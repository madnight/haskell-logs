00:01:53 <vincenz> dcoutts: wow, how long are you still planning on staying there?
00:02:07 <dcoutts> 'til end of April
00:02:36 <vincenz> 2oh
00:02:41 <vincenz> and you plan to move for that 1 month?
00:02:55 <dcoutts> dons: pushing Test.SmallCheck.Partial
00:03:09 <dons> cheers
00:03:17 <dons> dcoutts: into streams/smallcheck ?
00:03:20 <dons> or into our list repo?
00:03:24 <dcoutts> dons: list repo
00:03:36 <dons> i guess its just one module, right?
00:03:48 <dcoutts> yep
00:03:55 <dcoutts> dons: so all the Strictness bits should build now
00:04:16 <dcoutts> dons: try make strictness
00:05:34 <dons> ok. did we plan on being strict in all our loop !s states?
00:05:41 <dons> or should expose do that?
00:07:06 <dons> i thought we were supposed to be strict now explicitly in any state arg to loops? and Lazy should handle that?
00:07:21 <dcoutts> dons: it'd do no harm to !s the loop states
00:07:39 <dons> ok. might help too perhaps.
00:07:44 <dcoutts> expose just exposes the stream structure in recursive calls
00:08:14 <dcoutts> but since it's only on the recursive call sites, not on the top of each function then it doesn't force strictness
00:08:36 <dcoutts> dons: like the difference in the foldl' definitions
00:08:58 <dcoutts> so yes, we should !s!!1 ;-)
00:08:59 <dons> right.
00:09:25 <dcoutts> I can do that if you're looking at something else
00:09:46 <dons> ok. better pull my patches then.
00:10:06 <dons> yeah, i'll grab dinner, then see if this helps out the small benchmarks that had trouble.
00:10:09 * dcoutts darcs pulls
00:10:41 <dons> and we just depend on the normal ChasingBottoms lib?
00:10:47 <dcoutts> yes
00:11:00 <dons> ok. that's in chakcvs/darcs/streams/ too
00:11:08 <dcoutts> ok
00:11:16 <dons> and a fork of smallcheck. but nad says to just take over chasingbottoms, so we could just own it.
00:11:29 <dons> ah good. strictness is running now
00:11:36 * dons grabs some dinner.
00:12:04 <dcoutts> dons: we don't really need smallcheck except for the partial variant on it
00:59:09 <dcoutts> dons: pushed
01:02:05 <sjanssen> @hackage x11
01:02:05 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/x11
01:09:12 <ivanm> just remembered to do this from before:
01:09:14 <abz> ?poll-list
01:09:15 <lambdabot> ["EvilPoll","OperatingSystem","RestrictToOneVote","Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
01:09:16 <ivanm> Cale++
01:09:22 <ivanm> ddarius++
01:57:58 <hpaste>  vincenz pasted "woo" at http://hpaste.org/1115
01:58:15 <vincenz> \o/
01:59:18 <ivanm> and its meant to do what?... looks like C or Java, not haskell...
01:59:43 <vincenz> that is the ouput of the pretty printer after typecheck of ++C, all written in haskell
02:00:23 <vincenz> the code pasted?
02:00:26 <vincenz> it doesn't do anything worthwhile
02:00:29 <vincenz> at all
02:00:39 <ivanm> lol
02:00:47 <vincenz> what?
02:00:52 <vincenz> it typechecks, that's what matters
02:00:54 <ivanm> that it doesn't do anything
02:01:02 <vincenz> hmm
02:01:04 <ivanm> what's ++C? is it the same as C++?
02:01:07 <vincenz> no
02:01:11 <vincenz> it's c++ but better
02:01:13 * ivanm probably came in the middle of a discussion here
02:01:18 <vincenz> nope
02:01:27 <vincenz> but anyways
02:01:31 <vincenz> the point is, my tool
02:01:33 <vincenz> which does
02:01:42 <vincenz> (++C) -> [MY TOOL] -> (the lame code you see)
02:01:43 <vincenz> does work
02:01:54 <ivanm> a haskell tool to parse and check ++C code?
02:01:58 <vincenz> yes
02:02:54 <sjanssen> the :: * -> * -> * -> * -> *?
02:03:00 <ivanm> so you'd run it through your tool before compilation, as an extra checker to ensure correctnes?
02:03:30 <vincenz> not quite
02:03:36 <vincenz> sjanssen: yeah
02:03:47 <ivanm> sjanssen: wtf?
02:03:56 <vincenz> sjanssen: that one :)
02:04:02 <vincenz> the one with one function of 330 lines of code
02:04:17 <sjanssen> ivanm: vincenz's statement looked like a Haskell type signature
02:04:25 <sjanssen> so I asked a goofy question about it
02:04:34 <ivanm> ahhh, k
02:04:50 <vincenz> sjanssen: oh, I thought you were referring to my GADT
02:04:58 <sjanssen> my response is a kind declaration
02:05:01 <sjanssen> @kind Maybe
02:05:03 <lambdabot> * -> *
02:05:48 <vincenz> @kind Monad
02:05:50 <lambdabot> Class `Monad' used as a type
02:31:13 <kolmodin> dons, sjanssen, I`m running xmonad now..
02:31:54 <kolmodin> and fixed the ebuild so that xmonad shows up amongst the xsessions in your display manager
02:32:25 <kolmodin> it crashes though when I try to switch to my keyboard layout
02:32:49 <kolmodin> xmodmap .svorak # this kills it
02:33:47 <kolmodin> how about a wrapper that restarts it if it crashed, and saves output to logfiles by date
02:33:50 <kolmodin> ?
02:57:49 <mauke> .xsession: until xmonad; do sleep 1; done
02:58:39 <wolverian> er :)
03:00:08 <Stinger> does HSDL support sound?
03:00:59 <Stinger> or can anyone show me a haskell library for playing sounds, only need very basic .wav load and play
03:01:03 <Stinger> with windows support
03:04:25 <Lemmih> hsSDL has a binding to sdl-mixer.
03:10:45 <Stinger> how does that fare for windows installation? :)
03:48:30 <bringert> dcoutts_: you mentioned a spec for cabal configurations. is that online somewhere?
03:50:18 <kolmodin> cabal configurations?
03:50:31 <kolmodin> as in how to write .cabal-files?
03:51:13 <kolmodin> dcoutts went offline 2h30min ago
03:51:16 <bringert> ah
03:51:32 <bringert> no, it's about having multiple configurations in a single cabal file
03:51:54 <kolmodin> like if you'd want to build in different ways?
03:51:55 <bringert> for example to use base < 2.0 and fps >= 0.7, or base == 2.0
03:52:01 <bringert> yeah
03:52:02 <kolmodin> ah
03:52:20 <bringert> or using different CPP macros etc
03:52:27 <kolmodin> ok, haven't heard anything recently about it. but then again I don't hear everything :)
03:52:50 <kolmodin> I know there's been discussion on some mailing lists
03:53:26 <bringert> Igloo: what's the current spec for configurations in Cabal? Is it online somewhere? Is it ready enough for a SoC project to implement it?
03:54:08 <bringert> is this the latest one? http://www.mail-archive.com/cabal-devel@haskell.org/msg00282.html
03:54:09 <lambdabot> Title: Configurations proposal, take n
03:54:21 <kolmodin> bringert: dcoutts posted a mail to cabal-devel
03:54:37 <bringert> kolmodin: you know when?
03:54:59 <kolmodin> 25/10 2006
03:55:25 <bringert> ok, Igloo's mail is a little more recent
03:55:32 <bringert> 27 Nov 2006
03:55:59 <kolmodin> yeah
03:56:09 <bringert> I'll just go ahead and add a proposal, people can change it later
03:56:13 <kolmodin> aye
03:59:18 <resiak> Is there a straightforward way to discover which breed of base I have installed?
03:59:52 <kolmodin> ghc-pkg list base
04:02:02 <bringert> http://hackage.haskell.org/trac/summer-of-code/ticket/1131
04:02:04 <lambdabot> Title: #1131 (Implement Cabal configurations) - Haskell.org Google Summer of Code - Tra ...
04:06:00 <resiak> massively useful command! thank you!
04:07:01 <kolmodin> resiak: np :)
04:08:34 <MBH> hello
04:08:37 <MBH> everybody
04:08:40 <MBH> i am mbh
04:08:43 <MBH> and i have a question
04:08:47 <MBH> about haskell
04:08:53 <MBH> can somebody helb me pls
04:08:56 <MBH> ?
04:09:10 <Lemmih> maybe.
04:09:13 <Lemmih> it depends on
04:09:18 <Lemmih> what question you have.
04:12:29 <MBH> --solved
04:12:53 <kolmodin> MBH: http://www.catb.org/~esr/faqs/smart-questions.html#prune
04:12:54 <lambdabot> Title: How To Ask Questions The Smart Way
04:13:29 <MBH> KOLMONDIN  what
04:13:53 <kolmodin> MBH: some hints for future questions
04:14:29 <MBH> hm
04:15:59 <MBH> I'm having problems with my Windows machine. Can you help?
04:16:01 <MBH> ^^
04:16:11 <MBH> stupid question^^
04:17:31 <kolmodin> we're usually a bit more kind than that manual says
04:25:35 <twb> dons: ping?
04:27:08 <twb> dons: at http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons you have a small shell script.  Here is a version that requires fewer subprocesses: http://twb.ath.cx/tmp/dons.sh
04:27:10 <lambdabot> Title: Haskell hacking, http://tinyurl.com/ywdjsr
04:29:42 <twb> dons: also, the first two points (regexp, error checking) no longer hold.  test(1) now expects integers (via weak typing), and will crash if it doesn't get them.
04:30:00 * resiak hopes that xmonad is worth this upgrady hassle :)
04:33:25 <twb> Has anyone set something up so Hackage packages are automatically turned into .debs and uploaded to Debian?
05:00:53 <hpaste>  MathematicalOrc pasted "How interesting..." at http://hpaste.org/1116
05:01:23 <Orphi> I wanted to write a function with x -> Maybe y -> Maybe (x,y)
05:01:36 <Orphi> but then I did something we all do from time to time - I made it absurdly general!
05:02:08 <Orphi> and now... well, I'm not sure WHAT I've created. but it's interesting! lol
05:04:02 <opqdonut> isn't that just liftM2 (,)
05:04:06 <ivanm> Orphi: was your original function meant to be Maybe x -> Maybe y -> Maybe (x,y)?
05:04:09 <opqdonut> :t liftM2 (,)
05:04:11 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
05:04:18 <Stinger> not quite
05:04:19 <ivanm> or are you assuming x is a monad?
05:04:37 <Orphi> well, to begin with it was [x] -> [Maybe y] -> [Maybe (x,y)]
05:04:45 <Orphi> then I tried making BOTH arguments be Maybe
05:04:49 <opqdonut> isn't that just liftM2 (x,)
05:04:53 <Orphi> and then I replaced Maybe with ANY monad
05:05:02 <Orphi> and then I split it into two functions, as you can see now
05:05:29 <Orphi> ah... liftM2... I knew somebody would have done this before. ;)
05:05:31 <Stinger> @pl \x -> liftM2 (x,)
05:05:32 <lambdabot> (line 1, column 16):
05:05:32 <lambdabot> unexpected ","
05:05:32 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
05:05:57 <Stinger> @pl \x -> liftM2 $ (,) x
05:05:58 <lambdabot> liftM2 . (,)
05:06:18 <Orphi> :t zipWith $ liftM2 (,)
05:06:20 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => [m a1] -> [m a2] -> [m (a1, a2)]
05:06:30 <Orphi> trust Haskell! lol
05:06:36 <Stinger> :t liftM2 . (,)
05:06:39 <lambdabot>     Couldn't match expected type `a2 -> r'
05:06:39 <lambdabot>            against inferred type `(a, a1)'
05:06:42 <Syzygy-> > liftM2 (,) 3 5 :: (Maybe Int,Maybe Int)
05:06:43 <lambdabot>  Couldn't match expected type `Maybe Int'
05:06:56 <Syzygy-> > liftM2 (,) 3 5 :: Maybe (Int, Int)
05:06:57 <lambdabot>   add an instance declaration for (Num (Maybe Int))
05:07:11 <Syzygy-> > (liftM2 (,) 3 5) :: Maybe (Int, Int)
05:07:12 <lambdabot>   add an instance declaration for (Num (Maybe Int))
05:07:15 <Syzygy-> Or not...
05:07:18 <Botje> > liftM2 (,) (Just 3) (Just 5)
05:07:20 <lambdabot>  Just (3,5)
05:07:24 <Syzygy-> Oh, right.
05:07:34 <Syzygy-> > liftM2 (,) (Just 3) Nothing
05:07:36 <lambdabot>  Nothing
05:08:11 <Botje> > liftM2 (,) [1..3] [4..5]
05:08:13 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
05:08:26 <Orphi> > zipWith (liftM2 (,)) [Just 1, Just 2, Just 3] [Just 7, Just 8, Just 9]
05:08:27 <lambdabot>  [Just (1,7),Just (2,8),Just (3,9)]
05:08:31 <Botje> :)
05:08:33 <Orphi> > zipWith (liftM2 (,)) [Just 1, Just 2, Just 3] [Just 7, Just 8, Nothing]
05:08:35 <lambdabot>  [Just (1,7),Just (2,8),Nothing]
05:08:41 <Orphi> > zipWith (liftM2 (,)) [Just 1, Just 2, Nothing] [Just 7, Just 8, Just 9]
05:08:43 <lambdabot>  [Just (1,7),Just (2,8),Nothing]
05:08:48 <Orphi> ...works as required :)
05:09:38 <Orphi> now... WTH happens if I use another monad? o_O
05:10:17 <Orphi> ...is there some way to make lambdabot "remember" a function definition for a minute or two?
05:12:47 <Cale> Orphi: @let
05:12:51 <Cale> @let foo = 5
05:12:54 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
05:12:56 <Cale> > L.foo
05:12:58 <lambdabot>   Not in scope: `L.foo'
05:13:00 <Cale> er, oh
05:13:07 <Cale> it's broken, apparently
05:13:19 <Orphi> @let zipM = zipWith $ liftM2 (,)
05:13:20 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
05:13:26 <Orphi> ah... neat! :D
05:13:42 <Cale> That would work normally though.
05:13:47 <Orphi> lol. kk
05:14:09 <Orphi> zipWith $ liftM2 (,) $ [[1,2,3],[4,5,6],[7,8,9]] ["abc","def","ghi"]
05:14:18 <Orphi> > zipWith $ liftM2 (,) $ [[1,2,3],[4,5,6],[7,8,9]] ["abc","def","ghi"]
05:14:19 <lambdabot>  Couldn't match expected type `t -> m a1'
05:14:36 <Orphi> > zipWith (liftM2 (,)) [[1,2,3],[4,5,6],[7,8,9]] ["abc","def","ghi"]
05:14:38 <lambdabot>  [[(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')],[...
05:14:49 <Orphi> uh... what did I just do? :|
05:14:52 <Orphi> lol!
05:15:04 <Cale> $ doesn't have the proper associativity
05:15:13 <Orphi> > liftM2 (,) [1,2,3] "abc"
05:15:14 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
05:15:21 <Orphi> ...ok, that's...interesting...
05:15:42 <Cale> f $ g $ x = f . g $ x, unfortunately.
05:15:43 <Orphi> I wonder how it does that.
05:15:51 <Cale> How it does what?
05:15:57 <Orphi> Cartesian product.
05:16:06 <Orphi> I spent ages trying to work out how to make Haskell do that...
05:16:06 <Cale> Ah, that's the list monad.
05:16:31 <Orphi> you can do it with comprehensions, but since those are merely sugar, it should be possible without...
05:16:34 <Cale> liftM2 f x y = do u <- x; v <- y; return (f u v)
05:16:36 <resiak> and suddenly Cale's comments about the associativity of $ last night make sense
05:16:53 <Cale> resiak: :)
05:17:47 <Cale> So if we resugar the do-notation into list comprehension style, that's  liftM2 f x y = [f u v | u <- x, v <- y]
05:18:12 <Cale> Or if you want, we could write that out in terms of concatMap
05:18:38 <Orphi> do x <- y; z ==> y \x -> z
05:18:55 <Orphi> my word that hurts >_<
05:19:03 <Cale> y >>= \x -> z
05:19:13 <Orphi> ty
05:19:15 <Cale> and >>= is essentially concatMap
05:19:42 * Orphi binds mind...
05:19:50 <Botje> > liftM3 (,,) [1,2,3] "abc" ["foo","bar","baz"]
05:19:51 <lambdabot>  [(1,'a',"foo"),(1,'a',"bar"),(1,'a',"baz"),(1,'b',"foo"),(1,'b',"bar"),(1,'b...
05:19:58 <Orphi> OMG - even my powers of typing are failing me! o_O
05:20:53 <Orphi> do x0 <- x; y0 <- y; return (x,y) ==> x >>= \x0 -> y >>= \y0 -> return (x0,y0)
05:21:55 <Orphi> concatMap (\x0 -> concatMap (\y0 -> return (x0,y0)) y) x
05:21:58 <Orphi> ...or something...
05:22:11 <Orphi> my God, I think I need to sit down...
05:22:23 <resiak> you type standing up?
05:22:27 <Orphi> lol!
05:22:34 <Orphi> well... actually I *am* sitting down, so... hmm
05:22:54 <Orphi> by the way, just so the entire channel knows... I JUST ATE AN ENTIRE TERRY'S CHOCOLATE ORANGE!
05:23:02 <Cale> > replicateM 3 [0,1]
05:23:04 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
05:23:23 <Orphi> Cale: ok, now you're just scaring me...
05:23:53 * Orphi feels slightly nausious from too much chocolate
05:24:44 <Cale> > filterM (const [True,False]) "abcd"
05:24:45 <lambdabot>  ["abcd","abc","abd","ab","acd","ac","ad","a","bcd","bc","bd","b","cd","c","d...
05:25:53 * Orphi feels dizzy from too much monadic Haskell...
05:26:07 <resiak> @type filterM
05:26:09 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
05:26:37 <Orphi> @type replicateM
05:26:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
05:26:59 <Cale> > sequence [(+2),(*2),(^2)] 5
05:27:05 <Cale> > Control.Monad.sequence [(+2),(*2),(^2)] 5
05:27:07 <lambdabot>  [7,10,25]
05:27:19 <Orphi> ...da hell? o_O
05:27:30 <Cale> That's another monad entirely :)
05:27:37 <Orphi> ok Cale, you can stop now :P
05:27:39 <Cale> Specifically, the monad ((->) e)
05:27:49 <Cale> sequence :: [m a] -> m [a]
05:27:57 <Cale> sequence :: [e -> a] -> e -> [a]
05:28:24 <Orphi> what I was *actually* doing in the first place is writing a function plotter
05:28:29 <Cale> hehe
05:28:33 <Orphi> I want it to skip "undefined" points
05:28:37 <Cale> ah
05:28:43 <Orphi> and I wanted to make it so if one coordinate in undefine, they BOTH are
05:28:59 <Orphi> hence :: [Maybe x] -> [Maybe y] -> [Maybe (x,y)]
05:29:08 <Orphi> see? :)
05:29:17 <Cale> yeah
05:29:24 <Cale> I think
05:29:35 <Orphi> however... it seems 7 / 0 doesn't generate an exception, it just returns NaN
05:29:42 <Cale> right
05:29:47 <Cale> @type isNaN
05:29:49 <lambdabot> forall a. (RealFloat a) => a -> Bool
05:30:02 <Orphi> ...ok, time to go map isNaN over my list :}
05:30:25 <Orphi> I haven't ever actually tried exception catching in Haskell before anyway, so...
05:30:37 <Cale> Catching exceptions can only be done from IO anyway
05:30:43 <Cale> which makes it a pain
05:30:44 <Orphi> yeah, so I hear
05:30:56 <Orphi> but then, graphics can only happen in IO too...
05:31:15 <Orphi> here's a puzzle for you...
05:31:25 <Orphi> @type System.Environment.getArgs
05:31:27 <lambdabot> IO [String]
05:31:32 <Orphi> ...why?
05:31:43 <Cale> Because it's not always the same list of strings
05:31:56 <Orphi> it is during the execution of the program ;)
05:32:03 <Cale> Not necessarily
05:32:13 <Orphi> the program's arguments cannot change while it's running.
05:32:50 <Cale> withArgs :: [String] -> IO a -> IO a
05:33:33 <Orphi> @type System.Info.os
05:33:35 <lambdabot> String
05:33:45 <Orphi> see? the OS can't change while the program is running
05:33:57 <Orphi> and nor can the CLI args - yet they're in IO. go figure!
05:34:09 <Cale> withArgs locally runs an IO action with a different list of args.
05:34:35 <Orphi> ...ok...that's pretty bizzare...
05:35:00 <Cale> It's occasionally handy
05:35:05 <Orphi> sure
05:35:29 <Orphi> hmm... there was another monad-related question I had the other day...
05:35:35 * Orphi thinks
05:35:51 <Lemmih> GHCi is probably the most famous user of 'withArgs'.
05:36:44 <Orphi> ...nope, can't think what the question was.
05:36:58 <Orphi> was something about "why is feature X only available in IO, not an arbitrary monad"
05:37:04 <Orphi> but I can't remember what feature exactly.
05:37:21 * Orphi shrugs
05:37:39 <Orphi> > liftM2 (,) [1,2,3] "abc"
05:37:41 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
05:38:00 <Orphi> ...ok, how do I make that come out in a different order?
05:38:45 <Cale> hmm
05:38:48 <Cale> which order?
05:38:50 <Orphi> if both lists were infinite and I wanted to search the result, it would never terminate
05:38:56 <Cale> right
05:39:10 <Orphi> so... what, use newtype and write a new monad instance?
05:39:22 <Cale> you'd need to diagonalise. In that case, it's probably worth writing your own Cartesian product.
05:39:30 <Orphi> ok.
05:40:25 <Orphi> BTW... I have a couple of Haskell books now
05:40:35 <Orphi> I just read The Fun of Programming
05:40:44 <Orphi> I find something interesting about it...
05:40:51 <Orphi> some chapters are, like "wow, that's so cool!"
05:41:00 <Orphi> and other chapters are like "...and I care because...?"
05:41:28 <Orphi> I forget what chapter number it is, but I read the one about folds and unfolds so many times now
05:41:34 <Orphi> it still doesn't make a huge amount of sense
05:41:56 <Philippa> it'll make more sense as you find more examples
05:42:02 <Orphi> maybe
05:42:16 <Orphi> anybody know what \/ and /\ mean?
05:42:40 <Cale> maybe union and intersection
05:42:51 <Cale> or 'or' and 'and'
05:42:58 <Orphi> ah... maybe.
05:43:11 <Cale> depends on what that's ascii art for :)
05:43:18 <Orphi> lol!
05:43:38 <Orphi> I'm guessing it must be Boolean ops then - there aren't any sets involved.
05:44:05 <Orphi> but anyway, the whole chapter seems to be about proving some really obscure properties of folds and unfolds.
05:44:09 <Orphi> not sure why anybody would care...
05:44:41 <Orphi> I mean, for example, map (g . f) = map g . map f - that's a useful property
05:44:56 <Orphi> but the properties in this chapter don't look useful for anything
05:45:39 <dons> anyone following the fusion saga, we've got some initial numbers!
05:45:40 <dons> http://www.cse.unsw.edu.au/~dons/tmp/results.html
05:45:40 <lambdabot> Title: nobench: Haskell implementation shootout
05:45:46 <dons> Cale: you might be interested.
05:45:55 <dons> so 'ghc' is ghc with lists based on stream fusion.
05:46:01 <dons> and ghc-old is the current head, using build/foldr
05:46:04 <kolmodin> first day of the year with excellent weather. blue sky and 12C
05:46:06 <kolmodin> yay
05:46:22 <dons> kolmodin: hehe. that's scary
05:47:19 <kolmodin> :)
05:47:32 <kolmodin> I've added the LANGUAGE pragma to binary
05:47:44 <dons> ok. good
05:48:01 <dons> we should really write a paper on this for the haskell workshop, kolmodin
05:48:02 <kolmodin> I like Ian's proposal
05:48:09 <dons> esp. with the new bounds checking rules working
05:48:12 <kolmodin> dons: yeah, dcoutts where on to be earlier
05:48:20 <dons> ah good :-)
05:48:32 <kolmodin> good to know that I don't run out on stuff to do the next few years...
05:48:33 <kolmodin> :)
05:48:33 <dons> he and I are trying to cook up some papers to write. that's an obvious one to do.
05:48:37 <dons> hehe
05:49:03 <kolmodin> yeah, that almost became my master thesis
05:50:22 <kolmodin> dons: I've got a properly working ebuild for xmonad now
05:51:09 <kolmodin> and tried it on my laptop. works nice :)
05:51:14 <kolmodin> except I can use xmodmap
05:53:12 <Cale> dons: cool :)
05:53:43 <Orphi> um... what do the numbers mean?
05:54:01 <Igloo> bringert: The link at the start of http://hackage.haskell.org/trac/hackage/ticket/27
05:54:03 <lambdabot> Title: #27 (Configurations) - Hackage - Trac
05:56:31 <bringert> Igloo: I added a SoC proposal for it: http://hackage.haskell.org/trac/summer-of-code/ticket/1131
05:56:32 <lambdabot> Title: #1131 (Implement Cabal configurations) - Haskell.org Google Summer of Code - Tra ...
05:56:44 <bringert> Igloo: do you think it's a realistic SoC project?
05:57:15 <Igloo> bringert: I think so
05:57:40 <kolmodin> dons: it's nice to see that the old ghc in your benchmark is ghc 6.6 :)
05:57:50 <kolmodin> ghc 6.4.2 doesn't count any more? :)
05:58:06 <Igloo> ghc 6.4.2 is dead, Dave
05:58:17 <kolmodin> hah hah :)
06:00:33 * kolmodin tried to take the laptop outside in the sun. didn`t see a thing
06:02:59 <capisce> kolmodin: glossy monitor?
06:03:53 <hpaste>  drigz pasted "read lines from file into a list" at http://hpaste.org/1117
06:04:18 <drigz> can someone help me with this? i get monady-seeming errors that i don't understand
06:05:46 <kolmodin> capisce: it looks completely black :/
06:07:26 <capisce> kolmodin: hmm, does it work better if you sit in the shade?
06:08:16 <Igloo> drigz: Your accumulator is [String], not IO [String]
06:08:34 <kolmodin> capisce: there is no shade on my balcony
06:09:16 <drigz> Igloo: i just got it to compile, but i'm now worrying if building it backwards and reversing is the right thing to do?
06:09:29 <drigz> or should i do accum ++ [line]
06:09:31 <kolmodin> drigz: line 11 and 12 have errors too
06:09:43 <mauke> main = do { x <- readFile "base_exp.txt"; putStr x }
06:09:46 <drigz> but i think that will bump it up to O(n^2)
06:09:59 <capisce> kolmodin: nature sucks :/
06:10:03 <hpaste>  kolmodin annotated "read lines from file into a list" with "(no title)" at http://hpaste.org/1117#a1
06:10:12 <drigz> ?hoogle readFile
06:10:12 <lambdabot> Prelude.readFile :: FilePath -> IO String
06:10:13 <lambdabot> System.Win32.File.c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
06:10:13 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
06:10:20 <kolmodin> capisce: no doubt
06:10:52 <kolmodin> drigz: see what I changed? line 6 11 12
06:11:30 <mauke> main=readFile"base_exp.txt">>=putStr
06:12:06 <drigz> kolmodin: thanks!
06:12:16 <drigz> kolmodin: is the 'do' on the penultimate line necessary?
06:12:16 <hpaste>  kolmodin annotated "read lines from file into a list" with "a little more clear, perhaps" at http://hpaste.org/1117#a2
06:12:28 <kolmodin> drigz: no, my bad
06:14:00 <drigz> kolmodin: that's perfect, thanks
06:14:27 <kolmodin> np
06:14:47 <kolmodin> drigz: do you see why your old code didn't work?
06:14:53 <drigz> yeah
06:15:01 <drigz> return takes a normal type and IOs it
06:15:24 <drigz> and the <- takes an IO type and normals it
06:15:38 <drigz> (i don't understand monads at all, so i work this out with silly rules...)
06:16:40 <sioraiocht> drigz: a better way to think of it is that for IO a, evaluating it performs an IO action and then return something of type a
06:17:10 <sioraiocht> so <- evals the right side, performs any IO side effects and returns a value that is then assigned to the left side
06:17:38 <kolmodin> drigz: yup
06:17:48 <chessguy> mmm, i think 'bound' is a better word than 'assigned'
06:17:53 <drigz> that makes sense
06:18:08 <sioraiocht> chessguy: for sure, I couldn't think of the word
06:18:10 * sioraiocht is hungover.
06:18:11 <kpreid> Cale: Looked at what you posted. Looks good to me.
06:19:29 <kpreid> Cale: I wonder a bit about the outer do in writer; couldn't that be a regular let or where?
06:19:56 <Cale> iirc, yes, it could be
06:20:36 <mauke> man, parse errors are hard
06:23:08 <drigz> ?hoogle foldl1
06:23:09 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
06:23:09 <lambdabot> Data.List.foldl1' :: (a -> a -> a) -> [a] -> a
06:23:38 <ivanm> has anyone imiplemented the vigenere cipher in haskell?
06:23:52 <drigz> encode or decode?
06:24:02 <ivanm> crack/decode
06:24:09 <drigz> well, encode/decode or crack
06:24:26 <drigz> i wrote a crappy xor breaker for project euler
06:24:33 <drigz> but i'm not sure how useful it would be
06:24:49 <kpreid> Cale: What do you think about "writer takeLine putCount = loop 0 \n where loop n = ..."?
06:24:59 <ivanm> I could do it, but I'm mainly not sure of 1) finding the substrings with how far apart they are and 2) splitting the text into m separate blocks for an m-length keyword
06:26:11 <drigz> ivanm: you can find repeated substrings by looking for adjacent elements sharing the start in (sort . tails)
06:26:43 <Cale> kpreid: hmm, that's possibly more readable actually
06:26:58 <ivanm> drigz: how about the starting positions?
06:27:40 <drigz> ivanm: you mean finding the positions once you know the substring?
06:27:47 <ivanm> or do something like (sortBy snd . zip [1..] . tails)
06:28:05 <drigz> ivanm: yeah, or you could just search for it afterwards
06:28:19 <drigz> depends how big your input is
06:28:20 <ivanm> drigz: wanting to know that a substring foo starts at positions a, b and c in the text
06:28:51 <ivanm> i.e. if foo = "bar", then I find the letter b in bar as the 1st, 23rd and 127th positions in the ciphertext
06:28:55 <drigz> not sure of the best way to search for substrings in haskell, but i'm sure it's not too hard
06:29:02 <ivanm> drigz: ~150-200 chars
06:29:21 <kolmodin> err..
06:29:32 <ivanm> just a matter of, I could do this assignment by hadn, but why would I when I can get a computer to do it for me? ;-)
06:30:14 <drigz> ivanm: i think with any cryptography, you have to view the computer more as an aid rather than something that takes the input and spits out an answer
06:30:14 <sioraiocht> ivanm: doing the kasiski test
06:30:25 <ivanm> sioraiocht: yep
06:31:01 <ivanm> drigz: well, I've been given the list of substrings and their positions... just wanted to work out how I could do such a thing in haskell
06:31:32 <ivanm> mainly though, its splitting the text "abcabcabc" into ["aaa","bbb","ccc"]
06:31:53 <kpreid> Cale: seems to work
06:31:58 <drigz> ivanm: i have something to do that, i was asking about it here the other day
06:32:04 <kpreid> Cale: also, you forgot to give putEOF to the reader
06:32:17 <drigz> oh my bad, it's not on this computer
06:32:25 <Cale> oh, oops :)
06:32:45 <sioraiocht> haskell is awesome for crypto stuff
06:32:50 <Cale> I'd made that change after I'd already put it on the wiki.
06:32:56 <ivanm> drigz: the only way I can think of doing it is to repeatedly split it into the length/m chunks, then transpose it
06:32:58 <sioraiocht> I love that the Integer type is built in
06:33:13 <drigz> ivanm: i think that's what i was using
06:33:13 <ivanm> @hoogle mod
06:33:14 <lambdabot> Prelude.mod :: Integral a => a -> a -> a
06:33:15 <lambdabot> Prelude.module :: keyword
06:33:15 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
06:33:28 <kpreid> Cale: hm, not sure about the most consistent-with-your-style indenting of 'loop''s body when it's in a where clause
06:33:29 <ivanm> drigz: *sigh* I was hoping for a better way than that...
06:33:46 <ivanm> @hoogle [a] -> b -> [[a]]
06:33:47 <lambdabot> No matches, try a more general search
06:33:50 <ivanm> @hoogle [a] -> b -> [[c]]
06:33:51 <lambdabot> No matches, try a more general search
06:33:57 <ivanm> :(
06:34:21 <drigz> you can use unfoldr
06:34:52 <chessguy> ?hoogle typeable
06:34:52 <sioraiocht> wtf is unfoldr?
06:34:53 <lambdabot> Data.Typeable :: module
06:34:53 <alcojol> @hoogle a -> [a] -> Bool
06:34:54 <lambdabot> Data.Typeable.Typeable :: class Typeable a
06:34:54 <lambdabot> Data.Typeable.Typeable1 :: class Typeable1 t
06:34:55 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
06:34:55 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
06:35:26 <sioraiocht> ha, I'm sorry, but notElem is namespace pollution
06:35:54 <drigz> sioraiocht: like a version of iterate that terminates
06:35:55 <Cale> kpreid: like that...
06:36:14 <kpreid> Cale: I see
06:36:26 <sioraiocht> drigz: how does it terminate?
06:36:43 <kpreid> Cale: I'd assumed you wanted newlines after most =s :)
06:36:51 <drigz> sioraiocht: the function returns Maybe
06:37:04 <drigz> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#unfoldr
06:37:06 <lambdabot> http://tinyurl.com/yhrw65
06:37:24 <Cale> ah, the other newlines were mostly there because the indentation level became high if I didn't put them in
06:37:37 <kpreid> mm
06:37:52 <kpreid> my own style tends to "main = do <break> <one indent level> action ..."
06:39:26 <drigz> is #haskell logged anywhereL
06:39:28 <drigz> *?
06:39:32 <mauke> @where logs
06:39:33 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
06:39:46 <sioraiocht> drigz: so the function you pass should eventually return Nothing
06:39:49 <sioraiocht> ?
06:39:56 <SamB> drigz: check the topic, also ;-)
06:40:14 <drigz> yeah i just realised i could google 'drigz haskell'
06:40:15 <drigz> my bad
06:40:36 <lzc> hi all, i want to extract [String] from command line arguments and cast it into the form: [option]:pattern:[file] :: [String]:String:[String]. is it possible in *one* list comprehension?
06:40:47 <SamB> probably it is better to use meme's search functionality
06:41:15 <mauke> lzc: huh?
06:42:19 <chessguy> is it possible to tell the type of a function from within the program? like this
06:42:27 <lzc> mauke: i try to describe it clearly.....err
06:42:29 <chessguy> ?hoogle (a -> b) -> TypeRep
06:42:30 <lambdabot> No matches, try a more general search
06:42:31 <drigz> god, uncompressed irc logs are a good way to fill bandwidth...
06:42:51 <ndm> chessguy, for non-polymorphic functions, Data.Typeable has something
06:43:18 <chessguy> that's what i'm looking at, but i can't find it
06:43:25 <ndm> @where Data.Typeable
06:43:26 <lambdabot> I know nothing about data.typeable.
06:44:01 <ndm> @hoogle typeOf
06:44:02 <lambdabot> Data.Typeable.typeOf :: Typeable a => a -> TypeRep
06:44:02 <lambdabot> Data.Typeable.typeOf1 :: Typeable1 t => t a -> TypeRep
06:44:02 <lambdabot> Data.Typeable.typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
06:44:10 <ndm> chessguy, i think typeOf does it
06:44:43 <chessguy> hmm, there's no instance of Typeable for functions
06:45:00 <ndm> > typeOf not
06:45:01 <lambdabot>  Bool -> Bool
06:45:16 <ndm> chessguy, not in the haddock documentation - but it is there somewhere - and works fine
06:45:22 <chessguy> > typeOf (*)
06:45:24 <lambdabot>  Integer -> Integer -> Integer
06:45:28 <chessguy> nice
06:45:31 <ndm> > typeOf id
06:45:32 <lambdabot>  Add a type signature
06:47:00 <chessguy> > typeOf (*) == a -> b -> Integer
06:47:00 <lambdabot>  Parse error
06:47:08 <drigz> > transpose . takeWhile (not.null) . unfoldr (Just . splitAt 3) $ [1..11]
06:47:09 <lambdabot>  [[1,4,7,10],[2,5,8,11],[3,6,9]]
06:47:14 <drigz> ivanm: still need the code?
06:47:29 <lzc> okay,  i want to split a String list into several ones. if predicates are given , is it possible to make it in one list comprehension?
06:47:40 * SamB wonders why he gets spam in japanese and/or chinese...
06:47:43 <ivanm> drigz: wouldn't mind at least seeing how you did it
06:47:56 <drigz> ivanm: it's just above what i just said
06:47:58 <SamB> at least, I think it be spam
06:48:13 <chessguy> > typeOf (*) == Integer -> Integer -> Integer
06:48:13 <lambdabot>  Parse error
06:48:26 <ndm> SamB, i do too - often to the hoogle -at- haskell address
06:48:28 <ivanm> drigz: yours just decrypted and that's it?
06:48:31 <chessguy> > (typeOf (*)) == (Integer -> Integer -> Integer)
06:48:32 <lambdabot>  Parse error
06:48:33 <drigz> it was written by quicksilver
06:48:55 <drigz> ivanm: mine did a poor mans version of frequency analysis and assumed that the most common character was space
06:48:59 <ndm> chessguy, its displaying something - that isn't haskell syntax
06:49:14 <SamB> yeah, it seems to be advertising some event that began yesterday
06:49:36 <drigz> ivanm: it was for an xor cipher so every character was encrypted
06:49:38 <xs> is there a nice way of embedding Data.ByteString.ByteString constants in my code? equivalent to "foo" for String.
06:49:42 <ivanm> drigz: ahhh, k... we're told to ignore spaces
06:49:44 <drigz> and i knew the keylength in advance
06:49:57 <drigz> ivanm: you could try the same with e but it'd be dodgy
06:50:04 <ivanm> fair enough... so quicksilver did one as well?
06:50:04 <chessguy> > (typeOf (*)) == TypeRep (Integer -> Integer -> Integer)
06:50:05 <lambdabot>  Parse error
06:50:18 <ivanm> drigz: "same with e" <- what's e?
06:50:25 <ivanm> oh, most common char
06:50:47 <ivanm> nah, wanting to use mutual index of coincidence, have frequencies of letters to use
06:51:49 <drigz> it probably won't be so easy to automate that
06:52:33 <drigz> you could try, for a given key letter, working out the frequencies and getting the sum of the errors between that and the expected frequencies
06:52:36 <drigz> and minimise that sum
06:53:08 <ivanm> nah, I'm told how to do it
06:54:01 <ivanm> just needed to know how to get the common substrings and their locations for kasiskis test, and then how to split the cipher text up into the m shifted texts
06:55:48 <drigz> ?hoogle iterate
06:55:49 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
06:56:44 <drigz> > reverse . takeWhile (/=0) . iterate (`div` 10) $ 162534
06:56:45 <lambdabot>  [1,16,162,1625,16253,162534]
06:57:08 <ivanm> isn't that the same as prefix?
06:57:23 <ivanm> hmmm.... not quite...
06:57:41 <drigz> ?hoogle prefix
06:57:42 <lambdabot> Distribution.Simple.Configure.prefix :: LocalBuildInfo -> FilePath
06:57:42 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
06:57:42 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
06:57:59 <drigz> it's the same as tails but for numbers
06:58:03 <Botje> > map read $ inits $ show 162534
06:58:04 <lambdabot>  Exception: Prelude.read: no parse
06:58:13 <Botje> > map read $ tail$ inits $ show 162534
06:58:13 <ivanm> drigz: yeah, I get that now...
06:58:14 <lambdabot>  [1,16,162,1625,16253,162534]
06:58:31 <ivanm> drigz: is that meant to be for me?
06:58:36 <drigz> no
06:59:03 <sioraiocht> drigz: You're on like, a whole other level of function composition than I could ever to understand
06:59:59 <drigz> really? i only started with haskell on tuesday...
06:59:59 <ivanm> drigz: good, cos I couldn't work out how that related to the vigenere ;-)
07:00:12 <ivanm> drigz: and you already have a vigenere decryptor?
07:00:17 <drigz> i think it's all my experience writing stupidly long screen filling unix command lines
07:00:20 <integral> nmm
07:00:30 <sioraiocht> drigz: Maybe I'm just stupid, then ;)
07:00:51 <drigz> sioraiocht: i like to think that using haskell automatically makes us clever
07:00:57 <sioraiocht> ha
07:01:09 <sioraiocht> drigz: what do you use it for, mainly?
07:01:21 <drigz> currently, i'm trying to do project euler problems with it
07:02:12 <sioraiocht> ah.  I use it for crypto.....and as a really good desk calculator..
07:02:41 <Botje> drigz: heh, so am I. how much did you solve?
07:03:50 <drigz> i got to about 34% with python, and then i did a couple of the easy starter ones and maybe 2 or 3 that i hadn't done before in haskell
07:06:38 <Botje> I'm at 54% atm
07:07:07 <drigz> Botje: nice!
07:07:47 <drigz> ?hoogle ceiling
07:07:47 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
07:08:48 <shapr> Oooh, cool error message:  "Constraint is no smaller than the instance head"
07:09:08 <chessguy> shapr: that's a new 6.6 one i think
07:09:59 <shapr> It's cute!
07:10:04 <drigz> ?hoogle /
07:10:04 <lambdabot> Prelude.(/) :: Fractional a => a -> a -> a
07:10:05 <lambdabot> Array.(//) :: Ix a => Array a b -> [(a, b)] -> Array a b
07:10:05 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
07:10:23 <hpaste>  ScriptDevil pasted "GuessGame.hs:19:16: parse error (possibly incorrect indentation)" at http://hpaste.org/1118
07:10:39 <scriptdevil> ^^^^^^... that one... anybody?
07:10:55 <shapr> hiya scriptdevil! How are you enjoying Haskell?
07:11:02 <scriptdevil> shapr: loving it..
07:11:17 <chessguy> scriptdevil: what error are you getting, and on what line?
07:11:26 <chessguy> oh, sorry
07:11:32 <scriptdevil> chessguy: that is the heading
07:12:16 <scriptdevil> shapr: this time stuff seems to be making more sense... finally i am begining to see haskell is elegant
07:12:59 <chessguy> scriptdevil: you want your if to be on the same level as the let
07:13:08 <chessguy> and the then and else lines should match it
07:13:30 <scriptdevil> yeah... now i see.. thanks.. i missed in
07:13:31 <Stinger> the problem with functional languages
07:13:44 <chessguy> no, you don't need the in
07:13:59 <Stinger> is that you spend so much time trying to get some massively complicated operation into one small concise statement :)
07:16:17 <SamB> Stinger: you wish it took less time?
07:16:31 <dmwit> The real bug is that you tell the user [1..10] but pick a number in [1..100]. ;-)
07:16:47 <Stinger> no no I mean you can write some massive crap that works fine
07:17:02 <Stinger> but I feel obligated to make it elegant :D
07:17:18 <scriptdevil> chessguy: i get the same error with improper indentation at 19:12
07:17:32 <SamB> oh, you wish the language did not compell you to refactor mercilessly?
07:17:34 <scriptdevil> Stinger: ... you r welcome..
07:18:04 <scriptdevil> Stinger: anyway.. isnt it important to get to know the basics first before going of elegance??
07:18:36 <SamB> scriptdevil: probably if you can write the massive crap, you have enough basics to try for elegance
07:18:48 <dmwit> :t read
07:18:51 <lambdabot> forall a. (Read a) => String -> a
07:19:20 <Stinger> I'll try and do point free stuff when I don't really have to
07:19:26 <scriptdevil> i dont know why the error is in 19:12.. looks neat to me
07:19:58 <araujo> morning!
07:20:03 <hpaste>  ScriptDevil annotated "GuessGame.hs:19:16: parse error (possibly incorrect indentation)" with "GuessGame.hs:19:12: parse error (possibly incorrect indentation)" at http://hpaste.org/1118#a1
07:20:04 <dmwit> scriptdevil: Did you do both the extra "in" and deleted indentation?
07:20:05 <SamB> Stinger: there is a reason we jokingly refer to point-free code as "pointless" code
07:20:08 <Stinger> SamB, yeah pretty much :)
07:20:15 <scriptdevil> dmwit: no..
07:20:22 <scriptdevil> i repasted that
07:20:29 <SamB> Stinger: also, have you seen @pl?
07:20:31 <dmwit> then and else have to be indented from if
07:20:47 <Stinger> SamB, yeah but thats cheating ;D
07:20:49 <dmwit> (I think.)
07:20:54 <SamB> Stinger: is it?
07:20:55 <hpaste>  chessguy annotated "GuessGame.hs:19:16: parse error (possibly incorrect indentation)" with "compiles for me under ghc 6.6" at http://hpaste.org/1118#a2
07:21:10 <chessguy> scriptdevil: ^^
07:22:14 <scriptdevil> dmwit: i know that.. but emacs gave this as the sole indentation.. so i thought this was acceptable
07:22:46 * dmwit shrugs
07:22:47 <chessguy> scriptdevil: doesn't work though
07:23:04 <scriptdevil> chessguy: .... i am compelled to use some other editor.... how dare it say wrong stuff.. the mode is buggy
07:23:08 <SamB> scriptdevil: sometimes, it isn't really caused by incorrect indentation
07:23:26 <SamB> hence "(possibly incorrect indentation)"
07:23:46 <SamB> not "(incorrect indentation)" or "incorrect indentation"
07:23:56 <hpaste>  ScriptDevil annotated "GuessGame.hs:19:16: parse error (possibly incorrect indentation)" with "Why does this work??" at http://hpaste.org/1118#a3
07:24:07 <scriptdevil> SamB: ^^^^^^^^^^^^^^^^^^
07:24:25 <SamB> scriptdevil: what, you want me to actually look at it?
07:24:57 <dmwit> Are the indenting rules different in do blocks?
07:25:02 <dmwit> That would seem a bit odd to me.
07:25:27 <chessguy> they're not
07:25:54 <scriptdevil> SamB: yeah.. please.. i want the basics as hard as electron beam welded diamonds
07:26:15 <scriptdevil> chessguy: why did you comment out linebuffering??
07:26:24 <chessguy> in his original code, the if was being interpreted as a sub-block of the let
07:26:34 <chessguy> scriptdevil: not needed for ghc
07:26:56 <SamB> ah
07:26:57 <SamB> I see it now
07:27:01 <scriptdevil> ok.. what about the second.. my second paste??
07:27:27 <chessguy> the one you just pasted now, of completely different code?
07:27:32 <SamB> scriptdevil: yeah, haskell-mode is horrible at indenting stuff in "do" blocks
07:27:51 <chessguy> since the if is indented, it again interprets it as a sub-block, and this time, it's right
07:28:09 <scriptdevil> SamB: is vim haskell mode any better?
07:28:19 <scriptdevil> i hate vi but.. am willing to switch
07:28:21 <dmwit> Not really.
07:28:40 <dmwit> (I haven't found a working Haskell indent file yet.)
07:28:53 <scriptdevil> chessguy: no the one where i unindented if
07:29:20 <scriptdevil> dmwit: does yi indent??
07:29:42 <dmwit> dunno
07:29:46 <SamB> indentation is non-trivial
07:29:59 <lekro> why does Prelude.maximum need so much stack space in ghci 6.6 that maximum [1..1000000] gives a stack overflow?
07:30:04 <SamB> however, haskell-mode still could do bettter with do blocks
07:30:22 <SamB> lekro: because it is implemented with the wrong fold
07:30:38 <SamB> probably...
07:30:47 <SamB> @src maximum
07:30:48 <lambdabot> maximum [] = undefined
07:30:48 <lambdabot> maximum xs = foldl1 max xs
07:31:28 <SamB> :t foll1
07:31:32 <lambdabot> Not in scope: `foll1'
07:31:35 <SamB> :t foldl1
07:31:37 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:31:43 <SamB> @hoogle (a -> a -> a) -> [a] -> a
07:31:44 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
07:31:44 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
07:31:44 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
07:31:49 <lekro> > foldl1 max [1..1000000]
07:31:51 <lambdabot>  1000000
07:31:55 <lekro> > foldr1 max [1..1000000]
07:31:58 <lambdabot>  Exception: stack overflow
07:32:11 <SamB> @hoogle foldl1'
07:32:11 <lambdabot> Data.List.foldl1' :: (a -> a -> a) -> [a] -> a
07:32:14 <SamB> ah.
07:32:24 <lekro> in ghci 6.6 both statements results in a stack overflow
07:32:28 <lekro> -s
07:32:29 <SamB> > foldl1' max [1..1000000]
07:32:30 <lambdabot>  1000000
07:33:18 <SamB> maybe GHC is being clever...
07:33:58 <SamB> but "foldl1' max" works fine in ghci
07:35:05 <lekro> thanks
07:35:11 <SamB> the difference between foldl1 and foldl1' is that foldl1' is strict in the accumulator
07:39:14 * ndm needs to think of a good name for his paper - something he sucks at
07:40:03 <wolverian> ndm, yeah, that's not a very good name.
07:40:05 <kolmodin> ndm: names are hard
07:40:56 <ndm> :(
07:41:16 <kolmodin> a friend just offered me a cruise if I could come up with a name for his company
07:41:33 <ndm> "Safe Pattern Matching" is the best I have so far, with "A Static Checker for Haskell" as the subtitle
07:41:42 <kolmodin> "Catch This!"
07:41:59 <ivanm> kolmodin: what's the company do?
07:42:16 <kolmodin> http://oskar.edespong.se/dump/namn.pdf -- it's in swedish
07:42:20 <mauke> Gotta match them all!
07:42:43 <ndm> hmm, i want something that says what the paper is
07:42:47 <kolmodin> "One app to Catch them, one app to.."
07:43:17 <Philippa> one operator to bind them, surely?
07:43:22 <mauke> This Is A Paper
07:43:34 <kolmodin> Philippa: haha, exactly
07:43:38 <Philippa> ndm: Safe Pattern Matching tempts me to abbreviate it SPaM
07:43:53 <kolmodin> ivanm: the company does many many things..
07:44:07 <ndm> Philippa, not the meaning i'm after ;)
07:44:07 <ivanm> lol, a bit hard to make up a name then, isn't it
07:44:32 <Philippa> what does it check that's new, anyway?
07:45:05 <ndm> Philippa, it proves that your program won't crash at runtime with a pattern match error
07:45:09 <Philippa> how much of the existing work've you gone through? Are there any reasonably well-known papers you can make a reference to
07:45:14 <Philippa> so it proves your patterns're total
07:45:28 <pejo> Philip Wadler should blog about finding good names for papers, sharing his knowledge with the rest of the world.
07:45:30 <Philippa> does it handle guards? :-)
07:45:32 <ndm> Philippa, but allows you to have incomplete patterns - you can use head/tail etc
07:45:47 <ndm> Philippa, it handles Haskell 98 + a bit more
07:46:20 <Philippa> presumably by doing something akin to flow analysis? You can probably get a slightly more interesting title out of that
07:46:25 <ndm> "Proveable Partial Patterns"
07:46:36 <ndm> Philippa, only in the loosest sense is it flow analysis
07:47:13 <ndm> "Preconditions for Proveable Partial Patterns"
07:47:24 <ndm> since it does operate by generating precnoditions
07:48:11 <Philippa> yeah, but that mostly makes me think "probably a naive dependant type system or a kludge for one". Of course, arguably it's the latter...
07:48:33 <ndm> maybe
07:48:44 <ndm> but rather than go all dependent type, you just fire it off and forget
07:49:52 <Philippa> yeah, you're doing inference in exchange for what's presumably an incomplete analysis
07:49:57 <ndm> yep
07:50:07 <ndm> are there any dependent type inference stuff?
07:50:17 <Philippa> Epigram does shitloads of inference
07:50:32 <ndm> yes, but i'd hardly class it as an inference based system
07:50:49 <ndm> it infers in between your definitions, but not the original definitions
07:50:56 <Philippa> have you actually used it? It's surprising the stuff it will figure out for you
07:51:03 <ndm> i used it a bit
07:51:11 <Philippa> nor does Haskell - it doesn't define your datatypes for you
07:51:17 <ndm> but not that deep at all
07:51:21 <ndm> true
07:51:48 <Philippa> the amount of actual inference Epigram does is more than Haskell, not less
07:52:04 <yshhq> @hoogle from
07:52:05 <lambdabot> Maybe.fromJust :: Maybe a -> a
07:52:05 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
07:52:05 <lambdabot> Numeric.fromRat :: RealFloat a => Rational -> a
07:52:14 <ndm> oh yes, i realise that
07:52:20 <yshhq> @hoogle to
07:52:20 <lambdabot> Char.toLower :: Char -> Char
07:52:21 <lambdabot> Char.toUpper :: Char -> Char
07:52:21 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
07:52:38 <yshhq> @hoogle fromInteger
07:52:39 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
07:52:45 <yshhq> @hoogle from*
07:52:46 <lambdabot> Hoogle Error: Parse Error: Unexpected character '*'
07:53:30 <Philippa> and an awful lot'll come of having a decent-sized predefined library, too - a batch of pre-existing constraints it can work from, if you like. It does tend to know what it's looking for in order to prove something total...
07:53:33 <SamB> ndm: do you happen to know malcolmw's stance on type-system extensions?
07:53:35 <yshhq> @hoogle "from.*"
07:53:35 <lambdabot> Hoogle Error: Parse Error: Unexpected character '"from.*"'
07:53:42 <yshhq> @hoogle from
07:53:43 <lambdabot> Maybe.fromJust :: Maybe a -> a
07:53:43 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
07:53:43 <lambdabot> Numeric.fromRat :: RealFloat a => Rational -> a
07:54:19 <yshhq> @help hoogle
07:54:19 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
07:54:30 <ndm> @where hoogle
07:54:31 <lambdabot> http://www.haskell.org/hoogle
07:54:37 <Philippa> tbh, I suspect most of your issues with Epigram have more to do with it being a total language :-)
07:54:44 <ndm> yshhq, use teh web interface and it will give you more answers
07:54:59 <yshhq> ok
07:55:02 <ndm> SamB, i would guess not overly fussed - they are rarely as useful as many people think
07:55:16 <ndm> SamB, and they hamper Hat etc - why?
07:56:00 <Philippa> I tend to find it rare that I write something in excess of a KLoC without having at least one good use for an extension, FWIW
07:56:16 <Philippa> and that's even if I didn't have a good use for ST somewhere, which begs one all on its own
07:56:27 <SamB> oh, I was hoping I might be able to contribute some code using them to polyparse... I didn't think it was likely, though.
07:56:58 <ndm> SamB, i would say unlikely - which extension were you after
07:57:10 <SamB> ndm: that least-likely of extensions
07:57:17 <SamB> functional dependencies
07:57:25 <SamB> I don't actually *like* them
07:57:46 <ndm> SamB, he is probably reasonably open to that - although still unlikely - it won't work on nhc/Yhc, which is his compilers
07:58:16 <SamB> figured
07:58:43 <SamB> do either/both have Data.ByteString, at least?
07:59:04 <ndm> SamB, nhc has ByteString, but its a lot slower than String
07:59:10 <SamB> ah.
07:59:20 <SamB> how does that work?
07:59:25 <SamB> bad optimizer?
07:59:31 <SamB> (no optimizer?)
07:59:34 <ndm> its hyper optimised for GHC
07:59:45 <SamB> hmm.
07:59:58 <ndm> some times they define something as a foldr because GHC can fuse it, which is actually less efficient unless you have GHC's rules etc
08:00:20 <SamB> so should there be a "basic" version and a "RULES happy" version?
08:00:37 <ndm> SamB, malcolm wrote a basic version, just using String, and it was about 1000 times faster
08:01:01 <SamB> ndm: that is pretty basic alright
08:01:10 <SamB> how did the memory usage compare?
08:01:38 <ndm> i would guess worse
08:01:45 <SamB> me too
08:02:46 <SamB> see, his ELF parsing library uses [Word8] to store the data
08:11:19 * shapr reads about Data.Binary
08:12:08 <yshhq> @hoogle guard
08:12:09 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
08:12:09 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
08:12:09 <lambdabot> Language.Haskell.TH.Guard :: data Guard
08:15:52 <shapr> I'm looking at the SYB Binary deriving code, it returns text, right?
08:15:56 <drigz> ?hoogle (a, b) -> (b, a)
08:15:57 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
08:16:39 <shapr> Is there some way to do SYB like Template Haskell so I get executable code without pasting into a textfile?
08:16:43 <drigz> ?djinn (a, b) -> (b, a)
08:16:43 <lambdabot> f (a, b) = (b, a)
08:17:26 <ndm> shapr, yes it does
08:17:28 <_dolio> ?type snd &&& fst
08:17:30 <lambdabot> forall a b. (a, b) -> (b, a)
08:17:37 <ndm> shapr, if you look at that, instead look at my derive libarary
08:17:42 <shapr> ?
08:17:47 <shapr> @where ndmderive
08:17:48 <lambdabot> I know nothing about ndmderive.
08:17:53 <ndm> @where+ derive http://www.cs.york.ac.uk/fp/darcs/derive
08:17:53 <lambdabot> Done.
08:20:38 <shapr> Ah, so I can use the Binary deriving code in your library instead of cut'n'paste?
08:21:28 <ndm> shapr, you can use my code instead of theirs - but you still may need a cut and paste
08:21:38 <shapr> Why so?
08:21:49 <ndm> shapr, but its a better engineered version, so if you are trying to extend it into Template Haskell may go easier
08:22:06 <ndm> shapr, oh - you mean do a templeate haskell code splice? that may well work
08:22:23 <shapr> I'd thought about that, but really I just want a way to derive Binary with as little work on my part as possible.
08:23:08 <ndm> that derive library is likely to be your best start - if you manage to hook up template haskell please let me know
08:23:19 <ndm> you could derive it at runtime, but would be slow
08:23:40 <ndm> i.e. write instance Data a => Binary a
08:24:19 <shapr> One of the steps to make binary serialization the default in HAppS is to find a way to make it easy for users to create or derive Binary instances for their own datatypes.
08:24:22 <ndm> my library is designed to support that
08:24:41 <ndm> well deriving Data, Typeable would work, if you did that way
08:27:29 <shapr> ndm: ?
08:28:22 <ndm> shapr, you could write instance Data a => Binary a where ... - and write an instance that way
08:28:36 <ndm> shapr, everytime they wanted to save binary data would invoke SYB on their data and save it that way
08:28:39 <shapr> ah
08:29:20 <SamB> hmm?
08:29:30 * SamB does not think that sounds quite right.
08:30:02 <SamB> that sounds like it involves -fallow-incoherent-instances
08:30:21 <shapr> ndm: You're talking about using TH to splice in the result of derive from your library?
08:31:23 <SamB> shapr: he was talking about that
08:31:44 <SamB> shapr: now he seems to be talking about crazy schemes involving incoherent instances
08:31:50 <ndm> shapr - two distinct choices
08:32:09 <ndm> 1) run my library at compile time, using SYB/Template Haskell at compile time
08:32:24 <ndm> 2) run my library at runtime, using SYB only, and overlapping instances
08:32:44 <ndm> 3) turn my library into a preprocessor - i intend to do this at some point
08:33:23 <ndm> 4) learn to count to 2
08:34:47 <SamB> could you make your library/preprocessor into a replacement for that thing... the horrible one?
08:36:07 <ndm> SamB, drift - i definately want to
08:36:29 <ndm> SamB, would be a nice project to hack, if you wanted?
08:36:33 <SamB> i.e., having derivings return an AST
08:36:43 <ndm> yep, all possible
08:36:50 <ndm> although what would an AST over a string give you?
08:37:08 <ndm> i can see you might want to return a function, to execute at runtime, or a string to paste in at compile time
08:37:15 <SamB> it would save you from having to prettyprint
08:37:34 <SamB> also, TH doesn't support strings...
08:37:41 <ndm> perhaps, although i think prettyprinting is easy enough - and an AST would require extra work
08:37:48 <ndm> ah, now thats a good reason to return an AST
08:38:06 <SamB> well, I mean, the framework could take care of prettyprinting/compiling/converting to TH
08:38:24 <ndm> yep, all good things
08:38:38 <ndm> i think thats important - the framework should do as much of that as it can
08:38:54 <SamB> personally I think it is stupid to have lots of similar, but not reusable, prettyprinters in the code for various derivings
08:38:55 <ndm> and then should put them in a tool which auto-invoke GHCi, a template haskell and a runtime only variant
08:39:02 <shapr> Building SYB instances at compile time sounds best to me.
08:39:04 <ndm> very much agreed
08:39:18 <ndm> shapr, with Template Haskell or a preprocessor?
08:39:23 <shapr> I don't care.
08:39:31 <SamB> ndm: it depends on what compilers you are using
08:39:44 <shapr> instance (Works a) => Spiffy a where ...
08:39:49 <ndm> SamB, true - i'd like it to be powerful enough to do anything
08:39:56 <SamB> it should be made fairly painless to switch
08:40:03 <ndm> agreed once more
08:40:12 <ndm> all it needs is someone to give it some hacking time
08:40:15 <SamB> (its okay if the tool only runs in GHC, though)
08:40:21 <SamB> hmm.
08:40:21 <ndm> i don't think its all that much effort
08:40:45 <ndm> SamB, yes - you require GHCi at "generate the code" time, but not at runtime
08:40:47 <SamB> does haskell-src-exts do what we'd need from a syntax tree?
08:41:13 <ndm> SamB, i don't know - i deliberately defined an abstraction over SYB so we can switch in different abstractions
08:42:02 <ndm> i would hope so
08:42:33 * SamB wonders if other compilers include the TH library...
08:43:00 <SamB> (it occurs to me that that doesn't actually require GHC)
08:43:18 <ndm> they don't
08:44:04 <ndm> if either of you two want to submit patches, i'd be grateful
08:44:06 <SamB> now, the syntax requires GHC, and the primary splicings require GHCi support
08:44:23 <ndm> i was going to release next week
08:44:57 <SamB> hmm.
08:45:33 <SamB> oh, did I mention I think that drift's replacement should have plugins?
08:45:41 * SamB has to do the dishes...
08:46:02 <ndm> SamB, i do want it to be a drift replacement
08:46:19 <ndm> and some kind of simple textual syntax would be wonderful, so you can add more processors at runtime
08:48:25 <ndm> actually, once you depend on GHCi at generation time, plugins are quite easy
08:54:50 <ndm> how do you cite Simon Peyton Jones in bibtex
08:55:02 <ndm> i.e. get his surname as "Peyton Jones", not "Jones"
08:55:37 <piis3141> {Peyton Jones} ?
08:56:17 <ndm> @karma+ piis3141 -- thanks!
08:56:18 <lambdabot> piis3141's karma raised to 1.
09:11:57 <yshhq> @hoogle log
09:11:58 <lambdabot> Prelude.log :: Floating a => a -> a
09:11:58 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
09:11:58 <lambdabot> GHC.ConsoleHandler.Logoff :: ConsoleEvent
09:12:11 <yshhq> @src logBase
09:12:11 <lambdabot> Source not found. Where did you learn to type?
09:12:57 <yshhq> @source Prelude
09:12:57 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
09:18:33 <yshhq> @src takeWhile
09:18:33 <lambdabot> takeWhile _ []                 =  []
09:18:34 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
09:18:34 <lambdabot>                    | otherwise =  []
09:19:52 <alcojol> @src rnf
09:19:53 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:25:53 <stepcut> alcojol: rnf is from a type class, so there are multiple definitions
09:26:02 <stepcut> instance (NFData a, NFData b) => NFData (a,b) where
09:26:02 <stepcut>   rnf (x,y) = rnf x `seq` rnf y
09:26:30 <alcojol> yes
09:26:35 <Saizan> rnf == reduce to normal form?
09:26:42 <stepcut> Saizan: yes
09:26:43 <alcojol> is not possible ask for one of them?
09:27:28 <Saizan> you can put the name of the type
09:27:47 <stepcut> alcojol: no idea
09:28:01 <Saizan> ?src Maybe return
09:28:02 <lambdabot> return              = Just
09:28:56 <alcojol> uhmm
09:29:04 <alcojol> ?src rnf Bool
09:29:05 <lambdabot> Source not found. You speak an infinite deal of nothing
09:29:08 <alcojol> ops
09:29:14 <alcojol> ?src Bool rnf
09:29:15 <lambdabot> Source not found. You type like i drive.
09:29:26 <Saizan> src doesn't have so many definitions
09:29:28 <stepcut> I think @src only imports some subset of the libraries
09:29:50 <stepcut> Saizan: any idea how @src  gets populated ?
09:30:14 <arke> happy caturday!
09:30:37 <stepcut> :(
09:30:55 <Saizan> stepcut: mmh, no, i suspect that's not automated
09:31:23 <Saizan> ?help src
09:31:24 <lambdabot> src <id>. Display the implementation of a standard function
09:31:54 <Saizan> well, you can darcs get lambdabot's source :)
09:32:23 <stepcut> it would be nice if haskell-mode had a command that would take you to the source of a standard function :-/
09:32:42 <stepcut> of course, there is usually two or three layers of abrstraction before you get to the actual source in GHC
09:33:21 <Saizan> some of the @src definitions are from the report
09:33:28 <shapr> @yarr!
09:33:29 <lambdabot> Where d' all t' pirates come from?
09:33:29 <lambdabot> Great Yarrmouth!
09:33:41 <Saizan> @src splitAt
09:33:42 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
09:35:35 <sioraiocht> @src map
09:35:36 <lambdabot> map _ []     = []
09:35:36 <lambdabot> map f (x:xs) = f x : map f xs
10:05:40 <Gwern> hey, in a data type declaration, what on earth does ", leftWidth     :: {-# UNPACK #-} !Rational" mean?
10:06:19 <Gwern> (specifically, how do exclamation marks affect the type?)
10:06:28 <Botje> strictness.
10:06:43 <Botje> the rational will always be evaluated when the constructor is called
10:07:13 <Gwern> and the unpack pragma?
10:07:27 <shapr> It means unbox it.
10:08:05 <Gwern> guess I'd better look up what unboxing is
10:08:13 <shapr> Well, lists usually just hold pointers to the actual thing.
10:08:24 <shapr> If you unbox them, then the real value is there in the list.
10:08:37 <Gwern> so it's an efficiency thing?
10:08:50 <Botje> yes.
10:08:58 <Botje> (doesn't unboxing prevent sharing? istr that)
10:09:02 <shapr> Sometimes it's more efficient, but you sure wouldn't want to unbox [1..]
10:09:15 <shapr> Yeah, it means you don't get laziness, sharing, etc.
10:09:35 <Gwern> so what circumstances would you use it in?
10:09:57 <shapr> If you are sure that value won't be shared, that you won't want to memoize it, all that sort of thing.
10:10:30 <SamB> shapr: I'm not sure you can unbox [1..] anyway
10:10:37 <shapr> SamB: dons probably could...
10:10:45 <SamB> even if you could, you'd only get (1:[2..])
10:10:46 <shapr> But it'd make somebody's hardware cry.
10:11:37 <shapr> Gwern: Do you know how thunks work in lazy languages?
10:12:03 <shapr> Gwern: For example, do you know that > snd (1/0,1) won't cause an error?
10:12:20 <shapr> hiya sorear
10:12:24 <shapr> I liked your Prelude rant.
10:13:02 <Gwern> shapr: I think I sort of understand that 1/0 won't cause an error because it won't be evaluated as snd only evaluates the 1 in the tuple
10:13:10 <shapr> Yup
10:13:28 <Gwern> shapr: dunno. I sort of thought that it really isn't much trouble to hide the prelude and import a new one
10:13:30 <shapr> But if you made that tuple strict, it would.
10:13:40 <Gwern> shapr: right, that's what I thought
10:14:01 <SamB> shapr: but you can't make tuples strict
10:14:10 <shapr> SamB:  Yeah ok... I'm sleepy :-P
10:14:43 <SamB> (You'd need to write a datatype of your own)
10:15:16 <ddarius> :t (# 2, 3 #)
10:15:18 <lambdabot> forall t t1. (Num t, Num t1) => (# t, t1 #)
10:15:48 * allbery_b wonders if it's time to propose a sort of "m Haskell" (as opposed to Haskell')
10:16:07 <Gwern> meta Haskell?
10:16:11 <pejo> allbery, "m" as in strict?
10:16:16 <allbery_b> monad
10:16:26 <allbery_b> strict quold be `seq` Haskell :)
10:16:52 <allbery_b> hm, no backquotes there really
10:17:01 <allbery_b> in other words, higher order Haskell
10:18:15 <allbery_b> so, reflecting things like (.) and map being defined as higher order to start with
10:19:02 <sorear> hello.
10:19:25 <ndm> anyone know anything about a semantics for Core Haskell, untyped
10:19:43 <ndm> ideally a pointer to a paper i could steal it from
10:20:24 <sorear> surely pure untyped lambda calculus has an adaptable semantics?
10:20:26 <pejo> ndm, "core haskell" as in the ghc format?
10:20:38 <sorear> pejo: ndm has his own core, Yhc.Core
10:20:42 <ndm> pejo, technically a reduced variant of that, but close enough
10:20:54 <ndm> sorear, its actually reduced quite a bit from Yhc.Core...
10:21:20 <pejo> sorear, if there was a semantics specified for the yhc core - wouldn't he know about it?
10:21:21 * sorear wonders what there is to reduce in yhc.core :)
10:21:44 <ndm> sorear, the things i'm looking for is how to reprenent an environment with the name bindings, how do to instnaiation etc
10:21:49 <sciolizer> @hoogle Data a => [(String, Dynamic)] -> a
10:21:50 <lambdabot> No matches, try a more general search
10:22:20 <ndm> sorear, there are let bindings, lambdas, application, partial application, oversaturation - lots to remove
10:22:30 <ndm> although not much a normal person would try to remove
10:23:20 <sorear> partial application and oversaturation are only removable if you treat poliadic functions as primitive, I prefer monadic
10:23:21 <pejo> ndm, Marlow's thesis specifies the syntax somewhere around pp 106. But that might be a several versions old core, I'm not sure.
10:23:29 <sorear> isn't Yhc.Core already lambda lifted?
10:23:53 <ndm> sorear, i actually put out an alpha of catch locally yesterday - you may want to update, there is also CATCH_BASE_PATH which means you don't have to run catch out of its own directory
10:24:00 <pejo> ndm, oversaturation = more arguments to a function than its arity?
10:24:06 <sorear> pejo: right.
10:24:08 <ndm> pejo, syntax is easy, semantics is what i need
10:24:28 <sorear> but arity is meaningless if all your funcs are monoadic
10:24:31 <ndm> sorear, it is - no lambda's by default, but still oversaturation/understaturation
10:24:32 <pejo> ndm, isn't oversaturation a type error?
10:24:51 <ndm> > let even = not . odd in even 12
10:24:53 <lambdabot>  True
10:24:58 <ndm> pejo, no ^^^
10:25:07 <ndm> since even has arity one
10:25:27 <ndm> sorear, in the implementation they are - but only as teh very last step - i treat it as multi-arity elsewhere
10:25:28 <sorear> ndm: zero
10:25:42 <pejo> ndm, and is given one argument in your example?
10:25:50 <ndm> sorear, that was a braino ;)
10:26:01 <ndm> even has arity zero, and is given one argument - oversaturation
10:26:21 <vincenz> semantico
10:27:00 <sorear> ndm: in GHC in the very end functions are poliadic, what implementation are you refering to where everything is made monadic as the last step?
10:27:25 <sorear> hm. no catch patches since at least ~14h ago
10:27:26 <ndm> soear, Catch makes all functions have arity-one
10:27:34 <sorear> shhould I change my repo-url?
10:27:43 <SamB> JohnMeacham: JHC is missing some autocrap-related files
10:27:45 <sorear> @users
10:27:45 <lambdabot> Maximum users seen in #haskell: 336, currently: 322 (95.8%), active: 34 (10.6%)
10:28:03 <ndm> sorear, no - thats fine, the bugs all got fixed yesterday
10:28:19 <ndm> sorear, readme describes some of the constraints briefly now
10:28:25 <SamB> JohnMeacham: at the very least, it is missing install-sh
10:28:39 <sorear> SamB: AIUI jhc doesn't use autocrap at all.
10:28:47 <SamB> er
10:28:48 <SamB> sorry
10:28:51 <SamB> I'm confused
10:28:53 <pejo> :t not . odd
10:28:55 <lambdabot> forall a. (Integral a) => a -> Bool
10:28:56 <sorear> SamB: in good UNIX style, you edit the Makefile and 'make'
10:29:01 <SamB> I'm actually in the DrIFT directory
10:29:04 <SamB> ;-)
10:29:13 <sorear> what!
10:29:13 <SamB> JohnMeacham: s/JHC/DrIFT/
10:29:24 <sorear> a haskell-98 app that doesn't use Cabal!
10:29:35 <pejo> ndm, but not . odd has arity zero?
10:29:41 <sorear> pejo: sure!
10:29:46 <SamB> sorear: ... would you want that such an ugly app would use Cabal?
10:29:56 <sorear> pejo: do you see any lambdas in that definition? :)
10:30:31 <SamB> pejo: what is this "arity" thing?
10:31:00 <sorear> <*ndm> sorear, there are let bindings, lambdas, application, partial application,
10:31:00 <sorear>       oversaturation - lots to remove
10:31:07 <sorear> the subject.
10:31:32 <xs> Data.ByteString.Lazy* appears to be missing getLine :: IO ByteString?
10:31:41 <SamB> if "arity" is "number of arguments of a lambda"...
10:31:56 <SamB> then sure, (not . odd) has arity zero...
10:32:14 <sorear> right.
10:32:34 <sorear> this is implementation-hack-arity, not type-arity
10:32:50 <vincenz> why deal with that?
10:32:52 <sioraiocht> @type (not . odd)
10:32:54 <lambdabot> forall a. (Integral a) => a -> Bool
10:33:06 <pejo> Surely the implementation expects type-correct expressions, no?
10:33:08 <sorear> vincenz: ask ndm
10:33:18 <sorear> pejo: yes it does
10:33:22 <ndm> vincenz, i don't want lambda in my semantics
10:33:22 <sioraiocht> how does not . odd have arity zero?
10:33:28 <sioraiocht> > (not . odd)
10:33:30 <lambdabot>  <Integer -> Bool>
10:33:42 <ndm> even = ...
10:33:45 <sioraiocht> looks like it's 1-arity to me
10:33:48 <sorear> sioraiocht: it doesn't start with a lambda!
10:33:51 <int-e> @index getLine
10:33:51 <lambdabot> System.IO, Prelude
10:33:54 <ndm> therefore even has 0 arity, and returns a lambda
10:34:21 <sioraiocht> I've never heard of that definition...
10:34:27 <vincenz> ndm: maybe you oughta rephrase tat
10:34:33 <vincenz> ndm: it can't lead to a closure-generation
10:34:44 <sioraiocht> arity does not refer solely to anonymous functions
10:34:47 <vincenz> ndm: cause there's no captured variables
10:34:50 <vincenz> arity 0 is rather misleading
10:35:08 <sorear> vincenz: he isn't inventing the term
10:35:22 <sorear> vincenz: this is very well established ghc terminology
10:35:33 <sorear> vincenz: ghc -ddump-simpl | grep Arity
10:35:42 <int-e> xs: funny, but I guess the expectation is that you either want a strict bytestring then, or take the whole input (with getContents) and split it into lines (using lines)
10:35:46 <vincenz> poor naming?
10:36:12 <vincenz> that's probably just a data-constructor
10:36:37 <sorear> that?
10:36:39 <vincenz> hardly 'official terminology' more like a programmer's whimfully chosen data-const name
10:36:42 <vincenz> 'Arity'
10:36:51 <ndm> no, arity has an explicit meaning
10:37:00 <xs> int-e, i see strictness as a subset of laziness, so i figured it would be the other way around. thanks.
10:37:14 <ndm> its the number of arguments you give to a function, before its evaluated
10:37:15 <sioraiocht> ndm is right
10:37:16 <sorear> and anyway dump-simpl doesn't use the datacon names :)
10:37:26 <sioraiocht> http://en.wikipedia.org/wiki/Arity
10:37:29 <ndm> it may evaluate to a lambda, but it does evaluate
10:37:29 <sorear> how could he not be? :)
10:37:53 <vincenz> sorear: dunno, never triedi t
10:37:58 <sioraiocht> ndm: but you could argue that all functions in haskell are that way
10:38:00 <pejo> sorear, that ddump-simpl doesn't contain the word arity?
10:38:21 <sorear> pejo: it's not Show
10:38:36 <sorear> pejo: it's a full prettyprinter and renames everything
10:38:49 <vincenz> ndm: so ALL functions in haskell are either nullary or unary?
10:38:54 <ndm> sioraiocht, you can, but its not the way implementation is defined
10:39:03 <vincenz> ndm: caus every time you pass an argument, an action -is- taken: closure generation
10:39:04 <sioraiocht> i know
10:39:09 <ndm> vincenz, in Catch ALL functions are unary
10:39:22 * vincenz nods
10:39:24 <ndm> and there is no lambda, i.e. no closure generation
10:39:36 <sorear> vincenz: in GHC functions can have any arity
10:39:46 <sorear> vincenz: arity analysis is not a semantic issue
10:40:02 <sorear> vincenz: it's just a (vitally important) implementation detail
10:40:04 <sioraiocht> ndm: so are you saying that even is 0 arity because it's the product of a composition?
10:40:36 <sioraiocht> because (.) is a binary function, and (not . odd) passes two arguments, so therefore it ahs be a constant (nullary) value?
10:41:12 <ndm> sioraiocht, it is a constant, even will be evaluated once at run time, because it has no arguments to the left of the =
10:41:22 <ndm> (.) is a function of arity 3
10:41:31 <ndm> @src .
10:41:31 <lambdabot> (.) f g x = f (g x)
10:41:46 <sioraiocht> :t (.)
10:41:48 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:41:49 <sioraiocht> @t .
10:41:50 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
10:42:50 <SamB> what is the arity of read?
10:42:50 <pejo> sorear, it becomes a semantic issue since you need partial application
10:43:10 <sorear> pejo: there is no such thing as partial application, semantically
10:43:15 <sioraiocht> :t read
10:43:17 <lambdabot> forall a. (Read a) => String -> a
10:43:26 <sorear> sioraiocht: :t has NOTHING to do with arity
10:43:29 <SamB> yeah, semantically a partial application is just a function
10:43:35 <SamB> sometwo: not nothing
10:43:38 <SamB> er.
10:43:39 <SamB> sorear:
10:43:42 <sioraiocht> sorear: could have fooled me
10:43:49 <sioraiocht> sorear: they're definitely related
10:44:07 <SamB> sorear: because I'm pretty sure it is bad for a function to have a higher arity than the number of arrows in its type!
10:44:22 <sioraiocht> arity is the number of formal parameters to a function, the end.  haskell's type system is an abstractionl, sometimes, but not always
10:44:25 <SamB> (note: yes, I know that not all arrows are relevant to arity)
10:44:46 <ndm> hmm, but still i can't find a good lambda calculus/haskell semantics online...
10:45:21 <SamB> If I knew the notation I might be able to write one for lambda calculus
10:45:31 <SamB> I would be able to read one in a paper
10:45:33 <SamB> I think
10:45:45 <ndm> yeah, but its the notatino thats holding me back
10:45:55 <ndm> i could write an evaluator in Haskell, which is a semantics
10:45:57 <sorear> ndm: untyped lc is a subset of standard ml, no?
10:46:13 <ndm> sorear, the ML semantics is a book - too big alas
10:46:26 <ndm> but worth a look, thanks
10:46:28 <SamB> well, basically the semantics would be the same thing except with a certain compact notation...
10:46:32 <pejo> sorear, that's a strict semantics though.
10:47:08 <LoganCapaldo> Does SML have promises?
10:47:18 <SamB> I'm pretty sure that the semantics for lambda calculus fit on one page
10:47:39 <sorear> LoganCapaldo: it has nullary functions, which are semantically just as good
10:48:00 <LoganCapaldo> So you could do all the lazy stuff from the strict semantics, right?
10:48:02 <ddarius> ndm: Are you looking for an operational semantics, a denotational one, or...?
10:48:11 <Saizan> aren't lc semantics just alpha,beta and eta-reduction?
10:48:14 <SamB> ddarius: hmm, reminder as to the difference?
10:48:26 <ndm> sorear, i don't have nearly enough space for that... - quarter of a page tops
10:48:47 <ndm> ddarius - my supervisor wants semantics adding, i was going to guess operational is easiest - but denotational is doable
10:49:15 <ddarius> SamB: Denotational just maps the syntax into a mathematical object and looks pretty much like a Haskell interpreter, operational breaks things down step by step showing how things "simplify"
10:49:48 <ddarius> big step "operational" semantics is the same thing as denotational semantics.
10:49:54 <SamB> a Haskell interpreter being an interpreter *of* Haskell, or *written in* Haskell?
10:50:03 <ddarius> SamB: Written in Haskell.
10:50:06 <ndm> i have such a small language, small-step operational is likely to be the saem
10:50:14 <SamB> ddarius: ah, no wonder I didn't get the difference
10:50:25 <pejo> ndm, Ariola and Felleisen has a JFP article about lazy lambda calculus.
10:50:33 <ddarius> small step operational semantics is different
10:50:56 <SamB> how can you tell that a small step operational semantics is not a denotational semantics?
10:51:36 <kilimanjaro> Saizan, those are reduction rules. The semantics itself can have any number of forms
10:51:45 <ddarius> SamB: Big step operational semantics are just a notational variation of denotational semantics
10:52:57 <SamB> ndm: what are you supposed to do with the semantics?
10:53:36 <ndm> SamB, paste it at the top o page 2
10:53:49 <SamB> ndm: then probably denotational is easiest
10:53:58 <ndm> and i suspect we'll end up removing for space concerns later on
10:55:43 <ddarius> ndm: From what it sounds like you are doing, operational semantics sounds more appropriate.
10:56:25 <SamB> ddarius: does that fit in half a page?
10:56:29 <ddarius> That said if it's small enough you can convert between the mechanically by hand fairly easily.
10:56:35 <ddarius> SamB: It depends on the semantics.
10:56:39 <SamB> heh
10:56:45 <SamB> "mechanically by hand"
10:57:08 <ndm> i might try a haskell evaluator
10:57:14 <ddarius> The transforms are off-the-shelf, but still not something you just have sitting around.
10:57:26 <ndm> i think thats about 8 lines for my language, and might apease my supervisor enough
10:57:26 <pejo> SamB, I fit the syntax and semantics in half a column for a small cbv-language.
10:57:34 <ddarius> @google from interpreter to abstract machine
10:57:37 <lambdabot> http://www.pms.ifi.lmu.de/publikationen/PMS-FB/PMS-FB-1998-13.ps.gz
10:57:48 <ddarius> @google Danvy from interpreter to virtual machine
10:57:51 <lambdabot> http://www.brics.dk/RS/03/14/index.html
10:57:51 <lambdabot> Title: From Interpreter to Compiler and Virtual Machine: A Functional Derivation
10:57:52 <twanvl> ndm: I played with Data.Derive a bit, it can now derive Functor
10:58:05 <ndm> twanvl, patch?
10:58:05 <ddarius> http://www.brics.dk/RS/03/13/index.html
10:58:07 <lambdabot> Title: A Functional Correspondence between Evaluators and Abstract Machines
10:58:14 <twanvl> on its way
10:58:18 <sorear> @google Data.Derive
10:58:20 <ddarius> That's the one (both actually).
10:58:21 <lambdabot> http://jobfunctions.bnet.com/whitepaper.aspx?docid=121943
10:58:21 <lambdabot> Title: Gathering The Data; Derive Real Value From CRM - CRM, from SYS-CON Media - Busin ...
10:58:24 <ndm> @karma+ twanvl
10:58:24 <lambdabot> twanvl's karma raised to 2.
10:58:28 <ndm> @where+ derive
10:58:28 <lambdabot> Done.
10:58:30 <sorear> url?
10:58:34 <ndm> sorear, as yet entirely unreleased
10:58:44 <ndm> @where+ derive http://www.cs.york.ac.uk/fp/darcs/derive
10:58:44 <lambdabot> Done.
10:58:46 <twanvl> I had to add information on the types used by constructors, though
10:58:47 <sorear> part of catch?
10:59:03 <ndm> sorear, no
11:02:14 <ndm> sorear, i wrote it for Play and binarydefer
11:02:20 <ndm> neither of which are released yet...
11:02:43 <ndm> think of it as a Drift competitor, but designed in an entirely different way
11:05:37 <sm-afk> morning all
11:05:47 <ndm> twanvl, can you resend them gzipped patch?
11:05:52 <sm-afk> is there a nice speedy planet (rss aggregator) written in haskell by chance ?
11:06:10 <ndm> twanvl, darcs send -o details.patch, gzip details.patch, email
11:06:22 <ddarius> @google hrss
11:06:24 <lambdabot> http://www.hrss.net/
11:06:24 <lambdabot> Title: Welcome to the House Rabbit Society of Singapore
11:06:31 <ndm> twanvl, otherwise gmail/windows gets very upset by line eneding etc...
11:06:38 <ddarius> Well, that was interesting.
11:06:40 <sm-afk> heh
11:06:54 <ddarius> sm-afk: There is some Haskell RSS thing.  I'm not sure what it does exactly though.
11:07:00 <ddarius> @google hrss Haskell
11:07:03 <sorear> @where+ HRSS
11:07:05 <lambdabot> http://cale.yi.org/index.php/HRSS
11:07:05 <lambdabot> Title: HRSS - CaleWiki
11:07:05 <lambdabot> Done.
11:07:19 <sorear> ech, I meant @where
11:07:23 * sorear slaps sorear
11:07:34 <sm-afk> thanks! I'll try it
11:07:37 <sorear> @where+ HRSS http://cale.yi.org/index.php/HRSS
11:07:50 <lambdabot> Done.
11:07:50 <sm-afk> tired of venus chewing up my cpu
11:08:48 <ddarius> sm-afk: I have no idea how efficient or not hrss is.
11:12:14 <sorear> @botsnack
11:12:14 <lambdabot> :)
11:15:35 <sorear> ndm: why does derive use UNIX-style line endings?  seems rather atypical for your code
11:15:50 <ndm> sorear, i tend to use unix line endings for most things...
11:16:00 <ndm> sorear, i think catch is unix all over
11:16:21 <ndm> latex documents are \r\n because of my editor, otherwise i use unix
11:16:28 <sorear> hmm.  major percepto then
11:17:01 <ndm> some old projects, hoogle 3 i think, accidentally ended up in DOS format - possibly thats it
11:17:04 * sorear stefan@stefans:/usr/local/src/derive/Data$ grep -lr '\015' ../../catch
11:17:20 <ndm> sorear - isn't it 13?
11:17:28 <sorear> ndm: octal :)
11:18:01 <sorear> ndm: retrying with \013, all I get is ycr and hbc files
11:18:12 <sorear> and Risers.log
11:18:26 <sorear> and the darcs inventory ?!
11:18:36 <ndm> hehe, not my fault ;)
11:19:07 <sorear> which? octal | binary format for yhc.core | Risers.log | inventory?
11:19:50 <ndm> not my fault for any of those, Risers.log would have been generated on your system, i would have thought
11:20:01 <ndm> you should get all the .bat files having \r in them
11:20:04 <ndm> otherwise it doesn't work
11:20:21 <sorear> oh, that's odd, grep doesn't do character escapes.
11:20:28 <sorear> bogus results!
11:20:30 <ddarius> "Despite its incestuous look, the code works."
11:21:29 <sorear> stefan@stefans:/usr/local/src/derive/Data$ grep -lr '^M' ../../catch | rev | sort | rev  # where ^M was entered with C-v C-m
11:22:17 <xerox> grep -e '\013' ?
11:23:52 <sorear> wow, there's a .c in catch
11:24:24 <Bourbaki> hidiho
11:24:29 <sorear> hi!
11:24:53 <Bourbaki> how do you implement if then else with arrows?
11:25:01 <ndm> sorear, is there? perhaps thats my C back end for Yhc
11:25:01 <sorear> ArrowChoice?
11:25:12 <Caelum> going through a tutorial, what does  Couldn't match expected type `t -> String' against inferred type `String' mean?
11:25:28 <Bourbaki> sorear how is this composed?
11:25:37 <drigz> Caelum: depends on context
11:25:44 <sorear> usually, that you passed one two many args to a function
11:25:52 <drigz> strictly, it means a String is being given where a function is expected
11:26:15 <Bourbaki> does these two functions need to have the same type?
11:26:28 <sorear> ndm: ../../catch/src/Backend/Hello.c  and it definitely has yhc.core-ey names
11:26:46 <Caelum> drigz: oh, I added some parens and it went away...
11:26:48 <sorear> LAMBDA191 and all that
11:27:05 <Caelum> thank you
11:27:07 <ndm> sorear, yeah, thats C generated from the Yhc.Core translator I have
11:27:24 <ndm> sorear, won't work though - it doesn't unwind the stack so overflows every time
11:27:35 <ndm> well, it does work basically - it will say hello world
11:30:05 <ndm> its actually GHC competative, until it blows the stack - which is incredibly quickly for any real computation
11:56:47 * SamB likes how Debian tends to put GFDL'd things in the non-free section
11:57:18 <SamB> I mean, beating the FSF at their own game...
11:58:48 <ndm> SamB, they are quite non-free
12:00:54 <SamB> yeah.
12:00:55 <SamB> I know.
12:02:14 <SamB> I like how Debian apparantly cares more about software being free than the FSF does
12:03:44 <ndm> http://picasaweb.google.com/ndmitchell/PhD/photo#5045568110321373394
12:03:47 <lambdabot> Title: Picasa Web Albums - Neil Mitchell - PhD, http://tinyurl.com/22keux
12:04:09 <ndm> thats the syntax and semantics of my minimal core language
12:04:17 <ndm> anyone think thats understandable? or confusing?
12:06:02 <lispy> ndm: it's terrible and you should drop out of school ;)
12:06:52 <dmwit> What is Ctor for?
12:07:11 <lispy> ndm: hnf == head normal form?
12:07:21 <sorear> not whnf?
12:07:31 * sorear isn't entirely sure either
12:07:42 <ndm> lispy, yes - correct
12:07:44 <ddarius> ndm: The semantics is not compositional
12:07:54 <sorear> ctors are for wimps
12:08:03 <sorear> church encoding is so much better
12:08:18 <ndm> sorear, whnf is when you are reducing to either a constructor or a lambda, not appropriate in a first order language
12:08:22 <ddarius> And you may want to add a comment as to why the Var case is not handled in hnf.
12:08:26 <ndm> dmwit, a constructor
12:08:42 <drigz> yes! this was the first time i've ever written a haskell program that has both compiled and run correctly first time!
12:08:46 <ndm> ddarius, what advantages would i get from going compositional? and how? (semantics is not my strong point)
12:08:54 <lispy> drigz: congrats!
12:08:54 <sorear> ndm: wait - I thought Yhc.Core was higher order?
12:08:56 <dmwit> drigz: Great work!
12:09:01 <ndm> ddarius, good point about var in hnf
12:09:11 <ndm> sorear, it is - but this langauge is a restricted version of Yhc.Core
12:09:12 <sorear> -Wwarn-incomplete-cases :)
12:09:36 <sorear> can catch prove itself yet?
12:09:55 <ndm> sorear, ideally you'd write bind using Play, but thats a later paper
12:10:08 <sorear> ndm: huh?
12:10:25 <ndm> sorear, no - i looked at it briefly, but Catch can't be compiled with Yhc yet - missing a few libs
12:10:40 <ndm> sorear, i have a SYB competitor called Play, which would write bind in 2 lines
12:11:02 <ndm> bind r (Var x) = fromJust $ lookup r x
12:11:03 <sorear> what's bind?
12:11:13 <ndm> bind r x = descend (bind r) x
12:11:16 <ndm> a nice two liner
12:11:35 <ndm> sorear, repleace free variables with a given value
12:11:50 <SamB> ndm: ... that is Haskell code
12:12:10 <ndm> SamB, yes - i think that makes it more readable (not in a separate language/syntax)
12:12:30 <ndm> SamB, but note i haven't assumed either lazy or strict evaluation, the eval function makes it explicit
12:13:33 <kyevan> Does anyone know if there is a version of YAHT (Which I find is a good peice of writing for me to learn from) in html?
12:13:39 <sorear> ndm: you aren't using field anywhere
12:14:05 <kyevan> Since... printing 200 page things is /not/ a good idea, and, um, plucker :P
12:14:51 <ndm> sorear, i am elsewhere in my paper - its defined for then
12:15:08 <ndm> sorear, if you compile the latex document in academic/icfp2007 you'll see why i need it ;)
12:15:13 <drigz> kyevan: the wikibooks one
12:15:15 <dmwit> http://en.wikibooks.org/wiki/Haskell/YAHT
12:15:43 <sorear> rename error on 'instantiate' :)
12:15:56 <pejo> ndm, is there a pdf of that somewhere?
12:16:33 <ndm> sorear, thats defined elsewhere as well - or rather referenced
12:16:33 <ddarius> ndm: Sorry, big lag.  A denotational semantics must be compositional.  The reason is to clearly separate (in programming terms) the runtime from the "compile" time
12:16:34 <kyevan> drigz: I thought of that. Plucker and Mediawiki... do NOT get along :P
12:16:35 <sorear> pejo: yes.
12:16:51 <SamB> ndm: I think I'll order a print of that...
12:16:55 <sorear> kyevan: can't you use a db-dump? :)
12:17:02 <drigz> kyevan: oh i see, you want to download it
12:17:05 <pejo> sorear, url?
12:17:39 <SamB> ddarius: why would you want to do that?
12:17:44 <sorear> pejo: file:///usr/local/src/catch/academic/...
12:17:54 <sorear> actually, I remember I couldn't
12:18:03 <sorear> latex really didn't want to run
12:18:07 <ddarius> ndm: Essentially, being non-compositional pulls the AST into the runtime rather than just interpreting it into a semantic function.
12:18:13 <sorear> I'm missing googleproof style files
12:18:57 <sorear> stefan@stefans:/usr/local/src/catch/academic/icfp2007$ bibtex final
12:18:57 <sorear> I couldn't open file name `final.aux'
12:19:17 <sorear> stefan@stefans:/usr/local/src/catch/academic/icfp2007$ texify final.tex
12:19:17 <sorear> ** Don't know who I am.  You can call me:
12:19:19 <kyevan> sorear: If I want to write my own pluckerizer....
12:19:42 <sorear> kyevan: it'll only be like 10 lines of haskell :)
12:19:44 <ndm> sorear, you have to do lhs2tex on it first
12:19:46 <kyevan> (AND mediawiki syntax parser :P)
12:19:47 <hpaste>  jdrake pasted "parse error in pattern? (line 2)" at http://hpaste.org/1120
12:19:52 <sorear> ndm: already did
12:19:56 <jdrake> Any ideas what might be wrong on line 2?
12:20:11 <SamB> ddarius: oh, you mean that a compositional returns a function that can have the AST optimized out of it?
12:20:13 <ndm> pejo, no pdf yet, but i have a note to email you a copy on monday
12:20:15 <ddarius> jdrake: need parens
12:20:15 <dmwit> jdrake: Needs parens.
12:20:18 <sorear> ndm: the lhs2TeX was the only command from that batchfile that DIDN'T fail
12:20:24 <pejo> ndm, oh right!
12:20:34 <SamB> s/compositional/compositional one/
12:20:36 <dmwit> idx (x:xs) 1 = x
12:20:46 <pejo> ndm, clearly your notes remember better than I do. :P
12:20:51 <jdrake> merci
12:21:04 <ndm> pejo i emailed myself a message telling me to :)
12:21:07 <ddarius> SamB: A compositional interpreter keeps the syntax out of the semantics which is the whole point of the semantic function.
12:21:10 <dmwit> jdrake: But, even better is idx = (!!) ;-)
12:21:27 <ndm> sorear, hmm, works fine for me on 3 computers - all miktex though
12:21:43 <jdrake> dmwit: It is an exercise to implement it
12:21:44 <sorear> ndm: what's miktex?
12:21:48 <kyevan> sorear: problem with that: I'm not lazily evaluated or functional. I have to learn haskell BEFORE I can use it :P
12:22:01 <ndm> sorear, windows program - easy tex distro
12:22:08 <sorear> ndm: I have 30+ texify*** programs, and none will accept TeX as input
12:22:15 <ddarius> ndm: Incidentally, an easy way to ensure compositionality is to write you eval function as a fold (you can inline the definition at the end for clarity)
12:22:30 <ndm> ddarius, thanks for the comments - i'll see if i can figure it out in denotational
12:22:41 * kyevan kicks eir scheme code for school
12:22:57 <sorear> ndm: most of them accept progrmaming-language input, not TeX
12:23:14 <ndm> sorear, miktex just works (TM)
12:23:16 <dmwit> kyevan: You have a Haskell compiler for your handheld?
12:23:25 <kyevan> dmwit: No?
12:23:34 <jdrake> What would be the best way to implement protection over a function like factorial to prevent infinite recursion when given a negative number?
12:23:45 <sorear> and if I try to run tex itself:
12:23:47 <sorear> ! LaTeX Error: File `datetime.sty' not found.
12:24:01 <ddarius> fac n | n >= 0 = ...
12:24:04 <dmwit> kyevan: Ah.  I was assuming you'd want to be writing Haskell code in pretty close time-proximity to reading YAHT.
12:24:55 * ddarius is somewhat bored.
12:25:04 <kyevan> dmwit: I like to be able to move while reading, though.
12:25:06 <jdrake> perfect, thank you
12:25:12 <ndm> sorear, an you not install datetime? miktex runs off to the internet and fetches it automatically
12:25:21 <kyevan> And desktops are a pain to lug around to read stuff :P
12:25:29 <dmwit> =P
12:25:35 * ddarius doesn't want to do something too involed.  He may write a partial ps interpreter/full pdf parser.
12:25:56 <ddarius> Actually, I should have a postscript interpreter... somewhere...
12:26:08 <sorear> ndm: ah.  the program miktex calls texify has absolutely nothing to do with the program debian calls texify.
12:26:17 <sorear> ndm: no wonder the command line didn't work!
12:26:29 <ndm> sorear, no wonder then ;)
12:28:56 <sorear> ftr debian uses tetex (by default)
12:30:48 <ddarius> repl = repl . print . eval . parse
12:31:11 <SamB> that isn't very compositional
12:31:12 <ddarius> Did I ever even try to compile that...
12:31:55 <SamB> @type \eval parse -> let repl = repl . print . eval . parse in repl
12:31:58 <lambdabot> forall b c c1. (Show c) => (b -> c) -> (IO () -> b) -> IO () -> c1
12:32:22 <sorear> @type let repl = repl . print . ?eval . ?parse in repl
12:32:25 <lambdabot> forall c. (?parse::IO () -> b, ?eval::b -> Integer) => IO () -> c
12:32:36 <sorear> implicit parameters make :t much nicer
12:32:50 <SamB> sorear: whoa, neato!
12:33:27 <ddarius> Yes, but parse is unlikely to be an IO () -> b function for any b.
12:33:56 <SamB> yeah
12:34:02 <SamB> I think we know that ;-P
12:34:28 <SamB> I think you want to replace that first "." with something else
12:35:53 <SamB> @type let repl = print . ?eval . ?parse >> repl in repl
12:35:55 <lambdabot> forall b c a b1. (?parse::a -> b, ?eval::b -> c, Show c) => a -> b1
12:36:10 <SamB> hmm.
12:36:23 <SamB> ddarius: what sort of type were you looking for?
12:36:43 <SamB> that won't work, since it only takes one program ;-)
12:37:04 <sorear> @type sequence_ . repeat . $ print . eval =<< readLn
12:37:07 <lambdabot> parse error on input `$'
12:37:13 <sorear> @type sequence_ . repeat $ print . ?eval =<< readLn
12:37:16 <lambdabot>     Ambiguous type variable `a' in the constraint:
12:37:16 <lambdabot>       `Read a' arising from use of `readLn' at <interactive>:1:39-44
12:37:28 <sorear> @type \eval -> sequence_ . repeat $ print . eval =<< readLn
12:37:31 <lambdabot> forall b a. (Show b, Read a) => (a -> b) -> IO ()
12:37:43 <sorear> implicit params, alas, aren't perfect
12:38:47 <sorear> my lexical implicit parameter system can do everything lambdas can, but doesn't seem to be good for much besides simplifying the typechecker
12:40:25 <SamB> lexical?
13:07:56 <sciolizer> What's the difference between rank 1 and rank 2 types?
13:08:33 <ndm> @type id
13:08:35 <lambdabot> forall a. a -> a
13:08:36 <ndm> @type runST
13:08:39 <lambdabot> Not in scope: `runST'
13:08:55 <ndm> @type build
13:08:57 <lambdabot> Not in scope: `build'
13:09:07 <sorear> ndm: you need qualifiers
13:09:23 <ndm> sciozer, they have forall's other than at teh right most position
13:09:24 <sorear> sciolizer: rank 2 types have inner quantifiers
13:09:34 <sorear> @type Control.Monad.ST.runST
13:09:37 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
13:09:42 <sorear> @type GHC.List.build
13:09:44 <lambdabot> Not in scope: `GHC.List.build'
13:09:49 <sorear> @type GHC.Exts.build
13:09:52 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
13:10:18 <sciolizer> Looking at the type for runST: is "a" a "free" type variable?
13:10:26 <sciolizer> (I'm making up terms.)
13:10:26 <sorear> no
13:10:28 <sciolizer> ok
13:10:43 <sorear> all type variables in runST's type are bound by some forall
13:11:32 <sorear> IMO System F's handling of rank-2 types, impredicativity, and plain old polymorphism is much easier to understand than the Haskell way
13:11:32 <sciolizer> So, why is the type of runST not (ST s a) -> a?
13:11:48 <sorear> (that said, it's too verbose to use in practice except as an IL)
13:12:02 <sorear> sciolizer: because s and a are unbound
13:12:16 <sorear> sciolizer: or are you talking about forall a s. ST s a -> a?
13:12:28 <vincenz> sorear: most likely
13:12:28 <sciolizer> sorear: yes, the latter
13:13:25 <sorear> evil, evil hacks
13:13:45 <sorear> ST uses rank2 for referential transparency
13:13:52 <sorear> it's unsafePerformIO inside
13:14:07 <sorear> if runST had the type you describe, I could
13:15:03 <thorat> sorear: so you're saying rank 2 *should* be verbose?
13:15:20 <sorear> let ref = runST (newSTRef undefined) ; runST (writeSTRef ref (17::Int)) `seq` (runST (readSTRef ref) :: [Char])
13:15:27 <sorear> unsafeCoerce for free!
13:15:42 <sorear> thankfully the rank-2 wierdness makes that ill-typed
13:15:48 <sorear> thorat: no
13:16:00 <sorear> thorat: rank 2 should be nice and concise
13:16:12 <sciolizer> sorear: I have little experience with the state monad, so I will have to think through that.
13:16:15 <sorear> thorat: but the explicitness of SF makes things easier to understand
13:16:18 <thorat> (I've never understood the monad transformers anyway ;))
13:16:35 <sciolizer> sorear: but are there uses for rank2 other than to protect unsafe operations?
13:16:36 <thorat> right
13:16:50 <sorear> sciolizer: replace *ST* with *IO* and runST with unsafePerformIO, and try it in ghc.  you'll get a segfault
13:17:02 <sorear> sciolizer: try it as-is. you'll get a type error
13:17:17 <sorear> sciolizer: yes
13:17:37 <sorear> sciolizer: Haskell's type classes are effectively sugar for rank-2 types
13:18:21 <sorear> sciolizer: a monadic function (for example) usually needs to use 'return' at many different types, so if the dictionary was a monomorphic lambda binding it wouldn't work
13:18:31 <SamB> also "build"
13:18:48 <SamB> @hoogle build
13:18:49 <lambdabot> GHC.Exts.build :: ((a -> b -> b) -> b -> b) -> [a]
13:18:49 <lambdabot> Distribution.Simple.Build.build :: PackageDescription -> LocalBuildInfo -> Int -> [PPSuffixHandler] -> IO ()
13:18:49 <lambdabot> Data.Graph.Inductive.Internal.Heap.build :: Ord a => [(a, b)] -> Heap a b
13:19:01 <SamB> hmm.
13:19:05 <SamB> That doesn't look right.
13:19:14 <SamB> :t build
13:19:16 <lambdabot> Not in scope: `build'
13:19:27 <SamB> :t GHC.Exts.build
13:19:29 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
13:20:06 <SamB> also, I believe the new fusion scheme uses at least one rank-2 data constructor
13:21:09 <sciolizer> sorear: I might as well speak about what I'm working on. Why do so many of the SYB functions have something like (forall a . Data a => a -> a) as a parameter?
13:21:11 <Philippa> sorear: System F's more consistent, but a hypothetical Haskell-with-good-impredicativity'd be fine in my book
13:21:39 <sorear> Philippa: is it as easy to understand as System F?
13:21:45 <ndm> sorear, only higher kinded type classes hide rank-2 types
13:21:46 <sorear> Philippa: I want to program in Haskell
13:22:00 <sorear> Philippa: but I want SF for pedagogical purposes
13:22:04 <sciolizer> sorear: That is, why is forall a. Data a => (a -> a) -> ... not good enough?
13:22:32 <ndm> SamB, hoogle strips rank-2 types
13:22:40 <SamB> ndm: yeah.
13:22:46 <SamB> it is just disconcerting ;-)
13:22:52 <resiak> what does build even do?
13:22:52 <vincenz> sciolizer: it's not polymorphic enough
13:22:56 <sorear> ndm: class Iffable bool where if' :: bool -> a -> a -> a
13:22:57 <sciolizer> sorear: Does it have something to do with the fact that the (a -> a) might be a different type than the a in the rest of the signature?
13:23:16 <ndm> SamB, version 4 will fix that
13:23:16 <SamB> sciolizer: no.
13:23:18 <sorear> sciolizer: consider eg data Foo = Foo Int Bool deriving(Data)
13:23:18 <sciolizer> vincenz: I only know what polymorphism means as far as message passing in OO systems go.
13:23:35 <vincenz> sciolizer: basically SYB traverses down different types
13:23:41 <ndm> sciolizer, have you read the first SYB paper? if you understand that, understanding rank-2 isn't that important
13:23:42 <vincenz> sciolizer: so the mapping function must be able to handle all those
13:23:43 <sorear> sciolizer: if you use generic traversals, the sub-traversal needs to be called at both Int and Bool
13:23:48 <SamB> sciolizer: it has to do with whether or not you can pass in something like ("hello "++)
13:23:55 <vincenz> sciolizer: if you use the second definition, you're restricting that (a->a) to the 'current a'
13:24:05 <ndm> sorear, how is that iffable rank-2?
13:24:31 <ndm> i had heard it was only higher kinded ones that went rank-2, but could well be wrong
13:24:40 <sciolizer> ndm: I have read it, but right now I'm trying to make my own invocation of gunfold, and it's not typing correctly.
13:24:49 <sorear> ndm: the dictionary is data IffableD b = IffableD (forall a. b -> a -> a -> a)
13:25:09 <sorear> ndm: foo b = replicate (if' b 2 5) (if' b 'x' 'e')
13:25:25 <ndm> hmm, yes
13:25:32 <sorear> ndm: foo (IffableD if') b = replicate (if' b 2 5) (if' b 'x' 'e')
13:25:40 <ndm> sciolizer, probably better to paste your code in :)
13:25:41 <ndm> @paste
13:25:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:25:52 <sorear> what monomorphic type would you assign to that lambdabinding of if'?
13:26:02 <SamB> that makes IffableD :: forall b. -> (forall a. b -> a -> a -> a) -> IffableD b?
13:26:16 <Philippa> sorear: it'd be nice if System F were the explicitly-annotated version of Haskell's rank-n stuff, yeah. I do find it just occasionally helps to learn where the hypothetical type lambdas would go
13:26:20 <sciolizer> ndm: Alright. I'll see if I still have an old copy of it. :)
13:26:39 <sorear> Philippa: huh?  System F came first
13:26:40 <SamB> Philippa: those aren't hypothetical
13:26:42 <Philippa> (around the term corresponding to the type with the forall, of course)
13:26:51 <SamB> they actually exist.
13:26:58 <Philippa> not if it's haskell code you're reading
13:27:21 <sorear> Philippa: oh, so you want haskell to be system f - some annotations?
13:27:25 <Philippa> sorear: you're misreading me :-) Try "if the haskell stuff, explicitly annotated, were System F"
13:27:32 <Philippa> right
13:27:45 <SamB> you'd need to add /\ a lot
13:27:56 <SamB> does that qualify as an annotation?
13:27:59 <Philippa> yep
13:28:22 <SamB> how would you decide exactly where to put them?
13:28:51 <sorear> Philippa: -ddump-ds isn't good enough for you? :)
13:29:16 <Philippa> SamB: I just gave you a usable rule of thumb
13:29:32 <Philippa> applications placed equivalently, of course
13:29:53 <SamB> yeah. but it still seems like sometimes you'd have some choice about where to put them...
13:31:14 <Philippa> sure, but you only get that when it's isomorphic anyway
13:31:16 <sorear> would adding a typing rule that forall was illegal on the right of function arrows disambiguate things enough?
13:31:18 <Philippa> pick a convention and stick to it
13:31:40 <Philippa> you mean restricting to rank-1 again?
13:31:59 <sorear> Philippa: no, that's eliminating forall on the *left*
13:32:12 <Philippa> ...point
13:32:24 <Philippa> but even then it doesn't really matter much
13:32:27 <sorear> Philippa: on the right you don't need foralls, since A -> forall b. C === forall b. A -> C
13:32:47 <Philippa> yeah, but if you're adding your lambdas having already figured the type you don't have a problem anyway
13:34:53 <ment> hello, please where to find in haskell report what the pipe symbol in class instance declaration means? (eg. instance MonadReader m s | m -> s where ...)
13:35:05 <Philippa> you won't, it's not Haskell 98
13:35:15 <ndm> ment, they are called functional depenencies, not in the report
13:35:42 <ment> so where are they explained?
13:36:21 <mattam> scholar.google.com certainly has an answer to that question
13:36:37 <mattam> maybe the Haskell Wiki too
13:36:49 <ment> thanks
13:38:02 <thorat> ment: you might like http://www.cs.chalmers.se/~hallgren/Papers/wm01.html
13:38:04 <lambdabot> Title: Fun with Functional Dependencies
13:43:19 <pejo> l
13:43:24 <pejo> Ups, wrong window.
13:43:30 <ment> thorat: that's exactly what i'm looking for
13:43:48 <thorat> ;)
13:44:05 <Eelis> and of course there's the ghc manual
13:44:34 <sorear> @where manual
13:44:35 <lambdabot> I know nothing about manual.
13:44:39 <sorear> grr
13:44:56 <sorear> @slap Lambdabot.writeModuleState
13:44:57 <lambdabot> why on earth would I slap Lambdabot.writeModuleState
13:45:11 <sorear> It's my least favorite function, that's why!
13:45:32 <sorear> @where+ manual http://haskell.org/ghc/dist/current/docs/users_guide/
13:45:33 <lambdabot> Done.
13:47:52 <sorear> twanvl++ Functor deriving
13:51:36 <hpaste>  sciolizer pasted "using generics to deserialize a dictionary" at http://hpaste.org/1121
14:06:56 <ndm> twanvl++ - i already gave extra karma for the functor deriving, plus he wrote a lot of other good stuff to the library, which i'll need for Play
14:08:40 <sorear> karma = deeds * people think it's cool
14:09:03 <sorear> so if we agree functor deriving is cool, both ++ are justified
14:09:13 <sorear> besides, it's not like the bot will remember
14:09:15 <UUStudent> hello
14:09:27 <sorear> I've been well past 40 in the past
14:09:29 <sorear> @karma
14:09:30 <lambdabot> You have a karma of 24
14:09:38 <ndm> @karma
14:09:38 <lambdabot> You have a karma of 11
14:09:38 <sorear> hello, $UUStudent
14:09:41 <UUStudent> I have a problem with IO
14:10:00 <UUStudent> hi sorear
14:10:07 <vincenz> eeen student
14:10:13 <sorear> not suprising, IO is one of the trickier bits of haskell for newbies to get
14:10:16 <vincenz> dag student
14:10:26 <sorear> @babel de en een
14:10:28 <sorear> @babel de en eeen
14:10:40 <sorear> @botsnack
14:10:42 <vincenz> sorear: dutch
14:10:42 <lambdabot> Plugin `babel' failed with: IRCRaised thread killed
14:10:43 <lambdabot> Plugin `babel' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:10:43 <lambdabot> :)
14:10:50 <UUStudent> does anyone know how to convert a IO String to a String
14:10:53 <vincenz> UUStudents are people comng through earthy's (.nl) website
14:10:58 <sorear> @activity 90
14:10:59 <vincenz> UUStudent: with donotation
14:10:59 <lambdabot> 6*total 5*#haskell 1*private
14:11:04 <vincenz> do
14:11:13 <int-e> . o O ( karma = number of bytestring and lambdabot patches you've sent )
14:11:21 <vincenz>   myString <- someActivityReturningIOString
14:11:47 <qwr> UUStudent: or >>= \x ->
14:12:19 <UUStudent> i'm not a pro, do you have a better syntax
14:13:02 <UUStudent> I want to read a file and store the content in a string, not a IO String
14:13:17 <UUStudent> how can i do that?
14:13:32 <sorear> you can't, but usually it doesn't matter
14:13:41 <UUStudent> why
14:13:54 <sorear> readFile "myFileName" >>= \contents -> you can use contents as a regular string here
14:14:12 <sorear> or, using the 'do' syntax:
14:14:25 <sorear> do { contents <- readFile "myFileName" ; you can use contents as a regular string here }
14:14:59 <UUStudent> oke, but how can I use any function on that content
14:15:30 <sorear> within the rest of the do-block, contents has type String, not IO String
14:15:54 <qwr> let do_something_with_string str = putStrLn (map Data.Char.toUpper str) in getLine >>= do_something_with_string
14:16:58 <qwr> and this is direct equivalent to the previous one with do notation: do { str <- getLine; putStrLn (map Data.Char.toUpper str) }
14:22:47 <qwr> (the str is String, while getLine and readFile give IO String)
14:23:50 <UUStudent>  I have now => do x <- readFile filename; return x
14:24:02 <sorear> twanvl: ping?
14:24:18 <UUStudent> so now i can use the x as a string
14:24:33 <sorear> sortof.
14:24:45 <sorear> return puts x right back in IO
14:24:56 <UUStudent> but only in the same do and not anywhere else?
14:25:00 <sorear> if you want to use the string, you'll need to do it in the do-block
14:25:10 <sorear> (or in a do-block that calls this one)
14:25:35 <UUStudent> but don't you have to return anything
14:25:51 <qwr> UUStudent: yes, you never really escape the IO monad. (ok its unsafely possible, but better not try it)
14:26:18 <sorear> one of the monad laws (like field laws but for the class of objects that includes IO) specifically states that do { x <- action ; return x } is precisely equivalent to action.
14:26:39 <UUStudent> hey guys, i don't know what monads are
14:26:55 <UUStudent> i'm have just began with haskell
14:27:18 <sorear> just a class of objects that includes IO, in the same way that fields include the reals
14:27:54 <sorear> any statement about monads applies to IO, so instantiating:
14:28:06 <sorear> one of the IO laws specifically states that do { x <- action ; return x } is precisely equivalent to action.
14:28:34 <sorear> just like any statement about numbers applies to 42.
14:29:05 <sjanssen>  @yow
14:29:06 <SamB> "a number is the answer"
14:29:07 <UUStudent> oke, and how can i change the type of the output so that for example a function FilePath -> [Date]
14:29:15 <SamB> does that apply to 42?
14:29:31 <sorear> @ask twanvl [wrt Data.Derive] why do we need both ctorArity and ctorTypes
14:29:32 <lambdabot> Consider it noted.
14:30:11 <qwr> UUStudent: if it wants to get dates from file, then you need FilePath -> IO [Date]
14:30:12 <sorear> SamB: a is the existential quantifier/article, so that statement need not apply to all nubers
14:30:23 <twanvl> sorear: no, just the latter should do
14:30:23 <sorear> @users
14:30:24 <lambdabot> twanvl: You have 1 new message. '/msg lambdabot @messages' to read it.
14:30:24 <lambdabot> Maximum users seen in #haskell: 337, currently: 324 (96.1%), active: 37 (11.4%)
14:30:45 <sorear> 337!
14:30:56 <qwr> UUStudent: haveing type IO a means, that this thing interacts with outside world. like files.
14:31:01 <UUStudent> yes I know but first i have to parse them, that's why i wanted to store the content first in a string
14:31:03 <augustss> haskell is growing
14:31:59 <qwr> UUStudent: inside this function you can get it temporily into String (like the x in your example) and process it into [Date], and finally return the dates into IO [Date]
14:32:21 <sciolizer> UUStudent: do { x <- readFile filename; result <- doStuff x; return result }
14:32:29 <sciolizer> doStuff :: String -> whatever
14:32:56 <sorear> Philippa: have you looked at Yhc/TMR?
14:33:00 <UUStudent> if i understand it correct: the last do statement is the type of the whole output
14:33:08 <qwr> if the doStuff do not return IO action, you'd want let result = doStuff x
14:33:21 <sciolizer> qwr: right. Sorry about that.
14:33:54 <Philippa> sorear: no?
14:34:43 <Philippa> you're lucky I caught that btw, it's generally better to PM me if I've been quiet for more than a couple of minutes
14:35:16 <norpan> Philippa: playing hard to get eh?
14:35:55 <UUStudent> and what can i use to print a function with type IO [Date] -> IO ()
14:36:17 <Botje> print a function?
14:36:25 <qwr> blaah >>= print
14:36:31 <UUStudent> show it on the screen!
14:36:45 <xian> has anyone made any experiences with lhs2Tex? if so, do you know how to embed haskell-code on the fly (without the necessity to wrap a {code}-environment around it)
14:36:50 <qwr> where blaah is the IO [Date] thing
14:37:08 <qwr> UUStudent: or do { dates <- blaah; print dates }
14:38:33 <qwr> @src print
14:38:33 <lambdabot> print x = putStrLn (show x)
14:39:38 <UUStudent> okay, thanx very much guys. I'm gonna work this out them
14:43:29 <sjanssen> @remember SvenPanne taking away the prelude is a little bit like taking away 'int', 'double', 'for', 'while' etc. from the C programmer
14:43:29 <lambdabot> Done.
14:45:12 <sorear> how do we know what "nick" to use for people like SvenPanne?
14:45:40 <sjanssen> sorear: I just made that up
14:45:57 <sjanssen> as far as I know he doesn't spend time in #haskell
14:46:30 <lekro> what's a good way to implement caching? I wrote this function, but it doesn't seem to be as fast as it could: http://paste.lisp.org/display/38643
14:46:35 <sorear> yeah, well, StefanO'Rear has lambdabot quotes
14:46:44 <sorear> as do both SPJ and SimonPJ
14:46:57 <sorear> @quote SimonM
14:46:58 <lambdabot> No quotes match. stty: unknown mode: doofus
14:47:43 <sorear> @quote SMarlow
14:47:44 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
14:47:49 <sorear> @quote SimonMarlow
14:47:50 <lambdabot> No quotes match. I've seen penguins that can type better than that.
14:47:58 <sorear> (yes I know his real nick)
14:47:58 <sjanssen> lekro: that looks good, if Data.Map is the best data structure to hold your data
14:48:03 <sorear> @quote IanLynagh
14:48:04 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
14:48:30 <sjanssen> the quotes file is binary+gzip nowadays?
14:48:39 <sorear> at least gzip
14:48:48 <sorear> I think it's still read/show underneath
14:48:57 <lekro> sjanssen: I don't know if it is the best data structure. atm I only need Integer-Integer-Caching
14:49:21 <sorear> IntMap is a little faster for Int
14:49:24 <sjanssen> lekro: if you need Integer, then Data.Map is probably the best
14:50:20 <sorear> lekro: btw, #haskell has a channel pastebin
14:50:24 <sorear> @paste
14:50:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:50:42 <sorear> we don't insist you use it of course
14:50:51 <sorear> it just auto-announces
14:51:01 <lekro> ah, ok :)
14:51:09 <sorear> and it's written in Haskell
14:51:13 <sorear> big plus, that
14:53:12 <kosmikus> xian: (lhs2tex) what?
14:58:11 <vincenz> @flip \Botje -> Botje
14:58:11 * lambdabot smacks \Botje -> Botje about with a large trout
15:03:27 <xian> kosmikus: lhs2tex is a tex preprocessor. it translates a (la)tex document which contains haskell code into a proper .tex-file.
15:03:56 <xian> btw, i already foundwhat i was looking for.
15:10:03 <kosmikus> xian: I know what lhs2tex is. I didn't understand the question though.
15:10:35 <Heffalump> xian: kosmikus *wrote* lhs2tex :-)
15:10:52 <Heffalump> or at least maintains it now, I can't remeber its history
15:11:42 <sjanssen> awkward :)
15:12:45 <hpaste>  sciolizer annotated "using generics to deserialize a dictionary" with "unpickling of a dictionary" at http://hpaste.org/1121#a1
15:13:12 <sciolizer> I still don't understand rank2, but like nmd (I think) said, you don't need to in order to use generics. :)
15:13:36 <sciolizer> Anyway, thanks to everyone for your help. Sorear, I will later take a look at some of your examples from earlier.
15:15:42 <xian> kosmikus: oh, ok, i'm sorry. i was looking for a way to embed haskell code without using \begin{code} and \end{code} so that code and normal text can go together on the same line.
15:16:23 <xian> kosmikus: a few minutes later, while browsing the manual, i found that |code| is what i needed.
15:17:02 <bringert> xian: I wanted to do that just the other day. I wrote a script that cats together a header, the code, and a footer, and then run lhs2TeX on it
15:18:28 <bringert> xian: what's that |code| thing?
15:19:56 <bringert> xina: oh, sorry, I misread your question. you wanted something else
15:20:06 <xian> bringert: it processes code between two | symbols
15:20:14 <xian> yeah, probably
15:20:51 <bringert> yeah |...| does what you want, I think I've even used it at some point
15:30:39 <mboes> hey, could anyone give me any indication of how long/hard it would be to write a registerised version of GHC for ARM?
15:32:02 <stepcut> mboes: I can
15:32:27 <stepcut> It is not very hard/long, once you know how, but it can take a while to learn how
15:32:53 <stepcut> which arm platform ?
15:32:59 <mboes> the Nokia N800
15:33:15 <stepcut> I have partially ported GHC to the 770
15:33:21 <stepcut> but ran out of time :-/
15:33:24 <Philippa> I still need to get an unregisterised version on my zaurus :-(
15:33:37 <stepcut> mboes: have you got an unregisterized build done yet ?
15:33:43 <Heffalump> does the specific ARM platform make much difference?
15:33:58 <mboes> i was at the GHC Hackathon last year during which time SimonM and SimonPJ detailed the innards of GHC so have a vague idea of how the RTS works, but oh so vague ;)
15:34:10 <Philippa> Heffalump: potentially. Certainly makes one for the libs
15:34:29 <stepcut> Heffalump: it could -- for example, a port to ARM/Linux is probably easier than ARM/VxWorks
15:34:29 <hyrax42> yay ghc 6.6
15:34:30 <Igloo> mboes: I think Arm knowledge is probably more important than RTS knowledge
15:34:36 <mboes> stepcut: not yet, but that's just because it takes so long to build on my system. The instructions on the wiki seem up to date
15:34:53 <Heffalump> stepcut: oh, right, yeah. I meant the specific hardware rather than the OS.
15:35:06 <mux> is it possible to have two different gtk callbacks called concurrently?
15:35:10 <Igloo> You can get Arm/Linux unregisterised binaries from Debian
15:35:19 <stepcut> mboes: the wiki is pretty close to up-to-date, but I had to do a bit of hacking to get it to build
15:35:33 <Philippa> Igloo: yeah, I still haven't done the relevant upgrades, I've been bad about that
15:35:43 <mboes> think this project would be suitable for SoC?
15:36:10 <stepcut> this is a page I started about my experience, but it is not complete, and it some cases, wrong :-/ http://hackage.haskell.org/trac/ghc/wiki/ArmLinuxGhc
15:36:12 <lambdabot> Title: ArmLinuxGhc - GHC - Trac
15:36:44 <mboes> stepcut: how far did you get to having a registerised version working?
15:36:48 <stepcut> mboes: I could certainly be done in a summer, if anything it might be to short
15:36:55 <stepcut> mboes: I am checking that right now
15:37:43 <kosmikus> xian: ok. glad you found what you were looking for.
15:39:45 <hpaste>  Botje pasted "groepeer" at http://hpaste.org/1122
15:39:58 <stepcut> mboes: I got an unregisterised build working, and I did the first step in section 9.2.2, which is adding the STG register->machine register mapping to ghc/includes/MachRegs.h
15:41:03 <stepcut> mboes: I did not test my register mappings though. I think you need to do the first two steps at the same time
15:41:41 <stepcut> mboes: and you might be able to skip the last step since there is already Linux support
15:42:33 <stepcut> mboes: also, in the past, before maemo supported EABI, I had to do a little hack to get floating point working properly, because the old ARM system used a funny floating point word ordering
15:42:42 <stepcut> mboes: I did not see if that is still a problem or not
15:43:01 <Heffalump> Debian isn't using EABI, so presumably that's been sorted properly in GHC anyway
15:43:51 <hpaste>  stepcut pasted "my ARM register mapping" at http://hpaste.org/1123
15:43:52 <Igloo> It has
15:45:12 <Botje> is it possible to make (a, [b]) an instance of Ord?
15:45:20 <Botje> (a and b are both Ord)
15:45:36 <allbery_b> @instances Ord
15:45:37 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
15:45:46 <Igloo> It already is an instance
15:45:48 <dmwit> It should be automatic...
15:45:51 <stepcut> mboes: the instructions for doing an unregisterised build are very good -- but the steps for doing the registerising don't seem well documented, so adding some good documentation would be great
15:45:59 <Botje> ehh
15:46:13 <Botje> > (1,2) `compare` (3,4)
15:46:15 <lambdabot>  LT
15:46:17 <Heffalump> why don't you think you need to preserve r9?
15:46:23 <Botje> > (1,2) `compare` (1,4)
15:46:24 <lambdabot>  LT
15:46:31 <Botje> heh.
15:46:32 <Botje> that's nice!
15:47:29 <stepcut> Heffalump: let me look
15:48:04 <Heffalump> and you should always be able to use r12, but not across function calls, it's neither caller-saved nor callee-saved
15:48:18 <stepcut> Heffalump: my guess is, ignorance
15:49:02 <Heffalump> r0-r3 are caller-saved/argument-passing. r4-r11 are callee-saved. r12 is neither. r13-r15 should be treated with care.
15:49:25 <Heffalump> though you can use r14 if you save it first (and don't expect it to be preserved across a function call)
15:49:30 <hpaste>  dmwit annotated "groepeer" with "Is this equivalent?" at http://hpaste.org/1122#a1
15:50:05 <dmwit> Whoops, no, it isn't.
15:50:46 <mboes> stepcut: yeah, was looking at that. There seems to be a lot in the code though. I guess getting a registerized build is not too hard, writing an NCG seems like more work.
15:51:17 <dmwit> There, that one is better.
15:51:17 <stepcut> Heffalump: I sort of ignored r9, because I was not sure if I could use it. I thought that since I did not explicity use it for anything, nothing would break?
15:51:43 <Heffalump> oh, sure, if you don't touch it then you'll certainly be fine
15:51:59 <Heffalump> but it's no different to the rest of r4-r11 in ARM state, AFAIK
15:52:10 <Heffalump> (Thumb state is a whole different kettle of fish)
15:52:45 <Igloo> gcc might use it for something though, right?
15:52:49 <stepcut> mboes: yeah, if you look through the code there is definately some extra info in there. I found that reading the STG paper helped me understand what was going on better too -- but if you were at the GHC internals thing, you might already know enough
15:53:05 <fasfafa> http://lads.sytes.net Join Please
15:53:10 <lambdabot> Title: lads - [ LV ]
15:54:09 <stepcut> Heffalump: the call spec I looked at says, r9/v6 - SB - ARM-state variable register 6, Static Base in PID/re-entrant/shared-library variants
15:54:24 <Heffalump> ahh.
15:54:30 <Heffalump> ok, perhaps you should just ignore me :-)
15:55:00 * Heffalump used to work on ARM's own C compiler, but is quite forgetful and didn't pay that much attention to the special conventions used for relocatable code.
15:55:05 <stepcut> maybe -- I have never written any assembly for the ARM so...
15:56:47 <JohnMeacham> SamB: those should not be in darcs repos. they arn't original source. run 'autoreconf' to have autoconf install them properly.
15:57:13 <stepcut> Heffalump: You said that Debian does not support EABI -- do you know about the armel project ?
15:58:25 <Heffalump> stepcut: yes - I meant currently.
15:58:59 <stepcut> Heffalump: ah. Well, maemo (nokia's Linux distro) is based on armel
15:59:03 <Heffalump> as in "if GHC works on ARM in Debian currently, then the FPA  middle-endian floating point representation must be supported"
16:01:16 <stepcut> mboes: If you are interested in doing a port to the 770/800, I would be interested in helping
16:04:57 <mboes> stepcut: thanks for the info you've given so far. I'm looking into this in more detail and will be writing up a proposal. Any help with the implementation work would be appreciated :)
16:06:19 <stepcut> mboes: Providing good documentation on how to do the registerising process is probably more valuable than the port itself :p
16:07:54 <Botje> dmwit: I appreciate the refactoring :)
16:08:08 <Botje> (a bit late but better late than never)
16:08:19 <dmwit> =P
16:08:47 <mboes> stepcut: that may well be. An interesting extension to the ARM porting would be to get all the other platforms that GHC used to support (eg. Sparc) back up to par.
16:08:56 <stepcut> yeah
16:09:58 <stepcut> mboes: I am already overbooked with projects -- but at the very least, I can backport the port from the 800 to the 770 -- that should be pretty straightforward
16:10:09 <kyevan> mreh. Don't you hate it when you have a solution for a problem in one language and just can't seem to get it to translate nicely?
16:11:08 <kyevan> (In this case, finding the node on a tree with the highest number in one slot, of all nodes with the symbol 'brown in another, in a scheme subset (+ a couple things, like structure definitions))
16:12:08 <mboes> stepcut: myes, though the 770 isn't EABI based, am I right. But then the only real difference there is in the syscall convention and the floating point code, IIRC
16:12:53 * kyevan wishes eir class used Haskell instead of scheme. Oh well
16:13:05 <stepcut> mboes: the 770 is armel now, though it did not used to be
16:13:22 <stepcut> mboes: so, hopefully, I just have to recompile against a different set of libraries ;)
16:13:49 <mwc> If I switch over to the stable branch of ghc, am I gonna regret it?
16:13:57 <christine_c> hello people
16:14:01 <mwc> Welcome
16:14:20 <christine_c> mwc...are you a database programmer?
16:14:21 <stepcut> mboes: in 6.4, I just had to add a specific #ifdef for the floating-point
16:14:58 <mwc> christine_c, even worse, I'm an applied mathematician
16:15:00 <stepcut> mwc: what are you switching from? head ?
16:15:05 <mwc> stepcut, 6.6 release
16:15:26 <christine_c> i see
16:15:27 <christine_c> o
16:15:29 <christine_c> ok
16:15:52 <vincenz> 6.6 is stable
16:16:02 <mwc> There's also a stable branch
16:16:11 <sorear> hello!
16:16:27 <vincenz> sorear: do you ever sleep?
16:16:34 <sorear> vincenz: yes.
16:16:39 <sorear> @localtime
16:16:41 <lambdabot> Local time for sorear is Sat Mar 24 16:14:58 2007
16:16:45 <vincenz> \/ever.ever > 0
16:17:00 <sorear> generally, from 2200 to 0600
16:17:10 <vincenz> your a hs student?
16:17:14 <sorear> yeah
16:17:15 <vincenz> s/your/you're
16:17:19 <mwc> 8 hours? that's unheard of
16:17:29 * stepcut sleeps 9
16:17:31 <vincenz> mwc: too little?
16:17:38 * Heffalump sleeps about 6 hours on weeknights :-/
16:17:46 <sorear> it's easier, since I have two hours of bus time to sleep :)
16:17:48 <mwc> I didn't start sleeping more than 6 hours a night until I got to university and didn't go to morning classes
16:18:02 <mwc> sorear, live in the sticks?
16:18:03 <oguz> any ways to get pre-bootstrapped ghc?
16:18:15 <sorear> oguz: download from the website
16:18:21 <vincenz> stepcut: phd student?
16:18:22 <kscaldef>  I always slept 8 hours until I had a kid
16:18:24 <sorear> http://www.haskell.org/ghc
16:18:26 <lambdabot> Title: The Glasgow Haskell Compiler
16:18:28 <sorear> mwc: ?
16:18:30 <stepcut> vincenz: working man
16:18:43 <mwc> sorear, that you'd get an hour of bus time each way, you must live out of the city?
16:18:59 <oguz> sorear: but i need a haskell compiler, don't i?
16:19:07 <sorear> mwc: more reflection, it's actually 45m or so
16:19:08 <mwc> oguz, download binaries
16:19:17 <stepcut> oguz: what platform ?
16:19:26 <oguz> stepcut: linux
16:19:30 <stepcut> oguz: what distro ?
16:19:34 <mwc> oguz, you also have the option of building from intermediate c files that've been pre-cooked by the developers in the source package
16:19:41 <sorear> mwc: anyway this is a fairly small school, so each busroute covers a considerable amount of geography
16:19:50 <mwc> ahhh
16:20:01 <oguz> the problem is, i am trying to builg ghc on a distro called pardus
16:20:07 <sorear> mwc: this is the only school in its niche in the san diego unified district
16:20:09 <oguz> and there are no other haskell compilers included
16:20:28 <sorear> oguz: the binaries on haskell.org are pretty much distro independant
16:20:29 * stepcut is in Hillcrest
16:20:34 <mwc> oguz, download the vanilla linux binaries, install to say /opt/haskell, then use that to build a version from source that complies with your package manager
16:21:03 * sorear is suprised at how many #haskellers are in ca.us
16:21:12 <stepcut> oguz: http://www.haskell.org/ghc/download_ghc_66.html#x86linux
16:21:14 <lambdabot> Title: GHC: Download version 6.6
16:21:20 <oguz> trying
16:22:29 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1124
16:23:38 <sorear> mmh, looks like dutch
16:27:34 <dmhouse> ?src foldr
16:27:35 <lambdabot> foldr k z xs = go xs
16:27:36 <lambdabot>     where go []     = z
16:27:36 <lambdabot>           go (y:ys) = y `k` go ys
16:28:25 * kc5tja used to live in San Diego, but now lives in Mountain View.
16:29:19 <dmhouse> Remarks on foldr/foldl differences: foldr is a catamorphism on lists, which is why it's considered more fundamental in Haskell. foldl is tail-recursive, which is why it's considered more fundamental in Scheme. Would that be true?
16:30:06 <mwc> wtf is a catamorphism
16:30:17 <sjanssen> dmhouse: yes, Scheme's evaluation strategy means that foldr will always consume O(n) stack
16:31:11 * sorear uninstalls firefox
16:31:28 <dmhouse> mwc: if you write a list down like 1 : 2 : 3 : 4 : 5 : [], then replace every : with a `f`, and replace the [] with z, and compute what's there, you get foldr f z the_list.
16:31:53 <mwc> yeah, I think I get the idea from looking up the catamorphism article on wikipedia. They give an example of a tree catamorphism
16:32:00 <sorear> meanwhile, Haskell's evaluation strategy guarantees that foldl will always consume O(n) stack.
16:32:26 <sjanssen> modulo strictness analysis
16:32:31 <sorear> (unless you feel like relying on compiler cleverness to reduce the asymptotic cost of your program, which I for one don't)
16:33:01 <dmhouse> sorear: the others are O(1) space?
16:33:19 <sjanssen> dmhouse: depends on the function you're folding
16:33:27 <Heffalump> Haskell's evaluation strategy doesn't guarantee anything, does it? :-)
16:33:30 <sjanssen> foldl isn't O(n), its Omega(n)
16:33:59 <jcreigh> sjanssen: what's Omega(n)?
16:34:19 <mwc> jcreigh, worse cast complexity
16:34:36 <sjanssen> jcreigh: O means roughly "fits under", Omega roughly means "fits over"
16:34:48 <sjanssen> mwc: that isn't quite accurate
16:34:50 <mwc> omicron = best case, O = average case, Omega = worst case. Of course, with my memory, it's some sort of bizarre permutation
16:35:05 <jcreigh> okay, so O(n) is "worst case" and Omega(n) is "best case"?
16:35:15 <oguz> ghc
16:35:27 <dmhouse> hugs
16:35:41 <sjanssen> f \in O(g) means the function f is asymptotically less than or equal to g
16:35:55 * dmhouse wins this round of name-a-Haskell-implementation! :)
16:35:57 <sjanssen> f \in Omega(g) means f is asymptotically greater than or equal to g
16:36:03 <mwc> sjanssen, I thought that O(f) meant that as t -> infinity, the run time T(t) of the function had the property that T(t)/f(t) = k for some real constant k.
16:36:17 <sjanssen> mwc: yes, I'm speaking very roughly
16:36:21 <mwc> I don't really undersant the "fits under/over" business
16:36:59 <sjanssen> over/under is the intuition behind the notation
16:39:57 <sjanssen> http://en.wikipedia.org/wiki/Big_O_notation#Related_asymptotic_notations:_O.2C_o.2C_.CE.A9.2C_.CF.89.2C_.CE.98.2C_.C3.95
16:40:00 <mwc> hmmm, so Omega(f) means that as t -> infinity, the runtime T(t) has the asymptotic behaviour f(t)/T(t) \elem |R
16:40:00 <lambdabot> http://tinyurl.com/2j4p9
16:41:11 <mwc> so the over under refers to the function T(t) fitting over or under the function f to give a finite limit?
16:41:49 <mwc> maybe I'm overanalyzing this
16:42:38 <sjanssen> firstly, O, Omega, etc. aren't necessarily about runtime
16:43:15 <mwc> oh, I know, it's functional asymptotic behaviour at infinity
16:43:15 <sorear> Indeed, this whole argument was started by my use in the context of stack usage.
16:43:17 <sjanssen> they're concepts that work for all functions
16:43:30 <mwc> it's just that I only ever see them being applied to run time
16:43:32 <rashakil> mwc, f \in O(g) means that |f(n)/g(n)| has an upper bound.  (If we pretend they're positive and g(n) != 0.)
16:43:38 <jcreigh> gah, don't understand all the funny symbols. But the upshot is that an O(n) algorithm will take, *at most*, N units of whatever (time, space) and an Omega(n) algorithm will take, *at least* N units of whatever.
16:43:39 <mwc> maybe stack space 10% of the time
16:43:39 <sorear> I have *such* a knack for inciting "lively debates".
16:43:42 <jcreigh> right?
16:43:57 <mwc> rashakil, and omega implies it has a lower bound?
16:44:13 <rashakil> well, a lower bound that's greater than zero.
16:44:22 <sjanssen> jcreigh: yes, this is a solid intuition
16:44:40 <hpaste>  oguz pasted "(no title)" at http://hpaste.org/1125
16:44:54 <oguz> any opinions?
16:45:00 <sorear> hpaste: hexedit!
16:45:11 <mwc> rashakil, thanks
16:45:12 <dmhouse> I hate how a two-character function in Haskell, ++, becomes a 13-character function, string-append, in Scheme.
16:45:32 <dmhouse> oguz: install readline/
16:45:36 <mwc> dmhouse, but just think about how that gets you such wonderful uniform syntax in return ;)
16:45:38 <dmhouse> *?
16:45:45 <sorear> oguz: use a hex editor to change the string "libreadline.so.4" to "libreadline.so.5" in the ghc binary
16:45:54 <sorear> oguz: I'm not kidding - this worked for me.
16:46:16 <oguz> sorear: i'll give it a try
16:46:21 <dmhouse> mwc: I realise that was sarcastic, but I actually like Lisp's syntax. It has a minimalistic appeal to it.
16:46:39 <sorear> dmhouse: .4 is a semi-obsolete version that some distros no longer ship with.
16:46:51 <sorear> dmhouse: (anyway if you have bash you have libreadline)
16:46:55 <dmhouse> (Which is why I like Scheme. It's interesting because it's simple and minimalistic, which is how Lisps should be, IMO.)
16:47:12 <mwc> dmhouse, I played with scheme but it was too minimalistic for my tastes
16:47:31 <sorear> dmhouse: now imagine scheme with type classes... (++ "foo" "bar")
16:48:13 <mwc> sorear, you don't need to... can't you just have ++ introspect on the types of the arguments and tailcall a specialized version of itself?
16:48:46 <sorear> mwc: that wouldn't be extensible
16:49:26 <mwc> well, it's extensible at the point of ++'s definition :)
16:50:24 <mwc> but I imagine you could just look up the type of the arguments in a map to get the proper instance method, and provide a mechanism for clients to insert bindings into that map
16:50:45 <mwc> (register-++ ....)
16:50:53 <nmessenger> i.e. implement type-based dispatching yourself. :D
16:50:54 <jcreigh> like, oh, I don't, a type class? :)
16:50:57 <sorear> that fails to be suitibly extensible because it requires boilerplate code for each overloaded operations
16:51:20 <mwc> I'm sure you could in turn solve that with creative macros
16:51:23 <sorear> how about a lisp where you can add equations to functions?
16:52:25 <mwc> y'all realize I'm playing this out to illustrate my disaffection with scheme, right?
16:52:35 <dmhouse> sorear: how about a Haskell without a type system?
16:52:38 * nmessenger didn't realize
16:53:01 <dmhouse> sorear: "But that wouldn't be very Haskelly!" Exactly, and multiple equations/type classes/what have you aren't Lispy.
16:53:51 <sorear> dmhouse: oh.
16:54:01 <sorear> dmhouse: I thought I was describing the advice system
16:54:05 <mwc> I haven't really tried to live with scheme, but the biggest Scheme fan I know, Comp sci graduate at Waterloo, still uses C++ for his day to day one-off tasks
16:54:11 <sorear> dmhouse: but then I've never seriously used lisp
16:54:18 <sorear> dmhouse: sorry for misunderstanding
17:04:44 <Blackfoot> i'm trying to understand the generics package
17:05:03 <Blackfoot> can i get the constructors of any datatype?
17:05:14 <sorear> sure
17:05:20 <Blackfoot> i don't understand how to referrence a type
17:05:29 <sorear> undefined :: Type
17:05:43 <sorear> see, fex, ndm's deriving code
17:05:58 <sorear> uses syb to find the constructors of a data type
17:06:03 <sorear> then generates instances
17:06:16 <Blackfoot> ok, i'll search for it
17:06:22 <sorear> @where derive
17:06:23 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
17:06:36 <sorear> sorry for taking away your fun :)
17:07:13 <Blackfoot> haha, no, this is much easier :)
17:15:32 <meester> :l Data.Set in ghci gives the error 'module `Data.Set' is a package module'
17:15:35 <meester> what does this mean?
17:15:53 <Heffalump> :m +Data.Set
17:15:56 <jcreigh> meester: means you can't load modules with :l
17:16:47 <meester> danke
17:20:11 <Blackfoot> sorear: if I'm defining my own datatypes, do they have to derive stuff from Generics?
17:20:20 <sorear> Blackfoot: ?
17:20:32 <sorear> Blackfoot: in GHC you can just say deriving(Data,Typeable)
17:24:05 <nmessenger> Blackfoot: you have to add {-# OPTIONS_GHC -fglasgow-exts #-} to the first line of your source file to get Data and Typeable deriving.
17:24:32 <Blackfoot> i see, then you're able to use the generics code on types you've defined
17:27:56 <sorear> hello.
17:53:24 <jdrake> Is there a way I could redefine things that are already defined for the purposes of trying to implement them (as a learning exercise). I am currently editing a file and loading it in ghci.
17:54:09 <stepcut> import Prelude hiding (functionYouWantToReimplement)
17:54:35 <sorear> There's a bit of magic in the Report for that
17:54:40 <Igloo> Or import Prelude () if you want to reimplement everything
17:54:54 <sorear> if you import the prelude *ex*plicitly, it won't be imported *im*plicitly
17:55:19 <EvilTerran> you'd still be able to access prelude functions as Prelude.whatever if you do it Igloo's way
17:55:38 <EvilTerran> but your main namespace is clear
17:56:10 <sorear> Igloo++ As usual, my idea for a better way to specify extensions came a little too late.
17:56:33 <jdrake> Thank you
18:00:54 --- mode: ChanServ set +b *!*@88.232.*
18:08:01 <HairyDude> I have an FC6 system with HaXML apparently installed in /usr/lib64/hugs/packages/HaXML, and my path includes {Hugs}/packages/*, which I would have thought would catch it, but :m Text.XML.HaXml in hugs seems not to work
18:09:14 <mutjida> @users
18:09:14 <lambdabot> Maximum users seen in #haskell: 337, currently: 307 (91.1%), active: 43 (14.0%)
18:09:32 <stepcut> HairyDude: you might have to do something like, '-package HaXml' on the command-line to get Hugs to add that package -- not sure what the Hugs syntax is
18:10:38 <HairyDude> ah, looks like just giving the module name as if it were a filename argument seems to work... but...
18:10:40 <HairyDude> ERROR "/usr/lib64/hugs/packages/HaXml/Text/XML/HaXml/XmlContent.hs":584 - Syntax error in data type declaration (unexpected `.')
18:11:20 <dons> hmm. does haxml even work with hugs?
18:11:24 <HairyDude> ah, it uses existentials
18:11:28 <dons> try hugs -98
18:11:30 <dons> or else use ghc.
18:11:33 <sorear> hello dons!
18:11:33 <dons> really, use ghc . :-)
18:11:40 <dons> morning!
18:11:46 <sorear> hugs is faster at loading still :(
18:12:02 <HairyDude> sorear: which makes it better for cgi apps
18:12:08 <dons> i doubt it would be loading haxml
18:12:11 <sorear> and my start-time benchmark has been dropped from nobench :)
18:12:18 <dons> HairyDude: hmm? wouldn't you compile your code first?
18:12:36 <dons> your compiled cgi code should run at C-ish speeds, unlike hugs, which is about 20x slower
18:12:55 <sorear> dons: no, ghci is 20x slower rt
18:13:02 <sorear> @where nobench-results
18:13:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
18:13:10 <HairyDude> bah, I'm used to doing web development in scripting languages, haskell should conform to my expectations! ;)
18:13:16 <sorear> hugs is more like 7000x slower runtime :)
18:13:21 <sorear> but 4x faster loading
18:13:31 <dons> wrt. ghci
18:13:33 <dons> not to ghc.
18:13:48 <sorear> yeah.  ghc compiled loads in ~20ms
18:13:56 <sorear> ghci loads in 800ms or so
18:13:58 <HairyDude> out of interest, is there some kind of mod_haskell that's been updated in the last 5 years?
18:13:59 <sorear> hugs 250ms
18:14:06 <dons> so hugs comes in at 41.87x slower.ghci at 19.88x
18:14:23 <sorear> HairyDude: would HAppS fit your bill?
18:14:39 <sorear> #happs, happs.org
18:14:52 <HairyDude> from what little I read of it, it seems overkill
18:15:11 <dons> its pretty nice though. runs hpaste.org
18:16:01 <sorear> it also doesn't interact with apache at all, which could be a nuisance if you also have to serve eg perl cgi
18:16:48 <HairyDude> it'd be kind of nice if it ran on port 80 :)
18:16:57 <HairyDude> (given that the server already has apache on it)
18:17:21 <HairyDude> oh, plus HAppS seems not to be in fedora extras
18:21:20 <sorear> it's in debain
18:22:03 <sorear> @localtime shapr
18:22:04 <lambdabot> Local time for shapr is Sat Mar 24 20:20:22 2007
18:22:34 <stepcut> @gps-coordinates shapr
18:22:35 <lambdabot> Unknown command, try @list
18:22:39 <sorear> HairyDude: talk to shapr - he hosts hpaste.org, which runs apache on port 80 using some weird configuration foo
18:22:47 <sorear> stepcut: Alabama
18:23:18 <stepcut> sorear: yeah, I know that much, I was looking for higher precision
18:23:53 <stepcut> shapr == The #1 Haskell Programmer in Alabama :)
18:24:44 <sorear> stepcut: Birmingham
18:24:47 <HairyDude> I really don't want to go fiddling about with webserver configurations just to get started with writing Haskell web scripts - I'm not an admin on the server
18:25:07 <ikegami--> WebFunction is another web authoring system in Haskell
18:25:28 <ikegami--> oops, correctly, WebFunctions
18:28:19 <bd_> ?where soc
18:28:19 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
18:30:33 <sorear> stepcut: Google Phonebook saz:     B Gilliam        (205) 978-4543  728 Twin Branch Dr,Birmingham, AL 35226  Map
18:30:58 <sorear> where B Gilliam is shapr's birth name - S Erisson gives no hits
18:31:42 * sorear derives far too much pleasure from google stalking
18:31:49 <jdrake> Is it possible to create a function like factorial that is expressed like 5! ?
18:31:57 <sorear> not really
18:32:36 <HairyDude> 5 ! () I suppose, but that's horrid :)
18:32:43 <jdrake> yes
18:32:50 <dolio> > let (0 !) = 1 ; (n !) = n * ((n - 1) !) in (5 !)
18:32:50 <lambdabot>  Parse error in pattern
18:33:15 <dolio> > let (!) 0 = 1 ; (!) n = n * ((n - 1) !) in (5 !)
18:33:16 <lambdabot>  120
18:33:36 <HairyDude> interesting
18:33:43 <bd_> The parenthesis aren't optional in that case though :)
18:33:49 <bd_> > let (!) 0 = 1 ; (!) n = n * ((n - 1) !) in 5! + 3
18:33:50 <lambdabot>  Parse error
18:34:01 <nmessenger> no actual support for postfix operators, but sections approximate them :)
18:34:10 <sorear> actually, they don't
18:34:16 <sorear> this is #haskell not #ghc
18:34:21 <nmessenger> true
18:34:31 <sorear> (nb: #ghc is devel only)
18:34:52 <ddarius_> @google Typed Quote/AntiQuote
18:34:55 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
18:37:31 <sorear> now if only UNloading emacs modes was as easy as loading them :)
18:37:41 * sorear has decided shim isn't worth it
18:46:43 <nmessenger> does haskell' specify (x `op`) as (\y -> x `op` y) or (op x)?
18:49:05 <dolio> :t (`id`)
18:49:07 <lambdabot> parse error on input `)'
18:49:48 <twanvl> http://haskell.org/onlinereport/exps.html#sect3.5
18:49:48 <dolio> :t ( `id` )
18:49:49 <lambdabot> Title: The Haskell 98 Report: Expressions
18:49:51 <lambdabot> parse error on input `)'
18:50:20 <HairyDude> nmessenger: how are they different?
18:50:43 <twanvl> I doubt Haskell' changes this
18:50:51 <nmessenger> HairyDude: just the situation above.  If op is a unary function, (\y -> x `op` y) is a type error.
18:52:22 <jdrake> @src zip
18:52:22 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
18:52:23 <lambdabot> zip _      _      = []
18:54:55 <jdrake> @src (:)
18:54:56 <lambdabot> Source not found. My mind is going. I can feel it.
18:54:58 <HairyDude> ah yes
18:55:17 <nmessenger> @src []
18:55:17 <lambdabot> data [] a = [] | a : [a]
18:55:21 <nmessenger> ^^ jdrake
18:56:33 <nmessenger> "A list of a's ([] a or [a]) is a datatype defined as either the empty list value ([]) or an a consed (:) onto a list of a's."
18:57:01 <jdrake> nmessenger: That definition is mildly confusing to me. How does [] a be the same as [a]
18:57:13 <nmessenger> jdrake: [a] is special syntax
18:57:13 <HairyDude> does hugs ignore a leading #! line?
18:57:25 <nmessenger> data List a = Nil | Cons a (List a) -- equivalent
18:58:26 <jdrake> ok
18:59:18 <HairyDude> ah, seems it does
19:00:18 <dylan> anyone here running linux on ppc hardware with bcm43xx?
19:00:20 <jdrake> With my attempt at implementing zip, it appears I did a little more than necessary. Adding something like zip (x:[]) (y:ys) = (x,y) instead of just doing zip _ _ =
19:00:43 <dylan> if so, I could really use some working firmware.
19:02:47 <nmessenger> jdrake: did you also define the cases zip [] (y:ys) and zip (x:xs) []?
19:03:49 <jdrake> nmessenger: http://hpaste.org/1126
19:04:31 <nmessenger> jdrake: as it is, zip _ _ always matches, so zip always returns [].
19:05:31 <jdrake> Good point
19:05:57 <nmessenger> move it after the (x:xs) (y:ys) case
19:06:48 <nmessenger> jdrake: was your original the two commented out cases plus the last case?
19:06:56 <jdrake> yes
19:07:12 <nmessenger> zip [] [1,2,3] would be undefined
19:07:15 <jdrake> I know it does not cover the [] case
19:07:27 <nmessenger> alrighty :)
19:07:35 <jdrake> I should say, that I know now :p
19:07:59 * HairyDude gets the cgi "hello world" program working
19:09:15 <nmessenger> jdrake: in ghc, -Wall will tell you if you forget cases
19:10:07 <Saizan> > let replicate 0 c = []; replicate n c = c : replicate (n-1) c in replicate 3 c -- no need for ++
19:10:08 <lambdabot>   Not in scope: `c'
19:10:21 <Saizan> > let replicate 0 c = []; replicate n c = c : replicate (n-1) c in replicate 3 'c' -- no need for ++
19:10:22 <lambdabot>  "ccc"
19:10:45 <nmessenger> [x] ++ xs = x : xs
19:11:58 <nmessenger> @scheck (\x xs -> [x] ++ xs == x : xs) :: Int -> [Int] -> Bool
19:12:02 <lambdabot>   Completed 325767 test(s) without failure.
19:12:12 <nmessenger> :D
19:12:25 <Saizan> 325787? :O
19:13:06 <dmwit> jcreigh: ping
19:13:11 <nmessenger>  @scheck++
19:14:38 <nmessenger> "Small Check" indeed!
19:15:58 <dcoutts> well, it starts small :-)
19:16:00 <sorear> .
19:16:32 <dcoutts> SmallCheck is really great, and complementary to QuickCheck
19:16:51 <sorear> what's your _|_ *Check called?
19:17:01 <dcoutts> it's not really named
19:17:03 <dmwit> ?tell jcreigh I don't think I actually have the hardware I need to run Xinerama. =(  I won't be able to test that part of xmonad, sorry.
19:17:04 <lambdabot> Consider it noted.
19:17:30 <dcoutts> sorear: Olaf Chitil had something he called StrictCheck
19:17:38 <dcoutts> and what I've got is a variation on that
19:17:52 <dcoutts> different approach and implementation, but similar idea
19:18:08 <dcoutts> and only for comparative strictness checking
19:18:16 <jdrake> Saizan: merci for the correction to replicate
19:19:32 <Saizan> np
19:19:40 <nmessenger> > (foldr ((.).(:)) id) [1,2,3] [4,5,6] -- obfuscated (++) ftw!
19:19:42 <lambdabot>  [1,2,3,4,5,6]
19:20:00 <sorear> nmessenger: you call that obfuscated?
19:20:27 <nmessenger> sorear: not especially, but completely impregnable to newbies. :D
19:20:39 <sorear> nmessenger: ignoring your manually fused foldr/map, that's the natural definition of append in terms of a monoid morphism from lists to difference lists
19:20:56 <nmessenger> uh, sure
19:21:08 <sorear> foldr is really cool
19:21:24 * nmessenger whistles nonchalantly "That's exactly what I meant!"
19:21:25 <sorear> it totally captures the notion of morphisms from free monoids
19:23:51 <Saizan> mmh all that function compositions are going to "blow" the heap, isn't it?
19:24:05 <Saizan> *those
19:24:50 <dolio> > (foldr (.) id . map (+) $ [1..100000]) 0
19:24:51 <sorear> you can't blow the heap, it's garbage collected
19:24:52 <lambdabot>  5000050000
19:25:02 <araujo> Hello around here
19:25:17 <sorear> > length $ (foldr ((.).(:)) id) [1..1000000] [1..1000000]
19:25:19 <lambdabot>  2000000
19:25:23 <dolio> Did you mean blow the stack?
19:26:20 <dolio> The heap doesn't have limits unless you specify them, to my knowledge.
19:26:44 <stepcut> I think I have exhausted the heap before...
19:26:55 <Saizan> well, make it bigger than the necessary
19:26:58 <dolio> Hence how I frequently grind my machine to a halt swapping when I accidentally leave a space leak or something.
19:27:33 <mlh> ulimit it
19:28:15 <stepcut> data AsyncException
19:28:15 <stepcut>   = StackOverflow
19:28:15 <stepcut>   | HeapOverflow
19:28:15 <stepcut>   | ThreadKilled
19:28:54 <dolio> Yeah, I know it's possible to set heap limits. I just don't think they're on by default.
19:29:10 <dolio> Unless the default limit is like 90% memory use.
19:29:25 <nmessenger> jdrake: I just noticed; Prelude.!! starts indexing at zero, YourModule.!! at one.
19:29:33 * Saizan remembers a 220mb space leak in his cellular automata evaluator
19:30:00 <stepcut> dolio: yeah, you could be right. I have certainly written programs that sucked up GBs by accidenty
19:30:24 <dolio> Heh, yeah. I do that with alarming frequency. :)
19:30:47 <dolio> I don't notice anything has gone wrong until my X cursor starts lagging several seconds behind.
19:31:01 <dolio> Then I'm in trouble.
19:31:45 <stepcut> I am pretty sure I have gotten an error message that said to run with -H20M though
19:34:29 <stepcut> hrm, perhaps not
19:38:43 <sorear> stepcut: if you set a heap limit, it will print that and abort on out-of-heap
19:39:03 <sorear> stepcut: if you don't set a heap limit, OOM from the OS is a fatal error
19:39:16 <sorear> stepcut: either way HeapOverfow is never thrown
19:39:24 <sorear> (which is considered a bug, fwiw)
19:39:35 <sorear> dolio: I <3 ^C
19:39:37 <stepcut> spiffy
19:39:51 <sorear> dolio: or if I'm more desparate, Alt-SysRq-K
19:40:09 <sorear> I really like the way debian kernels ship with magic sysrq ON.
19:40:37 <sorear> SysRQ-R is also fun.
19:41:19 <sorear> Who here is responsible for haskell-mode?
19:41:43 <dolio> sorear: Yeah, but when it gets to the point that X starts swapping, it's not always easy to get the gui to pass ^C through.
19:42:00 <dolio> So I occasionally have to drop to the console and kill it from there.
19:42:07 <sorear> dolio: I don't use X
19:42:21 <dolio> Heh, well, that wouldn't be a problem, then.
19:44:30 <stepcut> don't use swap -- problem solved ;)
19:44:35 <sorear> @bug
19:44:35 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
19:45:12 <sorear> swap is very nice
19:45:18 <stepcut> indeed
19:45:23 <sorear> when your programs have good mem locality
19:45:41 <sorear> I've written programs with a 2GB working set that ran plenty fast...
19:45:46 <sorear> (ram = 384M)
19:46:10 <dmead> who does the HWN?
19:46:12 <dmead> its dons right?
19:46:13 <stepcut> plus, if you have swap, you can swap out the crap you aren't using, and fill the memory with useful pages instead
19:46:19 <sorear> dmead: nobody
19:46:21 <stepcut> dmead: yes
19:46:32 <stepcut> dmead: but, I think it's also automated to a degree
19:46:34 <dmead> by that logic dons is nobody
19:46:36 <sorear> dmead: theoretically dons, but he fails to act 8 weeks out of ten
19:46:38 <dmead> and thats not very  nice =/
19:46:47 <jcreigh> dmead: pong
19:46:48 <lambdabot> jcreigh: You have 1 new message. '/msg lambdabot @messages' to read it.
19:46:55 <dmead> kk
19:46:57 <jcreigh> dmead: err, sorry, meant that for dmwit
19:47:29 <sorear> I don't think we had an HWN all of Dec/Jan
19:48:15 <dmwit> jcreigh: Yeah, I was assuming it would be possible, since Windows puts things on both screens.
19:48:29 <dmwit> But there's only one entry for my graphics card in lspci, so...
19:48:38 <jcreigh> dmwit: what's your graphics card?
19:48:48 <dmwit> Nvidia GeForce 5200x
19:49:35 <dmwit> err... go5200, not 5200x
19:50:46 <jcreigh> hmm.
19:51:18 <dmwit> I'll take a look again tomorrow -- lspci may give different answers when I'm on my laptop screen and when I'm on my big screen.
19:51:39 <dmwit> But I'm heading to bed for now.
19:52:02 <jcreigh> well, failing that, it would be fairly easy to manually hack in the multihead information.
19:52:33 <dmwit> Hmmm... I'm a bit of a newcomer to all of this, but I'll look around for infos.
19:52:36 <jcreigh> (if your video card presents both screens as one big display, all we need to do is tell xmonad where the displays are)
19:53:01 <jcreigh> that's all Xinerama does anyway: Make one big display, and then give some metadata about where the actual heads are.
19:53:30 <dmwit> I'm going to have to learn the difference between screen, display, and head, aren't I? =P
19:53:32 * dmwit shudders
19:53:37 <jcreigh> heh
19:53:56 <sorear> A display is a computer that runs X
19:54:01 <sorear> A head is a monitor
19:54:09 <sorear> A screen is an arcane X term
19:54:24 <sorear> corresponding to monitor if !Xienerama
19:54:35 <sorear> corresponding to ALL monitors if Xienerama
19:54:54 <dmwit> Okay, but... a single computer can have multiple displays.
19:55:05 <dmwit> (I know just enough to be dangerous. =)
19:55:17 <sorear> dmwit: I simplify. There is no longer such a thing as a multiple user computer.
19:55:18 <jcreigh> confusingly, it's possible to run multihead with different X11 screens without Xinerama, but you can't move windows from one X11 "screen" to another.
19:55:36 * sorear gazes at the wastefulness of western culture
19:55:46 <dmwit> sorear: I am multiple users. ;-)
19:56:06 <sorear> dmwit: you have multiple computers then :(
19:56:26 <dmwit> I guess that's one interpretation...
19:56:38 <stepcut> sorear: KDE has 'fast user switching', which just basically just runs mulitple copies of X -- would that qualify as multiple displays ?
19:56:40 <jcreigh> my local library uses the "Userful" multi-display multi-keyboard solution...they've got 10 or so terminals (LCD monitor, keyboard, mouse) all hooked up to (I presume) a single computer.
19:56:44 <jcreigh> kinda cool
19:56:48 <dmwit> more liek, one CPU and many network connections. =)
19:57:31 <sorear> stepcut: *vomit* yes
19:58:02 <sorear> stepcut: Why can't people just use ptys like God so obviously intended?
19:58:24 * sorear is exaggerating of course
19:58:26 <stepcut> sorear: well, you see, when you get older, you will learn about this thing called pornongraphy
19:59:24 <dmwit> Hmm... twinview looks interesting. /me adds many pages to his "Tomorrow!" list.
20:00:31 <jcreigh> dmwit: anyway, if it turns out that your video card presents both screens as a single display to X11 with some odd resolution (2048x768 or whatever), we can work around it very easily.
20:01:00 <dmwit> jcreigh: Okay, cool.  I'll probably try to find you again tomorrow afternoon.
20:01:16 <dmead> twinview is much easier than xinerama
20:01:19 <dmead> if you have nvidia
20:14:00 * araujo jumps and throws lambdas at everyone
20:18:16 * nmessenger is impaled by the pointy end of a lambda
20:18:48 <nmessenger> someone @pointless me! plz!
20:19:06 <Adamant> @pointless me
20:19:06 <lambdabot> me
20:19:11 <nmessenger> thx
20:20:26 <dmead> @pointless poopey
20:20:27 <lambdabot> poopey
20:20:44 <nmessenger> @pl \y x -> out x y
20:20:45 <lambdabot> flip out
20:21:00 * araujo shoots an ADT and packs nmessenger in an existential type
20:21:31 <nmessenger> oh noes!  I've lost typing information! :(
20:21:57 <dmead> it's the next moral combat
20:21:59 <dmead> i can see it now
20:22:26 * nmessenger passes araujo to a random _|_ function.
20:22:48 <araujo> wowowo
20:22:53 * sorear unsafeCoerce#s himself
20:23:04 <nmessenger> sorear: to what type?
20:23:04 <araujo> hah
20:23:40 * sorear becomes forall a. IO a -> a
20:23:46 <nmessenger> :O
20:23:48 * sorear terrorizes villagers
20:23:57 * sorear burns down cities
20:24:04 <dmead> burination time
20:24:22 * sorear eats Referential Transparandor
20:25:15 <jcreigh> sorear: you really think Prelude should totally disappear? Not even an implicit (.)?
20:26:08 <sorear> jcreigh: yes.  it's very hard to see (.) go, but I don't see a reasonable way of defining it that doesn't come with a free slippery slope
20:26:33 <dmead> the import system really does need to be more pragmatic
20:26:40 <dmead> i agree with sorear
20:26:49 <sorear> {-# IMPORT "Data.Map" #-}
20:26:54 <dmead> we should have to explicitly import some parts of the prelude
20:26:57 <dmead> hah
20:27:04 <dmead> not in that sense
20:27:06 <dmead> i mean
20:27:08 <dmead> like java
20:27:17 <dmead> ready for "industrial" use
20:27:26 <dmead> but not so dumbed down
20:28:28 <jcreigh> it's seems silly that map isn't (Functor f) => (a -> b) -> f a -> f b; what's the point of a rich type system if you don't use it?
20:28:49 <jcreigh> s/^it's/it/
20:29:04 <dmead> mmmm
20:29:12 <dmead> isn't map just for lists?
20:29:17 <jcreigh> dmwit: no!
20:29:24 <jcreigh> dmwit: I mean, yes, the map in prelude is.
20:29:30 <dmead> ah
20:29:35 <dmead> Data.Map is different?
20:30:03 <nmessenger> jcreigh is speaking of Functor's fmap
20:30:04 <jcreigh> dmwit: Data.Map is "Map" (ie, associative array)
20:30:21 <jcreigh> yeah, basically, I don't see why map shouldn't be fmap to begin with
20:30:25 <nmessenger> @type Data.Map.map -- unrelated
20:30:28 <lambdabot> forall a b k. (a -> b) -> Data.Map.Map k a -> Data.Map.Map k b
20:30:43 <nmessenger> wait, no, that's fmap isn't it? :)
20:31:00 <jcreigh> (I know H98 thought polymorphism was confusing; I think arbitrary warts are confusing.)
20:31:07 <sorear> @remember jcreigh it seems silly that map isn't (Functor f) => (a -> b) -> f a -> f b; what's the point of a rich type system if you don't use it?
20:31:08 <lambdabot> Done.
20:31:52 <nmessenger> jcreigh: perhaps there should be a BeginnersPrelude with more monomorphism that newbies start out with?
20:32:44 <sorear> @google Stefan O'Rear video game
20:32:48 <lambdabot> http://www.amazon.com/tag/computer%20reference
20:32:57 <sorear> wtf?
20:33:02 <nmessenger> lambdabot: what?
20:33:19 <dmead> nmessenger: it's called hugs maybe?
20:33:19 <nmessenger> and really, the case of map/fmap is just naming.  Not that bad
20:33:29 <jcreigh> nmessenger: maybe. I don't know what the best solution would be. I think Haskell tutorials/books aimed at newbies could hand-wave. ie, "map has type (a -> b) -> [a] -> [b]", with a footnote to the effect that it's more general than that, but don't worry your pretty little head about that just yet.
20:34:32 <sorear> @google Stefan O'Rear videogame industry
20:34:35 <lambdabot> http://www.nabble.com/Where-prelude-alternatives--classes-and-types-to-get-values--t3245170.html
20:34:35 <lambdabot> Title: Nabble - Where prelude alternatives/ classes and types to get values?
20:34:37 <nmessenger> map f (newbieMeantItToBeAList :: NotAList) -- what?!!  What the hell does "NotAList not an instance of Functor mean?!!?!"
20:35:25 <dmead> ?src map
20:35:26 <lambdabot> map _ []     = []
20:35:26 <lambdabot> map f (x:xs) = f x : map f xs
20:35:32 <dmead> looks like a list to me =/
20:35:42 <jcreigh> nmessenger: it confused me at first. for a while, I thought fmap was somehow different than map. It took me some time to realize that they were the same.
20:36:03 <Saizan> i think newbie should learn polymorphism and typeclasses from the very start.
20:36:10 <jcreigh> dmwit: he means of "map" really was fmap
20:36:14 <jcreigh> s/of/if/
20:36:15 <nmessenger> dmead: my comment was in the context of a polymorphic map
20:36:26 <dmead> ?src fmap
20:36:27 <nmessenger> (polymorphic on arbitrary Functors)
20:36:27 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:36:33 <nmessenger> @src [] fmap
20:36:34 <lambdabot> fmap = map
20:36:39 <jcreigh> > fmap (*2) [1,2,3]
20:36:39 <nmessenger> @src Tree fmap
20:36:40 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:36:40 <lambdabot>  [2,4,6]
20:36:50 <nmessenger> @src Maybe fmap
20:36:51 <lambdabot> fmap _ Nothing       = Nothing
20:36:51 <lambdabot> fmap f (Just a)      = Just (f a)
20:36:57 <nmessenger> etc.
20:37:01 <dmead> hmm
20:37:08 <dmead> i'll discuss more later
20:37:11 <Saizan> @src (a (->)) fmap
20:37:11 <lambdabot> Source not found. Where did you learn to type?
20:37:12 <dmead> gotta go
20:37:15 <dmead> be back in a few hours
20:37:21 <sorear> http://haskell.org/pipermail/libraries/2007-February/index.html
20:37:23 <lambdabot> Title: The Libraries February 2007 Archive by thread
20:37:25 * dmead is away: coffee
20:37:30 <sorear> ops
20:37:37 <sorear> http://haskell.org/pipermail/libraries/2007-February/006909.html
20:37:39 <lambdabot> Title: Where prelude alternatives/ classes and types to get values?
20:37:45 <sorear> read that, esp. second paragraph
20:37:58 <sorear> s/^/nmessenger: /
20:38:10 * dmwit rubs his eyes and looks around sleepily, then turns off his speakers
20:38:24 <sorear> @src (->) fmap
20:38:24 <lambdabot> fmap = (.)
20:38:33 <sorear> @src Data.Tree fmap
20:38:33 <lambdabot> Source not found. It can only be attributed to human error.
20:38:40 <sorear> @src (,) fmap
20:38:40 <lambdabot> fmap f (x,y) = (x, f y)
20:38:47 <sorear> @src Either fmap
20:38:48 <lambdabot> fmap _ (Left x) = Left x
20:38:48 <lambdabot> fmap f (Right y) = Right (f y)
20:39:08 <sorear>  @src is not very friendly, you need a lot of experience to use it well :()
20:40:15 <nmessenger> {- Data.Tree -} fmap (Node x xs) = Node (f x) (map (fmap f) xs) -- I believe
20:40:34 <nmessenger> oops s/fmap/fmap f/ :)
20:42:21 <jcreigh> I feel like it's more confusing (to me) to have fmap vs. map, when they're both really the same thing.
20:42:53 <nmessenger> jcreigh: and fmap vs. (.)?  :)
20:43:54 <Saizan> map = fmap; (.) = fmap, and all is just right!
20:44:00 <nmessenger> vs. liftM vs. liftA?
20:44:15 <jcreigh> nmessenger: I don't fully understand that relationship yet...I can see the outlines of it, and it looks really cool.
20:45:09 <nmessenger> type BlahReader a = Blah -> a; fmap (f :: a -> b) :: BlahReader a -> BlahReader b
20:45:11 <sorear> nmessenger: what do you think of ndm's point?
20:45:47 <jcreigh> but I didn't learn Haskell because I thought it would be easy. If you want VB, you know where to find it. :)
20:45:53 <jcreigh> s/learn/start to learn/
20:46:00 <nmessenger> sorear: it's a good point
20:47:29 <newsham> http://www.coverproject.org/ <- sweet!
20:47:32 <lambdabot> Title: Cover Project
20:50:08 <nmessenger> generalizing, type Reader r a = r -> a; thus Reader and (->) are the same, and thus fmap :: (a -> b) -> (Reader r a) -> Reader r b), or after type aliasing, fmap :: (a->b) -> (r->a) -> (r->b)
20:50:59 <nmessenger> you can see (r->a) as a computation that result's in a's.  fmap (f :: a -> b) changes the 'a' into a 'b' by hooking f onto its end.
20:52:26 <dolio> ?src (->) join
20:52:27 <lambdabot> Source not found. My mind is going. I can feel it.
20:52:37 <dzhefri> I'm reading an older book that uses the function >.>, which doesn't seem to exist in GHC -- did it get replaced with something else?
20:52:49 <stepcut> sorear: regarding Prelude -- I am reminded of this 'famous anecdote'
20:52:52 <hpaste>  stepcut pasted "Famous Anecdote about Make" at http://hpaste.org/1127
20:52:53 <dzhefri> or, doesn't exist in the prelude, i guess i should say
20:52:58 <nmessenger> dolio: join is defined in terms of (>>=), :(
20:53:06 <nmessenger> @src join
20:53:07 <lambdabot> join x =  x >>= id
20:53:13 <nmessenger> @src (->) (>>=)
20:53:13 <lambdabot> f >>= k = \ r -> k (f r) r
20:53:18 <dolio> dzhefri: What does it do in the paper?
20:53:24 <nmessenger> \ r -> id (f r) r
20:53:35 <dzhefri> it's like . , but in the other direction
20:53:35 <nmessenger> = \ r -> f r r
20:53:44 <sorear> dzhefri: >>>?
20:53:46 <dolio> Yeah. join doesn't have to, though, I think.
20:53:56 <sorear> > ((+20) >>> (*2)) 1
20:53:58 <lambdabot>  42
20:54:05 <dzhefri> dolio: so (f >.> g) is the same as (g . f)
20:54:20 <sorear> dzhefri: >>> will do then (Control.Arrow)
20:54:23 <dolio> Ah. Yeah. >>> does the same thing now, as sorear said.
20:54:25 <nmessenger> (>.>) is an awesome opname btw :D
20:54:34 <sorear> >=> is cooler
20:54:50 <sorear> ^-^ has been mentioned before
20:55:03 <sorear> @quote kore
20:55:04 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
20:55:16 <nmessenger> ^o^
20:55:16 <sioraiocht> LOL
20:55:29 <dzhefri> It does?  I just tried ":t (>>>)" and i'm told "not in scope"
20:55:36 <nmessenger> Control.Arrow.>>>
20:55:37 <sorear> dzhefri: Control.Arrow
20:56:15 <sorear> stepcut: so, I've accomplished my goal of attracting attention?
20:56:21 <dolio> @pl \f g -> runKleisli (Kleisli f >>> Kleisli g)
20:56:21 <lambdabot> (runKleisli .) . (. Kleisli) . (>>>) . Kleisli
20:56:32 <sorear> dolio: >=>
20:56:41 <dolio> Yeah, I know.
20:56:52 <dolio> I was just seeing how worse >>> is. :)
20:56:59 <dolio> How much worse, that is.
20:57:07 <jcreigh> heh heh...like the {op}= (as opposed to {op}=) form in C...they realize that i=-1 is ambiguous, so they changed it to i-=1, but were reluctant to disallow the =- form because of the then-thousands of lines of code that depended on it.
20:57:52 <dzhefri> hmm.... now I'm a bit confused
20:58:01 <dzhefri> i'm told (>>>) :: (Arrow a) => a b c -> a c d -> a b d
20:58:10 <sorear> dzhefri: that's correct
20:58:11 <dolio> Yeah, but functions are arrows.
20:58:15 <nmessenger> dzhefri: yep, so a = (->)
20:58:29 <sorear> dzhefri: as is (>>>) :: (a -> b) -> (b -> c) -> (a -> c)
20:58:31 <sorear> ===
20:58:38 <dzhefri> I think what i'm thinking of should be (a -> b) -> (b -> c) -> a -> c
20:58:53 <sorear> (>>>) :: ((->) a b) -> ((->) b c) -> ((->) a c)
20:58:55 <sorear> ===
20:59:15 <sorear> (>>>) :: a b c -> a c d -> a b d (where a = (->))
20:59:18 <stepcut> sorear: I agree with the sentiment that it would suck to get stuck with what we have today, just because there are a few thousand haskell users, when someday there will be millions of users
20:59:26 <sorear> <=
20:59:31 <jcreigh> a few thousand? Is that all?
20:59:39 <sorear> (>>>) :: Arrow a => a b c -> a c d -> a b d
20:59:49 <dzhefri> hmmm.... what's this arrow business?
21:00:09 <dolio> If you use some funky GHC stuff, you can write (I think): (Arrow (~>)) => (a ~> b) -> (b ~> c) -> (a ~> c)
21:00:09 <sorear> yet another obscure abstraction
21:00:22 <stepcut> jcreigh: well, depends on who you count -- there are probably thousands of students alone
21:00:27 <dolio> Which is perhaps somewhat more lucid, since you can replace ~> with -> there.
21:00:32 * sorear changes topic to: #haskell is not #ghc! ...
21:00:34 <nmessenger> dzhefri: an Arrow is just a type that accepts two types, supports some functions, and adheres to laws.  The (->) type fits the definition.
21:01:10 <stepcut> jcreigh: but, perhaps, thousands (10,000 - 100,000) people that would be more severely affected by breaking Prelude
21:01:20 <sorear> IMO we should introduce breaking changes into the language every 3 months
21:01:20 <dzhefri> nmessenger, okay, so what does it mean to support a function?
21:01:26 <jcreigh> "Haskell: thousands of voluntary users" :)
21:01:29 <sorear> whether or not it is needed
21:01:45 <jcreigh> sorear: hmm? why?
21:01:50 <sorear> that way, every 3 months we can fix warts without adding extra breakage!
21:01:54 <sorear> jcreigh: psychology
21:01:55 <jcreigh> lol
21:02:22 <nmessenger> dzhefri: (->) is an instance of the Arrow class, so it implements the class methods.  You know how (+), (-), and the like are Num methods?  Arrow has methods of its own
21:02:25 <nmessenger> @src Arrow
21:02:26 <lambdabot> class Arrow a where
21:02:26 <lambdabot>     arr, pure   :: (b -> c) -> a b c
21:02:26 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
21:02:26 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
21:02:26 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
21:02:28 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
21:02:30 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
21:02:49 <jcreigh> you're right, of course. we were probably stuck with Prelude as soon as Haskell was first viewed as a production platform.
21:03:16 <nmessenger> @src (->) (>>>)
21:03:16 <lambdabot> f >>> g = g . f
21:03:22 <nmessenger> @src (->) arr
21:03:23 <lambdabot> arr f = f
21:04:00 * sorear wonders how many have read his rant
21:04:08 <jcreigh> well, we'd provide Language.Haskell98.Prelude that you could import, of course.
21:04:26 <stepcut> sorear: yeah, I think it would be nice to see a standard-like Haskell' that creates something usuable and stable platform for users, but then have a fork of Haskell that can continue being developed and broken
21:04:46 <dzhefri> nmessenger: thanks
21:04:46 <sorear> stepcut: we already have that
21:05:03 <stepcut> sorear: oh ?
21:05:17 <sorear>    Haskell 98 was conceived as a relatively minor tidy-up of Haskell 1.4, making some simplifications, and removing some
21:05:17 <sorear>    pitfalls for the unwary. It is intended to be a "stable" language in sense the implementors are committed to supporting
21:05:17 <sorear>    Haskell 98 exactly as specified, for the foreseeable future.
21:05:39 <sorear> ie, we can break Haskell as long as we keep +98
21:06:06 <stepcut> right, and Haskell' is a more modern standard that incorporates the useful things add since 98
21:06:07 <jcreigh> but people want stability *and* enhancements. :)
21:06:48 <stepcut> but, I have not seen much real effort in the *breaking* Haskell
21:08:05 <jcreigh> I think the testing branch should be code-named "Crazy Arrows"
21:08:24 <stepcut> It would be nice to do things like rename fmap -> map, do class (Functor m) => Monad m where ..., and maybe do things like split Monad into two classes so you can make Monad instances for Set, etc
21:08:42 <jcreigh> so, in Crazy Arrows, I could map (+2) over a list with (+2) . [1,2,3], right?
21:09:48 <stepcut> And, similarily, it would be nice if you could make instances of Arrow where 'pure' could have the type, pure :: (Read b, Show c) -> (b -> c) -> a b c
21:10:11 <stepcut> (or, whatever class constraints you wanted)
21:11:05 <nmessenger> stepcut: can you do that with GADTs?  /me doesn't know.
21:11:24 <stepcut> nmessenger: I don't think so
21:11:49 <stepcut> nmessenger: http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
21:11:52 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
21:12:14 <stepcut> I believe it is basically the same problem as making a Set Monad
21:13:03 <sorear> Actually, the problem is that constructor classes are EVIL.
21:13:21 <jcreigh> constructor classes?
21:13:38 <nmessenger> jcreigh: classes like Monad with take a (* -> *) type.
21:13:47 <nmessenger> which*
21:14:08 <jcreigh> oh, so basically 90% of classes?
21:14:20 <nmessenger> i.e. [], Maybe, IO, instead of [a], Maybe a, IO a
21:14:57 <jcreigh> how would you avoid that?
21:15:14 <sorear> jcreigh: pasting...
21:15:36 <sorear> (writing and tc'ing first)
21:15:49 <stepcut> sorear: that could be true. There are (at least) two level of change. One level is just fixing all the library level stuff, the other level is fixing the language itself
21:16:06 <sorear> stepcut: what are you responding to?
21:16:25 <sorear> stepcut: please put ML responses on the ML, for continuity of the archive
21:16:26 <stepcut> sorear: "constructor classes are EVIL"
21:16:50 <stepcut> sorear: I will.. I am still trying to figure out what exactly I want to say ;)
21:17:06 <sorear> you received it already?
21:18:37 <allbery_b> I got your H98 message as well already, if that's what ypu'
21:18:38 <allbery_b> re asking
21:18:57 <stepcut> yes: 164918  03/24(Sat)21:13 [ Stefan O'Rear    ] [Haskell-cafe] What ever happened to Haskell 98 as a "stable branch"?
21:19:35 <sorear> And I thought I was the only one who had fetchmail set to every-five-minutes :)
21:19:47 <jcreigh> stepcut: wow, 164918? clean out your haskell-cafe mbox. :)
21:20:04 <stepcut> sorear: I use imap and compulsively hit refresh ;)
21:20:17 <sorear> yikes, what mua is that that everyone knows the format of?
21:20:29 <jcreigh> mutt, I think.
21:20:34 <sorear> 6590   F Mar 24 To haskell-cafe (  27) [Haskell-cafe] What ever happened to Haskell 98 as a "stable branch"?
21:20:45 <sorear> <- mutt
21:20:58 <stepcut> jcreigh: I think that is the total number of emails I am received, I currently only have 24579 messages in my inbox :p
21:21:08 <stepcut> s/I am/I have/
21:21:09 <jcreigh> stepcut: ah, okay, that's fine then. :)
21:21:14 <sorear> Currently, I have 0 messages in my inbox.
21:21:38 <stepcut> <- wanderlust
21:21:38 <sorear> <supercilious> *I* read my email in real time
21:27:30 * araujo throws a sugar lambda at chessguy 
21:27:43 * chessguy eats it
21:27:53 <araujo> :-)
21:28:09 * sorear springs at araujo's quiver
21:28:44 <araujo> haha
21:30:08 * allbery_b has 63 saved messages in his combined inbox
21:30:28 <allbery_b> I strive to keep both inboxes under 100 messages.  at times the work inbox violates that.  *badly*
21:32:08 <chessguy> sorear: how's the new base coming?
21:32:13 <allbery_b> imap terlls me my highest message ID is 492592 :)
21:32:43 <sorear> chessguy: not, I love the old base in a big brothery sort of way
21:33:01 <chessguy> bah
21:33:09 <chessguy> so much for "why prelude must die"
21:33:18 <sorear> I learned a lot
21:33:55 <jdrake> Prelude seems very nice
21:33:58 <sorear> the prelude doesn't need to die - just be (a) moved out of base (b) fixed
21:34:15 <sorear> I have a new pester for the ML
21:34:54 <chessguy> the H98 thing?
21:35:12 <sorear> yeah
21:36:01 * jdrake goes through a whole drawer full of cdr/dvdrs and recalls the joy of giving away 500 5.25" disks for $5 10 years ago.
21:36:05 <chessguy> i have to admit, i didn't really see your point there
21:37:28 <allbery_b> the point is that given a fixed, stable H98 it should be safe to play with e.g. the Prelude without breaking it
21:37:40 <allbery_b> although I'd argue that in fact we should wait until Haskell'
21:37:59 <allbery_b> so as not to break *current* Haskell programs, which will be covered by the fixd H' standard
21:38:25 <sorear> fair enough.
21:41:31 <sorear> stepcut, jcreigh: Looking at it again, my solution is the same as ekidd's.
21:42:04 <sorear> stepcut, jcreigh: I didn't think ekidd's solution was relevant when I first saw it on pho because my solution didn't need TH :)
21:42:28 <stepcut> :p
21:42:34 <stepcut> sorear: is your solution online?
21:42:54 <sorear> stepcut: no, but aside from a few fundeps it's the same as ekidd's
21:43:26 <stepcut> nice
21:47:43 <sorear> @where polyparse
21:47:44 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse
21:52:32 <jcreigh> irssi top of the day: you can do "/hilight yournick" to make irssi highlight/awaylog lines with your nick in it, even if it's not at the begining of the line.
21:52:39 <jcreigh> *tip
22:00:31 <sorear> @tell malcolmw Darcs send is broken for polyparse
22:00:31 <lambdabot> Consider it noted.
22:19:57 <dan__> sorear: do you propose to change the way modules work or just whats included by default in the prelude?
22:22:19 <sorear> Both.  I want a smaller, better prelude and a more usable import syntax.
22:22:30 <sorear> btw, how'd you figure out my nick?
22:22:42 <sorear> a lot of people seem unable to see the S. O'Rear
22:22:45 <dmead> hehe
22:22:59 <dmead> i saw jcreigh or somebody asking you
22:23:09 <dmead> so i assumed you were the guy on the list
22:23:45 <sorear> import qualified Text.ParserCombinators.Parsec as P just makes me *cringe*
22:23:45 <dmead> i do agree  though
22:24:00 <dmead> we should be able to do import Text.*
22:24:02 <dmead> or Data.*
22:24:03 <dmead> like java
22:24:13 <dmead> it's verbose
22:24:24 <dmead> but you probably want some verbosness in picking out what librarys you want
22:24:35 <dmead> *libraries
22:25:04 <ddarius_> dmead: Explicitness (not verbosity) is helpful maintenance and change protection why.
22:25:17 <nornagon> i want import Data.{List,Char}
22:25:46 <dmead> hmm?
22:25:47 <dmead> why what
22:25:49 <dmead> o0
22:26:00 <ddarius> I don't know.  I don't remember typing it or why it is there.
22:26:01 <sorear> I just want import Data.List, Data.Char, qual Data.Map, ...
22:26:14 <dmead> o0
22:26:21 <sorear> where qualification uses a prefix-of-token-suffix rule
22:26:27 <sorear> so M. will match Map
22:26:47 <ddarius> That last part sounds nasty.
22:26:51 <dmead> yea..
22:26:57 <sorear> eh?
22:26:57 <dmead> whats qual?
22:27:12 <dmead> prefix-of-token-suffix rule?
22:27:19 <sorear> dmead: like qualified, but less steriotypically cobolly
22:27:39 * sorear binds C-c C-q to insert "qualified"
22:27:48 <dmead> ah
22:27:49 <dmead> well
22:27:52 <dmead> thats different
22:28:05 <dmead> well
22:28:12 <dmead> i'm not really sure why you'd want/need that
22:28:20 <dmead> but i don't know cobol
22:28:27 <sorear> neither do I
22:28:35 <sorear> hence steriotypically qualifier :)
22:29:07 * glguy wonders if he'd be able to get used to living in a  big city
22:29:15 <dmead> where do you live now?
22:29:23 <glguy> St Louis County
22:29:27 <glguy> Missouri
22:29:29 <ddarius> stereo
22:29:32 <dmead> define big city?
22:29:35 <dmead> like new york?
22:29:38 <dmead> or st louis
22:29:40 <glguy> Portland is big to me
22:29:44 <ddarius> Urban sucks!
22:30:25 <dmead> Oregon?
22:30:28 <glguy> yeah
22:30:36 <dmead> hmm
22:30:41 <dmead> don't know much about it
22:30:46 <dmead> but i'm from philadelphia
22:30:54 <dmead> and i find it easier to learn when not in or near the city
22:31:38 <dmead> anyway
22:31:41 <dmead> sorear
22:31:48 <sorear> dmead
22:31:50 * ddarius just hates cities with a passion.
22:32:00 <ddarius> Riemann
22:32:01 <dmead> your probably right about the prelude being included too hasily
22:32:17 <dmead> hmm
22:32:23 <dmead> i like going to the city
22:32:25 <dmead> but not living there
22:32:30 <sorear> Pseudonym's comment is very interesting.
22:33:15 <dmead> on the mailing list?
22:33:19 <sorear> yea
22:33:41 <dmead> which one is he?
22:33:50 <sorear> Andrew J. Bromage
22:34:09 <sjanssen> search for ajb
22:34:54 <dmead> ah
22:34:55 <dmead> i got it
22:34:56 <dmead> yea
22:35:06 <sjanssen> sorear: you like typing import statements?  Just add an extra "import Prelude ()" and you're good to go :)
22:35:07 <dmead> btw, what is nub short for?
22:35:16 <dmead> and is it supposed to be like newb?
22:35:17 <sjanssen> dmead: nothing
22:35:18 <sorear> it isn';t
22:35:22 <dmead> ?src nub
22:35:23 <lambdabot> nub = nubBy (==)
22:35:23 <sorear> @all-dicts nub
22:35:26 <lambdabot> *** "Nub" gcide "The Collaborative International Dictionary of English v.0.48"
22:35:26 <lambdabot> Nub \Nub\, v. t. [Cf. {Knob}.]
22:35:26 <lambdabot>    To push; to nudge; also, to beckon. [Prov. Eng.]
22:35:26 <lambdabot>    [1913 Webster]
22:35:26 <lambdabot>  
22:35:27 <lambdabot> [44 @more lines]
22:35:32 <sorear> @more
22:35:33 <lambdabot> *** "Nub" gcide "The Collaborative International Dictionary of English v.0.48"
22:35:33 <lambdabot> Nub \Nub\, n.
22:35:34 <lambdabot>    A jag, or snag; a knob; a protuberance; also, the point or
22:35:36 <lambdabot>    gist, as of a story. [Colloq.]
22:35:38 <lambdabot>    [1913 Webster]
22:35:40 <lambdabot> [39 @more lines]
22:35:41 <sjanssen> nub means "gist" or "point"
22:35:47 <dmead> ah
22:36:27 <newsham> ?src nubBy
22:36:27 <lambdabot> nubBy eq []             =  []
22:36:28 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
22:36:52 <sorear> > nubBy(((/=1).).gcd)[2..]
22:36:54 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:37:13 <glguy> (>1) shorter than (/=1) :-)
22:37:26 <sorear> good idea!
22:37:30 <sorear> > nubBy(((>1).).gcd)[2..]
22:37:32 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:37:43 <dmead>   /=
22:37:46 <dmead> is not equal?
22:37:51 <sorear> yes
22:38:01 <newsham> so readable
22:38:07 <dmead> hehe yea
22:38:23 <dmead> i actually tried != a few times
22:38:52 <sorear> strict equality?
22:38:54 <sorear> :p
22:38:57 <dmead> hah
22:39:05 <dmead> like perl's ===
22:39:10 <dmead> my proff said
22:39:11 <dmead> ==
22:39:14 <dmead> is equal
22:39:16 <dmead> ===
22:39:19 <dmead> is REALLY equal
22:39:45 <sorear> === is like lisp's eq? (with == eqv? or equal?)
22:40:13 <dmead> i liked calling it  REALLY equal
22:40:14 <dmead> :P
22:40:19 <sorear> mmh, === isn't listed in my perlop(3)
22:40:55 <allbery_b> that's actually perl6
22:41:17 <allbery_b> perl5 has no ===
22:43:19 <dmead> really?
22:43:27 <dmead> i thought it was perl 5.8 or something
22:43:52 <allbery_b> maybe there's one in 5.10
22:44:30 <sorear> in any event, I'm running the sid perl
22:44:48 <allbery_b> it's not in our 5.8 build, at least
22:45:11 <dmead> then i'm probably thinking of php i guess
23:26:12 <lokam> uud iu sei dat "see you later" uud bi laik lu bazacoi li'u?
23:26:34 <sorear> lokam: potential mischannel detected
23:26:41 <lokam> oops
23:26:44 <lokam> tanks
23:26:51 <ivanm> or else he's channeling the holy spirit and talking in tongues :p
23:27:12 <sorear> swedish and spanish are spoken here fairly often, but always with a specific address
23:27:26 <sorear> shapr et al talking amongst themselves
23:27:51 <lokam> #lojban :)
23:28:11 <lokam> .uanai(confusion)
23:28:18 <sorear> no wonder I couldn't recognize the natural langauge :)
23:28:42 <sorear> (that said, I'm pretty bad at recognizing non-indo-european langs anyway)
23:28:59 <lokam> dai(empathy)
23:29:46 <lokam> it's pretty funny to speak normal languages after you learn it
23:30:18 <lokam> they seem so fragile and flimsy. I mean compare English to Haskell!
23:30:23 <lokam> :)
23:30:52 <lokam> Haskell is far better at describing things accuratly, so others could understand what they meant
23:31:10 <lokam> same with Lojban, but it's speakable by humans
23:31:58 <lokam> by others in the Haskell example while refering to other computers I also refer to other developers :)
23:32:18 <sorear> we can't explain stuff like creativity
23:32:33 <sorear> so in human languages we have to wedge it in as a primop
23:32:49 <sorear> and there's no standard form for those primops in haskell
23:33:00 <sorear> thus rendering haskell useless for most human communication
23:33:15 <nmessenger> @remember sorear we can't explain stuff like creativity so in human languages we have to wedge it in as a primop
23:33:16 <lambdabot> Done.
23:34:08 <lokam> would you not say creativity is randomness?
23:34:43 <sorear> semantically, maybe, in the same sense semantically call-by-name is call-by-value
23:34:49 <sorear> s/value/need/
23:35:09 <sorear> but in practice there's a huge difference in perf characteristics
23:35:15 <siti> is Lojban a good man-made languag?
23:35:50 <sorear> Well, I've only heard of three, and one was never intended for serious use :)
23:36:16 <lokam> siti: I'd have to say it's pretty amazing. :)
23:36:25 <siti> cool
23:36:34 <siti> I might check it out when I have 6 months spare ;)
23:36:49 <lokam> it actually takes two weeks to learn
23:36:54 <siti> wow
23:37:07 <lokam> enough that you can read and understand any text with a dictionary
23:37:14 <siti> longer to speak and listen to it?
23:37:34 <lokam> no, it gets more information across with fewer words
23:37:37 <nmessenger> wikipedia: "Lojban is a predicate-logic based constructed logical language."  Cool.
23:37:39 <siti> ok
23:37:58 <sorear> I'd like to see a conlang based on information theory :)
23:38:01 <siti> I looked at some other man-made languages but they didn't look that good
23:38:06 <nornagon> lambdabot should have a @wiki <foo>, which grabs the first sentence off the wp page for foo.
23:38:14 <nmessenger> @wikipedia Foo
23:38:15 <lambdabot> No Result Found.
23:38:25 <nornagon> heh :)
23:38:29 <nornagon> @wiki Lojban
23:38:30 <lambdabot> http://www.haskell.org/haskellwiki/Lojban
23:38:36 <nornagon> @wikipedia Lojban
23:38:37 <lambdabot> No Result Found.
23:38:40 <nmessenger>  wrong wiki :)
23:38:48 <sorear> @oldwiki Lojban
23:38:49 <lambdabot> http://www.haskell.org/hawiki/Lojban
23:39:09 <nornagon> @oldwiki  sucks
23:39:10 <lambdabot> http://www.haskell.org/hawiki/sucks
23:39:18 <nornagon> clever.
23:39:32 <lokam> .u'i(amusement)
23:40:46 <sorear> I'd like to design a conlang on information theory.  Spoken it will be indistinguishable from white noise; written it will obsolete gzip.  (not like I'll ever have time of course)
23:41:28 <lokam> probably would have to wait for our brains to be uploaded into computers before we could understand it :)
23:42:11 <lokam> so would you make it sound based? or would you like go all out photons?
23:43:06 <sorear> I'd go link layer independent.  Just like IPoE/IPoPPP/IPIP/IPAC/etc.
23:43:40 <sorear> though I expect StefansLang/AC to be subsumed by StefansLang/Pen
23:46:06 <tene> Yeah, lojban is pretty nice, but don't judge it by lokam.  He's kidn of... um... insane at times.
23:47:19 <sorear> I judge him as insane/genius, of the subtype that is best described by saying "is naturally chaotic neutral"
23:48:07 <tene> I'd say that's pretty accurate, but I've seen no evidence of the "genius" part.
23:48:27 <tene> I only know him from the lojban community, though, so it's entirely possible he's done some great stuff I just haven't seen.
23:54:58 <happy_nic> if I had a bunch of a "data" types with lots properties.. let's say I had Horse, Monkey, and Snail. Is there a way to give them all named fields like legs, gender, ears indirectly through something like type classes?
23:55:30 <sorear> not really
23:55:45 <sorear> the usual approach with stuff like this is to have :
23:55:53 <nmessenger> class Legged a where legs :: a -> Legs; class Gendered a where gender :: a -> Gender
23:56:04 <sorear> data Animal = Animal Species Gender NumEars
23:56:18 <sorear> data Species = Horce | Monkey | Snail
23:56:38 <sorear> you can use type classes to access a bunch of fields with the same accesors, BUT
23:56:47 <sorear> it won't help for record updata
23:56:55 <sorear> and it's a lot of boilerplate code
23:57:39 <nmessenger> boilerplate yes, but you could add updators: class Fooed a where foo :: a -> Foo; setFoo :: Foo -> a -> a
23:57:42 <happy_nic> I still have to explicitly define the accessor for each type too, right
23:58:16 <happy_nic> +?
23:58:40 <nmessenger> if you use the classes like that, yes, afaik.
