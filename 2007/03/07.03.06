00:00:32 <narain> dmwit: your last statement is begging for a russian reversal joke
00:02:39 <dmwit> =P
00:03:19 <narain> monad transforms YOU???
00:03:31 <dmwit> In Soviet Russia, state warps YOU!
00:03:36 <bd_> In soviet transformers, *you* warp state monad!
00:03:55 <narain> soviet transformers!
00:04:04 <dmwit> In warp state, monad Russia you!
00:04:38 <dons> http://programming.reddit.com/info/186p8/comments
00:04:39 <lambdabot> Title: Design Patterns in Haskell: bracket (reddit.com)
00:04:46 <narain> Comrade Optimus Prime?
00:07:58 <dmwit> Hey, neat!
00:08:06 <dmwit> bracket++
00:08:41 <narain> any thoughts on tom moertel's comment at the end?
00:09:17 <narain> is the definition of  bracket  given in the article incomplete?
00:09:57 <dmwit> ?hoogle bracket
00:09:58 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
00:09:58 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
00:09:58 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
00:10:16 <dmwit> It seems to be in the standard libs?
00:10:25 <narain> ?src IO.bracket
00:10:26 <Korollary> @src withOpenFile
00:10:26 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:10:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
00:10:33 <dons> withFile
00:10:35 <dons> in ghc 6.6
00:10:36 <dons> -- | @'withFile' name mode act@ opens a file using 'openFile' and passes
00:10:36 <dons> -- the resulting handle to the computation @act@.  The handle will be
00:10:36 <dons> -- closed on exit from 'withFile', whether by normal termination or by
00:10:39 <dons> -- raising an exception.
00:10:41 <dons> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
00:10:44 <dons> withFile name mode = bracket (openFile name mode) hClose
00:11:28 <dons> ah, only in ghc head, i think
00:11:31 <Korollary> so no finally needed?
00:13:34 <Korollary> well, that's a detail anyways. The more important thing is that Pascal actually doesn't make a good case for using a macro instead of a function.
00:14:40 <dons> right. no macros needed.
00:14:50 <dons> just lazy control structures as first class functions
00:15:17 <Korollary> right. It has to be lazy like if-then-else. Other than that there is nothing new that is enabled.
00:15:55 <dons> yep. you need decent exception handling, and higher order functions (+ closures help)
00:18:16 <Korollary> Hmm, a paper on just quasiquotation?
00:18:25 <Korollary> http://citeseer.ist.psu.edu/bawden99quasiquotation.html
00:18:26 <lambdabot> Title: Quasiquotation in Lisp - Bawden (ResearchIndex)
00:18:46 <Korollary> holy cow. 28 pages.
00:18:47 <ski> that's a nice paper
00:19:30 <Korollary> You've seen it before?
00:19:57 <ski> hasn't everybody ;)
00:20:12 <ski> ((lambda (lambda) `(,lambda ',lambda)) '(lambda (lambda) `(,lambda ',lambda)))
00:20:15 <ski> is a nice quine
00:22:06 <Korollary> It indeed is.
00:22:23 <narain> ski: that's the Y combinator, isn't it?
00:22:32 <ski> not quite
00:22:55 <ski> it is adapted from Big_Omega = small_omega small_omega
00:23:08 <ski> small_omega = \t. t t
00:23:33 <narain> right, i thought that was what Y was
00:23:41 <narain> clearly my ignorance of lambda calculus is showing
00:23:42 <ski> the type of the quine is 'a  where a = Code a'
00:24:28 <narain> ok, never mind me
00:25:11 <ski> (\t -> t t) (\t -> t t)  -- Big_Omega in haskell (type error, because cyclic type not allowed)
00:25:44 <narain> right
00:25:44 <ski> \f -> (\t -> t t) (\t -> f (t t))  -- Y combinator
00:26:08 <ski> (hm, iirc that verion of 'Y' was due to Church)
00:26:48 <Korollary> apparently there are many fixpoint combinators.
00:27:08 <ski> (\t -> t t) (\t f -> f ((t t) f))   -- Y combinator due to Turing, iirc
00:27:11 <Korollary> This tidbit brought to you by Gatorade.
00:27:52 <ski> hm
00:27:56 <narain> ski: are they equivalent?
00:28:03 <narain> they must be to be both called Y
00:28:06 <narain> i guess
00:28:07 <ski> yes
00:31:07 <dons> why is there no readM :: Monad m, Read a => String -> m a -- ?
00:31:55 <ski> (let ((let '`(let ((let ',let)) ,let))) `(let ((let ',let)) ,let))   ; another one, which is interesting, since it uses open code (with free variable 'let' here)
00:33:04 <opqdonut> hmm what are ' and `?
00:33:58 <ski> quote - '
00:34:03 <ski> quasiquote - `
00:34:08 <ski> unquote - ,
00:34:25 <opqdonut> quasiquote?
00:35:00 <opqdonut> oh, there was a link earlier
00:35:10 <ski> (the use of 'quote' there is somewhat ugly .. i think it wouldn't be needed with a better quasi-quotation / code-interpolation/splicing system, like in Slate, iirc)
00:36:20 <ski> (let ((x (foo? 42))) (if x #t (bar? 17)))
00:36:24 <opqdonut> ah now i see
00:36:28 <ski> in scheme corresponds to
00:36:40 <ski> let x = isFoo x in if x then True else isBar 17
00:36:42 <ski> in haskell
00:37:20 <ski> the 'quote' can be used to create valure *representing*code* at run-time
00:37:25 <ski> '(let ((x (foo? 42))) (if x #t (bar? 17)))
00:37:28 <opqdonut> yes i know of quoting
00:37:35 <opqdonut> i just hadn't heard of quasiquoting :)
00:37:42 <ski> is a datastructure representing code
00:37:50 <opqdonut> yes, lisp stuff :)
00:38:00 <ski> `(let ((x (foo? ,(* 6 7)))) (if x #t (bar? 17)))
00:38:06 <opqdonut> i should learn scheme i guess
00:38:19 <opqdonut> yes and that is a "templated" datastructure representing code?
00:38:29 <opqdonut> i.e parametrisized code generation?
00:38:30 <ski> constructs a code datastructure, by computing the results of the values in the "," holes
00:38:34 <ski> yes
00:39:36 <ski> i believe TH have something a bit similar
00:39:47 <Korollary> I learned scheme after haskell. I don't use it. Fortunately it's small enough to be learned in short time. Otherwise, what a pain to learn languages that you don't use.
00:41:29 <opqdonut> yes
00:41:53 <ski> (opqdonut : btw, MetaML and MetaOCaml also have quasiquotation (but typed), if you're more interested)
00:41:53 <opqdonut> somehow i do have a respect for the lisp dialects a si have played around with them a bit, written simple parsers etc
00:42:46 <Korollary> Speaking of metaocaml, how popular is it among ocamlers?
00:43:03 <Korollary> realising that this is not #ocaml
00:43:11 * ski dunno .. have myself mostly played with MetaML
00:43:38 <Korollary> What I mean is, I really don't know how many haskellers use arrows, for instance.
01:02:49 <dmwit> ?yow
01:02:50 <lambdabot> Well, here I am in AMERICA..  I LIKE it.  I HATE it.  I LIKE it.  I
01:02:50 <lambdabot> HATE it.  I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I LIKE ...
01:02:50 <lambdabot> EMOTIONS are SWEEPING over me!!
01:03:19 <dmwit> > cycle "I LIKE it.  I HATE it.  "
01:03:21 <lambdabot>  "I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I L...
01:10:15 <nornagon> > map (\verb -> "I " ++ (map toUpper verb) ++ " it.  ") (unzip.cycle $ ("like","hate"))
01:10:16 <lambdabot>  Couldn't match expected type `[(a, b)]'
01:10:18 <nornagon> hmph
01:10:22 <quicksilver> dons: because using 'Monad' as if it meant 'Failure encapsulator' is icky? :P
01:10:42 <nornagon> hmphoh well
01:11:05 <quicksilver> map (\verb -> "I " ++ (map toUpper verb) ++ " it.  ") (unzip.cycle $ ["like","hate"])
01:11:08 <quicksilver> > map (\verb -> "I " ++ (map toUpper verb) ++ " it.  ") (unzip.cycle $ ["like","hate"])
01:11:10 <lambdabot>  Couldn't match expected type `(a, b)'
01:11:27 <quicksilver> > map (\verb -> "I " ++ (map toUpper verb) ++ " it.  ") (cycle $ ["like","hate"])
01:11:29 <lambdabot>  ["I LIKE it.  ","I HATE it.  ","I LIKE it.  ","I HATE it.  ","I LIKE it.  ",...
01:20:25 <dmwit> > map (\verb -> "I " ++ (map toUpper verb) ++ " it.  ") (cycle ["like","hate"]) -- What's that dollar sign doing?
01:20:27 <lambdabot>  ["I LIKE it.  ","I HATE it.  ","I LIKE it.  ","I HATE it.  ","I LIKE it.  ",...
01:21:24 <ski> dmwit : unneeded, in that case
01:21:48 <quicksilver> nothing at all, I was editing the earlier broken version :)
01:21:55 <dmwit> > unwords ["hi ", "world"] == unwords ["hi", "world"]
01:21:56 <lambdabot>  False
01:22:52 <dmwit> > unwords $ map (\verb -> "I " ++ (map toUpper verb) ++ " it. ") (cycle ["like", "hate"])
01:22:55 <lambdabot>  "I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I L...
01:24:53 <quicksilver> or simply change the map to a concatMap
01:25:15 <dmwit> Yep, lots of ways to do it.
01:26:01 <dmwit> > cycle ["LIKE", "HATE"] >>= (\verb -> "I " ++ verb ++ " it.  ")
01:26:02 <lambdabot>  "I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I L...
01:28:29 <ski> > do verb <- cycle ["LIKE","HATE"]; "I " ++ verb ++ " it.  "
01:28:30 <lambdabot>  "I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I L...
01:29:09 <Thunder> > unwords . ("I"++) . intersect ["it. I"] . map toUpper . cycle $ ["like", "hate"]
01:29:10 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
01:29:30 <resiak> > cycle ["LIKE", "HATE"] >>= ("I "++) . (++" it.  ") -- ?
01:29:32 <lambdabot>  "I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I L...
01:29:45 <Thunder> > unwords . ("I":) . intersect ["it. I"] . map toUpper . cycle $ ["like", "hate"]
01:29:46 <ski> > liftM (\verb -> "I " ++ verb ++ " it.  ") (cycle ["LIKE","HATE"])
01:29:46 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
01:29:47 <lambdabot>  ["I LIKE it.  ","I HATE it.  ","I LIKE it.  ","I HATE it.  ","I LIKE it.  ",...
01:29:48 <dmwit>  > unwords . ("I"++) . intersect ["it. I"] . map toUpper $ cycle ["like", "hate"]
01:30:47 <dmwit> > unwords . ("I"++) . intersect ["it. I"] . map toUpper $ cycle ["like", "hate"]
01:30:48 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
01:32:12 <earthy> > unwords . ("I"++) . intersect ["it. I"] . map toUpper $ cycle
01:32:13 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
01:32:36 <earthy> > unwords . (["I"]++) . intersect ["it. I"] . map toUpper $ cycle ["like","hate"]
01:32:37 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
01:32:45 <earthy> hm?
01:32:48 <earthy> right.
01:32:59 * earthy tries waking up
01:33:02 <dmwit> > unwords . ("I "++) . intersperse ["it.  I"] . map (map toUpper) $ cycle ["like", "hate"]
01:33:03 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
01:33:54 <dmwit> > unwords . ("I ":) . intersperse ["it.  I"] . map (map toUpper) $ cycle ["like", "hate"]
01:33:55 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
01:33:56 <earthy> > unwords . (["I"]++) . intersect ["it. I"] . map (map toUpper) $ cycle ["like","hate"]
01:34:00 <lambdabot> Terminated
01:34:13 <Thunder> > unwords . ("I":) . intersect ["it. I"] . map (map toUpper) . cycle $ ["like", "hate"]
01:34:13 <earthy> heh.
01:34:15 <dmwit> > unwords . ("I " ++) . intersperse ["it.  I"] . map (map toUpper) $ cycle ["like", "hate"]
01:34:15 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
01:34:17 <lambdabot> Terminated
01:34:32 <dmwit> > unwords . take 30 . ("I " ++) . intersperse ["it.  I"] . map (map toUpper) $ cycle ["like", "hate"]
01:34:33 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
01:34:34 <Thunder> Exaclty: Terminited, but why?
01:35:00 <earthy> > unwords . take 50 . (["I"]++) . intersect ["it. I"] . map (map toUpper) $ cycle ["like","hate"]
01:35:04 <lambdabot> Terminated
01:35:08 <earthy> interesting. :)
01:35:12 <Thunder> Does intersected has problems with infinite lists?
01:35:29 <Thunder> earthy: [x] ++ == x :
01:35:32 <dmwit> I don't understand why you're all using intersect.
01:35:36 <earthy> yeah. it should be intersperse. ;)
01:35:51 * earthy was using intersect because I copy-pasted. ;)
01:35:52 <Thunder> dmwit: Because it does not terminate.
01:35:55 <dmwit> > unwords . take 30 . ("I " ++) . intersperse "it.  I" . map (map toUpper) $ cycle ["like", "hate"]
01:35:56 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
01:36:11 <earthy> > unwords . take 50 . (["I"]++) . intersperse "it. I" . map (map toUpper) $ cycle ["like","hate"]
01:36:13 <lambdabot>  "I LIKE it. I HATE it. I LIKE it. I HATE it. I LIKE it. I HATE it. I LIKE it...
01:36:16 <dmwit> Thunder: ok.
01:36:46 <earthy> there, that cup of tea helped. ;)
01:37:12 <Thunder> earthy: Moving the take 50 in front og unwords will cause bottom.
01:37:34 <dmwit> ???
01:38:14 <dmwit> > take 50 . unwords . (["I"]++) . intersperse "it. I" . map (map toUpper) $ cycle ["like","hate"]
01:38:15 <lambdabot>  "I LIKE it. I HATE it. I LIKE it. I HATE it. I LIKE"
01:38:16 <quicksilver> no it won't, it will just cause it to take the first 50 letters
01:38:21 <quicksilver> instead of 50 words
01:38:27 <dmwit> yah
01:38:47 <Thunder> Strange. My ghci on 6.6 (amd64) will not terminate.
01:39:29 <dmwit> let let = let in let
01:39:33 <dmwit> > let let = let in let
01:39:33 <lambdabot>  Parse error
01:39:44 <dmwit> > let tel = tel in let
01:39:45 <lambdabot>  Parse error
01:39:55 * dmwit slaps head
01:40:01 <dmwit> > let barf = barf in barf
01:40:03 <lambdabot>  Exception: <<loop>>
01:40:52 <Thunder> Very strange. Restarting ghci helps-.
01:41:10 <dmwit> Maybe you had something bound in a strange way?
01:41:33 <Thunder> Just _
01:42:38 <dmwit> > filter (<3) [1..]
01:42:42 <lambdabot> Terminated
01:47:26 <ski> (dmwit : for some reason, one can't shadow keywords with variables in haskell)
01:47:45 <dmwit> That's fine, I like it better that way.
01:47:52 <ski> (though maybe it works in liskell ..)
01:48:16 <dmwit> No need to make obfuscation so easy as that... =)
02:05:00 <araujo> include-dirs , is the cabal option to include C headers file right?
02:06:44 <CosmicRay> that sounds right
02:11:07 <quicksilver> how does lambdabot control the CPU behaviour of its commands? does it run them as heavyweight processes?
02:18:07 <wkh> quicksilver: i've kind of wondered that myself.
02:18:24 <wkh> quicksilver: the source for lambdabot is available if you're feeling brave enough to study it
02:20:49 <quicksilver> wkh: *nod* I know. I was being lazy and hoping someone would simply answer me :)
02:22:12 <Cale> It runs a program called runplugs
02:22:20 <Baughn> quicksilver: There are no references to forkOS in the source, at least
02:23:08 <Cale> It's in scripts/RunPlugs.hs, iirc.
02:24:25 <Cale> RunPlugs is written using hs-plugins.
02:24:32 <Baughn> It gets run as an actual external program?
02:25:12 <Cale> Well, runplugs is written using hs-plugins, it puts the rest of the code around the expression, compiles that and executes it.
02:25:24 <dons> and typechecks it
02:25:33 <Cale> It appears the first thing runplugs does is setResourceLimit ResourceCPUTime (ResourceLimits rlimit rlimit)
02:25:34 <dons> its a type-based sandbox
02:25:40 <Cale> rlimit = ResourceLimit 3
02:25:45 <dons> yeah, no types for cpu resources :-)
02:25:51 <dons> someone want to write a thesis ?
02:25:57 <earthy> on what? :)
02:26:04 <dons> heh
02:26:15 <earthy> and for whom? :P
02:26:18 <Cale> Types for time complexity.
02:26:28 <dons> well, space would be ok too.
02:26:31 <dons> and there's work on that
02:26:39 <dons> you might need Isabelle
02:26:50 <earthy> isn't that somewhat unsolvable? :)
02:28:29 <ski> well, possibly one can approximate in some useful way
02:28:57 <dons> i suppose we could always run the code and see. oh wait, that's what we do
02:29:04 <opqdonut> :)
02:29:23 <ski> length :: (xs :: [a]) -> Int is O(length xs)
02:29:24 <dons> ruling out IO is the big win though. since then we don't have to worry about proper sandboxing
02:29:35 <opqdonut> massive compile-time benchmarks of everything
02:29:43 <ArthurClemens> Does anyone have experience with installing missingh on Mac OS X? The installer does not take me through all configure steps...
02:30:02 <opqdonut> :)
02:30:24 <earthy> arthurclemens: I had no problems whatsoever, last time I checked
02:30:42 <earthy> simply unpacked the tarball and installed
02:30:50 <ArthurClemens> perhaps its just this version (0.18)
02:31:11 <ArthurClemens> the error I get is "setup: cannot satisfy dependency FilePath-any"
02:32:47 <tarantoga> do you have the FilePath library?
02:33:04 <tarantoga> http://software.complete.org/missingh/wiki/RelatedSoftware
02:33:06 <lambdabot> Title: RelatedSoftware - MissingH
02:33:28 <ArthurClemens> I supposed that was in Prelude
02:33:59 <ArthurClemens> ah I see, thanks for the pointer
02:34:24 <ArthurClemens> I hoped macports could do this for me, but no luck
02:36:39 <quicksilver> ah, nice
02:36:52 <earthy> hackage!
02:37:00 <quicksilver> thanks all
02:37:09 <dons> ndm, is FilePath on hackage yet? and if not, why not?
02:37:47 <Cale> http://en.wikipedia.org/wiki/Global_National -- It seems you don't even have to listen to the news to get your cognitive dissonance anymore. They put some right in the name of the news program.
02:41:03 <dons> my head hurts
02:41:10 <ulfdoz> I have a grammar, specifying comments and whitespaces to be token delimiters, i.e. they can occur hardly everywhere. When parsing and building the parse-tree, how can I deal with those delimiters, to have the possibility, to reserialize the tree without loosing the delimiters?
02:41:44 <ulfdoz> It does not seem to be nice, to put them directly into the tree.
02:42:54 <ski> @. read run (\l -> l ++ " " ++ show l) "(\\l -> l ++ \" \" ++ show l)"
02:42:55 <lambdabot>  (\l -> l ++ " " ++ show l) "(\\l -> l ++ \" \" ++ show l)"
02:43:01 <ski> @. read run let l = "\"let l = \" ++ show l ++ \" in \" ++ l" in "let l = " ++ show l ++ " in " ++ l
02:43:03 <lambdabot> Plugin `compose' failed with: IRCRaised Prelude.read: no parse
02:43:45 <ski> (hm, something is strange .. that last parses in '/msg')
02:44:45 <wkh> @pl reverse $ head l
02:44:45 <lambdabot> reverse (head l)
02:45:14 <wkh> @describe pl
02:45:14 <lambdabot> Unknown command, try @list
02:45:17 <wkh> @list
02:45:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
02:45:23 <wkh> @help pl
02:45:24 <lambdabot> pointless <expr>. Play with pointfree code.
02:45:35 <wkh> @pl reverse $ head
02:45:35 <lambdabot> reverse head
02:45:52 <Thunder> @pl \l -> reverse $ head l
02:45:52 <lambdabot> reverse . head
02:46:00 <wkh> ah.
02:46:11 <wkh> gosh that's cool
02:46:20 <wkh> i mean, being able to write a program that does that
02:46:29 <ski> @pl foo l = reverse (head l)
02:46:30 <lambdabot> foo = reverse . head
02:47:11 <Thunder> @pl \s -> "I " ++ map toUpper s ++ " that."
02:47:12 <lambdabot> ("I " ++) . (++ " that.") . map toUpper
02:47:45 <quicksilver> @pl \a b c -> (b,c,a)
02:47:45 <ClaudiusMaximus> > 2.5 / 3
02:47:45 <lambdabot> flip (flip . (,,))
02:47:47 <lambdabot>  0.8333333333333334
02:47:59 <ClaudiusMaximus> > 2.5 / 3 * 60
02:48:01 <lambdabot>  50.0
02:48:41 <wkh> @pl count w file = (>>=print) . liftM(length . filter(==w) . lines) . readFile file
02:48:42 <lambdabot> count = (((print =<<) .) .) . (. readFile) . (.) . fmap . (length .) . (. lines) . filter . (==)
03:02:05 <wkh> @src liftM
03:02:06 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:02:15 <Japsu> > let { fac 0 = 1; fac n = n * fac(n-1) } in sum (map fac [1..100]) `mod` 12
03:02:16 <lambdabot>  9
03:02:17 <wkh> :t liftM
03:02:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
03:02:20 <Japsu> \o/
03:02:49 <wkh> japsu: is that an euler project thing?
03:03:30 <Japsu> wkh: nah, just following a lecture in number theory
03:03:34 <wkh> oh
03:04:06 <wkh> for being an academic language, haskell can be pretty handy :P
03:04:30 <Japsu> yeah
03:05:03 <dancor> can i put unicode in haskell string literals
03:05:23 <Japsu> dancor: in ghc 6.6 and greater
03:05:39 <dancor> i'm on 6.6 but getting different things using putStrLn vs like bash's echo
03:05:44 <Japsu> :o
03:06:07 <Japsu> well I'm on 6.4 so I probably won't be of much help here :)
03:06:21 <dancor> unicode bullet shows as "
03:07:14 <dancor> hm this could be vim
03:07:28 <dancor> nevermind me while i check that possibility
03:09:35 <wkh> @src liftM2
03:09:36 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:13:37 <dancor> does yi have :map yet
03:14:14 <Japsu> @src liftM
03:14:15 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:14:17 <Japsu> hmm
03:14:23 <Japsu> source code is the best documentation
03:14:54 <wkh> for one-liners, it's helpful to see what it actually does
03:15:26 <dons> dancor: i thin its had :map from the beginning?
03:16:11 <swiert> dons: any chances of seeing your irc tutorial in the next TMR?
03:16:19 <wkh> what exactly is yi? it's a text editor?
03:16:34 <swiert> I'm kind of short on potential submissions...
03:17:41 <wkh> seeing someone on IRC whose name you've been seeing constnatly in papers recently is kind of jarring
03:17:45 <wkh> ::we're not worthy::
03:19:02 <wkh> oh wiat. are you a different swiersta from s. doaitse swiersta of swiersta and duponcheel?
03:19:26 <wkh> swierstra
03:19:26 <quicksilver> that's wouter swiersta here in the channel
03:19:33 <dons> swiert: yes, I think that's reasonable.
03:19:34 <swiert> Yes.
03:19:37 <quicksilver> funnily enoughu I was about to ask if the two were related :)
03:19:43 <quicksilver> if that's not an impertinent question
03:20:04 <swiert> We are related. Doaitse is my uncle.
03:20:12 <swiert> I get that question a lot.
03:20:23 * quicksilver nods
03:20:28 <swiert> dons: great!
03:20:35 <quicksilver> well it's an uncommon name, and he's pretty famous in the field :)
03:21:05 <earthy> heh. I'd better not go into logic in computer science then
03:21:26 <dons> i'm writing a little blog article now on a similar theme, swiert. so I think its doable.
03:24:00 <therp> anyone familiar with HaskellDB here? I seem to be unable to write an update statement that matches against some keys in its where clause
03:25:40 <swiert> therp: bringert might be able to help you.
03:28:57 <hpaste>  therp pasted "Haskell DB update troubles" at http://hpaste.org/815
03:29:34 <therp> my mind fails to make sense of the type class system of Haskell DB
03:29:50 <audreyt> dons: what is your preferred way of introducing a new typeable-type in runtime for GHC 6.6?
03:30:14 <dons> haven't tried it of late :-)
03:30:17 <audreyt> I need a way to generate, at runtime, an indefinite supply of newtypes to the same underlying type
03:30:23 <audreyt> ah ok :)
03:30:35 <dons> sounds Data.Generics'ish
03:31:02 <audreyt> mm?
03:32:05 <dons> I can't imagine what evil code you're writing that needs this .. :-)
03:35:21 <dancor> why would installing vty say this if configure and build went fine: Setup.lhs: Error: Could not find module: Graphics.Vty with any suffix: ["hi"]
03:35:36 <Japsu> @src div
03:35:36 <lambdabot> Source not found. That's something I cannot allow to happen.
03:35:46 <quicksilver> audreyt: all instincts point to "that can't be a healthy way to do it" but heck, I'm sure you know what you're doing.
03:35:46 <Japsu> @type div
03:35:49 <lambdabot> forall a. (Integral a) => a -> a -> a
03:35:57 <quicksilver> Japsu: not all the primitives have source
03:36:34 <audreyt> quicksilver: I know what I'm doing, yes :) I'm writing JIT compiler from Perl6 to GHC
03:36:46 <Japsu> quicksilver: :<
03:36:54 <quicksilver> Is there a particularly good reason why constructors as type-class methods are allowed for one special case (1,2,3...) but not in general
03:37:25 <quicksilver> audreyt: I know that :) That doesn't prove to me that an infinite supply of runtime newtypes is necessarily the right way to model that problem...
03:38:37 <dons> audreyt: so you really need a unique supply of newtype values in your AST?
03:38:40 <audreyt> quicksilver: ok... the problem is that I'd like to compile perl6 classes into concrete types
03:38:57 <audreyt> but of course p6 allows runtime definition of classes
03:39:09 <audreyt> what I really like is whenever someone said
03:39:14 <dons> oh, so they create a new Dynamic or something?
03:39:20 <dancor> ah looks like i needed --tag=rel-3.0.0 on darcs get line
03:39:30 <dancor> i don't even know what that does :)
03:39:31 <audreyt> well, existentially constructed typeable
03:39:37 <audreyt> but it's the same as Dynamic
03:40:34 * quicksilver nods
03:40:44 <audreyt> what I really like is whenever someone said class Foo { has Int $.bar, has Int $.baz }, go ahead and construct a "data Foo { _Foo_bar :: TVar Int, _Foo_baz :: TVar Int }" and instantiate it to the class Invokable
03:41:04 <audreyt> which will then point to the vtable of its method (etc, standard OO stuff)
03:41:06 <quicksilver> intuitively that feels like something you could do with an hs-plugins type technique
03:41:25 <quicksilver> you could stuff it into a module which only exposes the Invokable bit
03:41:42 <quicksilver> and compile that module
03:41:42 <audreyt> sure, but that is still a new type
03:41:53 <audreyt> sure.
03:42:14 * audreyt wonders if libGHC can do the same thing, and if yes, if there's already recipes
03:42:43 <quicksilver> yes, I'm hazy on how hs-plugins works
03:42:46 <quicksilver> dons: ?
03:43:02 <quicksilver> I'm pretty sure you can use it to compile a fragment which is a module (hiding a fresh type)
03:43:08 <quicksilver> and exports only the Invokable
03:43:37 <audreyt> perhaps, though Invokable is subclass to Typeable, so it needs to genuinely get a new TyCon
03:43:44 <audreyt> I can write the Typeable instance myself
03:44:11 <dancor> having gentoo's dev-haskell/gtk2hs-0.9.10-r1 should satisfy gtk-any for the yi configure, no?
03:48:19 <hpaste>  Japsu pasted "Extended Euclidean algorithm for solving a linear congruence equation" at http://hpaste.org/816
03:49:32 <dcoutts_> dancor, hmm, probably not. Try the latest version. It's in the overlay.
03:57:02 <notsmack> @where vty
03:57:03 <lambdabot> http://members.cox.net/stefanor/vty/
03:57:31 <dancor> dcoutts_: sweet, i just emerged layman, life is getting better all the time
04:02:23 <notsmack> $ runhaskell Setup.hs build
04:02:23 <notsmack> *** Exception: failed to extract ghc path from command line
04:02:36 <notsmack> (yi)
04:04:57 <kuribas> This article talks about the State Monad: http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
04:04:59 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
04:05:09 <dancor> notsmack: i got that at one point for some reason..
04:05:14 <kuribas> But I don't seem to have Control.Monad.State ?
04:05:40 <dancor> notsmack: run configure first?
04:06:19 <kuribas> Should it be part of ghc?
04:06:51 <Igloo> No, you need the mtl library
04:06:55 <notsmack> dancor: yep
04:07:06 <dancor> that's what i needed to do
04:13:21 <notsmack> nope, just tried a fresh copy of yi, configure then build gives me that error
04:14:54 <dons> http://programming.reddit.com/info/187np/comments :-)
04:14:56 <lambdabot> Title: Practical Haskell: shell scripting with error handling and privilege separation  ...
04:16:21 <notsmack> dons: "The frequency of the clock life is greatly extended,"
04:16:39 <dons> urgh
04:17:30 <dons> yeah, tired
04:17:32 <dons> fixed.
04:18:03 <kuribas> Why isn't there a Contol.Monad.State?
04:18:18 <dons> there is.
04:18:19 <vegai> "A Haskell Translation" or "An Haskell Translation"?
04:18:45 <dons> vegai, well, maybe if you're french. 'A Haskell ..' is acceptabe modern usage
04:19:17 <vegai> on aime l'Haskell, n'est-ce pas?
04:19:24 <dons> I'd use 'An' only if I pronounced Haskell as: l'askell
04:19:31 <kuribas> dons: I installed ghc from source (6.6) but it doesn't seem to have Control.Monad.State
04:19:44 <dons> kuribas: right, you get that from the 'mtl' package on hackage
04:19:46 <dons> ?where hackage
04:19:47 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
04:19:52 <dons> look for 'mtl'
04:19:54 <dons> ?hackage mtl
04:19:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
04:19:58 <dons> even better :-)
04:20:19 <dons> vegai, oh I see. oops. my fault.
04:20:46 <dons> I had 'An implementation in Haskell' before slipped though
04:20:57 <kuribas> dons: I see. Thanks.
04:20:58 <vegai> sorry to nitpick
04:21:05 <dons> now, thanks.
04:21:17 <dons> if 10k people read it today, its a good idea to fix it in the first few mins :-)
04:21:36 <dons> though 10k might be a stretch :-)
04:22:21 <notsmack> dons: nice article
04:24:58 <vincenz> you learn something new every day
04:25:56 <dons> oh?
04:29:55 <vincenz> vim :)
04:30:07 <vincenz> http://notvincenz.blogspot.com/2007/03/vim-sessions.html
04:30:09 <lambdabot> Title: lambda.oasis: Vim Sessions
04:30:12 <vincenz> ak
04:31:26 <vincenz> there we go
04:33:21 <mauke> vincenz: :set ssop-=options ssop+=resize
04:34:03 <vincenz> thx
04:41:19 <vincenz> damn
04:41:22 <vincenz> modelling types ain't easy
04:41:38 * vincenz is tempted to model TCs
04:42:23 <vincenz> Anyone know how record types are represented in GHC?
04:44:25 <quicksilver> vincenz: they're just tuples with sugar, AFAIK
04:44:36 <vincenz> quicksilver: well you have to model the fieldnmaes
04:44:45 <vincenz> s/fieldnmaes/fieldnames
04:44:54 <quicksilver> the fieldnames are erased, I believe
04:44:59 <vincenz> maybe not for getters, as they're just funcs, but definitely for setters
04:45:02 <therp> vincenz: represented internally?
04:45:03 <quicksilver> all that remains is the accessor functions
04:45:04 <SamB> yay sugar!
04:45:06 <vincenz> therp: yes
04:45:11 <vincenz> quicksilver: even for setters?
04:45:11 <quicksilver> vincenz: there aren't setters
04:45:13 <vincenz> Foo { bar = ...}
04:45:14 <SamB> but, they are not tuples with sugar
04:45:23 <SamB> they are plain-old constructors with sugar
04:45:35 <vincenz> well I can understand desugaring a plain getter
04:45:39 <vincenz> but tell me how you desugar
04:45:48 <vincenz> x{ bar = lala}
04:45:59 <SamB> well. it gets messy-looking
04:46:09 <SamB> you need a case in there somewhere
04:46:10 <quicksilver> let y = Foo a b c lala d e f where Foo a b c _ d e f = x
04:46:16 <vincenz> hm
04:46:23 <vincenz> damn
04:46:25 <quicksilver> no you don't :) just a pattern match
04:46:28 <vincenz> well I can't desugar fieldnames
04:46:34 <quicksilver> although arguably that's the same thing
04:46:36 <vincenz> in my model
04:46:41 <SamB> quicksilver: yes!
04:47:17 <vincenz> crud
04:47:19 <quicksilver> this is what people are getting at, I believe, when they accuse haskell records of not being real records
04:47:29 <quicksilver> although it's never caused me a problem personally
04:47:32 <therp> vincenz:  data X = A { a :: Int } | B { a :: Int } .. then foo { a = 2 } is desugared into (case foo of { (A _) -> A 2; (B _) -> B 2; }
04:47:41 <vincenz> therp: alright, thx
04:47:47 <vincenz> :/
04:48:06 <therp> ":/" ? didn't that help?
04:48:06 <vincenz> At least know that the haskell model won't do then
04:48:18 <quicksilver> although, admittedly, I don't like having "things which aren't first class constructs" in the language
04:49:19 * vincenz thinks about it a bit more
04:58:28 <kzm> Parsec used to have a handy 'run' for testing parsers.  Where did it go?
05:00:07 <notsmack> runParser?
05:00:15 <SamB> testParser?
05:00:18 <notsmack> er, parseTest
05:00:30 <SamB> something like that
05:04:25 <Cale> :index parseTest
05:04:30 <Cale> @index parseTest
05:04:31 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
05:07:53 <dons> why reddit is nice: "Maybe for my next job I'll switch to Python or Ruby -- or maybe I'll try to jump all the way to Haskell."
05:08:36 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/817
05:09:19 <kpreid> hpaste: perhaps pastes like that one should be rejected?
05:09:47 <dons> yeah, that's reasonable
05:09:58 <dons> glguy: lightweight checking over pastes for content?
05:10:32 <kpreid> so I looked at that page, and I saw hpaste's wacky function signature header...
05:10:44 <kpreid> idea for impractical programming:
05:11:12 <kpreid> all programs shall be [a] -> [a]. effects are encoded in the rearrangement of the list structure.
05:11:31 <dons> heh
05:11:33 <kzm> thanks!
05:12:06 <kpreid> hm, the only input that model allows is the length of the list
05:12:22 <SamB> what? not (a -> a) -> (a -> a)?
05:13:14 <Saizan> is there a tool to build a dependency graph from a hierarchy of modules?
05:13:14 <kpreid> that allows *no* input, unless the real program is really encoded in the output, model-of-IO-monad style
05:13:34 <SamB> oh. right.
05:13:39 <CosmicRay> dons: url?
05:13:48 <SamB> hrmm...
05:13:55 <SamB> no, no it doesn't!
05:14:02 <SamB> oh yes.
05:14:06 * SamB sees
05:14:32 <SamB> (forall a. a -> a) -> (b -> b) -> (b -> b) ?
05:14:49 <SamB> no. not quite...
05:15:12 <SamB> (forall a. (a -> a) -> (a -> a)) -> (b -> b) -> (b -> b) ?
05:15:29 <kpreid> nice
05:16:17 <dons> oh, this looks useful, http://metavar.blogspot.com/2007/03/simple-socket-programming.html
05:16:19 <lambdabot> Title: metasyntactic variable: Simple Socket Programming, http://tinyurl.com/2398sm
05:18:27 <dons> nice, and another, http://stephan.walter.name/blog/computers/programming/haskell/interacttcp.html
05:18:30 <lambdabot> Title: stephan.walter.name/blog, http://tinyurl.com/2jhdps
05:20:07 <dons> so there's quite a few nice new articles on reddit now, mod up!! ;)  http://programming.reddit.com/new
05:20:11 <lambdabot> Title: reddit.com: programming - newest submissions
05:20:23 <dons> our documentation drought is turning into a blog flood
05:20:39 <ozone> dons: you're such a reddit slave :)
05:20:50 <notsmack> who's 'linuxer' on reddit?
05:20:53 <dons> ozone, hey, i have scripts ;-)
05:21:03 <ozone> dons: written in haskell?
05:21:05 <dons> ozone, but since i'm preparing the weekly news anyway...
05:21:09 <dons> of course.
05:21:12 <ozone> dons++
05:21:23 <dons> ?users
05:21:24 <lambdabot> Maximum users seen in #haskell: 339, currently: 312 (92.0%), active: 44 (14.1%)
05:21:27 <ozone> @karma+ dons
05:21:27 <lambdabot> dons's karma raised to 128.
05:21:31 <ozone> 128!
05:21:38 <ozone> karma whore
05:21:52 <Saizan> are GLUT haskell bindings supposed to work on windows?
05:21:58 <dons> well at least I'm no iron yuppy
05:22:13 <dons> Saizan: hmm, I think so. but best check with someone with windows
05:22:23 <ozone> dons: quiet, before i run you over in my prius while listening to emo podcasts on my ipod!
05:22:34 <dons> hah
05:23:26 <nominolo> ?karma ozone
05:23:26 <lambdabot> ozone has a karma of 0
05:23:57 <ozone> i liked it on vim.sf.net when vimacs had a negative karma
05:24:00 <Saizan> dons: uhm ok, the problem is i can't find a glut32.dll that works with them
05:24:08 <dons> ozone++ well, hoc is good
05:24:18 <dons> hah. that's cool ozone
05:24:34 <dons> there *is* something upsetting to the cosmic balanace about vimacs
05:25:08 <ozone> dons: viper's even more crack than vimacs
05:25:21 <ozone> at least vimacs is kinda consistent: vim in normal mode, emacs in insert mode
05:25:25 <ozone> viper is just... crazy
05:25:46 <ozone> dd to delete a line, Ctrl-x 2 to split a window.  wtf?
05:26:01 <dons> yikes
05:26:06 <ozone> sorry, not viper, vile
05:26:31 <dons> cool, the average in here is 299 now.
05:26:40 <quicksilver> Saizan: pretty sure they are supposed to, yes
05:27:31 <Saizan> quicksilver: do you use windows?
05:27:52 <quicksilver> Saizan: never. Have never owned a copy, have never pirated a copy. Never wish to :P
05:28:11 <quicksilver> Saizan: I do of course, occasionally, use windows on other people's computers. But not for haskell programming.
05:30:07 <Saizan> well ghc+cabal is the most windows-friendly development environment that i've found, only python beats it maybe
05:31:36 <dons> Saizan: that's good to know. I think the cabal guys will be pleased
05:32:24 <ozone> Saizan: you don't use visual haskell at all?
05:32:37 <Saizan> heh :) if they could manage even C libs dependecies it would be great :)
05:33:08 <Saizan> ozone: no, everything on cmd.exe plus the mingw/msys suite
05:34:07 <Saizan> (which is rarely or not at all used by cabal)
05:34:25 <ozone> right
05:34:58 <therp> when we have a common build architecture, we could also create a common installation architecture.. asdf is for lisp what cabal is for haskell. but there is in addition asdf-install. you just provide it with a package name and it fetches it from a semi centralised repository builds and installs it (either system-wide or just in ~/.asdf-install-dir/).
05:35:55 <therp> cliki.net (a common lisp wiki) serves as central repository.. actually its just an indirection repo, feeding url where the actual packages can be fetched to asdf-install. haskell wiki could be cliki in our case
05:36:25 <dons> right, that's what cabal-install is for
05:36:28 <dons> though its in beta
05:36:45 <dons> basically, wget $hackage/package.tar.gz ; untar ; runhaskell configure/build/install
05:36:48 <dons> done.
05:36:56 <dons> ?hackage mtl
05:36:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
05:36:58 <dons> for exapmle
05:37:08 <therp> usually I dislike when "my" ideas are realized by someone else.. that's an expection here :)
05:37:31 <ozone> therp: beware of dons, he's the best idea-stealer i've ever seen
05:37:42 <dons> well, cabal-install has always been the key part of cabal/hackage's vision
05:37:42 <ozone> but, he's also rather good at implementing them
05:37:58 <therp> fine :) I don't mind at all
05:38:09 <dons> lazy bones ozone needs to write more code! ;-)
05:38:09 <ozone> i'm convinced that he's actually an army of gnomes
05:38:22 <Saizan> so we can have somthing like CPAN
05:38:24 <ozone> i write code, just not haskell code these days :/
05:38:33 <dons> Saizan: right, that's exactly what hackage is.
05:38:44 <dons> i note there are daily new packages landing, so i think it is working
05:38:53 <dons> and once ghc 6.8 comes out with cabal-install, that's it basically
05:39:25 <Saizan> if you add a "search"
05:39:45 <dons> yeah, that'll be needed soon enough, + hoogle intergration and system wide docs
05:39:57 <dons> (since all the cabal stuff can be haddockised too)
05:40:18 <dons> just having the things in a central place is already a big step
05:40:51 <_roconnor> @hoogle quickCheck
05:40:51 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
05:40:52 <lambdabot> Test.QuickCheck :: module
05:47:40 <_roconnor> @instances Arbitrary
05:47:41 <lambdabot> Couldn't find class `Arbitrary'. Try @instances-importing
05:48:10 <dons> they're in Test.QuickCheck
05:48:17 <dons> ?source Test.QuickCheck
05:48:17 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
05:48:21 <dancor> why does ghc-6.6 block hs-plugins in gentoo
05:48:32 <dons> only the darcs version works with ghc 6.6
05:48:37 <dancor> ah
05:48:52 <dons> @seen kfish
05:48:52 <lambdabot> kfish is in #haskell. I don't know when kfish last spoke.
05:49:21 <dons> nytol!
05:50:04 <huschi> hi. i'm working with hxt and i've got an xml arrow "a b XmlTree" and want to construct an xml arrow "a [b] XmlTree". does anybody know how to do this.
05:50:26 <huschi> i've already a knot in my brain and i still can't figure out the right way.
05:50:43 <huschi> ?
05:51:57 <_roconnor> dons:  can we have Ratio a an instance of Arbitrary?
05:54:10 <_roconnor> ?paste
05:54:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:54:46 <hpaste>  roconnor pasted "Arbitrary (Ratio a)" at http://hpaste.org/818
05:54:54 <Saizan> ?hoogle (Arrow a) => a b x -> a [b] x
05:54:55 <lambdabot> Prelude.id :: a -> a
05:54:55 <lambdabot> Prelude.asTypeOf :: a -> a -> a
05:54:55 <lambdabot> Prelude.const :: a -> b -> a
05:56:08 <huschi> Saizan: :(
05:56:40 <LoganCapaldo> I think I heard in here that hoogle doesn't grok (Someclass a) => things
05:56:42 <huschi> it looks like a great problem for me.
05:57:06 <Saizan> huschi: now that i think of it, it's not obvious how would build it
05:58:08 <huschi> Saizan: yeah, i got it.
05:58:15 <huschi> arrL from ArrowList is the key.
05:58:40 <huschi> ist has type: ArrowList a => (b -> [c]) -> a b c
06:04:12 <chessguy> ?where report
06:04:13 <lambdabot> http://www.haskell.org/onlinereport/
06:04:30 <quicksilver> chessguy: not a very hard url to remember :)
06:04:40 <chessguy> 'morning haskellites
06:04:44 <chessguy> quicksilver, :)
06:05:38 <chessguy> hey, someone was wrong yesterday
06:05:45 <chessguy> modules ARE allowed to be mutually recursive
06:07:12 <quicksilver> chessguy: really?
06:07:38 <chessguy> "Because they are allowed to be mutually recursive, modules allow a program to be partitioned freely without regard to dependencies."
06:07:46 <quicksilver> "GHC supports the compilation of mutually recursive modules. This section explains how."
06:07:54 <chessguy> http://www.haskell.org/onlinereport/modules.html , second-to-last paragraph before section 5.1
06:07:55 <lambdabot> Title: The Haskell 98 Report: Modules
06:08:09 <chessguy> quicksilver, where are you looking?
06:08:38 <quicksilver> chessguy: GHC docs
06:08:50 <quicksilver> chessguy: first google hit for 'mutually recursive modules', actually
06:09:02 <quicksilver> chessguy: it was me, I was wrong. Sorry. I still think it's a bad idea in general though.
06:09:18 <chessguy> mmm, maybe
06:09:31 <quicksilver> maybe I just haven't been showed the use case that convinces me :)
06:09:41 <chessguy> but the Report is right about it being nice to be able to partition your program without regard to dependencies
06:09:58 <erider> good morning all
06:09:58 <quicksilver> in general the principle of modularisation (in any program, in any language) which I use is for all dependencies to be one way
06:10:20 <quicksilver> hmm
06:10:39 <chessguy> but if you don't allow this,  you have to allow things like A imports B, A imports C, and B imports C
06:10:46 <chessguy> which is kind of ugly
06:10:51 <quicksilver> why is that ugly?
06:11:02 <quicksilver> surely that's quite sensible and often necessary
06:11:13 <chessguy> because C is imported twice by A
06:11:15 <quicksilver> (C could be Prelude, for example :P)
06:11:23 <quicksilver> 'imported twice' doesn't mean anything
06:11:30 <quicksilver> you either have access to the symbols, or you don't
06:11:37 <quicksilver> importing a symbol into a namespace is idempotent
06:11:38 <chessguy> i guess
06:11:51 <chessguy> ?all-dict idempotent
06:11:53 <lambdabot> *** "idempotent" wn "WordNet (r) 2.0"
06:11:54 <lambdabot> idempotent
06:11:54 <lambdabot>      adj : unchanged in value following multiplication by itself; "this
06:11:54 <lambdabot>            matrix is idempotent"
06:11:54 <lambdabot>  
06:11:55 <lambdabot> [41 @more lines]
06:12:00 <chessguy> oh
06:12:04 <quicksilver> idempotent : do it twice and it's the same as doing it once
06:12:09 <quicksilver> f f x = f x
06:12:11 <osfameron> useful for test suites
06:12:27 <chessguy> anyway
06:12:33 <quicksilver> 'Haskell, the language so good they imported it twice'
06:12:38 <chessguy> interesting stuff
06:12:42 <kuribas> What happend to lisppaste?
06:12:51 <chessguy> !paste
06:12:51 <hpaste> Haskell paste bin: http://hpaste.org/
06:12:53 <mauke> including standard headers in C is idempotent
06:12:58 <kpreid> @check \x -> (nub . nub) x == nub x
06:12:59 <chessguy> kuribas, we have our own pastebin
06:13:00 <lambdabot>  Add a type signature
06:13:29 <kuribas> chessguy: Why, is it better than lisppaste?
06:13:45 <quicksilver> of course, it's written in haskell!
06:13:46 <roconnor> is posting to ghc Trac appropriate for placing a patch to add Arbitrary Ratio to quickCheck?
06:13:47 <quicksilver> :P
06:14:02 <chessguy> kuribas, it's written in haskell, it has support for haskell syntax highlighting, it has diff capabilities, etc.
06:14:27 <Daveman> :)
06:14:29 <kuribas> chessguy: lisppaste has haskell syntax highlighting (and other features).
06:14:31 <Saizan> kuribas: also, lisppaste was often down
06:14:59 <chessguy> yes, this is actually hosted by active #haskell members
06:15:43 <kuribas> Allright then...
06:16:03 <hpaste>  kuribas pasted "State Monad in Parser" at http://hpaste.org/819
06:17:14 <kuribas> Is this the best way to embed a StateMonad in a Parser?
06:17:29 <kuribas> Or should I use a Monad Transformer or something?
06:17:38 <Saizan> does that work?
06:18:24 <kuribas> Don't know...
06:18:30 <dancor> doesn't it bother anyone that it's really hard to trace things when looking at someone else's code and the imports are not import qualified
06:18:44 <chessguy> i've never seen a monadic return type with a monad in it
06:19:24 <chessguy> (but don't judge by me, i'm clueless)
06:19:24 <Saizan> well, you can do it, you are computing action without executing them
06:19:39 <chessguy> i didn't say you couldn't do it
06:20:50 <Saizan> dancor: definitely
06:21:26 <dancor> Saizan: but import qualified seems quite rare
06:21:46 <dancor> Saizan: should i just use it personally and feel smugly superior about it
06:21:53 <chessguy> i don't know, i see it a fair amount
06:22:21 <dancor> well that's good
06:22:24 <Saizan> dancor: a better solution would be an editor with name-resolition triggere on hovering
06:23:35 <kuribas> chessguy: The idea is that it parses a duration if it finds one, and otherwise takes it from the context.
06:24:10 <kuribas> But I want to controle where to put a value in the context.
06:24:21 <sjanssen> ghci :info and hoogle are very handy in tracking down imports
06:25:32 <Zeroth|work> > putStrLn "hello!"
06:25:34 <lambdabot>  <IO ()>
06:25:44 <hpaste>  (anonymous) annotated "State Monad in Parser" with "(no title)" at http://hpaste.org/819#a1
06:25:46 <sjanssen> Zeroth|work: no IO allowed :)
06:26:02 <Zeroth|work> :-p
06:26:04 <Saizan> uhm, :info is not that useful when you want to poke symbols not exported, right?
06:26:11 <ski> kuribas : do you want to use the state to guide how to parse ?
06:26:47 <kuribas> ski: Only for the length of the notes, but it doesn't really affect the parsing, only the return value.
06:27:12 <ski> if it doesn't affect the "pattern of parsing", then that should be ok, i think
06:27:23 <sjanssen> Saizan: when you want to find out where a symbol is defined (and most likely where it is imported from), it is in one of two places:
06:27:30 <sjanssen> 1.  The file you are editing
06:27:32 <ski> (otherwise you need a parser transformer)
06:27:44 <sjanssen> 2.  The location returned by ghci :info
06:31:45 <malcolmw> dancor: tried ghc -ddump-minimal-imports?
06:32:55 <Zeroth|work> thank god we killed that vampire, slobodian milosevic: http://www.theregister.co.uk/2007/03/06/milosevic_staked/
06:34:18 <kuribas> ski: does it exist?
06:35:08 <Zeroth|work> > [1..3]
06:35:12 <lambdabot>  [1,2,3]
06:40:17 <sjanssen> malcolmw: is there a trick to using -ddump-minimal-imports?
06:40:18 <ski> kuribas : i don't recall ..
06:40:34 <chessguy> ?remember dons This is all very nice, but the code feels a bit icky.
06:40:34 <lambdabot> Done.
06:40:44 <malcolmw> sjanssen: why, does it not work as expected?
06:43:45 <hpaste>  sjanssen pasted "what should -ddump-minimal-imports do here?" at http://hpaste.org/820
06:44:57 <roconnor> can haskell do linear optimization?
06:44:59 <Itkovian> dons: nice blog post.
06:48:22 <sjanssen> ah, the imports are dumped into a file
06:48:58 <sjanssen> this isn't documented at all
06:49:26 <Zeroth|work> my boss picked up the YAHT that I printed off, flipped through it and just said "theres a lot of gobble-dee-gook in there."
06:50:40 <Saizan> gobble-dee-gook?
06:50:48 <Zeroth|work> yup
06:51:00 <notsmack> Zeroth|work: that's why he makes the big bucks
06:51:47 <Zeroth|work> its the C students that go on to become entrepreneurs. its the D students like me that can't spell "entrepreneur"
06:51:47 <Zeroth|work> heh
06:52:01 <Pastorn> @pl (\(x,y) (a,b) -> (x+a,y+b))
06:52:02 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
06:52:16 <Pastorn> @pl (\(x,y) -> (y,x))
06:52:17 <lambdabot> uncurry (flip (,))
06:54:01 <Zeroth|work> well I'll be damned. I spelled it right
07:00:03 <notsmack> @where mtl
07:00:03 <lambdabot> www.cs.brown.edu/~jwicks/mtl_reference/
07:01:34 <Igloo> @hackage mtl
07:01:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
07:05:13 <Zeroth|work> @where hopengl
07:05:13 <lambdabot> http://haskell.org/HOpenGL/
07:13:44 <Pastorn> @google haskell vectors
07:13:46 <lambdabot> http://sneezy.cs.nott.ac.uk/QML/weblog/?p=32
07:13:46 <lambdabot> Title: QML@CS.Nott » Blog Archive » QMeet: Infinite Vectors in Haskell and LinAlg Revis ...
07:19:53 <Zeroth|work> the "red book" link on http://haskell.org/HOpenGL/ is dead as dead
07:19:54 <lambdabot> Title: HOpenGL
07:21:07 <sjanssen> Zeroth|work: I think that page is bitrotted
07:21:30 <Zeroth|work> lol@bitrot
07:21:43 <Zeroth|work> thats the only dead link afik
07:21:49 <Zeroth|work> a few others worked fine
07:22:03 <Zeroth|work> @where red book
07:22:03 <lambdabot> I know nothing about red.
07:22:07 <Zeroth|work> @where redbook
07:22:08 <lambdabot> I know nothing about redbook.
07:22:45 <sjanssen> Zeroth|work: the latest release listed on that page is 1.05, but the latest release on hackage is 2.1
07:23:01 <Zeroth|work> yikes
07:24:38 <chessguy> Zeroth|work, i suspect it's referring to http://www.amazon.com/exec/obidos/ASIN/0321335732/ref=nosim/openglorg , though i can't be sure
07:24:42 <lambdabot> http://tinyurl.com/23a27w
07:25:17 <Zeroth|work> I'm looking at that page
07:25:39 <Zeroth|work> I think I've got 4th edition ...
07:25:45 <Zeroth|work> but I dont recall it being red
07:29:43 <clanehin> this?  http://www.opengl.org/documentation/red_book/
07:29:44 <lambdabot> Title: The OpenGL Programming Guide - The Redbook
07:29:58 <Pastorn> @hoogle nub
07:29:59 <lambdabot> List.nub :: Eq a => [a] -> [a]
07:29:59 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
07:30:21 <Pastorn> how do I ask lambdabot what module a certain function is in?
07:30:42 <ibid> index
07:30:47 <sjanssen> @index nub
07:30:47 <lambdabot> Data.List
07:33:19 <mauke> @index forall
07:33:20 <lambdabot> bzzt
07:34:34 <Pastorn> @type mapAccumL
07:34:36 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:34:43 <Pastorn> ?src mapAccumL
07:34:43 <lambdabot> mapAccumL _ s []        =  (s, [])
07:34:43 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
07:34:43 <lambdabot>    where (s', y ) = f s x
07:34:43 <lambdabot>          (s'',ys) = mapAccumL f s' xs
07:41:07 <Pastorn> ?src minimum
07:41:07 <lambdabot> minimum [] = undefined
07:41:07 <lambdabot> minimum xs = foldl1 min xs
07:41:41 <Pastorn> @type foldl1
07:41:44 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:42:13 <Pastorn> shouldn't minimum make use of scan instead of fold?
07:42:51 <Thunder> Pastorn: You need only the result, not the list of all intermediate minimas.
07:46:58 <Zeroth|work> > let f (10946:xs) = 10946:xs; f (x:xs) = f ([x + xs !! 0] ++ x:xs) in f [1,1]
07:46:59 <lambdabot>  [10946,6765,4181,2584,1597,987,610,377,233,144,89,55,34,21,13,8,5,3,2,1,1]
07:47:14 <Zeroth|work> now whats the other ways of doing this?
07:48:32 <Igloo> To do what, exactly?
07:48:38 <Zeroth|work> fibonacci
07:48:45 <sjanssen> Zeroth|work: you should use head xs instead of xs !! 0
07:49:08 <Zeroth|work> > let f (10946:xs) = 10946:xs; f (x:xs) = f ([x + head xs] ++ x:xs) in f [1,1]
07:49:10 <lambdabot>  [10946,6765,4181,2584,1597,987,610,377,233,144,89,55,34,21,13,8,5,3,2,1,1]
07:49:52 <Igloo> > let f x y = x : f y (x+y) in reverse $ takeWhile (<= 10946) $ f 1 1 -- is what I'd do
07:49:53 <lambdabot>  [10946,6765,4181,2584,1597,987,610,377,233,144,89,55,34,21,13,8,5,3,2,1,1]
07:49:54 <Zeroth|work> how do I remove the last item of a list?
07:50:10 <sjanssen> Zeroth|work: init
07:50:26 <Zeroth|work> > let f (10946:xs) = 10946:xs; f (x:xs) = f (init ([x + head xs] ++ x:xs)) in f [1,1]
07:50:28 <lambdabot>  [10946,6765]
07:50:29 <sjanssen> but it is not efficient to do it repeatedly
07:50:36 <Zeroth|work> > let f (x:xs) = f (init ([x + head xs] ++ x:xs)) in f [1,1]
07:50:40 <lambdabot> Terminated
07:50:46 <Zeroth|work> I wanted the last value :-p
07:50:53 <Zeroth|work> > let f (x:xs) = f (init ([x + head xs] ++ x:xs)) in head (f [1,1])
07:50:57 <lambdabot> Terminated
07:51:05 <sjanssen> Zeroth|work: you need a termination condition
07:51:15 <resiak> are you still trying to get it to run until you run out of stack space and then pull the last value computed out of the wreckage?
07:51:27 <Igloo> Zeroth|work: Are you just trying to find the nth fibonacci number?
07:51:34 <Zeroth|work> meh
07:51:36 <Zeroth|work> sort of
07:51:43 <Igloo> sort of?  :-)
07:51:55 <Zeroth|work> the main purpose is to learn, but yes.
07:52:22 <Igloo> The natural way to do that is to make the infinite list of fibonacci numbers (in ascending order) and then just take the nth element of the list
07:52:49 <chessguy> Igloo, he's been told that many times
07:53:11 <Zeroth|work> chessguy, funny, I don't recall
07:53:11 <Igloo> OK, why don't you like that answer then?
07:53:29 * Igloo senses a communication issue  :-)
07:53:34 <Zeroth|work> aye
07:53:40 <Zeroth|work> I'm taking lunch.
07:54:58 <chessguy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs || 100
07:54:59 <lambdabot>  Couldn't match expected type `Bool' against inferred type `[a]'
07:55:22 <chessguy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
07:55:24 <lambdabot>  573147844013817084101
07:55:41 <chessguy> that error threw me for a minute :)
07:56:30 <chessguy> @pl \n -> fibs !! n
07:56:31 <lambdabot> (fibs !!)
07:57:02 <chessguy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in (fibs !!)
07:57:04 <lambdabot>  <Int -> Integer>
07:57:41 <chessguy> interesting. how does it infer fibs::[Integer]
07:57:55 <Saizan> defaulting
07:58:07 <chessguy> oh, i thought the default was Int
07:58:17 <Saizan> no
07:58:31 <chessguy> > take (3::Integer) [1..10]
07:58:32 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
07:58:40 <chessguy> hmm, that's silly
07:58:43 <Saizan> ?type take
07:58:46 <lambdabot> forall a. Int -> [a] -> [a]
07:59:05 <sjanssen> chessguy: the default integral type is Integer, but all of the list index functions use Int
07:59:06 <chessguy> shouldn't it be Integral b => b -> [a] -> [a] ?
07:59:23 <chessguy> ?type (!!)
07:59:25 <lambdabot> forall a. [a] -> Int -> a
07:59:44 <sjanssen> this is a concession towards efficiency
07:59:54 <chessguy> fair enough
07:59:58 <Thunder> > let myAcc f s = (\xs -> (fst $ last xs, map snd $ tail xs)) . scanl (\s x -> let (s',y) = f (fst s) x in (s',y)) (s,undefined)
07:59:58 <lambdabot>  Parse error
08:00:33 <Thunder> This myAcc is the same as mapAccumL or do I miss something?
08:00:50 <chessguy> ?src mapAccumL
08:00:51 <lambdabot> mapAccumL _ s []        =  (s, [])
08:00:51 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
08:00:51 <lambdabot>    where (s', y ) = f s x
08:00:51 <lambdabot>          (s'',ys) = mapAccumL f s' xs
08:01:14 <Thunder> chessguy: I replaces the recursion by scanl.
08:02:05 <Thunder> @pl let myAcc f s = (\xs -> (fst $ last xs, map snd $ tail xs)) . scanl (\s x -> let (s',y) = f (fst s) x in (s',y)) (s,undefined) in myAcc
08:02:05 <lambdabot> (line 1, column 82):
08:02:05 <lambdabot> unexpected "("
08:02:05 <lambdabot> expecting natural, identifier or "in"
08:03:25 <Saizan> ?ty let myAcc f s = (\xs -> (fst $ last xs, map snd $ tail xs)) . scanl (\s x -> let (s',y) = f (fst s) x in (s',y)) (s,undefined) in myAcc
08:03:28 <lambdabot> forall a b b1. (a -> b -> (a, b1)) -> a -> [b] -> (a, [b1])
08:03:40 <chessguy> Thunder,  "in myAcc" doesn't make any sense. you have to give it the parameters
08:04:23 <Thunder> @pl \f s ->  (\xs -> (fst $ last xs, map snd $ tail xs)) . scanl (\s x -> let (s',y) = f (fst s) x in (s',y)) (s,undefined)
08:04:24 <lambdabot> (line 1, column 75):
08:04:24 <lambdabot> unexpected "("
08:04:24 <lambdabot> expecting natural, identifier or "in"
08:05:36 <pafcu> Hi. I have a function which returns the n first elements of a list: dropEnd n list = take (length list - n) list
08:05:39 <mux> @pl \a x -> (a+1,x+1)
08:05:39 <lambdabot> (. (1 +)) . (,) . (1 +)
08:05:47 <pafcu> But it seems to be slow and uses a lot of memory
08:05:51 <pafcu> Any way to make it better?
08:06:04 <mux> @pl fst (+1) . snd (+1)
08:06:04 <lambdabot> fst (1 +) . snd (1 +)
08:06:18 <chessguy> pafcu, umm. dropEnd = take ?
08:06:26 <mux> @pl (fst (+1), snd (+1))
08:06:27 <lambdabot> (fst (1 +), snd (1 +))
08:06:45 <chessguy> > take 5 [1..10]
08:06:47 <earthy> pafcu: I presume you mean the prefix of a list that leaves n elements out at the end?
08:06:48 <lambdabot>  [1,2,3,4,5]
08:06:56 <pafcu> earthy: yes
08:07:00 <mux> @pl curry (fst (+1), snd (+1))
08:07:01 <lambdabot> curry (fst (1 +), snd (1 +))
08:07:01 <chessguy> oh
08:07:14 <pafcu> I said it wrong earlier :-)
08:07:22 <fasta> What's the worst case complexity of inserting n elements in a hashtable?
08:07:28 <earthy> dropend n l = reverse . drop n . reverse $ l
08:07:44 <earthy> that's as bad though. :)
08:08:14 <pafcu> earthy: When profiling my app that functions seems to allocate a lot of memory
08:08:14 <chessguy> it's just a bad thing to want to do with a linked list
08:08:33 <earthy> pafcu: ofcourse. It has to traverse the entire list
08:08:48 <earthy> as in absolutely definitively *has* to. can't do it otherwise.
08:09:08 <chessguy> > let dropEnd n list = take (length list - n) list in dropEnd 1 [1..]
08:09:10 <chessguy> worse yet
08:09:12 <lambdabot> Terminated
08:09:15 <Thunder> > let myAcc f s = (\xs -> (fst $ last xs, map snd $ tail xs)) . scanl (f . fst) (s,undefined) in myAcc (\s x -> (s + x, x)) 0 [1 .. 10]
08:09:17 <lambdabot>  (55,[1,2,3,4,5,6,7,8,9,10])
08:09:41 <Thunder> > mapAccumL (\s x -> (s + x, x)) 0 [1 .. 10]
08:09:43 <lambdabot>  (55,[1,2,3,4,5,6,7,8,9,10])
08:09:44 <earthy> but why would you want to drop a fixed number off of the end of a list?
08:09:49 <chessguy> @pl \s x -> (s + x, x)
08:09:49 <lambdabot> join . ((,) .) . (+)
08:09:53 <chessguy> heh
08:10:08 <chessguy> Thunder, why didn't you think of that? :)
08:10:16 <emu> fasta: O(n) presumably
08:10:19 <pafcu> earthy: I want to swap the n last elements in a list for another list
08:10:20 <Pastorn> @type join
08:10:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:10:44 <fasta> emu: why? I have TAOCP Vol 3 here, but I don't see it claiming that.
08:10:53 <pafcu> I.e keep the start of the list, but change the n last elements to match those in another list
08:10:56 <earthy> pafcu: can you restate the calculation in terms of reversed lists? :)
08:10:59 <emu> TAOCP was written before universal hashing
08:11:06 <emu> i think
08:11:06 <Thunder> chessguy: Because I'd like to keep it a bit readable ;-)
08:11:13 <chessguy> Thunder, yes, i was kidding
08:11:41 <fasta> emu: ok, so you claim that universal hashing gives not just an expected bound, but a real bound?
08:11:46 <Thunder>  @pl \f s ->  (\xs -> (fst $ last xs, map snd $ tail xs)) . scanl (f . fst) (s,undefined)
08:11:54 <pafcu> earthy: I guess I'll have to experiment a bit with different approaches
08:11:55 <fasta> emu: Do you know a good reference for that?
08:12:01 <Thunder> @pl \f s ->  (\xs -> (fst $ last xs, map snd $ tail xs)) . scanl (f . fst) (s,undefined)
08:12:01 <lambdabot> ((ap ((,) . fst . last) (map snd . tail) .) .) . (. flip (,) undefined) . scanl . (. fst)
08:12:24 <chessguy> hehe
08:12:26 <pafcu> It just seems like the great gurus in this channel always have a solution to my problems
08:12:57 <quicksilver> or problems with your solutions
08:12:58 <quicksilver> or both
08:13:02 <Thunder> This would be pretty cool for the standard library: The unreadable one.
08:13:41 <chessguy> pafcu, you'll have to be very careful to not try to do this on an infinite list, too. it's very dangerous
08:14:58 <Thunder> @unpl ((ap ((,) . fst . last) (map snd . tail) .) .) . (. flip (,) undefined) . scanl . (. fst)
08:14:59 <lambdabot> (\ j ah ak -> ((\ y -> ((,)) (fst (last y))) >>= \ r -> (\ ae -> map snd (tail ae)) >>= \ q -> return (r q)) (scanl (\ ar -> j (fst ar)) ((,) ah undefined) ak))
08:15:13 <Thunder> ah.
08:15:17 <chessguy> hehe
08:15:59 <Thunder> The Haskell uglifier at work.
08:16:12 <chessguy> sometimes pl is very nie
08:16:13 <chessguy> nice
08:16:24 <chessguy> @pl \x y -> x + y
08:16:24 <lambdabot> (+)
08:16:50 <chessguy> that came up yesterday, i think
08:16:50 <emu> ?pl \x y -> fst x `compare` fst y
08:16:51 <lambdabot> (. fst) . compare . fst
08:17:07 <Thunder> @pl \x s -> let (s',y) = f (fst s) x in (s',y)
08:17:07 <lambdabot> (line 1, column 13):
08:17:08 <lambdabot> unexpected "("
08:17:08 <lambdabot> expecting natural, identifier or "in"
08:17:28 <Thunder> Bad, but this was the one which returns "f . fst"
08:17:31 <Saizan> too bad that after an iteration of pl unpl your code just oscillates :)
08:17:41 <nominolo> are there any other implementations of heterogeneous records in haskell?
08:17:51 <nominolo> i mean other than HLIST
08:18:12 <earthy> well, records, obviously
08:18:14 <chessguy> uh, standard records are heterogenous
08:18:29 <earthy> tuples
08:18:33 <Saizan> extendible maybe?
08:18:35 <chessguy> ugh
08:18:55 <nominolo> oh, heh, yes, extendable
08:18:55 <earthy> but maybe you mean something else, nominolo
08:19:05 <chessguy> Saizan, well, it doesn't quite oscillate, all your names get replaced with incomprehensible ones :)
08:19:06 <Thunder> Either this that
08:19:07 <earthy> well, there was t-rex
08:19:09 <nominolo> that is, statically extendable
08:19:25 <quicksilver> nominolo: well tuples are statically extendable
08:19:36 <quicksilver> it does rather depend what your requirements are...
08:20:28 <nominolo> hm, back to step one then
08:20:49 <Saizan> the real improvement over records would be subtyping i think
08:21:07 <quicksilver> subtyping would be nice, although there's always 'catch'
08:21:07 <dcoutts_> and ability to join/mask records
08:21:08 <nominolo> yes
08:21:25 <nominolo> quicksilver: catch?
08:21:26 <quicksilver> when I say 'there's always' I mean 'hopefully there soon will be'
08:21:33 <sjanssen> I'd be happy with a record system with overloaded names
08:21:33 <earthy> I'd be *perfectly* happy with first class labels. :)
08:21:33 <quicksilver> nominolo: ndm's static subtype-checker
08:21:37 * sjanssen is a simple man
08:22:03 <quicksilver> earthy: what would the type of a first-class label be?
08:22:05 <nominolo> ok, i have a big record
08:22:19 <earthy> that's one of the problems. :P
08:22:21 <nominolo> and i have some typeclasses which each need some part of this record
08:22:34 <nominolo> and update other parts of the record
08:22:51 <nominolo> but since each field has a different type ...
08:23:07 <Saizan> anyone here used HList records with subtyping?
08:23:16 <nominolo> the problem is, i have multiple such records
08:23:44 <nominolo> and having them all as typeclass parameters is a bit evil
08:24:14 <chessguy> @get-shapr
08:24:14 <lambdabot> shapr!!
08:25:44 <nominolo> in oop i'd use mixins or traits
08:26:04 <sjanssen> nominolo: can a field name have different types of data associated with it
08:26:21 <nominolo> no
08:27:41 <nominolo> ok, i think i want exactly mixins
08:28:08 <nominolo> maybe with a feature to include the same thing twice
08:28:21 <nominolo> but then it'd would just get a different integer index
08:28:37 <nominolo> that wouldn't be a problem, i guess
08:28:46 <quicksilver> it sounds to me like what you're talking about is just plain simple typeclasses
08:28:58 <sjanssen> the set of fields for a record is static or dynamic?
08:29:32 <shapr> hiya chessguy
08:29:35 <nominolo> sjanssen: hm
08:29:50 <nominolo> sjanssen: static
08:30:19 <nominolo> ok, maybe i was just thinking too complicated
08:33:30 <quicksilver> I find that's endemic with type system extensions
08:33:44 <shapr> Man, I have some kind of nasty cold today.
08:34:12 <ventonegro> can anybody help me? i've been bitten by laziness
08:34:18 <ventonegro> @paste
08:34:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:35:26 <hpaste>  ventonegro pasted "table creation" at http://hpaste.org/821
08:36:19 <ventonegro> first, the initDB function is an ugly translation of an imperative idiom
08:36:38 <ventonegro> second, createTables is never called because its value is never needed
08:38:25 <chessguy> so...you know your code has problems and you want us to re-write it for you?
08:39:02 <quicksilver> ventonegro: I've never used HDBC, but
08:39:14 <ventonegro> chessguy: believe me, i'm not asking for the sake of it
08:39:23 <quicksilver> ventonegro: I'd be very surprised if it mattered that createTables value is not needed
08:39:27 <ventonegro> chessguy: if you could help, it would be appreciated
08:39:34 <sjanssen> ventonegro: what is the run function?
08:39:49 <quicksilver> ventonegro: typical behaviour of IO actions is that they do their work, whether or not the computed value is used
08:40:03 <ventonegro> sjanssen: it runs a simple query on the db connection
08:40:06 <quicksilver> ventonegro: i.e. IO actions are not typically lazy (getContents being an exception)
08:40:52 <quicksilver> ventonegro: are you sure 'tablesCreated' isn't returning true?
08:40:54 <sjanssen> @where hdbc
08:40:55 <lambdabot> http://quux.org/devel/hdbc
08:41:01 <ventonegro> quicksilver: hmmm... then i'm more lost than before
08:41:06 <CosmicRay> ventonegro: unless (created) (createTables con)
08:41:16 <ventonegro> @index unless
08:41:16 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:41:47 <CosmicRay> now, you return an integer from createTables but don't really want it
08:41:52 <quicksilver> ventonegro: in fact, I'm faintly surprised that code compiles. is '0' a valid value of type Connection ?
08:42:01 <ventonegro> CosmicRay: thanks, very useful
08:42:04 <quicksilver> CosmicRay: true but that would actually be the cause of the symptoms he describes, woudl it?
08:42:08 <quicksilver> CosmicRay: woudln't
08:42:25 <CosmicRay> quicksilver: well createTables is his own function
08:42:30 <ventonegro> createTables is an IO Integer
08:42:40 <ventonegro> quicksilver: because run is IO Integer
08:43:07 <quicksilver> oh, right
08:43:07 <quicksilver> duh
08:43:28 <CosmicRay> @hoogle evaluate
08:43:29 <lambdabot> Control.Exception.evaluate :: a -> IO a
08:43:29 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
08:43:30 <Pastorn> ?src mapM_
08:43:31 <lambdabot> mapM_ f as = sequence_ (map f as)
08:43:55 <quicksilver> CosmicRay: true. But I don't see how using if instead of unless in this context would stop createTables being executed :)
08:44:12 <CosmicRay> quicksilver: it won't.  that was addressing his "it looks like an imperative program" comment
08:44:18 <quicksilver> CosmicRay: ah, right :)
08:44:42 <hpaste>  (anonymous) annotated "table creation" with "(no title)" at http://hpaste.org/821#a1
08:44:54 <CosmicRay> I am not positive that this will fix your evaluation order problem
08:45:32 <CosmicRay> http://software.complete.org/hpodder/browser/DB.hs is an example of a much more involved version of the basic problem you are trying to solve
08:45:34 <lambdabot> Title: /DB.hs - hpodder
08:45:34 <quicksilver> :t unless
08:45:34 <Zeroth|work> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
08:45:37 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:45:38 <lambdabot>  573147844013817084101
08:45:44 <Zeroth|work> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 101
08:45:45 <lambdabot>  927372692193078999176
08:45:57 <Pastorn> ?src  sequence
08:45:57 <lambdabot> sequence ms = foldr k (return []) ms
08:45:57 <lambdabot>     where
08:45:57 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:45:58 <quicksilver> CosmicRay: if you want to unless, you need to strip the value from createTables
08:45:58 <Zeroth|work> what does zipWidth do?
08:46:23 <quicksilver> > zipWith (+) [1,2,3] [2,0,-2]
08:46:24 <lambdabot>  [3,2,1]
08:46:30 <CosmicRay> quicksilver: what do you mean, "strip the value"?
08:46:30 <mux> zip = zipWith (,)
08:46:31 <quicksilver> Zeroth|work: see? :)
08:46:38 <quicksilver> CosmicRay: unless wants something of type IO ()
08:46:49 <CosmicRay> quicksilver: yeah, I know, see my anotated paste
08:46:50 <quicksilver> oh
08:46:52 <quicksilver> blah
08:46:54 <quicksilver> right
08:46:55 <quicksilver> :)
08:47:13 <Zeroth|work> quicksilver, it just adds each element respectively?
08:47:18 <quicksilver> what I meant by strip the value is exactly what you did :)
08:47:21 <Zeroth|work> well
08:47:25 <quicksilver> Zeroth|work: it 'does that function' respectively, yes
08:47:26 <Zeroth|work> (+)'s them ...
08:47:35 <quicksilver> > zipWith (*) [1,2,3] [3,4,5]
08:47:37 <lambdabot>  [3,8,15]
08:48:03 <ventonegro> CosmicRay: yep, your annotation equals my new version
08:48:31 <CosmicRay> ventonegro: is it working for you?
08:48:40 <ventonegro> it compiles
08:48:48 <quicksilver> ventonegro: I take it that this initDB is actually linked into your main?
08:48:48 <kaol> > let fibs = 1 : zipWith (+) fibs (tail fibs) in fibs
08:48:50 <lambdabot>  Exception: <<loop>>
08:48:50 <mauke> zipWith f [x1,x2,x3,...] [y1,y2,y3,...] = [f x1 y1, f x2 y2, f x3 y3, ...]
08:48:51 <ventonegro> but the tables are not created
08:49:05 <ventonegro> quicksilver: sure :-)
08:49:06 <CosmicRay> are you sure you are reading valid data from the sqlfile
08:49:20 <quicksilver> ventonegro: add some handy putStrLns in
08:49:42 <ventonegro> CosmicRay: sqlite3 laura.db < schema.sql works
08:49:43 <CosmicRay> and what does your main look like?
08:49:54 <CosmicRay> give us a self-contained example.
08:50:11 <CosmicRay> if you never care about the return value from initDB, all this work could be for naught
08:50:21 <hpaste>  quicksilver annotated "table creation" with "putStrLns, for example" at http://hpaste.org/821#a2
08:51:17 <quicksilver> CosmicRay: that implication is not correct, surely. IO actions perform their work if sequenced into the main action. It doesn't matter if you ignore the return value or not.
08:51:27 <hpaste>  ventonegro annotated "table creation" with "(no title)" at http://hpaste.org/821#a3
08:51:38 <ventonegro> CosmicRay: main pasted
08:51:50 <Zeroth|work> > let fibs = 1 : 1 : (zipWith (+) (fibs (tail fibs))) in fibs !! 100
08:51:52 <lambdabot>  Couldn't match expected type `[a1] -> [a]'
08:52:02 <CosmicRay> ventonegro: I bet you solve your problem if you add "disconnect con"
08:52:40 <quicksilver> > let fibs = 1 : 1 : (zipWith (+) fibs (tail fibs)) in fibs !! 100
08:52:41 <CosmicRay> quicksilver: I don't think I agree with that completely
08:52:41 <lambdabot>  573147844013817084101
08:52:49 <ventonegro> CosmicRay: hmmm, maybe it's gonna flush something
08:53:06 <quicksilver> CosmicRay: there are certain rare IO actions which are (unsafely) designed to only perform action when their results are evaluated, like getContents
08:53:09 <CosmicRay> it should at garbage collection time anyway, but!  then you will actually use con for something
08:53:15 <quicksilver> CosmicRay: see oleg's recent post on the subject
08:53:24 <quicksilver> CosmicRay: most IO actions don't act like that, though
08:53:46 <quicksilver> Zeroth|work: you just had the parentheses wrong
08:54:08 <Zeroth|work> quicksilver, I see that now
08:55:04 <quicksilver> CosmicRay: IO actions that do that are actually broken; unless their action has no observable side-effects. On that grounds you can try to excuse getContents.
08:55:53 <hpaste>  vincenz pasted "vincenz" at http://hpaste.org/822
08:58:35 <CosmicRay> quicksilver: but does that even hold if he says foo <- action, but never uses foo?
08:58:49 <quicksilver> CosmicRay: yes
08:58:59 <Zeroth|work> I can't figure out why this works:  > let fibs = 1 : 1 : (zipWith (+) fibs (tail fibs)) in fibs
08:59:05 <quicksilver> CosmicRay: it is intended to, that is required for referential transparency to work in the IO monad
08:59:20 <quicksilver> CosmicRay: some actions behave wrongly for reasons that they believe are justified :)
08:59:23 <notsmack> Zeroth|work: which part don't you understand?
08:59:43 <Zeroth|work> you're zipWidth'ing a list that hasn't even been made yet
08:59:53 <quicksilver> CosmicRay: that's why unsafeInterleaveIO has the word 'unsafe' in it :)
08:59:59 <Zeroth|work> notsmack, or is that the laziness?
09:00:04 <alec> Zeroth|work: ah, but part of the list has been made - the first two elements
09:00:05 <quicksilver> yes, that's the laziness
09:00:06 <notsmack> Zeroth|work: follow the substitution through on paper, you'll see it never gets into trouble
09:00:10 <notsmack> yeah, laziness
09:00:18 <Zeroth|work> notsmack, why does it ever stop?
09:00:22 <Zeroth|work> > let fibs = 1 : 1 : (zipWith (+) fibs (tail fibs)) in fibs
09:00:24 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
09:00:27 <quicksilver> it doesn't ever stop
09:00:38 <Zeroth|work> so why doesnt it get terminated?
09:00:45 <notsmack> Zeroth|work: why would it?
09:00:48 <quicksilver> lambdabot stops after 80 characters of output
09:00:53 <quicksilver> if you try it in ghci it will run forever
09:00:59 <Zeroth|work> > let f (10946:xs) = x:xs; f (x:xs) = f ((x + (xs !! 0)) ++ xs) in f [1,1]
09:00:59 <quicksilver> (until your computer runs out of memory)
09:01:00 <lambdabot>   Not in scope: `x'
09:01:02 <Zeroth|work> because mine did
09:01:14 <quicksilver> > let fibs = 1 : 1 : (zipWith (+) fibs (tail fibs)) in length fibs
09:01:16 <kc5tja> On a clear disk, you can seek forever.  ;D
09:01:19 <lambdabot> Terminated
09:01:30 <quicksilver> see? lambdabot had to terminate that one because it ran too long
09:01:43 <quicksilver> (trying to calculate length of infinite list)
09:02:04 <ventonegro> @where hdbc
09:02:05 <lambdabot> http://quux.org/devel/hdbc
09:03:17 <CosmicRay> that should be updated to http://software.complete.org/hdbc
09:03:18 <lambdabot> Title: Haskell Database Connectivity
09:04:00 <ventonegro> CosmicRay: the link to API docs is broken
09:04:05 <ventonegro> just emailed haskell-cafe
09:04:09 <CosmicRay> hit reload
09:04:14 <CosmicRay> I fixed it about 30 seconds ago
09:04:20 <ventonegro> alas, no luck with disconnect
09:04:30 <quicksilver> ventonegro: did you try some debugging printfs?
09:04:38 <quicksilver> ventonegro: does 'run' return any kind of error code?
09:04:41 <CosmicRay> ventonegro: remove all the other crap.
09:04:47 <ventonegro> quicksilver: "creating tables" is shown
09:04:51 <CosmicRay> ventonegro: no extra junk in main, no reading queries from a file.
09:04:58 <CosmicRay> ventonegro: make an isolated test case
09:05:17 <ventonegro> CosmicRay: ok
09:05:39 <CosmicRay> ventonegro: something that anyone can compile and test
09:06:20 <quicksilver> CosmicRay: HDBC should be throwing an exception, shouldn't it?
09:06:28 <CosmicRay> yes.
09:06:31 <quicksilver> CosmicRay: shouldn't he try to catch that after the run?
09:06:31 <Pastorn> ?src print
09:06:32 <lambdabot> print x = putStrLn (show x)
09:06:44 <CosmicRay> however, if his query didn't actually do anything, and thus didn't cause sqlite to return an error, no exception would be thrown
09:06:55 * quicksilver nods
09:06:58 <CosmicRay> quicksilver: he ideally would say main = handleSQL $ do
09:07:23 <CosmicRay> he could quite well be saying run conn "" [], and sqlite could obediantly be doing nothing
09:07:31 <quicksilver> main = handleSQL (myErrorHandler) $ do
09:07:32 <quicksilver> ?
09:07:45 <quicksilver> ah
09:07:51 <quicksilver> main = handleSQLError $ do
09:07:55 <quicksilver> (you meant, I think)
09:08:04 <CosmicRay> handleSqlError, right.
09:08:19 <ventonegro> hmm... sure, readFile is lazy
09:08:34 <ventonegro> as I don't ask for the value of run...
09:08:35 <sjanssen> ventonegro: try printing the contents of 'query' before run
09:08:39 <CosmicRay> that *shouldn't* be your problem, but we have no idea what is in your file
09:08:50 <sjanssen> ventonegro: laziness has nothing to do with your problem
09:08:51 <ventonegro> CosmicRay: is a valid complete schema
09:09:00 <CosmicRay> also, are you sure tablesCreated is doing the right thing?
09:09:07 <ventonegro> CosmicRay: as I said, sqlite3 laura.db < schema.sql works
09:09:09 <CosmicRay> I don't pretend to know what liftM is doing right off hand
09:09:23 <CosmicRay> ventonegro: are you sure that sqlite takes kindly to be handed a ton of queries when it expects one query?
09:09:29 <quicksilver> he said 'creating tables..' was printed
09:09:30 <sjanssen> CosmicRay: it's the same as: do x <- getTables; elem "stock" x
09:09:39 <CosmicRay> bin/sqlite is not the same as sending it queries through its API
09:09:41 <quicksilver> so it's definitely getting into that code
09:09:56 <ventonegro> quicksilver: yes, createTables is called
09:10:10 <CosmicRay> ventonegro: maybe you have comments in that file that are interpreted differently by the C api
09:10:18 <CosmicRay> run takes *ONE* query
09:10:31 <CosmicRay> if you are giving it more than one query, it is up to sqlite to interpret it, and who knows what it will do
09:11:03 <CosmicRay> sjanssen: surely you mean more like getTables con >>= (return . elem stock $ x) ?
09:11:17 <ventonegro> CosmicRay: i use it the same way from the C interface
09:11:18 <sjanssen> CosmicRay: yeah, I missed the return
09:11:43 <CosmicRay> ventonegro: once again.  make the problem as simple as possible.  reduce all possible complexity.
09:12:05 <CosmicRay> maybe you are doing something special from the C interface to make it work, who knows
09:14:03 <fasta> What's the worst case complexity of inserting(and doing the other operations like lookup and delete) n elements in a dynamic hashtable in the most efficient way currently known?
09:14:47 <Pastorn> ?src concatMap
09:14:47 <lambdabot> concatMap f = foldr ((++) . f) []
09:14:55 <sjanssen> fasta: if your hash is perfect, it should be O(n) to insert n elements
09:15:03 <mux> fasta: it depends on the average length of the collision chains
09:15:18 <mux> if your hash is perfect, indeed every insertion/deletion is O(1)
09:15:32 <mux> otherwise it's O(m) with m being t he length of the collision chain
09:15:36 <fasta> mux: ok, in other words: is there a general algorithm which achieves a perfect hash always?
09:15:36 <quicksilver> O(n log n) is an acheivable (amortised) upper bound, if you get an 'average number' of collisions, I think
09:15:45 <quicksilver> fasta: only if all data is known in advance
09:15:46 <mux> fasta: no
09:15:47 <quicksilver> (all keys)
09:15:54 <mux> but it's not ONE algorithm
09:16:09 <mux> if you know the data by advance, you can use gperf to generate a perfect hashing function
09:16:23 <quicksilver> in O(n log n) you have time to do allocations as well
09:16:25 <mux> though I've never used it myself
09:16:30 <fasta> Ok, and what's the best if I don't know the data in advance and only know a range?
09:16:34 <sjanssen> fasta: there is no perfect hash (see pigeonhole principle)
09:16:36 <quicksilver> otherwise even with a perfect hash, you need to know the quantity of data
09:16:37 <mux> fasta: depends on the data
09:16:57 <mux> you wouldn't use the same function to hash strings that are usernames, than to hash, err, IPs for instance, etc
09:17:06 <sjanssen> fasta: how big is your range?
09:17:14 <mux> it all depends on your data
09:17:24 <fasta> sjanssen: the range is about as large as the data.
09:18:10 <quicksilver> of course O(n log n) is a pretty big space and there are plenty of other things you can do in that space
09:18:19 <quicksilver> includign some which are more suited to functional languages :)
09:18:32 <mux> in some cases you would use quadratic rehashing too
09:18:41 <mux> in other cases you'd use multi-level hash tables
09:18:46 <mux> sparse hash tables, etc
09:19:00 <mux> each problem its hash table design ;-)
09:24:30 <fasta> I thought that I read somewhere that a sequence of n operations on a hashtable takes amortized O(n), but I suppose that's incorrect?
09:25:02 <quicksilver> that's true under some assumption about how often collisions take
09:25:04 <sjanssen> fasta: in good cases, probably
09:25:10 <quicksilver> and some other assumptions about how you handle reallocations
09:25:16 <quicksilver> (and how expensive a reallocation is)
09:25:40 <quicksilver> I'm damned if I can remember all the assumptions, though :)
09:26:16 <fasta> quicksilver: well, I am interested in those, of course. :)
09:27:38 <fasta> http://www.cs.berkeley.edu/~jrs/61b/lec/38 <- that is overly simplified
09:28:14 <fasta> Assume that the
09:28:14 <fasta> chains don't grow longer than O(1), and any operation that doesn't resize the
09:28:17 <fasta> table takes O(1) time--more precisely, suppose it takes at most one second."
09:28:25 <fasta> That's the whole point.
09:29:32 <sjanssen> fasta: you should just use Data.IntMap -- I can guarantee insertion, deletion, and search are O(1) in all cases
09:29:34 <ventonegro> @type ($!)
09:29:36 <lambdabot> forall a b. (a -> b) -> a -> b
09:29:53 <sjanssen> though the argument that says they're O(1) is a little shaky
09:30:23 <fasta> sjanssen: The O(1) increases with word size, IIRC.
09:30:32 <sjanssen> right
09:30:44 <sjanssen> it's only O(1) because Int has finite bits
09:30:57 <fasta> yes
09:31:19 <quicksilver> sjanssen: does the reallocation still amortize down to O(1) when the table gets grown?
09:31:36 <sjanssen> quicksilver: IntMap is a binary tree, not a table
09:31:38 <fasta> Can we conclude from this that the analysis of algorithms that use hashing are probably shaky in general?
09:32:04 <quicksilver> fasta: no, we conclude that there are a relatively small number of people who really understand this and bother to write out the details
09:32:24 <fasta> quicksilver: right
09:32:30 <bos> algorithm analysis is generally questionable. most of the people who write analyses are analysing the compexity of their own algorithms, and have an axe to grind.
09:32:43 <quicksilver> I'm sure there are some good analyses around, though
09:34:28 <bos> @users
09:34:28 <lambdabot> Maximum users seen in #haskell: 339, currently: 331 (97.6%), active: 51 (15.4%)
09:34:35 <bos> woo.
09:35:39 <vincenz> fmap "lambdacookie" $ join 331
09:35:58 <vincenz> > fmap (const "lambdacookie") $ join 331
09:35:58 <notsmack> "./darcs-all --extra get" isn't getting the extra packages
09:35:59 <lambdabot>   add an instance declaration for (Show (m [Char]))
09:36:27 <vincenz> > fmap (const "lambdacookie") $ join replicate 331
09:36:28 <lambdabot>  ["lambdacookie","lambdacookie","lambdacookie","lambdacookie","lambdacookie",...
09:37:29 <fasta> Knuts claims in the final sentence of the part on hashing that some people made a data structure with all operations amortized O(1)
09:37:52 <fasta> So, apparantly it is possible just not "popular".
09:39:07 <sjanssen> is it actually possible?
09:39:16 <kolmodin> ?seen dons
09:39:17 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3h 50m 2s ago.
09:39:26 <kolmodin> ?localtime dons
09:39:28 <lambdabot> Local time for dons is Wed Mar  7 04:36:42 2007
09:39:29 <sjanssen> couldn't one generate a bunch of data that hashes to the same value?
09:39:30 <kolmodin> mm
09:39:49 <fasta> Apparently*
09:39:55 <kolmodin> I'm looking for a syntax highlight for vim that highlights spaces at the end of the line.
09:39:56 <dcoutts_> @arr
09:39:57 <lambdabot> I'll crush ye barnacles!
09:39:57 <dcoutts_> any windows user want to try out my Gtk2Hs app deployment demo?
09:40:12 <dcoutts_> http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
09:40:13 <kolmodin> Igloo: ^^ you had something too?
09:41:38 <alec> notsmack: is your /bin/sh not bash?  I just had a similar problem and sent in a patch
09:41:42 <Igloo> I just do :set hls and then search for space
09:41:46 <Igloo> Nothing permanent
09:41:53 <kolmodin> Igloo: ah, ok
09:42:08 <kolmodin> dons highlighted them in red, so you notice right away
09:42:15 <Igloo> I think dons has something, or it should be a trivial synhl file which imports the normal haskell one
09:42:15 <kolmodin> which I find cunning
09:43:35 <sjanssen> dcoutts_: it works on the lab machine I'm sitting next to
09:43:44 <fasta> sjanssen: http://wwwcs.uni-paderborn.de/fachbereich/AG/agmadh/PapersPostscript/DynamicPerfHashing_SICOMP.ps
09:43:47 <lambdabot> http://tinyurl.com/2byz2m
09:44:00 <fasta> sjanssen: this is where Knuth references to. I haven't read it yet.
09:44:09 <shapr> yarr!
09:44:26 <sjanssen> dcoutts_: the machine is pretty much naked (no ghc, gtk)
09:45:14 <ndm> dcoutts_, neato, works perfectly!
09:45:48 <ndm> dcoutts_ - ah, but the generated shortcut in the start menu is wrong
09:46:45 <ndm> dcoutts_ - points at C:\Program Files\LSystem\LSystem.exe, when the file is under bin
10:01:42 <Baughn> @hoogle [a] -> a -> [[a]]
10:01:43 <lambdabot> No matches, try a more general search
10:02:49 <Baughn> ..fnord. Does "find all sublists of a given list that start with a given element" sound reasonable?
10:03:27 <Baughn> Something like strchr "abcaada" 'a' = ["abcaada","aada","ada","a"]
10:03:58 <ToRA> any gtk2hs people around?
10:05:41 <notsmack> alec: nope, bash
10:06:14 <ToRA> or is dcoutts around?
10:06:17 <sjanssen> > filter (\xs -> case xs of [] -> False; (x:_) -> x == 'a') (tails "abcaada")
10:06:18 <lambdabot>  ["abcaada","aada","ada","a"]
10:06:32 <sjanssen> next? :)
10:06:42 <Baughn> sjanssen: I was thinking of something in Data.List, maybe. ;)
10:06:51 <Baughn> Looks useful enough to be in there
10:06:53 <sjanssen> Baughn: there isn't such an existing function
10:07:03 <sjanssen> there is isPrefixOf
10:07:47 <sjanssen> > filter ("a" `isPrefixOf`) (tails "abcaada")
10:07:49 <quicksilver> > (\l -> [ x:xs | (x:xs) <- l,x == 'a']) (tails "abcaada")
10:07:49 <lambdabot>  ["abcaada","aada","ada","a"]
10:07:50 <lambdabot>  ["abcaada","aada","ada","a"]
10:08:07 <sjanssen> there, that's practically too short to put in the standard libs
10:08:08 <quicksilver> > (\l -> [ x:xs | (x:xs) <- tails l,x == 'a']) ("abcaada")
10:08:10 <lambdabot>  ["abcaada","aada","ada","a"]
10:08:35 <quicksilver> pattern match + list monad (comprehension) is slightly conciser than having to case against [] explicitly
10:08:55 <Saizan> > (\l -> [ x:xs | ('a':xs) <- tails l]) "abcaada"
10:08:56 <lambdabot>   Not in scope: `x'
10:09:05 <Saizan> > (\l -> [ 'a':xs | ('a':xs) <- tails l]) "abcaada"
10:09:06 <lambdabot>  ["abcaada","aada","ada","a"]
10:09:21 * quicksilver nods
10:09:46 <sjanssen> > (\l -> [ xs | xs@('a':_) <- tails l]) "abcaada" -- better sharing
10:09:48 <lambdabot>  ["abcaada","aada","ada","a"]
10:10:07 <quicksilver> good point
10:19:32 <shapr> Man, I hope musasabi is okay.
10:19:37 * shapr hugs bringert_
10:19:51 <chessguy> what's going on with musasabi
10:19:54 <shapr> bringert_: Er, as long as that doesn't make your wife jealous
10:20:08 <shapr> chessguy: No clue, just haven't heard anything from him for weeks.
10:20:18 <Pastorn> foldl is faster than foldr, right?
10:20:19 <bringert> shapr: I think she's ok with it
10:20:24 <shapr> bringert: good to hear :-)
10:20:35 * shapr laughs
10:20:36 <bringert> shapr: especially now that you have cut your hair
10:20:40 * shapr laughs more
10:20:52 <bringert> why the hug, btw?
10:21:02 <pejo> shapr, did you have to cut your hair to get the job?
10:21:22 <sjanssen> Pastorn: depends on which function you're folding
10:21:31 <shapr> bringert: I'm happy to see you, and the great code you've written over the years has long term happiness benefits for me. So I figure you deserve at least some positive returns.
10:21:32 <cddar> any command in ghci for getting infix operator priorities?
10:21:47 <shapr> bringert: It's like, hugs for happy code or something.
10:22:05 <shapr> pejo: Nah, I cut my hair to try to get a employment here in Alabama. Didn't really work though.
10:22:40 <bringert> shapr: thanks
10:22:49 <Pastorn> sjanssen: max (sorta)
10:22:54 * bringert thinks #haskell should give shapr a collective hug
10:23:03 * bringert hugs shapr
10:23:05 <shapr> pejo: It's hard to describe how different I am from the average corporate programmer.
10:23:07 * shapr cheers!
10:23:54 <sjanssen> > foldl (||) False (repeat True)
10:23:58 <lambdabot> Terminated
10:24:16 <sjanssen> > foldr (||) False (repeat True) -- foldr is infinitely faster here!
10:24:17 <lambdabot>  True
10:24:26 <shapr> pejo: I did have a corporate programmer job for a year. It paid well but I had trouble fitting into the community, especially because there wasn't really one. It seems that corps hold onto their knowledge like misers, thinking that will make them un-fireable.
10:24:30 <sjanssen> Pastorn: but for max, foldl is probably the best choice
10:24:37 <Pastorn> thanks :)
10:25:27 <pejo> shapr, which is just silly, of course. But yeah.
10:25:59 <sciolizer> Greetings. Does anybody have experience with hat?
10:26:08 <shapr> I have a hat!
10:26:10 <chessguy> sciolizer, sorry, i don't usually wear hats
10:26:17 * chessguy giggles at shapr 
10:26:21 <shapr> sciolizer: But seriously, I think ndm is writing a new version of hat.
10:26:36 <shapr> sciolizer: Did you have any specific questions?
10:26:45 <sciolizer> Yeah. Just a second.
10:26:46 * shapr throws a rook at chessguy 
10:26:58 * chessguy eats it
10:27:00 <hpaste>  sciolizer pasted "hat compilation troubles" at http://hpaste.org/823
10:27:05 <mux> bah, Jin sucks :-(
10:27:09 <mux> oops, wrong chan
10:27:11 <shapr> chessguy: Oh, that was the candy chess set?
10:27:15 <shapr> mux: Who's Jin?
10:27:19 <chessguy> Jin is a chess interface
10:27:23 <chessguy> what channel was that for?
10:27:24 <mux> it's a chess client for FICS
10:27:29 <shapr> oh
10:27:30 <chessguy> ICC too
10:27:32 <mux> that may sound weird, but ##FreeBSD
10:27:43 <mux> actually, this channel wasn't so bad a target for saying that
10:27:50 <mux> :-)
10:27:55 <shapr> sciolizer: Oh, you need bringert's Network.HTTP
10:27:57 <shapr> @where http
10:27:57 <lambdabot> http://www.haskell.org/http/
10:28:17 <sciolizer> shapr: Well, I have it installed. (debian dev package, unstable)
10:28:18 <mux> we desperately need a decent chess interface for UNIX, that is of course FICS capable
10:28:32 <dinounix> ,
10:28:46 <malcolmw> sciolizer: Hat does not actually have traced/debugging versions of all those extra packages (HTTP,hsql) available
10:28:49 <chessguy> jin isn't horrible
10:28:59 <chessguy> it's not desirable, but it's not horrible
10:29:19 <malcolmw> sciolizer: the lack of library support is one of Hat's biggest failings
10:29:20 <shapr> malcolmw: Didn't you write Hat?
10:29:29 <mux> at least it doesn't seem as prone to crashes than eboard is
10:29:41 <malcolmw> shapr: part of it, yes
10:29:42 <mux> but it lacks a lot of features
10:29:58 <sciolizer> malcolmw: Well, will it work with source (or does Network.HTTP use foreign C calls), or what's an alternative to hat?
10:30:22 <mux> chessguy: I'm hoping for something along the lines of BabasChess but for UNIX
10:30:31 <Pastorn> @pl \(a,b,c) (x,y,z) -> (a+x,b+y,c+z)
10:30:32 <lambdabot> (line 1, column 6):
10:30:32 <lambdabot> unexpected ","
10:30:32 <lambdabot> expecting letter or digit, operator or ")"
10:30:32 <lambdabot> ambiguous use of a non associative operator
10:30:33 <malcolmw> sciolizer: yes, so if you unpack all the source code for all the libraries into your build tree, then Hat _might_ work
10:30:34 <chessguy> i haven't seen that one
10:30:43 <Pastorn> @pl (\(a,b,c) (x,y,z) -> (a+x,b+y,c+z))
10:30:44 <lambdabot> (line 1, column 7):
10:30:44 <lambdabot> unexpected ","
10:30:44 <lambdabot> expecting letter or digit, operator or ")"
10:30:44 <lambdabot> ambiguous use of a non associative operator
10:30:45 <shapr> malcolmw: Oh hey! HAppS does a lot of ToElement and FromMessage stuff that's just casting a Haskell value to and from XML, and I think a single XmlContent definition would fix that, right? If so, is there an XmlContent tutorial in the latest version of HaXml?
10:30:51 <mux> bonus if it's GTK+ based
10:31:00 <sciolizer> malcolmw: Ok, I'll give it a shot.
10:31:10 <mux> chessguy: if I had more free time, I think I'd start writing one in Haskell with Gtk2Hs
10:31:33 <malcolmw> sciolizer: I can predict that something is likely to break pretty quickly, so don't spend too much effort on it
10:31:33 <chessguy> that'd be cool
10:31:35 <Pastorn> @pl (\(a,b,c) (x,y,z) -> (a+b+c, x+y+z))
10:31:35 <lambdabot> (line 1, column 7):
10:31:36 <lambdabot> unexpected ","
10:31:36 <lambdabot> expecting letter or digit, operator or ")"
10:31:36 <lambdabot> ambiguous use of a non associative operator
10:31:37 <shapr> Most libs I've seen are still using the pre-XmlContent HaXml.
10:31:40 <sciolizer> malcolmw: ok
10:31:57 <Pastorn> what's wrong? i can't see it.... :(
10:31:57 <shapr> Yay, new stable release of HAppS is just out!
10:32:12 <mux> shapr: what's hot in this release?
10:32:46 <malcolmw> There does exist a plan for doing libraries transparently with Hat, but unfortunately it requires a good couple of weeks solid work, which  I don't have available.
10:32:55 <vegai> shapr: whoa!
10:33:11 <shapr> mux: Huge changes in 0.8.8. So much that it's hard to summarize. glguy joined the HAppS team and he's done lots of good stuff.
10:33:31 <mux> cool, glad to hear that :)
10:33:35 <malcolmw> shapr: the dev version of HaXml is still in flux.  likely to be more API changes before it becomes stable
10:33:36 <shapr> The other active HAppS team members at the moment are Lemmih and me. And of course, alexj is leading the project.
10:34:06 <shapr> I think XmlContent would save a lot of boilerplate code in HAppS.
10:34:25 <malcolmw> shapr: re:boilerplate, yes
10:34:29 <shapr> It'd save even more if it could be derived.
10:35:00 <mux> I've had issues with XmlContent in the past, IIRC it was hard to make it output the haskell structures I really wanted
10:35:10 <sciolizer> malcolmw: it seems to have worked
10:35:16 <conal> shapr:  i want to hook up TV and HAppS to do something cool.  TV works with any arrow, so I'm thinking Kleisli MACID.
10:35:25 <malcolmw> shapr: unfortunately tutorial type material is something HaXml desperately needs, and it's another thing i don't have the time to create
10:35:43 <Pastorn> @pl flip . $
10:35:44 <lambdabot> (line 1, column 8):
10:35:44 <lambdabot> unexpected "$"
10:35:44 <lambdabot> expecting space or simple term
10:36:07 <Pastorn> @pl flip $
10:36:08 <lambdabot> (line 1, column 7):
10:36:08 <lambdabot> unexpected end of input
10:36:08 <lambdabot> expecting white space or simple term
10:36:12 <shapr> malcolmw: If the API stabilizes such that HAppS can start using XmlContent, I'll write the tutorial.
10:36:19 <shapr> I'm Mr Tutorial for HAppS.
10:36:24 * mux wonders if BabasChess would work within wine
10:36:48 <Pastorn> is there any way to "turn" $ so that the right hand side is "calculated" first?
10:36:55 <malcolmw> shapr: the XmlContent stuff is probably stable enough now
10:37:05 <shapr> conal: That sounds cool, but I have no idea what it would do, can you tell me more?
10:37:07 <Pastorn> *left hand side
10:37:14 <allbery_b> :t flip ($)
10:37:17 <lambdabot> forall a b. a -> (a -> b) -> b
10:37:20 <Pastorn> danm
10:37:29 <Pastorn> thanks :)
10:37:35 <shapr> malcolmw: Ok, I'll grab it and try it.
10:37:47 <malcolmw> shapr: but there is one nasty corner of it that still needs attention (automatic generation of a DTD for any arbitrary value)
10:38:01 <malcolmw> but maybe no-one uses DTDs these days
10:38:17 <shapr> I remember Simon Foster working on that, wasn't it pretty hard to do? Or am I thinking of Relax-NG or Xml Schemas or something?
10:38:27 <mux> malcolmw: is it possible to do SAX-like parsing or any kind of event-based parsing so that we can handle very large XML files with HaXml ?
10:38:28 <shapr> I know it was stuff he was doing with HAIFA and CASHEW.
10:38:41 <malcolmw> shapr: Simon did a Schema -> haskell mapping I think
10:39:04 <malcolmw> mux: Text.XML.HaXml.SAX :-)
10:39:11 <conal> shapr: i don't know what it would do either.  TV is about declarative "interfaces" to pure values (including functions).  So far, I'm using GUIs and IO as two different interface styles, built with a common vocabulary.
10:39:14 <mux> eww, hot!
10:39:21 * mux goes to check this
10:39:30 <shapr> Oh hey, I'm on the committee for Commercial Users of Functional Programming 2007, does anyone have any suggestions for people to contact?
10:39:33 <conal> shapr: maybe HAppS would be a dandy way to do some kind of remote interfaces.
10:39:43 <malcolmw> mux: also, dev version of HaXml has a lazy parser for standard XML docs
10:40:11 <conal> btw, TV is described at http://haskell.org/haskellwiki/TV
10:40:12 <lambdabot> Title: TV - HaskellWiki
10:40:25 <mux> malcolmw: I do not find this module on the haddock interface, not there yet?
10:40:39 <shapr> conal: Oh that'll probably help, I'll read it.
10:40:56 <conal> shapr: cool.  :)
10:41:06 <malcolmw> mux: http://www.cs.york.ac.uk/fp/HaXml-devel/
10:41:07 <lambdabot> Title: HaXml: Haskell and XML
10:41:24 <mux> malcolmw: thank you!
10:41:57 * mux drops a tear
10:41:59 <mux> this is great
10:42:08 <conal> shapr: in a sense, TV is a generalization of "interact", adding compositionality and interface types other than IO
10:42:36 <conal> and interact is easily composable out of simpler pieces
10:43:04 <shapr> conal: Could you hook this up to HOpenGL and make something like http://www.alice.org/ ?
10:43:07 <lambdabot> Title: Alice: Free, Easy, Interactive 3D Graphics for the WWW
10:43:14 * malcolmw -> home
10:43:45 <mux> I want someone to implement DOM bindings for Haskell as a plugin for both IE and Mozilla, ok plz thanks
10:43:49 <mux> :-)
10:43:59 <shapr> conal: Can the values modify themselves?
10:44:34 <conal> shapr: about alice: yes, and with a totally different take, as it would be functional.
10:44:40 <conal> shapr: modify themselves???
10:44:53 <conal> shapr: like piercings?
10:45:00 <shapr> piercings?
10:45:11 <chessguy> ?hoogle lookup
10:45:12 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
10:45:14 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
10:45:14 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
10:45:19 <chessguy> ?src lookup
10:45:20 <lambdabot> lookup _key []          =  Nothing
10:45:21 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
10:45:21 <lambdabot>                         | otherwise = lookup key xys
10:46:21 <conal> shapr: http://www.bodymod.org/home.asp .  but maybe that's not what you mean by "modify themselves"
10:46:25 <lambdabot> Title: BodyMod.org - The Official Body Modification Organization
10:46:27 * shapr laughs
10:46:41 <shapr> I guess I was thinking more like transistors.
10:47:07 <araujo> hola shapr
10:47:17 <shapr> Could you use TV to graphically model circuits?
10:47:30 <shapr> hola araujo, como est as?
10:48:30 <araujo> shapr, muy bien y tu? :-)
10:48:42 * araujo wonders if shapr knows c2hs
10:48:52 <conal> shapr: hm.  i don't know how circuit modeling might fit.  but maybe rendering/visualizing circuits.
10:49:32 <mux> cool, topalov vs svidler on FICS
10:52:29 <chessguy> blitz? or part of the tourney going on
10:53:10 <chessguy> ah yes, linares
10:53:33 <mux> I guess there are relay problems though
10:53:34 <chessguy> Carlsen is showing up big this year
10:54:18 <mux> okay, the game is over, it's a draw
10:54:56 <Pastorn> @pl (\(x0,y0) (x1,y1) (x2,y2) (x3,y3) -> (min (min x0 x1) (min x2 x3), max (max x0 x1) (max x2 x3)))
10:55:00 <lambdabot> flip ap snd . (. fst) . (const .) . flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . flip flip snd . (flip .) . ((ap .) .) . flip flip fst . (flip .) . (((.) .) .) . (((const .) .) .)
10:55:00 <lambdabot>  . ap (ap . (ap .) . ((ap .) .) . ((((,) .) .) .) . flip flip min . ((.) .) . ((.) .) . (min .) . min) (flip flip max . ((.) .) . ((.) .) . (max .) . max) . fst
10:55:00 <lambdabot> optimization suspended, use @pl-resume to continue.
10:55:04 <Pastorn> yay!!
10:55:14 <mux> hahah, Pastorn hacked LB
10:55:31 * Pastorn isn't done yet...
10:56:35 <mux> chessguy: I watched the end of Topalov - Leko the other day, it was good :)
10:56:46 <chessguy> Muad_Dib, i haven't been following it
10:56:51 <chessguy> err, mux
10:57:08 * Muad_Dib looks around sleepily
10:57:19 <chessguy> Muad_Dib, sorry, go back to sleep
10:57:31 <chessguy> @pl-resume
10:57:38 <chessguy> @bot
10:57:38 <lambdabot> flip ap snd . (. fst) . (const .) . flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . (((.) . (const .)) .)) .) . ap (ap
10:57:38 <lambdabot> . ((ap . (ap .)) .) . ((((,) .) .) .) . flip flip min . ((.) .) . ((.) .) . (min .) . min) (flip flip max . ((.) .) . ((.) .) . (max .) . max) . fst
10:57:38 <lambdabot> optimization suspended, use @pl-resume to continue.
10:57:38 <lambdabot> :)
10:57:46 <chessguy> wow
10:58:23 <Muad_Dib> np chessguy ;)
10:59:23 <vincenz> chessguy: two more times
10:59:29 <vincenz> nm
11:00:04 <Pastorn> f (x0,y0) (x1,y1) (x2,y2) (x3,y3) = ((lowest x, lowest y), (highest x, highest y))
11:00:10 <Pastorn> @pl (\(x0,y0) (x1,y1) (x2,y2) (x3,y3) -> (min (min x0 x1) (min x2 x3), min (min y0 y1) (min y2 y3)) , (max (max x0 x1) (max x2 x3), max (max y0 y1) (max y2 y3))))
11:00:10 <lambdabot> (line 1, column 158):
11:00:11 <lambdabot> unexpected ")"
11:00:11 <lambdabot> expecting variable, "(", operator or end of input
11:00:14 <Pastorn> fuck
11:01:42 <Pastorn> @pl (\(x0,y0) (x1,y1) (x2,y2) (x3,y3) -> (min (min x0 x1) (min x2 x3), min (min y0 y1) (min y2 y3)) , (max (max x0 x1) (max x2 x3), max (max y0 y1) (max y2 y3)))
11:01:46 <lambdabot> (ap (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . (flip .) . ((flip .) .) . (((ap .) .) .) . flip flip fst . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip (flip . (flip .) .
11:01:46 <lambdabot> ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((((((.) .) .) .) .) .) . flip ((.)
11:01:46 <lambdabot> . flip . ((.) .) . (flip .) . (((.) .) .) . ((flip .) .) . ((((.) .) .) .) . ((((,) .) .) .) . flip (flip . ((.) .) . ((.) .) . (min .) . min) min) (flip (flip . ((.) .) . ((.) .) . (min .) . min)
11:01:46 <lambdabot> min)) fst) snd . fst) snd, (max (max x0 x1) (max x2 x3), max (max y0 y1) (max y2 y3)))
11:01:48 <lambdabot> optimization suspended, use @pl-resume to continue.
11:01:56 <Pastorn> @pl-resume
11:02:02 <lambdabot> (ap (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . (flip .) . ((flip .) .) . (((ap .) .) .) . flip flip fst . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip flip snd . (flip .)
11:02:03 <lambdabot>  . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip flip fst . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((((((.) .) .) .) .) .) . (.
11:02:03 <lambdabot> flip (flip . ((.) .) . ((.) .) . (min .) . min) min) . flip . ((.) .) . (flip .) . (((.) .) .) . ((flip .) .) . ((((.) .) .) .) . ((((,) .) .) .) . flip flip min . ((.) .) . ((.) .) . (min .) . min .
11:02:03 <lambdabot>  fst) snd, (max (max x0 x1) (max x2 x3), max (max y0 y1) (max y2 y3)))
11:02:04 <lambdabot> optimization suspended, use @pl-resume to continue.
11:02:06 <Pastorn> @pl-resume
11:02:12 <vincenz> Pastorn: stop please?
11:02:15 <vincenz> Pastorn: priv-msg lambdabot
11:02:19 <lambdabot> (ap (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . (flip .)) .) . ((((.) .) .) .) . flip flip snd . (flip .) . ((flip
11:02:19 <lambdabot> .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip flip fst . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((((((.) .) .) .) .) .) . (. flip (flip
11:02:19 <lambdabot> . ((.) .) . ((.) .) . (min .) . min) min) . flip . ((.) .) . (flip .) . (((.) .) .) . ((flip .) .) . ((((.) .) .) .) . ((((,) .) .) .) . flip flip min . ((.) .) . ((.) .) . (min .) . min . fst) snd,
11:02:19 <lambdabot> (max (max x0 x1) (max x2 x3), max (max y0 y1) (max y2 y3)))
11:02:20 <lambdabot> optimization suspended, use @pl-resume to continue.
11:02:37 <Pastorn> vincenz: good idea :)
11:02:43 <vincenz> :)
11:03:44 <conal> that pl output looks like a mess to me on first glance.  but i wonder if there's some hidden regularity/beauty.
11:03:56 <Pastorn> who wrote @pl?
11:04:07 <chessguy> i suspect dons
11:04:24 <dmwit> Miss Green, in the Library, with a Pipe.
11:04:30 <Pastorn> YAY!!!! "Plugin `pl' failed with: IRCRaised thread killed"
11:04:59 <int-e> @bot
11:04:59 <lambdabot> :)
11:05:00 <conal> Pastorm: nervous breakdown perhaps
11:05:09 <Pastorn> something like that...
11:05:39 <Pastorn> maybe I should remove the pausing-case in lambdabots source and do that myself
11:09:40 <astrolabe> I suppose the output must be regular.  It seems unlikely to be chaotic.
11:09:57 <kaol> > let fibs = 1: zipWith (+) fibs (tail fibs) in fibs -- I just want to see what happens
11:09:59 <lambdabot>  Exception: <<loop>>
11:10:19 <vegai> she ain't no fool
11:10:45 <dmwit> > let fibs = 1: 1:zipWith (+) fibs (tail fibs) in fibs
11:10:47 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:11:12 <kaol> stop abusing them rabbits
11:11:21 <dmwit> =)
11:11:53 <nmessenger> > fix $ (1:) . (1:) . ap (zipWith (+)) tail
11:11:54 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:12:09 <dmwit> :t fix
11:12:11 <lambdabot> forall a. (a -> a) -> a
11:16:58 <mux> hah, the comments in the GHC docs about reading Core syntax are hilarious
11:19:10 <mux> ("It's just a simple functional language" is an unregisterised trademark of Peyton Jones Enterprises, plc.)
11:20:04 <quicksilver> Pastorn: pl wasn't written by dons, no
11:20:15 <quicksilver> Pastorn: it was written by someone who apparently doesn't IRC any more
11:20:22 <Pastorn> hehe
11:20:33 <sjanssen> TheHunter, I believe
11:21:01 <xerox> Yup.
11:22:29 <monochrom> Haha mux
11:23:36 <monochrom> Haha monadocracy
11:24:11 <kolmodin> any one on an intel mac? http://www.dsek.lth.se/navigation/blogs.php?blog=20061101/0xFFFF1600
11:24:14 <lambdabot> Title: Blogg, http://tinyurl.com/3dcym5
11:24:14 <mux> The `number' is printed fairly compactly in a `base-62' format, which everyone hates except me (WDP).
11:24:52 <monochrom> base-62 is a bit weird, but ok.
11:25:01 * Zeroth|work is NOT going to change his clocks this weekend, or *ever* for that matter.
11:25:11 <monochrom> haha
11:26:01 <xerox> kolmodin: what does that mean?
11:26:03 <sjanssen> kolmodin: what exactly does that do?
11:26:47 <pejo> kolmodin, haha - funny one.
11:27:17 <xerox> Funny?
11:27:57 <dmwit> > ord 22
11:27:58 <lambdabot>   add an instance declaration for (Num Char)
11:28:05 <dmwit> > chr 22
11:28:06 <lambdabot>  '\SYN'
11:28:16 <dmwit>  '\ACK'
11:28:42 <dmwit> > chr 255
11:28:43 <lambdabot>  '\255'
11:29:48 <stmartin> What support is there in Haskell (GHC or Hugs in particular) for easy memoization?
11:30:03 <mbishop> uh oh
11:30:16 <Pastorn> @paste
11:30:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:30:24 <mbishop> [vincenz] has become multiple vincenz's
11:30:24 <sjanssen> stmartin: you have to do it manually
11:31:15 <stmartin> What!? Eww. Why? Even Perl allows me to wrap a function call in memoize() and be done with it.
11:31:39 <pjd> stmartin: i think that's what counts as doing it manually
11:32:15 <quicksilver> @src sort
11:32:15 <lambdabot> sort = sortBy compare
11:32:20 <quicksilver> @sort sortBy
11:32:21 <lambdabot> Maybe you meant: more part src
11:32:27 <quicksilver> @src sortBy
11:32:28 <sjanssen> stmartin: there are plenty of nice ways to write a wrapper
11:32:29 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:32:32 <stmartin> pjd: Oh, I see. I was worried it might look like the horrid sort of thing I saw in Craft2e
11:32:46 <quicksilver> ah interesting. Insertion sort.
11:32:48 <sjanssen> I've written a memoization monad, for example
11:33:08 <fantasma> @pl \x -> map sum . map digitToInt . map show $ x
11:33:08 <lambdabot> map (sum . digitToInt . show)
11:34:21 <nmessenger> @source Data.List
11:34:22 <quicksilver> wow. @pl knows that map is distributive
11:34:22 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
11:34:26 <nmessenger> ^^ not in the actual implementation, quicksilver
11:34:26 <quicksilver> neat trick
11:34:38 <kolmodin> xerox, sjanssen: it says, compile it on your intel mac and find out what apple thinks of software piracy
11:34:59 <kolmodin> naturally, I'm curious :)
11:35:05 <kolmodin> but don't have a mac
11:35:15 <kolmodin> hia waern !
11:35:18 <psi`> it's a poem, right?
11:35:18 <pejo> !paste
11:35:19 <hpaste> Haskell paste bin: http://hpaste.org/
11:35:27 <waern> hi kolmo!
11:35:32 <fantasma> :t digitToInt
11:35:33 <kolmodin> waern: how's code?
11:35:34 <lambdabot> Char -> Int
11:35:39 <fantasma> :t map (digitToInt . show) [12,45,67,3,23]
11:35:41 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
11:35:42 <lambdabot>     In the second argument of `(.)', namely `show'
11:35:44 <quicksilver> nmessenger: ah, it's a merge
11:35:45 <waern> kolmodin, sent a new Cabal patch yesterday
11:35:46 <sjanssen> stmartin: another nice example: http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo
11:35:48 <kolmodin> waern: yay
11:35:49 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/u45vz
11:36:07 <hpaste>  pejo pasted "(Spoiler) Kolmodins mac-thing." at http://hpaste.org/825
11:36:12 <xerox> > map (map intToDigit . show) [12,45,67,3,23]
11:36:13 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
11:36:24 <xerox> > map (map digitToInt . show) [12,45,67,3,23]
11:36:26 <lambdabot>  [[1,2],[4,5],[6,7],[3],[2,3]]
11:36:30 <waern> kolmodin, how's your code?
11:36:55 <hpaste>  Pastorn pasted "Which one is the fastest?" at http://hpaste.org/826
11:37:27 <kolmodin> waern: I have good progress with the pure haskell dbus client
11:37:43 <waern> kolmodin, ok nice
11:37:55 <fantasma> @pl \x -> map (map (sum . digitToInt . show)) $ x
11:37:55 <lambdabot> map (map (sum . digitToInt . show))
11:37:57 <sjanssen> Pastorn: the difference is negligible
11:38:00 <kolmodin> just figured out what I did wrong with receiving messages
11:38:08 <kolmodin> obviously I was very tired last night :)
11:38:19 <Pastorn> sjanssen: which one is nicest to look at?
11:38:49 <chessguy> Pastorn,  i'd prefer the first
11:39:00 <sjanssen> Pastorn: the first
11:39:05 <waern> kolmodin, gonna watch inter - valencia now
11:39:06 <Pastorn> ok :)
11:39:13 <Pastorn> thanks
11:39:13 <kolmodin> waern: eum... ok
11:39:17 <kolmodin> :)
11:39:33 <waern> you don't like football?
11:39:51 <Zeroth|work> football is highly over-rated
11:39:59 <Zeroth|work> programmign is hughly under-rated
11:40:15 <kolmodin> Zeroth|work: that's the truth of the day
11:40:23 <kolmodin> waern: not really
11:40:37 <Zeroth|work> I'd take chess over football anyday
11:40:46 * allbery_b watching liverpool - barÃ§a :)
11:40:52 <chessguy> hear, hear
11:41:02 <kolmodin> it all depends on the friends you watch it with, and the beer, but I wouldnever watch it without those two
11:41:14 <Zeroth|work> why not friends beer and chess?
11:41:27 <Zeroth|work> nothing is more fun than intoxicated programming
11:41:35 <kolmodin> I'm not good at chess and beer doesn't make me better
11:41:37 <Pastorn> @google lambdabot source code
11:41:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/STYLE
11:41:45 <Zeroth|work> im no good at chess either, but its good for your brain
11:41:50 <chessguy> ?where lambdabot
11:41:51 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:41:51 <Zeroth|work> teaches you to not be so impulsive
11:41:57 <kolmodin> I bet it is, as is programming (I hope)
11:42:01 <kolmodin> ?quote kolmodin
11:42:02 <lambdabot> kolmodin says: it's nice to have static types after a bottle of wine
11:42:06 <kolmodin> ^^ see
11:42:17 <kolmodin> I was hoping for that quote :)
11:42:44 <chessguy> @quote wine
11:42:44 <lambdabot> kolmodin says: it's nice to have static types after a bottle of wine
11:42:47 <Pastorn> anyone know where in the source pl is?
11:42:52 <yip> kolmodin: hey
11:42:58 <chessguy> Pastorn, i bet grep does
11:43:08 <Pastorn> hehe
11:43:13 <kolmodin> yip: hey!
11:43:39 <yip> kolmodin: what do you think about adding inotify runtime detection to hinotify?
11:43:41 <kolmodin> yip: where do you live? we've managed to miss each other for quite some time
11:43:45 <kolmodin> ?localtime yip
11:43:47 <lambdabot> Local time for yip is Tue Mar 06 21:41:10
11:44:07 <kolmodin> oh, guess I'm just early off to bed :)
11:44:35 <kolmodin> yip: might be useful
11:45:10 <kolmodin> yip: you shouldn't install hinotify unless you have inotify though
11:45:15 <yip> kolmodin: this way you could even have the hinotify module available for all platforms
11:45:39 <yip> kolmodin: yeah but it would be good if your final program executable could run on all linux platforms, and enable optional features at runtime if inotify is available
11:45:40 <fantasma> > map sum . (map digitToInt . show) [123,32,57,24,958]
11:45:41 <lambdabot>  Couldn't match expected type `a -> [[a1]]'
11:45:48 <fantasma> :t sum
11:45:50 <lambdabot> forall a. (Num a) => [a] -> a
11:45:57 <waern> is it possible to emulate hinotify on other platforms? it would be a great haskell library
11:46:03 <kolmodin> I'd rather have an platform independent module to use, and having hinotify as one of the backends
11:46:04 <fantasma> > map sum . (map digitToInt . show) [123,32,57,24,958]
11:46:05 <lambdabot>  Couldn't match expected type `a -> [[a1]]'
11:46:17 <fantasma> > map (sum . (map digitToInt . show) [123,32,57,24,958])
11:46:18 <lambdabot>  Couldn't match expected type `a -> [a1]'
11:46:31 <kolmodin> waern: I think windows have some thing similar too
11:46:35 <yip> kolmodin: yeah, that sounds good, but in order to do that hinotify would need run-time detection, even if only for linux
11:46:47 <fantasma> @pl \x -> map (sum . (map digitToInt . show) x
11:46:47 <lambdabot> (line 1, column 43):
11:46:47 <lambdabot> unexpected end of input
11:46:47 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or ")"
11:47:08 <waern> kolmodin, ok. please code some kind of generalized hinotify lib that works on all platforms. :)
11:47:18 <kolmodin> yip: I think you should be able to detect that at compile time. possibly switch over to dnotify if inotify is missing
11:47:21 <fantasma> @pl \x -> map sum $ map (map digitToInt . show) x
11:47:21 <lambdabot> map (sum . map digitToInt . show)
11:47:30 <kolmodin> waern: hah, yeah :)
11:47:36 <kolmodin> waern: if you'll do the mac bit then
11:47:45 <fantasma> > map (sum . map digitToInt . show) [123,32,57,24,958]
11:47:47 <lambdabot>  [6,5,12,6,22]
11:47:57 <yip> kolmodin: but then you need to compile 2 versions of your program, instead of one
11:48:03 <kolmodin> I'm not too happy with the hinotify interface. I'll change it some day
11:48:17 <yip> kolmodin: hinotify api seems to work good for me
11:48:26 <kolmodin> yip: no. this should be at the library level.
11:48:38 <kolmodin> yip: oh, you're thinking for folks that don't compile their programs
11:48:48 <kolmodin> yip: I'm on gentoo.. :D
11:49:04 <kolmodin> yip: hmm. guess runtime detection would be useful
11:49:09 <kolmodin> I'll put it on my todo
11:49:32 <yip> this way you could have a single RPM for your program, and at runtime it will detect if inotify is available and if so enable file-monitoring features
11:50:01 <kolmodin> aye
11:50:07 <hpaste>  (anonymous) annotated "HAppS configure output..." with "(no title)" at http://hpaste.org/828#a1
11:50:32 <yip> and who knows... maybe some day bsd and windows will also have inotify support? this is why you could even have hinotify available on all platforms... just have it always fail the runtime test :)
11:50:53 <kolmodin> yip: ultimately, you'd want it to use inotify if possible, otherwise switch to dnotify or whatever
11:50:59 <mux> what's inotify?
11:51:26 <yip> kolmodin: well, sometimes file monitoring might only be one part of your application that isn't absolutely critical
11:51:41 <mux> file monitoring? we have that
11:51:45 <kolmodin> ?google inotify
11:51:47 <mux> through kqueue() and kevent()
11:51:47 <lambdabot> http://en.wikipedia.org/wiki/Inotify
11:51:50 <fantasma> > maximum $ map (sum . map digitToInt . show) [x^y | x <- [1..100], y <- [1..100]]
11:51:52 <lambdabot>  972
11:52:01 <fantasma> @karma+ lambdabot
11:52:01 <lambdabot> lambdabot's karma raised to 39.
11:52:04 <mux> but best is to use the more high-level library such as fam, or better, gamin
11:52:16 <mux> that way you get BSD support for free
11:52:25 <kolmodin> mux: on mac/bsd? great
11:52:39 <mux> check for mac, but bsd for sure :)
11:52:44 <yip> mux: last i heard fam didn't use inotify, it used dnotify
11:53:06 <kolmodin> yeah, fam is old
11:53:13 <mux> gamin is newer and preferred
11:53:20 <mux> I don't know what it uses for Linux
11:53:21 <kolmodin> aye
11:53:27 <fantasma> @karma+ *
11:53:27 <mux> but I know it uses kqueue for FreeBSD
11:53:27 <lambdabot> *'s karma raised to 1.
11:53:29 <mux> and that is good
11:53:31 <kolmodin> inotify, I bet
11:53:38 <fantasma> @karma- ChanServ
11:53:39 <lambdabot> ChanServ's karma lowered to -1.
11:53:46 <mux> because we've had kqueue much before Linux gained that kind of feature :-P
11:54:06 <yip> i think i read somewhere that gamin requires running a daemon
11:54:18 <kolmodin> yes yes. and beos has had it since the 1990s sometime. but we've got it now!
11:54:22 <mux> no, fam used to require RPC
11:54:27 <mux> gamin doesn't require a daemon
11:54:46 <mux> oops, my bad
11:54:47 <mux> it does :)
11:54:49 <mux> gam_server
11:55:05 <yip> yeah that kind of sucks eggs
11:55:14 <mux> maybe that's for supporting architectures where the kernel doesn't offer the monitoring features
11:55:22 <yip> best is a common api over inotify/kqueue/whatever-windows-has
11:55:30 <blackelf> @karma+ hitler
11:55:30 <lambdabot> hitler's karma raised to 1.
11:55:31 <mux> portability is good, though in that case it would indeed be nice if it could work without the server
11:55:32 <yip> and poll as a backup
11:55:38 <blackelf> wow that bot needs to be adjusted
11:55:42 <mux> in cases where it's possible
11:55:50 <mux> but maybe it does, you should check
11:56:32 <mux> also, if Linus wasn't an ass, everything would be great because at that point you Linux folks would have kqueue in the kernel :)
11:56:32 <yip> even if the kernel doesn't support monitoring, you can still do polling in a thread, instead of running some daemon
11:56:56 <yip> linux should have been forked ages ago :\
11:57:16 <blackelf> yip: into
11:57:30 <kolmodin> yip: yes, I'd prefer that backend as a backup
11:57:50 <yip> anyway i gotta go!
11:57:57 * yip is outta here
11:58:04 <mux> bye
11:58:17 <fantasma> @users please
11:58:18 <lambdabot> Maximum users seen in please: 1, currently: 0 (0.0%), active: 0 (NaN%)
11:58:24 <fantasma> @users
11:58:25 <lambdabot> Maximum users seen in #haskell: 339, currently: 334 (98.5%), active: 59 (17.7%)
11:58:29 <araujo> @index a -> Ptr a
11:58:30 <lambdabot> bzzt
11:58:30 <fantasma> @users debian
11:58:30 <lambdabot> Maximum users seen in debian: 1, currently: 0 (0.0%), active: 0 (NaN%)
11:58:43 <fantasma> bzzt
11:58:53 <kolmodin> yip: bye
11:58:55 <fantasma> > Just Nothing
11:58:56 <lambdabot>  Just Nothing
11:59:11 <fantasma> > Just Nothing And Just
11:59:12 <lambdabot>   Not in scope: data constructor `And'
11:59:32 <fantasma> i have to do spanish homework =\
11:59:56 <Igloo> I swear cabal is designed to make my life as hard as possible. Does anyone know how I can write a rule in make like   %.stamp: %/%.cabal    (%/*.cabal would do equally well)?
12:00:00 <Jaak> > join $ Just Nothing
12:00:01 <lambdabot>  Nothing
12:00:19 <quicksilver> is the Ord instance for ByteString pretty fast, does anyone know?
12:00:39 <fantasma> :t Ord
12:00:41 <lambdabot> Not in scope: data constructor `Ord'
12:00:52 <fantasma> :k Ord
12:00:55 <lambdabot> Class `Ord' used as a type
12:02:48 <norpan> quicksilver: i hope it's pretty fast
12:03:48 <quicksilver> norpan: doesn't seem to be haddock'ed, but you'd hope so
12:03:59 <norpan> it seems to use memcpm
12:04:01 <norpan> memcmp
12:04:11 <norpan> so it should be fast enough
12:04:41 <fantasma> does haskell curry ever stop by here?
12:05:08 <norpan> as in the person?
12:05:13 <fantasma> yah
12:05:20 <norpan> he's dead
12:05:24 <chessguy> i'd be pretty frightened if he did
12:05:43 <fantasma> @where haskell curry
12:05:44 <lambdabot> http://haskell.org
12:05:49 <Pastorn> when should either/Either be used and when should I use cases?
12:05:50 <cjay> I'm sure his spirit is with us :p
12:05:57 <chessguy> ?remember fantasma does haskell curry ever stop by here?
12:05:58 <lambdabot> Done.
12:06:06 <norpan> Pastorn: when you feel like it
12:06:21 <Pastorn> why was either created?
12:06:33 <norpan> because people felt like not using case
12:06:38 <Pastorn> hehe
12:06:47 <fantasma> ohhhh, the language was named after him
12:06:54 <Saizan> pointfree style maybe
12:06:56 <Zeroth|work> whats an easy way to calculat epi?
12:07:01 <Zeroth|work> pis/epi/
12:07:09 <Zeroth|work> ...    s/epi/pi
12:07:10 <Pastorn> fantasma: actually he never liked the name "Haskell"
12:07:18 <quicksilver> Pastorn: it's nice to equip data types with their natural functions
12:07:22 <fantasma> i like the name
12:07:29 <nmessenger> > pi :: Double -- easy :)
12:07:30 <lambdabot>  3.141592653589793
12:07:31 <quicksilver> Pastorn: I prefer 'maybe' to a case quite often too
12:07:34 <norpan> Zeroth|work: it all depends on what you mean by easy
12:07:44 <fantasma> > pi :: Float
12:07:45 <lambdabot>  3.1415927
12:07:50 <quicksilver> Pastorn: either and maybe can both be partially applied usefully, too
12:07:53 <Zeroth|work> norpan sort and efficient
12:07:55 <chessguy> :t 3
12:07:58 <lambdabot> forall t. (Num t) => t
12:07:59 <chessguy> :t e
12:08:01 <lambdabot> Not in scope: `e'
12:08:01 <chessguy> sigh
12:08:04 <chessguy> never mind
12:08:06 <Zeroth|work> > pi -- is this a calculation ot a constant?
12:08:07 <lambdabot>  3.141592653589793
12:08:12 <fantasma> :t phi
12:08:14 <lambdabot> Not in scope: `phi'
12:08:16 <quicksilver> :t either "Holy Mackerel, Batman! It went wrong!"
12:08:18 <lambdabot>     Couldn't match expected type `a -> c'
12:08:18 <lambdabot>            against inferred type `[Char]'
12:08:21 <chessguy> :t pi
12:08:23 <lambdabot> forall a. (Floating a) => a
12:08:25 <CosmicRay> I have this data type: data Opt = Verbose | S String         I have a list of Opts.  What is the easiest way to extract the first S if it exists, and give me some other code if it doesn't?
12:08:29 <nmessenger> Zeroth|work: it's a polymorphic constant :D
12:08:37 <quicksilver> :t either (const "Holy Mackerel, Batman! It went wrong!")
12:08:39 <lambdabot> forall a b. (b -> [Char]) -> Either a b -> [Char]
12:08:44 <Pastorn> quicksilver: yeah... I'm sitting here thinking but can't come up with anything... what's a good example of where Either could be used?
12:08:48 <CosmicRay> I thought of List.Find but I'd like to give it an anonymous function but can't seem to figure a nice way to do it
12:08:57 <Zeroth|work> lets say I want the first 100 digits of pi
12:09:03 <quicksilver> Pastorn: are you talking about the Either type, or 'either' the function?
12:09:09 <chessguy> CosmicRay, what do you mean "give you some other code"?
12:09:12 <Pastorn> both, combined =)
12:09:23 <CosmicRay> Cheery: Left, Nothing, whatever
12:09:36 <Saizan> CosmicRay: listToMaybe [s <- S s <- opts]
12:09:39 <Saizan> err
12:09:45 <Pastorn> what data structure should I have to think "i should use either/Either here!!"?
12:09:46 <Saizan> listToMaybe [s | S s <- opts]
12:09:56 <allbery_b> the most common use of Either is its incarnation as MonadError
12:09:57 <quicksilver> Pastorn: in your own code, it's normally preferable to define your own algebraic data type, than use Either
12:10:04 <CosmicRay> @hoogle listToMaybe
12:10:04 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
12:10:08 <quicksilver> Pastorn: since you can give the constructors more meaningful names
12:10:21 <Pastorn> quicksilver: true...
12:10:21 <norpan> if you have a function that returns one of two types for instance
12:10:31 <quicksilver> norpan: yes, but a custom type is normally better for that
12:10:38 <norpan> like a function returns either a result or an error
12:10:48 <quicksilver> Pastorn: so I'd have to agree with allbery_b, the built-in type is mainly useful for its monad instance
12:11:03 <Pastorn> oh, okay
12:11:04 <fantasma> does there exist a really good book to learn Haskell, or is YAHT the best way to do so?
12:11:13 <norpan> quicksilver: not if the custom type is made just so that function can return one of two types
12:11:14 * CosmicRay totally forgot about list comprehensions
12:11:30 <allbery_b> @google haskell road
12:11:37 <lambdabot> http://www.cwi.nl/~jve/HR
12:11:37 <chessguy> ?where soe
12:11:37 <lambdabot> Title: The Haskell Road
12:11:37 <lambdabot> http://haskell.org/soe/
12:11:38 <norpan> then it seems like a waste of time to think of a meaningless name for that type
12:11:51 <quicksilver> only if it's meaningless
12:12:02 <quicksilver> if it's meaningful then it's worth it :)
12:12:23 <norpan> sure, if that combined type is meaningful in itself, if it can be passed to some other function
12:12:27 <quicksilver> Pastorn: A very similar question is: why do we have tuples?
12:12:32 <norpan> otherwise you'll just end up decomposing it anyway
12:12:41 <quicksilver> Pastorn: what is the value of (a,b) when we have CustomConstructor a b ?
12:12:57 <quicksilver> it's a trade off between syntax, sugar, documentation, reusability of functions
12:12:58 <quicksilver> etc
12:13:19 <fantasma> hmm which one, "The Haskell Road to Logic" or "The Haskell School of Expression"
12:13:19 <Pastorn> quicksilver: readability?
12:13:38 <Pastorn> oh... retorical question...
12:13:43 <allbery_b> possibly neither, I'm brainfarting :/
12:13:50 * Pastorn hides in a corner
12:14:13 <quicksilver> Pastorn: exactly
12:14:20 <quicksilver> Pastorn: that was (one of) the answers
12:14:28 <norpan> i almost never use typles and either as inputs to functions, but they are handy as results
12:14:38 <Pastorn> fantasma: this is quite good: http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
12:14:40 <lambdabot> Title: Haskell: The Craft of Functional Programming, Second Edition
12:14:40 <quicksilver> norpan: and they're handy because there are built-in combinators which use them
12:14:54 <norpan> quicksilver: exactly
12:14:58 <quicksilver> norpan: like unzip, and ***, and so on
12:15:02 <Saizan> well sometimes you just have to pair values as int the arrows functions
12:15:17 <allbery_b> okay, actually, Haskell Road is the one I was recalling
12:15:23 <norpan> i never use arrows
12:15:36 <quicksilver> the same kinds of tradeoffs apply to a 'built-in' disjunct (Either) versus build-your-own-disjunct (make a data type)
12:15:36 * shapr shoots an arrow at norpan.
12:15:47 <quicksilver> norpan: do you ever use functions?
12:15:51 <quicksilver> norpan: if so, you're using arrows :)
12:16:03 <norpan> i use functions, but i don't use them as arrows
12:16:42 <norpan> i prefer silver bullets
12:16:45 <quicksilver> :)
12:17:09 <quicksilver> @remember norpan <norpan> i use functions, but i don't use them as arrows. i prefer silver bullets
12:17:10 <lambdabot> Done.
12:20:20 <fantasma> so there is general consensus that "The Road to Haskell" is the best book on Haskell
12:20:52 <chessguy> fantasma, you were pointed to at least three different books, they're all good, as are others
12:21:01 <chessguy> ?where books
12:21:01 <lambdabot> I know nothing about books.
12:21:26 <allbery_b> there are quite a few good haskell books, yeh
12:21:40 <allbery_b> check the haskell wiki too, there is a list of recommended books
12:21:47 <chessguy> http://www.haskell.org/haskellwiki/Books_and_tutorials#Textbooks
12:21:48 <lambdabot> Title: Books and tutorials - HaskellWiki
12:21:52 <chessguy> allbery_b, :)
12:22:08 <allbery_b> @quote stereo
12:22:09 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
12:22:15 <chessguy> where+ books http://www.haskell.org/haskellwiki/Books_and_tutorials#Textbooks
12:22:17 <lambdabot> Title: Books and tutorials - HaskellWiki
12:22:24 <allbery_b> fgorgot the @
12:22:39 <Cale> hehe
12:22:48 <chessguy> hmm, road to haskell isn't on that list
12:22:52 <allbery_b> @where+ books http://www.haskell.org/haskellwiki/Books_and_tutorials#Textbooks
12:22:53 <lambdabot> Done.
12:23:07 <allbery_b> I think it just cam eout recently and the wiki hasn't been updated yet
12:23:12 <chessguy> oh
12:23:14 <chessguy> sorry
12:23:23 * chessguy slaps himself awake
12:23:31 <malcolmw> shapr: do you fancy being a google SoC mentor again this year?
12:24:00 <Cale> I'm going to have to look into some way of telling X-Chat not to highlight my name when it occurs in certain contexts :)
12:24:12 <chessguy> Cale, such as?
12:24:17 <Cale> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
12:24:21 <chessguy> haha
12:24:32 <Cale> It gets my attention every time :)
12:24:38 <allbery_b> heh
12:24:39 <chessguy> @quote cale
12:24:39 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
12:24:42 * chessguy giggles
12:24:48 * SamB likes to know when people see his quotes
12:24:58 <chessguy> @quote samb
12:24:58 <lambdabot> SamB says: [<lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane] <SamB> is that a Python web framework?
12:25:05 <chessguy> @tell samb i looked at one of your quotes
12:25:05 <allbery_b> well, every time someone mentions perl or uses (a-b) in a computation I get dinged at
12:25:06 <lambdabot> Consider it noted.
12:25:11 <SamB> heh
12:25:23 <allbery_b> (perl qustions on #lopsa, and folks there like to refer to me as a_b and xchat's a bit stupid about it)
12:25:37 * SamB wonders why lambdabot has not jumped him yet
12:25:43 <nmessenger> samb /= SamB
12:25:47 <SamB> oh.
12:25:50 <chessguy> bah
12:26:03 <shapr> malcolmw: Sure!
12:26:04 <SamB> lambdabot is really stupid!
12:26:11 <SamB> @help tell
12:26:12 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
12:26:16 <chessguy> samb :Nickname is already in use.
12:26:25 <SamB> @messages
12:26:25 <lambdabot> You don't have any new messages.
12:26:29 <chessguy> lol
12:26:33 <samb> hi
12:26:33 <lambdabot> samb: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:26:36 <chessguy> haha
12:26:37 <malcolmw> shapr: I'm just about to send a cheerleading email to the cafe to get people to start signing up for SoC
12:26:40 <shapr> malcolmw: Not sure what sort of projects I'd sponsor this time though.
12:26:48 <shapr> malcolmw: Awesome! I can help with cheerleading.
12:27:06 <cHesSGUy> @messages
12:27:07 <lambdabot> You don't have any new messages.
12:27:11 <cHesSGUy> ok, just checking
12:27:17 <samb> <lambdabot> lispy said 8m 16d 12h 24m 59s ago: lispy wrote a bf interpreter (in case you were looking for examples interpreters for some reason)
12:27:28 <Cale> @quote timesheet
12:27:28 <lambdabot> No quotes match. Do you think like you type?
12:27:29 <shapr> Eight months, wow.
12:27:36 <Cale> @quote TimeBot
12:27:36 <lambdabot> No quotes match. Take a stress pill and think things over.
12:27:38 <Cale> hmm
12:27:45 <chessguy> @quote time
12:27:45 <lambdabot> qwe1234 says: i don't know about you, but i only use c++ because it gives static compile-time guarantees that assembly could never give.
12:27:49 <chessguy> @quote time
12:27:50 <lambdabot> EvilRanter says: I find "your a moron! unban me, or i shall TAUNT YOU A SECOND TIME!!" to be a particularly poor attempt
12:27:51 <dmwit> sassy
12:28:04 <chessguy> @quote merlyn
12:28:04 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
12:28:23 <dmwit> ?quote lambdabot
12:28:24 <lambdabot> lambdabot says: Of course i'm female
12:28:31 <malcolmw> shapr: we might well want a backup mentor for every project this year, so plenty of opportunities
12:28:51 <SamB> malcolmw: does this process involve a mind-wiping?
12:29:44 <malcolmw> SamB: huh? (mento_r_, not coke+mentoes)
12:30:07 <SamB> malcolmw: well, you know, to replace the mind with a backup copy of the mentor's mind ;-)
12:30:36 <chessguy> SamB, sadly enough, i got t hat joke
12:30:37 <malcolmw> replacement doesn't sound like a good backup strategy
12:30:51 <SamB> malcolmw: perhaps not
12:31:10 * malcolmw prefers incremental accumulation
12:31:22 <SamB> malcolmw: I suppose when you backup your computer, you do it by having another computer with all different stuff on it?
12:31:29 <chessguy> lol
12:31:35 * malcolmw sighs at how full of junk his house is :-)
12:31:54 <SamB> what? was that an accurate description of your computer backup strategy?
12:31:59 <malcolmw> SamB: absolutely
12:32:08 <chessguy> @slap SamB
12:32:09 <lambdabot> why on earth would I slap SamB
12:32:12 <chessguy> for being so difficult
12:32:22 <SamB> well. I do the same thing, except I don't call it a backup.
12:32:28 <malcolmw> SamB: copy all stuff from A to B, (and also all stuff from B to A)
12:32:33 <SamB> oh.
12:32:39 * SamB needs more drives
12:32:46 <SamB> (or bigger, rather)
12:32:58 <chessguy> SamB, trying to compensate for something?
12:33:11 <SamB> the lack of free space, possibly
12:33:38 <SamB> or maybe I should say the growing amount of stuff I put on the drives?
12:35:35 <Pastorn> @hoogle Int -> Double
12:35:36 <lambdabot> No matches, try a more general search
12:35:49 <Pastorn> @hoogle Float a => Int -> a
12:35:50 <lambdabot> Data.Graph.Inductive.Example.starM :: GraphM m gr => Int -> m (gr () ())
12:35:51 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
12:35:51 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
12:36:03 <Pastorn> help? just normal conversion...
12:36:07 <Saizan> ?type fromIntegral
12:36:09 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:36:14 <Pastorn> yay!
12:37:03 <shapr> So, how do I upload to hackage?
12:37:31 <kolmodin> shapr: through the web page
12:37:37 <kolmodin> ?where hackage
12:37:38 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
12:37:48 <shapr> kolmodin: thanks.
12:37:52 <kolmodin> http://hackage.haskell.org/packages/upload.html
12:37:54 <lambdabot> Title: HackageDB: checking and uploading packages
12:37:54 <kolmodin> ^^ there
12:38:06 <kolmodin> np
12:43:33 <mbishop> http://geekz.co.uk/lovesraymond/archive/the-redhat-package-mangler
12:43:37 <lambdabot> Title: Everybody loves Eric Raymond » The RedHat Package Mangler, http://tinyurl.com/35vz96
12:44:15 <Zeroth|work> > [1,7..]
12:44:16 <lambdabot>  [1,7,13,19,25,31,37,43,49,55,61,67,73,79,85,91,97,103,109,115,121,127,133,13...
12:44:52 <pjd> where do they get those faces!
12:45:50 <Pastorn> @where ghc
12:45:51 <lambdabot> http://haskell.org/ghc
12:45:59 <chessguy> one looks like it comes from the stapler guy on Office Space
12:47:51 <Pastorn> why isn't there any documentation when running man ghc?
12:48:23 <dmwit> Because it's installed incorrectly?
12:48:59 <dmwit> Or, maybe there's a ghc-doc package for your distribution.
12:49:14 <Pastorn> dmwit: you're probably right ;)
12:49:33 <Saizan> you may find what are you looking for in the user guide: http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
12:49:35 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.6, http://tinyurl.com/y4o7nt
12:50:06 <Pastorn> yeah, found that...
12:50:37 <Zeroth|work> [(..)1,2]
12:50:40 <Zeroth|work> > [(..)1,2]
12:50:40 <lambdabot>  Parse error
12:51:43 <Cheery> lol, again my nick mentioned. :) get better nick completion!
12:51:51 <chessguy> > (..) 1 2
12:51:52 <lambdabot>  Parse error
12:52:08 <chessguy> oh, it's just sugar, not an actual function
12:52:21 <Zeroth|work> sugar for what?
12:52:24 <chessguy> Cheery, everyone seems to think i'm you
12:52:30 <chessguy> ?type enumFromTo
12:52:30 <dmwit> enumFromTo
12:52:32 <lambdabot> forall a. (Enum a) => a -> a -> [a]
12:52:51 <dmwit> :t enumFrom
12:52:53 <lambdabot> forall a. (Enum a) => a -> [a]
12:53:03 <chessguy> ?src enumFrom
12:53:03 <lambdabot> Source not found. Take a stress pill and think things over.
12:53:03 <dmwit> (and family)
12:53:22 <chessguy> Cheery, i guess they think three characters is always enough to tab-complete on
12:54:08 <nmessenger> > enumFromThen 1 7
12:54:09 <lambdabot>  [1,7,13,19,25,31,37,43,49,55,61,67,73,79,85,91,97,103,109,115,121,127,133,13...
12:54:26 <Zeroth|work> chessguy, it should be >:-(
12:54:50 <Zeroth|work> > (..) 1 7
12:54:51 <lambdabot>  Parse error
12:55:00 <chessguy> > enumFromThen 1 7
12:55:02 <lambdabot>  [1,7,13,19,25,31,37,43,49,55,61,67,73,79,85,91,97,103,109,115,121,127,133,13...
12:55:04 <nmessenger> (..) is not a function, it's syntax sugar
12:55:05 <chessguy> > enumFromTo 1 7
12:55:06 <lambdabot>  [1,2,3,4,5,6,7]
12:55:39 <Zeroth|work> > [1..2]
12:55:40 <lambdabot>  [1,2]
12:55:42 <malcolmw> > (,,) 1 2 3
12:55:42 <Zeroth|work> heh
12:55:43 <lambdabot>  (1,2,3)
12:55:52 <chessguy> ?src enumFromThen
12:55:52 <lambdabot> Source not found. You speak an infinite deal of nothing
12:56:06 <dmwit> > [1..(-3)]
12:56:08 <lambdabot>  []
12:56:17 <nmessenger> > [1,0..(-3)]
12:56:18 <lambdabot>  [1,0,-1,-2,-3]
12:56:20 <dmwit> ...that took a long time.
12:56:43 <nmessenger> yours was []
12:57:02 <Zeroth|work> > [,,]
12:57:02 <lambdabot>  Parse error
12:57:05 <Zeroth|work> > [1,,1]
12:57:06 <lambdabot>  Parse error
12:57:19 <chessguy> > [(,,)]
12:57:20 <lambdabot>  Add a type signature
12:57:41 <chessguy> > [(,,)] :: a -> b -> c -> (a,b,c)
12:57:41 <lambdabot>  Couldn't match expected type `a -> b -> c -> (a, b, c)'
12:57:52 <chessguy> > [(,,)] :: [a -> b -> c -> (a,b,c)]
12:57:53 <lambdabot>  Add a type signature
12:58:00 <Zeroth|work> haha
12:58:02 <nmessenger> > [(,,)] :: [Int -> Char -> Bool -> (Int,Char,Bool)]
12:58:04 <lambdabot>  [<Int -> Char -> Bool -> (Int,Char,Bool)>]
12:58:11 <chessguy> bah
12:58:12 <nmessenger> helpful!
12:58:13 <Zeroth|work> > [(,,) :: [a -> b -> c -> (a,b,c)]]
12:58:14 <lambdabot>  Couldn't match expected type `[a -> b -> c -> (a, b, c)]'
12:58:15 <nornagon> > (,,) 1 2
12:58:16 <lambdabot>  Add a type signature
12:58:36 <nmessenger> > (,,) 1 2 3
12:58:37 <lambdabot>  (1,2,3)
12:58:44 <nornagon> orite
12:58:49 <dmwit> > [(,,) :: a -> b -> c -> (a,b,c)]
12:58:50 <lambdabot>  Add a type signature
12:58:59 <nmessenger> monomorphic!
12:59:27 <nmessenger> If you expect it to eval to something, it has to have *one* type
12:59:39 <Zeroth|work> > zipwidth (+) [1,2,3] [1,2]
12:59:40 <lambdabot>   Not in scope: `zipwidth'
12:59:41 <dmwit> hah
12:59:44 <Zeroth|work> > zipWidth (+) [1,2,3] [1,2]
12:59:45 <lambdabot>   Not in scope: `zipWidth'
12:59:51 <Saizan> width?
12:59:54 <nmessenger> -With?
12:59:55 <dmwit> > zipWith (+) [1,2,3] [1,2]
12:59:56 <lambdabot>  [2,4]
12:59:58 <Zeroth|work> > zipLength (+) [1,2,3] [1,2]
12:59:59 <lambdabot>   Not in scope: `zipLength'
13:00:03 <Zeroth|work> ahaha
13:00:40 <nmessenger> "zip two lists using this function to combine corresponding elements"
13:00:42 <Zeroth|work> zipWith (+) (1,2) (1,4)
13:00:46 <nmessenger> "zip with this function"
13:00:50 <Zeroth|work> > zipWith (+) (1,2) (1,4)
13:00:51 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a1, b)'
13:01:01 <nmessenger> tuples aren't lists!
13:01:06 <Zeroth|work> I'm aware
13:01:08 <dmwit> > unzip [(1,2), (1,4)]
13:01:10 <lambdabot>  ([1,1],[2,4])
13:01:11 <Zeroth|work> I'm a newbie, gimme a break
13:01:31 <Zeroth|work> unzip [("pants")]
13:01:33 <Zeroth|work> > unzip [("pants")]
13:01:34 <lambdabot>  Couldn't match expected type `(a, b)'
13:01:56 <Zeroth|work> > unzip [("pants"), ("pants")]
13:01:57 <lambdabot>  Couldn't match expected type `(a, b)'
13:01:58 <nornagon> > uncurry (++) (unzip [(1,2),(3,4)])
13:01:59 <lambdabot>  [1,3,2,4]
13:02:12 <Zeroth|work> > unzip [("pants", "pants"), ("pants", "pants")]
13:02:14 <lambdabot>  (["pants","pants"],["pants","pants"])
13:02:16 <dmwit> > unzip [("pants","pants")]
13:02:18 <lambdabot>  (["pants"],["pants"])
13:02:30 <nmessenger> @djinn (a -> b, c -> d) -> (a, c) -> (b, d)
13:02:31 <lambdabot> f (a, b) (c, d) = (a c, b d)
13:03:00 <nornagon> @. pl djinn (a -> b) -> (a,a) -> (b,b)
13:03:00 <lambdabot> f = (`ap` snd) . (. fst) . (const .) . (ap =<< ((,) .))
13:03:24 <nornagon> ewww.
13:03:32 <Saizan> @djinn (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)
13:03:33 <lambdabot> f a (b, _) (c, _) = (a b c, a b c)
13:03:38 <nornagon> @pl \a -> a *** a
13:03:39 <lambdabot> join (***)
13:03:43 <nmessenger> > (\(f,g)(x,y)->(f x,g y) ((join (***) (+)) (1,2)) (3,4)
13:03:44 <lambdabot>  Parse error
13:03:50 <nornagon> :t join (***)
13:03:53 <nmessenger> > (\(f,g)(x,y)->(f x,g y)) ((join (***) (+)) (1,2)) (3,4)
13:03:53 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
13:03:54 <lambdabot>  (4,6)
13:04:09 <Cheery> why lambdabot never loses his pants?
13:04:15 <dmwit> What sorcery is this!
13:04:20 <Saizan> her!
13:04:40 <chessguy> lambdabot *wears* the pants around here
13:04:47 <nmessenger> > (\xy -> (\(f,g)(x,y)->(f x,g y)) ((join (***) (+)) xy)) (1,2) (3,4)
13:04:48 <lambdabot>  (4,6)
13:04:59 <Cheery> hm. What do you think it is? some darn personal harem 1.0?
13:05:14 <Cheery> PH :P
13:05:16 <nmessenger> @pl (\f xy -> (\(f,g)(x,y)->(f x,g y)) ((join (***) f) xy))
13:05:16 <lambdabot> (((`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .)) . snd) .) . join (***)
13:05:25 <chessguy> augustss, welcome to the insanity :)
13:05:42 <nornagon> > let (*~) = join (***) (*) in (1,0) *~ 2
13:05:43 <lambdabot>  Couldn't match expected type `t1 -> t'
13:06:15 <nornagon> > let a *~ b = join (***) (*b) a in (1,0) *~ 2
13:06:16 <lambdabot>  (2,0)
13:06:44 <dmwit> > let a *~ b = join (***) (*b) a in (3,4) *~ 2
13:06:46 <lambdabot>  (6,8)
13:06:54 <nornagon> @pl \a b -> join (***) (*b) a
13:06:55 <lambdabot> flip (join (***) . (*))
13:07:04 <Pastorn> WHY would anyone use ap? I don't get it!! All it does is to take a out of (m a), appli id and re-apply m on a
13:07:04 <mbishop> damnit dons
13:07:19 * mbishop blames dons for any non haskell links being downvoted on reddit
13:07:21 <chessguy> ?src ap
13:07:21 <lambdabot> ap = liftM2 id
13:07:24 <nmessenger> Pastorn: the interesting thing is in the "taking-out"
13:07:30 <dmwit> @pl \x -> f x x
13:07:31 <lambdabot> join f
13:07:45 <nmessenger> > [(+3), (*2)] `ap` [2,5,3]
13:07:46 <lambdabot>  [5,8,6,4,10,6]
13:07:50 <dmwit> @pl \x -> (f x, g x)
13:07:50 <lambdabot> liftM2 (,) f g
13:07:50 <Pastorn> oh... nevermind
13:08:04 <Pastorn> @pl liftM id
13:08:05 <lambdabot> id
13:08:11 <nmessenger> ?
13:08:15 <Pastorn> @pl liftM2 id
13:08:15 <nornagon> @pl liftM2 id
13:08:15 <lambdabot> ap
13:08:15 <lambdabot> ap
13:08:17 <sjanssen> mbishop: why do you blame him?
13:08:18 <nornagon> :D
13:08:38 <mbishop> because dons always submits a bunch of haskell links, and they get +20 in no time
13:08:44 <Pastorn> ?src liftM2
13:08:45 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:08:55 <mbishop> whereas a good ocaml link (submited by me :P) will get one vote up, then right back down again
13:09:12 <nmessenger> "draw out the function, draw out the arguments, return the result"
13:09:23 <Pastorn> @type id
13:09:26 <lambdabot> forall a. a -> a
13:09:34 <nmessenger> in [], this "draws out" each one, making a product
13:09:44 <Batterseapower> maybe someone can help me with a design issue i'm having..
13:09:47 <Pastorn> HOW can I apply id to two arguments, as apparently ap does?
13:09:57 <Batterseapower> i'm writing yet another toy compiler in haskell
13:09:57 <nmessenger> perhaps it'd be clearer if it used ($) instead of id?
13:10:08 <Batterseapower> each of my pipeline stages has its own AST type
13:10:13 <nmessenger> > id (+1) 2
13:10:15 <lambdabot>  3
13:10:23 <Batterseapower> that encodes the invariants each stage tries to make in the type system
13:10:30 <nmessenger> id <function> <arg> = <function> <arg>
13:10:32 <Pastorn> > id (:) 4
13:10:33 <lambdabot>  <[Integer] -> [Integer]>
13:10:37 <sjanssen> mbishop: which post are you bemoaning?
13:10:53 <Batterseapower> but it leads to lots of tedious lines in the more boring stages that just translate from one AST construct to another AST construct with the same name
13:10:56 <nmessenger> > id (:) 4 [5,6]
13:10:58 <lambdabot>  [4,5,6]
13:11:10 <Batterseapower> (but not the same type, crucially)
13:11:19 <Pastorn> > id (:) 4 -- why does he do that?
13:11:20 <mbishop> sjanssen: I just submitted 2 nice ones I found (one on using opengl with ocaml's "Graphics" module, and another for a scheme interpreter in ocaml)
13:11:21 <lambdabot>  <[Integer] -> [Integer]>
13:11:29 <nmessenger> id (:) = (:)
13:11:42 <Batterseapower> is there any way to factor out this cruft but maintain the multiple ASTs?
13:11:43 <nmessenger> (:) 4 :: [Integer] -> [Integer]
13:11:50 <nornagon> :t id (:)
13:11:53 <lambdabot> forall a. a -> [a] -> [a]
13:12:02 <nornagon> :t id (:) 4
13:12:05 <lambdabot> forall a. (Num a) => [a] -> [a]
13:12:11 <dmwit> :t liftM2
13:12:13 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:12:14 <nornagon> :t id (:) 4 []
13:12:16 <lambdabot> forall a. (Num a) => [a]
13:12:21 <Cale> Batterseapower: perhaps by parametrising the AST type?
13:12:30 <Cale> (i.e. with a type of label)
13:12:43 <Pastorn> @ty ap
13:12:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:12:52 <Cale> :t sequence
13:12:55 <lambdabot>     Ambiguous occurrence `sequence'
13:12:55 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
13:13:06 <Cale> Almost thought that had been fixed :)
13:13:07 <Pastorn> > ap (:) [1] [2]
13:13:08 <lambdabot>  Couldn't match expected type `a -> [a]'
13:13:12 <nmessenger> > [(4:), (5:)] `ap` [[1,2], [7,8]]
13:13:13 <Pastorn> > ap (:) 1 [2]
13:13:14 <lambdabot>   add an instance declaration for (Num ([t] -> [[t]]))
13:13:14 <lambdabot>  [[4,1,2],[4,7,8],[5,1,2],[5,7,8]]
13:13:31 <Pastorn> nmessenger: cool :)
13:13:39 <Cale> > ap (,) tail [1,2,3]
13:13:40 <lambdabot>  ([1,2,3],[2,3])
13:13:50 <hpaste>  WMa pasted "(no title)" at http://hpaste.org/829
13:13:52 <Cale> > ap zip tail [1,2,3]
13:13:52 <Pastorn> cool indeed
13:13:54 <lambdabot>  [(1,2),(2,3)]
13:14:10 <nmessenger> Pastorn: Cale's is ap in ((->) r), which is a strange beast
13:14:28 <nornagon> :t ap zip tail
13:14:30 <lambdabot> forall a. [a] -> [(a, a)]
13:14:35 <nornagon> :t ap zip
13:14:36 <Pastorn> ap is short for?
13:14:37 <Cale> I'm convinced that ((->) r) is a useful thing though.
13:14:38 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
13:14:41 <Cale> Pastorn: apply
13:14:44 <Batterseapower> Cale: thanks for the suggestion, but if you can do that its not obvious how :( i've posted an example at http://hpaste.org/829
13:14:47 <Cale> @type ap
13:14:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:15:08 <dmwit> > [4, 5] >>= [(:[1,2]), (:[7,8])]
13:15:09 <lambdabot>  Couldn't match expected type `t -> [b]' against inferred type `[a]'
13:15:17 <thief_grr> from a list of integers, i need the initial segment until it hits a fixed number n
13:15:17 <nmessenger> Cale: I said nothing to the contrary :D.  Usefulness and strangeness aren't mutally exclusive :P
13:15:20 <Cale> @type liftM2 ($)
13:15:23 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
13:15:24 <thief_grr> what's the most economic way to do it?
13:15:26 <dmwit> > [4, 5] >>= (\x -> [[x,1,2], [x,7,8]])
13:15:27 <lambdabot>  [[4,1,2],[4,7,8],[5,1,2],[5,7,8]]
13:15:43 <Cale> thief_grr: takeWhile?
13:15:50 <dmwit> ?pl \x -> [[x,1,2], [x,7,8]]
13:15:51 <lambdabot> liftM2 (:) (: [1, 2]) (return . (: [7, 8]))
13:15:59 <Cale> > takeWhile (/= 7) [1..]
13:16:01 <lambdabot>  [1,2,3,4,5,6]
13:16:19 <Pastorn> my head is spinning
13:16:30 <nornagon> > [4,5] >>= ap [(:[1,2]), (:[7,8])]
13:16:31 <lambdabot>   add an instance declaration for (Num [a])
13:16:31 <lambdabot>     In the expression: 5
13:16:36 <nmessenger> > do f <- [(4:), (5:)]; xs <- [[1,2],[7,8]]; return (id f xs) -- make any sense?
13:16:38 <lambdabot>  [[4,1,2],[4,7,8],[5,1,2],[5,7,8]]
13:17:05 <nornagon> > [[4],[5]] >>= ap [(:[1,2]), (:[7,8])]
13:17:07 <lambdabot>  [[4,1,2],[4,7,8],[5,1,2],[5,7,8]]
13:17:13 <thief_grr> Cale: thats what i was looking for, thanks
13:17:17 <Pastorn> @type :()
13:17:20 <lambdabot> parse error on input `:'
13:17:22 <Pastorn> @type :()
13:17:24 <lambdabot> parse error on input `:'
13:17:28 <Pastorn> @type (4:)
13:17:30 <dmwit> > do f <- [(4:), (5:)]; xs <- [[1,2],[7,8]]; return (f xs)
13:17:31 <lambdabot> forall t. (Num t) => [t] -> [t]
13:17:32 <lambdabot>  [[4,1,2],[4,7,8],[5,1,2],[5,7,8]]
13:17:51 <Cale> Batterseapower: hmm... you might want to look at the Scrap your Boilerplate paper, it might be the sort of thing you're looking for given that implementation of simplify.
13:17:55 <Pastorn> > ap (4:) [1..10]
13:17:56 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[t]'
13:17:57 <nmessenger> (4:) conses four onto the beginning of a list.
13:18:20 <nmessenger> ap expects the functions to be in the monad (a list), too
13:18:28 <dmwit> > ap (4:) [[1..n] | n <- [1..10]]
13:18:28 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[t]'
13:18:56 <dmwit> > inits [1..10]
13:18:58 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
13:19:11 <Cale> Batterseapower: why couldn't the Simplify.hs stage use the same type as the InferTypes stage, just with () as the parameter for GeneralSyntax.
13:19:14 <Cale> ?
13:19:15 <nmessenger> dmwit, Pastorn: if you want to do that, just use map (4:)
13:19:30 <nmessenger> > ap [(4:), (5:)] [[1..n] | n <- [1..10]]
13:19:32 <dmwit> yah
13:19:32 <lambdabot>  [[4,1],[4,1,2],[4,1,2,3],[4,1,2,3,4],[4,1,2,3,4,5],[4,1,2,3,4,5,6],[4,1,2,3,...
13:19:33 <Batterseapower> cale: there si no Less, Greater or GreaterEqual in the Simplify syntax
13:19:36 <chessguy> nmessenger, ap, map, it's all the same
13:19:46 <Batterseapower> cale: thats what i meant when i talk about encoding invariants in the type system
13:20:01 <Cale> ah, okay
13:20:02 <sjanssen> mbishop: upvoted
13:20:10 <Cale> (I missed some of what you said then)
13:20:16 <nmessenger> map <func> <arglist>, vs. ap <funclist> <arglist>
13:20:18 <mbishop> sjanssen: <3
13:20:32 <Batterseapower> cale: i'll take a look at scrap your boilerplate, thanks, but i'd hoped there was some way to do it without extensions :)
13:20:47 <chessguy> nmessenger: i hope you know i was kidding
13:20:48 <Cale> > Control.Monad.sequence [(+1), (*2), (^2)] 5
13:20:50 <lambdabot>  [6,10,25]
13:21:01 <nmessenger> in fact, map f xs = ap (return f) xs
13:21:13 <Batterseapower> cale: probably my fault, i think IRSII ate some of my text when my connection died a few minutes ago
13:21:20 <Batterseapower> thanks again!
13:21:23 <Cale> Batterseapower: actually, since the type is changing, I'm not sure how useful that'll be
13:21:25 <nmessenger> return puts the 'f' into the monad, and ap applies it to the args
13:21:41 <sjanssen> mbishop: does "(lisp_expr array list)" mean a list of arrays of lisp expressions?
13:21:50 <Cale> (no, I actually did see that comment when I looked in the scrollback, I'd just not read it)
13:22:23 <pjd> nmessenger: !
13:22:38 <nmessenger> pjd: ?
13:22:57 <sjanssen> bleh, this interpreter uses mutation :(
13:22:57 <pjd> map f = ap (return f)
13:23:17 <Batterseapower> cale: damn.. is this something I could fix with template haskell? it seems like overkill though..
13:23:36 <mbishop> sjanssen: well I never said it was good :P
13:23:42 <mbishop> sjanssen: still probably interesting
13:24:11 <sjanssen> mbishop: I was working on implementing it in Haskell
13:25:17 <nmessenger> pjd: are you !-ing over a sudden realization, or complaining about my lack of eta-reduction? :D
13:25:37 <pjd> nmessenger: in wondrous amazement, actually
13:25:56 <nmessenger> it's all there in The_Other_Prelude
13:26:14 <pjd> (i'm still waiting for the realization really :)
13:26:24 <nornagon> i still suck at haskell :(
13:26:38 <nornagon> even though i sorta vaguely grok monads and stuff
13:26:42 <nmessenger> notice: map f x = return f <*> x
13:27:05 <chessguy> :type <*>
13:27:14 <chessguy> @type <*>
13:27:15 <pjd> fmap ~= ap . return
13:27:17 <lambdabot> parse error on input `<*>'
13:27:23 <nmessenger> you just have to hook together the types, it's like legos! :3
13:27:24 <augustss> nornagon: I still suck at Haskell too :)
13:27:30 <nmessenger> @type (<*>)
13:27:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:27:34 <nmessenger> = ap
13:27:48 <Mebius> ÑÐ¹ Ð·Ð´ÐµÑÑ ÐºÑÐ¾ Ð½Ð¸Ð±ÑÐ´Ñ ÑÐ°Ð·Ð³Ð¾Ð²Ð°ÑÐ¸Ð²Ð°ÐµÑ Ð½Ð° ÑÑÑÑÐºÐ¾Ð¼?
13:28:00 <nmessenger> come again?
13:28:01 <augustss> Tja, jag vet inte.
13:28:23 <nmessenger> "function in the monad, arg in the monad, result in the monad"
13:28:32 <nominolo> njet
13:28:58 <Mebius> How many haskell programmers using GTK2hs?
13:29:40 <nominolo> i think full quantification is undecidable
13:30:04 <nominolo> but it's probably satisfyable
13:30:21 <nornagon> augustss: heh
13:30:34 <nornagon> i wrote that boids implementation in C++
13:30:39 <cddar> > let a + b = 0 - (0 - a - b) in 2 + 2
13:30:41 <lambdabot>  4
13:30:44 <nornagon> it is orders of magnitude faster
13:30:53 <cddar> > let a + b = 0 - (0 - a - b - 1) in 2 + 2
13:30:54 <lambdabot>  5
13:31:06 <nornagon> but what bugs me is that the profiling seemed to tell me that the ffi stuff was the bottleneck
13:31:52 <augustss> nornagon: marshaling can kill you
13:31:52 <nominolo> cddar: what the ..?
13:31:57 <Pastorn> @pl (\(x,y) -> (y,x))
13:31:58 <lambdabot> uncurry (flip (,))
13:32:02 <nornagon> augustss: :/
13:32:13 <nornagon> augustss: are there sneaky ways to get around it?
13:32:14 <Pastorn> > let f = uncurry (flip (,)) in f 1 2
13:32:15 <lambdabot>  Couldn't match expected type `t1 -> t'
13:32:15 <nornagon> besides
13:32:29 <nornagon> SDL.flip was one of the big consumers
13:32:40 <augustss> well, if the Haskell code is just passing data around you don't need to marshal
13:32:44 <nornagon> shouldn't be much marshalling there...
13:33:29 <nmessenger> > let f = uncurry (flip (,)) in f (1,2) -- you forgot the param type, Pastorn :P
13:33:30 <lambdabot>  (2,1)
13:33:35 <tuukkah> they're not letting me use variables bound in pattern guards in the where clauses of the body :-(
13:34:24 <Pastorn> nmessenger: whoops
13:34:30 <nominolo> cddar: ah, get it
13:34:54 * Pastorn has had enough of school and goes home
13:34:59 <Cale> tuukkah: that's because where scopes over guards
13:35:02 <Cale> tuukkah: use let
13:35:11 <tuukkah> Cale, yeah :-/
13:36:14 <hpaste>  procyon pasted "Combinator List problem with sums" at http://hpaste.org/830
13:36:32 <dylan> nornagon: I wonder if opengl would be faster?
13:36:44 <nornagon> heh, i have double software design first
13:36:47 <procyon_> Can any combinator pros look at my hpaste and tell me if there is a way to do this in haskell?
13:36:50 <nornagon> they teach us EBNF!
13:36:58 <nornagon> and consideration of social and ethical issues!
13:37:02 <nornagon> stupid high school
13:37:02 <cddar> nominolo: is there a better version?
13:37:05 <nornagon> dylan: why would it be?
13:37:07 <nornagon> i mean
13:37:15 <sjanssen> procyon_: what are you trying to do there?
13:37:17 <nornagon> apart from there being nice hw acceleration
13:37:23 <dylan> nornagon: I dunno if SDL uses any 2d hardware acceleration.
13:37:36 <nornagon> well, it's obviously not SDL that's the problem
13:37:36 <procyon_> sjanssen: one sec.  brb.  stupid pseudo emergency....
13:37:48 <nornagon> see: my C++ version that runs at ten times the speed
13:37:55 <nominolo> cddar: no, i was just confused how 2+2 can be anything other than 4, until i finally realized that you locally overloaded (+)
13:38:01 <nornagon> using SDL.
13:38:08 <nornagon> and pretty much the same algorithm.
13:38:13 <dylan> sure, but the goal is to get a haskell version that is fast, you might not be able to optimize in the same places.
13:38:25 <nornagon> (though much uglier)
13:38:33 <nornagon> hmph :(
13:38:34 <nominolo> > let a + b = a + b + 1 in 2+2
13:38:35 <lambdabot>  Exception: <<loop>>
13:38:36 <dylan> "same algorithm" might be the problem, too.
13:38:54 <cddar> nominolo: you should not use +
13:39:13 <nornagon> dylan: well, the algorithm in the haskell version was not the performance bottleneck
13:39:17 <nominolo> > let a + b = a Prelude.+ b - 1 in 2 + 2
13:39:18 <lambdabot>  3
13:39:24 <nornagon> something to do with the ffi was
13:39:55 <bd_> nornagon: Are you using safe calls where unsafe calls could be used?
13:39:58 <Cale> I think the shootout should give up on the "same way" thing. If you want to enforce constraints of that sort, ensure the programs emit intermediate results.
13:40:07 <nornagon> bd_: no idea.
13:40:32 <cddar> nominolo: hmm. it's better than "0 - (0 .."
13:40:42 <bd_> nornagon: If the call doesn't block or callback into haskell, use an unsafe FFI binding :)
13:40:56 <shapr> Cale: Yeah, I think the different paths to the same goal are illustrative.
13:41:30 <nominolo> cddar: but confusing in any way.. redefining common operators is evil
13:41:44 <Cale> and if there's a better algorithm in one language, then the others can try to copy it
13:42:00 <nornagon> bd_: um, okay then.
13:42:14 <nornagon> how do I make it an unsafe call then?
13:42:38 <dylan> add "unsafe" to the foreign import.
13:42:57 <nornagon> oh
13:43:00 <nornagon> i think it's already there
13:43:06 <dylan> hmm
13:43:07 <bd_> foreign import "C" "function name" unsafe varname :: stuff,right?
13:44:01 <nornagon> foreign import ccall unsafe "circleColor" sdlgfxCircleColor
13:45:19 <nornagon> so, ye, it's already unsafe
13:46:24 <procyon_> sjanssen: back
13:46:47 <sjanssen> procyon_: so what should sum_c do?
13:47:26 <procyon_> sum_n should add all ints in the combinatorial list
13:47:35 <procyon_> It is an infinite type though.
13:47:45 <pjd> nmessenger: is there some symmetrical way to define ap in terms of fmap?
13:47:49 <sjanssen> procyon_: how are you encoding your lists?
13:47:49 <bd_> nornagon: have you profiled?
13:48:02 <nornagon> bd_: yeah
13:48:04 <pjd> it seems like there should be, but i can't figure it out
13:48:07 <procyon_> cons a b cn cc = cc a b
13:48:08 <sjanssen> something like: (a -> b -> b) -> b -> b ?
13:48:22 <Batterseapower> is there no monad transformer for ST anywhere? (STT?)
13:48:28 <bd_> nornagon: and it's spending all its time in the FFI marshalling?
13:48:36 <nornagon> bd_: after sprinkling {-# SCC #-} everywhere, it seemed to be spending all its time in the FFI calls
13:48:48 <bd_> nornagon: try using -auto-all?
13:48:51 <nornagon> i did
13:48:54 <sjanssen> procyon_: shouldn't that be cons a b cn cc = cc a (b cn cc) ?
13:48:54 <bd_> hmm
13:49:09 <bd_> nornagon: What optimization flags are you building with?
13:49:38 <nornagon> oh, hm
13:49:49 <sjanssen> procyon_: at least that is one formulation that we can actually give a type in Haskell
13:49:56 <nmessenger> pjd: you'd need an unreturn, which doesn't exist in general, as far as I understand.
13:50:10 <nornagon>     drawBoid             Main                                                 252        4286   0.9   53.0     0.9   53.0
13:50:16 <pjd> nmessenger: that's more or less what i figured
13:50:16 <Saizan> Batterseapower: no, you have to use it as the core monad, just like IO
13:50:26 <nornagon> 53% alloc for one sdl call
13:50:30 <bd_> oO'
13:50:45 <bd_> 53% alloc? What arguments does that have?
13:50:49 <procyon_> sjanssen: ok.  I'll try that one.  in my current, given a list l, l nil k  gives the car and l nil k1 gives the cdr
13:51:06 <nmessenger> pjd: Functors are just fmap, add return and you get ap, for an Applicative Functor, add join or bind and you got a Monad. :)
13:51:13 <Batterseapower> saizan: i see.. is there a reason for that? I was hoping to be able to deal with errors within ST with the Error monad.. was that too naive?
13:51:14 <fasta> Why doesn't this work again? (\computation -> runST computation)
13:51:19 <nornagon> bd_: drawBoid :: SDL.Surface -> Boid -> IO Bool
13:51:32 <pjd> nmessenger: applicative functor?
13:51:37 <fasta> "Inferred type is less polymorphic than expected"
13:51:39 <nmessenger> @src Applicative
13:51:40 <lambdabot> class Functor f => Applicative f where
13:51:40 <lambdabot>     pure  :: a -> f a
13:51:40 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:51:53 <nmessenger> pure = return, (<*>) = ap
13:52:01 <bd_> nornagon: weird... that shouldn't be allocating much... Are you building with -O2 -fvia-c?
13:52:06 <nornagon> yup
13:52:12 <sjanssen> procyon_: the approach I suggested is like turning a list into a foldr
13:52:16 <Saizan> fasta: monomorphism restriction maybe? also runST is rank-2
13:52:27 <sjanssen> procyon_: it's quite similar to peano numbers
13:52:28 <pjd> nmessenger: weird
13:52:34 <dylan> I bet Boid needs some strictness
13:52:49 <procyon_> sjanssen: so nil=k is still valid in your representation?
13:52:52 <roconnor> @pl (\((a,b),c) ((d,e),f) -> ((a+d),(b+e),f+c))
13:52:56 <lambdabot> uncurry (ap (flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . (flip .) . (((.) .) .) . flip flip (+) . ((.) .) . (
13:52:56 <Saizan> Batterseapower: i think it's because you don't want the state to escape
13:52:56 <lambdabot> flip .) . ((flip .) .) . ((((.) .) .) .) . (. (+)) . flip . ((.) .) . ((,,) .) . (+) . fst) snd)
13:52:56 <lambdabot> optimization suspended, use @pl-resume to continue.
13:52:59 <bd_> dylan: it should be strict on its args already, since it's FFI
13:53:01 <nmessenger> > getZipList $ (*) <$> [1,2,3] <*> [4,5,6]
13:53:02 <roconnor> :/
13:53:02 <lambdabot>  Couldn't match expected type `ZipList a'
13:53:12 <nmessenger> > getZipList $ (*) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
13:53:14 <lambdabot>  [4,10,18]
13:53:21 <bd_> dylan: unless you mean it's being passed some large suspension... but wouldn't that be accounted to a different SCC?
13:53:21 <fasta> Saizan: I already have {-# OPTIONS_GHC -fglasgow-exts -fno-monomorphism-restriction #-}
13:53:21 <QtPlatypus> Can someone expand FFI?
13:53:28 <dylan> bd_: drawBoid is FFI?
13:53:42 <bd_> nornagon: drawBoid is FFI, right? :)
13:53:58 <nornagon> it's not FFI itself
13:54:03 <bd_> oh?
13:54:07 <nornagon> but it just calls an FFI function
13:54:23 <nornagon> drawBoid surf (Boid { pos=(x,y), vec=v }) = circle surf (floor x) (round y) 2 (SDL.Pixel 0xffff)
13:54:28 <nornagon> where circle is FFI
13:54:42 <bd_> nornagon: Hm, is SDL.Pixel unboxed?
13:54:43 <nornagon> and, oops, that should've been round x
13:55:03 <nornagon> no idea, what's unboxed mean?
13:55:14 <bd_> nornagon: What's the data-declaration for SDL.Pixel?
13:55:18 <Saizan> fasta: it's the rank2 then, i'm not sure how you can deal with it, i've found giving explicit type sings can help
13:55:31 <nornagon> newtype Pixel = Pixel Word32 deriving (Show,Eq,Ord)
13:55:34 <bd_> unboxed means the argument for SDL.Pixel is packed into the structure itself, rather than being a pointer
13:55:37 <bd_> aha!
13:55:37 <bd_> newtype
13:55:39 <bd_> blah
13:55:42 <bd_> oh
13:56:00 <bd_> newtypes are always unboxed
13:56:10 <nornagon> so 'yes'
13:56:25 <bd_> hmm
13:56:31 <bd_> nornagon: how polymorphic is drawBoid?
13:56:36 <nornagon> uh.
13:56:47 <procyon_> sjanssen: what is cdr in that representation?
13:56:53 <nornagon> bd_: not?
13:57:00 <roconnor> @type (+) *** (+)
13:57:02 <lambdabot> forall a a1. (Num a, Num a1) => (a, a1) -> (a -> a, a1 -> a1)
13:57:27 <nornagon> :t join (***) (+)
13:57:30 <lambdabot> forall b. (Num b) => (b, b) -> (b -> b, b -> b)
13:57:32 <bd_> nornagon: hm, I can't see how that's doing 53% allocation... :/
13:57:37 <nornagon> me either.
13:57:43 <narain> :t (***)
13:57:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:57:49 <bd_> nornagon: assuming circle is FFI
13:57:56 <nornagon> well
13:57:58 <nornagon> not quite
13:58:01 <nornagon> i think
13:58:02 <bd_> oh?
13:58:03 <nornagon> one sec
13:58:06 <bd_> does circle have a SCC then?
13:58:19 <nornagon> circle = circle' sdlgfxCircleColor
13:58:27 <bd_> nornagon: hmm
13:58:29 <nornagon> circle' :: (Ptr SurfaceStruct -> Int16 -> Int16 -> Int16 -> Word32 -> IO Int) -> Surface -> Int16 -> Int16 -> Int16 -> Pixel -> IO Bool
13:58:38 <nornagon> circle' f surf x y r (Pixel px) = withForeignPtr surf $ \dst -> intToBool (-1) (f dst x y r px)
13:58:41 <bd_> nornagon: try rewriting that with explicit points?
13:59:11 <bd_> ie: circle !surf !x !y !r !px = circle' sdlgfxCircleColor surf x y r px
13:59:28 <bd_> circle' !f !surf !x !y !r (Pixel !px) = ...
13:59:34 <bd_> explicit strictness and etc
13:59:45 <bd_> I suspect that -auto-all might actually be harming optimization here...
14:00:15 <bd_> since, if circle has a SCC, it can't inline it away
14:01:07 <hpaste>  sjanssen annotated "Combinator List problem with sums" with "a solution?" at http://hpaste.org/830#a1
14:02:27 <bd_> nornagon: -fbang-patterns of course if you use the explicit strictness annotations as I did
14:02:39 <nornagon> right.
14:05:23 <bd_> nornagon: any improvement?
14:05:24 <nornagon> afk.
14:05:38 <tuukkah> it's not that bad i suppose - learning to accept that let and where are different :-)
14:05:41 <bd_> XD
14:05:42 <nornagon> bd_: no
14:05:45 <bd_> oh :/
14:06:40 <Saizan> maybe you need -unbox-strict-something ?
14:06:54 <Saizan> (replace something with the actual flag)
14:07:30 <procyon_> >sjanssen: The problem with going to peano numbers is horrible performance.  I'd like to keep a primative representation.
14:08:24 <chessguy> ?src bracket
14:08:25 <lambdabot> bracket before after thing = block $ do
14:08:25 <lambdabot>     a <- before
14:08:25 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
14:08:25 <lambdabot>     after a
14:08:25 <lambdabot>     return r
14:08:59 <sjanssen> procyon_: should be easy to replace zeroc and plusc with 0 and (+) in my implementation
14:09:23 <procyon_> ahh.  I see.  Kindof.
14:10:57 <pjd> @type \x -> join . (liftM2 liftM x) . return
14:10:59 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m (a1 -> r) -> m a1 -> m r
14:11:12 <narain> tuukkah: let and where are different?
14:11:18 <narain> i didn't know that
14:11:19 <pjd> same type as ap
14:11:22 <nmessenger> narain: scope
14:11:37 <sjanssen> procyon_: sumc l = l (+) 0
14:11:41 <pjd> but it blows up when you actually try to define it
14:11:55 <pjd> nmessenger: i don't suppose you know what's going on?
14:12:02 <narain> let foo in expr  /=  expr where foo  ?
14:12:02 <nmessenger> pjd: that'd take me a while to unravel :)
14:12:33 <pjd> nmessenger: the idea is, since you can't unreturn
14:12:48 <nmessenger> narain: where scopes over a whole equation, including all guards
14:12:55 <RyanT5000> how do i make a new lexer for Parsec?
14:13:18 <pjd> you wrap the function and its arguments
14:13:20 <narain> nmessenger: ah thanks, i hadn't considered that
14:13:26 <pjd> then join the results
14:13:28 <pjd> or something
14:13:51 <pjd> i just made the types match up without understanding what's going on :)
14:13:53 <nominolo> @hpaste
14:13:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:14:22 <pjd> GHC gives me a "Couldn't match expected type `(->) (m a1)' against inferred type `m' (a rigid variable)"
14:14:39 <fasta> I solved my problem.
14:14:58 <chessguy> post titles like "MPTC and rigid type variables" scare the crap out of me
14:15:05 <fasta> monomorphic pattern bindings.. you have got to love those :(
14:15:41 <hpaste>  nominolo pasted "That's a bug, isn't it?" at http://hpaste.org/832
14:16:04 <nmessenger> pjd: it works for me when I bring Control.Monad.Reader into scope
14:16:13 <pjd> ooh
14:16:25 <pjd> hrm, i have Control.Monad.Instances in scope
14:16:36 <nominolo> could someone confirm/reject that my paste is a bug in ghc-HEAD ?
14:16:50 <narain> > tail []
14:16:51 <lambdabot>  Exception: Prelude.tail: empty list
14:17:02 <pjd> Ambiguous type variable `m' in the constraint: `Monad m' arising from use of `liftM2' ...
14:17:18 <nmessenger> :/
14:18:05 <nmessenger> > let ap x = join . (liftM2 liftM x) . return in ap [(+1),(*2)] [1,2,3]
14:18:06 <narain> > (,2) 1
14:18:06 <lambdabot>  Parse error
14:18:07 <lambdabot>  [2,3,4,2,4,6]
14:18:14 <narain> > ((,) 2) 1
14:18:15 <lambdabot>  (2,1)
14:18:50 <pjd> huh
14:18:55 <pjd> that works
14:19:07 <pjd> but changing it to let ap = \x  -> ...
14:19:08 <pjd> doesn't
14:19:17 <pjd> bug?
14:19:24 <nmessenger> MMR?
14:19:42 <pjd> *blank stare*
14:19:50 <nmessenger> (monomorphism restriction?)
14:20:03 <pjd> i don't understand that yet :)
14:20:17 <pjd> i thought foo x = ... is equivalent to foo = \x -> ...
14:20:25 <nominolo> pjd: just note let /= .\
14:20:29 <nmessenger> I don't understand it either, I just know it sometimes rejects lambdas
14:20:31 <nominolo> ie. lambda
14:20:50 <pjd> nominolo: ?
14:20:53 <nominolo> @go let-polymorphism
14:20:55 <lambdabot> http://www.cs.uwaterloo.ca/~david/cs442/lect-TYPEINFERENCE.pdf
14:21:08 <pjd> nmessenger: wow, it works
14:21:33 <pjd> and i haven't the faintest clue how or why
14:21:46 <nmessenger> liftM2 can be defined in terms of ap, so it's probably twisting around some way or another
14:22:07 <nmessenger> liftM2 f x y = liftM f x `ap` y
14:22:09 <hpaste>  procyon annotated "Combinator List problem with sums" with "Still missing a CDR" at http://hpaste.org/830#a2
14:22:12 <nominolo> pjd: let f x = ... f :: a -> b means, a can be infered for each use of f
14:22:28 <procyon_> sjanssen: I'm still not seeing how to do a CDR here.
14:22:29 <nmessenger> liftA2 f x y = fmap f x <*> y
14:22:36 <Saizan> well, it seems to me you are usign the fact that m >>= f === join (fmap f m)
14:22:41 <nominolo> pjd: while let f = \x -> ...  means always the same f (and type of f)
14:22:51 <nominolo> pjd: which is inferred once
14:22:59 <sjanssen> procyon_: tail (I refuse to use the word cdr :) ), is a little tricky
14:23:17 <sjanssen> procyon_: but with this representation, you want to avoid calling tail at all costs
14:23:31 <pjd> nominolo: oh, really?
14:23:48 <nominolo> pjd: i think it's a type-inference + decidability thing or something
14:24:09 <pjd> so the former infers lazily, and the latter eagerly?
14:24:11 <pjd> so to speak?
14:24:13 <Saizan> pjd: yes, that's whet is called monomorphism-restriction, and it's there for runtime optimization
14:24:25 <pjd> hmm, ok
14:24:28 <sjanssen> procyon_: do you know your foldr's very well?
14:24:40 <nmessenger> > let f = (\x -> x + 1) in (f (1::Int), f (1::Float)) -- trying something
14:24:41 <lambdabot>  Couldn't match expected type `Int' against inferred type `Float'
14:24:52 <Saizan> you can disable it by -fno-monomorphism-restriction
14:24:53 <procyon_> sjanssen: so, without tail, (I use cdr to avoid tromping haskell primitives :)) how would you implement primitive recursion on the list in terms of combinators only?
14:25:24 <procyon_> sjanssen: a bit.  I'm not a foldr guru by any means ;)
14:25:26 <sjanssen> procyon_: the recursion is encoded into the list type
14:25:48 <nmessenger> > let f = (\x -> x + 1); f :: Num a => a -> a in (f (1::Int), f (1::Float))
14:25:49 <lambdabot>  (2,2.0)
14:26:05 <sjanssen> your list of a's :: forall b. (a -> b -> b) -> b -> b
14:26:45 <sjanssen> so you supply two parameters, the function to replace cons cells, and an item to replace the nil at the end
14:27:07 <sjanssen> for sum, you use theList (+) 0
14:28:16 <sjanssen> map f theList = \c n -> theList (\x xs -> c (f x) xs) n
14:28:38 <procyon_> sjanssen: slick.  Something is backwards with mine, as theList 0 (+) gives sum.. but yeah.
14:29:00 <sjanssen> same idea, of course
14:29:15 <procyon_> sjanssen: Much better than I was going for  originally.
14:29:44 <sjanssen> procyon_: as a side effect of writing code this way, you're accidentally learning ghc's fusion system
14:29:48 <monochrom> how to express tail in terms of foldr?
14:30:28 <sjanssen> tailc l = \c n -> l (\x xs b -> b x (xs c)) (const n) (flip const) -- is my definition of tail
14:30:50 <sjanssen> it isn't exactly the same, tail [] = [], instead of _|_, but that's easy to fix
14:30:55 <nominolo> ?type flip const
14:30:57 <lambdabot> forall a b. b -> a -> a
14:31:19 <narain> @pl flip const foo
14:31:20 <lambdabot> id
14:31:25 <narain> :)
14:31:46 <nominolo> pl is clever
14:31:49 <mauke> ?type const id
14:31:52 <lambdabot> forall a b. b -> a -> a
14:31:58 <wkh> it is time to get drunk and play video games!
14:32:02 <sjanssen> tail' l = foldr (\x xs b -> b x (xs (:))) (const []) l (flip const) -- a version thta works on actual Haskell lists
14:34:19 <pjd> ap g x = do f <- g; a <- return x; return (liftM f a)
14:34:39 <pjd> wooh
14:35:01 <nmessenger> that's what I'm working towards
14:35:05 <mauke> a <- return x? wtf?
14:35:30 <nominolo> use let a = x
14:35:35 <mauke> use x
14:35:41 <monochrom> use ap
14:36:01 <monochrom> ?type ap
14:36:02 <wkh> @src ap
14:36:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:36:04 <lambdabot> ap = liftM2 id
14:36:09 <nmessenger> we're trying to figure out how to derive ap from (join . (liftM2 liftM2 fs) . return)
14:36:20 <nmessenger> er, (\fs -> join . (liftM2 liftM2 fs) . return)
14:36:22 <wkh> @src liftM2
14:36:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:36:40 <dmhouse> pjd: ap g x = do f <- g; liftM f x
14:37:02 <pjd> dmhouse: right, i just got that too
14:37:40 <pjd> very nifty
14:37:43 <pjd> but now i must run
14:38:22 <monochrom> (\fs -> join . (liftM2 liftM2 fs) . return) fs xs = (join . (liftM2 liftM2 fs) . return) xs
14:39:15 <mauke> join (liftM2 liftM2 fs (return xs))
14:39:19 <nmessenger> oops, (... (liftM2 *liftM* fs) ...)
14:39:27 <monochrom> OK.
14:40:08 <monochrom> ?type liftM2
14:40:10 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:40:28 <nmessenger> thus do {f <- fs; a <- return xs; return (liftM f a)}
14:41:57 <monochrom> Isn't there a join too?
14:42:13 <nmessenger> yeah, I elided it
14:42:33 <nmessenger> join (... above ...) = join (\fs xs -> do f <- fs; liftM f xs) -- this right?
14:42:57 <monochrom> Delete "\fs xs ->"
14:44:16 <monochrom> there are other typos, e.g., missing "return".
14:44:41 <nmessenger> dmhouse said: ap g x = do f <- g; liftM f x
14:44:47 <nmessenger> oh, nvm
14:45:15 <nmessenger> that's because it doesn't join
14:45:44 <monochrom> Have faith in algebra!
14:45:58 <nmessenger> :D
14:46:04 <dmhouse> Perhaps ap g x = join (fmap ($ x) g)
14:46:16 <nmessenger> I do, I'm just not privy to *all* the identities
14:46:42 <dmhouse> The fmap pops inside the monadic wrapper of g, applies x to it yielding a monadic result, popping out of fmap makes it doubly-monadic then you join it again.
14:47:55 <nmessenger> isn't that ($ x) >>= g?
14:48:10 <dmhouse> Yeah, sounds like one of the monad laws.
14:48:10 <nmessenger> (or flipped)
14:48:29 <dmhouse> ap g x = g >>= ($ x)
14:48:49 <nmessenger> @type \x g -> g >>= ($ x)
14:48:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> m (a -> m b) -> m b
14:49:24 <nmessenger> er, but the inner function is a Kleisli.
14:49:41 <narain> doesn't the second argument of ap have to be monadic as well?
14:49:50 <dmhouse> narain: yes.
14:49:51 <monochrom> fmap = liftM
14:49:55 <monochrom> @src liftM
14:49:56 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:50:15 <dmhouse> narain: remember that the function on the right of >>= has to return a monadic result.
14:50:18 <monochrom> fmap ($ x) g = liftM ($ x) g = m1 >>= return . f
14:50:39 <monochrom> err, g >>= return . ($ x)
14:51:17 <narain> :t fmap
14:51:20 <nmessenger> that's fmap, I was confused, I thought we were talking about ap?
14:51:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:52:00 <monochrom> Someone conjectured ap g x = join (fmap ($ x) g)
14:52:48 <nmessenger> @type \g x -> join (fmap ($ x) g)
14:52:51 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => m (a -> m a1) -> a -> m a1
14:53:13 <monochrom> Ha, busted! :)
14:53:15 <nmessenger> it doesn't have the same type
14:53:27 <narain> that's what i was wondering myself
14:53:49 <nominolo> @where stats
14:53:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
14:54:00 <SamB> @type ap
14:54:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:54:33 <narain> is it possible to express  take  as a fold?
14:55:04 <narain> i'm trying to make a take-like function which will return Nothing if less than n elements were found
14:55:22 <dmhouse> Use a guard.
14:55:33 <dmhouse> Actually, that's a bad idea.
14:55:42 <narain> you mean check the length of the list?
14:56:02 <nominolo> @karma lambdabot
14:56:02 <lambdabot> lambdabot has a karma of 39
14:56:33 <xerox> monochrom: I've done it.
14:56:38 <dmhouse> takeMb (_+1) [] = Nothing; takeMb (n+1) (x:xs) = x : takeMb n xs
14:56:45 <dmhouse> Err,
14:56:57 <monochrom> What have you done?
14:57:01 <dmhouse> No, hang on, that's not going to work.
14:57:06 <xerox> > let tail = app . foldr (\x (f,n) -> (\l -> if l == n+1 then f l else x : f l, n+1)) (const [],0) in tail "monochrom"
14:57:07 <lambdabot>  "onochrom"
14:57:08 <narain> dmhouse: i have written it recursively
14:57:27 <narain> dmhouse: i wanted to see if it could be done with a foldM or someting
14:57:28 <monochrom> ?type app
14:57:31 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
14:57:51 <dmhouse> narain: what have you got?
14:58:07 <narain> > > let maybeTake 0 list = Just []; maybeTake n [] = Nothing; maybeTake n list = liftM (head list :) . maybeTake (n-1) $ tail list in maybeTake 5 [1..10]
14:58:08 <lambdabot>  Parse error
14:58:12 <narain> > let maybeTake 0 list = Just []; maybeTake n [] = Nothing; maybeTake n list = liftM (head list :) . maybeTake (n-1) $ tail list in maybeTake 5 [1..10]
14:58:13 <lambdabot>  Just [1,2,3,4,5]
14:58:57 <narain> i like one-liners using combinators much more than recursion with case analysis :)
14:59:04 <sjanssen> > let take' 0 _ = Just []; take' n [] = Nothing; take' n (x:xs) = fmap (x:) (take' (n-1) xs) in take' 2 [1..]
14:59:05 <lambdabot>  Just [1,2]
14:59:10 <sjanssen> > let take' 0 _ = Just []; take' n [] = Nothing; take' n (x:xs) = fmap (x:) (take' (n-1) xs) in take' 2 [1]
14:59:12 <lambdabot>  Nothing
14:59:15 <narain> so i wanted to see if it could be done with a foldM or something
14:59:16 <mauke> > (\n -> foldl (\z@(m,c) x -> if m == 0 then z else (m-1,c++[x])) (n,[])) 5 [1..10]
14:59:18 <lambdabot>  (0,[1,2,3,4,5])
14:59:33 <narain> > (\n -> foldl (\z@(m,c) x -> if m == 0 then z else (m-1,c++[x])) (n,[])) 5 [1..3]
14:59:34 <lambdabot>  (2,[1,2,3])
14:59:37 <dmhouse> Oh, of course, I was missing an equation.
14:59:57 <narain> mauke: that's interesting
15:01:49 <xerox> monochrom: the app is not an argument to foldr, unsatisfied?
15:02:58 <roconnor> @pl \(a,b) -> (b,a)
15:02:58 <lambdabot> uncurry (flip (,))
15:03:01 <hpaste>  procyon annotated "Combinator List problem with sums" with "Almost there." at http://hpaste.org/830#a3
15:03:11 <xerox> :t (snd &&& fst)
15:03:13 <lambdabot> forall a b. (a, b) -> (b, a)
15:03:32 <procyon_> sjanssen: ok.  I'm still having trouble defining nil and cons though.
15:03:44 <sjanssen> procyon_: nil is flip const
15:03:48 <sjanssen> or \c n -> n
15:03:58 <mauke> no, const id!
15:04:15 <narain> flip const == const id -- that's cute
15:04:31 <roconnor> @type (***)
15:04:33 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:04:34 <sjanssen> procyon_: do you want me to show you cons?
15:04:35 <roconnor> @type (&&&)
15:04:38 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:04:46 <procyon_> yes please ;)
15:05:05 <sjanssen> cons x xs = \c n -> c x (xs c n)
15:05:53 <sjanssen> procyon_: and did you want nil the empty list, or nil the predicate?
15:06:10 <procyon_> nil empty list
15:06:33 <sjanssen> and that is const id (are you happy, mauke?)
15:07:19 <dibblego> I'm trying to compile some old code that depends on System.FilePath.Version_0_11, but I get "Could not find module `System.FilePath.Version_0_11': it is a member of package FilePath-0.11, which is hidden" -- why come?
15:07:39 <dibblego> since: http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php "The interface is still changing, for that reason please use System.FilePath.Version_0_10 or System.FilePath.Version_0_11 which will be guaranteed to work unmodified in future releases."
15:07:42 <lambdabot> Title: Neil Mitchell - Haskell Libraries
15:08:06 <malcolmw> dibblego: because you have a newer version installed, you need to explicitly ask for the older one?
15:08:17 <procyon_> sjanssen: and what is nil the predicate, just so I can sit and stare until my brain catches fire, and have closure?
15:08:21 <dibblego> I just installed that version one minute ago
15:08:40 <malcolmw> dibblego: with ghc -package FilePath=0.11 perhaps
15:08:40 <dibblego> "Registering FilePath-0.11..."
15:08:48 <nmessenger> @type \fs xs -> join (fmap (`fmap` xs) fs) -- close, dmhouse
15:08:51 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => m (a -> a1) -> m a -> m a1
15:09:04 <malcolmw> dibblego: well, ghc knows about it, because it was able to tell that it is hidden
15:09:17 <dibblego> oh wait, maybe I need it in my .cabal file
15:09:24 <kscaldef> I'm getting confused by GHCI... I'm sure this is a FAQ, but doesn't seem to be in the FAQs.  I have a program foo.hs, and I do :l foo.hs and that's all good.  I can run main, but trying to run any other function, ghci complains: "Not in scope: `my_func'"
15:09:46 <kscaldef> help!
15:09:48 <procyon_> sjanssen: nil? l = l const True
15:09:58 <procyon_> sjanssen: correct?
15:10:10 <malcolmw> kscaldef: presumably foo.hs does not export any other function
15:10:11 <augustss> kscaldef: have you exported my_func from foo.hs?
15:10:26 <mauke> kscaldef: is there a foo.o file?
15:10:42 <kscaldef> malcolmw, augustss: no
15:10:42 <sjanssen> procyon_: nullc l = l (const $ const false) true
15:10:52 <kscaldef> mauke: yes
15:10:58 <mauke> try removing it
15:11:00 <procyon_> sjanssen: ahhh. k.
15:11:05 <procyon_> sjanssen++
15:11:11 <malcolmw> kscaldef: there is a way to "enter the scope" of a module and use unexported entities
15:11:16 <augustss> kscaldef: The easiest way is to start Foo.hs with 'module Foo where'.  It will export everything
15:11:34 <dibblego> ?hoogle isSpace
15:11:35 <lambdabot> Char.isSpace :: Char -> Bool
15:11:36 <kscaldef> mauke: that fixed it
15:12:28 <kscaldef> malcolmw, augustss: I've not had this problem debugging other files using ghci
15:12:38 <dibblego> "Could not find module `Char': it is a member of package haskell98, which is hidden" -- WTF?
15:13:01 <kscaldef> so... what effect does the .o have?
15:13:33 <SamB> dibblego: you are supposed to be using Haskell XP or Haskell 2003 server
15:13:34 <mauke> I don't know
15:13:39 <malcolmw> kscaldef: the .o means it has been compiled properly, so only exported fns are available
15:13:41 <SamB> support has ended for Haskell 98, you know!
15:13:50 <dibblego> SamB, wtf?
15:14:00 <SamB> or you could try Haskell Vista if you want
15:14:06 <SamB> but you need a new computer for that
15:14:07 <dibblego> SamB, I thought you were serious (the download comes with .bat files)
15:14:13 <malcolmw> kscaldef: whereas if there is no .o, then ghci must interpret it, so  everything is accessible
15:14:23 <sjanssen> dibblego: are you building a cabal package?
15:14:32 <dibblego> sjanssen, yes
15:14:41 <dibblego> sjanssen, I have Build-Depends:    base, QuickCheck, FilePath
15:15:03 <sjanssen> dibblego: add haskell98, or change your import to Data.Char
15:15:07 <malcolmw> dibblego: in that case, Cabal hides all packages by default, to ensure that you fill in the build-depends line correctly!
15:15:09 <dibblego> oh thanks
15:15:16 <kscaldef> hmm.... naively this seems like a mis-feature.  I'm using the interpreter precisely because I want a level of transparency into the code that's not there in the compiled end-product
15:15:25 <narain> @hoogle (a -> Bool) -> a -> Maybe a
15:15:26 <lambdabot> No matches, try a more general search
15:15:31 <sjanssen> dibblego: I recommend the latter, Data.Char is the way of the future
15:15:39 <dibblego> sjanssen, nod
15:15:47 <malcolmw> kscaldef: but ghci is willing to use compiled files if they exist, e.g. for speed, or in a library
15:16:01 <augustss> "isSpace, the final frontier"
15:16:15 <SamB> > isSpace "the final frontier"
15:16:16 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
15:16:31 <sjanssen> @remember augustss "isSpace, the final frontier"
15:16:31 <lambdabot> Done.
15:16:36 <narain> "is space the final frontier"?
15:16:47 <malcolmw> False
15:16:53 <allbery_b> > and $ map isSpace "the final frontier"
15:16:54 <augustss> > map isSpace "the final frontier"
15:16:55 <lambdabot>  False
15:16:56 <lambdabot>  [False,False,False,True,False,False,False,False,False,True,False,False,False...
15:17:00 <sjanssen> > any isSpace "the final frontier"
15:17:01 <lambdabot>  True
15:17:14 <kscaldef> Again, naively, I'd expect imports in my code to use compiled versions, and perhaps ":l foo" to use a compiled version is available.  But, ":load foo.hs" should load foo.hs, dammit
15:17:20 <dibblego> > most isSpace "the final frontier"
15:17:21 <lambdabot>   Not in scope: `most'
15:17:22 <mauke> and $ map better written as all
15:17:38 <malcolmw> kscaldef: interesting point.  file a bug report!
15:17:57 <augustss> kscaldef: good point!
15:18:21 <procyon_> sjanssen: so what is GHC fusion?  The internal GHC representation of lists?
15:18:41 <sjanssen> @source build
15:18:41 <lambdabot> build not available
15:18:44 <malcolmw> fusion is the anti-list
15:19:25 <sjanssen> procyon_: fusion is the system that ghc uses to eliminate intermediate lists in composition
15:19:30 <sorear> hello.
15:19:38 <procyon_> ic
15:19:50 <sjanssen> for example, map f . filter p creates no intermediate list
15:20:05 <sorear> if you use -O and it's a full moon
15:20:21 <sjanssen> sorear: map . filter is generally quite reliable
15:20:45 <monochrom> It was just a moon eclipse a few days ago.  So I think it's still full moon now. :)
15:20:49 <notsmack> hugs errors aren't helpful, are they?
15:20:56 <procyon_> sjanssen: I was looking into it to eliminate lists in a DSL.. same Idea.  After our discussion I see I was on the right track, but off to the side and in the bushs a bit ;)
15:23:18 <moonlite1> i'm trying out Parsec for a small programming task. And was reading about <|> , a combinator for choice. That would be like mplus right?
15:24:08 <Philippa> moonlite1: yep, in fact it might even be mplus for Parser
15:24:15 <Philippa> Parsec, even
15:24:16 <SamB> it is mplus, yes
15:24:18 <sjanssen> moonlite1: I believe that mplus = (<|>) in Parsec
15:24:27 <moonlite1> cool
15:24:28 <sjanssen> @quote stereo
15:24:28 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:24:36 <moonlite1> :D
15:24:44 <mauke> what is mzero?
15:25:03 <sjanssen> mauke: the failing parser, I imagine
15:25:11 <mauke> which one? :-)
15:25:45 <augustss> pzero?
15:25:49 <Philippa> the smallest one
15:26:02 <Philippa> I'll leave picking an ordering to you :-)
15:26:30 <SamB> you know, it doesn't parse anything and doesn't consume any input?
15:26:36 <moonlite1> hm. And stuff like Parsec and say Data.Map export stuff like <|> and Data.Map.map instead of just mplus and fmap because of non-trivial error-messages?
15:27:02 <Cale> @type Data.Map.map
15:27:04 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
15:27:08 <Philippa> moonlite1: <|> is there because it's more readable to people familiar with parsing and grammars than mplus is
15:27:17 <Cale> Oh, that's interesting.
15:27:32 <dons> morning all
15:27:33 <Cale> That's more general than it used to be, isn't it?
15:27:35 <SamB> it is more readable to most I think
15:27:37 <dons> ?users
15:27:37 <lambdabot> Maximum users seen in #haskell: 339, currently: 318 (93.8%), active: 54 (17.0%)
15:27:58 <moonlite1> Philippa: a reason as good as any. :) thx
15:28:12 <Philippa> SamB: well quite, but it's also the domain-specific name
15:28:27 <SamB> well, yes, it is domain-specific
15:28:52 <Philippa> moonlite1: there're multiple sensible concepts of 'map' for Data.Map, and thus multiple possible Functor instances
15:29:37 <sorear> hello!
15:29:50 <malcolmw> dons: morning
15:30:09 <SamB> Philippa: there are?
15:30:33 <augustss> dons: is the maximum user trend following the projections?
15:30:37 <SamB> @hoogle (a -> b) -> Data.Map.Map k a -> Data.Map.Map k b
15:30:38 <lambdabot> No matches, try a more general search
15:30:47 <Philippa> yeah. You could frig with the keys instead of the values
15:30:47 <dons> augustss: it is, yes.
15:30:51 <dons> the average is now 300.
15:31:05 <SamB> Philippa: I don't think that is allowed as a functor instance...
15:31:23 <augustss> dons: and on what day will everyone on earth be on #haskell?
15:31:28 <malcolmw> dons: know anything about the permissions on summer-of-code trac?  I've had a complaint that a student couldn't edit the wiki after registering and logging in.
15:31:28 <Philippa> why not?
15:31:42 <SamB> :k Functor
15:31:44 <lambdabot> Class `Functor' used as a type
15:31:53 <augustss> feeble!
15:32:00 <SamB> I know!
15:32:36 <augustss> Functor :: (* -> *) -> Class, or something like that
15:32:42 <dons> malcolmw: hmm. don't know about any permission issues
15:33:07 <malcolmw> dons: ok, I'll hassle some other people about it
15:33:44 <sorear> augustss: too used to the niceties of hbc, eh?
15:34:13 <augustss> sorear: hmmm, I'm not sure it was, actually.  I'm just whining in general.
15:34:16 <hpaste>  nmessenger pasted "pjd: derivation of ap" at http://hpaste.org/833
15:35:26 <sorear> is hi still maintained? (not hbi)
15:35:26 <augustss> nmessenger: you're using ETA as if it was valid ;)
15:35:43 <nmessenger> :D
15:35:49 <malcolmw> sorear: as in hmake interactive?
15:35:59 <sorear> malcolmw: yes
15:36:04 <malcolmw> sorear: if so, then I'm responsible
15:37:00 <malcolmw> sorear: why? is it broken?
15:37:51 <pjd> nmessenger: wooo :)
15:38:28 <nmessenger> anyone need proof that x >>= k = join (liftM k x)?  :D
15:39:44 <sorear> malcolmw: no, just thinking of trying it ... it seems similar to an idea of mine
15:40:33 <pjd> ap = liftM2 id reminds me of flip ($) = flip id
15:40:46 <nmessenger> that's because it is!
15:40:51 <nmessenger> ap = liftM2 ($)
15:41:02 <pjd> right :)
15:41:07 <sorear> ($) = id!
15:41:08 <nmessenger> "lifted application" :D
15:41:12 <pjd> type inference is funny
15:41:17 <pjd> sorear: almost!
15:41:27 <sorear> id > ($)
15:41:52 <pjd> what's the test for telling them apart again?
15:41:53 <pjd> i forget
15:41:58 <sorear> > id 4
15:41:59 <lambdabot>  4
15:42:01 <sorear> > ($) 4
15:42:02 <lambdabot>   add an instance declaration for (Num (a -> b))
15:42:11 <pjd> besides that
15:42:23 <nmessenger> um, look at the type?
15:42:24 <sorear> (id undefined) `seq` 2
15:42:38 <sorear> > (id undefined :: (Int -> Int)) `seq` 2
15:42:39 <lambdabot>  Undefined
15:42:44 <sorear> > (($) undefined :: (Int -> Int)) `seq` 2
15:42:45 <lambdabot>  2
15:42:51 <nmessenger> awesome!
15:43:05 <nmessenger> ...in a horrible sort of way
15:43:16 <pjd> there's another way
15:43:52 <allbery_b> @remember nmessenger awesome! ...in a horrible sort of way
15:43:53 <lambdabot> Done.
15:45:01 * nmessenger wants his eta back!  WAAHHH!!  D:'
15:46:01 <sorear> @ysrs
15:46:02 <lambdabot> Maybe you meant: src users yarr
15:46:06 <sorear> @ysres
15:46:06 <lambdabot> Unknown command, try @list
15:46:09 <dcoutts> @tell Mebius re your Gtk2Hs question: I think lots of people use it. For example in the week since the latest release we've had ~140 downloads.
15:46:10 <sorear> @ysers
15:46:10 <lambdabot> Consider it noted.
15:46:10 <lambdabot> Maximum users seen in #haskell: 339, currently: 315 (92.9%), active: 51 (16.2%)
15:47:12 <dcoutts> @tell ToRA you had a Gtk2Hs question? catch me some time or email the gtk2hs-users mailing list
15:47:12 <lambdabot> Consider it noted.
15:48:22 <dcoutts> ndm, oh, yeah, I changed the install location of the .exe and didn't update the link. I'm writing a guide on how to deploy Gtk2Hs apps on your OS of choice.
15:51:31 <sorear> is there some kind of standard parser combinator benchmark?
15:51:42 <astrolabe> [23:45] dcoutts: ndm, oh, yeah, I changed the install location of the .exe and didn't update the link. I'm writing a guide on how to deploy Gtk2Hs apps on your OS of choice.
15:51:46 <ndm_> hi, i'm trying to add a ticket to the SoC wiki, and am failing miserably
15:51:57 <ndm_> "columns ticket, name are not unique"
15:51:58 <dcoutts> astrolabe, hmm?
15:52:15 <astrolabe> dcoutts: I guess ndm might have missed your message
15:52:23 <ndm_> even overlooking the horrible grammar in that error mesage, its impossible to understand
15:52:27 <dcoutts> astrolabe, ah right, ta
15:52:36 <ndm_> astrolabe, thanks - i'm logged in at work and will see it tomorrow morning
15:52:44 <ndm_> just hopped on from home to complain about trac ;)
15:52:45 <sorear> ndm_: the urgent help needed one?
15:52:55 <sorear> ooops read error
15:53:16 <ndm_> sorear, urgent help one?
15:53:46 <ndm_> dcoutts, thanks for fixing the gtk installre - look handy
15:54:18 <sorear> ndm_: sorry, I didn't catch the "error" in your message, I thought you were referring to a very broken english ml post
15:54:54 <dcoutts> ndm, hmm, yes I see that trac error. I manually edited the db earlier to remove the spam, perhaps I needed to update something else.
15:55:21 <ndm_> dcoutts, well i just spent 5 minutes writing a project proposal, and now its not submitting :(
15:55:28 <sorear> @botsnack
15:55:28 <lambdabot> :)
15:55:32 <ndm_> dcoutts, how do i log in to add myself as a mentor?
15:55:56 <mbishop> I love how on reddit all the python kids drool over this IPython
15:55:56 <dcoutts> ndm, erm, not sure that's necessary, or do you mean log on to edit the wiki?
15:56:18 <mbishop> "What is this new 'read eval print loop'? It must be new python technology!"
15:56:44 <ndm_> dcoutts, yes - since the wiki has the mentor list
15:57:37 <dcoutts> ndm, try registering
15:57:47 <dcoutts> ndm, otherwise ask malcolmw, xerox or dons.
16:02:33 <ndm_> dcoutts, registering worked - any idea on the ticket creation thing? worth trying again?
16:02:50 <dcoutts> ndm, I'm looking into it
16:03:21 <ndm_> ok, cool - i'll try again later
16:05:50 <pjd> mbishop: eh?
16:06:07 <mbishop> pjd: what?
16:06:31 <pjd> Python has always had a capable REPL
16:06:40 <dcoutts> ndm, hah, fixed it :-)
16:06:45 <dcoutts> ndm, cunning and hackery
16:07:23 <mbishop> pjd: capable could be debated, but still, people are getting all giddy over this "IPython" thing
16:07:33 <mbishop> which seems to be a cheap knockoff of SLIME + Emacs
16:07:42 <pjd> mbishop: at least as capable as ghci, say
16:07:52 <pjd> IPython's attraction is all its bells and whistles
16:08:15 <pjd> (and it has a lot of them)
16:08:18 <mbishop> ghci isn't very capable, I find :[
16:08:48 <mbishop> Heh, this "synthespian" guy seems to be the new reddit troll of the month
16:16:30 <dons> ?usres
16:16:31 <lambdabot> Maximum users seen in #haskell: 339, currently: 311 (91.7%), active: 41 (13.2%)
16:16:51 <sorear> hm.
16:17:04 <sorear> I'm looking at the uulib stuff now ...
16:17:14 <sorear> why has it so little visibilty?
16:17:44 <dons> lack of publicity
16:17:56 <dons> its not on hackage, for example
16:19:57 <fantasma> Hello!
16:20:03 <sorear> hi.
16:20:18 <sorear> any luck getting linux to like your rc scripts?
16:21:05 <fantasma> nope, I trashed them and I'm going to rewrite them in php
16:21:40 <sorear> php?!
16:21:51 <fantasma> running a site off rc scripts was impractical to begin with
16:21:59 <sorear> methinks Haskell is so much better :)
16:22:21 <fantasma> but I want the app to be portable on all webhosts
16:22:39 <sorear> my webhost doesn't do php
16:22:45 <fantasma> 0.0
16:22:56 <fantasma> ruby?
16:23:02 <sorear> heck, they don't even do ssh/scp
16:23:19 <fantasma> I'm sorry
16:23:33 <sorear> ftp only for uploads, file storage only
16:23:44 <fantasma> but I bet you've got your own set up ;)
16:24:07 <sorear> and there only like the #1 ISP in the US southwest.
16:24:54 <fantasma> which ISP
16:25:01 <sorear> cox
16:25:24 <kscaldef> boggle
16:25:31 <moonlite1> im in need of documentation of the Data.Time modules. The haddock-docs doesn't help me much
16:25:54 <sorear> first, what do you want to do?
16:26:51 <moonlite1> sorear: i'm parsing a date and a time and would like to return a standard Haskell type for that
16:27:23 <dons> so you have the time package?
16:27:29 <dons> ?hackage time
16:27:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/time
16:27:37 <dons> which contains the time parser code.
16:27:50 <dons> hopefully there's a link to the haddocks there somewhere
16:28:02 <gh_> http://paste.uni.cc/13502 <- i have a problem with this piece of code: ghc tells me "test.hs:13:12: The last statement in a 'do' construct must be an expression" (so, at the "nb <- rand_nb" line), and i don't know why (i'm a beginner in haskell)
16:28:25 <sorear> first, hpaste is preferred here
16:28:28 <dons> you'll need to end in a 'return ..' line, to pass back the final value of your function.
16:28:32 <hpaste>  pjd annotated "pjd: derivation of ap" with "pointlessness" at http://hpaste.org/833#a1
16:29:02 <pjd> nmessenger: which do you reckon wins?
16:29:06 <kscaldef> Are the curlies a problem?
16:29:10 <gh_> sorear: ok
16:29:18 <kscaldef> at any rate, they are unnecessary
16:29:50 <sorear> gh_: do you know how to read topic strings in your IRC client?
16:30:15 <gh_> it was hidden on my client, sorry
16:30:32 <sorear> unconditionally or was ours too long?
16:30:41 * SamB wonders if he should use his RML linter in his RML->C compiler...
16:30:57 <fantasma> unbelievable, every single site on page 1 of google query "shortest path algorithm" has a java applet on it :(
16:31:09 <sorear> gh_: it's not just you, an amazing number of people come here without reading the "Paste: http://hpaste.org"
16:31:46 <sorear> gh_: it's irritating, and I don't think there are enough stupid people on earth to explain the effect - what's tripping up the smart people?
16:31:56 <pjd> gh_: you can say "rand_nb = return randomRIO (0,100)", by the way
16:31:57 <kscaldef> sorear: yeah the length is an issue
16:32:05 <SamB> sorear: lack of telepathy?
16:32:19 <SamB> at least they are smart enough to find a pastebin
16:32:20 <kscaldef> I see "The Haskell programming language: this is an"
16:32:32 <sorear> an!?
16:32:35 <sorear> #haskell (+tnc,lag:0) ["The Haskell programming language: this is an monadocracy!","http://haskell.org","Paste: http://hpaste.or
16:32:48 <dibblego> s/an/a
16:32:50 <kscaldef> unless I explicitly pull up more info on the room
16:32:52 <mauke>  ["The Haskell programming language: this is an monadocracy!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/
16:33:35 <nmessenger> @type randomRIO
16:33:37 <lambdabot> forall a. (Random a) => (a, a) -> IO a
16:33:42 <sorear> dons: can you fix the grammatical error in our topic?
16:33:44 <nmessenger> gh_: remove the return
16:34:05 <kscaldef> also, until 5 minutes ago, I actually had no idea what a pastebin was.  I've seen hpaste mentioned, but never saw an explanation of why I would want to go look at it.
16:34:15 <nmessenger> rand_nb = randomRIO (0,100)
16:34:20 <gh_> ok
16:34:31 <sorear> kscaldef: adding that would make the topic too long :)
16:34:31 <kscaldef> perhaps one has to be a big user of IRC already to know your should use such a thing
16:34:59 <kscaldef> which is all to say, I agree with SamB
16:35:08 <nmessenger> gh_: randomRIO already results in an IO Int, so returning it makes an (IO (IO Int))
16:35:13 <gh_> ok
16:35:20 <gh_> so the "do" is not necessary too ?
16:35:47 <nmessenger> do blocks are mainly for connecting together actions
16:35:54 <gh_> ghc prints the same mistake
16:36:02 <nmessenger> if you just have one action, you don't need it
16:36:07 <gh_> ok so in this case it doesn't change anything
16:36:08 <gh_> ok
16:36:37 <nmessenger> @paste your new version on hpaste if you still get an error
16:36:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:36:53 <SamB> : http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]
16:37:12 <hpaste>  gh_ pasted "test.hs:10:12: The last statement in a 'do' construct must be an expression" at http://hpaste.org/834
16:37:14 <LordBrain> hmmm. was the name 'return' chosen simply to make it look like an imperative language?
16:37:55 <nmessenger> gh_: the last line in the do must be an action, so use putStr for example
16:38:03 <nmessenger> (in main)
16:38:28 <nmessenger> also the lack of ';' when you use explicit braces would cause an error.
16:38:46 <mnislaih_> dcoutts: remember the issues with gtk2hs in Mac Os? I dumped a log of my findings at http://pepeiborra.blogspot.com/2007/03/gtk2hs-on-mac-os.html
16:38:48 <lambdabot> Title: blog :: Date -> Maybe String: Gtk2Hs on Mac Os
16:39:05 <mnislaih_> short story: it works perfectly with the MacPorts GHC,
16:39:10 <kscaldef> gh_: you don't need those curlies
16:39:21 <gh_> nmessenger:  still the same error for the 1st hypothesis, but the second one brings changes
16:39:33 <dcoutts> mnislaih_, interesting
16:39:35 <mnislaih_> and more or less I gor it working with my home compiled ghc but dont really know why
16:40:19 <hpaste>  nmessenger annotated "test.hs:10:12: The last statement in a 'do' construct must be an expression" with "use this" at http://hpaste.org/834#a1
16:41:02 <dcoutts> mnislaih_, is your blob syndicated on planet.haskell.org? seems not, it should be!
16:41:23 <mnislaih_> err.. I don't post so much
16:41:30 <gh_> nmessenger: good!
16:41:37 <mnislaih_> I'm not much of a blogger myself
16:41:40 <dcoutts> mnislaih_, s'ok you won't annoy people ;-)
16:41:56 <nmessenger> also you could use the print function, since it equals \x -> putStr (show x)
16:41:57 <dcoutts> mnislaih_, so you can tell everyone else how to make Gtk2Hs work on OSX86
16:42:00 <nmessenger> @src print
16:42:01 <lambdabot> print x = putStrLn (show x)
16:42:16 <gh_> @type show
16:42:19 <lambdabot> forall a. (Show a) => a -> String
16:42:38 <mnislaih_> yeah, only that as a matter of fact I cannot dcoutts  :)
16:44:07 <gh_> nmessenger: thank you
16:48:31 <nominolo> i can't even get gtk compiled using macports :/
16:49:20 <mnislaih_> ouch nominolo
16:49:35 <mnislaih_> how's that, it was pretty easy here
16:49:37 <nmessenger> mnislaih_: awesome blog title and subtitle! :D
16:49:49 <mnislaih_> hah! :)
16:50:12 <mnislaih_> I'm pretty good at titles now that I think :)
16:50:19 <nominolo> mnislaih_: hm, or i aborted it.  but then ghc didn't work.
16:50:35 <nmessenger> though in hindsight I think I'd give it type ... -> Maybe Post
16:50:41 <mnislaih_> ghc takes ages to build using macports
16:51:02 <nmessenger> stronger types and everything :D
16:51:03 <nominolo> btw, mnislaih_ , have you tried building ghc-HEAD on OSX86?
16:51:25 <mnislaih_> yes nominolo, I do that almost every day, or at least when I get some hacking time
16:51:50 <nominolo> wow
16:52:00 <nominolo> ok, i guess you have splitting turned of
16:52:04 <mnislaih_> nmessenger: that depends, if you plan to change the underlying monad on your blog in the future
16:52:21 <nominolo> or some other configuration in mk/
16:52:26 <nmessenger> a Post class? :3
16:52:29 <mnislaih_> yes, I always build with SplitObjs=NO
16:52:46 <nominolo> because straight checkout + ./configure && make didn't work
16:52:56 <nominolo> i filed a bug yesterday
16:53:06 * CosmicRay hopes to have a dozen packages uploaded to hackage shortly
16:53:23 <mnislaih_> nominolo: I believe you need to use -fvia-C to make split objs work again
16:54:08 <nominolo> mnislaih_: yes, or i'll fix it some day.  i wanted to play around with the NCG anyways
16:54:11 <mnislaih_> I think that -fasm is the default now
16:54:29 <nominolo> but not too soon, i'm afraid
16:55:09 <nominolo> yes, it's supposed to be twice as fast during compilation and have little performance impact
16:56:02 <nmessenger> pjd: yours is rather pointless, I'll give you that :D
16:56:49 <pjd> nmessenger: :)
16:57:19 <Zeroth404> > "howdy"
16:57:20 <lambdabot>  "howdy"
16:57:21 <Zeroth404> that sfunny
16:57:23 <Zeroth404> > 6
16:57:24 <lambdabot>  6
16:57:25 <Zeroth404> erm
16:57:27 <Zeroth404> lambdabot: ?
16:57:28 <lambdabot> Maybe you meant: . activity activity-full admin all-dicts arr ask b52s babel bf botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add djinn-clr
16:57:28 <lambdabot> djinn-del djinn-env djinn-names djinn-ver docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq figlet figlet' flush foldoc forecast fortune
16:57:28 <lambdabot> fptools free freshname ft gazetteer get-shapr ghc girl19 google gsite gwiki hackage help hitchcock hoogle hoogle+ id index instances instances-importing irc-connect jargon join karma karma+ karma-
16:57:28 <lambdabot> karma-all keal kind learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on offline oldwiki palomer part
16:57:30 <lambdabot> paste pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc read reconnect redo
16:57:33 <lambdabot> [3 @more lines]
16:57:38 <nmessenger> geh!
16:57:41 <Zeroth404> yeh
16:57:47 <dons> gah
16:57:48 <Zeroth404> yall see what I saw?
16:58:17 <Zeroth404> someone must be goin to town on that thing
16:58:34 <nmessenger> Zeroth404: ? sets off LB's spell checker
16:58:42 <TomMD> @karma dons
16:58:42 <lambdabot> dons has a karma of 128
16:59:04 <nominolo> @karma shapr
16:59:04 <lambdabot> shapr has a karma of 37
16:59:23 <int-e> dons karma overflows signed characters.
16:59:55 <nominolo> > fromIntegral (@karma dons) :: Int8
16:59:56 <lambdabot>  Parse error
17:00:01 <nominolo> :/
17:00:12 <nmessenger> int-e: what a (struggles to find adjective)... interesting observation
17:00:40 <nominolo> especially since it's ASCII
17:01:00 <nominolo> no Unicode Encoding
17:02:21 <pjd> @protontorpedo?
17:02:21 <lambdabot> does haskel work one windows?
17:03:01 <nominolo> @karma-all
17:03:02 <lambdabot>  "audreyt"             322
17:03:03 <lambdabot>  "dons"                128
17:03:03 <lambdabot>  "fglock"               67
17:03:03 <lambdabot>  "putter"               51
17:03:03 <lambdabot>  "glguy"                49
17:03:04 <nmessenger> @. elite protontorpedo
17:03:04 <lambdabot> [801 @more lines]
17:03:06 <lambdabot> CaN I 8uiLd 5O/\/\3+hin9 T|-|a7 |etz |aPT0P usERS zynC (0NTacT5 4ND C1i3n7 dTA o\/3R 7HE N3t?
17:03:33 * nmessenger <3 LB
17:04:01 <nominolo> @karma+ lambdabot
17:04:02 <lambdabot> lambdabot's karma raised to 40.
17:04:14 <Zeroth404> @karma Zeroth404
17:04:15 <lambdabot> You have a karma of 0
17:04:17 <Zeroth404> :(
17:04:46 * Zeroth404 gets a karma for learnign haskell
17:05:45 <nominolo> written your monad tutorial blog-entry yet?
17:05:46 <pjd> @dogma
17:05:47 <lambdabot> Unknown command, try @list
17:05:52 <nominolo> @girl19
17:05:53 <lambdabot> I'm in Moscow, Russia
17:05:57 <CosmicRay> http://hackage.haskell.org/packages/archive/recent.html
17:07:50 <nominolo> @quote lambdabot
17:07:51 <lambdabot> lambdabot says: tERmIN473d
17:08:25 <nmessenger> @quote
17:08:25 <lambdabot> Gahhh says: monads are usually a personal experience.
17:08:45 <fantasma> > (Just 1) + (Just 2)
17:08:46 <lambdabot>   add an instance declaration for (Num (Maybe t))
17:08:47 <lambdabot>     In the expression: (Jus...
17:09:04 <fantasma> > (Just 1) + 2
17:09:04 <nmessenger> > liftM2 (+) (Just 1) (Just 2)
17:09:05 <lambdabot>   add an instance declaration for (Num (Maybe t))
17:09:05 <lambdabot>     In the expression: (Jus...
17:09:06 <lambdabot>  Just 3
17:09:06 <nominolo> ap (+) (Just 1) (Just 2)
17:09:16 <nominolo> > ap (+) (Just 1) (Just 2)
17:09:17 <lambdabot>  Couldn't match expected type `(->) a' against inferred type `Maybe'
17:09:22 <fantasma> cmon we can do it!
17:09:36 * nmessenger did it
17:09:37 <dmwit> > ap Just (+) (Just 1) (Just 2)
17:09:38 <lambdabot>  Couldn't match expected type `a -> t1 -> t'
17:09:46 <fantasma> what
17:10:00 <fantasma> > liftM2 (+) (Just 5) (Just 15)
17:10:02 <lambdabot>  Just 20
17:10:05 <nominolo> nmessenger: wins
17:10:08 <fantasma> he's a genuis!
17:10:08 <nmessenger> > (Just (+)) `ap` (Just 1) `ap` (Just 2)
17:10:10 <lambdabot>  Just 3
17:10:32 <fantasma> :t lines
17:10:34 <lambdabot> String -> [String]
17:10:48 <wkh> :t readFile
17:10:51 <lambdabot> FilePath -> IO String
17:10:54 <dmwit> @. elite > [1..]
17:10:55 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: ">"
17:10:59 <fantasma> @src lines
17:10:59 <lambdabot> Source not found. My pet ferret can type better than you!
17:11:02 <nominolo> oh, ghci/hugs commands work also
17:11:09 <nmessenger> -- > = @run
17:11:19 <nmessenger> nominolo: just :t and :k
17:11:24 <fantasma> @run
17:11:25 <lambdabot>  Parse error
17:11:29 <fantasma> @run 1+2
17:11:30 <lambdabot>  3
17:11:30 <nmessenger> @. elite run [1..]
17:11:32 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:11:45 <fantasma> ...
17:11:49 <fantasma> :t elite
17:11:51 <lambdabot> Not in scope: `elite'
17:11:53 <nmessenger> unawesome!
17:11:55 <dmwit> @. elite run intersect [1..] [0,-1,..]
17:11:56 <lambdabot> PaRSe 3rrOr
17:11:57 <wkh> wtf is elite?
17:12:02 <fantasma> lol!
17:12:04 <wkh> oh, it types waht you say in leetspeak
17:12:05 <fantasma> that's godly
17:12:13 <int-e> wkh: a lambdabot command
17:12:15 <fantasma> @. elite 1
17:12:15 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "1"
17:12:19 <fantasma> @. elite "1"
17:12:20 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "\"1\""
17:12:24 <nominolo> @go wikipedia 1337
17:12:25 <lambdabot> http://en.wikipedia.org/wiki/Leet
17:12:26 <lambdabot> Title: Leet - Wikipedia, the free encyclopedia
17:12:28 <dmwit> @elite 1
17:12:28 <lambdabot> 1
17:12:29 <int-e> wkh: @. cmd1 cmd2 = apply cmd1 to the output of cmd2
17:12:30 <nmessenger> is everyone else as laggy as I?
17:12:43 <fantasma> @hoogle lines
17:12:43 <lambdabot> Prelude.lines :: String -> [String]
17:12:44 <lambdabot> Data.PackedString.linesPS :: PackedString -> [PackedString]
17:12:44 <lambdabot> Text.Html.linesToHtml :: [String] -> Html
17:12:56 <int-e> @. elite index length
17:12:57 <lambdabot> Say again?
17:13:12 <wkh> hey, here's a haskell challenge
17:13:16 <dmwit> ?. elite hoogle length
17:13:17 <lambdabot> pRe1udE.|Eng7h :: [a] -> iNT DAt4.paxxEd$7rING.LEnGThPz :: paCKED$+riNg -> IN7 fOREi9N./\/\4rS|-|41.ARR4y.|3ngtHARR4y0 :: (sToR4B1E A, 3Q A) => a -> PTr A -> Io In7
17:13:25 <dmwit> =D
17:13:32 <fantasma> rofl
17:13:34 <wkh> in Squeak Smalltalk, you can type in sample input and output data and Squeak will try to find a function that gives the desired behavior for the given examples
17:13:41 <wkh> could you do that in haskell?
17:14:06 <dmwit> Like, machine learning?
17:14:16 <nominolo> wkh: you mean theoretically or with an existing tool?
17:14:19 <fantasma> ?. elite ['a'..'z']
17:14:19 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "['a'..'z']"
17:14:21 <dmwit> Or, do you mean, function in the library.
17:14:32 <dmwit> ?. elite run ['a'..'z']
17:14:33 <lambdabot> "A8cD3F9HijxlmN0PQRs7uv\/\/XYZ"
17:14:39 <wkh> i mean it finds a function in the libraries you have installed to get you what you want.
17:14:49 <wkh> nominolo: either
17:14:58 <sjanssen> wkh: we do have tools that find functions based on the types you provide
17:15:04 <nmessenger> like: performMagic [(1,2), (4,5), (7,8)] = (+1)?
17:15:08 <nominolo> well, hoogle can find functions by types
17:15:16 <nominolo> maybe that's close enough?
17:15:18 <fantasma> ?. elite run (1 / 0)
17:15:19 <lambdabot> INphINIty
17:15:25 <wkh> nmessenger: close. that's the basic idea
17:15:31 <wkh> nominolo: yeah that helps
17:15:35 <dmwit> ?djinn (b -> c) -> (a -> b) -> (a -> c)
17:15:36 <lambdabot> f a b c = a (b c)
17:15:51 <nominolo> djinn finds implementations for types
17:16:01 <kpreid> where hoogle is insufficient is finding the right function of type, say, [a] -> [a]
17:16:02 <nmessenger> @. pl djinn (b->c) -> (a->b) -> (a->c)
17:16:03 <lambdabot> f = (.)
17:16:04 <fantasma> can haskell check truth {==} for type signatures?
17:16:05 <kpreid> @hoogle [a] -> [a]
17:16:06 <lambdabot> Prelude.cycle :: [a] -> [a]
17:16:06 <lambdabot> Prelude.init :: [a] -> [a]
17:16:06 <lambdabot> Prelude.reverse :: [a] -> [a]
17:16:09 <nominolo> but not quite "implementations"
17:16:28 <sjanssen> fantasma: there is asTypeOf
17:16:37 <wkh> oh well. whatever. just a thought. Squeak also has a kickass debugger :P
17:16:41 <fantasma> :t asTypeOf
17:16:43 <lambdabot> forall a. a -> a -> a
17:16:51 <fantasma> @src asTypeOf
17:16:52 <lambdabot> asTypeOf = const
17:16:54 <sjanssen> fantasma: yields a static type error if the two things aren't type compatible
17:17:00 <nmessenger> > 5 `asTypeOf` (undefined :: Double)
17:17:02 <nominolo> wkh: well, we'll get to that later on
17:17:02 <lambdabot>  5.0
17:17:09 <sjanssen> fantasma: there is also Data.Typeable (I'm not sure what you want)
17:17:11 <nominolo> maybe ghc 7 or something
17:17:26 <nominolo> i mean until it deserves the "kick-ass" predicate
17:17:34 <fantasma> > [String] `asTypeOf` [[Char]]
17:17:34 <wkh> nominolo: but i want $0 equivalents of tools that cost thousands of dollars _now_ :(
17:17:35 <lambdabot>   Not in scope: data constructor `Char'
17:18:17 <fantasma> @quote
17:18:17 <nominolo> wkh: well, what's wrong with squeak then? ;)
17:18:17 <lambdabot> Samus_ says: FUCKYOU
17:18:36 <sjanssen> > ((undefined :: [String]) `asTypeOf` (undefined :: [[Char]])) `seq` "ok"
17:18:37 <lambdabot>  Undefined
17:18:38 * nmessenger always liked Metroid :(
17:18:43 <sjanssen> oops, wrong
17:18:48 <wkh> nominolo: goofy default interface, can't use existing development toolchain (editors, version control). squeak wants to be its own world, it's very much all or nothing
17:19:14 <sjanssen> > const "ok" $ ((undefined :: [String]) `asTypeOf` (undefined :: [[Char]]))
17:19:16 <lambdabot>  "ok"
17:19:23 <nominolo> wkh: well, true.  but that's often also what makes "kick-ass" predicates possible :/
17:19:34 <fantasma> > const "ok" $ ((undefined :: [String]) `asTypeOf` (undefined :: [[Int]]))
17:19:35 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
17:19:39 <wkh> right. it's turtles all the way down
17:19:41 <fantasma> nice
17:20:02 <nmessenger> asTypeOf doesn't do casting, just type variable specialization
17:20:21 <fantasma> i was just testing
17:20:47 <nmessenger> > cast "Blah!" :: Maybe Int
17:20:49 <lambdabot>  Nothing
17:21:01 <nmessenger> > cast "Blah!" :: Maybe [Char]
17:21:03 <lambdabot>  Just "Blah!"
17:21:19 <fantasma> > null []
17:21:20 <sjanssen> fantasma: did you notice that the definition of asTypeOf doesn't require any magic?
17:21:21 <lambdabot>  True
17:21:31 <sjanssen> @hoogle cast
17:21:31 <nominolo> wkh: heard of COLAs?
17:21:32 <lambdabot> Data.Typeable.cast :: (Typeable a, Typeable b) => a -> Maybe b
17:21:32 <lambdabot> Foreign.ForeignPtr.castForeignPtr :: ForeignPtr a -> ForeignPtr b
17:21:32 <lambdabot> Foreign.Ptr.castFunPtr :: FunPtr a -> FunPtr b
17:21:32 <nmessenger> ...which is pretty much what the cast function does too
17:21:50 <nominolo> alan kays newest(?) project
17:24:02 <nominolo> called "Making COLAs with Pepsi and Coke" (really)
17:24:27 <fantasma> why are there so many zipWith functions...why not just make one zipWithN?
17:24:37 <nominolo> it's about a fully modifyable programming environment
17:24:39 <bd_> fantasma: they're different types
17:24:43 <bd_> :t zipWith
17:24:45 <bd_> :t zipWith2
17:24:46 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:24:47 <lambdabot> Not in scope: `zipWith2'
17:24:49 <bd_> :t zipWith3
17:24:51 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
17:24:54 <fantasma> :t zipWith7
17:24:55 <nominolo> fantasma: because we don't have dependent types ;)
17:24:56 <lambdabot> forall a b c d e f g h. (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
17:25:17 <nominolo> but some sort of macros would help
17:25:30 <sjanssen> you can do it with TH
17:25:37 <nominolo> yep
17:25:50 <sjanssen> and (with effort) MPTCs
17:26:07 <nominolo> MPTC?
17:26:18 <bd_> multi-parameter typeclasses
17:26:28 <nmessenger> define zap = zipWith ($), then zipWith3 f x y z = f `map` x `zap` y `zap` z
17:26:33 <nominolo> oh, oleg-land :)
17:26:33 <dons> sjanssen: window manager code! I want something to hack on in my spare time :-)
17:27:36 <nominolo> dons: couldn't you just "translate" dwm?
17:27:55 <sjanssen> nominolo: that's what I'm doing
17:27:58 <dons> that's what sjanssen's started doing :-)
17:28:17 * QtPlatypus asks "What are good debugging tools to use with ghc?"
17:28:18 <nominolo> hey it's < 10k C-code ;)
17:28:19 <sjanssen> dons: I ruined my Linux partition, so I haven't hacked on it for a week
17:28:46 <sjanssen> through cunning use of strings and less, I managed to save the code :)
17:28:46 <dons> could you just make the code available somewhere? in whatever state?
17:28:52 <dons> wow
17:29:00 <dons> that's super scary.
17:29:03 <dons> you need harchive !
17:29:08 <nominolo> QtPlatypus: for starters Debug.Trace.trace ;)
17:29:22 <dons> i'd really like to hack on it...
17:29:40 <dons> hmm. we need an rss plugin for hackage
17:29:45 <sjanssen> lemme make sure it still builds, and it will be up in a moment
17:29:46 <lispy> yes!
17:29:46 <dons> which pings the channel when new stuff is uploaded
17:29:55 <dons> note all the new stuff: http://hackage.haskell.org/packages/archive/recent.html
17:30:10 <lispy> dons: heh, i don't know about that...would be better if people could subscribe via lambdabot for /msgs
17:30:42 <dons> well, say, 5 msgs a day to #haskell saying "Foo 0.x is on hackage"
17:30:44 <dons> would be nice.
17:31:15 <dons> anyone know what the rss url for hackage is?
17:31:18 <dons> i can't seem to find it
17:31:33 <lispy> heh, that sounds like something i would ask you :)
17:31:55 <dons> it says there's a feed, just can't find any linky
17:32:25 <chessguy> hi haskellers
17:32:32 <dons> ah, /packages/archive/recent.rss
17:32:33 <QtPlatypus> nominolo: Thankyou.
17:32:42 <lispy> chessguy: hi chessguy
17:33:10 <nominolo> QtPlatypus: if you have some time you can try to get the latest ghc and try out the debugger
17:33:35 <nominolo> QtPlatypus: then there's buddha, a declarative debugger, but i haven't tried that either
17:35:28 <hpaste>  jeff pasted "strict readFile" at http://hpaste.org/835
17:35:39 <nominolo> hm, shouldn't happy live in category text on hackage?
17:35:55 <dons> yeah, it was put up before they added categories
17:36:10 <mutjida> Hello. What is a better way to write a strict readFile than what I just pasted?
17:36:26 <nmessenger> foldr seq ()?
17:37:13 <hpaste>  dons annotated "strict readFile" with "less complex strict readfile" at http://hpaste.org/835#a1
17:37:35 <dons> mutjida: how's that?
17:37:44 <dons> the traditional way is to length s `seq` ...
17:37:57 <dons> but i'd probably use Data.ByteString.readFile >>= return . unpack these days
17:38:00 <mutjida> dons: looking...
17:38:19 <dons> we should have System.IO.Strict
17:38:26 <dons> hmm. it 'd be an easy little package to create too
17:38:46 <dons> did i ever mention how nice hpaste is compared to everything single other paste site on the web?
17:38:57 <dons> its fast and clean.
17:39:15 <nominolo> and runs on HAppS (right?)
17:39:17 <nmessenger> I don't recall you mentioning that, no :P
17:39:42 <dons> yeah, 100% haskell running on happs
17:39:49 <mutjida> dons: ok. thanks.
17:40:10 <mutjida> and there should really be a strict IO module.
17:40:30 <dons> yeah. ok. i agree.
17:40:33 * dons creates one
17:40:35 * lispy agrees too
17:41:14 <bd_> Is haskell.org applying for the SoC this year, too?
17:41:23 <dons> we are indeed.
17:41:39 <dons> after being one of the top 10 largest SoC participants lsat year, it'd be funny if we didn't do it again
17:41:45 <bd_> heh
17:41:52 <dons> esp. considering the growth we've had since this time last year
17:42:02 <sjanssen> s/funny/tragic
17:42:04 <sjanssen> ;)
17:42:11 * dons notices we have some SoC guys still here writing code. yay!
17:42:15 * dons points and waves
17:42:27 <TomMD> What are current SoC thoughts, if any?
17:42:37 <dons> right, so the trac is up.
17:43:03 <dons> the best way to get accepted is to propose to work on libraries, imo. and to demonstrate experience in lib and haskell dev
17:43:13 * nominolo just missed to notice where dons pointed to
17:43:20 * dons hunts around for a url
17:43:45 <chessguy> ?where soc
17:43:46 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
17:43:53 <dons> http://hackage.haskell.org/trac/summer-of-code
17:43:54 <lambdabot> Title: Haskell.org Google Summer of Code - Trac
17:43:55 <dons> right
17:44:00 <chessguy> :)
17:44:33 <dons> afaik all students are eligible, including phd and masters students
17:44:38 <dons> and school students
17:44:51 <mbishop> that's a shame
17:44:57 <mbishop> shouldn't be required to be a student
17:45:00 <nominolo> how much time should one usually dedicate?
17:45:03 * mbishop isn't a student
17:45:14 <dons> full time for 2 months would be reasonable.
17:45:29 <lispy> dons: oh i thought it was just undergrads...hmm
17:45:31 <nominolo> hm, when's the final deadline?
17:45:32 <dons> sjanssen: whaddya reckon? a good project is a full time job?
17:45:42 <dons> the applications by students begin next week
17:45:44 <lispy> dons: wonder if i could do my darcs research as a SoC project :)
17:45:49 <dons> indeed
17:45:58 <dons> you should talk to david, lispy
17:46:11 <lispy> i talk to him once a week! ;)
17:46:14 <lispy> yeah, ask him about it
17:46:16 <dons> since the darcs guys are planning their own application (and we'll be happy to umbrella-ify darcs projects)
17:46:17 <lispy> get him to mentor someone
17:46:40 <lispy> i gotta run
17:46:44 <lispy> we should chat about it later
17:47:04 <nominolo> who could be a mentor?
17:47:39 <mbishop> there was a guy in #erlang that said he was a mentor for erlang/CL
17:48:27 <dons> anyone with some project management and haskell experience can volunteer to mentor
17:48:47 <nominolo> hm, ok, then i might ask bringert
17:49:06 <dons> last year it was either academics, or open source haskell people acting as mentors
17:49:14 <sjanssen> dons: yeah, I think that full time is what google is aiming for
17:49:29 <nominolo> do you know when the final project (not application) deadline is?
17:49:33 <nominolo> 1st september?
17:49:38 <dons> check code.google.com/soc
17:49:44 <dons> its around september usualyl, yes.
17:50:03 <nominolo> couldn't find anything there, yet
17:50:06 * nominolo looks harder
17:50:07 <dons>  August 20: Students upload code to code.google.com/hosting;
17:50:08 <dons>  August 31: Final evaluation deadline; Google begins issuing final payments
17:50:20 <dons>  April 9: List of accepted student applications published
17:50:26 <dons>  May 28: Students begin coding; Google begins issuing initial payments
17:50:48 <mbishop> I wonder if that Jane Street Capital stuff will interfere with the ocaml SoC stuff
17:51:39 <nominolo> hm, fits perfectly
17:51:55 <nominolo> and i'd even have a few weeks of for vacation
17:52:04 <wkh> :t return
17:52:07 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:53:24 <dons> hmm. we should get credit suisse to run a haskell soc too
17:53:30 <dons> can't let jane st get all the attention
17:53:42 <dons> augustss_: ... ^ ;-)
17:53:51 <wkh> what does credit suisse use haskell for?
17:55:16 <wkh> *!*@*.adsl.net.t-com.hr is banned
17:55:19 <wkh> that looks like an entire isp
17:55:37 <dons> hmm. seems a bit odd.
17:55:46 <dons> i'l look into that
17:55:58 <wkh> .hr is hungary, right? probably won't affect many users
17:56:08 <mbishop> dons: what the hell was that?
17:56:11 <dons> wkh, see http://haskell.org/haskellwiki/Haskell_in_industry
17:56:13 <lambdabot> Title: Haskell in industry - HaskellWiki
17:56:13 <wkh> then again in a haskell chat room banning all of AOL wouldn't make much difference, either
17:56:21 <dons> mbishop: hmm?
17:56:31 <wkh> <dons> hmm. seems a bit odd.
17:56:31 <mbishop> dons: you had a bunch of non-unicode characters there heh
17:56:36 <dons> oh sorry.
17:56:48 <dons> slow wifi triggers the irssi escape code timeout
17:56:54 <dons> and then metachars go through unfiltered
17:56:55 <wkh> oh sorry, just haxing ur boxen
17:57:00 <mbishop> heh
17:57:08 <dons> if someone knows the irssi setting to extend or disable the timeout?
17:57:36 <dons> 07.03.03:09:04:37 --- mode: xerox set +b *!*@*.adsl.net.t-com.hr
17:57:48 <dmead> ello all
17:58:16 <dons> 09:00:00 <bhz-> I will pay $20 via paypal if you DoS someone for several hours. message me if interes
17:58:19 <dons> ted
17:58:49 <dmead> :o
17:58:51 <dons> so he joined fomr a number ips. hmm
17:58:54 <wkh> d{$_$}b
17:59:02 <sjanssen> dons: darcs get http://darcs.haskell.org/~sjanssen/thunk
17:59:04 <lambdabot> Title: Index of /~sjanssen/thunk
17:59:23 <Pseudonym> I'll bet the intended target is me.
17:59:31 <Pseudonym> Oh, no, .hr, not .ru
17:59:34 <Pseudonym> Not me, then.
17:59:34 <dons> sjanssen: yay!
17:59:38 <mbishop> ping -f Pseudonym
17:59:39 <mbishop> :P
17:59:41 <Pseudonym> Different guy DoSing me.
17:59:50 <wkh> Pseudonym: do you owe the russian mafia money?
17:59:53 --- mode: ChanServ set +o dons
17:59:58 <sjanssen> dons: the permissions should be set such that you can push to it
17:59:59 --- mode: dons set -b *!*@*.adsl.net.t-com.hr
18:00:05 --- mode: ChanServ set -o dons
18:00:14 <Pseudonym> No.  In my case, it's just a blog comment spammer with a misbehaving script.
18:00:17 <dons> so there's a couple of legit users from .hr inside that range
18:00:26 <dons> no need to block them. if this guy comes back we can deal with it.
18:00:32 <dons> woo. /me gets
18:00:40 <wkh> they are hungary for turkey
18:00:41 <Pseudonym> Which launches 100+ requests for the same CGI script within the first second.
18:00:42 <wkh> *rimshot*
18:01:49 <Pseudonym> After about 20 seconds of this, my server dies.
18:01:53 <dons> sjanssen: so what state is it in?
18:02:12 <dmead> ?type any
18:02:14 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:02:19 <Pseudonym> I recently discovered syncookies.  This should help.
18:03:00 <sjanssen> dons: when windows spawn, thunk makes them go fullscreen.  You can switch between windows (alt+tab), and spawn xterms (alt+shift+enter)
18:03:30 <wkh> who is this Kleisli guy and what are Kleisli arrows
18:03:31 <sjanssen> it doesn't handle everything it should, so some applications make it crash (konqueror is one that causes it for me)
18:03:49 <nmessenger> type Kleisli m a b = a -> m b
18:03:56 <xpika> > zipWith ($) (intersperse id (repeat (*100))) [1,2,3,4,5]
18:03:57 <lambdabot>  [100,2,300,4,500]
18:04:06 <nmessenger> a Kleisli is a function that results in a monadic value
18:04:38 <nmessenger> thus (>>=)'s second arg is a Kleisli
18:04:42 <nmessenger> @type (>>=)
18:04:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:05:17 <nmessenger> return is also a Kleisli
18:05:25 <sjanssen> dons: also, it doesn't collect windows that have been started before the wm.  There aren't ffi bindings for those functions yet
18:08:07 <dons> ok. good.
18:08:31 <dons> and the general aim is to reproduce dwm functionality in far less lines, and more obviously correct?
18:08:51 <dons> so if i go ahead and clean/polish/add dwm stuff, that's ok?
18:08:53 <wkh> > let (f >>> g) a = do {b <- f a; g b} in readFile >>> print
18:08:54 <lambdabot>  <[Char] -> IO ()>
18:08:58 <sjanssen> dons: sure
18:09:17 <xpika> i need [1,2,3,4,5] -> [(1,2),(3,4)]
18:09:40 <wkh> > let (f >>> g) a = do {b <- f a; g b} and arr f = return . f in count w = readFile >>> arr words >>> arr (filter (==w)) >>> arr length >>> print
18:09:41 <lambdabot>  Parse error
18:09:44 <wkh> :(
18:09:57 <nmessenger> > (\xs -> zip xs (tail xs)) [1..5]
18:09:59 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
18:10:02 <nmessenger> close
18:10:50 <wkh> how do you introduce multiple temporary variables in a let clause thing
18:11:18 <Botje> just list them on separate lines
18:11:20 <Botje> don't forget the final in
18:11:24 <dons> ?pretty let x = 1 ; y = 2 in x + y
18:11:24 <lambdabot>  i = let x = 1
18:11:24 <lambdabot>          y = 2
18:11:24 <lambdabot>        in x + y
18:11:29 <Botje> and make sure it's laid out correctly
18:11:37 <Botje> also: We _TOTALLY_ need a haskell wM.
18:11:39 <wkh> > let (f >>> g) a = do {b <- f a; g b}; arr f = return . f in count w = readFile >>> arr words >>> arr (filter (==w)) >>> arr length >>> print
18:11:40 <lambdabot>  Parse error
18:11:47 <ClaudiusMaximus> > let f [] = [] ; f [a] = [] ; f (a:b:xs) = (a,b): f xs in f [1,2,3,4,5]
18:11:49 <lambdabot>  [(1,2),(3,4)]
18:11:50 <nmessenger> > let dropEvens = unfoldr (let f (x:_:xs) = Just (x,xs); f _ = Nothing in f) in (\xs -> dropEvens $ zip xs (tail xs)) [1..5]
18:11:52 <lambdabot>  [(1,2),(3,4)]
18:12:07 <wkh> whatever, i'm reading a cool paper that lets you write code like that
18:12:39 <wkh> good golly, it would seem it's possible to make haskell look like an imperative language!
18:13:08 <xpika> wkh: it does if you use IORefs
18:13:15 <wkh> whazdat.
18:13:59 <nmessenger> @src Kleisli (>>>)
18:14:00 <lambdabot> Source not found. Take a stress pill and think things over.
18:14:26 <xpika> > do { x <- newIORef 3 ; modifyIORef x (+1) ; readIORef x}
18:14:27 <lambdabot>   Not in scope: `readIORef'
18:14:33 <xpika> eval that
18:15:04 <wkh> will it make my computer explode?
18:15:31 <nmessenger> int x = 3; x += 1; return x;
18:15:34 <dmead> yes.
18:15:35 <xpika> not if you  :m + Data.IORef in ghci first
18:16:11 <wkh> glayven!
18:16:18 <wkh> it prints 4.
18:16:28 <dons> 14799 dons       2    0 3252K 1456K sleep    poll     0:00  0.00% thunk
18:16:30 <dons> :-)
18:16:34 * dons is running in thunk 
18:16:41 <dons> sjanssen++
18:16:41 <xpika> my only haskell imperative gripe is that record updates arnt first class :(
18:17:06 <nmessenger> xpika: make your own setter functions?
18:17:29 <nmessenger> setBlah x newBlah = x{blah=newBlah}
18:17:34 <xpika> nmessenger: that would defy the `write once` philosophy
18:18:32 <nmessenger> well, "setting" is a rather unusual thing to do in Haskell :)
18:18:35 <sjanssen> dons: you're running thunk as your main wm?!
18:18:44 <monochrom> what would first-class record update look like?
18:19:11 <dons> sjanssen: well, i just tried it out
18:19:12 <xpika> modifyIORef ref { number = 2 }
18:19:18 <dons> seemed to work
18:19:27 <dons> back in dwm now.
18:19:33 <dons> i'l do a walk through the code, adding comments.
18:19:45 <dons> and trying to understand it
18:20:17 <monochrom> I suggest using a record of IORefs (not an IORef to a record)
18:20:52 <monochrom> Then it goes: writeIORef (number myrecord) 2
18:21:00 <dmead> hey channel
18:21:08 <dmead> is there syntactic sugar somewheres
18:21:20 <dmead> for looking at a 1:many relationship for two lists?
18:21:23 <dons> sjanssen: how do you feel about having the src all in the top level, like dwm, to emphasise how small the source is?
18:21:27 <dmead> ie
18:21:40 <dmead> every member in listA compared to every member in listB
18:21:50 <sjanssen> dons: "in the top level"?
18:22:06 <sjanssen> oh, flatten the hierarchy?
18:22:09 <nmessenger> liftM2 compare?
18:22:09 <dons> $ cd dwm-3.7
18:22:09 <dons> $ ls
18:22:09 <dons> LICENSE          client.c         config.mk        dwm.h            main.c
18:22:09 <dons> Makefile         config.arg.h     draw.c           event.c          tag.c
18:22:10 <dons> README           config.default.h dwm.1            layout.c         util.c
18:22:16 <dons> yeah, so we really keep a lid on the src loc.
18:22:17 <Cale> > liftM2 (,) [1,2,3] [4,5]
18:22:19 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
18:22:27 <sjanssen> dons: sure
18:22:37 <dmead> ah
18:22:38 <dmead> yes
18:22:39 <dmead> thank you
18:22:44 <Cale> > and $ liftM2 (<) [1,2,3] [4,5]
18:22:45 <lambdabot>  True
18:22:49 <Cale> > and $ liftM2 (<) [1,2,5] [4,5]
18:22:50 <lambdabot>  False
18:22:55 <dmead> cool :o
18:22:57 <dmead> Cale ++
18:23:13 <Cale> :)
18:23:20 <nmessenger> liftM2 (,) should have a name somewhere
18:23:22 <dmead> saves a few lines there
18:23:23 <Cale> @karma
18:23:24 <lambdabot> You have a karma of 43
18:23:32 <ClaudiusMaximus> > let outer op l l' = [ i `op` i' | i <- l, i' <- l' ]  -- this is how i tend to do it
18:23:32 <lambdabot>  Parse error
18:23:40 <dons> how are you licensing it, sjanssen ?
18:23:53 <Cale> outer = liftM2 :)
18:23:56 <dmead> ?src liftM2
18:23:56 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:24:05 <dmead> ?type liftM2
18:24:08 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:24:19 <nmessenger> where m = []
18:24:37 <ClaudiusMaximus> ?type liftM5
18:24:39 <sjanssen> dons: oh, I forgot!
18:24:40 <lambdabot> forall a1 a2 a3 a4 a5 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
18:24:44 <ClaudiusMaximus> :)
18:24:52 <dmead> module for liftM2 =?
18:24:58 <dons> sjanssen: let me push a patch to the cabal file first
18:24:59 <resiak> @hoogle liftM2
18:24:59 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
18:24:59 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:25:02 <dons> so you don't conflict
18:25:02 <nmessenger> @index liftM2
18:25:03 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:25:04 <xpika> indeed i think liftM2 (,) is concise enough
18:25:04 <sjanssen> dons: BSD3, I suppose
18:25:07 <dmwit> ?h liftM2
18:25:08 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . v
18:25:11 <dons> ok. i'll add that
18:25:29 <nmessenger> oooo
18:25:31 <nmessenger> @help hackage
18:25:32 <lambdabot> Plugin `help' failed with: IRCRaised Plugin/Dummy.hs:(23,19)-(46,62): Non-exhaustive patterns in case
18:25:41 <xpika> liftM2 [1,2,3,4,5] [
18:25:57 <Cale> > liftM2 (+) [1..5] [10..30]
18:25:58 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,12,13,14,15,...
18:26:13 <Cale> > liftM2 (+) [1..5] [10,20..30]
18:26:15 <lambdabot>  [11,21,31,12,22,32,13,23,33,14,24,34,15,25,35]
18:26:48 <dmwit> > liftM2 (+) [1..5] [10,20,30] -- =P
18:26:50 <lambdabot>  [11,21,31,12,22,32,13,23,33,14,24,34,15,25,35]
18:26:56 <nmessenger> > getZipList $ liftA2 (+) (ZipList [1..5]) (ZipList [10,20,30])
18:26:57 <lambdabot>  [11,22,33]
18:27:15 <Cale> > zipWith (+) [1..5] [10,20,30]
18:27:17 <lambdabot>  [11,22,33]
18:27:27 <xpika> @index getZipList
18:27:28 <lambdabot> bzzt
18:27:41 <dmwit> :t getZipList
18:27:41 <nmessenger> the new type is cumbersome, I'd rather have zipWith ($) as a special function
18:27:43 <lambdabot> forall a. ZipList a -> [a]
18:27:45 <Cale> Possibly Control.Applicative.
18:28:06 <Cale> @t zipWith ($)
18:28:06 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
18:28:10 <Cale> @type zipWith ($)
18:28:12 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
18:28:23 <nmessenger> ZipWith's (<*>)
18:28:36 <nmessenger> -List's, rather
18:29:23 <dmwit> > zipWith ($) [(+n) | n <- [1..3]] [7..12]
18:29:24 <lambdabot>  [8,10,12]
18:29:39 <nmessenger> Cale: I think I prefer Control.Applicative's (<$>) for fmap instead of overloading (.)
18:29:49 <dmead> ?src or
18:29:50 <Cale> Oh?
18:29:50 <lambdabot> or    =  foldr (||) False
18:30:07 <Cale> We wouldn't need <$> either. :)
18:30:12 <Cale> er
18:30:24 <Cale> no, <$> is ap
18:30:36 <nmessenger> (<*>) = ap, (<$>) = fmap
18:30:52 <ClaudiusMaximus> is this a reasonable structure for arbitrary-dimensional rectangular arrays?   data Grid a = G [Int] (Array Int a)  -- i don't like it, seems 'error' prone, and the output dimensions are always defined by the input dimensions, so that could be embedded in the type somehow?  without having to write functions for all dimensions...
18:30:58 <Cale> ah, right
18:31:08 <mdmkolbe> does arrow syntax support pattern matching?  (i.e. I want to write an arrow proc that is the equivelent of "foo True = ...; foo False = ..." more directly than having to go through a "case" match)
18:31:15 <mdmkolbe> :t ap
18:31:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:31:20 <Cale> :t (<$>)
18:31:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:31:24 <dons> sjanssen: i think we might be able to get kolmodin to hack on this too. he's into dwm , iirc
18:31:29 <Cale> indeed it is :)
18:31:29 <dons> patches pushed for admin stuff
18:32:07 <dmwit> dons: Is this a plan to reproduce dwm in Haskell?
18:32:08 <nmessenger> (.) is supposed to resemble the function composition operator, so it seems like a stretch to overload.
18:32:18 <dons> sjanssen: so the XlibExtras stuff are bindings for missing functionality in xlib?
18:32:22 <dons> dmwit: right.
18:32:30 <dmwit> AWEsome!
18:32:31 <sjanssen> dons: yes
18:32:32 <Cale> mdmkolbe: arrow syntax supports a sugary form of case
18:32:51 <dons> sjanssen: and that should really be moved into say, xlib-extras package?
18:32:57 <dons> or into xlib itself?
18:33:14 <sjanssen> maybe
18:33:20 <dons> $ wc -l Wm.hs
18:33:20 <dons>       48 Wm.hs
18:33:21 <dmwit> Some people over in #dwm were talking about a Haskell version of dmenu.
18:33:22 <dons> cute :-)
18:33:23 <pjd> nmessenger: function composition resembles functor composition, doesn't it?
18:33:35 <sjanssen> I'm hoping that Sven Panne will write XHB, and then we'll use that
18:33:46 <Cale> (But only if your arrow is an ArrowChoice)
18:33:50 <dons> if we send him the XlibExtras patch that might be motivating
18:34:26 <sjanssen> true :)
18:34:51 <mdmkolbe> dwm = the windows vista equivalent to quarts?
18:35:01 <Cale> hehe
18:35:05 <dmwit> I think dwm == little brother of wmii.
18:35:09 <nmessenger> pjd: What does Functor composition look like?
18:35:11 <dons>                       Code  Comments
18:35:11 <dons> Wm.hs                    33     15
18:35:11 <dons> thunk.hs                 96     13
18:35:11 <dons> TOTAL:                  129     28
18:35:16 <dons> so that's promising
18:35:53 <pjd> nmessenger: i probably speak sloppily; i mean overloading (.) to mean fmap, or whatever
18:36:06 <dons> i'll move the xlib stuff into a new package, xlib-extras
18:36:07 <Cale> http://www.suckless.org/wiki/dwm
18:36:09 <lambdabot> Title: about
18:36:33 <Cale> http://www.suckless.org/shots/dwm-20070224.png
18:36:35 <pjd> which is what you were talking about, innit?
18:36:37 <jcreigh> minimal software is great, so long as it has all the features you want.
18:36:54 <dmwit> Hahaha, the least screenshot-centric program ever...
18:36:59 <dons> http://www.cse.unsw.edu.au/~dons/tmp/dwm.png
18:37:04 <nmessenger> pjd: function composition happens to be fmap in the ((->)r) Functor, but it makes more sense to me as a special case, i.e. overloading the (.) notation seems stretchy.
18:37:07 <Cale> nmessenger: but once you notice that function composition and functorial application are the same...
18:37:27 <jcreigh> dmwit: naw, the least screenshot centric program ever is probably ratpoison.
18:37:39 <dmwit> =)
18:37:58 <hpaste>  moonlite pasted "Parsec Trouble" at http://hpaste.org/836
18:38:19 <moonlite1> please have a check :)
18:38:23 <jcreigh> dwm/wmii look cool, but don't support Xinerama, so it's a non-starter for me. But I like the concept.
18:38:33 <pjd> nmessenger: given the very basic category theory reading i've done, it doesn't seem strange; arrows are composed like that all the time, and the result of fmap (functorials?) are just arrows
18:38:57 <nmessenger> Cale: what's "functorial application"?  I just know that (.) is fmap in ((->)r).
18:38:58 <dmwit> Yeah, the xinerama thing is disheartening.
18:39:09 <Cale> nmessenger: fmap
18:39:22 <Cale> It's the application of the functor in question to the function.
18:39:31 <nmessenger> I see
18:39:41 <Cale> fmap f in mathematical syntax would be T f, where T is the name of the functor.
18:40:16 <dmwit> moonlite1: which line is 38?
18:40:47 <moonlite1> hm sorry. that would be "i <- integer"
18:40:53 <pjd> so it's (.) for arrow/functorial/whatever composition that's general, and its function instance which is the special case
18:41:12 <pjd> (i think)
18:41:38 <hpaste>  moonlite annotated "Parsec Trouble" with "(no title)" at http://hpaste.org/836#a1
18:42:05 <nmessenger> does the function composition notation get used anywhere else for fmap in general?
18:42:29 <mdmkolbe5> @src ArrowChoice.left
18:42:29 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:42:39 <mdmkolbe5> @src (+++)
18:42:40 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:42:56 <mdmkolbe5> @src Control.Arrow.ArrowChoice.left
18:42:57 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:43:04 <mdmkolbe5> @source Control.Arrow
18:43:04 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
18:43:18 <pjd> nmessenger: not in conventional Haskell, i don't think
18:43:56 <nmessenger> pjd: by "anywhere else" I meant outside Haskell
18:45:44 <Cale> It is possible that unifying (.) and map is going too far, I'll admit. It seems strange at first, but like one of those things which you'd quickly get used to.
18:45:46 <pjd> i haven't a clue :)
18:46:02 <Cale> I think it's worth trying :)
18:46:16 <nmessenger> I understand the reasoning, I'm just not sure about overloading the (.) notation.  Anyway, I'm not vehemently opposed or anything, I just wasn't sure.
18:47:22 <Cale> It's possible that it might result in certain cases which ought to be type errors turning into code which runs and does the wrong thing.
18:47:22 <nmessenger> > let (.) = fmap in (*3) . (Node 1 [Node 2 [], Node 3 []])
18:47:24 <lambdabot>  Node {rootLabel = 3, subForest = [Node {rootLabel = 6, subForest = []},Node ...
18:47:34 <jcreigh> how would you unify (.) and map?
18:47:46 <nmessenger> ((->)r)'s fmap = (.)
18:47:47 <Cale> jcreigh: they're both instances of fmap
18:48:27 <nmessenger> type IntReader = (->) Int;  fmap :: (a -> b) -> IntReader a -> IntReader b
18:48:34 <wkh>  this paper started with a motivating example that was slightly uglier
18:48:38 <wkh> the objective was to make it prettier
18:48:41 <Cale> I kind of think it would be nice if (.) and map both meant fmap, fmap went away, and liftM/liftA were relegated to providing convenient default instances of Functor.
18:48:46 <wkh> first he made it prettier, then he made it much uglier
18:48:47 <wkh> :(
18:48:56 <dibblego> you still whinging about that?
18:48:56 <wkh> slightly ugly
18:48:58 <dibblego> :)
18:49:00 <araujo> hello
18:49:28 <Cale> wkh: which paper?
18:49:52 <jcreigh> wow, fmap f g really *is* f . g
18:50:01 <nmessenger> And my opinion was for (<$>) = map and (.) = special case map in ((->) r)
18:50:31 <Cale> But <$> is already like that.
18:50:31 <wkh> cale: "programming with arrows" by john hughes
18:50:44 <nmessenger> Though I'm not so bold as to state my opinion as fact :)
18:50:45 <Cale> So that's the null proposal :)
18:50:46 <dmead> ?src newtype
18:50:47 <lambdabot> Source not found. Take a stress pill and think things over.
18:50:48 <wkh> i checked out a souped up version that has some exercises
18:50:49 <dmead> :s
18:50:58 <Cale> dmead: newtype is a keyword
18:51:00 <nmessenger> Cale: for TheOtherPrelude I mean
18:51:06 <dmead> ah
18:51:15 <Cale> nmessenger: ah, so just move it into the prelude.
18:51:20 <dons> sjanssen: darcs get http://www.cse.unsw.edu.au/~dons/code/X11-extras
18:51:21 <lambdabot> Title: Index of /~dons/code/X11-extras
18:51:26 <dmead> say i have a an algebraic datatype
18:51:33 <dons> sjanssen: do you want to stick that on darcs.haskell.org, next to the 'thunk' repo?
18:51:36 <dmead> and i want a new type based off a subset of it's constructors
18:51:47 <dmead> is that a job for newtype?
18:51:49 <dons> i'm about to push a patch to thunk to switch to depending on the extras pcaakge
18:52:29 <dibblego> is there a take/drop that returns Maybe [a] (Nothing for n > length xs)?
18:52:38 <dibblego> ?hoogle Int -> [a] -> Maybe [a]
18:52:39 <lambdabot> No matches, try a more general search
18:52:44 <Cale> dmead: you could do it -- but only by hiding the constructor for the newtype in a module, and exporting abstracted versions of the constructors on your original type.
18:52:45 <dons> npoe. but easy to roll one
18:52:52 <dibblego> ok ta
18:52:59 <nmessenger> dmead: sounds like subtyping.  newtype might do, but you might also factor out the common constructors into their own type and put that type into one of the constructors for your supertype.
18:53:09 <nmessenger> *phew*
18:53:11 <dmead> hehe
18:53:15 <dmead> actually
18:53:17 <dmead> i tried that
18:53:24 <hpaste>  kapheine pasted "Modifying records" at http://hpaste.org/837
18:53:27 <dmead> and it didn't seem obvious how to do that without breaking tones of other functions
18:53:36 <dmead> ie
18:53:59 <dmead> data Expression = P | Q | Expression :\/ Expression
18:54:07 <dmead> how do you move P and Q out?
18:54:18 <kapheine> Hey.. if anyone has a spare moment, I have a question about records, as hpaste showed, at http://hpaste.org/837.  The question is in the body.
18:54:44 <kapheine> I tried various methods but nothing seems to do what I'm looking for.
18:54:48 <LoganCapaldo> data P = P; data Expression = E P | ....
18:54:59 <Cale> data Expression = Const PQ | Expression :\/ Expression; data PQ = P | Q
18:55:04 <monochrom> "move out"?
18:55:23 <LoganCapaldo> err Cale's is obviously cooler than mine :)
18:55:49 <Cale> kapheine: er, you want a list of new records, or all the changes applied to get one new record?
18:55:52 <dmead> ahh
18:55:59 <nmessenger> :\/ looks like a loudmouth to me
18:56:11 <hpaste>  Cale annotated "Modifying records" with "(no title)" at http://hpaste.org/837#a1
18:56:14 <dmead> that requires Const to be use in constructing expressions right?
18:56:21 <dmead> *explicitly used
18:56:22 <kapheine> Cale; I want the changes all applied to one new record
18:56:22 <Cale> dmead: yes
18:56:23 <LoganCapaldo> yes
18:56:36 <dmead> :>
18:56:41 <Cale> recFinal = aRec {a = "changed0", b = "changed1"}
18:56:43 <dmead> nmessenger: i have parse to cover it up
18:56:46 <dmead> err
18:56:47 <dmead> parsec
18:57:07 <kapheine> Cale: Ah yeah but the key is to have it done in a list, because I will programatically be deciding what transformations happen.
18:57:20 <hpaste>  bd_ annotated "Modifying records" with "how about this?" at http://hpaste.org/837#a2
18:57:33 <kapheine> So I will be inserting various transformations into the list
18:58:16 <Cale> Probably go with bd_'s version then :)
18:58:29 <bd_> note that in that fragment, the first item on the list will take precedence
18:58:46 <bd_> in case you're modifying the same value more than once
18:59:05 <bd_> it's ugly though, someone ought to do something about that :)
18:59:16 <dmead> hmm
18:59:33 <kapheine> Ah, well, that certainly does what I want, thank you both.  I'll see if I can pretty it up using that as a base.
18:59:33 <dmead> can algebraic types be mutually dependant?
18:59:37 <Cale> If you're making a huge number of changes, it might be worthwhile to switch to foldl', in which case, the last change would have precedence.
18:59:37 <kapheine> Not that it is too bad as it is
18:59:57 <kapheine> Nah, the number of changes will be very small (around 5 max)
19:00:07 <dibblego> let take 0 _ = Just []; take _ [] = Nothing; take n (x:xs) = do t <- take (n - 1) xs; return $ x : t in take 12 [1..10]
19:00:13 <dibblego> > let take 0 _ = Just []; take _ [] = Nothing; take n (x:xs) = do t <- take (n - 1) xs; return $ x : t in take 12 [1..10]
19:00:14 <lambdabot>  Nothing
19:00:20 <dibblego> > let take 0 _ = Just []; take _ [] = Nothing; take n (x:xs) = do t <- take (n - 1) xs; return $ x : t in take 1 [1..10]
19:00:22 <lambdabot>  Just [1]
19:00:27 <dibblego> oh it's working now
19:00:42 <bd_> Cale: Wouldn't foldl' and foldr be the same? Since (.) is associative...
19:01:26 <bd_> @check \xs v foldl' (.) id xs v == foldr (.) id xs (v :: Int)
19:01:27 <lambdabot>  Parse error
19:01:33 <bd_> @check \xs v -> foldl' (.) id xs v == foldr (.) id xs (v :: Int)
19:01:37 <lambdabot>  OK, passed 500 tests.
19:01:38 <nmessenger> > foldr (.) id (replicate 99999999 (+1)) 5
19:01:41 <lambdabot>  Exception: stack overflow
19:01:47 <nmessenger> > foldl' (.) id (replicate 99999999 (+1)) 5
19:01:51 <lambdabot> Terminated
19:01:57 <nmessenger> :D
19:02:09 <bd_> well, apart for performance aspects
19:02:11 <bd_> from*
19:02:21 <bd_> @check \xs v -> foldl' (.) id xs v == foldr (.) id xs v
19:02:22 <lambdabot>  Add a type signature
19:02:28 <bd_> lambdabot really should default that
19:02:33 <bd_> ...somehow <.<
19:03:01 <nmessenger> foldl' prevents stack explosion, though
19:03:04 <dmead> ?paste
19:03:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:03:07 <dons> yeah, QC could use the -fextended-defaulting flag
19:03:40 <LoganCapaldo> what if you foldl' (\v f -> f v) instead of folding .?
19:03:56 <nmessenger> flip ($)?  Different type
19:04:00 <bd_> LoganCapaldo: type error :)
19:04:05 <bd_> flip (.) would work
19:04:10 <LoganCapaldo> (and use the initial record as the seed)
19:04:38 <bd_> @check \xs v -> foldl' (.) id (reverse xs) v == foldr (flip (.)) id xs v
19:04:39 <lambdabot>  Add a type signature
19:04:43 <bd_> @check \xs v -> foldl' (.) id (reverse xs) v == foldr (flip (.)) id xs (v :: Int)
19:04:45 <lambdabot>  OK, passed 500 tests.
19:04:53 <bd_> LoganCapaldo: oh, I see. hm. I guess that's work.
19:05:10 <bd_> @check \xs v -> foldl' (flip ($)) id xs v == foldr (flip (.)) id xs (v :: Int)
19:05:10 <hpaste>  dmead pasted "Mutually dependant types?" at http://hpaste.org/838
19:05:11 <lambdabot>  Couldn't match expected type `Int'
19:05:17 <bd_> @check \xs v -> foldl' (flip ($)) v xs == foldr (flip (.)) id xs (v :: Int)
19:05:20 <lambdabot>  OK, passed 500 tests.
19:05:23 <dmead> Cale: check that out
19:05:38 <bd_> LoganCapaldo: looks like it works :)
19:05:42 <nmessenger> oh, ($) then v as the base case?
19:06:31 <LoganCapaldo> huzzah
19:07:06 <sjanssen> dons: done
19:07:09 <Cale> dmead: sure, you can do that
19:07:30 <Cale> dmead: only you need a data constructor
19:07:38 <dmead> eh?
19:07:40 <dmead> if i do
19:07:50 <dmead> P :\/ Q in ghci
19:07:54 <dmead> it fails to construct!
19:07:56 <Cale> Well, that compiles, but those types are not mutually dependent
19:08:02 <Cale> right
19:08:10 <dmead> oh
19:08:13 <nmessenger> Proposition :\/ Proposition :: Expression
19:08:18 <hpaste>  Cale annotated "Mutually dependant types?" with "fixed" at http://hpaste.org/838#a1
19:08:21 <LoganCapaldo> data Singleton = S -- Take that OO, languages!
19:08:24 <Cale> er, sorry
19:08:33 <LoganCapaldo> I think I misplaced my comma
19:08:34 <hpaste>  Cale annotated "Mutually dependant types?" with "oops" at http://hpaste.org/838#a2
19:08:49 <dmead> ah
19:08:51 <Cale> (can't have two things named P)
19:09:03 <dmead> i guess i'm not getting  away with what i really have in mind
19:09:23 <dmead> to have a seperate type for P Q R S and not change anything
19:09:25 <dmead> hehe
19:09:45 <Cale> The compiler has to be able to determine whether something is a Proposition or Expression just by looking at how it's built.
19:10:04 <LoganCapaldo> HMMMMMM
19:10:10 <Cale> (and it can't be both)
19:10:28 <LoganCapaldo> oh no wait you couldn't use that in a pattern match
19:10:30 <nmessenger> LoganCapaldo: EHHH?
19:10:39 <dmead> but then the sort of mutual relationship i have there shouldn't compile
19:10:50 <dmead> if it's really not allowed
19:11:23 <LoganCapaldo> nmessenger I was thinking about a class of which proposition and expression would be instances and P Q R S wouldbe functions
19:11:36 <LoganCapaldo> P :: Expression, P :: Proposition, etc.
19:11:47 <LoganCapaldo> but it wouldn't work for the pattern match
19:11:49 <Cale> dmead: it's not mutual
19:11:57 <LoganCapaldo> So its useless :)
19:12:01 <dmead> :<
19:12:23 <Cale> Expression is both a value and a type, and the value is of type Proposition
19:12:52 <Cale> You're allowed to name data constructors the same thing as existing types.
19:12:59 <dmead> oh
19:13:09 <dons> sjanssen: what docs have you referred to when working thist stuff out?
19:13:10 <Cale> It's as if you wrote data Proposition = X | P | Q | R
19:13:35 <dmead> you mean X as a variable right?
19:13:46 <Cale> X as in just like P
19:14:10 <Cale> "Expression" is just another nullary data constructor there.
19:14:19 <dmead> oh
19:14:28 <dmead> it's not actually a refernce to the Expression type?
19:14:31 <Cale> right
19:14:34 <dmead> ahhh
19:14:45 <Cale> So the types are not mutually referring to one another
19:14:47 <nmessenger> Cale: You mean E?
19:14:53 <dmead> thats odd
19:14:59 <wkh> @pl printAST ast = runQ ast >>= putStrLn . show
19:15:00 <lambdabot> printAST = (putStrLn . show =<<) . runQ
19:15:02 <Cale> nmessenger: that's in the correction, I'm discussing his original code.
19:15:09 <nmessenger> Cale: oh, you're talking about his, gotcha
19:15:12 <dmead> because i've seen it where String or Int can actually be used as a constructor
19:15:19 <dmead> and it will actually mean string
19:15:21 <Cale> dmead: data constructors and type constructors are in separate namespaces
19:15:31 <dmead> hmm
19:15:58 <nmessenger> after a while your eyes get used to switching between "type mode" and "value mode"
19:16:08 <dmead> hmm
19:16:10 <dmead> interesting
19:16:28 <Cale> So you could create a type:
19:16:31 <dmead> i'm guessing it'd be useless to create a new type?
19:16:35 <Cale> data MyType = String String | Int Int
19:17:08 <dmead> oh
19:17:09 <dmead> like
19:17:11 <Cale> Some values in this type would look like: String "Hello", String "", Int 42
19:17:16 <nmessenger> data <Type> = <Value> <Type> | <Value> <Type>
19:17:53 <dmead> ahhh i see
19:18:08 <dmead> but i'd still wouldn't be able to restrict the Expression datatype
19:18:20 <Cale> Not transparently.
19:18:33 <Cale> Subtyping doesn't mix well with HM and type inference.
19:18:51 <dmead> yea i suppose so
19:19:17 <mdmkolbe5> is there a monadic equivalent of using delay with an arrow?
19:19:28 <dmead> what difference would there be to type coersion then
19:20:07 <Cale> mdmkolbe5: er, not in general at least, and I'm not aware of any such thing
19:20:27 <sjanssen> dons: I've been reading man pages and dwm source
19:21:00 <Cale> dmead: hm?
19:21:09 <wkh> do i need to run ghc with any special flags to use template haskell?
19:21:22 <Cale> -fth, I think.
19:21:35 <Cale> yeah
19:21:50 <wkh> ah, right, thought so, guvna
19:21:54 <dons> sjanssen: what's 'gmrun' ?
19:22:11 <dmead> i'm just suggesting that having a dependant type be really flexible like that would be too much like C++ or java polymorphism
19:22:44 <dmead> same thing you said i guess, nevermind :P
19:24:46 <Cale> It makes it hard to sort out which types things should be during inference -- whether they should be treated as members of the supertype or subtype.
19:25:34 <Cale> (and whether the functions applied to them are more or less general)
19:25:40 <dmead> yea i suppose there would have to be some compiler directives or something
19:26:00 <nmessenger> we could always nix the inferencer and annotate everything like mainstreamers do :/
19:26:00 <Cale> You'd end up adding lots of type annotations to straighten things out.
19:26:22 <dmead> #ifdef is your friend :)
19:26:43 <Cale> hm?
19:26:53 <nmessenger> I agree, hm?
19:27:00 <dons> sjanssen: how much of dwm do we implement at the moment?
19:27:10 <LoganCapaldo> ifdef is yucky, mm k?
19:27:11 <dmead> as in, C?
19:27:14 <dmead> hehe
19:27:23 <mdmkolbe5> @src unzip
19:27:23 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
19:27:27 <mdmkolbe5> @src zip
19:27:27 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
19:27:28 <lambdabot> zip _      _      = []
19:27:32 <Cale> I just don't know how that would help here :)
19:27:46 <mdmkolbe5> is there a nonstrict version of unzip?
19:28:10 <mdmkolbe5> (well, other than (foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])))
19:28:14 <dmead> if the compiler can't decide between some types, you'd just have to clue it in
19:28:15 <LoganCapaldo> -Paraphrasing-- Some people when confronted with a problem think, I know, I'll use the C pre processor. Now they have two problems
19:28:32 <nmessenger> dmead: with name :: Type
19:28:55 <dmead> nmessenger: i'm speaking in the context of dependant types that don't exist
19:29:02 <dmead> ie, out my ass
19:29:35 <LoganCapaldo> Sounds painful ;)
19:29:48 <nmessenger> your ass certainly seems to know things I don't understand. :D
19:30:15 <LoganCapaldo> woah
19:30:18 <dmead> lol
19:30:19 <LoganCapaldo> nvm
19:30:28 <dmead> :D
19:30:35 <nmessenger> *fumbles around trying to qualify statement*
19:30:47 <mdmkolbe5> does that make you a smart ass?
19:30:58 * jcreigh groans
19:31:26 * nmessenger EXPLODES!!
19:31:37 <dmead> xD
19:32:59 <jcreigh> sjanssen: is Main.hs and Wm.hs *all* of thunk?
19:34:56 <dons> uh hu.
19:35:01 <jcreigh> nice
19:35:19 <dons> this is why I think we can do better than dwm's 1600 lines of C
19:35:27 <dons> and make some stronger assertions about correctness
19:35:43 <wkh> dons: this is a project you really, really, really wanna do, huh?
19:35:58 <dons> right.
19:36:07 <wkh> have you been dreaming about it
19:36:16 <wkh> watching window management monads do their magic before your eyes
19:36:17 <wkh> ;_;
19:36:20 <dmead> what is dwm?
19:36:21 <dons> not yet, but i've been thinking about it for a few years now.
19:36:29 <jcreigh> @go dwm window manager
19:36:31 <lambdabot> http://en.wikipedia.org/wiki/Desktop_Window_Manager
19:36:36 <jcreigh> err...
19:36:58 <jcreigh> http://www.suckless.org/wiki/dwm
19:37:00 <lambdabot> Title: about
19:37:06 <dmead> first one is a windows component :P
19:37:07 <LoganCapaldo> @go dynamic wm
19:37:10 <lambdabot> http://keck.biology.uiowa.edu/
19:37:10 <lambdabot> Title: W.M. Keck Dynamic Image Analysis Facility
19:37:12 <dons> the second-last word in window manager minimalism
19:37:16 <LoganCapaldo> heh
19:37:29 <dons> ?where+ dwm http://www.suckless.org/wiki/dwm
19:37:30 <lambdabot> Done.
19:37:40 <dmead> mmm
19:37:43 <dmead> please make it pretty :)
19:37:44 <dons> the whole philosophy of dwm is just perfect for haskell
19:37:45 <dmead> and i'll use it
19:37:48 <dmwit> ?where hwm
19:37:48 <lambdabot> I know nothing about hwm.
19:37:49 <wkh> can you still view pr0n in it?
19:37:53 <dons> its all about clean code, small amounts of code and so on
19:37:54 <dmead> apprently
19:37:57 <dons> and correctness
19:38:06 <dmead> but no title bars?
19:38:06 <dmead> o0
19:38:07 <dylan> my dwm is a 1700 lines, but I've added dynamic tagging.
19:38:09 <dons> so currently we're running at:
19:38:11 <dons>                       Code  Comments
19:38:11 <dons> Main.hs                  97     61
19:38:11 <dons> W.hs                     41     57
19:38:11 <dons> TOTAL:                  138    118
19:38:19 <dons> for basic dwm
19:38:21 <wkh> how did you generate that?
19:38:27 <dons> i've a script
19:38:29 <LoganCapaldo> I've played with wmii, like it to a certain extent, never tried dwm
19:38:34 <wkh> can you share plz >_<
19:38:35 <dons> wmii is bloatware ;)
19:38:43 <dmead> kde for the win
19:38:58 <dons> http://www.cse.unsw.edu.au/~dons/tmp/count_lines
19:39:06 <dylan> dons: if you make it so your wm is nearly identical to dwm usage-wise, I'll use it in a heartbeat.
19:39:10 <wkh> w00t
19:39:11 <dons> right. that's the plan
19:39:16 <dons> dwm in 1/4 the code
19:39:16 <wkh> see dons? you give a little, you give a little.
19:39:20 <dmwit> wmii wins for getting closer to allowing arbitrary layouts, though.
19:39:32 <jcreigh> Thanks to firefox, almost any amount of bloat in a WM is not going to matter to me.
19:39:36 <dylan> dons: hopefully with TOPBAR False powers too.
19:39:56 <dons> heh
19:39:56 <LoganCapaldo> I thought wmii won for "plan9 is cool"ness ? :)
19:40:04 <wkh> jcreigh: yes, in the last 18 months i am at peace with the notion of a web browser taking up 200 MB of ram when i have 3 tabs open
19:40:20 <dmwit> No, wmii loses for plan9 filesystem control interface.
19:40:23 <dmwit> Too complicated.
19:40:30 <dons> i wonder how I ever managed to run NTSC mosaic on my 4M mac
19:40:34 <LoganCapaldo> I mean I certainly didn't download it try out its window managing
19:40:39 <dons> it seemed to do everything firefox does. hmm
19:40:46 <dmead> dons: think widgets  man, widgets
19:41:38 <LoganCapaldo> dons: did it have tabs?
19:41:38 <SamB> dmwit: what?
19:41:41 <pjd> dons: it wasn't implemented in Javascript
19:41:49 <dons> ah yes. thta'd be it
19:41:59 <LoganCapaldo> tabs, implemented in javascript?
19:42:08 <LoganCapaldo> glorious javascript
19:42:12 <pjd> LoganCapaldo: not tabs, firefox
19:42:12 <dmwit> SamB: If you can tell me the syntax of all the events off the top of your head, you win a prize... =P
19:42:40 * LoganCapaldo waits for the Mozilla Foundation to realease the all JS desktop environment
19:42:55 <LoganCapaldo> pjd: I know. But the tabs are in js by extension :)
19:43:29 <dmwit> SamB: Scratch that.  What I really mean is, I can do everything I want to do in dwm, without the filesystem interface.  So, why have it when something much simpler will do?
19:43:47 <pjd> LoganCapaldo: actually, they're built in now
19:43:49 * pjd ducks
19:44:02 * LoganCapaldo quaks
19:44:19 <LoganCapaldo> WOuld someone mind picking up that c for me?
19:44:24 <LoganCapaldo>  It's right over there
19:44:30 <SamB> over where?
19:44:32 * pjd collapses
19:44:34 <dmead> o0
19:44:36 <pjd> night everyone
19:44:54 * nmessenger hands Logan his c
19:45:11 <LoganCapaldo> Huzzah. I can make animal noises again
19:45:17 <LoganCapaldo> Thanks
19:45:19 <mbishop> or write buggy code
19:45:20 <mbishop> :P
19:45:25 <nmessenger> No prolem
19:45:40 <SamB> @src liftM4
19:45:40 <lambdabot> liftM4 f m1 m2 m3 m4 = do { x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; return (f x1 x2 x3 x4) }
19:45:40 <nmessenger> :P
19:45:44 <SamB> aww.
19:45:49 <LoganCapaldo> mbishop, I can write buggy code in Haskell too. I just have to try slightly harder :)
19:45:53 <SamB> what was the one with the "ap"s in it?
19:46:03 <nmessenger> @src liftA4
19:46:04 <lambdabot> Source not found. stty: unknown mode: doofus
19:46:07 <nmessenger> @src liftA2
19:46:07 <lambdabot> liftA2 f a b = f <$> a <*> b
19:46:11 <LoganCapaldo> @pl . src liftM4
19:46:12 <lambdabot> (line 1, column 1):
19:46:12 <lambdabot> unexpected "."
19:46:12 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
19:46:29 <dmwit> ?. pl src liftM4
19:46:30 <lambdabot> (line 1, column 1):
19:46:30 <lambdabot> unexpected end of input
19:46:30 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
19:46:33 <nmessenger> @src liftA3
19:46:33 <SamB> I meant, how do you define liftM4 in terms of ap
19:46:33 <lambdabot> Source not found. That's something I cannot allow to happen.
19:46:54 <SamB> ?. . pl undo src liftM4
19:46:54 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
19:46:57 <nmessenger> liftM4 f a b c d = liftM f a `ap` b `ap` c `ap` d
19:47:19 <SamB> @type ap
19:47:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:47:51 * SamB isn't sure that is actually going to help...
19:48:01 <LoganCapaldo> ap confuses me. I can't see where to apply it
19:48:12 <mdmkolbe5> :t ap
19:48:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:48:25 <SamB> @type \f w x y z -> join (liftM4 f w x y z)
19:48:28 <lambdabot> forall a1 a2 a3 a4 (m :: * -> *) a. (Monad m) => (a1 -> a2 -> a3 -> a4 -> m a) -> m a1 -> m a2 -> m a3 -> m a4 -> m a
19:48:35 <mdmkolbe5> LoganCapaldo: ap generalizes liftM, liftM2, etc
19:48:59 <LoganCapaldo> oh shoot
19:49:14 <mdmkolbe5> @type liftM
19:49:17 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:49:26 <LoganCapaldo> @type ap . return
19:49:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
19:49:37 <mdmkolbe5> @type \f a -> f `ap` a
19:49:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:49:55 <mdmkolbe5> @type \f a -> f `ap` (return a)
19:49:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
19:50:03 <dmwit> :t return . return
19:50:06 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => a -> m (m1 a)
19:50:28 <LoganCapaldo> :t join . return . return
19:50:31 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:50:36 <mdmkolbe5> :t ap
19:50:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:50:55 <jaredj> :t _|_
19:50:55 <mdmkolbe5> @type \f a -> (return f) `ap` a
19:50:59 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
19:50:59 <lambdabot> parse error on input `|'
19:51:13 <LoganCapaldo> :t undefined
19:51:16 <lambdabot> forall a. a
19:51:19 <mdmkolbe5> @type \f a b c -> (return f) `ap` a `ap` b `ap` c
19:51:21 <lambdabot> forall a a1 a2 b (m :: * -> *). (Monad m) => (a -> a1 -> a2 -> b) -> m a -> m a1 -> m a2 -> m b
19:51:24 <mdmkolbe5> @type liftM3
19:51:27 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
19:51:31 <nmessenger> liftMn f x1 x2 ... xn = return f `ap` x1 `ap` x2 `ap` ... `ap` xn
19:52:10 <dons> so i'm sitting here in the haskell window manager right now.
19:52:17 <dons> needs some tuning, but things are looking pretty sweet
19:52:20 <LoganCapaldo> are you really?
19:52:24 <Botje> dons: screenshot!
19:52:25 <LoganCapaldo> fantasmatic
19:52:27 <mdmkolbe5> dons: wc?
19:52:39 <dons>                       Code  Comments
19:52:39 <dons> Main.hs                  96     67
19:52:39 <dons> W.hs                     43     62
19:52:40 <dons> TOTAL:                  139    129
19:52:44 <dmead> screenshot?
19:52:48 <LoganCapaldo> main = interactWM
19:52:56 <dons> let's see if i can work out how to do a screenshot
19:52:58 <jaredj> dons, the what?
19:53:29 <jaredj> you said "the haskell window manager" not "a haskell window manager"
19:53:30 <dmead> you should change the default X windows symbol to a lambda :)
19:53:35 <jaredj> as if it's extant
19:53:46 <mdmkolbe> implemented as arrows, monads, boring old haskell?
19:53:47 <jaredj> @google haskell window manager
19:53:48 <lambdabot> http://www.cse.unsw.edu.au/~pls/thesis-topics/windowmanager.html
19:53:48 <lambdabot> Title: Thesis Topic : The Haskell Window Manager
19:53:53 <jaredj> muha, cool
19:54:03 <jaredj> @botsnack
19:54:04 <lambdabot> :)
19:54:06 <dons> ok. so that kind of crashed it.
19:54:31 <jaredj> waaaait a minute
19:54:47 <jaredj> "In this project you will develop a window manager. It will be scriptable in Haskell..."
19:54:53 <dons> man this thing restarts quickly
19:54:58 <jaredj> @botsmack
19:54:58 <lambdabot> :)
19:55:00 <dons> i think it must be the fastest starting wm i've used
19:55:03 <jaredj> lol
19:55:09 <dons> now, about that screen shot.. hmm.
19:55:20 <mdmkolbe> dons: anything interesting about how it's implemented?  Arrows, monad tricks?
19:55:53 <dons> uses a state monad. and the Seq sequence type to hang on to the list of indows
19:56:04 <araujo> dons, just take a pic with your digital camera
19:56:06 <dons> but it should just be very very standard haskell i'm hoping, and concise
19:56:06 <araujo> :-)
19:56:11 <dons> hopefully small enough that we can reason about it
19:56:14 <dons> araujo: ah good idea.
19:56:21 <dons> i actually do have a screen dump, but of the wrong window
19:56:33 <dons> i need to work out the id of the window i want the shot of
19:56:37 <dons> but hey, let's use the camera...
19:56:45 <araujo> yea!
19:56:53 * mdmkolbe2 growls at his wireless
19:56:57 <dmwit> Haha, that output makes it look like there are a total of 139 lines, of which 129 are comments.
19:57:07 <dmwit> Ten-line window manager for the win!
19:57:33 <mdmkolbe2> was there a screenshot while I was down?
19:57:40 <nmessenger> not yet
19:57:43 <mdmkolbe2> dons: anything interesting about how it's implemented?  Arrows, monad tricks?
19:58:03 <bd_> dons: import -window root ?
19:58:16 * mdmkolbe2 crancks the generator on his wireless router to try to stay up
19:58:24 <dmead> main:: screen turn on?
19:58:32 <jaredj> mdmkolbe2: you have a crank? cool
19:58:46 <Botje> mdmkolbe2: his reply was "fairly standard haskell"
19:59:11 <jaredj> how many people made one?
19:59:16 <nmessenger> <dons> uses a state monad. and the Seq sequence type to hang on to the list of indows
19:59:44 <nmessenger> mdmkolbe: still with us? :)
19:59:50 <dons> look at the src yourself,  http://darcs.haskell.org/~sjanssen/thunk
19:59:52 <lambdabot> Title: Index of /~sjanssen/thunk
19:59:52 <dmwit> mdmkolbe,
19:59:57 <mdmkolbe3> thx Botje
20:00:33 <mdmkolbe4> thx Botje
20:00:39 <nmessenger> haha
20:00:46 * mdmkolbe4 needs to crank harder
20:00:48 <jaredj> ah thanks dons
20:02:36 <newsham> http://www.haskell.org/haskellwiki/Programming_performance
20:02:37 <lambdabot> Title: Programming performance - HaskellWiki
20:02:55 <nmessenger> why io = liftIO?
20:03:43 <dons> tradition
20:06:02 <wkh> what do you expect from an inhabitant of a nation of criminals
20:06:45 * chessguy suddenly hears Tevya warbling in the background
20:07:36 <LoganCapaldo> Is sjanssen in australia too? Or was dons directly responsible for io = liftIO ?
20:09:09 <dons> ok. screeny shots! http://www.cse.unsw.edu.au/~dons/tmp/thunk/thunk.png
20:09:35 <sjanssen> LoganCapaldo: no, I'm in the USA
20:09:55 <sjanssen> dons: screen shot of thunk?
20:09:58 <wkh> i love seeing screenshots of people's working environments
20:10:05 <sjanssen> isn't it just going to be your window? :)
20:10:14 <araujo> nice
20:10:17 <wkh> it's the computer equivalent of rifling around in their medicine cabinet
20:10:28 <nmessenger> looks like irssi :D
20:11:07 <nmessenger> good GOD that's a lot of channels!
20:11:34 <jaredj> hooray, it looks like ratpoison
20:11:40 <dons> sjanssen: and i just pushed dmenu support, but the progs aren't executed. any idea why? (hit Alt-p)
20:12:15 <dons> oh, live shots (1M), http://www.cse.unsw.edu.au/~dons/tmp/thunk/thunk-live.png
20:12:23 <dons> that's the digital camera
20:12:43 <jcreigh> dons: points for books in the background
20:12:55 <dons> oh heh, the laptop is also running hmp3, hence the headphones
20:12:59 <dons> its haskell central
20:13:01 <sjanssen> dons: dmenu must require something that dwm doesn't do correctly
20:13:05 <dmwit> That... that looks like it's daylight where you are.
20:13:09 <sjanssen> erm
20:13:11 <jaredj> wuah
20:13:14 <jaredj> daylight
20:13:14 <sjanssen> s/dwm/thunk
20:13:15 <dons> ?time dons
20:13:19 <lambdabot> Local time for dons is Wed Mar  7 15:10:46 2007
20:13:20 <jaredj> yes yes
20:13:29 <jaredj> still odd
20:13:37 <dons> sjanssen: does dmenu pop up nicely for you though?
20:13:45 <jaredj> text from around the world is one thing, pics another :)
20:13:46 <dons> (and do we want to use dmenu here ... seems nice, I must admit)
20:14:10 <sjanssen> I don't actually have dmenu installed
20:14:19 <Cale> thunk?
20:14:26 <sjanssen> Cale: the dwm clone
20:14:29 <jaredj> used to think
20:14:32 <Cale> ah
20:14:49 <Cale> heh, that's a funny screenshot then :)
20:15:25 <sjanssen> dons: I probably need to actually learn something about X11 programming :)
20:15:35 <dons> sjanssen: do you notice a delay on launching xterms too?
20:15:42 <dons> yeah, we might have to work that out at some point
20:17:20 <sjanssen> I can use >= in depends, right?
20:17:27 <dons> yeah.
20:17:29 <SamB> hmm. Compiling RML to Haskell directly is *not* going to work...
20:17:35 <dons> but we want to be cautious right? :-)
20:17:44 * SamB was going to do it to C, but C's syntax is just so icky
20:17:52 <SamB> anyone know what might be a good target?
20:18:12 <SamB> ideally something with proper cases and a smallish compiler?
20:20:07 <dons> ah , my dmenu code might be wrong
20:21:29 <LoganCapaldo> Is there a smallish ML compiler?
20:21:48 <monochrom> moscow ML
20:23:14 <dons> ah yes, typo. not thunk's s fault
20:23:41 <sjanssen> dons: so does dmenu actually display correctly?
20:23:55 <LoganCapaldo> Haskell already has type checking. What it needs now is typo checking
20:24:08 <dons> indeed it does
20:24:23 <sjanssen> nice
20:24:27 <LoganCapaldo> Not to mention typo annotations
20:25:22 <monochrom> dependent typos are the next big thing.
20:25:41 <araujo> cool
20:25:43 <araujo> http://groups.inf.ed.ac.uk/links/
20:25:45 <lambdabot> Title: Links
20:25:50 <wkh> ok, that's it
20:25:54 <wkh> i'm switching from emacs to vim
20:27:31 <dmwit> do tell
20:28:16 * LoganCapaldo feels sudden urge to switch to emacs to balance out the universe
20:28:37 <newsham> if you switch to emacs you can use shim.
20:28:56 <newsham> ?where shim
20:28:56 <lambdabot> http://shim.haskellco.de/trac/
20:29:15 <dons> sjanssen: yeah, dmenu works now
20:29:23 * dons tries to launch firefox
20:29:28 <newsham> on the flip side you'll have to user meta, super and all sortsa weird key combos
20:29:29 <dons> and bingo. yes.
20:29:29 <LoganCapaldo> gasp
20:30:05 <LoganCapaldo> escape meta alt control shift
20:30:10 <Cale> meh, you only really need to know a few of them.
20:30:12 <wkh> i'm on windows
20:30:17 <dons> its funny that dmenu launches immediately, but there's a delay on xterms starting up
20:30:20 <wkh> emacs on windows = misery
20:30:21 <dons> i wonder what's giong on
20:30:24 * QtPlatypus has never used anything beond meta, shift and control, is he a weard emacs user.
20:30:29 <sjanssen> dons: firefox (conkeror, actually) has worked for me too
20:30:44 <newsham> wkh: which one?  i think xemacs in cygwin is ok.
20:30:55 <LoganCapaldo> well escape meta alt is all the same button usually :)
20:31:00 <newsham> i would think that a good win emacs would work well too
20:31:19 <QtPlatypus> a
20:31:25 * LoganCapaldo has used XEmacs under windows to good effect
20:31:41 <newsham> I still prefer vim ;-)
20:32:07 <LoganCapaldo> Vim is slowly converging on emacs anyway
20:32:14 <dmwit> How's shim's vim support?
20:32:32 <LoganCapaldo> one day someone will write a vimscript to emulate emacs's key bindings and it will all be over
20:32:46 <LoganCapaldo> (I mean we're already half way there with cream)
20:33:55 <sjanssen> this is the correct way to launch a window manager on a new display, yeah?  xinit dist/build/thunk/thunk -- :1.0
20:34:03 <sjanssen> dons: is this how you launch thunk?
20:34:14 <dons> i add:   exec thunk
20:34:20 <dons> to the last line of my .xsession file
20:34:28 <dons> exec /home/dons/bin/thunk
20:34:29 <dons> actually
20:34:43 <LoganCapaldo> .xsession is a wunderful thing
20:35:10 <dons> what's gmrun, sjanssen ?
20:35:12 <SamB> wunderful you say?
20:35:16 <sjanssen> I didn't want to override my (working) dwm settings
20:35:28 <sjanssen> dons: it's a little command launcher thing
20:35:35 <dons> ah instead of dmenu?
20:35:42 <newsham> still want powerful but simple haskell based editor
20:36:00 <sjanssen> yeah, it's closer to what I'm used to
20:36:02 <LoganCapaldo> Is there not yi?
20:36:10 <dons> sjanssen: is there any reason not to use [Window] btw?
20:36:13 <newsham> yah, but i dont think yi's there yet.
20:36:28 <dons> it would be nice an elegant (do the window lists ever get big enough to matter?)
20:36:40 <newsham> maybe when the yi authors use yi on a regular basis we can declare it a contender.
20:37:14 <sjanssen> dons: [] is probably fast enough
20:37:32 <LoganCapaldo> the yi authors don't use yi?
20:37:34 <sjanssen> it would make the program 6.4 compatible too
20:37:35 <LoganCapaldo> :(
20:37:56 * LoganCapaldo goes to bed depressed about the realities of the world
20:37:57 * araujo wrote a small haskell editor
20:39:49 <newsham> logan: baby steps.  dont write it off yet
20:39:57 <araujo> it's just a notepad-like editor but written on haskell though
20:40:15 <araujo> http://dev.gentoo.org/~araujo/heditor.png
20:43:31 * monochrom writes a news headline: LoganCapaldo is depressed about the RealWorld#
20:43:38 <dons> sjanssen: does the firefox url bar work? i can't seem to enter input. (the mouse works fine)
20:47:23 <sjanssen> hmm, things are breaking that weren't before
20:47:34 <kapheine> dons: I know ion3 had a longstanding issue with that because of a Gtk bug, dunno if your problem is related
20:47:43 <Botje>                 http://groups.google.com/groups?selm=9q0579%2421c%241%40news-int.gatech.edu&output=gplain
20:47:46 <lambdabot> http://tinyurl.com/oe22e
20:47:46 <Botje>                 http://groups.google.com/groups?selm=9q0579%2421c%241%40news-int.gatech.edu&output=gplain
20:47:48 <lambdabot> http://tinyurl.com/oe22e
20:47:49 <sjanssen> dons: the url bar works for me
20:47:49 <Botje> oh crap.
20:47:52 <Botje> apologies
20:47:54 <kapheine> I think it is fixed in recent versions of Gtk anyway, but you may have an old one
20:48:31 <procyon_> @src fix
20:48:32 <lambdabot> fix f = let x = f x in x
20:48:40 <Botje> http://dev.gentoo.org/~araujo/heditor.png
20:48:41 <Botje> http://dev.gentoo.org/~araujo/heditor.png
20:48:41 <Botje> http://dev.gentoo.org/~araujo/heditor.png
20:48:42 <Botje> http://dev.gentoo.org/~araujo/heditor.png
20:48:46 <Botje> http://dev.gentoo.org/~araujo/heditor.png
20:48:46 <Botje> http://dev.gentoo.org/~araujo/heditor.png
20:48:46 <Botje> http://dev.gentoo.org/~araujo/heditor.png
20:48:47 <Botje> http://dev.gentoo.org/~araujo/heditor.png
20:48:56 <araujo> wta?!
20:48:59 <Botje> asdfbh
20:49:05 * Botje steps away from the keyboard
20:49:13 <araujo> :-|
20:49:19 <monochrom> You have shaky hands?
20:49:27 <Botje> no, keyboard mouse is not liking me.
20:49:35 <fantasma> heditor
20:49:53 <Botje> I apologise for the behavior of my stupid keyboard :[
20:49:56 <fantasma> omg it's e17
20:50:06 <monochrom> It's ok. It's fun. :)
20:50:21 <sjanssen> dons: this code definitely isn't the latest code that I had
20:50:29 <newsham> ?keal
20:50:29 <lambdabot> with KealDigit quantum crackproof encryption possible
20:50:36 <monochrom> You stepped on the "sustain" pedal :)
20:50:48 * sjanssen goes back to sifting through the 5 GB worth of strings output . . .
20:51:49 <monochrom> why the obsession with strings? there are also brass and woodwinds...   (duck)
20:52:03 <dons> sjanssen: :/
20:52:08 <Botje> mm, duck.
20:52:14 <dons> distributed backup via darcs
20:52:17 <Botje> I should've picked duck for dinner n hours ago
20:52:33 <monochrom> You can do again 24-n hours later.
20:52:41 <Botje> myeah
20:52:44 <Botje> real	0m0.000s
20:52:44 <Botje> user	0m0.000s
20:52:44 <Botje> sys	0m0.000s
20:52:48 <Botje> DJEEZ
20:52:49 <monochrom> Modulo arithmetic rocks!
20:52:53 <Botje> Wed Mar  7 05:50:24 CET 2007
20:53:07 <Botje> i've been up since 12 yesterday
20:53:14 <Botje> and no prospect of sleep for the next 12ish hours
20:53:17 <monochrom> I sometimes do that too.
20:53:20 * Botje hugs caffeine
20:53:32 <monochrom> get Darjeeling tea :)
20:53:38 <bos> and you people don't have kids? sheesh. sleep while you can.
20:53:56 <Botje> nope.
20:53:59 <jaredj> ?local botje
20:53:59 <lambdabot> Maybe you meant: localtime localtime-reply docs eval keal lojban
20:54:03 <jaredj> :d
20:54:04 <Botje> Job fair starts in ~ 1h
20:54:06 <jaredj> ?localtime botje
20:54:08 <dons> bos, we've a haskell window manager up and running now
20:54:12 <dons> in fact, i'm using it right now.
20:54:19 <bos> teh roxor!
20:54:19 <jaredj> !LOCALTIME BOTJE
20:54:20 <monochrom> Are you in Germany?  In Germany it is very easy to buy many kinds of teas.
20:54:20 <Botje> hmm
20:54:20 <dons> all in 100 loc :-)
20:54:24 <Botje> 05:51 lambdabot [n=lambdabo@manzano.cse.unsw.EDU.AU] requested CTCP TIME from botje:
20:54:33 <Botje> how do I make irssi reply to a CTCP time? :)
20:54:38 <jaredj> monochrom: do tell
20:54:51 <monochrom> THE END. :)
20:54:57 <Botje> (jaredj: look up, I I pasted my localtime above)
20:55:00 <jaredj> aw.
20:55:03 <jaredj> oh ok
20:55:17 <Botje> monochrom: I'm in Belgium, haven't found time to actually go out and buy tea
20:55:53 <Botje> so it's been mostly lipton stuff and the occasional tea I can get from a friend
20:56:06 <Botje> so far I'm liking Sabah tea and earl grey most
20:56:07 <monochrom> OK, just one more.  I went to Munich.  The main train station had a shop selling many kinds of teas.
20:57:10 <bos> dons: who wrote the wm? sjanssen?
20:57:25 <sjanssen> bos: yeah, I started it
20:57:35 <monochrom> I have found Darjeeling to go very well with learning monads.  OK I'm biased.
20:57:43 <bos> sjanssen: sweet. are you using xcb or xlib?
20:58:03 <sjanssen> bos: xlib, because those are the only existing bindings
20:58:30 <sjanssen> I'd use xhb in a heart beat if Sven Panne writes it
20:58:34 <bos> i look forward to translucent shimmering windows in a few days :-)
20:58:42 <sjanssen> bos: none of that junk!
20:59:09 <monochrom> You will mimick Windows Vista's Aero. :)
20:59:19 <jaredj> bos: translucent shimmering windows are not nearly as interesting when they all take up the whole screen :)
20:59:29 <monochrom> hehehe
20:59:36 <jcreigh> monochrom: oh, crap, does that mean thunk won't be out of beta for five more years? :)
20:59:39 <zeeeeee> anybody tried using HSH? how do you start it directly from the shell? i tried 'ghci HSH' but i get "module `HSH' is a package module". also the wiki says HSH is incompatible with ghci....yet the Goerzen's example session starts with 'ghci -fglasgow-exts HSH'.
21:00:06 <monochrom> I think in haskell it has a somewhat better chance...
21:01:11 <monochrom> If package module, start "ghci -fglasgow-exts", then ":module HSH"
21:01:15 <zeeeeee> (weird thing is ':m HSH' works fine)
21:01:29 <zeeeeee> monochrom: yeah, i was wondering if there's a way to load modules from the cmd line
21:01:58 <monochrom> Not weird at all.  :load or command line for non-package modules (i.e., the source code is right in your cwd).  :module for package modules.
21:02:12 <zeeeeee> monochrom: so no cmd line for pkg modules?
21:02:18 <monochrom> No.
21:02:38 <zeeeeee> monochrom: then do you know what's up with Goerzen's example?
21:03:00 <monochrom> He has the source code right in his cwd, I suppose?
21:03:55 <zeeeeee> monochrom: is there a reason why starting with a pkg module loaded doesn't make sense?
21:04:15 <zeeeeee> monochrom: or is this an implementation issue?
21:05:27 <fantasma> foobar2000!
21:05:53 <monochrom> I now think it is an implementation decision that can be easily changed.
21:07:36 <fantasma> cirlce of life (from lion king) is such a great song
21:07:40 <jaredj> wha? foobar2000 quite cool
21:07:58 <jaredj> schakooooo whenyaa aaaaaaa
21:08:20 <jaredj> COOO OOOCA COLAAA
21:08:21 <jaredj> oh wait
21:08:53 <jaredj> when the choir first comes in i always think of a cool refreshing coke
21:09:28 <fantasma> linux would be perfect if it had foobar2000 and EAC
21:09:44 <jaredj> @google eac
21:09:47 <lambdabot> http://www.exactaudiocopy.de/
21:09:47 <lambdabot> Title: EAC - Exact Audio Copy
21:09:49 <monochrom> what are they?
21:09:59 <jaredj> foobar2000 is a very simple, but powerful audio player + tagger
21:10:11 <jaredj> eac... cd ripper?
21:10:18 <monochrom> someone has the gut to call it foobar2000?
21:10:30 <fantasma> jaredj, yea
21:10:42 <jaredj> cdparanoia is fine for me
21:10:52 <jaredj> and eac just maximized its own browser window. -karma
21:11:15 <fantasma> haha
21:11:26 <jaredj> and the fonts are reeally teeny
21:13:18 <fantasma> @quote
21:13:18 <lambdabot> <skew> says: also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
21:13:29 <fantasma> @quote
21:13:30 <lambdabot> Conor says: We could all sit in a long line with laptops, and talk to each other on #haskell
21:13:43 <jaredj> whoa, these tests of ripping on different drives on the EAC page look well-done
21:13:55 <fantasma> @google eac
21:13:56 <lambdabot> http://www.exactaudiocopy.de/
21:13:56 <lambdabot> Title: EAC - Exact Audio Copy
21:13:58 <jaredj> speaking of laptops
21:14:04 <jaredj> anyone run linux on a powerbook g4?
21:14:31 <jaredj> i'm thinking about it
21:14:34 <fantasma> why
21:15:18 <fantasma> unless you already own a powerbook -- don't go out and buy one just to put linux on it
21:15:20 <thedward> I ran Linux on by iBook g3 before it died.
21:15:22 <jaredj> errr ibook g4.
21:15:27 <jaredj> not pb.
21:15:43 <jaredj> it seems to be of high quality, and i like powerpc's
21:15:57 <jaredj> because, you know, i write assembly language all the time
21:16:13 <fantasma> @google "potassium hydrogen phthalate"
21:16:14 <lambdabot> http://en.wikipedia.org/wiki/Potassium_hydrogen_phthalate
21:16:19 <fantasma> perfect
21:16:23 <fantasma> @karma+ lambdabot
21:16:24 <lambdabot> lambdabot's karma raised to 41.
21:17:33 <thedward> the main thing I miss about my iBook was the virtually instand sleep/wake
21:17:49 <jaredj> under macosx right?
21:19:22 <fantasma> don't buy a laptop, just buy a notebook and a pencil and write down 0's and 1's
21:19:37 <jaredj> fantasma: no backlight
21:19:42 <fantasma> hahaha
21:19:45 <jaredj> :)
21:20:19 <jaredj> that would sort of put to rest the questions of bluetooth and wifi support and quick sleep/wake
21:20:49 <jaredj> heh one of my friends still hasn't managed to come up with an implementation for IPoV
21:21:11 <jaredj> (speaking of wireless communication)
21:23:08 <fantasma> > 0.002364 / 0.0028
21:23:10 <lambdabot>  0.8442857142857144
21:24:29 <jaredj> > take 50 $ repeat 1
21:24:31 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:24:36 <jaredj> wise
21:24:48 <lispy> > filter (==1) $ repeat 1
21:24:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:25:21 <jaredj> huh?
21:25:25 <nrb23> > filter (/=1) $ repeat 1
21:25:26 <lambdabot>  Exception: <<loop>>
21:25:32 <jaredj> > show True
21:25:33 <lambdabot>  "True"
21:25:38 <fantasma> > 23.64 / 1000
21:25:39 <lambdabot>  2.364e-2
21:25:46 <jaredj> > show (1==1)
21:25:47 <lambdabot>  "True"
21:25:54 <nrb23> > showString "hot grits"
21:25:55 <lambdabot>  <[Char] -> [Char]>
21:25:56 <newsham> > show me the money
21:25:57 <lambdabot>   Not in scope: `money'
21:25:58 <jaredj> oh, right
21:26:04 <jaredj> heh
21:26:06 <fantasma> $ echo hi
21:26:37 <jaredj> harhar:
21:26:40 <jaredj> > show me the deer
21:26:41 <lambdabot>   Not in scope: `deer'
21:26:50 <nrb23> so, I was reading an article today that claimed the GHC type-checker took up more code than the Hugs one
21:27:02 <fantasma> @. elite run ['a'..'z']
21:27:04 <lambdabot> "AB(dEph9|-|IJklMN0pqrz7U\/wxYz"
21:27:05 <jaredj> nuh uh!
21:27:18 <jaredj> ?
21:27:26 <jaredj> ohh
21:27:51 <newsham> does magnus irc?
21:27:59 * jaredj goes off along to bed now, night all
21:28:03 <fantasma> @seen magnus
21:28:03 <lambdabot> I haven't seen magnus.
21:28:10 <fantasma> Good Night friend
21:28:23 <newsham> fantasma: now how do you ask it what nickname magnus uses on irc?
21:28:28 <sieni> > let {me = ('$':); the = me; money = "$"} in show $ me $ the $ money
21:28:29 <lambdabot>  "\"$$$\""
21:28:32 <sieni> hmm...
21:28:52 <fantasma> newsham, not sure
21:28:54 <monochrom> Nice
21:29:09 <nrb23> sieni: :->
21:29:11 <monochrom> @remember sieni let {me = ('$':); the = me; money = "$"} in show $ me $ the $ money
21:29:11 <lambdabot> Done.
21:29:29 <newsham> > let motor sound = sound "vroom! " in motor cycle
21:29:31 <lambdabot>  "vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom...
21:29:38 <fantasma> LOL
21:29:56 <nrb23> :t cycle
21:29:59 <lambdabot> forall a. [a] -> [a]
21:30:04 <newsham> > cycle "abc "
21:30:05 <lambdabot>  "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc...
21:30:25 <fantasma> > cycle . cycle . cycle $ "abc"
21:30:26 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
21:30:36 <fantasma> > cycle . cycle . cycle $ Just Nothing
21:30:37 <lambdabot>  Couldn't match expected type `[a]'
21:30:45 <fantasma> > cycle . cycle . cycle $ [Just Nothing]
21:30:46 <lambdabot>  [Just Nothing,Just Nothing,Just Nothing,Just Nothing,Just Nothing,Just Nothi...
21:32:22 <fantasma> 0.2931 g acid / (0.02468 L * 0.117 mol/L)
21:32:34 <fantasma> > 0.2931 / (0.02468 * 0.117)
21:32:36 <lambdabot>  101.50438432448156
21:33:45 <monochrom> @remember newsham let motor sound = sound "vroom! " in motor cycle
21:33:45 <lambdabot> Done.
21:34:13 <fantasma> @quote
21:34:13 <lambdabot> weitzman says: Sometimes it's ok to polish diningware with a hammer, as long as it gets the job done
21:34:34 <fantasma> @quote
21:34:34 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
21:34:36 <monochrom> wow
21:34:51 <nrb23> @karma+ newsham
21:34:51 <lambdabot> newsham's karma raised to 5.
21:35:00 <nrb23> @karma + sieni
21:35:01 <lambdabot> + has a karma of 10
21:35:10 <newsham> where can I spend this?
21:35:28 <fantasma> @karma- fantasma
21:35:28 <lambdabot> You can't change your own karma, silly.
21:35:33 <nrb23> newsham: you can spread the wealth :->
21:35:35 <newsham> ?quote newsham
21:35:35 <lambdabot> newsham says: haskell's like chess.  easy to learn. hard to master.
21:35:49 <nrb23> ?quote nrb23
21:35:50 <lambdabot> No quotes match. My mind is going. I can feel it.
21:35:51 <fantasma> good quote :)
21:36:04 <fantasma> ?quote fantasma
21:36:04 <lambdabot> fantasma says: does haskell curry ever stop by here?
21:36:10 <fantasma> :(
21:38:14 <sieni> a nerd restaurant certainly should have a meal called "haskell curry"
21:38:38 <newsham> would you eat it?
21:38:49 <newsham> seems irreverant and perhaps unsanitary and unethical
21:39:01 <nrb23> I'd be worried it contained infinite noodles
21:39:09 <newsham> "you have to try the shitty soup"
21:39:24 <fantasma> has anyone here implemented the dancing links algorithm in haskell?
21:39:48 <nrb23> I've only implemented the forbidden dance :->
21:40:44 <monochrom> Please don't serve the corpse of Haskell in curry.
21:41:06 <monochrom> But red wine sauce is fine by me.
21:41:27 <fantasma> monochrome without the e
21:41:35 <newsham> part of a turing complete meal
21:41:44 * monochrom goes cut out some beef into the lambda shape
21:42:02 <monochrom> Oh I have a better idea!
21:42:07 <sjanssen> @tell dons just pushed the missing handler code.  @tell me if your xterms still launch slowly
21:42:08 <lambdabot> Consider it noted.
21:42:12 <newsham> lamb-da?
21:42:25 * monochrom goes out and buy some lamb and some curry.
21:42:37 <monochrom> "Lamb da Curry"!
21:43:02 <newsham> perfect for the church-rosser potluck
21:44:30 <sjanssen> @seen dons
21:44:30 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 50m 11s ago.
21:45:17 <sjanssen> okay, #haskell, what do I implement next?  Dynamic window layout, or multiple workspaces?
21:45:32 <fantasma> tiling windows
21:45:33 <nrb23> sjanssen: multiple workspaces
21:46:03 <nrb23> sjanssen: writing an X11 Window Manager?
21:46:07 <monochrom> rotating windows
21:46:09 <sjanssen> nrb23: that is correct
21:46:13 <sjanssen> @where thunk
21:46:13 <lambdabot> I know nothing about thunk.
21:46:23 <sjanssen> @slap monochrom
21:46:24 <lambdabot> why on earth would I slap monochrom
21:46:29 <monochrom> haha
21:46:36 <nrb23> @slap nrb23
21:46:36 * lambdabot beats up nrb23
21:46:39 <nrb23> hmm
21:46:43 <nrb23> @slap pambdabot
21:46:43 * lambdabot beats up pambdabot
21:46:45 <monochrom> windows without borders
21:46:49 <nrb23> @slap lambdabot
21:46:49 * lambdabot smacks lambdabot about with a large trout
21:47:06 <nrb23> why wouldn't it slap monochrom ?
21:47:07 <sjanssen> @where+ thunk darcs get http://darcs.haskell.org/~sjanssen/thunk/
21:47:08 <lambdabot> Done.
21:47:10 <nrb23> @slap monochrom
21:47:11 * lambdabot beats up monochrom
21:47:13 <nrb23> ah
21:47:13 <monochrom> I need windows without borders.
21:47:20 <nrb23> 'cause it's bored
21:47:46 <rahikkala> Style * !Borders
21:47:48 <monochrom> It is great for xeyes.
21:47:53 <fantasma> i'm switching to thunk
21:48:21 <monochrom> And I will tell you why I want xeyes without borders.
21:48:27 <rahikkala> ... since the fact is, no matter what language you implement it in, no window manager can be better than FVWM :)
21:48:33 <sjanssen> fantasma: you might want to wait a couple weeks
21:48:41 <sjanssen> fantasma: or help us hack!
21:48:49 <sjanssen> @seen RemiTurk
21:48:50 <lambdabot> I haven't seen RemiTurk.
21:48:53 <fantasma> sjanssen, I don't think you want that ;D
21:48:56 <sjanssen> @seen Remii
21:48:57 <lambdabot> I haven't seen Remii.
21:49:03 <monochrom> I have a stuffed animal.  Large eyes.  I have a pic of it as my computer screen background.  Now I want to fit xeyes to its eyes...
21:49:16 <fantasma> haha that's awesome
21:49:31 <monochrom> "It's coming to life!" :)
21:49:53 <fantasma> why dont use psuedo-transparency on xeyes
21:50:45 <monochrom> Yes that too.  But the border is the biggest bother.
21:51:10 <fantasma> if you were using thunk you could fix that yourself
21:51:16 <monochrom> yeah
21:51:43 <fantasma> we'll add thunk to portage tomorrow
21:53:29 <fantasma> sjanssen, have you tried compiling it?
21:54:30 <dons> i wouldn't bother adding it to portage yet.
21:54:30 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
21:54:32 <dons> wait for a release
21:55:02 <sjanssen> fantasma: thunk? yes, I have
21:55:25 <fantasma> it's functional?
21:55:33 <sjanssen> fantasma: kinda
21:55:38 <fantasma> > 10**(-9.2)
21:55:39 <lambdabot>  6.309573444801942e-10
21:56:03 <dons> i'm running it now
21:56:08 <dons> and have been all day
21:56:17 <dons> 30730 dons       2    0 3088K 1496K sleep    poll     0:00  0.00% thunk
21:56:28 <dons> don to 122 loc :-)
21:56:32 <kolmodin> morning!
21:56:42 <dons> kolmodin: you wanted to work on a dwm clone, no?
21:56:47 <kolmodin> aye
21:56:49 <fantasma> dons, how's it look like
21:56:53 <sjanssen> dons: no crashes?
21:56:54 <dons> well, its working. dive in.
21:56:59 <kolmodin> thunk, yay
21:57:08 <fantasma> thunk is a dwm clone?
21:57:10 * kolmodin has darcs got it
21:57:10 <dons> sjanssen: exiting 'xv' kills it (subprocess dieing not caught/)
21:57:26 <sjanssen> dons: pull, and it may work
21:57:29 <dons> there's some screenshots at www.cse.unsw.edu.au/~dons/tmp/thunk/
21:57:51 <dons> i refactored to use lists, and am trying to find some nice combinators to better express the window popping stuff
21:58:02 <dons> No remote changes to pull in! ?
21:58:20 <dons> or wsa the patch to the -extras?
21:58:22 <kolmodin> haha, screenshots, yeah.. :)
21:58:31 <kolmodin> sjanssen: good work
21:59:25 <fantasma> a dwm clone written in haskell would be fantastic
22:00:04 <kc5tja> Won't be long before an OS coded in Haskell appears.
22:00:11 <sjanssen> dons: I forgot to push, but now there are conflicts.  I'll push the changes in a moment
22:00:12 <fantasma> (especially w/ dynamic window tiling)
22:00:15 <kc5tja> And I'm not talking about HOUSE, which apparently has vanished from the web.
22:00:52 <dons> ?where house
22:00:53 <fantasma> i was thinking that if I made an OS in haskell i would call it House
22:00:53 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
22:00:55 <bd_> kc5tja: http://programatica.cs.pdx.edu/House/
22:00:57 <lambdabot> Title: House
22:01:13 <bd_> hm, both lead to the same place
22:01:17 <kc5tja> I'd rather call it HaskOS or some such.
22:01:28 <kc5tja> Then you could say things like, "HaskOS!  The Function Maker!"
22:02:37 <bobwhoops> Hi, I know LISP is popular for AI stuff. Is haskell good for it too?
22:03:09 <dons> its just a general purpose language. i'd imagine pattern matching on data structures might help though.
22:03:34 <fantasma> haskell is a modern LISP no?
22:03:45 <bos> no.
22:04:07 <Cale> fantasma: In some sense, but the difference is very very large.
22:04:26 <dons> its about hmm. 1977-2007, 30 years more modern.
22:04:33 <Cale> Haskell formalises many things which lisp programmers were doing for a long time.
22:05:04 <Cale> Haskell is more closely related to ML
22:05:12 <Cale> and really has its roots in ISWIM
22:06:17 <bos> iswim -> krc -> miranda -> haskell, more or less.
22:06:17 <Cale> @go next 700 programming languages
22:06:21 <lambdabot> http://www.cs.cmu.edu/~seanmcl/life/papers/landin_700.pdf
22:07:03 * fantasma will look at paper when he has enough memory to open pdf reader
22:07:13 <monochrom> woooo another landin paper!
22:07:31 <Cale> I like how the where clause as a programming construct dates back to 1966.
22:07:42 <Cale> and how it's still around in Haskell.
22:08:03 <fantasma> > 0.145 / (0.02537 * 0.100)
22:08:04 <dancor> "ISWIM can be looked on as an attempt to deliver LISP from its eponymous commitment to lists, its reputation for hand-to-mouth storage allocation" etc
22:08:05 <lambdabot>  57.15411903823413
22:08:23 <Cale> You have this syntactic construct which has been preserved through that entire history.
22:08:30 <sjanssen> dons: now you can pull
22:08:43 <Pseudonym> Cale: The Fortran COMMON block dates from earlier and it's still around.
22:09:06 <triplah_w> Cale: the same could be said for "goto"
22:09:18 <triplah_w> :P
22:09:29 <dons> sjanssen: you know, i think we can aim for something like 200 loc
22:09:38 <Cale> Sure :)
22:09:48 <dons> kind of stunning really. what is dwm doing??
22:10:10 <fantasma> 10,000
22:10:11 <fantasma> i think
22:10:26 <dons> dwm is currently 1600 lines of C.
22:10:32 <sjanssen> dons: wc -l says 273 right now
22:10:35 <fantasma> my mad
22:10:42 <dons> TOTAL:                  146    127
22:10:43 <sjanssen> and there are still a handful of things dwm doesn't do yet
22:10:52 <sjanssen> right, comments and whitespace
22:10:56 <dons> yeah. maybe the font / colour stuff gets tricky.
22:10:58 <sjanssen> s/dwm/thunk
22:11:09 <dons> multiple workspaces
22:11:13 <dons> still, doesn't seem terribly hrad.
22:11:17 <fantasma> tagging
22:11:23 <triplah_w> is it possible to compile hs into .so ? :P
22:11:42 <triplah_w> or create a compileable interface?
22:11:47 <sjanssen> fantasma: I don't plan to implement tagging
22:12:01 <dons> sjanssen: we can derive MonadState WState
22:12:02 <fantasma> it's such a great feature
22:12:04 <dons> saves a few lines
22:12:09 <sjanssen> dons: there's also the question of float
22:12:13 <dons> i don't use tags
22:12:15 <dons> ah yes.
22:12:36 <sjanssen> dons: I'm reluctant to derive MonadState
22:12:41 <dons> why's that?
22:12:51 <dons> the explicit use of W is a bit irksome
22:13:21 <sjanssen> we may need to go multithreaded at some point, and StateT ActualState will become ReaderT MvarsWithState
22:14:05 <kolmodin> sllocount says 148 lines
22:14:18 <kolmodin> *sloccount
22:18:18 <dancor> dons: should i just add any missing vim bindings to yi that i come across
22:19:07 <sjanssen> dons: so what are you hacking on now
22:21:00 <sjanssen> dons: the next thing I'm going to write is existing window querying at startup
22:21:20 <kolmodin> and by tags you mean to have one window on several virtual windows?
22:21:32 <kolmodin> I don't use that either
22:22:15 <sjanssen> then you can put while [[ 1]]: thunk in your .Xsession, making for a poor man's error recovery system
22:22:53 <kolmodin> aye
22:23:53 <dons> dancor: yes.
22:24:04 <dons> sjanssen: ok. i'm going to work on left/right window movement.
22:24:33 <dons> i'm hesitatn about multithreaded though.
22:24:40 <dons> seems overkill when we're almsot there :-)
22:24:52 <dons> oh, its much better with those new patches
22:25:06 <dons> xv exits cleanly now, and xterms pop up immediately
22:26:02 <dons> ok. i'm just (for now) going to derive MonadState. we can undo it if we want, but it just saves so much code, it seems worth it.
22:26:31 <dons> so left/right movement, then maybe look at workspaces
22:26:34 <sjanssen> dons: I anticipate wanting multithreaded for the status bar
22:26:37 <triplah_w> it'd be possible to access compiled haskell libs from C wouldnt it?
22:26:55 <dons> sjanssen: so not the dwm-status style? where we just read stdin from a process?
22:27:11 <sjanssen> dwm uses select to simultaneously poll stdin and the X handle
22:27:11 <dons> hmm. that's a good point though.
22:27:22 <dons> ah ok. so we'll need a thread there
22:27:25 <sjanssen> I think that'd get pretty ugly
22:27:28 <triplah_w> select ... poll?
22:27:57 <triplah_w> is there no haskell wrapper to select?
22:28:09 <dons> yea, its called forkIO
22:28:13 <kolmodin> triplah_w: there is no need
22:28:16 <triplah_w> with select you shouldnt to poll
22:28:16 <sjanssen> triplah_w: yeah, select is used transparently in the threading system
22:28:31 <triplah_w> dons, sjanssen ahh i see
22:28:39 <triplah_w> thats even better
22:28:57 <triplah_w> select in "principle" is great
22:29:02 <triplah_w> its a pain to code thoughy ;)
22:29:05 <triplah_w> though*
22:29:26 <dons> the status bar could be thread local state
22:29:41 <dons> so multithreaded, but the statusbar/stdin thread never touches the W state
22:30:56 <sjanssen> dwm's status bar highlights the current workspace, that requires some shared state
22:31:36 <dons> ah yes. its a window onto the state
22:32:26 <sjanssen> window titles are rendered in the status bar too
22:32:47 <dons> yeah. so there's shared state. hmm. so a shared field in the WState?
22:32:54 <dons> with a lock on it?
22:33:46 <sjanssen> perhaps
22:33:56 <sjanssen> a message passing approach might be better
22:34:55 <sjanssen> it might just be better to use select
22:35:35 <sjanssen> but that means cbits :(
22:36:01 <dons> I think we should use a Haskell thread with an MVar or STM. that's worked for lots of other things.
22:36:08 <kolmodin> poor mans concurrency.. :)
22:36:12 <dons> just have to think about the state a bit
22:36:53 <kolmodin> dons: that would be the classical approach, yeah
22:37:13 <sjanssen> can you block on an MVar and a handle simultaneously?
22:37:45 <dons> so the reader thread can wait on the Handle, when it gets input it blocks on the state till that's free to update
22:37:53 <dons> then it updates, and loops
22:39:33 <cpfr> hey when i try to load haskell-mode emacs tells me it cant find it
22:40:38 <ftegularius> cpfr: not sure if this is the right channel, maybe #emacs, but, is haskell-mode.el in your load-path?
22:40:52 <cpfr> yes
22:41:02 <ftegularius> are you doing (load "haskell-mode")?
22:41:16 <cpfr> autoload
22:41:37 <ftegularius> does it work if you manually load?
22:41:57 <cpfr> how would i manually load?
22:42:11 <ftegularius> when you do a (load "haskell-mode") or (require 'haskell-mode)
22:42:25 <allbery_b> M-: (load "haskell-mode")
22:42:43 <allbery_b> or M-x load-library haskell-mode
22:42:49 <ftegularius> yes
22:43:05 <cpfr> says cant load
22:43:08 <cpfr> cant find
22:43:22 <ftegularius> it must not be in your load-path
22:43:31 <allbery_b> did you copy the files to somewhere in your load path, or add it to your load path?
22:43:48 <cpfr> i thought i added it to a local path
22:43:54 <cpfr> how can i check my local path
22:44:01 <ftegularius> cpfr: you have to add it to your load path, do this in emacs
22:44:21 <ftegularius> Ctrl-h v
22:44:28 <ftegularius> and then type "load-path"
22:44:41 <ftegularius> all files loaded by emacs have to be in one of the dirs in that list to be found
22:45:04 <ftegularius> so, either put it in one of those dirs, or create some dir of your own and add that to the load-path in your .emacs
22:45:40 <cpfr> ok
22:46:03 <sjanssen> dons: I just pushed my plan for the statusbar
22:47:22 <dons> ok
22:47:41 <dons> i think im' just about done with left/right rotation (code's getting shorter)
22:49:46 <bobwhoops> I use ctrl-x
22:49:53 <bobwhoops> err
22:49:55 <bobwhoops> wrong channel
22:50:22 <cpfr> still no luck
22:50:24 <dons> sjanssen: ok. this is usable enough for me to switch for my daily stuff now
22:50:27 <robreim> Does parsec have a MonadTrans implementation?
22:50:39 <sjanssen> robreim: no
22:50:41 <dons> i'd need dwm for floating. and will need workspaces. and a statusbard eventually
22:50:45 <dons> that's about it .
22:51:09 <robreim> sjanssen: oh ok. Is there a reason?
22:51:12 <ftegularius> cpfr: did you move the file, or create your own dir and add it?
22:51:27 <cpfr> i added the dir to load-path
22:51:31 <sjanssen> robreim: it's theoretically possible, but nobody has written it
22:51:46 <robreim> sjanssen: ok, thanks.
22:51:53 <ftegularius> cpfr: check load-path again with Ctrl-h v, is it there?
22:52:29 <cpfr> how do i have emacs reload the .emacs if i changed it
22:52:44 <dons> sjanssen: ok. alt-j/-k work for rotation left and right now.
22:52:52 <dons>                       Code  Comments
22:52:52 <dons> Main.hs                 105     59
22:52:52 <dons> W.hs                     34     70
22:52:52 <dons> TOTAL:                  139    129
22:53:02 <triplah_w> nice
22:53:03 <dons> so hmm. workspaces.
22:53:06 <ftegularius> cpfr: you can just do (load ".emacs")
22:53:13 <robreim> cpfr: M-x load-file ?
22:53:22 <cpfr> thanks
22:53:22 <sjanssen> dons: [[Window]]? ;)
22:53:29 <sjanssen> plus an Int, I suppose
22:53:33 <dons> we just want integer keys right?
22:53:54 <dons> IntMap [Window] ?
22:53:57 <sjanssen> dons: no, 2^31 - 1 workspaces is plenty for me, thanks
22:54:21 <dons> yeah, Map Word8 [Window] is overkill :-)
22:54:32 <sjanssen> Data.Sequence will keep the index invariant more easily
22:56:12 <cpfr> ok works
22:56:16 <cpfr> that was weird
22:56:30 <ftegularius> cpfr: what was?
22:57:14 <cpfr> that i had to put the load-path higher in the .emacs file
22:57:30 <cpfr> thanks for the help
22:57:33 <ftegularius> np
22:57:54 <dons> hmm. sjanssen my firefox bar still isn't taking focus.
22:58:08 <dons> oh, and we need killClient
22:58:18 <cpfr> dons that last haskell hacking article was kickass
22:58:25 <dons> cheers
23:00:19 <cpfr> yep
23:01:02 <newsham> ?seen sorear
23:01:03 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc, #haskell and #happs 6h 4m 24s ago, and .
23:01:38 <sjanssen> dons: hopefully that will go away once we handle everything that dwm does
23:02:05 <dons> i see killclient is:
23:02:06 <dons>     if(isprotodel(sel))
23:02:06 <dons>         sendevent(sel->win, wmatom[WMProtocols], wmatom[WMDelete]);
23:02:06 <dons>     else
23:02:06 <dons>         XKillClient(dpy, sel->win);
23:02:16 <dons> do we have everything we need to do that?
23:04:16 <sjanssen> dons: we'll have to FFI XKillClient
23:05:05 <dons> ok
23:05:43 <dons> ah i see, -- XKillClient omitted
23:05:49 <dons> Graphics.X11.Xlib.Misc
23:07:22 <dons> returning Int in ffi calls isn't 64 bit safe
23:07:25 <dons> has to be CInt
23:08:27 <dons> grr. I see its used wrongly in X11 all over :/
23:08:47 <sjanssen> dons: yes, I chose the lazy and incorrect route
23:09:02 <dons> well, so did -package X11
23:09:28 <sjanssen> for at least the third time today: I really really hope Sven Panne writes xhb
23:10:41 <dons> heh. maybe we if talk to him about it
23:11:14 <sjanssen> yeah, I'm going to bring that thread up again on haskell-libraries
23:11:55 <sjanssen> the great potential of xhb: autogenerated bindings for the entire X11 API
23:13:03 <dons> that'd simplify our job a bit
23:13:27 <nrb23> ?seen Syntaxpolice
23:13:28 <lambdabot> I haven't seen Syntaxpolice.
23:15:57 <dmead> ?seen my sanity
23:15:57 <lambdabot> I haven't seen my.
23:16:01 <dmead> ?seen my_sanity
23:16:02 <lambdabot> I haven't seen my_sanity.
23:16:06 <dmead> me neither :s
23:17:41 <bd_> ?where soc
23:17:42 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
23:18:37 <bd_> http://hackage.haskell.org/trac/summer-of-code/ 'project ideas' complains that ticket 792 does not exist
23:18:38 <lambdabot> Title: Haskell.org Google Summer of Code - Trac
23:21:07 <bd_> hm, now it works
23:24:25 <dons> sjanssen: ok alt-c/kill-client works. you need to update to darcs X11-extras firs
23:24:28 <wkh> how do i use the Lift class in Language.Haskell.TH.Syntax?
23:24:50 <wkh> i imported Language.Haskell.TH.Syntax but it says "Not in scope: daata constructor 'Lift'"
23:34:21 <sjanssen> dons: the convention in -package X11 is to omit the X prefix, so I changed xKillClient to killClient
23:34:30 <sjanssen> and I'm going to bed
23:34:51 <dons> ok. cool.
23:35:06 <dons> i'll see if i can get workspaces working.
23:38:35 <wkh> i found a tutorial on using template haskell which has an example function cnst :: Int -> String -> Q Exp
23:38:35 <wkh> cnst n s = return (LamE (replicate n WildP) (LitE (StringL s)))
23:38:51 <wkh> how would you generalize cnst to take any kind of variable rather than a string
23:39:07 <wkh> i.e. how would you make the tpe signature be cnst :: Int -> a -> Q Exp
23:40:12 <kowey> @karma+ TheBinaryStrikeForce
23:40:12 <lambdabot> TheBinaryStrikeForce's karma raised to 1.
23:40:23 <dons> heh
23:40:37 <dons> i'm glad someone noticed that :-0
23:40:40 <kowey> thank you guys very much... my application now loads instantaneously
23:40:46 <dons> oh wow. that's great.
23:41:03 * dons disappers for a sec. testing haskell window manager..
23:41:07 * kowey rebans himself from IRC at work
23:41:41 <dons> seems to be working
23:42:00 <wkh> dons: can you answer my template haskell question? :(
23:42:40 <dons> isn't that just a polymorphism issue?
23:42:53 <dons> make a typeclass /or reuse one, and make cnst polymorphic over the instances of the class
23:44:39 <ivanm> is there a graphing/plotting library for Haskell?
23:45:45 <dons> gtk does graphics, there's also a plotting library hmm using gnuplot?
23:45:57 <dons> this was discussed on haskell-cafe earlier in the week if you check the archives
23:46:00 <dons> the links should be available there
23:46:04 <ivanm> dons: OK, I will
23:46:14 <ivanm> don't need it for anything atm, just for future use
23:48:50 <ivanm> dons: yeah, the Haskell charts one looks like what I was after
23:49:01 <ivanm> didn't find it myself, as I was searching for plots, graphs, etc
23:49:04 <ivanm> not charts
23:51:22 <ivanm> dons: so your darcs-graph is just using a wrapper to gnuplot?
23:51:50 <dons> yep
23:53:08 <ivanm> k
23:53:29 <acang> are there any plans to ultimate the Haskell wikibook?
23:54:02 <ivanm> well, there go my idle plans of writing a haskell plotting library ala matplotlib for an honours thesis next year ;)
23:54:15 <triplah_w> ivanm: write one
23:54:24 <triplah_w> pppuuuulllleeassse
23:54:28 <ivanm> triplah_w: there's already some there
23:54:38 <ivanm> http://comments.gmane.org/gmane.comp.lang.haskell.cafe/20009
23:54:40 <lambdabot> Title: gmane.comp.lang.haskell.cafe
23:54:47 <ivanm> rewriting the wheels pretty pointless :s
23:54:47 <triplah_w> ah kk
23:54:52 <triplah_w> it sure is
23:54:58 <triplah_w> shame on your for considering it!
23:55:00 <triplah_w> :P
23:55:03 <triplah_w> you even
23:55:50 <triplah_w> i need to stop procrastinating
23:56:01 <ivanm> lol
23:56:10 <triplah_w> i always do this when i have to write heavily concurrent code
23:56:11 <triplah_w> :(
23:56:16 <acang> dons: is there a coordinated effort to ultimate the Haskell wikibook? Currently is lacking many interesting and advanced topics
23:56:34 <ivanm> triplah_w: I probably wouldn't have been able to do so for a maths honours anyway ;)
23:56:42 <dons> there's no coordinated effort
23:56:59 <acang> dons: thanks
23:57:07 <triplah_w> ivanm: you are doing a maths honours? i can give you stuff to write ;D
23:57:17 <ivanm> triplah_w: next year
23:57:22 <triplah_w> ah cool
23:57:28 <ivanm> acang: what do you mean by "ultimate" the wikibook?
23:57:28 <triplah_w> most of my masters will be math
23:57:37 <dons> complete?
23:57:59 <acang> ivanm: complete it
23:58:22 <acang> ivanm: as you can see here http://en.wikibooks.org/wiki/Haskell there are currently several missing lessons
23:58:38 <ivanm> ahhh... so ultimate == complete... that's really strange English usage
23:58:49 <ivanm> I know there's missing bits... just "ultimate" sounds a little weird
23:59:24 <wkh> if Engrish bothers you, i suggest you stay way from research papers on optimization metaheuristics
23:59:41 <ivanm> triplah_w: you're doing network theory or something, aren't you?
23:59:58 <triplah_w> ivanm: dimensional reduction
