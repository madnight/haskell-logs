00:27:53 <dons> ?uptime
00:27:53 <lambdabot> uptime: 6d 13h 30m 4s, longest uptime: 6d 13h 30m 4s
00:27:55 <dons> ?users
00:27:55 <lambdabot> Maximum users seen in #haskell: 337, currently: 289 (85.8%), active: 28 (9.7%)
00:48:38 <tsp> > time
00:48:39 <lambdabot>   Not in scope: `time'
00:48:46 <tsp> lol, there's no way to get the current time in haskell?
00:48:49 <tsp> > now
00:48:50 <lambdabot>   Not in scope: `now'
00:48:59 <tsp> ah, probably a module
00:49:18 <kfish> ?hoogle time
00:49:19 <lambdabot> System.Time :: module
00:49:19 <lambdabot> Time :: module
00:49:19 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
00:49:59 <kfish> ?docs System.Time
00:49:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
01:09:34 <dons> ?uptime
01:09:35 <lambdabot> uptime: 6d 14h 11m 45s, longest uptime: 6d 14h 11m 45s
01:09:55 <dons> so clearly its possible to find out the current time using the haskell language...
01:13:39 <dolio> Even if the way to get the current time were named 'time', lambdabot wouldn't let you use it, because it'd have to live in the icky IO monad.
01:13:44 <earthy> do { t <- getCurrentTime; show t }
01:14:06 <earthy> oh, and that's Data.Time
01:14:11 <earthy> which is *much* nicer than System.Time
01:14:14 <abz> >  toCalendarTime =<< getClockTime
01:14:15 <lambdabot>   Not in scope: `getClockTime'
01:20:10 <siti> what's that lib that's a unicode wrapper around bytestrings called?
01:20:15 <siti> the*
01:20:54 <mux> Data.CompactString I think
01:23:43 <siti> thanks
01:43:49 <hpaste>  gour pasted "test" at http://hpaste.org/1192
01:44:03 <gour> hmm
01:44:21 <gour> glguy: how to direct hpaste to #haskell.hr ?
01:45:32 <gour> (if it's invoked from there)
01:47:18 <gour> @seen glguy
01:47:19 <lambdabot> glguy is in #haskell. I last heard glguy speak 3h 28m 41s ago.
01:48:02 <Vq^> gour: what about making the announcement yourself instead of using the announce function in the bot?
01:48:33 <gour> Vq^: ?
01:50:41 <Vq^> maybe i misunderstood your question
01:51:08 <gour> Vq^: i pasted from #haskell.hr, but bot reported paste here
01:51:25 <Vq^> how do you paste from a channel?
01:53:05 <gour> Vq^: well, previously there was separate paste for #haskell.hr, now @paste in #haskell.hr gives http://hpaste.org/new which is disturbing for #haskell users, so question is how to get separate paste for #haskell.hr & similar channels
01:55:17 <Vq^> ok, then i understand
01:55:23 <Vq^> hej nominolo
02:00:37 <nominolo> hi Vq^
02:31:31 <ndm> @seen augustss
02:31:31 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
02:31:34 <ndm> @seen augustss_
02:31:34 <lambdabot> I saw augustss_ leaving #haskell 14h 13m 30s ago, and .
02:31:56 <ndm> @seen ddarius
02:31:56 <lambdabot> I saw ddarius leaving #haskell, #haskell-overflow and #haskell-blah 2h 46m 27s ago, and .
02:32:18 <ndm> @tell ddarius wasn't around last night, but am now if you have any questions - or feel free to email them in
02:32:18 <lambdabot> Consider it noted.
02:32:48 <ndm> @tell sorear either is fine by me, probably avoiding conflicts is a priority, given a low number of users
02:32:48 <lambdabot> Consider it noted.
02:33:37 <ndm> @where logs
02:33:37 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
02:41:26 <tsp> @where isPrefixOf
02:41:27 <lambdabot> I know nothing about isprefixof.
02:41:35 <quicksilver> it's in Data.List
02:41:41 <tsp> thanks
02:41:43 <quicksilver> @hoogle isPrefixOf
02:41:44 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
02:42:01 <quicksilver> '@where' is for websites, not functions, really
02:42:09 <quicksilver> @index isPrefixOf
02:42:10 <lambdabot> Data.List
02:52:59 <hpaste>  tsp pasted "replaceString problem" at http://hpaste.org/1193
02:53:15 <tsp> I tried to rewrite that, but I know I"m missing something
02:53:30 <tsp> I worked through the logic, but it still gives an exception at the end
02:55:20 <quicksilver> tsp: you don't want that 'do'
02:55:31 <quicksilver> tsp: do is for monads, this code is not monadic :)
02:56:15 <tsp> does that matter? it'll just run them in sequence
02:56:59 <quicksilver> tsp: yes, it does matter
02:57:10 <quicksilver> tsp: 'just run them in sequence' doesn't really mean anything
02:57:24 <quicksilver> tsp: do returns something in some monad; it works out which monad by type inference
02:57:51 <quicksilver> you don't want to use any monad here
02:57:54 <tsp> what can I replace the do with? I tried {, didn't work. I tried nothing, didn't work
02:59:16 <quicksilver> Oh, interesting
02:59:26 <quicksilver> actually the 'do' isn't your problem, although it's not needed
02:59:35 <quicksilver> the problem is you called it replaceINString once
02:59:36 <tsp> taking it out wouldn't even let it compile
02:59:40 <quicksilver> and replaceString the other time
02:59:45 <tsp> oh
02:59:52 <tsp> and the compiler didn't warn me about this
03:00:16 <tsp> ah, that's why
03:00:22 <tsp> the empty list base case
03:00:25 * quicksilver nods
03:00:34 <tsp> how can I get it to compile without the do {} in there?
03:00:49 * mux lifts self into the morning monad
03:01:27 <quicksilver> tsp: trying to work that out for you. I'm not totally familiar with non-layout code :)
03:01:55 <tsp> quicksilver: what will happen when I start writing larger projects? noone will be able to read my code
03:02:07 <tsp> I had that problem with perl :)
03:02:32 <mux> heh
03:02:53 <tsp> I like the fact that I can write a replace in string function by calling it from itself
03:03:07 <tsp> I imagine it'll be slow as crap though
03:03:35 <tsp> @src words
03:03:35 <lambdabot> words s = case dropWhile isSpace s of
03:03:36 <lambdabot>     "" -> []
03:03:36 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
03:04:24 <tsp> dropWhile isSpace s?
03:04:31 <Cale> tsp: there are some things you could do to speed it up -- computing the length of the thing being replaced over and over is a bit of a waste
03:04:34 <tsp> does that trim spaces from the beginning of the string?
03:04:53 <tsp> Cale: but I'd need to keep passing the length around
03:04:53 <Cale> tsp: yeah
03:05:11 <Cale> tsp: indeed you would, though you could do that in an internally defined function
03:05:13 <Cale> er
03:05:15 <Cale> actually, no
03:05:25 <tsp> it'd still need to be passed around :)
03:05:29 <tsp> and recomputed
03:05:33 <Cale> You'd define a function internally which used it as a constant bound by the outer function
03:05:45 <tsp> you can define functions inside functions?
03:05:50 <Cale> absolutely
03:05:51 <tsp> neat
03:05:53 <Cale> with where and let
03:05:56 <quicksilver> tsp: the only way I can get it parse without layout is to add a module Main where {} around the whole thing
03:06:00 <Cale> You can make local definitions
03:06:08 <tsp> quicksilver: heh
03:06:11 <quicksilver> Cale: have you ever tried turning off layout for the toplevel?
03:06:26 <quicksilver> Cale: I can't seem to do with without an explicit 'module'
03:06:46 <Cale> quicksilver: Yeah, you probably need that.
03:07:29 <tsp> is layout itself written in haskell?
03:07:55 <hpaste>  quicksilver annotated "replaceString problem" with "remove the 'do'" at http://hpaste.org/1193#a1
03:08:10 <quicksilver> tsp: there is my version with no 'do'
03:08:56 <quicksilver> Cale: the report appears to be incorrect. the report has the grammar reductions : module -> body and body -> { impdecls; topdecls; }
03:08:58 <tsp> got it
03:08:59 <tsp> neat
03:09:07 <tsp> I think I'm slowly starting to figure this out :)
03:09:16 <quicksilver> Cale: but that isn't accepted by ghci with explicit {}s
03:10:07 <quicksilver> tsp: the reason your do code worked, is that lists are a monad. And because you only had one statement in the 'do' it wasn't actually doing anything monadic. It was an odd way to write it, though :)
03:10:13 <hpaste>  Cale annotated "replaceString problem" with "my version of your idea" at http://hpaste.org/1193#a2
03:10:34 <quicksilver> Cale: he's using a screen reader, layout isn't convenient for him :)
03:10:40 <Cale> oh
03:10:43 <Cale> okay...
03:11:48 <hpaste>  Cale annotated "replaceString problem" with "without layout." at http://hpaste.org/1193#a3
03:11:52 <dcoutts> interesting, perhaps that's a good justification to provide explicit layout as an option
03:12:06 <quicksilver> dcoutts: ?
03:12:14 <dcoutts> not, 'perhaps' is is a good justification
03:12:21 <dcoutts> quicksilver: accessibility
03:12:40 <tsp> dcoutts: what does explicit layout mean?
03:12:43 <quicksilver> dcoutts: but your phrasing suggested that explicit layout wasn't an option currently
03:12:44 <Cale> That's a good point, I wonder how accessible python is.
03:12:44 <dcoutts> and a tool to convert implicit to explicit for people who want to read code that way
03:12:48 <quicksilver> dcoutts: that's what confused me
03:12:58 <tsp> Cale: someonw rote me a brace processor for python :)
03:13:05 <Cale> tsp: nice :)
03:13:08 <tsp> else i have to use l in ed with tabs
03:13:14 <dcoutts> quicksilver: well few people use it, that's what I mean and some people wonder why it's provided as an option
03:13:20 <quicksilver> dcoutts: right, yes :)
03:13:40 <quicksilver> dcoutts: I just discovered an odd bug, too; it seems you can use explicit at the top level, unless you use the module Main where {} form
03:13:45 <quicksilver> dcoutts: s/can/can't/
03:14:00 <dcoutts> quicksilver: report it as a bug
03:14:02 <quicksilver> dcoutts: so 'quick scripts' can't use explicit at the top level
03:14:09 <quicksilver> dcoutts: in what? ghc?
03:14:12 <dcoutts> right
03:14:24 <dcoutts> though check what hugs does too
03:14:42 <desp> clear
03:14:44 <dcoutts> might be a bug in both or our misunderstanding
03:14:56 <dcoutts> if they differ it's a bug
03:15:40 <quicksilver> dcoutts: I don't have hugs here
03:15:49 <quicksilver> dcoutts: I checked the grammar the haskell report
03:15:52 <dcoutts> quicksilver: what's the example, I'll try it
03:15:57 <quicksilver> dcoutts: it's fairly clear to me that it should work
03:16:02 <quicksilver> I'll paste it
03:16:35 <hpaste>  quicksilver pasted "simple top-level explicit layout (not accepted by ghci)" at http://hpaste.org/1194
03:17:56 <dcoutts> quicksilver: ok, hugs accepts that so it must be a ghc bug
03:18:09 <dcoutts> so go ahead and report it
03:18:38 <dcoutts> and cite the example of users with screen readers as an extra motivation to fix it
03:21:42 <Cale> quicksilver: what if you drop the braces?
03:22:02 <quicksilver> Cale: then it doesn't like the '3' on its own
03:22:11 <quicksilver> Cale: it believes that to be the start of a new topdecl
03:22:14 <Cale> ah, okay
03:22:33 <quicksilver> Cale: the real example was fun x = \nif
03:22:38 <Cale> Yeah, so I suppose you need to include an explicit module declaration.
03:22:44 <quicksilver> yes, that's the workaround
03:22:49 <quicksilver> but it should work :)
03:23:01 <Cale> which is just  module Main where { ... }
03:25:17 <quicksilver> Cale: yes, that's what I did :) Note that line in the code I pasted for tsp just before you did :)
03:25:20 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/1253
03:25:22 <lambdabot> Title: #1253 (Can't use explicit braces/semicolons (i.e. non-layout) at top level with  ...
03:26:39 <dcoutts> quicksilver: good bug report
03:26:57 <quicksilver> thanks :)
03:44:09 <arcatan> btw, do ghc and gtk2hs work on windows?
03:44:51 <ndm> arcatan: yes, perfectly
03:52:58 <nominolo> @pl \x f -> f x
03:52:58 <lambdabot> flip id
03:53:44 <nominolo> @pl \x fs -> map (\f -> f x) fs
03:53:44 <lambdabot> map . flip id
03:57:18 <quicksilver> nominolo: or simply map ($x) fs
03:57:34 <quicksilver> nominolo: sometimes going all-the-way pointfree isn't worth it :)
03:57:45 <tsp> lol, Trac - which hackage.org uses - is written in python?
03:57:52 <quicksilver> tsp: yup :)
03:58:04 <nominolo> quicksilver: oh, yes. thanks.  that looks more readable :)
03:58:05 <quicksilver> tsp: the world is a big place, it takes a while to rewrite it *all* in haskell :)
03:58:38 <tsp> quicksilver: good to know python still has a place :)
03:59:13 <tsp> one of haskell's major weaknesses is object orientation - e.g. in my replaceString function, I have to explicitly specify the string
03:59:26 <tsp> where in an OO language I would say string.replace(old,new)
03:59:44 <nominolo> so now you write replace string old new
03:59:47 <nominolo> even shorter
03:59:53 <tsp> ah
04:00:03 <tsp> hmm, the string object wouldn't change anyway
04:00:06 <ibid> tsp: maybe that's because haskell is not an object oriented language? :)
04:00:13 <ibid> tsp: there are no objects in haskell
04:00:26 <vincenz> data Object;
04:00:37 <tsp> ibid: objects make it significantly easy to encapsulte stuff
04:00:48 <tsp> s/easy/easier
04:00:50 <vincenz> tsp: so do modules
04:01:08 <vincenz> or data-types
04:01:09 <nominolo> tsp: haskell has quite a different approach, though. that's certainly true
04:01:24 <rahikkala> The object.thingInsideObject syntax is just a kluge to make not having multiple dispatch look natural ;)
04:01:25 <ibid> tsp: maybe so, but that does not make haskell an oo language. for information hiding, use modules
04:01:52 <hpaste>  LPhas annotated "happs learning" with "(no title)" at http://hpaste.org/1195#a1
04:01:57 <vincenz> for encapsulation, use data-types with record-syntax
04:02:04 <ibid> tsp: you can encapsulate data and behavior by putting functions inside the data
04:02:09 <vincenz> for templates use higher-order tycons
04:02:22 <nominolo> tsp: hm .. if you use haskell the right way, things are even nicer encapsulated
04:02:33 <quicksilver> tsp: haskell offers all the abstractions that OO offers, but they are actually more fine-grained
04:02:43 <quicksilver> tsp: so you can pick and choose the appropriate ones for the circumstance
04:02:59 <nominolo> e.g. you start by defining some data type, then the primitives.  then you implementation is quite easy to substitute
04:03:00 <ibid> quicksilver: that's not true. there is no object abstraction in haskell
04:03:21 <vincenz> ibid: I was going to make the same comment, though existentials help
04:03:27 <dons> an existential is just an object.
04:03:42 <dons> full type abstraction, statically checked.
04:03:42 * vincenz beeps dons 
04:03:46 <ibid> dons: an existenial IORef i could buy as an object :)
04:03:48 <pejo> Subtyping! Emacs! Vim! Ed!
04:04:00 * vincenz peers at pejo 
04:04:01 <dons> ibid: hehe. ok. state-boy ;-)
04:04:25 <ibid> dons: oject = identity + STATE  + beavior
04:04:31 <vincenz> ibid: not true
04:04:34 <dolio> Objects don't need to be mutable. For instance, strings aren't in Java.
04:04:36 <tsp> hmm, could a state help me maintain all the lists I would need in writing, say, an irc client?
04:04:41 <tsp> or would I still have ot pass it to everything
04:04:42 <vincenz> ibid: what about languages that have non-mutable objects, like ocaml?
04:04:51 <ibid> vincenz: they are not true objects
04:05:01 <vincenz> ibid: according to *your* definition
04:05:06 <ibid> vincenz: of course, this is very much a matter of definition :)
04:05:09 <dons> tsp,any state you need, you pass in a monad. see e.g. lambdabot or xmonad.
04:05:24 <ibid> vincenz: according to a definition that makes a lot of sense to me :) ... not mine by any measure, btw
04:05:37 <vincenz> ibid: many people consider it objects hence the little o' in o'caml
04:05:49 <vincenz> mutability is orthogonal and that's what 'ref's are for
04:05:53 <ibid> vincenz: yes, they do, and they're wrong from my pov :)
04:05:58 <tsp> but I'd need to make everything a monad - in the case of an irc client, ignore user, etc
04:06:04 <ibid> but this is a fruitless debate
04:06:07 <ibid> --> goes
04:06:08 <vincenz> mutability `isOrthogonalTo` objects
04:06:27 <vincenz> > True
04:06:28 <lambdabot>  True
04:06:30 <nominolo> tsp: no, everything will live in the same monad
04:06:50 <tsp> nominolo: would that allow me to do something like addToList ignored_users user?
04:07:03 <tsp> nominolo: or would the one-use-per-variable apply
04:07:17 <vincenz> dons: how hard is it to grow arrays?
04:07:23 <nominolo> tsp: yes, something like:  ignoreUser :: Username -> IrcM ()
04:07:42 <tsp> ah
04:07:49 <vincenz> or simply
04:07:55 <vincenz> ignoreNominolo :: IrcM ()
04:07:56 <vincenz> :P
04:08:17 <tsp> I thought that once a variable was set, I couldn't reset it - so if my monad had an ignoreList, I couldn't add to it
04:08:20 <dons> tsp: yeah, i think you'll just need some experience writing apps in haskell. none of this is terribly hard, you just have to learn how to do it.
04:08:29 <nominolo> tsp: and ignoreUser u = do s <- get; put (returnNewStateWithUserIgnoredAdded s u)
04:08:32 <quicksilver> tsp: that's only true in a sense
04:08:37 <tsp> ah, return the state
04:08:46 <quicksilver> tsp: you can explicitly pass a state around
04:08:54 <quicksilver> tsp: and when it changes, you just pass the new state around, instead
04:09:02 <quicksilver> tsp: then, that becomes a bit of a hassle
04:09:05 <dons> > runState (do x <- get ; put (x+1) ; return () ) 7
04:09:06 <lambdabot>  ((),8)
04:09:06 <quicksilver> tsp: and that's where monads come in
04:09:09 <nominolo> vincenz: yes, but that is just api-sugar ;)
04:09:14 <quicksilver> tsp: monads are a way to 'hide plumbing'
04:09:20 <quicksilver> tsp: in this case, passing state around all the time
04:09:26 <tsp> quicksilver: ah, so I can change the monad and it'll get passed around
04:09:27 <vincenz> nominolo: :)
04:09:28 <quicksilver> tsp: the state is still being passed but it's hidden away
04:09:31 <quicksilver> tsp: right
04:10:22 * nominolo has class now
04:10:23 <tsp> monads are confusing - I've read docs on them etc but they still get me for a loop, I just know how to read a file now :)
04:10:42 <quicksilver> tsp: well you don't need to try to understand them up front
04:10:53 <quicksilver> tsp: experiement with some general programming and pick them up gradually
04:11:23 <tsp> I don't want to be stuck writing string parsers :) I want to hack a text editor, but again can't pass the list of lines around
04:11:35 <tsp> and don't know where to look for easy docs on this stuff
04:11:56 <earthy> what do you consider easy?
04:11:59 <vincenz> Yay for amazon:
04:11:59 <vincenz> Yay for amazon: As someone who has expressed interest in books by Douglas R. Hofstadter,
04:12:02 <vincenz> you might like to know that "I Am a Strange Loop" will be released on 5
04:12:05 <vincenz> April 2007. You can pre-order your copy for just £14.24 by following the
04:12:07 <vincenz> link below.
04:12:14 <vincenz> grr, damn newlines
04:12:50 <quicksilver> tsp: fair enough, but nobody writes a text editor in a new language on their 3rd day :)
04:12:54 <earthy> http://www.cs.uu.nl/docs/vakken/gont/diktaat.pdf is a reasonable introduction to grammars and parsing e.g.
04:12:57 <quicksilver> tsp: it takes a while for it to filter in
04:13:27 * earthy agrees with quicksilver there
04:13:31 <vincenz> earthy: does it deal with GLR?
04:13:34 <earthy> give it time to gestate
04:13:48 <earthy> vincenz: it's a bachelor's course...
04:14:08 <vincenz> GLR has matrured enough...
04:14:45 <earthy> yeah, but from 'barely knows fp' up to 'understands glr
04:14:50 <earthy> ' is quite some ways
04:15:13 <earthy> you won't get students that far in a mere 200 hours
04:15:15 <vincenz> oh, it's a bacherlor course on FP, I thought it was a bachelor course on parsing
04:15:21 <earthy> it is on parsing
04:15:39 <earthy> but it als has to introduce regular languages and grammars and such
04:16:01 <psykotic> isn't GLR just a nondeterministic interpretation of LR tables?
04:16:11 <vincenz> psykotic: you're alive
04:16:34 <vincenz> psykotic: yes, but 'just' is a matter of definitioin
04:17:23 <psykotic> well i mean a naive nondeterministic interpretation, as opposed to something like that algorithm named after a japanese guy which tries to merge "threads" of execution
04:18:21 <psykotic> tomita
04:18:52 <earthy> ghe. tomita is cool
04:19:01 <vincenz> from a webpage "Tomita's Algorithm amounts to a simple generalisation of the standard LR algorithm. "
04:19:14 <earthy> parseforests in less than exponential time
04:20:46 <psykotic> vincenz, tomita is glr except that it uses dynamic programming to share as much as possible
04:21:28 <psykotic> basically suppose you have an LR parsing that in one part splits off two ways due to a potential ambiguity and later continues normally. in that case tomita would share the last common part between the two split off parsings
04:21:40 * vincenz nods
04:22:41 <psykotic> so, tomita is a little tricky but just interpreting an LR table nondeterministically is really basic, especially in a functional language
04:23:18 <psykotic> you could write it in a backtracking monad and the code would be the same as a normal LR table machine/driver
04:27:28 <psykotic> vincenz, btw one nice thing about GLR is that you can use the extremely simple LR(0) table generating algorithm and still get something with full generality
04:27:49 <vincenz> psykotic: does it hold the same propertiers as tomita that it improves if you use a 'better' grammar table?
04:27:51 <Saizan> LR?
04:27:54 <psykotic> from that point of view the purpose of the other algorithms is efficiency, not generality
04:28:14 <vincenz> right
04:28:17 <vincenz> which answers my Q
04:29:29 <psykotic> Saizan, its a class of bottom-up parsing algorithms. LR stands for left-to-right parse, rightmost derivation
04:30:43 <Saizan> ah, so the table is the one with Not-terminal symbols on one side and terminals on the other?
04:32:17 <psykotic> actually the states (one of the "dimensions") is made up of item sets, where an item is a right-hand-side/rule with a "position" inside the rule indicated, and the item sets are closed with respect to an operation thats similar to epsilon closure in regular expressions
04:34:21 <psykotic> so for instance, suppose you have a production expr <- expr + expr
04:35:15 <psykotic> the possible items for that production would be _ expr + expr, expr _ + expr, expr + _ expr and expr + expr _, where the _ is a position/marker
04:35:39 <psykotic> it basically says how much of that rule has already been matched and how much has to be matched
04:36:08 <Saizan> oh
04:36:31 <Saizan> ok, is something i've never seen :)
04:36:33 <psykotic> so a set of those items corresponds to a bunch of different rules being explored in parallel
04:38:14 <psykotic> i think this is usually covered in compiler courses. most people seem much more comfortable with topdown parsing ala LL(k)
04:39:00 <psykotic> anyway this is the kind of thing that yacc does
04:47:18 <Saizan> i'm following one this semester, only 48 hours though :\
04:50:07 <YayikAyran06> anybody has a code for burrows-wheeler transform?
04:50:46 <psykotic> YayikAyran06, try searching the haskell-cafe archives, i remember someone posted code for BWT there
05:19:13 <YayikAyran06> anybody willin to help for a college homework :) ?
05:20:23 <twanvl> sure
05:21:15 <Jaak> @quote homework
05:21:16 <lambdabot> vincenz says: sure, give us your homework and we'll email it straight to your teacher :)
05:21:28 <YayikAyran06> great ;)
05:22:21 <YayikAyran06> bothead make me pass wif A+ ;)
05:22:23 <vincenz> notice how the sarcasm drips off of that like the oil from a philly chees steak
05:24:45 <Thunder> I found some funny things today: My last Xmas lecture ... http://www.iks-jena.de/mitarb/lutz/vortrag/weihnacht2004.hs ... Script: http://www.iks-jena.de/mitarb/lutz/vortrag/weihnacht2004.ps.bz2 it's about rautavistic computer science. Have fun or ignore it.
05:29:49 <quicksilver> I think Andrzej
05:30:05 <quicksilver> aworksi is taking the path to trollhood
05:30:11 <tsp> Thunder: who uses postscript?
05:30:20 <vincenz> Woo
05:30:21 <vincenz> gtk2hs+=
05:30:23 <vincenz> gtk2hs++
05:30:28 <vincenz> Gotta love software that builds so smoothly
05:30:29 <tsp> how did you write that in postscript? I thought it was binary
05:30:45 <Thunder> tsp: You can get the tex source, too.
05:30:57 <tsp> vincenz: does the haskell gtk api support the accessibility interfaces?
05:31:13 <vincenz> tsp: no idea
05:31:38 <tsp> Thunder: that reminds me - another thing I want is a way to read tex documents - hearing all the symbols drives me nuts
05:31:45 <vincenz> http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.11/
05:32:29 <pejo> tsp, is pdf significantly better than postscript from an accessibility pov?
05:32:37 <tsp> pejo: lol
05:32:41 <tsp> pejo: some would say yes
05:32:48 <tsp> but adobe reader is so slow its almost unusable
05:33:06 <vincenz> wtf is accessibility?
05:33:09 <tsp> pdftotext screws up -everything-, including indentation for a python book I found
05:33:27 <Thunder> tsp: Stick to the haskell source and you get the idea.
05:33:36 <tsp> vincenz: it helps screen reader users
05:33:45 <vincenz> tsp: by doing ...what?
05:34:01 <tsp> vincenz: providing hooks and api's so that we can use the programs
05:34:07 <vincenz> contrast settings help screen reader users
05:34:29 <vincenz> oh, wait, I parsed 'screen reader user' wrongly
05:34:36 <tsp> vincenz: how so? Contrast is some sort of monitor setting
05:34:37 <vincenz> you mean for TTS
05:34:39 <tsp> vincenz: yeah
05:34:41 * vincenz nods
05:35:00 <vincenz> I thoguht you meant users that read from screen at first
05:35:13 <tsp> vincenz: I don't even have a monitor - its in a closet for when I need to pull out the webcam and the other box for some obstenent piece of software that won't talk
05:35:37 <vincenz> tsp: you're blind?
05:35:50 <tsp> vincenz: yup
05:36:08 <tsp> funny enough, I can never configure X properly enough that it'll work
05:36:17 <dcoutts> :-)
05:36:24 <tsp> work = be able to take a screenshot of it  to see what breaks
05:36:49 <tsp> so I went back to windows as the talking terminal - it has a good vmware setup for the linux box I need for haskell hacking :)
05:37:35 <tsp> accessibility isn't just the os - I want to buy a new computer, and am 99% positive that I'll have to get a pile of people on irc and the webcam to configure its bios
05:41:52 <psykotic> tsp, are there any text editors with good support for the blind?
05:42:29 <psykotic> i remember hearing about emacspeak but wasn't sure about how well it works
05:44:03 <tsp> emacspeak works, but I don't like it much
05:44:24 <tsp> I don't like the whole arrow keys and cursor movement style of editing
05:44:49 <tsp> for example, if you have the mistyped line "this is a test on the #haskel channel on freenode"
05:45:19 <tsp> you have to hit next-word over the "this is a test of the", then find the l to add an extra l
05:45:45 <nominolo> tsp: you prefer raskin-style leap-keys?
05:45:45 <tsp> where I can just type out s/haskel/haskell and get it the first time, with ed reprinting the line due to the lack of a trailing /
05:45:45 <psykotic> couldnt you use incremental search to position the point?
05:46:02 <arcatan> this reminds me of the video in which somebody tries to code perl with windows vista speech recognition
05:46:11 <tsp> psykotic: incremental search might get me somewhere else
05:46:16 <vincenz> arcatan: that was .... sad
05:46:29 <vincenz> tsp: you have ed running on irc?
05:46:40 <tsp> vincenz: ed on irc? no
05:47:02 <tsp> but it's become so much of a habbit to type s/x/y without even thinking about it now that I may as well write an ed interface to irc with a scrollback and all
05:47:51 <vincenz> or :quit
05:48:10 <tsp> for example, in emacs's dired mode, emacspeak would speak files, directories and links in different voices - that's all well and good, but it uses a dectalk speech synth which I have. The problem with that is that the speech server lags
05:48:42 <tsp> no-one else on the emacspeak mailing list thinks it lags. I think that they're so used to slow speech response that it's natural to them
05:48:50 * quicksilver nods
05:49:14 <quicksilver> real screenreader experts have their voices up so fast that unskilled people have no chance of understanding :)
05:49:27 <quicksilver> I listened to a podcast of a fast screenreader once
05:49:29 <tsp> case in point: http://silenceisdefeat.org/~tspivey/eloquence.flac
05:49:40 <tsp> quicksilver: podcasts are pretty slow
05:49:57 <tsp> that flac file was my normal speed as of a month or two ago - I think I sped it up a bit since then
05:50:02 <therp> woot, after a slightly wrong unification algorithm and a typo, my embedded prolog finally solves the zebra problem.
05:50:15 <quicksilver> tsp: but this podcast contained a recording of someones screenreader at high speed
05:50:19 <tsp> quicksilver: ah
05:50:28 <tsp> high speed is subjective though :)
05:50:47 <quicksilver> tsp: indeed. I don't claim to be experienced, but it was fast enough that I couldn't understand it :)
05:51:04 <tsp> I can listen at high speed, but most of the info I get is useless - for example in windows
05:51:19 <vincenz> like "Please reboot"
05:51:49 <tsp> run dialog type the name of a ... <I shut it up> control<enter> desktop list view not selected my documents 1 of 67 control panel blah blah blah
05:52:06 <tsp> I don't care that my desktop reappeared for a second and a half
05:53:08 <vincenz> how do you deal with special characters? (non-alphabetical ones)
05:53:20 <tsp> vincenz: ah, punctuation? it reads them, if I set it to
05:53:33 <vincenz> doesn't that get overly verbose/
05:53:39 <tsp> yup
05:53:47 <tsp> every time I speak, it says less tsp greater
05:54:03 <tsp> I could turn that off, but I'd need to keep tweaking it for everything I did
05:54:11 <vincenz> does it use a different voice to make it clear it's punctuation?
05:54:20 <tsp> and under windows I need to go through a cupple of menus to get to it
05:54:30 <tsp> vincenz: nope
05:54:31 <tsp> vincenz: that would be highly annoying
05:54:39 <pejo> quicksilver, apparently you get used to listening quickly quite soon if you do it a lot. I visited a company that monitors tv/radio/newspapers for companies and all they listened to souded like chip and dale.
05:54:43 <vincenz> alphabetical backslash  symbol \
05:54:54 <tsp> heh
05:54:58 <tsp> for a \, it just says back slash
05:55:10 <vincenz> I typed back slash
05:55:15 <tsp> yeah
05:55:17 <tsp> it read that too
05:55:25 <vincenz> well they must sound similar
05:55:32 <tsp> it does
05:55:33 <mux> can it read
05:56:17 <mux> err
05:56:19 <vincenz> simpleMonadFunction :: (Monad m) => String -> m String
05:56:22 <tsp> ouch
05:56:25 <mux> can it read λ ?
05:56:32 <tsp> mux: it read that
05:56:39 <mux> as lambda? :)
05:56:43 <tsp> but its my job to figure out what it does, it doesn't tell me its a function
05:56:49 <mux> that's very nice
05:56:56 <tsp> it said
05:57:16 <vincenz> tsp: no he typed a lambda symbol, he wasn't referring to my code
05:57:19 <tsp> ah
05:57:21 <tsp> the ?
05:57:24 <vincenz> no
05:57:28 <vincenz> prior to that was a lambda symbol
05:57:29 <mux> only ? if you don't have utf-8
05:57:30 <vincenz> it's extend UTF
05:57:32 <tsp> damnit
05:57:39 <tsp> tera term doesn't support utf-8 :)
05:57:42 <mux> ok
05:57:48 <tsp> if it did, it probably would have read something
05:57:54 <vincenz> but yeah, my function signature would be a haskell function signature
05:57:55 <mux> λx.x
05:58:11 <tsp> vincenz: it made no sense of that - reading the punctuation literally
05:58:23 <vincenz> even the parentheses?
05:58:27 <tsp> yup
05:58:37 <vincenz> good :) they
05:58:41 <vincenz> they're maeningfunl
05:58:47 <tsp> it also doesn't distinguish between 2 of the 3 possible letter "a"s in swedish
05:59:08 * dylan wonders how a braile combination input/output device would be.
05:59:29 <tsp> dylan: I have a braille display, but that thing is impossible to use when I"m lying in a bed where I do most of my work these days :)
05:59:38 <tsp> besides, they suck with ed
06:00:00 <vincenz> you use ed and not vi?
06:00:10 <tsp> ed and edbrowse
06:00:17 <int-e> vi displays too much information I guess
06:00:21 <vincenz> probably
06:00:23 <tsp> edbrowse mostly, but fall back to ed if edbrowse doesn't work
06:00:28 <psykotic> im impressed that you can get anything done at all this way. you must have a very good memory--as a programmer i rely on the screen extensively as a sort of ultra short term memory, i cannot imagine not having that.
06:00:58 <tsp> psykotic: memory wise, its not that great - I have to keep going back up to previous functions/classes
06:00:59 <vincenz> psykotic: I was thinking the same thing, getting the structure of code must require very good memory
06:01:07 <tsp> haskell is truely annoying
06:01:10 <dylan> tsp: were you born blind or did it happen later in life?
06:01:13 <tsp> dylan: born this way
06:01:26 <tsp> I doubt that I'd want to be able to see - too much new learning
06:01:33 <psykotic> tsp: how do you visualize the relationship between parts of a text}
06:01:41 <tsp> psykotic: how so?
06:01:43 <psykotic> i feel bad using the term visualize
06:01:48 <tsp> psykotic: text wise
06:01:48 <psykotic> how do you organize it in your head
06:01:52 <tsp> psykotic: no idea, I just do
06:01:59 <tsp> psykotic: I'm stuck in the ed lines mindset
06:02:21 <tsp> I know that haskell is going to give me problems when I go beyond 1 or 2 functions
06:02:26 <vincenz> tsp: what about such things as matching braces in a java-like language?
06:02:37 <tsp> vincenz: edbrowse has a B command that solves that, mostly
06:02:49 <tsp> and it also browses the web which is a plus
06:03:01 <tsp> but I want to rewrite that is a true talking app
06:03:34 <vincenz> tsp: I guess you also try to minimize what is displayed in whatever windowing system you use?
06:03:34 <quicksilver> vincenz: for tsp, haskell has braces :P
06:03:52 <tsp> I use mutt to read mail, but it's too big and bulky - it takes up an entire screen for its index, when I could use the previous lines of output to display something else
06:03:53 <vincenz> quicksilver: yeah, layout rule would suck
06:03:57 <malcolmw> I can imagine that if you keep your function definitions short, haskell might be better than e.g. Java for comprehension.
06:04:12 <tsp> the best language I've found so far is python - oddly enough
06:04:18 <tsp> write a brace parser for it and there we go
06:04:18 <vincenz> tsp: with the indent??
06:04:42 <tsp> vincenz: I strugled around with tabs and ed's \t\t\t, tried to memorize my level (mostly worked), but someone wrote me a brace parser that helps alot
06:04:56 <tsp> so I can write def f(x): {
06:04:58 <vincenz> if you like python, try ruby, it's much like python but it has explicit end's
06:05:08 <tsp> vincenz: ruby and edbrowse's brace matching didn't get along
06:05:15 <tsp> since it uses end, and no explicit begin
06:05:43 <malcolmw> I think it should be easy to persuade any haskell compiler to convert layout to explicit braces and give you the result
06:05:58 <vincenz> yes, that's actually purely a lexer thing
06:06:09 <tsp> malcolmw: if I start learning haskell, I guess someone will be annoyed enough to write one that goes the other way
06:06:14 <vincenz> tsp: and although haskell has indent rules, it's just a short cut for internal brace-style coding
06:06:17 <tsp> malcolmw: contributing to it, that is
06:06:17 <malcolmw> after all, the compiler it doing it internally anyway, so making it available to the user should be simple
06:06:25 <vincenz> tsp: braces are standard syntax as well
06:07:11 <vincenz> tsp: the lexer replaces the start of an indentiation with a hidden brace, so you can program with explicit braces, but it would be nice if the lexer could reoutput code so you could easily bracify other people's code
06:07:19 <tsp> vincenz: that would be cool
06:07:36 <tsp> vincenz: how about going the other way? would people really be able to read, say, a hundred line program written in my style?
06:08:04 <vincenz> tsp: sure, it's somorphic
06:08:10 <tsp> I do the equivalent of ,s/^\s*//g and it's almost a g/^$/d
06:08:11 <vincenz> isomorphic even
06:08:21 <tsp> vincenz: isomorphic?
06:08:24 <int-e> tsp: maybe with some preprocessing (namely, indenting it)
06:08:35 <malcolmw> although it would be a little more difficult, I'm sure a tool to convert braces to layout would not take long to write
06:08:58 <malcolmw> in fact, a compiler can probably do that already as well
06:09:01 <int-e> tsp: a flat view can be highly confusing if you're not used to it.
06:09:18 <vincenz> tsp: if one line is indented more than a previous line, the lexer inserts a brace for the parser.   But you acn progam with explicit braces
06:09:31 <tsp> vincenz: that part is easy
06:09:45 * malcolmw notes that the Hat parser can read explicit braces and output nicely indented layout style instead
06:09:59 <vincenz> malcolmw: I think the reverse direction would be more interesting for tsp
06:10:27 <dcoutts> in theory the Language.Haskell lib can do that
06:10:27 <int-e> hmm. I wonder how hard it is to write a tool that adds the explicit braces. does something like this exist already?
06:10:37 <vincenz> int-e: it's the lexer that does it...
06:10:38 <dcoutts> in practise it misses a bunch of stuff
06:10:51 <malcolmw> int-e: pretty much every compiler does layout to braces
06:10:55 <vincenz> int-e: any h98 compatible lexer that keeps comments could do it
06:11:06 <dcoutts> the Language.Haskell pretty printer can produce both styles
06:11:15 <quicksilver> well, sort of
06:11:17 <vincenz> dcoutts: nice, though what of comments?
06:11:21 <malcolmw> oh yeah, I forgot about the comments - compilers tend to strip those away
06:11:24 <quicksilver> a h98 lexer would typically remove newlines and blanklines, though
06:11:28 <dcoutts> however it does other stupid things like miss out (..)parens
06:11:32 <vincenz> quicksilver: indeed, and comments
06:11:50 <quicksilver> which is not the end of the world
06:11:54 <quicksilver> but just making that point :)
06:11:59 <dcoutts> the HaRe stuff keeps the comments
06:12:02 <quicksilver> you'd want to add back newlines between different functions, at least
06:12:10 <quicksilver> and possibly around multi-line comment blocks
06:12:16 <vincenz> the whole idea of this tool would be to ease code reading of other people's code for tsp , removing the comments sort of defeats that purpose
06:12:17 <dcoutts> since it's a refactorer it tries to keep existing stuff as much as possible
06:12:28 <tsp> quicksilver: haskell has no way for, say, an editor to find the next/previous function :)
06:12:44 <tsp> in python, I can just do /^\s*def /
06:12:49 <tsp> at least with ed
06:12:57 <vincenz> tsp: you can do /^[^\s]/
06:13:13 <tsp> what good would that be?
06:13:23 <tsp> that woudl search for anything that wasn't indented
06:13:39 <vincenz> tsp: yes, whic can only be comments or top level deifnitions
06:13:46 * vincenz mutters at the lag induced by his ssh connection
06:13:49 <quicksilver> vincenz: unles you're not using layout
06:13:57 <quicksilver> vincenz: in which case, any line can be non-indented :P
06:14:01 <tsp> in layout that holds true, I think
06:14:01 <vincenz> quicksilver: which is rare
06:14:06 <quicksilver> vincenz: but not for tsp
06:14:10 <quicksilver> vincenz: for him, it's universal
06:14:13 <tsp> vincenz: in my case, I need a way to jump between elements
06:14:17 <vincenz> quicksilver: n but he can look for braces instead
06:14:24 <tsp> not for functions
06:14:30 <quicksilver> vincenz: toplevels don't get braces
06:14:35 <tsp> although I could just code with the x = do { thing I did earlier
06:14:43 <quicksilver> what you need to look for is 'top-level semicolons'
06:14:53 <tsp> heh, ;'s could be anywhere
06:14:58 <quicksilver> but that implies your editor can match braces
06:15:03 <quicksilver> and know which semicolonos are top-level
06:15:09 <tsp> lol, edbrowse can match braces
06:15:16 <tsp> but that's it
06:15:21 <quicksilver> tsp: yes, but match braces and then exclude semicolons inside them
06:15:22 <vincenz> tsp: why not use something custom, namely place a little marker in a comment?
06:15:25 <quicksilver> tsp: which is slightly more :)
06:15:38 <tsp> vincenz: I'll probably end up doing that
06:15:40 <mauke> /=$/
06:15:49 <vincenz> {-function-}
06:15:56 <quicksilver> /=$/ is pretty good
06:15:59 <ddarius> Why not just add top level type declarations and search for those.
06:16:00 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
06:16:06 <quicksilver> as long as you make that a convention
06:16:15 <tsp> quicksilver: what's /=$/?
06:16:25 <quicksilver> tsp: regexp for equals at the end of a line?
06:16:29 <tsp> ah
06:16:30 <tsp> yeah
06:16:51 <vincenz> that would bork as soon as you have trailing spaces or one-line functions
06:16:59 <quicksilver> indeed
06:17:00 <vincenz> foo x = x + x
06:17:06 <tsp> I was thinking - can I make a function that does nothing, then put it at the beginning?
06:17:09 <mauke> trailing spaces is just /=\s*$/
06:17:10 <tsp> e.g.
06:17:25 <tsp> f x = func $ x+1;
06:17:31 <vincenz> tsp: id?
06:17:35 <tsp> where func is something that does nothing
06:17:40 <vincenz> id does nothing
06:17:55 <mauke> whatever = undefined;
06:18:00 <int-e> tsp: sure you can define   func x = x   and that will work.
06:18:02 <vincenz> > let foo x = id $ x + x in foo 2
06:18:03 <lambdabot>  4
06:18:03 <mauke> (great for prototyping, too)
06:18:23 <tsp> @src id
06:18:24 <lambdabot> id x = x
06:18:26 <tsp> ah
06:18:44 <mauke> @src undefined
06:18:44 <lambdabot> undefined =  error "Prelude.undefined"
06:19:13 <vincenz> what I love doing in haskell, is making everything undefined, making sure my top-level type signuatres are correct and then incrmenentally code, usinig the compiler to tell me when I have bugs :)
06:19:34 <vincenz> sigh, this ssh lag is really annoying, I only see what I type like a second after I type it, all these stupid typos :/
06:20:14 <vincenz> tsp: why do you use X or windows, why not a plain term?
06:20:14 <tsp> vincenz: are you sshing from a cellphone or something?
06:20:30 <vincenz> tsp: no, but for some reason the box I'm sshing to has a laggy connection
06:20:41 <tsp> vincenz: I can't use X - I just use it for qemu or vmware since orca nd gnome can speak it :) otherwise, its windows and tera term
06:20:58 <tsp> the plain terms works, until someone asks me to call them on skype
06:20:59 <vincenz> why not a plain linux tty?
06:21:04 <vincenz> ah
06:21:29 <tsp> besides, bsd on a sparc box atm, and linux on a vmware box under win for haskell
06:21:32 <vincenz> well X ONLY for skype and then linux tty's
06:21:36 <tsp> ghc doesn't like sparc64
06:23:28 <dcoutts> tsp: ghc-6.4.1 builds and works fine on sparc, 6.4.2 is ok except for some issues in ghci and 6.6 fails to work for me on sparc64
06:23:53 <tsp> dcoutts: what does 6.6 do?
06:23:54 <dcoutts> tsp: mind you I'm using 32bit user space (as I believe is common)
06:23:59 <tsp> you could probably use 6.4.2 to compile 6.6
06:24:07 <dcoutts> tsp: I've tried
06:25:19 <dcoutts> tsp: it build the ghc stage2 ghc binary (I think it was stage2 not just stage1) but when run that fails immediately with an error message like "schedule: re-entered unsafely. perhaps you forgot to make a foreign export as 'safe'? "
06:25:47 <vincenz> unsafeMakeStage2
06:25:51 <tsp> dcoutts: is this on bsd?
06:25:54 <dcoutts> tsp: there's a full bug report in the ghc trac somewhere, I think solaris had the same issue. I'm using linux.
06:25:54 <tsp> weird
06:25:58 <tsp> ah
06:25:59 <tsp> linx
06:26:01 <tsp> s/x/ux
06:26:32 <dcoutts> tsp: debian have a build but they build unregisterised, without ghci and without the threaded rts :-(
06:26:42 <dcoutts> tsp: which is a shame since 6.4.1 worked just perfectly
06:27:00 * dcoutts -> bed
06:27:05 <dcoutts> g'night folks
06:27:09 <vincenz> cya dcoutts
06:27:48 <tsp> hmm
06:28:11 <dcoutts> @tell dons I implemented the new desugarer, see the code in darcs
06:28:12 <lambdabot> Consider it noted.
06:36:31 <mux> ghc not working on sparc64?
06:36:43 <Alneyan> Naive question of the day: is it considered bad style to use parallel list comprehensions?
06:36:47 * mux ponders booting his netra X1
06:37:05 <dons> Alneyan: they're rather nice, imo.
06:37:06 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
06:37:12 <dons> Alneyan: though you can always use a zip.
06:37:20 <dons> maybe if more people used them, they'd be standardised :-)
06:37:35 <dons> Alneyan: certainly not bad style. maybe a bit obscure.
06:39:01 <Alneyan> dons: Yeah, I quite like them too, so I reckon I'll stick with them. Thanks!
06:39:14 <Saizan> parallel as in Control.Parallel?
06:39:37 <ski_> > [x+y | x <- [0,1,2] | y <- [10,30,50]]
06:39:37 <lambdabot>  Parse error
06:39:44 <merus> > [(x, y) | x <- [1..3], y <- [1..3]]
06:39:46 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
06:40:28 <Saizan> oh, i tought that was a common use..
06:40:39 <wolverian> the former, not the latter.
06:41:23 <Saizan> > [[x+y | x <- [0,1,2]] | y <- [10,30,50]] -- this?
06:41:24 <lambdabot>  [[10,11,12],[30,31,32],[50,51,52]]
06:41:29 <ski_> no
06:41:33 <ski_> not nested
06:41:47 <ski_> parallel / lock-step / zipping
06:42:13 <Saizan> liftM2?
06:42:15 <Igloo> malcolmw: What is the good reason hmake doesn't do macros?
06:42:31 <ski_> (Saizan : for certain values of 'm', yes ..)
06:42:55 <ski_> > liftM2 (+) [1..3] [1..3]  -- not this 'm', e.g.
06:42:57 <lambdabot>  [2,3,4,3,4,5,4,5,6]
06:43:03 <malcolmw> Igloo: macros are not required for conditional imports
06:44:00 <merus> > liftM2 (,) [1..2] [1..2]
06:44:01 <lambdabot>  [(1,1),(1,2),(2,1),(2,2)]
06:44:05 <merus> hunh.
06:44:20 <ski_> you want the stream monad ..
06:44:24 <malcolmw> Igloo: at least, I can't think of a good use of macros that couldn't just be placed directly into the conditional
06:44:31 <merus> the stream monad?
06:45:01 <ski_> merus ; 'return' is 'repeat', and 'join' takes the diagonal
06:45:20 <merus> Oho.
06:45:25 <malcolmw> Igloo: also, this is the first time anyone ever has tried it :-)  which is good evidence that it isn't needed
06:45:41 <ski_> (merus : and if you want, you can use potentiall-finite streams)
06:45:57 * merus `ap` class -- :(
06:46:20 <ski_> malcolmw : isn't it evidence that it was needed right here ?
06:46:41 <malcolmw> ski_: no, because it was trivially easy to replace the macro with a pure conditional
06:47:30 <ski_> malcolmw : (heh, was not following your conv.) .. where is this example showed ?
06:47:37 <malcolmw> ski_: (it even made the code shorter)
06:47:53 <quicksilver> :t repeat
06:47:56 <lambdabot> forall a. a -> [a]
06:48:01 <ski_> :t return
06:48:03 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:48:12 <malcolmw> ski_: in a patch I just pushed to the filepath package repo
06:48:14 <quicksilver> > repeat 1
06:48:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:48:36 <ski_> quicksilver,merus : so 'liftM2' basically is 'zipWith' in that monad
06:48:39 <quicksilver> ah, gotcha
06:48:41 * quicksilver nods
06:48:45 <quicksilver> yes, I worked it out now :)
06:49:03 <quicksilver> so parallel list comprehensions are in fact zipWith comprehensions?
06:49:10 <ski_> hm
06:49:22 <ski_> [x+y | x <- [0,1,2] | y <- [10,30,50]]
06:49:24 <ski_> is
06:49:36 <ski_> zipWith (+) [0,1,2] [10,30,50]
06:49:38 * quicksilver nods
06:49:42 <quicksilver> yes, that's what I meant
06:49:53 <quicksilver> is this syntax provided by some actual compiler extension?
06:49:59 <ski_> and, assuming '[]' here is our zipping monad (assuming we can hide the standard one .. or something)
06:50:14 <ski_> quicksilver : you can always make a newtype, or new datatype
06:50:27 <ski_> liftM2 (+) [0,1,2] [10,30,50]
06:50:37 <Saizan> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#parallel-list-comprehensions <--
06:50:39 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/y6v6by
06:50:44 <ski_> do x <- [0,1,2]; y <- [10,30,50]; return (x+y)
06:50:59 <ski_> [x+y | x <- [0,1,2] , y <- [10,30,50]]
06:51:06 <ski_> QED
06:51:38 <ski_> quicksilver : it looks like you're right .. amazing discovery :)
06:52:11 <sioraiocht> > do {x <- [0,1,2]; y <- [10,30,50]; return  (x+y)}
06:52:12 <quicksilver> ski_: well this converstaion started
06:52:12 <lambdabot>  [10,30,50,11,31,51,12,32,52]
06:52:17 <quicksilver> ski_: with someone talking about using them :)
06:52:18 <sioraiocht> ?
06:52:29 <quicksilver> sioraiocht: yes, but that uses the standard List monad
06:52:38 <quicksilver> sioraiocht: ski_ is talking about a different way of making lists into moands
06:52:41 <ski_> sioraiocht : that uses the ordinary list monad instance, not the one we were considering here
06:52:48 <sioraiocht> ah, sorry
06:53:03 * sioraiocht just joined the convo
06:53:37 <erider> good morning
06:53:59 <ski_> hm .. so this is strange .. the '|' in parallel list comprehensions is actually like ',', just for another monad
06:54:20 <ski_> hm, what about guards in list comprehensions
06:54:24 <ski_> ?
06:54:38 <ski_> in the ordinary list monad we have
06:55:17 <ski_> [x+y | x <- [0,3,6,9] , y <- [1,5,8] , x < y]
06:55:21 <ski_> is the same as
06:55:43 <ski_> do x <- [0,3,6,9]; y <- [1,5,8]; guard (x < y); return (x+y)
06:55:46 <ski_> :t guard
06:55:48 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
06:56:25 <ski_> so, the obvious question is : can one make out other monad an instance of 'MonadPlus', and what does guards mean there ?
06:56:33 <ski_> (s/out/our/)
06:56:53 <ski_> :t mzero
06:56:55 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
06:58:27 <ski_> hm .. which laws should hold ?
06:59:11 <ski_> i guess 'mzero' must be '[]', if anything at all .. (otherwise we get to partial values, and i don't think we should need to do that)
06:59:49 <Saizan> do (x,y) <- zip [0,3,6,9] [1,5,8]; guard (x < y); return (x+y) <-- it should behave like this one in the list monad, right?
07:00:03 <ski_> i'm not sure
07:00:27 <ski_> i still don't know what 'guard' would do in the (potentially finite) stream monad
07:00:37 <quicksilver> I don't think it can work
07:00:56 <quicksilver> the semantics saizan wants is to 'miss out' some elements of the zip
07:01:04 <quicksilver> but that's a complete change to the monad
07:01:16 <quicksilver> that effect can't be acheived with a monadplus instance
07:01:34 <ski_> left_mzero :: forall ma. mzero >> ma = mzero
07:02:00 <ski_> would 'mzero = []' satisfy that ?
07:02:25 <ski_> (>>) = liftM2 (flip const)  -- i think
07:02:53 <ski_> so that means zipping with the empty list .. and that gives an empty list !
07:02:58 <Cheery> does there exist some builtin function which would do:   (f ["ad", "be", "cg"] ", ") == ["ad, be, cg"]
07:02:59 <quicksilver> ski_: mzero = [] would kill everything
07:03:01 <quicksilver> ski_: right
07:03:04 <dino-> I was trying to get readFile behavior to be both strict and faster, so I tried Data.ByteStream.Char8
07:03:05 <Cheery> ägh, something like that
07:03:12 <quicksilver> Cheery: Data.List.intersperse
07:03:17 <ski_> quicksilver : so that law holds, at least .. yay !
07:03:24 <quicksilver> :t intersperse
07:03:26 <lambdabot> forall a. a -> [a] -> [a]
07:03:30 <dino-> It seems super slower just doing a B.readFile and then length . B.words on the result
07:03:35 <ski_> @src guard
07:03:36 <lambdabot> guard True  =  return ()
07:03:36 <lambdabot> guard False =  mzero
07:03:46 <quicksilver> > concat . intersperse ", " $ ["ad","be","cg"]
07:03:47 <lambdabot>  "ad, be, cg"
07:03:58 <quicksilver> Cheery: see? :)
07:04:04 <ski_> foo = do x <- [0,3,6,9]; y <- [1,5,8]; guard (x < y); return (x+y)
07:04:08 <dino-> Like more than twice as slow. :o
07:04:36 <ski_> 'foo' zips three lists, and maps '(\(x,y,_) -> x+y)'
07:04:38 <Cheery> I see, I need to concat it myself later then
07:04:43 <ski_> hm
07:04:43 <dino-> I wonder if I'm doing something wrong. Maybe using the wong module.
07:04:45 <quicksilver> Cheery: yes but that's not very hard :)
07:04:45 <ski_> well
07:05:13 <Cheery> concat $ intersperse ", " ["a", "b", "c"]
07:06:05 <Saizan> > concatMap (++ ", ") ["a","b","c"]
07:06:06 <lambdabot>  "a, b, c, "
07:07:29 <quicksilver> Saizan: similar but not the same :)
07:07:46 <Saizan> yeah
07:08:48 <ski_> > let return = repeat; join ((a:_):ass) = a : join (map tail . takeWhile (not . null) $ ass); join _ = []; (>>= f) = join . map f; guard b = if b then return () else [] in [0,3,6,9] >>= \x -> [1,5,8] >>= \y -> guard (x < y) >>= \_ -> return (x+y)
07:08:48 <lambdabot>  Parse error in pattern
07:09:20 <Cheery> Saizan, thanks about that too.
07:09:26 <Cheery> it's also a bit useful. :)
07:10:30 <quicksilver> Cheery: so many different ways to do stuff :)
07:11:31 <ski_> > let return = repeat; join ((a:_):ass) = a : join (map tail . takeWhile (not . null) $ ass); join _ = []; ma >>= f = join . map f $ ma; guard b = if b then return () else [] in [0,3,6,9] >>= \x -> [1,5,8] >>= \y -> guard (x < y) >>= \_ -> return (x+y)
07:11:33 <lambdabot>  [1]
07:12:05 <HairyDude> is it possible to use DrIFT to make types?
07:12:42 <dino-> Does that sound normal to anyone? That let l = B.readFile "bigassfile" >>= length . B.words  should be horrendously slower than using the Prelude readFile/words ? (where B is Data.ByteString.Char8)
07:13:09 <HairyDude> not lazy enough?
07:15:38 <quicksilver> dino-: depends how big bigass is
07:15:41 <dino-> 1M
07:15:48 <quicksilver> 1M? now that is odd
07:15:49 <dino-> 972K or something.
07:15:51 <ski_> hmm
07:15:55 <quicksilver> that's not bigass at all
07:15:59 <quicksilver> that's like really tiny :)
07:16:25 <quicksilver> there are differences, though
07:16:38 <quicksilver> B.readFile keeps around the whole file in a big chunk
07:16:54 <quicksilver> whereas the prelude version lets it be GC'ed bit by bit
07:17:02 <quicksilver> dino-: try Lazy Bytestring?
07:17:19 <dino-> Part of why I went for ByteString in the first place is I want it strict.
07:17:37 <quicksilver> nod
07:17:38 <dino-> I want to be able to output '.' chars to stderr as each file is being processed of a large group.
07:17:52 <dino-> Which, of course, doesn't sequence nice for me with the lazy read.
07:18:12 <dino-> I think
07:18:13 <quicksilver> well depends what you mean by processed
07:18:21 <quicksilver> if processed actually does something and uses the result
07:18:28 <quicksilver> then that will sequence just fine
07:18:45 <quicksilver> if it doesn't then strictifying the file doesn't really help :P
07:18:48 <dino-> I have a list of FilePath's, I want to get the number of words in each one. Each time one is done, print a '.'
07:18:53 <quicksilver> all that does is sequence the file reads
07:19:02 <quicksilver> it doesn't sequence the processing :)
07:19:17 <quicksilver> so then it has to hold all the files in memory
07:19:24 <quicksilver> until you get around to actually doing the counting
07:19:40 <dino-> ok
07:22:04 <dino-> I'm trying to gather up all the results of this counting into a list. Later I'll need to see them all to figure out column width for output.
07:26:09 <ski_> > let return = repeat; join ((a:_):ass) = a : join (map tail . takeWhile (not . null) $ ass); join _ = []; ma >>= f = join . map f $ ma; guard b = if b then return () else [] in [1,5,8] >>= \y -> [0,3,6,9] >>= \x -> guard (x<y) >>= \() -> return (x+y)
07:26:10 <lambdabot>  [1,8,14]
07:26:28 <ski_> hm .. so order seems to matter for some reason ..
07:31:42 <therp> my simply and stupid unification is presumable doing redundant work too often, any off-the-shell unification "libraries" I can use instead?
07:33:23 <dino-> I guess I can't use this in any case. It's like 2.5x slower
07:45:43 <glguy> Would anyone happen to know of an existing functional doubly connected edge list library?
07:47:45 <dino-> I wonder if there's any value in using openFile, hGetContents, hClose for this.
07:50:47 <dino-> Wow! When I do { h <- openFile "bigtext" ReadMode; content <- hGetContents h; let l = length . words $ content; hClose h; putStrLn $ show l } ...
07:50:57 <dino-> I get 0
07:50:58 <dino-> bah
07:51:08 <ski_> don't use 'hClose' on a handle you've used 'hGetContents' on ..
07:51:50 <ski_> 'hGetContents' will do a 'hClose' itself, lazily .. so you shouldn't do it yourself
07:51:52 <earthy> *unless* you've forced the contents
07:52:23 <dino-> I see.
07:52:23 <dylan> hmm, how much does it cost to buy a trusted SSL certificate?
07:52:35 <earthy> dylan: depends
07:53:03 <earthy> http://www.cacert.org/ is fairly cheap
07:53:03 <ski_> earthy : if you force the whole contents, doesn't the forcing of the final '[]' 'hClose' the handle ?
07:53:05 <lambdabot> Title: Welcome to CAcert.org
07:53:25 <earthy> ski: yeah, and that is exactly when the extra hClose doesn't kill you :)
07:53:44 <dino-> Ok, I get similar time as with Prelude.readFile now. I wonder if that's what's really going on in there anyway: (\x -> openFile x ReadMode >>= hGetContents) or similar.
07:54:00 <ski_> better to avoid extra 'hClose', imo ..
07:54:08 <dino-> ski_: thank you
07:54:31 <earthy> dylan: however, a 'commercial' license is pricey
07:55:11 <ski_> (if copy-on-write semantics was implemented in 'hGetContents', it would probably be an error to use 'hClose' then, i think ..)
07:55:49 <quicksilver> dylan: bout $100, in practice
07:55:52 <earthy> ski: hm. yah
07:56:01 <quicksilver> dylan: some places will give them for free to opensource organisation, though
07:56:03 <ski_> (anyway, one should think of 'hGetContents' as calling 'hClose', so that's why one doen't need to do it oneself .. only complication is that it call it lazilly :)
07:56:07 <ski_> @spell lazilly
07:56:09 <lambdabot> lazily Lilly lazuli labially hazily
07:56:30 <earthy> ofcourse, there are other contexts in which forcing the result garnered from hGetContents is useful
07:56:52 <quicksilver> in most of those cases you're probably better of not using it in the first place
07:56:57 <earthy> such as when you get from a child process and want to wait for it ending
07:57:02 <dino-> quicksilver: Where readFile will do, you mean?
07:57:04 * quicksilver is deeply suspicious of unsafe lazy IO
07:57:08 <quicksilver> dino-: readFile is as bad/worse
07:57:16 <dino-> oh, when you don't want the lazy at all
07:57:44 <earthy> dino-: basically, you never want IO to be lazy at all
07:58:00 * therp just recognizes how important strictness actually is for the performance of Haskell.
07:58:43 <quicksilver> if I was writing an app that didn't care about performance, I'd use strict whole-file IO
07:58:55 <quicksilver> if I was writing an app that did care, I'd do my own IO
07:59:06 <quicksilver> and make my own decisions about when to read the next chunk
07:59:22 * earthy nods
08:00:26 <quicksilver> having said that, readFile getContents are convenient in throwaway programs and shortlived scripts, if you understand the caveats
08:01:20 <dino-> Ok, but that brings me back to using Data.ByteString.Char8's readFile. When I want to call words on the result of that: unbelievably slow.
08:02:18 <quicksilver> dino-: I"m a bit baffled by that, I must admit
08:02:20 <dino-> Any alternative to that?
08:02:24 <quicksilver> dino-: I suggest a haskell-cafe posting
08:02:33 <quicksilver> dino-: you could ask dons or dcoutts, but I think they're asleep :)
08:02:39 <norpan> hmmm, bytestring is strict so the method of reading it in shouldn't matter, right?
08:03:01 <quicksilver> norpan: that doesn't really follow
08:03:09 <Philippa> "don't care but want sane memory usage" is the main use case for lazy IO
08:03:09 <dino-> That's what I should be using, right? The Char8 sub-module?
08:03:16 * ski_ wonders whether the file is huge ..
08:03:22 <quicksilver> ski_: 1M, roughly
08:03:28 <quicksilver> ski_: not very big really
08:03:29 <norpan> quicksilver: well, it'
08:03:41 <norpan> it will allocate an array for all of it and read it in strictly
08:03:42 <dino-> ski_: 952k
08:03:48 <Philippa> for values of sane where running a 10 gigabyte file through your code on a 32bit system is viable
08:03:49 <quicksilver> norpan: but only once it starts
08:04:07 <quicksilver> norpan: it might not read in when you thing it does
08:04:15 <Philippa> try a lazy bytestring?
08:04:18 <quicksilver> norpan: it will read in (all at once) once you try to do something with it
08:04:24 <norpan> yes, exatcly
08:04:26 <norpan> exactly
08:04:41 <dino-> Philippa: yeah, I'll try that. Someone else mentioned that earlier as well. I forget whom.
08:04:44 <norpan> so try another operation, like length
08:05:50 <dylan> quicksilver: what places have them for $100?
08:06:10 <quicksilver> dylan: godaddy.com
08:06:17 <dylan> ah.
08:06:19 <quicksilver> dylan: (probably not the only place)
08:06:49 <earthy> godaddy is somewhat expensive on the renewals by the way, usually
08:06:54 <earthy> at least, with domain names they are
08:07:03 <dino-> mm, very fast, B.length
08:07:16 <quicksilver> dylan: IIRC, comodo is cheap-ish, too
08:07:40 <quicksilver> dino-: B.length is O(1) for strict bytestrings, yes :)
08:07:42 <quicksilver> dino-: it knows how long its buffers are...
08:07:46 <dino-> Maybe I should try B.split ' '
08:08:15 <dino-> I see, yeah.
08:10:22 <dino-> Also much faster than B.words. Interesting.
08:14:31 <quicksilver> now that's very off
08:14:32 <quicksilver> odd
08:14:40 <quicksilver> I thought B.words *was* split ' '
08:15:24 <Saizan> > words "foo\tbar"
08:15:26 <lambdabot>  ["foo","bar"]
08:15:27 <dino-> Actually, split gives me a bigger list. Probably because adjacent spaces are counted separately. Where words is looking for space breaks between things of any length.
08:15:32 <glguy> split ' ' probably treats "a  b" differently
08:15:38 <dino-> exactly
08:15:54 <quicksilver> I'm still surprised by "much faster" though
08:16:23 <dino-> 10x faster
08:16:54 <quicksilver> if you can produce a relatively small demonstration of that, I think you should post it to the -cafe
08:17:05 <dino-> I certainly can.
08:19:00 <lizhn> does 'B' mean ByteString?
08:19:22 <dino-> lizhn: Yes  import qualified Data.ByteString.Char8 as B
08:19:45 <lizhn> dino: thx
08:19:47 <dino-> So it doesn't collide with the same-named functions in the Prelude.
08:20:58 <chessguy> hi haskellers
08:27:16 <laz0r> hi, erm, if i would like to see the definition of foldl, where would i look?
08:27:23 <rahikkala> @src foldl
08:27:24 <lambdabot> foldl f z xs = lgo z xs
08:27:24 <lambdabot>     where lgo z []     =  z
08:27:24 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
08:27:31 <laz0r> ah, thank you
08:27:45 <int-e> @src Data.List
08:27:45 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:27:57 <Saizan> @source Data.List
08:27:57 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
08:28:29 <rahikkala> Also http://haskell.org/onlinereport/ , in this case http://haskell.org/onlinereport/list.html
08:28:30 <lambdabot> Title: The Haskell 98 Language Report
08:28:30 <int-e> oh right.
08:28:34 <int-e> thanks Saizan
08:29:25 <quicksilver> laz0r: although, that's a rather odd way to define it, incidentally :)
08:29:47 <quicksilver> laz0r: most of us probably wouldn't bother with 'lgo' especially if the purpose was just to explain how it works
08:34:37 <therp> I'm asked to not walk on the grass in an organization email of a conference. I guess the only place where such a conference could be is England. And so it is.
08:35:02 <laz0r> quicksilver, actually i wondered about that too, but its ok, i figured it out... i just wanted to compare it to a definition of foldr in the wikibook im currently reading
08:35:08 <quicksilver> laz0r:  :)
09:03:33 <Saizan> ?seen kolmodin
09:03:33 <lambdabot> kolmodin is in #darcs, #gentoo-haskell and #haskell. I last heard kolmodin speak 1d 9h 35m 48s ago.
09:06:33 <ikegami--> hello
09:07:48 <ikegami--> i notice that ghc's POSIX library of Haskell may not have a feature of 'sticky bit'
09:09:07 <ikegami--> actually, ghc's System.Posix has a datatype 'FileMode', but i couldn't find stickyMode::FileMode
09:10:07 <ikegami--> therefore I wrote a short FFI snippet and, my problem was solved
09:10:37 <ikegami--> maybe POSIX does not support sticky bit, i don't know
09:12:05 <ikegami--> anyone has an interest about sticky bit issue? :-)
09:13:13 <ski_> foldl f = lgo
09:13:16 <ski_>     where ...
09:13:35 <dmwit> foldl f z [] = z
09:13:52 <dmwit> foldl f z (x:xs) = foldl f (f z x) xs
09:22:20 <quicksilver> ikegami--: pretty sure stick bits aren't in POSIX
09:22:44 <ikegami--> quicksilver: good point!
09:22:56 <ikegami--> I didn't know it
09:23:21 <ikegami--> thanks
09:24:24 <ikegami--> now I rewrite /bin/test in Haskell for a joke on April Fool
09:26:43 <ikegami--> and the '-k' option of /bin/test, which tests whether file is sticky or not, is not easy to write in Haskell (needs FFI)
09:27:39 <ikegami--> i need a small C function: mode_t stickyMode (void) { return S_ISVTX; }
09:28:28 <ikegami--> however, Haskell FFI is very useful!
09:29:09 <quicksilver> haskell FFI is nice and simple
09:29:10 <quicksilver> for simple things
09:29:13 <quicksilver> I like that very much
09:31:35 <ikegami--> now I can add some options to /bin/Test, which is written in Haskell
09:31:59 <ikegami--> even /bin/test has over 30 options
09:33:08 <ikegami--> I think it's interesting idea that every commands in /bin is rewritten in Haskell
09:33:52 <Igloo> ikegami--: Is there not even a function for it in System.Posix somewher?
09:34:49 <kpreid> when I looked, there wasn't one
09:35:45 <ikegami--> Igloo: I refer /bin/test of GNU coreutils 6.9, and only '-k option (check sticky bit)' needs FFI
09:36:38 <ikegami--> Igloo: other options can be written with System.Posix and some with System.IO, System.Directory
09:36:39 <Igloo> Hmm, it would be nice to propose a patch for the unix package in that case
09:37:35 <twb> Why am I still here?
09:37:47 <glguy> > let poly_eval = flip foldl 0 . (((+) .) . (*)) in poly_eval 3 [2,2,1]
09:37:49 <lambdabot>  25
09:39:43 <mauke> ikegami--: you could use hsc2hs
09:40:14 <chessguy> glguy:  that's a nice one
09:40:18 <sioraiocht> zomg TOO MANY EMAILS
09:40:23 <chessguy> took me a minute to figure out what you were doing
09:40:25 <sioraiocht> ...wrong window
09:40:26 <sioraiocht> sorry
09:40:41 <int-e> @pl \x l -> sum (zipWith (*) (repeat x) l)
09:40:42 <lambdabot> (sum .) . zipWith (*) . repeat
09:40:43 <chessguy> (and i still have no idea how it works)
09:41:07 <int-e> argh
09:41:31 <chessguy> @type (sum .) . zipWith (*) . repeat
09:41:34 <lambdabot> forall a. (Num a) => a -> [a] -> a
09:41:44 <glguy> > let poly_eval x cs = foldr ((. (* x)) . (+)) 0 cs in poly_eval 3 [1,2,2]
09:41:46 <lambdabot>  25
09:41:46 <int-e> repeat is wrong anyway.
09:41:58 <quicksilver> I"m still not happy enough with the (f .) . g . h idiom to use it in real code
09:42:06 <quicksilver> I suppose it's all familiarity and subjective
09:42:09 <ikegami--> mauke: thanks, now I'm looking the manual of hsc2hs
09:42:15 <int-e> @pl \x l -> sum (zipWith (*) (repeat iterate (x*) 1) l)
09:42:16 <lambdabot> (sum .) . zipWith (*) . flip (repeat iterate . (*)) 1
09:42:21 <quicksilver> but I'm quite happy with f x . g y . h z
09:42:25 <quicksilver> and don't much like (f .) .
09:43:09 <mauke> ikegami--: basically, you use stickyMode = #{const S_ISVTX}
09:43:20 <ski_> :t \x -> repeat iterate x
09:43:23 <lambdabot>     Couldn't match expected type `t1 -> t'
09:43:23 <lambdabot>            against inferred type `[(a -> a) -> a -> [a]]'
09:43:36 <araujo> morning
09:43:42 <quicksilver> actually, in general, I suppose I'm not all that happy with pointfree forms which take more than one paramter in any but the most obvious way
09:44:15 <chessguy> araujo!
09:44:22 <araujo> chessguy, hola!
09:44:33 <chessguy> que hay?
09:44:59 <glguy> I generally dont use pointfree code like the above outside of #haskell
09:45:01 <chessguy> @type (f .) .
09:45:03 <lambdabot> parse error (possibly incorrect indentation)
09:45:12 <chessguy> @type (?f .) .
09:45:15 <lambdabot> parse error (possibly incorrect indentation)
09:45:20 <glguy> ?type ((f .) .)
09:45:23 <lambdabot> Not in scope: `f'
09:45:26 <ski_> :t \f -> ((f .) .)
09:45:29 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
09:45:32 <quicksilver> chessguy: (f .) . composes in the second paramter, in some sense
09:45:35 <araujo> chessguy, no mucho ... despertandome :-)
09:45:40 <vincenz> @pl \f -> ((f .) .)
09:45:41 <lambdabot> (.) . (.)
09:45:50 <vincenz> araujo: hola, que tal
09:45:52 <quicksilver> tis the famous boobie combinator
09:45:56 <araujo> vincenz, hola!
09:46:04 <chessguy> @quote casado
09:46:05 <lambdabot> chessguy says: mejor cansado que casado!
09:46:06 <vincenz> de donde eres?
09:46:10 <araujo> haha
09:46:13 <ikegami--> mauke: aha, very short!
09:46:20 <araujo> vincenz, venezuela :-)
09:47:11 <vincenz> me gusta isla marguertia
09:47:53 <glguy> ugh, I can't focus today
09:48:04 <glguy> I think that my allergy medicine is affecting me
09:48:11 <chessguy> vincenz cree que puede conversar con nosotros :)
09:49:28 <araujo> vincenz, haha
09:49:34 <araujo> vincenz, have you been there?
09:49:41 <vincenz> araujo: indeed I have
09:49:48 <araujo> Remember we have #haskell.es
09:49:54 <vincenz> chessguy: I thought you didn't know me
09:50:46 <araujo> vincenz, hah, nice
09:52:26 <chessguy> vincenz: i don't
09:52:50 <vincenz> Then refrain from the personal comments
09:52:51 <vincenz> :)
09:53:37 <ikegami--> mauke: it works. thanks. I prefer to hsc2hs
09:59:33 <Igloo> Does anyone know a pwd-equivalent for cygwin that will give a path starting c:/?
10:00:03 <vincenz> \cygdrive\c
10:00:03 <vincenz> ?
10:00:14 <vincenz> something to that extent
10:00:21 <ndm> Igloo: can't you write one in haskell in about a line?
10:00:40 <ndm> i had to re-implement which in Haskell, since the one that comes with cygwin always goes barmy for me
10:01:06 <Igloo> ndm: I guess I'll have to
10:01:19 <vincenz> Igloo: oh sorry, I misinterpreted your question, I thought you were asking where c:/ was located in cygwin
10:01:27 * ndm thinks a complete set of console utilities in Haskell would be handy
10:01:55 <ndm> i currently use unix-tools, but a haskell reimplementation of most would be trivial
10:02:22 <ndm> is there any way to create a NaN in haskell without divide by zero?
10:02:41 <ndm> or alternatively, are there any other predefined Haskell values which have Ord which isn't a proper ordering?
10:05:54 <Igloo> ndm: Why without division by zero?
10:06:15 <ndm> Igloo: catch models division by zero as a pattern match failure
10:06:19 <ddarius> sqrt (-1)
10:06:22 <emu> > (1/0) < 1
10:06:23 <lambdabot>  False
10:06:23 <ndm> break2 = sizeFM $ delFromFM (unitFM nan ()) nan
10:06:25 <ndm>     where nan = 0 / 0
10:06:36 <int-e> > let x = 2**100000; y = 3**10000 in x-y
10:06:37 <lambdabot>  NaN
10:06:41 <doserj> > sqrt (-1.0)
10:06:42 <lambdabot>  NaN
10:06:43 <ndm> Igloo: that above example causes finite map to crash with a pattern match error
10:06:51 <int-e> > let x = 2**100000 in x-x -- tsk, gets optimized to 0.
10:06:52 <lambdabot>  0.0
10:07:12 <ndm> doserj: hmm, thats still not great (catch demands non-negative for square root), but may be better
10:07:50 * ndm likes the fact that he can crash FiniteMap :)
10:08:26 <ddarius> Oh, ndm.  One thing that struck me is that it seems that you should be citing quite a bit of abstract interpretation work.
10:08:51 <ndm> ddarius: ah, quite possibly - do you have any particular reference for Haskell/functional languages?
10:09:30 <ndm> there is plenty of strictness stuff, but i haven't seen anything on shape analysis or anything in a functional language
10:09:40 <ddarius> ndm: The only paper I can think of off hand that I think directly uses Haskell and abstract interpretation is too specific for you (I think it's a strictness analysis thing.)
10:09:52 <ddarius> Exactly.
10:09:56 <ndm> ddarius: if you have the name of that paper, i can follow up its references
10:10:14 <ndm> ddarius: probably worth mentioning strictness analysis in the paper anyway, as it is _the_ analysis for haskell
10:10:41 <ddarius> For abstract interpretation in general you could, among others, cite Cousot Cousot.
10:11:02 <ddarius> Actually, I think there's a paper that relates type checking and abstract interpretation that may use Haskell or another functional language.
10:11:38 <ndm> ddarius: remember anything names/authors of that?
10:12:25 <ddarius> I think I may be able to find it.  I only have about 20 more minutes, so if I don't find it now I'll email or @tell you it if I find it later.
10:13:02 <ddarius> Cousot & Cousot paper if you want to cite that http://www.di.ens.fr/~cousot/COUSOTpapers/POPL77.shtml
10:13:05 <lambdabot> Title: P. Cousot & R. Cousot, Abstract interpretation: a unified lattice model for stat ...
10:13:38 <ndm> ddarius: thanks :)
10:14:10 <ndm> i read the neilsen*2 and hankin book on static analysis - so i know plenty of static anlaysis, but it does definately need a citation for abstract analysis
10:15:15 <ski_> not (diagonal . map diagonal . transpose = diagonal . map diagonal)
10:17:00 * sioraiocht o.O
10:17:43 <ddarius> ndm: http://www.haskell.org/haskellwiki/Research_papers/Compilation#Strictness probably includes the paper I was thinking of for strictness analysis, if not it definitely includes some.
10:17:46 <lambdabot> Title: Research papers/Compilation - HaskellWiki, http://tinyurl.com/yst9wl
10:18:35 <ndm> ddarius: thanks
10:18:49 <ndm> it also has one on strictness analysis
10:19:07 <ski_> @check let diag ((a:_):ass) = a : diag (map tail . takeWhile (not . null) $ ass); diag _ = [] in \asss -> (diag . map diag . transpose $ asss) == (diag . map diag $ asss :: [Int])
10:19:09 <lambdabot>  Falsifiable, after 13 tests: [[[-5,-7,-4,-1,1,7,5],[]],[[-4,-7,-3,-2,-1],[-7...
10:20:17 <ski_> this is why the (potentially finite) stream monad is not commutative
10:20:54 <ddarius> http://www.di.ens.fr/~cousot/COUSOTpapers/POPL97.shtml
10:20:55 <lambdabot> Title: P. Cousot, Types as Abstract Interpretations
10:21:27 <ddarius> I haven't read this, but it may also be good, it uses ML http://citeseer.ist.psu.edu/602127.html
10:21:31 <lambdabot> Title: An Experiment in Type Inference and Veri (ResearchIndex)
10:22:07 <ndm> ddarius: perfect
10:22:15 <mattam> its mostly unreadable
10:22:22 <ddarius> Anyways, I'm off.
10:22:24 <ndm> ddarius: a recent paper, on a functional language - i'll definately cite it - i may read the abstract ;)
10:22:49 <ddarius> Types as Abstract Interpretation is pretty relevant and uses the (eager) lambda calculus.
10:23:24 <ndm> neat, thats a good one
10:23:44 <mattam> really this one shouldn't be referenced, just have a look at it :)
10:24:03 <ski_> ddarius : hm, which paper was about strictness analysis ?
10:24:09 <mattam> if you have to explain it you will be in deep trouble
10:24:51 <ndm> mattam: i'll take a brief look, but you never have to explain a reference in a conference paper
10:25:15 <ndm> in a thesis its a different matter
10:25:18 <mattam> well, you may have to if you meet cousot
10:25:39 <ndm> hehe, i'm sure he understands his paper ;)
10:25:41 <mattam> that's what i meant
10:25:52 <mattam> yeah, exactly :)
10:26:55 <ndm> i'll print a copy now, and see if it does the goods or not
10:31:57 <phoniq> what's the emacs setup of choice for haskell?
10:32:15 <phoniq> haskell-mode with shim?
10:41:28 <emu> how is shim doing
10:42:32 <ndm> mattam: that paper is entirely impenetrable, it just goes silly quite quicly
10:43:20 <mattam> indeed
10:43:36 <ndm> i'll cite the older one, at least that made sense
10:43:43 <ndm> this one may be some cryptic code for a joke
10:44:05 <monochrom> try to know the content of what you cite. maybe you don't read it directly but you have to learn its content from somewhere.
10:44:13 <mattam> well, it's surely a code for "all your types are belong to us"
10:44:56 <mattam> submitting to ICFP ?
10:45:20 <monochrom> e.g., one may cite the original monad papers, never read it but learned monad somewhere else.
10:47:15 <monochrom> There is a joke among the community of digital signal processing.  Everyone cites the original paper that gave the fast fourier transform algorithm, but how many have read it :)  They all learned the algorithm from textbooks written after that paper.
10:49:06 <monochrom> Cousot's papers and talks are quite cryptic.  Dialogues in person are normal.  Someone who has met him told me this.
10:49:19 <mattam> it is certainly best this way. source papers are as often badly written as others in my small experience
10:50:34 <mattam> man, ghc takes ages to compile
10:53:11 <monochrom> The Cousot experience is quite surreal, I'm told.  Talks are cryptics but dialogues are fine.  So, you go to his talk, it's all unreadable math.  Then you ask a question, and suddenly he makes a lot of sense.  Then he continues the talk, and it's back to Martian.  The mode switch is quite surreal.
10:54:04 <mattam> Yes i've seen that happen :-)
10:55:16 <ndm> mattam: yes, i am submitting to ICFP
10:56:34 <ndm> hmm, are there any Haskell types that are in Eq but not Ord?
10:56:52 <int-e> no.
10:56:56 <int-e> Ord requires Eq
10:57:09 <ndm> int-e: my question is the other way round
10:57:13 <mattam> The point is that he's the abstract one and his students do the concretion of his ideas somehow. That's how his course on AI is done: he does the theory, they show how it can be applied successfully (which require that you have grasped the theory too).
10:58:10 <int-e> ndm: hah. hmmm.
10:58:19 <bos> ndm: Bool?
10:58:27 <ndm> @instances Bool
10:58:28 <lambdabot> Couldn't find class `Bool'. Try @instances-importing
10:58:45 <ndm> bos: it is an instance of ord, for example the <= operator is implies ;)
10:58:52 <bos> oh, huh.
10:58:59 <int-e> ndm: Complex
10:59:06 <monochrom> "haskell types" as in those provided by the standard?
10:59:18 <bos> yes, looks like all standard types in Eq are also in Ord
10:59:28 <bos> even () is in Ord, which is just weird.
10:59:36 <bos> > () > ()
10:59:38 <lambdabot>  False
10:59:51 <ndm> int-e: well found, thanks :)
11:00:03 <mattam> so you can sort lists of units :)
11:00:08 <ndm> int-e: is that the only one?
11:00:24 <bos> Complex is a bit different because it's a typeclass
11:00:36 <hpaste>  LPhas pasted "(no title)" at http://hpaste.org/1198
11:00:52 <monochrom> If you allow the FFI, certain pointer types are Eq but not Ord
11:00:52 <mattam> Option has one ?
11:01:11 <mattam> err Maybe
11:01:12 <ndm> monochrom: thats a good one, comlex numbers are quite difficult
11:01:59 <monochrom> Oh damn I misread, the pointer types are Ord.
11:02:54 <monochrom> But yeah, Complex Double is Eq but not Ord.
11:02:56 <int-e> ndm: it's the only one I can think of (aside from obvious derivatives like [Complex] or Array i Complex)
11:03:10 <ndm> int-e: thanks
11:04:06 <monochrom> Handle is Eq and not Ord :)
11:04:14 <int-e> (and I realize that Complex is missing a type argument there)
11:04:14 * monochrom is doing an exhaustive search :)
11:04:31 <Botje> exhausted eyt?
11:04:55 <monochrom> IOException
11:04:56 <ndm> i'm just doing an exhaustive hoogle database manip
11:05:15 <Cheery> do you guys have some method for chaining things? like: a ++ b ++ c, without the (++)s
11:05:25 <kpreid> Cheery: concat
11:05:49 <kpreid> Cheery: most operators have list versions when appropriate
11:05:50 <dataangel> Is there a good explanation somewhere of haskell's memory model? Like how long does it keep the results of lazy evaluation of a list before it drops it to let it be recomputed the next time it comes up, etc.?
11:06:21 <kpreid> ndm: IORef is Eq but not Ord
11:06:39 <ndm> i have a list now, i'll just post it
11:07:08 <monochrom> Fun.
11:08:38 * monochrom is an organic Hoogle :)
11:08:49 <dataangel> brb
11:09:11 <Orphi> is there a way to make GHCi / a GHC-compiled program crash if it uses for than X bytes of RAM?
11:09:37 <Orphi> I just ran a program and it almost killed my PC by exhausting all available virtual memory :-}
11:09:52 <sieni> well, I guess the program just aborts if it runs out of memory
11:10:03 <monochrom> Yes. There is a way of "+RTS something" to say the heap must never exceed X.
11:10:21 <Orphi> I see... any idea what the 'something' is?
11:10:25 <kpreid> Orphi: or you could use your OS's memory limit
11:10:29 * Orphi starts flicking through the GHC manual
11:10:33 <ndm> http://neilmitchell.blogspot.com/2007/03/eq-but-not-ord.html
11:10:35 <lambdabot> Title: Neil Mitchell's Haskell Blog: Eq but not Ord
11:10:38 <sieni> Orphi: what about ulimit -v?
11:11:05 <Orphi> what's ulimit?
11:11:20 <Excedrin> -M<size> Sets the maximum heap size (default unlimited)  Egs: -M256k -M1G
11:11:23 <wy> I'm trying to switch to Windows version of Haskell. But I got the error the 'impossible' happens when I tried to run the program wrote in Linux
11:11:47 <Orphi> Excedrin: ah... that sounds like what I want.
11:12:01 <Excedrin> ./somebinary +RTS '-?' will spit out all of the valid RTS options
11:12:12 <Orphi> also worth knowing :)
11:12:29 <Orphi> FWIW... I did a sorting benchmark
11:12:39 <Orphi> quicksort took 500 ms... insertion sort almost killed the PC o_O
11:12:58 <ndm> wy: from the compiler? can you give the full error message
11:13:00 <ndm> @paste
11:13:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:13:01 <monochrom> Thou hast very leaky insertion sort indeed.
11:13:10 <Orphi> er... yeah
11:13:13 <wy> I'm wondering if it's possible to use Haskell under Windows
11:13:14 <ndm> wy: ^^^ paste it if its too long
11:13:21 <ndm> wy: yes, i do all the time, and am right now
11:13:27 <Orphi> I'm not completely convinced I shouldn't have used the strict version of fold...
11:13:31 <wy> : panic! (the 'impossible' happened)
11:13:31 <wy>   (GHC version 6.6 for i386-unknown-mingw32):
11:13:31 <wy> 	loadObj: failed
11:13:31 <ndm> wy: Haskell is 100% supported on windows
11:13:50 <ndm> wy: is that running a linux binrary? or compiling?
11:13:59 <ndm> wy: how do you provoke that?
11:14:06 <wy> I'm using emacs and running ghci just on the source
11:14:33 <Orphi> I don't have the source with me, but it was something like > isort = foldl insert []
11:14:49 <wy> ndm, I'm wondering if my set up is wrong. I just unzipped the package of ghc6.6
11:14:58 <ndm> wy: why not use the installer?
11:15:03 <Jaak> @src sort
11:15:04 <ddarius> :t insert
11:15:04 <lambdabot> sort = sortBy compare
11:15:06 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
11:15:08 <ndm> thats what i do, and its very reliable
11:15:25 <wy> ndm, Maybe I should try the installer
11:15:29 <ddarius> > foldl' insert [] [100,99..0]
11:15:29 <Jaak> @src sortBy
11:15:30 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
11:15:30 <lambdabot>       Expected...
11:15:31 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:15:36 <Jaak> there
11:15:42 <wy> ndm, does it set some environment variable other than PATH?
11:15:47 <sioraiocht> okay
11:15:55 <ndm> wy: no
11:16:04 <sioraiocht> ghci runs my code, but when i try and compile, i get
11:16:05 <sioraiocht> usr/bin/ld: Undefined symbols:
11:16:05 <sioraiocht> _stmzm2zi0_ControlziMonadziSTM_check_closure
11:16:06 <ndm> wy: but it may play with the registry slightly, although i didn't think so
11:16:08 <sioraiocht> ...why?
11:16:17 <ndm> sioraiocht: did you pass --make ?
11:16:40 <sioraiocht> no...
11:16:43 <Orphi> anyhow... a while back a wrote a quicksort that swaps to insert sort when the list becomes "small"
11:16:48 <wy> ndm, I'm installing
11:16:54 <Orphi> but my mistake: using the length function ;)
11:16:57 <sioraiocht> and it's just one script, with 3 imports
11:17:09 <sioraiocht> ndm: that worked
11:17:14 <sioraiocht> ndm: what does that do?
11:17:26 <Saizan> it links the packages you imported in the binary
11:17:29 <sioraiocht> ah
11:17:34 <ndm> sioraiocht: that makes it link properly, always do --make (Yhc is always in --make mode)
11:17:50 <int-e> Orphi: merge sort works better for linked lists
11:18:16 <Orphi> int-e: I had expected this... but a benchmark showed it as SLOWER than quicksort... for no obvious reason
11:18:25 <ski_> > foldl' (flip insert) [] [100,99..0]
11:18:26 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:18:27 <mightybyte> @src FilePath
11:18:28 <lambdabot> type FilePath = String
11:18:58 <Orphi> @src Data.List.sort
11:18:58 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:19:05 <Orphi> ...?! o_O
11:19:07 <sioraiocht> thanks guys, I'm not used to compiling my code :)
11:19:22 <wy> ndm, the same problem...
11:19:34 <wy> ndm, do you use emacs ?
11:19:42 <ndm> wy: no, i use textpad and winhugs
11:19:50 <ndm> wy: does it work when you run things from the command line?
11:20:33 <wy> ndm, I haven't tried yet
11:21:02 <wy> ndm, too bad. emacs froze
11:21:24 <ndm> wy: try the command line, if it seems to not be Emacs fault, then report it as a bug
11:21:28 <sioraiocht> is there anyway I get a function to loop forever so that its thread doesn't die?
11:21:32 <ndm> possibly report it as a bug anyway
11:21:37 <ddarius> ndm: The relevance of the Eq not Ord... ?
11:21:44 <Saizan> ?src forever
11:21:44 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:21:48 <ndm> ddarius: I can crash FiniteMap
11:21:58 <ndm> instance Ord Errno where compare _ _ = EQ
11:22:00 <ndm> break3 = sizeFM $ delFromFM (unitFM (Errno 1) ()) (Errno 2)
11:22:01 <Cheery> why does it yell when I do something like this? > instance StyleElement [Import] where
11:22:05 <mightybyte> Is it possible to use guards to tokenize strings?
11:22:15 <Cheery> class StyleElement a
11:22:17 <Saizan> sioraiocht, just call it again at the end
11:22:22 <monochrom> You can get a function to block forever so that its thread doesn't die.  Create an MVar and wait on it.
11:22:26 <ndm> ddarius: you just have to prevert the Ord function, and the example is shorter if you don't have to introduce a new data type
11:22:38 <monochrom> block forever is cheaper than loop forever
11:22:47 <Cheery> So, why can't I give such instance of my class StyleElement for a list of type Import?
11:22:55 <ndm> anyway, me off home - bye
11:22:58 <sioraiocht> Saizan: it forks off threads, I want 20, not an infinite number ;)
11:24:31 <Orphi> Cheery: AFAIK, you can write an instance for ALL lists, not just not for one specific type of list...
11:24:53 * Orphi waits to be contradicted
11:25:13 <ddarius> If you do, you can't make an instance for any particular list of X
11:25:40 <Cheery> > instance StyleElement a => StyleElement [a] where
11:25:41 <lambdabot>  Parse error
11:25:49 <Cheery> that works.
11:26:00 <Cheery> but it does not do exactly what I'm looking for
11:26:24 <Cheery> Import requires to be handled differently than say, other instance of the same class
11:26:51 <Saizan> mmh, what's the error?
11:27:13 <Cheery> Illegal instance declaration for `StyleElement [Import]'
11:27:27 <Cheery> (The instance type must be of form (T a b c)
11:27:36 <Cheery> where T is not a synonym, and a,b,c are distinct type variables)
11:27:36 <Cheery>     In the instance declaration for `StyleElement [Import]'
11:27:39 <Orphi> instance Foo (Tree a) where  -- should work
11:27:49 <Orphi> instance Foo (Tree Int) where  -- wont' work
11:28:11 <Cheery> Orphi: why?
11:28:26 <Orphi> that's apparently how the rules work
11:28:30 <Orphi> if I'm remembering this right...
11:28:43 <Saizan> i think it's a restrictive rule to make type inference decidable
11:28:49 <Saizan> or something like that
11:29:07 <Saizan> have you tried with -fglasgow-exts?
11:29:07 <Orphi> in fact yeah - it says in right there in the error message; T a b c, where a, b and c are type VARIABLES, not specific types
11:29:23 <Orphi> you'll probably have to play with newtype :(
11:29:24 <Cheery> tried, said same
11:29:48 <Orphi> newtype Foo = Bah Int      and then        instance Thing Bah    might work
11:30:03 <Cheery> are you sure?
11:30:10 <Orphi> no
11:30:12 <Orphi> lol
11:30:12 <Saizan> instance Thing Foo
11:30:15 <jyasskin> Cheery: You may want -fundecidable-instances (or one of the other two -fblah-instances flags)
11:30:41 <Orphi> ...uh, yeah, what Saizan said :$
11:30:43 <Cheery> heha, maybe that Foo -thing goes. :)
11:31:46 <Orphi> so in your case, it's... let me see.... newtype ListImport = [Import], and then instance StyleElement ListImport where...
11:32:15 <Orphi> gah... newtype ListImport = MkListImport [Import]
11:32:24 <Saizan> but it's quite ugly
11:32:28 <Orphi> indeed
11:32:36 <Saizan> -fallow-undecideable-instances ftw
11:32:44 <Cheery> unnamed.lhs:25:21: parse error in data/newtype declaration
11:32:50 <Orphi> and it won't magically make [Import] behave differently; you have to manually tag on MkListImport to get the different behaviour.
11:32:51 <Saizan> s/undecideable/undecidable/
11:33:17 <Orphi> otherwise, yeah, bring on the experimental type system extensions! :-}
11:33:24 <Cheery> :P
11:33:55 <Cheery> {-# OPTIONS -fallow-undecideable-instances #-}
11:33:59 <jyasskin> Cheery: You can also say (roughly) class HasListStyleElement ; instance HasListStyleElement Import; instance HasListStyleElement a => StyleElement [a] where ...;
11:34:05 <Orphi> hmm... rank-2 polymorphism, multiparameter type classes, functional dependencies, GADTs, polymorphic components, existantial quanitification...
11:34:08 * Orphi feels ill
11:35:15 <Orphi> ...now that's what I call thinking! heh
11:35:15 <Saizan> MPTC are in mtl, i won't count them as "experimental" or anything
11:35:31 <Cheery> except the option -thing does not fix it
11:35:33 <Orphi> mtl?
11:35:40 <jyasskin> See http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html#t%3AIsChar
11:35:42 <lambdabot> http://tinyurl.com/2gflfv
11:35:55 <Saizan> Orphi: Control.Monad and co.
11:36:21 <Orphi> to me, anything not in Haskell 98 is "experimental" ;)
11:36:31 <Orphi> let's face it, Haskell 98 is pretty powerful on its own...
11:36:43 <jyasskin> Particularly the "instance IsChar c => PrintfArg [c]"
11:37:19 * Orphi destroys a priceless ELO classic with his bad singing
11:37:25 <Cheery> I think I stop hitting myself to head with a keyboard and go on, it's not too big trouble to not be able to do that
11:37:30 <Saizan> Orphi: yeah, but it requires some strange class encoding like in this case
11:37:45 <Igloo> Orphi: Sure, and sed is Turing complete :-)
11:38:09 <Orphi> POV-Ray is Turing complete... I'm still trying to replace it's language with Haskell 98 ;)
11:38:32 <Cheery> Orphi: cool
11:38:50 <monochrom> Postscript can do ray-tracing.
11:39:02 <Cheery> I've been wondering in what sense it is turing complete
11:39:08 <Orphi> seriously... Haskell seems to attract bizzare type system extensions like anything. I've yet to see much explanation of what all this stuff is for!
11:39:40 <Orphi> Postscript can most certainly do ray-tracing. Now try to rasterise it on a HP LaserJet 6P...!
11:39:58 <Orphi> (the users weren't amused)
11:40:00 <monochrom> I think it's due to a combination of the two Simons and the one Oleg.
11:40:47 <Saizan> orphi, ofr example, if Monad was a MPTC we could have a Set monad
11:41:21 <monochrom> I now think the idea of type classes attracts lots of extension dreams.
11:41:41 <Orphi> I have a Haskell book here, and virtually everybody involved in its production works at Oxford Uni. I should get over there! lol
11:42:09 <monochrom> Study under Richard Bird. You will come out reborn.
11:42:22 <Orphi> 3 guesses who edited this book :P
11:42:53 <Orphi> and then 3 guesses what the book is... after all, the Haskell bookshelf is hasn't "large"
11:43:07 <Orphi> grr... my typing sucks tonight :(
11:43:37 <ddarius> monochrom: It doesn't help that the Haskell masses swarm upon new extensions like vultures as soon as they are available.
11:44:38 <Orphi> ...there are Haskell masses?
11:46:30 <Orphi> random question: if I somehow succeeded in writing a Haskell to Java compiler, would anybody care?
11:46:51 <monochrom> Haskell extensions are more conservative than other community's extensions. By this I mean the former receives quite some rigour while the latter are just based on delusive intuition. Consequently the mass feels more confident, and objective there is less grey area ==> less need to debate.
11:46:57 <ski_> Orphi : java or jvm bytecode ?
11:47:06 <Orphi> Java source
11:47:09 <monochrom> s/objective/objectively/
11:47:49 * SamB wonders why his system is writing to disk so much...
11:47:50 <Orphi> monochrom: I gather the Haskell' guys are currently debating FDs vs ATs
11:48:13 <SamB> Orphi: really?
11:48:21 <Orphi> apparently...
11:48:33 <SamB> I was kinda just waiting to get the chance to run them head to head ;-)
11:48:34 <Orphi> myself I like ATs more... but no one has ever implemented them
11:48:57 <Orphi> [...although if my Haskell to Java compiler ever happens... muhuhuhuh!]
11:49:14 <dino-> That thing I was talking about earlier, hideous Data.ByteStream.Char8.words performance. Seems like it all stems from the B.splitWith isSpace
11:49:15 <SamB> we have ATs, but ATs are not so great compared to AT synonyms
11:49:27 <dino-> If I change that to B.split ' ', tremendously faster.
11:49:35 <SamB> (only in GHC 6.7, mind you, but still...)
11:49:46 <SamB> and AT synoyms we haven't got yet
11:49:53 <SamB> I found that out the hard way
11:50:00 <monochrom> There are some debates. Note that the level is higher. We don't debate "should we have GC? should we have foldl?".  The Python people use only subjective intuition and therefore they debate obvious things, for example.
11:50:01 <Orphi> ...and again I'm feeling hopelessly lost...
11:50:04 <Saizan> AT?
11:50:12 <Saizan> ah, associated types?
11:50:16 <SamB> Saizan: yes
11:51:01 <jyasskin> Orphi: For jvm bytecode, yes. Being able to integrate with the large number of existing libraries there would be really handy.
11:51:13 <SamB> personally, I am in the "both for now" camp, but I'm fine with fundeps not being standardized for at least the near future
11:51:30 <Orphi> jyasskin: my plan was to make a program that dumps out Java source code
11:51:37 <Orphi> then you compile it with javac as normal
11:51:44 <SamB> (i.e., until we get a feel for what AT Synonyms let us do and what they do not let us do)
11:51:49 <Orphi> and if I can make a clean way to call existing Java code - and backwards...
11:52:11 <Saizan> i think there's yet some project to build to jvm bytecode
11:52:21 <SamB> Orphi: it is called the FFI
11:52:35 <Orphi> Saizan: yeah, probably...
11:52:49 <Orphi> my main motivation is to be able to experiment with running stuff an parallel and so on
11:53:06 <SamB> can't you already do that in Haskell?
11:53:13 <Orphi> SamB: I'll be very surprised if you can call *Java* with FFI
11:53:36 <monochrom> GHC threading may be more efficient than Java threading.
11:53:42 <SamB> Orphi: oh, well, you probably need to write an addendum to the FFI addendum
11:53:53 <SamB> to talk about the Java-specific aspects of it
11:54:08 <Orphi> SamB: I'm thinking more it's probably fundamentally impossible to call Java from *any* natively compiled language...
11:54:16 <SamB> heh
11:54:20 <kowey> Orphi: have you seen lambdavm? http://www.cs.rit.edu/~bja8464/lambdavm/
11:54:21 <SamB> of course it isn't
11:54:23 <lambdabot> Title: LambdaVM - The Haskell to Java Translator
11:54:33 <Orphi> nope
11:54:36 * Orphi checks it out
11:54:54 <SamB> anyway I was assuming you'd be doing this with your hs2java compiler
11:55:22 <SamB> that doesn't seem like a very nice name
11:55:27 <SamB> "lambdavm"
11:55:38 <SamB> it in no way indicates that JVM is involved
11:55:39 <Orphi> I was thinking "Haskell over Java" - HoJ
11:56:18 * SamB wonders whether JNI would permit calling Java from Haskell directly
11:56:44 * Orphi wonders what JNI is - and then quickly decides it's probably better not to know
11:56:45 <SamB> (that is, without having to have "main" implemented in Java)
11:56:52 <SamB> Orphi: Java Native Interface
11:57:07 <SamB> that sounds kinda relevant, doesn't it?
11:57:15 <Orphi> I used to program stuff in Java... but it's just such an annoying language to use. heh.
11:57:21 <Orphi> so many flaws to work round
11:57:37 <Orphi> I haven't kept up to date with the technology much
11:57:45 <SamB> well JNI is, afaik, a C API
11:58:11 <Orphi> I know you can call C (and probably others) *from* Java. I'd just be surprised if you can go the other way...
11:59:13 <Orphi> anyway, Haskell is a wonderful language, but there's an annoying amount of stuff it can't do.
11:59:18 <Orphi> Java can do most of that stuff
11:59:24 <Orphi> so if I could convert one to the other...
11:59:44 <phoniq> you can call java from c
11:59:56 <Orphi> [of course, whether this project will ever get beyond an early draft is another matter entirely. lol!]
12:00:01 <SamB> what can Java do that Haskell cannot do?
12:00:10 <Cheery> Orphi: there's an annoying amount of stuff you don't actually need when toying with haskell
12:00:25 <Orphi> well, let me see... graphics, sound, database access...
12:00:34 <Excedrin> SamB: run in a browser?
12:00:49 <Cheery> sure, you lack those
12:00:53 <SamB> Excedrin: what browser does Java run in?
12:00:57 <SamB> Orphi: heh
12:01:07 <Excedrin> SamB: IE?
12:01:17 <Cheery> Orphi: but those who have them lacks higher level stuff from some reason
12:01:19 <SamB> sound might be nice
12:01:19 <Igloo> Orphi: Haskell has GLUT/Gtk2, ALUT, and various database libraries
12:01:26 <SamB> I'd like it if Linux would support that
12:01:38 <SamB> well, I mean, it can go boing and such
12:01:50 <SamB> maybe ALUT works
12:02:01 <Orphi> I'm currently attempting to survive Gtk2hs
12:02:05 <Orphi> it's very hard work
12:02:14 * SamB blames GTK
12:02:18 <Orphi> (mind you, GUI programming usually is...)
12:02:33 <Cheery> game deployment systems, proper web tools, proper UI programming tools, etc.
12:02:50 <SamB> I want Qt bindings so that gtk2hs will have some competition...
12:03:01 <SamB> Cheery: games? you don't write games in Java afaik.
12:03:06 <Orphi> I'm told somebody implemented Quake in Haskell... I don't know how that's physically possible ;)
12:03:17 <Igloo> SamB: What issues does gtk2hs have that you think cmpetition would solve?
12:03:17 <SamB> and what are "UI programming tools"?
12:03:34 <Igloo> Orphi: Googling for frag Haskell should find it
12:03:39 <ski_> haskell can run in the browser at end of http://www.cs.chalmers.se/Cs/Research/Functional/Fudgets/demoform.html, iirc
12:03:42 <lambdabot> Title: Fudgets - Demo Form, http://tinyurl.com/yt4eg4
12:03:47 <Cheery> SamB: well, java has simple set of stuff you can use to describe GUIs
12:04:05 <Orphi> yeah, Ive seen the web page for frag; I still don't 'get' how it works.
12:04:07 <Cheery> but most other languages do have much more limited and primitive
12:04:12 <SamB> Igloo: well, the part where I feel resentful about not being able to compare it with Qt maybe.
12:04:32 <ski_> @where frag
12:04:32 <SamB> Cheery: explain it?
12:04:33 <lambdabot> http://www.haskell.org/haskellwiki/Frag
12:04:48 <hpaste>  Procyon112 pasted "Is there an idiom to simplify this?" at http://hpaste.org/1199
12:05:12 <procyon112> Any pointers? ^^^
12:05:37 <Orphi> no - this is Haskell, not C
12:05:41 <Orphi> ;) ;)
12:05:42 <Cheery> SamB: Just swing yourself to tree with java and you'll see.
12:06:02 <Orphi> sorry about that... lol
12:06:21 <SamB> Cheery: you lost me at "swing"
12:06:42 <SamB> last I tried using programs that used that, it took a ton of RAM
12:07:25 <SamB> procyon112: there is a sort of idiom
12:08:16 <procyon112> SamB: I figured there was :)
12:09:01 <SamB> procyon112: but, you better handle the case where neither is simple *before* that part
12:09:12 <Cheery> the Yampa in that frag -thing seems to be the key point on making it reasonable to write a game on haskell
12:09:29 <Cheery> I guess I should look into it since I'm interested about doing games in general
12:09:58 <procyon112> SamB: Yes.. I left that out.  I wanted to express the root of the question only.
12:10:02 <hpaste>  SamB annotated "Is there an idiom to simplify this?" with "a sort of idiom, maybe not so great *here*" at http://hpaste.org/1199#a1
12:10:19 <Cheery> uuh, arrows
12:10:21 <SamB> procyon112: the important part being to do that above this
12:10:49 <ddarius> There are plenty of ways of doing games in Haskell.  Games aren't especially special programs.
12:11:10 <sioraiocht> is there anyway to convert IO () to STM a
12:11:20 <procyon112> SamB: ahh... I figured the solution would be obvious ;)
12:11:25 <procyon112> SamB++
12:11:32 <ddarius> sioraiocht: Not safely.
12:11:34 <monochrom> arrows are not scary!
12:11:37 <Cheery> ddarius: do you know how many ways there has been used?
12:11:46 <sioraiocht> ddarius: thanks..
12:11:50 <Cheery> And what do they commonly involve?
12:11:52 <SamB> yeah, I think games are some of the least-special programs
12:12:08 <SamB> though I suppose if you have some kind of reasonable AI they are a lot more special
12:12:22 <ddarius> procyon112: You could also use case as well, but overall, there probably isn't a reason not to use your current version if the case analysis is this simple.
12:12:54 <ddarius> Cheery: You can more or less write them the way you would in any other language to begin with.
12:13:27 <Cheery> I don't know, you can do, but what's the point of doing it exactly like with imperative languages?
12:13:40 <procyon112> ddarius: Case just moves the pattern match... doesn't really simplify the problem.  In my example, the call is simple enough to ignore factoring it out, but in my real problem, that call to "func" is actually a few lines of code.
12:13:45 <SamB> ddarius: the lack of global mutable state may have a dramatic effect on the style of the code
12:13:53 <ddarius> Haskell tends to be nicer than them.
12:14:19 <SamB> Cheery: Haskell lets you make your own imperative language to write your game in ;-P
12:14:21 <ddarius> SamB: If only Haskell was actually lacking global mutable state, but even without it that's not all that significant an effect.
12:14:31 <SamB> you can even use more than one, and they can be related
12:14:42 <Cheery> ddarius: well, it does so, but it amplifying if one finds out better ways while doing that :-)
12:14:44 <ddarius> procyon112: It leads to func x y being written only once.
12:15:09 <ski_> procyon112 : one possibility could be to factor out 'func', i.e. '.. where func x y = ..x..y..'
12:15:59 <ddarius> But I only mentioned that because there's nothing that makes programming games in Haskell harder than programming them in other languages, because at the very least you can program them the same way.
12:16:15 <Cheery> well, one thing does
12:16:30 <ddarius> Yampa and related FRP techniques often have (small) games as examples.
12:16:39 <Cheery> you require more from them, since after you've learnt haskell, you get a weird attitude
12:16:42 <procyon112> ski_: Yeah, I did that.  I'll paste the real code to give an example of how it scales up to messiness :)
12:16:43 <ddarius> There was a game writing library FunGen
12:17:05 <Cheery> FRP?
12:17:16 <ddarius> Functional Reactive Programming
12:18:25 <hpaste>  procyon112 annotated "Is there an idiom to simplify this?" with "Example of real world case" at http://hpaste.org/1199#a2
12:19:02 <Excedrin> is something like http://www.terracotta.org/ easy in Haskell?
12:19:03 <lambdabot> Title: Home - Open Terracotta - Terracotta
12:19:51 <Excedrin> (it's obviously easy in Erlang, and apparently possible with Java)
12:20:01 <Cheery> ddarius: what does it mean in practise?
12:20:53 <ddarius> Excedrin: What is it?
12:21:14 <ski_> procyon112 : i believe one often calls a simpler 'unifyVar :: Var -> Expr -> M Expr' (or whatever types you are using)
12:21:23 <ddarius> Cheery: Reify time, and process events as streams of signals, reacting to them.
12:22:29 <monochrom> There used to be GUM. It's GHC patched to spread over a cluster, i.e., Control.Parallel.par calls PVM to spawn a process elsewhere.
12:23:13 <Cheery> seems and looks like interesting.
12:23:37 <Cheery> And, it actually looks like something I were going at myself on my own workbench :-)
12:23:43 <Excedrin> ddarius: distributed clustering stuff for Java, lets any Java app be distributed across a cluster
12:23:59 <Excedrin> I'd like to use CAL with Terracotta to get a sort of Haskell meets Erlang meets Java thing...
12:24:03 <hpaste>  ddarius annotated "Is there an idiom to simplify this?" with "my unify" at http://hpaste.org/1199#a3
12:24:18 <monochrom> The upshot was that the GUM people also came up with Control.Parallel.Strategies so you never call par yourself.
12:24:56 <hpaste>  procyon112 annotated "Is there an idiom to simplify this?" with "Prettier Code" at http://hpaste.org/1199#a4
12:24:59 <ddarius> @google Haskell Ports distributed
12:25:01 <lambdabot> http://citeseer.ist.psu.edu/479359.html
12:25:02 <lambdabot> Title: Implementation of Port-based Distributed Haskell - Huch, Stolz (ResearchIndex)
12:25:43 <Excedrin> that sounds great, is it usable?
12:26:19 <procyon112> ddarius++  Thanks... I'll look at that.
12:37:05 <hpaste>  ddarius annotated "Is there an idiom to simplify this?" with "more complete code" at http://hpaste.org/1199#a5
12:40:33 <JoshTriplett> Does any good Haskell physics engine exist?  I've searched around, and I can't find anything other than hODE.
12:40:58 <JoshTriplett> (Not implying that hODE doesn't qualify as "good"; I just want to evaluate multiple options.)
12:41:58 <LordBrain> hmmmm
12:42:03 <Cheery> I've not found any
12:42:30 <LordBrain> i have only found version 1 of the FFI, is there any later relavent documents?
12:42:52 <Cheery> if you don't need it too soon, I'd propose you toy with the idea of doing it yourself
12:43:23 <LordBrain> maybe FFI 2 sneak peeks?
12:43:25 <LordBrain> haha
12:43:47 <SamB> LordBrain: that does seem to be the version you get to from http://haskell.org/haskellwiki/Definition
12:43:48 <lambdabot> Title: Language and library specification - HaskellWiki
12:43:48 <JoshTriplett> Cheery: Yeah, I thought about that.
12:44:28 <Cheery> JoshTriplett: what kind of physics stuff you'd need to do?
12:44:53 <sieni> We at #haskell don't pee on our hands. Thus: version 1 of the FFI is already perfect.
12:45:24 <JoshTriplett> Cheery: I've looked at Jiggle with an eye towards a Haskell implementation of those concepts.
12:45:33 <JoshTriplett> Cheery: I don't need deformable body physics.
12:45:45 <JoshTriplett> Cheery: Rigid bodies with some joints/constraints would do the trick.
12:45:57 <JoshTriplett> Cheery: And the ability to apply forces.
12:46:27 <Cheery> what kind of program you have which needs it all?
12:46:46 <monochrom> "Version 1" means "Version Right".
12:47:04 <JoshTriplett> Cheery: A few different applications.  I'd like to use it to write a rocket simulator, and I'd like to use it to implement a game idea I've had for a while.
12:47:11 <ski_> ddarius : bah, untyped :)
12:47:36 <Cheery> ic.
12:47:56 <LordBrain> this seems to be a good start page for FFI stuff http://haskell.org/haskellwiki/GHC/Using_the_FFI
12:47:58 <lambdabot> Title: GHC/Using the FFI - HaskellWiki
12:48:19 <JoshTriplett> Cheery: The former for http://psas.pdx.edu ; the latter just for fun. :)
12:48:21 <lambdabot> Title: PsasHome - Portland State Aerospace Society
12:48:34 <JoshTriplett> Useful bot.
12:48:46 <ddarius> ski_: It's for a Prolog interpreter.
12:49:18 <ddarius> But a dash of GADTs (which were not available at the time) and *boom* you have a typed logic language.
12:49:19 <Cheery> basically those things you mention, if you aren't doing serious simulation, I guess they are about something I did in C some years ago, it'd may be interesting to see such algorithms written in haskell. :)
12:49:39 <JoshTriplett> Cheery: Depends on what you mean by "serious simulation".
12:50:46 <ski_> ddarius : hm .. i've not used GADTs .. /me did an extension of Claessens et al embedding og logic programming into haskell
12:51:34 <Cheery> for games, one dares to use less physically correct approximations, since they are easier to implement and faster? in practise
12:51:53 <ski_> (ddarius : basically the equivalent of '?- L = [(_,9),(_,25)],(member((X,Y),L) => square(X,Y))' works :)
12:51:59 <ddarius> I need to switch the code to use Data.Map instead of FiniteMap, then I should have a Prolog interpreter again.  But what I want to do is make a LolliMon interpreter or a language similar to that.
12:52:09 <ski_> ddarius : what did you use GADTs for, and how ?
12:52:24 <ddarius> ski_: I didn't.  I'm just saying one could make it typed very easily.
12:52:28 <ddarius> via GADTs
12:52:28 <ski_> ah
12:52:40 * ski_ would like to see that
12:53:18 <ski_> 'LolliMon' ? 'Mon' meaning ?
12:53:18 <ddarius> ski_: What if you did square(X,10) say?
12:53:52 <ski_> X = 3.16227766016838 ; X = -3.16227766016838
12:53:55 <ddarius> Monadic.  It uses monads to separate the additive and multiplicative linear parts.  Monads look a bit different in Logic programming languages.
12:54:12 <ski_> (just for the example .. the cool stuff was '=>')
12:54:33 <ski_> very interesting
12:55:04 <ddarius> ski_: Lookup the Concurrent Logic Framework or browse Frank Pfenning's site.
12:55:15 <ski_> ddarius : are you referring to something like http://logic.csci.unt.edu/tarau/research/PapersHTML/monadic.html, or something else ?
12:55:16 <lambdabot> Title: Monadic Constructs for Logic Programming
12:55:25 <ski_> ty
12:55:57 <ddarius> From the looks of that (just a glance) something else.
12:56:20 <JoshTriplett> Cheery: True.  I'd prefer correct over fast, as long as I can get real-time simulation of relatively few bodies and forces.
12:56:22 <ddarius> At the very least, the particular monad they talk about is a builtin one.
12:56:32 <ddarius> "Type Directed Concurrency" is also another related paper.
12:57:30 <ddarius> ski_: But for your "Prologesque" code above, you mean HOL?
13:00:54 <JoshTriplett> Cheery: I rather like the approach from the "Nonconvex Rigid Bodies with Stacking" paper for various reasons.  In particular, it uses a simulation algorithm that avoids the usual "penetrate the surface and then restore" approach, a common cause of instability.
13:01:07 <JoshTriplett> Cheery: With that algorithm, an object on a surface just doesn't move.
13:01:15 <ski_> ddarius : i don't know HOL
13:01:45 <JoshTriplett> Cheery: With ODE, if you sit a block on a flat surface with no friction, it will vibrate and start moving along the surface as though on an air hockey table.
13:01:46 <ddarius> Higher Order Logic
13:02:03 <JoshTriplett> Cheery: http://web.archive.org/web/20030930141006/http://graphics.stanford.edu/courses/cs448a-03-spring/tmp/rigid_bodies_talk.pdf
13:02:07 <lambdabot> http://tinyurl.com/2dfs64
13:02:09 <ski_> ddarius : basically, what i implemented is an implication, like the usual checking one in prolog, but mine can export instantiations
13:02:28 <ski_> so e.g.
13:02:35 <JoshTriplett> Hmmm, I didn't know lambdabot did tinyurls; why does it do that?
13:02:51 <ski_> ?- L = [(3,_),(4,_)],(member((X,Y),L) => square(X,Y)).
13:02:52 <lambdabot> Maybe you meant: . v
13:03:02 <ski_> L = [(3,9),(4,16)] ;
13:03:02 <ski_> NO
13:03:49 <ski_> (the usual definition of (=>)/2 being 'A => B  :-  not (A, not B).')
13:04:13 <ski_> also, i can also get
13:04:27 <ski_> ?- L = [(_,9),(_,16)],(member((X,Y),L) => square(X,Y)).
13:04:27 <lambdabot> Maybe you meant: . v
13:04:31 <ski_> L = [(3,9),(4,16)] ;
13:04:33 <ski_> L = [(3,9),(-4,16)] ;
13:04:35 <ski_> L = [(-3,9),(4,16)] ;
13:04:37 <ski_> L = [(-3,9),(-4,16)] ;
13:04:38 <ski_> No
13:04:48 <ski_> ddarius : understand ?
13:05:17 <ddarius> I started to after I said "Higher Order Logic". I wasn't looking at what you wrote clearly enough.
13:06:11 <ddarius> A => B runs B with the bindings of A ?
13:06:12 <ski_> (the above is of course translated into prolog syntax .. i just have an embedding into haskell)
13:06:21 <procyon112> @hoogle Typeable
13:06:22 <lambdabot> Data.Typeable :: module
13:06:22 <lambdabot> Data.Typeable.Typeable :: class Typeable a
13:06:22 <lambdabot> Data.Typeable.Typeable1 :: class Typeable1 t
13:06:35 <ddarius> procyon112: It's for Data.Dynamic.
13:06:36 <ski_> the prolog translation is maybe a bit ambiguous
13:06:49 <Cheery> JoshTriplett: thanks
13:07:13 <ski_> i implemented both universal quantifier and implication .. the universal implication is implicit in the above prolog translation
13:07:42 <monochrom> ?type ***
13:07:45 <lambdabot> parse error on input `***'
13:07:53 <ski_> the goal 'A => B' succeeds if for every way that 'A' can succeed, 'B' succeeds
13:07:54 <procyon112> ddarius: Just trying to make some sense of this.  It's a bit beyond my level of Haskel-fu.
13:07:55 <monochrom> ?type (***)
13:07:58 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:08:18 <procyon112> @hoogle BacktrT
13:08:19 <lambdabot> No matches found
13:08:24 <ski_> ddarius : 'A' can be an arbitrary goal, including arbitrary nesting of implications
13:08:47 <ddarius> ski_: Yes, I'm wondering how it's implemented.
13:08:50 <ski_> ddarius : and instantiations made by 'B' are retained by the whole construct
13:09:06 <ddarius> ski_: And yes, I think that is more or less an implementation of Higher Order Logic.
13:09:10 <ski_> ddarius : deep scary levels of continuation machinery ;)
13:09:33 <ski_> ddarius : ok, interesting, ty for the ref. i'll have to look that up
13:09:36 <ddarius> Speaking of which, BacktrT is Ralf Hinze's Backtracking Monad.  Google Ralf Hinze and browse his papers.
13:10:18 <procyon112> ddarius: Yeah.. I read his paper, and my lack of Prolog really hurt my comprehension.
13:10:39 <ski_> (basically i started from 'type Foo m o a = ((a -> m o -> m o) -> m o -> m o)' ..)
13:10:45 <ddarius> procyon112: The code is still incomplete.  In particular, writeLPRef is not what you would first guess.
13:11:53 <shapr> ddarius: I really like that combo language with concurrency and proof search.
13:12:16 <ddarius> The example "programs" for LolliMon/CLF are extremely slick.
13:12:38 <procyon112> It sure is prettyier than mine ;)  I think I'll stick to what I have for now, which I understand and it works, and revisit this file in a few months, when Haskell itself is more natural to me.
13:13:21 <ski_> ddarius : in aforementioned papers ?
13:14:39 <ski_> ddarius : (re 'BackTrackT') Prolog's control constructs in a functional setting - Axioms and implementation ?  Deriving Backtracking Monad Transformers ?
13:14:40 <ddarius> ski_: A few are in the papers, e.g. the pi calculus implementation.  Also, the source code has some interesting examples.
13:14:49 <ski_> mhm
13:14:55 <ddarius> Deriving Backtracking Monad Transformers.
13:14:58 <ski_> ty
13:15:05 <ddarius> Yay abstraction.
13:16:18 <shapr> ddarius: Do you know if there's a working implementation?
13:17:19 <ddarius> shapr: There's a buggy O'Caml version of LolliMon. I have half a mind to rewrite it into Haskell or implement the very similar language from "Type Directed Concurrency"
13:18:54 <ski_> (hm 'http://www.informatik.uni-bonn.de/~ralf/' seems to be down atm .. this is his current, yes ?)
13:19:58 <shapr> Yeah, Type Directed Concurrency is way nifty.
13:20:30 <ddarius> ski_: I believe so.  It's down for me as well, but I did go to it about a week or two ago.
13:21:34 <ddarius> The saturating parser example in the lollimon examples is pretty slick.
13:22:23 <ski_> lollimon is in the fp papers you mentioned above ?
13:24:07 <ddarius> http://www.cs.cmu.edu/~fp/lollimon/
13:24:08 <lambdabot> Title: Index of /~fp/lollimon
13:24:20 <rahikkala> > reverse "Ytinasni"
13:24:21 <lambdabot>  "insanitY"
13:27:02 <abz> Has anyone tried keeping patches in darcs (not darcs patches, but diff -u patches)?
13:27:26 <abz> And did you have any trouble?
13:33:18 <ddarius> A few slight changes and now GHCi is a Prolog interpreter as well.
13:34:31 <Cheery> > reverse "Cheery"
13:34:33 <lambdabot>  "yreehC"
13:34:43 <Cheery> gn
13:34:52 <Cheery> ddarius: lol
13:35:02 <Cheery> can I see it?
13:35:09 <Cheery> or is it that lollimon?
13:35:51 <ddarius> It's just a Prolog interpreter I wrote running in GHCi.  I needed to change FiniteMap -> Data.Map since the code is like 3 years old or something.
13:36:11 <ddarius> But since I wisely named all uses of the Map code, it was very easy.
13:36:27 <Cheery> you didn't invent any less LOL name?
13:36:32 <Cheery> :P
13:37:56 <Cheery> or wait, it's not lollimon
13:38:05 <abcde`> lolimon sounds like a cartoon series of underage monsters
13:38:39 <glguy> roflcopter
13:39:02 <Cheery> roflcopter vs. lollimon
13:39:47 * Cheery is happy, he got his CSS -low level stuff done
13:39:47 <abcde`> FIGHT
13:40:38 <Cheery> here were some guy who wanted to see them when they are done, I guess I put them up to hpaste.org for now
13:42:18 <hpaste>  Cheery pasted "unnamed stuff for generating CSS" at http://hpaste.org/1200
13:42:48 <ddarius> Perhaps I will use arrows in my lollimon implementation that I'll start sooner or later so I can have runLolA
13:43:00 * Gwern groans
13:43:14 <Gwern> "lollimon - gotta rape'em all..."
13:43:23 <glguy> :-/
13:43:45 <stepcut> Cheery: yay!
13:44:27 <Cheery> like the thing says, they aren't complete, but close of being completent on the way they are
13:44:37 <Cheery> *complete
13:45:17 <Cheery> Gwern-comment appeared too hilarious. me goes to bed
13:47:12 <monochrom> I want to ask Cheery what the hell does he mean by "WTF-8".
13:47:53 <stepcut> heh
13:48:20 <sieni> monochrom: it's Worldwide Transformation Format number 8
13:48:41 <mauke> it's doubly-encoded UTF-8
13:49:10 <monochrom> haha all of you are funny
13:51:19 <mauke> motÃ¶rhead
14:04:26 <chessguy> hi haskellers
14:05:46 <LordBrain> Why do we use "realToFrac" here? Wouldn't something like "fromRealFrac" be more consistent  --> http://haskell.org/haskellwiki/FFI_Introduction
14:05:47 <lambdabot> Title: FFI Introduction - HaskellWiki
14:06:13 <LordBrain> not that there is a fromRealFrac...
14:06:35 <ddarius> :t realToFrac
14:06:38 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
14:06:42 <LordBrain> maybe toDouble
14:06:58 <ddarius> :t fromIntegral
14:07:01 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:07:02 <LordBrain> :t toDouble
14:07:05 <lambdabot> Not in scope: `toDouble'
14:07:17 <monochrom> there is no fromRealFrac
14:07:22 <LordBrain> yeah i know
14:07:26 <ddarius> toDouble would be ugly
14:07:35 <ddarius> :t fromReal
14:07:37 <lambdabot> Not in scope: `fromReal'
14:07:46 <ddarius> fromReal would be the consistent naming
14:07:55 <LordBrain> oh ok
14:07:57 <monochrom> You may suggest renaming realToFrac to fromRealFrac.  There are a few issues.
14:07:57 <int-e> :t fromRational
14:08:00 <lambdabot> forall a. (Fractional a) => Rational -> a
14:08:00 <int-e> :t toRational
14:08:03 <lambdabot> forall a. (Real a) => a -> Rational
14:08:13 <LordBrain> fromReal, that seems consistent
14:11:01 <monochrom> fromIntegral earns its name by returning any Num at all.  This is because Num is a ring, and for every ring there is a homomorphism from the integers to the ring.
14:11:19 <monochrom> There is, however, no such generic homomorphism from realfrac's (e.g., the rationals) to rings.  the name fromRealFrac will inevitably mean something else.  it will actually be inconsistent.
14:12:44 <monochrom> But I'm ignoring the established name fromRational. Oh well.
14:14:02 <LordBrain> does ghc optimize it away, if i set athunk = bthunk?
14:14:22 <LordBrain> cthunk = athunk ...
14:15:06 <ddarius> Presumably there would be nothing to optimize.
14:15:12 <LordBrain> well
14:16:06 <LordBrain> i would think if you dont do any kind of elimination or anything, there would be extra indirections
14:16:22 <monochrom> Yes.
14:16:46 <LordBrain> yes you think that too monochrom ? or yes it does optimize it away?
14:17:07 <monochrom> optimizes
14:24:55 <LordBrain> thats good, because its nice to be able to rename things
14:25:05 <LordBrain> :)
14:30:22 <ndm> @seen augustss
14:30:22 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
14:31:11 <wy> ndm, I'm back from classes.
14:31:24 <ndm> wy: succeeded with Haskell running yet?
14:31:33 <wy> ndm, I tried running from command line. The same problem.
14:31:43 <ndm> wy: report it as a bug to the GHC people
14:31:53 <ndm> wy: i can't think of any reason it should do that
14:31:56 <ndm> @where ghc-bugs
14:31:57 <lambdabot> http://www.haskell.org/ghc/reportabug
14:32:02 <wy> It's strange that it can run with simple a program but not this one
14:32:30 <ndm> wy: do you have a complete transcript for your bug, i.e how to reproduce it?
14:32:35 <ndm> wy: code and command lines?
14:32:44 <shapr> ddarius: haha, runLolA
14:32:57 <wy> ndm, I need to sort things out. The code is a bit messy
14:32:58 <Igloo> What's the problem?
14:33:28 <ndm> wy: explain your issue to Igloo
14:33:33 <wy> ndm, maybe I should submit the messy program?
14:33:37 <ndm> Igloo: he appears to be getting "impossible happened"
14:33:47 <wy> Igloo, I've got problem running Haskell on Windows XP
14:33:58 <ndm> wy: hpaste the bug you would report, Igloo will know exactly what to do
14:34:37 <wy> I wrote some program under Linux this winter. Now I took them out and run in windows. I got something like ": panic! (the 'impossible' happened)"
14:34:39 <Igloo> ndm: I won't hav a clue know you've built me up like that  :-)
14:34:45 <wy> loadObj: failed
14:34:57 <Igloo> Is this using hs-plugins?
14:35:28 <wy> It's just some code from Simon Peyton Jone's book
14:35:58 <Igloo> Oh, well, if you can put the code somewhere I'll take a look
14:36:57 <wy> Igloo, Thank you very much! I'll make it less messy and paste it.
14:37:42 <ndm> wy: messy should be fine, impossible happened shouldn't be a result of the code really...
14:40:29 <wy> ndm, so I'll paste the code now. It can be compiled and run with ghc, but ghci crashes if main is called
14:40:46 <ndm> wy: that should be plenty for Igloo to work with
14:41:11 <wy> ndm, Haha! Could you point me to a paste bin?
14:41:20 <TSC> hpaste.org
14:41:21 <ndm> @paste
14:41:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:41:26 <ndm> wy: ^^^
14:41:36 <ndm> we have one written in Hsakell
14:41:59 <hpaste>  wy pasted "(no title)" at http://hpaste.org/1201
14:42:38 <ndm> wy: there is no main in that code?
14:42:52 <wy> That doesn't seem to be complete...
14:43:06 <ndm> wy: it has a limit to 5000 charcters
14:43:07 <wy> something is wrong with the paste bin
14:43:11 <wy> Oh...
14:43:32 <wy> Let me try to cut it down
14:50:42 <wy> Igloo, I tried to shorten the program. But then I can't reproduce the bug
14:51:04 <wy> Igloo, is there a way to paste a long program ?
14:52:46 <wy> As said by ndm, this should never happen however messy the code is. So I need to paste the messy code
14:54:32 <hpaste>  wy pasted "part2" at http://hpaste.org/1202
14:55:05 <wy> Hmmm. finish
14:58:57 <Igloo> wy: What version of ghc do you have?
14:59:12 <wy> Igloo: 6.6
14:59:33 <Igloo> wy: And the problem is just opening it in ghci and typing main?
15:00:05 <wy> Igloo: wait... why doesn't it crash now...
15:00:18 <Igloo> I was building up to that question  :-)
15:01:25 <wy> Igloo: I've re-unpacked my file. Let's see...
15:02:51 <wy> Igloo: I need to restore the whole directory. I'm happier, although I'm still trying to reproduce it.
15:04:26 <monochrom> installation glitch?  fixed by re-installing?
15:05:16 <kc5tja> Voodoo bug.
15:07:59 <wy> Igloo: I found the problem!
15:08:41 <wy> Igloo: There was a .hi in my directory which is produced by the Linux version of GHC several month ago. I deleted this file and everything is fine now!
15:11:42 <wy> Igloo: I think this should still be regarded as a bug, because this troubled me for a whole afternoon. It should be able to deal with this gracefully.
15:14:51 <Igloo> wy: Right, I agree; if you have a way to reproduce it then please file a bug report
15:15:29 <wy> Igloo: I can package the directory up but I'm not sure if I can use such attachments for bug report
15:16:02 <sorear> hi!
15:16:03 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:16:58 <wy> sorear: long time no see!
15:17:09 <ndm> sorear, hi - thanks for the patches :)
15:17:20 <Igloo> wy: What do you mean by package it up? You shouldn't need to include .hi files in teh report
15:17:45 <wy> Igloo: so I just need to say something and don't even need to provide code?
15:18:14 <wy> Igloo: If the hi files are not present, this can't be reproduced.
15:18:41 <wy> HI ndm ! I've found the cause of the problem
15:18:58 <Igloo> wy: No provide code, commands to run on Linux, then commands to run on Windows
15:19:03 <ndm> wy, i saw, well done :)
15:19:18 <Igloo> wy: Sorry, missing comma after "No"
15:19:46 <sorear> wy: eh? I'm pretty often here :)
15:19:48 <monochrom> corrupted hi files?
15:19:53 <sorear> @clear-messages
15:19:53 <lambdabot> Messages cleared.
15:20:16 <wy> Igloo: I don't know how was the hi files generated. I'm always using emacs to interact
15:20:46 <wy> sorear: I haven't been here for several months. Really dulled by my classes.
15:25:25 <liquidengineer> Yo
15:25:29 <wy> Is there darcs for windows?
15:25:34 <sorear> yes
15:25:38 <sorear> hi.
15:26:52 <Saizan> sorear: to get that O(n log k) "select n random distinct elements from a set of size k" i added elemAtDel :: Int -> Set a -> (a,Set a) to my Data.Set, is there some hope to get this in base in your opinion?
15:27:11 <wy> sorear: where can I get it?
15:27:54 <procyon112> Windows can do a lot these days... it might be ready for the desktop soon.
15:28:18 <Saizan> http://darcs.net/DarcsWiki/CategoryBinaries#head-c7910dd98302946c671cf63cb62712589b392074 <-- wy
15:28:20 <lambdabot> Title: CategoryBinaries - DarcsWiki, http://tinyurl.com/luaqp
15:28:54 <ndm> wy, everything is available for Windows, pretty much - i use it as my main program
15:28:58 <wy> Thanks! Do you recommend using it under cygwin?
15:29:03 <Saizan> procyon112, yeah, it's wuite amazing the haskell support for windows
15:29:16 <sorear> @quote windows
15:29:16 <ndm> wy, eek - no - thats horrible, just run native windows, its plenty nice enough
15:29:17 <lambdabot> shapr says: I encourage my competitors to use Windows.
15:29:18 <sorear> @quote windows
15:29:19 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
15:29:22 <Saizan> i used it on cmd.exe without problems
15:29:25 <sorear> @quote windows
15:29:26 <lambdabot> shapr says: I encourage my competitors to use Windows.
15:29:36 <ndm> @remember procyon112 Windows can do a lot these days... it might be ready for the desktop soon.
15:29:36 <lambdabot> Done.
15:30:22 <procyon112> I'm joking of course.  It will never be ready for the desktop.
15:30:48 <wy> I've cygwin already. But I don't know how to install it yet
15:31:03 <wy> I don't know how to install the tar.gz into cygwin
15:32:03 <procyon112> cygwin is decent, but it doesn't ever quite pull off the illusion that it's not just a hack. :(
15:32:05 <Saizan> i think i've just untarred it in some directory which is in my %Path%
15:32:31 <Saizan> cygwin is quite ugly, i like mingw+msys a lot more
15:32:47 <tao36> anyone solved the ghc "not buit for interactive use " bug ?
15:32:56 <tao36> *built
15:33:46 <tao36> /who
15:34:10 <procyon112> Saizan: I forgo the emulators on Windows, and let Windows be what it was designed to be: A game console.
15:34:17 <procyon112> :)
15:36:03 <Saizan> :P
15:36:49 <tao36> anyone solved the ghc "not built for interactive use " bug ?
15:36:57 <ndm> I forgo the emulators and let Windows be what it should be, perfect :)
15:37:17 <procyon112> Saizan: Of course, I'm biased... I'm sitting here hacking C++ writing a Vista Wizard.. it probably makes me a bit jaded.
15:37:58 <ndm> procyon112, its the C++ bit that would make me cry most... - the windows C API is horrid, but part of that is C's fault
15:38:05 <ndm> use Gtk2Hs and its perfectly fine
15:39:20 <sorear> tao36: doesn't sound like a bug to me
15:39:47 <sorear> tao36: it sounds like your GHC wasn't built for interactive use
15:40:03 <sorear> tao36: re-check your mk/config.mk, and make sure you are using stage2
15:40:25 <Saizan> procyon112, well i don't like windows, and now i've finally switched to linux where everything builds just fine! (after you get the dependencies)
15:41:00 <procyon112> ndm: The problem I have develping under windows is that things just never want to work nicely together.  Add to that the lack of native development tools and the kludgie way of getting development tools, and it's a big headache.
15:41:01 <tao36> sorear: thanx , will try
15:41:04 <tao36> :)
15:42:11 <sorear> isn't windows designed such that all problems can be fixed (only) by paying more?
15:43:03 <procyon112> sorear: using the word "designed" is giving the system alot of questionably deserved credit.
15:43:26 <Saizan> don't know, paying more would prevent my PATH to have half of my directories inside it?
15:43:27 <sorear> I always figured it was designed.
15:43:43 <sorear> Not necessarily by programmers.
15:44:56 <procyon112> sorear: It's organized to be a game console and internet browser, with the ability to accept 3rd party plugins to run custom applications... Much like a palm pilot, but a whole lot more pricey.
15:45:45 <sorear> ndm: what do you find less clean about the new Eq deriver?
15:46:20 <sorear> ndm: I'm hoping that an AST approach could be cleaner, since we needn't worry about the quirks of the haskell syntax.
15:50:06 <procyon112> sorear: snarkiness aside, "Windows" isn't really centrally designed any more than Linux is... it's a competitive bazaar of groups trying to get their projects accepted into the mainline branch.  Individual sections are designed well, like the explorer shell, the file system (one of the best), etc..., but having things work well together is mostly a job of retrospect design after dealing with customer complaints.
15:50:22 <ndm> sorear, i guess you have to learn the AST, where as everyone knows Haskell
15:50:39 <metaperl> any bored Haskellers wanna crack out a quickie: http://sequence.complete.org/node/269  ... i'd like to see it!
15:50:41 <lambdabot> Title: I&#039;ve seen the J and the C, how about the Haskell? | The Haskell Sequence
15:50:41 <ndm> sorear, i don't think its important - your and', etc combinators make it better
15:52:07 <monochrom> step up to the plate? does that mean to be eaten?
15:52:48 <JoshTriplett> What Haskell library (preferably standard) should I use to get vectors and matrices with math operations?
15:52:50 <procyon112> sorear: (I've worked at MS for going on 10 years.. I've been to war room.)
15:53:17 <monochrom> metaperl: do you have a matrix representation in mind?
15:53:19 <DRMacIver> monochrom: It's a metaphor relating to some tedious sport only the colonials play. :)
15:53:22 <sorear> metaperl: maximumBy (comparing maximum) will do the trick
15:53:25 <ndm> fst . maximumBy (compare `on` snd) . zip [1..] . map maximum
15:53:36 <ndm> metaperl, thast my attempt ^^^
15:53:49 <metaperl> wanna post to the blog?
15:53:57 <sorear> > maximumBy (comparing maximum) [[1,2,3],[2,9,4],[5,6,7]]
15:53:59 <lambdabot>  [2,9,4]
15:53:59 <ndm> sorear, you seem to want to get the index of the maximum, i think
15:54:03 <monochrom> Oh! Baseball.
15:54:17 <ndm> metaperl, post them for us :)
15:54:26 <metaperl> yes, the spec was for the column index of the maximum entry... cant imagine why that would be more important than the value
15:55:04 <ndm> the actual value is trivial
15:55:08 <ndm> maximum . concat
15:55:20 * sorear 's mind boggles ... metaperl == CosmicRay? can't be...
15:55:35 <metaperl> no I am not him
15:55:39 <ndm> maximumBy (comparing maximum) -- just as easy to get the whole column
16:01:25 <monochrom> I want to ask a converse question. How would you write a parser in J? :)
16:02:12 <sorear> ... ghc -e ...
16:02:18 <DRMacIver> With great pain. :)
16:02:25 <DRMacIver> (I still don't understand J)
16:02:39 <kc5tja> J is not that hard to understand.
16:02:50 <kc5tja> It's just a matter of understanding the symbology.
16:02:52 <tao36> sorear: i have config.mk open and it  seems a bit criptic.. where is stage 2 selector?.. only one place an its under if condition.. its there wher i have to modify?
16:02:56 <kc5tja> And that is learnt by actually hacking on it.
16:03:13 <sorear> tao36: what version are you using?
16:03:16 <DRMacIver> Yeah, I've not really done much with it.
16:03:17 <monochrom> I think there is a straightforward way of implementing each J operator in Haskell. The end result is an isomorphic set of Haskell operators.
16:03:20 <tao36> 6.6
16:03:34 <sorear> tao36: normally, if you just build and install, the installed version will be a stage 2 build
16:03:38 <monochrom> I should write a book "J for Haskell programmers"
16:03:42 <DRMacIver> monochrom: Wouldn't you run into typing issues?
16:03:53 <kc5tja> The other thing for learning J is simple: use spaces.  :)
16:03:57 <sorear> tao36: you have to go out of your way to run a stage-1 compiler.
16:04:06 <kc5tja> Everyone always says, "Don't use spaces!  It makes for ugly code!"
16:04:16 <monochrom> Maybe. But one can restrict the types or use tricks.
16:04:22 <kc5tja> And it does, sometimes.  But on the average, that's nonsensical.
16:04:30 <tao36> and how can i do it?
16:04:55 <sorear> tao36: ./configure && make && make install should have just worked
16:05:14 <tao36> i did that already.
16:05:17 <monochrom> what platform is tao36 building on?
16:05:21 <tao36> i think..
16:05:25 <tao36> ppc
16:05:27 <tao36> debian
16:05:33 <sorear> tao36: And you are using the installed version?
16:05:37 <tao36> nope
16:05:40 <sorear> tao36: ie NOT a ghc-inplace?
16:05:42 <tao36> source
16:06:01 <sorear> tao36: after you made install, you should have a working /usr/local/bin/ghc
16:06:09 <tao36> yes
16:06:22 <monochrom> which installed ghc do you use to build the attempted ghc?
16:06:23 <kc5tja> monochrom: True; however, it won't run as fast (lists aren't vectors.  You'd need to code a Haskell extension in C for using vectors, kind of like ByteString is for 8-bit characters)
16:06:33 <sorear> tao36: if you have a working ghc, what's the problem?
16:06:40 <monochrom> I'm thinking the operators work for arrays, kc5tja
16:06:43 <tao36> the prob is the interactive mode needed for the hsc
16:06:45 <sorear> tao36: /usr/local/bin/ghc --interactive doesn't work?
16:06:56 <tao36> yes
16:07:05 <kc5tja> monochrom: Well, yes, the operators themselves only care about collections.  Arrays and lists are both collections.
16:07:15 <tao36> sorear: ghci doesnt work
16:07:41 <DRMacIver> Hm. I've just encountered Liskell.
16:07:42 <monochrom> ok, some typeclasses can cover the general case. specific implementations have specific performance.
16:07:43 <tao36> im trying to use haskell to controll supercollider
16:07:45 <sorear> tao36: if the build succeeded, and ghc --interactive fails, you've got a pretty unusual problem, complain on the ML
16:07:49 <DRMacIver> I can't decide whether it's an awesome or horrific idea. :)
16:08:12 <tao36> i know sorear :)
16:08:27 <tao36> that why ive come here :P
16:08:59 <sorear> tao36: the real GHC gurus (except for Igloo) don't hang out here, the ML is a better avenue for obscure build problems
16:09:16 <tao36> ok
16:09:35 <monochrom> is debian-ppc known to be hard to build for?
16:09:40 <tao36> sorear: thankx anyway for the effort
16:09:43 <tao36> :D
16:09:52 <Igloo> ghci isn't supported on PPC/Linux yet
16:09:55 <sorear> hello chessguy
16:10:06 <monochrom> ok, that kills the conversation :)
16:10:07 <chessguy> 'evening
16:10:11 <tao36> thank you igloo:
16:10:31 * monochrom was prophetic in asking "what platform"
16:11:03 <tao36> so .. using hsc in ppc/linux is on stall...:(
16:11:12 <Igloo> hsc?
16:11:17 <tao36> anyone us
16:11:26 * sorear ran a ^AVERSION^A before advising configure... and got the amazingly helpful teply of
16:11:27 <tao36> haskell with supercollider
16:11:38 <sorear> Gaim IRC
16:12:15 <sorear> It'll be waay slow, but you might be able to use hi
16:12:18 <sorear> @where hi
16:12:19 <lambdabot> I know nothing about hi.
16:12:19 <monochrom> It is fashionable to abstract away the platform :)
16:12:22 <sorear> @where hmake
16:12:23 <lambdabot> http://haskell.org/hmake
16:12:30 <sorear> hi == hmake interactive
16:12:37 <tao36> igloo: using haskell to control sound synthesis ..kool at least 2 me :)
16:12:48 <chessguy> @where bye
16:12:49 <lambdabot> I know nothing about bye.
16:13:00 <monochrom> naughty chessguy
16:13:29 <augustss> @seen ndm
16:13:29 <lambdabot> I saw ndm leaving #haskell 4m 16s ago, and .
16:13:40 <sorear> Igloo: about how hard is it to get the interactive interpreter running on a new platform?
16:14:46 <Igloo> tao36: Why do you need ghci for that?
16:15:06 <tao36> http://doc.gold.ac.uk/~ma503am/alex/node/24
16:15:10 <lambdabot> Title: Haskell supercollider tutorial | Alex McLean
16:15:18 <tao36> the author requires it
16:15:29 <Igloo> sorear: I have some patches that I need to tidy up to make ghci work for unregisterised ghci. Then it should work everywhere ghci does
16:15:48 <sorear> Igloo: that conclusion is already true
16:15:57 <sorear> Igloo: indeed, it is tautological
16:16:15 <Igloo> Sorry, last ghci should be ghc
16:16:49 <sorear> ok.
16:17:26 <tao36> @where hsc
16:17:27 <lambdabot> I know nothing about hsc.
16:18:52 <monochrom> You can drop the supercollider emacs mode and ghci.  Write code in file then compile and execute.  It is less convenient but same expressive power.
16:20:48 <tao36> monochrome: im a newbie in haskell and interactive mode is really convenient.. but its a good advice :)
16:21:47 <JoshTriplett> @hoogle cross
16:21:48 <lambdabot> No matches found
16:21:50 <JoshTriplett> @hoogle dot
16:21:52 <lambdabot> Text.ParserCombinators.Parsec.Token.dot :: TokenParser st -> CharParser st String
16:21:52 <lambdabot> GHC.Dotnet :: module
16:21:56 <JoshTriplett> @hoogle dotproduct
16:21:57 <lambdabot> No matches found
16:22:00 <JoshTriplett> @hoogle dotProduct
16:22:01 <lambdabot> No matches found
16:22:21 <dolio> > zipWith (*) [1, 2, 3] [4, 5, 6]
16:22:23 <lambdabot>  [4,10,18]
16:22:30 <dolio> > sum $ zipWith (*) [1, 2, 3] [4, 5, 6]
16:22:31 <lambdabot>  32
16:22:44 <JoshTriplett> dolio: Looking for a more general vector and matrix library, actually. :)
16:22:49 <monochrom> I admit inconvenience is annoying :)
16:22:52 <JoshTriplett> dolio: Hoping that would find it.
16:23:11 <dolio> Yeah. I don't think there is one in the standard libs...
16:23:24 <JoshTriplett> dolio: Noticing that.
16:23:58 <dolio> There's probably one floating out on the internet somewhere.
16:24:07 <dolio> Probably the subject of a paper or something. :)
16:24:20 <JoshTriplett> dolio: No, probably 5.  Hence my problem. :)
16:24:36 <dolio> Heh.
16:25:48 * JoshTriplett would like to avoid making it 6.
16:27:59 <dolio> http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics
16:28:01 <lambdabot> Title: Libraries and tools/Mathematics - HaskellWiki, http://tinyurl.com/hq4t3
16:28:29 <dolio> That has two different descriptions using the word "matrix."
16:29:40 <dolio> Although I suppose any of the linear algebra ones might qualify.
16:46:37 <sjanssen> @yow!
16:46:37 <lambdabot> The Korean War must have been fun.
16:51:26 <sjanssen> JoshTriplett: do I know your name from the xcb mailing list?
16:51:59 <kc5tja> or maybe the C2 wiki?  :)
16:53:07 <sorear> @quote
16:53:07 <lambdabot> edwinb says: I think I'd panic if I had to write something that wasn't a compiler.
16:53:23 <sjanssen> heh
16:55:42 <sorear> <- 5 min lag
16:56:04 <sjanssen> ping
16:56:11 <sorear> pong!
16:56:22 <sorear> funny how lag is so bursty
17:03:08 <sorear> ndm: I'm going to consider the AST move complete after binary + eq +binarydefer, since Functor didn't work to begin with.
17:03:38 <jcreigh> sjanssen: I'm beginning to think we don't need "refocus" after all, we can just do all that in setFocus
17:03:39 <ndm> sorear, did it not work at all?
17:04:24 <sorear> sjanssen: elementary google stalking shows JoshTriplett active on LKML, freedesktop.org, debian-legal, and Wikipedia. so probably "yes"
17:04:27 <ndm> sorear, the original version at least worked for some data types
17:04:33 <jcreigh> (and maybe make borders actually work at the same time)
17:04:51 <sorear> ndm: oh... didn't notice in my earlier testing :)
17:04:59 <sorear> ndm: thanks
17:05:16 <JoshTriplett> sjanssen: Yes, you do.
17:05:28 <JoshTriplett> sjanssen: Hi.
17:05:40 <sorear> ERC> /wois JoshTriplett
17:05:40 <sorear> *** wois: Unknown command
17:05:40 <sjanssen> jcreigh: that sounds reasonable
17:05:48 <sorear> I wish erc was more like lb :)
17:06:35 <ndm> sorear, i think its restricted to certain data types possibly - the last two in the examples file allow functor to be derived
17:06:39 <sjanssen> JoshTriplett: just curious.  Seems to be disproportionate interest in Haskell among xcb hackers :)
17:07:15 <ndm> sorear, which means that deriving things should possibly return a Maybe AST - which makes sense (you can't define Eq over functions etc)
17:07:37 <jcreigh> sjanssen: all interest in Haskell is disproportionate. :)
17:07:42 <stepcut> sorear: hav you tried circe? It has flyspell support... maybe that would help ?
17:07:58 <JoshTriplett> sjanssen: One of those correlation versus causation problems.  A disproportionate number of XCB hackers come from the various Open Source work at Portland State, and a disproportionate number of Haskell users come from the Open Source work at Portland State. :)
17:08:08 <JoshTriplett> sjanssen: They overlap heavily.
17:08:20 <JoshTriplett> sjanssen: Hence fun projects like xhsb.
17:09:55 <LordBrain> What does Managed vs UnManaged Code mean in the context of Windows DLLs ?
17:10:03 <LordBrain> anyone know?
17:10:08 <JoshTriplett> sjanssen: Also participating as a mentor for Summer of Code, so you might see me through that as well.
17:10:35 <ndm> JoshTriplett, for Haskell, or X?
17:10:40 <ndm> LordBrain, .NET vs C
17:10:45 <jcreigh> LordBrain: ISTR that refers to .NET/CLR stuff
17:10:51 <JoshTriplett> LordBrain: Relates to the use of the .NET runtime.  Managed code doesn't bypass the runtime and do things like pointer manipulation.
17:10:51 <LordBrain> Managed = .NET ?
17:11:02 <JoshTriplett> ndm: X, and PSU, and ikiwiki, and sparse. :)
17:11:10 <LordBrain> ah
17:11:44 <LordBrain> so if i'm mixing haskell and c++, using ghc, i have no choice really but to make it unmanaged right?
17:11:55 <ndm> LordBrain, yes - managed would be a nightmare
17:12:03 <siti> managed c++ == c# with ugly syntax
17:12:19 <ndm> LordBrain, but c++ is likely to be hard too, C would be best (certainly for the haskell interface)
17:12:41 <ray> i don't know personally, but if it has to be .net people seem to think c# is the way to go
17:12:49 <ray> isn't there a haskell compiler that does .net stuff?
17:13:19 <LordBrain> well i'm following a tutorial which makes a DLL project in VS C++..
17:13:58 <siti> .net was only designed for imperative and statically typed languages
17:13:59 <ndm> ray, Yhc generates .NET bytecode, GHC/Hugs could at one point link to .NET code, but it may well have bit rotted
17:14:03 <siti> running haskell on it is a hack
17:14:07 <ray> yhc was what i was thinking of
17:14:10 <ndm> siti, you can translate Haskell to it
17:14:17 <siti> it's a hack :p
17:14:22 <ndm> siti, not as much of a hack as java, at least they have tail call!
17:14:27 <siti> lol
17:14:56 <siti> native code is so much better :D
17:15:30 <ndm> a custom haskell bytecode is the best solution though ;)
17:15:45 <chessguy> hey procyon112, you around?
17:15:57 <siti> yeah the combination of both would be good
17:16:25 <LordBrain> doesn't the latest ghc let you mix ghci bytecode in?
17:16:45 <LordBrain> i recall reading something like that...
17:16:47 <ndm> LordBrain, only when running ghci, hs-plugins does some trickery, but it isn't a proper solution
17:17:02 <ndm> to running as bytecode, it is for doing plugins, of course
17:17:48 <chessguy> @pl \x -> case x of (Just _) -> True; Nothing -> False
17:17:48 <lambdabot> (line 1, column 23):
17:17:48 <lambdabot> unexpected "_"
17:17:48 <lambdabot> expecting variable, "(", operator or ")"
17:17:56 <chessguy> @pl \x -> case x of (Just y) -> True; Nothing -> False
17:17:57 <lambdabot> (line 1, column 26):
17:17:58 <lambdabot> unexpected ">" or "-"
17:17:58 <lambdabot> expecting variable, "(", operator or end of input
17:18:35 <dolio> > maybe False (const True) (Just 5)
17:18:39 <lambdabot>  True
17:18:48 <dolio> > maybe False (const True) (Nothing)
17:18:52 <lambdabot>  False
17:19:07 <chessguy> ?src maybe
17:19:10 <lambdabot> maybe n _ Nothing  = n
17:19:10 <lambdabot> maybe _ f (Just x) = f x
17:19:51 <ndm> chessguy, isJust
17:19:59 <chessguy> ?src isJust
17:20:00 <lambdabot> isJust Nothing = False
17:20:00 <lambdabot> isJust _       = True
17:20:03 <ndm> @hoogle Maybe a -> Bool
17:20:04 <lambdabot> Maybe.isJust :: Maybe a -> Bool
17:20:04 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
17:20:16 <dolio> I am beaten.
17:20:31 <chessguy> now i've got to remember what i wanted it for :)
17:20:45 <ndm> I recommend everyone read through Data.Maybe, and probably Data.List as well - it will save you time in the long run
17:22:16 <monochrom> In general RTFM
17:22:43 <ndm> ATFH
17:22:56 <chessguy> ?vera ATFH
17:22:57 <ndm> ask the * hoogle
17:23:00 <lambdabot> No match for "ATFH".
17:23:07 <chessguy> lol
17:23:22 <jcreigh> that's one of the fun things about Haskell: Once you figure what type of function you need, you're halfwaythere.
17:23:30 <jcreigh> s/way/& /
17:23:35 <dcoutts> @arr
17:23:36 <lambdabot> Yeh scurvy dog...
17:23:41 <JoshTriplett> @remember ndm ATFH: ask the * hoogle
17:23:42 <lambdabot> Done.
17:23:52 <monochrom> I practice type-oriented programming.
17:24:23 <sjanssen> @remember jcreigh that's one of the fun things about Haskell: Once you figure what type of function you need, you're halfwaythere.
17:24:23 <lambdabot> Done.
17:24:38 <jcreigh> ...and now my typo is recorded forever. :)
17:24:47 <ndm> hi dcoutts, i'll be in Oxford on monday :)
17:24:53 <monochrom> Pretend it's German.
17:25:11 <JoshTriplett> monochrom: gehalfenwayther?
17:25:15 <monochrom> Not to mention that halfwaythere is shorter than half way there. :)
17:25:48 <jcreigh> halfwaythere seems Orwellian...
17:25:55 <monochrom> hehe
17:25:57 <sjanssen> @djinn a -> (b -> a) -> Maybe b -> a
17:25:58 <lambdabot> f a b c =
17:25:58 <lambdabot>     case c of
17:25:58 <lambdabot>     Nothing -> a
17:25:58 <lambdabot>     Just d -> b d
17:26:32 * JoshTriplett tries to think of a real application of a function with that signature...
17:26:42 <JoshTriplett> @hoogle a -> (b -> a) -> Maybe b -> a
17:26:43 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
17:26:46 <jcreigh> @src maybe
17:26:47 <lambdabot> maybe n _ Nothing  = n
17:26:47 <lambdabot> maybe _ f (Just x) = f x
17:26:54 <JoshTriplett> nm. :)
17:26:54 <monochrom> Nice, djinn knows a handful of common types
17:27:13 <kpreid> JoshTriplett: it's like foldr
17:27:23 <monochrom> It is the foldr of Maybe.
17:27:29 <dolio> 'maybe default id (lookup map key)' is common, I think.
17:27:36 <JoshTriplett> monochrom: I knew about maybe, I just didn't immediately connect it to that type signature.
17:27:49 <jcreigh> dolio: fromMaybe seems better there
17:27:55 <chessguy> @pl \x -> let y = f x in if (isJust y) then y else g x
17:27:55 <monochrom> Did I say something?
17:27:55 <lambdabot> ap (flip (if' =<< isJust) . g) f
17:28:34 <JoshTriplett> @type if'
17:28:36 <dcoutts> SamB: I think the main issue with C++ GUI libs (wx/qt) is that they don't play nicely with GC'd languages, they expect you to know when to free things and not free them too early (which is hard if you do not know which other things have references to said object/widget).
17:28:37 <lambdabot> Not in scope: `if''
17:28:42 <chessguy> ?hoogle if
17:28:43 <lambdabot> Prelude.if :: keyword
17:28:43 <lambdabot> Foreign.C.Error.throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
17:28:43 <lambdabot> Foreign.Marshal.Error.throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
17:28:53 <chessguy> ?hoogle+
17:28:53 <lambdabot> Language.Haskell.Syntax.HsIf :: HsExp -> HsExp -> HsExp -> HsExp
17:28:54 <lambdabot> System.Win32.Types.failIf :: (a -> Bool) -> String -> IO a -> IO a
17:28:54 <lambdabot> Language.Haskell.TH.Ppr.parensIf :: Bool -> Doc -> Doc
17:28:56 <chessguy> ?hoogle+
17:28:56 <lambdabot> Data.Array.Diff :: module
17:28:57 <lambdabot> Directory.getModificationTime :: FilePath -> IO ClockTime
17:28:57 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
17:28:59 <chessguy> ?hoogle+
17:28:59 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
17:28:59 <lambdabot> Monad.liftM3 :: Monad a => (b -> c -> d -> e) -> a b -> a c -> a d -> a e
17:29:01 <lambdabot> Monad.liftM4 :: Monad a => (b -> c -> d -> e -> f) -> a b -> a c -> a d -> a e -> a f
17:29:05 <chessguy> bah
17:29:15 <chessguy> ?hoogle if'
17:29:15 <lambdabot> No matches found
17:29:15 <jcreigh> chessguy: /msg lambdabot for stuff like that, please. :)
17:29:22 <JoshTriplett> @hoogle Bool -> a -> a -> a
17:29:24 <lambdabot> No matches, try a more general search
17:29:33 <ndm> chessguy, hoogle isn't silly - if if' was there, it would have been second - its not
17:29:42 <kpreid> chessguy: I think you want mplus
17:29:44 <ndm> don't use lambdabot, use the hoogle website if you want many results
17:29:48 <dolio> jcreigh: I suppose. The catamorphism subsumes all the more specific ones, though.
17:29:52 <ndm> plus pretty colours and haddock documentation links etc.
17:29:55 <ndm> @where hoogle
17:29:55 <lambdabot> http://www.haskell.org/hoogle
17:29:58 <chessguy> how does pl use if', when it's not in scope
17:30:13 <chessguy> kpreid: how so?
17:30:17 <ndm> chessguy, who said pl code will run
17:30:26 <kpreid> wait, not mplus, but rather the Kliesli arrow equivalent
17:30:26 <jcreigh> dolio: errr...what? Does that translate roughly to "fromMaybe is a special case of maybe"?
17:30:30 <kpreid> or something like that
17:31:01 <monochrom> ?type fromMaybe
17:31:04 <lambdabot> forall a. a -> Maybe a -> a
17:31:08 <dolio> jcreigh: Yeah. maybe is the function you can write everything else in terms of. Like foldr with lists.
17:31:14 <dolio> Roughly speaking.
17:32:20 <sjanssen> catamorphism!
17:32:37 <monochrom> catamorphism is not scary.
17:32:49 <dolio> Although I can't figure out how to write a lazy tail with the list catamorphism.
17:33:08 <dcoutts> sjanssen: btw, do you recall your 'build' in terms of streams hack ?
17:33:17 <sjanssen> dcoutts: yeah, what about it?
17:33:19 <kpreid> chessguy: \x -> f x `mplus` g x
17:33:29 <dcoutts> sjanssen: I can't remember how it worked :-)
17:33:31 <dolio> I was playing around the other day with 'newtype List a = Build { foldr' :: forall b. (a -> b -> b) -> b -> b }', and that was one sticking point.
17:33:37 <kpreid> chessguy: that's the same as  \f g x -> let y = f x in if (isJust y) then y else g x
17:33:42 <dolio> And suchlike.
17:33:44 <chessguy> @type \x -> ?f ?x `mplus` ?g ?x
17:33:47 <lambdabot> forall t (m :: * -> *) a t1. (MonadPlus m, ?g::t1 -> m a, ?x::t1, ?f::t1 -> m a) => t -> m a
17:33:53 <sjanssen> dcoutts: hmm, give me a couple minutes
17:34:03 <kpreid> er, where'd those ?s come from?
17:34:36 <chessguy> implicit parameters
17:34:50 <kpreid> I know, but why did ...oh
17:34:59 <sjanssen> dcoutts: what does your Stream data type look like nowadays?
17:35:00 <kpreid> you might want to take them off the xes
17:35:06 <dcoutts> sjanssen: pretty much the same
17:35:35 <dcoutts> sjanssen: different class constraints and different smatterings of ! but basically the same
17:35:46 <ddarius> dolio: Tail is ugly, add para morphisms, or better read and apply "Recursion Schemes from Comonads"
17:36:06 <chessguy> @type \f g x -> f x `mplus` g x
17:36:06 <dcoutts> sjanssen: we've got this cool Unlifted class of strict unlifted types that we use for stream states :-)
17:36:08 <lambdabot> forall t (m :: * -> *) a. (MonadPlus m) => (t -> m a) -> (t -> m a) -> t -> m a
17:36:09 <kpreid> chessguy: mplus on Maybes just takes the first Just of its arguments
17:36:12 <chessguy> does that make you feel better? :)
17:36:28 <procyon112> How do I import a module from the ghci repl
17:36:29 <procyon112> ?
17:36:36 <kpreid> procyon112: :m + Module
17:36:40 <procyon112> danke
17:36:41 <chessguy> procyon112!
17:37:18 <dolio> ddarius: I didn't really want tail specifically, but without it it's not immediately clear to me how to define zip(With) in terms of foldr, though it may well be possible.
17:37:41 <chessguy> kpreid++ nice solution
17:38:19 <kpreid> and if you ever want both answers, just switch it to the list monad :)
17:38:32 <ddarius> Tree!
17:38:33 <chessguy> heh. that wouldn't make much sense in this case :)
17:39:32 <jcreigh> sjanssen: refocus -> setFocus patch sent. Borders actually follow mod-{j,k} around now.
17:40:06 <chessguy> hey procyon112, do you have koza's (first) GP book? from '92?
17:40:32 <ddarius> > snd $ foldr (\x (xs,txs) -> (x:xs,txs)) ([],error "tail of empty list") [1..]
17:40:34 <lambdabot>  Exception: stack overflow
17:40:46 <ddarius> > snd $ foldr (\x ~(xs,txs) -> (x:xs,txs)) ([],error "tail of empty list") [1..]
17:40:51 <lambdabot> Terminated
17:41:00 <ddarius> > snd $ foldr (\x ~(xs,txs) -> (x:xs,txs)) ([],error "tail of empty list") [1..10]
17:41:02 <lambdabot>  Exception: tail of empty list
17:41:13 <ddarius> > snd $ foldr (\x ~(xs,txs) -> (x:xs,xs)) ([],error "tail of empty list") [1..10]
17:41:15 <lambdabot>  [2,3,4,5,6,7,8,9,10]
17:41:20 <ddarius> > snd $ foldr (\x ~(xs,txs) -> (x:xs,xs)) ([],error "tail of empty list") [1..]
17:41:21 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
17:41:27 <dolio> Ah, well, there we are.
17:41:38 <dolio> I guess I needed the irrefutable pattern match.
17:41:45 <jcreigh> negative LOC patches are fun...too bad they're harder to make.
17:42:00 <ddarius> jcreigh: They are quite easy to make.
17:42:10 <jcreigh> ...while maintaining functionality. :)
17:42:15 <dolio> ddarius++
17:42:20 <ddarius> A might trickier.
17:42:24 <ddarius> s/might/mite
17:42:28 <hpaste>  sjanssen pasted "streaming and build" at http://hpaste.org/1203
17:42:44 <sjanssen> dcoutts: that's how I remember it
17:42:55 <dcoutts> sjanssen: ta
17:43:23 <dcoutts> sjanssen: ah yes and the wrap was because we were strict in the stream state
17:43:32 <dcoutts> sjanssen: while build required it to be lazy
17:43:55 <sjanssen> dcoutts: actually, this wrap is to make the type finite
17:44:11 <dcoutts> sjanssen: oh, that's more exciting :-)
17:44:36 <dcoutts> @type GHC.Base.build
17:44:39 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
17:45:00 <sjanssen> though if the defn. of Step had Yield a !s you'd need data
17:45:17 <dcoutts> right
17:46:12 <dcoutts> @src build
17:46:13 <lambdabot> build g = g (:) []
17:46:15 <sjanssen> I think the RULE is forall f. build f = unstream (streamFoldr f), or something
17:46:18 <procyon112> chessguy: My typeof is broken :/
17:46:32 <chessguy> procyon112: uh-oh!
17:46:37 <procyon112> I just found a case where it gives a non-simplified answer.
17:46:50 <dcoutts> sjanssen: yes, that makes sense
17:47:24 <rhz_> I am getting this runtime error using GLUT in a ghc compiled program: "user error (unknown GLUT call glutSolidCylinder, check for freeglut)". Is this a bug in the GLUT module?
17:47:39 <procyon112> I don't think it's a big deal... but damn, It's hard to debug an algorithm that I wrote, but I'm not sure how it works.
17:48:37 <chessguy> lol
17:51:40 <sjanssen> jcreigh: pushed, cheers
17:51:48 <procyon112> chessguy: typeof const (+ $ ap const const 1 2) 3) -- is giving me the equivelent of type "a" instead of "Int" because it infers that the type is b, and b == a and a == int, but it only substitutes 1 level
17:52:49 <procyon112> And I'm not sure how to fix it... Oh well, It's not used in my tree generator, so I guess I can let it slide for now.
17:54:12 <procyon112> Damn Haskell typechecker... It lets me write code I don't understand, but can verify correct.
17:54:40 <jcreigh> sjanssen: cool. focus handling still seems a little weird...seems like we have lots of functions that try to deal with it. I don't know...can't quite put my finger on it. seems like there must be a better way.
17:55:03 <sjanssen> yeah, there needs to be some simplification
17:55:51 <jcreigh> but I think moving that to setFocus is a step in the right direction, anyway.
17:56:41 <sjanssen> I should try the selectInput changes in refresh.  At that point we might be able to have every focus and window changing function call refresh
17:57:44 <jcreigh> and that would be "ignore enter/leave window... do refresh...unignore enter/leave window"?
17:58:07 <sjanssen> jcreigh: correct
17:58:50 <procyon112> @pl \x y z = (x,y,z)
17:58:50 <lambdabot> (line 1, column 8):
17:58:50 <lambdabot> unexpected "="
17:58:50 <lambdabot> expecting pattern or "->"
17:58:59 <procyon112> @pl \x y z -> (x,y,z)
17:59:00 <lambdabot> (,,)
17:59:19 <jcreigh> > (,,,,) 1 2 3 4
17:59:21 <lambdabot>  Add a type signature
17:59:24 <jcreigh> grr...
17:59:36 <jcreigh> but anyway, there's a bunch of (,,,) functions for various tuple sizes...
17:59:38 <sjanssen> > (,,,) 1 2 3 4
17:59:40 <lambdabot>  (1,2,3,4)
17:59:49 <procyon112> neato
17:59:49 <jcreigh> oh, right.
18:00:08 <chessguy> procyon112?
18:00:21 <jcreigh> but most tuples bigger than 2-tuples want to be datatypes.
18:00:28 <procyon112> yes?
18:00:38 <chessguy> do you have koza's first GP book?
18:00:43 <ndm> i like the 3 tuple, but there are no standard functions to extract elements from it :(
18:00:58 <procyon112> chessguy: no.. I digested that years and years ago.
18:01:23 <chessguy> ah. i was thinking of modelling the GUI for our library after the interface he talks about
18:01:27 <procyon112> ndm: yeah.. we were talking about that the other night.
18:01:46 <procyon112> chessguy: I don't remember his interface. :(
18:02:08 <dolio> ?pl \a as -> if' (p a) (a:as) as
18:02:09 <lambdabot> join . ap ((.) . if' . p) (:)
18:04:08 <procyon112> ndm: we had an amusing naming convention.  fst,snd; frst,scnd,thrd; first,secnd,third,forth;.... fiiirst, seecond, thiiird, foourth, fiiifth, siiixth...
18:04:35 <ndm> procyon113, i have the convention: fst3, snd3, thd3
18:04:51 <ndm> procyon112, and of course this can extend equally
18:05:12 <procyon112> ndm: that's not anywhere near as amusing though.  Sometimes amusement trumps scalability ;)
18:05:37 <procyon112> ?src if'
18:05:37 <lambdabot> Source not found. Wrong!  You cheating scum!
18:06:28 <procyon112> ?pl x y z = (nonexistant x) + y + z
18:06:29 <lambdabot> x = fix (((+) .) . (+) . nonexistant)
18:06:46 <procyon112> ahh.. I didn't know it worked for undefined functions... kool!
18:09:19 <procyon112> ?pl myfunc t c = foldl (\s (x,y) -> func x y s) t c
18:09:20 <lambdabot> myfunc = foldl ((`ap` snd) . (. fst) . flip (flip . func))
18:10:42 <procyon112> I want an implant that lets me do ?pl in my head.
18:11:23 <dolio> With enough practice, it's not too hard to do the useful pointless transforms in your head.
18:11:54 <procyon112> I hope to get there eventually then.
18:12:14 <dolio> Where I'd probably categorize the above one as useless (too much flipping and such).
18:12:42 <procyon112> yeah
18:13:27 <procyon112> ?pl x y x = m where m = y
18:13:27 <lambdabot> (line 1, column 19):
18:13:27 <lambdabot> unexpected "="
18:13:27 <lambdabot> expecting variable, "(", operator or end of input
18:13:53 <procyon112> ?pl x y x = m; where m = y
18:13:53 <lambdabot> (line 1, column 10):
18:13:54 <lambdabot> unexpected ";"
18:13:54 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
18:14:17 <sjanssen> procyon112: I don't think pl parses where
18:14:26 <procyon112> just checking
18:14:30 <sjanssen> it's got an ugly little parser for a subset of Haskell
18:15:45 <procyon112> ?pl scnd (_,s,_) = s
18:15:46 <lambdabot> (line 1, column 7):
18:15:46 <lambdabot> unexpected "_"
18:15:46 <lambdabot> expecting lambda abstraction or expression
18:16:00 <procyon112> ?pl scnd (a,s,b) = s
18:16:00 <lambdabot> (line 1, column 14):
18:16:00 <lambdabot> unexpected "="
18:16:00 <lambdabot> expecting variable, "(", operator or end of input
18:16:06 <sjanssen> it doesn't know 3 tuples either
18:16:11 <procyon112> IC
18:16:24 <procyon112> I'm always breakin stuff
18:16:38 <sorear> hello!
18:16:42 <procyon112> yo
18:16:43 <sjanssen> that can't be point freed anyway with the standard libs anyway
18:17:06 <procyon112> I didn't figure it could, but I was wondering if I'd be suprised.
18:17:19 <sorear> > (\ (x,y,z) -> y) . Foreign.free  -- Point freed!
18:17:21 <lambdabot>   Not in scope: `Foreign.free'
18:18:29 <sjanssen> hmm, is there really no way to point free it?
18:18:38 <sjanssen> I wonder if Data.Generics can do it
18:18:45 <sorear> cheating :)
18:18:49 <sjanssen> @hoogle uncurry3
18:18:49 <lambdabot> No matches found
18:19:35 <sorear> @seen dons
18:19:36 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 11h 41m 59s ago.
18:20:09 <procyon112> ?pl x y c = fmap (++ [(x,y)]) (u $ s x y c)
18:20:10 <lambdabot> x = fix (ap (ap . (((.) . fmap . flip (++)) .) . flip flip [] . ((:) .) . (,)) (((u .) .) . s))
18:20:50 <sorear> ...BWAHAHAHA!
18:20:57 <dolio> Beautiful.
18:21:10 <procyon112> I think I like the pointfull version.
18:21:31 <procyon112> ?pl ua x y c = fmap (++ [(x,y)]) (u $ s x y c)
18:21:32 <lambdabot> ua = ap (ap . (((.) . fmap . flip (++)) .) . flip flip [] . ((:) .) . (,)) (((u .) .) . s)
18:21:43 <sorear> Prelude GHC.Exts> (snd . unsafeCoerce# :: (a,b,c) -> b) (1,2,3)
18:21:43 <sorear> 2
18:21:47 <sorear> procyon112: ^^^
18:21:59 <procyon112> lol
18:22:03 <sjanssen> mwahaha
18:22:25 <procyon112> Somehow, I alse prefer a pattern match to an unsafeCoerce :)
18:23:08 <sorear> Unsafecoerce is GREAT for pfholics!
18:23:44 <procyon112> phholism can lead to unsafe coding.
18:23:52 <procyon112> pfholism can lead to unsafe coding.
18:24:33 <sjanssen> sorear: I don't like the points in the type signature
18:25:09 <sjanssen> @pl \x -> f x x x
18:25:10 <lambdabot> join (join f)
18:25:37 <sjanssen> @type join (join (,,)) undefined
18:25:39 <lambdabot> forall a. (a, a, a)
18:27:25 <procyon112> ?src join
18:27:25 <lambdabot> join x =  x >>= id
18:28:04 <sorear> That definition is too pointy.
18:28:13 <Botje> you should add arrows.
18:28:17 <Botje> or possibly spears
18:28:26 <procyon112> ?pl j x = x >>= id
18:28:26 <lambdabot> j = join
18:28:29 <procyon112> lol
18:28:50 <Botje> :t (>>= id)
18:28:51 <sorear> I was thinking (>>= ap const const)
18:28:52 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
18:29:04 <sorear> :t ap return return
18:29:07 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> a
18:29:18 <sorear> :t (>>= ap return return)
18:29:21 <lambdabot> forall (m :: * -> *) b (m1 :: * -> *). (Monad m1, Monad m) => m (m b) -> m b
18:29:29 <sorear> wtf?
18:29:38 <sorear> This isn't System F!
18:29:42 <procyon112> :t (>>= ap const const)
18:29:45 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
18:29:50 <rahikkala> :t join
18:29:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:30:02 <procyon112> return != const
18:30:15 <sorear> bzzt
18:30:19 <sorear> @src (->) return
18:30:20 <lambdabot> return = const
18:30:25 <procyon112> s/!=//=
18:30:43 <sorear> Invalid substitution flag: =
18:30:48 <procyon112> lpl
18:30:49 <sorear> ;)
18:30:53 <procyon112> lol even
18:30:54 <sorear> lpl?
18:31:09 <Botje> Can't assign to substitution (s///) at ..
18:31:09 <sorear> Lazy Perl?
18:31:57 <Botje> ((*) >>= ap const const) 5
18:31:59 <Botje> > ((*) >>= ap const const) 5
18:32:00 <sorear> ... and augustsson's amazing Chalmers Lazy Perl Compiler ...
18:32:01 <lambdabot>  25
18:32:06 <Botje> it weven works.
18:32:25 <Botje> obfuscation is too easy :(
18:32:27 <procyon112> > ((*) >>= ap return return) 5
18:32:28 <lambdabot>  Add a type signature
18:32:45 <procyon112> > (((*) >>= ap return return) 5) :: Int
18:32:45 <lambdabot>  Add a type signature
18:32:51 <sorear> Haskell is not System F, unfortunately.
18:33:20 <sorear> We pay a lot of sanity for our conciseness.
18:33:58 <Botje> sanity is for java programmers.
18:34:39 <procyon112> Java is not sane... Java is structured to the point of autistic
18:34:51 <Botje> funny.
18:34:59 <Botje> so why can't you put ints in a Map ?
18:35:07 <sorear> Because you can't
18:35:28 <sorear> Don't argue with the sun god, for he is all powerful!
18:35:29 <procyon112> > map +1 [1,2,3]
18:35:30 <lambdabot>        add an instance declaration for
18:35:30 <lambdabot>       (Num ([t] -> (a -> b) -> [a] -> ...
18:35:38 <dolio> You can these days, no? Since they added auto-boxing?
18:35:40 <procyon112> > map (+1) [1,2,3]
18:35:41 <lambdabot>  [2,3,4]
18:35:57 <procyon112> Oh... THAT kinda map.
18:36:05 <dolio> I guess that's cheating, though.
18:36:11 <Botje> dolio: it still fails horribly on java 1.5
18:36:25 <Botje> I should check out the new java sometime
18:36:33 <ddarius> C#?
18:36:36 <sorear> procyon112: is the 112 constant?
18:36:38 <dolio> Ah. I haven't actually used Java in a while.
18:36:47 <procyon112> Because Int's aren't an object.. They are a java hack for performance.
18:37:10 <ddarius> They are a Java hack for implementation simplicity.
18:37:15 <sorear> {- deliberate leading space -} @remember procyon112 Java is not sane... Java is structured to the point of autistic
18:37:17 <Botje> but surely the compiler could auto-promote ints to Integers?
18:37:24 <procyon112> sorear: yes.  It's a number I picked years ago for times when people steal "procyon" ;)
18:37:27 <ddarius> autism
18:37:42 <sorear> Botje: aren't ints fixnums?
18:38:04 <sorear> Botje: Oh, wait, Java Integers aren't?
18:38:04 <Botje> sorear: think so
18:38:12 <ddarius> BigInt
18:38:16 <Botje> oh. that kind of Integer.
18:38:18 <Botje> no.
18:38:22 * sorear is spoiled
18:38:35 <sorear> @remember procyon112 Java is not sane... Java is structured to the point of autism
18:38:36 <lambdabot> Done.
18:38:38 <Botje> Integer (in java) is an object representation of the native int data type
18:38:52 <Botje> because eg a Map takes Objects
18:38:54 <sorear> I imagine it's waay slower than Int :)
18:39:02 <ddarius> Really sorear, how often do you truly take advantage of (Haskell's) Integer?
18:39:02 <sorear> (haskell Int)
18:39:08 <Botje> and Since An Int Is Not An Object, You Can't Put It In A Map.
18:39:08 <dolio> All the primitives have wrapper classes like that.
18:39:26 <Botje> (emphasis by the sun god)
18:39:28 <ddarius> But, but, but everything is an object!
18:39:38 <procyon112> not in Java.
18:39:38 <sorear> ddarius: normally I don't.  but it gives my complete freedom from integer overflow
18:39:56 <sorear> ddarius: and really, integer overflow is something the compiler should worry about for me
18:40:08 <nnunley> java maintains a small pool of constant Integers to map to small ints, primarily to cushion the performance blow of their implementation of autoboxing.
18:40:42 <monochrom> everything is an object, until you want performance. then you introduce non-objects for performance. then you keep converting between the two and lose performance.
18:40:44 <sorear> Glasgow haskell interns Ints too, but lazily at GC time.
18:40:56 <sorear> Int# anyone?
18:40:59 <ddarius> It does come in handy though.  E.g. the hardest part about writing many cryptographic algorithms is implementing Integers.
18:41:13 <Botje> *yawn*
18:41:15 <Botje> time for sleep
18:41:20 <Botje> 03:39
18:41:42 <ndm> sorear, Yhc's C back end will have lazy unboxed Int's
18:41:59 <ddarius> ... why?
18:42:01 * lambdabot /kicks Botje
18:42:18 <sorear> ndm: aren't unboxed types unpointed by definition?
18:42:32 <ddarius> No...
18:42:43 <procyon112> sorear:  Java:Haskell int:Int# Integer:Int BigInt:Integer.. pretty similar performance between the 2 languages.
18:42:45 <sorear> ndm: or can you get around that by using catch to eliminate the need for pointedness
18:43:23 <sorear> procyon112: so heavy java.whatever.Integer code is automatically unboxed with -O ?
18:43:27 <ndm> sorear, you can put the "point" in as a tag
18:44:05 <sorear> ndm: you can't detect the point, unless you have a hypercomputer
18:44:16 <sorear> ndm: so we need some kind of thunk!
18:44:26 <procyon112> sorear: I don't think there Is an -O in javac.. but yeah.
18:44:28 <ddarius> 0|ptrtothunk 1|int#
18:44:44 <sorear> ndm: I can see inlining that, but it can't be a raw int32_t
18:44:49 <ndm> soear, we have values so that we can tell if its a thunk, or a value
18:44:58 <ndm> sorear - not a raw int, but a raw int with a tag
18:45:16 <dons> ?yow
18:45:16 <lambdabot> Everywhere I look I see NEGATIVITY and ASPHALT ...
18:45:29 <ndm> i hope to go for full unboxing once -O11 is done, from initial investigations it seems that -O11 might actually make nearly all the code strict
18:45:45 <ndm> not something I'd expected at all!
18:46:04 <dcoutts> g'morning dons
18:46:09 <sorear> hiya dons
18:46:22 <procyon112> night all.  gotta run.
18:46:32 <sorear> dons: there's a message on -cafe wrt lambdabot that has just passed outside my field.
18:46:33 <dolio> That'll please the people who ask for eager haskell every so often. :)
18:46:42 <dcoutts> ndm: I think you should call it -O11!!11!
18:46:44 <ddarius> Everywhere you looked there was confusion, violence, drama, and drugs
18:46:56 <foxy_> dons, Hi!  Did you get my email about unresolved links (_free) wrt hs-plugins
18:46:58 * sorear /whois ddarius 
18:47:10 <ndm> dcoutts, currently -Ovarpourware is more appropriate
18:47:15 <dcoutts> ndm: or even better: -OMG!!!1
18:47:39 <dolio> Heh, I like that one.
18:47:45 <sorear> ndm: I think a spinal tap reference would be even funnier still.  How does "-O11" sound?
18:48:44 <ndm> sorear, -O11 is the current name :)
18:49:08 <sorear> ndm: I know, I just like it better than -OMG
18:49:48 <ndm> i can support both flags :)
18:49:58 <ndm> (supporting flags is easy, writing the optimiser might be harder...)
18:51:13 <sorear> Is it still just conditional rewrite rules with Catch to eliminate the preconditions, or is there more unpublished fanciness?
18:51:56 <ndm> how do you mean?
18:52:00 <ndm> for -O11?
18:52:06 <sorear> yeah
18:52:16 <ndm> i don't really focus on eliminating preconditions with that, the Catch stuff is mainly unused
18:52:40 <ndm> i have a small set of rules and a strategy for applying them - entirely unpublished so far
18:53:08 <ndm> a side effect is that a lot of error calls are eliminated, but then so is a lot of stuff
18:53:09 * sorear has mad dreams of writing an uber-optimizer based on GP, profiler feedback, and interpretation using an abstract trace+data cache model
18:53:44 <sorear> that kind of stuff is very low level however
18:53:52 <ndm> my optimiser assumes that C is the level to optimise for - no profiler hints or cache stuff
18:54:06 <sorear> might grind icc to a pulp, but would be helpless at deforestation
18:54:10 <ndm> once i've done that though, someone else could easily play low level
18:55:12 <sorear> So where does -O11 fit in? UnoptimizedCore -> C? OptimizedCore -> C?
18:55:52 <ddarius> ndm: The "EXE: Automatically Generating Inputs of Death" paper I keep talking about may be a decent paper for related work.
18:56:22 <ndm> sorear, unoptimised Core -> super-optimised Core
18:56:50 <ndm> sorear, then i have stage 2, which is super-optmised first-order Core + strictness analysis -> C
18:57:08 <ndm> stage 1 is actually upoptimised first-order Core -> super-optimised first-order Core
18:57:28 <ndm> ddarius, months away yet, remind me later :)
18:58:01 <ndm> ddarius, unless you are talking about the Catch paper?
18:58:08 <ddarius> ndm: Catch paper
18:59:04 <sorear> ndm: is -O11 Just A Shiny OSS Project or does it have academic implications?
18:59:26 <sorear> ndm: Urban Boquist got a Phd for something not extremely different...
18:59:33 <ndm> sorear, its chapter 5 of my PhD thesis
18:59:59 <ndm> i have: Play, First-Order Haskell, -O11, Catch as the chapters in my thesis
19:00:47 <hpaste>  zeeeee pasted "help, i'm getting a compiler error when trying to building my simple app" at http://hpaste.org/1204
19:01:00 <sorear> --maek
19:01:43 <ndm> I have read some of Boquist's PhD, and i realise its similar stuff
19:01:49 * ddarius should email Goguen.
19:01:55 <ndm> but I want -O11 to be fast at compile time as well
19:02:09 <sorear> How fast is GRIN?
19:02:24 <sorear> I would assume it's much much much faster than jhc
19:02:25 <ndm> ddarius, not quite appropriate for Catch, esp as I'm trying not to change too much now - but perfect for the guy who sits next to me!
19:02:37 <sorear> same side?
19:02:50 <ndm> sorear, i'm not sure there was ever an available implementation, but pretty slow i thought
19:03:39 <ddarius> It does similar things albeit in a rather different context and with different vocabulary.  It even works and very roughly the same way.
19:04:08 <sorear> ddarius: pronoun resolution error
19:04:08 <monochrom> Windows Causes C?
19:04:13 <ndm> ddarius, it seems quite different - esp in mode of operation - but very similar to the guy who sits next to me
19:04:22 <sorear> ndm: still talking about m.naylor?
19:04:29 <ddarius> As long as it's useful.  It's a good paper.
19:04:31 <ndm> sorear, yep
19:04:43 <sorear> ndm: How many people sit next to you? 8? 26? 4? 2? 1?
19:04:51 <ndm> very useful, he'll love it
19:04:54 <ddarius> 3^^^^3
19:05:02 <ndm> one sits directly next to me, matt naylor
19:05:08 <sorear> ooh, bignum
19:05:16 <ndm> tom shackell sits next to me, but through a thin divider
19:05:29 <ndm> malcolm wallace is the other side of the corridor
19:05:49 <sorear> tom davie? :)
19:05:53 <ndm> kent
19:06:07 <ndm> one person in my area only comes in about once a month for a few hours
19:06:18 <ndm> one guy left and moved to columbia with his wife
19:07:14 <ndm> my office is currently pretty much desserted
19:07:22 <sorear> Yum.
19:07:45 <sorear> sorry :)
19:07:48 <zeeeee> sorear: thanks
19:09:08 <ndm> sorry, was hungry
19:09:43 <ndm> had a sorbet for desert, another word for "flavoured ice"
19:10:23 <sorear> yeah, people look at me funny when I eat unflavoured ice ;-)
19:11:06 <Adamant> chewing ice is fun
19:12:02 <sorear> is -O11 mostly ideas-hard or code-hard? (cloning difficulty)
19:13:42 <ndm> sorear, i have an initial version implemented, and the theory is mainly done - i would say ideas-hard and code-easy
19:14:12 <ndm> i need to work on the code, from a theory point of view, but once its done I suspect it will be very easy to replicate
19:14:14 <sorear> I worry I may not be able to resist adding an optimizer to my compiler :)
19:15:27 <sorear> HV is on hold until derive is unbroken and drift-for-C is finished, I suspect this means "forever" :(
19:15:44 <ndm> sorear, once i've got the details, i'll let you know - shouldn't be too hard
19:15:50 <ndm> although will require whole-program compilation
19:16:36 <sorear> Whole program is no problem.  Ghc --make is whole program.  Albiet with a lot of memoization.
19:16:42 <sorear> @spell albiet
19:16:44 <lambdabot> albeit Albert Albie alibied Ailbert
19:17:41 <ndm> anyway, i'm going to head to bed now
19:17:49 <ndm> night
19:18:32 <sorear> How bad would it be for derive to generate dumb code like "return 0 >>= \tag -> case tag of 0 -> ..."
19:18:49 <sorear> In the spirit of "let the optimizer do all the hard work"
19:18:50 <ddarius> Damn Goguen and being interesting.
19:20:08 <ddarius> sorear: Premature optimizers are the roots of all evil.
19:20:41 <sorear> ddarius: have you seen what ghc desugars listcomps into ... :|
19:21:02 <sorear> yee gow!
19:21:18 <sorear> ghci -ddump-ds gives results for code not even entired
19:21:19 <ndm> sorear, let the optimiser do the work, if it is an issue, someone will patch it later
19:21:52 * sorear sighs relieffully
19:21:55 <sorear> thanks
19:21:55 <ndm> however, do remebmer that only 1 in 4 current haskell compilers come with an optimiser
19:22:03 <ndm> anyway, rael sleep now
19:23:20 <sorear> Oh, my.
19:23:35 <sorear> ghci -ddump-ds uses unsafeCoerce# in the handling of '2'
19:30:03 <dolio> Hmm, apparently the Haskell sudoku solver community has to watch out. Some people are writing faster solvers in XSLT.
19:30:55 <chessguy> heh. seriously?
19:31:12 <chessguy> how many pages?
19:31:23 <dolio> http://dnovatchev.spaces.live.com/Blog/cns!44B0A32C2CCF7488!355.entry
19:31:25 <lambdabot> http://tinyurl.com/yvpyqg
19:31:35 <dolio> Be careful, your eyes might bleed.
19:32:11 <chessguy> yeah, that's a hideous yellow
19:32:34 * sorear doesn't care!
19:32:50 <dolio> Only one I've tried definitely beats those.
19:33:02 <sorear> man I'm dump
19:33:04 <dolio> Although all the haskell solutions are way shorter, I think. :)
19:33:05 <sorear> *dumb
19:33:10 <sorear> stefan@stefans:/usr/local/src/derive$ links 'http://dnovatchev.spaces.live.com/Blog/cnscd ../filepathB0A32C2CCF7488ghc -ddump-simpl -O2 -fno-code -fglasgow-exts A.hs.entry'
19:33:51 <chessguy> @quote page
19:33:51 <lambdabot> chessguy says: heh. i think i'm officially addicted. i'm chatting in #haskell, helping hack on a haskellwiki page, browing a reddit thread about haskell, while playing a haskell video lecture in the
19:33:51 <lambdabot> background
19:34:01 <chessguy> @quote one.page
19:34:01 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
19:34:04 <chessguy> there we go
19:34:10 <sorear> The background color is a very pretty shade of gray.
19:34:24 <sorear> And the text is a pleasantly darker shade.
19:35:34 <dolio> Strangely enough, the smart solver on the haskell page solves the 'real hardest problem' in the update slower than their original 'hardest problem'.
19:36:04 <dolio> In fact, it solves their original one in 0.15 seconds on my machine, where theirs took over a second (on a faster machine, I think).
19:36:41 <dolio> And, on the other hand, the one in the update takes a little over 2 seconds on my machine, while theirs takes between one and two seconds.
19:37:46 <stepcut> dolio: did you see the sudoku solver written with regular expressions ?
19:38:03 <dolio> Heh. I saw the story, but I didn't look at it.
19:42:54 * sorear considers writing a sudoku solver in p4 asm as an exercise in optimization
19:43:50 <ddarius> Worst paper title ever: "Objects"
19:44:12 <dolio> Tells you just what the paper is about, doesn't it?
19:44:50 <sorear> wadler papers tell you just what they're about
19:44:52 <sorear> funnily
19:45:25 <dolio> Yeah. He has a knack.
19:46:13 <stepcut> sorear: what is ayhi, btw ?
19:46:44 <dolio> Ask you haskell interpreter?
19:46:55 <sorear> One of my indefinitely on hold projects.
19:47:19 <sorear> I'm rewriting yhi in asm to control every aspect of the calling convention.
19:47:19 <stepcut> but, after eternity, what will it do ?
19:47:24 <stepcut> heh
19:47:46 <sorear> This lets me play with stuff that's hard to do in languages like C that do things behind your back.
19:47:50 <sorear> Dumping, for instance.
19:47:59 <sorear> JIT is also on the TODO.
19:48:14 <sorear> In practice most of ayhi will be written in haskell...
19:48:28 <sorear> but as long as I control the interpreter that's fine
19:49:11 <sorear> I also do a MUCH better job than gcc at optimizing for size.
19:49:24 <sorear> I have most of the intepreter already written ... in 4k
19:49:34 <sorear> yhi compiled with gcc -Os is 100k
19:49:46 <stepcut> :p
19:50:22 <stepcut> ayhi, a yhc-bytecode interpreter in under 4096 bytes :p
19:50:56 <chessguy> ?seen procyon112
19:50:57 <lambdabot> I saw procyon112 leaving #haskell 1h 4m 31s ago, and .
19:51:04 <sorear> heh. actually there's a good chance I'll be using Core, too much info is erased at the bytecode level
19:51:42 <sorear> fex. it is impossible to statically reconstruct the stack depth at an arbitrary point in a bytecode function
19:51:58 <sorear> thus making it impossible for the JIT to do register allocation
19:52:06 <sorear> or even -fomit-frame-pointer
19:52:14 * sorear wants EBP as a temporary
19:52:33 <stepcut> heh
19:53:09 <sorear> yhc.core of course :)
19:53:16 <stepcut> right
19:54:11 <araujo> hello!
19:54:14 * sorear begs araujo for a lambda
19:54:31 * araujo throws a sugar-lambda at sorear 
19:54:40 <sorear> :)
19:54:53 <araujo> :-)
19:54:57 <araujo> sorear, how you doing?!
19:55:00 <sorear> good.
19:55:15 <sorear> spring breaking!
19:56:55 <araujo> yay!
19:57:03 * araujo has one week of vacation
19:57:33 * sorear does too, starting tomorrow
20:05:01 <chessguy> i woner if i can have a working chess engine by the end of the day tomorrow
20:05:09 <chessguy> s/one/onde/
20:05:28 <whaleofconfusion> I just had one of those moments where you realize that "who is me" is proper grammar
20:06:35 <sorear> whaleofconfusion: still curious what a branch point is?
20:07:43 <whaleofconfusion> well if you know a good definition I would like to hear it
20:07:52 <sorear> http://tunes.org/~nef/logs/haskell/07.03.29 , 19:17:55 -- good?
20:07:59 <whaleofconfusion> a guy in #math knew some, but it wasn't too practical for immediate calculation
20:08:16 <whaleofconfusion> although it seemed to make sense
20:08:28 <sorear> I think mine makes calculatory sense.
20:11:20 <sorear> whaleofconfusion: whadya think?
20:15:44 * ddarius pulls out his notebook that contains instructions on how to crochet to look for something in the section on complex analysis.
20:16:44 * sorear imagines said section is quite short
20:17:33 <ddarius> Depending on how it's measured, it's probably about as long as the section on generating functions, which may actually be the section I want.
20:19:52 <ddarius> "f(z) has an algebraic singularity, or branch point, at z_0 if f(z) = (z-z_0)^a * g(z) where g is analytic at z_0 and a is not an integer."
20:24:14 <bos> @seen bos
20:24:14 <lambdabot> You are in #haskell-soc and #haskell. I last heard you speak just now.
20:24:17 <bos> @seen dons
20:24:18 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 1h 39m 1s ago.
20:24:32 <sorear> Hi!
20:24:57 <bos> aloha.
20:30:47 <jfoutz> > 5.0 / (length [1,2,3])
20:30:48 <lambdabot>   add an instance declaration for (Fractional Int)
20:30:48 <lambdabot>     In the expression: 5.0...
20:31:14 <jfoutz> how do i promote length [1,2,3] to a fractional?
20:31:34 <sorear> genericLength
20:31:40 <dufflebunk> ooo! I know this...
20:31:45 <dufflebunk> bah. Too slow
20:31:46 <sorear> > 5.0 / genericLength [1,2,3]
20:31:48 <lambdabot>  1.6666666666666667
20:31:56 <jfoutz> you're awesome. thanks.
20:32:11 <thoughtpolice> hey, just wondering, what editors do you guys use for haskell? i've been using emacs' haskell-mode, but I was just wondering what some other people here's preferences are
20:32:13 <sorear> :t length
20:32:15 <lambdabot> forall a. [a] -> Int
20:32:17 <sorear> :t genericLength
20:32:20 <lambdabot> forall b i. (Num i) => [b] -> i
20:32:34 <sorear> <- emacs + haskell-mode
20:32:38 <dufflebunk> thoughtpolice: Emacs here
20:32:43 <jfoutz> me three
20:32:53 <sorear> <- used to use shim, but decided it didn't do anything useful
20:33:13 <dolio> I've been using vim. But emacs + haskell mode is probably nicer for haskell
20:33:33 <dolio> Well, that's a bit redundant.
20:34:06 <sorear> Actually, *clarifies*
20:34:16 <sorear> <- emacs + emu's fork of haskell-mode
20:34:37 <sorear> I think. :(
20:34:53 <sorear> I wish the changes would be fully merged
20:34:59 <sorear> Your choices are:
20:35:00 <thoughtpolice> well at least now i feel like i made a venerable choice, or, something
20:35:15 <sorear> (a) Upstream haskell-mode, with extra dumb intendation
20:35:43 <sorear> (b) Forked haskell-mode, with good indentation but two versions behind in every other way
20:36:01 <sorear> @seen emu
20:36:02 <lambdabot> emu is in #haskell-blah and #haskell. I last heard emu speak 9h 54m 33s ago.
20:36:25 <sorear> Choose wisely.
20:37:42 <thoughtpolice> hm well i'm comfortable with haskell-mode. i need to get it on my other linux box since i like to just write little things  on it from time to time, and no major mode sucks
20:39:22 <jfoutz> you might consider keeping your emacs config in darcs or subversion or cvs. version control has turned out to be pretty handy for those kinds of things.
20:41:44 <ddarius> The Haskell community primarily uses emacs or vim and then a spread of other editors.
20:42:36 <dcoutts> Yi!
20:42:49 <dcoutts> @where yi
20:42:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
20:43:19 <thoughtpolice> i was thinking of looking at yi
20:43:21 <thoughtpolice> looks cool
20:43:46 <dcoutts> apparently the development is going well, patches keep flowing in
20:44:29 <sorear> Yeah, it's going way faster now that jyp has taken over from dons :)
20:44:44 <dcoutts> yep
20:44:53 <dcoutts> dons is very pleased with the hand over :-)
20:45:02 <dcoutts> much more work is getting done
20:45:18 <dcoutts> I intend to try it again soon
20:45:29 <dcoutts> it wouldn't take much to get me to switch from nedit or vim
20:45:55 <dcoutts> and the fact that it has both curses and gui modes is rather nice
20:46:04 * ddarius wouldn't mind using Yi if he could get it vimy enough for his purposes.
20:46:06 <sorear> vim has both too :)
20:46:27 <sorear> ddarius: you think it's an emacs clone?
20:46:28 <dcoutts> sorear: yeah vim is magnificent but it's also vim
20:46:38 <ddarius> sorear: No I don't.
20:46:46 <sorear> ddarius: it's Yet Another Skinnable (yukk!) Editor
20:46:49 <sorear> ok.
20:46:54 <sorear> nm then
20:47:46 <sorear> Now we just need xmonad integration :)
20:49:27 <thoughtpolice> ls
20:49:32 <thoughtpolice> damnit what the hell :(
20:49:39 <sorear> hehe.
20:49:41 <dufflebunk> thoughtpolice: Fille Not found
20:50:11 <thoughtpolice> ugh i'm just getting frusterated. this system update is totally taking forever.
20:50:16 <sorear> From http://tunes.org/~nef/logs/haskell/07.03.26
20:50:16 <sorear> 17:18:55 <merus> su root
20:50:16 <sorear> 17:19:03 <merus> wow, wrong window ;_;
20:50:58 <sorear> thinkpol: feel better now?
20:51:47 <thoughtpolice> sorta i guess
20:52:47 <thoughtpolice> i need something fun to hack on.
20:53:00 <thoughtpolice> it's the weekend and it's going to be a rainy one :(
20:53:00 * stepcut is waiting for Yi to have a good haskell editing mode
20:53:05 <sorear> What are you good at?
20:53:12 <sorear> stepcut: it has synhl.
20:53:47 <stepcut> sorear: does that just syntax highlight? or does it assist with indentation ?
20:53:58 <sorear> just synhl
20:54:18 <thoughtpolice> sorear: i dunno, i want to try and figure out monad transformers, but i can't find any great tutorials. the latetst thing i've been working on is pretty much in a beta right now and i don't feel like workin' on it.
20:54:22 <stepcut> I'm too spoiled by emacs' haskell-mode, as broken as it is
20:54:49 <sorear> stepcut: try emu's fork, the indentation is completely non-broken
20:55:10 <stepcut> fork of haskell-mode ?
20:55:13 <sorear> yeah
20:55:24 <stepcut> @whereis haskell-mode
20:55:24 <lambdabot> Maybe you meant: where where+
20:55:30 <stepcut> @where haskell-mode
20:55:30 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
20:55:56 <sorear> http://mapcar.org/~mrd/emacs/haskell-mode/haskell-mode-2.0.tar.gz
20:56:19 <sorear> or just darcs get the whole ...emacs/
20:58:02 <stepcut> sorear: spiffy, I'll take a look at that later
21:04:31 <ddarius> This is going to be a crappy weekend.
21:04:55 <sorear> No, it'll be great.
21:06:22 <sorear> Yay, mrd-haskell-mode indentation brokenness.  In a layed-out source file, how many valid indentations of an instance stmt are there?
21:11:23 <rashakil> has anybody else every noticed that
21:11:29 <ddarius> I have the curse of tending to be right.
21:11:32 <rashakil> s/every/ever ....
21:13:02 <rashakil> newtype Bar = Bar (Ptr Bar)    ;    data Foo = Foo { x :: {-# UNPACK #-} !Bar }    causes GHC 6.6 to have the impossible happen?
21:13:24 <sorear> rashakil: you know how to check trac?
21:13:40 <rashakil> I have; didn't see anything, but don't know about my searching abilities
21:13:47 <sorear> rashakil: that is by definition a bug
21:14:03 <sorear> rashakil: remember that bugs can always be closed as duplicate-of-XYZ
21:14:15 <sorear> rashakil: so err on the side of too-often
21:14:42 <rashakil> okay okay... was wondering since XState in xmonad seems to avoid it with the display field
21:15:05 <sorear> probably because the newtype isn't recursive?
21:15:21 <sorear> recursive newtypes have a long history of triggering bugs in ghc
21:17:30 <sorear> FWIW head doesn't bomb even with -dcore-lint
21:17:42 <sorear> head has a very different approach for handling newtypes
21:18:03 <sorear> but 6.6 needs to be supported for a while, so for the benefit of everyone who will use 6.6.2
21:18:32 * mwc didn't even know 6.6.2 was out
21:18:43 <mwc> sorear, do you run head snapshots, or pull daily from darcs?
21:18:50 <sorear> mwc: pull weekly
21:18:56 <sorear> mwc: actually I pull hourly
21:19:00 <mwc> Hah
21:19:01 <sorear> mwc: recompile weekly
21:19:16 <sorear> mwc: 6.6.2 isn't out, but 6.6.1 is
21:19:32 <mwc> I started doing that until I ran into build borkedness, now I just grab the head snapshot that's released every week or so
21:19:37 <sorear> mwc: ergo if rashakil's bug is fixed, only people who use 6.6.2 or later will have the fix
21:19:53 <mwc> or more clearly, every week I get the latest head snapshot
21:22:06 <sorear> rashakil: I'm not finding it in the trac.
21:22:15 <sorear> rashakil: go ahead and report it
21:30:07 <ddarius> "Of course there are difficulties, and perhaps there are successes.  But commitment to our art and craft, to our profession, to our own integrity, and to other people, are far more important; life occurs as it is lived, and to live it fully is to appreciate joys and pains as they are, rather than in the light of ambitions that can only intensify pain and confusion."
21:34:04 <rashakil> alright, it's reported, thanks for holding my hand :-)
21:37:54 <sorear> hehe.
21:38:01 <rashakil> hey, in xmonad, would anybody like the ability to shrink/grow right-hand tiled windows vertically, with the ability to toggle size-as-fixed-number-of-pixels and size-as-ratio-of-available-space on a window-by-window basis?
21:38:03 <sorear> yay!
21:38:08 <sorear> binary TH working!
21:38:17 <sorear> now, binarydefer
21:39:05 <rashakil> or is there a better design?
21:39:19 <dons> rashakil: i'd like to be able to grow them vertically, yes.
21:39:19 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:39:39 <dons> in fact, i'd like an entire vertical tiling mode somehow. since my screen isn't wide enough for the horizontal mode relaly.
21:40:35 <rashakil> okay.
21:41:36 <sorear> dons: did I remember to tell you about the lambdabot/XP mail I can't handle?
22:01:35 <wy> Is there a standard way to deal with lookup tables?
22:01:44 <sorear> Map
22:01:50 <sorear> don't use lookup
22:02:00 <sorear> Prelude.lookup that is
22:02:07 <sorear> use Data.Map.* instead
22:02:10 <sorear> @docs Data.Map
22:02:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
22:03:46 <wy> sorear: so many functions. Which are the main two?
22:04:12 <dmwit> wy: fromList, lookup, (!!)
22:04:16 <sorear> fromList and lookup
22:04:26 <sorear> / insert and empty
22:04:41 <sorear> / update and delete
22:04:52 <dmwit> As you need other things, you'll look them up to see if they're there.
22:04:56 <dmwit> (They are. ;-)
22:05:08 <wy> What does "import qualified Data.Map as Map" mean?
22:05:13 <sorear> findMin, split, etc are very rarely used, but are invaluable when you need them
22:05:22 <sorear> wy: uh, that's an import statement
22:05:32 <sorear> wy: in practice most people just use
22:05:41 <sorear> "import qualified Data.Map as M"
22:05:57 <sorear> wy: you know about the haskell module system?
22:06:11 <dmwit> I often use "import Data.Map hiding (map)".
22:06:33 <sorear> bad!
22:06:42 <dmwit> Why?
22:06:50 <sorear> it shadows waay too much other stuff
22:07:08 <dmwit> No, the compiler complains.
22:07:12 <wy> sorear: I know about it somewhat
22:07:19 <sorear> or just use ross' collections :)
22:07:27 <wy> do I just start by inserting into empty?
22:07:35 <sorear> wy: yes
22:07:51 <sorear> wy: or use fromList if you have a list of inital data
22:09:17 <wy> It says "empty" is not in scope. I did have imported the module
22:09:43 <sorear> names aren't always imported under the original names
22:09:55 <sorear> since you used the qualified ... as ... form of import
22:10:08 <sorear> you want M.insert, M.empty, M.Map, M.fromList, etc
22:10:45 <sorear> http://haskell.org/onlinereport/modules.html#sect5.3.2 for all the gory details
22:10:47 <lambdabot> Title: The Haskell 98 Report: Modules
22:12:10 <dmwit> Oh, do people actually read the Report?
22:12:20 <sorear> yes!
22:12:35 <sorear> I don't count however, since I'm an implementor.
22:12:41 <sorear> Not a person.
22:13:10 <dmwit> ah
22:13:20 <wy> sorear: It seems I need something else. It requires the first thing to be able to get ordered.
22:13:24 <dmwit> Actually, that section of the report is relatively readable.
22:13:53 <wy> But the first thing I want to put into the map is some arithmetic operators
22:13:54 <sorear> wy: no, you want to impose a total order on the first argument
22:14:03 <dmwit> wy: Yes, maps have the (Ord a) => Map k a restriction.
22:14:23 <dmwit> Err...
22:14:24 <sorear> wy: fixing Ord is much easier than the alternatives
22:14:29 <dmwit> (Ord k) => Map k a
22:14:33 <sorear> wy: remember strings are ordered
22:14:37 <sorear> > "+" > "-"
22:14:38 <lambdabot>  False
22:14:57 <wy> I defined some datatype like data Expr = EVar String | ...
22:15:04 <sorear> ... deriving(Ord)
22:15:25 <dmwit> Why are you using expressions as keys?
22:15:37 <sorear> and what dmwit said :)
22:15:39 <dmwit> (Out of curiosity.)
22:18:44 <wy> I have a type variable in my definition. So first I have Expr a = EVar a |.... Then I used type CoreExpr = Expr String. How can I derive Ord in this situation?
22:19:14 <sorear> Just try it, it will work.
22:19:32 <sorear> Internally haskell makes an instance of the form Ord a => Ord (Expr a)
22:19:44 <sorear> since Ord [Char], we derive Ord (Expr [Char])
22:19:55 <sorear> and of course synonyms don't matter here
22:20:25 <sorear> but I'm still curious why you use exprs as keys ... sounds like some very fun algorithm
22:20:34 <wy> It says Could not deduce (Eq (Expr a)) from the context (Ord a)
22:20:55 <sorear> ok, deriving(Eq,Ord)
22:20:59 <wy> sorear: It's just a precedence table...
22:21:10 <sorear> wy: "precedence table"?
22:22:05 <wy> sorear: yes. EVar "+" has precedence 3, EVar "*" has precedence 5, etc.
22:22:39 <sorear> wy: what's the precedence of a non-variable?
22:23:00 * sorear suspects "meaningless"
22:23:09 <wy> sorear: applications has precedence 6.
22:23:41 <sorear> ah, so this is sorta like showsPrec
22:23:52 <sorear> it gives the precedence level of the top constructor
22:23:57 <wy> sorear: Ah!! Maybe I should strip EVar and only put the Strings into the table
22:24:07 <sorear> so 3 * 5 has precedence 5
22:24:07 <sorear> ?
22:24:24 <sorear> wy: that would probably work
22:25:08 <sorear> wy: also note that maps can only be finite, so if you need precedences for an infinite number of expr's a map is definitely wrong
22:25:10 <wy> sorear: yeah! This works.
22:26:26 <wy> sorear: This is just a chance that I only need to make the strings work. But if somehow I need to give every Expr an attribute, how can I put them into a map? Can I use hashtables?
22:27:24 <sorear> *every* expr? As in an infinite number of assocs?
22:27:55 <dino-> Is Data.Map backed by a hash?
22:28:05 <sorear> btw, you generally don't want HashTables
22:28:06 <sorear> dino-: no
22:28:27 <dino-> I see, so not the quickest retrieval.
22:28:36 <sorear> no method of implementing hashtables is known to be simulataneously fast and pure
22:28:56 <sorear> you can make a fast pure hashtable for lookups, but it would be O(n) update
22:29:24 <sorear> dino-: Data.Map uses self balancing binary search trees
22:29:27 <wy> sorear: Some Expr contains strings, some contains numbers, some contains other objects. How can I put them in?
22:29:35 <sorear> (not to be confused with btrees!)
22:29:39 <wy> they can't be said to have a total order
22:29:58 <sorear> wy: are you sure your map will only need a finite number of them?
22:30:02 <dino-> I see.
22:30:18 <rashakil> wy: you can't invent some contrived order?
22:30:46 <sorear> wy: it doesn't matter what the order is, as long as there is one Data.Map will work fine
22:30:54 <wy> rashakil: but that will take me some extra code
22:31:04 <rashakil> it's not 'extra' if you need to do it :)
22:31:09 <sorear> wy: nah, just add deriving(Ord,Eq)
22:31:21 <sorear> wy: then the compiler will invent an order for you
22:31:29 <wy> sorear: I tried this just now and it didn't work
22:31:41 <sorear> wy: note that this won't work if your structure contains functions
22:32:10 <sorear> wy: if you reference another user-defined structure, you will need to add derivings to the others probably
22:32:17 * sorear washes sorear's mouth
22:33:51 <wy> sorear: It's not very economical to modify all the related code just for some order
22:34:46 <sorear> well, haskell needs some way to tell your values apart
22:35:41 <rashakil> if you can have Eq for your keys, you can probably contrive some kind of Ord.
22:36:27 <wy> Maybe that's better way theorectically
22:37:16 <sieni> Hmm... could one do a DiffHashTable the same way as a DiffArray
22:37:46 <wy> sorear: in GHC.List there is a lookup. What's the difference between this one?
22:38:30 <sorear> wy: GHC.List.lookup == Prelude.lookup
22:38:44 <sorear> wy: but ghc doesn't correctly implement recursive modules
22:38:58 <sorear> wy: so they had to fudge the definition locations
22:39:09 <sorear> wy: and it still requires a class (Eq here)
22:39:19 <sorear> wy: and it's VASTLY slower
22:39:41 <wy> Is the one in Map using balanced trees?
22:39:44 <sorear> yeah
22:40:13 <sorear> GHC.List.lookup == Prelude.lookup == Data.List.lookup uses linear search
22:40:19 <sorear> O(n) v. O(log n)
22:40:31 <ddarius> assoc
22:40:54 <sorear> :t assoc -- huh?
22:40:57 <lambdabot> Not in scope: `assoc'
22:41:00 <sorear> ?hoogle assoc
22:41:01 <lambdabot> Control.Parallel.Strategies.Assoc :: data Assoc a b
22:41:02 <lambdabot> Text.ParserCombinators.Parsec.Expr.Assoc :: data Assoc
22:41:02 <lambdabot> Array.assocs :: Ix a => Array a b -> [(a, b)]
22:41:07 <sorear> ?hoogle+
22:41:07 <lambdabot> Data.Array.assocs :: Ix i => Array i e -> [(i, e)]
22:41:08 <lambdabot> Data.IntMap.assocs :: IntMap a -> [(Key, a)]
22:41:08 <lambdabot> Data.Map.assocs :: Map k a -> [(k, a)]
22:41:09 <sorear> ?hoogle+
22:41:10 <lambdabot> Data.Array.IArray.assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
22:41:10 <lambdabot> Text.ParserCombinators.Parsec.Expr.AssocLeft :: Assoc
22:41:10 <lambdabot> Text.ParserCombinators.Parsec.Expr.AssocNone :: Assoc
22:42:19 <sorear> @seen waern
22:42:20 <lambdabot> I saw waern leaving #haskell 1d 3h 58m 31s ago, and .
22:43:35 <ddarius> assoc is lookup in CL if I remember correctly
22:44:16 <sorear> *sigh* somehow I'd the impression CL used uppercase, glad I was wrong :)
22:44:45 <ddarius> CL is case insensitive (or rather it doesn't specify that, again if I remember correctly)
22:44:53 * sorear IS NOT A BIG FAN OF UPPERCASE ONLY PROGRAMMING LANGUAGES
22:45:42 <dolio_> Like Intercal?
22:45:43 <sorear> ANS FORTH ANYONE P
22:46:04 <wy> It seems Haskell lacks some support. I still feel I can't do all the things with it. For example to create something like Photoshop.
22:46:05 <dolio_> Or INTERCAL, I guess.
22:46:06 <sorear> IIRC even intercal is case-insensitive.
22:46:27 <dufflebunk> gwbasic
22:46:29 <sorear> No, I think that's mostly a capital issue.
22:46:31 <dmwit> wy: You feel you could create Photoshop in another language?
22:46:50 <sorear> If you could clone photoshop all by yourself I would have heard of you already.
22:47:01 <sorear> Now, I invoke the law of the contrapositive.
22:47:25 <dmwit> heh
22:47:40 <wy> dmwit: Which language did they use to create photoshop?
22:47:54 <dmwit> sorear: You're missing the warrant; you need to say, "I haven't heard of you."
22:48:09 <dolio> It's probably C.
22:48:10 <dmwit> wy: Is that relevant?
22:48:10 <sorear> @all-dicts warrant
22:48:13 <lambdabot> *** "Warrant" gcide "The Collaborative International Dictionary of English v.0.48"
22:48:13 <lambdabot> Warrant \War"rant\, v. t. [imp. & p. p. {Warranted}; p. pr. &
22:48:13 <lambdabot>    vb. n. {Warranting}.] [OE. waranten, OF. warantir, garantir,
22:48:13 <lambdabot>    guarantir, garentir, garandir, F. garantir to warrant, fr.
22:48:13 <lambdabot>    OF. warant, garant, guarant, a warrant, a protector, a
22:48:15 <lambdabot> [300 @more lines]
22:48:24 <sorear>  ... @more? :)
22:48:50 <dolio> Or C++, maybe.
22:48:56 <dmwit> sorear: It's the "hidden assumption" of any given argument.
22:49:04 <dmwit> As soon as you say it, it is no longer a warrant. =)
22:50:02 <sorear> Nah, I think I'll leave it unstated and invoke modus inferens instead :)
22:50:03 <wy> dolio: It seems that just because of support. C and C++ have more large corporations' support and they put money to hire people. So although they suck, a lot of people can only use them just because of the libraries.
22:50:50 <sorear> dmwit: Did you get my "Nah ..."?
22:50:57 <dmwit> sorear: Nope.
22:50:59 <sorear> Nah, I think I'll leave it unstated and invoke modus inferens instead :)
22:51:04 <dmwit> =)
22:51:36 <wy> I got your Nah
22:51:47 <sorear> wy: you didn't leave, dmwit did
22:51:54 <sorear> *** dmwit (n=dmwit@buckwheat.Stanford.EDU) has left channel #haskell: "Leaving"
22:52:16 <dmwit> Sometimes my Ctrl-W goes here instead of Firefox by mistake. =P
22:52:46 <sorear> My web browser closes tabs with cy
22:52:55 <sorear> My irc client uses C-x k RET
22:52:55 <wy> What's buckwheat? dmwit
22:53:06 <sorear> stanford! :)
22:53:15 <sorear> there's something to be said for incompatible interfaces :)
22:53:23 <dmwit> yah
22:53:26 <sorear> inconsistent, even
22:53:29 <dmwit> wy: just the name of my computer.
22:53:48 <dmwit> Gonna hack me now?
22:53:59 * sorear <3 hacking
22:53:59 <wy> good we got another college student. You are lucky to have a real name.
22:54:18 <sorear> dmwit: hack may be a transitive noun, but it doesn't apply to people
22:54:30 <sorear> dmwit: here, it only applies to projects
22:54:41 <sorear> dmwit: or it can be used intransitively
22:54:44 <wy> sorear: yeah I've put the code into precedence tables. It's much nicer now.
22:54:44 <dmwit> You're right, I should have said:
22:54:53 <sorear> dmwit: in which case it is an unspecified project.
22:55:06 <dmwit> "j00 g01|\|g to h4xx0rz m3 n0\/\/?"
22:55:22 <sorear> dmwit: teh bot can help you
22:55:31 <dmwit> ?elite You going to hack me now?
22:55:32 <sorear> @elite you going to hack me now?
22:55:32 <lambdabot> YOu GOiNg +O H4(K /\/\e NOW?
22:55:33 <lambdabot> YOu goInG TO HAxx Me n0w?
22:55:38 <dmwit> yay!
22:55:56 <dmwit> It's more fun doing it by hand.
22:56:05 <wy> @elite you going to hack me now?
22:56:05 <lambdabot> YOu 9oInG T0 |-|Ack M3 NO\/\/?
22:56:19 <wy> haha! This is fun
22:56:33 <dmwit> ?. elite quote
22:56:33 <lambdabot> L0ganCapalDo 5Ay5: <sOR34R> I am Not |-|a\/In9 4nY LuCk ConVEr7IN9 c|-|Ri$ KUx1e\/\/ICZ :( <10GaNC4p4ldo> dO3z |-|3 iMpLem3N+ 7yp34B1E?
22:56:53 <ddarius> Does anyone actually still talk this way? did any group ever really?
22:57:09 <dmwit> ddarius: I don't know, and yes.
22:57:39 <sieni> ?. elite elite this might be dun
22:57:39 <lambdabot> ThiZ /\/\IG|-|+ 83 DUN
22:57:43 <sieni> ?
22:58:06 <sieni> or then again, not
22:58:12 <dmwit> sieni: As all the conversions tend to punctuation and numbers, less transformations tend to happen.
22:58:32 <dmead> #haskell
22:58:32 <dmead> :P
22:58:35 <ddarius> ?fix elite A sentence
22:58:36 <lambdabot> Maybe you meant: faq ft id
22:59:28 <gmh33> ?. elite elite face melting guitar solo!
22:59:28 <lambdabot> ph4C3 /\/\317IN9 9ui+4r $O|0!
22:59:32 <gmh33> heheh
22:59:57 <dmwit> ?. elite . elite . elite elite face melting guitar solo!
22:59:58 <lambdabot> F4c3 /\/\3L+in9 9uI74R 5010!
23:00:18 <dmwit> I think the government should use this as an encryption technique.
23:00:37 <dufflebunk> What, one way hashes?
23:01:10 <dmwit> They could hire "leet-speakers" on the other end to decrypt...
23:01:17 <wy> Is there a program to decode this?
23:01:36 <sorear> @remember dmwit [on leetspeek] I think the government should use this as an encryption technique.
23:01:37 <lambdabot> Done.
23:01:58 <wy> or is there a function in the bot to reverse this thing?
23:02:30 <dmwit> wy: It's impossible without the encryption key.
23:03:16 <wy> haha
23:04:02 <wy> It seems every symbol has only one corresponding letter
23:04:21 * ddarius can take limits of forgetful functors in his head.
23:04:57 * sorear can take FIXPOINTS of forgetful functors in his head!
23:05:08 <dufflebunk> wy: V -> \/, W -> \/\/ -> VV
23:05:29 <sorear> @. elite elite VW
23:05:30 <lambdabot> V\/\/
23:05:32 <sorear> @. elite elite VW
23:05:32 <lambdabot> \/w
23:05:40 <sorear> @. elite . elite elite VW
23:05:41 <lambdabot> V\/\/
23:05:46 <sorear> @. elite . elite . elite elite VW
23:05:47 <lambdabot> Vw
23:05:49 <sorear> @. elite . elite . elite elite VW
23:05:50 <lambdabot> \/\/\/
23:06:48 <sorear> ... why does TH have to come with a worthless ppr?
23:08:27 <wy> sorear:  is import Data.Map (Map) and import qualified Data.Map as Map both necessary?
23:08:57 <sorear> wy: no, the docs are quite different from actual usage
23:09:14 <sorear> wy: normally people just do "import qualified Data.Map as M"
23:09:34 <wy> what if I use both?
23:09:46 <bd_> Then you can access the Map type as either Map or Map.Map
23:11:26 <wy> sorear: I see. The first line imported the datatype Map. But the rest of Data.Map is qualified under Map. right?
23:11:41 <sorear> right!
23:13:20 <ddarius> > (Prelude.+ 1) Prelude.. (Prelude.* 2) Prelude.$ 4
23:13:22 <lambdabot>  9
23:13:31 <ddarius> Yay qualified operators.
23:13:37 <sorear> Just don't try Prelude.( :)
23:14:04 * sorear likes haskell's qop syntax, oddly enough
23:14:15 <dcoutts> @type (Prelude.:)
23:14:18 <lambdabot> Not in scope: data constructor `Prelude.:'
23:14:22 <dcoutts> :-(
23:14:58 <dmwit> > 3 Prelude.: []
23:14:59 <lambdabot>   Not in scope: data constructor `Prelude.:'
23:15:08 <dmwit> oh, builtin
23:16:02 <sorear> dcoutts: that's not a qconop, that's a reservedop that happens to behave like an ADT constr in every way
23:16:19 <dcoutts> sorear: yeah I know, it's upsetting
23:24:44 <dmwit> "For instance, the Grub boot menu in NixOS allows the user to boot into any previous system configuration that hasn’t been garbage collected yet."
23:24:46 <dmwit> What.
23:25:20 <dcoutts> NixOs is a unix/linux OS that uses Nix for package management
23:25:21 <sorear> yay, sounds fun.
23:25:35 <sorear> But what if I want to use a RC operation other than unpull?
23:25:37 <dmwit> ...garbage collected boot options?
23:25:53 <sorear> dmwit: sounds more like weak pointers
23:25:55 <dcoutts> Nix can keep multiple copies of packages around and manage multiple configurations/environments
23:26:11 <dcoutts> it GC's packages when you ask it to
23:26:27 <dcoutts> which means it looks at all the active configurations and finds packages that are used by none of them
23:26:43 <dmwit> Actually, that sounds pretty nice.
23:26:52 <sorear> Is nix related to nnix? :p
23:27:55 <sorear> @users
23:27:56 <lambdabot> Maximum users seen in #haskell: 337, currently: 290 (86.1%), active: 23 (7.9%)
23:28:14 <dmwit> Friday night, low activity.
23:30:15 <siti> it's saturday here :p
23:30:27 <ddarius> "Consider a comfortable leather armchair C."
23:30:38 <abz> Best night of the week for hacking?
23:31:08 <shachaf> How usable is NixOS as a desktop, so far?
23:31:36 <shachaf> I downloaded an ISO earlier today but am hesitant to try it.
23:31:56 <siti> put it in vmware then!
23:32:18 <dcoutts> shachaf: or use a chroot
23:32:37 <shachaf> siti, dcoutts: I could do that.
23:33:12 * shachaf realizes he has an unused 10GB partition set aside for such purposes.
23:36:57 * sorear cleans up and cabalizes daan-pp
23:45:11 <sorear> Show of hands:
23:45:31 <sorear> Who would be interested in a prettyprinting lib supporting proportional fonts?
23:46:32 <jcreigh> how would that even work?
23:47:12 <sorear> It knows character widths by asking the output function?
23:48:05 <sorear> Yay, I'm back at #2
23:48:08 <sorear> by 42 lines
23:48:31 <dcoutts> sorear: you can't take a span of text and measure its length by summing the lengths of the component chars
23:48:46 <dcoutts> you have to ask the output function for each span you want to output
23:49:05 <jcreigh> oh, due to kerning? (if that's the right term...)
23:49:09 <dcoutts> due to kerning, ligatures and other more funky stuff in other languages
23:49:34 <dcoutts> combining characters and probably more exotic things in other languages
23:49:43 <sorear> Of course, I'll also need to find a way to handle non-horizontal fonts :)
23:50:09 <sorear> ... long piece of haskell code {- one line Chinese comment -} ...
23:50:17 <sorear> how should that lay out?
23:50:22 <dcoutts> sorear: check the pango docs, this stuff is rather tricky to do in full generality
23:51:11 <sorear> dcoutts: ok.  (this is a HughesPJ tpye thing)
23:51:42 <dcoutts> sorear: actually vertical layout should be easy in a HughesPJ setting
23:51:53 <dcoutts> they already have combinators for similar things
23:52:23 <dcoutts> but you might want the output of the pretty printer to be more of a block model thing
23:52:38 <dcoutts> rather than a string with '\n's in it
23:52:52 <sorear> right, yeah
23:53:01 <dcoutts> then you can render the block output directly on some surface using pango
23:53:11 <sorear> This is looking a Bit Too Hard For Right Now.
23:53:16 <dcoutts> :-)
23:53:24 <ddarius> TeX
23:53:26 <sorear> I'll just fix any obvious anachronisms and release.
23:53:35 <sorear> archaisms?
23:53:54 <dcoutts> sorear: now now don't be rude about TeX ;-)
23:54:06 <sorear> anyway, I'm cleaning up JohnMeacham's implementations of Daan's pretty printer
23:54:19 <sorear> it is a *lot* nicer on the inside
23:54:42 <sorear> fewer comments of "I've been trying to track down such-and-such-crash-bug for years"
23:54:47 <sorear> (than HughesPJ)
23:55:02 <sorear> actually satisfies its invariants (a plus over HughesPJ)
23:55:33 <sorear> > replicate (-1) ' '
23:55:35 <lambdabot>  ""
23:58:26 <wy> Did Haskell learn the way to parse in layout from Python?
23:58:34 <dcoutts> heh, no.
23:58:36 <jcreigh> wy: I don't think so
23:58:51 <jcreigh> does Haskell predate Python?
23:58:51 <sorear> Haskell is older than python iirc
23:58:55 <jcreigh> oh, okay
23:59:05 <sorear> but it's independent
23:59:07 <dcoutts> wy: it's from the way computer scientists and mathematicians write mathematics and code on paper
23:59:44 <wy> The first time I saw this kind of formatting is in Python. So I guessed. Maybe I was wrong.
23:59:45 <sorear> Haskell derives from Landin's offside rule, which was in one of the early lazy fpls (KRC era, not sure which specifically)
