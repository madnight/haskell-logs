00:00:53 <wy> I don't accually like this. That's why I don't like Python.
00:01:33 <dufflebunk> wy: you can use squiggly brackets and semi-colons if you want
00:02:38 <wy> But as long as semi-colons are not enforced, I have to sacrifice automatic indentation from any editor
00:03:07 <jcreigh> wy: hmm? I don't quite get your meaning.
00:03:29 <wy> I can't indent the lines automatically to the correct position
00:04:37 <wy> and the editor's ability to navigating according to blocks is disabled because of this.
00:05:01 <jcreigh> "the editor"?
00:05:25 <wy> unless there is an intelligent editor which really knows the language's grammar, this can't be done.
00:05:58 <wy> No. I was wrong. There can't be any editor that can do this.
00:06:13 <foxy> dcoutts: I get an error trying to apply patch 107 of c2hs (I've had this happen before, it's to do with a capitalisation inconsistency under windoze)
00:06:28 <wy> jcreigh: I just mean any editor
00:06:45 <dcoutts> foxy: I'm not sure how to fix it, does using get --partial help ?
00:07:05 <foxy> dcoutts, that's what I did
00:07:48 <foxy> dcoutts, does the latest release of c2hs include the '_attribute_' fix?
00:07:49 <wy> For any editor, doing automatic indentation = read our mind.
00:08:20 <dcoutts> foxy: no, only the darcs version
00:08:38 <jcreigh> wy: right. it would be like trying to make an editor that automatically knows where to insert curly braces in, eg, C.
00:09:05 <foxy> dcoutts, How can I get a copy of the current repository working around this problem?
00:10:17 <dcoutts> foxy: scp if you've got a darcs.h.o account or get someone to make a tarball
00:10:24 <wy> jcreigh: I think that's too big a sacrifice just to save several curly braces.
00:10:52 <dcoutts> foxy: gimme a sec I'll make a tarball
00:11:54 <wy> With curly braces, we just need to push { and } for each block. Now without them, we have to push the tab button several times for each line in an indented block.
00:12:21 <jcreigh> wy: what? You have to do that? Your editor sucks!
00:13:10 <wy> You agreed to me that no editor can save us from this
00:13:22 <jcreigh> wy: vim has an "autoindent" option (and emacs has something similar, I'm sure) to continue indentation at the same level as the previous line.
00:13:50 <jcreigh> so I have to tab in *once* to start in indented block, and backspace *once* to get out of it.
00:13:57 <dcoutts> foxy-om: http://haskell.org/~duncan/c2hs/c2hs-newparser.tar.gz
00:14:00 <jcreigh> I don't have to do anything per line.
00:14:09 <dcoutts> foxy-om: oh wait, wrong .tar.gz
00:14:17 <dcoutts> http://haskell.org/~duncan/c2hs/c2hs-snapshot-31-3-07.tar.gz
00:14:22 <dcoutts> foxy-om: that's the one ^^
00:14:42 <Cheery> I never use autoindent when writing haskell
00:15:00 <Cheery> It's few indented lines just do not require such apparatus. :)
00:15:43 <sorear> Haskell code is so short I don't spend a lot of time typing it from scratch.
00:16:08 <sorear> Much better to have a decent editor like emacs/vim that can rearrange indented text that already exists.
00:16:13 <Cheery> and you do not type it like thousand lines indented
00:16:58 <wy> sorear: you mean square operations?
00:17:11 <sorear> wy:no
00:17:22 <sorear> wy: vim calls what I mean block reindent ops
00:17:31 <sorear> wy: emacs calls it rectangle ops
00:17:56 <sorear> V< , C-x r d
00:18:20 <wy> But I still like curly braces :(
00:18:32 <sorear> you can still use them
00:18:39 <dufflebunk> wy: Why?
00:18:43 <foof> sieve (x:xs) = x : (sieve (filter (\y -> not (mod y x==0)) xs))
00:18:45 <foof> main = putStrLn (show (sum (takeWhile (< 1000000) (sieve [2..]))))
00:18:59 <dufflebunk> wy: that's not a sarcastic question, It's a serious question.
00:19:02 <sorear> do we scream TSP IS AN IDIOT! when he refuses to use layout?
00:19:04 <foof> 57 minutes to compute the sum of all primes < 1 million
00:19:07 <sorear> no, we don't.
00:19:15 <sorear> we let him have his braces.
00:19:49 <wy> because with curly braces, I can be confident that my program won't be ruined if the format changes. Now I can't.
00:19:50 <foof> vs. 0.2 seconds using an explicit vector-based sieve in Scheme
00:19:53 <foxy-om> dcoutts, thanks
00:20:21 <sorear> foof: try a linked list sieve in scheme, tell us how fast it is
00:20:32 <foof> how could I make the above faster in haskell?
00:20:38 <sorear> and you did use -O2, right?
00:20:46 <foof> no, -O
00:20:55 <dcoutts> list fusion :-)
00:21:09 <sorear> won't work here.
00:21:14 <dcoutts> wy: I normally find it's the other way around, people get the indenting right but the { .. } wrong
00:21:31 <dcoutts> sorear: because the list is actually being used as a data structure ?
00:21:31 <Cheery> wy: do { a ; b ; c }
00:21:32 <foof> (well, more comparable would be a stream in scheme)
00:21:34 <sorear> foof: I'd suggest using vectors in haskell.
00:21:53 <sorear> foof: that is, UArray Int Bool
00:22:03 <sorear> I mean STUArray
00:22:30 <foof> ah, OK, I'll check that out
00:22:32 <foof> thanks
00:22:57 <sorear> that will make the code use 96 times less ram
00:23:05 <sorear> and cache effects being what they are,
00:23:10 <sorear> it'll be faster to boot
00:27:27 <foxy-om> my ghc is in my PATH variable but cabal 'runhaskell Setup.hs' is reporting that it can't find ghc.  Any clues?
00:38:37 <dcoutts> foxy-om: how about runghc is that in the path?
00:39:07 <foxy-om> yup
00:39:49 <tsp> anyone have a good state tutorial?
00:41:23 <lazist> hello, can anyone tell me how to express 'arbitrary ascii character' in regular expression, Text.Regex seems not to support [:print:]
00:41:46 <foxy-om> dcoutts: I think I needed to run autoconf, which crashed sh.exe a few time but seems to have fixed the problem
00:55:15 <matthew-_> lazist: use a char range? [0x00-0x7F] ?
00:55:53 <lazist> matthew i have tried that , but still does not work
00:56:16 <lazist> matthew: thx
00:58:27 <foxy-om> dcoutts: c2hs is still barfing on '__attribute__', I recall having seen a post to the mailing list which was supposed to have fixed this?
00:59:17 <dcoutts> foxy-om: the latest darcs c2hs is supposed to totally ignore all __attribute__ tokens in the lexer
00:59:22 <dcoutts> do you have an example ?
00:59:32 <dcoutts> an example of what's failing for you
00:59:37 <foxy-om> yup
01:01:48 <foxy-om> dcoutts: include/float.h line 125 in mingw include files
01:02:32 <dcoutts> foxy-om: I'll need the pre-processed version of that since I don't have that file
01:30:17 <triple_> gee, when the ghc README says 'it can take a long time' ...they really mean it :o
01:33:18 <dcoutts> triple_: we can build a full ghc in about 6min on a 16-way opteron box :-)
01:35:48 <triple_> what about a p3 1ghz 128mb ram compaq? :(
01:55:03 <dcoutts> triple_: 2 hours maybe ?
01:56:11 <Cheery> stepcut: what do you think about those sources?
02:19:05 <triple_> dcoutts: 3 :)
02:19:15 <dcoutts> heh :-)
02:19:45 <dcoutts> triple_: I can assure you it takes longer on my 500MHz sparc :-)
02:20:21 <dcoutts> more like 8
02:22:09 <triple_> hehe damn :/
02:23:34 <dcoutts> foxy-om: it works for me, are you absolutely sure you're using the darcs version of c2hs ?
02:29:01 <un-brice> hello world !
03:01:53 <ndm> @seen augustuss
03:01:53 <lambdabot> I haven't seen augustuss.
03:02:03 <ndm> @seen augustss
03:02:03 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
03:09:26 <ndm> @seen sorear
03:09:27 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc and #haskell 1h 45m 5s ago, and .
03:22:00 * araujo jumps !
03:24:24 * foof hops !
03:44:39 <laziest> anybody: How advisable is C preprocessing (-cpp) supposed to be?
03:47:23 <laziest> are there any alternative ways for conditional compiling?
03:47:44 <ndm> laziest, a runtime test can be done
03:47:50 <ndm> laziest, what do you want to conditional on?
03:47:57 <ndm> cpp is often used, but try and avoid it if you can
03:48:26 <laziest> basically for a certain optimal performance, I need an instance of Ix class in a certain way
03:48:39 <laziest> but it violates the 'laws' of the Ix class mentioned in the standard
03:49:00 <laziest> so I want to generalize this instantiation with the parameter 'safe' and 'unsafe'
03:49:23 <ndm> hmm, don't understand
03:49:31 <ndm> explain a bit more
03:49:37 <laziest> ya sure.
03:49:45 <laziest> I am deriving an instance of Ix for lists
03:49:50 <ndm> are you saying you have one instantiation and it comes accross twice?
03:49:56 <ndm> yep
03:50:11 <laziest> not in the same program ofcourse, but I want to generalize the module.
03:50:14 <laziest> coming back
03:50:31 <laziest> now, ideally the bounds and the index lists should be of the same size
03:50:57 <laziest> but for my case I want to index using slices of bigger lists
03:50:58 <ndm> yes
03:51:28 <laziest> so for using a slice, I will have to create a slice if I am strict about the size of the index
03:51:47 <laziest> but if i relax that and only use the first part of the list (== length of bounds)
03:51:57 <laziest> then I don't have to create new lists just for indexing
03:52:29 <laziest> but then if I allow larger lists (and ignore the tails after the length of bounds)
03:52:43 <ndm> hmm, not sure why you then want a safe and unsafe variant, if you're always going to use the unsafe one for performance
03:52:46 <laziest> the 'laws' of the Ix class are violated in a certain way
03:53:01 <laziest> well, if later I encounter another problem
03:53:07 <laziest> which requires list indexing
03:53:13 <laziest> inwhich performance is not an issue
03:53:22 <laziest> I would be happy to use the one obeying the laws
03:53:42 <ndm> i'd just define teh unsafe one, and be happy if it works
03:53:47 <laziest> so I would like a module to compile in two different ways depending upon the problem.
03:53:53 <laziest> hmmm...
03:54:01 <ndm> thats very likely to go wrong in some unforseen way
03:54:13 <ndm> it can be done, but is very risky
03:54:26 <laziest> you mean conditional compilation?
03:55:13 <laziest> you mean conditional compilation being risky? or violating the laws?
03:59:22 <laziest> ndm: are you still there?
04:00:17 <ndm> laziest, just had to get some food
04:00:34 <ndm> laziest, conditional compilation is not that bad, having a module change its function based on who uses it is
04:00:43 <laziest> oh..
04:00:51 <laziest> I got the point.
04:01:05 <ndm> do you really want to do the Ix class?
04:01:11 <ndm> what are you using Ix for?
04:01:25 <ndm> you could perhaps define your own class, which is similar to Ix but has your laws
04:01:32 <ndm> then the standard Ix could remain true
04:01:38 <laziest> Oh yes, I am analysing n-mers in DNA sequences
04:01:51 <laziest> I need arrays, so I need instance of Ix class
04:01:58 <ndm> ah, fair enough, no way round that
04:02:19 <ndm> its also best if one program has only one instance of a class per type - classes in Haskell are not scoped in ways that they could be
04:02:57 <laziest> In fact, currently I have the the instance written and tested on the interpreter ready. It is currently the safe version.
04:03:12 <laziest> Modifying it to the one I want is just a change of 6 characters.
04:03:21 <laziest> (as is typical in Haskell :))
04:03:32 <ndm> laziest, can you post the slow and the fast one to the paste bot?
04:03:42 <ndm> that might show if there is a way round the problem
04:03:57 <laziest> ya I can
04:04:08 <laziest> I have not tested it yet for performance
04:04:14 <laziest> but I am sure it will have those problems,
04:04:36 <laziest> since a friend of mine who has written that program in python runs for about half an hour for a particular data set
04:04:54 <ndm> always profile before saying something is a performance bottle neck
04:04:59 <laziest> ya pasting the safe version. I am updating it to unsafe soon.
04:05:23 <ndm> i wrote a program last week that spent 55% of its time calculating a heuristic, removing the  heuristic sped it up massively
04:05:46 <laziest> I know that, but indexing is going to occur on every seven-mer of 1000 sequences of each length 10000. (or similar)
04:06:03 <laziest> Infact I had a serious problem in my friends python program on a similar issue.
04:06:11 <ndm> yeah, you are likely to be right
04:06:21 <laziest> so, pasting.
04:06:24 <ndm> you can always use unsafeAt, if you need array speed
04:06:40 <ndm> that is likely to remove teh depenence on the Ix class mostly
04:06:54 <laziest> ah!. ok. Will check that.
04:07:05 <laziest> ?paste
04:07:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:08:14 <hpaste>  laziest pasted "Lists as instances of Ix class" at http://hpaste.org/1205
04:08:16 <ndm> if you need high array performance, the things to check are unboxed arrays and unsafeAt
04:08:44 <laziest> Yes. I was aware of unboxed arrays.
04:09:37 <ndm> i'd just always use the optimised one, and write a comment that you don't obey Ix
04:09:55 <ndm> the other alternative is to newtype it
04:10:06 <ndm> newtype UnsafeIx a = UnsafeIx [a]
04:10:17 <ndm> then define instance Ix (UnsafeIx a)
04:10:40 <ndm> that way you are more explicitly stating the unsafeness in the code, and can still write a safe instance
04:10:44 <laziest> So this will give a visual hint that it's unsafe
04:10:50 <ndm> yes
04:10:55 <ndm> and allow the safe variant to be the default
04:11:42 <laziest> Great! Thanks!! Getting back to work now...
04:14:17 <hpaste>  lizhn pasted "How can i split a string into several substrings which each one begins with "@\t*\n"  ?" at http://hpaste.org/1206
04:17:17 <diffbavis> > threadDelay (10^10)
04:17:18 <lambdabot>   Not in scope: `threadDelay'
04:18:33 <hpaste>  (anonymous) annotated "How can i split a string into several substrings which each one begins with "@\t*\n"  ?" with "(no title)" at http://hpaste.org/1206#a1
04:22:14 <Cale> Who is lizhn?
04:27:44 <desp> http://www.xach.com/misc/lambda.html
04:27:53 <desp> OBEY
04:37:50 <lazist> i am
04:38:36 <lizhn> i am
04:39:00 <sebastienb> yes you are
04:40:43 <Cale> I think you're using \1 in a very strange way there.
04:41:13 <lizhn> Cale: it is
04:41:15 <Cale> Isn't \1 only used in substitutions?
04:41:24 <lizhn> Cale: yes
04:41:57 <Cale> Personally, I'd probably not use a regex for that.
04:42:21 <lizhn> Cale: how can i express arbitrary character other than that?
04:42:39 <Cale> use lines to break the string into lines, and then break up that list of lines by those which start with an @ and are followed by some tab characters (which is an easy test to write)
04:42:52 <Cale> . means an arbitrary character in a regular expression
04:43:13 <Cale> Your problem though is going to be that this regex is too greedy.
04:43:24 <Cale> and everything will end up in a single match
04:43:25 <lizhn> Cale: but .* can not mean arbitrary long char
04:43:33 <Cale> huh?
04:43:43 <Botje> . doesn't match \n by default
04:43:52 <Cale> ah, right
04:44:12 <lizhn> but the paragraph may be cross more than one line
04:45:15 <lizhn> sorry , i misss the above
04:47:22 <lizhn> i'll try your suggestion, thx :)
05:04:41 <hpaste>  Cale annotated "How can i split a string into several substrings which each one begins with "@\t*\n"  ?" with "one direct way to do it" at http://hpaste.org/1206#a2
05:06:30 <LeCamarade> @seen Igloo
05:06:31 <lambdabot> Igloo is in #haskell-soc, #haskell, #darcs, #ghc, #gentoo-haskell and #haskell.hac07. I last heard Igloo speak 12h 50m 14s ago.
05:07:22 <Igloo> Yes?
05:33:34 <hpaste>  Saizan annotated "How can i split a string into several substrings which each one begins with "@\t*\n"  ?" with "with parsec" at http://hpaste.org/1206#a3
05:33:58 * dcoutts hacks away on ghc's list comp desugaring
05:36:08 <Botje> I had an idea for making pattern matching into real unification, but the GHC sources scare me.
05:36:31 <dcoutts> the simplifier is indeed a work of wonder
05:36:44 <dcoutts> Botje: the RULE matching is fairly simple though
05:37:48 <Botje> is there a good reason for not doing "real" unification? it doesn't seem like lots of extra work
05:38:32 <dcoutts> Botje: I'm not sure I understand what that means exactly
05:38:37 <dcoutts> give me an example
05:39:17 <Botje> I saw an example the other day
05:39:24 <Botje> f a b a' | a == a' = ...
05:39:50 <ndm> Botje, look at Curry, its entirely different semantics because it uses unification
05:40:08 <ndm> Botje, plus the reason that is a bad idea is that usually its not what the person wanted, but was a typo!
05:40:32 <ndm> i've seen some totally crazy extensions to pattern matching,  most are a really bad idea, but the inventor always sees tehm as natural and intuative
05:40:32 <Botje> hmm.
05:40:48 <ndm> what you really want is Eq side conditions, not unification
05:40:51 <Botje> I guess they fall in the same cathegory as n+k patterns, then
05:41:06 <ndm> which are occasionally useful, but not verbose
05:41:09 <dcoutts> also it means that values have some kind of intrinsic identity beyond what some == function says
05:41:18 <ndm> yes, n+k patterns were a bad idea
05:41:20 <dcoutts> which is very non-haskell
05:42:06 <dcoutts> Botje: I mean it doesn't sit well with abstract types for example
05:42:12 <jacobian> it makes a bit of sense in SML though
05:42:44 <jacobian> since equality types are basic
05:43:05 <ndm> just make sure you don't refer to it as unification :)
05:43:21 <ndm> Yhc has unification as pattern matching in one evaluator, its neat, but very different
05:43:43 <jacobian> fun same (x,x) = true | same (x,y) = false
05:43:43 <ndm> you can do things like x - y = z, and once it figures out y and z, it binds x
05:44:00 <jacobian> resolution and unification aren't the same thing
05:44:15 <jacobian> I think that what botje is talking about can be called unification
05:45:14 <ndm> i don't, given i've seen what true unification is
05:45:24 <ndm> in the context of a functional language
05:46:41 <jacobian> if applicability of a case is decided by unification then you get exactly what Botje is talking about
05:47:23 <jacobian> Because there is some global notion of logic variables in a functional/logic programming language that you know of does not mean, that the pattern match is not "unification"
05:47:46 <jacobian> it in fact would use exactly a unification algorithm to decide what local variables to bind in a pattern math
05:47:49 <jacobian> s/math/match/
05:48:28 <jacobian> I think what dcoutts says is still applicable though
05:48:47 <araujo> morning!
05:49:03 <jacobian> But I also think that botje's idea might work fairly well in SML
05:49:35 <jacobian> where we could infer a type   ''a * ''a -> bool    from the same function written above
05:49:49 <jacobian> i.e. that the function could only be polymorphic over equality types
06:26:19 <Cheery> http://ask.slashdot.org/comments.pl?sid=228701&cid=18549429
06:26:21 <lambdabot> Title: What is the Best Bug-as-a-Feature?
06:32:36 <ndm> @seen sorear
06:32:36 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc and #haskell 5h 8m 14s ago, and .
06:33:29 <chessguy> ?vera AVL
06:33:31 <lambdabot> *** "avl" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
06:33:31 <lambdabot> AVL
06:33:31 <lambdabot>      Adelson, Veslkij and Laudis [tree]
06:33:31 <lambdabot>  
06:34:35 <chessguy> 'morning haskellers
06:38:51 <Botje> ?vera bogosort
06:38:54 <lambdabot> No match for "bogosort".
06:38:57 <Botje> boo :)
06:43:01 <chessguy> vera is for acronyms
06:43:12 <chessguy> ?all-dict bogosort
06:43:13 <lambdabot> *** "bogo-sort" jargon "Jargon File (4.3.1, 29 Jun 2001)"
06:43:14 <lambdabot> bogo-sort /boh`goh-sort'/ n. (var. `stupid-sort') The archetypical
06:43:14 <lambdabot>    perversely awful algorithm (as opposed to {bubble sort}, which is merely
06:43:14 <lambdabot>    the generic _bad_ algorithm). Bogo-sort is equivalent to repeatedly
06:43:14 <lambdabot>    throwing a deck of cards in the air, picking them up at random, and then
06:43:15 <lambdabot> [42 @more lines]
06:43:40 <chessguy> @more
06:43:42 <lambdabot>    testing whether they are in order. It serves as a sort of canonical
06:43:42 <lambdabot>    example of awfulness. Looking at a program and seeing a dumb algorithm,
06:43:42 <lambdabot>    one might say "Oh, I see, this program uses bogo-sort." Esp. appropriate
06:43:42 <lambdabot>    for algorithms with factorial or super-exponential running time in the
06:43:42 <lambdabot>    average case and probabilistically infinite worst-case running time.
06:43:42 <lambdabot> [37 @more lines]
06:43:50 <chessguy> lol
06:44:37 <chessguy> good description
06:45:47 <chessguy> @pl \m -> if (m .&. t) > 0 then W else B
06:45:47 <lambdabot> flip (flip if' W . (> 0) . (.&. t)) B
06:49:43 <chessguy> 'morning emk
07:10:56 <ndm> @seen dons
07:10:56 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 9h 31m 16s ago.
07:11:04 <ndm> dons, do you have any stats on XMonad use?
07:11:27 <ndm> sjanssen: same question to you ^
07:26:47 <tsp> :t flip
07:26:49 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:27:00 <tsp> um?
07:27:03 <tsp> that makes no sense
07:27:09 <tsp> > flip 1 2 3
07:27:10 <lambdabot>   add an instance declaration for (Num (a -> b -> c))
07:27:25 <tsp> > flip [1,2,3]
07:27:26 <lambdabot>  Couldn't match expected type `a -> b -> c'
07:27:30 <tsp> I thought that did
07:29:18 <diffbavis> > flip (-) 3 2
07:29:20 <lambdabot>  -1
07:29:27 <tuukkah> > flip (++) "abc" "def"
07:29:29 <lambdabot>  "defabc"
07:29:38 <chessguy> ?src flip
07:29:39 <lambdabot> flip f x y = f y x
07:30:52 <Botje> > sortBy compare [5,1,4,9,2,3,10,52]
07:30:54 <lambdabot>  [1,2,3,4,5,9,10,52]
07:30:57 <Botje> > sortBy (flip compare) [5,1,4,9,2,3,10,52]
07:30:59 <lambdabot>  [52,10,9,5,4,3,2,1]
07:32:48 <phoniq> wow
07:36:22 <jacobian> Anyone here from ireland?  If so, would it be hard to hire you to work on a web haskell project? (I'm not hiring, just curious)
07:36:59 <jacobian> s/from/in/
07:37:20 <chessguy> nice one Botje
07:53:08 <tsp> lets see what it makes of this
07:53:19 <tsp> > toUppercase "å"
07:53:20 <lambdabot>   Not in scope: `toUppercase'
07:53:26 <tsp> is there no uppercase function?
07:53:36 <tsp> of can you even put that wahtever it is in uppercase
07:53:44 <tsp> > "å"
07:53:44 <chessguy> > toUpper 'a'
07:53:46 <lambdabot>  "\229"
07:53:47 <lambdabot>  'A'
07:54:12 <chessguy> ?hoogle Char -> Char
07:54:13 <lambdabot> Char.toLower :: Char -> Char
07:54:13 <lambdabot> Char.toUpper :: Char -> Char
07:54:26 <tsp> > toUpper 'å'
07:54:26 <lambdabot>  Improperly terminated character constant
07:54:48 <tsp> weird
07:54:57 <tsp> > toUpper "å"
07:54:58 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
07:55:07 <tsp> I guess it wants nothing to do with that character
07:55:34 <chessguy> "å" is a String, not a Char
07:55:48 <chessguy> @type "å"
07:55:50 <lambdabot> [Char]
07:57:49 <tsp> ok, why doesn't it like this?
07:57:57 <tsp> > @type 'å'
07:57:58 <lambdabot>  Parse error
07:58:11 <tsp> that's still a char, if a little odd one
07:58:13 <chessguy> @type 'å'
07:58:15 <lambdabot> lexical error in string/character literal at character '\165'
07:58:36 <tsp> how did you get a different error? I typed the same thing
07:58:41 <wolverian> no, you didn't.
07:58:48 <tsp> or did my irc client screw it up
07:58:54 <wolverian> no.
07:58:58 <chessguy> @ is a different lambdabot command from >
07:59:08 <tsp> @type 'å'
07:59:10 <lambdabot> lexical error in string/character literal at character '\165'
07:59:17 <tsp> why is it giving me that error
07:59:26 <tsp> its still a char :)
07:59:31 <wolverian> I assume it doesn't like the encoding.
07:59:34 <chessguy> i guess it doesn't have unicode support
08:00:13 <chessguy> does your screen-reader read that character?
08:00:16 <tsp> I think its a swedish something or other
08:00:19 <tsp> it reads it as a
08:00:31 <tsp> so a, A and å sound the same
08:00:51 <tsp> but not ä - it reads the umloud
08:00:59 <chessguy> huh. it doesn't even distinguish capital letters?
08:01:05 <tsp> chessguy: it can if I want it to
08:01:11 <tsp> but can you imagine how annoying that would be
08:01:18 <chessguy> ok, that's what i thought
08:01:24 <tsp> if I read 'A' manually, it'll say it in a higher pitch
08:01:44 <chessguy> that makes sense
08:02:03 <chessguy> i wouldn't expect it to read Apples differently from apples
08:02:13 <chessguy> but i would expect a change if you were spelling the 2 words
08:02:42 <tsp> heh
08:02:54 <chessguy> that probably just sounded really strange :)
08:03:01 <tsp> nicely enough, it reads camelCase
08:03:04 <tsp> as seperate words
08:03:34 <tsp> unfortunately it has the side effect that you can type in certain phrases to crash the synthesizer, and the screen reader goes with it
08:03:54 <chessguy> heh. why?
08:03:57 <tsp> used to great effect on mailing lists, people send hundreds of messages complaining
08:04:08 <chessguy> why do certain phrases crash it, that is
08:04:08 <tsp> chessguy: its a bug in eloquence, the default synth that ships with jaws
08:04:16 <tsp> chessguy: eloquence bug :)
08:04:32 <chessguy> ah. a bug is different from a side effect :)
08:04:45 <tsp> the original word is caesure - it's not crashing my synth because FS made a patch
08:05:48 <chessguy> what windows are you on?
08:07:19 <chessguy> i heard FS worked closely with MS on jaws in Vista
08:08:43 <tsp> if you add an extra e to the end, it'll crash. same with h've and h're. I can add those two to my dictionary though
08:09:26 <tsp> the real kicker is that anything after the first word of a mixed case processing isn't ran through dictionary processing - so any lower-case leter or word, then start the crash word with an uppercase letter then poof!
08:09:53 <tsp> I"m on windows xp
08:09:57 <tsp> but ssh'ed into a bsd box
08:10:05 <chessguy> ah ok
08:10:09 <tsp> windows vista and jaws together are crap - fs dropped the ball
08:10:15 <chessguy> wow, really?
08:10:19 <tsp> window eyes and gw micro had a beta out right on the day of vista's release
08:10:34 <tsp> jaws was delayed a month or so, and doesn't support UAC
08:10:42 <tsp> which is one of the big things in vista
08:10:46 <chessguy> what's UAC?
08:10:50 <tsp> user account control
08:10:55 <tsp> chessguy: do you run vista?
08:10:57 <chessguy> no
08:11:14 <chessguy> fedora here
08:11:26 <tsp> chessguy: heh
08:11:52 <tsp> chessguy: basically its like a linux sudo or su - you'll be asked if your sure you want this program to run
08:11:57 <tsp> and it runs as admin
08:12:08 <chessguy> ah, ok
08:12:26 <tsp> at least in xp, people are so stupid that they'll run anything
08:12:34 <chessguy> hmm, my fiancee's talking about switching to vista. she's running the latest jaws on xp right now
08:12:41 <tsp> chessguy: ouch
08:12:46 <tsp> jaws itself is a piece of crap
08:12:53 <chessguy> well yeah
08:13:03 <tsp> it does a lot of things, most of which it does not do well
08:13:16 <chessguy> but it's the best thing out there
08:13:31 <tsp> and has too many commands - I think it has... lets see, 619 commands in the default keyboard map
08:13:36 <tsp> not all are defined though
08:13:46 <tsp> chessguy: jaws, window eyes, hal, and not NVDA
08:13:50 <tsp> s/not/now
08:13:55 <tsp> NVDA is open source, written in pytho
08:13:57 <tsp> s/$/n
08:14:09 <chessguy> yes, i've been lurking on the NVDA mailing list for a month or 2 now
08:14:30 <tsp> neat
08:14:37 <chessguy> i've heard window eyes is crap
08:14:42 <chessguy> not familiar with hal
08:14:48 <tsp> chessguy: window eyes sucks with erminals
08:14:54 <tsp> may as well go back to dos
08:15:02 <tsp> dos rocks
08:15:11 <chessguy> what about for general-purpose apps?
08:15:20 <tsp> works reasonably well
08:15:26 <tsp> window eyes supports office 2007
08:15:27 <chessguy> better than jaws?
08:15:32 <tsp> in some cases yes
08:16:05 <tsp> besides, wineyes is easier to crack
08:16:10 <tsp> no copy protection
08:16:20 <chessguy> i thought it shipped with windwos
08:16:22 <chessguy> windows
08:16:27 <tsp> chessguy: lol, that's narrator
08:16:38 <tsp> window eyes is gw micro's product
08:16:46 <chessguy> oh ok
08:17:01 <tsp> I have no idea where to crack it though :)
08:17:26 <tsp> still, windows sucks
08:17:37 <tsp> chessguy: what got you interested in haskell?
08:17:47 <chessguy> yeah, melissa's used JAWS for years and years. she's about to get certified to train people in it
08:18:21 <chessguy> mmm, i started with SICP, and then wandered around looking at different functional languages, and just kind of stumbled on haskell
08:18:30 <tsp> neat
08:18:48 <tsp> the word haskell just popped up somewhere and here I am
08:19:02 <chessguy> it's an awesome language
08:19:21 <tsp> I'm probably going to stick with python/ruby, but not sure yet - I don't think I cna move everything over to haskell though
08:19:48 <chessguy> have you played around with building NVDA yet?
08:21:05 <LPhas> learning a OO or procedural language when you are used to haskell is always painfull
08:21:47 <chessguy> yeah, i'm afraid i'm going to get a job programming in some imperative language now, after not having touched anything imperative in like a year
08:22:09 <tsp> LPhas: I find it the other way around
08:22:10 <chessguy> well, except perl
08:22:15 <tsp> LPhas: haskell really isn't that powerful atm
08:23:06 <chessguy> haskell is powerful, it's your brain that's the limit :)
08:23:09 <tsp> oh
08:23:58 <chessguy> expand your brain, and you become a better programmer, and you can use more of haskell
08:24:39 <LPhas> chessguy: you are right, the problem is that haskell always makes me fell my brain very limited :P
08:25:14 <chessguy> LPhas: but see, i'd rather have a language where i'm the bottleneck.
08:25:30 * LPhas agrees!
08:26:06 <LPhas> because you can study and improve, but the language will remain the same
08:26:25 <chessguy> and not only that, but i enjoy studying/improving
08:26:42 <chessguy> and it makes me a better programmer/thinker in general, not just in haskell
08:27:15 <ndm> @seen sorear
08:27:16 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc and #haskell 7h 2m 53s ago, and .
08:27:18 <tsp> chessguy: have you checked out python?
08:27:41 <chessguy> yes, i've poked around with it. never actually written anything in it
08:28:08 <chessguy> www.pythonchallenge.com is cool :)
08:33:35 <tsp> chessguy: I can't get past the encryption challenge :)
08:33:42 <chessguy> :)
08:33:47 <tsp> it's not rot13
08:34:24 <LPhas> tsp: you say that haskell is "not so powerful" then you talk about python. well, ok, python is said to be a very cool language, but is a *scripting* one
08:36:49 <phoniq> there's a distinction to be made between how inherently powerful the language is, and how many external libraries are available for it
08:39:32 <tsp> LPhas: I'm planning to write some tools, mostly screen readers and such for myself
08:39:46 <tsp> in that aspect, I"m not sure how well haskell will work
08:40:16 <encryptio> when i do programming languages i try to find the best that's the most different from what i know. that's why i've not learned much python or ruby - i do perl. but, my major languages show that: RB (VB clone), Perl 5, Haskell, and learning x86 assembly.
08:41:02 <matthew-_> how would you go defining a data type that can only be constructed with a 40-char sha1 hash ?
08:42:17 <matthew-_> I guess I'm going to have to just use String but then hide the constructor and use a function to construct it where the function checks the string is the right length...
08:42:22 <matthew-_> any better ideas?
08:43:22 <xerox> newtype SHA1 = SHA1 String
08:43:41 <matthew-_> yeah. but obviously you can do SHA1 "x" which is silly
08:44:12 <xerox> maybe you can put those bytes straight into bytes, would a Word be enough?
08:44:40 <LPhas> matthew-_: isn't a word 32 bit?
08:44:42 <xerox> if not, take yourself yourself the memory you need as fields in the type constructor?
08:45:03 <LPhas> xerox: i hardly see how 40 char could fit 32 bits
08:45:24 <matthew-_> so, it's a 40-digit hex number
08:45:28 <phoniq> 6da56ab883fd02244526c09a3a3861399d80ffba
08:45:30 <phoniq> e.g.
08:45:32 <matthew-_> yup
08:46:04 <xerox> you can't have type-level length-annotated strings yet
08:46:17 <rahikkala> "yet"?
08:46:22 <matthew-_> well, how about a bounded number
08:46:39 <matthew-_> the hash is clearly between 0 and 16^40
08:46:50 <xerox> newtype SHA1 = S Char Char Char ... Char
08:47:14 <matthew-_> mmm. yep, I guess that's doable.
08:47:36 <lizhn-> q
08:48:17 <matthew-_> what's the biggest fixed unit?
08:48:34 <matthew-_> I could use 8 Words
08:48:46 <xerox> Word64 ?
08:49:03 <matthew-_> ok, that's good.
08:49:08 <xerox> :m +Data.Word
08:49:12 <xerox> :b Data.Word
08:49:22 <LPhas> type SHA1 = (Char,Char,Char...)
08:50:13 <matthew-_> LPhas: no, I'd prefer to use data so that I can make the Show instance sane
08:50:29 <matthew-_> cool, thanks for your input.
08:50:36 <LPhas> well, but use a tuple
08:50:52 <LPhas> newtype SHA1 = S (Char,Char...)
08:51:32 <sorear> hello!
08:51:34 <LPhas> so you can handle the whole """string"""" more easily
08:52:31 <jdrake> What would be the easiest way to write a predicate to match more than one type? I would suspect something like 'or', but I am not thinking clearly on how it would work in haskell.
08:52:55 <matthew-_> LPhas: yeah, true enough.
08:53:12 <emu> data DisjointType = Choice1 ... | Choice2 ...
08:53:24 <xerox> jdrake: your function wants a constraint on a variable type
08:53:56 <xerox> which type do you want to take in input?
08:56:20 <jdrake> It is a Word8
08:56:28 <jdrake> I am making use of ByteString
08:56:44 <jdrake> Using the splitWith function
08:56:47 <matthew-_> sorry, I know this came up the other day, I can't remember the answer - how do you get a number converted to a string as hex ?
08:56:54 <jdrake> Which takes a (Word8 -> Bool)
08:57:02 <emu> @hoogle show
08:57:03 <lambdabot> Prelude.show :: Show a => a -> String
08:57:03 <lambdabot> Text.Show :: module
08:57:03 <lambdabot> Prelude.Show :: class Show a
08:57:30 <emu> @doc Numeric
08:57:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
08:57:38 <matthew-_> ok, cheers
08:57:59 <emu> > showHex 10
08:58:01 <lambdabot>  <[Char] -> [Char]>
08:58:13 <emu> > showHex 10 ""
08:58:14 <lambdabot>  "a"
08:58:32 <LPhas> > showHex 10 "aaa"
08:58:34 <lambdabot>  "aaaa"
08:58:38 <LPhas> prefix?
08:58:39 <emu> > showHex 10 "prepend"
08:58:41 <lambdabot>  "aprepend"
08:58:46 <emu> er, yea
08:58:47 <LPhas> suffix
08:58:50 <LPhas> why a suffix?
08:59:11 <emu> > showHex 10 $ showOct 8 $ show 123
08:59:13 <lambdabot>  "a10123"
08:59:20 <xerox> ?type ((?f :: Char -> Bool) . chr . fromIntegral) :: Word8 -> Bool -- jdrake
08:59:22 <lambdabot> Word8 -> Bool :: (?f::Char -> Bool) => Word8 -> Bool
08:59:26 <LPhas> ooooooh
09:00:03 <jdrake> xerox: What am I looking at
09:00:50 <xerox> jdrake: a function that takes a (Char -> Bool) and returns a (Word8 -> Bool)
09:00:50 <sorear> A bug, I think
09:01:14 <sorear> Lambdabot incorrectly cuts on the first :: rather than the last
09:01:35 <jdrake> I can use '\n' and ' ' to represent what I want to split at, it works fine (I am importing the right thing that works automatically)
09:01:36 <xerox> I think it's a regexp, can you fix that?
09:02:22 <jdrake> I am really needing a way for the predicate to match either '\n' or ' '
09:03:04 <sorear> xerox: insufficient motivation
09:03:18 <sorear> \x -> x == '\n' || x == ' ' -- ?
09:03:20 <xerox> ?type (||)
09:03:23 <lambdabot> Bool -> Bool -> Bool
09:03:43 <jdrake> ok, I didn't know about ||
09:03:51 <xerox> right
09:03:54 <resiak> @pl \fs x -> or (map ($x) fs)
09:03:55 <lambdabot> (or .) . flip (map . flip id)
09:04:00 <resiak> hot!
09:04:19 <sorear> liftM2 (||) (=='\n') (==' ')
09:04:34 <sorear> @seen
09:05:14 <jdrake> Thank you, it works
09:05:49 <ndm> sorear, hi
09:06:08 <ndm> sroear (just a note, if you send me a message more than 30 lines ago, i can't see it)
09:06:32 <ndm> sorear, i've patched up Data.Derive.SYB, was failing with type errors before - think it was teh AST -> String move
09:08:03 <sorear> nice.  Does it actually work, or just compile?
09:08:12 <ndm> sorear, works fine
09:08:13 <sorear> it was what I was planning on doing next
09:08:24 <sorear> but I hadn't started, so great
09:08:29 <ndm> i am writing the "derive.exe" binary
09:08:34 <ndm> which does automatic derivations
09:08:46 <ndm> should have a first version ready in about 20 mins
09:09:00 <sorear> ... writing reply ...
09:09:11 <ndm> that will be our DrIFT killer
09:11:44 <matthew-_> sheesh. There are so many times where haskell just makes me smile.
09:11:46 <matthew-_> instance Show Hash where
09:11:46 <matthew-_>     show (Hash w1 w2 w3 w4 w5) = foldr showHex "" [w1,w2,w3,w4,w5]
09:11:57 <matthew-_> how lovely is that?
09:12:32 <sorear> > maxBound :: LargeKey Word128 Word32
09:12:33 <lambdabot>   Not in scope: type constructor or class `LargeKey'
09:12:41 <sorear> > maxBound :: Key Word128 Word32
09:12:42 <lambdabot>   Not in scope: type constructor or class `Key'
09:12:47 <sorear> > maxBound :: Word128
09:12:50 <lambdabot>  340282366920938463463374607431768211455
09:12:50 <xerox> Crypto package?
09:12:53 <sorear> yeah
09:13:14 <Igloo> matthew-_: You'll probably want to pad each of the components, though
09:13:23 <sorear> it has a largekey type, which lets you construct arbitrary even sized fixnums
09:13:36 <sorear> so, Word160, matthew-_? :)
09:13:41 <matthew-_> ahh. yes.
09:15:15 <sorear> ndm: reply sent.
09:15:41 <ndm> hmm, can you run a module that is not main with runhaskell?
09:15:58 <ndm> i.e. i want module Fred where main = print "hello", then to invoke that module with runhaskell
09:16:15 <sorear> I don't know.
09:16:47 <sorear> It would be pretty easy to fix editing the runghc source code, but That Is Unportable
09:16:56 <ndm> indeed :)
09:16:57 <sorear> and I know how much you care about hugs ;)
09:17:13 <ndm> i suspect Hugs might allow it, since it has no notion of Main.main
09:17:21 <sorear> testing derive, my suspicions are confirmed:
09:17:29 <matthew-_> soread: bizarre, the exports on LargeKey don't include Word160, but it is defined in the file: http://darcs.haskell.org/crypto/Data/LargeWord.hs
09:17:31 <sorear> instance (Eq t1, Eq t2) => Eq (Example.State t1 t2)
09:17:31 <sorear>     where == (StateT a1) (StateT b1) = && (== a1 b1) True
09:17:31 <sorear>           == _ _ = False
09:17:56 <sorear> matthew-_: bizarre indeed.  Patch?
09:18:05 <ndm> hmm, unfortunate
09:18:14 <resiak> sorear: you appear to be using == as a prefix.  i am confused!
09:18:24 <sorear> resiak: I know.
09:18:53 <sorear> resiak: http://haskell.org/pipermail/libraries/2007-March/007301.html
09:18:54 <lambdabot> Title: Dubious behavior in TH pretty printer
09:19:20 <resiak> sorear: heh!
09:19:51 <sorear> ndm said something about reporting a bug earlier, but I can't find it now
09:22:13 <ndm> sorear, just got your email - i mean the latter, and yes it does depend ppr being fixed, but I can write and test all the code before hand, and then hook it up once its ready
09:22:37 <doserj> ndm: can you use "ghc -e Fred.main Fred.hs"?
09:23:56 <ndm> doserj, works like a treat - thanks
09:24:08 <ndm> for reference -main-is doesn't seem to have any effect with runhaskell
09:29:57 <matthew-_> anyone know of a an Email package/module including a parser for valid email addresses? Hackage doesn't seem to...
09:31:47 <tapi> hi
09:32:06 <sorear> !
09:33:09 <tapi> please, please, please, can someone tell me where i could find a howto about the state monad... a howto made for retards like me
09:33:22 <sorear> @google state monad
09:33:24 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
09:33:25 <Cheery> haskell wikibook has one
09:33:29 <sorear> @google state monad howto
09:33:31 <lambdabot> http://www.cs.chalmers.se/pub/haskell/yale/hugs0.README
09:33:52 <Cheery> but tapi, state monad is simple, it just looks complicated
09:34:02 <sorear> @src State
09:34:02 <lambdabot> Source not found. I feel much better now.
09:34:09 <sorear> @slap @src
09:34:10 * lambdabot smacks @src about with a large trout
09:34:21 <Cheery> @src Control.Monad.State
09:34:22 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:34:22 <tapi> sorear: i read something i agree with somewhere : guys are more trying to show how clever they are than explain things clearly
09:34:40 <Cheery> just remove all the type -stuff for a moment
09:34:52 <shachaf> @source Control.Monad.State
09:34:53 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
09:35:43 <sorear> @djinn (s -> ((s -> (a, s), s) -> s -> (a, s)  -- essense of State
09:35:44 <lambdabot> Cannot parse command
09:35:47 <sorear> @djinn (s -> ((s -> (a, s), s) -> s -> (a, s)
09:35:47 <Cheery> return unit = \state k -> k unit state
09:35:47 <lambdabot> Cannot parse command
09:36:08 <tapi> i writing a small irc bot to learn haskell, and i don't know how to, ie, maintain a list of open chans
09:36:16 <Cheery> bind monad function = \state -> monad state function
09:36:16 <tapi> or even store the bot's nickname
09:36:25 <sorear> @goog Roll your own IRC bot
09:36:27 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
09:36:28 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
09:36:47 <tapi> i was my start point, yes
09:36:59 <tapi> but it doesn't explain how to store updatable informations
09:37:03 <tapi> :/
09:37:19 <shachaf> tapi: "If we wished to add read-write state, we need only change the ReaderT transformer to StateT."
09:37:21 <tapi> do i need a state monad to implement that ?
09:37:52 <Cheery> it's  State transformer monad
09:38:02 <sorear> tapi: or (as lambdabot does) you could store a mutable reference in the RO state
09:38:31 <tapi> well, it seems it's time to go back on 7 lines sentences...
09:39:25 <Cheery> I think I'll yet rewrite my CSS -generator
09:39:50 <ndm> @hoogle crc
09:39:50 <lambdabot> No matches found
09:40:05 <ndm> is there some sort of hash function in the standard library
09:40:21 <ndm> i just want to use it for checking that the user hasn't screwed with the contents of a file
09:40:27 <Cheery> it works, but is too clumsy
09:40:34 <ndm> not cryptographically secure, just something basic
09:41:08 <Cheery> http://www.haskell.org/hoogle/?q=hash&format=sherlock
09:41:10 <lambdabot> Title: hash - Hoogle
09:41:37 <Igloo> I think crypto has crc32, but you may as well use a real hash if you're going to depend on that
09:42:10 <jcreigh> > foldr (xor . ord) 0 "hello world" -- :-)
09:42:11 <lambdabot>  32
09:42:28 <Igloo> Java uses this:
09:42:29 <Igloo> mkName :: String -> String
09:42:29 <Igloo> mkName s = show (abs (foldl f 0 s))
09:42:29 <Igloo>     where f :: Int32 -> Char -> Int32
09:42:29 <Igloo>           f x y = x * 31 + fromIntegral (ord y)
09:42:30 <ndm> i only want to check the user hasn't accidentally modified the code before i overwrite it
09:42:36 <ndm> hashString will probably be plenty
09:43:15 <Igloo> Oh, there's one for HashTables in the libraries, but I think there's a bug about it being broken
09:43:31 <ndm> hmm, i might go with my own one then, as per your description
09:43:40 <ndm> i need it to remain stable, and be slightly good - not very good
09:43:58 <jcreigh> > hashString "hello world"
09:43:59 <lambdabot>   Not in scope: `hashString'
09:44:16 <LPhas> @hoogle hash
09:44:16 <lambdabot> Data.HashTable.hashInt :: Int -> Int32
09:44:16 <lambdabot> Data.HashTable.hashString :: String -> Int32
09:44:16 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
09:44:41 <jcreigh> > Data.HashTable.hashString "hello world"
09:44:43 <lambdabot>   Not in scope: `Data.HashTable.hashString'
09:44:50 <jcreigh> I guess lambdabot doesn't have it. but on my system:
09:45:05 <jcreigh> hashString "hello world" => 71 hashString "world" => 71
09:45:08 <jcreigh> concerning?
09:45:21 <Igloo> That's what the bug's about, IIRC
09:45:31 <jcreigh> oh.
09:52:17 <Nanar> Hi ;)
09:52:24 <Nanar> need a smal explication
09:52:28 <Nanar> in deep :: (ArrowTree a, Tree t) => a (t b) (t b) -> a (t b) (t b)
09:52:47 <Nanar> what does mean the '=>' ?
09:53:44 <ddarius> sorear: You remember how I said this weekend was going to be crappy last night?
09:56:23 <LoganCapaldo> Nanar In the following type the prceeding constraints are in effect
09:57:56 * LoganCapaldo wishes that it was type => class stuff
09:58:53 <LoganCapaldo> Cause then it could read like a -> b => (Tree a, Node b) a implies b when a is an instance of Tree and b is an instance of Node
09:59:18 <LoganCapaldo> But that's probably just my left to right language bias showing :)
09:59:27 <Nanar> :)
10:00:07 <Nanar> I am trying to play with XHT, but it not easy to begin
10:01:45 <ddarius> LoganCapaldo: ? Foo a => a -> b reads as if a is in Foo a implies b, the other order makes no sense.
10:04:40 <LoganCapaldo> it makes as much sense as I usually do
10:18:52 <ndm> sorear, i've just pushed Derive.hs, which is our DrIFT competitor
10:18:59 <ndm> create a data type such as:
10:19:15 <ndm> data Foo = Foo deriving ( {!- Binary !-} )
10:19:28 <ndm> then run derive filename.hs --append, and the instance will end up in that file
10:19:54 <ndm> derive filename.hs -o outputfile will also give the thing in a file, and we have --import and --module for various other things
10:21:32 <ndm> where should temporary files be created in Haskell?
10:29:58 <sorear> ndm: cool!
10:30:21 <thermoplyae> I'm looking for a function that sums all the digits in an integer, and I'm a terrible Haskell programmer
10:30:22 <sorear> WOW.
10:30:26 <thermoplyae> Can anyone help me out real quick?
10:30:36 <sorear> sure.
10:30:59 <sorear> > sum . map (read . (:[])) . show $ "999"
10:31:01 <lambdabot>  Exception: Prelude.read: no parse
10:31:03 <sorear> > sum . map (read . (:[])) . show $ 999
10:31:04 <lambdabot>  27
10:31:10 <ddarius> @index digitToChar
10:31:10 <lambdabot> bzzt
10:31:15 <thermoplyae> Sweet, thanks
10:31:17 <ddarius> @index charToDigit
10:31:17 <lambdabot> bzzt
10:31:21 <sorear> > sum . map digitToInt . show $ 999
10:31:23 <jcreigh> @hoogle Char -> Int
10:31:23 <lambdabot>  27
10:31:24 <lambdabot> Char.digitToInt :: Char -> Int
10:31:24 <lambdabot> Char.ord :: Char -> Int
10:31:38 <lemmih> > sum . map (read.return) . show $ 64
10:31:40 <lambdabot>  10
10:31:46 <thermoplyae> How useful
10:32:13 <sorear> lemmih: your name has changed case
10:32:52 <sorear> ndm: there's a temp file routing in System.IO, I'm pretty sure
10:32:57 <sorear> @hoogle IO FilePath
10:32:58 <lambdabot> Directory.getCurrentDirectory :: IO FilePath
10:32:58 <lambdabot> System.Directory.getHomeDirectory :: IO FilePath
10:32:58 <lambdabot> System.Directory.getTemporaryDirectory :: IO FilePath
10:33:08 <sorear> @hoogle+
10:33:09 <lambdabot> System.Directory.getUserDocumentsDirectory :: IO FilePath
10:33:09 <lambdabot> Distribution.Simple.GHCPackageConfig.localPackageConfig :: IO FilePath
10:33:09 <lambdabot> System.Directory.canonicalizePath :: FilePath -> IO FilePath
10:33:15 <sorear> @hoogle+
10:33:15 <lambdabot> System.Directory.getAppUserDataDirectory :: String -> IO FilePath
10:33:44 <sorear> hmm, hoogle didn't find it
10:33:46 <lemmih> sorear: Yeah, some jerk stole my uppercase l. I'll get a new one soon, though.
10:33:57 <kc5tja> I'm sorry -- I can't resist posting this:
10:34:07 <sorear> @ty System.IO.openTempFile -- ndm
10:34:10 <lambdabot> FilePath -> String -> IO (FilePath, GHC.IOBase.Handle)
10:34:14 <kc5tja> (from #lojban, where someone was talking about coding something in C)
10:34:16 <kc5tja> 01:11 < cizra> apparently select() modifies the g'damn socket list!
10:34:25 <sorear> socket?
10:34:56 <sorear> lemmih: IRC is case insensitive.  If Lemmih was stolen, lemmih would be unavailable.
10:34:57 <kc5tja> Since most C coders generally don't agree FPLs are useful, or at least aren't aware of their characteristics, I found this exclamation humorous.  :)
10:35:40 <sorear> Or do you mean someone physically stole your SHIFT key?
10:35:48 <jcreigh> heh
10:35:51 <sorear> that has happened at my school :)
10:36:27 <ndm> sorear, neat - will fix up derive to use that
10:36:35 * dufflebunk wonders what someone would do with a shift key
10:36:46 <sorear> extortion?
10:37:00 <sorear> ask for ransom?
10:37:42 <ndm> we used to have our mouses checked for balls at the end of every class
10:37:51 <jcreigh> dufflebunk: make uppercase letters? :)
10:38:05 <ddarius> Yeah, stealing mouse balls is a popular past time apparently.
10:38:09 <kilimanjaro> If they took the 's' key they could only ask for ranom
10:38:14 <dufflebunk> ndm: we had that too, then they started switching to neutered mice
10:38:30 <ndm> dufflebunk, this was years ago
10:38:44 <ddarius> Years ago for me too.
10:38:52 <ndm> apparently after George W Bush got into the whitehouse, the leaving democrats removed all the 'W' keys
10:39:23 <sorear> VV Bush
10:39:47 <ddarius> @elite George W Bush
10:39:48 <lambdabot> Ge0rg3 W 8uSH
10:39:54 <dufflebunk> I see a repeat of the l33t speak from last evening brewing
10:40:09 <ddarius> That's all for me.
10:40:16 <sjanssen> @. elite keal
10:40:17 <lambdabot> ARE Th3rE phulL bODy r3cognITiON fi135 phoR SORtinG art?
10:40:35 <qwr> lambdabot uses very little numbers
10:41:18 <ddarius> Once we add a @fix command we'll be able to concisely solve that.
10:41:37 <flux-> qwr, like 1 and 2, or even more little?
10:41:43 <qwr> 530r53 \/\/ 8|_|5|-|
10:41:45 <sorear> No, it would just give _|_
10:42:43 <sorear> qwr: I have a notice for you from the Zero Anti-Defamation League
10:43:54 <ddarius> sorear: Just have @fix stop if the input is the same as the output.
10:45:05 <sorear> ddarius: don't we have to start the AKC from _|_?
10:45:25 <qwr> sorear: that protects zeros from defamation? ;)
10:51:09 * ndm beats the GHC developers to death
10:51:20 <ndm> openTempFile and openBinaryTempFile are only defined in GHC, not in Hugs!
10:52:15 <dufflebunk> qwr: I think it's zero tolerance for anti-defamation
10:52:22 <sorear> oh yay
10:53:43 <Igloo> ndm: Beat the hugs developers to death, then  :-)
10:54:33 <ndm> Igloo: i will beat everyone to death
10:54:37 <sorear> ndm: or just finish yhii ;)
10:55:19 <Cheery> @elite Cheery
10:55:20 <lambdabot> CH33RY
10:55:22 <longarms2> has  anyone used hat with parallel arrays (i.e. with the special array syntax enabled by -fparr on ghc)?
10:55:28 <Cheery> xD
10:55:41 <Igloo> longarms2: I doubt very much that will work
10:55:46 <sjanssen> longarms2: hmm, that sounds like it's not going to work
10:55:56 <sorear> ndm: you'll need to go soon and fast, if you want to compete with the human birthrate ;)
10:56:15 <longarms2> it seems like it would if i could enable the desugering early
10:56:22 <ndm> sorear, its going to be hard work...
10:56:29 <longarms2> but i have no idea how
10:56:44 <Igloo> sorear: I think you may as well wait a couple of hundred years and let the birthrate decline first
10:57:24 <sorear> heh.
10:57:26 <Igloo> Unless the "soon" was due to the ndm death rate
10:57:47 <ndm> sorear, I think it would be cool to derive Fuctor's ;)
10:57:53 * Igloo disappears
10:58:18 <sorear> one of my projects (waay low on the prio list) was a hat-clone for Yhc.Core.  Realised there probably wasn't a demand for something that low level.
10:58:20 <ndm> just updating the derive script with proper temporary files
10:58:46 <ndm> sorear, i was tempted by that - only useful if Hat doesn't work (which it doesn't)
11:07:07 <SimonRC> I realised yesterday why FP code might be less buggy.
11:07:51 <SimonRC> Because everything is made of expressions, not statements, it is harder to get the computer to pull numbers out of its
11:08:16 <jcreigh> ...bitbucket? :)
11:08:53 <sorear> $(random /usr/share/dict/words)
11:08:54 <SimonRC> It's harder to forget to do something, because often that would involve data coming out of no-where
11:11:23 <DRMacIver> Hm. Hoogle is really rather cool.
11:11:42 <sorear> ndm++
11:11:51 <DRMacIver> I've been programming Java for too long. It would never have occured to me that searching on a type signature was a useful thing to do. :)
11:14:15 <Saizan> we need an editor with embedded haddock documentation
11:15:23 <sorear> For how long has TH failed to ppr irrefutable patterns correctly?
11:15:31 <sorear> Prelude Language.Haskell.TH> fmap ppr (runQ [| \ ~x -> x |] )
11:15:31 <sorear> \x_0 -> x_0
11:18:41 <sjanssen> the output there is semantically the same
11:18:48 <sjanssen> what happens if you use a real pattern?
11:19:04 <ddarius> \~(x,y) -> x
11:19:26 <sorear> *Data.Derive.FixedPpr Language.Haskell.TH.Syntax> ppr `fmap` runQ [| (+) 2 2 |]
11:19:26 <sorear> (GHC.Num.+) 2 2
11:19:29 <sorear> yay!
11:20:03 <sorear> sjanssen: vvv
11:20:03 <sorear> Prelude Language.Haskell.TH> fmap ppr (runQ [| \ ~(x,y) -> 2 |] )
11:20:03 <sorear> \(x_0, y_1) -> 2
11:20:33 <Cheery> Anyone could help me in making a tiny language?
11:20:35 <sjanssen> vvv?
11:20:42 <sorear> opposit of ^^^
11:20:46 <sjanssen> ah
11:20:57 <Cheery> kind of, you know the selector field of CSS?
11:21:02 <sorear> #lojban maybe? ;)
11:21:12 <ndm> sorear, no one uses TH because its broken :)
11:21:26 <Cheery> selector { declarations* }
11:21:52 <Cheery> the selector is a kind of pattern to match
11:22:30 <sorear> stefan@stefans:/usr/local/src/derive$ ./Derive /tmp/X.hs
11:22:30 <sorear> Error, module name not detected
11:22:30 <sorear> instance Binary Main.Foo
11:22:30 <sorear>     where put (Foo) = (>>) (return ()) (return ())
11:22:35 <sorear>           get = (>>=) (return 0) (\tag_ -> case tag_ of
11:22:38 <sorear>                                                0 -> return Foo)
11:22:44 <sorear> yeah!
11:23:34 <ndm> sorear, it does expect a module name, i wonder if thats a worthwhile error or not
11:23:55 <ndm> sorear, try --append, or add {-# OPTIONS_DERIVE --append #-} at teh top of the file
11:24:48 <Cheery> how should I describe such patterns with combinators?
11:24:53 <sorear> ndm: if I had done that, you wouldn't have seen the fact that the output is correct now!
11:25:17 <ndm> sorear, oh, i missed that :) - well done
11:25:24 <ndm> sorear++
11:27:14 <sjanssen> so what're the advantages to this new deriver?
11:27:19 <bos31337> is there a way to combine two darcs patches into one?
11:27:37 <sorear> bos31337: yes, but you probably shouldn't
11:27:50 <ndm> sjanssen: you can use it with TH, it is based on Data.Generics, just nicer generally
11:27:51 <sorear> sjanssen: multi-modal - SYB, preprocessor, TH
11:28:11 <bos31337> sorear: in this case, i think i want to. i only want to publish one patch, but i have two.
11:28:25 <Cheery> ie, say I've this kind of structure representing the selector:  [Descendant x (Base y), Child z (Descendant y (Base x))]
11:28:31 <ndm> bos31337: unrecord both patches, record afresh as one
11:28:40 <bos31337> ndm: ah, ok
11:28:45 <Cheery> well, I could make it less ugly with small changes on the first hand...
11:28:49 <sorear> bos31337: darcs send will send multiple patches
11:28:54 <Cheery> I think I'll do those
11:29:07 <sjanssen> ndm/sorear: can the user extend the set of derivable classes?
11:29:11 <ndm> bos31337: but as sorear said, its probably not the right thing to do
11:29:24 <sorear> sjanssen: yes!  Infact easier than DrIFT
11:29:25 <ndm> sjanssen: yes, easily
11:29:53 <sorear> sjanssen: since with drift you need to fugde paths, or edit drift itself
11:30:12 <sorear> sjanssen: but with Data.Derive, you can just write the deriver as a module in your program
11:31:56 * jcreigh wonders where to send a patch for dmenu...
11:32:30 <benny_> jcreigh: #dwm or #wmii on oftc.net, "arg" is the person you should talk to
11:32:42 <jcreigh> benny_: excellent! Thank you!
11:34:07 <sjanssen> sorear: can a library export this deriver module, so client code will automatically use it?
11:35:41 <sorear> sjanssen: sure, package L can export derivers to be used in package C
11:36:10 <sjanssen> nice
11:36:19 <ndm> sjanssen: its very extensible, I don't quite no exactly how it will work, but everything possible should be pretty easy
11:36:33 <sjanssen> I think Haskell could use something like this in the standard
11:38:21 <hpaste>  sciolizer pasted "Data.Generics.Basics does not export Prefix?" at http://hpaste.org/1207
11:38:25 <ndm> sjanssen: the way we're doing it, its almost as good
11:38:28 <sciolizer> @hoogle Prefix
11:38:28 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
11:38:29 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
11:38:29 <lambdabot> Distribution.Simple.Configure.prefix :: LocalBuildInfo -> FilePath
11:39:36 <Saizan> ?docs Data.Generics.Basics
11:39:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics-Basics.html
11:40:44 <sciolizer> There's nothing in the documentation saying that it would be hidden. And besides, it is used in one of the examples (con_C1 and con_C2).
11:41:00 <Saizan> sciolizer: Prefix is a constructor, the type is Fixity, so you should import Data.Generics.Basics (Fixity(Prefix))
11:41:13 <sciolizer> Saizan: oh, thanks. silly me
11:43:32 <chessguy> @type repeat
11:43:35 <lambdabot> forall a. a -> [a]
11:43:44 <chessguy> ?src repeat
11:43:45 <lambdabot> repeat x = xs where xs = x : xs
11:44:07 <sorear> I prefer fix . (:)
11:44:12 <chessguy> ?hoogle Int -> a -> [a]
11:44:12 <lambdabot> Prelude.replicate :: Int -> a -> [a]
11:44:16 <sorear> just as efficient :)
11:44:29 <chessguy> ?src replicate
11:44:29 <lambdabot> replicate n x = take n (repeat x)
11:45:43 <ndm> sorear, i would have thought repeat could be a build, hence fused
11:47:08 <bos31337> i have a taste question.
11:47:22 <sorear> sweet or sour?
11:47:45 <bos31337> in my ipv6-for-network patch, the getNameInfo function takes two Bool parameters. one controls whether to look up hostnames, the other whether to look up service names.
11:48:18 <sorear> ick! ;)  make sure you have haddocks
11:48:21 <bos31337> i was wondering whether it would be "nicer" to add once-off type aliases for those Bools to make the function's signature a bit more self-documenting
11:48:48 <ndm> bos31337: yes, definately, without a doubt
11:48:56 <bos31337> ok, great.
11:49:35 <sorear> getNameInfo :: String -- ^The name to look up
11:49:35 <sorear>             -> Bool   -- ^Should the hostname be looked up?
11:49:35 <sorear>             -> Bool   -- ^Should the service name be looked up?
11:49:35 <sorear>             -> NameInfo
11:49:44 <bos31337> as in "typeLookupHost = Bool" and "type LookupService = Bool" ?
11:49:53 <bos31337> er, "type LookupHost..."
11:49:55 <sorear> I suppose aliases are better for hoogle ;)
11:50:20 <sorear> that's the syntax for haddocking parameters, btw
11:50:32 <bos31337> yes, i know. i've haddocked the existing code :)
11:50:46 <sorear> it's a very unloved feature
11:51:17 <bos31337> the parameter haddocking?
11:51:32 <sorear> yeah
11:56:18 <ndm> bos31337: when the option is so booly as in that example, leaving it as Bool is probably ok
11:56:47 <ndm> adding type X = Bool isn't very helpful
12:00:39 <bos31337> ndm: ok.
12:01:26 <ndm> its more useful to do data Lookup = LookupBoth | LookupHost | LookupService | LookupNone is sometimes handy
12:01:36 <ndm> depends on the exact circumstance
12:03:06 <Cheery> what kind of sorting algorithms there are in haskell combinator library?
12:03:18 <mux> please don't forget LookupNumericHost for getNameInfo
12:03:30 <mux> the NI_NUMERICHOST flag is very useful
12:03:52 <Cheery> I'd need to sort my list of elements, like this:
12:04:58 <Cheery> [(1, b), (3, a), (5, c)]
12:05:26 <sorear> just use 'sort'
12:05:31 <Cheery> so that tuples which have 3 in their first cell, would be always first
12:05:39 <sorear> sortBy, then
12:06:01 <Cheery> where is it?
12:06:07 <sorear> import List
12:06:12 <Cheery> thank
12:06:15 <sorear> :t sortBy
12:06:17 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:07:25 <Cheery> the real case thing is like this: [Id "b", Element "a", Class "c"]
12:07:34 <Cheery> sortBy should do this, I guess
12:07:53 <mux> > sortBy (\(a,b) (c,d) -> if (compare a c == EQ) then compare b d else compare a c) [(3,'a'), (1,'b'), (5,'c')]
12:07:54 <lambdabot>  [(1,'b'),(3,'a'),(5,'c')]
12:08:18 <sorear> mux: firsly, that's the default ordering on tuples
12:08:27 <sorear> mux: second, Ordering is a monoid
12:08:53 <sorear> > sortBy (\(a,b) (c,d) -> compare a c `mplus` compare b d) [(3,'a'), (1,'b'), (5,'c')]
12:08:54 <lambdabot>  Couldn't match expected type `m a' against inferred type `Ordering'
12:08:59 <mux> ah, mplus
12:09:02 <sorear> > sortBy (\(a,b) (c,d) -> compare a c `mappend` compare b d) [(3,'a'), (1,'b'), (5,'c')]
12:09:04 <lambdabot>  [(1,'b'),(3,'a'),(5,'c')]
12:09:05 <sorear> meh.
12:09:10 <mux> k
12:09:21 <mux> and that isn't even needed since that how tuples compare, thanks
12:09:21 <sorear> > sort [(3,'a'), (1,'b'), (5,'c')] -- even easier
12:09:23 <lambdabot>  [(1,'b'),(3,'a'),(5,'c')]
12:09:26 <mux> yeah
12:12:18 <doserj> > let on f g x y =  f (g x) (g y) in sortBy ((compare `on` fst) `mappend` (compare `on` snd)) [(1,'b'),(3,'a'),(5,'c')]
12:12:20 <lambdabot>  [(1,'b'),(3,'a'),(5,'c')]
12:13:07 <doserj> "on" should become standard :)
12:13:21 <Botje> @plk \f g x y -> f (g x) (g y)
12:13:21 <lambdabot> join . ((flip . ((.) .)) .) . (.)
12:13:28 <Botje> funky.
12:13:34 <Cheery> sortBy patternPriority patterns
12:13:38 <Cheery> :P
12:14:02 <Cheery> doserj: yep, that `on` -combinator seems nice
12:14:03 <sorear> doserj: it is
12:14:17 <doserj> sorear: where?
12:14:24 <sorear> doserj: Data.Function
12:14:46 <sorear> doserj: you might need a newer ghc tho
12:15:18 <doserj> its not in my standard ghc 6.6
12:15:20 <sorear> > sortBy ((compare `on` fst) `mappend` (compare `on` snd)) [(1,'b'),(3,'a'),(5,'c')]
12:15:21 <lambdabot>   Not in scope: `on'
12:15:34 <sorear> > sortBy ((comparing fst) `mappend` (comparing snd)) [(1,'b'),(3,'a'),(5,'c')]  -- works in 6.6
12:15:36 <lambdabot>  [(1,'b'),(3,'a'),(5,'c')]
12:15:42 <sorear> doserj: right. it's new in ghc 6.7
12:15:57 <phoniq> so is there a Better way to get cabal packages than download-tarball,untar-tarball,runhaskell Setup.sh (configure,build,install), etc?
12:16:22 <sorear> supposedly there's a cabal-get program in the works
12:16:30 <rahikkala> > let on f g x y =  f (g x) (g y) in nubBy (on (==) abs) [-1, 2, 1]
12:16:30 <sorear> maybe it was called calab-install
12:16:31 <lambdabot>  [-1,2]
12:16:43 * rahikkala likes
12:17:00 <sorear> nubby is fun!
12:17:12 <sorear> > nubBy(((>1).).gcd)[2..]
12:17:14 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:17:29 <doserj> :)
12:17:34 <sorear> My favorite one liner!
12:18:30 <ndm> wow, that is a nice one liner!
12:18:52 <Vq^> sorear: nice!
12:23:47 <Cheery> > patternPriority (Element _) (Element _) = error "two elements in same pattern"
12:23:48 <lambdabot>  Parse error
12:23:49 <benja_> hi, I'm trying to make an efficient SHA1 implementation and I'm trying to use unboxed values, but GHC can't find MutByteArr#; any advice?
12:23:59 <Cheery> I feel too much hacker after this one
12:24:05 <sorear> hmm, problem is derive+th - th is perfectly willing to tell you Int is algebraic
12:24:23 <sorear> so I need some heuristic to reject it...
12:24:27 <benja_> with boxed types, I'm allocating something like 800 MB to has 300 KB
12:24:30 <sorear> benja_: Ghc.Prim?
12:24:45 <sorear> benja_: that sounds like a space leak
12:24:47 <benja_> sorear: is imported, and Word# and such are found
12:24:48 <ndm> sorear: if you ask for the constructors of Int, what does it say?
12:24:54 <sorear> I# Int#
12:25:06 <ndm> sorear: module name?
12:25:15 <sorear> GHC.Base
12:25:17 <ndm> for Int, that is
12:25:25 <ndm> anything else in GHC.Base which is algebraic?
12:25:44 <benja_> sorear: I mean profiling says I'm allocating 800 MB total, not that the program uses 800 MB at some particular point
12:26:00 <sorear> benja_: boxed types in the worst case use around 100 times the actual data size
12:26:05 <sorear> benja_: oh...
12:26:24 <sorear> benja_: I'd try adding a few bangs - let's stay portable if we can
12:26:50 <sorear> ndm: yes
12:27:06 <sorear> ndm: GHC.Base is the Prelude, basically
12:27:56 <ndm> sorear: the constructor ends with a #, so perhaps all algebraic types with # ending constructors are really abstract
12:27:58 <hpaste>  benja_ pasted "SHA1 bottleneck" at http://hpaste.org/1208
12:29:06 <sorear> ndm: maybe a better heuristic would be to stop chasing when we reach GHC.anything
12:29:14 <sorear> ndm: so lists eg wont be derived
12:29:22 <sorear> ndm: unless you ask explicitly
12:29:26 <benja_> this version uses STUArray, but the results are in the same ballpark with STArray
12:29:57 <sorear> hm. are you using tuples for indices?
12:30:26 <ndm> sorear, perhaps - I'm not sure the "derives" thing was actually that useful in the end
12:30:43 <benja_> sorear: if you meant me, no, Int
12:31:04 <sorear> @ki GHC.Prim.MutByteArr#  --exists just fine
12:31:07 <lambdabot>     Not in scope: type constructor or class `GHC.Prim.MutByteArr#'
12:31:18 <sorear> wha?!
12:31:23 <sorear> it's in the dons!
12:31:27 <sorear> *docs
12:31:41 <ndm> sorear, i've now got temporary files working with the derive program
12:32:11 <ndm> sorear, i'm now thinking its in a sufficient state that I can actually make Yhc depend on this
12:32:18 <sorear> yay!
12:32:36 <sjanssen> benja_, sorear: MutableByteArray#
12:32:41 <sorear> actually I've got a small iface change I'd like to make
12:32:48 <sorear> the docs are obsolete :(
12:32:56 <ndm> sorear, make it quick and break it fast :)
12:33:06 <ndm> sorear, don't worry about interface stability for the moment
12:33:22 <benja_> sjanssen: thanks!
12:33:22 <ndm> sorear, i'm going to write up a manual for the derive binary to start with
12:34:01 <chessguy> data Foo = Foo {bar :: Int}; f :: Foo -> Foo; f x = x{bar = bar + 1}; -- is this valid?
12:34:20 <ndm> chessguy: yes, i think so
12:34:26 <sorear> almost.
12:34:37 <sorear> data Foo = Foo {bar :: Int}; f :: Foo -> Foo; f x = x{bar = bar x + 1};
12:34:41 <sorear> that should work
12:35:03 <chessguy> oh yes
12:35:59 <sorear> @spell consistent
12:36:00 <lambdabot> consistent
12:37:01 <benja_> @spell czech my words
12:37:02 <lambdabot> Czech Czechs creche Zach catch
12:37:37 <ddarius> creche is rarely used word
12:38:01 <chessguy> ?all-dict creche
12:38:02 <lambdabot> *** "Creche" gcide "The Collaborative International Dictionary of English v.0.48"
12:38:03 <lambdabot> Creche \Cr[`e]che\ (kr[asl]sh), n. [F.]
12:38:03 <lambdabot>    1. A public nursery, where the young children of poor women
12:38:03 <lambdabot>       are cared for during the day, while their mothers are at
12:38:03 <lambdabot>       work.
12:38:04 <lambdabot> [28 @more lines]
12:41:57 <ndm> sorear, which license is Data.Derive under?
12:42:41 <sorear> same as DrIFT sounds like a good bet
12:42:45 * sorear checks
12:43:01 <sorear> == BSD3
12:45:22 <glen_quagmire> give me an example of lazy evaluation
12:45:36 <sorear> > nubBy(((>1).).gcd)[2..]
12:45:37 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:45:54 <glen_quagmire> a = 3; f a;
12:45:56 <sorear> > let x = (1 `div` 0) in x -- this fails
12:45:58 <lambdabot>  Exception: divide by zero
12:46:03 <sorear> > let x = (1 `div` 0) in 2 -- this doesn't
12:46:05 <lambdabot>  2
12:46:23 <glen_quagmire> i should read about haskell syntax first :)
12:47:13 <qwr> > take 5 [1..]
12:47:14 <lambdabot>  [1,2,3,4,5]
12:47:39 <benja_> ...ok, so I was just being incredibly stupid again =]
12:47:59 <benja_> didn't turn on optimization. as ibid pointed out, no wonder it didn't unbox :)
12:48:52 <sorear> hehehe.
12:51:26 <glen_quagmire> what is 'in'? is that 'in operator' ?
12:51:58 <sorear> it's part of the let syntax
12:52:03 <Cheery> is it wrong if I use State -monad to construct my stylesheets?
12:52:19 <sorear> let { DEFINITIONS } in EXPRESSION
12:52:32 <Cheery> by keeping the stylesheet and 'heating-point' in the state
12:52:38 <sorear> the braces can be omitted in certain situations
12:52:45 <sorear> > let { x = 2 + 2 } in x
12:52:47 <lambdabot>  4
12:52:51 <sorear> > let { x = 2 } in x + 2
12:52:52 <lambdabot>  4
12:52:54 <sorear> > let { x = 2 } in x + x
12:52:55 <lambdabot>  4
12:52:58 <chessguy> ?src (!!)
12:52:58 <lambdabot> xs     !! n | n < 0 = undefined
12:52:58 <lambdabot> []     !! _         = undefined
12:52:58 <lambdabot> (x:_)  !! 0         = x
12:52:58 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:53:01 <sorear> > let { x = 2 } in (x + x)
12:53:03 <lambdabot>  4
12:53:10 <sorear> glen_quagmire: make sense?
12:53:44 <glen_quagmire> ah i think i see
12:53:55 <sorear> glen_quagmire: if you just want to learn haskell syntax, the Report has a context free grammar
12:54:12 <sorear> http://haskell.org/onlinereport/syntax-iso.html
12:54:13 <lambdabot> Title: Haskell 98 Syntax
12:54:21 <ddarius> sorear: I don't think that's the level he was talking about.
12:54:21 <glen_quagmire> i was a bit confused about lazy evaluation
12:54:37 <chessguy> grammars are hardly ideal for human reading to learn about syntax
12:54:45 <glen_quagmire> in general
12:54:57 <sorear> glen_quagmire: what languages are you most familiar with?
12:55:02 <chessguy> glen_quagmire: you might also like:
12:55:07 <chessguy> ?wiki Lazy_Evaluation
12:55:07 <lambdabot> http://www.haskell.org/haskellwiki/Lazy_Evaluation
12:55:18 <glen_quagmire> i'm using python to prototype my own simple language
12:55:18 <chessguy> ugh
12:55:38 <chessguy> ?wiki Lazy_evaluation
12:55:39 <lambdabot> http://www.haskell.org/haskellwiki/Lazy_evaluation
12:55:40 <glen_quagmire> i want it to be lightweight purely functional..like Lua + Haskell
12:55:57 <sorear> glen_quagmire: you can think of lazy evaluation as replacing every value with a function that returns the value
12:55:59 <chessguy> ok fine. http://www.haskell.org/haskellwiki/Haskell/Lazy_evaluation
12:56:00 <lambdabot> Title: Haskell/Lazy evaluation - HaskellWiki
12:56:44 <glen_quagmire> oh
12:56:53 <sorear> glen_quagmire: so e.g if 'x' and 'y' are lazy values, the lazy value 'x + y' is def x_plus_y(): return (x() + y())
12:57:45 <ddarius> sorear: If the language is purely functional then you probably want memoization as well.
12:57:56 <sorear> glen_quagmire: there's actually a performance hack where evaluating a lazy value overwrites it with the final value so the computation is done at-most-once, but you don't need to worry about that now.
12:58:10 <glen_quagmire> i thought, if 'x' and 'y' are lazy values, they don't get evaluated until they are 'needed'  -- from wikipedia
12:58:27 <glen_quagmire> i was trying to figure out how to 'test' when lazy values are 'needed'
12:58:28 <ddarius> Actually, that hack is what differentiates lazy evaluation (call-by-need) from call-by-name.
12:58:30 <sorear> ddarius: computers are so fast now newbies don't need to know about the difference between call-by-name and call-by-need
12:58:39 <sorear> glen_quagmire: right.
12:58:53 <sorear> glen_quagmire: a value is needed when a larger expression is needed
12:59:03 <ddarius> sorear: The difference can lead to an exponential difference is space usage.
12:59:14 <sorear> glen_quagmire: in the example above, x_plus_y is called when x+y is 'needed'
12:59:16 <ddarius> Infinite ones even.
12:59:25 <sorear> glen_quagmire: but then 'x' and 'y' are needed
12:59:47 <shapr> whee!
12:59:52 <shapr> I'm going to Sweden on Tuesday!
12:59:58 <ddarius> glen_quagmire: They're needed when they are needed.  Just don't do anything about them until you absolutely have to.
13:00:00 <sorear> glen_quagmire: so if the runtime decides it needs a value (like the 'main' value), it automatically traverses the program to find all other needed values.
13:00:18 <sorear> ddarius: no, call-by-name is never infinitely slower than call-by-need
13:00:28 <shapr> Thus main is that one thread that unravels (ravels?) the whole sweater of your program.
13:00:38 <ddarius> sorear: I didn't say anything about speed.
13:00:52 <sorear> never infinitely bigger, either.
13:00:59 <glen_quagmire> this is hard. i need to think about this hard.
13:01:07 <ddarius> let x = 1:x
13:01:12 <zarvok> sorear: in the presence of effects could we write a program that loops under call by name but not under call by need
13:01:25 <zarvok> something along the lines of the jensen device
13:01:34 <zarvok> err, jensen's device, whatever it's called
13:01:42 <sorear> zarvok: there are no effects here :)
13:02:00 <zarvok> sure, sure, but it seemed like you were talking about the strategies in general
13:02:02 <hpaste>  (anonymous) annotated "look, "imperative"" with "(no title)" at http://hpaste.org/1185#a2
13:02:08 <shapr> glen_quagmire: What about making everything either a pointer or a value, and not executing the code under the pointer until something else wants to use that value?
13:03:22 <chessguy> @pl \b -> if (b .&. 1 > 0) then White else Black
13:03:22 <lambdabot> flip (flip if' White . (> 0) . (.&. 1)) Black
13:03:29 <chessguy> eep
13:03:35 <glen_quagmire> in my language, a = [b = 1]. I can either bind a to [b=1], some sort of queue or object. or, evaluate b = 1. bind 1 to b. then bind a to b.
13:05:17 <hpaste>  Cheery pasted "more ideas?" at http://hpaste.org/1210
13:06:53 <Cheery> in that form, it actually starts looking like a language on it's own.
13:07:09 <ddarius> Cheery: Do you need a state monad or would a Writer work?
13:07:24 <Cheery> what is a Writer?
13:07:36 <Cheery> @google haskell Writer monad
13:07:38 <ndm> sorear, pushed your patch and an initial version of a manual
13:07:40 <lambdabot> http://sequence.complete.org/node/231
13:07:40 <lambdabot> Title: Parser with Writer monad | The Haskell Sequence
13:07:46 <ndm> @hoogle Writer
13:07:46 <lambdabot> Control.Monad.Writer :: module
13:07:47 <lambdabot> Control.Monad.Writer.Writer :: (a, w -> Writer w a)
13:07:47 <lambdabot> Control.Monad.Writer.Writer :: newtype Writer w a
13:07:48 <ddarius> It allows you to "output" values along with the computation.
13:08:14 <ddarius> @doc Control.Monad.Writer
13:08:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
13:08:40 <ddarius> @oldwiki MonadWriter
13:08:40 <lambdabot> http://www.haskell.org/hawiki/MonadWriter
13:08:59 <Cheery> hmm....
13:09:13 <Cheery> ddarius: that'd may work too
13:09:44 <Cheery> I need to delve deeper
13:10:29 <glen_quagmire> i think my problem is that = is a function call. not special assignment/definition operation.
13:10:46 <Cheery> I remember haskell wikibook had some helpful story to Writer
13:10:50 <glen_quagmire> maybe = is indeed special. it's difficult to treat it as normal function
13:11:41 <qwr> glen_quagmire: = in haskell just gives name to value. and there are no variables in a value box sense
13:11:44 <chessguy> ?where wikibook
13:11:44 <lambdabot> http://en.wikibooks.org/wiki/Haskell
13:12:18 <sorear> glen_quagmire: in haskell IMO it's best to consider = as part of the let syntax
13:12:46 <ndm> sorear, you were thinking of adding extra syntax for parameterised derivings?
13:12:52 <Cheery> oh well, there weren't
13:13:08 <ndm> sorear, i'm thinking I may want to use that for PlayOn, which Yhc would find handy
13:13:34 <Cheery> qwr: part of module ... where -clause as well, maybe?
13:13:35 <glen_quagmire> thanks
13:13:59 <sorear> ndm: yeah
13:14:12 <ndm> sorear, any initial thoughts on Syntax or anything else yet?
13:15:15 <sorear> ndm: it's a lot easier now with your version of exec-Derive ... invoking runhaskell is pretty brilliant compared to the yucky haskell-parser I was toying with ...
13:15:20 <jcreigh> wait...so the name of the bytestring package is fps?
13:15:23 <sorear> with TH it would be some form of:
13:15:25 <sorear> jcreigh: yes
13:15:31 <jcreigh> foreign packed string or something?
13:15:43 <sorear> $( derive (makeFoo "param") ''MyType )
13:15:48 <ndm> jcreigh: fast packed string
13:15:49 <sorear> Fast Packed String
13:15:55 <sorear> once upon a time,
13:15:56 <jcreigh> ah
13:16:09 <sorear> bos wrote a PackedString module
13:16:18 <sorear> this was before . was legal in module names
13:16:35 <sorear> it used less memory, but it was slow - slower even than [Char]
13:16:41 <Cheery> @oldwiki Monoid
13:16:42 <lambdabot> http://www.haskell.org/hawiki/Monoid
13:16:55 <Cheery> oh well
13:17:00 <Cheery> I guess this gives better info
13:17:03 <Cheery> @info Monoid
13:17:04 <lambdabot> Monoid
13:17:10 <sorear> Cheery: wikipedia will tell you what a monoid is
13:17:14 <sorear> pretty well IMO
13:22:00 <DRMacIver> It's odd. Monads, laziness, etc. don't cause me nearly as much trouble as one simple feature of Haskell: All those damn type aliases. :)
13:22:53 * DRMacIver keeps getting caught out and trying to figure out how to get from type Foo to type Bar only to discover eventually that they're already the same type.
13:23:36 <sorear> @hoogle String -> FilePath
13:23:37 <lambdabot> Distribution.Compat.FilePath.changeFileExt :: FilePath -> String -> FilePath
13:23:37 <lambdabot> Distribution.Compat.FilePath.joinFileExt :: String -> String -> FilePath
13:23:37 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
13:23:45 <sorear> aww, no 'id' :)
13:23:49 <sorear> @hoogle+
13:24:25 <DRMacIver> sorear: Yeah, that was the first one that caught me out a while ago. :)
13:25:10 * sorear wonders what Hoogel 4 will think of String -> FilePath
13:25:17 <Cheery> aah, that Writer -thing may be exactly what I want
13:26:31 <ndm> sorear, Hoogle 4 will get id, Hoogle 3 doesn't
13:26:55 <ndm> for Hoogle 3 a type is completely distinct
13:34:38 <sorear> ndm: how useful is it to be able to say "derive everything"?  esp. that we want to support lots of little-used classes, and classes in unreleased libs (BinaryDefer anyone?)
13:35:05 <ndm> sorear, if i wanted to add a new deriving, how stable is the API - i.e. will i big holding back future changes, or is it ready for that now?
13:35:11 <sorear> ndm: I have an idea to eliminate the need for StdDerivations by giving Derive-the-exec knowledge of our naming conventions
13:35:36 <ndm> sorear, i'm not sure its that useful to derive everything, as you say, you'd have to import loads of rare libraries
13:35:55 <ndm> sorear, that actually is better for derive.exe, i currently don't validate that the class names are valid
13:36:16 <sorear> ndm: I think it's pretty stable - we don't really need to support monadic foo or other output funny business
13:36:18 <ndm> since to do so would require GHC(i) only derive.exe, while at the moment it is standard haskell
13:36:32 <ndm> if people want monadic foo, they can add it locally
13:36:42 <ndm> ok, i'll try and add another deriving
13:37:02 <ndm> sorear, i'll commit my new derive.exe changes - then you can try and remove StdDerivings
13:37:03 <Cheery> so, If I specify how my data structure gets concatted and what is it when empty, I can use Writer -monad for my structure :)
13:37:20 <sorear> Cheery: yeah
13:37:45 <sorear> ndm: we will probably be extending the DataCtor etc types - but all that will break is that you'll get a pattern match error when you try to derive for a type that wasn't supported at all when you wrote the deriver
13:38:07 <sorear> ndm: come to think of it, that might be a good reason to have accessor functions / compatibility views
13:38:34 <ndm> sorear, we can worry about that later - it doesn't sound that big a deal, and it sounds like little tweaks, rather than throwing away what we've got
13:38:43 <sorear> ok.
13:39:06 <ndm> sorear, all the derive.exe changes are pushed, feel free to remove the standard derivings library
13:47:12 <chessguy> hm. i swear, Ctrl+x never made x-chat quit before
13:47:33 <rashakil> it doesn't make it quit for me
13:48:35 <nominolo> maybe Ctrl-Shift-X?
13:48:48 <nominolo> ie, caoslock
13:48:49 <chessguy> i'm trying to cut
13:48:55 <nominolo> er, capslock
13:50:02 <sorear> chessguy: muahaha.  I reconfigured my kbd layout to discard capslk presses ... and haven't regretted it!
13:50:26 <sorear> :t elemIndex
13:50:27 <jcreigh> discard? You didn't go for the capslock -> ctrl or capslock -> esc hack?
13:50:28 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
13:50:40 <chessguy> this has nothing to do with capslock
13:50:53 <sorear> jcreigh: nope
13:51:22 <sorear> jcreigh: capslock is in a very inconvienient place - if i were to make it anything, I would make it another shift
13:54:39 <chessguy> sigh
13:56:05 <Cheery> good night people, tomorrow you'll hopefully see my cool StyleSheet shitter
13:57:05 <sorear> is that a typo?
13:57:10 <sorear> or sarcasm?
13:57:30 <sorear> or a freudian slip?
13:58:09 <NichardRixon> all three!
13:58:15 <Cheery> what is a freudian slip?
13:58:20 <NichardRixon> the goose that lays the golden stylesheets
13:59:01 <NichardRixon> Cheery, a freudian slip is when you say one thing but mean your mother
13:59:37 <chessguy> that's not quite the full efinition
13:59:59 <chessguy> oh, i read it wrong
14:00:02 <Cheery> oh, it was ALSO in the wikipedia...
14:00:04 <chessguy> ?all-dict freudian
14:00:06 <lambdabot> *** "Freudian" gcide "The Collaborative International Dictionary of English v.0.48"
14:00:06 <lambdabot> Freudian \Freudian\ prop. a.
14:00:06 <lambdabot>    of or pertaining to Sigmund Freud; as, Freudian theories.
14:00:06 <lambdabot>    [WordNet 1.5] Frey
14:00:06 <lambdabot>  
14:00:06 <Cheery> damn
14:00:08 <lambdabot> [4 @more lines]
14:00:12 <chessguy> @more
14:00:13 <lambdabot> *** "Freudian" wn "WordNet (r) 2.0"
14:00:13 <lambdabot> Freudian
14:00:14 <lambdabot>      adj : of or relating to Sigmund Freud or his psychoanalytic ideas;
14:00:16 <lambdabot>            "Freudian theories"
14:00:18 <chessguy> bah
14:00:26 <shapr> humbug!
14:00:37 <chessguy> @get-scrooge
14:00:37 <lambdabot> Unknown command, try @list
14:00:38 <NichardRixon> actually, it probably comes out better as "a freudian slip is when you say one thing but mean a mother"
14:01:01 <sorear> <Cheery> ... my cool StyleSheet shi*t*ter  <- ?
14:01:51 <chessguy> @pl f $ b `s` 2
14:01:52 <lambdabot> f (b `s` 2)
14:02:12 <chessguy> @pl 2 + f $ b `s` 2
14:02:12 <lambdabot> 2 + f $ b `s` 2
14:02:13 <Cheery> 'cool' is sarcasm, 'shitter' is a freudian slip, 'my' is a typo
14:03:28 <Cheery> Writer gives a mechanical feel, while I have biological feel when handling lambdas, rest you can conclude yourself
14:03:55 <Cheery> or... maybe not
14:04:00 <ndm> hmm, writing definitions in template Haskell AST isn't particularly fun
14:04:09 <ndm> its quite a bit of work to figure out what it should be...
14:05:29 <sorear> would probably be easier if Langauge/Haskell/TH/Syntax.hs used less -- and more -- | ?
14:05:39 <Cheery> 'my' is a typo in the sense that it is nonsense to own something you have just happened to have written
14:06:14 <gh_> hi, what is the new place for the System module in ghc ?
14:06:21 <ndm> sorear, i haven't looked at it yet, so i can't really complain too much
14:06:33 <ndm> gh_, which particular function were you looking for
14:06:45 <sorear> gh_: you should just use System
14:06:51 <ndm> gh_, it got sent in lots of directions (System.Directory/System.Process, System.Environment)
14:06:54 <sorear> gh_: remember to always use --make
14:06:57 <gh_> getArgs
14:07:06 <ndm> @index getArgs
14:07:07 <lambdabot> System.Environment
14:07:11 <gh_> the problem is I want to use Cabal
14:07:20 <sorear> use System unless you have a different reason to make your program non-portable
14:07:24 <Igloo> ndm: Use runQ [| ... |] >>= print to see what it should look like
14:07:34 <Cheery> gn
14:07:36 <Igloo> ndm: And where possible, just use quasiquote syntax in the first place
14:07:40 <ndm> Igloo: oh, that looks handy
14:07:54 <gh_> and Cabal won't build my program unless I use the haskell98 package, and it's caused by my use of System
14:07:57 <ndm> Igloo: not possible, we're constructing one AST from another
14:08:02 <gh_> i'll try Sys.Env
14:08:08 <sorear> Igloo: quasiquote syntax blows up hard on this problem
14:08:20 <sorear> Igloo: I'm using the TH AST to write portable code
14:08:36 <sorear> Igloo: and quasiquote insists on making names like GHC.Base.+
14:08:48 <gh_> ndm: thanks
14:08:57 <sorear> Igloo: also we're not in Q (but that could be fixed)
14:09:11 <matthew-_> ndm: is filepath going to go into hackage?
14:09:34 <sorear> gh_: what's wrong with using haskell98?  more portable than base...
14:09:44 <Igloo> sorear: That's just for ghci so you can see what you need to write
14:09:58 <Igloo> sorear: And it isn't in Q either, runQ give you something in IO
14:10:15 <gh_> sorear: i don't know, base was in the given example
14:10:22 <sorear> Igloo: I agree with the runQ ... suggestion.  I'm saying we can't "just use quasiquote syntax in the first place"
14:10:57 <ndm> matthew-_: it will be in GHC 6.6.1, yes, it shoudl be in Hackage
14:11:12 <sorear> ndm: the ghci example requires :set -fth and :m + Language.Haskell.TH, iff you're still stuck
14:11:29 <matthew-_> ooo. ok, didn't know it was going into ghc. If I use _0_11, that'll still work right?
14:11:44 <ndm> sorear, i'm working on another aspect of the problem (what the translation should be), but will remember that
14:11:54 <ndm> matthew-_: no, the Version_* all go once its with GHC
14:12:25 <ndm> matthew-_: you should now move to System.FilePath - its now a frozen and stable API
14:12:40 <chessguy> !paste
14:12:40 <hpaste> Haskell paste bin: http://hpaste.org/
14:12:45 <matthew-_> ndm: ok, and that's still your stuff?
14:13:20 <hpaste>  chessguy pasted "My head hurts...is this even close to right as an MSB finder?" at http://hpaste.org/1211
14:13:50 <matthew-_> ndm: ahh, ok, I understand what you mean now.
14:14:45 <sorear> chessguy: yes, but atypical style
14:14:59 <chessguy>  what would be more typical?
14:15:42 <sorear> I assume "type BitBoard = Word64" ?
14:15:54 <chessguy> yes, Int on my machine
14:16:26 <sorear> Actually, no it's wrong.
14:16:32 <sorear> precedence woes.
14:17:11 <hpaste>  sorear annotated "My head hurts...is this even close to right as an MSB finder?" with "line up masks; use normal guard layout; fix prec issue" at http://hpaste.org/1211#a1
14:17:38 <chessguy> huh. why can't i use $ there
14:17:52 <sorear> because $ is lower prec than +
14:18:13 <sorear> 1 + (*2) $ 10 parses as  (1 + (*2)) $ 10
14:18:20 <sorear> oh, wow
14:18:30 <chessguy> hm?
14:18:33 <sorear> asymmetrical fixities would make this more intuitive
14:18:45 <sorear> didn't realise there was a use for them before
14:18:59 <chessguy> ok, so next question: is this efficient?
14:19:10 <sorear> pretty
14:19:26 <sorear> it should unbox nicely, and iterate at most 6 times
14:19:48 <sorear> probably won't reduce to a BSF insn though :)
14:19:53 <sorear> :( rather
14:20:07 <sorear> too bad ghc doesn't have anything like gcc's __asm__
14:20:18 <chessguy> anything i can do to speed it up?
14:20:37 <sorear> I think it might do better with an accumulating parameter
14:20:40 * sorear looks at Core
14:22:05 <sorear> oh, fun, 573 lines of core!
14:22:24 <sorear> reduce to 194 with -O
14:23:39 <sorear> code size is cut in half replacing the > with /=
14:24:06 <sorear> Ouch!
14:24:19 <sorear> GHC Core contains:
14:24:25 <sorear>                       `cast` (CoUnsafe GHC.Base.Int GHC.Prim.Int# :: GHC.Base.Int ~ GHC.Prim.Int#)
14:24:44 <sorear> I'm pretty sure that means (unsafeCoerce# :: Int# -> Int)
14:24:57 <chessguy> is that slow?
14:25:09 <sorear> no, casts are erased
14:25:19 <sorear> they're just there to appease the type checker
14:25:31 <sorear> it does look crashy however :/
14:25:45 <chessguy> crash?
14:25:52 <ndm> sorear, Clean has _asm
14:26:29 <sorear> apparently it doesn't [crash]. wierd.
14:26:48 <sorear> yow!
14:26:55 <mahogny> hm. reminds me of a question; would it be possible to merge C-code with haskell to have it inlined? would cut down on a lot of wrapper code and maybe a few IO's as well
14:26:56 <sorear> chessguy: what is (first 0)?
14:27:12 <sorear> currently, it's a pattern match error
14:27:16 <chessguy> ermm. should probably be an error
14:27:54 <sorear> chessguy: ok, the recursion isn't optimized out
14:28:07 * sorear rewrites using an accumulating parameter!
14:28:25 <chessguy> maybe it would be better of 0x1 were indexed with a 1 instead of a 0?
14:30:00 <sorear> oh wow.
14:30:29 <sorear> the unsafeCoerce# mentioned above was used to cast error "Y.hs:(5,0)-(10,48)|function first" to Int#
14:30:46 <sorear> because error has type forall (e :: *) . String -> e
14:30:52 <sorear> and Int# has kind #
14:31:02 <sorear> so the typechecker would normally complain
14:31:11 <sorear> but since error never actually returns
14:31:22 <sorear> the blatantly bogus coercion is actually safe
14:31:38 <sorear> ghc is a very subtle beast, it seems
14:43:56 <DukeDave> Hi guys, am I right in thinking the Read class is a little arkward :S
14:44:04 <DukeDave> *awkward
14:45:38 <sorear> Read is broken in every way!
14:45:44 <sorear> @seen malcolmw
14:45:44 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 6h 43m 13s ago, and .
14:45:58 <sorear> @goo malcolm text parse blog
14:46:01 <lambdabot> http://nhc98.blogspot.com/
14:46:01 <lambdabot> Title: malcolm
14:46:14 <sorear> I think it's on there.
14:46:21 <sorear> when you want code:
14:46:24 <sorear> @where polyparse
14:46:25 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse
14:47:21 <DukeDave> hm, I think this might be a little over the top for me :)
14:47:36 <zarvok> here's the post you want:
14:47:38 <DukeDave> (reading in pairs of ints!)
14:47:39 <zarvok> http://nhc98.blogspot.com/2005/11/replacement-for-read-class.html
14:47:40 <lambdabot> Title: malcolm: Replacement for Read class
14:48:11 <zarvok> yeah, you may not care about all this stuff :)
14:50:43 <Cale> DukeDave: The read class would be better replaced by a proper parser combinator library, but it does its job reasonably well for basic reading of datatypes.
14:51:18 <Cale> DukeDave: How are the pairs of Ints formatted?
14:51:41 <Cale> If they're like "(57,12)", you can just apply read straight off.
14:51:51 <Cale> > read "(57,12)" :: (Int, Int)
14:51:53 <lambdabot>  (57,12)
14:59:47 <Cale> I think probably the easiest way to create an instance of Read is to use ReadP and use the ReadP_to_S function to get reads.
15:00:42 <Cale> (er, readsPrec, but you can ignore the precedence parameter.)
15:02:04 <Cale> If you really need precedence parsing, there's ReadPrec, which ReadP lifts into as well.
15:03:32 <araujo> Hello
15:03:36 <Cale> Hi
15:03:42 <araujo> :-)
15:03:46 <araujo> how you doing Cale ?
15:03:54 <Cale> all right
15:04:39 <sorear> hello!
15:05:14 * araujo packs sorear into a State transformer
15:05:42 * sorear execStates himself
15:06:21 <araujo> :-)
15:06:26 <sorear> Wow, this isn't something you see every day.
15:06:33 <sorear> Almost unbelievable, even.
15:06:45 <sorear> GHC's "probable cause" was correct.
15:06:52 <araujo> !?
15:07:42 <Cale> sorear: huh?
15:08:01 <Cale> You mean for a type error?
15:08:03 <sorear> Probable cause: ex_type is applied to too few arguments
15:08:07 <sorear> Cale: yeah
15:08:51 <Cale> Yeah, I usually don't pay too much attention to it, but it's not that uncommon for it to be right.
15:16:06 <sorear> Can't understand parse error:
15:16:08 <sorear> *Data.Derive.Eq Data.Derive.TH> [| let { $(derive makeEq ''Maybe) } in 2 |]
15:16:15 <sorear> <interactive>:1:34: parse error on input `}'
15:16:16 <ddarius> Obviously, GHC should use a learning algorithm of some sort to determine what causes are actually the probably ones.
15:16:36 <sorear> What am I doing wrong?
15:17:31 <lemmih> sorear: What's the type of 'derive'? I'm not sure you can splice bindings like that.
15:18:05 <sorear> Derivation -> Name -> Q [Dec]
15:18:08 <DukeDave> Cale! Thanks for info, am slowly battling through now,
15:18:12 <sorear> I just want to test it!
15:18:19 <DukeDave> just using my own function
15:18:32 <sorear> *Data.Derive.Eq Data.Derive.TH> [d| $(derive makeEq ''Maybe) |]
15:18:32 <sorear> <interactive>:1:6:
15:18:32 <sorear>     Declaration splices are not permitted inside declaration brackets
15:18:41 <sorear> so I had to use expression brackets
15:18:45 <sorear> hence the let
15:19:11 <sorear> ghci and th don't get along :(
15:19:16 <Igloo> You can't splice non-toplevel declarations in
15:19:16 <Cale> DukeDave: okay. What is it that you're going for?
15:19:17 <lemmih> sorear: Why the brackets at all?
15:19:27 <sorear> Igloo: why not?
15:19:28 <Igloo> You could splice a whole let expression in, though
15:19:42 <chessguy> sorear: any luck with the accumulating parameter method?
15:19:56 <sorear> lemmih: this reason: vvv
15:19:58 <sorear> *Data.Derive.Eq Data.Derive.TH> runQ (derive makeEq ''Maybe)
15:19:58 <sorear> Template Haskell error: Can't do `reify' in the IO monad
15:19:58 <sorear> *** Exception: user error (Template Haskell failure)
15:20:11 <Igloo> sorear: Because then GHC doesn't know where names are bound
15:20:39 <sorear> chessguy: oh, I forgot :)  anyway, acc.parm. made the Core tail recursive.
15:20:49 <sorear> Igloo: it can't run the splice?
15:21:00 <sorear> Igloo: then it would know where names are bound
15:21:24 <chessguy> sorear: do you have the code?
15:21:33 <sorear> Are all these weird restrictions documented anywhere?  (I ask as a would-be implementor...)
15:21:49 <sorear> chessguy: yes, but it's pretty straitforward
15:22:19 <hpaste>  sorear pasted "acc. par. first" at http://hpaste.org/1212
15:22:21 <Igloo> The splice can depend on values that are passed as an argument
15:22:32 <Igloo> sorear: Implementor for what? yhc/
15:22:34 <sorear> it can?!?
15:22:56 <chessguy> ohh, i see
15:22:57 <sorear> Igloo: hv, actually.  but yes part of the Yhc System
15:23:21 <sorear> Igloo: my project to rewrite hugs for the 21st century
15:24:02 <Igloo> sorear: Yes, e.g.  let f x = [| $( lift x ) |] in runQ (f 'a') >>= print
15:24:41 <sorear> That's quasiquoted, I don't think it counts
15:24:58 <sorear> because we can simply compile compiler logic
15:25:09 <Igloo> Yours was quasi-quoted too
15:25:40 <sorear> let f x = [| let $( foo x ) in bar |] -- I think I could translate this
15:25:46 <Igloo> But it's not allowed even if not. I don't think there's any fundamental reason why it couldn't be, though
15:26:07 <chessguy> sorear: any particular reason you used Word32?
15:26:19 <sorear> chessguy: because I have a 32-bit machine
15:26:26 <chessguy> so why not Int
15:26:32 <Igloo> And I don't know of a doc I would be confident describes exactly the restrictions other than the GHC source
15:26:39 <chessguy> oh, never mind
15:26:51 <sorear> not even the th paper?
15:26:55 <chessguy> sorry, i thought you were using Word32 for the accumulator
15:27:06 * sorear gives up, stops trying to use ghci
15:32:09 <sorear> ANN: TH deriving in Data.Derive works
15:32:40 <Igloo> What does that mean?
15:33:02 <sorear> $( derive makeEq ''Foo ) generates a working Eq instance
15:34:03 <Igloo> Ah, right
15:35:01 <sorear> I find it interesting that TH has no way to express infix function definitions.
15:35:29 <sorear> Foo a1 a2 == Foo b1 b2 = (a1 == b1) && (a2 == b2)  kind of thing
15:35:50 <sorear> just about everything else can be
15:36:00 <paulc> hello
15:36:11 <sorear> hi.
15:36:31 <paulc> I have a question about haskell's evaluation order
15:37:11 <sorear> go ahead.
15:37:16 <paulc> suppose I have a function, f,  defined by:
15:37:35 <paulc> f(g x) = whatever
15:37:42 <sorear> won't work
15:37:48 <paulc> okay
15:37:51 <paulc> how come?
15:38:09 <sorear> you can't pattern match on thunks
15:38:11 <sjanssen> you can't pattern match on application
15:38:24 <sorear> since the compiler is free to eval (g x) at any time
15:38:38 <sorear> so it might not still be there when f is doing case analysis
15:38:47 <paulc> so evaluation is not 'normal order'?
15:38:55 <sorear> no.
15:39:00 <sorear> it's arbitrary order.
15:39:11 <paulc> hmm, ok
15:39:49 <ddarius> That wouldn't be a good idea anyways.
15:39:53 <paulc> can you explain your statement 'so it might not still be there when f...'
15:40:01 <sjanssen> yeah, what would the types of 'g' and 'x' be?
15:40:06 <sjanssen> they could be anything!
15:42:15 <paulc> hum, I think my problem is that I am think of haskell's semantics as being like a general term-rewriting language like mathematica
15:42:22 <sjanssen> paulc: what happens when you apply: f 1
15:42:34 <ndm> hi augustss_, you were looking for me?
15:43:10 <paulc> sjanssen: um, well, suppose there is another equation for f, f 1 = whatever
15:43:37 <paulc> otherwise I guess it would be undefined
15:44:01 <sjanssen> let's look at f (succ 1)
15:44:06 <paulc> ok
15:44:24 <sjanssen> you want the match to succeed with g bound to succ and x to 1
15:44:34 <paulc> sure
15:45:47 <sjanssen> this violates a primary rule in Haskell: referential transparency
15:46:07 <paulc> how does that violate referential transparency?
15:46:17 <sjanssen> that states that any subexpression may be replaced with it's value
15:46:21 <sjanssen> succ 1 == 2
15:46:30 <sjanssen> f 2 doesn't take the first match
15:47:17 <paulc> I see...
15:47:20 <goltrpoat> quick question.. shouldn't i be able to eliminate dictionary passing by generating specific instantiations of polymorphic functions on demand at the evaluation site, by backtracking from the entry point?
15:47:41 <ndm> goltrpoat: yes, you can, its called specialisation
15:47:42 <goltrpoat> or is there ever a situation where you don't know what the specific type is
15:47:45 <sorear> that requires introspection
15:48:00 <sorear> and it can require creating an infinite amount of code
15:48:18 <sorear> http://members.cox.net/stefanor/MultispecializeKiller.hs iirc
15:48:45 <sorear> I re-discovered this .. a program whose use of types cannot be statically bounded
15:48:46 <sjanssen> paulc: does that clarify?
15:49:03 <goltrpoat> well, the backtracking from the entry point bit was intended to eliminate the potentially infinite amount of code (with the caveat that specific types are known statically)
15:49:08 <sorear> Oleg and CCShan discovered it a few years before me, in the implicit configurations maper
15:49:16 <paulc> I'm thinking about it...
15:49:19 <goltrpoat> ah interesting.. thanks
15:49:22 <sorear> Oh so you wanted runtime code gen?
15:49:33 <goltrpoat> sorear:  no, compile time
15:49:44 <goltrpoat> if it's runtime, then you might as well do dictionary passing, no?
15:50:47 <goltrpoat> sorry, should probably give some background.. i'm talking about eliminating it compiler-side
15:51:15 <paulc> so, sjanssen --
15:51:28 <paulc> what is allowed to appear on the lhs of an equation?
15:51:45 <sorear> a pattern
15:51:51 <sorear> @where report
15:51:51 <lambdabot> http://www.haskell.org/onlinereport/
15:52:00 <sorear> section "declarations and bindings"
15:52:19 <sorear> we only allow things that can only match at one stage of a normal order reduction chain
15:52:25 <sorear> this eliminates ambiguity
15:52:43 <goltrpoat> speaking of that..
15:52:46 <sorear> in short - constructors of patterns and variables
15:52:51 <goltrpoat> ndm:  were you the guy who came up with the generalized pattern proposal?
15:52:58 <paulc> sorear - I'm not sure what you mean by that
15:53:14 <sjanssen> paulc: constructors and variables
15:53:38 <sjanssen> constructors are things like: Nothing, True, False, Nothing, [], etc.
15:53:49 <ndm> goltrpoat: yeah, i guess - with functions as matches?
15:53:53 <goltrpoat> yeah
15:53:58 <ndm> yep :)
15:54:16 <goltrpoat> iirc, you'd put together a prototype?  how did that work out
15:54:16 <ndm> it wasn't a proposal for the language as such, merely another way of seeing rules as
15:54:41 <ndm> it works fine, but it was for a compilation strategy, the rule was that ignoring the function matches souldn't change the code
15:54:49 <ndm> i.e. you can't rely on them, only hint at them
15:55:00 <goltrpoat> oh i see
15:56:01 <goltrpoat> ah right, makes sense.
15:59:47 <goltrpoat> blah.  i remember reading on the jhc site that it eliminates dictionary passing by "using the entire lambda cube," and i have zero clue how that remotely applies
16:00:03 <ndm> i can do it, using specialisation
16:00:05 <goltrpoat> but i think i can see a way to eliminate it by static analysis
16:00:15 <ndm> i also have no idea what a lambda cube is...
16:00:47 <ndm> there was also a paper by Mark Jones on how to do it
16:01:06 <ndm> @google partial evaluation dictionaries mark jones
16:01:10 <lambdabot> http://citeseer.ist.psu.edu/jones94dictionaryfree.html
16:01:11 <lambdabot> Title: Dictionary-free Overloading by Partial Evaluation - Jones (ResearchIndex)
16:01:12 <goltrpoat> barendregt's classification of things in coquand's calculus of constructions
16:01:17 <ndm> goltrpoat: ^^^
16:01:24 <goltrpoat> oh cool, thanks
16:04:00 <goltrpoat> sorear:  getting close to wrapping up TC btw :)
16:04:23 <sorear> goltrpoat: I've been distracted :)
16:04:38 <sorear> goltrpoat: I still don't even have my haskell renamed
16:04:50 <sorear> goltrpoat: but I do have a working TH-based deriving engine!
16:04:55 <goltrpoat> ah nice
16:05:24 <ndm> woohoo, and shortly we'll have Play deriving
16:05:26 <sciolizer> sorear: How does it handle functions of kind #?
16:05:37 <sorear> sciolizer: no such thing
16:05:41 <ndm> I think we'll need to tidy up the Binary instances, people will complain...
16:05:44 <sorear> @ki (->)
16:05:46 <lambdabot> ?? -> ? -> *
16:05:55 <sorear> sciolizer: so all functions have kind *
16:06:32 <goltrpoat> is # really necessary?  as in, can't it be transparent?
16:06:42 <sorear> ndm: you don't like (>>) (return ()) (return ())? ;)
16:07:11 <shachaf> @pl \v l -> l >>= (:[v])
16:07:11 <lambdabot> (=<<) . flip (:) . return
16:07:20 <goltrpoat> seems like that makes the typechecker aware of boxing semantics, and i'm not sure why that's necessary
16:07:29 <sorear> ndm: yes, one of my longerish plans was to create a Data.Derive.Nicify module which does peephole optimization-y things
16:07:39 <sorear> ndm: like using infix, and the monad laws
16:07:56 <ndm> sorear, i don't overly care, but once the code gets squirted into modules, people will complain
16:08:10 <ndm> sorear, using infix isn't an issue, more just return 1 >>= \tag -> case
16:08:20 <ndm> not for efficiencies sake, but to produce pretty code :)
16:08:22 <sorear> ndm: unfortunately we don't have Play for Language.Haskell.TH.Syntax ;)
16:08:33 <ndm> sorear, i'm just writing Play, so we could soon :)
16:08:44 <goltrpoat> what's Play?
16:08:48 <ndm> @where Play
16:08:49 <lambdabot> I know nothing about play.
16:08:58 <ndm> goltrpoat: SYB variant, my version
16:09:14 <sorear> goltrpoat: main advantage: it's statically typed!
16:09:15 <goltrpoat> ah cool
16:09:23 <goltrpoat> ooh
16:09:33 <goltrpoat> link?
16:09:35 <ndm> and no rank-2 types
16:09:40 <sorear> SYB just LOVES typeable...
16:09:45 <goltrpoat> hehe yeah
16:09:52 <sorear> @google play with your boilerplate
16:09:54 <ndm> http://www.cs.york.ac.uk/fp/darcs/play/play.htm
16:09:54 <lambdabot> Title: Play With Your Boilerplate
16:09:54 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/play/play.htm
16:09:54 <lambdabot> Title: Play With Your Boilerplate
16:10:19 <goltrpoat> thanks
16:10:26 <ndm> still under development, the document won't actually work with teh code
16:10:32 <ndm> all the function names have changed, to be more logical
16:11:04 <goltrpoat> cool name btw
16:11:45 <ndm> thanks, my supervisor wants me to change it from Play, but I like it
16:12:35 <sorear> Was he also the one who wanted yhc -OMG!! ?
16:13:01 <ndm> sorear: no, no name suggestions from him for that
16:26:48 <sorear> ndm: Now that TH-deriving works, any reason not to use that framework in the exec Derive?
16:26:48 <sorear> It seems like it would simplify by avoiding the need to rewrite deriving(Typeable,Data).
16:27:00 <paulc> it seems like in most cases, when defining functions, you can avoid explicitly declaring the type
16:27:13 <sorear> virtually all
16:27:19 <paulc> aside from documentation
16:27:27 <paulc> is there any reason to make it explicit?
16:27:37 <sorear> not much
16:27:51 <sorear> a more restrictive sig can make code faster, sometimes
16:28:09 <paulc> ok
16:28:10 <sorear> and polymorphic recursion is incompatible with inference
16:28:21 <paulc> polymorphic recursion?
16:28:22 <ndm> sorear, no particular reason - I am just more familiar with the SYB
16:28:46 <ndm> sorear: woudl also have the advantage that modules imported would work, currently if you import and use a type without SYB on it, it won't
16:29:23 <ndm> sorear: feel free to rewrite :) - although i would like it if the actual Derive.hs main program could still be loaded/run with Hugs
16:29:34 <sorear> How intelligent is windows about long command lines?
16:29:40 <ndm> but not if there is something particularly compelling
16:29:51 <ndm> sorear: generally not, is a safe assumption
16:29:51 <sorear> Linux fails at a hardcoded limit of 128k chars
16:30:03 <ndm> sorear: i think 32K may be the limit, or 64
16:30:16 <sorear> oh, I guess I'll keep using the tempfile approach :)
16:30:28 <sorear> as opposed to crafting ghci command lines
16:30:52 <sorear> figure 100-ish chars per derivation
16:32:00 <ndm> yes, i don't think the command line is long enough
16:32:40 <sorear> bye, family calls for dinner.
16:33:10 <ndm> bye
16:34:29 <dons> http://www.iseff.com/2007/03/is-haskell-going-to-be-next-it-language.html
16:34:33 <lambdabot> Title: iseff, By Ian Sefferman: Is Haskell going to be the next 'it' language?, http://tinyurl.com/yvooqq
16:39:08 <goltrpoat> there's been a weird shift in what drives language popularity, in that it's still merit-based, but the merit focus has been towards web apps, for some godawful reason
16:39:23 <goltrpoat> past 5-7 years or so.
16:40:18 <goltrpoat> (case in point:  java)
16:40:23 <dons> yeah :/
16:40:54 <goltrpoat> i really hope that ends some time soon.
16:41:54 <jcreigh> sorry, but worse is better.
16:52:39 <augustss> yeah, worse is better.  haskell is not going to be the next big thing.  haskell often requires you to think.  and we don't want that now, do we?
16:53:15 <jcreigh> right. if you can't sit down and mutate variables in five minutes, most people are going to leave.
16:56:28 <ddarius> > runST (do ref <- newSTRef 0;forM_ [1..10] (\i -> do acc <- readSTRef ref; writeSTRef ref (acc*i)); readSTRef ref)
16:56:29 <lambdabot>   Not in scope: `readSTRef'
16:56:38 <jcreigh> see? :)
16:57:07 <goltrpoat> well, it's not that it requires you to think, it's that it requires you to more or less forget everything you know about languages with mutable state, and people seem to have a hard time with that.
16:57:38 <ddarius> > Control.Monad.ST.runST (do ref <- Data.STRef.newSTRef 0;forM_ [1..10] (\i -> do acc <- Data.STRef.readSTRef ref; Data.STRef.writeSTRef ref (acc*i)); Data.STRef.readSTRef ref)
16:57:38 <lambdabot>   Not in scope: `Data.STRef.readSTRef'
16:57:53 <goltrpoat> architecturally, i think i do a bit less thinking in haskell than i do in c++.
16:58:09 <ndm> goltrpoat: only after you've done the thinking to change your mindset
16:58:14 <goltrpoat> exactly.
16:58:29 <ndm> plus Haskell favours the people who reason about their programs in their heads, that isn't most people - but it is most of the good people
16:58:35 <ddarius> @index readSTRef
16:58:36 <lambdabot> Data.STRef.Lazy, Data.STRef, Data.STRef.Strict
16:59:00 <augustss> I think Haskell will gain popularity among the good people.
16:59:19 <goltrpoat> k, my laptop is trying to shut down, i don't think it likes running on 5% battery.
16:59:22 <goltrpoat> bbl.
16:59:29 <augustss> ndm: I read your paper.  catch is very cool stuff
16:59:53 <ndm> augustss: cool, is the version of your paper with System.FilePath in?
17:00:05 <ddarius> @version
17:00:06 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
17:00:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:00:08 <augustss> but the firstification relies on Reynolds for the tricky cases
17:00:30 <augustss> it had FilePath
17:00:44 <ndm> the firstification never actually gets to Reynolds ever
17:00:52 <augustss> I'll try and give you some feedback tomorrow
17:00:55 <ndm> its a backup, but a completely unused backup
17:01:10 <ndm> since then I checked FiniteMap, and it turns out you can crash it :-)
17:01:15 <augustss> ndm: no, in most programs higher order functions can be macro expanded
17:02:25 <ndm> augustss: i can send you an updated draft if you want, not much new stuff, but some small language improvements
17:02:31 <ndm> augustss: what do you mean, macro expanded?
17:03:18 <augustss> I should put "macro expanded" in quotes.  what I mean is basically what you're doing
17:03:41 <augustss> you inline enough to see that there's nothing higher order actually going on
17:04:22 <ndm> the specialisation is the important bit
17:04:31 <augustss> absolutly
17:04:38 <ndm> more so than the inlining, although the inlining gets over the humps, when they occur
17:05:02 <augustss> well, you can specialise if you don't inline
17:05:05 <augustss> can't
17:05:48 <ndm> in some cases, yes, but in most cases the specialisation doesn't require the inlining at all
17:06:31 <ndm> the inlining only needs to fire when you put functions inside constructors, such as tuples
17:06:41 <augustss> how can you get rid of 'map foo xs' if you don't inline map?
17:07:16 <augustss> but that's what you call specialise, i guess :)
17:07:32 <ndm> map foo xs, you generate a specialised map with foo bound in
17:07:44 <ndm> i guess this new map is map foo xs inlined once
17:07:44 <augustss> yes, but i see it as inlining map.
17:07:56 <ndm> yeah, thats certainly one way of seeing it
17:08:22 <ndm> i guess i don't see it that way because implementationally it doesn't call the inling function :)
17:08:24 <augustss> anyway, that this works in almost all cases comes as no surprise
17:08:43 <ndm> has anyone else done this, that you are aware of?
17:08:46 <ddarius> ndm: You reference partial evaluation?
17:09:05 <augustss> ndm: doesn't mlton do a lot of that?
17:09:05 <ndm> ddarius: yes, specifically Jones's stuff for dictionary removal
17:09:12 <ddarius> Cool.
17:09:21 * ddarius too lazy to check right at that second.
17:09:36 <ndm> augustss: not sure, it may do it, but i'm not sure its going for (or gets) first-order
17:09:55 <augustss> i don't know of any serious lazy language implementation that has done it
17:10:13 <ndm> good good :)
17:11:04 <ddarius> ndm: You sent that EXE paper to Matt Naylor?  And if so, what did he think of it if he's read it yet?
17:11:16 <augustss> it's been discussed
17:11:25 <ndm> ddarius: he says its very similar to his work, although he goes backward, rather than forward
17:12:05 <ndm> augustss: i actually have a more complex variant than in that paper which is linear time to execute in the size of the resulting program
17:12:14 <ndm> unfortunately there is no space in the paper
17:12:53 <augustss> ndm: do you have some kind of cutoff when the program would result in an infinite specialization?
17:13:23 <ndm> augustss: currently its mainly implemented as Ctrl+C, in practice it never happens
17:13:41 <augustss> ndm: but for a real compiler that's not good enough
17:13:47 <ndm> augustss: although i think i can detect it based on a stack of specialisations and seeing repeated names in it
17:14:13 <ndm> augustss: i definately can do that, what i'm not sure is if it will loose things where it would have worked otherwise
17:14:30 <augustss> ndm: you could also give up when the program has grown beyond a certain size
17:14:41 <augustss> too much code is bad anyway
17:15:22 <ndm> augustss: yes, thats another option - i'm sure it can be solved well, just not quite sure whats the best answer
17:15:39 <augustss> me neither
17:16:22 <augustss> how well can you do without whole program optimization?  can you imagine doing this module by module?
17:17:26 <ndm> perhaps, although you are more likely to fall back to reynolds style
17:17:50 <augustss> i think that's fine if it doesn't happen much
17:17:58 <ndm> you could do some variant of SCC and run through groups of equations
17:17:58 <ddarius> ndm: So you have a defunctionalizer for Haskell?
17:18:02 <ndm> ddarius: yes
17:18:14 <ddarius> Sweet
17:18:33 * ddarius knew that, but it just now hit him.
17:18:43 <ndm> although being linear in computation time, its not really that expensive to do on whole programs up to a reasonable size - we are talking 0.5 seconds on 2000+ lines of code
17:19:12 <augustss> but that assumes that the rest of the compiler is linear too
17:19:33 <ndm> true, but if it compiles each section individually, then at teh end you do this transformation, you are ok
17:19:35 <ddarius> Is the (Reynold's) defunctionalizer bound into your code, or could it be separated out fairly easily?
17:19:57 <ndm> ddarius: it would take about 20 mins to implement from scratch, easier to do that than look at my code
17:20:55 <augustss> ndm: have you tried it one something serious?  like yhc
17:21:32 <ndm> augustss: yhc can't compile yhc, which means i can't - i'm restricted to things yhc can compile
17:21:59 <augustss> a compiler that can't compile itself?  how did that happen?!? ;)
17:22:08 <augustss> nhc could compile itself
17:22:08 <ndm> augustss: i tried it on cpphs, and found 2 instances where the firstifier broke down, i think both are bugs (the free variable computation is a bit of a nightmare), but want to get back to that after ICFP deadlines
17:22:13 <ndm> and HW deadlines
17:22:14 <ddarius> Extensionitis I suspect.
17:22:18 <ndm> yeah, we lost a few libraries
17:22:21 <ndm> no extensions, just libraries
17:22:43 <ddarius> It did have extension uses before yes?
17:22:45 <ndm> we moved to using Data.Map, Control.Monad.State - rather than keeping our own bad versions in the source directory
17:22:51 <ndm> nope, no extension uses, still none
17:22:58 <ndm> we are haskell98 + heirachrical
17:23:04 <ndm> we even removed all uses of CPP
17:23:05 <ddarius> Hmm, I must be misremembering something then.
17:23:11 <augustss> but Data.Map is just Haskell
17:24:09 <ndm> not really, it derives Data.Typeable etc
17:24:19 <ndm> we just need to take some time to get the right CPP magic into base
17:24:27 <augustss> right
17:24:27 <ndm> nothing hard, just time consuming
17:24:48 <augustss> or implement Typeable
17:25:06 <ndm> we already implement super-typeable
17:25:20 <ndm> which can get the type of something with free variables in it, not just monomorphic
17:26:56 <stranger> Are field labels supposed to clash with top-level bindings when used in record construction or update and not as selector functions?
17:27:08 <stranger> The Report says one thing and GHC, another.
17:29:57 <augustss> there's no reason that they should
17:30:14 <ndm> anyway, i'm off to bed now
17:30:17 <ndm> night
17:30:24 <augustss> nite
17:30:41 <ndm> augustss: i've sent a slightly revised copy, but its mostly the same
17:30:54 <augustss> thanks
17:30:56 <ndm> i'll let you know once i have the full implementation and details of the firstifier
17:30:59 <ndm> bye
17:31:01 <chessguy> ?seen procyon112
17:31:02 <lambdabot> I saw procyon112 leaving #haskell 22h 44m 33s ago, and .
17:35:34 <ddarius> augustss: Aren't field labels functions?
17:35:47 <ddarius> Damn
17:36:07 <stranger> Ye, but the Report says: "Selectors are top level bindings and so they may be
17:36:07 <stranger> shadowed by local variables but cannot conflict with other top level bindings of the same name.
17:36:07 <stranger> This shadowing only affects selector functions; in record construction (Section 3.15.2) and update
17:36:07 <stranger> (Section 3.15.3), field labels cannot be confused with ordinary variables.
17:36:23 <stranger> sorry for the hack cut&paste job...
17:39:15 <chessguy> implementations trump standards anyway :)
17:39:38 <stranger> Well, even GHC and Hugs disagree with each other...
17:41:45 <stranger> Should I bother to file a bug report or does no one care about such minor deviations?
17:41:54 <stranger> Or am I reading the standard wrong?
17:46:55 <sorear> hello.
17:47:17 <Igloo> stranger: You should file a bug report if GHC doesn't match the standard
17:49:21 <stranger> Before I do, I could use some confirmation that it is indeed GHC that is wrong and not me...
17:52:17 <jyasskin_> > foldl' (flip id) 0 $ replicate 1000000 $ (+1)
17:52:19 <lambdabot>  1000000
17:52:28 <jyasskin_> > runState (sequence_ $ replicate 1000000 (modify (+1))) 0
17:52:31 <lambdabot>  Exception: stack overflow
17:52:43 <jyasskin_> Is there a way to get the effect of the first in the state monad?
17:53:09 <sorear> @botsnack
17:53:10 <lambdabot> :)
17:53:13 <sorear> No.
17:53:17 <sorear> Import Control.Monad.State.Strict if you have a *very* recent GHC.
17:53:50 <sorear> == less than ~2 weeks old
17:54:45 <Igloo> You'd still need a modify'
17:55:27 <Igloo> But you could probably fudge one with get, seq and put
17:55:42 <jyasskin_> Hm, thanks. I was surprised that Debug.Trace.trace printed things in the opposite order from the way they happened.
17:56:06 <sorear> I'm not suprised
17:56:22 <sorear> after a bunch of modifies w/o using the value
17:56:29 <sorear> your state will look like
17:56:40 <sorear> mod3 (mod2 (mod1 initial))
17:56:52 <sorear> then normal order eval takes over
17:57:16 <sorear> mod3 is reduced, printing the message, and *then* evalling mod2 (mod1 initial)
17:57:21 <jyasskin_> Oh! So if I seq the values in the trace, it should print in the order I expected.
17:57:26 * jyasskin_ tries that.
17:57:57 <sorear> Normal order reduction is not known for being intuitive ;)
17:58:55 <sorear> Remember that as soon as you say "-O" ghc takes a LOT of liberties with the concept of normal order.
17:59:21 <ddarius> No it doesn't.  Or at least it shouldn't.
17:59:26 <sorear> You'll still get the same answer, but we mean it when we say "order of side effects is not guaranteed"
18:00:14 <jyasskin_> Yeah. I'm using the traces to try to see where a crash in Graph is happening, so it's not optimized. There's probably a better way to do this of course. :)
18:00:24 <sorear> ddarius: let foo x = trace "foo" x in foo (trace "()" ())
18:00:58 <sorear> ddarius: if the stricness analyser does it's job, and the inliner doesn't, that will give foo() -O0 and ()foo -O1
18:01:06 <jcreigh> wow, naive chess engines are slow. :)
18:01:16 <chessguy> hm?
18:01:26 <sorear> chess engines SLOW?
18:01:38 <ddarius> I know.  But only because trace violates the non-existant semantics of Haskell.
18:01:40 <jcreigh> sorear: yes, really. :)
18:01:48 <chessguy> jcreigh: you're writing a chess engine?
18:01:54 <jcreigh> chessguy: yeah, just for fun.
18:01:57 <sorear> I could write a perceptually instantaneos chess engine on a pocket calculator!
18:01:59 <jcreigh> chessguy: (ie, to see if I could)
18:02:13 <chessguy> heh. me too. we should combine our efforts
18:02:40 <jcreigh> your nick suggests to me that you have more experience in that area than I. :)
18:03:00 <chessguy> lol, probably
18:03:21 <sorear> wait - what is a chess engine?
18:03:27 <jcreigh> chess AI
18:03:37 <sorear> I thought it was something that only validates moves :)
18:03:50 <sorear> no wonder I couldn't see one being slow ...
18:03:55 <chessguy> no, jcreigh is correct
18:04:11 * sorear has never even USED a chess engine
18:04:17 <ddarius> I could write a perceptually instantaneous chess AI on a pocket calculator.
18:04:27 <jyasskin_> Thanks, sorear, that worked.
18:05:33 <chessguy> jcreigh: i could at least look at your code and make some suggestions
18:06:35 <jcreigh> chessguy: I may take you up on that after it's correct. (ie, validates user input, handles castling/en passant...)
18:08:11 <sorear> chessguy: is your chess engine related to GPLib?
18:09:25 <chessguy> sorear: not yet :)
18:09:32 <chessguy> but i hope it will be eventually
18:16:47 <chessguy> i'd like to get the 2 working independently before i try to combine my ideas
18:17:22 <jyasskin_> *sigh* Data.Inductive.Graph is not very friendly. It forces the user to uniquify the node labels before inserting them, and insert them before inserting edges that rely on them. :(
18:17:28 * jyasskin_ writes a useful wrapper
18:18:09 <sorear> jyasskin_: read this: http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
18:18:11 <lambdabot> Title: How to write a Haskell program - HaskellWiki
18:18:51 <sorear> one of the most undiscoverable documents we have, but very very useful
18:19:01 <chessguy> undiscoverable?
18:19:15 <sorear> @all-dicts undiscoverable
18:19:20 <lambdabot> *** "Undiscoverable" gcide "The Collaborative International Dictionary of English v.0.48"
18:19:20 <lambdabot> Undiscoverable \Undiscoverable\
18:19:20 <lambdabot>    See {discoverable}.
18:19:20 <lambdabot>  
18:19:20 <lambdabot> *** "undiscoverable" wn "WordNet (r) 2.0"
18:19:22 <lambdabot> [17 @more lines]
18:19:50 <jcreigh> chessguy: yeah. we log hits to that page, contact your ISP to get your real address, and dispatch a death squad. or perhaps sorear meant it's just slightly obscure. :)
18:20:18 <chessguy> uh-oh. i just clicked on it
18:20:23 * chessguy hides under the bead
18:20:26 <chessguy> uh, bed
18:20:37 <sorear> wow, big bead :)
18:23:00 <jyasskin_> sorear: Yeah, that's useful in general. Were you pointing me at any piece in particular?
18:23:03 <hpaste>  DukeDave pasted "Do notation confusion" at http://hpaste.org/1213
18:23:12 <DukeDave> Another question :)
18:24:16 <DukeDave> in lighter news I think my mind is starting to warp into a declarative one
18:24:46 <hpaste>  chessguy annotated "Do notation confusion" with "Is this what you mean?" at http://hpaste.org/1213#a1
18:25:24 <dino-> Or, if your myIOoutputFunc isn't monadic: let bar = myIOoutputFunc (myProcessingFunc foo)
18:25:24 <sorear> jyasskin_: the parts relating to lib publishing
18:25:52 <hpaste>  sjanssen annotated "Do notation confusion" with "make sharing explicit with let" at http://hpaste.org/1213#a2
18:25:59 <dino-> Oh, we have it wrong.
18:26:05 <chessguy> how could an IO output function not be monadic?
18:26:06 <dino-> He's asking how to re-use the result of myProcessingFunc foo
18:26:16 <dino-> chessguy: yeah
18:26:31 <DukeDave> ah thankyou sjanssen
18:26:39 <DukeDave> I always forget let
18:26:52 <DukeDave> can you use 'where' in a similar fashion then?
18:26:55 <sjanssen> DukeDave: a Haskell compiler may make that transformation for you, but you can't really count on it
18:27:08 <DukeDave> although, certainly 'let' is more appropriate there
18:27:17 <sjanssen> you can't use where there because you need the result of 'foo'
18:27:36 <jyasskin_> sorear: you mean for when I finish the useful wrapper? Probably I would just send a patch on the FGL to libraries@.
18:27:41 <sjanssen> and a where statement doesn't inherit that scope
18:27:49 <sorear> jyasskin_: ok.
18:27:58 <sorear> jyasskin_: don't forget to subscribe :(
18:28:17 <DukeDave> it makes sense :)
18:28:42 <DukeDave> I was actually trying to factor in a 'where' prior to asking & got stumped with scoping ;)
18:28:43 <jyasskin_> sorear: I'm not quite that new. ;) I've already submitted a patch to Data.Monoid.
18:28:48 * sorear fixed a build failure in GHC, but didn't get credit because in the time it took to realise I needed to subscribe, Simon (I forget which one) found and fixed the same bug.
18:29:06 <jyasskin_> Ouch. :(
18:29:16 <sorear> jyasskin_: are you the First/Last guy?
18:29:19 <jyasskin_> Yeah
18:29:37 <stefanha> e <- liftM (read :: String -> Int) $ getLine
18:29:48 <stefanha> Is there a way to make that "String -> Int" more concise?
18:29:55 <sjanssen> @hoogle readLn
18:29:56 <lambdabot> Prelude.readLn :: Read a => IO a
18:30:09 <stefanha> Ah, cool :)
18:30:23 <sjanssen> that isn't *exactly* the same, because it makes the read error into an IO error
18:30:35 <sjanssen> but it's probably fine for most uses
18:30:40 <stefanha> Thanks
18:31:26 <sorear> e <- readLn
18:31:39 <sorear> usually, the compiler can infer the type of e for you
18:33:05 <dolio> Yeah, typically, the more concise way to write your original would be 'e <- liftM read getLine', because the type annotation isn't necessary.
18:33:20 <encryptio> @where fix
18:33:20 <lambdabot> I know nothing about fix.
18:33:29 <dolio> Control.Monad.Fix
18:33:33 <encryptio> @module fix
18:33:34 <lambdabot> Unknown command, try @list
18:33:35 <chessguy> ?hoogle fix
18:33:35 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
18:33:36 <encryptio> (lag sucks)
18:33:36 <lambdabot> Control.Monad.Fix :: module
18:33:36 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
18:33:49 <chessguy> ?src fix
18:33:50 <lambdabot> fix f = let x = f x in x
18:34:37 <chessguy> @type fix (++)
18:34:39 <lambdabot>     Couldn't match expected type `[a]'
18:34:40 <lambdabot>            against inferred type `[a] -> [a]'
18:34:55 <chessguy> @type fix (*2)
18:34:57 <lambdabot> forall a. (Num a) => a
18:35:10 <dolio> @type mfix (++)
18:35:12 <lambdabot> forall a. [a] -> [a]
18:35:22 <chessguy> > fix (*2)
18:35:23 <lambdabot>  Exception: <<loop>>
18:36:05 <chessguy> wouldn't 0 be a correct answer there?
18:36:32 <dolio> That's not what fix does.
18:36:32 <sorear> no
18:36:33 <jyasskin_> chessguy: 0, 1, 2, -512.2 would all be correct answers.
18:36:40 <jyasskin_> So none of them are. :)
18:36:49 <chessguy> huh?
18:36:49 <sorear> jyasskin_: no, there can only be one least fixed point
18:36:59 <sorear> jyasskin_: and here it's  _|_
18:37:01 <jyasskin_> oops. sorry, for (*2) I'm totally wrong
18:37:06 * sorear LOVES least fixed points
18:37:27 <chessguy> the fixed point of a function is the input that produces itself as the output, right?
18:37:35 <sorear> rght.
18:37:41 <sorear> but we have to pick one
18:37:43 <jyasskin_> I was thinking of (fix id), which has lots more fixed points, but yes, only _|_ for a least one.
18:37:49 <sorear> so fix uses the smallest one.
18:38:20 <sorear> haskell values are partially ordered, and haskell functions are monotonic on the order
18:38:29 <chessguy> there are no other integers which you can multiply by 2, and get the same integer back
18:38:34 <sorear> so by elementary order theory, they all have unique fixed points
18:38:45 <sorear> *unique least fixed points
18:38:55 <chessguy> i don't get it
18:39:04 <sorear> (*2) has two fixed points, _|_ and 0
18:39:17 <sorear> _|_ is smaller than 0 in the haskell ordering
18:39:27 <chessguy> ok
18:39:28 <sorear> (which has nothing to do with numeric order btw)
18:39:42 <chessguy> that's quite silly
18:39:51 <chessguy> > fix sqrt
18:39:52 <sorear> it's a partial order
18:39:52 <lambdabot>  Exception: <<loop>>
18:40:10 <sorear> 1 is neither less nor greater nor equal to 2 in this order
18:40:24 <sorear> for Int, the fix-order is _|_ < anything else
18:40:31 <sorear> and that's the only relation
18:40:37 <chessguy> that's dumb
18:41:07 <sorear> well, it's pretty much impossible to find the fixed points of a function.
18:41:28 <sorear> the fact that the least one in any order can be found so easily is somewhat miraculous
18:41:54 <sorear> > fix (const 1)
18:41:55 <lambdabot>  1
18:42:03 <sorear> const 1 has exactly one fixed point, 1
18:42:11 <jcreigh> fix *never* works for strict functions, right?
18:42:28 <jyasskin_> > fix (const $! 1)
18:42:29 <lambdabot>  1
18:42:30 <sorear> a function f is defined to be strict iff f _|_ = _
18:42:37 <kpreid> > fix ((0:) . (map (+1)))
18:42:38 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
18:42:39 <sorear> a function f is defined to be strict iff f _|_ = _|_
18:42:51 <sorear> so if f is strict, then _|_ is a fixed point
18:43:11 <sorear> and since _|_ is smaller than all other values, it is the least fixed point of any strict function
18:43:37 <sorear> lol at claus reinke's afd post...
18:44:13 <chessguy> software archaeology?
18:44:23 <sorear> yeah
18:44:44 <sorear> it's the only afd post so far this year :)
18:44:56 <sorear> there will probably be more
18:45:08 <dolio> Crazy foreigners with their different time zones.
18:45:19 * sorear senses incomplete communication
18:45:27 <sorear> chessguy: afd == april fools day
18:45:37 <jyasskin_> Oh!
18:45:38 <sorear> nothing directly to do with software april
18:45:41 <chessguy> i knew that
18:45:49 <sorear> s/april/archaeology/
18:47:14 <chessguy> i don't get how this is an april fools' joke
18:47:24 <chessguy> it's quite funny, mind you
18:47:34 <jcreigh> where is this, anyway? haskell-cafe?
18:47:55 <chessguy> haskell@
18:48:01 * sjanssen waits eagerly for further April Fools messages
18:48:03 <jcreigh> ah, I'm not subscribed to that one.
18:48:23 <chessguy> i wonder if google is going to do something cool this year
18:50:05 <chessguy> LOL, http://en.wikipedia.org/wiki/April_fool
18:50:05 <lambdabot> Title: April Fools' Day - Wikipedia, the free encyclopedia
18:50:12 <chessguy> look at the note at the beginning :)
18:52:32 <jcreigh> well, maybe there's a scottish town named "compiler"
18:59:44 <jcreigh> sjanssen: did you see my dmenu Xinerama patch/
18:59:45 <rashakil> sjanssen: vertical split added, windows resizable now, check email.
18:59:51 <jcreigh> lol
19:00:15 <rashakil> and lines of code growing uncomfortably past 400...
19:00:21 <jcreigh> rashakil: yeah. :(
19:00:52 <sorear> I'll just have to start golfing^Whacking xmonad.
19:01:35 <jcreigh> I think we can refactor in a few places to bring it down a bit...but 400 LOC is probably something of a pipe dream.
19:02:06 <rashakil> maybe 400!
19:02:19 <ddarius> What does sloccount say on Lambdabot?
19:02:32 <rashakil> s/!/!.
19:02:51 <jcreigh> factorial 400? :)
19:03:11 <rashakil> i'd have to install lambdabot
19:04:29 <dons> jcreigh: you hacked dmenu?
19:04:34 <dons> rashakil: woot.
19:04:35 <sorear> a lot?
19:04:35 <sorear> lambdabot is in pretty dire need of a rewrite, anyway
19:04:36 <jcreigh> dons: just a bit.
19:04:40 <dons> rashakil: can you send me the patch too please?
19:04:44 <rashakil> okay
19:04:56 <sorear> hi dons
19:04:59 <dons> sorear: agreed. want to write lambdabot v7 ?
19:05:10 <sorear> dons: where'd 7 come from?
19:05:12 <dons> you'd need to be able to roughly support the 40 or so core plugins
19:05:18 <dons> sounds like a nice number.
19:05:21 <jcreigh> dons: I just made dmenu accept -x and -w, and then pass those in from xmonad.
19:05:31 <dons> jcreigh: so we forked dmenu?
19:05:35 <jcreigh> dons: no.
19:05:40 <dons> or those were already valid dmenu flags?
19:06:07 <jcreigh> dons: well, I don't *mean* to fork dmenu. I'm hoping to get the patch accepted upstream.
19:06:10 <dons> yes, xmonad needs a refactor. and we must be pretty darn close to v0.1 now..
19:06:14 <jcreigh> http://www.jcreigh.com/dmenu/position-options.patch
19:06:16 <dons> jcreigh: ah ok. we'll see...
19:06:24 <jcreigh> ...it's not a big change.
19:06:30 <dons> jcreigh: so it does what? single screen support for xinerama?
19:06:42 <jcreigh> dons: lol, sounds funny when you say it that way, but yes.
19:06:51 <jcreigh> menu appears only on the current screen.
19:06:55 <dons> ok.
19:07:22 <dons> rashakil: i think you better darcs pull first, before generating the patch
19:07:36 <dons> i think its going to conflict with some whitespace/formatting changes i pushed earlier
19:08:30 <dons> at some point I want to just say "xmonad is done" no more features. then refactor for 3 weeks.
19:08:43 <foxy-om> dons: Did you get the email I sent about the '_free' problem with hs-plugins?
19:08:58 <jcreigh> dons: oh, I think that would be good.
19:09:00 <dons> yeah, i know about the problem. i'm not able to fix it currently.
19:10:51 <foxy-om> dons, I think the problem is not with hs-plugins, but with the libc symbols (not) linked?
19:17:42 <dons> foxy-om: right, that's what it looks like. hs-plugins isn't loading the extra c lib it needs, or else not resolving it properly
19:20:03 <dons> rashakil: yes, you'll need to darcs pull, then merge your changes,
19:20:04 <dons> There are conflicts in the following files:
19:20:05 <dons> ./Config.hs ./Operations.hs
19:20:07 <rashakil> yep
19:20:10 <rashakil> just did
19:20:39 <dons> can you resend?
19:24:28 <rashakil> done
19:24:44 <zeeeee> are there such things as mutable arrows? eg, most frp guis for haskell have immutable wirings. to have, say, a variable number of textboxes, you'll need to tear down & rebuild everything.
19:25:29 <zeeeee> that's my understanding at least
19:25:38 <rashakil> whoa
19:26:17 <rashakil> dons there are some layout issues of my own that I missed; I'll send another
19:26:34 <rashakil> just ugliness
19:26:49 <sorear> ... almost without trying I seem to have all but taken over ndm's deriving lib ...
19:28:09 <zeeeee> sorear: what's this deriving lib you speak of?
19:28:39 <sorear> ndm's! ;)
19:28:41 <sorear> @were derive
19:28:42 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
19:29:10 <zeeeee> thanks
19:29:40 <dons> rashakil: i've just received another patch from you, but should i ignore this too? and wait for the next clean up?
19:29:47 * dons is keen to test horizontal splitting
19:29:54 <rashakil> no go ahead with that one, it works
19:29:57 <dons> ok.
19:30:02 <rashakil> I'm moving whitespace around
19:30:13 <dons> what's the motivatoin for using ctrl-space?
19:30:20 <rashakil> emacs set mark
19:30:25 <jcreigh> ctrl-space?
19:30:33 * jcreigh likes everything to be under modMask...
19:30:35 <dons> heh. we're going to have a mixture of vim and emacs keys, eh?
19:30:36 <zeeeee> yi hacking?
19:30:47 <dons> yeah, modMask i think would be preferable. is mod-shift-space free?
19:30:59 <sorear> ctrl-space would be just about the most effective way to cripple emacs ;)
19:31:10 <sorear> maybe ctrl-x would be better
19:31:28 <jcreigh> sorear: vim extended completion key. :)
19:31:49 <jcreigh> sticking everything under modMask is good because then you can bind it to your windows key...
19:31:51 <rashakil> feel free to change them back -- I was messing with the config with much sleep deprivation...
19:32:00 <sorear> hello dpiponi
19:32:07 <dpiponi> hello sorear
19:32:15 <araujo> hi hi
19:32:19 <jcreigh> is there anything magic about hiding windows by moving them to displayWidth*2, displayHeight*2? Wouldn't any other off-screen coords work as well?
19:32:21 <sorear> reading your post, it turns out I *have* seen universal covers before.
19:32:31 <sorear> in a topology text no less!
19:32:37 <rashakil> but ctrl+space and alt+w are risking accidentally deleting data and such
19:32:48 <sorear> must be more careful about glazing over sections in the future ;)
19:33:02 <dons> jcreigh: nothing magic, only that dwm also uses those numbers
19:33:07 <jcreigh> okay.
19:33:08 <sorear> rashakil: alt-w is pretty saft
19:33:17 <sorear> rashakil: that's emacs for "copy to kill ring"
19:33:36 <sorear> rashakil: so, it deletes (only) the Nth (20?) least recent copy
19:33:37 <dpiponi> sorear: Does what I wrote make sense?
19:33:37 <rashakil> right, and then when you paste it, you get the wrong thing -- which could look like the right thing.
19:33:39 <dons> rashakil: i note this is a pretty huge set of patches... :-)
19:33:57 <rashakil> yeah...
19:33:57 <dons> hope it works..
19:34:00 <sorear> dpiponi: yeah
19:34:30 <sorear> dpiponi: when trying to understand it from my topology book, I did get the mental "unaliasing" image
19:34:41 <sorear> dpiponi: they used S^1 -> E^1 as their example
19:35:03 <sorear> dpiponi: but I couldn't quite get anything more complicated than that
19:35:03 <dpiponi> sorear: That's basically the same as R->SO(2)
19:35:19 <dpiponi> sorear: Well SO(3) is a nice example to think about
19:35:20 <sorear> dpiponi: yeah, I could tell :)
19:35:47 <sorear> dpiponi: am I supposed to be able to visualise the construction of uc(SO(3))?
19:35:59 <sorear> dpiponi: ie is it irreducably Nd | N >= 4?
19:36:42 <dons> rashakil: is it just me, or did you randomly change a bunch of keybindings? ;-)
19:36:51 <sorear> the fact that it is only two copies of a three-d space suggests it could be constructed as a quotient of a subspace of E^3
19:36:53 <dpiponi> sorear: The dirac belt trick lets you see it. I hope you checked out Greg Egan's applet.
19:36:57 <rashakil> <rashakil> feel free to change them back -- I was messing with the config with much sleep deprivation...
19:37:19 <dons> ok. but i should be able to do vert splitting and resizing now, yeah?
19:37:24 <rashakil> yes
19:37:26 * dons tries this out
19:37:26 <sorear> No java here, alas.
19:37:50 * sorear tries this out, with a real belt
19:40:02 <dons> ok. some initial thoughts, rashakil
19:40:19 <dons> i like the idea of cycling through full/ver/thorizontal mode. that's good
19:41:02 <dons> having different keys for resizing in vert /horizontal mode, not so good. i think mod-h,l should probably be bound to whatever resizes windows in the current mode
19:41:18 <dons> ideally though, i'd like to be able to resize vertically and horizontally in both modes
19:41:32 <rashakil> okay
19:41:51 <ddarius> Just added a comment.
19:41:53 <rashakil> you mean mod-h,l for horizontal resizing, mod-j,k for vertical?
19:41:53 <dons> and we have to keep mod-jk for switching focus, imo.
19:41:57 <rashakil> okay
19:42:25 <dons> yes, so either mod-h,l for resizing, either vertically in vertical mode, or horizontally in horizonntal mode.
19:42:33 <dons> *or* we go for both resizing options in both modes
19:42:44 <dons> then we pick a set of 4 keys for this. mod-shift-hjkl maybe
19:43:16 <jcreigh> how would you resize vertically in the current tiling mode? What would it even do?
19:43:26 * ddarius suggests, again, Roger Penrose's "The Road to Reality"
19:43:30 <rashakil> you can grow and shrink windows on the right hand side
19:43:34 <dons> right
19:43:52 <dons> and in horizontal mode it grows sideways in the bottom window.
19:44:08 <rashakil> The way it's done, though, isn't very good
19:44:25 <jcreigh> do you have to keep track of sizes for each window, then?
19:44:38 <dons> dwm has to.
19:44:43 <rashakil> sizes in horizontal and vertical direction
19:44:57 <dons> yeah, maybe i can live without this ability.
19:45:00 <jcreigh> well, just one, right? The other one is per workspace.
19:45:04 <dons> but then i don't want seperate resize keys for both modes.
19:45:05 <stepcut> dons: if you hit Mod-p (or whatever dmenu is bound too), and run a non-GUI app, like hmp3, I think it locks up xmonad -- I only tried once ;)
19:45:13 <dons> the same resize keys should just mean different things in vert or horizontal mode.
19:45:19 <jcreigh> stepcut: don't do that, then. :)
19:45:23 <dons> stepcut: ok. interesting.
19:45:30 <stepcut> jcreigh: like I said, I only tried once :p
19:45:33 <jcreigh> heh
19:46:21 <ddarius> sorear: You don't need a belt.
19:46:38 <sorear> I've got one however.
19:46:51 <dons> rashakil: so i think i'll apply your patch, with some tweaks.
19:46:58 <rashakil> alright
19:48:12 <ddarius> sorear: You can do the same thing essentially, with just your arm and your hande.
19:49:01 <sorear> ddarius: I'm done.
19:51:42 <hpaste>  oren pasted "old { a = ...} and Name { a = ... } are different?" at http://hpaste.org/1214
19:52:03 <dons> so what does 'promote' do?
19:52:08 <dons> jcreigh: is it xinerama only?
19:52:12 <jcreigh> dons: no.
19:52:24 <dons> how do I use it?
19:52:31 <jcreigh> dons: promote moves the focused window to the..."big area"
19:52:34 <jcreigh> or whatever you call it.
19:52:38 <dons> hmm?
19:52:48 <dons> ah
19:52:50 <dons> yes.
19:52:58 * dons leaves full screen mode for a moment
19:53:15 <dons> don't we have a generic method for cycling windows around?
19:53:25 <jcreigh> I don't believe so.
19:54:04 <oren> Hi dons, can I bother you a second?
19:54:04 <dons> maybe rather than just 'promote', or in conjunction with promote, we could cycle the layout stack clockwise or counterclockwise
19:54:09 <dons> oren: you can try.
19:54:47 <oren> Working on my streaming parser I hit on this weird Haskell behavior (hpaste 1214)
19:54:55 <oren> Is this by design, or is this a bug?
19:55:17 <oren> This forces me to manually copy all my state fields all over the place (tons of boilerplate code)
19:55:18 <dons> old { a = ...} updates an old value's field, yeah?
19:55:21 <oren> Yes
19:55:25 <dons> and Name { ...} constructs a completely new record
19:55:32 <oren> Right
19:55:35 <jcreigh> I kinda like the way promote works. I don't feel any particular need to rotate the whole stack. (then again, I don't use tiling an awful lot...)
19:55:38 <oren> But both create a new record
19:55:45 <dons> so if you want to copy fields, use the let new = old { .. } syntax?
19:55:48 <dons> oren: right.
19:55:52 <oren> And the tag of the new record is constant (by type)
19:56:02 <dons> jcreigh: ok. i'll just put it on my list of things to try next week.
19:56:04 <sorear> DOH!
19:56:20 <jcreigh> hmm, darcs revert -i is handy.
19:56:24 <sorear> oren: thhe record update evaluates the old record
19:56:45 <oren> Is there no lazy modify-field then?
19:56:55 <sorear> oren: when you say foo { field = new } it desugars to (\ Rec x y -> Rec x new) foo
19:56:58 <sorear> you want
19:57:08 <sorear> (\ ~(Rec x y) -> Rec x new) foo
19:57:26 <oren> Is there a way to access this in a nice syntax?
19:57:29 <sorear> apply the desugaring for ~, and you get to the pre-update code that works.
19:57:32 <oren> My code is full of this
19:57:49 <sorear> you could make functions to do it
19:57:59 <sorear> set_snd v ~(Rec x _) = Rec x v
19:58:02 <oren> One for each field I suppose
19:58:08 <sorear> set_fst v ~(Rec _ x) = Rec v x
19:58:26 <oren> I have like a dozen of these (named)
19:58:40 <sorear> sounds like a job for DrIFT
19:59:10 <oren> I'll give it a look
19:59:14 <dons> rashakil: ok. patch applied to mai nrepo.
19:59:18 <dons> sjanssen: ^^ heads up.
19:59:27 <oren> Thanks guys
19:59:38 <dons> rashakil: we follow dwm's key bindings wherever possible (helps ease users in)
19:59:46 <rashakil> okay
19:59:49 <dons> rashakil: so mod-shift-jk for vert resize.
19:59:52 <dons> and mod-jk for focus.
20:00:13 <chessguy> hey dons?
20:00:14 <dons> ok. some workspace switching issues i see..hmm
20:00:28 <rashakil> what issues?
20:01:17 <dons> switching from an empty workspace back to workspace with windows seems not to move windows into focus (sometimes).
20:01:35 <dons> i have to try to switch back the workspace twice to make it work.
20:02:43 <dons> and swtiching seems to sometimes lose track of what window was on top of the stack.
20:02:55 <dons> grr. too much logic moved into Operatoins.hs, and out of stackset. grumble.
20:03:44 * dons reverts to see if that helps
20:03:59 <sorear> xmonad needs a testsuite?
20:05:34 <dons> it has one, but only for the pure part.
20:05:41 <dons> and people seem to be adding code to the impure part ... :/
20:05:55 <dons> rashakil: doesn't look like its your patch's fault though
20:06:07 <rashakil> i'm not noticing any of the behavior
20:06:49 <rashakil> I wouldn't be surprised if I caused problems on multiple screens, though
20:06:54 <dons> so with windows on workspace 1:  mod-2 mod-1 returns to a workspace 1 with missing windows, and the layout order messed up.
20:07:24 <dons> i'm not using multiple screens, but your patch isn't the problem. the issue is there without applying your patches anyway.
20:07:28 * dons blames jcreigh  ;-)
20:07:45 <rashakil> i'm not seeing it.  what layout are your windows in when this happens?
20:07:55 <dons> fullscreen
20:08:22 <dons> so 2 windows on workspace 1, in full screen mode.  empty workspace 2
20:08:42 <dons> mod-2 ; mod-1, and half the time workspace 1 appears empty, till I type 'mod-1' again
20:09:13 <rashakil> okay, i'm seeing it
20:09:22 <jcreigh> I so see somebody decided to change the screen switching bindings. :)
20:09:31 <jcreigh> s/I so/so I/
20:09:36 <rashakil> oh sry :P
20:09:38 <dons> jcreigh: i reverted it.
20:09:47 <dons> jcreigh: grab the latest patches. should be back to normal.
20:09:54 <dons> jcreigh: can you have a look at this workspace switching issue?
20:10:00 <jcreigh> dons: sure
20:10:16 <dons> seems to work fine if there's a window being managed on workspace 2.
20:10:34 <jcreigh> we can change the screen switching bindings if lots of people like to use alt as modMask...
20:10:50 <sorear> @users
20:10:50 <lambdabot> Maximum users seen in #haskell: 337, currently: 286 (84.9%), active: 20 (7.0%)
20:11:45 <dons> i will try to encourage sjanssen to bring in a feature lock this week, i think.
20:11:59 <dons> so we can just concentrate on stabilising everything and testing.
20:12:11 <rashakil> It seems like it's always, when changing windows unexpectly, changing back to the same window, for me.
20:12:13 <jcreigh> that sounds like a good idea.
20:12:24 <jcreigh> (feature freeze for refactoring, I mean)
20:12:29 <dons> yes.
20:13:02 <dons> so some of the root/empty workspace logic is wrong, when switching or focusing.
20:13:14 * dons grumbles about things that work getting broken and made to not work.
20:13:26 * dons grumbles that xmonad was perfeect already when it was 150 loc ;-)
20:14:49 <jcreigh> I did the "two windows full screen on workspace 1, switch to 2, then back" and didn't see anything unusual
20:15:19 <dons> try it a few times.
20:15:29 <jcreigh> are you sure you reverted the screen switching keys? I did another darcs pull, and they're still e,r,t
20:15:31 <dons> it seemed to fail or me maybe 1/2 attempts
20:15:42 <rashakil> yeah, I got e r t too.
20:15:50 * dons checks.
20:16:12 <dons> oh urgh. what's this e r t stuff??
20:16:15 <rashakil> And you forgot to include bindings for resizing tiled windows
20:16:33 <rashakil> I'm just trying to sabotage things
20:16:34 <dons> people should not be messing with the key bindings!!
20:17:01 <dons> and if they do, they should be a single well-discussed patch. not buried in a larger patch set...
20:17:40 <jcreigh> dons: to be fair, I believe the keybinding change was in a single, one-line patch
20:17:49 <jcreigh> dons: just not well-discussed. :)
20:18:33 <dons> i can't imagine what the motivation for it is though. this is a dwm clone after all.
20:18:49 <jcreigh> "Config.hs avoids conflict with essential M-w Emacs shortcut." is the patch name.
20:18:54 <jcreigh> motivation for what?
20:20:17 * dons tries to work out what happened to the key bindings
20:20:28 <jcreigh> oh, "restart" is gone too. :)
20:20:46 <jcreigh> oh, no wait, it was moved to r
20:20:57 <jcreigh> which doesn't work, because mod-shift-r is taken.
20:20:58 <dons> dont' use F* keys
20:21:40 <jcreigh> hmm? why not? (I figured that, since restart was fairly rare, it would be better to use some obscure key)
20:21:52 <stepcut> xmonad conflicts with quite a few emacs shorcuts... fixing just M-w is silly
20:22:22 <dons> if the user cares about emacs, use a different mod key.
20:22:24 <stepcut> switching Mod1 to Mod4 is much more sensible
20:23:02 <dons> jcreigh: so what's this e,r,t stuff anyway? what keybindings is it generating?
20:23:08 <dons> do they correspond to anything in dwm?
20:23:12 <jcreigh> dons: no.
20:23:46 <jcreigh> dons: it's screen switching. mod-{w,e,r} (well, e,r,t now) switch to screens 1, 2 and 3 respectively. and shift-mod-{w,e,r} moves the current window to the workspace on that screen.
20:24:02 <jcreigh> it's all in the docs at the top of Config.hs :)
20:24:29 <dons> hmm. w e r eh?
20:24:44 <jcreigh> we can certainly move their defaults to somewhere else if those keys are needed for something else...shift-mod-w is a little too close to shift-mod-q anyway.
20:24:47 <dons> i'd have done maybe, mod-shift-ctrl-1..n ?
20:24:56 <jcreigh> gah.
20:25:06 <dons> or do you switch screens a lot?
20:25:09 <jcreigh> screen switching is the most common thing you do on a multihead setup.
20:25:14 <dons> ok.
20:25:53 * mwc keeps his back against the wall
20:25:55 <dons> now, you're also trying to work around some emacs overlap issue here?
20:26:01 <jcreigh> me?
20:26:08 * jcreigh doesn't use emacs
20:26:09 <dons>         | (key, sc) <- zip [xK_e, xK_r, xK_t] [1..]
20:26:10 <dons>         | (key, sc) <- zip [xK_w, xK_e, xK_r] [1..]
20:26:23 <dons> what's the purpose of this change?
20:26:33 <jcreigh> I didn't write that...
20:26:40 <dons> so it should be w e r no?
20:26:50 <jcreigh> that's what it was, yes.
20:26:59 <jcreigh> that's what my fingers think it is. :)
20:26:59 <dons> yes. and you use multihead, so you get to choose :-)
20:27:04 * dons reverts to wer.
20:27:49 <jcreigh> in that case, you also have to pick a different binding for restart, since you tried to move it to shift-mod-r, which is taken by those bindings.
20:27:50 <dons> it'd be nice to tag 'screen' comments tagged as (multiheaded) or something, so its clear this is non-core functionality
20:27:54 <dons> yep.
20:27:55 <oren> 23/leave
20:28:34 <dons> so why only 3 screens? is that all we can support?
20:28:41 <dons> does anyone have more?
20:28:43 <jcreigh> dons: that's how many screens I have. :)
20:28:49 <dons> ok.
20:29:07 <jcreigh> dons: if you add another binding to the list, I'll Just Work. I figure the quad-headed guy can add it himself.
20:29:24 <jcreigh> s/I'll/it'll/
20:30:00 <dons> yeah
20:30:27 <dons> does anyone use both gmrun and dmenu?
20:30:43 <dons> or can they just share the mod-shift-p binding, pick which one you like
20:31:24 <dons>     , ((modMask,               xK_p     ), spawn "exe=`dmenu_path | dmenu` && exec $exe")
20:31:27 <dons>     , ((modMask .|. shiftMask, xK_p     ), spawn "gmrun")
20:31:40 <dons> makes more sense to me, at least. unless sjanssen uses both, we could save one binding here.
20:32:31 <jcreigh> sounds fine. I only use dmenu.
20:32:45 <dons>     , ((modMask .|. shiftMask, xK_q                     ), io $ exitWith ExitSuccess)
20:32:48 <dons>     , ((modMask .|. shiftMask .|. controlMask, xK_q     ), io restart)
20:32:48 <dons> make more sense to me too.
20:32:56 <jcreigh> oh! nice!
20:33:01 * jcreigh wishes he thought of that
20:33:54 <jcreigh> BTW, I think that every default binding should have modMask in it. Otherwise, what's the point of having modMask?
20:33:59 <dons> yes.
20:34:09 <dons> they all do, now, I think
20:35:11 <jcreigh> maybe we should have a "HACKING" document that describes some of these things (Don't arbitrarily change default keybindings without discussion, always use modMask, think about what you're doing, don't just randomly hack it into Operations.hs, etc.)
20:36:18 <dons> yeah, i think 'promote' should actually cycle. it actually does cycle if you position the focus in the right location
20:36:28 <dons> otherwise it flips windows
20:36:46 <dons> if it cycles, we get nice properties to describe its behaviour abstractly
20:36:55 <dons> (its behaviour wrt. the other windows)
20:37:14 <dons> yes. in general people should be taking code out.
20:37:36 <dons> too much code has ended up in big chunks of logic that we can't reason about anymore.
20:37:51 <dons> so the Quickcheck'ed wm is a bit far off from where we started.
20:38:01 <dons> so yeah, feature freeze and refactor till v0.1
20:40:33 <dons> ok. pushed.
20:41:05 <dons> my original plane for the layout algorithm was that it would be fully pure, so we coudl QC it. that got lost somewhere along the line.
20:41:39 <dons> refresh is way way to hairy currently. grumble.
20:41:49 <jcreigh> yeah, refresh tries to do everything.
20:41:49 <bos> @seen cale
20:41:50 <lambdabot> cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard cale speak 5h 22m 33s ago.
20:41:52 * dons feels the minimalist wm developer disese taking over.
20:42:19 <dons> rashakil__: looks like 'runRects' is actually a pure layout function, almost
20:42:32 <dons> urgh imperative gunk.
20:43:12 <dons> i feel bad. there are parts of xmonad i don't want to look at.
20:43:39 * dons goes back to writing papers, and notes down to get a tree lock from sjanssen 
20:43:51 <sorear> @seen sjanssen
20:43:52 <lambdabot> sjanssen is in #haskell-soc, #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 1h 55m 51s ago.
20:44:24 <bos> bah. googling for "cale random monad" is not getting me cale's random state monad doodad.
20:44:41 <dons> i think its on haskell.org/haskellwiki somewhere.
20:46:16 <bos> yeah. but searching haskellwiki is painful :(
20:48:58 <jcreigh> dons: how wold you QC a layout algorithm? What properties could you check?
20:49:14 <Cale> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
20:49:16 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
20:49:47 <dons> jcreigh: you give it a list of windows, and geometry, it returns a modified layout. you check for overlapping, that cycling didn't break things, and so on.
20:49:56 <dons> that the ratios are always preserved.
20:50:08 <dons> there's lots of good properties that we want to have.
20:50:15 <dons> e.g. that everything is on the screen, for example.
20:50:31 <jcreigh> gah! "refresh" is huge after latest patchs. ugh.
20:50:33 <dons> the height of the master window is the sum of the heights of all the minor windows
20:51:15 <dons> i'll probably do a complete rewrite of this layout stuff so it is fully pure and QC-able, next week some time.
20:51:25 <stepcut> yay!
20:51:26 <jcreigh> ah, okay.
20:52:08 <jcreigh> If I get the itch to clean up some of xmonad, I'll focus my efforts elsewhere, then.
20:52:16 <dons> all layout and window logic is /supposed/ to be in the StackSet data structure, and the layout (pure) function.
20:52:28 <dons> so there should be no core wm logic in imperative code (ideally)
20:52:38 <dons> at least the key functionality needs to be pure.
20:52:47 <foxy-om> @hoogle liftM
20:52:48 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
20:52:48 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
20:52:48 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
20:54:44 <dolio> :t liftM7
20:54:46 <lambdabot> Not in scope: `liftM7'
20:56:24 <jcreigh> "liftM5 should be enough for everyone" :)
20:56:37 <sorear> besides, we have ap
20:57:03 <dolio> :)
20:57:03 <sorear> @ty \f a b c d e f g -> return f `ap` a `ap` b `ap` c `ap` d `ap` e `ap` f `ap` g
20:57:06 <lambdabot>     Conflicting definitions for `f'
20:57:06 <lambdabot>     In a lambda abstraction
20:57:14 <sorear> ...
20:57:19 <sorear> @ty \fu a b c d e f g -> return fu `ap` a `ap` b `ap` c `ap` d `ap` e `ap` f `ap` g
20:57:22 <lambdabot> forall a a1 a2 a3 a4 a5 a6 b (m :: * -> *). (Monad m) => (a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> b) -> m a -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m a6 -> m b
20:57:59 <dolio> I guess I was thinking of zips.
20:58:02 <dolio> :t zip7
20:58:05 <lambdabot> forall a b c d e f g. -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
20:58:39 <foxy-om> is it possible to reshape mutable arrays?
20:59:37 <dons> i have a program which runs 43% faster when compiled with the intel C compiler, than with gcc.
20:59:52 <stepcut> heh
21:00:22 * sorear has jhc for C on his todo list ...
21:00:27 <dji> 43% is not alot
21:01:16 <dons> heh sure. 43% purely due to better optimisations is a *lot*.
21:01:28 <bos> we've seen 20x speedups in a few cases with our compiler, due to cache blocking.
21:01:35 <bos> but those are rare.
21:02:22 <bos> dons: is this on your big opteron, or an intel box?
21:03:39 <tsp> 43% is cool
21:04:26 <dons> just an intel machine. p4.
21:05:36 <sorear> I'm gonna go crazy.  Abstract interpretation.  Cache modelling.  Profiling feedback.  Predicate propagation.  GP.
21:05:45 <sorear> I think I'll call it 'vcc'
21:05:52 <sorear> the Vaporware C Compiler
21:06:01 <jcreigh> heh. nice.
21:06:23 <sorear> to complement ndm's yhc -Ovaporware project
21:06:52 <sorear> would probably have been -Ovapourware ...
21:06:54 * sorear checks logs
21:06:57 <stepcut> 43% might be enough to rocket haskell to the top of the computer language shootout
21:07:16 <stepcut> with yhcc -O11 + ICC
21:07:17 <stepcut> ;)
21:07:23 <dons> yes, i'd really like to try some icc-compiled haskell
21:08:14 <sorear> jhc + VCC will beat mlton in every way
21:09:34 <dji> dons, im new to haskell but couldn't you ghc -C it and then icc it?
21:10:13 <dons> unfortunately not, as ghc relies on a number of gcc-specific extensions
21:10:25 <dji> hm thats evil
21:10:27 <dons> working out which ones can be rewritten to something icc supports would be a good SoC proejct ;-)
21:10:47 <dji> should have made a --pedantic option :O
21:10:57 <dons> you can get ansi C, but its 2x slower.
21:11:06 <dons> though ansi C + icc might even catch up to gcc ...
21:11:32 <dji> is there another haskell -> c compiler out there?
21:11:38 <sorear> jhc
21:11:41 <dons> jhc, for one.
21:11:47 <sorear> jhc generate ANSI C
21:11:53 <stepcut> but jhc can only compile 2 apps in nobench :)
21:11:59 <sorear> on nobench, jhc fails on 30/32 programs
21:12:14 <sorear> but on those two... 70% faster than GHC+GCC exts
21:12:27 <stepcut> indeed
21:13:31 <xpika> both the darcs wxhaskell and the tar.gz haskell get compile errors
21:13:35 <xpika> for me
21:14:37 <dji> 30/32 seems good as far as noncorformance is concerned tho
21:14:51 <dji> s/corf/conf/
21:17:11 <Gwern> dons: heck, I'd be happy if xmonad allowed the modifier to be a single key
21:17:21 <foxy-om> what is xmonad?
21:17:26 <xpika> a window manager
21:17:29 <xpika> in haskell
21:17:44 <foxy-om> .oO
21:18:04 <dji> what style of wm is it?
21:18:31 <xpika> I'm not sure weather it's a Google SOC project or not.
21:18:35 <Gwern> dji: tiling
21:19:02 <dji> is it complete enough to be usabe?
21:19:09 <ddarius> It's being used.
21:19:14 <Gwern> dji: it's as usable as dwm in my experience...
21:19:14 <stepcut> minimal, tiling, dwm-like haskell window manager in under 400 lines + QuickCheck properties. Though the last two parts are not quite in shape at the moment
21:19:21 * stepcut is using right now
21:19:35 <Gwern> I'm using it now. it's not as good as ratpoison or stumpwm yet, but it has potential
21:20:02 <dons> Gwern: what's needed, in your opinion?
21:20:24 <Gwern> dons: see previous message
21:20:41 <Gwern> I don't want my alt bindings stolen! I have two perfectly good superfluous keys, 'less
21:20:46 <dons> mm?
21:20:47 <Gwern>  and '>' which I'm not using
21:20:51 <dons> oh.
21:20:58 * Gwern curses the placement of apostrophes and the return key
21:21:00 <dons> edit Config.hs then.
21:21:03 <sorear> that's easu
21:21:05 <dons> no?
21:21:24 <dons> is it just key bindings you're worried about?
21:21:25 <Gwern> dons: but AFAIK, the type of the modifier key only allows mod[1-5]Mask and cousins
21:21:30 <Gwern> which aren't arbitrary keys
21:21:36 <sorear> Gwern: xmodmap!
21:21:40 <Gwern> I've been trying to figure out how to use xmodmap, but...
21:21:44 <dons> hmm.
21:21:47 <Gwern> sorear: yes, but xmodmap is insane
21:22:10 <sorear> makes perfect sense to me.
21:22:15 <sorear> might be biased tho
21:22:28 <Gwern> dons: well, there're some bugs, and I would like stumpwm's run-or-raise, but I think if the keybinding thing were made easier or something then I could switch primarily to xmonad
21:22:28 <sorear> having written a kbd driver or two
21:22:35 <Gwern> sorear: -_-
21:22:44 <narain_> is the plan to keep xmonad <= 400 lines even if features are added?
21:22:52 <dons> yeah.
21:22:53 <sorear> yes
21:22:54 <dcoutts> @yarr!
21:22:55 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
21:22:59 <dons> there's a lot of yucky code to chuck.
21:23:01 <dcoutts> g'afternoon folks
21:23:05 <sorear> but nobody said the plan was followed :)
21:23:09 <sorear> hi dcoutts
21:23:26 <dons> Gwern: have you tried using '0' as a modMask?
21:23:29 <stepcut> dons: this is my biggest annoyance with xmonad: http://www.n-heptane.com/nhlab/tmp/xmonad-annoyance.png
21:23:34 <narain_> that would be quite impressive... more features in the same loc
21:23:34 <stepcut> sorry about the resolution
21:23:54 <Gwern> dons: I don't understand - you mean use mod0Mask?
21:24:00 <dons> narain_: by the power of abstraction.
21:24:10 <dons> Gwern: i mean, using no mask at all
21:24:24 <dons> stepcut: transients?
21:24:28 <Gwern> would that even compile? how would you control xmonad?
21:24:42 <stepcut> yeah, the find box + no matches found take up 75% of the screen
21:25:03 <stepcut> 'no matches found' takes up 50% for a line of text + one button
21:25:04 <stepcut> :p
21:25:32 * Gwern remembers one bug - for some reason, when I switch to the second virtual desktop/work group/M-2 thing, it puts applications in a partial frame, and then when I switch back to 1, everything I opened up in 2 follows me back
21:25:54 <narain_> dons: so you plan to find better and better abstractions as you go along? considering the code's right up against 400 loc, iirc.
21:26:07 <narain_> that's what i meant by "that would be impressive" :)
21:27:22 <Gwern> narain_: what better abstraction could you have besides circular lists, anyway?
21:28:02 <sorear> Bah.
21:28:06 <dons> narain_: yeah, it all in the abstractions
21:28:09 <sorear> 'DrIFT -' doesn't work
21:28:11 <sorear> :(
21:28:21 <dons> i.e. refactoring repeated code into higher order control
21:28:36 <shachaf> sorear: 'DrIFT /dev/stdin' ?
21:28:44 <sorear> > nubBy(((>1).).gcd)[2..]  -- haskell is great for golfing!
21:28:46 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:29:08 <dons> yes, i'm not terribly happy with all the bugs that have crept in.
21:29:09 <sorear> shachaf: you didn't need to tell me :)  Actually I used /dev/fd/0 ... but still - is conventional
21:29:20 <dons> unfortunately, i've been too busy to work on xmonad for a while.
21:29:26 <shachaf> sorear: It is.
21:29:44 <sorear> shachaf: unresolved overloading
21:30:31 <Gwern> wow. dons, using 0 is weird. it eliminates any need to hit a modifier key, it seems?
21:30:59 <Gwern> that's great. a pity about all the keys one might want to use literally, like r or tab or space. :)
21:31:01 <xpika> does anyone know if GTK can run on OSX ?
21:32:00 <sorear> Sure it can.  Just use bochs ;)
21:32:24 * xpika googles bochs
21:32:29 <sorear> Actually, OSX supports X apps, so it should be usable...
21:32:33 <sorear> xpika: pc emulator
21:32:41 <sorear> xpika: NOT useful, hence ;)
21:32:47 * sorear needs to stop doing that
21:34:34 <narain> :t (?f.).?g
21:34:36 <lambdabot> Not in scope: `.?'
21:34:36 <lambdabot>  
21:34:36 <lambdabot> <interactive>:1:7: Not in scope: `g'
21:34:43 <dons> Gwern: i have no idea what you're asking for.
21:34:44 <narain> :t (?f .) . ?g
21:34:46 <lambdabot> forall b c a a1. (?f::b -> c, ?g::a1 -> a -> b) => a1 -> a -> c
21:34:48 <xpika> sorear: no, it was quite important
21:34:57 <dons> my impression was you were complaining about the need to use a Mod key?
21:35:02 <sorear> xpika: it was?!
21:35:08 <dons> anyway, Config.hs is all yours to hack on.
21:35:25 <xpika> sorear: PC emulation == lame
21:35:50 <sorear> xpika: so how is it important?
21:35:52 <sorear> narain: idiom for binary function composition
21:35:58 <Gwern> dons: my complaint is I can't use an arbitrary modkey
21:35:59 <sorear> @pl \x y -> f (g x y)
21:36:00 <lambdabot> (f .) . g
21:36:04 <sorear> narain: ^^
21:36:08 <xpika> sorear: I was looking for something like Wxhaskell
21:36:14 <dons> Gwern: you mean, a non-mod key as a mod key?
21:36:18 <Gwern> dons: yes!
21:36:26 <narain> sorear: thanks, i got it from the types
21:36:27 <xpika> sorear: but Wx has all these versioning issues for me
21:36:39 <sorear> Modifiers are not keys
21:36:40 <dons> ok. well, talk to X. that's too hard I think.
21:36:47 <Gwern> as in, I have a key which prints <, but I'd like to make that mod2Mask or something so I can freely use my regular Ctrl and Alt keys for y'know applications
21:36:55 <dons> Gwern: does any app your know do this?
21:37:04 <Gwern> dons: I can do this just fine in stumpwm and ratpoison
21:37:10 <Gwern> actually, I can do it with two keys
21:37:12 <dons> ok. find out how they do it.
21:37:21 <sorear> A modifier refers to a key, but you don't want to redefine keys to use different mods
21:37:38 <Gwern> sorear: why not?
21:37:54 <sorear> because you can just redefine the modifier!
21:38:07 <Gwern> sorear: ok. how do I do that?
21:38:14 <sorear> if you redefine Prev to give Ctrl, then you can't use prev etc normally
21:38:25 <sorear> uh, I forget, I haven't used X seriously in months :)
21:38:31 * sorear man xmodmap
21:38:44 <narain> Gwern: i used to use the Win key (Mod4, iirc) to keep Ctrl and Alt free, would that work for you?
21:39:00 <Gwern> sorear: xmodmap's man page or overall design is the product of demented minds in the throes of being tortured by demons from the darkest pits of hell
21:39:15 <sorear> echo -e 'clear mod5\nadd mod5 = FooBarKey' | xmodmap - should do it
21:39:16 <Gwern> it is something mothers whisper in the dark of night to frighten small children
21:39:17 <dons> however, this really is xmodmaps job, not xmonad.
21:39:28 <sorear> what does xev say
21:39:35 <dons> any functionality that can be done by an external program, doesn't really belong in xmonad.
21:39:38 <sorear> when you press the key you want to victimize?
21:39:38 <Gwern> (older children view it as archaic legend from the days of yore, if they give it credence at all)
21:40:08 <dons> xmodmap's not too hard. e.g. to rebind caps lock to ctrl,
21:40:09 <dons> xmodmap -e "remove Lock = Caps_Lock"
21:40:10 <dons> xmodmap -e "keysym Caps_Lock = Control_L"
21:40:10 <dons> xmodmap -e "add Control = Control_L"
21:40:11 <Gwern> xbindkeys -k says " m:0x0 + c:94
21:40:11 <Gwern>     less
21:40:22 <sorear> xbindkeys /= xmodmap
21:40:32 <Gwern> sorear: I realize that, but I have it handy
21:40:33 <sorear> I don't even HAVE xbindkeys
21:40:46 <Gwern> narain: that might. can't hurt to know how you did it
21:41:12 <sorear> oh, so you were drawing conclusions about the sanity of xmodmap without even trying to use it? ;-)
21:41:21 <narain> Gwern: it was when i was using wmii though :)
21:41:33 <Gwern> sorear: I have a xmodmap.. it was getting it to work that drove me to those conclusions
21:41:46 <narain> Gwern: it's Mod4 if that's any help
21:41:55 <Gwern> I think I eventually wound up using some tool of Zawinski's to generate it programmatically >.<
21:42:15 <Gwern> narain: no harm in giving it a shot
21:42:27 <sjanssen> dons: I like the idea of a feature freeze
21:43:24 <Gwern> narain: huh. bizaarely that works. another step towards my goal!
21:43:55 <narain> Gwern: glad to be of service
21:44:00 <dons> sjanssen: ok. anything you need that is currently missing?
21:44:13 <dons> with vertical tiling, i have everthing i need, I think.
21:44:23 <narain> Gwern: what's your goal though? world domination or something?
21:44:38 <Gwern> narain: no, pink, it's to TAKE OVER THE WORLD
21:44:43 <dons> ?brain
21:44:43 <lambdabot> I think so, Brain! How much deeper would the ocean be if there weren't sponges down there?
21:44:47 <Gwern> (wait, you said that, didn't you?)
21:45:06 <narain> :D
21:46:52 <sjanssen> dons: I can't think of anything at the moment
21:47:15 * Gwern ruminates. hmm. the two windows keys are bound to Super_L and Super_R, respectively, and those correspond to mod4Mask; so if I can make < and less be bound to the two supers, my goal will be acheived. the latter tasks seems feasible with xmodmap.
21:47:35 <dons> sjanssen: ok. how about we lock all features for 0.1 *now*. only refactoring and bug patches accepted till release?
21:47:44 <Gwern> sjanssen: how about some sort of little area where stuff could be printed? I don't know anyway to do it with dmenu
21:47:56 <dons> Gwern: fork dmenu. pipe text into it.
21:48:01 <dons> or use dzen* (I think)
21:48:07 <sjanssen> as far as keybindings, we really need to be more strict about changing them
21:48:22 * Gwern wasn't fond of the stealing of M-w or e
21:48:36 <Gwern> I was going to email you guys about it, but you fixed it. I appreciate it :)
21:48:40 <rashakil__> yeah, sorry.
21:48:43 <sjanssen> and I think we need a more sane system for them (so that contributors don't accidentally send me their personal changes)
21:48:55 <dons> yes. not sure how best to deal with that.
21:49:03 <dons> reject any patch that modifies Config.hs would be one way ;-)
21:49:38 <Gwern> how about some intermediate function which takes the default keymap as an argument, and takes a second one which consists of a user-supplied map, with entries in the second overriding entries in the first?
21:49:54 <dons> too complex. edit Config.hs
21:49:58 <sjanssen> I'll just delete the gmrun binding if stealing ctrl+space bugs people
21:50:07 <sorear> I'm rather fond of the idea of having Config.hs dispatch on LOGNAME
21:50:08 <dons> sjanssen: well, do you use gmrun?
21:50:09 <rashakil> they can edit it themselves
21:50:18 <Gwern> dons: too complex? it's what, a zip or something?
21:50:19 <sorear> then have everyone push their configs!
21:50:40 <Gwern> sorear: "dispatch on LOGNAME"?
21:51:01 <sorear> LOGIN, USER, man 7 environ, whatever.
21:51:10 <dons> Gwern: Config.hs is for user specified extra bindings. there's no need to add further configuration features, imo. you simply edit Config.hs
21:51:15 <sjanssen> dons: yes, but I think I'm the only one
21:51:17 * dons feels the power of Anselm inside!
21:51:27 <Gwern> dons: but aren't all the default bindings in Config.hs already?
21:51:31 <dons> sjanssen: ok. how about you take mod-p for that then?
21:51:37 <dons> and we comment it out by default?
21:52:04 <sjanssen> isn't mod-p for dmenu?
21:52:13 <dons> do you use both??
21:52:28 <Gwern> demenu and gmrun does seem like overkill
21:52:40 <sjanssen> I have ctrl-space burned into my fingers, so I'm going to stick with that binding
21:52:51 <dons> i'm suggesting we use dmenu by default. those who use gmrun instead, can comment out the dmenu binding, and use whatever is best for gmrun instead.
21:52:54 <dons> yep ok.
21:53:24 <dons> Gwern: you're missing the grand vision: Config.hs is for overriding default bindings. you use 'vi' to do this.
21:53:41 <dons> oh mighty Anselm, show me the way!
21:53:58 <Gwern> dons: you yourself was pointing out that this causes problems with patches, were you not?
21:54:09 <Gwern> and what does an adulterer like anselm have to do with this?
21:55:01 <thedward> I like gmrun because it has a history, but it is ugly
21:55:13 * dons ponders hosting xmonad on codesucks.org
21:55:19 <dons> is that free?
21:55:29 <thedward> ctrl-space messes with hit-a-hint though
21:55:35 <dons> or, featuresuck.org ? how about that?
21:55:43 <sjanssen> okay everybody, feature freeze effective immediately
21:55:58 <thedward> lambdabot doesn't have a whois plugin yet? :)
21:56:17 <dons> yeah, no feature freeze on lambdabot. ever. go nuts!
21:56:48 <sjanssen> right, I mean freeze on xmonad
21:56:49 <dons> sjanssen: ok. i'll devote some time after Saturday to cleaning up the layout code.
21:57:06 <dons> and we can polish it back down to 300 lines of pure gold :-)
21:57:26 <sjanssen> dons: can you think of a nice way to have both a DefaultConfig.hs and a UserConfig.hs?
21:57:51 <dons> so we can supply say, Default.hs, and the user needs to manually copy that onto Config.hs , or as part of the build process?
21:58:14 <sjanssen> I'd like something automatic, so it just builds out of the box
21:58:14 <dons> (i.e. so no Config.hs appears under darcs control?)
21:58:46 <dons> i can't think of a nice way to do this, other than by treating Config.hs as a preprocessor file of some sort.
21:58:59 <sjanssen> hmm
21:59:14 <sjanssen> maybe requiring an ln -s is okay?
21:59:17 <sjanssen> dons: what do you think?
21:59:44 <dons> can't we just say "Dont record changes to Config.hs" ?
22:00:09 <thedward> darcs makes that very easy
22:00:22 <dons> right.
22:00:29 <Gwern> btw, I've been meaning to ask: I understand Xinerama headers are needed to compile, but when you're actually running the binary, they aren't needed, right?
22:00:54 <sjanssen> I can't honestly say that I'll never accidentally record and push one of my private changes to Config.hs
22:01:26 <sjanssen> Gwern: the headers aren't needed, but the library is
22:01:28 <dons> hmm. how do your settings differ from the defaults?
22:01:40 <sjanssen> dons: ctrl-space to gmrun
22:01:51 <jcreigh> ah, so somebody *does* use gmrun. :)
22:02:31 <dons> i'd be inclined to invoke authors privledge then. (i know what I said earlier ;).  just stick gmrun in there.
22:02:45 <dons> since your Config.hs should be the default.
22:03:09 <sjanssen> I understand ctrl-space is really needed for emacs?
22:03:16 <jcreigh> hmm.
22:03:28 <dons> we could provide some suggested emacs bindings in a comment
22:03:33 <Gwern> sjanssen: ok. another question, is xinerama library necessary for running?
22:03:39 <stepcut> sjanssen: yes, you need it to mark the beginning of a region (for copy and paste, etc)
22:03:40 <Gwern> even if you aren't using it?
22:03:59 * Gwern seconds stepcut. I was seriously wondering how emacs broke when I wasn't looking
22:04:03 <sjanssen> Gwern: yes, X11-extras links against it and calls it at runtime
22:04:07 <jcreigh> Gwern: yes. but if you have the headers, I imagine you have the library as well.
22:04:15 <stepcut> emacs uses everything, changing Mod1 to Mod4 is probably a reasonable suggestion
22:04:19 <stepcut> Mod4= windows key
22:04:22 <dons> Gwern: nope. Xinerama libs arne't needed at runtime
22:04:26 <Gwern> jcreigh: I installed them just for playing around with Xmonad. I don't really want it
22:04:30 <Gwern> dons: I'm glad to hear that
22:04:37 <sjanssen> Gwern: if you want to eliminate the xinerama dependency, make it configurable in X11-extras
22:04:39 <jcreigh> dons: err...what?
22:04:43 <sjanssen> dons: yes, they're needed at runtime
22:04:57 <dons> well, maybe they are, now I look into X11R6/lib a bit more.
22:05:08 <dons> but if my old openbsd systme has them, then so does everyone
22:05:40 * sorear continues plotting lambdabot7
22:06:42 <Gwern> sjanssen: understood
22:06:48 <sjanssen> do any xmonad contributors use alternate keybindings?
22:07:00 <jcreigh> I have modMask = winkey, but that's it.
22:08:03 <sjanssen> dons: do you?
22:08:31 <dons> nope. i just use the defaults
22:09:57 <jcreigh> BTW, did an xmonad ML ever materialize?
22:10:58 <dons> ah reminds me.
22:11:03 * dons checks
22:13:09 <dons> i'll have to look into this tomorrow. bit busy now.
22:16:20 <Gwern> sjanssen: I do
22:17:09 <Gwern> I've got a bunch to import from stumpwm as xmonad permits, but generally I change movement keys and add 'd' to be firefox and 'e' for emacs, and 'g' and 't' for google and wikipedia respectively
22:17:34 <sjanssen> so you've got extensive changes
22:18:39 <Gwern> sjanssen: yup
22:19:17 <Gwern> (I've been using rp/stumpwm for going on a year. lots of time to make modifications and things more comfortable)
22:32:09 <sjanssen> hmm, is M-w a really critical emacs key too?
22:32:30 <sorear> Not really critical.
22:32:38 <sjanssen> sorear: what does it do?
22:32:48 <sorear> But any emacser would be stupid to have xmonad use meta.
22:32:51 <sorear> sjanssen: copy
22:33:03 <sorear> sjanssen: like C-w = cut, C-y = paste
22:33:10 <stepcut> sjanssen: kill-ring-save (also know as copy)
22:35:04 <stepcut> and, M-space == just-one-space, "Delete all spaces and tabs around point, leaving one space."
22:35:10 <sjanssen> hmm.  so ctrl-space is more annoying for emacsers because it uses another (non-configurable) mask
22:35:23 <stepcut> useful for turning, "hello      world", into "hello world"
22:36:36 <stepcut> in order to copy in emacs, I typically do, "C-space, move to the end of the region I want to copy, M-w", and both those keys are bound by xmonad :p
22:37:19 <jcreigh> of course, if you have a different modmask, only the former will be bound by xmonad.
22:37:20 <stepcut> and M-p is usually bound it *-previous-command, where * is dependent on the context (erc, shell, etc)
22:37:41 <sjanssen> if our keybindings are annoying for emacs users anyway, maybe I should just ignore their whining about ctrl-space :)
22:37:54 * jcreigh thinks that the winkey is ideal for windows mangers
22:38:18 <jcreigh> sjanssen: I don't think xmonad should bind anything that doesn't have modMask in it.
22:38:35 <jcreigh> ...IMHO
22:38:44 <stepcut> sjanssen: yeah, there is a lot of overlap. fixing just one binding isn't going to help
22:38:52 <sjanssen> yes, this is a good point
22:39:29 <sjanssen> maybe we really should dispatch on username, per sorear's suggestion
22:39:40 <jcreigh> heh.
22:39:50 <stepcut> sjanssen: how about looking at $EDITOR :p
22:40:04 <jcreigh> no, I think we just need to get a slightly better scheme for managing Config.hs
22:40:21 <jcreigh> (so we don't always have to remember not to submit our personal changes in a patch)
22:40:30 <sjanssen> jcreigh: any ideas?
22:41:03 <Gwern> sjanssen: I already proposed one. separate the default and user keymaps
22:41:15 <sjanssen> Gwern: how?
22:41:18 <Gwern> have some trivial little lambda or function integrate the two with priority for the user
22:41:30 <Gwern> (dons didn't like it though)
22:41:41 <sjanssen> I don't think this solves the really annoying issues
22:42:00 <Gwern> issues beyond the accidetanl patch stuff?
22:42:06 <jcreigh> hmm
22:42:17 <sjanssen> Gwern: this doesn't solve the accidental patch stuff at all
22:42:38 <thedward> I kind of like the idea of a wm with modes (kind of like vi); Just have one keybinding that gets you into wm mode, then all keystrokes go to the wm, otherwise everything but the wm-mode binding goes to applications.
22:43:02 <jcreigh> thedward: ratpoison kind of has that. (prefix key, like screen)
22:43:15 <thedward> huh. I'll have to check that out.
22:43:34 <Gwern> stumpwm has it even better
22:43:36 <thedward> though, using xmonad is good for encouraging me to play around with haskell more. :)
22:44:10 <sjanssen> jcreigh: what do you think about requiring a new user to copy/symlink to a DefaultConfig.hs?
22:44:19 <Gwern> sjanssen: I don't understand why it wouldn't? you could have a module in another file with nothing but the user keymap, an import in Config.hs, and everytime the user edits that other file, Config.hs need never change
22:44:38 <Gwern> or I guess the keymap could be moved into Xmonad.hs and importing from Config.hs?
22:44:50 * Gwern doesn't really see any obvious path, though
22:45:11 <Gwern> oh, hey! I fixed my keybinding problem!
22:45:18 <sjanssen> Gwern: Config.hs will need to mention that user config file.  So that means the user config must be in darcs to make sure that xmonad builds by default
22:45:37 <jcreigh> sjanssen: problem with that is when we add a new setting. all of a sudden everybody's Config.hs would break because it didn't define defaultFoobarWidget
22:45:50 <jcreigh> (if they had copied to make modifications)
22:46:03 * Gwern switched to mod4Mask, and then used xkeycaps to generate a .xmodmap which swapped Super_L and less, and Super_R and Insert
22:46:53 <Gwern> btw, someone made a misspelling in Config.hs : "swtiches", if anyone cares
22:47:16 <jcreigh> nonsense. whoever wrote the docs in Config.hs would never make such a trivial typo. :)
22:47:28 <jcreigh> Gwern: thanks, we'll fix that.
22:47:41 <thedward> would it be just too huge a hack to add a configure script and have that create the user config?
22:48:41 <Gwern> while you're making trivial changes to Config.hs, could you remove the like 50 '--'s in the top and just enclose it all in {- -}?
22:48:59 <Gwern> (that's just way too many hyphens there, imo)
22:49:02 <jcreigh> Gwern: yeah, I suppose. -- bugs you?
22:49:08 <Gwern> jcreigh: strangely, yeah
22:49:49 <jcreigh> oh, wait, that typo might not have been my fault. heh. :)
22:50:50 <Gwern> out of curiosity, how are you guys counting lines?
22:50:57 <jcreigh> I almost wonder if there should be Config monad. there your config file would look like:
22:51:08 <jcreigh> modMask = mod4Mask
22:51:12 <rhz> Is the module HGL known to work/not work on Mac OS X?
22:51:16 <jcreigh> config = do
22:51:21 <jcreigh>     defaultBindings modMask
22:52:02 <jcreigh>     unbind (modMask, xk_p) -- if I didn't want mod-p bound for whatever reason
22:52:16 <jcreigh>    bind (modMask, xk_z) (spawn "do_something_cool")
22:53:55 <sorear> hello jyp
22:54:09 <jyp> Hey sorear
22:54:20 <jcreigh> just a crazy idea. Thoughts? It would be pretty heavyweight comparing to the current system...
22:54:49 <Gwern> rhz: I think it's supposed to work. I vageuly remember reading about a Tetris in Haskell using the OpenGL binding which was developed by a guy using OSX
22:54:58 <sjanssen> jcreigh: yes, I think it's overengineering
22:55:11 <dcoutts> rhz: but generally HGL doesn't work well on any platform
22:55:18 <dcoutts> nobody maintains it
22:55:34 <dcoutts> and it has issues with threads
22:56:21 <mwc> that's too bad
22:57:29 <xpika> is there any way to interface to JDK functions from haskell?
22:58:00 <dons> not easily.
22:58:04 <jcreigh> can't we hook into Cabal somehow and copy DefaultConfig.hs to Config.hs if it doesn't exist?
22:58:04 <dons> jvm /= ghc runtime
22:58:32 <sjanssen> well, the really evil thing would be to add it to the Setup.lhs
22:58:40 <rhz> Gwern: I don't think HGL has anything to do with OpenGL. It appears to be a binding to X11.
22:58:45 <Gwern> sjanssen: why is that evil?
22:58:54 <Gwern> rhz: oh. well, I did say I wasn't very sure
22:59:01 <mwc> xpika, if you're looking to bring some of the niceness of Haskell to the JVM, look into Scala
22:59:17 <sjanssen> Gwern: it is generally discouraged to have a non-trivial Setup file
22:59:19 * xpika googles Scala
22:59:42 <Gwern> sjanssen: but if it's trivial, why have it?
23:00:20 <sjanssen> history
23:00:52 <Gwern> oh. I guess even Haskell has to make compromises because of history and backwards comaptibility and Stuff
23:01:13 <sjanssen> it was a bad decision in the original Cabal design that everybody regrets now
23:01:38 <mwc> It's too bad we can't have an epoch for standards
23:01:52 <xpika> mwc: sorry scala isnt concise enough for me.
23:02:58 <mwc> xpika, don't let the Java-like syntax confuse you, it's pretty functional. They claim to have implemented monads
23:03:16 <xpika> mwc: sorry its no haskell. :(
23:03:18 <jcreigh> "WARNING: The hooks interface is under rather constant flux as we try to understand users needs. Setup files that depend on this interface may break in future releases."
23:03:23 <jcreigh> hmm.
23:03:52 <mwc> Define an epoch for Cabal, say that Cabal 2 will be out by 2008 and that the current epoch will be completely unsupported by '09
23:05:46 <jcreigh> sjanssen: I can't immediately think of anything better to do than symlink Config.hs to DefaultConfig.hs in a preBuild hook. Should I go ahead and do that?
23:06:30 <sjanssen> jcreigh: let's hold off on that for a while
23:06:34 <jcreigh> k
23:10:30 <jcreigh> anyway, it's bedtime. 'night all
23:10:49 <dcoutts> rhz: it's not specific to X11, on win32 it uses a different underlying impl of course, but I think on OSX it probably uses X11
23:21:06 <rhz> dcoutts: i see. When I try to run the function "getTime" from ghci in the HGL module it gives me this error: "Loading package X11-1.1 ... can't load .so/.DLL for: X11 (dlopen(libX11.dylib, 10): image not found)"
23:21:59 <rhz> I have got libX11.dylib installed. Not sure how to point HGL to the right path though.
23:22:25 <dcoutts> is it in the right place? how about the search path
23:22:44 <dcoutts> rhz: try asking someone who knows anything about GHC on Mac OS X
23:22:56 <rhz> dcoutts: such as?
23:23:41 <dcoutts> hmm, most the people I know who use OSX are asleep
23:28:25 <sorear> OK, for google's sake I've finally made myself a web page ...
23:29:34 <jyp> dcoutts: got any chance to look at Yi lately?
23:29:59 <jyp> I'm afraid I have a couple of questions for you :)
23:31:54 <sorear> @where sorear
23:31:54 <lambdabot> I know nothing about sorear.
23:32:07 <sorear> @where+ sorear http://members.cox.net/stefanor
23:32:08 <lambdabot> Done.
23:32:50 <dcoutts> jyp: I've not but I intend to, so what're the questions ?
23:33:06 <dcoutts> jyp: I hear from dons that you're making stead progress :-)
23:33:10 <dcoutts> steady
23:33:30 <jyp> dcoutts: basically I can't seem to focus the textview I want in the gtk frontend
23:33:42 <dcoutts> hmm, ok so what happens?
23:33:42 <jyp> the cursor appears nowhere
23:34:17 <dcoutts> are you binding to any of the signals that control cusror movement ?
23:34:43 <dcoutts> a lot of default behaviour is implemented as the final default signal handler
23:35:00 <jyp> oh, that's interesting
23:35:15 <dcoutts> so intercepting signals and stopping propagation can cause weirdness
23:35:44 <dcoutts> but if you let them propagate it should all be ok
23:36:03 <jyp> I tried to connect to "onMoveCursor"
23:36:04 <dcoutts> ie insert your extra stuff but don't prevent the remaining handlers from getting their turn
23:36:23 <jyp> but I did not seem to get any event
23:36:48 <jyp> I'll try to remove this and see what happens for the other problem
23:38:52 <dcoutts> jyp: according to the docs that signal is one of these slightly odd 'action' signals
23:39:00 <dcoutts> and it's not clear if we should bind it at all
23:39:05 <dcoutts> http://developer.gnome.org/doc/API/2.0/gtk/GtkTextView.html#GtkTextView-move-cursor
23:39:08 <lambdabot> Title: GtkTextView, http://tinyurl.com/yrsgfd
23:39:37 <dcoutts> it suggests apps should not bind to it, but of course you're no ordinary app you're making a derived editor widget
23:39:45 <jyp> dcoutts: well I removed that; the main problem remains.
23:40:32 <mwc> Hmm, read http://www.joelonsoftware.com/articles/Wrong.html if you haven't already, which discusses Hungarian notation (as it was originally intended, to document the properties of a value rather than its type.)
23:40:34 <lambdabot> Title: Making Wrong Code Look Wrong - Joel on Software
23:40:38 <dcoutts> jyp: to track cursor change you might want to use the buffer's mark-set signal instead
23:40:44 <mwc> Seems to me like EXACTLY the sort of thing newtypes are for ;)
23:41:33 <dcoutts> jyp: the cursor is one of theses 'marks', the cursor is just one builtin mark, there's also one for each end of the selection (actually one end of the selection is the cursor itself)
23:42:21 <jyp> dcoutts: I will try that;
23:42:38 <dcoutts> jyp: anyway you can get notified when a mark changes, though unfortunately at the moment you can only be notified of *all* mark changes, not just for a specific mark, that's because we've not bound the 'detail' bit of the signal connect stuff.
23:42:40 <jyp> for tracking cursor position...
23:42:51 <jyp> but;
23:43:09 <dcoutts> jyp: but at least it gives you a ref to the mark so you can check if it's the one you want.
23:43:16 <jyp> do you know how to force the cursor being displayed (at all) in a textview?
23:43:32 <jyp> I currently use widgetGrabFocus
23:43:39 <jyp> but that does not seem to do the job.
23:44:03 <dcoutts> jyp: it should happen automagically when a widget gets the focus, eg when you tab to it or click in it
23:44:15 <jyp> The problem is...
23:44:37 <jyp> 1. we might want to change focus with a keybinding (emacs C-x o)
23:44:47 <jyp> 2. when a window is created I want to focus it
23:44:58 <jyp> s/window/textview
23:45:01 <dcoutts> right, I think you can do that
23:46:48 <dcoutts> jyp: looks like widgetGrabFocus is ok, all that does it make the widget the focus widget for the window it's in (so it gets focus if the window itself has global focus)
23:47:54 <jyp> Well that does not seem to work
23:48:32 <dcoutts> jyp: and just clicking in the text view does work right ?
23:48:41 <jyp> yup
23:50:05 <dcoutts> jyp: and the top level window it's in is focused at the time right
23:50:05 <dcoutts> ?
23:50:16 <jyp> dcoutts: yes.
23:52:05 <dcoutts> and you're not binding to any of the widget focus signals ?
23:52:31 <jyp> I'm binding to `onFocusIn` ...
23:52:45 <dcoutts> ah
23:53:07 <dcoutts> and do you return True or False ?
23:53:11 <jyp> True
23:53:28 <dcoutts> Returns : 	TRUE to stop other handlers from being invoked for the event. FALSE to propagate the event further.
23:53:36 <dcoutts> try False
23:53:50 <jyp> ...
23:54:04 <jyp> \o/
23:54:07 <jyp> Thanks :)
23:54:10 <dcoutts> np
23:54:31 <dcoutts> that's the way most of theses signals that return True/False work
23:55:04 <dons> dcoutts: so what's the state of the list comprehension project?
23:55:09 <jyp> Well I never really used that before... And therefore did not understand the semantics :)
23:55:18 <dons> will we be in a position to benchmark things (or at least pass them to roman) tomorrow?
23:55:45 <dcoutts> dons: lemme chceck the result of my latest build...
23:56:33 <dcoutts> jyp: we should probably change the type from Bool to data Something = BlockSignal | PropagateSignal so it's be clearer. Bool is so untyped :-)
23:56:50 <lizhn> hello, is there any StringToInteger function?
23:56:58 <dcoutts> read
23:57:16 <lizhn> dcoutts: thx
