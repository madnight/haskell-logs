00:09:08 <glguy> sucks that people are abusing the pastebin
00:09:19 <glguy> I was hoping it would take longer for the assholes to come around
00:09:45 <glguy> maybe they don't know any better
00:09:49 <glguy> and they think it's general purpose
00:22:31 <dons> glguy: just the guys last night?
00:22:35 <dons> have there been any others?
00:23:07 <dons> there was a suggestion to cross check the ip address against #haskell if we care, or create an account.
00:23:14 <glguy> 217.21.43.222
00:23:27 <glguy> doesn't show up in /who
00:23:35 <glguy> anddoesn't resolve to a hostname
00:24:16 <astrolabe> dons: maybe the pastebin would help sell haskell, like lisppaste sells lisp.  It would be nice not to have irrelevent pastes notified on #haskell though.
00:24:17 <glguy> we could just have a key in the /topic
00:24:40 <glguy> and we change the key when it becomes a problem
00:24:57 <glguy> and I set a cookie so you don't have to retype the key
00:25:17 <dons> glguy: so was there other abuse, other than the overeager pasting yesterday?
00:25:43 <glguy> it is more like misuse i guess (tonight)
00:27:40 <dons> you know about the guys bugging us this time yesterday?
00:27:52 <dons> i had to delete a couple
00:27:54 <glguy> I saw it in the logs
00:28:11 <dons> so you're referring to something else?
00:28:23 <dons> ~oh yes. i see.
00:28:23 * dons scrolls
00:28:57 <dons> maybe hmm. disable irc except for registered users
00:29:02 <dons> that'd work for me.
00:29:15 <astrolabe> how do you get regestered?
00:29:44 <astrolabe> beginners will be some of the most common users I think
00:29:54 <dons> you hand your nick to glguy, if you loging as that person, you get the irc announce button
00:30:07 <glguy> heh, you could ask a currently registered user to add you
00:30:09 <dons> then it stores a cookie
00:30:15 <dons> right.
00:31:21 <glguy> doesn't solve much though, unless we use passwords, and I don't want to do that
00:31:29 <glguy> because abusers will just use the nicks listed on the site
00:31:44 <astrolabe> I was toying with the idea of making a baysian-based spam-spotter for lambdabot so it could boot them automatically.
00:32:05 <astrolabe> The abusers know a bit about #haskell then?  That makes it harder.
00:32:19 <glguy> no, the nicks listed on the index page
00:32:24 <glguy> they could just reuse one
00:32:26 <dons> glguy: oh, i was thinking of passwds, like the admin accounts
00:32:32 <astrolabe> Ah, ok.
00:32:32 <dons> glguy: but then a cookie that remebers you
00:32:39 <glguy> ah
00:32:52 <glguy> I also want a low barrier-to-entry
00:32:54 <dons> and yeah, unlikely they'd know the nicks. people don't care that much
00:33:12 <dons> note the nicks above are all silly obfuscated thingies
00:33:31 <dons> glguy: or, make it easy for admins to find and block ip addresses?
00:33:31 <astrolabe> How about automatically allowing posts that contain recognisable haskell code?
00:34:11 <astrolabe> I clean my cookies out quite often (paranoid)
00:34:14 <dons> i'd be happy with just with the ability to find the ip addr of a poster and to then block that ip addr, via the admin functions
00:34:36 <dons> even better, !block 42
00:34:47 <dons> would for admins, here, block the ip addr of post 42, as it appears here.
00:34:51 <dons> that'd be fast
00:35:02 <glguy> true
00:35:17 <glguy> I need to figure out a good way for the irc bot to communicate with the webserver
00:35:18 <astrolabe> yes, as long as there is an admin about at the time.
00:35:30 <glguy> astrolabe: well, we'd just have to have a lot of admins
00:36:08 <dons> so "3AbE|/| pasted "A" at http://hpaste.org/726"  then we say @block 726
00:36:23 <glguy> anyway, I'm not going to implement some advanced system like this unless it becomes a big issue
00:36:27 * glguy crosses fingers
00:36:29 <dons> agreed
00:36:39 <dons> if we could just block viathe admin interface, that'd be enough i think
00:36:46 <astrolabe> glguy: right.  Maybe it would be sufficient to allow anyone to do it.  It doesn't seem as though the abusers and those that understand about lambdabot intersect at all
00:37:06 <glguy> lambdabot: doesn't understand hpaste yet :)
00:37:11 <glguy> !say independent logic
00:37:12 <hpaste> independent logic
00:37:43 <hpaste> quite life-like
00:37:52 <Baughn> astrolabe: That might risk abuse. It probably isn't an issue, but I would be very nervous about implementing something like that in ##C.
00:38:28 <hpaste> I noticed you were trying to make a paste about C++, would you like me to delete it for you?
00:38:43 <astrolabe> Baughn: There is a risk, but if it went wrong, the system could be changed.
00:38:45 <astrolabe> Heh
00:38:49 <roconnor_> should hpaste posts be limited to usernames on #haskell?
00:39:23 <ivanm> roconnor: what happens for someone using it from another haskell channel?
00:39:30 <astrolabe> roconnor_: They use other's nicks.  See above
00:39:32 <glguy> it could just trigger off when you say !paste
00:39:49 <roconnor> 3AbE|/| is someones' nick?
00:40:06 <glguy> the /new page could be locked until someone does a !paste and then it could unlock for 10 seconds ;)
00:40:23 <astrolabe> The sooner they get the unsafeLaunchMissiles command working, the better.
00:40:31 <Baughn> I like the idea of trying to parse it as code. How often does anyone paste something that doesn'T contain haskell?
00:41:02 <glguy> all they would have to do is {-   -} around it :)
00:41:07 <roconnor> Baughn: all the time; although you could put everything in a comment I guess :)
00:41:31 <Baughn> contain != is. ;)
00:41:35 <astrolabe> glguy: It depends if the abusers know about haskell.
00:41:54 <roconnor> what were they pasting?  links to porn?
00:42:33 <ivanm> c++ code
00:42:36 <roconnor> (wonders if this is just people screwing around, or trying to boost their search results)
00:42:37 <ivanm> even worse ;)
00:42:41 <glguy> and vulgarity earlier
00:43:02 <glguy> how about... !paste tells you you need to prefix your title with a >
00:43:06 <roconnor> Oh, so it is just people who will eventually get board.
00:43:10 <glguy> prefixing your title with a > is the secret!
00:43:22 <glguy> sure it could leak
00:43:29 <glguy> and I'd just change the character :-p
00:43:39 <glguy> but !paste could reveal the hidden knowledge
00:43:48 <roconnor> glguy: I kinda like your locking of /new idea.
00:44:33 <glguy> hell
00:44:34 <glguy> then
00:44:40 <glguy> when we tell a newb to go to !paste
00:44:42 <glguy> and paste something
00:44:48 <Baughn> glguy: If you're going in that direction, how about having !paste drop a single-use key?
00:44:51 <glguy> ... they won't even know it was locked ;)
00:45:18 <roconnor> Baughn: I fear people may swipe a one time key out from under the user.
00:45:27 <glguy> lol
00:45:33 <glguy> this doesn't needto be bullet proof
00:45:47 <astrolabe> We need to decide how sophisticated we think these people are.
00:46:10 <glguy> and we need to make it easy for joe newb to makea paste
00:46:14 <glguy> without reading the hpaste man page
00:46:17 <astrolabe> right
00:46:19 <Baughn> roconnor: Biometric identification, then
00:46:42 <glguy> ok, everyone that wants to paste runs their own hpaste
00:46:49 <glguy> we have a channel #haskell-pasteannounce
00:46:55 <glguy> that you can idle in to hear the announces
00:47:03 <glguy> solved!
00:47:18 <roconnor> Baughn: I say we set up a world government where we all get retinal scans put into a global central database.  Then users have their eyes scanned and compared to the database before they can post haskell code.
00:47:22 <ivanm> lol... and how are joe newb (like myself) meant to run our own hpaste?
00:47:23 <Baughn> Actually, you could have !paste drop an URL with key and username embedded. That would be useful enough to be.. used.
00:47:31 <astrolabe> glguy: the hpaste code would need to be distributed with bugs in so that only programmers could use it.
00:47:50 <glguy> astrolabe: it *kind of* is already!
00:48:00 <astrolabe> heh
00:48:28 <roconnor> I know, how about people just dump their code right into #haskell. :D
00:48:30 <glguy> because you can't darcs get HAppS and hpaste right now
00:48:39 <glguy> and expect it to compile
00:48:51 <glguy> happs moved too far
00:49:04 <glguy> and the updated code base isn't on kakapo
00:49:24 <glguy> because I just pushed all the changes todya and yesterday
00:49:26 <glguy> (to happs)
00:49:30 <roconnor> Baughn: Still other people could take the users post.
00:49:42 <roconnor> I'm sure that would become annoying
00:49:49 <Baughn> roconnor: Have it reply by privmsg?
00:49:56 <kolmodin> how about making a console interface so I don't have to use my web browser? :)
00:49:56 <roconnor> Baughn: oh
00:50:05 <glguy> kolmodin: oh, you mean elinks?
00:50:07 <glguy> kolmodin: that's done
00:50:16 <kolmodin> heh, nice :)
00:50:27 <glguy> elinks http://hpaste.org
00:50:44 <roconnor> Baughn: that's not a half bad idea; although I still think the 30 second unlock or whatever is simpler and just as effective.
00:50:45 <Baughn> kolmodin: If you want an upload-file script.. you could probably slightly modify rafb.pl
00:51:02 <Baughn> roconnor: 30 seconds would be extremely annoying to me.
00:51:10 <kolmodin> oh, elinks is a text mode web browser
00:51:38 <roconnor> Baughn: what do you mean.  Does it take you more than 30 seconds to get from !paste to the /new page?
00:51:57 <glguy> it *would* be annoying
00:52:03 <Baughn> roconnor: Quite often, yes.
00:52:05 <glguy> i never said it wouldn't do that :)
00:52:18 <glguy> and I never type !paste in for any reason other than to spam
00:52:28 <Baughn> roconnor: The paste page is /cached/; it doesn'T actually hit the server until I submit. I checked.
00:52:29 <glguy> !paste
00:52:30 <hpaste> Haskell paste bin: http://hpaste.org/
00:52:31 <glguy> like that
00:52:36 <roconnor> Baughn: oh, okay.  I'm surprised, but if that is true then.
00:52:38 <glguy> i know where it is :)
00:52:59 <glguy> Baughn: by design!
00:53:04 <roconnor> Baughn: The paste page can be made to be uncached.
00:53:15 <glguy> like the index page
00:53:15 <Baughn> roconnor: It would have to be, yes.
00:53:30 <glguy> why would it have to be??
00:53:36 <glguy> the point is to keep passer-bys out
00:53:38 <glguy> not to keep Baughn out
00:53:50 <kolmodin> glguy: I ment more like pybugz to bugzilla, http://www.liquidx.net/pybugz/
00:53:52 <lambdabot> Title: PyBugz - Python Interface to Bugzilla | liquidx
00:53:54 <Baughn> roconnor: Even so, some people (possibly including me; I'm not sure) have nonconforming transparent proxies between them and the web at large. Which cache even if told not to.
00:54:28 * glguy is not responsible for people that screw themselves with proxies and filters
00:54:34 <Baughn> roconnor: You'd have to generate a unique URL each time, even if the ?-parameter has no actual meaning, in which case you might as well use a one-time key
00:54:43 <Baughn> glguy: Even if it's half of norway? -_-
00:54:53 <roconnor> Baughn: The /new page can be turned into a POST request?
00:54:59 <glguy> is that a city in sweden?
00:55:04 <roconnor> POST requests cannot be cached.
00:55:10 <roconnor> (I hope)
00:55:14 <glguy> roconnor: POST requests can't be urls
00:55:26 <glguy> so... http://hpaste.org/new
00:55:28 <glguy> not a POST
00:55:32 <glguy> if you just type it in
00:55:49 <roconnor> Can /new redirect to a post? ... maybe not
00:55:59 <Baughn> roconnor: It'd have to use javascript
00:56:03 <roconnor> So when you do a get with a ?, is that cached?
00:56:07 <glguy> it could do whatever I want it to :-p
00:56:22 <glguy> what who decides which half of norway sucks?
00:56:23 <Baughn> roconnor: It's cached if and only if the url has been fetched before
00:56:23 <roconnor> I can't remember if Gets are always ``side effect free''
00:56:26 <glguy> s/what/and
00:56:29 <Baughn> glguy: The ISPs
00:56:39 <yts> hello, i have a quersion, how can i post the code?
00:56:46 <Baughn> roconnor: They're certainly supposed to be.
00:57:23 <TSC> !paste
00:57:24 <hpaste> Haskell paste bin: http://hpaste.org/
00:57:29 <TSC> yts: ^^
00:57:42 <roconnor> Baughn: yep
00:57:43 <TSC> (if it's not locked)
00:57:45 <glguy> surely, 'tis a joke
00:57:56 <Baughn> glguy: No.
00:58:02 <yts> !paste data Value = Vint Integer | Vdouble Double | Vbool Bool | Vvoid | Uninit deriving Show unwrap :: Ord a => Value -> Value -> (a->a->Bool) -> Bool unwrap (Vint a) (Vint b) op = op a b unwrap (Vdouble a) (Vdouble b) op = op a b
00:58:03 <hpaste> Haskell paste bin: http://hpaste.org/
00:58:07 <glguy> Baughn: no no, not your silly city!
00:58:08 <glguy> :)
00:58:14 * glguy dies
00:58:30 <ivanm> no, don't die glguy, come back, come back! ;)
00:58:42 <TSC> Well, I wasn't expecting that (:
01:00:14 <hpaste>  yts pasted "(no title)" at http://hpaste.org/727
01:00:54 <glguy> yts: that function can't be written
01:00:55 <yts> sorry for that...
01:01:08 <pejo> Baughn, since this seems to be a widely known issue (the broken proxy) - why don't the customers complain?
01:01:18 <yts> glguy: why??
01:01:40 <Baughn> pejo: Almost nobody knows about it, because there are exceptions for commonly used websites
01:01:52 <glguy> yts: because you have to give "op" a single type
01:01:59 <Baughn> pejo: Also, caching of GET requests - even erronous caching - isn't /supposed/ to cause trouble.
01:02:05 <glguy> yts: and it can't have one because you want to apply it to a lot of things
01:02:09 <glguy> rather
01:02:11 <glguy> more than one type
01:02:32 <glguy> especially when those types have nothing in common
01:02:40 <yts> glguy: but i use a->a->Bool @@
01:02:52 <glguy> yeah, that's part of why it didn't work
01:04:15 <glguy> yts: what would this mean:
01:04:58 <yts> glguy:so i can not write this kind of function...right?
01:05:29 <yts> glguy: is there any ways to write this, like generic programming?
01:06:53 <TSC> Not exactly like that
01:07:09 <TSC> What would "unwrap Uninit Uninit (<)" do?
01:08:20 <yts> i can sure that only Vint and Vdouble can apply in ~
01:09:45 <glguy> unwrap :: Value -> Value -> (forall a. Ord a => a->a->Bool) -> Bool
01:09:49 <glguy> hurray beer!
01:11:29 <hpaste>  glguy annotated "(no title)" with "unwrap" at http://hpaste.org/727#a1
01:13:04 <glguy> yts: did you read that?
01:13:08 <yts> glguy: i still can not compile it
01:13:20 <glguy> what compiler
01:13:33 <yts> ghci
01:13:39 <glguy> use -fglasgow-exts
01:13:45 <glguy> ghci -fglasgow-exts
01:14:53 <yts> glguy: it's not standard usage?
01:15:10 <glguy> no, what you are doing is not idiomatic
01:15:14 <glguy> requires extensions
01:15:32 <glguy> but , it works , so yea!
01:15:34 * glguy sleeps
01:15:44 <yts> glguy: thanks ~~
01:16:28 <TSC> Is there a nice way to read (forall a. Ord a => a->a->Bool) ?
01:17:44 <glguy> http://cvs.haskell.org/Hugs/pages/users_guide/quantified-types.html
01:17:48 <ivanm> for every type of variable which has an ordering, this function takes two of those variables in and spits out a boolean
01:17:49 <lambdabot> http://tinyurl.com/2xvnrl
01:18:27 <TSC> Ahh, thanks (to both)
01:23:35 <yts> glguy: but i think the meaning of Ord a => and forall a . Ord a => is the same
01:25:47 <yts>  but i think the meaning of Ord a => and forall a . Ord a => is the same
01:26:02 <yts> :yts test
01:26:46 <ivanm> yts: pretty much, I think the forall bit is just lambdabot
01:27:13 <yts> ivanm:lambdabot?
01:27:48 <ivanm> the haskell IRC bot with various haskell-orientated plugins
01:27:56 <ivanm> its the only one I've seen that uses the forall syntax
01:28:35 <ivanm> @type \ x -> x < x
01:28:37 <lambdabot> forall a. (Ord a) => a -> Bool
01:28:41 <ivanm> see?
01:29:07 <ivanm> that was a pretty stupid example though (it's always false!)
01:29:10 <quicksilver> ML 'tradition' is to keep the forall implicit
01:29:14 <ivanm> @type (<)
01:29:17 <lambdabot> forall a. (Ord a) => a -> a -> Bool
01:29:32 <quicksilver> because the only way ML allowed quantification was rank 1
01:29:38 <quicksilver> i.e. foralls on the outside
01:29:41 <quicksilver> so you might as well omit them
01:29:57 <quicksilver> haskell extensions take you past that, so it's convenient to be more explicit sometimes
01:30:28 <yts> quicksilver: but why can
01:30:43 <yts> not i use this unwrap :: Ord a => Value -> Value -> (a->a->Bool) -> Bool
01:31:01 <quicksilver> you can
01:31:03 <TSC> It's quantifying over different things
01:31:08 <quicksilver> it might not meanw what you think it means
01:31:10 <quicksilver> but you can use it :)
01:32:25 <yts> quicksilver: http://hpaste.org/727#a1, my question is like this~
01:32:53 <yts> quicksilver: i am thinking why can't i use the original one :p
01:35:14 <yts> @type (>)
01:35:16 <lambdabot> forall a. (Ord a) => a -> a -> Bool
01:47:42 <quicksilver> yts: your type says, it will work for any orderable type 'a'
01:48:45 <yts> quicksilver: is that Value -> Value -> (forall a. Ord a => a->a->Bool) -> Bool is the same?
01:48:46 <quicksilver> yts: but then it tries to apply that operator to the 'inside' of VInt, and also the 'inside' of VDouble
01:48:54 <quicksilver> no, that's quite different
01:49:05 <quicksilver> that says "give me an operator which works at any type"
01:49:22 <quicksilver> your original spec says "my function works with an operator of any Ord type"
01:49:39 <quicksilver> glguy's correction says "give me an operator which works at *every* ord type"
01:51:02 <Baughn> quicksilver: And now I finally grok forall. Somehow I'd missed that. Thanks!
01:51:33 <yts> quicksilver: thanks a lot :p
01:52:30 <quicksilver> np :)
01:52:45 <quicksilver> unfortunately the word 'any' is slightly ambmiguous in english
01:52:51 <quicksilver> or, at least, it's context sensitive
01:53:06 <quicksilver> but really the difference is between 'any arbitrary' and 'every'
02:13:04 <bhauth> So, what languages will haskell suck features from next?
02:13:49 <apfelmus> bhauth: ?
02:14:06 <siti> everyone is copying haskell not the other way around :p
02:14:44 <bhauth> Doesn't haskell exist as a sphere pulled forward by myriad fringe languages?
02:14:47 <apfelmus> indeed. unfortunately, nobody copies purity :)
02:15:00 <apfelmus> i mean indeed, everyone is copying from haskell
02:15:02 <audreyt> there's plenty of languages where haskell can copy from... I'd like Erlang's bit notation, for example
02:15:16 * bhauth points at Q
02:15:45 <audreyt> also, logic programming from Curry/Mozart/etc side is interesting too
02:15:53 <ivanm> what's O'Haskell like?
02:16:03 <apfelmus> why do you need bit notations if a decent parsing monad can do?
02:16:13 <bhauth> interesting, but imho better implemented as a feature not as a base
02:16:15 <audreyt> apfelmus: a parsing monad can get you first-class bits?
02:16:32 <apfelmus> what might first-class bits be?
02:17:08 <bhauth> "indeed. unfortunately, nobody copies purity"
02:17:12 <bhauth> why the smily?
02:17:20 <bhauth> if you really liked them you'd want them copied ^^
02:17:56 <audreyt> apfelmus: for example, in erlang you can have
02:17:56 <audreyt> <<X:1,Y:6,Z:1>>
02:18:05 <audreyt> which constructs a struct that's exactly 1 byte long
02:18:13 <audreyt> with three fields that are 1, 6 and 1 bits each
02:18:13 <apfelmus> bhauth: because purity is the source of power, but most ignore it
02:18:36 <audreyt> apfelmus: also you can case over then
02:18:44 <audreyt> *them
02:19:13 <apfelmus> <<...>> is a pattern? or can it serve as constructor, too?
02:19:17 <audreyt> both
02:19:27 <audreyt> see http://erlang.se/doc/doc-5.4.8/doc/programming_examples/bit_syntax.html
02:19:28 <apfelmus> ah
02:19:30 <lambdabot> Title: Bit Syntax, http://tinyurl.com/249pam
02:19:36 <quicksilver> audreyt: but in haskell you can have a type which contains X, Y, and Z, and is transparently written-to/read-from that bit syntax at IO time
02:19:40 <bhauth> That's why logic programming should be a feature, not a base. You can build up, but not down.
02:19:42 <therp> bit syntax would be totally trivial with Liskell, I guess
02:19:43 <quicksilver> audreyt: isn't that effectively good enough?
02:20:21 <therp> the question is what's the underlying data structure as haskell doesn't know Byte.. and so on..
02:20:48 <therp> but I guess we could just use malloced memory with FFI
02:20:58 <audreyt> quicksilver: not sure what you mean... erlang bitstructs are also immutable
02:21:05 <audreyt> so it should function outside IO
02:21:24 <quicksilver> audreyt: what I mean is, why should I *care* how the runtime stores it?
02:21:38 <quicksilver> audreyt: the runtime might elide the value completely because it's a compile-time constant
02:21:44 <apfelmus> audreyt: well, monads can give you patterns and constructors but i'm unsure whether you need two monads (one parsing, one printing) for that.
02:21:53 <quicksilver> surely all I care about is that I have control when it's written to disk/socket
02:21:54 <audreyt> quicksilver: oh because there's an entire class of programs that processes binary formatted files and in-memory structs
02:22:12 <audreyt> and if your in-memory notation uses 2 bytes for each bit in the file
02:22:17 <audreyt> it very quickly becomes unwieldy
02:22:19 <audreyt> <- been there
02:22:34 <quicksilver> not with laziness, it doesn't
02:22:45 <audreyt> laziness is the source of that extra byte...
02:22:45 <quicksilver> it only uses 2 bytes during the algorithm, not 'long term'
02:22:48 <audreyt> or rather, "word"
02:22:58 <audreyt> since a thunk is one level of indirection
02:23:28 <audreyt> the ability to manipulate in-memory strict bitfields is really useful to me
02:23:46 <audreyt> and haskell doesn't very easily do that without FFI
02:23:55 <apfelmus> i guess that you don't want to parse bits but to use bit fields as data structure?
02:24:05 <bhauth> And what if you want to do cryptography.  :|
02:24:09 <apfelmus> i mean, parsing is best left to monads
02:24:22 <audreyt> well with strict bitfield
02:24:24 <audreyt> there's no parsing
02:24:24 <therp> let me repeat myself: Liskell can define this syntax sugar very easily. memo to myself: write a blog entry about that
02:24:26 <quicksilver> audreyt: *nod* but Data.Binary gives you most of that
02:24:27 <audreyt> there is just mmap :)
02:24:37 <audreyt> quicksilver: Data.Binary has its own encoding
02:24:48 <audreyt> (and yes I heavily adapted Data.Binary for my use in OpenAFP)
02:24:56 <audreyt> but it's not a general solution...
02:25:10 <audreyt> therp: url to blog?
02:25:10 <quicksilver> however it is, IMO, the 'shape' of a general solution
02:25:23 <therp> audreyt: http://clemens.endorphin.org/weblog/
02:25:26 <lambdabot> Title: clemens.endorphin.org/weblog - clemens.endorphin.org
02:25:35 <therp> I should change my weblog's title..
02:25:36 <audreyt> quicksilver: aye, in OpenAFP I used TH to abstract over it
02:25:48 <earthy> 'parsing is best left to monads' WTF?!
02:25:48 <audreyt> which captures the "shape"
02:25:52 <therp> audreyt: so you want syntax sugar for in-memory manipulation of bits?
02:25:55 <earthy> no it isn't!
02:25:56 <quicksilver> to me it feels like an abstraction break to have your actual programming language annotating fields with bit lengths
02:26:04 <earthy> combinators, yes, monads?! no!
02:26:10 <audreyt> quicksilver: well Word8 and Word16 are _also_ annotations
02:26:17 <audreyt> quicksilver: all this gets us is the ability to defined Word3 and Word4.
02:26:29 <quicksilver> audreyt: no, you're asking for more than that
02:26:41 <audreyt> hm? GHC packs strict unboxed Word8 fields etc
02:26:42 <quicksilver> audreyt: you're asking not only for word3 and word4, but some guarantee of how the runtime stores the values
02:26:51 <audreyt> it already promises that
02:26:54 <audreyt> if the fields are byte-aligned
02:27:06 <apfelmus> earthy: ok, ok. combinators that are not monads may be faster than those that are. i should have said "combinators" :)
02:27:17 <kolmodin> Data.Binary doesn't do bit matching yet
02:27:29 <audreyt> therp: I defined those sugar myself with TH...
02:27:37 <audreyt> therp: but Liskell is very interesting
02:28:18 <audreyt> therp: so Liskell is like TH but untyped?
02:28:28 <quicksilver> earthy: the combinators are monads, whether you like to call them that or not
02:29:10 <quicksilver> s/monads/monadic/ probably. Although I'm not being very precise anyway.
02:29:11 <audreyt> therp: and the obvious question -- do you have runtime eval facility like TH+libGHC does? :)
02:29:11 <kolmodin> what's OpenAFP?
02:29:31 <audreyt> kolmodin: it's a toolchain for the IBM AFP format, which is like .pdf but binary
02:29:40 <kolmodin> ah, cool
02:29:40 <audreyt> source: http://svn.openfoundry.org/openafp/
02:29:41 <lambdabot> Title: Revision 31: /
02:30:02 <apfelmus> quicksilver: there are parser combinators that are not monads
02:30:12 <kolmodin> audreyt: yeah, fond that site, but it doesn't contain what it does, only how :)
02:30:24 <kolmodin> contain/say
02:30:27 <quicksilver> apfelmus: the type [token] -> ([token],result) is a monadic functor
02:30:40 <quicksilver> apfelmus: are there parse combinators that don't work over a type like that?
02:30:51 <apfelmus> quicksilver: yes, that's what i mean
02:31:00 <quicksilver> audreyt: I understand your point but I don't think that's an argument for a new language feature
02:31:07 <apfelmus> @google Duponcheel Swierstra Deterministic parser
02:31:09 <lambdabot> http://www.cs.uu.nl/docs/vakken/afp/Literature/LL1.pdf
02:31:28 <quicksilver> audreyt: I'd rather have somethiing 'like' Data.Binary which lazily inflates to haskell data on demand
02:32:32 <therp> audreyt: yes Liskell is pretty much untyped. It's typed of course as it Haskell underneath, but it has a very simple parse tree (two constructors)
02:32:56 <earthy> and if you want to play with those parser combinators: http://www.cs.uu.nl/wiki/HUT/
02:32:57 <lambdabot> Title: HUT: Haskell Utrecht Tools
02:33:30 <therp> audreyt: eval facility is coming. I'm working on it. I did a Liskell repl inside ghci last week, but I'm busy with work-for-food
02:34:26 <kolmodin> quicksilver: Data.Binary does that
02:36:02 <quicksilver> kolmodin: Data.Binary doesn't let you specify the exact bit-level format of the data to read, I believe
02:36:09 <therp> audreyt: but ATM Liskell lacks top-level specials for FFI definitions. But those should be trivial to complete.
02:36:55 <kolmodin> quicksilver: no, but it does lazy reading. perhaps I just misunderstood you
02:37:00 <bhauth> Do you think liskell works better than hasp would?
02:37:31 <quicksilver> kolmodin: yes, I know it does lazy reading :) That was my point, too.
02:37:51 <therp> bhauth: I haven't seen an embedded version of Prolog done with Hasp.
02:37:51 <quicksilver> kolmodin: I'm suggesting somethign which does lazy reading, like Data.Binary, is the right answer to audreyt's requirement
02:38:05 <kolmodin> quicksilver: right. sorry
02:38:31 <bhauth> therp: that means nothing, the communities are totally different
02:39:05 <audreyt> therp: so how does Liskell use Parsec?
02:39:18 <therp> audreyt: not at all.
02:39:19 <audreyt> (or, more generally, how does it embed code in other monads)
02:39:23 <audreyt> oy.
02:39:36 <audreyt> that means no library code for me?
02:39:42 <audreyt> or rather, only IO
02:39:42 <therp> audreyt: or was the question how would you use parsec with Liskell?
02:39:46 <audreyt> with
02:40:01 <audreyt> say I want to say
02:40:06 <therp> audreyt: just use the binding operator. >>. you don't need do syntax sugar for that.
02:40:07 <audreyt> string "foo" <> string "bar"
02:40:08 <audreyt> er
02:40:14 <audreyt> string "foo" <|> string "bar"
02:40:33 <audreyt> (<|> (string "foo") (string "bar"))
02:40:33 <audreyt> ?
02:40:48 <quicksilver> apfelmus: good paper, thanks
02:40:55 <quicksilver> apfelmus: still monads underneath it all, I believe, though
02:41:16 <apfelmus> not in this paper :)
02:41:24 <earthy> quicksilver: most definitely not
02:41:32 <therp> bhauth: the point is that you can do it. Not that you want someone from the prolog community.
02:41:45 <therp> audreyt: yes. I think so. If that is supposed to be an infix operator
02:41:55 <therp> audreyt: Liskell is strictly prefix notation. as Lisp
02:42:00 <earthy> quicksilver: monads would kill most of the performance of the UU parser combinators
02:42:24 <audreyt> therp: gotcha. I guess I still like TH for its typechecked splicing/quasiquoting
02:42:45 <audreyt> therp: but for producing haskell-compatible AST from programs, Liskell seems like a competitive alternative
02:43:05 <audreyt> if only because its defmacro is easier
02:43:12 <quicksilver> earthy: you're talking about implementation decisions
02:43:19 <quicksilver> earthy: I'm talking about categorical constructions
02:43:33 <therp> audreyt: typechecking gives you almost no gain for meta programming, as typing (as in Haskell) does not guarantee anything with TH syntax trees. It still can fail to compile because of free vars or other oddities
02:43:34 <quicksilver> erider: these two points are orthogonal, aren't they?
02:43:52 <quicksilver> earthy: that was for you, too :)
02:44:04 <therp> audreyt: btw. quasiquotation is also available with Liskell (and I think it's more nice as it comes from Lisp backquoting operator)
02:44:25 <therp> and Lisp backquoting is superior to almost anything I have seen in this area.
02:44:28 <earthy> no, because the categorical construction cannot be made.
02:44:49 <apfelmus> quicksilver: well, the categorical constructions are implementation decisions
02:45:06 <audreyt> therp: free vars is only a problem is you use late-bound vars in TH which is not default
02:45:31 <audreyt> therp: re lisp backquoting, that assumes you _start_ writing macro bodies this way. for me to abstract over existing Haskell code, TH is more convenient
02:45:38 <audreyt> unless there is a Haskell->Liskell decompiler
02:45:40 <audreyt> is there such a thing?
02:45:50 <therp> audreyt: the syntax tree you are constructing with TH does not guarentee error free compilation. the same is true for liskell. I don't see the gain.
02:46:08 <therp> audreyt: I plan to write one yes
02:46:18 <audreyt> ok, given that then the convenience factor is on par
02:46:23 <audreyt> therp: most interesting work :))
02:46:29 <quicksilver> apfelmus: OK, well let me go away and read the paper properly before I continue this discussion :)
02:46:34 <apfelmus> :)
02:46:52 <therp> audreyt: the problem is that I actually planed to do something else, not inventing a programming language :)
02:47:08 <dons> is it possible to build a grammaticaly incorrect structure in liskelll, though, therp?
02:47:11 <therp> I wanted to do PhD work in the area of genetic programming..
02:47:19 <dons> (since I think that's not possible hacking directly on the HsSyn type)
02:47:25 <dons> in TH
02:47:44 <dons> i.e. is liskell working before or after the parser?
02:48:29 <therp> dons: yes that's possible, but to defend that shortcoming: it's much more easier and the protection you gain from a complex syntax tree as TH is not very much as both the syntax and the parse tree are not guaranteed to compile
02:48:59 <therp> dons: http://clemens.endorphin.org/ILC07-Liskell-draft.pdf page 3 gives a picture how Liskell works and where parsing happens
02:49:10 <dons> ah right. yes.
02:49:30 <dons> i can certainly see an advantage in src evel macros, versus HsSyn macros
02:49:34 <therp> dons: but yes, you might catch errors later in Liskell as you don't get the protection of typing as in TH. so that's clearly a disadvantage
02:49:36 <dons> src level
02:50:24 <therp> you are free to introduce totally new syntax forms.. again I have to point to embedded Prolog which could not be captured by anything in HsSyn
02:50:48 <therp> at least very not naturally.
02:50:54 <therp> at least not very naturally.
02:52:26 <dons> yep
02:59:52 <roconnor> > exp(0.0525)
02:59:53 <lambdabot>  1.0539025620785374
03:29:47 <JaffaCake> dons: I fixed the -fasm slowdown for nsieve
03:32:01 <lemmih> JaffaCake: Didn't ghc support parallel --make builds at some time?
03:32:01 <lambdabot> lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
03:32:11 <dons> JaffaCake: great!
03:32:13 <dons> JaffaCake++
03:32:15 <dons> what was it?
03:32:22 <dons> lemmih: it does
03:32:31 <dons> oh, sorry.
03:32:43 <dons> yes, that's mentioned in the smp paper, but not in ghc now, afaik
03:32:53 <JaffaCake> dons: a couple of places we weren't generating the best code in the native code gen
03:33:06 <lemmih> Whoa, <lambdabot> ADEpt said 7m 16d 21h 56m 37s ago:
03:33:19 <dons> i'll run with the new patches in the morning, then, JaffaCake
03:33:28 <JaffaCake> great
03:33:46 <JaffaCake> lemmih: I have a patch for it, but it's not really ready for general use
03:34:09 <dons> JaffaCake: killer app for this: jhc. it builds --make and has 200 modules or so that take quite a while
03:34:18 <dons> having 15 cores idle makes me feel bad ;)
03:34:41 <JaffaCake> you'd still spend 30% or more time doing GC on a single core, unfortunately
03:34:42 <dons> (maybe jhc should use ghc -M + make -j16)
03:35:17 <JaffaCake> I did some work on parallel GC recently, but didn't manage to get it parallelising very well
03:35:33 <JaffaCake> might be a memory bandwidth issue, I'm not sure
03:35:36 <dons> ah ok. i saw you were working on that
03:35:43 <JaffaCake> I'll get back to it hopefully at some point
03:37:39 * JaffaCake looks at sumcol next
03:38:00 <kuribas> I want to write a simple music typesetting program in Haskell.  What would the best way be to add properties to notes?  Give the Note type a list of NoteProperty values?
03:38:54 <dons> kuribas: have you seen haskore?
03:39:15 <dons> yeah, you could parameterise your Note type with a annotation type
03:39:27 <dons> data Note a = Note Int a -- for example
03:39:34 <JaffaCake> dons: where do I get sumcol.input?
03:39:36 <dons> then AnnotatedNote = Note String
03:39:42 <dons> JaffaCake: 'make boot'
03:39:45 <JaffaCake> ah
03:39:50 <dons> will create the file imaginary/sumcol/sumcol.input
03:39:57 <dons> a 100M file , be warned ..
03:40:06 <dons> (had to be that big to get any decent runtime ;)
03:41:18 <kuribas> dons: And when a note can have many properties?
03:41:29 <dons> Note [String] ?
03:41:33 <dons> Note [Property] ?
03:42:13 <kuribas> I was thinking along the lines of "data Note = Note Duration Pitch [NoteProperty]"
03:42:23 <dons> yep, that looks reasonable.
03:42:57 <kuribas> I am not sure how I would extract properties from the note then.  In scheme I would use ASSOC.
03:43:13 <TSC> @type lookup
03:43:16 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
03:43:33 <dcoutts_> JaffaCake, I saw you deleted loads of code for vectored returns, was that satisfying? :-)
03:43:38 <ADEpt> lemmih: better late then never, right? :)
03:43:46 <JaffaCake> dcoutts_: oh yes
03:44:09 <kuribas> dons: And if the properties could have different types, would you make a union type for them?
03:44:47 <dons> yeah
03:44:47 <dons>         
03:44:53 <quicksilver> almost certainly, yes
03:45:36 <dcoutts_> JaffaCake, did you note the message from the chap who was trying to investigate the feasibility of ghc/stg on the cray MTA-like boxes? I would expect that for that to be practical they'd need to work on a native code gen and parallel gc (if not also concurrent) since they've got 128 threads per cpu.
03:46:21 <JaffaCake> certainly a NCG, they don't have gcc right?
03:46:31 <dcoutts_> they've only got Cray cc
03:46:39 <JaffaCake> so the manger is out
03:46:41 <dcoutts_> right
03:46:52 <JaffaCake> yes, parallel GC seems a must too
03:47:17 <dcoutts_> it's an interesting arch for stg since memory latency becomes much less of a problem
03:47:30 <dcoutts_> since that thread just blocks til it's ready
03:47:45 <JaffaCake> yes, that's really what you want for GC
03:47:46 <dcoutts_> so long as you have enough threads available you can saturate the cpu functional units
03:48:00 <JaffaCake> no worrying about prefetching
03:48:15 <dcoutts_> I was also thinking of the latency you get due to taking lots of indirect jumps, which you get a lot of in stg
03:48:38 <JaffaCake> ah well, you see we've got some changes in the pipeline that help there...
03:48:51 <earthy> hm. I like how this program allows me to go have lunch and then find a new profile when I come back
03:48:56 <earthy> and not that much sooner
03:48:57 <dcoutts_> JaffaCake, semi-tagging? or more than that?
03:49:04 <JaffaCake> yeah, semi-tagging and pointer-tagging
03:49:12 <JaffaCake> writing a paper on it at the mo
03:49:17 <dcoutts_> great
03:49:56 <JaffaCake> we got 8-10% just for semi-tagging, a 100-line patch to GHC :)
03:50:04 <dcoutts_> yay
03:50:13 <JaffaCake> another 4-6% or thereabouts for pointer tagging
03:50:30 <JaffaCake> not clear whether we're going to incorporate pointer tagging yet
03:50:34 <earthy> that's Alexey's stuff?
03:50:36 <JaffaCake> yep
03:50:44 <dcoutts_> JaffaCake, I was thinking today how it'd be nice and useful to do a paper on the real cpu/time/memory cost of the various stg primitives so we can be more accurate/authoritative when talking about how much improvement we get due to various low level transformations
03:50:48 <earthy> cool stuff, that. :)
03:51:00 <earthy> very helpful to have him around when trying to optimize code :)
03:51:15 <JaffaCake> indeed
03:51:19 <dons> JaffaCake: is the semi tagging in the head?
03:51:21 <dcoutts_> eg comparing the stg level implementations of things implemented in a direct recursive 'goto' style vs higher order folds etc
03:51:24 <JaffaCake> dons: not yet
03:51:47 <JaffaCake> dcoutts_: I'm not sure you can quantify the cost of primitives out of context... a lot depends on cache and branch prediction
03:52:12 <SamB> dons: playing mind games are we?
03:52:28 <dcoutts_> JaffaCake, sure, buy you could treat cached vs uncached separately
03:52:41 <dcoutts_> JaffaCake, eg I've got a couple versions of things like concat/unwords/unlines etc. There are dramatic performance differences from different styles. It'd be interesting to characterise that accurately at the stg level, how many fewer costly Foo ops etc.
03:53:03 <siti> dcoutts_: http://hpaste.org/723#a1 just pointing out a bug, I know how to fix it I think though
03:53:24 <SamB> does not a lot depend also on code generation?
03:53:29 <earthy> okay, profiler question. what does the profiler count when calling out through the FFI?
03:53:32 <JaffaCake> maybe... I'm mildly skeptical about trying to decompose performance like that, because in my experience there tend to be lots of dependencies
03:53:57 <dcoutts_> JaffaCake, hmm, right.
03:54:25 <dcoutts_> siti, yep there are a few subtle resource bugs there. It needs a bit of a rethink.
03:54:38 <siti> yep
03:54:58 <JaffaCake> earthy: the timer samples should still work when in foreign code
03:55:22 <earthy> okay. then I think I don't understand this profile. :)
03:55:36 <dons> can someone write a '@fibs-sec' plugin for lambdabot
03:55:43 <siti> all the pointers really need to use the _reference and _destroy functions and ForiegnPtr's
03:55:47 <dons> its important to know how many fibs/sec our compilers can do :)
03:56:16 <SamB> why do we need to know how many lies/sec our compilers can do?
03:57:29 <dons> in the old days, SamB, haskell compiler performance was in terms of fibs/sec , if you look back at the 1990/91 posts
03:57:35 <hpaste>  Earthy pasted "Weird profile" at http://hpaste.org/728
03:57:50 <SamB> I don't see how lies/sec is a usefull speed metric
03:58:03 <dons> fibonacci
03:58:41 * JaffaCake notes that nofib was a great name for a benchmark suite
03:58:50 <dons> yeah
04:00:37 <dcoutts_> SamB, lies/sec? is that some kind of measure of a politician?
04:01:38 <earthy> 'individual %time
04:01:38 <earthy> The percentage of the total run time of the program spent at this point in the call graph.
04:01:41 <earthy> '
04:01:43 <Thunder> dco: only if measured logarithmically.
04:01:46 <earthy> how should I read this?
04:03:25 <earthy> The call graph gets generated, and is populated with all functions that are not in the standard libraries
04:03:25 <earthy> so calls to functions in the standard libraries are counted to the calling cost center?
04:03:27 <earthy> or what?
04:04:05 * earthy thought he had an intuition of how to read profiles
04:04:12 <earthy> now I'm not so sure anymore
04:06:59 <earthy> 'Time spent in foreign code (see Chapter 8, Foreign function interface (FFI) ) is always attributed to the cost centre in force at the Haskell call-site of the foreign function'
04:07:50 <kuribas`> dons: Do you know of a project that is written this way (with annotations) and that I could examine?
04:08:16 <earthy> okay. so... that would mean that if I add SCC annotations around every call through the FFI I'd get a good representation of the time spent on the other side
04:09:06 <dons> kuribas`: the data types in ghc are often paramaterised by annotation types, see here, http://darcs.haskell.org/ghc/compiler/cmm/Cmm.hs
04:10:22 <kuribas`> dons: ok, thanks.
04:11:07 <mux> dons: hey, have you seen my mail about adding an @op admin command to LB?
04:12:11 <dons> yep. gotta apply it, and maybe think about it.
04:12:14 <dons> haven't had time yet
04:13:05 <mux> cool, thanks
04:13:27 <mux> I guess it would make sense to disable it by default, given what usage you want to make out of LB
04:13:36 <mux> it was quite useful to me for another channel on another server
04:14:11 <dons> ok
04:16:19 <earthy> ohkay. fuck it. I'm just going to add cost centre's to evry frigging expression in this function
04:16:25 <earthy> that'll show me where the time's going.
04:24:25 <chessguy> if you have data Foo = Foo { foo :: Bar } and f :: Foo, i know you can update it with f { foo = bar}, but what's the sugar-free way to do the update?
04:27:10 <apfelmus> de- and reconstruct. let Foo x = f in Foo (fizzbuzz x)
04:28:01 <chessguy> fizzbuzz?
04:28:04 <apfelmus> is equivalent to f { foo = fizzbuzz (bar f)}
04:28:33 <apfelmus> fizzbuzz is just an arbitrary name like foo or bar :)
04:28:34 <chessguy> bar is a value, not a function
04:28:50 <apfelmus> err, f { foo = fizzbuzz (foo f) }
04:28:51 <dons> malcolmw: good sign. sum-col seems to run :-)
04:29:04 <dons> malcolmw: hasn't finished yet, but it does run
04:30:54 <chessguy> i don't understand why you introduced something new
04:31:30 <quicksilver> let Foo a b c x f g h = f in Foo a b c bar f g h
04:31:36 <quicksilver> chessguy: is the simplest case
04:31:51 <apfelmus> i thought bar would depend on x somehow
04:31:51 <dons> malcolmw: and Sven's patch fixes a build error I just had on amd64 :)
04:32:06 <chessguy> ahh, ok
04:32:10 <chessguy> now i'm with you
04:32:34 <mux> chessguy: your nicknames makes me think of something
04:32:40 <mux> http://mu.org/~mux/glchess.png
04:32:57 <mux> this stupid chess game allowed a totally illegal castling move
04:33:09 <mux> (the blue squares are those where you can move the king)
04:33:26 <mux> talk about crappiness.
04:33:47 <int-e> mux: e8 to c8?
04:33:55 <mux> int-e: yes
04:34:07 <mux> and the funny bit is that this results in a checkmate after two moves
04:34:19 <mux> Ba6+ Qb7 Qxb7#
04:34:19 <chessguy> lots of engines have gametree-traversal bugs
04:36:33 <mux> any people using FICS in here?
04:49:56 * kuribas` used to play on FICS.
04:55:41 <norpan> i haven't played chess in a long time
04:55:51 <norpan> i hardly remember how the pieces move...
04:56:35 <norpan> actually, that's a lie; i'
04:56:48 <norpan> i'm a chess arbiter in my spare time
04:57:27 <mux> match norpa^H^H^H^H^H^H
04:57:32 <mux> hehe
05:07:42 <mightybyte> mux: I play on FICS
05:09:04 <dons> ?users
05:09:05 <lambdabot> Maximum users seen in #haskell: 332, currently: 301 (90.7%), active: 30 (10.0%)
05:10:10 <earthy> hm. drat. this code is just plain *slow* and I can't seem to do anything about it in Haskell land
05:11:00 <lemmih> earthy: Have you tried applying the #haskell optimization phase?
05:11:03 <JaffaCake> dons: I made a couple more tweaks to the NCG that will help with sumcol
05:11:25 <JaffaCake> it's not quite as good as via-C, because we need somre more heavy-duty optimisations
05:11:30 <earthy> lemmih: the code in question is:
05:11:30 <earthy>             ; {-# SCC "exportEvidenceListNetworkUpdate" #-} networkUpdateBeliefs networkPtr
05:11:33 <earthy>             ; -- look up posteriors
05:11:41 <earthy> The profile gives me:
05:11:52 <earthy> exportEvidenceListNetworkUpdate SmileExport           49.2    0.2
05:12:04 <earthy> (yea, that's 49.2 of the runtime of my program)
05:12:10 <earthy> %
05:12:24 <apfelmus> earthy: i don't know but maybe the == 0.0 fails unexpectedly
05:13:13 <earthy> oh, and foreign import ccall "DSL_network_UpdateBeliefs"    networkUpdateBeliefs     :: NetworkObject a -> IO Int
05:13:15 <dons> JaffaCake: got some numbers for rfib you might want to check too, on x86, http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
05:13:16 <lambdabot> Title: nobench: Haskell implementation shootout
05:13:17 <apfelmus> the rule of thumb is not to compare floating point numbers without an expsilon
05:13:25 <apfelmus> *epsilon
05:13:49 * JaffaCake knows that rfib sucks with -fasm
05:13:51 <earthy> apfelmus: I know. this bit does not scare me, as the 0.0 *really* is 0.0
05:14:03 <JaffaCake> on x86, that is
05:14:07 <earthy> it's the defined output of my external lib
05:14:26 <dons> JaffaCake: does fine on amd64 though, 3.79 (1.0)
05:14:27 <dons> 	4.06 (1.1)	4.14 (1.1
05:14:45 <JaffaCake> I don't plan to improve the i87 code generator, but we could generate SSE2 floating point on x86
05:15:03 <dons> yeah. its a closer match if I don't ask gcc for sse2
05:15:07 <JaffaCake> that's just a matter of refactoring, because x86_64 already uses SSE2
05:15:20 <apfelmus> ok. if the 0.0 doesn't arise by addition or subtraction, you should be fine
05:15:38 <earthy> no, it arises by exceptional checking in the external lib
05:15:45 <earthy> basically as a flag
05:15:50 <earthy> (yeah, that sucks :))
05:15:56 <earthy> but I didn't write the lib
05:15:57 <JaffaCake> SSE2 is better IMO, because you get exact-sized operations, not funky 80-bit precision
05:16:08 <earthy> plus, conceptually, it does exactly what it's supposed to do
05:16:30 <ClaudiusMaximus> > 2^32
05:16:31 <lambdabot>  4294967296
05:18:10 <apfelmus> ?type (!!)
05:18:12 <lambdabot> forall a. [a] -> Int -> a
05:19:25 <chessguy> norpan, who are you an arbiter for?
05:20:06 <norpan> chessguy: various tournaments
05:20:16 <chessguy> what federation though
05:20:25 <norpan> also a proud member of the swedish rules and arbiter's committee
05:20:27 <norpan> sweden
05:20:33 <chessguy> oh, national
05:20:38 <norpan> yeah
05:20:41 <chessguy> nice.
05:20:45 <chessguy> you guys rock
05:20:59 <apfelmus> earthy: mh, can't you make the code more pure? the IO makes me feel sick. ForeignPtr comes to mind
05:21:16 <norpan> i was an arbiter during the eruopean team championships two years ago, that was fun
05:21:21 <earthy> apfelmus: nope. I'm bound by the external lib.
05:21:29 <chessguy> i bet you had fun watching kramnik-topalove last year
05:21:35 <norpan> hehe
05:21:44 <earthy> that is, making it more pure would mean reimplementing that libs functionality
05:21:55 <norpan> chessguy: it was ... interesting
05:22:18 <apfelmus> earthy: not necessarily. i mean, it's like ByteString
05:22:38 <chessguy> it was ridiculous
05:23:23 * mux has followed the poland chess tournament that was relayed on FICS, but can't pretend to have understood the moves the GMs are doing
05:23:27 <earthy> ah, no it isn't. :)
05:23:28 <dcoutts_> apfelmus, ByteString doesn't wrap very much existing impure C/IO stuff actually.
05:23:44 <dons> like 10 lines of code in C
05:23:51 <earthy> the call to networkUpdate is really fundamental, and it's really calculating some interesting data
05:23:55 <dons> maybe we should remove that stuff, eh, dcoutts_ ?
05:24:01 <dons> and complain to JaffaCake if it runs slower
05:24:12 <dcoutts_> dons, good idea :-)
05:24:18 <earthy> so, no, I think this is as fast as I can get this
05:24:29 <earthy> (still, down to 1000 s from 5000 s... not to be sneezed at)
05:24:37 <dons> you checked the core, earthy ?
05:24:38 <dcoutts_> dons, so there's the 4 C functions we coded, and then a few glibc ones.
05:24:41 <apfelmus> well, wrapping something a -> IO a into pure stuff would require copying, indeed.
05:24:43 <dons> lots of nice Addr#'s :-)
05:24:56 <earthy> what core? Data.Bytestring's core? :)
05:24:56 <dons> dcoutts_: right. i'd say ours could go, some C stuff too.
05:25:00 <Igloo> I wouldn't bother rewriting the standard C ones in Haskell
05:25:12 <dcoutts_> dons, I was looking at KMP matching yesterday for [Char], I see we have that already for ByteString, I'd never noticed :-)
05:25:24 <dcoutts_> Igloo, no, nor would I.
05:25:29 <Igloo> Some of them are scarily optimised, and it doesn't really buy anything
05:25:33 <dons> just the cbits
05:25:36 <mux> dcoutts_: do we have BM too?
05:25:42 <Igloo> Yeah, removing cbits would definitely be nice
05:25:48 <dons> since they're probably not even needed now, in ghc head
05:26:06 <dcoutts_> mux, nope, bout you could do for ByteString, I think for String you would prefer something that only looks at each char once.
05:26:09 <dons> sounds like a job for ... when dcoutts is here!
05:26:15 <ivanm> does the listings package in latex support literate (bird-style) haskell?
05:26:26 <malcolmw> dons: ya-ouch.  sumcol is 1000x slower in nhc98 than ghc
05:26:39 <dons> malcolmw: interesting, no? no optimised ForeignPtr in nhc
05:26:46 <dons> malcolmw: see the reverse-complement failure?
05:26:52 <mux> dcoutts_: that makes me think, I know an *awesome* website listing exact string matching algorithms: http://www-igm.univ-mlv.fr/~lecroq/string/
05:26:54 <lambdabot> Title: ESMAJ
05:26:57 <mux> but maybe you know it already :)
05:27:10 <dons> Error: allocation limit (1024) exceeded for Foreign(Obj/Ptr)
05:27:13 <dcoutts_> mux, I didn't. Thanks.
05:27:30 <mux> it's really great, with explanations, sample C code, etc
05:27:34 <dons> malcolmw: but I've now added 'nhc98' to the supported status on fps' homepage
05:27:56 <malcolmw> dons: can I go back to having sumcol broken? :-) it would improve the geometric mean...
05:28:50 <dons> hehe.
05:28:59 <dons> maybe we should weight supportedness into the final number
05:29:10 <dons> so your mean * the number you support ;)
05:29:46 <dons> but don't worry, ghci sucks on sumcol too
05:29:56 <dons> its scarily optimised by ghc
05:30:02 <dons> (to beat C by a good margin)
05:30:50 <dons> here, you can see that lovely code in action: http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
05:30:52 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
05:31:07 <dons> though lennart's pointed out that the asm gcc produces could actually be improved a bit
05:31:48 <dons> dcoutts_: oh, heh, i see the gcc guys have up on naive sumcol and stil can't catch us, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=gcc&id=2
05:31:50 <lambdabot> Title: sum-file C gcc #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer L ..., http://tinyurl.com/2d2rn5
05:32:00 <malcolmw> I wonder if a naive solution to sumcol might work out faster for all the bytecode interpreters
05:32:46 <dons> dcoutts_: i'm so happy, look at C gcc and C gcc #2. they really did rewrite it to match the haskell version!
05:33:06 <dcoutts_> dons, heh heh
05:33:19 <dons> and its still 3x slower
05:34:25 <dcoutts_> dons, I wonder why the C impl is so slow there, perhaps it's because they really are limited to doing line buffered IO, where as we kind of cheat ;-)
05:34:40 <dons> yeah, though i've been assured that blocksize chunks are ok
05:34:44 <dcoutts_> we slurp in 64k chunks and then break that into lines
05:34:50 <dcoutts_> ok, fine then
05:34:53 <dons> yep.
05:34:57 <ivanm> Again: does the listings package in latex support literate (bird-style) haskell?
05:35:01 <dons> they just care about constant space overhead
05:35:15 <dons> so the (even faster) strict bytestring versoin was illegal
05:35:44 <dcoutts_> sure sure
05:35:57 <araujo> morning!
05:36:01 <JohnMeacham> burp.
05:36:10 <dcoutts_> you're excused
05:37:10 <dons> malcolmw: hmm. i'm having trouble getting nhc to build on the amd64. i'm not sure how I managed it the first time. have you been able to build on one?
05:37:31 <malcolmw> dons: I don't think I have one to build on
05:37:38 <dons> my builds either seem to result in segfaulting nhc binaries, or in funny missing dependency errors
05:37:45 <earthy> lovely. maybe I should go test this with a smaller dataset.
05:38:07 <earthy> or I can spend more time on generally useful hacking on tags and haskell modes and other fun stuff.
05:38:23 <malcolmw> dons: hold on, I build on a 2x AMD64 box every night
05:38:44 <dons> oh "I don't think I have one to build on" --> "I build on a 2x AMD64 box every night" ?? :)
05:38:49 <malcolmw> but I think it is only running a 32-bit linux, so it worked fully before I added -m32
05:39:26 <dons> ah ok.
05:39:36 <malcolmw> AMD Athlon(tm) 64 X2 Dual Core Processor 4400+
05:40:07 <JohnMeacham> they have that new fully open source BIOS motherboard from GIGABYTE. power to linux prompt in 3 seconds.
05:40:32 <dons> yeah, that's pretty cool
05:41:22 * malcolmw has finally managed to resurrect a nightly sparc build of nhc98 after a break of a year
05:42:07 <dons> cool
05:44:01 <malcolmw> dons: wow, sumcol figures are surprising on my powerpc.  ghc-6.6 = 0.94 (1.0 x) , ghc-6.4.1 = 43.54 (46.3 x) , nhc98 = 776.11 (825.6 x)
05:44:24 <malcolmw> so nhc98 is only 40x worse than ghc-6.4.1
05:44:44 <dons> huh. looks like we really did improve ghc and the ForeignPtr rep in 6.6
05:45:18 <dcoutts_> the ForeignPtr rep change was crucial I think
05:45:30 <dcoutts_> by allowing the Addr# to be unpacked
05:45:43 <dons> those numbers are really weird on powerpc though, malcolmw . ghc-old shouldn't be that bad
05:45:51 <dcoutts_> and made a direct parameter to recursive functions
05:45:57 <dons> oh, maybe . actually
05:46:11 <dons> the head is faster still
05:48:07 <pejo> malcolm, 40x40 = 1600, not 800. :-)
05:48:38 * malcolmw blushes
05:49:35 <malcolmw> re-running sumcol as print . sum . map read . lines =<< getContents
05:50:58 <dons> ah right. that's the slow shootout example, its some 400x slower on the shootout box
05:51:09 * dcoutts_ resists the urge to fuse the pipeline
05:51:14 <dons> don't do it!
05:51:35 <dcoutts_> but but! sum . map f . lines .... aargh!
05:51:36 <dons> maybe we could just add a patch to ghc that turns that code into sumcol bytestring code
05:51:40 <quicksilver> the internet is faster now. dcoutts_ fused the tubes.
05:51:40 <dons> just for the shootout example ;)
05:51:46 <dcoutts_> dons, that's my plan... :-)
05:51:58 <dons> yeah, silly foldl
05:52:24 <dcoutts_> dons, I've got a new Data.List lib btw, I'll send patches soon
05:52:34 <dons> ah good.
05:52:41 <dcoutts_> next is quick check and optimising and stream-fusible versions
05:52:57 <dcoutts_> some things are quicker already though
05:53:13 <Igloo> malcolmw: Is that a registerised powerpc 6.4.1?
05:53:33 <dcoutts_> there is a good deal to be got just by rewriting some of the ordinary [] functions
05:54:19 <malcolmw> Igloo: how can I tell?
05:54:26 <mattam> A little english question: would you say 'a less well-known approach' or 'a lesser known approach' ?
05:54:48 <dcoutts_> mattam, probably the first, but the second is ok too
05:55:39 <edwinb> I think I prefer the second...
05:55:50 * edwardk waves hello.
05:56:03 * malcolmw has just seen Sven's patch.  Makes sense (especially since I only added the $(ARCH) to compiling that file yesterday)
05:56:08 <mattam> i think i prefer it too
05:56:33 <mattam> but can't find anything on the net that says it is correct :)
05:56:47 <dons> malcolmw: yeah, i'm trying again with that patch
05:56:54 <edwinb> This is the net, and we say it's correct ;)
05:57:04 <edwinb> maybe this doesn't count
05:57:11 <dons> dcoutts_: so we'll need a way to benchmark against old Data.List
05:57:12 <Igloo> malcolmw: See if it's calling the mangler when you compile with -O -v
05:57:18 <dcoutts_> dons, yep.
05:57:20 <malcolmw> dons: you will probably need to clean and rebuild all the prelude and libraries
05:57:22 <dons> and check al the properties, if people are going to trust this stuff
05:57:24 <Igloo> malcolmw: If it's registerised it'll run ghc-asm
05:57:30 <dcoutts_> dons, indeed.
05:57:32 <dons> malcolmw: right. make realclean ; ...
05:57:55 <dcoutts_> dons, in a couple places I've also found strictness differences, eg my unwords impl is naturally *more* lazy than the spec.
05:58:12 <dons> dcoutts_: numbers + quickcheck should be good, I think. and replace things a few functions at a time.
05:58:23 <earthy> mattam: Practical English Usage by Michael Swan suggests to not use lesser unless you're trying to be formal
05:58:43 <earthy> otoh: it does contain the example 'a lesser-known writer'
05:58:58 <earthy> so go for it. :)
05:59:08 <dons> dcoutts_: oh, i have an email here from someone asking for erlang-style bit pattern matching for Data.Binary
05:59:17 <dcoutts_> dons, replacing a few at a time? Surely benchmarking individually is enough? Or perhaps I misunderstand.
05:59:27 <mattam> It's for an abstract so yes it is formal
05:59:28 <ivanm> Is there any way of getting the Latex Listings package to parse literate haskell properly?
05:59:56 <dons> i was just considering how we'd go about replacing say, 50 functions in the standard libs, in terms of getting consensus for doing so
06:00:07 <dcoutts_> dons, all at once :-)
06:00:22 <dcoutts_> dons, the point is that they'd be more fusible, you don't get that piecemeal
06:00:31 <dons> true
06:00:40 <dons> properties then. lots of 'em and good numbers.
06:00:42 <notsmack> question about haskell compilation:  I'm using the FFI to compile to .o with no problem;  how do I instead make a shared object?
06:00:47 <dcoutts_> dons, yes.
06:03:19 <notsmack> can it be done?
06:03:44 <malcolmw> Igloo: yup, my ghc-6.4.1 calls the mangler, so it is registerised
06:04:09 <Igloo> OK
06:04:20 <tuukkah> notsmack, ghc -optl -shared
06:05:03 * chessguy returns
06:07:03 <norpan> do shared objects work in ghc in linux nowadays?
06:08:13 * notsmack hopes so
06:09:00 <tuukkah> at least they work for some people
06:09:22 <Pastorn> @paste
06:09:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:09:59 <notsmack> is there another compiler that might handle shared objects better?
06:10:52 <hpaste>  Pastorn pasted "data type declaration error (see comments)" at http://hpaste.org/729
06:11:53 <Pastorn> ?src repeat
06:11:54 <lambdabot> repeat x = xs where xs = x : xs
06:12:11 <Pastorn> @type read
06:12:14 <lambdabot> forall a. (Read a) => String -> a
06:13:00 <Pastorn> ?src transpose
06:13:01 <lambdabot> transpose []             = []
06:13:01 <lambdabot> transpose ([]   : xss)   = transpose xss
06:13:01 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
06:15:09 <earthy> ivanm: not that I know of
06:15:09 <dons> malcolmw: some bug sfor you in #haskell-overflow
06:15:09 <ivanm> earthy: OK.... took a while for anyone to read any of my questions ;)
06:15:09 <Pastorn> ?src sequence
06:15:09 <lambdabot> sequence ms = foldr k (return []) ms
06:15:09 <lambdabot>     where
06:15:09 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
06:16:33 <quicksilver> that transpose would look neater as zipWith (:) . unzip  [ (h,t) :
06:16:34 <quicksilver> IMO
06:19:00 <quicksilver> erm
06:19:08 <quicksilver> that wouldn't be the same thing, though :)
06:19:17 <quicksilver> just uncurry (:) unzip, I mean
06:20:19 <earthy> ivanm: I tend to simply use lhs2TeX
06:20:27 <earthy> or haddock
06:20:30 <earthy> but rarely both at the same time
06:21:00 <earthy> okay, enough profiling of Dazzle. 66.3% of the runtime is spent in C land
06:21:21 <earthy> and I'm down from ~5000s to ~800s
06:21:26 <ivanm> earthy: well, I have my haskell code in a seperate file in bird style... can't use lhs2tex for it
06:21:32 <earthy> ah, no
06:22:03 <earthy> you can use unlit though, and then use the results of that with the listing style
06:22:47 <ivanm> unlit? what's that?
06:24:56 <Pastorn> could someone please have a quick peek at my paste?
06:25:02 <Pastorn> http://hpaste.org/729+
06:25:03 <earthy> /usr/local/src/ghc-6.6/utils/unlit/README
06:25:08 <Pastorn> http://hpaste.org/729
06:26:14 <earthy> Pastorn:
06:26:21 <earthy> you need data Symbol a
06:26:38 <earthy> because in your definition of the constructor Other you require a type variable
06:26:43 <earthy> which you haven't bound yet
06:27:49 <notsmack> test: internal error: stg_ap_v_ret
06:27:50 <notsmack>     (GHC version 6.6 for i386_unknown_linux)
06:29:00 <Pastorn> oh... thanks :D
06:30:57 <Pastorn> earthy, changed it to (Other Char), still doesn't work :/
06:31:24 <earthy> yeah, you don't want the parentheses
06:31:29 <earthy> so | Other Char
06:31:31 <earthy> should suffice
06:31:45 <Pastorn> nope... still doesn't work :/
06:32:31 <earthy> um. your data LSystem should be type LSystem :)
06:32:39 <earthy> you're not adding constructors for LSystem
06:32:54 * earthy hadn't even seen that yet :)
06:32:54 <Pastorn> hehe... "whoops"
06:35:08 <Pastorn> @type (x:: Int) * pi
06:35:18 <lambdabot> Not in scope: `x'
06:35:23 <Pastorn> @type (60:: Int) * pi
06:35:26 <lambdabot>     No instance for (Floating Int)
06:35:26 <lambdabot>       arising from use of `pi' at <interactive>:1:13-14
06:35:36 <earthy> well, duh. ;)
06:36:34 <quicksilver> @type fromIntegral (60 :: Int) * pi
06:36:37 <lambdabot> forall b. (Floating b) => b
06:36:56 <Pastorn> nice :D
06:44:31 <earthy> @type 60 * pi
06:44:33 <lambdabot> forall t. (Floating t) => t
06:44:51 <earthy> > 60 * pi
06:44:54 <lambdabot>  188.49555921538757
06:45:24 <earthy> ain't defaulting great?
06:45:45 <Pastorn> @type (let (toRad = (/180) . (*pi) . fromIntegral) in toRad 360)
06:45:48 <lambdabot> parse error on input `='
06:46:03 <dons> > reverse [] -- yep, and -fextended-defaulting is even better!
06:46:05 <lambdabot>  []
06:46:06 <Pastorn> @type (let (toRad = (/180) . (*pi) . fromIntegral) in (toRad 360))
06:46:09 <lambdabot> parse error on input `='
06:47:19 <Thunder> @type let toRad = (/180) . (*pi) . fromIntegral in toRad 360
06:47:21 <lambdabot> forall b. (Floating b) => b
06:47:37 <Thunder> @unpl (/180) . (*pi) . fromIntegral
06:47:37 <lambdabot> (\ e -> ((fromIntegral e) * pi) / 180)
06:48:03 <Pastorn> @type let toRad = (/180) . (*pi) . fromIntegral in toRad
06:48:06 <lambdabot> forall b a. (Integral a, Floating b) => a -> b
06:48:21 <Pastorn> Thunder, unpl?
06:49:43 <earthy> unpointless
06:49:56 <Pastorn> hehe
07:00:49 <ivanm> OK, I've just finished the draft of the paper I've been doing my Latin Squares project on
07:01:05 <ivanm> Does anyone want to read it before I go to sleep (need to wake up in 5 hours :)
07:01:16 <ivanm> that should be :s), not :)
07:01:47 <ivanm> @yarr
07:01:47 <lambdabot> Yo ho ho, and a bottle of rum!
07:02:08 <ivanm> ?localtime ivanm
07:02:10 <lambdabot> Local time for ivanm is Fri Mar  2 01:01:36
07:02:20 <ivanm> sleep time! g'night!
07:02:44 <quicksilver> ?localtime quicksilver
07:02:48 <lambdabot> Local time for quicksilver is Thu Mar  1 14:59:58 2007
07:02:55 <quicksilver> how does it know?
07:03:46 <earthy> it does a ctcp time query
07:04:24 <earthy> so if your clock is off it'll still show your local time. :)
07:05:02 <opqdonut> unless your client lies in ctcp responses!
07:05:20 <earthy> in which it'll show what your client tells it is your local time
07:08:23 <Pastorn> what can I use to do Double -> Int?
07:08:45 <Pastorn> nevermind...
07:09:59 <Pastorn> @type (round . (*180) . (/pi))
07:10:02 <lambdabot> forall b a. (Integral b, Floating a, RealFrac a) => a -> b
07:10:22 <earthy> @hoogle Double -> Int
07:10:23 <lambdabot> No matches, try a more general search
07:10:48 <earthy> @hoogle (Floating a, Integral b) => a -> b
07:10:50 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
07:10:50 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
07:10:50 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
07:11:02 <earthy> @hoogle round
07:11:03 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
07:11:03 <lambdabot> Text.Html.background :: String -> HtmlAttr
07:11:03 <lambdabot> System.Win32.Info.cOLOR_BACKGROUND :: SystemColor
07:11:14 <earthy> @hoogle (RealFrac a, Integral b) => a -> b
07:11:15 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
07:11:15 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
07:11:15 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
07:11:21 <earthy> hm. right. :)
07:12:50 <quicksilver> isn't there truncate, too?
07:12:55 <quicksilver> @more
07:13:05 <quicksilver> @hoogle truncate
07:13:06 <lambdabot> Prelude.truncate :: (RealFrac a, Integral b) => a -> b
07:13:06 <lambdabot> System.Win32.File.tRUNCATE_EXISTING :: CreateMode
07:13:08 * quicksilver nods
07:14:33 <huschi> hi all.
07:14:52 <huschi> i've got a type like "data Language = En | De | Fr | Es | ..."
07:15:33 <huschi> if i derive Show and Read these values are related to the strings "En", "De", "Fr", "Es", ...
07:15:42 <hpaste>  Icebreaker annotated "Pentago" with "Now checks for winning board" at http://hpaste.org/730#a1
07:16:10 <huschi> how can i achieve that they are related to "en", "de", "fr", "es"... without writing too much code.
07:16:17 <huschi> ?
07:16:49 <glguy> !say alive
07:16:50 <hpaste> alive
07:16:52 <lemmih> ppLanguage = map toLower . show?
07:17:53 <glguy> lemmih: did you get my email?
07:18:05 <huschi> lemmih: i also want these values to be generated/recogniced by show/read.
07:18:54 <quicksilver> huschi: show/read are not really intended as a general prettyprinter/parser pair, so much as for debugging
07:19:12 <quicksilver> huschi: still the answer to your question is to stop 'deriving' and write your own implementations
07:19:44 <huschi> quicksilver: that would be writing too much code without thinking.
07:20:46 <quicksilver> you could derive Read and Show on a newtype, and attach read and show on the real type to the newtype via toLower and so on
07:20:49 <quicksilver> sounds nasty to me
07:21:41 <huschi> quicksilver: too me too.
07:22:07 <huschi> well, i need it for parsing xml and there is a XmlAttrType class und HaXml.
07:22:27 <huschi> i will derive Show and Read und implement that class by means of toLower.
07:25:16 * glguy pre-emptively boings
07:26:11 <shapr> glguy: ahh, you beat me to it!
07:26:28 * shapr throws bouncy lambdas at glguy 
07:26:55 <glguy> shapr: did you see my email?
07:27:18 <shapr> I'm reading it now.
07:27:56 <matthew_-> so are there any plans on incorporating session types into haskell?
07:29:47 <shapr> Oh, I think I'm gonna like returning unmatched suffixes.
07:30:25 <glguy> it only does it if you ask for them
07:40:40 <earthy> yeah! Prelude GHC DynFlags> load sess LoadAllTargetsghc-6.6: panic! (the 'impossible' happened)
07:40:43 <earthy>   (GHC version 6.6 for powerpc-apple-darwin):
07:40:45 <earthy>         lookup_dfun main:Text.XML.HaXml.Lex.$f3{v r9Dc} [lid]
07:40:51 <earthy> time to go for drinks
07:42:09 <glguy> ?localtime glguy
07:42:10 <lambdabot> Local time for glguy is Thu Mar 01 09:39:22 2007
07:42:11 <glguy> agreed
07:43:36 <quicksilver> Anyone got any good references on bytecode compiler design?
07:43:51 <Pastorn> > "he" ++ "\n" ++ "llo"
07:43:52 <lambdabot>  "he\nllo"
07:44:04 <quicksilver> I read a throwaway comment here once about 'once you get sophisticated enough that you move from an evaluator to a stack-based machine"
07:44:09 <quicksilver> at the time I didn't question it
07:44:23 <quicksilver> but now I'm wondering "which is a stack machine obviously better than an AST evaluator?
07:44:26 <Pastorn> > "he" : '\n':"llo"
07:44:28 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
07:44:33 <quicksilver> s/which/why/
07:44:45 <Pastorn> > 'n'
07:44:47 <lambdabot>  'n'
07:44:47 <glguy> > "he" ++ '\n' : "llo"
07:44:49 <lambdabot>  "he\nllo"
07:44:54 <Pastorn> > '\n'
07:44:55 <lambdabot>  '\n'
07:44:58 <matthew_-> anyone here at glasgow?
07:45:08 * quicksilver looks around doubtful
07:45:11 <quicksilver> this is glasgow?
07:45:15 <quicksilver> doesn't look like it to me
07:45:37 <Pastorn> apparently Simon Peyton Jones is here at Chalmers this week...
07:45:49 <Pastorn> a friend spotted him together with hughes
07:45:54 <matthew_-> ...right. In other news, does anyone have a copy of the paper at http://www.dcs.gla.ac.uk/publications/paperdetails.cfm?id=8353 ?
07:45:57 <lambdabot> Title: Computing Science - Publications
07:46:11 <Pastorn> Claiming we should hunt him down and make him sign our chests...
07:46:25 <matthew_-> annoyingly, acm don't seem to have the paper and I really really want to read it...
07:47:38 <quicksilver> matthew_-: http://www.dcs.gla.ac.uk/~simon/publications/tcs06.pdf
07:47:44 <quicksilver> matthew_-: google scholar ftw
07:48:32 <matthew_-> ahh! thanks so much. I'm amazed plain google didn't find it given there were only 4 results for it.
07:49:26 <quicksilver> matthew_-: scholar.google.com is quite a bit better at finding the actual paper (rather than pages with abstracts)
07:50:07 <quicksilver> matthew_-: there is, incidentally, an '07 version in teh same dir, not sure what if anything is different
07:50:15 <matthew_-> ahh. fair enough. scholar's harder to type than google, so given firefox's keywords, lazyness tends to win...
07:50:17 <matthew_-> mmm. cheers
07:52:15 <glen_quagmire> is haskell better than ocaml?
07:52:23 <glen_quagmire> #haskell has more people
07:52:44 <gour> glen_quagmire: not only that
07:52:53 <Thunder> Numbers of users do not correspond to quality.
07:53:22 <Thunder> Ocaml is different. And if you ask here: Haskell is better. :-)
07:53:33 <matthew_-> which means we're right.
07:54:20 <Thunder> matthew: _We_ are always right. (compared to other langugae abusers)
07:54:49 <quicksilver> glen_quagmire: ocaml is a good imperative language with some kind of weak type-checking
07:54:55 <quicksilver> glen_quagmire: it's a bit like Perl
07:55:00 <quicksilver> glen_quagmire: haskell is a functional language
07:55:02 <quicksilver> ;)
07:55:03 <matthew_-> rotfl
07:55:24 <matthew_-> how to condemn a language in five words. "it's a bit like Perl"
07:55:36 <CosmicRay> or s/Perl/Java/
07:55:43 <Thunder> Oh, Perl6 is not that bad.
07:55:49 <Thunder> It's a bit like Haskell.
07:55:52 <Pastorn> ?src iterate
07:55:53 <CosmicRay> I think that OCaml is like a hybrid between Haskell and Fortran
07:55:53 <lambdabot> iterate f x =  x : iterate f (f x)
07:56:01 <quicksilver> perl6 is good in the same why that epigram is good
07:56:03 <CosmicRay> ocaml's I/O support really stinks, unlike perl
07:56:06 <quicksilver> neither of them actually exists :)
07:56:50 <yip> does ocaml have light weight threads?
07:57:27 <dcoutts_> I don't think it does
07:57:38 <Thunder> yip: Does that matter?
07:57:54 <CosmicRay> ocaml can't even open a file read/write in the default library
07:57:57 <yip> Thunder: they can be pretty cool
07:58:16 <dcoutts_> if you want to take advantage of your multi-core cpus then it matters :-)
07:58:18 <yip> dcoutts_: btw, i've put a darcs repos online for my haskell gameboy emulator:
07:58:23 <yip> http://www.mutantlemon.com/omegagb/
07:58:25 <lambdabot> Title: OmegaGB - Game Boy Emulator
07:58:25 <dcoutts_> ah great
07:58:30 <Thunder> yip: There are a lot of things which are pretty cool.
07:58:31 <quicksilver> actual two trivial things about ocaml annoy me more than the important things
07:58:37 <quicksilver> 1. value restriction
07:58:49 <quicksilver> 2. constructors not being functions
07:58:57 <quicksilver> between them they really mess up high-level code, IME
07:59:17 <emu> +. vs +
07:59:27 <emu> lack of type classes
08:00:29 <allbery_b> someone should send them oleg's most recent message :)
08:00:45 <CosmicRay> oh also, ints in ocaml are 31 bits.
08:01:12 <CosmicRay> there are two incompatible list types, one lazy, and one strict
08:01:15 <gour> what's recommended package for doing database-stuff with sqlite3, takusen, haskelldb,hdbc, hsql..?
08:01:28 <CosmicRay> gour: I would tell you HDBC but I just *may* have a hint of bias
08:01:52 <CosmicRay> I use sqlite3 via HDBC in hpodder with good results
08:02:00 <gour> CosmicRay: have you thought about howto support extension api in sqlite3?
08:02:36 <CosmicRay> not really, but someone -- sigh, I forget who, a HaskellDB guy -- is adding a genericized extension support to HDBC
08:02:42 <gour> @where hpodder
08:02:42 <lambdabot> I know nothing about hpodder.
08:02:43 <CosmicRay> I may even have patches from him somewhere
08:02:51 <glen_quagmire> ok i finished haskell in 5 steps
08:02:51 <CosmicRay> gour: http://software.complete.org/hpodder
08:02:53 <lambdabot> Title: hpodder
08:04:27 <gour> CosmicRay: ta
08:07:03 <gour> CosmicRay: any eta for ext. support ?
08:25:08 * rufius has reached the conclusion that the hardest part of haskell is IO
08:25:29 <LPhas> someone can help me getting the dependency graph of a module to compile?
08:25:40 <LPhas> i was planning to get it from cabal
08:27:45 <Igloo> Cabal doesn't know it
08:28:14 <Igloo> You should be able to get it from teh GHC API if you don't mind being non-portable?
08:28:49 <LPhas> yes, it's not a problem to being not portable
08:29:02 <LPhas> but how can cabal don't know it?
08:29:12 <LPhas> you mean that cabal uses --make?
08:29:13 <Igloo> It just calls ghc --make
08:29:19 <LPhas> oh
08:29:44 <quicksilver> zbrown: people certainly think IO is hardest. I think sometimes they make it harder than it really is.
08:30:11 <Igloo> I'm not really familiar with that bit of the API, but http://darcs.haskell.org/ghctags/ might give you something to work from
08:30:12 <lambdabot> Title: Index of /ghctags
08:31:34 <LPhas> Igloo: do you have a link for GHC API?
08:32:42 <Igloo> http://haskell.org/haskellwiki/GHC/As_a_library for some docs
08:32:43 <lambdabot> Title: GHC/As a library - HaskellWiki
08:32:52 <LPhas> thx
08:35:12 <LPhas> but there isn't a list of the API?
08:36:00 <alexj> LPhas: searchpath traverses module graphs. You can also grab code from it.
08:36:46 <alexj> http://searchpath.org
08:36:47 <lambdabot> Title: SearchPath
08:39:10 <Pastorn> @type iterate
08:39:13 <lambdabot> forall a. (a -> a) -> a -> [a]
08:42:03 <glen_quagmire> how do I make ghc spit out c or c++ code?
08:42:09 <LPhas> curl http://searchpath.org/searchpath/SearchPath.hs > SearchPath.hs
08:42:09 <LPhas> ghc --make SearchPath.hs -o sp
08:42:12 <LPhas> bwhawhawhgaweghhadj
08:42:13 <LPhas> LOL
08:42:15 <chessguy> > iterate *2 1
08:42:16 <lambdabot>        add an instance declaration for (Num (t -> (a -> a) -> a -> [a]))
08:42:21 <chessguy> > iterate (*2) 1
08:42:22 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
08:42:25 <chessguy> yes i am a genius
08:43:39 <Botje> > fix (*2)
08:43:41 <lambdabot>  Exception: <<loop>>
08:43:46 <Botje> boo hiss.
08:44:02 <Botje> > fix ((1:) .(*2))
08:44:03 <lambdabot>   add an instance declaration for (Num [t])
08:44:11 <yip> > let v = v + 1 in v
08:44:12 <lambdabot>  Exception: <<loop>>
08:45:29 <glguy> > fix ( (1:) . map (+1) )
08:45:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:45:51 <glguy> > fix ( (1:) . map (*2) )
08:45:53 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
08:45:56 <glguy> is that what you wanted?
08:46:46 <Botje> yeah
08:47:00 <glguy> > let xs = 1 : map succ xs
08:47:00 <lambdabot>  Parse error
08:47:09 <glguy> > let xs = 1 : map succ xs in xs
08:47:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:47:51 <glguy> In the spirit of the idiots that post stuff to digg, I've labeled a chair at work [PROFOUND]
08:48:03 <glguy> and left it out in the middle of the walkway
08:48:08 <glguy> it's a hit!
08:48:41 <chessguy> i'm sure it has been hit many times
08:49:07 <chessguy> being in the middle of the hallway
08:49:41 <glguy> it's a dirty old chair that looks like it is from the 70s
08:49:59 <glguy> someone decided that it was too classic to throw away and took the DISCARD sticker off of it
08:50:03 <glguy> and wrote KEEP
08:53:27 <glguy> @losers
08:53:27 <lambdabot> Maximum users seen in #haskell: 332, currently: 301 (90.7%), active: 47 (15.6%)
08:54:37 <LPhas> but is the GHC API totally undocumented?
09:14:15 <kosmikus> @tell ivanm: you can use Bird-style with lhs2tex -- it being in a separate file (which you presumably don't want to modify at all) might be more of a problem
09:14:16 <lambdabot> Consider it noted.
09:14:53 <glen_quagmire> lambdabot: asl?
09:15:07 <Pastorn> how do I make an instance of + and - for tuples so that, say (1,3) + (2,3) = (3,6)
09:15:10 <glguy> You are thinking of @vixen, which is down
09:15:30 <glguy> ?src Num
09:15:30 <lambdabot> class  (Eq a, Show a) => Num a  where
09:15:31 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:15:31 <lambdabot>     negate, abs, signum     :: a -> a
09:15:31 <lambdabot>     fromInteger             :: Integer -> a
09:16:35 <Pastorn> ?src (+) :: Integral
09:16:35 <lambdabot> Source not found. Where did you learn to type?
09:16:40 <Pastorn> ?src (+) :: Int
09:16:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:16:57 <Pastorn> ?src (+) :: Num
09:16:57 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:17:01 <Pastorn> help?
09:21:45 <Pastorn> @hoogle instance
09:21:46 <lambdabot> Prelude.instance :: keyword
09:21:47 <lambdabot> Language.Haskell.TH.instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
09:21:47 <lambdabot> Language.Haskell.TH.InstanceD :: Cxt -> Type -> [Dec] -> Dec
09:22:01 <Pastorn> kill me now...
09:22:37 * DynWind killz
09:23:00 <glguy> Pastorn: try asking a direct question, what don't you know how to do?
09:23:06 <LPhas> if
09:23:07 <LPhas> newtype ModuleName = Module.ModuleName FastString
09:23:16 <LPhas> why i can't
09:23:17 <LPhas> :t (ModuleName mkFastString "asd") :: ModuleName
09:23:19 <lambdabot> Not in scope: data constructor `ModuleName'
09:23:19 <lambdabot>  
09:23:19 <lambdabot> <interactive>:1:12: Not in scope: `mkFastString'
09:23:20 <Pastorn> I don't know how to make an instance of (+)
09:23:42 <glguy> (+) isn't a class
09:23:46 <Pastorn> I want to be able to do coordinate calculations
09:23:48 <glguy> You want an instance of Num?
09:24:10 <glguy> what does (1,2) * (3,4) mean?
09:24:13 <LPhas> oh, sorry
09:24:14 <LPhas> :t (mkFastString "asd") :: ModuleName
09:24:16 <lambdabot> Not in scope: `mkFastString'
09:24:16 <lambdabot>  
09:24:16 <lambdabot> <interactive>:1:24:
09:24:23 <Pastorn> nothing... that ain't gonna happend...
09:24:32 <Pastorn> so (0,0) seems fine :D
09:24:54 <glguy> Pastorn: You probably just shouldn't be making this an instance of Num
09:25:05 <glguy> since it doesn't behave like one then
09:25:15 <glguy> or you could say:
09:25:24 <glguy> (1,2) * (3,4) = (1*2,3*4)
09:25:28 <Pastorn> I could make it (a,b) * (x,y) = (a*x, b*y)
09:25:34 <Pastorn> yeah
09:25:41 <glguy> ?src Num
09:25:41 <lambdabot> class  (Eq a, Show a) => Num a  where
09:25:41 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:25:41 <lambdabot>     negate, abs, signum     :: a -> a
09:25:41 <lambdabot>     fromInteger             :: Integer -> a
09:25:59 <glguy> so: write:
09:26:08 <glguy> instance Num a => Num (a,a) wher
09:26:09 <glguy> e
09:26:14 <Pastorn> instance Num (Double, Double)
09:26:18 <glguy> and then define all of the funtions below
09:26:32 <glguy> no sense in making it specific to Double
09:26:33 <Pastorn> thanks :D
09:27:41 <Pastorn> glguy, yeah, you're right, Num it is
09:29:05 <Pastorn> do I need to define fromInteger?
09:29:19 <kosmikus> @type fromIntegral
09:29:21 <lambdabot> forall a b. (Num b, Integral a) => a -> b
09:29:30 <glguy> @type fromInteger
09:29:33 <lambdabot> forall a. (Num a) => Integer -> a
09:29:41 <glguy> \a -> (a,a)
09:29:53 <glguy> Pastorn: you have to use the whole class
09:29:59 <glguy> (some methods can have default implemenations)
09:30:38 <Pastorn> i just do f (x,y) = (f x, f y)
09:30:53 <glguy> no
09:30:59 <Pastorn> no?
09:31:07 <glguy> Num a => *Integer* -> (a,a)
09:31:17 <Pastorn> oh...
09:31:31 * glguy lunch
09:31:36 <Pastorn> ?src signum
09:31:37 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:31:46 <Pastorn> ?src signum :: Int
09:31:47 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:31:54 <Pastorn> ?src Int.signum
09:31:55 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:32:02 <Pastorn> what is signum?
09:32:10 <DynWind> signed?
09:32:15 <ddarius> @src Int signum
09:32:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:33:03 <tarantoga> Pastorn: returns -1 if negative, +1 if positive, 0 if zero
09:33:27 <Pastorn> thanks
09:37:46 <huschi> is there something like the XmlContent class from HaXml in HXT?
09:39:37 <quicksilver> > map signum [-75,0,128]
09:39:38 <lambdabot>  [-1,0,1]
09:40:10 <Botje> ?src signum
09:40:11 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:41:29 <quicksilver> I don't think it can find the sources for the instances for the built-ins
09:41:56 <quicksilver> ?src [] liftM
09:41:57 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:42:00 <quicksilver> ?src [a] liftM
09:42:01 <lambdabot> Source not found. stty: unknown mode: doofus
09:42:15 <dmhouse> This is really weird.
09:42:20 <Pastorn> "instance Num a => Num (a, a) where" gives me "Repeated type variable "a" in instance head" (
09:42:23 <Pastorn> :(
09:42:38 <dmhouse> Pastorn: use -fglasgow-exts.
09:42:48 <dmhouse> Pastorn: instance declarations are stupidly limited in H98.
09:42:54 * Pastorn uses hugs
09:43:08 <dmhouse> Don't :) Or doesn't Hugs have something similar?
09:43:27 <mahogny> Pastorn, hm. chalmers? :) have you just started there?
09:43:30 <quicksilver> I believe hugs supports many of the glasgow exts but I have no idea how you turn them on.
09:43:53 <LPhas> pls, someone could help me? i have this function: depanal :: Session -> [ModuleName] -> Bool -> IO (Maybe ModuleGraph)
09:43:56 <Pastorn> worked a little better :D
09:44:02 <LPhas> but i can't manage to get a ModuleName data
09:44:16 <dmhouse> Okay. Text.XHtml.Strict.Attributes clearly exports the 'disabled' function. I'm importing Text.XHtml.Transitional, which in turns imports and reexports the aforementioned module. However, I'm getting a not-in-scope error regarding 'disabled'.
09:44:17 <Pastorn> @paste
09:44:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:44:20 <mahogny> my rule of thumb for hugs: avoid avoid :P I don't see any reason why one would use it
09:44:23 <Pastorn> LPhas, paste?
09:44:31 <LPhas> ok
09:44:40 <Pastorn> mahogny, nice error messages?
09:44:47 <dmhouse> mahogny: it (or, more specifically, WinHugs), is great on Windows.
09:44:53 <Pastorn> fuck this...
09:44:55 <mahogny> Pastorn, hm. I think they are worse
09:45:15 <mahogny> dmhouse, I guess the follow up then is, why the heck are you using windows?? :)
09:45:22 * Pastorn defines +' :: (Double, Double) -> (Double, Double) -> (Double,Double)
09:45:37 <quicksilver> Pastorn: much better
09:45:49 <quicksilver> Pastorn: pairs really aren't instances of num in a sensible way :)
09:45:50 <Botje> Pastorn: you're implementing complex numbers? :)
09:46:18 <Pastorn> no, coordinates for Turtle graphics/L-Systems
09:46:23 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/731
09:46:36 <LPhas> it's mine
09:46:44 <LPhas> i really don't understand
09:46:44 <Pastorn> where should we look?
09:47:06 <dmhouse> Pastorn: ooh, you might try the -98 flag to Hugs.
09:47:55 <ndm> mahogny: i find the error messages much more readable, half the time i spend trying to "see" all the GHC error message at once - with Hugs its all there for you
09:48:16 <Pastorn> if I define a function as (f), then the normal way to use it should be "x f y", right?
09:48:28 <ndm> Pastorn: f x y
09:48:37 <ndm> or x `f` y
09:48:40 <Igloo> It has to be symbols to define it as (+)
09:48:45 <LPhas> Pastorn , i pasted my problem
09:48:58 <dmhouse> Pastorn: yes, if the name is all non-alphanumeric characters.
09:49:15 <Igloo> Oh, actually, defining (f) will probably work too, with it being treated as a pattern
09:49:16 <Pastorn> dmhouse, thanks ;)
09:53:58 <Pastorn> let (+') (x,y) (x',y') = (x + x', y + y') in (0,0) +' (1,2)
09:54:33 <Botje> @pl \(x,y) (x',y') ->  (x + x', y + y')
09:54:34 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
09:54:39 <Botje> pure poetry.
09:54:44 <ndm> Pastorn: don't use ', its like a letter :)
09:54:51 <Pastorn> :(
09:54:57 <Pastorn> ndm, what can I use?
09:55:15 <Botje> MY_COOL_PLUS_OPERATOR
09:55:20 <ndm> Pastorn: +!~%^&*$<>=
09:55:30 <ndm> +!
09:55:33 <Pastorn> +! seems nice =)
09:55:45 <ndm> or you can make it an instance of Num, and use +
09:55:58 <ndm> but thats probably something to look at afterwards
09:56:05 <Pastorn> Botje, "(flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))" seems kinda nice =)
09:56:08 <dmhouse> Pastorn: I'd make it an instance of Num. Just use the -98 flag to Hugs.
09:56:34 <Pastorn> dmhouse, nah, "+!" is cooler
09:56:54 <dmhouse> :)
09:57:06 <ndm> dmhouse: why -98 to make an instance of Num?
09:57:29 <dmhouse> ndm: you'd need instance Num (a, a), and that's a repeated tyvar in the instance head.
09:57:48 <ndm> dmhouse: ah, fair enough :)
09:58:05 <ndm> dmhouse: you could always define Pair a = Pair a a, then make it Pair a
09:58:19 <dmhouse> ndm: that's pretty much Data.Complex right there :)
10:00:19 <Pastorn> @type foldr
10:00:22 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:00:46 <Pastorn> ?src foldr
10:00:47 <lambdabot> foldr k z xs = go xs
10:00:47 <lambdabot>     where go []     = z
10:00:47 <lambdabot>           go (y:ys) = y `k` go ys
10:00:56 <Pastorn> ?src scanr
10:00:56 <lambdabot> scanr _ q0 []     =  [q0]
10:00:57 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
10:00:57 <lambdabot>     where qs@(q:_) = scanr f q0 xs
10:01:10 <Pastorn> @google Cale scan fold picture
10:01:13 <lambdabot> http://www.springerlink.com/index/QRV4J7DD5G97GV4J.pdf
10:01:14 <lambdabot> Title: SpringerLink Home - Main
10:01:19 <Pastorn> no...
10:01:30 <Pastorn> Cale, could you link me to your nice picture?
10:02:43 <nmessenger> http://cale.yi.org/index.php/Fold_Diagrams
10:02:44 <lambdabot> Title: Fold Diagrams - CaleWiki
10:02:45 * Pastorn found it...
10:04:07 <Pastorn> I don't exactly get it... say that i have [Int] and I want to do a function that gives me [Int] where each element is the sum so far, what do I use?
10:04:29 <nmessenger> scan
10:04:33 <Pastorn> ok
10:04:41 <nmessenger> > scanr (+) 0 [1..10]
10:04:43 <lambdabot>  [55,54,52,49,45,40,34,27,19,10,0]
10:04:53 <nmessenger> > scanl (+) 0 [1..10]
10:04:54 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
10:05:16 <Pastorn> oh, I thought it did it the "wrong" way first
10:05:25 <nmessenger> add a 'last' and you have foldl/r  :)
10:05:44 <Pastorn>  scanr1 (+) [1..10]
10:05:46 <Pastorn> > scanr1 (+) [1..10]
10:05:48 <lambdabot>  [55,54,52,49,45,40,34,27,19,10]
10:05:56 <Pastorn> > scanl1 (+) [1..10]
10:05:58 <lambdabot>  [1,3,6,10,15,21,28,36,45,55]
10:07:23 <Pastorn> @type scanl
10:07:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:07:27 <Pastorn> @type scanl1
10:07:30 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
10:07:41 <Pastorn> weird...
10:08:24 <Pastorn> ?src scanl1
10:08:25 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
10:08:25 <lambdabot> scanl1 _ []     =  []
10:08:38 <nmessenger> (+) is the (a->a->a), [1..10] is the first [a], and the result is the second [a]
10:08:42 <Pastorn> ?src scanl
10:08:42 <lambdabot> scanl f q ls = q : case ls of
10:08:43 <lambdabot>     []   -> []
10:08:43 <lambdabot>     x:xs -> scanl f (f q x) xs
10:10:03 <nmessenger> the non-1 versions require a base case and a combiner, the 1 versions use the list's first element as the base case, so are undefined for []
10:10:37 <nmessenger> er, the foldl/r1 versions are undefined, I guess the scanl/r1 just return []
10:11:06 <Pastorn> now to apply this to something insanely more complex...
10:11:16 <paolino> good evening, how I open a named pipe for reading commands ?
10:12:14 <Pastorn> getLine?
10:12:24 <zbrown> hmmmm
10:12:49 <resiak> @hoogle FilePath -> IO Handle
10:12:50 <lambdabot> IO.openFile :: FilePath -> IOMode -> IO Handle
10:12:50 <lambdabot> System.IO.openBinaryFile :: FilePath -> IOMode -> IO Handle
10:12:50 <Vq^> named pipe? do you mean a unix socket?
10:13:02 <paolino> yes
10:13:37 <Vq^> should be very similar to opening a tcp connection
10:14:35 <Pastorn> @type ap
10:14:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:14:40 <wkh> i can't figure out what monad transformers are
10:14:48 <wkh> i'm reading http://en.wikibooks.org/wiki/Haskell/Monad_transformers and it doesn't help
10:14:51 <hpaste>  zbrown pasted "(no title)" at http://hpaste.org/732
10:15:11 <zbrown> Could anyone tell me why that ^^ where it says 'sum lst' doesn't work?
10:15:13 <Pastorn> what module is the function "ap" in?
10:15:28 <zbrown> oh hmm nm
10:15:30 <zbrown> i think ig ot it
10:15:35 <paolino> Control.Monad
10:15:41 <Pastorn> paolino, danke
10:15:47 <zbrown> hmmm nm
10:15:55 <wkh> let ... in ...
10:16:27 <Pastorn> @pl (+!) (x,y) (x',y') = (x + x', y + y')
10:16:27 <lambdabot> (line 1, column 20):
10:16:28 <lambdabot> unexpected "="
10:16:28 <lambdabot> expecting variable, "(", operator or end of input
10:16:34 <Pastorn> @pl (x + x', y + y')
10:16:35 <lambdabot> (x + x', y + y')
10:16:53 <paolino> Vq^: tcp means opening a port, that's the way ?
10:17:06 <Pastorn> @pl \(x,y) (x',y') ->  (x + x', y + y')
10:17:07 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
10:17:10 <zbrown> wkh: thank you :)
10:17:18 <wkh> np
10:17:26 * wkh is still learning
10:17:36 * zbrown is just starting to learn :)
10:17:50 <wkh> i think you could ahnge trueFalse to: trueFalse = map Char.isLower
10:18:10 <zbrown> wkh: i know, but the 'exercises' break them down
10:18:15 <zbrown> thats why they're like that :)
10:18:19 <wkh> ah, ok
10:18:21 <zbrown> it was asking me to write a function for eaach
10:18:37 <zbrown> i know all that code could be a lot shorter, but really its just an exercise in udnerstanding how the code works
10:18:48 <wkh> ok
10:19:19 <Pastorn> Botje, there?
10:19:43 <Pastorn> @pl uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
10:19:44 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
10:20:22 <kc5tja> :t (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
10:20:24 <lambdabot> forall b a. (Num b, Num a) => a -> b -> (a, b) -> (a, b)
10:20:42 <Pastorn> @type uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
10:20:44 <lambdabot> forall b a. (Num b, Num a) => (a, b) -> (a, b) -> (a, b)
10:20:55 <Pastorn> yeah, but I can't get it to load :/
10:20:56 <kc5tja> Heh, all that typing, for a function that has a thoroughly uninteresting type signature.  :)
10:21:18 <Pastorn> kc5tja, it's coordinate/vector addition
10:21:48 <Pastorn> could someone else try to get it to load? I can't seem to get it to work...
10:22:44 <kc5tja> How are you trying to get it to load?
10:22:59 <Pastorn> :r in hugs & ghci :)
10:23:12 <Pastorn> Instance of Monad ((->) (Double,Double)) required for definition of (+!)
10:23:20 <Pastorn> how do I get me one of those?
10:23:54 <kc5tja> Sounds like you're conflicting with a predefined operator in the standard Prelude.
10:24:07 <Pastorn> ?src ap
10:24:07 <lambdabot> ap = liftM2 id
10:24:17 <kc5tja> ?src +!
10:24:17 <lambdabot> Source not found. You type like i drive.
10:24:21 <kc5tja> hmm
10:24:35 <Pastorn> no, +! is (+!) (x,y) (x',y') = (x + x', y + y')
10:24:41 <cjeris> is research.compaq.com ever up?  ever?
10:25:07 <wkh> stats?
10:25:11 <wkh> @stats
10:25:12 <lambdabot> Unknown command, try @list
10:25:14 <wkh> @list
10:25:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:25:33 <wkh> users?
10:25:35 <kc5tja> Pastorn: You missed my point though; if you look at the error message, it hints that +! is defined in some monad class.
10:25:40 <wkh> dammit, i can never remember the command
10:25:52 <kc5tja> But, your type signature is that it accepts only Nums.  Hence, a type error.
10:26:32 * Pastorn sticks to the original definitions
10:26:34 <kc5tja> Maybe I'm missing something; I'm not an experienced Haskell coder.  But that's what it seems like to me.
10:26:35 <Pastorn> -s
10:26:54 * kc5tja notes that Sucrets is an excellent way to numb your mouth.
10:27:10 <wkh> > let fibs = [1:1:zipWith (+) fibs (tail fibs)] in fibs
10:27:11 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
10:27:12 <lambdabot>       Expected...
10:27:33 <dmhouse> Pastorn: by the way, you can write (x, y) +! (x', y') = (x + x', y + y'), a bit neater.
10:27:48 <wkh> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
10:27:49 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:28:43 <ndm> I know GHC lets you return GC collection stats with -RTS -<something>
10:28:43 <dmhouse> Pastorn: and don't use the points-free style, for goodness' sake! It's horrendously complicated.
10:28:52 <ndm> but is there anyway to get the GC stats out of a Haskell program?
10:29:05 <ndm> obviously in the IO monad
10:29:07 <dmhouse> Indeed, you could import Control.Monad.Instances (which is needed for the ((->) a) instance), but I'd still write it as you just did.
10:29:20 <ndm> something like getMaximumResidency :: IO Integer
10:29:38 <dmhouse> ndm: run the program and parse the output?
10:30:00 <ndm> dmhouse: i need both wall clock time and GC stats
10:30:19 <ndm> dmhouse: and at the moment i have to get both of them from different places - would be nice to common it up
10:36:56 <nmessenger> @where stats
10:36:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
10:36:59 <nmessenger> whk: ^^
10:37:23 <nmessenger> er, wkh: ^^
10:41:19 <Pastorn> is there a rounding funtion that I can use for Double -> Double? (since sin pi /= 0)
10:41:25 <Pastorn> >sin pi
10:41:27 <Pastorn> > sin pi
10:41:29 <lambdabot>  1.2246063538223773e-16
10:41:34 <nmessenger> > round (sin pi)
10:41:35 <lambdabot>  0
10:41:41 <ClaudiusMaximus> > 320 * 240 * 3 * 25 * 60 * 60
10:41:43 <lambdabot>  20736000000
10:41:51 <Pastorn> > @type round $sin pi
10:41:52 <lambdabot>  Parse error
10:41:58 <Pastorn> > @type (round $sin pi)
10:41:58 <lambdabot>  Parse error
10:42:01 <dmhouse> ?type round $ sin pi
10:42:02 <Pastorn> @type (round $sin pi)
10:42:04 <lambdabot> forall b. (Integral b) => b
10:42:06 <lambdabot> forall b. (Integral b) => b
10:42:11 <dmhouse> You need a space after $.
10:42:39 <nmessenger> apparently some extension treats $name special
10:42:48 <dmhouse> Template Haskell.
10:45:08 * nmessenger discovers that putting (... :: ()) on an expression is a good way to see what type it really is.
10:46:14 <Vq^> paolino: instead of a host & port you open a unix socket, otherwise it's the same thing
10:47:18 <Pastorn> @pl (\x xs -> x:xs)
10:47:18 <lambdabot> (:)
10:47:25 <chessguy> > 2 (... :: ())
10:47:25 <lambdabot>  Parse error
10:47:29 <chessguy> :)
10:47:31 <Pastorn> @pl (\x:xs -> xs)
10:47:32 <lambdabot> tail
10:47:38 <nmessenger> :P
10:47:43 <chessguy> > 2 :: ()
10:47:44 <lambdabot>   add an instance declaration for (Num ())
10:47:44 <lambdabot>     In the expression: 2
10:47:44 <lambdabot>     In th...
10:48:11 <nmessenger> "so it's a Num a => a?"
10:48:13 <chessguy> the infamous ... operator
10:48:34 <chessguy> @type (...)
10:48:36 <lambdabot> Not in scope: `...'
10:48:47 <Pastorn> @type (..)
10:48:49 <lambdabot> parse error on input `..'
10:48:52 <psi> > tail :: ()
10:48:53 <lambdabot>  Couldn't match expected type `()'
10:49:07 <nmessenger> in ghci that is
10:49:48 <nmessenger> and ... isn't an operator so much as informal notation for "this part elided"
10:49:48 <Pastorn> what can I do to make (sin pi) == 1.000 ?
10:49:54 <Pastorn> sorry... 0.000
10:50:14 <chessguy> > let pi = 0 in (sin pi)
10:50:16 <lambdabot>  0.0
10:50:21 <Pastorn> hehe
10:50:31 <nmessenger> truncate rounds towards zero, floor towards -Infinity, ceiling towards Infinity, round towards the nearer number
10:50:37 <chessguy> i don't know what you're looking for
10:50:53 <Pastorn> > truncate (sin pi)
10:50:55 <lambdabot>  0
10:50:59 <Pastorn> @ty truncate (sin pi)
10:51:02 <chessguy> ohhh
10:51:02 <lambdabot> forall b. (Integral b) => b
10:51:23 <chessguy> nmessenger, you should write tutorials. you have a nice way of summarizing
10:51:33 <Pastorn> :)
10:51:40 <chessguy> seriously
10:51:45 <nmessenger> thanks
10:51:56 <chessguy> that's the second time lately i've noticed it
10:52:07 <chessguy> @quote nmessenger >>=
10:52:07 <lambdabot> nmessenger says: [hpaste] prepare to die! [nmessenger]  > "aah!" >>= replicate 5
10:52:14 <nmessenger> :)
10:52:21 <chessguy> ok, not the quote i was looking for
10:52:22 <chessguy> @quote nmessenger >>=
10:52:22 <lambdabot> nmessenger says: [hpaste] prepare to die! [nmessenger]  > "aah!" >>= replicate 5
10:52:42 <nmessenger> @quote m.a
10:52:42 <lambdabot> Cale says: alpha beta gamma delta epsilon, zeta eta theta iota kappa lambda mu, nu xi, omicron pi, rho sigma tau, upsilon phi, chi psi omega... now I know my alpha beta gammas, next time won't you
10:52:43 <lambdabot> sing with me?
10:52:55 <chessguy> @quote nmessenger combine
10:52:55 <lambdabot> nmessenger says: m a {- a computation that produces a -} -> (a -> m b) {- a function from results to new computations -} -> m b {- the combined computation -}
10:52:58 <chessguy> there we go
10:53:12 <nmessenger> they tend to come in bursts, I don't think I could sustain it for a whole article :)
10:53:57 * chessguy shrugs
10:53:59 <chessguy> would be worth a shot
10:54:36 <nmessenger> I'll probably write something one'a these days
10:54:51 <chessguy> or at least blog
10:58:12 <nmessenger> though I am awestruck at the clarity of the latest Nub Games post.  Have you read it?  http://blogs.nubgames.com/code/?p=22
10:58:13 <lambdabot> Title: Nub Games  Haskell IO for Imperative Programmers
11:01:47 <chessguy> don't think so
11:02:26 <bos31337> @seen Cale
11:02:26 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 11h 7m 48s ago.
11:04:30 <chessguy> @type do { line <- getLine; print $ length line; main }
11:04:32 <lambdabot> Not in scope: `main'
11:04:47 <chessguy> @type \main -> do { line <- getLine; print $ length line; main }
11:04:49 <lambdabot> forall t. IO t -> IO t
11:05:43 <nmessenger> @type fix $ \main -> do { line <- getLine; print $ length line; main }
11:05:46 <lambdabot> forall t. IO t
11:06:59 <nmessenger> main is called in the same block as print, so its confined to IO t, but this is an infinite loop, so it doesn't actually return a value.  Thus it has any type at all.
11:07:46 <kc5tja> clear
11:07:48 <kc5tja> oops
11:10:32 <bos> i find haskell's type system quite confounding once i leave the realm of simple types and typeclasses.
11:11:23 <chessguy> interesting article
11:11:53 <nmessenger> agreed muchly
11:13:26 <chessguy> is nubgames not syndicated on planethaskell?
11:13:34 <chessguy> (i don't know if syndicated is the right word)
11:14:43 <nmessenger> appears not
11:15:32 <chessguy> i'll just add it to my google RSS module
11:15:52 <dmhouse> nmessenger: that's a brilliant post.
11:16:32 <nmessenger> praise him not me!
11:17:33 <chessguy> "The truth is Haskell is never going to be a mainstream language." ...ouch
11:18:24 <DynWind> I think what matters is whether haskell has the critical mass to make hacking on/in it worthwhile, which it does
11:19:15 <nmessenger> chessguy: where's that from?
11:19:37 <chessguy> same guy, his post called "Writing a Simple Search Engine in Haskell: Part 0  Introduction"
11:20:08 <nmessenger> meh.  Why would you want a bunch of "mainstream" code monkeys weighing down Haskell?
11:20:14 <glguy> Being a mainstream laguage buys us nothing
11:20:24 <glguy> mainstream developers are completely inept
11:20:34 <nmessenger> *ooh ooh ah ah ah!*  *eats banana*
11:20:37 <glguy> and would contribute nothing
11:22:14 <nmessenger> from "Wearing the hair shirt": Tony Hoares comment I fear that Haskell is doomed to succeed
11:22:37 <notsmack> is there a built-in way to truncate a float to n digits when showing?
11:23:33 <nmessenger> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
11:23:35 <lambdabot> http://tinyurl.com/yjng6j
11:24:05 <nmessenger> > showFFloat 2 10.23984 ""
11:24:05 <lambdabot>   add an instance declaration for (Num (Maybe Int))
11:24:08 <notsmack> nmessenger++
11:24:13 <nmessenger> > showFFloat (Just 2) 10.23984 ""
11:24:15 <lambdabot>  "10.24"
11:24:47 <chessguy> he's got a really great style
11:25:04 <chessguy> "Well, we cant get data out of a monad to operate on it  The solution is obvious, isnt it?  If you cant bring the data to the function, bring the function to the data. "
11:25:42 <nmessenger> heh, /msg lambdabot @type showFloat, @index showFloat, "Numeric", @docs Numeric
11:26:01 <nmessenger> lambdabot++
11:26:26 <chessguy> @karma  lambdabot
11:26:26 <lambdabot> lambdabot has a karma of 42
11:26:38 <nmessenger> I expected higher
11:27:49 <glguy> @karma
11:27:49 <lambdabot> You have a karma of 48
11:28:06 <DynWind> 42, let it be that
11:28:18 <glguy> While it is debateable who is more helpful, I insult people less ;)
11:28:25 <glguy> ?src forexample
11:28:26 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:28:29 <nmessenger> :D
11:28:40 <glguy> *less*
11:28:54 <nmessenger> glguy ?src forexample
11:29:24 <glguy> nmessenger: that functio doesn't exist, but I'd be happy to help you with one that does
11:29:34 <glguy> :-D
11:29:47 <nmessenger> ?guysnack
11:29:48 <lambdabot> Unknown command, try @list
11:30:21 <hpaste> *intercepted*
11:30:28 <nmessenger> :O !!
11:31:06 <Cale> bos: looking for me?
11:39:49 <monochrom> This is enlightening!  Although we use to say "one size doesn't fit all", Oleg today shows that "one class fits all"!
11:41:41 <bd_> monochrom: what do you mean?
11:41:59 <ndm> bd_: its on the cafe list
11:43:09 <monochrom> On the [haskell] list, not [haskell-cafe], actually.
11:48:13 <bd_> clever
11:53:04 * CosmicRay announces HSH: http://software.complete.org/hsh
11:53:05 <lambdabot> Title: HSH
11:53:50 <CosmicRay> thank you lambdabot, that was great
11:57:04 <Nafai> CosmicRay: Pretty cool!
11:57:15 <CosmicRay> thanks!
12:03:10 <chessguy> hrmm.
12:04:04 <chessguy> from http://blogs.nubgames.com/code/?p=22 : http://blogs.nubgames.com/code/?p=22 -- "Even though youve written code that looks like its constructing a huge list of strings in memory, thats not whats happening. Youve actually written instructions for generating a sequence of strings as you need them."
12:04:05 <lambdabot> Title: Nub Games  Haskell IO for Imperative Programmers
12:04:24 <CosmicRay> does anyone know of a command line parsing library other than GetOpt for HAskell?
12:04:30 <chessguy> is he saying that no more than one line of the file will exist in memory at a time?
12:04:40 <araujo> hi CosmicRay
12:04:46 <monochrom>  Damn!  Someone has acquired the email name "catamorphism@gmail.com" at gmail!
12:04:47 <CosmicRay> hey araujo!  ltns
12:04:52 <araujo> CosmicRay, i think hsshellscript got something like that
12:04:58 <araujo> CosmicRay, nice project
12:05:04 <CosmicRay> thanks!
12:05:08 <araujo> :-)
12:05:16 * CosmicRay plans to port some shell scripts to Haskell now
12:05:22 * araujo will find time to test it
12:05:25 <CosmicRay> strong typing plus easy shell access.  powerful combo.
12:05:30 * araujo right now going crazy with univ stuff
12:05:31 <Philippa> monochrom: sure, the interesting question's whether or not it's Binkley's (they use it as a nick in a number of places)
12:06:01 <araujo> CosmicRay, cool
12:06:14 <erider> hola araujo
12:06:18 * araujo has been trying to do the same (sanely) for a few time too
12:06:21 <araujo> hola erider
12:06:33 <erider> whats up how are things going
12:06:34 <araujo> :-)
12:06:45 <araujo> erider, i am fine ... but kind of busy :-(
12:06:57 <erider> yeah me too
12:07:09 * araujo would like a 'setDelayTime' function on real life
12:07:27 <erider> I'm close to you uno pais over
12:07:42 <araujo> erider, yeah? , where?
12:07:53 <erider> bogota
12:07:56 <araujo> CosmicRay, check one of my attempts ... haskell.org/hashell
12:08:36 <araujo> erider, very close , i live in the state on the border line with .co
12:08:51 <tibbe> does arrows sugar require any specific compiler flags? and what exactly does it desugar to?
12:09:18 <chessguy> @type \f -> interact (unlines . f . lines)
12:09:20 <lambdabot> ([String] -> [String]) -> IO ()
12:09:24 <erider> bogota is in the middle
12:09:36 <chessguy> @type interact
12:09:38 <lambdabot> (String -> String) -> IO ()
12:09:40 <monochrom> Philippa: I saw it on [haskell-cafe]. It's Kirsten Chevalier.
12:09:44 <araujo> erider, yeah, i mean, with the country :-)
12:09:50 <araujo> erider, what you doing there?
12:09:50 <nmessenger> chessguy: getContents is lazy, so when the putStr eventually requests evaluation of (unlines r), it matches on (x:xs), which causes unlines to request r's head, which goes to proccessIt, to show, to length... eventually to getContents, which gets the first character.
12:10:01 <nmessenger> putStr then puts it, and, iirc, garbage collects it.
12:10:29 <CosmicRay> araujo: yup, I actually checked that out.  interesting project, just not quite the idea I was after
12:10:47 <chessguy> the GC is what i was asking about. it seems to me that if you, in fact, need to process the whole file, you can't guarantee that it won't all be in memory at once
12:10:55 <chessguy> but i could be wrong
12:11:00 <araujo> CosmicRay, kind of unmaintained ; i am not happy with some things
12:11:12 <nmessenger> chessguy: map processIt . lines only needs one line in memory at a time
12:11:16 <araujo> CosmicRay, i also have some code around that modifies ghci to make it shell-like capable
12:13:00 <nmessenger> processIt calls length, which at least reads the line, then show, then adds it to the cons generated by map, which is passed to unlines, to interact, etc.
12:13:03 <monochrom> If you do{ getContents >>= putStr }  the cons cells will be created and gced as you go.
12:13:27 <chessguy> hmm
12:13:46 <monochrom> If you do{ s<-getContents; putStr s; putStr s }  the cons cell will be hanging around for the second putStr.
12:14:00 <chessguy> the language says how to do the GC?
12:14:22 <hpaste>  xian pasted "(no title)" at http://hpaste.org/734
12:14:33 <monochrom> the language says who are still being referenced and who are orphaned.
12:14:40 <nmessenger> I don't think so, but non-strictness would allow that behavior and I've no idea why it wouldn't.
12:14:50 <monochrom> "gc" collects the orphaned.
12:15:06 <chessguy> interesting
12:15:51 <moonlite1> nick moonlite
12:15:58 <monochrom> The whole thing is pretty obvious.
12:16:24 <nmessenger> *laziness* isn't required, just non-strictness.  But laziness is what causes the magic.
12:18:36 <monochrom> "non-strict" is at the denotational level, usually very coarse about time and space.  "lazy" is at the operational level, very detailed about what is done, when, how much cost.
12:18:48 <nmessenger> it is extemely backwards from what I've burned into my brain, too, so don't be hard on yourself :D
12:19:16 <monochrom> "very coarse" means just a boolean "finite / infinite".
12:19:19 <chessguy> wait, isn't unlines . map f . lines -- a built-in function?
12:19:29 <monochrom> No.
12:19:34 <nmessenger> nope, but easily defined
12:19:35 <chessguy> boo!
12:19:54 <chessguy> ?src interact
12:19:54 <lambdabot> interact f = do s <- getContents; putStr (f s)
12:20:19 <nmessenger> I prefer onLines f = unlines . f . lines; thus interact . onLines . map $ f
12:22:12 <monochrom> Oh, to continue.  Since "non-strictness" is very coarse about costs, it alone probably doesn't tell you the memory footprint of getContents>>=putStr.
12:28:40 <Pastorn> ?src concatMap
12:28:41 <lambdabot> concatMap f = foldr ((++) . f) []
12:28:49 <pjd> nmessenger: s/onLines/linewise/ ?
12:29:19 <nmessenger> sure
12:29:35 <CosmicRay> araujo: that sounds very nifty
12:30:21 <nmessenger> pjd: are you saying there's already a function named that?  Or just suggesting a name?
12:30:28 <pjd> nmessenger: latter
12:31:19 <pjd> hmm, it would be nifty to make multi-line strings a type
12:31:49 <nmessenger> is there any benefit over [String]?
12:31:50 <pjd> then you could define a functor instance, instead of unlines . f . lines
12:32:04 <tibbe> a <- arrowforr -< b rewritten?
12:32:09 <chessguy> ?seen lemmih
12:32:09 <lambdabot> I saw lemmih leaving #haskell 4m 34s ago, and .
12:32:26 <nmessenger> oh, so like newtype Lines = L [String]; instance Functor Lines where ...?
12:32:28 <chessguy> nice timing
12:32:37 <pjd> nmessenger: well, "benefit" is arguable
12:33:02 <emu> fmap f (L l) = L (map f l)
12:33:10 <pjd> it would probably be a newtype of String, not [String]
12:33:11 <emu> er fmap
12:33:17 <nmessenger> er, yeah
12:33:47 <pjd> the latter is already a Functor and everything
12:33:58 <moonlite> is it true that the difference between random testing (quickcheck etc) and unit testing (hunit and junit etc) is that in unit testing you define assertions that hold for specific values while in random testing the values to test against are produced "randomly". What i mean is, can unit testing be random testing too?
12:34:33 <hpaste>  tensh pasted "eval function" at http://hpaste.org/735
12:34:39 <pjd> the difference with a MultilineString is that the latter is already joined
12:34:46 <emu> sure, but QuickCheck makes it declarative
12:35:28 <emu> bbl
12:35:36 <tensh> I'm having some major trouble getting an eval-function I'm trying to write to compile: http://hpaste.org/735
12:35:44 <moonlite> emu: my question was a bit bad formulated. Was that a "sure" for the first or last question? :)
12:35:49 <tensh> been sitting with it for a while now and I can't figure it out :(
12:35:49 <nmessenger> tensh: arbitrary functions have to start with lowercase
12:35:51 <pjd> moonlite: "unit testing" isn't a very strictly-defined term to begin with
12:36:12 <tensh> argh, stupid
12:36:16 <tensh> nmessenger: thanks a lot!
12:36:18 <tensh> :)
12:36:37 <chessguy> what's the "a a" in the type signature for AritFn anyway?'
12:36:52 <tensh> ehm
12:36:54 <tensh> dunno
12:36:56 <nmessenger> neat! so 'a' has an infinite kind!
12:36:57 <tensh> that's wrong
12:36:59 <tensh> :)
12:37:05 <tensh> should be a->a
12:38:44 <nmessenger> @kind [[]]
12:38:46 <lambdabot>     `[]' is not applied to enough type arguments
12:38:47 <lambdabot>     Expected kind `*', but `[]' has kind `* -> *'
12:39:19 <tarantoga> why has Data.Set a function 'unions' but no 'intersections'?
12:40:29 <dcoutts_> holy shmolly! They're planning to add a non-blocking primitive to linux. That is you can have a function :: IO a -> IO a that runs an arbitrary IO action (including C code) and if the code blocks the current OS thread then the kernel will automatically fork a new thread and return!
12:40:49 <dcoutts_> but in the ordinary non-blocking case it runs fast
12:41:14 <dcoutts_> I wonder if GHC could use that for it's 'safe' foreign calls
12:41:24 <tarantoga> I guess it's not clear what should happen when the list is empty
12:41:46 <nmessenger> > S.unions []
12:41:47 <lambdabot>   Not in scope: `S.unions'
12:42:12 <Pastorn> anyone know a good Cont Monad guide?
12:42:21 <TSC> tarantoga: Yeah, the natural definition (for me) would use foldl1, so it would break on an empty list
12:42:23 <nmessenger> @where monads
12:42:23 <lambdabot> http://www.haskell.org/all_about_monads/html/index.html
12:42:32 <nmessenger> has some stuff
12:42:56 <kombinator> dcoutts_: hello, I noticed that gtk provides "move-cursor" signal for GtkEntry but this is missing from Entry gtk2hs
12:43:11 * dcoutts_ checks
12:43:14 <kombinator> dcoutts_: is it possible to easily add it?
12:43:21 <dcoutts_> probably
12:43:38 <dcoutts_> you'll have to use the darcs version of gtk2hs
12:44:12 <kombinator> is it already there?
12:44:54 <dcoutts_> kombinator, hmm, it's kind of an internal signal, what do you need it for?
12:44:59 <chessguy> Lemmih!
12:45:59 <nmessenger> @unmtl ContT t (RWST r w s IO) a
12:46:00 <lambdabot> (a -> r -> s -> IO (t, s, w)) -> r -> s -> IO (t, s, w)
12:46:02 <nmessenger> I like evil!
12:46:06 <kombinator> dcoutts: But it sits next to all other signals of GtkEntry in the docs. I want to be notified of cursor movement
12:46:22 <chessguy> ?remember nmessenger I like evil!
12:46:22 <lambdabot> Done.
12:46:28 <kombinator> dcoutts_: this is all for my experimental toolkit
12:46:46 <dcoutts_> kombinator, we tend not to implement 'action' signals. We're planning to remove existing 'action' signals unless they're really necessary.
12:46:46 <Lemmih> chessguy!
12:47:04 <tensh> when using a generic a in a function header, can I enforce usage of a type I defined myself using `data`?
12:47:12 <kombinator> dcoutts_: 'action' signals as opposed to...?
12:47:17 <chessguy> hey Lemmih, i can't darcs push on my repo on your server, can i?
12:47:36 <dcoutts_> kombinator, action signals are a bit special and usually internal, they're not really intended to be part of the external api, though admittedly there's some confusion over that issue.
12:47:59 <tarantoga> TSC: I'll use that then, I think in my case the list is never empty
12:48:03 <dcoutts_> kombinator, you'll notice those ones are tagged as 'Action' in the Gtk C docs.
12:48:06 <roconnor> For the first time in something like 20 years, I feel like making a flow-chart to figureout my programming task
12:48:18 <kombinator> dcoutts_: so it will not be possible to be notfied of cursor movement?
12:48:22 <nmessenger> tensh: use type (a -> YourDataType)
12:48:33 <dcoutts_> kombinator, not sure, you can try it and see if it works.
12:48:42 <wkh> i don't understand monad transformers and i don't know how to go about reducing my ignorance.
12:48:48 <Lemmih> chessguy: Sure you can.
12:48:54 <tensh> nmessenger: ahhh, thanks
12:49:18 <dcoutts_> kombinator, you'd probably need to bind the GtkMovementStep enum and add a new signal type and then bind the signal.
12:49:27 <tibbe> where can I find the arrow syntax desugaring?
12:49:35 <chessguy> from my machine, i can darcs get, make changes, darcs push, log in and record?
12:49:43 <kombinator> dcoutts_: I think that the enum is already bound
12:49:59 <nmessenger> tibbe: I was told to read "Generalizing Monads to Arrows" but I haven't yet
12:50:08 <nmessenger> @go Generalizing Monads to Arrows
12:50:09 <tibbe> ok
12:50:11 <lambdabot> http://wiki.ittc.ku.edu/lambda/Image:Hughes_Generalizing_Monads_to_Arrows.pdf
12:50:11 <lambdabot> Title: Image:Hughes Generalizing Monads to Arrows.pdf - Lambda Group
12:50:17 <nmessenger> Image?
12:50:18 <tarantoga> dcoutts_: any news about the listStore bug?
12:50:33 <kombinator> dcoutts_: http://tinyurl.com/2n9kxz
12:50:47 <dcoutts_> tarantoga, not yet, except that I can reproduce it.
12:51:08 <dcoutts_> kombinator, and you'd need to add VOID:ENUM,INT,INT to gtk2hs/tools/callbackGen/gtkmarshal.list
12:51:09 <kombinator> dcoutts_: anyway, I'll try to play with TextBuffer first, but it is quite complex
12:51:40 <nmessenger> wkh: you can understand when you'd want to write a function (s -> IO (a, s)), right?
12:51:50 <pjd> dcoutts_: how do they define "blocking"?
12:52:04 <dcoutts_> pjd, anything that would enter the kernel scheduler
12:52:05 <pjd> and when it gets forked, what gets returned, and how do you monitor the fork?
12:52:07 <wkh> nmessenger: not really
12:52:18 <dcoutts_> pjd, there's some completion ring or something
12:52:30 <Pastorn> FUCK!!! I want a global variable! NOW!!
12:52:32 <stefanha> Does GHC profiling dump the stats to file on SIGINT exit?
12:52:53 <nmessenger> I happen to know this looks like State, so first I use @kind State to see how many types it needs
12:52:55 <nmessenger> @kind State
12:52:58 <lambdabot> * -> * -> *
12:52:58 <dcoutts_> pjd, if you subscribe to LWN you can read about it now, or wait a week
12:52:59 <moonlite> Pastorn: consider a state monad or something instead
12:53:14 <Pastorn> moonlite, I have no clue of how to use those...
12:53:15 <nmessenger> needs two types, so I @unmtl to see what it turns into
12:53:20 <pjd> but when the code returns, it can't have any useful value, right?
12:53:23 <nmessenger> @unmtl State Int Char
12:53:23 <lambdabot> Int -> (Char, Int)
12:53:31 <kombinator> dcoutts_: I can be notified of cursor movement by a TextView, but I don't find a way to read its position. I have to look at the corresponding TextBuffer which is strange.
12:53:32 <Pastorn> @google State Monad
12:53:35 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
12:53:45 <nmessenger> a transformer basically smooshes another monad in the middle
12:53:47 <pjd> so does it return with a flag or something you have to check?
12:53:50 <nmessenger> @kind StateT
12:53:52 <lambdabot> * -> (* -> *) -> * -> *
12:54:00 <tibbe> nmessenger, hmm, that paper didn't explain the syntax
12:54:01 <kombinator> dcoutts_: Is it TextBuffer which remembers the position of the cursor?
12:54:05 <nmessenger> @unmtl StateT Int [] Char
12:54:05 <lambdabot> Int -> [(Char, Int)]
12:54:10 <pjd> (i have no such subscription)
12:54:18 <nmessenger> @kind []
12:54:20 <lambdabot> * -> *
12:54:26 <nmessenger> "takes a type, and produces a type"
12:54:30 <nmessenger> @kind [] Int
12:54:31 <tibbe> @seen Cale
12:54:32 <dcoutts_> kombinator, no, the view. I think it has a 'TextMark' for the insertion and selection points. you can track changes to them.
12:54:33 <lambdabot> *
12:54:33 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 23m 27s ago.
12:54:40 <nmessenger> "a simple type, list of Ints"
12:54:59 <SamB> @remtl s -> IO (a, s)
12:54:59 <lambdabot> err: No applications
12:55:05 <SamB> @mtl s -> IO (a, s)
12:55:05 <nmessenger> [] Int = [Int]
12:55:06 <lambdabot> Maybe you meant: ft map msg pl unmtl url
12:55:12 <nmessenger> no @mtl :(
12:55:18 <tarantoga> tibbe: which syntax?
12:55:23 <nmessenger> tarantoga: kinds
12:55:39 <moonlite> Pastorn: intro courses in functional programming at chalmers?
12:55:56 <Pastorn> moonlite, yeah... monads aren't included :(
12:55:58 <dcoutts_> kombinator, oh, hmm, it's not how I remembered, lemme check the docs again
12:56:01 <tarantoga> I thought he was asking about arrows
12:56:25 <moonlite> Pastorn: no that's in advanced functional programming
12:56:41 <chessguy> @kind Tree a
12:56:43 <lambdabot> Not in scope: type variable `a'
12:56:47 <chessguy> @kind Tree
12:56:50 <lambdabot> * -> *
12:56:58 <chessguy> @kind State
12:57:01 <lambdabot> * -> * -> *
12:57:02 <nmessenger> tarantoga: oops, I misunderstood
12:57:08 <Laney> Pastorn, here are my lecture notes on Monads, might help you? http://www.cs.nott.ac.uk/~gmh/monads
12:57:14 <chessguy> @kind Arrow
12:57:14 <moonlite> Pastorn: anywho. Pass a variable env through all your functions instead. That'll be almost like global state
12:57:17 <lambdabot> Class `Arrow' used as a type
12:57:17 <nmessenger> @kind (->)
12:57:19 <tibbe> tarantoga, arrows
12:57:19 <tibbe> i was asking about arrows :)
12:57:19 <tibbe> the a <- foo -< b
12:57:20 <lambdabot> ?? -> ? -> *
12:57:21 <Pastorn> moonlite, but I need to have a "stack" of sorts... input '[' takes the current position and angle and remembers it, ']' then returns back to the last remembered position
12:57:22 <nmessenger> @kind (->) Int
12:57:25 <lambdabot> ? -> *
12:57:26 <nmessenger> @kind (->) Int Char
12:57:28 <lambdabot> *
12:57:37 <chessguy> nmessenger, showoff :)
12:57:57 <Pastorn> so passing an exta variable back and forth seems kinda silly...
12:58:04 <tibbe> I want the desugaring not the kind!!!11 ;)
12:58:09 <moonlite> Pastorn: i have no idea what your assignment is. I'm guessing our assignments 4 years ago was totally different
12:58:18 <nmessenger> a (* -> *) type is an "imcomplete" type.  It still needs another type to make sense.
12:58:28 <Pastorn> hehe... Turtle graphics
12:58:43 <Pastorn> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funvt/lab3/lab3.pdf
12:58:54 <moonlite> Pastorn: aah cool. We did turtle graphics in the AFP course
12:59:07 <Pastorn> page 6
12:59:38 <tibbe> I did turtle graphics too when I took it
13:00:05 <Pastorn> how do I implement a Monad for variable storing?
13:00:16 <chessguy> Pastorn, that's exactly what State is for
13:00:28 <Pastorn> nice :)
13:00:31 <bos> multiparameter typeclasses are confusing to work with. at least, i'm confused.
13:00:53 <Laney> I'm trying to get my head round state currently too :(
13:00:58 <Pastorn> chessguy, you know any State-monad-for-n00bz0r-guides?
13:01:19 <nmessenger> If you have a function from (Map Name Value) -> (a, (Map Name Value)), i.e. returns 'a' but also updates a Name-Value mapping, you'd used State (Map Name Value) a
13:01:28 <nmessenger> @unmtl State (M.Map n v) a
13:01:28 <lambdabot> M.Map n v -> (a, M.Map n v)
13:01:33 <chessguy> @where monad
13:01:33 <lambdabot> I know nothing about monad.
13:01:36 <chessguy> @where monads
13:01:36 <lambdabot> http://www.haskell.org/all_about_monads/html/index.html
13:01:47 <dcoutts_> kombinator, ok, refreshed my memory. So yes it's the buffer that has the insert and selection mark. You can ask the buffer to notify you of changes in a mark (onMarkSet).
13:01:56 <chessguy> (as you were told before)
13:02:05 <chessguy> there's also YAHT, and many many others
13:02:05 <tarantoga> tibbe: where can I find -< ?
13:02:21 <kombinator> dcoutts_: what if a buffer has more views? they all share a cursor?
13:02:59 <njd> @users
13:03:00 <lambdabot> Maximum users seen in #haskell: 332, currently: 320 (96.4%), active: 64 (20.0%)
13:03:12 <dcoutts_> kombinator, yes. Views don't have to show the same bit of the buffer at the same time, but there's only ever one 'active' view at once, so there's a single cursor and selection per buffer.
13:03:30 <tibbe> tarantoga, hey, that was my question!
13:03:47 <tarantoga> tibbe: I mean, I've never seen it before
13:04:02 <kombinator> dcoutts_: and they lose the cursor position once they lose the focus?
13:04:13 <nmessenger> @type \mapping -> ("newint was set to 5", insert "newint" 5 mapping)
13:04:16 <lambdabot>     Couldn't match expected type `t -> t1'
13:04:16 <lambdabot>            against inferred type `[[Char]]'
13:04:36 <chessguy> @type insert
13:04:37 <nmessenger> @type \mapping -> ("newint was set to 5", M.insert "newint" 5 mapping)
13:04:38 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
13:04:40 <lambdabot> forall t. (Num t) => M.Map [Char] t -> ([Char], M.Map [Char] t)
13:04:44 <dcoutts_> kombinator, well they share the cursor position, so they loose nothing.
13:04:46 <Laney> Can someone explain in simple terms what "<-" does in the do notation please? It seems like some voodoo to me
13:04:54 <tarantoga> tibbe: so, where have you found it?
13:05:04 <nmessenger> @type modify (M.insert "newint" 5) >> return "newint was set to 5"
13:05:06 <lambdabot> forall t (m :: * -> *). (Num t, MonadState (M.Map [Char] t) m) => m [Char]
13:05:12 <kombinator> dcoutts_: ok, nevermind;)
13:05:24 <zbrown> Laney: it implies the data will be set to some variable 'foo', but its not the same as '='
13:05:28 <nornagon> Laney: it is! :D
13:05:30 <dcoutts_> kombinator, the view doesn't automatically scroll to keep the cursor visible so you can have two different views on different parts of a buffer and switch between them. That's not a problem.
13:05:39 <nornagon> <- is like a voodoo version of >>=
13:05:42 <nmessenger> @undo do { x <- action; return (f x) }
13:05:42 <lambdabot> action >>= \ x -> return (f x)
13:05:44 <tibbe> tarantoga, http://web.mit.edu/ghc/www/users_guide/arrow-notation.html
13:05:46 <lambdabot> Title: 7.7. Arrow notation
13:05:48 <chessguy> Pastorn, you may also want to check out the book "haskell school of expression", where he develops a robot that does this kind of stuff
13:05:49 <nmessenger> Laney: use @undo
13:05:51 <sjanssen_> how does one use a normal Haskell function as a ForeignPtr finalizer?
13:06:01 <zbrown> Laney: like in mathematics if you say 'let y = x^2' y is always equal to x^2, the same with haskell
13:06:14 <zbrown> Laney: but if you use '<-', it implies that it may not always be equal to the same value
13:06:20 <zbrown> so maybe you're generating random numbers
13:06:23 <Laney> @undo do { x <- Just 3} -- will this work
13:06:23 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 17}) "Parse error"
13:06:26 <Laney> :(
13:06:28 <dcoutts_> kombinator, you want textBufferGetInsert to get the insertion mark.
13:06:35 <nmessenger> oh, simple terms, oops
13:06:39 <tarantoga> tibbe: wah, thanks
13:06:54 <nornagon> @undo do { x <- Just 3; return x }
13:06:55 <lambdabot> Just 3 >>= \ x -> return x
13:06:57 <Vq^> Laney: the last expression can't bind a value
13:07:10 <Laney> ah yes, the last action has to do something, right?
13:07:10 <nmessenger> '<-' "extracts" the value from the monad, but something has to be put back into it, via return or some monadic function.
13:07:14 <nornagon> @undo do { x <- Just 3; return 1 }
13:07:14 <lambdabot> Just 3 >>= \ x -> return 1
13:07:17 <kombinator> dcoutts_: ok, thanks, I'll try to code the thing tomorrow, I'll let you know if it works!
13:07:19 <Vq^> Laney: correct
13:07:20 <Lemmih> Is Bit Connor on IRC?
13:07:39 <Lemmih> Anyone know his handle?
13:07:43 <sjanssen_> Lemmih: as yip, I believe
13:07:46 <sjanssen_> @seen yip
13:07:47 <lambdabot> yip is in #darcs, #haskell, #ghc and #happs. I last heard yip speak 4h 23m 34s ago.
13:08:04 <sjanssen_> Lemmih: Bit Connor is the gameboy emulator guy, right?
13:08:29 <nmessenger> Just 3 >>= (\x -> return x) = Just 3 >>= return = (>>=) (Just 3) (return)
13:08:33 <Pastorn> given "type State = (Position, Angle)", will I have trouble implementing the State monad? (disregarding my own confusion)
13:08:34 <dcoutts_> kombinator, ok :-) one thing to watch out for, the onMarkSet tells you about changes to *all* marks, not just the one you're interested in. So you'll have to filter yourself. In future I think we could bind it such that we can select particular marks to watch (using the signal 'detail' field).
13:08:34 <Lemmih> sjanssen_: Right. I'm currently looking through his code.
13:08:35 <nmessenger> @src Maybe (>>=)
13:08:35 <lambdabot> (Just x) >>= k      = k x
13:08:36 <lambdabot> Nothing  >>= _      = Nothing
13:09:06 <nmessenger> = (\(Just x) k -> k x) (Just 3) (return)
13:09:24 <nmessenger> = return 3
13:09:32 <nmessenger> @src Maybe return
13:09:32 <lambdabot> return              = Just
13:09:36 <nmessenger> = Just 3
13:09:37 <nmessenger> :)
13:09:39 <tarantoga> tibbe: as I understand it, -< and co are no sugar
13:10:16 <Laney> @type return Nothing
13:10:18 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a)
13:10:32 <nmessenger> . @type <type> <classmethod>
13:10:35 <tarantoga> tibbe: it's not simply a haskell function but it's a real addition to the language's syntax
13:10:45 <nmessenger> Maybe is a type, return is a method in the Monad class
13:10:56 <nmessenger> er, @src rather
13:11:08 <nmessenger> . @src <type> <method>
13:11:35 <nmessenger> or simply @src <function>, if it isn't in a class
13:13:25 <Pastorn> @type State.get
13:13:27 <lambdabot> Couldn't find qualified module.
13:13:31 <Pastorn> @type get
13:13:34 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
13:13:46 <nmessenger> @instances MonadState
13:13:47 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
13:13:52 <hpaste>  Laney pasted "I have trouble understanding how the <- in this causes "iteration" over the lists" at http://hpaste.org/737
13:14:02 <Pastorn> nmessenger: stop confusing me
13:14:07 <nmessenger> sorry :)
13:14:15 <Pastorn> this is hard enough as it is
13:14:47 <tibbe> tarantoga, yes, but it can be converted to functions (and is in a preprocessor)
13:14:49 <nmessenger> Laney: in the list monad, "x <- xs" means "x takes each value in turn from xs"
13:14:53 <Pastorn> nmessenger: could you walk me through the type declaration of get?
13:15:03 <Laney> nmessenger, That's just a definition from list?
13:15:16 <nmessenger> Laney: @src [] (>>=)
13:15:21 <nmessenger> @src [] (>>=)
13:15:21 <lambdabot> m >>= k     = foldr ((++) . k) [] m
13:15:28 <nmessenger> scary
13:15:42 <nmessenger> m >>= k = concatMap k m
13:15:44 <Pastorn> ?src State (>>=)
13:15:45 <lambdabot> Source not found. My mind is going. I can feel it.
13:16:07 <nmessenger> Pastorn: that shoulda worked, must not be in the @src db :(
13:16:32 <Pastorn> what does get do?
13:16:35 * wkh just discovered the html combinator libraries
13:16:38 <wkh> pretty!
13:16:39 <Pastorn> fetches the state?
13:16:47 <nmessenger> Pastorn: yep
13:17:07 <tarantoga> tibbe: you're right, there are examples on that page
13:17:12 <Pastorn> how do I declare a type for the State?
13:17:15 <nmessenger> Laney: the 'k' is basically the rest of the do block, it is mapped accross the list, and the results are concatted
13:17:47 <nmessenger> State (typeYouWantToPassAround) intermediateResultType
13:17:53 <zbrown> How would i convert an 'IO Int' to 'Int'?
13:17:58 <nmessenger> return
13:17:58 <Laney> Ah, so it'd be something like xs >>= (\x -> ys >>= (\y -> return (x, y))?
13:18:02 <nmessenger> er, no
13:18:08 <yip_> @seen Lemmih
13:18:09 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 9m 34s ago.
13:18:18 <nmessenger> Laney: precisely
13:18:21 <tarantoga> zbrown: you run the action
13:18:24 <Lemmih> Hi yip_.
13:18:28 <zbrown> tarantoga: umm what?
13:18:36 * zbrown is confused :
13:18:37 <Pastorn> >sequence_ [a <- 14 :: Int, return a]
13:18:40 <Pastorn> > sequence_ [a <- 14 :: Int, return a]
13:18:41 <lambdabot>  Parse error
13:18:55 <Pastorn> > sequence_ [a <- (14 :: Int), return a]
13:18:56 <lambdabot>  Parse error
13:18:59 <yip> Lemmih: hey, you rang?
13:18:59 <tarantoga> zbrown: a value of type IO Int is an action that, if performed, returns an Int
13:19:04 * Pastorn hides in a corner
13:19:07 <zbrown> oh i see
13:20:12 <Lemmih> yip: The code for MachineIO is somewhat broken.
13:20:58 <yip> Lemmih: yeah that would make sense
13:21:30 <tarantoga> zbrown: to perform such an action you have to "connect it to the real world", by using it e.g. in the main function or within another action that is used in main
13:21:33 <Laney> > let xs = [1, 2]; ys = [3, 4] in (xs >>= (\x -> ys >>= (\y -> return (x, y))))
13:21:34 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
13:21:40 <zbrown> tarantoga: oh ok
13:21:46 <yip> Lemmih: what's the problem with it?
13:22:43 <tarantoga> zbrown: main itself is an action, too. it has type IO ()
13:23:50 <tibbe> how to set ghci to use -farrows when it has already been started?
13:23:51 <zbrown> hmmm
13:23:57 <tibbe> also can I put something on the top of my .hs file so ghci will use it automatically?
13:24:03 <xerox> tibbe: :set -farrows
13:24:09 <tibbe> thanks
13:25:50 <zbrown> tarantoga: is there a preferred manner in which to generate Random numbres given a range ?
13:27:25 <nmessenger> tibbe: also in your source file, before *any* code: {-# OPTIONS_GHC -farrows #-}
13:27:37 <augustss> @hoogle random
13:27:38 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
13:27:39 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
13:27:39 <lambdabot> Random :: module
13:28:29 <tarantoga> zbrown: here's an simple example:
13:28:30 <tarantoga> rand :: Int -> IO Int
13:28:31 <tarantoga> rand n = getStdRandom (randomR (0, n))
13:29:16 <pjd> hmm, are there any monad tutorials that start by explaining functors first?
13:29:20 <augustss> tarantoga: but it's better not to do it all in the IO monad.  just grab the generator and the use it
13:29:22 <nmessenger> which = randomRIO (0, n)
13:29:49 <pjd> it seems like an obvious approach, but i can't think of any
13:30:13 <zbrown> tarantoga: hmm ok
13:30:18 <chessguy> pjd, HSOE does that
13:30:23 <nmessenger> pjd: I've been thinking of that recently, 'twould seem simpler.
13:30:41 <tarantoga> zbrown: but listen to augustss and nmessenger
13:30:57 <monochrom> Cales' "monad as container" may do what pjd asks.
13:31:12 <hpaste>  zbrown pasted "trying to use randomR" at http://hpaste.org/738
13:31:16 <pjd> chessguy: that's a bit more than a "monad tutorial" :)
13:31:20 <zbrown> ^^ Thats what I'm working with
13:31:32 <zbrown> trying to make a new 'position' so to speak using the random number generator
13:31:34 <chessguy> pjd, yeah, but his chapter on monads does do that
13:31:36 <zbrown> having a little trouble
13:31:57 <pjd> chessguy: cool;  i still need to get to that :)
13:32:03 <chessguy> pjd, definitely worth doing
13:32:17 <monochrom> http://www.haskell.org/haskellwiki/Monads_as_containers  starts with fmap
13:32:19 <lambdabot> Title: Monads as containers - HaskellWiki
13:32:34 <monochrom> Now also available in russian!
13:32:38 <augustss> zbrown: but as you can see from the type, randomR returns a new generator
13:33:02 <zbrown> hmmm
13:33:11 <zbrown> ok so how would i get the random number then
13:33:18 <zbrown> Sorry lol, I'm still having trouble interpreting the Haskell docs
13:33:25 <qwr> zbrown: you have to thread the random generator state explicitly or implicitly through some monad
13:33:27 <zbrown> i promise i'll stop asking silly questions once i've got it down
13:33:30 <hpaste>  nmessenger annotated "trying to use randomR" with "manual StdGen threading" at http://hpaste.org/738#a1
13:33:43 <augustss> zbrown: you have to somehow thread the generator around.  probably in a state monad
13:34:07 <stefanha> Is it possible to do self-referencing in construction using field labels?  eg. Person { fullname = "John Smith", firstName = head (words (fullname *SELF*)) }
13:34:07 <zbrown> augustss: oh ok
13:34:08 <monochrom> http://www.vex.net/~trebla/haskell/random.xhtml  is one optional for zbrown
13:34:14 <zbrown> nmessenger: oh... i think i understand now
13:34:22 <eamelink> [a, b, c] -> [(a,a), (a,b), (a,c), (b,a), (b, b), (b, c), (c, a), (c, b), (c,c)]       <=== How do I achieve that? Making a matrix from a vector... I just can't find an easy way :P
13:34:50 <tibbe_> what's the correct way to put compiler flags in a .hs file?
13:34:52 <nmessenger> you can use do { gen <- newStdGen; print (mosqMove (1,2) gen) } for example to get a StdGen
13:35:12 <chessguy> stefanha, why would you want to do that in a particular instance of Person?
13:35:15 <TSC> > [(x,y) | x <- [a,b,c], y <- [a,b,c]]
13:35:16 <lambdabot>   Not in scope: `c'
13:35:17 <ClaudiusMaximus> > let l = "abc" in [ (x, y) | x <- l, y <- l ]
13:35:18 <lambdabot>  [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c',...
13:35:23 <TSC> Bah (:
13:36:01 <stefanha> chessguy: sorry, stupid example.  Basically, I want to avoid recalculating the same value multiple times.
13:36:13 <augustss> monochrom: I notice that the page you linked to says "to do" on the state monad part :)
13:36:16 <pjd> monochrom: man, how did i miss that
13:36:18 <nmessenger> also with an explicit seed: (mkStdGen 42) will give you a StdGen without the IO
13:36:21 <eamelink> Thanks
13:36:30 <eamelink> That's some inspiration :)
13:36:30 <stefanha> chessguy: So I have the actual value, and a few common calculations as fields that lazy evaluation will only compute when used.
13:36:32 <chessguy> stefanha, what you want is firstName :: Person -> String, firstName = head . words . fullname
13:36:43 <zbrown> nmessenger: doesn't seem to like that code
13:36:57 <zbrown> hmmm
13:37:05 <monochrom> The state monad way is also available elsewhere by other authors
13:37:05 <tarantoga> zbrown: you have to change your move function for that
13:37:16 * nmessenger should have tested it, one sec..
13:37:21 <zbrown> tarantoga: im speakin of the edited one
13:37:26 <pjd> monochrom: thanks, the functor stuff must not have registered back when i read it
13:37:27 <eamelink> I love this game
13:37:28 * zbrown is trying to understand it :-D
13:38:15 <tarantoga> ah, missed that
13:38:53 <monochrom> I hesitate to recommend http://www.haskell.org/haskellwiki/New_monads/MonadRandom because it is a lot of code with little tutorial. But the state monad way is there.  I used to see a more explained one.
13:38:55 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
13:39:15 <stefanha> chessguy: Your example would recompute firstName each time it is used, right?  I would like to compute it zero or once, throughout the entire program, by making it a field label.
13:39:27 <tarantoga> zbrown: I think the last "mosqMove" should be removed
13:39:35 <newsham> ?tell dons @dict needs to support http://members.tripod.com/catchout/dictionary/DICT.html
13:39:36 <lambdabot> Consider it noted.
13:39:47 <hpaste>  nmessenger annotated "trying to use randomR" with "oops, called mosqMove recursively :)" at http://hpaste.org/738#a2
13:39:48 <zbrown> tarantoga: how do you mean?
13:40:14 <nmessenger> diff: http://hpaste.org/738/diff?old=1&new=2
13:40:24 <zbrown> oh nm
13:40:24 <tarantoga> yeah, there :)
13:40:27 <zbrown> i undrstand tarantoga
13:40:34 <zbrown> thanks nmessenger & tarantoga
13:40:35 <zbrown> :)
13:41:03 <nmessenger> glguy++
13:41:15 <nmessenger> (for hpaste)
13:41:25 <nmessenger> for that matter, hpaste++
13:41:41 <tibbe_> I get horrible error messages from my arrows code, anyone inclined to have a look?
13:42:28 <tarantoga> zbrown: and for making mosqMove prettier you can use a state monad, but if you've never heard of such a thing then better wait until you've read something about it
13:42:55 <zbrown> tarantoga: never heard of it ;)
13:42:59 <monochrom> It is getting harder and harder to find stuff on the haskell wiki
13:43:10 <zbrown> tarantoga: this will be a simpler program, its merely a program to be a 'proof of concept'
13:43:18 <tarantoga> zbrown: although for just that single function it's overkill
13:43:23 <monochrom> It is now on the edge of being write-only.
13:43:36 <zbrown> tarantoga: im working for two researchers and there's debate whether to use haskell or a C based Swarm agent
13:43:42 <zbrown> im obviously advocating haskell ;)
13:43:48 <zbrown> but im also learning lol
13:44:44 <dancor> oh i have a question.  i was asking yesterday about what haskell is slow at.  on a related note, why is darcs so much slower than git etc
13:45:23 <dancor> is that just because optimization is hard, or because of something intrinsically slow with haskell
13:45:33 <dancor> like mutable hashes are i guess
13:46:01 <hpaste>  augustss annotated "trying to use randomR" with "Sample working code" at http://hpaste.org/738#a3
13:46:50 <cddar> what would be the best way for invoking another program from my haskell code and catching some textual results of that program? I'm currently using system(from System module) and some file operations. but it's not appropriate i guess. so?
13:46:53 <augustss> dancor: darcs uses a fundamentally different approach than git
13:47:07 <qwr> dancor: Data.HashTable is mutable
13:47:24 <pjd> dancor: darcs's slowness is probably algorithmic more than anything else
13:48:32 <pjd> take mercurial, for example:  it's probably one of the fastest DVCSes around, and it's in *Python*
13:48:42 <tarantoga> cddar: this may help: http://www.cse.unsw.edu.au/~dons/code/newpopen/System/Process/Run.hs
13:48:44 <lambdabot> http://tinyurl.com/2f7j8l
13:49:18 <augustss> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
13:49:20 <lambdabot> http://tinyurl.com/y5fbtr
13:49:25 <pjd> which is because of its algorithms and design choices (Python is significantly slower than Haskell, in general)
13:49:45 <hpaste>  nmessenger annotated "trying to use randomR" with "I was working on it, too :D" at http://hpaste.org/738#a4
13:50:10 <cddar> tarantoga: thanks, it's great. that's what i was looking for.
13:50:46 <Laney> @src mapM
13:50:46 <lambdabot> mapM f as = sequence (map f as)
13:50:51 <Laney> @src liftM
13:50:52 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:51:42 <nmessenger> liftM f m = m >>= (\x -> return (f x))
13:52:00 <Laney> yeah that's the one i had
13:52:10 <nmessenger> "applies the function f to the monad's contents"
13:52:13 <dancor> augustss: so basically haskell encourages you to make your program awesome but slow :)
13:52:44 <nmessenger> it encourages *correct* code before *performant* code.
13:52:46 <augustss> dancor: ummm, darcs started out as c++
13:53:02 <chessguy> ?spell performant
13:53:04 <lambdabot> per formant per-formant perform ant perform-ant performance
13:53:12 <TSC> "fast"
13:53:25 <nmessenger> :)
13:53:48 <Laney> @hoogle Monad m => m (m a) -> m a
13:53:49 <lambdabot> Prelude.id :: a -> a
13:53:49 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
13:53:49 <lambdabot> Prelude.asTypeOf :: a -> a -> a
13:54:00 <augustss> @type join
13:54:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:54:07 <nmessenger> join!
13:54:17 <dancor> but c++ has built-in features to make it impossible to do anything hard and cool :) coding-time optimization
13:54:21 <Laney> It scares me how you can recognise that
13:54:22 <augustss> > join (*) 5
13:54:24 <lambdabot>  25
13:55:30 <Saizan> why don't we use OOP notation for records' fields? it would save us name clashes with other functions
13:55:38 <augustss> Laney: join is a fundamental monad operation.  you could say it's *the* fundamental one, if you already know it's a functor
13:55:53 <Laney> augustss, Now there's a word I don't recognise :)
13:56:06 <nmessenger> m >> k = join (liftM k m)
13:56:14 <augustss> Saizan: because . was taken for function composition :(
13:56:24 <chessguy> hmm, wouldn't >>= be more fundamental, since it can be written in terms of >>
13:56:28 <nmessenger> A functor is just something with a "liftM" and nothing else, it's usually called "fmap"
13:56:38 <Eelis> Saizan: i agree. i hate having to name my fields foo_bar for a field type foo if bar is already used elsewhere
13:56:55 <Eelis> s/field type/data type/
13:57:01 <nmessenger> oops, I meant (>>=) in the above code
13:57:02 <Laney> I'm just trying to puzzle through my lecture notes from this and last week (basically trying to understand monads) - http://www.cs.nott.ac.uk/~gmh/monads
13:57:06 <augustss> Eelis: of, but the unique names is a different matter from how the record selection notation looks
13:57:22 <Saizan> augustss: mmh i see, not that . is not yet overloaded as module separator
13:57:55 <augustss> Saizan: yes, it is.  and that barely works
13:58:48 <Saizan> uhm, we could go perlish with obj->field :D
13:58:49 <augustss> Saizan: I think . for record selection would be great
13:59:36 <augustss> And maybe  as composition
14:00:12 <Saizan> i don't see that
14:00:29 <Botje> let (-->) = flip ($)
14:00:35 <Botje> there's your operator :)
14:00:45 <augustss> At work we use !
14:00:48 <nmessenger> @src (->) (>>>)
14:00:49 <lambdabot> f >>> g = g . f
14:01:19 <augustss> ! reminds people of Excel
14:04:02 <nmessenger> :-> is such a mischievous constructor
14:04:44 <chessguy> :k Monad
14:04:47 <lambdabot> Class `Monad' used as a type
14:04:50 <chessguy> :k State
14:04:52 <lambdabot> * -> * -> *
14:04:59 <chessguy> :k State Int
14:05:01 <lambdabot> * -> *
14:05:12 <nmessenger> @type return
14:05:15 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:05:22 <nmessenger> ^^ you see there that Monads are (* -> *)
14:05:25 <chessguy> :k State Tree
14:05:27 <lambdabot>     `Tree' is not applied to enough type arguments
14:05:27 <lambdabot>     Expected kind `*', but `Tree' has kind `* -> *'
14:05:48 <nmessenger> :k State (Tree Int)
14:05:50 <lambdabot> * -> *
14:06:06 <augustss> Hmmm, I think :k Monad should work
14:06:14 <augustss> classes have kinds
14:06:28 <chessguy> so what's the second * in * -> * -> *
14:06:29 <nmessenger> augustss: what about MPTCs?  which param would it show?
14:06:53 <nmessenger> :k State (Tree Int) Bool
14:06:55 <lambdabot> *
14:07:08 <nmessenger> @unmtl State (Tree Int) Bool
14:07:08 <lambdabot> Tree Int -> (Bool, Tree Int)
14:07:09 <chessguy> oh, the return type
14:07:09 <augustss> nmessenger: all of them, with -> between them
14:07:54 <chessguy> ?vera MPTC
14:07:55 <lambdabot> No match for "MPTC".
14:08:01 <chessguy> boo!
14:08:03 <nmessenger> multi parameter typeclasses
14:08:08 <augustss> the best way would probably be to say that a class has a different result kind
14:08:25 <nmessenger> but classes aren't types!  types have kinds!
14:08:41 <chessguy> ?instances Arrow
14:08:42 <lambdabot> (->), Kleisli m
14:08:51 <chessguy> :k (->)
14:08:53 <lambdabot> ?? -> ? -> *
14:09:05 <chessguy> what do those ?? and ?'s mean?
14:09:14 <nmessenger> CRAZY STUFF!
14:09:21 <dmhouse> It's something to do with unboxed types.
14:09:50 <nmessenger> @vera+ MPTC multiparameter typeclass
14:09:52 <lambdabot> No match for "MPTC".
14:09:53 <lambdabot> No match for "multiparameter".
14:09:53 <lambdabot> No match for "typeclass".
14:09:56 <nmessenger> :)
14:10:08 <chessguy> heh
14:10:16 <chessguy> @vera+
14:10:32 <chessguy> ooook
14:10:42 <chessguy> @bot -- did i break it?
14:10:42 <lambdabot> :)
14:10:47 <chessguy> whew
14:11:25 <nmessenger> @kind Kleisli IO
14:11:28 <lambdabot> * -> * -> *
14:11:56 <nmessenger> @unmtl Kleisli IO String ()
14:11:56 <lambdabot> err: Unknown MTL(2)
14:12:31 <nmessenger> I guess @unmtl does do Arrows :D
14:12:40 <chessguy> ?hoogle Kleisli
14:12:40 <lambdabot> Control.Arrow.Kleisli :: a -> m b -> Kleisli m a b
14:12:41 <lambdabot> Control.Arrow.Kleisli :: newtype Kleisli m a b
14:12:41 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
14:12:46 <nmessenger> = String -> IO () -- i.e. putStr's type
14:13:45 <nmessenger> doesn't*
14:14:05 <nmessenger> makes sense, "Monad template library"
14:14:20 <chessguy> :)
14:14:36 <Laney> @unmtl StateT
14:14:37 <lambdabot> err: No applications
14:14:51 <chessguy> nmessenger, how long have you been programming in haskell?
14:14:53 <Laney> @kind StateT
14:14:54 <hpaste>  dmhouse pasted "subkinding" at http://hpaste.org/740
14:14:55 <lambdabot> * -> (* -> *) -> * -> *
14:15:00 <dmhouse> chessguy: ^^
14:15:07 <nmessenger> chessguy: two months-ish
14:15:12 <chessguy> dmhouse, ?
14:15:18 <yip> will ghc decide on it's own to inline functions?
14:15:21 <chessguy> oh
14:15:34 <dmhouse> chessguy: you just asked about the ? and ?? in kinds, see that paste.
14:15:42 <chessguy> umm, ok
14:16:57 <chessguy> nmessenger, did you have prior FP experience?
14:17:01 <nmessenger> nope
14:17:07 <nmessenger> @kind (# Int, Char #) -> Bool -- so this doesn't kind?
14:17:09 <lambdabot>     Kind mis-match
14:17:09 <lambdabot>     Expected kind `??', but `(# Int, Char #)' has kind `(#)'
14:17:13 <nmessenger> :D
14:19:08 <nmessenger> just a hobbyist with nothing else to do.
14:19:35 <user317> does anyone know how to checkout an older version of 1 file in darcs?
14:19:50 <dmhouse> user317: tried darcs get --help?
14:21:04 <user317> dmhouse: darcs get --partial, but it doesnt tell you how to specify the version of the file
14:22:44 <augustss> user317: as far as I know you can just get an old version of a single file.  changes come in change sets that will be undone atomically
14:22:53 <augustss> but i could be wrong
14:22:54 <nmessenger> actually I've been on #haskell for two months-ish, I've noodled around with Haskell for maybe 6mo-1yr.
14:23:01 <user317> how do i get an older version of a single file?
14:23:34 <Laney> All self taught, nmessenger?
14:23:34 <augustss> user317: I'd get a new repo and then revert back in that and extract the single file
14:24:01 <nmessenger> Laney: Haskell?  Yeah.  Programming in general?  Mostly.
14:24:35 <icarroll> @pl (a -> b) -> (a -> c) -> a -> (b,c)
14:24:35 <lambdabot> (line 1, column 4):
14:24:36 <lambdabot> unexpected ">"
14:24:36 <lambdabot> expecting variable, "(", operator or ")"
14:24:49 <nmessenger> . @. pl djinn?
14:24:51 <user317> augustss, how do revert back a single file?\
14:25:16 <nmessenger> @. pl djinn (a -> b) -> (a -> c) -> a -> (b,c)
14:25:16 <lambdabot> f = liftM2 (,)
14:25:27 <icarroll> nmessenger: thx
14:26:00 <icarroll> is there a better way to describe that operation than "liftM2 (,)"?
14:26:34 <nmessenger> > liftM2 (,) (+1) (*3) 4 -- just to verify it works
14:26:35 <lambdabot>  (5,12)
14:26:36 <fons> hi all
14:26:46 <Vq^> hello fons
14:26:58 <fons> is there a way to see what part of the code generates a stack overflow in ghc?
14:27:04 <fons> ghci
14:27:18 <fons> in what function at least
14:27:30 <augustss> user317: I don't think you can revert a single file.  Do a 'darcs get --to-patch=...' to the appropraie point and grab the file from that new repo.
14:27:39 <fons> hi Vq^
14:27:57 <nmessenger> icarroll: the simple way is good: \f g x -> (f x, g x)
14:28:22 <nmessenger> matter of taste
14:28:37 <icarroll> I want to give it a name (preferrably an operator). Any suggestions?
14:29:00 <nmessenger> @src (->) (***)
14:29:00 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
14:29:08 <nmessenger> er...
14:29:11 <nmessenger> @src (->) (&&&)
14:29:11 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:29:16 <nmessenger> yeah, &&&
14:29:27 <nmessenger> > ((+1) &&& (*3)) 4
14:29:29 <lambdabot>  (5,12)
14:29:38 <icarroll> spiffy, thanks
14:29:40 <icarroll> nmessenger++
14:29:49 <nmessenger> @index (&&&)
14:29:49 <lambdabot> Control.Arrow
14:30:45 <fons> > sequence [(+1),(*3)] 4
14:30:51 * nmessenger hugs the libs
14:31:23 <nmessenger> > Control.Monad.sequence [(+1),(*3)] 4 -- darned bug
14:31:25 <lambdabot>  [5,12]
14:31:27 <augustss> @src (&&&)
14:31:28 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
14:31:49 <fons> thanks nmessenger
14:31:56 <nmessenger> "split into a pair, then do f *** g"
14:32:12 <dmhouse> > sequence [(+1), (*3)] 4
14:32:23 <dmhouse> nmessenger: what's the bug?
14:32:32 <nmessenger> no error message
14:32:38 <dmhouse> Why's it an error?
14:32:47 <augustss> because LB is broken
14:32:47 <nmessenger> ambiguous name
14:32:54 <dmhouse> ?index sequence
14:32:54 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:33:14 <Saizan> ?hoogle sequence
14:33:14 <augustss> but they are all the same
14:33:15 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
14:33:15 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
14:33:15 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
14:33:20 <fons> Prelude should be assumed if there's a clash I guess
14:33:32 <augustss> and there's no real clash
14:33:35 <Saizan> no there's the Data.Traversable one
14:33:43 <augustss> oh, bother
14:33:52 <nmessenger> @type Data.Traversable.sequence
14:33:54 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Traversable t, Monad m) => t (m a) -> m (t a)
14:34:01 <augustss> I see
14:34:29 <nmessenger> a generalization over traversables instead of lists?
14:34:42 <augustss> then I don't think Data.Traversable should be in scope
14:34:50 <Saizan> it should be qualified
14:34:53 <nmessenger> @where imports
14:34:53 <lambdabot> I know nothing about imports.
14:35:11 <augustss> right
14:35:32 <augustss> @src second
14:35:33 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:36:35 <nmessenger> @src (->) second
14:36:35 <lambdabot> second f = id *** f
14:36:36 <fons> hahah, I like lambdabots errors
14:36:58 <Saizan> ?src Arrow
14:36:59 <lambdabot> class Arrow a where
14:37:00 <lambdabot>     arr, pure   :: (b -> c) -> a b c
14:37:00 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
14:37:00 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
14:37:00 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
14:37:01 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
14:37:03 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
14:37:11 <Saizan> :O
14:37:31 <Saizan> what's the diffrence between arr and pure?
14:37:37 <nmessenger> none
14:37:49 <Saizan> ah
14:38:00 <nmessenger> except arr sounds like a pirate :)
14:38:10 <nmessenger> @quote pirate
14:38:11 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
14:39:04 <wkh> :t [1 2]
14:39:07 <lambdabot> forall t. (Num (Integer -> t)) => [t]
14:39:13 <wkh> what does that expression mean?
14:39:16 <wkh> is [1 2] a list? a tuple?
14:39:25 <glguy> it means that if 1 is a function
14:39:26 <nmessenger> you're applying the number '2' to the function '1'
14:39:27 <glguy> then that will work
14:39:41 <monochrom> [1 2] is nobody.
14:39:49 <wkh> :t [+ 1 2]
14:39:52 <lambdabot> forall a. (Num (Integer -> a), Num a) => [a -> a]
14:39:55 <chessguy> [1 2] is just bad syntax
14:39:55 <monochrom> [1,2] is a list
14:40:07 <glguy> chessguy: [1 2] could be made to compile
14:40:11 <monochrom> (1,2) is a tuple
14:40:15 <glguy> with haskell98
14:40:19 <chessguy> glguy, obviously i'm talking about in general
14:40:19 <wkh> i know the syntax for tuples and lists
14:40:28 <wkh> i want a way of writing out list data without needing comments
14:40:33 <wkh> er, commas
14:40:35 <monochrom> there
14:40:36 <monochrom> is
14:40:37 <monochrom> none
14:40:45 <glguy> there is:
14:40:49 <glguy> > words "1 2 3 4"
14:40:50 <lambdabot>  ["1","2","3","4"]
14:41:00 <nmessenger> also (1 : 2 : 3 : 4 :[])
14:41:01 <fons> > let a = "sds"
14:41:01 <lambdabot>  Parse error
14:41:12 <monochrom> why do people want strange things?
14:41:13 <glguy> > map read $ words "1 2 3 4 5" :: [Int]
14:41:13 <wkh> so what does [+ 1 2] mean?
14:41:14 <fons> uhm, it doesn't accept lets
14:41:14 <lambdabot>  [1,2,3,4,5]
14:41:21 <wkh> http://www.mail-archive.com/haskell@haskell.org/msg18396.html
14:41:22 <lambdabot> Title: [Haskell] Haskell as a markup language
14:41:25 <wkh> i liked how they did the syntax there
14:41:26 <monochrom> [+ 1 2] is nobody.
14:41:45 <nmessenger> wkh: a list containing the section (+ 1 2), where 1 is itself a function
14:41:53 <glguy> fons: all lets (not in a do-block) have a corresponding "in"
14:41:53 <fons> monochrom, well strange things in Haskell ... common thing I guess
14:41:56 <wkh> [title "blah" somedata "whatever"] is nice and i wondered how they produced it
14:41:59 <nmessenger> like (+ f 2)
14:42:09 <wkh> you don't
14:42:11 <wkh> have to be
14:42:12 <wkh> so fucking
14:42:14 <wkh> condescending.
14:42:28 <fons> glguy, ghci admits it
14:42:43 <fons> glguy, and given that we are using lambdabot as an interpreter
14:42:50 <Saizan> ghci is in a kind of do-block
14:42:51 <glguy> fons: that is a ghci specific behavior, not haskell specific
14:43:10 <fons> glguy, where did I say I was refering to standard haskell?
14:43:14 <fons> :)
14:43:16 <monochrom> [title "blah" somedata "whatever"] is not a list with four items.  Rather, it is a list with just one item, and that item is obtained by calling the function "title" with three parameters.
14:43:32 <glguy> fons: lambdabot used to allow @let this = that
14:43:38 <glguy> I think it's broken at the moment
14:43:44 <nmessenger> @let x = "borked :("
14:43:47 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:43:58 <glguy> @undefine
14:43:58 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:44:09 <monochrom> It is akin to [const 1 2]
14:44:15 <cddar> any chance that it might be [title "blah", somedata "whatever"]?
14:44:15 <monochrom> > [const 1 2]
14:44:17 <lambdabot>  [1]
14:44:25 <monochrom> No chance.
14:44:41 * fons tries asking the question again, any clue about how to detect stack overflows in ghci?
14:44:48 <glguy> > let title _ _ _ = 1 in [title "block" undefined 3]
14:44:49 <lambdabot>  [1]
14:45:31 <dfranke> somebody should add hoogle-integration to emacs haskell-mode.
14:45:43 <dfranke> That somebody would be me if I weren't swamped.
14:45:53 <fons> dfranke, name completion would be great as well
14:46:23 <fons> with the tab as in bash
14:47:01 <Saizan> there's no way to write a composition operator what works with a RHS function with N parameters, right?
14:47:12 <cddar> apparently wxhaskell uses something like that: [text := "Quit", on command := close f]  (however "," means alot)
14:47:23 <dfranke> fons: Slime has that but I tend not to use it.
14:47:35 <wkh> how does that example code allow for apparently an arbitrary number of parameters?
14:47:38 <fons> Slime?
14:47:39 <glguy> Saizan: how do you want to specify the number of parameters?
14:47:46 <fons> let me google for it ..
14:47:47 <dfranke> fons: emacs mode for Common Lisp.
14:47:59 <dfranke> and haskell has shorter identifiers than CL does.
14:48:05 <Saizan> glguy: just by changing the function :)
14:48:16 <cddar> wkh, arbitrary?
14:48:20 <fons> I love emacs vhdl mode
14:48:27 <monochrom> I don't think it does, wkh.  Could you show an example?
14:48:42 <dfranke> I've never tried that one, but I surely do not love VHDL.
14:48:50 <wkh> in the snippet [title "Haskell" longdash "HaskellWiki"], it appears that they could have added any more strings if they wanted to and it would have rendered/concatenated together appropriately
14:48:54 <glguy> > printf "%s %d" "seemingly arbitrary?" (4 :: Int) :: String
14:48:55 <lambdabot>  "seemingly arbitrary? 4"
14:49:01 <fons> dfranke, verilog?
14:49:15 <dfranke> fons: I've heard it's better but I've never used it.  I'm not an EE.
14:49:15 <glguy> > printf "%d %d %d %d" (1::Int) (2::Int) (3::Int) (4:: Int) :: String
14:49:17 <lambdabot>  "1 2 3 4"
14:49:23 <monochrom> I think that's false.
14:49:32 <glguy> > printf "fewer?" :: String
14:49:33 <lambdabot>  "fewer?"
14:49:35 <fons> dfranke, neither am I, but unfortunately I have work with it
14:50:01 <fons> dfranke, hopefully not anymore after next week, once I'm done with my thesis
14:50:18 <Saizan> let f:: a -> a -> b, g:: a -> a -> a -> b, h -> b -> c,  h .:. f :: a -> a -> c, h .:. g :: a -> a -> a -> c
14:50:33 <monochrom> OK I see.  There is [title "Haskell" longdash "HaskellWiki"], then later there is [title "titleline"].  The technique is advanced.  It is advanced hackery of type classes.
14:50:36 <Saizan> glguy: oh, how is that done?
14:50:44 <glguy> typeclasses
14:50:49 <glguy> :t printf
14:50:52 <lambdabot> forall r. (PrintfType r) => String -> r
14:51:01 <dfranke> fons: If I had been required to take more than one hardware course it probably would have been worthwhile to write my own HDL.
14:51:17 <dfranke> I hated VHDL that much.
14:51:35 <Saizan> ?hoogle printf
14:51:36 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
14:51:37 <lambdabot> Text.Printf :: module
14:51:37 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
14:51:42 <monochrom> However, I must emphasize that, [title "Haskell" longdash "HaskellWiki"] or [title "titleline"], it is a list with just one single item.  Only the function "title" is variadic.
14:52:12 <chessguy> variadic. nice word
14:52:19 <dfranke> its typesystem is just on crack.
14:52:39 <augustss> it's magic :)
14:52:52 <fons> dfranke, well, if I succeed the hardware course of my college won't use VHDL anyomore :)
14:53:08 <dfranke> why the hell are a bit and a boolean two types that I can't even cast to each other?
14:53:15 <augustss> dfranke: writing your own HDL is a bit of work
14:53:28 <fons> I'd like to think the students are goona be happier with my HDL
14:53:42 <monochrom> I recently have had some glimpse of the variadic technique.  This was 5 years after I started learning Haskell.  Please take note of that.
14:53:52 <fons> (if they finally use it as they told me)
14:54:00 <dfranke> augustss: I'd implement it as a translator targeting VHDL so that I woulldn't have to deal with the low-level stuff.
14:54:07 * glguy notes that varadic functions are hard for monochrome
14:54:17 <glguy> :-p
14:54:41 <augustss> dfranke: even so.  the one i wrote translated to Verilog.  writing a good language still takes time
14:54:50 <monochrom> dfranke: because it is ambiguous whether 0 should be mapped to True or False.
14:55:02 <glguy> hmm
14:55:18 <glguy> > toEnum 0 :: Bool
14:55:19 <lambdabot>  False
14:55:27 <glguy> > toEnum 1 :: Bool
14:55:28 <lambdabot>  True
14:55:38 <augustss> monochrom: you can make conventions about bit level translations that make these things work out very nicely.  that's what we did in Bluespec
14:56:07 <dfranke> augustss: that I know.  I've implemented two languages.  One was my design, the other wasn't.  The one I designed only required twice as much code, but took six months rather than one day.
14:57:10 <dfranke> well, three languages if you count the toy one that we used in the compilers class I took.
14:57:11 <augustss> dfranke: given more spare time i'd do another HDL
14:57:15 <monochrom> I have seen circuit designs in which 0 is true.
14:57:43 <monochrom> Worse, I have seen circuit designs in which one part uses 0 for true and another part uses 0 for false.
14:57:54 <dfranke> monochrom: sure, that's typical.
14:57:58 <augustss> monochrom: if you want 0 to be true, you should be able to do that.  i don't think that should be default, though :)
14:59:13 <augustss> monochrom: i did a small design that used 0 and 1 for true alternately through every gate.  so i used two different kinds of booleans to keep it sane
14:59:16 <monochrom> I think it is clear that given this context my point is you can't expect a circuit modeling language to avail one single coercion operator that automatically guess what you mean.
14:59:51 <glguy> monochrom: but *perl* could do it!
15:00:07 <dfranke> though, more to the point, hardware knows about neither 1 and 0 nor true and false, just high and low.  In some situations it's appropriate for 0 to be high and 1 to be low.  But since 1 and true are both logical concepts, not physical ones, there's no reason there shouldn't be a consistent mapping between them.
15:00:40 <monochrom> Right, the hardware doesn't attach any meaning.
15:01:00 <monochrom> But the modeling language is there to let some perverted designer to attach a perverted meaning.
15:01:29 <cddar> (if 0 1 2) -> 1, lisp does it too? (by the way, let 0 == True = True in 0 == True is ironic)
15:01:49 <monochrom> You could define the language to outlaw perversion altogether, of course.  Some "real world" people will not like it.
15:02:53 <augustss> "A real programmer can write Fortan code in any language"
15:04:27 <monochrom> > let 1 = 4+5 in 4+5
15:04:28 <lambdabot>  9
15:04:36 <monochrom> cddar: have you seen that? :)
15:04:45 <dfranke> ooh, weird.  That's legal?
15:04:59 <dfranke> > let 2 = 3 in 2+2
15:05:01 <lambdabot>  4
15:05:06 <dfranke> hrmm.
15:05:14 * monochrom grins
15:05:20 <dfranke> > let 4 = 5 in 2+2
15:05:22 <lambdabot>  4
15:05:51 <dfranke> that looks to me like a bug.
15:06:03 <monochrom> how do you propose to fix it?
15:06:08 <Igloo> It's not
15:06:18 <augustss> > let 2+2 = 5 in 2+2
15:06:20 <Igloo> 4 there is a pattern, and laziness means the match is never checked
15:06:20 <lambdabot>  5
15:08:13 <lupo__> > let 4 = 5 in 4
15:08:15 <lambdabot>  4
15:08:24 <lupo__> > let 2+2 = 5 in 4
15:08:26 <lambdabot>  4
15:08:35 <lupo__> yeah, that's absolutely logical.
15:08:44 <Laney> > let 2<0 in 9
15:08:45 <lambdabot>  Parse error
15:09:26 <lupo__> i mean ...
15:09:33 <cjay> > let False = True in 1 == 2
15:09:34 <lupo__> > let 4 = 10 in "hello kitty"
15:09:36 <lambdabot>  False
15:09:36 <lambdabot>  "hello kitty"
15:09:40 <monochrom> you mean you were sarcastic
15:09:43 <augustss> Haskell has some features that might look glance.  But it all makes sense. ;)
15:09:55 <augustss> s/look/look weird/
15:09:56 <wkh> where can i learn about leet typeclass hackery so that i could type something ("customers", ["id" int primary_key auto_increment not_null]...)?
15:10:00 <augustss> urg!
15:10:04 <dons> ?users
15:10:04 <augustss> can't type
15:10:05 <lambdabot> Maximum users seen in #haskell: 332, currently: 307 (92.5%), active: 58 (18.9%)
15:10:26 <monochrom> wkh: http://okmij.org/ftp/Haskell/
15:10:28 <lambdabot> Title: Haskell Programming: Miscellanea
15:10:34 <wkh> hokai.
15:10:39 <dfranke> wkh: I think you'd rather use TH for that.
15:10:53 <wkh> yeah maybe.
15:10:57 <augustss> wkh: hmmm, i think you should learn the low-magic stuff first
15:10:58 <monochrom> The HSXML stuff you saw is from Oleg.  The url I just gave is also of Oleg.
15:11:06 <wkh> yes
15:11:07 <cddar> cjay, let 1 == 2 = True in 1 == 2
15:11:21 <wkh> > let 1==2 = True in 1==2
15:11:22 <lambdabot>  True
15:11:23 <cjay> yes, got it now :)
15:11:29 <wkh> omg hax!
15:12:01 <monochrom> augustss: well, wkh called some of us condescending, so let's just trust wkh knows all the basics and is ready for Oleg.
15:12:04 <TSC> > let 2+2 = 5 in 2+2
15:12:05 <lambdabot>  5
15:12:19 <monochrom> (lest we will be called condescending again)
15:13:05 <augustss> hmmm, ok.  i'm still working mostly with the low-magic stuff myself and learning new things.
15:13:59 <wkh> monochrom: i called you condescending because you were exasperated that i dared to ask how something interesting i saw worked
15:14:08 <sorear> hello.
15:14:50 <augustss> Hej, sorear!
15:14:59 <edwinb> evening
15:15:45 <dons> so guys, how are we going to change the world today? :-)
15:15:46 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
15:16:13 <augustss> dons: we could write another monad tutorial
15:16:22 <monochrom> I was not exasperated.  I was not condescending either.  I was just making emphasis.
15:16:38 <sorear> dons: I'm writing a JIT optimiser for york haskell *muahaha*
15:17:21 <dons> augustss: heh
15:17:54 <dons> augustss: how about that hbc src? could i run it on the amd64 yet?
15:17:55 <augustss> sorear: there is a JIT?
15:18:33 <augustss> dons: patience, I have a long a difficult trek ahead of me (to bring our cat to London) :)
15:19:21 <sorear> augustss: not yet!
15:21:02 <edwinb> I've just been to the Edinburgh Linux user group. They seemed to be proud at being the sickest LUG on the planet.e
15:21:10 <monochrom> I now think Haskell is too popular.
15:21:17 <edwinb> on account of having the authors of Intercal and Whitespace compilers int he same room
15:21:22 <dons> hmm, is this true what I see, our very own bos changed 1.4% of the linux kernel in the last year? http://lwn.net/Articles/222773/
15:21:23 <lambdabot> Title: LWN: Who wrote 2.6.20?
15:21:28 <dons> grep for Bryan O'Sullivan
15:21:30 <LPhas> anyone here knows a bit of GHC API?
15:22:10 <monochrom> I know a very little bit of GHC API.
15:23:38 <sorear> LPhas: don't use the ghc api
15:23:50 <sorear> LPhas: treat the ghc api like UNIX syscalls
15:24:12 <sorear> LPhas: it's there if you need it but you *really* ought to be using a higher level library
15:24:29 <sorear> @where hs-plugins <-- probably what you're looking for
15:24:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
15:24:33 <LPhas> sorear, ok, you have suggestion about a way to calculate the dependency graph of a module witouth it?
15:24:52 <sorear> LPhas: ok, that's a legitimate use :)
15:24:53 <LPhas> if you have, i'il love you forever
15:24:59 <LPhas> d'uh
15:25:01 <monochrom> depanal is already very high level
15:25:04 <dons> you could use ghc -M and then parse the makefile output
15:25:12 <sorear> LPhas: IIRC YHC-API exists :)
15:26:40 <monochrom> http://www.haskell.org/haskellwiki/GHC/As_a_library  has information
15:26:42 <lambdabot> Title: GHC/As a library - HaskellWiki
15:26:55 <LPhas> dons, seems not a very good solution
15:27:23 <LPhas> monochrom, depanal works fine, but returns me a "flat" list of dependencies, not a graph
15:27:30 <monochrom> It doesn't have depanal.  But don't worry.  Do everything the page says, exception: don't call "load", call "depanal" in its place.  Then you're set.
15:27:32 <dons> i'd use ghc-api
15:27:52 <dons> ping Lemmih, he's used it quite a bit
15:27:53 <monochrom> OH!  You want a graph data structure?
15:28:29 <LPhas> monochrom, yes, i want to parallelize compilation
15:28:37 <LPhas> i need more than a flat list
15:28:40 <sorear> LPhas: and when you're done, write a lib (it's not hard in Haskell) so I can tell the next guy not to use the ghcapi.
15:28:49 <monochrom> Though the list is flat, each item is a record with a field pointing to other modules.  It has all the information for building a graph.
15:29:03 <sorear> LPhas: so highlevel, you want ghc -j16 ?
15:29:22 <LPhas> sorear, ?
15:29:53 <sorear> LPhas: in GNU Make make -j16 means "run 16 jobs at once", good for dons' 16 core box.
15:30:04 <LPhas> oh, yes
15:30:07 <LPhas> right
15:30:16 <LPhas> but i want it distributed over network eheh
15:30:46 <sorear> distghc? :)
15:30:50 <LPhas> right
15:31:24 <LPhas> this is why i need a graph
15:31:44 <siti> make a distcc style thing for ghc :)
15:31:44 <LPhas> to calculate "independent sub-graph" that i can distribute
15:31:58 <LPhas> siti, no way, Haskell is different from C
15:32:02 <siti> ok
15:32:22 <LPhas> with C you can preprocess a .c against all .h that includes
15:32:29 <LPhas> the result can be compiled alone
15:32:34 <LPhas> so you don't need dependencies
15:32:39 <siti> true
15:32:42 <LPhas> distcc only wraps gcc
15:32:46 <sorear> LPhas: you can do that with Haskell too
15:32:54 <LPhas> sorear, how?
15:32:55 <sorear> LPhas: ghc --make is NOT the only option
15:33:29 <LPhas> sorear, i lurked the ghc doc but i didn't found anything like that
15:33:31 <sorear> LPhas: once you compile a module, take the MyModule.hi file and put it somewhere it can be found for each other module you compile
15:33:39 <LPhas> eheheheheh
15:33:54 <LPhas> so i need to know the dependencies graph
15:33:56 <sorear> LPhas: you still need to follow dep order, but you don't need to juggle source code
15:34:05 <LPhas> yes, yes of course
15:34:20 <LPhas> otherwise i can't do the whole thing
15:34:37 <LPhas> or i need a shared memory
15:34:47 <LPhas> but, still, i need the dep graph
15:36:01 <monochrom> In ModSummary, I'm wondering what the two fields ms_srcimps and ms_imps are.
15:36:03 <LPhas> monochrom, you say that each item has a field pointing to another
15:36:10 <LPhas> ok
15:36:12 <LPhas> i look
15:37:26 <LPhas> monochrom, yes, found!
15:37:57 <LPhas> now the "only" problem i have is 19Mbytes result of compilation :|
15:38:05 <LPhas> seems that it links half ghc ...
15:38:11 <sorear> exactly
15:38:26 <sorear> you Should only need the deptracer ....
15:38:35 <sorear> is ghc compiled w/ splitobjs
15:38:36 <sorear> ?
15:38:48 <sorear> if not, you'll get the whole think
15:38:53 <LPhas> splitobjs? :P
15:38:59 <LPhas> my ghc version is the standard one
15:39:01 <Gwern> I have a question. I am in an IO monad, using HSH to call shell commands. how can I ignore run $ "foo" raising big nasty error messages and continue down the list?
15:39:22 <sorear> try $ foo
15:39:25 <sorear> @ty try
15:39:28 <lambdabot> Not in scope: `try'
15:39:36 <sorear> @ty IO.try
15:39:38 * Gwern will hoogle it. thanks
15:39:39 <lambdabot> forall a. IO a -> IO (Either IOError a)
15:42:06 <LPhas> monochrom, ms_srcimps returns a [Located ModuleName]
15:42:25 <LPhas> what is the "Located" functor?
15:42:27 <monochrom> ms_imps does too.  I'm wondering why two separate fields.
15:43:16 <monochrom> Located keeps track of source code location e.g.., "line 5 columns 7-15"
15:44:47 <monochrom> This gives you enough information to print out error messages like "at line 5 columns 7-15 you are importing X.Y and I think you're on crack"
15:45:24 <LPhas> monochrom, so me don't need that, thx
15:46:12 <monochrom> Yeah, a simple pattern matching will throw away the location and just extract the ModuleName.
15:46:58 <monochrom> Alternatively use SrcLoc.unLoc :)
15:47:02 <LPhas> the pain is that this gives me the "ModuleName" and not the "ModuleSummary"
15:47:27 <monochrom> Right, the next hurdle is to go through the list again to find its ModSummary.
15:47:35 <LPhas> right
15:47:52 <LPhas> with all these damned FastString :P
15:48:00 <LPhas> this work is painful, man
15:48:48 <sorear> emacs is remarkably snappy with 300kchar lines :)
15:49:07 <monochrom> Hey, topSortModuleGraph may be of interest
15:49:54 <monochrom> Ha, the result of topSortModuleGraph may be much much closer to the data structure you want.
15:51:50 <monochrom> OK, it doesn't solve all problems.
15:54:34 <LPhas> monochrom, i don't know how to unpack the FastString from the ModuleName
15:54:41 <LPhas> and i cant find the Module.hs file:|
15:56:40 <mbishop> "Well, you can certainly post whatever you like, but I will downmod posts that don't include content that's worth reading. Since the text is only (officially) available if you pay for the book, the page you posted is really nothing more than an advertisment for the book."
15:56:42 * mbishop sighs
15:56:45 <mbishop> reddit logic
15:57:05 <monochrom> Don't bother unpacking.  You have one ModuleName n, you have lots of ModSummary's ms, you just want to know: which guy in ms does n allude to?  Use ms_mod_name :: ModSummary -> ModuleName, then use == to search.  It also enjoys >= if you want to use a Data.Map
15:57:24 <LPhas> oh, right
15:57:55 <augustss> mbishop: who said that?
15:58:21 <monochrom> You can also use FastString.unpackFS :: FastString -> String if you really want.
15:58:32 <LPhas> yes i found that
15:58:40 <LPhas> this is not the problem
15:58:53 <mbishop> augustss: "TomP", a guy who replied to my CTM post
15:59:01 <LPhas> the problem was to get a :: ModuleName -> FastString one
15:59:12 <LPhas> i don't know why i can obtain it via Pattern Matching
15:59:31 <monochrom> "newtype ModuleName = Module.ModuleName FastString.FastString"
15:59:35 <augustss> mbishop: not sure i read that thread.  reddit has some morons, for sure
16:00:04 <mbishop> http://programming.reddit.com/info/173h6/comments
16:00:05 <lambdabot> Title: Concepts, Techniques, and Models of Computer Programming (Better known as CTM) ( ...
16:00:09 <monochrom> I have undug much info by using lots of ":i" and ":b" at the ghci prompt. :)
16:00:23 <LPhas> yes, of course i saw it
16:00:37 <LPhas> but
16:00:53 <LPhas> :t Module.ModuleName
16:00:53 <LPhas> <interactive>:1:0:
16:00:54 <LPhas>     Not in scope: data constructor `Module.ModuleName'
16:00:55 <lambdabot> Couldn't find qualified module.
16:00:56 <monochrom> OH!  ModuleName is made abstract, the data constructor is not exported.
16:01:02 <LPhas> eheh :P
16:01:48 <monochrom> For this application it's best to just stick with the == and <= operators of ModuleName.
16:06:51 <zbrown> Is there a random function in which I can set an upper limit for the random number?
16:07:04 <sorear> randomR
16:07:06 <monochrom> > randomsR (1,5)
16:07:07 <lambdabot>   Not in scope: `randomsR'
16:07:07 <zbrown> that is i want to set both a range, and then a ceiling
16:07:22 <monochrom> > randomRs (mkStdGen 42) (1,5)
16:07:23 <lambdabot>  Couldn't match expected type `(a, a)'
16:07:29 <monochrom> Sorry
16:07:52 <monochrom> > randomRs (1,5) (mkStdGen 42)
16:07:52 <zbrown> Basically this: range is x-2 to x+2, then ceiling for x is 16 or something like that
16:07:53 <lambdabot>  [2,2,3,5,2,2,4,2,4,1,1,5,2,4,5,1,3,2,4,2,2,5,3,5,2,5,1,4,4,5,5,1,3,3,2,4,5,3...
16:08:04 <monochrom> BTW 42 is my favourite seed.
16:08:14 <zbrown> monochrom: hitchhiker's guide to the galaxy im sure?
16:08:30 <monochrom> I have never read that book or watched that movie.
16:08:33 <zbrown> oic
16:08:44 <zbrown> monochrom: you understand what i mean though for the ceiling?
16:08:47 <monochrom> But you are  still right.
16:08:56 <ddarius> zbrown: Many people are aware of 42 without reading the book or watching the movie.
16:09:00 <dibblego> ?hoogle a -> Int -> [a]
16:09:01 <zbrown> or is that what randomRs (1,5) (mkStdGen whatever) will do?
16:09:01 <lambdabot> Prelude.replicate :: Int -> a -> [a]
16:09:18 <monochrom> (1,5) means 1,2,3,4,5 are the possibilities
16:09:27 <zbrown> monochrom: ok
16:10:08 <monochrom> I do not entirely understand "x-2 to x+2, then ceiling for x is 16"
16:10:12 <zbrown> ok
16:10:23 <zbrown> monochrom: a creature is moving
16:10:30 <zbrown> it can move no more tahn 2 spaces forward, or two back
16:10:37 <zbrown> but it must stay within the bounds of a room, that is l*w
16:10:50 <monochrom> Is it from (x-2 `min` 16) to (x+2 `min` 16) ?
16:10:53 <zbrown> so (x,y) represents the creatures position and it cannot change those by more than +2 or -2, and it must stay within the bounds of the room
16:11:04 <zbrown> ya
16:11:24 <monochrom> Formal (symbolic) mathematics is so much better than English.
16:11:34 <zbrown> ddarius: i know, but its often a favorite :)
16:11:45 <monochrom> If anything, formal mathematics is at least testable.
16:11:48 <zbrown> monochrom: any hints as to how to write what im talking?
16:12:00 <zbrown> what im speaking of rather
16:12:32 <monochrom> The bounds of the room are: 1 to l along one dimension, and 1 to w along the other?
16:12:37 <zbrown> yes
16:13:19 <monochrom> Along one dimension: (x-2 `max` 1, x+2 `min` l).  Similarly the other dimension.
16:13:50 <dons> hey zbrown. so who's day 2 of haskell coding coming along? :-)
16:14:08 <zbrown> dons: pretty good, making a very basic model
16:14:21 <zbrown> i have to provide 'compelling proof' that haskell is the proper language for our model :)
16:14:45 <monochrom> `max` and `min` are underrated operators.  Not just in haskell, but also human thinking in general.
16:15:00 <zbrown> monochrom: ya i had forgotten they existed :)
16:15:08 <dons> i guess if you can do it in a lot less lines, and have the actual code look like an executable spec in pseudo code, that'd be a good proof?
16:15:20 <dons> let us know if you want help refactoring
16:15:49 <ddarius> Who can forget the join and meet in the lattice of numbers?
16:16:14 <sorear> which one?
16:16:16 <monochrom> No one can forget, if they are taught.  The problem is they are seldom taught.
16:16:33 <zbrown> dons: hehe i think so ;)
16:16:56 <zbrown> monochrom: i first encountered them in self study, but hte first formal course i was taught with them was Discrete Math
16:17:02 <sorear> {lcm,gcd}  {max,min}   {.|.,.&.} ?
16:17:15 <zbrown> dons: really I just need a reason to use haskell over objc/java + swarm
16:17:29 <sorear> that last one burns your eyes? :P
16:17:31 <zbrown> they feel swarm is a good choice, but i don't think it will be as easy to express the mathematical functions in
16:19:02 <dons> so maybe you could show some actual math, and its direct translation into almost identical haskell. that's worked for others, i know.
16:19:09 <monochrom> The result is that usually you say "late penalty: $5*n, but not exceeding $250" or "due date: your birthday, or March 31, whichever one is earlier".
16:19:11 <dons> if they care about the math
16:19:31 <zbrown> dons: i showed them some of that a bit
16:19:36 <LPhas> monochrom, worked! thx a lot! i now have to make a good rappresentation of the graph, but i know where to get infos
16:19:45 <zbrown> dons: they care, or at least one does, being the mathematician
16:20:02 <zbrown> dons: I think really they're concerned that they feel not many use Haskell
16:20:10 <monochrom> If max and min were taught properly like *, people on the street would have no problem with "$5*n min $250" etc.
16:20:21 <monochrom> congrats LPhas
16:20:43 <dons> zbrown: these are academics?
16:20:52 <zbrown> ya
16:20:57 <LPhas> certanly... it's slow
16:21:04 <sorear> YAH! I can parse the Prelude.hbc file
16:21:06 <Cale> max x y = (x + y)/2 + abs (x - y)/2
16:21:13 <zbrown> dons: but the mathematician doesn't program and the biologist works pretty much only in C/Swarm
16:21:14 <monochrom> Damn, what is swarm? :)
16:21:34 <zbrown> http://www.swarm.org/wiki/Main_Page
16:21:36 <monochrom> swarm is biologists favourite programming environment or something?
16:21:37 <lambdabot> Title: Main Page - SwarmWiki
16:21:46 <zbrown> Its a agent-based modeling system
16:21:51 <dons> zbrown: haskell is widely used in academia, and growing rapidly in general. maybe point to the fact that the community is extremely active (this channel along being one of the top 15 on freenode), and use in industry is growing.
16:21:55 <monochrom> thanks
16:22:24 <monochrom> I would think Haskell + Swarm is probably nice.
16:22:26 <zbrown> dons: i think they're just worried that not many others that work on this project (its international) will understand or warm to haskell
16:22:44 <chessguy> dons, did you see the haskell blog entry that got 10,000 unique-ip hits within a few days or something?
16:22:46 <LPhas> may i hask why GHC API is so undocumented and if doc will be written someday?
16:22:47 <dons> i guess your technical arguments will have to be compelling
16:23:12 <dons> chessguy: i know my 'Programming Haskell' articles, which hit digg, got 45k unique ip hits
16:23:16 <hpaste>  Gwern pasted "Wikipedia bot" at http://hpaste.org/741
16:23:21 <dons> for about 3 days in a row
16:23:25 <monochrom> doc will be written some day.  GHC API is rather new.
16:23:38 <zbrown> dons: my main argument was its more convenient to write the mathematical expressions in, the code will be easier to read
16:23:40 <dons> the 'simple unix tools' article had 7k in about 8 hours, before haskell.org crashed ;)
16:23:51 <Gwern> anyone want to take a look at my attempt at a useful bot to do stuff on Wikipedia? I've been working on it for a while, but I can't seem to fix this last error
16:24:01 <monochrom> Also there are only so many Simons.  If they're busy doing implementations, they don't have much time organizing the API.
16:24:03 <dons> zbrown: right. did you see the 'reasons to use haskell as a mathematician' link?
16:24:07 <iron33> zbrown : I think the nature of the project and not the language used will be the biggest factor in determining how many people are interesting in the project Darcs being a great example of people learning haskell just to participate in a really cool source control tool
16:24:08 <dons> that might have some other good points
16:24:13 <zbrown> dons: ya, i just haven't menitioned it completly
16:24:20 <chessguy> http://blogs.nubgames.com/code/?p=18 -- "When I wrote my last post about my experiences learning Haskell, I wrote for the surprisingly large audience of one hundred or so people who subscribe to my feed.  Then I got hit from ten-thousand unique IPs in the first twenty-four hours."
16:24:21 <lambdabot> Title: Nub Games  Writing a Simple Search Engine in Haskell: Part 0 &#8212; Introducti ...
16:24:33 <dons> chessguy: ah yes.
16:24:40 <dons> well, nubgames writes good articles :-)
16:24:43 <Gwern> chessguy: you have experience with IO stuff in haskell! please look at my bot
16:24:44 <dons> and timely ones.
16:24:51 <Gwern> http://hpaste.org/741 <-- linky
16:24:54 <zbrown> iron33: dons: they were also concerned with performance
16:25:05 <chessguy> Gwern, i was quoting someone else
16:25:16 <Gwern> oh. darn. :( sorry then
16:25:19 <dons> oh, just wave them at the shootout, performance should be great. profiling would rapidly reveal any area that needs tuning.
16:25:22 <dons> ?shootout
16:25:23 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:25:25 <chessguy> i'll look, but i'm a n00b
16:25:32 <dons> zbrown: i mean, they're using Java??
16:25:44 <zbrown> dons: mmmm mostly the C side of swarm
16:25:48 <zbrown> rather objc
16:25:56 <zbrown> there's a java implementation and a objc implementation
16:26:06 * Gwern ponders "Couldn't match expected type `IO t' against inferred type `[IO ()]'"
16:26:11 <dons> i'd not be concerned then about performance.
16:26:20 <dons> zbrown: you can use the shootout numbers to back that up
16:26:25 <sorear> Gwern: you're missing a sequence
16:26:29 <zbrown> dons: ok
16:26:35 <chessguy> Gwern, what line does it point to?
16:26:41 <sorear> Gwern: or eqv, you are using map etc instead of mapM
16:26:42 <dons> native compiled haskell performs very well, since it can do optimisations just not possible in languages like JAva
16:26:43 <sorear> etc
16:26:46 <Gwern> chessguy: the line mentioned in my comments
16:26:50 <zbrown> dons: they're gonna run the simulation on a cluster so i doubt it will take too much of  ahit and if it comes down to it i can convert the code from haskell to c
16:26:57 <Gwern> sorear: mapM?
16:27:03 <sorear> @src mapM
16:27:03 <lambdabot> mapM f as = sequence (map f as)
16:27:06 <dons> zbrown: also, you could mention that with the built in support for concurrency and smp, parallel programming in haskell is rather easy
16:27:19 <chessguy> actually, he wants mapM_
16:27:29 * Gwern tears some hair out
16:27:38 <Gwern> haven't you guys ever heard of meaningful names?
16:27:40 <monochrom> dons, zbrown: As usual, it is the "how likely we can hire a temp coder" that determines language choices.
16:27:46 <sorear> mapM_ / mapM is very little difference ...
16:27:49 <dons> monochrom: not in academia
16:27:50 * Gwern wonders if maybe I actually want mapM`m_
16:27:51 <chessguy> Gwern, replace it with mapM_ generateAndTest list
16:28:00 <sorear> Gwern: sure.  we like consistent short names.
16:28:02 <dons> since you can be expected to learn the tools
16:28:23 <sorear> Gwern: M means monadic composition, map works over a data struct
16:28:28 <dons> in a university research setting, there's a lot more incentive to use newer, more sophisticated technologies
16:28:40 <monochrom> OK, second attempt.  The first coder determines the language.
16:28:50 <chessguy> @type mapM_
16:28:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:28:53 <Gwern> sorear: that seems to get me closer but I don't think its quite there, as it hasn't compiled yet :)
16:28:56 <iron33> zbrown : Choosing a language to do a new project is never an easy issue thats why many people stick to choices they perceive as safe i.e some derivative of C
16:29:06 <dons> but really, doing math in C? that should be a pretty easy one to tackle :-)
16:29:12 <zbrown> iron33: ya
16:29:25 <hpaste>  sorear annotated "Wikipedia bot" with "fixed?" at http://hpaste.org/741#a1
16:29:27 <monochrom> OH!  Doing math in C is actually very likely.
16:29:33 <zbrown> monochrom: well here's the thing, im not a temp coder per se, im listed as a researcher on the project
16:29:33 <chessguy> Gwern, what did you put in there?
16:29:34 <emu> doing math in C is awful :/
16:29:38 <zbrown> i work for them but im not so much a temp
16:29:42 <sorear> Gwern: diff
16:29:53 <Gwern> ah, i misunderstood you
16:30:00 <dons> and also, good technical results can be more influential in  an academic setting
16:30:08 <Gwern> you meant mapM_ in the function definition, not in the main monad where it's being called
16:30:09 <dons> since there's not nearly so much pressure from management ;)
16:30:14 <zbrown> monochrom dons: there's also the fact that in this research area i'd be the first to write a modeling system that isn't based off of swarm in some way
16:30:30 <zbrown> swarm or some commercial product tha tis
16:30:33 <dons> ok. so that's probably a good thing.
16:30:34 <monochrom> The non-CS prof, who wants to initiate a coding project but doesn't code, hires a temp coder and says "do whatever you want".  If that coder happens to use L, then the project is henceforth stuck with L.
16:31:04 <dons> monochrom: not always though. i was involved in porting a polymer simulator written in perl to haskell
16:31:17 <zbrown> monochrom: heh the eventual goal is to make this my life's work basically
16:31:20 <dons> and as a result it runs in smaller space and faster than the commerical product it was designed to model :-)
16:31:29 <zbrown> if this goes well ill probalby do my phd thesis on this project
16:31:41 <monochrom> Yes, after 5 years the prof may decide to migrate.  Not a yearly event.
16:31:46 <dons> the original author had to just ditch perl and learn haskell, since the math was a lot easier, and there was no way we'd parallelise the perl
16:32:07 <dons> zbrown: then you don't want to do it in C :-)
16:32:15 <zbrown> dons: exactly
16:32:23 <zbrown> if i have to i may compromise, first doing some in haskell, some in swarm
16:32:26 <iron33> zbrown: I finally got the go ahead to do a functional programming course at work but I doubt I will pitch from a Lisp, Scheme, SML, OCAML or Haskell angle even tthough they are great languages I will have to pitch it from Microsofts F#, LINQ and next gen C# and VB.NET just to give it credibility eventhough Haskel is my favorite programming language I would never be able to demonstrate FP benefits using it because my co workers woul
16:32:26 <iron33> seriously
16:32:37 <zbrown> and eventually writing my own system entirely in haskell
16:32:50 <dons> iron33: hmm. scary. that might make the point hard to get across?
16:33:08 <monochrom> I am just trying to say most of the time things are just social historical accidental, and then once every 5 years you can maybe sneak in a technically sound decision.
16:33:09 <iron33> dons: How so ?
16:33:12 <dons> iron33: since they'll only see the concepts in diluted or weak form
16:33:15 <zbrown> I have to use .NET at my job, which is horrid
16:33:23 <dibblego> is there a type class that is something like: class Serializable a where serialize :: a -> List[Word8]; deserialize :: List[Word8] -> a ?
16:33:33 <dons> i guess work is hard. hmm.
16:33:44 <dons> dibblego: yes, Data.Binary
16:33:50 <dibblego> dons, ah thanks
16:33:50 <dons> ?where hackage
16:33:51 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
16:34:02 <dons> its on hackage
16:34:15 <dons> monochrom: yes, that's true enough
16:34:25 <iron33> dons: I don't see how F# and LINQ can be considered a weak form of FP
16:34:43 <dons> but we can and must move things forward. no reason to use bad technology, esp. when zbrown is planning a phd in the area
16:34:43 <dibblego> iron33, I have spent lots of years developing methods of "getting the point across" - I should document them some time
16:35:24 <dons> iron33: well, I just think the particular concepts will be hard to get across in a unified way. e.g. LINQ is a damaged list monad, so how do you convey monads when you can't show a range of them?
16:35:36 <dons> F# should be ok though, that's just ocaml
16:35:37 <iron33> dibblego : Well I have giving quite a few presentations but mostly in the OO world
16:35:50 <dons> but may as well show ocaml...
16:36:06 <dibblego> I developed these methods by trial and reflection on the reaction
16:36:35 <dons> dibblego: yes. experience pitching new ideas to sceptical colleagues at work. hmm. hard.
16:36:36 <dibblego> i.e. challenging the illegitimate authority successfully
16:37:36 <dibblego> dons, I don't have the problem here at work, but of course, in general it exists (I dare not try it back at IBM - *that* would be the biggest challenge ever)
16:38:02 <dibblego> I smile at the thought of how many of my ex-colleagues would pass FizzBuzz
16:38:06 <iron33> well unfortunately coming from a large Corporation myself having another large corporation means something where academia is not as respected as it should be even if the CORPS just steall all the ideas from there anyway
16:38:20 <dons> yeah. sad.
16:38:36 <zbrown> hmmm
16:38:45 <zbrown> i just wrote a never ending recursion it appears
16:38:48 <zbrown> oops
16:39:04 <dibblego> iron33, no point being bitter about it; what are you going to do about it?
16:39:05 <dons> we call that a 'loop' here. a technical term ;)
16:39:13 <iron33> zbrown : The possible consequence of programming in any turing complete language :)
16:39:17 <sorear> we also call it _|_
16:39:23 <chessguy> infinite recursion is the off-by-one error of functional programming
16:39:35 <zbrown> lol
16:39:37 <sorear> @seen _|_
16:39:38 <lambdabot> I haven't seen _|_.
16:39:55 <zbrown> does '_' count for a tuple in an argument call?
16:39:57 <chessguy> @quote bottom
16:39:58 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
16:39:58 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
16:40:02 <chessguy> @quote bottoms
16:40:03 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
16:40:04 <dibblego> zbrown, yes
16:40:08 <iron33> dibblego : Only thing I can do about it pitch it the only way the will accept it F#, LINQ, FunctionalJ, JFP
16:40:11 <zbrown> Ok thank you :
16:40:12 <zbrown> :)
16:40:17 <iron33> FC++
16:40:49 <dibblego> iron33, you might try Scala as well
16:41:10 <sorear> TEq :Co_CInt :: TEq Int CInt
16:41:16 <iron33> dibblego : I would do Python first neve really took to that language though
16:41:27 <sorear> TEq @ :Co_CInt
16:42:44 <iron33> I am just amaze the agreed to this course. Could still fall through though we will see
16:43:23 <hpaste>  zbrown pasted "how to fill in the last mosqMove?" at http://hpaste.org/742
16:43:39 <zbrown> ^^ Can someone tell me what id want to set "mosqMove _ _ _ 0 = " to?
16:44:13 <iron33> dibblego : You ever give an FP course before ?
16:44:52 <dibblego> iron33, yeah, only to two colleagues; one was extremely sceptical and intelligent, the other was "whatever" and not-so-clever; the sceptical one hates using Java these days
16:45:54 <dibblego> the "whatever" one still doesn't get it (nor Java for that matter)
16:46:09 <dibblego> I spent a whole week doing it
16:47:48 <iron33> Well despite that Java is not an especially well constructed language it has good tools and libraries, huge community and tons of books and free examples on how to do just about anything so I can't say I hate it. It would be nice to code in a better thought out paradigm for a change
16:49:12 <dibblego> I hate using Java (and Scala's strictness is annoying)
16:50:57 <zbrown> http://hpaste.org/742Any hints for my paste? :)
16:50:59 <zbrown> oops
16:51:04 <zbrown> didn't mean to paste it again
16:51:24 <iron33> dibblego : You can almost always simulate lazy evaluation with thunking so strictness doesn't bother me to much although I prefer lazy eval by default still I just want to be able to glue software together in a better way instead of through brittle complicated interfaces
16:52:01 <dibblego> iron33, yep, that's exactly what I do, hence "annoying" and not "debilitating"
16:53:45 <iron33> See I wouldn't mind Objects as long as the have only one public method with only one argument :)
16:54:19 <dibblego> so that it can be partially applied?
16:54:25 <dibblego> you'd hit problems
16:54:38 <dibblego> and you could always pass a tuple
16:54:42 <iron33> dibblego : Like ?
16:54:54 <dibblego> like the fact that the Sun JVM doesn't tail call eliminate
16:55:42 <dibblego> passing an int is passing 32 arguments
16:55:56 <dibblego> I've never understood those people who complain about 32 arguments, then go right ahead and pass an int
16:55:59 <iron33> dibblego : How so ?
16:56:03 <dibblego> how not?
16:56:11 <siti> lol, that's pedantic :p
16:56:15 <dibblego> interface Pair<X, Y>{X x(); Y y();}
16:56:23 <dibblego> if I pass one of those, is that one or two arguments?
16:57:01 <dibblego> it';s not pendantic, it's Information Theory for ninnies
16:57:24 <iron33> dibblego : Well you will forgive me if I refuse to see it your way for the sake of abstraction I am don't bit twiddle when I don't have too ;)
16:57:41 <sorear> zbrown: why didn't you use announce?
16:58:08 <zbrown> sorear: i did earlier
16:58:10 <zbrown> no one saw :(
16:58:11 <zbrown> lol
16:58:23 <dibblego> hpaste>  zbrown pasted "how to fill in the last mosqMove?" at http://hpaste.org/742
16:58:31 <sorear> ah.
16:58:33 <sorear> sorry :)
16:58:41 <zbrown> im trying to get that code to iterate
16:58:43 <zbrown> but im not sure how
16:58:50 <zbrown> say take 10 steps or w/e
17:00:58 <zbrown> hmmm replicate looks promising
17:02:54 <sorear> yhc folks here?
17:12:29 <dpiponi> What's the most portable device anyone out therehas run (interactive) haskell on?
17:12:44 <zbrown> If i have a function that calculates an infinite list, how would i tell it to only calculate say... the first 40 elemetns?
17:12:52 <monochrom> I have a laptop.
17:13:01 <yip> > take 40 [1..]
17:13:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:13:11 <zbrown> thank you yip
17:13:25 <mbishop> [1..] !! 40
17:13:27 <dons> dpiponi: i think shapr has run hugs on his nokia
17:13:28 <mbishop> > [1..] !! 40
17:13:30 <lambdabot>  41
17:13:33 <mbishop> heh
17:13:34 <dino-> dons: He has? :o
17:13:42 <dino-> I need hugs on my n770.
17:13:49 <dons> and nhc has been known to run on the palm pilot, and on an embedded linux on an arm card
17:13:49 <dino-> Where the hell have I been.
17:13:49 <dpiponi> dons: Is that the nokia tablet thing?
17:14:02 <dons> not sure. better check with shapr
17:14:15 <mbishop> hmm nhc runs on arm? if I had a working wifi card, I'd try to get it installed on my jornada :P
17:14:27 <dons> yeah, nhc is a good choice stil for arm
17:14:28 <dino-> I was vaguely under the impression it would need something like yhc because of the arm. But I speak with no knowledge or authority.
17:14:35 <dons> yhc is a fork of nhc
17:14:37 <dpiponi> dons: I've run hugs on an NSLU2, but it's not portable.
17:14:48 <dons> that currently runs slower, and supports less libraries ;)
17:15:09 * monochrom picks on dons grammar :)
17:15:13 <dons> that's why we run the shootout, http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
17:15:14 <lambdabot> Title: nobench: Haskell implementation shootout
17:15:16 <dino-> I would be pretty pleased even with being able to target binaries for the thing build on my big box.
17:15:33 <dino-> s/build/built/
17:15:37 <dons> note that nhc supports Data.ByteString, which yhc still doesn't
17:16:18 <dons> hugs supports more type system tricks though
17:16:26 <dons> (e.g. mtl and ST)
17:16:41 <sorear> yhc/nhc98 are in theory portable ansi C on the output side
17:17:24 <hpaste>  zbrown pasted "(no title)" at http://hpaste.org/743
17:17:47 <zbrown> ^^ Could someone tell me how to modify the randomR statements so that they stay within the bounds of lenght and width ?
17:18:01 <zbrown> monochrom: the numbers didn't stay within the bounds with your suggestion :-/
17:18:12 <monochrom> eh, "g0 <- newStdGen"?  No seed?
17:18:29 <zbrown> monochrom: its what nmessenger gave me?
17:18:45 <monochrom> ?type newStdGen
17:18:48 <lambdabot> IO StdGen
17:18:57 <monochrom> Oh nevermind, it's right.
17:19:26 <zbrown> now i just need randomR to stay within my bounds :(
17:19:31 <dino-> I was under the impression that was a good way to do it because it splits off a new gen.
17:20:32 <monochrom> w is along the x axis, l is along the y axis?
17:20:36 <zbrown> yes
17:20:55 <zbrown> it "looks" right to me
17:20:58 <zbrown> but i dunno why its not
17:21:33 <monochrom> > 2 - 3 `max` 0
17:21:35 <lambdabot>  -1
17:21:40 <hpaste>  dons annotated "(no title)" with "some refactoring hints" at http://hpaste.org/743#a1
17:21:54 <TomMD> If I have an arbitrary data type what is the best way to convert that data to [Word32]?  E.g. convert (x :: Foo Int Word16 [Word8]) == y :: [Word32]
17:21:56 <monochrom> That explains why.  I didn't pay attention to precedence.  (2-3) `max` 0  is correct.
17:22:20 <dons> TomMD: hmm. you could use Data.Binary to convert it to a list of bytes
17:22:22 <dons> how about that?
17:22:31 <monochrom> I need to be more like a computer, less like a human.
17:22:44 <TomMD> And then reread the bytes as Word32?  Hummm  I'll look into it.
17:22:46 <dons> TomMD: or you could derive show, nd then map fromIntegral.ord over the result
17:22:59 <dons> depends on why you want to create Word32s
17:23:09 <dons> is it for large data sets?
17:23:13 <monochrom> Take nothing for granted. Be pedantic. Ask for all details and definitions.  The only true way to becoming a superior programmer, not mediocre programmer.
17:23:14 <zbrown> dons: why is 'R !Int !Int' preferable to tuples?
17:23:28 <iron33> monochrom : Humans are smart but do stupid things, computers are stupid but do smart things :)
17:23:34 <bd_> zbrown: it's strict, and with -funbox-strict-fields avoids indirections
17:23:44 <TomMD> But they might not all be numeric value... so pretend I have a datatype I wish to send over the network (hopefully similar to the simplicity of 'C' structs)
17:23:46 <dons> oh, just a reflex. R Int Int is preferable in that it creates a new type
17:23:49 <monochrom> I think doing smart things is a better contribution than being smart.
17:23:58 <iron33> you could say we compliment each other perfectly
17:24:00 <dons> so you can't accidentally mix up your Mosq and your Rooms
17:24:15 <dons> the ! bit is just an optimiations, to unpack the Int into the constructor, saving a ptr
17:24:26 <monochrom> Be a smart human, make stupid mess, die ---> what's the value?
17:24:53 <TomMD> Getting more to the point - what about Haskell Crypto library - how do I encrypt any random data structure easily?  I have to convert to [WordX]
17:24:55 <monochrom> (# Int, Int #) is preferable to R !Int !Int  :)
17:25:07 <iron33> monochrom : I disagree you forgot the most important thing about great programmers creativity :)
17:25:11 <dons> not really, monochrom
17:25:15 <dons> since its not a first class kind
17:25:39 <dons> and you'd want (# Int#, Int# #) if you were doing that anyway
17:25:43 <monochrom> I think creativity is overrated.
17:25:49 <dons> otherwise you still have a pair of pointers
17:25:55 <monochrom> Right that.
17:26:04 <SamB> monochrom: a smart compiler will make it return (# Int#, Int# #) if possible
17:26:15 <SamB> and of course you aren't allowed to pass those in to things
17:26:21 <monochrom> I want to be a smart compiler.
17:26:22 <dons> hmm. I don't think ghc will do that. It will just remove the constructor entirely
17:26:29 <dons> the worker will pass Int# Int# as separate args
17:26:50 <dons> and forget about wrapping them. so they'l take up 2 consecutive slots on the stack anyway
17:27:24 <dons> so a smart compiler will turn ( R !Int !Int ) -> ... into Int# -> Int# -> ...
17:27:32 <yip> will ghc decide to inline functions on its own?
17:27:36 <dons> yeah
17:27:52 <yip> functions from another module?
17:28:04 <dons> if they were compiled with -O, yes.
17:28:13 <yip> nice
17:28:28 <yip> will an inlined function show up in profile results?
17:28:32 <dons> yeah
17:28:45 <dons> but profiled code behaves differently to real code, due to all the annotatoins
17:28:52 <dons> which break some optimisatoins opportuities
17:29:27 <yip> that doesn't sound good
17:29:55 <dons> its just something to be aware of when doing very low level things
17:29:59 * SamB thinks it would be cool if there was precise costing somehow
17:30:11 <dons> you'd have to run on top of valgrind or something
17:30:25 <yip> dons: do typeclasses have any performance overhead costs?
17:30:32 * SamB was thinking of help from oprofile or something
17:30:48 <SamB> maybe just fuzzy costing
17:31:02 <SamB> that didn't break optimization
17:33:52 <dons> yip, not really, no. only rarely do they not get specialised in polymorphic code, and you can manually control that
17:34:05 <dons> for your emulator though, I'd really get familiar reading GHC core output
17:34:15 <dons> since you want to know exactly what code is produced for your inner loooops
17:34:30 <yip> how do i generate GHC core output?
17:35:40 <dons> i have a little tut on reading Core here, http://www.haskell.org/pipermail/haskell-cafe/2007-February/022315.html
17:35:43 <lambdabot> Title: [Haskell-cafe] Tricks for making low level haskell hacking easier, http://tinyurl.com/2f2dsc
17:36:10 <dons> but check the performance wiki
17:36:17 <dons> ?wiki Performance
17:36:17 <lambdabot> http://www.haskell.org/haskellwiki/Performance
17:36:21 <yip> ok great thanks!
17:38:37 <chessguy> :k StateT
17:38:39 <lambdabot> * -> (* -> *) -> * -> *
17:38:49 <chessguy> ?type StateT
17:38:51 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
17:43:18 <chessguy> Lemmih, ping
17:47:04 <chessguy> is it possible with darcs to get the most recent version of the code, without worrying about what parts are patches, etc.?
17:47:20 <Saulzar> yip: Have you had another look at that emulator any time lately?
17:47:43 <yip> Saulzar: there's a darcs repository now available
17:48:07 <dons> chessguy: you can ask for a specific tag or patch
17:48:12 <dons> chessguy: so say, --to-match=PATTERN             select changes up to a patch matching PATTERN
17:48:29 <dons> darcs get --to-match=last-patch-i-care-about
17:48:39 <chessguy> dons, i'm saying, i just want the corrected code, without caring about the ability to roll back patches
17:49:25 <Saulzar> yip: Nice, where abouts?
17:49:29 <tensh> I want to create a function where I get an arithmetic function as an argument (plus, minus etc.) that can handle bot Integer and Double values
17:49:34 <yip> Saulzar: http://www.mutantlemon.com/omegagb/
17:49:36 <lambdabot> Title: OmegaGB - Game Boy Emulator
17:49:44 <tensh> any ideas?
17:49:53 <allbery_b> Num a -> (a -> a)
17:49:55 <allbery_b> er
17:50:00 <tensh> well
17:50:01 <allbery_b> Num a => (a -> a)
17:50:15 <tensh> I have: Num a => (a -> a -> a)
17:50:22 <allbery_b> ook
17:50:25 <allbery_b> er, ok
17:50:25 <dons> chessguy: oh, --partial is the closest you'll get to tthat
17:50:28 <tensh> but I get
17:50:31 * allbery_b is tired and messed up
17:50:31 <dons> which depends on when the person last tagged their repo
17:50:40 <tensh> Expected type: a    Inferred type: INteger
17:50:46 <tensh> Integer*
17:50:56 <allbery_b> @paste your code
17:50:56 <chessguy> ok
17:50:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:51:29 <allbery_b> (dependong on what's using it / being used by it, I can imagine the MR coming into play, or something)
17:52:10 <hpaste>  tensh pasted "generic arithmetic" at http://hpaste.org/744
17:52:36 <yip> Saulzar: Lemm!h started wrtiting some patches... he's has the same idea that you had about going with the ST monad
17:53:07 <tensh> right now it's not used at all
17:53:41 <tensh> so it shouldn't be affected by external stuff
17:53:58 <dons> yip, how similar is the gameboy emulator to a hardware simulator?
17:54:17 <dons> or say, something like the UM machine puzzle in the ICFP contest last year?
17:54:18 <yip> dons: very. it pretty much is a hardware simulator
17:54:36 <yip> dons: i'm not familiar with that puzzle
17:54:47 <dons> so lots of mutable arrays then, modelling a machine's memory and registers?
17:54:56 <yip> yes
17:55:12 <dons> ok. this is a known hard  area for ghc haskell. getting down to say, 3x C would be a good result
17:55:20 <dons> you migth want to consider doing some of the key inner loops in C
17:55:48 <yip> i want to try to avoid c if at all possible. even if it's 20x slower then C it should still be fast enough
17:55:48 <dons> yip, here's a sample of UM machines, http://www.cse.unsw.edu.au/~dons/um.html
17:55:49 <lambdabot> Title: Haskell UM
17:55:54 <dons> ah ok.
17:55:57 <dons> 20x should be easy
17:56:05 <dons> have a look at the haskell code there for some hints
17:56:35 <dons> i'd probably use bytestrings for some of that stuff now
17:56:54 <yip> dons: my initial implementation used an immutable unboxed array for memory, and was purely functional, copying it on every update i imagine
17:57:02 <dons> STUArrays or IOUArrays should be good.
17:57:07 <tensh> allbery_b: any idea? :/
17:57:12 <dons> Ptr Word32 or what have yo umight be another 10% better
17:57:15 <dons> and should get near to C.
17:57:17 <allbery_b> I don't see anything obvious there, maybe if one of the other folks can poke at it?
17:57:20 <Saulzar> Yeah, I seem to remember the stuff for updating pixels was a bottle neck - and updating the mutable memory
17:58:04 <allbery_b> hrm.  actually I'm nto sure you can reuse the same variable for VInt xv' and VDouble xv'
17:58:32 <yip> dons: Lemm!h has started to modify all the code to use STUArrays
17:58:42 <tensh> the method works nicely if I exchange `r` into a plus or something like that
17:59:02 <allbery_b> that definitely sounds MR-ish
17:59:18 <tensh> MR?
17:59:18 <tensh> ;)
17:59:20 <allbery_b> but your code snippet doesn't really haev enough information for me to see it
17:59:27 <Saulzar> I tried changing it to use a StateT ST ... but the memory read functions became slow
17:59:29 <yip> Saulzar: yeah, for some reason copying the display array every scanline was really slow, but copying the entire memory buffer ever frame wasn't
17:59:35 <allbery_b> monomorphism restriction.  haskell98 doing newbie handholding :)
17:59:42 <monochrom> MR = magnetic resonance.
18:00:19 <tensh> ok ;)
18:00:28 <tensh> well... I'll keep trying
18:02:12 <jcreigh> for stuff like UM, I have to wonder, is it really worth it to write it in Haskell? It seems like, in a larger program, yes, because the bottleneck is probably in 10% of your code and the other 90% can be idiomatic Haskell. But for a VM, since you want to simulate mutable memory and whatnot, it seems easier just to use C in the first place. What do you guys think? Am I totally off base here?
18:02:49 <dons> its not worth it to write in haskell , at the moment
18:02:55 <dons> other than to verify the machine on a high level
18:03:12 <monochrom> MR refers to this.  When you define "x = ..." (not "x y = ..."), the computer thinks, x should not be polymorphic, I must infer one single type for it.
18:03:17 <dons> i.e. it would be worth doing at a very high level in haskell, and say, checking that in isabelle
18:03:23 <dons> then translating the resulting spec to C.
18:04:35 <yip> is it possible to call out to c functions from within the ST monad and have them modify an STArray?
18:05:20 <dons> yeah
18:05:34 <dons> though using a Foreign array would be faster and simpler for that
18:05:41 <dons> Foreign.Marshal.Array
18:05:49 <yip> but that requires IO, right?
18:05:52 <tensh> monochrom: ahh, I see
18:06:02 <dons> right, you're in the IO monad instead of the ST monad
18:06:05 <chessguy> suppose module A imports module B. now module B has a function foo, one parameter of which is another function. so to call foo, A passes a function bar. but in the definition of bar, it has to call another function, which is defined in A. is that allowed?
18:06:11 <Igloo> for an STArray you'd be limiting yourself to ghc -threaded I think
18:06:26 <yip> dons: if i stay in ST then i can end up with a pure function in the end, even though it's actually calling c functions inside, right?
18:06:45 <Pastorn> ?src mapAccumL
18:06:45 <lambdabot> mapAccumL _ s []        =  (s, [])
18:06:45 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
18:06:45 <lambdabot>    where (s', y ) = f s x
18:06:45 <lambdabot>          (s'',ys) = mapAccumL f s' xs
18:06:51 <dons> well, if it is pure from the outside, and you're using the FFI, you could still wrap that with unsafePerformIO safely
18:07:03 <dons> since you're just using the IO monad as an ST monad, which you know to be safe
18:07:04 <tensh> monochrom: I tried changing the case expression to (xv,yv) though so I could match on both
18:07:30 <dons> ie. .use unsafePerformIO as runST, along with the assurance that it is indeed pure
18:07:35 <jcreigh> chessguy: I can't imagine it being disallowed.
18:07:52 <yip> dons: ok, i guess both ways are very similar
18:08:01 <chessguy> jcreigh, hmm. but how does B have access to that other function in A
18:08:05 <Igloo> Oh, actually, it would all be single threaded, so just ignore me
18:08:15 <dons> the advantage of the IO monad there is that it is more flexible
18:08:35 <dons> but you lose the nic eguarantees ST provides
18:08:37 <jcreigh> chessguy: well, it doesn't, really, it just calls the function it was passed.
18:08:43 <yip> dons: if i have multiple threads, is it possible that the c function will be run multiple times concurrently?
18:08:49 <lucca> dons: icfpcontest.org urls are now pointing at 2007 stuff; use boundvariable.org for the 2006 specific materials-links
18:08:51 <chessguy> hmm
18:09:06 <bd_> yip: yep, you'll need to use locking if you want to avoid that
18:09:08 <dons> yip, it is possible. it depends how you write the code.
18:09:09 <jcreigh> otherwise, how would Prelude.map work?
18:09:16 <dons> lucca: thanks.
18:09:26 <jcreigh> (or any other HOF)
18:09:46 <Pastorn> ?paste
18:09:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:09:52 <yip> i read somewhere that there is a global lock that allows only one c function to be running at a time
18:10:11 <bd_> yip: There isn't, at least in the threaded RTS
18:10:44 <yip> bd_: what if i am running the threaded RTS, but it is using only one OS thread, because there is only one cpu?
18:11:08 <yip> er... i guess there it's impossible to run 2 c functions
18:11:31 <bd_> yip: The threaded RTS may use multiple OS threads even with +RTS -N1
18:11:36 <hpaste>  Pastorn pasted "Is there any simpler way to do this?" at http://hpaste.org/745
18:11:41 <bd_> yip: However, only one thread will be running /haskell/ code at a time
18:11:58 <dons> you can run multiple foreign calls simultaneously, if you want, and multiple haskell threads
18:12:03 <dons> writing a parallel game boy emulator, eh?
18:12:25 <yip> that would be quite difficult :) i am just curious
18:12:39 <bd_> yip: So for example if you call into a foreign ccall safe declaration with one haskell thread, it'll spawn a second to pick up haskell execution while the first enters C-land
18:13:22 <yip> bd_: so the RTS creates and destroys os threads at runtime? it doesn't create a fixed size pool at startup?
18:13:30 <Saulzar> Pastorn: the maybe function?
18:13:39 <Pastorn> no, the guards
18:13:46 <bd_> yip: Right. But! The number of capabilities set at startup controls how many are in haskell code at any given time
18:13:49 <Saulzar> @type maybe
18:13:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:13:52 <Pastorn> maybe some pattern matching?
18:14:10 <jcreigh> Pastorn: What are you trying to do? (note that, "g x == Just x" compares the result of "g x" with "Just x". It *does not* do pattern matching.)
18:14:11 <Saulzar> The function called maybe, I mean :)
18:14:11 <Pastorn> Saulzar: I don't want to evaluate it as it can be matched...
18:14:33 <bd_> yip: note that if you use foreign ccall unsafe, it might not spawn an extra thread. However this also means it can block every thread in your program, which is probably bad :)
18:15:28 <monochrom> case g x of {Nothing -> ... ; Just x -> ...}  like that?
18:15:40 <yip> bd_: i think i read in the docs not to use the usleep function, to use threadDelay, because usleep calls the system usleep, and it will block *all* threads
18:15:57 <fantasma> is it possible to use the OR ( || ) operator with the filter function?
18:16:04 <Pastorn> monochrom: yeah, something like that
18:16:05 <fantasma> > filter (\x -> mod x 3 == 0 || mod x == 5) [1..1000]
18:16:06 <lambdabot>   add an instance declaration for (Num (a -> a))
18:16:16 <bd_> yip: that may be outdated documentation... the builtin IO loop in GHC (with -threaded) uses blocking syscalls directly...
18:16:22 <Pastorn> but considering how g x isn't a variable...
18:16:24 <jcreigh> fantasma: the second "mod" is only given one argument.
18:16:38 <fantasma> jcreigh, wow, i am so careless thank you
18:16:43 <jcreigh> heh.
18:16:47 <monochrom> g x isn't a variable.  but that's ok, don't worry.
18:17:10 <fantasma> next time I should LOOK at my code instead of jumping straight to irc
18:17:20 <jcreigh> when GHC says "add an instance for (Foo (a -> b))", it usually means there's a missing argument somewhere.
18:17:25 <yip> bd_: ok. but if i call forkIO 1000 times, and each thread opens a net connection to some host and sends data, it's possible that all of these will actually run on a single os thread?
18:17:34 <Pastorn> monochrom: could you annote, please?
18:17:45 <fantasma> jcreigh, yah Im not really used to the errors yet
18:17:48 <monochrom> me annote?  where?
18:17:56 <bd_> yip: yes, as long as they're not all in blocking C calls at the same time :)
18:17:57 <monochrom> found
18:18:02 <Pastorn> hehe
18:18:21 <jcreigh> fantasma: You're doing FizzBuzz, aren't you? :)
18:18:39 <fantasma> jcreigh, what's FizzBuzz?
18:18:40 <yip> bd_: ok, but if just one thread calls a blocking C call (like usleep), then all threads will block, right?
18:18:54 <bd_> yip: probably not :)
18:19:08 <yip> why not?
18:19:36 <dons> yp, well, you're using the SMP runtime, right?
18:19:38 <jcreigh> fantasma: http://tickletux.wordpress.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding
18:19:41 <lambdabot> Title: Using FizzBuzz to Find Developers who Grok Coding  Imran On Tech, http://tinyurl.com/2k83vg
18:19:43 <dons> foo +RTS -N100
18:19:49 <dons> to have 100 actual OS threads?
18:20:11 <jcreigh> fantasma: BTW, if you didn't already know this, you can use backticks to make a normal function infix, for when it reads nicer. eg, filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) [1..1000]
18:20:27 <yip> dons: but even if there are 100 actual OS threads, the RTS can still decide if it wants to put all 1000 threads on a single os thread. it probably won't, but it's *possible*, right?
18:21:17 <fantasma> jcreigh, yah I knew aobut the infix, didn't know that it looked nicer though :) -- and I'm doing the first problem on the euler project
18:21:20 <bd_> yip: no, if you have multiple runnable haskell threads and free capabilities (= OS threads, roughly), they will be assigned to additional OS threads
18:21:30 <bd_> yip: see http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler for more detail
18:21:33 <lambdabot> Title: Commentary/Rts/Scheduler - GHC - Trac
18:21:51 <jcreigh> fantasma: heh, well, looks nicer to me anyway.
18:21:57 <bd_> yip: note the first bullet-point :)
18:22:00 <hpaste>  monochrom annotated "Is there any simpler way to do this?" with "(no title)" at http://hpaste.org/745#a1
18:22:43 * yip reads
18:22:50 <Pastorn> thanks :D
18:23:23 <yip> btw, ghc uses pthreads?
18:23:48 <bd_> yip: that's an implementation detail, isn't it? :)
18:24:08 <yip> that doesn't make it a valid question =]
18:24:20 * zbrown is quite pleased with the succinctness of the code for the simple model he wrote :)
18:24:42 <zbrown> thanks monochrom & dons & whoever else helped me for the assistance
18:25:02 <bd_> yip: I think it uses it, but you're not going to have a pthread for each haskell thread
18:25:15 <yip> right, and on windows it uses win32 threads?
18:25:16 <dons> yip, you'd have to look at the scheduler. i think that if that happened it would be a serious bug (99 os threads idle)
18:25:27 <bd_> yip: I'd assume so :)
18:25:28 <dons> do you have a real problem, or just wondering?
18:25:41 <yip> just wondering
18:25:51 <monochrom> or just wondering about a real problem :)
18:26:11 <yip> well i am working on a multi threaded web server
18:26:22 <yip> but i'm not having any problems with it :)
18:27:35 <dons> for some situations we've found the os itself doesn't schedule os threads onto cores ideally, under linux. sometimes you get two os threads runing on one core, when there' another idle. not always, just occasionally. doesn't seem to happen as often on solaris
18:27:59 <dons> we've not had problems with ghc's scheduler though
18:28:37 <yip> did you try configuring the linux kernel to use one of the alternate schedulers?
18:28:40 <monochrom> if the os does a weird thing, the program cannot help much
18:29:36 <allbery_b> solaris used to have such issues, IIRC, but fixed them
18:29:44 <allbery_b> linux?  who knows...
18:31:55 <dons> we'll be looking into kernel tweaking soon, i think
18:33:08 <monochrom> Oh!  bos can hack linux kernel for us! ...
18:33:47 <dons> apparently!
18:34:03 <monochrom> "bos: could you rig it to become hostile to non-GC programs such as C programs and optimized for GCed programs such as Haskell programs?"  :)
18:34:11 <dons> handy guy to have around. i wonder if we can convince him to get back into GHC runtime hacking...
18:34:21 <dons> maybe move the GHC runtime into the kernel?? ;)
18:34:28 <yip> who is he?
18:34:36 <monochrom> You are more perverted than me.
18:34:42 <fantasma> i have a an infinite list, how can I use the filter function on only a specific part of the list?
18:34:45 <dons> he modified 1.5% of the linux kernel last year, yip :-)
18:34:53 <dons> and happens to hang out here and write haskell
18:34:56 <zbrown> fantasma: there's the "take" function
18:35:06 <zbrown> fantasma: take 40 func
18:35:11 <zbrown> err take 40 list
18:35:12 <jcreigh> > take 5 [1..]
18:35:13 <lambdabot>  [1,2,3,4,5]
18:35:14 <fantasma> zbrown, thanks I'll look into it
18:35:16 <monochrom> fantasma: yes, but first use some function to pick out the specific part, for example another another filter...
18:35:50 * zbrown notes 1.5% of the linux kernel is quite large
18:36:07 <yip> doesn't linux have like 10 million lines of code? 1.5% is 150,000 loc
18:36:11 <zbrown> yup
18:36:28 <zbrown> thats a lot of characters :-O
18:37:26 <yip> so the GC blocks all threads? this could be a problem in the future when you have 64 cpus
18:38:21 <NichardRixon> > (take . drop) 5 [1..]
18:38:22 <lambdabot>  Couldn't match expected type `Int'
18:38:29 <NichardRixon> > (take 5 . drop 5) [1..]
18:38:30 <lambdabot>  [6,7,8,9,10]
18:38:33 <monochrom> Oh, yes that's right.  Few people have researched into distributed GC algorithms, let alone implemented...
18:38:48 <bd_> yip: Someone was working on a parallel collector
18:39:07 <yip> that could be really interesting
18:39:30 <monochrom> Dijkstra and Lamport together wrote one, wouldn't hang other threads, but no code just pseudocode and correctness proof.  That's the only one I ever heard of.
18:40:06 <bd_> not incremental/background, but parallel :)
18:40:12 <bd_> ie, scales with number of threads
18:40:15 <bd_> but still stop-the-world
18:40:56 <monochrom> how to scale with number of threads and still stop the world?
18:41:16 <bd_> stop the world, all threads run GC at the same time (parallelizing the mark phase), then resume
18:41:25 <monochrom> Ah, nice.
18:46:14 <fantasma> ok, I have an infite list and I want all the value less than X from that list, so I use filter...but it never stops!
18:47:08 <beelsebob> http://www.bloggerheads.com/red_nose_day/
18:47:10 <lambdabot> Title: Red Nose Day 2007: Some Legal Advice
18:47:26 <bd_> fantasma: takeWhile :)
18:48:02 <fantasma> bd_, thanks
18:48:05 <yip> > takeWhile (<10) [1..]
18:48:07 <lambdabot>  [1,2,3,4,5,6,7,8,9]
18:49:07 <beelsebob> fantasma: the problem you're encountering is that filter does not stop scanning the list when it finds something that fails it's test -- it just omits it from the list
18:49:18 <beelsebob> thus using filter will produce the correct result
18:49:32 <beelsebob> but it will keep searching in the vain hope that it finds some more things that pass
18:49:33 <monochrom> "all the value less than X from that list" may still be an infinite list.
18:49:58 <beelsebob> indeed
18:50:07 <beelsebob> > let ones = 1:ones in fliter (<2) ones
18:50:08 <lambdabot>   Not in scope: `fliter'
18:50:10 <beelsebob> fail
18:50:16 <beelsebob> > let ones = 1:ones in filter (<2) ones
18:50:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:50:24 <fantasma> fantastic! problem 2 from project euler solved!
18:50:32 <monochrom> but if you say, "I am sure it stops, because of the following reason", then all that means is you are asking the wrong question, you have not revealed your reason.
18:51:18 <monochrom> I hate it when people keep some crucial information secret when they ask questions.
18:51:29 <fantasma> yah sorry about that
18:51:38 <fantasma> i'll change my nick and everything once I learn haskell
18:51:39 <monochrom> "how do you solve math problems?"
18:51:47 <jcreigh> heh
18:51:48 <merus> carefully?
18:51:51 <merus> heh.
18:51:55 <beelsebob> monochrom: I suspect that it's often a failed attempt to keep the question simple
18:52:03 <jcreigh> @remember fantasma i'll change my nick and everything once I learn haskell
18:52:04 <lambdabot> Done.
18:52:11 <bd_> monochrom: Step one: State the theorem. Step two: Provide a proof. Step three: Write "QED".
18:52:12 <fantasma> haha
18:52:12 <beelsebob> often it's harder to explain the exact maths problem than to say "how do I solve problems in general"
18:52:25 <Hirvinen> monochrom: You are just bitter because your mind reading over IRC abilities aren't very good.
18:52:43 <monochrom> My mindreading ability is not very good.
18:52:50 <monochrom> I AM A COMPUTER!
18:52:51 <dons> monochrom: is just bitter though
18:53:24 <jcreigh> what's the Feynman method? "Think hard, and then write down the answer"?
18:53:56 <merus> the Feynmann method got me through probability models, I'm afraid.
18:53:58 <monochrom> and go to a topless bar and drink 7-up?
18:54:30 <monochrom> 7-up is probably his secret of success :)
18:54:48 <beelsebob> I doubt that
18:54:57 <beelsebob> irn-bru is much more likely
19:00:06 <rahikkala> sum $ filter even $ takeWhile (<1000000) $ fix (\n -> 0 : 1 : zipWith (+) n (tail n)) -- easy!
19:02:46 <Pastorn> when declaring exports, do I need to mention type declarations (like type Position = (Double, Double))
19:02:51 <Pastorn> ??
19:03:33 <beelsebob> Pastorn: no
19:03:34 <allbery_b> yes
19:03:44 <beelsebob> you need to mention their name
19:03:45 <allbery_b> hm?
19:03:48 <Pastorn> yay! consistency!!
19:03:48 <beelsebob> but not their definition
19:03:49 <bd_> Pastorn: only if you want them exported
19:03:55 <bd_> @quote sterepo
19:03:56 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
19:03:57 <Pastorn> ok
19:03:57 <bd_> @quote stereo
19:03:58 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
19:04:08 <allbery_b> you need to list the name, and either the constructor names or (..) for all constructors
19:04:18 <bd_> allbery_b: type synonyms have no constructors
19:04:22 <bd_> you just mention their name
19:04:27 <allbery_b> oh, type syns.  name only
19:04:35 <Pastorn> i have "type Accumulator = (Angle, State, [State])", do i still need to mention State and Angle?
19:04:48 <beelsebob> Pastorn: if you are trying to export a data type you may need more -- to export data Bob = Bill | Fred you would need to include Bob in the list, to allow people to use the constructors you need to say Bob(..)
19:05:05 <Pastorn> ok
19:05:19 <beelsebob> Pastorn: depends how you want people to use it
19:05:27 <Pastorn> true
19:05:31 <beelsebob> if they write functions that only use the Accumulator type then no
19:05:42 <beelsebob> if they actually get dirty and need to use the types inside it, then yes
19:05:56 <Pastorn> ok... thanks :)
19:05:56 <CosmicRay> algorithm question.  I have a [String], each String representing a line.  I have four strings, A, B, C, D.  I need to delete from the [String] everything between A and B, and everything between C and D, inclusive.  Anything before A, after D, or between B and C needs to be included.
19:06:04 <CosmicRay> now I can write this with a 2-line sed program
19:08:08 <CosmicRay> I'm trying to think about stringing across some takeWhile and dropWhiles, or some spans, but I just can't figure out an elegant way to do it.
19:08:14 <CosmicRay> there are plenty of ugly ways that I could do
19:08:18 <CosmicRay> but I want something elegant
19:08:19 <CosmicRay> any ideas?
19:09:13 <Pastorn> beelsebob: if i want some functions but ALL the types exported? any easy way out?
19:09:33 <sjanssen_> CosmicRay: you know that A B C and D appear in that order?
19:09:37 <monochrom> takeWhile (/= A) . dropWhile (/= B)
19:09:43 <monochrom> oops!
19:09:50 <monochrom> takeWhile (/= B) . dropWhile (/= A)
19:09:51 <CosmicRay> sjanssen: yes
19:09:58 <monochrom> That's between A and B.
19:10:14 <monochrom> ?type span
19:10:16 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:10:26 <Pastorn> > (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))) (1.0, 0.0) (1.0, 4.5))
19:10:27 <lambdabot>  Parse error
19:10:32 <Pastorn> fuck...
19:10:47 <CosmicRay> monochrom: actually I don't think that is right, wouldn't that drop everything before A and keep the stuff between A and B?  (the opposite of what I want)
19:11:01 <CosmicRay> what I am trying to do, BTW, is drop GPG signature blocks from plaintext ascii files
19:11:07 <Pastorn> >let f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+)) in f (1.0, 0.0) (1.0, 4.5))
19:11:10 <monochrom> I misread!
19:11:14 <Pastorn> > let f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+)) in f (1.0, 0.0) (1.0, 4.5))
19:11:14 <lambdabot>  Parse error
19:11:16 <CosmicRay>     sed -e '/^-----BEGIN PGP SIGNED MESSAGE-----/,/^Hash: / d' \
19:11:16 <CosmicRay>         -e '/^-----BEGIN PGP SIGNATURE-----/,/^-----END PGP SIGNATURE-----/ d'
19:11:21 <CosmicRay> that's what I worked up to do it in sed
19:11:52 <beelsebob> Pastorn: you need to export only the types that appear in the function's type signature, or you explicitly manipulate
19:11:55 <beelsebob> fail
19:12:45 <monochrom> span is about the right thing to use.  two spans are one sed line.
19:13:11 <CosmicRay> monochrom: I am having trouble visualizing how to nicely thread the two parts of the tuple through things.
19:16:49 <CosmicRay> it seems that some monad would be nice, but I don't know quite how.
19:20:33 <sjanssen_> CosmicRay: could you use parsec?
19:21:09 <CosmicRay> yeah, I could.
19:21:18 <CosmicRay> but that seems overkill
19:21:20 <hpaste>  monochrom pasted "intervals" at http://hpaste.org/746
19:21:30 <sorear> .
19:21:40 <CosmicRay> maybe my instincts are wrong, but something tells me that there is a solution here around span and maybe the state monad or something
19:21:50 <monochrom> Yes.
19:22:47 <monochrom> This code happens to include B and D.  There are many ways to weed them.
19:23:17 <monochrom> This code yells "state monad", too.  But I don't want to take away all of your fun.
19:23:27 * CosmicRay studies
19:24:15 <dibblego> I often see code that is a -> b -> a -- I think for all of these cases, you can use the state monad
19:24:28 <hpaste>  sjanssen pasted "is this right?" at http://hpaste.org/747
19:24:41 <CosmicRay> monochrom: yes, I understand the cost you have pasted
19:24:46 <sjanssen_> CosmicRay: how about that?
19:25:07 <monochrom> sjanssen's is also right.
19:25:38 <CosmicRay> that looks pretty decent
19:26:03 <CosmicRay> but not as intuitive as sed
19:27:35 <jcreigh> It terms of "just getting it done", I doubt you're going to beat sed.
19:27:58 <monochrom> sed is itself a whole DSL.
19:28:03 <CosmicRay> true
19:28:16 <CosmicRay> but maybe I can beat it in elegance and readability.
19:28:20 <allbery_b> if you really needed it that often I'm sure a "sed monad" could be whipped up
19:28:25 <CosmicRay> heh
19:28:32 <allbery_b> question is if it's worth the effort
19:28:41 <CosmicRay> allbery_b: don't say that around the perl people.  pretty soon we'll have a perl monad ;-)
19:28:51 <sjanssen_> allbery_b: I think parsec is a fine monad for this problem
19:28:52 <jcreigh> *cough* pugs *cough*
19:29:01 * allbery_b ==jcreigh :)
19:29:06 <CosmicRay> heh, does fail in the perl monad dump out python code? ;-)
19:29:30 <monochrom> parsec is more strict than sed.
19:29:55 <monochrom> but don't mind me, I know you mean a suitable parser monad
19:30:06 <CosmicRay> hmm, I have this in MissingH:
19:30:12 <monochrom> or rather, after a minute I realize you mean
19:30:14 <CosmicRay> grab :: Int -> State [a] [a]
19:30:14 <CosmicRay> grab count =
19:30:14 <CosmicRay>     do g <- get
19:30:14 <CosmicRay>        (x, g') <- return $ splitAt count g
19:30:14 <CosmicRay>        put g'
19:30:15 <CosmicRay>        return x
19:30:34 <allbery_b> the "sed monad" would be a parser monad, of course
19:30:47 <CosmicRay> if I generalized that a bit so that it worked with span...
19:30:57 <CosmicRay> then monochrom's solution would be nicely portable
19:31:14 <CosmicRay> to the state monad
19:31:17 <CosmicRay> I think
19:33:40 <monochrom> Yes.  If you make it a state monad (state being "the unexamined lines"), and introduce the right helper functions, the end result will look like: do { in0 <- until A; until B; in1 <- until C; until D; in2 <- get; return (in0++in1++in2) }
19:34:04 <CosmicRay> yes, that is what I'm after.
19:34:54 <monochrom> There are other variations.  "in0 <- until A; until B" can be merged into one function.
19:36:32 <monochrom> ?type get
19:36:35 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
19:38:24 <nmessenger> "given a state monad 'm' parameterized over the state 's', 'get' is an action resulting in 's'"
19:38:59 <monochrom> Observe that "break (== A)" has type "state -> (answer, state)".  (Similarly "span (/=A)")
19:39:09 <CosmicRay> yep
19:39:25 <monochrom> Doesn't it look familiar, and ripe for injection into State? :)
19:39:54 <CosmicRay> no and yes ;-)
19:40:10 <monochrom> ?src Control.Monad.State.State
19:40:11 <lambdabot> Source not found. It can only be attributed to human error.
19:40:26 * monochrom hates to be a human. :)
19:40:40 <CosmicRay> heh
19:41:19 <nmessenger> newtype State s a = State { runState :: s -> (a, s) }
19:41:30 <TomMD> ?paste
19:41:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:42:03 <nmessenger> @type State
19:42:05 <lambdabot> forall s a. (s -> (a, s)) -> State s a
19:42:11 <hpaste>  TomMD pasted "Haskell as the Universal Language" at http://hpaste.org/748
19:42:14 <nmessenger> @type State (break (==undefined))
19:42:17 <lambdabot> forall a. (Eq a) => State [a] [a]
19:42:21 <jfoutz> i think i'd have to be a lot smarter to use happs
19:42:36 <TomMD> Good night everyone, let me know if you don't think this is a good argument in favor of Haskell.
19:42:53 <TomMD> 'This' being the paste
19:43:41 <dons> hehe
19:43:43 <nmessenger> > (toEnum 109, toEnum 112, toEnum 116) :: (Char,Char,Char)
19:43:44 <lambdabot>  ('m','p','t')
19:44:14 <sorear> not
19:44:26 <sorear> prefix = "not"
19:44:48 <sorear> i'm not subject to off by one bugs, nmessenger  </human_arrogance>
19:45:05 <nmessenger> :D  I said nothing of the sort!
19:45:20 <hpaste>  monochrom annotated "intervals" with "monadic intervals" at http://hpaste.org/746#a1
19:45:21 * sorear ,in the mood of 1984, denounces nmessenger of being a C programmer
19:45:30 <tensh> is it possible to send a compare operator as an argument to a function? (< > <= >=)
19:45:42 <tensh> == and != also of course
19:45:46 <nmessenger> @type compare
19:45:49 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
19:46:11 <nmessenger> tensh: that'd give you all the cases, but yes, you could use (<), (>), (<=), etc.
19:46:11 <tensh> hmm... I don't get it
19:46:17 <nmessenger> > compare 1 2
19:46:18 <lambdabot>  LT
19:46:21 <tensh> oooh
19:46:22 <tensh> sweet
19:46:30 <nmessenger> @type sortBy
19:46:32 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
19:46:39 <nmessenger> ^^ fits nicely :)
19:46:41 <dons> i'd probably write it with a where clause though,
19:46:59 <dons> main = do
19:46:59 <dons>     putStrLn $ prefix `doubleplus` body
19:46:59 <dons>   where
19:47:00 <dons>     prefix     = ...
19:47:06 <dons> oh, drop the 'do'
19:47:26 <nmessenger> you're no fun, dons :P
19:47:34 <monochrom> > sortBy (==) [3,1,4,1,5,9,2,6,5,3]
19:47:35 <lambdabot>  Couldn't match expected type `Ordering'
19:47:47 <monochrom> oops, nevermind.
19:47:55 <CosmicRay> monochrom: thanks for all your help... my battery is almost exhausted so I'll have to run
19:47:58 <nmessenger> > sortBy (flip compare) [3,1,4,1,5,9,2,6,5,3]
19:47:59 <lambdabot>  [9,6,5,5,4,3,3,2,1,1]
19:48:31 <sorear> wow: data Foo = Foo ; data Bar = Bar Foo deriving (Show)
19:48:50 <sorear> GHC generates an amazingly opaque error message :)
19:48:58 <sorear>     Constraint is no smaller than the instance head
19:49:02 <nmessenger> wouldn't Foo need Show?
19:49:12 <sorear> nmessenger: yes, I did figure that out
19:49:14 <monochrom> You can send operators to functions.  For example, (+) is an operator, foldl is a function...
19:49:15 <dons> sorear: the constraint has to be smalle rthan the instance head
19:49:23 <dons> Ord a => Ord ([] a)
19:49:23 <monochrom> > foldl (+) 0 [1..10]
19:49:24 <lambdabot>  55
19:49:30 <sorear> nmessenger: it seems like it might be very confusing to newbies
19:49:59 <monochrom> I cannot use "foldl (<=) ..." in this example.  But some other functions will gladly take (<=).
19:50:19 <sorear> why won't foldl take (<=) ?
19:50:27 <nmessenger> wrong type
19:50:40 <sorear> > foldl (<=) True [False]  -- tell that to GHC
19:50:42 <nmessenger> unless folding over Bools :)
19:50:42 <lambdabot>  False
19:50:47 <monochrom> Yeah.
19:51:15 <sorear> remember Bools are ordered *muahahaha*
19:51:38 <monochrom> (<=) is implication.  (==) is iff.
19:51:58 <SamB> I thought => was implication!
19:52:24 <monochrom>  is implication. => is just ascii art.
19:52:32 <SamB> and <=> was iff
19:52:41 <bd_> > let (=>) = flip (<=) in ()
19:52:42 <lambdabot>  Parse error
19:52:46 <monochrom> "syntax doesn't matter"
19:52:49 <bd_> only valid in typesigs I see
19:53:10 <nmessenger> (/=) xor
19:53:37 <sorear> yeah! I can parse YHC/Primitive.hbc
19:53:45 <allbery_b> 
19:53:51 <bd_> > let and = curry (== (True, True)) in True `and` False
19:53:53 <lambdabot>  False
19:53:59 <bd_> > let and = curry (== (True, True)) in True `and` True
19:54:01 <lambdabot>  True
19:54:21 <bd_> > let or = curry (/= (False, False)) in True `or` False
19:54:22 <lambdabot>  True
19:54:57 <sorear> yay, ayhi can now recursively load the prelude (in ten seconds :( )
19:55:13 <sorear> I'd use Data.Binary, but this code needs to run in yhc :)
19:58:19 <dons> nhc supports bytestrings, so why not yhc?
19:58:35 <dons> i suspect maybe not enough of the FFI is fleshed out?
19:59:26 <sorear> dons: If yhc was going to support bytestrings for anybody I suspect it would work on the nobench box :)
20:00:08 <sorear> wow, jhc is even faster than before! 25%! :)
20:04:23 <dons> you're using jhc with the new grin patches?
20:11:19 <dino-> @seen Cale
20:11:20 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 3h 50m 12s ago.
20:24:29 <hpaste>  chessguy pasted "Not sure how to structure my program" at http://hpaste.org/749
20:24:58 <chessguy> so, if anyone's familiar with genetic programming, i'm working on a GP framework for haskell
20:25:11 <chessguy> right now, everything's in one file
20:25:36 <chessguy> i'm trying to figure out how to separate the problem-specific and the library code
20:25:47 * sorear <3 GA
20:27:28 <chessguy> i'm thinking what i need to do is, in the library code, have Data (Problem a) = Problem a { fitness :: Program a -> Double, ... etc. }
20:27:43 <sorear> you're missing a lot of imports
20:27:47 <chessguy> but i'm not sure how to handle the Environment
20:27:57 <sorear> Control.Monad.State, Data.Tree, System.Random ...
20:28:05 <chessguy> yeah, i cut out most everything but the type signatures
20:28:08 <chessguy> for the paste
20:28:15 <sorear> oh :)
20:28:18 <chessguy> and the comments
20:28:23 <sorear> I was trying to get it to run :)
20:28:28 <sorear> silly me
20:28:29 <chessguy> heh
20:28:45 <chessguy> you can darcs get http://catenova.org/~awagner/GPLib if you'd like :)
20:28:47 <lambdabot> Title: Index of /~awagner/GPLib/
20:29:01 * sorear thinks it would help understanding
20:29:06 <chessguy> sure
20:29:19 <chessguy> there's not much output yet
20:29:20 <sorear> I like downloading things into /tmp.  Mess vanishes at reboot
20:30:00 <chessguy> are you calling my code a mess? :)
20:30:04 <allbery_b> heh
20:30:12 <jcreigh> I like downloading things into ~/downloads. It's there if I need it later, and vanishes in 5 years when I clean out my homedir. :)
20:30:19 <sorear> chessguy: no, I make messes when I download a lot of programs :)
20:30:32 <sorear> chessguy: what is the sample problem?
20:30:35 <chessguy> thin ice there, kid :)
20:30:44 <dibblego> I keep /opt in revision control
20:30:50 <chessguy> sorear, just evolving x^2+x
20:30:59 <chessguy> (i think)
20:31:24 <chessguy> yeah
20:31:48 <chessguy> given a bunch of x/y data points
20:31:56 <sorear> so, evolve an expr to make x^2+x == 0?
20:32:07 <sorear> oh, regression
20:32:14 <chessguy> right, symbolic regression
20:32:26 <sorear> evolve a func to minimize deviation from a set of samples
20:32:27 <sorear> ?
20:32:48 <chessguy> yes
20:33:11 <chessguy> a classic problem for GP
20:33:44 <chessguy> symbolic regression : GP :: factorials/fibonaccis : haskell
20:34:04 <sorear> wait, what's the State Environment for?
20:34:28 <chessguy> it's the environment that a particular program runs in
20:35:02 <sorear> hmm.
20:35:04 <chessguy> because some of the "functions" in the nodes of the program are going to be stateful
20:35:39 <sorear> so you're evolving an impure functional program to compute foo.
20:35:41 <sorear> ok.
20:35:48 <sorear> ...
20:35:52 <chessguy> e.g., another classic problem is to evolve an algorithm for an ant to find a path of food. so it's going to be constantly modifying its state
20:35:54 <chessguy> right
20:36:10 <chessguy> (though i'm not sure what foo is, if anything)
20:36:27 * sorear uses higher order fu to simplify the problem!
20:37:32 <chessguy> so, i want to first get rid of the type DataType = ...
20:37:38 <sorear> nah
20:37:54 <chessguy> and instead have a data Problem = Problem a { ... }
20:37:58 <sorear> or maybe you should, but I've a general simplification first
20:38:19 <chessguy> what's that?
20:38:52 <sorear> get rid of the State Environment
20:39:02 <chessguy> that would be nice
20:39:10 <chessguy> how?
20:40:19 <sorear> type DataType = State Environment Double
20:40:54 <chessguy> erhmmm
20:41:12 <sorear> higher order fu!
20:41:33 <chessguy> that's going to break type signatures like node :: [DataType]->State Environment DataType
20:43:22 <chessguy> see, my thinking is to parameterize the Gene datatype, a new Problem polymorphically
20:43:36 <chessguy> s/, a/, and a/
20:43:51 <chessguy> that still doesn't make sense
20:44:30 <chessguy> what i meant was change data Gene = ... to data Gene a ..., and create a new data Problem a = ...
20:44:49 <chessguy> where Problem contains all the parameters to define a problem that the library can solve
20:45:09 <chessguy> and then the type doesn't matter
20:45:44 <chessguy> but i'm not sure what to do with the Environment then
20:46:45 <chessguy> i want to say that the Problem record can contain any state it wants to, but i'm not sure how to do that
20:46:47 <hpaste>  sorear annotated "Not sure how to structure my program" with "use higher order fu to make gplib not care about State Environment" at http://hpaste.org/749#a1
20:48:27 <kc5tja> You people don't know what you're talking about.
20:48:30 <kc5tja> Everyone knows...
20:48:35 <kc5tja> BASIC is the king!
20:48:45 * kc5tja has one thing to say, for real: fevers suck.  :(
20:49:04 <kc5tja> Can't sleep, have headache, am drugged to hell and back, but I still have to wait everything out.  :(
20:49:13 <chessguy> sorear, i don't think that works
20:50:03 <sorear> chessguy: of course not, I deleted the implementations of the methods I didn't change, to squeeze it under the 5k limit.
20:50:09 <sorear> glguy: thanks :(
20:50:20 <sorear> chessguy: but it typechecks here ...
20:50:22 <chessguy> sorear, that's beside the point
20:50:48 <sorear> chessguy: and it evolves x*x+x
20:50:59 <chessguy> hmm
20:51:15 <chessguy> shouldn't it break this though?  node :: [DataType]->DataType,
20:51:49 <sorear> no, because DataType is State Environment Double.
20:52:00 <sorear> we're composing entire stateful programs.
20:52:22 <chessguy> but before it wasn't expecting the items in the list to be stateful. now they are
20:53:33 <sorear> BTW, if you don't need mutation, Reader is better than State
20:53:57 <jcreigh> sorear: why is that the case? They both look about the same to me.
20:54:03 <chessguy> well, that's up to the user
20:54:05 <sorear> (State Environment Double) is an ordinary, first class, predictable value
20:54:12 <sorear> jcreigh:
20:54:21 <sorear> @unmty State Environment Double
20:54:22 <lambdabot> Environment -> (Double, Environment)
20:54:27 <sorear> @unmty Reader Environment Double
20:54:28 <lambdabot> Environment -> Double
20:54:46 <sorear> Reader avoids a tuple and threading of the new value.
20:55:46 <chessguy> sorear, does your method work if the user-defined problem isn't stateful?
20:56:24 <chessguy> e.g., if they decide to do type DataType = Integer
20:56:27 <sorear> chessguy: yes
20:56:27 <nmessenger> getX _ = gets x -- ?
20:56:42 <sorear> nmessenger: yes iirc
20:56:57 <chessguy> ?src gets
20:56:58 <sorear> @src gets
20:56:58 <lambdabot> Source not found. stty: unknown mode: doofus
20:56:58 <lambdabot> Source not found. My mind is going. I can feel it.
20:57:08 <nmessenger> @type gets
20:57:10 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
20:58:26 <monochrom> Is kc5tja hallucinating badly? :)
20:58:31 <nmessenger> gets f = do
20:58:32 <nmessenger> 	s <- get
20:58:32 <nmessenger> 	return (f s)
20:59:09 <sorear> @src MonadState
20:59:10 <lambdabot> Source not found. I feel much better now.
20:59:11 <chessguy> looks right to me
21:02:04 <chessguy> ?hoogle node
21:02:05 <lambdabot> Data.Tree.Node :: a -> Forest a -> Tree a
21:02:05 <lambdabot> Test.HUnit.Base.Node :: data Node
21:02:05 <lambdabot> Data.Graph.Inductive.Graph.Node :: type Node
21:02:10 <chessguy> what's this node function?
21:02:38 <chessguy> sorear,
21:02:50 <nmessenger> data Gene = Gene { ... node :: [DataType]->State Environment DataType, ... }
21:03:28 <sorear> node :: [DataType] -> DataType now :)
21:03:48 <chessguy> oh man
21:03:52 <chessguy> i'm way too tired
21:04:11 <nmessenger> record sigs sometimes confuse me, node *really* has type Gene -> ([DataType] -> DataType)
21:08:58 <chessguy> wow, it works
21:09:12 <chessguy> weird how you can just turn a type inside-out like that
21:11:13 <chessguy> i almost don't like this though
21:11:35 <chessguy> the lifting kind of obscures the simple definitions of the genes
21:13:52 <sorear> it's pointfree notation ... plus (x:y:xs) = liftM2 (+) x y ==> plus (x:y:xs) = do { x' <- x; y' <- y ; return $ x + y }
21:14:36 <nmessenger> not pointfree so much as higher-order
21:14:45 <chessguy> you mean return $ x' + y'
21:14:57 <sorear> yeah :)
21:15:14 <sorear> liftM2 is less error-prone too :)
21:15:19 <chessguy> i'm just saying, having to pull those values out of the monad is ugly
21:15:57 <fantasma> what's the fastest prime numbers algorithm
21:15:58 <nmessenger> That's why you lift the (+) into the monad :D
21:16:16 <sorear> fantasma: google
21:16:27 <chessguy> fantasma, browse haskell-cafe archives from recent days
21:16:30 * nmessenger vaguely remembers chessguy quoting him
21:16:32 <sorear> @google number of primes less than a billion
21:16:34 <lambdabot> http://www.troubleshooters.com/codecorn/primenumbers/primenumbers.htm
21:16:35 <lambdabot> Title: Fun With Prime Numbers
21:16:46 <sorear> no coding needed!
21:16:51 <fantasma> i was hoping for something done in haskell
21:16:55 <chessguy> http://www.haskell.org/pipermail/haskell-cafe/
21:16:56 <lambdabot> Title: The Haskell-Cafe Archives
21:17:18 <fantasma> just tell me which function I should use :D
21:17:23 <fantasma> scanl
21:17:47 <chessguy> it's not one simple function
21:18:16 <fantasma> well you have to put stuff inside of it
21:18:22 <fishkandy> fantasma, http://comments.gmane.org/gmane.comp.lang.haskell.cafe/19380
21:18:24 <lambdabot> Title: gmane.comp.lang.haskell.cafe
21:18:24 <chessguy> nmessenger, quoting you about what?
21:18:48 <chessguy> @quote nmessenger
21:18:49 <lambdabot> nmessenger says: [hpaste] prepare to die! [nmessenger]  > "aah!" >>= replicate 5
21:18:50 <chessguy> @quote nmessenger
21:18:51 <lambdabot> nmessenger says: (_|_) <-- haha look at my bottom!
21:18:52 <chessguy> @quote nmessenger
21:18:52 <lambdabot> nmessenger says: [hpaste] prepare to die! [nmessenger]  > "aah!" >>= replicate 5
21:18:54 <chessguy> @quote nmessenger
21:18:54 <lambdabot> nmessenger says: (_|_) <-- haha look at my bottom!
21:19:11 <chessguy> so many memorable things you've said :)
21:19:18 <nmessenger> can't bring value out of monad, bring function into it.
21:19:26 <chessguy> oh that one
21:20:00 <chessguy> the point is, the code the user has to write is uglier now
21:20:29 <sorear> make combinators!
21:20:42 <chessguy> ?
21:20:45 <sorear> binop :: String -> (a -> a -> a) -> Gene a
21:20:58 <bd_> > let (_|_) :: a; (_|_) = undefined in ()
21:20:58 <lambdabot>  Parse error
21:21:01 <bd_> :(
21:21:06 <sorear> binop nam f = Gene (liftM2 f) 2 nam
21:21:16 <sorear> er
21:21:31 <sorear> binop nam f = Gene (\(x:y:_) -> liftM2 f x y) 2 nam
21:21:53 <sorear> [ binop "+" (+), binop "*" (*), binop "-" (-) ]
21:22:14 <chessguy> hrmm
21:22:22 <hpaste>  nmessenger annotated "Not sure how to structure my program" with "instance RandomGen GlobalState, in case it makes randomness part any easier." at http://hpaste.org/749#a2
21:22:41 <chessguy> nmessenger, yeah yeah, i'll get to that eventually
21:24:19 <sorear> > mapAccumL (\a b -> (liftM2 (||) ((==0).(`mod`b)) a, a b) (const False) [2..]
21:24:19 <lambdabot>  Parse error
21:24:26 <sorear> > mapAccumL (\a b -> (liftM2 (||) ((==0).(`mod`b)) a, a b)) (const False) [2..]
21:24:27 <lambdabot>  (<Integer -> Bool>,[False,False,True,False,True,False,True,True,True,False,T...
21:24:42 <chessguy> what in the world?
21:25:01 <sorear> > filter snd $ ap zip (snd . mapAccumL (\a b -> (liftM2 (||) ((==0).(`mod`b)) a, a b)) (const False)) [2..]
21:25:03 <lambdabot>  [(4,True),(6,True),(8,True),(9,True),(10,True),(12,True),(14,True),(15,True)...
21:25:11 <sorear> > filter (not.snd) $ ap zip (snd . mapAccumL (\a b -> (liftM2 (||) ((==0).(`mod`b)) a, a b)) (const False)) [2..]
21:25:13 <lambdabot>  [(2,False),(3,False),(5,False),(7,False),(11,False),(13,False),(17,False),(1...
21:25:20 <sorear> > map fst $ filter (not.snd) $ ap zip (snd . mapAccumL (\a b -> (liftM2 (||) ((==0).(`mod`b)) a, a b)) (const False)) [2..]
21:25:22 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:25:23 * chessguy backs slowly away from sorear
21:25:37 * chessguy hides behind nmessenger 
21:26:00 * sorear *muahahaha*s at writing a sieve using mapAccumL
21:26:13 * nmessenger is jealous
21:26:33 <chessguy> fantasma, ^^ there you go :)
21:26:41 <fantasma> you guys are so smart =\
21:27:02 <merus> lol.
21:27:04 <pzpz> hey, how abouts would I implement a Num instance for a datatype such as RomanNumeral? I've tried simple bindings such as, I = 1 to no avial.
21:27:05 <sorear> > snd $ mapAccumL (\a b -> (liftM2 (||) ((==0).(`mod`b)) a, a b)) (const False) [2..]
21:27:07 <lambdabot>  [False,False,True,False,True,False,True,True,True,False,True,False,True,True...
21:27:22 <sorear> ^ much simpler if you can handle it :)
21:27:32 <sorear> (the output that is)
21:28:40 <fantasma> what is the difference between the following pieces of code :
21:28:48 <fantasma> > let factor n = [ x | x <- [1..n], n `mod` x == 0] in factor 10
21:28:49 <lambdabot>  [1,2,5,10]
21:28:53 <nmessenger> pzpz: a roman numeral isn't a number, it's a numeral.  However, you could newtype Integer and implement the Read and Show you want.
21:28:54 <fantasma> > let factor n = filter (\x -> n `mod` x == 0) [1..n] in factor 10
21:28:55 <lambdabot>  [1,2,5,10]
21:29:21 <pzpz> nmessenger:  I think you're entirely correct.
21:29:29 <sjanssen_> fantasma: there is no real difference
21:29:55 <fantasma> sjanssen_, no difference in speed or effeciency?
21:30:16 <sorear> fantasma: after the desugarer they produce the same code.
21:30:25 <jcreigh> fantasma: well, maybe, but why worry? Eat, drink, and be merry, for tomorrow someone will write a better compiler. :)
21:30:35 <dons> sorear: you want me to add that to the primes benchmark?
21:30:50 <merus> heh :)
21:30:53 <dons> or send me the patch yourself, to spectral/primes/SorearPrimes.hs
21:30:57 <pzpz> nmessenger: I'm trying to just implement a mapping inbetween roman char -> numeric value. I thought by implementing a Num instance I could do that, heh.
21:31:01 <sieni> jcreigh: that's also my approach to compiler development
21:31:34 <nmessenger> pzpz: you'd have to futz with the Haskell parser itself if you wanted XVII as an Integer literal.
21:31:39 <sorear> dons: it's a plain old quadratic trial divider, nothing fancy ... or do you value the peculiar loop structure ?
21:32:01 <nmessenger> you might represent them somehow in a datatype.
21:32:21 <nmessenger> though I don't see the advantage
21:32:23 <pzpz> I've built a simple datatype, data RomanNumerals = I | V | ...
21:32:48 <pzpz> have a simple parser from String -> [RomanNumerals]
21:32:49 <nmessenger> wouldn't the be I | II | III | IV | V | VI | VII | ...
21:32:50 <dons> sorear: i value code in benchmarks :-)
21:33:00 <pzpz> that's one way of doing it.
21:33:07 <nmessenger> :)
21:33:35 <pzpz> or you could just check to see if (x:y:xs) ,x < y, and return y-x
21:33:37 <jcreigh> nmessenger: infitine datatype definitions are hard. (Definitions of infinite data structures are easier)
21:33:39 <pzpz> and reduce your symbol set :)
21:33:41 <nmessenger> you'd have a purdy big datatype, though
21:34:01 <avnit> data RomanNumeral = [RomanNumeralSingle]
21:34:02 <avnit> data RomanNumeralSingle = I | V | X | C | L ...
21:34:06 <nmessenger> jcreigh: can roman numerals represent beyond MMM?
21:34:06 <pzpz> which would allow you do do nassty things
21:34:11 <pzpz> liek, CI
21:34:25 <pzpz> but for this little program I"m not worried about constraints
21:34:26 <jcreigh> avnit: ITYM type RomanNumeral = [RomanNumeralSingle]
21:34:36 <avnit> yeah, sure
21:34:46 <nmessenger> "I think you made"?
21:34:50 <avnit> mean
21:35:11 <jcreigh> nmessenger: ah, right, it probably is finite after all.
21:35:25 <nmessenger> just *large* :D
21:36:22 <chessguy> pzpz, IIRC, there was a RomanNumeral problem in the 99 Haskell Exercises
21:36:40 <fantasma> what's the quickest way to do a prime factorization
21:36:43 <nmessenger> I think there is a notation for >3000, though.  Overbars over numerals multiply by 1000 or something.
21:37:17 <jcreigh> fantasma: open up a terminal, and type "factor N", where N is the number you want to factor. :)
21:37:23 <avnit> nmessenger: http://en.wikipedia.org/wiki/Roman_numeral agrees
21:37:34 <chessguy> hmmm, guess not
21:37:43 <chessguy> ?hoogle factor
21:37:44 <lambdabot> No matches found
21:37:53 <fantasma> jcreigh, factor is not in prelude :(
21:38:17 <jcreigh> fantasma: sorry, I shouldn't have to tried to make a joke. "factor" is a standard UNIX utility to find the prime factors of a number.
21:38:39 <chessguy> oh nice
21:38:42 <chessguy> didn't know about that one
21:38:56 <fantasma> really??
21:39:06 <fantasma> had no idea
21:39:16 <chessguy> system(`factor`) then :)
21:39:41 <jcreigh> another fun, lesser known one is "units"
21:39:46 <dons> hehe, the scheme guys are playing catch up on hackage, http://snow.iro.umontreal.ca/?tab=Packages
21:39:49 <lambdabot> Title: Snowfort
21:40:37 <chessguy> dons, the perl folks could be saying the same about us and cpan
21:40:43 <jcreigh> eg, http://hpaste.org/699
21:41:34 <chessguy> on that note, time to catch some shut-eye. 'night all!
21:42:39 <dons> they could and should
21:43:10 <pzpz> there's no way to bind some numeric value to a type?
21:43:20 <pzpz> via the Num instance?
21:43:42 <dons> hmm?
21:44:13 <pzpz> I mean such that one can do , (+) RomanNumeral RomanNumeral
21:45:09 <allbery_b> you could define a RomanNumeral type and make it an instance of Num
21:45:23 <pzpz> I tried that, but i'm not sure how to define the syntax.
21:45:37 <pzpz> I tried, instance Num RomanNum where \ I = 1 ...
21:45:56 <pzpz> yet, that results in a pattern binding error
21:45:57 <fantasma> is there some sort of intersect function for lists in prelude?
21:46:12 <nmessenger> @src Num
21:46:13 <lambdabot> class  (Eq a, Show a) => Num a  where
21:46:13 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:46:13 <lambdabot>     negate, abs, signum     :: a -> a
21:46:14 <lambdabot>     fromInteger             :: Integer -> a
21:46:19 <nmessenger> ^^ you need to provide those functions
21:46:39 <pzpz> ?hoogle intersect
21:46:40 <lambdabot> List.intersect :: Eq a => [a] -> [a] -> [a]
21:46:40 <lambdabot> Data.Set.intersect :: Ord a => Set a -> Set a -> Set a
21:46:40 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
21:46:52 <nmessenger> @hoogle+
21:46:52 <lambdabot> Data.FiniteMap.intersectFM :: Ord key => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
21:46:52 <lambdabot> Data.FiniteMap.intersectFM_C :: Ord key => (elt1 -> elt2 -> elt3) -> FiniteMap key elt1 -> FiniteMap key elt2 -> FiniteMap key elt3
21:46:52 <lambdabot> Data.IntMap.intersection :: IntMap a -> IntMap b -> IntMap a
21:47:17 <sorear> Data.FiniteMap eh?
21:47:18 <pzpz> yes, but how does it know how to do (+), (-) without some numeric binding?
21:47:41 <pzpz> ie, I = 1, V = 5
21:48:05 <nmessenger> newtype Roman = R [RomanDigit]
21:48:11 <pzpz> i'm triyng to avoid using a simple translation function (RomanNumeral->Int) directly
21:48:46 <nmessenger> R x + R y = ...
21:49:11 <nmessenger> a (Roman -> Int) would be much easier
21:49:21 <nmessenger> call it toInt
21:49:28 <nmessenger> R x + R y = toInt x + toInt y
21:49:38 <nmessenger> R x + R y = R $ toInt x + toInt y
21:49:54 <fantasma> > List.intersect [1,4,6] [8,2,4,7,6]
21:49:55 <lambdabot>  [4,6]
21:50:02 <jcreigh> well, you'd need toRoman too.
21:50:10 <nmessenger> er, yeah
21:50:36 <nmessenger> fromInteger provides your number-making magic
21:51:08 <fantasma> that same code above does not work in ghc
21:51:18 <nmessenger> fromInteger x = R (toRoman x)
21:51:39 <jcreigh> fantasma: ghc or gchi?
21:51:42 <nmessenger> fantasma: the intersect thing?  worked for me. :/
21:51:49 <fantasma> jcreigh, ghci
21:52:32 <jcreigh> fantasma: huh, works for me. I was thinking it might be something you need to import, but I guess not.
21:52:39 * jcreigh has GHC 6.6
21:52:44 * nmessenger likewise
21:52:53 <jcreigh> fantasma: what error do you get?
21:53:33 <fantasma> "not in scope" "List.intersect"
21:55:28 <tensh> is it possible to write a function like this?
21:55:37 <tensh> func :: IO Value -> Value
21:55:45 <jcreigh> tensh: no
21:55:51 <tensh> dammit
21:55:58 <nmessenger> what are you trying to do?
21:56:13 <jcreigh> tensh: (Actually, there is a function that does that, but it's a back door for when you really need it.)
21:56:21 <tensh> I need to evaluate a list of expressions and get them as a regular list
21:56:31 <tensh> jcreigh: ok, I don't wanna do that ;)
21:56:53 <nmessenger> liftM (f :: [Exp] -> [Whatever]) :: IO [Exp] -> IO [Whatever]
21:56:54 <tensh> well, I have a list of expressions that are to be used as function arguments
21:57:20 <tensh> and function doesn't take IO ones
21:57:29 <nmessenger> lift it into IO!
21:57:33 <allbery_b> the way you do this is do whatever is needed in IO, then invoke a pure function on it and let that pure function do te work
21:58:01 <tensh> hmm, ok
21:58:04 <jcreigh> tensh: so you have [IO Value] and you want [Value]?
21:58:19 <tensh> jcreigh: yeah, kinda
21:58:36 <tensh> I have [Exp], but and Exp evalutes into IO Value
21:58:54 <nmessenger> so [Exp] -> [IO Value]?
21:59:03 <nmessenger> then sequence
21:59:21 <tensh> well, I have these pre-defined functions
21:59:28 <nmessenger> > sequence [return 1, return 2] :: IO [Int]
21:59:28 <tensh> I'll paste an example
21:59:31 <tensh> hold on a sec
21:59:46 <tensh> (Id "printInt",   \ [v] -> putStrLn (printValue v) >> return Vvoid)
22:00:31 <nmessenger> printValue :: Exp -> IO Value ?
22:00:39 <tensh> I have a data-type Value defined that can be VInt Integer | VDou... and so on
22:01:16 <tensh> exchange printValue for show v
22:02:06 <nmessenger> @paste the whole thing, I'm not following
22:02:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:02:37 <tensh> entire program?
22:02:43 <nmessenger> into hpaste.org
22:02:55 <jcreigh> tensh: assuming you have something like eval :: Exp -> IO Value, and some list exprs :: [Exp], you could do something like mapM eval exprs in the IO monad to get [Value]
22:02:59 <nmessenger> is it large?
22:03:39 <tensh> 6kb
22:04:33 <nmessenger> you could just do the functions you want, but the whole thing probably wouldn't hurt.  It'll probably get truncated, though
22:05:05 <tensh> ok, I'll leave out some stuff then
22:06:28 <ivanm> ?seen kosmikus
22:06:28 <lambdabot> kosmikus is in #haskell, #darcs, #ghc and #gentoo-haskell. I last heard kosmikus speak 8h 14m 54s ago.
22:07:00 <hpaste>  tensh pasted "Interpreter" at http://hpaste.org/750
22:07:16 <tensh> I'm afraid it's not heavily commented if you catch my drift ;)
22:07:36 <nmessenger> :)  which function has the error and where?
22:08:05 <tensh> nmessenger: well, it's not in the code right now
22:08:17 <tensh> at the bottom of the code you'll see an earlier attempt
22:08:28 <tensh> oops, you don't
22:08:32 <tensh> that part got truncated
22:09:17 <nmessenger> annotate the rest including updateVar
22:09:28 <nmessenger> there's an "annotate" link
22:09:41 <hpaste>  tensh pasted "Interpreter (rest)" at http://hpaste.org/751
22:09:58 <tensh> oops, sorry
22:10:19 <hpaste>  nmessenger annotated "Interpreter" with "rest" at http://hpaste.org/750#a1
22:12:24 <tensh> the method is supposed to be a special case of "eval"
22:12:39 <tensh> right by the place that says "-- call"
22:13:25 <tensh> as you might have figured out, it's the method for evaluating a function call ;)
22:15:42 <nmessenger> so updateVar is ill-typed?
22:15:54 <nmessenger> does the rest work wellish?
22:16:14 <tensh> everything is correct except for the commented out stuff
22:16:21 <tensh> works good
22:16:31 <tensh> this is the last obstacle
22:16:45 <nmessenger> annotate the error you get when it's uncommented
22:17:06 <sorear> night.
22:17:14 <nmessenger> g'night
22:17:15 <tensh> well, I haven't even tried running it, because I ran it in my head and I couldn't find a way to do it properly
22:17:56 <nmessenger> you want an implementation of getArgs?
22:18:10 <tensh> yeah, kinda
22:18:17 <tensh> but I'm guessing that won't work
22:18:43 <tensh> f here is a generic function
22:18:51 <tensh> found with lookup
22:18:59 <tensh> and this function is supposed to take arguments
22:19:14 <tensh> all arguments should be in Value-form
22:19:58 <tensh> so the "val <- f $ getargs args" line is wrong to I guess
22:20:12 <nmessenger> do you need to map eval over the arguments somehow to turn them into Values?
22:20:17 <tensh> since this would present the method with a list of Values instead of separate arguments
22:21:25 <tensh> yeah, but there's also the problem with presenting a volatile number of arguments to f
22:22:06 <nmessenger> are you keeping track of f's arity anywhere?
22:22:35 <tensh> what's arity? ;)
22:22:41 <tensh> don't know that word
22:23:09 <nmessenger> arity = number of arguments
22:23:18 <tensh> but if it is it's argument list, then it's in ths ig
22:23:35 <tensh> ooh, nm the argument problem
22:23:40 <tensh> that's the form they want it in
22:23:43 <tensh> gah, stupid
22:24:14 <tensh> I'm getting pretty tired... clock's 7.21am over here :)
22:24:41 <nmessenger> 1:24am here -_- zzZ
22:24:49 <tensh> so to sum up, I need [Value] from [Exp], yeah ;)
22:25:01 <tensh> eastern usa?
22:25:38 <nmessenger> yep
22:27:32 <nmessenger> eval turns Exp's into Values
22:27:52 <tensh> eval :: Env -> Exp -> IO (Env,Value)
22:28:02 <allbery_b> he's off by a few minutes according to my ntp-synched host :)
22:28:06 <allbery_b> @localtime allbery_b
22:28:08 <lambdabot> Local time for allbery_b is Fri Mar  2 01:25:16
22:28:25 <tensh> yeah, my ntp won't sync automatically
22:28:27 <tensh> <3 windows
22:29:21 <allbery_b> ntp's kinda requirement here in the land of kerberos and afs :)
22:29:25 <nmessenger> @unmtl StateT Env (ReaderT Exp IO) Value
22:29:25 <lambdabot> Env -> Exp -> IO (Value, Env)
22:29:29 <nmessenger> you need monads :)
22:29:54 <allbery_b> but, at almost 1:30, past time for bed :) I actually sent tha whole time thing to the wrong network+channel initially, proving my point...
22:30:14 <tensh> ;)
22:30:36 <tensh> yeah... My first class starts in 2 and a half hours
22:35:39 <tensh> ah well... I guess I'll hit the sack... Thank a lot for all the help!
22:35:58 * nmessenger `hit` sack -- also
22:37:47 <dons> hi coffee-mug
22:37:53 <dons> how's code?
22:39:15 <ivanm> @help list
22:39:16 <lambdabot> list [module|command]
22:39:16 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:39:48 <ivanm> @help tell
22:39:48 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
22:39:54 <coffee-mug> hey dons
22:39:58 <coffee-mug> code's good
22:40:07 <coffee-mug> how are you doing?
22:40:23 <ivanm> @tell kosmikus Thanks, but it would have been too difficult (and ugly) to use lhs2tex for my code
22:40:23 <lambdabot> Consider it noted.
22:40:57 <dons> coffee-mug: good. having fun working on compiler benchmarks
22:41:06 <dons> http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html :-)
22:41:07 <lambdabot> Title: nobench: Haskell implementation shootout
22:41:59 <coffee-mug> wow
22:42:04 <coffee-mug> that's a pretty comprehensive chart :)
22:44:19 <dons> its uncovered quite a few issues that have been rapidly adddressed, i'm please to note.
22:44:48 <dons> i end up having to rerun it every couple of days because of code gen fixes and improvements to ghc or nhc or yhc or jhc :)
22:45:03 <dons> nothing like public competition to drive developers ;)
22:45:44 <coffee-mug> yeah
22:45:49 <coffee-mug> that's a Dale Carnegie trick
22:46:03 <coffee-mug> I've been doing some Lisp work lately
22:46:10 <coffee-mug> not as clean as Haskell
22:46:24 <coffee-mug> but I derive very different type of pleasure from it :)
22:46:30 <dons> oh?
22:47:08 <coffee-mug> being able to code "live" is awesome :)
22:47:27 <coffee-mug> I'm probably going to spend some time to figure out how to achieve the same thing with Haskell
22:47:46 <coffee-mug> just need to get some free time
22:48:33 <dons> ah, you mean modifying the system dynamically?
22:49:20 <dons> i wonderhow far we'd get just using ghc-api for that. embed the haskell bytecode interpreter in your app, run everything in that, and you've got the same kind of set up as interpreted ruby or lisp or what have you
22:49:32 <ADEpt> morning
22:49:44 <dons> hey ADEpt
22:50:00 <coffee-mug> dons: yeah
22:50:06 <ADEpt> ppl, what do you make of this: http://video.google.com/videoplay?docid=-3577397095054783025&hl=en? (I dont know if flash variant looks ok, no flash here. Try downloading original video)
22:50:07 <ADEpt> dons:
22:50:07 <lambdabot> Title: Doing pythonchallenge.com in Haskell, levels 1-5 - Google Video, http://tinyurl.com/yrwfp4
22:50:16 <coffee-mug> it would really just be a client-server ghci
22:50:21 <coffee-mug> ghci on steroids, basically
22:50:59 <dons> ADEpt: oh interesting. I was thinking about this just the other day
22:51:20 <ADEpt> dons: about screencasting or about pythonchallenge?
22:51:40 <dons> about doing the pythonchallenge
22:51:47 <dons> getting people to do it, i mean ;)
22:51:57 <ADEpt> dons: it could bring lots of useful libraries around :)
22:52:21 <ADEpt> dons: I was stopped by lack of "zipfile" and "Image" analogs in haskell, for instance
22:53:08 <dons> its a bit too blurry, the .avi file?
22:57:41 <ADEpt> dons: for me, it's not without artefacts, but not blurry. Hope that google didnt mess with it. Should be  45838176 bytes, md5sum dfabc3e695ba9934ab6d3bc8def4c914
23:03:21 <ADEpt> dons: original file, before H.264 compression, was almost 9 time that big, which was really an overkill
23:32:05 <notsmack> i did pythonchallenge in haskell until i got to a problem that was "Use a python library on this data"
23:33:17 <ADEpt> notsmack: that's level six, exactly where I stopped. Like, "deserialize this python data and think about it"
23:33:31 <Vq^> notsmack: isn't there some pickle-based challange?
23:33:45 <notsmack> Vq^, ADEpt: exactly
23:34:17 <Vq^> yeah, thats not much fun outside the pythonworld
23:34:23 <notsmack> very trivial up until there though
23:35:25 <Vq^> just do a shellout to the python-interpreter :o)
23:36:19 <dons> wel, we could parse it back in with Data.Binary and treat it as haskell data
23:36:33 <dons> it'd be, oh, 200x faster too ;)
23:37:23 <gh_> does anyone knows if using .ahs / .alhs files to describe interfaces of haskell modules, is used anywhere but here : http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Hetris/ ?
23:37:23 <lambdabot> Title: Hetris
23:37:50 <Vq^> dons: would it yield the same result?
23:38:17 <dons> depends on what we're supposed to do with the data
23:38:40 <dons> i don't see why we can't parse in python data, build isomoprhic haskell structures, and proceed from there
23:39:30 <Vq^> im sure it's possible, but have you seen the pickle output?
23:40:06 <dons> nope
23:40:22 <Procyon_> If wanted to interleave a value into a list, for instance I want to put a 0 in between the values [1,2,3] to get [1,0,2,0,3], I have an incling to use foldr, but I'm not sure how to compose (:) with the interleaved value.
23:40:38 <dons> > intersperse 0 [1,2,3]
23:40:39 <lambdabot>  [1,0,2,0,3]
23:40:59 <notsmack> @src intersperse
23:41:00 <lambdabot> intersperse _   []     = []
23:41:00 <lambdabot> intersperse _   [x]    = [x]
23:41:00 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
23:41:03 <Procyon_> lol. bow to the prelude.
23:41:16 <Procyon_> thx
23:44:12 <Gwern> so I've been wondering something. I remember hearing that seq somehow ruins the semantics of haskell, but why does't it just act like an alias to id and only be interpreted differently by a compiler?
23:45:05 <Korollary> an alias?
23:45:28 <Gwern> well, defined as a no-op
23:46:10 <dons> i wouldn't say 'ruined'. it complicates matters
23:46:41 <Gwern> or to put it another way, if it's a no-op with relevance only to the compiler, how can it complicate matters?
23:46:57 <dons> it isn't a no-op though
23:47:02 <dons> it forces evaluation to weak head normal form
23:47:35 <dons> > let x = length [1..] in 7
23:47:37 <lambdabot>  7
23:47:40 <Gwern> dons: but shouldn't that only matter to the compiler and not the code, like other optimizations?
23:47:40 <dons> > let x = length [1..] in x `seq` 7
23:47:45 <lambdabot> Terminated
23:47:56 <earthy> gwern: no. the termination behaviour changes.
23:48:09 <earthy> and termination behaviour is most definitely something you want to control
23:48:14 <dons> > let x = length [1..] in x `id` 7 -- it isn't id
23:48:15 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Int'
23:48:34 <dons> > let x = length [1..] in x `const` 7  -- or const ;)
23:48:38 <lambdabot> Terminated
23:48:44 <Gwern> huh. I guess I didn't understand what seq actually does then
23:48:47 <tigliona2bit> h'lo
23:48:57 <dons> > let x = length [1..] in (flip const) x 7
23:48:59 <lambdabot>  7
23:49:23 <Gwern> flip gets used a lot, doesn't it...
23:49:53 <dons> its nice for lining up functions so you can compose them
23:49:53 <tigliona2bit> it just occurred to me that haskell would make a great server-side scripting language.  Are there any big rails-like APIs for haskell?
23:50:04 <dons> there's Happs
23:50:13 <dons> a couple of other similar frameworks are under development
23:50:14 <notsmack> and WASH
23:50:17 <dons> ?paste <-- demo
23:50:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:50:37 <tigliona2bit> thanks
23:51:31 <tigliona2bit> was trying to think of things haskell can get away with without monads
23:52:27 <Lemmih> @seen yip
23:52:28 <lambdabot> yip is in #haskell, #ghc, #happs and #darcs. I last heard yip speak 5h 4m 21s ago.
23:57:21 <earthy> there used to be mod_haskell
23:58:18 <Lemmih> mod_haskell has be deprecated by haskell-fastcgi.
