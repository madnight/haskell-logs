00:54:36 <goltrpoat> adept:  are you ADEpt from efnet #coders?
00:55:43 <sorear> goltrpoat: ADEpt is a "crazy russian hacker" (dons words), wrote a lambdabot jabber interface ... helpful?
00:56:22 <goltrpoat> eh, not really :)  i just remember someone with that same nick with the same capitalization, from a while back
00:58:11 <sorear> wow haskell-mode is old
00:58:17 <sorear> type in echo area:
00:58:19 <sorear> concat :: MonadPlus m => [m a] -> m a
00:59:10 <ivanm> sorear: as in old version, or its been around for a while?
00:59:13 <goltrpoat> heh, nuts
00:59:20 <sorear> @ty concat
00:59:23 <lambdabot> forall a. [[a]] -> [a]
00:59:30 <sorear> ivanm: that's the 1.4 signature for concat
00:59:40 <ADEpt> goltrpoat: no, not really. why?
00:59:42 <ivanm> ahhh....
00:59:46 <sorear> ivanm: AFAIK I'm running the "current" version of haskellmode
00:59:58 <goltrpoat> adept:  the nick looked familiar.
00:59:58 <ADEpt> sorear: actually, not exactly russian, but close enough :)
01:00:22 <ivanm> 2.2?  AFAIK, I've never managed to work out when the signatures in haskell mode work
01:00:41 * sorear accesses memory, finds data fragment .kiev. (url component)
01:00:41 <tiglionabbit> hi
01:01:05 <sorear> hello.
01:01:12 <tiglionabbit> if you have a function that takes a list, and returns something of the type in the list, and you're given an empty list, what are you to do?
01:01:26 <mauke> cry
01:01:27 <TSC> Panic?
01:01:27 <sorear> die messily
01:01:35 <sorear> @ty head
01:01:37 <lambdabot> forall a. [a] -> a
01:01:38 <sorear> > head []
01:01:39 <lambdabot>  Exception: Prelude.head: empty list
01:01:46 <sorear> @quote spryng
01:01:47 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
01:01:51 <goltrpoat> tiglionabbit:  what do you mean exactly?
01:02:02 <tiglionabbit> exactly that
01:02:08 <tiglionabbit> there really isn't anything I can do then :P
01:02:09 <goltrpoat> oh
01:02:11 <TSC> Return "Maybe a"
01:02:12 <goltrpoat> well, there you go then
01:02:12 <goltrpoat> hehe
01:02:21 <sorear> tiglionabbit: _|_ (excpetions, nontermination, and everything that isn't a value) inhabits *every* type.
01:02:23 <tiglionabbit> yeah, I was thinking that
01:02:30 <tiglionabbit> but then the caller has to expect Justs
01:02:45 <TSC> Yes (:
01:03:33 <tiglionabbit> btw, is there a site with some IO monad examples?
01:03:46 <tiglionabbit> I'm having trouble figuring out how to do anything useful
01:03:54 <sorear> @wiki IO_inside
01:03:54 <lambdabot> http://www.haskell.org/haskellwiki/IO_inside
01:04:03 <sorear> oh, do something useful
01:04:17 <tiglionabbit> well first off, I want to see how you write cat in haskell
01:04:27 <dons> main = interact id
01:04:30 <sorear> @wiki Blog_articles -- dons had a thing on writing full BSD cat in haskell
01:04:30 <lambdabot> http://www.haskell.org/haskellwiki/Blog_articles -- dons had a thing on writing full BSD cat in haskell
01:04:39 <dons> ?go simple unix tools in haskell
01:04:41 <lambdabot> http://haskell.org/haskellwiki/Simple_unix_tools
01:04:41 <lambdabot> Title: Simple unix tools - HaskellWiki
01:05:26 <dons> tiglionabbit: so you do this:
01:05:27 <dons> $ vim A.hs
01:05:29 <dons> $ ghc -O A.hs
01:05:38 <dons> $ ./a.out < A.hs
01:05:38 <dons> main = interact id
01:05:43 <dons> and you have written 'cat' in haskell
01:06:33 <tiglionabbit> interact?
01:06:48 <goltrpoat> on that note, that bash hack by joahim breitner was pretty cool
01:06:58 <dons> for the full story, see here (an implementation of GNU cat), http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/18#ph-3
01:06:58 <lambdabot> Title: Haskell hacking
01:07:01 <goltrpoat> joachim, too
01:07:05 <dons> :t interact
01:07:08 <lambdabot> (String -> String) -> IO ()
01:07:20 <dons> its a function that takes a function as an argument, and uses that to transform stdin
01:07:25 <dons> the result is sent to stdout
01:07:25 <ivanm> @t interact
01:07:26 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
01:07:38 <ivanm> @type interact
01:07:38 <tiglionabbit> ...
01:07:40 <lambdabot> (String -> String) -> IO ()
01:08:05 <dons> so, main = interact id -- is cat
01:08:17 <dons> main = interact (unlines . reverse . lines) -- is tac
01:08:28 <tiglionabbit> what does interact do?  er..  *hoogles*
01:08:29 <dons> main = interact (unlines . sort . lines) -- is sort
01:08:36 <dons> I just explained it :-)
01:08:39 <dons> ?src interact
01:08:39 <lambdabot> interact f = do s <- getContents; putStr (f s)
01:08:52 <tiglionabbit> getContents?
01:08:55 <dons> it takes a chunk of code as an argument, gets stdin, applies that code to the result, writes it to stdout
01:08:59 <tiglionabbit> (I'm very new to this)
01:09:06 <dons> its ok :)
01:09:09 <dons> see the src above
01:09:15 <nornagon> @src getContents
01:09:15 <lambdabot> getContents = hGetContents stdin
01:09:29 <ivanm> @src hGetContents
01:09:30 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:09:31 <tiglionabbit> ?src hGetContents
01:09:31 <lambdabot> Source not found. That's something I cannot allow to happen.
01:09:35 <tiglionabbit> =\
01:09:39 <dons> its a bit too low level
01:09:40 <tiglionabbit> builtin?
01:09:43 <tiglionabbit> okay
01:09:48 <nornagon> hGetContents gets the contents of some file handle
01:09:50 <dons> hGetContents reads a handle, returning a string
01:09:51 <nornagon> (lazily)
01:09:54 <dons> :t hGetContents
01:09:54 <tiglionabbit> the word 'stdin' there comforts me
01:09:56 <lambdabot> Not in scope: `hGetContents'
01:09:58 <ivanm> :t hGetContents
01:10:00 <lambdabot> Not in scope: `hGetContents'
01:10:09 <dons> :t System.IO.hGetContents
01:10:11 <lambdabot> GHC.IOBase.Handle -> IO String
01:10:29 <dons> so getContents is hGetContents applied to 'stdin', the stdin Handle
01:10:40 <dons> ?src getContents
01:10:40 <lambdabot> getContents = hGetContents stdin
01:10:43 <dons> as you can see.
01:10:49 <dons> now, interact then is:
01:10:51 <sorear> yay! Ayhi.BCLoader just suceeded in loading 'foreign import ccall ayhi_exit :: Int -> IO () ; main = ayhi_exit 42'
01:10:51 <dons> ?src interact
01:10:52 <lambdabot> interact f = do s <- getContents; putStr (f s)
01:10:54 <tiglionabbit> I must say haskell is the most differentest language I have seen...
01:11:14 <dons> well, that's true
01:11:22 <dons> not many languages have their core libraries as one liners
01:11:36 <tiglionabbit> are there more sophisticated graphics (opengl) toolkits for haskell than wrapping glut?
01:11:59 <ivanm> see, Haskell is so powerful that complex library functions are just one liners! ;)
01:12:00 <dons> yeah, there's OpenGL/Glut
01:12:01 <dons> and gtk2hs
01:12:08 <dons> ?where gtk2hs
01:12:08 <lambdabot> http://haskell.org/gtk2hs/
01:12:16 <dons> and the GLUT bindings are in the core libraries
01:12:22 <dons> see frag, the 3d game for a nice example
01:12:24 <dons> ?where Frag
01:12:25 <lambdabot> http://www.haskell.org/haskellwiki/Frag
01:12:44 <ivanm> Frag didn't work for me... to slow
01:12:46 <goltrpoat>  /whois tiglionabbit
01:12:49 <ivanm> then again, I might have xorg issues
01:12:51 <goltrpoat> er.
01:12:53 <goltrpoat> thank you, spacebar.
01:12:56 <ivanm> lol
01:12:57 <dons> ivanm, you should have a recent graphics card
01:13:04 <ivanm> how recent is "recent"
01:13:12 * ivanm has a Radeon Mobility 9000
01:13:18 <dons> lsat couple of years. it uses some newer extensions.
01:13:32 <dons> btw, that's the first speed complaint i've ever heard about frag.
01:13:34 <dons> which is nice.
01:13:38 <ivanm> Well, mine was cutting edge from 2003 ;)
01:13:54 <dons> ah that might be why then
01:14:04 <ivanm> then again, I saw somewhere that for some reason it might be thinking its a Radeon FireGL :s
01:14:06 <dons> you need  OpenGL drivers that support the vertex array and multitexture OpenGL extensions
01:14:16 <ivanm> then, yeah, I'm probably out
01:15:05 <dons> tiglionabbit: so you've got ghc installed?
01:15:05 <ivanm> dons: btw, I finished that Latin Squares project I was doing over summer.  Interested in having a look at my code/paper?
01:15:13 <sorear> dons: I think I've found a source of yhc's performance problems
01:15:19 <dons> sure, ivanm
01:15:30 <dons> sorear: oh?
01:15:40 <goltrpoat> well, in all fairness, frag is using fairly old tech -- so speed complaints are difficult to expect, but at the same time, it should run ok on a radeon 9000, since comparable engines ran on those cards back then
01:15:48 <sorear> dons: I thought I could procrastinate on implementing the APPLY bytecode ... least efficient, most general case of application
01:15:56 <sorear> dons: main = ayhi_exit 42
01:16:05 <goltrpoat> in other words, it's not exactly a testament to frag being a speed beast
01:16:12 <tiglionabbit> dons: yep, playing around with ghci
01:16:15 <sorear> dons: should be able to use the special case MK_AP_0 code, but it isn't
01:16:34 <dons> oh, that's interesting.
01:17:07 <dons> tiglionabbit: so you can stick that 'main = interact id' straight in a file now, A.hs and compile it to a binary
01:17:13 <dons> that will run like any other unix program.
01:17:15 <dons> ghc -O A.hs
01:17:17 * tiglionabbit nods
01:17:45 <tiglionabbit> hey um, in ghci in windows, once I've got it doing something infinite, is there any way to make it stop and become usable again?
01:18:10 <dons> ^c on unix. so hmm, whatever's the equivalent on win32
01:18:18 <goltrpoat> that's a 6.6 bug, i think.  ctrl-c and ctrl-break used to work in 6.4
01:18:24 <tiglionabbit> would be the same, but that leaves the dos prompt broken
01:18:54 <sebell> tiglionabbit: Same way as it found it ;)
01:19:04 <dons> there's a wrapper i think some people use to get the right keycodes
01:19:22 <dons> here , http://haskell.org/haskellwiki/Windows
01:19:23 <lambdabot> Title: Windows - HaskellWiki
01:19:35 <dons> "When running GHC under a Cygwin shell on Windows, Ctrl-C sometimes doesn't work. A workaround is to use the rlwrap program to invoke ghci : In addition to proper Ctrl-C, you also get emacs (or vi) key bindings and command history across sessions, which saves you a load of typing."
01:19:56 <dons> "Using GHCi from a DOS box sucks. Using it from withing shell mode in Emacs sucks a lot less - do 'M-x shell' in emacs, then type 'ghci'."
01:20:00 <sorear> should be : NEED_HEAP_32 | PUSH_INT 42 | MK_AP_0 | RETURN_EVAL
01:20:21 <rahikkala> rlwrap is love
01:20:27 <dons> ?google rlwrap
01:20:30 <lambdabot> http://utopia.knoware.nl/~hlub/rlwrap/
01:20:30 <lambdabot> Title: rlwrap, Emacs midi-input and p5httpd
01:20:37 <sorear> is: NEED_HEAP_32 | PUSH_INT 42 | PUSH_CONST 0 | EVAL | NEED_HEAP_32 | APPLY_1 | NEED_HEAP_32 | RETURN_EVAL
01:20:38 <dons> oh?
01:20:42 <dons> sorear: ah.
01:20:48 <dons> bug report (or can you fix it?)
01:20:53 <goltrpoat> why does it suck?  it's more or less functionally the same as invoking it from the command line in unix.  it's just that ctrl-c stops execution in linux at least, and hangs ghci in windows
01:20:54 <goltrpoat> hehe
01:20:59 * sorear wishes for yhc bytecode disassembler
01:21:25 <sorear> dons: Would this be lumped under the "Yhc has no optimizer" feature-bug?
01:21:31 <dons> hmm.
01:21:38 <tiglionabbit> goltrpoat: the history behaves like dos as well-- not as smart as bash
01:21:49 <dons> yes, i suppose. or more that the code gen is a bit broken.
01:21:51 <goltrpoat> history persists between sessions
01:21:58 <tiglionabbit> ?
01:22:02 <goltrpoat> in dos
01:22:04 <tiglionabbit> I mean pressing up and down
01:22:07 <dons> sorear: i guess it doesn't explain the theory that yhc is 20% faster than yhc
01:22:07 <goltrpoat> yeah
01:22:20 <goltrpoat> not so in linux
01:22:29 <goltrpoat> so i'd say that part is actually nicer in dos
01:22:45 <ivanm> goltrpoat: isn't that what .bash_history is meant to do?
01:22:46 <tiglionabbit> *shrug*
01:22:53 <mauke> my history persists
01:23:15 <sorear> mine too
01:23:26 <goltrpoat> hmm
01:24:16 <goltrpoat> not here it doesn't
01:24:30 <tiglionabbit> so, I don't have emacs
01:24:33 <tiglionabbit> vim work?
01:24:46 <sorear> dons: oh, silly me, notabug, l5 is a CAF for some reason :(
01:25:30 <tiglionabbit> hm
01:25:59 <tiglionabbit> invoking ghci from vim by saying :!ghci at least makes it not hang when I hit control-C
01:26:09 <tiglionabbit> instead it exits ghci and closes the window
01:26:18 <goltrpoat> hehe
01:26:51 <tiglionabbit> this gets the benefit that it's opening in the directory I'm editing my files in, too-- cool
01:35:36 <tiglionabbit> what do those .s do in the unix command examples?
01:36:00 <sorear> composition
01:36:18 <sorear> > ((\x -> x * 2) . (\y -> y + 10)) 20
01:36:20 <lambdabot>  60
01:37:28 <tiglionabbit> oh
01:38:53 <ivanm> dons: btw, do you know if its possible to do a dual computer science/maths honours at unsw?
01:39:18 <dons> a dual honours program?
01:39:22 <dons> or dual undergrad degree?
01:39:37 <dons> dual CS/Math undergrad is possible, yeah.
01:39:45 <ivanm> dual honours
01:40:04 <dons> so the honours year, with what, credits to both a CS or Math BSc?
01:40:06 <ivanm> I'm considering going interstate (from UQ) for honours, and trying to work out if its possible
01:40:13 <ivanm> something like that
01:40:26 <dons> seems possible, if you talk to someone
01:40:32 <dons> wouldn't be impossibly, anyway
01:41:01 <ivanm> I found this page: http://www.handbook.unsw.edu.au/undergraduate/courses/2007/MATH4003.html
01:41:03 <lambdabot> Title: UNSW Handbook Course - Mathematics and Computer Science Honours (Full Time) - MA ..., http://tinyurl.com/2x2vbq
01:41:11 <ivanm> just not sure about coming in from interstate
01:41:26 <ivanm> cos it seems to be from an accelerated degree
01:42:40 <dons> you'd have to ask one of the program coordinators
01:43:10 <ivanm> OK, thanks
01:43:26 <ivanm> UQ advertises a dual comp sci/maths honours, but no one seems to have any idea what it is :(
01:46:08 <stmartin> I'm working through 'Haskell: The Craft of Functional Programming, 2nd Ed.', and I'm supposed to use fromInt to convert an Int to a Float, except neither Hugs Sept2006 nor GHC 6.6 seem to recognise it. What should I do?
01:46:20 <sorear> fromIntegral
01:46:21 <augustss> fromIntegral
01:46:43 <stmartin> Thanks. Does that work the same with Int and Integers or something?
01:46:50 <augustss> yes
01:46:50 <sorear> yeah
01:47:11 <augustss> @quote stereo
01:47:11 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
01:47:39 * sorear narrowly decided against doing that, at almost the same time
01:49:16 <malcolmw> dons: are the results for the older version of yhc up on the nobench webpage yet?
01:49:48 <dons> i was unable to get it working.
01:50:11 <malcolmw> couldn't compile, or couldn't run any programs?
01:50:12 <dons> the main issues is that it is missing getArgs, the second issues was that even without it the binaries broke
01:50:47 <ClaudiusMaximus> @hoogle Int -> [a] -> [[a]]
01:50:48 <lambdabot> No matches, try a more general search
01:50:56 <ClaudiusMaximus> @hoogle Integer -> [a] -> [[a]]
01:50:57 <lambdabot> No matches, try a more general search
01:51:29 <augustss> @hoogle Int -> a -> [a]
01:51:29 <lambdabot> Prelude.replicate :: Int -> a -> [a]
01:51:38 <dons> so nhc98 wins this round, malcolmw
01:52:00 <dons> augustss: so where's this hbc darcs repo? :-) /me wants to test some lambda warez
01:52:19 <dons> gotta keep SimonM on his toes.
01:52:35 <malcolmw> dons: I wonder if it would be worth me spending a little time patching the ancient version of yhc just to get benchmarks out
01:52:41 <augustss> dons: it should be at darcs.augustsson.net/Darcs/hbc
01:53:04 <augustss> dons: it probably needs some patches to compile on linux
01:53:13 <ClaudiusMaximus> i want a function that groups a list into sublists of equal numbers, like munge 2 [1, 2, 3, 4] = [ [ 1, 2 ], [ 3, 4 ] ]
01:53:25 <ClaudiusMaximus> s/numbers/length/
01:53:34 <augustss> ClaudiusMaximus: there is none predefined :(
01:54:02 <dons> malcolmw: hmm, up to you. i didn't try to debug the segfaulting binaries. since we can't run this old yhc, i'll just assume it never existed for now
01:54:07 <ClaudiusMaximus> i'm sure i've seen it defined in this channel before, though
01:54:30 <dons> augustss: ok. looking
01:54:46 <augustss> ClaudiusMaximus: unfoldr (\ l -> if null l then Nothing else Just $ splitAt n l)
01:54:58 <malcolmw> augustss: got it working on your Mac yet?
01:55:29 <TSC> ClaudiusMaximus: chunk _ [] = []
01:55:30 <TSC> chunk n xs = let (a,b) = splitAt n xs in a : (chunk n b)
01:55:34 <augustss> malcolmw: no, i've not really had any spare time the last week
01:55:58 <malcolmw> augustss: your mac is an intel anyway though
01:56:03 <augustss> malcolmw: yes
01:58:39 <ClaudiusMaximus> augustss++  (solution seems concise, but i don't 'get' unfoldr)
01:58:40 <ClaudiusMaximus> TSC++  (this solution seems easier to comprehend for me)
02:02:51 <tiglionabbit> oof.  When I try to compile cat on my campus' unix server, it says this: http://pastie.caboo.se/44406
02:02:53 <lambdabot> Title: #44406 - Pastie
02:03:52 <tiglionabbit> am I doing something wrong?
02:04:53 <dons> tiglionabbit: hmm. ooks like and old ghc with a broken installation
02:04:57 <dons> not your fault at all
02:05:14 <dons> try: ghc -O -fasm cat.hs
02:06:37 <ski> (malcolmw : 'it' being hbc ?)
02:07:04 <malcolmw> ski: yes
02:07:14 <ClaudiusMaximus> > [ (a,b) | a <- [0..2], b <- [0..2], a /= b ]  -- is this syntax allowed?
02:07:16 <lambdabot>  [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]
02:07:25 <ClaudiusMaximus> @botsnack
02:07:26 <lambdabot> :)
02:07:41 <dons> ClaudiusMaximus: were you just guessing ?
02:07:46 <nornagon> hmm
02:07:48 <ClaudiusMaximus> dons: yeah
02:07:52 <dons> cool
02:08:02 <dons> intuitive syntax rocks
02:08:22 <ClaudiusMaximus> dons: or maybe i saw it in 2000/2001 when i last studied haskell formally...
02:08:38 <tiglionabbit> http://pastie.caboo.se/44407
02:08:40 <lambdabot> Title: #44407 - Pastie
02:08:51 <nornagon> > [(a,b) | a <- ['a','b','c'], b <- ['a','b','c'], a < b]
02:08:52 <lambdabot>  [('a','b'),('a','c'),('b','c')]
02:09:04 <nornagon> > [[a,b] | a <- ['a','b','c'], b <- ['a','b','c'], a < b]
02:09:05 <lambdabot>  ["ab","ac","bc"]
02:09:23 <dons> tiglionabbit: good idea to use hpaste.org for haskell pastes, its a bit faster, and you get syntax hghlighting
02:09:23 <nornagon> > [[a,b] | a <- ['a'..'z'], b <- ['a'..'z'], a < b]
02:09:25 <lambdabot>  ["ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao","ap",...
02:09:39 <dons> tiglionabbit: hmm. what operating system?
02:09:45 <dons> what architecture?
02:09:52 <tiglionabbit> dons: okay thanks.  But I figured since this is plain text it wouldn't matter.  This is on solaris
02:10:00 <tiglionabbit> sparc
02:10:04 <tiglionabbit> I believe
02:10:14 <dons> ah looks like the ghc install there is broken though. its missing some header files
02:10:24 <tiglionabbit> yep
02:10:35 <dons> any chance you have access to say, a linux box? or you could put a new ghc on the machine?
02:10:43 <tiglionabbit> it's also missing any manuals :P
02:10:52 <dons> sparc/solaris is unmaintained, afaik
02:11:00 <dons> does ghci work?
02:11:05 <tiglionabbit> yes
02:11:14 <tiglionabbit> but I can't use io in ghci
02:11:29 <tiglionabbit> well, I can load a file that uses it though
02:12:49 <dons> do you have the program 'runhaskell' ?
02:13:20 <dons> (you can , btw, run your code like so:
02:13:23 <dons> $ ghci -v0 cat.hs
02:13:23 <dons> *Main> main
02:13:23 <dons> xx
02:13:23 <dons> dd
02:13:31 <dons> but that only works around the broken ghc
02:15:29 <tiglionabbit> whoa crazy--   running cat like that makes it respond on every character rather than line
02:15:34 <tiglionabbit> so it doubles my characters
02:15:58 <dons> yep, its char-at-a-time cat
02:16:02 <dons> unbuffered
02:17:37 <tiglionabbit> also when I try and run a program that uses 'io' it says Not in scop: `io'
02:18:00 <tiglionabbit> *scope
02:18:10 <tiglionabbit> even if I import System.IO
02:18:13 <dons> oh, from that article?
02:18:14 <tiglionabbit> like in the examples
02:18:21 <dons> the 'io' function is defined at the top of that page
02:18:30 <dons> its a wrapper over interact
02:18:32 <tiglionabbit> oh whoops
02:18:53 <tiglionabbit> I thought that was standard
02:19:02 <stmartin> Can 'where' be used in a guarded function in order to calculate values used in the guards?
02:20:02 <dons> yeah
02:20:20 <stmartin> @paste
02:20:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:20:55 <dons> f x
02:20:55 <dons>   | y /= x    = True
02:20:55 <dons>   | otherwise = False
02:20:55 <dons>   where
02:20:55 <dons>     y = -x
02:21:33 <stmartin> Ah, yes I see where I went wrong now. Thanks.
02:23:53 <tiglionabbit> :src unlines
02:24:36 <tiglionabbit> ?src unlines
02:24:37 <lambdabot> unlines = concatMap (++ "\n")
02:24:47 <tiglionabbit> ?src concatMap
02:24:48 <lambdabot> concatMap f = foldr ((++) . f) []
02:24:54 <tiglionabbit> Lsrc foldr
02:25:01 <tiglionabbit> ?src foldr
02:25:01 <lambdabot> foldr k z xs = go xs
02:25:01 <lambdabot>     where go []     = z
02:25:01 <lambdabot>           go (y:ys) = y `k` go ys
02:25:05 <mnislaih> has anyone tried on hacking the gameboy emulator ?
02:35:57 <stmartin> Is there a way of saying Infinity when talking about Ints in Haskell?
02:37:46 <dons> > 1/0 -- ?
02:37:47 <Jaak> @type 1/0
02:37:48 <lambdabot>  Infinity
02:37:49 <lambdabot> forall t. (Fractional t) => t
02:37:59 <ClaudiusMaximus> > (maxBound :: Int) + 1
02:38:00 <dons> > 1/0 == 1/0
02:38:00 <lambdabot>  -2147483648
02:38:01 <lambdabot>  True
02:38:27 <nornagon> > 1%0
02:38:28 <lambdabot>  Exception: Ratio.%: zero denominator
02:45:10 <stmartin> I guess it would either have to a Fractional Int or a Monad or something.... Oh well, -1 will do for now.
02:46:40 <uccus> join #haskell
02:50:04 <_roconnor> bind #haskell
02:52:17 <rahikkala> return #haskell
02:52:39 <mauke> fmap #haskell
02:55:08 <nornagon> ap #haskell
02:55:08 <vdrab> hello #haskell, I was wondering, how far along is haskell's unicode support these days? I tried googling but couldn't really find anything conclusive? Also, does Bytestring do encodings?
02:56:57 <uccus> c'mon guys I didn't notice I'm already in
02:57:16 <Saizan> udrab: ByteString just truncates
02:57:32 <Saizan> ?docs Data.Binary
02:57:33 <lambdabot> Data.Binary not available
02:59:33 <vdrab> saizan, so you 're pretty much on your own?
03:00:54 <Saizan> well there are some UTF8.hs modules not packaged out there
03:01:19 <Saizan> both in lambdabot and in darcs
03:02:42 <kowey> vdrab: http://www.haskell.org/haskellwiki/UTF-8 <-- this may help
03:02:44 <lambdabot> Title: UTF-8 - HaskellWiki
03:02:51 <nornagon> @wiki UTF-8
03:02:51 <lambdabot> http://www.haskell.org/haskellwiki/UTF-8
03:03:10 <kowey> you might consider bugging pesco about cabalising and packaging his utf-8 stuff (it's what this example code uses)
03:03:26 <ClaudiusMaximus> > "♩♬♫♩♪♩"  -- UTF-8 test
03:03:27 <lambdabot>  "\9833\9836\9835\9833\9834\9833"
03:03:42 <vdrab> I have a project that requires processing a few Gb of text, but it's all in Japanese... So I'm kind of wondering whether to go with python, or give it a go in Haskell anyway...
03:03:43 <Saizan> ah, also the Char Binary instance converts to utf9
03:03:49 <vdrab> wow, that's pretty neat
03:03:49 <Saizan> err utfo
03:03:53 <Saizan> utf8
03:04:14 <kowey> http://en.wikipedia.org/wiki/UTF-9_and_UTF-18
03:04:19 <Saizan> well Char is 32bit
03:05:32 <vdrab> so, utf-8 is possible for Strings and Binary Chars, but not Bytestring? is that correct?
03:06:26 <Saizan> vdrab a BysteString is just a sequence of Word8, you can put an utf8 in it
03:07:30 <vdrab> Saizan, i thought utf-8 didn't have a fixed byte size
03:08:13 <Saizan> vdrab, afaik it's more like each character can be splitted in more than one byte
03:08:53 <vdrab> the ascii range chars fit in one byte, but for CJK languages, you need up to three bytes, in some cases
03:09:02 <Saizan> yeah
03:09:16 <Saizan> but you can just put them one after the other
03:09:26 <vdrab> so, it'd be nice to have a library that takes care of all the low-level byte fiddling...
03:09:33 <vdrab> true
03:11:02 <vdrab> if it turns out there's no such thing available, i'm afraid I 'll have to go with python or something like that ... :(
03:11:35 <vdrab> maybe some of the other Japanese encodings, like EUC...?
03:11:37 <Saizan> well in Data.Binary the instance of Char does that
03:11:57 <vdrab> oh,... guess we'll have a look at that then
03:14:55 <Saizan> http://dev.pugscode.org/browser/src/UTF8.hs?rev=15410 <-- or maybe you can just "steal" this module :)
03:14:59 <lambdabot> Title: /src/UTF8.hs - Pugs - Trac
03:15:51 <solcom> is there anyway to stop GHCi when it gets stuck in a recursive loop other than closing it?
03:16:08 <mauke> ^C
03:16:36 <solcom> what does the ^ stand for?
03:16:37 <vdrab> Saizan: sweet! thanks for the pointer
03:16:48 <mauke> control
03:16:53 <solcom> ah cheers
03:23:51 <dons> stefanha: don't use -1, use Maybe a or Nothing if possible
03:31:51 <malcolmw> stefanha: the Haskell/SIMD project has been firmly allocated to you now
03:48:37 <david_> hello
03:49:02 <david_> seems like a stupid question, but how do I divide an integer ?
03:49:09 <xerox> ?type div
03:49:12 <lambdabot> forall a. (Integral a) => a -> a -> a
03:49:16 <malcolmw> > 4 `div` 2
03:49:17 <lambdabot>  2
03:49:21 <nornagon> > 2 `div` 4
03:49:22 <lambdabot>  0
03:49:23 <david_> let z = ( 21 :: Int ) / 5 gives an error
03:49:26 <xerox> Use this if you have got another integer to divide it with.
03:49:43 <xerox> ?type \x -> fromIntegral x / 2.3
03:49:46 <lambdabot> forall a b. (Integral a, Fractional b) => a -> b
03:49:57 <xerox> This other in case you have a non-integral value.
03:51:06 <david_> thanks !
03:51:13 <xerox> You're welcome !
03:51:35 <david_> now is there a way to shift right an integer ?
03:51:45 <xerox> ?type Data.Bits.shiftR
03:51:48 <lambdabot> forall a. (Bits a) => a -> Int -> a
03:51:55 <xerox> ?docs Data.Bits
03:51:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
03:52:00 <xerox> There you go.
03:52:42 <david_> thanks again !
03:52:50 <xerox> :)
03:56:55 <roconnor> is there a library for making http requests?
03:57:40 <xerox> Yep.
03:57:45 <xerox> http://haskell.org/http/
03:57:45 <lambdabot> Title: Haskell HTTP package
03:58:12 <xerox> I think you can find it in Hackage too.
03:58:22 <roconnor> oooh get uri
03:59:13 <Jaak> > takeWhile (/= 0) $ iterate (`shiftR` 1) (2^16)
03:59:13 <lambdabot>  Add a type signature
03:59:15 <roconnor> looks good
03:59:18 <Jaak> > takeWhile (/= 0) $ iterate (`shiftR` 1) (2^16 :: Int)
03:59:20 <lambdabot>  [65536,32768,16384,8192,4096,2048,1024,512,256,128,64,32,16,8,4,2,1]
04:05:11 <nornagon> :t shiftR
04:05:13 <lambdabot> forall a. (Bits a) => a -> Int -> a
04:05:22 <nornagon> @instances Bits
04:05:23 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
04:05:29 <nornagon> @instances-importing Bits
04:05:30 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
04:05:51 <mauke> @help instances-importing
04:05:52 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
04:06:08 <mauke> @instances-importing Data.Bits Bits
04:06:09 <lambdabot> Int, Integer
04:51:41 <matthew-_> um, how does # work in the type sigs for tuples?
04:52:16 <matthew-_> I'm trying to return, eg, (# 4, 6 #) and so I have the type like (# Int, Int #) but it seems not to like that
04:52:36 <matthew-_> eg I get errors like
04:52:36 <matthew-_>     Couldn't match kind `*' against `(#)'
04:52:37 <matthew-_>     When matching the kinds of `a :: *' and
04:52:37 <matthew-_>                                `(# Int, [(a1, Vector3D, Double)] #) :: (#)'
04:53:16 <Lemmih> Why do you want to return an unboxed tuple?
04:53:17 <lambdabot> Lemmih: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:53:20 <dons> that's an unboxed tuple :-)
04:53:36 <dons> they're limited in their use, basically you can only string them along with case statements
04:54:13 <matthew-_> Lemmih: for speed
04:54:40 <matthew-_> yeah, I know they're limited, but I can't see where I'm going wrong vs http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html#unboxed-tuples
04:54:42 <lambdabot> Title: 7.2. Unboxed types and primitive operations, http://tinyurl.com/y59rbr
04:54:44 <malcolmw> I think unboxed tuples can only contain unboxed values, so (# 4#, 6# #) perhaps?
04:55:34 <dons> :t (# 7, 'x' #)
04:55:37 <lambdabot> forall t. (Num t) => (# t, Char #)
04:56:02 <dons> :t case (# 7, 'x' #) of (# x , y #) -> y
04:56:04 <lambdabot> Char
04:56:13 <Igloo> If possible you should write using boxed tuples and let GHC optimise it to unboxed tuples
04:56:38 <matthew-_> Igloo, yeah I know. Sometimes I need a bigger hammer though.
04:56:46 <dons> ghc never optimises to unboxed pairs does it? they always turn into x# y# pairs for me
04:56:59 <dons> matthew-_: hmm, i've never needed to introduce (# , #) for performance reasons
04:57:08 <dons> only when using primops inside IO which require them
04:57:19 <Igloo> dons: but presumably unboxed tuples would be optimised into the same thing
04:57:38 <dons> s/pairs/ (Int,Int)  becomes  Int# -> Int# -> ...
04:57:56 <dons> as arguments, on return values they stay boxed
04:58:20 <matthew-_> mmm. I've seen ghc return unboxed through -ddump-simpl
04:58:39 <dons> you'll see them when IO stuff is unwrapped
04:58:42 <dons> ?src IO
04:58:42 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
04:58:46 <dons> due to that
04:59:12 <matthew-_> ahh right.
05:00:00 <matthew-_> $w is for the worker right?
05:00:00 <matthew-_> OctTree.$wfindInRadius :: forall a_aiW.
05:00:22 <dons> yeah
05:00:28 <matthew-_> in which case ghc is unboxing it automatically as the result type is   -> (# GHC.Base.Int, [(a_aiW, Base.Types.Vector3D, GHC.Float.Double)] #)
05:00:59 <dons> oh, interesting!
05:01:14 <matthew-_> but only on the worker
05:01:23 <matthew-_> the nonworker does not unbox
05:02:10 <malcolmw> Igloo: I fixed my darcs problem on MacOS by upgrading to a newer binary, but the same thing persists on Solaris, regardless of darcs version.  I'm pretty sure it is a bug in the version of libcurl that is statically linked in.
05:02:30 <matthew-_> dons, oh, that might be only if you do a let (a,b) = blah in (a,b)
05:02:35 <Igloo> malcolmw: Are you sure libcurl is statically linked in?
05:03:14 <malcolmw> Igloo: yes, sure.  There is a dyn-linked one too, but my solaris box doesn't have libcurl installed.
05:03:34 <Igloo> malcolmw: But it can call wget instead, for example
05:04:02 <malcolmw> Igloo: yeah, I have wget, but don't know how to force darcs to use it in preference to curl
05:04:10 <malcolmw> rebuild?
05:05:10 * matthew-_ swears at ghc
05:05:31 <matthew-_> even with bang patterns there's a double I'm passing around which it won't unbox
05:05:33 <Igloo> Rebuilding on a machine without libcurl certainly ought to do it
05:06:58 <malcolmw> Igloo: will give it a try, although building software on Solaris is often tricky (in the absence of lots of common libraries and utils)
05:09:23 <dons> matthew-_: hmm. odd. you could manually unbox that double
05:09:33 <dons> but sounds like something is amiss
05:12:48 <hpaste>  matthew-_ pasted "feel free to manually unbox the tuples such that ghc doesn't complain." at http://hpaste.org/774
05:18:13 <dons> Vector3D is strict?
05:18:16 <Igloo> matthew-_: Why not have !s in the Vec3 type definition?
05:18:29 <dons> you're using -fexcess-precision in the pragma?
05:18:56 <matthew-_> dons: data Vector3D = Vec3 !Double !Double !Double
05:19:11 <dons> -funbox-strict-fields?
05:19:13 <matthew-_> dons: yes, -fexcess-precision is on
05:19:16 <matthew-_> yes
05:19:29 <dons> the bang patterns shouldn't be needed. what doe sthe core look like?
05:19:45 <hpaste>  matthew-_ annotated "feel free to manually unbox the tuples such that ghc doesn't complain." with "flags for ghc" at http://hpaste.org/774#a1
05:20:07 <matthew-_> dons: core?
05:20:26 <dons> yeah, the -ddump-simpl output for the bit you're trying to tweak?
05:21:24 <hpaste>  matthew-_ annotated "feel free to manually unbox the tuples such that ghc doesn't complain." with "-ddump-simpl" at http://hpaste.org/774#a2
05:22:04 <matthew-_> mmm. wah. I think hpaste just cropped that
05:22:20 <malcolmw> Igloo: configuring darcs I get a warning about term.h being present but not useable - it even says to mail a bug report to bugs@darcs.net.  And indeed, building darcs fails with parse errors in term.h, whilst compiling External.hs
05:22:22 <matthew-_> yes, it did.
05:22:25 <dons> glguy: i think the hpaste crop limit is too low
05:22:58 <dons> glguy: if we can't use it for debugging core stuff, then that's got to be fixed ;)
05:22:59 <hpaste>  matthew-_ annotated "feel free to manually unbox the tuples such that ghc doesn't complain." with "the remaining -ddump-simpl what hpaste cropped" at http://hpaste.org/774#a3
05:23:32 <Igloo> malcolmw: Hmm, no idea about that
05:23:42 <dons> that looks fine, wfindInRadius'
05:24:03 <dons> foldl' should probably be inlined. interesting.
05:24:44 <Igloo> Why would inlining be beneficial?
05:24:51 <dons> the worker loop looks reasonable there matthew-_
05:25:17 <matthew-_> dons. yep. but why isn't there unboxing on the non-worker?
05:25:17 <dons> Igloo: maybe we'd be able to unbox the accumulator? just speculative
05:25:18 <Igloo> Or do you mean you want a new loop with foldl' fused with the function being folded?
05:25:25 <dons> matthew-_: because its the non worker
05:25:36 <dons> if you're exporting that function?
05:25:38 <Igloo> Hmm, that is true
05:25:40 <matthew-_> dons: you say that like it should mean something to me ;-)
05:25:51 <matthew-_> yep, the non-prime'd version is exported
05:26:10 <dons> right. so the wrapper has to be used with boxed types
05:26:12 <Igloo> matthew-_: The point of the non-worker is to provide the standard interface
05:26:15 <dons> that's fine though.
05:26:23 <Igloo> And it then does the unboxing and calls the worker
05:26:43 <matthew-_> and if it's unboxed at the call site the wrapper will be completely skipped?
05:26:49 <Igloo> Normally the worker will get inlined and then the boxing and unboxing will be eliminated at the callsite
05:26:54 <matthew-_> super
05:26:56 <matthew-_> ok
05:27:21 <dons> try adding an {-# INLINE foo #-} to the top level function, so the worker really will get inlined.
05:27:30 <dons> do you have numbers for why you're tuning this code?
05:27:34 <matthew-_> yep
05:27:42 <dons> and then, i'd look at timing the cost of that foldl'
05:27:49 <Igloo> But you should be able to tidy up the code a bit with data Vector3D = Vec3 !Int !Int !Int (or whatever) and changing things like !from@(Vec3 !_ !_ !_) to just !from
05:27:51 <dons> if its heavy, manually loop yourself
05:28:01 <matthew-_> ok.
05:28:08 <Igloo> Unless there are other times when you don't want strict field in a vector
05:28:14 <dons> yeah, you should get identical code without thos bang patterns everywhere
05:28:35 <matthew-_> I'm sure I've seen significant speed ups adding lots of bangs
05:29:02 <dons> quite possibly it does help, but most likely not all are needed :-)
05:29:02 <Igloo> If the type hasn't got strict fields then that would make sense
05:29:10 <dons> i too use a somewhat scattergun approach at first
05:29:15 <dons> then work out what is actually needed
05:29:47 <dons> you can sit in a loop though looking at the core, adding ! patterns, until the right core is produced
05:29:58 <dons> rather than adding them and timing the result, which is a bit more error prone
05:30:06 <dons> you need some idea of the core you want to generate though
05:30:14 <matthew-_> I've found that if you have foo :: Vector3D -> ... ; foo _ something = something ; foo (Vec3 x y z) _ = more_blah then the type wont get unboxed
05:30:31 <matthew-_> thus you need the (Vec3 !_ !_ !_) in the first _ pattern to ensure it's unboxed
05:30:35 <chessguy> @pl \n p f -> n p (m e f)
05:30:36 <lambdabot> flip flip (m e) . ((.) .)
05:30:45 <dons> oh, that's interesting. you're using -O2?
05:30:47 <chessguy> 'morning, haskellers
05:30:48 <matthew-_> yep
05:31:04 <Igloo> Just !_ should suffice
05:31:14 <dons> i think i've seen that once before. it might even be bug report worthy if !_ doesn't work
05:31:34 <matthew-_> ok, I'll see whether I can force that to happen.
05:32:20 <dons> and then think about that foldl'
05:32:46 <dons> but do so with {-# SCC #-} data so you know how much it costs
05:32:53 <matthew-_> ok - you'd consider replacing it with explicit recursion?
05:33:06 <chessguy> @pl \f xs -> map (\x -> (x, f x)) xs
05:33:06 <lambdabot> map . ap (,)
05:33:23 <xerox> :t map . second
05:33:25 <lambdabot> forall b c d. (b -> c) -> [(d, b)] -> [(d, c)]
05:33:26 <matthew-_> SCC?
05:33:48 <chessguy> @ty map . ap (,)
05:33:50 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
05:34:02 <chessguy> not quite, xerox ;)
05:34:12 <xerox> :t map . (id &&&)
05:34:14 <dons> matthew-_: yeah, you can profile individual subexpressions with {-# SCC "foo" #-} on that line
05:34:14 <lambdabot> forall a c'. (a -> c') -> [a] -> [(a, c')]
05:34:26 <dons> then you get costs tagged for everything to the right of the pragma
05:34:34 <dons> and yes, i'd consider manually looping there
05:34:49 <matthew-_> ahh. cool. is scc in the ghc user manual on profiling ?
05:34:50 <dons> in fact, since this is an inner loop, i wouldn't even consider foldl' :-)
05:34:57 <dons> yeah , i think so
05:35:15 <matthew-_> yup. http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html#id3159559
05:35:17 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/kwh6c
05:36:13 <matthew-_> dons: ok, that sounds like you have rules of thumb for when to use foldl' and when not. What's the deal regarding top level functions?
05:36:38 <nornagon> :t foldl'
05:36:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:36:46 <nornagon> :t foldl
05:36:49 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:37:02 <nornagon> difference?
05:37:23 <matthew-_> strictness
05:37:38 <matthew-_> foldl' is strict. foldl isn't
05:37:38 <nornagon> ah.
05:39:32 <dons> for inner loops, and those involving doubles, where performance is crucial , i hand write my loops
05:39:45 <dons> that's how you catch C ;)
05:40:13 <dons> if a structure is of a known small length, pass it as arguments, rather than a list, tricks like that
05:40:53 <ClaudiusMaximus> dons: that's how you catch C ;)  -- you make C sound like a disease...
05:41:03 <dons> well...
05:41:37 <ClaudiusMaximus> not that i would disagree ;)
05:42:34 <dons> C serves us well for what it does
05:43:11 <matthew-_> with 6.8, is viaC or viaASM or something else going to give the best performance most of the time?
05:43:19 <dons> what arch?
05:43:45 <dons> amd64 I think -fasm might just win out.
05:43:45 <sieni> if you actually have to write C code for living, then you _know_ that it's a disease :-)
05:43:53 <dons> its only a percent or two either way though
05:43:55 <matthew-_> and x86?
05:44:09 <dons> -fvia-C is probably still more consistent on x86.
05:44:35 <matthew-_> ok. is that because gcc does better optimisations for x86 than for amd64?
05:45:25 <dons> one issues is that ghc native backend doesn't use sse2 on x86
05:45:32 <dons> so some double math runs a lot slower
05:48:06 <dons> Igloo: oh, interesting, the 'pic' real program runs a fair bit faster under 6.6, than under the head, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
05:48:06 <lambdabot> Title: nobench: Haskell implementation shootout
05:48:18 <dons> after  increased the load so that we could see what was happening
05:48:56 <Igloo> increased the load == made it run for longer?
05:49:00 <dons> yeah
05:49:12 <dons> from N=1 to N=10000
05:49:18 <dons> so it actually registers a real running time
05:49:34 <Igloo> It looks like it is via-C that is faster than the NCG, though
05:49:53 <dons> oh, you mean in general?
05:50:03 <Igloo> No, I mean for that benchmark
05:50:17 <dons> hmm? 4.00 (1.0)4.03 (1.0)
05:50:34 <Igloo> Right, those are HEAD and 6.6 NCGs
05:50:34 <dons> close enough for me. -fvia-C is marginally better, some small thing
05:50:48 <Igloo> And 2.7 is 6.6 via-C
05:50:53 <dons> yes
05:51:13 <pejo> dons, do you see a way in the future to get rid of hand writing loops for performance?
05:51:23 * Igloo is confused now - so that isn't a case of 6.6 being faster than the HEAD, right?
05:51:31 <dons> pejo: fusion, and improved ghc
05:51:50 <dons> Igloo: hmm? Head -fvia-C 4s Head -fasm 4.03  6.6 -fvia 2.7s
05:52:23 <dons> oh looks like my version tags are wrong
05:52:27 <pejo> dons, a more general fusion than for bytestrings?
05:52:34 <dons> the results arecorrect, not the version tag at the bottom for ghc-asm, Igloo
05:52:46 <Igloo> Ah, OK  :-)
05:52:51 <dons> pejo: that system on steroids :-)
05:52:53 <dons> for lists
05:53:07 <Igloo> So are you explicitly using -fvia-C for the first column? -fasm should be the default now
05:53:24 <pejo> dons, crap. Is that described in the bytestring paper, or elsewhere?
05:53:30 <dons> yeah. i'm using it explicitly
05:53:48 <Igloo> dons: (and couldn't you autogenerate the key with ?hc -v?)
05:53:55 <dons> i could yes
05:54:09 <dons> i have a script, but it didn't know to ask for ghc-6.7.2000301
05:54:18 <ndm> runhaskell is just ghc --something, i suspect
05:54:26 <ndm> anyone have any idea what something is?
05:54:44 <ndm> the documentation doesn't seem to mention runhaskell at all...
05:54:45 <Igloo> ghc -e main would do the same thing, I think
05:55:34 <ndm> can ghc -e take a file to load up as well?
05:55:48 <ndm> I have already located ghc in the users path, so don't want to make more dependancies
05:55:56 <ndm> and can ghc find ghc-pkg with any flags?
05:56:09 <Igloo> Yes
05:56:13 <ndm> i am worried the user might select differing versions of ghc and ghc-pkg, which will make everything go wrong
05:56:29 <Igloo> And no to finding ghc-pkg
05:57:59 <ndm> C:\Documents\Uni\yhc\current>ghc obj\haskell\cpphs\Setup.hs -e main
05:58:01 <ndm> <interactive>: No command given (try --help)
05:59:10 <matthew-_> if you have a function with different patterns on the args, where do you put the SCC stuff so you can see which pattern costs what? is it a) before the pattern, b) after the =, or c) somewhere else?
05:59:12 <dons> $ ghc -e main A.hs
05:59:12 <dons> d
05:59:12 <dons> d
05:59:13 <ndm> oh, i see!
05:59:28 <ndm> that <interactive> message is being given by the Setup.hs
05:59:35 <dons> ah yes
05:59:38 <dons> configure :-)
05:59:42 <ndm> yep!
05:59:52 <ndm> now how do i pass "configure" as the command line args?
05:59:56 <ndm> to main
06:00:02 <dons> matthew-_: on the rhs of each case?
06:00:35 <matthew-_> what about if one of the cases then uses guards?
06:00:40 <dons> ndm, you compile Setup.hs ?
06:00:50 <ndm> dons: fair point, i guess
06:03:07 <chessguy> ?src gets
06:03:08 <lambdabot> Source not found. I feel much better now.
06:03:15 <chessguy> @type gets
06:03:17 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
06:06:08 <pejo> dons, is the list fusion described in the bytestring paper? :-)
06:08:58 <uccus> hello guys... right now I'm reading on FUNARG problem... and wondering how it is solved in Haskell... anyone knows anything about it?
06:09:14 <dons> pejo, not yet. the general technique is described in that paper though ,yes.
06:09:18 <chessguy> FUNARG?
06:09:48 <uccus> you know... the problems of implementing function tossing around in a stack based system
06:10:01 <ndm> grr, cabal is stupid - you can't run an installed setup.exe form anywhere but the current directory containing the .cabal file
06:10:57 <pejo> dons, thanks.
06:11:13 <sieni> uccus: doesn't like everybody solve it like "allocate everything you can in the stack and the rest in the heap"?
06:11:31 <uccus> wikipedia says O'Caml solves the problem by a hybrid approach, both stack-based calls and heaps... I would be surprized if Haskell didn't do it
06:11:52 <uccus> sieni: thanks, that's what I wanted to know, so Haskell does the same...?
06:12:03 <sieni> Haskell? Which Haskell?
06:12:11 <chessguy> ah, hadn't heard of that problem before
06:12:51 <uccus> :|
06:12:59 <uccus> GHC I suppose? 8-)
06:13:18 <uccus> I wonder what JHC does, does anyone know?
06:13:39 <pejo> uccus, (think this reference comes from ndm) - http://www.brics.dk/RS/01/23/BRICS-RS-01-23.pdf
06:14:02 <pejo> uccus, if "FUNARG" is the problem of implementing first class functions
06:14:22 <chessguy> i'm not sure i follow the type signature for gets. s is the type of state being carried around, right?
06:14:25 <uccus> yes it is, thanks
06:14:45 <xerox> chessguy: yes
06:15:10 <chessguy> :k MonadState
06:15:12 <lambdabot> Class `MonadState' used as a type
06:15:21 <xerox> gets f = fmap f get
06:15:39 <chessguy> shouldn't it be MonadState s a then?
06:16:04 <sieni> aaaargh, what an article: http://en.wikipedia.org/wiki/First-class_function
06:16:07 <sieni> O_O
06:16:21 <xerox> chessguy: MonadState is a constructor class
06:16:44 <sieni> Horrible crap
06:16:55 <uccus> isn't Object an entirely different concept?
06:17:01 <chessguy> xerox, fancy terms don't help :)
06:17:25 <uccus> sieni: the article you gave me looks very, very informative for me
06:17:30 <xerox> chessguy: neither does considering 's' and 'a' a monad.
06:17:44 <sieni> uccus: it has factual errors
06:17:47 <uccus> sieni: is this how YHC does it? :D I remember ndm talking about it
06:18:06 <chessguy> hmm
06:18:07 <uccus> sieni: which one... the paper? or the wikipedia article?
06:18:16 <sieni> the wikipedia article
06:18:21 <chessguy> what would be the signature of gets if it were written just for the State monad?
06:18:21 <sieni> "A different set of difficulties arises when programs can create functions at runtime; if the program is compiled, this means that the runtime environment must itself include a compiler."
06:18:23 <uccus> ah right
06:18:38 <ndm> uccus: no particular memory of Yhc does it
06:18:51 <xerox> chessguy: you might ask GHCi for `:m + Control.Monad.State' and `:info MonadState'.
06:18:58 <uccus> ndm: we are talking about defunctionalization...
06:19:20 <QtPlatypus> sieni: Isn't that only the case if you have an eval in your language,  and even then only if you use it.
06:19:22 <ndm> uccus: oh, in a special and unique way
06:19:26 <xerox> chessguy: the state monad is a multi-parameter typeclass.
06:19:46 <sieni> QtPlatypus: yes
06:19:47 <ndm> uccus: i hope to have that in -O in a few months
06:19:57 <uccus> okay... I should read through the paper first, thanks ndm
06:20:14 <uccus> do you have any paper on how Yhc defunctionalizes?
06:20:16 <sieni> how do you dispute the factual accuracy of a wikipedia article?
06:20:25 <xerox> chessguy: err, type.
06:20:51 <uccus> It has been suggested that this article or section be merged into First-class object. whoa!
06:20:59 <ndm> uccus: no, but it will be a thesis chapter by the end
06:21:05 <uccus> okay
06:22:10 <chessguy> @type gets
06:22:12 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
06:22:15 <xerox> chessguy: Monads are type constructors whose kind is * -> *. State's kind is * -> * -> *.
06:22:51 <chessguy> xerox, so the requirement MonadState s m essentially just means that m must be a State monad with type state, or something like it?
06:23:10 <xerox> Yes.
06:23:13 <int-e> @kind MonadState
06:23:16 <lambdabot> Class `MonadState' used as a type
06:23:35 <chessguy> ?instances MonadState
06:23:37 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
06:24:01 <xerox> chessguy: note that MonadState has got a functional dependency. Hence there is at most one `s' for each `m'.
06:27:20 <ski> evil
06:28:05 <toyo> anybody help me?
06:28:34 <uccus> sorry to interrupt again... so, in Haskell the problem (FUNARG) is solved by closures, but defunctionalization is possible. any caveat?
06:28:47 <ski> toyo : state your question/problem
06:29:13 <toyo> I made this program . do putStrLn "hoge"; a  <- getLine ; b<- getLine; putStrLn "fuga"
06:29:47 <toyo> Why the result of this program is  input,input ,then output "hoge" "fuga"
06:30:04 <toyo> I expected "hoge" input,input ,then "fuga"
06:30:42 <ski> that sounds strange
06:31:06 <mauke> block buffering?
06:31:18 <mauke> how do you enable line buffering in haskell?
06:32:18 <stefanha> hSetBuffering
06:32:18 <toyo> line buffering?
06:32:18 <ski> @type hSetBuffering
06:32:18 <lambdabot> Not in scope: `hSetBuffering'
06:32:18 <ski> @hoogle hSetBuffering
06:32:18 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
06:32:25 <ski> @hoogle BufferMode
06:32:25 <lambdabot> System.IO.BufferMode :: data BufferMode
06:32:38 <mauke> hSetBuffering stdout LineBuffering;
06:33:00 <chessguy> ski!
06:33:20 <ski> chessguy ?
06:34:29 <MarcWebe1> Is there a way to only ghc-pkg list the user or system database?
06:34:47 <emk> More probability stuff: http://www.randomhacks.net/articles/2007/03/03/smart-classification-with-haskell
06:34:49 <lambdabot> Title: Smart classification with Haskell, http://tinyurl.com/yosb9v
06:34:53 <dmhouse> If I have a "class Foo a b | a -> b" and an "instance Foo Int String", can a unify the type "Foo Int b => b" with type "String"?
06:37:21 <ski> i think you *ought* to, but i don't remember if the new system in ghc can handle that (yet)
06:37:29 <ski> istr they discussed it on mailinglist
06:39:49 <dmhouse> It turns out not. I get the "b is a rigid variable" error.
06:40:01 <dmhouse> Gah. That means I'll have to use existentials again.
06:41:05 <xerox> How did you test it?
06:42:18 <dmhouse> class Foo a b | a -> b
06:42:18 <dmhouse> instance Foo Int String
06:42:18 <dmhouse> bar :: Foo Int b => b
06:42:18 <dmhouse> bar = "rargh"
06:42:34 <dmhouse> GHCi gives:
06:44:26 <dmhouse> Couldn't match expected type `b' (a rigid variable)
06:44:26 <dmhouse> 	   against inferred type `[Char]'
06:44:26 <dmhouse>       `b' is bound by the type signature for `bar'
06:44:26 <dmhouse>  
06:44:26 <dmhouse> That's GHC's way of saying "You said it was a polymorphic type, but it's not."
06:44:26 * ski thinks the term 'rigid variable' sounds strange
06:44:26 <dmhouse> ski: I've always thought that too.
06:44:29 <ski> 'skolem (constant)' would be better, imo
06:44:53 <kuribas> What's the best way to express (2**i) but as an integer?
06:44:58 <dmhouse> Hehe, that sounds just as confusing to me.
06:45:06 <dmhouse> I'd prefer an error that says something along the lines of what I said.
06:45:24 <Igloo> kuribas: Do you want 2^i?
06:45:35 <ski> (yes, i didn't say there couldn't be better terms :)
06:45:36 <kuribas> Igloo: yes
06:45:50 <kuribas> Igloo: ah that works!  Thanks.
06:46:03 <dmhouse> ERROR "mptcs.hs":11 - Inferred type is not general enough
06:46:03 <dmhouse> *** Expression    : bar
06:46:03 <dmhouse> *** Expected type : Foo Int a => a
06:46:03 <dmhouse> *** Inferred type : Foo Int [Char] => [Char]
06:46:09 <dmhouse> That's what Hugs says.
06:46:21 <ski> that's not bad, methinks
07:24:19 <Orphi> anybody here know stuff about Gtk2hs / Cairo?
07:24:19 <lambdabot> Orphi: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:26:46 <Orphi> ....so I'm guessing 'no' then. heh.
07:40:33 <astrolabe> I've used it a little bit
07:40:47 <astrolabe> Not cairo
07:41:05 <astrolabe> I guess you just picked a bad time to ask
07:41:13 <MarcWebe2> astrolabe: He is gone
07:41:17 <astrolabe> Oh, he's gone :(
07:46:27 <chessguy> emk++ another fine blog, on bayesian classifiers
07:50:17 <chessguy> ?hoogle Perhaps
07:50:17 <lambdabot> No matches found
07:53:31 <emk> chessguy: Thanks!
07:53:40 <emk> Perhaps is in part 1.
07:53:48 <emk> http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions
07:53:51 <lambdabot> Title: Refactoring probability distributions, part 1: PerhapsT, http://tinyurl.com/ythywo
07:54:22 <chessguy> ya, see it now
07:55:08 <emk> Or you can pull all the code from darcs, finally. :-) http://www.randomhacks.net/darcs/probability
07:55:09 <lambdabot> Title: Index of /darcs/probability
07:55:15 <chessguy> great stuff. i like where you and syntaxfree are going with these statistics series'
07:55:19 <dmhouse> emk, in part 4, in the snippet where you introduce score, you mention perhapsValue and perhapsProb. Are those meant to be the prob and value from part 3?
07:55:47 <emk> Yup. I cleaned up a few bits of the API when doing the Haddock.
07:56:22 <dmhouse> Right, well you should make that point clear :)
07:56:50 <dmhouse> I'd define it like data Perhaps a = Perhaps { value :: a, prob :: Prob }, and get the selector functions for free.
07:57:56 <emk> dmhouse: Yup! That's the way the current version works.
07:58:05 * emk is eating breakfast, but won't be far
07:58:30 <chessguy> emk, does that repo include PFP?
08:11:18 <kuribas> Is it necessary to have one module per file?
08:12:52 <Cale> In present implementations, yes. In general, the language doesn't exclude the possibility.
08:13:57 <kuribas> So it is not possible to include a file without using the module system?
08:14:11 <Nicu> hi, is there a way to write \x y -> compare (fst x) (fst y) as pointless?
08:14:30 <chessguy> @pl \x y -> compare (fst x) (fst y)
08:14:31 <lambdabot> (. fst) . compare . fst
08:14:49 <Cale> kuribas: right.
08:15:01 <chessguy> @type (. fst) . compare . fst
08:15:04 <lambdabot> forall b a b1. (Ord a) => (a, b1) -> (a, b) -> Ordering
08:15:07 <kuribas> Cale: Ok, thanks.
08:15:09 <Cale> kuribas: Unless you want to use some sort of text processor like CPP.
08:15:25 <Cale> (but that's pretty ugly :)
08:15:26 <Nicu> thanks chessguy
08:15:41 <Cale> Nicu: comparing fst
08:15:46 <Cale> @index comparing
08:15:47 <lambdabot> bzzt
08:15:54 <Cale> :t Data.Ord.comparing
08:15:56 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
08:16:27 <Cale> (Note that it's new in 6.6)
08:16:56 <dino-> Sort of like a compare with mapping. Map the function over the things to be compared, compare those results.
08:17:06 <chessguy> Cale, strange and somewhat ugly things are happening to my GP code
08:17:28 <xerox> chessguy: PARI?
08:17:37 <chessguy> ?vera PARI
08:17:41 <lambdabot> No match for "PARI".
08:17:48 <chessguy> xerox, ?
08:17:53 <xerox> I mean, is it PARI/GP code?
08:18:10 <chessguy> xerox, i don't know what you're talking about
08:18:16 <xerox> Nevermind then
08:18:31 <chessguy> it's a library for doing genetic programming in haskell
08:19:02 <xerox> Sounds nice, what kind of stuff does it offer?
08:19:22 <chessguy> well, not much yet
08:19:42 <chessguy> eventually, it will offer a very simple but highly customizable interface
08:20:24 <chessguy> with a large array of built-in crossover/selection/mutation operators and parameters, and the ability to define your own as well
08:20:58 <chessguy> but without the need to define hardly anything
08:21:08 <chessguy> outside of your domain
08:21:26 <xerox> Hmmm, the user provides a Genetic instance or something?
08:22:09 <chessguy> the user provides basically the genetic material, and a way of determining the fitness of an individual
08:23:06 <xerox> chessguy: and then what happens?
08:23:20 <chessguy> and the library evolves a solution
08:24:25 <chessguy> darcs get http://catenova.org/~awagner/GPLib if you like. but it's currently under the knife
08:24:27 <lambdabot> Title: Index of /~awagner/GPLib/
08:26:11 <chessguy> that code should be capable of evolving x(1+x) from a bunch of data points
08:26:32 <xerox> What does it mean to evolve x(1+x) ?
08:26:51 <chessguy> it's a regression
08:27:36 <kaol> anyone had a look at Fishkill? http://wiki.yurusanai.de/pmwiki.php?n=Fishkill.HomePage
08:27:38 <lambdabot> Title: yurusanai.de Wiki | Fishkill / Fishkill
08:27:47 <chessguy> you have a bunch of (x,y) points, and you want to know what function fits those points
08:27:52 <kaol> some sort of minimalistic functional language apparently
08:28:25 <chessguy> thus the first sentence, "Fishkill is a minimalist functional programming language. "
08:29:20 <kaol> just stated it for the benefit of anyone who's lazy enough to not look at the page but still wonders what the link is about (or something like that)
08:29:54 <kaol> or then again, it's just a spurious comment, as the whole link might be for #haskell
08:30:37 <kaol> it has monads
08:31:22 <emk> chessguy: My probability repo contains a reimplementation of PFP, based on PerhapsT.
08:31:36 <chessguy> emk, ah
08:32:08 <emk> dmhouse: Are you the one who posted the running code for part 3? If so, many thanks!
08:32:30 <ski> @hoogle PerhapsT
08:32:30 <lambdabot> No matches found
08:32:54 <dmhouse> emk: I'm David House, yeah :)
08:32:54 <emk> ski: http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions
08:32:56 <lambdabot> Title: Refactoring probability distributions, part 1: PerhapsT, http://tinyurl.com/ythywo
08:33:50 <ski> ty
08:34:14 <emk> dmhouse: If there's any other improvements you'd like to suggest, please feel free!
08:34:45 <emk> I'm going to eventually take all this code to haskell-cafe for peer review, and try to turn it into a useful library.
08:34:51 <dmhouse> emk: I'm yet to finish reading through part 4, but I'm sure I'll have some ;)
08:35:02 <dmhouse> Yeah, I can see a nice Bayesian filtering library as coming in handy.
08:36:23 <emk> dmhouse: Definitely. The entire family of probability monads is seriously awesome.
08:37:02 <emk> I can't wait for sigfpe to post the rest of his stuff, generalizing them to quantum mechanics!
08:37:32 <chessguy> emk, i'd like to eventually put together a more general AI library. i'll be watching your code, and probably using it at the core of my library when i do
08:37:38 <emk> chessguy: I decided to reimplement PFP because I wanted Dist to be a typeclass.
08:37:54 <emk> chessguy: Yeah, that sounds like an excellent idea.
08:38:05 <chessguy> i'm not near good enough at haskell yet, but someday
08:38:19 <emk> I'd like to get a whole bunch of machine learning tools running in Haskell with a nice, intuitive API.
08:39:15 <chessguy> that would be cool. the simple API is what i like most about your code so far
08:39:42 <emk> Well, all the credit goes to the probability monad people. It's an amazingly nice structure.
08:40:38 <chessguy> anyway, back to hacking on genetic programming
08:43:13 <DynWind> emk: you got a link to the first post on probability monads?
08:43:16 <DynWind> can't seem to find it
08:43:46 <Stinger> are there any audio libs that work on win?
08:44:03 <emk> DynWind: There a list of all my posts just below the title of this page: http://www.randomhacks.net/articles/2007/03/03/smart-classification-with-haskell
08:44:05 <lambdabot> Title: Smart classification with Haskell, http://tinyurl.com/yosb9v
08:44:07 <Stinger> need something simple for an audible alert notification
08:44:28 <emk> chessguy: Let us know what you discover!
08:45:31 <chessguy> emk, discover?
08:46:03 <emk> About genetic algorithms in Haskell. :-)
08:46:13 <DynWind> emk: thanks
08:46:22 <emk> No prob!
08:46:49 <chessguy> oh
08:47:03 <chessguy> i'm more likely to make a mess of it, but we'll see :)
08:50:00 <chessguy> @pl \f ps -> map (\x -> (x, f x)) ps
08:50:00 <lambdabot> map . ap (,)
08:50:08 <emk> Hey, even that's valuable. As Edison famously said: "I have discovered a thousand things that don't work."  :-)
08:50:39 <chessguy> :)
08:56:31 <nomeata> @type ap
08:56:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:56:45 <chessguy> @pl \gs -> u (b gs) m
08:56:45 <lambdabot> flip u m . b
08:57:24 <nomeata> @type ap (,)
08:57:26 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
08:58:04 <nomeata> @type (,)
08:58:04 <chessguy> @pl \n -> re n ra
08:58:06 <lambdabot> forall a b. a -> b -> (a, b)
08:58:06 <lambdabot> flip re ra
09:00:00 <bhz-> I will pay $20 via paypal if you DoS someone for several hours. message me if interested
09:00:07 <nomeata> @type map . ap (,)
09:00:09 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
09:00:12 --- mode: ChanServ set +o xerox
09:00:18 --- mode: xerox set +b bhz-!*@*
09:00:23 --- kick: bhz- was kicked by xerox (xerox)
09:00:41 <nomeata> @pl flit (map . ap (,))
09:00:42 <lambdabot> flit (map . ap (,))
09:00:57 <nomeata> @pl \ps f -> map (\x -> (x, f x)) ps
09:00:57 <lambdabot> flip (map . ap (,))
09:03:52 <chessguy> xerox, might need a more general ban
09:04:25 <xerox> OK
09:04:37 --- mode: xerox set +b *!*@*.adsl.net.t-com.hr
09:05:00 --- mode: xerox set -b bhz-!*@*
09:05:48 <chessguy> @pl \gs n -> re n (ra gs)
09:05:48 <lambdabot> flip re . ra
09:09:25 <hpaste>  fantasma pasted "Need help fixing this." at http://hpaste.org/775
09:13:58 <hpaste>  fantasma annotated "Need help fixing this." with "slight fix" at http://hpaste.org/775#a1
09:18:09 <fantasma> cjeris, harvard eh?
09:18:26 <ski> forall n :: Integer.  n >= 0  ==>  sum [0..n] = n*(n+1) `div` 2
09:20:12 <cjeris> fantasma: staff, yes.
09:22:19 <chessguy> @type foldr
09:22:21 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:23:08 <roconnor> @vixen
09:23:08 <lambdabot> <undefined>
09:23:44 <fantasma> > let temp2 n = forall n :: Integer. n >= 0  ==>  sum [0..n] = n*(n+1) `div` 2 in temp2 10
09:23:45 <lambdabot>  Parse error
09:24:07 <chessguy> @pl f p -> foldr (\x y -> x + (f p y)) f
09:24:08 <lambdabot> (line 1, column 5):
09:24:08 <lambdabot> unexpected ">" or "-"
09:24:08 <lambdabot> expecting variable, "(", operator or end of input
09:24:59 <chessguy> @pl f p -> foldr (\x y -> x + (f p y)) 0 f
09:24:59 <lambdabot> (line 1, column 5):
09:25:00 <lambdabot> unexpected ">" or "-"
09:25:00 <lambdabot> expecting variable, "(", operator or end of input
09:25:51 <kpreid> dons?
09:26:45 <sorear> kpreid: no chance.  he wakes up in six hours
09:26:55 <ski> @check \n -> n  >= 0  ==>  sum [0..n :: Integer] == n*(n+1) `div` 2
09:26:56 <lambdabot>  OK, passed 500 tests.
09:27:25 <kpreid> sorear: ah ok
09:27:51 * kpreid has a mysteriously and cryptically busted lambdabot
09:27:57 * SamB wonders what the Computer Science program is like at villanova
09:28:28 <ski> fantasma : are you sure it is better to use 'nub' and 'gcd' to compute 'factors', rather than just filter with 'div' ?
09:29:03 <fantasma> ski, I was using filter and mod before but I couldn't tell the difference
09:29:14 <ski> ok
09:30:18 <hpaste>  Saizan annotated "Need help fixing this." with "reducing complexity" at http://hpaste.org/775#a3
09:30:55 * ski wonders if one could express 'length . factors $ n*(n+1) `div` 2' in terms of 'length . factors $ n' and 'length . factors $ n+1'
09:30:57 <fantasma> hmm I'll try it with mod again
09:31:02 <fasta> 5 minutes to compile my project... That is long.
09:31:13 <Saizan> ah
09:31:16 <Saizan> i'm late
09:31:24 <Pastorn> is this okay?
09:31:49 <Pastorn> data <- readFile fp >>= fixFile
09:32:05 <fasta> It stack overflows in the interpreter (not expected, but expected to be "slow")
09:32:14 <Cale> Pastorn: It reads better if you write it as   data <- fixFile =<< readFile fp
09:32:16 <fasta> So, I am now trying with optimization on .
09:32:17 <ski> data <- fixFile =<< readFile fp
09:32:26 <Pastorn> Cale: thanks :)
09:32:37 <fantasma> Saizan, it runs about the same
09:32:58 <ski> Cale : hey, what do you say about it ? :)
09:33:19 <Pastorn> does fixFile have to be String -> IO (Whatever) ? or is String -> Whatever sufficient?
09:34:10 <ski> do you need/want to do IO in 'fixFile' ?
09:34:10 * Pastorn isn't that good with >>=
09:34:32 <Pastorn> no, fixFile is actually String -> LSystem
09:34:46 <roconnor> @where t-shirt
09:34:47 <lambdabot> I know nothing about t-shirt.
09:34:47 <ski> data <- fixFile `liftM` readFile fp
09:34:51 <mauke> then you probably don't want >>=
09:34:56 <Pastorn> ski: thanks
09:34:59 <Cale> Well, yeah, I'm pretty sure you can count the divisors of n (n+1)/2 in terms of the divisors of n and n+1
09:35:05 <Pastorn> @type liftM
09:35:07 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:35:11 <mauke> a.k.a. data <- fmap fixFile (readFile fp)
09:35:21 <ski> 'liftM' really is 'fmap'
09:35:33 <fantasma> ski, do you think using {n*(n+1) `div` 2} is faster than {scanl (+) 0 [1..]}
09:35:46 <ski> fantasma : yes
09:35:46 <Cale> fantasma: absolutely
09:36:00 <fantasma> thanks
09:37:12 <Cale> actually, hmm... it might depend on whether you're using them all
09:37:33 <Cale> Computing n * (n+1) `div` 2 is certainly faster if you only need the nth one.
09:37:57 <fantasma> i need to find the nth one with 500 factors
09:37:58 <Cale> er, (n * (n+1)) `div` 2, to be careful :)
09:38:26 <Cale> 500 factors, or 500 divisors?
09:38:27 <chessguy> woohoo!
09:38:32 <chessguy> houston, we have separations!
09:38:52 <fantasma> Cale, what's the difference?
09:39:20 <Pastorn> should I import Monad or Control.Monad for liftM?
09:39:22 <Cale> 500 factors means there's a product a_1 a_2 ... a_500 = k
09:39:24 <mauke> (2 2 3) or (1 2 3 4 6 12)
09:39:47 <fantasma> that's _prime_ factors
09:39:53 <Cale> 500 divisors means that there are 500 distinct numbers which divide n.
09:40:05 <Cale> The a_n might not be prime.
09:40:23 <ski> Pastorn : the latter (former is old)
09:40:25 <fantasma> does factors refer to only prime numbers?
09:40:30 <Cale> No
09:40:40 <Cale> It refers to the parts of a product.
09:41:00 <Cale> And implies that those things are being multiplied.
09:42:00 <fantasma> usually the number of factors and divisors is the same though
09:42:17 <fasta> Is there also an option or similar -fyes-cse cf.  -fno-cse?
09:43:51 <sorear> GCH doesn't really do CSE with any set of options.
09:44:05 <sorear> and it would be -fcse, not -fyes-cse
09:45:38 <yip> is CPUTime.getCPUTime thread safe?
09:45:44 <sorear> wha?
09:45:50 <sorear> how could it not be?
09:46:24 <sorear> and I'd assume so, I've yet to meet a thread-unsafe standard library function
09:46:39 <yip> maybe it needs to adjust some hardware registers in a certain sequence, and if another call happens while it's doing this then the sequence will be broken
09:48:15 <sorear> I just figured it called times(2), so is your OS threadsafe?
09:49:36 <sorear> ah, it uses getrusage(2) on non-solaris non-irix non-windows
09:50:18 <hpaste>  fantasma annotated "Need help fixing this." with "still not fast enough" at http://hpaste.org/775#a4
09:50:42 <chessguy> @pl \fc p -> sum $ map (mf p) fc
09:50:42 <lambdabot> (sum .) . flip (map . mf)
09:51:36 <fasta> A naieve implementation of the "steps" as described in al algorithm article gives me >500MB of stack usage (my computer has too little to terminate) for a graph with 8 nodes. Isn't that hilarious?
09:51:56 <yip> sorear: so you're sure it's thread safe?
09:52:36 <sorear> yip: no
09:52:46 <sorear> it's a system call
09:53:03 <sorear> if it isn't, it's not haskell's fault
09:53:28 <yip> so what should i do?
09:53:35 <int-e> fasta: depends on the algorithm.
09:53:46 <Cale> fantasma: The number of divisors usually exceeds the maximum number of factors.
09:53:49 <jcreigh> yip: just use it, and see if it breaks?
09:54:06 <chessguy> > 8388608  * 2
09:54:07 <lambdabot>  16777216
09:54:08 <Cale> (which is the number of prime factors, since you can't break the thing down any further)
09:54:40 <fantasma> Cale, well I need the number of divisors then
09:54:54 <yip> jcreigh: that's not usually a good idea
09:55:31 <Cale> You say you need numbers which have exactly 500 divisors?
09:55:43 <jcreigh> yip: yeah, but if the docs don't say it's thread unsafe, and sorear doesn't think it's thread unsafe, there's a pretty good chance it's not thread unsafe, eh?
09:56:04 <chessguy> houston, we have a Problem.hs :)
09:56:17 <fantasma> Cale, I can get the number, that's not important, Im just having trouble making the list (see the paste)
09:56:32 <Cale> If a number factors as p_1^n_1 p_2^n_2 ... p_k^n_k, then it has (n_1 + 1) (n_2 + 1) ... (n_k + 1) divisors.
09:56:38 <chessguy> i've managed to separate my library and client code
09:56:52 <chessguy> after about 5 hours of surgery
09:57:10 <Cale> (where the p_i are prime)
09:58:34 <fantasma> Cale, I don't understand how that helps
09:59:11 <Cale> 500 = 2^2 5^3, so we immediately get that any number with exactly 5 divisors has at most 5 prime factors.
09:59:32 <Cale> and this heavily restricts the powers on the prime factors in it.
10:00:46 <Cale> Supposing that it has exactly 5, for example, we get that it's of the form p_1 p_2 p_3^4 p_4^4 p_5^4.
10:02:08 <narain> Cale: why does it have to have exactly 500 divisors?
10:02:18 <narain> i don't see that in fantasma's paste
10:02:21 <Cale> narain: I thought that was mentioned as a restriction.
10:02:29 <Pastorn> > sin pi -- this is undesired :(
10:02:31 <lambdabot>  1.2246063538223773e-16
10:02:45 <narain> ah, i must have come in late
10:02:48 <Cale> fantasma is trying to find the nth natural number with 500 divisors.
10:02:57 <jcreigh> Pastorn: floats suck, then you die. :)
10:03:02 * Pastorn writes sin' and cos'
10:03:18 <mauke> sin' = cos; cos' = -sin
10:03:19 <narain> Pastorn: you can't do better than 1e-16 with floats
10:03:19 <Cale> Pastorn: why is that a problem?
10:03:37 <Pastorn> Cale: it doesn't look nice
10:03:39 <Pastorn> :D
10:03:44 <fantasma> Cale, are you saying that I can do that without finding the number of factors for everything before n?
10:03:53 <Cale> fantasma: yes
10:04:02 <LoganCapaldo> I thought we had rationals?
10:04:08 <Cale> fantasma: I'm saying you can generate the numbers with 500 divisors directly.
10:04:09 <LoganCapaldo> oh I guess pi isn't rational
10:04:10 <LoganCapaldo> heh
10:04:11 <|Lupin|> Hello, everybody.
10:04:17 <LoganCapaldo> so much for that idea
10:04:34 <LoganCapaldo> Any language out there have a "symbolic" pi?
10:04:44 <Cale> LoganCapaldo: Mathematica and maple do.
10:04:50 <LoganCapaldo> cool
10:04:54 <yip> haskell has pi
10:05:00 <mauke> yip: symbolic
10:05:03 <Pastorn> @hoogle Real
10:05:04 <lambdabot> Prelude.Real :: class (Num a, Ord a) => Real a
10:05:04 <lambdabot> Prelude.RealFrac :: class (Real a, Fractional a) => RealFrac a
10:05:04 <lambdabot> Prelude.RealFloat :: class (RealFrac a, Floating a) => RealFloat a
10:05:06 <chessguy> > pi
10:05:08 <lambdabot>  3.141592653589793
10:05:15 <Cale> > pi :: Float
10:05:16 <lambdabot>  3.1415927
10:05:20 <Pastorn> > pi :: RealFloat
10:05:21 <yip> you can assign it to a symbol, even the pi symbol if your haskell implementation has it in it's charset
10:05:21 <lambdabot>      Class `RealFloat' used as a type
10:05:21 <lambdabot>     In the type `RealFloat'
10:05:21 <lambdabot>     In an e...
10:05:24 <|Lupin|> I am looking for efficient algorithms to generate all the permutations of a list (or array, or whatever) of length n. The algorithm should notnecessarily be written in Haskell... Any aideas / pointers, please ?
10:05:39 <LoganCapaldo> yip, erm thats not really what I meant
10:05:44 <narain> yip: but then you have to redefine sin and cos :)
10:05:45 <jcreigh> Pastorn: floats don't give the results you expect, unless you expect ((n*2)/2) /= n
10:06:01 <Pastorn> jcreigh: hehe :)
10:06:05 <LoganCapaldo> > pi -- would return pi
10:06:05 <narain> > (pi*2)/2 - pi
10:06:05 <lambdabot>  3.141592653589793
10:06:06 <lambdabot>  0.0
10:06:22 <Cale> > pi^2 / 6
10:06:23 <lambdabot>  1.6449340668482264
10:06:31 <SamB> @quickcheck \n -> ((n*2)/2) /= (n :: Double)
10:06:32 <lambdabot> Unknown command, try @list
10:06:36 <SamB> @qcheck \n -> ((n*2)/2) /= (n :: Double)
10:06:36 <lambdabot> Maybe you meant: check scheck
10:06:40 <SamB> @check \n -> ((n*2)/2) /= (n :: Double)
10:06:41 <lambdabot>  Falsifiable, after 0 tests: 0.0
10:06:51 <Cale> > sum [1/n^2 | n <- [1..1000]]
10:06:53 <lambdabot>  1.6439345666815615
10:06:54 <SamB> jcreigh: even if you expect that it doesn't work
10:06:58 <Cale> > sum [1/n^2 | n <- [1..10000]]
10:06:59 <dcoutts> @tell Orphi you were asking about Gtk2Hs / Cairo? Anything specific?
10:06:59 <lambdabot> Consider it noted.
10:06:59 <lambdabot>  1.6448340718480652
10:07:24 <chessguy> hey duncan, get my message about hIDE?
10:07:32 <narain> > exp (0 :+ 1)
10:07:34 <lambdabot>  0.5403023058681398 :+ 0.8414709848078965
10:07:39 <narain> > exp (0 :+ pi)
10:07:40 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
10:07:47 <narain> > exp (0 :+ pi) + 1
10:07:47 <jcreigh> @check \n -> ((n*2)/2) == (n :: Double)
10:07:49 <lambdabot>  OK, passed 500 tests.
10:07:49 <dcoutts> chessguy, don't think so
10:07:50 <lambdabot>  0.0 :+ 1.2246063538223773e-16
10:07:50 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:07:59 <chessguy> it may have gotten lost in the net split
10:08:01 <narain> Euler would not be pleased
10:08:11 <chessguy> i was wondering if hIDE is buildable
10:08:14 <jcreigh> hmmm....maybe that's not the gotcha I'm thinking of.
10:08:42 <Cale> I think that one part in 10^16 is not bad error given that it's using methods of approximation.
10:08:42 <dcoutts> chessguy, hIDE is probably only buildable with a lot of hacking
10:08:47 <chessguy> when i try, i get src/Hide/Plugin/LoaderMidLevel.hs:126:26: Not in scope: `moduleFS'
10:08:54 <Cale> With finite precision
10:09:06 <|Lupin|> About permuations...no Ideas ?
10:09:10 <narain> 10^-16 error is *unavoidable* when doing numerical computation using IEEE floats
10:09:25 <chessguy> |Lupin|, i'd bet there are tons of algorithms out there, if you google it
10:09:25 <dcoutts> chessguy, I've not tried recently, so I don't know any better than you.
10:09:29 <Cale> |Lupin|: sure, there's lots of ways to generate permutations. Most of the ways I know are just the obvious things.
10:09:31 <chessguy> dcoutts, ok. thanks
10:10:35 <chessguy> |Lupin|, you could also grep the logs over the last couple of days, i know we just had a discussion about this recently
10:10:45 <Cale> For each element of the list xs, pick that element out and attach it to the front of each of permutations of the rest of the list.
10:10:55 <Cale> That's the basic idea :)
10:11:01 <fantasma> Cale, how do I do the prime factorization for a number?
10:11:03 <|Lupin|> The question is: which keywords should appear inThe googl request ? permutation ? Or something else ?
10:11:15 * |Lupin| not an english native speaker
10:11:21 <narain> |Lupin|: generate permutations?
10:11:39 <narain> |Lupin|: i mean search for "generate permutations"?
10:11:54 <Cale> fantasma: Find the smallest proper divisor, and divide by it, then repeat that.
10:11:57 <narain> yup, that gets results
10:12:07 <sorear> > let insert x [] = [[x]] ; insert x (y:ys) = (x:ys) : map (y:) (insert x ys) ; permute [] = [[]] ; permute (x:xs) = insert x =<< permute xs in permute "abcd"
10:12:09 <lambdabot>  ["a","ba","ab","ca","cba","ac","ba","bca","ab","da","dba","acb","dab","dca",...
10:12:10 <Cale> The smallest proper divisor will always be a prime.
10:12:21 <sorear> > let insert x [] = [[x]] ; insert x (y:ys) = (x:y:ys) : map (y:) (insert x ys) ; permute [] = [[]] ; permute (x:xs) = insert x =<< permute xs in permute "abcd"
10:12:23 <lambdabot>  ["abcd","bacd","bcad","bcda","acbd","cabd","cbad","cbda","acdb","cadb","cdab...
10:12:30 <sorear> > length (let insert x [] = [[x]] ; insert x (y:ys) = (x:y:ys) : map (y:) (insert x ys) ; permute [] = [[]] ; permute (x:xs) = insert x =<< permute xs in permute "abcd")
10:12:32 <lambdabot>  24
10:12:38 <chessguy> > let perms [] = []; perms list@(x:xs) = [y:ys | y <- list, ys <- perms xs] in perms [1..5]
10:12:40 <lambdabot>  []
10:12:48 <chessguy> ouch
10:13:20 <|Lupin|> thanks !
10:13:34 <sorear> |Lupin|: it is effecient in LOC
10:13:35 <chessguy> > let perms [] = []; ;perms [x] = [[x]]; perms list@(x:xs) = [y:ys | y <- list, ys <- perms xs] in perms [1..5]
10:13:37 <lambdabot>  [[1,2,3,4,5],[1,2,3,5,5],[1,2,4,4,5],[1,2,4,5,5],[1,2,5,4,5],[1,2,5,5,5],[1,...
10:13:41 <fantasma> Cale, can I work backwords from knowing the number of divisors to get n
10:13:50 <sorear> [1,2,3,5,5] eh?
10:13:51 <nominolo> anyone know what this error message means: "Failed to load interface for `Prelude'" when building recent ghc 6.7.20070238 ?
10:13:55 <chessguy> hmm, not quite what i had in mind either
10:14:00 <Cale> fantasma: Yeah, that's what I suggested.
10:14:56 <chessguy> > let perms [] = []; ;perms [x] = [[x]]; perms list@(x:xs) = [y:ys | y <- list, ys <- perms (delete y xs)] in perms [1..5]
10:14:57 <lambdabot>  [[1,2,3,4,5],[1,2,4,5],[1,2,5,4],[1,3,4,5],[1,4,3,5],[1,5,3,4],[2,3,4,5],[2,...
10:14:59 <Cale> > let factors n = if k == n then [n] else k : factors (n `div` k) where k = head [m | m <- [2..n], n `mod` m == 0] in factors 500
10:15:00 <lambdabot>  [2,2,5,5,5]
10:15:03 <chessguy> sigh
10:15:08 <chessguy> whatever, i give up
10:15:30 <fantasma> 2^2,5^3
10:15:53 <Cale> It's possible to do better than that. You really only have to test primes less than the square root of n.
10:16:47 <sorear> > length (let insert [] x = [[x]] ; insert (y:ys) x = (x:y:ys) : map (y:) (insert x ys) ; permute = foldM insert [] in permute "abcd")
10:16:48 <narain> > let context n list = (take n list) ++ (drop (n+1) list); perms list = map (\i -> (list !! i) : perms $ context i list) [0..length list-1] in perms [1,2,3,4,5]
10:16:51 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
10:16:52 <lambdabot>       Expected...
10:16:52 <lambdabot>  Couldn't match expected type `[a]' against inferred type `[a] -> t'
10:17:01 <sorear> > length (let insert [] x = [[x]] ; insert (y:ys) x = (x:y:ys) : map (y:) (insert ys x) ; permute = foldM insert [] in permute "abcd")
10:17:03 <lambdabot>  24
10:17:09 <sorear> > let insert [] x = [[x]] ; insert (y:ys) x = (x:y:ys) : map (y:) (insert ys x) ; permute = foldM insert [] in permute "abcd"
10:17:11 <lambdabot>  ["dcba","cdba","cbda","cbad","dbca","bdca","bcda","bcad","dbac","bdac","badc...
10:18:12 <narain> :t foldM
10:18:14 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:18:23 <chessguy> sorear, i managed to separate my GP library and client code!
10:18:38 <sorear> chessguy++ cool!
10:18:45 <narain> @src foldM
10:18:45 <lambdabot> foldM _ a []     = return a
10:18:45 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
10:18:59 <chessguy> sorear, nobody got it when i announced "Houston, we have a Problem.hs" though
10:24:05 <chessguy> how do i get a list of patches from darcs?
10:25:49 <ibid> darcs changes?
10:26:03 <chessguy> ah, yes
10:46:48 <narain> :t foldM
10:46:51 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:52:04 * jcreigh sometimes finds himself typing "> expr" in ghci...
10:52:54 * LoganCapaldo finds himself typing @. elite expr in ghci
10:53:55 <narain> :t mapM
10:53:57 <lambdabot>     Ambiguous occurrence `mapM'
10:53:58 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
10:54:18 <narain> :t Control.Monad.Writer.mapM
10:54:19 <jcreigh> mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
10:54:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:55:17 <narain> would this be what i use to iterate over a list printing each element in turn?
10:55:28 <jcreigh> narain: yeah.
10:55:36 <jcreigh> narain: mapM_ actually
10:55:44 <narain> :t mapM_
10:55:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:55:52 <narain> nice
10:55:53 <jcreigh> mapM_ throws away the results.
10:56:07 <jcreigh> :t putStrLn
10:56:07 <narain> just what i needed
10:56:09 <chessguy> generally, a function with a _ at the end throws away intermediate results
10:56:09 <lambdabot> String -> IO ()
10:56:24 <jcreigh> otherwise, you'd end up with a list of [(), (), ...]
10:56:30 <narain> right
10:56:47 <LoganCapaldo> [(),()..]
10:56:48 <chessguy> hey, that could be useful :)
10:56:57 <narain> what about iterating getLine n times to get a list?
10:56:57 <LoganCapaldo> > [(),()..]
10:56:59 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
10:57:07 <jcreigh> lambdabot: heh
10:57:18 <sorear> replicateM n getLine
10:57:20 <chessguy> @quote lol
10:57:20 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
10:57:27 <sorear> @ty replicateM ?n getLine
10:57:29 <lambdabot> (?n::Int) => IO [String]
10:57:37 <chessguy> @quote lol
10:57:37 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
10:57:39 <jcreigh> what's the ?n for?
10:57:47 <sorear> @ty replicateM n getLine  -- no ?
10:57:50 <lambdabot> Not in scope: `n'
10:57:55 <kpreid> jcreigh: implicit parameter
10:57:59 <LoganCapaldo> the ?n is the greatest feature _ever_
10:58:03 <LoganCapaldo> _EVER_
10:58:08 <narain> wow, that syntax is awesome
10:58:40 <narain> why is this not written in big capital letters at the top of every haskell tutorial?
10:58:43 <LoganCapaldo> Me: "Sometimes, I wish it would just guess" --> sorear shows me the question mark
10:58:46 <mauke> > [True,True ..]
10:58:48 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
10:59:40 <LoganCapaldo> @type forM [1..?n] (\_ -> getLine)
10:59:43 <lambdabot>     Ambiguous occurrence `forM'
10:59:43 <lambdabot>     It could refer to either `forM', imported from Control.Monad.Writer
10:59:55 <Japsu> > [True, True, False, True, True, False, ..]
10:59:55 <lambdabot>  Parse error
11:00:02 <LoganCapaldo> @type forM [1..10] (\_ -> getLine)
11:00:04 <lambdabot>     Ambiguous occurrence `forM'
11:00:04 <lambdabot>     It could refer to either `forM', imported from Control.Monad.Writer
11:00:06 <narain>  @type Control.Monad.Writer.forM [1..?n] (\_ -> getLine)
11:00:13 <Japsu> > [True,True,False,True,True,False, ..]
11:00:14 <lambdabot>  Parse error
11:00:15 <narain> @type Control.Monad.Writer.forM [1..?n] (\_ -> getLine)
11:00:16 <Japsu> :(
11:00:17 <lambdabot> Not in scope: `..?'
11:00:17 <lambdabot>  
11:00:17 <lambdabot> <interactive>:1:31: Not in scope: `n'
11:00:24 <LoganCapaldo> > [True,False,True..]
11:00:24 <lambdabot>  Parse error
11:00:24 <narain> @type Control.Monad.Writer.forM [1 .. ?n] (\_ -> getLine)
11:00:26 <lambdabot> (?n::Integer) => IO [String]
11:00:33 <Japsu> > cycle [True, True, False]
11:00:35 <lambdabot>  [True,True,False,True,True,False,True,True,False,True,True,False,True,True,F...
11:00:41 <Japsu> :>
11:00:42 <narain> how can a single possibility be ambiguous?
11:00:43 <mauke> it's [a ..] or [a .. b] or [a, b ..] or [a, b .. c]
11:00:58 <narain> [1,2..-1]
11:01:01 <narain> > [1,2..-1]
11:01:01 <LoganCapaldo> yes, theres no b,..
11:01:02 <lambdabot>   Not in scope: `..-'
11:01:06 <narain> > [1,2.. -1]
11:01:08 <lambdabot>  []
11:01:11 <sorear> narain: the message is truncated, there are actaull two possibilities
11:01:24 <narain> i see
11:01:27 <narain> @hoogle forM
11:01:28 <lambdabot> Text.Html.form :: Html -> Html
11:01:28 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
11:01:28 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
11:01:34 <sorear> @ty Data.Traversable.forM
11:01:36 <Orphi> @src mapM_
11:01:36 <lambdabot> forall (t :: * -> *) a (m :: * -> *) b. (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
11:01:37 <lambdabot> mapM_ f as = sequence_ (map f as)
11:01:42 <sorear> ^^^ the other
11:02:29 <narain> [True..]
11:02:33 <narain> > [True..]
11:02:33 <lambdabot>  Parse error
11:02:34 <narain> guh
11:02:38 <LoganCapaldo> why not just stick [] into Data.Traveseable?
11:02:57 <jcreigh> so implicit parameters are used for dynamic scoping?
11:03:06 <LoganCapaldo> oh wait
11:03:07 <sorear> yeah
11:03:11 <LoganCapaldo> thats not the problem is it
11:03:39 <kmag2> Any of you using ghc on OS X (x86) ?
11:03:44 <mauke> > [True ..]
11:03:45 <lambdabot>  [True]
11:03:54 <narain> isn't there a difference between dynamic scoping and lambda arguments?
11:03:54 <Japsu> !!
11:03:59 <LoganCapaldo> (PPC)
11:04:20 <jcreigh> > [False .. True]
11:04:22 <lambdabot>  [False,True]
11:04:33 <narain> :t (1 + ?n)
11:04:36 <lambdabot> forall t. (?n::t, Num t) => t
11:04:57 <sorear> :t (?n 0, ?n 'a')
11:05:00 <lambdabot>     No instance for (Num Char)
11:05:00 <lambdabot>       arising from the literal `0' at <interactive>:1:4
11:05:07 <LoganCapaldo> @type map ?f ?l
11:05:08 <sorear> :t (?n (0::Int), ?n 'a')
11:05:10 <lambdabot> forall a b. (?f::a -> b, ?l::[a]) => [b]
11:05:11 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
11:05:11 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
11:05:11 <lambdabot>  
11:05:21 <LoganCapaldo> sweet :)
11:05:26 <hpaste>  kmag2 pasted "last stmt in do must be expr" at http://hpaste.org/776
11:05:44 <narain> > (1 + ?n) 2
11:05:45 <lambdabot>  Parse error
11:05:51 <mauke> kmag2: borken indentation
11:05:52 <sorear> kmag2: the message means exactly what it says
11:06:07 <mauke> kmag2: start a new line after "do", "where"
11:06:12 <sorear> kmag2: use a expr as the last statement in your do's
11:06:14 <kmag2> sorear: that's copied and pasted strait from a tutorial
11:06:16 <kmag2> :-(
11:06:27 <mauke> not completely straight
11:06:41 <narain> dang, i thought ?x produced a lambda
11:06:46 <narain> but shouldn't it?
11:07:05 <allbery_b> either the tutorial's formatting or your cut/paste appears to have dropped a tab
11:07:07 <hpaste>  mauke annotated "last stmt in do must be expr" with "fixed (I think)" at http://hpaste.org/776#a1
11:07:39 <allbery_b> hm, no, it dropped 7 spaces, not 8
11:08:01 <hpaste>  LoganCapaldo annotated "last stmt in do must be expr" with "Ugly but guranteed to work :)" at http://hpaste.org/776#a2
11:08:47 <hpaste>  mauke annotated "last stmt in do must be expr" with "while we're at it" at http://hpaste.org/776#a3
11:09:09 <ski> :t let f () = 1 + ?n in let ?n = 2 in f ()
11:09:12 <lambdabot> forall t. (Num t) => t
11:09:25 <hpaste>  sorear annotated "last stmt in do must be expr" with "do notation considered harmful (and excessively verbose)" at http://hpaste.org/776#a4
11:10:00 <narain> what's the advantage of implicit parameters?
11:10:24 <LoganCapaldo> I love the progression
11:10:27 <LoganCapaldo> :)
11:10:59 <LoganCapaldo> do with bad layout, to do with correct layout to do with explicit layout to no do, to pointfree no do
11:11:11 <LoganCapaldo> its like that evolution of a haskell programmer page
11:11:29 <LoganCapaldo> the next guy is gonna throw in arrows or something :)
11:11:54 <kmag2> so... I couldn't get it to work with do on the same line as the binding to args
11:12:09 <kmag2> but putting the do on a new line fixed it
11:12:33 <mauke> kmag2: the token after 'do' determines the indentation level of the do block
11:12:41 <kmag2> oh
11:12:47 <kmag2> blushes
11:12:51 * kmag2 blushes
11:13:08 * kmag2 is used to python whitespace sensitivity
11:13:10 <narain> you could probably align the putStrLn with the args <- getArgs and it would work (afaik)
11:13:37 <LoganCapaldo> yep
11:13:42 <LoganCapaldo> thats what I do usually
11:13:50 * LoganCapaldo doesn't know if its "proper"
11:13:53 <glguy> hpaste: url
11:13:53 <hpaste> Haskell paste bin: http://hpaste.org/
11:13:54 <LoganCapaldo>  style
11:14:21 <emu> i often write ... = do\n
11:14:42 <narain> can anyone explain implicit parameters to me?
11:14:51 <fasta> narain: nobody uses them
11:14:58 <emu> they are dynamically scoped
11:15:00 <allbery_b> IIRC they're scheduled to be removed from ghc
11:15:03 <emu> and yea
11:15:19 <emu> you should be using the State monad or something
11:15:39 <narain> it seems like it would make sense to make an expression with ?x become a lambda instead
11:15:45 <kmag2> So have any of you gone through the amherst.edu "write a Scheme interpreter in Haskell" tutorial?
11:16:02 <narain> @google write yourself a scheme
11:16:04 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
11:16:04 <lambdabot> Title: Write Yourself a Scheme in 48 hours
11:16:16 <fasta> kmag2: do you have a question?
11:17:26 <kmag2> fasta: just wondering if I'm going to run in to any bugs
11:17:51 <kmag2> fasta: I've coppied the tutorial to my HD in anticipation of my long flight
11:18:05 <narain> i went through the first three sections and they worked fine, fwiw
11:18:18 <kmag2> narain: thanks :-)
11:19:05 <narain> make that 5... up to and including the intermezzo
11:19:23 <fasta> kmag2: If you solve the bugs, you have learned something.
11:20:09 <kmag2> fasta: yea... just want to make sure I'm not banging my head against something for 6 hours
11:20:42 <fasta> kmag2: I don't know, but I don
11:20:56 <fasta> kmag2: 't know anyone who did run into serious problems.
11:21:09 <kmag2> cool.  Thanks everyone
11:22:00 <narain> good luck. it's quite a good way to get into Haskell
11:22:56 <kmag2> yea, it looks very fun
11:29:51 <narain> @pl \g -> f g h
11:29:51 <lambdabot> flip f h
11:36:52 <chessguy> @type fac
11:36:54 <lambdabot> Not in scope: `fac'
11:36:55 <chessguy> @type fact
11:36:57 <lambdabot> Not in scope: `fact'
11:36:59 <chessguy> bah
11:37:50 <chessguy> > let fac 0 = 1; fac n = n * fac (n-1) in fac 25
11:37:52 <lambdabot>  15511210043330985984000000
11:38:07 <mauke> @let fac n = product [1 .. n]
11:38:10 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
11:38:25 * chessguy kicks the bot
11:38:26 <benja_> ?hoogle (//)
11:38:27 <lambdabot> Did you mean: (//)
11:38:27 <lambdabot> Prelude.undefined :: a
11:38:27 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:38:32 <heatsink> How do I cause a function to be inlined in its callers?  {-# INLINE f #-} doesn't do it.
11:40:28 <user317> does anyone use the haskell overlay on gentoo?  the 6.6 install doesn't have
11:40:40 <user317> Control.Monad.Cont for some reason
11:42:21 <allbery_b> libghc6-mtl-dev or some such?
11:47:13 * sorear implements the APPLY bytecode ... fear and terror
11:49:22 <sorear> @seen beschmi
11:49:23 <lambdabot> I saw beschmi leaving #haskell, #darcs, #haskell-blah and #ghc 4d 4h 54m 50s ago, and .
11:49:34 <chessguy> is it possible to create a new numeric datatype which is exactly n bits, for some particular n?
11:50:12 <sorear> yeah!
11:50:18 <sorear> > maxBound :: Word512
11:50:21 <lambdabot>  1340780792994259709957402499820584612747936582059239337772356144372176403007...
11:50:26 <sorear> > maxBound :: Word256
11:50:29 <lambdabot>  115792089237316195423570985008687907853269984665640564039457584007913129639935
11:50:34 <sorear> > maxBound :: Word128
11:50:35 <lambdabot>  340282366920938463463374607431768211455
11:50:40 <LoganCapaldo> > maxBound :: Word3
11:50:41 <lambdabot>   Not in scope: type constructor or class `Word3'
11:50:41 <chessguy> > maxBound :: Word361
11:50:41 <lambdabot>   Not in scope: type constructor or class `Word361'
11:50:47 <LoganCapaldo> :(
11:51:12 <SamB> sorear: ... those aren't actually efficient are they?
11:51:27 <sorear> haha :)
11:51:33 <sorear> i doubt it
11:51:36 <sorear> elegant maybe
11:52:19 <kmag2> SamB: define efficent?  More efficient than doing the same thing with an array of ints?
11:52:25 <rahikkala> > maxBound :: Word4096
11:52:29 <lambdabot>  ghc: failed with error code 9
11:52:41 * rahikkala slayed the beast!
11:52:50 <user317> ah, thanks, i needed the mtl library
11:53:08 <rufius> > maxBound :: Word2048
11:53:11 <lambdabot>  ghc: failed with error code 9
11:53:14 <rufius> huzzah
11:53:17 <rufius> > maxBound :: Word1024
11:53:21 <lambdabot>  ghc: failed with error code 9
11:53:24 <rufius> :(
11:53:43 <SamB> I suppose gmp might support arithmatic modulo powers-of-2
11:53:45 <kaol> > length . show (maxBound :: Word512)
11:53:46 <lambdabot>  Couldn't match expected type `a -> [a1]'
11:53:54 <SamB> with increased efficiency
11:53:55 <kaol> > length (show (maxBound :: Word512)) -- meh
11:53:59 <lambdabot>  155
11:54:21 <SamB> > length . show $ (maxBound :: Word512)
11:54:24 <lambdabot>  155
11:55:01 <glguy> > sqrt (10**12)
11:55:03 <lambdabot>  1000000.0
11:55:12 <kmag2> SamB: from what I've seen of the gmp low-level API, all of the multiplications are done non-modulo
11:55:50 <LoganCapaldo> Hey if haskell is already creating thunks, could it not also store in parallel to the thunks an AST repr?
11:56:28 <LoganCapaldo> then when sqrt got (10**12) it could peek and just do 10**6 instead of actually computing the sqrt
11:56:41 <SamB> heh
11:56:43 * LoganCapaldo has too many silly elaborate ideas
11:57:00 <sjanssen> LoganCapaldo: it's hard to do that in a referentially transparent way
11:57:11 <SamB> maybe it could do that when you use a symbolic Floating implementation
11:57:22 <LoganCapaldo> yeah
11:57:26 <LoganCapaldo> stupid floats
11:57:29 <sjanssen> LoganCapaldo: have you heard of ghc's RULES pragma?
11:57:34 <LoganCapaldo> yep
11:57:58 <SamB> but actual floating-point values tend to take exception to that sort of treatment
11:58:08 <sjanssen> so you can do some limited transformations at compile time
11:58:15 <kmag2> Logan: and the cost of checking for all of those optimizations probably outweighs their benefit.
11:58:16 <emu> do they take sigfpe to that?
11:58:31 <SamB> emu: okay, lets just say they'd give you different answers
11:58:48 <LoganCapaldo> kmag2: certainly :)
11:58:50 <sjanssen> @check \x -> sqrt (x**12) == x**6
11:58:50 <lambdabot>  Add a type signature
11:59:08 <sjanssen> @check (\x -> sqrt (x**12) == x**6) :: Float -> Bool
11:59:10 <lambdabot>  Falsifiable, after 13 tests: 4.25
11:59:39 <nmessenger> > (sqrt ((4.25::Float)**12), (4.25::Float)**6)
11:59:41 <lambdabot>  (5892.9614,5892.961)
11:59:48 <LoganCapaldo> yep
11:59:49 <sjanssen> @check (\x -> sqrt (x**12) == x**6) :: Double -> Bool
11:59:50 <lambdabot>  Falsifiable, after 10 tests: -5.333333333333333
11:59:55 <LoganCapaldo> stupid floats
12:00:03 <LoganCapaldo> ruining my ideas
12:00:23 <sjanssen> Double-- Float--
12:00:44 <glguy> @check (\x y -> sqrt (x ** y) == x ** (y / 2))
12:00:45 <lambdabot>  Add a type signature
12:00:49 <nmessenger> FPA NO LIKE RT
12:00:53 <SamB> @karma Double
12:00:53 <lambdabot> Double has a karma of -1
12:00:56 <SamB> @karma Float
12:00:56 <lambdabot> Float has a karma of -1
12:01:07 <glguy> @check (\x y -> sqrt (x ** y) == (x::Double) ** ((y :: Double) / 2))
12:01:08 <lambdabot>  Falsifiable, after 5 tests: -1.5, 3.0
12:01:57 <kmag2> Logan: just constrain your optimization to operations on arbitrary precission rationals
12:01:57 * jcreigh has a feeling that if he did Double++, it would have a karma of 10^-16
12:02:01 <rufius> Any mathematicians in here right now? Can't get an answer in #math, wondering if someone will confirm something for me?
12:02:12 <glguy> @check (\x y -> x > 0 ==> sqrt (x ** y) == (x::Double) ** ((y :: Double) / 2))
12:02:15 <lambdabot>  Falsifiable, after 8 tests: 6.857142857142857, -3.5
12:02:15 <sorear> @check (\x y -> x * y / x == y) :: Double -> Double -> Bool
12:02:16 <lambdabot>  Falsifiable, after 0 tests: 0.0, -2.0
12:02:33 <seliopou> rufius: just ask the question
12:02:44 <rufius> Would the linear combination of the gcd(33,44) be "11=(-3*11) + 33 + 11" ?
12:02:46 <sorear> @check (\x y -> (x /= 0 && y /= 0) ==> x * y / x == y) :: Double -> Double -> Bool
12:02:47 <lambdabot>  Couldn't match expected type `Bool'
12:02:47 <kmag2> Logan:  of course, with sqrts... you'll often get stuck in an infinite loop until you exhaust memory allocating space for a rational square root
12:02:56 <sorear> @check (\x y -> (x /= 0 && y /= 0) ==> (x * y / x == y)) :: Double -> Double -> Bool
12:02:57 <lambdabot>  Couldn't match expected type `Bool'
12:03:17 <seliopou> are you talking about bezout's identity?
12:03:28 <kaol> @check (\x y -> x * y / x == y) :: Rational -> Rational -> Bool
12:03:30 <lambdabot>  Exception: Ratio.%: zero denominator
12:03:32 <rufius> seliopou: was that to me?
12:03:36 <seliopou> yes
12:03:39 <glguy> ?type (==>)
12:03:42 <lambdabot> forall a. (Testable a) => Bool -> a -> Property
12:03:48 <rufius> seliopou: no
12:04:11 <nmessenger> so (... -> Property)
12:04:28 <rufius> seliopou: esentially and example would be for gcd(10,11), the linear combo would be "1=(-1*10)+1*11
12:04:31 <rufius> "
12:04:32 <ski> @check \x y ->  x /= 0  ==>  x * y / (x :: Rational) == y
12:04:33 <lambdabot>  OK, passed 500 tests.
12:05:05 <glguy> ?hoogle Ratio
12:05:06 <lambdabot> Data.Ratio :: module
12:05:06 <lambdabot> Ratio :: module
12:05:06 <lambdabot> Data.Ratio.Ratio :: data Ratio a
12:05:24 <glguy> @check \x y ->  x /= 0  ==>  x * y / (x :: Ratio Double) == y
12:05:25 <lambdabot>   add an instance declaration for (Integral Double)     In the expression: le...
12:05:27 <glguy> oh
12:05:41 <yip> @seen kolmodin
12:05:42 <lambdabot> kolmodin is in #darcs, #gentoo-haskell and #haskell. I last heard kolmodin speak 3h 19m 36s ago.
12:05:57 <nmessenger> @src Rational
12:05:57 <seliopou> I'm not sure what you're asking rufius
12:05:57 <lambdabot> type Rational = Ratio Integer
12:06:00 <glguy> ?src Integral
12:06:01 <lambdabot> class  (Real a, Enum a) => Integral a  where
12:06:01 <lambdabot>     quot, rem, div, mod :: a -> a -> a
12:06:01 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
12:06:01 <lambdabot>     toInteger           :: a -> Integer
12:06:10 <glguy> Rational is a Ratio Integer?
12:06:16 <sorear> yees
12:06:33 <nmessenger> that's what LB said!
12:06:35 <sorear> @src Ratio
12:06:35 <lambdabot> data (Integral a) => Ratio a = !a :% !a
12:06:41 <seliopou> If you're asking for the linear combination of the gcd of two integers, that's just the a multiple of the gcd.
12:06:45 <glguy> nmessenger: well, I don't read
12:06:46 <glguy> so
12:06:51 <rufius> seliopou: I'm not sure what else to tell lol, The exact question is "Express the greatest common divisor of each of these pairs of integers as a linear combination of these integers." and the pair i have is "33,44"
12:07:03 <seliopou> that's bezout's identity
12:07:11 <rufius> seliopou: oh ok, i didn't know it by that name
12:07:23 <seliopou> which states, there are integers r and s such that gcd(a,b) = ra + sb
12:07:39 <seliopou> with a, b integers
12:07:49 <rufius> ok
12:08:12 <chessguy> > 3 ^ 9
12:08:12 <lambdabot>  19683
12:08:13 <seliopou> you can use the euclidean algorithm to determine r and s, I believe
12:08:50 <glguy> > head [(r,s) | r <- [-100..100], s <- [-100..100], r * 33 + s * 44 == 11] --fast enough
12:08:52 <lambdabot>  (-97,73)
12:08:54 <rufius> seliopou: ya, so for gcd(33,44) then it would be... "11=3*11 + 1*44"
12:09:01 <rufius> ?
12:09:03 <seliopou> no
12:09:09 <rufius> err (-3*11)
12:09:11 <seliopou> 11 = r *33 + s *44
12:09:22 <seliopou> fill in r and s
12:09:24 <glguy> > head [(r,s) | r <- [-10..10], s <- [-100..100], r * 33 + s * 44 == 11] --fast enough
12:09:25 <lambdabot>  (-9,7)
12:09:34 <seliopou> ...
12:09:47 <seliopou> glguy: that's what I call unnecessary
12:09:55 <glguy> seliopou: good for you!
12:09:59 <seliopou> indeed
12:11:40 <yip> is there a shorter way to write: \x -> (foo x) && (bar x) && (oof x) && (rab x)
12:11:56 <glguy> all ($ x) [foo, bar,oof,rab)
12:12:06 <mauke> @pl \x -> (foo x) && (bar x) && (oof x) && (rab x)
12:12:06 <lambdabot> liftM2 (&&) foo (liftM2 (&&) bar (liftM2 (&&) oof rab))
12:12:11 <Orphi> I wish *I* could think that fast!
12:12:11 <mauke> haha
12:12:23 <glguy> and . sequence [foo,bar,oof,rab]
12:12:24 <sorear> and . sequence [foo, bar, oof, rab]
12:12:29 <glguy> ha! ;)
12:12:55 <mauke> wait, so sequence is antimap?
12:13:09 <glguy> ((->)r)
12:13:11 <nmessenger> @src (->) sequence
12:13:11 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:13:14 <Orphi> @seen dcoutts
12:13:14 <nmessenger> silly me
12:13:14 <lambdabot> dcoutts is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I last heard dcoutts speak 2h 3m 47s ago.
12:13:20 <nmessenger> @src sequence
12:13:21 <lambdabot> sequence ms = foldr k (return []) ms
12:13:21 <lambdabot>     where
12:13:21 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
12:13:26 <yip> which monad would that sequence be working in?
12:13:35 <glguy> ((->)r)
12:13:36 <mauke> (->) r
12:13:36 <Orphi> list, as a guess?
12:14:18 <Orphi> dcoutts: you around?
12:14:33 <glguy> 1*44 + (-1)*33 = 11
12:14:57 <emu> nah, this is list
12:15:04 <emu> > sequence [[1,2],[3,4,5]]
12:15:12 <emu> @botsnack
12:15:13 <lambdabot> :)
12:15:15 <emu> > sequence [[1,2],[3,4,5]]
12:15:17 <mauke> no, this is sparta!
12:15:17 <nmessenger> @type sequence
12:15:20 <lambdabot>     Ambiguous occurrence `sequence'
12:15:20 <glguy> Conrol.Monad
12:15:20 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
12:15:25 <nmessenger> @type Control.Monad.sequence
12:15:27 <glguy> Control.Monad.sequence
12:15:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:15:30 <glguy> lambdabot is broken
12:15:33 <nmessenger> the monad is *inside* the list
12:15:37 * emu cries on lambdabot 
12:15:53 <Orphi> lambdabot(tm) - probably the worst logo ever(r)
12:15:56 <emu> someone do something, i need my lambda fix
12:15:59 <allbery_b> > Control.Monad.sequence [[1,2],[3,4,5]]
12:16:01 <lambdabot>  [[1,3],[1,4],[1,5],[2,3],[2,4],[2,5]]
12:16:05 <emu> > fix (\ x -> not x)
12:16:06 <lambdabot>  Exception: <<loop>>
12:16:07 <glguy> @vixen getting old and rusting!
12:16:07 <lambdabot> <undefined>
12:16:52 <narain> @src fix
12:16:52 <lambdabot> fix f = let x = f x in x
12:17:09 <Orphi> ...da hell...?
12:17:20 <nmessenger> let x = not x in x
12:17:23 <mauke> fix = unconst
12:17:24 <narain> > fix tail
12:17:25 <lambdabot>  Exception: <<loop>>
12:17:26 <sorear> Orphi: you saw the logo?
12:17:38 <Orphi> the lambdabot logo?
12:17:40 <Orphi> yeah...
12:17:40 <glguy> x = fix f        same as: x = f x
12:17:54 <mauke> > fix (const "y helo thar")
12:17:55 <lambdabot>  "y helo thar"
12:17:57 <narain> > fix (drop 1)
12:17:58 <lambdabot>  Exception: <<loop>>
12:18:00 <nmessenger> > fix ("passes function to itself" ++)
12:18:02 <lambdabot>  "passes function to itselfpasses function to itselfpasses function to itself...
12:18:04 <emu> > fix (1:)
12:18:05 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:18:11 <narain> > drop 1 []
12:18:13 <lambdabot>  []
12:18:17 <sorear> > fix((1:).scanl(+)1)
12:18:18 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:18:18 <LoganCapaldo> it would be neat if let x = not x in x returned some kind of superposition <g>
12:18:33 <emu> LoganCapaldo: there is a fixed pt for that
12:18:33 <Orphi> isn't that just what iterate does?
12:18:40 <mauke> if you want Quantum::SuperPosition, you know where to get it
12:18:42 <narain> drop 1 [] == []  but  fix (drop 1) /= []?
12:18:47 <nmessenger> that's what last . iterate does :)
12:18:50 <emu> LoganCapaldo: it's _|_
12:18:52 <Orphi> oh
12:19:12 <Orphi> @src iterate
12:19:12 <lambdabot> iterate f x =  x : iterate f (f x)
12:19:17 <narain> @src drop
12:19:17 <glguy> Orphi: iterate can be expressed with fix
12:19:17 <lambdabot> drop n xs     | n <= 0 =  xs
12:19:18 <lambdabot> drop _ []              =  []
12:19:18 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
12:19:32 <emu> everything can be expressed with fix
12:19:49 <mauke> emu: how do I express const in terms of fix?
12:19:51 <Orphi> Haskell(r): The programming language where everything can be programmed twelve different ways(tm)
12:20:01 <LoganCapaldo> I guess I don't know what fixed pt. means
12:20:04 <emu> > fix (\_ -> "a")
12:20:05 <glguy> iterate f x = fix ((x:).map f)
12:20:06 <lambdabot>  "a"
12:20:08 <Orphi> ah, but which way is the most efficient? ;)
12:20:22 <LoganCapaldo> I thought if it diverged it meant there was no fix point
12:20:32 <emu> everything has a fixed point
12:20:54 <sorear> everything.
12:21:00 <narain> really?
12:21:00 <opqdonut> EVERYTHING
12:21:03 <nmessenger> it just might not be finite
12:21:07 <emu> every computable transformation function, sorry
12:21:14 <sorear> every continuous function on a pointed partial order
12:21:30 * LoganCapaldo drowns in theory
12:21:40 <Orphi> how about Haskell(r): The scary theoretical physics language(tm)?
12:21:47 <emu> physics? pshaw
12:21:47 <LoganCapaldo> physics?
12:21:51 <narain> does function continuity extend to discrete structures?
12:22:06 <heatsink> I thought (+1) had no fixed point.
12:22:10 <narain> i only know of continuity in R^n -> R^m
12:22:12 <sorear> narain: er, monotonic
12:22:17 <Orphi> have you seen how much maths there is in theoretical physics??
12:22:23 <Orphi> just like Haskell! ;)
12:22:26 <sorear> narain: sure, use the order topology!
12:22:34 <opqdonut> haha
12:22:36 * sorear <3 topology
12:22:42 <opqdonut> or the trivial topology
12:22:42 <mbishop> @source ($)
12:22:43 <lambdabot> ($) not available
12:22:45 <narain> whoa
12:22:45 <opqdonut> always a good choice
12:22:46 <emu> A has C, B has C, therefore A is B?
12:22:50 <mauke> @src ($)
12:22:51 <lambdabot> f $ x = f x
12:23:17 <Orphi> @src hFlush
12:23:17 <lambdabot> Source not found. That's something I cannot allow to happen.
12:23:19 <araujo> hello
12:23:20 <opqdonut> > fix ($)
12:23:21 <lambdabot>  Add a type signature
12:23:24 <opqdonut> :P
12:23:25 <nmessenger> ($) f x = f x, ($) f = f, ($) = id
12:23:44 <mauke> you can't fix id
12:23:49 <sorear> sure you can
12:23:53 <sorear> > fix id :: Int
12:23:55 <lambdabot>  Exception: <<loop>>
12:23:59 <sorear> it's always _|_
12:24:02 <opqdonut> > fix id :: Integer
12:24:03 <lambdabot>  Exception: <<loop>>
12:24:05 <sorear> but it's still a fixpoint!
12:24:08 <opqdonut> yep
12:24:13 <mauke> that doesn't count
12:24:13 <LoganCapaldo> I feel like going back to OO land where at least I could act like I knew what was going on
12:24:20 <emu> > fix fix
12:24:21 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
12:24:21 <lambdabot>     Probabl...
12:24:35 <heatsink> So we need to include _|_ in all types to give everything a fixpoint?
12:24:37 <Orphi> > fix cat
12:24:37 <nmessenger> @type let x = fix x in x
12:24:38 <lambdabot>  Couldn't match expected type `[Doc]' against inferred type `Doc'
12:24:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
12:24:40 <lambdabot>     Probable cause: `fix' is applied to too many arguments
12:24:50 <emu> heatsink: _|_ is in all types
12:24:54 <mbishop> LoganCapaldo: OO land? I don't see why everyone loves to use that paradigm EVERYWHERE
12:24:59 <sorear> @type  fix ?me
12:25:01 <lambdabot> forall a. (?me::a -> a) => a
12:25:14 <narain> wait, what does fix do when functions have multiple fixed points?
12:25:19 <Orphi> OO land is a lot easier to explain ;)
12:25:24 <narain> what does fix really do, anyway?
12:25:28 <sjanssen> sorear: :)
12:25:30 <sorear> narain: returns the smallest one
12:25:31 <emu> there are lots of fixed poitn combinators
12:25:32 <LoganCapaldo> mbishop: I'm pretty sure not everyone loves to use that everywhere :)
12:25:33 <opqdonut> @src fix
12:25:33 <lambdabot> fix f = let x = f x in x
12:25:35 <emu> fix is the least
12:26:15 <emu> heatsink: it's inescapable because with the Y combinator, you can express a contradiction.  for example, that x = not x
12:26:49 <Orphi> > let primes = s [2..] ; s (p :xs) = p : filter (\x -> x `mod` p /= 0) xs in primes
12:26:50 <narain> what is the notion of "smallest" or "least" here?
12:26:50 <lambdabot>  [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
12:26:50 <sorear> or, you can eliminate _|_ (eg System F)
12:26:55 <opqdonut> > fix not
12:26:56 <lambdabot>  Exception: <<loop>>
12:26:58 <sorear> BUT Y must go
12:27:02 <emu> yea
12:27:10 <sorear> narain: domain theoreticall
12:27:11 <heatsink> What's a good introduction to system F?
12:27:15 <emu> Pierce
12:27:18 * heatsink has heard about it a lot
12:27:46 <Orphi> let f = 1 : 1 : zipWith (+) f (tail f) in f
12:27:51 <Orphi> > let f = 1 : 1 : zipWith (+) f (tail f) in f
12:27:52 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:28:05 <Orphi> I love Haskell so much...
12:28:06 <narain> emu: which pierce? kinda hard to google for
12:28:12 <emu> ?where tapl
12:28:12 <lambdabot> http://tinyurl.com/282m6x
12:28:13 <fantasma> Orphi, what is that
12:28:21 <jcreigh> fantasma: fibonacci
12:28:35 <Orphi> fantasma: the Fibonacci sequence ;-)
12:28:36 <fantasma> that's what I thought...it looked fimiliar ;)
12:28:43 <Orphi> previous one was the prime numbers
12:28:58 <Orphi> I can't remember Pascal's triangle off the top of my head...
12:28:59 <fantasma> ah yea the sieve
12:29:04 <Orphi> ...but it's another 1-liner
12:29:05 <LoganCapaldo> tapl is cheaper than I thought
12:29:20 <LoganCapaldo> I may have to devote some birthday money too it
12:29:26 <Orphi> seriously... I wish to hell GNUplot supported Hasekll!!
12:29:28 <fantasma> everything can be done with 1 line in haske;; :)
12:29:42 <fantasma> s/haske;;/haskell/
12:29:51 <nmessenger> > fix $ (1:) . (1:) . ap (zipWith (+)) tail
12:29:52 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:29:53 <Orphi> everything can be done in 1 line in Java; just renove all the newline characters! ;)
12:30:04 <kmag2> fantasma: everything can also be done with one line of bf
12:30:08 <nmessenger> :D
12:30:10 <LoganCapaldo> How is "Basic Category Theory for Computer Scientists"?
12:30:16 <Orphi> in Haskell it's more complicated; gotta handle layout ;)
12:30:28 <sjanssen> Orphi: nah, just use ; {}
12:30:34 <nmessenger> Orphi: nope, layout is optional, use {}
12:30:34 <emu> > [ [ floor $ product [1..n] / (product [1..(n-k)]*product [1..k]) | k <- [0..n] ] | n <- [1..] ]
12:30:34 <opqdonut> http://opqdonut.users.paivola.fi/mandel.png
12:30:39 <opqdonut> http://opqdonut.users.paivola.fi/mandel.hs <-- code for that
12:30:45 <lambdabot>  [[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7...
12:30:47 <SamB> sjanssen: that is dramatically more complicated transformation
12:30:49 <opqdonut> ascii mandelbrot in one line of haskell :)
12:31:01 <SamB> you need at least a partial Haskell parser to implement it
12:31:07 * heatsink 's library's copy of TAPL is checked out until may :(
12:31:13 <opqdonut> emu: quite an ugly solution
12:31:19 <Orphi> opqdonut: wow... it took me 6 lines!
12:31:21 <mgsloan> since functions only take one parameter, does something like (foldl (+) 1) create a thunk which points to a thunk?  In other words, each thunk has a pointer and one argument
12:31:22 <SamB> (you don't need to handle the operator precedence, at least)
12:31:25 <opqdonut> Orphi: hah
12:31:36 <jcreigh> opqdonut: heh, looks like the aalib mode of xaos
12:31:40 <mahogny> LoganCapaldo, have it, I'm looking for a more advanced text. it felt a bit thin
12:31:41 <emu> the use of product [1.. ] could be factored out
12:31:47 <sorear> > ap zip (scanl (*) 1) [1..
12:31:48 <lambdabot>  Parse error
12:31:51 <sorear> > ap zip (scanl (*) 1) [1..]
12:31:53 <lambdabot>  [(1,1),(2,1),(3,2),(4,6),(5,24),(6,120),(7,720),(8,5040),(9,40320),(10,36288...
12:31:57 <Orphi> http://warp.povusers.org/MandScripts/haskell.html
12:31:58 <lambdabot> Title: Haskell ascii mandelbrot
12:32:08 <Orphi> oh... neat
12:32:16 <Orphi> I thought it only did that for "known" sites...
12:32:17 <sorear> > filter ((==1) . uncurry gcd) $ ap zip (scanl (*) 1) [1..]
12:32:19 <lambdabot>  [(1,1),(2,1),(3,2),(5,24),(7,720),(11,3628800),(13,479001600),(17,2092278988...
12:32:34 <fantasma> > let foo = putStr[(".-~^,:=+rcfkwO*H8#B@$"!!).(`div`5).length.take 100.takeWhile((<100).magnitude).(\x->iterate((+x).(^2))x)$(3*x/w-2):+(2*y/h-1)|y<-[0..h],x<-[0..w]] in foo
12:32:35 <lambdabot>   Not in scope: `w'
12:32:44 <mahogny> LoganCapaldo, I guess it all depends on your expectations
12:32:46 <heatsink> mgsloan: as I understand it, thunks can have multiple values inside.  Thunks and data constructors are almost identical in the runtime.
12:32:52 <opqdonut> fantasma: you need to substitute w and h for term dimensions
12:32:57 <sorear> > map fst $ filter ((==1) . uncurry gcd) $ ap zip (scanl (*) 1) [2..]
12:32:59 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:33:07 <emu> > [ floor $ product [1..n] / (product [1..(n+1)]*product [1..n]) | n <- [1..] ]
12:33:08 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
12:33:12 <fantasma> > let w = 238; h = 84; foo = putStr[(".-~^,:=+rcfkwO*H8#B@$"!!).(`div`5).length.take 100.takeWhile((<100).magnitude).(\x->iterate((+x).(^2))x)$(3*x/w-2):+(2*y/h-1)|y<-[0..h],x<-[0..w]] in foo
12:33:14 <lambdabot>  <IO ()>
12:33:17 <fantasma> IO
12:33:19 <mgsloan> heatsink, ah, alright.  Makes since, but 'purity' wise multiple thunks might make sense...
12:33:20 <emu> > [ floor $ product [1..(2*n)] / (product [1..(n+1)]*product [1..n]) | n <- [1..] ]
12:33:21 <opqdonut> fantasma: hehe can't print that here
12:33:21 <lambdabot>  [1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674439,9694844,353...
12:33:24 <LoganCapaldo> mahogny: My expectations are to have less "Huh?" moments inthis channel :)
12:33:31 <emu> -- catalan numbers
12:34:36 <mahogny> LoganCapaldo, oh. then it won't be enough :)
12:34:44 <sorear> > drop 100000 $ fix (([0::Int ..607] ++) . liftM2 (zipWith (+)) (drop 203) (drop 606))
12:34:46 <lambdabot>  [952572057,-1388372156,50283391,-1273810191,1332589190,-1190325566,-19321366...
12:34:54 <sorear> ^^^ lagged fibbonacci PRNG
12:35:25 <nmessenger> > let w = 238; h = 84; foo = [(".-~^,:=+rcfkwO*H8#B@$"!!).(`div`5).length.take 100.takeWhile((<100).magnitude).(\x->iterate((+x).(^2))x)$(3*x/w-2):+(2*y/h-1)|y<-[0..h],x<-[0..w]] in foo
12:35:27 <lambdabot>  "..............................................................................
12:35:34 <nmessenger> top left corner of mandelbrot :)
12:35:37 <heatsink> mgsloan: There could be a thunk for each level of partial application, where each thunk evaluates to the next when applied to a value.  The intermediate thunks wouldn't have to be created if several values are applied at once.  You could probably look at .hc code to see if that's happening.
12:35:49 <mahogny> LoganCapaldo, it didn't feel very applied even though they made an effort. my thought was "ok. it is a category. now what?"
12:36:18 <sorear> @let foo = 2
12:36:19 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
12:36:20 <fantasma> is there any function in prelude that will count the number of instances of a number in a list
12:36:31 <sorear> no
12:36:37 <nmessenger> length (filter (x==) xs)
12:36:39 <mauke> length . filter
12:36:58 <sorear> > sum [1| 'l' <- "Hello, World" ]
12:36:59 <Orphi> nmessenger: ...and here I was telling everybody that Haskell is more readable!
12:36:59 <lambdabot>  3
12:37:00 <thalassocrac> i'm reading "sets for mathematics", it's pretty good thus far (i'm on chapter four); "elementary categories, elementary toposes" looks like it would be good too
12:37:02 <fantasma> nice
12:37:09 <fantasma> thanks nmessenger / mauke
12:37:43 <mauke> > sum . map (fromEnum . ('l' ==)) $ "Hello, world"
12:37:44 <lambdabot>  3
12:38:24 <Orphi> > length $ filter ('l' ==) $ "Hello, world"
12:38:26 <lambdabot>  3
12:38:27 <sorear> > transpose $ replicateM 5 "# "
12:38:28 <lambdabot>  ["################                ","########        ########        ","####...
12:38:31 <nmessenger> > fromEnum True :: Int -- the magic!
12:38:33 <lambdabot>  1
12:38:33 <mgsloan> heatsink: Ahh, well, I'd imagine that it'd be a good optimization to be able to condense thunks
12:38:34 <sorear> > transpose $ replicateM 4 "# "
12:38:36 <lambdabot>  ["########        ","####    ####    ","##  ##  ##  ##  ","# # # # # # # # "]
12:39:11 <heatsink> mgsloan: condense?
12:40:17 <mgsloan> combine, concatenate, eliminate the intermediates
12:40:17 <emu> condensation?
12:41:32 * mgsloan halts conversation with creative word use :P
12:41:52 <Orphi> ...so does anybody else think Haskell needs a better logo?
12:42:38 <sorear> Orphi: wait ... did you see the lambdabot logo, or the haskell logo, earlier?
12:42:50 <Orphi> I've looked at both
12:42:54 <sorear> Orphi: not I.  Haskell's logo looks like this to me:
12:42:54 <emu> lambda was chosen by the type-setter for Church's paper, iirc
12:43:14 <sorear>    [Haskell]
12:43:15 <Orphi> the lambdabot logo is a picture of some girl who looks like she has a brain dissorder
12:43:25 <mauke> haha
12:43:35 <emu> well, that describse lambdabot alright
12:43:38 <mauke> that's a portrait, not a logo
12:43:41 <fantasma> Orphi, I want to do that same thing but for everything in the list, not just one character or number
12:43:41 <Orphi> lolz!
12:43:50 <sorear> actually there was a contest to pick that one
12:43:56 <Orphi> x_x
12:44:17 <sorear> > map (head &&& length) . group . sort $ "Hello World!"
12:44:19 <lambdabot>  [(' ',1),('!',1),('H',1),('W',1),('d',1),('e',1),('l',3),('o',2),('r',1)]
12:44:38 <sorear> > sort . map (length &&& head) . group . sort $ "Hello World!"
12:44:39 <lambdabot>  [(1,' '),(1,'!'),(1,'H'),(1,'W'),(1,'d'),(1,'e'),(1,'r'),(2,'o'),(3,'l')]
12:45:04 <fantasma> what does the operator &&& do
12:45:17 <sorear> > ((+1) &&& (*2)) 20
12:45:17 <Orphi> > length $ filter (`elem` "abc") $ "Hello world"
12:45:19 <lambdabot>  (21,40)
12:45:19 <lambdabot>  0
12:45:21 <emu> it's a scary Arrow combinator
12:45:44 <Orphi> the Haskell logo looks... amaturish
12:45:46 <Orphi> too busy
12:45:51 <Orphi> low-tech
12:46:00 <Orphi> needs something more... sleek
12:46:03 <sorear> Orphi: we try not to look at it.
12:46:08 <mgsloan> hehe
12:46:08 <Orphi> lol
12:46:48 <Orphi> I'll have to see if I can't draw something nicer myself...
12:46:50 <emu> lambdas are 30s technology... old
12:47:04 <Orphi> ...and computers are...?
12:47:13 <emu> 40s?
12:47:15 <sorear> Orphi: haskell@haskell.org when you're done.
12:47:24 <Orphi> sorear: lolz... ok
12:47:29 <sorear> 20s iirc, depending on exact definition
12:47:34 <emu> yea i guess
12:47:42 <Orphi> erm... wait, they had *electricity* in the 20s?? o__O
12:47:51 <sorear> Orphi: that's a public mailing list addr, just so you know
12:48:03 <emu> acoustic lambdas don't need no electricity
12:48:14 <Orphi> sorear: don't you have to join to be able to post then?
12:48:31 <Orphi> emu: did Babbage make a Lambda Engine?
12:48:37 <shapr> Difference Engine?
12:48:56 <emu> an Engine that didn't make a Difference
12:49:16 <sorear> Orphi: Ch-rch did lambdas on paper!
12:49:31 <Orphi> 0wnership! x_x
12:49:42 <nmessenger> ch-rch?
12:49:51 <sorear> like g-d
12:50:01 <Orphi> "He who must not be named..."
12:50:09 <nmessenger> I s--.
12:50:13 <opqdonut> wnership even
12:50:16 <emu> Ch-rch and State are separated by monads
12:50:21 <sorear> Orphi: Alphonso Church, BTW
12:50:26 <Lamperi> \m/
12:50:38 <Orphi> VOLDEMORT!
12:50:39 <mauke> emu: hahargh
12:50:49 <Orphi> oh er, sorry, what are we talking about? ;)
12:50:50 <sorear> er, Alonzo
12:50:54 <nmessenger> What does that make Turing?  :3
12:51:26 <sorear> nmessenger: the devil
12:51:40 <Orphi> hmm... sense Haskell is referentially transparent, maybe the logo should be made of glass? ;)
12:51:50 <sorear> nmessenger: he tempts people with imperative evil
12:52:10 <Orphi> don't make me do my Yoda quote... 0;-)
12:52:13 <nmessenger> I suspected as much :D
12:52:59 <Orphi> A coder's strength *flows* from the Source. But beware of the Dark Side. Mutation... Side effects... Typecasts... The Dark Side of the Source are they. Easily they flow, quick to join you in a fight. If once you start down the Dark path, forever will it dominate your destiny. Consume you it will!
12:53:02 <nmessenger> Do not Fear, young one, the Libraries, for Vast Riches, They contain.
12:53:44 <Orphi> <= something is wrong with me
12:54:16 <nmessenger> @quote cult
12:54:16 <lambdabot> qwe1234 says: never heard of malbolge before, but i'd think that writing a simple source-to-source translator from some sort of minimal vm assembly to malbolge shouldn't be too difficult.
12:54:52 <nmessenger> bleh
12:54:59 <heatsink> I guess esolangers could be considered a cult.
12:55:06 <nmessenger> @quote the.cult
12:55:07 <lambdabot> nmessenger says: Welcome to the cult.  Have some koolaid.
12:56:44 <fantasma> what module is &&& in
12:57:03 <mauke> @index (&&&)
12:57:03 <lambdabot> Control.Arrow
12:57:12 <fantasma> thanks
12:57:17 <nmessenger> @index (&&&)
12:57:17 <lambdabot> Control.Arrow
12:57:52 * nmessenger seems laggy
12:58:41 <fantasma> @index (group)
12:58:42 <lambdabot> Data.List
12:58:51 <fantasma> @hoogle group
12:58:51 <lambdabot> List.group :: Eq a => [a] -> [[a]]
12:58:51 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
12:58:51 <lambdabot> System.Console.Readline.beginUndoGroup :: IO ()
12:59:14 <mauke> PING reply from nmessenger: 19.307 seconds
12:59:23 <fantasma> @hoogle sort
12:59:23 <lambdabot> List.sort :: Ord a => [a] -> [a]
12:59:23 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
12:59:23 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
12:59:35 <nmessenger> D:
13:03:44 <shapr> @yow !
13:03:44 <lambdabot> Zippy's brain cells are straining to bridge synapses ...
13:07:25 <Orphi> ...da hell...?
13:07:38 <Orphi> I just got called away, and when I come back I see lambdabot... Lol!
13:08:02 <Vq^> shapr: hej formarn :)
13:08:56 <nmessenger> lambdabot is omnipresent.  Soon she will be subsumed into the fabric of space-time itself.
13:09:41 <mgsloan> I always thought it'd be cool if a programming language was so powerful that logical inconsistency destroyed reality as we know it
13:10:34 <nmessenger> if it *did* destroy our reality, who would be left to realize it?
13:10:36 <Orphi> lambdabot is... strange
13:10:50 <nmessenger> @quote lambdabot
13:10:50 <lambdabot> lambdabot says: I know nothing about comprehending.
13:10:51 <Orphi> the product of an unbalanced mind, I feel. ;)
13:11:25 <nmessenger> @quote lambdabot
13:11:25 <lambdabot> lambdabot says: I know nothing about comprehending.
13:13:01 <Orphi> so... does the command list make sense to anybody else?
13:13:01 <Syzygy-> Yeah.
13:13:01 <Orphi> ok.
13:13:02 <Orphi> good to know it's only me that's retarded...
13:13:11 <nmessenger> what? @list?
13:13:16 <Orphi> yeah
13:13:21 <Syzygy-> @list
13:13:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:13:31 <Syzygy-> That's sensible enough.
13:13:31 <nmessenger> you could always do /msg lambdabot @
13:13:39 <nmessenger> nothing after the '@'
13:13:59 <Orphi> "more provides: more"
13:14:01 <Orphi> wtf?
13:14:08 <Syzygy-> Or you could -- if you're on irssi -- install my lambdabot-module and just tab-complete.
13:14:11 <sorear> ./dist/build/lambdabot/lambdabot -e list-all
13:14:13 <nmessenger> the more module has a @more command
13:14:15 <Orphi> is that supposed to mean something? or just be amusing...
13:14:19 <Syzygy-> Orphi: The lambdabot-module more provides the command @more.
13:14:37 <sorear> @list more
13:14:37 <lambdabot> more provides: more
13:14:41 <sorear> @help more
13:14:41 <lambdabot>  @more. Return more output from the bot buffer.
13:14:55 <Syzygy-> xx provides: yy zz -- this means that there's a module xx which interfaces with the commands @yy and @zz.
13:15:03 <Orphi> @list state
13:15:03 <lambdabot> state has no visible commands
13:15:12 <Orphi> that's just meta-funny...
13:15:12 <nmessenger> @. elite protontorpedo
13:15:13 <lambdabot> SO CaN H4zKe1l D0 WH4t PEr1 DOEz bU7 sImP1ER?
13:15:32 <nmessenger> @list quote
13:15:32 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
13:15:40 <nmessenger> @keal
13:15:40 <lambdabot> there is no way to prove the failsafe exists
13:16:02 <Orphi> x_x @ girl19
13:16:09 <nmessenger> @. elite girl19
13:16:09 <lambdabot> i H4V3 570LEN 4BouT 50 mSn and YAh0o a(cOuNTz
13:16:38 <nmessenger> heh, @. elite <command> = instant awesome!
13:16:47 <Orphi> ...starting to understand the lambdabot logo...
13:17:25 <Orphi> @. elite yarr
13:17:25 <lambdabot> W3|1 Ah0Y! +|-|4R.
13:17:35 <Syzygy-> @. elite quote
13:17:35 <lambdabot> $WI3RT z4YS: oF C0UR$3! wHo C4n |ivE \/\/i7hoU7 C0vARIaN+ HoMfuN(ToRS?
13:17:37 <Orphi> ...da hell?! 0__0
13:17:53 <Orphi> @slap lambdabot
13:17:54 * lambdabot smacks lambdabot about with a large trout
13:18:00 <Orphi> plz make it stop! x_x
13:18:03 <Syzygy-> Sure. I agree with that. Life without covariant homfunctors - and contravariant too for that matter - is worse.
13:18:10 <Syzygy-> @. elite slap Syzygy-
13:18:10 <lambdabot> /M3 $/\/\4x zYZY9y- AboU+ WI+H A |ArgE +RoU7
13:18:50 <Orphi> ...so does anybody here know anything about Gtk2hs?
13:18:57 <Orphi> or even just Gtk?
13:20:29 <heatsink> @palomer
13:20:29 <lambdabot> Pfft
13:20:42 <Orphi> .....so that would be a 'no' then. heh.
13:20:53 <Orphi> I'll see if I can leave a msg...
13:21:39 <Syzygy-> There are regulars in here who do a lot with Gtk2hs.
13:21:46 <Syzygy-> Only not active right this minute.
13:21:51 <nmessenger> @help tell
13:21:51 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
13:21:52 <allbery_b>  @tell dcoutts?
13:22:01 <Orphi> allbery_b: yeah, that's what I'm thinking
13:22:10 <sorear> @seen dcoutts
13:22:11 <lambdabot> dcoutts is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I last heard dcoutts speak 3h 12m 44s ago.
13:22:22 <Orphi> @seen dcoutts_
13:22:22 <lambdabot> dcoutts_ is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts_ speak 1d 1h 41m 11s ago.
13:22:31 <sorear> @seen dcoutts__
13:22:32 <lambdabot> I haven't seen dcoutts__.
13:22:32 <Orphi> there...are two... x_x
13:23:09 * nmessenger found it!  http://trappist.elis.ugent.be/~kehoste/haskell-blah_lambdabotContest.html
13:23:11 <lambdabot> Title: #haskell-blah: Everything but Haskell - Lambdabot contest, http://tinyurl.com/y949tc
13:25:06 <sorear> you coulda asked ... then I would just
13:25:12 <sorear> @topic-tell #haskell-blah
13:25:12 <lambdabot> Anything BUT Haskell (even SEX!) -|- add yourself to the collection -> http://www.elis.ugent.be/~kehoste/haskell-blahSouthPark.html -|- lambdabot's first words: "Ooh, functional programmers are so
13:25:13 <lambdabot> hot" -|- current topic: "A eux je montre mon derriere (Arno)"
13:25:35 <sorear> that link will get you to the contest very quickly
13:26:10 <chessguy> hmm, is it possible to write fsize to calculate the number of elements of an arbitrary functor, in terms of fmap?
13:26:20 <sorear> nope
13:26:25 <sjanssen> chessguy: no
13:26:40 <sorear> (->) [Char]  -- string indexed, infinite size
13:26:57 <sorear> (->) (Integer -> Bool)  -- uncountable size!
13:26:57 <sjanssen> there are functors that don't have a reasonable definition of "size"
13:27:08 <sorear> (but note computability :( )
13:27:32 <chessguy> ah. interesting
13:27:33 <sorear> Cont Bool -- this is a functor
13:27:38 <sorear> how big is it?
13:27:51 <nmessenger> @unmtl Cont Bool a
13:27:51 <lambdabot> (a -> Bool) -> Bool
13:28:09 <Orphi> you know, I thought that was "cheeseguy"... it must be subliminal
13:29:11 <sjanssen> chessguy: you could do something with Data.Foldable
13:29:37 <chessguy> ?src Foldable
13:29:37 <lambdabot> Source not found. Take a stress pill and think things over.
13:29:45 <chessguy> ?source Data.Foldable
13:29:46 <lambdabot> Data.Foldable not available
13:29:58 <sjanssen> @docs Data.Foldable
13:29:58 <lambdabot> Data.Foldable not available
13:30:07 <nmessenger> :O
13:30:21 <nmessenger> @docs
13:30:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:30:24 <sjanssen> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html -- I really wish the doc index was dynamic
13:30:26 <lambdabot> http://tinyurl.com/23pc9l
13:30:28 <nmessenger> there's the index, that'll get you there
13:30:57 <chessguy> nmessenger, i knew how to find it. i just thought i'd try the lazy way firs
13:30:59 <chessguy> t
13:31:31 <sjanssen> @type getSum . Data.Foldable.foldMap (Data.Monoid.Sum . const 0)
13:31:33 <lambdabot> forall b a (t :: * -> *). (Num b, Data.Foldable.Foldable t, Monoid (Sum b)) => t a -> b
13:33:51 <newsham> why isnt List a class?  there are many things that can behave like a list.
13:34:31 <sorear> newsham: because the people who designed h98 are idiots in retrospect
13:34:33 <nmessenger> Monoid is the (++) and [] class, Foldable is the foldr class, there are others
13:34:45 <newsham> its easy to be an idiot in retrospect.
13:34:55 <sjanssen> newsham: you can get into trouble with excessive overloading
13:35:05 <sorear> newsham: talk to Cale, you won't get a solution but you'll get plenty of ...
13:35:17 <newsham> you can also get into trouble with purity.  thats what moore's law is for.
13:35:32 <sjanssen> purity?
13:35:46 <newsham> no side effects.
13:36:05 <sjanssen> oh, I see what you're saying
13:36:07 <newsham> doesnt seem like haskell is the kind of language to shy away from trouble
13:36:13 <sjanssen> I'm speaking of a different type of trouble
13:36:32 <sjanssen> the type signatures become much more complicated, for example
13:36:55 <sjanssen> I'm sure the monomorphism restriction would pop up all the time with overloaded lists
13:36:58 <newsham> (List l x) => l -> x -> [x]   ?
13:37:13 <sorear> sjanssen: Num
13:37:15 <newsham> ?hoogle [x] -> x -> [x]
13:37:16 <lambdabot> List.intersperse :: a -> [a] -> [a]
13:37:16 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
13:37:16 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:37:18 <Orphi> it's easy to be an idiot in retrospect... but harder to be one now?
13:37:23 <Orphi> ;)
13:37:29 <sjanssen> sorear: you're proposing extended defaulting?
13:37:40 <sorear> sjanssen: yeah!
13:37:48 <sjanssen> I support extended defaulting, by the way
13:38:08 <sorear> who doesn't?
13:38:23 <Orphi> ...those of us who don't know what the hell it is? :P
13:38:27 <orbitz> in a number of programs you can add a verbosity level so whenever it does an operation you can get output or not get output, would such a thing make haskell code a bit icky? You'd need monads eerywhere evne in palces you really don't want it?
13:38:49 <sorear> orbitz: hat! :p
13:39:16 * chessguy kicks orbitz in the shin
13:39:48 <orbitz> what di di dooooo
13:40:15 <chessguy> orbitz, existed.
13:40:20 <newsham> kicked in the /sbin
13:40:20 <Orphi> sounds Jamecan...
13:40:22 * orbitz licks chessguy 
13:40:29 <Orphi> o_O
13:40:43 * sorear increments orbitz' l
13:40:53 <dmhouse> orbitz: the standard way of handling that is to pass your command-line arguments around in a Reader.
13:40:54 <orbitz> but really, how would someone do taht sort of thing in haskel? my code tries to be a pretty functional interior with a monad layer around it, i dont' want to muck up my pretty codes with monads everywhere
13:41:18 <sjanssen> orbitz: the typical Haskell solution would be to roll logging into your monad
13:41:26 <Orphi> Maybe is a monad
13:41:31 <Orphi> lists are monads
13:41:31 <sorear> dmhouse: I think he's complaining about the ickiness of Writer
13:41:37 <Orphi> it's not just IO ;)
13:41:52 * allbery_b thinking this sounds like a variant of Debug.Trace.trace
13:42:10 <Orphi> @type Debug.Trace.trace
13:42:12 <sorear> @here hslogger
13:42:12 <lambdabot> forall a. String -> a -> a
13:42:12 <lambdabot> http://software.complete.org/hslogger
13:42:15 <allbery_b> traceIf flag thing_to_trace a
13:42:48 <Orphi> ahh... I wish Hoogle worked for nonstandard modules...
13:43:58 <orbitz> hrm i had a nother quesiton but i think i forgot it
13:44:01 <orbitz> thanks for nothing!
13:44:14 * chessguy kicks orbitz farewell
13:44:15 <sorear> Orphi: it does
13:44:37 <Orphi> o rly?
13:45:09 <sorear> Orphi: ./Setup.lhs haddock --hoogle
13:45:19 <sorear> you are using cabal, right? :)
13:45:29 <Orphi> last time I touched cabal, it didn't work.
13:45:35 <sorear> also, cabal does not support haddocking executables
13:46:00 <sorear> the powers that be can't understand why an executable would need its internal apis documented.
13:46:02 <sorear> ross--
13:47:05 <sjanssen> sorear: I think the typical response here is "patches welcome"
13:47:25 <chessguy> isn't that the slogan for haskell?
13:47:31 <Cale> hehe, this approach encourages people to write reusable libraries :)
13:47:42 <Cale> Forcefully.
13:47:52 <Orphi> Cale lives!
13:47:54 <Orphi> lol
13:48:11 <yip> Cale: remember that chat from last night? i'm extending it, and almost have multiplayer connect four working :O
13:48:36 <dbremner> sjanssen- I also like "sooner if you help" as a response to when will it be done.
13:48:48 <Saizan> btw, i want haddock strings from :info in ghci :\
13:48:56 <sjanssen> dbremner: nice, I'll remember that one
13:48:59 <Cale> Awesome :)
13:49:11 <sjanssen> Saizan: maybe in ghc 6.8
13:49:16 * chessguy just discovered :info today
13:49:29 <sjanssen> there's work going on to integrate ghc and haddock
13:49:30 <Saizan> really?
13:49:53 <Cale> yip: If you write some articles about the process and how great STM is, I'll vote them up on Reddit :) (as well as the code when it's ready to release :)
13:49:57 <sorear> @where haddock-ghc
13:49:57 <lambdabot> I know nothing about haddock-ghc.
13:50:00 <sorear> @where haddock.ghc
13:50:00 <lambdabot> I know nothing about haddock.ghc.
13:50:09 <sjanssen> Saizan: I don't really know, but it's plausible
13:50:39 <sorear> @where+ haddock-ghc http://darcs.haskell.org/SoC/haddock.ghc
13:50:39 <lambdabot> Done.
13:50:42 <sorear> @where+ haddock.ghc http://darcs.haskell.org/SoC/haddock.ghc
13:50:43 <lambdabot> Done.
13:50:47 <yip> Cale: cool. your vote should count as 100 regular votes though. i think i'll wait for when i'm ready to release the code though
13:51:01 <sorear> no new patches in months, and unusable, but it exists.
13:54:28 <mbishop> http://programming.reddit.com/info/17p5r/comments
13:54:29 <lambdabot> Title: How to tell someone&#39;s language of choice by looking at their keyboard (reddi ...
13:55:45 <sorear> mbishop: x86 asm, and I virtually never use %
13:56:19 <mbishop> then change it? :P
13:56:26 <sorear> ?
13:56:31 <sorear> how?
13:57:10 <mbishop> it's a wiki...
13:57:16 <mbishop> in fact, it's THE wiki :P
13:57:37 <augustss> mbishop: funny, but i doubt the accuracy :)
13:58:07 <chessguy> ?src Show
13:58:08 <lambdabot> class  Show a  where
13:58:08 <lambdabot>     showsPrec :: Int -> a -> ShowS
13:58:08 <lambdabot>     show      :: a   -> String
13:58:08 <lambdabot>     showList  :: [a] -> ShowS
13:58:09 <mbishop> I like the java and perl ones :P
13:58:17 <dbremner> mbishop- there's this - http://klausler.com/evolved.html
13:58:19 <lambdabot> Title:
13:58:52 <mbishop> heh, I think pmk used to come to #haskell sometimes actually
13:59:29 <kc5tja> sorear: If you use AT&T syntax for x86 assembly, you use the % key a LOT.
13:59:34 <dbremner> mbishop- cool
13:59:36 * kc5tja amended Python and Forth entries to be more distinct.
14:00:08 <matthew-_> mmm. I use a Das Keyboard. It's blank. Good luck working out what I program in! ;-)
14:00:33 <kc5tja> matthew-_: You must program in EVERYTHING then, since all the keys are worn.  :)
14:01:26 <matthew-_> the new super languge: more than turing-complete. EVERYTHING
14:02:23 <thorat> mathrick_: the next super language should be less than turing-complete
14:02:37 <elaforge> hey, does anyone know if there's a standard name for do {x<-a; b; return x} ?
14:02:49 <dbremner> mbishop-added a Fortran entry
14:02:53 <elaforge> I've been using #>> since I remembered, um, wash I think defined # for that
14:02:57 <mbishop> dbremner: :)
14:03:16 <thorat> mathrick_: only statically guaranteed terminating functions allowed
14:03:38 <yip> @seen kolmodin
14:03:38 <lambdabot> kolmodin is in #darcs, #gentoo-haskell and #haskell. I last heard kolmodin speak 56m 43s ago.
14:03:39 <matthew-_> thorat: err, I doubt that somehow. In fact, current trends seem to be to make the type system closer to turing-completeness.
14:03:56 <matthew-_> and termination is only half the problem
14:03:58 <Philippa> thorat: you're oversimplifying
14:04:05 <thorat> hehe
14:04:18 <Philippa> the next superlanguage'll have to be able to do a number of things that require turing completeness to be sufficiently super, anyway
14:04:27 <nmessenger> elaforge: that's (Control.Applicative.<*), but not all monads have an Applicative instance :(
14:05:32 <thorat> thorat: turing completeness is overrated, it's so last century ;)
14:05:38 <nmessenger> (*>) = (>>), (<*) = what you said
14:05:44 <shapr> Today's nifty error message: *Main> thread blotttchhhkrrreeeedaaa dddi   nbbbdllleooofcccikkkneeeidddt   eiiilnnnydddeeefffiiinnniiittteeelllyyy
14:05:54 <matthew-_> besides, it's slightly odd to talk about "the *next* superlanguage" given there isn't a current superlanguage...
14:06:02 <shapr> Is that cool or what? :-)
14:06:22 <chessguy> i swear one of these days i'm going to make http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html my home page
14:06:24 <lambdabot> http://tinyurl.com/2gwkse
14:06:29 <nmessenger> shapr: that's far too awesome
14:06:41 <chessguy> ?remember shapr Today's nifty error message: *Main> thread blotttchhhkrrreeeedaaa dddi   nbbbdllleooofcccikkkneeeidddt   eiiilnnnydddeeefffiiinnniiittteeelllyyy
14:06:41 <lambdabot> Done.
14:07:03 <elaforge> nmessenger: aha, cool.  doesn't look like parsec is one of them though
14:07:32 <nmessenger> elaforge: precisely.  I tried to use it myself.
14:07:54 <elaforge> nmessenger: the applicative paper gave me a headache anyway :/
14:08:07 * nmessenger didn't read it
14:08:23 <dbremner> matthew-_: Arthur Whitney's K or Q might qualify. It's certainly terse enough.
14:08:24 <nmessenger> I just know that the functions there do simple enough things
14:09:04 <elaforge> nmessenger: hmm, that's a good approach, I should try that :)
14:09:05 <nmessenger> instance Applicative (GenParser ...) where pure = return; (<*>) = ap
14:09:18 <chessguy> @pl \t -> d (f s t)
14:09:18 <lambdabot> d . f s
14:09:47 <nmessenger> > [(+1), (*3)] <*> [3, 5]
14:09:48 <lambdabot>  [4,6,9,15]
14:10:17 <thorat> dbremner: the problem with K is that there's no free download anymore
14:10:28 <yip> how can i check if a Data.Map contains a certain value?
14:10:29 <sieni> shapr: are you already on that level? http://www.youtube.com/watch?v=jga10zt5yU4
14:10:37 <nmessenger> > (+1) <$> [3, 5] -- (<$>) = fmap = map in this case
14:10:38 <allbery_b> @ty M.lookup
14:10:39 <lambdabot>  [4,6]
14:10:40 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
14:10:49 <allbery_b> er?
14:10:54 <allbery_b> @ty lookup
14:10:56 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:11:01 <allbery_b> hrm
14:11:01 <dbremner> thorat- that disappointed me. I've still got old binaries somewhere but not for this OS/platform.
14:11:12 <chessguy> ugh. why can't i just do this: instance Show (Tree X) where show = drawTree . fmap show
14:11:23 <chessguy> (assuming i know X is an instance of Show)
14:11:24 <allbery_b> oh,, wait, the first was right.  Monad for result Either String or Maybe or []
14:11:35 <nmessenger> chessguy: add Show a =>
14:11:38 <allbery_b> @ty M.find
14:11:40 <lambdabot> Couldn't find qualified module.
14:11:52 <chessguy> a?
14:12:04 <nmessenger> instance Show a => Show (Tree a) where ...
14:12:38 <chessguy> oh, i have to do it polymorphically, even though i'm only worried about a specific instance?
14:12:41 <elaforge> nmessenger: urm, so <*> is like mapping fmap?  oh I see, it lifts the lhs and the rhs and applies "inside"
14:12:52 <emu> @hoogle &&&
14:12:52 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
14:13:11 <yip> allbery_b: no, i want to check for a value, not a key
14:13:37 <allbery_b> oh.  think there's npo good way to do that
14:13:44 <nmessenger> elaforge: (<*>) is ap, ap uses (>>=) to draw out each function and each argument and returns the result back
14:13:47 <nmessenger> @src ap
14:13:47 <allbery_b> (aside frm various forms of iterating the whole thing)
14:13:47 <lambdabot> ap = liftM2 id
14:14:00 <chessguy> nmessenger, that gives me overlapping instances
14:14:02 <nmessenger> = liftM2 ($)
14:14:06 <nmessenger> @src liftM2
14:14:06 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:14:13 <nmessenger> chessguy: hmm, I'm not sure then :/
14:14:27 <chessguy> but i can't hide Data.Tree.show, because it's not exported
14:15:20 <yip> allbery_b: so (elem . elems)?
14:15:28 <shapr> sieni: Heck no, that guy is like top five in the world.
14:15:30 <nmessenger> what does (Tree a) show look like?
14:15:45 <elaforge> @ty ap
14:15:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:15:53 <sjanssen> instance Show (Tree a) overlaps instance Show (Tree X) anyway
14:15:56 <glguy> Data.Tree already has a Show instance
14:16:12 <elaforge> @ty <*>
14:16:15 <lambdabot> parse error on input `<*>'
14:16:17 <chessguy> glguy, yeah, but i'm trying to use Data.Tree.drawTree
14:16:22 <nmessenger> parens
14:16:22 <elaforge> @ty (<*>)
14:16:22 <chessguy> instead
14:16:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:16:29 <nmessenger> the same
14:16:36 <glguy> chessguy: then you'd have to use that specific function
14:16:42 <glguy> chessguy: Show is matched with Read
14:16:49 <glguy> and read can't handle the drawTree outout
14:17:03 <chessguy> glguy, i have instance Show a => Show (Tree a) where
14:17:04 <chessguy>    show = drawTree . fmap show
14:17:20 <glguy> chessguy: you'd have to use a newtype then
14:17:23 <glguy> since that instance is defined
14:17:31 <elaforge> I see.  I recall that Applicative is slightly more general than Monad because, um, something about not supporting sequential dependence
14:17:40 <chessguy> newtype where?
14:18:00 <glguy> newtype YourTree a = YourTree (Tree a)
14:18:13 <glguy> then you could defined instances on that
14:18:24 <chessguy> but drawTree doesn't take YourTree's
14:18:36 <sjanssen> chessguy: is it strictly necessary to override Tree's Show behavior?  Could you introduce a prettyPrintTree function instead?
14:18:46 <glguy> drawYourTree (YourTree a) = drawTree a
14:19:15 <chessguy> sjanssen, hmm, i guess i could
14:19:16 <elaforge> nmessenger: which I guess would be a problem with parsec because you couldn't do the bind?
14:19:30 <glguy> chessguy: the problem is that you are trying to use Show for something other than debugging output
14:19:47 <nmessenger> elaforge: eh?  If the parsers are monads, then by definition they have (>>=)
14:19:56 <chessguy> glguy, i'm trying to output the end result of my program, yes
14:19:59 <elaforge> yeah, but applicative doesn't
14:20:24 <elaforge> so the parser can't be applicative and keep the binding?
14:20:28 <nmessenger> elaforge: oh, I misunderstood your question :)
14:21:05 <nmessenger> the Functor, Applicative, and Monad classes say what a type *can* do, not what it *can't*.
14:21:14 <nmessenger> It'd be fine.
14:21:24 <elaforge> nmessenger: aha, yes, of course
14:21:55 <nmessenger> just because monad doesn't have run :: m a -> a, doesn't mean you can have head :: [a] -> a
14:21:55 <elaforge> nmessenger: just like monads get functor for free
14:22:38 <nmessenger> techincally, Monads subclass Applicative Functors, which subclass Functors, regardless of actual implementation :D
14:22:46 <chessguy> sjanssen, so just prettyPrintTree = print $ drawTree . fmap show
14:22:58 <mbishop> http://programming.reddit.com/info/17p6x/comments
14:23:00 <lambdabot> Title: Ask Reddit: Why don&#39;t you use Scheme? (reddit.com)
14:23:05 <sjanssen> chessguy: sure, if you want to involve IO
14:23:15 <mbishop> spam! :P
14:23:25 <glguy> chessguy: you want putStr for the output rather than print
14:23:25 <elaforge> nmessenger: yeah, it's getting clearer.  thanks a lot
14:23:48 <chessguy> glguy, oh? why's that?
14:24:03 <glguy> :t print
14:24:05 <lambdabot> forall a. (Show a) => a -> IO ()
14:24:06 <glguy> ?src print
14:24:07 <lambdabot> print x = putStrLn (show x)
14:24:24 <glguy> because otherwise you'll have your output wrapped in quotation marks
14:24:57 <nmessenger> functor = type + fmap, applicative = functor + return (pure) + ap (<*>), monad = applicative + bind/join
14:25:41 <chessguy> @type drawTree . fmap show
14:25:43 <lambdabot> forall a. (Show a) => Tree a -> String
14:26:29 <chessguy> @type putStr . drawTree . fmap show
14:26:32 <lambdabot> forall a. (Show a) => Tree a -> IO ()
14:28:00 <ndm> @hoogle drawTree
14:28:00 <lambdabot> Data.Tree.drawTree :: Tree String -> String
14:29:05 <chessguy> > 8388608 * 2
14:29:06 <lambdabot>  16777216
14:29:14 <sorear> newsham: ping
14:29:51 <chessguy> heh
14:29:52 <chessguy> nice
14:29:55 <chessguy> *
14:29:55 <chessguy> |
14:29:55 <chessguy> +- +
14:29:55 <chessguy> |  |
14:29:55 <chessguy> |  +- 1
14:29:56 <chessguy> |  |
14:29:58 <chessguy> |  `- X
14:30:00 <chessguy> |
14:30:02 <chessguy> `- X
14:30:13 <elaforge> one more: is there a well-behaved way to turn a low-level polling interface into a lazy list?
14:30:18 <elaforge> I've been doing
14:30:22 <elaforge>     evts <- poll; threadDelay n
14:30:28 <elaforge>     rest <- unsafeInterleaveIO stream
14:30:28 <elaforge>     return (evts ++ rest)
14:30:58 <elaforge> but it doesn't look tail recursive
14:31:48 <elaforge> nmessenger: I'll keep that in mind, I think the problem is I learned these in the wrong order :)
14:31:50 <kpreid> is the preceding line "stream = do"?
14:31:55 <elaforge> yeah, sorry
14:32:02 <elaforge> and then the whole thing in a forkIO of course
14:32:06 <sjanssen> elaforge: that code looks fine
14:32:09 <kpreid> yea, that should be tail-recursive
14:32:19 <kpreid> oh, but rest isn't monadic, is it?
14:32:34 <kpreid> so it should be return (evts ++ unsafeInterleaveIO stream)
14:32:52 <sjanssen> kpreid: that doesn't type
14:33:04 <kpreid> @type IO.unsafeInterleaveIO
14:33:06 <lambdabot> Not in scope: `IO.unsafeInterleaveIO'
14:33:10 <kpreid> @type Foreign.unsafeInterleaveIO
14:33:12 <lambdabot> Not in scope: `Foreign.unsafeInterleaveIO'
14:33:18 <elaforge> kpreid: well, then the client will do
14:33:25 <elaforge> evt_stream <- stream
14:33:32 <elaforge> do_pure_stuff_with evt_stream
14:33:42 <kpreid> oh, I was confused with unsafePerformIO
14:33:53 <dmhouse> ?hoogle unsafeInterleaveIO
14:33:53 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
14:34:11 <kpreid> what about doing return (evts ++ unsafePerformIO stream) ?
14:34:25 <sjanssen> kpreid: blech
14:34:37 <kpreid> point
14:34:45 <kpreid> I'll shut up now
14:34:49 <sjanssen> kpreid: but semantically, it's the same as elaforge's original code
14:35:01 <sorear> @seen newsham
14:35:02 <lambdabot> newsham is in #haskell, #haskell-blah and #happs. I last heard newsham speak 54m 41s ago.
14:35:06 <elaforge> I guess I don't know how to recognize tail recursion :/
14:35:23 <elaforge> it seemed so straightforward in scheme...
14:35:27 <sjanssen> elaforge: this case is tricky
14:35:33 <kpreid> elaforge: actually, in Haskell you don't want tail recursion
14:35:35 <kpreid> no, now that I understand what unsafeInterleaveIO is I agree it'd be better to do that
14:35:37 <sjanssen> unsafeInterleaveIO is deep dark magic
14:36:13 <elaforge> kpreid: oh?  elaborate?
14:36:27 <sjanssen> elaforge: you are right though, the code you pasted isn't really tail recursive
14:36:34 <kpreid> elaforge: for maximum laziness, you want to bury the recursive call as deep as you can, so it's executed as late as possible
14:36:44 <sjanssen> it lazily produces the list (which is better)
14:36:50 <kpreid> elaforge: whereas tail recursion is about putting the recursive call as shallow as possible
14:37:19 <elaforge> but ghc has special magic that enters the recursive call without accumulating stack when the tail thunk is forced?
14:37:34 <kpreid> elaforge: not exactly
14:37:43 <kpreid> the stack elements have gone away already
14:38:16 <elaforge> but that's not always the case with laziness, e.g. fold stack explosion
14:38:45 <kpreid> hm, I'm not remembering the details
14:38:45 <sjanssen> elaforge: yes, there are cases where you want strictness+tail recursion
14:38:54 <sjanssen> Cale has a nice rule of thumb
14:39:03 <kpreid> it's the *heap* that goes boom if you do foldr1 (+) ...
14:39:03 <Cale> :)
14:39:51 <sjanssen> kpreid: no, the stack blows up there
14:39:51 <sorear> kpreid: no, foldr1 will blow the stack (on a G-machine impl, graph reduction will blow the heap)
14:39:55 <dmhouse> > foldr1 (+) [1..]
14:39:57 <lambdabot>  Exception: stack overflow
14:40:00 <Cale> You want strictness when you're reducing a large structure (with many separately evaluable parts) down to a small structure (with few subparts)
14:40:12 <elaforge> makes sense
14:40:22 <Cale> In basically all other cases, you want laziness, or the distinction is unimportant.
14:40:40 <dmhouse> kpreid: it keeps recursing on each element of the list; every recursion needs a new stack level, etc.
14:40:56 * kpreid thinks
14:41:09 <kpreid> oh, I see. + being (usually) strict
14:41:39 <sorear> is there any case where normal order graph reduction is asymptotically worse than applicative order?
14:41:41 <kpreid> right, whereas foldl will build up the + structure, and foldl' is just right
14:42:27 <elaforge> sorear: I thought normal order was provably the least reductions
14:42:35 <Cale> sorear: I don't think so. Further, assuming purity, you can get fundamentally better complexity algorithms with laziness than with strict evaluation.
14:42:59 <sorear> I recognize that, for the CPU case.
14:43:16 <Philippa> sorear: repeat after me: laziness != non-strictness
14:43:16 <sorear> I'm being deliberately polymorphic enough to include memory.
14:43:48 <Philippa> Cale: I'm guessing that result doesn't hold for call-by-name?
14:44:11 <chessguy> ?hoogle pretty
14:44:11 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
14:44:12 <Philippa> or at least, for nowhere near as many useful cases beyond the obvious infinite->finite time reduction?
14:44:12 <lambdabot> Text.Html.prettyHtml' :: HtmlElement -> [String]
14:44:18 <chessguy> ?hoogle+
14:44:19 <sorear> Philippa: huh?  Normal order graph reduction is laziness
14:44:25 <elaforge> anyway, thanks everyone, guess I'll keep my unsafePerformIO
14:44:39 <sorear> Philippa: or do I need to recheck the IFPL errata?
14:44:50 <Cale> I'm talking about absolute bounds with the ability to choose different algorithms in the strict/lazy case.
14:44:53 <sjanssen> elaforge: I hope you mean unsafeInterleaveIO?
14:45:00 <Cale> There was a paper on it a while back.
14:45:04 <elaforge> sjanssen: uh, right, sorry
14:45:13 <sorear> @users
14:45:13 <lambdabot> Maximum users seen in #haskell: 336, currently: 335 (99.7%), active: 54 (16.1%)
14:45:30 <Cale> sorear: er, if you include sharing in that description
14:45:30 <sjanssen> elaforge: just checking :).  unsafePerformIO is a dirty word 'round here
14:45:47 <Philippa> sorear: laziness generally requires call-by-need rather than call-by-name
14:45:50 <elaforge> sjanssen: well, I wanted to avoid unsafeInterleaveIO too
14:45:52 <Cale> (Perhaps that's what you mean by "graph")
14:46:02 <Philippa> *nod*
14:46:05 <sorear> Cale: yeah.  graphs have sharing.  trees don't
14:46:08 <Cale> I'm always confused by the call-by-X terms :)
14:46:16 <sorear> Cale: at least in IFPL's definitions
14:46:30 <elaforge> sjanssen: but I *am* sampling the hardware, so RealWorld has to be involved, I guess
14:46:31 <Philippa> CBName is also non-strict
14:46:44 <chessguy> ?vera IFPL
14:46:46 <lambdabot> No match for "IFPL".
14:46:47 <elaforge> I always thought lazy = normal order + non strict data constructors
14:46:52 <dmhouse> Philippa: is the essential difference between laziness and non-strictness that laziness is 'aggressive' non-strictness, in that non-strictness just says 'some things might not be evaluated', and laziness says 'only what's necessary will be evaluated'?
14:47:02 <Cale> I don't really think in terms of calling, I think in terms of reduction steps. ;)
14:47:05 <sorear> chessguy:
14:47:12 <sorear> @go slpj-book-1987
14:47:14 <lambdabot> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
14:47:14 <lambdabot> Title: The Implementation of Functional Programming Languages
14:47:19 <chessguy> ah
14:47:29 <sorear> interestingly, that is #2 on google "slpj"
14:47:35 <Philippa> dmhouse: arguably, yeah. Laziness is also about whether things get re-evaluated though
14:47:43 <Cale> dmhouse: Non-strict is the name of semantics. Laziness is one implementation of non-strict semantics.
14:47:44 <sorear> spj gives a completely different set of results
14:48:23 <Philippa> Cale: or perhaps more accurately, non-strictness is a denotational one, laziness is one operational approach or class of approaches
14:48:37 <Cale> Non-strict semantics just means that you get the same results/termination behaviour in the end as lazy evaluation gives you.
14:48:38 <Philippa> er, denotational property
14:49:12 <Cale> Even though the actual evaluation order might be different -- for example alternating between innermost and outermost reductions.
14:50:09 <elaforge> so then what's "full laziness"?  is that the "never evaluate twice" thing?
14:51:01 <xian> i have a problem understanding why a context is added for a "return type" as in "(RealFrac a, Integral b) => a -> (b,a)"   why do we need to specify that b is in instance of Integral? Can't this function just return an Int instead?
14:51:29 <Philippa> yeah. Or as it's usually seen as a property of various transformations, you can see it as "laziness-preserving" if you like
14:51:36 <dmhouse> xian: but you might want it to return an Integer.
14:51:37 <nmessenger> xian: it could also return an Integer
14:51:43 <dmhouse> nmessenger: not quite,.
14:51:51 <elaforge> xian: it could as a specialization
14:51:53 <dmhouse> It has to return a value which is common to both types.
14:52:15 <dmhouse> So the person who has this Integral b => b value can assume it to be either an Int or an Integer.
14:52:17 <xian> ahh, ok, i think i get it.
14:52:18 <kc5tja> elaforge: It's more accurately described, "Don't do a dang thing unless you need to."
14:52:43 <elaforge> kc5tja: a noble principle :)
14:52:52 <Philippa> kc5tja: nah, arguably sharing is work...
14:53:00 <nmessenger> I don't understand how "it could also return an Integer" is different from "you might want it to return an Integer"
14:53:18 <kc5tja> Philippa: ??
14:53:50 <sorear> kc5tja: full laziness is about sharing
14:53:58 <sorear> foo x y = sqrt x + y
14:53:58 <Philippa> kc5tja: full laziness is about getting and exploiting the maximum of sharing in order to reduce the amount of "work" (evaluation) you do
14:54:02 <sorear> ba = foo 1000
14:54:09 <sorear> map ba [1..1000]
14:54:16 <dmhouse> nmessenger: the way I read your statement, you were saying that the function returns something which is either an Int or an Integer. This is wrong. It returns something which is both.
14:54:23 <sorear> how many times is sqrt 1000 evaluated.
14:54:31 <dmhouse> Philippa: as in CSE?
14:54:41 <Philippa> dmhouse: no
14:54:53 <elaforge> dmhouse: but the actual value is concrete
14:55:00 <Philippa> dmhouse: as in not doing the inverse
14:55:13 <kc5tja> sorear: Strictly speaking, never.  The list ranges from 1 to 1000, so given (foo 1000) [1..1000], sqrt (1000+0) is never a consideration.  :)
14:55:26 <Philippa> dmhouse: no, it returns something that is one when you tell it which you want. You'll never actually treat it as both
14:55:42 <dmhouse> elaforge: sure. If you think of types as sets, it's a value which appears in the intersection of Int and Integer.
14:55:45 <Philippa> at best you treat it as /either/
14:55:47 <sorear> kc5tja: wrong!  recheck your parsing
14:55:59 <nmessenger> dmhouse: at any invocation, at runtime, it will return only one type.  A value can't have more than one type (modulo some typeclass hackery I've not considered)
14:56:07 <elaforge> dmhouse: except no value can be two types at once
14:56:23 <dmhouse> Of course it can; this is what polymorphism is all about.
14:56:24 <elaforge> dmhouse: the function could be instantiated at different types
14:56:26 <Philippa> dmhouse: *no*. 5::Int and 5::Integer are distinct values, with distinct concrete representations
14:56:37 <kc5tja> sorear: Damn operator precedence to hell.  This is why I prefer RPN.  :)
14:56:45 <sorear> it has type |~| a -> NumDict a -> a
14:56:46 <elaforge> dmhouse: but if you e.g. pass f to a function it will become monomorphic (except rank-2 I guess)
14:56:48 <sorear> it has type |~| a => NumDict a -> a
14:57:18 <dmhouse> Okay. I guess I should rephrase, then.
14:57:29 <dmhouse> (The example of numerals with their overloading perhaps confused me.)
14:57:49 <kc5tja> sorear: However, if evaluated just once, it fully conforms to my definition too.  Sharing is just a method by which the environment strives to minimize its amount of work.
14:58:38 <dmhouse> If you have x :: Integral a => a, then you can assume it's an Int (for example you could do x == length [1..5]), or assume it's an Integer.
14:59:01 <dmhouse> You tell x that you want to assume it's an Int, say, and x conjours up itself as an Int type.
14:59:14 <nmessenger> dmhouse: yes, but the compiler will reject it unless it can infer only one type.
14:59:35 <nmessenger> er, at top level invocation, that is.
14:59:53 <dmhouse> Yes.
15:00:16 <Saizan> a way to say this is that if you have foo :: (Foo x) => Blah -> x, foo can't decide which instance of Foo return, instead it has to return something that can be anyone of them
15:00:33 <rag3> > takeWhile even [1..]
15:00:34 <lambdabot>  []
15:00:38 <rag3> why is this?
15:00:40 <dmhouse> Saizan: that's what I was saying before, but got shot down for it :)
15:00:51 <dmhouse> rag3: takeWhile takes elements from the front of the list while the predicate is true.
15:01:04 <nmessenger> dmhouse: I think we both understand but just have different notions of what "type" means.
15:01:09 <dmhouse> rag3: the first element in [1..] is an odd number, so it fails straight away and returns the empty list.
15:01:13 <dmhouse> > filter even [1..]
15:01:15 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
15:01:17 <rag3> dmhouse: thanks
15:01:20 <dmhouse> rag3: did you mean that?
15:01:21 <rag3> I need filter then
15:01:29 <rag3> dmhouse: yes. thanks
15:01:49 <Saizan> dmhouse: yeah, trying to rephrase in a different way and see if it was clearer :)
15:01:56 <dmhouse> I'll keep going.
15:02:05 <JohnMeacham> anyone have that code snippet that enumerates the cross product of two lists? basically [ (x,y) | x <- xs, y <- ys] except it works on infinite lists just fine.
15:02:55 <dmhouse> If you have, say, x :: Show a => a, there's no way x can conjour itself up to be something that is a String, Bool, (), Int, etc. on demand, so x must be undefined.
15:03:06 <nmessenger> JohnMeacham: someone might have a DiagList type somewhere on the wiki
15:03:23 <thorat> JohnMeacham: the one from "The fun of programming"?
15:03:39 <dmhouse> It's only the presence of overloaded numeric literals that makes numeric polymorphism work a lot of the time, I guess.
15:04:20 <Philippa> dmhouse: once you have a notion of type lambda (and supplying semantics to haskell's polymorphism is easiest if you infer type lambdas and applications), it's actually quite tricky to give a good semantics for types in terms of sets. Impossible if you have an impredicative type system
15:04:57 <thorat> JohnMeacham: if so then: http://web.comlab.ox.ac.uk/oucl/publications/books/fop/dist/fop/chapters/9/Logic.hs
15:04:59 <lambdabot> http://tinyurl.com/27dsvn
15:05:27 <rag3> how do I specify Int in a condition? [f x | x <- Int]
15:06:02 <dmhouse> [ f x | x <- whatever :: Int ]
15:06:15 <dmhouse> Or [ f x | (x::Int) <- whatever ] with -fglasgow-exts
15:06:35 <nmessenger> er, the first should be [Int]
15:06:52 <dmhouse> > [ f x | x <- [1..5] :: Int ]
15:06:53 <lambdabot>   Not in scope: `f'
15:06:57 <dmhouse> > [ x | x <- [1..5] :: Int ]
15:06:58 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
15:07:15 <dmhouse> nmessenger: sorry. I guessed the :: would scope right back to the 'x'. :: has an awfully large scope.
15:07:29 <nmessenger> the <- syntax is higher-level than ::
15:07:36 <Philippa> <- isn't an operator
15:07:51 <nmessenger> :: scopes over whole expressions I believe
15:07:54 <Korollary> <- is a smooth operator
15:08:28 <thalassocrac> [x|x<-[1,1.5], x :: Int]
15:09:08 <nmessenger> thalassocrac: conditions have to be Bool :P
15:09:31 <nmessenger> > [x|x<-[1,1.5], let _ = x :: Int]
15:09:32 <lambdabot>   add an instance declaration for (Fractional Int)
15:09:32 <lambdabot>     In the expression: 1.5...
15:09:33 <rag3> Wow... I finally made problem 2 in a way that looks like Haskell-ish
15:09:47 <nmessenger> > [x|x<-[1,5], let _ = x :: Int]
15:09:48 <lambdabot>  [1,5]
15:10:14 <mbishop> rag3: sum of fibs one?
15:12:21 <rag3> yes mbishop
15:12:33 <mbishop> rag3: want to see mine? it's 2 lines heh
15:13:52 <rag3> mbishop: that will make me sad :-)
15:13:57 <rag3> can I show you mine?
15:14:01 <mbishop> sure
15:14:34 <mbishop> ?paste
15:14:34 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:14:35 <hpaste>  rag3 pasted "Problem 2" at http://hpaste.org/778
15:15:08 <kmag2> Where does ghc generally keep its runtime libs?  My installation on OS X seems to be having linkage problems.
15:15:13 <rag3> Using ghci inference to get the type of a function and then pasting it in one's own code is considered cheating? :-)
15:15:19 <hpaste>  mbishop annotated "Problem 2" with "(no title)" at http://hpaste.org/778#a1
15:15:49 <hpaste>  augustss annotated "Problem 2" with "This is much more efficient" at http://hpaste.org/778#a2
15:16:24 <augustss> rag3: no, that's not cheating.  it's normal :)
15:16:32 <sorear> rag3: not at all. infact both emacs and vi have automation for it!
15:16:45 <allbery_b> kmag2: <base>/lib/ghc-6.6 where <base> depends on how you installed it
15:17:11 <allbery_b> (/opt/local if you used macports; for the canned tarball the default is /usr/local)
15:17:11 <kmag2> albery_b: thanks.  I used the installer dmg.
15:17:17 <ndm> augustss: but if you put it in a library, users will not like you
15:17:35 <Saizan> rag3: also your f is yet the fibonacci sequence, infinitely indexing it is quite strange
15:17:35 <allbery_b> hm, installer dmg?  not aware of that one
15:18:10 <sorear> ndm: huh?  I like type sigs in my libs, and I don't care that they came from ghci!
15:18:52 <ndm> sorear: i meant augustss's annotation, users tend to like type sigs - if they don't have them then you get no haddock, and Hugs is the perfect way to find them
15:19:34 <Philippa> putting annotations with forall in the library isn't a good idea unless there's no H98 type anyway
15:19:46 <kmag2> albery_b: Audrey Tang's tarball, no dmg.  I was mistaken.
15:20:00 <rag3_> sorry I got disconnected
15:20:06 <sorear> @users
15:20:06 <lambdabot> Maximum users seen in #haskell: 336, currently: 333 (99.1%), active: 53 (15.9%)
15:20:10 <sorear> :(
15:20:14 <rag3_> mbishop: isn't your code more or less the same?
15:20:21 * mbishop nods
15:20:37 <mbishop> except I don't modularize it into functions
15:21:13 <rag3_> thanks augustss
15:21:35 <rag3_> I'm honored to be annotated by you
15:22:07 <kmag1> hmm... so how does one point ghc at its runtime?
15:22:23 <kmag1> I get /usr/bin/ld: Undefined symbols:
15:22:27 <kmag1> _parseczm2zi0_TextziParserCombinatorsziParsecziChar_oneOf_closure
15:22:39 <sorear> use ghc --make
15:23:03 <kmag1> sorear: thanks!!!
15:23:32 <kmag1> why doesn't it usually link against the ghc runtime?
15:23:38 <sorear> it does
15:23:47 <sorear> that's not a runtime symbol
15:23:54 <sorear> that's a parsec symbol
15:24:12 <sorear> unmangling, it is Text.ParserCombinators.Parsec.Char.oneOf
15:24:27 <allbery_b> parsec is one of the packages unbundled in 6.6.
15:24:35 * ndm loves z-encoding
15:24:53 <sorear> loves or "loves"?
15:25:00 <allbery_b> not sure where you'd get it from your .dmg install image (I don't see one on haskell.org/ghc/download...)
15:25:50 <ndm> well every time i see z-encoding i know exactly why Yhc.Core doesn't mangle names :)
15:26:33 <sjanssen> yhc doesn't compile to C
15:27:18 <sorear> we need @hsfilt
15:27:35 <ndm> sjanssen: yet, i have an experimental back end floating around which does
15:27:59 <sjanssen> ndm: and then you'll mangle your names :)
15:28:25 <ndm> sjanssen: oh yes, we mangle, but at the last possible second, not at the begining of the pipeline
15:28:32 <augustss> or if you compile to assembly code
15:28:50 <sorear> yay! I've finally implemented the APPLY bytecode.  only took 6 hours and 61 loc ...
15:28:51 <allbery_b> well, that symbol error is at the end of the pipeline
15:28:58 <augustss> well, when you get an error message from the linker it's hard to avoid the mangling
15:29:29 <allbery_b> by the time you reach ld, it's mangled. :/ unless you can come up with a trick to make haskell mangled names look  like C++ mangled names yet demangle to something recognizeable
15:29:36 <allbery_b> (and that only with gnu ld)
15:29:51 <sorear> maybe when Haskell is as popular as C++ ...
15:30:02 <sjanssen> ghc z encodes at the beginning of the pipeline?
15:30:04 * mbishop laughs
15:30:06 <allbery_b> ideally ld would have pluggable demangler modules
15:30:13 <Philippa> ndm: remind me, YHC.Core isn't a supercombinator language?
15:30:24 <sorear> Philippa: it is
15:31:17 <Philippa> *nod* - that'll tend to cause at least some mangling to compensate for scoping, no?
15:31:40 <sorear> Philippa: why mangle when you can rename?
15:31:53 <sorear> Philippa: Yhc.core uses names like LAMBDA4246
15:32:01 <sorear> Philippa: nice and readable!
15:32:46 <ndm> sjanssen: GHC Core only has mangled names
15:33:06 <ndm> Philippa: its a core language a lot like GHC, but slightly more restrictive
15:33:42 <ndm> sorear: those are internal lambda's, they never had a name to start with - but it would be nice if they were given a sensible one (like their parent_1 or something)
15:34:07 <sorear> ndm: yhc generates ridiculous bytecode for 'foreign import ccall ayhi_exit :: Int -> IO () ; main = ayhi_exit 42'
15:34:29 <ndm> sorear: what does it generate? if you have a dump hpaste it
15:34:30 <sorear> I never thought I'd need apply to get that program working ;)
15:34:54 <kmag1> YHC internally generates code for a stack abstract machine?
15:35:16 <ndm> kmag1: yes, like an STG machine as described in the SPJ Lester book
15:36:03 <sorear> ndm: which one? the "A tutorial" one?
15:36:43 <ndm> sorear: no idea, Tom read the book, not me :)
15:37:01 <hpaste>  sorear pasted "bytecodes" at http://hpaste.org/779
15:37:29 <sorear> notice that the system constructs a CAF for the foreign call, then uses APPLY
15:37:51 <sorear> when using the same primitives it should be able to use MK_AP
15:38:44 <ndm> sorear: could you define that as a local transformation to bytecodes?
15:39:47 <sorear> ndm: no.  the problem is that ayhi_exit is being defined with arity 0, so all calls must use apply. arity-raising is needed here.
15:40:01 <sorear> perhaps a rewrite, but at ayhi_exit, not main
15:40:32 <sorear> _mkIOok1 is suspicios
15:40:40 <ndm> if you can think of something concrete, feel free to propose it
15:40:46 <sorear> it is sooo simple, yhc Ought To Inline It
15:40:54 <ndm> oh, Yhc -O will :)
15:41:06 <ndm> but Yhc as it stands can't inline _anything_
15:41:13 <sorear> will Yhc -O1 generate any bytecodes?
15:41:18 <ndm> yep
15:41:26 <ndm> yhc -O will:
15:41:33 <sorear> ah good.  ayhi won't be obsolete tomorrow :)
15:41:34 <tiHo> hi! see this site: _http://tattoo.clan.su   Free forum! (by Russia) (5 languages: russian, english, deutch, france,spain) ;) and #freeforum
15:41:37 <lambdabot> Title:    -  
15:41:44 <ndm> generate yhc core, transform yhc core, output haskell, compile with yhc
15:41:45 <allbery_b> gah
15:42:00 <sorear> allbery_b: we needn't respond
15:42:27 <allbery_b> I know, it's just annoying
15:43:18 <sorear> ndm: ... compile with yhc ? the current code seems optimal *at the haskell level*, so how could yhc -O make it better without generating bytecodes/core itself?  or does the generated haskell use special magic unsafe primops?
15:44:18 <ndm> sorear: if it is optimal at the haskell level, it won't get any better - but things like _mkIOok1 can get inlined
15:44:35 <ndm> depends, i have no idea quite how ffi stuff will work
15:45:14 <sorear> well, if it can depend on the repr of IO, that's good enough
15:46:08 <sorear> ayhi's jit plans work at the bytecode level, so it won't have a hope of being able to do core optimizations like fusion
15:46:13 <ndm> initially it will be a total hack, guaranteed only on nobench
15:46:30 <ndm> thats perfect, fusion and stuff is what -O will get, the low level bytecode is left for someone else
15:47:52 * sorear still thinks Stewartian streams are PURE GENIUS
15:48:00 <sorear> codata ftw
15:48:07 <rag3_> what's the name of the function used to obtain a list of prime numbers
15:48:18 <sorear> let :)
15:48:28 <dcoutts> ndm, so what days will you be in Oxford? Damien and I were thinking of inviting you to talk about catch and/or fusion.
15:48:28 <sorear> it's not predefined
15:48:28 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
15:48:43 <sorear> > map fst $ filter ((==1) . uncurry gcd) $ ap zip (scanl (*) 1) [2..]
15:48:45 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:48:51 <rag3_> sorear: holy
15:49:01 <merus> well played.
15:49:10 <sorear> rag3_: I <3 C-r
15:49:23 <sorear> (emacs for 'search backward')
15:49:34 <bd_> > ap zip (scanl (*) 1) [2..]
15:49:35 <lambdabot>  [(2,1),(3,2),(4,6),(5,24),(6,120),(7,720),(8,5040),(9,40320),(10,362880),(11...
15:49:40 <sorear> I played that a couple hours ago, I didn't write it now :)
15:49:44 <bd_> aha.
15:49:53 <ndm> dcoutts, 2nd to the 5th i think, but from what i remember BCTCS is very solid talks etc
15:50:15 <dcoutts> ndm, of April? hmm, I'll be in .au anyway.
15:50:15 <rag3_> how do I obtain a list of prime factors of a number?
15:50:28 <ndm> dcoutts, yeah, April
15:50:35 <ndm> the last 3 days before the ICFP deadline...
15:50:49 <dcoutts> ndm, ah, heh, good timing
15:51:02 <ndm> yeah, i may have a laptop and be sneaking out to internet cafe's :)
15:51:19 <dcoutts> @tell Orphi check out the demo/cairo/StarAndRing.hs it shows how to create a bitmap surface and write it out to a .png file.
15:51:19 <lambdabot> Consider it noted.
15:52:14 <rag3_> there are no defined functions to obtain a list of prime factors of a given number, right?
15:52:37 <augustss> rag3_: right
15:53:25 <rag3_> problem is, without loops, I've no idea how to obtain the list :)
15:53:38 <rag3_> damn Ruby programming... :)
15:53:41 <sorear> recursion!
15:53:46 <sorear> @users
15:53:46 <lambdabot> Maximum users seen in #haskell: 336, currently: 326 (97.0%), active: 48 (14.7%)
15:53:56 <dcoutts> @tell Orphi and some of the other cairo demos show how to create bitmaps and display them on screen.
15:53:56 <lambdabot> Consider it noted.
15:54:05 <augustss> rag3_: Haskell has many functions that loop for you :)
15:54:46 <bd_> > let factor n = (case (filter ((== 0).(n `mod`)) [2..n-1]) of [] -> []; (h:_) -> h:factor (n `div` h)) in factor 24
15:54:48 <lambdabot>  [2,2,2]
15:54:51 <bd_> hmm
15:54:55 <bd_> that's not right...
15:55:18 <bd_> > let factor n = (case (filter ((== 0).(n `mod`)) [2..n-1]) of [] -> [n]; (h:_) -> h:factor (n `div` h)) in factor 24
15:55:19 <lambdabot>  [2,2,2,3]
15:55:24 <bd_> > 2*2*2*3
15:55:26 <lambdabot>  24
15:55:28 <bd_> :)
15:55:46 <rag3_> augustss: is there a tutorial that is short (so I can read it in a reasonable amount of time) and that has a good coverage of the language and the common functions? I'm perfectly fine if it's academic or mathematical
15:55:58 <bd_> @check \n -> (n > 1) ==> (product $ let factor n = (case (filter ((== 0).(n `mod`)) [2..n-1]) of [] -> [n]; (h:_) -> h:factor (n `div` h)) in factor n) == (n :: Integer)
15:55:59 <lambdabot>  OK, passed 500 tests.
15:56:29 <bd_> I'm sure that can be done in a cleverer way.
15:58:48 <augustss> rag3_: I don't know.  I don't keep up with all tutorials :)
15:58:48 <rag3_> augustss: I see. And a good book perhaps?
15:58:48 <elaforge> rag3_: I actually think the report is pretty good
15:58:48 <elaforge> rag3_: not a lot of examples, of course :)
15:59:10 <elaforge> rag3_: I've looked at both School of Expression and Craft of Functional Programming
15:59:15 <rag3_> elaforge: I learn well with a lot of examples usually, so it may be not the first choice
15:59:45 <elaforge> SOE is more graphics, animation, type stuff
16:00:06 <elaforge> craft is more traditional CS-ey huffman encoding, etc. IIRC
16:00:16 <sorear> rag3_: do you already "get" recursion, laziness, datatypes, functions?
16:00:50 <rag3_> sorear: as concepts in general, I do
16:01:07 <rag3_> sorear: but I miss the building blocks, like common functions in haskell
16:01:29 <rag3_> sorear: if I don't know about filter, zipWith, scanl, foldl... it's hard to do programming
16:01:44 <sorear> @quote pieces
16:01:45 <lambdabot> earthy says: the haskell standard prelude is ... a treasure trove. ;) but it does require breaking your mind and reassembling the pieces to unlock the trove
16:02:05 <dancor> so this thread <A> and the (CVS'd! 13 mo old) code it links to are the state of the art on XHB.  i'm going to start taking a crack at pushing it further, is there anything else i should see first?  saw nothing on haskell.org.  A : http://www.nabble.com/Re%3A--Haskell--Haskell-Xlib-bindings-tf3187264.html#a8928696
16:02:07 <lambdabot> Title: Nabble - Re: [Haskell] Haskell Xlib bindings, http://tinyurl.com/yu54hf
16:02:34 <rag3_> sorear: eheheh
16:02:34 <elaforge> rag3_: all that stuff is docced in the prelude, but I don't know anything about "idiomatic uses" except maybe on the wiki
16:02:48 <rag3_> for example
16:02:53 <rag3_> and this is a very basic example
16:03:06 <rag3_> I want to find the largest element of a numeric list
16:03:14 <rag3_> I do not know if there is a function that does that for me
16:03:15 <sorear> rag3_: oldest Haskell code in existance, idiomatic because it set the idioms: http://haskell.org/onlinereport/standard-prelude.html
16:03:16 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
16:03:32 <elaforge> I'd go look in the ghc library doc for Data.List
16:03:38 <Saizan> > maximum [1..20]
16:03:38 <sorear> maximum, but if you read the prelude it'll show you the standard defs
16:03:39 <elaforge> and eventually find maximum :)
16:03:39 <lambdabot>  20
16:03:58 <rag3_> ok thanks. I need to dig in there
16:04:04 <ikaros> wow im really impressed by the haskellwiki.. there is so much information. its great
16:04:18 <sorear> Nowadays, I actually kinda think we were better off without hierarchal modules.
16:04:25 <sjanssen> dancor: perhaps you should mail Sven Panne and ask him if he got anywhere with it?
16:04:31 <narain> rag3_: use the Hoogle
16:04:32 <sorear> stuff is split up so much you can't find any of it
16:04:42 <dancor> sjanssen: ok
16:04:43 <sorear> @hoogle Ord a => [a] -> a
16:04:44 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
16:04:44 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
16:04:44 <lambdabot> Prelude.head :: [a] -> a
16:04:57 <bd_> @src minimum
16:04:57 <lambdabot> minimum [] = undefined
16:04:58 <lambdabot> minimum xs = foldl1 min xs
16:05:15 <rag3_> @src max
16:05:16 <lambdabot> max x y = if x <= y then y else x
16:05:24 <rag3_> I see
16:05:38 <narain> > foldl1 min []
16:05:39 <lambdabot>  Exception: Prelude.foldl1: empty list
16:05:54 <narain> why the extra clause in the definition of minimum?
16:06:08 <sorear> no reason
16:06:11 <sorear> ask dons
16:06:11 <augustss> narain: for a better error message
16:06:16 <narain> oh, to prefer undefined over exceptions?
16:06:30 <narain> i guess that works
16:06:42 <augustss> narain: I don't think the real source contains undefined
16:06:47 <augustss> > minimum []
16:06:48 <lambdabot>  Exception: Prelude.minimum: empty list
16:07:37 <narain> i think  minimum []  should equal +infinity
16:07:38 <Saizan> undefined doesn't give a beter error message than "empty list" imho
16:07:39 <rag3_> augustss: I checked and the real source raises an exception
16:07:52 <augustss> rag3_: well, it calls error
16:08:01 <kpreid> narain: not all Nums have such a value
16:08:03 <bd_> narain: or minBound
16:08:12 <dancor> sjanssen: what do you think about his complaints about haskell networking?  "no getaddrinfo & friends, slightly obscure combination of features,
16:08:14 <narain> i know, its just wishful thinking :)
16:08:15 <dancor> one has to be careful about the byte order etc. etc"
16:08:18 <chessguy> ?instances Bounded
16:08:20 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
16:08:22 <bd_> > let minimum = foldl min minBound in minimum [] :: Int
16:08:22 <rag3_> augustss: is the expression "raise an exception" wrong in Haskell talk?
16:08:23 <lambdabot>  -2147483648
16:08:33 <sjanssen> dancor: I'm not educated on the issues
16:08:35 <fantasma> similar to head, is there a function that returns the last item in the list?
16:08:43 <emk> A Haskell testimonial: Haskell makes me smarter. With Haskell, I can solve problems that previously overwhelmed my poor brain...
16:08:44 <chessguy> ?hoogle last
16:08:45 <lambdabot> Prelude.last :: [a] -> a
16:08:45 <lambdabot> System.Win32.Registry.lastWrite_hi :: RegInfoKey -> Word32
16:08:45 <lambdabot> System.Win32.Registry.lastWrite_lo :: RegInfoKey -> Word32
16:08:47 <augustss> rag3_: well, H98 does not have exceptions.  ghc does
16:08:51 <chessguy> fantasma, ^^
16:08:57 <narain> > let minimum = foldl min maxBound in map minimum [[], [1,2,3]] :: Int
16:08:58 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
16:08:59 <fantasma> chessguy, thanks...again
16:09:02 <rag3_> augustss: thanks
16:09:02 <chessguy> fantasma, of course it's O(n)
16:09:20 <fantasma> chessguy, what do you mean
16:09:34 <chessguy> its runtime
16:09:42 <Saizan> ?src last
16:09:43 <lambdabot> last [x]    = x
16:09:43 <lambdabot> last (_:xs) = last xs
16:09:43 <lambdabot> last []     = undefined
16:09:48 <narain> fantasma: it takes time proportional to the length of the list
16:09:59 <fantasma> ah I see
16:10:00 <chessguy> fantasma, you have to touch every element in a list to get to the last one
16:10:06 <fantasma> no better way to do it?
16:10:16 <augustss> fantasma: no, not with lists
16:10:17 <chessguy> not with a list
16:10:18 <narain> > let minimum = foldl min maxBound in map minimum [[], [1,2,3]]
16:10:19 <lambdabot>  Add a type signature
16:10:30 <narain> > let minimum = foldl min maxBound in map minimum [[], [1,2,3]] :: [Int]
16:10:31 <lambdabot>  [2147483647,1]
16:10:48 <augustss> :t foldl min maxBound
16:10:50 <lambdabot> forall a. (Ord a, Bounded a) => [a] -> a
16:10:56 <augustss> :t minimum
16:10:59 <lambdabot> forall a. (Ord a) => [a] -> a
16:11:08 <Saizan> if you really need fast both ends lookup you can use Data.Sequence
16:11:10 <elaforge> fantasma: Data.Sequence has fast tail access, I believe
16:11:10 * sorear just used a -- comment in x86 assembly :)
16:11:32 <SamB> is that allowed?
16:11:54 <augustss> usually not :)
16:11:56 <sorear> no, nasm and gas both use ;
16:12:08 <sorear> forth assemblers use ( and \
16:12:23 <Zeroth404> I'm reading YAHT, and the first excervize asks you to do something that it hasn't quite explained, it seems. the excervize says "Use map to convert a string into a list of booleans, each element in the new list representing whether or not the original element was a lower-case character. That is, it should take the string ?aBCde? and return [True,False,False,True,True]."
16:13:09 <sorear> I always worry when apt says an upgrade will FREE disk space.  makes me think I'm losing yet another manual to non-free.
16:13:25 <chessguy> Zeroth404, a String is really a [Char]
16:13:26 <Zeroth404> sorear: you'll eventually move to gentoo anyhow ;-)
16:13:46 <yip> sorear: how can a free manual ever become non-free?
16:13:51 * augustss sometimes regrets -- as the comment started.  it's such a nice operator
16:13:59 <Zeroth404> chessguy: the only thing I know to do with map is "map toUpper "string""
16:14:05 * SamB thinks it should automatically install the manuals for things like that
16:14:22 <chessguy> Zeroth404, ok, this is similar to that
16:14:30 <chessguy> ?type map
16:14:32 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:14:32 <fantasma> Zeroth404, earlier in the chapter they briefly mention Char.isLower
16:15:29 <chessguy> Zeroth404, in map toUpper myString, map acts as if it had type (Char -> Char) -> [Char] -> [Char]
16:15:46 <fantasma> > last [1..100]
16:15:48 <lambdabot>  100
16:16:01 <Zeroth404> I don't really get how " forall a b. (a -> b) -> [a] -> [b]" works
16:16:03 <chessguy> Zeroth404, in this case, you want it to be (Char -> Bool) -> [Char] -> [Char]
16:16:25 <chessguy> Zeroth404, ok, let's start with something simpler
16:16:29 <chessguy> ?type length
16:16:32 <lambdabot> forall a. [a] -> Int
16:17:09 <chessguy> this says for any type, which we'll call a, length is a function from a list of a's, to Int
16:17:26 <augustss> > last [1..1000]
16:17:28 <lambdabot>  1000
16:17:37 <nmessenger> > isLower 'A'
16:17:38 <augustss> > last [1..100000]
16:17:39 <lambdabot>  False
16:17:39 <lambdabot>  100000
16:17:43 <chessguy> that is, it works the same way whether we're talking about a list of Int's, a list of Integers, a list of Char's, a list of lists of Char's or whatever
16:17:49 <fantasma> > last [1..]
16:17:53 <lambdabot> Terminated
16:18:04 <nmessenger> > [isLower 'A', isLower 'a']
16:18:05 <lambdabot>  [False,True]
16:18:30 <fantasma> > pi == 3
16:18:31 <lambdabot>  False
16:18:43 <chessguy> Zeroth404, the point is, it doesn't really matter what this is a list OF, the only important thing is that it's a list
16:18:44 <rag3_> > pi == 3 in Louisiana
16:18:44 <lambdabot>  Parse error
16:18:51 <augustss> > round pi == 3
16:18:51 <rag3_> :)
16:18:53 <lambdabot>  True
16:18:55 <chessguy> Zeroth404, make any sense?
16:19:01 <fantasma> > let pi == 3 in Louisiana
16:19:02 <lambdabot>  Parse error
16:19:04 <Zeroth404> chessguy: my brain is workin, but perhaps
16:19:15 * sorear has coerced haddock-ghc to compile
16:19:23 <sorear> @users
16:19:24 <lambdabot> Maximum users seen in #haskell: 336, currently: 324 (96.4%), active: 49 (15.1%)
16:19:40 <chessguy> Zeroth404, suppose you wanted to figure out the length of a list of Integer
16:19:52 <ndm> anyone have any information on how to compile haddock docs with a limited command line length?
16:19:56 <nmessenger> map :: (a -> b) -> ([a] -> [b]) -- when given a function 'f' that turns a's into b's, 'map f' turns lists of a's into lists of b's
16:20:01 <tarantoga> dcoutts: how can I enable sorting for a column?  for treeViewColumnSetSortColumnId I would need a column id, which I don't have
16:20:02 <ndm> i.e. feeding haddock increasingly more numbers of files
16:20:07 <Zeroth404> forall a. [a] -> Int  literally means ... for each element in the list 'a', convert them to int?
16:20:08 <ndm> or some @filelist command for haddock
16:20:13 <sorear> ndm: get a real OS? :p
16:20:18 <sorear> ndm: no
16:20:22 <nmessenger> isLower turns a Char into a Bool, can you figure out how to turn a [Char] into a [Bool]?
16:20:23 <Zeroth404> that must be wrong :-/
16:20:25 <ndm> sorear: its actually a case of a real Haskell interp :)
16:20:39 <ndm> sorear: works in GHCi, but not WinHugs
16:20:59 <Philippa> Zeroth404: it doesn't. The forall is "for all types a..."
16:21:09 <chessguy> Zeroth404, no. it means that the type of 'length' is a function from any list to an integer
16:21:09 <fantasma> > last [1..1000000000000000000]
16:21:11 <lambdabot> Terminated
16:21:29 * sorear invokes his trademark high speed doc reading skill
16:21:32 <mgsloan> > last [1..1000000]
16:21:33 <lambdabot>  1000000
16:21:42 <Zeroth404> chessguy: so it only defines its input and output types?
16:21:51 <fantasma> > last [1..76576500]
16:21:51 <chessguy> Zeroth404, yes
16:21:52 <augustss> > [last [1..10^n] | n <- [1..]]
16:21:58 <lambdabot> Terminated
16:21:59 <lambdabot> Terminated
16:21:59 <Zeroth404> forall a. [a] -> Int  takes a, and returns a list of a as type int?
16:22:08 <nmessenger> Zeroth404: precisely
16:22:10 <fantasma> @karma- lambdabot
16:22:10 <lambdabot> lambdabot's karma lowered to 41.
16:22:21 <chessguy> nmessenger, ?
16:22:23 <chessguy> that's wrong
16:22:34 <Zeroth404> chessguy: that in itself isn't enough to define the function to get the length of a string, is it?
16:22:56 <chessguy> Zeroth404, let's take the type signature one piece at a time
16:23:04 <nmessenger> Zeroth404: nope it's just the type.
16:23:07 <chessguy> forall a. [a] -> Int
16:23:13 * Zeroth404 understands so far
16:23:15 <chessguy> the first piece is forall a.
16:23:33 <rag3_> I've come to the bitter conclusion that Haskell seems hard to me because it forces me to think about the problem in the right terms. It forces me to formulate a correct answer, rather than find a solution that is a workaround and a shortcut . I've solved a few problems in Haskell and Ruby and my Ruby solutions looks like just that... workarounds. I spent 10  times more on coming up with Haskell solutions, but if I l
16:23:33 <rag3_> ook at both of them now, I feel like only Haskell imposed on me to come up with the right answer.
16:23:49 <chessguy> that means that it's going to make a statement which is true for any type, and it's going to call that type a.
16:23:49 <Zeroth404> does [a] mean "a single element of a", or "a list of a" ?
16:23:58 <Philippa> a list of a
16:24:01 <sorear> both
16:24:03 <nmessenger> chessguy: the precisely was at "so it only defines its input and output types?".  I seem to be horribly laggy.
16:24:05 <emu> rag3_: a common sentiment i think
16:24:08 <fantasma> maybe x is a better variable to use
16:24:24 <Philippa> Zeroth404: there's no "a single element of a", because a is a type rather than a list
16:24:24 <sorear> Zeroth404: [a] as a value means a list with one element, taken from the variable a
16:24:31 <Zeroth404> ah
16:24:45 <sorear> Zeroth404: [a] as a type means a list of elements, each of type a
16:24:55 <nmessenger> [x] as an expression is "a 1-element list containing x", [a] as a type is "lists of type a"
16:25:15 <Zeroth404> a is ambiguous as a type, or does 'a' somehow mean 'string' ?
16:25:20 <Zeroth404> or char
16:25:26 <sorear> ndm: I think I've found a workaround ... lemme test it
16:25:31 <mbishop> a is polymorphic...sort of a place holder
16:25:34 <Philippa> a isn't /ambiguous/, but it's a variable - it could become either
16:25:38 <nmessenger> forall a. a means "any type at all"
16:25:51 <Zeroth404> I don't recall yaht goign over this (im on page 20)
16:26:04 <nmessenger> > (length :: [Char] -> Int) "foo"
16:26:06 <lambdabot>  3
16:26:15 <nmessenger> > (length :: [Int] -> Int) [1..5]
16:26:16 <lambdabot>  5
16:26:19 <rag3_> emu: I feel like I need to learn how to program. After 10 years that I do this for one of the biggest companies in the world.
16:27:00 <nmessenger> > (length :: [Bool] -> Int) [False, True, True]
16:27:02 <lambdabot>  3
16:27:09 <Zeroth404> > (length || [Char -> Bool) "1"
16:27:10 <lambdabot>  Parse error
16:27:12 <Zeroth404> heh
16:27:34 <Zeroth404> > (length || [Int -> Char) [1..6]
16:27:34 <lambdabot>  Parse error
16:27:40 <Zeroth404> > (length || [Int -> Int) [1..6]
16:27:41 <lambdabot>  Parse error
16:27:49 <Zeroth404> woops
16:27:51 <psnl> f/win 31
16:27:53 <Zeroth404> > (length :: [Int -> Int) [1..6]
16:27:53 <lambdabot>  Parse error
16:28:07 <Zeroth404> > (length :: [Int] -> Int) [1..6]
16:28:08 <lambdabot>  6
16:28:12 <Cale> there you go :)
16:28:13 <chessguy> Zeroth404, Int and Char and Bool are types. you can't use them in expressions like that
16:28:13 <Zeroth404> > (length :: [Int] -> Char) [1..6]
16:28:14 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
16:28:15 <resiak> Zeroth404: are you a Dvorak user?
16:28:17 <Cale> I was about to type that. :)
16:28:36 <augustss> rag3_: one always needs to learn new things :)
16:28:38 <Cale> > (length :: [a] -> Int) [1..6]
16:28:40 <lambdabot>  6
16:28:49 <Zeroth404> > (length :: [Char] -> Int) ["a".."b"]
16:28:50 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
16:28:50 <chessguy> well, ok, you can do it like that. but not with ||
16:28:59 <Cale> > (length :: [Char] -> Int) "Hello"
16:29:01 <lambdabot>  5
16:29:07 <Cale> > (length :: [Char] -> Int) ['a'..'z']
16:29:08 <lambdabot>  26
16:29:11 <nmessenger> "the length function with type 'list of Ints to Int', applied to the list [1..6]"
16:29:19 <Zeroth404> > (length :: [Char] -> Int) ['a'..'b']
16:29:20 <lambdabot>  2
16:29:25 <fantasma> ['a'..4]
16:29:29 <Zeroth404> does the 'c' "string" thing as in C?
16:29:32 <fantasma> > ['a'..4]
16:29:33 <lambdabot>   add an instance declaration for (Num Char)
16:29:33 <lambdabot>     In the expression: 4
16:29:33 <lambdabot>     In ...
16:29:34 <elaforge> resiak: why is missing ] characterstic of dvorak?
16:29:46 <Cale> Zeroth404: Yeah, 'c' is a char, "s" is a string.
16:30:01 <augustss> :t 'c'
16:30:02 <fantasma> > ['a'.."z"]
16:30:03 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
16:30:04 <lambdabot> Char
16:30:12 <Zeroth404> > (length :: [Char] -> Int) ['a'..92]
16:30:13 <lambdabot>   add an instance declaration for (Num Char)
16:30:13 <lambdabot>     In the expression: 92
16:30:17 <fantasma> > ["a".."z"]
16:30:18 <lambdabot>   add an instance declaration for (Enum [Char])
16:30:18 <lambdabot>     In the expression: ["a" ....
16:30:33 <Cale> > ['a','c'..'z']
16:30:35 <lambdabot>  "acegikmoqsuwy"
16:30:35 <fantasma> > System.echo "Hello"
16:30:36 <lambdabot>   Not in scope: `System.echo'
16:30:46 <Zeroth404> >['a'..'z']
16:30:49 <Zeroth404> > ['a'..'z']
16:30:51 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
16:30:54 <Zeroth404> > ['a'..............'z']
16:30:55 <lambdabot>   Not in scope: `..............'
16:31:01 <Zeroth404> > ['a'...'z']
16:31:02 <lambdabot>   Not in scope: `...'
16:31:09 <chessguy> you can only use 2 dots like that
16:31:12 <fantasma> .. is a function
16:31:15 <Zeroth404> so I learnt :-)
16:31:20 <Zeroth404> ah
16:31:22 <Cale> > let x ... y = [x,y] in ['a'...'z']
16:31:23 <lambdabot>  ["az"]
16:31:26 <chessguy> ?sorc (..)
16:31:26 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:31:28 <augustss> fantasma: .. is special syntax
16:31:35 <Zeroth404> > ["aa".."ac"]
16:31:37 <lambdabot>   add an instance declaration for (Enum [Char])
16:31:37 <lambdabot>     In the expression: ["aa" ...
16:31:48 <Zeroth404> ?
16:31:48 <fantasma> augustss, isn't it sugarized?
16:32:01 <Cale> Zeroth404: The .. syntax only works with instances of the class Enum
16:32:09 <Cale> There's no instance for strings, so it doesn't work.
16:32:11 <augustss> fantasma: [e1 .. e2] is special syntax for enumFromTo
16:32:17 <Cale> If you wrote one, it would.
16:32:18 <astrolabe> > [(a,a)..(a,c)]
16:32:19 <lambdabot>   Not in scope: `c'
16:32:29 <Zeroth404> > ['a','b'..'a','c']
16:32:29 <lambdabot>  Parse error
16:32:31 <astrolabe> > [('a','a')..('a','c')]
16:32:31 <fantasma> augustss, yah I know, and enumFromTo is a function
16:32:31 <lambdabot>   add an instance declaration for (Enum (Char, Char))
16:32:32 <lambdabot>     In the expression: ...
16:32:41 <mgsloan> :/
16:32:42 <Zeroth404> tying to do a permutation of a string
16:32:49 <astrolabe> why doesn't it deduce the instance?
16:32:58 <resiak> elaforge: : and | are adjacent on my dvorak-gb keyboard.
16:33:09 * nmessenger makes a side comment: "(..) should be an ordinary function equalling enumFromTo!"
16:33:24 <elaforge> resiak: huh, wacky.  I have : in the lower-left and | in the upper right
16:33:27 <astrolabe> nmessenger: what about [1..]?
16:33:28 <Zeroth404> > ['a',['b'..'a'],'c']
16:33:29 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
16:33:37 <augustss> fantasma: yes, enumFromTo is a function.  So you could say that [ .. ] is a function, kinda
16:33:38 <Zeroth404> > ['a',] ['b'..'a'] ['c']
16:33:38 <lambdabot>  Parse error
16:33:39 <mgsloan> nmessenger: good idea... wouldn't even need the brackets then
16:33:47 <chessguy> nmessenger, yeah but then you'd have to write [1 .. n]
16:33:58 <mgsloan> would be cool to have a haskell with all such things cleaned up
16:33:59 <elaforge> resiak: crazy brits even have non-standard dvorak :)
16:34:00 <chessguy> ?src enumFromTo
16:34:01 <lambdabot> Source not found. I feel much better now.
16:34:05 <fantasma> > let x .... y = enumFromTo x y in ['a'....'b']
16:34:07 <lambdabot>  ["ab"]
16:34:12 <nmessenger> astrolabe: I didn't exactly give it much consideration
16:34:22 <astrolabe> nmessenger: :)
16:34:25 <fantasma> why didnt that work
16:34:29 <Zeroth404> unless I missed something, the book doesn't prepare you enough for the first excercizes
16:34:31 <resiak> elaforge: I think your \| key is where my #~ key is -- beside enter.
16:34:40 <fantasma> > let x .... y = enumFromTo x y in ['a'....'z']
16:34:41 <lambdabot>  ["abcdefghijklmnopqrstuvwxyz"]
16:34:49 <augustss> fantasma: it did work
16:34:49 <fantasma> :)
16:35:00 <sorear> ndm: still there?
16:35:02 <fantasma> augustss, haha yah, b != z
16:35:12 <sorear> ndm: I have a working work-around
16:35:15 <elaforge> resiak: right, I have | in the qwerty position, which is above return (on a mac)
16:35:17 <augustss> > let x .... y = enumFromTo x y in 'a'....'z'
16:35:18 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
16:35:21 <Zeroth404> ?type map
16:35:22 <ndm> sorear: please do tell :)
16:35:23 <elaforge> resiak: ... come to think of it that might be non-standard too :)
16:35:23 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:35:46 <fantasma> how long does a paste stay in hpaste?
16:35:48 <Zeroth404> so map takes a and b, .... and......
16:35:59 <sorear> fantasma: until I or glguy delete it.
16:36:05 <Zeroth404> whats the period for? forall a b.
16:36:17 <fantasma> sorear, i see
16:36:22 <nmessenger> "given a function that turns a's into b's, and a list of a's, map gives a list of b's"
16:36:27 <Cale> Zeroth404: just to separate the list of bound variables from the type
16:36:30 <Igloo> Zeroth404: It tells you where the variable list stops
16:37:18 <Zeroth404> why isnt it    forall a b. (a -> b) -> [b]   ?
16:37:23 <fantasma> sorear, if you want you can delete mine
16:37:27 <nmessenger> > let (...) = enumFromTo in 'a'...'z'
16:37:29 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
16:37:31 <Cale> Zeroth404: it needs a list :)
16:37:49 <Cale> Zeroth404: How else is it going to produce that list of b's?
16:37:54 <sorear> fantasma: which one?
16:38:11 <fantasma> sorear, all of mine :) doesnt matter which
16:38:16 <Zeroth404> (a -> b)  is the "function prototype" so to say?
16:38:17 <Cale> Note that (a -> b) -> [a] -> [b] is the same as (a -> b) -> ([a] -> [b]), because -> is right associative.
16:38:27 <sorear> fantasma: we delete spam and blank pastes, problems should be kept because the help people who are reading the logs
16:38:39 <Cale> That is, it takes a function from a's to b's, and produces a function from lists of a's to lists of b's.
16:38:49 <fantasma> sorear, ah alright, wasn't sure on the policy .. thanks :)
16:38:50 <sorear> fantasma: besides, gzipped text doesn't take much space :)
16:39:14 <resiak> elaforge: See, in .uk we have £ where you have #, so we need an extra key to have # on it, so we move \| to beside left shift. dvorak-gb preserves that
16:39:14 <fantasma> is hpaste written in haskell?
16:39:25 <Cale> However, you can also just read that as that it takes a function from a's to b's and a list of a's, and gives a list of b's.
16:39:35 <Cale> That's the same thing in Haskell.
16:39:47 <elaforge> resiak: oh, *that* why they call # "pound" sometimes.  learn something every day
16:39:57 <sorear> fantasma: if you click on the 'Source' link at the bottom you go to a bunch of .hs files :)
16:40:05 <resiak> elaforge: (of course, on a Mac weird stuff happens whereby # and £ are both on 3, as alt-3 and shift-3, but which way around depends on whether you're in .uk or not)
16:40:12 <nmessenger> > let addOne x = x + 1 in map addOne [1,2,3]
16:40:13 <lambdabot>  [2,3,4]
16:40:15 <Cale> Zeroth404: does that make sense
16:40:16 <Cale> ?
16:40:22 <Zeroth404> yes
16:40:24 <Zeroth404> actually
16:40:28 <fantasma> sorear, is something like HApps faster or more scalable than php?
16:40:32 <resiak> elaforge: thing is, i've never seen # used in the weight sense or in the currency sense, so..
16:40:50 * sorear looks at fantasma gravely
16:41:06 <Cale> > let addOnes = map (+1) in addOnes [1,2,3]
16:41:07 <lambdabot>  [2,3,4]
16:41:12 <Zeroth404> (a -> b) [a] -> [b]  function converts a to b, and converts a list of a to a list of b to return... ?
16:41:20 <elaforge> resiak: me either, but it does get called "pound"... actually mostly on phone menus now that I think about it
16:41:32 <fantasma> sorear, why :!
16:41:37 <sorear> fantasma: it's cooler :)  seriously, php can't be compiled iirc
16:41:42 <Cale> Zeroth404: map takes a function from a's to b's as a parameter
16:41:46 <Cale> and a list of a's
16:41:52 <Cale> and gives back a list of b's
16:41:53 <Zeroth404> ah
16:41:57 <sorear> fantasma: "thou durst mention PHP?!"
16:42:04 <Cale> > map (+1) [1,2,3]
16:42:04 <lambdabot>  [2,3,4]
16:42:11 <Cale> :t (+1)
16:42:14 <lambdabot> forall a. (Num a) => a -> a
16:42:17 <sorear> @quote php
16:42:17 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
16:42:17 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
16:42:19 <Cale> :t [1,2,3]
16:42:21 <lambdabot> forall t. (Num t) => [t]
16:42:28 <sorear> @quote php
16:42:28 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
16:42:28 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
16:42:44 <Zeroth404> so is like:  forall (what the function takes) (what the function does) (what the function returns)   ?
16:42:46 <fantasma> lol!
16:43:16 * sorear was hoping for something similar in tone to:
16:43:21 <sorear> @quote xslt
16:43:21 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
16:43:29 <Cale> Zeroth404: forall [type variables]. [what the function takes] -> [what the function returns]
16:43:45 <fantasma> that was yesterday :)
16:43:51 <Cale> Zeroth404: You can pretty much ignore the "forall a b." for now
16:43:58 <Zeroth404> Cale: doesnt the second part make the first a bit redundant?
16:44:01 <Cale> Zeroth404: It's implied if you leave it out anyway
16:44:07 <augustss> @quote
16:44:07 <lambdabot> newbcoder says: newbcoder is the best of them all
16:44:08 <sorear> @localtime fantasma
16:44:09 <lambdabot> Local time for fantasma is Sat Mar 03 18:41:04
16:44:19 <fantasma> eep
16:44:31 <Cale> The "forall a b." is a bit redundant, but not if it occurred elsewhere in the type.
16:44:33 <augustss> @quote
16:44:33 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
16:44:37 <Cale> For example...
16:44:52 <fantasma> LOL
16:45:30 <Zeroth404> how is  (a -> b) whathte function takes?  doesn't the -> imply a conversion from a to b? if so, then is that not what the function does and not what it takes?
16:45:31 <augustss> > let (^-^) = 5 in (^-^) + 1
16:45:32 <lambdabot>  6
16:45:44 <Cale> Zeroth404: It takes a function as a parameter
16:45:48 <resiak> elaforge: silly USians.  :-)
16:45:59 <Cale> That function which it takes as a parameter sends a's to b's.
16:46:03 <hpaste>  sorear pasted "haddocking a program with O(sqrt (number of files)) cmdline args" at http://hpaste.org/780
16:46:09 <sorear> ndm: poke
16:46:17 <ndm> sorear: prod
16:46:22 <Cale> For example, suppose a is Char and b is Int
16:46:22 <Zeroth404> Cale: but thats what the function does in the first place...heh
16:46:26 <Cale> like ord
16:46:30 <Cale> :t ord
16:46:32 <lambdabot> Char -> Int
16:46:40 <fantasma> > let (+) = (-) in 1 + 2
16:46:41 <Cale> Then we can pass ord to map
16:46:41 <lambdabot>  -1
16:46:44 <Cale> :t map ord
16:46:47 <lambdabot> [Char] -> [Int]
16:46:57 <Cale> and get a function from strings to lists of integers
16:47:04 <Cale> > map ord "Hello"
16:47:05 <lambdabot>  [72,101,108,108,111]
16:47:14 <Cale> ord 'H'
16:47:15 <Cale> > ord 'H'
16:47:16 <lambdabot>  72
16:47:21 <fantasma> is that ascii values?
16:47:24 <Cale> yeah
16:47:26 <Zeroth404> what are those numbers? unicode or something?
16:47:29 <fantasma> neat
16:47:34 <Cale> unicode or ascii.
16:47:39 <Zeroth404> doesnt look like ascii
16:47:43 <Cale> They're equivalent in this range.
16:47:46 <elaforge> augustss: how to freak out non-haskell programmers: "let 1+1 = 3 in 1+1"
16:47:49 <fantasma> ord 1
16:47:52 <fantasma> > ord 1
16:47:53 <lambdabot>   add an instance declaration for (Num Char)
16:47:54 <Cale> > ord '1'
16:47:54 <Zeroth404> I have been wrong before :-)
16:47:55 <lambdabot>  49
16:48:01 <Cale> > ord 'a'
16:48:03 <lambdabot>  97
16:48:06 <Cale> > ord 'A'
16:48:07 <lambdabot>  65
16:48:11 <Zeroth404> yeah
16:48:15 <augustss> elaforge: yes, it's strange :)
16:48:25 <Cale> map :: (a -> b) -> ([a] -> [b])
16:48:32 <fantasma> > foldl ord ['1'..'50']
16:48:32 <lambdabot>  Improperly terminated character constant
16:48:34 <Cale> We used a = Char, b = Int
16:48:47 <Cale> and gave it a function from Chars to Ints
16:48:57 <fantasma> > foldl ord ['a'..'z']
16:48:58 <lambdabot>  Couldn't match expected type `b -> Char'
16:48:58 <augustss> > let 1 + ((+)+1) = 5 in 1 + 2
16:48:58 <lambdabot>  Parse error in pattern
16:49:01 <Cale> and got back a function from [Char] to [Int]
16:49:08 <Cale> :t map ord
16:49:10 <lambdabot> [Char] -> [Int]
16:49:14 <ndm> sorear: i have to go now, but will be back in about half an hour
16:49:19 <Cale> Following? :)
16:49:20 <augustss> bad lambdabot!  bad parser!
16:49:28 <Zeroth404> how does ord mean char to int, exactly?
16:49:30 <ndm> sorear: hpaste the instructions and @tell them to me
16:49:33 <yip> can ghc cross compile?
16:49:38 <Cale> It takes a Char, and produces an Int
16:49:41 <ndm> sorear: or hpaste and wait half an hour (or a bit more,  maybe)
16:49:41 <sorear> ndm: already hpasted
16:49:43 <Igloo> yip: no
16:49:46 <Cale> > ord 'a'
16:49:47 <lambdabot>  97
16:49:51 <fantasma> > map ord ['a'..'z']
16:49:51 <Cale> :t ord 'a'
16:49:53 <yip> Igloo: :'(
16:49:53 <lambdabot>  [97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,11...
16:49:53 <lambdabot> Int
16:49:57 <Cale> :t ord 'a'
16:49:57 <Zeroth404> ?types ord
16:50:00 <lambdabot> Int
16:50:01 <lambdabot> Char -> Int
16:50:01 <sorear> @tell ndm <hpaste>  sorear pasted "haddocking a program with O(sqrt (number of files)) cmdline args" at http://hpaste.org/780 [16:43]
16:50:01 <lambdabot> Consider it noted.
16:50:11 <Cale> ord :: Char -> Int
16:50:18 <Cale> chr :: Int -> Char
16:50:24 <Cale> > chr 97
16:50:25 <lambdabot>  'a'
16:50:38 <Zeroth404> whats the logiv for the name "ord" ? I understand "chr" ...
16:50:44 <bd_> ordinal
16:50:45 <elaforge> Zeroth404: its just the conventional names, ord is "ordinal" I think
16:50:47 <augustss> just like BASIC
16:50:49 <yip> Igloo: any reason in particular why not?
16:51:12 <mgsloan> asc is a much better name imho
16:51:13 <Cale> Yeah, it's historical.
16:51:14 <bd_> @check \c -> ord c == fromEnum c
16:51:16 <lambdabot>  OK, passed 500 tests.
16:51:20 <bd_> @check \c -> chr c == toEnum c
16:51:21 <Cale> mgsloan: I'd agree with that.
16:51:21 <lambdabot>  Exception: Prelude.chr: bad argument
16:51:22 <mgsloan> and asc is historical too :)
16:51:28 <nmessenger> "ordinal value"?
16:51:28 <bd_> hm
16:51:31 <augustss> fromEnum/toEnum are the more general ones
16:51:34 <bd_> @check \c -> c >= 0 ==> chr c == toEnum c
16:51:36 <lambdabot>  OK, passed 500 tests.
16:51:41 <Cale> > fromEnum 'a'
16:51:42 <lambdabot>  97
16:51:45 <Igloo> yip: Because no-one's submitted a patch for it yet
16:51:47 <nmessenger> mgsloan: but Char is unicode!
16:51:48 <Cale> > toEnum 97 :: Char
16:51:50 <lambdabot>  'a'
16:52:07 <ndm> sorear: cheers, will try that with the new Yhc doc builder once i get back
16:52:07 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
16:52:17 <yip> Igloo: ok thanks
16:52:27 <ndm> @messages
16:52:27 <lambdabot> sorear said 2m 26s ago: <hpaste> sorear pasted "haddocking a program with O(sqrt (number of files)) cmdline args" at http://hpaste.org/780 [16:43]
16:52:30 <Zeroth404> I'm still not sure how I would use map to do the excercize
16:52:30 <sorear> ndm: it doesn't make exactly the same results :(
16:52:31 <mgsloan> nmessenger: true, but unicode is like an extension on ascii anyway
16:52:36 <fantasma> is there a section in the YAHT that covers input from a file to, say, a list?
16:52:41 <Cale> Zeroth404: oh, what's the exercise?
16:53:03 <Igloo> yip: I don't think it should be harder than C for just compiling Haskell programs
16:53:17 <Zeroth404> Exercise 3.3 Use map to convert a string into a list of booleans, each element in the new list representing whether or not the original element was a lower-case character That is, it should take the string ?aBCde? and return [True,False,False,True,True].
16:53:24 <Cale> ah
16:53:27 <sorear> @help clear-message
16:53:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:53:29 <sorear> @help clear-messages
16:53:30 <lambdabot> clear-messages. Clears your messages.
16:53:32 <Cale> Do you know about toUpper and toLower?
16:53:33 <sorear> @tell ndm @clear-messages
16:53:34 <lambdabot> Consider it noted.
16:53:35 <Cale> er
16:53:39 <Cale> isUpper and isLower
16:53:40 <Zeroth404> yes
16:53:43 <QtPlatypus> Do list elements have to all have the same type?
16:53:43 <Zeroth404> and yes
16:53:43 <Igloo> yip: Things like hsc2hs would be more of a headache...possibly (essentially) impossible in general
16:53:44 <Cale> > isUpper 'a'
16:53:45 <lambdabot>  False
16:53:46 <Cale> > isUpper 'A'
16:53:47 <lambdabot>  True
16:53:54 <Cale> A string is a list of Chars
16:53:56 <fantasma> > isUpper '1'
16:53:57 <lambdabot>  False
16:53:58 <stmartin> Can I use Unicode character constants in my Haskell source code?
16:54:02 <sorear> yes!
16:54:13 <sorear> '<character>'
16:54:21 <fantasma> haskell is fantastic!
16:54:24 <narain> Zeroth404: do you understand the type of  map  yet?
16:54:25 <sorear> ghc expects your source to be in utf-8
16:54:30 <Cale> Zeroth404: So you want to apply isLower to each of the elements of the list, right?
16:54:33 <Zeroth404> narain: yes, I believe so.
16:54:33 <qwr> Zeroth404: String is [Char]
16:54:35 <stmartin> OIC. Thanks!
16:54:43 <Cale> and that's what map does.
16:54:43 <narain> :t "abcde"
16:54:46 <lambdabot> [Char]
16:54:52 <Cale> It applies a function to every element of a list.
16:54:55 <fantasma> is it possible to take a bunch of numbers (which I have in a text file) and input them to a list?
16:54:58 <yip> Igloo: hm... does ghc claim to be any specific c compiler when it includes a c header?
16:55:05 <Zeroth404> Cale: lemme flesh something out...
16:55:10 <mgsloan> > chr 431
16:55:11 <lambdabot>  '\431'
16:55:13 <stmartin> Hmmm, so a Char is not 8-bit ASCII?
16:55:21 <mgsloan> guess not
16:55:24 <Cale> fantasma: xs <- fmap (map read . words) getContents
16:55:32 <sorear> stmartin: no!
16:55:37 <fantasma> Cale, you're the best
16:55:38 <Japsu> euro.hs:3:8: lexical error in string/character literal
16:55:39 <sorear> stmartin: char is full unicode
16:55:43 <fantasma> @karma+ Cale
16:55:43 <lambdabot> Cale's karma raised to 43.
16:55:44 <Japsu> euro.hs: UTF-8 Unicode text
16:55:51 <Igloo> yip: It calls gcc -E to do the CPPing IIRC...ghc -v should show you
16:55:53 <narain> Cale: is there a monadic combinator like foldM you can use for that?
16:55:56 <Japsu> What I'm trying to do is
16:55:56 <fantasma> @karma+ sorear
16:55:57 <lambdabot> sorear's karma raised to 23.
16:55:57 <allbery_b> > maxBound :: Char
16:55:58 <lambdabot>  '\1114111'
16:56:01 <sorear> > [minBound,maxBound] :: Char -- stmartin:
16:56:02 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
16:56:02 <Japsu> module Euro where
16:56:02 <Japsu> euro = '€'
16:56:05 <yip> Igloo: ok
16:56:08 <sorear> > [minBound,maxBound] :: [Char] -- stmartin:
16:56:09 <Japsu> that's euro.hs
16:56:09 <lambdabot>  "\NUL\1114111"
16:56:14 <Japsu> and ghci just won't load it
16:56:14 <Zeroth404>  > map isLower "BaaBssSSs"
16:56:17 <Cale> narain: Better to do all the real processing in pure functions.
16:56:20 <sorear> Japsu: ghci -V
16:56:25 <Zeroth404> > map isLower "BaaBssSSs"
16:56:26 <lambdabot>  [False,True,True,False,True,True,False,False,True]
16:56:28 <Zeroth404> erm
16:56:30 <Zeroth404> ah
16:56:35 <Japsu> The Glorious Glasgow Haskell Compilation System, version 6.4.2
16:56:37 <sorear> Japsu: you need GHC 6.6 for unicode in source
16:56:39 <Japsu> too old?
16:56:40 <Japsu> ah
16:56:41 <Zeroth404> that was easier than I expected
16:56:41 <Japsu> righ
16:56:43 <Japsu> :(
16:56:51 <narain> Zeroth404: there we go!
16:56:54 <sorear> Japsu: (toEnum 222) should sitll work however
16:56:55 <Japsu> ghc 6.6 is not in portage :<
16:57:07 <Cale> Japsu: there's a haskell overlay
16:57:08 <sorear> portage--
16:57:10 <mbishop> it isn't?
16:57:12 <mbishop> it's in apt
16:57:16 <mbishop> unstable, at least
16:57:23 <allbery_b> > let π = pi in π/4
16:57:23 <lambdabot>  Illegal character ''\128''
16:57:24 <Japsu> Cale: right, I'll look to it
16:57:24 <Cale> dcoutts maintains it
16:57:26 <allbery_b> bah
16:57:30 <sorear> yea, well debian >> gentoo
16:57:32 <Japsu> bah
16:57:34 <narain> Zeroth404: Haskell makes lots of things easier than expected, once you manage to get your head around them
16:57:41 <sorear> binary packages FTW
16:57:42 <mbishop> allbery_b: lambdabot uses 6.5 :P
16:57:43 <narain> *around it
16:57:48 <sorear> mbishop: no
16:57:50 <sorear> @version
16:57:50 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
16:57:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:57:51 <Cale> sorear: hear hear!
16:57:55 <Japsu> i386 binary packages on core duo FTL
16:58:01 <mbishop> sorear: indeed, I used to be a gentoo staff member
16:58:02 <kmag1> Is there a way to denote a particular type constructor as a type?
16:58:06 * mbishop spits on gentoo and runs
16:58:07 <allbery_b> yeh, LB got upgraded :)
16:58:09 <Japsu> mbishop: WHAT
16:58:17 <fantasma> DEBIAN
16:58:21 <Zeroth404> I'm still not sure how to pronounce it
16:58:25 <Zeroth404> GENTOO
16:58:36 * sorear C-x 0
16:58:44 <Cale> kmag1: no, because it would be a little too hard to statically prove much about that, and makes type inference hard.
16:59:03 <kmag1> if I have a type myType of I Integer or S String
16:59:06 <nmessenger> . /* other language: */ foreach (val in inList) { outList.append(f(val)) }  --> {- Haskell: -} outList = map f inList
16:59:08 <Zeroth404> I stress the 'ell' in haskell
16:59:23 <Japsu> hmm
16:59:26 <Zeroth404> as in "hash EL"
16:59:35 <kmag1> Cale: okay thanks.  I wasn't sure my question was clear enough... but it seems it was.
16:59:38 <Japsu> is it PHP that has foreach loops with the in keyword?
16:59:38 <Cale> I pronounce it like rascal, but with a hask
16:59:58 <allbery_b> awk: for (s in list) { ... }
17:00:03 <Cale> kmag1: I made some assumptions about what it was that you were really asking :)
17:00:07 <Japsu> java has... for(Xyzzy bar : bars)
17:00:16 <nmessenger> Japsu: that was just "generic language" :)
17:00:20 <Japsu> ok :)
17:00:33 <Cale> kmag1: You can't statically ensure that something returns a Just x, and not a Nothing, for example.
17:00:37 <yip> c# has a foreach with in
17:00:38 <Japsu> hmm, hey, I had some ugly code I wanted to implement better, let's see...
17:01:03 <Cale> (at least, not without much heavier type hackery)
17:01:14 <narain> according to NameVoyager, "Haskell" as a name for babies had a surge of popularity in 1890-1940 and has virtually disappeared since
17:01:21 <hpaste>  japsu pasted "fast fourier transform in haskell" at http://hpaste.org/781
17:01:34 <Japsu> that's the ugly code
17:01:39 <Zeroth404> I wonder if there's a "Haskell for Dummies"
17:01:39 <Zeroth404> heh
17:01:46 <sorear> @tell dons <hpaste> japsu pasted "fast fourier transform in haskell" at http://hpaste.org/781
17:01:46 <lambdabot> Consider it noted.
17:01:50 <fantasma> Cale, is there an equivalent to words that just takes on Char at a time regardless of whitespace?
17:01:50 <sorear> he wanted to see one
17:01:57 <Japsu> sorear: mine's ugly :<
17:01:59 <Japsu> and hmm
17:02:03 <Japsu> there's some evil to it
17:02:10 <sorear> Japsu: the one he has now is even uglier
17:02:17 <sorear> Japsu: 'cause it's written in ML
17:02:20 <Japsu> all elements but one have wrong sign
17:02:22 <Cale> fantasma: uh, not applying a function at all?
17:02:23 <sorear> he needs a haskell one
17:02:28 <Cale> or map (:[])
17:02:36 <Japsu> no wait
17:02:36 <Cale> > map (:[]) "Hello"
17:02:38 <lambdabot>  ["H","e","l","l","o"]
17:02:38 <Japsu> ARRGH
17:02:40 <tiglionabbit> ?src getArgs
17:02:40 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:02:41 <Japsu> disregard that
17:02:44 <Japsu> that version does not work
17:02:46 <Japsu> :<
17:02:50 <fantasma> thanks
17:03:04 <hpaste>  Japsu annotated "fast fourier transform in haskell" with "(no title)" at http://hpaste.org/781#a1
17:03:09 <Zeroth404> how do I pipe two commands together in hugs?
17:03:13 <Zeroth404> cmd | cmd ?
17:03:22 <sorear> foo bar
17:03:23 <Japsu> now let's see if I can find the one that almost works
17:03:25 <fantasma> cmd . cmd ?
17:03:27 <Cale> tiglionabbit: It gets the command line list of arguments to the program as a list of strings.
17:03:40 <tiglionabbit> okay.  Is that not writable in haskell?
17:03:57 <narain> Zeroth404: can you give an example of what you're trying to do?
17:03:58 <Cale> tiglionabbit: Well, it's an IO primitive.
17:04:03 <allbery_b>  @src is not complete
17:04:12 <Zeroth404>  > map toLower "asdDD"
17:04:15 <Cale> It's implemented in some fashion dependent on the implementation.
17:04:16 <allbery_b> getArgs does need to dig inside the runtime, but that doesn't always stop @src:
17:04:17 <tiglionabbit> is there a list of these?
17:04:21 <Zeroth404> I guess it didnt like it
17:04:23 <allbery_b> @src unsafeInterleaveIO
17:04:23 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
17:04:27 <Cale> @source System.IO
17:04:27 <lambdabot> http://darcs.haskell.org/packages/base/System/IO.hs
17:04:31 <Zeroth404>  > map toLower "asdDD"
17:04:43 <narain> Zeroth404: you have a leading space
17:04:47 <Zeroth404> > map toLower "asdDD"
17:04:47 <narain> > > map toLower "asdDD"
17:04:48 <lambdabot>  Parse error
17:04:48 <lambdabot>  "asddd"
17:04:56 <Zeroth404> > map toLower "asdDD" map toUpper
17:04:57 <narain> oops
17:04:57 <lambdabot>  Couldn't match expected type `((a -> b) -> [a] -> [b])
17:05:00 <Cale> @source System.Environment
17:05:01 <lambdabot> http://darcs.haskell.org/packages/base/System/Environment.hs
17:05:13 <Zeroth404> narain: ie, map toLower "asdDD" map toUpper
17:05:15 <fantasma> Zeroth404, for that excersise you need to use isLower because you need booleans
17:05:18 <Cale> @source System
17:05:18 <lambdabot> System not available
17:05:22 <Cale> hmm.
17:05:30 <narain> ah. what you mean is to apply (map toUpper) to the result of (map toLower "asdDD")
17:05:37 <Zeroth404> fantasma: I'm passed that one
17:05:38 <narain> (map toUpper) is a function
17:05:40 <fantasma> oh
17:05:46 <Zeroth404> trying to pipe commands now
17:05:50 <Cale> getArgs :: IO [String]
17:05:50 <Cale> getArgs =
17:05:50 <Cale>   alloca $ \ p_argc ->
17:05:50 <Cale>   alloca $ \ p_argv -> do
17:05:52 <Cale>    getProgArgv p_argc p_argv
17:05:54 <Cale>    p    <- fromIntegral `liftM` peek p_argc
17:05:56 <Cale>    argv <- peek p_argv
17:05:58 <Cale>    peekArray (p - 1) (advancePtr argv 1) >>= mapM peekCString
17:06:02 <kc5tja> clear
17:06:06 <Cale> hehe
17:06:08 <narain> you apply a function by putting its arguments after it, right?
17:06:08 <Zeroth404> I wantto pipe the output of one command to the n'th argument of another, in hugs
17:06:12 <fantasma> > map (toLower . toUpper) "abCDe"
17:06:13 <lambdabot>  "abcde"
17:06:21 <narain> map toUpper (map toLower "asdDD")
17:06:21 <kc5tja> I SAID CLEAR, DANG NABBIT!  ;)
17:06:25 <mbishop> If you live in eastern/central united states, the moon is eclipsing right now :P
17:06:27 <narain> > map toUpper (map toLower "asdDD")
17:06:29 <lambdabot>  "ASDDD"
17:06:33 <kc5tja> I hate it when I misplace the mouse sometimes.
17:06:38 <fantasma> mbishop, THANKS for the tip
17:06:41 * fantasma runs outside
17:06:47 <Zeroth404> > map toLower (map toUpper "ASDddDD123"
17:06:48 <lambdabot>  Parse error
17:06:49 <Zeroth404> > map toLower (map toUpper "ASDddDD123")
17:06:50 <lambdabot>  "asddddd123"
17:06:53 <Zeroth404> very kinky
17:07:33 <nmessenger> > (map toLower . map toUpper) "ASDddDD123"
17:07:35 <lambdabot>  "asddddd123"
17:08:04 <nmessenger> @src (.)
17:08:04 <lambdabot> (.) f g x = f (g x)
17:08:10 <Zeroth404> > length (filter isLower "asSSssSSSss")
17:08:11 <lambdabot>  6
17:08:14 <Zeroth404> yay
17:08:38 <nmessenger> > (.) (map toLower) (map toUpper) "ASDddDD123"
17:08:39 <lambdabot>  "asddddd123"
17:08:50 <Zeroth404> yikes
17:08:55 <Zeroth404> (.) ?
17:08:57 <fantasma> mbishop, it's so snowy outside I couldnt see a thing
17:09:01 <Zeroth404> ?types (.)
17:09:03 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:09:08 <nmessenger> > (+) 3 5
17:09:10 <lambdabot>  8
17:09:10 <allbery_b> > (map toLower . map toUpper) "ASDddDD123"
17:09:11 <lambdabot>  "asddddd123"
17:09:22 <qwr> Zeroth404: f . g is same as (.) f g
17:09:26 <fantasma> > map (toLower . toUpper) "abCDe"
17:09:27 <lambdabot>  "abcde"
17:09:46 <Zeroth404> qwr: now THAT is strange
17:10:03 <fantasma> prefix vs infix
17:10:16 <Saizan> > div 6 3
17:10:18 <lambdabot>  2
17:10:24 <Japsu> hmm, actually, why does this work: http://hpaste.org/781
17:10:25 <Zeroth404> > (map toLower . map toUpper . map toLower) map toUpper "sadddddDDDDD"
17:10:26 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
17:10:27 <Saizan> > 6 `div` 3
17:10:27 <lambdabot>  2
17:10:27 <nmessenger> > toLower `map` "abCDe"
17:10:27 <fantasma> > 6 `div 3
17:10:28 <Cale> qwr: Putting an infix operator in parens makes it a normal function
17:10:28 <lambdabot>  Parse error
17:10:29 <lambdabot>  "abcde"
17:10:30 <Cale> er
17:10:42 <Cale> Zeroth404 rather
17:10:52 <fantasma> can haskell do postfix?
17:10:57 <Zeroth404> infix?
17:11:05 <narain> > (+) 1 2
17:11:07 <lambdabot>  3
17:11:09 <fantasma> > 4 5 (*)
17:11:09 <lambdabot>        add an instance declaration for (Num (t -> (a -> a -> a) -> a1))
17:11:10 <lambdabot>     I...
17:11:10 <Cale> Like +, *, written between the parameters.
17:11:26 <allbery_b> H98 can't do postfix.  ghc can as an extension IIRC
17:11:33 <Cale> allbery_b: really?
17:11:37 <allbery_b> but only postfix unaty
17:11:39 <allbery_b> *unary
17:12:18 <narain> allbery_b: how does that work? as in, any special syntax like backquotes for infix?
17:12:22 <Cale> ah, as a special case of infix, perhaps
17:12:23 <fantasma> :t getContents
17:12:23 <allbery_b> that is, you could define something such that (x!) would compute the factorial of x (parens required, IIRC, as it's a hack based on section syntax)
17:12:26 <lambdabot> IO String
17:12:37 <fantasma> @src getContents
17:12:37 <hpaste>  tiglionabbit pasted "wtf indentation" at http://hpaste.org/782
17:12:37 <lambdabot> getContents = hGetContents stdin
17:12:37 <Cale> oh, you're talking about that
17:13:06 <Cale> tiglionabbit: you have to line up consecutive lines of a do-block
17:13:13 <allbery_b> tiglionabbit: yes, you need to indent to at least the first token after the do
17:13:20 <tiglionabbit> ...
17:13:23 <Cale> the first line starts at the first non-whitespace character after the do
17:13:30 <Zeroth404> > max [1,2,3]
17:13:31 <lambdabot>  <[Integer] -> [Integer]>
17:13:43 <narain> > let ! n = product [1..n]; postfix x f = f x in postfix x !
17:13:44 <tiglionabbit> so...
17:13:44 <lambdabot>  Parse error
17:13:45 <allbery_b> *but*  if you don't put a token after the do, but insead use a newline, then the next line can be any indentation beyond the enclosing scope
17:13:54 <hpaste>  japsu annotated "wtf indentation" with "(no title)" at http://hpaste.org/782#a1
17:13:55 <int-e> > maximum [1,2,3]
17:13:56 <lambdabot>  3
17:13:59 <narain> > let (!) n = product [1..n]; postfix x f = f x in postfix 6 (!)
17:14:01 <lambdabot>  720
17:14:01 <tiglionabbit> okay
17:14:01 <fantasma> > let n(!) = product [1..n] in 10!
17:14:02 <lambdabot>  Parse error
17:14:04 <narain> :)
17:14:08 <int-e> > max [1,2,3] [0..]
17:14:09 <lambdabot>  [1,2,3]
17:14:18 <tiglionabbit> okay.  So I guess I should be putting do on its own line then
17:14:23 <fantasma> > let n (!) = product [1..n] in 10!
17:14:23 <lambdabot>  Parse error
17:14:28 <hpaste>  allbery_b annotated "wtf indentation" with "or even this" at http://hpaste.org/782#a2
17:14:34 <Cale> tiglionabbit: actually, your first code is fairly idiomatic
17:14:37 <Zeroth404> not sure about this one: write a function using a fold that will return the maximum value in a list (and zero if the list is empty).
17:14:40 <fantasma> > let (!) n = product [1..n] in 10!
17:14:40 <lambdabot>  Parse error
17:14:47 <Zeroth404> says to use a fold
17:14:54 <tiglionabbit> Cale: that's because I copy-pasted it from a tutorial
17:14:55 <int-e> > let (!) n = product [1..n] in (10!)
17:14:56 <lambdabot>  3628800
17:15:08 <int-e> (only in recent ghc)
17:15:12 <nmessenger> > let (!) n = product [1..n] in (10 !)
17:15:13 <Cale> Zeroth404: Well, let's think about the two cases, and write it as a recursive function first.
17:15:14 <lambdabot>  3628800
17:15:21 <Japsu> Zeroth404: write a function that returns the greater of two values, and then use it to fold through the list
17:15:24 <Cale> Zeroth404: for the base case, it says to give 0
17:15:29 <allbery_b> fantasma: (a) check the extensions ection of the ghc manual (b) requires -fglasgow-exts, which lambdabot does not support
17:15:33 <Cale> so  myMaximum [] = 0
17:15:35 <Japsu> in fact there's "max" in prelude
17:15:37 <Zeroth404> aah
17:15:42 <tiglionabbit> there is little chance that my preferred indentation scheme will line up with the exact first character after the do.  So, if I just leave do on its own line I would be much happier
17:16:02 <fantasma> allbery_b, gotcha
17:16:03 <Zeroth404> > fold max [1,2,3]
17:16:04 <lambdabot>   Not in scope: `fold'
17:16:07 <Cale> Zeroth404: then to find the maximum of (x:xs) we'd want the max of x with the maximum of xs
17:16:08 <Zeroth404> > foldl max [1,2,3]
17:16:09 <lambdabot>  <[[Integer]] -> [Integer]>
17:16:11 <tiglionabbit> well, 50/50 actually since I use two-space tabs :P
17:16:13 <cjay> @src max :: [a] -> [a] -> [a]
17:16:13 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:16:20 <Cale> > foldl max 0 [1,2,3]
17:16:21 <lambdabot>  3
17:16:27 <Zeroth404> > foldl max 0 [1,2,3]
17:16:28 <lambdabot>  3
17:16:29 <Zeroth404> bah
17:16:32 <Zeroth404> heh
17:16:34 <Cale> or foldr
17:16:37 <Zeroth404> > foldl max 10 [1,2,3]
17:16:38 <lambdabot>  10
17:16:45 <allbery_b> huh, actually 7.3.4 says you don't need a flag
17:16:50 <fantasma> @type getContents
17:16:52 <Cale> (It happens to be the same, since max is associative)
17:16:53 <lambdabot> IO String
17:17:08 <narain> clearly at least one of the elements in the list has to be larger than your starting value :)
17:17:09 <allbery_b> but ! might be special because of the scrptness flag thing, so maybe I chose a bad example
17:17:13 <allbery_b> er, strictness
17:17:24 <Zeroth404> seems I'm thinking too far outside of the box
17:17:31 <fantasma> does getContents have any parameters (hopefully location of file)?
17:17:49 <narain> Zeroth404: it worked, didn't it?
17:17:54 <nmessenger> @type readFile
17:17:56 <Saizan> :t readFile
17:17:57 <lambdabot> FilePath -> IO String
17:17:57 <fantasma> or do I need to use readFile
17:17:59 <lambdabot> FilePath -> IO String
17:18:15 <fantasma> right
17:18:15 <narain> :t openFile
17:18:19 <lambdabot> Not in scope: `openFile'
17:18:20 <int-e> > max True undefined
17:18:21 <lambdabot>  Undefined
17:18:23 <Zeroth404> > foldl max 10 [10,10,10]
17:18:24 <lambdabot>  10
17:18:32 <Zeroth404> hows it determine which one?
17:18:38 <allbery_b> getContents operates on stdin.  you want hGetCOntents
17:18:42 <Zeroth404> which element did it return?
17:18:45 <allbery_b> @hoogle hGetContents
17:18:45 <lambdabot> IO.hGetContents :: Handle -> IO String
17:18:52 <Cale> Zeroth404: does it matter? :)
17:19:02 <nmessenger> @src max
17:19:03 <lambdabot> max x y = if x <= y then y else x
17:19:06 <Zeroth404> Cale: suppose I was interested in the index of the list
17:20:09 <Cale> Then you'd have to work that in with your comparison.
17:20:29 <stmartin> What if I want to deal with UTF-8 characters that are not 2-octet characters. (Remember, Unicode is NOT a 16-bit character code, and neither is UTF-8)
17:20:48 <stmartin> Where can I find more documentation about Haskells support for Unicode?
17:20:51 <Zeroth404> max 'a'  'b'
17:20:54 <Cale> But it appears that max picks its second argument when the two things compare equal.
17:20:55 <Zeroth404> > max 'a'  'b'
17:20:57 <stmartin> In particular UTF-8
17:20:57 <lambdabot>  'b'
17:21:23 <Zeroth404> max 1 '1'
17:21:25 <Zeroth404> > max 1 '1'
17:21:26 <lambdabot>   add an instance declaration for (Num Char)
17:21:40 <Zeroth404> > max (chr 1) '1'
17:21:41 <lambdabot>  '1'
17:21:59 <Zeroth404> thats not quite what I wanted heh
17:22:10 <dons> moin
17:22:10 <Zeroth404> > chr "as"
17:22:10 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:22:11 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
17:22:20 <sorear> hi!
17:22:29 <Zeroth404> > chr [a.s]
17:22:30 <lambdabot>   Not in scope: `s'
17:22:31 <allbery_b> > max (chr 33) '1'
17:22:32 <lambdabot>  '1'
17:22:36 <Zeroth404> > chr (foldl [a.s])
17:22:37 <lambdabot>   Not in scope: `s'
17:22:37 <allbery_b> > chr 33
17:22:39 <lambdabot>  '!'
17:22:42 <allbery_b> oops
17:22:46 <narain> > let maxIndex list = fst (maximumBy (\x y => compare (snd x) (snd y)) (zip [1..] list)) in maxIndex [3,7,5,8,1]
17:22:46 <Cale> So, foldl max 10 [10,10,10] = ((10 `max` 10) `max` 10) `max` 10, and the first paren will reduce to 10, and then it'll pick the right parameter which is the last element of the list.
17:22:46 <lambdabot>  Parse error
17:22:48 <allbery_b> > max (chr 49) '1'
17:22:49 <lambdabot>  '1'
17:22:49 <Zeroth404> > chr (foldl ['a','s','d'])
17:22:49 <lambdabot>  Couldn't match expected type `a -> b -> a'
17:22:59 <narain> > let maxIndex list = fst (maximumBy (\x y => compare (snd x) (snd y)) (zip [1..] list))) in maxIndex [3,7,5,8,1]
17:22:59 <allbery_b> not that it matters, you can't tell '1' from '1' :)
17:22:59 <lambdabot>  Parse error
17:23:10 <Cale> But if == is structural equality, then there's really no way to tell.
17:23:14 <narain> > let maxIndex list = fst (maximumBy (\x y -> compare (snd x) (snd y)) (zip [1..] list))) in maxIndex [3,7,5,8,1]
17:23:14 <lambdabot>  Parse error
17:23:17 <Zeroth404> allbery_b: I'm trying to tell 1 from '1'
17:23:29 <allbery_b> ha
17:23:30 <Botje> @pl \(x,y) -> x < y
17:23:31 <lambdabot> uncurry (<)
17:23:32 <Zeroth404> > foldl chr 0 ['a','s','d']
17:23:33 <lambdabot>  Couldn't match expected type `b -> Int'
17:23:35 <Botje> doh.
17:23:43 <allbery_b> > (typeOf 1 == typeOf '1')
17:23:45 <Zeroth404> > foldl chr '0' ['a','s','d']
17:23:45 <lambdabot>  False
17:23:46 <lambdabot>  Couldn't match expected type `b -> Int'
17:23:46 <Zeroth404> > foldl chr '0' ['a','s','d']
17:23:47 <narain> > let maxIndex list = fst (maximumBy (\x y -> compare (snd x) (snd y)) (zip [1..] list)) in maxIndex [3,7,5,8,1]
17:23:47 <lambdabot>  Couldn't match expected type `b -> Int'
17:23:48 <lambdabot>  4
17:23:49 <Cale> There are ways to construct types where things that are not structurally equal will compare as equal for <= and == though.
17:24:06 <narain> > typeOf 1
17:24:07 <lambdabot>  Integer
17:24:27 <Cale> Usually it's considered bad form to do this if it's possible to otherwise observe the differences between the structures.
17:24:54 <fantasma> what can possibly be wrong with this code: {nums <- readFile "numbers.txt"}
17:25:17 <Philippa> no do in front of the braces?
17:25:23 <fantasma> @type readFile
17:25:25 <lambdabot> FilePath -> IO String
17:25:29 <Philippa> plus it needs another line
17:25:38 <allbery_b> is readFile lazy?
17:26:00 <Cale> fantasma: do-blocks can't end with a line that has a <-
17:26:06 <Philippa> the last statement of a do block mustn't bind a variable
17:26:10 <Philippa> right
17:26:14 <Cale> (because there's no way for you to use the bound result)
17:26:37 <fantasma> k
17:26:47 <elaforge> allbery_b: yep
17:27:02 <Zeroth404> > sqrt pi
17:27:03 <lambdabot>  1.7724538509055159
17:27:13 <Zeroth404> > (sqrt pi)^2
17:27:14 <lambdabot>  3.1415926535897927
17:27:51 <Zeroth404> > pi
17:27:52 <lambdabot>  3.141592653589793
17:27:54 <elaforge> here's a basic parsec question: val `sepBy` (many1 space) >> many spaces >> char '\n'
17:28:02 <Zeroth404> is there a way to define precision?
17:28:19 <elaforge> unfortunately if the (many1 space) gets a space it really wants to match another val
17:28:33 <elaforge> I tried (try (many1 space)) but no luck
17:28:39 <narain> Zeroth404: you mean floats vs. doubles?
17:28:50 <Zeroth404> not really
17:29:04 <Zeroth404> I mean 100 digits instead of 10 :-)
17:29:04 <allbery_b> many1 (val >> spaces) >> newline -- ?
17:29:15 <allbery_b> hm, no
17:29:25 <Zeroth404> in tcl you can specify the precision of math functions
17:29:36 <mgsloan> I think there are a few real number libs for haskell
17:29:48 <Zeroth404> like sqrt 2 would yield as many digits as you like
17:29:51 <qwr> elaforge: what it should do?
17:29:57 <Zeroth404> > sqrt 2
17:29:58 <lambdabot>  1.4142135623730951
17:30:06 <Saizan> ?type sqrt
17:30:08 <lambdabot> forall a. (Floating a) => a -> a
17:30:09 <mgsloan> which delay eval to string out/round to normal representation
17:30:13 <Zeroth404> > (sqrt 2)*2
17:30:14 <lambdabot>  2.8284271247461903
17:30:16 <elaforge> qwr: match space separated vals, and trailing space and then newline
17:30:19 <Zeroth404> heh
17:30:30 <mgsloan> (and allow string eval to have as many digits as you like)
17:30:44 <yip> how do i make the list [n,n-1,n-2..0] ?
17:30:53 <Zeroth404> > (sqrt 2)*(sqrt 2)
17:30:54 <lambdabot>  2.0000000000000004
17:30:56 <mgsloan> > [9..0]
17:30:58 <lambdabot>  []
17:31:01 <mgsloan> huh
17:31:04 <Zeroth404> close, but no cigar ;-)
17:31:08 <narain> > reverse [0..9]
17:31:09 <mgsloan> > [9,8..0]
17:31:09 <Japsu> > [9,8.. 0]
17:31:10 <lambdabot>  [9,8,7,6,5,4,3,2,1,0]
17:31:11 <lambdabot>  [9,8,7,6,5,4,3,2,1,0]
17:31:12 <lambdabot>  [9,8,7,6,5,4,3,2,1,0]
17:31:22 <fantasma> > flip [0..10]
17:31:23 <lambdabot>  Couldn't match expected type `a -> b -> c'
17:31:27 <narain> ok, your way's better
17:31:30 <mgsloan> imho it should infer -1 delta
17:31:33 <yip> > [1,0..0]
17:31:35 <lambdabot>  [1,0]
17:31:40 <Zeroth404> [1,1,2,3,5,8,13,..]
17:31:45 <Zeroth404> > [1,1,2,3,5,8,13,..]
17:31:45 <lambdabot>  Parse error
17:31:47 <Zeroth404> > [1,1,2,3,5,8,13..]
17:31:48 <lambdabot>  Parse error
17:31:49 <narain> :D
17:31:50 <elaforge> allbery_b: unfortunately that won't work with a single arg\n
17:31:57 <Japsu> lol what
17:31:58 <Zeroth404> > [1,1,2,3,5,8,13..5555]
17:31:58 <lambdabot>  Parse error
17:32:08 <allbery_b> <allbery_b> hm, no
17:32:13 <yip> > let x = 10 in [x, x-1 .. 0]
17:32:15 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
17:32:17 <allbery_b> I realized it was wrong after I sent it
17:32:21 <yip> > let x = 2 in [x, x-1 .. 0]
17:32:22 <lambdabot>  [2,1,0]
17:32:26 <yip> > let x = 1 in [x, x-1 .. 0]
17:32:28 <lambdabot>  [1,0]
17:32:31 <yip> > let x = 0 in [x, x-1 .. 0]
17:32:32 <lambdabot>  [0]
17:32:37 <elaforge> allbery_b: sorry, lost in noise :)
17:32:48 <Japsu> > let x = -1 in [x, x-1 .. 0]
17:32:50 <lambdabot>  []
17:32:52 <Japsu> \o/
17:33:03 <allbery_b> Zeroth404: [x,y..z] is special syntax for enumFromThenTo x y z.  it doesn't generalize to e.g. [x,y,z..w]
17:33:16 <Japsu> @hoogle enumFromThenTo
17:33:17 <lambdabot> Prelude.enumFromThenTo :: Enum a => a -> a -> a -> [a]
17:33:17 <lambdabot> Language.Haskell.Syntax.HsEnumFromThenTo :: HsExp -> HsExp -> HsExp -> HsExp
17:33:29 <narain> @src enumFromThenTo
17:33:30 <lambdabot> Source not found. My mind is going. I can feel it.
17:33:33 <Japsu> !!
17:33:37 <mgsloan> would be cool if it could figure out polynomials that fit the data, though
17:33:44 <mgsloan> or rather, delta deltas
17:34:01 <yip> mgsloan: write your own function to do that :)
17:34:18 <mgsloan> yeah :)
17:34:20 <allbery_b> @where oeis
17:34:20 <narain> mgsloan: also won't work for arbitrary enums
17:34:21 <lambdabot> http://www.research.att.com/~njas/sequences/
17:34:24 <allbery_b> ...go nuts :)
17:34:36 <Zeroth404> > 4 (1,2,3,4)
17:34:37 <lambdabot>        add an instance declaration for (Num ((t, t1, t2, t3) -> a))
17:34:37 <lambdabot>     In th...
17:34:46 <mgsloan> yeah, tap into the internet sequence library :)
17:35:09 <mgsloan> narain - really? enums don't have subtraction?
17:35:23 <allbery_b> > True - False
17:35:24 <lambdabot>   add an instance declaration for (Num Bool)
17:35:25 <lambdabot>     In the expression: True - Fa...
17:35:29 <allbery_b> doesn't look like it :)
17:35:34 <allbery_b> @instances Enum
17:35:35 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
17:35:36 <Zeroth404> > True = False
17:35:36 <lambdabot>  Parse error
17:35:37 <mgsloan> > True + False
17:35:37 <lambdabot>   add an instance declaration for (Num Bool)
17:35:38 <lambdabot>     In the expression: True + Fa...
17:35:42 <mgsloan> yeah...
17:35:44 <narain> mgsloan: don't you also need scalar multiplication for polynomials?
17:35:51 <mgsloan> should have known, since num defines +/-
17:36:16 <mgsloan> yeah, instead i changed it to delta deltas, eg, the rate of change changes linearly :)
17:36:25 <rahikkala> > minBound :: Bool
17:36:26 <lambdabot>  False
17:36:29 <mgsloan> or if you give it 4, the rate of change of the rate of change changes linearly
17:36:40 <Japsu> @src (!!)
17:36:40 <lambdabot> xs     !! n | n < 0 = undefined
17:36:40 <lambdabot> []     !! _         = undefined
17:36:40 <lambdabot> (x:_)  !! 0         = x
17:36:40 <lambdabot> (_:xs) !! n         = xs !! (n-1)
17:36:49 <mgsloan> > ['a', 'c'..'z']
17:36:50 <lambdabot>  "acegikmoqsuwy"
17:36:55 <mgsloan> hah
17:37:02 <mgsloan> so how does it do that if there's no -?
17:37:14 <Saizan> ?src Enum
17:37:15 <lambdabot> class  Enum a   where
17:37:15 <lambdabot>     succ                     :: a -> a
17:37:15 <lambdabot>     pred                     :: a -> a
17:37:15 <lambdabot>     toEnum                   :: Int -> a
17:37:17 <lambdabot>     fromEnum                 :: a -> Int
17:37:17 <lambdabot> [3 @more lines]
17:37:19 <allbery_b> > fromEnum 'c'
17:37:21 <lambdabot>  99
17:37:22 <elaforge> allbery_b: aha: sepEndBy, I just needed to read the doc again :)
17:37:22 <Japsu> > 'c' - 'a'
17:37:23 <lambdabot>   add an instance declaration for (Num Char)
17:37:24 <lambdabot>     In the expression: 'c' - 'a'...
17:37:24 <rahikkala> > succ False
17:37:26 <lambdabot>  True
17:37:28 <mgsloan> ohh
17:37:41 <Zeroth404> how do I get the n'th element of a list?
17:37:45 <Japsu> > succ 'a'
17:37:46 <lambdabot>  'b'
17:37:53 <allbery_b> > toEnum (fromEnum 'c' + 2) :: Char
17:37:54 <lambdabot>  'e'
17:38:01 <narain> Zeroth404: (!!)
17:38:04 <allbery_b> succ nd pred work too
17:38:09 <Zeroth404> ?
17:38:20 <narain> > [0,1,2,3,4,5] !! 3
17:38:21 <lambdabot>  3
17:38:34 <Zeroth404> > snd ([(5,?b?),(1,?c?),(6,?a?)] !! 2)
17:38:34 <lambdabot>  Parse error
17:38:56 <narain> Zeroth404: im seeing question marks instead of quotes
17:39:07 <Zeroth404> hmm
17:39:07 <narain> > snd ([(5,"b"),(1,"c"),(6,"a")] !! 2)
17:39:09 <lambdabot>  "a"
17:39:10 <Zeroth404> I'm not
17:39:20 <Zeroth404> > snd ([(5,'b'),(1,'c'),(6,'a')] !! 2)
17:39:21 <lambdabot>  'a'
17:39:30 <Zeroth404> yeah, copied that text from a PDF
17:39:43 <allbery_b> probably mapped smartquotes to ?
17:39:44 <narain> could be curly quotes
17:40:10 <Zeroth404> I can't find any inscance of "!!" anywhere in YAHT
17:40:13 <Japsu> snd $ tail $ head [(5,"b"),(1,"c"),(6,"a")]
17:40:17 <Japsu> > snd $ tail $ head [(5,"b"),(1,"c"),(6,"a")]
17:40:17 <lambdabot>  Couldn't match expected type `[a]'
17:40:34 <Japsu> > snd $ head $ tail [(5,"b"),(1,"c"),(6,"a")]
17:40:36 <lambdabot>  "c"
17:40:44 <fantasma> how does getContents work??
17:40:51 <Japsu> @src getContents
17:40:52 <lambdabot> getContents = hGetContents stdin
17:40:58 <sorear> fantasma: evilly
17:41:01 <Japsu> @src hGetContents
17:41:02 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:41:06 <Japsu> !!
17:41:06 <fantasma> @type hGetContents
17:41:09 <lambdabot> Not in scope: `hGetContents'
17:41:11 <Japsu> @insult
17:41:12 <lambdabot> Unknown command, try @list
17:41:13 <fantasma> great
17:41:19 <narain> @hoogle hGetContents
17:41:20 <lambdabot> IO.hGetContents :: Handle -> IO String
17:41:23 <allbery_b> the short answer is it uses unsafeInterleaveIO to perform evil
17:41:25 <fantasma> sorear, why do you say that
17:41:27 <narain> @type IO.hGetContents
17:41:29 <lambdabot> GHC.IOBase.Handle -> IO String
17:41:36 <pstickne> what is the one haskell persistent server thing, HaPS? That doesn't sound quite right and I'm not getting google hits.
17:41:42 <allbery_b> @where happs
17:41:43 <lambdabot> http://happs.org
17:41:48 <Zeroth404> narain: is there another way?
17:41:54 <sorear> fantasma: to a first approximation (ignoring EOF and exceptions):
17:41:54 <sorear> getContents = unsafeInterleaveIO $ liftM2 (:) getChar getContents
17:41:57 <pstickne> Ohh, HAppS :)
17:41:59 <Zeroth404> > 3 !! [1,1,1]
17:42:00 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
17:42:05 <Zeroth404> > [1,1,1] !! 3
17:42:06 <lambdabot>  Exception: Prelude.(!!): index too large
17:42:15 <narain> indices start from zero
17:42:21 <Zeroth404> ah, stupid me
17:42:23 <Zeroth404> > [1,1,1] !! 2
17:42:24 <lambdabot>  1
17:42:26 <Zeroth404> > 2 !! [1,1,1]
17:42:27 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
17:42:47 <allbery_b> this isn't C, 3["foobar"] doesn't work :)
17:42:50 <Zeroth404> > ((2 !!) [1,1,1])
17:42:50 <mgsloan> only C++ has foo[] 1 == foo[1]
17:42:51 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
17:43:06 <Zeroth404> funny, I've never done 3["foobar"] before
17:43:11 <mgsloan> > (!!2)[1,2,3]
17:43:13 <lambdabot>  3
17:43:14 <Japsu> haha, that's just evil :D
17:43:19 <Zeroth404> I've never even used 2[] let alone ["string"]
17:43:40 <Zeroth404> doesnt seem like it would work
17:43:41 <Japsu> anyway in C a[b] is just a+b :)
17:43:48 <Zeroth404> yea
17:43:54 <narain> actually a[b] = *(a+b)
17:44:04 <Japsu> yeah
17:44:05 <narain> nitpick
17:44:17 <sorear> error!
17:44:25 <Japsu> hmm
17:44:31 <Japsu> *(a + b * sizeof(a)) ?
17:44:56 <narain> no, adding ints to pointers automagically takes sizeof into account
17:45:02 <Japsu> right
17:45:03 <allbery_b> yeh
17:45:16 <allbery_b> which is why 3["foobar"] does the "right" thing
17:45:22 <Japsu> yeah
17:46:38 <dons> ?users
17:46:38 <lambdabot> Maximum users seen in #haskell: 336, currently: 313 (93.2%), active: 48 (15.3%)
17:48:19 <fantasma> how do I input a file that's just numbers as a list?
17:48:56 <fantasma> i already have moo = do nums <- readFile "numbers.txt"
17:50:14 <sorear> > [1,2,3] !! 2
17:50:14 <sorear> @botsnack
17:50:14 <sorear> or am I lagging?
17:50:14 <lambdabot> :)
17:50:15 <lambdabot>  3
17:51:53 <sorear> actually, this should work in Haskell too
17:51:55 <stmartin> How can I get putStrLn etc. to not escape characters in input. For example, I want    putStrLn "\9608 FULL BLOCK"    do display in its Unicode glory, and not as either "\9608 FULL BLOCK" or "? FULL BLOCK".
17:52:55 <stmartin> LC_ALL and LC_CTYPE are set to en_NZ.UTF-8. Other Unicode enabled applications can display okay.
17:53:00 <sorear> stmartin: output is always 8 bit, sadly
17:53:30 <sorear> stmartin: GHC truncates outputted chars to 8 bits.  it doesn't utf-8 encode.
17:53:47 <stmartin> Bother, said Pooh.
17:54:36 <stmartin> Does it do that just for GHCi, or whenever I, eg. write to a file/socket etc.
17:54:52 <sorear> whenever you write to anything.
17:55:24 <yip> sorear: that's not my experience
17:55:24 <stmartin> What's the point in having a Unicode enabled language if you can't write out Unicode!?!
17:55:40 <yip> sorear: i send utf8 encoded data to/from a socket
17:56:04 <sorear> yip: you have to do it yourself, if you're using the GHC IO system
17:56:13 <chessguy> yo ho ho!
17:56:15 <sorear> (do sockets use the IO system)
17:56:26 <sorear> hm.
17:56:43 <yip> sorear: i'm using hPutStr
17:56:56 <dons> you just use one of the unicode libraries to pack your Unicode chars into bytes
17:56:58 <dons> then write those out.
17:57:07 <rahikkala> > parseTest (many1 digit `sepBy` char ' ') "1 2 3 4"
17:57:08 <yip> yeah, i'm using UTF8.lhs. don't have any problems
17:57:08 <lambdabot>   Not in scope: `sepBy'
17:57:31 <sorear> UTF8.lhs is slow
17:57:49 <sorear> Vty got an instant 10% speedup when I replaced it with my own utf8 printer
17:58:19 <stmartin> Where would I find that? I don't see it mentioned in the Haskell Hierarchical Libraries on the web.
17:58:19 <yip> well it seems to do pretty thorough error checking
17:58:29 <sorear> stmartin: hah
17:58:31 <chessguy> suppose i have a [(Int, Foo)], and i want to select a Foo at random, but weighted by the associated Int. suggestions?
17:58:38 <yip> stmartin: get it from the darcs darcs repository
17:58:40 <sorear> stmartin: like it would be in the standard libraries
17:58:49 <sorear> stmartin: you are too optimistic :(
17:58:59 <sjanssen> sorear: someday . . .
17:59:02 <sorear> @where darcs-unstable
17:59:03 <lambdabot> http://www.abridgegame.org/repos/darcs-unstable
17:59:13 <sorear> http://www.abridgegame.org/repos/darcs-unstable/UTF8.lhs
18:00:29 <chessguy> i'm thinking of taking the sum, s, and then choosing a random number in (1,s), and then finding the appropriate element that way
18:00:42 <elaforge> chessguy: knuth has a nice one for that, lemme think...
18:01:55 <elaforge> chessguy: it starts off with an n/m change to return the head, and each time subtracts from n so by the time you are at the last it's 1/1
18:01:55 * sorear just invented two algorithms for this purpose
18:02:01 <yip> what's a good algorithm for checking if you have a 4-in-a-row pattern in a grid, straight or diagnol?
18:02:15 <elaforge> forget the details and my book is at work :/
18:02:20 <chessguy> elaforge, n/m change?
18:02:20 <sorear> yip: how big is your grid
18:02:39 <sorear> chessguy: chance
18:02:53 <elaforge> chessguy: oh yeah, sorry
18:02:53 <yip> sorear: hm... small but actually i want to detect if there is a 4-in-a-row that goes through a specific cell
18:03:07 <chessguy> what's n/m though?
18:03:30 <sorear> chessguy: how often do you use the same list?  do you use the same set of weights each time?
18:03:41 <elaforge> chessguy: ahh, that's the detail :)  if it were even distribution it would be (1/length left)
18:03:47 <qwr> elaforge: btw, imho your parser eats '\n' as space before char '\n'
18:03:58 <chessguy> sorear, frequently. yes.
18:04:11 <elaforge> qwr: my defn of space excludes \n
18:04:19 <elaforge> qwr: sepEndBy seems to be working nicely though
18:04:47 <sorear> chessguy: frequently changes or frequently reused?
18:04:59 <sorear> chessguy: is this to pick genes from a static list?
18:05:03 <elaforge> chessguy: this algo might not do too well on lists, however :)
18:05:06 <chessguy> sorear, no
18:05:13 <chessguy> sorear, frequently used
18:05:33 <chessguy> sorear, it's for selecting individuals from a population to generate a new population
18:05:35 <sjanssen> yip: I'd say your best bet is to generate all four in a rows that go through a certain cell, and count on laziness to reduce computation
18:06:19 <yip> hm....
18:07:10 <fantasma> how do i do this...
18:07:12 <fantasma> nums = readFile $ "numbers.txt"
18:07:13 <fantasma> numss = (readIO :: String -> IO Int) nums
18:07:13 <fantasma> printer = print numss
18:07:17 <chessguy> yip, if it's 8x8, there could be some nice bit-pattern techniques that could be used
18:07:23 <sjanssen> then the algorithm becomes: any (all inGrid) (everyPossibleLineWithCell c)
18:07:45 <yip> sjanssen: interesting, i'll try that
18:08:09 <chessguy> @type print . readIO . readFile
18:08:10 <yip> chessguy: problem is that each cell can have one of three values
18:08:12 <lambdabot>     Couldn't match expected type `String'
18:08:12 <lambdabot>            against inferred type `IO String'
18:08:31 <chessguy> yip, that's not a problem
18:08:32 <sjanssen> yip: how big is the board?
18:08:50 <yip> sjanssen: 7x6
18:08:50 <fantasma> chessguy, help :(
18:09:28 <yip> sjanssen: also please keep in mind that i am going to have to also implement this in javascript :(
18:09:43 <Cale> fantasma: nums isn't a String
18:09:49 <chessguy> @type gets readIO
18:09:52 <lambdabot> forall a (m :: * -> *). (Read a, MonadState String m) => m (IO a)
18:09:56 <dons> nostrademons: hi, how's code?
18:10:00 <sjanssen> yip: maybe you can compile it to js with yhc? :)
18:10:01 <Cale> fantasma: It's an IO String, that is, an action which when run will produce a String.
18:10:13 <Cale> fantasma: You need to use do-notation to glue these actions together
18:10:26 <fantasma> Cale, i tried it with do and that failed too :(
18:10:44 <fantasma> Cale, is there any way to convert IO String to just String
18:10:55 <yip> sjanssen: the world will be a better place when the day comes that yhc will be usable for that in "real world" situations
18:11:07 <sjanssen> yip: true, true
18:11:10 <chessguy> fantasma, something like numss = do { s <- nums; return $ readIO s }
18:11:18 <sjanssen> does js have lazy lists?
18:11:23 <yip> no
18:11:24 <Cale> printNums = do { num <- readFile "numbers.txt"; let n = read num; print n }
18:11:25 <Cale> er
18:11:33 <Cale> printNum would be more accurate there
18:11:41 <qwr> fantasma: readFile "numbers.txt" >>= putStr . unwords . (map (show . (+ 1) . read)) . words
18:11:42 <dons> ?where jhc
18:11:42 <lambdabot> http://repetae.net/john/computer/jhc/
18:11:44 <sjanssen> come on, it's the year 2007!
18:11:45 <dons> ?where DrIFt
18:11:46 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
18:11:54 <Cale> printNums = do { num <- readFile "numbers.txt"; let ns = map read . words $ num; print ns }
18:12:08 <Cale> Or something like that, if the file has lots of numbers.
18:12:39 <Cale> fantasma: Do you see how that works? x <- a will run the action a to produce x.
18:12:53 <qwr> fantasma: which increments every number with (+1)
18:13:02 <Cale> However, it doesn't do this in evaluation of printNums, only in execution of the action printNums represents.
18:13:14 <QtPlatypus> How do I get the N'th element of a tupple?
18:13:32 <chessguy> QtPlatypus, use pattern matching
18:13:37 <Cale> The only things which can cause execution are the runtime system (it executes main) or GHCi, when you type an action.
18:13:58 <Cale> QtPlatypus: case foo of (x,y,z) -> y
18:14:01 <Saizan> uhm, when in the HList slides/srcs it says that labels have no runtime representation it's not counting typeclasses' dictionaries, right?
18:14:05 <chessguy> @type \(_,_,_,_,_,a) -> a
18:14:08 <lambdabot> forall t t1 t2 t3 t4 t5. (t, t1, t2, t3, t4, t5) -> t5
18:14:19 <QtPlatypus> Thanks
18:14:29 <Cale> or yeah, lambdas :)
18:14:34 <elaforge> QtPlatypus: fst, snd also work for pairs
18:14:48 <Cale> It's uncommon in Haskell to use tuples larger than pairs.
18:14:59 <Cale> And very uncommon to use anything larger than a triple.
18:15:10 <chessguy> yeah, usually if you want to do that, you're better off using a record
18:15:20 <elaforge> but there's zip3721 just in case :)
18:15:25 <jcreigh> heh
18:16:12 <dons> ?uptime
18:16:13 <lambdabot> uptime: 5d 1h 4m 52s, longest uptime: 5d 1h 4m 52s
18:16:27 <hpaste>  sorear pasted "Amortized O(log n) selection from a weighted list" at http://hpaste.org/783
18:16:33 <sorear> chessguy: ^^^
18:18:11 <chessguy> is M really that much more convenient than Map?
18:18:22 <sorear> I love the way in haskell I can write semi-tricky algorithms like random tree selection, and all the errors I get are scoping related. :)
18:18:51 <sorear> chessguy: I thought it was More Traditional
18:18:56 <sorear> @users
18:18:56 <lambdabot> Maximum users seen in #haskell: 336, currently: 308 (91.7%), active: 44 (14.3%)
18:19:18 <kc5tja> sorear: Unfortunately, the code is utterly opaque to me.
18:19:31 <kc5tja> (not that I've been paying attention, but I don't find the code particularly self-documenting)
18:19:44 <chessguy> you realize of course, i'll never comprehend this code
18:20:13 <sorear> urg, *tries harder*
18:24:49 <Cale> fantasma: Yes, but only inside a do-block
18:25:01 <Cale> fantasma: x <- a like I described.
18:25:08 <Cale> If a :: IO String, then x :: String
18:25:15 <fantasma> Cale, I cant get this to work
18:25:30 <Cale> Let's have a look at what you're doing
18:25:32 <ndm> ?where lambdabot
18:25:32 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:25:33 <Cale> !paste
18:25:33 <hpaste> Haskell paste bin: http://hpaste.org/
18:25:54 <hpaste>  fantasma pasted "file IO" at http://hpaste.org/784
18:26:33 <Cale> fantasma: you're returning from moo, the IO action, which will read the string
18:26:53 <Cale> readIO isn't particularly interesting -- it's only useful if you want parse errors to be thrown as IO exceptions
18:27:04 <Cale> It's much better to use read
18:27:07 <Cale> (usually)
18:27:15 <fantasma> Cale, so replace rList w/ read?
18:27:26 <hpaste>  Cale annotated "file IO" with "fixed" at http://hpaste.org/784#a1
18:27:42 <Cale> another way to do this would be...
18:27:58 <hpaste>  Cale annotated "file IO" with "(no title)" at http://hpaste.org/784#a2
18:28:43 <fantasma> Cale, using 'read' didnt work
18:28:52 <Cale> What happened?
18:29:02 <Cale> Does your file contain a single number?
18:29:05 <fantasma> Ambiguous type variable `a' in the constraint
18:29:12 <fantasma> Cale, it contains a very big number
18:29:15 <Cale> oh, right, give the thing a type signature
18:29:23 <Cale> So it knows to read an Integer
18:29:38 <Cale> (that is, moo :: IO Integer)
18:30:16 <Cale> (You could also turn the monomorphism restriction off)
18:30:55 <fantasma> Illegal signature in pattern: IO Int
18:30:55 <fantasma>     Use -fglasgow-exts to permit it
18:31:06 <Cale> huh?
18:31:11 <Cale> moo :: IO Int
18:31:13 <Cale> moo = do ...
18:31:23 <Cale> er
18:31:53 <rahikkala> @src unwords
18:31:54 <lambdabot> unwords [] = ""
18:31:54 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
18:32:00 <Cale> Use Integer if the number is large or you'll get whatever it is mod 2^32 or whatever your machine integers do.
18:32:30 <fantasma> i have moo :: IO Integer = do ...
18:32:39 <Cale> ah, yeah, you can't do that
18:32:44 <jcreigh> fantasma: put on two lines
18:32:48 <jcreigh> moo :: IO Integer
18:32:51 <jcreigh> moo = do ...
18:32:51 <Cale> you could however put a type signature on the other side of the =
18:33:00 <Cale> but that's awkward here
18:33:25 <Cale> I suppose you could label the last line of the do with :: IO Integer
18:33:46 <fantasma> now can I use moo as I would any other integer?
18:33:59 <Cale> no
18:34:06 <Cale> moo is an action for getting an Integer
18:34:09 <chessguy> moo is not an Integer. look at the type signature
18:34:16 <ndm> dons: lambdabot --partial has 500 patches, time for a tag methinks
18:34:17 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
18:34:21 <ndm> @messages
18:34:22 <lambdabot> sorear said 1h 40m 47s ago: @clear-messages
18:34:24 <Cale> You have to run it to get the Integer.
18:34:32 <Cale> You can only run it inside another action.
18:34:53 <Cale> However, that action might pass the result off to a pure function to do the real work of your program.
18:34:59 <Cale> (and then perhaps some output)
18:35:19 <fantasma> so I would have to call the function from the do of moo
18:35:24 <Cale> yeah.
18:35:28 <Cale> That would be sane.
18:35:48 <Cale> let result = f (read num)
18:35:53 <Cale> print result
18:36:00 <Cale> (in the do-block of moo)
18:36:34 <Cale> f would take an Integer.
18:36:56 <hpaste>  now with 1400%  annotated "Amortized O(log n) selection from a weighted list" with "sorear" at http://hpaste.org/783#a1
18:37:14 <sorear> + "more comments"
18:41:05 <chessguy> sorear, did i say Int? i meant Double
18:41:05 <sorear> glguy: it cut off my "nick"
18:41:05 * chessguy giggles
18:41:05 <chessguy> (just kidding)
18:41:05 <fantasma> > show 10
18:41:05 <lambdabot>  "10"
18:41:05 <chessguy> sorear++
18:41:05 <fantasma> > "10" + "12"
18:41:05 <lambdabot>   add an instance declaration for (Num [Char])
18:41:05 <lambdabot>     In the expression: "10" + ...
18:41:05 <Cale> > "10" ++ "12"
18:41:05 <lambdabot>  "1012"
18:41:05 <Cale> > show (read "10" + read "12")
18:41:05 <lambdabot>  "22"
18:41:05 <fantasma> Cale, how can I then convert that int into a list (each digit being an element in the list)
18:41:05 <chessguy> it is already
18:41:05 <Cale> well, show works, if the thing is positive.
18:41:05 <sorear> > map (read . return) . show $ "1234"
18:41:05 <chessguy> > length "22"
18:41:05 <lambdabot>  Exception: Prelude.read: no parse
18:41:05 <lambdabot>  2
18:41:05 <chessguy> > length "2234"
18:41:05 <lambdabot>  4
18:41:05 <sorear> > map (read . return) . show $ 1234
18:41:05 <lambdabot>  [1,2,3,4]
18:41:05 <Cale> Or do you want the digits to be Integers?
18:41:05 <fantasma> no instance for IO Integer
18:41:05 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 1234
18:41:05 <fantasma> yah I want the digits to be ints
18:41:05 <lambdabot>  [4,3,2,1]
18:41:49 <Cale> oh, interesting, that gives an infinite list if the number is negative :)
18:42:02 <Cale> using quot and rem in place of div and mod works though.
18:42:16 <bd_> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ (-1234)
18:42:17 <lambdabot>  [6,6,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
18:42:42 <Cale> It's giving the 10-adic expansion.
18:43:28 <Cale> http://en.wikipedia.org/wiki/P-adic_number
18:44:18 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ -1
18:44:19 <lambdabot>  [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
18:44:24 <Cale> :)
18:44:30 <Cale> cute.
18:44:42 <Cale> ...9999 = -1
18:44:49 <merus> Oh God.
18:44:59 <merus> Don't let the high schoolers hear.
18:45:00 <hpaste>  fantasma annotated "file IO" with ":(" at http://hpaste.org/784#a3
18:45:03 <merus> I'll never hear the end of it
18:45:21 <merus> (kidding)
18:45:35 <Cale> well, think about what happens when you add 1 and carry out the addition algorithm ;)
18:45:46 <Cale> you get ...0000
18:45:53 <bd_> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ (-35)
18:45:55 <lambdabot>  [5,6,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
18:45:57 <Gwern> hmm. is there a function which like interact lazily reads a stream and can feed it (after processing through 'words') to a function doing IO stuff?
18:46:13 <fantasma> Cale, look at the paste
18:46:21 <bd_> :t interact
18:46:24 <lambdabot> (String -> String) -> IO ()
18:46:31 <merus> Cale: Yeah, I know about p-adic numbers.  I was just thinking about people who claim .999... != 1
18:46:43 <Cale> fantasma: let numlist = map (read . return) . show $ num
18:46:49 <Cale> merus: eya
18:46:49 <bd_> Gwern: interact (unwords . f . words) ?
18:46:50 <merus> Imagine their consternation upon learning ...999 = -1
18:46:51 <Cale> yeah*
18:46:58 <Cale> merus: hehe
18:49:04 <Cale> fantasma: map (read . return) . show $ num is not an action, so you don't run it with <_
18:49:04 <Cale> <-
18:49:04 <fantasma> Cale, I tried with let and it failed too
18:49:04 <Gwern> bd_: hmm. maybe that'd work
18:49:04 <Cale> oh?
18:49:04 <allbery_b> I don't nderstand what you're trying to do there
18:49:04 <hpaste>  Cale annotated "file IO" with "fixed?" at http://hpaste.org/784#a4
18:49:04 <allbery_b> map read . show?
18:49:04 <Cale> > map (read . return) . show $ 1234
18:49:04 <lambdabot>  [1,2,3,4]
18:49:04 <Cale> > map (read . (:[])) . show $ 1234
18:49:04 <lambdabot>  [1,2,3,4]
18:49:04 <Cale> same thing
18:49:04 <hpaste>  allbery_b annotated "file IO" with "did you mean something like this?" at http://hpaste.org/784#a5
18:49:15 <fantasma> Couldn't match expected type `Integer' against inferred type `()'
18:49:25 <Cale> oh, right
18:49:32 <hpaste>  allbery_b annotated "file IO" with "oops" at http://hpaste.org/784#a6
18:49:38 <Cale> Your type signature for moo is wrong now.
18:49:43 * jcreigh has achieved his life-long goal of having a triple-monitor setup
18:49:47 <Cale> It's IO () now
18:49:53 <merus> jcreigh, grats
18:49:56 <Cale> because we're just printing the result and not returning it
18:50:18 <hpaste>  allbery_b annotated "file IO" with "or this" at http://hpaste.org/784#a7
18:52:23 <fantasma> allbery_b, your code just printed the number itself as opposed to the sum :)
18:52:24 <sorear> jcreigh: find a new one, fast!
18:52:36 <sorear> jcreigh: we can't have you becoming aimless!
18:52:53 <jcreigh> sorear: well, I don't think I'm going to go for 4. That would really be overkill.
18:53:43 * sorear wants to find a way to get his brain to speak 100baseT directly, or at least RS-232
18:53:44 <fantasma> I can't use 'words' because theres no spaces between the digits
18:53:50 <jcreigh> 2 is definitely a win, 3 is a little much, but still reasonable. But I had the extra video card, what was I to do?
18:54:14 <allbery_b> fantasma: I don'
18:54:22 <allbery_b> t really understans what you're doing
18:54:33 <allbery_b> the map (read . return) $ show thing has me lost
18:54:48 <fantasma> allbery_b, i have a long number in a file and i want to add up the digits of that number
18:54:51 <allbery_b> it's *already* in "show" format, presumably, since you read it from a file
18:54:52 <allbery_b> oh
18:55:05 <jcreigh> > map digitToInt (show 1234)
18:55:07 <lambdabot>  [1,2,3,4]
18:55:23 <fantasma> nice
18:55:27 <nmessenger> @index digitToInt
18:55:27 <lambdabot> Data.Char
18:55:33 <jcreigh> fantasma: a string is a list of Char, and digitToInt is Char -> Int, so you can just map it over the string.
18:55:55 <hpaste>  allbery_b annotated "file IO" with "ahh, digits" at http://hpaste.org/784#a8
18:57:04 <fantasma> @type digitToInt
18:57:07 <lambdabot> Char -> Int
18:58:23 <fantasma> thanks jcreigh and everyone
18:58:45 <hpaste>  nmessenger annotated "file IO" with "<3 fmap" at http://hpaste.org/784#a9
19:00:27 <nmessenger> the toInteger would be unneccessary if digitToInt returned Integral a => a
19:00:50 <chessguy> ?hoogle digitToInt
19:00:51 <lambdabot> Char.digitToInt :: Char -> Int
19:01:16 <nmessenger> <3 polymorphism too
19:01:24 <chessguy> well the name wouldn't be very good then :)
19:01:47 <nmessenger> fromDigit might work :)
19:01:49 <bd_> ?hoogle digitToNum
19:01:50 <lambdabot> No matches found
19:02:02 <chessguy> ?hoogle digit
19:02:03 <lambdabot> Text.ParserCombinators.Parsec.Char.digit :: CharParser st Char
19:02:03 <lambdabot> Char.digitToInt :: Char -> Int
19:02:03 <lambdabot> Char.intToDigit :: Int -> Char
19:02:12 <chessguy> ?hoogle+
19:02:43 <allbery_b> @src digitToInt
19:02:44 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:03:03 * chessguy teaches allbery_b to put his fingers on the home row...
19:03:23 * allbery_b beats chessguy with his ice cream spoon
19:03:50 <chessguy> mmmmm, ice cream
19:08:47 * sorear ponders an arrow-based ultra easy to use command line parser lib
19:10:28 <ndm> sorear: i don't think what we've got at the moment is good enough, so there must be something better
19:10:42 * ndm now maintains at least 3 separate command line parsers in Haskell
19:11:03 <sorear> I've got an Idea
19:11:05 <fantasma> 392847603827409 -> [392,847,603,827,409] (any way to do this where parameter is 3)?
19:11:17 <sorear> sure
19:11:26 <sorear> @ty showIntAtBase
19:11:28 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
19:11:50 <fantasma> what module are all of these functions in?
19:11:55 <sorear> Numeric
19:11:58 <fantasma> @index showIntAtBase
19:11:58 <lambdabot> Numeric
19:12:10 <sorear> > showIntAtBase 1000 toEnum 392847603827409 ""
19:12:11 <lambdabot>  "\392\847\603\827\409"
19:12:19 <sorear> > map fromEnum $ showIntAtBase 1000 toEnum 392847603827409 ""
19:12:21 <lambdabot>  [392,847,603,827,409]
19:12:41 <sorear> that'll break for the parameter > 6 case :(
19:12:46 <sorear> > map fromEnum $ showIntAtBase 10000000 toEnum 392847603827409 ""
19:12:48 <lambdabot>  Exception: Prelude.chr: bad argument
19:13:01 <fantasma> hmm that wont work then :(
19:13:02 <sorear> since unicode only goes up to 1114111
19:13:09 <fantasma> i need something that can do 50
19:13:21 <sorear> fantasma: 50 digits at a time!?
19:13:42 <fantasma> just put a comma every 50 digits :)
19:14:30 <fantasma> that's what I need it to do
19:15:31 <fantasma> nvm I got it
19:15:41 <nmessenger> > unfoldr (let f 0 = Nothing; f x = Just (mod x 1000, div x 1000) in f) 392847603827409
19:15:43 <lambdabot>  [409,827,603,847,392]
19:17:08 <fantasma> @type lines
19:17:10 <lambdabot> String -> [String]
19:17:34 <fantasma> @type read
19:17:36 <lambdabot> forall a. (Read a) => String -> a
19:17:55 <fantasma> > read ["1","2","6"]
19:17:56 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
19:17:57 <sorear> ndm: which three commandline parsers?
19:18:01 <sorear> @where ndm
19:18:01 <lambdabot> I know nothing about ndm.
19:18:04 <sorear> @where catch
19:18:05 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
19:18:15 <sorear> @where+ ndm http://www.cs.york.ac.uk/~ndm/
19:18:16 <lambdabot> Done.
19:18:16 <fantasma> > map read ["1","2","6"]
19:18:17 <lambdabot>  [1,2,6]
19:18:52 <ndm> sorear: Yhc, Catch, and i wrote one for the Yhc build system last night (also in Yhc, but completely separate)
19:19:03 <sorear> ok.
19:19:22 <sorear> I'll go look at those three to see if they'll fit into my framework as-is
19:19:34 <sorear> maybe, gasp, will help design iteration
19:20:03 <fantasma> > print [1,3,5]
19:20:04 <lambdabot>  <IO ()>
19:20:05 <ndm> they are all quite different
19:20:22 <ndm> Yhc has a fixed number of flags, including on/off support, and some are sets which accumulate, some overwrite
19:20:22 <sorear> from each other?
19:20:24 <ndm> yes
19:20:50 <ndm> The make mode allows one action, one @profile and any number of property=value's - not from a known set of properties
19:21:05 <ndm> and the Catch one is relatively simple, i think
19:21:35 * sorear hopes his lib will not degenerate into module .. (parseYhcFlage, parseYmakeFlags, parseCatchFlags)
19:21:46 <sorear> is the catch src intended to be online yet?
19:23:07 <ndm> kind of
19:23:17 <ndm> its not intented for anyone to actively look through it
19:23:37 <ndm> and i guess technically you shouldn't be looking at the icfp paper i'm writing in there
19:23:54 <ndm> but it is all publically available, so its not top secret or anything
19:24:29 <ndm> i haven't linked to the repo from any page, but its rather obvious where it lives, and there is a darcsweb for it :)
19:24:38 * sorear just found it
19:25:09 <fantasma> how long is the biggest possible int
19:25:23 <Saizan> > maxBound :: Int
19:25:25 <lambdabot>  2147483647
19:25:30 <fantasma> digits?
19:25:42 <dons> > length (show (maxBound :: Int))
19:25:43 <lambdabot>  10
19:25:44 <sorear> fantasma: depends.  what system are you using?
19:25:58 <dons> > length (show (10 ^100))
19:25:59 <lambdabot>  101
19:26:04 <dons> > length (show (10 ^1000))
19:26:06 <lambdabot>  1001
19:26:09 <dons> > length (show (10 ^10000))
19:26:11 <lambdabot>  10001
19:26:15 <dons> > length (show (10 ^100000))
19:26:16 <lambdabot>  100001
19:26:19 <ndm> fantasma: greater than 2^29, but anything else is system dependant
19:26:20 <dons> > length (show (10 ^100000000))
19:26:22 <fantasma> i am trying to read a 50 digit number and it wont let me
19:26:24 <lambdabot> Terminated
19:26:31 <dons> fantasma: read it as Integer
19:26:33 <dons> not Int.
19:26:38 <sorear> fantasma: 50 digits needs Integer on all current platforms
19:26:39 <fantasma> ah ok
19:26:43 <dons> > length (show (10 ^ 50))
19:26:43 <lambdabot>  51
19:26:50 <dons> > read ( length (show (10 ^ 50)) ) :: Integer
19:26:50 <lambdabot>  Couldn't match expected type `String' against inferred type `Int'
19:26:51 <fantasma> @type lines
19:26:53 <lambdabot> String -> [String]
19:26:54 <sorear> fantasma: dons' uberbox can read 20 digit nums as Int
19:26:59 <dons> > read (  (show (10 ^ 50)) ) :: Integer
19:27:01 <lambdabot>  100000000000000000000000000000000000000000000000000
19:27:08 <sorear> fantasma: most civilian middle-class hw can only read 10 digits
19:27:24 <fantasma> @type read
19:27:26 <lambdabot> forall a. (Read a) => String -> a
19:27:40 <dons> > show (10 ^ 50)
19:27:41 <lambdabot>  "100000000000000000000000000000000000000000000000000"
19:27:42 <fantasma> does read return integer?
19:27:45 <dons> > read (show (10 ^ 50)) :: Integer
19:27:47 <lambdabot>  100000000000000000000000000000000000000000000000000
19:27:52 <dons> it does if you ask it to
19:27:57 <sorear> read returns ANYTHING subject to Read a
19:27:58 <dons> or if you use the result as an Integer
19:28:01 <fantasma> what about default
19:28:07 <dons> there's no default
19:28:09 <nmessenger> > logBase 10 (maxBound :: Int) -- not quite 10 digits :3
19:28:09 <fantasma> ah ok
19:28:10 <lambdabot>   add an instance declaration for (Floating Int)
19:28:10 <lambdabot>     In the expression: logBa...
19:28:14 <sorear> read returns (|~| a => ReadDict a -> a)
19:28:15 <dons> its polymorphic in its return type
19:28:20 <nmessenger> bah
19:29:33 <fantasma> map (read :: Integer) [list] make sense?
19:29:35 <nmessenger> sorear: what's that notation?
19:29:42 <dons> fantasma: hmm .no.
19:29:48 <nmessenger> read has type String -> a
19:29:54 <dons> map read list :: [Integer[
19:29:56 <dons> ]
19:30:48 <Gwern> "*** Exception: user error (("/bin/bash",["-c","python get.py 'fooo'"]): exited with code 2)"  <-- how would I catch this and simply return an empty string?
19:30:59 <sorear> nmessenger: sysf/core.  to hopefully make it clearer.
19:31:11 * sorear might have used the wrong symbol for typelambda
19:31:30 <ndm> sorear: the current Catch command line processor is in catch_1, Main.hs
19:31:55 <ndm> sorear: there is also a completely different style one (again!) in src - that one has macro expansion of parameters
19:33:41 <fantasma> i love haskell
19:34:16 <nmessenger> @remember fantasma i love haskell
19:34:17 <lambdabot> Done.
19:34:35 <fantasma> ;)
19:34:39 <nmessenger> Champagne for all!  We got another one!
19:35:14 <Cale> fantasma: IO making more sense?
19:36:01 <fantasma> Cale, yah, I just did everything inside the 'do' and it worked out nicely
19:37:39 <fantasma> not quite sure why I can't return an Integer as opposed to an IO Integer but all is good regardless
19:38:49 <fantasma> @hoogle toInteger
19:38:49 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
19:39:11 <nmessenger> which Integer would it be?  It depends on the file, so it must be in IO.
19:39:46 <hpaste>  Gwern pasted "troublesome monad comparison" at http://hpaste.org/785
19:40:17 <dons> I want a :         hackage-get arrows
19:40:38 <dons> all this ghc testing has really illustrated how useful hackage is
19:40:50 <dons> and we can make it just a bit easier with a command line downloader ;-)
19:40:56 <fantasma> nmessenger, I don't understand what you mean
19:41:01 <Gwern> yeah, so I have a problem. I get an IO String frm a shell command, and I want to execute different actions based on it, but (==) doesn't want an IO String but a String, and I can't seem to figure out how to 'lift' == to work (is 'lift' the right term?)
19:41:02 <glguy> Gwern: if b then m else return () is when b m
19:41:09 <glguy> ?type when
19:41:12 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:41:13 <Cale> dons: Downloader and installer :)
19:41:13 * fantasma quick brb
19:41:20 <dons> Cale: right. cabal-get
19:41:23 <dons> maybe i should just hack it up.
19:41:28 <Gwern> glguy: I'm sorry, what?
19:41:35 <dons> i can't imagine its more than 100 loc
19:41:42 <ndm> Yhc build system now has the facility to spot you are missing a package and automatically download and install it for you, without any user intervention :)
19:41:44 <nmessenger> @type liftM2 (==) (return "blah")
19:41:46 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char] -> m Bool
19:41:46 <dons> basically just wget http://hackage.haskell.org/packages/archive/arrows/arrows-0.2.tar.gz
19:41:49 <lambdabot> http://tinyurl.com/yuu9r7
19:41:52 <dons> hey aja_
19:41:53 <Cale> dons: It looks like there's some code for cabal-get already
19:41:58 <Gwern> glguy: nm, I think I see
19:41:59 <dons> there is
19:42:01 <glguy> Gwern: I was just telling you about the when function
19:42:04 <dons> ?version
19:42:04 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
19:42:05 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:42:10 <dons> aja_: ^^ the bot is everywhere ;)
19:42:18 <glguy> > [id] <*> [()]
19:42:19 <lambdabot>  [()]
19:42:26 <dons> everyone say high to aja! he's doing a haskell thesis at unsw this year
19:42:34 <dons> so expect code!
19:42:42 <aja_> :-)
19:42:48 <Gwern> aja_: what are you doing?
19:43:13 <aja_> I'm looking at writing a .NET Bridge for Haskell.
19:43:47 <ndm> aja_: see the .NET back end in Yhc?
19:44:02 <dons> aja, yeah, you should talk to neil/ndm
19:44:13 <aja_> ndm: I have heard of it, but haven't had a chance to look.
19:44:51 <ndm> aja_: you'll also want to talk to Oliver Hunt <oliver -at- apple.com>, and ask for a copy of his thesis
19:44:58 <aja_> ndm/dons: They're compiling to .NET right tho, as opposed to running Haskell and .NET side-by-side.
19:45:13 <Gwern> glguy: when doesn't seem to fix my problem: "when (page == "") writeFile "dict.txt" text" is still problematic because of the page == ""
19:45:14 <ndm> aja_: yeah, there is no FFI to .NET even, Oliver did hte side by side thing
19:45:27 <aja_> ndm: Cool, okay.
19:45:47 <aja_> ndm: There is Hugs98.NET of course, but only works for .NET 1.0, and only with Hugs.
19:46:10 <ndm> aja_: is that still supported? it certainly doesn't come with teh windows build, and i doubt it comes on Linux
19:46:53 <aja_> ndm: Don't know if it is still supported, but last year I was using for some work stuff, it works.
19:49:04 <nmessenger> Gwern: run :: String -> IO String ?
19:49:12 <Gwern> nmessenger: part of HSH
19:49:27 <nmessenger> does it have that type?
19:49:40 <Gwern> nmessenger: it's polymorphic so you have to supply a sig, but yes
19:50:01 <nmessenger> what type does it have?
19:50:05 <Gwern> see http://software.complete.org/hsh/static/doc/HSH-Command.html
19:51:49 <Gwern> hmm (page == (run "echo " :: IO String)) doesn't work either.
19:52:11 <dons> ndm, you might be able to covince aja to work on other win32 projects too...
19:52:17 <dons> winGHCi?
19:52:20 <Gwern> shoot, is it so hard to get a IO String and then want to compare to a regular String?
19:52:38 <ndm> dons: It's called GuiHaskell, and i've already got a demo of it (plus it uses Hugs/GHCi interchangably)
19:52:42 <dons> Gwern: do x <- run "echo " :: IO String ; return (page == x )
19:52:46 <aja_> dons: You really want me to be busy! :-)
19:53:09 <dons> Gwern: basic principle of monadic IO: evaluate your actions with <-, and then use the result
19:53:26 <dons> the action itself is an unevaluated chunk of code, of type IO String. only once you force it do you get a String you can test and use
19:53:36 <Gwern> hmm
19:54:15 <dons> do str <- run "my thing"  ; print (str == page) -- for example.
19:54:31 <dons> str :: String, run "mything" :: IO String
19:54:43 <sorear> fun! I've just been disconnected from the entire Internet for the better part of twenty minutes.
19:54:46 <sorear> @karma- lag
19:54:47 <lambdabot> lag's karma lowered to -2.
19:54:50 <sorear> @karma- lag
19:54:50 <dons> sorear: scary
19:54:50 <lambdabot> lag's karma lowered to -3.
19:54:53 * sorear goes to read the logs
19:55:03 <sorear> ndm: my system can handle the catch parser easily
19:55:22 <ndm> sorear: catch_1 or src?
19:56:02 <ndm> catch_1 is a pretty simple parser, but i would like to see what it looks like in your framework
19:56:07 <dons> aja, what dev enivronment do you use mostly? do you use win32 as your main platform?
19:56:25 <sorear> catch_1
19:57:00 <sorear> my parser atm can handle catch_1 and dd ... I still need to extend it enough to handle src, Make, tar, and darcs
19:57:12 <sorear> those will be my test cases
19:57:14 <sorear> +yhc
19:57:25 <sorear> is #ghc logged?
19:57:38 <rahikkala> sorear: That's impressive dedication :)
19:57:49 <dons> only by lambdabot.
19:57:54 <hpaste>  nmessenger annotated "troublesome monad comparison" with "does this work? no HSH so no test" at http://hpaste.org/785#a1
19:58:10 <ndm> sorear: if you do manage to nicely rewrite the Yhc parser in a Haskell 98 way, send in a patch!
19:58:18 <aja_> dons: For my .NET work (at work) I run Windows Vista and use Visual Studio.  Haven't done a lot of Haskell hacking yet, so my platform for that is do be decided I guess.
19:58:38 <ndm> aja_: WinHugs + TextPad is unbeatable (or at least i think so)
19:59:00 <hpaste>  sorear pasted "GHC (api) panic" at http://hpaste.org/786
19:59:08 <Zeroth404> if I can use 'case' to evaluate only one option, then why in the world /must/ an 'if' have an 'else' ?
19:59:14 <aja_> ndm: :-) Outside of Visual Studio I'm a bit of a vi user myself.
19:59:39 <dons> Zeroth404: what happens when you the condition in the 'if' fails, if you have no 'else' ?
19:59:44 <ndm> aja_: WinHugs integrates with gvim automatically - you wouldn't be the only one
19:59:57 <Zeroth404> dons: then it would continu execution and do nothing at all
20:00:00 <aja_> ndm: Excellent.
20:00:07 <nmessenger> > case 1 == 2 of { True -> "yay" } -- the dangers of no 'else'
20:00:08 <lambdabot>   Non-exhaustive patterns in case
20:00:09 <dons> Zeroth404: oh, so its for side effecting code?
20:00:13 <dons> then you mean to use 'when'
20:00:16 <dons> ?type when
20:00:19 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
20:00:33 <Zeroth404> dons: I don't see why /not/ requiring an 'else' is a side effect
20:00:44 <dons> Zeroth404: you're thinking imperatively, btw. you're implying there is some execution to continue, and you've some idea of what 'nothing at all' means
20:00:45 <ndm> anyway, i should sleep - i'm trying to fix my sleep patterns before i have to teach 10am on tuesday...
20:00:46 <nmessenger> @src when
20:00:46 <lambdabot> when p s = if p then s else return ()
20:00:48 <Zeroth404> requiring it seems...imperative
20:00:51 <nmessenger> ^^ use that
20:01:01 <dons> yeah, nothing at all still has to evaluate to something
20:01:27 <dons>  f x = if x then 7 in f False -- what does this do?
20:01:33 <Zeroth404> I suppose... but in that case, does a 'case' functoin require a '_' option?
20:01:34 <allbery_b> Zeroth404: if...then...else is an expression
20:01:46 <dons> > case True of True -> 7
20:01:48 <lambdabot>  7
20:01:52 <dons> > case False of True -> 7
20:01:53 <lambdabot>   Non-exhaustive patterns in case
20:02:07 <nmessenger> oh noes runtime errors!
20:02:16 <Zeroth404> doesn't that seem a bit inconsistent?
20:02:34 <dons> in monadic code, which does have a concept of 'doing nothing at all' and 'continuing execution on the next statement', you can use 'when' to optionally evauate an effect
20:02:42 <allbery_b> pattern matches are more difficult
20:03:04 <dons> in general 'else' is require in pure code because we don't like partial functoins and runtime errors
20:03:23 <nmessenger> > head [] -- don't like 'em eh?  :P
20:03:25 <lambdabot>  Exception: Prelude.head: empty list
20:03:33 <dons> we don't like the, no.
20:03:40 <dons> hence fromJust is widely hated ;)
20:04:01 <dons> Zeroth404: any thoughts ?
20:04:13 <dons> do you grok the reason we have 'when' for monadic code, but no 'when' for pure code?
20:04:23 <Zeroth404> maybe I'll understand it later, but for now I still think its inconsistent to require an else when 'case' and 'if' are used (mostly) interchangably
20:04:34 * Zeroth404 continues reading YAHT
20:04:38 <dons> consider:   f :: Int -> Int ; f x = if True then 7
20:05:03 <dons> sorry, f :: Bool -> Int ; f x = if x then 7
20:05:10 <dons> what does f False do, if it "does nothing"?
20:05:20 <dons> does it throw an exception?
20:05:23 <sorear> Zeroth404: do you know C?
20:05:25 <Zeroth404> ah
20:05:26 <Zeroth404> I do
20:05:34 <dons> or does it return a nothing value of type Int?
20:05:35 <Zeroth404> but why does that not apply to 'else' ?
20:05:47 <sorear> Zeroth404: if b then t else f   is analagous to  (b ? t : f)
20:05:50 <Zeroth404> else should require a '_'
20:05:58 <sorear> Zeroth404: in C, what would (b ? t)  (no :)  mean?
20:05:59 <dons> you mean 'case'?
20:06:24 <Zeroth404> sorear: if this then that, else break;
20:06:24 <dons> good example, sorear
20:06:32 <Zeroth404> more or less
20:06:37 <Zeroth404> breaks out of the if
20:06:44 <Zeroth404> I suppose
20:06:46 <dons> but ? : isn't a control structure in C
20:07:04 <dons> 1 + (x ? 7)
20:07:13 <dons> does what if x is false in C? :-)
20:07:21 <Zeroth404> anyhow, I do see the logic in it, but my question now is why doesn't case *require* an '_' ?
20:07:44 <dons> ah, because it is the lowest level control structure. so you can introduce partial functions there if you like
20:07:53 <nmessenger> you might say if there isn't one, that it inserts: _ -> error "Non-exhaustive pattern"
20:07:53 <Zeroth404> can I not do this:
20:07:59 <dons> if -then-else is just sugar for case x of True -> e1 ; False -> e2
20:08:03 <sorear> Zeroth404: case foo of { True -> "true!" ; False -> "false!" ; _ -> "a bool that isn't true or false!?!?!" }
20:08:16 <Zeroth404> 1 + (case of x 'x' -> s)
20:08:18 <sorear> Zeroth404: what bool isn't true or false?
20:08:21 <Zeroth404> if you'll forgive the incorrect syntax
20:08:36 <dons> > 1 + (case False of True -> 7) --
20:08:37 <Zeroth404> sorear: I get the 'if' thing
20:08:38 <lambdabot>   Non-exhaustive patterns in case
20:08:55 <dons> it inserts _ -> error "Non-exhaustive patterns in case"
20:08:58 <dons> for the missing case you didn't write
20:09:01 <sorear> Zeroth404: another good reason to require else: if x then if y then z else w
20:09:02 <nmessenger> sorear: I think Zeroth404 means why doesn't case disallow non-exhaustiveness in general, not just Bool
20:09:12 <dons> oh ok.
20:09:16 <sorear> nmessenger: Bool was just a bad example
20:09:25 <dons> in general, hmm, because it is useful to allow partial functions
20:09:31 <dons> but you can prevent them with -Wall -Werror
20:09:39 <allbery_b> the compiler does issue warnings for it, because they're bad practice
20:09:41 <dons> which will disallow you from compiling case statements with missing branches
20:09:42 <allbery_b> yeh, that
20:10:06 <Zeroth404> aha
20:10:09 <Zeroth404> it all makes sense now
20:10:11 <allbery_b> but sometimes you know there will be cases that won't happen and don't want to bother coding for them
20:10:30 <Zeroth404> I think I'm pickin up haskell pretty well
20:10:33 <dons> yeah. you have some other side condition you know means that a particular case can never occur
20:10:37 * nmessenger introduces maybeIf b x = if b then Just x else Nothing
20:10:40 <allbery_b> (I recall in the ancient days using lint assertions to tell it not to cmplain about such)
20:10:44 <allbery_b> in C code
20:11:35 <Zeroth404> I keep wanting to link commands together using brackets [] ... just learned tcl/tk a couple days agi ;-)
20:12:19 <nmessenger> @type sequence_ [putStr "blah", putStr "blargh!!"] -- ;)
20:12:21 <lambdabot> IO ()
20:12:29 <dons> heh
20:12:45 <dons> so, who knows Factor, and wants to implement it as a DSL available as a library in Haskell?
20:12:49 <dons> http://programming.reddit.com/info/17q98/comments
20:12:50 <lambdabot> Title: Forth as a Haskell DSL (reddit.com)
20:13:11 * dons imagines scheme as a library-based DSL too....
20:13:21 <dons> you know, if we're serious about world domination and all
20:13:28 <dons> then every other language should be just a DSL library
20:13:49 <allbery_b> why not?  that's what perl6 is doing... :)
20:14:10 <dons> yeah, just another haskell DSL
20:15:19 <glguy> nmessenger: const x `fmap` guard b
20:15:36 <glguy> i guess guard b >> return x is better though :(
20:15:45 <nmessenger> :D
20:16:11 <dons> anyone got some nice benchmark code for nobench?
20:16:24 <dons> some hard performance code maybe? or some 10 module lisp interpreter?
20:16:36 <sorear> dons: have you seen my Fermat's Little Theorem primefinder?
20:16:38 <dons> i'm looking for more interesting code to add to http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
20:16:38 <lambdabot> Title: nobench: Haskell implementation shootout
20:16:48 <dons> sorear: was that your little one?
20:17:31 <sorear> > map snd . filter ((==1) . uncurry gcd) . ap zip (scanl (*) 1) $ [2..]
20:17:33 <lambdabot>  [1,2,24,720,3628800,479001600,20922789888000,6402373705728000,11240007277776...
20:17:38 <sorear> > map fst . filter ((==1) . uncurry gcd) . ap zip (scanl (*) 1) $ [2..]
20:17:40 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:17:45 <sorear> dons: that one
20:19:15 <sorear> @seen yip
20:19:15 <lambdabot> I saw yip leaving #happs and #haskell 59m 31s ago, and .
20:19:47 <sorear> @ask yip How would you feel about contributing a poorly-tuned gameboy emulator to the nobench suite?
20:19:47 <lambdabot> Consider it noted.
20:19:59 <sorear> muahaha.
20:20:22 <nmessenger> devilish
20:20:26 <nmessenger> <3
20:21:22 <dons> well, it needs to be h98-ish
20:21:27 <dons> h98 + hier libs + FFI
20:21:30 <dons> + cpp
20:21:37 <dons> is really the requirement
20:22:11 <sorear> > ap zipWith ((==1) . gcd) (scanl (*) 1) $ [2..]
20:22:12 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
20:22:22 <sorear> > ap zipWith (((==1) .) . gcd) (scanl (*) 1) $ [2..]
20:22:23 <lambdabot>  Couldn't match expected type `[a]'
20:22:32 <allbery_b> hrm.  all my real haskell source depends on things that would invalidate them for nobench
20:22:51 <sorear> > ap (zipWith (((==) 1 .) . gcd)) (scanl (*) 1) $ [2..]
20:22:52 <lambdabot>  [True,True,False,True,False,True,False,False,False,True,False,True,False,Fal...
20:22:59 <sorear> > ap (zipWith (((/=) 1 .) . gcd)) (scanl (*) 1) $ [2..]
20:23:01 <lambdabot>  [False,False,True,False,True,False,True,True,True,False,True,False,True,True...
20:23:02 <dons> allbery_b: right. unless you have smaller single module programs
20:23:27 <allbery_b> only one and it's actually useless (and still relies on external data, really)
20:24:00 <allbery_b> little thing for cleaning up some of the trash macports doesn't, except it turned otu to be a lot harder than I had hoped so I set it aside until I have time to work out how to do it right
20:24:40 <allbery_b> (specifically:  upgrade stuff in macports it leaves old versions around and registered as inactive.  ports -u doesn't seem to get rid of them as I think it should)
20:25:09 <sorear> > ap(zipWith(((==)1.).gcd))(scanl(*)1)[2..]  -- bool vector primes in 41 ch
20:25:10 <lambdabot>  [True,True,False,True,False,True,False,False,False,True,False,True,False,Fal...
20:26:33 <dons> Igloo: do we need Linker.c if we're not using GHCi?
20:26:44 <allbery_b> so I wrote something that takes output from "port installed" and outputs commands to clean up old ports, but it fails if there are dependencies
20:27:00 * sorear wonders how much mathematical fame he could get if he ran all 41ch haskell progs and discovered the deep significance of their output
20:27:03 <dons> Igloo: do we get a working ghc if GhcWithInterpreter=NO also meant Linker.c wasn't built?
20:27:26 <dons> allbery_b: ok, so maybe not benchmarky material
20:27:27 <allbery_b> port outdated
20:27:29 <allbery_b> oops
20:27:39 <dons> interpeters , math stuff, string processing all good.
20:27:41 <allbery_b> yeh.
20:27:44 <dons> data structure allocating
20:27:53 <dons> but systems programming, not so good
20:28:15 <sorear> dons: UMs ?
20:28:27 <dons> none are portable enough
20:28:31 <dons> i did look at that though
20:28:43 <allbery_b> the other two major ones are:  Hebrew zemanim calculator (requires hebcal executable to determine special days); finger client (and incomplete server), requires network and FFI hooks to utmp file
20:28:43 <dons> you could hack up a portable h98 only UM though
20:28:45 <dons> that'd be good
20:29:01 <Cale> dons: Perhaps if GHC's arrays were as fast as HBC's?
20:29:28 <dons> oh, hmm, seems like I broke hbc on my x86 too.
20:29:45 <allbery_b> haven't done a heck of a lot else; not much to program for at home, and work stuff generally needs to be perl (or occasionally ruby)
20:30:11 <dons> i'd like some of sigfpe's code
20:30:13 <allbery_b> haskell has the difficulty at work that we have a signficant Solaris presence
20:30:18 <dons> i bet that touches on funny bits of things
20:30:38 <dons> allbery_b: oh? ghc has been working on solaris for a while (though moderately unmaintained)
20:30:46 <dons> we use it on a massive solaris box in berlin
20:30:59 <allbery_b> I was under the impression, from looking athe bug list, that it was moderately broken
20:31:04 <allbery_b> and definitely unmaintained
20:31:10 <dons> don't think its broken.
20:31:19 <allbery_b> and I'm neither enough of a ghc hacker or enough of a SPARC hacker to fix
20:31:20 <dons> we built ghc 6.6 two days ago on solaris
20:31:25 <dons> ah sparc/solaris
20:31:25 <allbery_b> huh
20:31:37 <dons> hang on, yes, its a sparc/solaris we built  on
20:31:40 <allbery_b> yes, all our installed Solaris is SPARC
20:31:43 <dons> 40 cpus and all.
20:31:45 <allbery_b> hm
20:31:54 <dons> rl has been contributing patches to the native code gen for sparc as well
20:32:04 <allbery_b> maybe I'll see if I can bring 6.6 up on zaphod and see if it's useful
20:32:14 <dons> yeah, if you can find a binary to bootstrap from?
20:32:14 <mgsloan> dons - why'd you post that forth as Haskell DSL to reddit? It's not even a monad!
20:32:32 <allbery_b> although I think my coworkers will kill me if I push any Haskell code into support/maint/config :)
20:32:41 <Nafai> No way!  An article about Haskell on Reddit that isn't about Monads?
20:32:54 <dons> mgsloan: oh good point.
20:33:03 <dons> we need a Forth monad
20:33:05 <dons> to wrap up the stack
20:33:17 <dons> then we could get continuations in Forth for free
20:33:33 <mgsloan> yeah, and he's overall pretty nooby.  Says he can't understand exactly how it works, and says that if he does something wrong it spews undecipherable errors
20:33:37 <mgsloan> yep
20:33:52 <dons> mgsloan: ah ell. Cale's comment salvages the article
20:34:04 <dons> despite the content, the idea is nice.
20:34:11 <dons> hopefully someone decides to do a proper job
20:34:14 <mgsloan> definitely
20:34:21 <mgsloan> I was actually thinking about this lately
20:34:22 <dons> that was more my motivation
20:34:25 <dons> just to put forward the idea
20:34:41 <mgsloan> not as a monad, but that stack languages do make a great minimal syntax
20:35:13 <Zeroth404> there's gotta be a less sugary way of getting caffine
20:35:18 <dons> yeah, so an easy DSL.
20:35:18 <Zeroth404> a cold way
20:35:22 <dons> Zeroth404: espresso?
20:35:39 <mgsloan> and if you could make a stack language that could modify how the language works... you could get tiny interpreter implementations
20:35:47 <Zeroth404> dons: too much work
20:35:53 <Cale> Iced espresso :)
20:36:11 <mgsloan> (tiny bootstrap interpreter impls)
20:36:17 <Zeroth404> doesnt really help the lactose intolerant people ;-)
20:36:27 <dons> Zeroth404: soy milk?
20:36:27 <mgsloan> the code that modifies itself enough to be a decent language might be monstrous
20:36:30 <Zeroth404> lol
20:36:31 <sorear> @go Forth DSL
20:36:34 <lambdabot> http://www.pamforthpilates.com/
20:36:34 <lambdabot> Title: Pam Forth Pilates Studio of Ottawa
20:36:34 <Zeroth404> espresso with soy milk
20:36:40 <sorear> dons: wher?
20:36:42 <dons> well, a iced latte or something
20:36:51 * sorear thinks to check planet
20:36:59 <mgsloan> I should code it to relearn monads
20:37:02 <dons> sorear: the forth article?
20:37:05 <Cale> When I was in 1st year, I'd get those chocolate covered coffee beans (with meal plan money!) and pull all nighters. I eventually became really sick of them.
20:37:07 <sorear> yea
20:37:09 <Zeroth404> I just dont want to end up with diabetes because I needed to stay awake ;-)
20:37:09 <dons> sorear: http://programming.reddit.com/goto?id=17q98
20:37:12 <lambdabot> Title: Forth as a Haskell DSL, or Lambda: The Ultimate Stack?  Perpetual Weekend
20:37:17 <dons> sorear: can you do a better job, in less time, with more monads? ;-)
20:37:42 <dons> Zeroth404: when doing my honours thesis, for the last 36 hours i drank 1 espresso every 2 hours
20:37:47 <dons> for the entire last 36 hours
20:37:58 <dons> that worked somewhat
20:38:00 <Zeroth404> doesnt seem like much
20:38:10 <Zeroth404> I'd do 1 cup every 30 minutes
20:38:21 <Zeroth404> s/cup/shot
20:38:24 <dons> but you would die after a while. there's a matter of being able to function as well
20:38:42 <Zeroth404> well, how much caffine is too much?
20:38:46 <sorear> dons: I had a better idea
20:38:49 <sorear> ten grams
20:38:49 <Zeroth404> if its too much, then you're too awake to need anymore
20:38:54 <sorear> says wikipedia
20:39:03 <mgsloan> caffiene doesn't really wake you up
20:39:06 <mgsloan> at that point
20:39:09 <sorear> @googe Orders of magnitude weight
20:39:11 <lambdabot> http://hypertextbook.com/physics/foundations/orders-magnitude/
20:39:11 <lambdabot> Title: Orders of Magnitude
20:39:13 <allbery_b> when you start feeling odd pains in your joints, it's time to stop.  (early signs of caffeine overdose)
20:39:14 <sorear> @googe Orders of magnitude mass
20:39:16 <lambdabot> http://en.wikipedia.org/wiki/1_E-25_kg
20:39:17 <mgsloan> just poisons you
20:39:20 <Zeroth404> heard soem kid hada heart attack after drinking a crap load of energy drinks. was only like 16 or something
20:39:28 <mgsloan> only?
20:39:34 * allbery_b has triggered that a fw times, since he seems to be more or less immune to caffeine's "pick up" effect
20:39:46 <mgsloan> I know a kid that's practically clinically addicted to energy drinks
20:39:56 <allbery_b> (I won't claim it doesn't have cardiovascular effects but I don't sense those)
20:40:07 <sorear> wow, I see it's gone now
20:40:26 <sorear> at one point "lethal dose of caffine" was listed on the orders of magnitude page
20:40:34 <sorear> so out of place it was memorable
20:40:35 <Zeroth404> mgsloan: after a while of consuming a consistent level of caffine, I'm sure you gain a tollerance
20:41:01 <mgsloan> like any other drug, yes
20:41:05 <Zeroth404> a heroic dose
20:42:13 <Zeroth404> I'm probably entirely immune to the level of caffine in a couple of sodas
20:42:17 <sorear> dons: oh, yeah, my system is much better than DollerForth
20:42:23 <sorear> dons: eg mine has loop
20:42:34 <mgsloan> sorear - you been doing a stack lang monad?
20:42:40 <sorear> no wait it doesn't
20:43:05 <sorear> mgsloan: no, just a Random Old Idea
20:43:11 <mgsloan> ah
20:43:58 <mgsloan> It's actually probably just as easy to do a stack-lang string interpreter as it is to do a stack-lang monad
20:44:56 <Nafai> dons: Weren't you going to implement a sub-set of Factor in Haskell?
20:45:31 <dons> yeah, tossing around the idea
20:45:33 <dons> just need time
20:45:42 <nmessenger> mgsloan: not quite a string interpreter, but embedded in Haskell functions: http://programming.reddit.com/info/17q98/comments
20:45:43 <lambdabot> Title: Forth as a Haskell DSL (reddit.com)
20:46:03 <mgsloan> i know
20:46:43 <mgsloan> what's worse is that brands itself as forth, and doesn't even have anything to do with forth, except that it's stack based
20:47:24 <mgsloan> and it isn't quite domain specific, more just embedded
20:47:30 <Cale> Haha, "The Keynote XML format is so bad that it isn't merely an embarrassment to Apple, it actually makes baby Jesus cry."
20:47:43 <mgsloan> though that could be interpreted to mean that it runs on microcontrollers
20:47:53 <Cale> Forth is the canonical stack language.
20:48:01 <mgsloan> true
20:48:14 <nmessenger> no, False!
20:48:24 <nmessenger> @google false programming language
20:48:25 <nmessenger> :P
20:48:26 <lambdabot> http://wouter.fov120.com/false/
20:48:27 <lambdabot> Title: Wouter's False page
20:48:29 <mgsloan> hehe
20:50:34 <sorear> ayhi is basically gonna be a cross between haskell and forth
20:50:56 <sorear> all the implementation elegance of forth, all the user friendliness of haskell
20:51:05 <sorear> like the latter, it'll be 15 years late :)
20:51:49 <Nafai> sorear: URL?
20:52:05 <dons> @quit updates
20:52:14 <nmessenger> yay updates!
20:52:27 <mgsloan> oh, crazy, that reddit forth doesn't even use a stack....
20:52:31 <nmessenger> @bot startup
20:52:32 <Cale> @whatsnew
20:52:37 <mgsloan> just uses parameters
20:52:40 <Cale> :)
20:52:44 <lambdabot> :)
20:52:49 <nmessenger> :D
20:52:50 <lambdabot> Unknown command, try @list
20:52:53 <allbery_b> > maxBound :: Int
20:52:56 <mgsloan> :O
20:53:04 <nmessenger> :3
20:53:04 <dons> ok. lambdabot2 in the #haskell.lang channels is now exactly just lambdabot
20:53:06 <lambdabot>  2147483647
20:53:09 <dons> that's the main thing.
20:53:12 <allbery_b> hrm
20:53:12 <dons> so it should stay up to date
20:53:15 <dons> ?version
20:53:20 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
20:53:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:53:30 <dons> nmessenger, no, its not amd64 bot.
20:53:39 <dons> the benchmark machine really isn't free for this at the moment.
20:53:44 <nmessenger> er, allbery_b: ?
20:53:48 <sorear> @join freenode2:#haskell must confirm
20:53:58 <dons> allbery_b: it needs to stay unloaded while we run tests and such
20:54:00 <sorear> @listservers
20:54:00 <lambdabot> freenode
20:54:06 <dons> sorear: no, its two separate instances
20:54:13 <dons> not the one, with 2 joins
20:54:28 <dons> seems reasonable to distribute the load a bit
20:54:36 <dons> ?temp
20:54:38 <sorear> agreed.
20:55:52 <dons> ?temp
20:55:53 <lambdabot>   now 29.1, min 22.7, max 29.6, rain 0.0mm, wind 18km/h SE
20:56:04 <nmessenger> :O!!
20:56:08 <dons> not useful to anyone but me. its actually the first lambdabot plugin I wrote, and i never merged it in
20:56:08 <nmessenger> @help temp
20:56:09 <lambdabot> Local temperature
20:56:15 <dons> thought it was about time to do so.
20:56:21 <dons> its just the temp in my suburb :-)
20:56:21 <nmessenger> local as in whomever says @temp?
20:56:29 <dons> but feel free to modify it to be a bit more generic
20:56:38 <allbery_b> heh.  someone over on irc.perl.org:#haskell was wondering about a more generic one
20:56:51 <ivanm> dons: is it off a weather site or from sensors on your computer?
20:56:57 <ivanm> @temp
20:56:57 <lambdabot>   now 29.1, min 22.7, max 29.6, rain 0.0mm, wind 17km/h SSE
20:57:00 <dons> ivanm, from the bom, in canterbuy
20:57:03 <allbery_b> sadly the bot there is kinda broken
20:57:14 <dons> there's a irc.perl.org:#haskell ?
20:57:16 <ivanm> dons: the bom? what is the bom?
20:57:30 <dons> bom.gov.au :-)
20:57:36 <allbery_b> hm, thought I @tewll'd you about it a few days ago,m since they were asking for a lambdabot instance
20:57:42 <dons> http://www.bom.gov.au
20:57:42 <allbery_b> they have a broken one currently
20:57:42 <lambdabot> Title: Home Page - Bureau of Meteorology
20:57:51 <dons> allbery_b: oh hmm.
20:58:00 <allbery_b> it's intended for parrot / p5 devs who want to learn haskell
20:58:03 <dons> they want an instance of this lambdabot to connect to irc.perl.org?
20:58:05 <dons> ok. hmm.
20:58:08 <ivanm> dons: Oh, for some reason I was thinking canterbury in the UK :s
20:58:10 <dons> should I join and talk to them about it?
20:58:13 <allbery_b> not enormously active as yet
20:58:13 <dons> who's there?
20:58:24 <dons> and why don't they hang out here and learn from us?
20:58:35 <allbery_b> so far it's mostly #perl6 folks, but not completely
20:58:46 <dons> ok.
20:59:28 <allbery_b> the parrot devs (who hang out n irc.perl.org instead of freenode:#perl6 for the mosr part) have become somewhat interested in haskell via pugs
21:01:34 <sorear> oh joy :/
21:01:46 <sorear> I set a precedent :(
21:02:08 <sorear> server:#channel was never intened to stick :)
21:02:18 <sorear> @botsnack
21:02:18 <lambdabot> :)
21:05:09 <mgsloan> ah, now i see why he didn't use a stack... lol
21:15:29 <Gwern> huh. how does one take a list of things and replace all entries of thinga with thingb? strangely enough neither the prelude nor hoogle turned up anything. am I missing something very obvious?
21:15:53 <Cale> map (\x -> if x == a then b else x)
21:16:43 <Gwern> Cale: I wouldn't have any problem rolling my own, but it seems odd to me it's missing
21:16:52 <Gwern> isn't it a basic and obvious thing to want to do with a list?
21:16:53 <dons> > let change 'x' = '#' ; change c = c in      map change "abcxdefhaskxekdlxx"
21:16:54 <lambdabot>  "abc#defhask#ekdl##"
21:17:04 <Cale> It doesn't seem to come up all that often, strangely enough.
21:17:10 <Gwern> really?
21:17:18 <dons> and its a map with a one line helper function anyway
21:17:58 <dons> > replace a b xs = map (\x -> x == a then b else x) xs  in    replace 'x' '#' "abcxdefhaskxekdlxx"
21:17:59 <lambdabot>  Parse error
21:18:17 <nmessenger> if
21:18:18 <Cale> let
21:18:19 <dons> > let replace a b xs = map (\x -> x == a then b else x) xs  in    replace 'x' '#' "abcxdefhaskxekdlxx"
21:18:19 <lambdabot>  Parse error
21:18:30 <Cale> yeah, and if
21:18:35 <dons> heh
21:18:48 <dons> > let replace a b xs = map (\x -> if x == a then b else x) xs  in    replace 'x' '#' "abcxdefhaskxekdlxx"
21:18:48 <lambdabot>  "abc#defhask#ekdl##"
21:19:07 * nmessenger slaps dons with a syntax guide
21:19:53 <Cale> > let replace a b x = if a == x then b else x in map (replace 'x' '#') "abcxdefhaskxekdlxx"
21:19:55 <lambdabot>  "abc#defhask#ekdl##"
21:19:58 <dons> though with H' lambda patterns, (\x | x == a -> b | otherwise -> c)
21:20:00 <dons> iirc
21:20:27 <sorear> dons: is @let easily fixable?
21:20:29 <sorear> @let x = 2
21:20:30 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:20:35 <dons> yeah, i think so
21:20:44 <dons> its just not spotting some output from popen
21:20:51 <dons> something changed in Text.Regex, iirc
21:20:58 <Cale> That syntax seems sort of okay, but also sort of odd.
21:20:59 <dons> (bad Chris)
21:21:13 <sorear> ok, my cmdline framework looks like it will be able to parse tar's options
21:21:13 <Cale> (the guards in lambdas thing)
21:21:47 <sorear> even oldstyle tar xvf foo
21:21:56 <sorear> maybe not easily...
21:22:01 <Gwern> list <- mapM (\x -> mapM (\y -> if y == "_" then " " else y)) $ liftM words $ readFile "article-list.txt" --another dratted type mismatch
21:22:26 <Cale> why mapM?
21:22:35 <Cale> hmm
21:22:49 <nmessenger> Gwern: if you don't want to deal with IO, draw out the String from readFile, then use pure functions.
21:22:50 <Cale> it should be an ordinary map inside the liftM
21:23:07 <Cale> indeed.
21:24:05 <Zeroth404> my_length [] = 0; my_length (x:xs) = 1 + my_length xs
21:24:12 <Zeroth404> what the heck does the x:xs mean?
21:24:19 <dons> ?src []
21:24:19 <lambdabot> data [] a = [] | a : [a]
21:24:26 <jcreigh> Zeroth404: it's a pattern match on a list.
21:24:32 <dons> on the : constructor for lists
21:24:36 <nmessenger> "a list with 'x' as the head, and 'xs' as the tail"
21:24:39 <dons> > 1 : [2]
21:24:40 <lambdabot>  [1,2]
21:24:42 <Zeroth404> jcreigh:  whats the pattern?
21:24:49 <Zeroth404> ah
21:24:51 <nmessenger> xs is pronounced "exes"
21:24:55 <dons> (x:xs) matches the head and the tail of the list
21:25:02 <sorear> darcs, tar, catch_1, YMake, lambdabot  <-can  maybecan't-> src yhc
21:25:07 <nmessenger> as in plural x
21:25:08 <Zeroth404> so it could have just been (foo:bar) ?
21:25:09 <dons> so (x:xs) pattern, applied to [1,2] binds x = 1 and xs = [2]
21:25:14 <nmessenger> Zeroth404: yep
21:25:14 <dons> yes
21:25:16 <Zeroth404> yay
21:25:28 <dons> it just binds variables to the fields of the data structure you match on
21:25:46 * Zeroth404 is on page 31 of yaht
21:25:49 <dons> > (\(x:y:z:rest) -> y) "hasklel"
21:25:50 <lambdabot>  'a'
21:26:01 <nmessenger> if list were defined: "data List a = Nil | Cons a (List a)" then the patterns would be "f Nil = ...; f (Cons x xs) = ..."
21:26:56 <dons> pattern matching on data structures is absurdly powerful
21:27:02 <nmessenger> ':' is an infix constructor.  Have you learned about pattern-matching for arbitrary datatypes yet?
21:27:04 <dons> and something missing just about everywhere else.
21:30:18 <sorear> muahaha. I think my command line parsing ideas will work.  Time to write code.
21:30:40 <Gwern> (eek. now my code has a stack overflow. oy. so it's correct but way too inefficient)
21:31:35 <Zeroth404> (if p x) is the same as (if p == x) ?
21:31:51 <dons> nope, if p x == True
21:32:03 <dons> p(x) == True, for funny syntax fans ;)
21:32:07 <Zeroth404> but p is being checked against x, right?
21:32:18 <dons> p is applied to x, the result inspected
21:32:45 <dons> > if not False then "yes" else "no"
21:32:47 <lambdabot>  "yes"
21:32:55 <dons> > if not(False) == True then "yes" else "no"
21:32:56 <lambdabot>  "yes"
21:32:57 <Zeroth404> just seems like it would try to multiply p by x
21:33:09 <Zeroth404> p(x) seems like p * x
21:33:27 <dons> it does? doesn't that look like function application to you?
21:33:35 <dons> > toUpper 'x'
21:33:37 <lambdabot>  'X'
21:33:41 <dons> > toUpper('x')
21:33:42 <lambdabot>  'X'
21:33:49 <dons> > toUppe                                       r((('x')))
21:33:50 <lambdabot>   Not in scope: `r'
21:33:58 <mgsloan> so a stack monad would be like a state monad with a continuation function value?
21:33:58 <dons> oops
21:34:25 <Zeroth404> > 5 6
21:34:26 <lambdabot>   add an instance declaration for (Num (t -> a))
21:34:26 <lambdabot>     In the expression: 5 6
21:34:26 <lambdabot>  ...
21:34:31 <Zeroth404> > 5(6)
21:34:32 <lambdabot>   add an instance declaration for (Num (t -> a))
21:34:32 <lambdabot>     In the expression: 5 (6)...
21:34:36 <Zeroth404> > 5 *6
21:34:38 <lambdabot>  30
21:34:44 * Zeroth404 gets smarter
21:34:53 <mgsloan> hehe
21:35:10 <Zeroth404> > (5(5))
21:35:10 <nmessenger> f x is "apply the x argument to the f function"
21:35:10 <lambdabot>   add an instance declaration for (Num (t -> a))
21:35:11 <lambdabot>     In the expression: (5 (5...
21:35:14 <Zeroth404> > (5+(5))
21:35:15 <lambdabot>  10
21:35:18 <nmessenger> 5 isn't a function
21:35:30 <Zeroth404> yea, I'm just playin
21:35:38 <nmessenger> right-o :)
21:35:56 <mgsloan> he was seeing if we have juxtaposed multiplication, which wouldn't be so surprising
21:35:59 <nmessenger> use /msg lambdabot and go nuts :D
21:36:02 <Zeroth404> its reminiscent of Tcl, where each function is just a command with arguments separated by whitespaces
21:37:37 <nmessenger> actually, f x y in your usual imperative language would be (f(x))(y) -- i.e. "pass x into f, result in a function.  Pass y into that function"
21:38:07 <nmessenger> but you needn't really worry about such things yet ;)
21:38:47 <mgsloan> > (5+) 5
21:38:49 <lambdabot>  10
21:38:58 <mgsloan> better yet,
21:39:03 <mgsloan> > (+5) 5
21:39:04 <lambdabot>  10
21:39:33 <mgsloan> > map (+5) [1,2,3,4]
21:39:35 <lambdabot>  [6,7,8,9]
21:39:43 <nmessenger> (+5) 5 --(desugar)--> (\x -> x + 5) 5 --(beta-subst)--> 5 + 5 --(eval)--> 10
21:39:47 <Zeroth404> > (+) 5 5
21:39:49 <lambdabot>  10
21:40:02 <Zeroth404> > (+) 5 5 (ord '6')
21:40:02 <mgsloan> that too
21:40:03 <lambdabot>   add an instance declaration for (Num (Int -> a))
21:40:03 <lambdabot>     In the expression: (+)...
21:40:03 <nornagon> > map ($ 5) $ map (+) [1,2,3,4]
21:40:04 <lambdabot>  [6,7,8,9]
21:40:05 <nornagon> blah.
21:40:14 <mgsloan> hehe
21:40:20 <nmessenger> > (+) ((+) 5 5) (ord '6')
21:40:21 <lambdabot>  64
21:40:27 <nornagon> oh.
21:40:29 <sorear> dons: It would be quite easy to add support for data definitions, type synonyms, instances, etc in @let, and I think it could be useful for demonstrations.  obviousely some checking would be needed (no instances of Ix), but I would consider it worth it.
21:40:31 <nornagon> it worked for me :P
21:40:31 <Zeroth404> > (+) (5) (5) (ord '6')
21:40:32 <lambdabot>   add an instance declaration for (Num (Int -> a))
21:40:32 <lambdabot>     In the expression: (+)...
21:40:34 <Zeroth404> hmm
21:40:39 <nornagon> er.
21:40:41 <dons> sorear: and recursive newtypes
21:40:41 <nornagon> too many arguments!
21:40:44 <mgsloan> + is binary
21:40:45 <dons> which cause ghc to diverge
21:40:48 <nmessenger> (+) takes two parameters
21:40:49 <nornagon> > sum [5, 5, (ord '6')]
21:40:50 <lambdabot>  64
21:40:56 <dons> sorear: but yes, it might be worth it
21:41:03 <dons> just for data, and type
21:41:07 <sorear> anyone got a good name for a Haskell option-parsing lib?
21:41:10 <nornagon> > foldr1 (+) [5,5,(ord '6')]
21:41:12 <lambdabot>  64
21:41:16 <dons> hop?
21:41:20 <dons> well, that's taken
21:41:20 <sorear> dons: actually in this case I want instance :)
21:41:24 <dons> ah
21:41:35 <dons> hoptoit
21:41:36 <sorear> instance Num (a -> b) to be exact
21:41:47 <sorear> is that a name? :)
21:41:52 <dons> HopToIt
21:42:12 <dons> yeah, i was having funny dreams about overloaded numeric literals
21:42:13 * sorear is still getting ambiguous parse errors
21:42:18 <dons> and why we haven't exploited them for evil tricks
21:42:37 <sorear> I still don't dream haskell anything :/
21:43:17 <sorear> HopToIt --> "Name my lib \"HopToIt\"" | "Implement @let hackery and send a patch" ?
21:45:28 <sorear> M(onadic)O(ption)P(arsers) ?
21:45:34 <sorear> Mop!
21:46:43 <sebell> MOP's taken :P
21:46:54 <dons> see, how fun would:
21:46:56 <dons> *Main> 1 :: [Char]
21:46:56 <dons> "1"
21:46:56 <dons> *Main> 1 + 2 :: [Char]
21:46:56 <dons> "122"
21:46:58 <dons> *Main> 1 * 2 :: [Char]
21:47:01 <dons> "1212"
21:47:04 <dons> be :)
21:47:15 <dons> *Main> -1 :: [Char]
21:47:15 <dons> ""
21:47:23 <nmessenger> evil!  I cast thee out!
21:47:25 <ivanm> how does 1*2 become 1212?
21:47:37 <dons> we really don't exploit polymorphic numeric literals enough
21:47:57 <dons> *Main> 42 - 12 :: [Char]
21:47:57 <dons> "444444444444444444444444444444444444444444"
21:47:59 <sorear> dons: what did you mean by HopToIt?
21:48:01 <dons> hehe
21:48:11 <dons> just random scripting fun, ivanm:
21:48:12 <dons> instance Num [Char] where
21:48:13 <dons>     xs + ys = xs ++ ys
21:48:13 <dons>     xs - ys = xs \\ ys
21:48:13 <dons>     xs * ys = concat [ x : [y] | x <- xs, y <- ys ]
21:48:14 <dons>     fromInteger n = replicate (fromIntegral n) (head . show $ n)
21:48:22 <nmessenger> :O
21:48:29 <ivanm> lol
21:48:41 <dons> eat that, perl!
21:49:15 <ivanm> still, for 1*2, wouldn't it just be 12?
21:49:19 <greentea> i was expecting 1 * 2 to come out like Perl5's "1" x 2.
21:49:20 <nmessenger> methinks fromInteger = show -- would be slightly more sane.
21:49:27 <sorear> @let instance Num [Char] where  ...  -- I want this!
21:49:27 <lambdabot>  Parse error
21:49:30 <dons> sure. you can probably think up some useful instances
21:49:33 <ivanm> oh, wait, replicate... didn't see that
21:49:58 <sorear> sebell: what is Mop?
21:49:58 <dons> there's most likely a *useful* encoding of strings as numeric literals in there somwhere
21:49:59 <emu> > cycle "fizzbuzz"
21:50:01 <lambdabot>  "fizzbuzzfizzbuzzfizzbuzzfizzbuzzfizzbuzzfizzbuzzfizzbuzzfizzbuzzfizzbuzzfiz...
21:50:09 <dons> yeah, maybe as fizz buzz strings
21:50:33 <sorear> bijective base 1114111!
21:50:46 <nmessenger> @wn bijective
21:50:47 <lambdabot> No match for "bijective".
21:50:56 <nmessenger> @web1913 bijective
21:50:57 <sorear> @google Bijective numeration
21:50:57 <lambdabot> No match for "bijective".
21:50:59 <lambdabot> http://en.wikipedia.org/wiki/Bijective_numeration
21:51:01 <Zeroth404> > fibo n = fibo (n-2) + fibo (n-1); fibo 2
21:51:02 <lambdabot>  Parse error
21:51:16 <sorear> my wikipedia run for yesterday was productive :)
21:52:00 <fantasma> > let fibo n = fibo (n-2) + fibo (n-1) in fibo 2
21:52:02 <sorear> @freshname
21:52:03 <lambdabot> Haem
21:52:05 <lambdabot> Terminated
21:52:14 <allbery_b> > let fibo 0 = 1; fibo 1 = 1; fibo n = fibo (n - 2) + fibo (n - 1) in fibo 2 -- like this, Zeroth404
21:52:15 <lambdabot>  2
21:52:30 <Zeroth404> ah
21:52:42 <Zeroth404> > fibo n = fibo (n-2) + fibo (n-1) in fibo 2
21:52:43 <lambdabot>  Parse error
21:52:57 <fantasma> you need let and a base case
21:52:58 <Zeroth404> > fibo n = fibo (n - 2) + fibo (n - 1) in fibo 2
21:52:58 <lambdabot>  Parse error
21:53:11 <allbery_b>  @run wants expressions; you can't do top-;level defs, you must use let ... in
21:53:17 <allbery_b> > let fibo 0 = 1; fibo 1 = 1; fibo n = fibo (n - 2) + fibo (n - 1) in fibo 2 -- like this, Zeroth404
21:53:18 <lambdabot>  2
21:53:25 <Zeroth404> allbery_b: yeah I got that
21:53:36 <Zeroth404> > let fibo n = fibo (n - 2) + fibo (n - 1) in fibo 2
21:53:38 * sorear resorts to pwgen
21:53:40 <lambdabot> Terminated
21:53:47 <fantasma> now you need a base case
21:53:55 <nmessenger> sorear: why bijective?  why not plain base 1114111?
21:53:58 <allbery_b> that's also included in my example
21:53:59 <Zeroth404> didn't really want to put in the 0 and 1 :-)
21:54:16 <allbery_b> without the base case it'll go past 0 and 1 into the negatives and xcmpute forever (or untul LB times it out)
21:54:21 <Zeroth404> > let fibo 0 = 1; fibo 1 = 1; fibo n = fibo (n - 2) + fibo (n - 1) in fibo 2
21:54:23 <lambdabot>  2
21:54:28 <Zeroth404> ooh
21:54:34 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in show fiblist
21:54:36 <lambdabot>  "[0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:55:34 <Zeroth404> why isn't 'let' needed in all but the first "declaration" ?
21:55:37 <nmessenger> > fix $ (0:) . (1:) . ap (zipWith (+)) tail
21:55:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:55:47 <nmessenger> fix++
21:55:51 <sorear> I need a name for this option-processing lib :)
21:56:24 <nmessenger> @pretty let x = 1; y = 2 in 3
21:56:25 <lambdabot>  i = let x = 1
21:56:25 <lambdabot>          y = 2
21:56:25 <lambdabot>        in 3
21:56:47 <nmessenger> = let {x = 1; y = 2} in 3
21:57:50 <fantasma> its like an if statement
21:58:04 <fantasma> its over only when you say its over (in)
21:59:27 <nmessenger> > let evens = 0 : map (+1) odds; odds = map (+1) evens in odds -- also mutually recursive, a favorite example of Cale's :)
21:59:29 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
22:00:22 <fantasma> > filter even [1..]
22:00:24 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
22:00:29 <fantasma> > filter odd [1..]
22:00:31 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
22:00:57 <nmessenger> but that doesn't demonstrate mutual recursion :P
22:01:09 <fantasma> maybe not :)
22:01:35 <Zeroth404> let mult a 0 = 0; mult 0 b = 0; mult a 1 = 1; mult 1 b = 1; mult a b = a + a + mult a (b-1) in 5 6
22:01:52 <Zeroth404> > let mult a 0 = 0; mult 0 b = 0; mult a 1 = 1; mult 1 b = 1; mult a b = a + a + mult a (b-1) in 5 6
22:01:53 <lambdabot>   add an instance declaration for (Num (t -> a))
22:01:53 <lambdabot>     In the expression:
22:01:53 <lambdabot>      ...
22:02:12 <nmessenger> in mult 5 6 ?
22:02:23 <Zeroth404> > let mult a 0 = 0; mult 0 b = 0; mult a 1 = 1; mult 1 b = 1; mult a b = a + a + mult a (b-1) in mult 5 6
22:02:24 <fantasma> > let mult a 0 = 0; mult a b = a + mult a (b-1) in mult 5 6
22:02:25 <lambdabot>  51
22:02:26 <lambdabot>  30
22:02:32 <fantasma> hehe
22:02:33 <Zeroth404> er?
22:02:37 <Zeroth404> why'd I get two?
22:02:47 <fantasma> 2nd one was mine
22:02:50 <nmessenger> yours and fantasma's
22:02:50 <Zeroth404> o
22:03:18 <fantasma> you have too many base cases
22:03:22 <nmessenger> also your isn't multiplication :P
22:03:22 <Zeroth404> well, there are a lot of base cases in mine...is there something "wrong" with that?
22:03:23 <fantasma> you only need one ;)
22:03:54 <Zeroth404> might it save execution time?
22:04:10 <Zeroth404> > 0 * 4
22:04:11 <fantasma> no, but it will give you the correct answer
22:04:11 <nmessenger> negligibly, if at all
22:04:11 <lambdabot>  0
22:04:19 <Zeroth404> > 5 / 0
22:04:21 <lambdabot>  Infinity
22:04:25 <Zeroth404> odd
22:04:30 <fantasma> yah
22:04:33 <fantasma> that should return null
22:04:37 <nmessenger> > 5 / (0.0000001)
22:04:39 <lambdabot>  5.0e7
22:04:45 <fantasma> > null
22:04:46 <Zeroth404> imho, it should return 5 :-)
22:04:46 <lambdabot>  Add a type signature
22:04:48 <nmessenger> > 5 `div` 0
22:04:49 <lambdabot>  Exception: divide by zero
22:04:58 <nmessenger> fantasma: null [] = True
22:04:58 <Zeroth404> haha
22:05:07 <sorear> > minBound `div` (-1::Int)
22:05:09 <lambdabot> Terminated
22:05:23 <fantasma> > null []
22:05:24 <sorear> intel strikes again
22:05:25 <lambdabot>  True
22:05:30 <fantasma> > null [1]
22:05:32 <lambdabot>  False
22:05:33 <cakoose> Is there a library function I can use to compile a ".hs" file and return an object that I can call functions on?
22:05:49 <allbery_b> @where hs-plugins
22:05:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
22:06:01 <nmessenger> cakoose: that'd require a compiler, see ghc-api or hs-plugins
22:06:02 <fantasma> @src null
22:06:03 <lambdabot> null []     = True
22:06:03 <lambdabot> null (_:_)  = False
22:06:13 <dons> cakoose: yeah, hs-plugins does exactly that
22:06:18 <dons> > 1+2 -- example in action
22:06:19 <lambdabot>  3
22:06:22 <dons> cakoose: grab the darcs repo version
22:06:23 <fantasma> @src div
22:06:23 <lambdabot> Source not found. Are you on drugs?
22:06:31 <sorear> cakoose: hs-plugins is much higher level.  don't use ghcapi unless you have no other option.
22:06:32 <fantasma> i wish
22:06:35 <cakoose> Hmm... I must have missed it.  Thought hs-plugins only loaded ".o" files.
22:06:44 <dons> it compiles them too
22:06:48 <dons> using 'make "Foo.hs"'
22:06:50 <fantasma> @src (+)
22:06:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:06:58 <dons> giving you a handle onto a .o file to laod
22:07:00 <cakoose> dons: ok cool
22:07:25 <cakoose> Was also wondering if there were an existing text templating library for Haskell
22:07:37 <nmessenger> like TH?
22:07:37 <dons> templating in what sense?
22:07:39 <sorear> dons: is hs-plugins intended to be ghc only, or will it try to support other implementations if another one ever becomes capable of dynamic loading?
22:07:44 <cakoose> Like the Perl Template Toolkit
22:07:49 <sorear> dons: I hope you can parse that :)
22:07:50 <dons> sorear: it could support others, yes.
22:08:04 <dons> cakoose: which does what, you'll have to clue us in :-)
22:08:07 <fantasma> > 3*13 + 1
22:08:10 <lambdabot>  40
22:08:31 <sorear> dons: but is it intended to?  of course it can be ported, but I know a lot of people are allergic to #ifdef
22:08:32 <dons> string pretty printing? xml/html markup?
22:08:47 <dons> sorear: its  portable if the FFI interface to the linker is duplicated
22:08:48 <allbery_b> given a string, expand variables and/or snippets of code within it
22:09:00 <dons> ah yes. ok. there's a demo module, let me find it.
22:09:01 <cakoose> allbery_b: yeah
22:09:11 <dons> though usually one would use Text.PrettyPrint
22:09:11 <cakoose> Support for XML/HTML would be nice.
22:09:12 <nmessenger> string interpolation?
22:09:12 <allbery_b> I do custmized ones in perl fairly regularly
22:09:41 <allbery_b> it's a little more than just string interpolation since there's usually some form of eval / code execution involved
22:09:42 <Zeroth404> ?types sub
22:09:45 <lambdabot> Not in scope: `sub'
22:09:48 <Zeroth404> yay
22:09:49 <dons> for all your library needs check haskell.org
22:09:50 <cakoose> nmessenger: yes, string interpolation.  Hopefully something that's good with HTML
22:09:53 <dons> but here's a quick module , http://www.cse.unsw.edu.au/~dons/code/icfp05/tests/unit-tests/VariableExpansion.hs
22:09:55 <lambdabot> http://tinyurl.com/tpkn7
22:10:01 <allbery_b> presuably he wants something that supports embedded haskell expressions
22:10:05 <dons> it does "foo ${FOO} bar" interpolatoin
22:10:13 <dons> ah, then use Text.PrettyPrint
22:10:27 * allbery_b *really* can't type tonight, and not just because it's Purim (don't drink that much for many reasons)
22:10:32 <dons> hsep ["foo", some expression, "bar"]
22:10:56 <nmessenger> there's also Printf
22:10:59 <dons> ?docs Text.PrettyPrint
22:10:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint.html
22:11:10 <dons> is the perferred method for text generation
22:11:16 <dons> there are similar libs for XML, html, and so on
22:11:29 <dons> for small jobs you might use Text.Printf
22:11:38 <sorear> @docs Control.Monad
22:11:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
22:11:55 <nmessenger> Zeroth404: sub?  subtract?
22:11:57 <cakoose> dons: Maybe I can just make do with an XML parser and some custom code that goes in and replaces some tags.
22:12:25 <dons> yeah, possibly. then look at HaXml or HXT
22:12:34 <dons> available from hackage.haskell.org, and the haskell.org libraries page
22:12:54 <dons> what's the input format?
22:12:55 <dons> text?
22:13:05 <dons> or you're generating text with variable names repalced with haskell values?
22:13:17 <cakoose> dons: ok thanks.  I really should figure out how Haskell packaging works.  I have a not-very-robust Makefile that I currently use to include code from library dependencies.
22:13:28 <dons> oh. don't do that. use cabal
22:13:41 <dons> all modern haskell libraries come with cabal package info
22:14:03 <dons> you run the setup script, it builds and registers the package, and you just use --make to use it
22:14:17 <dons> using a Makefile is so 2002 ;)
22:14:21 <cakoose> dons: Registers it globally?  Does that work if I don't have root?
22:14:32 <dons> you can register locally
22:14:37 <dons> runhaskell Setup.hs install --user
22:14:44 <cakoose> Sounds good
22:15:20 <cakoose> Does my final executable end up being statically linked or dynamically linked to its dependencies?
22:15:34 <dons> statically linked
22:15:59 <fantasma> anyone here into project euler?
22:16:03 <dons> so no need to write makefiles at all for haskell programs these days
22:16:09 <dons> just write a foo.cabal file for your project
22:16:22 <Zeroth404> nmessenger: sub as in substitute:
22:16:23 <dons> plenty of examples on hackage.haskell.org
22:16:23 <Zeroth404> > let sub a b [] = []; sub a b [h:t] = if a h then b : sub a b t else h : sub a b t in sub 'b' 'y' "aaabaab"
22:16:25 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
22:16:25 <lambdabot>       Expected...
22:16:30 <cakoose> dons: ok thanks
22:16:38 <sorear> cakoose: also check out mkcabal
22:16:42 <sorear> @where mkcabal
22:16:42 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/mkcabal
22:17:00 <dons> needs a bit of work though.
22:17:00 <cakoose> dons: btw, I'm just writing some code so that I don't have to reproduce boilerplate HTML on every page on my website.
22:17:08 <sorear> cakoose: the interface is rather counterintuitive, but it works great once you can figure out how to use it
22:17:12 <dons> ah ok. xhtml then might be the way to go
22:17:21 <dons> that's what I use for html generation, e.g. http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
22:17:22 <lambdabot> Title: nobench: Haskell implementation shootout
22:17:34 <dons> docs here, http://haskell.org/ghc/docs/latest/html/libraries/xhtml/Text-XHtml.html
22:17:36 <lambdabot> http://tinyurl.com/24c32h
22:17:45 <nmessenger> > let sub x y = map (\z -> if z==x then y else z) in sub 'c' '#' "acbacacb"
22:17:47 <lambdabot>  "a#ba#a#b"
22:17:59 <Zeroth404> nmessenger: trying to not use map
22:18:05 <dons> you write things like:       (table $ concatHtml $ [ tr (td (toHtml s)) | s <- arch ])
22:18:14 <dons> to generate a nice html table
22:18:44 <allbery_b> Zeroth404: I think you wanted (h:t) instead of [h:t]
22:19:07 <allbery_b> > let sub a b [] = []; sub a b (h:t) = if a h then b : sub a b t else h : sub a b t in sub 'b' 'y' "aaabaab"
22:19:08 <lambdabot>  Couldn't match expected type `a -> Bool'
22:19:19 <nmessenger> a == h
22:19:25 <allbery_b> yeh
22:19:36 <allbery_b> > let sub a b [] = []; sub a b (h:t) = if a == h then b : sub a b t else h : sub a b t in sub 'b' 'y' "aaabaab"
22:19:37 <lambdabot>  "aaayaay"
22:20:01 <Zeroth404> aaah. theres an == in there
22:20:07 <Zeroth404> thought if didnt use thta
22:20:19 <allbery_b> sure it does
22:20:35 <allbery_b> if can use any predicate:  a == b, isUpper a, etc.
22:20:38 <nmessenger> if (expr1) then (expr2) else (expr3)
22:20:39 <allbery_b> anything that produces a Bool
22:20:44 <fantasma> anyone fimiliar with the Collatz problem
22:20:54 <nmessenger> expr1 has type Bool, expr2 and expr3 have the same type
22:20:54 <sorear> yeah
22:20:57 <sorear> fantasma: yes
22:21:13 <Zeroth404> why did my original not work?
22:21:20 <Zeroth404> > if 1 1
22:21:21 <lambdabot>  Parse error
22:21:26 <Zeroth404> > if 1 1 then 1 else 0
22:21:27 <lambdabot>   add an instance declaration for (Num (t -> Bool))
22:21:28 <lambdabot>     In the predicate expr...
22:21:38 <nmessenger> Zeroth404: you were trying to pass h to the 'a' function.
22:21:47 <Zeroth404> theres an a function?
22:21:54 <fantasma> sorear, if I want to find a number n < 1000000 that will produce a longest chain, is it feasible to try and run through all chains for all n?
22:22:00 <allbery_b> also, [a:b] has type [[x]] where a and b are both type x
22:22:15 <nmessenger> let sub a b (h:t) = ... -- that's where a is defined, but it isn't a function
22:22:18 <allbery_b> (a:b) is type [x] where a ad b are both type x
22:22:40 <sorear> fantasma: try it and see.  I assume you're not using Windows?
22:22:42 <allbery_b> (a:b) is pattern matching on lists, using the list constructor (:)
22:22:55 <sorear> fantasma: (since ^C is b0rked with GHC on that platform)
22:22:57 <allbery_b> a will be the head of the list and b its tail
22:23:05 <fantasma> sorear, no wonder!!!
22:23:11 <fantasma> damn it
22:23:17 <fantasma> i need to get back on debian :(
22:23:40 <narain> sorear: it is? darn, i'm glad i switched
22:23:56 <nmessenger> narain: also no name completion :'(
22:24:01 <allbery_b> IIRC it's fixed in HEAD
22:24:08 <allbery_b> (that is, ,ghc 6.7)
22:24:09 <sorear> narain: As I hear.  No windows experience in 3 years, and proud of it.
22:24:23 <Zeroth404> strings are tuples?
22:24:27 <sorear> no, lists
22:24:32 <allbery_b> and if there's a 6.6.1 release it will be fixed there
22:24:32 <nmessenger> type String = [Char]
22:24:37 <Zeroth404> then why did [] not work and () did?
22:24:49 <fantasma> i imagine it will take 0.1 seconds to compute large chains so...
22:24:50 <allbery_b> because it's a pattern match; the parentheses are just for grouping
22:24:52 <nmessenger> [h:t] = ((h:t):[])
22:25:01 <Zeroth404> oh man
22:25:10 <Zeroth404> can't believe I didn't see that
22:25:12 <allbery_b> using [] instead caused haskell to expect it to be embedded in *another* list
22:25:27 <allbery_b> hence the complaint about trying to create the infinite type t = [t]
22:25:28 <fantasma> > 1000000 * 0.1 / 60 / 60
22:25:30 <lambdabot>  27.77777777777778
22:25:35 <fantasma> 27 hours
22:25:35 <narain> fantasma: looking at mathworld it looks like all chains for n < 10000 are < 300 length
22:25:39 <fantasma> good
22:26:12 <fantasma> @google collatz
22:26:14 <lambdabot> http://en.wikipedia.org/wiki/Collatz_conjecture
22:26:17 <nmessenger> that's actually closer to 28 ;)
22:26:30 <fantasma> :-!
22:27:14 <mwc> What's the voodoo for using an STUArray from within a ReaderT Int (ST s) monad?
22:27:29 <bd_> lift (operation)
22:27:32 <bd_> eg,
22:27:34 <fantasma> wow the collatz fractal is nice
22:27:35 <mwc> hmmm.
22:27:37 <bd_> v <- lift (readArray a i)
22:27:41 <mwc> That's what I've done...
22:28:07 <narain> fantasma: hey that's cool
22:28:47 <mwc> Oh, that's what I did in all but one place
22:28:53 <Zeroth404> what exactly is a module?
22:29:04 <mwc> Hhahaha, same error message, diff't line no, thought it was the same error in the same place
22:29:24 <mwc> Zeroth404, basically, it's similar to a C++ namespace
22:29:29 <narain> fantasma: you may find the graph of chain length vs. n on mathworld useful
22:29:41 <narain> http://mathworld.wolfram.com/CollatzProblem.html
22:29:42 <lambdabot> Title: Collatz Problem -- from Wolfram MathWorld
22:29:44 <Zeroth404> thats simple enough
22:29:45 <narain> or at least interesting
22:30:03 <allbery_b> @where yaht
22:30:04 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
22:30:14 <allbery_b> Zeroth404: read ^^^ that
22:30:22 <Zeroth404> theres a lot of little things YAHT doesn't go over, or at least not until they've already been used in examples long before explanation
22:30:29 <Zeroth404> allbery_b: I am :-)
22:30:29 <fantasma> calculating a millions chains would take a week =\
22:30:38 <allbery_b> @where metatutorial
22:30:38 <lambdabot> I know nothing about metatutorial.
22:30:40 <Zeroth404> I'm on page 32
22:30:41 <allbery_b> hm
22:31:32 <allbery_b> then you should take notes on the stuff it's giving you in the wrong order, so we can fix it
22:31:46 <Zeroth404> allbery_b: for example, it didn't explain what a module was (yet) and hasn't (yet) gone over the type..thing... (like forall a b. a -> b....)
22:32:04 <allbery_b> well, forall is technically an extension
22:32:27 <Zeroth404> it would have been nice to know /exactly/ why if statements require an else
22:32:32 <Zeroth404> it didn't say specifically
22:33:02 <jcreigh> Zeroth404: because there's no side effects, it doesn't make sense to have an if without an else
22:33:14 <fantasma> or an if without a then ;)
22:33:31 <allbery_b> if p then t else e --> case p of { True -> t; False -> e } -- I think this is defined in the Haskell98 Report
22:34:10 <allbery_b> but in any case, if is an expression, so it must produce a value,, so you must specify values for it to produce whether p is true or false
22:34:29 <allbery_b> > 3 + if isUpper 'a' then 5 else 9
22:34:31 <Zeroth404> jcreigh: I like to think of it as the function if must retun /something/
22:34:31 <lambdabot>  12
22:34:42 <narain> Zeroth404: think of it as C's  cond ? expr1 : expr2
22:34:45 <Zeroth404> s/if/\'if\'/
22:35:24 <narain> Zeroth404: yes, exactly
22:35:36 <fantasma> how long do you think it takes to do 3n+1 one trillian times
22:36:10 <Zeroth404> narain: I just think that should have been said in YAHT
22:36:36 <mwc> @pl lift $ foo a i f
22:36:37 <lambdabot> lift (foo a i f)
22:36:54 <mwc> does @pl know about standard monad functions?
22:37:11 <fantasma> trillan = 12 zeros?
22:37:26 <ivanm> I think so
22:37:31 <nmessenger> there are no points for @pl to remove
22:38:01 <narain> fantasma: yes. also, trilli*o*n
22:38:08 <Zeroth404> can a function have the same exact name as a module ?
22:38:11 <fantasma> > let p = map (\x -> 3 * x + 1) [1..10^12]
22:38:11 <lambdabot>  Parse error
22:38:13 <mwc> ugh, I was hoping I could do something nicer.
22:38:14 <fantasma> > let p = map (\x -> 3 * x + 1) [1..10^12] in p
22:38:16 <lambdabot>  [4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,79...
22:38:25 <mwc> Zeroth404, nope, a functoin has a lowercase name. A module has an Uppercase name
22:38:26 <sorear> you know your haskell code is complicated when
22:38:26 <fantasma> trillion
22:38:28 <sorear> Indent cycle (17)...
22:39:05 <fantasma> > let p = last $ map (\x -> 3 * x + 1) [1..10^12] in p
22:39:07 <sorear> fantasma: a 2GHz P4, under optimal conditions, can do six billion operations in a second, or a trillion operations in about three minutes.
22:39:09 <lambdabot> Terminated
22:39:23 <fantasma> > let p = maximum $ map (\x -> 3 * x + 1) [1..10^12] in p
22:39:27 <lambdabot> Terminated
22:39:34 <fantasma> lambabot fails
22:39:37 <ivanm> 10^12 is too big for lambdabot to handle
22:39:52 <sorear> esp. since your code is far from optimal enough
22:39:52 <fantasma> > 10^12
22:39:54 <wkh> i saw a code snippet in a paper that looks like:
22:39:54 <lambdabot>  1000000000000
22:39:56 <wkh> count w = (>>=print) . liftM (length . filter (==w) . words) . readFile
22:40:03 <nmessenger> @help run
22:40:04 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
22:40:07 <nmessenger> time limited
22:40:09 <wkh> how would you convert that to do-notation?
22:40:12 <ivanm> fantasma: also, the list is probably too long
22:40:24 <ivanm> > let p = maximum $ map (\x -> 3 * x + 1) [1,10^12] in p
22:40:26 <lambdabot>  3000000000001
22:40:29 <nmessenger> @redo \w -> (>>=print) . liftM (length . filter (==w) . words) . readFile
22:40:30 <lambdabot> \ w -> (>>= print) . liftM (length . filter (== w) . words) . readFile
22:40:42 <nmessenger> @. redo unpl \w -> (>>=print) . liftM (length . filter (==w) . words) . readFile
22:40:43 <lambdabot> \ w e -> do { a <- (liftM (\ k -> length (filter (\ b -> b == w) (words k))) (readFile e)); print a}
22:40:45 <ivanm> @help redo
22:40:46 <lambdabot> redo <expr>
22:40:46 <lambdabot> Translate Monad operators to do notation.
22:41:03 <sorear> wkh: count w = do { text <- readFile ; print $ length $ filter (==w) $ words text }
22:41:10 <allbery_b> @. pretty . redo unpl \w -> (>>=print) . liftM (length . filter (==w) . words) . readFile
22:41:11 <lambdabot> "Parse error" at column 1
22:41:16 <sorear> er
22:41:26 <sorear> wkh: count w name = do { text <- readFile name ; print $ length $ filter (==w) $ words text }
22:41:35 <sorear> @ty \ w name = do { text <- readFile name ; print $ length $ filter (==w) $ words text }
22:41:38 <lambdabot> parse error on input `='
22:41:40 <sorear> @ty \ w name -> do { text <- readFile name ; print $ length $ filter (==w) $ words text }
22:41:43 <lambdabot> String -> FilePath -> IO ()
22:41:48 <allbery_b> @. pretty . redo unpl count w -> (>>=print) . liftM (length . filter (==w) . words) . readFile
22:41:49 <lambdabot> "Parse error" at column -17
22:41:55 <allbery_b> *blink*
22:41:58 <fantasma> that's my mission for tomorrow: generate all of the collatz chains for [1..1000000]
22:42:02 <nmessenger> allbery_b: lambda!
22:42:05 <sorear> @pretty count w name = do { text <- readFile name ; print $ length $ filter (==w) $ words text }
22:42:06 <lambdabot>  count w name  = do text <- readFile name
22:42:06 <lambdabot>                     print $ length $ filter (== w) $ words text
22:42:22 <allbery_b> it was the column -17 that got me
22:42:38 * nmessenger didn't notice that before :O
22:42:43 <allbery_b> @. pretty . redo unpl count w = (>>=print) . liftM (length . filter (==w) . words) . readFile
22:42:44 <lambdabot> "Parse error" at column -17
22:42:48 <allbery_b> heh
22:42:48 <sorear> @pretty count w name = do { text <- readFile name ; let matches = filter (==w) $ words text ; print (length matches) }
22:42:49 <lambdabot> "Parse error" at column 110
22:42:51 <wkh> why would you have to change from using . to $?
22:42:59 <sorear> @pretty count w name = do { text <- readFile name ; let { matches = filter (==w) $ words text } ; print (length matches) }
22:43:00 <lambdabot>  count w name  = do text <- readFile name
22:43:00 <lambdabot>                     let matches = filter (== w) $ words text
22:43:00 <lambdabot>                     print (length matches)
22:43:13 <sorear> wkh: readable? :)
22:43:19 <wkh> i wanted to do count w file = do {f <- readFile file; len <- liftM(length . filter (==w) . words) f; putStrLn len}
22:43:25 <sorear> @seen beschmi
22:43:25 <lambdabot> I saw beschmi leaving #haskell, #darcs, #haskell-blah and #ghc 4d 15h 48m 51s ago, and .
22:43:26 <wkh> but i got a type error that i couldn't figure out
22:44:11 <wkh> and in case if you've seen John Hughes' paper on arrow which is where that code snippet comes from, yes i am stuck on the first page
22:44:16 <allbery_b> you don't need to liftM with the <-
22:44:18 <wkh> arrows
22:44:26 <allbery_b> and thus you use let instead of <- on the second line
22:44:33 <Zeroth404> > read "67"
22:44:34 <lambdabot>  67
22:45:00 <Zeroth404> > chr ['6','7']
22:45:01 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
22:45:08 <nmessenger> > read "Just (Left 'f', Right [1,2,3])"
22:45:10 <lambdabot>  Exception: Prelude.read: no parse
22:45:10 <Zeroth404> > fold chr '0' ['6','7']
22:45:11 <lambdabot>   Not in scope: `fold'
22:45:16 <Zeroth404> > foldl chr '0' ['6','7']
22:45:17 <lambdabot>  Couldn't match expected type `b -> Int'
22:45:24 <narain> Zeroth404: do you mean map?
22:45:33 <narain> > map chr ['6','7']
22:45:34 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
22:45:36 <Zeroth404> dun think so
22:45:38 <narain> oh wait
22:45:44 <nmessenger> > read "Just (Left 'f', Right [1,2,3])" :: Maybe (Either Char (), Either () [Int])
22:45:46 <lambdabot>  Just (Left 'f',Right [1,2,3])
22:46:01 <allbery_b> ord instead of chr?
22:46:13 <Zeroth404> > foldl orf '' ['6','7']
22:46:14 <lambdabot>  Improperly terminated character constant
22:46:17 <Zeroth404> > foldl ord '' ['6','7']
22:46:18 <lambdabot>  Improperly terminated character constant
22:46:20 <wkh> in the do notation, you don't need liftM because the syntactic sugar does the necessary conversion?
22:46:23 <Zeroth404> if I spell it right
22:46:30 <narain> > map ord ['6','7']
22:46:32 <lambdabot>  [54,55]
22:46:38 <allbery_b> the <- pseudo-op unwraps it
22:46:42 <Zeroth404> thats about what I expected
22:46:51 <allbery_b> so f is effectively no longer an IO String
22:46:57 <narain> > map ord "67"
22:46:59 <lambdabot>  [54,55]
22:47:05 <allbery_b> that's what makes do-notation handy
22:47:15 <wkh> how does it unwrap?
22:47:23 <nmessenger> > foldr ((:) . f) [] "67"
22:47:24 <lambdabot>   Not in scope: `f'
22:47:29 <wkh> i tried to find a simple example of using the mutable hash table library in haskell
22:47:32 <nmessenger> > foldr ((:) . ord) [] "67"
22:47:33 <allbery_b> @undo x <- f
22:47:33 <wkh> and it gave me back a monad
22:47:34 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 3}) "Parse error"
22:47:34 <lambdabot>  [54,55]
22:47:35 <wkh> i didn't know wtf to do
22:47:42 <allbery_b> @undo do x <- f
22:47:42 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
22:47:48 <narain> do {f <- action; expr}  becomes  action >>= \f -> expr
22:47:49 <allbery_b> sigh
22:47:50 <nmessenger> @undo do {x <- xs; return x} -- wkh
22:47:50 <lambdabot> xs >>= \ x -> return x
22:47:51 <Zeroth404> does a fucntion take up more memory each time it is recursed?
22:47:51 <narain> afaik
22:47:52 <allbery_b> I should be in befd
22:48:15 <dons> Zeroth404: tail recursive calls are 'gotos', so no, they're just loops
22:48:22 <ivanm> allbery_b: then go to bed ;)
22:48:23 <dons> if you however write something not tail recursive, you keep values on the stack
22:48:29 <sorear> @quote ghc expl
22:48:30 <lambdabot> ghc says: Can't represent explicit kind signatures yet
22:48:32 <sorear> @quote ghc explo
22:48:33 <lambdabot> ghc says: My brain just exploded.
22:48:37 <Zeroth404> dons: tail recursive?
22:48:48 <sorear> my ghc just gave that second error!
22:49:02 <nmessenger> congrats sorear!
22:49:06 <wkh> tail recursion is where no computation remains to be done when you hit the base case
22:49:12 <sorear> /home/stefan/mop/System/Console/MOP.hs:30:62:
22:49:12 <sorear>     My brain just exploded.
22:49:12 <sorear>     I can't handle pattern bindings for existentially-quantified constructors.
22:49:16 <wkh> usually that involves passing along an "accumulator variable"
22:49:31 <allbery_b> do x <- v; f x --> v >>= \x -> f x -- the x there is not monadic but f must re-wrap its result in the monad
22:49:32 <Zeroth404> makes sense
22:49:48 <Zeroth404> does haskell *always* do that?
22:49:49 <narain> Zeroth404: e.g. fact n = n * fact (n-1)  is not tail recursive because you have to multiply by n after the recursive call
22:49:54 * allbery_b starts weekly backup and goes to bed
22:49:56 <Korollary> Does anyone have a cabal test hook example?
22:49:59 <nmessenger> Zeroth404: yes, always
22:50:20 <nmessenger> Zeroth404: make sense, that is :P
22:50:22 <wkh> scheme also guarantees that tail recursive calls will be compiled efficiently
22:50:46 <Zeroth404> then fact must pass on a variable to be evaluated later....when the whole argument is complete?
22:50:55 <Zeroth404> s/argument/...some bettter word
22:51:23 <fantasma> everyone import module 'Complex' and type this into your interpreter: ``let w = 100; h = 34 in putStr[(".-~^,:=+rcfkwO*H8#B@$"!!).(`div`5).length.take 100.takeWhile((<100).magnitude).(\x->iterate((+x).(^2))x)$(3*x/w-2):+(2*y/h-1)|y<-[0..h],x<-[0..w]]''
22:51:51 <narain> Zeroth404: generally you pass along a partially computed result as another argument
22:52:05 <narain> Zeroth404: and return it when you hit the base case
22:52:39 <sorear> Where should I report "My brain just exploded."? :: Maybe (Either MailingList Trac)
22:52:41 <fantasma> > 238 / 2
22:52:43 <Zeroth404> I believe a C function which recurses just created another "child function" and consumes more resources each iteration
22:52:43 <lambdabot>  119.0
22:52:52 <wkh> zeroth404
22:52:54 <narain> Zeroth404: e.g. tail recursive factorial: fact 0 acc = acc; fact n acc = fact (n-1) (n*acc)
22:53:02 * wkh was about to put that
22:53:09 <narain> :)
22:53:23 <narain> > let fact 0 acc = acc; fact n acc = fact (n-1) (n*acc) in fact 6 1
22:53:24 <lambdabot>  720
22:53:49 <wkh> Zeroth404: you'd then call that with acc=1. so the tail recursive form is like an auxiliary function. very common pattern
22:54:21 <rahikkala> fantasma: That is, do that for values of w that are equal to the width of your terminal, minus one
22:54:35 <wkh> fantasma: what does that code do?
22:54:42 <fantasma> wkh, try it ;)
22:54:49 <mwc> narain, don't forget the $!
22:54:59 <Zeroth404> are non tail recursive fucntions are less efficient than the opposite?
22:55:23 <wkh> well if it's not tail recursive you run the risk of exhausting the stack. tail recursion is highly desirable
22:55:49 <mwc> Zeroth404, a tail call doesn't create a new frame, basically it can reuse the place where the calling function lived
22:55:51 <dons> > let fact 0 acc = acc; fact n acc = fact (n-1) (n*acc) in fact 100 1
22:55:51 <narain> mwc: where?
22:55:52 * Zeroth404 didn't know stacks could be exhausted
22:55:53 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
22:55:57 <dons> > let fact 0 acc = acc; fact n acc = fact (n-1) (n*acc) in fact 1000 1
22:55:58 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
22:56:11 <wkh> a tail recursive function will be mechanically transformed into something like a for loop
22:56:27 <mwc> narain, fact (n - 1) $! (n * acc)
22:56:36 <fantasma> > let w = 119; h = 42 in putStr[(".-~^,:=+rcfkwO*H8#B@$"!!).(`div`5).length.take 100.takeWhile((<100).magnitude).(\x->iterate((+x).(^2))x)$(3*x/w-2):+(2*y/h-1)|y<-[0..h],x<-[0..w]]
22:56:37 <lambdabot>  <IO ()>
22:56:43 <Zeroth404> if its transformed into a loop, whats the point of originally writing it as a recursion?
22:56:51 <fantasma> > let w = 119; h = 42 in [(".-~^,:=+rcfkwO*H8#B@$"!!).(`div`5).length.take 100.takeWhile((<100).magnitude).(\x->iterate((+x).(^2))x)$(3*x/w-2):+(2*y/h-1)|y<-[0..h],x<-[0..w]]
22:56:52 <mwc> I'm certain that the strictness analyzer will do that for you, but isn't it best to be safe?
22:56:59 <lambdabot>  ".........................................-------------------------------~~,...
22:57:02 <mwc> Zeroth404, recursion is nicer to think about.
22:57:05 <wkh> keeping it recursive can make it more elegant
22:57:21 <Zeroth404> I find recursion more complicated to evaluate in my head
22:57:34 <Zeroth404> well, disregarding fence-post errors
22:57:35 <dons> its just loops :-)
22:57:43 <mwc> It's simpler if oyu only need ot think about one step at a time
22:57:44 <narain> mwc: thanks, i wasn't familiar with that
22:57:48 <sebell> Zeroth404: You need to read `The Little Schemer' :)
22:57:56 * Zeroth404 adds it to the to-read list
22:57:58 <mwc> with a loop you need to think about the pre and post conditions that go along with the loop
22:58:04 <dons> loops are recursion, after all
22:58:09 <dons> think about the asm translatoin of 'while'
22:58:25 <dons> while0 : test ; something ; jmp while0
22:58:32 <Zeroth404> eh, I know little of asm
22:58:51 <wkh> kids thesqe days :(
22:58:56 <dons> its recursion all the way down. just for some reason you only get 1 or 2 loop forms in imperative languages.
22:59:00 <Zeroth404> though I know a tid bit about dissassembled assembly
22:59:24 <sieni> doesn't that accumulator version of fact collect a lot of thunks before computing the result? like fact 3 1 = fact 2 (3 * 1) = fact 1 (2 * 3 * 1) = fact 0 (1 * 2 * 3 * 1) = (1 * 2 * 3 * 1) = (1 * 2 * 3) = (1 * 2) = 1 ?
22:59:33 <narain> dons: goto == recursion?
22:59:35 <dons> strictness analyser
22:59:47 <dons> narain: recursion on the label you're jumping to
22:59:57 <dons> unstructured goto, maybe not ;)
23:00:05 <Zeroth404> goto is used in recursion, but it isn't necessarily so
23:00:12 <dons> i'm sure Djikstra has something to say on this matter
23:00:14 <mwc> sieni, that's what the $! takes care of
23:00:15 <fantasma> it's a recursive world
23:00:25 <narain> you *can* think of everything in terms of recursion
23:00:32 * mwc recurses at these @*#&@(*@ NaN's
23:00:37 <fantasma> Djikstra knows how to get everywhere fastest
23:00:45 <narain> it's just that i didn't see how turning loops into gotos made that point any clearer
23:01:03 <dons> turning both loops and tail calls into gotos, to illustrate its all the same stuff
23:01:29 <dons> there was earlier context on the compilation of tail recursive haskell code to a goto
23:01:49 * nmessenger waits for "Tail calls considered harmful"
23:02:00 <dons> they are, you should use combinators :-)
23:02:03 <fantasma> time to sleep eh?
23:05:16 <wkh> so i'm the only one who has a hard time understanding monads, huh
23:05:47 <nmessenger> wkh: have you been around the internets?  There's more than a few monad tutorials :)
23:05:58 <wkh> everyone else is perfectly fine with the apparent paradox of carrying out side effects in a purely functional programming language
23:06:00 <dons> hehe, guess not, http://haskell.org/haskellwiki/Blog_articles#Monads
23:06:01 <sorear> yeah, monads were so easy for me I can't understand people who DON'T understand them
23:06:01 <lambdabot> Title: Blog articles - HaskellWiki
23:06:02 <wkh> yes, i have, actually
23:06:19 <dons> they're so simple though
23:06:22 <sorear> wkh: there is no side effects because they don't happen.
23:06:33 <dons> > runState (do x <- get; put (x+1) ; return "done") 8
23:06:34 <lambdabot>  ("done",9)
23:06:40 <dons> ?undo do x <- get; put (x+1) ; return "done"
23:06:41 <lambdabot> get >>= \ x -> put (x + 1) >> return "done"
23:06:50 <wkh> i understnad that it's all sof ucking plain and simple
23:06:52 <dons> > runState (get >>= \ x -> put (x + 1) >> return "done") 8
23:06:54 <mwc> There's a time when your brain doesn't get the monads. Then something violent and irreversable happens and you hate every other language for not having monads
23:06:54 <lambdabot>  ("done",9)
23:06:57 <sorear> wkh: IO is a language for describing to the interpreter (which is NOT confined by purity) what we want to do
23:07:13 <sorear> quote?
23:07:15 <dons> now replace the implementation of >>= and 'return' and you've got a completely different evaluation strategy
23:07:37 <sorear> yay, HOF use reduced my code from 33 lines to 22
23:08:06 <nmessenger> @remember mwc There's a time when your brain doesn't get the monads. Then something violent and irreversable happens and you hate every other language for not having monads
23:08:07 <lambdabot> Done.
23:09:06 <dons> > f state = let s = state {- get _} ; s' = s + 1 {- put x+1 -} in (s', "done") {- return -}   in {- runState -} f 8
23:09:07 <lambdabot>  Parse error
23:09:17 <wkh> i can understand the Maybe monad i think
23:09:18 <dons> > f state = let s = state {- get -} ; s' = s + 1 {- put x+1 -} in (s', "done") {- return -}   in {- runState -} f 8
23:09:18 <lambdabot>  Parse error
23:09:24 <dons> > let f state = let s = state {- get -} ; s' = s + 1 {- put x+1 -} in (s', "done") {- return -}   in {- runState -} f 8
23:09:25 <lambdabot>  (9,"done")
23:09:27 <nmessenger> @quote spacesuit
23:09:28 <lambdabot> dons says: think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples.  now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
23:09:28 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
23:09:36 <dons> there you go, desugared state monad, above wkh.
23:09:50 <dons> >>= and return just hide the 'state' argument being threaded through
23:10:04 <dons> so when you write:   get >>= \x -> put (x+1) >> return "done"
23:10:21 <dons> you're really writing: let s = state ; s' = s+1 in (s', "done")
23:10:36 <dons> and the do-notation gives us sugar for >>= and return
23:10:42 <nmessenger> @src State return
23:10:43 <lambdabot> Source not found. You speak an infinite deal of nothing
23:10:43 <dons> ?redo get >>= \x -> put (x+1) >> return "done"
23:10:43 <lambdabot> do { x <- get; put (x + 1); return "done"}
23:11:14 <dons> and then you see, if you overload >>= and return to do something else, your same code:   do { x <- get; put (x + 1); return "done"} has a completely different meaning
23:11:23 <wkh> i better be able to wrie some fucking awesome programs if i can figure this stuff out.
23:11:26 <dons> the ; is >>= , but its behaviour depends on the type
23:11:32 <dons> its a programmable ;  !
23:11:34 * wkh wants a silver bullet
23:11:58 <dons> does any imperative language have a programmable ;  ?
23:12:07 <mwc> dons, sure, C.
23:12:10 <mwc> #define ; ...
23:12:13 <dons> that lets you do some arbitrary computation between each statement ?
23:12:15 <dons> hmm
23:12:17 * mwc basks in the evil
23:12:27 <dons> #define ; bindIO
23:12:38 <mwc> the problem is you can't make it contexts sensitive
23:12:42 <mwc> or can you....
23:12:53 <dons> well, that might need a um ... type system, and type classes
23:12:55 <mwc> #define bindIO(a,f) .... ;
23:13:27 <dons> wkh, so does that state example help any? or are you just being noisy? ;)
23:13:28 <mwc> replace your ; with bindIO that does something, finally ;
23:13:47 <wkh> i don't know. it's coming at me faster than i can process it. i need to paste this stuff into emacs and think about it away from irc
23:13:55 <dons> yeah
23:14:01 <dons> fire up ghci and write some code
23:14:18 <Korollary> Does anyone know how to use defaultMainWithHooks to test the code without installing it?
23:14:20 <mwc> I came to a point where I knew I needed a monad, but still didn't really understand them
23:14:25 <dons> hmm. I think "The programmable ';' " would make a good blog article ..
23:14:28 <mwc> so I just smashed my head against the wall for three days and it worked.
23:14:28 <Korollary> (in cabal that is)
23:14:40 <wkh> i'm acting under the assumption that monads and arrows would be useful for creating a code generation system
23:14:44 <dons> Korollary: hmm. I'd use darcs setpref test
23:14:46 <wkh> i want to create a domain language that targets PHP
23:14:46 <mwc> I'm dreading ever needing an arrow
23:15:00 <dons> a code generator for php, wkh?
23:15:09 <mwc> wkh, there was a guy writing an assember in a monad... for a JIT compiler
23:15:12 <wkh> i want to make a very brief, high-level DSL that generates web applications
23:15:12 <dons> so like, say, the xhtml combintors, but it builds a php AST ?
23:15:32 <mwc> wkh, once you learn haskell, look into HApps
23:15:46 <wkh> i don't want to write web code in haskell. i wnat to put PHP people out of jobs
23:16:06 <Korollary> dons: "runhaskell Tests.hs" won't be able to pick up the stuff I just built, will it?
23:16:19 <sorear> @remember wkh i don't want to write web code in haskell. i wnat to put PHP people out of jobs
23:16:19 <lambdabot> Done.
23:17:15 <dons> wkh, i think a DSL for generating php is a *great* idea
23:17:18 <wkh> there's so much duplicated code and functionality in web applications
23:17:31 <dons> you get haskell libs, haskell syntax, haskell typing, but spit out ugly old php
23:17:45 <wkh> so many common patterns: file upload. paginated listing of tabular data. listing by filter. listing a subset of attributes for data in a database etc etc etc
23:17:48 <wkh> dons: yes
23:18:11 <dons> it really could work. embedded DSLs like this are the bread and butter of haskell
23:18:15 <sorear> OMG
23:18:17 <wkh> yeah that's what i'm hoping for
23:18:24 <sorear> my command line parser isn't just a monad
23:18:24 <dons> and you might only need a simple state monad for carrying around, say, unique symbol names
23:18:30 <sorear> it's a monad transformer!!
23:18:44 * mwc shoots sorear 
23:18:48 <mwc> the madness had to stop somewhere.
23:19:06 * nmessenger shoots mwc
23:19:14 <nmessenger> don't hate on transformers
23:19:42 <wkh> exactly what makes Haskell so conducive to DSLs?
23:19:55 <wkh> higher-order functions and the liberal/free-form kind of syntax?
23:20:03 <wkh> i mean it's just highly expressive and you don't have superfluous semicolons
23:20:10 <wkh> no superfluous parentheses
23:20:18 <sorear> wkh: infix ops, higher order functions, yeah stuff like that
23:20:21 <wkh> it's highly compositional
23:20:22 <wkh> i see
23:20:27 <mwc> sorear, on the wiki, there's an article about using System.GetOpt effectively, using IO actions as the action type. I ended up having to wrap that in an ErrorT to support some stuff, so I'm sure that oit's a pretty common thing.
23:22:45 <dons> kh, the arguments are: infix operators and symbols, higher order functions and *laziness*
23:23:03 <dons> means you can write control structures that map onto the control of the language you're embedding
23:23:13 <dons> with a close-to-the-embedded language  syntax
23:23:21 <dons> so syntactica and semantics support
23:23:45 <dons> the type system doesn't hurt either
23:24:06 <dons> since you can embed the type system of the target language in haskell, and get type checking for free
23:24:07 <wkh> i don't see what laziness and the type system get you.
23:24:10 <wkh> oh
23:24:14 <wkh> that's what they get you?
23:24:20 <dons> control structures, you get from laziness
23:24:26 <dons> while p (do .... )
23:24:36 <dons> if 'while' was strict, you'd have trouble
23:24:39 <wkh> i've wanted to find an exmaple of simulating C style for loops by taking advantage of the laziness in haskell
23:24:45 <wkh> and other stuff like that
23:25:08 <dons> well, because arguments are evaluated lazily, a 'while' loop is just a normal haskell function
23:25:28 <dons> the ability to define control structures as everyday functions is pretty special
23:25:38 <dons> no need for syntax for 'while', 'for' and so on
23:25:51 <rag3> dons: you're adding nice articles to Reddit
23:25:54 <nmessenger> @oldwiki wkh, grep plusPtr
23:25:54 <lambdabot> http://www.haskell.org/hawiki/wkh, grep plusPtr
23:26:04 <nmessenger> @oldwiki QuotesPage rather
23:26:04 <lambdabot> http://www.haskell.org/hawiki/QuotesPage rather
23:26:19 <dons> rag3, i'm trying anyway
23:26:27 <rag3> dons: that's good
23:26:40 <rag3> who wrote mostly the wikibook on Haskell?
23:28:50 <mwc> @hoogle a i e -> i -> (e -> e) -> m ()
23:28:51 <lambdabot> No matches, try a more general search
23:28:58 <mwc> @hoogle (e -> e) -> m ()
23:28:59 <lambdabot> Control.Monad.State.modify :: MonadState s m => (s -> s) -> m ()
23:28:59 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
23:28:59 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
23:29:04 <nmessenger> fmap?
23:29:15 <nmessenger> are Arrays in Functor?
23:29:32 <nmessenger> er, no, you just want to change one value
23:29:37 <mwc> I was just stunned that there's no way to transform one value with a given function
23:29:44 <Korollary> @paste
23:29:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:29:53 <mwc> readArray a i >>= writeArray a i . f does the trick
23:29:58 <dons> wkh, here's a little control structure for you:
23:29:59 <dons> main = for (0, (< 10), (+1)) (
23:29:59 <dons>             print "hello"
23:30:00 <dons>        )
23:30:06 <mwc> so I had to hoogle to see if I somehow missed it.
23:30:14 <nmessenger> @type (//)
23:30:14 <dons> ok, so that's a 'for' loop, where 'for' is just a function:
23:30:16 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
23:30:18 <rag3> @pl (head . reverse) x
23:30:19 <lambdabot> head (reverse x)
23:30:21 <dons> for (i,cond,inc) body = forW i
23:30:21 <dons>     where
23:30:21 <dons>         forW i | cond i     = body >> forW (inc i)
23:30:22 <dons>                | otherwise  = return ()
23:30:30 <rag3> @pl
23:30:31 <lambdabot> (line 1, column 1):
23:30:31 <lambdabot> unexpected end of input
23:30:31 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
23:30:36 <dons> wkh, yeah, get the idea?
23:30:49 <rag3> @pl \x -> x+1
23:30:49 <lambdabot> (1 +)
23:30:54 <dons> since the 'body' is evaluated lazily, the 'for' control structure can be just a recursive function
23:31:56 <dons> i think that's pretty cute, anyway
23:32:21 <nornagon> @pl \x -> 1-x
23:32:21 <lambdabot> (-) 1
23:32:25 <nornagon> @pl \x -> x-1
23:32:26 <lambdabot> subtract 1
23:32:41 <nornagon> @src subtract
23:32:41 <lambdabot> subtract x y = y - x
23:32:47 <nornagon> @pl . src subtract
23:32:48 <lambdabot> (line 1, column 1):
23:32:48 <lambdabot> unexpected "."
23:32:48 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
23:32:57 <nornagon> @pl \x y -> y - x
23:32:58 <lambdabot> subtract
23:33:05 <nornagon> you think you're funny?
23:33:11 <nornagon> @botslap
23:33:12 <lambdabot> Unknown command, try @list
23:33:17 <nornagon> @botsmack
23:33:18 <lambdabot> :)
23:33:18 <nmessenger> I find it hilarious
23:33:27 <nmessenger> as does LB :)
23:34:21 <nornagon> @unpl (flip (-))
23:34:21 <lambdabot> (\ b c -> c - b)
23:34:23 <hpaste>  Korollary pasted "Is this how cabal test works?" at http://hpaste.org/789
23:34:27 <rag3> > x <- getLine
23:34:27 <lambdabot>  Parse error
23:34:53 <dons> > do x <- getLine ; print x
23:34:54 <lambdabot>  <IO ()>
23:35:03 <rag3> do x <- getLine
23:35:07 <rag3> hello
23:35:08 <nmessenger> > join (***) length ("(flip (-))", "subtract")
23:35:10 <lambdabot>  (10,8)
23:35:17 <rag3> > print x
23:35:18 <lambdabot>   Not in scope: `x'
23:36:30 <mwc> @pl \a b c d e f = u a b c >>= v d e >>= w f
23:36:30 <lambdabot> (line 1, column 14):
23:36:30 <lambdabot> unexpected "="
23:36:30 <lambdabot> expecting pattern or "->"
23:36:37 <mwc> @pl \a b c d e f -> u a b c >>= v d e >>= w f
23:36:39 <lambdabot> flip flip w . ((flip . ((flip . ((flip . (((.) . (>>=)) .)) .)) .)) .) . flip flip v . ((flip . (((.) . (.) . (>>=)) .)) .) . u
23:36:50 * mwc gags
23:36:59 <mwc> I think I'll just stick with my cruddy 7 parameter function
23:37:00 <sorear> @quote flip
23:37:01 <lambdabot> Cale says: Also, I want people to write things using (.) instead of repeated ($) because of my hidden agenda to flip the associativity of ($)
23:37:03 <sorear> @quote flip
23:37:04 <lambdabot> Cale says: Also, I want people to write things using (.) instead of repeated ($) because of my hidden agenda to flip the associativity of ($)
23:37:08 <sorear> @quote flip.str
23:37:08 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
23:37:30 <rag3> what's the difference between (.) and ($)?
23:37:37 <dons> ?src (.)
23:37:38 <lambdabot> (.) f g x = f (g x)
23:37:41 <dons> ?src ($)
23:37:41 <nmessenger> i dunno (flip flip w . ((flip . ((flip . ((flip . (((.) . (>>=)) .)) .)) .)) .) . flip flip v . ((flip . (((.) . (.) . (>>=)) .)) .) . u) seems readable to me :D
23:37:41 <lambdabot> f $ x = f x
23:37:55 <dons> one is function composition, the other is function application
23:38:02 <sorear> @unpl (flip flip w . ((flip . ((flip . ((flip . (((.) . (>>=)) .)) .)) .)) .) . flip flip v . ((flip . (((.) . (.) . (>>=)) .)) .) . u)
23:38:03 <lambdabot> (\ at f i l o r -> ((u at f i) >>= (v l o)) >>= (w r))
23:38:05 <dons> > toUpper $ 'x'
23:38:06 <lambdabot>  'X'
23:38:09 <dons> > toUpper . 'x'
23:38:10 <lambdabot>  Couldn't match expected type `a -> Char'
23:38:20 <dons> > toUpper . id $ 'x'
23:38:21 <lambdabot>  'X'
23:38:23 <rag3> I'm familiar with the composition operator
23:38:26 <sorear> wow, unpl did a good job
23:38:36 <nmessenger> sorear: surprising
23:38:39 <rag3> but why do you do f $ x, can't you just do f x?
23:38:44 <dons> ?redo (\ at f i l o r -> ((u at f i) >>= (v l o)) >>= (w r))
23:38:44 <lambdabot> (\ at f i l o r -> do { a <- (do { a <- (u at f i); (v l o) a}); (w r) a})
23:38:50 <mwc> > sin $ pi * 1
23:38:51 <lambdabot>  1.2246063538223773e-16
23:38:56 <dons> rag3, sometimes it requires too many parentheses
23:39:00 <mwc> rag3, that's why
23:39:01 <sorear> tsk. doesn't redo know the monadlaws?
23:39:09 <dons> > toUpper (id (id 'x'))
23:39:10 <lambdabot>  'X'
23:39:14 <rag3> > sin pi
23:39:15 <lambdabot>  1.2246063538223773e-16
23:39:20 <dons> > toUpper $ id $ id $ 'x'
23:39:22 <lambdabot>  'X'
23:39:40 <rag3> toUpper (id (id 'x'))
23:39:45 <rag3> > toUpper (id (id 'x'))
23:39:47 <lambdabot>  'X'
23:40:01 <nmessenger> that's a property of ($)'s fixity and low precedence
23:40:05 <rag3> ok... so if there are something like 3 or 4 parenthesis then it's easier to use $
23:40:52 <dons> yeah
23:41:01 <dons> or if one argument is a huge chunk of code
23:41:07 <mwc> I find it easier to use $ if there's just one set of ()... only need to hit shift once.
23:41:20 <rag3> are there any guidelines on the usage of $?
23:41:24 <dons> forM_ [1..100] $ \i -> do some huge thing with i
23:41:25 <mwc> which pretty much explains why I'm not an emacs user
23:41:26 <rag3> can be used and abused?
23:41:37 <nmessenger> @type liftM2 ($)
23:41:40 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
23:41:41 <dons> rag3, use . where possible, and $ where too many parens occur
23:41:48 <rag3> dons: thanks
23:42:04 <nmessenger> > liftM2 ($) [(+2), (*4)] [1,2,3]
23:42:05 <lambdabot>  [3,4,5,4,8,12]
23:42:08 <rag3> dons: can I replace every composition with . rather than double parenthesis or is it an overkill?
23:42:15 <dons> i often do.
23:42:23 <dons> f . g . h . i $ 7
23:42:45 <ivanm> dons: talking about languages on #gentoo-au, someone said: "the haskell benches on there are bs. the devs wrote unreadable code and optimised the hell out of it"
23:42:48 <ivanm> care to refute that?
23:42:50 <ivanm> ;)
23:42:50 <rag3> would be ok to do f . g $ argument
23:43:10 <dobblego> ivanm, how about "lol"? :)
23:43:19 <ivanm> yeah, I used that myself
23:43:36 <dons> ivanm, do they have an example?
23:43:38 <sorear> ivanm: does any language claim to make readable code faster than unreadable code?
23:43:42 <dons> because there's plenty of clear code there.
23:43:56 <dobblego> "readable" is relative to the observer
23:43:59 <dons> anyway, its a benchmark, its optimised to hell, and it shows you that optimised haskell code is damn fast.
23:44:05 <rag3> so basically given f . g $ arg, I save typing (f . g) arg or  f (g arg)
23:44:08 <dobblego> "that language is bullshit, because I can't read it (Chinese)"
23:44:09 <dons> that's kinda the point. the ruby guys optimsie to hell as well, but it still sucks
23:44:12 <rag3> dons: haskell code is super fast
23:44:33 <sorear> ivanm: besides, I firmly believe haskell is slow, and I still think the expressiveness makes up a thousand times over.
23:44:41 <nmessenger> rag3: they're all equivalent, use whichever you fancy.
23:44:51 <rag3> nmessenger: thanks
23:45:01 <nmessenger> also: f $ g $ arg
23:45:04 <sorear> ivanm: I would rather spend hard cash on a new computer than brain cells on C, 99% of the time.
23:45:11 <ivanm> lol
23:45:27 <rag3> sorear: have you ever used Ruby?
23:45:35 <sorear> rag3: no
23:45:37 <ivanm> they're ignoring me now, and arguing about the relative merits of ruby vs python
23:45:44 <sorear> fools
23:46:01 <wkh> i used to love participating in internte language wars
23:46:06 <wkh> i no longer care
23:46:12 <sorear> do they not realize infighting will only speed the demise of imperative languages?
23:46:56 <wkh> do you guys hate anything that isn't lazy and purely functional?
23:47:02 <sorear> they can only hope to crush us through a unity they clearly do not possess
23:47:05 <sorear> yes!!
23:47:08 <dons> ivanm, you were looking at something like, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=python ?
23:47:10 <wkh> in addition to being statically and strongly typed
23:47:10 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2deng4
23:47:12 <sorear> though even durst WONDER!?!
23:47:15 <dons> wkh, so you're just trolling now?
23:47:22 <rag3> sorear: if you did, you would think Haskell is unbelievably fast
23:47:33 <ivanm> dons: yes
23:47:45 <wkh> dons: i wans't really trying to. i appreciate you helping me and answering my questions
23:48:18 <ivanm> dons: actually just the benchmarks over all, as they were arguing over which is better, python or ruby
23:48:18 <sorear> wkh: sorry. I did not mean for my evil-plotter act to be misinterpreted so.
23:48:26 <ivanm> so I posted that link and said haskell was better
23:48:50 <dons> well, according the the benchmarks, it is for better=higher rated on the shootout :-)
23:49:01 <sorear> so, how long until stream fusion hits the shootout?
23:49:06 <ivanm> that was my point ;)
23:49:11 <dons> sorear, hmm 6.8
23:49:18 <dons> ther's some array fusion there already, sorear
23:49:26 <rag3> what's stream fusion?
23:49:30 <nmessenger> who pulls the 6.8 switch anyway?
23:49:38 <sorear> dons: what'll revcomp look like with steam fusion! :)
23:49:44 <sjanssen> nmessenger: whoever it is, I'm sure his name is Simon
23:49:52 <nmessenger> haha
23:49:55 <sorear> nmessenger: it might be Ian
23:50:02 <rag3> Simon P J?
23:50:13 <nmessenger> @quote simons
23:50:13 <lambdabot> No quotes match. Take a stress pill and think things over.
23:50:18 <nmessenger> @quote simon
23:50:18 <lambdabot> StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
23:50:25 <sorear> or Simon M (JaffaCake) or Simon Ian Lynagh (Igloo)
23:50:34 <sjanssen> sorear: heh
23:51:08 <rag3> so what is this "fusion" stuff?
23:51:32 <nmessenger> @quote simon.*title
23:51:32 <lambdabot> DougalStanton says: I'm beginning to wonder if Simon is less a name and more a title, meaning "strong in the lambda force" or somesuch. Let's hope they don't go over to the dark side ;-)
23:51:51 <sorear> @where icfp
23:51:52 <lambdabot> I know nothing about icfp.
23:52:03 <sjanssen> rag3: consider the code "filter p . map f" -- there's an intermediate data structure between the filter and the map.  Fusion seeks to combine the filter and map and eliminate the intermediate data structure
23:52:08 <sorear> @goo rewriting haskell strings
23:52:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
23:52:10 <lambdabot> Title: Rewriting Haskell Strings
23:52:17 <sorear> rag3: ^^^
23:52:33 <wkh> sjanssen: is there something in SICP about that?
23:52:46 <wkh> at least elminating inefficiency associated with heavy use of filter/map/etc
23:52:48 <sjanssen> wkh: I haven't read SICP
23:53:22 <sorear> dons: have you ever noticed that streams sans Pass allow infinite lists to be embedded in strongly normalizing system fw while keeping a guarantee of progress?  has anyone else?  is that the thesis of "codata"?
23:53:39 <rag3> sjanssen: thanks
23:58:57 <sorear> it seems the answer to my last question is "yes"
23:59:00 <sorear> google++
23:59:11 <sorear> I so love rediscovering things :/
23:59:57 <ivanm> sorear: dons is busy trying to re-convert triplah_ over on #gentoo-au ;)
