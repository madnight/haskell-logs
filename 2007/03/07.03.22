00:05:50 <dons> ?uptime
00:05:50 <lambdabot> uptime: 8d 3h 36m 3s, longest uptime: 8d 3h 36m 3s
00:07:43 <Cheery> It's surprising how tiny that state monad turns out to be without those tuples in it.
00:12:57 <hpaste>  jdrake pasted "Exercise from Wikibooks, would like thoughts" at http://hpaste.org/1082
00:13:20 <jdrake> I have a solution to one of the beginning exercises, was hoping for some thoughts on it.
00:13:56 <mauke> or (map) == any
00:14:17 <jdrake> Not sure what you mean
00:14:46 <mauke> if any (name ==) ["Simon", "John", "Phil"]
00:14:59 <jdrake> ah nice
00:15:26 <jdrake> I got a nice feeling about the solution I came up with, especially with it being this late at night (3am)
00:16:09 <jdrake> Thank you sir
00:16:33 <Cheery> well, that is nice.
00:17:00 <Cheery> I like the prompt -action myself.
00:17:13 <Cheery> It gives me intuitions on one another thing.
00:18:27 <jdrake> prompt action was fixed for me by Cale last night. I had something about 75% of what you see, just certain things like do and I had a <- action in there.
00:19:01 <jdrake> Originally it retrieved a number, but modified it for reading in a line for this particular problem.
00:20:10 <dmwit> jdrake: name `elem` ["Simon", "John", "Phil"]
00:21:19 <jdrake> In that definition, what does (Eq a) mean exactly? elem :: (Eq a) => a -> [a] -> Bool
00:21:26 <dons> hack hack hack!
00:21:39 <dmwit> It means that (==) is defined for the type.
00:21:40 <Cale> jdrake: it means that values of type a are comparable for equality
00:21:41 <dmwit> ?src Eq
00:21:41 <lambdabot> class  Eq a  where
00:21:41 <lambdabot>     (==), (/=)   :: a -> a -> Bool
00:22:02 <jdrake> Greetings cale
00:22:09 <Cale> hi
00:22:11 <mauke> jdrake: it means a must implement the Eq interface
00:22:19 <jdrake> I just can't give in to sleep without a haskell fix
00:22:49 <jdrake> My next exercise is to convert that to a case instead of an if
00:22:59 <dmwit> It doesn't look too much better.
00:23:13 <dmwit> The three "S", "J", and "P" cases are too similar.
00:23:22 <jdrake> I suspect that a good pattern match would be nice
00:23:46 <desp> man, compiling ghc takes a long time
00:23:59 <Cheery> I think it will look a bit worse.
00:24:04 <jdrake> desp, start it and then go to sleep - that is what I did
00:24:09 <Cheery> jdrake: sometimes it is good to use if then.
00:25:03 <jdrake> Actually the wikibook only does uses compare with case, so I think the author assumes too much about the student's ability to go off and find the right way.
00:25:19 <jdrake> So I think I will skip the case exercise.
00:25:57 <Cheery> cases are useful, and there's not much in them.
00:26:17 <zeeeeee> i'm trying to wrap my head around frp; it seems to basically be about processing streams of data values. how is this different from simply writing and using functions over lists of values?
00:26:35 <Cheery> case item of { cond1 -> thing1 ; cond2 -> thing2 }   etc.
00:26:43 <Cheery> @t frp
00:26:44 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
00:26:53 <hpaste>  dmwit annotated "Exercise from Wikibooks, would like thoughts" with "The cleanest pattern match I could think of" at http://hpaste.org/1082#a1
00:27:45 <jdrake> ?src compare
00:27:45 <lambdabot> compare x y | x == y    = EQ
00:27:46 <lambdabot>             | x <= y    = LT
00:27:46 <lambdabot>             | otherwise = GT
00:28:10 <jdrake> ?src EQ
00:28:11 <lambdabot> Source not found. Are you on drugs?
00:28:16 <jdrake> yes
00:28:20 <dmwit> Well, even better would be to put the (name ++ ", " ++) bit outside of greet, but... =)
00:28:23 <dmwit> :t compare
00:28:25 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
00:28:28 <dmwit> ?src Ordering
00:28:29 <lambdabot> data Ordering = LT | EQ | GT
00:28:41 <jdrake> Ok, thank you - that is what I was suspecting
00:30:04 <dolio> zeeeeee: Using a library of stream-processor combinators is more abstract than writing functions on lists?
00:30:52 <zeeeeee> dolio: certainly, but is that all there is to it?
00:31:08 <zeeeeee> i'm guessing not
00:31:19 <dolio> zeeeeee: I seem to recall that restricting things to stream processors instead of letting people handle streams directly solves space leaks, too.
00:32:00 <dolio> I'm certainly no expert on the subject.
00:32:15 <dolio> But, I mean, lists are an implementation detail.
00:33:16 <dolio> Perhaps you could, instead, implement it differently behind the scenes, if that gels better with whatever underlying toolkit you're using.
00:33:36 <dolio> While keeping the same interface on the functional end.
00:35:10 <dolio> I think the idea is that you specify the relationship between your various elements, and then the library takes care of the details of how that works for you.
00:35:23 <dolio> So it's more declarative.
00:38:50 <jdrake> Tomorrow onto recursion and pattern matching. But till then, to all a good monad!
00:48:05 <ivanm> with the bind operator for monads, does it just act as: unpack monad, apply function, re-pack monad?
00:48:31 <Cale> ivanm: no
00:48:33 <quicksilver> no
00:48:48 <quicksilver> that sounds more like fmap
00:48:50 <quicksilver> (liftM)
00:49:01 <ivanm> oh...
00:49:06 <Cale> "unpack" might not mean anything
00:49:08 <quicksilver> but even then, it's never actually possible to 'unpack/repack' quite that simply
00:49:21 <ivanm> just something to help me get my head around it...
00:49:32 <ivanm> @type (>>=)
00:49:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:49:47 <Cale> x >>= f = do { v <- x; w <- f v; return w }
00:49:49 <dons> sjanssen: i agree 1%2 is better
00:49:56 <dons> i'd also like to be able to split vertically by default...
00:49:59 <Cale> Would be one way to look at it.
00:50:01 <dons> and resize vertically
00:50:01 <quicksilver> I personally find it easier to understand join and return and fmap, ivanm
00:50:14 <sieni> ivanm: think of the list monad for example
00:50:15 <ivanm> Cale: so what does the "<-" function do?
00:50:17 <quicksilver> and then accept bind as being defined in tuerms of them
00:50:32 <Cale> It's syntax, v <- x means that v is the result of running the computation x.
00:50:33 <ivanm> I'm working my way through the haskell school of expression atm
00:50:53 <Cale> In fact, do-notation is defined in terms of bind, so this is a little circular :)
00:50:55 <ivanm> Cale: so if x is of type m a, is v of type m a or just a?
00:51:01 <Cale> just a
00:51:10 <quicksilver> there's always a trivial way to 'pack' into a monad, that's return
00:51:13 * ivanm is annoyed that the haskell school of expression uses windows-only libraries for its examples
00:51:21 <Cale> It does?
00:51:24 <ivanm> quicksilver: *nod* I get that
00:51:28 <quicksilver> but 'unpkacing'  requires something more complex (a 'computation'
00:51:42 <ivanm> Cale: its trying to teach haskell via multimedia, using some windows graphics libraries
00:52:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-SOE.html
00:52:02 <lambdabot> http://tinyurl.com/stnum
00:52:05 <quicksilver> I thought there was a SOE library which ran on any OS, but H avne't tried it
00:52:15 <Cale> I believe that works under linux too.
00:52:19 <Thunder> Does anybody know a paper describing how erlang's update of running code works?
00:52:23 <ivanm> oh, the impression I got was that SOE was windows only
00:53:42 <dons> Thunder: hmm, yes. there's a ref in the hs-plugins paper, iirc.
00:53:47 <dons> basically, they lazily relink symbols, iirc
00:53:48 <quicksilver> I thought once that if I was teaching haskell to undergrads, I'd use something openGL based as a running example
00:53:58 <dons> quicksilver: or gtk2hs. (they do at oxford)
00:53:59 <quicksilver> undergrads are impressed by such things :)
00:54:04 * quicksilver nods
00:54:11 <dons> silly kids ;-)
00:54:13 <quicksilver> at QM we weren't brave enough to teach functional programming
00:54:18 <dons> :(
00:54:24 <quicksilver> and I wasn't influential enough to change that :)
00:54:35 <ivanm> quicksilver: QM is?
00:54:52 * ivanm enjoyed the maths part of learning scheme... then again, I'm weird ;-)
00:55:07 <quicksilver> ivanm: Queen Mary, Univrsity of London
00:55:14 <ivanm> ahhh, k
00:55:20 <astrolabe> what is the maths part?
00:55:42 <Thunder> I offered the students Haskell instead of just another year of Java ... They are interested but two days later a single student urged the university to stick to the learning plans :-(
00:55:54 <ivanm> astrolabe: the beginning at least of structure and interpretation of computer programs uses a lot of maths examples
00:56:01 <ivanm> Thunder: lol
00:56:07 <quicksilver> well learning plans are there for a reason, no matter how much we may disagree with them :)
00:56:18 <astrolabe> ivanm: Ah. Thanks
00:56:28 <quicksilver> and if you're not very good at programming, an extra year in Java is more likely to increase your expected salary
00:56:34 <quicksilver> which is mostly what my students cared about
00:56:53 <Korollary> Thunder: how about scala instead?
00:57:01 <basvd> Hello, I'm making an assembly language DSEL in Haskell (just for fun) very simillar to the one from Russel O'Conner in the latest Monad.Reader. I'm trying to specify describe the various register in a CPU. So I have for example: data AX = AX (16bit) and data EAX = EAX (32bit). I would like to know statically (at type checking time) the sizes of these registers so that I can compare them for equality. What is the best way to do this? (type level na
00:57:25 <Thunder> ivanm: It was silly, because I got the course after three years and after the teacher was going. The univeristy officials told me to restart from scratch ...
00:57:33 <ivanm> Cale: I can't find SOE in hackage...
00:57:41 <ivanm> Thunder: lol
00:57:54 <ivanm> which uni you at?
00:58:01 <Thunder> www.fh-jena.de
00:58:28 * ivanm wonders why xchat won't open some urls in firefox...
00:58:30 <Thunder> I'm not a teacher, I'm a sys- and network admin at a commercial ISP.
00:58:55 <quicksilver> ivanm: it reads them first. If it doesn't approve of the content, it won't open them
00:58:57 <astrolabe> I'd prefer it if university courses were for the sake of learning rather than for the sake of improving career prospects.
00:59:09 <quicksilver> (In Soviet Russia, links follow you)
00:59:31 <ivanm> quicksilver: lol, its just the weirdest links it won't load... like the one Thunder just posted
01:00:35 <astrolabe> basvd: That structure suprises me a bit.  I would expect regesters to be variables rather than types.
01:03:16 <basvd> astrolabe: well, maybe I can use only variables with types like Reg16, Reg32, etc. But certain CPU instructions are very specific about which types of registers they can have as operands. So I think I need to have very specific types for the registers
01:03:55 <ivanm> Cale, quicksilver: from the book: "... there is no standard graphics library for Haskell yet, although there is one in popular use on Windows machines called Graphics"
01:04:04 <ivanm> looks like SOE is for windows only :s
01:05:11 <Korollary> http://www.haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-SOE.html
01:05:13 <lambdabot> http://tinyurl.com/stnum
01:06:36 <ivanm> I can't seem to find anything called "graphics" or soe on my system (using 6.6)
01:06:39 <basvd> astrolabe: I just think of something... I can have: data Reg32 and data Reg16 and a class OfSize reg size. And then instance Size EAX Reg32 and instance Size AX Reg16...
01:08:23 <astrolabe> basvd: Ah, I see, the CPU restrictions mean the choice makes sense
01:08:53 <ivanm> I take it back... it comes under hgl, not as a standalone package
01:11:43 <desp> ?seen bos
01:11:43 <lambdabot> bos is in #haskell. I last heard bos speak 3h 44m 44s ago.
01:13:33 <ivanm> so how does >> differ from >>=? And is =<< just the flipped version of >>=?
01:13:52 <quicksilver> ivanm: >> throws away the result of the computation
01:13:56 <quicksilver> ivanm: and yes
01:14:09 <mauke> a >> b = a >>= \_ -> b
01:14:12 <ivanm> quicksilver: so >> is analogous to const?
01:14:18 <quicksilver> no
01:14:23 <quicksilver> it still does the computation
01:14:24 <mauke> yes
01:14:31 <quicksilver> it just throws away the result
01:14:31 <ivanm> lol, stop confusing me!
01:14:38 <dolio> Mu.
01:14:44 * dons hacks base !
01:14:47 <ivanm> OK, a bit like $! then?
01:15:01 <mauke> (>>) a = (a >>=) . const?
01:15:16 <ivanm> I think that's the thing I want... where the first item is forced to be evaluated, whether its used or not?
01:15:27 <quicksilver> The analogy to const isn't apparent to me, shall we say :)
01:15:27 <dolio> ?pl f m n = m >>= const n
01:15:28 <lambdabot> f = (. const) . (>>=)
01:15:39 <quicksilver> ivanm: it has nothing to do with strictness
01:15:41 <ivanm> quicksilver: so >> is const with the side-effect of the computation a?
01:16:00 <quicksilver> ivanm: in a sense, yes
01:16:20 <dolio> ?pl f m n = m >>= \_ -> n
01:16:20 <lambdabot> f = (. const) . (>>=)
01:16:36 <ivanm> the analogy with strictness is that I recall seeing a function that forced the first argument to be evaluated, even if it wasn't actually used in the subsequent computations
01:18:10 <ivanm> Also, a functor is a data type that can have functions evaluated upon its contents?
01:18:12 <mauke> ivanm: flip const
01:18:26 <ivanm> didn't explain myself there to well...
01:18:30 <ivanm> mauke: for >>?
01:18:42 <mauke> yeah, const a b is a, but a >> b returns b
01:19:14 <ivanm> yeah... I didn't mean in the specifics, just in what it did
01:19:56 <ivanm> so, in the haskell school of expression, there's an example of a state-like monad Label
01:20:25 <quicksilver> I do see your point, ivanm
01:20:37 <quicksilver> but I don't think the analogy between side effects and `seq` is helpful
01:20:40 <ivanm> and they have a a function getLabel = Label (\n -> (n+1,n)) :: Label Integer
01:20:48 <quicksilver> monads still use fully lazy evaluation
01:20:52 <ivanm> quicksilver: possibly not... I meant in terms of the forced computation
01:21:01 <quicksilver> computation at different levels
01:21:16 <quicksilver> seq forces some mostly-unobservable comutation
01:21:26 <quicksilver> only observable in terms of memory profile and so on
01:21:28 <ivanm> anyway, with getLabel, they then have "do n <- getLabel" -> how is n now an integer?
01:21:39 <ivanm> quicksilver: *nod* OK
01:22:02 <quicksilver> yes
01:22:08 <quicksilver> looks like Label is a state monad?
01:22:33 <ivanm> quicksilver: its a customised version: Label a = Label (Integer -> (Integer, a))
01:23:03 <ivanm> I know State has get and put, which return the value and the state, don't they?
01:23:06 <quicksilver> yes, that's a state monad
01:23:14 <ivanm> but how does that getLabel function work?
01:23:29 <ivanm> it seems to automagically increment itself each time :s
01:23:32 <quicksilver> get and put are part of the standard state momand
01:23:39 <quicksilver> this is a custom one
01:23:39 <ivanm> *nod*
01:23:56 <quicksilver> getLabel seams to be doing 'get the state and increment it'
01:24:14 <quicksilver> i.e. it's generating fresh labels
01:24:23 <ivanm> quicksilver: yeah... but its never called with any arguments... so what value is passed in to the lambda expression?
01:24:58 <quicksilver> well the magic there is in the definition of 'bind' for that monad
01:25:06 <ivanm> oh, wait, I think I see where it could be getting the values from...
01:25:11 <quicksilver> the definition of bind takes the state from the last computation
01:25:18 <quicksilver> and gives it as a parameter to this lambda
01:25:32 <quicksilver> so 'last state' ends up bound to that n
01:26:05 <ivanm> yeah... it looks like it might be building up a big huge nested lambda function, then they pass it through an intial value of 0
01:26:07 <ivanm> that must be it
01:26:21 <ivanm> I'll have to have a play with it, rather than just reading the book
01:26:33 <quicksilver> :)
01:26:50 <quicksilver> fwiw, getLbel would be this, in the standard state monad
01:27:36 <ivanm> and this is? :P
01:27:39 <ivanm> @src this
01:27:39 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
01:27:50 <ivanm> @hoogle this
01:27:51 <lambdabot> No matches found
01:28:07 <ivanm> oh, I thought you meant this was an actual function...
01:30:03 <quicksilver> getLabel = do {old_n <- get; put (old_n + 1) ; return old_n }
01:30:09 <quicksilver> sorry, bit laggy here :)
01:30:33 <ivanm> lol, that's OK
01:30:50 <ivanm> @src get
01:30:50 <lambdabot> Source not found. Wrong!  You cheating scum!
01:30:59 <ivanm> @type get
01:31:01 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
01:31:56 <ivanm> @hoogle get
01:31:57 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
01:31:57 <lambdabot> Text.ParserCombinators.ReadP.get :: ReadP Char
01:31:57 <lambdabot> Text.ParserCombinators.ReadPrec.get :: ReadPrec Char
01:32:00 <quicksilver> get is \s -> (s,s)
01:32:03 <quicksilver> it pulls out the state and puts it in the value part
01:32:07 <ivanm> ahhh, that's what I was looking for
01:32:20 <ivanm> and in the state part as well? isn't it replacing both?
01:32:37 <quicksilver> well it doesn't alter the state part
01:32:41 <quicksilver> so the state stays the same
01:32:47 <quicksilver> 'get'ing the state doesn't alter the state
01:33:49 <ivanm> but how does it pull the state part out of the monad to be able to put it into the value?
01:34:12 <quicksilver> \s -> (s,s)
01:34:14 <quicksilver> like that :)
01:34:25 <quicksilver> actions in the state monad are functions which are given the state as input :)
01:34:26 <ivanm> but that's a function...
01:34:28 <quicksilver> right
01:34:33 <quicksilver> actions in the state monad *are* functions
01:34:40 <quicksilver> that's the nature of that particular monad
01:34:49 <ivanm> oh, so "get monad" = \s -> (s,s) $ monad?
01:34:58 <quicksilver> no
01:35:04 <ivanm> I'll puzzle this out later... dinner time
01:35:06 <ivanm> ttyl
01:35:08 <quicksilver> 'get' isn't a function which you apply to a pmonad :)
01:35:11 <quicksilver> get is an action
01:35:13 <quicksilver> later :)
01:35:53 <Cale> ivanm: data State s a = S (s -> (s,a))
01:36:20 <Cale> (well, something roughly equivalent to that)
01:37:16 <quicksilver> but even that is only necessary because haskell class syntax has restrictions on the 'shapoe' of things you can make into monads
01:38:01 <quicksilver> conceptually, s -> (s,a) is the monad. The other fluff is language implentation fluff.
01:39:49 <dancor> how do you do timers/events in haskell
01:40:16 <quicksilver> depends rather what you want them for :)
01:40:23 <quicksilver> probably using threads though
01:42:39 <quicksilver> threads + mvars give a reasonable abstraction for an event model
01:44:45 <quicksilver> some of the reactive programming stuff is another way of thinking about event models
01:44:49 <dancor> i want to make a game
01:45:10 <dancor> ascii tetris attack or dr mario clone i think
01:45:43 <dancor> i need things to fall every n msecs
01:46:31 <quicksilver> that probably doesn't want an event model
01:46:56 <quicksilver> that's more like a main loop which says 'do all the drawing; check time; is it time for the next block yet?'
01:47:39 <quicksilver> games are often structured around 'ticks' (sometimes a tick is a 60Hz screen refresh)
01:47:59 <quicksilver> and at each tick you 'advance' the game world and check for various randome vents
02:00:42 <dancor> is there a way to sleep until the next tick
02:04:27 <Thunder> dancor: I wrote an scheduler myself: Based on an ordered [Time, Action] list you can call threadDelay . subtract current_time . time . head $ actionlist
02:05:00 <ejt> Thunder: that's exactly what I'm about to write !
02:05:11 <ejt> any chance I could steal your code please ?
02:05:22 <Thunder> I can send you my code, if you like to cheat ;-)
02:05:42 <Thunder> Actions are "SingleShot, Repeatable, ..."
02:06:02 <Thunder> It's part of a multicast router.
02:06:12 <ejt> don't worry I'm not a student (joe dot thornber at gmail dot com)
02:09:40 <Thunder> ejt: It's in the mailqueue. Usually you have the actions described above, but there are also marked actions in order to modify the scheduling paramtaters later. I did not send Config frameword, too. Please remove this yourself.
02:10:04 <ejt> many thanks
02:30:45 <Thunder> ejt: I did this as a test implemention, I'd prefer a STM variant, but it was not available at that time.
02:30:47 <Lemmih> Are there any compilers that use protected memory as stack checks?
02:31:12 <quicksilver> dancor: short answer, yes
02:31:22 <quicksilver> Lemmih: there is 'stuff' which does that on linux, yes
02:31:35 <quicksilver> Lemmih: I don't recall if it's a compielr patch, or a libc patch, or a preload library
02:31:53 <quicksilver> Lemmih: but there's definitely some code out there which does it
02:36:14 <desp> :foldl is like foldl, but strict in the accumulator. Though actually foldl is also strict in the accumulator.:
02:36:23 <desp> s/:/"/
02:37:24 <quicksilver> do you mean fold' and fold?
02:37:29 <quicksilver> foldl'  and foldl, rather
02:37:32 <quicksilver> typoes ho!
02:37:49 <desp> the correct question to ask would be, "does the ByteString documentation mean foldl'" :)
02:37:52 <desp> and yes
02:37:53 <opqdonut> @yarr
02:37:54 <lambdabot> Swab the deck!
02:38:04 <mauke> @quote
02:38:05 <lambdabot> <erg0t> says: @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
02:38:24 <quicksilver> I thought bf was cool until I saw Piet
02:38:27 <quicksilver> but Piet is much cooler :)
02:38:35 <mauke> do you know Java2k?
02:38:41 <desp> I handed in an assignment in BF
02:38:42 <desp> ;)
02:42:21 <dolio> bf is no Shakespeare, either.
02:42:31 <ejt> Thunder: what does With do ?
02:44:22 <rjeq> is there an equivalent of words or lines for a user-defined character, or do i have to write my own code that uses break repeatedly?
02:45:17 <dolio> > break (=='c') ['a'..'f']
02:45:18 <lambdabot>  ("ab","cdef")
02:45:37 <dolio> I don't think there's anything built in.
02:45:44 <dolio> Although it's quite common.
02:46:11 <drigz> :( why not?
02:46:15 <drigz> it's silly
02:46:25 <quicksilver> drigz: yes, I've often thought it was strange
02:46:31 <kuribas> I'd like the Prelude to have unfoldLines.
02:46:39 <quicksilver> drigz: I believe it's because there are quite a few possible ways you might want it
02:46:44 <drigz> to have two specialised functions to do something and no general function. not very haskellic or haskellian or whatever
02:47:07 <quicksilver> drigz: constant delimeter, delimeter specified by a predicate, delimeter included in result, delimeter excluded from result
02:47:15 <dolio> > let unfolder _ [] = Nothing ; unfolder f xs = Just (f xs) in unfoldr (unfolder (break (=='c')) "abcdefcghi"
02:47:15 <lambdabot>  Parse error
02:47:17 <quicksilver> drigz: the way you treat repeated delimeters
02:47:34 <dolio> > let unfolder _ [] = Nothing ; unfolder f xs = Just (f xs) in unfoldr (unfolder (break (=='c'))) "abcdefcghi"
02:47:35 <lambdabot>  ["ab","","","","","","","","","","","","","","","","","","","","","","","","...
02:47:36 <quicksilver> drigz: there are a whole family of minor variations, it's not clear what the natural 'universal' method is
02:47:48 <dolio> Well, that doesn't work, I guess. :)
02:47:50 <drigz> quicksilver: i see your point
02:48:09 <drigz> words and lines actually have more differences than the delimiter
02:48:14 * quicksilver nods
02:48:27 <quicksilver> they're not idempotent, either
02:48:32 <drigz> ?hoogle readFile
02:48:33 <lambdabot> Prelude.readFile :: FilePath -> IO String
02:48:33 <lambdabot> System.Win32.File.c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
02:48:33 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
02:48:35 <quicksilver> they fold multiple whitespaces to one
02:48:44 <quicksilver> and they strip out non-standard line endings completely I think
02:48:44 <QtPlatypus> @hoggle char -> [char] -> [[char]]
02:48:45 <lambdabot> Did you mean: Char -> [Char] -> [[Char]]
02:48:54 <QtPlatypus> @hoggle Char -> [Char] -> [[Char]]
02:48:55 <lambdabot> No matches, try a more general search
02:49:28 <dolio> > let unfolder _ [] = Nothing ; unfolder f xs = Just (f xs) in unfoldr (unfolder $ second tail . break (=='c')) "abcdefcghi"
02:49:29 <lambdabot>  Exception: Prelude.tail: empty list
02:49:48 <dolio> Heh. Well, I'm done.
02:50:27 <drigz> ?hoogle String -> Integer
02:50:28 <lambdabot> No matches, try a more general search
02:50:34 <drigz> ?hoogle Strin -> Integer
02:50:34 <lambdabot> No matches, try a more general search
02:50:50 <drigz> ?hoogle Integral b => String -> b
02:50:51 <lambdabot> Prelude.error :: String -> a
02:50:51 <lambdabot> Debug.Trace.trace :: String -> a -> a
02:50:51 <lambdabot> Prelude.fail :: Monad m => String -> m a
02:51:08 <drigz> ?hoogle String -> Integral b
02:51:08 <lambdabot> No matches, try a more general search
02:51:13 <dolio> Anyhow, unfoldr with lots of functions would be handy, except those functions don't return Maybe (Result), so they can't easily be used with unfoldr.
02:51:20 <drigz> ?hoogle a -> Integral b
02:51:21 <lambdabot> No matches, try a more general search
02:51:30 <dolio> For splitting up lists, that is.
02:51:33 <desp> how would I go about using a C function to get a ByteString?  return a Ptr and construct the BS in a helper Haskell function?
02:51:45 <drigz> if anyone wants to step in and tell me how to convert a string to an integer, it'd be welcome :)
02:51:58 <dolio> > read "1234"
02:51:59 <lambdabot>  1234
02:52:38 <dcoutts> desp: there are functions for constructing ByteStrings from C strings, see the docs
02:53:29 <drigz> oh yeah
02:53:33 <drigz> thanks
02:53:35 <drigz> ?hoogle read
02:53:36 <lambdabot> Prelude.read :: Read a => String -> a
02:53:36 <lambdabot> Text.Read :: module
02:53:36 <lambdabot> Prelude.Read :: class Read a
02:53:37 <beelsebob> boo!
02:55:18 <desp> dcoutts: I see there's packCString function, which is O(n) because it needs to measure the length of the cstring.  this is unfortunate, because I already know the size on the C side
02:55:40 <dcoutts> desp: there's one for that too
02:56:37 <quicksilver> still it's O(n) with a very very small constant
02:56:41 <quicksilver> strlen is *fast*
02:56:42 <quicksilver> :)
02:56:45 <dcoutts> desp: packCStringLen
02:56:51 <drigz> > break isSpace " hello"
02:56:52 <lambdabot>  (""," hello")
02:56:55 <dcoutts> the docs even say O(1)
02:57:05 <quicksilver> strlen is orders of magnitude faster than most haskell kinds of O(n) :)
02:57:09 <quicksilver> (e.g. List.length)
02:57:19 <desp> quicksilver: sure
02:57:22 <desp> dcoutts: sorry, I missed that function
02:57:31 <dcoutts> np
02:57:48 <desp> so there's no way to build a ByteString on the C side?
02:58:15 <dcoutts> desp: hmm? not sure what you mean. A ByteString is a Haskell type not a C type.
02:58:39 <desp> right, but it's apparently possible to have C functions return some Haskell values -- no?
02:58:43 <desp> I may be mistaken
02:59:01 <dcoutts> not really, only primitive types like Int
02:59:04 <desp> ah
02:59:40 <dcoutts> desp: GHC has an api to construct Haskell values from C but it's not fun to use and it's totally non-standard
02:59:47 <desp> I see
02:59:49 <desp> thanks
03:01:34 <drigz> can i unpack the result of break like: where (h, t) = break (==d) x?
03:01:50 <mauke> I think so
03:02:13 <drigz> i'm getting a parse error atm
03:02:40 <quicksilver> drigz: that little fragment is fine
03:02:45 <quicksilver> :t break
03:02:47 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:03:01 <drigz> i think i'd screwed up the bit before actually
03:03:03 <quicksilver> drigz: parse errors in haskell are often indentation problems :( :(
03:03:55 <drigz> i hate how sometimes you need . and sometimes you need $
03:04:07 <drigz> when you're stringing together functions
03:04:47 <quicksilver> drigz: use . by preference, to compose functions
03:04:57 <quicksilver> drigz: use $ to apply a function to an argument
03:05:10 <quicksilver> like this, normally : f . g . h . i . j . k $ x
03:05:39 <quicksilver> (you could write f $ g $ h $ i $ j $ k $ x, but the . form is preferred)
03:05:48 <drigz> i find when g and h are getting other arguments it gets more complicated though
03:05:52 <drigz> and . stops working
03:06:03 <drigz> and you end up with a mix of .s and $s, and it's all very ugly
03:06:16 <drigz> and then i change them all to $s for consistency
03:06:24 <dolio> f . g a b . h c d . i . j . k $ x ?
03:06:57 <quicksilver> as dolio says
03:07:03 <quicksilver> there's no problem with g and h taking arguments
03:07:16 <dolio> Unless a, b, c or d are applications themselves.
03:07:23 <quicksilver> then you use brackets
03:07:27 <quicksilver> (parentheses)
03:07:29 <dolio> Then you, regretably, have to use parentheses.
03:07:32 * quicksilver nods
03:07:35 <quicksilver> that's OK, IMO
03:07:40 <quicksilver> I'm not allergic to parentheses
03:07:46 <dolio> :)
03:07:46 <quicksilver> it's just nice not to use too many
03:07:55 <drigz> unoh i see, if you put a $ at the end it fixes it
03:08:18 <drigz> thanks
03:08:46 <arvid> in haskell - is there a difference between a function without arguments and a variable?
03:09:03 <quicksilver> when it *does* get messy is when the 'running argument' (which is the transformed x) is not the last argument, somewhere in the pipeline
03:09:04 <int-e> yes. variables don't exist ;)
03:09:13 <quicksilver> then you need a nasty lambda expression, or a flip
03:09:15 <quicksilver> which are both ugly
03:09:20 <drigz> unrelatedly, what should i do if my code works when i hardcode a string, and stops working when i put (readFile "path") in its place?
03:09:25 <quicksilver> at that point I generally break down into sub definitions
03:09:38 <quicksilver> arvid: there is no difference between a function without arguments and a value
03:09:43 <quicksilver> arvid: which is probably what you mean :)
03:09:55 <quicksilver> int-e: yes, they do. (\x -> x+1), x is a variable
03:10:31 <arvid> quicksilver: yes - I know variable doesn't make sense
03:10:34 <mauke> drigz: look at readFile's type
03:10:39 <arvid> since you can't change it
03:10:39 <quicksilver> int-e: because it 'varies' over different calls to that function
03:10:39 <quicksilver>  
03:11:04 <drigz> mauke: i haven't put any types in my program though, shouldn't it infer the IOs?
03:11:33 <int-e> quicksilver: but it never varies within a function call. anyway, that's the point of view I was taking.
03:11:51 <quicksilver> int-e: indeed. It's still a variable though :)
03:11:58 <mauke> drigz: a string has the type String. readFile "path" has the type IO String. they're not interchangable
03:12:15 <quicksilver> int-e: in (x+1), x is a free variable and in \x . (x+1) it's a bound variable... but definitely a variable
03:12:36 <int-e> quicksilver: I won't argue. I was only half serious anyway.
03:12:41 <quicksilver> :)
03:13:22 <int-e> @quote variables
03:13:22 <lambdabot> ghc says: At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'
03:13:46 <int-e> @quote slowly
03:13:46 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
03:13:46 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
03:14:24 * quicksilver nods
03:14:29 <quicksilver> 'variable' is overloaded, that's the problem
03:14:34 <quicksilver> like almost all terms in computer science
03:14:48 <quicksilver> like those horrible arguments you get over what exactly 'closure' means
03:15:02 <quicksilver> some people think it's semantic, some people think it's an implementation technique...
03:15:35 <desp> it's that feeling you get when you finally get to 1.0
03:17:17 <desp> so it's also not possible to construct a Haskell tuple on the C side?
03:17:24 <kfish> Variable \Va"ri*a*ble\, a. [L. variabilis: cf. F. variable.]
03:17:25 <kfish>  Liable to vary; too susceptible of change; mutable;
03:17:25 <kfish>         fickle; unsteady; inconstant; as, the affections of men
03:17:25 <kfish>         are variable; passions are variable.
03:17:25 <kfish>         [1913 Webster]
03:17:55 <quicksilver> desp: can't you call the function "(,)" over the FFI?
03:17:59 <quicksilver> desp: if that's what you want
03:18:09 <desp> hmm.
03:19:34 <quicksilver> desp: I *think* the answer to your question is : there isn't a direct way of doing it with the standard FFI interface, it's possible with the GHC-specific interface but a bit of a mess
03:19:45 <desp> okay, do not want
03:19:55 <desp> I would just like to return multiple values from a C function
03:20:44 <desp> looks like Storable is the answer
03:21:12 <quicksilver> I believe the tool 'c2hs' can make a haskell API to a C struct?
03:21:18 <quicksilver> which could contain multiple values
03:21:21 <quicksilver> never done it myself
03:21:37 <desp> http://www.haskell.org/haskellwiki/FFI_Introduction says that marshalling doesn't support structs
03:21:38 <lambdabot> Title: FFI Introduction - HaskellWiki
03:22:01 <mauke> have the C function take pointers
03:23:37 <desp> mauke: that's how I would do it in pure C, right; but on the Haskell side -- the Ptr type?
03:24:38 <desp> ah.
03:24:40 <desp> ok.
03:25:00 <quicksilver> then have a little haskell-side wrapper
03:25:11 <quicksilver> which unwraps the pointers and returns them
03:25:26 <quicksilver> you could even use unsafePerformIO to make it pure, with care, I believe
03:25:31 <desp> right
03:25:38 <desp> thanks all.
03:25:40 <mauke> alloca $ \p -> c_func p >> peek p
03:25:44 <desp> think I got all the pieces now :)
03:27:09 <quicksilver> mauke: what about de-allocating?
03:27:10 <desp> :t alloca
03:27:12 <lambdabot> Not in scope: `alloca'
03:27:18 <mauke> @hoogle alloca
03:27:18 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
03:27:18 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
03:27:18 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
03:27:44 <mauke> quicksilver: it's automatic
03:27:46 <desp> hrm
03:27:46 <quicksilver> mauke: oh, is alloca a safe wrapper which deallocates
03:27:48 <quicksilver> neat
03:27:53 <quicksilver> some people are so smart :)
03:28:06 <pejo> quicksilver, what is the semantic meaning of closure?
03:28:17 <desp> @hoogle peek
03:28:17 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
03:28:18 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
03:28:18 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
03:30:23 <mauke> alloca $ \p1 -> alloca $ \p2 -> alloca $ \p3 -> liftM3 (,,) (c_foo p1 p2 p3)  -- whee
03:30:32 <mauke> except that's wrong
03:31:04 <desp> I'm struggling to follow you
03:31:18 <mauke> alloca $ \p1 -> alloca $ \p2 -> alloca $ \p3 -> do c_foo p1 p2 p3; liftM3 (,,) (peek p1) (peek p2) (peek p3)
03:31:55 <ejt> once I've installed a package with Cabal (Edion in this case), where can I find the documentation ?
03:32:02 <desp> ah.
03:32:24 <hpaste>  mauke pasted "formatted code" at http://hpaste.org/1083
03:33:50 <desp> mauke: thanks
03:34:07 <quicksilver> pejo: binding some variables in a thunk which contains free variables
03:34:15 <quicksilver> pejo: pretty much the same thing as partial application
03:36:07 <quicksilver> mauke: that alloca stuff looks a lot like the kind of thing do notation is supposed to sugar out
03:36:36 <dolio> ?type alloca
03:36:38 <pejo> quicksilver, is there an obvious reason to why they don't use partial application as term for the semantic meaning then?
03:36:38 <lambdabot> Not in scope: `alloca'
03:37:15 <quicksilver> pejo: it's to do with them coming from an imperative programming background, I think
03:41:21 <kuribas> quicksilver: does ghc do partial application?
03:41:36 <pejo> quicksilver, I'll admit that "binding free variables in a thunk" looks awfully a lot like implementation to me. But i'm not into semantics, either.
03:42:44 <quicksilver> kuribas: I'm not sure on what level to answer that question, really
03:42:52 <quicksilver> kuribas: certainly, ghc supports partial application
03:43:04 <quicksilver> kuribas: how it performs it behind the scenes I don't know :)
03:43:15 <LPhas> @where zlib
03:43:15 <lambdabot> darcs get http://haskell.org/~duncan/zlib
03:50:38 <LPhas> @where fptools
03:50:38 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
03:55:54 <LPhas> trying to compile lambdabot i get ghc-6.6: could not execute: ./BotPP
03:55:54 <LPhas>  
03:56:19 <opqdonut> chmod +x?
03:56:48 <LPhas> ghc-6.6: could not execute: ./BotPP
03:56:48 <LPhas>  
03:56:58 <LPhas> opqdonut: i cannot fined ani BotPP
03:57:34 <LPhas> oh, in scripts/ ...
04:00:57 <LPhas> @hoogle Data.Binary
04:00:58 <lambdabot> No matches, try a more general search
04:01:07 <LPhas> @where Data.Binary
04:01:07 <lambdabot> I know nothing about data.binary.
04:09:29 <ejt>     Could not find module `Data.Edison.Coll.SkewHeap':
04:09:29 <ejt>       it is a member of package EdisonCore-1.2.1, which is hidden
04:09:34 <ejt> ^^ what does this mean ?
04:09:45 <ejt> I can use it from ghci quite happily
04:10:15 <matthew_-> you should be able to use the -package flag in ghc in order to make it non-hidden
04:10:25 <ejt> ah, thx
04:10:28 <matthew_-> ghc-pkg list (or something like that)
04:10:36 <matthew_-> to find which package the module's in
04:12:45 <LPhas> ejt: ghc-pkg -list
04:12:59 <ejt> thx
04:13:10 <ejt> just adding that package to my .cabal
04:13:17 <LPhas> ejt: ah eheh :D
04:13:37 <LPhas> ejt: i was asking you "but are you using cabal?"
04:14:35 <ejt> all working now thx
04:16:08 <LPhas> ejt: of course, cabal hides all packages but the ones listed in .cabal
04:16:19 <ejt> y, I realise that now
04:16:38 <ejt> nice way of enforcing the author gets the .cabal right
04:18:58 <LPhas> ejt:  :D
04:19:37 <LPhas> compiling lambdabot: /tmp/ghc1378_0/ghc1378_8.hspp:21:1: lexical error at character 'i'
04:24:23 <LPhas> ?seen dons
04:24:23 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3h 9m 38s ago.
04:37:36 <ejt> @paste
04:37:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:38:44 <hpaste>  ejt pasted "ByteString.Lazy question" at http://hpaste.org/1084
04:39:15 <quicksilver> ejt: it does run lazily
04:39:26 <quicksilver> ejt: but your c library buffers the IO :P
04:39:49 <ejt> it runs differently from getContents >>= putStr
04:39:52 <quicksilver> if you type more than C-buffer-size (could be 8k?) then you'll see some output
04:39:59 <ejt> k
04:40:10 <quicksilver> try unbuffering stdin and stdout
04:40:14 <ejt> I thought stdin/stdout were line buffered
04:40:30 <opqdonut> depends
04:40:51 <quicksilver> 'lazily' doesn't mean 'instant pass through'
04:41:00 <quicksilver> 'lazily' means 'constant space overhead in the big picture'
04:41:09 <opqdonut> ejt: "Output  streams that refer to terminal devices are always line buffered by default;"
04:41:10 <quicksilver> if it didn't buffer anything at all it would be incredibly inefficient
04:41:24 <ejt> quicksilver: ack
04:43:49 <ejt> if I set NoBuffering then characters get echoed immiediately as I'd expect
04:43:55 * quicksilver nods
04:44:00 <ejt> line buffering doen't echo after every line however
04:44:07 <quicksilver> not sure why that would be
04:44:14 <quicksilver> lazy IO is evil
04:44:15 <quicksilver> :)
04:44:23 <ejt> me neither, is it worth mentioning to dons ?
04:44:37 <quicksilver> it's certainly interesting to ask him
04:44:45 <quicksilver> the answer may be obvious from the source, too
04:45:53 <quicksilver> hGetContents = hGetContentsN defaultChunkSize
04:46:04 <quicksilver> -- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
04:46:04 <quicksilver> -- are read on demand, in at most @k@-sized chunks. It does not block
04:46:04 <quicksilver> -- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
04:46:04 <quicksilver> -- available then they will be returned immediately as a smaller chunk.
04:46:07 * quicksilver shrugs
04:46:50 <dons> hmm?
04:47:10 <quicksilver> dons: ejt finds that getContents >>= putStr (lazy) performs as expected with NoBuffering
04:47:18 <quicksilver> dons: but with LineBuffering it doesn't appear to LineBuffer
04:47:33 <dons> oh hmm. it would chunk buffer, i suspect
04:47:44 <fsafasfasf> http://taleworld.sytes.net Join Please
04:47:47 <lambdabot> Title: мир Tale World
04:47:53 <quicksilver> ah
04:48:02 <quicksilver> it's probably the putStr that's blocking, not the getContents
04:48:15 <quicksilver> the getContents is probably respecting line buffering
04:48:20 <ejt> ah
04:48:27 <quicksilver> but the putStr part is probably chunking it up
04:48:39 <dons> it'd be dumping chunks out at a time, I think.
04:48:50 <ejt> y, that's sane
04:48:55 <ejt> thx
04:49:02 <quicksilver> hmm
04:49:12 <quicksilver> but in line-buffered mode, getContents should be making smaller chunks
04:49:22 <quicksilver> since getContents is never supposed to wait for data before returning
04:49:26 <dons> yes, perhaps.
04:49:39 <quicksilver> bad use of words
04:49:52 <quicksilver> 'before returning' -> 'before producing a chunk'
04:50:21 <quicksilver> using imperative phrases to describe lazy IO is not helpful :)
04:50:49 <dons> heh
04:51:37 <quicksilver> the lazy hGetContents calls hGetNonBlocking
04:51:56 <dons> there was a bug in the the lazy hGetContents, iirc, where it was one element too strict
04:52:00 <dons> that was fixed in fps head
04:52:01 <quicksilver> on a line-buffered stdin, you'd expect hGetNonBlocking to return a line (or multiple lines)
04:52:37 <quicksilver> dons: hmm that sounds like it could be it
04:53:02 <dons> yes, that might be it actually
04:53:15 <dons> ejt, you could test with fps head (though thats non-trivial with ghc 6.6)
04:53:48 <dons> we'd use strictBench now for this stuff
04:53:49 <ejt> it's not critical, so will look if have time thx
04:53:56 <quicksilver> http://darcs.haskell.org/ghc-6.6/packages/base/Data/ByteString/Lazy.hs
04:53:58 <lambdabot> http://tinyurl.com/23qotg
04:54:02 <dons> precise laziness properties are hard to test for!
04:54:04 <quicksilver> dons: is that version the 6.6 version or the newer one?
04:54:16 <dons> there's a newer version in fps head
04:54:17 <dons> not ghc head.
04:54:22 <dons> we've yet to merge it in.
04:54:26 <quicksilver> the one I've been reading is the old one, then?
04:54:39 <dons> it would be, unless it had a cse.unsw.edu.au url
04:54:42 * quicksilver nods
04:54:53 <quicksilver> I don't see the bug but then maybe I"m being blind
04:54:54 <dons> we plan to do the merge after the icfp deadline sometime
04:55:10 <quicksilver> what's the URL to the fps HEAD?
04:55:15 <dons> ?where fps
04:55:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
04:55:55 <quicksilver> thanks
04:57:23 <quicksilver> dons: I don't see a difference in either hGetNonBlockingN or hGetContentsN
04:57:24 <quicksilver> odd
04:57:51 <dons> hmm. ok. maybe that bug was fixed earlier
05:39:29 <dons> ?yow
05:39:30 <lambdabot> Hmmm ... A hash-singer and a cross-eyed guy were SLEEPING on a deserted
05:39:30 <lambdabot> island, when ...
05:39:35 <dons> ?usres
05:39:35 <lambdabot> Maximum users seen in #haskell: 336, currently: 309 (92.0%), active: 33 (10.7%)
05:42:31 <quicksilver> not a creature was stirring, not even a mouse
05:42:40 <ivanm> stirring what? soup?
05:45:31 <dons> soup!
05:46:09 <ivanm> lol
05:46:20 * ivanm thinks dons is easily amused ;-)
05:46:55 <desp> mmm, soup.
05:47:33 <desp> ?us0rs
05:47:33 <lambdabot> Maximum users seen in #haskell: 336, currently: 313 (93.2%), active: 34 (10.9%)
05:47:56 <desp> ?uzerz
05:47:56 <lambdabot> Maximum users seen in #haskell: 336, currently: 313 (93.2%), active: 34 (10.9%)
05:48:04 <desp> it's magic!
05:48:07 <Botje> :src join
05:48:19 <quicksilver> @src join
05:48:19 <lambdabot> join x =  x >>= id
05:48:40 <quicksilver> such a backwards way to define it :)
05:48:58 <Botje> yay! I get join in the ((->) r) monad now!
05:49:03 <quicksilver> woo!
05:49:05 <ToRA> quicksilver: how would you define it?
05:49:14 <quicksilver> ToRA: I'd make join fundamental
05:49:18 <quicksilver> ToRA: and define bind
05:49:47 <ToRA> quicksilver: don't you have to define bind anyway?
05:50:00 <quicksilver> currently we make bind fundamental, and define join in terms of bind
05:50:04 <quicksilver> I'm saying, I'd do the opposite
05:50:22 <ToRA> quicksilver: ah ok
05:50:56 <Botje> quicksilver: but bind is used more often than join & fmap, no ,
05:50:57 <Botje> ?
05:51:04 <quicksilver> because in many monoids, I find join a more 'obvious' operation than bind
05:51:06 <ToRA> what would bind in-terms-of join, and fundamental join look like for Maybe?
05:51:27 <quicksilver> join for maybe is case m of Just x -> x ; Nothing -> Nothing
05:51:28 <ToRA>  / is there a reference for such things?
05:52:05 <desp> the ((->) r) monad?
05:52:07 <desp> what's that for?
05:52:11 <quicksilver> bind in terms of join is basically fmap followed by join
05:52:12 <Botje> fun stuff.
05:52:14 <Botje> like
05:52:19 <Botje> > join (*) 5
05:52:20 <lambdabot>  25
05:52:25 <Botje> and.
05:52:36 <Botje> @pl \x -> (show x) == (reverse $ show x)
05:52:36 <lambdabot> liftM2 (==) show (reverse . show)
05:52:44 <desp> oerr
05:53:17 <quicksilver> desp: the ((->) r) monad is about functions which are all waiting for one argument
05:53:30 <quicksilver> desp: and you 'execute' the action by giving it the argument
05:53:35 <quicksilver> (which it gives to all the functions)
05:53:40 <quicksilver> it's the same as the Reader monad
05:53:40 <Botje> @t join negate
05:53:41 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
05:53:46 <Botje> @type join negate
05:53:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
05:53:48 <lambdabot>     Probable cause: `negate' is applied to too many arguments
05:53:59 <Botje> boo! :)
05:54:01 <Syzygy-> > return 5 >>= (+3) >>= (*5)
05:54:02 <lambdabot>   add an instance declaration for (Num (m b))
05:54:05 <Syzygy-> No.
05:54:28 <Syzygy-> :t join
05:54:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:54:42 * Syzygy- agrees about the join being more ... mathematically ... sane.
05:54:44 <Botje> > (+1) >>= (+) $ 2
05:54:45 <lambdabot>  5
05:54:49 <desp> quicksilver: right...so why Syzygy-'s example didn't work?
05:54:50 <quicksilver> > (return 5 >>= (+) >>= (*)) $ 4
05:54:51 <Syzygy-> Botje: Ah.
05:54:51 <lambdabot>  36
05:54:57 <desp> ah
05:55:07 <quicksilver> desp: well when you apply >>= then that thing needs two argumentsw
05:55:12 <quicksilver> one coming from the 'environment'
05:55:18 <desp> gotcha
05:55:19 <quicksilver> and one coming from the result of the last computation
05:55:27 <desp> you guys are all insane
05:55:28 <quicksilver> and, Syzygy- didn't give it an environment
05:55:28 <desp> ;p
05:55:30 <Syzygy-> Ooooooh. Right. One is in the \x -> foo, and the other is the argument it expects.
05:55:43 <Syzygy-> quicksilver: I thought I gave it an environment with the return 5.
05:55:54 <quicksilver> no, giving it an argument is 'external'
05:55:59 <quicksilver> you can't do that 'inside the monad'
05:55:59 <Syzygy-> desp: I have a valid excuse. I do homological algebra for a living.
05:56:03 <Syzygy-> quicksilver: Right.
05:56:06 <quicksilver> just like you can't run an IO action from 'inside'
05:56:24 <quicksilver> although in the specific case of Reader, there is 'local' which does do somethiing a bit like that
05:56:30 <Syzygy-> So, basically, (+3) $ 5 is a kind of "minimal" application of the ((->)r) monad?
05:56:34 <Syzygy-> > (+3) $ 5
05:56:36 <lambdabot>  8
05:56:36 <quicksilver> right
05:56:46 <Syzygy-> > (+3) >>= (*) $ 5
05:56:47 <quicksilver> (+3) is a simple computation in the (->)r monad
05:56:47 <lambdabot>  40
05:56:51 <quicksilver> it has the effect of adding 3
05:57:08 <quicksilver> (+3) >>= (*) has the effect of adding 3 and then multiplying by the number you first thought of
05:57:09 <desp> amazingly enough
05:57:12 <desp> :)
05:57:13 <quicksilver> if you're familiar with such childhood game s:)
05:57:17 <Syzygy-> Hehe
05:57:26 <Syzygy-> > (+3) >> (+5) $ 5
05:57:27 <lambdabot>  10
05:57:30 <Syzygy-> Hah!
05:57:38 <quicksilver> that adds three, but throws the result away
05:57:50 <ToRA> > undefined >> (+5) $ 5
05:57:51 <lambdabot>  10
05:57:55 <quicksilver> the (->)r monad has no observable side-effects
05:58:02 <quicksilver> so once you throw stuff away that's a bit pointless
05:58:11 <ToRA> quicksilver: i would argue that it doesn't add the 3
05:58:24 <quicksilver> ToRA: you're talking about the operational semantics of lazy evaluation
05:58:28 <drigz> is there a builtin that will map [1, 2, 3, 4, 5] -> [1, 4], [2, 5], [3] etc?
05:58:35 <quicksilver> ToRA: I'm just talking about monads without caring about the host language
05:58:40 <drigz> like python's list[0::3]
05:58:58 <quicksilver> drigz: it's probably simple to construct but I don't know what you mean
05:59:10 <Botje> drigz: that looks like some kind of partitioning operator, can you give some more examples?
05:59:21 <ejt> drigz: use a list comprehension
05:59:52 <drigz> a list goes to [every third element], [every third element (tail)], [every third element (tail.tail)]
06:00:11 <quicksilver> I think monad comprehensions should be brought back into the language, but renamed 'monad incomprehensions'
06:00:29 <kombinator> hello #haskell, does anyone know if Data.Map supports lower bound/upper bound operations efficiently?
06:00:30 <desp> :)
06:01:10 <Botje> > unzip3 $ takeWhile (not.null) $ unfoldr (Just . splitAt 3) [1, 2, 3, 4, 5]
06:01:11 <lambdabot>  Couldn't match expected type `(a, b, c)'
06:01:22 <Botje> phew. i'm not insane yet.
06:01:39 <drigz> ejt: how?
06:01:40 <Botje> > unzip3 $ map (\[a,b,c]->(a,b,c)) $ takeWhile (not.null) $ unfoldr (Just . splitAt 3) [1, 2, 3, 4, 5]
06:01:41 <lambdabot>   Non-exhaustive patterns in lambda
06:01:51 <Botje> grr.
06:02:07 <Botje> > unzip3 $ map (\[a,b,c]->(a,b,c)) $ takeWhile (not.null) $ unfoldr (Just . splitAt 3) [1, 2, 3, 4, 5, 6, 7]
06:02:08 <lambdabot>   Non-exhaustive patterns in lambda
06:02:10 <ejt> drigz: one minute (playing chess)
06:02:11 <Botje> > unzip3 $ map (\[a,b,c]->(a,b,c)) $ takeWhile (not.null) $ unfoldr (Just . splitAt 3) [1, 2, 3, 4, 5, 6]
06:02:13 <lambdabot>  ([1,4],[2,5],[3,6])
06:02:19 <dons> mmm. in nofib there are ~3000 stream fusion sites, and only 1500 build/foldr fusoin sites.
06:02:20 <Botje> well, this works. kind of.
06:02:58 <ski> '(r ->)' is discardable, copyable, and commutative
06:03:32 <dons> fusion for everyone!
06:03:45 <dons> kombinator: hmm. yes, iirc.
06:03:47 <pejo> dons, does the doubling in numbers imply large performance differences?
06:04:06 <dons> pejo: well, *potentially* we can eliminate twice as many intermediate lists
06:04:13 <dons> which should lead to speedups
06:04:22 <dons> currently we get 4% speed up on micro benchmarks
06:04:25 <ski> dons : and list unboxing !
06:04:28 <dons> i expect to improve that
06:04:41 <kombinator> dons: ok, now I came across Map.splitLookup which should do the job for lower bound
06:04:47 <dons> ski, funny you should mention that, i noticed [Int#] used to be legal ghc 0.29
06:04:59 <pejo> dons, isn't 4% around the same that Gill got in his thesis?
06:05:19 <ski> dons : well, i meant a list which is unboxed in itself :)
06:05:21 <dons> ah ,for the original build/foldr?
06:05:35 <pejo> dons, nods, or do you mean 4% on top of build/foldr?
06:05:43 <dons> oh, instead of build/foldr. yes
06:05:54 <dons> we are 4% faster so far than build/foldr, but identify twice as many fusion sites
06:05:59 <dons> mainly because we can fuse foldls
06:06:01 <huschi> is there a function for showing numbers in hexadecimal in the std libs?
06:06:16 <dons> but, we've not yet tuned the code at all. so i think we can do much better.
06:06:21 <ejt>  let lst = [1, 2, 3, 4, 5, 6] in zip lst $ drop 2 lst
06:06:33 <int-e> > showHex 3298 ""
06:06:34 <lambdabot>  "ce2"
06:06:37 <int-e> from Numeric
06:06:38 <quicksilver> Oh, I know how to do it
06:06:41 <ejt> >  let lst = [1, 2, 3, 4, 5, 6] in zip lst $ drop 2 lst
06:06:42 <lambdabot>  [(1,3),(2,4),(3,5),(4,6)]
06:06:46 <pejo> dons, I'm looking forward to reading the paper, sounds very interesting.
06:06:55 <huschi> int-e: thx, hoogle didn't show that.
06:07:06 <dons> its exciting. the plan is to replace the entire build/foldr framework in fact
06:07:08 <quicksilver> let lst = [1...11] in takeWhile (not.null) . iterate (drop 3) $ lst
06:07:12 <quicksilver> > let lst = [1...11] in takeWhile (not.null) . iterate (drop 3) $ lst
06:07:13 <lambdabot>   Not in scope: `...'
06:07:18 <quicksilver> > let lst = [1..11] in takeWhile (not.null) . iterate (drop 3) $ lst
06:07:19 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11],[4,5,6,7,8,9,10,11],[7,8,9,10,11],[10,11]]
06:07:25 <dons> pejo: so not just papers, but real code :-)
06:07:27 <kombinator> dons: by the way, I wanted to ask you a few questions on how is syntax highlightning implemented in Yi
06:07:39 <dons> ah yes?
06:07:45 <pejo> dons, psah, code is over-rated. :-)
06:07:46 <ski> (dons : where e.g. an unboxed 'Either a b' is a computation that is passed two return paths (/adresses/continuations), one for 'a' and one for 'b')
06:07:47 <dons> it uses lexer combinators, iirc
06:07:53 <dons> pejo: http://www.cse.unsw.edu.au/~dons/streams.html
06:07:54 <lambdabot> Title: Data.List.Stream
06:08:28 <kombinator> dons: what does it mean? I've seen that it uses Alex in some nonstandard way
06:08:31 <dons> ski: ghc does that already ,in a way, via the SpecConstr optimisation
06:08:47 <dons> kombinator: iirc, (i didn't write the code) we relex individiual lines
06:08:51 <dons> remembering the lexer state of each line
06:08:55 <chessguy> 'morning, haskellers
06:09:10 <ski> dons : isn't that for specializing functions to some input patterns ?
06:09:15 <kombinator> dons: ok, that makes sense
06:09:33 <dons> ski, if ghc notices you make a recursive call with the same constructor, it generates a worker that avoids the constructor and calls that instead
06:09:49 <SimonRC> chessguy: or mourning
06:09:52 <dons> e.g. f (Just x) = ... f (Just ..) .. ; f Nothing = ... ;
06:09:59 <dons> is unwrappedd to f_J x = ..
06:10:01 <chessguy> if you'd rather...
06:10:21 <dons> ski, so not quite sure if that's what you wanted.
06:10:23 <quicksilver> > transpose . takeWhile (not.null) . unfoldr (Just . splitAt 3) $ [1..11]
06:10:24 <lambdabot>  [[1,4,7,10],[2,5,8,11],[3,6,9]]
06:10:27 <quicksilver> woot!
06:10:31 <quicksilver> I always forget transpost
06:10:43 <dons> but we certainly rely on SpecConstr to strip out Lefts and Rights used to mark state in some functions
06:10:45 <quicksilver> drigz: there you go
06:10:51 <ski> dons : right .. i was talking about if you call a function which returns 'Either# a b', say, inside a 'case', then what happens is that two continuations are passed, instead of actually tagging (and this would then be guarranteed)
06:11:42 <quicksilver> ski: it amounts to the same thing, except which continuation is known at compile-time
06:11:51 <quicksilver> ski: so it doesn't even need two continuations, just one
06:12:04 <drigz> quicksilver: what does the takeWhile (not.null) do?
06:12:19 <quicksilver> drigz: stops when it starts seeing empty lists
06:12:33 <int-e> > unfoldr (Just . splitAt 3) $ [1..11] -- many empty lists
06:12:33 <quicksilver> drigz: the unfoldr (Just . splitAt3) will keep producing empty lists forever
06:12:34 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
06:12:37 <ski> the point would be that the 'Either# a b' would be unboxed, i.e. not a single continuation that can handle both cases, but actually two different continuations
06:12:43 <ski> quicksilver : ^
06:12:54 <quicksilver> ski: yes, I understand the point, and I agree it isn't the same
06:12:59 <ski> ok
06:13:01 <chessguy> @type (>>=)
06:13:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:13:08 <drigz> quicksilver: cool, thanks!
06:13:09 <quicksilver> ski: the GHC optimisation that dons is talking about is for the case when it's known at compile time which branch you're in
06:13:25 <ski> quicksilver : yes, i understand that now
06:13:54 <ski> anyway, i wanted unboxed lists (in similar sense) ..
06:14:09 <ski> .. i have a hunch that would be closely related to list fusion
06:14:15 <quicksilver> yes, it would
06:14:22 <quicksilver> an unboxed list, in that sense, is like a 'build'
06:14:31 <quicksilver> 'build' is the type of list continuations
06:14:37 <quicksilver> (well, or foldr is)
06:14:38 <ski> (but the underlying 'cons'-continuation would need to be composable, afaict)
06:14:43 <ski> right
06:14:44 <quicksilver> it depends which way up your head is
06:14:46 <quicksilver> :)
06:14:58 <ski> @type foldr
06:15:00 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:15:19 <ski> build :: (forall o. (a -> o -> o) -> o -> o) -> [a]
06:15:20 <quicksilver> foldr has the type of list continuations. build has the type of a function which consumes list continuations
06:16:56 <ski> so .. if one could get something like 'Either# a b' or '[# a #]' to work, we'd be guarranteed a similar execution as with fusion, i think
06:17:29 <quicksilver> ski: I *think* you're just talking about encoding fusion into the type system, aren't you?
06:17:31 <ski> (at least for these top-level return-value cases)
06:17:37 <quicksilver> ski: it wouldn't be different from what we have now
06:17:42 <quicksilver> just a different way of expressin it
06:17:47 <ski> in some sense, yes
06:18:00 <ski> (maybe there's some details differing ..)
06:18:30 <quicksilver> I wonder about trival fusions too, myself
06:18:32 <pejo> Is there a difference between using type information for fusion, and encoding fusion into the type system?
06:18:36 <quicksilver> like temporary tuples
06:18:51 <dons> pejo:sure.
06:18:51 <quicksilver> f x s where (x,s) = (g,h)
06:19:02 <quicksilver> afaik, GHC actually constructs a tuple for that case
06:19:12 <quicksilver> instead of producing the code for f g h
06:19:22 <dons> hmm. i wonder..
06:19:24 <ski> now, maybe one could get some analogue of "proper tail calls" for this, so that we get same guarrantee for plain 'Either a b' (no '#') as top-level return type :)
06:20:40 <pejo> quicksilver, is that a common pattern anyways?
06:20:58 <ski> (i.e. one would be able to easily see, locally, whether the code is written in "proper fusion call" way or not, for easier prediction of performance)
06:22:13 <quicksilver> pejo: not sure. I use it sometimes
06:22:48 <ski> (btw, these multiple alternative continuations are e.g. described in Olin Shivers' "Multi-return Function Call" http://www-static.cc.gatech.edu/~shivers/papers/mrlc-jfp.pdf)
06:22:59 <chessguy> @type (>>)
06:22:59 <dons> dev hint: it really is a *lot* easier to work on ghc when it takes only 10 mins to rebuild
06:23:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
06:23:08 <quicksilver> dons: showing off isn't nice :P
06:23:15 <quicksilver> dons: it took me 8 hours!
06:23:18 <drigz> ?pl \x -> x a
06:23:18 <lambdabot> ($ a)
06:23:26 <dons> it changes the way you work so much.
06:23:33 <CosmicRay> dons: how do you achieve a 10-minute rebuild?
06:23:41 <CosmicRay> quicksilver: heh, obviously you weren't using aix ;-)
06:23:43 <dons> you can't plan to have lunch while the compiler is building any more ...
06:23:52 <CosmicRay> I think it took me a week to get a working ghc built there.
06:23:52 <dons> CosmicRay: -j16 with 16 cores, basically.
06:23:58 <CosmicRay> dons: sweet.
06:24:19 <Syzygy-> dons: Funky!
06:24:32 <quicksilver> I have found the linux kernel compile time to be remarkably constant
06:24:41 <quicksilver> over 12 years of linux use, it has always taken about 30 mins
06:24:49 <CosmicRay> heh
06:24:56 <quicksilver> whenever I get a better system, there is a bigger and uglier kernel
06:24:57 <dons> that's a bit scary. the openbsd kernel takes about 2 mins
06:25:00 <Syzygy-> Kernel growing with your hardware, eh?
06:25:05 <pejo> quicksilver, and a gcc upgrade.
06:25:12 <quicksilver> dons: this is compiling *all* modules of a fully modular kernel, though
06:25:18 <dons> ah right
06:25:20 <quicksilver> dons: so it's a lot of unnecessary work, technically
06:25:26 <dons> yeah
06:25:31 <quicksilver> but I'm too lazy to select only the ones I want
06:25:32 <dons> lot bigger system anyway
06:25:43 <quicksilver> and you never know what hardware I'm going to buy next month, anyway
06:29:21 <quicksilver> transpose should be function of the day, really
06:29:29 <quicksilver> it's underused
06:29:37 <Botje> heh.
06:29:53 <Botje> something like the Perl advent calendar would be neat.
06:30:12 <Botje> it highlights one interesting module per day during the month december
06:30:37 <Botje> which reminds me
06:30:44 <Botje> I still need to finish my terrain-drawing thing :(
06:30:58 <dolio> > transpose [[1, 2, 3], [4, 5]]
06:30:59 <lambdabot>  [[1,4],[2,5],[3]]
06:31:17 <quicksilver> Botje: actually a haskell advent calendar would be an excellent idea
06:31:24 <quicksilver> Botje: try to remember to propose it in november or so
06:31:29 <quicksilver> perhaps october would be wiser
06:31:51 <Botje> we could have an Easter calendar :p
06:31:58 <dons> quicksilver: its horrible though, tranpose.
06:32:01 <dons> i can't fuse it!
06:32:06 <quicksilver> heh :)
06:32:11 <Botje> try harder!
06:32:11 <desp> Botje: with one window?
06:32:27 <dons> ?src tranpose
06:32:27 <lambdabot> Source not found. That's something I cannot allow to happen.
06:32:47 <desp> :D
06:32:52 <dons> transpose []             = []
06:32:52 <dons> transpose ([]     : xss) = transpose xss
06:32:52 <dons> transpose ((x:xs) : xss) = (x : [h | (h:_t) <- xss])
06:32:53 <dons>                          : transpose (xs : [ t | (_h:t) <- xss])
06:32:57 <dons> urgh!
06:34:05 <quicksilver> dons: I want to see a picture of the way transpose walks through a lazy list of lazy lists
06:34:13 <quicksilver> dons: it's like a carpet unravelling on a single thread
06:34:42 <drigz> is something like this allowed:
06:34:50 <drigz> text <- readFile file
06:34:53 <drigz> print processed
06:34:56 <mrchebas_> strange error of the day: Couldn't match expected type `.' (a rigid variable)
06:34:57 <mrchebas_>            against inferred type `Rep2 GReduce a'
06:35:04 <drigz>   where processed = process text
06:35:08 <quicksilver> drigz: yes
06:35:12 <mrchebas_> (note that variable name is ".")
06:35:18 <dons> mrchebas_: tricksy
06:35:21 <quicksilver> drigz: except you can't use where
06:35:25 <quicksilver> drigz: have to use let :(
06:35:28 <Botje> drigz: you coould write it as print $ process text
06:35:34 <Botje> or let processed = process text
06:35:40 <Botje> (note: no in)
06:35:41 <mrchebas_> solved with -fglasgow-exts, the forall's were not parsed correctly :)
06:35:53 <drigz> Botje: i need to use processed in several places
06:35:56 <drigz> i'll try with let, thanks
06:36:08 <dons> mrchebas_: ah yes, now i recall that error. it has come up before
06:36:38 <mrchebas_> dons: this used to be a parsing error, but lexing or parsing has changed since.
06:36:57 <mrchebas_> i had to think for a while before figuring out what was wrong
07:09:51 <bakert> I have a function that has type "m (Maybe String)" and I want to pattern match "Just s".  I know I'm being thick but what's the syntax?
07:10:15 <Lemmih> That depends on what 'm' is.
07:10:17 <bakert> "Just s <- f" is wrong because it's still in the monad when the Just gets applied?
07:10:29 <bakert> m is the BrowserAction monad from Network.Browser
07:10:31 <opqdonut> bakert: m (Just s) = foo
07:10:31 <mux> x <- foo
07:10:35 <mux> case x of
07:10:36 <opqdonut> m Nothing = else
07:11:15 <opqdonut> oh it was inside a monad, nvm
07:11:37 <bakert> is there no way to do it on one line?
07:11:44 <DangerMouse> im programming in miranda (newbie) and im trying to learn it by making a small game, i need to initialize a list of lists as the board but how do i automatically generate a 10x10 board and initialize each element with the '-' character?
07:11:50 <bakert> like opqdonut's thing but working for monads ...
07:12:50 <dons> DangerMouse: miranda?
07:13:00 <dons> really, not haskell?
07:13:28 <dons> probably a list comprehension would do the trick, though i can't recall enough miranda to remember if it has them.
07:13:28 <Saizan> ?type let f = return (Just "a") in do { Just s <- f; return s }
07:13:30 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
07:13:31 <DangerMouse> dons: yeah :)
07:14:36 <DangerMouse> dons: miranda code can be moved to haskell without mich effort right?
07:15:15 <DangerMouse> much*
07:17:45 <Saizan> bakert: Just s <- f is fine if  f :: m (Maybe String), and s would be of type String, it's only that if f = return Nothing than you have a fail in the monad m
07:17:57 <bakert> Ah, really?
07:18:09 <bakert> Thanks Saizan.
07:18:12 <Saizan> > let f = return (Just "a") in do { Just s <- f; return s }
07:18:13 <lambdabot>   add an instance declaration for (Show (m [Char]))
07:18:29 <Saizan> > let f = return (Just "a") in do { Just s <- f; return s } :: Either String String
07:18:31 <lambdabot>  Right "a"
07:18:43 <Saizan> > let f = return Nothing in do { Just s <- f; return s } :: Either String String
07:18:45 <lambdabot>  Left "Pattern match failure in do expression at <irc>:1:31-36"
07:19:01 <quicksilver> > do { Just s <- [Just 1, Just 2, Just 3]; return s }
07:19:03 <lambdabot>  [1,2,3]
07:19:09 <quicksilver> > do { Just s <- [Just 1, Just 2, Just 3, Nothing]; return s }
07:19:10 <lambdabot>  [1,2,3]
07:19:18 <bakert> Wicked.  Works.  I think I must have misinterpreted an error message somewhere along the line.  Thanks Saizan!
07:19:38 <Saizan> :)
07:20:09 <bakert> Sometimes you need to know that you don't know.  Or something like that. ;)
07:30:46 <gleb> Hi #haskell! I have a small design problem, would someone be so kind to help me?
07:31:05 <quicksilver> you can always ask
07:31:11 <quicksilver> the worst that can happen is no one answers :)
07:31:22 <bakert> that is quite sad though
07:31:26 <quicksilver> or, possibly, the worst is that you get 3 totally contradictory answers :)
07:31:32 <bakert> no i like that!
07:31:40 <gleb> quicksilver: :)
07:31:59 <bakert> in the same vein as "there is no such thing as bad publicity"
07:32:08 <bakert> there is no such thing as bad irc responses
07:32:15 <bakert> at least it gives you something to try/think about
07:32:47 <gleb> Ok, I'm trying to prototype a little Machine Learning application, has smth to do with nearest neighbor classification
07:33:22 <edwardk> @seen ski
07:33:22 <lambdabot> ski is in #haskell-blah, #oasis and #haskell. I last heard ski speak 1h 10m 34s ago.
07:33:59 <gleb> I define a "Pattern" typeclass: http://paste.lisp.org/display/38480
07:35:07 <gleb> Anything that has "distance" and "centroid" operations defined can be categorized. So far so good
07:35:45 <edwardk> @seen dons
07:35:46 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 22m 18s ago.
07:35:56 * quicksilver nods
07:36:30 <gleb> But when I get to real problems, it turns out that real patterns have highly-dimensional feature vectors
07:36:45 <edwardk> dons: did hs-plugins ever get updated to be able to work right on ghc 6.6?
07:37:10 <Igloo> edwardk: I believe darcs does
07:37:31 <edwardk> igloo: ah so if i grab it via darcs i'm good?
07:37:33 <Igloo> although there may be some issues on Windows
07:37:38 <Igloo> Yup
07:37:40 <edwardk> ugh
07:37:47 <erider> good morning
07:37:53 <edwardk> was hoping to use it both on windows and linux =/
07:38:09 <gleb> Highly-dimensional vectors have 2 possible representations: dense and sparse. It's better to represent category prototypes as dense vectors, and ordinary patterns as sparse vectors.
07:38:22 <gleb> I cannot fit this into the Pattern type class
07:39:33 <quicksilver> hmmm
07:39:53 <quicksilver> this all sounds rather abstract, gleb
07:40:06 <quicksilver> I'd have expected a type class to be able to cope
07:40:07 <gleb> Yeah, I'm sorry
07:40:10 <quicksilver> (with dense and sparse both)
07:40:22 <quicksilver> how is it failing to fit?
07:40:38 <gleb> If I could express the problem in a cleaner way, I would probably have solved it already
07:40:46 <quicksilver> that's haskell for you :)
07:40:50 <quicksilver> (and maths, to some extent)
07:41:58 <gleb> Math doesn't really ever take into account different possible representation of a vector
07:43:22 <SamB> gleb: you need some more "meta"s
07:44:39 <quicksilver> that's true
07:44:49 <quicksilver> I was making an analogy, that's all
07:45:09 <gleb> SamB: I guess yes, but I don't know which "meta"s do I need
07:45:28 <quicksilver> meta-expression
07:45:39 <quicksilver> you need to meta-express the meta-problem meta-more cleanly
07:45:41 <quicksilver> then you're ok
07:46:10 * SamB was thinking of how you would apply math to the different representations and their algorithms
07:47:21 <dolio> What about rolling the different representations into a datatype?
07:47:24 <SamB> gleb: okay, so do you need to be able to mix the sparse and dense representations?
07:47:51 <dolio> 'data Vector a = Sparse <sparse representation> | Dense <dense representation>'?
07:48:02 <SamB> yeah, what he said ;-)
07:48:21 <dolio> Oh, I must have skipped that bit.
07:48:32 <dolio> :)
07:48:55 <SamB> dolio: no, I mean what *you* said
07:49:06 <dolio> :) Oh. I must need more sleep.
07:49:08 <bakert> dolio, i think samb was agreeing with you, not telling you it had already been said!
07:49:19 <bakert> oh.  and he told you that himself .. i'll shut up now
07:49:28 <dolio> :)
07:49:35 <gleb> SamB: Ideally, when implementing concrete clustering, classification and the like, I'd like to not care about representation
07:49:44 <gleb> but I do need to mix it
07:49:59 <SamB> @remember #haskell @quote stereo
07:49:59 <lambdabot> Done.
07:50:32 <dolio> The only issue with that might be deciding how to represent results of using two together.
07:50:33 <SamB> there, now when you do that you have a 50% chance of a self-referential meta-quote
07:50:45 <SamB> dolio: well, I'd assume sparsely
07:50:54 <SamB> I might be wrong
07:51:01 <dolio> I suppose that's a problem anyway. :)
07:51:02 <SamB> but there is one other option
07:51:26 <gleb> Guys, I'm afraid I've lost you
07:51:39 <quicksilver> gleb: having a datatype like Sparse <foo> | Dense <bar> does not conflict with the stated goal "I'd like to not care about representation"
07:51:52 <quicksilver> gleb: it's just a sensible way to represent data with two possible forms
07:52:12 <quicksilver> gleb: then, rather than accessing the data type directly, you provide a few 'low-level' building blocks
07:52:15 <SamB> gleb: well, you would presumably not be mucking with the internals of the datatypes anyway
07:52:20 <quicksilver> gleb: which do the one or the other as appropriate
07:52:35 <quicksilver> gleb: and your high-level functions like clustering call the low-level ones
07:55:17 <SamB> exactly
07:55:51 <quicksilver> typeclasses and algebraic data types are rather similar, for this kind of problem
07:55:54 <Saizan> mmh there was paolino on #haskell.it that has made a data-agnostic clustering algorithm in the past months
07:55:57 <quicksilver> the difference is that typeclasses are 'open'
07:56:03 <quicksilver> and datatypes are closed
07:56:09 <SamB> eh.
07:56:29 <SamB> you can mix constructors, with ADTs...
07:56:31 <gleb> quicksilver: It's all about efficiency. When classifiyng patterns into categories, I have to calculate a lot of distances between category prototype-vectors and pattern-vectors. For this operation to be efficient, it's better to represent category prototypes as dense vectors, and ordinary patterns as sparse vectors
07:56:40 <quicksilver> gleb: I understand that, yes
07:57:01 <quicksilver> gleb: and some of your low-level algorithms need to know which type their paramters are, to use the most efficient algorithm
07:57:06 <quicksilver> gleb: but most of your high level algorithsm don't care
07:57:07 <Saizan> but with datatypes you can use two different constructors knowing which is which
07:57:12 <quicksilver> gleb: this is all fine :)
07:57:40 <jcreigh> @tell sjanssen I like 1%2 better too. :)
07:57:40 <lambdabot> Consider it noted.
07:57:46 <quicksilver> Saizan: you can provide constructors with typeclasses too, if you like :)
07:57:58 <SamB> yeah, you'd just need your "distance" and "centroid", and a "densify" function
07:58:28 <SamB> quicksilver: typecases are not allowed
07:58:42 <gleb> SamB: sounds reasonable, thanks. I have to think about it
07:58:49 <Saizan> yeah i should have said pattern matching
07:59:10 <quicksilver> Saizan: indeed
07:59:19 <quicksilver> SamB: erm, that was for yhou
07:59:23 <gleb> So for simple cases like Double or (Double, Double) densify would be simply 'id'
07:59:40 <SamB> gleb: yeah.
07:59:42 <quicksilver> SamB: so a function which in the datatype model is a typecase, in the typeclass model becomes a method
07:59:47 <quicksilver> SamB: it's still isomorphic
07:59:48 <SamB> and you could put that in your typeclass, too
07:59:52 <quicksilver> SamB: although your code is split
08:00:23 <SamB> quicksilver: well, I suppose it is isomorphic if you do not export the constructors of the datatype
08:01:04 <quicksilver> or if you *do* export the constructors of the typeclass instances :P
08:01:20 <gleb> The more I think about it the more I like it. The first approach I've taken was multi-parameter t.c., but it quickly became a mess
08:01:30 <SamB> but, you can't add methods to a typeclass
08:01:39 <quicksilver> SamB: I'm the programmer! I can add what I like!
08:01:51 <SamB> quicksilver: well, I mean, not in another module you can't
08:02:01 * quicksilver nods
08:02:27 <quicksilver> and similarly you can't write a 'case' over non-exported constructors, in another module
08:02:38 <quicksilver> gleb: people overuse typeclasses
08:02:53 <quicksilver> gleb: they are very handy, but they are not to be preferred to simpler solutions when the simple one is as good :)
08:03:08 <quicksilver> occam's razor
08:03:46 <SamB> but, with tyepclasses, other modules may add new constructors to the cases. with algebraic datatypes, other modules may add new cases.
08:03:52 <Saizan> if i have data V = D .. | S ..;  i can do add (D ..) (D ..) = D ..; add (S ..) (S ..) = S ..; add (D ..) (S ..) = D .., how can i write this with data S = S .., data D = D.. and typeclasses?
08:04:12 <SamB> quicksilver: also when the simpler one is better. probably also occam's razor.
08:04:24 <quicksilver> SamB: right
08:04:33 <quicksilver> SamB: hence my comment about typclasses being open :)
08:04:37 <gleb> quicksilver: To be honest, this prototype will be translated to C#, so I have interfaces and generics there. I'm playing with Haskell solution to get rid of OO-stuff and have a clear solution to the problem
08:04:56 <gleb> Ok, thank you very much
08:05:14 <quicksilver> SamB: you'll need to expose some low-ish level method
08:05:17 <quicksilver> damn
08:05:19 <dolio> Saizan: You'd do it with "class Addable a b where ..." "instance Addable S D" "instance Addable D D" "instance Addable S S" ...
08:05:20 <quicksilver> nicks too similar!!!
08:05:31 <quicksilver> I wouldn't do what dolio says
08:05:36 <quicksilver> MPTCs are also overused
08:05:40 <SamB> quicksilver: I've discovered that I keep doing that these days
08:05:49 <SamB> I think I need to start typing three characters before TAB
08:05:53 <dolio> I wouldn't recommend it, but it's how you'd conver the datatype example to typeclasses.
08:05:54 <quicksilver> Saizan: you'd expose whater low-level methods you need
08:05:59 <quicksilver> dolio: I don't believe it is
08:06:19 <quicksilver> Saizan: so that you can write (V a) => add :: a -> a -> a
08:06:52 <SamB> anyway, you generally don't convert algebraic datatypes to typeclasses...
08:07:21 <SamB> actually, JHC converts typeclass methods to typecases
08:08:45 <dolio> quicksilver: I'm not sure what you mean? Would that not, essentially, do the same thing as the algebraic datatype, only with datatypes with a single constructor + typeclasses?
08:08:47 <bakert> ?paste
08:08:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:08:54 <Saizan> quicksilver: if i have (V a) => add :: a -> a -> a, how can i call add (x :: S) (y :: D)?
08:08:56 <dolio> Which was the question, I think.
08:09:20 <hpaste>  bakert pasted "If I trace it works, if not file locked." at http://hpaste.org/1086
08:09:53 <bakert> If add "(trace x x)" in place of "x" in this code, it works.  Otherwise I get "file locked".  Any idea why?
08:10:00 <quicksilver> Saizan: sorry, I meant (V a, V b) => add :: a -> b -> b
08:10:24 <SamB> bakert: probably some kind of subtle timing issue?
08:10:32 <SamB> to do with laziness
08:10:54 <Saizan> mmh i still think dolio's solution would be nicer
08:11:06 <bakert> SamB, Hmm.  I think though in the BrowserAction monad (from Http.Browser) I am sequencing things.  No?  So shouldn't it be sort of imperative style?
08:11:14 <dolio> I suppose for full generality, you'd require a third parameter for the typeclass for the result type, which is even more over-engineering.
08:11:15 <quicksilver> Saizan: possibly; but you have to write lot of instances
08:11:29 <SamB> bakert: readFile being lazy
08:11:42 <SamB> but, what I don't see is why the file would be locked...
08:12:00 <eulero> @seen xerox
08:12:00 <lambdabot> I saw xerox leaving #perl6, #haskell-overflow, #haskell-blah and #haskell 18h 19s ago, and .
08:12:01 <SamB> especially while you are reading it
08:12:08 <bakert> SamB, well I write to it beforehand ... could be something to do with that?
08:12:19 <Saizan> also, i'llr eally need add :: a -> b -> Either a b
08:12:27 <SamB> bakert: oh. maybe you also write to it again?
08:12:33 <bakert> No, just once.
08:12:38 <SamB> hmm.
08:12:46 <SamB> odd!
08:12:50 <bakert> yeah
08:13:13 <SamB> I don't suppose strace is of any use?
08:13:14 <bakert> I do delete it.
08:13:18 <bakert> Perhaps that's it.
08:13:19 <SamB> oh, you delete it?
08:13:28 <SamB> just unlinking, though?
08:13:43 <yonkie> hello. how do you think, it's worth to start learn haskell at haskell kernel level, e.g. without thinking about prelude and anothers libs?
08:13:43 <bakert> With "system rm /tmp/sf-session"
08:13:50 <bakert> With system "rm /tmp/sf-session"
08:13:50 <SamB> the case means the file is already open
08:13:52 <bakert> i mean
08:14:02 <quicksilver> yonkie: doesn't sound very useful to me
08:14:04 <bakert> ahahahahaha
08:14:12 <quicksilver> yonkie: the prelude has useful things in it
08:14:14 <SamB> yonkie: you will reinvent half of the prelude whether you like it or not
08:14:16 <bakert> perhaps the delete is what is chucking the error
08:14:24 <bakert> let me investigate.
08:14:27 <bakert> god i'm thick.
08:14:42 <SamB> but, deleting open files on *nix doesn't usually do any harm...
08:14:45 <yonkie> SamB: I'll not reinvent them.. I just want to see language as something pure
08:14:45 <bakert> true
08:14:55 <eulero> yonkie: Prelude is not that big, it's easy to learn Haskell AND Prelude
08:14:59 <SamB> yonkie: so, don't use unsafePerformIO
08:15:29 <SamB> yonkie: and trust me, you will reinvent something!
08:15:51 <yonkie> SamB : that's OK. at least we invent what we program as programmers :)
08:15:55 <Stinger> learn how the prelude is implemented in Haskell while learning Haskell
08:15:58 <bakert> SamB, nope it is the read that is the problem.
08:16:01 <bakert> hmmm.
08:16:11 <SamB> bakert: what filesystem is it?
08:16:20 <eulero> Stinger: that's a good approach
08:16:31 <bakert> ext3
08:16:44 <bakert> i'm going to get out of ghci and try an strace
08:16:53 <quicksilver> I suspect it's a ghci only problem
08:17:02 <quicksilver> to do with it not cleaning up after previous executions
08:17:09 <quicksilver> did you try a pure compiled executable?
08:17:14 <bakert> no going to try that now
08:17:22 <quicksilver> ghci tests often don't close files and stuff
08:17:28 <bakert> oh i didn't know
08:20:40 * SamB doesn't understand how that would be a problem if the file is rm'd between the readFile and the writeFile...
08:28:34 <bakert> You were right quicksilver, it works fine as a standalone binary.  thanks for your help SamB.
08:30:57 <quicksilver> bakert: yeah, I don't really understand but I've been aware of problems.
08:31:05 <quicksilver> bakert: I don't really like lazyIO, I prefer to close my own handles
08:31:10 <quicksilver> bakert: (which avoids such issues)
08:32:49 <carp> is Data.Binary in 6.6?
08:32:55 <glguy> no
08:33:11 <carp> oh, can i add it as a package or something?
08:33:45 <glguy> yeah
08:34:04 <carp> (now reading the readme of the thing i need it for)
08:41:20 <bringert> kosmikus: I'm writing a new paper, so naturally I have more lhs2TeX questions
08:42:57 <bringert> kosmikus: is there any reasonable way I could process each source file into a .tex file, that I could then \include in my main .tex file?
08:43:41 <bringert> kosmikus: I'd like to not have to run my main file though lhs2TeX
08:44:28 <bringert> the problem I get when I try it is that the lhs2TeX-generated files contain lots of stuff that must be in the preamble, so I can't \include them
08:44:39 <kolmodin> bringert: what is the paper about?
08:44:45 <bringert> GF stuff
08:44:51 <kolmodin> I should have known
08:44:53 <kolmodin> :)
08:45:06 <kolmodin> I'v written one page today!
08:45:22 <bringert> I like lhs2TeX output a lot, and I'd rather use it to typeset my code (GF code in this case) than lstlistings or something
08:45:39 <bringert> kolmodin: that's a reasonable pace
08:45:50 <kolmodin> :)
08:45:51 <bringert> kolmodin: more than that is hard to sustain
08:46:16 <kolmodin> some history of the standard we're moving to, so the readers know where it came from
08:46:25 <kolmodin> next'll be why it's partly awsome
08:46:34 <kolmodin> after that why it's partly crap
08:46:36 <kolmodin> :)
08:46:38 <bringert> partly awesome?
08:46:42 <bringert> ah
08:46:44 <Laney> @src reverse
08:46:44 <lambdabot> reverse = foldl (flip (:)) []
08:47:12 <kolmodin> being the best doesn't mean it's perfect
08:48:15 <kolmodin> it's in english, as I hope to get a little more feedback that way
08:48:51 <bringert> yeah, writing your thesis in english is a good plan
08:48:52 <pejo> "gf" = galois field?
08:49:04 <bringert> pejo: Grammatical Framework
08:49:07 <bringert> @where GF
08:49:07 <lambdabot> http://www.cs.chalmers.se/~aarne/GF/
08:49:59 <bringert> here's the the latest thing I did with GF: http://www.cs.chalmers.se/~bringert/xv/pizza/
08:50:00 <lambdabot> Title: Pizza Demo - GF XHTML+Voice - Description
08:50:06 <kolmodin> aye, I'm outta here
08:50:17 <kolmodin> bringert: that's the tram thingie?
08:50:26 <kolmodin> with the video?
08:50:27 <bringert> no, a pizza ordering app
08:50:30 <kolmodin> ah
08:50:39 <kolmodin> haven't seen that one
08:50:39 <bringert> with a flash demo video
08:51:10 <bringert> I need to fix it to give incremental feedback though
08:52:03 <quicksilver> I'll have a pepperoni feast with extra cheese, please
08:54:00 <kolmodin> bringert: the minutes in the text of the scripts are wrong.. it's two, one resp. three minutes :D
08:54:25 <bringert> ah, thanks
08:54:40 <bringert> the preparation time is generated randomly
08:54:56 <bringert> so it's different every time I run it, forgot to fix the script
08:55:11 <kolmodin> ah
08:55:36 <kolmodin> I'm off
08:55:43 <bringert> later
08:56:35 <bakert> ?pl sessionDetails <- retrieveSession; balance <- getBalance sessionDetails
08:56:35 <lambdabot> (line 1, column 34):
08:56:36 <lambdabot> unexpected ";"
08:56:36 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
08:56:41 <bakert> that went badly
08:56:47 <bakert> ?pl     sessionDetails <- retrieveSession
08:56:47 <bakert>     balance <- getBalance sessionDetails
08:56:48 <lambdabot> sessionDetails <- retrieveSession
08:56:58 <bakert> gah
08:57:01 <bakert> i am incompetent
08:57:22 <Saizan> ?pl do { sessionDetails <- retrieveSession; balance <- getBalance sessionDetails }
08:57:23 <lambdabot> (line 1, column 4):
08:57:23 <lambdabot> unexpected "{"
08:57:23 <lambdabot> expecting variable, "(", operator or end of input
08:57:44 <Saizan> ?pl do { sessionDetails <- retrieveSession; balance <- getBalance sessionDetails; return balance }
08:57:44 <lambdabot> (line 1, column 4):
08:57:44 <lambdabot> unexpected "{"
08:57:44 <lambdabot> expecting variable, "(", operator or end of input
08:57:47 <bakert> do i even mean "pl"?
08:57:50 <zbrown> [ x | x<-[0..3], comb 10 x ] <--- whats wrong w/ that list comprehension where the the function comb is a numerical combination calculator
08:57:53 <bakert> i want to see it with >>= in there.
08:58:08 <bringert> bakert, undo
08:58:11 <Saizan> ?undo do { sessionDetails <- retrieveSession; balance <- getBalance sessionDetails; return balance }
08:58:11 <lambdabot> retrieveSession >>= \ sessionDetails -> getBalance sessionDetails >>= \ balance -> return balance
08:58:13 <bakert> ah yes thanks
08:58:17 <Saizan> ?. pl undo do { sessionDetails <- retrieveSession; balance <- getBalance sessionDetails; return balance }
08:58:17 <lambdabot> getBalance =<< retrieveSession
08:58:28 <bakert> ooooh
08:58:35 <bakert> i knew there was something good in there!
08:58:50 <bringert> I think retrieveSession >>= getBalance is nicer
08:59:12 <bringert> but the first is more like application, which is nice too
08:59:17 * bringert can't decide
08:59:45 <bakert> i think >>= but that's because i'm only half haskellised at this stage!
09:00:20 <Saizan> i think it depends on if and where you have to put this inside a chain of compositions
09:00:52 <bakert> the whole routine is just - retrieveSession then send those details to getBalance then put the result of that in the field of a record.
09:01:03 <bakert>     return Funds { fnTime = undefined, fnBalance = balance, fnStake = 0.0,
09:01:03 <bakert>                    fnPending = 0.0, fnBets = 0 }
09:01:10 <bakert> (oops, ugly paste!
09:01:11 <bakert> )
09:02:35 <Saizan> ?pl fmap (\balance -> Funds { fnTime = undefined, fnBalance = balance, fnStake = 0.0, fnPending = 0.0, fnBets = 0 } ) $ getBalance =<< retrieveSession
09:02:35 <lambdabot> (line 1, column 25):
09:02:36 <lambdabot> unexpected "{"
09:02:36 <lambdabot> expecting variable, "(", operator or ")"
09:02:47 <bakert> woah
09:03:02 <Saizan> gah, pl doesn't like records
09:03:04 <bakert> why is it everything i ever do in haskell ends up being a one-liner.
09:03:05 <bakert> ?
09:03:08 <desp> ?seen bos
09:03:08 <lambdabot> bos is in #haskell. I last heard bos speak 11h 36m 8s ago.
09:03:17 <bakert> i think i'll have to start trying more difficult stuff!
09:03:26 <Saizan> :D
09:03:33 <quicksilver> zbrown: maybe you meant [comb 10 x | x <- [0..3]] ?
09:03:48 <Saizan> well it doesn't mean is more readable if it's on one line..
09:03:59 <sjanssen> @remember bakert why is it everything i ever do in haskell ends up being a one-liner.
09:04:00 <lambdabot> Done.
09:04:06 <Saizan> s/is/that is/
09:04:17 <quicksilver> more than one line and I have a terrible headache the next morning, anyway
09:05:11 <Saizan> @quote haskell.form
09:05:11 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
09:06:56 <chessguy> well, that was a conversation-stopper, Saizan :)
09:08:54 <Saizan> chessguy: heh, but now i'm remembering some hpaste functions to build html, still one line but written down as several of them
09:09:22 <chessguy> tut tut
09:09:44 <dolio> Looks like rain?
09:10:18 <Saizan> rain?
09:11:04 <dolio> Winnie the Pooh.
09:12:17 <chessguy> heh. i recently read a formal text on abductive inference that quoted (and cited) Winnie the Pooh
09:12:53 <dolio> Heh.
09:14:11 <chessguy> the author was arguing that Winnie the Pooh was clearly using abductive inference to determine the contents of the jar that said "Hunny" on it
09:14:40 <chessguy> hi shapr :)
09:14:50 <scriptdevil> how do i enter multiline statements in ghci?
09:15:08 <glguy> :l filename.hs
09:15:13 <desp> :t nullPtr
09:15:15 <lambdabot> Not in scope: `nullPtr'
09:15:20 <desp> :hoogle nullPtr
09:15:30 <desp> @hoogle nullPtr
09:15:30 <lambdabot> Foreign.Ptr.nullPtr :: Ptr a
09:15:35 <Saizan> > do { x <- [1..5]; return (x,x) }
09:15:37 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5)]
09:16:02 <scriptdevil> how do i enter multiline statements in ghci? i mean without putting it in a file..
09:16:06 <desp> if a C function returns 0 and the result is captured into Ptr a, will it be equal to nullPtr?
09:16:29 <scriptdevil> desp .. i think NULL in C is '\o'
09:16:31 <Saizan> scriptdevil: a do-block? or a let .. in?
09:16:46 <scriptdevil> Saizan: function declaration.. with a case statement
09:16:50 <desp> scriptdevil: uh... '\o'? what?
09:16:55 <scriptdevil> \0
09:16:57 <scriptdevil> sorry
09:17:06 <desp> '\0' is the ASCII NUL character
09:17:14 <desp> which incidentally has the decimal value 0
09:17:27 <desp> so yes, NULL is also 0x00
09:17:32 <desp> but the question remains
09:17:49 <scriptdevil> desp: we can do cptr = NULL
09:17:52 <chessguy> desp, don't the FFI docs say?
09:18:28 <scriptdevil> Saizan: Actually anything...
09:19:12 <Saizan> for function declaration you must use a let, like: let f 1 = 2; f x = case even x of True -> 2; False -> 1; f _ = 5
09:19:30 <chessguy> scriptdevil, you can't enter multiple lines at the ghci prompt, you have to use the appropriate haskell syntax to combine them into a single line
09:19:45 <scriptdevil> oh.. ok....
09:19:47 <kosmikus> bringert: yes, you can
09:20:01 <chessguy> (AFAIK)
09:20:03 <bringert> kosmikus: sweet, how?
09:20:03 <desp> chessguy: they don't say, apart from that the alloc functions return nullPtr on failure
09:20:12 <kosmikus> bringert: otoh, I don't know why people are so afraid of running their main file through lhs2TeX ...
09:20:38 <desp> but since they're Haskell functions, that doesn't really say anything meaningful
09:20:54 <mauke> desp: yes, C null pointers map to nullPtr
09:21:01 <desp> mauke: thank you!
09:21:14 <Saizan> mmh, actually we could extend this a bit like on the python prompt.. but given function composition this use of the interpreter is not so useful in haskell
09:21:25 <bringert> kosmikus: I have another related question, which perhaps is more reasonable: in my thesis, I want to include several articles. one of them is written with lhs2TeX. how do I sensibly include that without running lhs2TeX on the whole thing?
09:22:10 <bringert> kosmikus: the reason why I'd like to try to avoid running lhs2TeX on the whole thing is that I'd like to keep the build simple
09:22:37 <bringert> kosmikus: but it's not that critical I guess
09:23:00 <kosmikus> bringert: basically, what you already tried should work
09:23:17 <bringert> what about the preamble stuff?
09:25:46 <kosmikus> bringert: you have to make one .sty yourself
09:26:34 <kosmikus> bringert: create a file, call it whatever you like, say xyz.lhs and include there the lhs2TeX-preamble you're using for your other documents
09:26:50 <kosmikus> bringert: in the simplest case, this is just a one-liner %include polycode.fmt
09:26:59 <kosmikus> bringert: but maybe you're using other formats and setup
09:27:13 <bringert> and how do I get lhs2TeX to not emit the preamble stuff when I run it on the code?
09:27:17 <kosmikus> bringert: run this through lhs2TeX and name the result xyz.sty
09:27:32 <DukeDave> Hey gang, I'm just reading a tutorial and writer refers to the ( ) as in 'm ( )' as 'coin', anyone else use this phrase? :O
09:27:42 <kosmikus> bringert: it'll emit the preamble stuff, but it shoudn't do any harm
09:28:25 <DukeDave> in context "The putStrLn function takes a string and returns IO coin"
09:28:30 <kosmikus> there's a check that'll make TeX skip that part if it's already been read
09:30:17 <shapr> hiya chessguy
09:30:38 <bringert> kosmikus: ah, great, that works! thank you! I had read the FAQ entry about it, but I did understand the part about how it managed to ignore the preamble stuff if it was already there
09:30:44 <bringert> eh, didn't
09:31:09 <bringert> kosmikus: I should have just tried it. sorry for bothering you. thanks again!
09:31:09 <kosmikus> why do you have to understand it? you just have to try it ;)
09:31:13 <bringert> yeah
09:31:22 <kosmikus> np
09:31:48 <kosmikus> it's good to have users ;)
09:32:27 <bringert> there's not a single line of haskell in this paper, but lhs2TeX makes it look much better than lstlistings
09:34:20 <kosmikus> bringert: hehe
09:34:33 <kosmikus> what language was it again?
09:35:27 <bringert> kosmikus: GF
09:35:46 <scriptdevil> i dont know why.. haskell has the steepest learning curve among popular languages.. but i hardly find a single meritorius "Why haskell sucks" file yet.. probably people shut up fearing the name "idiot:
09:36:11 <scriptdevil> .. cut the yet in that sentence
09:37:37 <Botje> scriptdevil: haskell mostly sucks library-wise
09:37:46 <Botje> and that issue is easily solvable.
09:38:06 <Botje> (fsvo 'easily')
09:39:39 <therp> steep learning curve? that's certainly true, but once you've learned it, it feels like you can move huge amount of concrete blocks with a few lines of monad combinators.
09:40:04 <procyon>  I've seen Haskell sucks papers.  From Lisp people sniggling at space leaks mostly.
09:40:28 <scriptdevil> Botje: i have never quit learning a language and retried these many times... it has been C/C++/Java/Python/(Haskell)/Lisp/(Haskell)/Perl/(Haskell)/Ruby/...Present .. Haskell
09:40:50 <therp> today I prepared my talk for a Lisp conference. I see I will get bashed for advocating side effect free, functional, and typed programming.
09:41:24 <scriptdevil> procyon: i dont agree that lisp is the perfect language... it is actually.. yawn.. me working to please the compiler's parser.. :-/
09:41:44 <mauke> lisp isn't meant to be written by humans
09:41:56 <scriptdevil> mauke: TRUE!!!!!
09:41:56 <therp> that's so wrong.
09:43:05 <scriptdevil> the only merit of lisp is.. you can do everything wth it.. if only lisp had scheme's uniformity..
09:43:07 <therp> get a decent editor like emacs and Lisp will feel superior to anything haskell-mode can give you.
09:43:13 <procyon> meh.  List syntax makes for good macroing, which you really can't do in any other language.
09:43:38 <mauke> therp: emacs is too annoying to use
09:43:41 <cjeris> procyon: isn't the haskell slogan "macros are nice, but type-checked combinators are better" ?
09:43:48 <scriptdevil> I love emacs...
09:43:49 <therp> mauke: I disagree
09:43:49 <procyon> therp: that's not saying much.  Haskell mode generally gives me headaches :)
09:44:10 <scriptdevil> procyon: haskell needs an editor.. true
09:44:38 <scriptdevil> basically it is emacs for dynamic languages.. and vi for compiled languages for me
09:44:42 <kscaldef>  therp: I use emacs, but it doesn't make writing lisp (elisp) fantastically simpler for me
09:45:02 <scriptdevil> kscaldef: slime is the best env on emacs...
09:45:10 <procyon> cjeris: macros are nice, type checked combinators are nice too :)  I might play with Liskell after mastering Haskell better.. but the language I really want to go play with is Erlang.
09:45:16 <kscaldef> haven't tries slime
09:45:23 <scriptdevil> sad i dont have a shine superior haskell in emacs
09:45:24 <therp> kscaldef: not? you might want to look at a decent configuration of slime http://www.cliki.net/Editing%20Lisp%20Code%20with%20Emacs
09:45:26 <lambdabot> Title: CLiki : Editing Lisp Code with Emacs
09:45:49 <kosmikus> bringert: hmm, what's GF?
09:45:51 <therp> scriptdevil: there is shim http://shim.haskellco.de/trac/
09:45:53 <lambdabot> Title: shim - Trac
09:45:55 <kosmikus> bringert: is that your language?
09:45:56 <bringert> @where GF
09:45:56 <lambdabot> http://www.cs.chalmers.se/~aarne/GF/
09:46:18 <bringert> kosmikus: no, it's a grammar formalism for natural language
09:46:36 <bringert> kosmikus: it's rather my supervisor's language
09:46:36 <therp> @where shim
09:46:36 <lambdabot> http://shim.haskellco.de/trac/
09:46:42 <kosmikus> bringert: yes, I've seen that page before.
09:46:46 <kscaldef> I'll take a look.  I'm pretty experienced with emacs.  I guess I'm saying that I don't find writing elisp with emacs substantially nicer than writing any other language with a decent major mode
09:47:06 <kscaldef> but, I don't write much elisp compared to other languages
09:47:09 <kosmikus> bringert: do you have a syntax example? or even an lhs2TeX output example?
09:47:20 <therp> kscaldef: reindention and code restructing is so easy with slime. that's what I like about slime and dislike in haskell-mode
09:47:28 <kscaldef> curious: what don't people like about haskell mode?
09:47:36 <therp> but Liskell will take over world domination anyway soon.
09:47:42 <procyon> reindentation
09:47:46 <kscaldef> I find it sometimes misindents, but that's common to basically every language mode
09:47:50 <therp> procyon: thanks
09:48:01 <mauke> does elisp do escape sequences? like "foo\tbar\nbaz" in strings?
09:48:15 <kscaldef> hmm.... is it possible to have easy reindentation in a whitespace sensitive language?
09:48:43 <bringert> kosmikus: here's a demo written using my GF work: http://www.cs.chalmers.se/~bringert/xv/pizza/ here are some syntax examples from that demo: http://www.cs.chalmers.se/~bringert/xv/pizza/Pizza.gf http://www.cs.chalmers.se/~bringert/xv/pizza/PizzaEng.gf
09:48:44 <lambdabot> Title: Pizza Demo - GF XHTML+Voice - Description
09:48:56 <therp> kscaldef: it might be, but still code navigation is not that natural as with move-forward/backward-sexp in paredit mode in slime
09:49:09 <doserj> haskell-mode cycles between possible indentations
09:49:12 <bringert> kosmikus: I'm not done with the lhs2TeX output yet
09:49:50 <kosmikus> bringert: yes, it looks like it's not too difficult to coerce lhs2TeX into producing nice output for that
09:50:09 <kscaldef> doserj: that's true, but sort of irrelevant
09:50:24 <kscaldef> if you relocate a section of code, you have to reindent every line by hand
09:50:28 <kscaldef> that's the complaint
09:50:46 <kscaldef> also, sometimes haskell-mode is ignorant of the correct indentation choice
09:50:50 <doserj> agreed
09:51:34 <kscaldef> the problem is, this seems like a nearly insurmountable problem in a language that uses whitespace as syntax
09:52:05 <kscaldef> at least, without embedding the language parser into your editor
09:52:14 <therp> kscaldef: I agree. my solution is to change the syntax (which gives other benefits as well)
09:52:32 <doserj> yes. HaRe might theoretically be more suited for this
09:52:36 <bakert> ?hoogle [] -> (a, a)
09:52:36 <bringert> hmm, lsh2TeX doesn't like #:s in my code
09:52:36 <lambdabot> No matches, try a more general search
09:52:44 <bakert> ?hoogle [a] -> (a, a)
09:52:45 <lambdabot> No matches, try a more general search
09:53:24 <bakert> ah,  no.  always think "pattern matching"!
09:53:35 <procyon> kscaldef: c-mode imbeds the parser into the editor.  Haskell syntax is WAY simpler than c++
09:53:37 <bringert> kosmikus: I get "You can't use `macro parameter character #' in restricted horizontal mode." when I have a # in a -- comment
09:53:50 <kscaldef> procyon: no it doesn't
09:54:03 <quicksilver> bakert: pattern-matching in guards is handy for that
09:54:12 <kscaldef> it embeds a simplified model of the parser
09:54:22 <kscaldef> also, c++ is way harder to parse than c
09:54:30 <quicksilver> bakert: fun f (x:y:[]) = do_something_with (x,y) ; fun f _ = error "expected 2-element list"
09:54:55 <procyon> kscaldef: c++ is nearly impossible to parse ;)  But c-mode does a decent job of it.
09:54:55 <kosmikus> bringert: comments are text-mode TeX
09:55:02 <bakert> I'm in a case ... so i can just do [a, b, c] -> blah (a, b, c) ... cool
09:55:28 <quicksilver> kscaldef: haskell-mode has a pretty good stab at a haskell parser
09:55:36 <quicksilver> kscaldef: it wouldn't be that hard to turn it into a perfect one
09:55:39 <kscaldef> procyon: yes, well many modes do a decent, but imperfect job of parsing their languages
09:55:58 <quicksilver> kscaldef: I don't think whitespace is particularly harder to parse, for a computer program, than any other kind of syntax
09:55:58 <bringert> kosmikus: hmm, it's a GF pragma. maybe I can tell lhs2TeX that "--#" does not start a comment
09:56:02 <kscaldef> quicksilver: sounds great, when''ll it be ready?
09:56:21 <doserj> quicksilver: even ghc or hugs are not really compliant...
09:56:31 <quicksilver> kscaldef: I haven't noticed haskell-mode get anything badly wrong, yet...
09:56:36 <quicksilver> doserj: because they choose not to be, surely
09:56:42 <quicksilver> doserj: not because parsers are hard to write
09:57:07 <procyon> I've thought about fixing haskell-mode, but the thought of elisp hacking on that scale makes me go drink instead.
09:57:11 <kscaldef> the problem is moving code around and getting the indentation right.  Particularly when there are multiple possible indentations
09:58:07 <bakert> is there a lib to get an md5 hash of a string?
09:58:39 <SamB> there is a module around somewhere...
09:58:43 <quicksilver> kscaldef: yes, but the main 'deficiency' of haskell-mode in taht respect is just that it doesn't reindent a whole chunk at once
09:58:53 <quicksilver> kscaldef: personally I use indent-rigidly in that case
09:59:30 <glguy> when the meaning of the program depends on the whitespace, you can't very well have a program know the proper indenting :)
10:00:05 <kosmikus> bringert: do you have to typeset it?
10:00:13 <procyon> glguy: but you can have it retain relative indenting.
10:00:40 <bringert> kosmikus: not really, I guess
10:01:17 <quicksilver> glguy: you can have it (a) know all the sensible choices and (b) reindent blocks whilst retaining relative structure
10:01:25 <SamB> the HTTP library seems to be associated with an MD5 module...
10:01:27 <quicksilver> glguy: haskell-mode manages (a) rather well, but not (b)
10:01:37 <kosmikus> bringert: then I'd recommend to just %if style == newcode ... %endif it
10:02:47 <bringert> kosmikus: my source file is not literal code, there is no literate GF format. I add \begin{code} etc using my Makefile
10:03:22 <procyon> I'd also like it to manage haskell text in blocks instead of lines, so if I increase the length of a line, moving an indentation stop, the block tied to that stop will move as a unit.
10:03:37 <glguy> NumeralDemo couldn't parse "One hundred twenty"
10:04:17 <bringert> glguy: was that for me?
10:04:29 <glguy> I'm just being a pest, it uses the British convention :)
10:04:55 <bringert> glguy: patches are welcome :-)
10:05:02 <kosmikus> bringert: does GF support --# LINE pragmas?
10:05:14 <bringert> kosmikus: no
10:05:55 <bringert> glguy: wanna submit an en-US version of the numerals grammar?
10:06:05 <kosmikus> bringert: then I'd %subst comment to something that catches the #
10:06:11 <glguy> all I know about GF is that it has that applet :)
10:06:43 <glguy> the only difference I'm aware of is that the british use "and" in whole numbers and the americans don't
10:06:52 <bringert> kosmikus: what could that be? I'm far from a latex guru
10:07:13 <glguy> 120.1 is "one hundred and twenty point one" or "one hundred twenty and one tenth"
10:07:31 <glguy> iirc, I've never actually been to Europe :)
10:07:44 <Igloo> glguy: But not "one hundred twenty point one"?
10:08:02 <kosmikus> bringert: I have to test this, so it'll take a minute.
10:08:07 <procyon> glguy: the and is optional in en-us.  either is correct.
10:08:32 <quicksilver> what about three score and ten, in furlongs per fortnight?
10:08:46 <glguy> I guess it's regional, my grade schools just said it was wrong
10:09:06 <glguy> but its also possible I had misinformed teachers :)
10:09:14 <fiete> are there predefined makros like __LINE__ for ghc?
10:09:44 <procyon> glguy: Well, I do speak westcoast-us-en, which is a bit different than alternatives ;)
10:10:00 <glguy> I did k-6 in socal
10:11:08 <procyon> hmm.  Me too, and I was taught to speak the and.  It was only as a teen that I started dropping it in my common speech.  Of course, I was taught in Fresno, so that might be my problem.
10:11:31 <Philippa_> if I'm dictating a number I'll just give a string of digits anyway
10:12:16 <procyon> But it's weird that we were taught divergent dialect rules *in the space of socal*.
10:13:12 <glguy> I think that's more bothersome is that different people differ on whether billion is 10^9 or 10^12
10:13:18 <glguy> and trillion 10^12 or 10^18
10:13:31 <glguy> depending on world location
10:13:42 <vincenz> giga, tera, eta, peta
10:13:57 <procyon> What's a few orders of magnitude amongst friends?
10:14:35 <sioraiocht> that may be the best thing I'll hear all day?
10:14:42 <sioraiocht> s/?/./
10:15:13 <Philippa_> glguy: not that many people in the UK really use billion for 10^12 except among people they know
10:15:21 <Philippa_> our papers don't
10:15:22 <quicksilver> billion being 10^12 is pretty much dead now
10:15:31 <quicksilver> it's just something historical to mourn
10:15:38 <vincenz> CosmicRay: any reason you're not blogging about darcs?
10:15:50 <quicksilver> the financial community all use billion for 10^9
10:15:59 <sioraiocht> quicksilver: that's good to hear, I always avoided references to million and billion in my uni apps to over there, lol
10:16:00 <quicksilver> and the scientific community tend to use precise SI units or scientific notation :)
10:16:27 <quicksilver> but, e.g., company valuations and budget reshuffles are all put in terms of Ј1B = 10^9
10:16:32 <glguy> I can find things like this in wikipedia: "120 (one hundred twenty in American English; one hundred and twenty in British English)"
10:16:35 <Philippa_> there're better terms for "random big figure", anyway
10:16:38 <procyon> Off to work to turn off more Windows boxes... see ya.
10:16:40 <glguy> but I can't find the article that breaks down all the differences
10:16:57 <sioraiocht> glguy: that's odd
10:17:16 <dmhouse> glguy: I can tell you that both are used here (Britain), the 'American' English one being much more common, though.
10:17:16 <sioraiocht> glguy: "and" formally means the beginning of a fractional part of a number
10:17:19 <doserj> http://en.wikipedia.org/wiki/American_and_British_English_differences
10:17:21 <lambdabot> Title: American and British English differences - Wikipedia, the free encyclopedia, http://tinyurl.com/4ezjg
10:17:37 <CosmicRay> vincenz: nothing much to say about it right now
10:17:55 <CosmicRay> vincenz: if they get doppleganger fixed, I'll have something to say ;-)
10:17:59 <glguy> doserj: seems obvious now :)
10:18:05 <doserj> :)
10:20:37 <vincenz> CosmicRay: doppleganger?
10:20:38 <funes8519> Hi
10:21:08 <kosmikus> bringert: hmm, this seems to be more difficult than I imagined
10:21:15 <funes8519> I'm trying to use HGL from Hugs
10:21:21 * kolmodin is home from work
10:21:24 <funes8519> it seems to be included in the Hugs distribution...
10:21:50 <bringert> kosmikus: I can get rid of it with grep in my Makefile if it's too hard to do with lhs2TeX
10:21:56 <funes8519> When I try to
10:22:02 <CosmicRay> vincenz: http://darcs.net/DarcsWiki/FrequentlyAskedQuestions?highlight=%28doppleganger%29#head-76fb029ff6e9c20468eacf3ff00d791e2cf03ecb
10:22:06 <funes8519> import Graphics.HGL
10:22:09 <lambdabot> Title: FrequentlyAskedQuestions - DarcsWiki, http://tinyurl.com/ypc3n4
10:22:21 <bakert> Trying to get an md5 hash of a string.  I've found a library that will do it for me.  The function I need has the following signature:
10:22:21 <bakert> > md5s :: (MD5 a) => a -> String
10:22:22 <lambdabot>   Not in scope: type constructor or class `MD5'
10:22:37 <bakert> What I get back from it is an (MD5.MD5 String)
10:22:41 <funes8519> ERROR "D:\PROGRAMAS\HUGS\packages\Win32\System\Win32\Process.hs" - Error while importing DLL "D:\PROGRAMAS\HUGS\packages\Win32\System\Win32\Process.dll"
10:22:43 <bakert> How can I just use that like a normal String?
10:22:52 <quicksilver> that type signature doesn't say that
10:22:59 <quicksilver> that type signature says it gives you a plain string
10:23:06 <bakert> quicksilver, hmmm.  that's what i thought.
10:23:12 <quicksilver> did you copy it wrong, or are you misunderstanding an error message? :)
10:23:36 <kosmikus> bringert: that's probably easier for now
10:23:41 <bakert> It's the "tom can't read haskell error messages problem" i think!  It says: "    No instance for (MD5.MD5 String)"
10:24:16 <quicksilver> it's complaing about the input then, not the output
10:24:26 <bakert> Ah.  Is it.  That would make sense.
10:24:30 <quicksilver> it's saying "this 'a' needs to be a member of class 'MD5'
10:24:33 <bakert> How did you know that?
10:24:34 <quicksilver> where did you find this code?
10:24:49 <quicksilver> No instance for MD5 String ---> String is not an 'MD5'
10:24:49 <bakert> http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/md5/
10:24:50 <lambdabot> Title: MD5 in Haskell
10:24:51 <bringert> kosmikus: ok, thanks
10:24:56 <quicksilver> Igloo: it's all your fault!
10:25:01 <bakert> quicksilver, ah i see.
10:25:31 <bakert> quicksilver, in my simple ways i thought MD5 was some kind of class/monad monstrosity wrapping itself around the output of md5s
10:25:37 <bakert> doh
10:25:58 <Igloo> Hmm, that code could really do with updating
10:26:01 <bakert> So the problem is that md5s takes some kind of wrapped input not just a plain string.
10:26:07 * quicksilver nods
10:26:10 <bakert> So I have to work out how to do the wrapping.
10:26:15 <quicksilver> looks like 'Str' is the magic to wrap a string
10:26:16 <quicksilver> I believe
10:26:22 <quicksilver> putStr $ md5s (Str c)
10:26:25 <quicksilver> (from the sample code)
10:26:30 <kosmikus> bringert: well, here's a really lame hack that'd work in this case: %subst comment a = "\mbox{\onelinecomment\" a "}"
10:26:31 <quicksilver> (where 'c' is in fact a String)
10:26:36 <kosmikus> bringert: but it's not very robust
10:26:44 <bakert> Where in the hell did you get that from?!
10:26:49 <quicksilver> http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/md5/haskell-md5-0.2.7/MD5Sum.dpkg.lhs
10:26:51 <lambdabot> http://tinyurl.com/28m2q8
10:26:55 <quicksilver> always read the example code :)
10:26:58 <kosmikus> bringert: and it requires that non-pragma comments are introduced by "-- " with a space following the minus
10:27:06 <bakert> Ah I see -- i need to look in the type stuff not just in the "exported functions".
10:27:12 <bakert> I am being a bit dim.
10:27:12 <funes8519> Hi, I'm trying to use HGL from Hugs, and a symple import Graphics.HGL isn't working.
10:27:19 <funes8519> *simple
10:27:20 <bakert> Or, indeed, example code.
10:27:27 <bakert> Should have thought of that myself really.
10:27:33 * bakert berates self
10:27:39 <quicksilver> the only reason Igloo didn't make 'String' an instance of MD5 directly
10:27:44 <quicksilver> was that haskell98 doesn't allow him to
10:27:52 <quicksilver> if he was prepared to go -fglasgow-exts
10:28:03 <quicksilver> he could have made String and instance of MD5 and wrapping wouldn't be needed
10:28:18 <bakert> Much better.  Thanks quicksilver.
10:28:27 <quicksilver> at least, I'm putting words into his mouth
10:28:32 <quicksilver> but I imagine that's why :)
10:28:42 <Igloo> You're almost certainly why
10:28:46 <Igloo> Err, s/why/right/
10:28:55 <sjanssen> quicksilver: you can make String an instance of MD5, but it requires asinine gymnastics
10:28:55 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
10:29:03 <bringert> kosmikus: great, thanks. I'll see which one I go with in the and
10:29:05 <bringert> end
10:29:28 <bringert> kosmikus: you've got to be one of the most acknowledged people in the Haskell community
10:29:40 <sjanssen> class IsStringType a where id' :: [a] -> String; instance (IsStringType a) => MD5 [a] where ...
10:29:50 * quicksilver nods
10:29:58 <quicksilver> sjanssen: or just switch on glasgow-exts :)
10:30:14 <sjanssen> right
10:30:27 <leshaste> why do we always use 'div' in haskell and not / ?
10:30:31 <quicksilver> sjanssen: I presume Igloo wasn't aware of the IsStringType trick
10:30:36 <quicksilver> leshaste: div is for integers
10:30:42 <quicksilver> leshaste: / is for fractions
10:30:47 <quicksilver> :t div
10:30:48 <quicksilver> :t /
10:30:50 <lambdabot> forall a. (Integral a) => a -> a -> a
10:30:51 <lambdabot> parse error on input `/'
10:30:52 <quicksilver> :t (/)
10:30:54 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:30:55 <Igloo> bringert: What was that in reply to?
10:31:09 <leshaste> quicksilver, thx.. I didn't even know there was a Fractional type :)
10:31:17 <quicksilver> leshaste: it's a class, technically
10:31:18 <leshaste> that's different from a real I assume?
10:31:38 <sjanssen> Fractional is a class of operations
10:31:41 <sjanssen> @instances Fractional
10:31:42 <lambdabot> Double, Float
10:31:47 <leshaste> aha
10:31:47 <bringert> Igloo: what I said to kosmikus? he helped me with some lhs2TeX magic
10:32:08 <Igloo> Oh, OK
10:32:12 <leshaste> @instances Integral
10:32:13 <lambdabot> Int, Integer
10:32:17 <bringert> Igloo: I figured that he helps lots of people with typesetting
10:32:41 <quicksilver> leshaste: lots of people in the haskell community are pretty pedantic, and to be *pedantic* you can't really conveniently model reals on a computer
10:32:46 <quicksilver> leshaste: since there are too many of them :)
10:33:11 <quicksilver> other languages like fortran just ignore this fact and equal Real with Float
10:33:13 <leshaste> quicksilver, :)
10:33:24 <leshaste> quicksilver, got to keep it real I suppose
10:33:51 <quicksilver> :)
10:33:56 <sjanssen> @instances RealFrac
10:33:57 <lambdabot> Double, Float
10:34:18 <sjanssen> quicksilver: we could stand to be more pedantic :)
10:34:35 <leshaste> I have to set some haskell exercises and I want to choose something that haskell is much better at than C or Java so that the students see the point
10:34:37 <leshaste> any ideas?
10:35:00 <quicksilver> depends how advanced they are
10:35:04 <sjanssen> leshaste: a typical example is a simple interpreter
10:35:08 <Philippa_> quicksilver: or in some cases with rationals
10:35:10 <quicksilver> one of the things I like is that you can abstract out repreating code
10:35:15 <leshaste> sjanssen, as in a language interpreter?
10:35:32 <quicksilver> so an example which is java is 20 copies of a 5 line code block
10:35:37 <quicksilver> but java can't factor that out
10:35:38 <sjanssen> leshaste: right, Haskell is king at that stuff
10:36:07 <leshaste> sjanssen, ok.. interpreting haskell might seem a little pointless... so what would you recommend?
10:36:28 <leshaste> a list interpreter maybe?
10:36:36 <Philippa_> yeah, or an extended lambda calculus
10:36:56 <leshaste> sounds good
10:36:58 <quicksilver> (because the entities aren't first-class, like class names)
10:36:59 <sjanssen> leshaste: depends on how much time/how experienced the students are.  An interpreter for math+variables should be a real quick project
10:37:05 * quicksilver nods
10:37:09 <quicksilver> just a plain 'calculator'
10:37:15 <Philippa_> sjanssen: four-operator arithmetic + variables
10:37:16 <leshaste> sjanssen, they did that :)
10:37:20 <leshaste> something more advanced
10:37:20 <Philippa_> maths in general is a bit trickier...
10:37:32 <Philippa_> leshaste: do a lambda calculus. It's simple enough
10:37:38 <sjanssen> Philippa_: yes, I should have said arithmetic
10:37:52 <leshaste> a little hard to motivate though as they don't know what lambda calculus is
10:38:02 <Philippa_> "a simple functional language"
10:38:03 <Saizan> lisp?
10:38:11 <leshaste> they are good programmers but not formally trained lets say
10:38:16 <Philippa_> do a CBV one with primitives
10:38:18 <leshaste> lithp lookth like a good bet
10:38:32 <leshaste> :)
10:38:41 <Philippa_> lisp's trickier than a CBV lambda calculus
10:38:57 <leshaste> what does CBV stand for?
10:39:00 <leshaste> three people?
10:39:01 <Philippa_> call-by-value
10:39:04 <leshaste> aha
10:39:04 <leshaste> :)
10:39:07 <sjanssen> church of the bound variable
10:39:14 <leshaste> I was never any good at acronyms
10:39:24 <leshaste> what about huffman coding or something like that?
10:39:38 <Philippa_> if you want, you can do the interpreter in the IO monad, and you really do get the core of a usable programming language
10:39:43 <sjanssen> leshaste: I've done that one before, that's not bad
10:39:48 <Philippa_> or you can do a statements-and-expressions imperative lang
10:39:55 <leshaste> no monads or IO at this point
10:39:59 <Philippa_> (still maths+variables, but with room for control statements)
10:40:00 <leshaste> sjanssen, ok thanks
10:41:57 <funes8519> Hi, I'm trying to use HGL from Hugs in Windows
10:42:02 <funes8519> but a simple
10:42:06 <funes8519> import Graphics.HGL
10:42:13 <funes8519> yields an error
10:42:17 <sjanssen> funes8519: in a file or from the hugs prompt?
10:42:26 <funes8519> in a file
10:42:52 <quicksilver> leshaste: if you want something more 'fun' why not somethin in openGL
10:43:03 <quicksilver> leshaste: something which builds a 3D scene from a simple scene description language
10:43:21 <funes8519> This is the error
10:43:24 <funes8519> ERROR "D:\PROGRAMAS\HUGS\packages\Win32\System\Win32\Process.hs" - Error while importing DLL "D:\PROGRAMAS\HUGS\packages\Win32\System\Win32\Process.dll"
10:43:33 <funes8519> Process.hs and Process.dll do exist
10:43:51 <quicksilver> funes8519: I know nothing about win32, sorry :(
10:44:19 <quicksilver> leshaste: or a declarative fireworks engine, builds a fireworks scene from a description language
10:44:34 <quicksilver> leshaste: my students used to love anything graphical, especially if I gave them enough framework to make it fairly easy
10:44:53 <Philippa_> yeah, and particle systems're always fun
10:45:11 <quicksilver> I set fireworks as an end-of-year project for some master's students
10:45:13 <quicksilver> (that was java)
10:45:18 <quicksilver> I got some really pretty submissions
10:45:22 <quicksilver> much more fun to mark, too!
10:46:09 <sjanssen> funes8519: have you tried all the standard Windows incantations? (uninstall/install again, try latest version of hugs, etc.)
10:46:27 <Saizan> pray?
10:46:33 <Philippa_> it can feel a little aggravating for non-artistic students if a significant amount of the marks go on aesthetics though
10:46:40 <funes8519> Actually this is the latest Hugs version, just installed
10:46:47 <ndm> funes8519: i think it got broken in the recent WinHugs versions, i recommend something pre-2006 if you want OpenGL
10:46:48 <lambdabot> ndm: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:47:18 <ndm> @seen SamB
10:47:18 <lambdabot> SamB is in #perl6 and #haskell. I last heard SamB speak 45m 53s ago.
10:47:22 <funes8519> Hmm, I think HGL != HOpenGL
10:47:25 <SamB> ndm: hello?
10:47:30 <funes8519> HGL seems to be for 2d graphics
10:47:40 <ndm> SamB: deferred binary isn't available because i haven't updated the website - i'm doing it right now though!
10:47:54 <ndm> SamB: as for being a code member, sure - i'll do that now
10:48:15 <SamB> ndm: hmm, sorear found me the URL in an email already anyway ;-)
10:48:17 <funes8519> Anyway I'll try with another Hugs version
10:48:18 <funes8519> Thanks
10:48:38 <SamB> at least, I think it was in an email
10:48:42 <bos> desp: you called?
10:48:45 <bos> ?seen desp
10:48:46 <lambdabot> desp is in #haskell. I last heard desp speak 1h 27m 44s ago.
10:49:05 <ndm> SamB: you're now a member of google code yhc group - you should be able to set flags etc - but you should have been able to file bugs even before that
10:49:16 <ndm> SamB: deferred binary is available on the darcs repo
10:49:37 <bos> what's a deferred binary when it's at home?
10:49:55 <ndm> bos: just trying to find it - i've forgotten where i put the darcs repo...
10:50:15 <SamB> ndm: yeah, the url for that. sorear found a url to a file in the repository, and we deleted stuff at the end to get the repository url
10:50:47 <ndm> http://www.cs.york.ac.uk/fp/darcs/binarydefer/binarydefer.htm
10:50:48 <lambdabot> Title: Deferred Binary Serialisation
10:50:50 <shapr> Why doesn't System.Time.ClockTime have a Read instance?
10:50:57 <ndm> bos: that document gives details
10:51:03 <ndm> SamB: are you wanted to use deferred binary?
10:51:54 <SamB> ndm: I was going to reserve judgement until I figured out what it can do
10:52:21 <bos> ndm: cute
10:52:27 <ndm> SamB: what are you hoping to do? if you want a big file which you need to load parts from as required but treat as one abstract data structure, its the right thing
10:52:34 <ndm> SamB: if that isn't what you need, it isn't
10:53:18 <SamB> ndm: exactly
10:53:33 <Saizan> so Data.Binary.decodeFile is strict?
10:53:55 <SamB> but sometimes things are "the right thing" for something they cannot, in fact, be used for (at least without modification);-)
10:53:57 <ndm> Saizan: it is linear, you load the file as you see it - its strict in all the bits up until the bit you want
10:54:08 <ndm> SamB: i'm happy to take patches
10:54:35 * SamB is hoping to write a linker
10:55:23 <Saizan> ndm: instead with deferred binary you can seek without forcing the intermediate bits?
10:55:47 <ndm> Saizan: you don't seek, you just work on a big data structure - underneath it seeks as appropriate
10:56:05 <ndm> Saizan: the whole point is its pure, and requires no complex seek stuff - but is still lazy
10:56:14 * shapr cries at the Haskell time libraries.
10:56:38 <SamB> ndm: so, do you think I can use it to read ELF files?
10:57:05 <ndm> SamB: i'd say unlikely - it is designed to define its own binary format
10:57:13 <zbrown> If I have two 'if' statements, and the else doesn't matter, what do put in it to make the compiler happy so that it doesn't bitch about not having an else?
10:57:18 <ndm> SamB: you may be better off with dons Data.Binary for that
10:57:24 <bringert> shapr: use Data.Time
10:57:32 <SamB> well, at least I might be able to steal ideas
10:57:34 <bringert> shapr: preferrably from darcs
10:57:40 <sm> shapr: they are a bit tricky aren't they
10:57:42 * bringert goes home
10:58:12 <nominolo> zbrown: an element of the right type
10:58:17 <nominolo> ;)
10:58:26 <zbrown> actually nm i figured it out ;)
10:59:03 <Philippa_> zbrown: you don't have two 'if' statements then, surely? You have one, with a condition you can guarantee on the second branch
10:59:24 <zbrown> Philippa_: i figured it out, no big deal, was jsut being dumb
10:59:31 <zbrown> was overlapping my pattern matching
11:00:25 <dolio> Well, there's always the possibility of having an if in a monad where you're running something purely for the side effects.
11:00:34 <dolio> In which case 'return ()' is usually the right answer, I guess.
11:01:29 <psi`> :t when
11:01:31 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:02:00 <dolio> Ah, well, that'd do it to, I guess. :)
11:03:38 <shapr> @where data.time
11:03:38 <lambdabot> I know nothing about data.time.
11:03:40 <shapr> hmm
11:04:06 <chessguy> @source Data.Time
11:04:06 <lambdabot> Data.Time not available
11:04:10 <chessguy> ?hoogle Time
11:04:11 <lambdabot> System.Time :: module
11:04:11 <lambdabot> Time :: module
11:04:11 <lambdabot> System.Locale.TimeLocale :: ([(String, String)] -> [(String, String)] -> [(String, String)] -> String, String -> String -> String -> String -> String -> TimeLocale)
11:04:21 <chessguy> @source System.Time
11:04:21 <lambdabot> http://darcs.haskell.org/packages/base/System/Time.hs
11:05:10 <zbrown> how would i write a negative sign in haskell, like if iw anted to multiply by -1
11:05:13 <zbrown> ?
11:05:24 <chessguy> > negate 4
11:05:25 <lambdabot>  -4
11:05:29 <psi> > 3 * -1
11:05:30 <lambdabot>      precedence parsing error
11:05:30 <lambdabot>         cannot mix `(*)' [infixl 7] and prefix ...
11:05:31 <zbrown> ok
11:05:37 <chessguy> ?src negate
11:05:38 <lambdabot> negate x = 0 - x
11:05:44 <psi> > 3 * (-1)
11:05:46 <lambdabot>  -3
11:05:53 <zbrown> oh ok
11:06:36 <zbrown> thanks psi
11:06:36 <chessguy> i wonder if one gets optimized better by the compiler
11:14:02 <chessguy> anybody very familiar with the book Haskell School of Expression?
11:14:21 * SamB would like to see a framework for dealing with pre-existing binary file formats
11:14:23 <chessguy> i have a general question about the Behavior type that he develops
11:14:47 <SamB> chessguy: I leant my copy to a friend. I don't think he's used it, but he also has not returned it...
11:15:03 <chessguy> :(
11:15:11 <chessguy> my copy's at home
11:15:21 <chessguy> anyway, i think Behavior is a monad
11:16:27 <ndm> SamB: i think Data.Binary aimed to do that somewhat
11:16:36 <chessguy> i can't remember specifically whether he develops a function of type Behavior a -> (a -> Behavior b) -> Behavior b, but it seems monadic to me
11:17:08 <chessguy> oh! i can look at his code again
11:19:13 <sjanssen> SamB: Data.Binary should be able to handle most binary formats
11:19:42 <SamB> dons didn't seem to think that that was what it was for
11:19:46 <chessguy> hm, doesn't look like he develops a function of that type :(
11:20:02 <sjanssen> there's a couple tricky things.  Structures that aren't byte aligned for one
11:20:22 <SamB> what is so tricky about that
11:20:23 <SamB> ?
11:30:27 <sjanssen> SamB: allowing for full bit-aligned stuff would make the entire library slower
11:31:24 <vincenz> damn
11:31:25 <vincenz> this sucks
11:31:37 <vincenz> foo :: a -> b
11:31:38 <SamB> sjanssen: oh, *that*
11:31:39 <vincenz> foo = ...
11:31:42 <vincenz>   where x :: a
11:31:44 <vincenz>      x = ...
11:31:51 <vincenz> it doesn't like the fact that those two a's are the same
11:31:57 <vincenz> (they'rer inferred to be the same a's)
11:32:05 <vincenz> which I rightly put so
11:32:19 <Igloo> vincenz: If you put forall a . before the first one then I think it should work
11:32:20 <sjanssen> vincenz: type variables aren't scoped by default
11:32:27 <vincenz> sjanssen: ah, for shame
11:32:28 <Igloo> (in ghc, with -fglasgow-exts)
11:32:34 <SamB> no, I meant a general purpose framework, not a framework for multimedia/compressed data
11:32:55 <vincenz> Igloo: no t's got to do with typing, I know they're the same a, but because I type annotate x, it thinks that 'a' is a different 'a' and it doesn't like that
11:32:56 <SamB> MOST formats do not involve non-byte-aligned access of that type
11:33:01 <vincenz> erm, scoping even
11:33:04 <vincenz> it's counterintuitive
11:33:20 <Igloo> vincenz: Right, but putting the forall in makes it a scoped type variable IIRC
11:33:37 <Igloo> I may be out of date on what the rules are, though
11:33:56 <vincenz> Igloo: you mean for the 'x' then not for the func-def
11:33:58 <vincenz> ?
11:34:31 <Igloo> I mean in foo's typesig
11:34:32 <vincenz> putting in a forall i makes all my other variables unknown :/
11:34:38 <vincenz> meaning I have to forall em all
11:35:22 <vincenz> oh well
11:35:58 <vincenz> Igloo: thanks that worked :)
11:36:12 <sjanssen> SamB: there are some other issues.  Data.Binary also doesn't handle formats that refer to byte offsets in other parts of the file very well
11:37:38 <vincenz> gotta love incremental design with type-annots and undefined :)
11:37:57 <vincenz> slowly build up some complex function knowing you're not making mistakes through typing
11:40:38 <huschi> ?hpaste
11:40:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:41:14 <hpaste>  Huschi pasted "Existential qualification problem" at http://hpaste.org/1087
11:41:35 <dmhouse> huschi: *quantification, I believe.
11:41:48 <vincenz> hpaste: what is the problem?
11:42:01 <huschi> i don't understand why showable can be compiled and showable' not.
11:42:11 <huschi> dmhouse: yes, it was just a typo.
11:42:18 <dmhouse> (forall a. Show a => a) - the only member of this type is _|_.
11:42:24 <vincenz> huschi: the first one returns a new type
11:42:27 <vincenz> huschi: the second doesn't
11:42:52 <huschi> ok. so i always need a "box type"?
11:43:05 <int-e> dmhouse: show is also a member of that type
11:43:16 <int-e> dmhouse: err.
11:43:21 <dmhouse> The latter says that 'Given something which instantiates Show, I'll return something which you can assume to be of any type whatsoever, as long as that type is an instance of Show'.
11:43:23 <int-e> dmhouse: ignore that
11:43:42 <huschi> dmhouse: that was exactly what i wanted.
11:43:56 <dmhouse> huschi: well, that's impossible.
11:44:14 <vincenz> yay for lb team-members :)
11:44:24 <dmhouse> huschi: I could give you 5, then you give me something back which I can assume to be a Bool, say.
11:44:30 <huschi> but doesn't the version with the extra type say (almost) the sane.
11:44:40 <dmhouse> No. This is the 'existential' bit.
11:45:27 <huschi> dmhouse: i thought the only thing you can do with a result of showable' is to use show on it.
11:45:31 <dmhouse> It says 'Give me something of a type that instatiates Show. Then I'll give you something whose type instantiates Show, but you can't know what that type is', roughly.
11:46:06 <huschi> dmhouse: so i'm discarding some information.
11:46:07 <dmhouse> Another way of writing 'data ShowB = forall a. Show a => SB a' is as 'data ShowB = SB (exists a. Show a => a)'.
11:46:25 <dmhouse> huschi: yes, exactly. The only thing you know about its type is that it instantiates Show.
11:46:46 <huschi> that would be enough for me.
11:47:10 <huschi> my target is something like [(forall a. Show a => a)]
11:47:32 <huschi> i simply want a list of things which i can show afterwards.
11:47:36 <dmhouse> That's a list of _|_.
11:47:54 <dmhouse> Then you mean [exists a. Show a => a], which is isomorphic (the same as) [Showable].
11:48:17 <dmhouse> (Up to the fact that in the latter the values are boxed in a Showable constructor.
11:48:23 <huschi> but exists doesn't exist ( :-) ) in haskell, or am i wrong?
11:48:35 <dmhouse> No, which is why you have to use these existential boxes.
11:48:44 <vincenz> huschi: he means it semantically, not on a syntactcal level
11:48:53 <dmhouse> I have to dash, HTH. There are many others around that should be able to answer :)
11:49:21 <huschi> dmhouse: ok, i think that was helpful enough for now.
11:49:23 <int-e> huschi: the forall in the data declaration is confusing; what it means is  that you have a constructor of type   Showable :: forall a . Show a => a -> Showable, and a deconstructor that gives you both a and the show instance back
11:49:54 <dmhouse> huschi: check out the Existentially Quantified Types article on the Wikibook if you haven't already.
11:50:10 <int-e> huschi: and that's different from (forall a . Show a => a) which says that given any show instance, you'll return a value inhabiting the corresponding type.
11:50:16 <huschi> i already did once. maybe reading it several times helps.
11:51:15 <huschi> int-e: that means showable' has type: (Show a, Show b) => b -> a?
11:51:43 * SamB wonders if he is still connected to the internet
11:51:50 <int-e> huschi: which for Show only allows bottom; a more interesting case is the Num class. (forall a . Num a => a) is inhabited by all integers - say  fromIntegral 0.
11:52:05 <SamB> ah, yes, I am.
11:53:00 <int-e> huschi: hmm. no, not really. the value that it returns has type Show a => a
11:53:40 <huschi> int-e: but doesn't that mean that you can use show on it and nothing more?
11:53:57 <int-e> huschi: the difference is that (Show a, Show b) => b -> a can only be called if you already know which instance for Show a you want. showable' can be called without knowing that.
11:54:05 <int-e> huschi: yes, that's what it means
11:54:08 <int-e> huschi: err
11:54:10 <int-e> huschi: no
11:54:21 <int-e> huschi: it means that you can only use show to construct the value
11:54:31 <int-e> huschi: and undefined.
11:54:59 <huschi> mhm, existential types seem to be a bit complicated.
11:55:04 <int-e> huschi: it's a universally quantified type, not an existentially quantified one
11:55:24 <huschi> int-e: that sound very theoretical.
11:55:53 * SamB wonders why he is seeing a ton of ARPs on the port to his cable modem
11:56:11 <SamB> (well, coming over my cable modem, actually)
11:56:27 <int-e> SamB: other cable modems maybe?
11:56:40 <Jaak> whoa. i already love existentially quantified types
11:56:47 <SamB> does it indicate a router reboot?
11:57:05 <SamB> the strangest part is they aren't all requesting the same IP addresses be informed
11:57:24 <int-e> huschi: the fact that 'forall' is used to denote existential types doesn't help - this is quite confusing in the beginning.
11:57:28 <SamB> oh, I should mention...
11:57:46 <SamB> they all seem to have the same source ethernet address
11:58:23 <huschi> int-e: so there is now way to express [exists a. Show a => a] without another type?
11:59:07 <int-e> huschi: the point is really that forall a. Show a => Showable a  denotes a function  Showable :: forall a . Show a => a -> Showable  and the corresponding deconstructor is (almost?) isomorphic to a function of type  Showable -> (exists a: Show a => a)
11:59:09 <int-e> huschi: yes
11:59:38 <huschi> int-e: ok, thank you.
12:00:13 <desp> bos: hi
12:00:38 * SamB wonders if these ARP packets are encrypted and, if so, how much bandwidth they waste
12:25:00 <chessguy> zzzzzzz
12:28:41 <ski> aaaaaaa
12:29:23 <chessguy> hmmm, interesting blog on planet haskell about returning multiple things of different types
12:29:38 * xerox sedates ski
12:29:39 <chessguy> i wonder if Either could be extended to perform like this
12:30:15 <DangerMouse> i have a function: make_move [a,b,c,d,e,f,g,h,i,j] (x, 0) = [a] : [b,c,d,e,f,g,h,i,j]
12:30:18 <DangerMouse> but i get errors
12:30:36 <DangerMouse> cannot cons [*] to [*]
12:30:40 <xerox> DangerMouse: a : ... not [a] : ... because (:) :: a -> [a] -> [a], not [a] -> [a] -> [a].
12:30:44 <DangerMouse> but they are list of char
12:30:51 <DangerMouse> oh?
12:31:07 <Saizan> ?type (:)
12:31:09 <lambdabot> forall a. a -> [a] -> [a]
12:31:11 <DangerMouse> sorry i just started doing this today, finding it a bit difficult
12:31:17 <xerox> DangerMouse: on the other hand, if you want to concat list, you can use (++) :: [a] -> [a] -> [a] or even make a list of lists to be concatenated and use concat :: [[a]] -> [a]
12:31:26 <chessguy> ?hoogle any
12:31:26 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
12:31:27 <lambdabot> Text.ParserCombinators.Parsec.Char.anyChar :: CharParser st Char
12:31:27 <lambdabot> Text.ParserCombinators.Parsec.Combinator.anyToken :: Show tok => GenParser tok st tok
12:31:30 <chessguy> ?hoogle Any
12:31:30 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
12:31:31 <lambdabot> Network.Socket.aNY_PORT :: PortNumber
12:31:31 <lambdabot> Text.ParserCombinators.Parsec.Char.anyChar :: CharParser st Char
12:31:34 <chessguy> @more
12:31:42 <chessguy> ?hoogle+
12:31:43 <lambdabot> Text.ParserCombinators.Parsec.Combinator.anyToken :: Show tok => GenParser tok st tok
12:31:43 <lambdabot> Network.Socket.iNADDR_ANY :: HostAddress
12:31:43 <lambdabot> Foreign.Marshal.Utils.withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
12:31:46 * ski reads blog
12:32:53 <DangerMouse> xerox : i need to put a for example in a specific part of the list
12:33:00 <DangerMouse> so ++ will put it at the end right?
12:33:08 <xerox> DangerMouse: right.
12:33:16 <DangerMouse> so i must use cons
12:33:36 <xerox> > concat [[1,2,3,4],[1000],[6,7,8,9]]
12:33:37 <lambdabot>  [1,2,3,4,1000,6,7,8,9]
12:33:45 <ski> chessguy : lightweight variants would be good for that, i think
12:34:06 <xerox> DangerMouse: I suppose arrays are better for such operations, though. I must dash off to dinner, bbl.
12:34:14 <ski> or, hm
12:34:16 <chessguy> ski, couldn't there be something like Either, but extended to have more than 2 types?
12:34:21 <ski> sure
12:34:40 <DangerMouse> xerox : thx
12:34:49 <chessguy> could it be extended to have an arbitrary number of types? probably not
12:35:11 <SamB> is there any particular significance to the fact that there are 256 patches in the "binary" repository?
12:35:40 <DangerMouse> ok im having some other problems. im trying to cons the result of another function to a list but i seem to be doing something wrong, any help is appriciated
12:35:56 <DangerMouse> i have a function: make_move [a,b,c,d,e,f,g,h,i,j] (x, 0) = (mark_col a x) : [b,c,d,e,f,g,h,i,j]
12:36:06 <DangerMouse> the definition of mark_col is:
12:36:07 <Saizan> what's the type of mark_col?
12:36:16 <whitenoyce> http://www.youtube.com/watch?v=Fc1LL5if2kM&NR
12:36:22 <ski> foo :: Blah -> {unsuccessful | successful :: {pylons_response :: Foo & file_handle :: Handle & xml_document :: XML}}
12:36:26 <ski> chessguy : or something
12:37:03 <DangerMouse> mark_col [cell1, cell2, cell3, cell4, cell5, cell6, cell7, cell8, cell9, cell10] 0 = ['*', cell2, cell3, cell4, cell5, cell6, cell7, cell8, cell9, cell10]
12:37:29 <DangerMouse> it just replaces an elemnt
12:37:32 <DangerMouse> element*
12:37:42 <DangerMouse> with the '*' char
12:38:00 <chessguy> ski, i was thinking more of the general case
12:38:05 <ski> being ?
12:38:15 <Saizan> so the a in make_move is a list itself?
12:38:25 <DangerMouse> yeah
12:38:34 <DangerMouse> each letter is itself a list
12:38:48 <chessguy> ski abstracting the notion of being able to return any of an arbitrary number of types, like Either abstracts the notion of being able to return either of 2 types
12:38:54 <DangerMouse> error im getting is: cannot unify [[[char]]] with [[char]]
12:39:09 <ski> chessguy : that is just lightweight variants (as in the example)
12:39:31 <ski> { foo :: Foo  |  bar :: Bar  |  baz :: Baz }
12:39:36 <ski> (or some other syntax)
12:39:49 <Saizan> DangerMouse: a is a list of chars or a list of strings?
12:39:53 <ski> this denoting the type that can be of three shapes
12:40:04 <DangerMouse> list of chars
12:40:14 <chessguy> wait, is that H98?
12:40:24 <ski> so returning something of this type amounts to returning something out of three possible types
12:41:04 <ski> (the point being that no declaration of the type is needed .. it is lightweight, just as tuples are .. while 'data','newtype' is heavyweight)
12:41:08 <Saizan> ?paste
12:41:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:41:18 <ski> chessguy : e.g. OCaml has this
12:41:24 <Saizan> DangerMouse: can you paste a bit more of the code and the error?
12:41:31 <chessguy> ski, but does haskell?
12:41:42 <DangerMouse> Saizan : yea sure, give me a sec, i'll find a pastebin site
12:41:53 <Saizan> you can use http://hpaste.org/new
12:42:02 <ski> well, istr the TREX extension, which had lightweight records .. possible variants as well (at least in the paper, i think)
12:42:13 <DangerMouse> Saizan : ok
12:42:14 <ski> (extension implemented in hugs)
12:42:16 <chessguy> i'm talking about mainstream haskell
12:42:52 <ski> yes, it would be nice to get some common support, in ghc, nhc, .. yes
12:43:21 <ski> (istr there were some details that needed to be thought out the proper way to do them ..)
12:44:06 <ski> positional variants has also been suggested here on #haskell (beelsebob) and on the mailing-list
12:44:38 <chessguy> so there's definitely no way to do it in Haskell 98?
12:44:45 * ski thinks both positional, and named variants would be good, just as both tuples and records are good
12:44:58 <hpaste>  DangerMouse pasted "board_game" at http://hpaste.org/1088
12:45:02 <ski> nope
12:45:09 <SamB> what are positional variants?
12:45:14 <ski> (you can simulate positional by nesting 'Either')
12:45:16 <SamB> are those like HList?
12:45:21 <SamB> oh.
12:45:22 <DangerMouse> Saizan, thats handy :)
12:45:30 <ski> SamB : beelsebob called them "disjunctive tuples"
12:45:44 <ski> foo :: Int -> (Char | Bool | String)
12:45:57 <ski> foo 0 = ('a' | | )
12:46:02 <chessguy> DangerMouse, any time you are repeating yourself that much your design is pretty much guaranteed to be flawed
12:46:05 <ski> foo 1 = ( | False | )
12:46:10 <beelsebob> see - loads of people want them!
12:46:15 <ski> foo 2 = ( | | "bar")
12:46:21 <DangerMouse> Saizan : the first line just create a 10x10 board initialized with the '-' character
12:46:32 <ski> (or some similar syntax .. concrete syntax not decided)
12:46:53 <DangerMouse> print_game_board just prints out the board as a table
12:47:03 <edwardk> ski: still fixated on those? =)
12:47:27 <edwardk> oh wait, slightly new syntax, reading...
12:47:30 <DangerMouse> make_move and mark_col are just attempting to put a '*' character on the specified coordinate.
12:47:31 <chessguy> DangerMouse, your make_move function  can be written in 1 line
12:47:35 <ski> edwardk : heh .. actually i've not been thinking of these for so long (a few months)
12:48:01 <edwardk> reminded me of your destructor stuff
12:48:04 <DangerMouse> chessguy, im new :) + this is miranda code so im not sure if it has the appropriate haskell equivilant
12:48:08 <edwardk> took a moment to notice the distinction
12:48:15 <ski> positional would be use for quickly returning one of a few alternatives
12:48:37 <chessguy> so why are you asking about miranda code in #haskell?
12:48:44 <Saizan> DangerMouse: i think the problem is in empty_game_board
12:48:47 <Saizan> > [ ([['-'] | n <- [1..10]]) | x <- [1..10] ]
12:48:48 <lambdabot>  [["-","-","-","-","-","-","-","-","-","-"],["-","-","-","-","-","-","-","-",...
12:48:54 <ski> names would be used when there's more variants, to avoid recalling order (row polymorphism could be used to sortof get supertyping)
12:49:04 <Saizan> see?, they are list of strings, not of chars
12:49:24 <Saizan> ?type [ ([['-'] | n <- [1..10]]) | x <- [1..10] ]
12:49:26 <lambdabot> [[[Char]]]
12:49:33 <Saizan> ?type [ (['-' | n <- [1..10]]) | x <- [1..10] ]
12:49:35 <lambdabot> [[Char]]
12:49:44 <chessguy> mark_col is another 1 line
12:49:45 <DangerMouse> oh
12:49:45 <SamB> ski: what happens if I have type Floaty = (Float | Double) and type Inty = (Int16 | Int32) and type Fooey = (Floaty | Inty)?
12:49:45 <ski> heavyweight variants (i.e. 'data') is used when the type has some meaning on its own (e.g. used more than a couple of times)
12:50:10 <ski> SamB : similar as with nested tuples
12:50:18 <SamB> ski: okay.
12:50:20 <ski> ((Int,Bool),(Char,String))
12:50:31 <edwardk> > let rep n t = take n $ repeat t in rep 10 $ rep 10 '-'
12:50:32 <lambdabot>  ["----------","----------","----------","----------","----------","---------...
12:50:51 <DangerMouse> chessguy : because they are similar and there arent any people who help with miranda since its very old
12:50:56 <ski> if you want flattening for those, possibly the named/labelled variant can be used for that, as well
12:51:16 * SamB wants proper records, actually ;-)
12:51:39 <hpaste>  (anonymous) annotated "Using gtk2hs and drawingArea (?)" with "(no title)" at http://hpaste.org/278#a2
12:51:47 <Cale> Miranda is pretty close to Haskell :)
12:52:10 * ski wants heavvyweight records, and lightweight (named) records (positional ones, i.e. tuples, already exist) .. and mutatis mutandis for variants :)
12:52:16 <DangerMouse> Saizan : so i could just change '*' to "*" right?
12:52:23 <chessguy> DangerMouse, just write it in haskell then :)
12:52:38 <chessguy> how are we supposed to know whether miranda has the same functions haskell has?
12:52:43 <DangerMouse> i know my code is very plan and simple but i've never touched a functional language until today
12:52:47 <Cale> okay
12:52:48 <DangerMouse> so :)
12:52:52 <Saizan> DangerMouse: yeah, or change the ['-'] to '-'
12:53:03 <Cale> Why Miranda? Do you have a text on it or something?
12:53:10 <SamB> yeah, why?
12:53:28 <SamB> whoa
12:53:30 <ski> data Stream a = Head :: a  &  Tail :: Stream a  -- a heavyweight record type declaration, with two fields/deconstructors
12:53:31 <Saizan> search if you have a splitAt function in Miranda too :)
12:53:33 <SamB> oh, nevermind
12:53:34 <Cale> Miranda is Haskell's direct ancestor.
12:53:41 <SamB> #miranda exists but is about an IM client
12:53:41 <DangerMouse> i asked my lecturer what the best way of learnign a functional language was and he said to begin with miranda
12:53:43 <DangerMouse> so :)
12:53:47 <Cale> ah, okay
12:53:48 <DangerMouse> lol SamB
12:53:49 <SamB> I was wondering why there were 75 people there
12:54:06 <DangerMouse> yeah, not very helpful :)
12:54:14 <Heffalump> DangerMouse: what uni?
12:54:16 <edwardk> DangerMouse: your lecturer is a little out of date. Haskell is pretty much the spiritual successor to Miranda
12:54:20 <sjanssen> DangerMouse: your lecturer may be giving you 15 year old advice
12:54:30 <edwardk> the language is identical in the ways that matter and improved in a number of subtle ways
12:54:36 <chessguy> e.g., you would write make_move in haskell as somthing like make_move list (x,n) = (take n list) ++ (mark_col (list !! n)) ++ (drop n list)
12:54:46 <DangerMouse> lol easy guys :)
12:54:47 <edwardk> and there is current documentation and support
12:54:51 <SamB> DangerMouse: what does he teach now?
12:54:51 <chessguy> but we have no way of knowing whether take, ++, !!, or drop exist in miranda
12:55:05 <edwardk> DM: not trying to go all fanboy on you =)
12:55:08 <DangerMouse> still miranda
12:55:14 <DangerMouse> he's been doing it for 20 years now
12:55:23 <ski> where is this ?
12:55:36 <DangerMouse> sheffield, uk
12:56:25 <Saizan> > let mark_col xs n = let (before,(_:after)) = splitAt n xs in before ++ ('*':after) in mark_col "----------" 5
12:56:27 <lambdabot>  "-----*----"
12:56:31 <SamB> DangerMouse: what is his email address?
12:56:38 <SamB> or maybe his regular address
12:56:43 <ski> classified
12:56:48 <DangerMouse> SamB : lol
12:57:01 <chessguy> Saizan, the actual implementation is beside the point. he's not writing in  haskell
12:57:06 <DangerMouse> Saizan : thanks, that looks much better
12:57:24 <chessguy> not to mention we shouldn't be doing his homework for him
12:57:30 <DangerMouse> its not homework
12:57:35 <DangerMouse> im doing this formyself
12:57:43 <chessguy> whatever
12:57:43 <Saizan> well, just to allure him to haskell :>
12:57:44 <DangerMouse> to learn...
12:57:50 <DangerMouse> hehe
12:57:54 <sjanssen> wow, this is Miranda code?
12:58:01 <Heffalump> you don't want to learn Miranda for its own sake, learn Haskell
12:58:08 <sjanssen> shockingly similar
12:58:22 <CosmicRay> any gtk2hs folks around?
12:58:26 <DangerMouse> sjanssen : yeah
12:58:26 <Cale> http://www.cs.kent.ac.uk/people/staff/dat/miranda/stdenv.html -- there's a reference to the Miranda prelude.
12:58:28 <lambdabot> Title: stdenv.m
12:58:40 <Cale> Miranda and Haskell are almost the same, it's just Miranda's non-free.
12:58:42 <psi> the why fp paper is written with miranda, it's almost exactly haskell code
12:58:54 <chessguy> does this code actually work in Miranda?
12:59:04 <Cale> Oh, and Miranda is a trademark of Research Software Limited.
12:59:16 <Cale> ;)
12:59:17 <chessguy> does this code actually work in Miranda(TM?
12:59:22 <edwardk> "Research Limited" how appropriately named ;)
12:59:25 <chessguy> +)
12:59:35 <Heffalump> I understand it'd probably have become the standard language instead of Haskell if it wasn't for that
12:59:43 <edwardk> yeah
12:59:57 <chessguy> haskell's hardly standard
13:00:08 <Heffalump> the standard lazy functional language :-p
13:00:12 <Cale> chessguy: As far as research languages go, it is.
13:00:12 <edwardk> chessguy: well, it was intended to become the standard lazy functional language..
13:00:14 <edwardk> heh
13:00:16 <sjanssen> chessguy: it's the standard language of it's class
13:00:31 <chessguy> lol, out of what, about 3 languages in the class?
13:00:35 <DangerMouse> Saizan: i get an unexpected token '_' error
13:00:38 <dolio> chessguy: You mean it's exceptional, not standard?
13:00:52 <Heffalump> chessguy: there are a limited number of such languages precisely because Haskell exists
13:01:05 <Cale> DangerMouse: Miranda probably doesn't support wildcard patterns -- stick some variable in the place of the _
13:01:06 <chessguy> dolio, i mean we're the only ones that think it's exceptional, most of the world doesn't :)
13:01:06 <sjanssen> chessguy: there were a couple surfacing when the committee decided to make Haskell
13:01:07 <edwardk> chessguy: when it was written there were a lot of people doing research in the area and they all had incompatible languages, made it very hard to do research because you got bogged down in the details of each language
13:01:11 * chessguy hides
13:01:18 <chessguy> incoming~!
13:01:20 <dolio> :)
13:01:21 <Cale> DangerMouse: you might also need an implementation of splitAt
13:01:32 * chessguy dives for cover
13:01:33 <DangerMouse> Cale : ok sec, ill give it a try, hmm i think your right
13:02:21 * chessguy screams into a phone for backup
13:02:35 <sjanssen> DangerMouse: if you were using Haskell, you'd be one import Data.List away from splitAt :)
13:02:36 <SamB> edwardk: what sort of research were they doing?
13:02:43 <ski> @src splitAt
13:02:43 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
13:02:52 <DangerMouse> lol i got lots of errors :)
13:02:56 <ski> @src take
13:02:56 <lambdabot> take n _      | n <= 0 =  []
13:02:56 <lambdabot> take _ []              =  []
13:02:56 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:02:59 <ski> @src drop
13:03:00 <lambdabot> drop n xs     | n <= 0 =  xs
13:03:00 <lambdabot> drop _ []              =  []
13:03:00 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
13:03:04 <edwardk> samb: i was just paraphrasing the history of haskell paper =)
13:03:24 <DangerMouse> canot unify bool with [*] and cannot apply [char] to *
13:03:27 <SamB> DangerMouse: it would probably be easier to learn Haskell than to learn Miranda by translating programs in a language you don't know into it
13:03:41 <DangerMouse> SamB, your probably right
13:03:55 <chessguy> no, he's trivially right
13:04:11 <edwardk> if you REALLY wanted to learn Miranda, Simon Peyton Jones' old book on Miranda is online on his website
13:04:42 * chessguy votes edwardk off the island
13:04:51 <sjanssen> edwardk: it almost seems perverse to use SPJ's book to learn Miranda
13:04:53 <glguy> I just got a voice message at work "Recycling will no longer be necessary as of Friday, March 23"
13:05:05 <glguy> woo hoo! the environment is saved, we can solve other problems now
13:05:07 <chessguy> haha
13:05:17 <DangerMouse> sjanssen : lol why?
13:05:25 <cjeris> glguy: they going to recycle all the employees?
13:05:40 <glguy> cjeris: they layed off 20 people recently
13:05:46 <cjeris> :(
13:05:50 <glguy> a lot of the maintenance staff
13:05:52 <glguy> and others
13:06:08 <sjanssen> DangerMouse: SPJ is the editor of the Haskell '98 report, one of the maintainers of the premier Haskell systems (ghc), and a prominent researcher on Haskell topics
13:06:18 <sjanssen> s/systems/system
13:07:16 <DangerMouse> sjanssen : ah :)
13:07:58 <edwardk> DM: though it IS the only book i can think of that you could read on Miranda ;)
13:08:19 <SamB> edwardk: "on" Miranda?
13:08:28 <DangerMouse> lol
13:08:35 <SamB> I thought the book was about *implementing* functional programming languages
13:08:45 <SamB> maybe there are two books...
13:08:46 <edwardk> yeah but it uses Miranda throughout no?
13:08:53 <SamB> well yes
13:09:23 <edwardk> gr1ff0n
13:09:40 <edwardk> wrong window
13:13:08 <DangerMouse> Saizan : if i change mark_col to use "*" instead of '*' i get cannot unify [[[char]]] with [[char]]
13:13:20 <DangerMouse> argh this is frustrating
13:13:57 <chessguy> i bet it's even more frurstrating to know that if you were writing in haskell it would have been done yesterday :)
13:14:23 <DangerMouse> lol
13:14:31 <DangerMouse> thats mean! :)
13:14:37 <chessguy> truth hurts!
13:18:53 <rahikkala> @quote oleg
13:18:53 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
13:20:47 <vincenz> @quote vincenz.*oleg
13:20:48 <lambdabot> No quotes match. My pet ferret can type better than you!
13:20:51 <vincenz> @quote vincenz.*Oleg
13:20:51 <lambdabot> No quotes match. Wrong!  You cheating scum!
13:20:56 <vincenz> @quote oleg
13:20:56 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
13:21:01 <vincenz> @quote oleg
13:21:01 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
13:29:03 <ski> @oleg
13:29:05 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:29:13 <ski> hmpf
13:41:06 <Cale> DangerMouse: can't unify [[[char]]] with [[char]] means that you probably have a list of lists of lists and need a list of lists. Perhaps apply concat?
13:41:25 <Cale> (and I know that concat is in the Miranda prelude :)
13:44:58 <DangerMouse> Cale : concat would probably work but i need to cons because i need to put it in a certain position in the list
13:45:26 <_roconnor> or it could mean that you have a list of lists of Strings and need a list of Strings
13:45:40 <DangerMouse> http://hpaste.org/1088
13:45:57 <DangerMouse> the probelms occur with mark_col
13:46:22 <DangerMouse> its the reconstruction of the list with the marker "*"
13:46:46 <Cale> Well, what's the type of cell0 ?
13:46:57 <Cale> (or mark_col, for that matter)
13:47:32 <Cale> Given this code, I'd estimate that it's intended to be [char] -> num -> [char]
13:47:48 <DangerMouse> yeah
13:48:04 <Cale> Okay, note that "*" and '*' are different too.
13:48:29 <Cale> "*" is a [char], while '*' is a char, at least, in Haskell. I don't know Miranda that well.
13:48:40 <DangerMouse> yeah its the same in miranda
13:49:04 <Cale> okay
13:49:13 <DangerMouse> for the basic things im doing you can pretty much assume its a straight swap
13:49:27 <Cale> Is this code here failing to compile?
13:49:34 <DangerMouse> yeah
13:51:13 <glguy> Blogger: Term used to describe anyone with enough time or narcissism to document every tedious bit of minutia filling their uneventful lives.
13:51:14 <DangerMouse> Cale : my current errr is cannot unify [[[char]]] with [[char]] but if i change from '*' to "*" i get another one:
13:51:19 <glguy> http://www.thebestpageintheuniverse.net/c.cgi?u=banish
13:51:20 <lambdabot> Title: If these words were people, I would embrace their genocide.
13:51:49 <ptolomy> Hm.. can anyone think of a program/algorithm that is run in a batch form that is relatively straight-forward in specification but rather difficult to handle without good abstractions? (As an exercise, I was trying to think of a shootout program that would stack the deck against C)
13:51:51 <Cale> DangerMouse: I'll type check the code by hand and see what I come up with :)
13:51:59 <DangerMouse> Cale : so with "* i get cannot unify [char[->num->[char] with [[char]]->num->[[char]]
13:52:14 <DangerMouse> Cale : thats very kind of you :)
13:52:59 <ptolomy> Hm. Stupid question.
13:55:15 <Cale> DangerMouse: does it say which line the error is on?
13:56:09 <sjanssen> DangerMouse hasn't converted to Haskell yet? :P
13:56:12 <DangerMouse> says its at the main function but im sure thats a lie :)
13:56:23 <DangerMouse> its deintly to do with mark_col i think
13:56:50 <DangerMouse> sjanssen : lol, its annoying but i might aswell finish this small app first before moving
13:58:02 <Cale> aha, I see where there's an error.
13:58:22 <Cale> mark_cell_occupied :: [[char]] -> (num,num) -> [[char]]
13:58:32 <Cale> but empty_game_board :: [[[char]]]
13:59:20 <sjanssen> ptolomy: you can stomp C in anything to do with multithreading
13:59:40 <DangerMouse> Cale : i see
13:59:47 <Cale> Perhaps you intend for empty_game_board to be [['-' | n <- [1..10]] | x <- [1..10]]
13:59:57 <DangerMouse> yeah
13:59:59 <vincenz> sjanssen: or generating data and then not consuming it all
14:00:10 <vincenz> sjanssen: ..data-dependent data consumption
14:00:12 <Cale> That is, it'd be a list of strings, rather than a list of list of strings.
14:00:39 <Cale> but then the type of print_game_board is going to have to change, I think
14:00:57 <Cale> hmm
14:01:18 <Cale> We need to decide on a convention for the board, and stick to it :)
14:01:39 <DangerMouse> Cale : im not sur ethats right, i want empty_baord game to represent a 10x10 boar
14:01:47 <DangerMouse> sure that*
14:01:55 <Cale> okay, and the elements of the board are strings or characters?
14:02:17 <Cale> ['-'] = "-"
14:02:21 <DangerMouse> the board can only contain either '-' or '*' chars
14:02:24 <Cale> okay
14:02:32 <Cale> so [[char]]
14:02:33 <SamB> :t [['-' | n <- [1..10]] | x <- [1..10]]
14:02:35 <lambdabot> [[Char]]
14:02:44 <SamB> oh, oh.
14:03:01 * SamB missed the nesting
14:03:08 <DangerMouse> it starts with all filled with '-', then we give main a set off coordinates and fill each one with '*' and then print the board
14:03:16 <SamB> it looked like one of them zipWith comprehensions
14:03:20 <Cale> now, let's have a look at format_row, since it's got a type that doesn't jive with its name now.
14:03:26 <Cale> format_row :: [[char]] -> [char]
14:03:26 <Cale> format_row [] 		= ""
14:03:26 <Cale> format_row (front : rest) = front ++ " " ++ format_row rest
14:03:46 <Cale> format row's type indicates that it'd handle an entire board
14:04:03 <Cale> but perhaps that's not what is desired.
14:04:15 <DangerMouse> yeah i fiddled with it a little, it used to just deal with the row
14:04:16 <Cale> A row is now a string, which is [char]
14:04:45 <Cale> So presumably the goal of format_row is just to intersperse spaces into that string.
14:05:04 <Cale> format_row :: [[char]] -> [char]
14:05:05 <Cale> format_row [] 		= ""
14:05:05 <Cale> format_row (front : rest) = front : ' ' : format_row rest
14:05:12 <Cale> er, different type
14:05:13 <DangerMouse> yeah so when its printed it will look like better
14:05:18 <Cale> format_row :: [char] -> [char]
14:05:29 <Cale> So that's fixed now.
14:05:55 <Cale> print_game_board :: [[char]] -> [sys_message]
14:06:01 <Cale> is that right?
14:06:20 <Cale> print_game_board game_board = map (Stdout.(++ "\n").format_row) game_board
14:06:29 <DangerMouse> yeah
14:06:41 <Cale> make_move :: [[char]] -> (num,num) -> [[char]]
14:06:42 <DangerMouse> i think its [[[char]]]
14:06:49 <DangerMouse> print_Game_baord that is
14:06:52 <Cale> no, our board is now [[char]]
14:06:56 <DangerMouse> ah yes
14:07:34 <Cale> mark_col :: [char] -> num -> [char]
14:07:51 <Cale> mark_cell_occupied = make_move
14:08:13 <Cale> and so mark_cell_occupied :: [[char]] -> (num,num) -> [[char]]
14:08:42 <ski> miranda uses dialogue-io ?
14:09:02 <Cale> mark_cell_occupied empty_game_board :: (num,num) -> [[char]]
14:09:09 <Cale> mark_cell_occupied empty_game_board (0,0) :: [[char]]
14:09:27 <Cale> print_game_board (mark_cell_occupied empty_game_board (0,0)) :: [sys_message]
14:09:42 <Cale> So main :: [sys_message]
14:09:51 <DangerMouse> hmm
14:09:54 <nominolo> ?where TMR
14:09:55 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
14:10:12 <nominolo> ?where TMR 6
14:10:12 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
14:10:43 <sjanssen> nominolo: that's an outdated page
14:10:47 <Cale> So if that's an appropriate type for main to have, I think this should work now.
14:10:51 <sjanssen> @google monad.reader
14:10:52 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
14:10:53 <lambdabot> Title: TheMonadReader - The Haskell Wiki
14:11:11 <DangerMouse> Cale : just making those changes, sec
14:11:14 <hpaste>  Cale annotated "board_game" with "corrected?" at http://hpaste.org/1088#a1
14:11:27 * ski wonders how miranda handles imput
14:11:39 <nominolo> sjanssen: yes, but the second hit on google doesn't work
14:11:43 <sjanssen> @where+ tmr http://www.haskell.org/haskellwiki/The_Monad.Reader
14:11:44 <lambdabot> Done.
14:11:48 <nominolo> sjanssen: but i found my local copy
14:12:19 <sjanssen> nominolo: I'm not sure why google has so much trouble finding the right page
14:12:21 * mwc wonders if there's an easy way to get a list of the roots of arbitrary-degree legendre polynomials
14:12:22 <sjanssen> quite annoying
14:12:32 <sjanssen> @where+ monad.reader http://www.haskell.org/haskellwiki/The_Monad.Reader
14:12:32 <lambdabot> Done.
14:15:43 <DangerMouse> Cale : all the types work nicely but im still getting an error
14:15:54 <Cale> What error?
14:16:03 <Cale> Is it that main has an inappropriate type?
14:16:19 <DangerMouse> are we using ['*',cell1, cell2, cell3, cell4, cell5, cell6, cell7, cell8, cell9] ? or :
14:16:23 <DangerMouse> ["*",cell1, cell2, cell3, cell4, cell5, cell6, cell7, cell8, cell9]
14:16:26 <thorat> mwc: you might like: http://www.cs.dartmouth.edu/~doug/pearl.ps.gz
14:16:34 <Cale> the former
14:16:35 <DangerMouse> as mark_cols body
14:16:43 <Cale> (see my paste)
14:16:49 <Cale> http://hpaste.org/1088#a1
14:17:16 <Cale> We should probably clean that code up, but let's try to get this to work first :)
14:17:19 <DangerMouse> error = cannot unify [[[char]]] with [[char]]
14:17:25 <Cale> hmm, where?
14:17:30 <DangerMouse> compilation
14:17:32 <ddarius_> ski: I think it used the lazy list approach, but I don't remember.
14:17:35 <Cale> uhh
14:17:44 <DangerMouse> not used your code yet tho
14:17:45 <DangerMouse> sec
14:17:58 <Cale> note that we changed format_row
14:18:04 <thorat> mwc: and http://citeseer.ist.psu.edu/karczmarczuk97generating.html
14:18:06 <lambdabot> Title: Generating Power of Lazy Semantics - Karczmarczuk (ResearchIndex)
14:18:06 <Cale> format_row (front : rest) = front : ' ' : format_row rest
14:18:27 <DangerMouse> sorry my bad, forgot to change the definition of empty_board_game
14:18:31 <Cale> aha
14:18:42 <DangerMouse> was using ['-'] instead of '-'
14:18:46 <Cale> yeah
14:18:46 <DangerMouse> wow it works :)
14:18:49 <Cale> cool :)
14:19:03 <DangerMouse> thanks alot, such a struggle when you begin :)
14:19:23 <mwc> thorat, it's not so much computing with power series that I'm working on (at the moment, monday will be a diff't story) but that I need to add gaussian quadrature to my FEM codes
14:19:33 <DangerMouse> a different type of programming that is
14:19:54 <Cale> Yeah
14:20:31 <Cale> Learning Miranda/Haskell/Clean is sort of like learning to program all over again :)
14:20:58 <ddarius_> Cale: Because you realize you don't know how to program?
14:21:00 <DangerMouse> Cale : thats so true, its scary
14:21:04 <Cale> ddarius_: partly :)
14:21:26 <DangerMouse> now i know why the google engine uses the MapReduce algorithm
14:21:28 <DangerMouse> :)
14:22:07 <Cale> Actually, I think that's a little disingenuous. Even if you really do know how to program, your programming knowledge is likely to be encoded in a way that's somewhat incompatible with this mode of reasoning.
14:22:50 <thorat> mwc: well, let me know if you find anything
14:22:52 <DangerMouse> Cale : i do alot of java, C# and C
14:22:58 <Cale> Let's look at trying to simplify your program now, because make_move and mark_col don't look like anything which you'd ordinarily want to write -- imagine if the board was 19x19.
14:23:16 <augustss> I find that Haskell clears my mind.  It's easier to formulate your unclear thoughts.
14:23:17 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
14:23:19 <DangerMouse> when you start doing functional programming you feel helpless at the start
14:23:20 <DangerMouse> hehe
14:23:43 <DangerMouse> Cale : isn't that the truth lol
14:23:57 <Cale> I think the key thing we need is a function with type  * -> num -> [*] -> [*]
14:24:17 <Cale> Which will replace the element at the given position in the list with the given element.
14:24:33 <DangerMouse> which will deal with the substitution of '-' to '*'
14:24:40 <DangerMouse> ah yea :)
14:24:41 <DangerMouse> hehe
14:25:07 <ski> ddarius :: [Response] -> [Request]  -- ?
14:25:08 <Cale> Note that it's polymorphic, so * could be char, or could be [char]
14:25:17 <DangerMouse> so thinking functionally we can use structural analsys?
14:25:22 <thorat> mwc: in any case, your best bet is http://users.info.unicaen.fr/~karczma/arpap/
14:25:28 <lambdabot> Title: Some papers (Karczmarczuk)
14:25:32 <thorat> afaik
14:25:35 <Cale> We'll use some recursion to break things down and make the replacement.
14:25:40 <DangerMouse> i think i just through of all the possible cases, which is bad
14:26:01 <Cale> When you're working with lists, there are generally only 2 cases.
14:26:19 <DangerMouse> base case and general case :)
14:26:24 <Cale> yeah
14:26:30 <ddarius> ski: Yes.
14:26:35 <ski> base case and non-base case
14:26:50 <ski> ddarius : ok, "dialogue-IO", then
14:27:05 <ski> @src []
14:27:06 <lambdabot> data [] a = [] | a : [a]
14:27:11 <Cale> in this case though, we likely want the empty list to result in an error
14:27:18 <Cale> since there's nothing to swap out
14:27:28 <Cale> We could also just have it place the element at the end.
14:27:54 <Cale> replace x n [] = error "replace: index too high!"
14:28:00 <SamB> once in a while you need more than one base case
14:28:34 <Cale> With that taken care of, we'll be able to assume that the list has at least one element in it.
14:28:43 <DangerMouse> Cale : the general sense of this program is to have an empty board and get a list of moves at the beginning in the form of north, south, easy or west and a starting coordinate, and we move from there making sure we dont touch another '*' cell or hit the edges of the 10x10 board
14:28:53 <ski> @src foldr1
14:28:53 <lambdabot> foldr1 _ [x]    = x
14:28:53 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
14:28:53 <lambdabot> foldr1 _ []     = undefined
14:29:00 <DangerMouse> so i broke it down to first, getting the board and drawing the start position
14:29:35 <DangerMouse> and dealing wiht the error handling at the end, so i thought of using list indexing to check if it was already a '*', if so then error
14:29:38 <Cale> That seems reasonable, in that it helps you to define a lot of the things about your program.
14:29:54 <thorat> mwc: oh, sorry, there is a lot more in http://haskell.org/haskellwiki/Libraries_and_tools/Mathematics
14:29:55 <lambdabot> Title: Libraries and tools/Mathematics - HaskellWiki
14:30:04 <Cale> replace x 0 (y:ys) = x:ys
14:30:08 <DangerMouse> so if board!x!y = '*' then error
14:30:37 <Cale> replace x n (y:ys) = y : replace x (n-1) ys
14:30:52 <DangerMouse> ah yes
14:31:24 <Cale> Then, mark_col = replace '*'
14:31:59 <Cale> oh, actually, we should be more general still
14:32:15 <DangerMouse> <--- banding my head thinking about the general case
14:32:18 <DangerMouse> banging*
14:32:42 <Cale> since this only lets us write make_move awkwardly.
14:32:45 <Cheery> what is lambda cube?
14:32:53 <Cheery> and how it is used?
14:33:00 <Cale> What we *really* want is a way to apply an arbitrary function to the nth element of the list.
14:33:28 <earthy> cheery: it as a classification of the different points in the design space of type systems for the lambda calculus
14:33:28 <DangerMouse> Cale but dont we need to specify a coordinate? like x,y and not just the nth?
14:33:37 <Cale> well, we'll be able to handle that
14:33:42 <Cale> suppose we have
14:33:45 <DangerMouse> ah ok
14:33:46 <earthy> cheery: and it is used to gain insight in what the design space signifies
14:33:55 <Cale> apply_at :: (* -> *) -> num -> [*] -> [*]
14:34:04 <ddarius> -some- points
14:34:30 <Cheery> earthy: sounds hard to understand.
14:34:43 <Cale> then make_move board (x,y) = apply_at (apply_at (const '*') y) x board
14:34:52 <earthy> cheery: not really
14:35:04 <Cale> That might be mind-bending at first.
14:35:04 <earthy> (it actually made lambda calculus 'click' for me
14:35:04 <earthy> )
14:35:14 <Cheery> earthy: so, how do I use it?
14:35:23 <ddarius> earthy: How does that work?
14:35:23 <earthy> well, you don't, really
14:35:25 <Cale> const x y = x
14:35:30 <DangerMouse> Cale : kinda lost me, mind if i setup a private chat? getting muddled up with other comments
14:35:31 <earthy> you pick a type system
14:35:34 <Cale> (It's in the Miranda prelude)
14:35:36 <Cale> sure.
14:35:37 <earthy> and it is somewhere in the lambda cube
14:35:39 <DangerMouse> thx
14:36:01 <ddarius> earthy: Not necessarily, or even all that likely.
14:36:19 <earthy> ddarius: if all you have is lambda calculus: bloody hell yes
14:36:35 <ddarius> earthy: What about, e.g. Pure Type Systems.
14:36:53 <earthy> ddarius: the base idea behind the cube actually extend to PTSs
14:37:12 <earthy> but PTSs allow more kind symbols
14:37:47 <earthy> there's a very nice chapter in the Handbook of Logic in Computer Science that explains all this stuff
14:37:55 <Cheery> earthy: why it is for my interest to know where in the lambda cube the type system I picked is?
14:38:20 <earthy> cheery: because it gives you a clue as to what kind of polymorphism you have in your type system
14:38:46 <Cale> DangerMouse: are you registered?
14:38:51 <earthy> plus, it gives you an idea as to whether or not type inference is decidable and whether or not type checking is decidable
14:39:03 <Cale> DangerMouse: If you're talking to me, then I'm not getting your messages.
14:39:12 <DangerMouse> Cale : oh?
14:39:26 <ddarius> Cale, DangerMouse: Why not just use #haskell-overflow?
14:39:30 <earthy> and IIRC of whether all types are inhabited
14:39:34 <Cale> You have to be registered with NickServ to send private messages on this network.
14:39:44 <DangerMouse> ah
14:39:51 <DangerMouse> shit
14:39:54 <DangerMouse> sec
14:39:55 <SamB> Cale: how can you register with nickserv without sending a private message?
14:39:58 <Cheery> ok, I guess I know enough about lambda cube for now, what is second order lambda calculus?
14:40:07 * ddarius has never had trouble sending privmsgs.
14:40:10 <Cale> SamB: Well, except to certain ops.
14:40:16 <Cheery> That is another thing I've hit and did found little about it.
14:40:29 <DangerMouse> Cale come to #haskell-overflow :)
14:40:31 <ddarius> Cheery: The rank-2 polymorphic lambda calculus.
14:40:50 <Cale> DangerMouse: I'm there.
14:41:46 <earthy> cheery: a lambda calculus where types can depend on terms
14:42:39 <earthy> it is \2 in the cube
14:43:16 <Cheery> why there's such thing?
14:45:10 <earthy> so you can type id
14:46:35 <Cheery> do you mean id like haskell id?
14:46:53 <Cheery> id x = x ; id :: a -> a   ?
14:47:00 * earthy nods
14:47:10 <earthy> id has type \forall a. a -> a
14:48:05 <Cheery> how do I hand-calculate rank > 1 lambda calculus?
14:48:12 <earthy> the full type in rank-2 lambda calculus is  (/\ A : * ( \x : A . x ) : A -> A )
14:49:07 <Cheery> I guess you could really help me if you'd have some link about these things.
14:49:24 * earthy is looking for Barendregt's publications
14:49:31 * earthy has the stuff on paper ;)
14:49:45 <earthy> (my luck for studying in his group... :))
14:50:27 <Cheery> thanks. chat is too low-bandwidth medium, it'd take few hours to explains this kind of things through it.
14:51:15 <huschi> int-e: now i understood the main difference between the forall in the result type and the solution with the extra type.
14:51:19 <ddarius> Cheery: As a first cut, there are only about 3 things you need to know beyond the simply typed lambda calculus.
14:51:44 <ddarius> And they more or less reuse the knowledge contained in the lambda calculus.
14:51:56 <Cheery> cool.
14:52:01 <int-e> huschi: nice
14:52:34 <huschi> int-e: are there any plans for introducing an exists quantifier?
14:52:47 <earthy> ah, the chapter of the handbook of logic in computer science is online!
14:52:58 <earthy> ftp://ftp.cs.ru.nl/pub/CompMath.Found/HBK.ps
14:53:10 <ddarius> \2 gives you type lambdas, you can "abstract out" types. \w gives you type-level lambdas (kind of like adding type constructors, only they can be arbitrary functions), \P gives you dependent types, i.e. a lambda that abstracts over terms to make a type.
14:53:21 <ddarius> The other points are combinations of those.
14:53:44 <earthy> that w, is that omega or weak-omega? :)
14:53:52 <Cheery> you mentioned simply typed lambda calculus, is it that simplest form of lambda calculus?
14:53:56 <earthy> no
14:54:04 <earthy> the simplest form of lambda calculus is untyped
14:54:04 <Cheery> ok, what is it?
14:54:43 <SamB> type Foo = Foo -> Foo
14:54:48 <SamB> and everything is of type Foo
14:54:50 <ddarius> earthy: That's debatable.  They aren't really comparable.
14:54:51 <int-e> huschi: I don't know, but I expect there aren't any.
14:55:18 <earthy> um. \omega is the combination of \2 and \weak-omega
14:55:20 <ddarius> Certainly the simply typed lambda calculus has much nicer properties.
14:55:43 <vincenz> @pl \(a,b) -> (f a, b)
14:55:43 <lambdabot> first f
14:55:54 <huschi> int-e: that's a pity since it would simplify code and also eases understanding.
14:56:09 <ddarius> weak, the three axes of the cube
14:56:38 <SamB> huschi: suggest it again?
14:57:01 <huschi> int-e: to my mind the use of forall in sth like "data Showable = forall a. Show a => S a" is a bit counter intuitive.
14:57:15 <huschi> SamB: what would that help?
14:57:33 <ddarius> huschi: Yes and no.
14:57:37 <SamB> I think the consensus is that it is a Good Idea
14:58:11 <Cheery> so basically, what is interesting to know is that the lambda calculus can extend 'under' the lambdas in the form of mechanics for type system?
14:58:52 <earthy> I didn't parse that, Cheery?
14:58:59 <ddarius> Me neither.
14:59:17 <earthy> you can extend the untyped lambda calculus with types
14:59:23 <earthy> there's two styles
14:59:28 <earthy> church style and curry style
14:59:43 <ddarius> earthy: Church style doesn't really fit that.
14:59:43 <earthy> the church style is strictly more powerful and cleaner
15:00:03 <earthy> church style really changes the terms though
15:00:08 <earthy> whereas curry style only adds types
15:00:17 <int-e> huschi: I agree that it's confusing at first. It's actually less confusing in GADT syntax (where you spell out the type of the constructors)
15:00:40 <earthy> the simply typed lambda calculus is representable in both styles
15:00:46 <earthy> the calculus of constructions isn't. ;)
15:01:50 <Cheery> earthy: how much that postscript you gave explains me things?
15:01:51 <ddarius> There is an interesting exercise in "Lectures on the Curry-Howard Isomorphism" that involves showing that eta-reduction is unsound in a Curry-style lambda calculus (but not a Church one)
15:02:35 <SamB> hmm. so what do *we* use?
15:02:45 <earthy> cheery: it was the full lecture notes for the course on typed lambda calculi that I took with Barendregt's group, so I'd say it is quite complete
15:03:11 <Cheery> so a treasure -class of paper. neat!
15:03:42 <huschi> int-e: in the sample above if you have got a value (S x) then you know that there is any type that is an instance of Show and that is the type of x. so using the word exists would be more intuitive to me.
15:04:03 <Cheery> I think it's enough for me this day. Thank you for all.
15:04:10 <earthy> yeah, that and 'the lambda calculus: it's syntax and semantics' should give you a *complete* knowledge of the lambda calculus. :)
15:04:27 <earthy> the latter is somewhat expensive though
15:04:31 <earthy> I don't own a copy
15:04:42 <huschi> unless the counstructor has type containing forall and the destructor has type containing exists, as far as i understood, so there doesn't seem to be a "best" solution.
15:04:49 <bd_> earthy: Complete and inconsistent, I suppose? :)
15:05:30 <earthy> bd_: well, the knowledge is quite consistent, it's just that 'the lambda calculus' is an ill-defined subject
15:05:39 <earthy> there's many. :)
15:05:41 <bd_> ah
15:05:50 <earthy> typed as well as untyped
15:05:53 <Cheery> and there's lot to add, I've learnt.
15:06:12 <earthy> well, you should at least know about subject reduction, normal forms, church-rosser...
15:06:25 <Cheery> It seems like guys haven't searched even half of possibilities of lambda calculus there possibly is.
15:06:45 <earthy> what guys?
15:07:07 <Cheery> humankind.
15:07:17 <Cheery> it's like you'd have yet another 200 years to go before you have *everything* about lambda calculus you can know. :)
15:07:29 <earthy> um. I kinda doubt that
15:07:42 <earthy> at least where it concerns the untyped lambda calculus
15:08:17 <earthy> http://www.cs.ru.nl/~henk/Masterclass.html
15:08:19 <lambdabot> Title: Masterclass Typed Lambda Calculus
15:08:33 <ehird> <ehird> @pl curry f x y = f (x, y)
15:08:33 <ehird> <lambdabot> curry = (. (,)) . (.) <-- Lambadbot really IS the answer to all life
15:09:48 <Cheery> earthy: That is the feeling I get, since I've not yet bored to lambda calculus.
15:10:50 <Cheery> Actually, it's like I've not yet even seen it all, things are getting interesting and more interesting every day.
15:11:01 <earthy> cheery: well, Henk Barendregt's been working on it for some 40 years and still isn't bored. :)
15:11:10 <earthy> and he is *scary* smart
15:12:02 <Cheery> by parts, I feel lambda calculus has already even changed the way how I think on a general aspects.
15:12:07 <Cheery> -a
15:12:16 <sorear> hi..
15:13:06 <pejo> Felleisen has a nice set of course notes on lambda calculus online for free. Well written and easy to read.
15:14:25 <mux> okay, I have two datatypes that auto-derive Enum, one for chess pieces clours (black and white) and one for the various piece types
15:14:45 * earthy is suddenly somewhat scared of himself
15:14:50 <mux> I have a third Piece datatype that contains a colour and a typee
15:14:54 <Cheery> :DD "Q: What is the shortest lie in computing?              A: It works."
15:14:57 <mux> I can easily enumerate all the pieces with:
15:15:00 * earthy learned all this stuff over 10 years ago
15:15:01 <mux> [ Piece x y | x <- enumFrom White, y <- enumFrom Pawn ]
15:15:10 <earthy> *shudder*
15:15:16 <mux> but I can't see how to easily define toEnum/fromEnum for this data-type
15:15:50 <earthy> oh well, time for bed
15:15:56 <Cheery> gn
15:16:14 <mux> I want to define toEnum and fromEnum so that I have an instance of Enum for Piece, of course
15:16:22 <ddarius> sorear: Show that the Curry-style simply typed lambda calculus with product types does not have the subject reduction property for (product)-eta-reductions.
15:16:53 <ddarius> earthy: I do that sometimes, usu. with CT.
15:17:55 <sorear> ddarius: what's the subject reduction property?  I *think* I get everything else...
15:18:45 <ddarius> sorear: That if an expression has a certain type reduction preserves it (i.e. it has the same type (partially) reduced).
15:19:30 <ddarius> (Incidentally, the Church-style lambda calculus does which may help)
15:20:45 <sorear> ok... now does curry-style lc give polymorphic types, or just monotypes?  (I know church w/o type abstraction gives monotypes)
15:20:54 <EvilTerran> wow. I think i just got something that's effectively a kinding error out of my c compiler.
15:21:03 <EvilTerran> test.c:8: cannot cast 'int **()()' to 'int **()'
15:22:38 <ddarius> sorear: It's still monotypes, it feels a bit more polymorphic but it isn't really.
15:23:11 <Saizan> mux: i think it's easy to do if you also derive Bounded
15:23:27 <mux> Saizan: ah, thanks for the hint
15:23:42 <sorear> I haven't studied any of this ... so if I write \x -> x (AIUI that's curry style), how do we guess what monotype to use?
15:24:27 <huschi>     Cannot match a monotype with `forall s. (SQL s) => s'
15:24:27 <huschi>       Expected type: IO (forall s. (SQL s) => s)
15:24:27 <huschi>       Inferred type: IO (forall s. (SQL s) => s)
15:24:33 <huschi> that's very cool.
15:25:00 <sorear> rank2 inference is impossible, that's why it is so confusing :)
15:25:24 <huschi> sorear: i there a way around this?
15:25:26 <ddarius> You don't really, you just leave it as an unbound type variable which is why it feels more polymorphic, but since you never generalize you don't get Haskell-98-like polymorphism
15:25:26 <sorear> bunch of very tricky heuristic algorithms, which don't always work
15:25:29 <twb> I'm curious: does Haskell have something analogous to Lisp's UNWIND-PROTECT?  That is, "do <something>, then do <something else>", where even if <something> fails (e.g. trying to open a file that doesn't exist), <something else> will be done.
15:25:46 <sorear> bracket
15:25:48 <ddarius> @type bracket
15:25:50 <lambdabot> Not in scope: `bracket'
15:25:54 <sorear> @type IO.bracket
15:25:56 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:26:13 <sorear> note that for hysterical raisons that only handles io errors
15:26:27 <sorear> if you want to handle e.g div-by-zero as well, you'll need:
15:26:34 <sorear> @type Control.Exception.bracket
15:26:37 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:26:44 <sorear> which is newer and marginally less portable
15:26:58 <sorear> ddarius: uh, what's an unbound type variable?
15:27:22 <sorear> my lack of knowledge in conventional inference algorithms is showing i think
15:28:01 * sorear knows inference in general, by having invented an inference algo where every type variable is quantified at all times
15:28:05 <ddarius> sorear: Like an unbound logic variable.  I.e. it's only one type, but it isn't determined.  Once fixed it's fixed everywhere.
15:28:35 <sorear> ddarius: you've completely lost me.  since when does lc have side effects?
15:28:59 <EvilTerran> if i understand right, if your function has an unbound type variable, then the compul
15:29:11 <huschi> ddarius, sorear: is there a way to avoid this problem, when it occurs?
15:29:12 <ddarius> sorear: I'm talking about for the purposes of type assignment/checking.
15:29:15 <EvilTerran> *the compiler will pick an arbitrary instance of you using it
15:29:32 <EvilTerran> and infer the type from that, thus doing something which may be unexpected. amirite?
15:29:54 <EvilTerran> s/function/expression/
15:31:04 <sorear> EvilTerran: in the standard inference algorithm that everyone but me understands, there's some funny business involving "unification" and "generalization"
15:31:22 <sorear> EvilTerran: so I'm told the system waits in some sense
15:31:56 <ChilliX> EvilT: What do you mean by arbitrary instance?
15:32:11 <EvilTerran> as i understand it, it waits 'til it sees you use it, and then it goes "aha! here, 'a' must mean 'Int'! I'll assume s/he meant that!"
15:32:39 <huschi> ?hpaste
15:32:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:32:49 <ddarius> sorear: if you write id = \x -> x, it has a type like a -> a, if elsewhere you use it as foo = id 3, a gets bound to Int so that id :: Int -> Int
15:33:08 <hpaste>  Huschi pasted "Rank 2 polymorphism type inference problem" at http://hpaste.org/1089
15:33:25 <ChilliX> EvilTerran: if there is an unbound ty var, type inference will add a binder (ie, universally quantidy the variable)
15:33:29 <sorear> Oh, I thought that was just the monomorphism restriction
15:33:31 <huschi> that's the code that generates this error message.
15:33:43 <huschi> is there any way around?
15:33:48 <EvilTerran> i'm not sure exactly what circumstances the thing i'm talking about happens in.
15:33:52 <qwr> sorear: em. being lost in terminology, what you mean by quantified (all the time)?
15:33:58 <ddarius> sorear: Well, everything is monomorphic.  I'm talking about the simply typed lambda calculus.
15:33:59 <EvilTerran> i may be confusing haskell with ML.
15:34:13 <sorear> qwr: forall is a quantifier
15:34:39 <sorear> ddarius: I understand the Church-style simply typed lc.  \ (x :: Bool) -> x
15:34:49 <ddarius> sorear: YEs.
15:34:49 <ChilliX> EvilTerran: ML and Haskell work exactly the same in this respect (they both use a process called Hindley-Milner type inference)
15:35:05 <sorear> ddarius: but the static semantics engine in my head doesn't grok this destructive unification thing :)
15:35:35 <EvilTerran> i'm sure there was some circumstance where one of them or t'other decided what type an expression was (and applied this type to all instances) only when you used it
15:35:55 <ChilliX> EvilTerran: Maybe you mean "defaulting" in Haskell
15:36:04 <EvilTerran> causing massive confusion if, say, it was only being used in files other than where it was defined
15:36:31 <ChilliX> This is happens when you have type class constraints involving a type variables which does *not* occur in the overall type of the expression
15:36:31 <EvilTerran> so using it in one file it was imported to could cause an error in a different file it was imported to
15:36:59 <ChilliX> the canonical example is "show . read"
15:37:14 <EvilTerran> if the latter file was written before the former but compiled after it
15:37:20 <qwr> sorear: as i've understood it, it joins two type points (variables) into one (and checks, that they have identical structure).
15:37:23 <SamB> EvilTerran: you can't do that in Haskell
15:37:30 <SamB> well.
15:37:35 <sorear> qwr: join is a verb
15:37:54 <EvilTerran> i'm not sure if i've got the details right. it was something like that. O.o
15:37:56 <ChilliX> EvilTerran: compilation order does not make a difference
15:38:10 <sorear> qwr: destructive verbs don't exist in the mathematical realm I assumed the simply typed lambda calculus would inhabit
15:38:20 <EvilTerran> ChilliX, it affects which lines the compiler burps at
15:38:46 <ddarius> typeinfer(Var,TyEnv,Type) :- lookup(Var,TyEnv,Type), typeinfer(App F X,TyEnv,B) :- typeinfer(F,TyEnv,A -> B), typeinfer(X,TyEnv,A), typeinfer(Abs V Body,TyEnv,A -> B) :- typeinfer(Body,[(V,A)|TyEnv],B)
15:38:58 * sorear sniffs
15:39:03 <sorear> prolog?
15:39:20 <qwr> sorear: the joining should be stateing that two type variables are equivalent
15:39:21 <ddarius> sorear: Yes, infering simple types for a Curry-style lambda calculus.
15:39:36 <ddarius> My prolog syntax is somewhat rusty.
15:39:49 <ddarius> And I'm leaving some stuff implicit.
15:40:03 <ehird> isn't `ap = liftM2 id' == `ap = liftM2'/
15:40:05 <ehird> *?
15:40:11 <ChilliX> EvilTerran: hmm, seems hard to pin down w/o an example
15:40:15 <sorear> qwr: not sure I get this 'are' thing
15:40:26 <shapr> yar
15:40:31 <sorear> qwr: my concept of join is more of a 'becomes'
15:40:32 <ddarius> ehird: No. f id /= f in general.
15:40:46 <sorear> qwr: and time is an illusion
15:40:53 <ddarius> hardly ever actually.
15:40:55 <shapr> and lunchtime doubly so
15:40:59 <EvilTerran> lunchtime dou- damniot
15:41:00 <EvilTerran> -o
15:41:02 <sorear> qwr: perpetrated by the java cartel
15:41:09 <ChilliX> Hey shapr!
15:41:13 <qwr> sorear: when they are not equivalent, they will not become - unification error is then the result
15:41:15 <shapr> Gutentag ChilliX!
15:41:22 <ChilliX> Guten Tag :)
15:41:25 <shapr> ChilliX came up with the #haskell slogan years ago :-)
15:41:35 <shapr> ChilliX++
15:41:37 <ehird> ddarius: what would differentiate then?
15:41:39 <sjanssen> funk in funktion?
15:41:42 <sorear> which one?
15:41:43 <shapr> sjanssen: Yup, that's it.
15:41:55 <ChilliX> Did I?
15:41:56 <sorear> we've changed it sooo often
15:42:09 <shapr> ChilliX: Yup. You remember I confused you by speaking some German?
15:42:25 <sorear> qwr: unify 'A' with 'B' -> 'C'.  If that evaluates to _|_ my inferer is worthless.
15:42:27 <ChilliX> Yeah, that's bound to confuse me ;)
15:42:29 <shapr> heh
15:42:32 <ddarius> ehird: liftM2 id and liftM2 don't have the same type.
15:42:38 <shapr> Idag kan jag tala svenska istдllet
15:42:50 <shapr> ChilliX: In the meantime I've learned Swedish, I bet that's even more confusing!
15:42:51 <ChilliX> Ahem, or maybe not ;)
15:42:56 <EvilTerran> ...that's german?
15:43:01 <shapr> EvilTerran: Nah, that was Swedish.
15:43:08 <EvilTerran> i didn't think it was german.
15:43:09 <ChilliX> shapr: No, not confusing, just incomprehensible ;)
15:43:13 <shapr> haha
15:43:24 <ehird> @kind id
15:43:26 <shapr> EvilTerran: Do you speak German, Swedish, or other non-English language?
15:43:26 <lambdabot> Not in scope: type variable `id'
15:43:31 <ehird> oops
15:43:32 <ehird> @type id
15:43:34 * shapr waves at edwardk
15:43:35 <lambdabot> forall a. a -> a
15:44:02 <chessguy> hi iall
15:44:10 <dons> moin.
15:44:10 <chessguy> oh yeah, i'm off to a good start
15:44:14 <shapr> greetz chessguy
15:44:16 <ChilliX> shapr: Did you see the 0.1 package ndp release?
15:44:19 <EvilTerran> shapr, not with any fluidity. i can generally get the gist of written french and german, and can identify quite a lot of languages, but that's about it
15:44:28 <shapr> EvilTerran: That's an excellent start.
15:44:45 <shapr> ChilliX: How's NDP?
15:44:55 <EvilTerran> "eeh... that looks like polish" "hm. i think that's czech" etc
15:44:59 <qwr> sorear: it would evaluate to B -> C
15:45:04 <shapr> ChilliX: Oh, I heard about the BIG box you guys got.
15:45:22 <ChilliX> Well, we did release the first version (with very limited functionality!) that actually does its stuff in parallel.
15:45:27 <shapr> w00!
15:45:27 <sorear> shapr: you want wierd language id?
15:45:33 <shapr> sorear: Huh?
15:45:33 <qwr> sorear: at least when A is alias for some other type expression
15:45:43 <qwr> sorear: s/is/is not/
15:45:53 <shapr> sorear: Jag fцrstеr inte.
15:45:54 <sorear> shapr: emacs stalled for a half-second loading shift-jis when you said that :)
15:45:59 <shapr> ah
15:46:04 <EvilTerran> shapr, thanks. i'm not so convinced, but i guess it's better than nothing.
15:46:04 <ChilliX> shapr: It's taken a long time, I know, but we're getting there
15:46:09 <shapr> Oh, I wonder if I'm using 8859
15:46:26 <shapr> ChilliX: Oh, what's up with Associated Types these days? I should really go check out your homepage.
15:46:39 <shapr> ChilliX: Hey, I'm glad someone is doing it. I've never gotten around to hacking on it.
15:46:50 <ChilliX> shapr: well, still trying to find the time to finish implementing associated type synonyms
15:46:50 <sorear> qwr: Ok.  now suppose that somewhere else there's a (A,A) lying around.
15:46:54 <ChilliX> data types are all done
15:47:03 <shapr> I have been doing a lot of paid Haskell work lately though! Yay!
15:47:08 <sorear> qwr: the side effects are needed to turn it into (B -> C, B -> C)
15:47:22 <ChilliX> The problem is that we got more ambitious in the meantime
15:47:32 <shapr> ChilliX: Oh hey, do you know if committee members for things like CUFP get any subsidies for travel or entrance?
15:47:36 <ChilliX> We want assoc type synonyms and GADTs to work together fully
15:47:37 <sorear> qwr: I use a unify (L, R, IN) -> IN' in my system, but that doens't seem to be used here
15:47:59 <sorear> ChilliX: I smell a combinatoric explosion :(
15:48:07 <ChilliX> shapr: no, they don't - the workshop/conf budgets simply are not big enough to allow that
15:48:11 <qwr> sorear: yes. you stated that A = B -> C, so (A, A) = (B -> C, B -> C)
15:48:12 <shapr> Ah well.
15:48:19 <shapr> Means I probably won't be in Freiburg then.
15:48:36 <shapr> Not unless I'm already back in Sweden then, maybe it'd be cheaper to fly from there.
15:48:43 <sorear> qwr: no I stated unify(TVar "A", TVar "B" :-> TVar "C").  That is just a computation
15:48:48 <ChilliX> sorear: We know the problem og type inference for GADTs and assoc type synonyms is decidable and we have an algorithm to do it
15:48:57 <sorear> qwr: variables like A don't change in maths
15:49:13 <sorear> qwr: hence my confusion...
15:49:26 <sorear> ChilliX: now implement Foozles.
15:49:29 <shapr> hah
15:49:47 <shapr> I was especially amused that Foozles quoted Wadler.
15:49:52 <shapr> Er, referenced
15:50:17 <shapr> Man, my brain is fried.. I think I'll go play a game some and then look at FLM.
15:50:50 <sorear> bah, I've already forgotten what FLM is
15:50:56 <sorear> @grep-logs FLM --wishlist
15:50:57 <lambdabot> Unknown command, try @list
15:51:00 <shapr> Fermat's Last Margin
15:51:04 <qwr> sorear: it won't change. it gets a attribute I'm equal to that thing. or reference. ;)
15:51:15 <shapr> I've done so much HAppS work lately that I can probably write FLM without much trouble.
15:51:35 <Mushy-pea> Hi.
15:51:35 <sorear> qwr: how do you add the attribute purely?
15:51:36 <qwr> sorear: some weird dual world view due to implementation
15:51:46 <shapr> hiya Mushy-pea
15:51:57 <shapr> Mushy-pea: Have you seen the lambda?
15:52:11 <Mushy-pea> No, just joined.
15:52:17 <Mushy-pea> What about it?
15:52:31 <shapr> The lambda is our friend!
15:52:38 <shapr> Mushy-pea: But seriously, are you learning Haskell?
15:52:40 <ChilliX> shapr: re Freiburg, that's a pity :/
15:52:44 <Mushy-pea> Yes.
15:52:47 <shapr> ChilliX: Yeah, too bad.
15:52:53 <shapr> Mushy-pea: Cool! For business or pleasure?
15:53:18 <Mushy-pea> Open source development, so a bit of both.
15:53:20 <qwr> sorear: purely you should state it somewhere else. and later check it.
15:53:21 <ChilliX> shapr: are you on the CUFP committee?
15:53:22 <shapr> ooh nice
15:53:25 <shapr> ChilliX: Yup
15:53:40 <qwr> sorear: i think...
15:53:40 <shapr> ChilliX: I've gotten two people, so I figure I'm doing well.
15:53:50 <shapr> ChilliX: Er, three if you count HAppS.
15:53:57 <shapr> Though really alexj got himself.
15:53:58 <ChilliX> shapr: cool :)
15:53:58 <procyon_> I HAVE SEEN THE LAMBDA!  And it was APPLICABLE!
15:54:04 <shapr> procyon_: AWRIGHT!
15:54:12 <shapr> procyon_: That should be a Yow! quote.
15:54:18 <procyon_> hehe
15:54:29 <sorear> qwr: I've a working pure type inference engine.  but it didn't look like :: Type -> Type -> ()
15:54:32 <shapr> Mushy-pea: What sort of OSS development?
15:54:32 <kc5tja> @remember procyon_  I HAVE SEEN THE LAMBDA!  And it was APPLICABLE!
15:54:33 <lambdabot> Done.
15:54:54 <procyon_> I plan on seeing the pi soon.
15:55:09 <sorear> procyon_: big pi?
15:55:24 <procyon_> sorear pi calculus.
15:55:27 <shapr> appl pi!
15:55:28 <sorear> procyon_: also look at brackets, those are really mind-bending
15:55:39 <sorear> procyon_: pi abstractions rock
15:55:49 <kc5tja> To paraphrase Arthur C. Clarke -- "Look -- pi!  _It's full of digits!_"
15:56:09 <shapr> Mushy-pea: Do you have any questions about Haskell?
15:56:16 <procyon_> sorear: I am terribly fascinated... but I need to get more natural with Haskell in general before I go tackling another calculus.
15:56:21 <ddarius_> procyon_: The pi calculus unfortunately does not have a pi binder.
15:56:43 <shapr> Doesn't JoinHs implement some of the pi calculus?
15:56:46 <sorear> procyon_: pi abstractions are found in pure type systems!
15:56:56 <Mushy-pea> back in a minute
15:57:00 <ddarius> sorear: Or in dependently typed systems.
15:57:17 <Mushy-pea> talking on mobile phone
15:58:12 <shapr> Mushy-pea: Wow, I can't do that and type at the same time. I'm impressed.
15:58:16 <qwr> sorear: but the HM algoritm with unification is imho optimised for computation with side effects.
15:58:43 <sorear> qwr: I've never seen a decent explanation of HM
15:58:47 <Mushy-pea> shapr: web based forum system http://sourceforge.net/projects/perlbb
15:58:47 <lambdabot> Title: SourceForge.net: perlBB (perl Bulletin Board)
15:58:51 <sorear> qwr: I was forced to reinvent it
15:59:29 <shapr> Mushy-pea: Oh, so you're interested in Pugs then?
15:59:31 <qwr> sorear: i reverse engineered some minicaml implementation once. took quite a time. french variable names didn't help eighter...
15:59:44 <ddarius> sorear: It's pretty easy to make the Prolog code I gave above into a HM inferer.
15:59:58 <Mushy-pea> yes
16:00:10 <sorear> ddarius: that assumes you understand prolog :P
16:00:22 <shapr> Mushy-pea: Spiffy!
16:00:59 <Mushy-pea> is there a binary for i386 netBSD?
16:01:00 <ddarius> Prolog is a horrible language, but well worth learning.  However, if you are familiar with some other logic language, it would be just as easy to write it in them.
16:01:03 <qwr> sorear: and it is... clever. and somewhat hackish.
16:01:13 <Mushy-pea> for pugs?
16:01:20 <sorear> qwr: what is?
16:01:45 <sorear> ddarius: does [] count as logic programming, or do I need more magic features
16:02:06 <ddarius> sorear: No, not even close.  Logic variables would also be required.
16:02:06 <qwr> sorear: the destructive trick there, where they use the object identify for variable identity
16:02:12 <sorear> I've read wikipedia's description of prolog, and it looks like any implementation would need to solve halting.
16:02:22 <Mushy-pea> or do i have to compile it with GHC?
16:02:34 <procyon_> sorear: from talking to you, I think you already know most of prolog.. you just haven't learned it's syntax.
16:02:52 <ddarius> sorear: I have a (pure) Prolog implementation in about 300ish lines of code.  The first cut was about 80, but then I added stuff.
16:03:02 <twanvl> You can just read the prolog   "P(X,Y) :- Q(Z), R(U,V)"   as   "instance (Q z, R u v) => P x y"
16:03:15 <sorear> ddarius: parenthesize
16:03:25 <sorear> ddarius: (pure Prolog) implementation
16:03:31 <sorear> ddarius: pure (Prolog implementation)
16:03:46 <sorear> are you talking no prolog IO or no haskell IO
16:04:00 <sorear> twanvl: :)
16:04:18 <procyon_> perhaps: pure prolog $ implementation
16:04:24 <sorear> twanvl: I'm told prolog has more magic impossible-looking-to-implement features
16:04:39 <ddarius> sorear: It doesn't support the non-logical features of Prolog, but then it also can arranged to purely return a list of results so both.
16:05:00 <qwr> sorear: http://pauillac.inria.fr/~remy/cours/appsem/ocaml-ml.html#toc4
16:05:02 <ddarius> It uses (with that type) Lazy.ST
16:06:34 <sorear> ddarius: might be interesting.  I've read dozens of pages of English descriptions of quicksort but didn't understand it until I saw the Haskell...
16:08:40 <ddarius> I have a simply typed lambda calculus inferer (and (untyped) lambda calculus) evaluator as some example input in the file...
16:11:11 <Mushy-pea> what platforms has pugs been tested on?
16:11:20 <shapr> Mushy-pea: I don't know if there's an i386 bsd binary, have you asked on #pugs?
16:11:29 <shapr> Mushy-pea: Actually, #perl6 may be the right place to ask.
16:11:46 <Mushy-pea> ok
16:12:04 * shapr bails out to play with xmonad
16:13:20 <ortmage> has anyone succeeded in parsing c++ with parsec?
16:14:35 <ddarius> ortmage: No one is that masochistic.
16:15:05 <ortmage> i wish they were... i don't want to have to write the grammar myself
16:16:16 <sorear> ortmage: can't you just use gcc's yacc grammer in happy?
16:16:29 <ddarius> ortmage: It's not sooo much the grammar as the semantic information you need to accurately parse C++.  However, you can ignore that and accept a wider language and deal with it later.
16:16:40 <ddarius> FOG works(/ed) that way.
16:17:04 * sorear parses a wider language than h98 in 400 lines of yacc
16:18:21 <hpaste>  mux pasted "Problem with Enum" at http://hpaste.org/1090
16:18:35 <mux> anyone sees what's happening here?
16:18:52 <ortmage> ddarius, that's quite true... if it weren't for inconsistant style and overuse of typedef, i'd just use grep to help reason about the dependencies
16:27:20 <TSC> @src fromEnum
16:27:20 <lambdabot> Source not found. Take a stress pill and think things over.
16:27:30 <TSC> @src enumFrom -- oops
16:27:31 <lambdabot> Source not found. I feel much better now.
16:29:21 <TSC> mux: It seems like it's calling toEnum 12, but I can't see why
16:29:40 <mux> TSC: I can't see why either
16:29:57 <mux> *Main> fromEnum (maxBound :: Piece)
16:29:57 <mux> 11
16:30:02 <mux> it definitely shouldn't
16:30:08 <TSC> Yeah, the bounds look right
16:31:10 <hpaste>  Mushy-pea pasted "Simple program works.  But does it look nice?" at http://hpaste.org/1091
16:31:28 <Mushy-pea> OK.
16:31:48 <Mushy-pea> I wrote this little triangular number calculator.
16:31:54 <sjanssen> mux: you don't have an implementation for enumFrom
16:32:21 <Mushy-pea> It works, but....Someone on a forum said it displayed bad form, the way I used a do block.
16:32:25 <mux> sjanssen: I thought that the minimal definition was toEnum and fromEnum
16:32:26 <sjanssen> the default for enumFrom is something like: enumFrom = iterate succ
16:32:29 <mux> I can easily define enumFrom
16:32:32 <TSC> There's no default like "enumFrom     x   = enumFromTo     x maxBound" ?
16:32:35 <mux> [ Piece x y | x <- enumFrom White, y <- enumFrom Pawn ]
16:33:03 <sjanssen> TSC: no, because the default doesn't know whether the type is Bounded
16:33:20 <Mushy-pea> So, can anyone give me some pointers about avoiding structure potholes?
16:33:33 <TSC> Oh, Enum is not guaranteed to be Bounded
16:33:53 <TSC> Of course, Enum Integer (:
16:33:56 <mux> ok, so really I need to define toEnum, fromEnum *and* enumFrom
16:34:15 <Mushy-pea> btw, how do you ger lambdabot to compile something?
16:34:29 <Botje> > sum [1..5]
16:34:30 <lambdabot>  15
16:35:12 <Mushy-pea> lambdabot: http://hpaste.org/1091
16:35:40 <TSC> It's not that smart (:
16:35:40 <Mushy-pea> Guess not....:)
16:35:46 <Mushy-pea> :)
16:36:00 <TSC> let result x = foldr (+) 0 [1..read x] in result "5"
16:36:03 <TSC> > let result x = foldr (+) 0 [1..read x] in result "5"
16:36:05 <lambdabot>  15
16:36:09 <TSC> But you can do that
16:36:33 <mux> sjanssen: would that be okay?
16:36:34 <mux>   enumFrom p = [ toEnum x | x <- [fromEnum p .. fromEnum (maxBound :: Piece) ]]
16:36:42 <mux> seems to work
16:36:46 <QtPlatypus> Mushy-pea: I would indent everything under the do.
16:36:56 <QtPlatypus> :type read
16:37:00 <mux> that's a lot of boilerplate code that really could have been generated :-/
16:37:23 <QtPlatypus> @type read
16:37:25 <lambdabot> forall a. (Read a) => String -> a
16:37:43 <sjanssen> mux: that's fine.  Maybe you could use: enumFrom x = enumFromTo x maxBound?
16:38:53 <mux> sjanssen: didn't know about enumFromTo, but wouldn't that be defined with enumFrom and thus lead to problems?
16:39:19 <sjanssen> mux: I'm really not sure how it is defined
16:39:20 <QtPlatypus> How should I read that type?  Forall a such that there is a instance of read a.  Take a String and return something of type a?
16:39:21 <hpaste>  procyon annotated "Simple program works.  But does it look nice?" with "cleaner" at http://hpaste.org/1091#a1
16:39:22 <Mushy-pea> Qtplatypus: OK.
16:39:39 <mux> sjanssen: well that works, thanks :)
16:40:27 <TSC> QtPlatypus: For all readable types a, take a string and return an a
16:42:02 <QtPlatypus> TSC: Thanks.
16:45:58 <hpaste>  procyon annotated "Simple program works.  But does it look nice?" with "With haddoc comments and type annotations" at http://hpaste.org/1091#a2
16:46:33 <procyon_> Mushy-Pea: there's a more stylistic form.
16:46:58 <twb> Anybody know why nhc98 is in Debian/stable but not Debian/unstable?
16:49:23 <sjanssen> @check (\x -> x > 0 ==> foldr (+) 0 [1.. x :: Integer] == x*(x+1) `div` 2)
16:49:24 <lambdabot>  OK, passed 500 tests.
16:49:41 <Igloo> twb: It bitrotted
16:49:49 <twb> Igloo: because no one loved it?
16:50:07 <Igloo> No-one had the time to love it enough
16:50:11 <dmwit> ?src sum
16:50:11 <lambdabot> sum = foldl (+) 0
16:50:12 <twb> Fair enough.
16:50:40 <dmwit> Isn't foldr the more Haskell-friendly one?
16:50:48 <hpaste>  sjanssen annotated "Simple program works.  But does it look nice?" with "use readLn" at http://hpaste.org/1091#a3
16:50:57 <Igloo> It might be better now, but it didn't build for me earlier this week
16:51:16 <sjanssen> dmwit: foldl is better for sum (because (+) is strict)
16:51:28 <vincenz> foldl'
16:51:28 <dmwit> o
16:51:30 <QtPlatypus> @hoggel [a] -> a -> Bool
16:51:30 <lambdabot> Unknown command, try @list
16:51:35 <QtPlatypus> @list
16:51:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:51:48 <vincenz> @hoogle [a] -> a -> Bool
16:51:48 <vincenz> == elem
16:51:48 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
16:51:48 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
16:51:51 <dmwit> @hoogle [a] -> a -> Bool
16:51:51 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
16:51:52 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
16:53:20 <QtPlatypus> Thats smart of hoogle.
16:53:43 <dmwit> ?botsnack
16:53:43 <lambdabot> :)
16:56:04 <dmwit> ?hoogle a -> Int -> [a]
16:56:05 <lambdabot> Prelude.replicate :: Int -> a -> [a]
16:56:16 <chessguy> @hoggle map
16:56:17 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
16:56:17 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
16:56:17 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
16:59:39 <dmwit> :t const
16:59:41 <lambdabot> forall a b. a -> b -> a
17:01:56 <ddarius> @djinn a -> b -> a
17:01:56 <lambdabot> f a _ = a
17:02:25 <procyon_> @djinn a -> b -> b
17:02:25 <lambdabot> f _ a = a
17:12:23 <hpaste>  DangerMouse pasted "added moves" at http://hpaste.org/1093
17:15:41 <dmead> ?seen augustss
17:15:41 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
17:17:20 <Mushy-pea> Bit of an off topic one....
17:18:01 <Mushy-pea> ....where is the link on google.co.uk to put a domain in their search path?
17:18:17 <Mushy-pea> It's not where it used to be.
17:19:48 <Mushy-pea> I've found it now.
17:19:51 <Mushy-pea> :)
17:19:57 <dpiponi> Mushy-pea: Just use google. Search on "link:www.google.co.uk submit site"
17:20:28 <dpiponi> Actually that should have been 'site'but 'link' worked
17:21:22 <dpiponi> So I have a Haskell puzzle for anyone who's out there.
17:21:44 <Mushy-pea> Yes, I've done it now.
17:22:05 <dpiponi> It's easy to write the minimax algorithm using foldr min.
17:22:21 <dpiponi> Is there an equivalent way of writing alpha-beta search using foldr?
17:24:21 <edwardk> dpiponi: you should be able to slap it together with scanr then convert that to a foldr
17:26:25 <dpiponi> edwardk: Hmmm...not sure how the scanr helps. (It's probably really obvious but I'm not seeing it.)
17:28:03 <chessguy> dpiponi: in practice, i don't think you want to do it in quite such an encapsulated way
17:29:19 <dpiponi> chessguy: I'm trying to see if there's another way to look at alpha-beta
17:29:29 <dmead> :o
17:29:44 <chessguy> you're such a purist :)
17:29:54 <dons> ?yow!
17:29:55 <lambdabot> My Aunt MAUREEN was a military advisor to IKE & TINA TURNER!!
17:29:55 <edwardk> i have a fairly simple haskell alpha-beta around here somewhere in a chat log if i can find it
17:30:16 <sorear> hi.
17:30:43 <edwardk> from when goltrpoat was transcoding some of his c chess stuff into haskell iirc
17:30:47 <sorear> what! C doesn't do % on doubles!
17:30:56 <dpiponi> chessguy: I'm not really that much of a purist. I'm hoping that a different perspective might lead to solutions to other problems that might not be so purist.
17:31:18 <chessguy> dpiponi: well, in practice, alphabeta is usually modified extensively
17:31:34 <edwardk> dpiponi: do you have a concise version of minimax in the style you want?
17:31:39 <chessguy> so i'm not sure you want to write it in terms of map and foldr and stuff
17:31:54 <edwardk> yeah, i tend to use MTD(f) with iterative deepening, etc.
17:32:01 <dpiponi> chessguy: Actually, that's precisely the reason I was thinking about rewriting alphabeta
17:32:18 <edwardk> those tweaks would be terribly invasive in an overly functional style (they were last time i adapted the code anyways)
17:32:38 <chessguy> exactly, edwardk
17:33:09 <chessguy> incidentally dpiponi, if you have a concise minimax, i'd like to see it too
17:33:38 <chessguy> mostly because i'm lazy
17:33:42 <edwardk> dpip: http://www.arcknowledge.com/gmane.comp.lang.haskell.general/2002-08/msg00148.html mentions alphabeta stuf in haskell. haven't looked at the code. just googled real quick =)
17:33:44 <edwardk> hehehe
17:33:45 <lambdabot> Title: Re: AlphaBeta (chess) in Haskell, http://tinyurl.com/274b39
17:33:54 <sorear> any yhcers here?
17:34:00 <chessguy> i assume you've read whyfp
17:34:05 <chessguy> ?where whyfp
17:34:05 <lambdabot> I know nothing about whyfp.
17:34:08 <chessguy> bah
17:34:08 <hpaste>  dpiponi pasted "Super simple minimax" at http://hpaste.org/1094
17:34:32 <dpiponi> It's just some trivial folding on a tree
17:34:42 <sorear> ah, the answer to "what is MOD_F for?"
17:34:44 <edwardk> yeah
17:34:47 <sorear> Case(MOD_F) abort(); Break;
17:34:49 <sorear> hehe.
17:35:20 <chessguy> ?where+ whyfp http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
17:35:20 <lambdabot> Done.
17:35:48 <chessguy> dpiponi: err, was there a reason you didn't just use Data.Tree?
17:36:14 <hpaste>  dpiponi annotated "Super simple minimax" with "Alphabeta not as a fold" at http://hpaste.org/1094#a1
17:36:48 <dpiponi> chessguy: if time (look up name of structure on web)<time (write it myself) then ...
17:36:51 <edwardk> looks like he was fixated on the whole tree catamorphism angle
17:36:52 <dpiponi> chessguy :-)
17:37:07 <chessguy> lol, the structure is very similar
17:38:40 <dpiponi> Data.Tree is different. There are labels at every node, not just leaves
17:38:59 <Mushy-pea> Got to go to bed now.  Work in the morning.
17:39:10 * Mushy-pea goes to bed :)
17:40:10 <dpiponi> edwardk: not fixated, just curious. :-)
17:40:20 <edwardk> heh
17:40:49 <chessguy> actually, with Data.Tree, your instance of fmap just becomes fmap f (Node x ts) = Node (f x) (map (fmap f) ts)
17:40:53 <edwardk> anyways, i think you'll run into a problem there, i think the new problem requires some sort of zygomorphism or at least a hylo into a different structure
17:40:54 <chessguy> (i think that's right)
17:41:21 <chessguy> dpiponi: well for alphabeta, you want labels at every node
17:42:13 <dpiponi> chessguy: For plain and simple alphabeta you don't need them (I think). You certainly need them for many of the heuristics.
17:42:19 <edwardk> your map (fmap f) in your base functor doesn't seem sufficient on its own, so you need some form of hylomorphism to change the structure or a different traversal with memory
17:43:05 <chessguy> edwardk: whose, mine?
17:43:14 <edwardk> (when its adapted to alphabeta, hrmm, trying to work it out now, gah, i'd flushed all these thoughts a couple months ago) =)
17:43:33 <chessguy> i'd flushed them all a couple years ago :)
17:43:37 <edwardk> chess: nah dpiponi's minimax code
17:43:52 <edwardk> trying to think of how close you can get to the structure with alphabeta
17:44:41 <dpiponi> edwardk: my fmap is simply there to flip the signs of all my scores. Seems sufficient to me. What kind of structure change are you interested in having it perform?
17:45:51 <ddarius_> monadic fold
17:46:56 <dons> so, how are we going to change the world today!? :-)
17:47:15 * dons is fully caffeinatted. hack time!!
17:47:18 <dons> hack hack hack!
17:47:36 <chessguy> hey dons, any thoughts on why nobody's ever put together a general haskell AI toolkit?
17:48:12 <chessguy> i mean, AI is supposed to be a major selling point of FP
17:48:20 <sorear> <- ayhi time!
17:48:24 <dons> hmm. strange, no? we implemented a AB with pruning and A-star for ICFP a couple of years ago
17:48:29 <dons> there really should be a general kit
17:48:31 <SamB> chessguy: that was a lisp fad
17:48:41 <dons> chessguy: i suspcet its because the haskell community of researchers doesn't do much AI
17:48:49 <sorear> too much thunder, bye
17:48:55 <chessguy> dons: that's a shame
17:49:01 <Eelis> it would be pretty sad if we would need something as obscure as AI as a "major selling point of FP"
17:49:13 <SamB> also, we don't actually have any sort of "general AI"
17:49:14 <chessguy> i'm putting together an AI Strike Force!
17:49:17 <SamB> as far as I'm aware
17:49:29 <dpiponi> I can never remember which is which out of hylo-, zygo-, cata-, and ana-morphisms. Is there a good web page on the subject. (Yes, I could download a bunch of PDFs but a simple summary web page would be nice.)
17:49:44 <edwardk> dpip: so carry a state monad with alpha and beta and voila =)
17:49:48 <SamB> I don't remember hylo- or zygo- at all...
17:49:50 <chessguy> i meant general toolkit, as in, with AI tools that could be adapted anywhere
17:50:02 <chessguy> e.g., a module for ANNs, a module for learning, etc., etc.
17:50:14 <edwardk> dpip: not that i know of, i obsessed over them for a while when i figured i might add them in as keywords to my toy language
17:50:17 <chessguy> an Eelis where do you get off calling AI "obscure"?
17:50:18 <dolio> Hmm... Hylo is like map, no?
17:50:18 <SamB> but I'm pretty sure ana and cata are related to fold and unfold?
17:50:27 <dolio> Ana is unfold, cata is fold.
17:50:30 <kosmikus> ana is build/unfold, cata is fold, hylo is unfold followed by fold
17:50:49 <SamB> wait a minute
17:50:51 <kosmikus> I don't recall zygo right now
17:50:56 <edwardk> dolio: hylo tears down a structure and builds another, its like foldr/build
17:50:59 <SamB> how does that qualify as a morphism?
17:51:03 <dolio> I could be wrong.
17:51:06 <Eelis> chessguy: relatively few programmers are interested in AI
17:51:13 <SamB> so hylo is like a fold followed by an unfold?
17:51:14 <dpiponi> Yes, I can remember cata- because cata- means down and I think of folding down an envelope. Can't remember the others/
17:51:23 <dolio> edwardk: Is para- the map-like one?
17:51:46 <dpiponi> Yup, there's definitely need for a summary web page!
17:51:51 <kosmikus> SamB: no, unfold followed by fold
17:51:55 <edwardk> er kos: hylo is a cata then an ana, i.e. you can use a hylomorphism to build a tree from a list
17:52:18 <kosmikus> para is a cata paired with the identity
17:52:21 <dpiponi> http://etymon.blogspot.com/2004/08/bananas-lenses-envelopes-and-barbed.html
17:52:24 <lambdabot> Title: Etymon: Bananas, Lenses, Envelopes, and Barbed Wire., http://tinyurl.com/yuufk4
17:52:27 <dpiponi> It's a cheat sheet!
17:52:41 <kosmikus> edwardk: no, you have to build before you can destruct
17:53:11 <edwardk> checking my code, its been a while =)
17:54:09 <edwardk> yep
17:54:13 <edwardk> i'm a moron =)
17:54:27 <edwardk> just looked at my para keyword syntax, you're right
17:54:51 <kosmikus> ok
17:54:59 <kosmikus> I might have been wrong. It's late ... ;)
17:55:28 <kosmikus> but hylo is the fusion/deforestation thing, therefore there should be an intermediate structure
17:55:40 <edwardk> [|(c,+),(g,p)|] = (|c,+|) . [(g,p)]    forgot the way the . runs =)
17:55:43 <dons> hey kosmikus
17:55:51 <kpreid> dons?
17:55:53 <kosmikus> hey dons
17:55:55 <kpreid> oh, hi
17:56:06 <kpreid> dons: do you have some spare time to debug my lambdabot?
17:56:09 <dons> see malcolm's recent paper on hylo fusion :-)
17:56:14 <dons> kpreid: no :(
17:56:17 <dons> super super busy.
17:56:20 <kpreid> ok
17:56:28 <dons> basically, you can tell if i have spare time by seeing if the HWN came out this week
17:56:41 <kosmikus> dons: :)
17:56:44 <dons> and , well, 2 weeks before the ICFP deadline, i'm in hack/write mode.
17:57:02 <kpreid> super-short version in case it's obvious: it started exiting silently during Initializing... immediately after I did an OS upgrade
17:57:11 <dons> kpreid: ah ok. try removing State/seen
17:57:20 <dons> that's usually the issue (the binary format changed a while ago)
17:57:20 <kpreid> why would seen be OS-dependent?
17:57:24 <edwardk> wow time flies, ICFP already?
17:57:55 <edwardk> now i feel like a slacker
17:58:01 <dons> kpreid: no idea.
17:58:15 <kpreid> dons: works. thanks. I'll be more thorough about assuming it's seen's fault now :)
17:58:19 <dons> kpreid: i only suspect you might have updated your binary library in the mean time.
17:58:28 <kosmikus> oh, don't remind me of ICFP ...
17:58:28 <chessguy> dpiponi: so are you thinking that writing AB in terms of fold/map/etc., it will be more able to allow changes to the algorithm?
17:58:31 <dons> kosmikus: ICFP!
17:58:34 <dons> oh, oops.
17:58:53 <kosmikus> hehe, I still have a contest to co-prepare ;)
17:59:14 <kosmikus> so no paper this year. I hope I get one ready for HW though.
17:59:31 <dpiponi> chessguy: Exactly.
17:59:51 <dpiponi> chessguy: Think of minimax as a declarative statement of what you want to compute, but alphabeta is the algorithm
18:00:09 <chessguy> hmm
18:00:32 <dpiponi> chessguy: I want to find what turns the declarative form into an algorithm so you can write down more general declarations that might not be so easy to convert to alpha-beta style
18:00:46 <chessguy> so alphabeta is just a shortcut for minimax, that's been known for years
18:01:31 <dpiponi> chessguy: Yeah, but I was just curious to see if there's a way for people to have their minimax code automatically turned into alpha-beta so they don't have to think about alpha and beta
18:01:39 <chessguy> aha
18:02:06 <dpiponi> dpiponi: These are just random thoughts - I've no evidence there is a nice way to do this.
18:02:35 <chessguy> dpiponi: talking to yourself now? :)
18:04:17 <chessguy> dpiponi: you might do better to unroll minimax first then
18:04:42 <dpiponi> chessguy: My fingers seem to be preprogrammed to type my login. I guess that's usually quite useful.
18:04:44 <chessguy> transform that into alphabeta, and then see if you can re-roll it into a similar form to what you have now
18:06:02 <dpiponi> Dumb question. What do you mean by unroll here?
18:06:11 <chessguy> make less concise
18:06:26 <dpiponi> OK, not unroll as in loop unrolling
18:06:31 <chessguy> no, sorry
18:06:50 <chessguy> (though the idea's not so different)
18:07:19 <dpiponi> Anyway, I already have a longer minimax that's intended to look as similar to the alphabeta as possible and I'll probably play with it a bit more later.
18:07:37 <chessguy> care to paste it?
18:08:13 <dpiponi> It's very uninteresting but here goes...
18:08:23 <chessguy> i rather like this quote about HOFs: I read lots of code with recursion -- and it was hard to read, because it is hard to retrieve the data flow from it. -- HenningThielemann
18:08:39 <chessguy> that data flow is exactly what you're trying to modify right now
18:09:35 <dpiponi> Actually I don't have it any more. I've already fiddled with it too much.
18:09:40 <chessguy> lol
18:09:44 <twb> http://darcs.haskell.org/haskell-prime-report/report/haskell-prime-draft.html <-- the PDF and PS give 404
18:09:47 <lambdabot> Title: The Haskell Prime Report: Working Draft, http://tinyurl.com/y99amy
18:10:05 <hpaste>  dpiponi annotated "Super simple minimax" with "minimax w/o fold" at http://hpaste.org/1094#a2
18:10:15 <dpiponi> chessguy: no, i do have it.
18:10:26 <dpiponi> chessguy: it's trivial as you can see
18:12:03 <chessguy> dpiponi:  hmm. i'll have to kick this around in my head for a while
18:12:28 <chessguy> i think i understand what you're after, and it should be possible
18:13:18 * chessguy goes to grab a notebook and scribble
18:13:19 <dpiponi> chessguy: Remember, this might not be going anywhere, so don't waste too much time thinking :-)
18:14:31 <Daveman> chessguy is the man :)
18:14:49 <chessguy> dpiponi: it's worth trying though
18:22:04 <chessguy> ?hoogle max
18:22:05 <lambdabot> Prelude.max :: Ord a => a -> a -> a
18:22:05 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
18:22:05 <lambdabot> Prelude.maxBound :: Bounded a => a
18:26:08 * QtPlatypus asks "Checking if a list is finite or infinite is equiverlent to the halting problem?"
18:26:45 <twanvl> yes
18:27:32 <twanvl> Simply make a list of all states in the execution of a program. The program halts iff the list is finite.
18:29:22 <dmwit> QtPlatypus: Just use (length xs) < (maxBound :: Integer) ;-)
18:29:58 <chessguy> dpiponi: i think i found the problem
18:30:08 <dpiponi> chessguy: Yeah?
18:30:31 <chessguy> dpiponi: well, you can't really use map as it is
18:30:32 <dmwit> On a more serious note, in many cases you can write down the conditions under which it is finite or infinite, if you have enough information about how the list was made.
18:30:36 <edwardk> currently using mapM and a state monad
18:30:41 <chessguy> because map says to do something to every item in the list
18:30:44 <edwardk> yep
18:30:46 <chessguy> regardless
18:30:54 <edwardk> that was the earlier issue raised
18:31:13 <chessguy> oh, i must have missed that
18:31:45 <edwardk> right now i'm just trying to get all the lifting right =)
18:32:05 <dpiponi> edwardk: Are you talking about using alpha and beta as the state?
18:32:15 <edwardk> currently, yeah
18:33:02 <edwardk> alphabeta :: (Ord a, Num a) => Tree a -> State (a,a) a
18:33:14 <edwardk> or something like that
18:33:31 <edwardk> swapping in a mapM for the map and lifting the foldr you have
18:33:33 <edwardk> over it
18:34:15 <edwardk> then i think you need to reverse alpha and beta in the state around the nested alphabeta call
18:34:32 <chessguy> dpiponi: what you really want is map' :: (a->b) -> (b->Bool) -> [a] -> b
18:34:40 <edwardk> @type mapM
18:34:42 <lambdabot>     Ambiguous occurrence `mapM'
18:34:43 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
18:34:48 <edwardk> @type Control.Monad.mapM
18:34:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:35:31 <edwardk> i will confess that (ab)using state in this way breaks the spirit of the exercise but it seems to yeidl something closest to the original
18:36:10 <dpiponi> edwardk: Yup, I've thought about using the state monad like this but I think it's close to what you might write in an imperative language and not what I'm after
18:36:15 <edwardk> and its reasonably pure categorically coz its just a monadic fold
18:36:29 <edwardk> well, i was trying to keep your existing style
18:36:35 <edwardk> but yeah
18:37:02 <chessguy> or maybe you want a fold that can cut out early
18:37:31 <dpiponi> edwardk: one idea I had was to represent scores by intervals. So (a,b) means the score for this node lies between a and b.
18:38:07 <dpiponi> edwardk: the algorithm would start by returning a rough approximation and as you traverse more nodes you'd get more accurate intervals
18:38:26 <dpiponi> The idea would be that you don't need to get an interval to a size of 1 before you start reject subtrees
18:38:52 <dpiponi> For example you know that (1,10) is less than (20,30) without having to chase along the tree to find exactly which value in (1,10) is meant.
18:41:50 <dpiponi> If such a scheme worked you could use it to encode all kinds of heuristics in the game tree. Like if you had a trick to quickly put an upper or lower bound on the value of a position without fully evaluating it.
18:43:51 <procyon_> whoa vista is flaky
18:44:28 <procyon_> I just tried to run the same program 3 times (that requies LUA elevation) and got 3 completely different startup behaviors.
18:44:30 <chessguy> dpiponi: by the way, i think i have a simpler minimax
18:44:48 <chessguy> (assuming a Data.Tree structure)
18:45:02 <procyon_> (program I wrote... my code=not THAT flaky)
18:45:12 <dpiponi> dpiponi: I'm surprised you can get simpler! But I gotta go now. I'll check in later...
18:45:23 * dpiponi talks to self again
18:45:29 <chessguy> minimax (Node pos []) = eval pos; minimax (Node pos kids) = max $ map (negate minimax) kids
18:46:01 <chessguy> i think that makes it clearer what's going on anyway
18:46:08 <dpiponi> negate minimax, but minimax is a function?
18:46:24 <chessguy> err, negate . minimax
18:46:31 <dpiponi> Anyway, gotta go...
18:46:33 <procyon_> 1) "Program stopped working error" 2) "Program is not a valid Win32 App" 3) Works fine.
18:47:52 <edwardk> gah he left
18:47:53 <dmwit> procyon_: Whee! Insanity feels *GOOD*!
18:48:11 <chessguy> edwardk: he's coming back later
18:48:17 <procyon_> dmwit: not even a recompile between runs.
18:48:26 <chessguy> you can paste your code as an annotation
18:48:32 <chessguy> he'll see it :)
18:48:33 <edwardk> ya
18:49:14 <procyon_> dmwit:  OK.. the hang, sure... the working, of course... but NOT A VALID APP?!?  WTF?
18:49:32 <dmwit> Dunno, lol!
18:50:26 <dmwit> Maybe they have an if (program = valid) instead of if (program == valid) statement. ;-)
18:51:32 <siti> is it possible to use parsec with bytestrings?
18:51:49 <procyon_> It's not like I'm not already pulling my hair out coverting this stupid VBS app into a C++ wizard.. I gotta put up with bugs in kernel's executable file layout parser?
18:51:57 <dmwit> siti: I think the consensus is "not yet."
18:52:49 <chessguy> @type max $ map (negate . ?minmax) ?kids
18:52:51 <lambdabot> forall b a. (Ord [b], Num b, ?minmax::a -> b, ?kids::[a]) => [b] -> [b]
18:53:08 <siti> dmwit: ok :(
18:53:30 <dmwit> I think there's a SoC proposal to do it, though.
18:53:35 <dmwit> ?where SoC
18:53:36 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
18:53:54 <dmwit> Okay, I decided what I want in a syntax highlighter.
18:54:07 <dmwit> I want it to highlight the variable names, not the keywords.
18:54:30 <dmwit> Do something clever to choose their color.  (Like use a hash on their name or something.)
18:54:38 <dmwit> Now, my question is:
18:54:38 <siti> ok
18:54:38 <jyasskin> Color by type. ;)
18:54:49 <procyon_> ooh... I like color by type.
18:54:58 <dmwit> what is the chance that I will be not lazy enough to try writing that?
18:54:58 <chessguy> @type map (negate . ?m) ?k
18:55:01 <lambdabot> forall b a. (Num b, ?m::a -> b, ?k::[a]) => [b]
18:55:17 <jyasskin> Ok, dmwit, integrate a Haskell type inferencer into Emacs. :)
18:55:44 <dmwit> jyasskin: Exactly. =P  (But... vim!)
18:56:01 <chessguy> @type maximum
18:56:02 <allbery_b> @where shim
18:56:03 <lambdabot> forall a. (Ord a) => [a] -> a
18:56:03 <lambdabot> http://shim.haskellco.de/trac/
18:56:05 <procyon_> Yi!
18:56:09 <procyon_> :D
18:56:28 <dmwit> !
18:56:28 <jyasskin> No, Yi would actually be tractable. ;)
18:56:47 <dmwit> bookmark'd
18:57:19 <jyasskin> dmwit: But, I do like your original idea. As long as names were colored consistently across many files, I think it'd help quite a bit.
18:57:23 <procyon_> yeah.. sending him on quests he can succeed at is no fun
18:57:49 <dmwit> jyasskin: Yeah, and a hash might actually extend to other languages.
18:57:59 <procyon_> Actually, a type inferencer in elisp wouldn't be all that tough.
18:58:07 <dmwit> I need more hours in my day!
18:58:08 <jyasskin> A hash would also catch small misspellings a lot better.
18:58:23 <siti> dmwit: don't sleep ;)
18:59:50 <procyon_> Well, if chessguy does well on his AI taskforcing we can just make a lambdabot plugin for tasks: @generate-code syntax highlighter
19:03:47 <dmwit> allbery_b: What are the two binaries that shim creates?
19:05:10 <allbery_b> I'm not actually sure
19:05:33 <allbery_b> I know shim exists; I haven't had much luck with it (the elisp doesn't like my xemacs very much; lile too many things, it's fsfemacs-specific)
19:06:07 <dmwit> Hum.
19:06:32 <allbery_b> shim is the actual binary, which uses ghclib to do the heavy lifting.
19:06:50 <allbery_b> I *think* shim-udproxy is run by emacs to talk to it.  don't quote me on that, though
19:06:52 <dmwit> Well, I'll probably check it out eventually, but it means I'd have to do all my own vimscripting...
19:07:05 <allbery_b> someone has supposedly alredy done some work to mak it talk to vim
19:07:36 <glguy_> what was the url for the lambdabot web interface?
19:07:56 <dmwit> ?where lambdabot
19:07:56 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:08:09 <dmwit> Nope, not it. =P
19:08:17 <chessguy> http://lambdabot.codersbase.com/
19:08:18 <lambdabot> Title: Lambdabot Web Interface
19:08:25 <glguy_> chessguy: thanks
19:08:34 <allbery_b> bleh.  I had codersbase but not the prefix :>
19:08:39 <allbery_b> shoulda been obvious...
19:08:56 <ddarius> http://obvious.codersbase.com/
19:08:57 <lambdabot> Title: animaforge.net
19:09:12 <jcreigh> does exec() change the PID?
19:09:52 <allbery_b> whose exec?
19:10:02 <jcreigh> UNIX. (Linux specifically)
19:10:06 <allbery_b> no
19:10:42 <allbery_b> exec replaces the current process's memeory image with a new one.  the process itself remains the same (modulo suid/sgid bits)
19:19:52 <Cale> How was lambdabot's web interface written?
19:20:00 <Cale> (and who wrote it?)
19:20:06 <dons> lispy, fastcgi
19:20:10 <dons> reverse.
19:20:11 <lambdabot> Clever machine learning algorithms.
19:20:25 <Cale> cool
19:20:43 <Cale> Does he intend to reddit it?
19:21:52 <dons> oh he. not sure.
19:21:59 <dons> we never actually announced it for some reason
19:27:48 <araujo> hello!
19:28:47 <chessguy> araujo!
19:28:53 <jcreigh> mmm, darcs is kinda nice
19:29:06 <araujo> chessguy!!!!
19:29:12 <araujo> how you doing?
19:29:23 <chessguy> excelente!
19:29:23 <araujo> jcreigh, yeah!
19:29:28 <araujo> hah
19:29:30 <araujo> nice
19:29:47 <chessguy> ?hoogle fold'
19:29:47 <lambdabot> No matches found
19:32:11 <chessguy> @type (>=)
19:32:13 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:34:17 <chessguy> @pl f = \a b (p:ps) -> if (p >= b) then b else f p b ps
19:34:18 <lambdabot> f = fix (const . flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . ((.) .) . (flip =<< (if' .) . flip (>=))) . flip)
19:34:23 <chessguy> whee
19:34:47 <hoopy> that makes no sense to me
19:34:51 * hoopy has much to learn
19:35:03 <chessguy> @pl f a b [] = a; f a b (p:ps) -> if (p >= b) then b else f p b ps
19:35:04 <lambdabot> (line 1, column 10):
19:35:04 <lambdabot> unexpected "="
19:35:04 <lambdabot> expecting variable, "(", operator or end of input
19:35:15 <Gnezdo> I'm trying to adapt somebody elses code to run on 6.6. The code goes something like this:   where (arr1::monomorphic) = ...
19:35:27 <Gnezdo> 6.6 complains     Not in scope: type variable `monomorphic'
19:35:34 <Gnezdo> 6.4.2. doesn't object
19:35:36 <hoopy> is there a GHC for intel macs yet?
19:35:42 <hoopy> i suppose i could google...
19:35:56 <chessguy> ?where ghc
19:35:56 <lambdabot> http://haskell.org/ghc
19:35:59 <Gnezdo> anybody has a link for what such type declarations actually mean?
19:37:02 <sorear> hello.
19:37:22 <sorear> Gnezdo: the rules for scoped tvs are different in 6.6 and 6.4.2
19:37:26 <sorear> @where manual
19:37:26 <lambdabot> http://haskell.org/ghc/dist/current/docs/users_guide/
19:37:41 <sorear> ^^^ somewhere in the type system extensions section
19:37:48 <chessguy> hmmm. how can i abstract out the notion of quitting a fold early?
19:37:55 <sorear> chessguy: laziness
19:38:00 <Gnezdo> sorear: reading, thanks
19:38:05 <sorear> chessguy: foldr always quits early
19:38:13 <jcreigh> why does cabal barf when you try to install over a running executable? (eg, xmonad)
19:38:32 <procyon_> @pl s x y z = x z (y z)
19:38:33 <lambdabot> s = ap
19:38:34 <balodja> hi, everybody. would you advise any docs about 'parsec'?
19:38:37 <chessguy> sorear: but i need to be able to only quit eaqrly some of the time
19:38:38 <procyon_> heh
19:38:40 <sorear> dmwit: shim-udproxy is a hack used because emacs only speaks UDP, while shim proper is Unix-domain only
19:38:46 <chessguy> depending on some condition
19:38:51 <chessguy> condition(s)
19:38:59 <sorear> jcreigh: probably, you're using a *NIX system?
19:39:09 <dmwit> sorear: Ah, thanks.
19:39:09 <sorear> jcreigh: and I'm guessing the error is ETXTBSY?
19:39:20 <chessguy> sorear:  f a b [] = a; f a b (p:ps) -> if (p >= b) then b else f p b ps
19:39:23 <procyon_> ?src ap
19:39:23 <lambdabot> ap = liftM2 id
19:39:24 <dmwit> jcreigh: You can delete the executable, then install.
19:39:30 <sorear> jcreigh: Unix systems don't allow writing to running text files
19:39:30 <jcreigh> *** Exception: /home/jason/bin/xmonad: copyFile: resource busy (Text file busy)
19:39:38 <jcreigh> so yeah, I guess ETXTBSY
19:39:40 <chessguy> err, that -> should be an =
19:39:50 <jcreigh> dmwit: I know how to workaround it. I'm just lazy. :)
19:40:26 <beelsebob> anyone fancy staring at an annoying LaTeX problem?
19:40:46 <chessguy> sorear: does that make any sense?
19:40:48 <beelsebob> specifically - anyone see a good way of making Definition 3 on the right of http://www.cs.kent.ac.uk/people/rpg/tatd2/um.png do something nice?
19:41:17 <sorear> jcreigh: UNIX systems use 'mmap' to load text files, which loads things lazily
19:41:37 <sorear> jcreigh: this would make a big mess if the text file was changed, so the latter is disallowed
19:41:44 <jcreigh> ah
19:41:55 <sorear> jcreigh: and in case you wonder, text is an archaic synonym for binary machine code
19:42:06 <sorear> jcreigh: don't ask me where that came from :)
19:42:13 <procyon_> ?src LiftM2
19:42:14 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:42:19 <sorear> ?src liftM2
19:42:20 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:42:20 <procyon_> ?src liftM2
19:42:20 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:42:47 <chessguy> ergh, that code doesn't even make sense. sigh
19:42:54 <chessguy> @type foldr
19:42:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:43:28 <procyon_> @type liftM2
19:43:30 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:43:40 <alexj> @seen glguy
19:43:40 <lambdabot> glguy is in #happs and #haskell. I last heard glguy speak 5h 52m 20s ago.
19:43:45 <procyon_> @type liftM2 id
19:43:47 <jcreigh> so I guess unlinking a running executable doesn't actually remove the file, since it's still being held open...
19:43:48 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
19:43:48 <chessguy> @src foldl
19:43:48 <lambdabot> foldl f z xs = lgo z xs
19:43:48 <lambdabot>     where lgo z []     =  z
19:43:48 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
19:43:53 <chessguy> @src foldlr
19:43:53 <lambdabot> Source not found. Where did you learn to type?
19:43:56 <chessguy> @src foldr
19:43:56 <lambdabot> foldr k z xs = go xs
19:43:56 <lambdabot>     where go []     = z
19:43:56 <lambdabot>           go (y:ys) = y `k` go ys
19:45:40 <sorear> jcreigh: exactly.  and when you copy you create a different file that happens to have the same name.
19:48:28 <procyon_> > ap const const 15
19:48:29 <lambdabot>  15
19:49:14 <edwardk> hrmm
19:49:55 <edwardk> i need a concise and fast way to say 'the first item in a list that satisfies a predicate, or the last one if nothing does'
19:50:27 <sorear> find is soo close
19:50:33 <edwardk> trying to avoid doublescanning
19:50:33 <edwardk> yeah
19:51:17 <sorear> and if there are no elements at all?
19:51:29 <beelsebob> foldr1 (\x y -> if p x then x else y)
19:51:32 <edwardk> i have a beta value i can stuff in
19:51:32 <beelsebob> or no?
19:51:35 <procyon_> @type ((ap(const((ap(const ap))const)))((ap(const ap))const))
19:51:37 <lambdabot> forall b a b1 b2. (a -> b1) -> (b -> b2 -> a) -> b -> b2 -> b1
19:51:58 <procyon_> bitchen
19:52:06 <beelsebob> edwardk: does that do the job?
19:52:10 <edwardk> hrmm
19:52:19 <edwardk> @type  foldr1 (\x y -> if p x then x else y)
19:52:21 <lambdabot> Not in scope: `p'
19:52:24 <edwardk> er
19:52:30 <sorear> @type  foldr1 (\x y -> if ?p x then x else y)
19:52:32 <lambdabot> forall a. (?p::a -> Bool) => [a] -> a
19:52:41 <edwardk> @type  foldr1 (\x y -> if x > 5 then x else y)
19:52:43 <lambdabot> forall a. (Num a, Ord a) => [a] -> a
19:52:54 <Pseudonym> @type \p -> foldr1 (\x y -> if p x then x else y)
19:52:56 <lambdabot> forall a. (a -> Bool) -> [a] -> a
19:53:14 <Pseudonym> ?free f :: (a -> Bool) -> [a] -> a
19:53:14 <lambdabot> g . f (h . g) = f h . $map g
19:53:27 <chessguy> @pl f _ [] = error "bah"; f _ [a] = a; f _ (x:xs) = if (p x) then x else f p xs
19:53:28 <lambdabot> (line 1, column 3):
19:53:28 <lambdabot> unexpected "_"
19:53:28 <lambdabot> expecting variable, "(", operator or end of input
19:53:29 <beelsebob> > foldr1 (\x y -> if x > 5 then x else y) [1,2,3,4]
19:53:31 <lambdabot>  4
19:53:38 <beelsebob> > foldr1 (\x y -> if x > 5 then x else y) [1,2,3,4,5,6]
19:53:39 <lambdabot>  6
19:53:42 <beelsebob> damn
19:53:43 <sorear> @unpl ((ap(const((ap(const ap))const)))((ap(const ap))const))
19:53:43 <lambdabot> ((\ h i j -> i >>= \ g -> j >>= \ h -> return (h g h)) (\ k -> k) (\ _ -> (\ _ u v -> u >>= \ s -> v >>= \ r -> return (s r)) >>= \ m -> (\ c _ -> c) >>= \ l -> return (m l)) ((\ _ ag ah -> ag >>= \
19:53:43 <beelsebob> not right
19:53:43 <lambdabot> ae -> ah >>= \ ad -> return (ae ad)) >>= \ y -> (\ e _ -> e) >>= \ x -> return (y x)))
19:53:48 <beelsebob> oh no
19:53:52 <beelsebob> > foldr1 (\x y -> if x > 5 then x else y) [1,2,3,4,5,6,7]
19:53:53 <lambdabot>  6
19:53:55 <beelsebob> yeh
19:53:56 <beelsebob> that works
19:54:20 <edwardk> hrmm
19:54:31 <procyon_> sorear: um... k
19:54:42 <edwardk> now to fold in the previous max step =)
19:54:44 <sorear> procyon_: what way it?
19:54:48 <sorear> s/way/was/
19:55:15 * ekidd is scared by @pl
19:55:19 <procyon_> sorear: B1 combinator in terms of ap and const
19:55:48 * sorear is scared by @pl's implementation
19:55:58 <procyon_> sorear: b1 = b b b
19:56:01 <ddarius>  @pl is simply a compiler.
19:56:04 <sorear> you should see it sometime.  Positively nubby.
19:56:35 <sorear> ddarius: A highly optimizing compiler...
19:56:54 <sorear> ddarius: with one of the least efficient optimizers around
19:57:10 <procyon_> where b = ap (const ap) const
19:57:16 <ekidd> ddarius: Thanks for your help with adjoint functors the other day!
19:57:27 <Pseudonym> > foldr1 (\x y -> if x > 5 then x else y) [1..]
19:57:28 <lambdabot>  6
19:57:32 <sorear> It's also buggy.
19:57:38 <sorear> @pl \foo -> let a = 2 in a
19:57:39 <lambdabot> const 2
19:57:42 <sorear> @pl \fix -> let a = 2 in a
19:57:42 <lambdabot> ($ const 2)
19:57:49 <sorear> name capture!
19:58:07 <beelsebob> Pseudonym: hmm, didn't think about that case - guess it's lucky it works :P
19:58:46 <Pseudonym> Yeah.  I figured it did, but I thought I should check.
19:59:07 <edwardk> hah beelse: i just realized that when i take yours and adapt it i get exactly the code i had... hahaha
19:59:08 <ekidd> I'm beginning to notice more and more CS papers where (a) the initial results were obviously developed using category theory but (b) the final published paper makes at most a sentence long mention of the form, "This can also be proven concisely using natural transformations."
19:59:10 <stepcut> @unpl (.) . (.) . (.) . (.)
19:59:10 <lambdabot> (\ o b c f i l -> o (b c f i l))
19:59:11 <ddarius> ekidd: Your @tell about adjoints and arrows and functors was not correct, at least not in an immediately obvious/sensible way.
19:59:14 <Pseudonym> I guess I don't have to use head-of-list-comprehension so much now.
19:59:20 <beelsebob> edwardk: rofl
19:59:25 <ekidd> ddarius: I suspected as much.
20:00:01 <beelsebob> damn it
20:00:08 <beelsebob> why dosn't LaTeX ever do what you want it to
20:00:20 <sorear> because it's LaTeX, duh
20:00:22 <beelsebob> hehe
20:00:34 <ekidd> ddarius: I was an interesting artifact of a couple of the examples I was looking at, where there was some odd--but interesting--stuff going on.
20:00:35 <beelsebob> I was *sooo* much happier working with InDesign
20:00:48 <ddarius> The (parameterized) representability view of adjunctions has them being an isomorphism between Hom functors.
20:00:55 <stepcut> beelsebob: :p
20:00:56 <beelsebob> but it's too slow to work with for paper submission
20:01:14 <ekidd> ddarius: Yeah, the Hom functor isomorphism makes the most sense to me at the moment.
20:01:14 <sioraiocht> beelsebob: What issue are you having in LaTeX
20:01:16 <sorear> yhc papery stuff?
20:01:36 <beelsebob> sioraiocht: http://www.cs.kent.ac.uk/people/rpg/tatd2/um.png
20:01:42 <beelsebob> look at definition 3
20:01:48 <beelsebob> can't make it do something useful with it
20:02:06 <sorear> subpixel!
20:02:08 <sioraiocht> beelsebob: you work for the university of kent?
20:02:22 <beelsebob> sioraiocht: I'm doing my PhD there, why?
20:02:32 <beelsebob> sorear: subpixel?
20:02:32 <sioraiocht> beelsebob: were you at ICER last year?
20:02:50 <sioraiocht> beelsebob: I can't see the problem, it looks like Definition 2...
20:03:00 <beelsebob> sioraiocht: nope, fraid not
20:03:08 <beelsebob> sioraiocht: the overflow to the right of the column
20:03:21 <sorear> RGBRGBRGBRGBRGBRGBRGBRGBRGBRGBRGBRGBRGBRGBRGBRGBRGB
20:03:22 <sioraiocht> ah!
20:03:26 <beelsebob> particularly problematic if it ends up in the left hand column
20:03:44 <ddarius> ekidd: The various different views help, but in my opinion, representability based approaches are easier to understand and work with.
20:03:45 <sioraiocht> that is a common issue.  not gonna like, i usually insert explicit line breaks in that cast
20:03:48 <sioraiocht> *case*
20:04:05 <ddarius> work with = (semi-)formally (possibly mechanically) manipulate
20:04:06 <beelsebob> sioraiocht: yeh, it's then a problem of actually getting it to line up nicely
20:04:26 <beelsebob> because it's already set up to align nicely on the = sign
20:04:32 <edwardk> @pl \x y -> if x <= alpha then x else min x y
20:04:32 <lambdabot> liftM2 (.) (if' =<< (<= alpha)) min
20:04:34 <ekidd> ddarius: I'm currently redrawing the diagrams from Pierce to get the important bits lined up in way that makes intuitive sense.
20:04:36 <edwardk> ugh
20:04:42 <beelsebob> edwardk: I agree
20:04:45 <chessguy> edwardk: are you making any progress?
20:04:50 <edwardk> chess yeah got it
20:04:56 <edwardk> just finished up now
20:04:58 <chessguy> paste?
20:04:58 <edwardk> cleaning the code
20:05:13 <sioraiocht> beelsebob: i only ask b/c my boyfriend was accepted at kent for the coming year for his PhD in CS, wasn't sure if you were in teh CSE research group there or not
20:05:14 <ekidd> ddarius: Most of the examples of adjoints that I've worked through are starting to feel pretty obvious.
20:05:41 <beelsebob> sioraiocht: I'm in the TCS (Theoretical Comp Sci) and FP groups
20:05:41 <sioraiocht> beelsebob: as for your LaTeX issue...I got nothing. I'm usually pretty good, but I dont do a lot of two column stuff with equations
20:06:14 <ddarius> ekidd: Depending on what area of math you are looking at they are (albeit some of that may simply be familiarity).
20:06:15 <hpaste>  edwardk annotated "Super simple minimax" with "alphabeta" at http://hpaste.org/1094#a3
20:06:22 <beelsebob> sioraiocht: for the most part I try to avoid the BlueJ people as much as I can
20:06:26 <edwardk> might still have bugs
20:06:27 <beelsebob> otherwise I end up teaching freshers java
20:06:28 <edwardk> but the idea is right
20:06:30 <edwardk> i think
20:06:46 <ddarius> ekidd: However, one sweet thing about CT, is how often something profound comes out of examining the adjoints to relatively trivial seeming functors.
20:06:51 <edwardk> and it is structurally identical to his minimax
20:06:52 <ekidd> I'm also beginning to feel that the popular category-theory texts are suboptimal for people with strong functional programming backgrounds but weak mathematical training.
20:07:01 <sioraiocht> beelsebob: ha! my b/f is actually proposing to create an IDE a la BlueJ for haskell =)
20:07:13 <ddarius> ekidd: A lot of them are not particularly good for that audience.
20:07:18 <beelsebob> sioraiocht: yerch!
20:07:19 <sioraiocht> Simon Thompson will be his supervisor...if he get the funding he needs to go
20:07:19 <edwardk> try: alphabeta 0 10 game
20:07:20 <ekidd> ddarius: Oh, I'm absolutely convince that adjoints are important.
20:07:36 <beelsebob> sioraiocht: actually could be useful
20:07:54 <beelsebob> we currently teach Haskell with a craptacular IDE that some 3rd years built as their final year project
20:08:04 <sioraiocht> beelsebob: the research backing up the dev should make it a good syste
20:08:10 <beelsebob> yeh
20:08:17 <ekidd> I've already noticed one very cool paper that is clearly about a pair of adjoint functors, though the authors don't present it that way (though some of their notation suggests that's how they conceive of the theory themselves).
20:08:27 <sioraiocht> it wasn't actually his idea, Sally Fincher wanted someone to do it because she can get a grant from...
20:08:28 <ddarius> ekidd: Which?
20:08:31 <beelsebob> I would guess 90% of research for that would be how to get the type checker to do something useful
20:08:35 <sioraiocht> Whatever your version of the NSF his..
20:08:35 <chessguy> edwardk:  i get a 3
20:08:45 <sioraiocht> EPSRC?
20:08:46 <beelsebob> like not tell them "this sploded with this and you don't understand the letters and the arrows so this means nothing"
20:08:56 <edwardk> wasn't that what the minimax on the game returned?
20:09:04 <chessguy> oh i don't know
20:09:24 <sioraiocht> beelsebob: aye, ghc in particular can be very difficut for students to master in terms of debugging
20:09:38 <edwardk> should probably run a quickcheck or something
20:09:39 <beelsebob> sioraiocht: yeh, I'm not sure if trying to get the PhD with Simon is the best plan for that -- him being head of department makes it awkward for him to get funding without looking biased
20:09:56 <edwardk> i had _just_ become comfortable with the solution when you asked =)
20:10:02 <beelsebob> sioraiocht: well, luckily in terms of debugging, the hat project is 90% based in Kent now
20:10:06 <sioraiocht> beelsebob: That's probably why Sally is going for it, I'm not really sure.
20:10:11 <ekidd> ddarius: "Combinators for Bi-Directional Tree Transformations:  A Linguistic Approach to the View Update Problem"
20:10:21 <chessguy> edwardk: his real goal was to eliminate alpha and beta though
20:10:43 <sioraiocht> beelsebob: that's very cool, I find the UK seems ot emphasise functional programming a lot more than the US curricula
20:10:49 <ekidd> ddarius: I may be completely deluded, but I think there's an some interesting adjoint stuff going on there.
20:10:50 <edwardk> i thought his real goal was to get the same general form of structural recursion with foldr
20:11:00 <beelsebob> sioraiocht: I hope not -- the course here has one module on it
20:11:02 <beelsebob> which sucks
20:11:21 <beelsebob> it's put as "this is a weird and wonderful thing you'll never use" rather than "lets study SICP as the first thing we do"
20:11:24 <ekidd> ddarius: I haven't proved it yet, though--just going by the "flavor" of the functor pair.
20:11:31 <edwardk> alphabeta has to carry along those two pieces of information or its not alphabeta =)
20:11:51 <sioraiocht> beelsebob: genearlly you find the same or less in the US.  We have two classes because one of th e professors teaches a colloquia in advanced haskell usage because she wnats to learn more about it ;)
20:12:12 <chessguy> edwardk: well, he wants to improve alphabeta, by abstracting that out
20:12:18 <chessguy> somehow :)
20:12:37 <chessguy> at least, that's my understanding
20:12:48 <beelsebob> sioraiocht: I guess actually we actually have 1.5 courses on it -- the guys teaching the compilers module are all functional programers
20:12:48 <edwardk> i walked away with a different understanding i guess
20:12:58 <ekidd> ddarius: I'll let you know whether my hunch is right as soon as I have time to work through the math. But even so, it's a very interesting paper.
20:13:02 <ddarius> ekidd: Are you familiar/comfortable with the notation used for typing judgements/natural semantics/and or sequents?
20:13:12 <beelsebob> so they sit there going "look, you could do it in Java as we've been told to do --- 4 files", or you could do it in Haskell -- 3 lines
20:13:17 <ekidd> ddarius: Tolerably.
20:14:12 <sioraiocht> beelsebob: I think it's hard to teach a lot of the more advanced concepts to undergrads re: functional programming
20:14:51 <beelsebob> sioraiocht: the problem is that they don't need to teach the advanced concepts -- they need to present it as a high powered, fully featured programming environment
20:14:59 <beelsebob> rather than something where you can do a few sums
20:14:59 <stepcut> it's hard to teach a lot of simple concepts to undergrads re: don't pass out at a frat party
20:15:01 <ddarius> ekidd: If I'm not misremembering, there is a chapter in Neil Ghani's PhD thesis that, if you haven't already realized it, will make a light pop on for you.
20:15:19 <edwardk> i was personally amused that I could get the exact same superstructure though
20:15:29 <sioraiocht> beelsebob: yeah, but I find MOST undergrads like OOH SHINY LANGUAGES
20:15:41 <chessguy> edwardk: by the way, minimax does give a 3 too
20:15:52 <chessguy> (his original minimax, that is)
20:16:00 <beelsebob> sioraiocht: this is true, it's a shame that they don't ever realise just how shiny FP is
20:16:02 <edwardk> yeah thought so =)
20:16:13 <edwardk> otherwise i would have a bug =)
20:16:24 <chessguy> well we can't have that :)
20:16:29 <edwardk> heh
20:16:30 <beelsebob> I was tought it as a 3rd year course, by which point a lot of the mathematical concepts were natuaral - so it all worked nicely
20:16:49 <edwardk> if you just hand check that is the min of the max's
20:16:51 <chessguy> anyway, i think this notion of being able to "quit early" is important
20:17:00 <edwardk> yeah
20:17:02 <ekidd> ddarius: For a better-known example of lurking category theory, see Wadler's "Theorems for free!" paper, which is basically a proof that polymorphic functions are natural transformations, with the usual commutativity properties. But the category theory is relegated to a single sentence.
20:17:16 <edwardk> currently it 'quits early' by ignoring its second argument for the remainder of the fold
20:17:29 <sioraiocht> beelsebob: I got it my 2nd semester of uni.  I wasn't ready for a lot of the concepts.  I'm taking a more advanced course in it now, and I appreciate haskell much much more...i
20:17:34 <chessguy> i'm not sure how it can be abstracted out though
20:17:53 <edwardk> i would otherwise have to inject a filter into the fold i think
20:18:09 <edwardk> that would be 'more correct' because then it could avoid even processing the count of the boards down that path
20:18:11 <chessguy> wait, what second argument?
20:18:20 <edwardk> in the prune
20:18:31 <edwardk> er might have that backwards, see told you i had bugs =)
20:18:57 <chessguy> AB gives me a headache
20:20:21 <edwardk> ok, there was a bug but it was not causing a problem in my tests
20:20:57 <hpaste>  edwardk annotated "Super simple minimax" with "alphabeta bugfix" at http://hpaste.org/1094#a4
20:24:20 <chessguy> so....have we accomplished anything with all this?
20:25:21 <edwardk> yeah, i have an alphabeta that fits his minimax's structure implemented in the same terms as his minimax. if you look at his minimax its just the same as my alphabeta with a hardcoded limit and without the special case on the min used in the fold
20:26:18 <edwardk> hence why when i bugfixed it i renamed that to min'
20:28:46 <chessguy> @pl \f x y -> f (negate y) (negate x)
20:28:46 <lambdabot> (. negate) . flip . (. negate)
20:29:01 <edwardk> i suppose you could argue that maybe it should foldl
20:29:13 <chessguy> @pl \f x y -> f (-y) (-x)
20:29:14 <lambdabot> (. subtract) . flip . (. subtract)
20:29:20 <edwardk> just to avoid calculating the length of the list
20:29:41 <Daveman> wow, still at it chessguy? :)
20:29:56 <chessguy> Daveman: edwardk's doing the real work :)
20:30:01 <edwardk> heh
20:30:22 <edwardk> right now it works and is clean, just isn't necessarily as fast as i might want
20:30:22 <chessguy> i'm just wishing i knew what i was talking about
20:30:54 <Daveman> heehee :)
20:31:00 <Daveman> sounds interesting
20:32:41 <edwardk> i think if i crack open the foldr and flip it around into a scanl, then i can muck around in its insides so it'll handle cases with infinite trees
20:32:50 <edwardk> right now its not entirely codata safe, because it foldrs
20:33:33 <chessguy> edwardk: what about the modifications we were talking about earlier?
20:33:38 <chessguy> mtd(f), etc.
20:34:03 <edwardk> well, MTD(f) just uses a base alphabeta function and tweaks the alpha and beta parameters
20:34:13 <edwardk> iterative deepening just plays with the max depth
20:34:20 <edwardk> both of those are orthogonal to this implementation
20:34:32 <chessguy> and the original, really
20:34:32 <edwardk> iterative deepening would affect the game construction before it reaches here
20:35:00 <edwardk> MTD(f) tweaks the alpha beta values and binary searches for the right value setting alpha=beta
20:35:18 <edwardk> or beta = alpha + 1 depending on how its implemented
20:35:19 <chessguy> i'm not sure how much sense iterative deepening even makes in the presence of laziness
20:35:39 <edwardk> well, you don't evaluate intermediate boards even while lazy
20:35:46 <edwardk> so iterative deepening is just as valuable here
20:36:07 <edwardk> i.e. i don't evaluate the value of a board 1 move away to get a better guesstimate of future board values with just laziness
20:36:15 <edwardk> ID still plays a role
20:36:36 <edwardk> also there is no memoization here, but that could be plugged in, probably monadically
20:36:37 <chessguy> but i mean, we could "evaluate" the "whole tree", but really only take the values to the depth that we want
20:37:09 <edwardk> true, but there you'd have to change his game tree representation, right now his scoring function is baked into it. you can't evaluate intermediate levels
20:37:24 <edwardk> ID is just the ability to evaluate at progressively broader horizons.
20:37:30 <chessguy> right
20:37:46 <chessguy> oh yes, you'd want to change his tree structure to do really do any of this
20:38:41 <chessguy> besides which, using Data.Tree gives you unfoldTree, which is just too pretty not to use :)
20:39:11 <fantasma> what's a simple font viewer I can use from the console?
20:39:40 <ddarius> ekidd: Okay, I don't think what I was thinking of is in Ghani's thesis.  It might be.  I'm having a hard time finding it.
20:39:41 <edwardk> heh
20:39:59 * ddarius should recompile his full-text database program.
20:41:20 <ekidd> ddarius: Well, if you run into it, please feel free to @tell me.
20:48:02 <chessguy> edwardk: well, thanks for the fun brain-melting session. it's time for bed here
20:48:35 <desp> ?seen bos
20:48:36 <lambdabot> bos is in #haskell-overflow and #haskell. I last heard bos speak 56m 5s ago.
20:48:44 <desp> aha!
20:48:54 <dolio> edwardk: I'm a bit sleep addled, but doesn't "min' x y = if x <= a then y else min x y" provide the same results, but quit early even on infinite lists?
20:49:03 <hpaste>  edwardk annotated "Super simple minimax" with "hideous but codata friendlier" at http://hpaste.org/1094#a5
20:49:08 <dolio> Er, "then x"
20:50:15 <icarroll> I'm having trouble getting opengl to work on an intel mac. Can anyone lend a hand?
20:50:33 <edwardk> dolio: my current thought pattern and it may be utterly fried is that you keep folding because it doesn't recognize its at a fixed point and can't start tearing down the list coz its a foldr and starts at the end
20:50:52 <edwardk> so you never get to the end of the list to hit your base case
20:51:08 <dolio> Well...
20:51:56 <dolio> > foldr (||) False $ [False, True] ++ repeat False
20:51:58 <lambdabot>  True
20:52:21 <edwardk> the foldl version is a bit better but it has to still know the length of the list because for a list of n items, it'll compute the inner comparison of its current value against the alpha cutoff and return itself that many times, no?
20:52:25 <dolio> If you use the min' above, and it sees an x that it can quit on, it will, pruning the tail of the list.
20:52:32 <edwardk> hrmm
20:52:34 <dolio> I think.
20:52:39 <edwardk> maybe you're right
20:52:44 <edwardk> i'm probably overthinking, huh?
20:53:23 <dolio> I'm not totally sure it will work, either. About 5 minutes ago I thought I saw a reason it wouldn't. :)
20:53:26 <edwardk> so if we go back to my version from 42 minutes ago, i'm done?
20:53:39 <bos> desp: you called?
20:53:40 <edwardk> =)
20:53:58 <Cale> edwardk: what's the question?
20:54:42 <edwardk> cale: playing with a foldr alphabeta trying to get it to terminate right in the presence of codata move lists in some cases basically
20:55:06 <edwardk> http://hpaste.org/1094
20:55:48 <edwardk> basically copied the minimax structure that dpiponi posted
20:55:57 <Cale> hmm, okay
20:56:03 <edwardk> and started doing alphabeta in the same context
20:56:21 <Cale> You might need to replace min with something smarter.
20:56:48 <edwardk> thats what the prune or min' is we're talking about
20:57:10 <edwardk> depending on the version you look at
20:57:11 <desp> bos: hello
20:57:23 <desp> bos: I sent you a couple of messages a while ago, did you get them?
20:57:30 <edwardk> min' x y = if x <= a then y else min x y     was dolio's version
20:57:41 <Cale> I think min' a x y = if x <= a then x else min x y
20:57:43 <edwardk> and its basically the only one i didn't post up =)
20:57:48 <dolio> > let prune x y = if x <= 1 then x else min x y in foldr prune 100 $ [2, 3, 4, 1, 0] ++ repeat 5
20:57:49 <lambdabot>  1
20:58:20 <bos> desp: no, irc is not a good way to catch me if i'm idling.
20:58:21 <edwardk> a is in scope from the alphabeta doesn't need to be carted along
20:58:41 <edwardk> dolio wins =)
20:58:49 <bos> i tend to ssh in and kill my client so i can run it elsewhere.
20:58:57 <bos> desp: email is best
20:59:01 <desp> bos: okay. can I get your email?
20:59:07 <bos> bos@serpentine.com
21:00:32 <hpaste>  edwardk annotated "Super simple minimax" with "cleaned up and apparently sufficient (thanks dolio)" at http://hpaste.org/1094#a6
21:00:38 <dolio> :) At least you don't need scanl.
21:00:44 <edwardk> yeah that was horrid
21:00:49 <vincenz> mhmm
21:00:55 <edwardk> i admit totally to being off track there
21:00:58 <desp> bos: I see that nominolo is also interested in the project, but he says he's going to work with a partner?
21:01:03 <edwardk> but my brain kept trying to crack the problem open that way
21:01:22 <edwardk> > let prune x y = if x <= 1 then x else min x y in foldr prune 100 $ [2, 3, 4, 1, 0] ++ repeat -1
21:01:23 <lambdabot>  Couldn't match expected type `[t]' against inferred type `a -> [a]'
21:01:31 <edwardk> > let prune x y = if x <= 1 then x else min x y in foldr prune 100 $ [2, 3, 4, 1, 0] ++ repeat 0
21:01:33 <lambdabot>  1
21:01:36 <bos> desp: um, let me dig out the trac ticket.
21:01:38 <edwardk> ok, just checking =)
21:01:54 <desp> boc: http://hackage.haskell.org/trac/summer-of-code/ticket/1122
21:01:55 <lambdabot> Title: #1122 (HTTP Library Replacement) - Haskell.org Google Summer of Code - Trac
21:02:17 <dolio> That's pretty short.
21:02:32 <dolio> Certainly shorter than the version I wrote for my AI class a couple years ago. :)
21:02:32 <edwardk> i'm comfortable with that version
21:02:35 <edwardk> heh
21:03:20 <edwardk> i'm mostly happy with the fact that it precisely mimics his alphabeta and 'does the right thing'
21:03:28 <edwardk> er his minimax
21:04:14 <bos> desp: i'll have to talk with other mentroids about this. i don't know of any particular policy for handling multiple people interested in a project.
21:04:38 <dolio> Yeah, that seems like the minimal extension of his original.
21:04:44 <bos> ?seen nominolo
21:04:44 <lambdabot> nominolo is in #haskell. I last heard nominolo speak 6h 52m 55s ago.
21:04:56 <desp> bos: I think I need to hurry up with my application :)
21:05:10 <bos> desp: certainly, yes. if you're not in, you can't win :-)
21:05:13 <desp> bos: I've been working on a simple proof-of-concept interface
21:05:25 <bos> ok
21:05:32 <desp> so that I'd be able to contrast a simple get with the HTTP package's get
21:05:34 <desp> almost done
21:05:38 <bos> nice.
21:07:29 <edwardk> ever feel like you're trying to polish haskell code to get it to some sort of minimal-surface? it feels like you pull a kink out here polish something there fold spindle and mutilate it until it asymptotically approaches some idealized form
21:07:44 <edwardk> golfing haskell is always fun
21:08:51 <allbery_b> not really, as a production-style programmer I susually stop at "good enough"
21:08:58 <edwardk> heh
21:09:14 <edwardk> i do that in my work stuff, but I write haskell for fun
21:09:28 <allbery_b> I'm sure someone could reduce the functions in my current gtk2hs-based thing to 2 lines, but feh
21:09:36 <allbery_b> I do both for fun and for work
21:09:58 <allbery_b> but even the "for fun" generally has some intended use, and "good enough" is good enough :)
21:10:08 <edwardk> heh
21:11:29 <bos> i stop at the point in the curve where my ability to grok my code right now meets my probable inability to understand it tomorrow, or in a week.
21:11:37 <allbery_b> hm, actually I think most of my functions *are* 2 lines at this point.  with one majjor exception but it'll probably not be shrinking any --- too much to do
21:11:40 <edwardk> heh
21:12:10 <edwardk> ok, i'll confess there is a point at which @pl or something like that doesn't legibility
21:12:35 <allbery_b> honestly, that's true for everyone
21:12:41 <allbery_b> @pl is for golfing, mostly
21:12:41 <lambdabot> (line 1, column 15):
21:12:41 <lambdabot> unexpected ","
21:12:41 <lambdabot> expecting variable, "(", operator or end of input
21:12:44 <allbery_b> heh
21:12:56 <allbery_b> @quote flip-stream
21:12:56 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
21:13:00 <edwardk> but i do enjoy the process of distilling a function down to a concise representation of its essence
21:15:27 <mauke> @. pl undo evalObject o = do v <- lookupVar . objectName $ o; foldM (\z x -> liftM (getIndex z . number) (eval x)) v (objectIndices o)
21:15:27 <lambdabot> (line 1, column 21):
21:15:27 <lambdabot> unexpected "{"
21:15:27 <lambdabot> expecting variable, "(", operator or ")"
21:18:31 <sorear> I've written a 590 char theorem prover before
21:18:49 <sorear> actually, I understand the subject much better now
21:19:04 <sorear> I could probably get it below the magic 490 now
21:24:51 <jcreigh> why is 490 "magic"?
21:25:09 <sorear> irc cutoff
21:25:12 <sorear> for @run
21:25:16 <jcreigh> oh, haha
21:25:41 <sjanssen> speaking of magic, xmonad has exactly 400 lines right now
21:25:53 <sjanssen> lines of code, that is
21:26:11 <sorear> refactor!
21:26:16 <sjanssen> yep
21:26:19 <mauke> if you can fit it in 4x80, you can use it as a signature!
21:26:49 <jcreigh> what does dons's fudged LOC script count? (skips whitespace lines and comments, yes?)
21:27:05 <sjanssen> jcreigh: I believe so
21:27:40 <sjanssen> sloccount reports 402
21:27:43 <sjanssen> 401
21:28:19 <sjanssen> it also estimates xmonad's development is worth $10,350
21:28:28 <jcreigh> what?
21:28:30 <stepcut> sjanssen: :p
21:28:39 <jcreigh> where's my cut? :)
21:29:01 <jcreigh> seriously, how could it come up with something like that? It's meant as a joke, right?
21:29:20 <sorear> Most programs are worth 4 times less written in Haskell.
21:29:24 <sjanssen> I could go for $10,000 right about now
21:29:39 <jcreigh> Haskell lines should count as more, since you have to think about them more.
21:29:59 <Pseudonym> No you don't, you type them and let the compiler find all your bugs.
21:30:04 <dons> sjanssen: does that mean we're done?
21:30:13 <dons> no more features!
21:30:25 <dons> oh, can i resize windows vertically yet?  :-)
21:30:26 <sorear> dons: sure we can add more features
21:30:40 <dons> as long as we remove code first.
21:30:41 <sorear> dons: just because it's full now doesn't mean it can't be compacted
21:30:42 <jcreigh> sjanssen: oh, BTW, "darcs send" works like a charm for xmonad now. Thanks
21:31:30 <dons> my xmonad has been running for 3 days now, and after the first hour or so, memory drops down to 1644K
21:31:33 <dons> which is very nice.
21:31:43 <dons> that's only 100k or so bigger than dwm, iirc
21:32:07 * sorear jokes about running xmonad in yhi
21:32:31 <sjanssen> sorear: that might be feasible
21:32:47 <edwardk> heh i'm somewhat afraid to try to measure the amount of lines in the random detritus that litter my machines from dead projects . the estimated cost terrifies me
21:33:09 <sjanssen> we only use a handful of extensions.  MPTC (from mtl) and newtype deriving
21:33:24 <Pseudonym> Unfortunately, slocount measures data, not information.
21:33:26 <sorear> neither of which is supported :)
21:33:49 <sorear> and ndm won't go anywhere near the yhc typechecker
21:34:05 <sorear> unfixably crufty and all that
21:34:21 <sjanssen> sorear: I'm saying that you could easily replace those portions with H '98 stuff
21:34:47 <sjanssen> ndm hates the entire yhc frontend from what I've heard
21:34:51 <edwardk> pseudonym: yeah, i gleaned a lot of information from working on those projects, so i guess i can say i probably got most of my money's worth
21:35:05 <sorear> sjanssen: how big is xmonad's heap?
21:35:33 <sorear> I've a few ideas for ayhi ... maximal sharing and cdr coding etc ... but it won't help if Xlib dominates the ram usage
21:35:41 <sjanssen> sorear: I've never tracked it.  Pretty small, I think
21:35:50 <dcoutts> xcb! xcb! xcb!
21:35:59 * dcoutts goes back to chasing _|_'s
21:36:05 <sorear> dcoutts: you mean xhb, right? :)
21:36:14 <dcoutts> yeah
21:36:29 <sjanssen> all xmonad holds (on the Haskell side), are a few Maps and lists
21:36:43 <sjanssen> dcoutts: did you see my comments about xhb last night?
21:38:39 <sjanssen> it looks like a perfect opportunity to use Data.Binary
21:39:26 <dcoutts> sjanssen: oh yeah, briefly
21:39:43 <dcoutts> edwardk: ;-)
21:40:05 <dcoutts> SmallCheck++
21:40:06 <dcoutts> ChasingBottoms++
21:40:11 <dcoutts> @where ChasingBottoms
21:40:11 <lambdabot> I know nothing about chasingbottoms.
21:41:02 <dcoutts> @where+ ChasingBottoms http://www.cs.chalmers.se/~nad/software/
21:41:03 <lambdabot> Done.
21:41:09 <dcoutts> where SmallCheck
21:41:13 <dcoutts> @where SmallCheck
21:41:14 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
21:41:18 <dcoutts> good good
21:43:55 <jcreigh> HardToTrackDownFocusBugs--
21:45:22 <mauke> @quote focus
21:45:23 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
21:45:23 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
21:46:04 <jcreigh> what is cunning newtype deriving, and why is it "cunning"?
21:46:38 <sorear> a ghc extension
21:46:41 <sorear> @where manual
21:46:41 <lambdabot> http://haskell.org/ghc/dist/current/docs/users_guide/
21:46:54 * sorear checks for section number
21:47:03 <edwardk> lemme guess it can provide a deriving for all of the classes the base type is an instance of or something?
21:47:12 <jcreigh> 7.4.8?
21:47:24 <sorear> jcreigh: True
21:47:49 <jcreigh> oh, in H98 you can't do newtype deriving?
21:47:51 <jcreigh> *at all*?
21:48:04 <sorear> right
21:48:14 <jcreigh> well, that's lame. No wonder the GHC folks fixed it.
21:48:16 <sorear> you can do regular deriving on newtypes
21:48:18 <Cale> You can derive the ordinary things which are derivable.
21:48:25 <sorear> but that's nowhere near as powerful
21:48:42 <sorear> newtype Foo = Foo Bar deriving(Show) -- regular deriving
21:48:58 <sorear> newtype Foo = Foo Bar deriving(Bits) -- newtype deriving
21:49:20 <jcreigh> hmm, okay. but what is so cunning about it?
22:16:03 <largos> is there an easy way to map <- across an array?  (I have an array of IO String, and I need an array of string)
22:18:11 <narain> :t mapM
22:18:12 <bd_> largos: import qualified Data.Traversable as T; T.mapM id array ?
22:18:13 <lambdabot>     Ambiguous occurrence `mapM'
22:18:13 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
22:18:16 <ibid> largos: why do you have an array of IO?
22:18:21 <vincenz> could that be fixed?
22:18:28 <vincenz> the whole ambiguous of Control.Monad.Writer is rather annoying
22:19:26 <largos> ibid: I'm trying to read all the files specified on the command line into an array
22:19:34 <largos> well, here's the code:
22:19:39 <largos> files <- map lines $ map readFile args
22:20:19 <bd_> that doesn't typecheck, I don't think
22:20:21 <bd_> how about
22:20:24 * largos is looking at MapM
22:20:27 <largos> bd_: nope :(
22:20:34 <bd_> file <- mapM (liftM lines . readFile) args
22:20:43 <bd_> and that's a list not an array :)
22:20:46 <ibid> largos: i mean, it seems strange to construct an array of IO, it takes special work to do that and i don't see what good it would do
22:21:20 <largos> ibid: I'm open to suggestions :) I don't know haskell that well
22:21:47 <largos> ah.. I always forget about function composition
22:22:07 <ibid> largos: just to make sure, are you really dealing with arrays? the code you pasted above has no arrays in it
22:22:22 <largos> ibid: no, I'm using lists
22:22:32 <largos> ibid: I just got the term wrong
22:23:10 <ibid> largos: ah, ok. that makes more sense. as discussed, mapM and mapM_ are good, as well as sequence and sequence_ (depending on what specifically you need)
22:23:30 <largos> ok
22:23:48 <largos> thanks for the help
22:34:55 <vincenz> damn
22:35:03 <vincenz> How bad is it to have a >100 line function?
22:35:20 <a-priori> define a scale for "bad" :)
22:35:31 <vincenz> user-defineable
22:35:36 <mauke> about 2
22:35:45 <vincenz> well ok, it's including comments
22:35:47 <vincenz> but still
22:35:53 <vincenz> it's planend to grow at least 20-30 some lines
22:35:57 <vincenz> so let's say ~150 line function
22:36:00 <a-priori> is it monadic?
22:36:13 <vincenz> somewhat
22:36:15 <a-priori> if not, that's impressive
22:36:29 <vincenz> oh but the body is quite small
22:36:33 <vincenz> it's just a shitload of where clausses
22:36:40 <a-priori> wow
22:36:55 <vincenz> here is the signature
22:36:56 <vincenz> typeCheckBodies ::forall m. (MonadError TyperError m) => [((UniqueID String), FSig (UniqueID String) Location)] -> [((UniqueID String), CSig (UniqueID String) Location)] -> [Ident (UniqueID String) Location] -> Program (UniqueID String) Location -> m (Program (UniqueID String) Location)
22:37:13 <a-priori> eep
22:37:44 <vincenz> though the last term is off
22:37:47 <vincenz> but it' still in devel
22:38:06 <vincenz> anyways, the reason I don't just make the where clauses funcitons is cause some where clauses define some environments
22:38:18 <vincenz> I don't feel like making these helper functions take in many parameters
22:38:30 <vincenz> so therefore I define them in the whereclause alongside those environments
22:40:59 <vincenz> the fact htat my liens are 160 characters long at times doesn't help much
22:41:00 <vincenz> *coughs*
22:41:17 <mauke> hmm, the last part is Inject (Program (UniqueID String) Location) m
22:41:21 <mauke> doesn't help much, though
22:41:37 <vincenz> mauke: hmm?
22:41:50 <vincenz> oh
22:41:55 <mauke> I have a set of type aliases to abbreviate common patterns
22:41:59 <vincenz> hey it's nice code
22:42:03 <vincenz> all my where clauses are typed
22:42:12 <vincenz> and some where clauses even have sub-where clauss
22:42:41 <vincenz> mauke: good idea
22:43:09 * sjanssen has never seen a 100 line function
22:43:20 <vincenz> 150 mind you
22:43:22 <mauke> type Endo a = a -> a;  type Combine a = a -> a -> a;  type Filter a = [a] -> [a];  type Inject a m = a -> m a
22:44:24 <vincenz> sjanssen:
22:44:26 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/Screenshot.png
22:44:35 <vincenz> looks clean, no?
22:46:09 <sjanssen> that isn't bad
22:46:39 <sjanssen> all the where bound functions stick to reasonable lengths
22:47:19 <vincenz> well those are not functions
22:47:23 <vincenz> just environments I use
22:47:24 <vincenz> but yeah
22:47:28 <vincenz> the obund funcs are like 20 lines tops
22:47:34 <vincenz> (where it's a case-analysis)
22:47:43 <vincenz> so one case is like 3-4 lines
22:48:42 * vincenz thinks it looks quite clean
22:48:59 <vincenz> granted I could probably shorten my lines here and there
22:49:08 <vincenz> but then I'm introducing a shitload of stupid little helpe functions with equally stupid names
22:49:19 <vincenz> for onetime use
22:50:24 <mauke> hah
22:50:28 <mauke> exprBinary :: CICP Expression
22:50:28 <mauke> exprBinary = liftM ExpressionBinary binaryExpr
22:51:41 <vincenz> ?
22:52:31 <mauke> that's exactly what I'm writing here
22:52:36 <mauke> stupid little helper functions :-)
22:52:39 <vincenz> :D
22:52:41 <vincenz> whatfor?
22:52:51 <mauke> a parser
22:52:56 <vincenz> yeah I figured
22:52:57 <vincenz> what language
22:53:04 <vincenz> parsec, hmm?
22:53:08 * vincenz tends to use alex and happy
22:53:16 <mauke> first I translated the grammar to data definitions, now I'm translating the data structures to functions
22:53:24 <vincenz> I've got it tailored so I NEVER have to change my alex file cause it's generic and uses a language lookup for keyowrds
22:53:41 <mauke> it's my own parser library
22:53:42 <vincenz> as well as a custom monad shared by my alex and happy code for locatable code
22:53:56 <mauke> newtype CICP a = CICP { runCICP :: ParserT String [] (Tagged Char) (Reader Context) a }
22:54:23 <vincenz> what sort of language is it?
22:54:38 <vincenz> anyyone got a better name for:
22:54:43 <vincenz> data Possibly x = Always x | Possibly x | Never
22:54:58 <mauke> C/C++
22:55:01 <mauke> see http://www.cpax.org.uk/prg/portable/c/c++/rfe00003.html
22:55:02 <lambdabot> Title: C/C++ Request For Enlightenment 3 - Sample Programs
22:55:04 <vincenz> ah you too, hmm?
22:55:49 <vincenz> what language is that??
22:55:53 <mauke> C/C++
22:55:56 <vincenz> and does it rip on existing names purposefully?
22:56:13 <mauke> yep
22:56:27 * vincenz tsks
22:56:58 <mauke> Those people who will most welcome the language, however, will be the denizens of comp.lang.c, comp.lang.c++, and alt.comp.lang.learn.c-c++, all of whom are sick to the back teeth of answering questions about C/C++ with "there's no such language". Now, there is. So they will at last be able to give intelligent answers to those questions. Furthermore, it is self-evident that C/C++ is topical on all three groups, so don't let them give you any no
22:57:17 <vincenz> how lame
22:57:19 <mauke> that's from http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html
22:57:20 <lambdabot> Title: C/C++ Request For Enlightenment 0 - Design Philosophy
22:58:57 <vincenz> heh
22:58:58 <vincenz> no comment
23:01:06 <largos> does function application bind more tightly than composition?
23:01:20 <dmwit> yes
23:01:35 <largos> ok, that explains the problem I'm having :)
23:01:35 <vincenz> composition?
23:02:07 <mauke> application binds more tightly than anything
23:02:26 <largos> ok
23:06:16 <vincenz> mauke: you sure?
23:06:27 <mauke> no
23:06:40 <mauke> e.g. I don't know if it beats record update
23:07:33 <Pseudonym> Oh, I love this quote.
23:07:36 <Pseudonym> "Have the book rights gone yet?" - Rob Pike
23:13:37 <desp> they actually use the word "functino"
23:13:40 <desp> ++
23:15:47 <largos> hm.. this has me stumped (again)   I'm getting a type error: can't match 'IO t' against inferred type 'Set String'
23:16:07 <largos> with this line: resSet <- Set.unions sets  -- sets is a [Set String]
23:16:36 <largos> I don't understand where the IO t is coming from
23:16:58 <sjanssen> largos: is the rest of that do block supposed to be in the [] monad or the IO monad?
23:17:07 <largos> sjanssen: the IO monad
23:17:21 <sjanssen> that line should be: let resSet = Set.unions sets
23:17:25 <hpaste>  largos pasted "(no title)" at http://hpaste.org/1095
23:17:45 <Pseudonym> Whic is equivalent to: resSet <- return (Set.unions sets)
23:17:47 <largos> oh
23:17:49 <Pseudonym> Not that this is good style.
23:18:05 <sjanssen> <- (inside a do block) is for binding the results of monadic actions only
23:18:07 <largos> because I'm not actually doing anything within the IO monad on the right side
23:18:17 <sjanssen> precisely.
23:18:21 <largos> thanks!
23:20:41 <largos> it's so depressing how much c# it took to write this same program...
23:26:32 <mauke> :t \x y -> liftM3 id ap x y
23:26:34 <lambdabot> forall a3 a b. ((a3 -> a -> b) -> a3 -> a) -> ((a3 -> a -> b) -> a3) -> (a3 -> a -> b) -> b
23:30:01 <mauke> why isn't there an ap2?
23:32:44 * QtPlatypus guesses "Where was an a2 but it was removed at some point type inference"
23:35:44 <mauke> not a2, ap2
23:35:52 <mauke> as in ap2 = liftM3 id
23:39:49 <dons> ?yow!
23:39:49 <lambdabot> I'm continually AMAZED at th'breathtaking effects of WIND EROSION!!
23:39:54 <vincenz> @arr
23:39:54 <lambdabot> Drink up, me 'earties
23:40:04 <dons> is the CODE faster YET?!
23:40:13 <vincenz> YES!
23:40:23 <dons> HOORAY!
23:41:49 <mauke> @unpl (<< skipws) . foldr (liftM2 (:) . tchar) (return [])
23:41:50 <lambdabot> (\ i -> (foldr (\ l f -> (tchar l) >>= \ c -> f >>= \ b -> return ((:) c b)) (return []) i) << skipws)
23:41:56 <mauke> oh god
23:42:26 <sjanssen> @redo (\ i -> (foldr (\ l f -> (tchar l) >>= \ c -> f >>= \ b -> return ((:) c b)) (return []) i) << skipws)
23:42:26 <lambdabot> (\ i -> (foldr (\ l f -> do { c <- (tchar l); b <- f; return ((:) c b)}) (return []) i) << skipws)
23:42:53 <mauke> ok, that's almost readable
23:43:15 <sjanssen> the original is best
23:44:34 <sjanssen> dons: how fast is the code? (assuming you're talking about base+streams)
