00:03:16 <dmead> ?losers
00:03:17 <lambdabot> Maximum users seen in #haskell: 336, currently: 291 (86.6%), active: 32 (11.0%)
00:08:51 <desp> does anyone else think that the term "to curry" is used with a meaning precisely opposite to the intuitive one?
00:09:31 <edwardk> desp: nope
00:11:15 <nmessenger> curry (f :: (a, b) -> c) :: a -> b -> c
00:11:32 <dmead> umm
00:11:34 <dmead> yea
00:11:36 <dmead> not really
00:11:41 <desp> nmessenger: yes
00:11:52 <dmead> what do you mean by the intuitive one?
00:12:16 <dmead> brb
00:13:07 <nmessenger> makes sense to me.  A curried function takes an 'a' and produces a function that takes a 'b' and produces a 'c'.
00:13:19 <nmessenger> "Currying" a function turns it into a curried function.
00:16:32 <desp> it's just a feeling that I have whenever I read about "curried arguments" -- first I think that they've been gathered into a tuple, then I remember it's the other way around
00:17:37 <nmessenger> think about the functions themselves being curried.  i.e. turned from functions-on-pair into functions-returning-functions.
00:17:53 <desp> you're right, I probably should
00:18:40 <nmessenger> @type uncurry {- turns a curried function -} (==) {- into a function on pairs -}
00:18:42 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
00:19:28 <nmessenger> > (uncurry (==)) (5,5)
00:19:30 <lambdabot>  True
00:19:35 <desp> sure, I know.
00:20:10 <nmessenger> @type curry randomRIO 0
00:20:12 <lambdabot> forall a. (Random a, Num a) => a -> IO a
00:20:26 <nmessenger> ^^ handy function that takes a random upper bound
00:21:46 <desp> er
00:22:36 <desp> ah.
00:22:47 <nmessenger> randomR usually takes a (lowerBound, upperBound) pair, so if you curry it and partially apply it to a lower bound, you get a function from upper bounds to IO numbers.
00:23:45 <desp> I got confused by the Random constraint
00:24:41 <nmessenger> (Random a => a) is basically a type that can have a random element picked from.
00:24:45 <nmessenger> @instances Random
00:24:46 <lambdabot> Couldn't find class `Random'. Try @instances-importing
00:24:47 <desp> right
00:39:36 <dolio> ?hoogle iterateM
00:39:37 <lambdabot> No matches found
00:49:30 <mauke> :t mapM_
00:49:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
01:03:20 <desp> "The functions that are expressible in terms of foldr are also known as list catamorphisms or bananas."
01:03:23 <desp> bananas!?
01:03:33 <mauke> yes
01:03:43 <mauke> @google bananas lenses wire
01:03:45 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
01:03:45 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
01:04:11 <desp> :)
01:11:56 <ray> ooh, bananas
01:11:56 <dolio> @pl iterateM f a = f a >>= \b -> iterateM f b >>= \c -> (b:c)
01:11:57 <lambdabot> iterateM = fix (liftM2 flip ((>>=) .) . flip flip (:) . (liftM2 (>>=) .))
01:13:47 <dolio> @pl iterateM f a = f a >>= \b -> iterateM f b >>= \c -> return (b:c)
01:13:48 <lambdabot> iterateM = fix (liftM2 flip ((>>=) .) . flip flip ((return .) . (:)) . (liftM2 (>>=) .))
01:13:55 <dolio> Heh.
01:23:49 <dons> ?yow
01:23:49 <lambdabot> Make me look like LINDA RONSTADT again!!
01:23:58 <dons> stepcut: ah ha!
01:23:59 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
01:24:23 <nmessenger> @pl uni (fix . (++))
01:24:24 <lambdabot> uni (fix . (++))
01:24:33 <nmessenger> :(   (fix . (++)) = cycle
01:25:20 <dons> @tell liquidengineer <stepcut> +    a <= b  = (playerID a)  <= (playerID b)
01:25:20 <lambdabot> Consider it noted.
01:25:27 <ailndx> dons: cant you put someone on hsplugins in win.. to write a small tutorial on how to install/configure and so on?
01:25:30 <Sgeo> let twos = iterate (2^) 0 in twos !! 6
01:25:52 <dons> ailndx: hmm. if someone knows how to do it...
01:26:00 <Sgeo> @help
01:26:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:26:05 <Sgeo> @list
01:26:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
01:26:27 <ailndx> dons: yes, but obviously a few people has used it in win
01:26:44 <Sgeo> @let twos = iterate (2^) 0 in twos !! 6
01:26:44 <lambdabot>  Parse error
01:26:52 <Sgeo> How do I run a line?
01:26:56 <nmessenger> Sgeo: @run or > expr
01:27:02 <nmessenger> > ()
01:27:03 <lambdabot>  ()
01:27:08 <Sgeo> @run let twos = iterate (2^) 0 in twos !! 6
01:27:09 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
01:27:19 <dons> ailndx: yeah, seems that foxy does, for example
01:27:21 <Sgeo> aww, it didn't display the whole number..
01:27:23 <Sgeo> > let twos = iterate (2^) 0 in twos !! 6
01:27:25 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
01:27:41 <dons> > 10 ^ 1000
01:27:42 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
01:28:17 <Sgeo> > let twos = iterate (2^) 0 in twos !! 7
01:28:21 <lambdabot> Terminated
01:28:41 <nmessenger> > length . show . (!! 6) . iterate (2^) $ 0
01:28:42 <lambdabot>  19729
01:28:51 <Sgeo> > let twos = iterate (2^) 0 in take 7 twos
01:28:53 <lambdabot>  [0,1,2,4,16,65536,2003529930406846464979072351560255750447825475569751419265...
01:28:55 <nmessenger> nineteen *thousand* digits!
01:29:51 <ray> > (iterate (2^) 0) !! 5
01:29:53 <lambdabot>  65536
01:30:03 <ray> hehe
01:30:11 <ray> five digits!
01:30:28 <nmessenger> exponentials have a way of doing that.
01:30:47 <nmessenger> > length . show . (!! 7) . iterate (2^) $ 0 -- hopefully it terminates :D
01:30:51 <lambdabot> Terminated
01:30:57 <QtPlatypus> nmessenger: There not exponentials, there the next ones up?
01:30:58 <nmessenger> :)
01:31:22 <ray> tetrations?
01:31:30 <Sgeo> twos !! 7 is taking a bit of a while to compute on my comp
01:31:49 <nmessenger> Sgeo: I wouldn't doubt it :)
01:32:05 <nmessenger> 2^(number with 19 thousand digits)
01:32:59 * Sgeo is just trying to compute its LENGTH
01:32:59 <nmessenger> I'm not sure what iterated exponentials are called.
01:33:15 <nmessenger> :O
01:33:19 <Sgeo> is there an easier way to do that?
01:33:26 <nmessenger> logBase 10?
01:33:30 <Sgeo> That doesn't involve finding twos !! 7?
01:33:41 <ray> > (iterate exp 0) !! 6
01:33:43 <lambdabot>  NaN
01:33:48 <ray> oh how nice
01:34:01 <nmessenger> > (iterate (2^) 0) !! 7
01:34:05 <lambdabot> Terminated
01:34:08 <ray> lambdabot: you're NaN
01:34:08 <nmessenger> > (iterate (2^) 0) !! 6
01:34:09 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
01:34:20 <dolio> > exp 0
01:34:21 <lambdabot>  1.0
01:34:38 <dolio> > iterate exp 0
01:34:39 <lambdabot>  [0.0,1.0,2.718281828459045,15.154262241479262,3814279.104760214,Infinity,NaN...
01:34:52 <nmessenger> > logBase 10 ((iterate (2^) 0) !! 6)
01:34:53 <lambdabot>  Add a type signature
01:35:01 <nmessenger> > logBase 10 ((iterate (2^) 0) !! 6) :: Double
01:35:01 <lambdabot>   add an instance declaration for (Integral Double)
01:35:18 <Sgeo> > logBase 10 ((iterate (2^) 0) !! 6) :: Integer
01:35:19 <lambdabot>   add an instance declaration for (Floating Integer)
01:35:19 <lambdabot>     In the expression: l...
01:35:26 <ray> sif!
01:35:43 <nmessenger> > logBase 10 ((iterate (2**) 0) !! 6) -- silly me
01:35:44 <lambdabot>  Infinity
01:35:48 <nmessenger> :D
01:36:03 <Sgeo> > logBase 10 ((iterate (2**) 0) !! 5)
01:36:05 <lambdabot>  4.816479930623698
01:36:39 <Sgeo> twos !! 5 has 4.816 digits???
01:36:43 <Sgeo> erm
01:36:51 <nmessenger> logBase 10 10
01:36:54 <Sgeo> Oh, right, log base 10 isn't exact
01:36:59 <nmessenger> > logBase 10 9
01:37:00 <lambdabot>  0.9542425094393249
01:37:28 <int-e> 65536 has 5 digits. yes.
01:37:46 * Sgeo still wants a sane way to find the number of digits in twos !! 7
01:39:00 <dolio> Isn't it approximately (twos !! 6) * logBase 10 2?
01:39:46 <Sgeo> > let twos = iterate (2^) 0 in (twos !! 6) * (logBase 10 2)
01:39:47 <lambdabot>  Add a type signature
01:39:59 <Sgeo> Sgeo> Can anyone figure out a way to determine the number of digits in twos !! 7 WITHOUT finding twos !! 7?
01:39:59 <Sgeo> <bd_> twos !! 6 / ln(2)
01:40:20 <bd_> wait
01:40:21 <bd_> log 2
01:40:22 <bd_> <.<
01:40:25 <bd_> silly me
01:40:28 <QtPlatypus> I possable rout would be to find the function that, f(x) = y such that x = log_10 a and y = log_10 b where a^2 = b.  Then iterate over that function.
01:40:30 <bd_> we're not looking for digits in base e :)
01:40:47 * nmessenger wants base e numerals
01:40:52 * ray too
01:41:03 <QtPlatypus> (I might have got that backwards at some point, but i think people will work it out)
01:41:08 <dolio> Didn't I just say it?
01:41:23 <dolio> twos !! 7 = 2^(twos !! 6)
01:41:28 <Sgeo> let twos = iterate (2^) 0 in (twos !! 6) * logBase 10 2
01:41:31 <Sgeo> > let twos = iterate (2^) 0 in (twos !! 6) * logBase 10 2
01:41:32 <lambdabot>  Add a type signature
01:41:35 <nmessenger> > (iterate (2**) 0 !! 6) * logBase 10 2
01:41:37 <lambdabot>  Infinity
01:41:42 <nmessenger> many many digits
01:41:44 <Sgeo> Why is it asking for a type signature?
01:41:51 <Sgeo> > (iterate (2**) 0 !! 5) * logBase 10 2
01:41:53 <lambdabot>  19728.301795834668
01:41:56 <nmessenger> (^) doesn't match logBase's type
01:42:04 <ray> ** does though
01:42:15 <ray> :t (**)
01:42:16 <nmessenger> (^) results in an Integral, (**) in a Floating (I think)
01:42:18 <lambdabot> forall a. (Floating a) => a -> a -> a
01:42:23 * Sgeo wants an exact answer..
01:42:30 <Sgeo> And not some infinity thing
01:42:31 <dons> i'm officiall callling 'shennanigans' now on anyone who complains their code works, even though the types don't check :-)  (see thread here:  http://programming.reddit.com/info/1at09/comments/c1b0xk)
01:42:32 <lambdabot> Title: ask reddit: thoughts on writing a Haskell/Lisp hybrid language (reddit.com)
01:43:13 <dolio> Ah, haskell is anti-programmer-freedom. :)
01:43:23 <dons> the type system is expressive enough for anyone's practical use. so any claims (by anti type system people) that they have code that would work, but doesn't type, i'm just going to call their bluff now.
01:43:40 <opqdonut> yeah
01:43:48 * nmessenger remembers a Dijkstra paper where he says that people even now equate "ease of programming" with "ease of making undetected mistakes" :)
01:43:55 <dons> nmessenger: *exactly*
01:44:04 <dolio> Sgeo: I think if you want an exact answer, you're going to have to go find an arbitrary precision floating point library. :)
01:44:08 <dons> the dynamic typing fallacy
01:44:41 <dolio> :t iterate (2**) 0
01:44:43 <lambdabot> forall t. (Floating t) => [t]
01:45:01 <dolio> > (iterate (2**) 0 !! 6) * logBase 10 2 :: Double
01:45:02 <lambdabot>  Infinity
01:45:04 <nmessenger> dons: I guess they just want to do there own case analysis without having to bother with making union types?
01:45:09 <Sgeo> If programmers were perfect and never wrote buggy code, would strongly-typedness be a liability?
01:45:24 <dons> nmessenger: yes, I thin kthat's usually the situatoin
01:45:25 <dons> [a]
01:45:32 <ray> nope, because all the code would pass the type checker then
01:45:35 <dons> esp. coming from a lisp guy
01:46:03 <nmessenger> like [Either This (Either That Other)], they just want to use This That and the Other directly.
01:46:11 <dons> yeah.
01:46:14 <Sgeo> How would you do self-writing code in Haskell?
01:46:19 <dons> and either they don't know about tags or existentials
01:46:23 <dons> > 1+2 -- like this
01:46:24 <lambdabot>  3
01:46:34 <dons> lambdabot is adding code to itself on the fly
01:46:39 <dons> and whoa! statically typed too
01:46:44 <dons> > readFile "/etc/passwd"
01:46:45 <lambdabot>  <IO [Char]>
01:46:47 <dons> omg!
01:46:58 <dons> :-)
01:46:59 <dolio> Also, strong typing (in haskell, at least) enables the compiler to do a lot of stuff for you automatically. So it's not useless even if you write perfect code.
01:47:23 <nmessenger> "You forgot to handle all the cases, silly!"
01:47:31 <dons> yeah, type specialisations, for example
01:47:43 <dons> if we know the type , we can pick a better sort functions, automagically
01:47:50 <dons> (we're hacking this up for [a] actually...)
01:48:06 <nmessenger> eh?
01:48:15 <dons> re. dolio's comment.
01:48:26 <dons> so say, you write sort xs :: [Word8]
01:48:30 <dons> we have a rule that says:
01:48:45 <dons> RULES forall (xs :: [Word8]) . sort xs == bucketsort xs
01:48:55 <nmessenger> gotcha.  cool!
01:49:02 <dons> ie. library -based optimisation, based on type s
01:49:35 <dons> or, RULE forall xs :: (Ord a => [a]) . nub xs == nubBy Data.Map
01:49:42 <dons> so better complexity for nub, if its in Ord
01:49:51 <dons> where we use a Map, rather than a [a]
01:50:16 <dons> if you don't know the type statically, you can't hope to have the compiler pick better algorithms for you
01:53:47 <dolio> There are even examples where it helps the mere mortal programmer directly.
01:54:03 <dolio> Like, when someone was asking for permutations the other day...
01:54:24 <Sgeo> Python doesn't seem to like the number (of digits)
01:54:42 <dolio> Write a MonadChoice instance that provides choose :: [a] -> (a, [a]) for picking one element from a list...
01:55:01 <dolio> Then use that to make permutation :: MonadChoice m => [a] -> m a
01:55:18 <dolio> If you run it in the list monad, you get all permutation. In the random monad, you get one random permutation, ...
01:55:55 <ray> see, that's the kind of thing that makes ray like haskell
01:56:09 <dolio> And it's all the same code (for permutation) that automatically gets different results depending on what type you request.
01:59:53 <ddarius_> dons: I'm surprised you didn't explicitly mention hs-plugins
02:07:08 <dons> ddarius: well, there's ghc-api too. and clean has its dyn linker framework.
02:14:52 <desp> :where isSpace
02:14:57 <desp> hm
02:15:04 <desp> how do I find out which package it's in?
02:15:23 <desp> @list
02:15:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
02:15:55 <desp> @hoogle isSpace
02:15:56 <lambdabot> Char.isSpace :: Char -> Bool
02:16:15 <mauke> @index isSpace
02:16:15 <lambdabot> Data.Char
02:16:17 <desp> @botsnack
02:16:17 <lambdabot> :)
02:30:34 <Sgeo> How does folding an infinite list work?
02:31:14 <Eidolos> It doesn't.
02:31:37 <Lemmih> It doesn't?
02:31:44 <Eidolos> It does?
02:31:49 <augustss_> It does too, if your function isn't strict
02:31:53 <nmessenger> depends if the combining function is a good producer or not.
02:32:16 <Sgeo> Where is the explanation of folds?
02:32:37 <mauke> @where fold
02:32:37 <lambdabot> I know nothing about fold.
02:32:43 <Eidolos> There are many.. most tutorials cover them
02:32:46 <dolio> Cale had some nice pictures the other day, I think...
02:32:47 <Sgeo> @where foldl
02:32:48 <lambdabot> I know nothing about foldl.
02:32:50 <dolio> @where logs
02:32:50 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
02:32:51 <nmessenger> foldr f z [1,2,3,4,5] = f 1 (f 2 (f 3 (f 4 (f 5 z))))
02:34:26 <dolio> http://cale.yi.org/index.php/Fold_Diagrams
02:34:29 <lambdabot> Title: Fold Diagrams - CaleWiki
02:35:14 <nmessenger> foldr (:) [] = id, since [1,2,3,4,5] is means (1 : (2 : (3 : (4 : (5 : [])))))
02:35:36 <nmessenger> so effectively foldr f z "replaces" [] with z and (:) with f.
02:35:51 <Eidolos> So how can you fold an infinite list?
02:36:12 <nmessenger> f just has to produce a top-level constructor in finite time
02:36:15 <desp> infinitely long
02:36:17 <desp> ;)
02:37:00 <dolio> > head $ foldr (:) [] [1..]
02:37:01 <lambdabot>  1
02:37:16 <nmessenger> @src head
02:37:16 <lambdabot> head (x:_) = x
02:37:17 <lambdabot> head []    = undefined
02:37:17 <Eidolos> ah
02:37:37 <nmessenger> pattern matches against the first constructor, so it's evaluation is forced
02:39:01 <dolio> At some point in the (non-strict) evaluation, you end up with: "1 : foldr (:) [] [2..]", at which point you can deconstruct and find the head.
02:39:21 <nmessenger> the usual problem with folding into a number is that all the (existing) numeric constructors are unique so it must be fully evaluated to produce that number.
02:39:27 <Eidolos> right, I hadn't considered that possibility
02:39:42 <dolio> There are some other slightly less trivial examples, too.
02:40:06 <dolio> > foldr (||) False (repeat True)
02:40:07 <lambdabot>  True
02:41:04 <dolio> Since at some point there you get "True || foldr (||) False (repeat True)", and || short-circuits.
02:41:06 <Sgeo> > foldr' (||) False (repeat True)
02:41:06 <lambdabot>   Not in scope: `foldr''
02:41:12 <Sgeo> > foldl (||) False (repeat True)
02:41:16 <lambdabot> Terminated
02:41:17 <int-e> @src or
02:41:18 <lambdabot> or    =  foldr (||) False
02:42:03 <dolio> Yeah, foldl won't allow for infinite folding.
02:42:45 <nmessenger> > foldl (flip const) 0 [1..]
02:42:49 <lambdabot> Terminated
02:43:50 <ddarius> The key thing is: foldr c n (x:xs) = c x (foldr c n xs)
02:44:30 <dolio> Because with foldl, it goes from "foldl f z (x:xs)" to "foldl f (f z x) xs" and xs is still infinite.
02:45:15 <nmessenger> yeah, you'd need foldl to pattern-match on [] to produce a non-recursive top level expression.
02:45:20 <Sgeo> > scanr (*) 1 [1..]
02:45:23 <lambdabot>  Exception: stack overflow
02:45:28 <Sgeo> >take 5 $ scanr (*) 1 [1..]
02:45:36 <nmessenger> s/>t/> t/
02:45:45 <Sgeo> > take 5 $ scanr (*) 1 [1..]
02:45:48 <lambdabot>  Exception: stack overflow
02:45:57 <dolio> Scans are kind of reversed.
02:46:04 <Sgeo> @t scanr (*) 1 [1..]
02:46:05 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
02:46:11 <Sgeo> @type scanr
02:46:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
02:46:24 <dolio> scanl can generate lazy infinite lists, where scanr won't.
02:46:33 <Sgeo> > take 5 $ scanl (*) 1 [1..]
02:46:34 <lambdabot>  [1,1,2,6,24]
02:46:58 <nmessenger> 'cause the result of foldl is the last of the scanl?
02:47:06 <Eidolos> > take 5 $ scanl1 (*) [1..]
02:47:08 <lambdabot>  [1,2,6,24,120]
02:47:19 <ddarius> @src scanl
02:47:20 <lambdabot> scanl f q ls = q : case ls of
02:47:20 <lambdabot>     []   -> []
02:47:20 <lambdabot>     x:xs -> scanl f (f q x) xs
02:47:33 <int-e> @index scanl'
02:47:33 <lambdabot> bzzt
02:47:41 <nmessenger> immediately give (q : _)
02:47:49 <nmessenger> gives*
02:48:03 <nmessenger> @src scanr
02:48:03 <lambdabot> scanr _ q0 []     =  [q0]
02:48:03 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
02:48:03 <lambdabot>     where qs@(q:_) = scanr f q0 xs
02:48:05 <dolio> Yeah. And the head of scanr is the result of foldr.
02:48:19 <Sgeo> > take 5 $ scanl (2^) 0 [1..]
02:48:20 <lambdabot>   add an instance declaration for (Num (b -> a))
02:48:29 <dolio> Requiring you to compute the rest of the infinite list before you can find it.
02:48:31 <dolio> Or something like that.
02:48:37 <Sgeo> > take 5 $ scanl (^) 0 [1..]
02:48:39 <lambdabot>  [0,0,0,0,0]
02:48:43 <Sgeo> > take 5 $ scanl (^) 2 [1..]
02:48:45 <lambdabot>  [2,2,4,64,16777216]
02:49:00 <Sgeo> > take 6 $ scanl (^) 2 [1..]
02:49:01 <lambdabot>  [2,2,4,64,16777216,1329227995784915872903807060280344576]
02:49:10 <Sgeo> More large numbers!
02:50:25 <Sgeo> > take 5 $ scanl (^) 2 [0..]
02:50:27 <lambdabot>  [2,1,1,1,1]
02:50:46 <Sgeo> > take 5 $ scanl (^) 2 [2..]
02:50:47 <lambdabot>  [2,4,64,16777216,1329227995784915872903807060280344576]
02:50:55 <nmessenger> [2, 2^0, 2^0^1..]
02:51:11 <Eidolos> Do you not have a local REPL, Sgeo? :)
02:51:29 <Sgeo> REPL?
02:51:36 <ray> ghci, for instance
02:51:37 <nmessenger> @vera repl
02:51:38 <lambdabot> No match for "repl".
02:51:40 <Eidolos> read-eval-print loop
02:51:48 <Eidolos> basically what you're doing with lambdabot
02:51:59 <mauke> (loop (print (eval (read))))
02:52:48 * Sgeo has hugs
02:53:21 <nmessenger> you might also /msg lambdabot if you want to play around
02:54:03 <Boney> Hey guys.  I've installed haskell and most things from my package manager (Ubuntu Edgy).  Now I'm trying to build HappS and it's dependancies from source since I can't find them in the package manager.  I got up to regex-base which requires base >= 2 and I'm stuck.  Is there an easier way?
02:59:13 <Heffalump> morning
03:05:22 <Sgeo> Grr why can Haskell handle 2^65536 but not 2**65536 ?
03:06:14 <dolio> Because 2^65536 is an arbitrary precision Integer, and 2**65536 is a machine Double.
03:06:16 <Eidolos> @type (^)
03:06:18 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
03:06:22 <Eidolos> @type (**)
03:06:24 <lambdabot> forall a. (Floating a) => a -> a -> a
03:06:56 <Sgeo> So there's no way to make 2**65536 arbitrary precision?
03:07:06 <Eidolos> Use ^
03:07:07 <Sgeo> 2**65536 * logBase 10 2
03:07:21 <nmessenger> > fromIntegral (2^65536)
03:07:23 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
03:07:29 <nmessenger> > fromIntegral (2^65536) :: Double
03:07:30 <lambdabot>  Infinity
03:07:44 <dolio> I don't think there's such a thing in the standard library. I've seen such a library before, but I don't know where it is off hand.
03:08:06 <dolio> > 2^65536 :: Double
03:08:07 <lambdabot>  Infinity
03:08:14 <dolio> That works, but it defaults to Integer.
03:09:21 <nmessenger> > let r x = realToFrac x in r (2^65536) * r (logBase 10 2) :: Rational
03:09:23 <lambdabot>  6031226062630294315555551075409685705468663232716199844564674818191145408393...
03:09:48 <Sgeo> realToFrac?
03:09:57 <nmessenger> @type realToFrac
03:09:59 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
03:10:03 <nmessenger> Real coercion
03:10:09 <nmessenger> like fromIntegral
03:10:10 <Eidolos> I think real is arbitrary precision, frac is machine size
03:10:18 <nmessenger> @instances Fractional
03:10:19 <lambdabot> Double, Float
03:10:27 <ray> @instances Real
03:10:28 <lambdabot> Double, Float, Int, Integer
03:10:33 <Eidolos> ah
03:10:52 <nmessenger> hmm, Rational has to be in Fractional too or that wouldn't type :/
03:10:55 <nmessenger> @src Rational
03:10:55 <lambdabot> type Rational = Ratio Integer
03:11:35 <augustss> @src Ratio
03:11:35 <lambdabot> data (Integral a) => Ratio a = !a :% !a
03:11:53 <Eidolos> interesting
03:11:56 <Eidolos> what the heck does that mean? :)
03:12:01 <nmessenger> I wonder why Ratio isn't in the instances list?
03:12:14 <nmessenger> > 20 % 5
03:12:16 <lambdabot>  4%1
03:12:18 <dolio> Ratio a is isomorphic to (a, a)
03:12:22 <Sgeo> 19728 digits in the number of digits? (mathamatical based guess)
03:12:39 <dolio> So it's a pair of a numerator and denominator.
03:12:51 <Eidolos> I just don't recognize the syntax !a :% !a
03:13:05 <dolio> Oh. Infix constructors have to begin with :
03:13:14 <dolio> And !a means that it's strict in a.
03:13:14 <nmessenger> yep
03:13:22 <Eidolos> I see
03:13:40 <dolio> So: undefined :% 1 is undefined.
03:13:45 <dolio> And so on.
03:13:56 <augustss> dolio: Ratio is not isomorphic to (a,a).  There is always a reduction of the numbers with the gcd
03:14:37 <nmessenger> you can try (let r x = realToFrac x in r (2^65536) * r (logBase 10 2) :: Rational) in your interpreter, but be prepared for large number :)
03:14:39 <dolio> Eh, true.
03:15:11 <augustss> The representation type is isomorphic, but you can't get at the.
03:15:29 <Sgeo> length $ show $ (realToFrac (2^65536) * realToFrac (logBase 10 2) :: Rational) - 4 --the -4 is for the bits at the end
03:15:33 <Sgeo> > length $ show $ (realToFrac (2^65536) * realToFrac (logBase 10 2) :: Rational) - 4 --the -4 is for the bits at the end
03:15:34 <lambdabot>  19730
03:15:39 <Sgeo> erm
03:15:56 <nmessenger> > {- also inexact I'd wager, since -} realToFrac (logBase 10 2) {- is likely rounded -}
03:15:57 <lambdabot>  0.30102999566398114
03:15:58 <Sgeo> > length $ show $ (realToFrac (2^65536) * realToFrac (logBase 10 2) :: Rational)
03:16:00 <lambdabot>  19730
03:16:16 <nmessenger> > {- er,-} realToFrac (logBase 10 2) :: Rational {- rather :) -}
03:16:17 <lambdabot>  2711437152599295%9007199254740992
03:16:42 <rahikkala> > "hi" >> "ho" >> "hello"
03:16:43 <lambdabot>  "hellohellohellohello"
03:16:58 <nmessenger> :)
03:17:05 <augustss> > approxRational pi 1e-10
03:17:06 <lambdabot>  312689%99532
03:17:21 <Sgeo> Would 65536 * logBase 10 2 + logBase 10 (logBase 10 2) work as the number of digits in the number of digits in 2^(2^65536)
03:17:51 <augustss> > approxRational pi 1e5
03:17:53 <lambdabot>  0%1
03:18:04 <nmessenger> > 65536 * logBase 10 2 + logBase 10 (logBase 10 2)
03:18:05 <lambdabot>  19727.780405607013
03:18:33 <Eidolos> > length $ show 2^(2^65536)
03:18:33 <lambdabot>   add an instance declaration for (Num String)
03:18:40 <Eidolos> > length $ show (2^(2^65536))
03:18:44 <lambdabot> Terminated
03:18:54 <augustss> > length $ show 2^65536
03:18:55 <lambdabot>   add an instance declaration for (Num String)
03:19:10 <nmessenger> = (show 2)^65536
03:19:14 <augustss> ength $ show $ 2^65536
03:19:18 <augustss> arg
03:19:35 <augustss> > length $ show $ 2^65536
03:19:36 <lambdabot>  19729
03:20:13 <Eidolos> > reverse $ take 5 $ reverse $ show $ 2^65536
03:20:14 <lambdabot>  "56736"
03:20:33 <dolio> > ceiling (65536 * logBase 10 2)
03:20:34 <lambdabot>  19729
03:20:40 <Eidolos> I guess that'd be a bit easier as drop 19724 :)
03:21:30 <Sgeo> > ceiling (65536 * logBase 10 2 + logBase 10 (logBase 10 2))
03:21:31 <lambdabot>  19728
03:21:55 <Sgeo> That SHOULD be the number of digits required to show the number of digits in 2^(2^65536)
03:22:27 <Eidolos> Learn something new every day :P
03:25:09 <dibblego> why isn't it?
03:25:37 <Sgeo> dibblego, hm?
03:25:51 <dibblego> why is it 19728 and not 19729?
03:26:05 <dibblego> > > length $ show $ 2^65536 -- since this is 19729
03:26:06 <lambdabot>  Parse error
03:26:10 <dibblego> > length $ show $ 2^65536 -- since this is 19729
03:26:11 <lambdabot>  19729
03:26:23 <nmessenger> floating point error?
03:26:26 <dibblego> which is wrong and why
03:27:20 <dolio> > logBase 10 (logBase 10 2)
03:27:21 <lambdabot>  -0.5213902276543249
03:27:23 <dibblego> ?type 2^65536
03:27:26 <lambdabot> forall t. (Num t) => t
03:27:26 <dolio> Tha'ts why.
03:27:39 <dmwit> dibblego: There should probably be a parens around the RHS of the (*) operator.
03:28:01 <dmwit> Errr...
03:28:32 <dibblego> > let f = \x -> ceiling $ x * (logBase 10 2 + logBase 10 $ logBase 10 2)) in f 65536
03:28:32 <lambdabot>  Parse error
03:28:38 <dibblego> > let f = \x -> ceiling $ x * (logBase 10 2 + logBase 10 $ logBase 10 2) in f 65536
03:28:38 <lambdabot>   add an instance declaration for (Floating (a -> a))
03:28:55 <Sgeo> dibblego, I don't think number of digits in the number of digits in 2^(2^65536) should be the number of digits in 2^(2^65536)
03:29:08 <dibblego> Sgeo, oh :)
03:29:16 <dmwit> > 2^65536 * (ceiling (logBase 10 2))
03:29:17 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
03:29:20 <Sgeo> s/should be/has to be/
03:29:44 <Sgeo> ceiling (logBase 10 2)
03:29:49 <Sgeo> > ceiling (logBase 10 2)
03:29:50 <lambdabot>  1
03:29:53 <dmwit> oic
03:30:06 <dibblego> "number of digits in the number of digits in" -- you said "number of digits" there intentionally right?
03:30:11 <dibblego> (twice)
03:30:13 <Sgeo> dibblego, yes
03:30:16 <dibblego> ok
03:40:27 <tibbe> what exactly is the purpose of Typeable?
03:40:48 <nmessenger> @src Typeable
03:40:48 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
03:41:31 <nmessenger> class Typeable a where typeOf :: a -> TypeRep; i.e. defines a runtime type representation for each type so they can be compared, casted, etc.
03:42:19 <tibbe> and introspected?
03:42:50 <nmessenger> I would suppose so, I've not looked very far.  Try :b Data.Typeable
03:43:41 <nmessenger> there are various functions (TypeRep -> a) that can be used to decompose type reps.
03:45:06 <tibbe> ok
03:45:07 <tibbe> thanks
03:45:13 <nmessenger> @type (\x -> fromMaybe (show x) (cast x))
03:45:16 <lambdabot> forall a. (Show a, Typeable a) => a -> String
03:45:27 <nmessenger> id on Strings, show on everything else.
03:47:45 <tibbe> hmm, perhaps I'm looking for Data not Typeable
03:51:13 <nmessenger> Data.Generics?
04:00:58 <tibbe> nmessenger, whatever you get when you do deriving Data
04:01:29 <nmessenger> I've not used it, but yeah, the Data class is in Data.Generics
04:01:34 <nmessenger> @docs Data.Generics
04:01:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
04:01:41 <Sgeo> Why do some things get to be special-cased?
04:01:50 <nmessenger> Sgeo: which things?
04:01:54 <Sgeo> deriving
04:02:04 <Sgeo> deriving Ord and stuff
04:02:48 <nmessenger> the compiler inserts reasonable instances for your data types, but you're free to define your own instead
04:03:17 <nmessenger> Only some are special cased because the compiler doesn't know about arbitrary classes.
04:05:34 <nmessenger> for example, given data T a c = A a | B | C c, deriving Ord would require a and c to be in Ord, all of (A a) would be ordered according to a's order, followed by B, followed by all of (C c)
04:07:29 <nmessenger> anyway, I'm spent.  'Night all.
04:08:03 <dcoutts__> @seen dons
04:08:04 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 2h 56s ago.
04:08:33 <dcoutts__> dons: should I email SPJ about the SpecConstr pragma stuff then?
04:09:09 <dcoutts__> hmm, actually it's still Sunday in UK so we can do it tomorrow and he'll get the email on Monday
04:13:59 <dolio> dons: I have some list-heavy code if you're still looking for such stuff.
04:14:23 <tuukkah> @pl \x y -> (x-y)
04:14:24 <lambdabot> (-)
04:14:45 <tuukkah> @pl \x -> \y -> (x-y)
04:14:45 <lambdabot> (-)
04:15:20 <tuukkah> @pl \x -> (x-)
04:15:20 <lambdabot> (-)
04:15:22 <tuukkah> @pl \x -> (-x)
04:15:23 <lambdabot> subtract
04:15:28 <tuukkah> that one :-)
04:17:47 <tuukkah> and whole my life i've thought it's spelled substract
04:24:30 <tibbe> is it possible to create types during runtime, by introspecting a database table say
04:31:04 <augustss> tibbe: Not really
04:31:07 <tuukkah> some dictionaries claim it can also be spelled as substract
04:32:00 <tibbe> augustss, ok
04:38:10 <johanneshoff> hi. anyone here with Graphics.SOE knowledge?
04:38:54 <johanneshoff> I would like to draw stuff in any color, but the only constructors I find for Color is White, Red, Green, etc.
04:39:25 <johanneshoff> I would prefer creating a color based on RGB values
05:11:24 <hpaste>  johanneshoff pasted "Import problems" at http://hpaste.org/1022
05:12:36 <ivanm> @hoogle RGB
05:12:36 <lambdabot> No matches found
05:12:43 <ivanm> @hoogle rgb
05:12:43 <lambdabot> No matches found
05:12:46 <johanneshoff> can anyone tell me why i can access the constructor RGB in winhugs, but the very same is undefined when running it (with runhugs)
05:12:59 <ivanm> what is the constructor?
05:13:04 <ivanm> custom?
05:13:38 <ivanm> can you do the col = RGB 1 2 3 line in winhugs?
05:13:59 <ivanm> @info Word8
05:13:59 <johanneshoff> well, i can
05:13:59 <lambdabot> Word8
05:14:10 <ivanm> @hoogle Word8
05:14:11 <lambdabot> Data.Word.Word8 :: data Word8
05:14:29 <johanneshoff> well, i can't evaluate expressions in winhugs (that i know of, but i'm really a noob. got it yesterday :)
05:14:41 <ivanm> how about col = RGB (1 :: Word8) (2:: Word8) (3 :: Word8)
05:14:58 <ivanm> but it looks like an importation issue...
05:15:29 <Saizan> you should be able to, it's an interpreter..
05:15:39 <johanneshoff> with col = RGB (1 :: Word8) (2:: Word8) (3 :: Word8), I get the same error
05:15:57 <ivanm> where is the Graphics library from? is it a custom one?
05:16:37 <johanneshoff> saizan: ah, you're right. what I can't do is binding. (then I get Syntax error in input (unexpected `=') )
05:16:56 <johanneshoff> so, RGB 1 2 3 evaluates just fine in winhugs
05:17:00 <Lemmih> johanneshoff: Have you tried ':info RGB'?
05:17:58 <johanneshoff> ivanm: it was the one that came with hugs (version Sep 2006)
05:19:04 <ivanm> johanneshoff: no wonder I don't have it then... I don't have hugs installed
05:19:57 <hpaste>  johanneshoff pasted ":info RGB" at http://hpaste.org/1023
05:20:22 <johanneshoff> lemmih: trying :info RGB, nothing surprising there
05:20:33 <johanneshoff> (except that I just learned about :info :) )
05:21:23 <johanneshoff> ivanm: yeah, I first tried with GHC, but couldn't get the Graphics module to work at all
05:33:35 <johanneshoff> hmm.. using Graphics.HGL instead of Graphics.SOE gives me access to the RGB constructor. Only to realize that RGB r g b is not a constructor for Color :( ( found at http://www.csc.depauw.edu/~bhoward/courses/0203Fall/csc122/haskell/ )
05:33:38 <lambdabot> Title: Programming with Haskell, http://tinyurl.com/ynohpu
05:34:12 <johanneshoff> thanks for the help anyway. everything was much easier with the :info command
05:38:03 <dons> ?yow
05:38:04 <lambdabot> Did I SELL OUT yet??
05:44:22 <mwc> @seen dcoutts_
05:44:22 <lambdabot> dcoutts_ is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
05:44:59 <mwc> Sunday morning, and nobody's up early to Haskell?
05:45:32 * ekidd is looking at his category theory tutorial, trying to decide whether to add a new section
05:45:38 * desp yawns
05:46:11 <dons> mwc, dcoutts is probably in bed now :-) (he's in .au)
05:46:24 <mwc> ahh, thought he was in .uk
05:46:28 <desp> seems like Haskell is awfully popular in .au?
05:46:48 <ivanm> dons: its not even 12 down in sydney, what's dcoutts doing in bed? :P
05:46:50 <dons> it's taught in a fair few universities here.
05:46:53 <mwc> desp, it just appears that way because dolio is freakishly productive
05:46:59 <ekidd> "Haskell. Australian for programming."
05:47:02 <desp> heh
05:47:09 <mwc> s/dolio/dons
05:47:11 <dons> hehe. we were at the pub this arvo, maybe he's worn out from that
05:47:23 <desp> dons: it's taught in plenty of Polish unis as well
05:47:28 <dons> great!
05:47:49 <ivanm> ekidd: only down south, in Queensland they use Scheme nowadays
05:48:07 <ekidd> One of my friends in helping convert Dartmouth's honors second-term CS course from Scheme to Haskell.
05:48:25 <dons> cool
05:48:38 <arcatan> they should convert some of those java courses to haskell...
05:48:55 <mwc> That's why I never took a CSxxx course in my undergraduate career
05:48:56 <mwc> all Java.
05:49:02 <ekidd> Sadly, he's moving elsewhere, so he won't be teaching it himself. This is unfortunate, because he's an amazing teacher.
05:49:04 <mwc> or at least the first year ones were
05:49:04 <desp> dolio: I'm actually planning to move to .au; Brisbane, specifically.  would that be a good place to study CS?
05:49:09 <johnnowak> mwc: aye
05:49:10 <desp> err
05:49:14 <desp> s/dolio/dons/
05:49:29 * araujo `catch` dons 
05:49:34 <mwc> poor dolio, being vicitmized by all this do<tab> business
05:49:41 <dons> desp, hmm. not sure you'd get much FP there.
05:49:49 <ekidd> arcatan: Dartmouth's CS faculty have zero desire to run a trade school.
05:49:55 <ivanm> desp: what kind of CS?
05:50:01 <arcatan> :)
05:50:35 <desp> hmm.
05:50:39 <ivanm> desp: AFAIK, not much FP is done here in Brisbane...
05:50:43 <mwc> Is there anybody here who's done an academic education and then transferred successfully to something else?
05:50:48 <ivanm> but there are a couple of reaserchers doing stuff
05:50:50 <desp> ivanm: that's a good question
05:50:58 <mwc> I'm thinking I want to bail on the university lifestyle after my M.Math.
05:51:13 <ivanm> desp: www.itee.uq.edu.au/~paul -- I might be doing a special topics course with him
05:51:33 <desp> ivanm: I've done 2 years of a CS program with a strong theoretical background, which I'm not very good at... :)
05:51:44 <ivanm> lol
05:52:02 <ivanm> CS isn't as big here as opposed to IT/SE (more practical)
05:52:19 <desp> aha
05:52:28 <ekidd> The Dartmouth CS curriculum is about a 50/50 split between theory and implementation.  They expect students to be able to do theory, but also to be able to write non-trivial software.
05:52:29 <ekidd> It's a very nice program, but they are weak on the languages front.
05:52:40 <ivanm> desp: ask triplah_, he's at QUT
05:52:46 * QtPlatypus was under the impression that uq was very much a java shop.
05:52:47 <desp> cool, thanks
05:53:28 <ivanm> QtPlatypus: it is....
05:53:38 <ivanm> but they now use Scheme for first year
05:53:48 <ivanm> with a bit more C emphasis (which I skipped)
05:54:44 <desp> I do have one pressing question regarding QLD
05:54:45 <ekidd> Argh. Don't get me started on Java schools. Spolsky is right--too many good universities want to dumb down CS into a trade school.
05:55:24 <desp> is there much of a spider problem? :)
05:55:30 <ivanm> desp: not really ;-)
05:55:59 <ekidd> If your goal is to have _everyone_ pass first- and second-term CS, what do you do when it's time to write proofs?
05:56:06 <ivanm> ekidd: *nod*... I don't know what its like overseas, but here in Australia academics (particularly in IT/CS) are being made redundant left, right and centre
05:56:33 <desp> ekidd: my school drops about 66% of students during the first year
05:56:35 <ivanm> ekidd: lol... not much proofs required for me in my degree... most I have to do is for the software specification subject using the B method
05:56:53 <desp> ekidd: because of the proofs, mostly
05:57:14 <desp> which is a silly way of putting it, actually
05:57:33 <desp> because of the heavy reliance on abstract mathematics
05:57:43 <ekidd> The sad part is that anyone who gets a trade-school-type CS degree will have their career fed to the woodchipper of globalization in no time flat.
05:59:40 <mwc> ekidd, sic transit gloria mundi?
06:00:13 <mwc> I find myself kind of disturbed by the decline of intellectualism in the west.
06:00:56 <ekidd> Getting really, really good at this year's Microsoft or Sun API is a mug's game. If you get even a year or two behind, you're unemployable.
06:00:58 <ivanm> duh, what does intelle-what mean? ;-)
06:01:13 <mwc> I hadn't really thought about it in terms of the trade-school-izatoin of universities
06:01:36 <ivanm> ekidd: at Microsofts Tech Ed in Brisbane last year, a PC magazine reporter managed to get an MCSE without knowing a thing ;-)
06:01:57 <ekidd> mwc: As far as I can tell, there's huge pressure in many universities to keep department enrollment numbers up.
06:02:11 <mwc> Jsut more in the dumbing down of them. Complex analysis is a 3rd year course now. I took a Scientific Programming class at an honors-senior level and it was a total joke. Nothing but a semester-long C++ tutorial
06:02:35 <ivanm> mwc: I did complex analysis in 3rd year last year...
06:02:46 <ivanm> and scientific programming in 3rd year, but it was a joke...
06:02:49 <QtPlatypus> mwc: I am as well, I also worry about the decline of enlightment thinking and the rise of irrationalize,.
06:03:00 <ivanm> in terms of content that is, since it was mainly a projects course
06:03:02 <mmso> my math is not quite good, but if I wanna start to learn haskell, is that possible?
06:03:07 <ivanm> and most mathematicians can't program ;-)
06:03:16 <ekidd> mmso: Absolutely!
06:04:40 <mmso> ekidd: not sure where should I start. it seems evolve a lot math.
06:04:53 <ekidd> mmso: What's your background?
06:04:58 <mwc> ivanm, hahaha, it's true. in my honours Finite Element method class, everybody is barely getting things to run by trial and error in matlab. There's another guy in that class who has a prior undergraduate degree in comp sci who's doing his work in C++ (he welshed on our bet that he could do the whole class in Scheme.) I wrote a complete LODE solver in Haskell.
06:05:13 <ekidd> I might be able to point you in a direction that works better for you.
06:05:24 <mwc> btw, STUArray is a pretty nice way of doing numerical computations
06:05:39 <mmso> ekidd: mostly web developer, and no math background
06:05:45 <desp> mwc: what level is "honours"? 4th, 5th year?
06:05:45 <QtPlatypus> LODE?
06:06:06 <QtPlatypus> +1 more year then Bach.
06:06:09 <ivanm> mwc: *nod*... I learnt Fortran for the subject, so that I could use the supercomputers (was planning on learning parellization, but ran out of time), and there were a few other people with IT/CS/SE background
06:06:12 <mwc> 4th year undergrad
06:06:15 <ivanm> but most people struggled with matlab
06:06:16 <desp> ah
06:06:26 <mmso> mmso: I know php and python, some elisp for emacs.
06:06:30 <mwc> QtPlatypus, Linear Ordinary Differential equations, Boundary value problems
06:06:37 <ivanm> desp: in honours, you do a thesis, etc... similar to masters
06:06:59 <QtPlatypus> mwc: I have a book on that that I've never read.
06:07:02 <mwc> you have a wire supporting some loading W(x) of stuff hanging from it, and it's attached at given points to the walls,
06:07:09 <ivanm> mwc: I'm actually tutoring that same subject atm... and we've got an exchange student from germany whose never done any programming before
06:07:18 <mwc> ivanm, FEM?
06:07:24 <ivanm> and they're also learning how to use unix ;-)
06:07:26 <desp> we usually do masters directly, in a 5 year monolithic block
06:07:27 <ekidd> Dartmouth has one project class--it's roughly the 4th in the major, right after "discrete math for CS majors". It's actually quite impressive: Four-person teams with the talented students spread out, a non-trivial project, and they change the spec with one week to go right (before finals start). The intended lesson: Smart people, version control and clean code are all good things.
06:07:41 <ekidd> But the next course after that is heavy theory again.
06:07:49 <ivanm> mwc: FEM? what's FEM?
06:07:54 <ekidd> mmso: Let me think for a minute.
06:07:57 <mwc> ivanm, finite element method
06:08:10 <mwc> ivanm, Galerkin, Rayleigh-Ritz methods?
06:08:17 <ivanm> mwc: never heard of them...
06:08:30 <mwc> oh, wondered what you were tutoring
06:08:42 <ivanm> its scientific computing
06:08:51 <mmso> ekidd: ok, I'd like to know your opinion. I'm willing to learn some math if needed.
06:08:53 <mwc> ah
06:08:56 <ivanm> I'm actually tutoring in the "this is how to use unix and program" sense than the maths ;-)
06:08:57 <ekidd> mmso: Do you want to do web stuff in Haskell, or are you just looking for interesting projects to work on?
06:09:08 <mwc> ivanm, yeah, the prof here taught the course using VC++ 2003
06:09:37 <mwc> I almost failed because he couldn't get my code to compile (GCC 4.1.1, -Wall, strict)
06:09:50 <ivanm> mwc: *shudder*... the subject was a project-based one, so the lectures were based on briefly mentioning various topics and computations, with implementation up to us
06:09:55 <ekidd> mmso: http://programming.reddit.com/info/1aomv/comments
06:09:57 <lambdabot> Title: Ask Reddit: There are tons of Haskell tutorials online. Which ones have you foun ...
06:10:24 <mwc> I think the mistake was the appl. math dept got an adjunct prof of statistics to teach it
06:10:25 <ivanm> mwc: lol... I had problems getting Landau's Fortran and C codes working... because the local copy at uni was all corrupted ;-)
06:10:27 <mmso> ekidd: mostly just wanna learn more stuff, and I'm seeking some stuff which can improve my programming
06:10:27 <ekidd> http://programming.reddit.com/info/11ghr/comments
06:10:29 <lambdabot> Title: Ask Reddit: What is the best introductory book on Haskell? (reddit.com)
06:10:34 <tuukkah> @pl \xs -> listToMaybe $  concatMaybes xs
06:10:34 <lambdabot> listToMaybe . concatMaybes
06:10:44 <tuukkah> nothing better than that?
06:11:38 <ekidd> mmso: The math tends to show up in more advanced Haskell, not right at the beginning.
06:12:18 <ekidd> You can either avoid the math entirely, or learn it gradually if you prefer.
06:12:49 <mmso> ekidd: ok, cool.
06:14:06 <ekidd> mmso: I hear nice things about "The Haskell School of Expression", but I haven't read it yet. There's also a couple of books and tutorials which start from almost zero knowledge of programming, but I don't know them well-enough to recommend one in particular.
06:14:48 <tuukkah> @pl \xs -> listToMaybe $  catMaybes xs
06:14:48 <lambdabot> listToMaybe . catMaybes
06:15:02 <ekidd> mmso: Have you experimented with 'map' and 'filter' (or list comprehensions) in any of the languages that you know?
06:15:10 <tcr> Is there a comprehensive test suite for haskell itself available? (Basically a suite that includes tests for every language feature) I looked into the source distributions of Hugs and Ghc already but couldn't find any such thing.
06:15:23 <mmso> ekidd: ekidd, python has them.
06:16:08 <ekidd> mmso: Haskell has a similar "flavor", just more concentrated. :-)
06:17:21 <ekidd> mmso: The hardest part, for some people, is letting go of what they already know for at least a little while...
06:17:41 <pejo> mmso, (I'll jump in in the middle of the convo) first course I took in uni was Haskell. I think it made me a better programmer - and I knew no math/previous fp at the time.
06:17:58 <mmso> ekidd: ekidd, I heard that every variable in haskell is constant is that ture? and is there loops in haskell?
06:18:32 <ekidd> mmso: Yes(*), and sort of. :-)
06:18:55 <int-e> mmso: a value once created will never change. but you can create as many new values as you like. loops can be coded as recursion.
06:18:56 <mmso> pejo: cools, sounds like I may also could pick haskell.
06:19:34 <ekidd> (*) Actually, there are things which you can use as mutable variables if you really need them. But it's best to try to do as much as possible without them.
06:20:15 <int-e> > let loop i s = if i == 0 then s else loop (i-1) (i+s) in loop 15 0 -- add numbers 15 to 1.
06:20:16 <lambdabot>  120
06:20:37 <mauke> > sum [1 .. 15]
06:20:38 <lambdabot>  120
06:20:50 <int-e> right, and don't forget lists which make this much more convenient :)
06:21:20 <mmso> so list is also important in haskell right? just like lisp?
06:22:02 <int-e> many loops get turned into list processing in haskell, not into explicit recursion. that makes them pretty important, yes
06:22:21 <ekidd> mmso: It's probably easiest to learn Haskell on its own terms first--focusing on recursion and "pure" computations--and then move onto IO second. But some people prefer to do it the other way around.
06:23:39 <mmso> ekidd: there is some stuff like "dotimes" or "loop" in emacs lisp, is there one in Haskell? or I should use recursive all the way?
06:24:16 <mauke> mmso: depends on what you want the loop to do
06:24:34 <ekidd> OK, I'm back. IRC client problem...
06:24:38 <mmso> mauke: hmm.... simple loop?
06:24:45 <mauke> mmso: there are no simple loops
06:25:04 <Saizan> mmso: you rarely write the recursion explicitly, you use an higher order function instead
06:25:16 <mmso> mauke: oh. :( sorry seems a stupid question.
06:25:24 <ekidd> mmso: In Haskell, you use things like foldr more often.
06:25:28 <ekidd> mmso: No problem!
06:25:34 <mauke> the problem is, most loops rely on side effects in some way
06:25:47 <ekidd> > foldr (+) 0 [1,2,3,4]
06:25:48 <lambdabot>  10
06:25:53 <mauke> like changing variables that occur in the loop condition
06:27:17 <ekidd> mmso: It's a surprisingly different style at times--Haskell encourages you to learn a different way of looking at the world.
06:27:40 <mmso> what's the 'foldr' means? do the plus function one by one? sorry if that heard very stupid.
06:27:42 <mwc> > foldl (flip ($)) 0 [(+i) | i <- [1..100]]
06:27:43 <lambdabot>  5050
06:28:02 <mwc> mmso, foldl and foldr combine elements across the list using some function
06:28:07 <ekidd> mmso: Which is really cool if you want to learn something new, and a bit of pain if you just want to write an IRC client right away!
06:28:09 <mwc> they do it from the left, or right
06:28:38 <mauke> mmso: you can think of it as inserting an operator between list elements
06:28:38 <mwc> > foldl (+) 0 [1..100]
06:28:39 <lambdabot>  5050
06:28:47 <mwc> > foldl (*) 0 [1..100]
06:28:48 <lambdabot>  0
06:28:52 <ekidd> mmso: foldr (+) 0 [1,2,3] is the same as 1+2+3+0.
06:28:52 <mwc> > foldl (-) 0 [1..100]
06:28:53 <lambdabot>  -5050
06:29:21 <ekidd> foldl is the same as 0+1+2+3.
06:29:35 <mmso> ohoh cool, thanks the explain.
06:30:22 <mmso> I'll try to get ghc installed and play haskell a bit next week.
06:30:23 <ekidd> The idea is that you replace the loop with a procedure for combining the elements of a list. It's very high level! (And a bit of a surprise at first.)
06:30:58 <mwc> mmso, one big help is the type system. it's really helpful for finding functions you need. For instance, I need a function to sort lists. well, it takes a list and gives one back, so its type is [a] -> [a].
06:31:05 <mwc> @hoogle [a] -> [a]
06:31:06 <lambdabot> Prelude.cycle :: [a] -> [a]
06:31:06 <lambdabot> Prelude.init :: [a] -> [a]
06:31:06 <lambdabot> Prelude.reverse :: [a] -> [a]
06:31:19 <mwc> too many results. Of course, sorting needs an ordering
06:31:23 <mwc> @hoogle Ord a => [a] -> [a]
06:31:24 <lambdabot> List.sort :: Ord a => [a] -> [a]
06:31:24 <lambdabot> Data.Graph.Inductive.Internal.Heap.heapsort :: Ord a => [a] -> [a]
06:31:24 <lambdabot> List.insert :: Ord a => a -> [a] -> [a]
06:31:31 <mmso> mwc: I'm not sure if I will like type system, is that really that great?
06:31:38 <ekidd> > sort [3,4,7,1,5]
06:31:39 <lambdabot>  [1,3,4,5,7]
06:31:52 <mwc> yeah, it's vital once you get used to letting it work for you.
06:31:57 <nominolo> mmso: it helps in a pure language
06:31:59 <mwc> you can fight it and be totally miserable
06:32:11 <ekidd> mmso: Haskell's type system is more useful than a type system would be in Python.
06:32:25 <mauke> > sort "the quick brown fox jumped over the strict dog"
06:32:26 <lambdabot>  "        bccddeeeefghhiijkmnoooopqrrrsttttuuvwx"
06:32:46 <ekidd> mmso: Because Haskell encourages you to work at a higher level of abstraction, it's a bit easier to get confused sometimes.
06:32:49 <mwc> @hoogle Eq a => [a] -> [a]
06:32:50 <lambdabot> List.nub :: Eq a => [a] -> [a]
06:32:50 <lambdabot> List.delete :: Eq a => a -> [a] -> [a]
06:32:50 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
06:33:03 <ekidd> mmso: So you need the type system more than you would in an OO language.
06:33:11 * ekidd is also a fanatic Ruby programmer
06:33:17 <mwc> > nub . sort "the quick brown fox jumped over the strict dog."
06:33:17 <lambdabot>  Couldn't match expected type `a -> [a1]'
06:33:25 <mwc> > nub . sort $ "the quick brown fox jumped over the strict dog."
06:33:26 <lambdabot>  " .bcdefghijkmnopqrstuvwx"
06:33:46 <mmso> ekidd: ok I didn't get it yet, but I think you should be right and I'll try to figure it out next couple month or week.
06:33:47 <nominolo> @doc nub
06:33:47 <lambdabot> nub not available
06:34:00 <nominolo> @src nub
06:34:01 <lambdabot> nub = nubBy (==)
06:34:08 <mwc> @doc nubBy
06:34:08 <nominolo> @src nubBy
06:34:08 <lambdabot> nubBy not available
06:34:09 <lambdabot> nubBy eq []             =  []
06:34:09 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:34:17 <ekidd> mmso: I like to learn totally new ways to program, even if they're a bit mind-bending at first! :-)
06:34:43 <mwc> ewww. nubBy is O(n^2)
06:35:19 <nominolo> mwc: no you can fuse it
06:35:27 <mwc> true
06:35:52 <nominolo> but certainly some memory overhead
06:35:57 <int-e> > map head . group . sort $ "the quick brown fox jumped over the strict dog."
06:35:58 <lambdabot>  " .bcdefghijkmnopqrstuvwx"
06:36:13 <mwc> @src group
06:36:14 <lambdabot> group = groupBy (==)
06:36:19 <mwc> @src groupBy
06:36:19 <lambdabot> groupBy _  []       =  []
06:36:19 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
06:36:19 <lambdabot>     where (ys,zs) = span (eq x) xs
06:36:33 <ekidd> mmso: Please don't hesitate to ask for help on #haskell as you go! The people here can point you to tutorials, instructions on doing IO, or whatever you're interested in at any given point.
06:36:41 <mwc> int-e, nice
06:37:31 <mwc> mmso, indeed, #haskell really exists to teach haskell and talk to fellow devs
06:38:08 <ekidd> mmso: Haskell is mostly interesting because it teaches you a strange new way to think. But that does mean the learning process may be a bit strange at times... :-)
06:38:19 <mmso> thanks you're nice guys I've ever see. :)
06:38:43 * ekidd didn't really learn Haskell until about 6 months ago
06:40:00 <int-e> mwc: well-known. there's a current thread on the haskell libraries mailing list about it, starting at http://haskell.org/pipermail/libraries/2007-March/007029.html
06:40:01 <lambdabot> Title: Proposal: Add Data.List.sortNub and sortNubBy
06:40:18 <mmso> I think I'm going to try some haskell examples next week. is there something 'practical' can practice?
06:41:19 <nominolo> i think dons wrote something up a while ago
06:41:24 * mwc fires up pan
06:41:26 <mmso> I like to code, try and think, just reading books bored me sometimes.
06:41:45 <ekidd> nominolo: Oh, yeah! Those were cool. Let me look for some links.
06:45:30 * nominolo just realized that he should finally get started with his SoC application
06:45:56 <nominolo> so is there any list of _recommended_ projects, which are likely to be accepted?
06:48:27 <pejo> Regarding the need for a type system discussion earlier - all languages need a type system, but it needs to stay out of the way when programs are correct. :P
06:49:08 <Pastorn> i want a function like words, but i want to decide the characters it splits at myself...
06:49:46 <rahikkala> @src words
06:49:46 <lambdabot> words s = case dropWhile isSpace s of
06:49:46 <lambdabot>     "" -> []
06:49:46 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
06:49:53 <Cheery> How do I compile HSDL -program?
06:49:58 <ekidd> mmso: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16#programming-haskell-intro
06:50:00 <lambdabot> Title: Haskell hacking, http://tinyurl.com/yz4kdc
06:50:17 <mmso> ekidd: cool
06:50:19 <Pastorn> @hoogle String -> String -> [String]
06:50:20 <lambdabot> No matches, try a more general search
06:50:33 <ekidd> That's an especially nice introductory tutorial by dons, who lurks around here quite often.
06:50:49 <ekidd> There's several more pieces in the series, and they're all quite good.
06:51:16 <ekidd> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/17#programming-haskell-part-2
06:51:17 <lambdabot> Title: Haskell hacking, http://tinyurl.com/y852um
06:51:37 <nominolo> ekidd: did you write the SoC-proposal for the LLVM backend?
06:51:41 <ekidd> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/18#ph-3
06:51:41 <lambdabot> Title: Haskell hacking
06:51:52 <nominolo> oh, heh, no
06:51:55 <mmso> ekidd: nice
06:51:56 <ekidd> nominolo: No, I just put my name down as an interested mentor.
06:52:30 <nominolo> ekidd: do you know if LLVM is JIT or statically compiled?
06:52:32 <ekidd> mmso: Those three are nice because they mix some real-world IO with good Haskell style very early on. Most tutorials focus on one or the others.
06:52:43 <ekidd> nominolo: Either or both. :-)
06:53:25 <ekidd> LLVM is roughly competitive with GCC (modulo a few constructs that it doesn't fully optimize yet), and it's based on a small, strongly-typed assembly language.
06:53:30 <mmso> ekidd: cool I'll try read these this week. and it looks like approachable.
06:53:47 <nominolo> ekidd: so, what would be the actual advantage over gcc?
06:53:52 <ekidd> mmso: Good luck, and don't hesitate to hang out on #haskell and ask for clarifications!
06:54:10 <ekidd> nominolo: Well, GCC doesn't have a sane, publically-targettable intermediate language.
06:54:21 <ekidd> Whereas LLVM is a library you can link into your app.
06:54:55 <nominolo> so you mean for embedded haskell?
06:55:23 <ekidd> Plus, all put the final stages of compilation are in the same, strongly-typed assembly language, so you can dump out half-optimized code, and read it with all the standard tools.
06:56:08 <Cheery> there comes things like:
06:56:10 <Cheery> Test.o: In function `s2dU_info': undefined reference to `SDLzm0zi4zi0_GraphicsziUIziSDLziGeneral_withInit_closure'
06:56:10 <Cheery> Test.o: In function `Main_display_srt': undefined reference to `SDLzm0zi4zi0_GraphicsziUIziSDLziTypes_surfaceGetHeight_closure'
06:56:11 <ekidd> nominolo: Well, LLVM bindings would make it really easy for Haskell programs to generate optimized machine code on the fly--imagine a regex engine which compiled right down to the bare metal.
06:56:11 <nominolo> well, but it wouldn't be haskell core, but translated into risc-like structure
06:57:06 <Cheery> or wait, nvm.
06:57:13 <mwc> Hahaha, funniest ever microsoft demo... http://youtube.com/watch?v=KyLqUf4cdwc
06:57:19 <mwc> may actually be better than PnP BSOD
06:57:19 <ekidd> nominolo: Personally, I see more value for making LLVM available as a Haskell library than I do in porting the GHC compiler backend to target it.
06:57:25 <nominolo> ekidd: it sounds very interesting to me as i want to get more into ghc-hacking, but i'd like to find really good motivation to make sure it gets accepted
06:57:34 <ekidd> But the latter would be a very nice stress test.
06:57:43 <nominolo> ah
06:57:49 <nominolo> interesting
06:58:15 <nominolo> *THAT'S* a good idea
06:58:20 <nominolo> and seems easier
06:58:31 <ekidd> nominolo: I'm thinking about writing DSLs in Haskell and compiling them down to bare metal at runtime!
06:58:36 <nominolo> JIT for Haskell DSELs :)
06:58:44 <ekidd> Exactly.
06:58:59 <nominolo> yay, that sounds great
06:59:06 <ekidd> It would be a bit like .NET's System.Reflection.Emit.
06:59:18 * nominolo goes and writes SoC proposal
06:59:39 <ekidd> nominolo: But I'm not the one who decides which applications get funded, so you'll need to consult elsewhere for that! :-)
06:59:52 <nominolo> ekidd: yes, i know
07:00:02 <earthy> sounds much like what Pan did.
07:00:02 <nominolo> any idea where "elsewhere" could be?
07:00:45 <ekidd> I bet dons could steer you in the right direction... He seems to know everything that's going on in the Haskell world, and I've heard him bugging people to mentor.
07:00:49 <nominolo> earthy: yes
07:01:11 <ekidd> nominolo: See also the assembly-language DSL in issue 6 of The Monad Reader.
07:01:21 <ekidd> ?go The Monad Reader Issue 6
07:01:23 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
07:01:23 <lambdabot> Title: The Monad.Reader - HaskellWiki
07:01:54 <earthy> but, yeah, a good cross-platform lib for generating and then calling low level code would be great
07:02:03 <nominolo> ekidd: yes, raed it.  i already did something similar for a course project, but i didn't know about monad fixpoints back then
07:02:15 <ekidd> nominolo: It (ab)uses MonadFix to make a very nice high-level API for generating assembly.
07:03:39 <nominolo> are monad fixpoints mentioned in some haskell learning book?
07:04:02 <ekidd> nominolo: Hah. :-)
07:04:02 <nominolo> i never read one, and i wonder if i had known about them if i had
07:04:39 <ekidd> nominolo: Most of the more advanced Haskell techniques are in research literature (though the papers tend to be very accessible).
07:04:45 <ekidd> Let me look...
07:04:53 <nominolo> yes, i read the paper
07:05:52 <ekidd> nominolo: So you're ahead of the game, then. :-)
07:06:05 <nominolo> but the thing is, you have to know about it when you see the problem
07:06:23 <ekidd> nominolo: There is that.
07:06:31 <nominolo> and i wonder if i could have known before
07:06:52 <ekidd> nominolo: Well, the toolset provided by Haskell is gigantic.
07:07:25 <ekidd> nominolo: I'd love to see a textbook which provided a good intuition for when to use of the more exotic techniques, but it would probably be huge.
07:07:33 <nominolo> yep, that's why a "design pattern" style book for haskell would be nice
07:07:58 <nominolo> ekidd: yes, because you also have to _understand_ what you're doing
07:08:16 <ekidd> nominolo: Or a series of books, each of which focused on one aspect.
07:08:39 <ekidd> For example, data structures are already explained marvellously in "Purely Functional Data Structures".
07:09:13 <pejo> ekidd, we'd all love such a series. A functional compilers book would be great too.
07:09:16 <nominolo> ok, i guess i have to read it then :)
07:09:26 <ekidd> I could write a short book on strange variations of the probability monad. :-)
07:11:04 <nominolo> maybe just a book that gives a survey about the available papers, with focus on which design problems this technique might solve
07:11:16 <Uncountable> in this page http://people.mandriva.com/~prigaux//language-study/syntax-across-languages.html they say Haskell (and OCaml) constants have regexp [_A-Z][_a-zA-Z0-9']*
07:11:18 <lambdabot> Title: syntax across languages, http://tinyurl.com/2p54wk
07:11:22 <Uncountable> i suppose they mean constructors without arguments?
07:11:26 <ekidd> nominolo: That's actually an excellent idea. Are there any precedents for a book like that?
07:11:46 <nominolo> not that i know of
07:13:02 <pejo> nominolo, isn't it largely the job of a book to unify the notation and put the pieces together?
07:13:31 <nominolo> pejo: well, yes.  but it would be huge if it were to cover everything, wouldn't it?
07:13:42 * merus would like to grok the probability monad.
07:14:16 <nominolo> i guess it should be more like an introducion and a big catalogue
07:14:36 <nominolo> probably it should also be an online-catalogue
07:14:52 <pejo> nominolo, actually I'm not sure about which book we're talking now. Which one is it - the probability monad, the functional compiler, or something else?
07:15:22 <nominolo> pejo: The "Designing Haskell Programs" book ;)
07:17:22 <nominolo> Or maybe just "Practical Haskell" where theory is only covered where necessary and the main focus is on design problems and lot's of examples of use.
07:17:46 <nominolo> but i guess most of the haskell books are already pretty much like this
07:18:57 * nominolo better stops talking now, because he wouldn't be the right candidate for writing this stuff right now, anyways
07:19:33 <pejo> nominolo, ok, I'll make another statement then - on top of that unification of notation and similar - isn't it the author's job to acutally leave out the irrelevant parts too, in order to avoid having too much contents? :P
07:20:17 <ekidd> merus: http://www.randomhacks.net/articles/tag/Probability
07:20:20 <lambdabot> Title: Random Hacks
07:20:54 <nominolo> pejo: i completely agree.  we're just wondering if this can be done reasonably given the huge number of design techniques Haskell offers
07:21:08 <nominolo> pejo: or, if so, in which form
07:21:30 <ekidd> nominolo: Well, the core techniques are getting pretty well-documented at this point.
07:21:53 <ekidd> But you're right--it would be nice to have someplace that discussed GADTs, MonadFix, and all the other exotica.
07:21:56 <nominolo> ekidd: but in blog-form :)
07:22:12 * merus wonders why his furl is so slow as of late
07:22:55 <ekidd> It's true, you can learn a lot just by reading Planet Haskell for a while...
07:25:01 <nominolo> @hoogle ioref
07:25:02 <lambdabot> Data.IORef :: module
07:25:02 <lambdabot> Data.IORef.IORef :: data IORef a
07:25:02 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
07:25:22 <ekidd> Does anybody have any practical applications of category theory that they're particularly fond of? I'm working on a tutorial, and early readers keep asking for some applied topics...
07:25:43 <ekidd> (I will, of course, give thanks in the final tutorial for suggestions.)
07:26:18 <ekidd> I know of the neat work on implicit data-type conversions in the presence of overloaded operators.
07:28:42 <pejo> ekidd, did you use to have the nick 'emk'?
07:29:36 <ekidd> pejo: Yeah, but it looks like it fell out of registration years ago and somebody else reregistered it a couple years back. I hadn't noticed until last night.
07:29:50 <ekidd> So I'm ekidd for the moment.
07:31:07 <the_dormant> ekidd: where can I find more about implicit data-type conversion?
07:31:52 <ekidd> the_dormant: There's a nice section in Pierce's category theory book. I don't know the original paper right off the top of my head, but I could track it down if you wanted.
07:32:59 <nominolo> ekidd: is that book by pierce good?
07:33:13 * nominolo always wanted to have a decent introduction to CT
07:34:04 <Eelis> oh how i wish Haskell supported implicit conversions
07:34:17 <ekidd> nominolo: It's not as amazing at his TaPL, but it's not bad, either--basically just his notes on learning category theory, with a few CS examples and applications.
07:35:51 <Eelis> > (3 :: Int) + 2.0
07:35:51 <nominolo> hm, one amazon reader recommends [Lawvere and Schanuel] (as intro) or [Mac Lane] (for mathematicians).  have you read either of those?
07:35:58 <lambdabot>   add an instance declaration for (Fractional Int)
07:36:07 <Eelis> pure embarrassment
07:36:48 <ekidd> nominolo: Did you get my /msg?
07:37:04 <nominolo> yep
07:38:10 <xerox> > (fromIntegral (3 :: Int) + 2.0, (3 :: Int) + round 2.0) -- Eelis
07:38:11 <lambdabot>  (5.0,5)
07:38:40 <Eelis> xerox: i know.
07:39:04 <xerox> aye.
07:45:50 * dmhouse is searching for a Google Summer of Code project
07:46:09 <halassocracy> http://www.cs.man.ac.uk/~david/categories/book/ <-- book on category theory using ml (i haven't read it, but it looks pretty good)
07:46:11 <lambdabot> Title: Index of /~david/categories/book
07:48:10 <sorear> @where soc
07:48:11 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
07:48:42 <sorear> @suers
07:48:43 <lambdabot> Maximum users seen in #haskell: 336, currently: 305 (90.8%), active: 34 (11.1%)
07:49:28 <desp> suers? hah
08:01:00 <orbitz> is ther ea common idiom for printing out every element ofa list, like a foldl?
08:01:24 <Cale> mapM_ print
08:01:26 <Botje> mapM_ print
08:01:28 <Botje> damn!
08:01:37 <mauke> @quote stereo
08:01:37 <Cale> hehe
08:01:37 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
08:01:45 <orbitz> i want to d oa bit of work on the element first,then print
08:01:58 <mauke> mapM_ (print . work)
08:01:58 <Botje> mapM_ (print . something)
08:02:02 <Botje> mhjdwflkjvhd
08:02:02 <Botje> :(
08:02:10 <orbitz> figured as much, thank you
08:02:24 <mauke> putStr . join
08:02:57 <sorear> wow, Cale
08:03:09 <sorear> you've become by far the most popular quote
08:03:21 * sorear should run statistics on this
08:05:27 <dmhouse> Okay, ideas time. What's the Haskell library you've always wanted?
08:06:22 <orbitz> dmhouse: one that solves world hunger
08:06:26 <Botje> halting problem solver
08:06:36 <sorear> I keep having ideas to *write* libraries, never to use them :(
08:06:45 <iany> Help! my program keeps eating all my memory, and I don't want it to!
08:06:46 <Botje> dmhouse: some kind of templating library, perhaps?
08:06:52 <Botje> iany: poison your memory!
08:06:54 * sorear mg ~/TODO
08:06:59 <hpaste>  iany pasted "freqtest eats all my memory" at http://hpaste.org/1025
08:06:59 <orbitz> isn't htere arleayd a templating lib?
08:07:11 <Botje> a type-safe one?
08:07:18 <Botje> like tmoertel defined?
08:07:26 <orbitz> i don't know
08:07:30 <orbitz> i thought spj made one
08:07:35 <orbitz> i haven't looked at it touhg
08:08:06 <qwr> iany: kill -9 it
08:08:15 <iany> where am I going wrong with this? I'm not very good at working out this strictness stuff?
08:08:24 <sorear> iany: you need to force the counts
08:08:39 <iany> qwr: oh no, it's ok from that point of view because it just gets to 2GB and falls over
08:08:41 <sorear> iany: basically, after 10 chars, your map looks like:
08:09:01 <sorear> { 0 := (1+(1+(1+(1+(1+(1+(1+(1+(1+(1)))))))))) }
08:09:13 <sorear> iany: each 1+ takes 20+ bytes of ram
08:09:38 <iany> so I need to stick a `seq` somewhere? Where?
08:10:22 <sorear> @source Data.IntMap
08:10:22 <lambdabot> http://darcs.haskell.org/packages/base/Data/IntMap.hs
08:11:33 <sorear> iany: it appears insertWith makes it impossible to get proper strictness :(
08:12:34 <iany> it did occur to me that it didn't need to be a map: since the key is a Word8 (really) then an array would be fine, but I don't understand how mutable structures work in a functional world
08:12:42 <Botje> for the short while i've been here, cale's stereo quote has been said 34 times
08:12:45 <emu> maybe lookup (ord c) m `seq` insertWith...
08:12:49 <Botje> followed by the vending machine quote by JohnMeacham
08:13:14 <emu> yea this looks like a good application of DiffArrays
08:13:50 <iany> emu: oh, that wouldn't have the same problem? If not, I'll give it a go
08:13:59 <emu> DiffUArray even
08:14:42 <sorear> iany: Actually, the best approach is regular immutable arrays, with accum
08:14:59 <emu> hm, couldn't the function to insertWith use seq?
08:15:39 <sorear> emu: no
08:15:53 <sorear> emu: since the whole func is being delayed
08:16:06 <sorear> seq is not immune to laziness
08:18:40 <iany> well thanks all, I'll see how it goes with those suggestions...
08:18:51 <hpaste>  sorear annotated "freqtest eats all my memory" with "with UArray and accum" at http://hpaste.org/1025#a1
08:19:20 <sorear> that should use finite ram
08:19:41 <sorear> granted, it remains to be seen how well ghc fuses that pipeline...
08:20:19 <iany> finite is good! I'll give it a go... sorry this may take a while as I'm on my backup machine for hysterical raisins
08:20:43 <hpaste>  sorear annotated "freqtest eats all my memory" with "fix typo.." at http://hpaste.org/1025#a2
08:21:35 <sorear> if you're lucky, there is a very good chance this will turn into the standard C histogram after ghc munges it
08:21:51 <dmhouse> Doesn't casting to lists and back eat up all of ByteString's performance advantages?
08:22:32 <sorear> dmhouse: not if it fuses
08:24:34 <sorear> stream fusion should be able t handle this one
08:27:34 <iany> hmm, well it doesn't eat all the memory
08:28:39 <sorear> looking at the core, it didn't fuse. oh well.
08:28:51 <sorear> at least it still runs in O(1) memory
08:29:33 <iany> should I be compiling this with anything other than -O? (GHC 6.6)
08:30:04 <iany> ooh, it's finished!
08:30:19 <sorear> -O2 may help
08:30:31 <iany> Shame my Delphi program takes about 1 second to do the same
08:30:32 <sorear> but the difference is fairly small
08:30:43 <iany> (albeit on a faster machine)
08:31:02 <bluestorm_> hum
08:31:08 <sorear> how highlevel is delphi?  imperative, with unboxed arrays?
08:31:17 <iany> yeah
08:31:22 <bluestorm_> i'm looking for a good and not-too-difficult introduction to category theory
08:31:37 <iany> actually the version that takes one second reads in 64k chunks
08:31:46 <bluestorm_> (i'm nearly in a first year of university)
08:31:56 <sorear> oh.  lazy bytestring reads in 16k chunks
08:32:01 <bluestorm_> i found http://www.math.upatras.gr/~cdrossos/Docs/B-W-LectureNotes.pdf on haskell.org
08:32:22 <iany> sorear: naive Delphi textfiles and one character reads takes about 5 secs
08:32:24 <bluestorm_> do you think it would fit ? have another proposition ?
08:32:44 <sorear> iany: how many secs is the haskell soln?
08:33:19 <iany> sorear: I'd have to use the other machine for a fair comparison... hang on
08:33:44 <iany> sorear: the file's probably all in file cache, BTW
08:33:57 <sorear> iany: figures...
08:34:20 * sorear tries to write the fastest possible C hist
08:34:40 <iany> sorear: the woes of having 4GB on your home box, eh? :)
08:34:53 <sorear> <- 384m
08:35:27 <iany> sorear: yeah, but no Windows overhead (probably of about 384M)
08:35:53 <Botje> bluestorm_: 15:44 < halassocracy> http://www.cs.man.ac.uk/~david/categories/book/ <-- book on category theory using ml (i haven't read it, but it looks pretty good)
08:35:53 <lambdabot> Title: Index of /~david/categories/book
08:36:04 <Botje> no idea about the level though :)
08:36:14 <sorear> I remember back when windows ran on 8M boxes.
08:36:44 <bluestorm_> thanks Botje, i'll have a look
08:36:55 <sorear> that said, I've seen *current* versions of My Favorite OS do that...
08:37:32 <iany> sorear: I think they just use more memory to make you feel better about having bought that much. I remember seeing a box with 10MB in 1988 and thinking that was outrageous
08:38:09 <sorear> 384m is outrageous, except when I'm trying to run jhc
08:38:21 <sorear> normally, I use something like 30
08:39:04 <sorear> even the paragon of bloat, the infamous Eight Megabytes And Constantly Swapping, hasn't been able to dent my free ram.
08:39:55 <allbery_b> oddly, on my big desktop at work, xemacs is not the memory hog.  the primary Xvnc is.  (will have to restart it soon to free up RAM...)
08:40:01 <Botje> sorear: obviously. you have more than eight megabytes now ;)
08:41:00 <sorear> allbery_b: xrestop(1)
08:41:22 <sorear> allbery_b: X servers store a suprising amount of data on behalf of clients like emacs
08:41:29 <sorear> allbery_b: like megabytes of pictures
08:41:51 <allbery_b> actually, while Eight Megabytes And Constantly Swapping has kept its memory requirements fairly constant, everything else has been growing.  emacs is downright parsimonious compared to the fancy desktop environments and the applications that use them
08:42:14 <iany> sorear: oh, the answer was about 55 seconds!
08:42:15 <allbery_b> bleedin' *gaim* is one of the bigger memory hogs in my experience
08:42:18 <mauke> my fancy desktop environment is wmii + wmiirc!
08:42:25 <Botje> so is mine!
08:42:43 <allbery_b> sorear: actually I suspect it has a lot more to do witht he firefox than the emacs, as far as resource leaks are concerned
08:42:53 <Botje> I'd like to test thunk sometime, though
08:42:54 <mauke> I still need to figure out how 9p works so I don't need to shell out to wmiir
08:43:06 <sorear> Botje: it's called xmonad now
08:43:13 <Botje> :[
08:43:24 <sorear> yes, emacs is the biggest memory hog on my system now
08:43:36 <sorear> when I run ghci, it beats emacs
08:43:59 <sorear> iany: factor of 11 ain't bad for naive haskell code
08:46:16 <iany> sorear: well, the simple C.length one using lazy ByteString was about 1 second
08:46:46 <iany> sorear: sorry, that's testCLength in my original paste
08:47:12 <ekidd> citeseer thinks that Wadler had only 3 citations for "Theorems for Free!" That can't be right.
08:49:21 <allbery_b> sadly, xrestop wants an extension not supported by Xvnc
08:50:23 <sorear> iany: ok, my uber-C-histo takes 0.952s on a 157M file
08:51:05 <sorear> now testing the haskell...
08:51:49 <iany> anyone know where I can get a 'time' command for Windows: getting embarrassed with the vagueness of my numbers!
08:52:18 <sorear> otoh, you've got no shortage of large files :)
08:52:35 * sorear is running on the uncompressed apt-file database
08:53:06 <sorear> 1m54.383s
08:53:25 <iany> sorear: actually, that was one of few I was happy to put on this machine: no patient data in it. The biggest real file is getting on for 8GB
08:53:42 <sorear> > (60+54.383) / 0.952
08:53:43 <lambdabot>  120.15021008403363
08:53:55 <sorear> so, on my system, haskell is 120 times slower than C
08:54:36 <sorear> bah
08:54:39 <iany> sorear: sounds like the Delphi program's pretty competitive then! Anazing for an 8 year old pascal compiler
08:54:49 <sorear> I forgot to pass the -O option
08:54:52 <sorear> TO GCC
08:55:10 <sorear> so optimized haskell is 120 times faster than unoptimized C
08:55:13 <mauke> ITYM -O2
08:55:30 <sorear> er, that last statement was backward
08:55:32 <sorear> ITYM?
08:55:43 <mauke> I think you mean(t)
08:55:57 <sorear> heh.
08:56:09 <sorear> the gcc dead code eliminator did a very good job
08:56:24 <sorear> stefan@stefans:/tmp$ time ./a.out  < x
08:56:24 <sorear>  
08:56:24 <sorear> real    0m0.002s
08:56:24 <sorear> user    0m0.000s
08:56:27 <sorear> sys     0m0.000s
08:57:06 <Vq^> sorear: is that the time you are comparing against?
08:57:10 <ekidd> sorear: If Haskell is running any slower than a scripting language, there's definitely something wrong... Anything below 1/20th the speed of C is a sign of real trouble.
08:57:16 <ekidd> Anything below 1/4th the speed of C is a sign that a program is using String. :-)
08:57:54 <sorear> ah, fixed the dead code problem
08:58:07 <sorear> 0.480s from gcc -O2
08:58:29 <sorear> 1m54s from ghc-6.7 -O2
08:58:47 <sorear> > (60+54.383) / 0.480
08:58:48 <lambdabot>  238.2979166666667
08:58:50 <Vq^> thats quite a difference
08:58:55 <iany> That's what, 300MB/s? How near's that to memory bandwidth?
08:59:28 <iany> / me figures kids always know these sort of things
08:59:32 <sorear> iany: iirc memory bandwidth on this machine is 5000MB/s
08:59:41 <tcr> Is there a common abbreviation for the haskell98 report?
08:59:44 <iany> / me or not
08:59:57 <sorear> hm, that figure seems a bit big
09:00:15 <sorear> anyway, my c version is using mmap, so no checks for buffer exhaustion
09:02:02 <Igloo> tcr: "H98" probably has the meaning you want
09:02:17 <iany> sorear: what did the Haskell eventually look like? Your last paste didn't actually compile for me
09:02:19 <Igloo> Unless you really do want to refer to the actual document
09:02:40 <sorear> 0.360s C, word-at-a-time
09:02:53 <tcr> Igloo: I want refer to the standard document. The revised version, that is.
09:03:14 <hpaste>  sorear annotated "freqtest eats all my memory" with "working version" at http://hpaste.org/1025#a3
09:03:56 <iany> sorear: ta!
09:04:11 <sorear> ta?
09:04:41 <iany> sorear: "thank you"
09:04:43 <sorear> er, just noticed i'm still using the debug version of the module header.
09:04:53 <sorear> trying again with module Main(main) where
09:05:54 <sorear> no significant difference.
09:06:58 <iany> or "a Buddhist symbol of a horse bearing with three flaming jewels on its back"
09:08:18 <mauke> iany: is it in unicode?
09:09:54 <iany> mauke: heh! Like U+FDFA, you mean?
09:10:13 <mauke> hmm, that's not in my font
09:10:23 <mauke> ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM
09:11:02 <iany> mauke: voted character whose decomposition is most likely to cause pain 3 times running
09:11:16 <iany> mauke: (joking)
09:12:19 <mauke> FDFB and FDFD look also nice
09:12:46 <sorear> > 0x9C39000 / 0.360
09:12:48 <lambdabot>  4.550314666666667e8
09:13:11 <sorear> > show ((0x9C39000 / 0.360) / 1048576) ++ " MB/s (C)"
09:13:13 <lambdabot>  "433.9518229166667 MB/s (C)"
09:13:37 <sorear> > show ((0x9C39000 / 114.4) / 1048576) ++ " MB/s (C)"
09:13:39 <lambdabot>  "1.3655826595279719 MB/s (C)"
09:14:00 <sorear> obviously, the optimizer could use a little work :)
09:14:26 <sorear> (I can say this because dons already has a much better fusion system, which will be merged RSN)
09:31:44 <iany> sorear: much thanks for your efforts!
09:33:13 <iany> sorear: oh, does the fact that it's using O(1) memory with the UArray mean that it won't be much different with something that's explicitly mutable?
09:35:19 <sorear> right
09:35:42 <sorear> accumArray uses mutable arrays internally
09:35:58 <sorear> but if you use explicit mutability you can hand-fuse it
09:36:05 <sorear> but that's shootout stuff
09:38:58 <iany> goodness, it's snowing!
09:40:20 <iany> so is it immediately apparent which crack the performance is falling down, or does it need profiling and grovelling about to find that out?
09:40:55 <jacobian> it's snowing here too!
09:41:03 <pejo> sorear, is that the general fusion beyond bytestrings, described in that paper - or some other code?
09:41:22 <iany> and will dons new fusion stuff magically fix it
09:51:25 <samx> i'm trying to parse date strings, but all lost in looking through the hierarchial lib docs. I'd like to end up with something like Data.Time.Calendar.Day. Any suggestions on what modules/functions I should be using (short of building my own parser), that is
09:52:14 <ndm> samx: does read work at all?
09:52:39 <ndm> samx: although i'm not entirely sure there is any good parser for dates in the libraries - they tend to be a bit diverse (language dependent etc)
09:53:45 <iany> Does anyone else see "big-endian Patricia Trees" and think "how rude!" ?
09:54:07 <ihope> Does GHC put anything in its output that I might have copyright issues with?
09:54:26 <ndm> ihope: GMP?
09:54:31 <ihope> I don't want the GHC devs suing me for using GHC :-)
09:54:33 <ndm> ihope: what do you want to do with the output?
09:54:49 <ndm> ihope: oh no, its BSD, and explicitly states they have no claim over the generated code
09:55:06 <ihope> Explicitly states they have no claim to the generated code?
09:55:12 <iany> > chr(169)
09:55:14 <lambdabot>  '\169'
09:55:23 <ihope> That'll certainly work, then.
09:55:27 <ndm> ihope: yes, you write a program, compile it, you are free
09:55:30 <ndm> 
09:55:40 <ndm> > chr 169
09:55:41 <lambdabot>  '\169'
09:55:50 <ndm> btw, we don't need the brackets - its a very C way of doing things
09:56:28 <int-e> > (chr 169) -- and if we need them it's usually this way
09:56:30 <lambdabot>  '\169'
09:56:40 <iany> oh how embarassing: next thing you know I'll be typing C-f in Emacs to search
09:56:56 <ihope> Does C-f in Emacs search?
09:57:12 <benny> no, C-s does
09:57:12 <iany> no, it goes forward one char
09:57:37 <ndm> it does in textpad, C-f
09:57:41 <ihope> I'm more of a vi person than an emacs person. And I'm not a vi person.
09:58:08 <iany> which is less potentially dangerous than pressing C-s in a windows editor if you didn't want to save the file
09:58:19 <ihope> Indeed.
10:01:55 * ndm wants a haskell tool to automaticallly insert imports as required - i.e. if you use (\\) it adds import Data.List
10:02:01 <Heffalump> <aol>
10:02:12 <ndm> aol?
10:02:15 <Heffalump> "me too"
10:02:30 <glguy> but "aol"?
10:02:42 <ndm> i was thinking it could be added into GuiHaskell quite easily, just trap the compile error coming out of Hugs/GHCi, tweak the file and reload
10:03:12 <Heffalump> back in the days when plebs were first starting to flood onto the internet, many of them came from AOL and their sole contribution to conversation (be it by IRC or newsgroups or whatever) tended to be "me too"
10:03:56 <Heffalump> ndm: just allowing imports to be sprinkled anywhere in a file would be a good start
10:04:41 <ndm> Heffalump: hmm, i don't like that idea so much - i do like imports at the top - its just when splitting up a files etc fixing up the imports (despite being dead obvious) is tedious
10:05:01 <ndm> i guess its a style thing
10:06:01 <Heffalump> it's great for being able to read what the files do, certainly
10:06:06 <Botje> haskell could use a DrScheme-like thing.
10:06:21 <Botje> Helium looks neat, but i'm not sure how far they've gone
10:06:42 <ndm> Heffalump: optimising for readability is usually the best choice
10:07:36 <Heffalump> well, you could allow people to sprinkle their imports anywhere and have an editor macro that lifts them to the top
10:08:14 <jbalint> what is plebs
10:08:32 <ndm> yeah, thats not a bad idea
10:08:35 <Botje> :h/^import/normal dd}p
10:08:39 <Botje> argh
10:08:45 <Botje> :g instead of :h
10:08:47 <ndm> @dictionary pleb
10:08:47 <lambdabot> Unknown command, try @list
10:08:53 <ndm> @wordlist pleb
10:08:53 <lambdabot> Unknown command, try @list
10:08:57 <ndm> @list
10:08:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:08:58 <Heffalump> jbalint: plebs = "normal people", with a somewhat derogatory implication
10:09:07 <jbalint> ah ;)
10:09:16 <Igloo> It wasn't so much that they only contributed "me too", but that they'd quote entire e-mails to do so
10:09:21 <Heffalump> I was referring to the days when the Internet was migrating from being mainly an academic network to being generally useful.
10:09:25 <ndm> i would have defined them probably as "the great unwashed"
10:09:37 * Heffalump looks at the snow outside his window
10:10:05 * ndm saw snow earlier
10:10:16 <Heffalump> but you expect that up Norf :-)
10:10:16 <ndm> Heffalump: are you still in cambridge?
10:10:34 <Heffalump> yes, still in the place you stayed. Just been out looking for places in St Neot's, though.
10:10:35 <iany> went back to rain here (Brum)
10:10:48 <ndm> St Neot's ?
10:10:51 <ndm> which country is that?
10:10:59 <Sgeo> Does the typing in Hpaste's logo make sense?
10:10:59 <Heffalump> England..
10:11:09 <Heffalump> presumably you've got the train to Kings Cross from York?
10:11:16 <Heffalump> or vice versa
10:11:45 <Heffalump> St Neot's is on that line, a bit south of Peterborough. Due West from here, basically.
10:11:48 <ndm> yep
10:11:53 <ndm> cool
10:12:13 <Heffalump> at the moment I have to drive there every morning to get the train
10:15:15 * Sgeo thinks he finally understands why foldr is good for infinite lists, but foldl is not
10:15:29 <Sgeo> From docs:  foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
10:16:00 <Sgeo> foldl basically has no way of knowing what `f` will do to each value
10:16:01 <iany> on second thoughts...
10:16:14 <Sgeo> But with  foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
10:16:34 <Sgeo> then if, e.g. f = (*), then if x1 is 0, foldr can stop
10:16:57 <Sgeo> ^^my own understanding, please don't rely on it
10:17:05 <isaacd__> if (*) has the necessary laziness properties, which it probably doesn't
10:17:45 <Sgeo> @src (*)
10:17:46 <lambdabot> Source not found. Wrong!  You cheating scum!
10:18:03 <isaacd__> if, e.g.  f = (&&), then if x1 is False, foldr can stop   ---- correct
10:18:10 <sjanssen> Sgeo: a better example is foldr (&&)
10:18:34 <sjanssen> @quote stereo
10:18:34 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
10:18:55 <isaacd__> since (*) is usually an primitive on Int, Integer etc., which requires both arguments already evaluated
10:19:12 <isaacd__> (which is almost always necessary anyway, so it helps optimization too)
10:34:26 <gdurazo> hello...?
10:34:39 <kaol> @yow
10:34:39 <lambdabot> Are you still an ALCOHOLIC?
10:35:07 <gdurazo> i've never used irc before, so i don't know if this is working. i've been here for about 15 minutes and no one has said anything
10:35:14 <gdurazo> that i can see
10:35:16 <Sgeo> Hi gdurazo
10:35:24 <Sgeo> Can you see what I'm typing?
10:35:28 <gdurazo> Hi, yeah. thanks
10:35:31 <Sgeo> yw
10:35:54 <gdurazo> i'm trying to learn haskell just for fun, and i have a very beginner question. is this an appropriate place to go for helpl?
10:36:02 <kaol> certainly yes
10:36:11 <araujo> gdurazo, you have found the right place
10:36:31 <gdurazo> cool. what i'm trying to do is just write a basic function which reverses a list
10:36:50 <gdurazo> and it's not working.
10:36:51 <glguy> !paste
10:36:51 <hpaste> Haskell paste bin: http://hpaste.org/
10:37:17 <gdurazo> !paste
10:37:17 <hpaste> Haskell paste bin: http://hpaste.org/
10:37:27 <gdurazo> er
10:37:33 <Botje> gdurazo: you can put the code on that site, so you don't clutter up the channel
10:37:42 <gdurazo> i see. thanks
10:37:53 <hpaste>  gdurazo pasted "(no title)" at http://hpaste.org/1026
10:38:25 <glguy> gdurazo: when you write:   something:[]
10:38:35 <glguy> you are just making a single element list of something
10:38:38 <Sgeo> Is http://hpaste.org/1021 a sensible way to separate IO from logic/
10:39:06 <Botje> :t (:)
10:39:07 <glguy> Sgeo: sure
10:39:08 <lambdabot> forall a. a -> [a] -> [a]
10:39:12 <glguy> Sgeo: do you know about readLn?
10:39:14 <glguy> :t readLn
10:39:16 <lambdabot> forall a. (Read a) => IO a
10:39:19 <Botje> gdurazo: the : operator expects a list as second argument
10:39:24 <Sgeo> glguy, yes, after I pasted that
10:39:31 <glguy> ok
10:39:35 <gdurazo> no, sorry. i don't really know anything about monads or IO yet
10:39:36 <Botje> and a single element as first argument
10:39:47 <gdurazo> i see, botje
10:39:52 <Botje> gdurazo: you should use lists and ++
10:40:08 <gdurazo> oh, ++ , i see
10:40:22 <gdurazo> that makes sense
10:40:36 <gdurazo> so `:` will complain at me if the second thing isn't a list?
10:40:45 <Saizan> yes
10:40:53 <Saizan> ?type (:)
10:40:55 <lambdabot> forall a. a -> [a] -> [a]
10:40:57 <glguy> Sgeo: you don't need so many parentheses (fyi) as the operators are applied after functions are
10:41:23 <gdurazo> i see. but i feel like if i gave my code the list [1, 2 ,3 ,4, 5] it would end up with: 5:(4:(3:(2:(1:[]))))
10:41:24 <glguy> Sgeo: you don't need a "do" in displayFacs for a single statement
10:41:25 <chessguy> hi haskellers
10:42:23 <glguy> Sgeo: using !! over and over on a list is probably a sign you could be doing something more effeciently
10:42:26 <glguy> I'll paste if you like
10:42:51 <cdsmith> gdurazo: that's the right answer!  "show" will write the list using bracket notation, though, so you'll see [5, 4, 3, 2, 1]
10:43:38 <gdurazo> right, i mean that's what i was thinking my code would output, but ghc complained about it and wouldn't even try... :(
10:44:07 <cdsmith> oh, sorry I just jumped in.  I am obviously missing context.
10:44:23 <gdurazo> ha, no it's okay. :)
10:44:44 <gdurazo> i guess my solution is a bit kludgey
10:44:57 <Saizan> > foldl (flip (:)) [] [1..5] -- just to show off
10:44:58 <lambdabot>  [5,4,3,2,1]
10:45:24 <gdurazo> cool!
10:45:42 <gdurazo> what does flip do? i'm a little confused by that
10:45:53 <Saizan> ?src flip
10:45:53 <lambdabot> flip f x y = f y x
10:46:16 <gdurazo> heh, i suppose that makes sense...
10:46:25 <glguy> Sgeo: mapM_ putStrLn (facsList n) -- is probably cleaner than -- putStrLn $ unlines $ facsList n
10:46:27 <Saizan> > foldl (\xs x -> x:xs) [] [1..5]
10:46:28 <lambdabot>  [5,4,3,2,1]
10:46:49 <abz> ?doc Control.Exception
10:46:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
10:46:56 <Sgeo> um.. that would require me knowing what mapM_ is
10:47:09 * Sgeo is just interested in simple easy-to-understand IO
10:47:19 <Sgeo> And separation of IO from logic
10:47:21 <gdurazo> wow, i'm going to have to study up on foldl and foldr
10:47:25 <glguy> Sgeo: well, it would be best to learn the standard functions
10:47:32 <glguy> so now would be as good a time as any :)
10:47:37 <iany> since it's got to be strict, should that be foldl'?
10:47:46 <glguy> mapM f xs    runs f on each element of xs and returns a list of the results
10:47:55 <encryptio> :t mapM
10:47:55 <glguy> mapM_ f xs runs f on each element of xs and returns no result
10:47:57 <lambdabot>     Ambiguous occurrence `mapM'
10:47:57 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
10:48:25 <Sgeo> glguy, what's the difference between map and mapM_?
10:48:29 <hpaste>  glguy annotated "Not so great factorial displayer" with "updated" at http://hpaste.org/1021#a1
10:48:38 <glguy> Sgeo: the _ functions discard their results
10:48:45 <gdurazo> ok, well thanks everyone for your help. i think i've got plenty of answers and things to think about now
10:48:49 <glguy> Sgeo: this can allow them to run more efficiently
10:48:59 <Sgeo> and between map and mapM?
10:49:13 <glguy> map runs a normal function on each element
10:49:16 <glguy> mapM is for monads
10:49:18 <glguy> :t mapM
10:49:20 <lambdabot>     Ambiguous occurrence `mapM'
10:49:20 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
10:49:27 <glguy> :t Control.Monad.mapM
10:49:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:49:36 <glguy> so in the case of IO
10:49:51 <Saizan> gdurazo: if you wnat to write the recursion explicitly you'll need to use an accumulator to pass the yet reversed part of the list down to the recursive call
10:49:53 <glguy> mapM f xs    runs a function in the IO monad on each element (print)
10:50:02 <JohnnyL> what does the  (m :: * -> *) b. mean up ^^ there?
10:50:14 <glguy> ?type map print [0..10]
10:50:16 <lambdabot> [IO ()]
10:50:25 <glguy> see how that returns a list of IO () values
10:50:33 <glguy> things that *would* perform IO if you ran them
10:50:35 <glguy> but
10:50:48 <glguy> ?type Control.Monad.mapM print [0..10]
10:50:51 <lambdabot> IO [()]
10:51:02 <glguy> returns a single IO action
10:51:05 <glguy> that does all of them
10:51:29 <glguy> mapM f xs  -- is like -- sequence (map f xs)
10:51:42 <cdsmith> ?src Control.Monad.mapM
10:51:43 <lambdabot> Source not found. You speak an infinite deal of nothing
10:51:44 <glguy> where sequence takes a list of actions and returns an action that runs all of them
10:51:57 <glguy> (in order)
10:52:40 <glguy> map print [1..3] -- [print 1, print 2, print 3]
10:52:42 <benny_> anyone here that has xmonad running? I can't seem to build it. Setup.lhs: cannot satisfy dependency X11-extras==0.0
10:53:13 <glguy> mapM_ print [1..3] -- print 1 >> print 2 >> print 3
10:53:21 <shachaf> @where x11-extras
10:53:21 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/X11-extras
10:53:29 <benny_> I already have that installed.
10:55:00 <Saizan> is it among the packages in ghc-pkg list ?
10:55:25 <glguy> > shows 20 . showString "! = " . show $ product [1..20]
10:55:26 <lambdabot>  "20! = 2432902008176640000"
10:55:42 <benny_> Saizan: no, but none of the other packages are. (x11)
10:56:34 <Saizan> and you can load them?
10:57:05 <benny_> configure: Dependency mtl==1.0: using mtl-1.0 ... this works, I'm not very familiar with haskell so I'm basically stabbing in the dark
10:57:41 <Japsu> > show 20 ++ "! = " ++ show $ product [1..20]
10:57:42 <lambdabot>  Couldn't match expected type `[Char]'
10:58:24 <glguy> Japsu: you are trying to concatenate "! = " and "show"
10:58:40 <Japsu> > shows 20 ++ "! = " ++ shows $ product [1..20]
10:58:41 <lambdabot>  Couldn't match expected type `[a]' against inferred type `ShowS'
10:58:49 <glguy> :t shows
10:58:51 <lambdabot> forall a. (Show a) => a -> String -> String
10:58:58 <encryptio> > show 20 ++ "! = " ++ $ show $ product [1..20]
10:58:58 <lambdabot>  Parse error
10:59:01 <encryptio> meh
10:59:19 <shachaf> > show 20 ++ "! = " ++ (show $ product [1..20])
10:59:20 <lambdabot>  "20! = 2432902008176640000"
10:59:29 <Japsu> !!
10:59:32 <Japsu> right
11:00:24 <glguy> > ((show 20 ++) "! = " ++) . show $ product [1..20]
11:00:25 <lambdabot>  "20! = 2432902008176640000"
11:00:27 <encryptio> can you define a postfix unary operator in haskell?
11:00:28 <chessguy> > (show 20 ++ "! = " ++) $ show $ product [1..20]
11:00:29 <lambdabot>      The operator `++' [infixr 5] of a section
11:00:29 <lambdabot>         must have lower preced...
11:00:44 <shachaf> encryptio: Yes.
11:00:44 <glguy> you can only do this:
11:00:48 <chessguy> weird error
11:00:51 <glguy> > (++ "A" ++ "B") "C"
11:00:52 <shachaf> encryptio: But you have to use it in parentheses.
11:00:53 <lambdabot>  "CAB"
11:01:07 <glguy> ++ is infixr, so sections of ++ must be left sections
11:01:29 <glguy> or, whatever ( `op` x ) is called
11:01:33 <abz> is there subString function in one of the Haskell libraries?
11:01:36 <glguy> maybe not "left section" i don't remember
11:01:39 <Sgeo> @src interact
11:01:40 <lambdabot> interact f = do s <- getContents; putStr (f s)
11:01:53 <glguy> > take 5 . drop 10 $ ['a'..'z']
11:01:54 <lambdabot>  "klmno"
11:02:17 <encryptio> take (-1) [1..]
11:02:24 <encryptio> > take (-1) [1..]
11:02:25 <lambdabot>  []
11:02:52 <Sgeo> > interact id
11:02:54 <lambdabot>  <IO ()>
11:03:04 <shachaf> abz: `isInfixOf`
11:03:19 <abz> :t isInfixOf
11:03:21 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
11:03:30 <abz> thanks shachaf
11:04:03 <glguy> as pdj_ pointed out, haskell might be pure, but learning haskell has side-effects :)
11:04:08 <pebblestone> hi, could anybody tell me some ai resources written in Haskell?
11:04:50 <glguy> "Why Functional Programming Matters" isn't necessarily written in Haskell, but has a lazy programming example of alpha beta pruning that might be interesting (and is easy to translate)
11:05:20 <pebblestone> glguy: yeah, I've read it. :)
11:06:24 <pebblestone> lazy eval can really simplifies algorithms because it deals nothing with time so you can combine different pieces of them.
11:08:12 <pebblestone> I'm written the same examples using lazy lists in Common Lisp but it seems it doesn't run as fast as Haskell. Are there any particular optimizations done in GHC compiling the lazy eval?
11:08:39 <emu> fusion
11:09:00 <glguy> you mean faster than normal?
11:09:03 <pebblestone> emu: yup? can you elaborate more?
11:09:29 <emu> for example, translating: map f . map g ==> map (f . g)
11:10:44 * glguy doubts that lisp doesn't do some fusion in its lazy lists
11:10:45 <emu> it seems to me that strict languages tend to do more work with intermediate results, generally, which Haskell doesn't
11:10:49 <pebblestone> glguy: I don't know what normal means, but the programs compiled by haskell is faster than that written in Common Lisp. But the precondition is using lazy list in CL. I didn't write the eager version because the structure would be quite different.
11:10:59 <emu> lisp doesn't have lazy lists
11:11:03 <emu> he's implementing it with lambdas
11:11:11 <glguy> emu: right, but that's already been done
11:11:19 <glguy> emu: similarly factor has a lazy list library
11:11:20 <pebblestone> emu: ok, i see.
11:11:39 <emu> glguy: unless that library has been integrated into the compiler somehow, it's at a disadvanage
11:12:08 <emu> deftransforms etc
11:12:08 <pebblestone> s/compiled by haskell/compiled by ghc
11:12:18 <glguy> emu: I just figured that the lazy list map in Lisp, for example, would take a function and a lazy list generator
11:12:31 <glguy> it would be easy for it to then wrap the output function of the generator
11:12:59 <glguy> just as easy as to make a new generator that pulls out an element and manually aplies the function
11:13:02 <emu> sure
11:13:02 <glguy> thats all
11:13:19 <emu> really, this lazy list impl is the big unknown
11:13:25 <glguy> yeah
11:13:41 <glguy> are lisp lazy lists any different than generators?
11:13:48 <emu> but one of the things that got me into Haskell was frustration with inefficiency of functional-style code in CL
11:14:12 <glguy> similarly, functional programming in C# looks ugly too
11:14:21 <pebblestone> glguy: lazy list can be implemented using generators. actually in my implementation, tha last element is a generator.
11:14:38 <emu> neither generators or lazy lists are part of CL, so I can't say what's going on here
11:14:39 <glguy> I've tried to take my Haskell to work (C#) and it wasn't pretty :)
11:15:50 <emu> in large software systems, using a functional programming style in CL seemed to cause lots of unnecessary and unavoidable cpu/mem waste
11:16:20 <pebblestone> emu: which implementation do you use?
11:16:26 <emu> allegro and sbcl
11:17:06 <dufflebunk> emu: if it's unavoidable, it's not unnecessary...
11:17:31 <pebblestone> emu: ok. I use SBCL and it's true that some functional-style functions cannot open code which cause some inefficiency. and as you've said, to implement fusion need a lot of work.
11:17:33 <emu> hmm, in two different senses
11:17:45 <emu> conceptually it's unnecessary. operationally, it's unavoidable
11:18:07 <glguy> dufflebunk: he was obviously saying that his lisp implementation was doing unnecessary things to his program, and that he couldn't avoid those faults when using his lisp impl
11:18:30 <glguy> unnecessary in the sense that a superior implementation wouldn't
11:18:38 <Sgeo> @t prompt
11:18:38 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
11:18:43 <Sgeo> @type prompt
11:18:45 <lambdabot> Not in scope: `prompt'
11:19:01 <glguy> Sgeo: that function is defined in one of the files you are looking at
11:19:03 <dufflebunk> Ah, ok. I just got up.
11:19:13 <Sgeo> glguy, hm?
11:19:20 <glguy> prompt isn't a standard function
11:19:22 <Sgeo> oh
11:19:28 <glguy> the definition is somewhere in what you are reading
11:19:36 <glguy> unless you made it up
11:19:40 <glguy> then it doesn't exist :)
11:19:49 <emu> try :info prompt or generate some tags
11:20:06 <Sgeo> Someone mentioned a prompt function instead of putStr and getStr. I guess the person meant to MAKE such a function
11:20:23 <Sgeo> s/getStr/getLine/
11:20:38 <glguy> prompt p = putStrLn p >> readLn
11:21:13 <hpaste>  byteshack pasted "reduce tree" at http://hpaste.org/1027
11:21:24 <glguy> ?type (>> readLn) . putStrLn
11:21:26 <lambdabot> forall a. (Read a) => String -> IO a
11:21:31 <byteshack> I've been trying to get this fo work for some time now
11:21:55 <byteshack> it's the "why funct prg... matters" reduce tree operation
11:22:14 <byteshack> ghci doesn't like me, what am I doing wrong?
11:22:24 <hpaste>  Sgeo pasted "Letter removal" at http://hpaste.org/1028
11:22:28 <glguy> byteshack: you aren't pasting the error message, for one
11:22:37 <byteshack> ah... sorry
11:23:18 <hpaste>  byteshack annotated "reduce tree" with "(no title)" at http://hpaste.org/1027#a1
11:24:08 <cdsmith> Is there a relatively standard data type for a decimal number with significant digits, or should I invent my own?
11:24:41 <kc5tja> Reading PJ's Implementation of FPLs paper -- very interesting that it relies on separate data and return stacks, a la Forth.
11:25:07 <sorear> kc5tja: which one?
11:25:13 <byteshack> kc5tja: got a link?
11:25:15 <sorear> kc5tja: impl. of fpls wasn't exactly a paper
11:25:24 <Heffalump> book?
11:25:27 <sorear> kc5tja: 400+ pages does not a paper make ;)
11:25:37 <kc5tja> @where simon-ifpl-1987
11:25:37 <lambdabot> I know nothing about simon-ifpl-1987.
11:25:45 <kc5tja> that one, although I can't remember the dang reference
11:25:46 <sorear> @goo slpj-book-1987
11:25:48 <lambdabot> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
11:25:48 <lambdabot> Title: The Implementation of Functional Programming Languages
11:26:08 <kc5tja> 87 pages on my end here; although technically a "book," it's structured like a normal "paper."
11:26:19 <sorear> kc5tja: are you talking about the separation between the "stack" and "dump"?
11:26:26 * kc5tja notes also most Ph.D. theses are referred to as "papers," even when 200+ pages.  :)
11:26:39 <kc5tja> SPJ has not mentioned any "dump" so far.
11:26:40 <sorear> kc5tja: my ifpl only covered the vanilla G-machine
11:26:53 <kc5tja> No, this is on the STG.
11:26:58 <kc5tja> Maybe it's not the same paper then.
11:27:02 <sorear> kc5tja: is this the "implementing functional languages: a tutorial"
11:27:26 <sorear> kc5tja: "Implementing functional languages on stock hardware: the Spineless Tagless G-Machine"?
11:27:44 <kc5tja> 16
11:27:46 <kc5tja> wtf?!
11:27:54 * kc5tja bats Acroread with a freakin' cluebat.
11:28:12 <kc5tja> Copying text from acroread 7 is broken in Linux version.
11:28:13 <kc5tja> >:(
11:28:20 <byteshack> darn it, PEBKAC again, forgot "a" on (redtree1 f g *a* subtrees)
11:28:38 <kc5tja> Implementing lazy function programming languages on common stack hardware: The Spineless Tagless G-Machine, Version 2.5
11:28:51 <sorear> egads!
11:28:53 <kc5tja> functional rather
11:29:19 <sorear> anyone know how to delete comments on the GHC trac?
11:30:16 <hpaste>  glguy annotated "reduce tree" with "fixed" at http://hpaste.org/1027#a2
11:30:24 <glguy> http://hpaste.org/1027/diff?old=0&new=2
11:30:28 <glguy> to see the difference
11:31:13 <glguy> byteshack: ah, I see you already fixed it :)
11:31:25 <byteshack> glguy: thanks.  I had been banging my head with it for a while
11:33:49 * Sgeo supposes that read doesn't terminate on infinite lists?
11:33:50 <byteshack> sweet, it works (TM) :)
11:34:04 <Sgeo> s/doesn't terminate/doesn't make sense/
11:34:38 <Heffalump> sego: read doesn'tt really, reads does
11:34:42 <sorear> Sgeo: it makes sense, but it won't work because of error handling
11:35:01 <Sgeo> @type reads
11:35:03 <lambdabot> forall a. (Read a) => String -> [(a, String)]
11:35:33 <kc5tja> Fascinating -- algebraic data types gives rise to *return conventions*, rather than calling conventions (the latter is effected by the use of a separate evaluation stack).  This is how case/pattern-matching is done, and is quite similar to structured return-stack manipulation in Forth.
11:35:47 <kc5tja> Forth and Haskell are remarkably similar under the hood!
11:36:25 <glguy> kc5tja: if you wanted to be more like Digg, it would be:
11:36:38 <glguy> [PROFOUND] algebraic data ty...
11:37:00 <glguy> [BREAKING] I'll be right back
11:37:12 <gdurazo> haha
11:37:22 <vvv> Hi, guys! I have a problem with emacs haskell-mode. It prints
11:37:22 <vvv> ``Invalid read syntax: "."'' and refuses to start. :-(
11:37:28 <sorear> kc5tja: you might want to look at the yhc guts...
11:37:31 <kc5tja> glguy: That's actually a pretty nice convention.  But I think it'd be too disruptive of IRC's emphasis on conversational, rather than tagged, prose.
11:37:58 <kc5tja> [BREAKING] News -- at 11!
11:38:20 <kc5tja> sorear: I don't think I'm ready to start looking at Haskell compiler guts yet.  :)
11:39:45 <kc5tja> But, I'm very glad to see some seriously lateral thinking; I mean, who ever would have thought of *return* conventions?  The thought has only *barely* crossed my mind, as one of those, "I wonder if it's possible to formalize Forth's return stack manipulations into a set of programming patterns?"
11:40:36 <sorear> atterns?" `isSuffixOf`?
11:40:56 <kc5tja> ?SYNTAX ERROR IN  <sorear>  ;)
11:40:57 <lambdabot> Unknown command, try @list
11:41:04 * kc5tja laughs
11:41:30 <sorear> ?SYNTAX ERROR ?  is that supposed to be some kind of text interpreter erro?
11:41:30 <lambdabot> Unknown command, try @list
11:41:53 <kc5tja> sorear: I'm dating myself.  You've obviously never coded in the old-school 8-bit BASICs of the early 80s.
11:43:31 <vvv> @list
11:43:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:43:46 * Sgeo attempts to come to terms with interact working with infinite lists
11:43:48 <SamB> sorear: I believe they actually tokenize the input and then interpret the token stream
11:44:09 <sorear> SamB: what was that for?
11:44:27 <SamB> rather than interpreting text
11:44:40 <sorear> I meant that == the comment
11:45:13 <kc5tja> SamB: Some implementations of BASIC did proper syntax checking during tokenization instead of at run-time (e.g., Atari BASIC), but most (being derived from Microsoft BASIC) just deferred syntax checking until runtime.
11:45:15 <Sgeo> @girl19
11:45:15 <lambdabot> is this a help channel for hackers-beginners?
11:45:19 <SamB> <sorear> ?SYNTAX ERROR ?  is that supposed to be some kind of text interpreter erro?
11:45:19 <Sgeo> @girl19
11:45:20 <lambdabot> well.. I never hacked Russians
11:45:25 <kc5tja> (hence, Atari BASIC was actually faster than most BASICs)
11:45:30 <Sgeo> @yhjulwwiefzojcbxybbruweejw
11:45:30 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
11:46:08 <glguy> @quote
11:46:09 <lambdabot> xDie says: sampabolla
11:46:18 <Sgeo> @ghc
11:46:18 <lambdabot> ghc says: Cannot desugar this Template Haskell declaration
11:46:22 <Sgeo> @ghc
11:46:23 <lambdabot> ghc says: does not have the required strict field(s)
11:46:27 <glguy> :-/ is there some hidden reason why that was worth quoting?
11:46:45 <Sgeo> @help girl19
11:46:45 <lambdabot> girl19 wonders what "discriminating hackers" are.
11:46:49 <Sgeo> @help girl19
11:46:49 <lambdabot> girl19 wonders what "discriminating hackers" are.
11:46:56 <Sgeo> @help yhjulwwiefzojcbxybbruweejw
11:46:56 <lambdabot> V RETURNS!
11:47:04 <sorear> hmm.  I would have guessed basics did non-optimizing compilataion of the STC flavor
11:47:09 <Sgeo> @help hoogle+
11:47:09 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
11:47:09 <glguy> @v
11:47:09 <lambdabot> Just 'J'
11:47:16 <sorear> @v
11:47:16 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
11:47:38 <sorear> v is fun!
11:47:47 <sorear> ooh, jabber.hst.ru
11:48:47 <Sgeo> @putStrLn "Hi!"
11:48:48 <lambdabot> Unknown command, try @list
11:48:51 <Sgeo> > putStrLn "Hi!"
11:48:53 <lambdabot>  <IO ()>
11:48:56 <sorear> nice try
11:49:28 <Sgeo> let main = do {putStrLn "Hi"} in main
11:49:31 <Sgeo> > let main = do {putStrLn "Hi"} in main
11:49:33 <lambdabot>  <IO ()>
11:49:48 <Uncountable> > unsafePerformIO (putStrLn "Haha!")
11:49:49 <lambdabot>   Not in scope: `unsafePerformIO'
11:50:01 <Uncountable> > ":("
11:50:02 <lambdabot>  ":("
11:50:10 <Sgeo> > import System.IO.Unsafe
11:50:11 <lambdabot>  Parse error
11:50:19 <sorear> > appendFile "/etc/passwd" "sorear::29923:29923::/:/bin/sh"
11:50:19 <Sgeo> >  System.IO.Unsafe.unsafePerformIO
11:50:20 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
11:50:21 <lambdabot>  <IO ()>
11:50:24 <Uncountable> > System.IO.Unsafe.unsafePerformIO (putStrLn "Haha!")
11:50:24 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
11:50:34 <kc5tja> sorear: Nope.  BASICs did the equivalent of intermixed TTC (Token-threaded code) with ASCII (re-)evaluation.
11:50:35 <sorear> Uncountable: it's not imported even qualified
11:50:55 <Sgeo> > Foreign.unsafePerformIO
11:50:55 <lambdabot>   Not in scope: `Foreign.unsafePerformIO'
11:50:57 <kc5tja> Not sure why; DTC or ITC would have been substantially superior code.
11:51:10 <sorear> > runST (unsafeIOtoST (putStrLn "x"))  -- you USED to be able to do this
11:51:11 <lambdabot>   Not in scope: `unsafeIOtoST'
11:51:48 <sorear> kc5tja: why DTC? on poorly pipelined arches of that era, wouldn't STC be a huge win?
11:52:04 <nominolo> sorear: did someone explit this?
11:52:06 <kc5tja> sorear: "poorly pipelined" would imply that they even had pipes at all.
11:52:11 <nominolo> *exploit
11:52:19 <sorear> nominolo: yes
11:52:32 <kc5tja> sorear: STC is the fastest representation of code (it's what I'm using on my Kestrel's Forth), but DTC and ITC are more compact.
11:52:32 <Sgeo> Is the "no unsafePerformIO" hardcoded?
11:52:39 <kc5tja> And on computers with 8K of RAM, that can be valuable.
11:53:05 <nominolo> yikes
11:53:08 <kc5tja> It also allows for one to reconstruct the original source text easily for editing purposes.
11:53:15 <sorear> kc5tja: how much more compact? on a 386, CALL <addr> is only 25% larger than DD <addr>
11:53:29 <kc5tja> sorear: 33% more compact for 8-bit architectures.
11:53:30 <vincenz> @seen dmhouse
11:53:31 <lambdabot> I saw dmhouse leaving #happs, #haskell-blah and #haskell 3h 24m 31s ago, and .
11:53:51 <kc5tja> sorear: But, again, we're talking about computers with 64K of RAM or less, of which video RAM is needed, some is taken by ROM, etc.
11:54:05 <kc5tja> All y'all on your modern-day 32-bit PCs are pampered, believe me.  :)
11:54:25 <Sgeo> I think I'm on P3
11:54:38 <nominolo> kc5tja: 32bit-address space is waaay too small ;P
11:54:52 <kc5tja> nominolo: For single-address-space OSes, definitely.  I couldn't agree more.
11:55:02 <kc5tja> nominolo: You need at least 64-bits of address space
11:55:22 <kc5tja> Although AmigaOS did quite well with a flat 32-bit address space, although it lacked protection.
11:55:26 <sorear> Sgeo: no - there's a list of modules that are imported, and System.IO.Unsafe simply isn't on the list
11:57:13 <kc5tja> sorear: The funny thing is, the 65816 is a 16-bit superset of the 6502 (8-bit), with 16MB address capability, but it still *firmly* prefers code to sit in convenient units of 64K 'banks' (if you say 'segments,' that not preferred terminology, but is correct).
11:57:45 <kc5tja> sorear: The architecture is amazingly hostile to C, but oddly enough, with the sole exception of polymorphism, a FPL might suit the architecture quite well.
11:58:11 <kc5tja> I can't confirm this yet, however; but it is something I'd like to toy with at some point.
11:58:19 <kc5tja> Hence, my reading SPJ's 87 STG paper.  :)
11:58:21 <kc5tja> err
11:58:23 <kc5tja> gees
11:58:26 <sorear> kc5tja: what's the Kestrel?
11:58:31 <kc5tja> 87-page STG paper.
11:58:32 <sorear> (a bird I know)
11:58:43 <kc5tja> http://www.falvotech.com/content/kestrel
11:58:44 <lambdabot> Title: The Kestrel Project
11:59:14 <Sgeo> @src seq
11:59:15 <lambdabot> Source not found. I feel much better now.
11:59:25 <Sgeo> How does seq work?
12:00:13 <sorear> Sgeo: magically
12:00:14 <Cale> Sgeo: seq x y will force the evalution of x up to the top level constructor, before resulting in y
12:00:35 <Cale> So, seq _|_ y = _|_, and seq x y = y otherwise.
12:00:37 <Pastorn_> @paste
12:00:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:00:43 <Sgeo> Cale, how? What if I wanted to define my own seq?
12:00:56 <Pastorn_> ?where random
12:00:57 <lambdabot> I know nothing about random.
12:00:58 <Cale> Well, you could define it for particular types using case
12:01:09 <Cale> For instance, for Maybe, you would write:
12:01:09 <Pastorn_> ?src frequency
12:01:10 <lambdabot> Source not found. My pet ferret can type better than you!
12:01:18 <Pastorn_> ?src System.Random.frequency
12:01:19 <lambdabot> Source not found. My pet ferret can type better than you!
12:01:27 <Cale> seq x y = case x of Nothing -> y; _ -> y
12:01:48 <Cale> The pattern matching case would force the evaluation of x
12:02:00 <Cale> It used to be that Seq was a typeclass
12:02:24 <Cale> But it was decided that making it a magical language primitive would be more convenient
12:02:58 <Cale> (because you wouldn't end up with lots of additional type constraints whenever you wanted to make something strict)
12:04:54 <sorear> kc5tja: oh, neat(kestrel)
12:05:28 <sorear> kc5tja: comment on frontpage about browser compatibility - I have no difficulty, and my browser does not suppose CSS *at all*
12:06:14 <kc5tja> sorear: The comments have certainly died down over the years.  I think I received the last "IT NO WOKRIE 4 ME!" message sometime last year.
12:06:19 <emu> isn't there a type-class for forcing eval
12:06:42 <emu> part of C.P.S.
12:07:18 <sorear> NFData
12:07:25 <sorear> @t rnf
12:07:25 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
12:07:26 <emu> yea
12:07:28 <sorear> @ty rnf
12:07:30 <lambdabot> forall a. (NFData a) => a -> Done
12:07:36 <kc5tja> Wow, neat, STG's syntax definition is quite definitely compact.  :)
12:07:49 <sorear> emu: also, BITD seq had type :: Eval a => a -> b -> b
12:08:27 <emu> DRiFT or something can derive RNF
12:08:36 <emu> NFData
12:08:38 <Sgeo> How would I use a function from System.IO in hugs?
12:08:38 <emu> yikes
12:10:28 <Cale> Sgeo: :also System.IO
12:10:33 <Cale> and then just use it
12:10:40 <Sgeo> ah
12:10:45 <ddarius> @help temp
12:10:45 <lambdabot> Local temperature
12:11:00 <Cale> In ghci, that would be :m + System.IO
12:11:16 <Sgeo> What happens if there's a conflict between two modules?
12:11:22 <psi> are the graphs in Data.Graph not weighted?
12:11:23 <chessguy> @type \f -> map f
12:11:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:11:45 <Cale> Sgeo: then using clashing names unqualified is an error
12:12:12 <Sgeo> Can I make it not use unqualified names?
12:12:30 <Cale> yeah, from a source file, but not as far as I know from the prompt
12:12:34 <chessguy> @type \f -> f b
12:12:36 <lambdabot> Not in scope: `b'
12:12:42 <chessguy> @type \f -> f ?b
12:12:44 <lambdabot> forall t t1. (?b::t) => (t -> t1) -> t1
12:13:08 <chessguy> @type map (\f -> f ?b)
12:13:08 <Cale> import qualified Module.Name
12:13:10 <lambdabot> forall t b. (?b::t) => [t -> b] -> [b]
12:13:17 <Cale> import qualified Module.Name as MN
12:13:30 <Sgeo> ty Cale
12:13:47 <Cale> (that latter one would result in the need to type MN.foo to access Module.Name.foo
12:13:50 <Cale> )
12:13:59 <Cale> Also, you can just import specific names
12:14:06 <Cale> import Module.Name (foo)
12:14:08 <cdsmith> @pl (\s (a, b) -> a ++ s ++ b
12:14:08 <lambdabot> (line 1, column 26):
12:14:09 <lambdabot> unexpected end of input
12:14:09 <lambdabot> expecting letter or digit, variable, "(", operator, ":", "++" or ")"
12:14:19 <cdsmith> @pl (\s (a, b) -> a ++ s ++ b)
12:14:19 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (++)) . (++)
12:14:34 <Cale> import qualified Module.Name as MN (foo, bar, quux)
12:15:31 <Mushy-pea> Hi.
12:16:28 <Cale> hello
12:17:00 <Mushy-pea> I'm living it up in Bristol (UK).
12:17:13 <Cale> Cool. Are you new here? Learning Haskell?
12:17:34 <Mushy-pea> Yes.  I've got a few basics down.
12:17:54 <Cale> Feel free to ask lots of questions here :)
12:19:41 <Mushy-pea> I do have a question, though it's slightly "out of left field".  But hey, I'll ask it anyway....
12:19:58 <sorear> good.
12:20:04 <sorear> questons are good.
12:20:33 <Mushy-pea> I've opened a Haskell forum on a non - commercial website of mine....
12:20:53 <Mushy-pea> The forum uses open source software that I wrote :)
12:21:12 <chessguy> in haskell?
12:21:22 <Mushy-pea> Perl.
12:21:47 <Mushy-pea> I've never found a hosting company that supports Haskell.
12:21:52 <vincenz> What is the question?
12:22:52 <Cale> (well, it would just have to support general CGI executables, which, yeah, is possibly rare)
12:23:49 <fasta> Is there a strict version of the State monad implemented anywhere?
12:23:54 <sorear> yes
12:24:01 <fasta> And where is that?
12:24:14 <fasta> (I mean a drop-in replacement)
12:24:37 <sorear> ml somewhere
12:24:42 <Cale> heh
12:25:02 <Mushy-pea> Would anyone object if I posted a link to it?  I wouldn't want to look like a room spammer.
12:25:11 <Mushy-pea> :)
12:25:39 <chessguy> go for it. i'd be interested
12:25:47 <Cale> Sure, new Haskell forum, let's have a look :) Are there many posts there yet?
12:25:58 <sorear> I prefer all communications to be centralized.
12:26:03 <Mushy-pea> 4
12:26:15 <sorear> I'd prefer it if #haskell or haskell-cafe were abolished.
12:26:23 <Cale> sorear: huh?
12:26:23 <chessguy> you might even mention it on haskell-cafe
12:26:25 <sorear> (but not both)
12:26:31 <Mushy-pea> Site index http://www.mushy-pea.org.uk
12:26:31 <xerox> xor
12:26:33 <lambdabot> Title: Welcome to mushy-pea.org.uk
12:26:36 <Cale> sorear: They're completely different though.
12:26:55 <Mushy-pea> Warning:  The software is in alpha stage.
12:28:50 <chessguy> sorear: what about the bloggers, the other mailing lists, and the wiki?
12:28:55 <chessguy> oh, and the wikibook
12:29:12 <chessguy> and the hardcopy books that are out there
12:29:35 <sorear> all these redundant channels are hurting our help-ability
12:29:54 <chessguy> i disagree. they all serve different purposes
12:30:48 <chessguy> or maybe the same purpose in different ways, if you prefer looking at it that way
12:31:00 <Cale> Mushy-pea: despite the potential issues with hosting Haskell web applications, you might be interested in hpaste (http://hpaste.org/), which is an IRC paste application which glguy wrote in Haskell in a couple of days. The source is available from the link at the bottom.
12:32:16 <Mushy-pea> OK.  I'm going to familiarise myself with these various Haskell related sites over the next few days.
12:33:11 <Mushy-pea> Got to get ready for a night out now.  Thanks for checking out the site.
12:33:35 * Mushy-pea does getting ready stuff.
12:33:56 <fantasma> can someone confirm that alioth.debian.org is down?
12:34:37 <fasta> fantasma: it is down
12:35:04 <shachaf> fantasma: It's responding to pings.
12:35:22 <shachaf> fantasma: No, not down, just slow.
12:35:26 <shachaf> fantasma: (For me).
12:35:42 <fantasma> eh, just got the site to appear
12:36:00 <fasta> My tolerance for down is rather low :)
12:36:10 <Sgeo> geom a r = a : [x * r | x <- geom a r]
12:36:15 <fasta> No, I think it got up now.
12:36:24 <Sgeo> Is that an appropriate way to define a geometric sequence?
12:36:31 <fantasma> thanks
12:37:37 <vincenz> > fix ((1:) scanl (*) 2))
12:37:37 <lambdabot>  Parse error
12:37:38 <vincenz> > fix ((1:) scanl (*) 2)
12:37:39 <lambdabot>  Couldn't match expected type `t -> t1 -> a -> a'
12:37:43 <vincenz> > fix ((1:) . scanl (*) 2)
12:37:44 <lambdabot>  [1,2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,618970019642690...
12:37:51 <sorear> > iterate (* 2) 1
12:37:52 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:37:53 <vincenz> that is a geometric sequence
12:37:58 <vincenz> hmm, nm
12:38:03 <Cale> iterate is probably clearest
12:38:08 <vincenz> true
12:38:12 <vincenz> mine is more exponential
12:38:24 <Sgeo> Remember the function from yesterday?
12:38:29 <Sgeo> s/function/list/
12:38:42 <Sgeo> > iterate (2^) 0
12:38:43 <lambdabot>  [0,1,2,4,16,65536,2003529930406846464979072351560255750447825475569751419265...
12:38:57 <vincenz> > iterator (^2) 1
12:38:58 <lambdabot>   Not in scope: `iterator'
12:39:01 <vincenz> > iterate (^2) 1
12:39:02 <sorear> lists are functions too!
12:39:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:39:19 * vincenz mutters at himself
12:39:20 <vincenz> > iterate (^2) 2
12:39:21 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
12:39:40 <Cale> > iterate (join (^)) 2
12:39:44 <lambdabot> Terminated
12:39:51 <Sgeo> join?
12:39:59 <Cale> join f x = f x x
12:40:09 <Cale> Well, in the appropriate monad
12:40:20 <sorear> actually join = (>>= id), but you don't want to know that yet.
12:40:24 <vincenz> join is for level 92 Haskellers
12:40:55 <Sgeo> looks so simple though
12:40:58 <Cale> Level 92, eh? That sounds a bit high.
12:41:06 <vincenz> Cale: not really, levels go up to 10k
12:41:10 <Cale> ah
12:41:11 <Cale> okay
12:41:30 <sorear> vincenz: is the normalization rule Oleg = 10k?
12:41:31 <chessguy> i'd love to see a list of those levels :)
12:41:36 <vincenz> sorear: no, he's an exception
12:41:44 <Cale> @type join
12:41:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:41:47 <vincenz> 10k = write ghc with mptcs from scratch
12:41:59 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
12:42:00 <lambdabot>  [1,2,3,4,5,6,7,8]
12:42:11 <Cale> > join (Just (Just 12))
12:42:12 <lambdabot>  Just 12
12:42:19 <Cale> > join (Just Nothing)
12:42:20 <lambdabot>  Nothing
12:42:22 <vincenz> > join (Right (Right 1))
12:42:23 <lambdabot>  Add a type signature
12:42:27 <tcr> Is it possible to define (and use) several modules within _one_ file?
12:42:42 <vincenz> tcr: hmm, define, no, but why would you want to?
12:42:45 <sorear> tar cf  :)
12:42:48 <Cale> tcr: Nothing in the language spec rules it out, but implementations don't support it.
12:43:11 <Cale> (because of the practical problem of locating imports, mostly0
12:43:12 <tcr> vincenz: Would make writing unit tests easier.
12:43:15 <Sgeo> The question: What is the number of digits in (256^256)^(256^256)
12:43:30 <sorear> tcr: my /dev/hdb1 file contains hundreds of haskell modules, which I use regulary
12:43:35 <Cale> Sgeo: that shouldn't be too hard to figure out on paper
12:43:50 <chessguy> > length $ show $ (256^256)^(256^256)
12:43:54 <lambdabot> Terminated
12:43:55 <tcr> vincenz: (unit tests that test modules themselves)
12:43:56 <sioraiocht> lol
12:44:02 <vincenz> tcr: just put them in the module?
12:44:02 <sorear> @hoogle log
12:44:02 <lambdabot> Prelude.log :: Floating a => a -> a
12:44:03 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
12:44:03 <lambdabot> GHC.ConsoleHandler.Logoff :: ConsoleEvent
12:44:10 <sorear> > logBase 10 100
12:44:11 <lambdabot>  2.0
12:44:28 <rashakil> > 256^257 * (logBase 10 256)
12:44:28 <sorear> > logBase 10 $ (256^256)^(256^256)
12:44:30 <lambdabot>  Infinity
12:44:30 <lambdabot>  Infinity
12:44:36 <sioraiocht> bummer
12:45:08 <sorear> > 256^256^257
12:45:11 <lambdabot> Terminated
12:45:14 <sorear> > 3^3^3
12:45:15 <lambdabot>  7625597484987
12:45:20 <sorear> > 3^(3^3)
12:45:22 <lambdabot>  7625597484987
12:45:38 <vincenz> > 3^3^3^3
12:45:41 <lambdabot> Terminated
12:45:42 <sorear> > length . show $ 256^257
12:45:43 <lambdabot>  619
12:45:51 <vincenz> > 2^2^2^2
12:45:52 <lambdabot>  65536
12:45:56 <Pastorn_> > unsafePerformIO newStdGen
12:45:57 <lambdabot>   Not in scope: `unsafePerformIO'
12:45:57 <Sgeo> (256 ^ 257) * logBase 10 256
12:45:57 <vincenz> > 2^2^2^2^2
12:45:59 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
12:46:39 <Sgeo> let's find num. of digits in the num of digits!
12:46:48 <Cale> It's 256^257 * log 256 / log 10
12:46:53 <Pastorn_> > Foreign.unsafePerformIO newStdGen
12:46:54 <lambdabot>   Not in scope: `Foreign.unsafePerformIO'
12:47:04 <Cale> Sgeo: er, yeah
12:47:10 <vincenz> > length $ show 2^2^2^2^2
12:47:11 <lambdabot>   add an instance declaration for (Num String)
12:47:17 <vincenz> > length $ show (2^2^2^2^2)
12:47:19 <lambdabot>  19729
12:47:32 <Cale> Which is 1.992 * 10^619
12:47:39 <Cale> approximately
12:47:57 <Sgeo> > 257 * logBase 10 256 + logBase 10 (logBase 10 256)
12:47:59 <lambdabot>  619.2993708444828
12:48:29 <Cale> > 10^0.2993708444828
12:48:30 <lambdabot>  Add a type signature
12:48:33 <tcr> I asked this question earlier today, but didn't receive any answer. So I'd like to ask again, if there is a comprehensive test suite of haskel itself, i.e. its language features? I looked briefly into the source distributions of Hugs and GHC, but couldn't find anything like that?
12:48:34 <Cale> > 10**0.2993708444828
12:48:35 <lambdabot>  1.992373902851299
12:48:53 <vincenz> tcr: I think yhc might have some
12:49:13 <Cale> that's correct to 12 places, at least :)
12:49:14 <sorear> tcr: ghc has a testsuite
12:49:30 <Cale> There's nofib
12:49:47 <vincenz> Cale: testsuite, not benchmark :)
12:50:24 <Cale> Well, being able to compile all the nofib programs is probably a decent, if not entirely thorough test :)
12:50:39 <allbery_b> ghc has a testsuite but it's separate from the base distribution.  check the ghc trac
12:50:39 <tcr> sorear: I only found something remotely looking like one in ilxGen/tests/; are you speaking of that?
12:50:44 <tcr> ah
12:51:02 <sioraiocht> so wait, would  "iterate (^2) 2" be the power tower series of two?
12:51:14 <allbery_b> (I run it on my local ghc HEAD builds)
12:51:16 <Cale> sioraiocht: yeah
12:51:37 <Cale> er, associated the wrong way though
12:51:42 <xerox> Cale, no sum?
12:51:44 <sioraiocht> okay, that's what I thought
12:52:03 <sioraiocht> > iterate (^2) 2
12:52:05 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
12:52:12 <sioraiocht> that grows way too slowly...
12:52:14 <vincenz> it's the square tower
12:52:20 <sioraiocht> aye
12:52:40 <sioraiocht> how would you get it to associate the other way, anyone know?
12:52:47 <sioraiocht> is there an equally elegant statement for it?
12:52:48 <Cale> > take 10 (iterate (^2) 2) == take 10 (map ((2^) . (2^)) [0..])
12:52:49 <lambdabot>  True
12:53:25 <vincenz> > iterate (2^) 2
12:53:26 <lambdabot>  [2,4,16,65536,20035299304068464649790723515602557504478254755697514192650169...
12:53:30 <vincenz> that's the powertower
12:53:32 <sioraiocht> aha
12:53:34 <sioraiocht> thanks
12:53:47 <vincenz> you won't get past element 5
12:53:51 <sioraiocht> lol i know
12:53:55 <vincenz> > iterate (3^) 3
12:53:56 <tcr> allbery_b: Would you mind pointing me to the specific site? I'm having trouble finding what you're speaking of. (Or did you mean that the test suite is included in ghc HEAD, but then stripped off during distribution generating?)
12:53:59 <lambdabot> Terminated
12:54:48 <sioraiocht> anyone down distributed system stuff in haskell?
12:54:54 <sioraiocht> s/down/done
12:55:05 <allbery_b> tcr: as far as I know the testsuite is only available from darcs
12:55:29 <nominolo> is it possible to apply to more than one SoC project?
12:55:35 <sioraiocht> nominolo: yes
12:55:35 <tcr> allbery_b: Is it possible to browse through it via an online interface?
12:55:44 <sioraiocht> up to twenty total
12:55:49 <kc5tja> > iterate (1.001^) 1.001
12:55:49 <lambdabot>  Add a type signature
12:55:57 <nominolo> ah, thanks sioraiocht
12:55:59 <allbery_b> http://darcs.haskell.org/testsuite
12:56:00 <lambdabot> Title: Index of /testsuite
12:56:01 <kc5tja> > iterate (1.001^) 1.001 :: Float
12:56:01 <lambdabot>  Couldn't match expected type `Float' against inferred type `[a]'
12:56:07 <sioraiocht> nominolo: which project are you looking at?
12:56:08 <vincenz> > iterate (1.001**) 1.001
12:56:09 <kc5tja> > iterate (1.001^) 1.001 :: [Float]
12:56:09 <lambdabot>   add an instance declaration for (Integral Float)
12:56:10 <lambdabot>  [1.001,1.0010010005003334,1.0010010015013346,1.0010010015023363,1.0010010015...
12:56:11 <allbery_b> both web address for browsing, and URL for darcs
12:56:18 <vincenz> it's **
12:56:33 <nominolo> sioraiocht: hackage web interface and LLVM library
12:56:37 <sioraiocht> I'm looking at doing the BSPHlib one
12:56:41 <Cale> so (Word8 -> Word8) -> (Word8 -> Word8), has roughly 2*10^619 elements.
12:56:58 * Sgeo wonders what a tetration tower would be like
12:57:09 <nominolo> sioraiocht: what's bsp?
12:57:15 <kc5tja> vincenz: That seems strange that operators like + and so forth are overloaded, but ^ isn't.
12:57:29 <ddarius_> @type (^)
12:57:29 <sioraiocht> nominolo: it's a paradigm for message passing parallelism
12:57:31 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:57:32 <vincenz> kc5tja: it is
12:57:50 <vincenz> kc5tja: ^ is for exacts, ** for floats
12:57:56 <vincenz> @type (**)
12:57:58 <lambdabot> forall a. (Floating a) => a -> a -> a
12:57:59 <nominolo> sioraiocht: comparable to MPI?
12:58:07 <kc5tja> Ahh
12:58:20 <kc5tja> :t iterate
12:58:22 <lambdabot> forall a. (a -> a) -> a -> [a]
12:58:39 <hpaste>  glguy pasted ""Odd Word Problem" Machine" at http://hpaste.org/1030
12:58:57 <sioraiocht> nominolo: it's considered an alternative to MPI
12:59:07 <hpaste>  glguy annotated ""Odd Word Problem" Machine" with "sample IO" at http://hpaste.org/1030#a1
12:59:33 <nominolo> sioraiocht: how is it better?
12:59:50 <nominolo> sioraiocht: the problem with mpi is the overhead and the 'low-level-ness'
13:00:37 <nominolo> afaik
13:01:16 <sioraiocht> correctness and performance prediction is considered easier in BSP
13:01:18 <tcr> allbery_b: thanks!
13:01:35 <Cale> Sgeo: have you seen Graham's number?
13:01:44 * Sgeo has heard of it
13:02:00 <allbery_b> the way you get there, by the way, is through the "Developers (Wiki)" sidebar link on the main GHC site
13:02:09 <glguy> ?hoogle Upper
13:02:09 <lambdabot> Text.ParserCombinators.Parsec.Char.upper :: CharParser st Char
13:02:09 <lambdabot> Char.isUpper :: Char -> Bool
13:02:09 <lambdabot> Char.toUpper :: Char -> Char
13:02:25 <sioraiocht> nominolo: BSPlib only contains about 20 functions to do the bul of the work
13:02:37 <allbery_b> that's also how you'll find GHC HEAD (6.7 development branch) and the nofib benchmark suite
13:02:45 <norpan> isUpper . toUpper == True
13:02:48 <nominolo> sioraiocht: sounds good.  i think the most intersting part wrt to motivating it is, why is it necessary for haskell?  ie. compared to MVars, Channels and STM
13:02:49 <Cale> Sgeo: first, you define up-arrow notation, which is basically a generalisation of forming tetration towers
13:02:52 <norpan> isUpper . toUpper == const True
13:03:16 <Cale> a^b = a*a*a*...*a (b times)
13:03:30 <Cale> a^^b = a^a^a^...^a (b times)
13:03:31 <nominolo> sioraiocht: you could probably built up some mpi-style group communication stuff on top of this in haskell
13:03:37 <Cale> a^^^b = a^^a^^a^^...^^a (b times)
13:03:38 <glguy> ?check isUpper . toUpper
13:03:40 <lambdabot>  Falsifiable, after 0 tests: '\394816'
13:03:43 <sioraiocht> nominolo: that's what I'm working on for my proposal, as most of my experience is with shared storage parallelism or thread-based concurrency
13:03:56 <Cale> And so on, where the evaluation is always right-associative
13:04:00 <glguy> ?scheck isUpper . toUpper
13:04:02 <lambdabot>   Completed 7 test(s) without failure.
13:04:12 <Cale> Then define g_1 = 3 ^^^^ 3
13:04:24 <Cale> which is already a ridiculously large number
13:04:37 <Sgeo> Is code written for Haskell?
13:04:47 <Sgeo> Cale, then do it 64 times or something?
13:04:48 <Cale> and then g_n = 3 ^^^...^ 3 with g_(n-1) up arrows
13:05:06 <Cale> Graham's number is then g_64
13:05:28 <sioraiocht> right now the nice thing would be that BSPlib is already fairly well distributed, and that haskell could be used in conjunction with C code if ther were haskell wrappers
13:05:32 <nominolo> sioraiocht: i did some stuff in mpi as a practical university course.  it's realy not nice.  doing it in haskell might be very nice
13:06:11 <Cale> Implementing this is almost pointless, as it's an understatement to say that 3 ^^^^ 3 has more digits than the number of particles in the universe
13:06:32 <sioraiocht> nominolo: I'm also pretty much against explicit thread-based concurrency
13:06:39 <sioraiocht> I think that should be left to the compiler
13:06:44 <Cale> and that's just g_1
13:07:25 <sioraiocht> BSP is for heavier parallelism, spawning as many threads as necessary for High Performance Computing
13:07:32 <nominolo> sioraiocht: yes, but Data-Parallel Haskell will need a while to become mature
13:07:53 <sioraiocht> you gotta start somewhere =)
13:08:21 <psi> i remember trying to wrap my head around graham's number once, it's truly mind boggling
13:08:32 <nominolo> sioraiocht: it *is* promising, and it seems like the only workable approach to reach scalability in the long run
13:08:53 <nominolo> sioraiocht: and it's food for a lot of reasearch, too
13:09:16 <nominolo> sioraiocht: i plan to be part of this, once i have my MSc
13:09:30 <Cale> For some extra perspective, if the rank of a number is the number of times you have to "count the digits" to get a number with 1 digit, that is, 0-9 are rank 0, and the rank of a number is n if the number of its digits has rank (n-1), then 3^^^3 (with just 3 up arrows), has rank 7,625,597,484,986
13:09:33 <sioraiocht> nominolo: ha, I'm hoping my MSc dissertation will be ona  similar topic ;)
13:09:48 <jcreigh> benny_: did you ever get your dependency problem with xmonad sorted out?
13:09:48 <lambdabot> jcreigh: You have 1 new message. '/msg lambdabot @messages' to read it.
13:10:10 <Cale> For comparison, the number of particles in the universe is around 10^81 or so, which is rank 2.
13:10:17 <benny_> jcreigh: nope. I tried to change the x11-extras to version 1.0 because I suspected that was the culplit but nope.
13:10:37 <jcreigh> benny_: how did you install the x11-extras package? (system wide, or just your user?)
13:10:46 <augustss> As fast something like g_n grows I think it's an interesting fact that there are function growing faster than you can express with any algorithm.
13:10:57 <Cale> Yeah
13:10:59 <benny_> jcreigh: system wide, setup.lhs configure, setup.lhs build, setup.lhs copy --destdir bla
13:11:12 <nominolo> sioraiocht: then maybe we'll meet at some conference some time :)
13:11:20 <Cale> Or just the fact that most natural numbers are larger than g_64
13:11:24 <sioraiocht> nominolo: where are you doing your grad work
13:11:40 <nominolo> sioraiocht: chalmers, gothenburg
13:11:46 <Cale> So as to give some sense of what we're really talking about, when we're talking about natural numbers. ;)
13:11:49 <Sgeo> What is the rank of the rank of Graham's number?
13:11:57 <jcreigh> benny_: hmm...
13:12:05 <fasta> About the one thing that annoys me most in Haskell is paradoxally the lack of transparancy.
13:12:06 <Cale> Sgeo: probably still something not directly expressible.
13:12:20 <sioraiocht> nominolo: is that in..sweden?
13:12:22 <Sgeo> How many ranks until you get to something conveniently expressible?
13:12:24 <Cale> My guess is something close to g_62
13:12:34 <nominolo> sioraiocht: yes, south-west
13:12:42 <Cale> But I could be way off.
13:12:58 <sioraiocht> nominolo:  awesome.  I'll be in the UK for my grad work starting in October
13:12:59 <jcreigh> benny_: I suspect that the package may not have been registered. You might want to try installing, eg, just for your user with runghc Setup configure --prefix=$HOME --user; runghc Setup build; runghc Setup install
13:13:01 <Sgeo> Well, it will be in [1..]
13:13:25 <Cale> oh, how many times you have to ask the rank of it
13:13:27 <Cale> hmm
13:13:27 <benny_> jcreigh: gimme a second.
13:13:40 <Cale> That's a good question.
13:14:25 <shachaf> Can a "where" be inside a lambda?
13:14:48 <Cale> shachaf: where is part of the syntax of declarations
13:14:53 <nominolo> sioraiocht: john hughes and koen classen of quickcheck fame work and teach here
13:14:55 <shachaf> > let f = \x -> g x where g = (+1) in f 5
13:14:56 <lambdabot>  6
13:15:00 <Cale> (function and pattern bindings)
13:15:04 <shachaf> > let f = (\x -> g x where g = (+1)) in f 5
13:15:04 <lambdabot>  Parse error
13:15:06 <nominolo> sioraiocht: and many in this channel, too
13:15:19 <shachaf> Cale: But "let" works.
13:15:24 <Cale> right
13:15:27 <shachaf> Cale: Why is there a difference?
13:15:41 <Cale> Because where is intended to scope over guards.
13:15:44 <benny_> jcreigh: seems to work. The dependency didn't fail
13:15:46 <Cale> So you can write:
13:15:53 <Cale> f x | y > 0 = ...
13:15:58 <Cale>     | y == 0 = ...
13:16:03 <Cale>     | y < 0 = ...
13:16:08 <Cale>   where y = x^2
13:16:13 <Cale> or some such
13:16:25 <shachaf> Cale: Hmm, OK.
13:16:26 <Cale> heh, probably better to use y = x^3
13:16:28 <shachaf> Cale: Thanks.
13:16:58 <Cale> You could never squeeze a let in between the function declaration and the guards otherwise
13:17:14 <jcreigh> benny_: cool. I'm not a cabal expert, but my understanding is that you have to install it (or register it manually) in order for cabal and GHC to be able to see and use the package.
13:17:26 <Cale> (unless you explicitly switched to using let and case)
13:17:37 <jcreigh> I usually just use the build/install stanza that I gave you
13:18:05 <shachaf> Cale: Is there any reason Haskell doesn't have cond? (I know about case () where _, but still.)
13:18:16 <Cale> You could write cond
13:18:19 <Uncountable> Cale: rank is just the inverse function of the power tower (the inverse of 10^^n, specifically)?
13:18:41 <jcreigh> shachaf: guards are usually used to do the same thing.
13:18:49 <Cale> Uncountable: yeah, roughly.
13:18:54 <Sgeo> cond?
13:19:02 <benny_> jcreigh: it's just that I installed it the same way as mtl and X11, and they worked. (And from what I can see in the directory structure, they are similar.)
13:19:15 <jcreigh> shachaf: also, I've found http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html to be helpful when I'm wondering about syntax issues
13:19:15 <lambdabot> Title: Tour of the Haskell Syntax
13:19:48 <jcreigh> benny_: hmm, really? what OS is this?
13:19:50 <Cale> cond [] = error "cond: Failure to match any case"; cond ((True,y):xs) = y; cond ((False,y):xs) = cond xs
13:20:10 <benny_> jcreigh: archlinux
13:20:49 <shachaf> Cale: I guess that would work.
13:20:54 <Sgeo> :t fix
13:20:57 <lambdabot> forall a. (a -> a) -> a
13:20:57 <Cale> If you wanted, you could also add some nice notation for pairs, like data Guard a = Bool :-> a
13:21:00 <tcr> shachaf: I'd think that case's pattern matching + guards are actually superior to a simple cond.
13:21:12 <Cale> and write cond :: [Guard a] -> a
13:21:32 <jcreigh> benny_: debian has packages for x11 and mtl, and I was thinking you might have had them installed without realizing it. I don't know what the packaging situation for GHC is on arch.
13:21:55 <jcreigh> benny_: just because I'm curious, could you paste the output of "ghc-pkg list"?
13:21:56 <jcreigh> @paste
13:21:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:21:58 <benny_> jcreigh: oh, I packaged them myself. I didn't do anything different at those 2.
13:22:11 <benny_> mtl is in it but X11 isn't... but yes.
13:22:36 <Sgeo> > fix (2^)
13:22:37 <lambdabot>  Exception: <<loop>>
13:22:40 <Cale> shachaf: Laziness means that you don't need macros to do that sort of thing :)
13:22:47 <hpaste>  benny pasted "ghc-pkg list" at http://hpaste.org/1031
13:22:53 <sorear> Sgeo: that's the least fixed point
13:23:11 <Cale> least in the sense of least-defined
13:23:20 <Cale> not in the numerical ordering sense
13:23:41 <Cale> Not that (2^) has any other fixed points.
13:24:01 <sorear> infinity :)
13:24:22 <shachaf> Cale: Does using that cond have any effects on efficiency?
13:24:24 <Sgeo> I thought everything had a fixed point? (remembering something or other from lambda calculus)
13:24:33 <sorear> Sgeo: correct
13:24:36 <Cale> shachaf: nope
13:24:44 <sorear> Sgeo: *everything* has a unique fixed point
13:24:48 <Cale> shachaf: It'd be just like using guards, essentially.
13:24:53 <sorear> Sgeo: s/fixed/least fixed/
13:24:56 <Sgeo> So why isn't the thing finding it?
13:25:02 <sorear> Sgeo: it is finding it
13:25:16 <sorear> Sgeo: in this case, the least fixed point is _|_
13:25:31 <sorear> Sgeo: represented textually as "Exception: <<loop>>"
13:25:33 <Cale> Which represents failure or nontermination.
13:25:42 <tcr> I'd like to how best to convert a parse tree as defined by Language.Haskell.Syntax (http://haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-Haskell-Syntax.html) to another tree. I'd possibly have one simple root conversion function that I use to match against each of the nodes and convert them. I'm having trouble though.. as the returned parse tree is pretty much just a tree of lotsa nested constructors, each of different type, I ca
13:25:44 <lambdabot> http://tinyurl.com/y7g5rc
13:25:57 <sorear> tcr: @more
13:26:13 <Cale> tcr: "each of different type, I c" -- your message got cut off there
13:26:21 <ddarius_> @where scrap your boilerplate
13:26:21 <lambdabot> I know nothing about scrap.
13:26:29 <Cale> @where syb
13:26:30 <lambdabot> I know nothing about syb.
13:26:31 <Cale> hmm
13:26:44 <tcr> as the returned parse tree is pretty much just a tree of lotsa nested constructors, each of different type, I can't see how to do that best.
13:26:45 <jcreigh> benny_: hmm...well, I've no clue why that would work for X11 but not X11-extras. (However, I think xmonad explicitly depends on X11-extras version 0.0, you might want to change the version of X11-extras back to 0.0 and reinstall so that the version is right in the package DB)
13:27:00 <Cale> http://www.cs.vu.nl/Strafunski/gmap/
13:27:01 <lambdabot> Title: Scrap your boilerplate ... in Haskell
13:27:12 <Cale> You might have a look at this approach.
13:27:23 <tcr> Cale: was that directed at me?
13:27:26 <Cale> It takes a little reading to understand properly though.
13:27:27 <Cale> yeah
13:27:47 <benny_> jcreigh: okay... one can probably force a registering in the package db... :-) thanks!
13:28:52 <tcr> Cale: Unfortunately, I think I'm restricted to Haskell98. Is that stuff still be relevant then?
13:29:03 <Cale> I think so...
13:29:09 <tcr> Excuse my grammar.
13:29:18 <sorear> tcr: Language.Haskell.Parser isn't haskell98
13:29:20 <Cale> oh
13:29:22 <Cale> er
13:29:28 <Cale> no, maybe not
13:29:42 <Cale> It looks like the Data typeclass involves some rank-2 types
13:29:45 <sorear> tcr: for one thing, Haskell98 forbids . in module names
13:30:01 <Cale> oh, there's that too of course
13:30:26 <ddarius_> There's the hierarchical modules addendum
13:30:44 <Cale> yeah, which was approved :)
13:30:44 <sorear> ddarius_: *proposed* hierarchical modules addendum.
13:30:55 <sorear> Cale: it has?
13:31:04 <Cale> wasn't it?
13:31:12 <sorear> Cale: and they didn't announce a party on haskell@haskell.org?
13:31:59 <sorear> http://haskell.org/definition  -- still lists hierarichal modules as a candidate for acceptance
13:32:00 <lambdabot> Title: Language and library specification - HaskellWiki
13:32:13 <Cale> huh, that's interesting
13:32:35 <Cale> If that's the case, let's change the module path separator so something better
13:32:36 <jcreigh> how many years do people have to use something nearly universally before it's no longer a "candidate"? :)
13:32:40 <Cale> to
13:32:49 <dcoutts__> I think it still has not been officially adopted
13:33:03 <dcoutts__> haskell' will incorporate it of course
13:33:14 <Cale> Yeah, we still might decide that having a flat namespace for modules would be better. ;)
13:33:31 <jcreigh> heh. Haskell' is GHC--, right? :)
13:33:33 <ddarius> Maybe we are waiting for first class modules
13:33:40 <tcr> sorear: Actually, I'm using haskell-src-exts which I thought of to be portable, but I'm not exactly sure.
13:33:45 <Cale> ddarius: good point
13:34:19 <Cale> I'd rather | (with no spaces allowed) were the module path separator
13:34:19 <Sgeo> Is something like `iterate f x !! 5` the best way to apply f to x 5 times?
13:34:27 <Sgeo> Or is there a better way?
13:34:41 <Cale> Sgeo: that's a fine way
13:35:17 <Cale> It does build up the expression before evaluating any of it though.
13:35:28 <Cale> So if 5 is very large, you could get a stack overflow.
13:36:06 <Sgeo> @src iterate
13:36:06 <lambdabot> iterate f x =  x : iterate f (f x)
13:36:48 <Cale> Note that's not  iterate f x = x `seq` x : iterate f (f x)
13:37:14 <Sgeo> Cale, hm?
13:37:28 <Cale> So it won't force the evaluation of the expression as it goes along.
13:37:39 <emu> @hoogle iterate'
13:37:39 <lambdabot> No matches found
13:37:57 <Cale> So, for instance...
13:38:09 <ddarius> > iterate (+1) 0 !! 10000000
13:38:13 <lambdabot> Terminated
13:38:15 <tcr> Cale: (re: that generic website) Afaics, that would even require haskell-src-exts data declarations to be changed.
13:38:24 <sioraiocht> does `seq` exist in ghc or just gph?
13:38:39 <Igloo> It's a Haskell 98 function
13:38:53 <tcr> Cale: What's the portable way of grovelling such a tree?
13:39:02 <sorear> by hand!
13:39:14 <Cale> tcr: manually, yeah
13:40:05 <Cale> iterate (+1) 0 !! 3
13:40:12 <Cale>  = (0 : iterate (+1) (0+1)) !! 3
13:40:17 <Cale>  = iterate (+1) (0+1) !! 2
13:40:22 <Cale>  = ((0+1) : iterate (+1) ((0+1)+1)) !! 2
13:40:26 <Cale>  = iterate (+1) ((0+1)+1) !! 1
13:40:42 <mbishop> portability is overrated
13:40:45 <ddarius> > iterate (+1) 0 !! 1000000
13:40:46 <Cale>  = (((0+1)+1) : iterate (+1) (((0+1)+1)+1)) !! 1
13:40:48 <lambdabot>  Exception: stack overflow
13:40:53 <ddarius> Yay
13:40:58 <Cale>  = iterate (+1) (((0+1)+1)+1) !! 0
13:41:12 <Cale>  = ((((0+1)+1)+1) : iterate (+1) (((0+1)+1)+1)) !! 0
13:41:24 <Cale>  = ((0+1)+1)+1
13:41:29 <Cale>  = (1+1)+1
13:41:32 <Cale>  = 2+1
13:41:34 <Cale>  = 3
13:41:39 <tcr> Well, yeah, but how? I mean, I'd like to write something like convert HsModule bar foo fuz quux = grovel grovel ; convert HsDecl qwerty asdf dvorak = grovel2 grovel2 and so on. But I don't see how to do that given that HsModule and HsDecl are completely different types. (I should note that I'm fairly new to Haskell.)
13:41:44 <Cale> That's how the evaluation proceeds.
13:41:51 <Cale> That's what I mean by "building up expressions"
13:42:03 <Cale> Sgeo: does that make sense?
13:42:16 <Sgeo> I..guess..
13:42:29 <Cale> Lazy evaluation is outermost-first.
13:42:33 * Sgeo is too lack-of-attention-spanned to notice
13:42:39 <Cale> ah, okay
13:43:14 <Cale> well, the important thing here is that once the !! was removed, we were left with something like ((0+1)+1)+1
13:43:20 <tcr> mbishop: Not if it it's within the requirements. :)
13:43:35 <Cale> Which, if we'd used 10000000 instead of 3, would be a gigantic expression
13:43:47 <Cale> and would use lots of memory
13:44:12 <ddarius> > let iterate' f x = x `seq` x : iterate' f (f x) in iterate' (+1) 0 !! 10000000
13:44:16 <lambdabot> Terminated
13:44:23 <ddarius> > let iterate' f x = x `seq` x : iterate' f (f x) in iterate' (+1) 0 !! 1000000
13:44:25 <lambdabot>  1000000
13:44:41 <Cale> that will run in constant space, by contrast
13:45:24 <Cale> This is one of those cases where strict evaluation is better -- we're reducing a "large" structure to a "small" one.
13:46:32 <Vq^> Cale: would it be possible to have an unboxed integer to achive constant space in that example?
13:47:21 <Cale> Yes.
13:47:39 <dcoutts> {-# RULE "strict foldl" forall (f :: !b -> a -> b) . foldl f = foldl' f #-}
13:48:09 <Cale> Except I don't know whether that's okay with iterate's polymorphism.
13:49:19 <nominolo> sioraiocht: what are you going to do in the UK then?
13:49:24 <nominolo> sioraiocht: phd?
13:49:30 <sjanssen> dcoutts: if only that really worked
13:49:32 <ddarius> dcoutts: We should just switch foldl and foldl'
13:49:40 <sioraiocht> nominolo: starting my MSc
13:49:58 <sioraiocht> nominolo: I'm finishing up my BSc in Computer Science right now
13:50:00 <dcoutts> ddarius: they're not the same of course and haskell usually uses the most lazy version as the standard spec
13:50:07 <Cale> I don't know about *switching* foldl and foldl', but foldl' should certainly be in the prelude.
13:50:12 <dcoutts> sjanssen: it's on my wish list
13:50:40 <ddarius> dcoutts: True, but foldl is almost never what you want.
13:50:44 <dcoutts> Cale: I think it's a hack, what we need is the above rule, not two versions of every function
13:50:54 <dcoutts> ddarius: yes I know :-(
13:51:07 <dcoutts> ddarius: except for arrays where it's fine
13:51:11 <nominolo> sioraiocht: ah, ok.  have a good topic for you BSc thesis? (mine was pretty boring)
13:51:13 <dcoutts> since foldl folds from the back
13:51:28 <dcoutts> as does foldr'
13:51:32 <sorear> dcoutts: better yet, have the garbage collector evaluate reductive things like 1+2
13:51:37 <sorear> dcoutts: (i wish)
13:51:47 <Cale> dcoutts: That ! in the type signature above means that the strictness analyser has detected that parameter as strict?
13:52:05 <sioraiocht> nominolo: I don't have a thesis requirement for my BSc., it's not common in the US
13:52:10 <dcoutts> sorear: mm, I think that kind of thing is better done at compile time by specialisation on types/strictness
13:52:25 <dcoutts> Cale: right. that's my fantasy syntax.
13:52:29 <sorear> GRIN ftw...
13:52:36 <Cale> That would be nice.
13:52:46 <ddarius> dcoutts: I don't like leaving things like that to the strictness analyzer.
13:52:50 <Cale> I wonder how hard it'd be to implement that.
13:53:13 <dcoutts> ddarius: there are more sophisticated strictness analysers about than the one ghc uses currently
13:53:50 <nominolo> sioraiocht: i see
13:53:51 <dcoutts> ddarius: also, I think people are nervous about the strictness analysis because they don't know how well it works, we should make it easier to look up the strictness that ghc has inferred
13:53:52 <Cale> I think that it would be good if we generally could leave things like that to the strictness analyser
13:54:05 <dcoutts> Cale: I agree
13:54:06 <Cale> and worry about explicit seq and strictness annotations less and less
13:54:08 <sorear> dcoutts: it's documented on the wiki
13:54:16 <ddarius> dcoutts: Yeah, but no strictness analyser is going to always get it.
13:54:26 <dcoutts> sorear: yeah, but it's not easy, not like :type in ghci
13:54:38 <sorear> #Haskell Show of Hands: Do you know how to look up strictness?
13:54:52 <sioraiocht> Nope
13:54:53 <nominolo> nominolo: good luck then.  you might be pretty close to the next hackatlon :)
13:54:55 <Cale> ddarius: It ought to be able to get it if the function specified has an explicit strictness annotation in it. :)
13:54:57 <ddarius> sorear: It's a PITA
13:55:03 * sorear curses gcc
13:55:15 <dcoutts> ddarius: no, but if ghc(i) tells you what it inferred then you can add a bit more explicit strictness and until it has the strictness you expect.
13:55:29 <sorear> #import "types.h"
13:55:38 <sorear> and gcc didn't complain...
13:55:41 <Cale> :strictness <expr>
13:55:46 <sorear> at least we have -fglasgow-exts
13:55:57 * sorear goes to add -ansi -pedantic to all his makefiles
13:56:29 <nominolo> sorear: heh
13:58:10 <dalexandre> Hi people, i want read a file content into a string and pass this string as parameter to another function
13:58:16 <ddarius> Couldn't we have it go the other way.  Newbies are not going to know this strictness stuff nor know the properties of foldl.
13:58:17 <dalexandre> How can i do this?
13:58:28 <ddarius> @type readFile
13:58:30 <lambdabot> FilePath -> IO String
13:58:39 <sjanssen> do s <- readFile; print (someFunction s)
13:58:43 <Cale> main = do x <- readFile "myfile"; let y = f x; print y
13:59:04 <ddarius> readFile >>= print . someFunction
13:59:36 <Cale> print . someFunction =<< readFile "someFile"
13:59:45 <Cale> Don't forget the filename parameter
13:59:51 <ddarius> Oh yeah, filename
14:00:36 <dalexandre> i dont want print the result
14:00:39 <Cale> dalexandre: If you're completely unfamiliar with IO in Haskell, I can point you at a 5-minute orientation which should help you a bit to get started
14:00:44 <sorear> I am an *expert*. I do *not* want to suffer from newbie defaults.  Haskell is AFAICT the *only* language that doesn't pander to newbies.  *Please* don't change that.
14:01:06 <ddarius> sorear: Even experts want foldl'!
14:01:15 <Cale> dalexandre: oh, then you can do something else with the result instead, but eventually somewhere in your program you're going to want to do output
14:01:37 <sorear> ddarius: experts want simple underlying rules.
14:01:52 <ddarius> sorear: Which is -exactly- what I'm suggesting.
14:01:56 <sorear> ddarius: "Anything without ' is fully lazy in the sense of Hughes" is something I can remember.
14:01:56 <dalexandre> Cale  5-minute orientation will be a good ideia
14:02:19 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
14:02:20 <lambdabot> Title: Introduction to IO - HaskellWiki
14:02:32 <ddarius> @hoogle
14:02:32 <lambdabot> HOOGLE - Haskell API Search
14:02:32 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
14:02:32 <lambdabot>  
14:02:36 <ddarius> @hoogle '
14:02:36 <lambdabot> Hoogle Error: Parse Error: Unexpected character '''
14:02:51 <dalexandre> i'm new in haskell programing language, i'm doing a work for the university
14:03:00 <tcr> Is there a TAGS file generator for haskell source files? Or how do you make M-. in Emacs work?
14:03:01 <sorear> ' doesn't begin identifiers :)
14:03:08 <sorear> @where hasktags
14:03:09 <lambdabot> http://www.cl.cam.ac.uk/users/rje33/software.html
14:03:23 <ddarius> sorear: I was hoping it would find all identifiers with ' in it.
14:03:35 <ddarius> I guess ' would be $!
14:03:40 <sorear> dalexandre: work meaning paid employment or educational/testing work?
14:04:16 <dalexandre> educational work
14:04:52 <tcr> sorear: (That link didn't work) Thanks!
14:05:14 <sorear> tcr: If you found it:
14:05:18 <sorear> @help where+
14:05:18 <lambdabot> where+ <key> <elem>. Define an association
14:05:41 <dalexandre> the work is a family tree application using haskell and prolog
14:06:02 <ddarius> @google hasktags
14:06:05 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/utils.html
14:06:05 <lambdabot> Title: Chapter 10. Other Haskell utility programs
14:06:28 <tcr> ddarius: Thanks, I'm not stupid. I found it way already :)
14:06:41 <Cale> dalexandre: let me know if you have any trouble understanding that tutorial
14:06:50 <dalexandre>  51 main = do
14:06:51 <dalexandre>  52     putStr "InputFile: "
14:06:51 <dalexandre>  53     iFile <- getLine
14:06:51 <dalexandre>  54     content <- readFile iFile
14:06:51 <ddarius> tcr: I was not implying you were.
14:06:53 <dalexandre>  55     listaPessoas content
14:07:02 <Gwern> so, uh, does anyone know where the documentation on global variables in GHC is?
14:07:17 <sorear> Gwern: there are no good global variables
14:07:21 <dalexandre> Hugs.Base> :l projeto_parte1_dba.hs
14:07:21 <dalexandre> ERROR "projeto_parte1_dba.hs":51 - Type error in final generator
14:07:21 <dalexandre> *** Term           : listaPessoas content
14:07:21 <dalexandre> *** Type           : [String]
14:07:21 <dalexandre> *** Does not match : IO a
14:07:29 <Gwern> sorear: what about for configuration stuff?
14:07:36 <Gwern> beats passing around the variable by hand
14:07:41 <dalexandre> How i can convert content to string..
14:07:41 <Cale> dalexandre: just stick a  return () at the end of main
14:07:44 <sorear> Gwern: you can cheat, but it's not recommended for any program intented to be used twice
14:08:02 <Gwern> and I don't think it's a bad thing if it's set once and then never modified, like configuration parameters should be
14:08:14 <Cale> dalexandre: or change main's type to reflect that it's an IO action returning a list of strings
14:08:18 <sorear> Gwern: monad transformers!  (and the cheat is unsaferPerformIO (getConfig))
14:08:21 <Cale> er
14:08:23 <Cale> oh!
14:08:35 <Cale> listaPessoas content :: [String]
14:08:42 <Cale> it's not an action
14:08:45 <Gwern> sorear: I guess I should explain. I'm thinking of modifying darcs to support .darcs directories instead of _darcs, but the problem is, .darcs is hardwired into string arguments all over darcs
14:08:54 <dalexandre>  64 -- Lista todas as pessoas presentes na arvore genealogica
14:08:54 <dalexandre>  65 listaPessoas::String->[String]
14:08:54 <dalexandre>  66 listaPessoas [] = []
14:08:54 <dalexandre>  67 listaPessoas s
14:08:54 <dalexandre>  68     | (ehPessoa (esqStr s '\n')) = (esqStr s '\n'):(listaPessoas(dirStr s '\n'))
14:08:55 <dalexandre>  69     | otherwise = listaPessoas(dirStr s '\n')
14:08:57 <Cale> right
14:09:00 <Gwern> *in addition to, not instead of.
14:09:08 <Cale> So what do you want to do with that list of strings?
14:09:10 <Cale> print it?
14:09:11 <sorear> dalexandre: pastes longer than 5 lines or so are preffered to be sent to hpaste.org
14:09:19 <sorear> http://hpaste.org/new
14:09:29 <Cale> I don't need a paste of this quite yet.
14:09:33 <dalexandre> sorear, sorry
14:09:48 <sorear> dalexandre: not quite sorry-worthy
14:09:56 <Cale> Just need to know what the purpose of that list is.
14:10:08 <sorear> dalexandre: 16 lines in three small chunks is just under the accepted limit
14:10:24 <Cale> The lines of a do-block need to be IO actions to be run.
14:10:37 <Cale> That last line of your main is not an IO action, it's a list of strings.
14:10:37 <hpaste>  (anonymous) pasted "Project Help" at http://hpaste.org/1032
14:10:49 <dalexandre> http://hpaste.org/1032
14:11:14 <sorear> Gwern: (I'm not a darcs hacker) Wouldn't it be easier to do if (fileExists (".darcs")) ... in the code that reads+writes dirs?
14:11:40 <Cale> dalexandre: try  print (listaPessoas content)
14:11:48 <Gwern> sorear: I did try that, but it ended up messing up a lot of type signatures and introducing mutual dependencies between modules
14:12:08 <Gwern> and at that point, I decided I was simply going with the wrong approach and that there must be a better way
14:12:17 <dalexandre> Cale this works but when i try print leFilhos (listaPessoas content) doesn't work
14:12:28 <Cale> print (leFilhos (listaPessoas content))
14:12:51 <Cale> or:  print . leFilhos . listaPessoas $ content
14:13:11 <Cale> depending on how much you hate parens :)
14:14:10 <Cale> what you wrote was passing  leFilhos, and listaPessoas content as two separate parameters to print, which is a type error
14:14:27 <dalexandre> Cale the problem is the follow
14:14:30 <shachaf> Cale: I've been wondering, is "f . g . h $ a" more standard than "f $ g $ h $ a" ?
14:14:40 <Cale> shachaf: it is now :)
14:15:04 <dalexandre> before the tree family was separated by a semicolon (;) like  49 arvore = "1.1. Ildefonso;;1.1. Ildefonso // Vo Mariquinha;1.1.1. Angelin;1.1.3. Florinda;;1.1. Ildefonso // Vo Mariquinha    ;1.1.1. Angelin // Madalena;1.1.1.1. Diogenes;1.1.1.2. Abraao;1.1.1.3. Joao"
14:15:14 <Cale> shachaf: The version with composition is slightly nicer for refactoring, and will be stable in the event that the associativity of $ changes.
14:15:24 <ddarius> Or so Cale likes to give the newbies the impression
14:15:44 <matthew-_> shachaf: it's slightly strange - I used to use $ a lot and . very little, but recently I've started using . a lot more. I guess you get better at thinking in terms of data flow with .
14:15:48 <dalexandre> but now the tree family is in a text file in place of ; is a newline
14:16:02 <Cale> (and the associativity of ($) deserves to change, in my opinion)
14:16:15 <shachaf> Cale: Why?
14:16:38 <dalexandre> if you look the code i have changed de filtrar (/=) ';' to filtrar (/=) '\n'
14:16:48 <Cale> It would let us remove even more parens, and function application is naturally left associative
14:17:04 <Cale> Also, $! is awkward to use with more than one parameter due to this right-associativity
14:17:22 <Cale> and the associativity of $ and $! really ought to match
14:17:36 <matthew-_> $!      If used numerically, yields the current value of the C "errno" variable, or in other words, if a system or
14:17:38 <matthew-_>                library call fails, it sets this variable.
14:17:47 <Cale> uhh, no :)
14:17:49 <matthew-_> mmm. Is haskell taking on Perl ? ;-)
14:18:04 <Cale> $! is strict function application
14:18:11 <Cale> f $! x = x `seq` f x
14:18:28 <matthew-_> I knew that! mind is being slow...
14:18:43 <matthew-_> and, in the presence of $s, defaults to Perl mode!
14:19:01 <Cale> The problem with it being right associative is when you have f x y, and you want to force x and y to be evaluated before being passed to f.
14:19:10 <Cale> You can't just write f $! x $! y
14:19:18 <Cale> you have to write (f $! x) $! y
14:19:34 <Cale> because the first thing means f $! (x $! y)
14:19:39 <matthew-_> true
14:19:57 <Cale> which you almost never want in this case of making things strict
14:20:07 <Saizan> is there a reason for its current associativity?
14:20:15 <Cale> To match the associativity of ($)
14:20:34 <Cale> which is right associative, because people want to abuse it to simulate function composition
14:20:44 <Cale> which is silly, because there's a proper function composition operator
14:20:58 <Saizan> right
14:21:07 <norpan> but $ is application, not composition
14:21:11 <Cale> right
14:21:19 <sorear> Cale: $! should be infixl 10
14:21:24 <Cale> and application is supposed to be left associative
14:21:44 <norpan> but application is just space in haskell
14:21:46 <Cale> sorear: I agree, and think $ should be too
14:21:47 <tilk> hm, I always thought about $ as "there are parentheses from here to the last place possible"
14:21:50 <Cale> norpan: yep
14:22:01 <norpan> so $ is right associative application
14:22:07 <norpan> nothing wrong with that
14:22:08 <Cale> norpan: because it's by far the most common operation, so we give it the most convenient notation of all
14:22:12 <sorear> Cale: if $ was infixl 10, what purpose would it serve?
14:22:14 <matthew-_> Cale, you could just put bang patterns on the params in f and then it'd be strict ;-)
14:22:22 <sorear> Cale: messing up rankn types?
14:22:26 <Cale> norpan: I don't want that though.
14:22:35 <norpan> so don't use $
14:22:39 <norpan> if you don't want it
14:22:46 <Cale> norpan: I just want a low-precedence left-associative function application
14:22:51 <norpan> so define it :)
14:22:56 <matthew-_> use  - they're worth more anyway!
14:23:04 <norpan> 
14:23:19 <Cale> and I'm also sick of seeing ($) be abused to simulate (.)
14:23:24 <norpan> then you get to use utf-8
14:23:56 <oren> Hi guys, sorry to bother you again... Working out on this streaming parser thing, I hit on the idea I can do short-circuit in a Monad if I knew the result type was a MonadPlus. So... How can I restrict a Monad to only accept MonadPlus values?
14:24:01 <Cale> Even if the associativity of ($) was swapped to be left associative, you could still rewrite f $ g $ h $ x as f . g . h $ x
14:24:02 <matthew-_> mmm. and then we're back to the old ghc-doesn't-deal-with-unicode-properly...
14:24:03 <oren> If that is possible at all, I mean :-)
14:24:20 <Cale> and using other characters is annoying
14:24:27 <Cale> because they're harder to type
14:24:39 <matthew-_> oren, do you mean that your monad should be an instance of monadplus?
14:24:43 <Cale>  takes 3 keystrokes for me
14:24:53 <sorear> <sorear> Cale: $! should be infixl 10                                     [14:20]
14:24:53 <sorear> <Cale> sorear: I agree, and think $ should be too
14:24:53 <sorear> But then what would $ be good for?
14:24:55 <norpan> how about 
14:25:08 <Cheery> I'd like to get a list of floating points, like: [0.0, 0.01, 0.02.. 1.0], what I know is how many I want and the beginning and ending range, do you know a function which would do this for me already?
14:25:15 <matthew-_> oren, if so, rather than (Monad m) => m a -> ... use (MonadPlus m) => m a -> ...
14:25:17 <oren> matthew: Nope, I mean I have a type - say "Parser a", and I do "instance Monad Parser where ..." - I want to use the fact "a" is MonadPlus
14:25:35 <Cale> sorear: oh, 10
14:25:35 <sorear> Cale: if you give '$' the same fixity as '', what purpose would '$' serve?
14:25:38 <oren> Specifically I really would like to have mzero :-)
14:25:40 <Saizan> > [0.0, 0.01 .. 1.0]
14:25:41 <lambdabot>  [0.0,1.0e-2,2.0e-2,3.0e-2,4.0e-2,5.0e-2,6.0000000000000005e-2,7.0e-2,8.0e-2,...
14:25:48 <Cale> sorear: I missed the 1 somehow
14:25:58 <sorear> Cale: makes sense now, sorry :)
14:26:06 <matthew-_> oren, just define instance MonadPlus Parser where ...?
14:26:18 <oren> I tried adding "MonadPlus m => ... (m a)" in every place I could think of, no luck - all I get is kind errors
14:26:24 <Gwern> dammit. looks like GHC handles configuration data as global variables implemented through a C preprocessor? http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/driver.html
14:26:25 <lambdabot> Title: The GHC Commentary - The Glorious Driver, http://tinyurl.com/yoheyv
14:26:53 <sorear> Gwern: you are looking at an *very* obsolete document
14:26:56 <oren> Hmmm... silly me. Makes sense. Let me try...
14:26:58 <sorear> @where commentary
14:26:58 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary
14:27:14 <dalexandre> how i change ao \n in a string to another character like ";" ?
14:27:17 <Gwern> sorear: well, I looked at the Main for GHC, and it seemed to be accurate in so far as the mention of definitions
14:27:31 <Cheery> hmm, Saizan, maybe I can work with that.
14:27:35 <Cheery> thanks.
14:27:41 <Cale> hmm "The Glasgow Haskell Compiler (GHC) Commentary [v0.9]"
14:27:51 <Cale> from 2001
14:28:00 <oren> Nope, that doesn't work - I want "a" to be MonadPlus, not "Parser".
14:28:01 <dalexandre> Cale how i change ao "\n" in a string to another character like ";" ?
14:28:15 <matthew-_> oren, I may be being slightly slow this evening - you will have to *add* the instance of MonadPlus in addition to the instance of Monad. Feel free to use @paste
14:28:28 <oren> Put another way, how can I do "MonadPlus m => type Parser result = P (State -> (State, (m result))" ?
14:28:31 <Saizan> Cherry: if you want a function there's an equivalent method in the Enum class, which that notation is synctatic sugar for
14:28:35 <Cale> dalexandre: perhaps  concat . intersperse ";" . lines
14:28:44 <mauke> dalexandre: map?
14:28:49 <oren> That is, how can I say you can only do "Parser some_type" if "some_type" is MonadPlus?
14:28:59 <Cale> > concat . intersperse ";" . lines $ "a\nb\nc"
14:29:00 <lambdabot>  "a;b;c"
14:29:07 <Cale> > concat . intersperse ";" . lines $ "a\nb\nc\n"
14:29:09 <lambdabot>  "a;b;c"
14:29:10 <matthew-_> oren, oh, MonadPlus a => Parser a
14:29:12 <mauke> > map (\c -> if c == '\n' then ';' else c) "This\nis\nnot\nenough\nbroccolis\n\n"
14:29:13 <lambdabot>  "This;is;not;enough;broccolis;;"
14:29:14 <Cale> > concat . intersperse ";" . lines $ "a\nb\nc\n\nd"
14:29:15 <lambdabot>  "a;b;c;;d"
14:29:38 <Cale> depends on which behaviour you want
14:29:54 <matthew-_> oren, paste code at  http://hpaste.org/new
14:30:00 <Cale> lines will strip off trailing newlines
14:30:12 <matthew-_> yeah, if you want a non-weird-ass version of lines, write your own ;-)
14:30:25 <Saizan> oren: when you define a monad it should work with any types, so maybe you should use data Parser m result = P (State -> (State, (m result)) and instance MonadPlus m => Monad (Parser m) where
14:30:44 <dalexandre> Projeto> concat . intersperse ";" . lines $ "a\nb\nc\n\nd"
14:30:44 <dalexandre> ERROR - Undefined variable "intersperse"
14:30:57 <Cale> dalexandre: intersperse is defined in Data.List
14:31:31 <dalexandre> sorry how a i can use this?
14:31:41 <Cale> Is this hugs or GHC?
14:31:46 <dalexandre> hugs
14:31:56 <Cale> Then :also Data.List
14:32:19 <Cale> Or, in your Projeto.hs, add a line at the top of the module saying  import Data.List
14:32:38 <Cale> (just below the module declaration, if any)
14:33:27 <hpaste>  oren pasted "MonadPlus constraint for Monad short-circuit" at http://hpaste.org/1033
14:34:00 <oren> Saizan: That looks like what I'm after, let me try
14:34:54 <dalexandre> Cale with this code i can do the reverse change all the ";" to "\n" to write to a file ?
14:35:27 <matthew-_> can't you put class constraints on data declarations?
14:36:11 <matthew-_> oh and the other one I've seen recently is, in the context of MonadPlus, should you use mzero or fail ?
14:36:35 <mauke> > map (\c -> if c == ';' then '\n' else c) "This;is;enough;broccolis;;"
14:36:37 <lambdabot>  "This\nis\nenough\nbroccolis\n\n"
14:36:55 <Cale> dalexandre: see what mauke wrote
14:36:56 <Saizan> matthew-_: you can, but they just limit you when you use the constructor instead of also adding contraint when that type is used
14:37:36 <Saizan> ?src MonadPlus
14:37:36 <lambdabot> Source not found. stty: unknown mode: doofus
14:38:53 <hpaste>  oren annotated "MonadPlus constraint for Monad short-circuit" with "2nd attempt" at http://hpaste.org/1033#a1
14:39:32 <oren> Saizan: I tried your way, I still get type errors. Can you take a peek at my hpaste?
14:39:54 <matthew-_> > fail "foo" :: Maybe a
14:39:55 <lambdabot>  Nothing
14:39:58 <matthew-_> vs
14:40:03 <matthew-_> > mzero :: Maybe a
14:40:04 <lambdabot>  Nothing
14:40:28 <dalexandre> what is wrong here
14:40:31 <dalexandre>  55 main = do
14:40:31 <matthew-_> but, this is the weirdest thing, I'm sure that the other day I was playing with this and left the string off on fail and it was ok
14:40:31 <dalexandre>  56     putStr "InputFile: "
14:40:31 <dalexandre>  57     iFile <- getLine
14:40:31 <dalexandre>  58     content <- readFile iFile
14:40:31 <dalexandre>  59     print concat . intersperse ';' . lines $ content
14:40:57 <augustss> print . concat
14:41:28 <dalexandre> Data.List> :l projeto_parte1_dba.hs
14:41:28 <dalexandre> ERROR "projeto_parte1_dba.hs":55 - Type error in application
14:41:28 <dalexandre> *** Expression     : intersperse ';' . lines
14:41:28 <dalexandre> *** Term           : intersperse ';'
14:41:28 <dalexandre> *** Type           : [Char] -> [Char]
14:41:29 <dalexandre> *** Does not match : [String] -> [Char]
14:41:40 <sorear> dalexandre: print . concat
14:41:41 <augustss> Do you really want print?  And not putStrLn?
14:42:16 <encryptio> @pl \s -> zip (inits s) (tails s)
14:42:16 <lambdabot> liftM2 zip inits tails
14:42:20 <dalexandre> i print just to see with work but i want to write the result to a file, or hold the result into a "variable"
14:42:39 <mauke> dalexandre: putStrLn (concat (intersperse ";" (lines content)))
14:43:23 <jcreigh> ah, I wondered why Data.Set wasn't a monad...
14:43:29 <ddarius> > let s = [1,2,3,4] in zip (inits s) (tails s)
14:43:30 <lambdabot>  [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
14:44:36 <dalexandre> mauke how i can store the return of (concat (intersperse ";" (lines content))) to another functions out of main have access
14:44:51 <Saizan> oren: the problem is that you are not really writing a monad, but a monad transformer, and i've not a clear idea of how to do this, maybe you should look at the definition of StateT?
14:45:03 <hpaste>  oren annotated "MonadPlus constraint for Monad short-circuit" with "Got it - using Maybe - Thanks!" at http://hpaste.org/1033#a2
14:45:22 <ekidd> Ow. Ow. Ow.
14:45:22 <mauke> dalexandre: well, you could say  let foo = concat (intersperse ";" (lines content))  and pass foo to other functions
14:45:33 * ekidd is trying to understand adjoint functors
14:46:36 <Saizan> oren; ah, your need was simpler than what it seemed :)
14:46:38 <ddarius> ekidd: THINK REPRESENTABILITY
14:46:45 <dalexandre> mauke:  55 main = do
14:46:45 <dalexandre>  56     putStr "InputFile: "
14:46:45 <dalexandre>  57     iFile <- getLine
14:46:45 <dalexandre>  58     content <- readFile iFile
14:46:45 <dalexandre>  59     let arvore = concat (intersperse ";" (lines content))
14:47:01 <ddarius> Hom(F-,=) ~ Hom(-,G=)
14:47:13 <dalexandre> in other function i want to use arvore like:  98 -- Lista todos os filhos de todas as pessoas presentes na arvore genealogica
14:47:14 <dalexandre>  99 leFilhos::[String]->[String]
14:47:14 <dalexandre> 100 leFilhos [] = []
14:47:14 <dalexandre> 101 leFilhos (x:xs) = (listaFilhos x (listaPessoas arvore)) ++ (leFilhos xs)
14:47:15 <Saizan> ?source Control.Monad.State
14:47:15 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
14:47:26 <stranger> Can I ask beginner type questions in here?
14:47:31 <sorear> stranger: yes.
14:47:32 <mauke> stranger: sure
14:47:33 <oren> Saizan: Obviously :-) I'm a Haskell newbie...
14:47:34 <ekidd> ddarius: Thanks!
14:47:40 <ddarius> ekidd: Grok representability in fullness and all of category theory will follow.
14:47:42 <oren> Thanks gues!
14:47:47 <dalexandre> mauke but this error appears in hugs: Data.List> :l projeto_parte1_dba.hs
14:47:47 <dalexandre> ERROR "projeto_parte1_dba.hs":101 - Undefined variable "arvore"
14:47:59 <sorear> stranger: the only kind of question you are not allowed to ask is: permission to ask questions
14:48:12 <mauke> dalexandre: I said "pass it to other functions"
14:48:13 <sorear> stranger: just assume you can ask
14:48:24 <mauke> dalexandre: you can't just use local variables where they don't exist
14:49:14 <stranger> Can anyone please have a look at this: http://hpaste.org/1034
14:49:38 <dalexandre> mauke i can't hold the result in a global variable?
14:50:46 <mauke> dalexandre: variables are constants
14:51:01 <jcreigh> dalexandre: basically, no. there's not really such a thing as a global variable in Haskell.
14:51:30 <jcreigh> dalexandre: (well, there's ways to do it, but it's almost certainly a bad idea)
14:51:52 <Saizan> stranger: i think you can't
14:52:56 <stranger> oh well
14:53:26 <sjanssen> stranger: sort . nub is slow
14:53:41 <jcreigh> bloody queen's pawn openings...
14:53:47 <sjanssen> map head . group . sort -- is better
14:53:48 <jcreigh> sjanssen: what do you mean?
14:53:51 <norpan> playing chess eh
14:53:59 <jcreigh> yeah, a bit
14:54:08 <sjanssen> jcreigh: O(n^2)
14:54:13 <stranger> sjanssen: I know, it's just a simple example
14:54:13 <norpan> jcreigh: quote the moves
14:54:50 <jcreigh> norpan: d4 :)
14:55:20 <jcreigh> norpan: I've never taken the time to learn any sort of opening theory...as a result, I'm always somewhat at a loss when confronted with less common openings.
14:55:42 <hyrax42_> jcreigh: where are you playing
14:55:47 <jcreigh> net-chess.com
14:56:00 <jcreigh> free correspondence chess
14:56:08 <jcreigh> I also play on FICS when the mood strikes.
14:56:11 <hyrax42_> pbem?
14:56:33 <jcreigh> hyrax42_: basically, yes. but through their web interface.
14:56:46 <hyrax42_> so similar to red hot pawn then?
14:56:51 <hyrax42_> redhotpawn.com
14:57:45 <jcreigh> dunno, never heard of it. net-chess.com is basically an interface to have multiple games concurrently with very long (30d+2d, for example) time limits.
14:57:59 <hyrax42_> ya sounds like same
15:01:06 <stranger> So, can anyone explain 'why' my simple set example is not a valid Functor?
15:01:14 <stranger> I'm not sure I understand.
15:01:39 <mauke> to be a functor, a type must support all element types
15:01:48 <mauke> yours imposes an Ord constraint
15:02:03 <jcreigh> I believe that Data.Set is not a monad for the same reason.
15:02:57 <stranger> And there is no way around this?
15:05:16 <sjanssen> stranger: you can use a slightly modified functor class instead
15:06:07 <sjanssen> class Functor' f b where fmap :: (a -> b) -> f a -> f b -- for example
15:06:47 <jcreigh> hmm? isn't that what standard Functor is?
15:06:55 * jcreigh goes off to read the haskell report...
15:07:11 <sjanssen> jcreigh: no, Haskell's class is class Functor f where ...
15:07:17 <dibblego> I think multi-parameter type-classes are a GHC extension
15:07:44 <mauke> class Functor a b f' f | f -> a, f' -> b, f -> f' where fmap :: (a -> b) -> f -> f'  -- does that work?
15:07:56 <stranger> I don't know anything about multi-parameter typeclasses, sorry
15:08:03 <stranger> still learning Haskell 98
15:08:38 <sjanssen> stranger: the problem is that fmap's signature says it works for any contained type
15:09:02 <sjanssen> but the Set instance requires a restriction (Ord) on the contained type
15:09:08 <dalexandre> mauke i have resolved the problem passing the arvore to the function
15:09:31 <ddarius> class OrdFunctor f where ofmap :: (Ord a, Ord b) => (a -> b) -> (f a -> f b)
15:09:33 <dalexandre> but now when i try to write the result to a file this error appear
15:09:45 <dalexandre> Projeto> :l projeto_parte1_dba.hs
15:09:46 <dalexandre> ERROR "projeto_parte1_dba.hs":52 - Type error in application
15:09:46 <dalexandre> *** Expression     : writeFile oFile (leiaArvore arvore)
15:09:46 <dalexandre> *** Term           : leiaArvore arvore
15:09:46 <dalexandre> *** Type           : [String]
15:09:46 <dalexandre> *** Does not match : [Char]
15:09:58 <ddarius> concat
15:10:24 <jcreigh> :t ["This", "is", "a", "list", "of", "strings"]
15:10:26 <lambdabot> [[Char]]
15:10:31 <jcreigh> :t "This is a string"
15:10:34 <lambdabot> [Char]
15:10:41 <jcreigh> String is an alias for [Char]
15:11:14 <sorear> @src String
15:11:14 <lambdabot> type String = [Char]
15:11:27 <augustss> stranger: there are other ways around your problem that does not require a new Functor class
15:11:56 <mux> > (+1) `fmap` (2,3)
15:11:57 <lambdabot>  (2,4)
15:12:09 <mux> hum
15:12:10 <dalexandre> jcreigh, then for each element in tail i need to concat with the head ok?
15:12:17 <augustss> stranger: but they are not very nice
15:12:26 <mux> @pl \f (x,y) -> (f x, f y)
15:12:26 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
15:12:30 <jcreigh> dalexandre: like ddarius says, you just need concat
15:12:34 <mux> ouch
15:12:38 <jcreigh> > concat ["list", "of", "strings"]
15:12:39 <lambdabot>  "listofstrings"
15:13:02 <shachaf> mux: ***
15:14:03 <shachaf> mux: Wait, no.
15:14:48 <augustss> :t (***)
15:14:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:14:57 <dolio> ?type join (***)
15:15:00 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:15:14 <dalexandre> jcreigh, thanks work... with concat i can put a "\n" between the elements of the list ?
15:15:15 <mux> ah yeah
15:15:19 <dolio> > join (***) (+1) (2, 3)
15:15:20 <lambdabot>  (3,4)
15:15:26 <mux> thanks
15:15:27 <dons> ?users
15:15:27 <lambdabot> Maximum users seen in #haskell: 336, currently: 320 (95.2%), active: 54 (16.9%)
15:16:02 <augustss> > join (**) 10
15:16:03 <lambdabot>  1.0e10
15:16:16 <shachaf> dolio: That's it.
15:16:23 <shachaf> dolio: There's no predefined function that does that?
15:16:45 <dolio> That does \x -> x ** x?
15:17:44 <dons> ah nice, awj on reddit is now blogging about haskell, http://a-w-j.blogspot.com/2007/03/learning-haskell.html
15:17:52 <Botje> dalexandre: unlines
15:17:54 <lambdabot> Title: Armchair programming at its finest: Learning Haskell...
15:18:24 <sorear> hi dons.
15:18:32 <dons> jcreigh: there's still some bugs in the new xmonad patch.
15:18:36 <dolio> dons: I don't know if you already responded to this this morning, but I have some somewhat list-heavy code, if you're still looking for such stuff.
15:18:36 <augustss> @check (join logBase == id)
15:18:37 <lambdabot>   add an instance declaration for (Eq (a -> a))     In the expression: ((join...
15:18:43 <dons> dolio: indeed i am!
15:18:56 <dolio> dons: http://haskell.org/haskellwiki/Haskell_Quiz/SimFrost/Solution_Dolio
15:18:58 <lambdabot> Title: Haskell Quiz/SimFrost/Solution Dolio - HaskellWiki, http://tinyurl.com/2cjf53
15:19:10 <chessguy> "armchair programming", that's an interesting term
15:19:19 <dalexandre> bolrod, thankls
15:19:36 <dons> jcreigh: go to a new workspace, create 2 xterms then 'j' into xterm 1. focus is lost. now go back to xterm 2, and try to switch to screen 1, it is empty (not brought back into focus).
15:19:43 <mux> gaaah
15:19:54 * mux getting lost with fromIntegral
15:19:56 <Cheery> @where vector math
15:19:56 <lambdabot> I know nothing about vector.
15:20:02 <sorear> dons: all these patches from jyp are making me very interested.  I might just have to give yi another try.  My goals of ridding my system of Linux+Emacs may be realized sooner than I think...
15:20:11 <dons> jcreigh: i'm actually going to unapply those xineram patches for now.
15:20:17 <dons> sorear: yes, it appears so!
15:20:18 <Cheery> Does somebody of you know a vector math library written in haskell?
15:20:22 <mux> how would I write (x - y) / 2 if x and y and Int's ?
15:20:31 <dons> i'd like jyp to maybe get some support on haskell-cafe@ and just take the project out there.
15:20:38 <mux> and I want the result to be a Double
15:20:47 <sjanssen> sorear: what replaces Linux?
15:20:58 <sorear> sjanssen: house, or maybe ayhi
15:21:05 <Cheery> plan9
15:21:09 <dolio> > fromIntegral (2 :: Int) / 2
15:21:10 <lambdabot>  1.0
15:21:16 <dons> sjanssen, jcreigh: yes, still problems with switching workspaces, not bringing its windows back into focus
15:21:20 <chessguy> Cheery: i'd poke around http://www.haskell.org/haskellwiki/Libraries_and_tools if i were you
15:21:21 <lambdabot> Title: Libraries and tools - HaskellWiki
15:21:26 <dons> someone (looking at you jcreigh ...) broke reveal?
15:21:36 <mux> oh, well I have something that works but is full of fromIntegral now
15:21:40 * mux will paste to hpaste
15:21:55 * chessguy turns the spotlight on jcreigh 
15:22:07 <stranger> Has anyone read Graham Hutton's book?
15:22:14 <sorear> Yes.
15:22:23 <stranger> I'm thinking of buying it, is it any good?
15:22:39 * sorear doesn't know
15:22:39 <chessguy> stranger: i haven't read it, but i've heard it's fairly basic
15:22:40 <dons> sjanssen: yes, and the bug isn't present if i unrecord the xinerama patches
15:23:11 <sjanssen> dons: I think we need a xmonad-xinerama branch
15:23:50 <dons> sjanssen: hmm. i was hoping we could just get the code in and working, but it needs more testing.
15:23:53 <dons> i don't trust it yet :-)
15:23:57 <sjanssen> yeah
15:24:11 <dons> sjanssen: should i revert the patches from the main repo for now, then?
15:24:21 <sjanssen> sure
15:29:16 <dons> hmm. grr. can't darcs rollback the main xinerama patch, its 'depended upon'
15:29:18 * dons ponders 
15:30:24 <sjanssen> dons: have you pulled the 'use "windows" in "unmanage"' patch I pushed last night?
15:30:42 <dons> yeah
15:31:02 <dons> i think i've got it, i have to unpull the xinerama patches, and rollback them one at a time
15:32:10 <dons> http://programming.reddit.com/info/1b60q/comments
15:32:12 <lambdabot> Title: Solving the Mr. S and Mr. P puzzle in Haskell. (reddit.com)
15:32:15 <dons> augustss++ :-)
15:32:28 <dons> oleg should really have a proper blog. ftp/.txt is a bit 1970s
15:32:43 <augustss> lol
15:33:40 <dons> sjanssen: yeah, got it. you pull the xinerama patches one at a time, 'rollback' each one as it lands. then it works
15:33:57 <dons> sjanssen: the undo patches are in the repo now
15:38:16 <psi> what are you talking about? haskell wm?
15:38:22 <sorear> yeah!
15:38:25 <sorear> @where xmonad
15:38:25 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
15:38:29 <psi> cool
15:38:44 <sorear> dho has ~dirs?
15:39:18 <sorear> and its not even listed in the / listing...
15:39:24 <liquidengineer> Hello
15:39:24 <lambdabot> liquidengineer: You have 1 new message. '/msg lambdabot @messages' to read it.
15:39:25 <liquidengineer> :D
15:39:27 <sorear> liquidengineer: your thing was solved
15:39:30 <stepcut> :p
15:39:35 <liquidengineer> yes
15:39:38 <liquidengineer> thankyou, stepcut
15:39:42 <chessguy> so has anyone come up with a more modern library for animations and reactivity than the one developed in HSOE?
15:39:47 <sorear> yampa?
15:39:48 <liquidengineer> and all the rest of you who listened to my madness
15:39:54 <dons> liquidengineer: hehe :-)
15:40:01 <dons> liquidengineer: so you 'darcs pull'ed the patch?
15:40:09 <chessguy> ?where yampa
15:40:09 <lambdabot> http://www.haskell.org/yampa/
15:40:17 <dons> i'd forgotten all about that Ord issue causing leaks, though it happened to me once before :/
15:40:19 <liquidengineer> dons: eh...no.  I just typed it into the code I had.
15:40:22 <liquidengineer> looked like just one line.
15:40:34 <dons> liquidengineer: right. but now your repo is out of whack :/ ah well.
15:40:43 <liquidengineer> :(
15:40:46 <stepcut> dons: 'leak' is a bit of understatement. More like, instant death ;)
15:40:50 <sorear> I wonder how many other hidden dirs there are on darcs.haskell.org
15:41:00 <liquidengineer> Now I feel guilty, dons.
15:41:04 <dons> stepcut: right. maybe there should be some stronger wording for the Ord class?
15:41:06 <jcreigh> dons: I can't reproduce that bug, either in xinerama or single-screen
15:41:14 <sorear> ~sjanssen is NOT listed in "Index of /"
15:41:14 <liquidengineer> I was wondering about that, actually
15:41:25 <liquidengineer> why didn't it tell me I wasn't defining an instance of Ord properly?
15:41:25 <dons> liquidengineer: its easy, 'darcs whatsnew -s' ; darcs revert
15:41:35 <dons> liquidengineer: then darcs pull from my repo, to get stepcut's patch
15:41:53 <liquidengineer> what do I put after the s?
15:42:13 <dalexandre> toLower onverts a letter to the corresponding lower-case letter, haskell have a equivalent to string?
15:42:15 <sorear> nothing, it's a boolean flag
15:42:22 <nmessenger> dalexandre: [Char]
15:42:22 <sorear> dalexandre: no
15:42:25 <dibblego> dalexandre, map . toLower
15:42:30 <sorear> dalexandre: because it's so easy to define
15:42:36 <sorear> dibblego: map toLower
15:42:38 <liquidengineer> I mean, don't I have to tell it what I want it to darcs on?
15:42:39 <dibblego> yeah that
15:42:46 <nmessenger> @type map toLower
15:42:46 <sorear> liquidengineer: it uses .
15:42:48 <lambdabot> [Char] -> [Char]
15:42:48 <dons> jcreigh: so the precise case was to switch to a *new* workspace, create 1 xterm, create another; then try to 'j' left into the first one.
15:42:59 <ddarius> Maybe the minimal definition should be formalized and checked by the compiler giving a warning.
15:43:08 <dalexandre> sorear map toLower "Teste" ?
15:43:19 <nmessenger> > map toLower "Teste"
15:43:20 <sorear> ddarius: I already have a language for describing minimal definitions
15:43:20 <lambdabot>  "teste"
15:43:32 <sorear> ddarius: I could implement it in hv...
15:43:33 <ddarius> sorear: It should not be hard at all.
15:43:34 <nmessenger> dalexandre: ask lambdabot! :)
15:43:41 <dalexandre> thankz
15:43:42 <nmessenger> @botsnack
15:43:42 <lambdabot> :)
15:43:46 <dons> liquidengineer: it uses the default, so whichever repo you last pulled from
15:44:05 <dons> liquidengineer: so cd into your nim repo; darcs revert; then darcs pull from my repo
15:44:17 <liquidengineer> how do I do the darcs pull thing again?
15:44:22 <liquidengineer> what was the address?
15:44:26 <dons> "darcs pull"
15:44:27 <dons> or else
15:44:37 <dons> "darcs pull http://www.cse.unsw.edu.au/~dons/tmp/nim"
15:44:37 <lambdabot> Title: Index of /~dons/tmp/nim
15:44:46 <sorear>  @where nim :p
15:45:14 <dons> jcreigh: maybe we should make a xinerama branch, for that to be worked on, till it works for everyone
15:45:19 <liquidengineer> now only one more major bug to track down
15:45:24 <liquidengineer> and this one's more annoying than anything else
15:45:28 <ddarius> liquidengineer: You don't need to remember the address as dons suggested.
15:45:41 <liquidengineer> I need to figure out why it's not counting playerIDs right
15:45:43 <jcreigh> dons: I have one xterm in workspace 1. I do modkey-9 shift-modkey-enter shift-modkey-enter modkey-j
15:45:51 <jcreigh> dons: hmm, perhaps so.
15:46:03 <liquidengineer> when it crossover_mutates, it's not assigning them correctly
15:46:07 <liquidengineer> of course, that's a minor niggle
15:46:11 <liquidengineer> it doesn't effect performance at all
15:46:14 <jcreigh> dons: that key sequence works fine for me.
15:46:31 <jcreigh> I'm running with a single screen right now to test this.
15:47:09 <liquidengineer> hmmm
15:47:12 <liquidengineer> said it failed to read patch
15:47:18 <Pastorn_> moonlite: #haskell.se
15:47:22 * ddarius takes this opportunity when he's not on the phone with his girlfriend to read a paper.
15:48:05 * stepcut takes this opportunity when ddarius is reading a paper to talk to ddarius's girlfriend on the phone.
15:48:35 <ddarius> Funny story there.
15:49:12 <jcreigh> hmm, since stepcut is busy...
15:49:28 <liquidengineer> hmmm...
15:49:30 <liquidengineer> darcs: failed to read patch in get_extra:
15:49:40 <liquidengineer> it thinks it's a partial repository, whatever that means
15:49:45 <dons> jcreigh: hmm. ok. let me just try again..
15:50:22 <dons> i was just able to reproduce a crash, xmonad: Main.hs:341:6-38: Irrefutable pattern failed for pattern Data.Maybe.Just curscreen
15:50:34 <dons> but that was with the xinerama code
15:50:37 <jcreigh> dons: that's old.
15:50:48 <dons> yeah, i had a unreverted patch
15:50:51 <jcreigh> dons: there's no more "let Just x = ..." in my latest code.
15:51:06 <dons> checking now ...
15:51:31 <dons> jcreigh: btw, you should be able to at least darcs get.
15:51:57 <jcreigh> but, that *still* shouldn't be Nothing, so if you can consistently get xmonad to print the "this shouldn't happen!" message, let me know about that too.
15:53:09 <dons> ok. with the current head, i don't see any workspace bug (after the xinerama stuff is reverted). trying again now with xinerama enabed
15:53:10 <jcreigh> dons: what do you mean, "at least darcs get"?
15:53:28 <dons> your complaint about partial repos
15:54:03 * jcreigh is confused.
15:54:18 <emu> did i miss a sub-list search function in Data.List or is it not there?
15:54:20 <dons> and yes, the bug is in the xinerama code (the original one I complained about)
15:54:28 <jcreigh> I don't recall my complaint about partial repos. care to scrollback quote me? :)
15:55:14 <Saizan> that was liquidengineer i think, [234825] <liquidengineer> it thinks it's a partial repository, whatever that means
15:55:27 <dons> jcreigh: so, restart xmonad ; mod-8 ; make 2 xterms ; mod-j, focus should be lost
15:55:49 <dons> once you've done it once though, it seems to work after that
15:56:25 <dons> liquidengineer: ah yes. sorry. not jcreigh
15:56:42 <stranger> Are views implemented by some compiler/interpreter, in any form?
15:56:51 <dons> hbc provides them, iirc.
15:57:09 <dons> light weight views (very) in the form of pattern guards are provided by ghc
15:57:17 <stranger> Thanks, I'll have a look.
15:57:33 <stranger> And I already knew about pattern guards
15:59:13 <stranger> Any particular reason views never quite caught on?
15:59:40 <stranger> The tension between pattern-matching and ADTs seems like a problem to me
15:59:47 <stranger> but what do I know?
16:00:02 <dons> they're rarely needed? (until now maybe)
16:00:24 <dons> no one had a type which needed to look like another type badly enough for it to be justified
16:00:57 <liquidengineer> dons: so I should darcs get again?
16:01:40 <augustss> stranger: yes, the tension is there, and somewhat of a problem.
16:02:31 <dons> liquidengineer: actually, try 'darcs pull' again. there was a permissions problem
16:02:42 <jcreigh> dons: nope, I *still* can't reproduce that bug. Just to confirm, when you say "focus should be lost", you mean it should be switching to the xterm that you started *first*, but it's not?
16:02:42 <augustss> stranger: I think the reason views never caught on is that all view proposals have had deficiencies of some kind
16:02:59 <dibblego> are views similar to implicit type conversions?
16:03:07 <sorear> no
16:03:14 <dons> jcreigh: right, go to new workspace; create xterm #1; create xterm #2 ; mod-j back to xterm #1 ; focus is lost.
16:03:15 <sorear> views are explicit type conversions
16:03:31 <dons> i can reprdouce that with the xinerama patches on, but not in the head, or before the xinerama patches
16:03:36 <sorear> functions can only convert types in expression context
16:03:42 <jcreigh> oh, you're saying you can switch to the first xterm, but it no longer has keyboard focus?
16:03:42 <nmessenger> (with a convenient pattern-matching syntax, usually)
16:03:43 <sorear> views are for pattern contexts
16:03:55 <dons> jcreigh: nope. can't switch, and focus is lost from xterm #2
16:04:13 <dons> so focus is lost, and xterm #2 is still on screen
16:04:46 <sorear> views are an icky band-aid for the gaping hole in haskell shaped like a first class pattern
16:05:26 <jcreigh> dons: okay, I understood you correctly then. It "works for me".
16:05:46 <dons> hmm. ok. sjanssen do you see this error?
16:05:54 <stranger> sorear: are there any languages without such a hole?
16:06:02 <liquidengineer> Fixed my other major bug just now
16:06:05 <dons> jcreigh: do you see no focus issues or other oddities at all then?
16:06:06 <liquidengineer> Everything works. :D
16:06:31 <sorear> observation: first class patterns could be implemented, given first class binding
16:06:33 <dons> liquidengineer: great!
16:06:39 <jcreigh> dons: no, everything works fine for since I changed unmanage to use the "windows" combinator. (before that, there was the workspace issue sjanssen reported)
16:06:49 <jcreigh> *fine for me
16:07:09 <liquidengineer> :D
16:07:10 <sorear> stranger: Liskell could probably do it
16:07:11 <nmessenger> and first class binding would require a lot of runtime machinery if I'm not mistaken.
16:07:18 <liquidengineer> question:
16:07:24 <liquidengineer> what's the efficiency of last?
16:07:28 <dons> ok. trying again just to be sure, jcreigh
16:07:28 <sorear> O(n)
16:07:30 <dons> O(n)
16:07:31 <sjanssen> dons: it seems to work for me
16:07:34 <sorear> fusible
16:07:37 <liquidengineer> Oh thank god.
16:07:54 <liquidengineer> and head is O(1), yes?
16:07:55 <sorear> what did you think it was :)
16:07:58 <sorear> yes
16:08:01 <liquidengineer> sorear: I wasn't sure
16:08:07 <jcreigh> let me paste my the versions of seemingly relevant software here, and we can compare to try to see if something weird like that...
16:08:08 <liquidengineer> thing is, I'm sorting in ascending order.
16:08:13 <liquidengineer> so the answer I need is on the end of the list
16:08:21 <sorear> just use maximum
16:08:22 <dons> sjanssen: do you have any issues with the xinerama code then?
16:08:24 <liquidengineer> if I could sort in descending order, that'd be swell
16:08:30 <liquidengineer> or that.
16:08:34 <sorear> > maximum [1,2,3,4,56,2,10]
16:08:36 <lambdabot>  56
16:08:37 <nmessenger> sortBy (flip compare)
16:08:44 <nmessenger> ^^ descending sort
16:09:04 <sjanssen> dons: I guess it's working?
16:09:06 <chessguy> you could also use a priority queue, if you want to get the maximum (or minimum) element multiple times
16:09:09 <stepcut> > sortBy (flip compare) [1..10]
16:09:10 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
16:09:12 <dons> ?check \xs -> let _=xs ::[I] in not (null xs) ==>    last (sort xs) == maximum xs
16:09:13 <lambdabot>  OK, passed 500 tests.
16:09:26 <sorear> I?
16:09:29 <liquidengineer> what's maximum's effiency?
16:09:37 <nmessenger> type I = Int
16:09:38 <sorear> O(n), optimal for any collection type
16:09:39 <chessguy> O(n)
16:09:42 <sjanssen> it does O(n) comparisons
16:09:44 <liquidengineer> ah
16:09:49 <liquidengineer> well, that's the same as last
16:09:55 <sorear> any unordered collection that is
16:10:04 <stepcut> ? \xs -> sortBy (flip compare) xs == reverse $ sort xs
16:10:05 <sorear> liquidengineer: if you use maximum you don't need to sort it
16:10:10 <stepcut> ?check \xs -> sortBy (flip compare) xs == reverse $ sort xs
16:10:11 <lambdabot>  Couldn't match expected type `[a]'
16:10:12 <augustss> It's hard to find the maximum without looking at all the elements :)
16:10:26 <liquidengineer> oops
16:10:32 <dons> jcreigh: nope. still there, after i unpull the UNDO patches
16:10:47 <nmessenger> ?check \xs -> sortBy (flip compare) xs == reverse (sort (xs::T))
16:10:48 <lambdabot>  OK, passed 500 tests.
16:10:58 <nmessenger> type T = [Int], btw :)
16:11:03 <chessguy> if you use a priority queue, maximum is log n, i think
16:11:09 <sorear> O(1)
16:11:11 <stepcut> nmessenger: spiffy
16:11:13 <liquidengineer> so sorting something and then calling last on that....that's like, n*n worst case?
16:11:23 <kc5tja> > let z = do a <- [1..5]; b <- [6..10]; (a,b) in z
16:11:23 <lambdabot>  Couldn't match expected type `[t]' against inferred type `(a, b)'
16:11:24 <chessguy> sorear: not if you remove it
16:11:26 <sorear> nope, only n log n
16:11:34 <kc5tja> > let z = do a <- [1..5]; b <- [6..10]; return (a,b) in z
16:11:35 <lambdabot>  [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),(...
16:11:41 <liquidengineer> n log n isn't so bad
16:11:44 <dons> jcreigh: but it only happens when you first log in. then other things appears strange too (switching workspaces doesn't seem right)
16:11:45 <sorear> chessguy: why remove it? he's not interested in all-but-maximum
16:11:45 <augustss> liquidengineer: last . sort is O(n * log n)
16:11:51 <sjanssen> dons: the issue we're referring to is "go to new workspace; create xterm #1; create xterm #2 ; mod-j back to xterm #1 ; focus is lost."?
16:12:01 <sjanssen> dons: oh, I need to try this from a fresh start?
16:12:06 <dons> yes.
16:12:07 <dons> and yes.
16:12:18 <liquidengineer> but if I could just get the maximum, that'd be O(n)
16:12:23 <sorear> right.
16:12:28 <sorear> @type maximum
16:12:29 <chessguy> sorear: the assumption is that he'll want to the the maximum k elements
16:12:30 <lambdabot> forall a. (Ord a) => [a] -> a
16:12:45 <chessguy> liquidengineer: or O(1) with a priority queue
16:12:48 <sorear> chessguy: subrange sorting is easy!
16:12:56 * sorear <3 modified quicksorts
16:13:05 <augustss> chessguy: only if you already have a PQ
16:13:09 <dons> sjanssen: so i'm not getting this with the head, but if i unpull the UNDO pathces, i hit the bug every time
16:13:13 <hpaste>  jcreigh pasted "versions of a few X11 progs" at http://hpaste.org/1035
16:13:16 <chessguy> augustss: sure
16:13:22 * sorear <3 all lesser-known algorithms, really
16:13:26 <chessguy> i'm assuming you have to build the list sometime
16:14:03 <dons> $ Xorg -version
16:14:03 <dons> X Window System Version 6.8.2
16:14:03 <dons> Release Date: 9 February 2005
16:14:16 <hyrax42_> modified quicksorts = hoare's FIND?
16:14:27 <jcreigh> hmm...
16:14:40 <dons> what would that imply, that one of the Xinerama calls is buggy between 05 and 06?
16:14:48 <dons> we don't hit xinerama that hard do we.... ?
16:14:58 <liquidengineer> wtf
16:14:59 <liquidengineer> internal error: interpretBCO: unknown or unimplemented opcode 866
16:15:04 <stepcut> liquidengineer: haha
16:15:10 <sjanssen> dons: I don't think xinerama is at fault here
16:15:17 <dons> neither.
16:15:17 <jcreigh> I don't know...I'm just trying to figure out what's different between your setup and mine
16:15:24 <liquidengineer> screw efficiency, then.
16:15:28 <liquidengineer> [;)
16:15:36 <dons> jcreigh: there have been other focus bugs that have only been seen on my system
16:15:36 <stepcut> liquidengineer: what platform ?
16:15:37 <jcreigh> sjanssen: are you seeing the same thing dons is?
16:15:40 <liquidengineer> PowerPC
16:15:59 <jcreigh> dons: other than my patches?
16:15:59 <dons> jcreigh: we had 2 or 3 focus issues that dwm and xmonad handled, but never occured on sjanssen's machine
16:16:07 <dons> jcreigh: yes, a few weeks ago
16:16:09 <jcreigh> oh, weird.
16:16:10 <dons> (fixed now)
16:16:24 <dons> but the issues only appeared on my setup for some reason.
16:16:33 <jcreigh> sjanssen: what version of X do you have?
16:16:48 <ddarius> sorear: Gapped insert sort
16:17:24 <liquidengineer> ah
16:17:25 <jcreigh> dons: what OS are you running?
16:17:25 <liquidengineer> wait
16:17:27 <liquidengineer> there was more
16:17:31 <liquidengineer> says "Abort trap"
16:17:34 <ddarius> @google insert sort is O(n log n)
16:17:36 <lambdabot> http://citeseer.ist.psu.edu/bender04insertion.html
16:17:36 <lambdabot> Title: INSERTION SORT is O(n log n) (ResearchIndex)
16:17:41 <dons> jcreigh: it seems like the current window isn't moved off screen when it should be
16:17:50 <dons> moving focus to #1 , but leaving #2 on top
16:17:54 <dons> ie. a missing 'raise'?
16:18:02 <sjanssen> jcreigh: X Protocol Version 11, Revision 0, Release 7.1.1
16:18:09 <liquidengineer> this is happening when I try to do functional composition: (progPop.evolve) enp
16:18:38 <dons> we could I suppose, have the xinerama branch, and just note that it requires a newer Xorg
16:18:39 <stepcut> liquidengineer: what version of ghc ?
16:18:44 <jcreigh> dons: "refresh", called by "windows" should raise the window.
16:19:31 <sorear> liquidengineer: don't bother, it's a (multiply!) reported bug
16:20:34 <jcreigh> dons: no, that's giving up. :) I wanna figure out what's really going on here. I think I'm going to try to get your version of X11 and see if I can reproduce the bug that way.
16:21:01 <liquidengineer> this is stupid
16:21:12 <liquidengineer> Now the stuff that was working five minutes ago is giving me the opcode error
16:21:13 <jcreigh> dons: so for now we'll leave the Xinerama support out of head until I can figure out what's going on. If I can't, maybe we will have to have a xinerama branch.
16:21:20 <sorear> http://hackage.haskell.org/trac/ghc/ticket/1013
16:21:21 <liquidengineer> WTF, ghci, WTF? ;)
16:21:22 <lambdabot> Title: #1013 (interpretBCO: unknown or unimplemented opcode 64356) - GHC - Trac
16:21:25 <jcreigh> dons: does that seem reasonable?
16:22:04 <Gwern> has anyone tried out xmonad?
16:22:21 <sorear> shapr, jcreigh, sjanssen, dons, ...
16:22:29 <liquidengineer> I think I'm going to cry
16:22:35 <liquidengineer> or bash my head in with something
16:22:44 <Gwern> (I thought it looked interesting, but I'm not having luck with the installation, but before I invest much more effort I want to know whether it's interesting or an improvement over stalwards like ratpoison)
16:22:48 <liquidengineer> why would it work five minutes ago, but now now?
16:22:49 <sjanssen> Gwern: do you have a bug?
16:22:59 <sorear> liquidengineer: it's called a bug :)
16:23:05 <sjanssen> Gwern: it's pretty bare right now (no tiling yet)
16:23:11 <kb_> foolish newbie question: Is there something like map or filter where you can 'peek ahead' at the next N elements in the list?  I keep finding situations where I want to do that, and I don't want to reinvent the standard library
16:23:19 <Gwern> sjanssen: sort of. the X11-extras thing that apparently is a dependency for xmonad won't compile when I use Cabal
16:23:40 <ddarius> sjanssen: How old is it at this point?
16:23:42 <sjanssen> Gwern: what happens when you attempt to build X11-extras?
16:23:43 <nmessenger> kb_: you can use unfoldr for that.
16:23:51 <liquidengineer> sorear: well, yeah, but this code worked five minutes ago
16:24:04 <liquidengineer> I didn't change anything
16:24:06 <Gwern> sjanssen: just an odd compiel error: Xinerama.hsc:45:0:  error: expected ; before ) token
16:24:07 <augustss> kb_: there's no single function that does it
16:24:09 <Gwern> Xinerama.hsc:45:0:  error: expected statement before ) token
16:24:14 <sorear> kb_: I don't know about the fixed-N case, but if you want to look at the entire rest of the list it's called a paramorphism
16:24:28 * jcreigh bangs his head against the wall
16:24:29 <dalexandre> with dropWhile i can remove repeated elements from a list?
16:24:39 <sjanssen> ddarius: the first recorded patch is "Mar  6", but I worked on it a bit before that
16:24:41 <jcreigh> I guess it's just not my day. :)
16:24:41 <ddarius> @google recursion schemes from comonads
16:24:43 <lambdabot> http://www.cs.ioc.ee/~tarmo/papers/nwpt00.ps.gz
16:24:51 <kb_> dalexandre: if it's a finite list, you might want nub?
16:25:00 <nmessenger> kb_: unfoldr f xs -- f gets the whole list.  It returns Just (resultElement, remainderOfListForNextInvocation) to produce an element, or Nothing when it's done
16:25:03 <ddarius> So 12ish days.
16:25:10 <augustss> kb_: you can do something like: map (f . take n) (tails xs)
16:25:24 <dalexandre> kb_ i have a finite list if names, i want to remove repeated names
16:25:32 <kc5tja> dalexandre: dropWhile will remove elements as long as the predicate function you use returns true.
16:25:44 <sjanssen> Gwern: and you built in the usual way?  runghc Setup.lhs configure; runghc Setup.lhs build
16:25:54 <sorear> kb_: nub works just fine on infinite lists
16:25:55 <psi> dalexandre: map head . group . sort
16:25:57 <kb_> dalexandre: http://cvs.haskell.org/Hugs/pages/libraries/base/Data-List.html#v%3Anub - that's exactly what nub does, albeit not very efficiently
16:25:59 <lambdabot> http://tinyurl.com/yy3u67
16:26:00 <nmessenger> > let f [] = Nothing; f xs = Just (splitAt 3 xs) in unfoldr f [1..15]
16:26:01 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15]]
16:26:17 <augustss> @src nub
16:26:17 <lambdabot> nub = nubBy (==)
16:26:19 <kb_> sorear: hm, ok; I wasn't sure if it would terminate in that case; hooray for lazyness
16:26:23 <dalexandre> psi how this works ?
16:26:23 <augustss> @src nubBy
16:26:24 <lambdabot> nubBy eq []             =  []
16:26:24 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:26:29 <Gwern> sjanssen: no, I was using some sort of cabal tool: cabal-setup-cvs configure; cabal-setup-cvs build
16:26:56 <psi> dalexandre: it sorts the list, groups all equal elements that are next to each other, and then takes the first element of each group
16:27:08 <SamB> > nub (cycle "a" ++ "b")
16:27:12 <lambdabot> Terminated
16:27:25 <sorear> > nubBy(((0==).).mod)[2..] --my new favorite haskell code
16:27:27 <kc5tja> nmessenger: Son of a  ... ggyaaahhH!!  My monadless parser reinvented unfoldr.  :)  If only I'd known about that function.  :)
16:27:28 <emu> nubby
16:27:28 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
16:27:30 <kc5tja> (oh well)
16:27:40 <emu> that's what we call haskell newcomers?
16:27:41 <kb_> nmessenger: cool, that looks more or less like what I was looking for; I'll play with it; thanks!
16:27:48 <sorear> > nubBy(((1/=).).gcd)[2..] --my new favorite haskell code
16:27:49 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:28:09 <nmessenger> kc5tja: join the club!  I rewrote *many* library functions when I was getting my feet wet.  :)
16:28:23 <stepcut> kc5tja: hence the paper, the underappreciated unfoldr
16:28:24 <emu> oh that's a nicer one than cale's even
16:28:24 <dons> Gwern: probably best to just use the normal build instructions?
16:28:24 <kb_> sorear: woah :)
16:28:27 <liquidengineer> and now it works again, after I ran its body in ghci
16:28:29 <liquidengineer> I love it.
16:28:30 <ddarius> kc5tja: That'll happen a lot for a while.
16:28:31 <augustss> sorear: clever!
16:28:35 <dalexandre> psi how i use this with a list ?
16:28:37 <dons> liquidengineer: use ghc perhaps? :-)
16:28:40 <stepcut> @google underappreciated unfold
16:28:42 <dons> ghc --make -O Main.hs
16:28:45 <lambdabot> http://citeseer.ist.psu.edu/gibbons98underappreciated.html
16:28:45 <lambdabot> Title: The Under-Appreciated Unfold - Gibbons, Jones (ResearchIndex)
16:28:48 <liquidengineer> dons: but ghci is so much more convenient.
16:28:49 <dons> ?karma unfoldr
16:28:49 <lambdabot> unfoldr has a karma of 8
16:28:53 <Gwern> dons: there were no build instructions in the readme that I saw :(
16:28:53 <liquidengineer> and it's working again anyway. :D
16:28:56 <sorear> kb_, augustss: I didn't invent it!
16:28:56 <dons> liquidengineer: indeed it is.
16:29:10 <liquidengineer> I gotta go
16:29:13 <augustss> sorear: clever nevertheless
16:29:14 <liquidengineer> thank you all, for all your help
16:29:17 <kb_> sorear: fine, but you're the first person I saw it from, and it's still pretty neat :)
16:29:23 <ddarius> @karma foldr
16:29:23 <lambdabot> foldr has a karma of 1
16:29:30 <emu> foldr++
16:29:32 <dons> Gwern: that's because it builds the same way as all cabal packages: runhaskell Setup.lhs configure --prefix=/foo/bar ; runhaskell Setup.lhs build ; runhaskell Setup.lhs install
16:29:39 <kb_> unfoldr++
16:29:51 <dalexandre> what is more eficient nub or  map head . group . sort ?
16:30:01 <sorear> depends on n
16:30:03 <augustss> the latter
16:30:07 <sorear> asymptotically the latter
16:30:23 <sorear> but ndm says that in practice the cutoff is fairly high
16:30:33 <emu> nub handles laziness better probably
16:30:34 <augustss> probably
16:30:42 <jcreigh> oh, wonderful, X11 doesn't use autoconf
16:30:46 <emu> xmkmf!
16:30:51 <sorear> my ordNub is much faster than either, and lazy to boot
16:30:57 <kc5tja> IMake -- gotta love it.  :)
16:31:01 <dons> sorear: yeah, but its in Ord
16:31:05 <dons> its easy if you allow Ord
16:31:07 <stepcut> jcreigh: i think X11 is older than autoconf ;)
16:31:16 <Gwern> dons: I did not know that. sounds complex.
16:31:16 <psi> dalexandre: you use it just like you'd use nub
16:31:20 <sorear> dons: so is map head . group . sort
16:31:20 * Gwern prefers apt
16:31:24 <dons> Gwern: npoe, easy. see above.
16:31:28 <augustss> I wouldn't mind a lazy ordNub in a library somewhere
16:31:33 <dons> configure ; build ; install, using  the provided Setup.hs
16:31:33 <qwr> hmm, didn't x.org 7.0 went to the autotools?
16:31:39 <psi> sorear: how do you do it?
16:31:46 <dons> augustss: I'd like to spot Ord constraints in rules, and rewrite them to ordNub
16:31:54 <stepcut> qwr: I believe so
16:31:58 <psi> sorear: i use it pretty heavily in a euler project challenge :)
16:32:08 <dons> RULE nub = ordnub :: Ord a => [a]
16:32:16 <sorear> http://haskell.org/pipermail/libraries/2007-March/007030.html
16:32:17 <lambdabot> Title: Proposal: Add Data.List.sortNub and sortNubBy
16:32:23 <dons> much as we do now for , say, maximum = strictMaximum :: [Int]
16:32:41 <augustss> yeah
16:32:41 <sorear> ^^ my message, contains ordnub code
16:32:53 <dons> augustss: it might even work with rules as is, i should try that today
16:33:14 <sorear> dons: but ... core doesn't have typeclasses?
16:33:57 <dons> sorear: no. rules are desugared into core with dictionaries
16:34:24 <jcreigh> Gwern: just do: runghc Setup configure --prefix=$HOME --user; runghc Setup build; runghc Setup install
16:34:34 <jcreigh> Gwern: that will install it into $HOME/lib
16:34:45 <jcreigh> Gwern: then do the same with xmonad
16:34:48 <dons> hmm. we're not really going to add sortNub are we??
16:34:56 <dons> since ndm sez" > Semantically sortNub = sort . nub"
16:35:04 <dons> ie.. just add a rewrite rule for this, don't change the api
16:35:32 <dons> RULE "sort/nub" sort . nub = map head . group . sort
16:35:44 <SamB> dons: I should hope not, if ordnub is more efficient *and* has the same type...
16:35:50 <SamB> as well as being lazier
16:36:03 <dons> using ordnub is a different issue
16:36:09 <dons> there's a class of Ord functions that we could have, but don't
16:36:27 <SamB> notice that sortNub has the same type?
16:37:17 <jcreigh> qwr: maybe Xorg 7.0 did, but I'm building 6.8.2
16:37:53 <dons> urgh. and they want to add State and Set deps. no no no.
16:38:19 <sorear> State is optional.
16:38:27 <sjanssen> the State dep can be dropped
16:38:35 <dons> yes, this is what I would do, http://haskell.org/pipermail/libraries/2007-March/007047.html
16:38:35 <lambdabot> Title: Proposal: Add Data.List.sortNub and sortNubBy
16:39:02 <dons> weird. this was exactly what dcoutts and I were talking about yesterday
16:39:56 <stepcut> dons: welcome to the hive mind
16:40:07 <sjanssen> I don't really see the use of sortNub
16:40:28 <dons> no. if the original proposal is to add sortNub == sort . nub == map head .group . sort
16:40:34 <dons> we should just add a rewrite rule for this
16:40:47 <sjanssen> I'd rather have uniq which is semantically equivalent to map head . group
16:40:59 <SamB> why would they want sortNub = sort . nub?
16:41:36 <SamB> @type concatMap == concat . map
16:41:38 <lambdabot>     Couldn't match expected type `[[a]]'
16:41:38 <lambdabot>            against inferred type `[a1] -> [b]'
16:43:02 <Gwern> hmm. "runghc Setup configure; runghc Setup build; runghc Setup install" should work, right?
16:43:38 <sjanssen> Gwern: Setup.lhs
16:43:49 <Gwern> sjanssen: pardon?
16:44:00 <sjanssen> runghc Setup.lhs ...
16:44:03 <Gwern> oh
16:44:11 <sjanssen> in the case of X11-extras
16:44:30 <sjanssen> oh, I guess runghc Setup works too.  neat trick
16:44:37 <Gwern> sjanssen: nah. the build fails for both names
16:44:52 <sjanssen> Gwern: still failing with the same message?
16:45:11 <Gwern> "Xinerama.hsc" is spilling errors all over the place, and it doesn't seem to change regardless of how I build
16:45:45 <sjanssen> I bet you don't have the xinerama headers
16:45:59 <Gwern> sjanssen: I would not take that bet
16:46:17 <dons> Gwern: do you have the headers in the right place?
16:46:28 <dons> Gwern: check the .cabal file, and adjust the includes path as needed
16:47:30 <kb_> is there anything like http://www.haskell.org/onlinereport/standard-prelude.html for, say, Data.List ?
16:47:31 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
16:48:14 <Gwern> ok. it was a header problem
16:48:28 <dons> ?docs Data.List
16:48:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
16:48:33 <kb_> nm, found it; http://www.haskell.org/onlinereport/list.html - thanks
16:48:34 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
16:49:39 <kb_> dons: I'd looked at that, but it only has an english description of the implementation; I find a lot of haskell functions remain opaque until I see the implementation
16:50:14 <psi> has anyone written any fast code to get all the divisors of a number?
16:51:07 <kb_> psi: I have some extremely naive code that does it, but not a fast implementation
16:52:20 <psi> i have two versions, one which searches up to the sqrt of the numbers, and adds all "mirror" divisors, and another which combines the primefactors to produce all divisors.
16:52:31 <dons> kb_: ah you want the source?
16:52:35 <dons> ?src Data.List
16:52:35 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:52:38 <dons> ?source Data.List
16:52:38 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
16:52:40 <kb_> dons: yeah; the url I pasted has it
16:53:15 <kb_> though your url has an example, as well; thanks!
16:53:26 <psi> the prime factor variant seems to be much faster.
16:53:56 <kb_> psi: hm, cool to hear; I'd thought about implementing that approach, but haven't yet
16:55:23 <psi> I might be doing it stupidly, I haven't thought about it much; divisors2 x = ordNub . map product . powerset . primeFactors $ x
16:56:23 * psi goes away for a while
16:56:29 <kb_> d'oh, powerset will also save me wheel reinvention
16:57:30 <SamB> @hoogle powerset
16:57:30 <lambdabot> No matches found
16:58:10 <SamB> hmm.
16:58:22 * SamB bets that wouldn't deal too well with 2^n
16:58:26 <SamB> or 3^n
16:58:42 <SamB> or 5^n or... pretty much anything ^n...
16:58:53 <nmessenger> @google haskell powerset
16:58:54 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2003-June/004484.html
16:58:54 <lambdabot> Title: powerset
17:00:26 <nmessenger> <3 (/\/) operator
17:07:53 <psi> I thought about how to combine prime factors cleverly a bit, but I couldn't figure it out.
17:08:29 <moconnor> Is there a canonical lexer to use for Haskell?  Googling turns up a couple of things, I'm reimplementing a toy language I've already implemented in Perl and want to try it with Haskell but am uncertain of the usual libraries.
17:08:36 <psi> powerset is a small factor of the overall running time , though.
17:09:48 <psi> ordNub isn't, however, and I guess that stems from using powerset.
17:10:12 <dons> moconnor: alex
17:10:14 <dons> otherwise, parsec
17:11:32 <moconnor> dons: thank you
17:11:50 <kb_> moconnor: parsec is pretty nice; I've used it (though the docs are slightly broken)
17:12:16 <moconnor> kb_: Are the examples that come with parsec pretty good?
17:12:29 <kb_> moconnor: overall, yes
17:14:27 <sorear> dons: I would be a lot happier about the RULES approach if it were possible to haddock them.
17:14:58 <sorear> As it stands, to predict the efficiency of some code, you only need to know about the efficiency and strictness of the functions you use.
17:15:17 <sorear> if we switch it all over to RULES, it becomes much more difficult
17:15:25 <dons> sorear: you add the rule to the documentation
17:15:26 <sorear> because you also need to know the interactions
17:15:38 <dons> adding special cases to the api is just silly though
17:15:53 <dons> its already huge. and this is purely a performance change
17:15:59 <sorear> for instance, I always thought B.filter (10==) was a very expensive operation, involving haskell loops across abstraction barriers
17:16:08 <dons> nope.
17:16:16 <sorear> so I struggled to find a cheaper way
17:16:18 <dons> *but* i do recognise the issue with rules
17:16:27 <sorear> the rules are in the documentation?
17:16:30 <dons> hence the new list library has precise docs about what fuses
17:16:43 <dons> sorear: they will be. yes.
17:16:53 <dons> http://www.cse.unsw.edu.au/~dons/streams/Data-List-Stream.html
17:16:54 <sorear> ftr, I don't read the haddocks anymore ... the comments are more useful, since they are next to a formal spec
17:17:18 <dons> since these special cases are both QC properties, and optimisations
17:17:24 <sorear> but, yes, know you have converted me
17:17:36 <dons> we just add them to the docs like other QC properties
17:17:50 <sorear> errorEmptyList looks new...
17:17:51 <Cale> moconnor: read the Parsec documentation here: http://www.cs.uu.nl/~daan/download/parsec/parsec.html
17:17:57 <psi> hehe, in top 5 on reddit, 3 are about haskell.
17:18:04 <dons> sorear: that's for use by Data.List
17:18:06 <Cale> moconnor: It's pretty tutorial in style and should get you up and running pretty quickly.
17:18:18 <sorear> dons: I don't think i've ever seen a qc prop in a documatum.
17:18:18 <dons> sorry, GHC.List
17:18:21 <Cale> Parsec is what actually got me to understand monads :)
17:18:31 <dons> sorear: oh, they're supposed to be in the docs now, under the new libraries process
17:18:41 <dons> sorear: expect to see them for the streams lib, anyway
17:18:43 <dons> fps also has them
17:19:03 <dons> ?where+ hsChess darcs get http://www.cse.unsw.edu.au/~dons/code/contrib/hsChess/
17:19:03 <lambdabot> Done.
17:19:33 <sorear> dons: can stream fusion handle map f (map g xs)?
17:19:39 <Cale> dons: How is the new list library's performance?
17:19:46 <sorear> or do I have to rewrite it as map f . map g $ xs?
17:20:05 <sorear> ie with explicit ., as the documentation seems to imply is needed
17:20:21 <dons> Cale: so far, we've only tested it lightly. everything the same or faster.
17:20:25 <Cale> cool
17:20:25 <dons> but no precise numbers yet
17:20:28 <dons> sorear: yes.
17:20:39 * merus_ derives too much pleasure out of calculating powersets.
17:20:41 <dons> you can rewrite it in all sorts of ways and it will still fuse
17:20:53 <Cale> What's the point of providing stream and unstream if there are no operations on the abstract stream type? Or are those planned?
17:21:04 <dons> Cale: they're exported so we can QC the lib
17:21:08 <Cale> ah, okay
17:21:24 <dons> the actual Data.List lib will just reexport this stuff from somewhere
17:21:26 <sjanssen> > filterM (const [True, False]) [1..5] -- seen this one merus_?
17:21:27 <lambdabot>  [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,...
17:21:36 <sorear> Cale: Stream a is exported, just not from data.list.stream
17:21:52 <merus_> That's a powerset calculuator?
17:22:08 <dons> i'll add this nub / sort rule to the streams list now .. :-)
17:22:09 <Cale> sorear: ah, okay
17:22:22 <sorear> data.stream iirc
17:22:24 <Cale> Can I make a request? Include combinations and permutations. :)
17:22:33 <dons> Cale: you want new stuff?
17:22:35 <sjanssen> merus_: yes
17:22:38 <Cale> hehe
17:22:44 <dons> Cale: that's a good idea. talk to the library submission process ;-)
17:22:49 <sorear> what, no fusion for transpose? :)
17:22:52 <merus_> ?src filterM
17:22:52 <lambdabot> Source not found. You type like i drive.
17:23:12 <Cale> Well, you could also think of it as pretty old stuff -- it used to be in the list library spec, but somehow got dropped on the floor along the way.
17:23:31 <kb_> I second what Cale says - I've wanted those a few times
17:23:49 <dons> so my plan, sorear , is to add rules/properties to each function as:
17:23:50 <dons> -- The following properties hold for nub:
17:23:50 <dons> --
17:23:50 <dons> -- >    sort (nub xs) = map head (group (sort xs))
17:23:56 <dons> and then mention which ones are optimisations
17:24:00 <Cale> It's a good question as to exactly *which* implementation is provided though.
17:24:09 <sorear> mapAccumL won't fuse!?
17:24:13 * sorear writes a patch
17:24:34 <dons> sorear: sure it will. we just haven't written that stream combinator yet
17:24:34 <Cale> iirc, there was a clear winner for combinations, but at least two for permutations which I couldn't quite decide between.
17:24:47 <merus_> Oh, sjanssen, I kind of see how that works.
17:25:02 <dons> sorear: they pretty much all should. well,transpose is a bitch, but who uses that?
17:25:07 <sorear> dons: how about span and break?
17:25:15 <sorear> dons: I've used transpose before
17:25:19 <merus_> ?src Monad.filterM
17:25:19 <Cale> One was a little faster, but only worked on finite lists, the other worked on infinite lists, and was only slightly slower.
17:25:20 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:25:37 <dons> span and break should too. we just have to ponder the sharing issues involved
17:26:00 <sorear> dons: what functions will never fuse, even when the lib is finished?
17:26:12 <shachaf> @source Control.Monad
17:26:12 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
17:26:54 <sorear> zip doesn't fuse!!?!?
17:27:17 <psi> what is the new list library?
17:27:24 <dcoutts> sorear: not currently with build/foldr, at least not in both args at once
17:27:42 <dons> sorear: hmm. tranpose probably.
17:27:43 <sorear> dcoutts: we're talking about Data.List.Stream
17:27:56 <dons> sorear: zip will fuse, just not done yet.
17:28:01 <dcoutts> sorear: oh, we've just not done that yet
17:28:07 <dcoutts> it's work in progress, fear not
17:28:23 <dcoutts> dons: we can fuse unzip and splitAt in the same way that the current list lib does, ie using foldr, but in a sense that doesn't really buy you anything since you build a list anyway
17:28:57 <sorear> one sided fusion is better than nothing
17:29:17 <dcoutts> unzip    =  foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
17:29:21 <ddarius> dons: Would it be possible to commute zips/unzips and fuse between them
17:29:32 <dcoutts> so you can fuse on the consuming side
17:30:10 <dcoutts> and then you build this pair of lists doing lots of sharing and you can stream the result pairwise
17:30:18 <dcoutts> but I think that does not buy you much
17:30:55 <dcoutts> ddarius: people rarely  do unzip . zip, or is that not what you meant?
17:31:42 <dcoutts> dons: in other words we do it like sort, we build an intermediate structure and then stream it out
17:31:48 <ddarius> dcoutts: Inserting zip or unzip as a kind of tupling transform to apply "normal" fusion techniques.
17:32:02 <dcoutts> we have a bit o freedom in the choice of intermediate structure
17:32:33 <dcoutts> ddarius: could you be a bit more specific? I don't think I get what you're driving at
17:33:10 <ddarius> dcoutts: I probably need to work out an example, it may not make any sense at all.
17:33:39 <dons> dcoutts: btw, why do we have OrdA and A distinct in the tests?
17:33:58 <dons> dcoutts: i'm trying to start an internal properties module, with
17:33:59 <dons> prop_nubsort    = (Test.sort . Test.nub)  `eq1`
17:34:01 <dons>                   (Test.map Test.head . Test.group . Test.sort)
17:34:15 <dons> but of course the monomorphic nub runs over [A], while sort is [OrdA]
17:34:59 <dcoutts> dons: OrdA is in Ord of course, A isn't. It's to make sure things don't cheat.
17:35:19 <dcoutts> dons: It's taken more or less directly from QuickCheck.Poly
17:35:27 <dons> ok. so we'll need a conversion function.
17:35:42 <dcoutts> do we? what for?
17:36:22 <Igloo> dons: Your QC property won't actually hold with silly Ord definitions, BTW
17:36:26 <dcoutts> but if you're doing sort, then you know the thing needs to be in Ord to start with
17:36:33 <Igloo> (which doesn't mean it isn't valid)
17:36:43 <Igloo> (the translation, that is)
17:36:48 <dcoutts> Igloo: does the report state anywhere that we can assume Ord gives us a true total order?
17:37:16 <Igloo> I don't think so
17:37:18 <dcoutts> Igloo: eg without that your Data.List.sort implementation isn't valid either since it gives different results than the H98 spec
17:37:46 <dcoutts> try it, try your merge sort implementation for sortBy
17:37:52 <Igloo> Yeah, that's why I think it's a valid transformation
17:38:10 <dcoutts> ok, so it's assumed but not stated in the report
17:38:20 <dcoutts> we need to fix that for H'
17:38:59 <dcoutts> we need to be able to rely on Eq giving an equivalence relation and Ord giving a total order
17:39:23 <dcoutts> otherwise we can't use anything other than insertion sort for example, or basically do anything
17:39:26 <Igloo> Oh, I stand corrected, "The Ord class is used for totally ordered datatypes."
17:39:42 <dcoutts> oh, good!
17:40:02 * dcoutts hasn't read the report in full ever either
17:40:18 <Igloo> I think I have read it, I just forget the details  :-)
17:40:29 <dcoutts> so we can rely on laws for Eq and Ord but not Monad then apparently? :-)
17:40:54 <fsck> > fix show
17:40:55 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:40:57 <sorear> @v
17:40:57 <lambdabot> Just 'J'
17:40:59 <sorear> @v
17:40:59 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
17:41:05 <fsck> hey sorear
17:42:38 <QtPlatypus> Wouldn't fix show output a quine?
17:43:14 <dons> dcoutts: hmm. if the spec says that, what does that mean for our Data.List.sortBy issue?
17:43:38 <mbishop> @rot13
17:43:38 <lambdabot> Unknown command, try @list
17:43:41 <mbishop> @list
17:43:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:43:51 <mbishop> oh come on, no rot13?
17:43:58 <dcoutts> dons: we can assume it's ok, it must be, but we can complain that the report isn't clear enough.
17:44:37 <dcoutts> dons: since for sortBy we're not using Ord of course so we need to explicitly state that the function must give a total order.
17:44:51 <dons> ah right. but why does the h98 sortBy work then?
17:45:34 <dcoutts> oh, I stand corrected (again):
17:45:38 <dcoutts> "when the "By" function replaces an Ord context by a binary predicate, the predicate is assumed to define a total ordering."
17:45:43 <dcoutts> so it's fine
17:45:51 * dcoutts should read the report
17:46:17 <dcoutts> dons: the H98 sortBy works fine and it assumes the thing is a total order
17:46:44 <dcoutts> it's just that different valid implementation will give different results if the comparitor is not a total order
17:47:10 <dcoutts> so our QuickCheck property just needs to ensure that it's using only total orders
17:47:20 <dcoutts> otherwise it's outside of the spec
17:47:42 <dons> oh i see. we just get different results from the h98 spec. that's all, for the out-of-spec condition
17:47:47 <dcoutts> right
17:55:26 <dons> dcoutts: so what do we do with [] and (:)?
17:55:33 <dons> we've got fusion combinators for them.
17:55:41 <ddarius> Yay lack of control flow.
17:58:03 <dcoutts> dons: hmm? I don't follow
17:58:32 <dons> RULE [] = Stream.empty
17:58:45 <dcoutts> oh right, hmm
17:58:45 <dons> RULE forall x xs . x : xs = Stream.cons x (stream xs)
17:58:58 <dons> in particular, the latter
17:59:07 <dcoutts> seems a tad dangerous to me
17:59:16 <dons> oh?
17:59:24 <dcoutts> cons isn't that great for fusion
17:59:26 <dons> we do that for bytestrings though
17:59:42 <dcoutts> aye, but people don't use cons much for ByteStrings
17:59:45 <dons> and monkey box too,  .(:[]) .
17:59:52 <dons> we might want to look at that.
18:00:19 <dons> which we'd get for free with rules for (:) and []
18:00:25 <Botje> @pl \x -> [1,2,x,3]
18:00:25 <lambdabot> (1 :) . (2 :) . (: [3])
18:00:33 <Botje> heh. cute
18:00:41 <dcoutts> dons: note that they don't do it for build/foldr
18:00:46 <Botje> @pl \x -> [1,x,2,x,3]
18:00:47 <lambdabot> (1 :) . ap (:) ((2 :) . (: [3]))
18:01:07 <dcoutts> because of code blowups or something
18:02:06 <dons> hmm.
18:21:47 <ikegami--> hello
18:21:51 <Botje> hi!
18:22:33 <ikegami--> today, I want to make a Haskell program which prints date where it is compiled
18:22:57 <ikegami--> without a CPP trick, how to make them?
18:23:26 <Botje> you could look at the stat() of the binary?
18:23:32 <Lemmih> Use TH?
18:23:37 <dons> ikegami--: some TH to splice in the date?
18:23:51 <ikegami--> interesting
18:24:06 <dons> let date = $(getdate)
18:24:09 <dons> basically.
18:24:14 <ddarius> ikegami--: Why do you want this?
18:25:20 <ikegami--> because I'm writing several program (includes some bugs), and I often confuse version of programs
18:25:45 <dons> ikegami--: you could also use the configure system
18:25:46 <ikegami--> I mean, which is new one, or old (not fixing bugs)
18:25:48 <dons> ?version
18:25:49 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
18:25:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:25:51 <dons> the way lambdabot does
18:26:06 <dons> it checks the _darcs/patch count on building, and writes it into a src file
18:26:55 <ikegami--> it is simple idea
18:27:22 <ikegami--> thanks
18:29:09 <ikegami--> yes, I prefer darcs
18:30:37 <Pseudonym> Woo!
18:30:40 <Pseudonym> There goes my productivity!
18:30:51 <Pseudonym> Haptic device just arrived!
18:31:48 <QtPlatypus> Haptic?
18:32:00 <nmessenger> @wn haptic
18:32:01 * Pseudonym nods and grins
18:32:02 <lambdabot> *** "haptic" wn "WordNet (r) 2.0"
18:32:02 <lambdabot> haptic
18:32:02 <lambdabot>      adj : of or relating to or proceeding from the sense of touch;
18:32:02 <lambdabot>            "haptic data"; "a tactile reflex" [syn: {tactile}, {tactual}]
18:32:02 <Pseudonym> Toy!
18:32:36 <nmessenger> one of those finger keyboard things?
18:32:40 <cdsmith> @where HList
18:32:40 <lambdabot> http://homepages.cwi.nl/~ralf/HList
18:32:43 <Pseudonym> No.
18:32:57 <Pseudonym> It's like a 3D mouse with force feedback.
18:33:29 <Pseudonym> http://bdml.stanford.edu/twiki/pub/Haptics/PHANToMs/LargePremium_1.5-web.jpg
18:33:31 <lambdabot> http://tinyurl.com/26hraq
18:33:32 <Pseudonym> Looks like that.
18:34:10 * nmessenger drools
18:35:27 <Pseudonym> Yeah.
18:35:35 <Pseudonym> Actually, I can't really install it now.
18:35:36 <Pseudonym> Dammit.
18:39:37 <robreim> Hey all. I've extended the Network module to use ByteStrings over UDP for sendTo and recvFrom instead of the TCP based ones in the current Network module. Is this likely to be useful to anyone else?
18:40:05 <kc5tja> :t unfoldr
18:40:07 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:40:38 <kc5tja> :t unfoldl
18:40:40 <lambdabot> Not in scope: `unfoldl'
18:41:21 <kc5tja> :t unfold
18:41:23 <lambdabot> Not in scope: `unfold'
18:41:36 <kc5tja> interesting.
18:41:37 <ddarius> Pseudonym: What exactly are you going to use it for?
18:41:42 * kc5tja goes back to work
18:42:02 <Pseudonym> ddarius: Oh, nothing.  We're just getting it back.
18:42:12 <Pseudonym> It was used for molecular modelling.
18:42:28 <Pseudonym> But I have to fight every internal urge to play with it.
18:43:38 <jcreigh> Pseudonym: why fight? Why not just give in? :)
18:45:44 <dons> robreim: sounds useful
18:46:22 <kc5tja> :t root
18:46:25 <lambdabot> Not in scope: `root'
18:46:32 <sorear> :t Data.Tree.root
18:46:34 <lambdabot> Not in scope: `Data.Tree.root'
18:47:00 <kc5tja> The "underappreciated unfold" paper has an unfold operator that markedly differs from unfoldr.
18:47:27 <kc5tja> In fact, I'd hazard a guess, they're not even the same concept.
18:47:55 <robreim> ok, maybe I'll see about getting it into the Network library.
18:48:06 <moconnor> I have a data type, which has 5 constructors (date Foo = Bar | Baz | ...).  One of them is: "Qux (Integer -> Integer)".  Because of Qux I can't use deriving(Eq, Show).  I hacked up my own instances of Eq and Show and it works, but it's ugly.  Is there a better way?
18:48:54 <sjanssen> you can import Text.Show.Function
18:48:58 <jcreigh> moconnor: you can import Text.Show.Function
18:49:09 * jcreigh waits for the stereo quote...
18:49:12 <sjanssen> @quote stereo
18:49:13 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
18:49:18 <jcreigh> there we go :)
18:49:37 <sjanssen> scary how often that happens
18:49:46 * Xgc invokes surround sound.
18:49:47 <jcreigh> moconnor: oh, but that won't work for Eq
18:49:55 <robreim> Since ByteString is now a part of the base package, would it be safe to assume it's portable?
18:49:55 <jcreigh> hmm
18:50:02 <jcreigh> I think you still have to write your own Eq
18:50:06 <dons> robreim: indeed.
18:50:12 <robreim> Great, thanks.
18:50:12 <dcoutts> robreim: portable to what?
18:50:13 <dons> it comes with hugs and nhc98, as well as ghc
18:50:16 <moconnor> Hmm, can't seem to load Text.Show.Function.
18:50:21 <moconnor> not found
18:50:31 <moconnor> newer version of ghc required?
18:50:43 <sorear> robreim:
18:50:44 <jcreigh> Text.Show.Functions
18:50:49 <robreim> dcoutts: just portable accross implementations. ie, if I make Network depend on it somehow, I'm not going to break the Network package for any set of implementations.
18:50:51 <sorear> @where Nobench-results
18:50:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
18:50:57 <sorear> robreim: ^^^
18:51:03 <dcoutts> robreim: that's safe
18:51:10 <sorear> robreim: all the implementations that suck at strings are missing fps
18:51:30 <robreim> sorear: thanks, I'd forgotten about that list
18:52:29 <dcoutts> robreim: it'd be great to use (lazy) ByteStrings in a network package
18:52:30 <sorear> dons: k-nucleotide is cheating
18:54:06 <sorear> dons: it doesn't test implementation support well ... are you suprised yhc, nhc, hbc, and jhc are all missing GHC.Exts?
18:54:09 <robreim> dcoutts: Yeah, that should already be supported with socketToHandle for TCP streams though, am I right?
18:54:11 <jcreigh> crap, X11 doesn't want to build.
18:54:20 <jcreigh> hmm
18:54:35 <dcoutts> robreim: right, if you can make a Handle then you can use the existing ByteString IO functions
18:54:46 <sorear> WARNING: A major update to this FAQ list is imminent, probably on September 1, 1995.  Many questions will be rearranged
18:54:56 <sorear> that does not inspire confidence in currency
18:55:45 <robreim> Yeah. So the only thing remaining is to make UDP work with lazy bytestrings. What I found when I tried to do that was that I had to use strict bytestrings and convert them to lazy: http://www.bobturf.org/software/Haskell/Network.hs
18:56:22 <dcoutts> robreim: right, but that's how lazy ByteStrings are constructed internally anyway so that's not surprising.
18:56:45 <dcoutts> one chunk per udp packet I suppose?
18:57:02 <robreim> Yep
18:57:49 <dcoutts> oh, dons, so we should email SPJ today and enquire about spec constr pragmas on data constructors
18:58:07 <robreim> If that's how all lazy bytestrings end up getting constructed I'm glad; I was a little concerned I was doing something pointless by converting to and from strict bytestrings for sending / receiving UDP packets.
18:58:14 <dcoutts> dons: should I draft it or do you want to?
18:58:18 <ekidd> ddarius: Whoo! I understand hom-functors.
18:58:20 <ekidd> That should be enough to take a run at representability.
18:58:23 <dons> dcoutts: go for it.
18:58:33 <ddarius> ekidd: Good!
18:59:10 <ddarius> I did not give representability the respect it deserved for a long time and ended up regretting it.
19:01:40 <ekidd> ddarius: hom-functors appears to be 'Functor (r ->)', as seen here:
19:01:40 <ddarius> ekidd: When I'm handy, which is somewhat hard to tell, throw questions about representability at me (or anything CT).
19:01:48 <ekidd> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Instances.html
19:01:50 <lambdabot> http://tinyurl.com/yrgo4g
19:01:59 <moconnor> I am writing an Eq instance for a data structure: "data Foo = Qux (Integer -> Integer) | ...".  I have to write the instance by hand b/c Qux takes a function, but I thought I could cheat and just do "instance Eq (Integer -> Integer) ..." and define == on that, and then use deriving (Eq) on Foo.  That doesn't work, why?
19:02:08 <ddarius> ekidd: Yep. But the other case requires a ContravariantFunctor class.
19:02:20 <moconnor> I have it working when i do it the long way (and define == for each constructor of Foo)
19:02:28 <moconnor> but I thought I could save myself some redundancy and typing
19:02:54 <kb_> moconnor: well, in general, proving the equivalence of functions is undecidable [though I don't see why that prevents you from giving an incorrect definition]
19:02:58 <sjanssen> @tell dons I just saw your weird focus bug
19:02:58 <lambdabot> Consider it noted.
19:03:10 <ekidd> ddarius: I was sitting there, thinking until my brain started to overheat, and I said, "Hey! I've seen this before!"
19:03:18 <moconnor> kb_: I dont' want to prove the equivalence of functions, i want to hard code it to False is very specific case where I know False is the Right Thing.
19:03:22 <ddarius> class ContraFunctor f where cfmap :: (a -> b) -> f b -> f a; instance ContraFunctor (->r) where cfmap f g = f . g -- or the other way, whichever
19:03:28 <jcreigh> sjanssen: really? Cool!
19:03:31 * ekidd doesn't think he could understand category theory without intuition from Haskell
19:03:37 <jcreigh> sjanssen: reproduced the same way?
19:03:52 <sjanssen> jcreigh: no, I have no idea how it happened
19:03:56 <jcreigh> oh.
19:04:04 * jcreigh sighs
19:04:27 <sjanssen> but I can confirm that strange things can still happen
19:04:31 <jcreigh> you're still running with xinerama patches applied, then?
19:04:40 <ekidd> ddarius: Thanks for the help!
19:04:43 <ddarius> Of course that instance declaration is not valid
19:04:50 <sjanssen> jcreigh: yes
19:05:20 <dolio> > replicate 4 (replicate 3 1)
19:05:21 <lambdabot>  [[1,1,1],[1,1,1],[1,1,1],[1,1,1]]
19:05:39 <ddarius> ekidd: Did you see my suggestion about proving the Yoneda lemma on LtU several months ago?
19:06:47 <ekidd> ddarius: Hmm. What's broken with that instance? fmap id ~ id seems to work, and does fmap (h . g) ~ fmap h . fmap g
19:06:59 <ekidd> ddarius: Nope. Let me Google.
19:07:38 <jcreigh> sjanssen: did you see it while doing a modkey+(j|k) or while switching workspaces?
19:07:43 <ddarius> ekidd: 1) I might've switched the order of the arguments to f . g (the typechecker will yell if I got it wrong) but 2) you simply can't write instance ContraFunctor (->r)
19:08:07 <ddarius> @google Derek Elkins Yoneda Lemma site:lambda-the-ultimate.org
19:08:09 <lambdabot> http://lambda-the-ultimate.org/node/1178
19:08:09 <lambdabot> Title: Djinn, a theorem prover in Haskell, for Haskell. | Lambda the Ultimate
19:08:21 <chessguy> @go 1 mile in km
19:08:22 <lambdabot> 1 mile = 1.609344 kilometers
19:08:32 * ekidd thinks djinn is way too cool
19:08:35 <chessguy> @go 5 km in miles
19:08:36 <lambdabot> 5 kilometers = 3.10685596 miles
19:09:02 <sjanssen> jcreigh: mod+j
19:09:37 <sorear> moconnor: instance declarations must be of the form (T a b c ...) where T is a type constructor and a, b, c, etc are distinct type variables
19:09:39 <nmessenger> @go 8 km in miles
19:09:40 <lambdabot> 8 kilometers = 4.97096954 miles
19:09:51 <sorear> moconnor: (as I'm sure ghc already told you)
19:09:55 <nmessenger> ^^ handy approximation
19:09:59 <sorear> moconnor: why does that error confuse people?
19:10:21 <nmessenger> 60 mph ~= 80 km/h
19:10:33 <nmessenger> 50*
19:11:32 <sorear> hello.
19:12:46 <moconnor> sorear: Yeah, I don't understand that error message.  The (T a b c) thing confuses me b/c most instance declerations I see look like "instance Foo Bar where" and I'm like "uh,, what the fuck is T a b c"
19:12:55 <ndm> hi
19:13:10 <sorear> moconnor: just like functions, types are curried
19:13:14 <ekidd> ddarius: Hmm. (->) r is (r -> -) is Hom(r,-). And (.) f r is (f . r), which should typecheck. If there's a problem there, I'm not seeing it.
19:13:40 <sorear> moconnor: so "instance Foo Bar" is equivalent to "instance Foo (Bar)"
19:13:53 <ddarius> @type \f g -> f . g
19:13:55 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:14:03 <sorear> moconnor: so T is Bar, and there are 0 (a valid nonneg integer) type variables
19:14:22 <sorear> moconnor: in this case, -> is an infix type operator
19:14:29 <ddarius> ekidd: Yeah, I flipped cfmap's args in the (.)
19:14:37 <sorear> moconnor: "instance Eq (Integer -> Integer)" =>
19:14:46 <sorear> moconnor: "instance Eq ((->) Integer Integer)"
19:14:50 <ekidd> Obviously, Haskell won't let us have that instance in scope at the same time as (- -> r).
19:15:06 <sorear> Integer and Integer are not distinct type variables.
19:15:21 <ekidd> ddarius: Oh! The bug was in the contravariant hom-functor, not Functor ((->) r)?
19:15:35 <ekidd> s/bug/potential bug/
19:15:58 <ddarius> ekidd: Actual bug and actual syntactic incorrectness, yes.
19:16:01 <moconnor> sorear: Is that b/c Integer is not a type variable at all?
19:16:12 <sorear> moconnor: right.
19:16:26 <moconnor> sorear: Your explanation makes much sense, thank you!
19:16:40 <ddarius> class BiFunctor f where bfmap :: (a -> b) -> (c -> d) -> f b c -> f a d; instance BiFunctor (->) where bfmap f g h = f . h . g
19:17:30 <ekidd> instance ContraFunctor (-> r) where cfmap f g = g . f, right?
19:17:48 <ekidd> ddarius: Yeah, the bifunctor is really cool.
19:18:45 <dolio> Well, so much for Random Webpage being the authorative documentation of the PPM image format.
19:21:02 <sorear> eh?
19:21:06 <sorear> I use man ppm
19:21:15 <sorear> much faster than even elinks :)
19:22:09 <dolio> Wherever I was reading from told me that it was "HEIGHT WIDTH" instead of "WIDTH HEIGHT".
19:22:40 <sorear> @slap dolio's source
19:22:40 * lambdabot smacks dolio's source about with a large trout
19:23:17 <dolio> So I spent about an hour looking for bugs in the stuff generating my pixels before I realized the bug was that. :)
19:23:23 <ekidd> ddarius: Your Bifunctor is contravariant in its first argument. Wouldn't you really want to call it ContraBifunctor or something, so that you can have Bifunctor (,) and Bifunctor Either?
19:24:42 * stepcut wonders what other useful instance of Bifunctor besides (,) and Either exist
19:25:23 <ddarius> ekidd: Yeah, re ContraFunctor.  With BiFunctor in CT we can use the OP construction, but yeah, it's not as general in Haskell. (sorry, about the delay, making a sandwich)
19:26:20 <ekidd> stepcut: Well, those are the simplest two, and they're duals. But Data.Map should form a bifunctor over key and value types. Really, almost anything of kind * -> * -> * should work.
19:26:50 <stepcut> Map requires Ord though
19:26:59 <nmessenger> @kind State
19:27:01 <lambdabot> * -> * -> *
19:27:05 <nmessenger> :)
19:27:18 <ddarius> So it's first argument is just the category of OrderedSets!
19:27:26 <ddarius> (if only)
19:27:33 <jcreigh> hmm, here's a bug I can reproduce at will with my patches: let 8 and 9 be empty workspaces. switch to 9. create two windows. switch to 8. now try to switch back to 9.
19:27:41 <stepcut> this paper: http://www.cs.nott.ac.uk/~gmh/bananas.ps referes to the ContraFunctor as Difunctor, btw
19:27:42 * ekidd now sees why Haskell arrows are in C^{op} * C -> C
19:27:44 <jcreigh> maybe that's part of the problem
19:27:44 <sorear> @tell sjanssen instance IsString (CharParser a)
19:27:45 <lambdabot> Consider it noted.
19:28:42 <stepcut> You can also implement Bifunctor for HList
19:28:51 <stepcut> instance Bifunctor HCons where
19:28:51 <stepcut>     bimap f g (HCons a b) = HCons (f a) (g b)
19:29:21 <stepcut> but, Either, (,), Map, and HCons are the only obvious ones I see
19:29:28 <stepcut> instance Bifunctor Map.Map where
19:29:28 <stepcut>     bimap f g m = Map.map g (Map.mapKeysMonotonic f m)
19:29:30 <ekidd> ddarius: I need to re-read "Arrows, like Monads, are Monoids" one of these days: http://www.cs.ru.nl/~heunen/publications/2006/arrows/arrows.pdf
19:29:50 <stepcut> and for map, it is unsafe, because it assumes that f does not change the sort order...
19:30:23 <ddarius> ekidd: Ooo, Bart Jacobs.  I have heard of the paper, but didn't realize I hadn't read it.
19:30:42 <sjanssen> sorear: that's a good one
19:30:42 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
19:32:33 <ddarius> ekidd: I'll have to see what the upshot of the paper is; the title is stating something that seems mostly obvious.
19:33:03 <ekidd> ddarius: Well, obvious to me and obvious to you are very different things. :-)
19:35:13 <ekidd> But you're right, it does seem like a fairly natural thing after {blah}map f g h = f . h . g
19:38:57 * sorear synthesizes algebraic kinds using typeclasses
19:41:12 <ddarius> One thing that may help you think about representability is that it pushes categorical concepts out to Set-theoretic concepts (adjunctions do the same only to Cat)
19:41:46 <ekidd> ddarius: It may take me another day or two. :-)
19:42:09 <ekidd> Does anyone know how to write (-> r) so that Haskell won't puke on it?
19:42:17 <mauke> ((->) r)
19:42:24 <mauke> hmm, no
19:42:30 <ekidd> mauke: Isn't that (r ->)?
19:42:34 <mauke> yeah
19:42:55 <stepcut> http://www.haskell.org/pipermail/haskell/2006-September/018487.html
19:42:57 <lambdabot> Title: [Haskell] On computable types. II. Flipping the arrow, http://tinyurl.com/229oor
19:43:02 <mauke> type X r a = a -> r
19:43:05 <stepcut> oleg, of course ;)
19:44:46 <ddarius> ekidd: You could just use Di/BiFunctor and add fmap and cfmap as defaultly implemented methods fmap f = bfmap id f; cfmap g = bfmap g id
19:45:23 * ekidd is used to seeing bifunctor in the category theory texts, fwiw
19:45:57 <ekidd> ddarius: I'll try that.
19:46:22 <ddarius> As an extreme example re representability, products in a category are interpreted by products in set via Hom(A,BxC) ~ Hom(A,B)xHom(A,C)
19:47:08 <ddarius> bifunctor is the term for a functor from the (binary) product category, but, as I said earlier, we unfortunately do not (handily) have the op construction
19:47:15 <ekidd> ddarius: I *think* that makes sense to me. :-)
19:47:50 <ddarius> It says an arrow into the product "type" is a pair of arrows
19:47:56 <ekidd> (That was in response to Hom(A,BxC))
19:49:33 <ndm> @seen dons dcoutts
19:49:33 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 51m 11s ago.
19:49:39 <encryptio> does GHC's String type support a form of unicode?
19:49:55 <dons> ndm. pong
19:49:55 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:50:13 <dons> sjanssen: good.
19:50:16 <dons> :-)
19:50:23 <ddarius> ekidd: Implementing that isomorphism (adjunction actually) in Haskell is easy and straightforward.
19:50:31 <sorear> encryptio: String is UTF-32
19:50:34 <ndm> dons, i was thinking bytestring thoughts - was wondering if your typical lines in a file example is faster than getc and checking for (and counting) '\n' s?
19:50:43 <ndm> dons, and in particular if you beat them why, and if you loose why
19:51:02 <encryptio> sorear: what about I/O?
19:51:26 <sorear> encryptio: iso8859-1 input, truncated to 8 bits on output
19:51:26 <dons> ndm, getc uses blocking reads, we use large chunk reads. the result should be about the same.
19:51:38 <dons> actually, no, we win, unless they use blocked input
19:51:45 <encryptio> =\
19:51:58 <encryptio> sorear: any way to explicitly change that?
19:52:02 <sorear> encryptio: no
19:52:25 <ndm> dons, a file is blocked input? so they win on files?
19:53:01 <dons> haven't tested that benchmark lately, so i'm not sure.
19:53:03 <dons> it'd be a close thing.
19:53:15 <dons> you've seen the sum-col benchmark? that's similar to counting lines
19:53:30 <dons> (though the C read :: String -> Int is far too slow)
19:53:32 <ndm> cool, i think i can (with -O11) transform the haskell list version to the getc low level one without any rules
19:53:57 <ndm> was wondering if after i had, i'd win/loose/draw with bytestring
19:54:21 <dons> running in yhc? or ghc?
19:54:26 <ndm> yhc
19:54:33 <dons> yhc doesn't support bytestrings. so...
19:54:34 <ndm> well, generating C from Yhc.Core
19:54:52 <ndm> i meant beat GHC with bytestrings speed, using Yhc and Lists
19:55:10 <dons> i doubt it. but feel free to prove me wrong :-)
19:55:11 <stepcut> ndm: do you go straight from Core to C ? Or do you take a walk through STG on the way ?
19:55:27 <ndm> stepcut, i'll be ignoring STG
19:55:43 <ndm> dons, its merely a wild dream right now, but it is the goal
19:55:45 <sorear> stepcut: stg is much of the reason ghc is so slow
19:55:53 <stepcut> sorear: oh ?
19:56:04 <dcoutts> sorear: originally it was the reason ghc was so fast :-)
19:56:40 <ndm> they are putting tags back in
19:56:48 <ndm> Yhc's C back end will have tags
19:56:56 <ndm> but no higher order functions
19:57:44 <ekidd> @paste
19:57:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:58:09 <stepcut> so, first we have the Spineless Tagless G machine, then we get, putting the spine back in the STG machine, and soon we will have, putting the spine and tag back in the STG machine ?
19:58:43 <ndm> stepcut, the spine is unlikely to ever go in - my machine will be super-spineless
19:58:50 <stepcut> heh
19:59:00 <ndm> super-spineless totally-tagged machine
19:59:13 <hpaste>  ekidd pasted "Contra1Bifunctor (thanks ddarius)" at http://hpaste.org/1036
19:59:31 * sorear is writing a typechecker in the typesystem
20:00:13 <stepcut> ndm:  nifty. I have been working on a Yhc core -> stg -> action script bytecode backend. I expect it to be quite slow ;)
20:00:29 <ndm> stepcut, have you seen teh javascript back end?
20:00:37 <stepcut> ndm: yes
20:00:44 <ndm> stepcut, plus we already have an STG machine in bytecode
20:00:54 <stepcut> ?
20:00:56 * sorear is still working (mostly distracted by hv) on a yhc forthy (standalone or hosted) jitting interp, with grin-like features
20:02:52 <ekidd> Hmm, c1bfmap really looks like an arrow operator.
20:02:59 <ndm> stepcut, our bytecode is STG based
20:02:59 * ekidd looks at arrow API.
20:03:37 <sorear> ndm: no, it's based on the Spineless G-Machine
20:04:02 <sorear> ndm: tomshackell told me in (private? must check) email a week or two ago
20:04:03 <ddarius> @hoogle Arrow arr => arr a b -> arr c d -> arr b c -> arr a d
20:04:04 <lambdabot> Did you mean: Arrow arr => Arr a b -> Arr c d -> Arr b c -> Arr a d
20:04:16 <ndm> sorear,  ok, he knows that bit much better than me
20:04:16 <nmessenger> @type (***)
20:04:18 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
20:05:15 <stepcut> ndm: yes, but actionscript byte-code engine (aka flash .swf) is pre-installed many more places ;)
20:05:26 <ekidd> nmessenger: Nope, that doesn't look like it. Hmm.
20:06:07 <ndm> stepcut, oh, you are going direct to the actionscript bytecode
20:06:18 <stepcut> ndm: yes
20:06:23 <ndm> stepcut, that sounds very handy
20:06:41 <stepcut> ndm: could be. So far it just educational :)
20:06:44 <ekidd> @hoogle Arrow arr => (c -> a) -> (b -> d) -> arr a b -> arr c d
20:06:45 <lambdabot> Did you mean: Arrow arr => (c -> a) -> (b -> d) -> Arr a b -> Arr c d
20:06:52 <sorear> how does a on-the-fly converting ClassLoader sound?
20:06:59 <ndm> stepcut, as soon as you have anything close, be sure to send us a patch
20:07:53 <mbishop> So I saw C# 3.0 is trying to be ML
20:07:54 <sorear> stepcut: note that getting hello world working in a .hbc system is fairly hard, you need to implement half the ffi first
20:08:12 <dibblego> mbishop, F# more so
20:08:25 <mbishop> Well F# is at least actually ML heh
20:08:33 <sorear> stepcut: OTOH once you have the ffi and basic graph reduction that's *it*, there are no special rts primops
20:08:39 <stepcut> ndm: i will -- it can compile some simple stuff, but is missing some important things -- like saving the environment when it is should
20:08:43 <mbishop> C# 3.0 is introducing some new stuff to try and give it type inference, and anonymous functions
20:09:03 <ekidd> ddarius: Arrow appears to be "Contra1Bifunctor" from my example, for all intents and purposes.
20:09:05 <dibblego> just trying to stay one step ahead of Java I guess - not hard to do
20:09:08 <stepcut> sorear: yeah, I hand coded up a ffi call for printing a value
20:09:29 <ekidd> Too bad it's missing the categorically-reasonable {blah}map function.
20:09:43 <mbishop> Meh, I think microsoft (at least MSR) has learned that functional programming has a lot of good ideas
20:10:07 <ddarius> mbishop: If C# gets tail calls, it will be rather sweet.
20:10:23 <dibblego> the .NET runtime has a tailcall instruction iirc
20:10:34 <ddarius> And a bit more aggressive (local) type inference
20:10:49 <ekidd> mbishop: I keep threatening to port my Bayesian monad to Visual Basic.Net for the sheer twistedness of it.
20:10:58 <mbishop> eww
20:11:35 <ekidd> mbishop: All it would take is a little abuse of LINQ, and I'd be in business. ;-)
20:11:57 <mbishop> I kind of like the way they added type inference to C# 3.0, a special keyword does inference on the variable name based on it's value, but it's backwards compatable with other code, since you can still declare your types if you like
20:12:13 * ekidd is vaguely alarmed that Visual Basic.Net will have built-in support for MonadZero
20:12:35 <jcreigh> oh, haha. I think I found (one of?) the focus bugs in my xinerama patches to xmonad.
20:13:43 <ekidd> ddarius: I think I understand the various Hom-functors. Thanks!
20:13:53 <sorear> and I'll bet it's something absolutely ridiculous :(
20:14:01 <ekidd> Now to take a look at representation, which is about 1 paragraph in Pierce. Hmm.
20:14:04 <sorear> Haskell needs a better bug detector.
20:14:16 <nmessenger> @type \f g h -> f ^>> h >>^ g
20:14:18 <lambdabot> forall b c (a :: * -> * -> *) c1 d. (Arrow a) => (b -> c) -> (c1 -> d) -> a c c1 -> a b d
20:14:43 <ekidd> nmessenger: I think you found it!
20:15:33 <ddarius> ekidd: Well, the formal part of representability is ridiculously simple, a (contravariant) functor F is representable iff F ~ Hom(-,X) for some X. Full stop.
20:15:34 <nmessenger> heh, I originally had 'h' named as 'a', but that was a bad idea :3
20:16:23 <ekidd> @type \f g h -> pure f ^>> h ^>> pure g
20:16:25 <lambdabot>     Ambiguous occurrence `pure'
20:16:25 <lambdabot>     It could refer to either `pure', imported from Control.Arrow
20:16:28 <chessguy> ekidd: lol, you're still working on your "simple introduction" to category theory?
20:16:31 <sorear> ekidd: arr
20:16:40 <sorear> ekidd: pure is also in control.applicative
20:16:47 <nmessenger> arr!
20:16:50 <nmessenger> @arr
20:16:51 <lambdabot> Drink up, me 'earties
20:17:08 <ekidd> chessguy: Everyone kept asking for applications, so it's going to get a major overhaul before I publish it.
20:17:18 <chessguy> nince
20:17:23 <chessguy> s/nc/c/
20:17:30 <mbishop> @girl19
20:17:30 <lambdabot> well.. I never hacked Russians
20:17:37 <chessguy> @quote russia
20:17:38 <lambdabot> vegai says: in soviet russia, YOU blow up GHC's brain!
20:17:44 <ekidd> Right now, I'm just messing around with slightly less simple category theory. And ddarius  is helping me become enlightened. :-)
20:17:52 <chessguy> @quote brain
20:17:52 <lambdabot> adept says: I think I need cobrain to understand coeffects
20:18:21 <chessguy> on that note, time for bet
20:18:27 <chessguy> bed!
20:18:33 <ekidd> @type \f g h -> Control.Arrow.pure f ^>> h ^>> Control.Arrow.pure g
20:18:35 <lambdabot> forall b c c1 d (a :: * -> * -> *). (Arrow a) => (b -> c) -> (c1 -> d) -> (c -> c1) -> a b d
20:19:06 <nmessenger> (^>>) is arr + (>>>)
20:19:11 <nmessenger> @src (^>>)
20:19:11 <lambdabot> f ^>> a = arr f >>> a
20:19:27 <ekidd> nmessenger: Oh, OK
20:19:35 <jcreigh> sorear: yeah, it was something stupid.
20:19:42 <ekidd> Now I see what you were doing.
20:19:42 <jcreigh> sloppy workspace focus might just have to wait
20:19:43 <ekidd> Cool.
20:20:20 <ekidd> nmessenger: Should we name it arrmap?
20:20:24 <sorear> writing typecheckers in the typesystem is fun!
20:20:30 * ekidd Arrr, me hearties!
20:20:47 <nmessenger> ekidd: if you like :)
20:21:01 <ddarius> sorear: It should be pretty straightforward, logic languages are decent for type checkers.
20:21:23 <nmessenger> simple enough, though, that I'm not sure it needs a name.
20:21:47 <sorear> ddarius: plus the language I'm checking has a notoriously simple typesystem
20:22:05 <ekidd> nmessenger: Well, I think it's more fundamental than most of the stuff in the Arrow class, at least from a categorical viewpoint.
20:22:31 <ddarius> One could probably do the simply typed lambda calculus in less than 10 lines of class/instance declarations.
20:24:18 <ddarius> @type \f g h -> f >>> h >>> g -- would be more proper for Arrow
20:24:20 <lambdabot> forall (a :: * -> * -> *) b c c1 d. (Arrow a) => a b c -> a c1 d -> a c c1 -> a b d
20:25:37 <nmessenger> that's just pre- and postcomposition of Arrows.  The "more fundamental" part is like how fmap is "more fundamental" than return and (>>=).
20:26:27 <nmessenger> after all, fmap f x = x >>= return . f
20:26:50 <ekidd>  nmessenger: It's not unreasonable to generalize to f >>> h >>> g here.
20:27:28 <ekidd> And return is fundamental enough. It's >>= that has cooties. :-)
20:27:58 <ddarius> I'm unsure what you are getting at, or rather what you are using Arrows for.
20:28:16 <nmessenger> also fmap f x = return f <*> x, so apparently (<*>) is also cootieful.
20:28:41 <ddarius> Those simply mean that fmap is more generally applicable.
20:28:48 <nmessenger> yep
20:28:53 <ekidd> ddarius: I'm trying to decide if Arrow is really just another name for Contra1Bifunctor.
20:29:18 <sorear> drat, ghc wants -fallow-undecidable-instances
20:29:42 <sorear> My algorithm is strongly negative!
20:29:50 <nmessenger> ekidd: maybe a subclass, since Contra1BiFunctor would only have c1bfmap.
20:30:24 <ekidd> Anyway, I'm off to do the dishes, and to try to pound representability into my brain.
20:30:47 <ekidd> Thanks, ddarius!
20:31:23 <jcreigh> dons: okay, I found the fix for at least some of the focus problems. I was trying to do sloppy workspace focus (make the workspace you mouse over become the current workspcae) but there are subtle issues with that (ask if you want details) so the fix I've implemented is just to revert back to the head version of the enterNotify event handler. My question is, what do I do now? both in general (are we going to go with a xinerama ...
20:31:29 <jcreigh> ... branch?) and darcs-wise (I'm still a darcs newbie, so if we did a branch, what would it mean in practical terms?)
20:31:38 <jcreigh> hmm, maybe that would have been a @tell or an email. :)
20:33:34 <jcreigh> s/would/should/
20:33:38 <dons> i'd like to have it in the head branch, if it works, and behves like dwm
20:33:51 <dons> so no semantic divergence (i.e. no sloppy focus and so on)
20:34:54 <jcreigh> well, dwm doesn't have xinerama, so it's hard to behave like it. :)
20:35:07 <sorear> booyah!
20:35:10 <sorear> tc (undefined :: (TL (L (V Z) (V Z)))) :: Pi ((:->) (V Z) (V Z))
20:35:43 <nmessenger> kc5tja: the paper mentions (in section 2.2) an (unfoldr :: (b -> Either () (a,b)) -> b -> [a]), and says in passing that it's equivalent to (unfoldr :: (b->Bool) -> (b->a) -> (b->b) -> b -> [a]), but doesn't prove it.
20:35:43 <sorear> where TL == type lambda, L == lambda, V == variable, Z == zero (de Bruijn numbers)
20:36:26 <sorear> nmessenger: the first is generable, but not minimal in Haskell
20:36:51 <sorear> (b -> Either () (a,b)) -> b -> [a]   ==> by Maybe = Either ()
20:37:01 <sorear> (b -> Maybe (a,b)) -> b -> [a]
20:37:04 <sorear> :t unfoldr
20:37:06 <jcreigh> dons: what? doesn't dwm use sloppy focus?
20:37:06 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:37:07 <sjanssen> dons, jcreigh: it's good to avoid a branch if at all possible -- too much work and coordination
20:37:08 <nmessenger> yes I understand Either () = Maybe at least
20:37:53 <nmessenger> what do you mean "not minimal"?
20:38:14 <nmessenger> ^^ that?
20:38:57 <jcreigh> so when we put this back into head, do we have to make an "unundo" patch?
20:39:22 <sjanssen> jcreigh: yeah, it's sloppy focus.  I guess we need to fix it to get tiling to work too
20:39:38 <sjanssen> jcreigh: I'm not really sure how that works . . .
20:39:50 <jcreigh> sjanssen: well, it's sloppy keyboard focus *right now* (ie, in head, without my patches)
20:40:16 <jcreigh> sjanssen: it's just that, if you have workspace 1 on monitor A, and workspace 2 on monitor B, if you move the mouse to monitor B, the current workspace will still be workspace 1
20:40:19 <Jyrinx> /tell lambdabot @help
20:40:26 <Jyrinx> Dernit ...
20:40:33 <jcreigh> so it's not, for the lack of a better term, "sloppy workspace focus"
20:40:56 <sorear> @help
20:40:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:41:13 * sorear resumes oleging
20:41:36 <jcreigh> so I figured I could live with having to manually switch workspaces to make new windows show up somewhere for now.
20:41:54 <sjanssen> jcreigh: sounds good
20:42:03 <nmessenger> oleg is a verb now!
20:42:21 <jcreigh> oleg got verbed? :)
20:42:47 <nmessenger> "That rather olegy code."
20:43:00 <nmessenger> grr, That's*
20:43:06 <sorear> "type class oleging" has been an acceptable construction for quite some time...
20:43:32 <sorear> I can't wait to see oleg's reaction when I post this on the ML
20:43:36 <nmessenger> I knew that the oleg is a unit of typecalss hackery
20:43:50 <sorear> probably some variation on "I can't believe someone this dumb exists"
20:43:58 <sorear> but it'll still be fun to see...
20:44:03 <sjanssen> sorear: he'll totally outdo you in a reply with a new subject line
20:44:35 <jcreigh> so should I submit the patch now, or sit on it a couple days to see if it tries to start a global thermonuclear war? (Or, worse yet, have more focus bugs)
20:44:46 <ddarius> Nah, he'll just point at "work"  (mailinglist post) he did in the late 90's.
20:45:25 <sjanssen> jcreigh: did you pull the unrecord patches to your working repo?
20:45:30 * ddarius is surprisingly resistant to the idea of a nuclear holocaust right yet.
20:45:43 <jcreigh> sjanssen: not yet...that was going to be my next question; how does this work with darcs?
20:46:03 <jcreigh> ddarius: oh, come on! it'll do wonders to get people to abandon COBOL! :)
20:46:39 <sjanssen> jcreigh: we probably won't be able to apply your patch if it's recorded before the "UNDO" patches
20:46:51 <sjanssen> and I don't know if darcs has un-undo
20:47:09 <desp> have you guys seen http://arstechnica.com/journals/apple.ars/2007/03/18/minireview-papers-for-os-x ? looks awesome
20:47:11 <lambdabot> http://tinyurl.com/2xp8wl
20:47:31 <ddarius> jcreigh: Most of the rest of my life, I'd be all for it, but not now.
20:48:43 <jcreigh> so it sounds like the easiest thing would be to make a new patch against head the re-introduces the xinerama support?
20:49:02 <sorear> ddarius: 14 instances and 3 classes for System F
20:49:07 <sjanssen> lemme see what happens if I un-undo those patches
20:49:39 <ddarius> sorear: Code will be forthcoming on the mailinglist?
20:50:06 <sorear> ddarius: especially so, now that you ask :)
20:50:08 <sjanssen> hmm, it seems darcs won't let me
20:51:42 <sjanssen> jcreigh: I'm not sure how to handle this
20:51:46 <sjanssen> dons: suggestions?
20:52:01 <dons> sjanssen: rollback the rollback patch?
20:52:39 <sjanssen> darcs failed:  cannot roll back a 'rollback' patch.
20:53:32 <dons> ah. go into the ~sjanssen/xmonad dir, unpull the UNDO patches manually
20:53:41 <dons> then tell everyone who has those to do the same
20:53:51 <sjanssen> okay.  And hope that nobody has pulled in the last few hours
20:54:03 * sjanssen unpulls
20:54:26 <ddarius> whew, though I think it'll be easier for me to start from scratch *sigh*
20:54:59 <sjanssen> jcreigh: you may send your patch
20:55:09 <jcreigh> okay
20:58:34 <dons> sjanssen: and you 'darcs revert'ed after the unrecord?
20:58:40 <dons> oh, unpull should do that, I guess
20:58:48 <sjanssen> yeah, it does
20:59:42 <jcreigh> patch sent. (two patches, actually; the one to stop trying to change the current workspace automagically, and a minor patch to trace wsOnScreen when it changes)
21:00:12 <jcreigh> it's cool how you can "darcs record" only the changes you want to be in a given patch.
21:00:17 <dons> jcreigh: and does it work? :-)
21:01:24 <jcreigh> dons: the debug output? Yeah, I've never had a problem with it. :) Yeah, I think so. Please bug me immediately if it does not.
21:02:20 <jcreigh> I really appreciate how willing you guys have been to work with me on this...I really want to see a good, xinerama-enabled, (dwm|wmii)-style WM.
21:02:47 <sjanssen> xinerama doesn't seem so complicated, I wonder why the wm writers hate it so much
21:04:07 <kc5tja> I really wish Haskell had a single-stepping debugger.  >:(
21:04:40 <dons> kc5tja: ghci in ghc head supports this.
21:04:50 <Jyrinx> Does it single-step yet though?
21:05:04 <Shimei> Has anyone else had problems with compiling programs that use gtk2hs? I'm getting tons of "undefined reference" errors.
21:05:08 <Jyrinx> (my working copy says :breakpoint step is "disabled")
21:05:26 <dcoutts> Shimei: can you give more details?
21:05:54 <dcoutts> Shimei: what are you doing? building gtk2hs itself, or building a program that uses it?
21:05:59 <dcoutts> what os/ghc version etc
21:06:07 <sjanssen> Shimei: you probably need to add -package gtk2hs
21:06:24 <sjanssen> or just build with --make
21:06:37 <Shimei> A program that uses gtk2hs itself. GuiHaskell (http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php). On Debian with GHC 6.6.
21:06:46 <Shimei> I'm using the --make flag.
21:07:06 <Shimei> Here's a sample: "/usr/local/lib/gtk2hs/libHSgtk.a(General__15.o):(.rodata+0x0): undefined reference to `glibzm0zi9zi10zi5_SystemziGlibziUTFString_fromUTF_closure'"
21:07:37 <dcoutts> Shimei: did you build gtk2hs yourself or from a package?
21:07:47 <Shimei> I built it myself from a debian source package.
21:08:14 <emk> Hmm. "Cartesian closed category" implies "arrows are first class", roughly speaking.
21:08:33 <dcoutts> Shimei: check this: ghc-pkg field gtk depends
21:08:40 <dcoutts> Shimei: does it include glib ?
21:09:01 <Shimei> Yeah. It outputs "depends: glib-0.9.10.5 cairo-0.9.10.5"
21:09:24 <ddarius> emk: Yes
21:09:28 <ddarius> and speak of the devil
21:10:36 <ddarius> emk: The relationship between Arrows Hom to an extent is Freyd categories are roughly an inclusion of a "pure language" into an "effectual" one.
21:11:51 <ddarius> The A(-,=) bifunctor in Arrows, like Monads, are Monoids essentially shows this by adapting the "pure" arrows into an "effectual" Hom (A)
21:13:52 <kc5tja> dons: Found the problem with the parser; remember when I said that it builds the list backwards?  Well, that was the problem.  Once I reversed the list, things started working as expected.  Which is good.  Suspected insanity leads to the dark side.  :)
21:14:07 <dcoutts> Shimei: what does this give: nm /usr/lib/<whatever>/libHSglib.a | grep UTFString_fromUTF
21:14:35 <dcoutts> Shimei: using the right path of course, which is something like /usr/lib/libghc6-glib-dev/
21:15:06 <kc5tja> @src nub
21:15:07 <lambdabot> nub = nubBy (==)
21:15:13 <kc5tja> @hoogle nub
21:15:13 <lambdabot> List.nub :: Eq a => [a] -> [a]
21:15:13 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
21:16:19 <Shimei> dcoutts: http://hpaste.org/1037
21:16:29 <Shimei> Whoops, forgot the grep there.
21:16:39 <ddarius> Hom(A,B) ~ Hom(1,B^A)  so the "elements" (categorical notion) of B^A are exactly the elements of Hom(A,B)
21:16:43 <encryptio> > iterate (*2) 1 !! 0
21:16:44 <lambdabot>  1
21:17:03 <Shimei> dcoutts: The grep returns nothing though.
21:17:25 <dcoutts> Shimei: ok, so something is messed up
21:17:43 <ddarius> If the adjunction that defines exponents is strong then your statement holds even more strongly.
21:18:14 <dcoutts> Shimei: the glib and gtk etc all got built at the same time right?
21:18:43 <dcoutts> Shimei: btw, was that the full output you pasted? if so it's very short and missing a bazillion things
21:18:53 <Shimei> Yeah, that was the full output.
21:18:56 <ekidd> ddarius: Most of this stuff doesn't seem all that hard, provided I'm willing to start at it long enough.
21:19:07 <ekidd> s/start/stare
21:19:25 <dcoutts> Shimei: ok, that screwed up, that includes *no* Haskell code, what you see there is only C code.
21:20:34 <ddarius> ekidd: In general, the basics of any mathematical area is usually -much- simpler than it initially seems.
21:20:53 <ddarius> ekidd: And is actually ridiculously straightforward.  Mathematicians do know what they are doing.
21:21:03 <dcoutts> Shimei: so something in the build went seriously wrong
21:21:09 <ekidd> ddarius: It doesn't hurt to have good advice from people who understand it. :-)
21:21:40 <Shimei> dcoutts: It seems that one of the flags I passed ./configure messed that one up. I'll see if taking that out fixes the compile problem.
21:22:03 <ekidd> ddarius: I bailed on math after a few bad experiences at the undergrad level, so it's pleasant to discover that most of it is learnable, given the right mindset.
21:22:50 * ddarius has tended to hack through it slowly on his own.  It would have been/be extremely nice sometimes to have someone else.
21:23:24 <ddarius> Colleagues is the only meaningful to me reason for me to go to college.
21:23:34 <dons> http://www.haskell.org/pipermail/haskell/2007-March/019251.html
21:23:35 <lambdabot> Title: [Haskell] ANNOUNCE: ndp-0.1, nested data parallelism in Haskell
21:23:45 <Shimei> dcoutts: Actually, that didn't fix it. It appears glib is still messed up. I may go fetch a new version off of the official site instead. Maybe Debian's too old.
21:23:49 <ddarius> Getting a piece of paper is nice, but doesn't matter to me, just employers.
21:24:38 <ekidd> ddarius: There was the occasional professor who totally blew my mind, and left seeds which sprouted years later.
21:25:54 <dons> http://programming.reddit.com/info/1b8ql/details :-)
21:25:55 <lambdabot> Title: ndp: a library for multicore parallel arrays in Haskell, now! (reddit.com)
21:26:27 <ekidd> dons: ndp++
21:26:27 <ddarius> Yay nested data parallelism
21:26:40 <ekidd> I can't wait until all the stuff in the papers is implemented.
21:27:17 <Shimei> Yay for example programs.
21:27:37 <kc5tja> @hoogle reverse
21:27:37 <lambdabot> Prelude.reverse :: [a] -> [a]
21:27:37 <lambdabot> Data.PackedString.reversePS :: PackedString -> PackedString
21:27:45 <Cale> Heh, also the New Democrat Party of Canada :)
21:27:47 <kc5tja> @src reverse
21:27:47 <lambdabot> reverse = foldl (flip (:)) []
21:28:06 <kc5tja> The reverse operator doesn't also implicitly nub a list, does it?
21:28:22 * ddarius still needs to read Manuel's paper.
21:28:22 <kc5tja> For some bizarre reason, my list of parsed nodes has duplicates removed, even though I never invoke nub.
21:28:37 <ddarius> That and about 150 others...
21:28:41 <kc5tja> (And while this is ultimately the intended behavior, the fact that GHC is exercising "I know what you mean" technology is disconcerting)
21:29:05 <dolio> > reverse $ replicate 5 1
21:29:06 <lambdabot>  [1,1,1,1,1]
21:29:33 <Cale> No, it doesn't delete things. Perhaps some of your code is somehow removing duplicates due to some assumptions you made while writing it?
21:29:51 <Cale> Should there be duplicates?
21:30:00 <kc5tja> As far as I can tell, nothing in my code is deleting duplicates.
21:30:09 <kc5tja> Cale: In this case, yes, there should be.
21:30:53 <Cale> hmm, I don't know how complicated your code is, but probably the best thing for it would be to take a small example and try to evaluate it by hand.
21:31:00 <kc5tja> If I print the (lexer) token list prior to reversal, it's huge -- 7MB worth of data.
21:31:06 <kc5tja> If I reverse it, it's only 5 lines.
21:31:24 <Shimei> dcoutts: BTW: I finally got it working by finding some proper Debian packages for gtk. Thanks for the help. :)
21:31:34 <jcreigh> no, reverse just reverses the lists, nothing magic.
21:32:29 * kc5tja is isolating the problem to the parser.
21:34:26 <ddarius> Lucky for me, Arrows, like Monads, are Monoids is unfolding pretty much exactly as I thought it would.
21:41:26 <yshhq> @src tails
21:41:26 <lambdabot> tails []         = [[]]
21:41:27 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
21:41:38 <dcoutts> Shimei: great
21:42:03 <yshhq> @type tails
21:42:05 <lambdabot> forall a. [a] -> [[a]]
21:42:18 <yshhq> >tails [1..5]
21:42:24 <nmessenger> > tails [1..5]
21:42:25 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
21:51:44 <samx> I have a list of Maybes ([Maybe Int]), and want to get rid of 'Nothing's to get a list of Ints ([Int]), what's the easiest way to do this?
21:51:59 <dons> catMaybes
21:52:04 <dons> ?hoogle catMaybe
21:52:04 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
21:52:10 <samx> excellent. thx
21:52:15 <dons> > catMaybes [Nothing, Just 1, Nothing, Just 3]
21:52:17 <lambdabot>  [1,3]
21:52:44 <yshhq> @help
21:52:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:52:54 <yshhq> list
21:52:56 <yshhq> @list
21:52:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:53:24 <yshhq> @dice
21:53:24 <lambdabot> unexpected end of input: expecting number
21:53:30 <nmessenger> @dice 2d6
21:53:30 <lambdabot> 2d6 => 6
21:53:45 <Cale> > [Nothing, Just 1, Nothing, Just 3] >>= maybeToList
21:53:47 <lambdabot>  [1,3]
21:54:07 <Cale> A more obscure way to do it :)
21:54:27 <nmessenger> obscure?  Makes sense to me.
21:55:00 <Cale> relative to catMaybes
21:57:06 <ekidd> dons: Your ndp post is gone reddit.
21:57:48 <ekidd> There's something odd going on with reddit right now.
21:57:51 <dons> yeah.
21:57:55 <dons> i noticed that too.
21:58:01 <dons> sometimes its htere, sometimes not.
21:58:05 <jcreigh> is it just me, or is Knuth a bad public speaker?
21:58:18 <ddarius> Hmm, unsafeCoerce . filter id . unsafeCoerce :: [Maybe a] -> [Maybe a]
21:58:19 <dons> sometimes the comments don't appear either
21:58:23 <dons> http://programming.reddit.com/info/1b8ql/details
21:58:25 <lambdabot> Title: ndp: a library for multicore parallel arrays in Haskell, now! (reddit.com)
21:58:31 <dons> ddarius: crikey.
21:59:08 <dons> Prelude GHC.Base> :set -fglasgow-exts
21:59:08 <dons> Prelude GHC.Base> let f = unsafeCoerce# . filter id . unsafeCoerce# :: [Maybe a] -> [Maybe a]
21:59:11 <dons> Prelude GHC.Base> f [Just 2, Nothing, Just 3]
21:59:14 <dons> [Just 2,Just 3]
21:59:19 <ddarius> Sweet!
21:59:48 <nmessenger> > map Just . catMaybes $ [Just 2, Nothing, Just 3]
21:59:49 <lambdabot>  [Just 2,Just 3]
21:59:54 <nmessenger> :D
21:59:58 <jcreigh> gah, my head hurts. what does unsafeCoerce# do?
22:00:09 <nmessenger> jcreigh: evil things!
22:00:12 <dons> ignores the type system
22:00:15 <jcreigh> > filter isJust [Just 2, Nothing, Just 3]
22:00:17 <kc5tja> Yeah, it looks like the parser is prematurely ending its parse for some reason.  :(
22:00:17 <lambdabot>  [Just 2,Just 3]
22:00:22 <dons> and asserts that the representation of two values are equial
22:00:23 <sorear> isn't it obvious how ddarius' code works?
22:00:40 <jcreigh> sorear: "yes", it isn't. :)
22:00:47 <dons> yeah, it inspects the tag
22:00:54 <nmessenger> Spark: Nothing is in the same place False is?
22:00:59 <sorear> right.
22:01:00 <dons> and casts Just -> 1, nothing -> 0, no?
22:01:02 <nmessenger> evil!
22:01:19 <sorear> nmessenger: this might not work on head, though - vectored returns are gone
22:01:19 <jcreigh> I like "filter isJust" better
22:02:02 <jcreigh> dons: representation? So is this like casting raw pointers?
22:02:07 <sorear> yes
22:02:09 <sorear> muahaha!
22:02:20 <jcreigh> you're all mad! Mad I say! :)
22:02:21 <sorear> @users
22:02:22 <lambdabot> Maximum users seen in #haskell: 336, currently: 290 (86.3%), active: 36 (12.4%)
22:02:26 <dons> jcreigh: yes. welcome to introductory C programming
22:04:02 <nmessenger> @remember dons [jcreigh] representation? So is [unsafeCoerce#] like casting raw pointers? [dons] yes. welcome to introductory C programming
22:04:02 <lambdabot> Done.
22:04:20 <nmessenger> :)
22:04:45 <sorear> say, anyone know a good ref for *implementing* floating point?
22:04:59 <ddarius> IEEE 795
22:05:12 <jcreigh> sorear: what, building a CPU?
22:05:12 <sorear> does that specify algorithms?
22:05:31 <sorear> jcreigh: no.  I'm writing a raytracer in the typesystme
22:05:39 <ddarius> er 754
22:05:54 <sorear> jcreigh: afraid yet?
22:06:00 <kc5tja> sorear: Maybe, if that turns out to be too much, you could use rationals instead of reals.
22:06:03 * nmessenger hides
22:06:06 <ddarius> sorear: I doubt it.  It's all pretty straightforward to (naively) implement if you understand the representation.
22:06:09 <jcreigh> #haskell: where "I'm writing a raytracer in the typesystem" is no idle threat. :)
22:06:22 <ddarius> I started an arbitrary precision floating point library in assembler a long long time ago.
22:06:58 <mbishop> and you just finished now? :)
22:07:02 <nmessenger>  @topic-cons!
22:07:42 <ddarius> I'm pretty sure the code has gone where the woodbine twineth.  This was like 8 years ago or something like that.
22:07:43 <sorear> that's suprising...  /msg chanserv op #haskell didn't work
22:07:59 --- mode: ChanServ set +o dons
22:08:06 --- topic: set to '["The Haskell programming language: Summer of Code time! http://hackage.haskell.org/trac/summer-of-code/","I'm writing a raytracer in the typesystem","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
22:08:11 --- mode: ChanServ set -o dons
22:10:07 * ddarius had a raytracer in 256 bytes several years ago as well.
22:10:41 <sorear> ddarius: you used hard fp for that? :)
22:10:57 * jcreigh never completed his attempt to fit tetris in the boot sector
22:11:09 <jcreigh> somebody had already done it.
22:11:19 * sorear never completed his attempt to fit forth in the boot sectora
22:11:29 <ddarius> That was... interesting.  I've wanted to rewrite it as I was hoping to have it be somewhat flexible, but didn't have the space, I could probably have trimmed some bytes and made it faster otherwise.
22:11:35 <jcreigh> But I was surprised to find out that the rotate algorithm can be 2 x86 instructions.
22:11:44 <Sgeo> ICFP?
22:11:46 <ddarius> x86 asm for DOS
22:12:02 <kc5tja> sorear: Shame on you.  :)
22:12:39 <sorear> well, my haskell interpreter is becoming very forthlike
22:13:27 <sorear> I've written at least four partial forths so far
22:13:39 <ddarius> Real-mode was so fun
22:13:41 <sorear> I will say writing floppy drivers is a PITA
22:14:27 <sorear> Strangly, out of my asm os, my C os, and my forth os, I only managed to drive the floppy from asm.  seems like it'd be easier with a higher level lang
22:15:09 <Pseudonym> Floppy drivers are finite state machines.
22:15:24 <Pseudonym> If you understand that, surely you can model them in any language elegantly enough.
22:17:59 <ddarius> asm is fairly nice, especially if you don't know about CPS and don't use languages with HOFs and tailcalls.
22:18:32 * ddarius is thinking about slickly popping out another PDFlib (in Haskell this time).
22:18:52 <ddarius> For anyone else, for future reference, read the ps spec before the pdf one.
22:26:35 <rubenz> I am using ghc on a network. It is missing the modules needed to use opengl however. Is it possible to install them locally?
22:26:46 <dons> yeah, grab them from hackage
22:26:48 <dons> ?where hackage
22:26:48 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
22:26:52 <dons> the OpenGL package?
22:27:35 <rubenz> OpenGL and GLUT
22:28:25 <rubenz> Will it matter if the ghc version is a bit old (6.4)?
22:28:36 <dons> yes. quite possibly.
22:28:48 <dons> you're best to grab the version that was distributed with ghc 6.4, if possible
22:28:52 <dons> which won't be the one on hackage.
22:28:57 <Procyon_> ?src map
22:28:57 <lambdabot> map _ []     = []
22:28:57 <lambdabot> map f (x:xs) = f x : map f xs
22:29:34 <rubenz> well that could be difficult.
22:31:35 <rubenz> dons: I'm actually located in the cse labs at unsw.
22:34:22 <dons> rubenz: ah ok. we've got newer ghc's installed in /home/pls/bin
22:34:26 <dons> add that to your path
22:34:52 <dons> $ /home/pls/bin/ghc --version
22:34:52 <dons> The Glorious Glasgow Haskell Compilation System, version 6.4.2
22:34:52 <dons> $ /home/dons/bin/ghc --version
22:34:52 <dons> The Glorious Glasgow Haskell Compilation System, version 6.6
22:34:58 <dons> either of those two could go in your path
22:43:48 <rubenz> dons: Thanks I am using the one at /home/dons/bin/ghc. Works well. Thanks.
22:46:28 <rubenz> dons: If I just add /home/dons/bin/ghc to my path it still invokes ghc 6.4. Any idea how to get the system to run the other version?
22:47:11 <rubenz> I suppose I can just type in the full path though
22:47:28 <dons> export PATH=/home/dons/bin:$PATH ?
22:47:58 <kc5tja> @quote+ ddarius (Assembly language) is fairly nice, especially if you don't know about CPS and don't use languages with HOFs and tailcalls.
22:47:58 <lambdabot> No quotes for this person. Where did you learn to type?
22:48:12 <ddarius>  @remember
22:48:15 <kc5tja> ahh
22:48:19 <kc5tja> @remember ddarius (Assembly language) is fairly nice, especially if you don't know about CPS and don't use languages with HOFs and tailcalls.
22:48:19 <lambdabot> Done.
22:48:32 <kc5tja> Definitely worth recording for posterity.  :)
22:49:02 <ddarius> Most of the cool stuff you can do with asm can be done much easier and more powerfully with CPS
22:49:20 <kc5tja> But, not as quickly nor as compactly.
22:49:26 <kc5tja> Typical size/speed tradeoff.
22:49:54 <desp> http://icpc.baylor.edu/icpc/default.htm -- woot.
22:49:54 <lambdabot> Title: The ACM-ICPC International Collegiate Programming Contest Web Site sponsored by  ...
22:49:58 <ddarius> Well, a lot of it can't be done at all sanely in like C.
22:50:47 <rubenz> dons: yes I put it inside .bash_profile. But for some reason it doesn't seem to have any effect.
22:51:23 * ddarius liked messing with the return stack in assembly.
22:51:23 <kc5tja> ddarius: That's because the state transformations provided by asm instructions are precisely defined; C doesn't attempt to build on this, choosing instead to be convenient shorthand for common sequences of assembly instructions instead.
22:51:34 <rubenz> dons: I'll try .profile
22:51:46 <kc5tja> ddarius: In Forth, messing with the return stack is quite often performed too.
22:52:10 <rubenz> dons: still doesn't work
22:52:13 <ddarius> To make yield like constructs (for example) ?
22:52:51 <kc5tja> ddarius: Yes; also to emulate case constructs like this: : cases  doA orB orC orD drop abort" Unhandled case" ;
22:53:03 <kc5tja> where doA, orB, ... conditionally rdrop to early-exit from cases.
22:53:45 <kc5tja> And, of course, there is always the age-old trick of stuffing values ONTO the rstack too, for vectored returns.
22:54:48 <pstickne> that sounds messy :(
22:55:01 <kc5tja> pstickne: Only because you're not used to it.
22:55:28 * ddarius really enjoyed this http://webster.cs.ucr.edu/AoA/DOS/ch12/CH12-6.html#HEADING6-1 when he read it.
22:55:29 <lambdabot> Title: Art of Assembly Language: Chapter Twelve-6
22:55:31 <kc5tja> When coding in a concatenative language, being able to manipulate these constructs with stack manipulation words becomes second nature.
22:56:19 <ddarius> But nowadays call/cc is more powerful and straightforward.
22:56:42 <kc5tja> And 99% unnecessary.
22:57:37 <Procyon_> ?src zipWith
22:57:37 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
22:57:37 <lambdabot> zipWith _ _      _      = []
22:58:51 <ddarius> Necessity? Who cares about that?
23:00:38 <kc5tja> ddarius: Nearly anyone who uses a computer, who writes compilers, etc.
23:00:52 * kc5tja isn't sure if you're being serious or joking.
23:13:28 <dmwit> > 1.0e3
23:13:29 <lambdabot>  1000.0
23:13:41 <dmwit> :t (e)
23:13:44 <lambdabot> Not in scope: `e'
23:18:34 <QtPlatypus> dmwit: I think e's a part of the number itself.  Like the decemal point.
23:18:45 <dmwit> Yeah, I think you're right.
23:18:48 <dmwit> I was just curious.
23:19:55 <dmwit> After all, there has to be SOMETHING about Haskell that isn't consistent. ;-)
23:20:37 <desp> what's inconsistent about this?
23:21:05 <dmwit> Nothing, I'm just joking.
23:21:59 <desp> ah, pardon me
23:22:09 <nmessenger> > let e x y = x * 10 ** y in 1.0 `e` 3
23:22:10 <lambdabot>  1000.0
23:22:29 <desp> :D
23:22:37 <dmwit> Right, I was hoping something like that was happening behind the scenes. =)
23:25:26 <kc5tja> So, I have a Classic and Progressive Rock station on Pandora.com.  And, suddenly, it thinks I like classical music.  How it derives that I like Taichovsky from hard-core Genesis or Pink Floyd is beyond me.  :)
23:25:46 <jdrake> I am a little confused by this: (1, 3.0, "4") :: (Num a, Fractional b) => (a, b, [Char])
23:25:53 <kc5tja> Amazingly, it's correct -- I do like classical music.  But, just not intermixed with progressive rock.  :)
23:26:03 <dons> jdrake: so the first two numbers are polymorphic
23:26:10 <dons> until you use them somewhere, which will constrain the type
23:26:22 <dons> > (1, 3.0, "4") :: (Int,Double,String)
23:26:24 <lambdabot>  (1,3.0,"4")
23:26:29 <nmessenger> Tchaikovsky is head-bangin'!
23:26:30 * ddarius will play Pachelbel's Canon in Dm followed by System of a Down's Prison Song.
23:28:01 <kc5tja> ddarius: Hehe.  I like classical, but I'm not fluent in citing names of songs from various artists.  I don't listen to it nearly often enough to do so.
23:28:02 <jdrake> I am not sure I understand why it says (Num a, ...) then => (a, b, [Char])  because it seems like it is saying the type of "4" but not earlier.
23:28:48 <dmwit> jdrake: On the right hand side of the "=>", it tells you the actual type of the tuple.
23:28:49 <nmessenger> jdrake: it says the tuple has type (a, b, [Char]), except a and b have a couple constraints on them
23:28:59 <dmwit> jdrake: On the left hand side of the "=>", it puts restrictions on that type.
23:29:17 <dmwit> For example, (Num a) means the "a" type on the right has to be a numeric type.
23:29:19 <nmessenger> specifically 'a' is any Numeric type, and 'b' is any Fractional type
23:29:40 <nmessenger> @instances Num
23:29:41 <lambdabot> Double, Float, Int, Integer
23:29:41 <dmwit> Cue the stereo quote. ;-)
23:29:55 * nmessenger resists
23:30:26 <jdrake> So any constraints will be on the left of =>? (Do they happen to be typeclasses?)
23:30:33 <nmessenger> exactly
23:30:38 <dmead> oh man
23:30:38 <desp> exactly
23:30:51 <nmessenger> oh man!
23:30:52 <dmead> some guy from linspire is spammin' up the haskell-cafe
23:30:59 <dmead> "proposing" ideas
23:31:02 <dmead> "ideas"
23:31:13 <dmwit> jdrake: (To directly answer your question, there's no restrictions on the "4" part because it isn't polymorphic -- there's only one type possible.)
23:31:15 <mbishop> """
23:31:18 <dmead> so i replied that they need to get my yahoo account off their spam lists
23:31:22 <dmead> and my rate is $50/hour
23:32:22 <sjanssen> dmead: I don't think your response is reasonable
23:32:39 <dons> dmead: hmm?
23:32:58 <dons> dmead: are you referring to stepcut's proposal to work on a unified Mime lib?
23:33:03 <dmead> yes..
23:33:07 <dmead> sigh
23:33:14 <dmead> other people thought it was perfectly funnyt
23:33:15 <dons> i have no idea what you're talking about, dmead
23:33:29 <jdrake> ok, I am thinking well of this now. Almost bed time :p
23:34:02 <dmead> ummm
23:34:06 <dons> dmead: fwiw, stepcut isn't just some guy at linspire (and also, linspire is a key haskell dev group...):
23:34:10 <dons> $ grep stepcut *
23:34:33 <dmead> it seems quite underhanded to me, actually
23:35:17 <dons> @seen stepcut
23:35:17 <lambdabot> stepcut is in #haskell-blah and #haskell. I last heard stepcut speak 3h 18m 47s ago.
23:35:34 <dons> why don't you ask him about it yourself then? :-)
23:35:54 <dmead> i will, their spam is quite annoying
23:35:59 <dmead> and plentiful
23:36:23 <dons> there's really no reason to attack stepcut. that's completely misguided.
23:36:42 <dons> i'm not sure anyone really knows what you're talking about, in fact, dmead.
23:37:15 <sjanssen> dmead: I can't find any messages sent from Linspire that I would call spam
23:37:36 <dolio> ?pl foldr (zipWith (:)) (repeat [])
23:37:36 <lambdabot> foldr (zipWith (:)) (repeat [])
23:38:38 <dmwit> :t foldr (zipWith (:)) (repeat [])
23:38:40 <lambdabot> forall a. [[a]] -> [[a]]
23:39:08 <nmessenger> > foldr (zipWith (:)) (repeat []) [[1..10],[11..20],[21..30]]
23:39:10 <lambdabot>  [[1,11,21],[2,12,22],[3,13,23],[4,14,24],[5,15,25],[6,16,26],[7,17,27],[8,18...
23:39:20 <nmessenger> transpose?
23:39:28 <dons> oh hmm
23:39:44 <dons> ?check \xs -> tranpose xs == foldr (zipWith (:)) (repeat []) (xs :: [T])
23:39:45 <lambdabot>   Not in scope: `tranpose'
23:39:51 <dons> ?check \xs -> transpose xs == foldr (zipWith (:)) (repeat []) (xs :: [T])
23:39:52 <lambdabot>  Falsifiable, after 0 tests: [[-2,-2,-1],[-1],[0]]
23:40:12 <nmessenger> > foldr (zipWith (:)) (repeat []) [[-2,-2,-1],[-1],[0]]
23:40:14 <lambdabot>  [[-2,-1,0]]
23:40:27 <dons> ?check \xs -> not (null xs) && not (null (head xs)) && length (head xs) == length xs ==> transpose xs == foldr (zipWith (:)) (repeat []) (xs :: [T])
23:40:28 <dmead> well
23:40:28 <lambdabot>  Falsifiable, after 0 tests: [[0,2],[3]]
23:40:40 <dolio> Hmm, that may be want I want, anyway.
23:40:49 <dolio> All my lists are the same length.
23:41:06 <dmead> i find it objectionable that someone would propose an open project whos only use would be as a part of a product
23:41:20 <dmead> and just kind of assume people will help out with it
23:41:54 <sjanssen> I'm sure MIME is useful for all sorts of software
23:41:56 <dons> dmead: i think you're misunderstanding stepcut. he's contributed lots of *open* code to haskell (e..g bytestring parser..)
23:42:24 <dons> dmead: so i'm pretty sure you're wide of the mark here.
23:46:01 <dmead> ah perhaps
23:46:07 <dmead> that just smelled fishy to me
23:46:28 <dons> its not. its just another effort to unify existing libs, as we did for binary earlier in the year.
23:46:58 <dcoutts> dmead: lots of people have use for a MIME lib
23:47:11 <dcoutts> it's not just useful in his commercial code
23:47:18 <dcoutts> it's generally useful
23:47:23 <kowey> darcs send relies on composing MIME messages, fwiw
