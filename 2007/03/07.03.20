00:00:25 <dolio> It appears to do it no matter what -O I use.
00:00:31 <dolio> I tried -O0 and -O2.
00:01:07 <dons> sjanssen: yes. :-)
00:01:15 <dons> we could support borders i suppose ;-)
00:01:24 <dons> grumble ... bloat ... grumble
00:01:51 <sjanssen> no borders in full screen mode, though
00:02:05 <sjanssen> does dwm put borders on maximized windows?
00:05:06 <_dolio> Disregard my claims of a problem. It was a case of PEBCAK.
00:05:41 <dons> sjanssen: yeah
00:05:45 <fuzan> any way to get Data.Binary to encode in little-endian? :'(
00:05:46 <dons> one pixel around the screen
00:05:56 <dons> fuzan: yes, you use the little endian ops directly
00:06:00 <dons> or newtype your code to call them
00:06:16 <dons> remember, the Binary class is for serialisation. if you care about ordering, use the underying ops
00:06:18 <sjanssen> dons: we can one up dwm there :)
00:06:27 <dons> two up, counting Xinerama
00:06:39 * dons thinks C slows down their development
00:07:03 <dons> we already have more contributors than dwm ;-)
00:07:04 <dons> yay for haskell
00:07:24 <fuzan> dons: would I need to muck through the source to discover these "underlying operators" ?
00:08:00 <dons> fuzan, no. look at the Get and Put monads
00:08:09 <fuzan> i've been assuming that the protocol i'm writing some code for uses big-endian types. i was sadly mistaken.
00:08:46 <dons> we have all operations for big and little endian
00:09:02 <dons> e.g. getWord16le
00:09:14 <dons> so yes, read the docs for Data.Binary.Get and Data.Binary.Put
00:09:22 <dons> then implement your own le instances for your types.
00:16:05 <dons> hehe http://programming.reddit.com/info/1biex/comments
00:16:06 <lambdabot> Title: Rubyâ€™s Inferiority Complex - Why does criticism of Ruby bring out the worst in ...
00:17:53 <Adamant> criticism of any language will not endear you to it's partisans.
00:18:00 <dons> indeed.
00:21:42 <sjanssen> @tell jcreigh tiling support is in darcs.  Feel free to hack on any items in the TODO
00:21:42 <lambdabot> Consider it noted.
00:22:21 <dons> oooh...
00:22:26 <dons> sjanssen: anything I should look at?
00:23:25 <dons> ?time sjanssen
00:23:40 <sjanssen> Tue Mar 20 02:21:54 CDT 2007
00:23:45 <dons> :-)
00:24:07 <fuzan> oo, i just thought of a neat little problem. alike to many prelude numeric functions (a -> a -> a)m would it be possible to extend these functions in one line such that they have the type "[a] -> a" ?
00:24:27 <fuzan> something like a, "lcm [2,6,9]"
00:24:29 <dons> a -> a -> a, to [a] -> a ?
00:24:37 <dons> ah, fold :-)
00:24:45 <fuzan> yah, but i really am poor with folds.
00:24:47 <mauke> fuzan: fold[rl]1
00:24:48 <dons> :t odd
00:24:50 <lambdabot> forall a. (Integral a) => a -> Bool
00:24:52 <fuzan> trying now unsucessfully.
00:24:56 <dons> :t (+)
00:24:58 <lambdabot> forall a. (Num a) => a -> a -> a
00:25:01 <dons> :t foldl1 (+)
00:25:03 <lambdabot> forall a. (Num a) => [a] -> a
00:25:04 <dons> :-)
00:25:05 <mauke> @src maximum
00:25:05 <lambdabot> maximum [] = undefined
00:25:05 <lambdabot> maximum xs = foldl1 max xs
00:25:19 <dons> @src and
00:25:19 <lambdabot> and   =  foldr (&&) True
00:25:22 <dons> @src or
00:25:23 <lambdabot> or    =  foldr (||) False
00:25:26 <dons> @src aby
00:25:27 <lambdabot> Source not found. Wrong!  You cheating scum!
00:25:29 <dons> @src any
00:25:29 <lambdabot> any p =  or . map p
00:26:14 <fuzan> oh, wow.
00:26:22 <fuzan> those are nice functions :)
00:27:16 <dons> :t gcm
00:27:18 <lambdabot> Not in scope: `gcm'
00:27:20 <dons> :t gcd
00:27:23 <lambdabot> forall a. (Integral a) => a -> a -> a
00:27:24 <dons> :t lcm
00:27:26 <lambdabot> forall a. (Integral a) => a -> a -> a
00:27:34 <dons> :t foldr lcm 0
00:27:36 <lambdabot> forall a. (Integral a) => [a] -> a
00:27:47 <dons> :t foldl1 lcm [2,6,9]
00:27:49 <fuzan> @src foldl1
00:27:49 <lambdabot> foldl1 f (x:xs) = foldl f x xs
00:27:49 <lambdabot> foldl1 _ []     = undefined
00:27:50 <lambdabot> forall a. (Integral a) => a
00:27:51 <dons> > foldl1 lcm [2,6,9]
00:27:52 <lambdabot>  18
00:28:01 <dons> > foldr lcm 1 [2,6,9]
00:28:03 <lambdabot>  18
00:28:07 <dons> > foldr lcm 1 []
00:28:07 <sjanssen> dons: you can hack on any items in the TODO too :).  0.1 time is drawing nigh
00:28:08 <lambdabot>  1
00:28:20 <dons> sjanssen: woo!
00:28:28 * dons <3 code
00:28:38 <ClaudiusMaximus> :t (<3)
00:28:40 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
00:29:41 <dons> type error!
00:30:36 <dons> sjanssen: we could probably get the status bar done before 0.1
00:31:03 <mauke> *Main> dons <3 code
00:31:03 <mauke> True
00:31:46 <mauke> yay for monadic Num instances
00:31:48 * sjanssen points out that mauke probably wrote instance Num (a -> b) for that
00:32:09 <mauke> instance (Num a, Monad m, Eq (m a), Show (m a)) => Num (m a)
00:33:39 * sjanssen sleeps
00:35:00 <fuzan> dons: do methods exist for overriding the default put/get methods for a certain instance?
00:36:47 <fuzan> hmm, I think this makes my generated binary instances worthless :(
00:37:48 <fuzan> instance Binary C0x50 where put (C0x50 a b c) = putWord64le >> putWord32le >> putWord16le
00:37:52 <fuzan> am I on the right track?
00:37:58 <bringert> what's the status of configurations in Cabal?
00:38:10 <bringert> maybe finishing that could be an SoC project?
00:38:23 <bringert> dcoutts: you've been involved in that, right?
00:39:23 <fuzan> it would be easier if I could manage to have put only use the le derivatives, however, i'm clueless on how to do such :/
00:40:11 <dons> fuzan: methods exist in the sense of newtype T = T A
00:40:16 <dons> then you write instance Binary T where ...
00:42:02 <fuzan> dons: yah. i've got that much.
00:43:19 <fuzan> dons: i can serialize an object, however, endienness isn't always correct on largerthanbyte types.
00:44:01 <fuzan> i think i'm a little confused, probably doesn't help in explaining my other confusions.
00:46:28 <Cheery> confutse.
00:51:22 <dcoutts> bringert: that'd be a good project yes, we have a spec and we need someone to implement it
00:51:41 <dcoutts> bringert: another good Cabal project would be to do dependency analysis in Cabal properly
00:52:07 <dcoutts> so we can do pre-processors properly and not have to rely on ghc --make etc
00:52:19 <dcoutts> and so we can do parallel builds :-)
00:55:18 <hpaste>  fuzan pasted "binary" at http://hpaste.org/1046
00:57:28 <fuzan> here's some code that's liable for the ugliest haskell awards. i can use the lowerlevel putWord32le easily, however, as I was saying earlier, is there a way to have put always use the le methods?
00:58:58 <Heffalump> a general solution would be to make a BinaryLE class
00:59:03 <Heffalump> then make newtype LE a = LE a
00:59:18 <Heffalump> and instance BinaryLE a => Binary (LE a) where put = putLE ; get = getLE
00:59:26 <fuzan> I think that's what dons was getting at and what I wasn't getting.
00:59:30 <Heffalump> yeah
00:59:46 <Heffalump> his solution was specific to one type whereas mine is more complicated and more generic
01:00:06 * Heffalump has to disappear for a bit but I'm sure someone else can explain if you don't follow
01:00:34 <Heffalump> mine would still need you to wrap your values in the LE constructor to write them out
01:01:44 <fuzan> thanks!
01:02:19 <kzm> Quick debian question: do I need the postinst script for a package providing a binary?  It seems to only register the package with ghc-pkg or similar.
01:02:37 <kzm> I.e. geared at libraries.  (I'm using Pupeno's example as a guideline)
01:03:14 <fuzan> how does Binary actually work? on put (Word32) does it do put putWord8 4 times, or does it do a putWord32be ?
01:03:28 <fuzan> @src putWord8
01:03:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:04:01 <bringert> dcoutts: care to add soc tickets for those?
01:06:38 <dcoutts> bringert: erm, I'd rather go have dinner :-) Right, I'll try and get round to that
01:07:33 <dcoutts> bringert: you might be interested to know that I'm currently quickchecking the strictness properties of the H98 List spec against our new Data.List implementation
01:08:27 <dcoutts> I get nice failures showing the partial lists that caused the discrepancy
01:08:43 <dcoutts> I added a newtype Partial a = Partial a
01:08:55 <dcoutts> with Arbitrary instances to insert _|_'s
01:09:36 <dcoutts> and a new EqBottom type class with operations === and <== to test for equality but taking _|_'s into account
01:10:04 <dcoutts> === requires the _|_'s to be identical, <== allows the right to refine the left when it comes to _|_'s
01:10:24 <dcoutts> the point is that in many cases our implementations refine the H98 spec
01:10:44 <dcoutts> and now we can make that precise
01:10:51 <dcoutts> which is nice :-)
01:11:44 <siti> sweet I actually get faster performance with -fasm :)
01:19:34 <ClaudiusMaximus> > (\ a b -> (and . zipWith (\a b -> a b) a b) && length a == length b) [id, not, id, not] [ True, False, True, False ]
01:19:35 <lambdabot>  Couldn't match expected type `a -> [Bool]'
01:20:10 <ClaudiusMaximus> > (\ a b -> (and ( zipWith (\a b -> a b) a b) ) && length a == length b) [id, not, id, not] [ True, False, True, False ]
01:20:12 <lambdabot>  True
01:20:20 <ClaudiusMaximus> > (\ a b -> (and ( zipWith (\a b -> a b) a b) ) && length a == length b) [id, not, id, not] [ True, False, True ]
01:20:21 <lambdabot>  False
01:20:46 <ClaudiusMaximus> @pl (\a b -> a b)
01:20:46 <lambdabot> id
01:21:39 <ClaudiusMaximus> @pl zipWith id
01:21:39 <lambdabot> zipWith id
01:22:09 <dolio> \a b -> a b is more commonly referred to as ($).
01:22:16 <dolio> But ($) is just identity on functions.
01:22:43 <bringert> dcoutts: interesting
01:23:47 <ClaudiusMaximus> dolio: it probably gives more informative error messages than 'id', though
01:25:14 <dolio> Quite possibly.
01:27:19 <Cale> also it "means" function application
01:27:46 <Cale> Which makes code easier to read when it's being used that way.
01:28:41 <dolio> Yeah, "zipWith id a b" wouldn't immediately pop out as "apply functions from a to values in b."
01:28:51 <dolio> To me, that is.
01:30:23 <nornagon> hm, makes sense after a little thought, but it wouldn't spring to mind
01:31:04 <nornagon> :t zipWith id
01:31:06 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
01:31:15 <nornagon> :t zipWith ($)
01:31:18 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
01:31:23 <nornagon> heh
01:31:57 <nornagon> @quote raytracer
01:31:57 <lambdabot> No quotes match. I've seen penguins that can type better than that.
01:32:03 <nornagon> hmph.
01:32:09 <nornagon> @quote oleg
01:32:09 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
01:32:14 <nornagon> @quote oleg
01:32:14 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
01:40:15 <vincenz> moin
01:40:19 <vincenz> @seen zarvok
01:40:19 <lambdabot> I saw zarvok leaving #oasis and #haskell 1d 3h 46m 21s ago, and .
01:43:47 <vincenz> Cale: is it me or can GADTS be replicated through typeclasess?
01:44:25 <Cale> Yes, sort of. This has been discussed at length on the mailing lists, iirc.
01:44:53 <Cale> Typeclasses have the additional property that they're open.
01:45:14 <Cale> You also certainly need some GHC extensions, but I'm not sure what the minimal set is.
01:45:37 <vincenz> well  yeah
01:45:43 <vincenz> for allowing you to define all instances of one function in one function
01:45:53 <vincenz> foo t = case t of -- multtyped
01:46:05 <vincenz>   Foo varType1_ ->...
01:46:10 <vincenz>    Foo varType2_ -> ...
01:46:13 <vincenz> s/Foo/Bar
01:46:16 <vincenz> for the second
01:48:11 <Cale> The translation can probably get cumbersome if the case analysis is complicated.
01:50:13 <vincenz> Is there any reason not to use gadts except for their poor collaboration with records?
01:50:50 <kzm> @seen igloo
01:50:51 <lambdabot> igloo is in #gentoo-haskell, #haskell.hac07, #ghc, #darcs and #haskell. I last heard igloo speak 8h 24m 48s ago.
01:50:55 <Cale> Well, I haven't run into too many applications for them, myself.
01:51:26 <Cale> Basically, they give you the ability to hijack Haskell's type system for your own purposes, which is pretty cool.
01:51:41 * vincenz tends to use them along with bringert' Compos system (but then extended for phantom typeS)
01:51:51 <vincenz> For ASTS (damn, lag)
01:52:42 <Cale> The GADT-style syntax is certainly cooler though.
01:53:08 <vincenz> well with GADTS
01:53:15 * vincenz meant GADTs
01:53:58 <nornagon> it's a vincenz
01:54:05 <vincenz> data AST :: * -> * -> ** where
01:54:17 <vincenz>   EVar :: String -> AST Exp_ tag
01:54:18 <vincenz>  ...
01:54:27 <vincenz>    Tag :: tag -> AST a tag -> AST a tag
01:54:34 <vincenz> and I get polytyped tags :)
01:54:47 <vincenz> (with tag being phantom for everything besides the Tag const)
01:57:20 <vincenz> `ap` meeting
01:57:25 <ClaudiusMaximus> @type (>>=)
01:57:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:02:51 <ClaudiusMaximus> is dispatching methods like this obviously wrong in some deep way?  data DispatchFoo = Map (String) [([Atom]->Bool, [Atom]->IO ())] -- maps methodName's to [ (canAcceptArguments, methodToCall) ]  (context: doDispatchFoo :: String -> [Atom] -> IO ()  would be called from an app written in C)
02:03:52 <dons> lists of functions are a bit unusual
02:06:48 <matthew-_> [[1..] ++ [1..]] -- isn't that a list of functions? ;-)
02:07:00 <dons> :t [[1..] ++ [1..]]
02:07:02 <lambdabot> forall t. (Num t, Enum t) => [[t]]
02:07:03 <dons> its all functoins I suppose
02:07:17 <ClaudiusMaximus> well, i'm dealing with a braindead app, trying to write a Haskell wrapper around its C plugin API
02:07:25 <dons> ClaudiusMaximus: using a String lookup table to find functions is fine
02:07:28 <matthew-_> dons, t'was my point...
02:07:34 <dons> I'd use a (F1,F2) in the Map though
02:07:40 <dons> rather than a list of length 2.
02:07:43 <dons> matthew-_: I know :-)
02:08:13 <ClaudiusMaximus> dons: it's [(F1,F2)]
02:08:19 <mux> dcoutts_: you around?
02:08:30 <dons> ClaudiusMaximus: hmm? so you map a symbol name to a list of functions?
02:09:28 <dons> data F = F Int {- arity -} ([Atom] -> IO ()) -- might be a nicer type
02:09:32 <dons> then Map String F --?
02:09:43 <dons> "I've printed out the Yet Another Haskell Tutorial, this is a fantasty haskell tutorial, but it's a
02:09:46 <dons> pitty that there's no printed version can be bought"
02:09:57 <dons> maybe haskell.org should sell dead trees in return for bandwidth?
02:10:25 <ClaudiusMaximus> dons: so i can do type checking / argument-counting / etc separately from the 'real' method function, and provide prebuilt functions to do that for the most common cases
02:10:44 <dolio> Hmm, John Backus died.
02:10:44 <dons> ClaudiusMaximus: ah, ok I see.
02:11:00 <dons> so you lookup the table of relevant functions, then dispatch to a particular one based on type or arity?
02:11:15 <ClaudiusMaximus> dons: yes
02:11:43 <ClaudiusMaximus> dons: data Atom = AFloat CFloat | ASymbol (Ptr ()) | ...
02:12:08 <dons> ok. i'd probably try to put a bit more type info about the arity and so on, but otherwise, yes. seems a reasonable structure
02:12:18 <dons> type SymbolTable = Map String ....
02:19:38 <ClaudiusMaximus> @type error
02:19:40 <lambdabot> forall a. [Char] -> a
02:24:41 <pejo> dons, is Haskell.org short on bandwidth?
02:28:38 <kzm> I did the usual ./Setup.hs configure and build, but then 'sudo ./Setup.hs install' fails with 'Setup.hs: error reading ./.setup-config; run "setup configure" command?'  Known issue?
02:28:53 <kzm> (This is the FPS library and GHC 6.4.2)
02:29:25 <asdasd> hello
02:31:19 <siti> hi
02:31:32 <Vq^> hiya
02:36:17 <asdasd> why block of code sometimes has the > sign in front of it? I've noticed this in blogs but also in some source files
02:36:37 <kzm> It's literate code.
02:36:45 <tibbe> asdasd: that's something called literal haskell files, usually ends with a .lhs extension
02:37:02 <kzm> Just remove the '>'s.
02:37:08 <tibbe> it's an alternative way to write code, all lines not starting with an > will be considered a comment
02:37:36 <tibbe> the code thing is that you can just cut n paste the whole blog entry into an editor, save as a .lhs file and run the thing
02:37:56 <asdasd> oh I see
02:37:58 <asdasd> very smart
02:38:23 <asdasd> I loved Haskell Weekly News that was published last Monday and was eager to read the new one this monday but I didn't see it published in the Haskell Sequence. Do you know what's the story there. I think dons take care of that.
02:39:57 <asdasd> do you know if the HWN will be published this week?
02:40:43 <araujo> it probably will
02:40:52 <asdasd> @seen dons
02:40:53 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 28m 34s ago.
02:41:04 <kzm> Should I file a bug against FPS, against Cabal, against GHC, or is it just expected behavior?
02:42:20 <int-e> kzm: hmm, is root's PATH different from yours so it tries using a different ghc?
02:42:42 <kzm> int-e, good point.
02:44:20 <kzm> Yep. That was it, it seems.  Thanks!
02:44:31 <kzm> (Strange error message, though)
02:44:43 <asdasd> @message dons
02:44:44 <lambdabot> Maybe you meant: messages messages?
02:44:46 <int-e> the file name changed between ghc versions
02:45:27 <asdasd> @message dons Hi dons, are you going to publish the Haskell Weekly Newsletter this week? I'm very interested in reading it. thank you.
02:45:27 <lambdabot> Maybe you meant: messages messages?
02:45:31 <int-e> (well, technically between different Cabal versions - I don't know when exactly)
02:46:22 <quicksilver> asdasd: dons is pretty busy, and therefore sometimes the HWN isn't quite weekly, I believe
02:46:22 <kzm> asdasd it's 'tell'
02:46:47 <quicksilver> on the other hand, I'm sure he'd be pleased to hear that you enjoy reading it :)
02:46:51 <asdasd> quicksilver: I see :/
02:46:57 <asdasd> it's so cool
02:47:06 <asdasd> because it has all the links to the latest article
02:47:11 <asdasd> and I start reading it on Monday night
02:47:19 <asdasd> and by Friday I'm done with it
02:47:25 <asdasd> and I've learn tons of stuff last week
02:47:34 <quicksilver> :)
02:47:40 <dmead> ?src liftM2
02:47:40 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:48:02 <asdasd> well, thank you guys
02:48:13 <quicksilver> @pl liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:48:14 <lambdabot> (line 1, column 21):
02:48:14 <lambdabot> unexpected "{"
02:48:14 <lambdabot> expecting variable, "(", operator or end of input
02:48:22 <quicksilver> @. pl undo liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:48:22 <lambdabot> (line 1, column 21):
02:48:23 <lambdabot> unexpected "{"
02:48:23 <lambdabot> expecting variable, "(", operator or ")"
02:48:26 <quicksilver> bleh
02:49:02 <dmead> :o
02:49:25 <dmead> > liftM2 (,) [1..10] [1..10]
02:49:26 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(2...
02:49:35 <dmead> > liftM2 (,) [1..10] [1..5]
02:49:36 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
02:49:43 <dmead> > liftM2 (^) [1..10] [1..5]
02:49:44 <lambdabot>  [1,1,1,1,1,2,4,8,16,32,3,9,27,81,243,4,16,64,256,1024,5,25,125,625,3125,6,36...
02:49:47 <dmead> hehe
02:50:28 <dmead> > liftM2 (^) [2 [1..10]
02:50:28 <lambdabot>  Parse error
02:50:32 <dmead> > liftM2 (^) [2] [1..10]
02:50:33 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
02:50:37 <dmead> > liftM2 (^) [2] [1..20]
02:50:38 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
02:50:59 <dmead> > map (-1 *) (liftM2 (^) [2] [1..20])
02:51:00 <lambdabot>      The operator `*' [infixl 7] of a section
02:51:00 <lambdabot>         must have lower precede...
02:51:05 <dmead> bah
02:51:19 <dmead> > liftM2 (-1 ) (liftM2 (^) [2] [1..20])
02:51:20 <lambdabot>   add an instance declaration for (Num (a1 -> a2 -> r))
02:51:26 <ClaudiusMaximus> > liftM2 (^) (Just 23) (Just 3)
02:51:27 <lambdabot>  Just 12167
02:51:31 <dmead> > liftM2 (-1 *) (liftM2 (^) [2] [1..20])
02:51:32 <lambdabot>      The operator `*' [infixl 7] of a section
02:51:32 <lambdabot>         must have lower precede...
02:51:33 <quicksilver> > map ((-1) *) (liftM2 (^) [2] [1..20])
02:51:34 <lambdabot>  [-2,-4,-8,-16,-32,-64,-128,-256,-512,-1024,-2048,-4096,-8192,-16384,-32768,-...
02:51:36 <dmead> ah
02:51:42 <dmead> > liftM2 ((-1) *) (liftM2 (^) [2] [1..20])
02:51:42 <quicksilver> dmead: - is ambiguous
02:51:43 <lambdabot>   add an instance declaration for (Num (a2 -> r))
02:51:43 <lambdabot>     In the expression: 2
02:51:47 <dmead> right
02:51:48 <vincenz> - is a bit of an annoying one
02:51:49 <quicksilver> dmead: and annoying :)
02:51:52 <dmead> yes
02:52:03 <vincenz> just 1 bit, mind you, not two bits
02:52:19 * mux notes lists comprehensions are more readable :)
02:52:37 <mux> > [ -2^x | x <- [1..20] ]
02:52:38 <lambdabot>  [-2,-4,-8,-16,-32,-64,-128,-256,-512,-1024,-2048,-4096,-8192,-16384,-32768,-...
02:52:55 <quicksilver> heh
02:53:00 <quicksilver> lambdabot too smart:
02:53:03 <quicksilver> @pl liftM2 f m1 f2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
02:53:03 <lambdabot> liftM2 = (const .) . (=<<) . (((m2 >>=) . (return .)) .)
02:53:09 <quicksilver> @pl liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
02:53:09 <lambdabot> liftM2 = liftM2
02:54:20 <ClaudiusMaximus> > liftM2 (^) (Just 23) [1,2,3]
02:54:21 <lambdabot>  Couldn't match expected type `Maybe a2' against inferred type `[a]'
02:55:24 <quicksilver> dmead: btw, liftM2 (^) [2] [1..10] is also just liftM (^2) [1..10]
02:55:41 <quicksilver> (which is just map, since liftM is map in the list monad)
02:55:48 <dmead> hehe
02:55:49 <dmead> yes
02:55:55 <vincenz> Anyone here worked with google projects?
02:55:57 <dmead> i'm just sleep deprived
02:56:09 <dmead> and trying to finish this writeup on my prover
02:56:13 <tibbe> vincenz: yes kinda ;)
02:56:14 <vincenz> dmead: prover of?
02:56:18 <dmead> logic
02:56:18 <vincenz> tibbe: can it be pw-protected?
02:56:23 <quicksilver> > liftM2 (^) [2,3] [1..5]
02:56:24 <tibbe> vincenz: but I guess you meant soc projects
02:56:25 <lambdabot>  [2,4,8,16,32,3,9,27,81,243]
02:56:30 <vincenz> dmead: could you mean more specific?
02:56:31 <vincenz> tibbe: no
02:56:37 * vincenz has no time for soc projects
02:56:38 <quicksilver> dmead: that's more representative of liftM2
02:56:43 <tibbe> vincenz: oh, then I missunderstood you
02:56:50 <dmead> oh, i've been working on a first order logic prover
02:56:58 <dmead> and i got a report on it due today ;o
02:57:00 <vincenz> tibbe: I meant the google projects, aka replacement for sourceforge
02:57:00 <tibbe> vincenz: that's what I get for not reading everything you wrote
02:57:13 <tibbe> vincenz: I see, no I haven't, sorry
02:57:57 <vincenz> moin bringert
02:58:03 <bringert> hi
02:58:44 <tibbe> morn
03:02:57 <diffbavis> > let swap = snd &&& fst; second' = swap >>> first in (second (+1)) (1,1)
03:02:58 <lambdabot>   add an instance declaration for (Arrow (,))
03:03:59 <nornagon> :t first
03:04:02 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
03:04:50 <nornagon> :t second
03:04:53 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
03:05:46 <quicksilver> :t snd &&& fst
03:05:48 <lambdabot> forall a b. (a, b) -> (b, a)
03:06:13 <quicksilver> diffbavis: why are you defining second' and not using it? :)
03:06:27 <diffbavis> quicksilver: typo :)
03:06:51 <nornagon> :t (snd &&& fst) >>> first
03:06:54 <lambdabot>     No instance for (Arrow (,))
03:06:54 <lambdabot>       arising from use of `first' at <interactive>:1:18-22
03:07:58 <quicksilver> :t (>>>)
03:08:00 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
03:08:26 <quicksilver> :t (snd &&& fst) >>> fst
03:08:28 <lambdabot> forall a b. (a, b) -> b
03:08:43 <quicksilver> that's a long way to write snd :)
03:08:50 <nornagon> :p
03:09:23 <int-e> @type Control.Arrow.pure (snd &&& fst)
03:09:25 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) (b, a)
03:10:09 <quicksilver> let swap = snd &&& fst; second' = (pure swap) >>> first in (second' (+1)) (1,1)
03:10:16 <quicksilver> > let swap = snd &&& fst; second' = (pure swap) >>> first in (second' (+1)) (1,1)
03:10:34 <mux> when is Duncan when I need him! :-)
03:10:40 <mux> anyone familiar with gtk2hs here?
03:10:40 * quicksilver looks expectantly at lambdabot
03:10:44 <quicksilver> > "hello?"
03:10:45 <lambdabot>  "hello?"
03:10:59 <quicksilver> > let swap = snd &&& fst; second' = (Control.Arrow.pure swap) >>> first in (second' (+1)) (1,1)
03:11:00 <lambdabot>      The section `(+ 1)' takes one argument,
03:11:00 <lambdabot>     but its type `(a, b)' has none
03:11:14 <quicksilver> that's a fun error :)
03:11:37 <int-e> > let swap = snd &&& fst; second' = (Control.Arrow.pure swap >>>) . first in (second' (+1)) (1,1)
03:11:39 <lambdabot>  (2,1)
03:11:51 <diffbavis> Ahh
03:12:04 <int-e> > let swap = snd &&& fst; second' = (Control.Arrow.pure swap >>>) . first in (second' (+1) >>> second' (+2)) (1,1)
03:12:06 <lambdabot>  (3,2)
03:13:21 <quicksilver> mux: there he is :)
03:13:28 <mux> yeeha!
03:13:31 <mux> dcoutts: ping :-)
03:14:43 <dcoutts> mux: something good? :-)
03:18:17 <mux> dcoutts: did you see my messages from yesterday? I'm afraid this isn't good news =)
03:18:29 <mux> it seems we're missing bindings somehow in gtk2hs
03:18:36 <dcoutts> oh aye
03:18:49 <dcoutts> colour dialog right?
03:18:54 <mux> yep
03:19:10 <mux> we can't get to the ColorSelection object from the ColorSelectionDialog one
03:19:13 <dcoutts> mux: think it's simple to fix? want to send us some patches ?
03:19:21 <mux> I don't know how to deal with c2hs
03:19:26 <dcoutts> you can add things like that to one of the .hsc files
03:19:42 <mux> I know how it's done in C though; they just have a "colorsel" field in the struct and consumers are supposed to read that
03:19:47 <dcoutts> c2hs isn't so good for extracting fields from C structs
03:20:08 <dcoutts> right, see General/Structs.hsc where we stick this kind of thing
03:20:22 <mux> if you can give me an example of some file where we give access to fields for other objects, I can probably infer the patch from that
03:21:50 <mux> is there a darcs repo for gtk2hs?
03:22:18 <dcoutts> mux: yep darcs get --partial http://darcs.haskell.org/gtk2hs/
03:22:20 <lambdabot> Title: Index of /gtk2hs
03:22:23 <mux> thanks
03:23:16 <dcoutts> mux: look at dialogGetActionArea for example in General/Structs.hsc
03:23:47 <mux> great, that sounds exactly like what I'm supposed to do
03:24:12 <LPhas> hi dcoutts
03:24:17 <dcoutts> @arr
03:24:18 <lambdabot> Yo ho ho, and a bottle of rum!
03:24:32 <LPhas> @arr
03:24:32 <lambdabot> Shiver me timbers!
03:25:26 <mux> dcoutts: so, I'd have something of the form #{peek GtkColorSelectionDialog, colorsel} with all the plumbing around it?
03:25:27 <vincenz> how do you mount a filesystem over ssh?
03:25:38 <dcoutts> mux: right
03:25:55 <mux> vincenz: you usually don't, it's most of the time done through userland with gnome-vfs for instance
03:26:03 <mux> but maybe your kernel has a sshfs somehow
03:26:05 <ClaudiusMaximus> vincenz: sudo modprobe fuse; sshfs user@host:/remotedir /localdir
03:26:08 <mux> and there's also fuse
03:26:11 <mux> heh.
03:26:36 <vincenz> time to update my apply-darcs script
03:26:40 <vincenz> ClaudiusMaximus: thx
03:30:04 <thartman> > sort . map . ["0","100","99"]
03:30:05 <lambdabot>  Couldn't match expected type `a -> a1 -> b'
03:30:26 <thartman> > sort . ["0","100","99"]
03:30:27 <lambdabot>  Couldn't match expected type `a -> [a1]'
03:30:34 <thartman> > sort ["0","100","99"]
03:30:35 <lambdabot>  ["0","100","99"]
03:30:43 <LPhas> mmh
03:30:54 <LPhas> "100" > "99"
03:31:00 <LPhas> > "100" > "99"
03:31:02 <lambdabot>  False
03:31:04 <mux> dcoutts: are the unObject functions generated automatically?
03:31:13 <dcoutts> mux: yup
03:31:17 <thartman> > sort map (\x -> show x :: Integer ) ["0","100","99"]
03:31:18 <lambdabot>  Couldn't match expected type `[a]'
03:31:31 <siti> is there anyway to convert between bytestrings?
03:31:42 <mux> ok let's see if that builds
03:31:45 <dons> re.
03:32:01 <thartman> (\x -> show x :: Integer ) "100"
03:32:15 <LPhas> > sort $ map (show :: String -> Integer) ["0","100","99"]
03:32:15 <lambdabot>  Couldn't match expected type `Integer'
03:32:38 <LPhas> > sort $ map (show :: String -> Int) ["0","100","99"]
03:32:39 <lambdabot>  Couldn't match expected type `Int' against inferred type `String'
03:33:03 <LPhas> > sort $ map (read :: String -> Int) ["0","100","99"]
03:33:04 <lambdabot>  [0,99,100]
03:33:12 <thartman> danke :)
03:33:13 <nornagon> > sort $ map show ["0", "100", "99"] :: [Integer]
03:33:14 <lambdabot>  Couldn't match expected type `Integer'
03:33:17 <nornagon> aw.
03:33:27 <nornagon> oh
03:33:28 <nornagon> doh :)
03:33:31 <LPhas> > :t show
03:33:31 <lambdabot>  Parse error
03:33:32 <opqdonut> yeah :)
03:33:37 <LPhas> mmh
03:33:47 <opqdonut>  > sort $ map show [0, 100, 99] :: [Integer]
03:33:58 <opqdonut> > sort $ map show [0, 100, 99] :: [Integer]
03:33:59 <lambdabot>  Couldn't match expected type `Integer'
03:34:00 <opqdonut> bah
03:34:12 <opqdonut> > sort $ map show ([0, 100, 99] :: [Integer])
03:34:13 <nornagon> > sort $ map show [0,100,99] :: [String]
03:34:13 <lambdabot>  ["0","100","99"]
03:34:14 <lambdabot>  ["0","100","99"]
03:34:17 <nornagon> :-O
03:34:19 <opqdonut> ::whistle
03:34:22 <LPhas> > sort $ map read ["0","100","99"] :: [Integer]
03:34:23 <lambdabot>  [0,99,100]
03:35:59 <dcoutts> mux: hmm, I can't pm you
03:36:08 <mux> you can't? weird
03:36:09 <dcoutts> mux: -> #haskell-overflow
03:36:12 <mux> ok
03:36:17 <dcoutts> mux: this nick isn't registered
03:36:24 <mux> ok
03:36:33 <dcoutts> hence you can pm me but I'm not allowed to pm you
03:37:00 <vincenz> those fascists
03:37:18 <quicksilver> mux can turn that off
03:37:34 <quicksilver> you can permit pms explicitly from unregged users, I did
03:38:11 <LPhas> > (sort (["0","100","99"] >>= return . read )) :: [Int]
03:38:12 <lambdabot>  [0,99,100]
03:38:46 <quicksilver> >>= return .  is a funny way to write map though :)
03:39:24 <nornagon> flip map, even.
03:39:38 <nominolo> :t snd &&& fst
03:39:40 <lambdabot> forall a b. (a, b) -> (b, a)
03:40:05 <nominolo> :t uncurry (flip (,))
03:40:07 <lambdabot> forall b a. (a, b) -> (b, a)
03:40:18 <nornagon> :t flip (,)
03:40:20 <lambdabot> forall a b. b -> a -> (a, b)
03:40:24 <nominolo> when will arrows be in the prelude :/
03:40:34 <nornagon> never, probably.
03:40:45 <nornagon> the prelude is supposed to be small
03:40:51 <kaol> :t curry $ snd &&& fst
03:40:53 <lambdabot> forall a b. a -> b -> (b, a)
03:40:55 <nominolo> or at least swap :)
03:41:10 <quicksilver> well swap should be in Data.Tuple
03:41:14 <quicksilver> but not the prelude, IMO
03:41:24 <nornagon> yep
03:41:29 <nornagon> sounds like a better idea to me
03:41:39 <nominolo> i think it's quite a useful combinator for making things pointfree
03:41:53 <nornagon> so just import Data.Tuple, then.
03:42:06 <quicksilver> also class Tuple t where rollR :: t -> t; rollL :: t->t
03:42:16 <quicksilver> then swap is actually just rollR (or rollL) for the 2-tuple instance
03:42:30 <nominolo> but it ain't there ..
03:42:35 <quicksilver> indeed it aint
03:42:44 <quicksilver> but since Data.Tuple is a library, anyone can suggest it :)
03:45:12 <nominolo> are there any propososals to get rid of stupid things like Foo<n> classes, where <n> is some integer?
03:45:37 <nominolo> i mean without resorting to full dependent types
03:46:34 <opqdonut> yeah, not having generic tuple stuff can be really irritating
03:48:44 <quicksilver> nominolo: I believe they can be got rid of, yes
03:48:55 <quicksilver> nominolo: at least, in many/most cases
03:49:00 <quicksilver> nominolo: it's not always pretty, though
03:49:13 <nominolo> use of Template Haskell?
03:49:14 <quicksilver> (remember that type classes *are* dependent types)
03:49:21 <quicksilver> no, without TH
03:49:26 <quicksilver> although sometimes TH might be preferable
03:49:47 <nominolo> oh, you mean church-numerals in types?
03:49:57 <quicksilver> not necessarily
03:50:00 <quicksilver> although you can :)
03:50:10 <nominolo> i leave that to oleg
03:50:12 <quicksilver> there are a whole load of different pattersn, depending on the problem
03:50:24 <nominolo> any pointers?
03:50:29 <quicksilver> yes, oleg's website :P
03:50:51 <nominolo> oh
03:50:55 <nominolo> sure
03:51:06 <opqdonut>  /act
03:51:10 <opqdonut> sry
03:52:24 <quicksilver> although actually most of it is much less verbose, and cleverer, than church numerals
03:52:34 <quicksilver> that kind of heavy-handd stuff is only needed in the worst cases
03:56:19 <nominolo> well, i missed a bit explanatory stuff when i was digging in the HList code
03:56:21 <thartman> how do I check if a string would conform to type Integer, when showed?
03:56:40 <thartman> > isNumeric "5"
03:56:41 <lambdabot>   Not in scope: `isNumeric'
03:56:51 <nominolo> :t read
03:56:54 <lambdabot> forall a. (Read a) => String -> a
03:57:03 <nominolo> > read "bla"
03:57:05 <lambdabot>  Exception: Prelude.read: no parse
03:57:07 <thartman> I meant read, above.
03:57:17 <thartman> no wait, maybe I did mean show.
03:57:27 <quicksilver> I think you meant 'readed' :)
03:57:41 <quicksilver> nominolo: HList is kind-of worst case
03:57:48 <quicksilver> nominolo: for simpler cases you dont' need that machinery
03:57:50 <ClaudiusMaximus> @type reads
03:57:52 <lambdabot> forall a. (Read a) => String -> [(a, String)]
03:58:01 <quicksilver> nominolo: don't need quite so much, at least
03:58:29 <quicksilver> > reads "55" :: [(Int,String)]
03:58:30 <lambdabot>  [(55,"")]
03:58:38 <quicksilver> > reads "55 66" :: [(Int,String)]
03:58:40 <lambdabot>  [(55," 66")]
03:59:19 <thartman> > filter someIsNumericFunc ["a","1","2"]
03:59:20 <lambdabot>   Not in scope: `someIsNumericFunc'
03:59:46 <thartman> reads "a" :: Int
03:59:53 <thartman> > reads "a" :: Int
03:59:54 <lambdabot>  Couldn't match expected type `Int'
04:00:03 <nornagon> > filter (catch false (read :: Int)) ["a","1","2"]
04:00:03 <lambdabot>   Not in scope: `false'
04:00:12 <nornagon> > filter (catch False (read :: Int)) ["a","1","2"]
04:00:13 <lambdabot>  Couldn't match expected type `IO a' against inferred type `Bool'
04:00:16 <quicksilver> thartman: in general, you really want a proper parser (which is not hard to write)
04:00:21 <nornagon> oh well.
04:00:31 <quicksilver> thartman: but for this specific case
04:00:34 <quicksilver> :t all.isDigit
04:00:36 <lambdabot>     Couldn't match expected type `a -> Bool'
04:00:36 <lambdabot>            against inferred type `Bool'
04:00:43 <quicksilver> :t all
04:00:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
04:00:54 <quicksilver> :t all isDigit
04:00:57 <lambdabot> [Char] -> Bool
04:01:08 <thartman> aha.
04:01:12 <quicksilver> :t filter (all isDigit) ["a","1","2"]
04:01:14 <lambdabot> [[Char]]
04:01:21 <quicksilver> > filter (all isDigit) ["a","1","2","55","a2"]
04:01:22 <lambdabot>  ["1","2","55"]
04:01:29 <thartman> thassit :)
04:02:46 <thartman> ?src isDigit
04:02:46 <lambdabot> Source not found. My pet ferret can type better than you!
04:02:49 <ClaudiusMaximus> > (read "2184763856123857162352359235") :: Int
04:02:51 <lambdabot>  -1708755133
04:02:56 <thartman> ?info isDigit
04:02:56 <lambdabot> isDigit
04:03:07 <quicksilver> it's in Data.Char
04:03:18 <thartman> thx
04:03:19 <quicksilver> it might as well be isDigit c = c `elem` "0123456789"
04:03:28 <quicksilver> dunno if that's actually how they implement it
04:03:50 <ClaudiusMaximus> @hoogle hex
04:03:51 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
04:03:51 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
04:03:51 <lambdabot> Numeric.readHex :: Integral a => ReadS a
04:04:02 <quicksilver> > filter (all (`elem` "1234567890")) ["a","1","2","55","a2"]
04:04:03 <lambdabot>  ["1","2","55"]
04:04:58 <TSC> From Hugs.Prelude: isDigit c = c >= '0' && c <= '9'
04:05:20 <nominolo> quicksilver: ok, i'll take a look.  maybe i even try to write it up in layman-terms (more likely not, but often it would help understanding)
04:05:44 * quicksilver nods
04:05:51 <quicksilver> that would be faster, certainly
04:06:06 <quicksilver> unless your compiler has a good way of optimising `elem` string constants
04:06:28 <quicksilver> Data.Set.member (Data.Set.fromList "1234567890") might be even faster, though
04:06:35 <quicksilver> or it might not :) who knows....
04:06:51 <ClaudiusMaximus> @hoogle TypeRep -> TypeRep -> TypeRep
04:06:51 <lambdabot> Data.Typeable.mkAppTy :: TypeRep -> TypeRep -> TypeRep
04:06:51 <lambdabot> Data.Typeable.mkFunTy :: TypeRep -> TypeRep -> TypeRep
04:11:13 <ClaudiusMaximus> > let u = u in mkFunTy (typeOf $ u :: Int) (typeOf $ u :: Double)
04:11:13 <lambdabot>  Couldn't match expected type `Int' against inferred type `TypeRep'
04:11:25 <ClaudiusMaximus> > let u = u in mkFunTy (typeOf (u :: Int)) (typeOf (u :: Double))
04:11:27 <lambdabot>  Int -> Double
04:11:39 <ClaudiusMaximus> > let u = u in mkAppTy (typeOf (u :: Int)) (typeOf (u :: Double))
04:11:40 <lambdabot>  Int Double
04:11:49 <thartman> is there a prelude or Data.List func or something that does this?
04:11:52 <thartman> > reverse . take 3 $ reverse [1,2,3,4,5]
04:11:53 <lambdabot>  [3,4,5]
04:13:29 <quicksilver> thartman: last 3 elements? no
04:13:55 <quicksilver> drop (length l - 3) is not too bad
04:14:05 <thartman> I mean, last n elements.
04:14:17 <thartman> like take, but from the end.
04:14:22 * quicksilver nods
04:14:28 <quicksilver> I'd use drop and length, personally
04:14:37 <quicksilver> that's going to be faster than two reverses, and IMO clearer
04:14:50 <thartman> makes sense.
04:15:05 <Thunder> and it does share the tail in memory
04:15:52 <quicksilver> you could do something rather clever to do a single traverse
04:15:58 <quicksilver> but it would be mainly for cuteness value
04:16:03 <Thunder> @pl \s -> drop (length s - n) s
04:16:03 <lambdabot> drop =<< subtract n . length
04:17:05 <Thunder> quicksilver: Yep slightly modified version of length will suffice.
04:17:30 <thartman> what about unique? eg, http://www.csse.monash.edu.au/~lloyd/tildeFP/Haskell/1998/List/, but somewhere in a standard lib.
04:17:30 <lambdabot> Title: Lists
04:17:34 <quicksilver> > let endtake n l = endtake' (drop n l) l; endtake' [] l = l; endtake' (x:xs) (y:ys) = endtake' xs ys in endtake 3 [1..5]
04:17:35 <lambdabot>  [3,4,5]
04:17:49 <quicksilver> thartman: that's the cute version which only makes one traverse, and shares tails :)
04:18:26 <quicksilver> thartman: it uses "drop n l" as a concrete version of "length l - n"; i.e. representing an integer by a list of that length
04:19:29 <Thunder> quicksilver: clever, I'd used numeric and had n more steps.
04:19:47 <quicksilver> thartman: 'unique' is called 'nub' in haskell standard libs
04:19:55 <thartman> ah, forgot that one.
04:20:18 <quicksilver> as someone pointed out yesterday, rotate each letter individually by 180 degrees, nub --> unq
04:21:00 <quicksilver> Thunder: it's a powerful technique, using a data-structure purely to represent a 'shape', never consulting its contents
04:22:01 <quicksilver> Thunder: the lists then represent 'straight-line recursion' while trees can represent subdivision-style recursion patterns
04:22:44 <thartman> here's my one liner (without the endtake stuff tho)...
04:22:45 <thartman> cat out_select_char_length_csv.out | ghc -e 'interact $ unlines . map show . reverse . take 10 . reverse . Data.List.sort . map ( read :: \
04:22:49 <thartman> String -> Integer ) . filter ( all Data.Char.isDigit ) . Data.List.nub . lines'
04:23:10 <thartman> grep through a list, sort numerically (not alphabetically), take the end.
04:23:58 <quicksilver> thartman: have you seen HSH?
04:24:46 <thartman> seen yes, dug into, no.
04:24:55 <thartman> maybe getting about time to do so though,.
04:26:38 <quicksilver> thartman: of course 'nub' is horribly inefficient since it isn't permitted to assume (Ord a)
04:27:02 <quicksilver> thartman: it works on 'Eq a' so it is quadratic (I presume; can't think how it could be otherwise)
04:27:58 <thartman> aware of that. I'm kind of taking the approach of get it to work, speed it up later :)
04:28:23 <quicksilver> thartman: if you're assuming Ord (which you are, since you use sort) it might be better to use Data.Set.fromList, which gives you nub and sort both, for n log n instead of n^2
04:28:51 <quicksilver> > Data.Set.fromList [6,3,1,6,6,1,4,5]
04:28:52 <lambdabot>  fromList [1,3,4,5,6]
04:29:15 <thartman> oh, in this case that is definitely true.
04:29:18 * quicksilver nods
04:29:42 <quicksilver> and Data.Set has all kinds of other handy operations
04:31:13 <quicksilver> interact $ unlines . map show . reverse . take 10 . reverse . Data.Set.toAscList . Data.Set.fromList . map (read :: String -> Integer) . filter (all Data.Char.isDigit) . lines
04:31:29 <quicksilver> :t unlines . map show . reverse . take 10 . reverse . Data.Set.toAscList . Data.Set.fromList . map (read :: String -> Integer) . filter (all Data.Char.isDigit) . lines
04:31:31 <thartman> how do I get it badk into list form, so it doesn't break my one liner?
04:31:31 <lambdabot> String -> String
04:31:38 <thartman> oh, ok
04:31:38 <quicksilver> toAscList :)
04:32:15 <quicksilver> toAscList . fromList is essentially an efficient way to do sort+nub in one go
04:39:34 <dcoutts> @seen ndm
04:39:34 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 14h 6m 24s ago, and .
04:41:25 <quicksilver> leaving #ghc? how could he!
04:43:25 <dons> who'd have thought there'd be 650+ properties an implementation of the List library should satisfy
04:43:31 <dons> yay for List
04:44:03 <LPhas> 650+ O_O
04:44:24 <dons> well, we've written 650 properties so far.
04:44:29 <dons> i think we'll find a few 100 more
04:44:42 <dons> its interesting, you end up with quite a good spec for the behaviour of Data.List
04:45:06 <dons> particular once you start checking strictness properties
04:45:16 <dons> anyway, night all!
04:45:27 <quicksilver> dons: I was muttering the other day about allowing people to annotate typeclasses with equations
04:45:41 <quicksilver> dons: which would be just annotations, but a compiler flag might generate code to test them
04:46:20 <dons> well, quickcheck... :-)
04:46:32 * quicksilver nods
04:46:41 <quicksilver> yes buyt the point is instances
04:46:50 <quicksilver> the point is, the author of the *class* writes the equation
04:46:51 <dons> yeah
04:47:00 <quicksilver> but the compiler checks it on behalf of the author of an *instance*
04:47:01 <dons> the problem with typeclasses is the extra side conditions
04:47:15 <dons> that random instances don't satisfy
04:47:17 <dons> which breaks all the nice rules
04:47:19 <quicksilver> right
04:47:22 <dons> Ord is a good one
04:47:26 <quicksilver> that's the point behind my suggestion :)
04:47:45 <quicksilver> encoding the side conditions so that they can in principle be tested by a compiler
04:47:55 <dons> i think if we were to write the h98 spec now, we'd include QC properties for the classes
04:48:39 <dons> since we can't even sort properly, if people write bogus Ord, and you can segfault with a bogus Ix instance
04:48:42 <dons> all very unsavoury
04:49:17 * quicksilver nods
04:49:57 <dons> it means i can't write specific rules for my library either, since some user foo in the future will just do the wrong thing.
04:50:07 <dons> though i'm inclined to instead use BIG WARNINGS about writing bad code ;-)
04:50:40 <dons> anyway, bed time.
04:50:41 <dons> night
04:50:55 <vincenz> xerox_: hehe, nice gateway
04:50:55 <quicksilver> night
04:51:00 <vincenz> cya dons
04:51:07 <xerox_> vincenz hehe
04:51:19 <xerox_> uni...
04:54:58 <matthew_-> @seen edwinb
04:54:58 <lambdabot> edwinb is in #haskell. I last heard edwinb speak 3d 20h 19m 19s ago.
04:55:30 <quicksilver> he's the wise, silent type :)
04:56:09 <matthew_-> mmm. I just met his boss.
04:57:00 <matthew_-> it really is a shockingly small world...
04:57:02 <quicksilver> who is edwin's boss these days?
04:57:32 * edwinb wakes up
04:57:42 <edwinb> oh yes, he's down south this week...
04:57:55 * xerox_ pokes edwinb
04:57:56 <edwinb> quicksilver: Kevin Hammond
04:58:03 * edwinb squeaks
04:58:15 * quicksilver nods
04:58:20 <matthew_-> yup, that's the guy
04:58:27 <quicksilver> matthew_-: theoretical computer science is a very small world indeed
04:58:31 <matthew_-> visiting Paul Kelly at Imperial this morning...
04:58:49 <matthew_-> yeah - I was surprised he was meeting Paul though as Paul's hardware and high performance and stuff
04:59:05 <edwinb> they're working on some stuff together
04:59:23 <edwinb> we're getting into functional programming for hardware design now
04:59:42 <edwinb> and there's a common interest in generative programming
04:59:44 <quicksilver> the good computer scientists recognise the links between very different areas of the subject :)
05:00:02 * matthew_- ponders
05:00:25 <quicksilver> if you're a practical type (like me) then one of the key things about understanding theory is to see how applicable it is, even if that isn't what the theory person was particularly thinking when he did the maths
05:01:13 <edwinb> yeah, that's what interests me about it
05:01:17 <quicksilver> or at least, that's my way of looking at it
05:01:33 <edwinb> someone once said to me "You can't be a real type theorist, you like to write programs" or something like that
05:01:48 <matthew_-> edwinb: yup, I've heard that one a few times
05:02:08 <matthew_-> still, there are some people here who do their entire PhD on type theory without writing a line of code
05:02:19 <quicksilver> which is fine, probably
05:02:24 <edwinb> I'm glad they do, or I'd never use it ;)
05:02:34 <quicksilver> although sometimes an 'implementation' of your theory is an extremely good way to debug it
05:02:50 <quicksilver> nothing like a computer program to point you at the gaping hole in your soundness proof
05:03:04 <quicksilver> terribly easy to elide over a critical step, in written prose :)
05:03:22 <matthew_-> quicksilver: there're increasing trends to using model checkers here
05:03:29 * edwinb goes back to writing programs to generate type theory
05:03:35 <matthew_-> proofs are less likely to go wrong that way...
05:03:42 <quicksilver> matthew_-: true
05:04:41 <pejo> quicksilver, isn't everything proof wise basically structural induction over terms?
05:04:47 <matthew_-> edwinb: that photo of Kevin at http://www.dcs.st-and.ac.uk/~kh/ doesn't quite look like him - I'm guessing about ten years ago?!
05:04:49 <lambdabot> Title: Kevin Hammond
05:04:58 <quicksilver> pejo: no
05:05:13 <quicksilver> pejo: if everything was structural induction everything would be easy :)
05:06:36 <pejo> quicksilver, aren't we talking type theory?
05:06:38 <edwinb> matthew_-: he does look rather younger there, yes
05:06:52 <edwinb> everything is structural induction, it can just be hard work to find the actual structure...
05:06:52 <quicksilver> the hard bit is sometimes finding the correct statement of the lemma to use in the induction
05:07:01 <quicksilver> and sometimes the hard bit is finding the structure
05:07:06 <quicksilver> but that's a bit reductionist....
05:07:23 <quicksilver> since then all you're really saying is 'I can re-cast any proof as a structural indcution, if you let me choose the structure'
05:07:31 <quicksilver> which is true, but quite uninformative
05:09:53 <pejo> I wasn't quantifying over all proofs, more like the normal case for type theory / program transformations / etc.
05:10:07 <pejo> Bit of a circular definition there, but we're not very formal here anyways!
05:11:44 <quicksilver> If you have an interesting program transformation then yes, the proof would be expected to be a structural induction
05:11:48 <quicksilver> but that's not the hard bit
05:11:54 <quicksilver> the hard bit is either constructing the invariant
05:12:01 <quicksilver> or constructing the 'step'
05:12:07 <quicksilver> depending how you set up the machinery
05:13:00 <Dunearhp> Can someone tell me what curly braces mean in Haskell?
05:13:12 <ibid> Dunearhp: they're punctuation
05:13:43 <ibid> Dunearhp: they don't mean anything by themselves, like commas in english
05:13:44 <quicksilver> Dunearhp: 90% of the time, they're an alternative to the layout rule
05:13:55 <Dunearhp> I have come across an idiom that confuses me
05:14:04 <pejo> quicksilver, what 'step' are you talking about, in the transformation, or the induction?
05:14:05 <ibid> quicksilver: 90 % of the time they are actually used, they are not an alternative to the layout rule :)
05:14:07 <quicksilver> Dunearhp: so you can write do {a ; b; c; } instead of a b and c each on a seperate line
05:14:13 <ibid> Dunearhp: please show some code
05:14:17 <Dunearhp> data FileInfo = FileInfo {fName :: String, fSize :: Integer}
05:14:19 <quicksilver> Dunearhp: the other 10% they're a special syntax for records
05:14:28 <ibid> Dunearhp: ah, there, that's just record syntax :)
05:14:29 <Dunearhp> \FileInfo { fName = name } -> [New.cellText := name]
05:14:35 <quicksilver> ibid: yeah, my 90% was a statistic made up on the spot :)
05:14:37 <ibid> Dunearhp: again record syntax
05:14:45 <quicksilver> pejo: I meant the induction step
05:15:15 <quicksilver> Dunearhp: that means : data FileInfo = FileInfo String Integer
05:15:24 <quicksilver> Dunearhp: except it also sets up special 'names' for the fields
05:15:29 <quicksilver> Dunearhp: and special syntax for accessing them
05:15:30 <ibid> Dunearhp: data FileInfo = FileInfo { fName :: String, fSize :: Integer } means the same as data FileInfo String Integer, but with some special goodies added
05:15:47 <quicksilver> Dunearhp: then \FileInfo { fName = name } is the same as \FileInfo name _
05:15:50 <ibid> Dunearhp: for instance, you can pattern match using that syntax, as you saw above
05:15:59 <pejo> quicksilver, or just point to an article by some smart fellow that has already proven your transformation correct. :-)
05:16:01 <quicksilver> Dunearhp: i.e. it means you don't have to remember which order you defined the fields
05:16:23 <quicksilver> pejo: indeed, but then you're not doing the proof :)
05:16:59 <ibid> Dunearhp: what quicksilver said :)
05:17:37 <pejo> quicksilver, think I forgot how this discussion started.
05:19:36 <Dunearhp> Thanks, I can technically see what it is doing, but I can't find documentation explaining how this pattern match
05:19:48 <Dunearhp> works in the lambda notation
05:20:03 <quicksilver> the documentation is in the report, hidden away :)
05:20:18 <quicksilver> but basically in a pattern match, you can use field names instead of field posiitions if you want to
05:20:49 <quicksilver> data MyRec = MyRec { foo :: Int, bar :: Int, baz :: Int }
05:20:52 <MarcWeber> What do you think about adding another mailinglist about web developement with haskell? Where is the place to request this? haskell-admin@haskell.org ?
05:21:14 <quicksilver> \MyRec { bar = 3 } is easier than \MyRec _ 3 _
05:21:20 <quicksilver> because you don't need to remember the positions
05:21:24 <quicksilver> or thats the argument, anyway
05:21:28 <quicksilver> I don't use them much myself :)
05:21:45 <quicksilver> MarcWeber: I would suggest to discuss the idea of creation on -cafe
05:21:49 <Dunearhp> It is the {fName = name} rather than {name = fName} that throws me
05:21:52 <fasta> Failed to load interface for `FOO': (where FOO is the as name of a module) Use -v to see a list of the files searched for.
05:22:06 <fasta> I only get this in Emacs.
05:22:18 <quicksilver> MarcWeber: and if agreement is reached, surely someone will know how to action it :)
05:22:18 <Dunearhp> Is it creating a partial function application on fName?
05:22:23 <quicksilver> Dunearhp: no
05:22:25 <fasta> Reloading, C-c C-l doesn't solve the problem.
05:22:28 <quicksilver> Dunearhp: it's not creating anything
05:22:34 <quicksilver> Dunearhp: it isn't a first class construct
05:22:38 <quicksilver> Dunearhp: it's a special syntax
05:22:47 <fasta> I can restart Emacs, but I'd rather do not do that.
05:22:52 <MarcWeber> quicksilver: I'll post a new thread then.
05:22:54 <Igloo> kzm: ?
05:22:57 <quicksilver> Dunearhp: it just means \FileInfo name _
05:23:56 <kzm> Igloo, oh, .deb questions, but I think I've worked it out.  (If you have the time, you could perhaps try to install the packages at http://www.ii.uib.no/~ketil/debian ?)
05:23:58 <lambdabot> Title: Index of /~ketil/debian
05:24:54 <quicksilver> Dunearhp: in particular, it has nothing to do with the function 'fName'
05:25:01 <kzm> BTW, is there any way for me to build a package for the x86-64 architecture?  Using the same binary would be fine (32bit is faster anyway)
05:25:08 <quicksilver> Dunearhp: except that they were both created by the same magic at the same time
05:26:13 <Dunearhp> quicksilver, ibid: thanks, I'll go look in the Report. Does this syntax/idiom have a name?
05:26:41 <quicksilver> Dunearhp: 'record syntax'
05:26:46 <fasta> Hmm, even restarting Emacs doesn't solve the problem I posted above :(
05:26:55 <Igloo> kzm: NAFAIK
05:27:13 <Dunearhp> thanks
05:27:25 <kzm> Okay.
05:27:43 <Igloo> kzm: There are a few lintian warnings that should be easy to fix. Also an error: /usr/bin/rbr is statically linked
05:29:02 <Igloo> kzm: Oh, and I can't install it because I don't have fps
05:29:15 <kzm> Is static linking an error?
05:29:49 <quicksilver> it's a debian policy violation unless there is a good reason to do so
05:29:58 <kzm> Oh right.
05:31:21 <kzm> Is fps needed for install as well, or just build?  Is there a debian package it should depend on?
05:31:53 <kzm> (I guess I had it installed via cabal, and of course 6.6 ships it included)
05:32:08 <Igloo> You should just use Data.Bytestrin from base
05:35:24 <kzm> I'm a bit confused here.  I thought linking rbr statically would eliminate any dependencies (on e.g. fps).
05:38:03 <araujo> morning
05:38:43 <Igloo> It's the lib package I tried to install; the binary will be fine whether statically linked or not
05:39:28 <vincenz> @localtime dcoutts__
05:42:50 <bringert> dcoutts__: hey, you in .au?
05:43:01 <bringert> sweet
05:44:19 <kzm> Igloo, ok.  But base doesn't provide Data.ByteString for ghc-6.4.2, does it?
05:49:00 <Dunearhp> quicksilver:  thanks again. I found it under the heading labelled fields
05:49:03 <Dunearhp> http://www.haskell.org/onlinereport/decls.html#field-labels
05:49:03 <lambdabot> Title: The Haskell 98 Report: Declarations
05:50:06 <Dunearhp> goodnight
05:55:41 <Igloo> kzm: No
05:58:19 <kzm> ..which means I must stick to ghc-6.6, build a .deb for FPS for 6.4.2 only, or include it?
05:58:48 <Igloo> It depends what you want the deb
05:58:51 <Igloo> for
05:59:07 <mux> dang, that reminds me I still didn't change the FreeBSD port for FPS to conflict with ghc-6.6
05:59:26 <Igloo> If you want a source package that can be used with either 6.4.2 or 6.6, then the easiest way is to make an empty fps package for 6.6 and depend on fps
05:59:47 <Igloo> If you just want something that can go into Debian itself then just don't depend on fps and make it 6.6-only
06:01:37 <kzm> Is fps debianized somewhere?
06:01:55 <quicksilver> as part of 6.6, it is
06:02:02 <quicksilver> I'm not aware of a 6.4-fps package
06:02:29 <quicksilver> ah, Igloo's comment would suggest there is, sorry
06:02:48 <Igloo> I didn't mean to suggest that - I don't know of one either
06:03:29 * kzm rolls up his sleeves.
06:04:36 <kzm> A binary library deb would still be compiler specific, wouldn't it?
06:04:41 <Igloo> Yes
06:04:57 <Igloo> Why is 6.4.2 important to you?
06:05:02 <kzm> So I need to make two releases: one for 6.6 and another for 6.4.2 (which could depend specifically on fps)
06:05:10 <kzm> It's what ships on my system.
06:05:17 <Igloo> Oh, ubuntu?
06:05:18 <vincenz> Igloo: you mentioned a fix?
06:05:20 <kzm> (Ubuntu Edgy)
06:05:38 <Igloo> Two binaries, but you could probably make do with one source
06:05:49 <kzm> I'll have Feisty when I get a laptop in a week or so, which, I trust will do ghc-6.6.
06:05:59 <Igloo> vincenz: I think I saw the bug being closed, but I might be misremembering
06:06:01 <kzm> Yeah - build-depends.
06:07:36 <Igloo> vincenz: http://hackage.haskell.org/trac/ghc/ticket/1214
06:07:37 <lambdabot> Title: #1214 (Iface type variable out of scope) - GHC - Trac
06:07:49 <kzm> But I don't think it's so important to provde the library as a deb, I'll settle for the program.
06:08:15 <kzm> If a significant number of people want fps on deb for 6.4.2, I guess we could package it up.
06:09:12 <kzm> Anyway: thanks for the help!
06:12:43 <vincenz> thx
06:14:45 <vincenz> Igloo: cool :)
06:15:24 <vincenz> Igloo: how do I update?
06:16:17 <Igloo> vincenz: Build the 6.6 branch, or grab a nightly snapshot
06:16:48 <vincenz> so just redownload the 6.6 tgz and recompile and reinstall and let it install over existing?
06:25:35 <ndm> @seen malcolmw
06:25:35 <lambdabot> malcolmw is in #ghc, #haskell-overflow, #haskell-blah and #haskell. I don't know when malcolmw last spoke.
06:25:59 <ndm> malcolmw: if you have any questions on the hscolour patches, feel free to message me in here
06:31:05 <vincenz> :hardcopy
06:33:07 <Igloo> vincenz: No, you need the source from the 6.6 (darcs) branch, not just 6.6
06:34:49 <mux> @hunt dcoutts -- go lambdabot! get him!
06:34:49 <lambdabot> Maybe you meant: quit run
06:34:50 <vincenz> Igloo: oh, ok
06:34:55 <Igloo> vincenz: See "Getting a branch" on http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources then http://hackage.haskell.org/trac/ghc/wiki/Building/Hacking for details
06:34:58 <lambdabot> Title: Building/GettingTheSources - GHC - Trac, http://tinyurl.com/y3nvjj
06:35:06 <vincenz> thx
06:37:42 <matthew_-> has anyone here used the perl module HTML::Chunks and is prepared to admit it?
06:38:03 <matthew_-> because I'm thinking of reimplementing it in Haskell
06:38:41 <matthew_-> for the interested, http://search.cpan.org/~mblythe/HTML-Chunks-1.53/lib/HTML/Chunks.pm
06:38:43 <lambdabot> Title: HTML::Chunks - A simple nested template engine for HTML, XML and XHTML - search. ..., http://tinyurl.com/24z7w5
06:44:12 <ndm> @seen dons
06:44:12 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1h 53m 31s ago.
06:45:17 <ndm> can anyone give me an example of a program that is in real use, written in haskell 98, and around the 500-1000 lines of code count
06:45:37 <ndm> something like cpphs/hscolour/hoogle, but not those
06:46:10 <quicksilver> something to test catch on, perhaps? :)
06:46:17 <ndm> quicksilver: indeed :)
06:46:42 <ndm> quicksilver: hscolour is done, i wrote hoogle (not a fair test), and cpphs is another of malcolms - so am looking for some variety
06:46:52 <pejo> ndm, nothing from just browsing darcs.haskell.org?
06:46:55 <sjanssen> xmonad is Haskell '98+FFI+hierarchical modules.  But it only has about a dozen users :)
06:47:24 <yshhq> @src STRef
06:47:24 <lambdabot> data STRef s a = STRef (MutVar# s a)
06:47:35 <yshhq> @hoogle STRef
06:47:35 <lambdabot> Data.STRef :: module
06:47:35 <lambdabot> Data.STRef.STRef :: data STRef s a
06:47:35 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
06:47:41 <sjanssen> fewer than a dozen, probably
06:47:52 <yshhq> @source Data.STRef
06:47:52 <lambdabot> http://darcs.haskell.org/packages/base/Data/STRef.hs
06:48:18 <ndm> sjanssen: actually thats a good one - a few users is fine
06:48:32 <ndm> pejo: thanks, c2hs seems the only thing there that looks appropriate, wiill take a checkout
06:48:37 <ndm> @where xmonad
06:48:37 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
06:49:13 <ndm> hmm, the import of Xlib looks annoying
06:49:15 <sjanssen> ndm: do you need it's dependencies too?
06:49:23 <ndm> sjanssen: yes, whole program
06:49:27 <sjanssen> yeah, you probably won't be able to do that on win32
06:49:43 <yshhq> @source  Data.STRef.STRef
06:49:43 <lambdabot> Data.STRef.STRef not available
06:49:47 <ndm> i don't need to run the code
06:49:52 <ndm> just compile it
06:50:10 <ndm> under Yhc though, which is where i think i will fail with that
06:50:30 <sjanssen> the X11 package is full of .hsc's, which you won't be able to process without the having the xlib headers
06:50:35 <ndm> doh
06:50:37 <ndm> @where c2hs
06:50:38 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
06:50:51 <ndm> @seen dcoutts_
06:50:51 <lambdabot> dcoutts_ is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
06:54:03 <sjanssen> ndm: does Yhc support FFI?
06:54:09 <ndm> sjanssen: yes
06:54:42 <mwc> Sigh, too bad about John Backus
06:55:25 <chessguy> 'morning haskellers
06:57:01 <mightybyte> 'morning
06:57:51 <mwc> Lol... ``Lisp has all the visual appeal of oatmeal with fingernail clippings mixed in.'' ---Larry Wall
06:58:48 <arke> good morning
06:58:53 <quicksilver> that's awesome coming from the creator of Perl :)
06:59:00 <quicksilver> (much as I love the language)
06:59:11 <chessguy> ?remember LarryWall Lisp has all the visual appeal of oatmeal with fingernail clippings mixed in.
06:59:11 <lambdabot> Done.
06:59:47 <chessguy> perl is more like the visual appeal of oatmeal with razor blades mixed in
06:59:50 <ndm> hmm, getting c2hs doesn't work
07:00:04 <sioraiocht> chessguy: I just ate oatmeal, now I want to vomit. kthx!
07:00:15 <chessguy> haha
07:00:27 <quicksilver> chessguy: I would say the razor blade are more attractive, yet more dangerous
07:00:34 <quicksilver> chessguy: not sure if that's what you intended :)
07:00:38 <chessguy> more attractive?
07:00:42 <chessguy> not in food!
07:00:50 <quicksilver> they're shiny and metallic
07:00:58 <quicksilver> that's nicer than nail clippings in my book
07:01:20 <sjanssen> I prefer oatmeal with raisins mixed in
07:01:28 <chessguy> i would say if i saw razor blades mixed in with my oatmeal it would scare the crap out of me and i'd stay away from it
07:01:44 <pejo> chessguy, don't let your fear control you. Fear can't kill you.
07:02:03 <sjanssen> pejo: yes, but eating razor blades certainly could
07:02:17 <quicksilver> chessguy: we're talking about attractive, not fearsome, though
07:02:23 <sioraiocht> pejo: Fear leaders to anger, anger leads to the Dark Side blah blah blah?
07:02:40 <quicksilver> chessguy: I might say a lion is more attractive than a slug, though it's certainly also more fearsome
07:02:41 <sjanssen> sioraiocht: anger leads to hate
07:02:47 <quicksilver> chessguy: be it in my oatmeal or otherwise
07:02:56 <sioraiocht> sjanssen: and hate...leads to SUFFERING! yes I remember the line =pe
07:03:36 <pejo> Actually we were looking at the toxic information pages earlier today. Most petroleum products said "Unless any visible effects, drink cream and don't worry".
07:03:50 <pejo> sjanssen, so apparently you can eat an awful lot of things without having to worry!
07:04:14 <chessguy> so anyway, how about that haskell....
07:04:21 <mwc> pejo: just chow down on some prussian blue and photographer's hypo
07:04:28 * sioraiocht likes haskell!
07:04:36 <mwc> you can eat pretty much any deadly inorganic toxic mineral that way
07:04:48 <mwc> yeah, haskell is gorgeous
07:05:05 * sjanssen is running a window manager in Haskell!  With tiling!  So exciting!
07:06:02 <sioraiocht> orly?
07:06:15 <sjanssen> yep
07:06:18 <sjanssen> @where xmonad
07:06:19 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
07:06:56 <sioraiocht> what's it made to place nice for?
07:07:02 <sioraiocht> any *nix?
07:09:37 <sjanssen> should build on anything that has xlib
07:09:46 <LPhas> sjanssen: a window manager in Haskell??
07:09:59 <sjanssen> LPhas: yes.  It's sort of a dwm clone
07:10:28 <LPhas> sjanssen: do you have a screenshot?
07:10:50 <thedward> some places make you ask for the key when you place an order
07:11:09 <thedward> ack. sorry. wrong window.
07:11:15 <sjanssen> LPhas: it's really boring at the moment, windows are displayed fullscreen (no window decorations, no statusbar, etc.)
07:11:37 <sjanssen> I suppose I should make a tiling screenshot
07:13:04 <quicksilver> CosmicRay: ping
07:14:33 <LPhas> uff on macosx i don't have x11 lib :|
07:14:50 <vincenz> Anyone know some nice way to have a test system for complers where you define in the inputfile what you expect the error from the compiler to look like
07:14:54 <quicksilver> you could install it from your install CD if you want, though
07:14:54 <vincenz> I'd love such a framework
07:15:02 <ndm> ping malcolmw
07:15:09 <mwc> LPhas: apple distributes an X11 package you can go find.
07:15:11 <LPhas> quicksilver: i have x11 installed
07:15:18 <malcolmw> ndm: pong
07:15:31 <LPhas> mwc: quicksilver : but still when i Setup.hs configure
07:15:33 <ndm> malcolmw: any good reason that cpphs uses SymTab, and not Data.Map?
07:15:44 <ndm> malcolmw: cause SymTab is making my firstifier loop :(
07:15:50 <LPhas> it says me Setup.lhs: cannot satisfy dependency X11-extras==0.0
07:16:12 <malcolmw> ndm: SymTab is just an association list, isn't it?
07:16:28 <ndm> malcolmw: yes, it is, actually]
07:16:54 <ndm> malcolmw: plus IndTree, which is some tree thing
07:17:00 <malcolmw> ndm: I think it was to avoid needing cpp to distinguish between compiler versions - Data.Map is more recent than cpphs, and I might have used Data.FiniteMap prior to that
07:17:30 <malcolmw> there is a lot of version hell dealing with Haskell libraries, which cpphs specifically needs to avoid.
07:17:51 <sjanssen> LPhas: you can install that library
07:17:53 <sjanssen> @where X11
07:17:54 <lambdabot> I know nothing about x11.
07:17:54 <ndm> hmm, SymTab IndTree looks painful...
07:17:59 <sjanssen> @hackage X11
07:17:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
07:18:06 <malcolmw> ndm: IndTree is a home-grown fast lookup structure
07:18:11 <sjanssen> LPhas: that URL for the source package
07:18:42 <LPhas> sjanssen: thx
07:18:49 <ndm> type SymTab v = IndTree [(String,v)]
07:19:07 <ndm> but i'm trying to figure out why you need IndTree, given the interface implies a simple associative list
07:19:11 <ndm> or a proper map
07:19:21 <ndm> but i don't see the need for associative lists inside a map
07:19:57 <ndm> or is it for the hash-like data structure?
07:20:05 <sjanssen> LPhas: http://cse.unl.edu/~sjanssen/xmonad-tiles.png
07:21:05 <ndm> malcolmw: ah, i think i see - a binary tree of hashes, which leads to an associative list for equal hashes
07:21:18 <malcolmw> ndm: that's right, from what i remember
07:21:50 <malcolmw> ndm: IndTree is a general fast lookup structure, very like Data.Map (but pre-dating it)
07:21:50 <LPhas> sjanssen: compiling X11 package : /usr/bin/ld: can't locate file for: -lX11
07:21:50 <LPhas>  
07:22:17 <quicksilver> you probably need apple's developer pacakges
07:22:23 <quicksilver> to make sure you have libX11 and friends
07:22:36 <LPhas> quicksilver: i have xcode installed..
07:22:39 <malcolmw> ndm: as it happens, cpphs only ever stores Strings in it, so it could be specialised away (and don't you have a tool to do that? :-)
07:23:03 <mux> @tell dcoutts http://mu.org/~mux/colordialog.diff
07:23:04 <lambdabot> Consider it noted.
07:23:16 <ndm> malcolmw: its the higher order functions that are upsetting it - not quite sure why
07:23:49 <malcolmw> ndm: ah, a firstifier that can't handle some higher-order examples?
07:24:10 <ndm> malcolmw: the current version doesn't implement the (theoretically needed) fallback
07:24:40 <sjanssen> LPhas: I remember having this problem on OS X, but I can't remember the solution
07:26:03 <LPhas> sjanssen: #@%$Â£ osx
07:26:34 <vincenz> noone I guess
07:27:03 <bdash> LPhas: X11 comes in two parts on OS X -- X11 user, and X11 development.  you likely don't hve the latter installed
07:27:22 <SamB> hmm, I finally figured out what that other bit is...
07:27:33 <sjanssen> bdash: the compile would fail earlier than the linking stage if LPhas didn't have his headers
07:27:34 * SamB wonders why mod2 is stuck on...
07:27:47 <mwc> bdash: that would explain the lack of headers, but the library should damn well be there.
07:27:59 <sjanssen> SamB: is it stuck on in your normal X11 instance too?
07:28:01 <quicksilver> mwc: not the symlink that you link against :)
07:28:04 <SamB> sjanssen: yes
07:28:05 <bdash> sjanssen, mwc: true, didn't read all the error
07:28:27 <SamB> oh, maybe that was numlock?
07:28:47 <SamB> yes, it seems to be numlock...
07:28:51 <sjanssen> heh
07:29:00 <sjanssen> xmonad probably is doing the wrong thing then :)
07:29:07 * sjanssen investigates
07:29:15 <SamB> what does your xmodmap say?
07:29:17 <SamB> mine says:
07:29:21 <SamB> mod2        Num_Lock (0x4d)
07:29:30 <earthy> did anybody already mention the passing away of John W. Backus here?
07:29:57 <sjanssen> SamB: same here.  This keyboard doesn't have a numlock key, so I haven't seen that problem
07:30:03 <SamB> ah.
07:32:12 <sjanssen> SamB: dwm explicitly removes the numlock mask.  You'll have a fix in a few minutes
07:33:26 <quicksilver> earthy: yes
07:33:37 <quicksilver> earthy: hudak emailed the list, and someone here expressed sadness
07:33:59 <therp> is the "all about monad" from nomaware.com mirrored somwhere? nomaware.com seems to have a DNS problem
07:34:03 <earthy> yeah, I just couldn't find it in the logs
07:34:22 <earthy> there's more than a little sadness there.
07:34:23 <quicksilver> therp: the wayback archive
07:34:28 <SamB> therp: web.archive.org?
07:34:34 <therp> ah that's a good idea thanks
07:35:17 <therp> works thanks
07:37:06 <SamB> Once, someone thought they'd lost a website and I told them that it was on the web archive still. They were happy about that ;-)
07:37:33 <sjanssen> therp: there's a mirror on haskell.org too
07:38:03 * SamB wishes for an idiomatic gender-neutral third-person in english
07:38:15 <mwc> SamB: like it?
07:38:22 <SamB> er. third-person *singular*, at that...
07:38:31 <SamB> mwc: I said third-*person*
07:38:36 <quicksilver> I find 'they' reasonably idiomatic
07:38:40 <mwc> well, it's "third person" grammatically
07:38:41 <quicksilver> not everyone agrees
07:38:50 <mwc> but by convention, it is never used to refer to actual persons
07:38:51 <SamB> quicksilver: but it isn't actually singular
07:38:56 <quicksilver> SamB: sure it is
07:39:07 <SamB> mwc: I am using playful terminology
07:39:16 <quicksilver> If anyone wants to join the haskell-cafe mailing list, they just have to send a single email to subscribe
07:39:18 <SamB> mwc: so I will call "it" third-thing
07:39:20 <quicksilver> that's clearly singular
07:39:24 <quicksilver> any 'one'
07:40:08 <sjanssen> SamB: the patch is in the repo.  Let me know whether it fixes your problem
07:40:17 <quicksilver> SamB: http://robotics.caltech.edu/~mason/ramblings/singularThey.html
07:40:19 <lambdabot> Title: Using "They" as a Singular Pronoun
07:41:20 <LPhas> has elisp in emacs functions for drawing lines, points, shapes etc?
07:44:06 <quicksilver> LPhas: somewhat, but it isn't that simple
07:44:10 <SamB> oh, okay, if shakespear does it then I can feel good about it ;-)
07:44:42 <LPhas> quicksilver: i want a web browser in emacs
07:44:50 <LPhas> quicksilver: but not a textual one
07:45:06 <LPhas> quicksilver: so i can quit using anyithing else
07:45:20 <SamB> what do you mean "not a textual one"?
07:45:30 <SamB> also doesn't emacs already have an almost-decent web browser?
07:45:38 <LPhas> SamB: not like w3m
07:46:06 <SamB> hmm.
07:46:26 <SamB> is that the same w3m that functions as a pager?
07:46:48 <quicksilver> LPhas: emacs doesn't have a layout engine capable of gecko-style layout
07:46:59 <quicksilver> LPhas: at least, it would be absurdly slow
07:47:07 <LPhas> quicksilver: but cool
07:47:16 <quicksilver> LPhas: you're better off using the emacs-UI plugin for firefox
07:48:22 <SamB> I think emacs would need a more flexible buffer model before you could do a decent browser in it
07:48:31 <quicksilver> LPhas: Conkeror it's called
07:48:56 <SamB> Main.hs:89:29:
07:48:57 <SamB>     Couldn't match expected type `Rectangle'
07:48:57 <SamB>            against inferred type `XineramaScreenInfo'
07:49:54 <sjanssen> SamB: actually, we were already handling that numLock stuff, so please unpull the last patch
07:50:07 <sjanssen> SamB: and you'll need the latest version of X11-extras to build xmonad
07:50:28 <SamB> sjanssen: oh. does it have a new version number?
07:50:33 <sjanssen> SamB: what's the value you were seeing for state?
07:50:40 <sjanssen> SamB: no, it doesn't
07:51:00 <fasta> I get /home/fasta/Foo/Bar/Something.hs file name does  not match module name `Foo/Bar/Something '
07:51:28 <SamB> sjanssen: I was seeing 0x10 with no keys down (but numlock on)
07:51:29 <fasta> I have no idea of why it gives this message.
07:51:50 <CosmicRay> quicksilver: pong
07:53:05 <Saizan> fasta: maybe you have '/' as your include path instead of '/home/fasta/' ?
07:53:12 <SamB> sjanssen: might I suggest bumping the third component of the X11-extras version whenever something changes type?
07:53:40 <xs> will the ghc rts be okay with millions of threads? (of the forkIO variety)
07:53:55 <sjanssen> SamB: that won't help unless you run configure every time you build
07:53:57 <SamB> xs: try it and see?
07:54:01 <SamB> sjanssen: true
07:54:20 <mwc> Huh, this is stange behaviour from darcs...
07:54:23 <xs> SamB, hm, okay. i shall if there's nothing known-bad :)
07:54:25 * SamB still wishes Setup.lhs worked more like setup.py
07:54:28 <mwc> Copying patch 161 of 161... done! Applying patch 160 of 160... done.
07:54:43 <LPhas> wo
07:54:50 <SamB> mwc: yeah, that bothers me too
07:55:03 <quicksilver> CosmicRay: was going to pick your brains about quickQuery and laziness
07:55:13 <SamB> mwc: I think it is a --partial thing?
07:55:13 <quicksilver> CosmicRay: seems to me like a worse gotcha than hGetContents
07:55:17 <CosmicRay> quicksilver: ok
07:55:25 <quicksilver> CosmicRay: but I thought maybe there were bits I hadn't understand
07:55:35 <fasta> Saizan: I have /home/fasta in my include path
07:55:36 <CosmicRay> there may be bits I don't understand too, so go ahead
07:55:38 <quicksilver> CosmicRay: alternatively, you could reply to my email on -cafe with enlightening comments :)
07:55:47 <CosmicRay> oh, sure, was it just today?
07:56:08 <fasta> Saizan: The odd thing is that I don't even use that module now.
07:56:16 <quicksilver> CosmicRay: *nod*
07:56:26 <sjanssen> > 0x10
07:56:27 <lambdabot>  16
07:56:33 <quicksilver> CosmicRay: subject liine 'Newbie vs laziness'
07:56:55 <fasta> Saizan: The module itself loads fine when I do C-c C-l (I have a small script that places all the modules in the include path)
07:57:12 <sjanssen> SamB: in ghci, what does Graphics.X11.Xlib.lockMask return?
07:57:25 <CosmicRay> quicksilver: it looks like the problem is just that he's using $! instead of evaluate or some such
07:57:26 <vincenz> \o/
07:57:26 <vincenz>     My brain just exploded.
07:57:26 <vincenz>     I can't handle pattern bindings for existentially-quantified constructors.
07:57:32 <CosmicRay> quicksilver: what am I missing?
07:57:48 <SamB> sjanssen: 2
07:57:50 <quicksilver> CosmicRay: nothing :)
07:58:06 <quicksilver> CosmicRay: but my comments in the same thread are that I'm wondering if quickQuery is really too gotcha-laden for a default interface
07:58:09 <CosmicRay> are you saying that the problem is that his program crashes?
07:58:11 <CosmicRay> ah
07:58:15 <quicksilver> that's the bit that scares me, yes
07:58:25 <quicksilver> the worst hGetContents can do is surprising reads
07:58:36 <quicksilver> having a program crash merely because you run two queries
07:58:38 <CosmicRay> I wish he had replied with the error message he was getting.
07:58:48 <quicksilver> (which doesn't sound like an unusual case to me)
07:58:52 <vincenz> anyone any clues on: I can't handle pattern bindings for existentially-quantified constructors.
07:58:56 <CosmicRay> I don't even know which database he was using
07:59:04 <quicksilver> right, he didn't give much info :
07:59:10 <CosmicRay> some databases (sqlite) don't let you have more than one active query
07:59:12 <CosmicRay> some are fine with that
07:59:33 <CosmicRay> the alternative is having your program crash because you filled up RAM with the 2 million downloaded rows ;-)
07:59:46 <CosmicRay> or some getNextRow sort of interface
08:00:11 <SamB> vincenz: you are trying to write "let ExistentiallyQualifiedConstructor x y = expr in [...]"?
08:00:18 <vincenz> SamB: well yes, that was obvious
08:00:28 <SamB> vincenz: and you can't do that?
08:00:31 <SamB> you have to use a case
08:00:39 <vincenz> ah, thx
08:00:52 <bd_> SamB: hm, why is that? Monomorphism restriction?
08:00:58 <fasta> Saizan: I got it now. Error message is just really bad.
08:01:00 <CosmicRay> quicksilver: would you like to send me a patch for a quickQuery' that is static?  I think others understand the static vs. non-static thing better than me, or you could file a bug at http://software.complete.org/hdbc
08:01:02 <lambdabot> Title: Haskell Database Connectivity
08:01:17 <Saizan> fasta: so, which was the problem?
08:01:20 <SamB> bd_: something to do with keeping the quantified type variable from escaping, I think
08:01:26 <fasta> Saizan: The problem was that a deeply hidden module was importing the non-hierarchical module.
08:01:27 <quicksilver> CosmicRay: mostly I'd like the issue discussed and understood
08:01:41 <sjanssen> SamB: there's now a numlockMask you can configure in Main.hs
08:01:45 <quicksilver> CosmicRay: because I feel the current situation is 'newbie writes sensible looking code and has surprising result'
08:01:54 <fasta> Saizan: I.e. I first had just module Something and then refactored it to ProjectName.Component.Something
08:02:12 <quicksilver> CosmicRay: did you read oleg's comment about how takusen does it, which he posted in the thread about lazy IO a week or two back
08:02:20 <fasta> Saizan: GHC should say: "Module Z is importing a module that does not exists"
08:02:25 <bd_> SamB: Couldn't one escape with a case x of Constructor y -> y ?
08:02:25 <jcreigh> sjanssen: sorry...I will :set expandtab in the future
08:02:26 <lambdabot> jcreigh: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:02:27 <vincenz> @info Ord
08:02:27 <lambdabot> Ord
08:02:31 <vincenz> @methods Ord
08:02:31 <lambdabot> Unknown command, try @list
08:02:33 <vincenz> @list
08:02:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:02:39 <CosmicRay> quicksilver: no, do you happen to have a url for that?
08:02:48 <bd_> SamB: or well, just as easily anyway
08:02:52 <fasta> Saizan: but it basically claims that the import is always correct and thus it must be the modules fault.
08:03:03 <sjanssen> jcreigh: no worries :).  Try tiling!
08:03:08 <fasta> Saizan: which doesn't really seem like a sane choice.
08:03:15 <quicksilver> CosmicRay: I can fish one up, just a moment
08:03:19 <CosmicRay> http://software.complete.org/hdbc/static/doc/Database-HDBC.html#v%3AfetchAllRows does document some of the potential issues
08:03:21 <lambdabot> http://tinyurl.com/2debxs
08:03:42 <CosmicRay> I suspect his database handle is getting garbage collected before he depands the result
08:03:51 <CosmicRay> s/depands/demands/
08:04:24 <SamB> bd_: well, there is some reason for it anyway.
08:04:30 <quicksilver> CosmicRay: http://www.nabble.com/Takusen-and-strictness%2C-and-perils-of-getContents-tf3337699.html#a9282690
08:04:32 <lambdabot> Title: Nabble - Takusen and strictness, and perils of getContents, http://tinyurl.com/2qjbse
08:04:46 <SamB> bd_: the typechecker won't let you do that either, of course...
08:05:43 <quicksilver> bd_: syntactically you can escape
08:05:52 <quicksilver> bd_: however, such an escape will not be usefully typeable
08:05:58 <quicksilver> bd_: and, hence, not usefully usable
08:06:18 <sjanssen> jcreigh: does sloppy xinerama screen/workspace focus work?
08:06:22 <quicksilver> however you can use class methods on it, if the existential was class-bounded
08:06:26 <quicksilver> which is rather the point, I believe
08:06:27 <robreim> If I create a new trac ticket proposal, is it possible for me to set the deadline somehow? I can't see an option for it in the ticket creation form.
08:06:36 <CosmicRay> quicksilver: what does he mean when he says the chunk is "given to an interateee"
08:06:50 <bd_> quicksilver: right, but I'm wondering why let is any different... is the recursion an issue?
08:08:17 <CosmicRay> quicksilver: I guess I should note that I fundamentally disagree with him about hGetContents.  I think it, and its friends, are an incredibly useful tool if used wisely.
08:08:25 <quicksilver> bd_: Hmm I don't know
08:08:40 <jcreigh> sjanssen: I'm at $WORK ATM, so I'll have to wait until tonight to check it out.
08:08:42 <quicksilver> bd_: something technical to do with irrefutable pattern matches, possible
08:08:50 <CosmicRay> quicksilver: I think the same can be said for databases (just let the library pull down data as needed)
08:09:05 <sjanssen> jcreigh: ok
08:09:08 <CosmicRay> quicksilver: but I understand the problem.  perhaps we need a smallQuery that is like quickQuery but static?
08:09:10 <quicksilver> CosmicRay: I haven't fully grokked his iteratee pattern
08:09:28 <quicksilver> CosmicRay: but I think it's analogous to what an imperative programmer would call 'a callback'
08:09:41 <quicksilver> CosmicRay: I.e. you provide to the library the function which you wish to call on each 'line'
08:09:46 <CosmicRay> quicksilver: I am wondering if it is like HSQL, where the query function takes another function (Row -> IO a) as a parameter and essentially maps over the result set
08:09:50 <CosmicRay> right
08:09:53 * quicksilver nods
08:09:58 <quicksilver> it's a generalisation of that pattern
08:10:14 <CosmicRay> I dislike that model.  it makes it take a lot more code to accomplish some simple things.
08:10:14 <quicksilver> which uses a kind of continuation to enable you to thread state through the callbacks
08:10:17 <quicksilver> (I think)
08:10:21 <CosmicRay> sort of like foldM
08:10:31 <quicksilver> as I say, I don't thoroughly understand it
08:10:34 <CosmicRay> ok.
08:10:51 <quicksilver> I'd almost favour making quickQuery strict by default
08:10:56 <quicksilver> and have quickLazyQuery
08:11:02 <quicksilver> for people who understand the implications
08:11:08 <CosmicRay> anyhow, I think it's too complex.  he provides the other mechanism (getNext), which is analogous to HDBC's fetchRow
08:11:17 <CosmicRay> quicksilver: that makes sense.
08:11:27 <shapr> Good morning #haskell!
08:11:29 <CosmicRay> quicksilver: would you like to create the bug or should I?
08:11:38 <CosmicRay> welcome, #shapr
08:11:39 <shapr> Has anyone use the Haskell cryptolib for session keys?
08:11:47 <shapr> I'm hash shapr now :-)
08:12:01 <CosmicRay> shapr: yes, you're a comment ;-)
08:12:14 <shapr> Is there a wikipedia article or something about which keytypes are best for encryption keys?
08:12:18 <mwc> worse, a CPP macro :(
08:12:19 <quicksilver> CosmicRay: if you wish to be cleverer then what would be *really* nice would be something that was lazy by default
08:12:20 <mnislaih> is there any Shim user around ?
08:12:27 <shapr> I've only read up on pub/priv key cryptosystems.
08:12:31 <quicksilver> CosmicRay: *but* if you try to issue another query and your DB doesn't support it
08:12:41 <quicksilver> CosmicRay: it flushes the first query (into some private buffer behind the scenes)
08:12:55 <shapr> I understand the idea behind session keys, but not which keysystems do that well, or how I would implement it using the Haskell cryptolib.
08:12:56 <CosmicRay> quicksilver: that would be fairly difficult to accomplish, I think
08:12:59 <quicksilver> CosmicRay: *nod*
08:13:14 <CosmicRay> quicksilver: and has some implications for threading (which different databases handle differently)
08:13:24 <quicksilver> true
08:13:50 <mux> dons: I can't 'darcs pull' my lambdabot checkout, darcs outputs tons of 'Can't understand repository format: ..' lines, dumping the HTML page. any idea?
08:14:29 <CosmicRay> mux: upstream url moved?
08:17:41 <quicksilver> CosmicRay: the problem with lazy IO is that when it works great, it is beautiful
08:17:52 <quicksilver> CosmicRay: but when it screws up, it screws up in suprising places
08:17:59 <CosmicRay> yeah
08:18:01 <quicksilver> CosmicRay: which make haskell lose it's nice composition feel
08:18:19 <quicksilver> and is to the detriment of claims the community might make about haskell programs being easy to reason about
08:18:42 <quicksilver> the idea that the behaviour of a function changes based on something you do afterwards
08:18:54 <quicksilver> (Which this hdbc example amounts to)
08:18:58 <quicksilver> is a bit of a nasty thought
08:19:47 <SamB> nobody seems to mind that with Twisted...
08:20:02 <CosmicRay> quicksilver: understood
08:20:20 <malcolmw> mux: I get those repository-format errors from unsw quite often as well
08:20:55 <quicksilver> CosmicRay: oleg's iteratee shows us that we can solve it by inverting control
08:21:00 <malcolmw> mux: in my case, it turned out to be a broken libcurl
08:21:09 <quicksilver> CosmicRay: then all we need is syntactic sugar which makes it look like we haven't inverted control
08:21:14 <quicksilver> CosmicRay: (which is rather like CPS transform)
08:22:05 <malcolmw> mux: either try to upgrade libcurl, or (maybe easier) recompile darcs without curl support, but with wget support instead
08:23:15 <CosmicRay> quicksilver: I don't quite follow, is there an example?
08:23:20 <mux> malcolmw: thanks for the tip, will try that.
08:23:27 <quicksilver> CosmicRay: no, I'm speculating
08:23:36 <quicksilver> CosmicRay: I don't even know if it's possible
08:23:46 <CosmicRay> ah
08:23:59 <quicksilver> CosmicRay: I'm hoping that it's possible to write code which 'implicitly passes a callback' whilst looking like normal code :)
08:24:09 <quicksilver> CosmicRay: but my hope may prove ill-founded
08:24:21 * mux notes an update to curl 7.16.1 is in order
08:24:44 <CosmicRay> heh
08:24:49 <CosmicRay> that would be interesting to see
08:25:24 <quicksilver> CosmicRay: well, much like the 'do' notation allows you to 'bind a variable to the output of a monad'
08:25:34 <vincenz> @hoogle [Maybe a] -> [a]\
08:25:35 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\'
08:25:36 <vincenz> @hoogle [Maybe a] -> [a]
08:25:37 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
08:25:43 <quicksilver> CosmicRay: the 'iteratee notation' would allow you to bind a variable to the next row in the file
08:25:47 <mux> @type map fromJust
08:25:51 <lambdabot> forall a. [Maybe a] -> [a]
08:25:53 <Igloo> malcolmw: With darcs with wget support, do you get loads of wget noise when you get things?
08:26:05 <vincenz> > map fromJust [Nothing, Just 1]
08:26:07 <lambdabot>  Exception: Maybe.fromJust: Nothing
08:26:15 * vincenz smacks mux 
08:26:16 <mux> fromJust considered harmful
08:26:23 <mux> do a catMaybes first then :-)
08:26:26 <vincenz> yes I know
08:26:31 <vincenz> I knew fromJust is harmful
08:26:33 <mux> @type map fromJust . catMaybes
08:26:35 <lambdabot> forall a. [Maybe (Maybe a)] -> [a]
08:26:40 <mux> hrmf
08:26:54 <mux> @type \xs -> map fromJust (catMaybes xs)
08:26:56 <lambdabot> forall a. [Maybe (Maybe a)] -> [a]
08:27:01 <mux> what
08:27:04 <mux> oh, right
08:27:21 <mux> > catMaybes [Nothing, Just 1, Just 3]
08:27:22 <lambdabot>  [1,3]
08:27:28 <mux> is that what you wanted?
08:27:36 <vincenz> yes, and I had that at
08:27:42 <vincenz> 16:24 < lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
08:27:51 <mux> oh well
08:28:11 <mightybyte> @hoogle max
08:28:12 <lambdabot> Prelude.max :: Ord a => a -> a -> a
08:28:12 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
08:28:12 <lambdabot> Prelude.maxBound :: Bounded a => a
08:28:47 <mightybyte> @hoogle [a] -> a
08:28:48 <lambdabot> Prelude.head :: [a] -> a
08:28:48 <lambdabot> Prelude.last :: [a] -> a
08:28:48 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
08:29:01 <vincenz> ndm: ping
08:29:11 <ndm> vincenz: pong
08:29:16 <vincenz> ndm: you work on yhc, right?
08:29:21 <ndm> vincenz: yep
08:29:33 <vincenz> ndm: do you guys use sample inputs that are known to be borked and then append the expected error-output to that input file?
08:29:54 <vincenz> ndm: and if so, do you have some framework to run through a set of these to check if the output and expected output match
08:30:07 <Igloo> ndm: BTW, there's no yhc interactive mode, right?
08:30:50 <ndm> vincenz: we have regression testing, but the expected is stored in a separate file - so yes, we have basically that
08:30:52 <hpaste>  vincenz pasted "ndm: like this" at http://hpaste.org/1047
08:30:53 <ndm> Igloo: not yet
08:31:20 <ndm> vincenz: we put them in separate files, but we do that basic idea
08:31:31 <vincenz> ndm: have some sort of script to do that easily?
08:31:33 <vincenz> or is it as simple as
08:31:40 <vincenz> for i in *.input; ..
08:31:48 <Igloo> ndm: Oh, BTW, why not have make/make install call the appropriate scons commands?
08:32:09 <Igloo> ndm: And is the configure stuff in the repo still actually used?
08:32:11 <ndm> vincenz: we have a testing program, written in haskell - see src/tester
08:32:14 <quicksilver> fromJust is not harmful
08:32:15 <vincenz> ndm: thx
08:32:29 <quicksilver> fromJust is perfectly appropriate if you know (but the type system doesn't) that there will only be Justs
08:32:31 <ndm> Igloo: no, the config stuff isn't - and we could have make/install do the appropriate scons, no reason not
08:32:37 <ndm> quicksilver: its perfectly safe with Catch
08:32:45 <quicksilver> ndm: indeed :)
08:32:46 <ndm> quicksilver: its proving things easily with it
08:32:54 <quicksilver> three cheers for catch, then :)
08:33:08 <ndm> i'm just trying to prove System.FilePath is safe
08:33:10 <quicksilver> for example, if you have written a type-checker, for a custom language of your own
08:33:18 <vincenz> ndm: can I rip that?
08:33:18 * Igloo is sure you're just trying to taunt me into starting to send yhc patches  :-)
08:33:23 <quicksilver> then you can write an 'evaluate' function which makes a whole bunch of cases
08:33:31 <quicksilver> since, that's the point of your type-checker
08:33:41 <quicksilver> checked code never has 'Nothings' in it
08:33:43 <quicksilver> roughly :)
08:33:45 <ndm> vincenz: feel free, i wrote it so consider it BSD'd
08:33:55 <vincenz> tx
08:33:57 <ndm> Igloo: dcoutts kept doing that with me and Yhc
08:34:01 <ndm> * gtk2hs
08:34:08 <vincenz> :D
08:34:47 <ptolomy> Hey, kind of a back-patting question, but I'm easily outsider enough to ask it: How is the haskell community so great?
08:35:02 <emu> @quote stereo
08:35:02 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
08:35:06 <araujo> ptolomy, Because we are based on the lambda power
08:35:10 <vincenz> ptolomy: motivated people, intelligent people, and lack of trolls
08:35:49 <malcolmw> Igloo: no noise from wget, no
08:36:09 <Igloo> Oh, interesting (I do on Windows)
08:36:22 <vincenz> araujo: you mean lambda-cookies
08:36:23 <vincenz> @users
08:36:24 <lambdabot> Maximum users seen in #haskell: 336, currently: 325 (96.7%), active: 46 (14.2%)
08:36:27 <glguy> ?quote troll
08:36:27 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
08:36:31 <vincenz> > replicate 325 "lambda-cookies"
08:36:32 <lambdabot>  ["lambda-cookies","lambda-cookies","lambda-cookies","lambda-cookies","lambda...
08:36:52 <glguy> ?quote troll
08:36:53 <lambdabot> qwe1234 says: are you really this dense, or just trolling me?
08:37:02 <vincenz> from the mouth...
08:37:04 <vincenz> hehe
08:38:08 <emu> the secret, like everything else, is Monads
08:38:47 <erider> what does monads allow one to do?
08:38:53 <glguy> ?quote troll
08:38:54 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
08:39:30 <quicksilver> erider: hide plumbing
08:39:37 <emu> they allow you to "do" things...
08:40:00 <tibbe> do we have any regex specialists in the haskell community? :)
08:40:15 <vincenz> one of my favourite funcs: findDoubleBy :: (Ord b) => (a -> b) -> [a] -> [(a,a)]
08:40:17 <emu> what does it mean to be a regex specialist?
08:40:31 <tibbe> solve a hard (to me) regex problem
08:40:35 <vincenz> another favourite func: findCycles :: (Ord a) =>  (b -> [a]) -> M.Map a b -> [[b]]
08:40:39 <tibbe> ie write a regex that matches a certain string
08:40:54 <SamB> just one?
08:40:56 <tibbe> (or tell me that the language isn't regular so I can give up)
08:40:58 <tibbe> yes
08:41:06 <SamB> that is easy ;-P
08:41:13 <emu> i can show that a language isn't regular
08:41:13 <chessguy> umm, wouldn't the regex just containing that string match that strign?
08:41:17 <vincenz> 0^n1^n
08:41:21 <quicksilver> har regexes aren't worth it
08:41:26 <SamB> chessguy: suitably escaped, yes
08:41:34 <emu> like vincenz's example
08:41:38 <tibbe> "foo 1,2,3 bar 4,5,6" I want to match a number in this string, if bar is present the number must appear somewhere before bar
08:42:03 <vincenz> s/[0-9] *bar/
08:42:12 <vincenz> s/\([0-9]\) *bar/\1
08:42:23 <tibbe> but if bar isn't present
08:42:25 <quicksilver> or /([0-9]+).8bar/
08:42:28 <quicksilver> or /([0-9]+).*bar/
08:42:35 <tibbe> that won't work
08:42:38 <vincenz> quicksilver: you mean [^0-9]*
08:42:38 <SamB> what if there are two bars?
08:42:46 <tibbe> I need some kind of lookahead
08:42:50 <emu> go bar-hopping
08:42:50 <tibbe> there can only be one bar
08:42:52 <tibbe> or none
08:42:53 <vincenz> /([0-9]+)[^0-9]*bar/
08:42:56 <quicksilver> ah, you can't do that in standard regex
08:43:05 <SamB> quicksilver: what?
08:43:07 <quicksilver> there are various lookahead extensions
08:43:08 <tibbe> well, say some extension like pcre
08:43:16 <tibbe> assume we have those
08:43:17 <SamB> you don't really need lookahead
08:43:35 <vincenz> /([0-9]+)[^0-9]*bar/ is ideal :)
08:43:40 <quicksilver> SamB: it has to match whether there is bar or not, but if there is bar, it must match before the bar not after
08:43:44 <tibbe> I plan to apply the regex repeatedly to the string so I get all numbers before bar (i.e. findall)
08:43:50 <malsyned> Is there some way to do pattern matching on a many-fielded data type without saying something noisy like (Param _ _ _ _ _ _ _ _ _ _) ?
08:44:00 <emu> if there is no bar then it can match any number after
08:44:00 <vincenz> tibbe: then you need extend-regexp
08:44:01 <SamB> tibbe: couldn't you just use a parser?
08:44:05 <quicksilver> malsyned: Param {fieldname = x}
08:44:11 <vincenz> tibbe: cause you want to get a minimal match between the number and bar
08:44:12 <emu> if there is a bar then it matches a number and then sees bar
08:44:16 <vincenz> /([0-9]+)[^0-9]*?bar/
08:44:16 <emu> i think vincenz has it
08:44:17 <tibbe> SamB, nope, I'm providing a user with a regex interface
08:44:18 <quicksilver> tibbe: I would *definitely* use a proper parser for something like that
08:44:25 <vincenz> *? = minimal
08:44:29 <vincenz> iirc
08:44:31 <malsyned> quicksilver: that works in pattern matches?  if I supply an empty {}, will that match anything of that type?
08:44:32 <SamB> tibbe: "regex interface"?
08:44:42 <quicksilver> malsyned: yes
08:44:46 <vincenz> back to working on my ++c compiler
08:44:50 <tibbe> SamB the use can give a command line argument which is a regex
08:44:55 <tibbe> it's a program, not a library
08:45:06 <malsyned> quicksilver: that is excellent, thank you.
08:45:09 <hpaste>  vincenz pasted "One cool module :)" at http://hpaste.org/1048
08:45:31 <tibbe> vincenz: the bar at the end won't work if there's no bar!
08:45:40 <vincenz> tibbe: if thee's no bar, then there's no number :)
08:45:53 <tibbe> sure there could be "foo 1,2,3"
08:46:01 <tibbe> there are numbers but no bar
08:46:05 <vincenz> eurhg
08:46:06 <vincenz> fine
08:46:10 <emu> (bar)?
08:46:23 <vincenz> emu: won't work afaict
08:46:25 <SamB> (bar|$)
08:46:26 <SamB> ?
08:46:29 <quicksilver> you can say (bar)?
08:46:30 <malsyned> what's are the idiomatic ways to insert newlines and indentations in a form of the type "do {if cond then cons else alt}" ?
08:46:32 <quicksilver> but it doesn't solve his problem
08:46:33 <emu> same as samb
08:46:55 <vincenz> tibbe: really your format is easy, this is easy as pie in any parserlib
08:46:59 <quicksilver> malsyned: before then and before else, typically
08:47:10 <emu> if cond\n     then cons\n    else alt
08:47:13 <tibbe> vincenz: I agree but it's not an option :)
08:47:13 <SamB> seriously, what is the API you need to implement?
08:47:20 <vincenz> tibbe: then special case the last number
08:47:33 <chessguy> do\n\tif cond \n\t\t then cons \n\t\t else alt
08:47:39 <malsyned> quicksilver: that's where to put the newlines.  where do you indent to?
08:47:39 <tibbe> SamB, the user provides a regex that gives all number before bar but after foo :p
08:47:50 <quicksilver> malsyned: the then has to be at least one space past the if
08:47:57 <quicksilver> malsyned: the else can be the same as the then
08:47:57 <glguy> malsyned: in that example, you wouldn't use do
08:47:59 <emu> both the then and the else have to be indented in a do-block
08:48:11 <tibbe> the two test cases are really "foo 1,2,3 bar 4,2,5" and "foo 1,2,3"
08:48:30 <emu> tibbe: which number of 1,2,3 do you want matched?
08:48:37 <tibbe> in both cases if you use a findall like contruct it should return [1,2,3]
08:48:38 <quicksilver> glguy: ah, hello
08:48:40 <malsyned> glguy: why not?  cons and alt are both do clauses as well, is there a better way to write it?
08:48:56 <quicksilver> malsyned: just if cond then do cons else do alt
08:49:00 <tibbe> emu, all of them but it's enough if it matches the first because I can reapply the regex to the rest
08:49:02 <quicksilver> malsyned: the 'if' doesn't need a do of its own :)
08:49:15 <glguy> malsyned: you only need a "do" when you have multiple lines
08:49:26 <quicksilver> glguy: your comments yesterday about the MonadPlus instance of Maybe
08:49:31 <glguy> malsyned: multiple expressesions rather
08:49:33 <quicksilver> glguy: and the lack of a corresponding Monoid
08:49:35 <emu> tibbe: what's wrong with s/foo \([0-9,]*\)/\1?
08:50:11 <glguy> quicksilver: it wasn't immediately obvious why there wasn't one
08:50:21 <glguy> quicksilver: still isn't :) to me
08:50:23 <malsyned> glguy: what if there are multiple expressions, and the if is the last one?
08:50:24 <vincenz> hiya ADEpt
08:50:25 <tibbe> emu, it returns the first match only AFAIK and the , inside the match is not acceptable because I can't do any post processing to remove it
08:50:44 <glguy> malsyned: then the do would occur before the multiple expressions
08:50:44 <malsyned> do {exp; exp2; if cond then cons else alt}
08:50:55 <ADEpt> vincenz: hi
08:50:59 <tibbe> let me restate the problem, extract a number from a string only if the number isn't followed by 'bar' somewhere later in the string
08:51:16 <malsyned> I guess the answer to my question really was just "before the 'then' and before the 'else'".  thanks.
08:51:23 <quicksilver> glguy: I think all Monads induce Monoids at all types
08:51:42 <quicksilver> glguy: Monad m means that m a is a Monoid, pointwise, at each a
08:51:45 <glguy> tibbe: does all of the logic need to by in the regex?
08:51:50 <glguy> quicksilver: right
08:51:51 <quicksilver> glguy: using >> as multiplication
08:51:54 <tibbe> glguy: yes unfortuneatly
08:52:11 <quicksilver> glguy: it just happens that the Maybe one is more interesting
08:52:21 <glguy> tibbe: since it would be easy enough to say: ([match numbers])(bar)?
08:52:22 <tibbe> glguy: lets assume that I can't even change the software only give it a regex that should extract the number from the string if applied repeatedly
08:52:27 <glguy> and then fail if bar matches
08:53:06 <tibbe> if we view the software as a black box (which it kinda is)
08:53:30 <kc5tja> tibbe: the only way I know how is this:  ([0-9]*)[^|]*
08:53:37 <kc5tja> I'm assuming you mean | for bar.
08:53:45 <kc5tja> If you're talking about the *word* bar, then no, it's not doable.
08:53:51 <tibbe> kc5tja: no, the string "bar" :)
08:53:54 <kc5tja> :(
08:54:15 <kc5tja> Unfortunately, regex applies negation only to individual character classes; not to whole constructs.  :(
08:54:32 <emu> regexes are closed under complement
08:55:03 <kc5tja> Whatever that means, I don't know.  But I've never successfully performed any "negation" of a multi-character construct with a regex.
08:55:25 <kc5tja> I've been using them for years (since I started coding in Perl 4 at the very least)
08:55:35 <emu> perl rots the brain apparently :/
08:55:47 <kc5tja> emu: Or you have a superiority complex.  :)
08:55:53 <kc5tja> I'm not stupid.
08:55:53 <tibbe> so is the language I'm describing regular?
08:55:54 <emu> construct a deterministic finite automata from any regular expression and invert the meaning of the states
08:56:46 <kc5tja> emu: tibbe just said he *CANNOT* do that.
08:56:47 <kc5tja> The software is already written; the meaning of the states are predetermined.
08:57:18 <kc5tja> So, no, regexes are not closed under complement.  It would be if it provided multi-character negation (or negation of parenthetical sequences).  But it doesn't.
08:57:26 <emu> ^ that is the complement
08:57:39 <kc5tja> emu: Read regex docs again; that's only for character classes.
08:59:06 <tibbe> [^b][^a][^r]
08:59:31 <norp> of course [^b][^a][^r] is not the same as the negation of bar
08:59:37 <glguy> tibbe: abcbar
08:59:39 <tibbe> grr, how hard can it be to write something that matches the '1' in "1 bar" but not in "bar 1"
08:59:40 <glguy> tibbe: matches that
08:59:56 <emu> yow, lag
08:59:59 <glguy> tibbe: that much is each
08:59:59 <kc5tja> Correct -- .*[^b][^a][^r].* will still match bar if there are other sequences of characters before and after it.
09:00:00 <glguy> easy
09:00:06 <tibbe> glguy: isn't acbar to long?
09:00:13 <norpan> allah acbar
09:00:15 <emu> regular languages are closed under complementation and regular expressions describe regular languages
09:00:25 <tibbe> yes yes
09:00:25 <glguy> tibbe: no, you didn't use ^ and $
09:00:43 <tibbe> ah
09:00:57 <glguy> bar 1 vs 1 bar is easy though
09:00:58 <kc5tja> emu: They *can* be, but "regex" as implemented in Unix, is not.
09:01:07 <tibbe> glguy: please do tell
09:01:20 <glguy> [0-9] bar
09:01:22 <kc5tja> I'm sorry, but until I see conclusive and independently repeatable demonstration otherwise, that is my understanding based on years of experience using them.
09:01:29 <emu> sigh
09:01:38 <norpan> what he means is that it's always possible to construct a regex that is the negation of a given regex
09:01:47 <tibbe> glguy: oh I'm, sorry, I said (much) earlier that bar may not appear and then "1" should also match
09:01:53 <norpan> but the usefulness of the compliment is small
09:02:14 <glguy> tibbe: right, but then later you said : "grr, how hard can it be to write something that matches the ..."
09:02:22 <tibbe> glguy: so _id_ there is a bar is must not preceed the number
09:02:25 <kc5tja> norpan: Well, if you want to spend your entire life writing a negation, that's fine.  The negated form will be rediculously long, and could well take eons to evaluate.
09:02:35 <kc5tja> norpan: And even then, I'm not convinced until I see a proof.
09:02:39 <tibbe> glguy: right, in my own mind the constraint was still there :)
09:02:40 <norpan> kc5tja: potentially, yes, but it can be done
09:02:43 <kc5tja> But I'm willing to entertain that possibility.
09:02:47 <norpan> but it's not useful
09:03:14 <kc5tja> I disagree.  When using AmigaOS years back, the fact that you could tell the filesystem which files to *NOT* include in its globs were invaluable.
09:03:24 <kc5tja> By extension, negated regexes are equally "da** useful."
09:03:30 <vincenz> <3 Haskell
09:03:31 <tibbe> hmm, perhaps the language I'm describing isn't regular, time for some pumping lemma ;)
09:04:15 <norpan> globs are not regexes though
09:04:33 <kc5tja> norpan: They certainly are too.  Where'd you get the idea they weren't?
09:04:40 <norpan> a very small subset
09:04:52 <norpan> not complete
09:04:54 <kc5tja> They use a different (and less powerful) syntax, but the end result is the same: a function that, given a string, returns a boolean that is true if it matches.
09:04:59 <kc5tja> Irrelavent!!
09:05:09 <kc5tja> If the negation operator works for globbing, it can work for regexes!
09:05:14 <norpan> that's true for a lot of things that aren't regular expressions at all
09:05:43 <norpan> globs cannot express "any number of a:s" for instance
09:05:43 <tibbe> I guess a flag to the regex could be used to negate it, like in s/../.../flag syntax
09:05:45 <kc5tja> #? = .* in regex syntax.
09:05:49 <kc5tja> ? = .
09:05:51 <kc5tja> # = *
09:05:53 <glguy> from the wikipedia, so hardly authorative, but: regular expression (abbreviated as regexp or regex, with plural forms regexps, regexes, or regexen) is a string that describes or matches a set of strings, according to certain syntax rules.
09:05:56 <kc5tja> (it's prefix instead of postfix)
09:06:02 <kc5tja> It allowed character classes.
09:06:16 <kc5tja> And, yes, ! did negation (if memory serves me correctly; its been a few years)
09:06:25 * glguy $
09:06:28 * glguy &
09:06:48 <kc5tja> Oops, no, it was ~ that did negation.
09:07:05 <norpan> this is something else than posix globs then
09:07:15 <kc5tja> dir (#?.(txt|bin)) libs:(~#?.library)
09:07:27 <kc5tja> norpan: I just said it was AmigaOS globs.
09:07:30 <kc5tja> Details, details!
09:08:11 <kc5tja> The world didn't always revolve around Windows or POSIX.
09:08:24 <kc5tja> There once was a time when computing actually was fun, and productive.
09:09:15 <chessguy> kc5tja, huh? the computing world has never revolved around windows
09:09:24 <norpan> or POSIX :)
09:09:31 <norpan> computing is still fun actually
09:09:48 <chessguy> indeed
09:09:57 <norpan> i implemented biere's liveness transformation the other day for instance
09:10:00 <kc5tja> Hardly.  Computing now-a-days is utterly oppressive compared to years ago.
09:10:09 <norpan> that was fun
09:10:11 <emu> regular languages are those which can be recognized by a deterministic finite state automata
09:10:37 <tibbe> emu, can you tell me if mine is regular :)
09:10:53 <emu> a regular expression is isomorphic to a non-deterministic finite state automata which can always be converted into a deterministic finite-state automata
09:11:21 <emu> if you want proofs, Sipser's book on the theory of computation is an excellent and accessible exposition
09:11:49 <tibbe> emu, I did read it and liked it
09:12:03 <tibbe> I think I've concluded that my language is in fact regular
09:13:10 <emu> from my understanding of what you've said, i'd agree
09:13:16 <tibbe> I have a state machine for it
09:13:16 <chessguy> we  used this one in my formal languages class, which i liked: http://www.amazon.com/Automata-Computability-Undergraduate-Computer-Science/dp/0387949070/ref=sr_1_15/102-9540991-7108100?ie=UTF8&s=books&qid=1174407076&sr=8-15
09:13:19 <tibbe> or so I believe
09:13:20 <lambdabot> http://tinyurl.com/2g72re
09:13:28 <emu> if you do, i can turn it into a regular expression
09:13:28 <shapr> SHAZAM!
09:13:41 <chessguy> @shapr
09:13:42 * lambdabot beats up
09:13:42 <tibbe> emu, yes, I'm trying to map it onto the syntqax now
09:13:47 <chessguy> @get-shapr
09:13:48 <lambdabot> shapr!!
09:13:53 <emu> tibbe: how big is it?
09:14:06 <tibbe> emu, 9 states
09:14:21 <tibbe> emu, lemme think for a sec
09:14:51 <tibbe> emu, I have one branch to "trap" strings where "bar" appears before any digits, I'm not sure how to make that a regex
09:15:24 <tibbe> i.e. as soon as it sees a 'b' it goes into a new state, sees an 'a' etc until it has seen bar and then it's stuck
09:15:38 <tibbe> ie in a non-accepting state
09:16:12 <hpaste>  (anonymous) pasted "lempa" at http://hpaste.org/1049
09:16:17 <tibbe> hmm, in fact I think I've found a way to cheat
09:16:55 <chessguy> @pl return $ []
09:16:55 <lambdabot> return []
09:17:14 <tibbe> [^a-zA-Z]+?(\d+)
09:17:18 * quicksilver peers curiously at chessguy 
09:17:31 <chessguy> quicksilver, from the paste
09:17:46 <tibbe> hmm, or not
09:18:26 <DukeDave> Hello all,
09:18:31 <tibbe> hi
09:18:54 <DukeDave> can anyone recommend a (documented ;) ) implementation of an artificial neural network in Haskell?
09:19:07 <DukeDave> not having a great deal of success with Google..
09:19:36 <chessguy> someone was just talking about having implemented an ANN in 30 lines of haskell
09:19:42 <chessguy> on haskell-cafe
09:19:54 <chessguy> he was looking for a place to host his code
09:20:10 <shapr> chessguy: You screamt?
09:20:18 <DukeDave> ah cool, synchronicity
09:20:22 <chessguy> shapr, i just like doing @shapr :)
09:20:27 <shapr> hah
09:20:29 <chessguy> err, @get-shapr
09:20:54 <chessguy> i probably shouldn't cry wolf
09:20:54 <vincenz> anyone have some nice vim bindings for working with haskell, like looking up a typsepec
09:21:21 <chessguy> DukeDave, i have no idea how well-documented or even good it is
09:22:04 <DukeDave> wow, I always forget to search the archives directly.. loads of results :)
09:22:11 <DukeDave> need to stop relying on Google :S
09:22:21 <shapr> Hey, Google is the smart half of my brain.
09:22:27 <emu> vincenz: implement shim-vim!
09:23:10 <quicksilver> vincenz: earth is the vim demon, I think
09:23:14 <quicksilver> earthy: ping
09:23:22 <chessguy> DukeDave, that's why i just have -cafe emailed to me
09:23:41 <earthy> ping
09:23:45 <earthy> what?
09:23:45 <chessguy> DukeDave, there's actually been some interesting discussion recently about putting together a general AI toolkit
09:23:59 <earthy> oh, just a sec
09:24:44 <bakert> ?hoogle String -> String -> Bool
09:24:44 <lambdabot> No matches, try a more general search
09:24:52 <bakert> ? [a] -> [a] -> Bool
09:25:01 <bakert> ?hoogle [a] -> [a] -> Bool
09:25:01 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
09:25:02 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
09:25:08 <quicksilver> what are you after?
09:25:17 <bakert> Is there a way to say "if this string is in that string"?
09:25:27 <quicksilver> @hoogle Infix
09:25:28 <lambdabot> Data.Generics.Basics.Infix :: Fixity
09:25:28 <lambdabot> Text.ParserCombinators.Parsec.Expr.Infix :: GenParser t st (a -> a -> a) -> Assoc -> Operator t st a
09:25:28 <lambdabot> Prelude.infix :: keyword
09:25:31 <bakert> f "hello" "hello and goodbye" == true
09:25:32 <quicksilver> 'hmm
09:25:39 <bakert> f "donky" "magic" == false
09:25:41 <bakert> stylie
09:25:42 <quicksilver> I thought there was ifInfixOf
09:25:55 <quicksilver> however, you could go for
09:25:56 <quicksilver> :t any
09:25:59 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:25:59 <ski> ? (?)
09:26:10 <ski> ? ?
09:26:22 <ski> oh-m
09:26:24 <therp> isInfixOf
09:26:36 <bakert> :t isInfixOf
09:26:39 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
09:26:44 <quicksilver> ah, there it is :)
09:26:46 <ski> :t Cont any
09:26:46 <bakert> aha!  cool
09:26:48 <lambdabot>     Couldn't match expected type `Bool'
09:26:48 <bakert> thanks folks
09:26:48 <lambdabot>            against inferred type `[a] -> Bool'
09:27:01 <ski> :t Cont . flip any
09:27:03 <lambdabot> forall a. [a] -> Cont Bool a
09:27:05 <bakert> ?src isInfixOf
09:27:05 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
09:27:15 <quicksilver> > "hello" `isInfixOf` "and hello goodbye"
09:27:16 <lambdabot>  True
09:27:21 <bakert> ?src isPrefixOf
09:27:21 <lambdabot> isPrefixOf [] _          = True
09:27:21 <lambdabot> isPrefixOf _  []         = False
09:27:21 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
09:27:22 <chessguy> heh, that's nice
09:27:28 <malsyned> @pl \x -> bitName x /= ""
09:27:29 <lambdabot> ([] /=) . bitName
09:27:29 <bakert> coolio
09:27:34 <vincenz> @seen zarvok
09:27:34 <lambdabot> I saw zarvok leaving #oasis and #haskell 1d 11h 33m 36s ago, and .
09:27:49 <quicksilver> malsyned: not.null considered preferably to /= ""
09:28:08 <malsyned> quicksilver: thanks.
09:28:21 <malsyned> that's because it doesn't require an Eq, right?
09:28:24 <quicksilver> malsyned: because it doesn't pull in a spurious Eq constraint, basically
09:28:25 <quicksilver> yes
09:28:38 <bakert> ?pl useSsl addr = or $ map (\x -> isInfixOf x addr) ["wh", "bsq"]
09:28:38 <lambdabot> useSsl = or . flip map ["wh", "bsq"] . flip isInfixOf
09:28:46 <bakert> crazy talk
09:28:51 <chessguy> @type null
09:28:53 <lambdabot> forall a. [a] -> Bool
09:29:11 <ski> > let for_any = Cont . flip any in flip runCont id $ do x <- for_any [0,3,7,8,5]; return (even x)
09:29:12 <lambdabot>  True
09:29:15 <quicksilver> null [] = True ; null _ = false
09:29:31 <LPhas> :t null
09:29:33 <lambdabot> forall a. [a] -> Bool
09:30:20 <bakert> ?hoogle isInfixOf
09:30:21 <lambdabot> No matches found
09:30:29 <bakert> Where does isInfixOf live?
09:30:35 <earthy> vincenz: http://www.cs.uu.nl/~arthurvl/vimhaskell_extras.tar.gz
09:30:37 <quicksilver> bakert: I think it must have been added to a later version of the libraries than the one hoogle has
09:30:40 <chessguy> ?hoogle isInfixOf
09:30:40 <lambdabot> No matches found
09:30:43 <bakert> ah
09:30:49 <earthy> (note, this is work in progress...)
09:31:02 <vincenz> earthy: gracias senor
09:31:15 <earthy> marc weber also has stuff
09:31:30 <earthy> but that is even more mysterious and badly documented
09:32:04 <mux> FWIW, updating curl from 7.16.0 to 7.16.1 fixed my darcs problem
09:32:34 <bakert> Gah.  Can't work out where to get isInfixOf from in 6.6.  Another hint?
09:32:43 <sjanssen> Data.List
09:32:44 <bakert> ?hoogle isPrefixOf
09:32:44 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
09:32:45 <quicksilver> Data.list
09:32:49 <bakert> sjanssen, ta
09:33:04 <quicksilver> bakert: a function defined over [a] is like to be in Data.List
09:33:31 <sjanssen> @pl \x y -> any (isPrefixOf x) $ tails y
09:33:31 <lambdabot> (. tails) . any . isPrefixOf
09:33:32 <chessguy> bakert,http://arcknowledge.com/gmane.comp.lang.haskell.libraries/2006-09/msg00000.html but it doesn't really say where it is
09:33:34 <bakert> yeah, i should have thought of that.  i just googled it and got a lot of darcs mailing list resposnse!
09:33:35 <lambdabot> Title: Re: darcs patch: New function isInfixOf that searches a list for a give., http://tinyurl.com/22halg
09:33:46 <bakert> yeah that's what i saw
09:34:24 * arke loves haskell
09:34:33 <ndm> i just proved my System.FilePath library safe - was far more worried that my FilePath library was incomplete, than that my proof tool couldn't manage it
09:34:44 <chessguy> ah, it is in Data.List though ;http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#12
09:34:46 <lambdabot> http://tinyurl.com/yhrw65
09:37:16 <ndm> @remember Josef Delete the "DO NOT DELETE" lines in .depend
09:37:17 <lambdabot> Done.
09:38:03 <shapr> hiya arke
09:38:15 <shapr> I love Haskell too!
09:38:57 * earthy loves Haskell the programming language, likes Haskell B. Curry, but is indifferent toward Haskell the town
09:39:56 <shapr> I sure do enjoy reading arxiv.org. Where can I find more nifty research papers?
09:40:15 <kaol> citeseer?
09:41:04 <shapr> Ok, I'll try that next.
09:41:08 <malcolmw> mux: glad to hear it worked
09:41:59 <pejo> shapr, scholar.google.com is great for finding the online copies of things, I'd say.
09:42:09 <pejo> But you need to know what you're looking for.
09:42:19 <pejo> Well, or atleast the author.
09:43:06 <shapr> Yeah, I'm doing exploratory searching at the moment.
09:44:17 * shapr looks at Modules over monads and the structure of untyped lambda-calculi
09:45:09 <shapr> http://arxiv.org/abs/cs.LO/0608051
09:45:50 <chessguy> a one-line definition of a lambda-calculus?
09:46:46 <shapr> One sentence, at least.
09:46:46 <chessguy> oh, english definition
09:47:11 <chessguy> i thought it meant definition by implementation
09:48:17 <shapr> It's a category theoretical definition of the lambda calculus, tuned towards checking with Coq.
09:48:27 <chessguy> yeah
09:53:08 <chessguy> heh
09:53:13 <chessguy> what kind of a title is this? "CHESS PURE STRATEGIES ARE PROBABLY
09:53:13 <chessguy> CHAOTIC
09:53:16 <chessguy> "
09:53:30 <bakert> nice
09:53:46 <quicksilver> an allcaps one!
09:54:01 <chessguy> hah!
09:54:02 <chessguy> "The fact
09:54:02 <chessguy> that there must exist pure winning strategies for chess is used to construct a
09:54:02 <chessguy> control strategy function
09:54:13 <chessguy> i'd like to hear a proof of this "fact"
09:54:37 <bakert> This didn't come from a top university, did it chessguy ;)
09:55:11 <chessguy> Universidad de Costa Rica
09:55:43 <quicksilver> I thought chess was widely believed to be a draw, in the technical sense?
09:56:33 <chessguy> well, he tames is statement down a little
09:56:35 <chessguy> "In this paper we offer an explanation for these peculiar situations, based on the following idea: since chess is a finite 2-person zero-sum game of perfect information it is strictly determined [5] and thus, for any particular initial state either White or Black should have a pure winning strategy, or both sides should have pure drawing strategies."
09:57:45 <quicksilver> obviously yes
09:58:03 <chessguy> that's a little different than "there must exist pure winning strategies for chess"
09:58:05 <quicksilver> and isn't it generally speculated that it's pure draw?
09:58:36 <chessguy> yes
09:58:38 <quicksilver> win for black seems inconceivable given the nature of the game, and first move seems like an insufficient advantage to guarantee win for white
09:58:49 <chessguy> though many will say that white has a slight advantage
09:58:58 * quicksilver nods
09:59:03 <chessguy> and a few crazies will even argue that black has an advantage
09:59:14 <bakert> yeah but they are crazee.  spelt like that.
09:59:24 <doserj> well, white is in "zugzwang" at the first move...
09:59:25 <chessguy> (that is, that the initial position is zugzwang)
09:59:37 <chessguy> doserj, not likely :)
09:59:42 <bakert> in my horrendously underinformed opinion
09:59:45 <chessguy> certainly not supported by any real evidence
10:00:12 <doserj> but i feel like it, when I'm playing...
10:00:55 <nominolo> > :t quickCheckIO
10:00:56 <lambdabot>  Parse error
10:01:04 <nominolo> :t quickCheckIO
10:01:06 <lambdabot> Not in scope: `quickCheckIO'
10:01:13 <nominolo> yucky
10:01:30 <chessguy> @type quickCheckMateIO
10:01:32 <lambdabot> Not in scope: `quickCheckMateIO'
10:03:03 <nominolo> @instances Testable
10:03:04 <lambdabot> Couldn't find class `Testable'. Try @instances-importing
10:03:18 <nominolo> @instances-importing Testable
10:03:19 <lambdabot> Couldn't find class `Testable'. Try @instances-importing
10:03:29 <nominolo> stupid bot
10:03:56 <nominolo> has anyone here ever used quickcheck with monadic functions?
10:04:10 <nominolo> and has written a blog-entry or something?
10:05:03 <nominolo> or rather:
10:05:31 <sjanssen> nominolo: the IO monad?
10:05:31 <nominolo> how do i quickcheck parameter-taking functions in the IO-monad?
10:05:46 <nominolo> ie. prop_foo :: Int -> Int -> IO Bool
10:06:09 <vincenz> @hoogle [Either a b] -> ([a],[b])
10:06:10 <lambdabot> No matches, try a more general search
10:07:35 <sjanssen> nominolo: you could do the evil thing and unsafePerformIO
10:07:39 <chessguy> well, this paper is interesting, but ultimately very unsatisfying. it really doesn't wind up saying much
10:08:22 <quicksilver> :t \l -> ((catMaybes . either Just (const Nothing)),(catMaybes . either (const Nothing) Just))
10:08:25 <lambdabot>     Couldn't match expected type `[Maybe a]'
10:08:25 <lambdabot>            against inferred type `Maybe a1'
10:08:42 <vincenz> @hoogle (a -> b) -> (a,a) -> (b,b)
10:08:42 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
10:09:04 <quicksilver> :t \l -> ((catMaybes . map (either Just (const Nothing)) $ l),(catMaybes . map (either (const Nothing) Just) $ l))
10:09:06 <lambdabot> forall a b. [Either a b] -> ([a], [b])
10:09:15 <quicksilver> vincenz: not very elegant :)
10:09:25 <vincenz> quicksilver: yeah
10:09:31 <nominolo> sjanssen: yes, should work
10:11:08 <bakert> Optional arguments.  Do they exist?  Can I fake them?  Is there a better way?
10:11:18 <quicksilver> bakert: Maybe ?
10:11:39 <bakert> But then I have to have an explicit paramenter.
10:11:44 <quicksilver> yup
10:11:45 <bakert> *parameter
10:11:53 <bakert> What I want is:
10:12:03 <bakert> httpGet address headers=[]
10:12:10 <bakert> and then I can supply headers if i want.
10:12:14 <bakert> No dice, I take it.
10:12:15 <ddarius> bakert: There is a variety of ways of simulating them, but none of them very satisfactory for all cases.
10:12:27 <Saizan> they exist but are deprecated
10:12:34 <bakert> Whyso?
10:12:48 <quicksilver> you can have two versions of httpGet
10:12:53 <nominolo> bakert, ddarius: oleg showed they are possible
10:12:54 <ddarius> Implicit parameters aren't quite optional parameters.
10:12:55 <quicksilver> or, you can use type-classes to overload
10:12:58 <ndm> @seen kosmikus
10:12:58 <lambdabot> kosmikus is in #gentoo-haskell, #ghc, #darcs and #haskell. I last heard kosmikus speak 1h 3m 7s ago.
10:13:29 <nominolo> you can also use wxHaskell style constructors
10:13:40 <bakert> quicksilver, when you say two versions what do you mean?  You mean with different names?
10:13:43 <ddarius> nominolo: I know, there are many ways to do them, there just isn't a -nice- general idiomatic way.
10:14:04 <quicksilver> bakert: yes, i mean with different names
10:14:13 <quicksilver> bakert: but then, you can use type classes to overload if you really want
10:14:20 <bakert> perhaps not worth it.
10:14:33 <quicksilver> it may help to think what function application means in haskell
10:14:47 <quicksilver> httpGet address headers is (httpGet address) headers
10:14:51 <ddarius> Perhaps a different approach where you can "add" headers, withHeaders headers (httpGet address ...
10:14:57 <quicksilver> httpGet is first applied to address
10:15:03 <bakert> ah.  right that's interesting
10:15:04 <quicksilver> then, whatever httpGet returns, is applied to headers
10:15:08 <nominolo> i'd just use a HTTP monad
10:15:29 <bakert> nominolo, i am using the BrowserAction monad from Network.Browser.  but perhaps badly!
10:16:02 <nominolo> bakert: I intend to fix this in the next couple of weeks (as a university projecT)
10:16:07 <quicksilver> bakert: it it possible to make (httpGet address) polymorphic in its return type
10:16:08 <bakert> I have made some convenience functions for myself and they are crying out for optional arguments to my python infested brain!
10:16:24 <vincenz> splitEither l = (map unLeft ls, map unRight rs)
10:16:27 <vincenz>   where isLeft (Left _)   = True
10:16:27 <quicksilver> bakert: and build a clever typeclass which knows whether or not to apply itself to the next object
10:16:29 <vincenz>         isLeft (Right _)  = False
10:16:32 <vincenz>         unLeft (Left l)   = l
10:16:34 <vincenz>         unRight (Right r) = r
10:16:36 <vincenz>         (ls, rs)          = partition isLeft l
10:16:39 <quicksilver> bakert: however this is pain :)
10:16:46 <bakert> yeah, that may be overkill!
10:17:02 * ddarius has never really used languages with optional arguments or ones that make extensive use of them.
10:17:11 <bakert> they are great ddarius
10:17:29 <bakert> get_page(address, postvars=[], headers=[])
10:17:33 <bakert> oooh ya
10:17:46 <nominolo> but they don't work well with (implicit) currying
10:17:51 <bakert> nope :(
10:18:04 <quicksilver> nominolo: you mean partial application, I think
10:18:18 <nominolo> er, yes
10:18:31 <bakert> we knew what he meant.
10:18:33 <bakert> !
10:18:44 <nominolo> well, sort of goes together in some way ;)
10:18:44 <bakert> not Schonfinkelisation.
10:19:06 <nominolo> :t curry
10:19:08 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:19:27 <quicksilver> curry is quite specifically about the conversion from tupled arguments to untupled
10:19:31 <nominolo> :t schoenfinkel
10:19:32 <quicksilver> and there is nothing implicit about that :)
10:19:33 <lambdabot> Not in scope: `schoenfinkel'
10:19:53 <nominolo> well all functions in haskell are implicitly curried
10:20:00 <quicksilver> no, they aren't
10:20:01 <nominolo> at least compared to ml
10:20:10 <quicksilver> :t \(a,b) -> 1
10:20:13 <lambdabot> forall t t1 t2. (Num t2) => (t, t1) -> t2
10:20:15 <emu> curried functions, tasty
10:20:18 <quicksilver> that wasn't curried
10:20:47 <quicksilver> \(a,b) -> 1 is a quite different type from \a b -> 1
10:20:53 <quicksilver> isomorphic, but different
10:20:57 <nominolo> you mean you decide yourself by using the correct syntax?
10:20:59 <quicksilver> the type system can tell them apart
10:21:06 <quicksilver> and it never 'implicitly' moves from one to the other
10:21:16 <quicksilver> right
10:21:36 <nominolo> ok, then it's just common style
10:21:45 * quicksilver nods
10:22:13 <quicksilver> what I think is true is that 'optional parameters don't work well for languages where functions are, by convention, curried'
10:22:27 * nominolo nods
10:22:39 <quicksilver> and certainly a massive percentage of the standard library functions are curried: basically all except a few which are specificaly to do with tuple manipulation
10:23:07 <quicksilver> bakert: you could use tuples as the basis for a typeclass, though
10:23:19 <quicksilver> bakert: class HttpGet a where httpGet :: a -> IO String
10:23:21 <bakert> that definitely sounds complicated.
10:23:36 <quicksilver> bakert: instance HttpGet Address (that's your basic example)
10:23:44 <quicksilver> instance HttpGet (Address,[Header])
10:23:52 <quicksilver> instance HttpGet (Anything,Else,You,Fancy)
10:24:01 <bakert> ooh.  that's quite cool.
10:24:33 <bakert> there's a Request type in Network.Browser.  I'm verging on recreating it if I do that.
10:24:44 <quicksilver> I haven't looked at that
10:24:44 <bakert> hmmm.
10:24:48 <quicksilver> maybe it's similar
10:25:02 <bakert> perhaps.
10:25:22 <bakert> i'm not sure i think i'll just have an explicit parameter and some pointless empty lists dotted about.
10:25:22 <nominolo> hm, would it be bad too have the new-and-improved HTTP lib be incompatible to the current one?
10:25:40 <kc5tja> emu: It's funny that we got involved with regexes today -- I had to help 4 employees with their regexes so far.  :D
10:25:45 <kc5tja> Fate is against me.
10:25:59 <quicksilver> bakert: personally I'm quite happy with differently named functions
10:26:04 <quicksilver> bakert: httpGet for the basic one
10:26:06 <nominolo> this is almost unavoidable if we fix error handling and string type
10:26:10 <quicksilver> bakert: httpGetH for the with-headers one
10:26:23 <bakert> quicksilver, you think so?  that's what I have at the moment.
10:26:29 <bakert> so it's easiest to do!
10:26:45 <bakert> although i definitely can't can't call it postFormReferer like it is at the moment.  Yuk!
10:26:50 <nominolo> you can also just take a single request object
10:26:59 <nominolo> and have different ways to construct it
10:27:12 <ddarius> @oldwiki UsingRecords
10:27:12 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
10:27:29 <bakert> true.
10:27:39 <nominolo> so, httpGet :: Request -> IO Response
10:27:58 <bakert> that's actually what my convenience methods do after a fashion (i have get, post and postForm which all construct request objects and pass them through to doRequest)
10:28:19 <quicksilver> nominolo: that is (very slightly) more verbose though
10:28:22 <bakert> but i like the simplicity of 'get "http://www.google.com/"'
10:28:29 <quicksilver> nominolo: since you need the constructor functions
10:28:37 <quicksilver> nominolo: I think bakert is looking for a really concise interface
10:28:38 <bakert> and postForm "http://google.com/search" [("q", "hello")]
10:28:40 <lambdabot> Title: Google
10:28:59 <nominolo> quicksilver: yep.  the type-class approach might be quite cool
10:29:10 <nominolo> quicksilver: good for show-off blog-posts
10:29:26 <bakert> And now it is getting more complicated.  Beyond a certain point the complicatedness means I should just scrap my little skinny layer and use the Http.Browser stuff directly
10:29:37 <quicksilver> HSH uses type-classes for complex overloading
10:29:47 <quicksilver> I have mixed feelings about that approach myself :)
10:29:47 <bakert> But I think I can get away with one more parameter on postForm or one more postFormH method before I give up!
10:29:52 <nominolo> @where HSH
10:29:52 <lambdabot> http://software.complete.org/hsh
10:30:17 <bakert> that looks confusing.  but possibly quite fun.
10:31:06 <quicksilver> agreed
10:32:00 <bakert> thanks for all your help folks.  very hard to learn the idiomatic approach in isolation so much appreciated.
10:32:54 <shapr> nominolo: Yeah, QuickCheck can be used with IO functions...
10:33:07 <shapr> nominolo: Have you read the second QuickCheck paper on monadic testing?
10:33:33 <shapr> nominolo: As sjanssen said, many people just use unsafePerformIO for the "run" function in QuickCheckM
10:33:47 <therp> hm.. I guess this is becoming the shortest scheme compiler ever..
10:34:00 <nominolo> shapr: second quickcheck paper?
10:34:05 <shapr> nominolo: But if you have the time and interest, there's a pre-release version of QuickCheck2 out, and it has lots of interesting and new features.
10:34:09 * nominolo goes paper-hunting
10:34:12 <ddarius> (compile (read))
10:34:14 <shapr> nominolo: Yeah, there are at least two.
10:34:25 <nominolo> shapr: i already use QC2
10:34:25 <shapr> nominolo: You could probably include the Erlang QuickCheck paper in that list as well.
10:34:30 <nominolo> but the doc could be better :)
10:34:35 <shapr> nominolo: Did you know that there's a commercial Erlang version of QC?
10:34:49 <shapr> nominolo: Ah, arbetar du på Chalmers redan?
10:34:52 <nominolo> shapr: yes, John told me so :)
10:34:54 <shapr> haha
10:35:03 <nominolo> shapr: jag studerar där
10:35:04 <shapr> So you probably know all about quviq, etc.
10:35:10 * shapr switches to utf-8
10:35:23 <bringert> nominolo: I think koen is writing a QuickCheck 2 tutorial
10:35:24 <Adamant> is QuickCheck basically a fuzzer?
10:35:32 <shapr> nominolo: I wrote a test-driven-development hack of QC1
10:35:38 <shapr> Adamant: No, but it has been used as such...
10:35:44 <shapr> Adamant: It's a fuzzer's wet dream.
10:35:49 <nominolo> shapr: nice
10:35:56 <shapr> QC is the ultimate fuzzing framework.
10:35:56 <nominolo> what's a "fuzzer"?
10:36:03 <shapr> @google fuzzer protocol
10:36:06 <lambdabot> http://www.securiteam.com/tools/5TP012AHFU.html
10:36:16 <Adamant> nominolo, bug hunting tool for finding bugs in software programs
10:36:21 <Adamant> usually security related
10:36:45 <nominolo> is that what they used for the months of the kernel bugs?
10:36:52 <shapr> Yeah, you through random and possibly protocol-illegal messages at an implementation. That's how the Oulu guys found the xdrlib/asn.1 bug for example.
10:36:56 <shapr> throw*
10:37:15 <Adamant> basically, it spits structured or semi-structured random values at an app's input, then you wait for the crash and investigate
10:37:15 <shapr> The PROTOS tool from Oulu is way cool.
10:37:29 <Adamant> nominolo, it was probably one of the tools used.
10:37:51 * nominolo likes QC a lot, but still uses it too little
10:38:47 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1050
10:38:57 <Adamant> actually, now that I remember it was definitely one of the tools used.
10:40:02 <Adamant> shapr, that tool is a heck of a lot of work
10:40:20 <sjanssen> @check \x y -> x * (y :: Integer) == y * x
10:40:21 <lambdabot>  OK, passed 500 tests.
10:40:21 <nominolo> hm, adding tests to a haskell program living almost completely in the IO monad is no fun :/
10:40:23 <Adamant> I mean, it was a lot of work to make it.
10:40:33 <ddarius> @google EXE: Automatically Generating Inputs of Death
10:40:35 <lambdabot> http://www.stanford.edu/~engler/exe-ccs-06.pdf
10:40:46 <bringert> nominolo: why is there so much IO?
10:41:02 <nominolo> i guess magnus wanted to get done quickly
10:41:08 <nominolo> and he used IORefs
10:41:14 <nominolo> a lot
10:41:30 <sjanssen> nominolo: global IORefs?
10:41:36 <nominolo> yep
10:41:41 * sjanssen shudder
10:41:47 * nominolo nods
10:41:52 <ddarius> @check \x y -> x * (y :: Float) == y * x
10:41:53 <lambdabot>  OK, passed 500 tests.
10:42:13 <ddarius> @scheck \x y -> x * (y :: Float) == y * x
10:42:15 <lambdabot>   Completed 6241 test(s) without failure.
10:42:40 <sjanssen> @check \x -> (x + 1) - x == (1 :: Float)
10:42:41 <lambdabot>  Falsifiable, after 62 tests: 3.8333333
10:43:10 <bringert> @check \x -> 1 / (x :: Double)
10:43:10 <lambdabot>   add an instance declaration for (Testable Double)     In the expression: le...
10:43:22 <bringert> oops
10:43:37 <vincenz> @check \x -> x > 10000000 >== x > 10000000
10:43:37 <lambdabot>   Not in scope: `>=='
10:43:43 <vincenz> @check \x -> x > 10000000 ==> x > 10000000
10:43:44 <lambdabot>  Add a type signature
10:43:45 <bringert> @check \x -> x / (x :: Double) == 1
10:43:47 <lambdabot>  Falsifiable, after 2 tests: 0.0
10:43:51 <vincenz> @check \x -> x > 10000000 ==> (x ::Int) > 10000000
10:43:52 <lambdabot>  Arguments exhausted after 0 tests.
10:43:58 <vincenz> hehe
10:44:06 <bringert> @check \x -> x / (x :: Int) == 1
10:44:07 <lambdabot>   add an instance declaration for (Fractional Int)
10:44:14 <bringert> dammit
10:44:16 <cjeris> any Coq heads in the house ?
10:44:18 <vincenz> @check insane bringert
10:44:19 <lambdabot>   Not in scope: `bringert'
10:44:20 <bringert>  @check \x -> x `div` (x :: Int) == 1
10:44:27 <int-e> @check \x -> x /= 0 ==> x / (x :: Double) == 1
10:44:28 <lambdabot>  OK, passed 500 tests.
10:44:37 <bringert> @check \x -> x `div` (x :: Int) == 1
10:44:38 <lambdabot>  Exception: divide by zero
10:44:49 <bringert> that's what I wanted to provoke
10:44:59 <nominolo> @ho [e] -> MArray a i e
10:44:59 <lambdabot> Maybe you meant: hoogle hoogle+ . bf echo ft ghc id pl rc show v wn yow
10:45:05 <nominolo> @hoogle [e] -> MArray a i e
10:45:06 <lambdabot> No matches, try a more general search
10:45:09 <bringert> QuickCheck 1 does not handle exceptions gracefully
10:45:32 <sjanssen> nominolo: there aren't any functions with that type
10:45:40 <sjanssen> @type Data.Array.MArray.newListArray
10:45:41 <jyasskin> Where is QuickCheck2 hiding? http://www.cs.chalmers.se/~rjmh/QuickCheck/ doesn't mention it.
10:45:42 <lambdabot> forall i e (m :: * -> *) (a :: * -> * -> *). (Ix i, Data.Array.Base.MArray a e m) => (i, i) -> [e] -> m (a i e)
10:45:43 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
10:45:55 <arke> hmm
10:46:01 <arke> does Prelude include some sort of Complex datatype?
10:46:06 <bringert> http://www.cs.chalmers.se/~bringert/darcs/QuickCheck/
10:46:07 <lambdabot> Title: Index of /~bringert/darcs/QuickCheck
10:46:11 <sjanssen> arke: it's in Data.Complex
10:46:16 <arke> ah, thx
10:46:34 <nominolo> sjanssen: thanks
10:46:46 <bringert> jyasskin that was for you
10:46:52 <jyasskin> bringert: thanks!
10:53:20 * vincenz wishes for destructuring typefunctions
10:53:25 <vincenz> Anyone know if there is such a thing?
10:53:50 <nominolo> Data.Typable?
10:53:56 <vincenz> at the typelevel
10:54:15 <vincenz> ok, here is a structuring one
10:54:23 <vincenz> data Tuple a b = Tuple a bb...
10:54:24 <nominolo> ok, i don't really understand what you are asking for ;)
10:54:26 <vincenz> forget about the datacons
10:54:32 <vincenz> now I want to be able to do
10:55:05 <vincenz> data MyEither atuple = Either (LeftSide atuple) (RightSide atuple)
10:56:32 <JoshTriplett> vincenz: Seems like the ideal syntax for that would look something like "data MyEither (Tuple a b) = Either a b"
10:56:42 <vincenz> JoshTriplett: yeah
10:56:59 <vincenz> the issue s that I have to pass 4 extra parameters to my GADT
10:57:02 <vincenz> and it already has 2 params
10:57:05 <vincenz> that' sgonna be 6 params
10:57:09 <vincenz> and buttugly
10:57:28 <sjanssen> vincenz: associated type's can do some of this
10:57:38 <vincenz> sjanssen: how?
10:57:45 <Saizan> uhm, i've some problem with irssi in a konsole on xmonad, alt-n changes xmonad's desktop instead of irssi's channel
10:58:10 <vincenz> sjanssen: ctrl+n
10:58:17 <vincenz> erm Saizan even, damn tabcomplete
10:59:16 <sjanssen> Saizan: xmonad doesn't use alt+n
10:59:33 <vincenz> sjanssen: how do I use associated types?
10:59:37 <Saizan> sjanssen: err., for alt-n i mean alt-1 alt-2 etc..
11:00:01 <vincenz> Saizan: /window 1
11:00:02 <sjanssen> vincenz: they're only partially implemented in ghc head
11:00:10 <vincenz> damn :/
11:00:16 <vincenz> seems like a rather bvious thing tho
11:00:19 <sjanssen> Saizan: you can change xmonad's bindings, see keys in Main.hs
11:00:26 <vincenz> you have datacons, and datadecons (patterns)
11:00:33 <vincenz> so you have tycons, and you need tydecons
11:00:53 <Saizan> sjassen: i'll see
11:01:08 <sjanssen> vincenz: associated types are much more general than that
11:01:15 <vincenz> sjanssen: ooh neat :)
11:01:46 <vincenz> sjanssen: I bet they don't mingle well with GADTS ?
11:02:05 <ndm> nothing does...
11:02:21 <vincenz> ndm: yes yes, play all the way
11:02:40 <xerox> Saizan: esc and then #
11:03:01 <nominolo> vincenz: but note, that there seem to be some bugs when using records with associated types
11:03:03 * vincenz sighs as he expands his parameters to his GADTS from 2 to 6
11:03:13 <vincenz> nominolo: idem GADT and records
11:03:14 <ndm> vincenz: i was more meaning type checking and compositionality etc.
11:03:25 <vincenz> ndm: I meant that you're biased :)
11:03:35 <ndm> i use haskell, of course i'm biased
11:03:40 <chessguy> is a GADT just an algebraic data type?
11:03:49 <ndm> chessguy: no, it has fancy type stuff with it
11:03:52 <hpaste>  sjanssen pasted "vincenz's problem with ATs" at http://hpaste.org/1051
11:04:36 <vincenz> sjanssen: nice
11:04:41 <vincenz> hmm
11:04:43 <vincenz> is this syntax allowed
11:04:52 <vincenz> data Foo a b :: * -> * -> * where
11:04:57 <vincenz> (aka define some but not all params)
11:04:57 <chessguy> are they H98?
11:04:57 <nominolo> vincenz: you need ghc 6.7 though
11:05:11 <vincenz> so Foo is a tycons of 4 params
11:05:28 <nominolo> vincenz: should be possible
11:05:28 <JoshTriplett> sjanssen: So associated types just give you the ability to say "class ... where type ..." and "instance ... where type ..."?  That seems really useful.
11:05:44 <nominolo> though i guess the current implementation does only support * atm
11:05:52 <arke> gah
11:05:59 <sjanssen> JoshTriplett: also class .. where data ...
11:06:00 <arke> type errors are killing me >_<
11:06:12 <JoshTriplett> sjanssen: Whoa.
11:06:17 <ndm> chessguy: reall really not
11:06:30 <sjanssen> JoshTriplett: they're a really nice alternative to fundeps
11:06:37 <JoshTriplett> sjanssen: Yeah, I like them better already.
11:07:30 <sjanssen> JoshTriplett: you should read Chakravarty's papers on associated types, they have some nice examples
11:07:33 <SamB> I'm still waiting for "class ... where type ..."
11:07:42 <SamB> so someone can port MTL to use ATs
11:07:46 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/1050#a1
11:07:55 <arke> argh
11:07:58 <arke> whats wrong with
11:08:05 <JoshTriplett> SamB: sjanssen's example seemed to do exactly that.
11:08:07 <arke> mandelbrot :: Complex -> Complex -> Int -> Complex
11:08:09 <SamB> glguy: what happened to disallowing that?
11:08:11 <arke> >_<
11:08:17 <SamB> JoshTriplett: maybe it doesn't work yet?
11:08:19 <sjanssen> JoshTriplett: they're not quite implemented in ghc yet
11:08:28 <SamB> the syntax is there.
11:08:33 <JoshTriplett> sjanssen: Ah.
11:08:34 <SamB> but nothing else is, yet.
11:08:42 <SamB> so, you get really wierd type errors
11:08:47 <sjanssen> associated data types are mostly complete, but associated type synonyms are quite a way off
11:08:58 <vincenz> I guess you can do it but you don't gain much
11:09:29 <vincenz> I guess you can do it but you don't gain much
11:09:47 <hpaste>  vincenz pasted "would be nice" at http://hpaste.org/1052
11:10:13 <vincenz> nominolo: btw, the partial naming works fine
11:10:31 <JoshTriplett> sjanssen: "synonyms"?
11:10:32 <hpaste>  vincenz annotated "would be nice" with "(no title)" at http://hpaste.org/1052#a1
11:10:45 <nominolo> vincenz: are you referring to my bug-report?
11:10:49 <vincenz> nominolo: no?
11:10:52 <sjanssen> JoshTriplett: "type" declarations are known as type synonyms
11:11:02 <JoshTriplett> sjanssen: Ah.
11:11:44 <nominolo> vincenz: http://hackage.haskell.org/trac/ghc/ticket/1204
11:11:46 <lambdabot> Title: #1204 (Associated types don't work with record updates) - GHC - Trac
11:11:55 <vincenz> nominolo: that's not a record
11:12:09 <chessguy> sjanssen, wouldn't bata declarations be considered types too?
11:12:18 <chessguy> s/bata/data/
11:12:28 <nominolo> vincenz: what is it then?
11:12:35 <vincenz> nominolo: a GADT
11:12:48 <vincenz> in my paste that is
11:12:52 <SamB> chessguy: notice the quotation marks
11:13:23 <sjanssen> chessguy: "type" and "data" are different beasts
11:13:37 <SamB> hmm.
11:13:43 <chessguy> sjanssen, yes, but both are type declarations of some kind, right?
11:14:27 <vincenz> back to my typechecker
11:14:28 <sjanssen> chessguy: sure, but they're not both "synonyms"
11:14:54 <chessguy> the "type" keyword renames an existing type, whereas the "data" keyword tells how to construct a new type
11:14:58 <nominolo> vincenz: no, i meant that declaring  "type Foo a b :: * -> * -> *" for an AT might not work (yet)
11:15:04 <chessguy> yes, i think i just misunderstood what you were saying
11:15:16 <vincenz> nominolo: oh, different usecase
11:16:01 <nominolo> vincenz: yes.  and i didn't even test it.  i just seem to remember reading a bug report about this.
11:17:35 <chessguy> are GADTs haskell-98?
11:17:49 <nominolo> chessguy: no
11:17:55 <chessguy> ok
11:22:36 <Botje> right.
11:22:44 * Botje sets aside two hours for his #haskell-cafe backlog
11:22:48 <Botje> 1300 mails :/
11:22:59 <jmelesky> yeah, traffic is huge there lately
11:23:36 <Botje> is there a haskell-newbies list too?
11:23:48 * nominolo has 2400+
11:23:48 <therp> yes, my little neat 163 line scheme _compiler_ works.
11:23:55 <jmelesky> not sure. i thought that was part of the point of haskell-cafe
11:24:13 <Botje> therp: shiny. will you blagging about it?
11:24:16 <jmelesky> also, enough traffic for a newbies list might imply that haskell is succeeding
11:24:46 <therp> botje: blogging? :) sure. I have to teach it a bit of R5RS first.
11:25:00 <Botje> it also means there's going to be people doing awful things to haskell
11:25:01 <therp> also my schememonad doesn't know dynamic variables..
11:26:19 <therp> botje: are you refering to me with your awful things statement?
11:27:10 <JoshTriplett> therp: That sounds interesting.  So you have a scheme parser and a scheme monad?
11:27:31 <therp> joshtriplett: not at all. this is another proof of concept for Liskell
11:28:00 <JoshTriplett> therp: I meant "have" in a vague sense. :)
11:29:52 <therp> joshtriplett: well don't expect too much. it compiles stuff like ((lambda (x) 1 (set! x 10) x) 2)) correctly
11:29:55 <Botje> therp: no..
11:30:09 <therp> botje: ah ok :)
11:30:10 <Botje> therp: I was thinking more along the lines of advocating unrestricted use of unsafePerformIO
11:30:27 <Botje> and other un-niceties
11:30:48 <shapr> Adamant: Yeah, PROTOS is a lot of work for fuzzing, but QuickCheck would remove almost all of the boilerplate work.
11:31:07 <quicksilver> why can't I make instances for tuples?
11:31:32 <sjanssen> quicksilver: you can
11:31:32 <therp> damn, I'm way too fast with my todo list. hmm, shall I write a paper for ICFP07?
11:31:49 <quicksilver> sjanssen: I get this kind of error
11:31:52 <xerox> therp: turn everything off and go partying!
11:32:03 <quicksilver> sjanssen:  Illegal instance declaration for `HttpGet (Int, Int)'
11:32:08 <Adamant> gah. start working caffiene
11:32:12 <sjanssen> quicksilver: turn on -fglasgow-exts
11:32:14 <therp> "Embedded Dependent Type Systems in Liskell" would make a nice ICFP07 topic
11:32:19 * mbishop shakes Adamant 
11:32:22 <therp> xerox: ahhh no! I'm a workaholic.
11:32:24 <quicksilver> sjanssen: ah!
11:32:31 <quicksilver> sjanssen: why does H98 not permit it?
11:32:56 <sjanssen> quicksilver: Haskell '98 says that every type applied to a type constructor must be a variable
11:33:02 <sjanssen> (in an instance that is)
11:33:33 <quicksilver> sjanssen: yes, I see that in the spec. Do you know what the motivation is?
11:33:53 <sjanssen> something about overlapping instances.  I'm not really sure
11:33:56 * shapr rattles and rolls Adamant 
11:33:59 <sjanssen> it bugs the heck out of me too
11:36:44 <quicksilver> sjanssen: hmm it seems to bug out the inferrer, too
11:37:05 <quicksilver> sjanssen: at least, it can't choose the (Int,Int) instance for  (1,2)
11:37:46 <sjanssen> quicksilver: that's numeric defaulting at work
11:39:28 <JoshTriplett> therp: I just read your page on liskell; looks fun.  I had a question on the last example, scalar-multiply.  Could you write (let ((p x) (* s x)) ...) as something like (let (p (* s)) ...) ?  Do you (or do you plan to) support partial application?
11:40:27 <therp> joshtripple: yes that's possible. it's haskell underneath (but you on both example you miss a level of parenthesis for the let bindings)
11:40:43 <therp> -you +s..
11:41:48 <JoshTriplett> therp: Possible currently, or possible later?
11:41:57 <therp> currently
11:44:19 <JoshTriplett> therp: So, assuming some outer binding for s, the syntax (let ((p (* s))) (p 5)) should work?  And, for that matter, the syntax ((* s) 5)?
11:44:46 <therp> joshtriplett: yes, this works (currently)
11:45:01 * SamB wonders how the _NET_WM_PID window property is usually set
11:45:57 <therp> samb: I presume the toolkit do that http://mail.gnome.org/archives/gtk-devel-list/2001-October/msg00204.html ?
11:45:58 <lambdabot> Title: _NET_WM_PID support, http://tinyurl.com/2ejm74
11:46:31 <quicksilver> sjanssen: it's not just defaulting though
11:46:58 <quicksilver> sjanssen: in general you can't compose a polymorphic-in-input function with a polymorphic-in0output function without a type annotation
11:47:05 <quicksilver> sjanssen: even if there is only one possible type
11:47:33 <quicksilver> sjanssen: I suppose this is inevitable given the open world  aziom
11:49:37 <quicksilver>  what I was wondering about, is if this harms compositionality in the big picture
11:49:44 <shapr> sjanssen: Oh hey, I get reproducible crashes with xmonad and vnc
11:50:13 <shapr> sjanssen: Still not sure exactly why or what, but Lemmih and I were pair programming last night and we got two crashes in a row when he tried to write to my emacs.
11:50:34 <sjanssen> hmm
11:50:39 <vincenz> shapr: how do you pairprogram?
11:50:47 <shapr> vincenz: x11vnc and skype
11:51:01 <shapr> I'd like to try gtalk for voip instead, but I can't find a deb.
11:51:21 <vincenz> shapr: not screen and an editor inside of it
11:51:25 <shapr> nope
11:51:32 <mbishop> Backus is dead...that seems so weird
11:51:37 <shapr> vincenz: I've tried that before, it's not that exciting.
11:51:39 <shapr> mbishop: Yeh, sad :-(
11:52:16 <sjanssen> shapr: have you seen xmonad's tiling support yet?
11:52:21 <vincenz> shapr: not exciting in what sense?
11:52:29 <shapr> sjanssen: No! I gotta pull patches and rebuild it!
11:52:43 <SamB> @hoogle getpid
11:52:43 <lambdabot> No matches found
11:52:57 <sjanssen> shapr: you probably need to rebuild X11-extras too
11:53:16 <sjanssen> SamB: the posix lib has different names for all the functions
11:53:25 <shapr> (Lemmih: Hiya vincenz. This is what makes pair programming exciting)
11:53:57 <shapr> vincenz: Yeah, part of the problem is that screen lets you interact with the same text-based session, but vnc lets you interact with everything on that person's screen.
11:54:08 <shapr> Not all of my programming happens inside of emacs.
11:54:14 <vincenz> example?
11:54:29 <shapr> I also use an xterm for building, my browser for looking up stuff, and instant messengers to ask questions.
11:54:32 <sjanssen> shapr/Lemmih: rm -rf ~ makes things _really_ exciting :P
11:54:37 <Nafai> shapr: Didn't we try pair programming once via screen?
11:54:43 <shapr> sjanssen: I don't want that much excitement thanks...
11:54:45 <shapr> Nafai: Yes!
11:54:51 <vincenz> shapr: besides watching each other's porn
11:54:52 <shapr> Nafai: Long ago when I was a Pythonista..
11:54:54 <SamB> sjanssen: ah.
11:54:56 <Nafai> shapr: :)
11:54:58 <shapr> vincenz: Er..
11:55:06 <shapr> vincenz: I do have a lot of unusual research papers...
11:55:06 <Nafai> I've done pair programming via nx client and skype
11:55:24 <quicksilver> if all you want to do is use emacs, you can just use make-frame-on-display
11:55:31 <vincenz> `ap` tired
11:56:34 <newsham> how many haskell phd types end up in industry doing haskell type work?
11:57:13 <newsham> do most stay in academia?  do most end up doing non-haskell work?
11:58:13 <vincenz> newsham >>= augustss
11:58:32 <Botje> is this your idea of bondage and discipline, vincenz ?
11:58:37 <newsham> ?seen augustss
11:58:37 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
11:59:10 <newsham> could not instantiate augustss at line [08:53]
11:59:27 <SamB> @doc Graphics.X11.Xlib
11:59:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/X11/Graphics-X11-Xlib.html
11:59:53 <sjanssen> SamB: I don't suppose you're hacking on xmonad?
12:00:19 <SamB> well, I'm trying to get it to show up by name in xrestop...
12:11:22 <SamB> sjanssen: apparantly, to do this I'd need the functions in XGetWindowProperty(3X11)
12:12:41 <sjanssen> SamB: xmonad doesn't allocate any windows
12:12:53 <SamB> sjanssen: not yet, no.
12:13:13 <SamB> but I'd need to make a dummy window to hold the PID
12:13:26 <sjanssen> oh
12:13:52 <SamB> xrestop makes a dummy window, too, but inexplicably does not actually set the property...
12:14:26 <SamB> (well, actually it is not inexplicable. I can easily explain it as a case of being too lazy.)
12:15:13 <sjanssen> what are the advantages of doing all this?
12:15:34 <SamB> well, presumably somone is going to want these functions for something anyway
12:15:59 <SamB> as for why would we want to make a window and store our pid in it?
12:16:12 <sjanssen> yeah, what's the point
12:16:31 <sjanssen> xrestop isn't going to show any interesting information, AFAICT
12:17:40 <SamB> yes, but it is kinda disconcerting to see those "unknown" entries in the list...
12:18:22 * SamB wonders what xterm is doing with 8 bytes of pixmap
12:18:36 <chessguy> ?hoogle Gen
12:18:36 <lambdabot> Test.QuickCheck.Gen :: data Gen a
12:18:36 <lambdabot> Distribution.Extension.Generics :: Extension
12:18:36 <lambdabot> Data.Generics.Aliases.Generic' :: Generic c -> Generic' c
12:18:47 <chessguy> @type Test.QuickCheck.Gen
12:18:49 <lambdabot>     Not in scope: data constructor `Test.QuickCheck.Gen'
12:18:50 <monochrom> Yippee!  Oleg did not dispute my answer (to the question on fixed points)!  He only added more. :)
12:19:12 <chessguy> what is this Gen dataype in Test.QuickCheck?
12:19:32 <SamB> apparantly, xmonad owns 57 Miscs
12:19:43 <shapr> chessguy: It's a PRNG monad.
12:19:59 <shapr> It lets you pass around a random number source, split it, etc safely.
12:20:08 <chessguy> from System.Random?
12:20:17 <shapr> Er, I think it uses System.Random
12:20:18 <xerox> monochrom++
12:20:24 <SamB> ooh, I made a new window and now it shows 58 Miscs
12:20:26 <monochrom> hehe
12:20:28 <chessguy> but where is it defined?
12:21:06 <monochrom> Many years of not doing my thesis (but rather spending time on lattices and CPOs) pays off! XD
12:21:06 <SamB> ooh
12:21:06 <shapr> chessguy: I think it's define in the QC source, but I'm not positive of that.
12:21:18 <SamB> now I have a grand total of 32 bytes of pixmaps!
12:21:19 * xerox laughs
12:21:35 * SamB has four xterms running under xmonad
12:21:41 <sjanssen> SamB: does it go away when you kill the window?
12:21:44 <SamB> (well, under Xephyr really)
12:21:52 <SamB> yes
12:22:11 <chessguy> shapr, i don't get it, it's exported there as Gen           -- :: * -> * ; Functor, Monad, but not defined
12:22:40 <shapr> Speaking of which, is there some way to sew TAGS tables together in a top level file?
12:22:43 <shapr> There must be...
12:23:49 <sjanssen> shapr: I think you can just concatenate
12:23:52 <shapr> oh
12:24:00 <shapr> I'd rather refer to subtable with a referenc
12:24:05 <chessguy> ?seen allbery_b
12:24:05 <lambdabot> allbery_b is in #perl6, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard allbery_b speak 35m 11s ago.
12:24:16 <SamB> shapr: -i option to etags?
12:24:17 <shapr> Basically, I want to be able to use M-. to jump to something defined in another darcs repo.
12:24:33 <chessguy> allbery_b, around?
12:24:36 <shapr> I guess the various tags programs won't understand Haskel imports though.
12:24:42 <quicksilver> you could just re-run etags with all the files at once
12:25:12 <quicksilver> but I don't think threre is a way to 'cleverly choose from sub TAGS-tables'
12:25:21 <quicksilver> I've wondered that myself before and not found one
12:25:32 <shapr> Sounds like hasktags needs to do that.
12:25:40 <malsyned> printf doesn't support * in the precision!  is there an (easy) workaround?
12:26:10 <monochrom> construct the string first.
12:26:39 <monochrom> printf ("hello %" ++ show 10 ++ "d") 20
12:26:45 <malsyned> er, right.  my panic has subsided and that has become obvious to me.
12:26:49 <malsyned> thanks!
12:26:52 <monochrom> Hey, nested printf!
12:27:03 <quicksilver> I find printf ratehr unhaskell-like, if you're just using it for floats I'd be incined to do something like
12:27:16 <monochrom> printf (printf "hello %%%dd" 10) 20  -- XD
12:27:36 <xerox> monochrom: I've tried fountain pens. Awesome experience, if not used with old paper which sucks all the ink out. Have to find a good one now.
12:28:05 <monochrom> C introduces * because the above two methods are too cumbersome in C.
12:28:19 <monochrom> xerox: nice
12:28:31 <quicksilver> let formatFloat a b n = sprintf ("%"++(show a)++"."++(show b)++"f")  in ...
12:28:41 <malsyned> quicksilver: well, given a floating-point number and a number of decimal points, what's a more haskell-y way to create a string with that number of decimal points, and no dot at all if the argument is 0?
12:29:08 <malsyned> quicksilver: no such thing as sprintf.  printf is polymorphic.
12:29:22 <quicksilver> you take my point though :)
12:29:47 <quicksilver> there is also sometihng like ShowEFloat and showFFloat
12:29:47 <quicksilver> I forget the names
12:31:21 <malsyned> Yeah, showFFloat is what I want.  now if only I knew what to do with ShowS.
12:31:48 <monochrom> Moral of the story: every time you see a convenient feature, especially in a poor language, think twice --- it may be there so as to cover up a bigger impotence.
12:32:29 <malsyned> monochrom: typically, it's there to cover up lack of garbage collection.  although that's not perl's excuse.
12:34:33 <monochrom> Perl's excuse is probably "it's in C, and I'm sure it's there for a good reason, why would you ever doubt K&R?" :)
12:34:46 <malsyned> haha, right :)
12:35:43 <monochrom> Lots of these things are about heritage, about copying old wisdom without re-thinking.
12:36:31 <chessguy> @hoogle sized
12:36:32 <lambdabot> Test.QuickCheck.sized :: (Int -> Gen a) -> Gen a
12:37:56 <monochrom> If you ask me, I still agree "%*d" is good, not because other people did it (though I must thank them for inventing it), but because "%*d" is probably still clearer than both methods I suggested.  Also, there is no extra difficult implementing it in Haskell.
12:38:17 <malsyned> right.  * is supported for field widths, just not for precisions.
12:38:27 <malsyned> anyway, showFFloat already does what I need.
12:38:34 <malsyned> hey, does haskell have list slicing?
12:39:05 <JoshTriplett> malsyned: You mean things like "every nth element"?
12:39:19 <monochrom> I forgot list slicing. what is it?
12:39:52 <monochrom> splitAt 4 "hello of the world, unite!"
12:41:02 <malsyned> it's just a convenient syntax for subsequences.  Python has something like listvar[3..6]
12:41:29 <malsyned> which gives you the list made of elements 3, 4, and 5 of listvar.
12:41:37 <monochrom> you have to combine "take" and "drop".
12:41:58 <monochrom> and a subtraction :)
12:42:48 * JoshTriplett tries to remember if Haskell has a function for the extended slices, such as listvar[::2]
12:43:17 <malsyned> monochrom: yeah.  slice is easy to implement in terms of those.
12:43:59 <monochrom> what is listvar[::2]?
12:44:18 <JoshTriplett> [1,2,3,4,5][::2] gives [1,3,5]
12:44:24 <JoshTriplett> monochrom: Every nth element.
12:44:39 <JoshTriplett> monochrom: [start:end+1:step]
12:45:01 <monochrom> This one is more interesting! :)
12:45:12 <malsyned> ooh, so listvar[3:6:] would be python-style slicing?
12:45:19 <malsyned> does this actually exist in Haskell?
12:45:42 <JoshTriplett> malsyned: No, I just wrote Python syntax, like you did...
12:45:45 <int-e> > map head . takeWhile (not . null) . iterate (drop 3) $ [1..5]
12:45:46 <lambdabot>  [1,4]
12:46:06 <JoshTriplett> int-e: iterate drop; that makes sense.
12:47:02 <nominolo> > let start = 1; step = 2, end = 10 in [start,start+step..end]
12:47:02 <lambdabot>  Parse error
12:47:10 <nominolo> > let start = 1; step = 2; end = 10 in [start,start+step..end]
12:47:11 <lambdabot>  [1,3,5,7,9]
12:47:32 <JoshTriplett> nominolo: Hmmm, good point.  You could use that combined with a function to give you the items for matching indices.
12:50:32 <dmwit> "Haskel has its own oddity that makes me screem sometimes in the middle of the night."
12:50:50 <mikeman> hey guys, I've got a question...
12:51:17 <chessguy> mikeman, wait! don't tell us! lambdabot has a new @crystalball feature
12:51:27 <mikeman> why is it that when I write "func = \x -> x+x" and take the type of func like ":t func", I get "Integer->Integer"? Why Integer and not Num?
12:51:46 <sjanssen> mikeman: it is called the monomorphism restriction and we all hate it
12:51:59 <int-e> mikeman: two features in combination, the monomorphism restriction and defaulting for Num
12:52:19 <shapr> dmwit: What's that from?
12:52:38 <mikeman> ah thanks, now at least I have some words I can search for :)
12:52:53 <dmwit> shapr: http://ipeev.blogspot.com/2007/03/solving-mrs-and-mrp-puzzle-by-john.html
12:52:55 <lambdabot> Title: Ivan Peev blog: Solving the "Mr.S and Mr.P" puzzle by John McCarthy in Python, http://tinyurl.com/2ch7jb
12:53:01 <SamB> mikeman: always nice ;-)
12:53:11 <int-e> mikeman: in any case you can get around that by providing your own type signature
12:53:26 <dmwit> shapr: It made me chuckle. =)
12:53:53 <int-e> mikeman: or by writing  func x = x+x  instead, to which the m.r. doesn't apply.
12:54:17 <mikeman> yeah, the weird part is that if I wrote :t (\x->x+x) I got Num, but not when I stored the lambda into a variable
12:55:46 <monochrom> When you store into a variable, you suffer from the monomorphism restriction plus defaulting.  A concrete type is picked for you, and you're stuck with it.
12:56:46 <monochrom> Of course, :t doesn't suffer from that restriction.
12:57:02 <monochrom> And damn, everything I say has been said. :)
12:57:24 * monochrom looks for something new to say.
12:58:04 <drigz> how do i use lambdabot to see the pointsfree version of a function?
12:58:24 <cddar> is "(f.g) x" equal to "f (g x)"?
12:58:25 <dmwit> ?pl \x -> x + x
12:58:25 <lambdabot> join (+)
12:58:45 <dmwit> cddar: Yep.
12:58:49 <nominolo> ?check (f . g) x == f (g x)
12:58:50 <lambdabot>   Not in scope: `x'
12:58:57 <nominolo> ?check \x f g -> (f . g) x == f (g x)
12:58:57 <JoshTriplett> :type join
12:58:57 <lambdabot>  Add a type signature
12:59:05 <JoshTriplett> @type join
12:59:05 <drigz> dmwit: thanks
12:59:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:59:12 <dmwit> cddar: So is "f $ g x".
12:59:14 <cddar> how about "(f.g) x y" and " f (g x y)" ??
12:59:24 <dmwit> cddar: No, it only applies to one argument.
12:59:36 <dmwit> But "f $ g x y = f (g x y)".
12:59:41 <monochrom> (f.g) x y = f (g x) y
12:59:51 <stepcut> poor implementation of slice:
12:59:54 <stepcut> > let  slice str slices = map fst $ filter (flip elem slices  . snd) (zip str [0..]) in slice ['a'..'z'] [1,3..10]
12:59:55 <lambdabot>  "bdfhj"
12:59:55 <JoshTriplett> monochrom: Which I seem to always get wrong...
12:59:56 <dmwit> ?pl \x y -> f $ g x y
12:59:56 <lambdabot> (f .) . g
13:00:06 <cddar> ok that was my question and "$" is the answer i wanted. thanks
13:00:40 <monochrom> If you put more parentheses it's easier.  (f.g) x y = ((f.g) x) y) = (f (g x)) y
13:01:05 <monochrom> Try to calculate!  Try not to intuit...
13:01:25 <cddar> monochrom, thanks.
13:01:44 <chessguy> heh. now this is an interesting argument for leaving off type signatures: "...the inclusion of explicit type signatures just entail [sic] extra maintenance work [sic] when the library is changed. For example, when a type is renamed or a function is made more general, an arbitrary number of type signatures may need to be updated."
13:01:45 <monochrom> (You can safely intuit after you have gone through millions of calculations and reached the level of 1 Oleg.)
13:02:03 <vincenz> Anyone familiar with VB?
13:02:08 <vincenz> Apparently there's two versions
13:02:11 <vincenz> an easy one and a difficult one
13:02:16 <vincenz> anyone know anything in regards to this?
13:02:42 <dmwit> > let slice str slices = map (str !!) slices in slice ['a'..'z'] [1,3..10]
13:02:43 <lambdabot>  "bdfhj"
13:02:55 <stepcut> > let slice str slices = map (str !!) slices in slice ['a'..'d']
13:02:56 <lambdabot>  <[Int] -> [Char]>
13:02:58 <chessguy> is it just me or is that a really lousy argument?
13:03:00 <doserj> > let slice xs idxs = map ($ xs) (map (flip (!!)) idxs) in slice [100..120] [1,3..10]
13:03:01 <lambdabot>  [101,103,105,107,109]
13:03:44 <monochrom> It is lousy because the speaker must have not heard of "re-factoring tools" e.g. renaming variables occuring a million times over ten thousand files is trivial.
13:03:51 <stepcut> the !! version will throw an exception if a slice index is greater than the length of the list -- whether that is a feature or bug is up to you ;)
13:04:02 <dmwit> Aha.
13:04:30 <drigz> how to i declare the type for a function declared in where?
13:04:49 <monochrom> in the same where.
13:05:02 <dmwit> drigz: As long as it doesn't require any of the same type variables as the function including the where.
13:05:11 <drigz> is there a way to do it on the same line?
13:05:16 <stepcut> chessguy: if you have to change *just* the type signatures, doesn't that imply your signatures where not as general as the could have been in the first place ?
13:05:28 <int-e> chessguy: it's a lousy argument. if true, the types of that library weren't well designed.
13:05:50 <stepcut> chessguy: unless they mean just renaming types...
13:06:19 <drigz> will there be a way to write a Miller-Rabin primality test without sprinkling IO everywhere in my program?
13:06:26 <chessguy> beats me. i think it's just a dumb argument
13:06:50 <int-e> @type randoms
13:06:52 <Fusionist> Hello guys
13:06:52 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
13:06:57 <dmwit> Definitely!  Especially if it doesn't do IO.
13:07:00 <chessguy> it comes from http://www.cs.chalmers.se/~hallgren/Thesis/haskell-comments.html , with regards to the Fudgets library
13:07:01 <lambdabot> Title: HacWrite - 40 Comments on Haskell and other language design issues
13:07:19 <Fusionist> does any1 in here use metasploit??
13:07:20 <drigz> so should will i have to keep passing a RandomGen around through the code?
13:07:24 <int-e> drigz: sure. you only need one random number for each iteration. the iteration can be pure and the loop around it can be pure as well, taking a list of random numbers as input
13:07:38 <int-e> drigz: or a RandomGen, your pick
13:08:04 <monochrom> My take is, similar things happen in OOP all the time, type sigs or not.  You have a class.  Now you make it more general.  Now you turn a local variable into a field.  Now you re-arrange methods. ...  Are these arguments against OOP?  Absolutely not, you use refactoring tools.  Why should "change type" and "generalize function" be different?
13:08:10 <drigz> can someone point me to something about hiding impure code away?
13:09:06 <SamB> monochrom: well, the fact that they cause type errors is a nice thing
13:09:17 <Fusionist> no1 uses metasploit?...
13:09:18 <Fusionist> :(((
13:09:22 <monochrom> Perhaps there is profit in arguing against programming at all "because you have to change the code all the time".
13:09:34 <SamB> heh
13:09:44 <monochrom> (Why not just buy and use slaves?)
13:09:47 <chessguy> monochrom, lol
13:10:01 * chessguy is tempted to @remember that
13:10:07 <int-e> drigz: hmm, hide away? just try to keep it to a minimum in the first place.
13:10:17 <SamB> couldn't you just have the slaves do the programming?
13:10:37 <drigz> i was under the impression that you have a wrapper around the impure stuff so that it doesn't filter up making everything that uses it impure
13:10:39 <glguy> SamB: what do they do instead?
13:11:02 <monochrom> or have the slaves transport files for you from SPJ's home to your home.  no need for a HTTP library.
13:11:23 <xerox> .oO( Johnny Mnemonic )
13:11:37 <sjanssen> @google metasploit
13:11:39 <lambdabot> http://www.metasploit.com/
13:11:40 <lambdabot> Title: The Metasploit Project
13:12:00 <drigz> int-e: it seems to me that i'll have to put IOs in the expmod procedure because it's using numbers that came from the Random
13:12:01 <SamB> monochrom: is this the same logic by which you would eat off of a slave rather than wasting good money on tables?
13:12:28 <monochrom> That depends on how many idling slaves you have.
13:12:38 <sjanssen> Fusionist: this is not a security channel
13:12:41 <monochrom> But yes!
13:12:47 <Fusionist> :(
13:12:52 <SamB> monochrom: well, yeah
13:12:58 <Fusionist> i can't get an exploit on metasploit to work :(
13:13:02 <Fusionist> this suxorz
13:13:02 * sjanssen sighs
13:13:06 <dmwit> drigz: Why not write a function that takes a random generator, creates a list of random numbers, and calls your subroutine with that list?
13:13:10 <monochrom> Fusionist: just use a slave. :)
13:13:18 <sjanssen> we don't even have 'hack' in the topic any more!
13:13:22 <Fusionist> a slave computer?
13:13:30 <monochrom> a slave monkey
13:13:36 <dmwit> ?quote hack
13:13:36 <lambdabot> dylan says: everything's a hack. the world's a hack.
13:13:41 <sjanssen> @girl19
13:13:41 <lambdabot> I'm in Moscow, Russia
13:13:43 <SamB> "The language of ICFP winners 3 years running" ... yeah, there is no "hack" in there
13:13:58 <dmwit> Wasn't there one like, "I have a different definition of 'hack' than you"?
13:14:01 <dmwit> ?quote hack
13:14:01 <lambdabot> robreim says: I'm in your base hacking all your lambdas
13:14:12 <Fusionist> a slave monkey?
13:14:15 <Fusionist> = slave computer?
13:14:17 <monochrom> ?quote 'hack'
13:14:17 <lambdabot> No quotes match. My pet ferret can type better than you!
13:14:22 <monochrom> ?quote "hack"
13:14:22 <lambdabot> No quotes match. That's something I cannot allow to happen.
13:14:28 <SamB> ?quote \bhack\b
13:14:28 <lambdabot> No quotes match. The more you drive -- the dumber you get.
13:14:33 <Fusionist> @quote metasploit
13:14:34 <lambdabot> No quotes match. Where did you learn to type?
13:14:40 <monochrom> Hahahah
13:14:40 <sjanssen> Fusionist: are you here to discuss the Haskell programming language?
13:14:42 <SamB> ?quote \shack\s
13:14:43 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
13:15:05 <SamB> ?quote hack
13:15:05 <lambdabot> dons says: ihope reaches level 4 hacker
13:15:13 <SamB> hmm.
13:15:18 <dmwit> Oh, it's on the quotes page.
13:15:23 <SamB> oh.
13:15:40 <drigz> dmwit: i think i would be able to do it by creating a RandomGen at the start, and then using iterate or something to get the numbers, but i was wondering if there was a way to do it without having to keep track of the generator, but being able to use the global random generator and get rid of the impurity somehow
13:15:42 <Fusionist> yes...
13:15:48 <dmwit> <Speck> I think we have different working definitions of "hack"
13:15:57 <Fusionist> do u guys know ay irc channels for metasploit?
13:16:02 <Fusionist> so i can go bugg them instead
13:16:16 <dmwit> ?hoogle randoms
13:16:16 <lambdabot> Random.randoms :: (Random a, RandomGen b) => b -> [a]
13:16:16 <lambdabot> System.Random.randoms :: (Random a, RandomGen g) => g -> [a]
13:16:50 <dmwit> drigz: Like that?
13:17:48 <drigz> dmwit: if i use that, but call it twice, they're going to either return the same list or have IO right?
13:18:18 <dmwit> By referential transparency, if you pass it the same random generator, you'll get the same list back. ;-)
13:18:27 <SamB> drigz: in this case, you have to pass in an RNG state
13:23:30 <drigz> ok, i think i have what i need, thanks!
13:23:51 <dadaism> @seen sorear
13:23:51 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc, #haskell and #happs 16h 27m 2s ago, and .
13:24:00 <dadaism> @seen dons
13:24:00 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 8h 33m 18s ago.
13:24:12 <dadaism> @seen nmessenger
13:24:12 <lambdabot> I saw nmessenger leaving #haskell 1d 12h 37m 1s ago, and .
13:26:12 <sjanssen> @seen dadaism
13:26:12 <lambdabot> I saw dadaism leaving #haskell 1m 48s ago, and .
13:27:12 <dmwit> ", and ."?
13:30:03 <malsyned> is there any way to get ghci to load all non-erroneous definitions from a file if some definitions can't pass the type-checker or are wrong for some other reason?
13:30:22 <dmwit> You could comment them out temporarily.
13:30:46 <malsyned> dmwit: that's what I've been doing.
13:31:00 <malsyned> it's tedious, error-prone, and (seems to me to be) easy enough to infer programatically.
13:31:01 <dmwit> GHCi probably doesn't have a really great way of telling which of two functions is wrong if one depends on the other but doesn't type check.
13:31:14 <asl> hello!  I'm new to haskell, and I'm having trouble getting useful error messages out of programs compiled with ghc
13:31:22 <dmwit> Is it the one that doesn't type check, or the other one, which if changed to a different type, would allow the first to type check?
13:31:32 <asl> is there any way to get some sort of backtrace on an erro?
13:31:42 <glguy> Hay guys which is the bestest language to learn programming, Python or Ruby?
13:32:13 <sjanssen> @slap glguy
13:32:13 * lambdabot smacks glguy about with a large trout
13:32:30 <TSC> asl: Not easily, I believe
13:33:11 <sjanssen> glguy: did you see the dork asking for hacking advice earlier?
13:33:17 <asl> TSC:  boo.  I'm getting an "Error in array index" going on.  it's nice to know what went wrong, but it'd be nice to know in which function ^_^
13:33:22 <glguy> sjanssen: Fusionist ?
13:33:27 <sjanssen> yeah.
13:33:34 <dmwit> asl: It doesn't give you a line number?
13:33:41 <asl> dmwit: nope
13:33:44 <dmwit> asl: Is it a run-time or compile-time error?
13:33:49 <glguy> sjanssen: yeah, I did... I didn't bother directing him to #lame_script_kidcare
13:33:56 <asl> dmwit:  run-time
13:34:16 <dmwit> ?hoogle trace
13:34:17 <lambdabot> Debug.Trace.trace :: String -> a -> a
13:34:17 <lambdabot> Debug.Trace :: module
13:34:17 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
13:34:18 <sjanssen> asl: there's a trick with profiling.  compile with -prof -auto-all, and run your program with +RTS -xc
13:34:37 <asl> sjanssen: thanks.  I'll give that a try
13:34:39 <dmwit> (But prefer sjanssen's method to mine.)
13:34:39 <drigz> i think this channel responded to him in a more civilised way than any other channel i've been on would
13:35:13 <glguy> drigz: if I kicked everyone from the channel that I wanted to, they'd take my ops away!
13:35:59 <glguy> drigz: but the #haskell way is generally to correct ignorance with information (or silence)
13:36:18 <sjanssen> asl: http://www.cse.unsw.edu.au/~dons/loch.html is another option
13:36:18 <lambdabot> Title: LocH
13:37:10 <sjanssen> one more OT message and I would have kicked him
13:37:30 <hpaste>  asl pasted "(no title)" at http://hpaste.org/1055
13:37:56 <asl> sjanssen: using the flags you recommended has introduced exciting new build errors: http://hpaste.org/1055
13:38:07 <hpaste> I'd appreciate if everyone could please bother to put titles on their pastes
13:38:17 <dmwit> Haha.
13:38:20 <asl> sjanssen: but I think this may be related to the borked install of ghc that ubuntu leaves me with
13:38:22 <dmwit> asl: Try ghc --make ?
13:38:37 <sjanssen> asl: as the message says you don't have profiling libs for haskell98
13:38:56 <sjanssen> asl: use System.IO instead of IO
13:39:12 <Igloo> asl: Try installing ghc6-prof
13:39:13 <asl> sjanssen: I'll look after both.  thanks for your help
13:39:43 <shapr> glguy: Though people who will not allow themselves to be corrected are sometimes shot.
13:40:11 <Philippa> in the foot. Repeatedly. With their own gun.
13:40:19 <drigz> this seems like the kind of question i should be able to google, but is there a debugger for Haskell?
13:40:35 <sjanssen> Philippa: yes, to make it look like an accident
13:40:55 <dmwit> drigz: There is Hat, though I've never gotten that to work.
13:40:59 <shapr> sjanssen: Or just hand them unsafe* and tell them to use those to solve their problems.
13:41:10 <shapr> In that case, you can save the effort of shooting them, for they will do it all by themselves!
13:41:32 <malcolmw> There is an SoC project proposal to revive Hat
13:41:39 <shapr> drigz: There are debuggers, but not many, and right now they don't do so much.
13:42:11 <shapr> drigz: I think most of that is that there's a cultural idea that it's better to understand your code piece by piece.
13:42:20 <shapr> Not everyone agrees with that, but I do think that way.
13:43:34 <monochrom> You are just writing a program. You are not creating a biological organism.
13:43:43 <dmwit> Gah, Google is not being helpful here.
13:43:50 <dmwit> What is golf, in the refactoring sense?
13:44:14 <Igloo> Trying to make the shortest program possible to do a given task
13:44:15 <monochrom> What this means is that you can actually educate yourself to have the program correct from the onstart, rather than needing testing and debugging and evolution and ...
13:44:46 <dmwit> Oh, so it's a negative practice...
13:45:38 <shapr> dmwit: It depends...
13:45:43 <drigz> dmwit: negative in that it's really fun :p
13:45:51 <shapr> dmwit: Sometimes you find clearer approaches.
13:45:57 <malcolmw> It is true that even the finest Haskell programmers occasionally create a bug that they really can't find by simple means
13:46:09 <dmwit> shapr: Okay, that's fair.
13:46:18 <chessguy> hmm, what's the most generalized structure in haskell whose values can have substructures which are also of the same type
13:46:19 <monochrom> OTOH if you have to follow a program written by an uneducated programmer, you probably need a debugger.
13:46:22 <shapr> dmwit: Also, there are obfuscated code contests... we have the winner of one IOHCC right here!
13:46:22 <malsyned> I find that occasionally, I thought I knew exactly what I was writing, but then it does something I didn't expect.  It's true that the solution to that is more education, but in that instance debuggers can be an excellent educational tool.
13:47:07 <malcolmw> We have always called Hat a tracer rather than a debugger, because its primary purpose is to reveal what the program is actually doing - education if you like
13:47:16 <monochrom> Yeah, debuggers should be limited to the classroom.
13:47:20 <shapr> dmwit: Sometime you just learn more stuff about the language you're using, and that's good too. But golf is not refactoring.
13:47:58 <chessguy> although proper understanding does tend to make your programs shorter
13:48:00 <chessguy> @quote melt
13:48:00 <lambdabot> dons says:  its like you can really see the guy's brain melting
13:48:05 <chessguy> @quote melt
13:48:05 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
13:48:09 <chessguy> there we go
13:48:13 <hpaste>  drigz pasted "broken permutation generator" at http://hpaste.org/1056
13:48:21 <malsyned> monochrom: having never taken a class in Haskell, the world is my classroom.  Drawing a sharp line between education and implementation is a cultural shift we're not likely to see in CS in our lifetime.  some people mourn that more sincerely than others.
13:48:24 <drigz> that code always returns []
13:48:43 <chessguy> drigz, x <- permuations xs
13:48:43 <dmwit> Base case should be [[]]
13:49:05 <chessguy> +t
13:49:18 <monochrom> the word "engineering" requires that line.
13:49:24 <drigz> dmwit: perfect, thanks!
13:49:45 <SamB> monochrom: why does it?
13:49:46 <dmwit> drigz: I made that bug my first three times, too. ;-)
13:50:01 <drigz> :D
13:50:43 <chessguy> ok, so what's the most generalized structure in haskell whose values can have substructures which are also of the same type
13:50:47 <SamB> well, I mean, you need some kind of line between people who are allowed to design bridges and people who aren't...
13:50:49 <dmwit> Looks like all the iohcc pages are kind of gone... =(
13:51:08 <dmwit> chessguy: Maybe?
13:51:14 <dmwit> Or isn't that what you meant?
13:51:19 <drigz> is there a better way of doing: reverse [1..9]?
13:51:31 <dmwit> > [9,8..1]
13:51:33 <lambdabot>  [9,8,7,6,5,4,3,2,1]
13:51:35 <monochrom> So, now it depends on what you view programming as.  If you are one of those who say "software engineering", you have to learn it and then do it right.  If you are one of those who say "software not engineering", you are entitled to "learn as you go".  I agree with both philosophy.  I just disagree that you can call yourself "engineering" and think you can legitimately trial-and-error too.
13:52:20 <chessguy> dmwit, i was looking for something more general, but i'm not really sure what i'm looking for.
13:52:26 <SamB> monochrom: well, I think you can legitimately trial-and-error, but you need to make sure not to "error" at the wrong time
13:52:31 <chessguy> @instances List
13:52:32 <lambdabot> Couldn't find class `List'. Try @instances-importing
13:52:48 <monochrom> trial-and-error is part of learning.
13:52:57 <malsyned> Jumping back and forth between engineering and learning is more possible in the engineering of computer programs and the engineering of bridges.  I don't mind that - I consider it a great feature.  However, far too many software "engineers" these days don't realize that they have to fully understand what they're program is doing before they can say they're "done" with it, no matter how much correct output it generates.
13:53:01 <glguy> chessguy: you are looking for something like Lisp's lists?
13:53:24 <malsyned> s/they're/their/
13:53:27 <monochrom> In engineering, you learn at your own cost.  You charge your customer for what you deliver, not what you learn.
13:53:45 <glguy> malsyned: I think that your use of they're was correct
13:53:56 <chessguy> glguy, no
13:53:57 <malsyned> glguy: "what they're program is doing"?
13:54:03 <SamB> monochrom: well yes...
13:54:07 <chessguy> i guess i need to think more about what i want
13:54:12 <glguy> malsyned: Ah, I'm looking at the last occurance
13:54:15 <glguy> occurence
13:54:15 <glguy>  :)
13:54:25 <malsyned> glguy: there was no /g flag ;)
13:54:51 <glguy> malsyned: when you write things that long, I only see the first and last few lines :)
13:55:08 <chessguy> like, for a list, any subset of a list is also a list. for a tree, any subset of a tree is also a tree, for a graph, or a map, or a lot of things
13:55:42 <malsyned> glguy: some day, I'll figure out how other people in channels manage to keep their thoughts so concise.
13:55:51 <glguy> k
13:55:56 <merus> gunzip.
13:56:01 <chessguy> malsyned, let me know when you do
13:56:33 <glguy> I want to go home and play Hitman: Blood Money
13:56:39 <chessguy> so are all (or most of) those things instances of a class?
13:57:03 <malsyned> chessguy: the class of types which are closed under a composition operation?
13:57:20 <chessguy> malsyned, that sounds right
13:57:33 <chessguy> what haskell typeclass is that?
13:57:45 <malsyned> damned if I know
13:57:48 <glguy> Monoid?
13:58:00 <chessguy> @instances-importing Monoid
13:58:01 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
13:58:04 <malsyned> from what I know of monoids, that sounds right.
13:58:09 <malsyned> but I don't know much.
13:58:13 <monochrom> "monoid" assumes the composition is associative, and has identity
13:58:17 <chessguy> heh. none of them are there
13:58:18 <dmwit> () is a pretty simple type.
13:58:45 <glguy> > [1,2,3] `mappend` [4,5,6]
13:58:47 <lambdabot>  [1,2,3,4,5,6]
13:59:01 <glguy> > [1,2,3] `mappend` mempty
13:59:02 <monochrom> If you have absolutely no assumption, just "a -> a -> a", I'm not sure it worths a typeclass :)
13:59:02 <shapr> I think software engineering is both science and engineering. I like the XP approach of "We can't design or understand something we've never built/written."
13:59:02 <lambdabot>  [1,2,3]
13:59:19 <chessguy> i guess i'm looking for something like Class Composable a where compose :: a -> a -> a
13:59:28 <glguy> ?src Monoid
13:59:28 <lambdabot> class Monoid a where
13:59:28 <lambdabot>     mempty  :: a
13:59:28 <lambdabot>     mappend :: a -> a -> a
13:59:28 <lambdabot>     mconcat :: [a] -> a
13:59:30 <shapr> And the answer there is, "First write a mostly working prototype of that thing for science, then you have the knowledge to do engineering."
13:59:54 <chessguy> hmmm
14:00:10 <malsyned> shapr: "Plan to throw one away.  You will anyway"  "You always build a prototype, whether you intended to or not"
14:00:28 <chessguy> isn't mconcat = foldr mempty (mappend)
14:00:37 <glguy> close
14:00:44 <malsyned> foldl?
14:00:50 <glguy> foldr mappend mempty?
14:00:50 <SamB> did they need a prototype for true(1)?
14:00:51 <sjanssen> foldr mappend mempty
14:00:59 <monochrom> I haven't seen much throwing-away in self-proclaimed "software engineering".
14:01:02 <chessguy> err, yeah
14:01:20 <malsyned> monochrom: and that's the problem.  but that doesn't mean we should be denied our debuggers while we're prototyping
14:01:23 <shapr> malsyned: Yeah, those are good quotes.
14:01:29 <SamB> monochrom: well, maybe the self-proclaimed software engineers are misnamed?
14:01:30 <drigz> will reverse be a lot faster than myreverse x:xs = (myreverse xs) ++ [x]?
14:01:38 <monochrom> Hehe, ok, yeah, debuggers are nice.
14:01:42 <glguy> drigz: yes
14:01:43 <sjanssen> drigz: yes
14:01:44 * monochrom pets the debugger
14:01:53 <shapr> malsyned: I'm still not convinced that debuggers are good practice.
14:02:00 <glguy> drigz: your implementation has O(n^2) time complexity
14:02:17 <monochrom> SamB: yes, it shows that the self-proclamation is wrong.
14:02:25 <chessguy> ?src reverse
14:02:25 <lambdabot> reverse = foldl (flip (:)) []
14:02:50 <SamB> shapr: it might depend on how they work
14:02:52 <drigz> glguy: is a ++ b O(length a)?
14:03:02 <shapr> SamB: How so?
14:03:05 <glguy> yeah
14:03:09 <dmwit> drigz: Check out http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/Exercises%20on%20List%20Recursion.htm
14:03:11 <lambdabot> Title: Exercises on List Recursion, http://tinyurl.com/222p5x
14:03:12 <mdmkolbe> ?hoogle Int -> Float
14:03:12 <lambdabot> No matches, try a more general search
14:03:13 <SamB> shapr: well, on what they do
14:03:17 <monochrom> There are also people who deserve to be called software engineers.  They do all the right things.
14:03:21 <dmwit> ?hoogle fromIntegral
14:03:22 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
14:04:03 <mdmkolbe> thx dmwit that was exactly what I needed
14:04:24 <dmwit> drigz: Note that on that page, reverse xs ++ ys === (reverse xs) ++ ys
14:04:25 <SamB> monochrom: you mean those folks who write the code for the space shuttle?
14:05:28 <monochrom> I don't know whether they do.
14:05:38 <drigz> ok, thanks
14:05:58 <drigz> BTW haskell doesn't have a built-in permutations fn, right?
14:06:02 <monochrom> Feynman's opinion is "yes".  But that was then.  Time changes.
14:06:22 <SamB> monochrom: well, they have a big book that says what the code is supposed to do
14:06:39 <dmwit> drigz: I don't think so.
14:08:49 <dmwit> :t (. reverse)
14:08:51 <lambdabot> forall c a. ([a] -> c) -> [a] -> c
14:12:31 <dmwit> Wow, this page considers fundeps to be a "finger exercise" (i.e. extremely easy)!
14:12:34 <drigz> my miller-rabin test seems a little over-zealous... it claims that 2 isn't prime...
14:14:31 <mdmkolbe> Any ideas why adding a reshapeCallback to my Graphics.UI.GLUT application makes the display stop updating?  (Probably an obsure problem, but if it's well known it would save me a few hours trimming my program to find the problem.)
14:14:42 <mdmkolbe> nm, I just found it
14:14:56 <malsyned> mdmkolbe: that was a quick few hours ;)
14:15:06 * mdmkolbe worships at the alter of brick wall debugging
14:16:00 <malsyned> mdmkolbe: wtf "brick wall debugging"?
14:16:25 <dmwit> Speaking to a brick wall often clears my head, too. =)
14:16:41 <malsyned> oh, I get it.
14:16:41 <dmwit> malsyned: It means he figured it out without having any input from other people...
14:16:55 <drigz> my teacher used to call it the cardboard programmer
14:17:09 <drigz> because he would just stand there while i explained the problem and then realised
14:17:14 <malsyned> well, now thanks to lambdabot's logging, Google will have a page with that definition.
14:17:32 <mdmkolbe> funnything is that I always need a live (though not nessisarily vocal) "brick wall"
14:17:47 <earthy> ah, the granny method
14:17:56 <earthy> useful, that
14:17:58 <drigz> never eat cake, eat salad sandwiches and remain young
14:18:20 <dmwit> ?
14:18:20 <drigz> i still think that out each time i have to write necessary
14:18:33 <dmwit> HA
14:18:38 <dmwit> Awesome.
14:18:57 * earthy always writes out  6 = 2 x 3  so 3 = 6 / 2 and 2 = 6 / 3
14:20:38 <shapr> drigz: Yeah, the original wiki calls it a cardboard consultant or cardboard programmer. There's a great quote on that page.. "Why is your lead developers talking to a cardboard wookie?"
14:21:15 <shapr> drigz: The LicensedPreludeExits has an excellent permutation function, just because a zillion people have asked for it on #haskell.
14:21:21 * malsyned always writes out VCR ==> V=C/R, C=VR, R=C/V.
14:22:20 * malsyned messed that up :|
14:22:27 <emu> hm, "brick wall" debugging is what i'd describe java debugging as
14:22:31 <glguy> V = CR
14:22:36 <emu> *smashing head into
14:22:43 <malsyned> yeah.  it was so easy I overthought it.
14:22:47 <mdmkolbe> ? LicensedPreludeExits
14:22:56 <glguy> and isn't it: V=IR ?
14:23:05 <dmwit> ?where LicensedPreludeExits
14:23:05 <lambdabot> I know nothing about licensedpreludeexits.
14:23:11 <dmwit> ?where LicensedPrelude
14:23:12 <lambdabot> I know nothing about licensedprelude.
14:23:20 <glguy> Exts
14:23:21 <xerox> yeah, in italy they suggest the phrase "Viva la Repubblica Italiana" to remember it.
14:23:23 <glguy> hot Exits
14:23:26 <dmwit> ?where LicensedPreludeExts
14:23:27 <lambdabot> I know nothing about licensedpreludeexts.
14:23:29 <malsyned> it is, but VIR doesn't stand for anything.
14:23:50 <dmwit> Cool, got it.
14:24:04 <mdmkolbe> new quote for lambdabot: "I know nothiiing."
14:24:17 <mdmkolbe> malsyned: It's "man" in latin
14:24:43 <dmwit> :t outer
14:24:45 <lambdabot> Not in scope: `outer'
14:24:46 <Sgeo> @get-shapr
14:24:46 <lambdabot> shapr!!
14:24:50 <shapr> Sgeo: You screamt?
14:24:54 <malsyned> mdmkolbe: cool.  Now all I have to do is learn Latin and I'll never be confused reading circuit diagrams again!
14:25:07 <shapr> Sgeo: Do I know you? I probably should if I don't.
14:25:12 * Sgeo found a command called 'get-shapr' in lambdabot's code
14:25:17 <xerox> @get-shapr
14:25:17 <lambdabot> shapr!!
14:25:20 <shapr> xerox: Hiya!
14:25:25 <dmwit> ?get-xerox
14:25:25 <lambdabot> Unknown command, try @list
14:25:27 <shapr> Sgeo: Yes, it's specifically designed to summon me!
14:25:31 <kaol> ?losers
14:25:31 <lambdabot> Maximum users seen in #haskell: 336, currently: 330 (98.2%), active: 57 (17.3%)
14:25:33 <xerox> hi shaper.
14:25:39 <shapr> Hi copy-man!
14:25:50 <Sgeo> @dummy
14:25:51 <lambdabot> dummy
14:26:08 <dmwit> shapr: Well, it looks like it works pretty well!
14:26:10 <mauke> @eval uate
14:26:24 <dmwit> ?eval [1..10]
14:26:26 <shapr> Sgeo: The Dummy module started out as a quick demo of the dynamic code reloading capabilities in lambdabot.
14:26:35 <dmwit> ?help eval
14:26:35 <lambdabot> eval. Do nothing (perversely)
14:26:49 <sjanssen> heh
14:26:57 <sjanssen> @eval 10
14:27:18 <dmwit> Is that a reference to the "man :" page?  I'm going to go with yes.
14:27:29 <shapr> Eval was originally ddarius' lambda calculus interpreter (close enough to Hasell to confuse many), and then later hs-plugins' eval command, but it was soo confusing it got removed, I think.
14:27:37 * mdmkolbe4 gives his wireless a hug ... of death
14:27:45 <Sgeo> I just called @get-shapr in a different chatroom, and shapr didn't come
14:27:46 <Sgeo> >.>
14:27:55 <shapr> Sgeo: Sorry, it's context depedent.
14:28:05 <shapr> Requires that you have a shapr in context...
14:28:30 <mdmkolbe4> can lambdabot learn? (e.g. canned answers for common questions)
14:28:36 <mauke> IIRC @eval clashed with the perl6 bot
14:29:03 <Sgeo> @faq
14:29:03 <lambdabot> The answer is: Yes! Haskell can do that.
14:29:28 <Sgeo> My question: Can Haskell solve the halting problem?
14:29:35 <Sgeo> @faq
14:29:35 <lambdabot> The answer is: Yes! Haskell can do that.
14:29:36 <mauke> @keal
14:29:36 <lambdabot> bot seems useless
14:29:48 <malsyned> @quote halting
14:29:48 <lambdabot> No quotes match. The more you drive -- the dumber you get.
14:29:58 <dmwit> ?quote protontorpedo
14:29:58 <lambdabot> No quotes match. Are you on drugs?
14:29:59 <vincenz> lol
14:30:03 <vincenz> @protontorpedo
14:30:03 <lambdabot> some dude called topmind says that oo is bs
14:30:08 <vincenz> @protontorpedo
14:30:08 <lambdabot> is it fun to program in haskell?
14:30:10 <vincenz> @protontorpedo
14:30:11 <lambdabot> its bs dude
14:30:15 <dmwit> ?proton
14:30:16 <lambdabot> and haskell is general purpose?
14:30:26 <vincenz> @prot
14:30:26 <lambdabot> so given that how does haskell let one turn business calcualtion anreocrding of info into somethng liek a big spreadsheet?
14:30:48 <cjeris> was this person serious?
14:30:56 <vincenz> cjeris: this person was calvino
14:31:09 <vincenz> the longterm lame-Q asker of cls (comp.lang.scheme)
14:31:16 <vincenz> cjeris: he's done this in plural channels under different nicks
14:31:23 <vincenz> always asking lame Qs, prolly to start flamewars
14:31:37 <vincenz> cjeris: and he asked the same types of questions for 6 months straight,  ask dons
14:31:55 <vincenz> unless he has serious mental handicaps, I doubt he was serious
14:32:07 <mauke> he's appeared in #perl as ramserver, shemale_magic, big-ego-guy, star-trekio, merlyns_undersdy, dreamgirl_pakin, evilgod99
14:32:33 <vincenz> mauke: and in #squeak
14:32:48 <vincenz> and prolly god knows where else
14:33:25 <dmwit> I like his nick-fu.
14:33:36 <cjeris> oh dear.  i had a very obtuse conversation with one evilgod99 in #math a while ago.  i guess he got me.
14:34:25 <shapr> He has to change nicks... otherwise people would never speak to him.
14:35:12 <mauke> watch out for ids: n=gschuett, n=bo, n=g; hosts: pool-71-106-168-30.lsanca.dsl-w.verizon.net, 208.201.11.51, 4.38.41.141
14:35:33 <vincenz> mauke: he's calvino, right
14:35:33 <vincenz> ?
14:35:42 <mauke> no idea
14:35:48 <mauke> I don't read cls
14:35:52 <vincenz> someone in #scheme said something ot that extent
14:35:56 <vincenz> you wonder what motivates him
14:35:59 <shapr> Other exciting people include Thaddeus L. Olczyck, Brian J. Van Every, rahul the common lisper, and some others that don't come to mind.
14:36:08 <vincenz> shapr: ken tilton?
14:36:15 <vincenz> shapr: smerdy?
14:36:29 <mauke> ITYM Brandon J.
14:36:30 <shapr> Smerdyakov is similar, but in a different class because he produces real useful research even if he's impossible in a community sense.
14:36:36 <shapr> mauke: Yes, sorry
14:36:39 <shapr> Brandon J. Van Every
14:37:00 <shapr> vincenz: I've only heard of Ken Tilton, haven't interacted with him myself.
14:37:12 <vincenz> shapr: nor I, but his cls postings just drip
14:37:45 <vincenz> what about this brandon person?
14:37:55 <mauke> he's a wanker
14:38:00 <vincenz> whre?
14:38:02 <vincenz> +e
14:38:07 <balodja> hi. which monad manual do you advise? i'm reading yaht now, and i feel lack of theoretical basis
14:38:37 <vincenz> shapr: the thaddeus person looks ok from a random google and reading a ng post
14:39:01 <mauke> http://lambda-the-ultimate.org/user/2284/track
14:39:03 <lambdabot> Title: Brandon J Van Every | Lambda the Ultimate
14:39:22 <dmwit> ?go you could have invented monads
14:39:24 <mauke> he's everywhere :/
14:39:24 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
14:39:24 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
14:39:34 * mdmkolbe3 bear hugs his wireless ... to death
14:39:46 <dmwit> balodja: How theoretical do you want to get?
14:40:13 <dmwit> ?go all about monads
14:40:15 <lambdabot> http://www.sampou.org/haskell/a-a-monads/html/
14:40:16 <lambdabot> Title: All About Monads
14:40:26 <vincenz> mauke: I meant that thaddeus person
14:40:37 <balodja> dmwit: first of all, i want to know the sources of "monad rules"
14:40:39 <vincenz> I have a partially interesting person..
14:41:07 <dmwit> balodja: Mmmm... most just definition.
14:41:50 <mdmkolbe3> balodja: first, which monad rules (Haskell people use a group fo three, but category people use a group of two)?  Second, by source do you mean why we invented them or how they get put into the program?
14:43:09 <Cheery> How do I turn Int to !Word16 ?
14:43:23 <glguy> toEnum?
14:43:23 <Cheery> or at least pretend it so?
14:44:02 <dmwit> > fromIntegral 32 :: Word16
14:44:04 <lambdabot>  32
14:44:28 * mdmkolbe6 has run out of ways to kill his wireless
14:44:30 <Philippa> shapr: I wouldn't have thought Brandon's ever actually shown up here?
14:44:36 <glguy> > toEnum 32 :: Word16
14:44:37 <lambdabot>  32
14:44:47 <shapr> Philippa: Nope, but I've interacted with him elsewhere.
14:44:56 <dmwit> toEnum is shorter.
14:45:11 <JoshTriplett> dmwit: Though somewhat less idiomatic.
14:45:13 <Cheery> what does happen there?
14:45:34 <JoshTriplett> Cheery: instance Word16 Enum
14:45:53 <JoshTriplett> Cheery: Conceptually, data Word16 = 0 | 1 | 2 | ...
14:45:58 <balodja> mdmkolbe: of course i'm talking about haskell(category ones would be useful too, just for aquaintance). and firstly i'm planning to use them in programming :)
14:46:17 <Cheery> aah.
14:46:19 <dmwit> ?src Monad
14:46:20 <lambdabot> class  Monad m  where
14:46:20 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:46:20 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:46:21 <lambdabot>     return      :: a -> m a
14:46:25 <lambdabot>     fail        :: String -> m a
14:46:39 <vincenz> @pl liftM2 f m1 m2 = m2 >>= \x1 -> m2 >>= \x2 -> return (f x1 x2)
14:46:39 <lambdabot> liftM2 = const . ap (>>=) . flip . (fmap .)
14:46:52 <Cheery> going to sleep, gn.
14:48:00 <dmwit> ?go monad laws
14:48:02 <lambdabot> http://etymon.blogspot.com/2006/09/monad-laws.html
14:48:02 <lambdabot> Title: Etymon: The Monad Laws
14:49:17 <vincenz> @src unsafePerformIO
14:49:17 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
14:55:13 <glguy> ASCII stupid questions, get stupid ANSI
14:58:58 <vincenz> flow: the insanity coders call peace
15:02:10 <dmwit> Hit any user to continue.
15:02:38 <dmwit> ?yow
15:02:38 <lambdabot> All of a sudden, I want to THROW OVER my promising ACTING CAREER, grow
15:02:39 <lambdabot> a LONG BLACK BEARD and wear a BASEBALL HAT!! ...  Although I don't know
15:02:39 <lambdabot> WHY!!
15:02:50 <dmwit> ?quote
15:02:50 <lambdabot> skew says: I think blackdog is right
15:03:08 <dmwit> ?yow
15:03:08 <lambdabot> Is a tattoo real, like a curb or a battleship?  Or are we suffering in
15:03:09 <lambdabot> Safeway?
15:04:04 <dmwit> ?quote sarahbot
15:04:04 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
15:05:07 <vincenz> @keal
15:05:07 <lambdabot> i can explain why something is without knowing what the rules decided by man are
15:05:22 <vincenz> @hoogle when
15:05:23 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
15:05:23 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
15:06:31 <dmwit> ?quote non-terminating
15:06:32 <lambdabot> kzm says: I therefore propose that all functions should either be of type '() -> ()', or non-terminating.
15:06:47 <vincenz> @quote semantics
15:06:48 <lambdabot> xxd says: but 90% of programming is semantics
15:06:59 * vincenz worries about the other 10%
15:08:01 <a-priori> the other 10% is communicating your semantics to the computer
15:08:12 <a-priori> i.e, syntax
15:08:40 <vincenz> opinions vary :)
15:08:46 <a-priori> I know :)
15:08:53 <a-priori> I'd peg it at far less than 10%
15:08:53 <dmwit> ?quote wine
15:08:54 <lambdabot> kolmodin says: it's nice to have static types after a bottle of wine
15:08:56 <vincenz> again, opinions vary
15:08:58 <vincenz> on the I know bit
15:09:02 <vincenz> :P
15:09:09 <vincenz> jk
15:09:13 <vincenz> @quote denotati
15:09:13 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
15:10:43 <a-priori> heh
15:10:49 <mux> dcoutts: around?
15:10:56 <dons> moin
15:11:02 <dcoutts> @arr!
15:11:03 <lambdabot> Arrr!
15:11:10 <dcoutts> hia mux, any luck ?
15:11:10 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:11:19 <mux> dcoutts: read your messages :-)
15:11:24 <dcoutts> @yarr!
15:11:24 <mux> there's a patch for you there
15:11:24 <lambdabot> Get out o' me way, yeh landlubber
15:11:39 <shapr> hiya dcoutts!
15:11:46 <vincenz> dcoutts: how's it down undah
15:11:47 <dcoutts> hay shapr
15:11:50 <mux> plz commit k thx! ;-)
15:11:57 <dcoutts> vincenz: nice :-)
15:12:07 <dcoutts> mux: right'o
15:12:18 <vincenz> hunt fer crocs yeaht?
15:12:24 <dcoutts> hah
15:12:31 <mux> dcoutts: is the patch okay?
15:13:38 <dcoutts> mux: you don't like using darcs and getting credit in the Changelog ?
15:13:59 * vincenz hahs as he introduces his brother to vim to get him hooked
15:15:10 <mux> dcoutts: I think I'm just used to the FreeBSD way - people send patches, we commit'em with a note in the commit log
15:15:17 <dcoutts> mux: looks fine to me
15:15:19 <mux> dcoutts: but if you want, I can darcs send it
15:15:23 <dcoutts> mux: darcs is our commit log
15:15:40 <dcoutts> mux: if you're going to darcs send then perhaps change the name of one function slightly..
15:15:49 <dcoutts> colorSelectionDialogGetColorsel -> colorSelectionDialogGetColor
15:15:58 <mux> sure thing
15:16:01 <vincenz> dcoutts: gtk2hs works with 6.6?
15:16:08 <dcoutts> vincenz: yep
15:16:11 <vincenz> nifty
15:16:25 <dcoutts> and in ghci :-)
15:16:35 <vincenz> @where gtk2hs
15:16:35 <lambdabot> http://haskell.org/gtk2hs/
15:16:41 <dcoutts> (so long as you don't forkIO)
15:17:16 * vincenz nods
15:17:41 <mux> (dang, I'll have to fix my sendmail now)
15:18:00 <sorear> hello.
15:18:37 <mux> dcoutts: just a quick build-test after the rename and I darcs send this
15:18:46 <dcoutts> mux: ok
15:19:07 <dcoutts> mux: btw, if you don't want to fix sendmail, use darcs send --output thingy.patch
15:19:19 <mux> that's ok, it actually works here
15:19:24 <dcoutts> and attach the file in an email, or post it on the web
15:19:34 <mux> ...now that my sendmail binary is postfix
15:20:42 <dmwit> ?quote VerityStob
15:20:43 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
15:21:13 <Saizan> condescension?
15:21:19 <vincenz> long desc sitting hurts the knees :/
15:23:47 <vincenz> s/desc/desk
15:24:35 <Sgeo> @help compose
15:24:35 <lambdabot> . <cmd1> <cmd2> [args].
15:24:36 <lambdabot> . [or compose] is the composition of two plugins
15:24:36 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
15:24:57 <Sgeo> composition.. of plugins?
15:25:16 <mux> yeah
15:25:17 <Sgeo> @help elite
15:25:17 <lambdabot> elite <phrase>. Translate English to elitespeak
15:25:24 <dmwit> ?. djinn type flip
15:25:26 <lambdabot> f a b c = a c b
15:25:50 <Sgeo> @help djinn
15:25:50 <lambdabot> djinn <type>.
15:25:51 <lambdabot> Generates Haskell code from a type.
15:25:51 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
15:26:20 <mux> @. elite figlet hello
15:26:20 <lambdabot> cOuLDN't RuN THE fi9|Et (O/\/\MAnD.
15:26:26 <mux> bleh
15:26:29 <mux> dons: install figlet :-)
15:26:50 <Sgeo> @djinn (a->b)->b->a
15:26:50 <lambdabot> -- f cannot be realized.
15:27:08 <Sgeo> @djinn a -> IO a
15:27:08 <lambdabot> -- f cannot be realized.
15:27:13 <Sgeo> ..
15:27:19 <dmwit> ?djinn (a -> b) -> [a] -> [b]
15:27:19 <lambdabot> -- f cannot be realized.
15:27:32 <dmwit> :t map
15:27:34 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:27:35 <mux> @. hoogle elite map
15:27:36 <lambdabot> Data.Map :: module
15:27:36 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
15:27:36 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
15:27:59 <Sgeo> ?djinn forall a b. (a -> b) -> [a] -> [b]
15:27:59 <lambdabot> -- f cannot be realized.
15:28:09 <dmwit> Huh.
15:28:37 <dmwit> ?djinn (a -> b) -> (b -> c) -> a -> c
15:28:37 <lambdabot> f a b c = b (a c)
15:28:54 <dmead> > let x = "me" in "ya mamma"
15:28:55 <lambdabot>  "ya mamma"
15:29:16 <Sgeo> > let x = undefined in 1+1
15:29:17 <lambdabot>  2
15:29:22 <Sgeo> > let x = undefined in x+1
15:29:24 <lambdabot>  Undefined
15:29:36 <Sgeo> ?djinn a
15:29:37 <lambdabot> -- f cannot be realized.
15:29:39 <dmwit> > let x = "me" in x >> "ya mamma "
15:29:40 <lambdabot>  "ya mamma ya mamma "
15:30:11 <mauke> > "lol" >> "wut"
15:30:13 <lambdabot>  "wutwutwut"
15:30:31 <Sgeo> @type (>>)
15:30:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
15:30:40 <jyasskin> ?djinn (a -> b) -> [a] -> [b]
15:30:40 <lambdabot> -- f cannot be realized.
15:30:51 <jyasskin> weird
15:30:58 <mauke> djinn doesn't understand lists
15:31:13 <sorear> understanding lists is hard
15:31:22 <sorear> any non-flat domain
15:31:45 <Sgeo> I guess it doesn't do monads?
15:31:49 <sorear> if theorem provers like djinn were much better at all, mathematicians would be out of work :)
15:31:55 <ddarius> Can djinn handle rank-2 types?
15:31:58 <Sgeo> @djinn a -> Maybe a
15:31:58 <lambdabot> f = Just
15:32:04 <sorear> Sgeo: it doesn't do type classes or rank-2
15:32:12 <Sgeo> rank-2?
15:32:17 <sorear> but it can handle monadic operations:
15:32:22 <Sgeo> @djinn Maybe a -> a
15:32:22 <lambdabot> -- f cannot be realized.
15:32:46 <sorear> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))  -- state's >>=
15:32:46 <lambdabot> Cannot parse command
15:32:49 <sorear> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))  -- state's >>=
15:32:50 <lambdabot> Cannot parse command
15:32:53 <sorear> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
15:32:53 <lambdabot> f a b c =
15:32:54 <lambdabot>     case a c of
15:32:54 <lambdabot>     (d, e) -> b d e
15:32:59 <dmwit> ?djinn (Monad m) => a -> m a
15:33:00 <lambdabot> Cannot parse command
15:33:03 --- mode: irc.freenode.net set +o ChanServ
15:33:07 <sorear> dmwit: no type classes! :)
15:33:08 <Sgeo> @djinn Maybe a -> ( a -> Maybe a) -> Maybe a
15:33:09 <lambdabot> f a b =
15:33:09 <lambdabot>     case a of
15:33:09 <lambdabot>     Nothing -> Nothing
15:33:09 <lambdabot>     Just c -> b c
15:33:24 <sjanssen> hmm, I wonder what djinn could do with data List a = forall b. List ((a -> b -> b) -> b -> b)
15:33:42 <sorear> sjanssen: not much
15:33:50 <sorear> sjanssen: the forall will kill it :)
15:34:14 <sjanssen> sorear: I don't know the mechanics behind djinn, can it learn rank-2?
15:34:19 <mauke> @djinn forall your base. x -> x
15:34:19 <lambdabot> f a = a
15:34:27 <sorear> sjanssen: no, that would be undecidable afaik
15:34:27 <dmwit> Disinformation is just as good as datinformation.
15:34:35 <sorear> sjanssen: talk to augusttson
15:35:15 <ndm> sorear: isn't djinn undecidable anyway?
15:35:28 <sorear> @djinn (a -> b) -> ((a -> r -> r) -> r -> r) -> ((b -> r -> r) -> r -> r)
15:35:28 <lambdabot> f a b c d = b (\ e -> c (a e)) d
15:35:35 <Sgeo> djinn hates the IO monad :(
15:35:44 <sorear> ndm: no, it always terminates
15:36:04 <Sgeo> Is djinn not expected to know return??
15:36:06 <Sgeo> :D
15:36:08 <ndm> sorear: always succesfully?
15:36:12 <sorear> ndm: yes.
15:36:20 <ndm> neat
15:36:35 * ndm is so used to undecidable problems, its a shock to see something decidable
15:36:50 <sorear> ndm: there's a lot of suprising stuff you can do when you restrict yourself to first order :)
15:36:59 * sorear thinks of CaTCH
15:37:02 <ChilliX> Hi augustss!
15:37:10 <Sgeo> What's CaTCH?
15:37:16 <augustss> howdy
15:37:22 <ChilliX> How are things in London?
15:37:23 <sorear> Case and Totality Checker for Haskell
15:37:24 <Heffalump> hi ChilliX
15:37:28 <sorear> Sgeo: ^
15:37:31 <ChilliX> Hey Heffalump
15:37:38 <ndm> sorear: first-order == higher order, for most purposes
15:37:39 <sorear> Sgeo: ndm's dissertation
15:37:44 <ndm> or rather you can convert
15:37:47 <vincenz> augustss: hey, my brother is going to start modelling in a company and they use VB(A?) and excel for their modelling, I believe you had something similar at CS but then switched over to your own language, how'd that go?  Additionally, any good resources on excel/vb(a?) programming for modelling purposes
15:37:49 <Sgeo> @help freshname
15:37:49 <lambdabot> freshname. Return a unique Haskell project name.
15:38:02 <Heffalump> vincenz: what kind of modelling?
15:38:05 <ndm> today i successfully checked HsColour - with my patches i can prove it will never crash :)
15:38:06 <sorear> augustss: we were just discussing djinn...
15:38:14 <JoshTriplett> @freshname
15:38:15 <Sgeo> HsColour?
15:38:15 <lambdabot> Haeu
15:38:21 <ndm> @where hscolour
15:38:21 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
15:38:25 <vincenz> Heffalump: propulsion systems
15:38:34 <augustss> vincenz: the switch over to my langue is far from complete.  just a few users so far
15:38:47 <Heffalump> and his language generates Excel + VBA anyway :-)
15:38:48 <vincenz> he's not a programmer tho, only thing he knows is the C he learned in first year of uni
15:38:53 <ndm> i found 3 unique ways to crash HsColour
15:39:02 <vincenz> (well and matlab, obvioulsy)
15:39:10 <zbrown> Is there a preferred manner in which to cite the Haskell website? I need to cite it in a research proposal
15:39:23 <sorear> ndm: food for thought: would it be at all feasable for catch to generate code in a total language like system-fw in the process of proving completeness?
15:39:43 <Heffalump> CS extends Excel with addins (written in C++ and COM) quite heavily.
15:39:47 <augustss> sorear: and what did you say about djinn?  that he has to learn more? :)
15:39:54 <vincenz> Heffalump: oic
15:39:56 <ndm> sorear: system-fw is more a type thing?
15:40:23 <ndm> sorear: i can more prove existing haskell is total, rather than generate a total variant of the program
15:40:24 <sorear> ndm: well, aiui it has the strong normalization property
15:40:27 <vincenz> Heffalump: well he told me he'll be working on VB (not sure which one, he said the easy one, cause apparently there's 2)... Which book/resource do you recommend?
15:40:28 <Heffalump> vincenz: but there's also augustss's stuff, which has people writing their models in Haskell that then gets compiled into a spreadsheet (at least for now)
15:40:33 <ndm> sorear: plus i don't do termination
15:40:38 <sorear> ndm: and, d'oh, you'd need to prove termination :)
15:40:44 <Heffalump> vincenz: I haven't touched the VB yet, augustss has though.
15:40:57 <vincenz> augustss: any tips?  And is that haskell->VB stuff oss?
15:41:13 <Heffalump> none of the CS stuff is, I'm afraid
15:41:29 <augustss> It's as closed as they come :)
15:41:30 <sorear> augustss: actually, I was boring and said that djinn cannot add the requested features and stay total :(
15:41:53 <vincenz> augustss: ok, what about resources to get him started on the vb that is used to model in excel?
15:41:59 <vincenz> (I guess vba?)
15:42:06 * vincenz knows nothing whatsoever about vb
15:42:09 <sorear> augustss: they wanted general quantifier support
15:42:17 <augustss> sorear: probably true.  even if it could do a little more
15:42:30 <augustss> general quantifiers are right out
15:42:37 <jacobian> hmmm, coq seems not to automagically find a program for (a -> b) -> [a] -> [b] either
15:43:03 <ndm> vincenz: its standard VB6, learn that and you know VBA - plus the object model of Excel, which is big, but not deep
15:43:07 <sorear> jacobian: does coq come with [] syntax?
15:43:18 <sorear> jacobian: (I know it's powerful enough to define them)
15:43:20 <jacobian> yeah
15:43:22 <zbrown> What would the overall governing body of the haskell standards be called? Like for R its the R Core Development Team
15:43:26 <ndm> Hoogle was actually designed for the VBA object model in Excel, but got taken in a different direction quite early on
15:43:32 <sorear> jacobian: I just didn't think it was that heavy on sugar :)
15:43:36 <ndm> zbrown: just cite the haskell report
15:43:42 <zbrown> ndm: k thanks
15:43:53 <jacobian> oh, no it doesn't come with the ability to write the type that way
15:44:02 <jacobian> you can define syntaxes very easily though
15:44:06 <ndm> zbrown: simon peyton jones, haskell language and libraries, 2003, revised edition
15:45:15 <Igloo> Is heatsink == Chris Rodrigues?
15:46:14 <mbishop> Bender Bending Rodriguez?
15:46:22 <jacobian> What I actually wrote was: forall A B C : Set, A -> B -> list A -> list B.
15:48:19 <jacobian> with the C being completely extraneous :)
15:48:32 * Sgeo wonders if it might actually be easier to write a chat program in Haskell than Python
15:48:41 <vincenz> yay for 4-pass typecheckers \o/
15:50:27 <vincenz> make that 5-pass
15:50:29 * vincenz adds a pass
15:51:19 <ndm> Sgeo: probably take a bit longer to write, maybe a few libraries missing, but likely to be nicer in the end and more safe with type checking
15:52:19 <Sgeo> The chat protocol is insane and needs to be reverse engineered. It uses single character codes for everything. Me no like
15:52:30 <stepcut> Sgeo: which chat system ?
15:52:40 <Sgeo> JRChat
15:53:05 <Sgeo> There is VB code, which was based off a Java... disthingy
15:55:24 <ndm> Sgeo: VB was before Java, and in my opinion has somethings done better than Java
15:55:53 <ndm> augustss: re your libraries post, do you believe that the compiler optimising _|_ to a concrete value is wrong?
15:56:10 <ndm> and what about error "foo" == error "bar", and being interchangeable
15:56:17 <Sgeo> I meant VB code was based off Java code that was, I don't know the word, taken from the .class file
15:56:33 <augustss> optimizing _|_ to a concrete value is wrong
15:56:42 <ndm> augustss: ByteString does that _loads_
15:56:48 <augustss> error "foo" and error "bar" are interchangable
15:57:08 <augustss> then ByteString is wrong
15:57:21 <Heffalump> ick, why does it do that?
15:57:25 <dcoutts> augustss: na it's just refinement :-)
15:57:30 <ndm> well its their fundamental design asumption (we were actually discussing this in the pub just before you came over)
15:57:32 <augustss> you cannot claim total correctness and change termination properties
15:57:41 <Heffalump> would you say changing that error "foo" to some real value is ok, then?
15:57:47 <dcoutts> augustss: how about refining implementations of the standard List lib to be more lazy than the spec ?
15:57:49 <vincenz> bringert: time for compos3
15:57:56 <vincenz> o.O
15:58:15 <augustss> dcoutts: that would be wrong too.  But we could change the List lib.
15:58:17 <ndm> dcoutts, that was usually the original intention - but GHC broke take...
15:58:38 <Heffalump> what d oyou mean by "more lazy"?
15:58:41 <dcoutts> augustss: we know it's a bit controversial but for ByteString really nobody cares. For lists they do care, we know that.
15:58:55 <dcoutts> Heffalump: augustss, let me give you an example...
15:59:05 <augustss> dcoutts: I care.  Someone has to care about semantics
15:59:25 <ndm> if you care about semantics, you wouldn't use a strict data structure, because semantically that sucks
15:59:51 <dcoutts> augustss: yeah we do to for lists. For ByteStrings people don't generally put _|_'s into them and the performance benefits for doing those refinements are huge.
16:00:03 <Heffalump> can you just claim that the termination properties of ByteString are undefined for certain inputs?
16:00:13 <ndm> i think i can make your length . lines . readFile as fast in list as for bytestring
16:00:26 <augustss> dcoutts: Then they should operate over Word8#
16:00:26 <ndm> thats the goal of part II of my phd i've decided ;)
16:00:45 <ekidd> ddarius: Adjoints: An isomorphism between functors and arrows, and arrows and functors?
16:00:47 <dcoutts> > unwords ("foo":"bar":undefined)
16:00:48 <lambdabot>  Undefined
16:01:04 <dcoutts> hmm? that's not right
16:01:14 <dcoutts> > unlines ("foo":"bar":undefined)
16:01:15 <lambdabot>  Undefined
16:01:23 <augustss> > take 5 $ unwords ("foo":"bar":undefined)
16:01:24 <lambdabot>  Undefined
16:01:40 <dcoutts> that's not what I get in my ghci
16:01:52 <emu> @info
16:01:52 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
16:01:56 <emu> @version
16:01:57 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
16:01:57 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:02:28 <dcoutts> augustss: so with a proper H98 spec for unwords we get that unwords ("foo":"bar":undefined) = 'f':'o':'o':_|_
16:02:30 <augustss> I think changing, e.g., unwords in the List library to be more lazy is fine.  But then you have to say you have changed the library.
16:02:35 <Heffalump> there was a fusion bug with the strictness of take, wasn't there?
16:02:43 <ndm> Heffalump: yes
16:02:54 <ndm> dcoutts, thats just a buggy library...
16:03:03 <dcoutts> augustss: with a faster re-implementation we get unwords ("foo":"bar":undefined) = 'f':'o':'o':' ':'b:'a:'r':_|_
16:03:10 <augustss> dcoutts: Then I think unwords should be changed :)
16:03:22 <dcoutts> augustss: yes, there are several like that.
16:03:40 <augustss> But you can't change it willy-nilly in your compiler.  It has to be a library change.
16:03:50 <ndm> dcoutts, fix them all - it will no doubt help my work as well (laziness for my -O11 is very handy)
16:04:08 <augustss> Fix them, and send them to Haskell'
16:04:15 <dons> dcoutts has a rather nify QuickCheck module that generates bottoms, so its exposing all these laziness issues
16:04:17 <dcoutts> augustss: this is a library change and we'll try and get the spec to catch up. It's not going to change with different optimisaiton settings.
16:04:19 <ndm> fix them now!
16:04:29 <ndm> have you seen StrictCheck?
16:04:36 <ndm> it basically does what you seem to be describing
16:04:47 <dcoutts> ndm: nope, but we re-implemented it yesterday
16:05:00 <dons> augustss: its all in reference to the reimplementation of Data.List we're working on for ICFP, http://www.cse.unsw.edu.au/~dons/streams.html
16:05:01 <lambdabot> Title: Data.List.Stream
16:05:15 <ekidd> @tell ddarius Adjoints: An isomorphism between functors and arrows, and also between arrows and functors?
16:05:16 <lambdabot> Consider it noted.
16:05:21 <dcoutts> augustss: we're under the impression that the H98 list spec was intended to be as lazy as possible so we're implementing our list lib that way and we'll file bugs for the spec for Haskell'
16:05:29 <ndm> dcoutts, then release it - i'm not sure the original was ever released
16:05:50 <dcoutts> ndm: it's released, though not separately
16:05:56 <augustss> dcoutts: well, there's no reason to believe that the code in H98 is flawless
16:06:03 <bringert> vincenz: huh?
16:06:37 <dons> augustss: but I thought the h98 libs were divinely inspired!?
16:06:45 <dcoutts> augustss: right, so we're not sticking 100% to the strictness specified there but to the spirit and we'll identify all the places where we disagree with the spec
16:06:50 <vincenz> bringert: remember how I had Compos2?
16:06:51 <dons> formed with perfect laziness
16:06:54 <vincenz> bringert: I'm writing Compos3
16:07:04 <ChilliX> augustss: What are you talking about?  H98 flawed?!?
16:07:09 * ChilliX is shocked!
16:07:14 <bringert> vincenz: what's it do?
16:07:41 <vincenz> bringert: it does it for GADTs of 3 parameters
16:07:52 <bringert> ah
16:08:00 <bringert> I thought it was a version number
16:08:00 <vincenz> bringert: I had 2 before, cause I had the phantom tag type
16:08:15 <chessguy> hi all
16:08:17 <vincenz> bringert: but I need another one cause I want idents to be a type-param
16:08:25 <bringert> vincenz: couldn't you have a tuple instead?
16:08:31 <vincenz> bringert: no
16:08:33 <chessguy> ?src Monoid
16:08:33 <lambdabot> class Monoid a where
16:08:33 <lambdabot>     mempty  :: a
16:08:33 <lambdabot>     mappend :: a -> a -> a
16:08:33 <lambdabot>     mconcat :: [a] -> a
16:08:35 <vincenz> bringert: they're used in different places
16:08:47 <vincenz> Tag :: t -> Tag i a t -> Tag i a t
16:09:01 <vincenz> Tag :: t -> GADT i a t -> GADT i a t  --this is the one
16:09:04 <chessguy> @type unfoldr
16:09:06 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:09:11 <vincenz> Ident :: i -> GADT i Ident t
16:09:20 <dcoutts> augustss: going back to the ByteString refinement issue, it's things like: head . map (\n -> if n > 1 then _|_ else n) . pack $ [1 ... 10]
16:09:32 <bringert> vincenz: ok
16:09:44 <vincenz> the nice thing is
16:09:46 <vincenz> by putting the i
16:09:51 <vincenz> with the tag it's still a Compos2
16:09:56 <vincenz> actually if I put t before a
16:09:56 <augustss> dcoutts: I can see your dilemma
16:10:02 <vincenz> I can make it an instance of Compos, Compos2 AND compos3
16:10:04 <vincenz> ;)
16:10:19 <vincenz> \o/
16:10:19 <dcoutts> augustss: since ByteString is normally strict that is _|_ since when we map that _|_-inserting function we get a _|_ ByteString, however when we fuse we don't inspect the tail at all and don't force those _|_'s
16:11:28 <dcoutts> augustss: which as you can see is also a great performance win, without that relaxed view of things we can't fuse any non-strict consumers, eg foldr
16:12:05 <dcoutts> augustss: of course with lists it's ok since they're lazy to start with
16:12:07 <Sgeo> Why must there be unzip7 etc.?
16:12:10 <augustss> dcoutts: But I don't like the view that you can do wrong things in the name of efficiency.
16:12:56 <dcoutts> augustss: we considered it carefully, we're at least 'wrong' in the right direction, we do not introduce _|_'s into your program when optimising, only take them away.
16:12:57 <augustss> dcoutts: That said, I do like fast byte strings!
16:13:10 <chessguy> is it possible to write a function like elements :: (Monoid a) => a -> [a]
16:13:11 <ndm> maybe the real solution is to always use String, and have the compiler automatically use ByteString underneath
16:13:18 <dons> you pay some price by switching to an unboxed type.
16:13:22 <dcoutts> augustss: in practise it's not really a problem since you'd find those _|_ when you run first time without using -O
16:13:35 <ekidd> chessguy: Only for free monoids.
16:13:36 <siti> is there a way to get infinity in haskell without (1/0)?
16:13:37 <augustss> dcoutts: I think there's solution that is correct and fast in there somewhere
16:13:45 <chessguy> what's a free monoid?
16:13:48 <dcoutts> augustss: and in practise people don't intentionally put _|_'s into ByteStrings
16:14:01 <augustss> siti: Haskell does not promise that 1/0 gives inifinity
16:14:05 <ekidd> One where the elements don't get smushed together, basically.
16:14:06 <dcoutts> augustss: I'd love to know what that solution might be
16:14:16 <siti> augustss: well is there a nice way to get infinity :p
16:14:28 <augustss> dcoutts: unpointed domains
16:14:28 <ekidd> chessguy: The integers for a monoid with mappend = (+)
16:14:35 <dcoutts> augustss: ah
16:14:44 <dons> dcoutts: i think we should have a special award for anyone who does put _|_ in their strict, unboxed bytestring.
16:14:45 <hpaste>  (anonymous) pasted "iterativefor" at http://hpaste.org/1058
16:14:52 <dcoutts> augustss: we'd like that for Streams too, Streams should be bottomless
16:14:55 <chessguy> ekidd: i'm assuming the integers aren't a free monoid then
16:15:00 <ekidd> chessguy: But you can't write elements 10 in any sensible fashion, then.
16:15:02 <xerox> ?type iterate (mplus mzero) mzero
16:15:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a]
16:15:07 <chessguy> right
16:15:25 <chessguy> ekidd: is there a built-in type class that captures the concept of a free monoi?
16:15:40 <augustss> siti: Haskell does not promise that Float and Double can represent inifinity
16:15:51 <dcoutts> augustss: for the NDP project, RL is giving people a couple variants for strict arrays, one that religiously forces everything even when you fuse with things like head/find etc and a variant that can be faster but can drop _|_'s
16:15:54 <ekidd> chessguy: Well, they're all isomorphic to [a], I think.
16:16:04 <chessguy> hmm
16:16:04 <siti> ok, well how can I get the highest value of a double?
16:16:17 <chessguy> what about t
16:16:18 <xerox> > maxBound :: Double
16:16:19 <lambdabot>   add an instance declaration for (Bounded Double)
16:16:19 <lambdabot>     In the expression: max...
16:16:20 <chessguy> what about Tree
16:16:38 <Sgeo> > maxBound
16:16:39 <lambdabot>  Add a type signature
16:16:44 <Sgeo> > maxBound :: Integer
16:16:45 <lambdabot>   add an instance declaration for (Bounded Integer)
16:16:45 <lambdabot>     In the expression: ma...
16:16:46 <chessguy> Data.Tree isn't an instance of monoid, but it could trivially be modified to be
16:16:49 <Sgeo> > maxBound :: Int
16:16:50 <lambdabot>  2147483647
16:17:01 <chessguy> i don't know that it would be isomorphic to [a] though
16:17:24 <Sgeo> > maxBound :: String
16:17:25 <lambdabot>   add an instance declaration for (Bounded String)
16:17:25 <lambdabot>     In the expression: max...
16:17:31 <Sgeo> > maxBound :: Char
16:17:32 <lambdabot>  '\1114111'
16:17:33 <augustss> siti: The methods in RealFloat can be used to construct the largest normal number
16:17:34 <ekidd> chessguy: Data.Tree isn't associative in mappend. I think monoids are supposed to be associative.
16:17:43 <siti> ok
16:18:02 <chessguy> oh, i need to look up the monoid laws
16:18:04 <ekidd> tree x (tree y z) != tree (tree x y) z
16:18:14 <augustss> siti: floatDigits, floatRadix, floatRange, encodeFloat
16:18:18 <rubenz> Is it possible to define a class Scalar which can do scalar multiplication on matrices and vectors?
16:18:26 <siti> thanks
16:18:42 <rubenz> I'm having some trouble with it
16:18:46 <stepcut> > read "Infinity" :: Float
16:18:47 <lambdabot>  Infinity
16:18:55 <chessguy> heh. you're kidding me
16:19:07 <ekidd> chessguy: http://en.wikipedia.org/wiki/Monoid
16:19:08 <lambdabot> Title: Monoid - Wikipedia, the free encyclopedia
16:19:11 <ndm> dcoutts, how much faster have you got nobench?
16:19:14 <chessguy> according to http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html : "The monoid class. A minimal complete definition must supply mempty and mappend, and these should satisfy the monoid laws."
16:19:16 <lambdabot> http://tinyurl.com/y5qk9n
16:19:20 <dcoutts> ndm: not got there yet
16:19:21 <ndm> dcoutts, with Data.List.Stream
16:19:22 <chessguy> ...but it doesn't list the monoid laws
16:19:32 <ndm> dcoutts, not cutting it a bit fine with only 15 days to go ;)
16:19:39 <siti> > encodeFloat 1 1000000
16:19:40 <lambdabot>  Infinity
16:19:45 <dcoutts> ndm: we'l probably have that working by the end of the week, right dons ?
16:19:47 <ekidd> chessguy: Associativity and an identity element.
16:19:49 <siti> well a bit ugly but not to bad ;)
16:19:54 <augustss> chessguy: mempty is the left and right identity of mappande, mappand is associative
16:20:00 <ekidd> chessguy: And a binary operation, obviously.
16:20:08 <ndm> i've finished my ICFP paper and am on to my HW one ;)
16:20:12 <vincenz> bringert: it's quite cool like this, cause with the `type` of the GDAT being last, you can instantiate all three compos's and only use the one you need
16:20:20 <vincenz> bringert: in fact, you could probably autoderive a compos from a compos2
16:20:30 <vincenz> bringert: and a compos2 from a compos3
16:20:37 <chessguy> well, my point right now is it's stupid to refer to the monoid laws in the documentation for monoids without listing them
16:20:41 <augustss> composM rocks!
16:20:50 <vincenz> bringert: so defining Compos3 gives you Compos2 and Compos3
16:20:55 <vincenz> augustss: I extended it for multiparam GADTS
16:20:56 <chessguy> anyway
16:21:00 <vincenz> augustss: with phantomtypes
16:21:01 <dcoutts> ndm: so how do you optimise/fuse return . length . lines =<< readFile f ?
16:21:08 <bringert> vincenz: but it looked like you had the tag argument last?
16:21:15 <vincenz> bringert: I'm changing that
16:21:18 <bringert> ah
16:21:19 <vincenz> bringert: to get that flexibility
16:21:37 <bringert> augustss: are you using it for anything?
16:21:39 <ndm> dcoutts, to loop {c = getc(); if (c == '\n') i++;} print i
16:21:47 <chessguy> so mappend (mappend a b) c == mappend a (mappend b c) ?
16:21:51 <dcoutts> ndm: we'll beat you then
16:21:51 <dons> dcoutts: we'll have it working by tonight i think
16:21:56 <bringert> vincenz: will you be writing this up?
16:21:57 <dcoutts> ndm: getc is far too slow
16:22:09 <vincenz> bringert: well I'm coding it
16:22:15 <ndm> dcoutts, i can always macro getc up to read a chunk and index into it locally
16:22:21 <dons> getc is for the slow guys, ndm. didn't you read "Rewriting Haskell Strings" ;-)
16:22:25 <bringert> I mean it sounds like it could turn into a nice paper
16:22:29 <dons> page 1, paragraph 1. don't use getc.
16:22:32 <vincenz> bringert: oh well, hmm :)
16:22:33 <dcoutts> ndm: without threads, yes.
16:22:52 <dons> ndm, jhc uses unblocked_getc or whatever it is.
16:22:53 <bringert> you're right to code it first though :-)
16:22:59 <vincenz> bringert: I kinda need it
16:23:10 <dcoutts> dons: which still isn't that fast, it's still a function call
16:23:12 <ndm> dons: i need some "get one single character off the list" - whatever that may be
16:23:14 <vincenz> I already had compos2 but reversed, now extending to compos3 made me realize the chain
16:23:23 <vincenz> bringert: pm?
16:23:24 <bringert> vincenz: papers aren't just for useless things :-)
16:23:37 <ndm> as a macro etc for performance
16:24:09 <dcoutts> ndm: that's also wrong :-) length . lines /= count '\n'
16:24:26 <chessguy> ekidd: ermm
16:24:36 <ndm> dcoutts, when -O11 does the translation it never gets it wrong - even when there is _|_ involved ;)
16:24:39 <chessguy> ekidd: why can't you write elements 10 in any sensible fashion?
16:24:41 <ekidd> chessguy: There's a whole bunch of potential type classes here: http://en.wikipedia.org/wiki/Algebraic_structure
16:24:41 <lambdabot> Title: Algebraic structure - Wikipedia, the free encyclopedia
16:25:06 <dcoutts> ndm: good good :-) I'm eager to see it. More speed please!
16:25:08 <dons> ndm, no no. its just wrong.
16:25:10 <jcreigh> @seen sjanssen
16:25:10 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 50m 55s ago.
16:25:14 <chessguy> wouldn't it just be the partitions?
16:25:20 <dons> ndm, since it messes up on \n missing on the last line of the file
16:25:28 <ekidd> chessguy: 7+3 = 10 doesn't allow you to recover 7 and 3.
16:25:29 <ndm> dons: i mean when i give a suggestion, i get it wrong, when -O11 does it, it won't get it wrong
16:25:37 <jcreigh> sjanssen: tiling seems to work fine in Xinerama
16:25:37 <ndm> dons: i'm only giving a flavour of -O11
16:25:39 <dons> i actually had that as a rule in fps in the early days, until QC pointed out that it was false
16:25:42 <dcoutts> ndm: right
16:25:52 <chessguy> hm
16:26:19 <Pseudonym> Given a Sufficiently Smart Compiler(tm), Haskell will cook you breakfast.
16:26:29 <dons> ?check \xs -> length (lines xs) == length (filter (=='\n') xs)
16:26:30 <ndm> dcoutts, as soon as HW submission date is over, i get to hack -O11
16:26:30 <lambdabot>  Falsifiable, after 1 tests: "\1025409\460528"
16:26:48 <dcoutts> ndm: what are you doing for HW btw?
16:27:01 <ekidd> chessguy: You could define something reasonable in most cases. Call it "MonoidWithElements" and implement it wherever it makes sense.
16:27:17 <ndm> dcoutts, Play
16:27:25 <ndm> dcoutts, my SYB/Compos competitor
16:27:25 <chessguy> ekidd: i'd prefer something a little less monster-y, like Composable
16:27:28 <stepcut> > fromRational (1%0)
16:27:29 <lambdabot>  Exception: Ratio.%: zero denominator
16:27:47 <dcoutts> ndm: ah cool, btw I'd like a reference for StrictCheck
16:27:52 <ekidd> chessguy: Sure!
16:28:03 <ndm> @google olaf chital strict check
16:28:05 <dcoutts> ndm: I might do something along those lines for HW
16:28:07 <lambdabot> http://www.contrib.andrew.cmu.edu/~ajo/free-software/xword/tartan.txt
16:28:08 <Sgeo> > undefined `seq` 1+1
16:28:09 <lambdabot>  Undefined
16:28:13 <chessguy> class Composable a where elements :: a -> [a]
16:28:27 * ekidd remembers the "Going under the water safely device" from Discworld...
16:28:30 <ndm> dcoutts, http://www.cs.kent.ac.uk/pubs/2006/2477/index.html
16:28:31 <lambdabot> Title: Computer Science: Publication: Promoting Non-Strict Programming
16:28:50 <kc5tja> ??
16:28:50 <dcoutts> ndm: ta
16:28:56 <ekidd> chessguy: elements :: c a -> [a]
16:29:03 <kc5tja> As if it requires promotion?  I rather think the benefits would be obvious.
16:29:13 <chessguy> ?
16:29:20 <chessguy> what's c?
16:29:36 <ekidd> class Composable c where elements :: c a -> [a]
16:29:36 <dcoutts> ndm: btw, I do in general like your non-inlining approach to optimisation, I just wish you'd tell us more about it :-) I keep having ideas for fusion without inlining and specialisation on strictness and structure etc
16:29:52 <ekidd> chessguy: Unless you want elements to return a list of composables.
16:29:54 <ndm> dcoutts, i'd love to, but only after i've told you about Catch and Play
16:30:09 <dcoutts> ndm: well 'approach' isn't the right word, but idea, since you've not told us your approach :-)
16:30:12 <chessguy> yes, i do
16:30:16 <ndm> dcoutts, or if you are at FITA Cambridge, grab me
16:30:23 <dcoutts> ndm: will do
16:30:41 <ndm> dcoutts, i'm happy to explain, its just a nightmare without a whiteboard and a face to face
16:30:49 <dcoutts> ndm: it might make sense to write something on this topic together
16:30:54 <ndm> or a carefully crafted paper...
16:30:56 <ndm> cool
16:31:04 <ekidd> chessguy: elementsTree :: Tree a -> [Tree a] ???
16:31:22 <chessguy> elementsTree = subtrees
16:31:26 <ndm> i'll need to hack -O11 for a few weeks before i can get the concrete results - but the firstifier in Catch is now pretty solid, so thats the stepping stone
16:31:38 <chessguy> (a list of all the subtrees of a tree)
16:31:45 <ekidd> elementsList :: [a] -> [[a]] ?
16:32:00 <chessguy> yes
16:32:33 <ekidd> chessguy: elements [1,2,3] = ??
16:32:53 <chessguy> elementsList [1..3] = [[1],[2],[3],[1,2],[2,3],[1,2,3]]
16:33:14 <ekidd> [1,3]?
16:33:29 <ekidd> []?
16:33:30 <chessguy> well, not for the application i'm thinking of
16:33:45 <Sgeo> @source foldr1
16:33:45 <lambdabot> foldr1 not available
16:33:50 <Sgeo> @src foldr1
16:33:50 <lambdabot> foldr1 _ [x]    = x
16:33:50 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
16:33:50 <lambdabot> foldr1 _ []     = undefined
16:34:19 <chessguy> in my case, i would only want non-empty continguous subsets
16:34:34 <ekidd> Hmm. A function which gives you either subtrees or partitions is certainly unusual, but if your application has a sensible way of seeing both as the "same thing", go for it!
16:35:07 <chessguy> ekidd: i'm trying to generalize genetic algorithms to genetic programming
16:35:36 <chessguy> (or maybe the other way around)
16:36:09 <dons> sjanssen: is this xmonad emulation, http://na.srck.net/dwm/dwm-3.8-monocle.patch ?
16:36:19 <dons> > just created patch to add fullscreen layout manager.
16:36:19 <dons> > It show only one window (that is actualy selected) on screen, but maximized.
16:36:19 <lambdabot>  Parse error
16:36:19 <lambdabot>  Parse error
16:36:22 <ekidd> elements (Tree Leaf 1 (Tree (Tree Leaf 2 Leaf) 3 Leaf) = ?
16:36:40 <jcreigh> heh heh
16:36:51 <chessguy> errr, that doesn't make ense
16:36:51 <ekidd> I'm just trying to puzzle this out! :-)
16:36:52 <ndm> dcoutts, i was wondering about c2hs - i tried to pull and it failed
16:36:53 <chessguy> sense
16:36:57 <chessguy> that's not a valid tree
16:37:05 <dcoutts> ndm: even with --partial ?
16:37:06 <ndm> dcoutts, with the darcs.haskell.org address, on windows, with --partial
16:37:08 <chessguy> oh wait
16:37:24 <ndm> dcoutts, plus i was wondering how big it is, and how "complex" it is
16:37:26 <dcoutts> ndm: hmm, I thought that was fixed. It was a case-sensitivity thing
16:37:27 <ekidd> chessguy: Assuming data Tree a = Leaf | Tree (Tree a) a (Tree a) -- (analogously to list)
16:37:38 <ndm> i.e. what chance would i have of proving it pattern match safe
16:37:51 <dcoutts> ndm: c2hs, it's fairly bug hah, no. It's very unsafe :-)
16:37:56 <dcoutts> bug/big
16:38:06 <dcoutts> freudian slip
16:38:06 <ndm> dcoutts, i.e. crashes lots of malformed input?
16:38:09 <ekidd> There's also data Tree a = Empty | Leaf a | Tree (Tree a) (Tree a), and several others.
16:38:25 <ndm> dcoutts, or safely tells the user "doh"
16:38:30 <chessguy> hang on, i have to draw out your tree, it's making my head hurt
16:38:48 <dcoutts> ndm: yep, well in practise no. It can parse many C constructs but if you try to bind some of the more exotic ones it'll fail.
16:39:00 <ekidd> chessguy: All data is stored in the nodes themselves, and my Leaf is really just NULL.
16:39:10 <ndm> dcoutts, fail and crash with error, or give a sensible message to the user?
16:39:37 <ekidd> It's just a version of List a = Nil | Cons a (List a)
16:39:39 <dcoutts> ndm: at least that's what I'd expect. We parse the glibc headers which contain much grunge, but fortunately people don't need to bind that stuff. Oh probably fail with a pattern match failure.
16:40:03 <ndm> dcoutts, do you have some framework to return a nicer error than that? or is fail just the way its done
16:40:07 <chessguy> ok
16:40:21 <ndm> i.e. in a monad or something that can return a Maybe back up the chain then print a pretty messages
16:40:30 <dcoutts> ndm: we sometimes give nice errors, but I'm sure there's lots of partial pattern matches
16:40:43 <ndm> or another way, is there a vague intention to make it complete
16:40:47 <dcoutts> no
16:40:54 <ndm> would it be nice if it was?
16:41:00 <dcoutts> perhaps, yes
16:41:05 <ekidd> chessguy: Good luck with the genetic algorithms!
16:41:06 <ndm> i.e. would you accept patches that made it so
16:41:19 <dcoutts> ndm: it'd at least tell us what we can't cope with currently
16:41:41 <chessguy> so elements would be [Leaf, Tree Leaf 2 Leaf, Tree (Tree Leaf 2 Leaf) 3 Leaf, Tree Leaf 1 (Tree (Tree Leaf 2 Leaf) 3 Leaf]
16:41:45 <chessguy> (i think)
16:41:46 <dcoutts> ndm: sure, but be aware that I'm adding to the set of things that will fail by extending the parser but not the middle layers
16:42:00 <chessguy> it's all the subtrees of the tree
16:42:04 <ndm> dcoutts, hmm, might not be such a good test case for catch then...
16:42:08 <chessguy> (in this case, i threw out the duplicates of Leaf
16:42:19 <dcoutts> ndm: ie adding more AST stuff without adding extra stuff that recognises those AST nodes in the middle parts
16:42:43 <ndm> until its stabalised and complete, and by then my paper will be in and the tool will be released and you can do it yourself ;)
16:42:52 <toko123> greetings
16:42:53 <dcoutts> ndm: so what would you need to do ?
16:43:04 <dcoutts> ndm: would working on a fork be ok ?
16:43:10 <ekidd> chessguy: Oh, OK! I see how that works. I think it might be similar (but not identical) to one of the "shrink" functions in QuickCheck.
16:43:15 <dcoutts> ndm: ie without me treading on your toes
16:43:24 <ndm> dcoutts, make it so it didn't crash - i've got one nice big example program which is proven - but i want another if possible
16:43:40 <toko123> please vote for Ellen Reavey, musicain missid districts as a sph tp top4 in state as a sr.
16:43:43 <toko123> http://www.wvia.org/education/AoW06-07/index.shtml
16:43:44 <lambdabot> Title: WVIA Public Broadcasting for Northeastern PA&the Central Susquehanna Valley
16:43:45 <dcoutts> ndm: eg by adding _ -> catchall cases ?
16:43:46 <chessguy> ekidd: the idea is, i want to be able to say class (Composable a) => Evolvable a where
16:43:47 <ndm> dcoutts, i'm more interested in the real world aspect, i.e. saying "look at HEAD for <program>, i can prove that doesn't crash!"
16:43:50 <ekidd> Except those are only required to return a list of "smaller" versions of the data structure.
16:43:58 <sorear> toko123: wgat does this have to do with haskell?
16:43:59 <toko123> thanks for your generous support
16:44:01 <toko123> re-v
16:44:02 <ndm> dcoutts, thats one usual way
16:44:20 <toko123> music and haskell are one
16:44:21 <dcoutts> ndm: so you need to look for explicit calls to error or something ?
16:44:31 <dcoutts> ndm: just partial patterns isn't enough ?
16:44:41 <dcoutts> head (x:_) = x
16:44:44 <dcoutts> and no [] clause
16:44:45 <toko123> sorear, thanks for your support
16:44:47 <ndm> dcoutts, yes - catch can prove most of them complete if they are
16:45:01 <ndm> dcoutts, when desugared there is an error introduced, so i just look for error
16:45:14 <ndm> catching both pattern matches and explicit error calls
16:45:27 <dcoutts> ndm: hmm I don't understand why we'd need to add catchall -> error cases then
16:45:42 <ndm> dcoutts, i meant _ -> sensible default
16:46:01 <dcoutts> ndm: oh, there's no sensible default, it's just -> internal error
16:46:05 <chessguy> ekidd: i suppose i could just make elements a part of the definition of evolvable
16:46:10 <dcoutts> _ -> not yet implemented
16:46:15 <chessguy> ?source QuickCheck
16:46:15 <ndm> dcoutts, oh - catch does all that automatically, it would be just fixing the issues that catch finds - where it finds you can crash
16:46:15 <lambdabot> QuickCheck not available
16:46:29 <ndm> dcoutts, yes - if not yet implemented was abort, rather than error
16:46:34 <sorear> @wgere QuickCheck
16:46:34 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
16:46:37 <dcoutts> ndm: ah ok, well that'd be telling us were we're incomplete
16:46:50 <dcoutts> ndm: where we can parse stuff that we then do not understand
16:47:03 <dcoutts> ndm: which in itself would be really useful
16:47:06 <ndm> dcoutts, yes - might be a handy tool for you then
16:47:23 <dcoutts> ndm: since at the moment we don't know what we don't know but we'd like to know it :-)
16:47:28 <ndm> unfortunately its not a great case study unless i can say at the end "i found these unknown bugs, now the program is proved safe"
16:47:49 <chessguy> ekidd: hmm, i don't see a shrink function in QC
16:47:51 <ndm> dcoutts, i'll try again at doing a darcs get (perhaps on linux), and see what comes of it
16:48:04 <ekidd> chessguy: I forget the exact name. One sec.
16:48:05 <chessguy> ?hoogle shrink
16:48:06 <lambdabot> No matches found
16:48:18 <dons> sjanssen: feature request, kill -s USR1 $pid_of_xmonad, will trigger a signal handler, that will unmanage all windows, and then re-exec xmonad
16:48:37 <dons> sjanssen: this patch to dwm provides that, http://na.srck.net/dwm/dwm-3.8-reload.patch
16:49:03 <dcoutts> ndm: hmm, but any complex real world program is going to be incomplete, so I think saying that we now know where and how it's imcomplete is really useful since it tells us what to do next
16:49:19 <dcoutts> actually being able to complete it is too big a task
16:49:59 <ekidd> chessguy: Hmm. There was another library like QuickCheck, wasn't there?
16:50:09 <ekidd> Maybe "shrink" was in that one. :-(
16:50:10 <chessguy> smallcheck?
16:50:14 <chessguy> ?where smallcheck
16:50:15 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
16:50:30 <ndm> dcoutts, complete /= all syntactic patterns are complete
16:50:36 <sorear> ?where strictcheck
16:50:37 <lambdabot> I know nothing about strictcheck.
16:50:45 <ndm> dcoutts, catch is way more clever than that
16:50:48 <Igloo> ndm: Why did a non-transitive Ord make Data.Map loop?
16:50:51 <Philippa> dcoutts: I suspect that gets us straight back into error handling, too
16:50:59 <ndm> Igloo: i don't know, but it definately did!
16:51:01 <Igloo> ndm: Surely at each comparison it descends deeper into a finite structure
16:51:02 <dcoutts> ndm: so completing it with calls to a monadic non-_|_internal error function would be ok then ?
16:51:03 <Philippa> I had stuff to say on list after a conversation ekidd and I had, never got round to posting...
16:51:10 <ndm> dcoutts, yes
16:51:30 <dcoutts> ndm: ok, that'd be useful
16:51:33 <ndm> dcoutts - HsColour can be proven to be totally safe, i was thinking c2hs would be a nice second one to complement that
16:51:53 <dcoutts> ndm: it's a lot bigger and has many more AST bits
16:51:57 <ndm> Igloo: you would have thought, but no, it definately looped on GHC 6.4.2
16:52:01 * Igloo also notes that complete pattern coverage is nice so that you can turn on -Wall and have the warnings inform you of real errors
16:52:21 <ndm> Igloo: HsColour as checked by catch throws up loads of warnings
16:52:21 <Igloo> ndm: Presumably you don't have a small example to hand, though?
16:52:28 <ekidd> chessguy: Anyway, the library I'm thinking of had a function which returned a list of all the different possible ways to shrink a data structure by one element.
16:52:28 <sorear> catch sould be linked into ghc :)
16:52:43 <ndm> Igloo: plus -Wall doesn't catch uses of head/tail etc - much more serious
16:52:47 <ekidd> It used that to shrink failing test cases down to minimum failing values.
16:52:47 <chessguy> ekidd: that would work
16:52:54 <ndm> dcoutts, true - likely to be a harder challenge
16:53:02 <dcoutts> ndm: yep
16:53:06 <chessguy> was the result of the same type?
16:53:14 <Igloo> ndm: The point of making it -Wall clean is so that you can also see warnings about /other/ things. Make it merely catch-clean doesn't help with that
16:53:26 <ndm> sorear: HsColour takes 2.1 seconds to transform and prove - when compiled with -O0 and profiling
16:53:29 * dcoutts pushes more changes to the c2hs C parser
16:53:35 <ekidd> shrink: [1,2,3] == [[2,3], [1,3], [1,2]], for example.
16:53:43 <ndm> sorear: i.e. faster than a compilation (although worst case is a lot bigger than that)
16:54:07 <chessguy> well, that's not exactly what i would want in my case, but i'd still be curious to see how they went about it
16:54:07 <Igloo> ndm: Oh, wait, you mean catch will find some errors in -Wall-clean programs? Yes, that is useful, but you still want to be Wall-clean first  :-)
16:54:07 <sorear> ndm: library doesn't obsolete standalone
16:54:15 <ndm> Igloo: true, although once you've proved it complete with catch that -Wall is pretty irrelevant
16:54:24 <chessguy> (i would want my function to return [[1,2],[2,3]]
16:54:37 <ekidd> And for trees, it would (hypothetically) either remove the root node (and merge), or shrink either the left or right child recursively.
16:54:49 <Igloo> ndm: For coverage, sure, but does catch also warn about shadowing, unused imports, ...?
16:54:49 <sorear> since catch is so fast, how about making it a standard -W option as well as a standalone program?
16:54:51 <ndm> Igloo: catch will find pattern match errors in -Wall-clean programs, and prove there are no errors in non -Wall clean ones - making -Wall's pattern match checker a bit silly
16:55:10 <ndm> Igloo: oh - you really want all the other good stuff in -Wall, just not pattern match errors if you are using catch
16:55:13 <ekidd> The only contract: It had to return a "smaller" value, so it would eventually terminate.
16:55:15 <Igloo> ndm: Admittedly you could turn off warnings catch does better, but easier just to be -Wall clean anyway (and also use catch)
16:55:31 <sorear> Igloo: can't we have -Wall *use* catch?
16:55:38 <chessguy> ekidd: i'd definitely like to see that if you can find it
16:55:43 <ekidd> So you could knock out more than one element at a time, if that was easier.
16:55:44 <ndm> sorear: easy enough to do, not terminating enough in general, too whole program analysis
16:56:04 <sorear> ndm: not terminating enought?
16:56:05 <ndm> sorear: maybe one day (about 3 versions down the line)
16:56:07 <ekidd> chessguy: If I run into it, I'll leave you a message with lambdabot.
16:56:10 <sorear> ndm: catch is partial? :)
16:56:12 <ndm> sorear: it can take quite a while on some examples
16:56:21 <chessguy> ok, great. thanks
16:56:25 <ndm> sorear: i have a proof of termination, that doesn't mean to say it actually terminates...
16:56:37 <sorear> ndm: strictness analysis is O(2^n) worst case
16:56:44 <sorear> ndm: is catch worse than that?
16:56:49 <ndm> sorear: and i haven't proven catch with catch, so it may still crash
16:57:30 <ndm> sorear: its O(m*2^t), where t is the size of the types, and m is the size of the program
16:57:36 <ndm> i think...
16:58:02 <ndm> in practice its a lot slower than strictness, and does require the whole program (including all imports)
16:58:17 <ndm> ESC/Haskell is much likelier to make it into GHC before Catch
16:58:55 <ndm> and once Catch can generate ESC/Haskell annotations, i guess you have the best of everything
16:59:01 <chessguy> ekidd: how's your category theory article coming?
16:59:30 <ekidd> chessguy: Slowly. It's the work-week, my girlfriend is back from her trip, and I'm trying to learn adjoints. :-)
16:59:39 <chessguy> haha
16:59:47 <chessguy> i bet she loves that
17:00:21 <ekidd> Obviously, I'm not learning adjoints very fast.
17:00:29 <sorear> nhc98 has an evil mangler!?
17:00:35 <chessguy> i thought this was supposed to be just the basics? i 've never even heard of adjoints
17:00:46 <ekidd> chessguy: Not for the tutorial, just for me.
17:00:57 <chessguy> ah
17:01:30 <ekidd> Adjoints a seem to be the bit of category theory that mathematicians in other fields get the most excited about.
17:01:57 * ekidd heads for home
17:02:38 <vincenz> @hoogle inc
17:02:39 <lambdabot> Distribution.InstalledPackageInfo.includeDirs :: InstalledPackageInfo -> [FilePath]
17:02:39 <lambdabot> Distribution.InstalledPackageInfo.includes :: InstalledPackageInfo -> [String]
17:02:39 <lambdabot> Distribution.PackageDescription.includeDirs :: BuildInfo -> [FilePath]
17:03:44 <stepcut> vincenz: perhaps you want succ ?
17:03:50 * vincenz shakes
17:06:42 <dcoutts> mux: I don't see it yet
17:07:22 <mux> dcoutts: I've received a mail saying my post was awaiting moderation
17:07:36 <Cale> Pairs of adjoint functors are generally fairly impressive gems to find.
17:07:41 <Igloo> mux: To which list?
17:07:46 <dcoutts> mux: ah yes, I don't do the moderation Axel does. If you want it applied now then post the patch.
17:07:52 <dcoutts> Igloo: gtk2hs, don't worry.
17:07:52 <mux> gtk2hs-devel
17:07:56 <Igloo> Ah, OK
17:08:15 <dcoutts> mux: ie stick it on your web space like you did with the first one
17:08:21 <dcoutts> i'll apply it
17:08:36 <mux> done, same address
17:08:43 <mux> there's no hurry though =)
17:08:44 <Cale> Some of the most interesting constructions in all of mathematics turn out to be adjoints when looked at in the right way.
17:09:29 <hpaste>  vincenz pasted "(no title)" at http://hpaste.org/1059
17:09:48 <mux> dcoutts: do you need the URL again or is it okay?
17:10:08 <dcoutts> if it's the same url I can scrollback
17:11:09 <dcoutts> mux: tell me when it's updated
17:12:12 <mux> it is
17:12:41 <mux> since when I said "done" ;-)
17:13:03 <dcoutts> mux: I see the same diff style patch, not the darcs patch
17:13:25 <dons> dcoutts: just commited isPrefixOf fusion (easy!)
17:13:48 <sjanssen> @tell jcreigh I'd love to see a screen shot of your three monitor xmonad goodness
17:13:48 <lambdabot> Consider it noted.
17:13:52 <dcoutts> dons: yay, when are you getting here ?
17:14:07 <dcoutts> mux: darcs send --output=colordialog.diff
17:14:17 <dons> i'll be leaving in hmm. 30 mins or so, get in around 12.30. you could go to lunch, or wait till 2.
17:14:24 <dcoutts> y'ok
17:14:34 <mux> dcoutts: oh, sorry
17:14:46 <dons> sjanssen: ah yes. full xinerama screen shots would be good!
17:14:47 <mux> I didn't get that you wanted the darcs style patch
17:14:55 <dons> sjanssen: what do you think of the sigusr1 re-exec for xmonad?
17:15:04 <dcoutts> mux: that way you get proper credit and it's easy to apply
17:15:20 <mux> dcoutts: done
17:15:24 <sjanssen> dons: it's probably useful -- but I have no idea how signal handlers work in Haskell
17:15:35 <dons> sjanssen: ah easy. i do.
17:15:38 <dons> i'll add it.
17:16:07 <dcoutts> sjanssen, dons: so what did you two decide about XCB ?
17:16:18 <dons> we can't do it till after icfp ;-)
17:16:26 <dcoutts> hah, of course
17:16:34 <dons> sjanssen: what did you decide?
17:16:42 <mux> dcoutts: while I've got you around, could you give me the name of the function I'm supposed to use to send a signal to some widget myself? :-)
17:16:47 <dcoutts> btw, I think a binding to XCB is better than a direct socket level impl since then you can use higher level things like cairo in the same program
17:16:55 <dons> yeah.
17:16:56 <dcoutts> since that needs to share an XCB connection
17:17:19 <dcoutts> mux: erm, we don't directly bind that, it's rather stringy
17:17:31 <dcoutts> mux: but there are several widget-specific ones that do that
17:17:56 <mux> ah, do you know any to force redrawing a GtkDrawingArea?
17:18:07 <sjanssen> dons, dcoutts: what was I supposed to decide about XCB?
17:18:15 <dcoutts> mux: widgetQueueRedraw iirc
17:18:25 <mux> dcoutts: cheers
17:18:29 <sjanssen> dcoutts: I hadn't considered interop with C libs before.  Yes, a C implementation is probably better
17:18:30 <dons> i think the decision was to look again at xcb after xmonad 0.1 is out
17:18:41 <jcreigh> xcb?
17:18:41 <lambdabot> jcreigh: You have 1 new message. '/msg lambdabot @messages' to read it.
17:19:13 <sjanssen> jcreigh: another interface to the X11 protocol -- like xlib remixed
17:19:18 <dcoutts> mux: ah, slightly wrong name, if you go to haskell.org/gtk2hs and type 'queue' in the api search box you'll find the right one though :-)
17:19:23 <dcoutts> hoogle++
17:19:29 <mux> dcoutts: nice thanks
17:20:28 <vincenz> @localtime bringert
17:20:29 <lambdabot> Local time for bringert is 2007-03-21 01:21:15 +0100
17:22:19 <jcreigh> sjanssen: is there any particular reason you make the tiling mode global?
17:22:29 <jcreigh> *made
17:22:51 <sjanssen> jcreigh: not really.  I considered making it per workspace
17:27:19 <dons> hmm. that's an interesting idea
17:27:22 <dons> what does dwm do?
17:27:29 <sjanssen> global
17:28:21 <sjanssen> there are good arguments for layout per workspace.  You can keep dumb programs like gimp on one float workspace while the rest are full/tile
17:29:39 <jcreigh> hmm, I really need to clean up the wsOnScreen data structure.
17:31:30 <jcreigh> Is there such a thing as a "symmetrical map"? A workspace can only be on one screen, and a screen can only have one workspace. Just having it as a Map makes it difficult to work with. (ie, right now, it's Map Workspace Screen, so it's easy to get the screen for a workspace, but hard to get the workspace for a screen. I need to be able to do both.)
17:31:43 <dons> heh, nice, http://programming.reddit.com/info/1bluy/comments
17:31:44 <lambdabot> Title: Quick and Dirty Theorem Prover in Haskell (reddit.com)
17:32:00 <dons> jcreigh: we can design a custom data structure
17:32:05 <dons> that will preserve the new constraints
17:32:08 <jcreigh> dons: the answer to everything. :)
17:32:27 <dons> since you really want a Set like structure
17:32:42 <jcreigh> yeah. It's like I want a Set with some contraints.
17:32:45 <dons> note in StackSet how we have a two-way map
17:32:54 <dons> you can map window to workspace, and workspace to window
17:33:00 <dons> so again, there's a 3rd layer, with screens
17:33:13 <dons> so Set Workspace maybe
17:33:22 <dons> and Workspace is the usual Map Window
17:33:32 <sjanssen> perhaps StackSet should contain the screen info too?
17:33:48 <jcreigh> heh. you mean StackSet (StackSet Window)?
17:33:57 <dons> so how do we track screen/workspace at the moment?
17:33:59 <jcreigh> I thought able that.
17:34:22 <jcreigh> dons: right now, it's wsOnScreen, which is a mapping of workspace # to screen #
17:34:42 <jcreigh> s/able/about/
17:34:50 <dons> hmm.oh,
17:34:56 <dons> i see. you keep a separate map
17:35:10 <dons> i think we should move to a single global structure for tracking screen/workspace/window
17:35:21 <dons> that we we can QuickCheck the entire abstraction
17:35:37 <dons> and enforce some nice invariants about workspace/screens
17:36:03 <dons> but .. i'm too busy to work on this till after april 6 i suspect
17:36:46 <jcreigh> hmm.
17:37:11 <dons> the first step would be to work out a suitable api
17:37:17 <dons> combinding workspace and screen calls
17:37:31 <dons> then draft up an abstract screen/stackset data type, QC it
17:37:38 <dons> then port xmonad over to it
17:38:23 <TSC> When I use xmonad, none of the (xmonad) keys do anything... any ideas?
17:38:40 <sjanssen> TSC: try turning of numlock
17:38:46 <sjanssen> s/of/off
17:39:22 <stepcut> does xmonad provide any window decorations? Or is does it just draw borderless windows?
17:39:37 <jcreigh> stepcut: no borders as of yet.
17:39:38 <TSC> sjanssen: Doesn't help ):
17:40:28 <TSC> If I press (for example) Mod-Shift-Enter, it does nothing, but doesn't pass it through to the program with the focus
17:40:39 <TSC> So it must be intercepting it, but not doing the action
17:54:32 <sjanssen> TSC: do you have xev?
17:55:16 <sorear> man, I'm having so much trouble thinking first order
17:55:35 <sorear> I keep seeing "error: Haskell->C: IO ()"
17:55:42 <TSC> sjanssen: Yep
17:55:59 <TSC> By the way, I added a print statement to the key handler; it doesn't seem to run...
17:56:30 <sjanssen> TSC: start xev, and press 'a' in it, what value does it print for 'state'?
17:57:10 <TSC> 0
17:57:18 <sjanssen> hmm
17:57:34 <sjanssen> what does state say when you press mod+a?
17:59:47 <TSC> 8
18:01:07 <sjanssen> try "modKey = 8" instead of mod1Mask
18:01:31 <TSC> Ok
18:03:40 <TSC> Doesn't seem to help; I'll try something else
18:06:42 <TSC> Ok, the problem is that the lookup is failing
18:07:19 <TSC> I put a "print (m,s)" call in the key handler, and it prints (for ModShiftReturn)
18:07:29 <TSC> (154618822665,65293)
18:07:35 <chessguy> > (>>=) [1] (:[])
18:07:37 <lambdabot>  [1]
18:08:13 <sjanssen> TSC: you don't happen to be on a 64 bit platform?
18:08:14 <chessguy> > [1] >>= (:[])
18:08:15 <lambdabot>  [1]
18:08:27 <chessguy> > [1..5] >>= (:[])
18:08:28 <lambdabot>  [1,2,3,4,5]
18:08:38 <TSC> Ahhhhhhh, I do
18:08:48 <sjanssen> shit, I hope that isn't the problem
18:09:36 <sjanssen> TSC: the X11 package (and by extension X11-extras and xmonad) have some questionable FFI stuff with 64 bit
18:09:40 <Igloo> Are you using CInt etc in any foreign imports rather than Int?
18:09:50 <chessguy> @type >>=
18:09:52 <lambdabot> parse error on input `>>='
18:09:58 <chessguy> @type (>>=)
18:09:58 <Igloo> Oh, I think there's a bug about X11 using the wrong types already
18:10:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:10:11 <sjanssen> Igloo: X11 uses Int all over the place
18:10:26 <chessguy> Just 3 >>= Just
18:10:32 <chessguy> > Just 3 >>= Just
18:10:33 <lambdabot>  Just 3
18:10:36 <Igloo> Right, http://hackage.haskell.org/trac/ghc/ticket/987
18:10:37 <lambdabot> Title: #987 (X11: foreign declarations use Haskell types instead of C ones) - GHC - Tra ...
18:10:40 <jcreigh> sjanssen: the whole X11 package? Not just X11-extras?
18:10:40 <chessguy> > Just 3 >>= Nothing
18:10:41 <lambdabot>  Couldn't match expected type `t -> Maybe b'
18:11:09 <sjanssen> jcreigh: yes, all of X11
18:11:14 <jcreigh> crap, that's awful
18:11:32 <Igloo> So, should I assign the bug to jcreigh or sjanssen?  :-)
18:11:46 <sjanssen> heh
18:11:53 <Igloo> Can't blame a guy for trying  :-)
18:12:01 <jcreigh> don't look at me. the Xinerama bindings use CInt and CShort. :)
18:12:13 <sjanssen> well, let's see if a simple search and replace does the job
18:13:48 <Igloo> Hmm, it ought to be easy to write something using the GHC API that complains about anything except certain types being used in foreign imports
18:14:16 <sjanssen> Igloo: it'd make a nice -W flag
18:14:39 <Igloo> Now that is very true
18:14:48 <sorear> I know! Let's make a class ForeignType, and use the TYPE SYSTEM!
18:14:50 <sorear> :)
18:14:51 <sjanssen> on by default, I'd say
18:15:20 <jcreigh> sorear: how do you mean? isn't that basically what Storable is?
18:15:22 <Igloo> sorear: Int isn't necessarily wrong, though
18:15:38 <Igloo> It's just people tend to use Int without thinking when they mean CInt
18:16:04 * Igloo is torn between on by default (== -Wall I assume) and not
18:16:26 <sjanssen> oh dear god, X11 uses CInt exactly five times -- and only in alignment methods for Storable
18:16:58 <Igloo> I wouldn't be surprised if those 5 wree added by Sven when he opened the bug  :-)
18:18:09 <jcreigh> oh, that reminds me. What's the correct way to implement "alignment"? Right now I have "alignment _ = alignment (undefined :: CInt)
18:18:14 <sjanssen> bleh, I don't have the patience to fix this right now
18:18:18 <jcreigh> ...with a worried comment above it.
18:18:26 <sjanssen> jcreigh: that is what I've done too :)
18:18:33 <jcreigh> sjanssen: yeah, I copied what you had. :)
18:18:37 <Igloo> There's an __alignOf or something in the latest C standard IIRC
18:18:45 <sjanssen> hsc2hs should have an alignment macro, methinks
18:19:15 <sjanssen> in most cases it should be the maximum alignment of all component types
18:19:39 <jcreigh> ah, XineramaScreenInfo is an int and 4 shorts, so int alignment should be fine then.
18:25:23 <jcreigh> hmm, so CInt is 64bits on 64bit platforms, right?
18:25:34 <sorear> CInt is usually 32 bits
18:25:50 <sorear> Int is 64 bits due to critical flaws in the STG machine
18:26:01 <jcreigh> "critical flaws"?
18:26:12 <sorear> everything must be the same size
18:26:22 <sorear> basically it assumes the machine is word-addressed
18:26:38 <sorear> ghc has no types smaller than a pointer
18:26:46 <jcreigh> I would have thought that C's int would usually be word-sized.
18:26:48 <sorear> Word8 takes 32 bits unboxed
18:27:18 <TSC> On my 64 bit machine, Int is 64 bits, CInt is 32
18:27:19 <sorear> jcreigh: int is natural sized, 64 bit machines are often faster with 32-bit data for cache reasons
18:27:20 <Igloo> On the most common 64 bit platforms, Int is 64 bit and CInt is 32 bit
18:27:40 <sorear> besides, if int was word-sized, why would we have intptr_t :)
18:29:32 <jcreigh> hopefully time_t is 64bit. :)
18:43:45 <nominolo> when you say CInt is 32 bit, does that mean in C sizeof(int) == 4?  i thought C int is always word-size ..
18:46:42 <stepcut> nominolo: http://www.unix.org/whitepapers/64bit.html
18:46:42 <kc5tja> nominolo: long is the longest wordsize.  int is the "native" wordsize.
18:46:44 <lambdabot> Title: The UNIX System -- 64bit and Data Size Neutrality
18:48:15 <TSC> nominolo: At least in GCC here, int is 32 bit
18:48:59 <kc5tja> That's because in 64-bit mode, the smallest instruction encodings are for 32-bit values.
18:49:06 <stepcut> accordin that that site, there are at least three different 64-bit data models, two of which have int == 32bits
18:49:08 <kc5tja> You need a prefix byte for 64-bit registers.
18:49:22 <nominolo> interesting
18:49:25 <kc5tja> Well, assuming AMD-64.
18:49:38 <kc5tja> err x86-64 I should say.
18:49:53 <nominolo> kc5tja: or x86e ;)
18:50:06 <nominolo> er, no. IA32e
18:50:33 <kc5tja> Where did that mode name come from?
18:51:09 <nominolo> well, since Intel uses IA64 for Itanium, it had to come up with something different for x86-64
18:51:21 <nominolo> where x86 == IA32
18:51:26 <kc5tja> Oh, so Intel's calling it IA32e now.  Hehe.
18:51:33 <kc5tja> I was wondering where it came from.  I haven't seen it before.
18:51:41 <nominolo> at least, last time i checked the manual
18:51:54 <nominolo> manual_s_, that is
18:53:03 <kc5tja> Yeah; at least there are manual_s_ now; I remember back in the day when Intel was feisty about even revealing the most basic stuff about the chip.
18:53:07 <kc5tja> err
18:53:11 <kc5tja> dang it, I can't type.
18:53:18 <kc5tja> about the *Pentium architecture*.
18:53:32 <kc5tja> The infamous "Appendix H" comes immediately to mind, for example.
18:54:02 <nominolo> i guess i'm too young for this.  or i lived too long in the dos-world
18:54:03 <jcreigh> really? If you built CPUs, wouldn't you want as many people to know as much as possible about them?
18:54:10 <jcreigh> seems strange
18:54:40 <kc5tja> jcreigh: Intel went through this phase where they wanted only companies like Microsoft  and IBM to access the sensitive optimization information, for two reasons:
18:54:45 <kc5tja> 1) They wanted the licensing revenue, and,
18:55:00 <kc5tja> 2) They were afraid disclosing the data would reveal to competitors too much knowledge of how their chips worked on the inside.
18:55:11 <stepcut> jcreigh: well, if you build CPUs + compilers, then you might be dupped into thinking there is a great advantage to keeping things secret
18:55:26 <kc5tja> Of course, when AMD re-architected the x86 in Verilog for the first Athlon, they proved that such fears were unfounded -- AMD could kick their butts *without* Appendix H.  :)
18:56:23 <nominolo> x86 really is incredibly ugly
18:57:00 <kc5tja> Unfortunately so.
18:57:13 <nominolo> mips and ppc is pretty nice
18:57:19 <kc5tja> But it is a workable architecture, and it can be made to do things quickly despite the lack of registers.
18:57:20 <jcreigh> registers? We don't need no stinking registers.
18:57:30 <nominolo> although x86 has advantages in integer performance
18:57:49 <nominolo> due to smaller instruction cache bandwidth requirements
18:57:55 <kc5tja> nominolo: I think with the same techniques used by Intel applied to PowerPC/MIPS, they would decimate the x86.
18:57:56 <stepcut> jcreigh: I used to work for a company that made a register-less CPU :p
18:58:17 * kc5tja prefers stack architecture processors.
18:58:18 <stepcut> didn't sell very well though...
18:58:23 <jcreigh> stepcut: how would that work? I wrote a register-less VM once, but it was a joke.
18:58:37 <jcreigh> oh, stack-based?
18:58:50 <kc5tja> Yup
18:58:53 <nominolo> kc5tja: i don't thinks so,  large instruction words have some inherent disadvantages
18:58:59 <stepcut> jcreigh: it was a stack based processer. Most of the instructions were direct implementations of forth instructions :)
18:59:13 <nominolo> kc5tja: you might do instruction compression, though.
18:59:23 <kc5tja> nominolo: ARM produced a reduced instruction set that was only a 16-bit opcode set; it's doable.
18:59:29 <kc5tja> Yeah, that's what I mean.
19:00:03 <kc5tja> jcreigh: I recommend reading the book "Stack Computers, a New Wave" for a detailed explanation of how 0-operand processors work.
19:00:18 <nominolo> kc5tja: hm.  yes, there's more research in that field, too.  I think I really have to take a look
19:00:35 <stepcut> the stack-based processor I worked with had 8-bit instructions, but a 32-bit data/code path
19:00:55 <kc5tja> stepcut: I'm a fan of MISC myself.
19:00:56 <greenrd> I think I've asked this before, but does template haskell support MPTCs?
19:01:04 <stepcut> so, it would fetch 4 instructions at a time
19:01:11 <jcreigh> isn't the JVM literally bytecode? (ie, 8bit instructs?)
19:01:13 <kc5tja> For my Kestrel, I was planning on toying with the idea of making a 64-bit MISC architecture processor.
19:01:17 <jcreigh> *instructions
19:01:37 <kc5tja> stepcut: Yeah, that's how MISC works.  1 cycle for pure opcode fetch, 4 cycles to execute opcodes.
19:01:47 <kc5tja> Amortized performance is 1.25 cycles per instruction then.
19:01:57 <nominolo> what does the M in MISC stand for?
19:02:00 <kc5tja> Minimal
19:02:15 <kc5tja> It's not uncommon to see MISC chips with 5-bit opcode fields.
19:03:02 <stepcut> are there any stack-based microprocessors on the market these days ?
19:03:02 <kc5tja> The Steamer16 homebrew MISC (which is NOT a Forth processor, BTW) has 3-bit opcodes, and packs 5 to a 16-bit word.  It runs about as fast as an 80386 at the same clock speed.
19:03:36 <kc5tja> stepcut: Patriot Scientific offers the PTSC-1000.  RTX-2000 is still available to government sources (it's a rad-hardened chip, and finds applications in space)
19:03:42 <Pseudonym> One of these days I'd like to try implementing a counterflow CPU.
19:03:58 <kc5tja> I think the FPGA market killed the stack architecture market, though, because it's so easy to roll your own with FPGAs.
19:04:01 <Pseudonym> IMO it's the cheapest way to get scuperscalar.
19:04:08 <Pseudonym> superscalar
19:04:15 <kc5tja> Pseudonym: What is counter-flow?
19:04:26 <stepcut> kc5tja: does patriot scientific still sell them? (not that they ever really did), I think they just sue people now
19:04:31 <Pseudonym> http://research.sun.com/techrep/1994/abstract-25.html
19:04:32 <lambdabot> Title: Counterflow Pipeline Processor Architecture
19:04:45 <Pseudonym> You'll probably recognise the authors.
19:04:45 <stepcut> kc5tja: that is where I used to work, btw
19:04:46 <kc5tja> stepcut: Yes, you can still purchase the chips from them.
19:04:55 <kc5tja> From what I understand at least.
19:05:16 <Pseudonym> Basically, it's a superscalar architecture where ALL decisions are local.
19:05:24 <kc5tja> stepcut: The fact that they're suit-happy is what prompted me to investigate transport-triggered architectures for the Kestrel before finally settling on the 65816.
19:05:31 * nominolo `ap` bed
19:05:33 <Pseudonym> No need to worry about this hazard by providing yet another data path.
19:05:46 <stepcut> "The company's legacy product brands (below) are no longer in production, as today, Patriot Scientific is focused on licensing its patent portfolio and intends on applying its resources towards investments in innovative technologies and solutions that create sustainable value to our customers and shareholders. "
19:06:04 <dons> sjanssen, Igloo: yes, X11 is just wrong wrong wrong wrt. Int/CInt
19:06:05 <kc5tja> Pseudonym: I was thinking of a stack architecture that had a master thread of control, and 1 or more "child" threads which work together as independent pipelines, but which were all bounded by basic blocks.
19:06:13 <Pseudonym> Right.
19:06:20 <QtPlatypus> stepcut: Is that market speek for "We are patent trolls"?
19:06:26 <stepcut> kc5tja: I left shortly after finding out the CTO had a mail-order PhD ;)
19:06:36 <kc5tja> (thus allowing a compiler to schedule concurrent statements of execution, but which still preserved the "sequential" nature of traditional computation models)
19:06:47 <dons> stepcut: you can get them in the mail now!? why didn't anyone tell me!!
19:06:50 * dons has wasted 4 years
19:07:03 <Pseudonym> kc5tja: I think you'd be impressed with the counterflow pipeline tech report.
19:07:12 <stepcut> dons: yep, as long as you don't need one from an accredited university
19:07:19 <kc5tja> Pseudonym: I'm reading it now.
19:07:22 <Pseudonym> It does raise some interesting questions, but the way it deals with sequential computation is simple and obvious.
19:07:36 <kc5tja> The nice thing with stack architectures is they don't need pipes.  This is of immense value.
19:07:54 <Pseudonym> Unfortunately, the main problem is that as presented, it can't issue multiple instructions per cycle.
19:08:04 <sjanssen> dons: yet another reason to write xhb
19:08:06 <Pseudonym> That's not an insurmountable problem.
19:08:09 <stepcut> we need to take House+Handheld computer, and make a Lisp Machine killer
19:08:31 <jcreigh> stepcut: but the Lisp Machine is already dead
19:08:37 <stepcut> jcreigh: crud.
19:08:47 * stepcut thinks up a new plan
19:10:09 <procyon_> stepcut: There's always more to kill
19:12:40 <stepcut> perhaps a BeOS killer ?
19:18:48 <moconnor> What's the syntax to create an anonymous function two varaibles?  \(x,y) -> x + y takes a tuple as an argument and \x,y -> x + y is giving me a parse error at the ,
19:18:58 <jcreigh> \x y -> x + y
19:19:05 <moconnor> jcreigh: bah!  thank you
19:19:07 <dmwit> Or, in that case, just (+).
19:19:29 <moconnor> dmwit: yeah, that was a simple case for the sake of the question.
19:19:37 <dmwit> Right, okay.
19:20:39 <stepcut> you could also do, \x -> \y -> x + y, but there is no real reason to
19:20:42 <procyon_> or, since currying is automatic, you can \x -> \y -> x + y
19:20:47 <jcreigh> haha
19:20:53 <stepcut> procyon_: jinx
19:20:56 <procyon_> lol
19:21:26 <kc5tja> Pseudonym: I'm reading the paper, and the author is simply not clear at all about how this thing works.
19:21:34 <kc5tja> Pseudonym: At least, I'm not getting it at all.
19:23:38 <shapr> stepcut: You're thinking House on the Nokia 770?
19:23:54 <stepcut> shapr: if I had the time, yes
19:24:06 <stepcut> shapr: but, with a prettier widget set ;)
19:25:13 <shapr> The closed source wifi and bluetooth modules would be a problem, but the rest would be fine.
19:25:23 <shapr> Er, wait .. only the firmware is closed now.. it'd work fine!
19:25:35 <stepcut> right
19:25:47 <shapr> That's tempting.
19:25:48 <stepcut> the only major problem is the DSP
19:25:53 <shapr> How so?
19:26:16 <stepcut> well, if you ignore it, it is not a problem, but there is no free C compiler for it, AFAIK
19:26:17 <Pseudonym> kc5tja: You have to go through the examples, I think.
19:26:23 <Pseudonym> It took me a couple of readings to get it.
19:26:35 <stepcut> shapr: could be ignored for v1.0 though
19:26:56 <kc5tja> Pseudonym: That's what I mean.  The text isn't clear.  And, the examples aren't terribly all that clear either.  :(
19:27:10 <kc5tja> I can't even say it's a bad idea -- that's how much I "can't get" from the paper.  :)
19:27:27 <Nafai> Hello!
19:27:42 <kc5tja> I'm glad new ideas are being thought of though.  The architecture of the super-pipe with the memory accessors on one side and "other stuff" on the other side looks like a nice hardware refactoring.
19:27:49 <stepcut> shapr: I think it is very doable -- just too time consuming for me to do it :(
19:28:02 <kc5tja> Nafai: Greetings.
19:28:04 <Pseudonym> Yeah.
19:28:16 <Pseudonym> The real problem with this is that a pipeline interrupt is REALLY expensive.
19:28:32 <Pseudonym> Like, say, a branch misprediction.
19:28:33 <stepcut> shapr: and, I am not sure if the world market for handheld haskell computers is big enough to get startup funding :p
19:28:42 <Pseudonym> Possibly more expensive than on a COTS CPU.
19:28:52 <Nafai> stepcut: That would certainly be cool though
19:29:16 <stepcut> Nafai: indeed
19:29:26 <shapr> stepcut: Sure would be fast though.
19:29:28 <kc5tja> Pseudonym: Yeah, you're effectively doubling the length of the pipeline with having stuff going in two directions.
19:29:57 <kc5tja> stepcut: I would be happy to (help) design the core MISC engine.  :D
19:30:23 <stepcut> kc5tja: I think step 1 is port to the Nokia 770/800, since the hardware exists today, step 2 is create a new hardware platform
19:30:39 <kc5tja> Oh, I don't care about handhelds.
19:30:39 <jcreigh> @hoogle (a -> Bool) -> [a] -> Bool
19:30:39 <jcreigh> ah, of course. "any"
19:30:40 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
19:30:40 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
19:30:41 <kc5tja> I never use them.
19:31:31 <kc5tja> Maybe, if you're good, I'll make a stack-based version of Kestrel, and let you compiler hackers have at it for porting Haskell to it.
19:31:39 <greenrd> For future reference, the answer to my earlier question is yes, Template Haskell does support MPTCs (I found a reference to fundeps in the API)
19:31:41 <stepcut> kc5tja: well, we could target desktops and handhelds. Using mobile byte-code, your handheld would suddenly get faster when you got within wireless distance of your desktop ;)
19:31:55 <Pseudonym> kc5tja: You're not doubling the length of the pipeline, exactly.  It's more complicated than that.
19:32:03 <Pseudonym> Or less complicated, actually.
19:32:27 <Pseudonym> But to kill the pipeline, you need to pass a message all the way down from the point where it happened.
19:32:49 <Pseudonym> And that means you need to rendezvous with every instruction below and kill it manually.
19:33:09 <chessguy> @type flip flix
19:33:11 <lambdabot> Not in scope: `flix'
19:34:24 <shapr> greenrd: Good to know... btw, let's have veggie food again sometime.
19:34:29 <kc5tja> A thought just occured to me; I wonder, assuming substantially better instruction timings, how applicable would a TMS9900 be towards executing Haskell?  :)
19:34:29 <shapr> greenrd: That was fun.
19:39:10 <chessguy> ?losers
19:39:11 <lambdabot> Maximum users seen in #haskell: 336, currently: 298 (88.7%), active: 39 (13.1%)
19:39:29 <chessguy> hm. was i the only one that just had trouble connecting to freenode?
19:40:12 <siti> I am using the http library to read in many contents of webpages, then processing them. My issue is all it's all done lazily so there are an enormous number of file handlers left open.  How can I make getting the contents strict?
19:40:30 <hpaste>  vincenz pasted "yucky?" at http://hpaste.org/1060
19:40:55 <chessguy> siti, you can use seq
19:41:30 <siti> does bang patterns have the same effect I am currently (attempting) to use them to make it strict
19:41:35 <siti> and it does not seem to help :(
19:41:41 <stepcut> siti: people often do something like, (length c) `seq` ....
19:41:58 <siti> arg that's ugly but I guess it will work :(
19:41:59 <stepcut> or, evaluate (length c)
19:42:12 <tcoppi> quick question, is there a book anyone would recommend to learn haskell?
19:42:21 <chessguy> ?where books
19:42:22 <lambdabot> http://www.haskell.org/haskellwiki/Books_and_tutorials#Textbooks
19:42:31 <stepcut> siti: or, if you can help it, don't use hGetContents, and manage everything explicitly
19:42:41 <tcoppi> chessguy: thanks
19:42:59 <chessguy> @type seq
19:42:59 <siti> stepcut: I am not using hGetContents, but the http module might be
19:43:01 <lambdabot> forall a t. a -> t -> t
19:43:24 <stepcut> siti: ah
19:43:47 <araujo> hi hi!
19:43:53 <stepcut> siti: i take it the http module does not give you a file Handle either ?
19:43:56 <chessguy> araujo!
19:44:04 <araujo> chessguy!!!
19:44:04 <siti> nope
19:44:39 <stepcut> siti: then, i think you probably have to do something that forces all the data to be read, so that the connection will be closed automatically
19:44:53 <siti> yep
19:45:11 <siti> I'll try out that length trick/hack
19:45:53 <stepcut> siti: yeah, seq by itself only reduces the expression to WHNF, so for a list like, (1:2:3:[]), it only reduces it till it sees the first (:), then it stops
19:46:05 <siti> yeah
19:46:07 <stepcut> siti: but for length, it reduces it till it gets the actually length back
19:46:11 <siti> yep
19:46:21 <siti> and bang patterns does the same?
19:46:38 <stepcut> @src ($!)
19:46:38 <lambdabot> Source not found. Are you on drugs?
19:47:03 <sjanssen> siti: yeah, bang patterns are essentially seq's
19:47:23 <stepcut> siti: which bang patterns? There is the function ($!), there are ! in the data declarations, and then, I think in 6.6 there is some other bang pattern stuff
19:48:07 <siti> I have only tried using ! on function args...
19:48:17 <stepcut> ($!)    :: (a -> b) -> a -> b
19:48:17 <stepcut> f $! x  = x `seq` f x
19:48:53 <siti> ok
19:49:07 <stepcut> siti: ah, I must confuse, I am behind the times, and have not learned about that use of ! yet
19:49:32 <sjanssen> siti: most things with ! mean strict, and are somehow related to seq
19:50:07 <siti> ok
19:50:37 <Pseudonym> The ones that aren't related to indexing.
19:50:41 <Pseudonym> Like (!) and (!!).
19:54:17 <greenrd> shapr: :)
19:55:18 <greenrd> shapr: I'm currently writing a generic programming tool for the Coq proof assistant, and I'm using two Haskell generic programming features (Data.Generic and TH) to implement it!
19:56:00 <kc5tja> Pseudonym: I think I get it now; it is definitely an elegant solution to a lot of control problems.
19:56:11 <kc5tja> And, yes, speculative execution can definitely be very expensive.
19:56:19 <greenrd> shapr: and the code in Coq that I'm generating is itself talking about a third language
19:56:28 <kc5tja> But, according to the paper, stages 2, 1, and 0 are all equipped with the *same* ALU circuitry.
19:56:44 <greenrd> shapr: Multilevel metaprogramming is cool.
19:56:44 <vincenz> greenrd: ooh interesting, have any links regarding that?
19:57:04 <kc5tja> Therefore, it ought to be possible for the I stage to skip stages 0 and/or 1 in some circumstances.
19:57:27 <greenrd> vincenz: not really, I've only been working on the project for a few weeks
19:57:35 <siti> weird, even if I print out the page it still builds up file handles :S
19:57:53 <vincenz> greenrd: hwo are you modelling that third language? operational semantics?
19:58:38 <greenrd> well, the third language is McBride and Altenkirch's "Observational Type Theory"
19:58:46 <chessguy> nice, Backus essentially invented State monads 30 years ago: http://scienceblogs.com/goodmath/2007/03/backuss_idea_of_functional_pro_1.php
19:58:46 <vincenz> ah
19:58:48 <lambdabot> Title: Good Math, Bad Math : Backus's Idea of Functional Programming, http://tinyurl.com/yq8gwh
19:59:37 <greenrd> ok, off to bed
20:00:33 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict-0.1
20:00:34 <lambdabot> http://tinyurl.com/23lbr4
20:02:27 <kc5tja> Pseudonym: There is a pretty critical flaw in the design though -- it's entirely possible for a register fetch to bypass completely the stage where it's needed.
20:02:43 <Pseudonym> kc5tja: Yes.
20:02:52 <Pseudonym> Ah, hang on.
20:02:59 <sjanssen> Donald "the release factory" Stewart :)
20:03:00 <Pseudonym> No, a register fetch can't bypass the stage where it's needed.
20:03:31 <Pseudonym> There is an issue with different stages having the same ALU circuitry.
20:03:40 <Pseudonym> Do you execute it here, or do you advance?
20:03:53 <Pseudonym> And there are subsequent papers which help answer that question.
20:04:05 <kc5tja> I just verified that it can happen.  By injecting a register result at the time an instruction enters the Decode stage in figure 3, it's entirely possible for the source values for an "Add" to miss the instruction in the adder stage.
20:04:18 <Pseudonym> Hang on, let me look at the paper.
20:04:53 <kc5tja> Unless I'm missing/overlooking something.
20:05:12 <Pseudonym> OK, I'm on figure 3.
20:05:43 <Pseudonym> Oh, I see what you're saying.
20:06:04 <Pseudonym> The key constraint here is that an instruction is not allowed to pass the last place where it can possibly be executed if it hasn't been executed.
20:06:22 <Pseudonym> That's P3.
20:06:40 <Pseudonym> On page 4.
20:07:02 <Pseudonym> So if an add instruction reaches the last adder and hasn't been executed yet, then it has to wait.
20:07:22 <kc5tja> Pseudonym: You're missing MY point.
20:07:31 <Pseudonym> I possibly didn't quite understand what you said.
20:07:37 <Pseudonym> Try again/
20:07:38 <Pseudonym> ?
20:07:40 <kc5tja> Pseudonym: The operands required for an addition *pass* the stage *before* the add instruction gets to that stage.  :)
20:07:48 <Pseudonym> Yup.
20:08:16 <kc5tja> That means it must wait potentially forever for the sources to recirculate through the pipe -- there's a potential for deadlock.
20:08:46 <Pseudonym> Nope, you've lost me.
20:08:58 <Pseudonym> When an instruction is decoded, a signal is sent to the register file, right?
20:09:10 <Pseudonym> And the results start moving down the pipeline.
20:09:31 <Pseudonym> Eventually, those results will meet the add instruction.
20:09:43 <Pseudonym> At which point, the operands get filled in.
20:09:50 <Pseudonym> This may be BEFORE the add execution unit.
20:09:53 <Pseudonym> In fact, we hope it is.
20:10:22 <kc5tja> But how does the add unit know to grab the sources?
20:10:32 <Pseudonym> The decision is made locally.
20:10:43 <Pseudonym> Every instruction has to interact with every result that it meets.
20:10:45 <kc5tja> Before the ADD instruction even arrives?
20:11:22 <Pseudonym> And P3 guarantees that this will happen before the instruction is executed.
20:11:45 <kc5tja> There is still a fundamental loss of synchronicity.
20:11:50 <kc5tja> I just don't see it.
20:13:36 <Pseudonym> The only "loss of synchronicity" is that the register file is not the "one true version" of the machine state.
20:13:42 <Pseudonym> But that's true in most modern CPUs.
20:16:53 <kc5tja> Pseudonym: I still don't see it.
20:17:16 <kc5tja> The rules provided do not take into account "the future," which is the only way to resolve the problem I'm seeing in figure 3.
20:17:48 <Pseudonym> What's the problem with the future?
20:17:59 <Pseudonym> That the values garnered may be wrong, because of future execution?
20:20:11 <kc5tja> No, that the results of the addition will be missed all-together because the operand-arrival and opcode-arrival are not the same moment in time.
20:21:12 <Pseudonym> Arrival at what point?
20:21:23 <Pseudonym> OK, the results of the addition.
20:21:25 <Pseudonym> Two things.
20:21:48 <Pseudonym> 1. Execution of the addition inserts the result into the right-hand side of the pipeline.
20:21:53 <Pseudonym> So everything below it gets the right result.
20:22:26 <Pseudonym> 2. If the executed addition meets a new result binding coming down, it replaces the result with the result from the instruction.
20:22:55 <Pseudonym> That way, everything below this instruction gets the right binding.
20:23:38 <kc5tja> I understand that.
20:24:02 <kc5tja> My point is, when ADD finally arrives at the Adder Input stage, the operands have already *passed* the adder input.
20:24:09 <Pseudonym> Yes.
20:24:13 <Pseudonym> And have been filled in.
20:24:14 <kc5tja> The adder siding has *no idea* that the *previous* sources were to be used as operands.
20:24:33 <Pseudonym> Let's look at this for a moment.
20:24:41 <Pseudonym> An add instruction looks like this: R2 <- R0 + R1
20:25:05 <Pseudonym> The results start coming down from the register file.
20:25:11 <Pseudonym> Say R0 = 1 and R1 = 2
20:25:27 <Pseudonym> If the result R0 = 1 meets the add instruction, it gets modified to:
20:25:31 <Pseudonym> R2 <- 1 + R1
20:25:51 <Pseudonym> And when the R2 = 2 result meets the instruction, it gets modified to:
20:25:54 <Pseudonym> R2 <- 1 + 2
20:25:59 <Pseudonym> At that point, it can be executed.
20:26:11 <Pseudonym> And it's not allowed to pass the last adder until both operands have been filled in.
20:26:59 <kc5tja> The add instruction must not pass the Add Input stage then until both operands are there.
20:27:07 <Pseudonym> Right.
20:27:18 <Pseudonym> Or, if there are multiple add ALUs, the _last_ Add Input stage.
20:29:09 <jcreigh> sjanssen: what do you think of modkey-{w,e,r} to switch screens, and shift-modkey-{w,e,r} to tag a window to the workspace on that screen?
20:29:56 <mbishop> anyone here know who wrote http://mbishop.esoteriq.org/poly.txt ?
20:31:05 <sjanssen> jcreigh: sounds good
20:31:45 <Pseudonym> kc5tja: Is it that you can't see how those results might arrive there?
20:31:55 <Pseudonym> To fill in the add instruction?
20:32:04 <sjanssen> I want to FFI a C function that returns a struct.  Is this possible without C wrapper code?
20:32:07 <kc5tja> No, I see it now.
20:32:10 <Pseudonym> Right.
20:32:17 <kc5tja> I'm working on another problem though -- result forwarding from the multiplier to the adder.
20:32:24 <Pseudonym> Ah.
20:32:29 <Pseudonym> That's the really clever bit.
20:32:32 <kc5tja> I think they're too close.
20:32:36 <Pseudonym> It's rule M1.
20:32:56 <Pseudonym> Figure 3 is just an example, BTW.
20:33:11 <Pseudonym> I wouldn't have laid out the execution units in those places.
20:33:45 <Pseudonym> I agree: they are too close, and will probably cause more stalls than it would if it was laid out more sensibly.
20:33:54 <Pseudonym> But the results will be correct.
20:34:02 <kc5tja> I don't even think they'll have the opportunity to stall at all.  :)
20:35:09 <kc5tja> Oh, no, it would.
20:35:18 <kc5tja> But an add-after-mul will introduce a pipeline bubble.
20:35:19 <kc5tja> WHOOPS.
20:35:29 <kc5tja> Forget DSP work.  ;D
20:35:33 <Pseudonym> :-)
20:35:54 <kc5tja> You know, the architecture of the sidings is *almost* like a transport-triggered architecture.
20:36:01 <Pseudonym> Yeah, almost.
20:36:15 <Pseudonym> That hadn't occurred to me before, but you're right.
20:36:18 <kc5tja> This is a pretty slick architecture design.  I think it has a lot of potential.
20:36:24 * Pseudonym nods
20:36:51 <Pseudonym> I love it that it's superscalar, but all decisions are local.
20:37:10 <Pseudonym> There's a subsequent paper by different authors, who point out that you could make the pipeline circular.
20:37:11 <kc5tja> Yes.  I like the idea a lot.
20:37:23 <kc5tja> I think it needs more work, of course, but the basic idea is sound.
20:37:23 <Pseudonym> So instructions can keep going around until they're executed.
20:37:27 <Pseudonym> Which completely avoids the stalls.
20:37:52 <kc5tja> Yikes!  Circular pipelines haven't been used since the CYBER 604 supercomputer.  :)
20:38:04 <Pseudonym> And, even cooler, once you've done that, you can stick another instruction fetch unit anywhere you like on the circle, and you have hyperthreading.
20:39:07 * kc5tja should attempt to model a 6502 with this idea, to see if I can push the architecture over the edge.  :D
20:39:14 <Pseudonym> :-)
20:39:37 * kc5tja has a hyperthreaded, superscalar 6502, baby!  Beat THAT!  ;D
20:39:46 <Pseudonym> The problem with that is that you won't have the predictable instruction timings that you get with a real 6502, so most of the C64 demos won't work,.
20:40:18 <kc5tja> Meh -- those don't interest me.
20:40:33 <Pseudonym> Isn't that the only reason why anyone would want a 6502?
20:40:43 <kc5tja> Nope.
20:41:01 <kc5tja> The 6502 and 65816 are still used a *lot* in embedded space because it's a smaller, faster, cheaper processor than some of the other alternatives.
20:41:20 <kc5tja> Most 6502/65816 implementations are synthesized via Verilog or VHDL, under license from Western Design Center.
20:41:49 <Pseudonym> Oh, I see what you mean.  A 6502 plus ASIC stuff on one die.
20:42:08 <kc5tja> I remember one report where a licensee had produced an ASIC with a 500MHz 6502 on it.  Imagine that beast inside your VIC-20.
20:42:21 <jcreigh> sjanssen: patch sent. The function I had to write to make it work is pretty ugly...if you have any ideas on the ideal data structure to represent the one-to-one mapping of screens <-> workspaces, I'd love hear them.
20:42:26 <Pseudonym> :-)
20:42:36 <Pseudonym> My first micro had an RCA CPD-1802.
20:42:41 <kc5tja> The 65816 is a better choice for this type of stuff though.
20:42:42 <Pseudonym> Same CPU as Voyager 2.
20:43:07 <Pseudonym> Not the exact same one, obviously, but same model.
20:43:15 * kc5tja nods
20:43:18 <kc5tja> Same family processor.
20:43:24 <jcreigh> sjanssen: so, with the addition of tiling, did the number of xmonad users take off? Or is the user list still visible via a "darcs changes"? :)
20:43:56 <kc5tja> jcreigh: xmonad supports tiling now?
20:43:59 <Pseudonym> The only micro which was radiation-hardened, I think.
20:44:01 <jcreigh> kc5tja: yes
20:44:21 <kc5tja> Pseudonym: At the time; the RTX-2000 (Stack-based architecture) followed, and later, the 80286.
20:44:28 <kc5tja> (Hubble Space Telescope runs on an 80286!)
20:44:29 * Pseudonym nods
20:44:34 <Pseudonym> Oh, woo!
20:44:50 <kc5tja> I think the Z-80 has been rad-hardened too now.
20:45:04 <Pseudonym> A lot of CPU + ASIC chips seem to use MIPS.
20:45:14 <kc5tja> <3 MIPS!
20:45:16 <Pseudonym> It'd be nice if you could license AVR.
20:45:26 <Pseudonym> I reckon it'd be better than 6502.
20:45:29 <kc5tja> I like AVR, but not enough to license it.
20:45:33 <kc5tja> Nope!!
20:45:37 <Pseudonym> It's a proper Harvard architecture for one.
20:45:41 <kc5tja> The 6502 is actually faster than the AVR for most tasks.
20:46:08 <Pseudonym> Really?
20:46:11 <Pseudonym> How does that work out?
20:46:26 <kc5tja> Although the AVR can run instructions faster, you need more of them to do the same kinds of things the 6502 does.
20:46:37 <kc5tja> SO it's faster at raw bit-banging performance, but that's it.
20:46:40 <Pseudonym> I thought it'd be something like the simple addressing modes.
20:46:43 <kc5tja> Also, the 6502 has a shorter interrupt latency.
20:47:15 <Pseudonym> Do you have an example of an operation that's faster on the 6502?
20:47:19 <sjanssen> jcreigh: I'm not sure how many users we might have picked up
20:47:22 <Pseudonym> Apart from interrupt delivery; I buy that.
20:47:25 <kc5tja> AVR has simpler addressing modes, but you can only address memory with X, Y, and Z, of which only Z is truely general purpose.
20:47:34 * Pseudonym nods
20:47:37 <sjanssen> jcreigh: I know dons, shapr, you and I use it
20:47:44 <sjanssen> jcreigh: I know SamB has tried it out
20:47:55 <sjanssen> TSC wanted to but X11 sucks
20:48:20 <kc5tja> jcreigh: I'll try to compile it a bit later.
20:49:25 <Pseudonym> And the 6502 has even fewer general-purpose registers than that!
20:49:25 <kc5tja> So, the only precondition necessary for counter-flow architectures is that the sources must be preloaded from results before the instruction reaches a stage where it'd be needed.
20:49:27 <TSC> ):
20:49:47 <Pseudonym> Well not just that, but yes.
20:49:47 <jcreigh> sjanssen: heh...the initial import is March 6th...hard to believe it's only 2 weeks old. (Plus however long you worked on it before making the darcs repo)
20:49:49 <kc5tja> Pseudonym: Yup.  Most of the logic comes in knowing when/how to use its addressing modes.  :)
20:49:57 <TSC> I tried haphazardly changing "Int"s into "CInt"s, but nothing changed
20:50:11 <sjanssen> TSC: in both X11 and X11-extras?
20:50:17 <TSC> Yeah
20:50:33 <TSC> I don't know a lot about FFI
20:51:03 <sjanssen> probably _every_ Int in both of those libraries should be CInt
20:51:39 <TSC> Not all of them; some are arguments to peekOffset, and the offset should be Int
20:51:52 <sjanssen> oh, hmm
20:52:01 <sjanssen> damn, nothing is simple
20:52:14 <bos_> @seen dons
20:52:14 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 51m 41s ago.
20:52:16 * dmwit goes to boot into Linux to try xmonad
20:52:32 * sioraiocht fears xmonad.
20:52:44 <sjanssen> TSC: every Int in a foreign import should be CInt, and then we tweak until it compiles
20:52:51 <kc5tja> Pseudonym: I think the counterflow pipeline is going to be slower than current methods, because of the pipeline bubbles it produces.  But, it is a *slick* design.
20:52:52 <bos_> sioraiocht: whence the nick?
20:53:06 <fantasmaa> @where fantasmaa
20:53:06 <lambdabot> I know nothing about fantasmaa.
20:53:08 <sioraiocht> bos_: means 'eternity' in irish
20:53:14 <bos_> sioraiocht: i know :-)
20:53:15 <Pseudonym> Yeah.
20:53:29 <TSC> That's more or less what I did
20:53:34 <Pseudonym> The authors comment that the main reason why they came up with it is that it's easy to make it asynchronous.
20:53:35 <sjanssen> TSC: many of the type synonyms should be CInt too, like KeyMask (your specific problem)
20:53:48 <kc5tja> Oh, if it's asynchronous, then bubbles almost don't matter.
20:54:02 <Pseudonym> kc5tja: http://ieeexplore.ieee.org/iel3/5242/14198/00650572.pdf?arnumber=650572
20:54:06 <kc5tja> They'll collapse on their own much faster than on a synchronous design.
20:54:06 <lambdabot> http://tinyurl.com/266679
20:54:15 <Pseudonym> You might also like to read that.
20:54:22 <sioraiocht> bos_: bhuel, tÃ¡ gaeilge agam agus is maith liom an focal =)
20:54:58 <bos_> sioraiocht: nÃ­l a lÃ¡n gaeilgÃ³irÃ­ anseo :-)
20:55:23 <TSC> sjanssen: It says KeyMask = Modifier = Mask = Word64
20:55:37 <sjanssen> oh, huh
20:56:03 <sioraiocht> bos_: TÃ¡.  An Eireannach tÃº?
20:56:41 <bos_> is annamh a bhfeicim Ã©inne a bhfuil gaeilge acu, agus mise i meiriceÃ¡ le deich bliain
20:56:56 <bos_> 'sea
20:57:04 <bos_> pardon the geeking in foreign languages.
20:58:53 <sioraiocht> hahaha
21:00:45 <sioraiocht> bos_:  Is MeiriceÃ¡nach mÃ©.  D'fhoghlaim mÃ© mo Ghaeilge i gcÃ³laiste.  An as Gaeltacht duit?
21:01:28 <bos_> nÃ­l. bhÃ­ orm Ã© a leabhairt ar scoil.
21:02:24 <bos_> haskell's a bit like irish. messes with your head pretty severely, even though you're doing substantially the same things as usual.
21:02:35 <sioraiocht> hahaha, I would say irish is far crazier
21:02:42 <sioraiocht> I
21:02:59 <sioraiocht> I'm surprised, i have a few irish friends that remember none of their irish
21:03:41 <sioraiocht> and to be honest, that's the longest convo I've had in it since my last class, hope my grammar wasn't horrendous
21:03:58 <bos_> no, quite impressive :)
21:04:10 <xpika> how can i output a unicode character to the stdin?
21:04:15 <sioraiocht> haha.  So where do you live in the states now?
21:04:22 <xpika> s/stdin/stdout/
21:04:36 <bos_> beautiful san francisco.
21:04:50 <jcreigh> is that near ugly san francisco? :)
21:04:52 * jcreigh ducks
21:04:57 <sioraiocht> I'm from Orange County, lol.  What brought you near Ireland
21:05:02 <bos_> the two are right next to each other.
21:05:03 <dmwit> ?where xmonad
21:05:03 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
21:05:05 <sioraiocht> jcreigh: yes, it's called Oakland
21:05:16 <sioraiocht> err
21:05:19 <sioraiocht> near = from
21:05:53 <xpika> :(
21:05:55 <bos_> many more interesting jobs in silly valley.
21:06:04 <bos_> could never get a job as a lisp hacker in ireland.
21:06:11 <sjanssen> @where X11-extras
21:06:11 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/X11-extras
21:06:16 <sjanssen> dmwit: ^^^ that too
21:06:21 <sioraiocht> hahah, touchÃ©
21:06:28 <sjanssen> @hackage X11
21:06:28 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
21:06:30 <xpika> i need to print something like "Ä‚" from a haskell program
21:06:42 <dmwit> sjanssen: How about the other dependencies listed in the README, should I ignore them?
21:06:43 <sioraiocht> I'm actually moving to the UK for school, soon.  I hope to spend some of my free time in Ireland
21:06:48 <sioraiocht> I've actually never been =p
21:06:55 <sjanssen> dmwit: you'll need all the deps
21:07:02 <sjanssen> (but you might already have X11)
21:07:04 <dmwit> k
21:07:36 <bos_> sioraiocht: get your liver into training now, then.
21:08:32 <sioraiocht> bos_: I've heard.  I met an Irishman when I was in Oxford a few years ago.  I went drink for drink with him...or I think I did..people tell me...I can't arelly remember...
21:09:05 * sioraiocht mutters about stupid Oxonian undergrads and their stupid drinking games...
21:09:28 <kc5tja> brb -- getting food before the store closes.
21:12:26 <dmwit> sjanssen: I ought to be able to do "runhaskell Setup.hs configure" in the X11-1.2 directory, right?
21:12:32 <sioraiocht> alright, oÃ­che mhaith, a bos_
21:12:43 <bos_> sioraiocht: agus duitse
21:12:53 <TSC> dmwit: That's right
21:12:58 <sjanssen> dmwit: correct
21:13:20 <bos_> @seen desp
21:13:20 <lambdabot> desp is in #haskell. I don't know when desp last spoke.
21:13:24 <dmwit> *** Exception: Line 14: Unknown field 'extra-source-files'
21:13:38 <TSC> Need a newer cabal?
21:14:21 <dmwit> Errr... I'm going to go with "yes".
21:14:35 <dmwit> Never mind why. ;)
21:19:54 <dmwit> Hmmm, this is not as easy as I was hoping.
21:20:00 <dmwit> It might have to wait until finals are over... =(
21:21:10 <sjanssen> dmwit: which distro do you run?
21:21:23 <dmwit> I'm on Ubuntu Dapper right now.
21:21:27 <dmwit> It has ghc 6.4...
21:22:04 <sjanssen> all the code should be 6.4 compatible, all you need is an updated cabal
21:22:29 <sjanssen> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal-1.1.6 should work
21:22:31 <lambdabot> http://tinyurl.com/239787
21:22:34 <dmwit> Okay, let me look at the newest Cabal...
21:26:51 <dons> re.
21:27:05 <dons> ?uptime
21:27:05 <lambdabot> uptime: 7d 57m 22s, longest uptime: 7d 57m 22s
21:28:27 <dmwit> If I have an old version of X11, do I have to ghc-pkg unregister it before building the new one?
21:29:14 <TSC> I don't think it's necessary
21:29:24 * sjanssen agrees
21:30:02 <kc5tja> back
21:30:30 * dmwit is excited!
21:32:09 <jcreigh> dmwit: do you have xinerama?
21:32:18 <dmwit> jcreigh: Not yet.
21:32:28 <dmwit> I'm going to set it up this Saturday.
21:33:02 <jcreigh> dmwit: cool.
21:33:21 <jcreigh>  maybe we can someone other than me using xmonad+Xinerama. :)
21:33:43 <dmwit> Yeah, I'll test it out with you. =)
21:33:52 <dmwit> s/with/for/
21:34:01 <dons> jcreigh: hmm. yes. that would be good.
21:34:07 <TSC> I have Xinerama, if X11 would work (:
21:34:11 <dons> so how's tiling coming along?
21:34:15 <dons> sjanssen: ?
21:34:19 <jcreigh> dons: darcs pull
21:34:24 <dons> at some point we can go into beta testing
21:34:34 <dons> i'd really like to have a very solid dwm replacement ready for v0.1
21:34:39 <dons> under 400 lines, with quickcheck
21:34:42 <sjanssen> dons: no real changes since about 24 hours ago
21:34:49 <kc5tja> @where xmonad
21:34:49 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
21:34:55 <dmwit> Ugh,
21:35:06 <dmwit> Setup.lhs: cannot satisfy dependency base==2.0
21:35:18 <dmwit> ?hackage base
21:35:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/base
21:35:27 <dons> base1.0 might work, i suppose
21:35:28 <sjanssen> dmwit: delete that ==2.0 part in the cabal file
21:35:34 <dons> it should.
21:35:40 <sjanssen> dmwit: you can't upgrade base without upgrading ghc
21:35:40 <dons> 374 loc.
21:35:42 <dmwit> Heh.
21:35:44 <jcreigh> hmm...right now wc says 668...I assume we cheat for the LoC counts and say "comments and whitespace lines don't count" or somesuch thing?
21:35:44 <dmwit> ?quote Josef
21:35:45 <lambdabot> Josef says: Delete the "DO NOT DELETE" lines in .depend
21:35:47 <dons> so no one can add more than 26 lines :-)
21:35:58 <dons>                       Code  Comments
21:35:58 <dons> Main.hs                 255    147
21:35:58 <dons> StackSet.hs              71    102
21:35:58 <dons> XMonad.hs                48     52
21:35:58 <dons> TOTAL:                  374    301
21:36:02 <Zeroth404> since haskell is converted to C to be compiled, wouln't it just be better to write a haskell compilers in assembly?
21:36:09 <dons> Zeroth404: ghc does that
21:36:16 <dons> it generates both C, and assembly, and bytecode
21:36:37 <Zeroth404> from haskell to c to asm, right?
21:36:38 <dons> though now your question confuses me.
21:36:46 <dons> Zeroth404: nope. ghc generates asm directly.
21:36:49 <dons> it also generates C directly
21:36:58 <dons> which gcc then turns into asm
21:37:03 <Zeroth404> well then why are haskell apps sometimes slower than C counterparts?
21:37:06 <dons> ghc -fasm doesn't use C at all
21:37:12 <dons> Zeroth404: counterparts?
21:37:18 <dcoutts> Zeroth404: why are some C programs slower than others ?
21:37:21 <Zeroth404> counterpart as in a program that does the same thing
21:37:28 <dons> they don't do the same thing.
21:37:40 <dcoutts> Zeroth404: why are some implementations of the same algorithm faster than others?
21:37:58 <Zeroth404> I figured they typically ran slower because its converted to un-optimized c code before beign broken down to assembly
21:38:07 <sjanssen> dmwit: let me know if xmonad builds with 6.4, I'll update the dependencies
21:38:23 <dons> the C code generated isn't the kind of C you'd write by hand.
21:38:34 <dmwit> sjanssen: It can't find Data.Map -- it says package base-1.0 is hidden.
21:38:37 <dcoutts> it's more like assembly actually :-)
21:38:40 <jcreigh> yeah. it segfaults less, for one thing. :)
21:38:43 <dmwit> I tried putting base>=1.0 in the cabal file, but still no go.
21:39:09 <Zeroth404> so its just slower by design?
21:39:24 <dcoutts> Zeroth404: it's more complicated than you think
21:39:49 <dcoutts> Zeroth404: 'translating' one language to another is not easy
21:39:53 <sjanssen> dmwit: try running Setup.lhs configure again?
21:40:02 <dmwit> sjanssen: Yeah, that did it.
21:40:09 <dmwit> Oop, no it didn't.
21:40:23 <sjanssen> still with the hidden thing?
21:40:31 <dmwit> Not in scope: `forM_'
21:40:44 <sjanssen> dmwit: change that to flip mapM_
21:41:10 <jcreigh> Zeroth404: Haskell and C are very different languages. Haskell is a much richer language. (Algebraic datatypes, pattern matching, first class functions, closures, typeclasses, rich typing system, etc, etc, etc) The fact that a language like Haskell can even get close to C WRT performance is amazing.
21:41:36 <jcreigh> (okay, technically, I suppose C has first class functions...but it's not the same)
21:41:50 <Zeroth404> I don't know what any of that means :-/
21:41:59 <Zeroth404> heh
21:42:09 <Zeroth404> beside pattern matching
21:42:12 <kc5tja> Zeroth404: Lots of goodies that makes programming easier, formerly associated with more dynamic, often *interpreted* programming languages.
21:42:27 <dmwit> BRAGH
21:42:31 <jcreigh> Zeroth404: well, let's start with one of my favorites: first class functions and closures.
21:42:34 <dmwit> Now it doesn't type-check.
21:42:57 <dmwit> ?where hpaste
21:42:58 <lambdabot> http://hpaste.org/new
21:43:02 <kc5tja> sjanssen: How do I "get" the dependencies listed for xmonad?
21:43:18 <sjanssen> kc5tja: follow the README
21:43:36 <kc5tja> Do you want me to cut and paste the contents of the README?  :)
21:43:40 <jcreigh> Zeroth404: A first class function means that you can pass around a function like any other datatype. You can write functions that take other functions.
21:43:49 <kc5tja> All it lists are URLs; are these darcs get URLs?  Regular documentation?
21:44:02 <Zeroth404> jcreigh: well that makes perfect sense
21:44:04 <dmwit> kc5tja: The dependencies are available on hackage.
21:44:07 <dmwit> Oh.
21:44:16 <dmwit> They're web URLs.
21:44:19 <jcreigh> Zeroth404: for example, "map". map takes a function, a list, and applies each of the elements of the list to the function, and builds a new list with the results.
21:44:21 <sjanssen> kc5tja: the hackage.* deps are just pages that you download a .tar.gz
21:44:22 <hpaste>  dmwit pasted "Trying to build XMonad" at http://hpaste.org/1061
21:44:29 <jcreigh> > map (\x -> x * 5) [1,2,3,4,5]
21:44:30 <kc5tja> Ahh.
21:44:30 <lambdabot>  [5,10,15,20,25]
21:44:43 <kc5tja> Ahh, thanks.
21:44:49 <dmwit> sjanssen: The line number will be off by two, since I added a forM_ = flip mapM_ at the top.
21:45:01 <Zeroth404> is the retail version of YAHT more upkept?
21:47:25 <sjanssen> dmwit: might be the monomorphism restriction
21:47:33 <sjanssen> give forM_ an explicit type
21:47:36 <sjanssen> @type forM_
21:47:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
21:47:46 <dmwit> Ooo
21:48:18 <jcreigh> Zeroth404: a "closure" is a function that refers to variables in its defining scope. It's hard to provide a concise example of how useful this is, but it's very handy to be able to say things like "scaleBy scale xs = map (\x -> x * scale) xs" (reference "scale" inside that lambda expression)
21:48:54 <mcflightsuit> Yes. It's like OO, but inverted.
21:48:57 <jcreigh> Zeroth404: with just closures and first class functions, you can abstract away a ton of stuff that you would be forced to make into boilerplate code in lesser languages.
21:49:11 <mcflightsuit> It's also more concise.
21:49:40 <jcreigh> Zeroth404: see this article http://www.joelonsoftware.com/items/2006/08/01.html for an introduction to how incredibly useful they are.
21:49:41 <lambdabot> Title: Can Your Programming Language Do This? - Joel on Software
21:50:15 <mcflightsuit> I made a video about lexical closure.
21:50:27 <mcflightsuit> It's awful, but I'll post a link anyway.
21:50:29 <dmwit> Okay, I just actually replaced the two forM_'s, and it compiles now. Yay!
21:50:38 <Sgeo> @type (#)
21:50:41 <lambdabot> parse error on input `)'
21:50:53 <mcflightsuit> http://www.youtube.com/watch?v=HFhPot-bgtI
21:51:06 <mcflightsuit> This is for *cough* Common Lisp, but same idea.
21:51:39 <Pseudonym> Gah!  Emacs!  It burns my eyes!
21:51:55 <mcflightsuit> Pseudonym, Emacs?
21:52:11 <Pseudonym> The video.
21:52:20 <mcflightsuit> Well...I'm using Vim there. :)
21:52:28 <Pseudonym> Huh?
21:52:30 <Pseudonym> Oh, I see.
21:52:32 <Pseudonym> Hmmm.
21:52:40 <mcflightsuit> Vim + IPython.
21:52:47 <Pseudonym> Never mind.  It's beautiful, then.
21:52:50 <sjanssen> dmwit: all you changed was the base dependency and forM_?
21:53:13 * Pseudonym thinks . o O ( This is delicious!  Oh, it's liver?  Then I don't like it! )
21:53:25 <mcflightsuit> I got interested in Haskell b/c I wanted something more challenging than Python and with a less caustic user community than Lisp.
21:53:29 <dmwit> sjanssen: Yes.
21:54:00 <Pseudonym> Yeah, because Lisp sucks.
21:54:32 <mcflightsuit> Pseudonym, I wouldn't say that. I would say, however, that its users have 'social problems'.
21:54:33 <ddarius> CL is fairly crappy in many regards.
21:54:33 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
21:54:37 <Pseudonym> :-)
21:54:40 * Pseudonym is kidding
21:54:44 <Pseudonym> ?quote Stob
21:54:44 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
21:54:44 * mcflightsuit has Asperger's and still notices this
21:54:54 <ddarius> mmm broccoli
21:54:55 <Pseudonym> ?quote condescention
21:54:56 <lambdabot> No quotes match. Wrong!  You cheating scum!
21:54:59 <Pseudonym> Huh.
21:55:00 * ddarius continues eating broccoli.
21:55:04 <Pseudonym> ?quote VerityStob
21:55:04 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
21:55:06 <Pseudonym> That's it.
21:55:12 <mcflightsuit> ddarius, It is way too baroque, I'll give you that.
21:55:39 <mcflightsuit> And Scheme, OTOH, reminds me of 'Fasting Buddha'.
21:55:58 <Pseudonym> Scheme has the advantage that it's a cleaner kernel language than Lisp.
21:56:02 <sjanssen> dmwit: those changes are in the repo now
21:56:09 <ddarius> mcflightsuit: It's baroqueness is partially due to lacking some things that would make it more uniform.
21:56:41 <mcflightsuit> Pseudonym, True, but this is what I think of anytime someone mentions Scheme: http://www.liebreich.com/LDC/Images/Various/Contrasts/Buddha.jpg
21:57:01 <mcflightsuit> Haskell is...the Middle Way.
21:57:27 <ddarius> My first @message.  Too bad I read it in the scrollback a long time ago.
21:57:39 <Pseudonym> Right.
21:57:53 <Pseudonym> Haskell isn't scared to grow, but it will never compromise on purity.
21:58:13 <ddarius> unsafePerformIO (putStrLn "Never!")
21:58:33 <mcflightsuit> Hm...I might be back.
21:58:47 <dmwit> sjanssen: Great, the repo builds for me now, thanks!
21:59:35 <ddarius> Dutch, eh.
22:01:05 <ddarius> Pseudonym: CL is more scared to grow than Scheme.
22:01:18 <Pseudonym> Yeah, good point.
22:01:20 * dmwit takes a deep breath
22:01:50 <Pseudonym> Still.  You can't write a braindead Haskell compiler in 6 hours from scratch!  And that's what's important in a programming language!
22:02:08 <ddarius> Pseudonym: Only because of the syntax.
22:02:20 <jcreigh> Pseudonym: shh! don't let sorear hear you! :)
22:02:47 <jcreigh> hmm, maybe xmonad should have some documentation other than the source code.
22:03:25 <dons> documentation!?
22:03:26 <dons> bah.
22:03:27 <Pseudonym> Mind you, braindead lambda calculus interpreters are easy.
22:03:32 <dons> ok. maybe that is a good idea.
22:03:33 <dmwit> WOOO!
22:03:53 <jcreigh> dmwit: have you used dwm before?
22:04:02 <dons> yes, iirc
22:04:06 <dmwit> jcreigh: It was my WM of choice for a while.
22:04:20 <jcreigh> dmwit: ah, okay, so you've got a pretty good idea of how things work, then.
22:04:25 * dons wants a 'shut up and hack' tshirt
22:04:30 <dons> anyone know if such things exist?
22:04:42 <jcreigh> dons: make one! :) (/me ducks)
22:04:46 <dmwit> It's  a little odd to be lacking the reminder of what workspaces a given window are on up top.
22:04:47 <dons> dmwit: yeah, xmonad should behave like a dwm clone
22:04:50 <sjanssen> dons, jcreigh: perhaps we should have Config.lhs that intersperses docs with configuration
22:04:58 <dons> ah well, that's like old school dwm, dmwit
22:05:03 <dons> hmm
22:05:14 <jcreigh> sjanssen: oohh, sounds shiny.
22:05:21 <dons> literate window manager would be cute.
22:05:32 <mcflightsuit> FP window manager?
22:05:46 <jcreigh> BTW, what do you guys do for your config? I've got two hunks in Main.hs that I keep having to tell darcs to ignore...
22:05:51 <sjanssen> I think literate is a bit heavy weight for most of the code, but it'd be nice for the config stuff
22:06:02 <sjanssen> jcreigh: all my defaults are in the base :)
22:06:04 <dons> jcreigh: config?
22:06:09 <dons> defaults are defaults for a reason ;-)
22:06:21 <dons> the one true xmonad config.
22:06:37 <mcflightsuit> Pardon my ignorance. What is an xmonad?
22:06:39 <jcreigh> I have xterm -> x-xterminal-emulator and modkey = mod3
22:06:39 <TSC> Except C-space is used in Emacs, so you have to change that one... right?
22:06:46 <sjanssen> @where xmonad
22:06:46 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
22:06:55 <sjanssen> mcflightsuit: an X11 window manager in Haskell
22:06:57 <dons> mcflightsuit: a window manager we're working on
22:07:00 <jcreigh> mcflightsuit: xmonad is that name of WM written by dons and sjanssen in Haskell.
22:07:04 <dmwit> Hmmm... I thought tiling was now available?
22:07:06 <mcflightsuit> Very interesting.
22:07:14 <jcreigh> dmwit: yup. hit modkey-space
22:07:15 <sjanssen> dmwit: yeah, press mod+space
22:07:23 <mcflightsuit> I used to use stumpwm, but right now I'm pretty happy with ratpoison.
22:07:38 <mcflightsuit> Is it in a similar vein?
22:07:42 <dons> yeah, much like that
22:07:42 <sjanssen> ratpoison == bloated :)
22:07:51 <dons> it actually about 20x smaller than ratpoison :-)
22:07:51 <dmwit> Huh.
22:08:04 <dons> being 18,000loc of C, versus 380 lines of haskell for xmonad
22:08:18 <ddarius> dons: What that's not about comparable?
22:08:18 <sjanssen> ratpoison is almost 20kloc?
22:08:26 <mcflightsuit> Hehe.
22:08:34 <jcreigh> sjanssen: yeah, surprisingly.
22:08:40 <mcflightsuit> Well, that's comparing apples and pears.
22:08:40 <dons> TOTAL:                13580   2611
22:08:45 <dons> ratpoision ^^
22:08:59 <jcreigh> no wonder shawn rewrote it in CL.
22:09:05 <sjanssen> umm, is there an embedded C compiler or something?
22:09:07 <dons> comparing dwm to xmonad is far more reasonable
22:09:22 <mcflightsuit> What matters for me most is that it's stable and does what I want.
22:09:24 <dons> but still ... bloat is bloat... ;-)
22:09:42 <sjanssen> does ratpoison have xinerama support?
22:09:42 <mcflightsuit> But I will look at xmonad.
22:09:45 <jcreigh> sjanssen: yes
22:09:46 <dons> xmonad is the only window manager which comes with quickcheck propertiies :-)
22:09:46 <mcflightsuit> It might.
22:10:14 <ddarius> dons: What kind of properties does it check? (though I guess I could just darcs pull and see)
22:10:20 <mcflightsuit> You have not seen bloat until you've used Firefox with an old version of Flash.
22:10:37 <dons> ddarius: the internal data structure is checked for consistency
22:10:43 <dons> e.g. cycling windows
22:10:47 <dons> adding and removing windows and so on
22:10:54 <dons> never leave the wm in an inconsistent state
22:11:02 <dmwit> Can I add ratio to the X monad?
22:11:14 <sjanssen> dmwit: please do
22:11:24 <sjanssen> dmwit: and please send your patches
22:11:36 <mcflightsuit> Does xmonad number windows as does rp?
22:11:37 <dons> ddarius: http://darcs.haskell.org/~sjanssen/xmonad/tests/Properties.hs
22:13:09 <dons> Cale: around?
22:13:11 <mcflightsuit> Hi ivanm.
22:13:21 <dons> Cale, I'd like a "Built with QuickCheck" logo, similar to the "Built with Cabal" page.
22:13:48 <Cale> sure
22:14:09 <ivanm> hi, mcflightsuit
22:14:30 * ivanm had xchat autostarted, has to go work on his business case assignment for tomorrow
22:14:32 <jcreigh> unfortunately, the bugs that I've seen were caused by problems with state in the X monad, not in StackSet
22:14:51 <ddarius> jcreigh: Surprise!
22:15:33 <jcreigh> dmwit: so, what do you think of xmonad?
22:15:46 <dmwit> Lightweight, fast.
22:15:51 <dmwit> Pretty much what I was expecting, really.
22:15:54 <mcflightsuit> I like how it has no screenshots. :)
22:15:59 <mcflightsuit> Must be all content.
22:16:03 <dmwit> I still don't like how GVim fails at sizing itself.
22:16:08 <dmwit> But that was also true in dwm.
22:16:19 <mcflightsuit> dmwit, ...and rp.
22:16:23 <sjanssen> mcflightsuit: http://cse.unl.edu/~sjanssen/xmonad-tiles.png
22:16:24 <mcflightsuit> I have a fix for that.
22:16:30 <jcreigh> dmwit: gvim doesn't like any fullscreenish WM. ion, ratpoison, dwm, xmonad, etc.
22:16:41 <mcflightsuit> Oh. :)
22:16:48 <mcflightsuit> Well, let me dig up my fix.
22:16:53 <dmwit> In dwm, you could increase/decrease the width and it would fix itself.
22:17:11 <jcreigh> dmwit: yeah, just hit mod-j mod-k
22:17:24 <dmwit> > 3 % 5
22:17:25 <lambdabot>  3%5
22:17:33 <mcflightsuit> set sessionoptions=buffers,curdir,folds,localoptions,options,resize
22:17:38 <dmwit> ?index (%)
22:17:38 <lambdabot> Data.Ratio
22:17:39 <mcflightsuit> This is in my .vimrc
22:18:00 <mcflightsuit> resize is the most relevant part obviously.
22:18:44 <mcflightsuit> Then I set columns=100, and lines=38 ... YMMV, experiment to get a good value.
22:19:23 * ddarius tends to prefer terminal vim so never had any problem when he used ion with vim
22:19:39 <mcflightsuit> The end result is that I can use gvim with a session script (-S) and it nicely fills the whole screen every time.
22:20:01 * mcflightsuit 's session is full of Perl code now :yuckyface:
22:20:07 <jcreigh> ddarius: trouble is, it's hard to bind some keys on the terminal
22:20:29 <mcflightsuit> You might be able to use screen to get around that...somehow.
22:21:16 <mcflightsuit> Speaking of keybindings: xmodmap -e "keysym Super_L = Multi_key" is really useful.
22:21:23 <mcflightsuit> (Or Super_R.)
22:22:31 <mcflightsuit> Those Windoze keys were useless until I put them to work...now it's painless to type things like "Khazad-dÃ»m" and "Mikael Ã…kerveldt".
22:22:48 <dmwit> Can I restart XMonad somehow?
22:23:06 <jcreigh> dmwit: quit, and start X again. :) (modkey-shift-q to quit)
22:23:16 <jcreigh> oh, I guess he figured it out
22:23:19 <mcflightsuit> dmwit, Where did you start the client processes from?
22:23:22 <dons> why would you want to restart? :-)
22:23:23 <mcflightsuit> Oops.
22:23:46 <TSC> dons: After a darcs pull + build, of course!
22:23:53 <dons> ah yes.
22:24:00 <dons> i should try to do this sigusr1 patch for that
22:24:03 <hpaste>  sjanssen pasted "snippet from my .xinitrc" at http://hpaste.org/1062
22:24:18 <dmwit> Obviously, that is not the way to restart XMonad. =P
22:24:29 <mcflightsuit> Hehe.
22:24:34 <sjanssen> dmwit: you might find http://hpaste.org/1062 useful
22:24:59 <jcreigh> on my wishlist of "features I'll probably never implement but would be cool" is serializing the state and then exec() itself so you can upgrade without losing quiting X/losing workspaces
22:25:13 <sjanssen> dons: I don't think the sigusr1 is useful for loading a new compile of dwm
22:25:15 <dons> jcreigh: right. that would be pretty easy in fact
22:25:25 <dons> sjanssen: oh?
22:25:26 <sjanssen> oh, I suppose you could fork...
22:25:32 <dons> yeah
22:25:46 <dons> hmm, but why not just exec ?
22:25:56 <mcflightsuit> You'd lose state I guess.
22:26:00 <dons> unix exec, replace the current address space with the new one
22:26:05 <dons> yeah, you'd unmanage, the remanage
22:26:10 <dons> but you can dump the state too
22:26:12 <sjanssen> yeah, exec should work
22:26:20 <dons> we already write it to stderr anyway.
22:26:27 <mcflightsuit> dons, What format?
22:26:34 <dons> Show/Read format
22:26:35 <mcflightsuit> I'm fond of YAML personally.
22:26:42 <dons> nothing that fancy.
22:26:43 <sjanssen> mcflightsuit: too bloaty :)
22:26:44 <mcflightsuit> Oh, never heard of that.
22:26:50 <dons> > show "foo"
22:26:51 <lambdabot>  "\"foo\""
22:26:56 <dons> > read (show "foo") :: String -- yay
22:26:56 <mcflightsuit> JSON is less bloaty. :)
22:26:58 <lambdabot>  "foo"
22:27:11 <sjanssen> > show [Just (1, "foo", Left 12)]
22:27:12 <jcreigh> mcflightsuit: show is like #inspect in Ruby, if you're familar with that.
22:27:12 <lambdabot>  "[Just (1,\"foo\",Left 12)]"
22:27:45 <mcflightsuit> jcreigh, No clue. My favorite serialization methods have always been YAML and JSON which are incredible for me.
22:28:14 * dmwit <3 ghci
22:28:25 <jcreigh> mcflightsuit: ah, Ruby folks tend to use YAML a lot, so I thought you might be a Ruby user.
22:28:40 <jcreigh> mcflightsuit: (but yes, I'm a fan of YAML as well)
22:29:05 <mcflightsuit> jcreigh, Not really. I'm a bigger fan of Python for largely pragmatic reasons.
22:29:42 <mcflightsuit> Er...back to Haskell...is it possible to define piece-wise functions in ghci or hugs?
22:30:11 <sjanssen> mcflightsuit: use let, and semicolons instead of newlines
22:30:36 <sjanssen> mcflightsuit: but if you're writing anything very long you should type it in a file and load it from there
22:30:39 <dons> > let f 0 = 1 ; f n = 1 + f (n-1) in f 10
22:30:40 <lambdabot>  11
22:30:42 <dons> like that.
22:30:56 <mcflightsuit> sjanssen, Cool. May I ask what let does differently from any other assignment? (Pardon my ignorance please.)
22:31:04 <mcflightsuit> dons, Thx.
22:31:18 <dons> its not assignment :-)
22:31:24 <dons> it just binds a name to that expression
22:31:33 <mcflightsuit> Ok. :)
22:31:34 <jcreigh> mcflightsuit: you can't really do a normal declaration in ghci. the nature of Haksell makes this pretty much impossible.
22:31:39 <sjanssen> mcflightsuit: syntactically, let is an expression.  The other binding forms are only for the top level
22:31:48 <dons> > (let x = 1 in x + x) + 2
22:31:49 <lambdabot>  4
22:32:02 <mcflightsuit> I see.
22:32:14 <dons> > if let x = True in x || x then let y = let x = 7 in x in y else 2
22:32:14 <lambdabot>  7
22:32:17 <dons> :-)
22:32:20 <mcflightsuit> Wait, I didn't know that 0! is defined.
22:32:24 <Cale> dons: http://cale.yi.org/tested-with-QuickCheck-dark.png http://cale.yi.org/tested-with-QuickCheck-light.png -- let me know what you think.
22:32:32 <dons> woot!
22:32:45 <sjanssen> 4044
22:32:48 <dons> 404
22:32:49 <sjanssen> s/44/4
22:32:52 <Cale> oh!
22:33:07 <Cale> dons: http://cale.yi.org/autoshare/tested-with-QuickCheck-dark.png http://cale.yi.org/autoshare/tested-with-QuickCheck-light.png
22:33:08 <jcreigh> I thought 4044 was some sort of leet-speak for a second. :)
22:33:14 <dmwit> Hmmm, can't Setup.lhs install while I'm in the window manager.
22:33:16 <mcflightsuit> Er.
22:33:16 <dmwit> Is this normal?
22:33:27 <dons> dmwit: rm -f `which xmonad`
22:33:30 <Cale> hmm, perhaps the text should sit a little lower on the image
22:33:42 <mcflightsuit> Cale, 404. :(
22:33:54 <Cale> still?
22:33:56 <dons> looks good to me.
22:34:02 <dons> mcflightsuit: use the new url
22:34:04 <jcreigh> ~$ grep xmonad ~/.xsession
22:34:04 <jcreigh> exec ~/src/xmonad/dist/build/xmonad/xmonad
22:34:07 <Cale> mcflightsuit: see my correction to the URLs.
22:34:10 <jcreigh> ie, you don't have to install
22:34:21 <mcflightsuit> Ok.
22:34:23 <dons> yes, very happy with that Cale.
22:34:23 <mcflightsuit> Sry.
22:34:24 <dons> thanks!
22:34:41 <sjanssen> shouldn't cabal unlink and replace the executable?
22:34:44 * mcflightsuit looks a gift horse in the mouth
22:34:55 <dons> jsit should.
22:34:56 <mcflightsuit> It needs Dragons and Elves.
22:35:33 <Cale> made a slight modification
22:35:36 <dons> sjanssen: we can badge xmonad now
22:35:39 <sjanssen> dons: known bug?
22:35:42 <Cale> I think it looks a little more vertically balanced like that
22:35:47 <Cale> (refresh)
22:35:58 <dons> sjanssen: yeah
22:36:19 <mcflightsuit> I see it. :)
22:36:27 <mcflightsuit> Still no Elves. :)
22:36:42 <Cale> I'd have included the QuickCheck logo if there was one.
22:37:05 <jcreigh> we're planning on waiting for 0.1 to start "marketing" (ie, reddit "Haskell window manager in 400 LOC!!! OMG!!!") xmonad, right?
22:37:10 <dons> Cale: there isn't one.
22:37:14 <dons> jcreigh: right.
22:37:16 <dons> we're waiting for 0.1
22:37:22 <dons> when it's a full dwm replacement.
22:37:24 <sjanssen> irc buzz only for now
22:37:26 <dons> then we take over the world.
22:37:33 <dcoutts> muwahahaha
22:37:37 <TSC> 3. ??? 4. Profit!
22:37:48 <jcreigh> TSC: haha, yes.
22:37:50 <dcoutts> what are we doing tonight Brain?
22:37:52 <dcoutts> @brain
22:37:53 <lambdabot> Uh, I think so Brain, but this time, you wear the tutu.
22:38:15 <Cale> Is xmonad going to use hs-plugins?
22:38:30 <sjanssen> Cale: no
22:38:31 <dons> nah
22:38:37 <mcflightsuit> TSC, LOL.
22:38:41 <dons> Cale: http://www.cse.unsw.edu.au/~dons/streams.html
22:38:41 <lambdabot> Title: Data.List.Stream
22:38:47 <mcflightsuit> PROFIT!
22:38:48 <sjanssen> I think compile time configuration is enough
22:39:09 <kc5tja> jcreigh: I thought it originally was 500 LOC.
22:39:22 <jcreigh> kc5tja: 400 LOC is the number dons has been throwing around
22:39:30 <mcflightsuit> Hi scorfield.
22:39:32 <kc5tja> jcreigh: In fact, I'm sure of it when the concept first struck.
22:39:40 <jcreigh> (I think LOC is a bogus metric, but whatever)
22:39:48 <dons> jcreigh: we beat dwm at its own game.
22:39:49 <dons> that's the point.
22:39:51 <mcflightsuit> jcreigh, Yeah.
22:39:56 <dons> you know, 10kloc and all that
22:40:14 <dmwit> Okay, how do I tell darcs to omit some of my changes?
22:40:30 <mcflightsuit> Hm.
22:40:31 <kc5tja> It sounds more impressive when you say, "We wrote it in 380 lines of code, thus significantly meeting our 500LOC limit."  :)
22:40:33 <sjanssen> dmwit: you pick and chose interactively with darcs record
22:40:36 <jcreigh> wmii is 10K, dwm is 1.6K, xmonad is 500. the next logical step is the 1 LoC "exec xterm" WM.
22:40:42 <mcflightsuit> Good night all.
22:41:03 <jdrake> In the wikibook's tutorial, it says that you can use read to convert a user string into a number. Thinking this, I tried read("5.5") and it says "no parse". What might I be doing wrong?
22:41:04 <mcflightsuit> Well, exec xterm and screen...
22:41:20 <sjanssen> > read "5.5" :: Double
22:41:21 <lambdabot>  5.5
22:41:28 <jcreigh> kc5tja: don't forget we have Xinerama, so if you have a multihead setup, it's *way* more usable than dwm or wmii
22:41:36 <sjanssen> jdrake: the type checker is probably choosing the wrong output type
22:41:37 <jcreigh> *more* features, *fewer* LoC.
22:41:40 <TSC> jdrake: You need to help read by mentioning the type
22:41:55 <jdrake> That seems wierd
22:41:56 <dmwit> Hmmm, I want to only record part of a hunk...
22:42:03 <dons> > read "5.5" :: Float
22:42:04 <lambdabot>  5.5
22:42:12 <kc5tja> jcreigh: Unfortunately, I can't get it to compile tonight.  I'm too tired to grab all the deps right now.  I'll try tackling it tomorrow.
22:42:30 * kc5tja feels like crap - I've been trying to work on my Kestrel project now for WEEKS, and no progress AT ALL.  :(
22:42:30 <sjanssen> jdrake: the type of the result can't depend on the value of the string (not in Haskell, anyway)
22:42:34 <Cale> jdrake: you have to make sure that the surrounding context will demand a Float or Double
22:42:38 * kc5tja envies those who can just straight-up code.  :(
22:43:01 <kc5tja> jcreigh: xinerama doesn't do anything for me.  I'm single-headed here.
22:43:03 <dons> kc5tja: practice practice practice
22:43:05 <Cale> @type read
22:43:07 <dons> its like playing an instrument.
22:43:07 <lambdabot> forall a. (Read a) => String -> a
22:43:12 <kc5tja> dons: I've been practicing since I was 4 years old.
22:43:17 <dons> you have to keep a large amount of code in front-of-brain memory
22:43:19 <jcreigh> kc5tja: it does something for me. :)
22:43:24 <dons> and maybe code 2 or 3 hours every single day
22:43:37 <dons> then you can pretty much writing anything just by sitting in front of your editor
22:43:39 <kc5tja> dons: I used to hack on Kestrel for 4 hours a day.
22:43:51 <kc5tja> dons: But as of last month, it's total block.  I can't write *anything*.
22:44:04 <dons> i guess there's writers block too.
22:44:13 <Cale> What's Kestrel?
22:44:22 <kc5tja> http://www.falvotech.com/content/kestrel
22:44:24 <lambdabot> Title: The Kestrel Project
22:45:16 <Cale> cool
22:45:22 <dons> hmm. maybe i should write a blog on coding as music practice
22:45:24 <jdrake> In my first code exercise, it works, but would like some style advice to help me out later.  http://pastebin.ca/404728
22:45:28 <dons> learning the scales and patterns
22:45:40 <dmwit> sjanssen: Where should I send the patch?
22:45:40 <sjanssen> dons: that makes a lot of sense to me
22:45:41 <dons> solving #haskell problems is a bit like practicing scales
22:45:44 <kc5tja> dons: I also tried learning an instrument too.  Heh -- forget it.
22:45:51 <sjanssen> dmwit: I can take it (should be the default)
22:45:53 <dons> you get forced to try out parts of the libs you don't often use
22:46:09 <dons> writing libraries is a good exercise too
22:46:11 <Cale> If you write  base <- readLn  then you won't have to read it latr
22:46:15 <Cale> later*
22:46:16 <dons> i think everyone should write their own Data.List
22:46:23 <dons> that's really good for learning how to do haskell :-)
22:46:27 <Cale> readLn = fmap read getLine
22:46:45 * dons <3 make -j16
22:46:47 <jcreigh> sjanssen: it would be nice if xmonad was "darcs send"able I don't know where to set that; otherwise, I'd send you a patch :)
22:46:48 <kc5tja> dons: I did one better than that.  I re-invented unfoldr no less than twice in the CUT rewrite project alone.
22:46:52 <dons> heh
22:47:00 <dons> jcreigh: argh yes.
22:47:12 <Cale> you just have to make sure that it ends up getting used as a double -- the division by 2, together with defaulting, should manage that.
22:47:16 <dons> sjanssen: want to stick yours or my email in the author and email file?
22:47:17 <sjanssen> dons: everyone should write two Data.Lists.  First time the naive way, second time every function via foldr
22:47:22 <dons> hehe
22:47:24 <sjanssen> oh, I thought I did that
22:47:33 <dmwit> Does this mean I succeeded? "." doesn't sound like a real email address.
22:47:46 <sjanssen> what do I edit?
22:47:56 <dons> _darcs/prefs/{author,email}
22:48:03 <sjanssen> dmwit: apparently my repo is misconfigured.  Send to sjanssen@cse.unl.edu
22:48:13 <TSC> jdrake: Looks ok, you might be able to discard one of the ":: Double" annotations
22:48:22 <dons> sjanssen: e.g.
22:48:23 <dons> $ cd code/fps
22:48:23 <dons> $ cat _darcs/prefs/email
22:48:23 <dons> Don Stewart <dons@cse.unsw.edu.au>
22:48:52 <jcreigh> darcs send is, IMO, darcs's killer feature
22:49:01 <Cale> jdrake: http://pastebin.ca/404734
22:49:04 <dons> makes contributing very cheap, eh jcreigh ?
22:49:35 <sjanssen> okay, I've added those
22:49:53 <jdrake> final version: http://pastebin.ca/404736
22:49:57 <jdrake> Looks much better
22:50:42 <Cale> you can also eliminate the parens around putStrLn's parameter using a $
22:50:55 <sjanssen> will users get this change when they pull?
22:51:27 <dmwit> It doesn't seem to.
22:51:36 <jdrake>  Cale, can you demonstrate? I am not sure of that syntax
22:51:44 <Cale> http://pastebin.ca/404734
22:51:47 <dons> sjanssen: i think so
22:52:05 <jdrake> So what exactly does that do?
22:52:11 <Cale> f $ x = f x
22:52:17 <jdrake> Looks like something special for precidence
22:52:17 <Cale> but $ has really low precedence
22:52:38 <Cale> It just helps eliminate parens.
22:52:49 <dmwit> dons: I don't get them from a pull...
22:52:55 <jdrake> Looks quite nice
22:53:29 <dmwit> Okay, time to go get some actual work done... =P
22:53:34 <sjanssen> dmwit: if you do one send I think darcs will remember the address
22:53:45 <jcreigh> sjanssen: it hasn't for me
22:53:48 <jdrake> Now you used a 2 instead of 2.0. How does it know it is a floating point instead of an integer?
22:53:53 <Cale> Another style point regarding $ is that you should only usually need one $ in an expression. If you find yourself writing f $ g $ h $ x, it's considered slightly better style to write that as f . g . h $ x
22:54:08 <TSC> :t (/) -- <---- jdrake
22:54:09 <Cale> The division
22:54:11 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:54:49 <Cale> Note that there's some defaulting going on. The default Fractional type is Double.
22:55:07 <jdrake> My previous (long ago) experience in ocaml wasn't so joyful
22:55:31 <Cale> For integer division, you have to use `div`
22:55:50 <Cale> The main reason why that's separated out is that it's a different enough operation.
22:56:30 <Cale> Also, it tends to help in cases like yours that the right types can get selected without explicit type signatures.
22:56:31 <sjanssen> ah, I guess darcs checks the _darcs/prefs/email file of the remote repo when you do a darcs send
22:56:33 <jdrake> It can certainly be
22:57:13 <jcreigh> sjanssen: so "darcs send" should work now?
22:57:21 <Cale> @type (,)
22:57:23 <lambdabot> forall a b. a -> b -> (a, b)
22:57:24 <Cale> er
22:57:25 <dmwit> sjanssen: I'm not sure if I have system set up properly, but I darcs send'ed a little bit ago.
22:57:26 <Cale> @type (/)
22:57:28 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:57:28 <Cale> @type div
22:57:31 <lambdabot> forall a. (Integral a) => a -> a -> a
22:57:42 <Cale> @type mod
22:57:44 <lambdabot> forall a. (Integral a) => a -> a -> a
22:58:16 <sjanssen> jcreigh: hopefully.  Let me know if it doesn't
22:58:29 <jcreigh> sjanssen: cool! thanks.
22:58:58 <sjanssen> dmwit: have you set up an MTA?
22:59:16 <dmwit> sjanssen: I have exim installed, but I don't recall explicitly configuring it.
22:59:31 <Cale> jdrake: another option for factoring your code: http://pastebin.ca/404739
22:59:40 <Cale> also, we should be using hpaste.org :)
22:59:43 <sjanssen> dmwit: I haven't received anything at this point, but who knows what that means
23:00:31 <kc5tja> You can also use darcs send to create output files, which you can attach to mails manually.  Useful for when gmail.com is your MTA.  :)
23:00:50 <sjanssen> darcs send -o foo.dpatch
23:00:57 <Cale> oops, missed a do
23:01:00 <Cale> http://pastebin.ca/404740
23:01:09 <jdrake> Cale: ironically, I was trying to design a prompt function (without much success).
23:01:32 <Cale> Well, that should give you the idea then :)
23:01:40 <jdrake> Also I use pastebin.ca because it is fast, and I am a patriot.
23:01:44 <Cale> hehe
23:02:18 <Cale> hpaste.org is written in Haskell, has haskell syntax highlighting, and there's a bot in the channel which will report new pastes made there
23:02:56 <hpaste>  Cale pasted "jdrake's code" at http://hpaste.org/1063
23:03:03 <jdrake> hpaste.ca would earn a patriotic gesture :p
23:03:07 <Cale> hehe
23:03:55 <hpaste>  jdrake pasted "Error in your code" at http://hpaste.org/1064
23:04:21 <jdrake> Either that or I am doing something wrong
23:04:43 <pebblestone> it seems to me that GHC are excellent optimizing away the intermediate result. But how could it know if the definition is recursive filtering like sieve?
23:05:09 <Cale> jdrake: uh, I don't get that error
23:05:31 <jdrake> I do :p
23:05:38 <TSC> The error is that read can return any type, but not any type is showable
23:05:45 <TSC> So using prompt like that won't work
23:06:00 <TSC> (ghci is implicitly trying to show it)
23:06:01 <Cale> TSC it's trying to show the IO action rather than running it
23:06:13 <Cale> try this:
23:06:25 <Cale> prompt "How?" :: IO Integer
23:06:36 <sjanssen> pebblestone: what sort of sieve?
23:06:39 <pebblestone> I mean if you have some recursive mapping or filtering, then how could it figure that there's no need to produce the intermediate result?
23:06:42 <TSC> Err, I don't get that error either (:
23:06:45 <jdrake> That worked
23:07:01 <jdrake> Now should it display the 5 after I type it as a return value?
23:07:01 <Cale> jdrake: okay, then somehow defaulting is broken in your copy of GHCi.
23:07:08 <pebblestone> sjanssen: one sec. I'll paste it.
23:07:14 <Cale> Does it?
23:07:15 <jdrake> Cale: blame ubuntu
23:07:29 <Cale> It does in some versions of GHC, and won't in others.
23:07:35 <jdrake> Oh yes, hpaste is nice and beautiful
23:07:43 <sjanssen> pebblestone: in the case of functions like map and filter GHC has special rules to fuse a pipeline of them into a single function
23:07:59 <hpaste>  pebblestone pasted "sieve" at http://hpaste.org/1065
23:08:00 <jdrake> This is also ghci 6.4.2
23:08:34 <Cale> okay, I'm using 6.6
23:08:41 <pebblestone> sjanssen: can you tell me where to find the reference about these rules?
23:09:10 <Cale> (I'm also using Ubuntu, but just decided to install a separate binary GHC rather than wait for Feisty.
23:09:12 <Cale> )
23:09:43 <jdrake> I considered that
23:09:44 <sjanssen> pebblestone: I don't think ghc is actually smart enough to totally eliminate the intermediate structures in this code
23:10:26 <Cale> I think Ubuntu and GHC's dev cycles are badly misaligned. It seems that a new GHC comes out just after the Ubuntu freeze.
23:10:46 <Cale> (at least, that's what seemingly happened the last couple of times)
23:10:58 <sjanssen> pebblestone: but lazy evaluation makes it seem as if the intermediate structure is never created
23:11:10 <Cale> Feisty will probably come out and then we'll have GHC 6.8 right after :)
23:11:14 <kc5tja> @where xmonad
23:11:15 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
23:11:29 <pebblestone> sjanssen: it does, otherwise the memory usage will grow constantly, everytime it generates a new prime, there'll be a new list created.
23:11:48 <pebblestone> sjanssen: but in my machine, the memory doesn't change.
23:12:00 <pebblestone> sjanssen: s/memory/memory usage/
23:12:02 <sjanssen> pebblestone: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3179621 (for the functions that truly fuse in ghc)
23:12:04 <lambdabot> Title: 7.11. Rewrite rules, http://tinyurl.com/y7rk9g
23:12:08 <pebblestone> sjanssen: thanks
23:12:16 <jdrake> Cale, do you happen to install it into /usr/local?
23:12:20 <kc5tja> Is anyone familiar or knowledgable about a make replacement written in Haskell?
23:12:22 <Cale> jdrake: yeah
23:12:51 <Cale> pebblestone: that actually does use more and more memory because it has to keep track of all the tests as it proceeds down the lists. The head of the list can be GC'd after it's been printed though.
23:12:55 <sjanssen> pebblestone: it's lazy evaluation.  Lists can be treated as streams in Haskell, if you process each element in turn and throw it away you'll run in constant memory
23:13:00 * kc5tja has gone through scons and now cmake.  And cmake is giving me nothing but nightmares.
23:13:54 <jdrake> kc5tja: KDE seems to like it :P
23:14:08 <kc5tja> jdrake: CMAKE on my old Linux system worked great.
23:14:13 <kc5tja> On this one, it is failing outright.
23:14:23 <kc5tja> Maybe it's not even cmake.
23:14:26 <Cale> jdrake: I don't compile GHC myself though.
23:14:28 <kc5tja> Maybe it's retardation with gcc.
23:14:35 <jdrake> Cale, do you find anything in particular that would be helpful in 6.6 over 6.4?
23:14:47 <kc5tja> But, whatever it is, the project I built using cmake is no longer building.  >:(
23:14:49 <Cale> Well, it's got loads of new libraries.
23:15:10 <Cale> and the compiled code is generally better
23:15:22 <jdrake> good enough reason
23:15:41 <kc5tja> 6.6 produces smaller executables than 6.4.  That much is for certain.  :)
23:15:45 <sjanssen> Data.ByteString is enough reason
23:16:48 <jdrake> ghc using configure seems like an abomination
23:17:02 <Cale> oh, don't compile it yourself!
23:17:10 <jdrake> Why not
23:17:18 <Cale> Because it'll take hours.
23:17:18 <kc5tja> It takes close to 6 to 8 hours to complete.  :)
23:17:26 <jdrake> hmm
23:17:27 <Cale> Just download the binary package.
23:17:57 <dons> ghc 6.6 produces better code
23:18:18 <dons> wasn't it kc5tja's app that ran 3x faster with 6.6?
23:18:21 <jdrake> Which binary to get though?
23:18:23 <Cale> Linux?
23:18:25 <Cale> http://www.haskell.org/ghc/download_ghc_66.html#x86linux
23:18:26 <dons> due to the improved bytestring rep.
23:18:26 <lambdabot> Title: GHC: Download version 6.6
23:18:31 <jdrake> There is quite a list
23:18:32 <kc5tja> dons: It ran faster because of the use of ByteString.
23:18:41 <Cale> Generic linux with glibc 2.3
23:18:52 <Cale> that last one which is a .tar.bz2
23:18:55 <Cale> http://www.haskell.org/ghc/dist/6.6/ghc-6.6-i386-unknown-linux.tar.bz2
23:18:57 <lambdabot> http://tinyurl.com/y9myfk
23:19:16 <kc5tja> OK, bedtime for me.
23:19:19 <Cale> unless you're running x86_64, in which case you want the one for x86_64
23:19:27 <kc5tja> I've #($*&74908@#$7 had it with software development.
23:19:33 * kc5tja is thinking it might be better to drop 100% out of the computer field.
23:19:39 * kc5tja sighs
23:19:44 <Cale> kc5tja: Pure mathematics.
23:19:44 <dons> kc5tja: and because bytestring is much faster in 6.6, than 6.4
23:19:47 <jdrake> kc5tja: I am going into instrumentation :p
23:20:00 <kc5tja> Cale: What do you mean?
23:20:15 <kc5tja> jdrake: Still involves computers.
23:20:18 <Cale> kc5tja: I'm saying that's what you should go into :)
23:20:19 <kc5tja> Obviously I'm being facetious.
23:20:29 <kc5tja> Cale: I've thought about it, but, what kind of mathematics?
23:20:39 * dons uses darcs while compiing ghc, listening to hmp3 running in xmonad
23:20:49 <Cale> Maybe algebraic topology?
23:20:54 <kc5tja> Besides, I abhore proofs -- proofs just 1000% (not a typo) baffle the ever-loving #@$& out of me.
23:20:56 <dons> grr. damn irssi and xterm muckying up my lambda goodness
23:21:00 <Cale> Or combinatorics?
23:21:10 <Cale> ah
23:21:13 <jdrake> kc5tja: instrumenation is a lot more than just computers :p
23:21:24 <Cale> Proofs are the fun part of mathematics.
23:21:30 <kc5tja> jdrake: You don't understand.  I want *LESS* than computers.
23:21:34 <kc5tja> Cale: If they made sense, sure.
23:21:35 <sjanssen> dons: plus xorg and that damn kernel
23:21:39 <kc5tja> Proofs don't make sense.
23:21:42 <jdrake> kc5tja: Go work in a pioneer villiage
23:21:50 <dons> grr. kernel. grr!
23:21:52 <Cale> kc5tja: They do, when you're actually in a pure mathematics program.
23:21:57 <dons> i'd be happy with user space though
23:22:22 <kc5tja> I fail to see why gcc is not finding an include file, despite being told *QUITE* explicitly where the heck it is.
23:22:23 <Cale> kc5tja: There's a hell of a lot wrong with the way that mathematics is taught outside of actual mathematics programs.
23:23:00 <kc5tja> Cale: I've spoken with math majors in the past, and I've looked at "how their taught."  They're not taught.  They're just kind of spewed, and you're expected to seep up whatever you can.
23:23:05 <kc5tja> I fundamentally don't work that way.  :(
23:23:20 <Cale> Huh?
23:24:28 <Cale> Perhaps the profs weren't so good?
23:24:33 <kc5tja> Cale: I'm a 5 time college dropout.
23:24:37 * _roconnor sort of agrees with kc5tja
23:25:01 <Cale> Hmm, can you elaborate on what you mean by "spewed"?
23:25:06 <emu> yea i was never very happy with lower level math training
23:25:13 <newsham> http://www.praxis-his.com/pdfs/issse2006tokeneer.pdf
23:25:32 <kc5tja> For one reason or another, through 5 different colleges, I've had to drop out either because of money, or because of schedule, but in all cases, I've found great difficulty with how math classes in general are taught.
23:25:34 <newsham> low defect coding in industry.
23:25:57 <kc5tja> Cale: Math instructors have to teach a lot of stuff in a semester, so they just rattle on about the subjects that need to be taught.
23:25:59 <Cale> Do you mean that the course was structured like a paper? "Definition,theorem/proof,theorem/proof..."
23:26:01 <kc5tja> No history behind the stuff.
23:26:11 <kc5tja> No reasons *why* things are needed.
23:26:16 <roconnor> Logic and deduction doesn't seem to be clearly taught.  Profs just give examples and students are expected to infer what a proof is.
23:26:17 <kc5tja> In other words, no context.
23:26:23 <roconnor> Some get it and some don't.
23:26:31 <kc5tja> You're just expected to memorize everything, like it's some kind of Universal Given.
23:26:37 <Cale> Well, you have some problems which you'd like to be able to solve.
23:26:40 <roconnor> I exagerate a bit, but not too much.
23:27:17 <Cale> Also, the historical development of some subjects is less enlightening than you'd expect it to be, and a retrofitted "history that ought to have been" is better.
23:27:23 <emu> just about every class i took did a short intro to propositional logic and predicate calc.  i got quite sick of it.
23:27:25 <kc5tja> Cale: As I encounter problems, I research solutions.  I cannot always understand them, unfortunately, but I usually do find something.
23:27:40 <roconnor> emu: really, wow.
23:28:19 <Cale> Also, it's not a good idea to go into mathematics with the preconception that it has anything to do with the real world :)
23:28:25 <kc5tja> Also, most proofs that I've encountered seem to rely on the "A=A because A=A" method.
23:28:34 <Cale> Circular reasoning?
23:28:40 <kc5tja> Almost every time.
23:28:45 <emu> who's proofs?
23:28:49 <kc5tja> At least, that's how I interpret them.
23:28:52 <Cale> Then you haven't encountered proofs. :)
23:29:06 <kc5tja> emu: Gahh, it's been years since I've encountered proofs, I can't remember.
23:29:17 <emu> proofs are just an argument to convince you of the truth of a statement
23:29:17 <Cale> Maybe things designed to trick you into thinking that the result has been proven when it hasn't?
23:29:23 <Cale> emu: They're not.
23:29:28 <newsham> emu: dont show up when they recap?
23:29:30 <kc5tja> emu: Yes, and they usually fail to convince me.
23:29:52 <emu> Cale: in a sound system
23:30:14 <Cale> A proof is a finite list of statements, starting with the assumptions of the theorem to be proven and each statement following logically from the previous ones, with the final statement being the result of the theorem.
23:30:20 <pebblestone> sjanssen: it's still quite tricky to me. I run the same sieve program using lambda implementation of lazy list in Common Lisp, but the memory usage will soon blow up and exceed more than 400MB for only taking 10000 primes.
23:30:23 <emu> nobody writes verifications
23:30:36 <pebblestone> sjanssen: while the haskell version only use 1.5MB ...
23:30:44 <Cale> Even if you don't write it down in exactly that format, that's what it is in your head. :)
23:31:04 <Cale> And to a large extent, that's what it should be on paper as well.
23:31:06 <newsham> lemma rev_rev [simp]: "rev (rev xs) = xs"
23:31:14 <emu> what people write down are arguments that hopefully will instigate that in the head of the audience members
23:31:15 <newsham> apply(induct_tac xs)
23:31:17 <newsham> apply auto
23:31:19 <newsham> done
23:31:21 <kc5tja> The notation used on some of the more formal proofs is all hieroglyphics too.
23:31:23 <Cale> emu: right.
23:31:41 <Cale> In initial courses, it's good to be extremely clear about it though.
23:31:45 <emu> you can't read a proof like prose
23:31:50 <roconnor> newsham: qed
23:31:53 <emu> *ordinary prose
23:31:58 <sjanssen> pebblestone: are you testing something like "main = print allPrimes"?
23:32:04 <Cale> kc5tja: That's just a matter of learning that notation.
23:32:06 <emu> it's much more dense. treat it like a program.
23:32:21 * QtPlatypus reads http://okmij.org/ftp/Computation/monadic-shell.html finally thinks he gets monads.
23:32:22 <lambdabot> Title: UNIX pipes as IO monads
23:32:27 <newsham> i like how predict calculus proofs are laid out in GEB
23:32:27 <pebblestone> sjanssen: main = putStrLn $ show $ last (take 10000 primes)
23:32:32 <newsham> predicate
23:32:49 <Cale> newsham: yeah, GEB does a decent job of introducing that.
23:32:58 <newsham> > take 100 $ nubBy (\x y -> y `mod` x == 0) [2..]
23:33:00 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:33:36 <newsham> > last $ take 10000 $ nubBy (\x y -> y `mod` x == 0) [2..]
23:33:40 <lambdabot> Terminated
23:33:58 <kc5tja> I dunno.
23:34:00 <Cale> hmm, what is done? return () ?
23:34:09 * kc5tja is just not convinced that math is a good idea for him.
23:34:13 <emu> kc5tja: did you read GEB?
23:34:29 <kc5tja> emu: I cannot read a book of that size; and just reading the introduction put me thoroughly to sleep.
23:35:23 <sjanssen> pebblestone: a 10000 element linked list doesn't eat very much space (less than 150 kb according to my calculations)
23:36:01 <newsham> kc5: it gets better after he gets past some of the preachy religeous crap at the beginning
23:36:27 <newsham> you can probably skip through it to parts that are interesting
23:36:28 <pebblestone> sjanssen: yes, but without elimination of intermediate results, everytime a new prime comes out, it will create a new list by the filter.
23:36:41 <Cale> pebblestone: it will?
23:36:43 <kc5tja> newsham: What some people claim to be better, I find otherwise.  Jumping around the book, I found pretty much the whole thing to be a bore.
23:36:59 <newsham> oh well
23:37:02 <Cale> pebblestone: perhaps I should run some of that code by hand and list the results
23:37:05 <pebblestone> sjanssen: I mean if it does not optimize the  intermediate result
23:37:25 <sjanssen> pebblestone: I bet you get similar memory performance from hugs
23:37:31 <pebblestone> Cale: yes, the filter will create a new one.
23:37:42 <pebblestone> sjanssen: I'll try it in hugs.
23:37:54 <newsham> i guess i wouldnt expect someone named kc5tja to be the kinda person to enjoy GEB
23:38:21 <kc5tja> newsham: Your statement makes no sense; what does my online name have anything at all to do with GEB?
23:38:38 <newsham> kc5tja sounds so robotic and GEB tries to be so artistic
23:38:44 <sjanssen> pebblestone: yes, there is an intermediate list created by filter.  But that list is consumed and produced lazily, so at any given moment only a very small portion of that list is actually in memory
23:38:46 <kc5tja> (for the record, it's my ham radio callsign)
23:39:01 <pebblestone> Cale: so 10000 elements will have 9999 list associated and if you implement it use closures, then 9999 closures will be created... absolutely memory killer.
23:39:07 <kc5tja> Artistic, I am not.
23:39:25 <kc5tja> At least, not in that frilly sense.
23:39:46 <pebblestone> sjanssen: I don't get it. filter :: [a] -> [a], right?
23:40:14 <pebblestone> sjanssen: at least, ghc figured it out that only a small portion is needed.
23:40:19 <nul-2845> (btw, thx-1138 rules)
23:40:30 <sjanssen> pebblestone: (a -> Bool) -> [a] -> [a], actually
23:40:37 <pebblestone> sjanssen: ah, yes
23:40:48 <sjanssen> dropMult is essentially a filter
23:41:21 <kc5tja> For all intents and purposes, one should generally approach me as if I have Asperger's Syndrome.
23:41:29 <sjanssen> pebblestone: this isn't a ghc specific feature, it is common among all Haskell implementations
23:41:39 <TSC> Ok, I have "fixed" 64-bit X11 bindings
23:41:50 <sjanssen> TSC: xmonad runs and everything?
23:41:51 <kc5tja> Although I've not been officially diagnosed, the symptoms described for it are pretty much describes me to a tee.
23:41:54 <hpaste>  Cale annotated "sieve" with "primes running" at http://hpaste.org/1065#a1
23:41:57 <TSC> sjanssen: Yeah, it runs
23:42:04 <TSC> And behaves
23:42:41 <TSC> But I don't know whether what I have done is in any way correct
23:42:50 <newsham> i think a lot of computer people want to believe they have asperger's
23:42:58 <sjanssen> TSC++ if you send me (sjanssen@cse.unl.edu) the patches, I can maintain temporary hosting alongside xmonad and X11-extras
23:43:10 <Cale> pebblestone: Yes, it will use a bunch of memory, but it's using up that memory on code.
23:43:13 <kc5tja> newsham: How else does one explain being a total social misfit?
23:43:39 <TSC> sjanssen: I'll try to narrow it down to the changes that actually did something
23:43:43 <newsham> lack of practice?
23:43:51 <TSC> My approach was not rigorous
23:43:54 <dufflebunk> lack of caring?
23:43:57 <kc5tja> Practice of what?
23:44:00 <Cale> The size of the tail after n elements is O(n)
23:44:12 <pebblestone> Cale: no actually it doesn't use that much memory. Hugs also works fine. I'll keep hacking it. thanks.
23:44:19 <newsham> to be good at something you have to practice
23:44:32 <newsham> kc: social interaction
23:44:58 <kc5tja> It's kind of hard to be good at social interaction when people would run away from you as you're growing up, like I was some kind of monster.
23:45:08 <kc5tja> Or when I was the school punching bag.
23:45:08 <Cale> pebblestone: It's just ordinary lazy evaluation which makes it work.
23:45:31 <dmead> o0
23:45:32 <kc5tja> Or when parties piss you off, just "because."
23:46:00 <Cale> I just largely didn't want to have anything to do with my peers.
23:46:11 <newsham> kc5: there's another explanation right there ;-)
23:46:15 <sjanssen> TSC: you can also comment on this bug http://hackage.haskell.org/trac/ghc/ticket/987
23:46:16 <lambdabot> Title: #987 (X11: foreign declarations use Haskell types instead of C ones) - GHC - Tra ...
23:46:23 <kc5tja> newsham: I don't follow.
23:46:34 <dufflebunk> Cale: I can see why, peer is mean, he reset Nioate's connection
23:47:19 <newsham> < kc5tja> newsham: How else does one explain being a total social misfit?  < kc5tja> It's kind of hard to be good at social interaction when people would run away from you as you're growing up, like I was some kind of monster. < newsham> there's another explanation right there
23:47:39 <Cale> For most of elementary and highschool, up until about grade 11 or 12, I didn't really consider most of the people in my class as being worth talking to. Eventually I came out of that antisocial thing to some extent. :)
23:47:42 <kc5tja> But that doesn't explain why they would not associate with me.
23:47:57 * dufflebunk sees a catch 22 looming
23:48:13 <newsham> dufflebunk: be careful.. literary reference.
23:48:15 <kc5tja> Cale: Unfortunately, most people I interact with aren't worthy of my attention, even to this day.
23:48:32 <newsham> kc5tja doesnt like the arts :)
23:48:50 <kc5tja> OK, if I'm going to be made fun of here, then I'll just leave.
23:48:52 <dufflebunk> newsham: I'm allowed, this is #haskell, not #VB
23:49:14 <Cale> kc5tja: Who's making fun of you?
23:49:25 <kc5tja> For what it's worth, I enjoy music, movies, etc.  To make a blanket statement like that is just uncalled for.
23:49:29 <kc5tja> 22:48 < newsham> dufflebunk: be careful.. literary reference.
23:49:31 <kc5tja> 22:48 < newsham> kc5tja doesnt like the arts :)
23:49:34 <kc5tja> Good night.
23:49:36 <kc5tja> I've had enough
23:49:38 <newsham> kc5tja: i didnt intend to offend
23:49:45 <newsham> all in good fun..
23:49:58 <newsham> cheers.
23:50:06 <kc5tja> You forget -- I don't understand the concept of "fun."
23:50:15 <kc5tja> night
23:50:19 <newsham> so you're allowed to poke fun of yourself?  no fair!
23:51:21 <arcatan> hmm, I have a friend who wants two believe he has asperger's
23:51:30 <arcatan> he's not really into cs, though
23:51:39 * sjanssen points to #haskell-overflow
23:51:41 <newsham> arcatan: its comforting having a reason, I guess.
23:51:48 <sjanssen> oops, #haskell-blah
23:51:51 <newsham> #haskell-blah?
23:52:19 <sjanssen> where #haskell regulars talk about everything but Haskell
23:55:24 <QtPlatypus> Are there pure functional lanugages that don't have closures?
23:55:41 <rahikkala> Excel ;)
23:56:11 <earthy> excel isn't pure
23:56:31 <earthy> iirc
23:56:55 <ski> iirc, Erlang core didn't have HOFs for some time ..
23:57:12 * QtPlatypus was thinking that it would be possable to compile such a lanugage down to pure gates.
23:58:35 <newsham> qtplatypus: what's the problem with closures?
