00:14:49 <dons> ?users
00:14:50 <lambdabot> Maximum users seen in #haskell: 336, currently: 298 (88.7%), active: 27 (9.1%)
00:25:22 <dmwit> ?hoogle (./)
00:25:23 <lambdabot> Did you mean: (./)
00:25:23 <lambdabot> Prelude.undefined :: a
00:25:23 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
00:25:34 <dmwit> =(
00:26:31 <nmessenger> dmwit: whatcha looking for?
00:27:21 <dmwit> I want to know what that function does.
00:27:26 <dmwit> I'm reading somebody else's source.
00:27:31 <nmessenger> where'd you see it?
00:27:43 <dmwit> I can't even figure out which modules to import to ghci to do a :t on it.
00:27:47 <dmwit> Errr...
00:27:49 <dmwit> One sec.
00:28:09 <dmwit> Okay, it's defined later in the code.
00:28:13 * dmwit is embarassed
00:33:30 <malcolmw> dons: were you impressed by the way I replaced "Fast"PackedString by ordinary lists, and got a 6x speed-up?
00:33:56 <Cheery> Hm.
00:36:37 <Cheery> I have class Drawable, I'd want a list which contains instances of Drawable.
00:37:41 <nornagon> @src catchError
00:37:42 <lambdabot> Source not found. Do you think like you type?
00:37:47 <Cale> Cheery: that's doable with existential types
00:37:48 <nornagon> @src Error catchError
00:37:48 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
00:38:52 <malcolmw> data Drawables = forall a . Drawable a => DR [a]
00:38:53 <Cale> data SomeDrawable = forall a. Drawable a => SD a
00:39:26 <Cale> malcolmw: that's not quite right, because they'd still all have to be the same instance of Drawable like that
00:39:53 <malcolmw> Cale: oh yeah.  I'm teaching by counterexample |:-)
00:39:55 <Cheery> Hmm. I continue reading from a wiki now, since I now know what I'm looking for.
00:40:50 <Cale> Cheery: basically, this SD data constructor throws away the knowledge of what type of thing you have, and only retains the fact that it's an instance of Drawable.
00:41:09 <Cale> So you can have a list of [SomeDrawable]
00:51:41 <nornagon> What's the 'a' in ReaderT Foo a?
00:51:50 <nornagon> er
00:51:55 <nornagon> ReaderT Foo Bar a
00:54:35 <Botje> the a is your final value, apparently
00:55:26 <Botje> s/value/type/
00:59:10 <nornagon> Hm.
00:59:33 <nornagon> this runFooT stuff is scaring me: runIdentity (runStateT (runWriterT (runErrorT (runReaderT ev env ))) st)
01:01:49 <Botje> runAwayT (runFasterT (runRaptorT runYouLose))
01:02:51 <Botje> (I wonder what a RaptorT would be like)
01:04:39 <Korollary> a raptor transformer
01:05:02 <Korollary> an anti-extinction device
01:05:33 <Botje> jurassicPark :: RaptorT Fast Hungry Vicous
01:05:33 <Botje> :)
01:06:15 <nornagon> heh
01:07:18 <osfameron> are there text-adventure libraries for Haskell ?
01:07:46 <osfameron> (that RaptorT declaration looked a bit like an Inform 6 one :-)
01:13:46 <dons> malcolmw: yes, that's rather interesting/disturbing...
01:14:11 <dons> i guess we've optimised based on some assumptions about how ghc compiles a ForeignPtr to an Addr#...
01:14:33 <malcolmw> dons|: it just goes to show that optimising a data represetnation for a single compiler means you get a fast data structure for that single compiler!
01:14:43 <dons> yep
01:15:23 <dons> we assume things about the representation, about the effect of strictness, about the kind of core that is generated, about the results of the specConstr optimisation, and inlining
01:15:25 <malcolmw> I was originally planning to compare fps with the original PackedString, and suddenly thought, why not get a baseline from lists
01:15:33 <malcolmw> and was surprised
01:15:40 <dons> PackedString would be interesting.
01:15:52 <dons> since that's sort of 'natively' supported in nhc? (a bit like bytestrings in ghc)
01:16:28 <malcolmw> yes, PackedString is 'native' as it were, although to be honest I think it probably has much the same overheads as fps
01:16:51 <malcolmw> there might be one indirection fewer per lookup or something
01:17:17 <dons> ok. that sounds reasonable.
01:17:41 <malcolmw> PackedString was always supposed to be a space optimisation in nhc98, never really considered as a speed trick
01:19:28 <dons> i wonder how far we'd get with bytestring in nhc98 if we could get a similar representation (heap allocated Addr#)
01:19:51 <malcolmw> dons: I was discussing that with dcoutts on Friday
01:20:49 <malcolmw> we came to the conclusion that supporting pinned structures in heap was possible, but would require largish changes to the memory allocator, GC etc
01:21:31 <dons> mm. ok. too much work then.
01:22:08 <malcolmw> One way to gain speed, especially on arithmetic, might be to do unboxing.
01:22:38 <malcolmw> Niklas added some stuff in the compiler to deal with unboxing, but it never got finished
01:22:56 <dons> ah ok. yes, that might help.
01:23:13 <malcolmw> And of course the biggest gain would be through higher-level optimisation, e.g. fusion
01:23:51 <dons> right.
01:23:53 <malcolmw> .me would love to work on all these things, but has a paid project to do as well
01:24:09 <mux> blah
01:24:26 <dons> its good though, we can check we don't break things on nhc98 now.
01:24:31 <dons> rather than just checking in hugs
01:24:31 * mux has to deal with developers that don't understand APIs and write bullshit in manpages afterwards
01:24:35 <mux> go open source!
01:24:53 <dons> dcoutts and i'll be doing quite a bit of bytestring hacking i nteh coming weeks, so its good to have nhc98 support now.
01:25:28 <malcolmw> yeah, I heard dcoutts will be in oz for a bit
01:27:55 <malcolmw> dons: how come hbc seems to be totally broken on x86?
01:28:27 <triplah_> mux: what project? :\
01:28:57 <mux> triplah_: FreeBSD
01:29:05 <triplah_> mux: argh :|
01:29:34 <mux> someone didn't get the *sleep()/wakeup() API and is butchering manpages
01:29:49 <triplah_> :\
01:29:55 <triplah_> revert is your friend
01:30:27 <mux> we're not supposed to just plain revert other people's changes :-)
01:30:34 <triplah_> haha
01:30:46 <quicksilver> make a change yourself, then
01:30:50 <mux> it would lead to endless commit wars, and we've had enough of those in the past
01:30:52 <quicksilver> and then revert *that* all the way back
01:31:02 <mux> no, I'm just harping on him with mails, as other devs are doing
01:31:05 <quicksilver> :)
01:31:28 <mux> so that at some point he'll either back out, or we'll have sufficient claims that his change is wrong for core@ to back it out
01:54:45 <Cff> @hoogle map
01:54:46 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
01:54:46 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
01:54:46 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
01:54:51 <Cff> neat
02:07:10 <mux> 40985 root        1  96    0  4287M  4274M select 0 391:01  4.93% snmpd
02:07:11 <mux> ouch
02:14:23 <mux> and no, this isn't an SNMP daemon written in Haskell ;-)
02:35:12 <dons> malcolmw: oh, well spotted. i moved the location of 'cc' by accident
02:37:45 <wkh> i wish i could empathize with users
02:37:57 <malcolmw> dons: I'm surprised to see that ghc-asm gives output errors.  Are you sure that ghc-head is correct, or is it possible that ghc-6.6 is actually doing the right thing in those cases?
02:38:00 <wkh> there are basically no web applications that have any degree of programmability.
02:38:08 <wkh> would uesrs care if they could?
02:38:10 <wkh> i have no idea.
02:38:14 <wkh> because i don't think ilke a user
02:38:49 <dons> seems like the known issues with floating point precision in the native code gen
02:38:53 <dons> though i've not looked closely
02:38:55 <nominolo> wkh: what kind of programmability?
02:38:55 <sebell> wkh: Yah, I don't use the web either.
02:39:03 <dons> i think i need to turn on one of the precision flags
02:39:16 <wkh> nominolo: e.g., adding some kind of analogue to Visual Basic for Applications to an online spreadsheet application
02:39:34 <mux> dons: hello! I've built yi from darcs HEAD yesterday, with GHC 6.6, and it dies immediately when I launch it, with an unhandled GhcException. is that a known problem?
02:39:55 <Igloo> I don't think there are flags for FP precision for the NCG
02:39:58 <mux> I can do yi -h and yi -V without having it die, but that's about it :-)
02:40:05 <nominolo> wkh: i don't think so.  also, it would require enormously more complexity in the webapp
02:40:40 <nominolo> wkh: and requires to take care of a lot of security issues
02:40:40 <dons> mux, jyp has taken over development of yi, you should check with him
02:40:45 <mux> dons: ok
02:40:53 <dons> there's been a *lot* of changes recently, so i'm not surprised its unstabe
02:40:53 <mux> is he IRC'ing somewhere?
02:41:02 <dons> @seen jyp
02:41:03 <lambdabot> I saw jyp leaving #oasis, #haskell.fr and #haskell 2d 12h 7m 33s ago, and .
02:41:04 <osfameron> wkh: you writing an online spreadsheet app in Haskell ?
02:41:08 <mux> okay :)
02:41:13 <nominolo> wkh: i think customized web-apps are ok
02:41:20 <dons> not usually. but you can mail him.
02:41:28 <osfameron> I think programmability of spreadsheets rocks.  But if you can avoid it (by having a powerful enough expression language), that might be better
02:41:36 <nominolo> wkh: or customizable for a specific company -- but not necessarily for any end user
02:42:07 <dons> Igloo: I thought there were known isues with floating point precision in the native code gen on x86?
02:42:21 <dcoutts> malcolmw, mm, I expect that's right. For ghc the [Char] -> ByteString representation change gets us more factors than the fusion (eg 5x vs 2or3x) but for an interpreter like nhc98 I expect the fusion would have a greater effect since it's eliminating real steps.
02:42:40 <Igloo> dons: Do you mean excess precision from the larger registers, or something else?
02:44:11 <dons> the output errors on -fasm x86 are in low end floating point numbers, e.g. -3.2225053e-5 vs -3.2225256e-5
02:44:32 <dons> now, i'm pretty sure simonM knows about this, and I though we could tweak it somehow.
02:44:42 <dons> or maybe the tweak is to use -fvia-C ?
02:45:01 <dons> i note everythings fine on amd64
02:45:14 <Igloo> If you go via C then you can tell gcc not to use excess precision (or perhaps that is the default, I forget)
02:45:20 <matthew_-> what about intel with 64 bit?
02:45:31 <Igloo> Hmm, I thought amd64 behaved the same
02:45:33 <dons> excess precision isn't the default, iirc. that's why we turn it on for more speed
02:45:46 <blackdog> hey, are there any haskell+erlang hackers around? any tips on avoiding the anguish of not having mutually recursive 'where' forms?
02:45:54 <blackdog> (i exaggerate, but only slightly)
02:46:04 <dons> blackdog: urgh, really? didn't know that.
02:46:09 <blackdog> yeah
02:46:17 <blackdog> you can have mutually recursive top-level funcs
02:46:31 <matthew_-> dons: should the base ghc libraries be compiled with excess-precision?
02:46:34 <dons> so you've moved into the erang camp eh? ;)
02:46:48 <blackdog> and you can define anon funcs in a function that inherit its variables
02:47:00 <dons> matthew_-: well, no, we want ieee math.
02:47:06 <blackdog> but they can't call each other, because they're introduced one by one.
02:47:19 <blackdog> dons: well, i'm trying to expand my mind a little.
02:47:49 <blackdog> the syntax for erlang is a bit grotty, but the runtime model seems really interesting.
02:48:09 <dons> definitely.
02:48:26 <blackdog> (and that whole "oh, that's a good idea, why don't i spend a year re-implementing it in My Favourite Language" thing is so lame.)
02:48:41 <blackdog> so i'm just going to drop in here and bitch instead :)
02:49:31 <dons> I wonder, is there no #erlang?
02:49:42 <wkh> the pragmatic programmers are putting out a book on erlang in july
02:49:42 <blackdog> there is
02:49:49 <blackdog> i've been asking silly questions there all day :)
02:50:09 <blackdog> most of the answers i get are pretty much just shrugs.
02:50:12 <ivanm> wkh: hook or book?
02:50:22 <ivanm> sorry, I can't read... thought it said hook :s
02:50:25 <wkh> book.
02:50:30 <blackdog> joe armstrong's thing, yeah?
02:50:33 <wkh> yes
02:53:33 <dons> http://programming.reddit.com/info/17yuj/comments <-- new
02:53:40 <lambdabot> Title: Persistence and concurrency using transactional memory in Haskell (reddit.com)
02:54:10 <wkh> whenever i see a snarky something.something.us title, i assume by default it's an arrogant ruby on rails user
02:54:29 <dons> heh
02:54:33 <wkh> er, url rather
02:54:36 <wkh> 3am here
02:54:50 <quicksilver> I wish CosmicRay had given some more details about his HSH use case example
02:55:01 <quicksilver> it sounded tantalizing, I wish he'd linked to some before-and-after source, for example
02:58:38 <wkh> what about a web based tool for letting non-programmers create boilerplate CRUD apps
02:58:48 <Botje> brilliant!
02:59:04 <Botje> and we'll name it after (some gem) on (a mode of transportation)
02:59:28 <matthew_-> emeralds on aircraft?
02:59:42 <wkh> most of my friends aren't programmers and i always wonder why they have no interest in deeply understanding computers, the most amazing and important invention in the history of the world
03:00:22 <blackdog> well, it's meant to be CRUDdy - how about geodes on garbage trucks?
03:00:23 <matthew_-> saphires on ocean-liners ?
03:00:28 <sebell> wkh: Probably because they're more attractive and popular.
03:01:03 <matthew_-> diamonds on scooters
03:01:38 <wkh> sebell: huh? are you insulting me?
03:02:34 <dolio> That probably depends on how ugly and unpopular your friends are.
03:02:54 <blackdog> wkh: i'd rather be a morlock than an eloi :)
03:03:36 <merus> I'd rather be a time-traveler than a morlock
03:04:02 <thief_grr> anyone got their hands on the fairly new book by graham hutton?
03:05:19 <sebell> Oh, and antibiotics is the most important invention in the world ;)
03:05:26 <dons> thief_grr: there's a review here, http://mult.ifario.us/articles/2007/02/25/review-of-programming-in-haskell, if that helps?
03:05:29 <lambdabot> Title: mult.ifario.us : Review of "Programming in Haskell", http://tinyurl.com/2xkk7n
03:06:13 <matthew_-> sebell: I think writing is actually the most important
03:06:35 <wkh> computers will eventually eclipse all of them.
03:07:03 <wkh> they've only been around for 50 or 60 years, personal computing for only 30 or so
03:07:05 <blackdog> wkh: steady on, big fella.
03:07:28 <blackdog> that's a pretty big call...
03:07:35 <sebell> matthew_-: True, I was thinking 20th century
03:09:14 <wkh> i don't think i engaged in hyperbole
03:10:05 <dons> sjanssen: haskell dwm please :-)
03:10:54 <nornagon> dwm as in the window manager?
03:10:55 <sebell> wkh: Computing, in and of itself, is relatively meaningless.
03:11:03 <nornagon> because that would be awesome in haskell
03:12:06 <wkh> managing and process massive amounts of information quickly, turning ideas into products and experiences, people connecting and sharing, that is potentially meaningful.
03:12:22 <wkh> i have no illusions of course that right now people mainly use computers for finding cartoons and porn on the internet.
03:12:34 <thief_grr> dons: thanks, fun thing about the torus
03:14:32 <dons> nornagon: yeah, we've been meaning to write our own dwm for months now, sjanssen's made some progress
03:14:55 <dons> since 50% of dwm is string processing and linked list code ...
03:15:06 <dons> we should be able to get the loc count down somewhat
03:15:07 <goltrpoat> dons:  oh, that'd be remarkably cool.
03:15:20 <nornagon> dons: :D
03:15:42 <dons> i'm hoping for around 500 lines of haskell
03:16:16 <goltrpoat> gtk?
03:16:20 <dons> no!
03:16:24 <goltrpoat> thank god.
03:16:28 <dons> btw, dwm is 1600 lines of C.
03:16:36 <Cale> http://xkcd.com/ -- ahaha
03:16:37 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
03:16:46 <Cale> the latest xkcd is great :)
03:17:05 <dons> Cale: i can't view it till it ppears on reddit
03:17:05 <goltrpoat> haha
03:17:26 <dons> hehe
03:17:31 <wkh> i love kittehs
03:18:01 <dons> they're cute.
03:18:37 <goltrpoat> dons:  wait, dwm as in the desktop window manager, or some other window manager?
03:18:46 <dons> no!
03:18:50 <mux> http://en.wikipedia.org/wiki/Image:God-kills-kitten.jpg
03:18:56 <dons> ?go dwm suckless
03:18:59 <lambdabot> http://dwm.suckless.org/
03:19:00 <lambdabot> Title: about
03:19:02 <quicksilver> dynamic, not desktop :)
03:19:29 <goltrpoat> ah ok, i was getting confused there for a minute
03:19:35 <goltrpoat> after the "1600 lines of c" comment
03:21:07 <goltrpoat> no shell-based configuration?
03:22:09 <goltrpoat> oh, holy crap.  just saw the customization bit.
03:22:25 <goltrpoat> cool.
03:23:58 <goltrpoat> haskell does make way more sense there.
03:25:37 <triplah_> is the struct the best way to model data? (short of using o'haskell)
03:25:49 <wkh> would it ever be possible to get the computer language shootout guy to change the benchmarks to not be, at best, meaningless
03:26:09 <goltrpoat> triplah:  depends on the data being modelled, no?
03:26:34 <matthew_-> wkh: not unless you succeed in making everyone do the same thing with a computer
03:26:38 <triplah_> goltrpoat: well i'm looking at porting classes from a python app
03:26:44 * mux finds the claims on dwm.suckless.org rather stupid
03:28:17 <goltrpoat> probably records then, although i suspect that a verbatim python->haskell port, depending on the style of python, would be less than idiomatic haskell
03:29:30 <triplah_> goltrpoat: yeah i'm aware of that, i just dont want to end up with functions like do_foo_to_bar
03:29:52 <triplah_> goltrpoat: i'm guessing there are no namespaces either?
03:30:14 <triplah_> actually, modules would give namespaces
03:30:18 <goltrpoat> modules are similar to namespaces
03:30:22 <triplah_> yep
03:30:47 <goltrpoat> particularly if you subscribe to the single file, single namespace point of view
03:31:55 <goltrpoat> you know you can pattern match on record fields, you can single out a record field to match, use an as-pattern to match the whole value at the same time, etc, right
03:32:26 <goltrpoat> (re the do_foo_to_bar part)
03:34:40 <goltrpoat> as in, your do_foo_to_bar should really be 'foo bar', where foo is a function whose domain is your record type, and you can write most of the extraction machinery pretty concisely
03:35:07 <dons> wkh, no. they're microbenchmarks for measuring particular aspects of the compiler. they're only meaningless if you misinterpret them
03:35:10 <triplah_> ahh yep
03:35:46 <triplah_> goltrpoat: yeah, thats excellent. that combined with my module/namespaces will give me all the abstraction i need
03:35:54 <goltrpoat> cool
03:36:17 <pejo> dons, considering how people write code for them - it's pretty non-standard stuff you're doing.
03:36:50 <dons> using standard libraries?
03:36:55 <dons> its library code, really.
03:37:06 <pejo> (But if it leads to people fixing so that the idiomatic way of writing code is equally fast that's great).
03:37:07 <dons> the kind you'd write for a high perf library
03:37:26 <dons> people should look at the current code too, its a lot different to last year's entries
03:37:32 <dons> i.e. no primops, iirc.
03:37:38 <goltrpoat> someone pointed me to another benchmark site, as an attempt at showing that ocaml was, in general, faster than ghc
03:37:50 <goltrpoat> it had very idiomatic, to the point of being naive, code -- both in ocaml and in haskell
03:38:08 <dons> measuring differnt data structures, I presume?
03:38:20 <dons> such as strict unboxed ocaml strings vs boxed, lazy haskell [Char]?
03:38:25 <goltrpoat> (the ocaml was a bit nicer, along the lines of using arrays for a matrix multiplication benchmark where the haskell code was using lists)
03:38:36 <goltrpoat> but yes, along those lines
03:38:40 <dons> yeah, so they're not measuring the same thing at all
03:38:45 <goltrpoat> right, definitely not
03:39:06 <dons> whereas the shootout measures the same thing
03:39:13 <dons> we use strict unboxed arrays, so does everyone else
03:39:51 <dons> if you want to have an idea of the peak performance you can get out of some haskell code, the shootout is reasonable for that.
03:40:13 <goltrpoat> -nod-
03:40:19 <dons> it shouldn't really be used for cross-language comparisons, though of course people do do that
03:40:28 <goltrpoat> i was just reminded of that due to the "so that the idiomatic way of writing code is equally fast" comment
03:42:47 <quicksilver> it's not a worthless thing to try to compare (idiomatic code speed)
03:43:03 <quicksilver> the problem is, it's rather easily influenced by choice of idiomatic problems :)
03:43:13 <goltrpoat> hehe
03:43:15 <goltrpoat> there's definitely that.
03:43:24 <dons> yeah, naive isn't necessarily idiomatic
03:43:36 <quicksilver> a carefully crafted algorithm which ran over multi-gigabyte tree structures
03:43:36 <opqdonut> :)
03:43:45 <quicksilver> and used haskell's laziness to run in constant space
03:43:55 <quicksilver> would give a pretty big idiomatic advantage to haskeel :)
03:44:04 <dons> oh, the trials we've had with laziness in the shootout. its basically disallowed :}
03:44:14 <goltrpoat> hah
03:44:16 <quicksilver> the equivalent naive program would blow up in ocaml
03:44:27 <dons> either everyone must run in constant space, or you must use O(n) space and be strict
03:44:48 <quicksilver> of course you can argue whether or not such problems are common in real life is open for debate
03:44:51 <beelsebob> seeing as the latex channel is useless I'll try a channel full of accademics instead... anyone know how to get a backslash while in the alltt environment?
03:44:52 <dons> e.g. binarytrees was rewritten a few days ago after being too fast, and using too little space
03:44:55 <dons> funny :-)
03:45:06 <profmakx> that sounds totally lame to me -.-
03:45:50 <quicksilver> beelsebob: \backslash ?
03:46:03 <pejo> dons, do they change the benchmark in a stupid way so laziness can't be used? ("Must take O(n) space")
03:46:07 <beelsebob> quicksilver: I get errors about entering the math environment
03:46:34 <fishkandy> we need our own shootout :-)
03:46:43 <dons> another good one was the Bool benchmark. haskell bool arrays use bitsets, which are too fast and use too little space
03:46:52 <opqdonut> :D
03:46:54 <dons> so we had to rewrite it with type BoolT = Word8
03:47:08 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/801
03:47:10 <pejo> dons, that's really stupid, too.
03:47:11 <norp> too fast?
03:47:14 <quicksilver> beelsebob: http://groups.google.co.uk/group/comp.text.tex/browse_thread/thread/5bc403488d9072ce/037080850a8f3ecc?lnk=st&q=backslash+alltt&rnum=1#037080850a8f3ecc
03:47:17 <lambdabot> Title: Backslash inside alltt - comp.text.tex | Google Groups, http://tinyurl.com/24n3go
03:47:27 <quicksilver> beelsebob: google groups is the key, for latex questions
03:47:31 <dons> there's a few benchmarks like that we're the haskell version has to be rewritten to run worse
03:47:40 <beelsebob> quicksilver: thanks, that's a good hint
03:47:41 <dons> norp, yeah the benchmark measured cache misses
03:47:50 <dons> so if you pack everything into bits, you hit the cache more often
03:47:56 <goltrpoat> dons:  eh?  that can't be right.  std::vector<bool> is a bitvector according to the c++ spec, that wouldn't give haskell any particular advantage over anyone
03:48:01 <dons> and haskell ran something like 3x faster with IOUArray Bool
03:48:09 <dons> c++ was also disqualified for that
03:48:13 <goltrpoat> ah
03:48:14 <opqdonut> :)
03:48:26 <dons> though the haskell entry still beat the C++ one. which is nice
03:48:30 <goltrpoat> hehe
03:48:32 <fishkandy> dons: do we have an archive of the disqualified code, and why it was disqualified?
03:48:33 <norp> so use int's instead of bool
03:48:40 <norpan> ints
03:48:54 <dons> all the code is on haskell.org/haskellwiki/Shootout, some have explanations why they're disqualified
03:49:00 <fishkandy> awesome :-)
03:49:02 <dons> actually, a lot of idiomatic stuff isn't allowed
03:49:21 <dons> we used pure Tries instead of hashtabes in IO for another entry, no good. illegally fast
03:49:47 <dons> so its nice after all that , that even when made to emulate a strict non-smart language, haskell still does well :-)
03:50:06 <fishkandy> heh
03:50:25 <goltrpoat> that doesn't make a huge amount of sense.  i mean, nothing is preventing the other entries from going through the pain of implementing that functionality
03:50:47 <quicksilver> you can see where they're coming from. Their intention is to compare like with like.
03:50:48 <goltrpoat> i get apples to apples, but if the point is to compare languages on their merits, that seems a tad silly.
03:50:52 <dons> it comes down to the biases and random decisions of the organisers
03:51:06 <dons> if only one language can do some trick that's much better, usually they rewrite the spec
03:51:10 <dons> so it becomes: do what C does.
03:51:15 <goltrpoat> haha
03:51:18 <quicksilver> They aren't trying to compare algorithms to solve problems
03:51:23 <nornagon> what's the syntax for pattern matching on records? I keep forgetting :(
03:51:29 <quicksilver> they're trying to compare languages to implement algorithms
03:51:41 <quicksilver> so if your code appears to be 'a different algorithm'
03:51:43 <dons> no. its same data structure (usually), same algorithm
03:51:44 <quicksilver> they disqualigy it
03:51:55 <goltrpoat> C is the glb of the poset
03:52:03 <dons> yeah, though when that difference comes down to runtime behaviour, like laziness or GC issues, then its a bit annoying
03:52:20 <dons> or if its something baked low down in the language, like the Array Bool instance
03:52:28 <pejo> dons, can't you avoid GC:ing during the benchmark, iwth a big heap?
03:52:29 <goltrpoat> nornagon:  f (D { field = local }) = local
03:52:34 <fishkandy> the problem with comparing apples to apples is that haskell has "mango daiquiri" as a basic fruit
03:52:39 <nornagon> goltrpoat: thx :)
03:52:42 <dons> of course, its was fun early on, when most of the benchmarks asked for work to be done just to chew up time, and enver used the results
03:52:42 <goltrpoat> np
03:52:49 <dons> haskell was suspiously fast back then
03:53:05 <dons> ie. for (1000) do the same thing
03:53:07 <dons> print "done"
03:53:07 <sebell> dons: lol :)
03:53:21 <goltrpoat> haha
03:53:46 <opqdonut> @remember fishkandy the problem with comparing apples to apples is that haskell has "mango daiquiri" as a basic fruit
03:53:47 <lambdabot> Done.
03:53:49 <dons> so now all benchmarks ask for different intermediate results to be printed, to make sure everyone evaluates the same stuff
03:53:52 <opqdonut> @quote apple
03:53:53 <lambdabot> fishkandy says: the problem with comparing apples to apples is that haskell has "mango daiquiri" as a basic fruit
03:53:56 <opqdonut> :)
03:53:59 <opqdonut> fishkandy++
03:54:19 <nornagon> how about for creating new records? (i.e, i have some record data Foo { a :: Integer, b :: String }, how do I get a new Foo?)
03:54:31 <dons> pejo, it was more for things like binarytree traversals, where the haskell version allocated nodes on demand, and immediately GC'd them, so it ran in tiny space.
03:54:43 <opqdonut> :)
03:54:47 <dons> whereas all the apple and orange languages allocated the whole tree strictly
03:54:59 <quicksilver> nornagon: Foo 1 "apple"
03:55:07 <dons> so yeay, mango daiquiri is considered too posh
03:55:07 <nornagon> quicksilver: ah, okay.
03:55:32 <goltrpoat> nornagon:  if data D = D { field :: Int, field2 :: String } in the above example, then g (D i s) = D { field = i+1 }
03:55:42 <goltrpoat> returns a D with an incremented 'field'
03:55:59 <quicksilver> nornagon: or, Foo { a = 1, n = "apple" }
03:56:09 <pejo> dons, well, you're paying with cycles to do the GC over and over again though.
03:56:22 <goltrpoat> also, \d -> D { field = field d + 1 }
03:56:47 <dons> was cheaper in the end though. i guess issues like locality come into play (some 20% slower once the tree is strictly allocated, only runs as fast as C :/)
03:56:51 <quicksilver> goltrpoat: your i+1 example is incorrect
03:57:03 <goltrpoat> quicksilver:  it is?
03:57:07 <goltrpoat> oh
03:57:10 <goltrpoat> yes, sorry
03:57:11 <quicksilver> goltrpoat: that creates a new D, with undefined in field2
03:57:13 <pejo> dons, wow. Nice.
03:57:18 <goltrpoat> g d@(D i s) = d { field = i + 1 }
03:57:21 <goltrpoat> same for the lambda one
03:57:22 * quicksilver nods
03:57:39 <dons> so the rule is basically: do whatever the shootout guys ask, and hope they don't get mean.
03:57:58 <pejo> dons, I guess you're avoding higher order functions though, and other things that might cause indirect jumps?
03:58:04 <dons> i'm still waiting for smp/multicore benchmarks ;)
03:58:19 <dons> often yes. lots of tight strict loops
03:58:21 <goltrpoat> the smp benchmarks should be fun
03:58:28 <dons> the binarytree stuff is just naive tree code though
03:58:54 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=all
03:58:57 <lambdabot> Title: binary-trees benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/zx84m
03:59:01 <dons> note the haskell version now has to use strict trees
03:59:46 <pejo> Would be interesting to see the cache statistics for the previous lazy version.
03:59:59 <dons> yeah, i've kept that as a benchmark program in nobench, in fact.
04:00:09 <goltrpoat> dons:  you're being remarkably nice in that top comment, there.
04:00:09 <goltrpoat> hehe
04:00:22 <dons> second from the top, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
04:00:22 <lambdabot> Title: nobench: Haskell implementation shootout
04:00:36 <dons> goltrpoat: oh you have to be. everyone on the web reads that stuff. :-)
04:01:31 <goltrpoat> oh, didn't realize jhc was GRIN.  makes sense i guess.
04:01:59 <dons> and a bit unstable :-)
04:02:02 <goltrpoat> hehe yeah
04:02:24 <dons> x86 is a bit better, http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
04:02:24 <lambdabot> Title: nobench: Haskell implementation shootout
04:02:31 <pejo> dons, is the compiler allowed to optimize whatever way it chooses?
04:02:33 <goltrpoat> "novel type class implementation not based on dictionary passing"  -- i was just thinking about that earlier
04:03:03 <dons> pejo, yeah, unless the optimisation does something too smart
04:03:11 <dons> e.g. like the Bool packing arrays
04:03:12 <goltrpoat> although im not sure how that would work in the presence of explicitly quantified things
04:03:17 <dons> of course, its fine to be too dumb :-)
04:04:56 <Saizan> oh, what makes ocaml so fast on binarytrees?
04:04:57 <goltrpoat> ("that" being eliminating dictionary passing through static analysis)
04:05:23 <dons> good code generator? cheating? i'm not sure, we'd have to check the generated code.
04:05:27 <dons> the input code looks fine.
04:05:38 <dons> its a good compiler, ocaml.
04:06:09 <goltrpoat> they're revising the syntax.
04:06:17 <goltrpoat> some odd choices there.
04:06:26 <kzm> Hi!  I have a stack leak using unfoldr from Data.Bytestring.  That should only happen if the unfoldr'ed function is too lazy, right?
04:06:26 <dons> any word on smp support?
04:06:33 <goltrpoat> no clue
04:06:39 <dons> kzm, hmm. if the seed is too lazy maybe?
04:07:05 <dons> kzm, you can also manually unroll the unfoldr as a loop, and be as strict as you want.
04:07:34 * dons `ap` sleep. play type-safe everyone!
04:07:34 <nornagon> hrm, I have a list of foos. I want to map a function over it such that the function is executed for each element (like map), but is additionally passed a list of all the elements in the original array except the current one.
04:07:41 <triplah_> i looking thru haskell i wrote in 05, i cant remember much :'(
04:08:10 <triplah_> optimal string alignments
04:08:42 <Saizan> you mean original list?
04:09:00 <nornagon> er
04:09:00 <nornagon> yes
04:09:02 <nornagon> sorry
04:09:18 <goltrpoat> nornagon:  a naive n^2 version could be something like \f xs -> map (\x -> f x (delete x xs)) xs
04:09:24 <Saizan> that seems almost like a cobind, but might be overkill
04:10:12 <nornagon> goltrpoat: but suppose i have a list [1,2,1]. That should call: f 1 [2,1] then f 2 [1,1] then f 1 [1,2]
04:10:28 <nornagon> order of the list of non-this-one elements not important
04:10:34 <goltrpoat> yeah, i thought that's what you were asking for
04:10:58 <Saizan> normagon: have you used a zipper before?
04:11:22 <nornagon> Saizan: briefly
04:12:04 <goltrpoat> delete only deletes the first element it sees that equals its first argument, it's not filter (/=x)
04:12:18 <nornagon> goltrpoat: oh, hm
04:12:28 <nornagon> i guess that works, since order isn't important
04:12:31 <goltrpoat> but.. that version is pretty ugly
04:12:37 <nornagon> agreed
04:13:14 <Saizan> well imagine you have a list zipper like Z a = Z [a] a [a]  where the first lists are the elements before and after the point where you are
04:13:32 <Saizan> s/first//
04:14:00 <vincenz> What is the syntax fo guards?
04:14:03 <nornagon> right
04:14:11 <vincenz> and can you have more than one/func-delc?
04:14:12 <nornagon> vincenz: f a | a == 0 = foo
04:14:17 <nornagon> yes
04:14:29 <nornagon> add a second | (cond) = (expr) clause
04:14:34 <vincenz> ah cool
04:14:35 <nornagon> on a new line possibly?
04:14:37 <vincenz> thx
04:14:39 <quicksilver> >  let f l [] = [] ; f l (x:xs) = (x,l ++ xs) : (f (l++[x]) xs) in f [] [1,2,3,4]
04:14:40 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
04:14:50 <quicksilver> nornagon: there's a zipped up 'each element and the rest'
04:14:54 <quicksilver> nornagon: you could then map over that
04:15:02 <nornagon> cool :)
04:15:05 <nornagon> quicksilver++
04:15:31 <quicksilver> if order doesn't matter in 'the rest' but speed does matter, it would be faster to replace l++[x] with x:l
04:15:33 <Saizan> heh simpler than a comonad :)
04:15:49 <nornagon> quicksilver: awesome, thanks
04:15:59 <quicksilver> Saizan: well everyone should learn about Zippers sometime
04:16:06 <quicksilver> Saizan: but each person has to choose his time
04:16:18 <quicksilver> (ideally that time would be with conor mcbride giving a seminar on it :)
04:16:52 <Saizan> (if i knew who he is i would agree :)
04:18:01 <quicksilver> one of the epigram team; keen on talking about how the derivative of a type is the type of its one-hole contexts
04:18:09 <quicksilver> a notion which is all tied up with zippers
04:18:31 <Saizan> btw, i don't grasp what the complexity of a cobind with a linear zipper is
04:23:51 <goltrpoat> > let mapZ f xs = [f x (ls++rs) | (ls, (x:rs)) <- zip (inits xs) (tails xs)] in mapZ (\x xs -> toUpper x : xs) "test"
04:23:53 <lambdabot>  ["Test","Etst","Stet","Ttes"]
04:26:30 <goltrpoat> more reminiscent of zippers, since the comprehension is singling out elements together with their closure of sorts
04:26:41 <quicksilver> goltrpoat: yes, nice
04:26:45 <cpfr> holy crap, i just grokked monads
04:26:55 <quicksilver> goltrpoat: although technically mine is more efficient since I only traverse the list once
04:27:06 <goltrpoat> true
04:27:11 <quicksilver> goltrpoat: but maybe the compiler doesn't care :)
04:28:15 <quicksilver> and certainly that's not somethine the programmer should care about ideally
04:33:11 <goltrpoat> i suspect some of it gets fused, but i just broke my brain trying to figure out how
04:34:12 <quicksilver> tails is a lovely example of an efficient function
04:34:24 <quicksilver> since all it does it return successive pointers into the same already extant data structure
04:34:31 <quicksilver> unfortunately inits, being dual, is terrible :)
04:34:36 <goltrpoat> heheh
04:35:47 <mnislaih> dcoutts: around?
04:35:47 <opqdonut> inits = (map reverse) . tails . reverse
04:35:49 <opqdonut> 8)
04:35:57 <goltrpoat> yeah
04:35:57 <dcoutts> mnislaih, aye
04:36:04 <mnislaih> dcoutts do you know if the latest gtk2hs release is expected to work on Mac Os Intel? I compiled it, but hello world dies with "bus error"
04:36:13 <mnislaih> I'm using GHC 6.6
04:36:29 <dcoutts> mnislaih, if ghc works and gtk+ itself works then yes, gtk2hs should work.
04:36:47 <mnislaih> thanks, I'll dig more
04:37:12 <dcoutts> mnislaih, let me know what you find out
04:37:59 <quicksilver> opqdonut: well if you're into micro-optimisations, then there's something to be said for just 'tails.reverse'
04:38:12 <goltrpoat> and i guess then you end up asking for a nice enough structure that lets us query tails and heads in decent time, which goes back to what Saizan said originally
04:38:13 <quicksilver> opqdonut: and then adjusting your algorithm to understand that it is dealing with reverse lists
04:38:22 <nornagon> on with the record syntax, what's record update look like?
04:38:30 <goltrpoat> tails and inits rather
04:38:31 <nornagon> foo { field1=newval }?
04:38:36 <quicksilver> but then again, if you're going that far, you should probably just go to a stream syntax like FPS
04:38:48 <goltrpoat> nornagon:  yep
04:38:54 <quicksilver> which is direction agnostic and fast-as-heck
04:39:38 <goltrpoat> quicksilver:  dan piponi had wrote a nice exposition on his blog a while back
04:40:25 <goltrpoat> er.  replace 'had wrote' with either 'had' or 'wrote'
04:40:33 <mnislaih> dcoutts: I tried launching with gdb, it gives a "EXEC_BAD_ACCESS, could not follow memory" with reason "KERN__PROTECTION_FAILURE at address: 0x00000008" in strcmp ()
04:40:37 <mnislaih> does that ring any bell ?
04:40:49 <dcoutts> nope, sorry.
04:41:13 <dcoutts> got a stack trace?
04:41:33 <mnislaih> let me see,
04:41:56 <mnislaih> hmm nothing helpful there
04:43:02 <mnislaih> FcPatternPosition shows up. googling it indicates a problem relating to a font
04:44:06 <huschi> hi. is it possible to write a parser combinator library like parsec with arrows? if yes, are there any resources on that topic in the web?
04:46:24 <quicksilver> huschi: googling for 'arrow parsers' brings up a bunch of hits
04:46:40 <quicksilver> huschi: some sources would say that parsers were the inspiration for arrows
04:47:37 <huschi> ah, my google was configured to search only german web pages.
04:47:40 <huschi> quicksilver: thx.
04:47:47 <goltrpoat> speaking of records, there was a cool trick in THIH.  data D a = D { f :: a -> Bool }, say.  then update :: D a -> a -> D a, and update (d@{ f = f' }) el = d { f = \el' -> if el == el' then True else f d el' }
04:48:27 <goltrpoat> so you get to literally build up case analysis
04:49:06 <goltrpoat> starting from initD = D (const False) as the base case
04:51:44 <goltrpoat> so then update initD 1 adds 1 to the list of things that f returns True for, update (update initD 1) 2 adds 1 and 2, foldl update initD xs adds xs.  the f d inside the curlies accesses the bound d, i.e. the old one.
04:53:46 <goltrpoat> er.  that should be just update d, sorry.  was writing it from memory and paraphrasing at the same time.
04:57:19 <goltrpoat> anyway.  weird use of records, data structures composed entirely of thunks, thought it was cool.
04:57:40 <SamB> goltrpoat: what? entirely of thunks?
04:57:49 <goltrpoat> sure.
04:57:51 <SamB> don't you need some non-thunks to hold the thunks together?
04:57:56 <psnl> mnislaih: seen a similar problem with gtk2hs...
04:58:14 <goltrpoat> samb:  once you pull it out, yes
04:58:31 <psnl> mnislaih: I think the ghc in ports works, but my homebuilt ghc doesn't.
04:58:36 <goltrpoat> a giant case statement is a data structure of sorts, but if it's not evaluated, it's not a value
04:59:46 <mnislaih> aha psnl I will try that
05:00:13 <goltrpoat> evaluating f d i with the above structure, after substitution, is literally, if i == someConst then True else if i == someOther const then True else if i == someOtherConstYet then True else False
05:00:30 <mnislaih> psnl: I was using ghc 6.6 binaries from the official ghc homepage, which is not the same as the macports one
05:00:55 <psnl> mnislaih: know what the difference is?
05:01:10 <psnl> mnislaih: I know how to fix the problem, but not what is causing it.
05:01:22 <mnislaih> psnl: no idea, I guess the build.mk settings
05:01:36 <mnislaih> how do you fix it?
05:01:54 <psnl> port install ghc; rebuild gtk2hs.
05:02:25 <mnislaih> I would be interested in knowing the why... I always work with homebuilt ghc 6.7
05:02:48 <psnl> mnislaih: so would I, but I don't have the free time to poke around that much.
05:02:56 <ski> update :: Eq a => (a -> Bool) -> a -> (a -> Bool)
05:02:57 <ski> update f el el' = el == el' || f el'
05:03:07 <ski> if you remove the 'D's ..
05:03:32 <ski> (goltrpoat : .. but maybe there were more fields in there ?)
05:05:59 <goltrpoat> ski:  sure, just not related to that structure
05:06:44 <mnislaih> psnl: do you happen to build your ghc with SplitObjs=NO ?
05:06:45 <goltrpoat> i mean, D as defined is a pretty ephemeral thing, it holds a thunk, and isn't forced until it's evaluated in a strict context, right
05:08:01 <psnl> mnislaih: I have no idea. sorry.
05:08:05 <goltrpoat> or am i missing something
05:08:19 <nornagon> :t (**)
05:08:20 <nornagon> er.
05:08:21 <lambdabot> forall a. (Floating a) => a -> a -> a
05:08:22 <nornagon> :t (***)
05:08:24 <Igloo> psnl, mnislaih: What's the problem? (can't see it obviously in scrollback)
05:08:24 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
05:08:37 <nornagon> @index (***)
05:08:37 <lambdabot> Control.Arrow
05:09:01 <mnislaih> haskell binaries linked to gtk2hs die with "bus error" in Mac Os Intel
05:09:33 <psnl> Igloo: gtk2hs built with a build of ghc from haskell.org has a null pointer ref somewhere. building with the version in macports works.
05:09:55 <nornagon> @src (***)
05:09:56 <lambdabot> f *** g = first f >>> second g
05:10:03 <nornagon> @src (>>>)
05:10:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:10:04 <psnl> Igloo: I have no real idea, and can't face debugging ghc
05:10:40 <Igloo> Euch, OK, thanks
05:11:29 <nornagon> if i have some function f, is there a function in the standard libs from f and (a,b) to (f a, f b)?
05:11:46 <psnl> dcoutts: is the correct way to do a tag specific popup menu on click to wait for a mark-set signal and then check what tag its in?
05:12:54 <nornagon> @hoogle (a -> b) -> (a,a) -> (b,b)
05:12:55 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
05:13:00 <nornagon> O_o
05:13:23 <nornagon> @hoogle (Monad m) => m a b -> (a,a) -> (b,b)
05:13:24 <lambdabot> No matches, try a more general search
05:14:08 <quicksilver> nornagon: yes
05:14:15 <quicksilver> nornagon: f *** f
05:14:33 <nornagon> okay.
05:14:35 <nornagon> thanks.
05:14:47 <quicksilver> or if you want to be gratuitously cute, join (***) f
05:15:06 <quicksilver> > let f = (+1) in f *** f $ (4,5)
05:15:08 <lambdabot>  (5,6)
05:15:57 <quicksilver> nornagon: the reason that hoogle can't find it is that it's a more general function, since it operates on arrows not functions
05:16:06 <goltrpoat> bedtime
05:17:18 <narain> > let f = (+1) in f *** id $ (1,2)
05:17:20 <lambdabot>  (2,2)
05:17:34 <narain> cool, i've been looking for something like this too
05:17:42 <narain> thanks quicksilver
05:17:56 <quicksilver> there is also &&&
05:18:04 <narain> :t &&&
05:18:06 <lambdabot> parse error on input `&&&'
05:18:16 <quicksilver> > let f = (+1); g = (*2) in f &&& g $ 6
05:18:17 <lambdabot>  (7,12)
05:18:25 <kolmodin> :t (&&&)
05:18:27 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:18:32 <narain> oh right
05:18:38 <kolmodin> :)
05:18:55 <quicksilver> arrow types are not enlightening until you've rotated your brain through the necessary 720 degrees
05:19:55 <narain> i'm just interpreting this using the concrete instance Arrow (,)
05:20:04 <opqdonut> quicksilver: i2pi degrees, rather
05:20:20 <narain> quicksilver: i didn't know brains had spin < 1/2
05:21:11 <narain> > fix id
05:21:12 <lambdabot>  Exception: <<loop>>
05:21:27 <narain> > fix (\x -> if x then True else True)
05:21:28 <lambdabot>  Exception: <<loop>>
05:21:55 <narain> ah, i believe i now understand how fix works
05:22:02 <mux> lucky you
05:22:15 <mux> I should get back to fix and mfix study some day
05:22:20 <mux> but I know groked GADTs
05:22:25 <mux> s/know/now/
05:22:57 <narain> mux: Cale told me to work through some examples
05:22:59 <narain> it helped
05:23:00 <quicksilver> narain: itym Arrow (->)
05:23:06 <quicksilver> narain: surely (,) isn't an arrow?
05:23:25 <narain> quicksilver: ah right
05:23:44 <narain> this is my first encounter with Arrows
05:23:56 <narain> misread the type of (***)
05:23:57 <MarcWebe1> Is there already a function mapping an either value to monad (Left -> fail Right v to m v ?)
05:25:03 <quicksilver> MarcWebe1: no, I don't think so. (either fail return)
05:25:09 <quicksilver> :t either fail return
05:25:11 <lambdabot> forall (m :: * -> *) b. (Monad m) => Either String b -> m b
05:25:15 <dcoutts> psnl, so there's the onPopulatePopup but it's not immediately clear to me how to find out the point in the buffer where the user right-clicked
05:25:48 <MarcWebe1> ah. sure. Thanks
05:26:22 <dcoutts> psnl, since it's not necessarily caused by right clicking, one can also get a popup by pressing the right key
05:26:48 <narain> :t either (const $ fail "error") return
05:26:48 <psnl> dcoutts: dang
05:26:50 <lambdabot> forall b (m :: * -> *) b1. (Monad m) => Either b b1 -> m b1
05:27:29 <quicksilver> narain: why throw away the error info you have?
05:28:07 <ski> :t either (const mzerp) return
05:28:09 <lambdabot> Not in scope: `mzerp'
05:28:11 <ski> :t either (const mzero) return
05:28:13 <lambdabot> forall (m :: * -> *) a b. (MonadPlus m) => Either a b -> m b
05:28:14 <MarcWebe1> quicksilver: It might be undefined ;))
05:28:25 <narain> quicksilver: i thought you had an either of arbitrary types
05:28:29 <dcoutts> psnl, what I'd do is look at what another gtk app does, for example gedit's spell check suggestion popup menu depend on the location in the buffer.
05:28:47 <quicksilver> narain: ah, fair enough
05:28:56 <quicksilver> how about fail.show then :)
05:29:01 <quicksilver> :t either (fail.show) return
05:29:02 <dcoutts> psnl, and from a quick check, it seems to deal correctly with right clicks vs pressing the popup keyboard accel
05:29:03 <narain> quicksilver: didn't think of the standard use of either as an error type
05:29:04 <lambdabot> forall (m :: * -> *) a b. (Show a, Monad m) => Either a b -> m b
05:29:16 <narain> quicksilver: though that probably makes more sense in this context
05:29:22 <psnl> dcoutts: I keep meaning to ask you this: Is gtk2hs complete wrt to gtk? is there any functionality missing?
05:30:28 <dcoutts> psnl, there's a little but it's mostly semi-internal things we don't bind. There is some missing stuff though, yes, eg drag&drop. It's still on the TODO, but obviously our priorities depend on what people find they need.
05:31:03 <psnl> yeah
05:31:06 <psnl> thanks
05:31:11 <dcoutts> psnl, what I mean about gedit doing it right is: on a mouse click it uses the location where you click, and for the keyboard it uses the location of the cursor.
05:31:42 <dcoutts> so it'd be interesting to find how they do that, I presume it's not a nasty hack :-)
05:32:08 <psnl> I'm off to poke though the source
05:32:45 <narain> can someone please tell me if i'm wrong:  fix  works by partially figuring out the value of  f x  without any knowledge of  x  and working forwards from there, right?
05:33:03 <dcoutts> psnl, ok, look at the gedit spell check plugin
05:33:24 <ski> narain : yes, that's one way to put it
05:33:28 <quicksilver> narain: fix works by tying a loop into the internal representation of the expression
05:33:37 <quicksilver> narain: and hoping that this doesn't make the computation loop
05:33:40 <quicksilver> (forever)
05:33:49 <ski> > take 10 (fix (1:))
05:33:51 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
05:34:17 <ski> > take 10 (fix (\xs -> case xs of [] -> 1:xs; _:_ -> 1:xs))
05:34:18 <lambdabot>  Exception: <<loop>>
05:34:28 <narain> i'm not quite sure what tying a loop means
05:34:31 <quicksilver> imagine (1:) inside some haskell machine.
05:34:44 <quicksilver> it's a function waiting for an argument
05:35:00 <quicksilver> so inside your machine you have "My_Expr : '(1:)'"
05:35:08 <quicksilver> in some memory cell, or whatever
05:35:10 <narain> oh yeah i remember seeing a knotty diagram involving (1:) somewhere
05:35:19 <quicksilver> when you 'fix' it, you give it itself as an argument
05:35:41 <narain> that's a better way to think of it, thanks
05:35:47 <ski> you give it the *result* as argument, to get the result
05:35:50 <quicksilver> My_Expr_fixed : '(1:) My_Expr_fixed'
05:36:16 <quicksilver> ski: result of what? it can't compute anything. It's a function waiting for an argument.
05:36:16 <ski> @src fix
05:36:17 <lambdabot> fix f = let x = f x in x
05:36:31 <quicksilver> narain: then you just try to evaluate it as normal
05:36:36 <quicksilver> narain: and hope that it works :)
05:36:47 <narain> i think i get it
05:36:54 <ski> quicksilver : the result of applying that function on the result, of course
05:37:19 <quicksilver> ski: ok, that's just another way of saying the same thing, yes :)
05:37:34 <narain> i was thinking of  fix (1:)  as saying, ok, if  x = 1 : x  but i don't know  x  at all, at least now i know  x = [1, _something_]  which then tells me  x = [1, 1, _something_]  and so on
05:37:35 <ski> (nod)
05:37:52 <ski> narain : yes, and that's not bad either
05:37:53 <quicksilver> narain: that's also a good way to look at it
05:37:55 <narain> but a loopy representation is probably better
05:38:14 <ski> if you think of '_|_' as meaning "not (*yet*) known"
05:38:14 <quicksilver> the loopy one explains how efficient it is in memory, though
05:38:18 <ski> then you first know
05:38:21 <ski> x = _|_
05:38:36 <ski> then, using the definition 'x = 1 : x' you get
05:38:39 <ski> x = 1 : _|_
05:38:41 <ski> and then
05:38:45 <ski> x = 1 : 1 : _|_
05:38:46 <ski> etc
05:39:07 <Igloo> It's not actually _|_ at all, though
05:39:11 <quicksilver> that's a particular reduction strategy though. One which mirrors the least fixed point semantics
05:39:19 <ski> the usual interpretation of '_|_' though is "eternally '_|_'"
05:39:26 <quicksilver> in fact, the 'loop in the graph' also models a real reduction strategy
05:39:34 <quicksilver> that of a graph-reducing machine
05:39:39 * ski nods
05:39:40 <narain> it helped me understand why, for example,  fix (drop 42)  is not  []  even thought  drop 42 []  is  []
05:40:15 <narain> ski: thanks, and i know  _|_  is "error" or something like that
05:40:18 <quicksilver> well 'drop 42' is a function, so fix (drop 42) will be a function
05:40:23 <quicksilver> not a single value
05:40:34 <narain> :t drop 42
05:40:36 <lambdabot> forall a. [a] -> [a]
05:40:39 <ski> (narain : rather 'error someThing' is one kind of '_|_' :)
05:40:54 <narain> quicksilver: isn't fix going to take care of that?
05:41:00 <quicksilver> narain: fix doesn't change the type
05:41:01 <ski> :t fix (drop 42)
05:41:03 <lambdabot> forall a. [a]
05:41:07 <quicksilver> erm
05:41:09 <quicksilver> yes it does
05:41:10 <quicksilver> :)
05:41:16 <quicksilver> not thinking clearly there, sorry
05:41:58 <narain> ski: so is _|_ a general "i don't (can't) have a value"?
05:42:18 <quicksilver> it models programs which go wrong
05:42:22 <ski> you could say so
05:42:26 <quicksilver> e.g. run forever without termination
05:42:31 <quicksilver> as well as other ways of going wrong
05:42:49 <ski> i.e. programs which don't return (normally)
05:42:49 <nornagon> @src min
05:42:50 <lambdabot> min x y = if x <= y then x else y
05:43:20 <narain> > fix (\x -> if x then True else True)
05:43:21 <lambdabot>  Exception: <<loop>>
05:43:29 <narain> i know why that doesn't work! yay
05:45:08 <narain> so  fix  as defined can't be implemented is strictly evaluated languages i assume?
05:46:49 <quicksilver> it can
05:46:57 <quicksilver> not all fix'ed things are infinite
05:48:25 <quicksilver> >  (fix (\f n -> case n of 0 -> 1 ; _ -> n * (f n))) 4
05:48:26 <lambdabot>  Exception: stack overflow
05:48:33 <quicksilver> in an eager language, that wouldn't overflow :)
05:48:38 <narain> but i don't see how you can do  x = f x  with strict evaluation
05:48:57 <therp> I presume you meant n * (f (n - 1))?
05:48:58 <narain> i just remembered that there are other fixed point combinators which could be used
05:48:59 <ski> not this general 'fix', no
05:49:04 <quicksilver> therp: oops, yes, thanks
05:49:20 <narain> >  (fix (\f n -> case n of 0 -> 1 ; _ -> n * (f (n-1)))) 4
05:49:21 <lambdabot>  24
05:49:26 <narain> just checking :)
05:49:27 <quicksilver> better :)
05:49:52 <ski> fix :: ((a -> b) -> (a -> b)) -> (a -> b)  -- works in strict, e.g.
05:50:01 <narain> :t fix
05:50:03 <lambdabot> forall a. (a -> a) -> a
05:50:15 <therp> narain: "Lisp in Small Pieces" lists a Y combinator for Lisp (and lisp is certainly strict)
05:50:46 <narain> therp: right, i remembered too late that other combinators exist :)
05:51:20 <narain> but you can't simply do  fix f = let x = f x in x  right?
05:51:28 <quicksilver> sure you can
05:51:39 <quicksilver> in any language which permits recursive definitions
05:51:57 <ski> fix f = let g x = f g x in g
05:52:01 <quicksilver> although some ML dialects require an explicity 'letrec' for that kind of thing
05:52:21 <ski> which is same as
05:52:30 <ski> fix f = let g = \x -> f g x in g
05:52:45 <ski> so, difference is that 'f g' was eta-expanded
05:52:55 <narain> ski: ah, that one makes sense
05:53:19 <ski> you can also do similar things with (lazy) records of mutually recursive functions
05:53:22 <narain> i've seen recursively defined functions but not recursively defined *values* in ML
05:53:33 <narain> (wait, functions are values too)
05:53:41 <narain> um.
05:54:09 <ski> fun fix f = let fun g x = f g x in g end
05:54:19 <narain> do i mean non-lambda expressions?
05:54:20 <ski> fun fix f = let rec g = fn x => f g x in g end
05:54:36 <narain> ski: i understand that example
05:54:39 <ski> er, s/rec/rec val/
05:54:49 <quicksilver> narain: ML has a value restriction which stops some of these tricks
05:54:58 <quicksilver> but it's a silly syntactic/type inference limitation
05:55:06 <quicksilver> and you can lambda your way out of it
05:55:16 <ski> only with functions
05:55:37 <ski> and it exists because of side-effects otherwise screwing up type-safety
05:55:53 <narain> and this has nothing to do with eager evaluation? hmm.
05:55:58 <ski> (there were other solutions, but they were considered too complex)
05:56:11 <narain> ok, i feel out of my depth now
05:56:28 <quicksilver> narain: no, it doesn't really have to do with eager evaluation
05:57:01 <quicksilver> narain: certainly, withlazy evluation, you can use fix to produce 'infinite' values, but the finite stuff works fine with eager
05:58:57 <narain> dang, and here i was thinking i knew ML pretty well :)
05:59:07 <narain> thanks quicksilver and ski
06:00:36 <quicksilver> one way of thinking of fix is that it 'internalises' recursive definitions into your language
06:00:57 <quicksilver> with fix, you no longer need explicit recursion; all recrusion is just a use of fix
06:01:11 <quicksilver> (conversely, with recursion fix itself is trivial to write)
06:01:47 <opqdonut> egg and chicken
06:04:24 <pejo> quicksilver, uh, "lambda your way out of it" sounds like you're fooling the static checks.
06:05:17 <narain> the wikipedia article on fixed point combinators has an amusing example at the end
06:05:58 <narain> "Yk = (L L L L L L L L L L L L L L L L L L L L L L L L L L) where L = abcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))"
06:06:11 <opqdonut> :DD
06:07:01 <quicksilver> pejo: well, I mean tricks like using a function which ignores its argument instead of a bare value
06:07:24 <quicksilver> pejo: tis' annoying but doesn't harm expressivity, I don't believe
06:08:53 <emk> Monad math question: Given two monad transformers FooT and BarT, where FooT (BarT m) and BarT (FooT m) are equivalent, is there a more accurate name for this property than "commutative"?
06:09:33 <pejo> quicksilver, (You must mean instead of a term/expression for the first one there). Well, since lambda abstractions are values, you're simply obeying the rules.
06:09:34 <quicksilver> commutative is the right name, but you have to be clear about which part you think is commutative
06:09:44 <quicksilver> pejo: right :)
06:10:12 <quicksilver> emk: the trasnformers commuting doesn't mean that the monads are commutative (I don't think). At least, that isn't obvious.
06:10:55 <emk> quicksilver: You're right that there's no (simple) link between the two kinds of commutativity.
06:11:21 <emk> quicksilver: Thanks for the terminology help!
06:11:33 * emk is sorely lacking in proper math education
06:11:41 <quicksilver> emk: I'd say "the two transformers commute"
06:11:47 <quicksilver> (or not, if they don't)
06:13:39 <kuribas> haskell is the most popular ML dialect, right?
06:14:00 <kuribas> (If it can be called a ML dialect)
06:14:00 <Syzygy-> ...
06:14:07 <quicksilver> it's certainly not an ML dialect
06:14:08 <Syzygy-> I wouldn't call it a ML dialect.
06:14:08 <Vq^> kuribas: haskell isn't ML
06:14:24 <narain> ocaml is probably the most popular ML dialect
06:14:31 <kuribas> uhm, the most popular functional language with static typing then?
06:14:33 <quicksilver> It's very hard to get a clear view of overall popularity
06:14:43 <quicksilver> I wouldn't be surprised if you told me ocaml was more popular
06:14:55 <quicksilver> certainly ocaml has a lot of traction in academia
06:15:05 <quicksilver> haskell is gaining more traction in 'the real world'
06:15:12 <quicksilver> but that's just guesswork and anecdote :)
06:15:31 <narain> i got the feeling ocaml is used somewhat outside academia
06:15:40 <narain> but yes, i could be very wrong
06:16:12 <edwinb> hi quicksilver. I see I have mail...
06:16:24 <quicksilver> edwinb: indeed. Good detective work, etc.
06:16:49 <edwinb> quicksilver: not really, you told me who you were last week when you asked me to say hello to Richard Bornat ;)
06:17:17 <quicksilver> :)
06:17:24 <edwinb> I'll reply properly later, but in the meantime have you seen  Gregoire and Leroy's Compiled Strong Reduction paper?
06:17:31 <quicksilver> damn, I give away my secret identity so easily
06:17:35 <quicksilver> I'd be a loiusy superhero
06:17:38 <edwinb> heh
06:17:51 <quicksilver> edwinb: no. I'll go get it
06:18:11 <edwinb> if you're worried about compile-time vs run-time, it might be interesting.
06:18:42 <edwinb> it's about (bad executive summary) compiling Coq terms to bytecode for fast conversion checking
06:19:06 * quicksilver nods
06:19:09 <quicksilver> interesting
06:19:20 <edwinb> anyway, must go again!
06:19:23 * quicksilver waves
06:29:28 <chessguy> 'morning haskellites
06:29:48 <opqdonut> morn
06:30:00 <opqdonut> (1630 here, tho)
06:30:12 <opqdonut> how's it coming along, chessguy
06:30:50 <chessguy> opqdonut! it's coming. i separated the client and library code for my GP stuff this weekend, which is an important step
06:31:13 <opqdonut> nice
06:31:30 <opqdonut> i haven't really done anything worth mentioning, mostly studies...
06:31:58 <chessguy> with a few more weeks of work, i hope this could actually be a useful library
06:32:56 <chessguy> i have some questions about the haskell module importing strategies
06:33:22 <chessguy> if i import a module, does that module have to be able to compile independently of where it's being imported from?
06:34:59 <allbery_b> ?
06:35:12 <chessguy> ermm, ok
06:35:14 <quicksilver> chessguy: you can't do recursive module dependencies
06:35:18 <quicksilver> chessguy: if that's what you're asking
06:35:24 <chessguy> no, it's not
06:35:46 <chessguy> suppose i do import Foo    data Bar = Bar ...
06:35:48 <quicksilver> it what other way could it fail to compile independently, if not a dependency?
06:35:55 <Zeroth|work> whats the diff between -> and => ?
06:35:56 <chessguy> can i refer to Bar in Foo?
06:36:02 <Zeroth|work> or <- and <=
06:36:07 <quicksilver> chessguy: no
06:36:17 <chessguy> ok
06:36:26 <Saizan> no, Foo should import your current module, and that's recursive
06:36:26 <chessguy> so it does have to compile independently
06:36:38 <chessguy> yeah i guess it is
06:36:39 <quicksilver> yes
06:36:43 <quicksilver> hence my comment:
06:36:47 <quicksilver> chessguy: you can't do recursive module dependencies
06:36:48 <quicksilver> :)
06:37:15 <chessguy> ugh. what's the usual way to fix that?
06:37:16 <Saizan> there's a "hack" in ghc to do so i think
06:37:30 <quicksilver> chessguy: don't do that?
06:37:37 <Saizan> put data Bar in a separated module which both your current and Foo imports
06:37:59 <chessguy> ok, that brings me to my second question
06:38:30 <chessguy> if modules Foo and Baz both import a module which contains Bar, is that going to be a problem?
06:38:39 <allbery_b> nope
06:38:56 <allbery_b> there's a .hs-bot hack that can also be used to get around recursive module dependencies
06:39:02 <allbery_b> er, .hs-boot
06:39:12 <quicksilver> however, you should ask yourself: in what sense are they modules if each depends on the other
06:39:15 <allbery_b> but if possible you should refactor the modules instead
06:39:21 <chessguy> well, i'd like to stay away from hacks, because more than likely i don't need them
06:39:25 <quicksilver> right
06:39:34 <quicksilver> a common Baz is a good solution in some cases, definitely
06:39:50 <quicksilver> another approach is that Bar becomes a typeclass *defined in Foo*
06:40:07 <chessguy> so i don't need to do anything like C++'s #ifndef foolishness
06:40:14 <allbery_b> Zeroth|work: -> is function application; => applies a typeclass constraint
06:40:40 <allbery_b> Show a => a -- says that a can b any type with a Show instance
06:40:44 <chessguy> a typeclass? Bar is a data constructor
06:41:10 <quicksilver> but make it a typeclass, definied in Foo
06:41:17 <quicksilver> and then Bar becomes and instance of it
06:41:31 <quicksilver> so you 'abstract' Bar into "what Foo really needs to know about Bar"
06:41:36 <quicksilver> which becomes the basis of the typeclass
06:41:59 <chessguy> hmm, ok
06:42:09 <quicksilver> a common module Baz is a good solution too :)
06:42:13 <quicksilver> it does depend on the case
06:42:15 <Magical1> Can the school of expression libs be run under the most recent version of hugs or does it have to be the November 2003 version?
06:42:33 <allbery_b> a -> b -- says expect an a and produce a b -- note that a -> b -> c is really a -> (b -> c), i.e. expect a, produce a function from b to c (currying)
06:42:55 <quicksilver> I feel like allbery_b is talking to someone I can't see
06:42:55 <quicksilver> odd
06:43:16 <allbery_b> Zeroth|work asked a question earlier; I'm answering it
06:43:42 <allbery_b> <Zeroth|work> whats the diff between -> and => ?
06:43:44 <quicksilver> oh yes, I see it now :)
06:44:21 <allbery_b> pity IRC doesn't have instances to separate conversations :)
06:45:08 <Saizan> it's also an advantage, everyone can contribute
06:45:18 <allbery_b> instances are just tags
06:45:22 <allbery_b> not filters
06:45:51 <allbery_b> imagine if each line of IRC output were e.g. <allbery_b> (-> vs =>) ...
06:46:01 <quicksilver> yes, for as long as I've used chat protocols of any type I've wondered about tagging/topic support
06:46:05 <allbery_b> <chessguy> (module deps) ...
06:46:09 <Saizan> allbery_b: like this?
06:46:12 <Saizan> :D
06:46:12 <quicksilver> would need a good UI to be helpful though
06:46:23 <Saizan> yes i see your point, however
06:46:24 <quicksilver> <IRC tagging> Saizan: no, like this
06:46:35 <chessguy> allbery_b, huh?
06:46:40 <allbery_b> zephyr is in many ways a sucky obsolete system, but it has instance tagging that's nicely integrated
06:46:46 <chessguy> oh
06:46:57 <matthew_-> <IRC tagging> mmm, the client would need to be quite clever
06:46:58 <emu> amazingly, people are still using zephyr
06:47:06 <opqdonut> zephyr?
06:47:24 <quicksilver> <IRC tagging> matthew_-: just colouring would be a useful hint. It could randomly assign a new colour to a previously unseen tag
06:47:49 <quicksilver> <IRC tagging> matthew_-: and allow you to flick between threads (for your next comment) with a single keypress, perhaps <- and ->
06:48:03 <allbery_b> zephyr is an IM system which uses kerberos and tags conversations with (class,instance,recipient)
06:48:12 <allbery_b> recipient is * for chatroom-like things
06:48:16 <opqdonut> ah ok
06:48:22 <opqdonut> nice
06:48:33 <emu> its really old, and stuff
06:48:41 <allbery_b> class can also be used to select separate chatrooms, or can indicate priorities; it's also used internally for control messages.
06:48:44 <quicksilver> in IRC, recipient is '#haskell' for chatroom-like-things I believe
06:48:52 <allbery_b> yes
06:48:54 <quicksilver> well recipient would be 'quicksilver' for a PM
06:49:00 <quicksilver> s/we/whi/
06:49:11 <allbery_b> yeh, IRC combines class and recipient but has no way to do instance
06:50:45 <Saizan> the tags are human created right?
06:50:51 <matthew_-> <IRC tagging> quicksilver: Mmm. It should also separate out different threads into different columns. Or something similar.
06:51:04 <Saizan> err, instances
06:51:13 <quicksilver> matthew_-: well, optionally, yes
06:51:19 <quicksilver> matthew_-: some people might not prefer that, though
06:51:32 <quicksilver> you might want to move some threads into other tabs
06:51:36 <quicksilver> or hide them completely
06:51:41 <allbery_b> Saizan: yes, so there's an expectation that people pprovide meaningful tags.  although tags can be empty
06:52:18 <matthew_-> <IRC tagging> if the tag is empty then the contents of the thread must also be empty
06:52:27 <matthew_-> <> null
06:52:45 <chessguy> <IRC tagging> any user dependencies are generally pretty ricky
06:52:56 <chessguy> s/y r/y tr/
06:53:48 <opqdonut> it's tricky to rock a rhyme to rock a rhyme that's right on time ...
06:54:17 <chessguy> thank you for those words of wisdom, opqdonut
06:54:48 <Saizan> stealing a few chars from the body of the message we could specify a TAG/IRC protocol
06:55:08 <opqdonut> :)
06:55:39 <opqdonut> a tag system might become too restrictive
06:55:53 <opqdonut> i'm all for showing all messages and just coloring them or so
06:56:00 <opqdonut> so everybody can contribute
06:56:03 <matthew_-> we could just use additional channels
06:56:13 <opqdonut> with tags and hiding people would miss interesting stuff
06:56:14 <matthew_-> eg #haskell-IRC_tagging
06:56:47 <Saizan> to colour them you need some information of which messages have to go together
06:56:57 <matthew_-> it would be the pinnicle of l33tness that in order to talk on #haskell you had to use a dedicated haskell IRC client...
06:57:19 <Zeroth|work> > :t map
06:57:19 <lambdabot>  Parse error
06:57:37 <opqdonut> :t map
06:57:40 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:57:56 <opqdonut> ^_^
06:58:05 <Zeroth|work> getting confused about types again
06:58:19 <Saizan> fell frre to ask
06:58:23 <Saizan> *feel
06:58:41 <Zeroth|work> I'm trying to figure out how to word my question
06:59:03 <Zeroth|work> given: (a -> b) -> [a] -> [b]
06:59:33 <Zeroth|work> does the (a -> b) mean that the function converts a to b ?
06:59:41 <matthew_-> yep
06:59:58 <matthew_-> :t (== 0)
07:00:01 <lambdabot> forall a. (Num a) => a -> Bool
07:00:11 <chessguy> Zeroth|work, the first parameter is a function that converts from any a to any b, yes
07:00:15 <Saizan> zeroth: you know that you can pass functions as parameters to other functions right?
07:00:34 <Zeroth|work> and the [a] -> [b] means that the function takes two lists of two different types?
07:00:42 <Saizan> no
07:01:11 <allbery_b> map takes a function from a to be and produces a function from [a] to [b]
07:01:15 <matthew_-> > map (== 0) [1,0,3,4,3,29,0,1]
07:01:16 <allbery_b> is one way to read it
07:01:18 <lambdabot>  [False,True,False,False,False,False,True,False]
07:01:54 <allbery_b> (a -> b) -> [a] -> [b])  ==>  (a -> b) -> ([a] -> [b])  -- because -> is right-associative
07:02:03 <Saizan> if you have map :: (a -> b) -> [a] -> [b] means that map takes a function "f" from a to b and a  "list of a" and returns a "list of b"
07:02:17 <allbery_b> :t map (== 0)
07:02:20 <lambdabot> forall a. (Num a) => [a] -> [Bool]
07:02:55 <allbery_b> :t map (== (0 :: Int))
07:02:58 <lambdabot> [Int] -> [Bool]
07:03:00 <Zeroth|work> hmm
07:04:17 <chessguy> in any type signature, everything before the last -> is the input parameters, whatever's after the last -> is the type of the result
07:05:44 <Zeroth|work> alright, so how does (a -> b) mean "take a function" ?
07:05:57 <Saizan> yes
07:05:57 <quicksilver> Zeroth|work: because it was at the beginning of the type
07:05:59 <chessguy> (a -> b) is a function
07:06:12 <quicksilver> Zeroth|work: the full type was (a->b) -> [a] -> [b]
07:06:13 <chessguy> from something of type a to something of t ype b
07:06:17 <earthy> *ouch*!
07:06:31 <quicksilver> which means 'give me a function of type (a->b), and a list of as, and I'll give you a list of bs
07:06:38 <earthy> that's nasty: ^M's in file names
07:06:40 <Zeroth|work> ah
07:07:14 <Zeroth|work> so, anything in parenthesis means it takes a function?
07:07:20 <quicksilver> no
07:07:26 <allbery_b> as a quick apprximation, yes
07:07:28 <quicksilver> it's the -> that means that is a function :)
07:07:32 <chessguy> anything in a set of parentheses is a single type
07:07:33 <allbery_b> but it's more complex than that.
07:07:37 <quicksilver> the parentheses are just there to group stuff
07:07:55 <quicksilver> (somethinig long and complicated) -> (something slightly simpler) -> c
07:08:07 <fantasma> > let P n = sum $ map (\k -> ((-1)^(k+1))*(P(n-1/2*k*(3*k-1)) + P(n-1/2*k*(3*k+1)))) [1..n] in P 5
07:08:08 <lambdabot>   Not in scope: data constructor `P'
07:08:19 <Zeroth|work> makes more sense
07:08:48 <Zeroth|work> but the function 'prototype' cant work without the parenthesis there, right?
07:08:50 <chessguy> fantasma, function names must start with a lowercase letter
07:08:56 <allbery_b> right
07:08:59 <fantasma> chessguy: ah yes, forgot
07:09:08 <Zeroth|work> a -> b -> [a] -> [b]  is not  (a -> b) -> [a] -> [b]
07:09:14 <matthew_-> -> is a binary relation. But people drop the brackets by convention. Eg + on Ints would be Int -> Int -> Int, but with the brackets in, it's actually (Int -> (Int -> Int)). So when you want to state you're receiving a function rather that returning one, the brackets have to explicitly say that.
07:09:18 <quicksilver> true
07:09:28 <fantasma> > let p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-1/2*k*(3*k-1)) + p(n-1/2*k*(3*k+1)))) [1..n] in p 5
07:09:29 <lambdabot>  Add a type signature
07:09:59 <chessguy> Zeroth|work, a -> b -> [a] -> [b] takes 3 input parameters, and returns 1.  (a -> b) -> [a] -> [b] takes 2 parameters and returns 1
07:10:01 <allbery_b> -> is right associative  so without parents it would be:  (a -> (b -> ([a] -> [b])))
07:10:23 <allbery_b> which is how currying works in Haskell
07:10:34 <Zeroth|work> it all makse sense now
07:10:39 <fantasma> is it feasible to use recursion inside the first map parameter
07:10:41 <allbery_b> so to make the first argument be a function you must add parentheses
07:11:05 <Zeroth|work> I doubt anyone can read YAHT without asking about things
07:11:10 <allbery_b> ((a -> b) -> ([a] -> [b]))
07:11:18 <quicksilver> fantasma: sure, with a 'let'
07:11:21 <Zeroth|work> unless I'm just missing things
07:11:30 <quicksilver> fantasma: map (let p = .... in p) [1..n]
07:11:33 <fantasma> > let p n = map (\k -> ((-1)^(k+1))*(p(n-1/2*k*(3*k-1)) + p(n-1/2*k*(3*k+1)))) [1..n] in p 5
07:11:34 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
07:11:34 <lambdabot>       Expected...
07:11:59 <quicksilver> fantasma: ah that's not what you meant.
07:12:13 <quicksilver> fantasma: yes, you can do that too
07:12:17 <earthy> cool! that's an interesting bug in cabal!
07:12:26 <earthy> cabal does not ignore line endings
07:12:30 <fantasma> quicksilver: apparantly not :(
07:12:39 <earthy> so, if I hava a Cabal file with dos line endings on a unix platform
07:12:47 <quicksilver> fantasma: well what you wrote was wrong, but there is nothing wrong with the idea
07:12:53 <earthy> my project executable will be called   Executable<Ctrl-M>
07:13:04 <quicksilver> fantasma: you can refer to a definition recursively from inside itself
07:13:08 <allbery_b> ow
07:13:20 <fantasma> quicksilver: do you know what's wrong with the code itself
07:15:04 <chessguy> fantasma, the parentheses don't balance
07:15:15 <chessguy> (i don't think)
07:15:49 <quicksilver> they do
07:15:51 <chessguy> err, maybe they do
07:15:53 <quicksilver> fantasma: p returns a list
07:15:57 <chessguy> sorry, i can't count
07:15:57 <quicksilver> fantasma: (map returns a list)
07:16:07 <quicksilver> fantasma: but p is being used inside the map as if it returns a number
07:16:25 <fantasma> quicksilver: ahhhh makes sense
07:17:01 <fantasma> > let p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-1/2*k*(3*k-1)) + p(n-1/2*k*(3*k+1)))) [1..n] in p 5
07:17:02 <lambdabot>  Add a type signature
07:17:30 <Zeroth|work> given: count2 p l = foldr (\x c -> if p x then c+1 else c) 0 l
07:17:31 <quicksilver> > let p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-1/2*k*(3*k-1)) + p(n-1/2*k*(3*k+1)))) [1..n] in p 5 :: Int
07:17:32 <lambdabot>  Add a type signature
07:17:38 <Zeroth|work> whats the backslash for?
07:17:50 <allbery_b> lame ASCII version of "lambda"
07:17:55 <Zeroth|work> ah
07:18:04 <allbery_b> 
07:18:08 <Zeroth|work> so why isn't it required for c as well?
07:18:19 <chessguy> > (\x -> x*x) 2
07:18:20 * Zeroth|work sees a big square dot
07:18:20 <lambdabot>  4
07:18:21 <mux> 
07:18:27 <mux> heh
07:18:35 <allbery_b> \x c -> is syntactic sugar for \x -> \c ->
07:18:44 <Zeroth|work> aha
07:18:45 <chessguy> > map (\x -> x*x) [1..10]
07:18:46 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
07:19:03 <quicksilver> fantasma: what you have written is OK
07:19:04 <chessguy> > map (\x -> sqrt x) [1..10]
07:19:05 <lambdabot>  [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.4494897427...
07:19:08 <Zeroth|work> I dont recall yaht ever saying \ means 'lambda'
07:19:09 <quicksilver> fantasma: it just needs a type signature
07:19:33 <fantasma> let p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-1/2*k*(3*k-1)) + p(n-1/2*k*(3*k+1)))) [1..n] in p 5 :: Integer
07:19:41 <allbery_b> no, I think it saves that for later, "lambda abstraction" is a big scaryy term
07:19:42 <chessguy> Zeroth|work, why do you keep whining about YAHT? it is what it is. it's no longer in active development, and nobody can change it. if you don't like it, don't use it
07:19:46 <fantasma> > let p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-1/2*k*(3*k-1)) + p(n-1/2*k*(3*k+1)))) [1..n] in p 5 :: Integer
07:19:46 <lambdabot>  Add a type signature
07:20:12 <maskd> Zeroth|work: try page 42
07:20:20 <Zeroth|work> chessguy, I was told that it IS under active development, and I was ALSO told to take notes on ways for people to fix it. thats not whining.
07:20:31 <chessguy> eh? that's news to me
07:20:34 <quicksilver> fantasma: actually the problem is a bit more subtle
07:20:47 <chessguy> someone's working on YAHT?
07:20:49 <quicksilver> fantasma: 1..n says that k is an integer
07:21:04 <quicksilver> fantasma: (and n)
07:21:20 <Zeroth|work> chessguy, wikibooks
07:21:31 <quicksilver> but then check the type of ^
07:21:31 <chessguy> ?where wikibook
07:21:32 <lambdabot> http://en.wikibooks.org/wiki/Haskell
07:21:33 <fantasma> k should definitely be an integer, not quite sure about n
07:21:33 <quicksilver> :t (^)
07:21:36 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:21:50 <quicksilver> ah, no it's the use of /
07:21:56 <quicksilver> the use of / gives you a fraction in the mix
07:22:01 <Saizan> fantasma: you should use div for integer division or fromIntegral and / and round
07:23:27 <quicksilver> Saizan: I think he wants floating point throughout
07:23:48 <fantasma> > let p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k `div` 2)*(3*k-1)) + p(n-(k `div` 2)*(3*k+1)))) [1..n] in p 5
07:23:51 <lambdabot>  Exception: stack overflow
07:23:54 <chessguy> Zeroth|work, i really don't think anyone's working on YAHT. wikibooks imported the whole thing for their book, but haven't changed the materials AFAIK
07:25:03 <Saizan> > let p n = foldl' (+) 0 $ map (\k -> ((-1)^(k+1))*(p(n-(k `div` 2)*(3*k-1)) + p(n-(k `div` 2)*(3*k+1)))) [1..n] in p 5
07:25:06 <lambdabot>  Exception: stack overflow
07:25:11 <fantasma> this is what I'm trying to make by the way: http://mathworld.wolfram.com/images/equations/PartitionFunctionP/equation3.gif
07:25:13 <lambdabot> http://tinyurl.com/2bn58n
07:26:34 <Zeroth|work> :t map
07:26:37 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:26:52 <chessguy> fantasma, is that the number of partitions of a set of size n?
07:27:07 <fantasma> chessguy: number of partitions for integer n
07:27:32 <chessguy> so....why are you passing it a list?
07:27:38 * fantasma has to go to class and will be back in 45 minutes
07:28:15 <fantasma> chessguy: I was trying to do sumation with a list
07:28:42 <chessguy> ?type for
07:28:44 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
07:28:53 <chessguy> yikes
07:29:22 <chessguy> i'll just use flip map
07:29:24 <chessguy> :)
07:32:32 <shapr> Good morning #haskell!
07:33:44 <shapr> It's a beautiful day out there, how's everyone doing?
07:33:58 <Zeroth|work> my computer screen is more beautiful
07:34:26 <shapr> Well, I can understand that. But you could always take your computer outside and have the best of both worlds!
07:34:42 <Zeroth|work> not at work I can't :-)
07:34:54 <Saizan> freeing some hxt code from the IO monad
07:35:42 <Zeroth|work> > data secks a b c -> secks a b c
07:35:42 <lambdabot>  Parse error
07:36:14 <Saizan> you can't do data definitions in lambdabot or in any interprer's command line
07:36:17 <chessguy> @get-shapr
07:36:18 <lambdabot> shapr!!
07:39:46 <shapr> chessguy: hiya!
07:40:14 <chessguy> hey hey!
07:40:21 <chessguy> did i tell you i landed me an interview?
07:41:03 <solcom> if i am trying to define my own version of Show, why would it say show imported from prelude?
07:41:18 <chessguy> what are you defining it for?
07:41:41 <solcom> to print to the console, but printing datatypes
07:41:55 <solcom> in a different represenations
07:41:59 <solcom> *representation
07:42:13 <quicksilver> solcom: call it something else
07:42:22 <quicksilver> solcom: show is special and it's a pain to hide it
07:42:37 <quicksilver> solcom: call yours 'prettyprint' or 'solcomprint' or 'externalrep'
07:42:53 <chessguy> solcom?
07:43:47 <solcom> hmm u mean in the instance name, or defining instances?
07:43:56 <quicksilver> I mean, choose a new class name
07:44:00 <quicksilver> and choose a different method name
07:44:17 <quicksilver> there is no value, and considerable pain, in overriding show, IMO
07:44:21 <chessguy> probably don't even need a class
07:44:26 <ndm> colwant to paste in what you've got - i'm not entirely sure what you're after
07:44:39 <ndm> @paste -- solcom
07:44:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:44:50 <ndm> (fingers in the wrong place on the keyboard before)
07:45:04 <shapr> chessguy: Whoa cool, when is it?
07:45:16 <quicksilver> Show is very specifically for the purpose of creating debugging output which is valid haskell code and can be read back in. Don't use it for pretty printing of other kinds.
07:45:31 <chessguy> shapr, not scheduled yet
07:45:54 <shapr> quicksilver: Did you see the thread on libraries@h.o about that?
07:45:58 <solcom> ok
07:46:14 <quicksilver> shapr: no. Did lots of very clever people disagree with me and hence make me feel stupid?
07:46:32 <quicksilver> 'cos I hate it when that happens
07:47:33 <ndm> quicksilver: they said it must be read . show = id
07:47:47 <ndm> basically raw haskell for (dead slow!) serialisation
07:47:57 <quicksilver> good. that's part of what I was saying. the other part was more 'don't try this at home, it's not what you want'
07:49:25 <solcom> if i am trying to print something eg a character but with say a word infront of it: eg data type equals 'letter Char' and im trying to print by doing show (Letter Char) = "Actual Letter = " ++ show char
07:50:35 <quicksilver> you want show (Letter a) = "Actual Letter =" ++ (show a)
07:50:53 <quicksilver> but really, you don't want to use show, as I was just saying :)
07:51:04 <solcom> yeah
07:51:11 <solcom> hmm i get an error saying show imported from prelude
07:51:23 <solcom> or ambiguous occurence
07:51:29 <Saizan> solcom: you should make an instance, not just redefine show
07:51:38 <quicksilver> ah yes, I assumed you were :)
07:51:45 <solcom> yeah i got instance Show Letters where ...
07:52:15 <Saizan> can you paste it?
07:53:10 <solcom> yep 1 sec
07:54:33 <solcom> instance Show Letter where
07:54:33 <solcom> show (Letter a) = "Actual Letter = " ++ (show a)
07:55:35 <solcom> first show is imported from prelude and second show says ambiguous occurence
07:56:35 <sjanssen> solcom: you need to indent the second line a bit
07:56:54 <solcom> :-O
07:56:57 <solcom> that worked
07:56:58 <shapr> quicksilver: Nah, lots of clever people agreed with you.
07:57:09 <solcom> ive spent hours trying to work this out
07:57:16 <solcom> cheers :D
07:57:16 <quicksilver> shapr: phew. :)
07:58:38 <sjanssen> solcom: did you already receive the "Show is not for prettyprinting" speech?
07:58:45 <quicksilver> sjanssen: twice :)
07:58:50 <solcom> yeah lol
07:58:53 <sjanssen> @quote stereo
07:58:54 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
07:58:56 <solcom> yeah i think next time ill avoid it
07:59:11 <opqdonut> hmm why is show not for pretty-printing?
07:59:35 <Igloo> Because you should be able to read it back in, or paste it into your hugs prompt
07:59:35 <sjanssen> opqdonut: all of the existing instances just aren't equipped for it
08:00:03 <opqdonut> you have a point there
08:00:19 <Saizan> well if you have one and only way in which you want your datatypes printed i think show is perfectly fine
08:00:38 <psnl> opqdonut: there is a pretty class
08:01:13 <Igloo> There isn't in Haskell 98
08:01:30 <opqdonut> Saizan: yeah that's what i'd think
08:01:43 <psnl> Igloo: is it just a ghc'ism then?
08:01:51 * psnl makes a note
08:02:05 <sjanssen> @hoogle Pretty
08:02:06 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
08:02:06 <lambdabot> Text.Html.prettyHtml' :: HtmlElement -> [String]
08:02:28 <ndm> @hoogle HughesPJ
08:02:29 <lambdabot> Text.PrettyPrint.HughesPJ :: module
08:02:32 <Igloo> No idea
08:02:34 <quicksilver> there's some interesting ideas about how to write a deeper pretty printer class in "Implementing Functional Languages:
08:02:37 <quicksilver> a tutorial "
08:02:45 * ndm hits Hoogle for not returning that result first
08:02:48 <chessguy> quicksilver, link?
08:02:48 <quicksilver> and undoubtedly more along similar lines in other places
08:03:01 <chessguy> ?where ifl
08:03:01 <lambdabot> I know nothing about ifl.
08:03:19 <chessguy> is that based on SPJ's book?
08:03:25 <quicksilver> that is one of SPJ's books, yes
08:03:35 <quicksilver> well SPJ + DR Lester
08:04:01 <quicksilver> the code is gofer not haskell, but it's pretty close
08:07:12 <DynWind> xerox: is haskell.org gonna be a mentor for GSoC this year too?
08:08:08 <xerox> DynWind: a mentoring organization, yes, that's realistically going to happen.
08:08:58 <DynWind> cool. Has a page with project ideas been put up yet?
08:10:01 <sjanssen> @where soc
08:10:01 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
08:10:18 <DynWind> thanks!
08:10:43 <sjanssen> DynWind: the project ideas aren't ready yet though (spammers took over the page since 2006)
08:11:34 <quicksilver> although some of the spammers' ideas are quite fun
08:12:08 <DynWind> hehe
08:12:14 <chessguy> couldn't a simple captcha stop most of those spams?
08:13:25 <quicksilver> captchas are trivially defeatable by cunning mechanical turks
08:13:39 <chessguy> really? how?
08:14:19 <quicksilver> chessguy: relay the captchas to a high traffic porn site that you run
08:14:29 <quicksilver> then all your 'customers' will solve the captchas for you
08:14:33 <quicksilver> so that you can spam more...
08:14:53 <chessguy> yeesh
08:15:10 <allbery_b> yep
08:15:13 <pejo> quicksilver, isn't the code Miranda, and not Gofer?
08:15:26 <matthew_-> you could do some sort of javascript magic which relies on the javascript being unable to load a url which is external to the serving domain
08:15:28 <quicksilver> pejo: it was miranda in the 1991 edition but if I'm not mistaken, later editions are Gofer
08:16:11 <quicksilver> matthew_-: no, you (the spammer) download the image as a file, you stick it on your website, you wait patiently for one of your sweaty customers to solve it, and then you enter the solution on the wiki-post page
08:16:42 <quicksilver> pejo: there are various mutterings in the comments about differences between the preludes
08:16:44 <matthew_-> quicksilver: short timeout on the validity of the captcha?
08:17:03 <allbery_b> there are sites which do that; not sure how well it works in practice
08:17:03 <chessguy> quicksilver, can't captcha images be generated on the fly?
08:17:11 <quicksilver> chessguy: yes, they are generated on the fly
08:17:18 <chessguy> oh, i guess tha doesn't matter
08:17:29 <quicksilver> chessguy: generated on the fly, relayed on the fly to the client website, customers coming in at 10/second see it instantly
08:17:38 <quicksilver> and solve it about as fast as you'de xpect a human being to solve it :)
08:17:43 <chessguy> yeesh
08:18:01 <quicksilver> of course, this is all anecdote
08:18:18 <quicksilver> but terribly plausible anecdote, to my mind.
08:18:27 <fantasma> > let p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k `div` 2)*(3*k-1)) + p(n-(k `div` 2)*(3*k+1)))) [1..n] in p 5
08:18:30 <lambdabot>  Exception: stack overflow
08:18:55 <allbery_b> it's third hand, but spammers have actually admitted to using those techniques, and others
08:18:58 <xerox> quicksilver: let's code it in HAppS
08:19:03 <quicksilver> xerox: :)
08:19:05 <vincenz> xerox: why the @?
08:19:14 <quicksilver> he's got a snail stuck to his head
08:19:19 <quicksilver> it's a bit rude to draw attention to it
08:19:20 <xerox> vincenz: the what?
08:19:25 <allbery_b> you're opped
08:19:25 <vincenz> xerox: the @
08:19:39 <allbery_b> left over from one of our r recent visitors IIRC
08:19:41 <int-e> fantasma: p(n-(k `div` 2)*(3*k-1)) calls p n again for k=1
08:20:14 <fantasma> int-e: I guess I must use normal division with type float
08:20:21 <allbery_b> vincenz: @ prefix = channel operator privs
08:20:29 <int-e> fantasma: I guess you should divide after multiplying.
08:20:35 <matthew_-> you want some information which is invalid as soon as it leaves the connection between the server and the proxy
08:21:02 <fantasma> int-e: what do you mean?
08:21:04 <allbery_b> + prefix = channel voice (useful only when channel is moderated)
08:21:39 <int-e> fantasma: (k `div` 2)*(3*k-1)  divides k by 2 first - truncating odd k results - then multiplies by (3*k-1)
08:21:57 --- mode: xerox set -o xerox
08:22:18 <xerox> Yeah, somebody was try to buy something on the channel.
08:22:33 <fantasma> int-e: http://mathworld.wolfram.com/images/equations/PartitionFunctionP/equation3.gif
08:22:34 <lambdabot> http://tinyurl.com/2bn58n
08:22:50 <int-e> fantasma: if you multiply by (3*k-1) first and then divide by 2 you'll get exact results
08:23:09 <int-e> fantasma: because that product is always even
08:23:38 <fantasma> ((3k-1)k)/2 ?
08:23:42 <int-e> yes.
08:25:43 <fantasma> > let p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k*(3*k-1)/2)) + p(n-(k*(3*k+1))/2))) [1..n] in p 5
08:25:44 <lambdabot>  Add a type signature
08:26:25 <fantasma> > let p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k*(3*k-1)/2)) + p(n-(k*(3*k+1))/2))) [1..n] in p 5 :: Integer
08:26:25 <lambdabot>  Add a type signature
08:26:28 <int-e> fantasma: you still have to use `div` of course
08:26:53 <matthew_-> quicksilver: (I'm still thinking...) you could use svg for the captcha. That would reduce to only those running recent firefoxes those who could solve the captcha
08:27:13 <fantasma> > let p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k*(3*k-1) `div` 2)) + p(n-(k*(3*k+1)) `div` 2))) [1..n] in p 5
08:27:14 <lambdabot>  0
08:27:43 <vincenz> allbery_b: I know that
08:27:50 <vincenz> allbery_b: my implicit question was why he was opped
08:27:50 <quicksilver> matthew_-: true, but do we want to deny IE users the ability to post ideas?
08:28:02 <int-e> > let p 0 = 1; p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k*(3*k-1) `div` 2)) + p(n-(k*(3*k+1)) `div` 2))) [1..n] in p 5
08:28:03 <vincenz> xerox: so why were you opped?
08:28:04 <lambdabot>  7
08:28:08 <matthew_-> quicksilver: no comment
08:28:19 <fantasma> ahh base case
08:28:47 <fantasma> > let p 0 = 1; p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k*(3*k-1) `div` 2)) + p(n-(k*(3*k+1)) `div` 2))) [1..n] in p 4
08:28:48 <lambdabot>  5
08:28:51 <fantasma> nice!
08:29:01 <matthew_-> quicksilver: ahh - sorry - I assume you're meaning for the trac site. I was meaning for personal blogs etc etc
08:29:13 <fantasma> thanks int-e
08:29:20 <int-e> fantasma: another thing to notice is that the sum doesn't have to be evaluated to n but only up to c*sqrt n  for some constant c.
08:29:38 <int-e> fantasma: and it's interesting how this definition deals with negative n.
08:29:42 <int-e> > let p 0 = 1; p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k*(3*k-1) `div` 2)) + p(n-(k*(3*k+1)) `div` 2))) [1..n] in p (-100)
08:29:43 <lambdabot>  0
08:31:05 <fantasma> int-e: why does it only have to be evaluated to c*sqrt n? and what would c be?
08:31:54 <fantasma> > let p 0 = 1; p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k*(3*k-1) `div` 2)) + p(n-(k*(3*k+1)) `div` 2))) [1..(ceiling (sqrt n)] in p 4
08:31:54 <lambdabot>  Parse error
08:32:10 <fantasma> > ceiling (sqrt 6)
08:32:11 <lambdabot>  3
08:32:25 <fantasma> > [1..ceiling (sqrt 6)]
08:32:26 <lambdabot>  [1,2,3]
08:33:25 <fantasma> > [1..(ceiling (sqrt 1)]
08:33:26 <lambdabot>  Parse error
08:34:25 <fantasma> > let p 0 = 1; p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k*(3*k-1) `div` 2)) + p(n-(k*(3*k+1)) `div` 2))) [0..(ceiling (sqrt n)] in p 4
08:34:25 <lambdabot>  Parse error
08:36:06 <fantasma> > let p 0 = 1; p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k*(3*k-1) `div` 2)) + p(n-(k*(3*k+1)) `div` 2))) [1..n] in map p [1..10]
08:36:08 <lambdabot>  [1,2,3,5,7,11,15,22,30,42]
08:42:06 <int-e> > let p 0 = 1; p n = sum . zipWith (*) (cycle [1,1,-1,-1]) . map p . takeWhile (>=0) $ [x | k <- [1..], x <- [n-k*(3*k-1)`div`2, n-k*(3*k+1)`div`2]] in map p [1..10]
08:42:08 <lambdabot>  [1,2,3,5,7,11,15,22,30,42]
08:42:35 <vincenz> allbery_b: so who got kicked?
08:44:17 <fantasma> int-e: why are you cycling 2 positive and 2 negative
08:44:49 <emk> quicksilver: Thanks for your terminology help earlier, re: monad transformers. Here's the note I was working on: http://www.randomhacks.net/articles/2007/03/05/three-things-i-dont-understand-about-monads
08:44:52 <lambdabot> Title: Three things I don't understand about monads, http://tinyurl.com/233qqc
08:44:56 <quicksilver> emk: I already read it :)
08:45:03 <quicksilver> emk: and guessed it was you, from the question
08:45:14 <int-e> fantasma: because I have a single list containing both n-k*(3*k-1)`div`2 and n-k*(3*k+1)`div`2 alternatingly
08:45:55 <int-e> fantasma: so the first two get added (first term of your sum) then the next two get subtracted, and the the cycle restarts.
08:46:02 <fantasma> int-e: ahhh I see that in the formula
08:46:21 <fantasma> (-1)^(k+1)
08:46:27 <emk> quicksilver: Well, thank you for confirming that my terminology was at least semi-standard. :-)
08:48:41 <fantasma> > let p 0 = 1; p n = sum . zipWith (*) (cycle [1,1,-1,-1]) . map p . takeWhile (>=0) $ [x | k <- [1..], x <- [n-k*(3*k-1)`div`2, n-k*(3*k+1)`div`2]] in p 20
08:48:43 <lambdabot>  627
08:50:28 <int-e> fantasma: note that I've mainly tried to produce something more idiomatic. it still lacks memoisation to be fast.
08:50:57 <fantasma> int-e: don't know what either of those terms mean =\
08:51:05 <fantasma> will look it up
08:51:38 <chessguy> idiomatic = the way you would usually write things like this in a particular language
08:52:04 <chessguy> memoisation = remembering results so as not to repeat a computation
08:52:31 <fantasma> can memoisation be achieved explicitly?
08:52:48 <fantasma> or is it only a result of your code?
08:52:58 <quicksilver> do you mean 'implicitly'?
08:53:16 <fantasma> it would be implicit for the latter
08:53:23 <int-e> fantasma: you have to code it explicitely in most cases - only in rare, accidental cases the compiler spots how to do it for you.
08:53:31 <quicksilver> well everything is as a result of your code :)
08:53:58 <Zeroth|work> whats the most common method of greating GUIs with haskell?
08:53:59 <norpan> using a lazy array is a standard way to implement memoization explicitly
08:54:03 <fantasma> would memoisation be achieved with things like `seq`?
08:54:05 <int-e> (future haskell compilers may be different, but the problem is hard - overzealous memoisation causes space leaks)
08:54:25 <norpan> fantasma: no, seq has to do with strict vs. lazy evaluation
08:54:27 <quicksilver> Zeroth|work: probably wxHaskell
08:54:37 <quicksilver> Zeroth|work: but gtk2hs is looking good recently apparently
08:54:44 <int-e> hmm. does anyone have a wiki link for memoisation at hand?
08:54:53 <Zeroth|work> interesting
08:54:55 <quicksilver> I can't find it anymore
08:54:56 <fantasma> @where memoization
08:54:56 <lambdabot> I know nothing about memoization.
08:55:01 <quicksilver> I think that page rotted
08:55:35 <quicksilver> ah, found it
08:55:37 <quicksilver> http://haskell.org/hawiki/MemoisingCafs
08:55:38 <lambdabot> Title: MemoisingCafs - The Haskell Wiki
08:56:22 <quicksilver> int-e: intelligently adaptive memoisation would probably end up in teh runtime, rather than the compiler
08:56:33 <quicksilver> int-e: since it tends to depend on things which are not statically computable
08:56:56 <fantasma> thanks for the link quicksilver
08:57:00 <int-e> fantasma: the classical example is the fibonacci numbers, where instead of writing  f n = f (n-1) + f (n-2)  you turn the result into a list, fibs = 0:1:zipWith (+) (tail fibs) (tail (tail fibs)), which the compiler then shares; in effect memoising the results.
08:57:26 <int-e> quicksilver: yes, but even then it'll be rather hard to do well.
08:57:28 <pejo> Argh. I think lambdabot forgets a bit too many factoids. Can we force a save or something simliar?
08:57:38 <quicksilver> int-e: VERY hard, I'd say :)
08:57:45 <fantasma> would an infinite list that's filtered be memoized?
08:58:00 <fantasma> (automatically)
08:58:05 <int-e> fantasma: note that the list is created explicitely; the compiler doesn't do that for you.
08:58:20 <quicksilver> if the list is a top-level definition then yes, it would be memoised
08:58:21 <norpan> fantasma: a list?
08:58:26 <quicksilver> if the filtered version is, I mean
08:58:42 <int-e> fantasma: in let x = list in  (f x, g x), x is only computed once.
08:59:09 <int-e> fantasma: 'list' can be a filtering expression. I don't know if that helps you.
09:00:29 <fantasma> it makes more sense now
09:02:18 <int-e> fantasma: oh and of course 'list' can use 'x' as well.
09:02:34 <int-e> fantasma: which is how the fibonacci example works.
09:07:28 <quicksilver> even let expressions are "memoised" for as long as they are in scope
09:15:52 <sjanssen> @quote
09:15:53 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
09:19:36 <haskell> hello, could anyone please help me with a function definition? I need to define a function that checks for each tuple with 3 values in my list whether there exists a tuple in which the first 2 values are switched, the third value is irrelevant
09:21:19 <sjanssen> haskell: okay, what have you got so far?
09:22:48 <haskell> nothing that works, I've tried to do it with elemBy, but that doesn't seem to be so effective if I need to check all elements
09:23:13 <sjanssen> @hoogle elemBy
09:23:13 <lambdabot> No matches found
09:23:58 <sjanssen> haskell: what should your function return?  a Bool?  a list of all the matching tuples?
09:25:32 <haskell> a list of matching tuples
09:25:52 <sjanssen> okay, looks like you want filter
09:25:55 <sjanssen> @type filter
09:25:58 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:26:53 <sjanssen> > filter even [1.. 10]
09:26:54 <lambdabot>  [2,4,6,8,10]
09:27:11 <revence> Salut, lambdafolk. I can't seem to inherit with a class of a kind that has args.
09:27:13 <int-e> norpan: you might like  http://hpaste.org:8000/41  :)
09:27:15 <revence> As in ...
09:28:05 <haskell> thanks, I think forall would be useful
09:28:19 <sjanssen> haskell: forall isn't a function
09:28:52 <haskell> I know but it's a keyword right?
09:28:54 <revence> putStrLn "Checking ..."
09:29:27 <haskell> my problem is that I've got a list with tuples like this: [(String,String,Float)]
09:29:39 <haskell> the worth of the Float is only relevant to the calculation I need to make
09:30:24 <sjanssen> haskell: look at my "filter even" example above
09:30:37 <haskell> but for each tuple (a,b,_) in the list I need to check whether there exists a tuple (b,a,_)
09:31:04 <sjanssen> ah
09:31:06 <vincenz> "but for each tuple (MAP) ... I need to check whether there exists (FILTER)"
09:31:12 <sjanssen> you don't exactly want a filter
09:31:14 <shapr> Is Eric Kidd on #haskell?
09:31:29 <Botje> haskell: what do you do if there's no matching value?
09:31:48 <sjanssen> shapr: Eric Kidd == emu?
09:32:04 <sjanssen> don't quote me on that
09:32:12 <xerox> haskell: lists?
09:32:26 <vincenz> @remember sjanssen "shapr: Erik Kidd == emu? don't quote me on that"
09:32:26 <lambdabot> Done.
09:32:34 <sjanssen> grrr
09:32:37 <xerox> > groupBy (\(x,y,_) (z,w,_) -> (x-z) == (y-w)) [(x,y,z) | x <- [1..3], y <- [1..3], z <- [1..3]]
09:32:39 <lambdabot>  [[(1,1,1),(1,1,2),(1,1,3)],[(1,2,1),(1,2,2),(1,2,3)],[(1,3,1),(1,3,2),(1,3,3...
09:32:42 * sjanssen hopes he was right
09:32:42 <xerox> ^- haskell
09:33:05 <revence> Hey, can anyone instance a class with a parametered constructor? It breaks, for me.
09:33:30 <sjanssen> reverence: can you provide an example?
09:33:31 <xerox> revence: put parens around the tycon
09:34:26 <revence> "Okay. example coming up. Am I allowed to dump hard?"
09:34:54 <sjanssen> dump hard?  if the example is more than a few lines, use:
09:34:55 <sjanssen> @paste
09:34:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:35:43 <sjanssen> haskell: I think what you want to do is combine the "any" and "filter" functions
09:36:15 <revence> Okay. Running to hpaste.
09:36:25 <Botje> > let l = [("one","two",5),("two","one",9),("three","one",2.5),("one","three",4)] in map (\i@(a,b,_) -> (i, listToMaybe [ x | x@(a1,b1,_) <- l, a == b1 && b == a1 ]) ) l
09:36:26 <lambdabot>  [(("one","two",5.0),Just ("two","one",9.0)),(("two","one",9.0),Just ("one","...
09:36:43 <revence> filter (== 100000) [1 .. 1000000000]
09:36:59 <revence> filter (100000 ==) [1 .. 1000000000]
09:37:01 <vincenz> let's stop solving homework? :)
09:37:19 <Botje> but homework is fun if it isn't yours :[
09:37:57 <sjanssen> it's okay, Botje's solution isn't quite what haskell needs
09:38:01 <shapr> vincenz: Aw, be nice
09:38:11 <haskell> nah didn't think so either :P
09:38:23 <haskell> and no I'm not looking for a solution to my homework, just need a little help with this part of the function
09:38:46 <haskell> I've been trying for 2 hours now and getting a bit lightheaded ;)
09:39:07 <sjanssen> haskell: can you write a function that says whether the two tuples are flipped?
09:39:40 <shapr> Is there a good google talk voip client for Linux?
09:40:00 * Botje shrugs, time for more nethack
09:40:06 <sjanssen> ie, a function with type (String, String, Float) -> (String, String, Float) -> Bool
09:40:48 <haskell> first I used this pattern: expand((bv,cv,_):ks) and wanted to test whether a tuple (cv,bv,_) existed in the list
09:41:04 <haskell> but I figured that's not quite going to work since it only tests for the head of the list anyway
09:41:33 <revence> Oh, I think I've figured it out. :o) Sorry, Priests of the Holy Lambda.
09:41:38 <haskell> so I wanted to try by recalling the function sometimes, but if I do so, the function will never know when to stop
09:44:09 <sjanssen> @type any
09:44:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:44:12 <jyasskin> Because Haskell's a higher-order language, it's often helpful to write the simplest function related to your problem, and then build the real answer out of it and combinators. I think sjanssen's thinking of a list comprehension once you've written that test function.
09:45:05 <kscaldef> Hi... I'm running into some strange problems with QuickCheck (or, maybe not QuickCheck precisely).   Running my tests in ghci, inside Emacs Shell mode, I get this exception:
09:45:06 <kscaldef> but last                 : OK, passed 100 tests.
09:45:07 <kscaldef> short but last           : *** Exception: <stdout>: hPutChar: resource exhausted (Too many open files)
09:45:09 <revence> [x | x <- [1 ... 200] , even x]
09:45:34 <kscaldef> running ghci from a normal terminal shell, it doesn't happen
09:46:04 <revence> take 1 [x | x <- [1 ... 200] , even x]
09:46:06 <kscaldef> anyone know this problem?
09:46:28 <icarroll> > take 1 [x | x <- [1 .. 200], even x]
09:46:28 <jyasskin> > [x*y | x <- [1..3], y <- [3..6], odd (x+y)]
09:46:30 <lambdabot>  [2]
09:46:31 <lambdabot>  [4,6,6,10,12,18]
09:48:51 <xerox> haskell: so you do need to know if there exist a triple in the list such that there exist a triple whose first two components are the same as the given triple, but swapped?
09:49:06 <haskell> yes exactly
09:50:33 <xerox> ?type any (\(x0,y0,_) -> any (\(x1,y1,_) -> x0 == y1 && x1 == y0))
09:50:35 <lambdabot>     Couldn't match expected type `Bool'
09:50:36 <lambdabot>            against inferred type `[(t1, t, t2)] -> Bool'
09:51:02 <xerox> ?type let f xs = any (\(x0,y0,_) -> any (\(x1,y1,_) -> x0 == y1 && x1 == y0) xs) xs
09:51:05 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
09:51:05 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
09:51:05 <lambdabot>  
09:51:05 <xerox> ?type let f xs = any (\(x0,y0,_) -> any (\(x1,y1,_) -> x0 == y1 && x1 == y0) xs) xs in f
09:51:08 <lambdabot> forall t t1. (Eq t) => [(t, t, t1)] -> Bool
09:51:08 <xerox> I'm sorry
09:51:21 <xerox> Trying to stop with pointfree notation is hard.
09:51:23 <quicksilver> [(x,y,z) | (x,y,z) <- l , (y,x,z) `elem` l]
09:51:43 <quicksilver> :t \l -> [(x,y,z) | (x,y,z) <- l , (y,x,z) `elem` l]
09:51:45 <lambdabot> forall t t1. (Eq (t, t, t1)) => [(t, t, t1)] -> [(t, t, t1)]
09:51:49 <quicksilver> looks right
09:51:51 <xerox> no
09:52:14 <xerox> he doesn't care about the third element
09:52:32 <quicksilver> ah
09:52:35 <xerox> haskell: actually, have you thought about using a Map if you need to lookup?
09:53:12 <quicksilver> :t \l -> [(x,y,z) | (x,y,z) <- l , (y,x) `elem` [(xx,yy) | (xx,yy,_) <- l] ]
09:53:14 <lambdabot> forall t t1. (Eq (t, t)) => [(t, t, t1)] -> [(t, t, t1)]
09:54:02 <xerox> :)
09:54:52 <Lacrimosa> Can I ask something? Is there a mechanism in Haskell (GHC) for dynamic bytecode generation and execution, runtimely? You know, there are a lot of Java and .NET libraries for dynamic bytecode generation - what about Haskell ?
09:55:09 <shapr> hs-plugins
09:55:15 <xerox> Like this?
09:55:19 <xerox> > 2+2
09:55:20 <lambdabot>  4
09:57:51 <icarroll> IHNJH, IJLS "runtimely"
10:00:13 <Lacrimosa> Well ?
10:00:54 <icarroll> @where hs-plugins
10:00:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
10:04:10 <pafcu> I have an infinite list that starts repeating at some point (e.g [1,2,3,4,4,4,4...]). What would be a good way to get just the start of the list, i.e cut off the repeating part?
10:04:45 <matthew_-> pafcu: um. that's impossible
10:05:07 <jyasskin> pafcu: your_fun [1,2,3,4,4,4,5,5,5,...] == [1,2,3,4] or == [1,2,3,4,4,4,5] ?
10:05:15 <jyasskin> The second is impossible.
10:05:24 <jyasskin> (roughly)
10:05:44 <matthew_-> given that you have "infiniteness" left, how can you know that "infiniteness" only contains repeats of what you've seen so far? It might differ, at the last element
10:05:54 <pafcu> jyasskin: The first alternative, it repeats inifinitely
10:06:42 <pafcu> matthew_- Because I generate it with iterate, and I know that the generating function starts to repeat itself
10:07:24 <sjanssen> pafcu: map fst . takeWhile snd $ zipWith (\x y -> (x, x /= y)) theList (tail theList)
10:08:06 <pafcu> sjanssen: Thanks. I'll try that, although it seems kind of complicated
10:08:41 <pafcu> Basically I just need to see if an element == equals the element at the previous index and cut off the list there.
10:08:59 <pafcu> But I'm not sure how express that in Haskell
10:09:08 <sjanssen> a simple recursive defn. is probably simpler
10:09:41 <sjanssen> f (x:y:xs) | x == y = [x]; | otherwise = x : f (y:xs)
10:10:31 <pafcu> sjanssen: That seems perfect. Just what I was looking for. Thanks
10:11:17 <icarroll> #quote infinite
10:11:23 <icarroll> @quote infinite
10:11:25 <lambdabot> ex0r says: if map was a woman she could probably handle infinite arguments
10:21:12 <fax> hi
10:22:07 <fax> how do you call C functions from haskell? (in particular GHC)
10:22:26 <jyasskin> @where ffi
10:22:26 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
10:23:09 <fasta> Is there a function that combines two m Bools via the function &&? Where m is a monad?
10:23:24 <malcolmw> foreign import ccall "string.h strlen" c_strlen :: Ptr CChar -> CInt
10:23:33 <mux> :t liftIO &&
10:23:35 <lambdabot> parse error (possibly incorrect indentation)
10:23:38 <mux> err, not
10:23:43 <mux> :t liftM &&
10:23:43 <matthew_-> @type liftM2 (&&)
10:23:46 <lambdabot> parse error (possibly incorrect indentation)
10:23:46 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
10:23:47 <jyasskin> fasta: See Data.Monoid.All
10:23:51 <mux> :t liftM (&&)
10:23:54 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m (Bool -> Bool)
10:24:06 <jyasskin> oops, ignore me. I didn't see "monad".
10:24:07 <fasta> mux: that's something else.
10:24:11 * mux notes matthew_- got it right
10:24:17 <mux> oh well :)
10:24:38 <Lacrimosa> lambdabot: thank you for the link :-)
10:24:42 <matthew_-> :) - It does become something of a competition to be helpful ;-)
10:24:50 <icarroll> @botsnack
10:24:50 <lambdabot> :)
10:24:51 <fax> I just type "foreign import ccall "math.h sin" sin :: CDouble -> CDouble." and it says parse error on input `import'
10:25:11 <fasta> Ok, I will write it myself.
10:25:37 <matthew_-> fasta: is liftM2 (&&) not what you want?
10:25:46 <fasta> matthew_-: that's what I said already
10:25:52 <matthew_-> oh, sorry
10:26:15 <fasta> The type should be: (Monad m) => m Bool -> m Bool -> m Bool
10:26:27 <sjanssen> fax: are you compiling with -fffi?
10:26:31 <mux> well that's the type of liftM2 (&&)
10:26:38 <fax> Im not compiling anything, I jsut tried it in ghci
10:26:49 <matthew_-> @type liftM2 (&&)
10:26:52 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
10:26:57 <matthew_-> looks the same to me
10:27:02 * mux nods
10:27:09 <sjanssen> fax: you'll have to type your foreign imports into a file
10:27:10 <fasta> Heh, ok, I was looking at mux's solution.
10:27:24 <mux> yeah, mine was crappy, and matthew_- got it right before I could correct mine
10:27:26 <fasta> liftM and liftM2 are different...
10:27:36 <fasta> I know that, but my eyes missed it.
10:27:41 <sjanssen> be careful, liftM2 (&&) doesn't short circuit like (&&)
10:27:56 <fasta> sjanssen: thanks for the warning.
10:28:06 <fasta> sjanssen: is there something that does short circuit?
10:28:16 <sjanssen> fasta: you'd have to write your own
10:28:20 <fasta> sjanssen: ok
10:28:49 * mux looks skeptically at a /. news saying computer forensics are supposed to solve the pioneer anomaly
10:28:55 * mux highly doubts it
10:29:09 <icarroll> @quote anomaly
10:29:10 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
10:30:22 <fasta> mand c1 c2 = do
10:30:22 <fasta>    b1 <- c1
10:30:22 <fasta>    b2 <- c2
10:30:22 <fasta>    return (b1 && b2)
10:30:33 <fasta> I suppose that's not short circuiting?
10:30:43 <sjanssen> it isn't
10:30:49 <fasta> (since otherwise liftM2 would be to)
10:30:50 <mux> icarroll: http://en.wikipedia.org/wiki/Pioneer_anomaly
10:30:52 <lambdabot> Title: Pioneer anomaly - Wikipedia, the free encyclopedia
10:30:52 <fasta> too*
10:31:32 <sjanssen> @redo c1 >>= \b1 -> if b1 then c2 else return False
10:31:33 <lambdabot> do { b1 <- c1; if b1 then c2 else return False}
10:33:54 <Botje> given that you explicitly _DO_ c1, THEN c2, THEN and them, no.
10:35:03 <fasta> mand c1 c2 =  c1 >>= (\b ->
10:35:03 <fasta>               if b
10:35:03 <fasta>                then c2 >>= (\b2 -> return b2)
10:35:03 <fasta>                else return False)
10:35:08 <fasta> That was my solution
10:36:03 <fasta> My solution is overly redundant
10:38:23 <sjanssen> fasta: remember your monad laws :)
10:38:32 <sjanssen> m >>= return <=> m
10:42:18 <Daveman> :)
10:42:25 <fax> on mac os x, can you use GHC to build a binary for ppc or intel?
10:43:26 <mux> I don't think GHC can do cross-compiles, can it?
10:43:37 <fax> oh
10:44:08 <sjanssen> fax: the easiest way is probably to generate ppc and intel executables with two compilers and use Apple's tools for merging binaries together
10:44:22 <fax> yeah
10:44:48 <sjanssen> I believe the ppc compiler will even run under rosetta
10:44:55 <fax> I was just about to try that but
10:44:56 <fax> lipo: can't figure out the architecture type of: /usr/local/bin/ghc
10:44:57 <fax> :S
10:45:32 <fax> ugh /usr/libexec/oah/translate ghc
10:45:38 <fax> results in segfault
10:45:54 <sjanssen> yikes
10:46:13 <fax> maybe I dont have a UB version of GHC :)
10:46:30 <sjanssen> ghc isn't distributed as a universal binary
10:47:13 <shapr> Is there a Base64 codec for lazy bytestrings?
10:50:01 <shapr> We want to send lazy bytestrings via http. I guess we could just turn 'em into String.
10:51:49 <shapr> I guess we could hack dcoutts' zlib code into a base64 codec for LBS.
10:52:57 <bringert> shapr: wouldn't it be pretty easy to just take igloos base64 for String and modify that?
10:52:57 <sjanssen> you can't just use the normal ByteString IO functions?
10:55:20 <sjanssen> @google haskell base64
10:55:23 <lambdabot> http://homepages.paradise.net.nz/warrickg/haskell/http/
10:55:24 <lambdabot> Title: Haskell HTTP Implementation
10:56:35 <fax> why would I get "Failed to load interface for `PrettyUtils':"
10:56:52 <fax> the file PrettyUtils is in the same dir as the filme (Casm.lhs) which refers to it
10:57:40 <sjanssen> fax: try compiling with --make ?
10:58:27 <fax> ah cool that did it cheers
10:58:40 <fax> they should probably add '--make' to SRC_HC_OPTS in the Greencard makefiles
10:59:09 <sjanssen> fax: greencard should probably use cabal instead of make
10:59:44 <fax> I shold use --cabal?
11:00:32 <sjanssen> fax: cabal is a Haskell build system that is used instead of make
11:00:39 <Saizan> ?where greencard
11:00:39 <lambdabot> http://haskell.org/greencard/
11:00:48 <sjanssen> make as in Makefile, not ghc --make
11:00:59 <fax> I ran the makefile but get errors
11:01:09 <fax> oh/..
11:01:14 <sjanssen> fax: note that the last release is from 2003
11:01:33 <sjanssen> I have a feeling greencard is seriously bitrotted
11:01:39 <fax> :S
11:01:46 <fax> no one uses HOpenGL?
11:02:19 <sjanssen> fax: yeah, people use HOpenGL
11:02:23 <sjanssen> does it use greencard?
11:02:29 <fax> It seems to require it
11:03:14 <fax> oh.. --without-greencard
11:04:21 <Zeroth|work> is haskell use much in commercial software (ie, is it hard to get a job in haskell?)
11:04:55 <sjanssen> fax: you got a message about greencard when you ran runhaskell Setup.hs configure?
11:05:07 <fax> I ran ./configure
11:05:14 <fax> ./configure --without-greencard made it go away
11:06:51 <fax> there is no Setup.hsd
11:06:58 <fax> .hs*
11:07:09 <Saizan> ?where hopengl
11:07:10 <lambdabot> http://haskell.org/HOpenGL/
11:07:32 <thalassocrac> all but a finite amount of code for windows xp was written in haskell
11:08:18 <sjanssen> Zeroth|work: there are a handful of companies using Haskell, but the jobs aren't incredibly common
11:09:18 <wkh> probably the easiest way to use haskell on a regular basis would be to become an independent contractor and do server-side software for clients who don't care what language you use
11:09:47 <chessguy> wkh, a la paul graham?
11:09:59 <wkh> sure
11:10:25 * shapr has a Haskell job!
11:10:34 <Zeroth|work> dare I ask what you make?
11:10:37 <wkh> did it require a PhD?
11:10:45 <jyasskin> @where TheOtherPrelude
11:10:45 <lambdabot> I know nothing about theotherprelude.
11:11:06 <thalassocrac> i heard that naughty dog used scheme for a video game
11:11:18 * Zeroth|work knows 0 about scheme
11:11:20 <wkh> crash bandicoot?
11:11:24 <chessguy> naughty dog?
11:11:39 <fax> jak and daxter
11:11:40 <Vq^> shapr: congratulations
11:11:42 <fax> iirc
11:11:51 <wkh> i thought that was common lisp
11:12:09 <pejo> It's definitely not a bad thing to have a phd if you want a Haskell job.
11:12:13 * chessguy is crossing his fingers, trying to get a haskell job
11:12:15 <wkh> some game company made their own lisp dialect but then scrapped it
11:12:32 <shapr> wkh: Nah, I have no degree, just a bunch of code and experience.
11:13:05 * Zeroth|work is an degree-less sysadmin
11:13:06 <Muad_Dib> yeah, but you are the shapr!
11:14:04 <sjanssen> Zeroth|work: did you know that linspire uses Haskell?
11:14:27 <Zeroth|work> uses it for what?
11:15:54 <sjanssen> Zeroth|work: http://haskell.org/communities/11-2006/html/report.html -- section 7.1.4
11:15:55 <lambdabot> Title: Haskell Communities and Activities Report
11:15:57 <malcolmw> hey shapr, where are you working now?  Sweden, Alabama, elsewhere?
11:15:58 <fax> I cant install HOpengl :D
11:16:16 * fax gives up
11:17:20 <sjanssen> fax: which release are you building?
11:17:37 <fax> I got the most latest one, 1.05
11:17:49 <sjanssen> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OpenGL-2.1
11:17:52 <lambdabot> http://tinyurl.com/2cjvrd
11:18:05 <Zeroth|work> why would you migrate code to haskell? haskell's thing (or so I've been told) is that you can write code fast. migrating == wasting more time.
11:18:09 <fax> huh oh cool, cheers
11:19:23 <sjanssen> Zeroth|work: ostensibly to gain productivity in the future
11:19:34 <kolmodin> it seems GHC warns (with -Wall) about unused imports, and when you remove them, it doesn't compile due to missing functions
11:19:45 <sjanssen> bug fixes, new features, etc. might be easier and faster with Haskell
11:20:33 <sjanssen> kolmodin: is it a missing instances problem?
11:22:22 <fax> sjanssen: cool it actually worked, thanks
11:22:25 <Zeroth|work> I wanna see a C interpreter written in Haskell :-p
11:22:34 <araujo> hello
11:22:50 <fax> does anyone have a sinple example of OpenGL?
11:23:12 <chessguy> sjanssen, that's a great link
11:23:16 <fantasma> @type lexDigits
11:23:18 <lambdabot> String -> [(String, String)]
11:23:36 <fantasma> > lexDigits "12345679"
11:23:38 <lambdabot>  [("12345679","")]
11:23:49 <fantasma> > lexDigits "david"
11:23:50 <lambdabot>  []
11:24:02 <fantasma> > lexDigits "d1a2v3id"
11:24:03 <lambdabot>  []
11:24:06 <chessguy> lots of fascinating projects there
11:24:16 <fantasma> what does lexDigits do?
11:24:21 <kolmodin> sjanssen: no
11:24:42 <kolmodin> for example, I'm using liftM from Control.Monad
11:25:05 <kolmodin> it says I don't need to import that module. I say "huh?" and remove it. now it doesn't compile
11:25:20 <sjanssen> that's funny
11:25:54 <Saizan> maybe it's suggesting you to use fmap :D
11:26:05 <kolmodin> hah :)
11:26:21 <Igloo> kolmodin: Do you import anything qualified that might export liftM?
11:26:41 <kolmodin> no, I don't reexport liftM
11:26:52 <allbery_b> maybe liftM actually lives in some other module (Instances?) that Control.Monad re-exports?
11:27:01 <fantasma> is there some sort of permutation function in the standard libraries?
11:27:02 <kolmodin> allbery_b: I guess so
11:27:15 <allbery_b> and ghc is getting confused by that?  (still qualifies as a bug, IMO)
11:27:50 <kolmodin> it seems quite common if I read the warnings and then try to remove the modules
11:28:03 * Igloo would like to see an example
11:28:26 <shapr> malcolmw: I'm living in Alabama, but my employer is in NYC, and my coworkers are in Denmark and St. Louis
11:28:37 <allbery_b> you might be able to use :info in ghci to verify
11:28:38 <kolmodin> Igloo: I'll try to reproduce a small example
11:28:40 <malcolmw> shapr: globalisation!
11:29:15 <allbery_b> (for example lots of stuff shows in :info as being from various GHC.Prim.* modules)
11:29:16 <shapr> malcolmw: Yes! and virtual pair programming with VNC and Skype! It's FUN!
11:29:19 <shapr> I like working with Lemmih.
11:29:35 <allbery_b> even though it's really Prelude that caused them to be in scope
11:29:35 <malcolmw> oh cool
11:31:04 <cypher543> does haskell support inline assembly?
11:31:19 <Igloo> shapr: What's the skype latency like?
11:31:22 <Igloo> cypher543: No
11:31:52 <notsmack> cypher543: i'd think you'd need to use FFI to call assembly
11:33:04 <shapr> Igloo: Less than a second.
11:33:11 <shapr> Igloo: Want to try it sometime?
11:33:23 <shapr> I'd rather use Google Talk but I can't find a good gtalk voip client in Debian.
11:33:36 <Igloo> I'd have to dig out a microphone first
11:34:01 <shapr> Speaking of jabber clients, is there one in debian that handles *creating* invite-only or passworded text chat rooms?
11:34:18 <Lacrimosa> wkh: not sure about that either
11:34:50 <shapr> Kopete appears to be the most featureful client in debian, but it has very little support for joining invite/password rooms.
11:35:12 <ikaros> sure kopete has more features than gaim? dont think so
11:35:48 <shapr> I think I had problems with gaim, I don't remember for sure.
11:36:08 <fantasma> the best aim client is bitlee
11:36:21 <fantasma> http://www.bitlbee.org
11:36:21 <lambdabot> Title: BitlBee - News
11:36:34 <fantasma> @type inits
11:36:36 <lambdabot> forall a. [a] -> [[a]]
11:36:38 <ikaros> i found the new gaim version(2.0) to be really nice.. but i still use kopete though..
11:36:41 <fantasma> @index inits
11:36:41 <lambdabot> Data.List
11:39:38 <shapr> Igloo: Well, dig up a mic :-)
11:39:52 <shapr> Igloo: It's really fun.
11:40:30 <dylan> speaking takes so much more energy than typing.
11:45:38 <shapr> dylan: I speak much faster than I type :-)
11:45:57 <dylan> well, everything is typed in my first anyway.
11:46:05 <dylan> *head. :)
11:46:13 <dylan> missing words is also much less common in text.
11:49:35 <Vq^> shapr: tested ekiga?
11:55:47 * Zeroth|work hits yaht chapter 6
12:01:03 <fantasma> what kind of error is this: "ERROR - Garbage collection fails to reclaim sufficient space"
12:02:56 <fax> how do you indent haskell code?
12:03:01 <fax> two/three spaces?
12:03:03 <fax> tabs?
12:03:19 <fantasma> are you asking me?
12:03:25 <fax> yeah :D
12:03:38 <fantasma> this was in hugs interactive?
12:03:38 <fax> (you are in the set of everyone)
12:04:03 <fantasma> most people have tab size 3
12:04:48 <pejo> fantasma, the error is what it said - the gc couldn't reclaim enough space. What kind of answer are you looking for?
12:04:57 <Zeroth|work> is it possible to have one module span multiple files?
12:05:06 <fantasma> pejo, I'm looking for a way to fix it
12:05:17 <nominolo> tabsize 3?
12:08:28 <kombinator> Hello #haskell, does anyone know how to easily debug a black hole (when program goes <<loop>>)?
12:10:27 <fantasma> @hoogle choose
12:10:28 <lambdabot> Test.QuickCheck.choose :: Random a => (a, a) -> Gen a
12:10:47 <araujo> kombinator, compile with -Wall ?
12:11:27 <QtPlatypus> What does "Non-exhaustive patterns in funtion" mean?
12:11:42 <nominolo> kombinator: or maybe try buddha
12:11:45 <araujo> QtPlatypus, you are not checking for possible values on patter matching
12:11:51 <nominolo> haven't tried that yet, though
12:12:17 <fantasma> someone please help me fix this error: "ERROR - Garbage collection fails to reclaim sufficient space"
12:13:07 <araujo> fantasma, how do you get that?
12:13:17 <fantasma> araujo: using hugs :(
12:13:35 <araujo> no idea
12:14:22 <lag> fantasma: in hugs you can usually try to narrow down which function is looping by testing them individually
12:14:30 <kombinator> fantasma: I got it once using hugs when I created a very long list which was on top level and it couldn't have been garbage-collected
12:14:32 <pejo> fantasma, recursing infinitely deep, or something else that is infinite that might be strict by mistake?
12:15:09 <kombinator> fantasma: It's probably some kind of space leak
12:15:15 <fantasma> > let perms [] = [[]]; perms (x:xs) = [ p ++ [x] ++ s | xs' <- perms xs, (p, s) <- zip (inits xs') (tails xs') ] in (sort . perms) "0123456789" !! 1000000
12:15:19 <lambdabot> Terminated
12:15:26 <fantasma> that is what I am trying to run
12:16:11 <fantasma> > let perms [] = [[]]; perms (x:xs) = [ p ++ [x] ++ s | xs' <- perms xs, (p, s) <- zip (inits xs') (tails xs') ] in (sort . perms) "012345" !! 10
12:16:12 <lambdabot>  "013524"
12:17:50 <fantasma> can someone run that in ghc really quick ;)
12:20:53 <wkh> i did
12:21:00 <wkh> it generates lots of permutations.
12:21:26 <wkh> the output for running on an easier case, "012" is
12:21:27 <wkh>  (sort . perms) "012345" !! 10
12:21:27 <wkh> <lambdab
12:21:29 <wkh> fuck
12:21:37 <wkh> ["012","021","102","120","201","210"]
12:22:02 <fantasma> (sort . perms) "0123456789" !! 1000000 --this is what I need
12:22:16 <wkh> why?
12:22:20 <wkh> why can't you run it on your own computer?
12:22:30 <fantasma> i only have hugs and I'm at school
12:22:47 <TSC> It seems to take a lot of memory
12:23:03 <wkh> it's taking many seconds, indexing the millionth element of a list is retarded
12:23:28 <wkh> ok it used up all my memory
12:23:29 <fantasma> :(
12:23:34 <wkh> had to kill the process
12:23:42 <fantasma> it only takes a min or two
12:24:03 <wkh> i have a gig of ram and it was working with virtual memory making the disk chug
12:24:03 <chessguy> fantasma, how do you know, if you can't run it?
12:24:13 * nmessenger has been churning on it since fantasma first asked.  Poor compy dying :(
12:24:13 <TSC> > product [1..10]
12:24:15 <lambdabot>  3628800
12:24:30 <TSC> > 3628800 * 20
12:24:32 <lambdabot>  72576000
12:24:35 <chessguy> nmessenger, i suspect his algorithm is very inefficient
12:24:47 <fantasma> chessguy: I did it once and then I added sort and I kept getting that error
12:25:05 <TSC> Because the sorting defeats laziness
12:25:05 <wkh> it appears to work correctly
12:25:17 <wkh> i looked at the output from 012345 and it seemed to generate all the permutations in order
12:25:26 <fantasma> hmmm
12:25:31 <wkh> hmmmm.
12:25:41 <fantasma> > let perms [] = [[]]; perms (x:xs) = [ p ++ [x] ++ s | xs' <- perms xs, (p, s) <- zip (inits xs') (tails xs') ] in perms "012345"
12:25:42 <lambdabot>  ["012345","102345","120345","123045","123405","123450","021345","201345","21...
12:25:57 <fantasma> > let perms [] = [[]]; perms (x:xs) = [ p ++ [x] ++ s | xs' <- perms xs, (p, s) <- zip (inits xs') (tails xs') ] in perms "0123"
12:25:58 <lambdabot>  ["0123","1023","1203","1230","0213","2013","2103","2130","0231","2031","2301...
12:26:03 <fantasma> guess not
12:26:12 <TSC> You could rewrite the perms function so that it generates them in order
12:26:24 <fantasma> yes, yes I could
12:26:48 <TSC> Or, if you just want to know the 1000001th permutation, you could calculate it by hand
12:28:02 <fantasma> > product [1..10]
12:28:03 <lambdabot>  3628800
12:28:11 <Zeroth|work> "where" is nothing more than a "namespace" as in C?
12:28:26 <Cale> Zeroth|work: where is syntax for let
12:28:30 <fantasma> perm(3628800, 1000000) ??
12:29:12 <Cale> let <decls> in <expr> is an expression in which the declarations <decls> are present in the evaluation of <expr>
12:29:43 <Cale> Where clauses are translated into let expressions, but the difference is that where scopes over multiple guards.
12:30:09 <Cale> So if you have:
12:30:16 <Cale> f x | y > 0 = ...
12:30:17 <Zeroth|work> Cale, thats a bit much to wrap my brain around
12:30:22 <Cale>     | y == 0 = ...
12:30:28 <Cale>   where y = x^2
12:30:33 <Cale> that's okay :)
12:30:42 <Cale> It's translated into something like:
12:31:14 <nmessenger> Zeroth|work: you know when you introduce a {} block in C, you can use new names that won't be visible from outside?  It's like that.
12:31:48 <Cale> f x = let y = x^2 in <stuff that handles guards>
12:34:01 <nmessenger> 'let' and 'where' allow you to introduce locally scoped names.
12:34:22 * Zeroth|work struggles
12:34:44 <mbishop> scoping shouldn't be a hard concept :P
12:34:47 <Zeroth|work> nmessenger, I'm not sure thats right
12:34:49 <TSC> It's the same concept as a local variable in C
12:35:00 <allbery_b> Zeroth|work: huh?
12:35:05 <TSC> Except they don't "vary" as much in Haskell
12:35:07 <Zeroth|work> nmessenger, you can add {} to anywhere and it doesn't change namespace )in C)
12:35:11 <nmessenger> The 'where' at the top of module simply introduces *all* the names in the module
12:35:30 <TSC> Zeroth|work: But it does change the scope of variables declared inside that block
12:35:32 <allbery_b> "like" that, not identical to it
12:35:40 <nmessenger> {x = 1; {y = 2} /* can't use y here! */ }
12:35:41 <Zeroth|work> TSC, I wasn't aware of that heh
12:35:58 <allbery_b> \of course haskell's scoping rules differ from C's; {} doesn;t introduce scope, it just disables the layout rule
12:36:02 <Zeroth|work> TSC, you can just randomly { int c=0 } anywhere in a program?
12:36:11 <allbery_b> (or activates record syntax)
12:36:23 <allbery_b> zeroth|work: yes
12:36:32 <allbery_b> but c goes out of scope at the closing brace
12:36:37 <nmessenger> Zeroth|work: anywhere you could put an ordinary statement, yes.  That's what {} is.
12:37:04 <allbery_b> { int c = 0; mumble; ...; } is legal anywhere a statement can be used (and in gnu c, anywhere an expression can be used)
12:37:18 * nmessenger forgot to type his c variables.  Such redundance.
12:37:43 <fantasma> nmessenger: did you end up churning it or did it die?
12:37:53 <nmessenger> I killed it
12:38:08 <nmessenger> my... compy... wasn't... moving... much.
12:38:16 <fantasma> :)
12:38:22 <notsmack> Zeroth|work: the reason blocks work in C after an if or while is that they're expecting a statement, which the block satisfies
12:38:55 <notsmack> that's why "if (1) printf("yo.\n");" works without the {}
12:39:26 <mauke> ;{{{}}};
12:40:36 <Zeroth|work> nmessenger, ok, so where is *exactly* like {} from C ?
12:40:56 <Zeroth|work> s/where/\"where\"
12:41:18 <fax> http://rafb.net/p/6n1NXO68.txt
12:41:23 <nmessenger> uh, it's similar enough to work.
12:41:28 <notsmack> Zeroth|work: no, it's just similar in how it lets you declare local identifiers
12:41:36 <fax> please tell me I am drawing a checkerboard in a horrendusly stupid way..
12:41:57 <fax> (withCheckImage is stolen)
12:42:27 <wkh> having succeeded in getting several of us to turn our computers into paperweights until we reboot, he leaves without a trace
12:42:51 <TSC> I wonder if he was doing the Project Euler problem
12:43:14 <TSC> If so, he really wanted (!! 999999) ...
12:44:56 <nmessenger> wkh: a guy's gotta have a goal :D
12:44:58 <Zeroth|work> "where" and "in" can be used interchangably? (with correct syntax)
12:45:09 <Zeroth|work> or do they do different things?
12:45:20 <notsmack> in is for use with let
12:45:27 <nmessenger> Zeroth|work: They do the same thing, but where has a slightly larger scope.
12:45:50 <notsmack> (am i wrong?)
12:45:55 * notsmack checks
12:46:50 <nmessenger> (let <decls> in <expr>) or <lhs> = <expr> where <decls>
12:47:00 <wkh> right
12:47:01 <Zeroth|work> "in" is an end-of-statement thing, whereas "where" is a beginning-of-statement thing. is that always true?
12:47:17 <Zeroth|work> (bla) in ...   versus   where ... (blah)
12:47:25 <notsmack> huh?
12:47:26 <malcolmw> let <decls> in <expr> can be used anywere an expr can be used, but <expr> where <decls> can only be used in certain positions in a decl
12:47:39 <nmessenger> Zeroth|work: er, no.  'in' is a part of the 'let' syntax
12:48:11 <nmessenger> @pretty let x = 1; y = 2; z = 3 in 4
12:48:12 <lambdabot>  i = let x = 1
12:48:12 <lambdabot>          y = 2
12:48:12 <lambdabot>          z = 3
12:48:12 <lambdabot>        in 4
12:49:07 * Zeroth|work stares at the number 4
12:50:19 <Lemmih> If you stare long enough at the number 4, it will stare back at you.
12:50:43 <Zeroth|work> 4 has always been my favorite number
12:50:51 <Zeroth|work> but I'm not sure what it's doing there
12:50:57 <hpaste>  fax pasted "(no title)" at http://hpaste.org/803
12:51:08 <notsmack> it's a placeholder for the expression in which x, y, and z are defined now
12:51:19 <fax> please can someone tell me what I am doing stupidly
12:51:26 <fax> (the code works, but its very long)
12:51:35 <fax> and confusing.. probably
12:51:44 <Zeroth|work> I understand:  f x = let y = x+1 in y
12:51:58 <Zeroth|work> but I don't understand: f x = let y = x+1 in 4
12:52:08 <Zeroth|work> or maybe I just dont understand at all
12:52:13 <notsmack> Zeroth|work: no, you got it
12:52:26 <notsmack> 4 isn't actually a useful value there, he was just showing you the syntax.
12:52:52 <int-e> Zeroth|work: the y is defined but not used - that's permitted.
12:53:19 <Zeroth|work> so x+1 in 6 is 7, regardless of the variable its being put into
12:53:24 <Zeroth|work> woah
12:53:29 <nmessenger> no
12:53:36 <Zeroth|work> omg
12:53:42 <psi`> > let x = 42 in 1
12:53:43 <lambdabot>  1
12:54:00 <nmessenger> > let x = 4 in (let y = x + 1 in y)
12:54:01 <Zeroth|work> > let x = 41
12:54:01 <lambdabot>  5
12:54:02 <lambdabot>  Parse error
12:54:09 <nmessenger> > let x = 4 in (let y = x + 1 in 7)
12:54:10 <lambdabot>  7
12:54:26 <malcolmw> fax: looks OK to me.  programming in OpenGL is always fairly verbose, cos the API is so imperative
12:54:37 <fax> hnn
12:54:42 <int-e> > f x = let y = x+1 in 4 in (f 0, f 1, f undefined)
12:54:42 <lambdabot>  Parse error
12:54:50 <int-e> > let f x = let y = x+1 in 4 in (f 0, f 1, f undefined)
12:54:51 <lambdabot>  (4,4,4)
12:55:01 <Zeroth|work> ok
12:55:09 <int-e> Zeroth|work: the y = x+1 just isn't used at all.
12:55:20 <Zeroth|work> so: f x = let y = x+1 in y  can be written as  f x = let y = x + (1 in y)
12:55:24 <Zeroth|work> because y IS 1  ?
12:55:27 <fax> ok cheers malcolmw
12:55:37 <int-e> Zeroth|work: no
12:55:42 <malcolmw> fax: of course, you are drawing coordinates explicitly, which I guess is just because it is a simple test prog
12:55:42 <nmessenger> s/(1 in y)/1/
12:55:46 <Zeroth|work> I dont understand why "in y" is needed
12:56:08 <wkh> in y tells the compiler/interpreter what to take as the value for the expression
12:56:17 <fax> yeah
12:56:20 <malcolmw> fax: in reality, you would probably use some pure expressions to compute the co-ords and just pass them to the callback
12:56:38 <shapr> Vq^: Just trying ekiga, but having lots of problems with it.
12:56:43 <notsmack> > let reverse = r in r "value"
12:56:44 <lambdabot>   Not in scope: `r'
12:56:44 <Zeroth|work> so  f x = let y = x+1 in h   means h takes the value?
12:56:48 <notsmack> er
12:56:49 <nmessenger> (let <decls> in <expr>), decls is a bunch of name bindings, expr is an expression that (usually) *uses* those name bindings
12:56:50 <int-e> > let in 42
12:56:51 <lambdabot>  42
12:56:54 <notsmack> > let r = reverse in r "value"
12:56:55 <lambdabot>  "eulav"
12:57:11 <fax> > drop 10 from pt = [1] : [1 : (zipWith (+) x (tail x)) ++ [1] | x <- pt
12:57:11 <lambdabot>  Parse error
12:57:17 <notsmack> (r "value") is the expression being evaluated.
12:57:35 <notsmack> to do that it subs in the values defined before the 'in', such as 'r = reverse'
12:59:36 <nmessenger> > (let {x = 3} in (x * 2)) -- hopefully explicit boundaries will help some
12:59:37 <lambdabot>  6
12:59:39 <Zeroth|work> the value of an expression is what it returns
13:00:04 <Zeroth|work> nmessenger, that makes sense to me
13:00:17 <Zeroth|work> nmessenger, but to just put "in y" at the end with nothing else....doesn't
13:00:26 <Zeroth|work> > let x = 5 in x
13:00:28 <lambdabot>  5
13:00:30 <Zeroth|work> okay
13:00:36 <nmessenger> Zeroth|work: that's because it's invalid syntax
13:00:49 <nmessenger> inside (x * 2), the 'x' is replaced with x's value (3)
13:00:55 <Vq^> shapr: ok :/
13:00:55 <Zeroth|work> nmessenger, well look at the top of page 76 of YAHT
13:01:14 <Zeroth|work> and disregard the "where" at the bottom
13:01:16 <nmessenger> Zeroth|work: yes?
13:01:30 <Zeroth|work> it just says "f x = let y = x+1 in y"
13:01:30 <nmessenger> let {y = x + 1} in (y)
13:02:06 <Zeroth|work> > let y = x+1 in 4
13:02:07 <lambdabot>   Not in scope: `x'
13:02:19 <nmessenger> Zeroth|work: x is a parameter to the 'f' function.
13:02:20 <notsmack> y is replaced with "x+1", x+1 becomes the value of the expression
13:02:24 <Zeroth|work> yeah I know
13:02:41 <Zeroth|work> its hard to use functions in this interpreter...
13:02:47 <Zeroth|work> which doesnt let you define functions
13:02:51 <nmessenger> int f(int x) {int y = x + 1; return y;}
13:03:16 <Zeroth|work> so y is just the return value?
13:03:28 <Zeroth|work> because *everything* needs a return value
13:03:46 <nmessenger> yep, the expression on the right-hand-side is what functions evaluate to, or "return"
13:03:51 <Zeroth|work> > let y = 64 in 6
13:03:53 <lambdabot>  6
13:03:55 <Zeroth|work> haha
13:04:24 <nmessenger> it's not as complicated as you might think it is.
13:06:27 <nmessenger> > let { f x = (let {y = x+1} in (y)) } in (f 5) -- you can define functions in the interpreter with 'let', but you have to use them in the 'in' clause, then they go out of scope
13:06:29 <lambdabot>  6
13:06:58 <nmessenger> > f 1 -- no longer in scope, since it was just inside of the previous 'let'
13:06:59 <lambdabot>   Not in scope: `f'
13:07:09 <chessguy> > let f = 3; g = 2 in g
13:07:11 <lambdabot>  2
13:07:49 <narain> do curly braces have any special meaning or are they just ignored in this context?
13:07:59 <chessguy> they are used for explicit layout
13:08:24 <xian> hello. perhaps you could enlighten me why 1/0 is infinity and not "undefined"?
13:08:28 <nmessenger> @pretty let {x=1;y=2} in x+y
13:08:28 <lambdabot>  i = let x = 1
13:08:28 <lambdabot>          y = 2
13:08:28 <lambdabot>        in x + y
13:08:33 <nmessenger> ^^ same thing
13:08:37 <narain> right, i've seen that in do blocks
13:08:46 <narain> but it doesn't seem to be required in let exprs
13:08:53 <nmessenger> xian: IEEE floating point
13:08:58 <narain> > let x = 1; y = 2 in x + y
13:09:00 <lambdabot>  3
13:09:11 <nmessenger> > 1 `div` 0 -- integer divide-by-zero is undefined, though
13:09:13 <lambdabot>  Exception: divide by zero
13:09:30 <narain> > do x <- [1,2,3]; return x
13:09:32 <lambdabot>  [1,2,3]
13:09:33 <chessguy> whoah
13:09:40 <fax> > 0 `div` 0
13:09:42 <lambdabot>  Exception: divide by zero
13:09:46 <chessguy> never saw @pretty before
13:09:50 <chessguy> @help prett
13:09:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:09:53 <chessguy> @help pretty
13:09:53 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
13:10:12 <xian> nmessenger: thanks.
13:10:18 <chessguy> narain, http://en.wikibooks.org/wiki/Haskell/Indentation touches on explicit layout some
13:12:56 <augustss> > (-1) / 0
13:12:58 <lambdabot>  -Infinity
13:13:09 <augustss> > 1 / (-0)
13:13:10 <lambdabot>  -Infinity
13:13:22 <narain> ah, so if you actually want to use ugly nonsensical indentation, you can do so using braces?
13:13:32 <chessguy> yes
13:13:40 <augustss> > -0 == 0
13:13:42 <lambdabot>  True
13:14:03 <narain> chessguy, that's one piece of information i will certainly avoid using :)
13:14:08 <Zeroth|work> point free programming (not to be confused with /pointless/ programming)
13:14:08 <Zeroth|work> hahahaha
13:14:18 <nmessenger> @help pointless
13:14:19 <lambdabot> pointless <expr>. Play with pointfree code.
13:14:24 <chessguy> narain, :)
13:14:31 <nmessenger> @pl \x y z -> x z (y z)
13:14:31 <lambdabot> ap
13:14:33 <notsmack> > (-1) / 0 == (-1) / (-0)
13:14:34 <lambdabot>  False
13:14:39 <narain> > sgn -0
13:14:40 <lambdabot>   Not in scope: `sgn'
13:14:43 <narain> > signum -0
13:14:44 <lambdabot>   add an instance declaration for (Num (a -> a))
13:14:45 <lambdabot>     In the expression: signu...
13:14:47 <notsmack> huh... seems like that violates /something/
13:14:50 <augustss> > signum (-0)
13:14:51 <lambdabot>  0
13:15:12 <narain> :t ap
13:15:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:15:23 <augustss> notsmack: IEEE floating point don't have the properties you expect of numbers
13:15:28 <narain> > -1
13:15:30 <lambdabot>  -1
13:15:31 <notsmack> augustss: yeah
13:15:32 <narain> > -0
13:15:33 <lambdabot>  0
13:15:45 <augustss> > isNegativeZero (-0)
13:15:45 <nmessenger> > (0/0) == (0/0)
13:15:48 <lambdabot>  True
13:15:48 <lambdabot>  False
13:15:54 <narain> > signum -0 -- what happens here? (-) as an operator?
13:15:55 <lambdabot>   add an instance declaration for (Num (a -> a))
13:15:55 <lambdabot>     In the expression: signu...
13:16:00 <nmessenger> narain: yes
13:16:12 <narain> argh, confusing
13:16:32 <Zeroth|work> :t ($)
13:16:34 <lambdabot> forall a b. (a -> b) -> a -> b
13:16:34 <notsmack> > isNegativeZero (0-0)
13:16:35 <augustss> narain: yes, having - as both negation and subtraction is confusing
13:16:36 <lambdabot>  False
13:17:10 <narain> augustss: point taken :)
13:17:12 <Zeroth|work> > ($) fst (3,4)
13:17:12 <augustss> > isNegativeZero (1/(-1/0))
13:17:14 <lambdabot>  True
13:17:15 <lambdabot>  3
13:17:28 <nmessenger> "apply the fst function to (3,4)"
13:17:36 <nmessenger> ($) is apply
13:17:39 <Zeroth|work> what the heck is ($)
13:17:45 <nmessenger> @src ($)
13:17:46 <lambdabot> f $ x = f x
13:17:47 <augustss> :t ($)
13:17:50 <lambdabot> forall a b. (a -> b) -> a -> b
13:18:01 <Zeroth|work> I just looked at that....
13:18:09 <augustss> @djinn  (a -> b) -> a -> b
13:18:10 <lambdabot> f a = a
13:18:19 <narain> @help djinn
13:18:20 <lambdabot> djinn <type>.
13:18:20 <lambdabot> Generates Haskell code from a type.
13:18:20 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
13:18:21 <nmessenger> f (g (h (k x))) = f $ g $ h $ k x
13:18:54 <narain> = f . g . h . k $ x
13:19:08 <nmessenger> yeah, but one thing at time ;)
13:19:15 <narain> oops, sorry :)
13:19:40 <augustss> Zeroth|work: 'f $ x' is just a different way to write 'f x'
13:19:44 <Zeroth|work> funn
13:19:56 <Zeroth|work> yeah I just read that, heh
13:20:11 <augustss> Zeroth|work: one that saves ()
13:20:32 <augustss> > sqrt $ 2+2
13:20:33 <lambdabot>  2.0
13:21:14 <nmessenger> > sqrt 2 + 2 -- parses as (sqrt 2) + 2
13:21:15 <lambdabot>  3.414213562373095
13:21:41 <Zeroth|work> > sqrt $ (sqrt 2) (sqrt 2)
13:21:42 <lambdabot>   add an instance declaration for (Floating (t -> a))
13:21:54 <Zeroth|work> erm
13:21:54 <Jaak> @djiin-env
13:21:55 <lambdabot> Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:22:05 <nmessenger> Zeroth|work: that's sqrt ((sqrt 2) (sqrt 2))
13:22:16 <Zeroth|work> yeah, not what I wanted to do anyhow
13:22:20 <xerox> > sqrt $ sqrt 2 * sqrt 2
13:22:22 <lambdabot>  1.4142135623730951
13:22:33 <Zeroth|work> > (sqrt 2) * (sqrt 2)
13:22:35 <lambdabot>  2.0000000000000004
13:22:37 <augustss> > exp pi
13:22:38 <lambdabot>  23.140692632779267
13:22:52 <narain> > pi^e
13:22:55 <lambdabot>   Not in scope: `e'
13:23:01 <narain> > pi ^ (exp 1)
13:23:02 <augustss> > pi ** exp 1
13:23:03 <lambdabot>  Add a type signature
13:23:05 <lambdabot>  22.45915771836104
13:23:10 <nmessenger> > exp (pi * (0 :+ 1))
13:23:13 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
13:23:14 <narain> :t (^)
13:23:17 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:23:23 <Zeroth|work> > (sqrt 2 :: double) * (sqrt 2 :: double)
13:23:24 <lambdabot>        add (Floating double) to the expected type of an expression
13:23:24 <lambdabot>     In the...
13:23:38 <augustss> capital D
13:23:41 <nmessenger> let i = 0:+1; e = exp 1 in e ^ (pi * 1) + 1
13:23:45 <nmessenger> let i = 0:+1; e = exp 1 in e ^ (pi * i) + 1
13:23:46 <Zeroth|work> > (sqrt 2 :: Double) * (sqrt 2 :: Double)
13:23:48 <lambdabot>  2.0000000000000004
13:23:49 <nmessenger> > let i = 0:+1; e = exp 1 in e ^ (pi * i) + 1
13:23:50 <lambdabot>        add an instance declaration for (Integral (Complex t))
13:23:57 <narain> (**)
13:24:00 <nmessenger> yes
13:24:05 <nmessenger> > let i = 0:+1; e = exp 1 in e ** (pi * i) + 1
13:24:06 <lambdabot>  0.0 :+ 1.2246063538223773e-16
13:24:17 <narain> "close enough"
13:24:29 <nmessenger> floating_point--
13:24:52 <narain> floating point epsilon is roughly 10^-16 anyway
13:25:09 <augustss> it's probably 1 ups off
13:25:10 <narain> this is the best you can do
13:25:14 <Zeroth|work> > (sqrt 2 :: Double) * (sqrt 2 :: Double) :: int
13:25:15 <lambdabot>   (sqrt 2 :: Double) * (sqrt 2 :: Double)
13:25:15 <lambdabot>     In the expression: (sqrt 2 :: D...
13:25:23 <Zeroth|work> > (((sqrt 2 :: Double) * (sqrt 2 :: Double)) :: int)
13:25:24 <lambdabot>   ((sqrt 2 :: Double) * (sqrt 2 :: Double))
13:25:25 <lambdabot>     In the expression:
13:25:25 <lambdabot>         ((...
13:25:36 <narain> capital I
13:25:40 <Zeroth|work> > (((sqrt 2 :: Double) * (sqrt 2 :: Double)) :: Int)
13:25:41 <lambdabot>  Couldn't match expected type `Int' against inferred type `Double'
13:25:44 <nmessenger> also a type error
13:25:54 <Zeroth|work> hmm I got it
13:26:00 <nmessenger> use truncate to Intify
13:26:05 <narain> @hoogle Double -> Int
13:26:05 <lambdabot> No matches, try a more general search
13:26:08 <Zeroth|work> > read (show ((sqrt 2 :: Double) * (sqrt 2 :: Double)))
13:26:09 <augustss> Zeroth|work: you need round, floor, or ceiling to convert to Int
13:26:10 <lambdabot>  Exception: Prelude.read: no parse
13:26:19 <maskd> > 0.2 + 0.1 - 0.3
13:26:20 <lambdabot>  5.551115123125783e-17
13:26:28 <narain> @hoogle Num a => a -> Int
13:26:29 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
13:26:30 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
13:26:30 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
13:26:38 <augustss> :t round
13:26:40 <Zeroth|work> augustss, example?
13:26:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:26:50 <augustss> > round 1.2
13:26:51 <lambdabot>  1
13:26:54 <Zeroth|work> show (2.4)
13:26:57 <Zeroth|work> > show (2.4)
13:26:58 <lambdabot>  "2.4"
13:27:09 <augustss> > ceiling 1.2
13:27:10 <lambdabot>  2
13:27:28 <Zeroth|work> > round((sqrt 2) * (sqrt 2))
13:27:30 <lambdabot>  2
13:27:49 <nmessenger> > map ($ (-3.7)) [truncate, ceiling, floor, round]
13:27:50 <lambdabot>  [-3,-3,-4,-4]
13:28:17 <jyasskin> nmessenger: Where did you put TheOtherPrelude again? I'm suspecting that I've forgotten the right name since Google can't find it.
13:28:27 <narain> @wiki The_Other_Prelude
13:28:28 <lambdabot> http://www.haskell.org/haskellwiki/The_Other_Prelude
13:28:33 <jyasskin> Ah, thanks.
13:28:37 <Zeroth|work> round (5.444444449)
13:28:43 <Zeroth|work> > round (5.444444449)
13:28:45 <lambdabot>  5
13:28:54 <augustss> > round 5.5
13:28:55 <nmessenger> > [-3.7, 1.2] <*> [truncate, ceiling, floor, round]
13:28:56 <lambdabot>  6
13:28:56 <lambdabot>        add an instance declaration for (Fractional ((a -> b1) -> b))
13:28:56 <lambdabot>     In t...
13:29:00 <augustss> > round 6.5
13:29:01 <lambdabot>  6
13:29:13 <narain> that is good behaviour
13:29:19 <nmessenger> > [-3.7, 1.2] <**> [truncate, ceiling, floor, round]
13:29:20 <lambdabot>  [-3,-3,-4,-4,1,2,1,1]
13:29:33 <narain> all these HOFs!
13:29:35 <narain> :t <**>
13:29:38 <lambdabot> parse error on input `<**>'
13:29:39 <nmessenger> :D
13:29:43 <narain> :t (<**>)
13:29:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
13:29:51 <Zeroth|work> who needs college
13:29:55 <Zeroth|work> I've got IRC
13:29:58 <nmessenger> (<**>) = flip (<*>)
13:29:59 <Zeroth|work> and books
13:30:07 <augustss> :t (<**>)
13:30:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
13:30:15 <narain> @src Applicative
13:30:16 <lambdabot> class Functor f => Applicative f where
13:30:16 <lambdabot>     pure  :: a -> f a
13:30:16 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:30:32 <narain> > pure 1 :: [Int]
13:30:38 <nmessenger> @src [] (<*>)
13:30:39 <lambdabot> (<|>) = (++)
13:30:41 <Zeroth|work> how did you guys do that patter matching thing? like put in 1,3,5.. and hugs would churn out 1,3,5,7,9....
13:30:45 <nmessenger> :O
13:31:00 <Zeroth|work> > 1,3,5..
13:31:00 <lambdabot>  Parse error
13:31:04 <jyasskin> @where+ TheOtherPrelude http://www.haskell.org/haskellwiki/The_Other_Prelude
13:31:05 <lambdabot> Done.
13:31:05 <Zeroth|work> > [1,3,5..]
13:31:06 <lambdabot>  Parse error
13:31:08 <narain> > [1,3..]
13:31:10 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
13:31:11 <jyasskin> @where TheOtherPrelude
13:31:12 <lambdabot> http://www.haskell.org/haskellwiki/The_Other_Prelude
13:31:13 <jyasskin> :)
13:31:19 <Zeroth|work> why didnt mine work?
13:31:27 <narain> square brackets
13:31:35 <Zeroth|work> was the same as yours
13:31:38 <nmessenger> [from, then.. to] is special syntax
13:31:42 <narain> oh and only two
13:31:44 <narain> right
13:31:59 <augustss> > [0,0.1 .. 1]
13:32:01 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
13:32:03 <nmessenger> @hoogle enumFrom
13:32:04 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
13:32:04 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
13:32:04 <lambdabot> Prelude.enumFromThenTo :: Enum a => a -> a -> a -> [a]
13:32:10 <nmessenger> @hoogle+
13:32:11 <lambdabot> Prelude.enumFromTo :: Enum a => a -> a -> [a]
13:32:11 <lambdabot> Language.Haskell.Syntax.HsEnumFrom :: HsExp -> HsExp
13:32:11 <lambdabot> Language.Haskell.Syntax.HsEnumFromThen :: HsExp -> HsExp -> HsExp
13:32:25 <nmessenger> > enumFromThen 3 5
13:32:27 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
13:32:53 <nmessenger> just an ordinary function
13:33:00 <narain> Doubles are Enums? that's certainly stretching the definition of "enumerable" :)
13:33:14 <nmessenger> heh, indeed
13:33:36 <Zeroth|work> f 0 = 0; f x = (x - 2) + (x - 1) in f 10
13:33:44 <Zeroth|work> > f 0 = 0; f x = (x - 2) + (x - 1) in f 10
13:33:44 <lambdabot>  Parse error
13:33:50 <narain> let
13:33:51 <nmessenger> let
13:33:58 <Zeroth|work> > let f 0 = 0; f x = (x - 2) + (x - 1) in f 10
13:33:59 <lambdabot>  17
13:34:22 <narain> something's amiss... you didn't need a base case for that
13:34:23 <erwin> http://www.drogendealer.de/cgi-bin/dd.cgi?z8nBe44s
13:34:25 <lambdabot> Title: Drogendealer
13:34:29 <nmessenger> do you mean (f (x-2) + f (x-1))?
13:34:32 <Zeroth|work> yeah
13:34:40 <Zeroth|work> it didn't even go up, shoudl have
13:34:52 <narain> you should also define f 1 = 1
13:34:54 <nmessenger> add the 'f' recursions
13:34:55 <Zeroth|work> > (10 - 2 ) + (10 - 1)
13:34:56 <lambdabot>  17
13:34:59 <narain> if you're trying to do fibonacci
13:35:10 <Zeroth|work> didnt recurse
13:35:17 <Zeroth|work> ?
13:35:20 <narain> you're not doing any recursive calls
13:35:24 <Zeroth|work> aye
13:35:30 <narain> what nmessenger said
13:35:41 <nmessenger> > fix $ (0:) . (1:) . ap (zipWith (+)) tail
13:35:41 <Zeroth|work> > let f 0 = 0; x = f (x - 2) + (x - 1) in f 10
13:35:43 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:35:43 <lambdabot>   Non-exhaustive patterns in function f
13:35:44 <Zeroth|work> heh
13:36:00 <nmessenger> you need f 1 = 1
13:36:07 <Zeroth|work> > let f 1 = 1; x = f (x - 2) + (x - 1) in f 10
13:36:09 <lambdabot>   Non-exhaustive patterns in function f
13:36:18 <Zeroth|work> I'm mostly just playing around now
13:36:23 <nmessenger> you need BOTH f 0 = 0 and f 1 = 1   >.>
13:36:38 <Zeroth|work> > let f 1 = 1; 0 = 0; x = f (x - 2) + (x - 1) in f 10
13:36:39 <lambdabot>   Non-exhaustive patterns in function f
13:36:42 <Zeroth|work> jeez
13:36:47 <Zeroth|work> > let f 1 = 1; f 0 = 0; f x = f (x - 2) + (x - 1) in f 10
13:36:49 <lambdabot>  25
13:36:57 <nmessenger> \o/
13:37:01 <narain> you're missing the second recursive call too
13:37:13 <narain> > let f 0 = 0; f 1 = 1; f x = f (x - 2) + f (x - 1) in f 10
13:37:14 <lambdabot>  55
13:37:16 <Zeroth|work> > let f 1 = 1; f 0 = 0; f x = f (x - 2) + f (x - 1) in f 10
13:37:17 <lambdabot>  55
13:37:20 <nmessenger> /o\
13:37:26 <nmessenger> \o/
13:37:48 * narain chuckles at nmessenger's gesticulations
13:37:55 <Zeroth|work> o/
13:38:04 <narain> \o
13:38:07 <Zeroth|work> heil?
13:38:45 * nmessenger pokes narain for showing off vocabulary
13:39:15 <Zeroth|work> > let f x 1 = 1; f x 0 = 0; f z x = f (x - 2 - z) + f (x - 1 - z) in f 10 20
13:39:16 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1 -> t
13:39:17 <lambdabot>     Probab...
13:45:18 <Zeroth|work> ok
13:45:26 <Zeroth|work> cant recall
13:45:45 <Zeroth|work> get the nth element of [1,2..]
13:46:06 <mauke> !!
13:46:16 <notsmack> f n = n
13:46:22 <Zeroth|work> aaah
13:46:47 * notsmack should have said id
13:46:48 <Zeroth|work> how about SET the n'th element?
13:46:57 <nmessenger> -- head (tail (tail (tail [0..5]))) -- also a bunch of tails
13:47:29 <fax> > !!
13:47:29 <lambdabot>  Parse error
13:47:30 <nmessenger> Zeroth|work: take the things before it, append the new elements, and append everything after it dropped
13:47:55 <nmessenger> > let xs = [1..10] in take 3 xs ++ [283] ++ drop 4 xs
13:47:56 <lambdabot>  [1,2,3,283,5,6,7,8,9,10]
13:48:03 <Zeroth|work> isnt there a simpler way?
13:48:17 <Lemmih> Zeroth|work: You usually don't wanna do it.
13:48:18 <Zeroth|work> liks a[]5 = 6; or something?
13:48:20 <nmessenger> Zeroth|work: it's not something that's done very often.
13:48:46 <nmessenger> map changes all the elements, and foldr transforms the whole list in a variety of ways
13:48:55 <fax> Zeroth|work: write a function to do it :S
13:49:53 <nmessenger> > let setAt i x xs = take i xs ++ x : drop (i+1) xs in setAt 3 283 [1..10]
13:49:55 <lambdabot>  [1,2,3,283,5,6,7,8,9,10]
13:50:16 <fax> > let f x = x x in f f
13:50:17 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
13:50:17 <lambdabot>     Probab...
13:50:26 <fax> :S
13:50:43 <Zeroth|work> how do I append an element?
13:50:44 <nmessenger> fax: no Y combinator for you!
13:50:46 <fax> how do you type it?
13:50:51 <nmessenger> (++)
13:50:53 <fax> nmessenger: I only want U !
13:50:58 <Zeroth|work> oh yeah
13:51:11 <fax> plz :D
13:52:00 <Zeroth|work> > let f x = x ++ 1 in f 10;
13:52:01 <lambdabot>  Parse error
13:52:05 * nmessenger chuckles at "I only want U!"
13:52:08 <nmessenger> We don't know each other that well yet :3
13:52:33 <mauke> > let f x = x ++ [1] in f [10]
13:52:34 <Zeroth|work> > let f x = (++) x 1 in f 10;
13:52:34 <lambdabot>  [10,1]
13:52:35 <lambdabot>  Parse error
13:52:50 <nmessenger> @type (++)
13:52:52 <Zeroth|work> > let f x = x ++ [1] in f [10];
13:52:52 <lambdabot> forall a. [a] -> [a] -> [a]
13:52:52 <lambdabot>  Parse error
13:52:54 <nmessenger> ^^ expects two lists
13:53:05 <Zeroth|work> > let f x = x ++ [1] in f [10]
13:53:07 <lambdabot>  [10,1]
13:53:38 <Zeroth|work> > let f x = x ++ ((x !! 1) + 2) in f [10]
13:53:39 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
13:53:40 <lambdabot>       Expected...
13:53:51 <Zeroth|work> > let f x = x ++ ((x !! 0) + 2) in f [10]
13:53:52 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
13:53:52 <lambdabot>       Expected...
13:54:14 <Zeroth|work> uhm
13:54:44 <Zeroth|work> > let f x = x ++ ([(x !! 0) + 2]) in f [10]
13:54:45 <lambdabot>  [10,12]
13:54:47 <Zeroth|work> yay
13:55:33 <Zeroth|work> length of a list?
13:55:40 <Zeroth|work> > length [4]
13:55:41 <lambdabot>  1
13:55:44 <Zeroth|work> sweet
13:55:58 <nmessenger> > length [1..]
13:56:02 <lambdabot> Terminated
13:56:20 <mauke> @hoogle [a] -> Int
13:56:21 <lambdabot> Prelude.length :: [a] -> Int
13:56:29 <Zeroth|work> > let f x = x ++ [(x !! (length-1)) + x] in f [1,1]
13:56:30 <lambdabot>  Couldn't match expected type `Int'
13:56:37 <mauke> @hoogle [a] -> Int -> a
13:56:38 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
13:56:42 <Zeroth|work> dont solve this one for me
13:57:21 <Zeroth|work> > let f x = x ++ [x !! (length-1 + x)] in f [1,1]
13:57:22 <lambdabot>  Couldn't match expected type `[a] -> Int'
13:57:39 <Zeroth|work> > let f x = x ++ [x !! ((length x) - 1 + x)] in f [1,1]
13:57:40 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
13:57:58 <Zeroth|work> > let f x = x ++ [(x !! ((length x) - 1)) + x)] in f [1,1]
13:57:58 <lambdabot>  Parse error
13:58:10 <LoganCapaldo> errm
13:58:12 <chessguy> what are you trying to do?
13:58:13 <Zeroth|work> hold
13:58:13 <nmessenger> /msg lambdabot if you want to play
13:58:17 <Zeroth|work> okay
13:58:20 <LoganCapaldo> how do you expect + x to ever work?
13:58:38 <Zeroth|work> just gimme a sec
14:00:15 * nmessenger has his client set up to /query lambdabot on connect :D
14:02:28 <chessguy> nmessenger, nice
14:02:53 * nmessenger wub LB <3
14:03:08 <chessguy> get a room!
14:03:10 <chessguy> oh, you have one
14:03:21 <kscaldef> I'm having difficulty figuring out how ghc is inferring a particular type conflict.  Is there some way to get it to tell me all the inferences it's made while trying to compile a statement?
14:03:25 <LoganCapaldo> nmessenger: Shouldn't you just have GOA at that point? :)
14:04:12 <kscaldef> or, when it tells me there's a type conflict in the second argument of foo to find out what it thinks the type of the third argument is?
14:04:29 <Igloo> What's the error?
14:04:42 <Igloo> Oh, the third
14:05:56 <LoganCapaldo> kscaldef: you could do let a1 = ...; let a2 = ...; let a3 = ...; foo a1 a2 a3. and use :type a3, etc. to ask about the args
14:06:46 * LoganCapaldo 's personal rule is when in doubt, give things names
14:07:56 <Zeroth|work> > let f x = x ++ [(x !! (length x - 1)) + (x !! (length x - 2))] in f [1,1]
14:07:57 <lambdabot>  [1,1,2]
14:08:11 <Zeroth|work> I'm having trouble making that recursive
14:08:24 <Zeroth|work> heh
14:09:07 <Zeroth|work> > let f x = x ++ [(x !! (length x - 1)) + (x !! (length x - 2))]; f x in f [1,1]
14:09:08 <lambdabot>  Parse error
14:09:12 <Zeroth|work> hah
14:09:34 <kscaldef> LoganCapaldo: hows that work in the middle of a function definition?
14:09:56 <nmessenger> > let f x = x ++ [(x !! (length x - 1)) + (x !! (length x - 2))] in iterate f [1,1] !! 30
14:09:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:09:56 <LoganCapaldo> > let f x = x ++ f [(x !! (length x - 1)] -- maybe?
14:09:59 <lambdabot>  Parse error
14:10:01 <narain> Zeroth|work: x !! (length x - 1)  is  last x
14:10:15 <Zeroth|work> narain, yeah, but I'm appending
14:10:43 <Zeroth|work> the append shoudl happen, and then the function shoud go again
14:11:01 <Zeroth|work> oh
14:11:05 <Zeroth|work> I see
14:11:15 <LoganCapaldo> kscaldef: break it into smaller functions so you can rewrite it like that?
14:11:23 <Zeroth|work> > let f x = x ++ [(x !! (last x) + (x !! (length x - 2))]; f x in f [1,1]
14:11:23 <lambdabot>  Parse error
14:11:35 <LoganCapaldo> If that's feasiable
14:11:36 <Zeroth|work> meh, I'll figure it out later
14:11:41 <Zeroth|work> time for me to go home. later guys
14:12:18 <kscaldef> I'm not sure it's feasible...
14:12:23 * kscaldef tries harder
14:14:03 <rahikkala> We have teleportation devices?
14:14:11 <LoganCapaldo> I mean I'm not offering up the "secret" to haskell debugging, just something that's worked for me in the past :)
14:14:36 <LoganCapaldo> In my admittedly limited experience
14:14:40 <narain> rahikkala: haskell weekly news, quotes of the week
14:14:56 * rahikkala reads
14:15:42 <narain> @src iterate
14:15:44 <lambdabot> iterate f x =  x : iterate f (f x)
14:16:07 <narain> @djinn (a -> a) -> a -> [a]
14:16:07 <lambdabot> -- f cannot be realized.
14:16:17 <narain> :t iterate
14:16:19 <lambdabot> forall a. (a -> a) -> a -> [a]
14:16:31 <narain> meh
14:21:22 <nburlett> query: is  f x = (p x) && (f (g x))  always tail recursive in Haskell?
14:21:31 <nburlett> (this is nrb23 in disguise)
14:22:34 <sjanssen> @source (&&)
14:22:34 <lambdabot> (&&) not available
14:22:39 <sjanssen> @source &&
14:22:39 <lambdabot> && not available
14:22:45 <LoganCapaldo> That's tail recursive period isn't it?
14:22:51 <LoganCapaldo> whether haskell or not
14:23:20 <bd_> @src (&&)
14:23:20 <lambdabot> True  && x = x
14:23:21 <lambdabot> False && _ = False
14:23:21 <nburlett> LoganCapaldo: depends on the language... C certainly won't remove the tail call on 99% of compilers
14:23:39 <sjanssen> nburlett: there is your answer
14:23:57 <LoganCapaldo> nburlett: asking if the compiler optimizes for tail recursive calls is different than asking if a function is tail recursive though
14:24:00 <LoganCapaldo> right?
14:24:01 <nburlett> bd_: yes, I tried that... but I wanted to make sure that that definintion given was gauranteed to be tail recursive
14:24:07 <nburlett> LoganCapaldo: true
14:24:35 <nburlett> LoganCapaldo: but in Scheme, the language itself makes such gaurantees
14:24:39 * LoganCapaldo switches off -fpendant
14:25:04 <nburlett> so the haskell compiler is gauranteed to avoid the stack in that sort of pattern match?
14:25:22 <sjanssen> nburlett: no, the Haskell spec allows for a compiler to be stupid
14:25:23 <bd_> nburlett: http://www.informatik.uni-bremen.de/~cxl/docs/haskell98-report/standard-prelude.html gives the semantics for && :)
14:25:26 <lambdabot> Title: The Haskell 98 Report: Standard Prelude, http://tinyurl.com/ywyu8w
14:25:47 <sjanssen> nburlett: but that code will work fine in ghc and hugs
14:26:02 <Saizan> is GLUT shipped with ghc?
14:26:12 <nburlett> sjanssen: thanks!
14:27:18 * nburlett goes back to doing actual work
14:28:15 <xerox> Saizan: yes, in the extras
14:29:32 <Saizan> xerox: seems that i miss the glut32.dll, is it normal?
14:29:47 <xerox> ndm may know?
14:38:17 <vincenz> @type ap
14:38:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:42:23 <jtza8> What would be the best route to learning haskell? Some knowlage of a lisp-like language, perhaps?
14:43:23 <rahikkala> Starting up ghci
14:43:39 <user317> jtza8, just start with haskell
14:43:41 <astrolabe> jtza8: Yeah, just dive in I reckon.  Find a good tutorial.
14:44:03 <notsmack> jtza8: heh, if you're gonna learn a language to learn haskell... make it haskell.
14:44:17 <jtza8> Ok, thanks...
14:44:30 <user317> jtza8, it helps if you have something that you really want done, even though your first implementation will be terrible you'll have some reason to laern and try to do things that you are used to in other langs
14:45:06 <Saizan> remember that the way to use parentheses is very different from the C-like languages
14:45:12 <psnl> @hoogle Double -> Int
14:45:12 <lambdabot> No matches, try a more general search
14:45:24 <jtza8> Would I get the ideas behind functional programming as I go along?
14:45:38 <rahikkala> @type floor
14:45:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:45:51 <astrolabe> jtza8: I think so.  I did.
14:46:07 <psnl> rahikkala: ta
14:46:31 <jtza8> Ok then, thanks to all for the advice.
14:47:14 <rahikkala> psnl: There's also truncate, round, and ceiling, use the appropriate one
15:01:46 <gly> How do I convert an Int to Double?
15:02:20 <bd_> gly: fromIntegral
15:02:26 <chessguy> ?hoogle fromIntegral
15:02:27 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
15:02:42 <chessguy> ?hoogle from
15:02:42 <lambdabot> Maybe.fromJust :: Maybe a -> a
15:02:42 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
15:02:42 <lambdabot> Numeric.fromRat :: RealFloat a => Rational -> a
15:02:51 <gly> oh, thanks :)
15:02:58 <chessguy> ?instances RealFloat
15:02:59 <lambdabot> Double, Float
15:07:40 <gly> http://tele-maskin.net/div/test.ps    , impressing what an Int->Double conversion can do ;)
15:22:27 <sorear> @users
15:22:27 <lambdabot> Maximum users seen in #haskell: 339, currently: 317 (93.5%), active: 42 (13.2%)
15:22:30 <sorear> hello.
15:28:11 <sorear> dons: awake?
15:32:32 <yip> man... the complexity of this program is getting out of hand :/
15:34:30 <sorear> which one?  OmegaGB?
15:35:14 <yip> no, a multiplayer "connect four" web game
15:35:46 <sorear> @tell dons I think @let's been fixed for us - http://haskell.org/pipermail/libraries/2007-March/006964.html
15:35:46 <lambdabot> Consider it noted.
15:36:16 <sorear> well, if you give up, call the informal association of #haskell obsessive refactorors
15:39:15 * Philippa wonders if n-player (n>2) connect four gets more interesting
15:39:24 <Philippa> I suspect it tends to result in an awful lot of draws
15:39:46 <Philippa> (2-player's solved, IIRC)
15:40:06 <yip> yeah, 2 player is solved
15:40:17 <yip> (start first and play in the middle column)
15:40:47 <yip> my problem is that the code is starting to baloon in size
15:41:02 <yip> i'm thinking of scraping it all and starting over with a better design
15:41:06 <LoganCapaldo> pop it! find a pin :)
15:41:41 <yip> even more annoying though is the tons of javascript i am writing :(
15:42:00 <sorear> yip: plan to throw one away.  You will, anyway.
15:42:24 <yip> well, both are required. the server is haskell, client is javascript
15:42:27 <sjanssen> yip: you said earlier you have to implement the game in both languages.  what sort of project is this?
15:42:28 * sorear agrees wholeheartedly with Brooks on the one
15:42:33 <sjanssen> ah
15:42:46 <sjanssen> it's too bad ycr2js isn't more mature
15:42:48 <yip> sjanssen: it's web-based
15:42:54 <sorear> oh, my quote was misinterpreted?
15:42:57 <yip> yeah that would be really sweet
15:43:19 <sorear> there's a javascript dsl out there
15:43:26 <sjanssen> I have a theory that a Haskell -> JS converter would make for some very neat ajax applications
15:43:42 <TuringTest> sorear: What was your problem with regex-* ?  (I wrote the code...)
15:43:48 <yip> sjanssen: such a converter would definitely cut down development time
15:44:38 <sorear> TuringTest: actually we're not sure what was the problem.  dons blames it on regex-foo, and every call to last in our code is obviously correct.
15:44:41 <sorear> @let x = 2
15:44:44 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
15:44:52 <yip> i have a version of the game just barely working, including full chat support. but adding in all of the rest of the details is killing me :(
15:45:09 <sorear> chat support!? in a connect 4 game!?
15:45:18 <TuringTest> sorear: Odd...Which regex-* backend is it using?
15:45:24 <sorear> methinks games today are too sophisticated
15:45:28 <yip> sorear: yeah, haven't you seen my haskell chat webapp already?
15:45:31 <sorear> TuringTest: -posix
15:46:36 <TuringTest> sorear: Thanks for the bug report -- I think I see the problem already...fixing....
15:47:10 <sorear> TuringTest: oh?  you mean we should have reported this a few weeks ago? :)
15:47:17 <sorear> that's an old breakage
15:47:22 <Zeroth404> I've almost got it
15:47:25 <Zeroth404> > let f x = (x ++ [x !! (length x - 1) + x !! (length x - 2)]) ++ (f x) in f [1,1]
15:47:26 <lambdabot>  [1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1...
15:47:30 <sorear> your ml post was a glimmer of long-lost hope
15:47:34 <Zeroth404> I know whats wrong thouhg
15:47:41 <TuringTest> sorear: I was ... not careful enough while being clever about something else...
15:47:57 <sorear> > cycle [1,1,2]  -- much simpler
15:47:58 <lambdabot>  [1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1...
15:48:03 <Zeroth404> haha not what I want
15:48:05 <Zeroth404> hold up
15:48:07 <Philippa> sorear: in practice these days people expect chat and lobby facilities built into multiplayer games
15:48:23 <Philippa> or else supplied by a general system with the game bolting a UI on the front
15:48:49 <TuringTest> sorear: I was testing the  ByteString.last against (0 :: Word8) to see if I could unsafeUseAsCString....
15:48:55 <sorear> I like sit-around-a-table card games.  You get chat with 0 implementation cost.
15:49:05 <chessguy> ?hoogle bolt
15:49:05 <lambdabot> No matches found
15:49:07 <Philippa> sure
15:49:09 <Zeroth404> let f x = x !! f (x ++ [x !! (length x - 1) + x !! (length x - 2)]) in f [1,1]
15:49:13 <sorear> @jargon bolt
15:49:15 <lambdabot> No match for "bolt".
15:49:15 <Zeroth404> stack overflow
15:49:21 <yip> Philippa: my connect four game works in tournament mode :) so the winner keeps playing as other players step up, while in the mean time they wait in a queue and spectate the current game
15:49:25 <Zeroth404> > let f x = x !! f (x ++ [x !! (length x - 1) + x !! (length x - 2)]) in f [1,1]
15:49:29 <lambdabot> Terminated
15:49:37 <yip> Philippa: and everything runs in a normal webbrowser with no plugins required
15:49:48 <Zeroth404> I want what it ends up with when it terminates
15:49:57 <chessguy> yip, what web technology does it use?
15:50:12 <Zeroth404> someone do the fibonacci sequence
15:50:25 <sorear> > fix((1:).scanl(+)1)
15:50:27 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:50:43 <yip> chessguy: it's custom server software that i wrote in haskell
15:50:49 <chessguy> yip, nice
15:50:51 <sorear> yip: just use happs :)
15:50:55 <yip> for those who haven't seen the chat example web-app, you can join me right now:
15:50:59 <yip> http://feld.sh.nu:2000/
15:51:05 <Zeroth404> is there a way to test for the LAST element of a list?
15:51:11 <resiak> > last [1..5]
15:51:12 <lambdabot>  5
15:51:17 <Zeroth404> ah
15:51:55 <sorear> Zeroth404: be careful, some lists don't have a last element
15:51:56 <Lemmih> yip: You're from Niue?
15:52:08 <yip> Lemmih: what's that?
15:52:10 <Zeroth404> sorear: thats for later...
15:52:19 <sorear> Zeroth404: TuringTest spaced on that, breaking @let
15:52:36 <Zeroth404> > let f ((last x) == 10946)) = 1; f x = (x ++ [x !! (length x - 1) + x !! (length x - 2)]) in f [1,1]
15:52:36 <lambdabot>  Parse error
15:52:38 <Zeroth404> hah
15:52:52 <Lemmih> yip: Maybe not.
15:52:54 <sorear> yip: there's remarkably little activity on your chat website.
15:53:05 <sorear> yip: if this is wrong ... add <noscript>
15:53:34 <resiak> Zeroth404: are you looking for ' let fibs = 1:1:zipWith (+) fibs (tail fibs) ' ?
15:53:37 <chessguy> ?where happs
15:53:37 <lambdabot> http://happs.org
15:53:47 <Zeroth404> > let f [1..10946] = 1;f x = (x ++ [x !! (length x - 1) + x !! (length x - 2)]) in f [1,1]
15:53:47 <lambdabot>  Parse error in pattern
15:54:01 <Zeroth404> resiak: I dont know what zipwidth is
15:54:11 <Zeroth404> I just need to end my infinite loop sometime
15:54:19 <Zeroth404> so I can get the answer
15:54:58 <chessguy> Zeroth404, what answer are you looking for?
15:55:08 <Zeroth404> fibonacci
15:55:27 <chessguy> fibonacci is an infinite sequence
15:55:29 <Zeroth404> isn't that obvious?
15:55:33 <augustss> > let f x = (x ++ [x !! (length x - 1) + x !! (length x - 2)]) in f [1,1]
15:55:35 <lambdabot>  [1,1,2]
15:55:36 <Zeroth404> I know, which is why I need it to end...
15:55:42 <Zeroth404> like with let f [1..10946] = 1;
15:55:52 <Zeroth404> 10946 is a valid fibonacci number
15:55:58 <sjanssen> Zeroth404: use takeWhile
15:56:00 <sorear> I love the way haskell-cafe gives me more email than the world's spammers combined :)
15:56:05 <resiak> > let f | last x == 10945 = 1 | otherwise = (x ++ [last x + x !! (length x - 2)]) in f [1,1]
15:56:05 <Zeroth404> sjanssen: define
15:56:06 <lambdabot>   Not in scope: `x'
15:56:08 <augustss> > let f x = (x ++ [x !! (length x - 1) + x !! (length x - 2)]) in iterate f [1,1]
15:56:09 <lambdabot>  [[1,1],[1,1,2],[1,1,2,3],[1,1,2,3,5],[1,1,2,3,5,8],[1,1,2,3,5,8,13],[1,1,2,3...
15:56:12 <resiak> bleh.
15:56:12 <sorear> > takeWhile (<1000) $ fix((1:).scanl(+)1)
15:56:13 <sjanssen> > takeWhile (< 4) [1..10]
15:56:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987]
15:56:15 <lambdabot>  [1,2,3]
15:56:16 <resiak> > let f x | last x == 10945 = 1 | otherwise = (x ++ [last x + x !! (length x - 2)]) in f [1,1]
15:56:16 <lambdabot>   add an instance declaration for (Num [t])
15:56:17 <lambdabot>     In the expression:
15:56:17 <lambdabot>         le...
15:56:23 <resiak> I have no idea what you were trying to do, though
15:56:25 <chessguy> > let fibs = 1 : 1 : zipWith (+) fibs (tailFibs) in fibs !! 100
15:56:26 <lambdabot>   Not in scope: `tailFibs'
15:56:29 <Zeroth404> slow down now
15:56:31 <chessguy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
15:56:33 <lambdabot>  573147844013817084101
15:57:07 <augustss> Zeroth404: as you can see, you f only adds one more fibonacci number to a list
15:57:25 <Zeroth404> augustss: yeah
15:57:45 <augustss> but iterate keeps applying it
15:58:04 <augustss> > let f x = (x ++ [x !! (length x - 1) + x !! (length x - 2)]) in iterate f [1,1] !! 20
15:58:06 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:58:24 <augustss> > let f x = (x ++ [x !! (length x - 1) + x !! (length x - 2)]) in last (iterate f [1,1] !! 20)
15:58:25 <lambdabot>  17711
15:58:31 <dons> morning all
15:58:32 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:58:42 <Pseudonym> G'day.
15:58:53 <TuringTest> dons and sorear: I am building regex-posix and regex-pcre with the fixes for ByteString.last ... sorry about the bug....
15:59:05 <TuringTest> hi dons
15:59:19 <augustss> hello dons
15:59:23 <chessguy> hi dons
15:59:36 <sorear> hi dons!
15:59:58 <sorear> how's worldchanging?
16:00:33 <dons> TuringTest: ah ha!
16:00:34 <augustss> The world changes earlier in Australia, it's closer to the dateline
16:00:37 <dons> it was you!
16:00:50 <Zeroth404> why does this not work:
16:00:53 <Zeroth404> >  let f x = if ((last x) == 10946) then 1 else (x ++ [x !! (length x - 1) + x !! (length x - 2)]); in f [1,1]
16:00:54 <lambdabot>   add an instance declaration for (Num [t])
16:00:54 <lambdabot>     In the expression:
16:00:54 <lambdabot>         le...
16:01:15 <Zeroth404> arr
16:01:17 <TuringTest> dons: I was checking the last item to see if it was zero and thus unsafeUseAsCString would be okay....
16:01:20 <sorear> > let f x = (x ++ [sum x]) in last (iterate f [1,1] !! 20) -- Zeroth404 : alg id's make this much simpler
16:01:20 <Zeroth404> its not recursive
16:01:21 <lambdabot>  1048576
16:01:21 <augustss> Zeroth404: because there is no recursive call to f
16:01:31 <dons> TuringTest: ah ok.
16:01:36 <dons> which failed on empty lists, yeah?
16:01:44 * Zeroth404 goes back to the drawing board
16:02:56 <augustss> Zeroth404: it's close
16:02:58 <sorear> @users
16:02:59 <lambdabot> Maximum users seen in #haskell: 339, currently: 312 (92.0%), active: 44 (14.1%)
16:03:33 <augustss> >  let f x = if ((last x) == 10946) then [1] else f (x ++ [x !! (length x - 1) + x !! (length x - 2)]); in f [1,1]
16:03:34 <lambdabot>  [1]
16:03:48 <augustss> but it doesn't compute fibonacci :)
16:03:48 <Zeroth404> I'm on to something here:
16:03:52 <Zeroth404> > let f x = if ((last x) == 10946) then 1 else (f [x !! (length x - 1) + x !! (length x - 2)]) in f [1,1]
16:03:53 <lambdabot>  Exception: Prelude.(!!): negative index
16:04:01 <Zeroth404> where is a negative index?
16:04:26 <augustss> the recursive call is on a list with only one argument
16:04:36 <augustss> element, i mean
16:04:48 <Zeroth404> when does it ever have less than 2?
16:05:01 <TuringTest> dons and sorear: I have pushed a darcs version of regex-posix, up to version 0.92 now -- will be on Hackage in a minute.  Also fixing regex-pcre for similar bug (new version will be 0.92 in a few minutes)
16:05:03 <augustss> else f [...]
16:05:07 <Igloo> Do you mean , where you ahve +?
16:05:15 <Zeroth404> hold
16:05:47 <augustss> Zeroth404: but you algorithm is pretty crazy even if you get it to work :)
16:06:06 <Zeroth404> augustss: I'm not one to give up ;-)
16:06:14 <augustss> good!
16:06:36 <augustss> you could stick the new element at the front instead.  more efficient
16:07:34 <dcoutts> sjanssen, it should be pretty easy to make a fusible base64 function and thus make it work for lists, bytestring whatever
16:07:39 <dons> TuringTest: great.
16:08:15 <sorear> dons: how much work is there on preventing excessive fusion?  if you have two loops on lazy bytestrings, each almost the size of the L1 insn cache, I imaging fusing them would be a major loss.
16:08:22 <Cale> What is it with all the railing against PDF? It's a fine document format!
16:09:23 <sorear> it's ten times better than every alternative I've seen, except for LaTeX/Docbook
16:09:24 <TuringTest> Cale: Where ? On L-T-U ?
16:09:50 <sorear> done well (big qualification) html also usually beats pdf
16:10:39 <sorear> but eg. pdf unconditionally beats ps, jpeg, plaintext, etc
16:10:43 <mgsloan> what's with hashtable's IOness?
16:10:56 <sorear> mgsloan: it's bogus. it ought to be in ST.
16:10:59 <TuringTest> mgsloan: It overwrites the old version using mutable state
16:11:04 <sorear> mgsloan: you think it should be pure?
16:11:09 <mgsloan> yes
16:11:28 <sjanssen> dcoutts: I'm not sure how to do it efficiently.  The usual method is to turn 3 octets into 4, how do you do that in streams?
16:11:28 <sorear> mgsloan: a hashtable has O(1) update because, after an update, the old table simply no longer exists.
16:11:29 <mgsloan> well, or at least I want an inefficient version that captures the same idea
16:11:33 <dons> sorear: why would that be a loss? the data isn't duplicated, you just do more cpu cycles on each loop
16:11:51 <dons> or, you're thinking about the input buffer and the output buffer?
16:11:54 <sorear> dons: because you have to fetch the loop from ram every time
16:11:54 <dcoutts> sjanssen, a Stream function with non-trivial state
16:12:04 <sorear> dons: I'm talking icache here
16:12:18 <dons> i haven't seen any effect from increasing the size of the loop body
16:12:38 <dons> its an interesting idea though
16:12:43 <sorear> dons: whereas with unfused lazy bytestrings, the ip stays local 16k at a time...
16:12:56 <Zeroth404> SUCCESS!
16:13:00 <Zeroth404> > let f x = if ((last x) == 10946) then x else ( f (x ++ [x !! (length x - 1) + x !! (length x - 2)]) ) in f [1,1]
16:13:02 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946]
16:13:09 <sorear> dons: it wouldn't affect small loops, where small is a CPU-dependent number ranging from 16 to 64K insns
16:13:12 <dcoutts> sjanssen, eg make a state data type that encodes the various states you go through
16:13:13 * Zeroth404 humps the air
16:13:16 <mgsloan> oooh, I want a map not a hashtable
16:13:19 <dons> i'd be interested in a real example
16:13:30 <dcoutts> sjanssen, one could do UTF8 en/decoding the same way
16:13:33 <sorear> dons: I don't have one :)  just an Idea
16:13:45 <Cale> TuringTest: reddit
16:13:55 <Cale> and well, various places
16:13:56 <augustss> Zeroth404: good going!
16:14:09 <dcoutts> sjanssen, I should do a demo of one of these some time, ping me tomorrow and I'll add one to the new stream module I'm doing.
16:14:26 <Zeroth404> augustss: sadly, it's not that great of an algorythm, but it works
16:14:30 <sjanssen> dcoutts: okay
16:14:41 <Zeroth404> > let f x = if ((last x) == 10946) then x else ( f (x ++ [x !! (length x - 1) + x !! (length x - 2)]) ) in f [1,6]
16:14:44 <lambdabot> Terminated
16:14:49 <Zeroth404> heh
16:14:50 <Philippa> sorear: I have purposes for which plaintext potentially beats PDF...
16:15:33 <Philippa> largely because PDF is overspecification for many purposes
16:17:00 <sorear> Philippa: plaintext is like bitmaps for me. As a user of a character-cell terminal, I can view plaintext fairly easily, but it always looks terrible.  80 wide, 166 wide, 72 wide ... none of it is properly compatible with my 128 wide monitor.  HTML wraps.
16:17:14 <sorear> (and doesn't lose it's formatting the the process)
16:17:15 <Zeroth404> Is there any way to get the value out of a function before it terminates because of a stack overflow or similar?
16:17:24 <sorear> sure, use laziness
16:17:32 <sorear> head (1:_|_) == 1
16:17:39 <sorear> er, non-strictness
16:17:46 <Zeroth404> sorear: you talkin to me?
16:17:48 <Philippa> sorear: there're ways to interpret plaintext that wrap properly
16:18:40 <sorear> Philippa: I'd be very interested to see your non-uglifying rewrap algorithm.
16:19:39 <Zeroth404> ping
16:20:06 <resiak> destination host unreachable!
16:20:08 <sorear> Zeroth404: I was talking to both you and phillipa
16:20:19 <sorear> <sorear> sure, use laziness  -- Zeroth404
16:20:19 <sorear> <sorear> head (1:_|_) == 1
16:20:19 <sorear> <sorear> er, non-strictness
16:20:21 <Zeroth404> sorear: I dont really follow then
16:20:48 <Philippa> sorear: it does constitute a very lightweight format on top of plaintext, but I'm thinking the one standardised as format=flowed in MIME
16:20:53 <sorear> > (let f x = 1 + f (x + 1) in f 0)
16:20:57 <lambdabot> Terminated
16:21:21 * sorear curses the strictness analyser!
16:21:29 <Philippa> note that no plaintext is /invalid/ format=flowed text, it's just that some won't get much rewrapping
16:21:38 <sorear> > (foldr (+) 0 [0..])
16:21:40 <lambdabot>  Exception: stack overflow
16:21:44 <sorear> > 1 : (foldr (+) 0 [0..])
16:21:46 <lambdabot>   add an instance declaration for (Num [t])
16:21:46 <lambdabot>     In the expression: 0
16:21:56 <Zeroth404> sorear: problems?
16:21:56 <sorear> > 1 : [foldr (+) 0 [0..]]
16:21:58 <lambdabot>  Exception: stack overflow
16:22:03 <sorear> > head (1 : [foldr (+) 0 [0..]])
16:22:04 <lambdabot>  1
16:22:20 <Zeroth404> hmm
16:22:27 <sorear> as you see, haskell's laziness allowed us to ignore the fact that part of the computation failed
16:22:28 <Zeroth404> tail (1 : [foldr (+) 0 [0..]])
16:22:30 <Zeroth404> > tail (1 : [foldr (+) 0 [0..]])
16:22:33 <lambdabot>  Exception: stack overflow
16:22:40 <Zeroth404> what I want is the tail
16:22:58 <sorear> well, that's the part that failed, sorry :)
16:23:15 <Zeroth404> I'll just flip it around then
16:23:20 <gvdm_other> see, what you have there is an infinite data set. infinite data sets on finite computers, think it over
16:23:42 <Zeroth404> you can trash the beginning data
16:23:51 <Zeroth404> but that wont save the stack
16:24:00 <sorear> quick! what's the last fibonacci number!
16:24:05 <Zeroth404> heh
16:24:06 <Zeroth404> zero?
16:24:15 <Zeroth404> zero == infinity;
16:24:37 <gvdm_other> see, one of those is a number, the other. a concept
16:24:39 <sorear> Sadly, Haskell today does not support infinity.
16:24:49 <Zeroth404> gvdm_other: actually, zero is a concept as well :-)
16:24:57 <mgsloan> bah! hashtable and map's insert function does exactly the same thing, but the params are in a different order
16:24:58 <Zeroth404> technically, all numbers are concepts...
16:25:11 <sorear> gvdm_other: hey! aleph-null is a perfectly good number!
16:25:12 <Zeroth404> unless you're talking sacred geometry
16:25:18 <gvdm_other> fine, but infinity is not a number
16:25:23 <Zeroth404> but thats another story
16:25:29 <Zeroth404> infinity = 0
16:25:37 <gvdm_other> tell me where it goes on the number line
16:25:56 <Zeroth404> 0 is commonly used to represent infinity, as well as the sidewasy 8 lookin thing
16:26:02 <sorear> > (1.0/ 0.0) == (0.0/0.0)  -- gvdm_other, lambdabot knows you are wrong about "infinity is not a number"
16:26:02 <gvdm_other> i know where zero goes, but try as you might you won't convince me that that is where infinity lies
16:26:03 <lambdabot>  False
16:26:06 <Zeroth404> an O or 0 is a loop, follow it around and around, it never ends
16:26:24 <Zeroth404> gvdm_other: infinity belongs with zero more than any other number
16:26:30 <Zeroth404> because its representable
16:27:06 <sorear> Haskell would be a MUCH nicer language if we used an infinity-supporting integer rep.
16:27:15 <Philippa> gvdm_other: infinity is not a natural number, nor a real. That doesn't mean that there aren't classes of numbers that include it
16:27:27 <Philippa> or rather, that include one or more infinities. There's an, uh, infinite number of them
16:27:37 <sorear> for a start, the false dichotomy between replicating and repeating will disappear
16:27:39 <Zeroth404> > let f x = if ((first x) == 10946) then 1 else ( f ([x !! (length x - 2) + x !! (length x - 1)] ++ x) ) in f [1,1]
16:27:40 <lambdabot>  Couldn't match expected type `[]' against inferred type `a b'
16:27:43 <Zeroth404> ?
16:28:05 <Zeroth404> crap
16:28:25 <Zeroth404> > let f x = if ((first x) == 10946) then 1 else ( f ([x !! 0 + x !! 1] ++ x) ) in f [1,1]
16:28:27 <lambdabot>  Couldn't match expected type `[]' against inferred type `a b'
16:28:30 <chessguy> don't suppose anyone here has any experience mucking around with eclipse
16:30:16 <Zeroth404> > let f x = if ((first x) == 10946) then 1 else ( f ([(x !! 0) + (x !! 1)] ++ x) ) in f [1,1]
16:30:17 <lambdabot>  Couldn't match expected type `[]' against inferred type `a b'
16:30:37 <Zeroth404> whats that mean?
16:30:51 <LordBrain> sorear, what does the infinity have to do with replicate verses repeat?
16:31:13 <LordBrain> oh i see what you are saying
16:31:19 <mgsloan> an even tougher infinity is the one that has to do with infinite detail
16:31:24 <LordBrain> like replicate inf x
16:31:34 <yip> can forkIO ever return a ThreadId that is equal to one previously returned?
16:31:54 <mgsloan> eg, length of the edge of a mandelbrot thingamabob, or all the rationals, worse yet, the reals, from 0 to 1
16:32:15 * mgsloan leaves with that
16:32:22 <LordBrain> yip, is that an implementation question or a language question?
16:32:38 <TuringTest> yip: Depends on ThreadID of implementation...I think GHC is fairly safe in this regard
16:32:42 <Zeroth404> > let f (x:xs) = if (x == 10946) then x else ( f ([x + (xs !! 0)] ++ x:xs) ) in f [1,1]
16:32:44 <lambdabot>  10946
16:32:50 <Zeroth404> okay, I flipped it around
16:32:55 <Zeroth404> > let f (x:xs) = if (x == 10946) then x:xs else ( f ([x + (xs !! 0)] ++ x:xs) ) in f [1,1]
16:32:57 <lambdabot>  [10946,6765,4181,2584,1597,987,610,377,233,144,89,55,34,21,13,8,5,3,2,1,1]
16:33:01 <yip> hm....
16:33:06 <Zeroth404> now I can grab the head
16:33:41 <Zeroth404> > head (1 : [foldr (+) 0 [0..]])
16:33:42 <lambdabot>  1
16:35:44 <Zeroth404> > let f (x:xs) = f ([x + (xs !! 0)] ++ x:xs) in head( f [1,1])
16:35:48 <lambdabot> Terminated
16:35:51 <Zeroth404> damn
16:36:03 <Zeroth404> sorear: explain why that didn'twork
16:36:36 <TuringTest> dons: And I have also pushed new "stable" versions of regex-posix-0.72 and regex-pcre-0.81 to http://darcs.haskell.org/packages/
16:36:38 <lambdabot> Title: Index of /packages
16:37:31 <dons> great.
16:37:39 <dons> i'll give them a whirl on lambdabot then, shall I?
16:38:09 <Zeroth404> sorear: ?
16:38:39 <TuringTest> dons: If you can, then you might jump to the Lazy ByteString supporting unstable versions under  http://darcs.haskell.org/packages/regex-unstable/
16:38:40 <lambdabot> Title: Index of /packages/regex-unstable
16:38:43 <Zeroth404> > head( f [1,1]) where f (x:xs) = f ([x + (xs !! 0)] ++ x:xs)
16:38:44 <lambdabot>  Parse error
16:38:55 <sorear> the old list is made to depend on the recursion, because you did it tail recursively
16:39:10 <Zeroth404> theres no parse error
16:39:14 <Zeroth404> > head( f [1,1]) where f (x:xs) = f ([x + (xs !! 0)] ++ x:xs)
16:39:14 <lambdabot>  Parse error
16:39:20 <TuringTest> dons: The unstable versions have also been bugfixed for this issue
16:39:27 <Zeroth404> it works in hugs just fine...sept for a garbage collection thing
16:39:40 <Lemmih> Zeroth404: You can't have a 'where' in that location.
16:39:41 <TuringTest> dons: I will sign off now and go to bed
16:39:51 <TuringTest> sorear: Thanks for the bug report!  Good night.
16:40:06 <Zeroth404> Lemmih: why? it works in hugs...
16:40:16 <dons> ok. thanks TuringTest
16:40:58 <dcoutts> Igloo, I've got another minor Haskell' list lib strictness proposal, though I may end up with several more. Perhaps I should ask SyntaxNinja for a Haskell' trac account.
16:41:24 <Lemmih> Zeroth404: hugs is broken.
16:41:30 <Zeroth404> heh
16:41:42 <sorear> lambdabot uses GHC
16:41:47 <dcoutts> Igloo, I'm going to try to use quick check to compare the strictness properties of the H98 list spec with other impls, my own the standard ghc one, the streams version etc.
16:41:50 <Zeroth404> sounds like lambdabot is broken...
16:41:57 <Zeroth404> the code worked just like I expected
16:42:04 <Zeroth404> hmm
16:42:17 <hpaste>  chessguy annotated "massive error" with "(no title)" at http://hpaste.org/805#a1
16:42:24 <Lemmih> Zeroth404: (x where x = 10) isn't an expression.
16:42:27 <dons> you can't use 'where' clauses in expressions. lambdabot accepts only expressions
16:42:37 <sorear> Zeroth404: it wouldn't be lambdabot's fault - virtually all the work is delegated to ghc -O2 --make
16:42:38 <chessguy> ack
16:42:44 <chessguy> i didn't mean to announce that, sorry
16:43:10 <Zeroth404> > f x where f x = x*2
16:43:11 <lambdabot>  Parse error
16:43:22 <Zeroth404> > f 2 where f x = x*2
16:43:23 <Lemmih> sorear: Actually the code isn't given to GHC. Lambabot parsed it before passing it on.
16:43:23 <lambdabot>  Parse error
16:44:07 <sorear> Lemmih: I thought he was referring to a semantic error (stack overflow v. no stack overflow), oops.
16:44:54 <Zeroth404> okay...what I really want is to calculate fibonacci until the stack overflows or something else blows up, and then spit out the last calculated number....
16:45:04 <Zeroth404> or all up until that point, would be nice
16:45:21 <Zeroth404> would have to do that in hugs
16:45:28 <gvdm_other> Zeroth404: go read up on the exception monad
16:45:31 <sorear> Zeroth404: you can't do that in haskel, the exception support isn't good enough
16:45:35 <sorear> directly
16:45:42 <Zeroth404> I'll just keep reading then
16:45:44 <sorear> @index popen
16:45:45 <lambdabot> bzzt
16:45:53 <Zeroth404> definitley a fun language
16:47:05 <Zeroth404> how do I invoke ghc as an interpreter?
16:47:11 <dibblego> ghci
16:47:21 <resiak> A
16:49:56 <dons> sorear: hmm?
16:50:08 <dons> you'd fork a thread, have it write values one at a time into an MVar till it blows up
16:50:14 <dons> the main thread then takes the last number written
16:50:40 <sorear> heh
16:50:56 <Lemmih> SamB: ping.
16:51:03 <sorear> I (mis)remembered that GHC buggily kills the whole program on blowup
16:51:04 <SamB> hello
16:51:05 <dons> seriously, that's how you do this kind of thing. we use it all the time in the ICFP contest, when you have hard time limits on everything
16:51:13 <SamB> am I wasting your RAM and/or disk space?
16:51:23 <dons> but yet you need to caculate moves as best as you can in the given time
16:51:30 <Lemmih> SamB: Yeah, 150megs of ram.
16:52:30 <chessguy> sigh. if only #eclipse was as helpful as #haskell
16:52:42 * SamB wonders if a UM that compressed not-recently-used arrays would be a good idea
16:52:47 <sorear> dons: well time limits are easy.  heap overflow is much harder.  eg the GNU HURD documentation advises as much swap as possible because OOM is a unavoidable kernal panic.
16:53:40 <sorear> or at least it did when I read it ~1 yr ago
16:53:59 <SamB> Lemmih: okay I killed it
16:54:05 <jcreigh> what? the hurd just dies if it runs out of memory?
16:54:07 <Lemmih> SamB: Thanks.
16:54:53 <dons> heap overflow would be hard, yes.
16:55:07 <chessguy> Lemmih++ thanks for the server space, my code is coming along nicely
16:55:27 <Lemmih> chessguy: Yay.
16:55:51 <sorear> jcreigh: that's what I've read, yes.
16:56:17 <sorear> jcreigh: so you add enough swap that you hopefully notice while it's still merely thrashing
16:58:02 <jcreigh> hmm, on Linux I've taken the opposite tack: Deliberately setting the swap space a little low so that if they're some runaway memory eating process, the OOM killer will get it instead of really making the system thrash. (This is a desktop; I don't know if I'd do the same on a server)
16:58:33 <sorear> for a while I actually ran with no swap at all
16:58:40 <sorear> it doesn't hurt much
16:58:56 <sorear> available RAM grows much faster than kernel bloat
16:59:11 <sorear> <-- 384 total, 20 used at almost any given time
16:59:27 <sorear> jhc and darcs being the major exceptions
16:59:57 <jcreigh> I have 256. The mozilla foundation makes sure that most of that stays used.
17:00:07 <SamB> sorear: if I didn't know you didn't use firefox already, I'd know now
17:00:10 <fantasma> @type unfoldr
17:00:13 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:00:20 <pejo> jcreigh, are you talking about desktop use now, or for systems in general? (regarding that dimensioning of swap).
17:00:32 <sorear>           system thrash. (This is a desktop; I don't know if I'd do the same on
17:00:32 <sorear>           a server)                                                       [16:54]
17:00:32 <sorear>  
17:00:36 <fantasma> @src unfoldr
17:00:36 <lambdabot> unfoldr f b  = case f b of
17:00:36 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
17:00:36 <lambdabot>    Nothing        -> []
17:00:43 <sorear> pejo: ^^^
17:01:18 <glen_quagmire> is haskell better than common lisp? people say CL is the last language you graduate into.
17:01:26 <pejo> sorear, doh.
17:01:38 * sorear smells a troll
17:01:46 <fantasma> me too
17:02:08 <jcreigh> pejo: well, I'm talking about a desktop; but I think that, in general, there's no point in having so much swap space, that, if it were ever 100% used, the system would be thrashing badly. But I've never been able to nail down a hard and fast rule as to how much is "too much"
17:02:30 <fantasma> > unfoldr [1,2,3,4,5]
17:02:31 <lambdabot>  Couldn't match expected type `b -> Maybe (a, b)'
17:02:44 <pejo> jcreigh, I'm more against killing large apps - since that will kill the computation that has been running for a couple of weeks and take several gigs of ram.
17:03:26 <fantasma> > unfoldr (+) [1..10]
17:03:27 <lambdabot>  Couldn't match expected type `Maybe (a, b)'
17:03:40 <fantasma> @type Maybe (a, b)
17:03:42 <lambdabot> Not in scope: data constructor `Maybe'
17:03:43 <lambdabot>  
17:03:43 <lambdabot> <interactive>:1:7: Not in scope: `a'
17:03:50 <fantasma> ?type Maybe (a, b)
17:03:52 <lambdabot> Not in scope: data constructor `Maybe'
17:03:52 <lambdabot>  
17:03:52 <lambdabot> <interactive>:1:7: Not in scope: `a'
17:04:00 <jcreigh> fantasma: Maybe (a, b) *is* a type!
17:04:03 <sorear> @kind Maybe (a, b) -- use kind for types
17:04:05 <lambdabot> Not in scope: type variable `a'
17:04:05 <lambdabot>  
17:04:05 <lambdabot> <interactive>:1:10: Not in scope: type variable `b'
17:04:15 <fantasma> what kind of type is it?
17:04:16 <sorear> @kind Maybe
17:04:18 <lambdabot> * -> *
17:04:20 <jcreigh> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Aunfoldr
17:04:22 <lambdabot> http://tinyurl.com/yhrw65
17:04:23 <sorear> @kind Maybe (Int, Int(
17:04:26 <lambdabot> parse error (possibly incorrect indentation)
17:04:26 <sorear> @kind Maybe (Int, Int)
17:04:27 <jcreigh> fantasma: ^^
17:04:27 <LoganCapaldo> > unfoldr (\x -> Just (x + 1, x + 1)) [1..10]
17:04:30 <lambdabot>   add an instance declaration for (Num [t])
17:04:30 <lambdabot>     In the expression: x + 1
17:04:30 <lambdabot> *
17:04:41 <LoganCapaldo> oops :)
17:04:49 <fantasma> * as in anything?
17:04:58 * LoganCapaldo can never remember how unforldr works
17:05:03 <sorear> fantasma: this is not miranda :)
17:05:12 <yip> anyone wanna take a look at a simple STM timeout system i've made?
17:05:27 <sorear> fantasma: we use varids for parametric vars, not sequences of stars
17:05:30 <jcreigh> > unfoldr (\n -> if n < 10 then (n, n+1) else Nothing) 0
17:05:31 <lambdabot>  Couldn't match expected type `Maybe (a, b)'
17:05:47 <jcreigh> > unfoldr (\n -> if n < 10 then Just (n, n+1) else Nothing) 0
17:05:48 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
17:05:57 <fantasma> nice
17:06:13 <fantasma> @type Just
17:06:16 <lambdabot> forall a. a -> Maybe a
17:06:25 <hpaste>  yip pasted "simple STM timeout system" at http://hpaste.org/806
17:06:25 <fantasma> @src just
17:06:26 <lambdabot> Source not found. You speak an infinite deal of nothing
17:06:33 <LoganCapaldo> @src Maybe
17:06:34 <lambdabot> data Maybe a = Nothing | Just a
17:06:46 <fantasma> @type Nothing
17:06:48 <lambdabot> forall a. Maybe a
17:07:06 <fantasma> > Nothing
17:07:07 <lambdabot>  Nothing
17:07:19 <fantasma> > Nothing + 1
17:07:20 <lambdabot>   add an instance declaration for (Num (Maybe a))
17:07:20 <lambdabot>     In the expression: Noth...
17:07:43 <fantasma> > Just Nothing
17:07:45 <lambdabot>  Just Nothing
17:07:50 <Terabyte> Hey, haskell is a functional language right? Certainly not a procedural language .. but is it a declarative language? (What's the difference could sombody clarify)
17:07:50 <fantasma> :)
17:08:16 <jcreigh> Terabyte: I would call it a functional programming language.
17:08:34 <LoganCapaldo> Terabyte: declarative means you say "what" you want, as opposed to "how"
17:08:35 <Terabyte> not a declarative language?
17:08:47 <Terabyte> oh rite
17:08:51 <lucca> > Just Just Just Just Nothing
17:08:52 <lambdabot>  Couldn't match expected type `(a -> Maybe a)
17:09:05 <jcreigh> Terabyte: I'm not really sure what you mean by "declarative language". *I* would call it a functional programming language. :)
17:09:12 <fantasma> LoganCapaldo, if that's the case then Haskall IS a declarative language
17:09:16 <LoganCapaldo> e.g. (An ideallized) SQL would be more of a declarative programming language
17:09:40 <fantasma> C focuses on how, haskell focuses on what
17:10:00 <Terabyte> yes, it's just, I was corrected at an interview when I said I had seen haskell the declarative language.. he promptly corrected me to say it was functional.. and explained why it was not declarative
17:10:22 <sjanssen> Terabyte: what was his explanation?
17:10:24 <Terabyte> Though I can't remeber what he said
17:10:28 <fantasma> declaritive isnt a word that should be used to describe languages =\
17:10:29 <Terabyte> exactly why i'm asking here :D
17:10:57 <Philippa> Terabyte: arguably functional (or at least purely functional) is a subset of declarative
17:11:08 <LoganCapaldo> well functional doesn't necessarily exclude declarative. Plus its kind of fuzzy. As fantasma pointed out Haskell is more declarative than C.
17:11:15 <Philippa> odds are what you were told was more or less that declarative => logic language
17:11:16 <Terabyte> I see
17:11:19 <sjanssen> "The term is not entirely clear and often controversial; it is sometimes used as a 10<font size="3">buzzword." -- from the Wikipedia article</font>
17:11:44 <Brocktoon> i would call C 'imperative' - meaning you say what to do
17:12:03 <Brocktoon> eh, say how to do it I mean
17:12:05 <Philippa> the paper title "how to declare an imperative" comes to mind - there's a reason for the pun
17:12:22 <Philippa> what to do rather than what you want achieved? :-)
17:12:27 * fantasma wants to read just because of the title
17:12:34 <Terabyte> lol
17:12:35 <jcreigh> I don't think the label "declarative" means anything. *every* language tries to be declarative: Some are more successful than others.
17:12:39 <Philippa> fantasma: one of the early papers on monads
17:12:53 <mbishop> ?goog how to declare an imperative
17:12:58 <Philippa> jcreigh: I disagree re every language trying to be imperative
17:12:59 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/monadsdeclare/monadsdeclare.ps.gz
17:13:08 <fantasma> postscript ;(
17:13:15 <sjanssen> <font size="3">Wikipedia also includes Haskell in the category of declarative languages</font>
17:13:23 <fantasma> @goog "how to declare an imperative"
17:13:24 <jcreigh> Philippa: um, I said "every language tries to be declarative"
17:13:25 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/monadsdeclare/monadsdeclare.ps.gz
17:13:28 <Philippa> in some older languages even the declarations were instructions and thus the top-level program a sequence of instructions
17:13:38 <Philippa> jcreigh: sorry, brainfart
17:13:50 <Philippa> it's late and I've had a stressful day, I'm surprised my brain's coping as well as it is tbh
17:13:55 <jcreigh> heh, no problem
17:13:57 <sjanssen> <font size="3">I suppose if you count Prolog as a declarative language, then you have to count Haskell with multi-parameter type classes and functional dependencies :)</font>
17:14:19 <fantasma> hmmm, if only lambdabot could parse inline html
17:14:25 <Terabyte> mm
17:14:45 <LoganCapaldo> If only sjanssen's IRC client could automatically strip html ;)
17:14:52 <mbishop> heh
17:15:00 <mbishop> what kind of irc client lets you add in html? :P
17:15:11 <sjanssen> <font size="3">huh? did I do something wrong?</font>
17:15:29 <Philippa> <blink><marquee>no, not at all</marquee></blink>
17:15:37 <Terabyte> http://en.wikipedia.org/wiki/Declarative_programming vs http://en.wikipedia.org/wiki/Functional_programming is what i found.. and i'm always skeptical about wikipedia
17:15:41 <Terabyte> but thanks guys :)
17:15:54 <jcreigh> gah, is HTML in IRC going to take off like HTML in email? Am I going to start getting IRC messages with MIME attachments? (Note to pedants: I'm ignoring the 510 char limitation for humorous effect.)
17:15:59 <fantasma> do you need {;} semicolons with guards when you are feeding lambabot?
17:16:10 <sorear> nope
17:16:25 <sorear> > let foo | True = 1 | False = 2 in foo
17:16:26 <sjanssen> <font size="3">did I write something that had HTML in it?</font>
17:16:26 <lambdabot>  1
17:16:36 <fantasma> lol sjanssen
17:16:45 <LoganCapaldo> > f x | x > 2 = x ; f _ = 0 in (f 1, f 5)
17:16:45 <lambdabot>  Parse error
17:16:51 <fantasma> <sjanssen> <font size="3">did I write something that had HTML in it?</font>
17:16:54 <Pseudonym> Terabyte: Why be skeptical about Wikipedia?  If it wasn't for that, I wouldn't know that functional programming was developed by **ERIC IS GAY**.
17:16:57 <sorear> sjanssen: <script>while(1){window.alert("yes");}</script>
17:17:14 <Philippa> jcreigh: there'd be a multi-line encoding, duh
17:17:18 <Terabyte> because (sometimes) information in it is just plain wrong
17:17:30 <LoganCapaldo> > let f x | x > 2 = x ; f _ = 0 in (f 1, f 5)
17:17:31 <lambdabot>  (0,5)
17:17:38 <jcreigh> sjanssen: <font> is deprecated. You want to use something like <span style="text-decoration: blink; text-transform: uppcase; font-size: 500%">
17:17:48 <Terabyte> of course its good for a jist of stuff.. but some people just write total and utter crap on there
17:18:01 <jcreigh> @remember Pseudonym Why be skeptical about Wikipedia?  If it wasn't for that, I wouldn't know that functional programming was developed by **ERIC IS GAY**.
17:18:02 <lambdabot> Done.
17:18:08 <LoganCapaldo> Everytime someone entered a room everyon's irc client would dump out the CSS style sheet to them
17:18:17 <sjanssen> <font size="3">oh dear god, gaim sucks</font>
17:18:28 <Philippa> *blink*
17:18:30 <Philippa> wow
17:18:36 <Philippa> yeah, if you can't stop it doing that then yes, it does
17:18:42 <Philippa> use something else for IRC?
17:18:48 <Pseudonym> If this were any other channel, someone would actually go and do that piece of vandalism.
17:18:54 <jcreigh> Philippa: sjanssen is joking.
17:18:58 <jcreigh> (I hope to God)
17:19:07 <sjanssen> jcreigh: no, gaim was really sending that html
17:19:13 <sjanssen> is it gone now?
17:19:17 <LoganCapaldo> yes
17:19:17 <Philippa> jcreigh: I could believe something written primarily as an IM client doing that all too easily
17:19:19 <Philippa> sjanssen: yep
17:19:20 <Pseudonym> Yes.
17:19:22 <fantasma> gaim always screws me over
17:19:27 <alisdair> why woulg gaim send html? what client reads html in ims?
17:19:30 <mbishop> gaim is terrible :(
17:19:36 <jcreigh> That's the worst thing I've seen all day.
17:19:39 <LoganCapaldo> alisdair: AIM for one
17:19:39 <sjanssen> sorry guys.  How embarassing :(
17:19:51 <mbishop> alisdair: probably because gaim reads html for other protocols
17:19:52 <Philippa> sjanssen: I guess I should apologise in case it rendered the blinking marquee
17:19:52 <alisdair> aim accepts html? that's insane.
17:19:54 <jcreigh> I had assumed that sjanssen was just being funny.
17:19:57 <mbishop> sjanssen: now we know your secret :P
17:19:59 <sorear> sjanssen: gah, get a real IRC client.
17:20:07 <fantasma> @where+ bitlbee-aim-client http://www.bitlbee.org
17:20:07 <jyasskin> @quote sjanssen <font size="3">did I write something that had HTML in it?</font>
17:20:07 <lambdabot> Done.
17:20:08 <lambdabot> No quotes match. Where did you learn to type?
17:20:08 <sorear> sjanssen: I hear nc is pretty gtood.
17:20:24 <Pseudonym> There's something to be said for using one IM client for everything.
17:20:28 <jyasskin> @remember sjanssen <font size="3">did I write something that had HTML in it?</font>
17:20:29 <lambdabot> Done.
17:20:32 <LoganCapaldo> jyasskin: @quote is spelled @remember
17:20:32 <Philippa> Pseudonym: yeah. Don't do it.
17:20:33 <jyasskin> @quote sjanssen
17:20:33 <lambdabot> sjanssen says: @djinn Haskell -> Curry
17:20:34 <mbishop> Pseudonym: "silly"?
17:20:36 <LoganCapaldo> nvm
17:20:45 <Philippa> Using one IM client for all actual IM networks isn't so bad though
17:20:47 <fantasma> we need a haskell aim client
17:20:56 <Pseudonym> I wonder if Raketu handles IRC.
17:20:59 <fantasma> with it's own haskell protocol too
17:21:02 <sjanssen> I see no real reason not to use gaim
17:21:16 <Pseudonym> sjanssen: <font size="1">I do.</font>
17:21:17 <Philippa> I use gaim for MSN and AIM when I'm on a *nix system
17:21:21 <fantasma> lol!
17:21:25 <Philippa> Pseudonym: that's far too nice
17:21:40 <sjanssen> Pseudonym: once I file a bug report, that will go away (hopefully)
17:21:43 <fantasma> i like how the text scrolls so smoothly in gaim (in the betas)
17:21:45 <Philippa> sjanssen: did it actually do the blinking marquee bit?
17:22:10 <LoganCapaldo> <blink>Boy I hope not, or this would be really annoying</blink>
17:22:17 <sjanssen> Phillipa: no, it actually displayed the html other people sent literally
17:22:17 <yip> @karma+ bitlbee
17:22:18 <lambdabot> bitlbee's karma raised to 1.
17:22:26 <Philippa> sjanssen: ah well :-)
17:22:35 <Pseudonym> So it can dish it out, but it can't take it.
17:22:36 <Pseudonym> Typical/
17:22:38 <yip> bitlbee lets you chat with the aim network through irc
17:22:53 <sjanssen> the Wikipedia quote I pasted had a footnote, I'm assuming that formatting sent gaim into a tizzy
17:23:16 <LoganCapaldo> Yes the pasting of wikipedia was when it started
17:24:40 <fantasma> yip, have you used it before?
17:24:45 <conal> so what are favorite irc clients?
17:24:51 <yip> fantasma: yes
17:24:52 <sorear> <- ERC
17:24:59 <fantasma> <- ii
17:25:10 <glen_quagmire> <- giggity
17:25:32 <sorear> i would like something written in a real (read: statically scoped and typed) programming language however
17:25:52 <alisdair> i like colloquy
17:25:58 <yip> fantasma: it creates an irc channel with all of your buddies in it.
17:26:04 <fantasma> yip, yah I know
17:26:07 <LoganCapaldo> sorear: Give lambdabot a ui? :)
17:26:18 <Nafai> ERC <- with bip + bitlbee
17:26:20 <fantasma> yip, I can't wait to try it out, I found out about it a few days ago =)
17:27:00 <rahikkala> gaim on #haskell = a GUI for lambdabot
17:27:01 <fantasma> let foo a = unfoldr f where f a | a == 1 = Nothing | even a = Just (a, a `div` 2) | otherwise = Just (a, 3*a+1) in foo 13
17:27:13 <fantasma> > let foo a = unfoldr f where f a | a == 1 = Nothing | even a = Just (a, a `div` 2) | otherwise = Just (a, 3*a+1) in foo 13
17:27:14 <lambdabot>  <Integer -> [Integer]>
17:27:22 <Nafai> How-to on bip + bitlbee: http://www.travishartwell.net/blog/2006/04/20_1810
17:27:23 <lambdabot> Title: Finally, a Near Ideal IRC and Instant Messaging Setup :: Travis B. Hartwell / So ...
17:28:00 <yip> "Finally"? bitlbee has been around for years already
17:29:01 <rahikkala> > take 10 $ fix (\c f v -> f v : c f (f v)) (1+) 0
17:29:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:29:34 <rahikkala> I finally figured out how to write simple recursive functions in terms of fix... so that's what I've been doing all night :(
17:29:52 <fantasma> fun night ;)
17:30:34 <rahikkala> @pl \c f v -> f v : c f (f v)
17:30:34 <lambdabot> liftM2 ap ((:) .) . ((.) =<<)
17:33:23 <Nafai> yip: Well, "finally" as in, "I finally found a great setup"
17:34:18 <fantasma> @pl
17:34:19 <lambdabot> (line 1, column 1):
17:34:19 <lambdabot> unexpected end of input
17:34:19 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
17:34:24 <fantasma> @pl
17:34:25 <lambdabot> (line 1, column 1):
17:34:25 <lambdabot> unexpected end of input
17:34:25 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
17:34:46 * sorear afi: reread the HughesPJ paper
17:35:38 <yip> Nafai: yeah, interesting article
17:36:06 <Nafai> I need to add a new part that includes my setup in ERC, since I started using it a few months ago
17:44:37 <LoganCapaldo> Does @pl use parsec?
17:45:01 <sorear> yes
17:45:17 <sorear> whoa!
17:45:18 <LoganCapaldo> parse error looked familar :)
17:45:58 <sorear> I just changed terminals in X, causing an untirminated error, causing about 30 copies of gv to open on the hughespj paper.
17:46:10 <sorear> C-M-Backspace to the rescur.
17:46:12 <sorear> X--
17:46:33 <sorear> anyway, /me restarts X, continues reading
17:48:19 <fantasma> is there a better way to get the position of n in a list other than {{ length $ takeWhile (\x -> x /= n) [list] }}
17:48:20 * araujo playing a bit with c2hs
17:48:37 <araujo> anybody could help me a bit with a small foreign function call?
17:49:02 <narain> @hoogle index
17:49:03 <lambdabot> Ix.index :: Ix a => (a, a) -> a -> Int
17:49:03 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
17:49:03 <lambdabot> Data.Generics.Basics.indexConstr :: DataType -> ConIndex -> Constr
17:49:18 <fantasma> thank you narain
17:49:30 <LoganCapaldo> @hoogle a -> [a] -> Maybe Int
17:49:31 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
17:49:31 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
17:49:43 <narain> don't thank me, thank Logan :)
17:49:56 <fantasma> thank you LoganCapaldo
17:50:01 <fantasma> @karma+ LoganCapaldo
17:50:01 <lambdabot> LoganCapaldo's karma raised to 2.
17:50:03 <LoganCapaldo> You're welcome
17:50:13 * LoganCapaldo hearts searching by type
17:50:29 <fantasma> i don't understand how you did that
17:50:47 <fantasma> "Maybe Int"
17:51:10 <LoganCapaldo> well I cheated a little bit
17:51:18 <fantasma> ohhh
17:51:27 <LoganCapaldo> but it has to handle the case when the list doesn't contain the item
17:51:35 <LoganCapaldo> that means its probably Maybe something
17:51:36 <fantasma> you knew that elemIndex had to be that type
17:51:55 <chessguy> ?source State
17:51:55 <lambdabot> State not available
17:52:00 <chessguy> ?src State
17:52:00 <lambdabot> Source not found. Where did you learn to type?
17:52:07 <LoganCapaldo> yeah
17:52:34 <LoganCapaldo> @djinn a -> [a] -> Maybe Int
17:52:34 <lambdabot> f _ _ = Nothing
17:52:38 <LoganCapaldo> heh
17:52:43 <LoganCapaldo> djinn is lazy
17:52:47 <narain> haha that was easy
17:52:54 * fantasma is curious if this will work
17:53:04 <jcreigh> ah, LoganCapaldo should have more karma that that.
17:53:07 <jcreigh> @karma+ LoganCapaldo
17:53:07 <lambdabot> LoganCapaldo's karma raised to 3.
17:53:17 <narain> @djinn Eq a => a -> [a] -> Maybe Int
17:53:17 <lambdabot> Cannot parse command
17:53:36 <fantasma> > (elemIndex . maximum) [1,2,3,4,5,100,7,8,50]
17:53:38 <hpaste>  araujo pasted "simple c2hs" at http://hpaste.org/807
17:53:38 <lambdabot>  <[Integer] -> Maybe Int>
17:53:56 <araujo> Anybody could help me there?
17:54:15 <fantasma> > elemIndex maximum [1,2,3,4,5,100,7,8,50]
17:54:16 <narain> @pl \list -> elemIndex (maximum list) list
17:54:16 <lambdabot>   add an instance declaration for (Num ([a] -> a))
17:54:16 <lambdabot>     In the expression: 50
17:54:16 <lambdabot> elemIndex =<< maximum
17:54:31 <narain> interesting!
17:54:44 <narain> > elemIndex =<< maximum $ [1,2,3,4,5,100,7,8,50]
17:54:45 <lambdabot>  Just 5
17:54:57 * narain <3 @pl
17:55:03 <fantasma> what does @pl do?
17:55:10 <LoganCapaldo> @help pl
17:55:10 <lambdabot> pointless <expr>. Play with pointfree code.
17:55:27 <fantasma> ah
17:55:40 <fantasma> ahhh i see
17:55:44 <fantasma> nice
17:55:46 <LoganCapaldo> basically tries to remove arguments to your function
17:55:57 <fantasma> make it "cleaner"?
17:56:02 <LoganCapaldo> err
17:56:09 <narain> not ... always.
17:56:10 <LoganCapaldo> GIGO ;)
17:56:18 <fantasma> @where GIGO
17:56:18 <lambdabot> I know nothing about gigo.
17:56:25 <narain> @define GIGO
17:56:26 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:56:27 <LoganCapaldo> garbage in, garbage out
17:56:36 <narain> @help define
17:56:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:57:08 <fantasma> @define+ LoganCapaldo very elite haskeller
17:57:09 <lambdabot> Unknown command, try @list
17:57:14 <LoganCapaldo> LOL
17:57:19 <LoganCapaldo> It is too laugh
17:57:29 <LoganCapaldo> s/too/to/ ?
17:57:43 <fantasma> :)
17:58:21 <narain> @pl \x -> f (g x) (h x)
17:58:21 <lambdabot> liftM2 f g h
17:58:58 <narain> @pl \x -> (g x, h x)
17:58:58 <lambdabot> liftM2 (,) g h
18:04:15 <fantasma> @pl \list -> elemIndex (maximum (map length (map foo list))) (map length (map foo list))
18:04:15 <lambdabot> ap (elemIndex . maximum . map (length . foo)) (map (length . foo))
18:04:48 <fantasma> @index ap
18:04:49 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
18:04:49 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
18:05:03 <fantasma> uh oh, i've never used a monad before
18:05:13 <dibblego> bet you have
18:05:29 <fantasma> @src ap
18:05:29 <lambdabot> ap = liftM2 id
18:06:00 <narain> @pl \list -> let lengths = map (length . foo) list in elemIndex (maximum lengths) lengths
18:06:02 <lambdabot> (elemIndex =<< maximum) . fix . const . map (length . foo)
18:06:56 <narain> :t ap
18:06:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:06:59 <fantasma> @karma+ narain
18:06:59 <lambdabot> narain's karma raised to 1.
18:07:34 <narain> such generosity with the karma! :)
18:08:24 <narain> > ap [round, floor, ceiling, truncate]
18:08:25 <lambdabot>  <[Double] -> [Integer]>
18:08:39 <fantasma> > let foo = unfoldr f where f a | a == 1 = Nothing | even a = Just (a, a `div` 2) | otherwise = Just (a, 3*a+1) in (elemIndex =<< maximum) . fix . const . map (length . foo) [1..1000000]
18:08:40 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[Int]'
18:08:42 <narain> > ap [round, floor, ceiling, truncate] [1.2, 1.3, 1.4, 1.5]
18:08:44 <lambdabot>  [1,1,1,2,1,1,1,1,2,2,2,2,1,1,1,1]
18:09:04 <narain> interesting
18:10:38 <narain> :t (elemIndex =<< maximum) . fix . const . map length
18:10:40 <lambdabot> forall a. [[a]] -> Maybe Int
18:11:39 <narain> golly, i can't understand that
18:11:46 <narain> time to im the lambdabot
18:12:21 <hpaste>  Dunearhp pasted "Wrapping an SQL query in a Connection handling function" at http://hpaste.org/808
18:14:36 <Dunearhp> I think I'm a little confused over the exact meaning of IO () in the above paste
18:14:59 <Dunearhp> I'm hoping someone can set me right
18:15:25 <kuribas``> @pl (\a x -> (a * 10) + x)
18:15:25 <lambdabot> (+) . (10 *)
18:16:06 <chessguy> Dunearhp, where, in particular?
18:16:18 <narain> fix . const == id
18:16:26 <narain> so why did lambdabot output  (elemIndex =<< maximum) . fix . const . map (length . foo) ?
18:16:36 <fantasma> that is odd
18:16:40 <fantasma> :t id
18:16:42 <lambdabot> forall a. a -> a
18:16:47 <narain> @pl fix . const
18:16:48 <lambdabot> id
18:17:05 <chessguy> @type (elemIndex =<< maximum) . map (length . foo)
18:17:07 <lambdabot> Not in scope: `foo'
18:17:10 <fantasma> > fix . const [1,2,3]
18:17:11 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[t]'
18:17:14 <chessguy> @type (elemIndex =<< maximum) . map (length . ?foo)
18:17:17 <lambdabot> forall a a1. (?foo::a1 -> [a]) => [a1] -> Maybe Int
18:17:31 <narain> > fix . const $ [1,2,3]
18:17:33 <lambdabot>  [1,2,3]
18:17:37 * araujo wonders if chessguy knows about c2hs
18:17:44 <chessguy> (elemIndex =<< maximum) . fix . const . map (length . ?foo)
18:17:49 <chessguy> @type (elemIndex =<< maximum) . fix . const . map (length . ?foo)
18:17:51 <lambdabot> forall a a1. (?foo::a1 -> [a]) => [a1] -> Maybe Int
18:17:59 <chessguy> huh
18:18:10 <chessguy> araujo, i don't even know what it is
18:18:45 <araujo> chessguy, haha
18:19:06 <yip> how does killThread affect a running atomically transaction?
18:19:19 <chessguy> araujo, looks like something that would show up in my alphabet soup
18:19:40 <Zeroth404> The Art of Computer Programming is such a daunting read
18:19:51 * araujo doesn't believe at chessguy 
18:20:15 <chessguy> i'm serious. i have no idea what c2hs is
18:20:36 <Dunearhp> chessguy: trying to get [(String,String)] out of doInConnectionNoInputData retrieveRecords, but I don't know how to write doInConnectionMoInputData
18:20:36 <Zeroth404> chessguy: if "zeroth" showed up in my alphabet soup, I'd shitmyself and start worshiping tomatos
18:20:40 <chessguy> some kind of converter from c to haskell?
18:20:54 <Dunearhp> without the type system demading it return IO ()
18:21:01 <TomMD> chessguy: How is checkers going? I've been considering making a breakout game in Haskell.
18:21:15 <chessguy> ack! too many people talking to me!
18:21:21 <TomMD> sorry
18:21:26 <fantasma> @karma+ chessguy
18:21:26 <lambdabot> chessguy's karma raised to 6.
18:21:27 <chessguy> lol, it's ok
18:21:32 <araujo> @where c2hs
18:21:33 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
18:21:38 <Dunearhp> demading = demanding
18:21:44 <kuribas``> How can I read a simple number using Parsec?
18:21:44 <araujo> chessguy, it's an interface generator for FFI
18:22:02 <kuribas``> I have: a <- liftM read $ many1 digit
18:22:06 <chessguy> Dunearhp, well, let's stick to your most basic question. what do you think IO () is?
18:22:12 <user317> is there a page somewhere that has the most elegant/shortest solution to the language shootout problems?
18:22:14 <TomMD> @users
18:22:15 <lambdabot> Maximum users seen in #haskell: 339, currently: 313 (92.3%), active: 47 (15.0%)
18:22:18 <chessguy> TomMD, i'm not sure what you're talking about with checkers
18:22:34 <TomMD> I was under the belief you were making a checkers game once upon a time.
18:22:37 <dons> oh nice.
18:22:40 <dons> sorear: 6^
18:22:57 * araujo wonders if dons knows about it
18:23:07 <dons> hmm?
18:23:26 <araujo> dons, c2hs :-)
18:23:42 <Zeroth404> how can I get [any given math function] to compute to [number] number of digits?
18:23:48 <Zeroth404> arbitrary precicion..
18:24:01 <mbishop> use Integer for type
18:24:12 <chessguy> TomMD, not that i can recall
18:24:13 <Dunearhp> chessguy, I think it may be a wildcard for either IO a or IO with no return value
18:24:24 <Zeroth404> mbishop: huh?
18:24:32 <narain> Zeroth404: do you mean arbitrarily large integers or arbitrarily precise reals?
18:24:35 <TomMD> > sum ([1..1000] :: Integer)
18:24:36 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[a]'
18:24:39 <chessguy> Dunearhp, it's an IO action that has no return value
18:24:43 <Zeroth404> narain: for example
18:24:44 <chessguy> @type putStrLn
18:24:46 <lambdabot> String -> IO ()
18:24:53 <Zeroth404> > (sqrt pi)
18:24:54 <lambdabot>  1.7724538509055159
18:24:58 <TomMD> > sum ([1..1000] :: [Integer])
18:24:59 <lambdabot>  500500
18:25:04 <Zeroth404> lets say I want 50 digits of (sqrt pi)
18:25:09 <chessguy> putStrLn takes a string, and returns an IO action which prints the string to the screen
18:25:20 <fantasma> when doing `maximum` on a list does it attempt to put the whole list in memory?
18:25:20 <chessguy> with no result
18:25:31 <TomMD> Zeroth404: See the 'sum' line?  Just use the 'Integer' type instead of letting ghc default to 'Int'.
18:25:42 <narain> Zeroth404: i don't think you can do it with the standard libs
18:26:19 <Zeroth404> > prod ([1..1000] :: [Integer])
18:26:20 <lambdabot>   Not in scope: `prod'
18:26:22 <user317> fantasma, i think you have to evaluate every element in an unorderded list to find the max
18:26:33 <Zeroth404> > fold (*) 1 ([1..1000] :: [Integer])
18:26:34 <lambdabot>   Not in scope: `fold'
18:26:38 <Zeroth404> > foldl (*) 1 ([1..1000] :: [Integer])
18:26:39 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
18:26:40 <narain> product
18:26:43 <Zeroth404> wow
18:26:49 <Zeroth404> thats a big integer
18:26:50 <narain> > product [1..1000]
18:26:52 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
18:27:14 <Cale> Double is double precision IEEE floating point, and Float is single precision. If you want more, you can use Rational, or else look around for an arbitrary precision real number library.
18:27:20 <TomMD> Zeroth404: :-)  If you want float then it might be easier to think of it as 2 integers (mantissa, etc).
18:27:49 <fantasma> user317, I know, but my question is: is just the element in the stack or the entire list when doing maximum
18:27:56 <Cale> There's nothing in the libraries for approximating pi to arbitrary precision as a Rational though, you'll have to write something yourself.
18:28:24 <yip> what about long double?
18:28:33 <narain> yip: is there such a thing?
18:28:39 <yip> sure, in c
18:29:17 <TomMD> Hence the suggestion about using two integers (like Ratio does, but customized).   Long double, double double, etc are not well standardized - the documents I've seen say they must be 'over 80 bits', but people often think they are 128 or some such.  The Web would know more than me, of coarse.
18:29:18 <Dunearhp> chessguy, OK, that means my wrapper function is incorrectly defined
18:29:28 <user317> fantasma, well, its probably on the heap somewhere, the garbage collector might delete the elements of the list as soon as it reads them if you no longer need them and just want the maximum
18:30:17 <fantasma> well it's erroring stack overflow when I try to do maximum on a list that's only a million elements long
18:30:25 <narain> @src maximum
18:30:25 <lambdabot> maximum [] = undefined
18:30:26 <lambdabot> maximum xs = foldl1 max xs
18:30:35 <mbishop> why does haskell allow for arbitrary precision (typically by default) anyway? I mean sure, it's convienient, but doesn't it hurt performance?
18:30:36 <narain> @src foldl1
18:30:36 <lambdabot> foldl1 f (x:xs) = foldl f x xs
18:30:37 <lambdabot> foldl1 _ []     = undefined
18:30:41 <yip> but can haskell do 80 bit precision floating point math via long double?
18:30:58 <narain> mbishop: correctness over performance, i suppose :)
18:31:12 <narain> @src foldl
18:31:12 <lambdabot> foldl f z xs = lgo z xs
18:31:12 <lambdabot>     where lgo z []     =  z
18:31:12 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
18:31:19 <TomMD> mbishop: People just want it often enough (to ensure no rollover or for scientific reasons).  Performance is the reason Int is default.
18:31:34 <Cale> > let fac n = product [1..n]; dfac n = product [n, n-2 .. 1] in 2 * sum [fac k / dfac (2*k+1) | k <- [0..100]]
18:31:35 <lambdabot>  3.1415926535897922
18:31:40 <Cale> > let fac n = product [1..n]; dfac n = product [n, n-2 .. 1] in 2 * sum [fac k / dfac (2*k+1) | k <- [0..100]] :: Rational
18:31:42 <lambdabot>  6985722258425656324842162623285571890561823960127238744636003194760176752632...
18:31:45 <TomMD> yip: I saw this proposed but I've not seen it implemented.
18:31:55 <mbishop> narain: nothing stops you from using a seperate type (like in ocaml), just wondering why it seems to be default for most stuff
18:31:57 * mbishop shrugs
18:32:04 <Cale> 69857222584256563248421626232855718905618239601272387446360031947601767526320570368%22236244569910437892880691136109856086794490658698290303471308035343578465879432175
18:32:14 <narain> is maximum actually implemented as a foldl?
18:32:26 <mbishop> :t maximum
18:32:26 <Cale> So there, you can compute pi to as many places as you want.
18:32:28 <lambdabot> forall a. (Ord a) => [a] -> a
18:32:31 <narain> that might explain stack overflow
18:32:42 <fantasma> narain, i should use foldl' yes?
18:33:00 <gvdm_other> If you are treating something like a Num, but the compiler is treating it as an Int, well it change to an Integer if it gets too large?
18:33:12 <TomMD> narain: Prelude implementations can vary by compiler.  I believe the lambdabod gives you ghc source.
18:33:15 <user317> fantasma, sounds like you have a non tail recursion somewhere, it dobt its the maximum function
18:33:26 <narain> is foldl tail recursive?
18:33:41 <narain> i've forgotten all this stuff :(
18:33:45 <fantasma> it's taking quite a long time to display only a million elements
18:33:48 <user317> fantasma, > maximum $ take 10000000 [1..]rn
18:33:52 <fantasma> it's been over five minutes
18:34:05 <dibblego> ?src foldl
18:34:06 <lambdabot> foldl f z xs = lgo z xs
18:34:06 <lambdabot>     where lgo z []     =  z
18:34:06 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
18:34:07 <user317> fantasma, hmm, that cause ghci to crap out
18:34:12 <fantasma> > maximum $ take 10000000 [1..]rn
18:34:12 <lambdabot>  Illegal character ''\DLE''
18:34:20 <user317> maximum $ take 10000000 [1..]
18:34:27 <fantasma> > maximum $ take 10000000 [1..]
18:34:30 <lambdabot>  10000000
18:34:41 <TSC> @src maximum
18:34:41 <lambdabot> maximum [] = undefined
18:34:41 <lambdabot> maximum xs = foldl1 max xs
18:34:58 <user317> i wonder why it craps out on my machine and not on lambdabot
18:35:03 <TSC> @src max
18:35:03 <lambdabot> max x y = if x <= y then y else x
18:35:07 <TomMD> what are you using? Hugs/
18:35:12 <user317> ghci
18:35:40 <user317> narain, foldl' is
18:35:51 <fantasma> ok, so maximum fails
18:36:16 <narain> ?src foldl'
18:36:17 <lambdabot> foldl' f a []     = a
18:36:17 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:36:44 <TomMD> user317: It seems ghci is not collecting the list as it is folded (memory usage goes through the roof).
18:37:05 <TomMD> Does anyone know which GHC lambdabot uses?  user317: what ghc version do you use?
18:37:43 <mbishop> lambdabot uses 6.6 now
18:37:45 <user317> fantasma, let mymaximum ll = foldl' (\ aa zz -> if aa > zz then aa else zz) (head ll) (tail ll)
18:37:50 <mbishop> ?lambdabot
18:37:51 <lambdabot> Unknown command, try @list
18:37:54 <mbishop> ?info
18:37:54 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
18:37:58 <mbishop> heh
18:38:00 <mbishop> @list
18:38:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:38:10 <narain> @index foldl'
18:38:10 <lambdabot> Data.List
18:38:17 <mbishop> ?version
18:38:18 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
18:38:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:38:53 <narain> yep, using foldl' doesn't overflow on my ghci
18:38:56 <user317> TomMD, 6.6
18:40:01 <narain> well caught, user317
18:41:09 <Cale> gvdm_other: no, if it's typed as an Int, you're working mod 2^k
18:41:28 <Cale> gvdm_other: If it's typed as Integer, then it'll internally use machine ints until the values get too large.
18:41:38 <Cale> (at least, in smart implementations)
18:41:45 <fantasma> @pl \list -> (elemIndex =<< maximum) . id . map (length . foo) list
18:41:45 <lambdabot> ((elemIndex =<< maximum) .) . map (length . foo)
18:41:45 <Cale> (this is what GHC does)
18:42:14 <fantasma> @pl \list -> ((elemIndex =<< maximum) .) . map (length . foo) list
18:42:15 <lambdabot> (((elemIndex =<< maximum) .) .) . map (length . foo)
18:42:30 <fantasma> @pl \list -> (((elemIndex =<< maximum) .) .) . map (length . foo) list
18:42:30 <lambdabot> ((((elemIndex =<< maximum) .) .) .) . map (length . foo)
18:44:30 <TomMD> user317: you understand why narain didn't have the issue, right?  foldl1' is strict, not lazy, thus there is no long list of closures to evaluate (they are evaluated as they are made) and memory doesn't go though the roof.
18:44:52 <user317> TomMD, that was fantasma that had a problem with it
18:45:17 <wkh> you have to love a tutorial that tries to explain an esoteric concept, monad transformers, using another esoteric concept, continuations
18:45:33 <TomMD> Gaaa... confusing users with each other... must sleep.  Good night.
18:45:40 <fantasma> thanks TomMD
18:45:40 <wkh> that was a brilliant idea. that and putting code against an ugly brown background
18:46:28 <Cale> wkh: Yeah, those are the two problems with All About Monads, otherwise it does not too bad of a job.
18:46:31 <user317> fantasma, try compiling with -O, ghc --make -O, in ghci it doesn't do anything though.
18:46:47 <Cale> Invoking the continuation monad doesn't really do anyone any good there.
18:47:10 <fantasma> do monads not function in interactive mode?
18:47:26 <Cale> fantasma: Monads are just ordinary code.
18:47:27 <wkh> Cale: how else might i go about reducing my ignorance of monad transformers?
18:47:52 <fantasma> > (elemIndex =<< maximum) [1,2,4,66,3,9]
18:47:53 <lambdabot>  Just 3
18:47:59 <Cale> Hmm... I wonder if there are any really good tutorials on them... I just sort of read the GHC documentation.
18:48:07 <wkh> haha.
18:48:46 <wkh> i tried to read that paper about creating modular interpreters because what they described sounded good but they lost me after about uh, half a page
18:49:08 <rahikkala> > sum $ take 1000 $ map (1.0/) $ fix (\n -> 1.0 : zipWith (*) n [1..])
18:49:09 <lambdabot>  2.7182818284590455
18:49:15 <Cale> Once you figure out what monad transformers are about, you could read my article about how to use them correctly.
18:49:27 <narain> wkh: sigfpe wrote a blog post about them: http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
18:49:30 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
18:49:39 <Cale> But it sort of assumes some prior knowledge.
18:49:45 <Cale> (my article)
18:50:07 <wkh> honestly, how many people are there who understand both quantum mechanics AND haskell
18:50:17 <wkh> narain: thanks, i'll take a look at that
18:50:17 <Cale> uh, probably quite a few :)
18:50:28 <narain> david roundy, for one?
18:50:39 <fantasma> @src maximum
18:50:40 <lambdabot> maximum [] = undefined
18:50:40 <lambdabot> maximum xs = foldl1 max xs
18:50:44 <narain> (darcs)
18:50:56 <Cale> Basically, monad transformers are tools for constructing monads that you're interested in.
18:50:59 <wkh> so it' slike a handful of ubergeeks
18:51:13 <wkh> and then the rest of us who are just average glance at the article, go "uh... guess that'd be cool if i could understand any of it" and move on
18:51:27 <narain> fantasma: you are aware that's just expository code, right? the actual implementation may be completely different
18:51:29 <Cale> hehe
18:51:50 <fantasma> narain, yah
18:52:06 <narain> good, because i didnt until yesterday :)
18:52:07 <Cale> Quantum mechanics isn't *so* bad. I can't claim to really properly understand it, but I've had lots of conversations with my friend about it.
18:52:36 <fantasma> narain, well the actual implementation is determined by the compiler yes?
18:52:39 <wkh> after hearing the feynman quote "if you think you understand quantum theory, you don't understand quantum theory" i decided never to bother trying.
18:52:43 <dons> Cale, anyone, i'd like some comments on a little article /code i'm hacking up.
18:52:56 <narain> fantasma: true
18:53:01 <dons> the idea is to use ErrorT and a privledged monad, to do nice shell scripting with previledge separation and strong error handling.
18:53:05 <dons> the initial code is here: http://www.cse.unsw.edu.au/~dons/tmp/cpuspeed.html
18:53:06 <lambdabot> Title: Haskell Code by HsColour
18:53:22 <dons> Cale, in particular, any hints on cleaning up the code, making the guarantees stronger, et al , would be useful
18:53:27 <fantasma> in this code {p14 n = elemIndex (mymaximum (foolist n)) foolist n} foolist n is not calculated twice right?
18:53:44 <fantasma> it is just memoized?
18:53:48 <dons> so the final core code, the main function, should be the same length as say, a shell script
18:53:55 <dons> but should have all the strong static guarantees we like
18:54:06 <dons> (everything else being delegated to libs)
18:54:07 <Cale> wkh: I'm convinced that the problem is that physicists handwave too much.
18:54:28 <dibblego> fantasma, p14 n = elemIndex (mymaximum (foon)) foon where foon = foolist n
18:55:00 <Cale> I mean, if you have trouble understanding your model, essentially the hypothesis that you're making about the universe, that's kind of a concern, don't you think?
18:56:03 <Cale> Physicists have dug themselves into a bit of a muddy hole, and there are million dollar prizes waiting for people who figure out bits of how to climb out.
18:56:13 <thalassocrac> most peoples knowledge of any given subject is very shallow, given that they watch so much television
18:56:50 <dibblego> what a deeply thought out philosophical position!
18:57:01 <thalassocrac> heh
18:57:14 <thalassocrac> just study, then you'll know something
18:57:26 <dibblego> is that all I need to do?
18:57:29 <narain> Cale: i'd guess most physicists have a pretty good understanding of QM from a mathematical perspective
18:57:36 <thalassocrac> yep
18:57:51 * dibblego turns the telly off
18:57:52 <narain> Cale: it's just that it's hard to make an interpretation of
18:58:01 <jtokle> \part
18:58:05 <jtokle> er,
18:58:08 <fantasma> bye jtokle
18:58:08 <yip> dons: interesting. does it actually work?
18:58:14 <jtokle> too much latex tonight
18:58:18 <fantasma> haha
18:58:20 <narain> jtokle: :D
18:58:38 <nornagon> @instances Num
18:58:39 <lambdabot> Double, Float, Int, Integer
18:58:47 <nornagon> @src Complex
18:58:48 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
18:59:53 <narain> does  @instances Num  only return types in the Prelude?
19:02:05 <dons> yip, sure. i even have it bound to a hotkey on my laptopt now
19:02:17 <dons> $ ./cpuspeed
19:02:17 <dons> cpuspeed: 100 -> 0
19:02:17 <dons> $ ./cpuspeed
19:02:17 <dons> cpuspeed: 0 -> 100
19:02:36 <dons> Cale: any thoughts? :-)
19:02:40 <wkh> i have a friend who took a programming class in haskell and they used java
19:02:47 <wkh> now he hates programming even though he was excited before
19:02:55 <yip> dons: i'm not familiar with openbsd, but if you set the "cpuspeed" to zero, won't that completely halt your computer, even preventing you from resetting it back? :)
19:02:58 <wkh> i want to convince him to give programming another try with a better language, e.g. scheme/haskell
19:03:01 <wkh> how can i convince him :(
19:03:08 <dons> yip, no, its setting the cpu perf rate to 0
19:03:15 <dons> i.e. 600Mhz on a Pentium M 1.6Ghz
19:03:20 <dons> thanks, i should explain that
19:04:08 <Cale> dons: you like printf :)
19:04:21 <alisdair> wkh: buy him programming erlang
19:04:21 <dons> that's true. i think it helps win over perl people
19:04:30 <narain> wkh: show him awesome one-liners in haskell?
19:04:33 <dons> Cale, any monad / monadT thoughts?
19:04:44 <wkh> narain: maybe
19:05:02 <Cale> hmm
19:05:10 <dons> the main thing is to get this type error:
19:05:11 <dons> $ ghc -O cpuperf.hs -o cpuperf
19:05:12 <dons> cpuperf.hs:35:12:
19:05:12 <dons>     Couldn't match expected type `Shell t'
19:05:12 <dibblego> wkh, tell him that Java isn't "programming"
19:05:12 <dons>            against inferred type `PrivShell String'
19:05:28 <dons> if you try to use a sudo-requiring command without asking explicitly
19:05:34 <wkh> let fibs=0:1:(zipWith (+) fibs (tail fibs)) in take 10 fibs
19:05:36 <dibblego> then when he bitches that he doesn't like programming, you can reply, "but you've never programmed"
19:05:39 <wkh> > let fibs=0:1:(zipWith (+) fibs (tail fibs)) in take 10 fibs
19:05:40 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
19:05:46 <alisdair> haskell is not a very good first language unless you are a math geek, really
19:05:52 <alisdair> there's too much minutiae
19:06:01 <narain> minutiae?
19:06:04 <alisdair> start him with python or erlang or ruby
19:06:12 <dons> alisdair: its taught as a intro programming language fairly widely though, using the scheme-subset of haskell
19:06:17 <wkh> he's planning on majoring in math/physics
19:06:28 <alisdair> narain: rules ;)
19:06:32 <Cale> dons: What is this code intended for? Have you seen HSH?
19:06:34 <dons> and we actually have textbooks for beginner programmers. so that helps..
19:06:40 <narain> wkh: great, he should love the fibs example then
19:06:52 * wkh has never been much of a salesman
19:06:59 <narain> alisdair: i know what it means :p i meant what minutiae?
19:07:00 <thalassocrac> basic is a fun language for beginners
19:07:04 <dons> Cale, sure. its more about in general using the type system and other haskellish stuff to achieve more robust code in the same number of lines as some shell
19:07:21 * wkh stares at thalassocrac like hells angels starting at peewee herman after he kicked over all their motorcycles
19:07:22 <Cale> ah, okay
19:07:26 <alisdair> i don't think statically typed languages are very good for beginners is all. there's too much to learn before you can actually do things.
19:07:27 <Cale> So it's for an article
19:07:31 <dons> yeah
19:08:46 <dibblego> haskell is a perfect first language
19:08:54 <Cale> hmm
19:08:57 <dibblego> it's a terrible second language
19:09:03 <Cale> Can run do that IO lazily?
19:09:03 <dibblego> too much unlearning
19:09:15 <narain> alisdair: possibly. type inference errors can drive you crazy sometimes
19:09:24 <alisdair> that is an awfully condescending view dibblego
19:09:24 <Cale> Unlearning is learning too :)
19:09:26 <dons> Cale, oh, hmm. good point. let me think.
19:09:30 <wkh> i've had a lot of problems with type errors
19:09:43 <dibblego> alisdair, I fail to see how an observation is condescending
19:09:45 <wkh> and also problems with figuring out how to use the standard libraries by looking at the docs
19:09:52 <Cale> dons: I just noticed that you're going out of your way to force the evaluation of the streams
19:09:54 <alisdair> there are things to learn from all languages
19:10:07 <alisdair> even terrible ones like java and c++
19:10:07 <wkh> alisdair: what does java teach you?
19:10:12 <Cale> That might be necessary, but I don't know :)
19:10:14 <dibblego> even "what not to do", sure
19:10:21 <narain> given that the guy is into math, i think he should be able to think in terms of types and HOFs though
19:10:23 <alisdair> how to look up documentation for third party libraries, mostly
19:10:28 <dibblego> alisdair, ever watched a Java programmer struggle to pick up Haskell?
19:10:46 <alisdair> i'm not recommending java as a first language either though
19:10:47 <dons> Cale, right. otherwise waiting on the process to terminate is a bit dangerous, but for the 8 byte output here, it shouldn't matter
19:10:47 <yip> woohooo language war!
19:10:54 <wkh> if other people are like me, they don't actually learn haskell the first time they try it
19:10:58 <alisdair> i was recommending something fairly lightweight and dynamic
19:11:05 <wkh> this is about my third time trying it, the most progress i've made of any of my attempts
19:11:07 <dibblego> alisdair, sure, but have you ever watched a Haskell programmer struggle to pick up Java?
19:11:21 <Cale> dibblego: actually, yes. :)
19:11:24 <nornagon> so
19:11:32 <dibblego> I haven't
19:11:37 <alisdair> no, but that's because i doubt there's more than a handful of haskell programmers that don't already know C or java or some other algol descendent
19:11:39 <nornagon> i wrote a version of the boids flocking algorithm
19:11:44 <nornagon> but it's slooow
19:11:49 <wkh> :t (..)
19:11:51 <lambdabot> parse error on input `..'
19:12:11 <dibblego> I still think my 6 year old is enough evidence to support my (apparently condescending) position
19:12:15 <yip> an expert haskell programmer can pick up any language easily. and quickly be a better programmer in that language than it's experts
19:12:33 <alisdair> an expert anything programmer can pick up any language easily.
19:12:40 <yip> not true at all
19:12:44 <dibblego> alisdair, absolutely untrue
19:12:48 <Cale> yip: Provided that they also know the paradigm of that language.
19:12:55 <yip> an expert c programmer will have a hard time with other languages
19:12:59 <wkh> there are plenty of people with the title "senior X engineer" who would have a very hard time with haskell or erlang
19:13:09 <dibblego> proclaimed "Java experts" don't actually know Java that well, let alone how to program
19:13:16 <alisdair> sure, but 'senior X engineer' is not the same as 'expert programmer'
19:13:23 <Cale> I mean, I can do OO programming, but I think I'd have problems going along with many of the idioms.
19:13:46 <blackdog> a haskell programmer can pick up any language, true, but any productivity advantage is nullified by the amount of time spent bitching that it's not as good as haskell.
19:13:49 <yip> Cale: OO was a big lie :P
19:13:50 <alisdair> i like haskell, a lot. but it's kinda crazy to insist it's the be all and end all of computer science.
19:13:59 <dibblego> alisdair, who insisted that?
19:14:03 <narain> Cale: while (n--) *dst++ = *src++;
19:14:04 <narain> :)
19:14:16 <yip> haskell is the most powerful mainstream language. it really has no competition
19:14:18 <Cale> alisdair: I think they're referring to contemporary languages, not future ones.
19:14:24 <dons> Cale, cleaned up 'run' a bit, http://www.cse.unsw.edu.au/~dons/tmp/cpuperf.html
19:14:24 <lambdabot> Title: Haskell Code by HsColour
19:14:39 <dibblego> I think it's crazy to create the delusion that one tool is not inferior to another in all possible ways
19:14:52 <Cale> dibblego: certainly
19:14:57 <dibblego> simply because it might hurt feelings (or be condescending or whatever)
19:15:13 <alisdair> not all contemporary languages are inferior to haskell, is my point.
19:15:45 <dino-> I feel increasingly uneasy with the things that are coming out of the OO world. Like the aspect stuff.
19:15:59 <yip> Cale: i've been thinking.... it should be possible to implement STM in pure haskell, based on MVars... right?
19:16:04 <dino-> And often I seem assailed by cultish ferver by these guys at companies.
19:16:09 <dibblego> that's not your point - or you've shifted your point
19:16:12 <Cale> yip: absolutely, but it's less efficient.
19:16:26 <alisdair> all i said was haskell would not be my first choice of languages to teach someone
19:16:27 <yip> Cale: right, also retry and orElse?
19:16:39 <hpaste>  nornagon pasted "Slooow (Boids)" at http://hpaste.org/809
19:16:57 <Cale> I'd teach Haskell first. It's good in that it requires a bit less mind corruption to learn to program in it.
19:17:10 <blackdog> alisdair: it works better than you might think - UNSW had it for a while as the first ugrad language.
19:17:20 <blackdog> alisdair: but which would you choose?
19:17:26 <dons> yeah, a decade of teaching 500 kids a year haskell
19:17:27 <dons> that was good
19:17:28 <dibblego> alisdair, my son will not see an imperative looping construct before he also sees an extremely violent movie; as his guardian, I must protect him from it - he picked up some basics of haskell in one day, such that he was programming better than most of my former IBM colleagues ever will
19:17:30 <Cale> When you wash a bunch of dishes, your first thought is not to number them, it's to apply a process to each of them.
19:17:31 <dons> and oxford still does.
19:17:43 <blackdog> dons: good times. good times. :)
19:17:43 <alisdair> lua, ruby, erlang or ecmascript. something like that.
19:17:59 <nornagon> are there any obvious bottlenecks in my code?
19:18:02 <blackdog> pete's teaching data structures in C now. poor bastard. :)
19:18:06 <Cale> dons: UNSW isn't anymore?
19:18:07 <dibblego> that's "all I'm saying"
19:18:20 <wkh> dibblego: make your son watch Full Metal Jacket and Silence of the Lambs over and over
19:18:20 <yip> nornagon: looks cool
19:18:35 <wkh> THEN make him code in java, that'll send him over the edge and you'll have a cold-blooded serial killer
19:18:44 <Cale> I know that there's at least one Australian uni where they were teaching Haskell, but whoever made up the assignment had obviously not done much in Haskell before.
19:18:59 <dibblego> those looping people struggle to comprehend even recursion - I've watched them!
19:19:14 <dons> Cale, for engineers, the CS kids get C first up now
19:19:15 <nornagon> yip: it slows down loads as soon as there's five or six boids
19:19:16 <mbishop> heh yeah
19:19:17 <nornagon> input lags
19:19:24 <alisdair> dibblego: i think you're being awfully dismissive of imperitive languages with that statement, and your previous one. although, admittedly, i program mostly in erlang and find imperitive languages crippled also.
19:19:30 <narain> alisdair: mutable variables are a common source of confusion among beginners to programming
19:19:40 <mbishop> on the other hand, recursion isn't hard to turn into looping really...just seems stupid to have to do that yourself though
19:19:41 <Cale> dons: That's an interesting starting point. Make them all hate programming right away.
19:19:43 <dibblego> alisdair, not "awfully", perhaps "definitely" I'll accept
19:19:59 <mbishop> the point of computers is to keep humans from having to repeat boring repetative tasks
19:20:00 <alisdair> alright, definitely. sure.
19:20:18 <dibblego> alisdair, I won't deny it, the universe is immutable - always has been :)
19:20:31 <yip> nornagon: are you compiling with -O?
19:20:31 <Cale> Imperative languages are crippled by the fact that they have no better way to express things when order does not matter.
19:20:39 <dons> Cale :/
19:21:01 <alisdair> i had to learn c++ as my first language in uni
19:21:02 <dons> blackdog: Gabi is teaching this C course too :-) so she hopes to get to linked lists by week 12..
19:21:03 <dibblego> dons, there is talk of Scheme or Haskell in some unis up here
19:21:05 <dons> sigh
19:21:08 <dons> dibblego: good!
19:21:12 <blackdog> alisdair: you're an erlang programmer? i've just started fiddling around with it - how do you cope with not having letrec??
19:21:13 <nornagon> yip: ah, hm!
19:21:15 <alisdair> we started OO about three weeks in
19:21:21 <dibblego> dons, part of my PhD deal I hope :)
19:21:23 <nornagon> yip: actually I'm using runhaskell >_>
19:21:26 <nornagon> that might be the problem
19:21:28 <mdmkolbe5> @pl o2 f g a b = f $ g a b
19:21:28 <lambdabot> o2 = (.) . (.)
19:21:31 <dibblego> (teaching that is - I used to lecture a while back)
19:21:39 <Cale> dons: At Waterloo it's Java, unless you take the advanced section CS, in which case it's Scheme. Seems the co-op people have allowed corporate interests to seep in.
19:21:41 <narain> i remember seeing an article arguing that haskell was a better choice than scheme for intro to programming courses
19:21:43 <blackdog> dons: jeez.
19:21:43 <mdmkolbe5> @pl o3 f g a b c = f $ g a b c
19:21:44 <nornagon> mdmkolbe5: ah, the well-known boobie combinator
19:21:44 <lambdabot> o3 = (.) . (.) . (.)
19:21:49 <yip> nornagon: ghc -O --make Main
19:21:53 <yip> nornagon: ./Main
19:22:14 <Cale> When I went through, there was no advanced section CS though, so I ended up doing Java.
19:22:17 <mdmkolbe5> @pl o4 f g a b c d = f $ g a b c d
19:22:17 <lambdabot> o4 = (.) . (.) . (.) . (.)
19:22:29 <bd_> @quote compiling with -O2
19:22:29 <dibblego> <idea>ask any Java programmer to solve FizzBuzz without a loop and observe the results and time taken to produce</idea>
19:22:29 <lambdabot> No quotes for this person. Do you think like you type?
19:22:32 <bd_> hm
19:22:33 <mbishop> narain: I don't think so, I think the main selling point of scheme as an introductory language is the fact it has very little syntax (even less than CL) and doesn't put too much sugar on anything
19:22:35 <bd_> @quote -O2
19:22:36 <lambdabot> ClaudiusMaximus says: compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
19:22:38 <yip> don't most kids start programming on their own before they get to uni?
19:22:43 <mbishop> both of which make it great for actually knowing what you are doing
19:22:57 <Cale> yip: many, but I don't think most, actually.
19:23:18 <mbishop> yip: not enough :P
19:23:29 * mbishop has never had formal programming training
19:23:29 <Cale> You'd think that it was most, but the intro programming courses still get filled up.
19:23:46 <narain> mbishop: true, but haskell's pattern matching syntax is cleaner
19:23:47 <mbishop> unless you count reading SICP and watching the lectures as formal :P
19:23:47 <Cale> (You can choose your starting point a bit at Waterloo)
19:24:01 <wkh> i couldn't handle SICP as a teenager
19:24:09 <mbishop> narain: arguable, I find COND to be almost as clean
19:24:11 <wkh> "they don't have any for loops?! what the fuck is this?"
19:24:18 <Cale> I think the lectures are possibly better than the book.
19:24:22 <yip> why would someone sign up to learn programming, if he's not attracted enough to it that he's already played around on his own?
19:24:22 <mbishop> wkh: obviously you learned bad things before that :P
19:24:29 <dibblego> wkh, LOL, you don't know how many times I've heard that
19:24:44 <mbishop> yip: because you can learn java in a year and get a job writing crappy code for big bucks
19:24:46 <dibblego> wkh, but you're supporting my original argument - that there is a lot to unlearn if you've been tainted
19:24:46 <Cale> GHC has forM now ;)
19:24:50 <wkh> yep, the damage C hath wrought
19:24:54 <wkh> dibblego: i 100% agree
19:24:57 <Cale> :t forM
19:25:00 <lambdabot>     Ambiguous occurrence `forM'
19:25:00 <lambdabot>     It could refer to either `forM', imported from Control.Monad.Writer
19:25:03 <dibblego> wkh, Haskell is the perfect first language, like I said :)
19:25:05 <narain> mbishop: i couldl try to dig up the article if you're interested in looking through it though
19:25:11 * Cale smashes his fist on the table in anger.
19:25:15 <mbishop> narain: might be interesting
19:25:19 <Cale> :t Control.Monad.forM
19:25:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
19:26:12 <narain> mbishop: it was written by a great name in functional programming as i recall, but i can't remember who
19:26:15 <yip> Cale: now haskell just needs an implementation of the "iterator" pattern in the Prelude :)
19:26:47 <Cale> :t Data.Traversable.forM
19:26:50 <lambdabot> forall (t :: * -> *) a (m :: * -> *) b. (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
19:27:01 <Cale> That's pretty close :)
19:27:06 <Cale> Not in the prelude.
19:27:10 <dons> hmm, I can't derive MonadError eh?
19:27:15 <dons>  even with cunning newtype deriving
19:27:18 <bd_> Cale: What, [] isn't good enough? :)
19:27:19 <Cale> MonadError e
19:27:34 <dons> ah
19:27:38 <dons> of course
19:28:06 <dons> yep, that's it
19:28:19 <Cale> bd_: You're right, but part of the idea of the iterator pattern is abstracting over the structure. Still, one could phrase that as a function of type F a -> [a]
19:28:32 <Cale> (a natural transformation from the data structure to lists)
19:28:35 <bd_> Data.Traversable is a useful generalization, but yeah, it can always be done in terms of toList
19:28:49 <yip> nornagon: how's it running?
19:29:34 <bd_> There should be some standard and automatic way to replace prelude functions with generalized versions (eg, map -> fmap, Data.Traversable, Data.Foldable, etc)
19:29:59 <Cale> The Prelude shouldn't be filled with monomorphic crap.
19:30:05 <Cale> hehe
19:30:09 <bd_> true I suppose
19:30:11 <hpaste>  fax pasted "(no title)" at http://hpaste.org/810
19:30:19 <Cale> Look at the Haskell 1.4 prelude.
19:30:33 <Cale> It was way way cooler in lots of ways.
19:30:35 <hpaste>  fax pasted "(no title)" at http://hpaste.org/811
19:30:56 <Cale> fax: hm?
19:31:02 <fax> Wooops!
19:31:05 <fax> sorry :S
19:31:14 <fax> I didnt know that was announcing in the channel
19:31:17 <Cale> (uncheck the announce box :)
19:31:19 <fax> eek
19:31:26 <bd_> import qualified Prelude; import Prelude14 ? :)
19:31:42 <fax> I love hpaste's syntax coloring.. I need to color a longer paste
19:31:44 <fax> is there anyway?
19:32:03 <Cale> We also have the problem that if you try to write your own prelude, you lose the use of all the libraries.
19:32:24 <bd_> Cale: foldr was monomorphic in 1.4 prelude though :/
19:32:32 <bd_> Cale: Not if you re-export the Haskell 98 prelude types
19:33:03 <bd_> right?
19:33:25 <Cale> well, right
19:33:46 <Cale> But some of the changes I'd really like to make are to things like the Monad class.
19:34:20 <yip> Cale: do you think that fail should be removed from Monad class?
19:34:29 <Cale> Yes, absolutely.
19:34:39 <Cale> It never should have gotten in in the first place.
19:34:56 <narain> mbishop: found it! http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf
19:35:01 <nornagon> yip: fiddling with some other stuff right now
19:35:06 <nornagon> refining the algo
19:35:29 <Cale> The reasoning behind that was shaky to begin with, but I believe it went something like this:
19:35:32 <narain> "This paper contrasts teaching in Scheme to teaching in KRC and Miranda, particularly with reference to Abelson and Sussman's text."
19:35:55 <Cale> "Type errors from monad comprehensions are hard, let's remove monad comprehensions."
19:36:10 <Cale> "Okay, then we don't need a separate MonadZero and MonadPlus anymore."
19:36:29 <mbishop> narain: figured ti was wadler :P
19:36:30 <Cale> "Whoops, the translation for do-notation won't work anymore."
19:36:43 <robreim> d'oh. I always wanted to use monad comprehensions :(
19:36:46 <Cale> "Let's add fail in place of mzero, and stick it in the Monad class."
19:36:51 <narain> mbishop: the main advantages wadler cites are pattern matching, syntax closer to traditional math, a powerful type system, and lazy evaluation
19:37:16 <narain> mbishop: yeah, i had a vague idea it was him but i didn't remember for sure
19:37:23 <robreim> Cale: are there any proposals to get it put back in in haskell'?
19:37:27 <bd_> Cale: hm, with -fallow-undecidable-instances and -fallow-overlapping-instances you could write a new monad class, and make the H98 and H1.4 versions imply each other...
19:37:33 <mbishop> narain: well pattern matching is nice, although again, I find you can get COND to be pretty close, also pattern matching isn't just a haskell thing
19:37:58 <mbishop> narain: and I'll give him the traditional math thing, and typing, well you can argue about that forever heh
19:38:04 <narain> well the paper actually uses miranda and not haskell :)
19:38:11 <mbishop> and scheme has optional lazy evaluation I believe :P
19:38:38 <bd_> Cale: though MonadZero would be tricky I admit
19:38:45 <Cale> robreim: I hope so, I haven't been following the H' list as closely as I should.
19:38:53 <Cale> bd_: tricky?
19:39:00 <Cale> oh
19:39:09 <narain> mbishop: lazy evaluation in scheme? how? do you mean by just wrapping stuff in a lambda?
19:39:15 <Cale> To get MonadZero back without disturbing things you mean.
19:39:22 <robreim> scheme's default evaluation is still strict though. I think lazy evaluation makes a much better default. lazy = expressive, strict = optimisation.
19:39:26 <mdmkolbe> how do you programaticly exit a Graphics.UI.GLUT application with just regular GLUT (i.e. no freeglut)
19:39:27 <mdmkolbe> ?
19:39:31 <Cale> Yeah, the right solution is just to fix it and break things slightly.
19:39:38 <bd_> I suppose instance (Prelude14.Monad m, Prelude14.MonadZero m) => Prelude.Monad m where ...
19:39:52 <Cale> and provide a compiler option to give back the Haskell 98 prelude.
19:40:10 <Cale> I also want the translation of do-syntax to be different
19:40:14 <narain> @docs Graphics.UI.GLUT
19:40:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/GLUT/Graphics-UI-GLUT.html
19:40:18 <Cale> and you can't fix that with a library
19:40:36 <narain> hmm.. don't see anything there
19:41:41 * Cale considers forking fptools.
19:41:55 <Cale> hmm, do I have the patience for that...
19:42:06 <robreim> Perhaps the right route for monad comprehensions would be to add them to GHC with a -f flag of some kind and use that as a precedent to get them into haskell'
19:42:35 <Cale> Oh, the patch to add monad comprehensions will be accepted if someone writes it.
19:42:40 <Cale> Simon says.
19:42:49 <mdmkolbe> monad comprehensions = ?
19:43:06 <Cale> mdmkolbe: Generalising list comprehensions to arbitrary instances of MonadZero
19:43:09 <yip> Cale: do you happen to know how killThread affects a running atomic block?
19:43:52 <Cale> mdmkolbe: Basically, list comprehensions are just sugar for the list monad operations together with guard.
19:44:15 <narain> :t \x -> x x
19:44:17 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
19:44:17 <lambdabot>     Probable cause: `x' is applied to too many arguments
19:44:26 <Cale> yip: hmm, I don't know, but it probably just doesn't allow the thing to commit.
19:44:37 <Cale> (probably just kills it off)
19:44:40 <mdmkolbe> Cale: could you give an example of these monad comprehensions?
19:44:48 <Cale> Sure.
19:44:49 <nornagon> @src foldl
19:44:50 <lambdabot> foldl f z xs = lgo z xs
19:44:50 <lambdabot>     where lgo z []     =  z
19:44:50 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
19:45:23 <yip> Cale: i'm afraid to use killThread since it's not clear how exactly it works
19:45:40 <yip> but i need it :/
19:46:07 <Cale> sequence (x:xs) = [y : ys | y <- x, ys <- sequence xs]
19:46:10 <sjanssen> yip: send an email to glasgow-haskell-users, you'll get a quick (1 day or so) response
19:46:21 <Cale> rather than:
19:46:26 <yip> sjanssen: oh?
19:46:42 <Cale> sequence (x:xs) = do {y <- x; ys <- sequence xs; return (y:ys) }
19:47:08 <Cale> It also incorporates guards in the case of instances of MonadZero, so...
19:47:43 <Cale> foo x = [z | y <- bar x, y < 10, z <- quux y]
19:47:52 <Cale> This could be a Maybe monad computation.
19:48:20 <Cale> Where, say bar returns a Maybe Integer
19:48:51 <mdmkolbe> Cale: how would the "y < 10" be translated?
19:49:00 <Cale> That whole thing would turn into:
19:49:24 <Cale> foo x = do { y <- bar x; guard (y < 10); z <- quux y; return z }
19:49:31 <mdmkolbe> @src guard
19:49:32 <lambdabot> guard True  =  return ()
19:49:32 <lambdabot> guard False =  mzero
19:49:51 <sjanssen> yip: yeah, Those With Knowledge generally respond quickly
19:50:05 <Cale> guard is a no-op in the case that the condition succeeds, and causes the computation to fail/backtrack if it doesn't.
19:50:42 <yip> sjanssen: hm, ok thanks
19:50:51 <mdmkolbe> Cale: cool.  I'd probably stick with "do" syntax since it's not inverted (the returned thing is at the end), but it would be nice to unify the two ideads of "do" and list comp
19:51:12 <Cale> mdmkolbe: Sometimes putting the returned thing at the beginning is natural.
19:51:23 <mdmkolbe> Cale: true
19:51:31 <robreim> Cale: what should MonadZero be capable of? Just providing a mzero method similar to fail or is there more?
19:51:35 <Cale> It also emphasizes the container analogy for monads.
19:52:28 <Cale> Basically, mzero >>= k = mzero
19:52:53 <Cale> also, if there's an mplus, you want some additional laws which tie in with mzero
19:52:58 <mdmkolbe> and m >>= const mzero = mzero
19:53:56 <Cale> hmm, I'm not sure about that one, but it's nice if you can get it.
19:54:17 <mdmkolbe> it's part of the MonadZero laws I thought
19:54:18 <Cale> (the only issue is that m might have effects which are impossible to revert)
19:54:40 <mdmkolbe> without it you wouldn't have a true mzero
19:54:56 <Cale> Yeah, it's probably a good idea. :)
19:55:53 <sjanssen> mdmkolbe: I don't think that is one of the MonadZero laws
19:56:23 <yip> Cale: is arrow syntax satisfactory?
19:56:26 <sjanssen> IO can't be a MonadZero with that law, for example
19:56:48 <mdmkolbe> sjanssen: as I recal, it isn't for presicely that reason
19:56:51 <Cale> The MonadPlus and MonadZero laws were actually a point of contention for a while. http://www.haskell.org/haskellwiki/MonadPlus along with the reform proposal is the general consensus, but is perhaps still a little shaky
19:56:52 <lambdabot> Title: MonadPlus - HaskellWiki
19:57:36 <wkh> cale, from your picture you look like you listen to Opeth, Ensiferum, and other metal bands.
19:57:39 <wkh> are you a metalhead?
19:57:44 <Cale> no
19:57:46 <wkh> :(
19:58:24 <yip> he looks just like your average hacker =]
19:58:30 <Cale> I actually listen to mostly jazz.
19:58:57 <Cale> And well, rock, blues, avant garde, whatever Zappa is.
19:59:01 <wkh> listenable stuff from the 50s or weirdo 60s/70s fusion
19:59:11 <Cale> Both.
19:59:23 <Cale> Tending toward the complex end of the spectrum though.
19:59:36 <mdmkolbe> I was going off of <http://www.nomaware.com/monads/html/laws.html>.  I'm suprized the category theorists couldn't have settled the question.
19:59:52 <Cale> Wayne Krantz is incredible. John Scofield as well.
20:00:22 <Cale> mdmkolbe: Well, the category theorists defined the monad laws anyway.
20:00:58 <Cale> But functional programmers seem to need more distinctions.
20:01:01 <mdmkolbe> Cale: that's what I mean.  Wouldn't they have defined the MonadZero laws
20:01:03 <Cale> at least, for the time being
20:01:27 <Cale> I don't think monoidal or pointed monads have been well-studied.
20:01:46 <Cale> Probably if it was anything, MonadZero would be called a pointed monad.
20:01:52 <Cale> But I don't know.
20:01:59 <yip> "I can write perfectly illegible code without using any of your fancy monads, thank you very much."
20:02:27 <Cale> yip: The arrow syntax is pretty good.
20:03:04 <Cale> yip: actually, I haven't *really* studied the translation process there, but it's grounded in the actual arrow combinators.
20:03:15 <Cale> and arrows don't have an extraneous fail.
20:03:19 <yip> Cale: yeah, but i don't think i'll ever really understand why they called it "returnA"
20:03:28 <Cale> hmm
20:03:29 <nornagon> foldr (-) [1,2,3,4] -- is this 1-(2-(3-4)) or ((1-2)-3)-4?
20:03:38 <Cale> because it's used similarly to return?
20:03:41 <nornagon> > foldr (-) [1..4]
20:03:42 <lambdabot>   add an instance declaration for (Num [t])
20:03:44 <robreim> Cale: reckon you might submit a patch for MonadZero + monad comprehensions then?
20:03:50 <nornagon> > foldr (-) 0 [1..4]
20:03:51 <lambdabot>  -2
20:04:04 <Cale> robreim: I would if I knew the GHC source code.
20:04:06 <nornagon> the former, then.
20:04:19 <nornagon> > foldl (-) 0 [1..4]
20:04:20 <mdmkolbe> nornagon: foldr = all the parens to the right (i.e. 1-(2-(3-4)))), foldl = all the parens to the left (i.e. (((1-2)-3-4))
20:04:20 <lambdabot>  -10
20:04:35 <nornagon> mdmkolbe: thanks :)
20:04:42 <Cale> also, fixing MonadZero would break H98 compatibility, so we need something more robust there.
20:05:01 <Cale> We need a way to provide multiple versions of the libraries.
20:05:21 <nornagon> mdmkolbe: and where does the 'seed' go in each one?
20:05:33 <nornagon> at the left?
20:05:45 <mdmkolbe> nornagon: it goes where the parens are bunched up
20:05:58 <robreim> Cale: some sort of -f flag?
20:05:58 <Cale> I really hope there's not too much inertia already.
20:06:02 <nornagon> ah, okay :)
20:06:07 <Cale> yeah
20:06:15 <Cale> I'd also really like to have a -101
20:06:15 <mdmkolbe> nornagon: i.e. (((seed-1)-2)-3) or (1-(2-(3-seed)
20:06:38 <Cale> for beginners
20:06:52 <mdmkolbe> nornagon: eh, I ment (1-(2-(3-seed))))
20:06:55 <Cale> though some people are vehemently opposed to that kind of stratification
20:07:00 <hpaste>  sarynx pasted "lame filesystem recursion" at http://hpaste.org/812
20:07:05 <Cale> and perhaps they are right in some ways
20:07:28 <Cale> But if so, then I don't want to hear arguments that some language features are too hard for beginners to cope with.
20:07:33 <robreim> Cale: sounds like a niche for a specialised academic version of haskell rather than a ghc flag to me
20:07:41 <nornagon> mdmkolbe: :)
20:08:03 <Cale> GHC isn't also academic?
20:08:12 <Cale> :)
20:08:15 <jaredj> ghc is doctoral
20:08:24 <Cale> Look at all the experimental stuff in there :)
20:08:28 <jaredj> (eep, i talked)
20:08:32 <Cale> jaredj: hehe
20:09:00 <robreim> Cale: not in the "learning haskell" sense :P
20:09:47 <Cale> Well, people do learn Haskell with GHC. I don't know how many users Helium has. Perhaps Helium was a bit too drastic in its simplification of the languages.
20:09:50 <Cale> -s
20:10:10 <jaredj> [OT: anyone care to give me pointers on how to de-uglify the above-pasted code?]
20:10:44 <jaredj> i don't really want to learn a subset of haskell, then the real thing
20:10:49 <Cale> nonTrivialItems = items \\ [".", ".."]
20:10:54 <Cale> :t (\\)
20:10:54 <jaredj> same with different compilers
20:10:57 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
20:10:58 <jaredj> oo cool thx
20:10:58 <robreim> Well, yeah. I learned haskell on GHC. Well, the second time I learned it anyway, first time was on gopher. I'm more saying that if there's a niche for a simplified haskell, it probably belongs in its own implementation.
20:11:07 <fax> > [1,2,3,4,5,6] \\ [3,4]
20:11:09 <lambdabot>  [1,2,5,6]
20:11:12 <jaredj> ah
20:11:13 <fax> cool
20:11:24 <Cale> and [isDirectory y, x `notElem` [".",".."]]
20:12:34 <jaredj> sigh
20:12:40 <jaredj> i don't disagree
20:12:52 <jaredj> but...
20:12:56 <wkh> > "blah" `elem` ["blah", "haskell has made me its bitch"]
20:12:57 <lambdabot>  True
20:13:09 <fax> O_o
20:13:12 <robreim> Actually, a simplified haskell might be as simple as bunging all the simplified stuff in its own module and getting learners to import that instead of prelude...
20:13:34 <fax> > 54 `div` 3
20:13:36 <lambdabot>  18
20:13:38 <fax> > 54 div 3
20:13:39 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
20:13:39 <lambdabot>     I...
20:13:47 <Cale> jaredj: looking for something more drastic?
20:13:48 <fax> whats the difference?
20:14:01 <Cale> > div 54 3
20:14:01 <wkh> the backtick lets you use any normal function as an infix operator
20:14:02 <lambdabot>  18
20:14:04 <fax> ooh
20:14:12 <fax> cool
20:14:17 <wkh> so you can use any function as infix if you think that will help
20:14:36 <fax> > `\\` [1,2,3,4,5,6] [1,2]
20:14:36 <lambdabot>  Parse error
20:14:39 <fax> >:(
20:14:49 <Cale> > (\\) [1..6] [1,2]
20:14:51 <lambdabot>  [3,4,5,6]
20:14:58 <wkh> yeah you have to wrap it with ()'s for some reason.
20:15:00 <Cale> Parens go the other way
20:15:08 <fax> hehe :D
20:15:16 <Cale> > (`div`) 54 3
20:15:17 <lambdabot>  Parse error
20:15:25 <jaredj> cale: by all means
20:15:26 <fax> > [1..6] `(//)` [2,3]
20:15:26 <lambdabot>  Parse error
20:15:30 <fax> :o
20:15:39 <Cale> > [1..6] `(\\)` [2,3]
20:15:39 <lambdabot>  Parse error
20:15:40 <fax> why is it a parse error?
20:15:43 <dibblego> > let f = (\\) in [1,2,3,4,5,6] `f` [1,2]
20:15:45 <lambdabot>  [3,4,5,6]
20:16:01 <Cale> The syntax doesn't allow for it, I suppose. :)
20:16:12 <mdmkolbe> @pl (\x -> f x >>= g)
20:16:12 <lambdabot> (g =<<) . f
20:16:17 <Cale> jaredj: hmm...
20:16:23 <sjanssen> only function names can go between ` `
20:16:36 <fax> wjh?
20:16:36 <wkh> if you don't know what monads are, the sight of a function named ">>=" or "=<<" is kind of disconcerting
20:16:44 <wkh> IMO
20:16:55 <jaredj> cale: particularly, i find a <- blah b, let c = blah a, d <- blah c distasteful
20:17:05 <Cale> jaredj: why is that?
20:17:17 <sjanssen> it is interesting that this doesn't work:
20:17:21 <fax> can you write `` and () ?
20:17:24 <wkh> :t (<-)
20:17:26 <bd_> jaredj: c <- fmap blah (blah' b) :)
20:17:26 <lambdabot> parse error on input `<-'
20:17:30 <sjanssen> > (`div`) 10 2
20:17:31 <lambdabot>  Parse error
20:17:36 <wkh> @type (<-)
20:17:37 <jaredj> ah
20:17:38 <lambdabot> parse error on input `<-'
20:17:40 * jaredj looks up fmap. again
20:17:42 <bd_> jaredj: or liftM
20:17:45 <mdmkolbe> @type (->)
20:17:48 <lambdabot> parse error on input `->'
20:17:55 <jaredj> that's what i was trying to think of, one of those two
20:18:00 <bd_> they're the same for monads, but not all monads define fmap, unfortunately
20:18:01 <Cale> -> and <- are special parts of syntax
20:18:08 <Cale> so you can't use them as infix operators
20:18:12 <nornagon> yip: i just tried it with -O and it's not much faster at all
20:18:25 <mdmkolbe> @kind (->)
20:18:28 <lambdabot> ?? -> ? -> *
20:18:29 <Cale> ah okay, yeah, you can use fmap
20:18:31 <fax> lol
20:18:51 <robreim> Is there any example of a Monad which can not also be a Functor?
20:19:00 <mdmkolbe> I understand the '*' kind, but what are '?' and '??'?
20:19:04 <Cale> robreim: no, by definition
20:19:08 <fax> mdmkolbe: what is *?
20:19:14 <Cale> robreim: A monad is a special kind of functor.
20:19:33 <robreim> that's what I thought. So why doesn't Monad just require a data type to first be a member of Functor and get rid of liftM?
20:19:33 <Cale> robreim: In fact, it's a bit of a mistake that the Monad class isn't a subclass of Functor.
20:19:49 <bd_> mdmkolbe, fax, * is a boxed type, ?? is a boxed or primitive type, ? is a boxed type, primitive type, or unboxed tuple, I believe. All but the boxed type are GHC internals :)
20:19:51 <Cale> Because some people want to allow other people to be lazy.
20:20:03 <fax> ohh ok thanks
20:20:11 <mdmkolbe> fax: 'kind' is the type of a type.  a '*' is a regular type like Char or (Maybe Char), a '*->*' is a type constructor like Maybe.
20:20:18 <Cale> liftM should probably be left in, but only as a default implementation for map
20:20:22 <fax> @kind Maybe
20:20:24 <lambdabot> * -> *
20:20:28 <robreim> Oh ok. Hmm. It would be nice if instantiating Monad automatically made the data type a member of Functor.
20:20:37 <bd_> Cale: instance Monad m => Functor m where fmap = liftM
20:20:38 <bd_> ?
20:20:38 <Cale> That's true as well.
20:20:45 <mdmkolbe> @kind Maybe Char
20:20:48 <lambdabot> *
20:20:53 <mdmkolbe> @kind Char
20:20:55 <fax> > (+) 1 1 1 1 1 1 1 1
20:20:55 <lambdabot> *
20:20:56 <lambdabot>        add an instance declaration for
20:20:56 <lambdabot>       (Num (t -> t1 -> t2 -> t3 -> t4 ...
20:20:57 <mdmkolbe> @kind Maybe
20:20:59 <lambdabot> * -> *
20:21:00 <Cale> bd_: the problem with that is that it'll overlap with everything
20:21:22 <fax> > (+) (+) (+) 1 1 1 1 1
20:21:23 <lambdabot>        add an instance declaration for (Num (t -> t1 -> t2 -> a))
20:21:26 <wkh> > foldl1 (+) [1, 1, 1, 1, 1, 1]
20:21:27 <fax> hmpf :[
20:21:28 <lambdabot>  6
20:21:29 <bd_> Cale: -fallow-overlapping-instances? >.>
20:21:31 <Cale> (even things which are not explicitly instances of Monad, because some future module might make them instances of monad)
20:21:47 <mdmkolbe> @type (:-)
20:21:49 <lambdabot> Not in scope: data constructor `:-'
20:21:51 <wkh> @type (+)
20:21:54 <lambdabot> forall a. (Num a) => a -> a -> a
20:21:57 <mdmkolbe> @type (>.>)
20:22:00 <lambdabot> Not in scope: `>.>'
20:22:08 <wkh> evidently + only takes 2 parameters rather than many parameters as in common lisp
20:22:10 <bd_> or, class Functor f => Monad m, but this would be annoying to implement.
20:22:16 <fax> < (+) ((+) ((+) ((+) ((+) 1 1) 1) 1) 1) 1
20:22:26 <fax> > (+) ((+) ((+) ((+) ((+) 1 1) 1) 1) 1) 1
20:22:28 <lambdabot>  6
20:22:34 <jaredj> mdmkolbe hehehe
20:22:38 <wkh> fax: looks like you expanded out a foldl call by hand
20:22:40 <fax> why is the order of evaluation backwrads
20:22:52 <jcreigh> fax: backwords? how so?
20:22:52 <bd_> > let (>.>) = (>) in 5 >.> 6
20:22:54 <lambdabot>  False
20:23:02 <Cale> bd_: huh?
20:23:03 <dibblego> fax, how is it backwards?
20:23:13 <mdmkolbe> fax: maybe because you did foldl instead of foldr or vise versa?
20:23:13 <fax> I would think: (+) (+) 1 1 1 should evaluate to 3
20:23:14 <wkh> kirby functions!!!!
20:23:17 <bd_> Cale: well, you'd have to implement functor for every monad you might make
20:23:18 <jaredj> cale: an excuse for >.>
20:23:20 <Cale> bd_: class Functor m => Monad m is what is proposed already.
20:23:30 <TSC> fax: It's parsed incorrectly
20:23:32 <mdmkolbe> fax: function application is left associative
20:23:32 <Cale> bd_: well, yes, but you can do so with 2 lines.
20:23:44 <jaredj> let O_o = _|_ in O_o
20:23:44 <dibblego> CAL has Monad as a subclass of Functor
20:23:45 <fax> > (+) 1 1 + 1
20:23:46 <lambdabot>  3
20:23:47 <jaredj> oops
20:23:48 <bd_> Cale: I suppose, it just seems like it should be smart enough to derive fmap given bind and return
20:23:51 <TSC> By "incorrect" I mean "not what you expected" (:
20:23:53 <Cale> actually, it would be nice if we could write something like:
20:24:04 <Cale> class Functor m => Monad m where
20:24:11 <Cale>   instance Functor m where
20:24:18 <mdmkolbe> fax: f x y z == (((f x) y) z)
20:24:27 <fax> ooh
20:24:39 <bd_> instance (Functor m, MonadJoin m) => MonadBind m where (>>=) m f = join (fmap f m)
20:24:39 <yip> Cale: have you seen this? http://programming.reddit.com/info/183jt/comments
20:24:40 <Cale>    map f x = return . f =<< x
20:24:41 <lambdabot> Title: STMlib: a user-space STM library for OCaml (reddit.com)
20:24:44 <fax> :D
20:25:11 <bd_> instance (MonadBind m, MonadReturn m) => MonadJoin m where join m = m >>= id
20:25:12 <Cale> and that instance would be used iff there is no visible instance of Functor when the instance of Monad is defined.
20:25:31 <fax> can I make a function which returns either a new function or a number?
20:25:33 <Cale> That is, it acts a bit like default method declarations.
20:25:47 <Cale> yip: yes.
20:25:50 <mdmkolbe> @info Either
20:25:50 <lambdabot> Either
20:25:55 <fax> awesp,e "
20:25:57 <fax> thanks
20:26:41 <Cale> :kind Either
20:26:45 <Cale> @kind Either
20:26:48 <lambdabot> * -> * -> *
20:26:55 <Cale> :t Left
20:26:58 <lambdabot> forall a b. a -> Either a b
20:27:01 <Cale> :t Right
20:27:03 <lambdabot> forall b a. b -> Either a b
20:27:10 <mdmkolbe> @src Either
20:27:10 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:27:44 <Cale> I wonder where lambdabot got its library of insults.
20:28:20 <jcreigh> Cale: so you're suggesting, what, an @insult-add command? :)
20:28:22 <robreim> Who's idea was it to make lambdabot insult people anyway?
20:28:42 <dons> i'd had too much wine on new year's eve
20:28:51 <mdmkolbe> they aren't even very good insults
20:29:08 <dons> the insults are from the openbsd sudo implementation, they're classix unix insults going back to the early BSD system
20:29:12 <dons> circa 1980
20:29:22 <jcreigh> cool, some fun history.
20:29:24 <Korollary> I bet they weren't warmly received back then, either.
20:29:31 <jcreigh> well, yes, but they
20:29:37 <dons> if anyone cares enough, submit a patch to disable them.
20:29:39 <jcreigh> 're called "insults" for a reason. :)
20:29:51 <dons> this is a do-ocracy. if you do it, it gets done. if you don't , stop complaining ;)
20:30:20 <bos> doesn't that desugar to a >>=ocracy?
20:30:46 <dons> heh
20:30:47 <bos> >>= \ocracy -> undefined
20:30:51 <bd_> bos: Nah, clearly it's isomorphic to a join.fmapocracy
20:31:27 <bos> i had a long chat with an editor at o'reilly today about a haskell book.
20:31:33 --- mode: ChanServ set +o dons
20:31:36 --- topic: set to '["The Haskell programming language: this is an monadocracy!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
20:31:41 --- mode: ChanServ set -o dons
20:31:47 <dons> bos, oh? do tell!
20:32:12 <bos> they're quite interested in publishing one, but have not found an author yet.
20:32:23 <dons> hmm.
20:32:26 <LoganCapaldo> Yes, what animal will they use for the cover? (the most important question for any O'Reilly book)
20:32:37 <chessguy> a lambda of course
20:32:40 <mwc> Hmmmm, in the docs for Data.ByteString.Lazy, quoth: Some operations, such as concat, append, reverse and cons, have better complexity than their Data.ByteString equivalents, due to optimisations resulting from the list spine structure.
20:32:47 <rahikkala> If it's Unix tradition that we want, you could replace the insult with "Meditate in this instead: " followed by a short fortune :)
20:32:47 <rahikkala> *on
20:32:51 <mwc> but then in th edocs it gives the complexity of append as O(n)
20:32:53 <wkh> a sloth!
20:32:57 <wkh> because haskell is lazy!
20:32:58 <dons> bos, so do they have a strategy for finding an author?
20:33:03 <LoganCapaldo> chessguy, african or eurpean lambda?
20:33:06 <mwc> so... not asymptotically better, but better wrt a constant factor?
20:33:18 <chessguy> LoganCapaldo, depends on if they want it to migrate
20:33:18 <bos> well, phil wadler doesn't want to write about haskell. simonpj is travelling.
20:33:20 <dons> mwc, oh, append is O(n/k)
20:33:32 <dons> yeah, spj is at redmond this week
20:33:34 * chessguy volunteers dons to write the book
20:33:43 * wkh seconds
20:33:44 <bos> he's dueling the f# people :-)
20:33:45 <dons> thanks chessguy. my supervisor would love that.
20:34:11 * LoganCapaldo carries the motion
20:34:12 <bos> i'll probably post a note to haskell-cafe in a few days.
20:34:13 <chessguy> bos, do they have a particular approach in mind for the book? or just "a book about haskell"?
20:34:17 <mdmkolbe> well we already have SOE
20:34:19 <dons> what kind of book are they thinking about? "practical haskell"? something like the new erlang book?
20:34:24 <fax> how do I say a function which returns either X or an Integer
20:34:28 * chessguy beats dons to it
20:34:28 <fax> X is what I just said
20:34:38 <bos> they don't know anything about haskell, or what the community needs. so i'm kind of their source of clue for now.
20:34:45 <wkh> > Either "X" 9
20:34:46 <lambdabot>   Not in scope: data constructor `Either'
20:34:52 <wkh> hm
20:34:52 <LoganCapaldo> f :: a -> Either X Int
20:34:57 <fax> wkh: by X I mean, what I just said
20:34:57 <chessguy> @type Either "X" 9
20:35:00 <lambdabot> Not in scope: data constructor `Either'
20:35:01 <fax> but its an infinite loop
20:35:03 <LoganCapaldo> > Left "X"
20:35:03 <mwc> dons, is the appending done with a shows sort of approach? I mean, is it safe to use LazyByteString as the monoid in a Reader?
20:35:04 <lambdabot>  Left "X"
20:35:06 <fax> haha
20:35:09 <LoganCapaldo> > Right 9
20:35:09 <wkh> > Right 9
20:35:11 <mwc> s/safe/smart
20:35:11 <lambdabot>  Right 9
20:35:12 <lambdabot>  Right 9
20:35:19 <bos> i'm going to write up a strawman book outline and post it in a few days, and people can fire their slings and arrows at it.
20:35:28 <fax> I mean I want a function which can return either, a function or an integer
20:35:31 <mdmkolbe> fax: data X = AnX (Int -> X) | AnInt Int
20:35:33 <wkh> bos: don't fuck this up plz :(
20:35:36 <mwc> I'm basically asking if the lazyness can save my ass there
20:35:52 <mwc> er, monoid in a Writer of course
20:36:03 <LoganCapaldo> Either (a -> a) Int works too
20:36:06 <wkh> fax: that would be encapsulated by Either (a->b) Int
20:36:06 <bos> wkh: i'm not in the habit of fucking things up. but thank you, i will of course bear that in mind.
20:36:07 <jaredj> bos: outrageous!
20:36:17 <jaredj> bos: and hopefully fortunate!
20:36:28 <bos> i'm by no means attached to the idea of writing anything by way of a book. writing books sucks.
20:36:29 <LoganCapaldo> (meant to type a -> b, a -> a came out for some reason)
20:36:45 <bos> but if nobody else steps up, the book needs writing.
20:36:51 <LoganCapaldo> If I wasn't so newb I'd love to take a crack at it
20:36:56 <jaredj> tis a consummation devoutly to be writ.
20:37:02 <fax> whats a and b?
20:37:13 <chessguy> thank you sir jared shakespeare
20:37:14 <jaredj> fax: any two types
20:37:18 <bos> i'd much rather read someone else's book :-)
20:37:18 <fax> oh cool
20:37:19 <jaredj> hehehe
20:37:19 <wkh> fax: a and b are type parameters. "a->b" means a function taking type a and returning type b
20:37:20 <LoganCapaldo> just examples
20:37:32 <wkh> @type head
20:37:34 <lambdabot> forall a. [a] -> a
20:37:40 <wkh> see, it's generic over the type
20:37:48 <jaredj> :d irc is bad for my concentration
20:37:50 <dons> bos, right. hmm. i'm sure we can find someone willing and capable
20:38:16 <LoganCapaldo> irc is a time burglar
20:38:24 <wkh> despite my lack of expertise, i'd suggest not trying to give examples of stuff haskell doesn't do very well. focus on its strengths
20:39:29 <dons> wkh, why do you think the erlang book was all about concurrency? :-)
20:39:32 <dons> and not regexes
20:39:58 <bos> dons: i hope so.
20:40:03 <yip> its strengths? you mean haskell has weaknesses? :o
20:40:12 <chessguy> you mean it wasn't because concurrency's just such a fascinating topic?
20:40:23 <wkh> haskell to me is not a language for creating a boilerplate CRUD web app
20:40:32 <dons> bos, i'll see if i can think of some people. we do have an awful lot of authors in the community, after all.
20:40:33 * araujo wonders if there is anybody good with c2hs around here
20:40:46 <jaredj> anyone seen the pessimal algorithms paper?
20:40:59 <jaredj> i think you can do those with haskell
20:41:02 <bos> dons: thx
20:41:05 <jaredj> (as well as optimal ones)
20:41:06 <chessguy> ?all-dict pessimal
20:41:08 <lambdabot> *** "pessimal" gcide "The Collaborative International Dictionary of English v.0.48"
20:41:09 <lambdabot> pessimal \pes"si*mal\ adj.
20:41:09 <lambdabot>    Least favorable for survival; -- of an organism's
20:41:09 <lambdabot>    environment.
20:41:09 <lambdabot>  
20:41:10 <lambdabot> [29 @more lines]
20:41:12 <fax> pacman n = (\ x -> n + x)
20:41:17 <fax> I cant do this?
20:41:21 <jaredj> opposite of optimal, of course
20:41:29 <fax> in ghci it says parse error on  =
20:41:33 <LoganCapaldo> [69, 114, 108, 97, 110, 103, 32, 115, 116, 114, 105, 110, 103, 115, 32, 97, 114, 101, 32, 97, 119, 101, 115, 111, 109, 101, 33]
20:41:56 <fax> oh I have to let..
20:42:03 <jcreigh> lisp seems kinda primitive after using Haskell; seems like it can't detect anything other than an unmatched paren at compiletime...
20:42:04 <wkh> if you're at the REPL, yes
20:42:11 <jcreigh> (I know, not quite, but it kinda feels that way)
20:42:18 <fax> jcreigh: why does that seem primitive?
20:42:19 <wkh> > let pacman n = (\x -> n+x) in pacman 10
20:42:20 <lambdabot>  <Integer -> Integer>
20:42:32 <wkh> > let pacman n = (\x -> n+x) in (pacman 10) 12
20:42:33 <lambdabot>  22
20:42:46 <wkh> > let pacman n = (\x -> n+x) in pacman 10 $ 12
20:42:48 <lambdabot>  22
20:42:50 <jcreigh> fax: I'm not used to having to actually *call* a function in order to determine whether, eg, the number of arguments is wrong.
20:42:51 <dolio> > let pacman = (+) in (pacman 10) 12
20:42:53 <lambdabot>  22
20:43:02 <jaredj> oh, it's the >, i see
20:43:04 <jaredj> > 42
20:43:05 <lambdabot>  42
20:43:08 <jaredj> k
20:43:20 <jaredj> jcreigh: heh. it's that way in python too
20:43:24 <chessguy> @pl p n = \x -> x + n
20:43:25 <lambdabot> p = (+)
20:43:27 <chessguy> :)
20:43:45 <jaredj> what's @pl short for
20:43:50 <chessguy> @help pl
20:43:50 <lambdabot> pointless <expr>. Play with pointfree code.
20:44:07 * jaredj runs screaming from the point
20:44:09 <jcreigh> jaredj: it rewrites your code in so-called "points free" style
20:44:43 <jaredj> this is the same poi... oh wait, that's a "fixed point."
20:44:44 <wkh> when you write it, you are awarded no points at all. it's kind of a drag.
20:44:53 <jaredj> bahahah
20:45:03 <jaredj> yes, it's pointless
20:45:09 <jaredj> (you made me!)
20:45:11 <fax> @pl fac n = if n > 0 then n * fac (n-1) else 1
20:45:12 <lambdabot> fac = fix (flip flip 1 . liftM2 if' (> 0) . ap (*) . (. subtract 1))
20:45:14 <fax> hehee
20:45:20 <QtPlatypus> What is the advantage of "points free" style.  From all I've seen of it is its a great way to make your code unreadable.
20:45:24 <jaredj> aaaaaaa fix
20:45:37 <ozone> dons: 'twas wolfgang's decision to use libffi in HOC
20:45:43 <dolio> It makes you a bigger hit with the ladies.
20:45:46 <jaredj> oh heh yeah i forgot how point-free code has lots of '.' in it :)
20:45:47 <jcreigh> QtPlatypus: sometimes it's just obfuscation. (I think it should be avoided in that case, obviously.)
20:45:54 <LoganCapaldo> QtPlatypus: its crunchy and delicious
20:45:57 <ozone> i told him about it without having much of a look at it, and next i know, he was using it
20:46:06 <chessguy> @type (fix (flip flip 1 . liftM2 if' (> 0) . ap (*) . (. subtract 1)))
20:46:09 <lambdabot> Not in scope: `if''
20:46:21 <dolio> And it can be nice for stream processing type stuff, once you get used to it.
20:46:26 * chessguy icks the bot
20:46:31 <chessguy> +k
20:46:33 <wkh> > let count w = length . filter(==w) . words in count "blah" "blah feh meh blah"
20:46:35 <lambdabot>  2
20:46:46 <chessguy> > (fix (flip flip 1 . liftM2 if' (> 0) . ap (*) . (. subtract 1))) 5
20:46:47 <lambdabot>   Not in scope: `if''
20:46:54 <chessguy> ?hoogle if'
20:46:54 <lambdabot> No matches found
20:46:58 <slowriot> QtPlatypus: "point free" programming is pointless.
20:47:02 <chessguy> ?hoogle if
20:47:03 <lambdabot> Prelude.if :: keyword
20:47:03 <lambdabot> Foreign.C.Error.throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
20:47:03 <lambdabot> Foreign.Marshal.Error.throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
20:47:03 <jaredj> wkh, that's a good one. unlike this fix flippy flip thing.
20:47:04 <araujo> QtPlatypus, you can make more concise code
20:47:07 <slowriot> ... get it? hyuk hyuk hyuk
20:47:15 <fax> > let pacman n x y = if n<0 then x else pacman n-1 x+y
20:47:16 <lambdabot>  Parse error
20:47:19 <fax> :(
20:47:24 <LoganCapaldo> @type let if' a b c = case a of { True -> b ; False -> c } in (fix (flip flip 1 . liftM2 if' (> 0) . ap (*) . (. subtract 1)))
20:47:27 <lambdabot> forall c. (Ord c, Num c) => c -> c
20:47:47 <fax> > let pacman n x y = if n<0 then x else (pacman (n-1) (x+y))
20:47:48 <lambdabot>  Parse error
20:47:52 <fax> can I do this?
20:47:59 <jcreigh> QtPlatypus: but it's nice to be able to say, eg, filter (not . isDigit) xs without having to say "filter (\x -> not (isDigit x)) xs" (small example, I know)
20:48:09 <chessguy> fax apparently not
20:48:12 <fax> LOL
20:48:16 <fax> can it be done?
20:48:17 <wkh> fax: you're calling a 3-parameter function with 2 parameters
20:48:24 <fax> wkh: I want to curry
20:48:33 <QtPlatypus> > 143.00 / 1.1
20:48:35 <lambdabot>  130.0
20:48:36 <dolio> You're missing the "in" portion of the let expression.
20:48:47 <mwc> fax, it can be done, but lambdabot want's in's as part of its toplevel
20:48:50 <rahikkala> QtPlatypus: Also, along with fix, you can use it to produce amusingly powerful Haskell golf oneliners
20:48:52 <mwc> > let foo = 5
20:48:52 <lambdabot>  Parse error
20:48:55 <mwc> >let foo = 5 in foo
20:48:57 <chessguy> fax, you can't return two different types in two different cases
20:48:57 <fax> what do I need for in
20:49:14 <fax> > let pacman n x y = if n<0 then x else (pacman) (n-1) (x+y) in pacman 3 1 2 3
20:49:15 <wkh> you just type let <decl> in <expr>
20:49:15 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1 -> t
20:49:16 <lambdabot>     Probab...
20:49:21 <chessguy> fax, you're returning x in one case, and a function in another
20:49:28 <fax> yes thats why I use Either
20:49:29 <allbery_b> an invcation of pacman, presumably, since you defined it presumably with intent to use it
20:49:31 <fax> pacman :: Either (a -> b) Int
20:49:51 <LoganCapaldo> you have to actually use either :)
20:49:52 <jaredj> fax: let pacman n x y = if n<0 then Left x else Right $ (pacman) (n-1) (x+y)
20:50:14 <jaredj> think i got the $ right
20:50:21 <fax> :S
20:50:24 <jaredj> er.
20:50:26 <chessguy> you don't need parens around pacman
20:50:29 <allbery_b> pacman doesn;t need to be parenthesized
20:50:33 <jaredj> switch Left and Right to make it fit your type
20:50:45 <fax> > let pacman n x y = if n<0 then x else pacman (n-1) (x+y) in pacman 3 1 2 3
20:50:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
20:50:46 <lambdabot>     Probabl...
20:50:48 <fax> argh!
20:50:50 <allbery_b> and in your invocation above you gave pacman an extra argument
20:50:54 <chessguy> @type let pacman n x y = if n < 0 then Left x else Right $ pacman (n-1) (x+y)
20:50:55 <fax> why is it saying that
20:50:56 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
20:50:56 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
20:50:56 <lambdabot>  
20:51:01 <allbery_b> pacman n x y ... pacman 3 1 2 3
20:51:03 <jaredj> allbery_b: he's trying to curry. (or she.)
20:51:10 <chessguy> @type let pacman n x y = if n < 0 then Left x else Right $ pacman (n-1) (x+y)
20:51:11 <allbery_b> oh
20:51:12 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
20:51:13 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
20:51:13 <lambdabot>  
20:51:22 <fax> I am so muddled :D
20:51:33 <fax> I think ill read some tutorials
20:51:33 <bd_> looks like a minor bug >.>
20:51:39 <allbery_b> so is lambdabot, evidently
20:51:53 <jaredj> heh
20:51:58 <wkh> is this the blind leading the blind?
20:52:10 <robreim> So I'm writing a monadic interface for TCP and UDP operations. I'd like to provide some sort of getLine function for TCP monads but I want to do it in a buffered way such that a malicious peer can't send 10 GB of crap on a single line and fill the server's memory. Any ideas on how to write such a getLine?
20:52:13 <jaredj> i can't quite see it
20:52:17 <jaredj> i think not
20:52:18 <jaredj> ;)
20:52:20 <LoganCapaldo> @typ let pacman n x y = if n < 0 then Left x else Right $ pacman (n-1) (x+y) in pacman
20:52:22 <lambdabot>     Occurs check: cannot construct the infinite type:
20:52:23 <lambdabot>       b = a -> Either a b
20:52:34 <robreim> I keep thinking laziness would help, but hGetContents doesn't look like what I want.
20:52:53 <chessguy> yeah, it's an infinite type
20:52:58 <allbery_b> oh, duh
20:53:03 <jaredj> robreim: hmm. for files, it works, maybe not for sockets
20:53:05 <wkh> what's an infinite type?
20:53:08 <chessguy> because the type of the right-hand side is dependent on the type of pacman
20:53:18 <allbery_b> what's your end condition that returns a Right?
20:53:25 <allbery_b> since pacman returns an Either
20:53:30 <bd_> robreim: liftM (map (take <line limit>) . lines) (hGetContents handle) ...
20:53:30 <robreim> jaredj: no, I don't think so. That "semi-closed state" doesn't look like what I want.
20:53:31 <bd_> but!
20:53:33 <bd_> the danger of this
20:53:44 <bd_> is if you step beyond an overlength line
20:53:51 <bd_> it'll iterate until it hits the end of the line
20:53:53 <bd_> though in O(1) space
20:54:07 <jaredj> ^^^ yeah, that.
20:54:09 <fax> ok I have a question :D
20:54:11 <fax> > let multiplier n = (\x -> x * n) in (multiplier 5) 3
20:54:13 <lambdabot>  15
20:54:15 <fax> this seems to work ok
20:54:21 <fax> but when I do (multiplier 0)
20:54:22 <jaredj> k
20:54:24 <robreim> bd_: is hGetContents safe for sockets?
20:54:27 <allbery_b> also, if I drop the Right I find that pacman is being reinvoked with to few parameters
20:54:33 <fax> it goes through the calculation of 0 * x every time
20:54:37 <chessguy> ghci gives a little bit clearer error:
20:54:38 <chessguy>     Occurs check: cannot construct the infinite type:
20:54:38 <chessguy>       b = a -> Either a b
20:54:38 <chessguy>       Expected type: Either a b
20:54:38 <chessguy>       Inferred type: Either a (a -> Either a b)
20:54:44 <bd_> robreim: Only if the other end doesn't block on data you're sending it.... or you're very, very careful
20:54:46 <robreim> For example the description of sendTo warns about its use of hGetContents
20:54:48 <fax> how do you change it to do if n = 0 return 0 else return (\x -> x * n) ?
20:55:00 <chr1s__> hey everone
20:55:01 <bd_> robreim: Actually, I'm not sure if hGetContents will close for sending come to think of it
20:55:04 <chessguy> (wow, i never thought i'd be saying that ghci gave me a clear error)
20:55:11 <chr1s__> I'm trying to optimize my prettyprinter
20:55:12 <jcreigh> multiplier 0 n = 0
20:55:18 <jcreigh> multiplier n m = n * m
20:55:27 <chr1s__> I now have every method of type :: String
20:55:29 <jcreigh> fax: ^^
20:55:39 <fax> jcreigh: but I want to return a function for n m
20:55:41 <chr1s__> but I heard that it would be better to have String->String
20:55:45 <fax> and 0 otherwise
20:55:47 <allbery_b> tha's automatic
20:55:51 <chr1s__> is that true?
20:55:53 <fax> ooh
20:55:59 <jcreigh> fax: right, but it's automatically curried
20:56:05 <allbery_b> multiplier n m becomes multiplier = \n -> \m -> ...
20:56:06 <LoganCapaldo> fax: you can't return 0 or some function
20:56:13 <fax> LoganCapaldo: I need to :|
20:56:15 <jcreigh> let foo a b = a + b in (foo 2) 6
20:56:19 <jcreigh> > let foo a b = a + b in (foo 2) 6
20:56:20 <lambdabot>  8
20:56:22 <allbery_b> haskell automatically curries ffunctions
20:56:30 <jaredj> ^^
20:56:34 <fax> It was just an example for somthing else I want to do though
20:56:41 <fax> hmm
20:56:44 <fax> maybe I can use it though
20:56:44 <jcreigh> fax: that's why f x y z is (((f x) y) z)
20:57:15 <jcreigh> because f x yields a function which we apply y to, which yields a function, which we apply z to.
20:57:25 <fax> but I cant enter that into ghci..
20:57:36 <fax> fac :: Integer -> Integer \n fac 0 = 1 \n fac n | n > 0 = n * fac (n-1)
20:57:41 <fax> for example, gives me errors
20:58:05 <wkh> fax: do you want to see a blog entry i just wrote where i collected the things i've found useful in learning haskell?
20:58:14 <fax> wkh: that would be fantastic
20:58:18 <jaredj> fax: that's because ghci doesn't like things that span multiple lines, afaik
20:58:22 <wkh> http://metacircular.wordpress.com/2007/03/05/a-haskell-study-plan/
20:58:24 <lambdabot> Title: A Haskell study plan  Metacircular thoughts, http://tinyurl.com/ystyev
20:58:29 <LoganCapaldo> fax: ghci has limited syntaxcx
20:58:36 <jcreigh> fax: there's ways to enter functions into ghci, but you have to kind of clever about it. It's easiest just to put your functions into a file and then load them in ghci.
20:58:36 <LoganCapaldo> stick it in a file
20:58:43 <fax> alright cheers
20:58:45 <wkh> then do :l name_of_file
20:58:49 <LoganCapaldo> and do ghci yourfile.hs to play with it
20:58:52 <wkh> or that
20:59:00 <fax> ah cool :D
20:59:00 <jaredj> jcreigh: {}; ?
20:59:09 <allbery_b> ghci also lets you do, as a temporary binding:
20:59:25 <robreim> bd_: ok, I'll have a play with hGetContents and failing that I guess I'll try just reading n characters at a time and return some other value if the line isn't complete or something.
20:59:37 <jcreigh> fax: also, if you have your file loaded in ghci, you can just type :r to reload instead of :l filename.hs (bit of a timesaver)
20:59:49 <allbery_b> let fac :: Integer -> Integer; fac 0 = 1; fac n | n > 0 = n * fac (n - 1); fac _ = error "negative factorial"
20:59:50 <fax> oh cool
20:59:55 <allbery_b> (without the "in")
21:00:09 <allbery_b> you can use that until the next time you :l or :r
21:00:26 <allbery_b> (note I added a catch-all case for nagatives because I don't like partial functions)
21:00:39 <jcreigh> jaredj: hmm, using explict layout works? Okay, I hadn't really thought about it; I find it easiest to just stick it in a file, since I'm probably going to want in a file anyway.
21:01:07 <jaredj> jcreigh: shrug, i haven't tried it, i was asking what you meant by "clever". i just stick it in a file too
21:01:32 <jaredj> oh.
21:01:36 * jaredj reads allbery_b
21:01:42 <fax> does fac :: Integer -> Either Integer (a -> b), mean it can return an integer or a function from a to b?
21:01:57 <fax> because I am getting an error for the line that returns (\x -> x * n)
21:02:07 <allbery_b> yes, but the Integer must be tagged with Left and the function with Right
21:02:12 <fax> oh !
21:02:16 <allbery_b> @src Either
21:02:17 <lambdabot> Source not found. I feel much better now.
21:02:19 <allbery_b> oops
21:02:23 <allbery_b> oh well
21:02:31 <allbery_b> anyway, data Eitheer a b = Left a | Right b
21:02:47 <LoganCapaldo> but but, @src Maybe works, why not Either?
21:02:50 <allbery_b> so you use the Left constructor to return an a, or the Right constructor to return a b
21:02:50 <LoganCapaldo> :(
21:02:58 * LoganCapaldo forgot we live in a do-ocracy
21:03:01 <jaredj> lambdabot: lol
21:03:08 <jaredj> @lol
21:03:09 <lambdabot> Maybe you meant: let pl url yow
21:03:13 <jaredj> meh
21:03:20 <LoganCapaldo> @botsnack
21:03:21 <lambdabot> :)
21:03:22 <allbery_b> @yow
21:03:22 <lambdabot> ... I have read the INSTRUCTIONS ...
21:03:44 <jaredj> ... I am VIBRATORY ...
21:03:48 <jaredj> that was a good quote
21:04:10 <LoganCapaldo> allright its time for this little haskeller to go to bed
21:04:16 <LoganCapaldo> night everybody
21:04:37 <jaredj> nn
21:04:38 <jcreigh> fax: note that Either Integer (a -> b) might not be the best way to use the Either datatype. (The usual usage of is like Maybe, but with some sort of error message on failure)
21:04:46 <wkh> @yow
21:04:46 <lambdabot> This MUST be a good party -- My RIB CAGE is being painfully pressed up
21:04:46 <lambdabot> against someone's MARTINI!!
21:04:54 <jaredj> not bad
21:04:58 <jaredj> @woy
21:04:59 <lambdabot> Maybe you meant: wn yow
21:05:13 <chessguy> @. elite yow
21:05:13 <lambdabot> YOW! it'z 4 Ho|3 alL th3 \/\/4y To D0WN+OwN 8URB4nx!
21:05:18 * wkh says haw haw haw das some funny what like on da innanet
21:06:41 <RyanT5000> so i have to learn ruby; do any of you know of a tutorial that assumes a high level of programming competence? everything out there seems to be pretty babyish
21:06:48 <allbery_b> generally when you're doing something like that you use your own data type instead, with more descriptive names, e.g.
21:06:56 <nornagon> RyanT5000: the ruby source
21:07:04 <nornagon> :-)
21:07:10 <RyanT5000> nornagon: is it readable? lol
21:07:22 <jaredj> RyanT5000: what, you don't want to learn rails? ;)
21:07:36 <RyanT5000> well, i'm learning rails
21:07:39 <allbery_b> data Expr a b = Val Integer | Lam (a -> b)
21:07:41 <nornagon> I'm building a bit from hsSDL and I'm trying to profile something that uses it, but ghc complains of no profiling version
21:07:41 <jaredj> oh ic
21:07:52 <allbery_b> (use Fun instead of Lam i f you prefer)
21:07:58 <jaredj> the pickaxe book, you have found, yes mm?
21:08:24 <nornagon> how do I get cabal to build a profiling version? or is there some other dark ritual i must perform?
21:08:31 <nornagon> can I just tell -prof to ignore that bit?
21:08:39 <allbery_b> there's an old version f the pickaxe online, it misses some of the 1.8 changes but is good for picking up ruby essentials
21:08:48 <RyanT5000> pickaxe? i've got AWD, and two oreillys: jackal and monkey
21:08:51 <fax> If I declare, fac :: Integer -> Either Integer (a -> b)
21:08:55 <fax> why am I not allowed to do, fac n | n > 0 = Right (\x -> x)
21:09:07 <RyanT5000> those are all rails, though
21:09:09 <jaredj> RyanT5000: ah. http://www.rubycentral.com/book/ (old one)
21:09:11 <lambdabot> Title: Programming Ruby: The Pragmatic Programmer's Guide
21:09:16 <sjanssen> nornagon: runghc Setup.hs --help returns the name of the flag, I think
21:09:24 <sjanssen> it might be --with-profiling
21:09:25 <jaredj> http://www.pragmaticprogrammer.com/titles/ruby/ (new, not online)
21:09:27 <lambdabot> Title: Programming Ruby, 2nd Ed.
21:09:41 <jaredj> whoa, what just happened.
21:09:42 <RyanT5000> thanks :)
21:09:49 <jaredj> @botsnack?
21:09:49 <lambdabot> :)
21:09:55 <sjanssen> --enable-library-profiling
21:10:16 <nornagon> ah, okay
21:10:17 <nornagon> thanks
21:10:50 <allbery_b> fax: you told it to expect two types, a and b.  you're using one type
21:11:01 <fax> I dont undertand
21:11:29 <fax> Either Integer (a) doesnt work either
21:11:39 <nornagon> sjanssen: will enabling profiling mean the library's slower even when not using -prof?
21:11:48 <allbery_b> by saying Either Integer (a -> b) you are saying that the Right expects two different types, but you're not using it with two different types
21:11:53 <jcreigh> fax: a type signature of "a -> b" means it takes a value that is of some type "a" and returns a value that is *of some different* type "b"
21:11:59 <allbery_b> Either Integer (a -> a) would work
21:12:17 <fax> Aha :D
21:12:29 <sjanssen> nornagon: no, ghc will generate two separate builds
21:12:35 <nornagon> sjanssen: ah, nifty
21:12:37 <nornagon> thanks :)
21:12:53 <ozone> ooo, it's nornagon
21:13:00 <ozone> fancy seeing you here
21:13:36 <nornagon> hi ozone!
21:13:59 <nornagon> hrm, now what's the fu to enable profiling when the program's run? +RTS something?
21:14:06 <sjanssen> +RTS -p
21:14:12 <dons> http://www.cse.unsw.edu.au/~dons/code/cpuperf/
21:14:12 <lambdabot> Title: Index of /~dons/code/cpuperf
21:14:25 <sjanssen> ooh, what is this?
21:14:39 <dons> a script to tune the cpu speed on openbsd machines (and as an example of how to do static priv separation with moands for shell scripting)
21:15:01 <dons> i needed this this morning, but thought, heh, i'll turn it into a blog article
21:15:03 <sjanssen> dons: openbsd doesn't have any established tools for this?
21:15:07 <dons> any comments would be appreciated.
21:15:08 <nornagon> hmm... it's not showing me much interesting.
21:15:16 <dons> yeah, it does, sysctl
21:15:23 <dons> but i wanted a nice 'toggle' functionality
21:15:28 <nornagon> that is, essentially it's telling me that main is taking the most time to execute.
21:15:33 <nornagon> thx.
21:15:34 <dons> then it becomes an exercise in writing safe shell code
21:16:07 <dons> e.g. the Priv monad to statically partition code that needs root privs
21:16:13 <fax> ghci tells me: add an instance declaration for (Show (Integer -> Integer))
21:16:16 <fax> how can I do that?
21:16:26 <nornagon> heh
21:16:37 <jcreigh> fax: it's tell you that whatever you evaluated is a function of type Integer -> Integer
21:16:55 <jcreigh> *telling
21:16:56 <fax> well its Either Integer or (Integer -> Integer)
21:17:10 <jcreigh> fax: right. But ghci can't print out arbitrary functions.
21:17:11 <fax> and it gives me this error if I enter 0 or 1 (for which it should return either of those)
21:17:25 <fax> so why do I get an error for both?
21:18:07 <dons> any thoughts on the code, sjanssen ?
21:18:26 <hpaste>  fax pasted "Integer -> Either Integer (Integer -> Integer)" at http://hpaste.org/813
21:18:35 <allbery_b> because Either Integer (Integer -> Integer) only has a Show instance if both Integer and (Integer -> Integer) have Show instances
21:18:40 <fax> this is the example, if that makes it any clearer
21:18:41 <allbery_b> but the latter doesn't, by default
21:18:47 <fax> allbery_b: Oh I see
21:19:06 <jcreigh> what's the magic import line for "showable functions"?
21:19:16 <jcreigh> (I forget)
21:19:16 <fax> can I do a check to see if the return type is Integer or (Integer -> Integer) ?
21:19:47 <sjanssen> fax: use case
21:19:54 <fax> alright, thank you
21:20:08 <sjanssen> case result of (Left stuff) -> ...; (Right junk) -> ...;
21:20:11 <allbery_b> http://hpaste.org/616#a1 might be useful to you
21:20:25 <jcreigh> ah, Text.Show.Functions
21:20:33 <fax> ohhh :D
21:20:36 <fax> thanks great as well
21:20:53 <jcreigh> fax: if you import (or load with :m + in ghci) trying to show a function will result in "<function>" instead of an error.
21:21:10 <allbery_b> Text.Show.Functions will just show any function value as <function>; the paste I just [pointed you to will show as <Integer -> Integer>, or whaever
21:21:35 <allbery_b> (the advantage of the former being that it will work for polymorphic functions)
21:21:52 <allbery_b> since showing types requires that it be typeable, and polymorphic functions's aren't
21:22:13 <allbery_b> so Integer -> Integer is fine, but Num a => a -> a is not
21:22:18 <fax> hmm I ran into somthing nasty
21:22:28 <fax> (fac 1) gives me "Right <Integer -> Integer>"
21:22:33 <fax> so I cant actually call that function
21:22:46 <jcreigh> so what does the Typeable solution do in the face of polymorhic functions? usual "missing instace for show" error?
21:22:52 <allbery_b> case fac 1 of Right f -> f x
21:22:59 <allbery_b> I think so
21:23:01 <fax> allbery_b: yeah :(
21:23:17 <Cale> fax: You have to deal with the case that it returns Left something.
21:23:20 <sjanssen> dons: so the purpose of priv is to ease auditing the script?
21:23:36 <sjanssen> ie, you know exactly where the very dangerous parts are
21:23:40 <allbery_b> actually,, for something like (+) it does defaulting so I get <Integer -> Integer -> Integer>
21:23:50 <Cale> You can probably use ap
21:23:57 <Cale> :t Control.Monad.ap
21:24:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:24:04 <QtPlatypus> :t (.)
21:24:06 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:24:28 <dons> sjanssen: right. and if you try to use something needing 'priv' status in normal shell code, you get a type error
21:24:40 <QtPlatypus> :t ($)
21:24:42 <lambdabot> forall a b. (a -> b) -> a -> b
21:24:44 <dons> "can't match Priv against Shell"
21:24:45 <allbery_b> actually it says ":Ambiguous type variable `a' in the constraint: `Typeable a' ..."
21:25:12 <dons> that's the main point: auditing. The openbsd devs go to great lengths to manually separate C code that does this stuff
21:25:14 <allbery_b> which is a reasonable way of saying "this isn't a single type"
21:25:20 <dons> we can hvae the compiler check it for us
21:26:00 <dons> so, domain info encoding in the type, for the domain of privledged shell commands
21:28:10 <jcreigh> actually, it would be really cool if ghci just printed out the type of anything it didn't have a Show instace for. So if you typed "map", it would be just like you typed ":t map"
21:29:06 <hpaste>  faax annotated "slightly friendlier Show for functions" with "(no title)" at http://hpaste.org/616#a2
21:29:14 <fax> it doesnt like 'b' being there
21:29:30 <fax> I cant really put an infinite amount of text in its place though :S
21:29:40 <fax> is it impossible?
21:29:47 <allbery_b> b isn't Typeable
21:30:26 <allbery_b> you need a concrete type for Typeable to work.  and Typeable can't, unfortunately, be expanded to handle arbiitrary types, typeclasses, or other forms of polymorphism
21:30:37 <fax> oh hmm
21:31:02 <jcreigh> fax: if you really need to, you can always define an instance of Show manually.
21:31:04 <fax> so is there anything I could put in place of b?
21:31:11 <allbery_b> you may be better of with Text.Show.Functions' <function> thing in that case
21:31:22 <allbery_b> or if you have a concrete type you can use for b, then it will work
21:31:39 <sjanssen> fax: there is no valid type for your pacman function
21:31:44 <fax> :(
21:31:50 <fax> so I cant write pacman?
21:32:03 <allbery_b> what are you really trying to do?
21:32:12 <jaredj> fax: he's more like oroborus
21:32:14 <sjanssen> perhaps you can, but you need to phrase it differently
21:32:19 <fax> I want a function pacman which you go, pacman 5 1 1 1 1 1 and it eats up the 5 ones
21:32:31 <sjanssen> heh
21:32:36 <allbery_b> you can do that but it's painful
21:32:43 <sjanssen> fax: this is a very advanced technique in Haskell
21:32:44 <allbery_b> @source Text.Printf
21:32:45 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
21:32:48 <sjanssen> it's pretty much never used
21:32:51 <fax> jaredj: http://www.asetusa.com/sc/oroborus.jpg :D
21:33:03 <allbery_b> that module dos something similar.  it's not for beginners.
21:33:11 <jcreigh> fax: you might want to pick something other than advanced type hackery to start out with.
21:33:13 <jaredj> fax: yes, quite :)
21:33:29 <sjanssen> fax: actually, you can't write the function as specified
21:33:30 <wkh> actually objects would come in handy for making a pacman game
21:33:36 <sjanssen> that would require dependent types
21:33:44 <fax> so its totally impossible?
21:33:49 <jaredj> wkh: anti-objects too -
21:33:57 <wkh> anti-objects?
21:34:09 <jaredj> *waits for browser*
21:34:13 <jcreigh> fax: no, variable arity functions are possible; see printf. Just not easy.
21:34:20 <fax> ok cool, :D
21:34:32 <sjanssen> fax: the *type* of pacman depends on the *value* of the first parameter -- you can't do this in Haskell
21:34:43 <wkh> besides
21:34:46 <wkh> Haskell is for real manly programming
21:34:47 <fax> sjanssen: but...
21:34:49 <dons> wel, its hard anyway ;)
21:34:54 <wkh> we have no concern for trifling things such as videogames
21:34:55 <nornagon> hm... this profiling seems to be telling me that (round (x :: Double)) is taking 25 time%
21:34:57 <wkh> or endusers
21:35:00 <wkh> or shipping software
21:35:07 <sjanssen> you can only simulate dependent types
21:35:09 <nornagon> er, sorry
21:35:11 <nornagon> 25 alloc%
21:35:15 <fax> I cant tell if what jcreigh and sjanssen are saying are contradicting
21:35:16 <dons> () :: () -- singleton types tell you something about the value on the type level, for example.
21:35:18 <nornagon> that doesn't seem quite rigth to me
21:35:20 <nornagon> right
21:35:21 <allbery_b> sjanssen: Text.Printf does it
21:35:31 <allbery_b> it can be done but it's not at all easy
21:35:32 <sjanssen> allbery_b: read fax's specification carefully
21:35:33 <dons> D0 .. D9 -- types for the digits 0 .. 9, as singletons
21:35:33 <jaredj> wkh: http://en.wikipedia.org/wiki/Antiobjects
21:35:51 <sjanssen> allbery_b: not only does he want varargs, he wants the type to depend on a value
21:36:15 <fax> doesnt the type of printf depend on the format string though?
21:36:36 <allbery_b> I'm not sure he does; I think the Either stuff was trying to decipher what he was asking for
21:36:42 <allbery_b> if the spec is:
21:36:47 <sjanssen> you could write something like "pacman (undefined :: Five) 1 1 1 1 1" where "type Five = Succ (Succ (Succ (Succ (Succ Zero))))"
21:36:50 <allbery_b> <fax> I want a function pacman which you go, pacman 5 1 1 1 1 1 and it eats up the 5 ones
21:36:55 <Cale> fax: not really, passing it the wrong number of parameters results in a runtime failure
21:37:16 <allbery_b> then it's doable via a printf-like trick.
21:37:22 <fax> sjanssen: but then I have to define an infinite number of numbers?
21:37:30 <jaredj> mehehehe
21:37:52 <sjanssen> fax: you can always define them longhand with Succ/Zero
21:38:03 <allbery_b> but, again, it comes down to "what are you *really* trying to do?"
21:38:03 <fax> I mean how is printf "%d%d%d%d%d" 1 1 1 1 1 different from pacman 5 1 1 1 1 1 ?
21:38:08 <dmwit> How about pacman 5 [1, 1, 1, 1, 1]?
21:38:13 <wkh> Peano axioms ought to be enough for anyone.
21:38:15 <allbery_b> perhaps the real question is why he wants such a function in the first place
21:38:30 <RyanT5000> yes, fax, why do you want it that way?
21:38:31 <Cale> fax: If you printf "%d%d%d%d%d" 1 1 1 1 1 1
21:38:39 <Cale> the error won't show up until runtime
21:38:48 <sjanssen> fax: printf doesn't do any strong checking, printf "" 1 1 1 1 1 1 -- will typecheck but will fail at runtime
21:38:50 <fax> I dont mind about runtime errors
21:39:12 <wkh> you don't mind if your program doesn't work correctly?
21:39:24 <wkh> for one thing it sounds like yo uhaven't thought about the data structures associated with what you want to do
21:39:26 <RyanT5000> fax: why don't you just use a list of Dynamic?
21:39:37 <RyanT5000> if you *really* want such behavior
21:39:45 <RyanT5000> although i would counsel against it in almost all circumstances
21:39:46 <sjanssen> fax: why do you want to write pacman?
21:39:56 <fax> I like the idea ofit
21:40:03 <fax> ill read printf
21:40:11 <wkh> what is the most complicated haskell program you've written thus far?
21:40:14 <allbery_b> that'll scare him off of it :>
21:40:28 <wkh> i tried to figure out this kind of haskell type hackery and failed
21:40:39 <fax> a checkerboard on a quad in GL
21:40:47 * allbery_b understood it, barely, but he's been picking stuff up over the past several months
21:41:09 <allbery_b> still, it's deeply scary code
21:41:12 <wkh> IMO code that wizardly shouldn't be written, because what if it doesn't work?
21:41:30 <fax> it wouldnt be wizardry if it didnt work
21:41:36 <wkh> there's some quote from one of the inventors of C about how debugging is harder than coding, thus if you code as cleverly as possible you wont' be able to debug it
21:42:10 <RyanT5000> wkh: they're different kinds of hard
21:42:56 <RyanT5000> but i agree with the vague notion that saying implies :)
21:43:30 <wkh> have you seen that funny thing "evolution of a haskell programmer"?
21:43:36 <wkh> are there actually people who write code like the ones at the end?
21:43:41 <wkh> with words like "catamorphic" being used?
21:43:44 <wkh> zyga something or other
21:44:02 <jaredj> fax lol true
21:44:49 <jaredj> RyanT5000, wkh: somebody was writing recently that their job assigns mediocre programmers to projects that will have to last and be maintained, because if they put wizards on it, nobody would understand it later on
21:45:37 <Cale> wkh: yes, that code is actually taken from a paper.
21:46:03 <wkh> everyone says Java is for mediocre programmers, but I find Java to be so complex that I don't see how a mediocre progrmamer could figure it out (not that I think that because I think i'm a great programmer, I don't see how nayone of any skill level could justify spending their time on it)
21:46:32 <RyanT5000> jaredj: that's only true insomuch as acquiring new wizards is hard, and forcing wizards to comment well is hard
21:46:51 <wkh> but well written code is its own documentation!
21:46:54 <jaredj> RyanT5000: i was offended, myself
21:46:58 <wkh> your problem is somehwere in the 50 meg codebase, go find it
21:47:02 <wkh> if you refuse, you're a moron and you're lazy
21:47:30 <Pseudonym> BTW, it's not that Java is complex.
21:47:36 <Pseudonym> It's that if you need this much complexity:
21:47:42 <Pseudonym> |<----------------------------------------------------------------->|
21:47:45 <Pseudonym> |<------------------------------------------------------------>|
21:47:54 <Pseudonym> And your language provides this much:
21:48:05 <Pseudonym> |<------>|
21:48:12 <Pseudonym> Then you need to provide this much:
21:48:18 <wkh> boobs
21:48:27 <fax> hahaha
21:48:29 <Pseudonym>         |<-------------------------------------------------->|
21:48:32 <Pseudonym> Or whatever.
21:48:33 <allbery_b> :t (.) . (.)
21:48:35 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:48:35 <Pseudonym> Didn't quite line that up.
21:48:42 * ivanm is amazed at how num(dashes) == complexity
21:48:58 <Pseudonym> Java isn't complex at all.
21:49:14 <QtPlatypus> Pseudonym: Its the water bed metaphore.  If you push down on complexity in one place it pops up in anouther.
21:49:15 <Pseudonym> The libraries are, admittedly.
21:49:19 <Pseudonym> Yeah.
21:49:26 <wkh> well that's what i meant
21:49:29 <jaredj> Pseudonym: agreed.
21:49:29 <wkh> all the xml hell
21:49:44 <jaredj> wkh: interoperability. duh!
21:49:55 * wkh stands corrected
21:50:02 <jaredj> when you use WS-* it's like you're building interoperability into your app.
21:50:07 <jaredj> bam! interoperability.
21:50:16 <jaredj> uh.
21:50:18 <ozone> wkh: that's right, there's a domain mismatch between xml and programming languages, just like the mismatch between RDBMSs and OO languages.  therefore, i propose that your programming language be totally in XML, solving the interoperability problem!
21:50:26 <jaredj> WOO HOO
21:50:33 <ozone> now, where was that XML programming language link
21:50:34 <wkh> ozone: there are entire XML-based application servers
21:50:35 <jaredj> [wkh: facetious]
21:50:39 <wkh> where you write very little code that is not XML
21:50:47 <Pseudonym> ozone: You mean like XSLT?
21:50:47 <jaredj> yep
21:50:54 <ozone> there it is
21:50:55 <ozone> http://www.o-xml.org/spec/langspec.html#functions
21:50:56 <jaredj> that's SO EASY you don't need to be a programmer to do it!
21:50:57 <lambdabot> Title: The o:XML Programming Language
21:51:00 <jaredj> ... right?
21:51:00 <sjanssen> @paste
21:51:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:51:03 <wkh> axkit.org
21:51:04 <ozone> behold the glorious horror!
21:51:27 <ozone> Pseudonym: no, i mean... like... the entire language :)
21:51:31 <hpaste>  sjanssen pasted "pacman, for fax" at http://hpaste.org/814
21:51:38 <sjanssen> fax: ^^^
21:51:54 <ozone> awww man, that's too good, they even have a section on writing a copy constructor for o:XML
21:52:05 <fax> ah thats very cool :D
21:52:31 <sjanssen> fax: note how it's a PITA :)
21:52:33 <wkh> i liked that slide from a Shriram Krishnamurthi presentation
21:52:41 <sjanssen> we don't write things like this in Haskell very often
21:53:19 <RyanT5000> they're usually brain-damaged
21:53:38 <wkh> "stupid parenthetical syntax: is clearly ugly, evil, and an insidious plot hatched by misbegotten academics"
21:53:50 <wkh> "smart parenthetical syntax: is a hip, cool, great new idea"
21:55:51 <jaredj> hah
21:56:12 <jaredj> given proper highlighting i'd take sexps over xml any day
21:56:27 <jaredj> but the reason you use xml is because everyone else does
21:56:34 <jaredj> so you can't get creative there
21:57:29 <fax> scheme should be written in XML syntax http://rafb.net/p/NyQne559.html
21:57:30 <lambdabot> Title: Nopaste - No description
21:58:54 <dibblego> <wkh> everyone says Java is for mediocre programmers, but I find Java to be so complex that I don't see how a mediocre progrmamer could figure it out (not that I think that because I think i'm a great programmer, I don't see how nayone of any skill level could justify spending their time on it)
21:59:01 <dibblego> wkh, I have argued this position before
21:59:26 <Pseudonym> There is only one justification for spending time on Java.
21:59:29 <dibblego> wkh, I used to work on the Java implementation - I know the language back to front - but it would take me years (best case) to understand most Java applications
21:59:34 <Pseudonym> There are people who will pay you money if you can.
21:59:39 <dibblego> wkh, compare that to the time required to learn Haskell
21:59:58 <Pseudonym> It's not a bad justification if employment is important.
22:02:04 <jaredj> java is not complex, it is tedious
22:02:15 <Cale> It's both :)
22:02:18 <jaredj> in my experience some people seem much better suited to dealing with tedium than complexity
22:02:19 <RyanT5000> the language itself is complex
22:02:32 <dibblego> anything written with the language is complex
22:02:33 <fantasma> why can i not do this.....
22:02:36 <dibblego> and difficult to reason about
22:02:39 <Cale> Well, you can get by only understanding a small fraction of that complexity, sometimes.
22:02:45 <fantasma> > 10^(-3.2) --please
22:02:46 <lambdabot>  Add a type signature
22:02:51 <jaredj> who's reasoning?
22:02:57 <fantasma> > 10^(-3.2) :: Float
22:02:58 <jaredj> mediocre programmers do not reason
22:02:58 <lambdabot>  Add a type signature
22:03:01 <Cale> hehe
22:03:02 <jaredj> they tinker
22:03:05 <dibblego> whoever wants to comprehend it
22:03:08 <jaredj> class paula {
22:03:19 <jaredj>     String cool = "Paula is great";
22:03:19 <Cale> Everyone has to reason somewhat in order to manage to write anything nontrivial.
22:03:47 <fantasma> > 10^(-3.2) make this float
22:03:48 <lambdabot>   Not in scope: `this'
22:04:00 <fantasma> > 10^(-3.2) Just Nothing
22:04:00 <jaredj> http://worsethanfailure.com/Articles/The_Brillant_Paula_Bean.aspx
22:04:00 <lambdabot>        add an instance declaration for
22:04:01 <lambdabot>       (Fractional ((a -> Maybe a) -> M...
22:04:01 <lambdabot> Title: The Brillant Paula Bean - Worse Than Failure
22:04:15 <fantasma> > 10^(-3.2) --Cale, help me out
22:04:16 <lambdabot>  Add a type signature
22:04:24 <Cale> > 10**(-3.2)
22:04:26 <lambdabot>  6.30957344480193e-4
22:04:36 <hpaste>  sjanssen annotated "pacman, for fax" with "try "pacman p10" :)" at http://hpaste.org/814#a1
22:04:43 <fantasma> @type **
22:04:43 <Cale> @type Integral
22:04:45 <lambdabot> parse error on input `**'
22:04:46 <Cale> @type (^)
22:04:47 <lambdabot> Not in scope: data constructor `Integral'
22:04:49 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
22:05:06 <RyanT5000> the importance of OOP languages in general is that they give programmers a well-defined structure for thinking in
22:05:06 <Cale> (excuse my brain malfunctioning there :)
22:05:08 <fantasma> @src **
22:05:08 <lambdabot> Source not found. You type like i drive.
22:05:12 <Cale> @src (**)
22:05:13 <lambdabot> Source not found. The more you drive -- the dumber you get.
22:05:21 <Cale> :type (**)
22:05:27 <Cale> :t (**)
22:05:30 <lambdabot> forall a. (Floating a) => a -> a -> a
22:05:33 <fantasma> nice
22:05:34 <Cale> :t (^^)
22:05:37 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
22:05:40 <fantasma> i like to float around
22:05:50 <dibblego> RyanT5000, sounds like the front cover of a glossy brochure to me
22:05:53 <jaredj> RyanT5000: i have seen people fail to identify the useful objects of their problem domain
22:05:58 <fantasma> ** is exponent?
22:06:38 <RyanT5000> jaredj: of course; people can fail at anything; but those same people would probably also fail to use the right monad transformers for problems in haskell :P
22:06:45 <dibblego> imperative OOP languages serve to make it impossible to reason about the application, thus producing more money
22:06:45 <jaredj> oh quite
22:06:48 <Cale> ^, ^^, and ** are all exponentials.
22:07:03 <jaredj> but i get saddled with helping those sorts of people
22:07:07 <RyanT5000> lol
22:07:11 <Cale> They correspond to three separate definitions which are used in mathematics, and normally overlap.
22:07:39 <jaredj> some guy at work today had a string like "25.42442, 42.543354, 32234.2"
22:07:45 <jaredj> he read in the first number
22:07:47 <jaredj> into a float
22:07:51 <fantasma> what a noob
22:07:53 <jaredj> it ended up 25.4244
22:08:16 <QtPlatypus> Unfortunitly alot of people don't think in a functional mannor, most likely because there brains have evolved in a universe that is basically imperative."
22:08:19 <jaredj> and then when he tried to read the second number, instead of " 42.543354" he got ", 42.543354" and it failed to parse
22:08:33 <hpaste>  sjanssen annotated "pacman, for fax" with "try "feed (pacman p10)"" at http://hpaste.org/814#a2
22:08:36 <jaredj> so he tried to use doubles so he could keep all the digits and count off the right number of chars
22:08:36 <Cale> QtPlatypus: You mean, by programming in languages like C and Java?
22:08:37 <dibblego> QtPlatypus, which universe might that be?
22:08:42 <jaredj> something is WRONG with that
22:09:10 <sjanssen> fax: ^^^ the piece de resistance
22:09:24 <Cale> My universe is governed by equations which are declarative.
22:09:37 <dibblego> as is mine
22:09:43 <Pseudonym> Mine too.
22:09:46 <jaredj> trying to figure out how many characters to read by counting decimal digits is indicative of a larger problem than declarative vs imperative
22:09:55 <Pseudonym> If you think it's imperative, you try telling an electron what to do.
22:10:05 * dibblego postulates that we all live in the same universe
22:11:21 * jaredj has entered a post-midnight universe
22:12:11 <fantasma> you can stop entropy with imperative languages
22:13:05 <jaredj> oo i wouldn't go that far
22:13:09 <fantasma> > 10**(-3.24) --doing chemistry homework at midnight
22:13:10 <lambdabot>  5.754399373371566e-4
22:13:18 <jaredj> you can inadvertently create a looot of entropy with imperative languages
22:13:36 <kc5tja> QtPlatypus: I second that.
22:13:41 * Cale postulates that we all live in different universes, with transition maps where the charts overlap.
22:14:01 <fantasma> which dimension is universes?
22:14:05 <fantasma> 7th correct?
22:14:15 <kc5tja> Because math concepts escape me often, I tend to think procedurally instead.
22:14:16 <jaredj> depends on the first parameter
22:14:26 <jaredj> universe 5 1 1 1 1 1 == 5
22:14:28 <ivanm> fantasma: 10, I think...
22:14:31 * narain hears "parallel universes" and thinks he picked an interesting time to enter the room
22:14:44 <fantasma> 10 is all possibility
22:15:02 <ivanm> http://en.wikipedia.org/wiki/String_theory
22:15:03 <lambdabot> Title: String theory - Wikipedia, the free encyclopedia
22:15:18 <ivanm> "String theory strongly suggests the existence of ten or eleven (in M-theory) spacetime dimensions, as opposed to the usual four (three spatial and one temporal) used in relativity theory[1]; however the theory can describe universes with four effective (observable) spacetime dimensions by a variety of methods."
22:15:29 * fantasma is affraid to get to interested because his chemistry homework needs to be done
22:15:31 <sjanssen> jaredj: universe looks suspiciously like pacman :)
22:15:40 <Cale> On the other hand, string theory isn't science.
22:15:58 <fantasma> string theory = truth
22:16:07 <kc5tja> sjanssen: I saw your link to pacman earlier today, and instinctively thought, "Ooh, the game written in Haskell!"  :)
22:16:08 <Cale> string theory = truthiness
22:16:17 <ivanm> Cale: lol!
22:16:33 <ivanm> the physics department at my uni won't even consider string theory
22:16:53 <sieni> http://www.amazon.com/Not-Even-Wrong-Continuing-Challenge/dp/0224076051
22:16:56 <ivanm> then again, string theory may not be valid science as it can't be disproven
22:16:56 <lambdabot> http://tinyurl.com/ysnmm8
22:17:00 <kc5tja> fantasma: String theory is hypothesis, not theory, until reproducable in a laboratory environment OR proven sufficiently based on evidence from lab experiments.
22:17:02 <Cale> Or maybe scienciness -- it *sounds* like science, so maybe it is?
22:17:26 <fantasma> kc5tja, then they should change the name to string hypothesis
22:17:36 <ivanm> Cale: that's Original Design
22:17:42 <kc5tja> Now, that being said, I subscribe to the "string-theory-is-ultimately-going-to-be-proven-correct" school of thought, but I must acknowledge that it is not a theory.  :)
22:17:55 <Cale> I think that altogether too much work has been put into it without getting very much back in terms of experimentally verifiable results.
22:18:11 <kc5tja> fantasma: I agree wholeheartedly; String Hypothesis is both less antagonistic and more accurate.
22:18:14 <Cale> There are much more promising and direct approaches to quantum gravity.
22:18:15 <ivanm> because, IIRC, you can't verify it
22:18:34 <fantasma> only way to verify it is mathamatically (my guess)
22:18:43 <emu> i hate the way string theory is explained informally
22:18:45 <sieni> well, string theory has produced lots of interesting mathematics, but hasn't been very relevant to physics so far
22:18:52 <emu> "durr, they're STRINGS vibrating like a GUITAR"
22:18:59 <Cale> haha
22:19:01 * emu groans
22:19:08 <narain> as far as i have heard, string theory does make testable predictions, they're just orders of magnitude away from the capabilities of real experimental equipment?
22:19:09 <kc5tja> Cale: There have been many times in the history of science when this is true.  That doesn't make ST any less true (or false).  Work invested is always good science, even if it yeilds bottom.  :)
22:19:12 <ivanm> emu: you only have yourself to blame!
22:19:13 <Cale> @yow
22:19:13 <lambdabot> PARDON me, am I speaking ENGLISH?
22:19:27 <ivanm> @yarr
22:19:27 <lambdabot> Har de har har!
22:19:43 <emu> my favorite was a TV program which explained that dimensions were like thin sheets which covered everything
22:19:54 <ivanm> lol
22:19:56 <fantasma> emu, I was just about to mention that tv show
22:19:57 <emu> and then went on to specify some value in nanometers for that
22:20:03 <narain> help, i'm trapped under a p-brane and i can't get out!
22:20:15 <kc5tja> Remember that those TV shows are targeting an audience with an average intelligence level of a 7th grader.
22:20:23 <jaredj> ogh
22:20:28 <narain> which tv show was this?
22:20:38 <narain> nanometers??
22:20:43 <ivanm> kc5tja: that's rather optimistic in terms of expected intelligence
22:20:45 <fantasma> i think it was on the discovery science channel
22:20:46 <kc5tja> The one I'm thinking of is the show that Nova produced.
22:20:55 <kc5tja> ivanm: Irrelavent; that's their target.
22:21:01 <emu> the average reading level of a 7th grader is 3rd
22:21:07 * ivanm thought it was people who never went to school
22:21:14 <kc5tja> To watch a show like Nova in the first place, it's assumed that you have a certain minimum level of intelligence to begin with.  :)
22:21:19 <emu> no, most likely it's people completely stoned
22:21:30 * ivanm has no idea what Nova is.  To him, Nova is a radio station
22:21:43 <kc5tja> Nova is a science documentary show.
22:21:48 <kc5tja> It's on PBS.
22:22:12 <ivanm> PBS = ?
22:22:19 <kc5tja> @google pbs
22:22:20 <lambdabot> http://www.pbs.org/
22:22:21 <lambdabot> Title: PBS
22:22:23 <fantasma> they play the string theory episode every three days lol
22:22:27 <jaredj> It's supported by the Corporation for Public Broadcasting. And by. - Viewers Like You.
22:22:31 <rahikkala> Nova is also an English school in Japan that one of my friends works at :p
22:22:41 <jaredj> public broadcasting service
22:22:44 <jaredj> service?
22:22:57 <ivanm> " With your support, PBS programs and education services enrich the lives of all Americans."
22:23:02 <fantasma> lol!
22:23:03 <ivanm> right...
22:23:08 <jaredj> oo haven't watche din a while.
22:23:17 <fantasma> i remember seeing those telathons on TV from PBS
22:23:17 <Cale> I would much prefer it if physics would do a better job of constructing models which were rigourously well-defined. If you're not careful, you'll end up with hypotheses which are not falsifiable.
22:23:18 <jaredj> never heard that one.
22:23:34 <emu> not falsifiable, how convenient
22:23:48 <fantasma> gravity is a terrible model
22:23:51 <Cale> Compounding that with lack of experimental evidence is a formula for disaster.
22:23:56 <emu> they don't make any statements about the world, much like string theory
22:24:07 <jaredj> an ILL-DEFINED formula for disaster! dun dun dunnnnnn
22:24:09 <ivanm> fantasma: how bout the sucking model instead then?
22:24:18 <fantasma> ivanm, yes, that's better
22:24:22 <kc5tja> Cale: You can't expect immediate experimental evidence right away.
22:24:29 <jaredj> it lacks gravitas
22:24:38 <kc5tja> Theory of relativity wasn't experimentally supported until decades after its publication, if memory serves me correctly.
22:24:59 <ivanm> http://www.theonion.com/content/node/39512
22:25:00 <emu> there was the speed-of-light experiments prior
22:25:01 <lambdabot> Title: Evangelical Scientists Refute Gravity With New 'Intelligent Falling' Theory | Th ...
22:25:05 <jaredj> if you're going to think about it a lot you need to call it a theory
22:25:06 <Cale> kc5tja: Well, sure, but then you should use that time to be extra careful about what it is that you're really going to see when the experiment finally happens.
22:25:09 <kc5tja> In fact, there are predictions made by it that we have yet to experimentally reproduce (e.g., gravity waves)
22:25:16 <ivanm> IIRC, the ether experiments supported relativity
22:25:18 <emu> the famous eclipse experiment was performed in the late 20s i think
22:25:19 <jaredj> like nobody teaches college math classes about "category hypothesis"
22:25:19 <ivanm> special, if not general
22:25:21 <fantasma> "only 3% of the universe is matter" <-- who came up with this???
22:25:33 <Cale> I find it kind of funny that there is a $1,000,000 prize to determine if Yang-Mills theory exists.
22:25:37 <kc5tja> Cale: umm....HUH?!
22:25:48 <ivanm> Yang-Mills? as in monopole gauge theory?
22:25:53 <emu> jaredj: theory means "set of true statements"
22:25:55 <fantasma> there's a $250,000 prize to find a prime with a billion digits
22:25:56 <Xgc> fantasma: The rest doesn't matter.
22:26:06 <jaredj> emu: yes yes. but it has connotations too
22:26:07 <fantasma> Xgc, hahaha
22:26:14 * ivanm recalls the name Yang-Mills from his paper about magnetic monopoles
22:26:24 <Cale> http://en.wikipedia.org/wiki/Yang%E2%80%93Mills_existence_and_mass_gap
22:26:27 <lambdabot> http://tinyurl.com/y9zbqv
22:26:29 <jaredj> a hypothesis needs a definite article, like "I study *the* blabla hypothesis"
22:26:42 <wkh> why would there be a prize for finding a sufficiently long prime
22:26:43 <emu> The Riemann Hypothesis
22:26:45 <emu> how about that
22:26:48 <wkh> inding new primes doens't tell you anything
22:26:52 <jaredj> but to get by without an article you have to say "Ii'm a researcher in blabla theory"
22:27:06 <fantasma> tell the IETF that
22:27:13 <fantasma> @where ietf
22:27:14 <lambdabot> I know nothing about ietf.
22:27:21 <ivanm> wkh: because primes are cool?
22:27:32 <emu> well remember, as bill gates said, factoring large primes is the next frontier
22:27:37 <jaredj> wkh: so you can get in bruce schneier's luggage?
22:27:42 <kc5tja> Primes also form the foundation for cryptography too.
22:27:44 <narain> emu: hahaha
22:27:54 <narain> emu: that was a joke, right?
22:27:55 <emu> or, rather, the road ahead
22:28:00 <jaredj> "64-digit primes ought to be enough for anybody"
22:28:00 <ivanm> kc5tja: stupid practical uses
22:28:02 <narain> emu: or a typo? sorry in that case
22:28:31 <fantasma> EFF is offering the prize
22:28:51 <narain> finding a prime with a million digits seems.. arbitrarily tied to the fact that we have ten fingers and tend to group powers of ten by threes
22:29:00 <fantasma> "The prizes will be awarded for finding huge prime numbers, that is, numbers that can only be divided by 1 and themselves. The first million-digit prime found will be worth $50,000; a ten-million-digit prime will claim $100,000; a hundred-million-digit prime garners $150,000; and the finder of the first billion-digit prime will receive $250,000."
22:29:02 <Cale> Basically, a one million dollar prize to take something which most physicists accept and actually show it mathematically makes sense.
22:29:16 <emu> narain: http://philip.greenspun.com/humor/bill-gates.html
22:29:17 <lambdabot> Title: Why Bill Gates is Richer than You
22:29:28 <wkh> because primes is in P, the task seems unworthy of a cash reward
22:29:52 <fantasma> "The obvious mathematical breakthrough would be development of an easy way to factor large prime numbers."
22:29:59 <fantasma> hahaha
22:30:27 * ivanm wonders who is so stupid that he thinks you can factor large primes
22:30:33 <ivanm> or was that a quote from the Bill Gates site?
22:30:35 <jaredj> supercomputers don't care what set your problem is in, you still have to pay for time
22:30:37 <narain> factorPrime n = [1, n]
22:30:40 <Cale> You can factor them, it's just easy to do so.
22:30:47 <ivanm> lol
22:30:48 <jaredj> oh
22:30:51 <wkh> ivanm: that was in one of bill gates' ghostwritten books
22:30:51 <jaredj> *slaps forehead*
22:30:55 <ivanm> duh, I meant any other way
22:30:59 <ivanm> wkh: ahhh, OK
22:31:00 <wkh> business at the speed of buy our shitty software
22:31:11 <bd_> factoring primes is easy. factoring composite numbers can be a bit more tricky ;)
22:31:12 <jaredj> lol so true
22:31:34 <emu> well finding a billion-digit prime probably entails some crazy new awesome algorithm which would be of benefit in general
22:31:37 <Cale> 2 = (3/2) * (4/3)
22:31:49 <Cale> Factorisation in Q!
22:31:52 <jaredj> emu: or a big computer, which is also awesome
22:32:10 <ivanm> quantum computers for teh win!
22:32:12 <ivanm> ;)
22:32:35 <ivanm> hmmm..... since haskell has no state, would it be naturally better for quantum programs? ;)
22:32:41 <fantasma> what's the big deal about finding one...? they can just use folding @ home for a day and find it
22:32:43 <dmwit> Cale: But, but... my beautiful uniqueness!
22:32:55 <narain> "can quantum computers factorize quickly?" "shor!"
22:32:57 <wkh> um, checking subsets of Z for primality is an embarassigly parallel task and basically suited for distributed computing. there's one that does that for finding mersenne primes
22:33:14 <wkh> what more can you do
22:33:27 <ivanm> quantum computers will theoretically do anything in no time flat
22:33:32 <wkh> no, not true.
22:33:34 <fantasma> my guess is that there are only 2 billion digit primes
22:33:42 <wkh> http://www.scottaaronson.com/blog/
22:33:43 <emu> boring computer programs have monads.  quantum computer programs have quanads.
22:33:44 <lambdabot> Title: Shtetl-Optimized
22:33:48 <ivanm> including solving the worlds ills, bring about enlightenment, and give me a ton of cash ;)
22:33:50 <wkh> fantasma: what?
22:33:51 <jaredj> ivanm: it's the i/o that's so terrible :)
22:33:59 <wkh> there are infinitely many primes
22:34:05 <ivanm> jaredj: that's an undocumented feature
22:34:06 <fantasma> billion digit?
22:34:11 <wkh> haven't you seen euclid's classic proof?
22:34:13 <jaredj> lazy evaluation, in hardware heh
22:34:16 <ivanm> fantasma: assume there's only a finite number of primes
22:34:19 <narain> "there are only two primes with a billion digits"?
22:34:25 <emu> fantasma: they'll take a billion-and-1 digit prime too i'm sure
22:34:26 <ivanm> multiply all the primes by each other
22:34:27 <ivanm> then add one
22:34:34 <ivanm> it'll have no prime factors
22:34:38 <ivanm> ergo, it must be prime
22:34:40 <ivanm> voila!
22:34:47 <fantasma> i said billion digits
22:34:51 <dmwit> Well, it could have prime factors.
22:34:57 <dmwit> But they'd be bigger than your biggest one yet.
22:34:58 <ivanm> dmwit: no it won't
22:35:01 <dmwit> So you're still okay. ;-)
22:35:15 <fantasma> @karma+ narain
22:35:15 <ivanm> dmwit: I said "assume there's a finite number of primes"
22:35:16 <lambdabot> narain's karma raised to 2.
22:35:48 <ivanm> fantasma: so you can't even put a cap on the number of digits a prime has
22:35:53 <ivanm> since there's an infinite number
22:35:58 <dmwit> ivanm: fair enough
22:36:02 <fantasma> what are you talking about
22:36:21 <narain> *sigh* fantasma please repeat your original hypothesis in an unambiguous manner
22:36:30 <fantasma> narain, you did :)
22:36:33 <ivanm> I second that
22:36:38 <narain> nobody paid attention :p
22:36:42 <wkh> http://metacircular.wordpress.com/2007/02/20/omg-wordpress-supports-math/
22:36:45 <lambdabot> Title: OMG Wordpress supports math!  Metacircular thoughts, http://tinyurl.com/yuawyu
22:36:47 <emu> i read it as 2 (billion-digit-primes)
22:36:49 <wkh> here's a quick proof written up slightly more carefully
22:36:49 <ivanm> at first glance it looked like you thought there was a cap on the number of primes
22:37:02 <fantasma> ivanm, no lol
22:37:15 <dmwit> Hypothesis: exactly two primes have a billion digits?
22:37:29 <emu> like exactly 4 primes have 1 digit in base 10
22:37:49 <fantasma> http://www.mersenne.org/prime9.txt
22:37:54 <wkh> the distribution of primes is more interesting although i'm out of my league here
22:37:56 <ivanm> wkh: did you write up that proof?
22:38:01 <wkh> ivanm: yes sir
22:38:11 <ivanm> it should be P is a subset of {n in Z...
22:38:22 <ivanm> oh, wait, I didn't even read that properly :s
22:38:24 <ivanm> my mistake
22:38:25 <narain> re: OMG Wordpress supports math! i wish mathml were more commonly supported so math would scale with font size
22:38:29 * ivanm should stop skim reading
22:38:39 <wkh> narain: yeah but i'm too lazy to type it
22:38:45 <wkh> and most people's browsers don't support it
22:38:48 <wkh> including mine right now
22:38:51 <emu> mathml is ew
22:38:59 <emu> it makes latex look really good
22:39:11 <narain> i know, i don't expect users to write mathml themselves
22:39:13 * emu wallows in latex all day lately
22:39:19 <narain> wouldn't wish that on anyone :)
22:39:29 <ivanm> wkh: actually, there's a slight flaw ... a | b is of type Integer -> Integer -> Bool
22:39:31 <narain> but you have latex-to-mathml converters
22:39:39 <ivanm> you have it as Integer -> Integer -> Integer
22:40:15 <narain> i mean since wordpress now supports latex but outputs to the web it would ideally convert to mathml for display
22:40:43 <wkh> you misunderstood the fixity of | and = :p
22:41:08 <fantasma> > delete evens [0..1]
22:41:09 <lambdabot>   Not in scope: `evens'
22:41:13 <fantasma> > delete even [0..1]
22:41:14 <lambdabot>   add an instance declaration for (Num (a -> Bool))
22:41:14 <lambdabot>     In the expression: 1
22:41:38 <fantasma> :t delete
22:41:40 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
22:41:59 <ivanm> wkh: in what way?
22:42:16 <ivanm> or is there understood brackets around the k - ... = 1 bit?
22:42:36 <narain> wkh: = :: Integer -> Integer -> Bool, then pi | (k - p1..pn = 1) fails to typecheck :)
22:42:40 <wkh> "p_i divides (k-p1*...*pn), and since k-p1*...*pn=1,p_i divides one, contradiction, qed"
22:43:06 <narain> p_i | True?
22:43:13 <wkh> ...
22:43:31 * narain ducks
22:43:32 <fantasma> > ['z'..'a']
22:43:34 <lambdabot>  ""
22:44:03 <wkh> > ['z','y'..'a']
22:44:05 <lambdabot>  "zyxwvutsrqponmlkjihgfedcba"
22:44:13 <ivanm> wkh: nope, still don't get it
22:44:13 <fantasma> > ['z', 'y','d',..'a']
22:44:14 <lambdabot>  Parse error
22:44:23 <fantasma> > ['z','y','d',..'a']
22:44:24 <lambdabot>  Parse error
22:44:36 <narain> fantasma: only two initial seeds allowed
22:44:36 <ivanm> > 'z':'y':['d','c'..'a']
22:44:38 <lambdabot>  "zydcba"
22:44:51 <narain> @hoogle enumFrom
22:44:52 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
22:44:52 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
22:44:52 <lambdabot> Prelude.enumFromThenTo :: Enum a => a -> a -> a -> [a]
22:45:05 <narain> @hoogle+
22:45:05 <lambdabot> Prelude.enumFromTo :: Enum a => a -> a -> [a]
22:45:07 <lambdabot> Language.Haskell.Syntax.HsEnumFrom :: HsExp -> HsExp
22:45:07 <lambdabot> Language.Haskell.Syntax.HsEnumFromThen :: HsExp -> HsExp -> HsExp
22:45:26 <fantasma> > take 10 . map (/0) $ [1..]
22:45:27 <lambdabot>  [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Inf...
22:45:29 <wkh> god damn lambdabot is the handiest thing ever
22:45:49 <narain> an infinite list of infinities!
22:46:01 <wkh> i like that joke about how people in different professions argue that 9 is a prime number
22:46:09 <wkh> computer scientist: 1 is prime, 1 is prime, 1 is prime, 1 is prime...
22:46:39 <wkh> lawyer: ladies and gentleman, the evidence is damning. 5 is prime, 7 is prime, 9 is prime, 11 is prime, and 13 are all prime numbers, your honor. need i continue?
22:46:39 <ivanm> lol
22:47:12 <narain> physicist: 3 is prime, 5 is prime, 7 is prime, 9 is experimental error, 11 is prime, ...
22:47:13 <ivanm> physicist: 3 is prime, 5 is prime, 7 is prime, 9 is an experimental error, 11 is prime...
22:47:18 <narain> d'oh!
22:47:20 <ivanm> dammit, you beat me!
22:47:24 <sieni> > take 10 . map (const (map (/0) $ [1..])) [1..]
22:47:25 <lambdabot>  Couldn't match expected type `a -> [a1]'
22:47:28 <sieni> oops
22:47:45 <sieni> > take 10 $  map (const (map (/0) $ [1..])) [1..]
22:47:47 <lambdabot>  [[Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,In...
22:48:00 <fantasma> infinity powerset
22:48:06 <ivanm> lol
22:48:27 <fantasma> @type Infinity
22:48:29 <lambdabot> Not in scope: data constructor `Infinity'
22:48:38 <wkh> @type 1/0
22:48:40 <lambdabot> forall t. (Fractional t) => t
22:48:52 <ivanm> :k Infinity
22:48:53 <fantasma> @kind Infinity
22:48:54 <lambdabot>     Not in scope: type constructor or class `Infinity'
22:48:56 <lambdabot>     Not in scope: type constructor or class `Infinity'
22:49:07 <ivanm> :k 1/0
22:49:10 <lambdabot> Not in scope: type variable `/'
22:49:10 <lambdabot>  
22:49:10 <lambdabot> <interactive>:1:2: Only unit numeric type pattern is valid
22:49:12 <fantasma> > Infinity/Infinity
22:49:13 <lambdabot>   Not in scope: data constructor `Infinity'
22:49:17 <ivanm> :k (1 / 0)
22:49:20 <lambdabot> Not in scope: type variable `/'
22:49:20 <lambdabot>  
22:49:20 <lambdabot> <interactive>:1:5: Only unit numeric type pattern is valid
22:49:23 <wkh> > (1/0)/(1/0)
22:49:24 <ivanm> :k (1 \ 0)
22:49:24 <lambdabot>  NaN
22:49:27 <lambdabot> parse error on input `\'
22:49:28 <fantasma> NaN
22:49:29 <fantasma> lol
22:49:33 <fantasma> > NaN
22:49:34 <lambdabot>   Not in scope: data constructor `NaN'
22:49:37 <ivanm> :t (1 \ 0)
22:49:39 <lambdabot> parse error on input `\'
22:49:43 <ivanm> :t (1 / 0)
22:49:46 <lambdabot> forall t. (Fractional t) => t
22:49:47 <fantasma> @k NaN
22:49:47 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . v
22:49:54 <narain> > let powerset = foldr (\sets elt -> sets ++ map (elt :) sets) [] in powerset [1,2,3]
22:49:55 <lambdabot>      Occurs check: cannot construct the infinite type: b = [[b]]
22:49:55 <lambdabot>       Expect...
22:49:56 <fantasma> :k NaN
22:49:59 <lambdabot> Not in scope: type constructor or class `NaN'
22:50:03 <wkh> karma+ karma- karma chameeeleeooon
22:50:15 <ivanm> @type (map (/0) [1..])
22:50:18 <lambdabot> forall a. (Fractional a, Enum a) => [a]
22:50:21 <fantasma> iterate karma+ rootkit 10
22:50:32 <wkh> that last one isn't interesting because it's still countable :P
22:50:46 <sjanssen> > "computer scientist: " ++ concat (repeat "3 is prime, ")
22:50:47 <lambdabot>  "computer scientist: 3 is prime, 3 is prime, 3 is prime, 3 is prime, 3 is pr...
22:51:06 <narain> > let powerset = foldr (\sets elt -> sets ++ map (elt :) sets) [[]] in powerset [1,2,3]
22:51:07 <lambdabot>      Occurs check: cannot construct the infinite type: b = [[b]]
22:51:08 <lambdabot>       Expect...
22:51:11 <fantasma> $ echo "hello"
22:51:25 <narain> :t foldr
22:51:28 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:51:29 <fantasma> $ killall *
22:51:43 <narain> > let powerset = foldr (\elt sets -> sets ++ map (elt :) sets) [[]] in powerset [1,2,3]
22:51:45 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
22:51:45 <ivanm> http://www-users.cs.york.ac.uk/susan/joke/3.htm
22:51:48 <lambdabot> Title: Engineer, Scientist, Mathematician
22:51:48 <wkh> fantasma: lambdabot won't let you do I/O or any haxor bidnis
22:51:57 <narain> > let powerset = foldr (\sets elt -> sets ++ map (elt :) sets) [[]] in powerset [0..]
22:51:58 <lambdabot>      Occurs check: cannot construct the infinite type: b = [[b]]
22:51:58 <lambdabot>       Expect...
22:52:06 <narain> > let powerset = foldr (\elt sets -> sets ++ map (elt :) sets) [[]] in powerset [1,2,3]
22:52:07 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
22:52:17 <narain> > let powerset = foldr (\elt sets -> sets ++ map (elt :) sets) [[]] in powerset [1..]
22:52:20 <lambdabot>  Exception: stack overflow
22:52:23 <fantasma> lol
22:52:23 <wkh> heh
22:52:23 <narain> shoot
22:52:36 <fantasma> neat function
22:52:51 <ivanm> Mathematician: "3 is prime, 5 is prime, 7 is prime. The result follows by induction."
22:52:55 <fantasma> let powerset = sort $ foldr (\elt sets -> sets ++ map (elt :) sets) [[]] in powerset [1,2,3,4]
22:53:02 <fantasma> > let powerset = sort $ foldr (\elt sets -> sets ++ map (elt :) sets) [[]] in powerset [1,2,3,4]
22:53:03 <lambdabot>  Couldn't match expected type `[a]'
22:53:17 <ivanm>     * Economist: "2 is prime, 4 is prime, 6 is prime, 8 is prime..."
22:53:20 <narain> > let powerset = sort . foldr (\elt sets -> sets ++ map (elt :) sets) [[]] in powerset [1,2,3,4]
22:53:21 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,4],[1,3],[1,3,4],[1,4],[2],[2,3],[2,3,4...
22:53:36 <sjanssen> > let powerset = filterM (const [True, False]) in [1..4]
22:53:38 <lambdabot>  [1,2,3,4]
22:53:57 <wkh> :t const
22:54:00 <lambdabot> forall a b. a -> b -> a
22:54:03 <sjanssen> > filterM (const [True, False]) [1..4]
22:54:04 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
22:54:05 <narain> that would have been awesome if it had worked
22:54:09 <narain> oh hey
22:54:15 <wkh> > const [True, False]
22:54:16 <lambdabot>  Add a type signature
22:54:19 <narain> wow
22:54:31 <sjanssen> narain: I just forgot to actually apply powerset to [1..4]
22:54:35 <fantasma> :t const [True, False]
22:54:38 <lambdabot> forall b. b -> [Bool]
22:54:42 <narain> > filterM (const [True, False]) [1..3]
22:54:44 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
22:54:47 <sjanssen> > const "is a function" "that throws away it's second argument"
22:54:49 <lambdabot>  "is a function"
22:54:59 <ivanm> lol
22:55:23 <ivanm> doesn't seem to be working though...
22:55:34 <fantasma> > const const const const const const const const 1+1
22:55:35 <lambdabot>   add an instance declaration for (Num (a -> b -> a))
22:55:35 <lambdabot>     In the expression:
22:55:35 <lambdabot> ...
22:55:37 <narain> that is impressive
22:55:42 <narain> (sjanssen)
22:55:47 <narain> :t filterM
22:55:49 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
22:56:43 <ivanm> Computer scientist using Unix: 3's a prime, 5's a prime, 7's a prime,  segmentation fault
22:56:44 <narain> @src filterM
22:56:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:57:14 <narain> ivanm: haha. also i typed your nick as ivanM at first.
22:57:22 <ivanm> lol
22:57:45 <ivanm> http://www.geocities.com/CapeCanaveral/Hangar/7773/humor.html
22:57:45 <lambdabot> Title: Math humor
22:57:47 <fantasma> > foldl (=) [1..]
22:57:48 <lambdabot>  Parse error
22:58:00 <wkh> > fold1l (=) [1..]
22:58:00 <lambdabot>  Parse error
22:58:06 <wkh> > fold1l (==) [1..]
22:58:06 <lambdabot>   Not in scope: `fold1l'
22:58:11 <wkh> > foldl1 (==) [1..]
22:58:12 <lambdabot>   add an instance declaration for (Num Bool)
22:58:13 <lambdabot>     In the expression: 1
22:58:21 <fantasma> > scanl (=) [1..]
22:58:22 <sjanssen> filterM p [] = return []; filterM p (x:xs) = do b <- p x; xs' <- filterM p xs; return (if b then x : xs' else xs')
22:58:22 <lambdabot>  Parse error
22:58:22 <ivanm> type sig is wrong
22:58:45 <ivanm> @type foldl
22:58:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:58:49 <ivanm> @type scanl
22:58:52 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:59:03 <fantasma> > pause
22:59:04 <narain> sjanssen: thanks
22:59:04 <lambdabot>   Not in scope: `pause'
22:59:45 <fantasma> > System.echo "hi"
23:01:30 <lambdabot>   Not in scope: `System.echo'
23:01:30 <sjanssen> @type \xs -> all (== head xs) xs
23:01:30 <lambdabot> forall a. (Eq a) => [a] -> Bool
23:01:30 <fantasma> > reverse . take 10 . reverse . map digitToInt . show . sum . map (\x -> x^x) $ [1..1000]
23:01:30 <lambdabot>  [9,1,1,0,8,4,6,7,0,0]
23:01:58 <narain> > reverse . take 10 . reverse . map digitToInt . show . sum . map (\x -> x^x) $ [1..5]
23:02:00 <lambdabot>  [3,4,1,3]
23:02:12 <narain> > sum . map (\x -> x^x) $ [1..5]
23:02:12 <fantasma> > sum $ filter (\x -> x == (sum . factors . sum . factors) x && x /= (sum . factors) x) [1..1000]
23:02:13 <lambdabot>   Not in scope: `factors'
23:02:14 <lambdabot>  3413
23:02:19 <dmwit> > sum [x * x | x <- [1..1000]]
23:02:21 <lambdabot>  333833500
23:02:50 <narain> > sum . map (\x -> x^x) $ [1..1000]
23:02:52 <lambdabot>  1000368199144695177095375011227646795567793680622934654583760988100234910747...
23:03:08 <ivanm> narain: are you trying to crash lambdabot?
23:03:21 <dmwit> > sum [x^x | x <- [1..1000]]
23:03:22 <narain> eep. not on purpose, sorry
23:03:22 <fantasma> > sum [1..]
23:03:23 <lambdabot>  1000368199144695177095375011227646795567793680622934654583760988100234910747...
23:03:27 <lambdabot> Terminated
23:03:42 <dmwit> narain: Don't worry, others have tried before you... =P
23:03:51 <fantasma> i want to crash him
23:04:03 <fishkandy> her
23:04:10 <fantasma> my bad
23:04:20 <ivanm> I think nmessenger did a @pl problem once when I first joined #haskell that took up quite a few lines before terminating
23:04:20 <dmwit> > foldr (\x y -> x + y^y) 0 [1..1000]
23:04:24 <fantasma> :*
23:04:25 <lambdabot> Terminated
23:04:48 <dmwit> :t foldr
23:04:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:05:03 <ivanm> :t foldr (\x y -> x + y^y) 0 [1..1000]
23:05:04 <fantasma> > repeat karma+ fantasma
23:05:05 <lambdabot>   Not in scope: `fantasma'
23:05:06 <lambdabot> forall b. (Integral b) => b
23:05:08 <dmwit> > foldr (\x y -> x^x + y) 0 [1..1000]
23:05:10 <lambdabot>  1000368199144695177095375011227646795567793680622934654583760988100234910747...
23:05:10 <sieni> @pl \x -> (x,x)
23:05:11 <lambdabot> join (,)
23:05:16 <fantasma> > repeat "karma+ fantasma" 10
23:05:17 <lambdabot>  Couldn't match expected type `t1 -> t'
23:05:23 <fantasma> > repeat 10 "karma+ fantasma"
23:05:24 <lambdabot>  Couldn't match expected type `[Char] -> t'
23:05:28 <sieni> @pl \x -> x*x
23:05:28 <lambdabot> join (*)
23:05:29 <fantasma> :t repeat
23:05:32 <lambdabot> forall a. a -> [a]
23:05:37 <bd_> fantasma: do you mean replicate?
23:05:41 <ivanm> @pl \q w e r t y u i o p -> q w e r t y u i o 1
23:05:42 <bd_> :t replicate
23:05:42 <lambdabot> ((((((((const .) .) .) .) .) .) .) .) . flip flip 1 . ((flip . ((flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .)) .)) .)
23:05:44 <lambdabot> forall a. Int -> a -> [a]
23:05:47 <fantasma> > replicate 10 "karma+ fantasma"
23:05:49 <lambdabot>  ["karma+ fantasma","karma+ fantasma","karma+ fantasma","karma+ fantasma","ka...
23:05:54 <ivanm> lol
23:06:01 <ivanm> fantasma: stop trying to cheat the system!
23:06:09 <ivanm> you're not meant to karma+ yourself!
23:06:09 <fantasma> ;)
23:06:13 <ivanm> fantasma--
23:06:19 <ivanm> @karma fantasma
23:06:19 <lambdabot> fantasma has a karma of -1
23:06:21 <bd_> If you really want to be clever you've got to use @where+ ;)
23:06:24 <fantasma> haha
23:06:26 <sieni> @pl \x -> (\y -> y*y) x
23:06:27 <lambdabot> join (*)
23:06:28 <ivanm> :p
23:06:29 <bd_> fantasma++ for effort
23:06:45 <dmwit> siene: (^2)?
23:06:53 <dmwit> :t join
23:06:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:07:56 <bd_> > transpose $ replicateM 8 " #"
23:07:57 <lambdabot>  ["                                                                          ...
23:08:00 <bd_> hm
23:08:25 <rahikkala> > transpose $ replicateM 3 " #"
23:08:27 <lambdabot>  ["    ####","  ##  ##"," # # # #"]
23:08:41 <bd_> not exactly what I meant... hm
23:08:53 <bd_> @src replicateM
23:08:53 <lambdabot> replicateM n x = sequence (replicate n x)
23:08:58 <narain> > replicateM 3 " #"
23:08:59 <lambdabot>  ["   ","  #"," # "," ##","#  ","# #","## ","###"]
23:09:01 <bd_> oh
23:09:09 <bd_> dright XD
23:09:15 <narain> what *is* that thing doing?
23:09:30 <rahikkala> It's doing scary sequence stuff
23:09:32 <narain> :t replicateM
23:09:33 <bd_> > replicateM 3 "01" -- counts from 000 to 111 in binary ;)
23:09:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
23:09:36 <lambdabot>  ["000","001","010","011","100","101","110","111"]
23:09:43 <rahikkala> @src sequence
23:09:43 <lambdabot> sequence ms = foldr k (return []) ms
23:09:44 <lambdabot>     where
23:09:44 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
23:09:50 <narain> whoa
23:09:51 <bd_> it's operating in the list monad
23:09:54 <narain> @src replicateM
23:09:54 <lambdabot> replicateM n x = sequence (replicate n x)
23:10:07 <rahikkala> That function is so deceptively short for all the... things... it does
23:10:08 <bd_> so if we desugar a bit
23:10:09 <bd_> it's:
23:10:31 <bd_> > do { a <- ['0', '1']; b <- ['0', '1']; c <- ['0', '1']; return [a,b,c] }
23:10:32 <lambdabot>  ["000","001","010","011","100","101","110","111"]
23:10:35 <narain> > sequence [1,2,3]
23:10:42 <bd_> only replicateM is shorter :)
23:10:49 <bd_> narain: Int is not an instance of Monad :)
23:10:50 <Cale> sequence = foldr (liftM2 (:)) (return [])
23:11:00 <narain> :t sequence
23:11:03 <lambdabot>     Ambiguous occurrence `sequence'
23:11:03 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
23:11:05 <rahikkala> > (sequence [Just 5, Just 6, Just 7], sequence [Just 5, Nothing, Just 7])
23:11:10 <narain> :t Prelude.sequence
23:11:12 <bd_> :t Control.Monad.Sequence
23:11:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:11:15 <lambdabot>     Not in scope: data constructor `Control.Monad.Sequence'
23:11:22 <narain> ah, it expects lists of monads
23:11:33 <Cale> lists of computations
23:12:16 <narain> what happened to rahikkala's snippet?
23:12:19 <narain> no output
23:12:22 <narain> > 1 + 2
23:12:23 <lambdabot>  3
23:12:28 <narain> lb's still alive
23:12:40 <narain> > sequence [Just 1, Just 2]
23:12:52 <bd_> > Prelude.sequence [Just 1, Just 3]
23:12:53 <lambdabot>  Just [1,3]
23:13:01 <narain> hm. weird
23:13:06 <dmwit> Heh, "there are two groups of people in the world: those who can be categorized into one of two groups of people, and those who can't."
23:13:10 <bd_> > Prelude.sequence [Just 1, Nothing]
23:13:11 <lambdabot>  Nothing
23:13:22 <ivanm> http://www.xs4all.nl/~jcdverha/scijokes/6.html
23:13:23 <lambdabot> Title: Science Jokes:6. THE MATHEMATICIAN, THE PHYSICIST AND THE ENGINEER (AND OTHERS)
23:13:32 <ivanm> the fence jokes are good ;)
23:15:27 <narain> dmwit: an autological word is one that describes itself, such as "short", "pentasyllabic", "unphonetic". a heterological word is one that is not autological, e.g. "hot", "gravitational", "unknown". now is "heterological" heterological?
23:15:51 <dmwit> Ha!
23:16:03 <dmwit> Although I might argue that "hot" is autological.
23:16:09 <narain> that's hot.
23:16:10 <dmwit> I know I get a rush every time *I* read it.
23:17:26 <dons> heh:        insults     If set, sudo will insult users when they enter
23:17:26 <dons>                    an incorrect password.  This flag is on by
23:17:27 <dons>                    default.
23:18:26 <narain> *on* by default?
23:18:37 <dons> of course!
23:18:50 <narain> hmm, that implies i've never misspelled my password to sudo
23:19:01 <narain> i don't recall ever being insulted by my computer
23:19:54 <sjanssen> dons: gentoo's sudo package has an "offensive" USE flag (which is off by default)
23:19:56 <Muad_Dib> well, I see it as an insulft if it doesn't do what I want it to do (although most often that is my own mistake)
23:20:03 <sjanssen> USE flags are compile time options
23:29:00 <ski> hm, what is the name for words, where attempting to use it to describe itself is meaningless ?
23:30:16 <narain> ski: heterological?
23:30:44 <narain> http://en.wikipedia.org/wiki/Grelling-Nelson_paradox
23:31:58 <ski> isn't 'heterological' when using it to describe itself yields falsity ?
23:32:27 <narain> no. "heterological" is heterological iff it is not heterological
23:33:01 <narain> i just mentioned it about it a minute ago here
23:33:20 <ski> rephrasing .. isn't a word 'heterological' when using the word to describe itself yields falsity ?
23:34:08 <narain> hmm, not sure i understand the question now
23:34:16 <narain> oh
23:34:19 <narain> yes
23:34:25 <ski> e.g. 'long' could be argued to not describe itself .. i.e. when applied to itself, yields falsity
23:34:29 <narain> right
23:35:07 <ski> otoh, 'blue' when applied to itself is meaningless, since words (by themselves, as opposed to written glyphs) doesn't usually have color
23:35:20 <narain> i don't know if there's a word for words like that
23:35:24 <ski> ok
23:35:49 <narain> any word which does not describe words would fit the criteria though
23:36:02 <narain> that may not be an interesting category
23:37:01 <narain> "nonlinguistic"? :p
23:56:39 <dmwit> How about "mu"?
23:57:24 <narain> "the word 'blue' is mu"
23:57:28 <narain> "'blue' is a mu word"
23:57:34 <narain> nah, doesn't work :)
23:57:35 <dmwit> http://www.ccil.org/jargon/jargon_28.html#TAG1183
23:57:37 <lambdabot> Title: The New Hacker's Dictionary - = M =
23:57:57 <narain> yes yes
23:58:09 <narain> i'm aware of that
23:58:19 <dmwit> k =)
23:58:23 <narain> :)
23:58:51 <dmwit> "mulogical
23:58:53 <dmwit> "
23:59:31 <dmwit> Argh, the state monad is warping me.
23:59:31 <narain> "It almost certainly derives from overgeneralization of the answer in the following    well-known Rinzei Zen teaching riddle"
23:59:32 <narain> heh
