00:01:44 <bos_> what are the doodads that ADTs contain referred to? branches? dangly bits? wibbles?
00:01:56 <bos_> i.e. data Foo = Doodad1 | Doodad2 | WTF
00:04:00 <robreim> bos_: constructors? That's what I call them anyway...
00:04:57 <bos_> yeah, i know the first element of each branch-doodad-what-have-you is a constructor, but i'm wondering about the thing as a whole, not just the constructor.
00:05:43 <monochrom> summands, viewing the type as a sum type
00:06:12 <monochrom> I say "cases" in casual writings
00:06:43 <monochrom> variants, from Pascal wording
00:08:42 <bos_> does darcs give me an easy way to see all of my recorded changes in a big diff?
00:09:29 * araujo wonders if haskell.org is going to participate in this GSoC
00:12:03 <bos_> i'm happy. the ipv6 support took about 5 hours to add.
00:12:39 <bos_> http://www.haskell.org/pipermail/libraries/2007-March/006991.html
00:12:40 <lambdabot> Title: ANN: IPv6 support for network
00:14:40 <bos_> people who observe that the networking libraries are a bit of a mess are correct.
00:17:04 <kfish> bos_, nice work
00:20:25 <Thunde1> bos: Oh, why did you not use the four year old code that already exists?
00:25:36 <bos_> Thunde1: url?
00:31:53 <Thunde1> bos: I do not find it anymore, so please never mind. Sorry.
00:32:13 <Thunde1> I can send you my copy.
00:33:28 <Thunde1> Oh found: http://www.tutorials-blog.com/functional/Haskell-55000/ -> ftp://ftp.iks-jena.de/pub/mitarb/lutz/haskell/GHCv6.tgz
00:33:30 <lambdabot> Title: tutorials-blog.com >> functional >> IPv6 for Haskell
00:43:40 <bos_> Thunde1: his code changes the implementation of getHostByName
00:46:14 <bos_> and mine is a bit better designed.
00:47:11 <Thunde1> bos: That's no question.Do you have open topic to do? Can I help?
00:47:45 <Thunde1> bos: Of course, it's my code. I know that's a crude hack.
00:47:48 <bos_> Thunde1: do you have windows?
00:47:57 <bos_> oh, sorry :-)
00:48:17 <Thunde1> bos: I think I can find a Windows computer.
00:48:26 <Thunde1> Vista.
00:48:32 <bos_> Thunde1: there is not a huge difference between the two.
00:48:53 <bos_> Thunde1: i have not compile-tested on windows.
00:49:15 <bos_> or any non-linux in fact.
00:49:35 <Thunde1> bos: That's why I ask you... network-alt is even older and better designed, but I prefer v6 in the standard lib. My implementation was dirty enough to prevent the inclusion ...
00:49:44 <bos_> so a little testing would be very welcome.
00:49:51 <bos_> really?
00:49:57 <Thunde1> bos: NextStep, VMS, True64 ...
00:51:49 <Japsu> > let { (^.^) x y = x * y; d = 7; b = 191 } in d ^.^ b
00:51:50 <lambdabot>  1337
00:52:11 <merus> wow.
00:52:16 <merus> that's... sad.
00:52:46 <Japsu> O_o
00:52:50 <mauke> > let { (^.^) = (*); d = 7; b = 191 } in d ^.^ b
00:52:52 <lambdabot>  1337
00:53:00 <Japsu> yay
00:53:09 <Japsu> that's much better
00:54:13 <xs> is HaskellDb dead?
00:54:58 <Thunde1> bos: I'll give it a try.
00:58:24 <bos_> Thunde1: thank you!
01:46:38 <Baughn> Is there a withTimeout thing I can use on network operations such as Network.Socket.recv?
01:51:05 <sebell> Baughn: looks like there is one in HAppS
01:54:00 <Baughn> Seems like it won't work with blocking foreign calls
01:54:19 <Baughn> Or does the safe version do so? I'm so confused
01:54:33 <Baughn> And I'd rather stick to GHC, if possible. :/
01:55:32 <Baughn> Actually, I don't really want to call recv at all; I want to make a Handle from it (can do), then use a timeout on that and assume GHC internally does the select/poll loop thing. Presumably it does.
01:55:46 <Baughn> Still need to find a timeout, though. Somewhere in Control, maybe..
01:56:40 <Baughn> Mind you making a Handle from an UDP socket seems a bit troublesome - I won't have any way to do recvFrom, or of making sure my packets actually stay as single packets.
01:57:12 <Baughn> mauke: Oh, any ideas?
01:57:17 <endless_> Hi, everyone. I'm a real beginner to Haskell. I'm currently wondering how to use a file as input to my program? I'm using Hugs and tried main < thefile.txt, but that doesn't seem to work.
01:57:31 <nornagon> :t interact
01:57:33 <lambdabot> (String -> String) -> IO ()
01:57:57 <nornagon> interact (toUpper)
01:58:01 <Baughn> endless_: For pure filters, main = interact works fine.
01:58:03 <nornagon> in: hello! out: HELLO!
01:58:08 <mauke> nornagon: map
01:58:21 <nornagon> mauke: oops
01:58:32 <nornagon> still a newbie :)
01:59:13 <endless_> Oh, sorry. In my main.hs i've got main = do in_file <- getContents
01:59:44 <nornagon> yup, so main < file should work fine
01:59:55 <nornagon> but obv. you have to have other things in main
01:59:58 <mauke> not in hugs
02:00:00 <endless_> right
02:00:18 <endless_> but in Hugs it says ERROR - Undefined variable
02:00:31 <nornagon> undefined variable what?
02:00:34 <endless_> and then gives part of the name of my input file
02:00:58 <endless_> ERROR - Undefined variable "txt"
02:01:09 <endless_> and the file being used is test.txt
02:01:20 <mauke> it's not a file
02:01:49 <mauke> it's three variables (main, test and txt) and two operators (< and .)
02:01:57 <mauke> hugs is not a shell
02:02:21 <nornagon> ah
02:02:23 <nornagon> heh
02:02:37 <nornagon> i was going, surely he means $ runhugs main.hs < test.txt
02:03:05 <nornagon> $ runhugs test.hs < test.hs
02:03:07 <nornagon> module Main where
02:03:07 <nornagon> main = do in_file <- getContents putStrLn in_file
02:03:14 <nornagon> gr, irssi folded the lines
02:03:16 <endless_> ah, i got it now
02:03:22 <endless_> like i said, real beginner ;P
02:07:01 <Baughn> I'm trying to communicate with an UDP server, which means sometimes messages get lost and I need to resend them. (It reimplements tcp, badly.)
02:07:20 <Baughn> As such, I need some sort of timeout on reading data from the socket
02:07:34 <Baughn> How should I do this?
02:08:04 <sebell> Baughn: I thought I pointed you to HAppS earlier... there's a few other implementations of withTimeout floating around on the web also (Google)
02:08:29 <Baughn> sebell: You did, but it explicitly states that it doesn't work with blocking foreign calls
02:09:21 <Baughn> Actually, it's got one function that works anyway. I just don't trust it - how can that work?
02:09:22 <sebell> Baughn: "The module provides a slightly slower alternative implementation which returns even if the computation has blocked on a foreign call." - from the Haddock
02:09:45 <Baughn> I really want to embed myself in ghc's main select loop. :/
02:10:18 <Baughn> sebell: It's not like you can interrupt a kernel function, so how does it /work/?
02:12:35 <sebell> Baughn: ? I would download and read the code
02:13:48 <sebell> Baughn: I'm assuming it starts up a thread that sleeps for the timeout period and if it wakes up before being killed itself, kills the IO thread
02:14:33 <Baughn> sebell: I'm looking at the code. It's hard to understand, so this might take a while.
02:14:50 <quicksilver> SIGALRM will interrupt a blocked IO call
02:14:51 <quicksilver> I believe
02:28:41 <vincenz> @seen Lemmih
02:28:41 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
02:29:02 <vincenz> @seen dmhouse
02:29:02 <lambdabot> I saw dmhouse leaving #happs, #haskell-blah and #haskell 11h 23m 20s ago, and .
02:29:07 <vincenz> @seen jethr0
02:29:08 <lambdabot> I haven't seen jethr0.
02:29:11 <Vq^> quicksilver: yeah, but you need to handle EINTR from your IO syscalls as a non-error then
02:31:34 <quicksilver> Vq^: *nod* this is true
02:40:03 <JohnMeacham_> hello! someone spoke of me.
02:40:18 <JohnMeacham_> but my chat client is silly and won't tell me whom.
02:41:23 <nominolo> ?where logs
02:41:24 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
02:41:24 <ibid> probably this:
02:41:25 <ibid> 03:15 #haskell:  <sorear> hello JohnMeacham_
02:41:33 <JohnMeacham> hello!
02:41:50 <ibid> and a lot of lambdabot quotes from you :)
02:41:58 <JohnMeacham> hmmm... IRC is a silly protocol.
02:44:01 <quicksilver> @quote johnmeacham
02:44:01 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
02:44:09 * quicksilver peers around suspciiously
02:44:16 <ibid> @quote JohnMeacham
02:44:16 <lambdabot> JohnMeacham says: There will also be a karaoke competition to determine the fate of the monomorphism restriction.
02:44:49 <ibid> is there a list of these quotations somewhere or do we have to @quote them all to find out? :)
02:46:40 <mauke> @quote ^
02:46:41 <lambdabot> dons says: note that you're using all the advanced features of haskell in 1 line here...
02:50:07 <Saizan> they should have quoted the line :D
02:50:43 <ibid> @quote
02:50:44 <lambdabot> nocotigo says: if you can't tell what encoding the code is in, i'd say you've gone too far
03:27:58 <Baughn> sebell: As it turns out, the "safe" version of withTimeOut handles blocking functions by leaving them running, just in a different thread. Not very useful for me, but I found an alternative.
03:41:36 <matt__r> quiet night
03:42:06 <ivanm> yeah
03:42:32 <matt__r> I guess I don't have anything constructive to add either
03:42:37 <ivanm> @yarr
03:42:38 <lambdabot> Yeh scurvy dog...
03:42:42 <matt__r> so I suppose I shouldn't complain
03:42:56 <matt__r> ahhh, old lambdabot, always good for a laugh
03:43:00 <matt__r> @yarr
03:43:01 <lambdabot> Arr! Me ship be the biggest brig in the port!
03:43:08 <matt__r> it sure is
03:43:11 <ivanm> :t const
03:43:11 <Baughn> Question, then. If I have an fd (or a Socket, or a Handle), how do I wait until (a) some data is available, or (b) a timeout has passed ?
03:43:13 <lambdabot> forall a b. a -> b -> a
03:43:33 <ivanm> map (flip const @yarr) [1..5]
03:43:35 <Baughn> There is a select loop inside ghc. I guess I'm just looking for a way to exploit it..
03:43:40 <ivanm> > map (flip const @yarr) [1..5]
03:43:41 <lambdabot>   Pattern syntax in expression context: const@yarr
03:43:47 <ivanm> :(
03:43:56 <matt__r> Baughn: hmmmm, that is a tough one
03:44:23 <Baughn> I hope not, considering that it's so very simple in POSIX.
03:44:44 <matt__r> probably not a tough problem
03:44:47 <apfelmus> Baughn: you just say getContents?
03:44:48 <matt__r> but I tough question
03:44:57 <matt__r> if only by virtue of the fact I don't know the anser
03:45:07 <matt__r> I think laziness allows some tricks here
03:45:20 <matt__r> try it and see
03:45:20 <Baughn> That shouldn't work..
03:45:40 <matt__r> well on a file descriptor, it will just stop at the end of the file, whatever state it is currently is (i.e empty)
03:45:42 <Baughn> I don't see how I'd get a timeout - and if enough time passes, I need to re-send some data.
03:45:56 <Baughn> It's an UDP socket. EOF need not apply.
03:46:42 <Baughn> hWaitForInput looks good, except that it claims to be broken. :/
03:47:07 <matt__r> indeed
03:47:36 <matt__r> you could call out to the posix function :)
03:48:04 <Baughn> select? That'd be.. yes, I guess I could, with forkOS
03:48:42 <dons> sjanssen: abstract StackSet (with QC properties) now in the src. state logged to stderr currently too
03:48:52 <matt__r> I am afraid I have managed to position myself in life so I never have to worry about such things
03:49:04 <matt__r> so I am no use to you :(
03:49:46 <Baughn> Of course, I wouldn't want one OS thread per socket, but select is helpful there, but then.. I'm reimplementing GHC's main loop instead of using the one already in place. There /has/ to be a better way.
03:50:46 <apfelmus> mh, in a sense, you are reimplementing TCP fault tolerance
03:50:50 <quicksilver> Baughn: I'm not at all sure that GHC has a main loop in the sense you suggest
03:51:00 <quicksilver> Baughn: GHC is a compiler, not an event-driven runtime
03:51:10 <Baughn> quicksilver: GHC's RTS, if you like
03:51:20 <quicksilver> well, I'm not sure the RTS is an event loop
03:51:35 <matt__r> Baughn: I think I am with quicksilver here
03:51:36 <Baughn> The runtime it uses /is/ event-driven, by inference; the apparently blocking functions do not block other lightweight threads
03:51:50 <quicksilver> ah, the threaded runtime
03:51:59 <quicksilver> I don't know how the threaded runtime works, good point
03:52:01 <matt__r> now I am switching - perhaps Buaghn is right....
03:52:03 <Baughn> There are only two ways I know of to implement that, and the other - polling - is insane.
03:52:09 <matt__r> so exciting
03:52:16 <matt__r> no polling!
03:52:21 <matt__r> no polling!
03:52:25 <matt__r> no polling!
03:52:30 <quicksilver> Baughn: pre-threads, the compiler produced a main() which really did map to your program's main
03:52:42 <quicksilver> Baughn: with lightweight threading I guess the arch did change a bit
03:52:51 <matt__r> I work at a uni and you cannot believe how often students turn to polling when there is no reason to at all
03:53:12 <quicksilver> polling is easy, when you've been taught imperative style programming
03:53:18 <quicksilver> event-driven programming is different :)
03:53:20 <resiak> matt__r: Students in "not knowing how to write good code" shocker?
03:53:29 <quicksilver> and select() is clever, but hardly intuitive to a first-year student
03:53:58 <matt__r> resiak: I know, but sometimes they have a program that needs no events, nothing like that and they still have some polling-like structure set up
03:54:10 <matt__r> they all learn event handling in first year I think
03:54:37 <matt__r> I think it is the natural state of the poor programmer - to poll things
03:54:50 <quicksilver> I think it is a natural consequence of the way you teach poor programmers
03:54:58 <quicksilver> if you taught poor programmers hypercard, for example
03:55:05 <quicksilver> then they'd probably use events, at least to some extent
03:55:06 <matt__r> quicksilver: you could be right
03:55:08 <quicksilver> (but make other mistakes)
03:55:13 <Baughn> Happily, lightweight threads means you can pretend to be blocking when you're really event-driven. It'S easier.
03:55:22 <Baughn> It just doesn't work for me right now.
03:55:40 * quicksilver nod
03:55:42 <quicksilver> right
03:55:51 <quicksilver> unfortunately thread synchronisation issues are *not* easier :)
03:55:58 <quicksilver> and that's why all java programs have bugs in
03:56:15 <quicksilver> admittedly, haskell's thread abstraction is rather more robust than java's
03:56:40 <Baughn> I didn't find the actual call to select(), but http://hackage.haskell.org/trac/ghc/ticket/635 implies that it does use it
03:56:42 <lambdabot> Title: #635 (Replace use of select() in the I/O manager with epoll/kqueue/etc.) - GHC - ...
03:57:22 <Baughn> If I have to add timeouts myself, I will, but I'd like someone to tell me I don't have to rewrite the I/O manager. :)
03:58:07 <quicksilver> well, JaffaCake is the man, probably, to show you the way
03:58:10 <quicksilver> JaffaCake: ping
03:58:17 <JaffaCake> hello?
03:58:31 <quicksilver> JaffaCake: Baughn has trouble with threads and timeouts and IO
03:58:38 <quicksilver> JaffaCake: perhaps you can shed some light?
03:58:52 <JaffaCake> what's the problem? should I read up?
03:59:11 <quicksilver> 11:41 < Baughn> Question, then. If I have an fd (or a Socket, or a Handle), how
03:59:15 <quicksilver>                 do I wait until (a) some data is available, or (b) a timeout
03:59:17 <quicksilver>                 has passed ?
03:59:27 <quicksilver> he wants to do a select()-with-timeout
03:59:43 <quicksilver> and he wonders if he needs to write his own select, or if he can 'use' the one built in to the threaded runtime
03:59:44 <Baughn> JaffaCake: I've got an UDP protocol that's reimplementing TCP, and I need to implement a flowchart with timeouts in it. The TCP flowchart, in fact.
04:00:09 <Baughn> The easy way is to use forkOS and do this in an entirely separate thread, in C
04:00:26 <JaffaCake> no need to use forkOS, certainly
04:00:45 <JaffaCake> you could use the new System.Timeout with threadWaitRead
04:01:17 <Baughn> By "new", you mean "not in 6.6"?
04:01:38 <JaffaCake> yes... the patch went into libraries/base a few days ago
04:02:01 <JaffaCake> it's only a few lines of code, you can easily use it separately
04:02:12 <kzm> Any standard function to get list elements corresponding to a (sorted) set of indices?  I.e., zipWith (!!), but linear performance?
04:02:20 <JaffaCake> http://darcs.haskell.org/packages/base/System/Timeout.hs
04:02:21 <Baughn> I'm building the newest version anyway, so that's fine
04:02:42 <quicksilver> kzm: I'm pretty sure the answer is no.
04:03:18 <Baughn> @docs threadWaitRead
04:03:18 <lambdabot> threadWaitRead not available
04:03:23 <JaffaCake> so you want System.Timeout.timeout N (threadWaitRead fd)
04:03:33 <JaffaCake> Control.Concurrent.threadWaitRead
04:03:42 <kzm> quicksilver, well - it's premature optimization, anyway :-)  zipWith (!!) for now.
04:04:02 <Baughn> JaffaCake: Ah. Yes, that'll do.
04:04:30 <Baughn> JaffaCake: Thanks - you've cut me down from hundreds of lines of C to a dozen lines of haskell. :)
04:04:44 <JaffaCake> great :)
04:05:09 <JaffaCake> note that it won't work on Windows at the moment
04:05:10 <quicksilver> kzm: right. Premature optimization is the root of all evil.
04:05:38 <Baughn> Next, is there a datagram/message-like stream I can instance instead of building my own? Handle really doesn't fit
04:05:42 <Baughn> JaffaCake: Not an issue.
04:10:20 <ivanm> JaffaCake: you mean people still use that archaic and clunky OS? ;-)
04:10:50 <JaffaCake> not always out of choice :)
04:11:16 <SamB> JaffaCake: do they force you MSR employees to use it or something?
04:11:51 <JaffaCake> we don't really have a choice for our desktop machines, but I do dual-boot my laptop, and we have Linux servers to access remotely
04:12:04 <SamB> also, I think windows grows less archaic
04:12:10 <Baughn> JaffaCake: Say, it does work on osx, I hope?
04:12:11 <SamB> maybe not actually less clunky yet
04:12:22 <JaffaCake> Baughn: sure, I think so
04:13:34 <SamB> JaffaCake: so, for how long is this only going to work under unix?
04:13:54 <JaffaCake> until someone gets around to implementing the I/O manager on Windows
04:14:02 <SamB> mmm.
04:14:23 <JaffaCake> the way to do non-blocking I/O on Windows is quite different: you have to use the overlapped I/O operations I think
04:14:58 <SamB> yeah. select isn't going to get you very far ;-)
04:15:08 <Baughn> libevent would help, though
04:15:17 <JaffaCake> but it would be moving in the right direction; we'd be using native Win32 instead of the CRT stuff
04:15:33 <SamB> (it only handles 64 sockets, iirc. emhasis on sockets.)
04:15:34 <JaffaCake> Baughn: libevent is supported on Windows?
04:15:48 <JaffaCake> oh, only for sockets?
04:15:55 <Baughn> JaffaCake: It claims to be
04:16:10 <SamB> JaffaCake: on windows? yes.
04:16:30 <JaffaCake> right, that's not really going to be good enough then
04:16:34 <Baughn> JaffaCake: By the way, most POSIX I/O functions get interrupted quite nicely if you receive a signal. Does ghc use that?
04:16:48 <SamB> JaffaCake: well, 64 isn't really enough either ;-)
04:17:02 <JaffaCake> Baughn: we don't use it to implement async exceptions, no
04:17:15 <JaffaCake> SamB: indeed not
04:17:17 <quicksilver> 64 sockets ought to be enough for anybody?
04:17:33 * quicksilver mimes a cymbal clash
04:17:45 <Baughn> They could at least have used 640. -_-
04:18:04 <SamB> quicksilver: maybe select was not meant to be used in new programs for a long time?
04:18:42 * SamB wonders how much RAM the old 286 system he used had
04:19:08 * SamB doesn't remember what "high memory" is
04:19:40 <Baughn> High memory is the bit.. some kilobytes.. just above 1MB that can be accessed due to the segments overlapping
04:19:57 <JaffaCake> heh, I remember that
04:20:03 <Baughn> 48K, I think. The segments are 64K, but overlap at 16K intervals, so the last segment starts 16K before 1MB...
04:20:24 <JaffaCake> you could load part of the OS up there to make more space for games, or something
04:20:24 <pejo> SamB, funny how we have the same problem with memory over 4G on the 32 bit architectures. :-)
04:20:44 <SamB> pejo: do we?
04:20:54 <Baughn> JaffaCake: Yes indeed. "This game requires 638 KB conventional memory" was quite a bane.
04:21:03 * SamB thought the OS could deal with that, if the hardware could handle it
04:21:09 <quicksilver> SamB: modern selects don't have the the 64-limit any more
04:21:13 <pejo> SamB, yeah, on the OS level. Lots of braindead hardware.
04:21:48 <SamB> see, in the DOS days the OS could not handle it
04:21:53 <Baughn> SamB: There's a similar problem at 16MB, too. More braindead hardware.
04:24:12 <Baughn> And at 1GB. And at 3.9997 GB, oddly.
04:24:30 <SamB> oooookay
04:25:01 <SamB> > 3.9997 * 1024^3
04:25:02 <lambdabot>  4.2946451734528e9
04:25:03 <Baughn> SamB: And now you know why linux reserves memory below 16MB as DMA zones.
04:25:08 <SamB> hmm.
04:25:23 <Baughn> SamB: ..you know I just pulled that one out of a hat. "Slightly below 4 GB".
04:25:31 <SamB> hmm.
04:25:50 <SamB> I don't know how to display floating point in hex anyway
04:26:09 <SamB> anyway, I don't consider "braindead hardware" to be the issue at 4gb, necessarily
04:26:18 <Baughn> > 39997 * 1024^3 / 10000
04:26:19 <lambdabot>  4.2946451734528e9
04:26:31 <Baughn> > 39997 * 1024^3 / 10000 :: Integer
04:26:32 <lambdabot>   add an instance declaration for (Fractional Integer)
04:26:32 <lambdabot>     In the expression:...
04:26:35 <SamB> > 39997 * 1024^3 `div` 10000
04:26:36 <lambdabot>  4294645173
04:26:52 <Baughn> Interesting.
04:27:29 <SamB> see, they needed to extend the CPU architecture to allow the mapping of more than 4 GB of RAM
04:27:44 <Baughn> Yes, which is fine for the CPU.
04:28:04 <pejo> SamB, so what is the issue at 4G?
04:28:07 <matthew_-> http://lwn.net/Articles/224654/
04:28:09 <lambdabot> Title: LWN: Patch: RSDL completely fair starvation free interactive cpu scheduler
04:28:13 <matthew_-> agh, ww, so sorry
04:28:14 <Baughn> I suspect foul play with PCIe - it doesn't support hardware that doesn't take 48-bit addresses, either. ;)
04:28:30 <SamB> pejo: some hardware does not support it
04:28:32 <SamB> Baughn: hmm?
04:28:43 <SamB> you think it is planned obsolescence?
04:29:04 * SamB doesn't think ethernet supports hardware that doesn't take 48-bit addresses, either ;-P
04:29:26 <Baughn> SamB: PCI cards don't fit anyway. It's more along the lines of making sure nobody makes PCIe hardware that gets people in trouble.
04:29:37 <SamB> oh
04:29:50 <Baughn> pejo: Some hardware uses 32-bit addresses. Or 24-bit. Or 20-bit.
04:30:32 <Baughn> pejo: Annoyingly, PCI allows that. PCIe doesn't, so.. yay.
04:30:52 <SamB> so why does linux claim I have 251 MB of RAM?
04:31:00 <SamB> is it only reserving 4 MB for DMA?
04:31:29 <Baughn> SamB: It includes that. Integrated graphics card?
04:31:35 <SamB> or is that 4 MB just the kernel and its non-pageable datastructures?
04:31:54 <SamB> I have a voodoo 3...
04:32:07 <Baughn> SamB: What command claims 251MB?
04:32:32 <SamB> there is a builtin card, but it gets disabled when I boot with another one...
04:32:37 <SamB> um, gkrellm
04:33:31 <Baughn> SamB: What does /proc/mtrr say?
04:33:55 <SamB> % cat /proc/mtrr
04:33:55 <SamB> reg00: base=0x00000000 (   0MB), size= 256MB: write-back, count=1
04:33:55 <SamB> reg01: base=0xf8000000 (3968MB), size=  32MB: write-combining, count=1
04:34:14 <arjanoosting> dat is inderdaad veel verstandiger :-)
04:34:15 <Baughn> SamB: Mm. Probably the kernel, then.
04:34:21 <Baughn> SamB: dmesg would let you know for sure.
04:36:26 <Baughn> 1024924k/1047424k available (2379k kernel code, 21740k reserved,
04:36:26 <Baughn> 1526k data, 180k init)
04:40:28 <skoom> shit theres alot of ppl in ere ey
04:41:08 <amiddelk> yes, but don't worry, most are inactive and wont eat you yet
04:41:15 * Baughn has just eaten.
04:41:28 <quicksilver> @losers
04:41:29 <lambdabot> Maximum users seen in #haskell: 339, currently: 297 (87.6%), active: 36 (12.1%)
04:41:38 <quicksilver> climbing slowly
04:41:44 <quicksilver> did dons draw graphs of his predictions?
04:41:58 <skoom> ne aussies?
04:42:21 <pejo> I'd say dons qualifies.
04:42:39 <quicksilver> do you mean 'any aussies' or 'any aussies awake'? :)
04:42:49 <skoom> either will do haha
04:43:08 <quicksilver> there are aussies around, including dons but there is little evidence of his wakefulness
04:43:56 <snappy> Is it possible to restrict the class of a argument in a lambda function definition?
04:44:29 <quicksilver> snappy: yes
04:44:35 <quicksilver> snappy: normally it happens implicitly
04:44:48 <quicksilver> snappy: simply by using it in context
04:45:18 <quicksilver> snappy: if that doesn't work, you can assign the correct type-signature to the enclosing top-level definition
04:45:35 <quicksilver> (or, using GHC extensions, you can assign a type sig to any term, but that isn't strictly haskell98 I think)
04:45:53 <snappy> hm, letsee.
04:46:30 <Baughn> The native code generator seems to be broken for osx/intel? It does what http://lists.apple.com/archives/Xcode-users/2006/Oct/msg00578.html says it shouldn't do.
04:46:33 <lambdabot> Title: Re: What is the meaning of "missing indirect symbols for section (__TEXT, __symb ..., http://tinyurl.com/ywd4u8
04:47:12 <skoom> where would b a good place to start on haskell, coming from .net
04:47:38 <quicksilver> skoom: the wiki is pretty good
04:47:39 <snappy> Hm, the lambda function takes in one list, how would I go about restricting the type of a list? eg. lambda func = \list ...where I want list to be only ints.
04:47:44 <quicksilver> skoom: there is a nice wikibook on wikibooks
04:47:58 <snappy> well Integral actually.
04:48:11 <quicksilver> snappy: normally it is automatic, from context
04:48:14 <quicksilver> snappy: watch:
04:48:19 <skoom> cool, thanks quicksilver
04:48:22 <quicksilver> :t (\list -> map (+1) list)
04:48:25 <lambdabot> forall a. (Num a) => [a] -> [a]
04:48:43 <quicksilver> snappy: you see, it deduces the 'Num a' restriction from the +1
04:49:47 <quicksilver> :t (\list -> map (`div` 2) list)
04:49:50 <lambdabot> forall a. (Integral a) => [a] -> [a]
04:49:56 <quicksilver> that one deduces Integral :)
04:49:59 <tuukkah> hmm, how would i enumerate Doubles?
04:50:20 <quicksilver> tuukkah: what do you mean? enumerate the entire data type?
04:50:29 <snappy> yaeh, hm
04:50:34 <tuukkah> quicksilver, yes
04:50:54 <quicksilver> tuukkah: I'm not sure you can. Is the data type even defined strictly by the report?
04:50:59 <snappy> i'm just trying to do a lambda for maximum: isLargest = (Ord l) => [l] -> foldl1 (max) l
04:51:06 <tuukkah> actually, i only want the doubles between 0.999 and 1.0
04:51:15 <snappy> If I don't type the lambda function, it complains
04:51:20 <quicksilver> snappy: isLargest = \l -> fold1 (max) l
04:51:27 <quicksilver> oops, missing l
04:51:35 <quicksilver> : \l -> foldl1 max l
04:51:39 <quicksilver> :t \l -> foldl1 max l
04:51:41 <lambdabot> forall a. (Ord a) => [a] -> a
04:52:22 <snappy> I get hte following error in hugs98: *** Outstanding context : Ord b
04:52:47 <quicksilver> snappy: don't put that context there
04:52:56 <quicksilver> just write this:
04:53:02 <snappy> I'm not, it's exactly how you have it
04:53:03 <quicksilver> isLargest = \l -> foldl1 max l
04:53:10 <snappy> ohh.
04:53:17 <snappy> hold.
04:53:44 <quicksilver> have you given it an explicit incorrect type?
04:53:46 <snappy> nope, it still complains, wit hthe above error
04:54:02 <quicksilver> have you got a line above with an explicit type?
04:54:07 <quicksilver> isLargest ::  something -> here
04:54:08 <quicksilver> ?
04:54:12 <snappy> I haven't provided it with an argument, im just trying to load my file at the moment.
04:54:24 <tuukkah> quicksilver, "Float is implementation-defined; it is desirable that this type be at least equal in range and precision to the IEEE single-precision type. Similarly, Double should cover IEEE double-precision."
04:54:27 <snappy> hold let m,e try with a brand new file.
04:54:31 <quicksilver> can you hpaste the file? or at least that portion of it
04:54:53 <quicksilver> tuukkah: right, so there can be no haskell98 code to enumerate it :)
04:54:58 <quicksilver> tuukkah: since the type is undefined
04:55:04 <quicksilver> tuukkah: why would you want to?
04:55:26 <hpaste>  MathematicalOrc pasted "Bitmap graphics in Gtk2hs" at http://hpaste.org/864
04:57:22 <hpaste>  snappy pasted "lambda function wont compile" at http://hpaste.org/865
04:57:26 * dcoutts_ wonders what kind of high level API MathematicalOrc would like
04:57:46 <snappy> quicksilver: http://hpaste.org/865
04:58:41 <tuukkah> quicksilver, i need to produce increasing decimal numbers and preferably as many of them as possible usable as doubles. now i think i mean ieee doubles and not haskell doubles
05:01:57 <Baughn> tuukkah: For what purpose?
05:02:16 <arvid> tuukkah: haskell doubles isn't the same as ieee doubles?
05:02:33 <doserj> snappy: http://www.haskell.org/haskellwiki/Monomorphism_restriction
05:02:34 <lambdabot> Title: Monomorphism restriction - HaskellWiki
05:02:44 <tuukkah> arvid, see the report quote above
05:03:18 <arvid> tuukkah: aha - okey
05:04:08 <snappy> doserj: wow, thanks.
05:04:12 <quicksilver> tuukkah: just pick an increment you're happy with and use that
05:04:23 <tuukkah> Baughn, there is an irc log in the rdf format and the events are ordered by XML Schema dateTime. if several events happen on the same second, i would employ the subsecond part to record the order
05:04:35 <kzm> Extracting some chunks from a file, and storing them in a slightly complicated nested data structure - what is the most elegant way to ensure GC of the unneeded file contents?  In particular, byte strings will just tend to be sliced - can that be avoided?
05:04:58 <Baughn> tuukkah: I read about a similar system once. However..
05:05:38 <quicksilver> snappy: the short answer, is write it as a defn with a parameter
05:05:39 <Baughn> tuukkah: It seems far cleaner to record time as a (second, sequence) tuple, where the sequence can increase sequentially (and infinitely).
05:06:09 <snappy> quicksilver: heh yeah, that's what im tihnking now, thanks.
05:06:30 <quicksilver> snappy: it's a bit annoying. note that you could happily use that lambda inside a function
05:06:41 <quicksilver> snappy: it's only top-levels without parameters that have the problem
05:06:53 <Baughn> tuukkah: The system in question incremented the second instead. Things got wonky once the number of transactions per second approached one, and while that isn"t a problem with yours, having to enumerate doubles (which approximate real numbers, which are uncountable and thus unenumerable) is.
05:07:21 <Baughn> tuukkah: Not to mention that doubles are /inaccurate/, and seconds-since-epoch is a large number.
05:07:33 <quicksilver> tuukkah: either just pick an increment which works and you are happy with (e.g. 10^-6 seconds)
05:07:39 <tuukkah> Baughn, indeed, but then we lose the interoperability with systems that don't interpret the extra pair of the tuple
05:07:45 <quicksilver> or use a sequence num as Baughn suggests
05:08:00 <quicksilver> surely the subsecond part of the XML Schema has a defined precision?
05:08:09 <tuukkah> quicksilver, i suppose i'm not being entirely practical with this :-)
05:08:40 <Baughn> tuukkah: If you pick a fixed precision, that is essentially the same thing as my sequence numbers
05:08:44 <tuukkah> quicksilver, the standard quarantees three decimal places, that's why i'm starting with 0.001...0.999 first
05:09:26 <Baughn> tuukkah: Just realize that you probably cannot read the whole time as a single number. The precision of floating-point numbers at the current time since epoch is, in fact, less than 1 for some commonly used sizes.
05:09:34 <tuukkah> Baughn, but then i have this stupid implementation limitation that i only support situations with less than 1000 events per second =)
05:09:49 <quicksilver> tuukkah: you have to work to the standard, though
05:09:54 <Baughn> tuukkah: That is inevitable unless you actually use a tuple.
05:10:00 <quicksilver> tuukkah: otherwise your interoperability point is invalid
05:10:22 <dons> sjanssen: so the event which firefox generates, and which dwm handles but we don't, is MappingNotify. i've stubbed in the code for it, but couldn't quite work out how to do the ffi stuff there. want to have a look?
05:10:26 <quicksilver> if the standard only specifies 3dp then use 3dp and scream if it breaks
05:10:44 <quicksilver> if you don't care about the standard then just use an Integer
05:11:10 <tuukkah> quicksilver, i'm trying to be as interoperable as possible :-) the standard says there is infinite precision in the type but implementations may implement only 3 dp
05:11:11 <Baughn> tuukkah: Just so you know, the system I mentioned - which handled only one transaction per second - was featured on dailywtf.com. Don't follow in its footsteps.
05:11:40 <Baughn> tuukkah: If the standard claims infinite precision, then the reals are, in fact, reals - and as such uncountable and unenumerable.
05:12:34 <quicksilver> they clearly aren't using reals
05:12:44 <tuukkah> hmm, perhaps i'm wrong in guessing that a typical implementation would represent the subsecond part as an ieee double
05:12:51 <quicksilver> infinite precision is acheived by strings of digits of arbitrary finite length
05:13:00 <quicksilver> tuukkah: if it did, it would be broken
05:13:08 <quicksilver> tuukkah: floating points are imprecise and rounded
05:13:16 <quicksilver> tuukkah: that would be a stupid way of storing sequence numbers :P
05:13:58 <tuukkah> well, clearly the dateTime isn't originally meant for sequence ordering :-/
05:13:58 <quicksilver> If you really want to do it right, it should be finite strings of digits understood to be right-padded with zeros
05:14:13 <quicksilver> (i.e. the standard denotation of things to the right of the decimal point)
05:14:26 <quicksilver> finite, but of unbounded length, that is
05:14:39 <quicksilver> still memory constraints may encourage you to bound the length in practice
05:14:41 <quicksilver> :)
05:15:22 <tuukkah> i thought after i run out of double precision i would just keep appending '1' :-)
05:16:42 <Baughn> tuukkah: Problem is, the precision is dependent on the value you're storing
05:16:49 <Baughn> tuukkah: It's not the same at 0.5 as it is at 0.1
05:17:06 <Baughn> Much less current-time-of-epoch
05:17:54 <tuukkah> storing the integer part from epoch wouldn't work anyway, right?
05:18:12 <Baughn>  Storing in what?
05:18:16 <tuukkah> in the same double as the fractional part, i mean
05:18:34 <Baughn> Mm. Nope.
05:19:01 <Baughn> As I said, precision decreases as the magnitude increses.
05:19:14 <Baughn> Current-time-of-epoch is a /large/ number.
05:19:18 <tuukkah> so i would only deal with doubles from ]0.999,1.0[
05:19:40 <Baughn> Why?
05:20:26 <Baughn> For any particular range, the distribution is the same. If you limit yourself to doubles that start with 0.999, the distrubution of numbers inside that is just as skewed as for double that start with 0.99, or 0.
05:20:33 <Baughn> ..mostly the same, at least.
05:20:53 <Baughn> Really, the only way to get predictable results is to use integers
05:20:55 <tuukkah> because a fraction is in ]0,1[ and i start with the ]0,0.999[ guaranteed by the standard for all implementations
05:21:26 <Baughn> Oh, you mean use 0.001, 0.002 ... 0.999?
05:21:45 <Baughn> That'd be.. annoying, to anyone with over 1000 events per second
05:22:01 <tuukkah> i think i've learned from this that whether i use this trick, i also want to come up with some additional, proper way such as a separate integer element
05:22:03 <Baughn> If you're concerned about interchange, look up what precision it's /supposed/ to be in
05:22:08 <Baughn> And then use an integer anyway
05:22:38 <Baughn> That is to say, you want fixed point, not floating point
05:24:02 <tuukkah> what i would get with the trick is 1000 events per second in any environment, double precision events per second in an environment that uses double, and infinite number of events per second in an environment that supports infinite precision
05:24:42 <tuukkah> basicly, it wouldn't be my fault but the other parties' fault =)
05:24:43 <Baughn> tuukkah: You would. And I'm telling you, allowing for anything but infinite number of events in /any/ environment is asking for trouble.
05:24:56 <Zeroth|work> I've officialy dreamed in Haskell
05:25:14 <Baughn> Zeroth|work: How does that work?
05:25:29 <Baughn> I've never noticed much in the way of abstract thought in my dreams
05:25:47 <Zeroth|work> Baughn, you've never?
05:26:09 <Baughn> Zeroth|work: My dreams usually look more like the plot of a bad disaster movie
05:26:16 <tuukkah> Baughn, so that's why i now think i'll need to include in addition the sequence integer as you and quicksilver suggest
05:27:54 <Zeroth|work> I've dreamed in Haskell for the past two nights, as if I were staring at a computer screen trying to forge out a program, only there was no scree, no me, ... just code
05:28:12 <Zeroth|work> I used to dream in C when I programmed in C a lot
05:28:33 <Botje> so, what monad did you use? :)
05:28:56 <Zeroth|work> I haven't gotten to the monad section of YAHT yet ;-)
05:29:19 <Botje> boo :p
05:29:27 <Zeroth|work> as of yet, I still have no idea what a monad is
05:29:43 <Zeroth|work> well, beside how haskell deals with output
05:29:44 <kaol> having dreams have side effects sounds downright scary
05:29:50 <Zeroth|work> or the framework under which it does so
05:30:11 <Botje> monads are pink fluffy things :)
05:30:25 <Zeroth|work> kaol, actually, most of m C dreams were nightmares, because the code would never "compile" or I just couldn't make heads from tails of it
05:30:44 <Zeroth|work> Botje, lawn flamingo?
05:30:59 <Botje> good enough :)
05:31:05 <Zeroth|work> probably stemmed from an actual program I was having problems with
05:31:38 * kaol sees a monad tutorial coming that compares them to lawn flamingos
05:31:49 <Zeroth|work> you do something long enough, you'll see it when you close your eyes. if you detassel corn, you see corn when you shut your eyes. mailboxes if you deliver mail. code if you program too much.
05:32:26 <vegai> monads are a series of tubes
05:32:32 <Baughn> Zeroth|work: This has serious implications for my disaster films
05:33:18 <Zeroth|work> Baughn, the "bad plot of a disaster film" pretty accurately describes my C nightmares
05:33:27 <Zeroth|work> often it would prevent me from sleeping
05:33:55 <Zeroth|work> if by "disaster movie" you mean somethign like Meet the Parents (only example I can think of)
05:34:11 <dcoutts_> @pl \a b -> u (f (s a) (s b))
05:34:11 <lambdabot> (u .) . (. s) . f . s
05:34:27 <Baughn> No, more along the lines of "Permutation City"
05:34:27 <dcoutts_> @pl \a b c -> u (f (s a) (s b) (s c))
05:34:28 <lambdabot> ((u .) .) . flip flip s . ((.) .) . (. s) . f . s
05:35:00 <Zeroth|work> never heard of it
05:35:23 <Zeroth|work> but basically, everything in the dream that can possibly go wrong does, and makes you feel like crap
05:35:36 <Zeroth|work> thats a true nightmare
05:35:44 <Baughn> Zeroth|work: Sometimes I'll have.. dreams?, where reality goes all out of whack - things are terribly wrong, in various highly philosophical ways. And they *stick around* after waking up, for very long minutes.
05:36:01 <Zeroth|work> weird
05:36:17 <Zeroth|work> depression?
05:36:27 <Baughn> Never had it
05:36:51 <Zeroth|work> I've had similar things, where you come to some unconscious observation( be it great or horrible) and the feeling lingers with you throughout the day even if you cant remember what it was
05:37:14 <Baughn> Oh, I remember precisely what the problem was
05:37:25 <Zeroth|work> I've heard people say they've had dreams so beautiful that they feel life itself is a nightmare.
05:37:47 <Baughn> Once I laid extremely still for ten minutes to avoid falling off the knife's edge I was balanced on in the fourth dimension. >_<
05:38:00 <Zeroth|work> hmm
05:38:04 <Zeroth|work> thats pretty out there
05:38:41 <Zeroth|work> a little meditation before bed might soothe your "unconscious" demeanor
05:38:45 <Baughn> It gets worse. How about the scenario where I somehow convinced myself that time was a double, and we'd reached the point where precision was becoming an issue?
05:38:52 <Baughn> Zeroth|work: Eh. It's not a common problem.
05:40:00 <Zeroth|work> my code dreams, whether good or bad, obviosuly come from thinking about things too hard for too long (as I said, I'm very persistent)
05:40:09 <Baughn> Zeroth|work: It's just generally the sort of thing you'd expect from someone who has seen just how fragile higher-layer simulations are if you alter the lower layer, and suspects that the universe has several such layers
05:40:35 <Baughn> As I said, philosophical. Even to the point of existential angst, in dreams.
05:40:53 <Zeroth|work> nihilistic?
05:41:08 <Baughn> Undecided
05:41:13 <Zeroth|work> the dreams
05:41:28 <Baughn> ..no.
05:41:39 <Baughn> More.. reality corruption.
05:41:39 <Zeroth|work> so jsut complicated
05:41:54 <Baughn> CRC errors in the laws of physics, that sort of thing. :/
05:42:00 <Zeroth|work> eep
05:42:29 <Zeroth|work> strange
05:43:16 <Baughn> Let's not forget the one dream where I "woke up" inside it, and went right on waking up. Must have been inspired by the matrix or something.
05:43:23 <dons> um? should this be on #haskell-blah ?
05:43:40 <Baughn> dons: We're just improving the activity stats
05:43:41 <Zeroth|work> there's no other conversations going on, I didn't think anyone woudl care
05:44:09 * Daveman pokes Botje
05:45:07 <Zeroth|work> about that base 26 integer....how would I achieve something like that?
05:45:16 <Zeroth|work> foo :: Int_26 ?
05:46:21 <Baughn> Zeroth|work: Isn't the base more a property of string representations of integers?
05:46:46 <Zeroth|work> I guess that might make sense
05:46:51 <Zeroth|work> but all integers have a base
05:47:50 <QtPlatypus> Zeroth|work: The base of an integer is more the way there  represented rather then an inherent quality of  the integer.
05:48:34 <Zeroth|work> QtPlatypus, and I understand that, but it's impossible to communicate a number without a base
05:48:41 <jfoutz> I have question about TVars. it seems like writeTVar returns a new tvar. That's ok, but i don't see how i can write to a tvar in one thread and see that change in another thread. any suggestions about where to look?
05:48:45 <Baughn> Zeroth|work: Integers don't have a base, really. Representations of them do, but you don't need to care about how the /machine/ represents them.
05:49:03 <Zeroth|work> unless you write it as tallies. heh
05:49:13 <Baughn> That'd be a representation.
05:49:14 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/866
05:49:21 <Zeroth|work> it would be base 1
05:49:27 <jfoutz> that there is a tvar example
05:49:31 <Baughn> Yes. A base 1 representation.
05:49:38 <QtPlatypus> Zeroth|work: succ succ 0
05:50:03 <Baughn> > succ 0.0
05:50:04 <lambdabot>  1.0
05:50:18 <Baughn> ..okay, that shouldn't have happened
05:50:41 <SamB> @type succ
05:50:43 <lambdabot> forall a. (Enum a) => a -> a
05:51:00 <Baughn> @type 0.0
05:51:03 <lambdabot> forall t. (Fractional t) => t
05:51:16 <mux> @instance Enum
05:51:17 <lambdabot> Maybe you meant: instances instances-importing
05:51:20 <mux> @instances Enum
05:51:22 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
05:51:22 <therp> is there some kind of range sublist operator? (op 1 2 "1234") => "23"?
05:51:29 <Baughn> Doesn't really make sense for floats to be enumerable
05:51:39 <Baughn> Much less for the "enumeration" to add 1
05:51:46 <Baughn> > succ (1.0 :: Float)
05:51:48 <lambdabot>  2.0
05:51:58 <SamB> Baughn: it is wanted fairly often though
05:52:12 <huschi> therp: op x y = drop x . take y
05:52:33 <Baughn> SamB: Speaking as a student of math, I must lodge a pro forma protest against that.
05:52:38 <SamB> Enum is the typeclass for [x..] and so on
05:53:00 <therp> huschi: nothing builtin? ok
05:53:06 <therp> thanks
05:53:07 <jfoutz> so, no thoughts on TVars?
05:53:26 <Syzygy-> Baughn: Speaking as an algebraist - haskell has other much more painful non-mathematical quirks than this particular one.
05:53:36 <huschi> therp: maybe there ist something in Data.List.Util from MissingH, but i don't know.
05:53:57 <huschi> @hoogle Int -> Int -> [a] -> [a]
05:53:58 <lambdabot> No matches, try a more general search
05:54:45 <QtPlatypus> Syzygy-: Such as?
05:55:05 <Zeroth|work> > succ succ 0
05:55:06 <lambdabot>   add an instance declaration for (Enum (a -> a))
05:55:07 <lambdabot>     In the expression: succ...
05:55:13 <Zeroth|work> > succ $ succ 0
05:55:15 <lambdabot>  2
05:55:37 <Baughn> > succ (\x -> x)
05:55:38 <lambdabot>   add an instance declaration for (Show (t -> t))
05:55:41 <Syzygy-> QtPlatypus: That rings are expected to be normed and have a sign function is the most annoying to my mind.
05:55:43 <Zeroth|work> > $(ls)
05:55:44 <lambdabot>  Parse error
05:56:05 <Zeroth|work> hmm, I saw code once execute a shell command, thought it was like that
05:56:17 <Syzygy-> Zeroth|work: Not in Haskell.
05:56:21 <Syzygy-> :t ($)
05:56:21 <Baughn> Zeroth|work: Sure. In bash, not haskell. ;)
05:56:23 <lambdabot> forall a b. (a -> b) -> a -> b
05:56:33 <Zeroth|work> yeah, but it was in a haskell program
05:56:42 <Zeroth|work> or maybe I just didn't read it right
05:56:55 <Syzygy-> You can do it by really ugly redefines, I guess...
05:59:36 <Baughn> How much of a difference will I see from disabling the (nonfunctional) native compiler?
06:01:40 <chessguy> can someone translate Oleg's recent announcement into lay english?
06:01:54 <fax--> I wake up with a headache because of you, haskell
06:02:12 <fax--> I spent all night dreaming about immutable state and monads and such :S
06:02:37 <Zeroth|work> fax--, that conversatino wa
06:02:39 <Zeroth|work> err
06:02:48 <Zeroth|work> we've already had that conversation ;-)
06:03:00 <fax--> I wasnt there at the time
06:03:05 <fax--> I just woke up 2 min ago
06:03:09 <Baughn> Clearly Haskell is infecting the collective unconscious.
06:03:16 <chessguy> @remember fax-- I wake up with a headache because of you, haskell
06:03:16 <lambdabot> Done.
06:03:20 <chessguy> @karma fax
06:03:21 <lambdabot> fax has a karma of 0
06:03:54 <chessguy> ?where books
06:03:55 <lambdabot> http://www.haskell.org/haskellwiki/Books_and_tutorials#Textbooks
06:04:44 <Zeroth|work> "Two Text Books", but it lists many below it...
06:07:17 <chessguy> 2 is the number of the section
06:07:31 <chessguy> look at the Contents
06:09:17 <wchogg> Is anyone running the ghc from the feisty fawn repositories?
06:26:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/867
06:26:08 <jatzccsrdf> hello
06:26:24 <jatzccsrdf> http://hpaste.org/867
06:26:45 <jatzccsrdf> (i'm reading the haskell tutorial but i don't find the syntax for "istance")
06:26:51 <chessguy> instance
06:27:02 <chessguy> there's an 'n' in it
06:27:05 <jatzccsrdf> ooops
06:27:23 <chessguy> and it needs to be instance Show (Tree a) where
06:27:31 <chessguy> err
06:27:40 <chessguy> instance Show (Tree a b) where
06:27:41 <jatzccsrdf>   instance Show (Tree a b) where
06:27:42 <jatzccsrdf> yes
06:27:43 <jatzccsrdf> found
06:27:48 <jatzccsrdf> i have spent 10 min on that :)
06:27:58 <jatzccsrdf> anyway ghc error messages are quite good
06:31:56 <Zeroth|work> oooh
06:31:59 * Zeroth|work raises his hand
06:32:03 <Zeroth|work> err wait
06:33:38 * chessguy raises an eyebrow
06:35:18 <Zeroth|work> is it possible to use a haskell function in a C program?
06:35:40 <edwinb> yes...
06:35:50 <opqdonut> Zeroth|work: system("ghci -e '%s'", program) ;))
06:35:55 <edwinb> (I don't actually remember how, I just know it's possible...)
06:36:10 <Zeroth|work> eh, not as an interpreter
06:36:12 <Zeroth|work> but compiled in
06:36:25 <Zeroth|work> cuz that would be spifftacular
06:36:25 <Botje> Daveman: ouch! what!
06:36:32 <edwinb> When I did it I remember the FFI docs explained it well enough
06:36:43 <Zeroth|work> @where FFI
06:36:44 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
06:37:39 <edwinb> section 4.1.2...
06:37:40 <Daveman> :p
06:38:05 <Daveman> @where FBI
06:38:06 <lambdabot> I know nothing about fbi.
06:38:11 <Daveman> heehee
06:40:09 <hpaste>  somenick2 pasted "(no title)" at http://hpaste.org/868
06:40:34 <somenick2> another probably trivial question..
06:41:05 <chessguy> instance (Show a, Show b) => Show (Tree a b) where
06:41:07 <chessguy> i think
06:41:32 <somenick2> yea
06:43:18 <bakert> how do you match a regex multiple times against a String with Text.Regex?
06:43:36 <bakert> matchRegexAll gives more output but still only finds the first match?
06:45:40 <quicksilver> bakert: I don't believe there is a primitive for that
06:45:44 <bakert> drat
06:45:57 <quicksilver> bakert: use the 'All' version
06:46:08 <quicksilver> bakert: and continue to match against the 'everythign after' part
06:46:13 <quicksilver> (probably)
06:46:48 <bakert> ah cunning.  thanks.
06:50:39 <quicksilver> > unfoldr (fmap (\(_,m,r,_) -> (m,r)) . matchRegexAll (mkRegex "f.o")) "far foo bar fdo baz fmo"
06:50:41 <lambdabot>   Not in scope: `mkRegex'
06:50:44 <quicksilver> bah
06:50:57 <quicksilver> bakert: try that in ghci, I think it does what you want, for some values of 'what you want'
06:51:08 * Zeroth|work logs into his server at home from work via SSH so he can use GHC
06:51:50 <quicksilver> @tell dons Request for lambdabot: import the regex packages?
06:51:51 <lambdabot> Consider it noted.
06:52:15 <chessguy> just submit a patch :)
06:52:18 <Zeroth|work> tell dons request for ascii porn?
06:52:20 <Zeroth|work> heh
06:54:56 <bringert> @seen dons
06:54:57 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 29m 14s ago.
06:55:27 <chessguy> @type unfoldr
06:55:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:55:36 <krff0> @pl (\f x->Just (x, f x))
06:55:37 <lambdabot> (Just .) . ap (,)
06:55:42 <bringert> dons: do you think a binary parsing library would be a good SoC project?
06:56:41 <quicksilver> bringert: designed to be lazy in that data isn't actually "pulled out of" the underlying bytestrings?
06:56:53 <quicksilver> bringert: just 'referred to'
06:57:03 <quicksilver> bringert: that could be neat
07:10:45 <hpaste>  fantasma pasted "need help quick" at http://hpaste.org/869
07:11:54 <glguy> > length ([1..100] \\ map (^2) [2..10])
07:11:56 <lambdabot>  91
07:12:04 <glguy> oh, as a factor
07:12:10 <fantasma> yah
07:12:32 <glguy> :t all
07:12:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:13:40 <narain> > let perfectSquares = map (^2) [2..10]; foo [] = []; foo (x:xs) = filter (\y -> y `mod` x == 0) [1..20] ++ foo xs in foo perfectSquares
07:13:41 <lambdabot>  [4,8,12,16,20,9,18,16]
07:13:50 <glguy> > let filter (\x -> all (\y -> x `mod` y /= 0) (map (^2) [2..10])) [1..100]
07:13:50 <lambdabot>  Parse error
07:13:58 <narain> you're counting things twice, looks like
07:14:00 <narain> see 16
07:14:22 <glguy> > let filter (\x -> all (\y -> x `mod` y /= 0) (map (^2) [2..10]))) [1..100]
07:14:22 <lambdabot>  Parse error
07:14:25 <fantasma> wow yah I didn't even realize that
07:14:27 <glguy> > filter (\x -> all (\y -> x `mod` y /= 0) (map (^2) [2..10]))) [1..100]
07:14:28 <lambdabot>  Parse error
07:14:31 <glguy> > filter (\x -> all (\y -> x `mod` y /= 0) (map (^2) [2..10])) [1..100]
07:14:32 <lambdabot>  [1,2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30,31,33,34,35,37,38,39,41,...
07:14:32 <glguy> _/
07:14:42 <glguy> > length $ filter (\x -> all (\y -> x `mod` y /= 0) (map (^2) [2..10])) [1..100]
07:14:42 <fantasma> > length $ filter (\x -> all (\y -> x `mod` y /= 0) (map (^2) [2..10])) [1..100]
07:14:44 <lambdabot>  61
07:14:44 <lambdabot>  61
07:14:54 <fantasma> :( you are all so smart
07:15:08 <glguy> can't be that smart, it took me 4 tries to get it to parse :)
07:15:15 <narain> what happened to yawgnimeh by the way?
07:15:22 <fantasma> haha
07:16:30 <narain> > reverse "asimov"
07:16:30 <fantasma> it's too hard to say and spell
07:16:31 <lambdabot>  "vomisa"
07:17:33 <narain> > liftM2 (,) [1,2,3] [1,2,3]
07:17:35 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
07:17:37 * glguy kindly reminds everyone that the best way to not get your pastes deleted is to put a nick and a title on them
07:18:02 <abz> ?poll-list
07:18:02 <lambdabot> ["EvilPoll","OperatingSystem","RestrictToOneVote","Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
07:18:12 <abz> ?poll-results "OperatingSystem
07:18:13 <lambdabot> No such poll: "\"OperatingSystem"
07:18:18 <abz> ?poll-results OperatingSystem
07:18:18 <lambdabot> Poll results for OperatingSystem (Open): MacOS=0, House=0, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=1, OpenBSD=1, Gentoo=3, Debian=5, Ubuntu=2, FreeBSD=2
07:18:20 <narain> what are these polls about?
07:18:25 <narain> how do i vote?
07:18:32 <glguy> ?help vote
07:18:33 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
07:18:38 <narain> thanks
07:18:42 <abz> ?vote OperatingSystem Gentoo
07:18:42 <lambdabot> voted on "Gentoo"
07:18:53 <narain> ?poll-results RestrictToOneVote
07:18:53 <lambdabot> Poll results for RestrictToOneVote (Open): PerOption=1, PerPoll=0, FileNotFound=0, No=0, Yes=3
07:19:25 <narain> ?poll-results Written_a_
07:19:26 <lambdabot> No such poll: "Written_a_"
07:19:31 <glguy> ?poll-results jabberName
07:19:31 <lambdabot> Poll results for jabberName (Open): Network.Protocol.Xmpp=0, Network.Xmpp=0
07:19:35 <narain> ?poll-results Written_a_compiler_or_interpreter?
07:19:35 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=4, Yes=20
07:19:51 <glguy> that's definitely a poor way to poll for that
07:19:58 <glguy> people that have will be more likely to vote!
07:20:12 <narain> very well then
07:20:18 <fantasma> ?vote OperatingSystem House
07:20:19 <lambdabot> voted on "House"
07:20:19 <narain> ?vote Written_a_compiler_or_interpreter? No
07:20:19 <lambdabot> voted on "No"
07:20:29 <glguy> :-p
07:20:34 <narain> :)
07:20:50 <Botje> > replicateM 2 [1,2,3] -- narain
07:20:51 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
07:20:55 <huschi> ?vote OperatingSystem Ubuntu
07:20:55 <lambdabot> voted on "Ubuntu"
07:21:06 <Botje> oh, that's lists instead of pairs. meh
07:21:16 <Botje> ?vote OperatingSystem Gentoo
07:21:16 <lambdabot> voted on "Gentoo"
07:21:19 <Botje> yay
07:21:22 <narain> > replicateM 3 [1,2,3]
07:21:24 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
07:21:27 <glguy> > join (liftM2 (,)) [1..3]
07:21:29 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
07:21:37 <narain> :t join
07:21:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:21:45 <narain> oh, right
07:21:55 <arvid> ?vote OperatingSystem Kubuntu
07:21:56 <lambdabot> "Kubuntu" is not currently a candidate in this poll
07:22:03 <arvid> aww :(
07:22:06 <narain> > join Just Nothing
07:22:07 <lambdabot>  Couldn't match expected type `(->) a' against inferred type `Maybe'
07:22:16 <glguy> > join (Just Nothing)
07:22:18 <lambdabot>  Nothing
07:23:06 <narain> > join (Just (Just Nothing))
07:23:07 <lambdabot>  Just Nothing
07:23:21 <Botje> hmm
07:23:26 <Botje> > src join Either
07:23:28 <lambdabot>   Not in scope: data constructor `Either'
07:23:30 <Botje> doh
07:23:32 <Botje> ?src join Either
07:23:33 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:23:44 <Botje> bah *waves paw*
07:24:07 <narain> ?src join
07:24:08 <lambdabot> join x =  x >>= id
07:24:59 <Botje> hmm.
07:25:20 <huschi_> > join (Just Nothing)
07:25:22 <lambdabot>  Nothing
07:25:45 <Botje> > join (Left $ Right "jump")
07:25:46 <lambdabot>        add an instance declaration for (Error (Either a [Char]))
07:25:46 <lambdabot>     In the e...
07:25:55 <Botje> > join (Right $ Right "jump")
07:25:56 <lambdabot>  Add a type signature
07:26:06 <Botje> shouldn't that work?
07:26:11 <Botje> :t Right $ Right "jump"
07:26:14 <lambdabot> forall a a1. Either a (Either a1 [Char])
07:26:25 <Botje> > join (Right $ Right "jump") :: Either Int String
07:26:26 <lambdabot>   add an instance declaration for (Error Int)
07:26:26 <lambdabot>     In the expression: join (Ri...
07:26:39 <Saizan> > join (Right $ Right "jump") :: Either String String
07:26:40 <Botje> > join (Right $ Right "jump") :: Either String String
07:26:41 <lambdabot>  Right "jump"
07:26:42 <lambdabot>  Right "jump"
07:26:50 <Botje> yeah :)
07:27:15 <Botje> my knowledge of join just ++ed!
07:27:18 <Saizan> only (Error e) => Either e  is an instance of monad
07:27:32 <Botje> that makes sense :)
07:27:43 <nominolo> ?vote Written_a_compiler_or_interpreter? Yes
07:27:43 <lambdabot> voted on "Yes"
07:28:51 <narain> ?instances Monad
07:28:52 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:29:53 <narain> how do i find the source of  (>>=)  for  Either ?
07:30:00 <narain> ?src (>>=)
07:30:00 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:30:04 <narain> ?src (>>=) Either
07:30:04 <lambdabot> Source not found. I feel much better now.
07:30:14 <Botje> ?src Either >>=
07:30:14 <lambdabot> Source not found. Are you on drugs?
07:30:16 <Botje> perhaps?
07:30:17 <Botje> boo.
07:30:30 <qwr> ?src (>>=) :: Either
07:30:31 <lambdabot> Source not found. stty: unknown mode: doofus
07:30:46 <Botje> @src (>>=) :: Either a b
07:30:46 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:30:53 * Botje gives up
07:30:56 <glguy> Either isn't a monad on its own
07:30:57 <narain> assuming lambdabot even has the source
07:30:58 <Botje> \bot is being stubborn today
07:31:18 <doserj> ?src Either (>>=)
07:31:18 <lambdabot> Left  l >>= _ = Left l
07:31:19 <lambdabot> Right r >>= k = k r
07:31:28 <glguy> (it still isn't)
07:31:54 <narain> glguy: yes, Saizan said  (Error e) => Either e  is?
07:32:02 <glguy> narain: yeah, that :)
07:32:14 * glguy isn't reading *every* line in the channel
07:32:19 <narain> :t (>>=) :: Either a b
07:32:21 <lambdabot>     Couldn't match expected type `Either a b'
07:32:21 <lambdabot>            against inferred type `m a1 -> (a1 -> m b1) -> m b1'
07:32:36 <glguy> narain: you know better than that! :)
07:32:50 <narain> :t (>>=) :: Either a b -> (b -> Either a c) -> Either a c
07:32:52 <lambdabot>     No instance for (Error a)
07:32:52 <lambdabot>       arising from use of `>>=' at <interactive>:1:0-4
07:33:04 <narain> oh great i'm writing the type myself :p
07:33:12 <quicksilver> :t (>>=)
07:33:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:33:24 <narain> i just wanted to see what the type would be specifically for  Either
07:33:27 <quicksilver> and the monad is (Error e) => Either e
07:33:28 <glguy> :t \ x y -> x >>= y
07:33:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:33:47 <glguy> :t \ (x :: Error a => Either a b) y -> x >>= y
07:33:50 <lambdabot>     All of the type variables in the constraint `Error a' are already in scope
07:33:50 <lambdabot>         (at least one must be universally quantified here)
07:34:01 <glguy> yeah.. I didn't see that happening
07:34:11 <narain> :t \ (x :: Either a b) y -> x >>= y
07:34:14 <lambdabot>     A pattern type signature cannot bind scoped type variables `a', `b'
07:34:14 <lambdabot>       unless the pattern has a rigid type context
07:34:19 <narain> blarg
07:34:21 <narain> never mind
07:34:27 <glguy> :t \ (x :: Either String Int) y -> x >>= y
07:34:30 <lambdabot> forall b. Either String Int -> (Int -> Either String b) -> Either String b
07:34:33 <glguy> hurrah
07:34:38 <narain> whee
07:34:49 <quicksilver> it's (Error e) => Either e a -> (a -> Either e b) -> Either e b
07:35:02 <glguy> quicksilver: the point was to make the bot do it :)
07:35:20 <quicksilver> :t (>>=) :: (Error e) => Either e a -> (a -> Either e b) -> Either e b
07:35:23 <lambdabot> (Error e) => Either e a -> (a -> Either e b) -> Either e b :: forall e a b. (Error e) => Either e a -> (a -> Either e b) -> Either e b
07:35:26 <quicksilver> happy?
07:35:27 <quicksilver> :P
07:35:42 <narain> ah now it makes sense to me what  (>>=)  does on the  (Error e) => Either e  monad
07:35:46 <narain> types are so enlightening
07:35:50 <quicksilver> it's the same as Maybe
07:35:52 <narain> quicksilver: cheating!
07:35:57 <quicksilver> only you can annotate the 'Nothing' with an message
07:36:10 <narain> i get it now
07:36:13 <glguy> Maybe a might as well be Either () a :)
07:37:19 <quicksilver> instance Error () where noMsg = () ; strMsg s = ()
07:37:20 <quicksilver> ?
07:37:26 <quicksilver> not a very good error instance that one :)
07:37:28 <Zeroth|work> :t map
07:37:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:37:54 <glguy> quicksilver: sure, but no worse
07:38:12 <Zeroth|work> > map print ["asd","asd"]
07:38:13 <lambdabot>  [<IO ()>,<IO ()>]
07:38:16 <Zeroth|work> yay
07:38:21 <glguy> Zeroth|work: mapM_ print
07:38:24 <Zeroth|work> I think that'll work
07:38:32 <Zeroth|work> mapM_ ?
07:38:39 <glguy> :t mapM_
07:38:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:38:43 <glguy> ?src mapM_
07:38:44 <lambdabot> mapM_ f as = sequence_ (map f as)
07:38:45 <narain> > mapM_ putStrLn ["foo", "bar"]
07:38:46 <lambdabot>  <IO ()>
07:38:53 <narain> grr
07:39:08 <narain> ?t print
07:39:08 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
07:39:10 <glguy> oh, right, you don't (typically) want to "print" Strings
07:39:12 <Thunde1> @type ap . (:[])
07:39:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:39:15 <narain> :t print
07:39:17 <lambdabot> forall a. (Show a) => a -> IO ()
07:39:23 <quicksilver> when did lambdabot start supporting IO like that?
07:39:27 <glguy> while back
07:39:32 <Thunde1> It looks like "ap" ist "map" without the List restriction.
07:39:36 <Zeroth|work> I just want to print every string in a list
07:39:45 <glguy> Thunde1: nope, fmap and liftM are
07:39:53 <Thunde1> Or "ap" is the "monadic map".
07:40:15 <narain> Zeroth|work: use  mapM_  instead of  map
07:40:29 <narain> :t map putStrLn
07:40:32 <lambdabot> [String] -> [IO ()]
07:40:35 <narain> :t mapM_ putStrLn
07:40:38 <lambdabot> [String] -> IO ()
07:40:47 <narain> does that help?
07:41:13 <quicksilver> As a point of interest, once you've used 'map' to produce a list of IO actions, you could then execute them with sequence
07:41:20 <narain> :t sequenc
07:41:23 <lambdabot> Not in scope: `sequenc'
07:41:24 <narain> :t sequence
07:41:27 <lambdabot>     Ambiguous occurrence `sequence'
07:41:27 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
07:41:34 <glguy> :t Control.Monad.sequence
07:41:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:41:38 <quicksilver> > Control.Monad.sequence . (map print) ["asd","asd"]
07:41:39 <lambdabot>  Couldn't match expected type `a -> [m a1]'
07:41:45 <quicksilver> > Control.Monad.sequence . (map print) $ ["asd","asd"]
07:41:46 <lambdabot>  <IO [()]>
07:41:56 <quicksilver> like so
07:42:04 <quicksilver> normally you'd use mapM, but that helps complete the picture
07:42:05 <glguy> well sure, if you wanted a list of units as a result
07:42:09 <glguy> ;)
07:42:20 <quicksilver> not like that matters particularly :)
07:42:51 <narain> glguy: sure, the length tells you how many things you printed :)
07:43:05 <glguy> Zeroth|work: the _ variants, like sequence_ vs sequence, will discard the results
07:43:16 <narain> :t sequence_
07:43:16 <Thunde1> glguy: ap is defined as a specialized liftM.
07:43:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
07:43:21 <Zeroth|work> no shit it works
07:43:50 <narain> Zeroth|work: do you see why?
07:44:00 <Zeroth|work> @where hpaste
07:44:01 <lambdabot> http://hpaste.org/new
07:44:11 <quicksilver> Thunde1: actually ap is a specialised liftM2. Not the same.
07:44:13 <Zeroth|work> narain, I aven't gotten to monads just yet, but I certainly will
07:44:33 <Thunde1> I does not get the meaing of "ap".
07:44:36 <hpaste>  zeroth pasted "I'm proud" at http://hpaste.org/870
07:44:39 <quicksilver> Zeroth|work: I don't think you need to 'understand monads' to see that sequence can be used to execute a list of IO actions
07:44:43 <glguy> :t
07:44:47 <glguy> :t ap
07:44:50 <quicksilver> Thunde1: 'ap' is function application lifted into a monad
07:44:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:45:02 <Zeroth|work> quicksilver, well yes, I understand what it does, but I do not understand monads.
07:45:05 <Zeroth|work> yet
07:45:18 <quicksilver> Thunde1: the difference between 'ap' and liftM is that 'ap' requires the *function* to be in the monad
07:45:23 <Zeroth|work> now I'll see if I can make it shorter
07:45:24 <glguy> given a monad containing a function, and a monad containing a value, return the monad that contains the function applied to the value
07:45:26 <quicksilver> Thunde1: liftM takes a plain function
07:45:34 <narain> > ap [floor,ceiling] [3.4, 5.6]
07:45:36 <lambdabot>  [3,5,4,6]
07:45:38 <quicksilver> Thunde1: and just lifts the arguments and results into the monad
07:45:44 <glguy> liftM -- if you can't take the data to the function take the function to the data
07:45:58 <Thunde1> Why are the names so different?
07:46:05 <quicksilver> 'ap' is short for 'application'
07:46:12 <quicksilver> it lifts application into the monad
07:46:19 <quicksilver> 'ap' is really 'liftM2 ($)'
07:46:31 <Thunde1> @src ap
07:46:31 <lambdabot> ap = liftM2 id
07:46:32 <glguy> :t liftM2 id
07:46:35 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
07:46:39 <glguy> :t flip liftM2 id
07:46:42 <lambdabot> forall a2 r a. (a -> a2 -> r) -> (a -> a2) -> a -> r
07:46:43 <narain> how often do you end up with a function inside a monad? (honest question, not snarkiness)
07:46:44 <quicksilver> because ($) is the way to view function application as a binary function
07:46:50 <quicksilver> narain: not often
07:47:04 <glguy> ap is awesome for writing point free code
07:47:11 <quicksilver> narain: you might have a function a -> b which calculates a value of b based on a *and user input*
07:47:17 <Thunde1> quicksilver: Your way to define is more clear.
07:47:19 <glguy> > ap (,) succ 1
07:47:20 <lambdabot>  (1,2)
07:47:21 <quicksilver> Thunde1: agreed
07:47:28 <quicksilver> Thunde1: ($) is actually a special case of id
07:47:33 <quicksilver> Thunde1: but that's painful to think about :)
07:47:39 <glguy> > ( (,) =<< succ ) 1
07:47:40 <lambdabot>  (2,1)
07:47:45 <narain> :t ap (,)
07:47:47 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
07:48:00 <glguy> ?src ((->)r) ap
07:48:01 <lambdabot> Source not found. That's something I cannot allow to happen.
07:48:02 <Zeroth|work> is there a System.numArgs?
07:48:04 <glguy> ?src (->)r ap
07:48:05 <lambdabot> Source not found. Where did you learn to type?
07:48:23 <quicksilver> Zeroth|work: no, just take the length of System.getArgs :)
07:48:30 <glguy> ap f g x = f x (g x) -- in the reader monad
07:48:31 <Zeroth|work> heh, good idea
07:48:49 <glguy> join f x = f x x -- in reader
07:48:50 <narain> :t ap
07:48:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:48:57 <narain> :t ap (,)
07:48:59 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
07:49:16 <narain> what's the monad involved in this?
07:49:24 <glguy> ((->)r)
07:49:24 <Thunde1> Which monad is used in ap (,)?
07:49:33 <glguy> ?instances Monad
07:49:35 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:49:58 <Thunde1> I see. I should abandom Haskell98.
07:50:17 <narain> ((->) r) is ... the type of functions which take arguments of type  r?
07:50:19 <earthy> oh, yes.
07:50:47 <narain> or return values of type  r ?
07:50:48 <quicksilver> Thunde1: why should you abandon 98?
07:50:56 <Thunde1> narain: and give an other type.
07:51:03 <glguy> narain: take
07:51:06 <narain> ok
07:51:25 <Thunde1> quicksilver: I run into problems understanding higher kind data types.-
07:51:45 <quicksilver> Thunde1: nah, you don't. You know what a list is
07:51:52 <quicksilver> Thunde1: hence, you know what a higher kind data type is :)
07:52:03 * Thunde1 smiles.
07:52:04 <glguy> :k []
07:52:07 <lambdabot> * -> *
07:52:41 <hpaste>  zeroth annotated "I'm proud" with "check num args" at http://hpaste.org/870#a1
07:52:43 <Thunde1> :k (->)
07:52:46 <lambdabot> ?? -> ? -> *
07:53:04 <Thunde1> Lambdabot does not understand either ;-)
07:53:21 <narain> that's awesome
07:53:24 <glguy> no, ?? and ? have specific meaning
07:53:34 <narain> it's still awesome :)
07:53:49 <Thunde1> glguy: yes, when leaving Haskell98.
07:54:00 <quicksilver> what do ?? and ? mean
07:54:51 <quicksilver> Zeroth|work: instead of "a.out" you could use System.getProgName
07:56:04 <narain> so in  ap (,)  ... ap  interprets  (,)  to be of type  ((a->b) -> c)  and returns  (a -> c) -> (b -> c) ?
07:56:10 <narain> where  c  is  (a,b) ?
07:56:16 <Zeroth|work> quicksilver, thanks
07:56:22 <narain> :t ap (,)
07:56:24 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
07:56:35 <narain> no that doesn't seem to be what's happening
07:56:38 <quicksilver> narain: no, a -> (b->v)
07:56:48 <quicksilver> a->b->c means a -> (b->c)
07:56:58 <quicksilver> arrows conventionally associate to the right
07:57:00 <quicksilver> :t (,)
07:57:01 <glguy> quicksilver: it means something like "anything that can be an argument" and "anything that can be unboxed"
07:57:03 <lambdabot> forall a b. a -> b -> (a, b)
07:57:04 <quicksilver> :t (,) 4
07:57:06 <glguy> I'll looking in the docs
07:57:06 <lambdabot> forall t b. (Num t) => b -> (t, b)
07:57:20 <narain> quicksilver: i understand currying
07:57:21 <quicksilver> glguy: interesting
07:57:30 <Thunde1> http://www.haskell.org/haskellwiki/Kind says, that (->) has the kind of * -> * -> *, not ?? -> ? -> *
07:57:31 <lambdabot> Title: Kind - HaskellWiki
07:57:33 <narain> i don't understand ((->) r)
07:57:49 <quicksilver> narain: ((->)r) means (r->)
07:57:57 <Thunde1> narain: (->) a b == a -> b
07:58:00 <quicksilver> but we don't support type-level sections as a syntax
07:58:09 <Zeroth|work> quicksilver, cant match String to IO String, and I cant put them on separate lines because haskell automatically puts a \n at the end of output
07:58:09 <quicksilver> so it means 'functions taking a parameter of type r'
07:58:46 <Thunde1> narain: It's the same as (+) 1 2 == 1 + 2 = (1+) 2
07:58:58 <narain> so ap takes an argument  m (a -> b)  and i'm told in this case  m  is  ((->) r)
07:59:21 <narain> so shouldn't ((->) (a -> b))  be  ((a->b) -> x) ?
07:59:22 <quicksilver> Zeroth|work: pn <- System.getProgName; print ("usage :"++pn++" string")
07:59:32 <Zeroth|work> yeah thats what I'm doing, but its annoying to have to do that :-p
07:59:49 <quicksilver> Zeroth|work: why is that annoying?
08:00:17 <Zeroth|work> quicksilver, because it takes more typing :-p
08:00:40 <Thunde1> narain: Of course: m = (-> r)  and r is (a->b), a and b in the three parts of the type signature
08:00:44 <Zeroth|work> its not very "lazy" ;)
08:01:00 <glguy> google sucks hard at searching for operators
08:01:12 <glguy> and sequences of punctuation
08:01:27 <quicksilver> @. pl undo do{pn <- System.getProgName; print ("usage :"++pn++" string")}
08:01:28 <lambdabot> print . ("usage :" ++) . (++ " string") =<< System . getProgName
08:01:33 <matthew_-> pretty much any non-[:alphnum:]
08:01:38 <quicksilver> Zeroth|work: I don't think that's better though :)
08:01:48 <quicksilver> matthew_-: they put in a special exception for C#, the fakkers
08:01:55 <quicksilver> matthew_-: and J# and a few similar things
08:02:08 <narain> Thunde1: ok, let me work through the type of  ap (,)  again
08:02:24 <Thunde1> But if google tries to fake this for haskell, they will fail ;-)
08:03:14 <pejo> quicksilver, admit that it would be nice if you could type "if (whatever) ..." instead of "whatever <- c; if (whatever) .. ".
08:03:16 <hpaste>  dcoutts annotated "Bitmap graphics in Gtk2hs" with "(no title)" at http://hpaste.org/864#a3
08:03:21 <quicksilver> Zeroth|work: I still don't know what you mean by 'can't put them on separate lines because haskell automatically...."
08:04:05 <quicksilver> pejo: if that bothers you then define an appropriate ifM
08:04:26 <quicksilver> although you lose 'then' and 'else' then
08:04:26 <Zeroth|work> print "this"; print "this" -- puts them on separate lines
08:04:42 <matthew_-> you could make thenM = id and elseM = id ;-)
08:04:44 <quicksilver> Zeroth|work: then don't use print :P
08:04:49 <quicksilver> Zeroth|work: use putStr
08:04:50 <Zeroth|work> printf("asd"); printf("asd"); /* not on separate lines */
08:04:59 <Zeroth|work> sweet
08:05:00 <matthew_-> then ifM blah thenM blah2 elseM blah3 would be ok ;-)
08:05:08 <SyntaxNinja> dons: heya, can you link me to your popl paper?
08:05:20 <pejo> matthew, heh, very convenient. And then code remains unreadable for all other people.
08:05:25 <quicksilver> matthew_-: only if ifM expects and discards its 2nd and 4th parameter
08:05:36 <matthew_-> quicksilver: gah, needs some brackets then
08:05:45 <matthew_-> I meant the id to apply to the blahs
08:05:57 <quicksilver> ifM blah (thenM blah) (elseM blah)
08:05:58 <quicksilver> in that case
08:06:22 <narain> :t ap (,)
08:06:25 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
08:07:01 <quicksilver> narain: got there yet?
08:07:09 <narain> no :(
08:07:13 <quicksilver> :t ap
08:07:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:07:16 <quicksilver> :t (,)
08:07:19 <lambdabot> forall a b. a -> b -> (a, b)
08:07:23 <narain> wait let me tell you what i have
08:07:30 <quicksilver> ok, go ahead :)
08:07:39 <narain> ap :: m (a -> b) -> m a -> m b  where  m = (r ->)  so  ap's specialized type is  ((a -> b) -> x) -> (a -> x) -> (b -> x)?
08:07:49 <quicksilver> nope
08:08:03 <quicksilver> specialised type is (r -> (a->b)) -> (r -> a) -> (r -> b)
08:08:05 <Thunde1> narain: It's vise versa
08:08:16 <narain> ah!
08:08:49 <narain> ok i had it all wrong
08:09:04 <narain> let me try to work it out again
08:10:21 <SyntaxNinja> oh, it was padl
08:11:48 <narain> got it!! whew.
08:12:18 <narain> thanks Thunde1, quicksilver
08:12:30 <narain> @pl ap (,)
08:12:30 <lambdabot> ap (,)
08:12:49 <Thunde1> @unpl ap (,)
08:12:49 <lambdabot> (\ e -> (,) >>= \ b -> e >>= \ a -> return (b a))
08:12:55 <Thunde1> eeks
08:12:56 <narain> ap (,)  ==  \f x -> (x, f x) ?
08:13:07 <Thunde1> Exacty
08:13:20 <narain> all that work for that little thing
08:13:23 <narain> i feel ripped off now
08:13:25 <narain> :D
08:13:51 <araujo> hello !
08:19:36 <hpaste>  zeroth annotated "I'm proud" with "improvements" at http://hpaste.org/870#a2
08:20:44 <glguy> Zeroth|work: you want to putStrLn for a String, generally
08:21:08 <Zeroth|work> glguy why?
08:21:12 <glguy> try it
08:21:25 <glguy> then print $ "usage: " ++ pname ++ " string" will be output to screen correctly then
08:21:40 <quicksilver> Zeroth|work: print shows it as a haskell data type
08:21:44 <quicksilver> Zeroth|work: it gets "" around it
08:21:58 <quicksilver> > show "hello"
08:22:00 <lambdabot>  "\"hello\""
08:22:48 <glguy> s == replicate (length s) 'z' = s -- is -- all (=='z') s
08:22:49 <glen_quagmire> is haskell dynamic language?
08:23:15 <Zeroth|work> aaah
08:23:18 <earthy> glen: what do you mean by 'dynamic'?
08:23:41 <quicksilver> glen_quagmire: not in the traditional senses of dynamic, no
08:24:00 <quicksilver> glen_quagmire: but you can manage quite a few programming styles which in other languages you'd need dynamic programming for
08:24:05 <earthy> haskell is a strongly statically typed non-strict pure functional language
08:24:24 <glguy> and if (length args) /= 1 -- is -- if length args /= 1 -- /me hates extra parentheses :)
08:24:26 <glen_quagmire> it's not. it's not listed on http://en.wikipedia.org/wiki/Dynamic_programming_language#Languages
08:24:41 <quicksilver> glen_quagmire: right, as I said
08:25:13 <nominolo> ?where logs
08:25:13 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
08:25:15 <xs> there's always Data.Dynamic
08:25:55 <hpaste>  zeroth annotated "I'm proud" with "putStrLn instead of print" at http://hpaste.org/870#a3
08:26:00 <xs> > let s = show "heh" in read s :: Int
08:26:01 <lambdabot>  Exception: Prelude.read: no parse
08:26:05 <earthy> Haskell + Template Haskell really fudges the definition ;)
08:26:23 <Zeroth|work> I'm curious to see how my program could be made smaller
08:26:35 <Zeroth|work> if anyone cares to take a peek
08:26:39 <Zeroth|work> I'm off to lunch
08:26:39 <quicksilver> arguably hsplugins makes haskell into a strongly-typed dynamic language
08:26:52 <quicksilver> these terms are not very accurately defined, but...
08:26:58 <earthy> qs: arguably
08:27:22 <quicksilver> as I said in my first answer to glen_quagmire I believe that many dynamic programming paradigms can be directly programmed in haskell\
08:27:29 <quicksilver> (without useing Data.Dynamic)
08:27:44 <glen_quagmire> thanks
08:28:34 <nominolo> @seen dons
08:28:35 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 2h 2m 55s ago.
08:29:33 <hpaste>  glguy annotated "I'm proud" with "avoiding length like the plague" at http://hpaste.org/870#a4
08:30:40 <nominolo> glguy: can you really have infinitely many command-line args?
08:30:49 <narain> > :t (show >>=)
08:30:50 <lambdabot>  Parse error
08:30:59 <glguy> nominolo: why count them if you don't care how many there actually are
08:31:00 <narain> :t (show >>=)
08:31:02 <lambdabot> forall a b. (Show a) => (String -> a -> b) -> a -> b
08:31:05 <glguy> unless that number is 1
08:31:14 <quicksilver> glguy: another approach is [x] <- System.getArgs
08:31:22 <quicksilver> glguy: then catch the pattern match exception
08:31:23 <glguy> quicksilver: but then he'll need to catch
08:31:28 <glguy> right
08:31:29 <somenick2> instead of if then else if then else ecc.. what i can use?
08:31:49 <quicksilver> somenick2: a definition with guards, perhaps?
08:32:01 <somenick2> perhaps..
08:32:11 <narain> :t \(x :: r -> a) y -> x >>= y
08:32:13 <lambdabot>     A pattern type signature cannot bind scoped type variables `r', `a'
08:32:13 <lambdabot>       unless the pattern has a rigid type context
08:32:15 <hpaste>  glguy annotated "I'm proud" with "further plague avoidance" at http://hpaste.org/870#a5
08:32:20 <somenick2> it is not clear for me the relation between pattern matching and conditional expressions
08:32:25 <narain> :t \(x :: Int -> String) y -> x >>= y
08:32:27 <lambdabot> forall b. (Int -> String) -> (String -> Int -> b) -> Int -> b
08:33:05 <narain> > (show >>= \s i -> s ++ (show i)) 5
08:33:07 <lambdabot>  "55"
08:33:15 <narain> > (show >>= \s i -> s ++ (show (i+1))) 5
08:33:16 <lambdabot>  "56"
08:33:20 <narain> woot
08:33:36 <narain> my understanding of Monad ((->) r) ++
08:33:46 <somenick2> quicksilver, can i give you an url in query?
08:33:57 <glguy> cycleWord :: String -> [String]
08:34:03 <quicksilver> somenick2: you can, is it too private to just paste?
08:34:05 <glguy> (mistype)
08:34:24 <somenick2> it is full of bugs.. i will have to change nick after publishing that
08:34:24 <somenick2> eheh
08:34:32 <quicksilver> :)
08:34:41 <glguy> to what? somenick3?
08:34:53 <quicksilver> anynick
08:35:00 <glguy> allnicks
08:36:18 <Vq^> dnick
08:37:34 <glguy> somenick2: Haskell, isn't Lisp, you don't have to surround everything in parentheses :)
08:38:47 <quicksilver> > ((((((((((((((("You can if you like, though")))))))))))))))
08:38:49 <lambdabot>  "You can if you like, though"
08:39:03 <somenick2> i have studied lisp recently
08:42:53 <somenick2> quicksilver, glguy.. no comment?
08:43:21 <quicksilver> somenick2: if you pmed it to me I didn't get it
08:43:30 <quicksilver> somenick2: you're probably not an identified user on freenode?
08:43:46 <somenick2> yes, i'm not identified
08:44:18 <somenick2> i'm asking only if there is some other construct that could make the code looks better..
08:44:40 <quicksilver> somenick2: ok, I enabled messages from unid'ed users, try again
08:48:08 <ndm> can you compile C files using GHC? I always thought the answer was yes, but it doesn't seem to be working, or i need to give it an extra flag
08:48:31 <ndm> ghc mark.c gives me loads of errors, it is treating mark.c as though it was a Haskell file :(
08:48:54 <xs> cc -c mark.c; ghc mark.o?
08:51:14 <ndm> xs: i don't want to invoke cc, i just want to invoke ghc
08:52:58 <quicksilver> ndm: ghc --make can do it
08:53:08 <quicksilver> ndm: ghc --make does the right think for .hs and .c files, I believe
08:53:31 <xs> ndm, okay. curious. why?
08:53:33 <ndm> D:\sources\yhc\current\src\runtime\BCKernel>ghc --make mark.c
08:53:35 <ndm> Chasing modules from: mark.c
08:53:36 <ndm> Could not find module `mark.c':
08:53:57 <ndm> xs: less dependancies for Yhc if we just use GHC to compile the haskell and c bits
08:54:00 <SyntaxNinja> dons: malcolmw: alive?
08:54:11 <malcolmw> yo SyntaxNinja
08:54:25 <quicksilver> ndm: odd I'm *positive* someone asked that recently and the answer was yes
08:54:32 <quicksilver> ndm: and I thought that was the way to do it
08:54:38 <ndm> quicksilver: i remember the answer was yes, but can't remember how
08:54:56 <ndm> quicksilver: the make thing doesn't seem to work unless i start with a haskell file, but this is a purely C project
08:54:58 <xs> ndm, what version of ghc? it works for me.
08:55:02 <xs> (ghc-6.6)
08:55:06 <ndm> xs: 6.4.2
08:55:06 <SyntaxNinja> hi malcolmw :)
08:55:09 <malcolmw> SyntaxNinja: I think dons is asleep :-)
08:55:21 <SyntaxNinja> malcolmw: did we come to any decision about who should be the google Point of Contact this year?
08:55:21 <quicksilver> ndm: I think it requires main to come from a haskell file
08:55:28 <quicksilver> ndm: maybe make a dummy main.hs?
08:55:35 <quicksilver> ndm: which just calls c_main by FFI?
08:55:38 <malcolmw> SyntaxNinja: I believe we agreed it would be dons, with me as backup
08:55:39 <xs> ndm, ah. maybe you need to update then. i just did ghc --make foo.c and it worked.
08:55:47 <ndm> quicksilver: that would suck a lot..
08:55:51 <ndm> xs: thanks, am updating now...
08:56:03 <SyntaxNinja> malcolmw: OK. do you think there's anything I need to do? we have a few days until the deadline. I'm sure he's on top of things, thoguh
08:56:42 <malcolmw> SyntaxNinja: it would be nice if mentors did some discussing about what our application should say
08:57:09 <malcolmw> SyntaxNinja: but otherwise, dons and me will just make it up :-)
08:57:25 <SyntaxNinja> OK cool.
08:58:07 <malcolmw> SyntaxNinja: maybe you could check who has signed up as a mentor on the wiki, and add people to the soc-mentors mailing list?
08:58:20 <malcolmw> SyntaxNinja: but I don't know if that is sensible yet
08:59:09 <SyntaxNinja> did anyone solve the trac permissions problem yet?
08:59:32 <malcolmw> SyntaxNinja: we don't seem to have many people signed up yet (especially students)
09:00:13 <malcolmw> SyntaxNinja: about trac permissions, I think the solution was just to register a login.  the guy who complained was certainly able to add his name on the wiki
09:00:21 <SyntaxNinja> ok
09:00:25 <SyntaxNinja> so I won't do anything
09:00:31 <ndm> SyntaxNinja: i don't think there was ever a problem other than i couldn't figure how trac works
09:00:45 <malcolmw> SyntaxNinja: but I suppose there could be lots of frustrated students out there who have been unable to sign up, and just haven't complained
09:01:37 <malcolmw> I did place a note on the front page about needing to use the register button
09:02:53 <SyntaxNinja> ok
09:20:37 <Saizan> how many projects will be accepted for haskell soc?
09:20:53 <Igloo> It's up to google, not us
09:24:39 <xs> is the correct way to remove a spam ticket to resolve it as invalid? (in the trac.)
09:24:53 <Zeroth|work> glguy, whats wrong with length?
09:25:00 <Igloo> xs: Yes
09:25:21 <xs> Igloo, thanks :)
09:25:23 <ventonegro> yay! another happy haskell newbie :-)
09:25:33 <ventonegro> http://www.ventonegro.org/
09:26:05 <Zeroth|work> vento negro?
09:26:20 <ventonegro> Zeroth|work: yes?
09:26:30 <Zeroth|work> oh hehe
09:26:37 <Zeroth|work> didn't realize it was your name
09:26:57 <ventonegro> Zeroth|work: not my name, just a nick :-)
09:27:47 <ventonegro> anyway, ghc + gtk2hs + hdbc = happyness
09:28:32 <SyntaxNinja> malcolmw: see email; I added the new mentors
09:29:36 <Zeroth|work> > let f s = if (any (/='z') s) then "1" else "2" in f "zzz"
09:29:38 <lambdabot>  "2"
09:29:40 <Zeroth|work> > let f s = if (any (/='z') s) then "1" else "2" in f "aza"
09:29:42 <lambdabot>  "1"
09:30:42 <malcolmw> SyntaxNinja: got it.  looks like it was only to previous mentors, but I'll trust you that any new ones have been added :-)
09:31:08 <ndm> malcolmw: i got it
09:31:55 <Zeroth|work> anyone, why should 'length' be avoided?
09:32:00 <Zeroth|work> ++ like the plague
09:32:55 <malcolmw> Zeroth|work: I don't know.  who says it should be avoided?
09:32:59 <dylan> Zeroth|work: because it is O(n)?
09:33:03 <ventonegro> Zeroth|work: length is strict
09:33:10 <Zeroth|work> malcolmw, glguy
09:33:12 <dylan> (and strict)
09:33:15 <ventonegro> i mean, reads a list strictly
09:33:27 <malcolmw> length is only strict in the spine of the list, not its contents
09:33:30 <Zeroth|work> define strict
09:33:38 <dylan> > length [1..]
09:33:42 <lambdabot> Terminated
09:33:49 <Saizan> it forces the whole list to be evaluated
09:34:16 <Zeroth|work> ooh
09:34:18 <malcolmw> > length [undefined]
09:34:19 <lambdabot>  1
09:34:27 <Zeroth|work> which is bad for laziness :-p
09:34:42 <narain> Zeroth|work: compare  \list -> zip list [1..]  with  \list -> zip list [1..length list]
09:34:56 <narain> only the former works for infinite lists
09:34:59 <Saizan> in fact sometimes you use length to "strictify" a list
09:35:01 <glguy> Zeroth|work: you are using length to calculate more information than you needed
09:35:07 <glguy> were*
09:35:17 <Zeroth|work> yeah, makes sense
09:35:19 <glguy> if you don't need to know the length of a list, you shouldn't ask for it
09:36:00 <Zeroth|work> I've never heard of the 'all' and 'any' fucntions before, is there a 'none' as well?
09:36:04 <dmhouse> Hrm, I just corrected Simon Peyton Jones about his own compiler.
09:36:14 <mauke> not . any
09:36:14 <SyntaxNinja> malcolmw: yeah, I added the new ones
09:36:15 <dmhouse> Zeroth|work: no, but that's just not (any f xs)
09:36:23 <Zeroth|work> indeed
09:36:27 <dmhouse> mauke: (not .) . any, I think.
09:36:34 <Zeroth|work> never heard of not either
09:36:35 <Zeroth|work> heh
09:36:39 <Zeroth|work> other than /=
09:37:14 <narain> @pl \f l -> not $ any f l
09:37:14 <lambdabot> (not .) . any
09:37:36 <glguy> ?pl \f l -> any (not . f) l
09:37:37 <lambdabot> any . (not .)
09:39:33 <Zeroth|work> I'm really diggin this language
09:40:16 <Saizan> predicative logic! not exist x such that p === forall x not p
09:41:32 <narain> common sense! if nothing is foo then everything is not-foo
09:42:21 <Saizan> :D
09:43:42 <narain> advanced logic doesn't always agree with common sense though
09:43:49 <narain> which is more a limitation of common sense
09:44:08 <glguy> ?check (\f xs -> all (not . f) xs == not (any f xs)) :: (Int -> Bool) -> [Int] -> Bool
09:44:10 <lambdabot>  OK, passed 500 tests.
09:44:13 <laz0r> hi, i'm a haskell learner trying to find the longest string in list, ["one","two","three"] "three" would be the string i need
09:44:19 <glguy> ?check (\f xs -> any (not . f) xs == not (all f xs)) :: (Int -> Bool) -> [Int] -> Bool
09:44:21 <lambdabot>  OK, passed 500 tests.
09:44:42 <glguy> :t maximumBy
09:44:45 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
09:45:08 <glguy> > maximumBy (\x y -> length x `compare` length y) ["one","two","three"]
09:45:09 <lambdabot>  "three"
09:45:25 <laz0r> ah uh, great
09:45:31 <glguy> (not the most efficient, however)
09:45:45 <laz0r> i was about to tell you all the things i already tried
09:45:57 <laz0r> but this looks like the elegant solution ive been looking for
09:46:15 <laz0r> doing it with a foor loop seemed so un-haskell-esque
09:46:40 <narain> laz0r: you'll get used to that -- ask a question on #haskell and before you know it someone pops up with a standard library function that solves all your problems and then some
09:46:42 <glguy> > let comparing f x y = f x `compare` f y in maximumBy (comparing length) ["one","two","three"]
09:46:43 <Zeroth|work> common sense isn't by definition always right
09:46:43 <lambdabot>  "three"
09:46:53 <Zeroth|work> which doesn't mean that common sense is by definition never right :-)
09:47:01 <Philippa> but sometimes the answer is uncommonly sensible
09:47:50 <Zeroth|work> and soemtimes the wrong anser is sensibly common
09:48:04 <narain> Zeroth|work: of course. if not always foo then sometimes not-foo but not always not-foo
09:48:19 <Zeroth|work> what we're looking for here is "perhaps foo"
09:48:34 <narain> that can't be formalized!
09:48:37 <Zeroth|work> hehe
09:48:42 <narain> Maybe foo, actually
09:49:21 <narain> i'm really enjoying sussman's talk on functional programming in physics
09:49:25 <vegai> would this work?
09:49:26 <narain> http://video.google.com/videoplay?docid=-2726904509434151616
09:49:28 <lambdabot> Title: Gerald Jay Sussman: The Role of Programming (Dan Friedman&#39;s 60th Birthday) - ...
09:49:42 <vegai> oh, well. Never mind
09:50:06 <Zeroth|work> I was planning our a program to interpret a string which contains a single mis-spelled word to internally /pronounce/ it (based on statistics) in order to interpret what a human would interpret the word to be
09:50:27 <Zeroth|work> in that way, you could make typos in a command or programming language and the computer can just ignore it and know what to do
09:50:30 <Zeroth|work> but its terribly complex
09:50:36 <Zeroth|work> s/our/out
09:51:31 <Zeroth|work> like l8r is obviosuly later, and 8 would translate to "ate" but then "later" would have to be spell checked and, if incorrect, pronounced to correction
09:51:32 <vegai> > foldr (\x y -> if length x > length y then x else y) "" ["one", "two", "three", "fourty and two!", "five"]
09:51:33 <lambdabot>  "fourty and two!"
09:52:07 <narain> you could make that a foldr1 and drop the ""
09:52:31 <Zeroth|work> > foldr1 (+) [1,2,3]
09:52:32 <lambdabot>  6
09:52:34 <Zeroth|work> sweet
09:52:44 <mauke> > sum [1,2,3]
09:52:45 <lambdabot>  6
09:53:01 <Zeroth|work> > foldr1 show [1,2,3]
09:53:02 <lambdabot>  Couldn't match expected type `a -> a'
09:53:19 <Zeroth|work> heh
09:53:23 <vegai> narain: makes it fail on an empty list, though
09:58:42 <narain> vegai: shouldn't it?
09:59:10 <vegai> I don't know ;)
09:59:24 <vegai> fail ugly, I mean
09:59:43 <vegai> > foldr (\x y -> x) "" []
09:59:45 <lambdabot>  ""
09:59:49 <vegai> > foldr1 (\x y -> x) []
09:59:50 <lambdabot>  Exception: Prelude.foldr1: empty list
09:59:54 <narain> it doesn't make sense to try to find the longest string in a set of zero strings anyway
10:00:02 <narain> > maximum [1,2,3]
10:00:03 <lambdabot>  3
10:00:05 <narain> > maximum []
10:00:07 <lambdabot>  Exception: Prelude.maximum: empty list
10:00:13 <narain> i rest my case
10:00:24 * vegai nods
10:09:51 <laz0r> where yould i see the definition of maximumBy?
10:10:00 <laz0r> i found this http://www.zvon.org/other/haskell/Outputlist/index.html
10:10:01 <lambdabot> Title: Zvon - Haskell Reference
10:10:14 <narain> @src maximumBy
10:10:14 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:10:19 <laz0r> but there it says maximumBy :: (a -> a -> a) -> [a] -> a
10:10:54 <laz0r> but :t maximumBy gives me maximumBy :: (a -> a -> Ordering) -> [a] -> a
10:11:42 <laz0r> :t maximumBy
10:11:46 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
10:12:58 <Zeroth|work> hmm...
10:13:39 <narain> @index maximumBy
10:13:40 <lambdabot> Data.List
10:13:46 <narain> ?src Data.List.maximumBy
10:13:46 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:13:57 <narain> :(
10:14:53 <Zeroth|work> > let doPi n = (4 / n) - (4 / (n+1)) + doPi (n+2) in doPi 1
10:14:57 <lambdabot> Terminated
10:15:07 <Zeroth|work> not sure how to get teh value out
10:15:21 <Zeroth|work> let alone with a specified precision
10:15:24 <narain> try unfoldr
10:15:48 <Zeroth|work> :t unfoldr
10:15:51 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:16:08 <narain> wait maybe thats not the best idea
10:16:43 <narain> > map (\n -> (4/n) - (4/(n+1)) [1,3,..]
10:16:43 <lambdabot>  Parse error
10:16:51 <narain> > map (\n -> (4/n) - (4/(n+1))) [1,3,..]
10:16:51 <lambdabot>  Parse error
10:16:57 <narain> > map (\n -> (4/n) - (4/(n+1))) [1,3..]
10:16:59 <lambdabot>  [2.0,0.33333333333333326,0.13333333333333341,7.14285714285714e-2,4.444444444...
10:17:09 <Zeroth|work> > let doPi n = if (n < 3) then (4 / n) - (4 / (n+1)) + doPi (n+2) else n in doPi 1
10:17:10 <lambdabot>  5.0
10:17:13 <Zeroth|work> haha
10:17:27 <Zeroth|work> not what I wanted
10:17:40 <narain> > sum . take 10 . map (\n -> (4/n) - (4/(n+1))) $ [1,3,..]
10:17:41 <lambdabot>  Parse error
10:17:47 <narain> > sum . take 10 . map (\n -> (4/n) - (4/(n+1))) $ [1,3..]
10:17:49 <lambdabot>  2.6750856127017113
10:18:05 <Zeroth|work> > sum . take 100 . map (\n -> (4/n) - (4/(n+1))) $ [1,3..]
10:18:07 <lambdabot>  2.762613721927296
10:18:14 <Zeroth|work> not even close to pi
10:18:18 <Zeroth|work> > sum . take 500 . map (\n -> (4/n) - (4/(n+1))) $ [1,3..]
10:18:19 <lambdabot>  2.770589722239285
10:18:26 <narain> > sum . take 10000 . map (\n -> (4/n) - (4/(n+1))) $ [1,3..]
10:18:27 <lambdabot>  2.7724887247397882
10:18:30 <Zeroth|work> heh
10:18:42 <narain> i don't think it converges very fast :p
10:18:49 <narain> are you sure that's the right formula though?
10:18:53 <Zeroth|work> > sum . take 99999 . map (\n -> (4/n) - (4/(n+1))) $ [1,3..]
10:18:54 <narain> > exp 1
10:18:54 <lambdabot>  2.7725787221647615
10:18:55 <lambdabot>  2.718281828459045
10:20:14 <narain> ah you're using the wrong formula silly
10:20:42 <narain> > sum . take 10 . map (\n -> (4/n) - (4/(n+2))) $ [1,5..]
10:20:43 <lambdabot>  3.0916238066678385
10:20:50 <Zeroth|work> haha
10:20:55 <narain> > sum . take 100 . map (\n -> (4/n) - (4/(n+2))) $ [1,5..]
10:20:57 <lambdabot>  3.136592684838815
10:21:04 <Zeroth|work> > sum . take 99999 . map (\n -> (4/n) - (4/(n+2))) $ [1,5..]
10:21:06 <lambdabot>  3.1415876535398177
10:21:09 <Zeroth|work> not bad
10:21:21 <narain> it's known to be a poorly convergent formula
10:21:22 <Zeroth|work> but for 99999 places, there must be a faster way to get pi
10:21:34 <narain> > 2 * acos 0
10:21:36 <lambdabot>  3.141592653589793
10:21:44 <narain> > pi
10:21:45 <lambdabot>  3.141592653589793
10:22:53 <Zeroth|work> $ == .
10:22:54 <Zeroth|work> ?
10:23:21 <resiak> @src pi
10:23:22 <lambdabot> Source not found. It can only be attributed to human error.
10:23:33 <resiak> Heh, that's a good attitude to pi!
10:23:57 <narain> Zeroth|work: no, f $ x == f x
10:24:00 <allbery_b> Zeroth|work: no, but sometimes they can be iused semi-interchangeably
10:24:32 <narain> f . g . h $ x == (f . g . h) x == f $ g $ h $ x
10:24:44 <narain> == f(g(h(x)))
10:30:31 <narain> Zeroth|work: you may find this interesting: http://mathworld.wolfram.com/PiFormulas.html
10:30:32 <lambdabot> Title: Pi Formulas -- from Wolfram MathWorld
10:34:27 <dylan> @src ($)
10:34:28 <lambdabot> f $ x = f x
10:34:29 <dylan> @src (.)
10:34:30 <lambdabot> (.) f g x = f (g x)
10:39:03 <Zeroth|work> thats a lot of pi
10:39:14 <Zeroth|work> I could never eat all that
10:46:15 <narain> Zeroth|work: :D
10:47:58 <Cale> > 2 * sum [product [1..n]/product[3,5..2*n+1] | n <- [0..100]
10:47:59 <lambdabot>  Parse error
10:48:02 <Cale> > 2 * sum [product [1..n]/product[3,5..2*n+1] | n <- [0..100]]
10:48:03 <lambdabot>  3.1415926535897922
10:50:13 <prb> Cale: You're better off to use one of the continued fractions.
10:50:27 <narain> Cale: neat, that's pretty close to mathematical notation
10:50:42 <Zeroth|work> Cale, I challenge you to a 1vs1 Q3 match
10:50:59 <Cale> Zeroth|work: sure :)
10:51:08 <Zeroth|work> we must play the mod unlagged, however, for fairness
10:52:07 <Zeroth|work> cale, say, in 4 hours? thats when I'm home from work.
10:52:19 <Cale> Okay. Do you have a URL for that mod?
10:52:36 <Zeroth|work> its small, you can download it when you connect, I can serve if you'd like
10:52:41 <Cale> ah, okay
10:52:48 <Zeroth|work> @google unlagged quake 3
10:52:53 <Zeroth|work> heh
10:53:03 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
10:54:11 <Zeroth|work> I think I had to download it from fileplanet because I couldn't find a homepage
10:57:21 <Cale> I wonder how fileplanet managed to get that obnoxious. :)
10:57:39 <Botje> thank $deity for bugmenot.
10:59:57 <tfc> can anyone help me with a bit of code?
11:00:03 <Cale> tfc: sure
11:00:09 <Zeroth|work> @where hpaste
11:00:10 <lambdabot> http://hpaste.org/new
11:00:15 <Zeroth|work> tfc ^
11:00:33 <Zeroth|work> if haskell is translated to C, wouldn't that mean there are a lot of side effects that go on behind the scenes?
11:00:50 <Botje> of course.
11:01:14 <Botje> evaluating thunks is basically done by hacking off the thunk and replacing it with the correct value
11:01:21 <Cale> Well, eventually it has to run on a register machine, in particular, your CPU :)
11:01:35 <tfc> whats hpaste?
11:01:40 <tfc> cale i PM'd you :)
11:01:44 <Cale> tfc: a place to paste your code
11:01:49 <Cale> tfc: no you didn't
11:01:54 <Botje> and eventually, that register machine has to alter the outside world anyway.
11:01:59 <Zeroth|work> tfc, is your nick registered?
11:02:01 <Cale> (you're probably not registered)
11:02:35 <Cale> Yeah, you're not registered -- you have to identify with nickserv
11:02:47 <Cale> (or else you can't send privmsgs)
11:03:22 <Zeroth|work> tfc, jsut paste it on hpaste so we can all poke at your code
11:03:59 <pejo> Zeroth, one could hope that the translation to C is somewhat more well studied than the random code people in general write in C.
11:04:18 <Zeroth|work> pejo, I had assumed
11:04:42 <Cale> C is just being used as high-level assembly.
11:04:46 <Zeroth|work> I actually considered looking at the HGC code
11:05:00 <Zeroth|work> Cale, yeah, I like to think of it like that
11:08:32 <Zeroth|work> I guess he didn't need help after all
11:12:48 <hpaste>  tfc pasted "sorting lists" at http://hpaste.org/873
11:16:09 <glguy> > map (\(a,b,c) -> a + b + c) [(1,2,3),(7,2,9)]
11:16:11 <lambdabot>  [6,18]
11:17:44 <glguy> tfc: is that what you wanted for the total function?
11:20:29 <hpaste>  somenick2 pasted "why this doesn't compile? (probably trivial to answer)" at http://hpaste.org/874
11:20:59 <dmhouse> somenick2: well, what's the error?
11:21:12 <hpaste>  (anonymous) annotated "why this doesn't compile? (probably trivial to answer)" with "(no title)" at http://hpaste.org/874#a1
11:21:27 <somenick2> ops
11:21:28 <somenick2> no
11:21:51 <hpaste>  (anonymous) annotated "why this doesn't compile? (probably trivial to answer)" with "(no title)" at http://hpaste.org/874#a2
11:22:02 <somenick2> pasted the error
11:22:45 <glguy> TreeAction ((Tree a b) -> ((Tree a b), c)) -- is -- TreeAction (Tree a b -> (Tree a b, c))
11:22:58 <dmhouse> somenick2: the type sig for putTreeAction
11:23:17 <glguy> Maybe b isn't a "TreeAction"
11:23:51 <somenick2> wait a moment
11:24:07 <Cale> somenick2: putTreeAction by that signature is returning a TreeAction (Maybe b), but TreeAction needs 3 arguments
11:24:29 <Cale> (Maybe b) is one of them, what are the other two?
11:24:32 <somenick2> <glguy> TreeAction ((Tree a b) -> ((Tree a b), c)) -- is -- TreeAction (Tree a b -> (Tree a b, c)) <- this just say i'm using some non-needed parenthesis.. ok? (ok, but now lets resolve the problem before speaking about that)
11:24:59 <glguy> somenick2: Free help will vary in usefulness
11:25:07 <xerox> ?where logs
11:25:07 <somenick2> TreeAction need 3 types
11:25:07 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
11:25:15 <somenick2> but only one argument
11:25:31 <Cale> somenick2: The *data* constructor only needs one argument
11:25:37 <Cale> The *type* constructor needs 3
11:25:52 <glguy> newtype TypeConstructor a b c = DataConstructor d
11:26:07 <Cale> They happen to be named the same thing here.
11:26:55 <Cale> actually, just delete the type signature for putTreeAction and let the compiler infer it for you
11:27:24 <xerox> Cale, I am very tired, want a rewon?
11:27:30 <somenick2> nice idea
11:27:32 <somenick2> *Main> :t putTreeAction
11:27:32 <somenick2> putTreeAction :: (Ord a) => a -> b -> TreeAction a b (Maybe b)
11:27:56 <Cale> there you go :)
11:28:02 <somenick2> i had forgotten types in the type signature..
11:28:03 <somenick2> :)
11:28:17 <Cale> That's what we were trying to tell you :)
11:28:19 <Cale> hehe
11:28:47 <glguy> Cale: he's creating a tree specific state monad?
11:28:50 <Botje> tfc: we saw your paste, waht's wrong with it? don't you know how to start?
11:29:08 <somenick2> i'm just experimenting
11:29:13 <Cale> glguy: looks like it
11:29:18 <somenick2> i have done some functions to manipulate a tree
11:29:18 <glguy> ok, just checking
11:29:57 <glguy> ?unmtl State a b
11:29:58 <lambdabot> a -> (b, a)
11:30:03 <somenick2> probably i could have used the already included State, i have read that
11:30:21 <glguy> ?unmtl State (Tree a) b
11:30:22 <lambdabot> Tree a -> (b, Tree a)
11:30:23 <Zeroth|work> porcupinecone
11:30:31 <somenick2> in fact monads like State make sense for me.. the others are still a bit obscure..
11:30:40 <glguy> ?unmtl State (Tree (a,b)) c
11:30:40 <lambdabot> Tree (a, b) -> (c, Tree (a, b))
11:34:12 <Zeroth|work> how do you exit hgci?
11:34:59 <dcoutts_> :q
11:35:08 <Zeroth|work> heh
11:43:36 <Cheery> has anybody written java or c# with haskell?
11:48:47 <dolio> ?unmtl StateT t (ListT (State s)) a
11:48:47 <lambdabot> t -> s -> ([(a, t)], s)
11:51:30 <Cale> Cheery: You mean FFI?
11:51:40 <Cale> Cheery: yes, I've seen some stuff which does that
11:52:01 <fantasma> does anyone have an opinion towards the book titled Programming in Haskell (http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521871727/ref=pd_bbs_sr_1/002-5794713-9465604?ie=UTF8&s=books&qid=1173383198&sr=8-1)
11:52:06 <lambdabot> http://tinyurl.com/yrv5z6
11:52:20 <Cale> fantasma: It looks interesting, I haven't actually read it.
11:52:28 <Cale> But it looks like it might be good.
11:52:28 <araujo> hello
11:52:40 <araujo> Any admin of hackage.haskell.org around here?
11:53:05 <fantasma> I'm looking for a good book from which I can learn Haskell, so far The Road to Haskell seems to be my best bet
11:53:19 <Lunchy> wow, for 63 cents a page, it better be good :)
11:53:29 <Cale> Haskell Road is okay, but it's not *really* a Haskell book
11:53:37 <Cale> There are faster ways to learn Haskell itself.
11:53:42 <fantasma> that's what I feared
11:53:47 <araujo> fantasma, Introduction to Functional Programming - Bird
11:54:04 <Cale> It's really more about introductory number theory and logic
11:54:55 <Cale> If you just want to learn the language, aside from that book you just linked to, I think the best resources are probably on the web.
11:55:29 <fantasma> araujo: is Introduction to Functional Programming the sequel to Intro to Functional Programming With Haskell>
11:55:50 <Cale> When I was learning, I took some Haskell books out of the library and was not as captivated by them as the tutorials on the web.
11:55:51 <araujo> fantasma, yes
11:56:26 <fantasma> Cale: I assume you mean YAHT?
11:57:12 <Cale> fantasma: yeah
11:57:23 <Cale> and, well, a bunch of others
11:57:43 <Cale> Nothing was ideal, but taken together, they were pretty good.
11:57:58 <Cale> The wikibook is getting pretty good.
11:58:36 <fantasma> I think I will buy both books (road to haskell and the new one I just linked to)
11:58:48 <fantasma> $70 <-- good investment ;)
11:59:38 <fantasma> i'm taking a discrete math course now and I'm not doing so well so maybe the former book might be able to help
12:00:05 <cjeris> fantasma: best discrete math book = Graham/Knuth/Patashnik, Concrete mathematics
12:01:10 <fantasma> cjeris: wow, thanks for the link, looks appealing
12:01:13 <cjeris> (within what it covers, which doesn't include graph theory.)
12:01:49 <Cale> Actually, the best discrete mathematics text I know of is the C&O 330 course notes at Waterloo. :)
12:01:51 <fantasma> that's perfect considering graph theory is one of my stronger areas
12:02:36 <Cale> It's really unfortunate that they are only available from the waterloo graphics shop.
12:03:03 <Cale> (in case anyone's wondering, they're Prof. D. M. Jackson's notes)
12:03:22 <cjeris> Cale: is that more at the level of Stanley's books though?
12:04:19 <Cale> It's lots of stuff about ordinary and exponential generating series, the pattern algebra, Polya theory, and some other stuff.
12:06:00 <Cale> Basically algebraic enumerative combinatorics.
12:10:12 <Cale> The approach is very much like Joyal's approach with species, but without the category theory.
12:10:47 <Cale> (which seems nuts at first if you know what species are about, but it's actually quite natural)
12:12:53 <fantasma> Cale: why is the HR book freely available?
12:13:01 <Cale> fantasma: I don't know :)
12:13:25 <Cale> fantasma: It's not linked to.
12:13:35 <Cale> But it's still sitting in that directory.
12:14:23 <fantasma> i should download it fast before someone finds out :D
12:17:06 <Zeroth|work> Cale, I'm gunna smoke you
12:17:12 <Zeroth|work> *g*
12:17:49 <hpaste>  glguy pasted "fizzbuzz revisited" at http://hpaste.org/876
12:17:59 <Botje> argh. fizzbuzz again?
12:18:02 <glguy> haha!
12:18:09 <Botje> get it over with and make it a monad!
12:18:14 <chessguy> hi haskellers
12:18:25 <Zeroth|work> fizz buzz lolz
12:18:27 <glguy> Botje: at least look at it :-p it's different than any of the previous definitive solutions
12:18:51 <glguy> and quite configurable ;)
12:19:51 <fantasma> fizzbuzz!
12:19:55 <fantasma> mod3 mod5!
12:20:05 <glguy> eww... two specific!
12:20:13 <fantasma> eww
12:20:25 <fantasma> @quote
12:20:26 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
12:20:30 <fantasma> YES
12:20:32 <fantasma> hahahaha
12:20:48 * fantasma 's favorite quote
12:21:07 <Zeroth|work> :t mod
12:21:09 <lambdabot> forall a. (Integral a) => a -> a -> a
12:21:13 <Zeroth|work> :t %
12:21:15 <lambdabot> parse error on input `%'
12:21:18 <Zeroth|work> no sugar?
12:21:30 <fantasma> only salt
12:21:31 <glguy> > 3 % 5 + 6 % 7
12:21:33 <lambdabot>  51%35
12:21:40 <glguy> :t (%)
12:21:43 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
12:21:52 <Zeroth|work> > 4 mod 5
12:21:52 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
12:21:53 <lambdabot>     I...
12:21:56 <glguy> > 4 `mod` 5
12:21:58 <Zeroth|work> woops
12:21:58 <lambdabot>  4
12:22:02 <Zeroth|work> > 4 % 5
12:22:05 <lambdabot>  4%5
12:22:14 <quicksilver> % is integer modulo
12:22:16 <quicksilver> isn't
12:22:16 <glguy> > 20 % 5
12:22:18 <lambdabot>  4%1
12:22:19 <dolio> @quote qwe1234
12:22:19 <lambdabot> qwe1234 says: the problem is that ocaml has mandatory garbage collection.
12:22:23 <quicksilver> it's ratio construction
12:24:11 <glguy> bangpop ys = mapM_ . (putStrLn .) $ \ x ->
12:24:11 <glguy>   case [b | (a,b) <- ys, a `divides` x] of
12:24:12 <glguy>     [] -> show x ; zs -> concat zs
12:32:20 <sjanssen> @YOW!
12:32:20 <lambdabot> Unknown command, try @list
12:32:23 <sjanssen> pssh
12:32:25 <sjanssen> @keal
12:32:25 <lambdabot> are there full body recognition files for sorting art?
12:32:42 <dolio> @yow
12:32:42 <lambdabot> I put aside my copy of "BOWLING WORLD" and think about GUN CONTROL
12:32:42 <lambdabot> legislation..
12:34:54 <dmhouse> Gah. I hate how you have to subscribe to mailing lists to ask _a single question_.
12:35:27 <dolio> Some don't require that.
12:35:32 <dolio> But they get drowned in spam.
12:35:36 <edwinb> the trouble is that most people's "single questions" are "would you like to buy some v1aGr@?"
12:35:38 <dmhouse> Exactyl.
12:36:15 <sjanssen> f v1aGr@(x:xs) = xs
12:36:19 <dmhouse> So the concept of a mailing list is flawed.
12:36:47 <dolio> You should just ask slashdot.
12:36:51 <dolio> They're pretty sharp over there.
12:43:31 <dolio> So, wait, the point of "fizzbuzz" or whatever is that, supposedly, most people can't write the program?
12:43:50 <Nafai> dolio: I believe so
12:44:26 <dolio> Seems hard to believe.
12:45:16 <Zeroth|work> @where hpaste
12:45:17 <lambdabot> http://hpaste.org/new
12:46:34 <dmhouse> dolio: most applicants for programming jobs can't, yes.
12:46:52 <dolio> Crazy.
12:47:00 <sjanssen> dolio: it does seem bizarre?
12:47:20 <sjanssen> that wasn't supposed to be a question, oops
12:47:34 <dolio> Heh. Unless I'm missing something.
12:47:47 <dolio> It sounds like a problem out of chapter 1 or 2 of a "learn to program" book.
12:47:48 <chessguy> is there i description of the fizzbuzz problem written out somewhere?
12:47:53 <procyon_> Just to be different I wrote fizzbuzz in windows batch file.  It took me 10 minutes because I had to stretch my brain expressing my fold in terms of goto ;)
12:47:55 <dmhouse> dolio: which most people haven't read :)
12:48:02 <dolio> :)
12:48:18 <chessguy> @remember procyon Just to be different I wrote fizzbuzz in windows batch file.  It took me 10 minutes because I had to stretch my brain expressing my fold in terms of goto ;)
12:48:19 <lambdabot> Done.
12:48:39 <dmhouse> chessguy: output the numbers from 1 to (say) 100, but print "Fizz" if the number is a multiple of 3, "Buzz" if the number is a multiple of 5, and "FizzBuzz" if the number is a multiple of 3 and 5.
12:48:58 <cddar> are there any function like perhabs removeNth in Prelude or List for removing nth element from the list?
12:49:06 <dmhouse> ?hoogle remove
12:49:07 <lambdabot> Directory.removeDirectory :: FilePath -> IO ()
12:49:07 <lambdabot> Directory.removeFile :: FilePath -> IO ()
12:49:07 <lambdabot> Distribution.PreProcess.removePreprocessed :: FilePath -> [String] -> [String] -> IO ()
12:49:10 <dmhouse> ?hoogle delete
12:49:11 <lambdabot> List.delete :: Eq a => a -> [a] -> [a]
12:49:11 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
12:49:11 <lambdabot> Data.IntMap.delete :: Key -> IntMap a -> IntMap a
12:49:30 <dmhouse> cddar: I think the standard way is just to take and drop around it.
12:49:43 <cddar> ok thanks.
12:49:46 <sjanssen> cddar: you'll have to write your own, but you can use Data.List.splitAt for most of the work
12:49:59 <chessguy> and what if it's a multiple of neither?
12:50:04 <dmhouse> chessguy: the number itself.
12:50:07 <sjanssen> chessguy: just print the number
12:50:19 <chessguy> that does sound easy
12:50:45 <sjanssen> cddar: if you find that you're using index operations many times, you may want to consider using Data.Sequence instead of a list
12:51:02 <sjanssen> or restructure your algorithm.  Indexing is O(n) on a list, after all
12:51:11 <sjanssen> chessguy: it's outrageously easy
12:51:46 <procyon_> The original point was that while many people can talk a good talk about programming theory and such, they could have gotten that by reading a single book on design patterns.  Presenting them with a trivial problem to solve will determine whether they can code at all instead of just talking like they can code.
12:52:01 <sjanssen> do programmers that can't write FizzBuzz ever get hired?
12:52:14 <procyon_> sjanssen: yes.
12:52:21 <procyon_> I've worked with some.
12:52:24 <sjanssen> that's ridiculous
12:52:34 <sjanssen> procyon_: and they aren't fired immediately?
12:53:19 <sjanssen> ie. after the first time their boss tells them to write some code and it just doesn't happen
12:53:25 <procyon_> Nope.  It's easy to duck the issue in most organizations and continue to collect a paycheck.
12:53:35 <siti> well the boss can't write code so how do they know ;)
12:53:47 <sjanssen> wow
12:53:52 <hpaste>  zeroth pasted "my fizzbuzz don't work :-(" at http://hpaste.org/877
12:54:12 <siti> woah nuts fizz buzz there :p
12:54:32 <hpaste>  zeroth annotated "my fizzbuzz don't work :-(" with "meh" at http://hpaste.org/877#a1
12:54:39 <siti> you can just do [1..100]
12:54:55 <dolio> I thnk you want "mod x 3"
12:54:58 <dolio> > mod 5 3
12:54:59 <lambdabot>  2
12:54:59 <procyon_> Boss (non coder) says: Write me something to do X.  Coder: You don't want X.. you want Y.  I'll spend a few weeks researching X vs. Y and write you a strategic report as to what my recommendations are.  We'll have a few meetings with management... yadda yadda.. code never gets written..
12:55:06 <dolio> > mod 3 5
12:55:06 <lambdabot>  3
12:55:07 <sjanssen> zeroth: you're not handling the case where n is not divisible by 3 or 5
12:55:22 <Zeroth|work> sure I am
12:55:25 <Zeroth|work> I return ""
12:55:26 <Zeroth|work> :-p
12:55:44 * SamB thinks the part about spending weeks researching X vs. Y needs to go
12:55:49 <sjanssen> procyon_: yikes.  Do companies hire janitors that can't/don't mop?
12:55:57 <siti> I read something that was like: It's easier to change the requirements to your code than change your code to the requirements :)
12:56:31 <glguy> I gave you fizzbuzz gold, are you guys still going on about that problem? ;)
12:56:52 <SamB> siti: well, changing the requirements to fit how technology is best applied is more better
12:57:00 <Zeroth|work> glguy I can't even figure out that code yet :-p
12:57:01 <siti> more better :p
12:57:06 <glguy> betterer
12:57:06 <Zeroth|work> don't forget I'm just a newb!
12:57:28 * Zeroth|work started learning haskell the day before yesterday
12:57:32 <procyon_> sjanssen: Everyone knows what mopping is, what it is meant to accomplish, and how to do it themselves if neccissary.  Coding on the other hand is a mystical art, and to managers, we are like medicine men who do things they don't understand.  It's very easy to be a fake medicine man ;)
12:57:34 <glguy> I want you to do a little bester
12:57:40 <Zeroth|work> or no, it must have been saturday
12:57:56 <siti> procyon_: nice :)
12:57:56 <sjanssen> Boss says: Take out the trash.  Janitor: You don't want me to take out the trash, you want to make compost.  I'll spend a few weeks researching disposing of trash vs. making fertilizer and write you a strategic report as to what my recommendations are.  We'll have a few meetings with management... the office starts smelling.
12:58:07 <sjanssen> procyon_: this is true
12:58:31 <glguy> additionally, it's easy to fire a janitor and hire a new one
12:58:41 <glguy> while for programmers its only easy to fire them ;)
12:58:55 <Zeroth|work> don't lists make tuples...well, a bit useless?
12:59:03 <hpaste>  qwr annotated "my fizzbuzz don't work :-(" with "(no title)" at http://hpaste.org/877#a2
12:59:12 <glguy> Zeroth|work: tuples can hold things of different types
12:59:16 <dolio> > (5, "Hello")
12:59:18 <lambdabot>  (5,"Hello")
12:59:20 <Zeroth|work> ah
12:59:23 <dolio> > [5, "Hello"]
12:59:24 <lambdabot>   add an instance declaration for (Num [Char])
12:59:24 <lambdabot>     In the expression: 5
12:59:24 <lambdabot>     I...
12:59:24 <SamB> glguy: it is very easy to hire a new supposed programmer
12:59:25 <dmhouse> qwr: I'm not hiring you, then! :)
12:59:25 <Zeroth|work> point which is good
12:59:55 <Zeroth|work> SamB, 99% of programmer interviewee's cant even write fizzbuzz
13:00:09 <SamB> dmhouse: I don't think you are supposed to make interview decisions based on fizzbuzzes in languages the authors do not claim to know
13:00:27 <dmhouse> qwr: oh, you wrote the annotation. My bad.
13:00:37 <dolio> Python has both lists and tuples, doesn't it?
13:00:37 <Zeroth|work> here
13:00:39 <qwr> ;)
13:00:45 <SamB> Zeroth|work: emphasis on "supposed"
13:00:49 <glguy> I was recently on an interview and if I didn't know Scheme they were going to expect me to learn enough to answer the question
13:01:03 <dmhouse> Scheme's not a hard language to learn.
13:01:04 <glguy> (I knew enough, so... it was ok)
13:01:13 <SamB> glguy: during the interview, or in advance?
13:01:16 <glguy> during
13:01:18 <Zeroth|work> check out my resume: http://geocities.com/zeroth404/files/img/resume.png
13:01:28 <Zeroth|work> its got a few bugs in it, but I've since updated it
13:01:33 <SamB> well, scheme is
13:01:40 <SamB> not so tricky to learn
13:01:51 <glguy> which makes that a less obsurd request
13:02:00 <SamB> for simple things like that, anyway
13:02:08 <glguy> (the question wasn't fizzbuzz)
13:02:16 <SamB> oh.
13:02:25 <glguy> I've never been asked about fizzbuzz in the wild
13:02:30 <hpaste>  procyon pasted "my Fizzbuzz" at http://hpaste.org/878
13:02:32 <SamB> actually, fizzbuzz isn't necessarily that simple
13:02:33 <glguy> I also haven't gone on many interviews :)
13:02:58 <Zeroth|work> BATch? heh
13:03:03 <dmhouse> Zeroth|work: and how does it work?
13:03:10 <Zeroth|work> dmhouse, my resume?
13:03:13 <dmhouse> Yeah.
13:03:24 <Zeroth|work> it prompts for an answer to whether or not you'll interview me
13:03:26 <dmhouse> Zeroth|work: as in, does it work well?
13:03:33 <dmhouse> I grokked that much :)
13:03:44 <dmhouse> As in, does it get you jobs?
13:03:54 <Zeroth|work> dmhouse, it does. I've doen my best to make it secure efficient code, except for the useless struct which is there for effect
13:03:56 <dmhouse> (Sorry, I'm not feeling particularly lucid today.)
13:04:02 <Zeroth|work> and like I said, thats not the latest version.
13:04:03 <procyon_> Windows batch is fun.  It makes any trivial problem a brain teaser.
13:04:10 <Zeroth|work> dmhouse, I've never used it :-)
13:04:45 <Zeroth|work> dmhouse, the job I'm at right now is the first one I've ever had, Ive been here for 3 years
13:06:12 <syntaxfree> I'm gonna ask a stupid, stupid question.
13:06:12 <sjanssen> @seen augustss
13:06:13 <lambdabot> I saw augustss leaving #haskell 7h 11m 38s ago, and .
13:06:20 <syntaxfree> Everyone ready for my stupid question? Show of hands!
13:06:55 * Zeroth|work averts his eyes
13:07:04 * dmwit raises hand
13:07:13 * Zeroth|work smacks dmwit
13:07:17 <Zeroth|work> :-p
13:07:24 <dmwit> ?slap Zeroth|work
13:07:25 * lambdabot smacks Zeroth|work about with a large trout
13:07:27 <Zeroth|work> syntaxfree, go ahead already
13:07:28 * dmwit is passive-agressive
13:07:33 <Zeroth|work> lambdabot, how could you!
13:07:37 <syntaxfree> I said show of hands!
13:07:44 * Zeroth|work raises his freakin hand
13:07:54 <procyon_> no instance of show for hands
13:08:56 <allbery_b> "just ask already" :>
13:09:08 <sjanssen> > show "hands"
13:09:10 <lambdabot>  "\"hands\""
13:09:13 <syntaxfree> haha. I'm having fun :)
13:09:15 <dmhouse> > return "Ask" :: Maybe String
13:09:16 <syntaxfree> anyway.
13:09:17 <lambdabot>  Just "Ask"
13:09:21 <syntaxfree> hahahaha
13:09:26 <sjanssen> dmhouse++ nice one
13:09:31 <syntaxfree> what's a good IDE for using with GHC?
13:09:40 <sjanssen> vim
13:09:41 <dmhouse> Emacs?
13:09:42 <procyon_> emacs
13:09:47 <syntaxfree> I'm tired of keeping track of text files in many subdirectories by hand.
13:09:59 <Philippa> so pick a text editor with a notion of project or workspace
13:10:00 <syntaxfree> I'd like something with "Projects" like old-school VB4 :)
13:10:14 <Philippa> TextPad has one under windows
13:10:18 <glguy> What does Marsellus Wallace look like?
13:10:43 <SamB> syntaxfree: explain the features you require
13:11:01 <SamB> also, VB5 had projects too
13:11:08 * Zeroth|work only knew VB6
13:11:15 <SamB> but it had a crappy programming language
13:11:16 * glguy started playing with VB3
13:11:20 <qwr> you could write bash-completion, that would search from subdirectories
13:11:20 <glguy> it fit on a floppy disk
13:11:26 <glguy> so I could take it to my grandma's house
13:11:34 <syntaxfree> why do people use Eclipse and the like?
13:11:43 <Zeroth|work> ellipsis?
13:11:49 <dmhouse> Because people write Java.
13:11:58 <eddyp> syntaxfree: because it has autocompletion done properly
13:12:01 <procyon_> Eclipse makes Java slightly less painful
13:12:09 <Zeroth|work> java...painful?
13:12:13 <Zeroth|work> wasn't it created to be easy?
13:12:20 <syntaxfree> why people use Eclipse with Ruby?
13:12:24 <Zeroth|work> c++ minus the low level stuff
13:12:31 <dmhouse> Because they previously wrote Java.
13:12:37 <eddyp> syntaxfree: because it has autocompletion done properly
13:12:37 <glguy> it was created to be dumbed down enough that companies could find lots of people that could handle churning out java software
13:12:44 <procyon_> Java is the second most painful language I ever programmed in.  The first is Windows Batch files, and that's only as a joke.
13:12:45 <glguy> not to be enjoyable to program with
13:13:03 <dmhouse> I dunno; Emacs is the most powerful editor in the world, it's revolutionised my expectations of a text editor and I couldn't live without it.
13:13:27 <procyon_> Hell, my SKI+Y combinator interpreter is easier than Java.
13:13:30 <Zeroth|work> I wanted to learn C and Assembly in highschool. they wanted to shove Basic and Java down my throat. and no, not 'visua' basic
13:13:31 <dolio> I'm sure emacs has some extention to do projects.
13:13:38 * SamB wonders if the fact that main/DriverPipeline.o is being compiled is an indication that GHC is almost finished building
13:13:55 <syntaxfree> I'd like to  have a tree-like visualization of GHC hierarchical modules and the functions/data types defined in them.
13:14:20 <dmwit> ...
13:14:24 <dmwit> in your IDE?
13:14:33 <Zeroth|work> IDE? where?
13:14:39 <Zeroth|work> :-p
13:14:44 <dolio> Does Visual Haskell do that?
13:14:58 <Zeroth|work> @where Visual Haskell
13:14:58 <lambdabot> I know nothing about visual.
13:15:02 <Zeroth|work> @where VisualHaskell
13:15:03 <lambdabot> http://www.haskell.org/visualhaskell/
13:15:34 <eddyp> only for windows
13:15:37 <Zeroth|work> yuc
13:15:40 <syntaxfree> yeah, I'm on a mac.
13:15:59 <dolio> Hmm, didn't the last HWN mention something about xcode integration?
13:16:00 <qwr> Zeroth|work: java was created to be easier than c++
13:16:03 <procyon_> I tried visual haskell, but it broke under my visual studio 2005 + vista 64 at work... besides, most all my real programming is not on Windows, so emacs is king in my world.
13:16:13 <Zeroth|work> qwr, thats the entire idea that I was implying...
13:16:24 <syntaxfree> I'm tired of juggling text files and browsing the online GHC docs.
13:16:35 * qwr don't think, that its hard to be easier than C++ :)
13:16:36 <chessguy> syntaxfree: hear, hear
13:16:41 <syntaxfree> Of course the Haddock documentation is amazing compared to what I've seen in the Python/Ruby world, yes.
13:17:04 <syntaxfree> Still, I'm not an experienced software developer and always end up so confused with larger-ish projects I drop everything in frustration.
13:17:22 <syntaxfree> And then someone scoops me with a cooler, monadic/comonadic/arrow-adic version of what I was doing =)
13:17:32 <procyon_> Java was NOT created to be easier than C++, and it is substatially more difficult to program in.  It was created to remove the possibility of making a few common C++ errors, not be easier persay.  IN the process, it removed most of the expressiveness of C++ with it, leaving a sad, shell of a language.
13:17:43 <chessguy> syntaxfree: i'm trying haskell-mode in emacs, hoping to get some good haskell-specific IDE features that way
13:17:58 <syntaxfree> I can't handle emacs. I'm a viiite.
13:18:09 <dmwit> Yay!
13:18:15 <chessguy> i've been using vim, but i need something else
13:18:26 <dmwit> ?where thunk
13:18:27 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/thunk/
13:18:36 <syntaxfree> http://eclipsefp.sourceforge.net/
13:18:44 <syntaxfree> to quote Ali G, is this good or is this whack?
13:18:44 <dolio> http://www.hoovy.org/HaskellXcodePlugin/
13:18:44 * procyon_ is not implying C++ is a good language, just that, good god, java is bad.
13:18:45 <lambdabot> Title: Haskell Xcode Plugin
13:18:48 <Zeroth|work> all I know is that carmack really doesnt like Java, and ... common, if carmack doesn't like it...
13:18:52 <dolio> Doesnt't say anything about docs, though.
13:18:53 <Philippa> procyon_: "most of the expressiveness of C++" is regarding exactly what you want to shoot yourself in the foot with, no?
13:18:58 <syntaxfree> I don't understand Xcode either.
13:19:19 <Philippa> not that I'm a fan of Java either
13:19:20 <Zeroth|work> where common = "come on"
13:19:22 <sjanssen> dmwit: are you trying thunk?
13:19:23 <stefanha> If you set the "path" option in Vim, then using ":find" is quite useful.
13:19:30 <dolio> Ah. I haven't used it (don't have a mac) but people seem to rave about it.
13:19:33 <qwr> procyon_: in some way you're right, but C++ as a language _is_ complicated.
13:19:35 <stefanha> No need for "projects".
13:19:37 <dmwit> I want to, when it gets a tiling mode.
13:19:44 <dmwit> So I'm keeping an eye on it. =)
13:19:52 <Cale> Zeroth|work: you might be right -- The best I've been able to do vs. Nightmare Uriel today is 10-3. Normally I can get perfect without too much trouble.
13:19:56 <Philippa> stefanha: there is if you want views on the same directory, stuff like that
13:20:00 <Zeroth|work> I thought about learning Java just to put it on my resume, but you guys are makin me think twice
13:20:12 <stefanha> Philippa: :e .
13:20:31 <Zeroth|work> Cale, bots aren't comparable to humans
13:20:38 <sjanssen> dmwit: are you looking for dwm style dynamic tiling, or more static (like ion3)?
13:20:43 <syntaxfree> I don't understand how people get work done without HOFs.
13:20:44 <Zeroth|work> cale, they're dumb, but their aim is about perfect at times
13:20:45 <Philippa> Zeroth|work: I've used worse languages, really
13:20:53 <Zeroth|work> Philippa, like what, Cobol?
13:20:55 <Cale> Zeroth|work: I usually can measure how alert I am with them though.
13:20:56 <glguy> Zeroth|work: be careful, you list it and you might have to *use* it!
13:21:09 <dmwit> sjanssen: I've never used ion3, so I don't know what it was like.  But I really liked wmii's tiling, and dwm does a pretty good job, too.
13:21:31 <dmwit> sjanssen: Basically, I don't want to have to do any window manipulations myself, and dwm gets _really_ close to that ideal.
13:21:42 * stefanha runs ratpoison
13:21:44 <Philippa> Zeroth|work: I haven't used cobol specifically, but it'd be an example
13:21:45 <procyon_> Philippa: The took away the choice of GC, although they did a decent job there.  They took away destructors which are the only sane way to do resource allocation in an imperative world.  They took away multi inheritance, which eliminates a whole range of programming idoms, not the least of which is default interface behaviors.  They gimped the generics, so there is no way to do non-imperative coding at all... I could go on and on..
13:22:01 <sjanssen> dmwit: you'll probably see dwm style tiling in thunk in the next few days
13:22:15 <dmwit> sjanssen: =D
13:22:24 <Philippa> procyon_: *hah*. There's plenty of way to do non-imperative coding, just remember that it's not going to be typesafe
13:22:24 <Zeroth|work> glguy, I'd rather not use any code on my job, unless its for personal use. System Administration of small business is where the easy but decent-pay jobs are
13:22:28 <Zeroth|work> *grin*
13:22:40 <Philippa> last time I wrote any Java there just weren't any generics...
13:22:49 <glguy> Zeroth|work: I have no interest in pursuing a job I consider "easy"
13:23:02 <procyon_> Philippa: there are now.. but they are brain dead.
13:23:23 <Zeroth|work> glguy if I were doing a job that was beneficial to humanity in some way, I wouldn't mind doing some hard stuff. but, just like haskell, I'm lazy.
13:23:52 <glguy> Zeroth|work: good, then we aren't competing for the same positions :)
13:24:12 <Zeroth|work> I work at a company that builds equipment for family entertainment centers. all this industry does is kill people
13:24:23 <SamB> hmm, for some reason Haskell people like to do the impossible
13:24:24 <Zeroth|work> :-p
13:24:32 <Philippa> tbh, I don't get really venemous about Java until I have to think about tasks that want sums at the core rather than products - that is, until I build something that looks like an AST
13:24:33 <procyon_> Philippa: Ruby is what Java wanted to be.  Java ended up just another C++, but without any benefits of C++.
13:24:43 <glguy> If it's easy, you aren't learning, if you aren't learning, you are just selling your time, if you are just selling your time you may was well get it over with and die
13:24:53 <titus> Zeroth|work: the entertainment industry kills people?
13:24:58 <qwr> Philippa: they added generics but no way for type aliases - which with no type inference sucks.
13:25:11 <Zeroth|work> titus. think roller coasters.
13:25:12 <Zeroth|work> heh
13:25:32 * titus thinks roller coasters
13:25:36 <Zeroth|work> glguy, I agree, but the odds are pretty good that I'll just be writing *crys* proprietary software
13:25:58 <glguy> Zeroth|work: that'd be terrible, especially if you were better off having done it
13:26:12 <Zeroth|work> glguy, huh?
13:26:41 <Philippa> glguy: it only works that way if you've nothing to do in the rest of the time you're not working
13:26:51 <Zeroth|work> glguy, think of it this way. I learned Haskell, mostly while on the job.
13:26:57 <Philippa> odds are I won't be learning when I first hit the workplace, it won't necessarily be the point
13:27:04 <Zeroth|work> s/I\ learned/I\'m\ learning
13:27:05 <glguy> Philippa: you have a finite amount of time
13:27:18 <Philippa> sure. I also have ongoing requirements for things like food
13:27:31 <glguy> right, so ifyou are just trading your day for food
13:27:39 <glguy> then you are just prolonging the inevitable
13:27:59 <Philippa> if I'm only trading it for a day's worth of food, sure
13:28:09 <Zeroth|work> glguy, which is why I'd rather spend my time enjoying my life, learning, and experiencing, rather than giving it to someone else, unless its philanthropical
13:28:43 <titus> It's hard to get the balance right. I have a pretty easy job, well paid, and it's driving me mad (java web apps, since you ask). I am hoping to give it up this year to go back to uni.
13:29:03 <dolio> Look on the bright side. It could be PHP web apps.
13:29:08 <Zeroth|work> I do more than just system administration. I also built and maintain their website
13:29:30 <Zeroth|work> dolio, I built it in PHP :-|
13:29:31 <titus> dolio: yeah, I could be digging a ditch.
13:29:41 <dolio> :)
13:30:03 <Zeroth|work> actually, I built it in ASP. then I learned PHP and converted it for busy-work and the excuse to learn PHP. :-p
13:30:30 <dolio> Heh.
13:31:37 <Zeroth|work> during this job, I've learned ASP, PHP, and a tid bit of Haskell ;-)
13:31:44 <Zeroth|work> oh, and Tcl/Tk
13:31:58 <Zeroth|work> and a tid bit of Mysql....
13:32:28 <dolio> Ah, tcl.
13:32:34 <dolio> Everything is a string.
13:32:44 <Zeroth|work> Tcl is good stuff man
13:32:57 <Zeroth|work> while not as interesting as Haskell, its great for RAD
13:34:00 <dolio> You know what never went anywhere? REBOL.
13:34:09 <Zeroth|work> Cale, we blow each other to pieces in T-minus 90 minutes
13:34:12 <dolio> I remember deciding way back whether to buy a Ruby book or a REBOL book.
13:34:18 <Cale> :)
13:34:20 <dolio> Luckily, I guess, I chose the former.
13:34:38 <titus> what's REBOL?
13:34:53 <dolio> It's a scripting language of sorts.
13:34:56 <Zeroth|work> I'm considering learning Ruby, but I already know Tcl, and I'm certainly going to learn Perl and eventually Python...but they're all languages that do pretty much the same stuff...
13:35:02 <dolio> With emphasis on making web stuff easy.
13:35:19 <dolio> I think sending emails was as primitive as printing to the screen, or something like that.
13:35:30 <titus> right, never heard of it...good choice :-)
13:35:34 <Cale> I find it amazing how Python and Ruby programmers argue. The languages are almost the same.
13:35:56 <Zeroth|work> Cale, then I'll have no trouble moving from Python to Ruby. :-)
13:36:04 <Zeroth|work> I love it when one language teaches another
13:36:14 <allbery_b> the only interesting thing about rebol IMO was mime objects and URLs as first class objects
13:36:17 <Philippa> learn a .NET lang, then
13:36:19 <titus> Cale: that *is* funny! they hate each other!
13:36:26 <Zeroth|work> avoid .NET like the plague
13:36:40 <Cale> It's like Catholics vs. Protestants.
13:36:49 <Zeroth|work> I don't remember why, but it was a great reason. also because of single-platform-ness
13:36:58 <malcolmw> any yhc people about?
13:37:04 <Zeroth|work> Cale, their god was the same, last I checked.
13:37:11 <titus> Peoples Front of Judea vs Judean Peoples' Front
13:37:12 <qwr> Zeroth|work: you already know scheme and ocaml? ;)
13:37:15 <mbishop> .NET is hardly single platform
13:37:17 <Cale> titus: exactly :)
13:37:31 <Philippa> titus: Splitter!
13:37:33 <Zeroth|work> qwr, I hear ocaml is much like Haskell, so I'll probably go to that once I'm proficient in Haskell.
13:37:41 <Zeroth|work> never seen a line of scheme in my life
13:37:56 <procyon_> Zeroth: Learn Scheme... The other "least broken" language of our time.
13:38:06 <psi> (display "Now you have!")
13:38:07 <Cale> Or how there are two communist parties in Canada :)
13:38:13 <Zeroth|work> scheme is like Haskell, I take it?
13:38:18 <Cale> Splitting the lost cause vote.
13:38:30 <qwr> Zeroth|work: no, it's not.
13:38:34 <Zeroth|work> hmm
13:38:34 <Cale> Zeroth|work: pretty different
13:38:36 <procyon_> Scheme is like haskell without the types.
13:38:45 * Zeroth|work makes a list
13:38:45 <Cale> and without the syntax, and it's strict.
13:38:45 <mbishop> or the monads
13:38:47 <dolio> And without the syntax.
13:38:57 <qwr> and with optional side effects
13:38:59 <sjanssen> and without the semantics
13:39:10 <dolio> Heh.
13:39:12 <Cale> and less currying
13:39:13 <titus> and with jam stains
13:39:15 <mbishop> but with a better ide
13:39:16 * mbishop runs
13:39:18 <procyon_> lol
13:39:25 <Cale> mbishop: Indeed!
13:39:38 <Cale> It would be cool to have a Dr.Scheme-alike for Haskell.
13:39:43 * mbishop nods
13:39:54 <Zeroth|work> scheme, ocaml, perl, python, ruby, in that order so far
13:39:57 <procyon_> They are similar enough that Liskell could be considered a dialect of either Haskell or Scheme.
13:40:01 <Cale> It would be ideal, in fact -- that's what everyone's doing already, but they need more than one window for it.
13:40:32 <Cale> Zeroth|work: do you play go at all?
13:40:33 <Zeroth|work> I'm considering Lisp as well, but I think that might be pointless
13:40:38 <Zeroth|work> go?
13:40:44 <Philippa> nah, Factor's pointless
13:40:53 <Philippa> or Joy
13:40:54 <procyon_> Scheme is lisp without the hairy tufts.
13:40:59 <syntaxfree> Factor is a toy, it seems to me.
13:41:02 <Cale> Yeah, it's a board game which has been around about 4000 years.
13:41:13 <Zeroth|work> so stick lisp after scheme
13:41:20 <procyon_> Forth would be a good one for that list.
13:41:23 <mbishop> shhh, Slava might be listening!
13:41:28 <rashakil> Factor might make a good freshman's programming language
13:41:35 <Zeroth|work> Cale, now that you mention it, I may have some memory of knowledge of that game in my brain somewhere.
13:41:36 <qwr> Zeroth|work: scheme is lisp, but simpler and cleaner than common lisp. and without a common lisp library ;)
13:41:38 <Cale> mbishop: hehe, wouldn't want to encourage him :)
13:41:41 <dolio> Ooo, and prolog. Evereyone likes prolog.
13:41:45 <procyon_> Zeroth: I would skip Lisp altogether.  Scheme is the cleanest *dialect* of lisp.
13:41:54 * sjanssen doesn't understand why people like stack languages
13:42:04 <Zeroth|work> qwr, so I should learn lisp before scheme, so that I wont just throw it down and stick to scheme?
13:42:05 <sjanssen> I get tired of writing swp and dup very quickly
13:42:06 <procyon_> prolog is a definite.  Infact, drop ruby from that list and replace it with prolog.
13:42:12 <Zeroth|work> scheme IS lisp?
13:42:17 <Cale> Zeroth|work: I taught chessguy the rules the other day. If you'd like, I could show you it as well. :)
13:42:22 <procyon_> ZerothL yes.
13:42:31 <Zeroth|work> (scheme, lisp), ocaml, perl, python, (prolog, ruby)
13:42:41 <psi> Zeroth|work: A lisp
13:42:53 <procyon_> Zeroth: Scheme is a lisp, but cleaned up severely.
13:42:53 <dolio> Prolog is actually appreciably different than the other languages on that list.
13:43:06 <Zeroth|work> Cale, board games are what you play when you're bored :-)
13:43:07 <Philippa> yeah, prolog's worth having met
13:43:20 <Cale> Zeroth|work: it's pretty good actually :)
13:43:29 <sjanssen> (scheme, lisp), ocaml, perl, prolog, (python, ruby) -- makes more sense, I think
13:43:32 <Zeroth|work> and some ancient ones...fortran, algol, ada, rpg (this one sounds scarry)
13:43:35 <cjeris> Zeroth|work: add J
13:43:37 <Zeroth|work> I'll probably die before I get to those
13:43:46 <mbishop> sjanssen: really? I'd put perl in that last grouping
13:43:59 <mbishop> then I'd cut that grouping off
13:44:05 <mbishop> since Scheme is good enough :P
13:44:06 <Cale> mbishop: haha
13:44:08 <sjanssen> mbishop: :)
13:44:34 <syntaxfree> hmm. Eclipse for Haskell has some kind of Haddock support.
13:44:35 <sjanssen> the best list: Haskell '98, Haskell', Haskel'' ...
13:44:45 <procyon_> Zeroth: My recommended list would be: Scheme, Ocaml, prolog, erlang, (eiffel | smalltalk), python
13:45:01 <Cale> sjanssen: If this continues, in 30 years, our language will be called ''''''''
13:45:10 <mbishop> Ohh neat, beta release of ocaml 3.10.0, includes a "ocamlbuild" tool...wonder if it will be nice like ghc's -make
13:45:15 <rashakil> no, Haskell^{(8)}
13:45:41 <sjanssen> procyon_: what can Ocaml offer to an experienced Haskeller?
13:45:42 * cjeris always wondered why Nintendo didn't call the 2005 Metroid game Metroid Double Prime
13:46:00 <syntaxfree> I'd guess HaskellM comes first :)
13:46:06 <syntaxfree> then HaskellT
13:46:11 <Zeroth|work> ok,
13:46:11 <Zeroth|work> ((scheme > lisp) ? ocaml), perl, (prolog, (python ? ruby)), erlang, (eiffel ? smalltalk), J?
13:46:15 <syntaxfree> sjanssen: functors?
13:46:24 <hpaste>  SamB pasted "AT troubles" at http://hpaste.org/879
13:46:26 <Philippa> ML-style module systems're worth knowing about
13:46:35 <Zeroth|work> that'll take me years heh
13:46:36 <chessguy> Zeroth|work: make sure you let Cale beat you, like i did
13:46:38 <Philippa> getting to play with extensible records and variants is good too
13:46:45 <Cale> heheh
13:46:47 <sjanssen> SamB: what's the problem
13:46:54 <procyon_> sjanssen:sjanssen: dunno.. but it was on his original list, and it's not a bad one ;)
13:46:58 <schemell> does anybody know how i can get ghc-6.6 on gentoo?
13:47:01 <SamB> Eval.hs:94:50:
13:47:01 <SamB>     Couldn't match expected type `m' (a rigid variable)
13:47:01 <SamB>            against inferred type `m1' (a rigid variable)
13:47:01 <SamB>       `m' is bound by the instance declaration at Eval.hs:94:27
13:47:01 <SamB>       `m1' is bound by the type signature for `marshallIn_'
13:47:01 <SamB>                          at Eval.hs:80:31
13:47:04 <SamB>       Expected type: Room m -> Value' m1
13:47:07 <SamB>       Inferred type: Room m1 -> Value' m1
13:47:10 <SamB>     In the expression: VRoom
13:47:12 <SamB>     In the definition of `marshallIn_': marshallIn_ = VRoom
13:47:17 <Zeroth|work> chessguy, I'll take that into consideration...
13:47:20 <chessguy> spammer! kick him!
13:47:31 <SamB> chessguy: hey!
13:47:38 * Zeroth|work beats SamB like a bad baby
13:47:41 <SamB> at least I did not paste the whole program in channel
13:47:44 <chessguy> die, scumbag spammer! DIE, i say!!!
13:47:58 <procyon_> Zeroth: Oh! and Windows Batch... You gots to get you some Windows Batch ;)
13:48:01 <syntaxfree> anyone here uses eclipse+ghc?
13:48:27 <cjeris> Zeroth|work: J is an APL descendant which is worth exploding your head with at least once.
13:48:40 <titus> Philippa: any suggestions for learning O'Caml?
13:48:42 <Zeroth|work> procyon_, I read a book, I think it was called "Advanced Batch [insert word]" when I was in about 5th grade
13:48:44 * SamB wants to know how to change his MarshallIn/MarshallOut classes so that the instances for Room work
13:49:19 <dolio> titus: Just buy the book Practical O'Caml.
13:49:22 <allbery_b> J was, in a sense, my first introduction to functional programming.  I guess you could say it made my learning Haskell inevitable --- but it also delayed my further exposure to FP by 15 years
13:49:23 * dolio snickers.
13:49:23 <Cale> Write a fold in unix dc.
13:49:34 <allbery_b> just from the "ow! brain hurty!"
13:49:46 <schemell> i tried to use the haskell overlays but emerging would downgrade my system from 6.4.2 to 6.4.1
13:49:59 <schemell> ghc-6.6 was masked
13:50:05 <procyon_> Zeroth: I implemented loading libraries for batch files, then defining classes and instantiating objects using the environment variables as a heap, and did OO Batch file programming... I never implemented a garbage collector for environment variables, but I considered it :)
13:50:16 <chessguy> heh. when something hurts my brain, i tend to come back for more. like licking a 9-volt battery
13:50:17 <sjanssen> SamB: does adding a class constraint to the instance help?
13:50:18 <titus> dolio: OK...and free resources in the meantime? I would need to get over the idea that OCaml code looks lots uglier than haskell before thinking it was wirth paying for a book.
13:50:30 <Cale> dcoutts: are you around? schemell needs help :)
13:50:48 <dolio> titus: That was just my weak attemt at humor. The book is, reportedly, terrible.
13:50:57 <Zeroth|work> procyon_, yikes
13:51:02 <SamB> no...
13:51:07 <sjanssen> SamB: instance (MonadAdvent m) => MarshallIn  (Room m)
13:51:12 <SamB> hmm.
13:51:17 <titus> dolio: thank goodness my credit card is till in my pocket :-)
13:51:22 <dolio> :)
13:51:30 <sjanssen> SamB: I think that is required there
13:51:50 <cjeris> allbery_b: J has unmatched clarity and usability for the kind of twisted, insane genius you find cackling to himself in an underground hideout surrounded by millions of dollars of dubiously functional machinery.
13:51:51 <procyon_> schemell: I believe in the latest sync, 6.6 is in the portage tree, but masked (assuming you are talking gentoo)
13:51:57 <SamB> sjanssen: I still get the same error though
13:52:13 <titus> I think I have heard O'Caml for Scientists(?) getting better reviews though?
13:52:20 <schemell> yep thats gentoo procyon_!
13:52:57 <schemell> not in the main portage tree but the haskell overlay
13:52:59 <Zeroth|work> its big enough for now: ((scheme > lisp) ? ocaml), Brainfuck, perl, (prolog, (python == ruby)), erlang, (eiffel ? smalltalk), (J > APL)?
13:53:30 <Zeroth|work> all while trying to learn MIX :-/
13:53:36 <dolio> Heh, brainfuck is on the list now?
13:53:38 <narain> speaking of J, i'm just going through the wikipedia entry. am i to understand that J allows *only* point-free programming?
13:53:38 <cjeris> Zeroth|work: s/MIX/MMIX/
13:53:43 <Zeroth|work> dolio, I wanna check it out
13:53:47 <sjanssen> SamB: writing out the argument for marshalIn'
13:53:49 <Zeroth|work> cjay, you sure?
13:53:57 <Zeroth|work> s/cjay/cjeris
13:53:58 <sjanssen> SamB: try writing out the argument for marshalIn'
13:54:15 <cjeris> Zeroth|work: for TAOCP, right?
13:54:31 <procyon_> Zeroth: The trick is that you can access environment variables like classname.%instance%.member That works for calls too, so you can have a batch file holding a class keep an internal counter and return %instance% as part of a new.  Then each dereference of an object will access the state of that particular instance.
13:54:41 <syntaxfree> J = APL.
13:55:27 <narain> "J ... is a synthesis of APL and the FP and FL function-level languages"
13:55:31 <schemell> i'd like to experiment with 'cgi' but cabal complains that i need base-2... i presume that's in ghc-6.6
13:55:35 <Zeroth|work> cjeris, yes
13:55:40 <narain> does that mean J > APL?
13:55:52 <allbery_b> J is the successor to APL
13:56:20 <procyon_> Zeroth: And as crappy a language as Batch is, if you are using the environment as a heap, "set > storage.bat" will save the state of the entire environment, which can later be restored by "call storage.bat".. so you can pause and restart batch programs at any time, even rebooting, by trivially dumping your heap to a file.
13:56:25 <allbery_b> it does not require point-free, but it's strongly encouraged.
13:56:37 <allbery_b> or at least it was so 15 years ago.  quite pssibly it's evolved since then
13:56:47 <SamB> sjanssen: actually, I get basically the same error with marshallOut_ anyway
13:56:56 <Zeroth|work> procyon_, sounds like a very interesting endeavour, but ... fruitless :-/
13:57:12 <narain> ok... i find the J examples in Wikipedia very intimidating
13:57:17 <Zeroth|work> haha, stick D somewhere in that list
13:57:31 <allbery_b> now you know why it scared me away from FP for so long :)
13:57:35 <dolio> Some are written to be so.
13:57:39 <cjeris> Zeroth|work: the revised Section 1.3 is available from Knuth's website.  there's no reason to solve your exercises in 1960's architecture :)
13:57:40 <dolio> Like glguy's quicksort.
13:57:47 <syntaxfree> does J have third-order functions?
13:57:49 <narain> allbery_b: yes, now i understand your pain
13:57:55 <Zeroth|work> cjeris, its a very intimidating read, AOCP
13:57:58 <syntaxfree> apparently APL has verbs (functions) and adverbs (second-order functions)
13:58:00 <SamB> hmm. adding m as an argument to the class helps...
13:58:06 <syntaxfree> TAOCP? Taocp is entertaining!
13:58:09 * SamB wonders what was intended
13:58:25 <allbery_b> when I looked at J, it only had verbse and adverbs, no third orders
13:58:31 <Zeroth|work> it is entertaining, but I don't know assembly, so MIX is my first assembly
13:58:32 <SamB> (that is, whether GHC behaves as intended)
13:58:46 <procyon_> Zeroth: It had a point.  We were using a *very* complex build process.  When something broke, the devs could not figure out what went wrong.  By replicating the build in batch files, I could show the devs the exact set of command lines that repro the build break... But as the project grew, I ended up with a cluster of machines each running a peice of the build... basically a performance cluster of batch file services ;)
13:58:59 <syntaxfree> I mean, there's something seriously wrong with a language that has second-order functions (i.e. the compiler is already handling function pointers or whatever it is) but stops there.
13:59:01 <cjeris> Zeroth|work: if you don't know assembly, starting with MMIX rather than MIX is likely to help you avoid habits that would be bad in the 21st century :)
13:59:29 <Zeroth|work> cjeris, diff MMIX MIX
13:59:50 <Zeroth|work> AOCP has MIX, so I thought
13:59:54 <SamB> well, MIX requires you to use self-modifying code for returning from procedures...
13:59:56 <narain> if verbs are functions, and adverbs are second-order functions, does the English language have third-order functions?
14:00:22 <syntaxfree> well, there are "functors" of sort relating entire theories.
14:00:23 <cjeris> Zeroth|work: MIX:MMIX :: [random 1960s architecture]:MIPS64
14:00:23 <procyon_> Wouldn't learning .NET, JVM or C-- be better than learning a processor specific assembly now days?
14:00:39 <dolio> Adverbs can apply to adverbs.
14:00:42 <ClaudiusMaximus> narain: he walked rather hurridly?
14:00:43 <dolio> In English, at least.
14:00:44 <syntaxfree> Classic studies often postulates a functor between Greece and Rome in many aspects, from its gods to its heroes.
14:00:54 <syntaxfree> Plutarch also has a series of compared lives of greeks and romans.
14:00:55 <SamB> perhaps verbs can apply to verbs, too?
14:00:56 <kc5tja> procyon_: Someone has to port backends .NET, JVM, and C-- to specific CPUs though.
14:01:04 <Zeroth|work> I'm out, see ya soon Cale >:-)
14:01:21 <syntaxfree> so there's a functor between category Greece, with objects being heroes and arrows being their actions, and category Rome, with similar structure.
14:01:44 <pejo> procyon_, considering what was said by Ramsey before christmas I'm not convinced that C-- will be developed that actively in the near future.
14:01:57 <narain> yes, the idea of "*rather* hurriedly" came to me too, but that's just an intensifier. anything more interesting?
14:02:06 <procyon_> kc5tja: Yes, but for learning assembly language programming in general... those seem like better choices, as what you learn there can be applied to any assembly language, AND you get a more widespread applicability.
14:02:17 <kc5tja> allbery_b: You can use any verb with adverbs, including custom-made verbs.
14:02:18 <cjeris> pejo: ?
14:02:18 <narain> syntaxfree: i meant parts of speech, not theories :)
14:02:20 <titus> procyon_: a lot of people want to learn assembly because they feel it's a hole in what they know. Then they can stand before St. Peter etc...
14:02:28 <kc5tja> allbery_b: Not sure if this is what you're referring to or not.
14:02:33 <pejo> cjeris, long email with a status report to the c-- list.
14:02:51 <sjanssen> SamB: I understand your problem now
14:03:00 <kc5tja> procyon_: But you lose the firmament of the real-world architectures.  Even C-- is still abstract by assembly language's standards.
14:03:13 <hpaste>  SamB annotated "AT troubles" with "This seems to work..." at http://hpaste.org/879#a1
14:03:46 <SamB> I can understand why the first one didn't work...
14:04:09 <allbery_b> kc5tja: no, that just means adverbs aren't constrained to predefined combinations.  I think we're looking for things that modify adverbs
14:04:12 <SamB> I'm not sure why this one works though ;-)
14:04:17 <allbery_b> the way adverbs modify verbs
14:04:49 <procyon_> kc5tja: yes, but I think it's more applicable than learning, say basic x86 assembly (with single pipelines), and much more within the grasp of a new student than modern architectures.
14:05:19 <sjanssen> SamB: the second one works because you're saying that the m in Room m and Value m are the same.  The first solution was trying to be polymorphic wrt. that same type variable
14:05:20 <SamB> hmm.
14:05:36 <dolio> Well, words like "somewhat" and "very" are adverbs, but they modify adjectives and other adverbs.
14:05:39 <sjanssen> SamB: agreed?
14:05:42 <dolio> Rather than verbs.
14:05:50 <procyon_> adverbs can modify themselves if the u combinator is typable in your language ;)
14:06:37 <kc5tja> procyon_: I disagree.  In my experience, people who have no knowledge of how "real-world" hardware works generally don't understand or appreciate various algorithms.  When you explain the rationale to them, they just stare at you blankly.  In short, they aren't nearly as good a programmer as they could be.
14:06:50 <SamB> sjanssen: yeah.
14:06:51 <narain> dolio: those are intensifiers, which certainly qualify but aren't a very interesting category :)
14:06:56 <SamB> hmm.
14:07:00 <resiak> Hrm.  Did I see someone mentioning a fix for the "IRCRaised Data.ByteString.last: empty ByteString" thrown by @eval?
14:07:04 <kc5tja> I'm not saying that you must learn all the ins and outs of superscalar architectures, or how register selection works for x86 in particular.
14:07:21 <kc5tja> But having even a firm understanding of single-pipe, scalar, machine language coding is *invaluable*.
14:07:30 <sjanssen> resiak: yeah, it's a bug in the regex libs
14:07:47 <SamB> I suppose I don't need the typeclass to be instanced because I'm not actually doing anything to the values in it, huh?
14:07:59 <SamB> (or rather, in its types)
14:08:24 <resiak> sjanssen: Heh, so I'd need a new ghc6 package.
14:08:34 <procyon_> kc5tja: I couldn't agree more.  I think you can teach that with raw JVM, or a spineless tagless G machine though, in the abstract, and have it directly applicable to most any machine language.
14:08:59 <sjanssen> resiak: I believe you can upgrade the regex libraries independently
14:09:38 <resiak> sjanssen: I'm loathe to trample on files managed by dpkg.
14:09:47 <resiak> *shrug* I don't actually need eval, so.
14:10:20 <SamB> hmm.
14:10:34 <kc5tja> procyon_: And that's where we will just have to agree to disagree, I guess.  An abstraction of reality is not reality, and that's what I don't like.
14:10:35 <SamB> I wonder if I'm pulling from the correct repository for GHC...
14:11:13 <SamB> teach them 6502!
14:11:22 <procyon_> kc5tja: Agreed. We Disagree. :)
14:11:35 <SamB> maybe Z80 so they can crash their calculators
14:11:49 <procyon_> SamB: Rotate Register instructions rock!
14:11:51 <kc5tja> SamB: My homebrew computer uses a 65816 processor, the 16-bit superset of the 6502.  :)  And I'm using an emulator to code the firmware, but the emulator still models a real-world processor.
14:12:59 <nominolo> procyon_: can you name a nice use-case?
14:13:02 <procyon_> SamB: I used to code video games in assembly on 6502... as long strings of Data poked into memory by a for loop in basic :)
14:13:19 <procyon_> nominolo: not a one.. but they still rock ;)
14:13:42 <augustss_> rotates are cool, but not that useful :)
14:13:47 <nominolo> procyon_: heh, that's exactly what i feel too
14:14:10 <nominolo> ?seen dons
14:14:10 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 7h 48m 39s ago.
14:14:18 <nominolo> ?seen bringert
14:14:19 <lambdabot> bringert is in #haskell. I don't know when bringert last spoke.
14:14:26 <bringert> hi nominolo
14:14:29 <nominolo> hi
14:14:34 <shapr> Wow, I joined #haskel and got forwarded to #haskell, neat!
14:15:03 <procyon_> 6502, using only X, Y and the accumulator gave me an instictive understanding of the tower of hanoi problem as applied to programming.
14:15:13 <beelsebob_> o.O it's shapr
14:15:30 <nominolo> bringert: i guess i should throw in that project list now, before the final selection is picked
14:15:38 <SamB> procyon_: but... you may only keep a single value in each register!
14:15:51 <SamB> not a stack of values, with the smallest ones on top!
14:16:18 <bringert> nominolo: sounds good
14:16:25 <shapr> hiya beelsebob_
14:16:36 <glguy> ?lusers
14:16:36 <lambdabot> Maximum users seen in #haskell: 339, currently: 308 (90.9%), active: 48 (15.6%)
14:16:55 <procyon_> SamB: So it's Hanoi folds!  I guess that's foldh
14:17:02 <shapr> wow, 339
14:20:18 <stefanha> wow .hc files look like IOCCC entries!  Looks like I'm sure to win next years' competition.
14:20:41 <chessguy> shapr!
14:21:13 <shapr> chessguy!
14:21:15 <malcolmw> bringert: IIRC, last year students could propose to work on a bunch of different projects, and different proposals got ranked by merit.  why should we prevent a student from talking up their ability to do a project that might otherwise look less interesting?
14:21:31 <SamB> how come I don't seem to have a "base" package built for GHCi? is there some special build option I need to enable or something?
14:21:40 <chessguy> shapr: had my phone interview today. they were impressed enough that they want me to fly out saturday so they can "grill" me
14:22:02 <procyon_> chessguy: grats!
14:22:12 <bringert> malcolmw: right. I don't think we should prevent them, just that we should help guide them towards the projects that we find important.
14:22:36 <chessguy> it's going to be interesting. they said they'll ask me everything from OO design to math to monads to philosophy
14:22:38 <malcolmw> bringert: i can agree with that.
14:22:54 <SamB> actuall, I seem to have one but it needs symbols that GHCi isn't finding :-(
14:23:02 <shapr> chessguy: awesome!
14:23:19 <SamB> why oh why does GHCi have to use a crummy hand-built symbol table for its exports?
14:23:26 <bringert> malcolmw: there are a lot of projects on the current list, but I would consider quite few of them to be important enough to care about
14:23:41 <SamB> I have a DOS program that does better than that
14:23:47 <malcolmw> bringert: yes, the current list is mostly left-overs from last year
14:24:01 <chessguy> i'm a little nervous, but a lot excited
14:24:12 <bringert> chessguy: where are you interviewing?
14:24:22 <chessguy> www.aetion.com
14:24:28 <bringert> ah
14:24:34 * malcolmw admits he hasn't added any new project ideas yet, despite having several
14:24:40 * bringert too
14:24:55 * bringert told nominolo to do it for him
14:25:30 <procyon_> chessguy: a job doing genetic algorithms... lucky bastard ;)
14:25:32 <SamB> ghc-6.5: /home/naesten/hacking/haskell/ghc/libraries/base/HSbase.o: unknown symbol `noDuplicatezh_fast'
14:25:32 <SamB> Loading package base ... linking ... ghc-6.5: unable to load package `base'
14:25:34 * nominolo <- peon
14:25:51 <SamB> (do not ask why it goes by this name -- I know not.)
14:26:27 <chessguy> procyon_: it's not mine yet :)
14:26:36 <chessguy> and it's a lot more than just genetic algorithms
14:27:06 <procyon_> cheesguy: Here I am stuck doing philanthropic work (I shut off windows machines for a living.. Microsoft WGA ;) )
14:27:28 <chessguy> ahem. that's "chessguy"
14:27:36 * chessguy glares at mbishop 
14:28:11 <procyon_> chessguy: lol. sorry.  freudian slip?
14:28:20 <chessguy> dunno, you hungry for cheese?
14:28:35 <procyon_> mmm gouda
14:29:02 <chessguy> personally, i like cheese, but not enough to name myself after it
14:29:48 <gimboland> hi all...  could someone possibly help me with a fairly newbie-ish IO/monad question?  this is my first time on #haskell, not quite sure of the protocol :)
14:30:01 <procyon_> gimboland: just shoot
14:30:07 <gimboland> cool - ta :)
14:30:08 <chessguy> gimboland: feel free to just ask it. if you need to show us some code!
14:30:09 <chessguy> @paste
14:30:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:30:38 <gimboland> ooh, neato
14:31:09 <monochrom> haskell rocks
14:31:09 <gimboland> i probably don't need to copy/paste much code, though - i think the function types tell the story
14:31:30 <chessguy> monochrom: duh? :)
14:32:02 <gimboland> i have a function l :: FilePath -> IO [FilePath], which turns a directory path into a list of files in that directory with some property (calls getDirectoryContents and does some other processing)
14:32:35 <monochrom> oh, I just say a generic thing so as to let lambdabot know I'm here in case it has messages waiting for me. :)
14:32:41 <nominolo> bringert: i think this is what you meant with "fix sockets, http, etc.": http://hackage.haskell.org/trac/summer-of-code/ticket/30
14:32:43 <lambdabot> Title: #30 (Haskellnet) - Haskell.org Google Summer of Code - Trac
14:32:45 <nominolo> bringert: right?
14:33:01 <gimboland> i have another function r :: FilePath -> IO a, which given a path to a file, reads it, processes it, and turns it into an a (whatever that is: some algebraic type)
14:33:02 <bringert> nominolo: no, not really
14:33:14 <gimboland> basically i want to call r on every path returned from l
14:33:17 <bringert> nominolo: I meant more low-level stuff
14:33:24 <vincenz> hola bringert
14:33:45 <bringert> nominolo: Simon Marlow talked about it one one of the mailing lists a while back
14:33:49 <bringert> on
14:33:50 <malcolmw> hi lennart
14:33:58 <Saizan> gimboland: and you want to compose them to get an IO [a]?
14:34:03 <nominolo> bringert: i take a look
14:34:04 <quicksilver> gimboland: mapM r (l x)
14:34:11 <gimboland> right
14:34:14 <quicksilver> gimboland: where x is the dir you want to lis
14:34:15 <gimboland> aha
14:34:15 <quicksilver> t
14:34:22 <Saizan> ?type mapM
14:34:24 <lambdabot>     Ambiguous occurrence `mapM'
14:34:25 <gimboland> i'd discovered liftM, which obviously isn't quite what i wanted
14:34:25 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
14:34:30 <Saizan> ?type Prelude.mapM
14:34:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:34:49 <gimboland> sweet
14:35:04 <gimboland> i knew it was worth installing an IRC client for the first time in 4 years to seek your advice :)
14:35:09 <Saizan> it's more l x >>= mapM r
14:35:26 <Saizan> you know how to use >>=?
14:35:54 <gimboland> are you asking me, Saizan?
14:35:56 <Saizan> yes
14:36:33 <gimboland> yes, roughly
14:36:49 <Saizan> if not you can write do {  fs <- l dirpath; mapM r fs }
14:36:57 <chessguy> heh. is that like saying you know roughly how to construct a nuclear bomb? :)
14:37:40 <narain> don't most people know roughly how to construct a nuclear bomb?
14:37:46 <norpan> U232 ++ U232
14:37:50 <xerox> hahaha
14:37:54 <chessguy> @type do {  fs <- ?l ?dirpath; mapM ?r fs }
14:37:56 <lambdabot>     Ambiguous occurrence `mapM'
14:37:56 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
14:38:09 <chessguy> @type do {  fs <- ?l ?dirpath; Prelude.mapM ?r fs }
14:38:09 <gimboland> right...  i'd seen it in the IO_inside tutorial on the wiki
14:38:11 <lambdabot> forall t (t1 :: * -> *) a b. (?l::t -> t1 [a], ?dirpath::t, ?r::a -> t1 b, Monad t1) => t1 [b]
14:38:25 <xerox> ?remember norpan [<narain> don't most people know roughly how to construct a nuclear bomb?] <norpan> U232 ++ U232
14:38:25 <lambdabot> Done.
14:38:36 * chessguy <3 lambdabot
14:38:45 <gimboland> at present i'd say "tinkering with a nuclear bomb" is approximately where i am with monads...
14:38:48 <xerox> chessguy: :O what's '?' ?
14:38:57 <chessguy> xerox, implicit tyep
14:39:00 <chessguy> *type
14:39:06 <chessguy> err
14:39:10 <xerox> Ah.
14:39:13 <xerox> Implicit parameter.
14:39:14 <chessguy> implicit variable maybe? i forget what it
14:39:18 <chessguy> yeah, that
14:39:21 <xerox> Now I recall.
14:39:32 <xerox> One don't see them often :)
14:39:33 <norpan> I NEED TO SLEEP
14:39:46 <norpan> oops
14:39:46 <norpan> i had caps lock on
14:39:46 <norpan> to write U232
14:39:56 <chessguy> ?remember gimboland at present i'd say "tinkering with a nuclear bomb" is approximately where i am with monads...
14:39:56 <lambdabot> Done.
14:40:34 <sjanssen> that reminds me of the launch_missiles example in the STM paper
14:40:45 <chessguy> ?quote missile
14:40:46 <lambdabot> lennart says: Should Haskell also provide unrestricted side effects, setjmp/longjmp, missile launching functions, etc?  After all, people who don't want to use them can just avoid them. :)
14:41:07 <norpan> wait, it's U235, hmmm, that's why roughly was extra funny
14:41:14 <gimboland> chessguy: am i going to show up on some haskell version of bash.org now ?
14:41:19 <norpan> anyway, time to sleep
14:41:22 <vincenz> @quote denotational
14:41:22 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
14:41:31 <chessguy> gimboland: you'll just show up like this
14:41:33 <gimboland> aha
14:41:33 <chessguy> @quote gimboland
14:41:34 <lambdabot> gimboland says: at present i'd say "tinkering with a nuclear bomb" is approximately where i am with monads...
14:41:35 <monochrom> @quote detonational
14:41:36 <lambdabot> No quotes match. I feel much better now.
14:41:40 <gimboland> grand
14:41:45 <norpan> haha, detonational
14:41:53 <sjanssen> @quote missile
14:41:53 <lambdabot> lennart says: Should Haskell also provide unrestricted side effects, setjmp/longjmp, missile launching functions, etc?  After all, people who don't want to use them can just avoid them. :)
14:42:39 <norpan> what's the detonational semantics of a nuclear bomb
14:42:52 * Zeroth404 's knotes have mysteriously been erased
14:42:53 <SamB> norpan: "I hate you and your little dog, too!"
14:42:54 <Zeroth404> :-(
14:42:56 <Zeroth404> Cale: you ready?
14:42:58 <Zeroth404> TO DIE?
14:43:00 <Zeroth404> norpan: boom.
14:43:01 <Cale> Zeroth404: sure
14:43:13 <monochrom> U237 + n --> stuff + 3n + photons
14:43:21 <vincenz> 238
14:43:24 <nominolo> bringert: i can't find anything like that
14:43:28 <monochrom> yeah 238
14:43:38 <Cale>  24.176.12.252 ?
14:43:44 <nominolo> bringert: at least not recently
14:43:46 <Zeroth404> hold, gotta port forward
14:43:46 <norpan> u-238 is the stablest one no?
14:43:47 <vincenz> 13kg  in a nice ball
14:44:09 <monochrom> I forgot :)
14:44:16 <vincenz> or add some plutonium
14:44:51 <Zeroth404> Cale: that is correct
14:44:57 <Zeroth404> Cale: gimme a few seconds to start a server
14:45:07 <Cale> 50ms ping between us
14:45:12 <Zeroth404> thats not bad
14:45:16 <Zeroth404> especially with unlagged
14:45:22 <Zeroth404> it'll be like LAN'ing
14:45:44 <Zeroth404> starting it, gimme a few seconds
14:45:46 <bringert> nominolo: it may have been in a thread about something else. anyway, it's probably not a great SoC project anyway.
14:46:01 <stefanha> Double literals seem to be constructed by ghc: "(GHC.Real.:% @ GHC.Num.Integer (GHC.Num.S# 3) (GHC.Num.S# 1))" -ddump-simpl.  Can I expect this turn into an unboxed constant value sometime before a binary is spit out?
14:46:04 <nominolo> k
14:46:41 <dibblego> when trying to configure lamabdabot, I get a "cannot satisfy dependency fps>=0.7" even though I just build and installed GHC 6.6 + extralibs - doesn't FPS come with 6.6?
14:46:49 <stefanha> Looking at the .hc suggests it doesn't, but I don't know how to read Core or .hc.
14:46:56 <xerox> Zeroth404: are you killing Cale?
14:47:08 <Cale> xerox: We're going to have a q3 game soon
14:47:20 <Cale> So, we'll see :)
14:47:21 <procyon_> U238 + neutron source (raduim/iodine + gold foil) -> U239 -> Np239 -> Pt239
14:47:41 <xerox> Cale: haha, have fun (-:
14:48:17 <chessguy> q3?
14:48:26 <xerox> Quake III.
14:48:29 <Cale> Quake 3 Arena
14:48:42 <chessguy> oh nice
14:48:58 <vincenz> procyon_: no need for neutron source, 13kg in a nice tight sphere will do
14:48:59 <user___> Cale: joining?
14:49:00 <vincenz> 13.4 kg
14:49:14 <Zerothh> Cale: ?
14:49:16 <Cale> uh, trying to, not getting a response
14:49:18 <procyon_> Americium + gold foil works too.  Have some hafnium to slow the neutrons, just to be sure, and some germanium rods to controll the fission.
14:49:23 <chessguy> ?losers
14:49:23 <vincenz> the U238 then acts as neutron source for the plutonium
14:49:24 <lambdabot> Maximum users seen in #haskell: 339, currently: 309 (91.2%), active: 52 (16.8%)
14:49:42 <narain> procyon_: don't control the fission! we want a kaboom!
14:49:43 <Zerothh> Cale: hold
14:49:55 <Cale> 27960?
14:50:06 <Zeroth404> standard port
14:50:13 <Zeroth404> lemem check iptables
14:50:14 <Cale> yeah
14:50:27 <procyon_> vincenz: But isn't U238 too stable to be a good neutron source?  It would seem the U->Pt reaction would take far too long that way.  I don't want to wait 10 years for my city destruction!
14:50:37 <vincenz> procyon_: 13.4kg
14:50:39 <Zeroth404> Cale: try to ssh to me
14:50:44 <Zeroth404> Cale: just to see if it responds
14:50:57 <vincenz> oh wait, that's 235
14:50:59 <Cale> ssh_exchange_identification: Connection closed by remote host
14:51:44 <vincenz> it's rather funny that 235=enriched, and 238=depleted
14:51:50 <vincenz> even though 238 has more neutrons
14:51:50 <procyon_> vincenz: right... and getting your hands on 14Kg of U235 is a royal PITA.  238 is everywhere though.. add a couple smoke detectoras and you have weapins grade plutonuium in 6 months to a year.
14:52:10 <qwr> http://en.wikipedia.org/wiki/Nuclear_weapon_design
14:52:36 <vincenz> procyon_: just enrich it :)
14:52:45 <vincenz> procyon_: uranium is -easy- to get, the hard part is plutonium
14:52:49 <Zeroth404> Cale: its my router, DMZ isn't working (I use dmz because its port forward features dont work, heh)
14:53:11 * vincenz wishes he could get ssh and irssi on his router
14:53:15 <Cale> Should I try creating a server then?
14:53:29 <Zeroth404> yes, but you gotta download unlagged mod
14:53:40 <vincenz> http://en.wikipedia.org/wiki/Image:HEUranium.jpg
14:53:40 <vincenz> lol
14:53:42 <procyon_> vincenz: Right.  But depleted uranium + 1 neutron is U239, which is highly unstable, and decays to neptunium 239, which decays to Plutonium 239.. which is what you want.
14:53:43 <vincenz> that must be healtyh
14:53:51 <Zeroth404> if all else fails I'll bypass my router completely
14:54:00 <Zeroth404> Cale: I can DCC it to you if you cant find it
14:54:02 <vincenz> procyon_: interesting
14:54:23 <Cale> That might be easier -- then again, if port forwarding isn't working :)
14:54:27 <Cale> But try :)
14:54:33 <Zeroth404> DCC or bypass?
14:54:40 <Cale> DCC
14:54:49 * xerox frags Cale
14:55:15 <Cale> there we go :)
14:55:18 <Zeroth404> yay
14:55:21 <qwr> Zeroth404: you routed udp?
14:55:22 <vincenz> procyon_: it'd be cool if they got to that remote island... I forgot the name of the atom, the one that's stable again
14:55:26 <procyon_> vincenz: Well, for certain values of "what you want" anyway.  Having a chunk of Pt239 lying around isn't really what I want, for health reasons
14:55:28 <Zeroth404> qwr:  yep
14:55:35 <Zeroth404> qwr: its my suckass router
14:55:37 <vincenz> procyon_: I know places where they havei t
14:55:46 <Zeroth404> qwr: I'm totally DMZ'd (supposed to be, but I'm not)
14:55:54 <monochrom> Interesting. If I define data T = C !Int, then x = C undefined is still allowed. The strictness kicks in only when I seq x.
14:56:31 <Zeroth404> Cale: preferably campgrounds or temple of retribution
14:56:49 <procyon_> vincenz: You can get U238 at any chemistry store.  You can get a neutron source to enrich with from smoke detectors.
14:57:04 <vincenz> procyon_: hmm, well the plutonium they have is hard to get
14:57:07 <sjanssen> monochrom: x = C undefined is the same as x = undefined
14:57:27 <procyon_> vincenz: and gold foil: safeway.  Hafnium and Germanium are trivial.
14:57:37 <Zeroth404> Cale: 74.114.58.144 ?
14:57:56 <Zeroth404> Verison?
14:57:58 <Cale> vx.hn.org
14:58:01 <Zeroth404> heh
14:58:08 <Cale> er, no
14:58:14 <Cale> cale.yi.org
14:58:19 <Cale> that was my old host :)
14:58:20 <Zeroth404> I just remember a subnet of 74. being under verison
14:58:36 <Zeroth404> ah
14:58:39 <Zeroth404> ready?
14:58:58 <Cale> q3tourney5 ?
14:59:08 <Zeroth404> not sure which one that is, but sure
14:59:13 <Zeroth404> as long as its not CTF :-p
14:59:35 <fax> hik
14:59:47 <Cale> okay, should be ready (?)
14:59:50 <vincenz> procyon_: elemet 218 :)
14:59:50 <Zeroth404> fax: what u call me
14:59:56 <fax> hrehe
14:59:56 <Zeroth404> Cale: trying
15:00:08 <vincenz> Or for that matter, even 168
15:00:49 <procyon_> vincenz: Element, or isotope?
15:01:04 <vincenz> element
15:01:05 <fax> I have a parsec specific question,  I want have variables in a Map like {x=3, q=7} so that expressions can involve variables which works great
15:01:36 <fax> but I was wondering if its stupid to have changed my return type of the parser to a tuple (Float, Map) so that I can get altered state
15:01:45 <procyon_> vincenz: AFAIK 121 or so is the biggest ever made... We haven't hit the next stable electron shell yet, have we?
15:01:46 <fax> if the it parses somthing like "x := 3+q" for example
15:01:54 <vincenz> procyon_: No, we haven't
15:01:58 <vincenz> procyon_: and it's a steep cliff
15:02:01 <vincenz> http://en.wikipedia.org/wiki/Periodic_table_%28extended%29
15:03:54 <procyon_> vincenz: hehe.  I think with 218 you wouldn't need a nuclear reaction... The ionic should be more than enough for anyone :)
15:04:28 <procyon_> vincenz: er.. 217
15:04:36 <fax> so is that the normal way to have a parser in Parsec which you can use multiple times with an updated state?
15:04:56 <vincenz> procyon_: how so?
15:05:14 <hpaste>  conal pasted "Control.Compose" at http://hpaste.org/880
15:05:16 <bd_> fax: Personally I'd parse things like x := 3+q into a structure like Assign "x" (Add (Const 3) (Var "q")), then handle all the state stuff after parsing
15:05:32 <xerox> fax like |many (char '-')| which parses string composed by "----...---" ?
15:06:30 <procyon_> vincenz: er... 219 even... 219 exposed to any hydrogen source would be one of the most potent chemical reactions possible.
15:06:41 <vincenz> ah :)
15:07:10 <vincenz> or even 119 which exists
15:07:12 <hpaste>  conal annotated "Control.Compose" with "comments please" at http://hpaste.org/880#a1
15:07:17 <fax> hmmmm
15:07:23 <fax> xerox: no
15:07:42 <fax> bd_: I dont know, that seems a lot harder but maybe its better im not sure
15:07:49 <procyon_> vincenz: a little 119 and a bathtub would be one hell of a party ;)
15:07:54 <vincenz> procyon_: or even air :)
15:08:20 <bd_> fax: It's more flexible in my opinion. You can do it directly in parsec I guess if you want.
15:10:04 <sorear> hello.
15:10:08 <vincenz> heh
15:10:13 <vincenz> Astatine is the rarest naturally-occurring element, with the total amount in Earth's crust estimated to be less than 1 oz (28 g) at any given time; this amounts to less than one teaspoon of the element.
15:10:14 <xerox> hiya sorear.
15:10:17 <vincenz> How do they know this???
15:10:43 <sorear> steady state assumptions I imagine
15:10:49 <Botje> someone accidentally put it in their tea, obviously.
15:10:52 <vincenz> 28h...
15:10:55 <vincenz> erm g even
15:11:10 <sorear> at equilibrium atoms of At = 1/k * atoms of U
15:11:11 <vincenz> We don't even know what's going on in the crust a few kilometers down
15:11:19 <sorear> and U can be measured(we think)
15:11:29 <sorear> and k can be calculated
15:11:35 <vincenz> Funky
15:11:44 <procyon_> vincenz: interesting... at 139, the speed of the electrons in the s shell exceed C, making weirdness happen.
15:14:43 <procyon_> vincenz: and 118 is the first semiconductor gas.  DAMN YOU FOR SHOWING ME THAT CHART!  I am now lost in amazing, fascinating, useless trivia!
15:14:56 <narain> procyon_: the speed of the electrons exceeds c?
15:15:14 <vincenz> narain: c being defined in this conversation as 1 m/s
15:16:12 <narain> when did that happen? i didn't see any memo!
15:16:44 <procyon_> narain: yes. http://en.wikipedia.org/wiki/Untriseptium. Feynman though 137 would be it, but adjusted for relativity, 139 is the first element in which the electrons must go faster than the speed of light in their orbitals.  I have no idea what that means, but'I wan it.
15:16:45 <sendo> what does a Parse error in pattern mean?
15:18:11 <QtPlatypus> You wrote the pattern part of your funtion definition wrong somehow.
15:18:36 <sendo> performAction::State -> Action -> State
15:18:44 <sendo> performAction [] (Action _ _ []) = []
15:19:06 <sendo> performAction s:ss (Action head prec (e:ff)) | the recursive stuff
15:19:28 <malcolmw> sendo: you need parens around (s:ss)
15:19:38 <sendo> cheers
15:20:02 <narain> procyon_: i'd have to see that in an actual physics text to believe it
15:20:26 <narain> or some other authoritative reference
15:21:28 <SamB> so do these elements go backwards in time or something?
15:23:31 <SamB> hmm.
15:23:40 <SamB> Latest GHC has a lame :b...
15:23:48 <SamB> where is the code for :b, does anyone know?
15:24:23 * SamB tries compiler/ghci/InteractiveUI.h
15:25:25 <shapr> Shazam!
15:25:59 <narain> i can't find anything online to support the v_e > c hypothesis
15:26:04 <narain> that isn't derived from wikipedia
15:26:40 <narain> and wikipedia seems to take it from the fotuva.org site
15:26:54 <narain> which credits it to a "Dr. Bill Riemers"
15:27:28 <narain> i'm filing this as unsubstantiated
15:28:20 <sendo> how do i do to remove from list a all ocurrences of b?
15:28:24 <sendo> a\\b?
15:28:31 <shapr> terve kaiki!
15:28:37 <mauke> filter (b /=) a
15:28:47 <narain> :t (\\)
15:28:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:29:07 <gimboland> thanks for the mapM help, guys - working great now
15:29:14 <sendo> thx
15:29:22 <gimboland> time to call it a night, but i'll definitely be back :)
15:29:30 <gimboland> cheers
15:29:30 <fax> > (\\) [1..10] [3..5]
15:29:32 <lambdabot>  [1,2,6,7,8,9,10]
15:29:45 <SamB> oh. It is marked as "TODO".
15:30:08 <SamB> filterOutChildren names = filter (not . parent_is_there) names
15:30:08 <SamB>  where parent_is_there n
15:30:08 <SamB> --	 | Just p <- GHC.nameParent_maybe n = p `elem` names
15:30:08 <SamB> -- ToDo!!
15:30:08 <SamB> 	 | otherwise		           = False
15:30:17 <procyon_> narain: It would probably just mean that elements above 138 are guaranteed to be unstable and that 126 is the highest stable element... nothing too earth shattering.
15:30:18 <fax> > let x [1..10] in (\\) x tail x
15:30:18 <lambdabot>  Parse error
15:30:24 <fax> > let x [1..10] in (\\) x (tail x)
15:30:24 <lambdabot>  Parse error
15:30:28 <fax> :/
15:30:33 <sendo> i get parse error
15:30:35 <sendo> too
15:30:36 <sorear> =!
15:30:37 <fax> > let x = [1..10] in (\\) x (tail x)
15:30:39 <lambdabot>  [1]
15:30:49 <sorear> > ap (\\) tail [1..10]
15:30:51 <lambdabot>  [1]
15:30:55 <narain> procyon_: particles moving at greater than the speed of light isn't earthshattering?
15:30:57 <fax> :O
15:30:58 <sorear> muahahaha.
15:31:00 <sendo> > [1,2,3,4,5]\\[1]
15:31:00 <sendo> <interactive>:1:11: Not in scope: `\\'
15:31:01 <lambdabot>  [2,3,4,5]
15:31:20 <narain> ?index (\\)
15:31:21 <lambdabot> bzzt
15:31:27 <sorear> sendo: Data.List!
15:31:32 <sorear> sendo: or List
15:31:43 <narain> ?index map
15:31:44 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
15:31:54 <narain> why didn't  ?index (\\)  work?
15:32:03 <SamB> narain: maybe that means that, in a stable atom of that element, the electrons would need to move that fast?
15:32:09 <shapr> glguy: I may have to kill hpaste for a bit, I'm trying to upgrade kakapo and running out of resources.
15:32:33 <fax> > ap (+1) 1 2
15:32:34 <lambdabot>   add an instance declaration for (Num (a -> b))
15:32:41 <procyon_> narain: I doubt they would move at faster than C.  More likely, they would require infinite energy to attain an S orbital, and that being unatainable, they would simply cease to have an S orbital, rendering them unstable.
15:32:57 <fax> > ap (+1) (*2) 2
15:32:58 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
15:32:58 <lambdabot>     Probabl...
15:33:17 <SamB> fax: sorear might know how to do that ;-)
15:33:24 <mauke> > ap (+) (*2) 2
15:33:26 <lambdabot>  6
15:33:28 * vincenz is going nuts with all the fizzbuzz crap
15:34:57 <resiak> lambdabot's COMMENTARY talks about running plugins in ghci rather than rebuilding everything.  However, ghci barfs on cpp directives.  Presumably there's some handy way around this... ?
15:34:58 <narain> SamB, procyon_: well all this doesn't sound like anything more than throwing guesses in the air, no offense mean but do we have any authoritative source?
15:35:16 <narain> *meant
15:35:21 <shapr> resiak: You could build lambdabot and then ghci would load the prebuilt .o files, I think.
15:35:25 <SamB> narain: we could write a letter to God if it would make you happy
15:35:29 <shapr> resiak: Or maybe :set -cpp ?
15:35:32 <procyon_> narain: of course not.  Just a passing curiosity.
15:35:35 <narain> SamB: :)
15:35:39 <SamB> I can't guarentee he would write back, though
15:35:46 <narain> is there a theoretical physicist in the house?
15:35:50 <sorear> resiak: sh ghci!
15:35:51 <narain> david roundy?
15:35:59 <SamB> (or that the incompetents at the USPS would manage to deliver it in the first place)
15:36:13 <sorear> narain: nah, droundy is "never" here
15:36:22 <procyon_> God told me that if I didn't stop asking him such questions he would revoke my state monad.
15:36:52 <sorear> @remember procyon_ God told me that if I didn't stop asking him such questions he would revoke my state monad.
15:36:52 <lambdabot> Done.
15:37:23 <narain> don't you want to be pure? referentially transparent even?
15:37:47 <procyon_> Not yet.
15:39:23 <narain> i wish i knew relativistic quantum mechanics
15:39:45 <sorear> i wish i know classical qm
15:39:52 <narain> that too
15:40:31 <SamB> narain: is there such a thing?
15:40:41 <sorear> certainly
15:40:43 <SamB> I thought they couldn't figure out how to integrate the two...
15:40:56 <procyon_> i still have problems with constructive predicate logics... qm can wait :)
15:41:00 <sorear> SamB: QM + GR = can of worms
15:41:07 <narain> SamB: i think it was general relativity and QM they couldn't integrate
15:41:08 <sorear> SamB: QM + SR = just fine
15:41:12 <SamB> ah
15:41:13 <SamB> okay
15:41:18 <narain> uh yeah what sorear said
15:41:23 <SamB> remind me what General Relativity is?
15:41:30 <sorear> curved space
15:41:35 <SamB> ah
15:41:36 <narain> relativity + gravitation = curved spacetime
15:41:42 <shapr> It's the theory that relatives are generally a pain in the .. oh, never mind.
15:42:19 <procyon_> you cannot sleep with a simlpe relative in most states, but a more general relative is legal, but frowned upon.
15:42:47 <SamB> procyon_: there are not rules against sleeping with them...
15:42:48 <procyon_> ^^ my theory of general relativity.
15:42:54 * sorear parsed simlpe as sigfpe, and was very confused
15:43:01 <procyon_> lol
15:47:52 <shapr> Ya know, I just can't stand to have php installed on my server.
15:48:28 <procyon_> shapr: I keep it around for drupal... because I can't stand writing my own websites anymore.
15:49:25 <shapr> When it comes to having PHP installed, I'd rather write my own websites.
15:49:34 <shapr> In Haskell, of course..
15:49:39 <sorear> or just use hope :)
15:49:51 <sorear>  /happs in the more general case
15:49:55 <shapr> Well, yes. Though I prefer HAppS lately.
15:50:55 <procyon_> Unfortunately, there is no good CRM in Haskell, and I dislike web programming so much that I only use CRM's now days, and profit from the sweat of other masochists.
15:51:18 <shapr> Well, tell me about the features of a good CRM, and there may be one based on HAppS.
15:53:11 <procyon_> shapr: 1) Simple install.  2) no coding required. 3) proffessional looking dynamic site out of the box with a variety of themes available.
15:53:39 <procyon_> shapr: 4) Threaded forums. 5) calendar functionality. 6) Blogging.
15:54:44 <procyon_> shapr: 7) Multiple sites off single install.  That's off the top of my head.
15:55:32 <chessguy> ?vera CRM
15:55:34 <lambdabot> *** "crm" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
15:55:35 <lambdabot> CRM
15:55:35 <lambdabot>      Customer Relationship Management
15:55:35 <lambdabot>  
15:55:44 <chessguy> i'm guessing that's wrong
15:55:48 <procyon_> lol
15:55:52 <chessguy> Content ____ Management, i assume
15:56:00 <procyon_> chessguy: Content Resource Management.
15:56:30 <procyon_> Basically, I want to just install, and have a full corporate website that's as easy to manage as a livejournal.
15:56:30 <chessguy> what is a content resource
15:56:41 <procyon_> chessguy: A fancy term for file ;)
15:57:06 <kscaldef> procyon_: that sounds like  CMS, not CRM
15:57:40 <procyon_> kscaldef: sounds like as good an acronym as any ;)
15:58:16 <kscaldef> what I'm saying is that I agree with lambdabot about the meaning of CRM
15:59:04 <procyon_> The 2 big ones I know of are Joombla and Drupal.. there's a few others.  Drupal has the most features and biggest community adding features.. the biggest downside is that it's in PHP, and so comes preinstalled with PHP flakey goodness.
15:59:05 <kscaldef> when I was building such software as you describe (which I stopped doing 5 years ago) we called it CMS
15:59:11 <kscaldef> Content Management System
15:59:24 <procyon_> I'm willing to accept CMS :)
16:00:07 <procyon_> Or WWS (website with sprinkles!)
16:00:55 <shapr> Drupal sources could benefit from a Haskell port. They use a lot of higher order functions, and that's a painful thing to do in PHP.
16:01:34 <procyon_> kscaldef: I've done enough programming of that type for one lifetime and am now happy to have an army of PHP monkeys do it for me.
16:01:51 <kscaldef>  also, sometime, PWS (psychic web server)
16:02:06 <chessguy> fly PHP monkeys, fly!
16:02:13 <procyon_> shapr: What couldn't benefit from a haskell port ;)
16:02:26 <kscaldef> when the client/customer expects it to do exactly what they want out of the box, with no configuration or customization
16:02:38 <kscaldef> and to magically change when they change their mind
16:02:43 <procyon_> chessguy: yeah, and PHP monkeys might fly out my butt...
16:02:44 <shapr> kscaldef: Yeah, I hate that.
16:03:06 <shapr> kscaldef: And then my clients say "It's a tiny little change, why should it take you four weeks and this huge amount of money to do it?"
16:03:42 <cjeris> shapr: that's when you pop a tear gas grenade, rush outside the meeting room, and lock the door.
16:03:52 <shapr> and I say "Plone was specifically designed to NOT do this thing that you have requested. Adding this feature is nothing short of a miracle." and they say "Doesn't look hard to me."
16:04:01 <procyon_> hence why I use drupal.  Somewhere, someone already had a client that wanted that stupid change, and there's a module for it somewhere I can just download.
16:04:45 <shapr> I actually had one of my clients decide not to pay for three months of work because they didn't believe I was doing anything difficult.
16:04:53 <procyon_> The only thing I ever had to change in a drupal install was a couple minor css tweaks.
16:05:26 <cjeris> shapr: ?!
16:06:00 <shapr> cjeris: I learned an important lesson from that.
16:06:12 <procyon_> shapr: Ohh! don't forget 8) ACL-like permission system for user accounts.
16:06:27 <shapr> Clients are not paying me to deliver business value. They're paying me to deliver to them the belief that they are getting their money's worth.
16:06:56 <shapr> Weird as that may sound, that realization has made my client relations much easier.
16:07:08 <cjeris> were you able to recover from them?  that's horrible.
16:07:29 <kscaldef> sigh... that encapulates almost everything that's wrong with the consulting business
16:07:42 <shapr> It does not matter how much you help a client if they do not understand what you have done and how it helps them.
16:07:42 <dibblego> shapr, I could have told you that :)
16:07:48 <shapr> dibblego: Wish I'd asked :-)
16:07:48 <kscaldef> (not a criticism of you in any way, mind you)
16:08:48 <shapr> cjeris: I lost somewhere between five and ten thousand dollars of unpaid work in that fiasco.
16:08:58 <shapr> Maybe more.
16:09:15 <procyon_> Reminds me of astory I heard about someone who always embedded "calculate the nth digit of pi" in his code.  Whenever the client asked him to do something difficult, he could do it, AND reduce N.. hence letting the client feel they got their money's worth from "performance upgrades"
16:09:52 <shapr> heh, scary.
16:10:25 <MarcWebe2> Whats going wrong when getting  lexical error in string/character literal (UTF-8 decoding error) ?
16:10:38 <smack_vaio> "Try it: irc.freenode.net #haskell! Its full of helpful, smart people. I have never seen it with less than 300 people in it."
16:10:59 <dibblego> ...says the 300th person before leaving
16:11:02 <procyon_> Client: That doesn't seem so hard...  programmer: Yes, but I did that AND it runs 30% faster!  Client: ooh! in that case <writes check>
16:11:03 <smack_vaio> :-)
16:13:04 <shapr> For my previous gig, I added so many band-aids that even small changes could cost a huge amount of time.
16:13:24 <shapr> I kept telling them that a deep solution would cost them less in the future, but they wanted the cheapest solution that could be done right now.
16:13:37 <shapr> That sort of thing is frustrating.
16:13:40 <dibblego> sounds like IBM
16:13:53 <kscaldef> I have learned the hard way that sometimes it's best to lie
16:14:08 <shapr> I have considered stopping offering the cheap band-aid solution, and offering only the correct long term solution.
16:14:12 <allbery_b> <MarcWebe2> Whats going wrong when getting  lexical error in string/character literal (UTF-8 decoding error) ?
16:14:15 <kscaldef> but, that only works if you can progressively works your way out of the hole
16:14:16 <mbishop> kscaldef: so....it's NOT best to lie?
16:14:16 <shapr> kscaldef: You mean like what I just said?
16:14:17 <mbishop> :P
16:14:25 <shapr> MarcWebe2: Can you show us the code?
16:14:30 * mbishop pokes shapr 
16:14:33 <dibblego> shapr, that's what our company does - we simply refuse the work if it is like that
16:14:33 <allbery_b> file was edited in a non-utf8-aware editor (say, iso8859/1, which tends to make a hash of utf8)?
16:14:39 * chessguy kicks mbishop in the shin
16:14:50 * shapr pokes mbishop 
16:15:23 <shapr> allbery_b: That sounds reasonable.
16:15:25 * cjeris smacks chessguy in the face with a cream pie
16:15:48 <shapr> MarcWebe2: What code gives you that error?
16:15:55 <kscaldef> dibblego: that's actually a nice luxury of being a contractor.  Regular employees can't usually rebel when the business types are being stupid
16:16:27 <dibblego> kscaldef, I recall my days at IBM - oh wait *enters nightmarish state*
16:17:10 <shapr> Yeah, but contractors can only rebel if they have somewhere else to go, or if they're willing to starve for awhile.
16:17:16 <sorear> MarcWebe2: use a real character set, like UTF8 or it's universally sufficient subset ASCII
16:17:17 <MarcWebe2> shapr: It has been this character &sect; in a string..
16:17:34 <zbrown> hmmm
16:17:47 * zbrown thinks he has provided haskell with a list comprehension that it won't be able to solve
16:17:51 <shapr> Consulting is either too much work or not enough money. Or you could say it's either plenty of money or plenty of vacation.
16:17:52 <zbrown> at least not on this hardware lol
16:18:11 <shapr> zbrown: Are you the Zac from Tuscaloosa?
16:18:17 <procyon_> shapr: I've never had a problem finding somewhere else to go.. contract or perm.  Of course, I'm in Seattle, where there are probably 3 times as many programming positions as programmers...
16:18:26 <zbrown> shapr: Nope, I'm the Zac from Arlington :)
16:18:31 <kscaldef> good contractors usually have more work lined up at any time
16:18:31 <shapr> Ah, I miss Seattle. I used to live in First Hill.
16:18:46 <zbrown> shapr: mmm arlington texas that is ;)
16:18:50 <shapr> zbrown: Ah, ok. I know a Zac Brown doing heavy duty asm here in Alabama.
16:18:55 <kscaldef> most perm employees don't have a second job just waiting most of the time
16:18:57 <procyon_> shapr: East lake union shore here.
16:19:06 <zbrown>  [(a,b,c,d,x) | x<-[-1000.0..1000.0], a<-[-1000.0..1000.0], b<-[-1000.0..1000.0], c<-[-1000.0..1000.0], d<-[-1000.0..1000.0], (1.0 + x) == ((x^2+4.0)*(a*x+b) + (x^2+4.0)^2 * (c*x + d))] <--- thats eating my computer's life away
16:19:10 <zbrown> lol
16:19:12 <procyon_> shapr: repr'sent'n
16:19:27 <zbrown> shapr: interesting, im currently in Miami :). College and whatnot
16:19:49 <shapr> zbrown: Oh, you should come to the Southeast FP gathering we keep threatening to have.
16:19:55 <narain> zbrown: not to mention you're doing equality comparison between floats??
16:20:08 <zbrown> narain: well there's a possiblity the answers will be fractional
16:20:09 <shapr> It'll probably be in either Atlanta or Tampa.
16:20:17 <Alpenmilchschoko>  :)
16:20:22 <zbrown> shapr: if its in tampa i might can make it, though not until this summer when i have myh car
16:20:25 <shapr> Hiya Alpenmilchschoko
16:20:25 <narain> @go what every programmer should know about floating point
16:20:27 <lambdabot> http://docs.sun.com/source/806-3568/ncg_goldberg.html
16:20:28 <lambdabot> Title: What Every Computer Scientist Should Know About Floating-Point Arithmetic
16:20:35 <Alpenmilchschoko> hi, i need commercial support for Haskell (GHC), any ideas ?
16:20:42 <narain> equality between floats is not reliable, zbrown
16:20:51 <shapr> Alpenmilchschoko: Commercial support? Can you give more detail?
16:21:35 <narain> it doesn't look like your formula involves fractional numbers anywhere
16:21:35 <zbrown> narain: heh i know, im just trying to punish my hardware more than anything
16:22:02 <zbrown> narain: ive got another one running only ints on a diff box that will compute it
16:22:14 <narain> well in that case... never mind everything i said :P
16:22:15 <procyon_> zbrown: what did your hardware ever do to you?
16:22:17 <resiak> sorear: huh, why is `sh ghci` different to `ghci`?
16:22:34 <Alpenmilchschoko> Contractual guarantees for the runtime system behaviour
16:22:38 <zbrown> procyon_: mmm i dunno but it seemed fun at the time lol
16:23:05 <shapr> Alpenmilchschoko: Guarantees for what sort of behaviour?
16:23:05 <narain> oh it's all fun and games until someone loses a significant digit
16:23:22 <shapr> Time/space behaviour of non-strict evaluation is an exciting subject.
16:23:59 <edwinb> I like your choice of adjective...
16:24:25 <zbrown> narain: yes indeed
16:24:38 <shapr> edwinb: Well, I get excited about it in a good way. Most people get excited in a bad way.
16:24:56 <Alpenmilchschoko> shapr: well, i cannot invest in a runtime environment without some kind of ...assurance, that the documented libraries will work properly
16:25:02 <zbrown> procyon_: wait til you hear what i do with the new cluster they're building in one of the applied math labs i work in :-D
16:25:16 <sjanssen> Alpenmilchschoko: I haven't heard of any companies that offer such an agreement
16:25:22 <shapr> Alpenmilchschoko: Ok, what's your definition of assurance and properly there?
16:25:25 <edwinb> shapr: I like 'exciting' meaning "nobody knows how to do it but it'd be fun if they did"
16:25:28 <zbrown> i havent decided what havok i will wreak, but it'll be fun
16:25:30 <procyon_> zbrown: next call the Ackermann function with Graham's number ;)
16:25:36 <zbrown> procyon_: lol
16:25:36 <shapr> edwinb: Yeah, I think that's the most accurate way to put it.
16:25:48 <narain> procyon_: haha
16:26:01 <kscaldef> what if the libraries are just delivered without documentation ;-)
16:26:31 <shapr> edwinb: Actually, I'm convinced that most problems with non-strict code are cultural, meaning that most people just have no idea how laziness works. I rarely have any difficulties myself.
16:26:53 <shapr> C-style strictness is nearly part of the subconscious understanding programmers have of the world around us.
16:27:17 <shapr> Continuations and coroutines are difficult for the same reason, imho.
16:27:19 <edwinb> ah, I'm thinking about formal cost models for accurate bounds on stack/heap
16:27:20 <Alpenmilchschoko> shapr: insurace, money..stuff like that
16:27:20 <kscaldef> Alpenmilchschoko: I'm curious to know, what languages have an implementation with such a guarantee?
16:27:42 <edwinb> well, okay, I'm not thinking about it myself, but that's what I'd mean by time/space behaviour
16:27:57 <shapr> edwinb: Have you read Okasaki's book? It has some neat stuff with the banker's and physicist's approaches to amortization.
16:27:59 <kscaldef> I'm not sure I've personally encountered such a thing
16:28:11 <sjanssen> can you get such a guarantee for, say, Microsoft's C# compiler or .NET runtime?
16:28:16 <sorear> yay!
16:28:27 <edwinb> shapr: yeah, Okasaki's book is lovely.
16:28:28 <kscaldef> I'm pretty sure Sun doesn't for Java
16:28:36 * sorear has fixed MathematicalOrc
16:28:43 <dibblego> Sun makes an explicit disclaimer that it moght not work
16:28:46 <shapr> I think all programming languages are pretty much caveat emptor.
16:28:48 <dibblego> *might
16:28:51 * sorear curses the proximity of j and k
16:29:07 <narain> shapr: i think time/space behaviour of a haskell program can be hard to analyze
16:29:09 <shapr> sorear: Hey, I like stack based postfix languages.
16:29:10 <kscaldef> I think pretty much all software is caveat emptor
16:29:17 <narain> because it's nonlocal
16:29:28 <sorear> shapr: not what I meant :)
16:29:35 <shapr> sorear: I know, just had to make that joke :-)
16:29:37 <Alpenmilchschoko> ksandstr: IBM C, C++, Fujitsu COBOL, AcuCorp COBOL
16:29:44 <procyon_> Alpenmilchschoko: I'm not aware of any compilers/libraries/interpreters with such a backing.
16:30:04 <shapr> narain: I think it's easier than analyzing bugs in languages with mutable values.
16:30:14 <sorear> narain: it's very easy to analyze, just not a priori.
16:30:19 <narain> shapr: absolutely true, but that's not my point
16:30:26 <sorear> narain: -prof
16:30:27 <procyon_> Alpenmilchschoko: What C++?  Certainly not Microsoft's or GCC.
16:30:49 <procyon_> or Intel's
16:31:15 <narain> all i meant was that in a strict language, you call a function, and you know a priori how much time and space it will take
16:31:16 <shapr> narain: I think there are only a few important principles to keep in mind with non-strict eval.
16:31:17 <Alpenmilchschoko> procyon_: well we have a contract with IBM for the C++ compilers
16:31:41 <narain> i'm only talking about traditional computational complexity analysis here
16:31:48 <narain> like taught in algorithms courses
16:31:56 <Alpenmilchschoko> Acucorp's COBOL too
16:31:57 <shapr> Alpenmilchschoko: Oh, if you want a contract to get support to fix GHC, that's no problem.
16:32:19 <procyon_> Alpenmilchschoko: In fact there are thousands of unresolved C++ standard library bugs *with the standards committee*.. meaning the very language definition makes no guarantee that the language itself is correct.
16:32:40 <Alpenmilchschoko> procyon_: yeah sure but i need that on paper
16:32:49 <shapr> narain: Ah.. well... traditional complexity assumes strictness from what I've seen.
16:33:10 <Alpenmilchschoko> shapr: name a company for Haskell
16:33:12 <kscaldef> it seems like you should approach the GHC maintainers directly, in that case,
16:33:13 <shapr> Okasaki's complexity estimates are tuned towards non-strict evaluation.
16:33:15 <dibblego> Alpenmilchschoko, if one us writes on a piece of paper that "Haskell works", will you give us some money?
16:33:18 <narain> shapr: yeah that was my point, it's easy to analyze
16:33:30 <dibblego> Alpenmilchschoko, name a company that IBM has written software for, where it works
16:33:31 <narain> shapr: i haven't seen okasaki's work
16:33:41 <Alpenmilchschoko> dibblego: yeah if you're big enough
16:33:43 <shapr> Alpenmilchschoko: I'm sure Galois would, but you could also find many professional contractors here on #haskell who could and would do it.
16:33:49 <procyon_> Microsft Cambridge is where SPJ works, but I'm not sure if MS will have anything to do with haskell.
16:33:54 <dibblego> Alpenmilchschoko, I'm 170cm (5'8") :)
16:34:02 <shapr> dibblego: haha
16:34:17 <narain> shapr: should i look it up?
16:34:25 <shapr> narain: Look up what? Okasaki's book?
16:34:27 <sjanssen> shapr: you can pay people to fix ghc, but I'm not sure that anyone will insure ghc
16:34:29 <narain> shapr: yes
16:34:40 <sjanssen> shapr: I think Alpenmilchschoko is looking for something else
16:34:58 <Alpenmilchschoko> dibblego: 188, all muscles, 2 kids and a big wife
16:35:15 <shapr> narain: Here are his pubs - the book was a rewrite and extension of his thesis -  http://www.eecs.usma.edu/webs/people/okasaki/pubs.html
16:35:16 <lambdabot> Title: Chris Okasaki's Publications
16:35:22 <shapr> Alpenmilchschoko: haha
16:35:31 <shapr> sjanssen: Er, like what?
16:35:55 <shapr> Alpenmilchschoko: spreuchen sie deutsche?
16:36:06 <shapr> Ah, my German is so sad, I shouldn't even try it...
16:36:15 <kscaldef> shapr: there's a big difference between saying "I'll fix a bug if you pay me" and "I'll pay you if you find a bug"
16:36:17 <narain> shapr: i can't figure out the time and space cost of a haskell program except by vague intuitive guesswork, and if i want to remedy that, would reading okasaki's work help?
16:36:25 <shapr> Men min svenska r mycket bttre.
16:36:31 <shapr> narain: I think so.
16:36:37 <Alpenmilchschoko> shapr: English is fine
16:36:42 <procyon_> Ich schpreche nur ein bissen.
16:36:53 <sjanssen> shapr: as I understand it, Alpenmilchschoko wants to pay some money, and then be guaranteed that GHC has no bugs (presumably the third party will be contractually obligated to fix bugs if Alpenmilchschoko finds any)
16:37:03 <sjanssen> Alpenmilchschoko: is this accurate?
16:37:22 <narain> shapr: ok, thanks
16:37:35 <Alpenmilchschoko> ksandstr: "i will sue you, if my system crash"
16:37:43 <procyon_> That sounds like a great job... you guys wanna incorporate real quick?
16:37:45 <shapr> Alpenmilchschoko: Oh.
16:37:46 * narain files away Okasaki's name for future reference when the need and/or free time arises, whichever comes first
16:38:23 <clanehin_> I don't know that anyone outside of nukes/airplanes pays their customers cash if they find a bug
16:38:30 <shapr> Alpenmilchschoko: I don't think you'll find anyone to take that contract. But you *could* get a contract that says "If you find a bug in GHC, we will immediately fix it."
16:38:47 <sjanssen> procyon_: I definitely would not write my name on a piece of paper that ghc is bug free
16:38:56 <sjanssen> s/that/that says/
16:39:32 <Alpenmilchschoko> shapr: "within 3 days or you'll pay me the pain"
16:39:48 <sjanssen> shapr: I'm skeptical that any corporation would take on such a contract
16:40:07 <procyon_> sjanssen: But I would write my name to a paper that says "Given $X, we will immediatly fix any deviations from the GHC specification that arise." Assuming that $X is large enough to be palatable,.
16:40:23 <shapr> sjanssen: Actually, I can think of one company and one contractor that would probably take that on.
16:40:27 <Alpenmilchschoko> sjanssen: IBM, ORCL, ACCRP
16:41:11 <sjanssen> Alpenmilchschoko: all huge corporations, yeah?  and they're putting a stamp of approval on software that is much more mature than ghc?
16:41:12 <sendo> how can i get get a list of lists to become just a list of the elements in that list? so if i have [[1,2,3,4],[5,6,7,8],[9,10]] i want [1,2,3,4,5,6,7,8,9,10]
16:41:19 <dibblego> the problem is identifying if a problem is indeed a bug
16:41:24 <allbery_b> :t concat
16:41:27 <lambdabot> forall a. [[a]] -> [a]
16:41:30 <sendo> aaah
16:41:34 <dibblego> if clients would just write their requirements with QuickCheck...
16:41:46 <sendo> cheers allbery_b
16:41:51 <fax> > concat [[1,2,3],[4,5,6],[7]]
16:41:52 <dylan> IBM software mature? hehehehehehe
16:41:53 <lambdabot>  [1,2,3,4,5,6,7]
16:41:58 <sjanssen> shapr: you realize that's a potentially unbounded amount of work?
16:42:02 <dibblego> IBM software? hehehehehe
16:42:06 <fax> > concat [1,2,3,[4,5,6],[7]]
16:42:06 <lambdabot>   add an instance declaration for (Num [a])
16:42:07 <kscaldef> dibblego: then they wouldn't need to hire us :-)
16:42:07 <lambdabot>     In the expression: 3
16:42:17 <procyon_> Alpenmilchschoko: What is their repurcussions in the case of failure?  Do they pay damages, or guarantee a fix within a specific time frame?
16:42:31 <dylan> I dunno if lotus notes counts as IBM software, but it has more problems than a gopher and a pineapple having children...
16:42:43 <shapr> sjanssen: Yup, I realize.
16:43:21 <Alpenmilchschoko> procyon_: they try to fix it within 72 hours, if not - they pay is big bux
16:43:30 <Zeroth404> ahoy
16:43:43 <dibblego> dylan, after 4 years at IBM software group, I could not find a piece of software that was complete rubbish and believe me, I looked *hard*
16:43:50 <Zeroth404> I have emerged victorious, kicker of cale's ass
16:44:03 <shapr> Alpenmilchschoko: Anyway, if you're serious about that, I do know a company and contractor that might do it.
16:44:08 <Zeroth404> (at least half time time_
16:44:15 * sorear wonders whether that is literally true
16:44:23 <dylan> dibblego: well, lotus notes, from a user perspective, is complete pineapple-on-gopher action.
16:44:41 <Zeroth404> he musta tripped over somethin
16:44:57 <dibblego> dylan, all IBM employees are forced to lotus notes (and by the way, encrypt with a controlled private key)
16:45:19 <Zeroth404> Cale: woop
16:45:23 <dylan> it would benefit from more static typing, surely, where "type error" means "you forgot to save"...
16:45:25 <Cale> Zeroth404: well, you got the idea
16:45:29 <Zeroth404> ya
16:45:36 <fax> http://www.gotopp.org/index.html.en
16:45:37 <lambdabot> Title: GOTO++ - Exciting news
16:45:40 <Cale> eventually it will work on all of them
16:45:41 <Zeroth404> Cale: if you want smarter bots, checkout brainworks
16:45:57 <Zeroth404> Cale: maybe I didn't get the idea...
16:46:02 <dylan> dibblego: I dunno, I refuse to learn to use lotus notes at work. And I'm helping migrate away from it. I hope.
16:46:20 <Cale> oh, you just sit there and shoot the target thing in the sky and otherwise ignore the bots
16:46:27 <dibblego> dylan, you get away with a different email client at IBM?
16:46:30 <Zeroth404> I saw that
16:46:35 <dylan> dibblego: I don't work at IBM.
16:46:36 <Cale> their scores will diverge toward -infinity much more quickly than yours
16:46:45 <dylan> dibblego: I am a *user* of lotus notes.
16:47:01 <dylan> and from that usage, I find it horrible.
16:47:03 <procyon_> Alpenmilchschoko: Given enough money, I think you would definately find a company willing to make that deal.  Your best bet for advice is probably simonpj@microsoft.com.  That's where I would start.
16:47:05 <dibblego> dylan, good luck migrating off it then - I encourage any user to move as far from IBM software as possible
16:47:08 <Cale> Every once in a while, you'll get killed, and they'll kill each other a bit, but they go after the BFG way more than they kill each other.
16:47:14 <fax> here is the faq http://www.gotopp.org/faq.html.en
16:47:15 <Zeroth404> Cale: you see that bounce? :-p
16:47:15 <lambdabot> Title: GOTO++ - FAQ
16:47:42 <Cale> the thing in the space map we were in?
16:47:45 <Zeroth404> ya
16:47:47 <Cale> Yeah, what was that?
16:47:47 <Zeroth404> boign
16:47:54 <Zeroth404> a bug, technically
16:47:54 <Cale> bug?
16:47:59 <dylan> dibblego: my boss loves it, sadly, but most internal stuff gets written by me, so...
16:48:21 <dibblego> dylan, I empathise with your boss and you, in that order
16:48:27 <Zeroth404> if you drop without moving on any axis except down/up, you'll bounce
16:48:37 <Zeroth404> easy when you run into a corner
16:48:55 <dibblego> dylan, I'd much rather swim in shit and know it (you), than not know it (your boss) :)
16:48:56 <Zeroth404> oh, and it only works at *special* heights
16:49:01 <Zeroth404> its a very complicated bug
16:49:01 <dylan> dibblego: of course, this is the same boss that doesn't realize how large a permutation of 16 boolean values is.
16:49:15 <dibblego> dylan, financial trading company?
16:49:22 <fax> hmm swimming in shit
16:49:23 <Cale> strange -- perhaps something in the collision detection
16:49:34 <dylan> dibblego: nah, design firm. Houses.
16:52:15 <nullstyle> hi, all, I have a quick question that I would be grateful for some help on.  I'm running ghc6.6 (installed from MacPorts) and I am trying to find how to build a simple C program that links to haskell and calls a haskell function that is exported through the haskell ffi.  Does anyone have a link that provides a simple method to call haskell from C.  I've been googling for a while and have not found anything that is easy to unders
16:52:42 <Cale> nullstyle: did you read the FFI spec?
16:52:54 <Cale> nullstyle: It's fairly tutorial in nature.
16:53:02 <nullstyle> ok, ill do that
16:53:05 <nullstyle> it looked forboding
16:53:08 <Cale> hehe
16:53:16 <Cale> It's not so bad once you jump it
16:53:17 <Cale> in*
16:53:21 <nullstyle> thank you
16:53:55 <chessguy_away> dylan: 64k isn't that big
16:54:54 <sorear> @go "8 choose 16"
16:54:55 <lambdabot> No Result Found.
16:54:58 <sorear> @go 8 choose 16
16:54:59 <lambdabot> 8 choose 16 = 0
16:55:06 <sorear> @go 16 choose 8
16:55:07 <lambdabot> 16 choose 8 = 12,870
16:55:21 <sorear> 12,870 << 65,536
16:56:38 <dylan> chessguy: huh?
16:57:02 <kc5tja> clear
16:57:04 <kc5tja> oops
16:57:08 <chessguy> oh, permutations, not combinations
16:57:32 <dylan> chessguy: either way, 64k orders is a big number.
16:57:56 <chessguy> dylan: <shrug>, it's all relative i guess
16:58:11 <dylan> that's 64 more orders than we're likely of getting in a year.
16:58:15 <dylan> err
16:58:26 <dylan> 64 times, I mean.
17:00:00 <zbrown> Hmmm this list comprehension could go on forever...
17:00:49 <sorear> nah.  list comprehensions don't affect the strong normalization of nonrecursive nonnewtype haskell.
17:01:07 <Zeroth404> Cale: is that the GO thing you keep mentioning?
17:01:11 <Zeroth404> Cale: @go?
17:03:14 <zbrown> sorear:  [(a,b,c,d,x) | x<-[-10..10], a<-[-100..100], b<-[-100..100], c<-[-100..100], d<-[-100..100], (1 + x) == ((x^2+4)*(a*x+b) + (x^2+4)^2 * (c*x + d))] <--- well that one will take a while ;)
17:04:44 <glguy> !paste
17:04:45 <hpaste> Haskell paste bin: http://hpaste.org/
17:06:19 <sorear> zbrown: you running that in GHCi?
17:06:28 <sorear> it'll go much faster if you compile it :)
17:06:31 <zbrown> ya, though ive optimized it ;)
17:06:42 <sorear> zbrown: no you haven't
17:06:49 <sorear> zbrown: -O is ignored by ghci
17:06:51 <zbrown> sorear: no i mean ive done it better
17:06:55 <zbrown> the actual formula lol
17:07:56 <sorear> well, zat list is only 10 trillion ops
17:08:02 <zbrown> yup
17:08:03 <sorear> it should be fusible
17:08:03 <zbrown> lol
17:08:22 <sorear> so, it'll optimize to a single machinecode loop
17:08:41 <sorear> but ghci will just execute every allocation etc
17:18:50 <sorear> :t mapAccumL
17:18:52 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:22:23 <Zeroth404> Cale: alive?
17:27:09 <Botje> @pl \(a,b) -> a/b
17:27:09 <lambdabot> uncurry (/)
17:27:14 <Botje> doh; of course
17:27:18 * Botje keeps forgetting about uncurry.
17:27:34 <zbrown> hmmm still gonna take a while sorear ;)
17:28:34 <abz> ?doc Monad
17:28:35 <lambdabot> Monad not available
17:28:44 <abz> ?doc Control.Monad
17:28:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
17:29:19 <fax> I get the error "Parse error in pattern"
17:29:32 <fax> whats that supposed to tell me :|
17:29:34 <zbrown> hmmm how would I tell the haskell code to do dual core?
17:30:09 <sorear> +RTS -N2
17:30:12 <sorear> *but*
17:30:21 <sorear> it won't help here, not without `par`s
17:30:33 <zbrown> sorear: hmmm fooey
17:30:36 <zbrown> par's?
17:30:41 <zbrown> sorear: can you explain?
17:30:45 <dons> re
17:30:45 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:31:28 <sorear> hi dons.
17:31:43 <zbrown> hi dons
17:31:43 <dons> sjanssen: patches please! :-)
17:31:44 <sorear> dons can explain the wonders of Control.Parallel far better than I
17:31:44 <zbrown> :)
17:31:59 <zbrown> hrm
17:32:06 <sorear> decode_LZW alphabet xs = concat output where
17:32:07 <sorear>   output = map (table !!) xs
17:32:07 <sorear>   table = map (:[]) alphabet ++ zipWith (++) output (map (take 1) (tail output))
17:32:11 <sorear> laziness ftw!
17:32:12 <dons> oh? compile with -threaded, run wiht +RTS -N2 -RTS, use forkIO or `par` in your code
17:32:19 <chessguy> man, i don't know how i'm going to study everything from monad transformers to math to OOP to algorithm design in 36 hours
17:32:21 <dons> ?docs Control.Parallel.Strategies
17:32:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel-Strategies.html
17:33:01 <zbrown> hmmm
17:33:07 <zbrown> looks daunting and almost not worth it lol
17:33:30 <zbrown> dons: any idea how i'd make this list comprehension work in parallel? [(a,b,c,d,x) | x<-[-1000..1000], a<-[-1000..1000], b<-[-1000..1000], c<-[-1000..1000], d<-[-1000..1000], (1 + x) == ((x^2+4)*(a*x+b) + (x^2+4)^2 * (c*x + d))]
17:35:01 <triplah_w> chessguy: closing irc would probably be a good start :P
17:35:02 <sorear> zbrown: C.P.S merely looks daunting.  99.99% of the time, you want `par`.
17:35:08 <zbrown> oh
17:35:49 <chessguy> triplah_w: i can't, i'll go through withdrawal
17:35:51 <zbrown> hrm `par`?
17:35:57 <zbrown> i see lots of par* something
17:36:30 <zbrown> parList looks promising
17:37:27 <bd_> :t parList
17:37:29 <lambdabot> forall a. Strategy a -> [a] -> Done
17:37:42 <bd_> still need to generate the list
17:37:55 <zbrown> ya... hmmm
17:38:23 <bd_> anyway... 4000000x4000000 list comprehension? Probably better not to generate such a huge list in the first place... :)
17:39:22 <zbrown> bd_: true ;)
17:39:23 <hpaste>  fax pasted "chainl1 example from parsec docs" at http://hpaste.org/881
17:39:28 <Cale> Zeroth404: hello
17:39:32 <Zeroth404> howdy
17:39:41 <Cale> Zeroth404: @go is google :)
17:39:42 <fax> ^ see if you run this parser it gives "1+2*3" => 9
17:40:01 <Zeroth404> who was it that was talkign about MIX vs MMIX ? because AOCP has MIX....and no mention of MMIX ....
17:40:45 <Cale> http://www.gokgs.com/download.xhtml -- If you'd like to find out about go, you might grab the Java Web Start client from here
17:40:47 <lambdabot> Title: CGoban 3 Download
17:40:53 <fax> if you change the two things it works correctly :S
17:40:59 <Cale> (the static client also works, but you end up having to update it too often)
17:41:50 <chessguy> Cale! how do i study everything from monad transformers to math to OOP to algorithm design in 36 hours
17:42:08 <Cale> recklessly?
17:42:24 * zbrown hates psychology
17:42:25 <chessguy> :)
17:42:27 * zbrown has an exam in it tomorrow...
17:42:28 <zbrown> grrr
17:43:36 * allbery_b is not too fond of psychology either.
17:43:43 <allbery_b> specifically, his own :/
17:44:36 <Zeroth404> Cale: gentoo has cogoban2 ... will that work?
17:46:02 <Cale> probably
17:46:12 <Cale> though the JWS version is usually more convenient
17:46:38 <Zeroth404> I downloaded it and opened it with konqueror. it just has one line of text. :-p
17:47:08 <Cale> er, heh :)
17:48:20 <Cale> If you have java installed properly, you should have a program called javaws with which you can run http://files.gokgs.com/javaBin/cgoban.jnlp
17:48:49 <dons> ooh, nice to see, http://www.ventonegro.org/?p=95
17:48:51 <lambdabot> Title: VentoNegro  Haskell in the real, mundane world
17:49:17 <Zeroth404> cgoban2 is java based
17:49:47 <Cale> right
17:50:35 <Cale> er, hey
17:50:41 <Zeroth404> ?
17:50:51 <Cale> I hadn't noticed, but what I'm running is CGoban 3 :)
17:51:08 <Zeroth404> yeah...is it just a different version, or a different game?
17:51:33 <Cale> Different version, but often you need to upgrade to be able to still connect to the network.
17:52:04 <Zeroth404> well now that the dependancies have been satisfied for cgoban2, maybe the download will work now
17:52:12 <Zeroth404> heh
17:52:12 <Zeroth404> nope
17:52:45 <dons> ?users
17:52:45 <lambdabot> Maximum users seen in #haskell: 339, currently: 294 (86.7%), active: 42 (14.3%)
17:52:56 <Cale> see if you have javaws somewhere, and if so, then just run it on that jnlp file
17:53:27 <Zeroth404> * javaws is not available for sun-jdk-1.5 on x86_64
17:53:29 <Zeroth404> :-(
17:53:39 <Cale> huh
17:53:54 <bd_> sun's JRE for x86_64 doesn't support webstart or applets
17:54:05 <bd_> dunno why
17:54:16 <Zeroth404> because sun needs to get wid da program
17:55:05 <Zeroth404> I think its funny theres a lotion called Jergens...cuz it sounds like jerkins...
17:57:27 <dons> @seen ventonegro
17:57:27 <lambdabot> I saw ventonegro leaving #haskell 24m 2s ago, and .
17:57:31 <dons> doh
17:57:41 <dons> http://programming.reddit.com/info/18ycn/details
17:57:42 <lambdabot> Title: Haskell for the Short Attention Span: Run-Length Encoding 3 (reddit.com)
17:58:26 <Zeroth404> dude
17:58:27 <Zeroth404> sweet
17:58:48 <dons> wow! --> http://www.bolour.com/papers/monads-through-pictures.html
17:58:50 <lambdabot> Title: Monads through Pictures
17:58:59 <dons> "My thanks to my fellow members of the Silicon Valley Patterns Group for lively discussions on Haskell"
17:59:59 <dons> here, http://programming.reddit.com/info/18yaw/comments
18:00:00 <lambdabot> Title: Monads Through Pictures (reddit.com)
18:01:08 <zeeeee> what's the shortest haskell code equivalent to python's 'enumerate'? (any builtin function?)
18:01:22 <dons> what does enumerate do?
18:01:35 <dons> > [LT ..] -- by chance?
18:01:37 <lambdabot>  [LT,EQ,GT]
18:02:01 <Cale> zipWith [0..] ?
18:02:03 <Cale> er
18:02:04 <Cale> zip [0..] ?
18:02:08 <zeeeee> Cale: oh, thanks
18:02:13 <Cale> > zip [0..] "Hello"
18:02:15 <lambdabot>  [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
18:02:21 <dons> enumerate is a zip??
18:02:31 <dons> oh, 'number'?
18:02:39 <zeeeee> > number "Hello"
18:02:39 <lambdabot>   Not in scope: `number'
18:02:44 <Cale> http://python.active-venture.com/whatsnew/section-enumerate.html
18:02:46 <lambdabot> Title: Python 2.3 Documentation - 7 PEP 279: enumerate()
18:03:07 <dons> right, zip [0..]
18:03:21 <dons> that's a built-in? how odd...
18:03:37 <dons> maybe they should have added parallel comprehensions ... ;)
18:04:22 <dons> does 'built-in' mean in the standard library, or it really is a new primop/syntax?
18:04:30 <cybercobra> how does haskell deal w/ tabs as indentation?
18:04:38 <dons> it assumes they're of width 8
18:04:50 <dons> best not to use them, in fact. they're deprecated
18:05:00 <dons> :set expandtab; :set ts=8 -- in vim
18:05:24 <cybercobra> dons: depreciated as in, won't be allowed in the future?
18:05:35 <Cale> yeah, probably.
18:05:49 <dons> well, they're discourged, and there's a compiler flag to warn if you use them
18:06:03 <cybercobra> thanks.
18:06:27 <Cale> It's best just to configure your editor to treat multiple spaces as if they were tabs.
18:06:34 <Cale> (and only store spaces into files)
18:06:55 <cybercobra> yes, i know. i use python, so i've dealt w/ this before
18:07:21 <dons> right. so haskell takes the opposite approach to layout to python,
18:07:27 <dons> less tabs, and { ; ; } is optional
18:07:47 <cybercobra> dons: how is it opposite?
18:08:07 <dons> aren't tabs the preferred (required?) whitespace in python?
18:08:30 <cybercobra> dons: no, it's mostly spaces actually
18:08:38 <cybercobra> dons: though there's no real concensus
18:08:39 <jcreigh> dons: no, I think they recommend spaces
18:08:54 <dons> ah ok. that's sensible
18:08:55 <fax> what reference do you use online?
18:09:04 <fax> to read about what a HashMap is or what Either is or whatever
18:09:10 <fax> or somthing offline?
18:09:15 <dons> ?docs Data.Either
18:09:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
18:09:17 <jcreigh> fax: I've found http://haskell.org/ghc/docs/latest/html/libraries/ to be helpful
18:09:18 <dons> ?docs Data.Map
18:09:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
18:09:28 <fax> alright :D
18:09:28 <dons> ?source Data.Either
18:09:28 <fax> thanks
18:09:29 <lambdabot> http://darcs.haskell.org/packages/base/Data/Either.hs
18:09:44 <dons> sjanssen: you hacking on anything?
18:09:48 <dons> or around?
18:11:26 <fax> I really like parsec :D
18:11:33 <jcreigh> yes, parsec is fun
18:13:37 <fax> er see "lookup :: (Monad m, Ord k) => k -> Map k a -> m a" in Data.Map
18:13:44 <fax> can you set the Monad it uses at any point?
18:13:54 <fax> I mean I really want to use Maybe
18:14:07 <jcreigh> fax: just constrain it to the right type
18:14:28 <fax> at what point?
18:14:36 <jcreigh> hold a sec...
18:14:36 <fax> when I create it, or use it or my function definition?
18:15:22 <jcreigh> like fromMaybe (error "Something went wrong!") (lookup k map)
18:15:24 <jcreigh> @type fromMaybe
18:15:27 <lambdabot> forall a. a -> Maybe a -> a
18:15:34 <dons> so oleg and chung-chieh  have outdone themselves again, http://article.gmane.org/gmane.comp.lang.haskell.general/14961
18:15:36 <lambdabot> Title: Gmane -- Mail To News And Back Again
18:15:51 <fax> Woah
18:15:54 <jcreigh> fax: In that case, fromMaybe needs a Maybe, so lookup knows to use Maybe.
18:16:26 <jcreigh> fax: or you could say case lookup k map of Nothing -> error "something went wrong" Just x -> x
18:16:37 <jcreigh> anything that lets the compiler know what type you're looking for
18:16:44 <fax> if I just do a case, it _will_ use the Maybe monad?
18:17:28 <jcreigh> fax: well, if you use a case that expects the Maybe monad, it will.
18:17:32 <fax> (a cuse with Nothing and Just)
18:17:38 <jcreigh> yeah
18:17:38 <fax> ok thats a nice feature :D
18:18:31 <jcreigh> or if you're expecting a list, it will use the list monad, etc, etc, etc.
18:20:27 <monochrom> it doesn't even have to be a monad!
18:21:14 <jcreigh> monochrom: hmm?
18:21:36 <monochrom> "case" is just pattern matching, isn't it?
18:21:52 <fax> I just like how what you have in the case affects what its testing :D
18:22:08 <fax> type inferrence is quite cool
18:22:46 <jcreigh> monochrom: yeah, but it wouldn't work if you were trying to pattern match against a type that wasn't a monad, given the type of "lookup" (Or am I mistaken?)
18:23:03 <monochrom> ok, specific to lookup.
18:23:31 <jcreigh> yeah. Of course you can pattern match against any old thing.
18:23:44 <jcreigh> but lookup returns something in a monad.
18:23:54 <monochrom> In that case, if you choose the monad to be IO, you can't use case.
18:24:54 <jcreigh> I forget; what does "fail" do in the IO monad?
18:25:02 <allbery_b> IOException
18:25:13 <fax> ugh :| The last statement in a 'do' construct must be an expression
18:27:28 <jcreigh> fax: what are you trying to do?
18:27:30 <jcreigh> @paste
18:27:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:27:54 <glguy> ?src bracket_
18:27:54 <lambdabot> bracket_ before after thing = bracket before (const after) (const thing)
18:28:07 <glguy> ?src bracket
18:28:08 <lambdabot> bracket before after thing = block $ do
18:28:08 <lambdabot>     a <- before
18:28:08 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
18:28:08 <lambdabot>     after a
18:28:08 <lambdabot>     return r
18:30:20 <fax> jcreigh: I was trying to do Map with the parameters back to front!
18:31:15 <robreim> There are too many jehovah's witnesses in rural Japan :(
18:32:00 <sjanssen> dons: I'm not hacking at the moment
18:32:46 <hpaste>  fax pasted "variable lookup" at http://hpaste.org/882
18:32:54 <fax> yikes
18:32:59 <fax> the indentation is screwed
18:33:21 <hpaste>  fax annotated "variable lookup" with "fixed indentation" at http://hpaste.org/882#a1
18:33:56 <fax> yeah I was hoping someone could tell me why it says "Couldn't match expected type `Float' against inferred type `Maybe a'"
18:34:12 <sjanssen> dons: I'm planning on handling XCrossingEvent.  I can fill in your MappingNotifyEvent stub too
18:34:30 <fax> It doesnt really make sense because I am actually using Maybe
18:35:10 <jcreigh> fax: you want "case Data.Map.lookup variables values of ..."
18:35:30 <fax> wow ok that works
18:35:45 <fax> I think I see what the error was now as well, thanks a lot
18:37:26 <araujo> hello!
18:37:34 <fax> hello:D
18:40:24 <chessguy> @type bracket
18:40:27 <lambdabot> Not in scope: `bracket'
18:40:36 <chessguy> sigh
18:40:40 <chessguy> ?hoogle bracket
18:40:41 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:40:41 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
18:40:41 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
18:42:18 <dons> sjanssen: i'm fixing it now, actually.
18:42:24 <dons> i've worked out the syntax :-)
18:43:24 <hpaste>  dpiponi pasted "Mandelbrot Set Code" at http://hpaste.org/883
18:43:48 <dpiponi> I wrote a cheesy little mandelbrot generator. How much shorter can you make it?
18:44:03 <dpiponi> I have an ulterior motive. I'm trying to get some Haskell source code on TV.
18:44:24 <fax> wow..
18:44:41 <dpiponi> I'm being interviewed for some TV show about fractals and I told them that fractals are cool because they don't take much code.
18:44:46 <fax> thats really cool
18:44:48 <dons> there's the shootout one, that's also pretty short (though ugly)
18:44:54 <dons> and b/w
18:45:08 <dpiponi> The producer said "can we show some actual code?" and I said "OK"
18:45:10 <glguy> putStrLn $ unlines $ map row [-1,-0.97..1] -- is probably -- mapM_ (putStrLn . row)
18:45:14 <dpiponi> So I'd like to impress them with shortness
18:45:16 <glguy> (and then the list)
18:45:53 <dpiponi> glguy: yup, that's shorter
18:45:59 <lispy> dpiponi: what region will this air in?
18:46:31 <dpiponi> lispy: Here's a link
18:46:34 <dpiponi> http://www.kikim.com/xml/projects.php?projectId=52
18:46:35 <lambdabot> Title: Kikim Media
18:46:43 <dpiponi> It's a PBS thing
18:46:49 <dpiponi> In the US
18:47:02 <lispy> dpiponi: cool, i'll try to watch it
18:47:07 <glguy> but what's the point of showing obfuscated code?
18:47:14 <dpiponi> II've no idea when it will appear
18:47:32 <dpiponi> glguy: the code will probably appear for 1 second on screen so nobody is going to read it
18:47:46 <dpiponi> glguy: I just want to impress how small fractal generators are
18:48:35 <dpiponi> glguy: I have a pretty version and an ugly short version. I haven't decided which to use.
18:48:59 <kpreid> dpiponi: if ... then '*' else ' ' = " *" !! fromEnum ..., but that might be too foul :)
18:49:09 <glguy> dpiponi: you should merge your x and y generation into a list comprehension
18:49:18 <jcreigh> dpiponi: well, I think code golf is silly, so I'd go with the pretty version...
18:49:30 <allbery_b> never underestimate the resourcefulness of a forewarned geek with a mythtv :)
18:49:58 <dibblego> is 0 a natural number?
18:49:59 * allbery_b notes that he doesn't have one and doesn't intend to
18:50:00 <kpreid> golf is silly, but fewer pieces is less so...
18:50:09 <lispy> dibblego: it can be
18:50:14 <dpiponi> " *" !! fromEnum is the Haskell version of C's " *"[x] But that's going too far.
18:50:16 <lispy> dibblego: depends on the school of thought
18:50:29 <lispy> dibblego: a lot of people want the naturals to start at 1
18:50:32 <kpreid> dpiponi: I'd try glguy's suggestion
18:50:34 <dibblego> lispy, I have seen people write data Nat = Zero | Succ Nat, however, I just read Peano's 8th axiom
18:50:42 <lispy> dibblego: and other, more lax people don't have a problem with 0 being a natural
18:50:50 <dpiponi> jcreigh: Actually, I don't think it's that obfuscated
18:50:51 <hpaste>  zeeeee pasted "i just finished writing my program - how do i even begin debugging it (array bounds violation)?" at http://hpaste.org/884
18:50:53 <jcreigh> of course, in C you can flip it around: x[" *"]
18:50:53 <kpreid> ...if you can make it work, I'd like to see
18:50:55 <dibblego> Peano(8) "If a is a natural number then Sa is not equal to 1."
18:51:09 <dibblego> (where S means successor)
18:51:09 <zeeeee> any approaches/hints would be greatly appreciated
18:51:44 <dibblego> lispy, so you mean I have to investigate and figure out which camp I belong to, making mistakes and switching camps the whole way, don't you?
18:51:50 <dons> sjanssen: hmm. its actually a MapNotify I see, not a MappingNotify. and dwm doesn't handle MapNotify. so I wonder if one of the other events isn't being properly handled (for firefox),  e.g. I notice we don't do everything dwm does for MapRequest
18:52:04 <halassocracy> you could interpret 1 to mean zero
18:52:14 <glguy> (length . takeWhile (<2) . take 100 $ iterate (\z -> magnitude(z*z+a)) a) >= 100
18:52:19 <glguy> is shorter than what it was
18:52:24 <lispy> dibblego: yup, but hey, it's one number out of an infinite set of numbers...it's nothing....literally :)
18:52:42 <SamB> dpiponi: go for a pretty one
18:52:57 <SamB> if it can all fit on the TV screen at once, anyway
18:52:59 <dibblego> it's an infinite series, but it has a start, unless you have a "shifting window", which I guess is what halassocracy is alluding to
18:53:12 <dpiponi> I think I might go for a list comprehension. That is both pretty and compact.
18:53:13 <lispy> dpiponi: if you can use list comps and make it look like a set theoretic definition in 3-5 lines that would be cool
18:53:27 <sjanssen> dons: the handling for MapNotify is a good place to start, I think
18:53:29 <dpiponi> lispy: exactly. That's what I think I'll do.
18:53:46 <SamB> lispy: don't forget the 3-5 lines to implement the ppm format
18:53:52 <sjanssen> dons: I've noticed some strange focus things too
18:54:29 <lispy> ah, the web...
18:54:30 <zeeeee> any general approaches?
18:54:32 <dibblego> lispy, if it not Peano's work that I look to to define natural numbers once and for all, then who's?
18:54:35 <dons> i'm not sure how to handle MapNotify, dwm doesn't handle it. But i've added full MappingNotify support
18:54:46 <dons> i'm looking at MapRequest now (we do one thing slightly differently there)
18:55:31 <lispy> dibblego: i'm in the lax camp myself.  If peano doesn't want 0 to be a natural, then when i work in his context 0 is not a natural "."  Otherwise, I'll ask 0 `elem` Nat
18:55:41 <sjanssen> dons: ah yes, I meant MapRequest
18:55:44 <SamB> dibblego: go with whatever your professor says
18:55:49 <SamB> or whatever your book says
18:55:53 <SamB> or whatever you prefer
18:55:56 <dibblego> SamB, I have no professor, nor book
18:56:15 <SamB> dibblego: buy some books
18:56:23 <dibblego> SamB, "what I prefer" is best left to theologians don't you think? :)
18:56:24 <lispy> the nice thing about mathematics is that you setup a well-defined context before you can work
18:56:30 <lispy> and sometimes you set it up differently
18:56:36 <lispy> depending on your mood if you like
18:56:40 <SamB> dibblego: mathemeticians won't tell you what you prefer
18:56:58 <dibblego> I'll buy books, but by who?
18:57:04 <halassocracy> undefined terms don't have any meaning in axioms, so the symbol "1" can be interpreted to mean zero, or the axioms could have some nonstandard model
18:57:12 <SamB> oh, well, a calculus book is always handy to have
18:57:19 <dibblego> halassocracy, yes, that model is forming in my mind right now
18:57:46 <sendo> hey ppl, i get *** Exception: Prelude.head: empty list on one of my functions. Where should i start looking for my error? is it because i dont have exhaustive patterns of recursion?
18:57:55 <glguy> > head []
18:57:56 <lambdabot>  Exception: Prelude.head: empty list
18:58:00 <sendo> aha
18:58:23 <lispy> sendo: that's a good question, unfortunately we don't have a good standard answer
18:58:29 <glguy> head is one of the dangerous partial functions
18:58:39 <dibblego> there was a mailing list thread about that
18:58:54 <glguy> the use of which forces you to take responsibility for an empty list being passed in into your own hands
18:58:55 <lispy> sendo: bottom line, you're going to be doing a fair bit of work...either up front getting your environment configured to be able to find it fast, or when you encounter it you'll have to dig for it.
18:59:02 <SamB> This guy wants to know whether zero is a natural or not. So, he walks up to God and says: "Is zero a natural or not?" and God says: "What are you reading?"
18:59:19 <sendo> cos i use head to get the first element of a list
18:59:39 <sendo> and the output of haskell does not tell me when head is being called
18:59:41 * glguy is having wild dejavu about this natural number quetsion
18:59:48 <sendo> is there anyway of making ghci more verbose?
18:59:53 <SamB> (except of course God would already know what you are reading ;-)
19:00:02 <sendo> to see which call of head is crapping all up?
19:00:09 <glguy> sendo: right, you were supposed to ensure that head wans't being called on anempty list
19:00:12 <glguy> before you compiled the program
19:00:13 <lispy> sendo: ^^ look at what i said :)
19:00:28 <fax> humpf
19:00:30 <sendo> ok
19:00:33 <fax> I dont know how to describe functions
19:00:42 <SamB> sendo: there is a tool called "catch"
19:00:46 <SamB> you might want to try it
19:00:46 * sendo gets diggin'
19:01:16 <lispy> sendo: you might want to try something like this: http://www.cse.unsw.edu.au/~dons/loch/Debug-Trace-Location.html
19:01:34 <glguy> errors like that are the price we pay forhaving a type system than terminates ;)
19:02:01 <lispy> glguy: yeah, but i think the language could still try harder to help when they do happen :)
19:02:14 <lispy> glguy: like making it give filename:lineno in the error
19:02:20 <sendo> yep
19:02:29 <monochrom> The compiler should just report: "unable to prove your program correct. aborted."
19:02:30 <sendo> which is given on most of the error outputs
19:02:35 <glguy> lispy: I think it should make your life miserable
19:02:43 <glguy> for callously using such a function ;)
19:02:50 <lispy> heh
19:03:04 <SamB> monochrom: the compiler might think the program was SUPPOSED to do that
19:03:09 <glguy> call it "unsafeHead"
19:03:23 <lispy> i've learned that "real" programmers writing code we depend on do far scarier things that call "head xs" without checking if xs is null
19:03:44 <glguy> lispy: maybe, that that doesn't excuse "head" abuse ;)
19:03:47 <SamB> glguy: I have a typechecker here that typechecks a language in which "head" is impossible
19:03:47 <fax> they use pointers
19:03:49 <glguy> but^
19:03:52 <lispy> glguy: these days, i'm happy if i can get others to do some testing :)
19:04:03 <monochrom> Coding is inherently unsafe.  Note I say coding, not programming.
19:04:13 <glguy> noted.
19:04:25 <hpaste>  dpiponi pasted "Short + Readable(?) Mandelbrot" at http://hpaste.org/885
19:05:40 <sendo> can u nest if clauses on haskell?
19:05:45 <lispy> dpiponi: is that a parallel list comp?
19:05:46 <kpreid> dpiponi: why use where?
19:05:48 <fax> sendo: yea
19:06:04 <dpiponi> kpreid: as opposed to let you mean?
19:06:13 <kpreid> lispy: no, it's two nested ones
19:06:15 <kpreid> dpiponi: no, as opposed to three top-level definitions
19:06:38 <lispy> kpreid: ah right, those brackets escaped my scrutiny
19:06:52 <dpiponi> kpreid: to reduce argument passing
19:07:11 <sendo> so if (length list == 0) then addStuffTo list else if (lenght list == 1) then backtrack else if (lenght list >= 2) then do something else
19:07:18 <sendo> would that be legal?
19:07:30 <kpreid> dpiponi: but escapes doesn't use any names from main
19:08:02 <kpreid> dpiponi: that is, you don't need the first where
19:08:09 <glguy> until (\(n,z) -> a == 100 || magnitude b < 2) (\(n,z) -> (n+1,z*z+a)) (1,a)
19:08:13 <dpiponi> kpreid: well spotted. It used to but I didn't notice it mutate to the point where it didn't.
19:08:18 <glguy> do you think that better describes what you are doing?
19:08:27 <kpreid> dpiponi: well, your original version didn't need the where either
19:08:30 <glguy> and that a and b are n and z
19:08:40 <dpiponi> kpreid: That wasn't the original original!
19:08:51 <lispy> mandlebrot = [[escapes (x :+ y) | x <- ...] | y <- ... ]; main = mapM putStrLn mandlebrot  -- <-- i'd use that personall :)
19:09:10 <glguy> mapM_ if it were me
19:09:23 <lispy> true, my point was just to name the set
19:09:30 <dpiponi> glguy: I hate those trailing underscores. So ugly :-)
19:09:43 <lispy> dpiponi: but they prevent space leaks
19:09:43 <glguy> dpiponi: I hate when people use too many parentheses
19:10:09 <glguy> lispy: but sometimes you have to sacrifice space for code attractiveness ;)
19:10:40 <kpreid> glguy: your until version's first function seems to be ignoring its arguments
19:11:02 <glguy> kpreid: like I said: 21:07  glguy> and that a and b are n and z
19:11:18 <kpreid> oh, sorry
19:11:32 <dons> sjanssen: ok. so fixing MapRequest didn't help firefox grab the keyboard. bah
19:11:48 <glguy> making a haskell wm?
19:11:58 <dons> sjanssen: do you see any interesting unhandled events in your logs?
19:12:02 <dons> glguy: already done.
19:12:07 <glguy> oh, cool
19:12:08 <dons> ?where thunk
19:12:08 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/thunk/
19:12:10 <glguy> when did that happen
19:12:15 <dons> a couple of days ago
19:12:21 <dons> sjanssen just sat down at wrote the damn thing
19:12:30 <araujo> anybody got admin for http://hackage.haskell.org/trac/ ?
19:12:32 <lambdabot> Title: Index of /trac
19:13:57 <hpaste>  dpiponi pasted "Good suggestions everyone!" at http://hpaste.org/886
19:14:25 <hpaste>  lispy annotated "Short + Readable(?) Mandelbrot" with "longer but saner IMHO" at http://hpaste.org/885#a1
19:14:40 <Gwern> is it not allowed to declare multiple definitions for a single function which differ in number of args?
19:14:57 <lispy> Gwern: not without type hackery
19:15:11 <Gwern> lispy: ack. what's the best way to work around it?
19:15:12 <glguy> :t printf
19:15:15 <lambdabot> forall r. (PrintfType r) => String -> r
19:15:21 <glguy> Gwern: write different functions?
19:15:27 <dpiponi> lispy: I think we're converging
19:15:35 * Gwern supposes so, but it wasn't what I wanted to hear
19:15:55 <lispy> dpiponi: yes, alhough i don't like the definition of escapes/interates
19:15:59 <SamB> Cale: I think flash just locked up my input...
19:16:02 <lispy> er iterates
19:16:12 <Cale> SamB: hm
19:16:17 <dpiponi> lispy: oh, what would you do?
19:16:24 <fantasma> > {- is there a function that takes this: -} ['a'..'z'] {- and returns this: -} [1..26]
19:16:25 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
19:16:27 * glguy don't think you are using /me correctly ;)
19:16:29 <monochrom> If you understand how Text.Printf gets it to work (there are some restrictions), you can do it yourself.  Sounds tautological, eh? :)
19:17:00 <fax> > map (-'a') ['a'..'z']
19:17:01 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Char'
19:17:02 <dpiponi> lispy: Actually, gotta go now but I'll scan the logs later.
19:17:06 <fax> >":(
19:17:13 <lispy> dpiponi: i have no futher recommendations :)
19:17:22 <fax> > map (ToIntegral) ['a'..'z']
19:17:23 <lambdabot>   Not in scope: data constructor `ToIntegral'
19:17:26 <fax> > map (ord) ['a'..'z']
19:17:28 <lambdabot>  [97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,11...
19:17:46 <fax> > map ((- $ ord 'a') . ord) ['a'..'z']
19:17:47 <lambdabot>  Parse error
19:17:47 <fantasma> > 26 - 97
19:17:48 <lambdabot>  -71
19:17:50 <fax> :S
19:17:55 <allbery_b> > map ((96 -) . ord) ['a'..'z')
19:17:55 <lambdabot>  Parse error
19:18:01 <allbery_b> > map ((96 -) . ord) ['a'..'z']
19:18:03 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
19:18:06 <allbery_b> durr
19:18:16 <allbery_b> > map ((subtract 96) . ord) ['a'..'z']
19:18:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]
19:18:25 <fantasma> damn it you beat me too it :)
19:18:55 <fantasma> thanks allbery_b
19:19:05 <fantasma> allbery_b++
19:19:21 <dmwit> > let negativeOne = -1 in negativeOne 3
19:19:22 <lambdabot>   add an instance declaration for (Num (t -> a))
19:19:23 <lambdabot>     In the expression: - 1
19:19:23 <lambdabot>  ...
19:19:30 <dmwit> > let negativeOne = (-1) in negativeOne 3
19:19:31 <lambdabot>   add an instance declaration for (Num (t -> a))
19:19:32 <lambdabot>     In the expression: (- 1)...
19:19:54 <fax> _
19:20:02 <SamB> _??
19:20:20 <fax> > let negative = (0-) in negative 3
19:20:21 <lambdabot>  -3
19:20:42 <lispy> > map (chr . ((((((subtract 97) . ord) + 13) `mod` 26)) + 97)) "Is this rot13?"
19:20:43 <lambdabot>        add an instance declaration for (Integral (Char -> Int))
19:20:46 <lispy> doh!
19:20:53 <dolio> > negate 3
19:20:55 <lambdabot>  -3
19:21:21 <dmwit> ?pl \x -> x - 1
19:21:21 <lambdabot> subtract 1
19:21:28 <fax> SamB: ____
19:21:54 <lispy> lambdabot: you're ignoring me
19:21:56 <SamB> my font does not appear to have U+29BF
19:21:57 <lispy> :t chr
19:22:00 <lambdabot> Int -> Char
19:22:12 <zeeeee> if i'd like to learn how to design/implement a haskell compiler (statically typed lazy functional lang - not interested in syntactic sugars/'advanced' features like exis. types, wonderful though these may be), what's the simplest one i should look at? jhc? any other resources/literature recommended?
19:22:42 <sendo>  ____
19:22:45 <sendo> wow
19:22:46 <sendo> nice
19:23:36 <Cale> zeeeee: http://research.microsoft.com/%7Esimonpj/papers/slpj-book-1987/index.htm
19:23:39 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/jd2f6
19:23:46 <dolio> > map (chr . (+97) . flip mod 26 . (+13) . subtract 97 . ord) "is this caesar"
19:23:48 <lambdabot>  "vfaguvfapnrfne"
19:23:59 <glguy> ?yhjulwwiefzojcbxybbruweejw
19:24:00 <lambdabot> Just 'J'
19:24:49 <zeeeee> Cale: thanks
19:25:20 <Cale> also, http://citeseer.ist.psu.edu/peytonjones92implementing.html is likely to be handy
19:25:22 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
19:25:52 <lispy> > map (\x -> chr ((((13 + (subtract 97 (ord x)))) `mod` 26) + 97)) "is this rot 13?"
19:25:53 <lambdabot>  "vfaguvfaebgartf"
19:26:08 <lispy> it does the numbers too which is bad
19:26:11 <fax> > map (\x -> chr ((((13 + (subtract 97 (ord x)))) `mod` 26) + 97)) "vfaguvfaebgartf"
19:26:13 <lambdabot>  "isnthisnrotnegs"
19:26:44 <dolio> The parentheses!
19:26:56 <chessguy> what is this, lisp?
19:27:15 <fax> you say that as if its a bad thing
19:27:23 <dons> jhc isn't the simplest compiler
19:27:27 <chessguy> you say that as if it's not
19:27:33 <fax> its not :D
19:27:40 <dons> maybe hmm, look at the 'Implementing Function Languages' tutorial/textbook?
19:27:43 <lispy> > map (\x -> if x `elem` ['a'..'z']++['A'..'Z'] then chr ((((13 + (subtract 97 (ord x)))) `mod` 26) + 97) else x) "is this rot13?"
19:27:44 <lambdabot>  "vf guvf ebg13?"
19:27:56 <chessguy> fac, someday you'll learn :)
19:28:07 <chessguy> s/c/x/
19:28:44 <dmwit> let rot13 x | isAlpha x = chr ((((ord x - ord 'a') + 13) `mod` 26) + ord 'a') in rot13 'a'
19:28:58 <fantasma> ?index ord
19:28:58 <dmwit> >let rot13 x | isAlpha x = chr ((((ord x - ord 'a') + 13) `mod` 26) + ord 'a') in rot13 'a'
19:28:59 <lambdabot> Data.Char
19:29:06 <cragwolf> ?poll-results OperatingSystem
19:29:07 <lambdabot> Poll results for OperatingSystem (Open): MacOS=1, House=1, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=1, OpenBSD=1, Gentoo=5, Debian=6, Ubuntu=5, FreeBSD=2
19:29:14 <dmwit> House??
19:29:17 <fantasma> HOUSE
19:29:20 <dmwit> Somebody is using that?
19:29:21 <lispy> dmwit: that's close but it's undefined for non-alpha
19:29:25 <fantasma> that's the one i voted for :D
19:29:54 <dmwit> Oh, it's a poll.
19:30:07 <fantasma> ?vote help
19:30:07 <lambdabot> usage: @vote <poll> <choice>
19:30:11 <rahikkala> There's an operating system named House?
19:30:13 <chessguy> thus the phrase "poll results"
19:30:17 <fantasma> @where house
19:30:18 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
19:30:18 <dmwit> I thought that was results from a Whois of some kind...
19:30:19 <lispy> @vote OperatingSystem Debian
19:30:19 <lambdabot> voted on "Debian"
19:30:41 <dmwit> Hey, polling is also a term used to refer to actively querying something for its status.
19:30:52 <dmwit> It's an overloaded term. =P
19:31:00 <fantasma> just like the word "set"
19:31:05 <lispy> dmwit: er well, in this case it's just passively querying... :)
19:31:07 <cragwolf> ?vote OperatingSystem Zenwalk
19:31:07 <lambdabot> "Zenwalk" is not currently a candidate in this poll
19:31:49 <dmwit> ?vote OperatingSystem Ubuntu
19:31:49 <lambdabot> voted on "Ubuntu"
19:31:51 <rahikkala> @choice-add OperatingSystem Zenwalk
19:31:51 <lambdabot> New candidate "Zenwalk", added to poll "OperatingSystem".
19:32:02 <rahikkala> (as if it wasn't already silly enough)
19:32:06 <fax> how do I..
19:32:12 <fax> :|
19:32:22 <cragwolf> ?vote OperatingSystem Zenwalk
19:32:22 <lambdabot> voted on "Zenwalk"
19:32:49 <cragwolf> rahikkala: thnx (yeah it's silly)
19:32:57 <fantasma> ?pl map (map x)
19:32:57 <lambdabot> map (map x)
19:32:58 <zbrown> ?vote Mandriva
19:32:58 <lambdabot> usage: @vote <poll> <choice>
19:33:07 <zbrown> ?vote OperatingSystem Mandriva
19:33:08 <lambdabot> "Mandriva" is not currently a candidate in this poll
19:33:12 <rahikkala> @pl \x -> map (map x)
19:33:12 <lambdabot> map . map
19:33:19 <zbrown> @choice-add OperatingSystem Mandriva
19:33:20 <lambdabot> New candidate "Mandriva", added to poll "OperatingSystem".
19:33:26 <zbrown> ?vote OperatingSystem Mandriva
19:33:27 <lambdabot> voted on "Mandriva"
19:33:33 <dibblego> is it fair to say that choosing 0 or 1 as the first natural number is not too meaningful - a bit superficial?
19:33:34 <chessguy_> hmm
19:33:42 <fax> > repeat 'a'
19:33:43 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
19:33:44 <lispy> dibblego: very
19:33:52 <dibblego> lispy, ok cool thanks /me wipes brow
19:33:55 <chessguy> not sure how that happened
19:34:05 * glguy runs OpenBSD FreeBSD Vista XP and OSX
19:34:05 <fax> > repeat ''
19:34:05 <lambdabot>  Improperly terminated character constant
19:34:06 <glguy> so...
19:34:13 <zbrown> ?poll-results OperatingSystem
19:34:13 <lambdabot> Poll results for OperatingSystem (Open): Mandriva=1, Zenwalk=1, MacOS=1, House=1, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=1, OpenBSD=1, Gentoo=5, Debian=7, Ubuntu=6, FreeBSD=2
19:34:16 <glguy> oh, and netbsdon an old laptop
19:34:37 <lispy> dibblego: otoh, someone asked me today if 1 is prime and i launched into an explanation of group generators vs. units :)
19:34:40 <dmwit> Err...
19:34:50 <dmwit> Ubuntu \subset Debian?
19:34:57 <lispy> dibblego: they glossed over and went back to work...so sometimes even when it's not superfical, no one cares :)
19:35:07 <fantasma> ubuntu is a pile of crap
19:35:11 <fax> hmm
19:35:12 <dmwit> o rly?
19:35:23 <zeeeee> how do i debug a haskell program? e.g. this one http://hpaste.org/884, where i get an array bounds violation - i can't even tell where it's coming from
19:35:25 <fantasma> yah rly
19:35:28 <jcreigh> fantasma: as compared to...?
19:35:30 <zbrown> Ubuntu is a little beyond being a subset of debian now
19:35:30 <lispy> please, it's #haskell no OS discussions :)
19:36:05 <zbrown> zeeeee: you might be better off with a list rather than array?
19:37:08 <fantasma> > map ((subtract 96) . ord) ['a'..'z']
19:37:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]
19:37:45 <fantasma> > map ((subtract 96) . ord) ['A'..'Z']
19:37:46 <lambdabot>  [-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13...
19:37:48 <zeeeee> zbrown: that would be a major change
19:37:55 <fax> HM
19:37:58 <dmwit> > 'A' < 'a'
19:38:00 <lambdabot>  True
19:38:00 <fantasma> > 96 + 31
19:38:02 <lambdabot>  127
19:38:06 <dmwit> > ord 'A'
19:38:07 <lambdabot>  65
19:38:17 <fax> can I make an infinite string
19:38:19 <fantasma> > 96 - 31
19:38:21 <lambdabot>  65
19:38:27 <dmwit> fax: What should be inside it?
19:38:28 <fantasma> > map ((subtract 65) . ord) ['A'..'Z']
19:38:30 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
19:38:33 <jcreigh> fax: sure!
19:38:36 <jcreigh> > repeat 'x'
19:38:37 <fax> A line of input from the user
19:38:37 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
19:38:42 <fantasma> > map ((subtract 64) . ord) ['A'..'Z']
19:38:43 <dmwit> getLines?
19:38:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]
19:38:58 <cragwolf> :t repeat
19:38:59 <fax> well my parser can do "1 + 1"
19:39:00 <lambdabot> forall a. a -> [a]
19:39:04 <dmwit> Whoops, not getLines.
19:39:15 <dmwit> getContents
19:39:19 <fax> but it errors on "1 +"
19:39:32 <fax> I was hoping theres a simple way I can just wait until theeres more input
19:40:12 <zeeeee> anybody?
19:40:15 <fantasma> > 1 + (Just 3)
19:40:16 <lambdabot>   add an instance declaration for (Num (Maybe t))
19:40:17 <lambdabot>     In the expression: 1 + ...
19:40:27 <fantasma> :hoogle ap
19:40:34 <fantasma> @hoogle ap
19:40:34 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
19:40:35 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
19:40:35 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
19:40:46 <dmwit> > do n <- Just 3; return (1+n)
19:40:47 <lambdabot>  Just 4
19:40:49 <lispy> here is another infinite sting in haskell
19:40:50 <lispy> > fix show
19:40:52 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:40:53 <newsham> > liftM (1 +) (Just 3)
19:40:54 <lambdabot>  Just 4
19:41:14 <lispy> in fact, the string, "fix show" is my favorite infinite string in haskell
19:41:16 <dmwit> Ooo, liftM.
19:41:25 <newsham> > fmap (1 +) (Just 3)
19:41:25 <cragwolf> :t fix
19:41:27 <dmwit> lispy: That's pretty neat!
19:41:28 <lambdabot>  Just 4
19:41:28 <lambdabot> forall a. (a -> a) -> a
19:41:36 <fax> why does it do that?
19:41:37 <newsham> > (1 +) `fmap` (Just 3)
19:41:38 <lambdabot>  Just 4
19:41:56 <dmwit> :t fmap
19:41:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:41:58 <newsham> ?src liftM
19:41:59 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:42:12 <lispy> dibblego: here is a way to convince yourself of the superficiality in this context...create a bijecition from Nat \ {0} to Nat U {0} (the nats without zero and the nats with zero).  Once you see they are isomorphic you kinda feel like it's all the same
19:42:12 <rahikkala> > let (.) = fmap in (+5) . ((+5) . Just 5)
19:42:14 <lambdabot>  Just 15
19:42:25 <cragwolf> ?src fix
19:42:25 <lambdabot> fix f = let x = f x in x
19:42:29 <zeeeee> i think the problem with this program is i wouldn't know how to break it up into smaller pieces to debug
19:42:44 <dmwit> Plus you get to keep your ordering! =)
19:42:45 <lispy> > map length . group . take 1000 . fix . show
19:42:46 <lambdabot>  Couldn't match expected type `a -> a'
19:42:47 <rahikkala> Hm, I'm impressed
19:42:51 <dibblego> lispy, yeah I keep telling myself that - I was just looking for assurance, thanks :)
19:42:52 <rahikkala> > let (.) = fmap; infixr 0 . in (+5) . (+5) . Just 5
19:42:54 <lambdabot>  Just 15
19:42:55 <lispy> > (map length . group . take 1000 . fix ) show
19:42:56 <fantasma> does liftM stand for liftMonad?
19:42:56 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,489]
19:43:26 <lispy> fantasma: correct
19:43:44 <fantasma> thanks lispy, makes a lot more sense now :)
19:43:47 <fax> > fix
19:43:48 <lambdabot>  Add a type signature
19:44:13 <lispy> > fix \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
19:44:14 <lambdabot>  Parse error
19:44:16 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
19:44:18 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:44:24 <fax> whats fix?
19:44:30 <newsham> > (1 +) `liftM` (Just 3)
19:44:32 <lambdabot>  Just 4
19:44:36 <fantasma> @index fix
19:44:37 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
19:44:40 <lispy> ?src fix
19:44:40 <dmwit> > take 30 . intersperse 1 $ map (\x -> 2**x - 1) [1..]
19:44:40 <lambdabot> fix f = let x = f x in x
19:44:42 <lambdabot>  [1.0,1.0,3.0,1.0,7.0,1.0,15.0,1.0,31.0,1.0,63.0,1.0,127.0,1.0,255.0,1.0,511....
19:45:03 <lispy> fax: it finds the least fixpoint of a function
19:45:15 <lispy> > fix . const $ show
19:45:16 <lambdabot>  <Integer -> [Char]>
19:45:21 <fax> oh ok
19:45:46 <fantasma> > Just fix Nothing
19:45:47 <lambdabot>  Couldn't match expected type `Maybe a -> t'
19:46:37 <fantasma> @src elemIndex
19:46:37 <lambdabot> elemIndex x     = findIndex (x==)
19:46:44 <hpaste>  jcreigh pasted "errors trying to build thunk" at http://hpaste.org/887
19:46:50 <fantasma> :t elemIndex
19:46:52 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
19:46:54 <jcreigh> sjanssen, dons: ^^ what am I doing wrong?
19:47:00 <jcreigh> this is debian etch.
19:47:13 <dmwit> zeeeee: What are you trying to do?
19:47:39 <newsham> > let sink f n = "drip! " ++ if n == 0 then "" else f (n - 1); plumber = fix sink in plumber 5
19:47:40 <lambdabot>  "drip! drip! drip! drip! drip! drip! "
19:47:42 <zeeeee> dmwit: i'm trying to write a dynamic program for solving "Evil Gambling Monster"
19:47:53 <zeeeee> *dynamic programming solution to
19:48:05 <dmwit> Link?
19:48:07 <zeeeee> http://www.facebook.com/jobs_puzzles/?puzzle_id=1
19:48:08 <lambdabot> Title: Facebook | Incompatible Browser
19:48:13 <zeeeee> hah
19:48:24 <jcreigh> this is the first time I've tried to use cabal...I installed dons's X11-extras package into /usr/local/stow/cabal-packages, and then did stow cabal-packages in /usr/local/stow to symlink it into /usr/local...
19:48:26 <zeeeee> Title: Facebook | Programming Puzzles
19:49:22 <dmwit> Aha.
19:49:23 <zeeeee> (i found the bug in my program, but only after much, much staring)
19:49:35 <zeeeee> (my question still stands, though - how the heck do you debug haskell)
19:50:27 <dmwit> Well, the newest versions of ghc(i?) have a debugger.
19:50:30 <zeeeee> it seems like there's really no easy way to debug it - the only tools you have are tracers
19:50:38 <zeeeee> oh, right, and that
19:50:45 <fantasma> does `zipWith` stop when one of the lists is exhausted?
19:50:49 <dmwit> yep
19:50:54 <fantasma> @src zipWith
19:50:54 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
19:50:55 <lambdabot> zipWith _ _      _      = []
19:50:58 <fantasma> nice
19:50:59 <fantasma> thanks
19:50:59 <dmwit> > zipWith (+) [1..5] [1..7]
19:51:01 <lambdabot>  [2,4,6,8,10]
19:52:08 <dmwit> zeeeee: If you're just starting with Haskell, arrays probably aren't the easiest way to make debuggable code...
19:52:16 <dino-> Just confirming what I suspect: I can only use Text.Regex.Posix =~ and =~~ for matching, not substitution?
19:52:41 <dino-> Must use Text.Regex.subRegex for that?
19:53:55 <zeeeee> dmwit: why would lists be easier?
19:54:18 <zeeeee> dmwit: seems like the only difference is instead of getting the array exception i'd get *** Exception: Prelude.tail: empty list
19:54:37 <dmwit> Hmmm...
19:54:38 <zeeeee> (that is, instead of *** Exception: Error in array index)
19:54:55 <fantasma> > tail []
19:54:56 <lambdabot>  Exception: Prelude.tail: empty list
19:55:04 <dmwit> What I mean is, many algorithms are expressed most clearly without explicitly using the (!!) operator or the head/tail functions.
19:55:18 <dino-> zeeeee: Debugging, so far I tend to use trace a lot. I have not yet seen ghci 6.7's debuggy stuff yet, although I'm excited that it's there.
19:55:44 <dino-> And I have not myself used hat much
19:56:06 <dino-> http://www.cs.york.ac.uk/fp/hat/
19:56:09 <lambdabot> Title: Hat - the Haskell Tracer
19:57:05 <zeeeee> dmwit: dynamic programming algorithms are most naturally expressed in terms of the recurrence relation that is memoized in an array, matrix, or other indexed construction
19:57:33 <dmwit> http://sequence.complete.org/node/263
19:57:36 <lambdabot> Title: Dynamic Programming in Haskell | The Haskell Sequence
19:57:37 <zeeeee> (depending on the dimensionality)
19:57:52 <dmwit> Haskell is magic: you can refer to results that haven't been calculated yet.
19:58:05 <dmwit> That makes the approach to dynamic programming...
19:58:07 <dmwit> different. =)
19:58:17 <zeeeee> dmwit: yes, that's exactly what i followed when i first learned using haskell for DP
19:58:37 <zeeeee> dmwit: well, that's exactly what my program does
19:58:51 <dmwit> Hum, looking at that again, there's quite a bit of listArray-ness.
20:00:09 <dmwit> Okay, consider me wrong. =P
20:00:47 <monochrom> nothing wrong with using an array
20:02:15 <monochrom> You still think less and code less.  You just code: "a[i] depends on a[i-1] and a[i+1]".  Compare with an eager language: you have to hardcode the proper order of evaluation too.
20:03:36 <zeeeee> monochrom: in my case, you think more and code more. after staring at the program and being unable to figure out where the violation is coming from, you keep changing and writing new code to try to slice up your haskell program to debug it.
20:04:45 <edited> heaven!
20:05:06 <zeeeee> furthermore! i wrote this in the comments, but i believe an imperative solution is actually more natural for this particular algorithm, because then we would avoid these 'undefined' cells (Nothing).
20:05:08 <dibblego> :)
20:05:18 <dibblego> edited, you'll notice no silly stuff in here :)
20:05:41 <monochrom> You can code an imperative solution as you see fit.
20:05:56 <edited> indeed
20:06:03 <zbrown> zeeeee: that may be true, but in many cases a functional solution may be more elegant ;)
20:06:25 <sjanssen> newsham: how long did your solution to the "Programming performance" problem take to execute?
20:06:39 <zeeeee> i thought for a while why this was the case. we have data dependencies that are selective, and we're trying to express that with 'pulling.' however, it would be more clear to express the propagation/flow of data in this case using a 'push' model.
20:06:42 * zbrown wishes that linux would quit dumping core files every few hours
20:07:02 <edited> even linux needs to take dumps
20:07:07 <edited> its healthy
20:07:10 <zeeeee> this then made me realize that FP is 'pull', and imperative programming is 'push'
20:07:14 <monochrom> I prove my programs correct, and I know haskell well enough to reliably do so.  I am denied access to certain hard-to-hunt coding errors.
20:07:29 <zbrown> edited: true... i just need to write a cron job that hourly goes through dirs and delets core.*
20:07:46 <edited> good idea
20:08:19 <zeeeee> this realization agrees very much with my other perspectives of FP's relative weaknesses (e.g. can't write a program that counts the number of occurrences of each word - why? because this would be most easily/efficiently expressed with *pushes* to hash tables)
20:08:24 <fax> why create these core files if you only delete them?
20:08:42 <dibblego> fax, we should have lazily evaluated core files?
20:08:45 <zbrown> fax: i don't create them, system does them
20:08:50 <fax> haha
20:08:57 <fax> zbrown: well its your computer
20:09:04 <zbrown> fax: eh, silly linux ;)
20:09:14 <dibblego> "hi I am your operating system, I have a core file behind this thunk here if you'd like to invoke it"
20:09:43 <fax> o99999999p0p-[p0-=][p0o;'09po['iolk;,/.op[
20:09:43 <kfish> or you could just disable core files if you don't want them: http://aplawrence.com/Linux/limit_core_files.html
20:09:45 <lambdabot> Title: Controlling core files (Linux)
20:09:49 * zbrown suspects lazy evaluation of core files would result in no core files being dumped if the evaluation basis was on core's usefulness
20:10:11 <zbrown> kfish: interesting, hadn't thought to just remove them from being made ;)
20:10:37 <kfish> it's linux, you're in charge dude
20:11:33 <fax> yeah and also the idea of digging a hole and then filling it in 10 mins later is jsut mad
20:12:08 <lispy> a trick i've used in hp-ux where it creates core files whether you want them or not, is to touch core; chmod a-w core.  Then nothing can create a core in that directory becaus it exists and isn't writable :)
20:12:50 <zbrown> lispy: haha nice
20:13:10 <monochrom> I am using Linux and I don't get periodic spontaneous core dumps.  I submit that your setup is wrong.
20:13:30 <zbrown> monochrom: what distro you using?
20:13:36 <monochrom> ubuntu 6.06
20:14:14 <zbrown> define 'setup is wrong' lol?
20:15:09 <edited> given "AbCDEf" how can i make a list of booleans returning true for upper case and false for lower case
20:15:20 <zbrown> ah YAHT lol ;)
20:15:22 <monochrom> I don't understand why so many people have so many problems with so many things.  "linux doesn't work" well it works for me.  "ubuntu is crap" well it runs great here.  "ghci is crashing" well I can't reproduce your problem here.  What's wrong with all you people?  Everything works just fine here.
20:15:31 <dmwit> > map isUpper "AbCDEf"
20:15:32 <lambdabot>  [True,False,True,True,True,False]
20:15:55 <dmwit> monochrom: =D
20:16:06 <zbrown> monochrom: lol i didn't say it was a problem so to speak
20:16:14 <zbrown> just something i didn't feel i wanted it to do ;)
20:16:15 <edited> hmmm  i didnt think it was that easy
20:16:27 <zbrown> i've used linux for six years, i just tend to be lazy when it comes to things like fixing the minor annoyances
20:16:33 <fax> Im using parsec right
20:16:39 <fax> and I parse "1+3 7*2" and it gives me 4.0
20:16:52 <fax> is there any way I can get the remaining stuff that hasnt been parsed?
20:16:54 <zeeeee> is there no reduce in haskell?
20:16:59 <zeeeee> only fold?
20:17:18 <fax> zeeeee: what languages have you used before?
20:17:24 <dmwit> zeeeee: Which one is reduce?
20:17:29 <dmwit> :t filter
20:17:31 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
20:17:33 <chessguy> folds are equivalent to reduce
20:17:51 <zeeeee> chessguy: i realize that...but reduce is so convenient, i'm surprised it's not in the standard lib
20:17:57 <dmwit> :t foldr
20:18:00 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:18:17 <dmwit> ?hoogle fold
20:18:17 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
20:18:18 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
20:18:18 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
20:18:20 <chessguy> how is reduce different from a fold?
20:18:37 <Korollary> reduce is foldl iirc
20:18:41 <monochrom> foldl' is so much more convenient
20:18:54 <fax> I wonder what language he is used to for the definition of reduce
20:18:58 <cragwolf> I'm trying to understand the fix function. Is the least fixed point of the function f(x) = (x - 1)^2 + 1 equal to 1?
20:19:01 <monochrom> I'm surprised Scheme doesn't call it foldl.
20:19:59 <Korollary> monochrom: there's foldr in some scheme libs iirc
20:20:18 <zeeeee> :t foldl'
20:20:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:20:30 <zeeeee> :t foldl
20:20:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:20:35 <zeeeee> um
20:20:36 <zeeeee> hm
20:20:41 <dmwit> cragwolf: I think so, but the "fix" function won't give you that.
20:20:42 <monochrom> :t foldl1
20:20:44 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
20:20:48 <monochrom> don't forget that
20:20:49 <zeeeee> ah
20:20:51 <zeeeee> strict
20:20:54 <dmwit> cragwolf: "fix" basically does infinite recursion
20:21:00 <zeeeee> fax: why do you ask?
20:21:18 <fax> zeeeee: to see where your definition of reduce is coming from
20:21:41 <dmwit> cragwolf: I've never seen it used in the wild, but I'm guessing it's mostly used to generate infinite lists.
20:21:52 <zeeeee> i've used haskell, scheme/lisp (but never explored the fun meta/symbolic stuff like macros), scala, ocaml a tiny bit, python, c, c++, java, php, can't think of others
20:21:54 <chessguy> @type unfoldl
20:21:57 <lambdabot> Not in scope: `unfoldl'
20:22:02 <chessguy> @type unFoldl
20:22:04 <lambdabot> Not in scope: `unFoldl'
20:22:09 <chessguy> ?hoogle unfold
20:22:10 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
20:22:10 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
20:22:10 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
20:22:18 <cragwolf> dmwit: thnx, the docs for fix is confusing
20:22:26 <fax> zeeeee: :O :O
20:22:27 <newsham> > fix (\recurse n -> if n == 0 then 1 else n * recurse (n - 1)) 5
20:22:29 <lambdabot>  120
20:22:32 <fax> zeeeee: you never messed with scheme macros?!
20:22:38 <chessguy> ?hoogle a -> Maybe (b, c)
20:22:39 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap.predFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
20:22:39 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap.succFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
20:22:39 <fax> ohh you have some fun ahead :D
20:22:55 <zeeeee> fax: so i hear
20:23:28 <monochrom> fix is easy to understand.  If you define recursion "f = ... f ...", you can write "f = fix (\f -> ... f ...)"
20:24:43 <fax> so does anyone know how I can get the remainder of a string from parsing with Parsec?
20:24:51 <monochrom> Example 0.  You want recursive list "trues = True : trues".  It is "trues = fix (\f -> True : f)
20:25:11 <fax> like "2+1 4*3+7" would give me 3.0 but I want to get the rest later on
20:25:45 <newsham> > xs = fix (\recurse -> 'x' : recurse)
20:25:45 <lambdabot>  Parse error
20:25:52 <newsham> > fix (\recurse -> 'x' : recurse)
20:25:54 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
20:25:55 <fax> > fix fix
20:25:56 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
20:25:56 <lambdabot>     Probabl...
20:26:12 <monochrom> Example 1.  You want recursive function "f x = ... f (x-1) ...".  First lambda-ize the parameter: "f = \x -> ... f (x-1) ...".  Then it is "f = fix (\f x -> ... f (x-1) ...)"
20:26:25 <zeeeee> holy hell...that's amazing - fix is defined exactly how you would define it in math...i have no idea how this compiles
20:26:29 <zeeeee> fix f = let x = f x in x
20:26:44 <zeeeee> oh wait, never mind - i misparsed that. it's straightforward.
20:27:24 <edited> is there a list where i can find out all the functions like Char.isUpper, `elem`, `mod`
20:27:28 <rashakil> fax: use parsec to parse the rest of the input, and return that as a string, and then pass that back in?  <- answer of somebody who hasn't really used parsec.
20:27:41 <fax> somthing like that would be great
20:27:45 <zeeeee> (is laziness what makes the above 'fix' definition possible?)
20:28:01 <fax> the functions dont seem to support this kind of thing :/
20:28:06 <newsham> ?let repX recurse n = if n == 0 then [] else 'x' : recurse (n - 1)
20:28:09 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:28:09 <monochrom> Example 2.  You want recursive function, but it has several pattern matching equations: "f 0 = 0; f x = ... f(x-1)...".  First lambda-ize and merge them into a case expression: "f = \x -> case x of 0 -> 0; _ -> ...f(x-1)...".  Then it is "f = fix (\f x -> case x of 0 -> 0; _ -> ...f(x-1)...)"
20:28:48 <Korollary> edited: you can hoogle for them
20:28:56 <Korollary> @help hoogle
20:28:57 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
20:29:13 <rashakil> fax: do { expr <- parseFoobar ; rest <- restOfInput ; return (expr, rest) },  perhaps?
20:29:18 <Korollary> @hoogle [a] -> [a]
20:29:18 <lambdabot> Prelude.cycle :: [a] -> [a]
20:29:19 <lambdabot> Prelude.init :: [a] -> [a]
20:29:19 <lambdabot> Prelude.reverse :: [a] -> [a]
20:29:29 <monochrom> fax: yes, laziness is essential in the implementation of fix.
20:29:44 <fax> rashakil: Ohhhhhh
20:29:46 <fax> wow
20:29:46 <cragwolf> monochrom: thanks for the examples, but what is the advantage of use fix? succinctness?
20:29:51 <newsham> > let repX recurse n = if n == 0 then [] else 'x' : recurse (n - 1) in repX (const "y") 0
20:29:52 <fax> I never saw that one, thanks a lot!
20:29:52 <lambdabot>  ""
20:30:01 <newsham> > let repX recurse n = if n == 0 then [] else 'x' : recurse (n - 1) in repX (repX (const "y") 1)
20:30:02 <lambdabot>  Couldn't match expected type `a -> [Char]'
20:30:03 <monochrom> Oh haha, I mis-replied.
20:30:05 <fax> :| Ive been looking at the docs for like an hour
20:30:08 <monochrom> zeeeee: yes, laziness is essential in the implementation of fix.
20:30:17 <newsham> > let repX recurse n = if n == 0 then [] else 'x' : recurse (n - 1) in repX (repX (const "y")) 1
20:30:18 <lambdabot>  "x"
20:30:27 <zeeeee> monochrom: sorry, silly question
20:30:27 <newsham> > let repX recurse n = if n == 0 then [] else 'x' : recurse (n - 1) in repX (repX (repX (const "y"))) 2
20:30:29 <lambdabot>  "xx"
20:30:42 <monochrom> cragwolf: yeah, just succintness, I suppose.
20:30:42 <newsham> > let repX recurse n = if n == 0 then [] else 'x' : recurse (n - 1) in repX (repX (repX (repX (const "y")))) 3
20:30:44 <lambdabot>  "xxx"
20:31:21 <newsham> > fix repX 3
20:31:22 <lambdabot>   Not in scope: `repX'
20:31:33 <newsham> > let repX recurse n = if n == 0 then [] else 'x' : recurse (n - 1) in fix repX 3
20:31:34 <lambdabot>  "xxx"
20:32:24 <edited> say i have a list of True and False how do i count how many true are there?
20:32:50 <dmwit> ?hoogle fromEnum
20:32:51 <lambdabot> Prelude.fromEnum :: Enum a => a -> Int
20:32:58 <newsham> > length $ filter (== 'x') "axbbxxuxxxux"
20:32:58 <dmwit> > fromEnum True
20:33:00 <lambdabot>  7
20:33:00 <lambdabot>  1
20:33:04 <fax> hmm restOfInput doesnt exist
20:33:12 <dolio> > length . filter id $ [True, False, False, True, True]
20:33:13 <lambdabot>  3
20:33:24 <rashakil> fax: yeah, write that yourself :P
20:33:28 <fax> er.
20:33:34 <fax> I see how its possible :S
20:33:36 <dmwit> > sum $ fromEnum [True, False, False, True, True]
20:33:37 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
20:33:42 <fax> I suppose i could just use getPosition
20:33:44 <dmwit> > sum $ map fromEnum [True, False, False, True, True]
20:33:46 <lambdabot>  3
20:33:53 <fax> oh wait of course its possible
20:33:57 <fax> hmmmmmmm
20:34:10 <fax> I like that :D
20:34:38 <sjanssen> jcreigh: did you get help with your thunk problem?
20:34:57 <zeeeee> ?pl (\(_,l) (_,r) -> compare l r)
20:34:57 <lambdabot> (`ap` snd) . (. fst) . const . compare . snd
20:35:05 <cragwolf> :t fromEnum
20:35:06 <zeeeee> urgh
20:35:08 <lambdabot> forall a. (Enum a) => a -> Int
20:35:17 <newsham> > let f True = (+ 1); f False = id in foldl (.) id (map f [True,False,True]) 0
20:35:18 <lambdabot>  2
20:35:23 <dolio> > liftM2 (-) length sum . map fromEnum $ [True, False, False, True, True]
20:35:24 <lambdabot>  2
20:36:43 <newsham> > foldl (\n p -> if p then n + 1 else n) 0 [True, False True]
20:36:44 <lambdabot>  Couldn't match expected type `Bool -> Bool'
20:37:09 <cragwolf> >fromEnum True
20:37:34 <cragwolf> > fromEnum True
20:37:35 <lambdabot>  1
20:38:19 <cragwolf> > fromEnum 'a'
20:38:21 <lambdabot>  97
20:38:30 <sjanssen> @tell jcreigh get X11-extras from darcs get http://darcs.haskell.org/~sjanssen/X11-extras -- the version that dons hosts is outdated
20:38:30 <lambdabot> Consider it noted.
20:38:47 <edited> with sum $ fromEnum [True, False, False, True, True] it counts all true...wat if i wanted to count all false
20:38:52 <dolio> ?pl snd *** snd >>> uncurry compare
20:38:53 <lambdabot> snd *** snd >>> uncurry compare
20:39:14 <dolio> > (snd *** snd >>> uncurry compare) (1, 2) (1, 3)
20:39:15 <lambdabot>  Couldn't match expected type `t1 -> t'
20:39:30 <dons> sjanssen: i'll remove it
20:39:39 <dons> gone.
20:39:39 <Korollary> edited: then filter false's from the list first
20:39:45 <dolio> > curry (snd *** snd >>> uncurry compare) (1, 2) (1, 3)
20:39:46 <lambdabot>  LT
20:39:51 <dolio> > curry (snd *** snd >>> uncurry compare) (1, 2) (1, 1)
20:39:52 <sjanssen> dons: and I updated the readme
20:39:52 <lambdabot>  GT
20:39:55 <dons> cheers
20:40:00 <newsham> > map not [True, False, True]
20:40:02 <lambdabot>  [False,True,False]
20:40:06 <dons> sjanssen: any thoughts on handling other events? the expose stuff?
20:40:11 <dons> XCross* whathvae you
20:41:09 <sjanssen> XCrossEvent was the next on my list.  I'm not sure what is causing the focus issues
20:41:46 <newsham> ?type foldl (\n p -> if p then n + 1 else n) 0 [True, False, True]
20:41:48 <lambdabot> forall a. (Num a) => a
20:41:52 <jcreigh> sjanssen: no, but I see your @tell...I'll try that
20:41:52 <lambdabot> jcreigh: You have 1 new message. '/msg lambdabot @messages' to read it.
20:41:53 <sjanssen> I've noticed some things in addition to your firefox problem.  Sometimes when switching windows focus gets stuck in one window
20:41:58 <newsham> > foldl (\n p -> if p then n  else n + 1) 0 [True, False, True]
20:41:59 <lambdabot>  1
20:42:33 <sjanssen> jcreigh: darcs pulling from that location and build/install should fix your problem
20:43:43 <dons> you'll want the most recent darcs versions of both repos, X11-extras and thunk
20:43:45 <glguy> ?get-shapr
20:43:45 <lambdabot> shapr!!
20:44:45 <newsham> apt get shapr
20:45:10 <glguy> apt sounds like one of those "loonux" applications
20:45:40 <dmwit> > let divides a b = b `mod` a == 0 in take 10 $ nubBy divides [2..]
20:45:42 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
20:46:34 <newsham> thats nice
20:46:35 <dmwit> Is there an elem-alike for ordered lists?
20:46:54 <dmwit> ?hoogle a -> [a] -> Bool
20:46:55 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
20:46:55 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
20:47:12 <dmwit> =(
20:47:42 <zeeeee> can you bind vars in comprehensions without using lists? i.e. not this: [y | x <- [1..], y <- [f x], predicate y]
20:47:57 <zeeeee> something like y = f x
20:48:04 <zeeeee> (i tried that but it didn't parse)
20:48:42 <jcreigh> yay, thunk works.
20:48:43 <glguy> > let elemUp x = foldr aux False where aux y goOn | y < x = goOn | x == y = True | otherwise = False in elemUp 5 [1..]
20:48:45 <lambdabot>  True
20:48:50 <glguy> > let elemUp x = foldr aux False where aux y goOn | y < x = goOn | x == y = True | otherwise = False in elemUp 5 [6..]
20:48:51 <lambdabot>  False
20:48:53 <jcreigh> sjanssen++ Thanks for your help
20:49:08 <newsham> isnt it a *list* comprehension?
20:49:39 <sjanssen> jcreigh: thanks for trying thunk
20:49:51 <dmwit> > let selem x xs = any (map (== x) xs) in selem 5 [1..]
20:49:52 <lambdabot>  Couldn't match expected type `a -> Bool'
20:50:06 <shachaf> > [ys | let n = 5, ys <- [1..n] ]
20:50:08 <lambdabot>  [1,2,3,4,5]
20:50:25 <glguy> dmwit: that elemUp was for you
20:50:34 <dmwit> glguy: thanks.
20:50:41 <dmwit> I'm playing with a few ways of doing it.
20:50:43 <zeeeee> shachaf: thanks
20:50:58 <glguy> dmwit: hmm... I think that foldr might be the one true way ;)
20:51:00 <dons> jcreigh: i think you're user number 3. :-)
20:51:00 <sjanssen> jcreigh: you might want to try something like this to switch between thunk and a more stable wm http://hpaste.org/856
20:51:19 <glguy> > let elemUp x = foldr aux False where aux y goOn | y < x = goOn | otherwise = x == y in elemUp 5 [6..]
20:51:20 <lambdabot>  False
20:51:22 <glguy> > let elemUp x = foldr aux False where aux y goOn | y < x = goOn | otherwise = x == y in elemUp 5 [2..]
20:51:23 <dons> s/more stable/more featureful/
20:51:24 <lambdabot>  True
20:51:27 <dmwit> > let selem h [] = False; selem h (x:xs) = if h < x then selem h xs else h == x in selem 5 [1..]
20:51:28 <lambdabot>  False
20:51:34 <dons> sjanssen: did you have a look at StackSet? any thoughts?
20:51:47 <dmwit> > let selem h [] = False; selem h (x:xs) = if h > x then selem h xs else h == x in selem 5 [1..]
20:51:49 <lambdabot>  True
20:51:51 <dmwit> > let selem h [] = False; selem h (x:xs) = if h > x then selem h xs else h == x in selem 5 [6..]
20:51:53 <lambdabot>  False
20:52:13 <sjanssen> dons: no, I haven't
20:52:14 * sjanssen looks
20:52:25 <glguy> > let elemUp x = foldr aux False where aux y | y < x = id | otherwise = \_ -> x == y in elemUp 5 [2..]
20:52:26 <lambdabot>  True
20:53:04 <dmwit> > take 10 $ map (== 5) [1..]
20:53:05 <lambdabot>  [False,False,False,False,True,False,False,False,False,False]
20:53:06 <cragwolf> sum $ map (fromEnum . not) [True, False, False, True, True]
20:53:15 <dmwit> :t any
20:53:16 <dons> sjanssen: runhaskell tests/Properties.hs :-)
20:53:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:53:20 <cragwolf> > sum $ map (fromEnum . not) [True, False, False, True, True]
20:53:22 <lambdabot>  2
20:53:24 <jcreigh> as expected, thunk doesn't play well with xinerama. :)
20:53:31 <cragwolf> I am so slow
20:53:35 <dons> jcreigh: that is expected :-)
20:53:51 <dmwit> > any (map (== 5) [1..])
20:53:52 <lambdabot>  Couldn't match expected type `a -> Bool'
20:54:03 <dmwit> ...oh
20:54:08 <glguy> dmwit: that works great until you want a false
20:54:12 <dmwit> ?hoogle [Bool] -> Bool
20:54:13 <lambdabot> Prelude.and :: [Bool] -> Bool
20:54:13 <lambdabot> Prelude.or :: [Bool] -> Bool
20:54:18 <dmwit> glguy: Yeah, I just realized that.
20:54:24 <zeeeee> ?pl (\(a,b) -> isJust b)
20:54:25 <lambdabot> isJust . snd
20:54:57 <zeeeee> ?pl (\(a,b) -> (a,fromJust b))
20:54:57 <lambdabot> second fromJust
20:54:58 <sjanssen> I wonder how complicated xinerama support is
20:55:08 <zeeeee> :t second
20:55:10 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
20:55:30 <dons> jcreigh: have you used dwm/wmii/ion ?
20:55:52 <dons> sjanssen: neither ion nor dwm support it, so i imagine it must be tedious/tricky?
20:56:01 <jcreigh> dons: ion3 supports xinermam
20:56:05 <jcreigh> *xinerama
20:56:12 <jcreigh> as well as ratpoison
20:56:17 <dons> oh, tuomo plans to give it up though
20:56:24 <jcreigh> what?
20:56:29 <dons> if you followed the "tuomov sucks" thread on ion-dev@
20:56:39 <jcreigh> silly. Just as well I jumped ship and went back to ratpoison.
20:57:19 <jcreigh> I played with wmii a for a little bit a couple nights ago...I really like the idea, except (of course) no xinerama.
20:57:46 <jcreigh> so I think if I want xinerama support, I'm just going to have to find a WM I like otherwise, and hack support in myself. :)
20:57:47 <kfish> dcoutts, dons, the rules for SoC mentoring organisations are a bit more strict this year
20:58:00 <dons> kfish: url?
20:58:16 <dcoutts> kfish, I didn't get the impression we need to be a legal entity
20:58:16 <sebell> I tend to like evilwm
20:58:47 <dons> of the 100 or so .orgs last year, only maybe 5 were legal entities/foundations...
20:59:08 <dons> so I don't think that's going to be required. having a real account to send stuff to might be reasonable, though
20:59:21 <jcreigh> sebell: hate to sound like a broken record here, but does it support xinerama? I have the hardware...I'm not going to let it sit idle. :)
20:59:32 <dmwit> :t scanr
20:59:35 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
20:59:44 <dmwit> :t scanl
20:59:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
21:00:06 <kfish> dons, dcoutts can't find a url, just remember from discussions -- and i had a long chat with leslie hawthorn after linux.conf.au
21:00:19 <cragwolf> I found a discussion of the fix function, for those interested: http://harold.hotelling.net/gcdfix.lhs
21:00:27 <kfish> dons, dcoutts but i'm guessing that haskell.org might be ok after doing a successful soc last year
21:00:27 <sebell> jcreigh: I used it on my dual-monitor setup without any issues, but I only used nv twinview's Xinerama plugin, so I'm not too sure
21:00:36 <dons> sjanssen: re. the statusbard, i think its feasible to run it as a seperate process that reads the StackSet dumps from thunk's stdout. however, i'm not keen on porting say, dmenu to support it. it would be easier to write a 20 line hskell 'statusbar' prog to draw the little window, imo
21:00:46 <dons> kfish: indeed.
21:01:21 <jcreigh> sjanssen: I gather the initial goal of thunk is be a dwm workalike?
21:01:28 <sjanssen> jcreigh: correct
21:01:56 <dons> ... without the bloat
21:02:01 <dons> (mwhahaha)
21:02:25 <fantasma> wouldn't a WM written in haskell be slower than one written in c?
21:02:40 <dons> fantasma: no, since the WM is just glue code to the Xlib
21:02:40 <fax> fantasma: not really
21:02:40 <sebell> fantasma: Oh no you didn't...
21:02:50 <dons> in fact, thunk has better complexity for its core operations
21:02:51 * Korollary doesnt care really
21:02:57 <fax> if you wrote it in C you could write while(!random()) all over the placen and it would be really "slow"
21:02:57 <dons> since it uses balanced trees, rather than linked lists
21:03:30 <dons> so detching clients and so on is O(log n) in the workspace count, while its o(n) for most ops in dwm.
21:03:40 <dons> now, of course, you only have 5 workspaces ...
21:03:45 <fantasma> big-o
21:03:55 <fantasma> thanks dons
21:04:05 <jcreigh> hmmm, if I sort by memory in "top", thunk is currently using less memory than bash
21:04:18 <dons> good. though its not been tuned yet, jcreigh
21:04:44 <dons> i've been using it for 2 days now, and it feels nicer than dwm (proper full screen), and not noticeably slower.
21:04:49 <dons> its also 1/10th the lines of code.
21:04:54 <jcreigh> dwm isn't proper full screen?
21:05:03 <sjanssen> jcreigh: why do you want xinerama, this is what tuomov has to say "multihead is most of the time unecological penis enlargement, with no real justifiable (to me) need behind  it"
21:05:26 <jcreigh> sjanssen: well, to me, it's a way to have more screen real estate.
21:05:36 <jcreigh> but I guess I must look at things differently than him. :)
21:05:56 <dons> tuomov has the typical "tiny window mangaer dev syndrome"
21:06:02 <dons> it makes you go crazy after a few weeks
21:06:03 <glguy> people that don't see how you could need more screen realesate must not be using their computers to do "work"
21:06:11 <kc5tja> sjanssen: Multihead is invaluable for the kind of hardcore coding work we do at work.  A single monitor is not very productive in comparison.
21:06:44 <sjanssen> jcreigh: I'll probably write xinerama support when I get an external monitor working with my laptop.  As long as the code isn't too hairy
21:06:48 <Korollary> Multihead is nice if it's set up nicely.
21:07:01 <sjanssen> kc5tja: I don't agree with tuomov
21:07:41 <dons> sjanssen: I see that evilwm also handles only the same events as dwm.
21:07:57 <dons> so I wonder if it maybe is those expose/hide events (though i've not seen them come up in the logs yet.. :/)
21:08:19 <sjanssen> dons: or some mask setting that dwm does initially
21:08:41 <dons> ah. ok. don't know about that.
21:08:43 <sjanssen> one of the first problems I encountered was not setting substructureRedirectMask
21:08:49 <dons> yeah
21:09:52 <dons> heh .evilwm and dwm are almost exactly the same size, and have the same ratio of comments/code/
21:10:02 <nornagon> :)
21:10:04 <dons> 1700 loc, 100 comments.
21:10:08 <nornagon> does thunk work yet?
21:10:11 <jcreigh> hmm, gvim acts funny, but gvim acts funny in all full-screen-ish WMs that I've tried.
21:10:18 <dons> nornagon: i'm using it., so yes.
21:10:35 <sjanssen> jcreigh: yeah, gvim doesn't always pay attention to resizing
21:11:00 <sjanssen> jcreigh: my trick with dwm is shrinking, then growing the column it's in
21:11:12 <jcreigh> yeah, it's kind of annoying. I always have to "nudge" it in ratpoison.
21:12:31 <sebell> Gross!
21:12:37 <jcreigh> dons: you're using it for real?
21:13:04 <dons> for 2 days now. i only use dwm in full screen mode anyway (12" laptop screen)
21:13:19 <sjanssen> nornagon: give it two weeks, then thunk should be usable
21:13:23 <dons> missing things I want: firefox input from keyboard fails for me, statusbar.
21:13:36 <dons> i think it'll be fully usable for me by say ... Monday? ;)
21:14:01 <jcreigh> dons: hmm, firefox input works fine for me. I'm on "iceweasel" 2.0.0.1
21:14:06 <dons> sjanssen: the layout tiling code should be doable as a pure pretty printer like algorithm, i suspect
21:14:15 <nornagon> sjanssen: :)
21:14:19 <dmwit> let parseStrings ss = ss >>= words >>= read in parseStrings ["3 4  5 6", "7 8 9"]
21:14:25 <dmwit> > let parseStrings ss = ss >>= words >>= read in parseStrings ["3 4  5 6", "7 8 9"]
21:14:27 <lambdabot>  Exception: Prelude.read: no parse
21:14:28 <dons> i hope it can be completely pure, and just build up an AST which then is rendered by X.
21:14:31 <dmwit> ?
21:14:40 <dons> so we can actually write QC properties for the layout code
21:14:46 <nornagon> dons: what kind of statusbar?
21:14:51 <nornagon> i want a statusbar that i can subvert
21:14:58 <nornagon> i.e, replace with some window of my own
21:15:02 <dons> yeah, its going to be a seperate process
21:15:11 <dons> thunk just dumps a snapshot of its internal state to stdout
21:15:12 <sjanssen> dons: sure.  The layout algo is pretty simple
21:15:25 <dons> and your custom statusbar proggy reads that, and does what it will
21:15:26 <Korollary> is a status bar a monad? It's got to be as this is called thunk.
21:15:30 <dons> i'm kinda surprised dwm doesn't do that, in fact
21:15:38 <dons> considering they have dmenu
21:16:08 <dmwit> > let stringsToInts ss = ss >>= words >>= read
21:16:09 <lambdabot>  Parse error
21:16:14 <dons> so thunk writes to stdout its state changes as : "(1,[[6291473,10485774],[33554446,18874382,20971534],[23068686,31457294,29360142,27262990],[],[]])"
21:16:23 <dmwit> ?let stringsToInts ss = ss >>= words >>= read
21:16:25 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:16:28 <dons> showing what stack is current, and what XIDs are on each stack
21:16:43 <dons> then your status bar prog reads that structure and does whatever it likes with it
21:16:55 <sjanssen> dons: three cheers for cheesy Read serialization!
21:17:02 <dons> woo!
21:17:49 <sjanssen> dons: you mentioned something earlier about handling the current window title?
21:18:00 <dons> yeah, we can just grab that from the XID
21:18:00 <jcreigh> oh, hey, alt+shift+N to move to workspace. cool.
21:18:02 <fax> "The last statement in a 'do' construct must be an expression"
21:18:09 <dmwit> > ["3"] >>= read
21:18:11 <lambdabot>  Exception: Prelude.read: no parse
21:18:11 <fax> why must the last statement of a do construct be an expression?
21:18:20 <dmwit> ???
21:18:23 <zeeeee> any haskell library interface to graphviz/dot?
21:18:23 <sjanssen> fax: them's the rules
21:18:27 <dons> jcreigh: just like dwm. alt-shift-n to move clients, alt-n to move focus. alt-j/k to move around the current stack
21:18:29 <fax> but why?
21:18:42 <dmwit> > ["3"] >>= liftM read
21:18:44 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
21:18:53 <sjanssen> fax: the translation to bind syntax wouldn't make any sense otherwise
21:18:57 <nornagon> fax: do you know how do-notation works?
21:19:06 <nornagon> and do you know about >>= and >>?
21:19:21 <sjanssen> fax: I imagine you're writing "someVar <- someThing" as the last line?
21:19:47 <dmwit> ?pl \x -> [read x]
21:19:48 <lambdabot> return . read
21:19:59 <dmwit> > ["3"] >>= return . read
21:19:59 <fax> yeah I am
21:20:01 <lambdabot>  [3]
21:20:03 <sjanssen> dons: ah, querying the X server, very clever!
21:20:09 <fax> and nornagon ive seen >>= but not >>
21:20:11 <dolio> > liftM read ["3"]
21:20:13 <lambdabot>  [3]
21:20:25 <nornagon> @src (>>)
21:20:25 <lambdabot> m >> k      = m >>= \_ -> k
21:20:26 <dmwit> > let stringsToInts ss = ss >>= words >>= return . read in stringsToInts ["3 4 5", "6 7 8"]
21:20:27 <lambdabot>  [3,4,5,6,7,8]
21:20:35 <dmwit> Ha!
21:20:37 <dmwit> Take that!
21:20:43 <dons> sjanssen: we'll need a binding to XFetchName though
21:20:55 <dons> only XStoreName is currently bound in X11
21:21:01 <sjanssen> dons: how will your status bar get other info (seeing as stdout is already taken)
21:21:13 <sjanssen> dons: of course we will . . . bleh
21:21:33 <dons> i was thinking the script itself would just compute other things.
21:21:45 <dons> another option is to use /var/run/thunk.state
21:22:09 <sjanssen> where thunk.state is a fifo?
21:22:17 <dons> yeah.
21:22:52 <dons> we need a little program that takes a complete string on stdin and draws a menu first though.
21:23:00 <dmwit> What if two users on the same computer both use thunk? ;-)
21:23:01 <sjanssen> right, right
21:23:02 <dons> thunk | render | rostatusbar
21:23:18 <sjanssen> dmwit: of course it will have to be more complicated than that
21:23:27 <dmwit> I know, I'm just teasing you guys.
21:23:38 <dons> where 'render' generates the text contents of the statusbar, and rostatusbar just draws it( a bit like dmenu/xmessage)
21:24:36 <jcreigh> heh...the debian dwm package is really small. :)
21:24:50 <fax> where are examples of using >> ?
21:25:15 <nornagon> f = a >> b, where a and be are two actions that you want performed that don't need interaction
21:25:18 <nornagon> er
21:25:19 <sjanssen> jcreigh: seems strange to use a binary package of dwm
21:25:21 <nornagon> s/be/b/
21:25:40 <glguy> > "ex" >> "ample"
21:25:41 <lambdabot>  "ampleample"
21:25:49 <newsham> > print "hi" >> print "there" >> print "mom"
21:25:50 <lambdabot>  <IO ()>
21:25:55 <jcreigh> sjanssen: yeah, the package description even says "this isn't really useful except just to try it out" (paraphrased)
21:26:09 <fax> > "abc" >> "def"
21:26:10 <lambdabot>  "defdefdef"
21:26:17 <fax> Oh
21:26:29 <fax> > "abc" >> (\x -> print x)
21:26:30 <lambdabot>      The lambda expression `\ x -> ...' has one argument,
21:26:31 <lambdabot>     but its type `[...
21:26:52 <fax> > [(\x -> print x)] >> "abc"
21:26:54 <lambdabot>  "abc"
21:26:56 <fax> heh
21:27:25 <fax> > map print [id, reverse, id] >> "abc"
21:27:26 <lambdabot>  Add a type signature
21:27:30 <fax> > map print $ [id, reverse, id] >> "abc"
21:27:32 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>]
21:27:37 <fax> hmpf:|
21:27:40 <jcreigh> ...it's off to work I go!
21:28:10 <newsham> > [1..3] >>= (\x -> "X")
21:28:12 <lambdabot>  "XXX"
21:28:18 <newsham> > [1..3] >>= (\_ -> "X")
21:28:20 <lambdabot>  "XXX"
21:28:23 <newsham> ?src (>>)
21:28:24 <lambdabot> m >> k      = m >>= \_ -> k
21:28:31 <newsham> > [1..3] >> "X"
21:28:32 <lambdabot>  "XXX"
21:28:40 <fax> ?src >>=
21:28:40 <lambdabot> Source not found. It can only be attributed to human error.
21:28:44 <fax> ?src (>>=)
21:28:44 <lambdabot> Source not found. Do you think like you type?
21:28:49 <fax> :[
21:28:50 <newsham> ?src (>>=) List
21:28:51 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:28:55 <fax> :D
21:28:56 <newsham> ?src (>>=) []
21:28:57 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:29:02 <newsham> ?src [] (>>=)
21:29:03 <lambdabot> m >>= k     = foldr ((++) . k) [] m
21:29:29 <newsham> ?src Maybe (>>=)
21:29:29 <lambdabot> (Just x) >>= k      = k x
21:29:30 <lambdabot> Nothing  >>= _      = Nothing
21:32:37 <newsham> > Just 1 >> Just 2 >> Just 3
21:32:38 <lambdabot>  Just 3
21:32:53 <nornagon> > Just 1 >> Nothing >> Just 3
21:32:55 <lambdabot>  Nothing
21:36:49 <Gwern> I am misunderstanding the idea of the Either type if I attempt to extract the first value via fst, am I not?
21:36:59 <jcreigh> :t fst
21:37:02 <lambdabot> forall a b. (a, b) -> a
21:37:12 <jcreigh> fst and snd are for extracting values out of 2-tupes
21:37:14 <jcreigh> *tuples
21:37:18 <sjanssen> Gwern: there is only one value in an Either
21:37:27 <Gwern> right, and Either doesn't return tuples if I've figured anything out
21:37:54 <nornagon> > (Right 2) >> (Right 3) >> (Left "error")
21:37:55 <lambdabot>  Left "error"
21:38:07 <nornagon> > (Right 2) >> (Right 3) >> (Left "error") >> (Right 1)
21:38:08 <lambdabot>  Left "error"
21:38:15 <nornagon> > (Right 2) >> (Right 3) >> (Right 1)
21:38:16 <lambdabot>  Add a type signature
21:38:27 <nornagon> > (Right 2) >> (Right 3) >> (Right 1) :: (Either Integer String)
21:38:28 <lambdabot>   add an instance declaration for (Num String)
21:38:37 <nornagon> > (Right 2) >> (Right 3) >> (Right 1) :: (Either String Integer)
21:38:38 <lambdabot>  Right 1
21:39:16 <rahikkala> > ((Right 1) :: Either String Int) >>= (return . (+1))
21:39:17 <lambdabot>  Right 2
21:39:40 <nornagon> > ((Left "halp") :: Either String Int) >>= (return . (+1))
21:39:40 <rahikkala> > ((Left "pass through") :: Either String Int) >>= (return . (+1))
21:39:42 <lambdabot>  Left "halp"
21:39:42 <lambdabot>  Left "pass through"
21:39:45 <nornagon> :)
21:39:51 <newsham> i wish i could use fst and snd on [1,2,3,4]  (Left 5)   (Just 3)  (1,2)  (1,2,3) etc.
21:39:54 * rahikkala yields
21:40:14 <newsham> i say "the first item in the tuple", why cant I say "fst (1,2,3,4)"
21:40:35 <nornagon> you can
21:40:43 <nornagon> > fst (1,2,3,4)
21:40:44 <lambdabot>  Couldn't match expected type `(a, b)'
21:40:44 <jcreigh> newsham: Because It Doesn't Work That Way.
21:40:46 <nornagon> ... oh.
21:41:10 <nornagon> > (\(a,_,_,_) -> a) (1,2,3,4)
21:41:11 <lambdabot>  1
21:41:16 <newsham> jcreigh: i'm not hearing that, see.
21:41:40 <fax> @doc hReady
21:41:41 <lambdabot> hReady not available
21:41:46 <nornagon> tuples are weird, yo.
21:41:57 <jcreigh> I haven't felt the need for anything more than a 2-tuple...higher N N-tuples seem to be saying "I want to be a real datatype"
21:42:18 <nornagon> mm
21:43:01 <newsham> jcreigh: it only doesnt work that way because I havent altered my library
21:43:22 <glguy> http://programming.reddit.com/info/18yaw/comments
21:43:24 <lambdabot> Title: Monads Through Pictures (reddit.com)
21:43:30 <newsham> http://www.thenewsh.com/~newsham/x/order.hs
21:43:35 <glguy> did anyone read this and think "oh, that is a useful way to look at it"?
21:44:39 <dons> well, I read it and thought wow, bay area haskell group :-)
21:44:54 <fax> http://www.bolour.com/papers/images/monad-elevation.png
21:44:57 <fax> Oh now I get it
21:45:00 <jcreigh> newsham: but can you define it for arbitrary N? :)
21:45:00 <fax> :D hhaha
21:45:12 <newsham> so are you saying monads are highly toxic?
21:45:31 <newsham> jcreigh: *cough*zip3*cough*
21:45:38 <glguy> ?quote "apples are carried"
21:45:39 <lambdabot> No quotes for this person. I feel much better now.
21:45:50 <glguy> ?quote apples
21:45:51 <lambdabot> dons says: think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples.  now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
21:45:51 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
21:46:02 <newsham> ?quote unsafePerform
21:46:03 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
21:46:03 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
21:46:29 <fax> LOL
21:46:42 <sjanssen> monochrom++
21:46:42 <jcreigh> monads are like...themselves.
21:46:50 <monochrom> hehe
21:46:55 <jcreigh> Monads on a plane.
21:46:56 <newsham> a simile is like a metaphor...
21:47:07 <glguy> ?quote plane
21:47:07 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
21:47:22 <glguy> ?quote plane
21:47:23 <fax> why do I _have_ to have an else on my if
21:47:23 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
21:47:23 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
21:48:05 <jcreigh> fax: because if is an expression. It has to evaluate to *always* evaluate to something.
21:48:14 <fax> hmpf
21:48:23 <fax> well Ill have to write somthing like dont
21:48:26 <glguy> lol, what should it do otherwise
21:48:27 <glguy> stop?
21:48:34 <glguy> :t when
21:48:36 <glguy> :t unless
21:48:37 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:48:38 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:48:40 <newsham> a priest and a rabbi walk into a bar and the bartender says "what is this, some sort of joke?"
21:48:45 <fax> oh they already exist, cool
21:48:45 <fax> thanks
21:49:14 <glguy> fax, you'd have to rename if to "maybeCrash
21:49:43 <fax> ":/
21:49:46 <fax> when not in scpoe
21:50:06 <glguy> ?index when
21:50:06 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:50:44 <fax> :/
21:50:47 <glguy> let faxIf b x = if b then x else error "didn't bother"
21:50:48 <fax> I guess ill just use if
21:51:17 <jcreigh> fax: what are you trying to do, anyway?
21:51:33 <fax> trying to get rid of else return () in:
21:51:41 <glguy> ?src when
21:51:41 <lambdabot> when p s = if p then s else return ()
21:51:48 <hpaste>  fax pasted "(no title)" at http://hpaste.org/889
21:52:01 <fax> well I tried when but it just says, Couldn't match expected type `()' against inferred type `IO ()'
21:52:20 <fax> hm
21:52:37 <hpaste>  glguy annotated "(no title)" with "with when" at http://hpaste.org/889#a1
21:52:48 <fax> Ohhh
21:52:55 <fax> I see exactly why that works now
21:53:09 <fax> ok thats great cheers again :D
21:54:16 <hpaste>  glguy annotated "(no title)" with "=<< chaining (if you were interested)" at http://hpaste.org/889#a2
21:54:49 <glguy> oops, you'd delete the 'l'
21:55:02 <fax> ooh
21:55:13 <fax> I didnt notice the =<< bit
21:55:36 <jcreigh> thunk is the first WM I've seen with comments giving the complexity of internal functions... (not that I make a habit of reading WM source code...who knows, maybe that sort of thing is all over in, oh, stumpwm or whatever.)
21:55:37 <glguy> it doesn't necessarily help anything here, just showing
21:55:53 <fax> yeah I was just reading about >> and >>=
21:55:59 <fax> so I think I sort of see whats going on there
21:56:04 <glguy> does it give the complexity assume a strict execution?
21:56:13 <glguy> assuming
21:56:56 <newsham> http://koweycode.blogspot.com/2007/01/think-of-monad.html <- added a comment.
21:57:00 <lambdabot> Title: koweycode: think of a monad...
21:57:20 <jcreigh> glguy: I don't know enough to answer your question. I just see comments that say "/O(log n)/" and I assumed that it meant something. :)
22:00:05 <sjanssen> glguy: yes, it assumes strict evaluation, because the underlying data structures are spine strict
22:00:35 <glguy> good deal :)
22:01:19 <jcreigh> I don't understand the difference... last xs is going to be O(N), whether you evaluate it now or later, right?
22:01:19 <glguy> sjanssen: when do you think that thunk will be ready for general use?
22:01:29 <sjanssen> glguy: hard to say
22:01:50 <sjanssen> there's only a few more things to implement before I can use it full time
22:01:58 <sjanssen> glguy: what do you use now?
22:02:01 * glguy uses dwm
22:02:12 <glguy> I tried other wms
22:02:16 <glguy> I really wanted to use something else
22:02:24 <glguy> they all get too cluttered after I got used to dwm
22:02:52 <glguy> wmii ended up being too much
22:03:00 <glguy> much less metacity or something
22:03:12 <jcreigh> glguy: I played around with it a bit earlier today. if you just open stuff full-screen, and you don't have a quirky app that you need to use, you can do stuff with it now. (I don't think there's any sort of splitting or columns support right now)
22:03:39 <glguy> dwm doesn't do "columns"
22:03:44 <glguy> it does big window on the left
22:03:52 <glguy> everything else stacked on the right
22:04:14 <glguy> and then it also has support for floating windows
22:04:54 <jcreigh> ah, okay, I haven't used dwm, so I don't know exactly what a dwm workalike is.
22:05:14 <glguy> one of the biggest features is the tagging system
22:05:30 <glguy> you add 1 to many tags to each window
22:05:37 <jcreigh> main problem with small WMs that actually manage windows is there's always some app that doesn't like to be resized...
22:05:40 <glguy> and you have show 1 to many tags at a time
22:05:50 <glguy> jcreigh: then you put in a rule for it
22:05:58 <glguy> jcreigh: so that it starts as a floating window
22:06:02 <sjanssen> glguy: do you actually use tags?
22:06:07 <glguy> sjanssen: yeah
22:06:16 <glguy> I've got stuff that I should be using while working
22:06:21 <glguy> and stuff that I should be using while not working
22:06:30 <fax> how do you avoid typing Prelude.map all the time if you use Prelude.map and Data.map in the same file?
22:06:33 <glguy> its nice ot be able to bring both up though
22:06:47 <glguy> so sometimes I'll have both tags enabled
22:06:56 <glguy> and then if I have something running in the background, I'll use a new tag
22:07:19 <glguy> and I usually use a separate tag for my email client
22:07:32 <jcreigh> fax: import qualified Data.Map as M
22:07:45 <fax> Ah, ok thanks
22:08:36 <glguy> sjanssen: why do you ask
22:09:05 <sjanssen> glguy: I don't use them, I'm not sure if thunk will have them
22:09:15 <glguy> that's like 1/2 of the feature set!
22:09:56 <glguy> literally
22:09:59 <glguy> 1 of the 2 features
22:10:04 <jcreigh> heh
22:10:34 <glguy> you can't claim size victory over dwm and only implement half of it :-p
22:11:30 <sjanssen> glguy: I really don't consider it a competition
22:11:46 <glguy> well... you should
22:11:48 <glguy> :)
22:11:55 <jcreigh> besides, "exec xterm" is the smallest possible WM...just use that. :)
22:11:57 <dons> i consider it a competition.
22:12:05 <glguy> hurrah
22:12:06 <dons> C is the wrong language to use for window managers
22:12:19 <glguy> ruby is the right language?
22:12:27 <dons> and I want to prove that. :-) high assurance (QC properties), less code, strong static typing, fast, small.
22:12:29 <glguy> wait, that was for wasting resources
22:12:34 <dons> no, not ruby.
22:12:36 <dons> yeah ;)
22:12:44 <fax> bash
22:12:45 <glguy> I always get those two mixed up
22:12:58 <jcreigh> Imagine if firefox was written in Ruby...
22:13:04 * zbrown thinks visual basic 5 is the best language for window managers ;)
22:13:10 <glguy> exec xterm is decidedly *not* a wm ;)
22:13:15 <dons> WMs are just glue code, so you should use strong glue
22:13:25 <glguy> gorilla glue?
22:13:28 <dons> and a language with good support for the WM data structures
22:13:39 <jcreigh> glguy: what? C'mon, do you want your WM to do *everything* for you? :)
22:14:49 <glguy> jcreigh: like tag windows?
22:15:17 <glguy> or "allow me to move them"
22:15:40 <dons> thunk does both of them, atm.
22:16:03 <jcreigh> I just think it's silly to go around saying "look what my WM can't do! But it has fewer LOC!" Computers are fast, space is vast, and your enemies are numerous. Coding is hard enough without trying to comply with some arbitrary line count limitation.
22:16:23 <Gwern> general sort of question. if I compile with -O3 instead of -O2, can I expect Bad Things to happen?
22:16:52 <dons> no. -O3 doesn't nothing over -O2
22:17:02 <dons> however, -O2 may (rarely) produce slower code than -O
22:17:07 <Gwern> jcreigh: the way I see it, a window manager should do things fast, since tiny slivers of sections make the different between a mentally wearying WM and one that's a joy to work with
22:17:15 <dons> I've seen it happen maybe 3 times in 3 years.
22:17:26 <Gwern> dons: so the option is just there for symmetry with GCC?
22:17:34 <dons> yep
22:17:35 <jcreigh> dons says that the line-count thing works well for dwm WRT refactoring and clean code...that's great, but I'm not going to use a WM that doesn't do what I want it to.
22:18:02 <fantasma> is there something more "modern" than `The Art of Computer Programming` - Knuth which delivers similar content?
22:18:03 <rahikkala> Gwern: If you're talking about gcc and mean Bad Things in the sense that it's not at all guaranteed to be faster than code compiled with -O2 (and very probably is larger), yes
22:18:19 <Korollary> Good projects are written in every language. It's a tool.
22:18:44 <jcreigh> fantasma: "modern"? Well, he's working on new editions which use a fictional RISC arch instead. :)
22:18:45 <zbrown> Always a good time watching the weird kids and the plastered kids come in from a rough night of being tools ;)
22:19:11 <merus> I wish Knuth would just get on with finishing it before he dies
22:19:37 <jcreigh> fantasma: are you refering to the use of MIX?
22:19:56 <fantasma> jcreigh: yeah, in a way
22:20:18 <merus> MIX isn't a bad architecture, though...
22:20:22 <Gwern> rahikkala: I sort of meant Bad Things as in programs blowing up and killing people with flying shrapnel
22:20:37 <jcreigh> I should really read TAOCP....I've been ~40 pages in for about a year now...
22:20:40 <fantasma> i mean, if his books are the definitive source for the content then I can deal with MIX
22:21:01 <merus> A lot of the content isn't really bound to MIX... which I think was the point.
22:21:52 <fantasma> question rephrase: anything better? :D
22:21:53 <rahikkala> Gwern: You'll want to use the specifically unsafe optimisation flags if you want gcc to make your programs blow up... I've heard that if -funsafe-loop-optimizations -ffast-math won't do it, -ftracer will :p
22:23:21 <rahikkala> Gwern: -fnew-ra in older versions of gcc is famous for its shrapnel-producing properties
22:26:02 <glguy> ?where status
22:26:03 <lambdabot> I know nothing about status.
22:26:04 <glguy> ?where stats
22:26:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
22:26:18 <fax> (or $ map (messageEq $ UnExpect "end of input") (errorMessages err))
22:26:23 <fax> yeah I didnt really expect that to work..
22:26:38 <glguy> hpaste wrote the longest lines, averaging 73.2 letters per line.
22:26:39 <glguy> #haskell average was 45.3 letters per line.
22:27:47 <revence> Eh, y'all how do I construct construct an IO monad? Or is it always supposed to be begun by the system?
22:28:27 <Korollary> You mean how to construct a value of type IO Int for example?
22:28:31 <revence> I figured out a way I think is rather sinful, but it was the only way I could convert a Bool-returner to an (IO Bool)- returner
22:28:45 <revence> Yes
22:28:58 <Korollary> return does it
22:29:11 <revence> Not if you are in a pure func.
22:29:18 <revence> like the following:
22:29:51 <revence> let gimmeIOInt 2 = return 2 -- this won't give you a monad, 'cause you aren't in an action.
22:30:12 <Korollary> if you are not in a do-block, it is of no use anyway.
22:30:12 <rahikkala> > (return 2) :: IO Int
22:30:14 <lambdabot>  <IO Int>
22:30:26 <fantasma> dons talks to him/herself a lot. He/She wrote over 5 lines in a row 141 times!
22:30:37 <revence> Oh! Lemme try that ...
22:31:32 <revence> Oh, sure. It works. Know what I had done?
22:31:36 <fax> :t (,,,)
22:31:38 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
22:31:43 <fax> wow :D
22:31:46 <fantasma> > foldr (.) id (replicate 99999999 (+1)) 5
22:31:48 <lambdabot>  Exception: stack overflow
22:31:56 <fax> > (,,,) 1 2 3
22:31:56 <lambdabot>  Add a type signature
22:32:02 <fax> > (,,,) 1 2 3 4
22:32:03 <lambdabot>  (1,2,3,4)
22:32:10 <rahikkala> revence: ... no?
22:32:10 <revence> I had turned the func into an action by calling putStr "" in there
22:32:11 <rashakil> :t (,,)
22:32:13 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
22:32:15 <rashakil> :t (,)
22:32:18 <lambdabot> forall a b. a -> b -> (a, b)
22:32:18 <fantasma> > unfoldr (\x y -> Just 1) 1
22:32:19 <lambdabot>      The lambda expression `\ x y -> ...' has two arguments,
22:32:19 <lambdabot>     but its type...
22:32:20 <rashakil> :t ()
22:32:22 <lambdabot> ()
22:32:29 <fax> > () () 1
22:32:30 <lambdabot>  Couldn't match expected type `() -> t1 -> t'
22:32:36 <fax> > () $() 1
22:32:37 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `()'
22:33:01 <fax> > (,) ((,) 1) 1
22:33:02 <lambdabot>  Add a type signature
22:33:04 <fax> > (,) ((,) 1 1) 1
22:33:06 <lambdabot>  ((1,1),1)
22:33:59 <revence> Okay, gotta go now.
22:34:29 <fax> > map2 (,) [1..] [1..]
22:34:30 <revence> :t (,,,,,,,)
22:34:31 <lambdabot>   Not in scope: `map2'
22:34:33 <lambdabot> forall a b c d e f g h. a -> b -> c -> d -> e -> f -> g -> h -> (a, b, c, d, e, f, g, h)
22:34:38 <fax> > LiftM2 (,) [1..] [1..]
22:34:39 <lambdabot>   Not in scope: data constructor `LiftM2'
22:34:55 <rashakil> > zipWith (,) [1..] [1..]
22:34:57 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,1...
22:35:04 <fax> COol
22:35:18 <rashakil> > zip [1..] [1..]
22:35:19 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,1...
22:35:27 <fax> wow
22:35:32 <fax> what
22:35:40 <fax> > zip "abcdef" "123456"
22:35:42 <lambdabot>  [('a','1'),('b','2'),('c','3'),('d','4'),('e','5'),('f','6')]
22:35:46 <fax> oh
22:36:28 <glguy> > join (,) `fmap` [1..]
22:36:30 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,1...
22:37:14 <fax> > reverse [1..]
22:37:18 <lambdabot> Terminated
22:37:22 <fax> :(
22:37:51 <glguy> > reverse [False .. ]
22:37:52 <lambdabot>  [True,False]
22:37:55 <jcreigh_> hey, cool, you can pattern match on records!
22:39:09 <rashakil> does the number exist where it's zero point zero repeated, with a 1 as the last digit?
22:39:15 <rashakil> > last [0.0000..1]
22:39:17 <lambdabot>  1.0
22:39:27 <jcreigh_> "last digit"?
22:39:52 <rashakil> yeah, it's 1 - 0.999... :)
22:40:36 <ibid> rashakil: 0.001 is one, 0.000001 is another :)
22:41:10 <Cale> rashakil: no, infinite decimal expansions don't have a last digit
22:41:11 <fax> whats at the end of [1..]?
22:41:23 <Cale> rashakil: that's what makes them infinite
22:41:25 <fax> > last [1..]
22:41:29 <lambdabot> Terminated
22:41:37 <jcreigh_> fax: it's an infinite list.
22:41:47 <fax> > [1..] !! 99999999999999
22:41:49 <rashakil> Cale: but lambdabot disagrees! ;-)
22:41:51 <lambdabot> Terminated
22:41:51 <Gwern> > [1.99..] == 2
22:41:52 <lambdabot>   add an instance declaration for (Num [t])
22:41:55 <fax> > [1..] !! 99999
22:41:56 <lambdabot>  100000
22:42:17 <Cale> rashakil: hehe, your expression is equivalent to last [0..1]
22:42:35 <fax> > let add a b = [a..] !! b in add 5 6
22:42:36 <lambdabot>  11
22:42:36 <Gwern> > (1+ [.99..]) == 2
22:42:37 <lambdabot>  Parse error
22:42:39 <fax> :D
22:43:24 <fax> let add a b = [a..] !! b in let mul a b = ?
22:44:00 <fax> let add a b = [a..] !! b in let mul a b = map (add a) [b..] !! b in mul 5 3
22:44:06 <fax> > let add a b = [a..] !! b in let mul a b = map (add a) [b..] !! b in mul 5 3
22:44:07 <lambdabot>  11
22:44:12 <fax> hm :/
22:44:18 <fax> > let add a b = [a..] !! b in let mul a b = (map (add a) [b..]) !! b in mul 5 3
22:44:20 <lambdabot>  11
22:44:27 <fax> what
22:44:54 <rashakil> 5 + 3 + 3 = 11
22:45:04 <fax> oh
22:46:23 <rashakil> > let add a b = [a..] !! b in let mul a b = iterate (add a) 0 !! b in mul 5 3
22:46:24 <lambdabot>  15
22:46:32 <fax> yes :D
22:48:15 <fax> > let add a b = [a..] !! b in let mul a b = iterate (add a) 0 !! b in let factorial a = (foldr mul (map (mul a) [0..])) in factorial 4
22:48:15 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Int]'
22:48:19 <fax> :S
22:50:20 <fax> > let add a b = [a..] !! b in let mul a b = iterate (add a) 0 !! b in let factorial a = foldr mul 1 [1..a] in factorial 4
22:50:21 <lambdabot>  24
22:50:33 <rashakil> > let add a b = [a..] !! b in let mul a b = map (add a) [b..] !! b in let factorial a = product [1..a] in let product = foldl add 3.14 in factorial 4
22:50:34 <lambdabot>  24
22:50:58 <fax> :O
22:51:02 <fax> 3.14 ?!?!
22:51:23 <rashakil> for better accuracy, use 3.142
22:51:32 <fax> what is that
22:53:14 <fax> wtf :D
22:53:54 <fax> mul and product are never used
22:54:03 <fax> so you can change them to anything?
22:56:06 <fax> > let add a b = [a..] !! b in let mul a b = iterate (add a) 0 !! b in let factorial a = foldr mul 1 [1..a] in factorial 5
22:56:07 <lambdabot>  120
22:56:11 <fax> > let add a b = [a..] !! b in let mul a b = iterate (add a) 0 !! b in let factorial a = foldr mul 1 [1..a] in factorial 6
22:56:12 <lambdabot>  720
22:56:16 <fax> > let add a b = [a..] !! b in let mul a b = iterate (add a) 0 !! b in let factorial a = foldr mul 1 [1..a] in factorial 10
22:56:20 <lambdabot> Terminated
22:56:24 <fax> ahaha
22:57:31 <fax> can you define a function which is applied like, "5 f" ?
22:58:18 <rashakil> > let (!) x = product [1..x] in (5 !)
22:58:19 <lambdabot>  120
22:58:30 <fax> cool
22:58:40 <rashakil> That's not really Haskell though.
22:58:47 <fax> no?
22:59:48 <fax> why nt?
23:00:06 <rashakil> The Haskell 98 interpretation of (5 !) is that it's equivalent to (\y -> (!) 5 y).
23:01:10 <nornagon> ghc accepts (5!) but not 5!
23:03:39 <rashakil> Don't believe the people who think that ! is a function that turns 5 into 120.  Rather, 5 is a function that turns factorial signs into 120.
23:04:48 <Gwern> gaah. why did the darcs dudes have to hardwire "_darcs" into just about every fircking filepath?
23:04:51 <Cale> Haskell is whatever GHC accepts at any given moment :)
23:04:57 <rashakil> that is true
23:05:12 <Cale> Plus a bunch of other stuff, some of which isn't even implemented
23:05:13 <Gwern> is there an easy way to define a read-only global variable? :(
23:05:35 <Cale> Gwern: uh, define something at the top level
23:05:41 <Cale> x = 5
23:05:50 <Gwern> ah. hmm, that might work
23:07:02 <Gwern> ok : the use-functions-and-monads approach to fixing darcs's reliance on _darcs -  ...quack experiment failed
23:07:04 <fax> > let add a b [a..] !! b in zipWith add [1..] [1..]
23:07:05 <lambdabot>  Parse error
23:07:14 <fax> > let add a b = [a..] !! b in zipWith add [1..] [1..]
23:07:15 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
23:07:34 <Gwern> next quack coding experiment:  define it at the top level and add a bunch of imports, and do some search and replaces
23:08:14 <fax> where is the shortest haskell prime seive possible?
23:08:27 <fax> http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell) this?
23:08:29 <lambdabot> Title: Sieve of Eratosthenes (Haskell - LiteratePrograms
23:09:09 <rashakil> fax: Oh I thought you wanted a short version of http://hackage.haskell.org/trac/haskell-prime
23:09:12 <lambdabot> Title: Haskell Prime - Trac
23:09:27 <Cale> > nubBy (\x y -> y `mod` x /= 0) [2..]
23:09:31 <lambdabot> Terminated
23:09:52 <Cale> er, oops
23:10:15 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
23:10:17 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:10:21 <fax> :D
23:11:32 <fax> > let add a b = [a..] !! b in zipWith add [1..] nubBy (\x y -> y `mod` x == 0) [2..]
23:11:33 <lambdabot>  Couldn't match expected type `[Int]'
23:11:39 <fax> > let add a b = [a..] !! b in zipWith add [1..] $ nubBy (\x y -> y `mod` x == 0) [2..]
23:11:41 <lambdabot>  [3,5,8,11,16,19,24,27,32,39,42,49,54,57,62,69,76,79,86,91,94,101,106,113,122...
23:17:47 <QtPlatypus> :type nubBy
23:17:57 <QtPlatypus> @type nubBy
23:17:59 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
23:35:43 <rashakil> > let diagonal ((x:_):xss) = x : diagonal (map tail xss) in diagonal $ iterate (\(x:xs) -> x : filter ((/= 0) . (`mod` x)) xs) [2..]
23:35:45 <lambdabot>  [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
23:53:47 <cragwolf> :t fromIntegral
23:53:50 <lambdabot> forall a b. (Num b, Integral a) => a -> b
