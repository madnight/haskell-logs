00:05:22 <dmwit> ?hoogle setbuffering
00:05:23 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
00:05:44 <dmwit> ?hoogle getbuffering
00:05:44 <lambdabot> IO.hGetBuffering :: Handle -> IO BufferMode
00:06:19 <dmwit> ?hoogle Handle
00:06:19 <lambdabot> System.IO.Handle :: data Handle
00:06:19 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
00:06:19 <lambdabot> System.Win32.Types.HANDLE :: type HANDLE
00:06:31 <dmwit> Hum.
00:06:34 <dmwit> ?index stdin
00:06:34 <lambdabot> System.IO
00:10:29 <cragwolf> :t ShowS
00:10:31 <lambdabot> Not in scope: data constructor `ShowS'
00:11:25 <dmwit> ?index getArgs
00:11:25 <lambdabot> System.Environment
00:14:42 <dmwit> What is EOF for ghc-compiled programs?
00:14:55 <dmwit> I.e. what key should I press to tell getContents it's done?
00:15:32 <dmwit> (I tried Ctrl-D and Ctrl-Z but they didn't work.)
00:18:01 <dmwit> > filter (< 64) primes where {divides a b = b `mod` a == 0; primes = nubBy divides [2..]}
00:18:02 <lambdabot>  Parse error
00:18:26 <dmwit> > let divides a b = b `mod` a == 0; primes = nubBy divides [2..] in filter (< 64) primes
00:18:30 <lambdabot> Terminated
00:18:47 <dmwit> > let divides a b = b `mod` a == 0; primes = nubBy divides [2..] in takeWhile (< 64) primes
00:18:49 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61]
00:19:44 <dmhouse> Ooh, pretty.
00:19:50 <dmhouse> ?docs nubBy
00:19:51 <lambdabot> nubBy not available
00:19:57 <rahikkala> @src nubBy
00:19:58 <lambdabot> nubBy eq []             =  []
00:19:58 <dmhouse> ?docs Data.List.nubBy
00:19:58 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:19:58 <lambdabot> Data.List.nubBy not available
00:21:34 <dmwit> :t ((== 0) .) .
00:21:36 <lambdabot> parse error (possibly incorrect indentation)
00:21:40 <dmwit> :t ((== 0) .) . mod
00:21:42 <lambdabot> forall a. (Integral a) => a -> a -> Bool
00:22:24 <dmwit> > take 10 $ nubBy (((==0).).mod) [2..]
00:22:26 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
00:22:57 <dmwit> > (((==0).).mod) 2 4
00:22:59 <lambdabot>  False
00:23:08 <dmwit> ?pl \x y -> x `mod` y == 0
00:23:08 <lambdabot> flip flip 0 . ((==) .) . mod
00:23:29 <dmwit> bad
00:23:35 <dmwit> > fix flip
00:23:36 <lambdabot>  Add a type signature
00:23:53 <dmwit> > fix flip :: Int -> Int -> Int
00:23:55 <lambdabot>  <Int -> Int -> Int>
00:24:39 <dmwit> > let f x y = 10*x + y in fix flip f 3 5
00:24:40 <lambdabot>   add an instance declaration for (Num (t -> t -> t))
00:26:13 <dmwit> ?pl fix flip
00:26:13 <lambdabot> fix flip
00:26:20 <dmwit> ?pl flip flip flip flip
00:26:20 <lambdabot> flip flip flip
00:26:32 <dmwit> ?pl flip flip flip flip flip flip flip
00:26:32 <lambdabot> flip flip flip
00:26:39 <dmwit> Huh.
00:26:51 <dmwit> ?pl flip flip flip flip flip flip
00:26:52 <lambdabot> flip flip flip
00:29:11 <rahikkala> > take 24 $ fix (ap (++)) "desu "
00:29:12 <lambdabot>  "desu desu desu desu desu"
00:29:46 <dmwit> 4chan?
00:30:01 <lispy> dons: is it just me, or does lambdabot ignore :t in a /msg
00:30:02 <dmwit> Or just a plain old anime fan?
00:30:41 <dmwit> lispy: it ignores :t for me, but ?type works.
00:30:56 <rahikkala> dmwit: I'm not a /b/tard, but other people on some of the IRC channels I'm on are
00:31:03 <dmwit> =(
00:31:04 <dmwit> Sorry.
00:34:33 <dancor> for testing do you usually write a fcn that you call from ghci, or can you do something cool like python if __name__ == '__main__' for testing modules
00:35:07 <lispy> dancor: most people would use smallcheck, quickcheck or hunit for testing
00:35:20 <lispy> dancor: python's trick doesn't really have an analog
00:35:33 <dancor> lispy: but even then your test code goes somewhere right
00:35:51 <lispy> dancor: well, you can use #ifdefs to hide it
00:36:07 <dancor> lispy: is it unusual to have a test fcn in there that isn't actually used in the normal executable
00:36:09 <lispy> that's fairly common with hunit users
00:36:19 <dancor> ok
00:36:52 <lispy> i need to go to bed, but i bet a some google searches could turn up some nice examplse
00:37:03 <lispy> ?google hunit example ifdef
00:37:03 <dancor> k
00:37:05 <lambdabot> http://www.geocities.com/SiliconValley/Bay/9159/dpas.pdf
00:37:40 <lispy> dancor: oh, the cabal source does it the way i'm thinking
00:37:43 <lispy> you could look at taht
00:41:23 <dons> dancor: here's an example use of QuickCheck
00:41:23 <dons> http://darcs.haskell.org/~sjanssen/thunk/tests/Properties.hs
00:41:31 <dons> you write a seperate tests module that imports the stuff you want to test
00:41:39 <dancor> ah, ok
00:41:44 <dons> then your run thtat test code from say, ghci, or runhaskell.
00:41:56 <dons> $ runhaskell tests/Properties.hs
00:41:57 <dons> read.show                : OK, 100 tests.
00:41:57 <dons> member/push              : OK, 100 tests.
00:41:58 <dons> ...
00:42:18 <dons> so none of the testcode is actually linked into the executable
00:42:55 <kzm> no isPrefixOf in Data.ByteString.Lazy.Char8?
00:42:55 <dons> (yes, that's automatically testing the core data structures of a window manager!) :-)
00:43:00 * dons <3 QC
00:43:04 <dons> kzm, hmm...
00:43:27 <dons> kzm, its the same type as .Lazy, isPrefixOf,             -- :: ByteString -> ByteString -> Bool
00:43:52 <dons> and I note it is also exported from .Lazy.Char8
00:43:59 <kzm> Oh, wait, I messed up the imports.
00:44:06 <kzm> My bad.
00:44:21 <dancor> if a gentoo haskell package refers to bug 151012
00:44:29 <dancor> where is the bug tracker
00:44:42 <dancor> this is the haskell overlay
00:45:05 <dancor> nm
00:45:28 <dancor> when there are only two possibilities, it is often best just to try them
00:53:10 <bitwiseshiftleft> question for GHC 6.6: when using GADTs with record syntax, is there a way to quantify with a type class?
00:53:21 <bitwiseshiftleft> because without using record syntax, you can say
00:53:35 <bitwiseshiftleft> data Foo where Ord a => a -> Foo
00:53:38 <bitwiseshiftleft> or something
00:53:58 <bitwiseshiftleft> but if you use record syntax, I don't know where such a statement would go
00:59:13 <kzm> ../../tally  185.81s user 4.22s system 82% cpu 3:51.72 total -- with [Char]
00:59:36 <kzm> ../../tally  9.22s user 1.98s system 39% cpu 28.049 total -- with lazy ByteString
01:01:04 <kzm> 95% reduction in CPU time, I thought that was pretty good for about ten minutes' work. :-)
01:01:31 <bitwiseshiftleft> haha
01:01:38 <bitwiseshiftleft> yeah, ByteString does that
01:01:46 <bitwiseshiftleft> ... can you run it with strict ByteString?
01:05:22 <kzm> I think the file is too big - 785Mb.
01:07:07 <bitwiseshiftleft> ah. yeah, that's kind of big
01:10:48 <malcolmw> dons: just wanted to check, are you OK with sorting out the GSoC application sometime before Monday?
01:17:42 <ulfdoz> hm, fw. checking my inventory.
01:20:13 <dons> malcolmw: i'm going to be quite busy actually. If you'd like to take over the front man role, I'd appreciate that
01:20:25 <dons> i'll be around to help
01:20:32 <malcolmw> dons: OK, I'll do the submission then
01:21:24 <malcolmw> dons after reading some of the google FAQs, i'm inclined to change some of the answers I proposed in email
01:21:51 <dons> oh, ok. yes, i've not looked at the FAQs yet. we can discuss it on soc-mentors@ if you like?
01:22:25 <malcolmw> dons: google seem to make a thing about incorporating students into the wider community, and I think they might frown on the idea of too much face-to-face contact between student and mentor
01:22:47 <dons> right. this was one of the points that came out of the summit
01:23:07 <dons> basically we want to encourage the students to get to know everyone, and become core devs if possible
01:23:08 <fuzan> ot, but no idea where else to ask... anyone know any keyboading/midi software for linux? I'd like to hook up a usb keyboard (musical keyboard) and play.
01:23:15 <dons> so they need to participate on #haskell, and on the mailing lists
01:23:21 <malcolmw> dons: yes, I can appreciate that
01:23:40 <dons> so several of last year's students are still active, which is good
01:23:55 <dons> mostly I think because we did get them talking to everyone
01:24:15 <malcolmw> dons: it was just from my experience last year of a disappearing student, I thought maybe a local face-to-face contact might have prevented that
01:24:41 <dons> that's interesting. hmm.
01:25:31 <malcolmw> but google are prepared to live with some failing projects, so maybe it doesn't matter
01:25:35 <dancor> fuzan: i just use snd-seq-midi module and then arecordmidi program
01:26:04 <malcolmw> I wonder whether a local student might be more or less inclined to engage with the wider community
01:26:13 <dons> they are, right. they planned for 50% failure originally, remember :)
01:26:19 <quicksilver> hmm. I imagined that top-level definitions were allowed to deliberate shadow imported definitions but this doesn't appear to be true.
01:26:27 <dons> well, hmm. hard to say. so we had local students at chalmers, didn't we?
01:26:41 <quicksilver> malcolmw: I would have though 'more' as long as their local contact encouraged them in the right direction
01:26:44 <malcolmw> dons: but they are making efforts to have fewer this time, or at least that is might impression
01:27:03 <quicksilver> malcolmw: but it could be 'less' if there was a strong haskell community locally and they felt less inclination, therefore, to mingle with the global one
01:27:19 <malcolmw> * fewer failures
01:27:33 <dons> right. that's the plan (always) I think. improve the success rate
01:27:41 <dons> and improve the number of people who join and become core devs
01:27:56 <dons> ok. diner time. back later!
01:29:01 <malcolmw> one important factor is that a student may feel intimidated about posting to mailing lists etc, and gentle local encouragement might help more than mentor emails
01:29:34 <malcolmw> but then again, IRC is a nice easy way in to asking questions
01:31:26 <quicksilver> there is a ByteString.hPutStrLn but no Lazy.hPutStrLn ?
01:35:28 <wkh> @pl test n = n + 3
01:35:28 <lambdabot> test = (3 +)
01:35:52 <wkh> @pl test2 n = (n >= 0) && (n <= 5)
01:35:52 <lambdabot> test2 = liftM2 (&&) (>= 0) (<= 5)
01:36:05 <dmwit> ?help hawiki
01:36:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:36:14 <dmwit> ?where ByteString
01:36:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
01:36:41 <wkh> :t liftM2 (&&)
01:36:44 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
01:36:53 <quicksilver> I was trying to convert some naive IO code to Lazy ByteStrings out of interest
01:37:11 <quicksilver> but it's not a simple case of insterting L. here and there, if lazy doesn't have hPutStrLn
01:37:15 <wkh> > liftM2 (&&) (>=0) (<=5)
01:37:17 <lambdabot>  <Integer -> Bool>
01:37:46 <wkh> @src liftM2
01:37:46 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:39:29 <quicksilver> well strict bytestring compiles
01:39:36 <quicksilver> (it has hPutStrLn)
01:39:39 <quicksilver> but it's no faster?!?
01:39:43 <quicksilver> that's very odd
01:40:40 <dmwit> Huh, I never new about the possibility of "as," like in import _ as _.
01:40:51 <dmwit> That would have saved me a lot of typing... =P
01:42:11 <quicksilver> ack
01:42:16 <quicksilver> it is quite a bit faster :)
01:42:42 <quicksilver> I didn't realise that between ghc 6.4 and ghc 6.6, the convention changed from ./a.out to <filename>
01:42:47 <quicksilver> I was running the old executable
01:42:53 <malcolmw> ByteString makes code 10x faster in ghc, but 6x slower in nhc98 :-)
01:43:04 <quicksilver> still 4 seconds to sort a file, though
01:43:13 <quicksilver> a file which takes 1.2 seconds to sort with /usr/bin/sort
01:43:58 <malcolmw> quicksilver: did you switch on -O2?
01:44:04 <quicksilver> malcolmw: yes
01:44:19 <quicksilver> it was 10 seconds with String, 4 seconds with strict ByteString
01:44:25 <quicksilver> 1.2 seconds with /usr/bin/sort
01:44:35 <dancor> is this mostly because there is no in-place qsort?
01:44:39 <malcolmw> quicksilver: best wait for dons to get back from dinner and ask him
01:44:44 <quicksilver> dancor: possibly
01:44:53 <quicksilver> malcolmw: *nod*
01:45:13 <quicksilver> dancor: it's a large-file algorithm, so it sorts smallish chunks into temporary files
01:45:18 <quicksilver> dancor: and then merges the temporary files
01:45:23 <quicksilver> (that's what /usr/bin/sort does, too)
01:45:34 <dancor> cool
01:46:06 <quicksilver> dons: when you come back, remind me to ask you about my sort program
01:47:05 <quicksilver> dancor: it may be that for large files, the haskell program gets close to the /usr/bin one, really I should find a much bigger file and test it
01:47:10 <wkh> :t print . sum . map read . lines =<< getContents
01:47:13 <lambdabot> IO ()
01:47:41 <dancor> rainbow tables are huge files that have to be sorted
01:47:52 <quicksilver> rainbow tables?
01:47:54 <dancor> i wonder how haskell would do at rainbow table generation
01:48:24 <dancor> http://en.wikipedia.org/wiki/Rainbow_table
01:48:25 <lambdabot> Title: Rainbow table - Wikipedia, the free encyclopedia
01:48:40 <dancor> hash-breaking
01:49:54 * quicksilver nods
01:50:59 <wkh> @hoogle loopU
01:50:59 <lambdabot> No matches found
01:51:01 <wkh> :(
01:51:05 <dons> quicksilver: hmm, not sure why hPutStrLn is missing. odd. its just , hPut stdout ps >> hPut stdout (singleton 0x0a)
01:51:10 <dons> s/stdout/h/
01:51:13 <wkh> @hoogle loop
01:51:14 <lambdabot> Control.Arrow.loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
01:51:14 <lambdabot> Data.Graph.Inductive.Example.loop :: Gr Char ()
01:51:14 <lambdabot> Data.Graph.Inductive.Example.loop' :: IO (SGr Char ())
01:51:49 <quicksilver> dons: I'm trying to reimplement /usr/bin/sort
01:51:55 <wkh> @hoogle choose
01:51:56 <lambdabot> Test.QuickCheck.choose :: Random a => (a, a) -> Gen a
01:52:03 <dons> iirc the best version uses lazy bytestrings
01:52:21 <quicksilver> dons: for a particular file (2 meg) I get about 10 seconds runtime with String, 4 seconds with strict ByteString. /usr/bin takes about 1.2 seconds
01:52:37 <dons> I think this was it:
01:52:38 <dons> import Data.ByteString.Lazy as B
01:52:38 <dons> import Data.ByteString.Lazy.Char8 as B
01:52:38 <dons> import qualified Data.List as L
01:52:39 <dons> main = putStr . unlines . sort . lines =<< getContents
01:53:16 <dons> oh no, that doesn't look right
01:53:18 <quicksilver> dons: surely missing some B. s?
01:53:44 <dons> right. I think that's it. just add the missing B.'s
01:53:50 <quicksilver> dons: anyhow I'm trying to write the version which can cope with larger-than-memory
01:54:01 <dons> ah ok
01:54:06 <quicksilver> dons: but I should clearly have that one around to compare against
01:54:23 <dons> from what I recall, lazy bytestrings were a reasonable win on the in-memory sort
01:54:30 <dons> be sure to use ghc 6.6, too.
01:54:38 * quicksilver nods. Just upgraded this morning.
01:54:52 <dons> (the head is even faster still, if that's of concern)
01:54:53 <quicksilver> I'm just running it on a 20x bigger file to see how the figures work out then
01:55:11 <dons> ah also, I was using the unstable (stream fused) fps, not the version in base
01:55:31 <dons> which uses array fusion, a bit slower. (and a bit slower in general).
01:55:32 <quicksilver> not sure fusion makes much difference to my algorithm
01:55:37 <dons> right.
01:56:48 <quicksilver> hmm bigger file. String version takes 3:37 user time and 28sec system time
01:56:57 <quicksilver> /usr/bin sort takes 3 seconds and 2 seconds
01:57:03 <quicksilver> just running strict bytestring version now
01:57:54 <mux> omg, everytime I use Parsec, the exact same feeling overwhelms me: IT'S FUCKING GOOD
01:58:08 <mux> it makes any other alternative to parsing look like a half-broken toy
01:58:12 <mux> it fills me with joy.
01:58:35 * kfish hugs combinators
01:58:44 <quicksilver> Strict Bytestring: 1:10 user, 16 system
01:59:00 <quicksilver> so almost a 3x speed but still orders of magnitude short of /usr/bin/sort
01:59:19 <wkh> from the instructions for building data.bytestring:
01:59:21 <wkh> "./Setup.hs configure --prefix=/f/g"
01:59:28 <wkh> what value do i provide for --prefix?
02:02:26 <quicksilver> dons: hmm I don't understand your version. Do you have a version of lines :: ByteString -> [ByteString] that I don't have?
02:07:17 <wkh> uh, does Data.ByteString come standard with GHC 6.6?
02:07:36 <norpan> yes
02:08:08 <wkh> i built and installed it by hand iwth the Cabal thing and now it says Data.ByteString is found in multiple packages. how do i uninstall the thing i installed? :(
02:08:56 <dancor> ghc-6.6: unknown package: posix
02:09:00 <dancor> but i'm on linux
02:09:03 <dancor> @where posix
02:09:04 <lambdabot> I know nothing about posix.
02:09:15 <dancor> is linux not posix enough
02:09:21 <Syzygy-> @where Posix
02:09:22 <lambdabot> I know nothing about posix.
02:09:53 <dancor> i was trying to get the gentoo app-editors/yi-20050821 going
02:10:02 <dancor> i guess i should just go darcs
02:14:43 <dons> quicksilver: the optimal set up is to use the unstable fps streams versions, its faster across the board. however to actually use it you have to rebuild ghc's base lib. regarding 'lines', hmm, use lazy bytestrings? to diagnose things any further i'd need to see the code
02:16:40 <quicksilver> dons: I was talking about your one-liner
02:17:03 <dons> using .Lazy ?
02:17:05 <quicksilver> dons: I didn't understand you your one-liner could work, since I don't have 'lines' or indeed 'unlines' for lazy bytestring
02:17:09 * quicksilver nods
02:17:21 <dons> lines and unlines are in .Lazy.Char8
02:17:25 <quicksilver> ah!
02:17:39 <quicksilver> this could explain my confusion :)
02:18:08 <dons> ah yes, i see i had an unrecorded darcs change, main = B.putStr. B.unlines . L.sort . B.lines =<< B.getContents
02:18:25 <dons> that's the version (using fps-unstable , not the one you've got) that we used in the paper
02:18:28 * quicksilver nods
02:18:39 <quicksilver> Lazy also doesn't offer hGetLine
02:18:49 <quicksilver> so it's hard for me to instantly refactor the code to use Lazy
02:18:53 <kzm> I wonder if string stuff should be removed from the Prelude (since one usually uses either String *or* ByteString)
02:19:00 <quicksilver> I'll hpaste the code in case you're interested
02:19:12 <kzm> So words, lines, etc could be in a separate Data.String module.
02:19:18 <dons> yeah, the idea is to use lines =<< hGetContents
02:19:23 <dons> since its lazily reading anyway
02:19:26 <mux> maybe we need the String type class
02:19:40 <kzm> mux: there is one, forget by whom.
02:19:47 <kzm> Stringable, I think.
02:19:51 <mux> ah cool
02:20:07 <hpaste>  quicksilver pasted "ByteString sort" at http://hpaste.org/892
02:20:13 <mux> that may be nice to have for Haskell'
02:20:31 <mux> so that we can easily exchange string backend while keeping the same interface
02:21:07 <quicksilver> mux: although it raises the problem about selecting which typeclass to use when nothing appears in the type to determine the class :)
02:22:14 <mux> quicksilver: I don't get it, would you have an example?
02:22:30 <kzm> It's not very straightforward how to do this right, unfortunately.
02:22:33 <quicksilver> mux: sort :: FilePath -> FilePath -> IO ()
02:22:37 <mux> quicksilver: oh
02:22:43 <araujo> morning
02:22:45 <mux> I guess String is a reasonable default
02:22:57 <quicksilver> mux: is an example of something which might use either String or ByteString under the hood
02:23:00 <mux> a bit like with defaulting to Int
02:23:04 <quicksilver> but you can't 'choose' in the normal way
02:23:14 <quicksilver> you can use dummy parameters and asTypeOf
02:23:17 <quicksilver> not very elegant though :)
02:23:21 * mux nods
02:23:36 <quicksilver> sort (undefined :: LazyByteString) "foo" "foo.sorted"
02:24:16 <quicksilver> or maybe you don't. Maybe you export sortLB and sortSB *shrug* maybe it's not a very good example
02:24:35 <quicksilver> maybe if you aren't feeding it a parameter you don't care which implementation it uses and you just expect it to use the best
02:25:07 <quicksilver> dons: hmm OK, I'd have to refactor the code for that
02:25:28 <quicksilver> dons: intuitively it seems like the 'correct' solution to my code is strict chunks, though
02:25:36 <quicksilver> dons: and then lazy for the second section (the file-merge part)
02:26:57 <arjanoosting> ifvoid: I just saw an upgrade from hal 0.5.8.1-6.1 to hal 0.5.8.1-7, with some changes for cd media, happening on my laptop
02:27:09 <arjanoosting> arjanoosting: CRAP
02:27:20 <arjanoosting> wrong channel
02:27:30 <dancor> when i run yi not from install directory: yi: panic! (the 'impossible' happened)
02:27:34 <dancor>   (GHC version 6.6 for i386-unknown-linux):
02:27:34 <dancor>         loadObj: failed
02:27:42 <dancor> work from install dir
02:28:19 <dancor> i've tried copying Yi/ and {Yi,}Config.hs to ~/.yi
02:28:24 <dancor> not sure how to debug
02:28:31 <dons> dancor: try the darcs repo version
02:28:41 <dancor> of what?  i'm using darcs yi
02:30:03 <dancor> i had to add a _ in one place: gtk/Yi/UI.hs:110:10: Constructor `Key' should have 10 arguments, but has been given 9
02:30:15 <dancor> but other than that i'm vanilla
02:34:59 <dancor> strangest thing.. i started deleting things from a copy dir and once i deleted vty/
02:35:07 <dancor> Yi/Editor.hs:46:22: Could not find module `Yi.UI':
02:35:21 <dancor> but when i cp -r ../yi/vty .   then
02:35:26 <dancor> Yi/Core.hs:892:7: Not in scope: data constructor `GHC_LIBDIR'
02:37:12 <dancor> i've done   ./Setup.py install   and my ghc 6.6 has been otherwise fine
02:37:45 <dancor> install just copied two files though
02:37:59 <dancor> yi and gtk-yi.  it should have done something with vty/ it seems like
02:43:28 <dancor> and the panic is contingent on the existence of dist/
02:43:33 <dancor> in pwd
02:47:36 <dancor> i guess i can set up a wrapper to record pwd, cd to yi dir and start with pwd/ prefixed to args without -?
02:48:45 <dancor> ah, 'including dynamic components, you need ghc-6.4'
02:51:53 <wkh> @pl improve y = (y+x/y)/2
02:51:54 <lambdabot> improve = (/ 2) . ap (+) (x /)
02:52:19 <wkh> point-free programming can be a great way to turn even a simple expression into a confusing one
02:52:55 <quicksilver> wkh: yup :)
02:53:17 <quicksilver> wkh: mainly when you duplicate arguments
02:53:37 <wkh> @pl improve x y = (y+x/y)/2
02:53:37 <lambdabot> improve = flip flip 2 . ((/) .) . ap (+) . (/)
02:53:40 <quicksilver> wkh: lambdabot has two approachs for duplicating arguments, basically: join and ap, in the r-> monad
02:53:52 <wkh> quicksilver: can you say job security?
02:53:55 <quicksilver> both are a little obfuscating for most people :)
02:53:57 <quicksilver> ;)
02:57:50 <dancor> where do i see a list of possible flags to cabal ./Setup build
02:58:10 <dancor> ./Setup build help only lists -h and -v, missing e.g. --with-ghc
03:02:51 <wkh> > let palindromep s = str == reverse str where str = map Char.toLower $ filter Char.isAlpha s in palindromep "Madam, I'm Adam"
03:02:52 <lambdabot>  True
03:02:56 <wkh> higher-order functions ftw
03:03:42 <wkh> @pl palindromep s = str == reverse str where str = map Char.toLower $ filter Char.isAlpha s
03:03:43 <lambdabot> (line 1, column 46):
03:03:43 <lambdabot> unexpected "="
03:03:43 <lambdabot> expecting variable, "(", operator, "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or end of input
03:04:29 <quicksilver> @pl can't do where clauses
03:04:29 <lambdabot> can't do where clauses
03:04:32 <dancor> @pl \s -> str == reverse str where str = map Char.toLower $ filter Char.isAlpha s
03:04:32 <lambdabot> (line 1, column 36):
03:04:33 <lambdabot> unexpected "="
03:04:33 <lambdabot> expecting variable, "(", operator, "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or end of input
03:05:16 <quicksilver> @pl palindromep s = let str = map Char.toLower s in str == reverse str
03:05:17 <lambdabot> palindromep = ap (==) reverse . fix . const . (map Char .) . toLower
03:05:41 <quicksilver> @pl palindromep s = let str = map Char.toLower $ filter Char.isAlpha s in str == reverse str
03:05:41 <lambdabot> palindromep = ap (==) reverse . fix . const . map Char . toLower . (filter Char .) . isAlpha
03:05:46 <wkh> stupid haskell tricks
03:06:12 <quicksilver> :t fix . const
03:06:13 <wkh> i can think in filter and map for simple problems
03:06:14 <wkh> go me
03:06:15 <lambdabot> forall a. a -> a
03:06:28 <quicksilver> wth does fix . const do ?
03:06:35 <quicksilver> > fix . const 5
03:06:36 <lambdabot>   add an instance declaration for (Num (a -> a))
03:06:40 <quicksilver> > fix . const $ 5
03:06:42 <lambdabot>  5
03:06:44 <quicksilver> I thought so
03:06:48 <quicksilver> > fix . const $ "hello world"
03:06:50 <lambdabot>  "hello world"
03:06:53 <quicksilver> stupid LB :P
03:06:54 <dancor> that's great
03:07:02 <wkh> even the humble id function can be obfuscated
03:07:21 <quicksilver> there are only two functions of true type forall a . a -> a
03:07:36 <quicksilver> and I didn't think I was going to be tilt
03:07:38 <wkh> @hoogle forall a . a -> a
03:07:38 <lambdabot> Hoogle Error: Parse Error: Unexpected character '. a -> a'
03:07:48 <wkh> @hoogle a -> a
03:07:49 <lambdabot> Prelude.id :: a -> a
03:07:49 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
03:07:49 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
03:08:14 <dancor> what is tilt
03:08:19 <therp> quicksilver: id and (const undefined)?
03:08:22 <quicksilver> tilt x = undefined
03:08:26 <quicksilver> therp: right
03:08:39 <quicksilver> more pragmatic is tilt x = error "tilt"
03:08:43 <quicksilver> but, yes
03:09:23 <dancor> that's a great name
03:09:54 <quicksilver> it's a traditional CS name for a program which diverges
03:09:59 <quicksilver> I presume it derives from pinball
03:10:11 <eulero> quicksilver: I think so
03:10:34 <therp> 'tilt' is new to me.
03:11:15 <dancor> @hoogle tilt
03:11:16 <lambdabot> No matches found
03:11:41 <wkh> @hoogle some
03:11:41 <lambdabot> Data.Generics.Schemes.something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
03:11:41 <lambdabot> Data.Generics.Schemes.somewhere :: MonadPlus m => GenericM m -> GenericM m
03:11:41 <lambdabot> System.Console.Readline.setIgnoreSomeCompletionsFunction :: Maybe ([String] -> IO [String]) -> IO ()
03:12:00 <dancor> @hoogle hoogle
03:12:01 <lambdabot> No matches found
03:13:01 <wkh> @src foldr1
03:13:02 <lambdabot> foldr1 _ [x]    = x
03:13:02 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
03:13:02 <lambdabot> foldr1 _ []     = undefined
03:13:03 <therp> I tried to hoogle 'sequence' recently and hoogle inserts "lambdabot says: http://sequence.complete.org" that's nice
03:13:05 <lambdabot> Title: The Haskell Sequence | News about Haskell
03:13:32 <wkh> :t undefined
03:13:35 <lambdabot> forall a. a
03:13:45 <wkh> > undefined + 2
03:13:47 <lambdabot>  Undefined
03:14:18 <wkh> > undefines*10000000000000000000000000000000000000000000000000000000
03:14:19 <lambdabot>   Not in scope: `undefines'
03:14:22 <wkh> > undefined*10000000000000000000000000000000000000000000000000000000
03:14:23 <lambdabot>  Undefined
03:14:26 <wkh> TIMES A JILLION
03:14:37 <wkh> i bet that made dons's's's's's box explode.
03:14:54 <quicksilver> there are actually two variations on the tilt for a->a
03:15:03 <quicksilver> there's undefined and \x -> undefined
03:15:24 <quicksilver> but fix at worst produces the latter, never the former
03:16:35 <wkh> :t scanl1
03:16:37 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
03:16:49 <wkh> > scanl1 (*) [1..5]
03:16:51 <lambdabot>  [1,2,6,24,120]
03:16:54 <wkh> > scanl1 (*) [1..]
03:16:56 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
03:17:12 <dancor> > "unicode • unicode"
03:17:14 <lambdabot>  "unicode \8226 unicode"
03:17:23 <dancor> is that normal
03:17:33 <dancor> > putStrLn "unicode • unicode"
03:17:35 <lambdabot>  <IO ()>
03:18:21 <wkh> > scanl1 id [1..5]
03:18:22 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
03:18:22 <lambdabot>     Probabl...
03:18:54 <wkh> > scanl1 (\x y -> [x,y]) [1..5]
03:18:55 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
03:18:56 <lambdabot>       Expected...
03:19:55 <wkh> > scanl1 (:) [1..5]
03:19:56 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
03:19:56 <lambdabot>       Expected...
03:20:07 <quicksilver> wkh: these things are not of type a -> a -> a
03:20:34 <quicksilver> scanl1 (++) . map (:[]) $  [1..5]
03:20:38 <quicksilver> > scanl1 (++) . map (:[]) $  [1..5]
03:20:39 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
03:21:01 <wkh> > map (:[]) $ [1..5]
03:21:02 <lambdabot>  [[1],[2],[3],[4],[5]]
03:21:14 <quicksilver> the monkey combinator! always good value
03:21:18 <bakert> I have a record type.  I'd like to add the concept of addition to the type.  But it's not in any sense a number.  What's the "best" way to go about that?
03:21:33 <quicksilver> bakert: just define a function
03:21:46 <quicksilver> bakertsFunkyAddition :: type -> type -> type
03:21:51 <bakert> yeah that's what i was leaning to.
03:21:59 <bakert> thanks.
03:22:18 <bakert> just wanted to make sure there wasn't something clever i should be doing.
03:22:25 <wkh> :t (.) . (.)
03:22:27 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:22:43 <wkh> we should sit down and collect the names of combinators with funny names
03:22:57 <wkh> boobie combinator: funny. monkey: funny. Y: intensely unfunny
03:23:15 <quicksilver> there are a couple on the wiki
03:23:38 <quicksilver> :t ((:[])>>=)
03:23:40 <lambdabot> forall a b. ([a] -> a -> b) -> a -> b
03:24:00 <quicksilver> :t ((:[])=<<)
03:24:02 <lambdabot> forall a. [a] -> [a]
03:27:45 <wkh> @pl \f g h (m,n,p) -> (f m, g n, h p)
03:27:46 <lambdabot> (line 1, column 12):
03:27:46 <lambdabot> unexpected ","
03:27:46 <lambdabot> expecting letter or digit, operator or ")"
03:27:46 <lambdabot> ambiguous use of a non associative operator
03:29:44 <quicksilver> @pl \f g h -> \(m,n,p) -> (f m, g n, h p)
03:29:45 <lambdabot> (line 1, column 16):
03:29:45 <lambdabot> unexpected ","
03:29:45 <lambdabot> expecting letter or digit, operator or ")"
03:29:45 <lambdabot> ambiguous use of a non associative operator
03:30:01 <quicksilver> @pl \(m,n,p) -> (f m, g n, h p)
03:30:01 <lambdabot> (line 1, column 6):
03:30:02 <lambdabot> unexpected ","
03:30:02 <lambdabot> expecting letter or digit, operator or ")"
03:30:02 <lambdabot> ambiguous use of a non associative operator
03:30:09 <quicksilver> @pl \ (m,n,p) -> (f m, g n, h p)
03:30:09 <lambdabot> (line 1, column 7):
03:30:10 <lambdabot> unexpected ","
03:30:10 <lambdabot> expecting letter or digit, operator or ")"
03:30:10 <lambdabot> ambiguous use of a non associative operator
03:30:12 <quicksilver> !?
03:30:53 <QtPlatypus> @pl (\m n p) -> ((f m),(g n),(h p))
03:30:57 <lambdabot> (line 1, column 8):
03:31:01 <lambdabot> unexpected ")"
03:31:02 <quicksilver> Oh
03:31:05 <lambdabot> expecting pattern or "->"
03:31:11 <quicksilver> it can do 2-tuples but not 3-tuples
03:31:21 <earthy> Q: 'How does one recognize a pubescent haskeller?' A: 'He smirks at the sight of forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c'
03:33:20 <wkh> narrow-audience humor is the sweetest
03:33:47 <CloudiDust> Hi all, I've recently finished my personal translation of SimonPJ's Beautiful Concurrency into Chinese, and I wanna know whether I can put this translation on my blog. And in general, can I post my translations of research papers?
03:33:53 <bakert> Is there a way to pattern match against (somestring ++ "," ++ otherstring) ?
03:35:26 <earthy> cloudidust: in general, no you can't. *however*: many researchers are very approachable, and I can't imagine them not being flattered by the translation
03:35:38 <earthy> so, ask Simon PJ. :)
03:35:57 <bakert> depends what you mean by "can't", of course.  but i think asking is your best bet.
03:36:10 <dancor> anarchy++
03:36:29 <dancor> @karma anarchy
03:36:29 <lambdabot> anarchy has a karma of 2
03:36:31 <CloudiDust> Oh thanks. :)
03:36:33 <dancor> nice
03:36:56 <bakert> very nice.  but not as nice as splitting a string on the first comma in a pattern match.  can you do that?
03:37:13 <bakert> f (s1 ++ "," ++ s2) = blah
03:37:14 <nominolo> ?karma democracy
03:37:14 <lambdabot> democracy has a karma of 0
03:37:16 <bakert> doesn't work
03:37:26 <earthy> you can't
03:37:29 <bakert> shame
03:37:31 <earthy> not without views
03:37:46 <bakert> can i pattern match on "contains a comma"?
03:37:56 <earthy> you can use regexps
03:38:02 <nominolo> bakert: sort of - using guards
03:38:23 <bakert> nominolo, that would be better than noting
03:38:29 <earthy> f s | s =~ <some regexp, syntax eludes me> = blah
03:38:33 <bakert> i can't put arbitrary code in a guard though can i?
03:38:37 <bakert> oh yes looks like i can
03:38:47 <nominolo> f s | (s1,s2) <- splitAt ',' s = ....
03:39:03 <nominolo> :t splitAt
03:39:05 <lambdabot> forall a. Int -> [a] -> ([a], [a])
03:39:18 * earthy grins
03:39:28 <nominolo> > splitAt ',' "foo,bar,baz"
03:39:29 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
03:39:42 <nominolo> oh
03:39:45 <dancor> break
03:40:03 <earthy> f s | (s1,s2) <- (takeWhile (/= ','), dropWhile (/= ',')) =
03:40:05 <nominolo> ok, well, then you have to write the correct version of split* first ;)
03:40:06 <earthy> or break ;)
03:40:16 <bakert> i have split already luckily!
03:40:36 <nominolo> :t break
03:40:38 <bakert> actually it is a regexy think
03:40:38 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:40:41 <bakert> (thing
03:40:43 <bakert> *thing
03:40:46 * earthy schedules some more reading of the prelude
03:40:48 <bakert> split pattern s = splitRegex (mkRegex pattern) s
03:41:15 <dancor> when are views happenning
03:41:17 <bakert> > break (== ',') "hello,there"
03:41:18 <lambdabot>  ("hello",",there")
03:41:34 * dancor schedules some learning to spell
03:42:41 <bakert> ?t splitAt
03:42:42 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
03:42:46 <bakert> :t splitAt
03:42:49 <lambdabot> forall a. Int -> [a] -> ([a], [a])
03:44:10 <nominolo> dancor: see the Haskell Prime wiki
03:44:22 <nominolo> ?where haskell prime
03:44:22 <lambdabot> http://haskell.org
03:44:55 <quicksilver> curiously 'split at commas' isn't anywhere in the standard library
03:45:09 <quicksilver> that is, there is no generalisation of 'unwords' to non-space-chars
03:45:46 <nominolo> ?src unwords
03:45:47 <lambdabot> unwords [] = ""
03:45:47 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
03:46:28 <Thunde1> @pl \w s -> w ++ ' ':s
03:46:29 <nominolo> :t words
03:46:29 <lambdabot> (. (' ' :)) . (++)
03:46:32 <lambdabot> String -> [String]
03:46:43 <nominolo> ?src words
03:46:43 <lambdabot> words s = case dropWhile isSpace s of
03:46:44 <lambdabot>     "" -> []
03:46:44 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
03:47:07 <quicksilver> sorry, I mean 'words' not 'unwords'
03:47:14 <quicksilver> I always get those two backwards, oddly
03:47:47 <nominolo> well, as you can see, it's break
03:47:56 <Thunde1> @type curry (:)
03:47:59 <lambdabot> forall a b. a -> b -> [(a, b)] -> [(a, b)]
03:48:00 <quicksilver> the reason there isn't one is probably that there are a few possible variants you can imagine: constant strings, constant chars, char predicate, string predicate
03:48:18 <quicksilver> and the question of whether you keep the delimeters in the output or not
03:48:42 <earthy> that's what we've got parser combinators for
03:48:54 <nominolo> a regexp-based implementation probably works best in any case
03:48:56 <Thunde1> @type uncurry (:)
03:48:59 <lambdabot> forall a. (a, [a]) -> [a]
03:49:11 <quicksilver> earthy: well, yes
03:49:31 <quicksilver> earthy: but it's still a question that often comes up "Why isn't this minor generalisation of words in the library"
03:49:58 <Thunde1> @pl \x xs -> x : words xs
03:49:58 <lambdabot> (. words) . (:)
03:50:13 <nominolo> > break (==';') "foo;basd;fds;..."
03:50:14 <lambdabot>  ("foo",";basd;fds;...")
03:50:32 <nominolo> oh
03:57:05 <huschi> ?hpaste
03:57:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:57:49 <dancor> i can't seem to put unicode in string literals and print them to my terminal
03:58:03 <hpaste>  Huschi pasted "default class method" at http://hpaste.org/893
03:58:20 <huschi> i've got a question concerning this post.
03:58:40 <huschi> is there a way to avoid the printInt function and the forall?
03:59:04 <huschi> this code is just a broken down version of the original.
04:00:12 <dancor> > ord '•'
04:00:14 <lambdabot>  Improperly terminated character constant
04:00:42 <dancor> anyway, ord works in my program
04:00:54 <dancor> but putStrLn does not print utf8
04:01:03 <dancor> as my term expects
04:01:47 <dancor> great, it's a 6.8 milestone
04:02:21 <hpaste>  lutz@iks-jena.d annotated "default class method" with "define your own type signature" at http://hpaste.org/893#a1
04:02:38 <LoganCapaldo> utf8 in IO, or the whole unicode shebang in IO is the milestone?
04:02:55 <LoganCapaldo> err by io I mean io not some kind of monad ;)
04:03:13 <dancor> heh
04:03:24 <dancor> converting to utf8 on output
04:03:35 <LoganCapaldo> neato
04:03:43 <dancor> i guess i have to do that via Text.XML.HXT.DOM.Unicode on my own for now?
04:03:48 <dancor> @hoogle utf8
04:03:49 <lambdabot> No matches found
04:05:14 <huschi> thx, lutz@iks-jena.d, whoever you are in irc.
04:05:30 <Thunde1> huschi: Here I am.
04:05:32 <dons> ?yow!
04:05:33 <lambdabot> PUNK ROCK!!  DISCO DUCK!!  BIRTH CONTROL!!
04:05:57 <huschi> Thunde1: ok. thx again :)
04:06:10 <dancor> ?yow!!
04:06:11 <lambdabot> I wonder if there's anything GOOD on tonight?
04:06:24 <dons> ?users
04:06:24 <lambdabot> Maximum users seen in #haskell: 339, currently: 304 (89.7%), active: 36 (11.8%)
04:06:27 <dons> ?uptime
04:06:27 <lambdabot> uptime: 5d 7h 16m 24s, longest uptime: 5d 7h 16m 24s
04:07:18 <dancor> it seems very odd that you would ever not go to utf8 on io in a posix environment
04:07:33 <dancor> and that this would be broken still in 6.6
04:07:37 <dancor> i mean, that's a big number
04:09:17 <dons> if utf8 matters to you a lot, the best thing would be to take the 2 or 3 utf8 libs out there, sort out the details, and put up a single clean module Something.UTF8 that anyone can grab and use from hackage.haskell.org
04:09:42 <dons> things happen in open source when someone cares enough about it
04:11:18 <dancor> dons: yeah.  i just don't understand what ghc is doing with unicode strings on putStrLn.  i guess truncating to bytes.  just something i would expect in a less elegant language
04:11:40 <SamB> dons: what an excellent package name
04:13:04 <JaffaCake> Igloo: what do you think about adding 'setup Makefile' to Cabal, that would emit a Makefile that you could use standalone with 'make -j', for example
04:13:21 <nominolo> btw, dons settled for a new name for "thunk" ?
04:14:21 <earthy> what about not generating filenames with ^M as the last character if the line-ending-convention on the platform is not ^M^J
04:16:53 <dancor> dons: what i would actually propose though is slapping a toUtf8 (axel simon has a good one) on outgoing (from process) strings and a fromUtf8 on incoming
04:16:57 <dancor> in ghc
04:17:08 <dancor> i don't know how blasphemous that would be
04:18:14 <JaffaCake> dons: no nobench results for a few days?
04:21:27 <wkh> boy, OO people come up with funny solutions to deal with the lack of algebraic data types and pattern matching in their languages of choice.
04:21:48 <wkh> boy, functional programming people come up with funny solutions to deal with the lack of mutable state in their languages of choice.
04:22:20 <nornagon> :)
04:22:27 <matthew_-> boy, programmers are funny people.
04:24:24 <therp> what's so funny about state monads?
04:24:39 <matthew_-> the punch line?
04:24:43 <earthy> 'rare jongens, die romeinen'. 'ils sont fous, ces romains'.
04:25:08 <Philippa> wkh: monads gain you a bit more than the visitor patterns does though
04:25:50 <bakert> ?hoogle seq
04:25:51 <lambdabot> Prelude.seq :: a -> b -> b
04:25:51 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
04:25:51 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
04:25:56 <bakert> ?hoogle liftM
04:25:57 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
04:25:57 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
04:25:57 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
04:26:28 <Botje> the visitor pattern is just a weak imitation of fmap
04:26:59 <wkh> well
04:27:25 <wkh> monads and functional progrmaming have a certain amount of solid theoretical foundation. object-oriented programming is rather ill-defined in contrast
04:27:28 <quicksilver> Botje: that's not actually true
04:27:35 <quicksilver> Botje: it's more like mapAccumL or something
04:27:57 <quicksilver> :t mapAccumL
04:28:00 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
04:28:11 <matthew_-> if modules were first class then I could see reasons for using the visitor pattern in haskell
04:28:13 <quicksilver> yes, more like that
04:28:18 <bakert> Gak.  I've forgotten all the haskell I did know!  I have two functions whose value is "m t" and I want to do something with both the t values then return in m.  Put me out of my misery and remind me how to do that good people?
04:28:21 <Philippa> wkh: it's not just that. Monads gain you significant functionality over just having mutable state in the core language, the visitor pattern doesn't unless you like being type-unsafe
04:28:39 <SamB> bakert: liftM2?
04:28:40 <Botje> bakert: liftM2?
04:28:48 <SamB> @quote stereo
04:28:49 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
04:28:52 <Botje> :)
04:29:09 <wkh> @quote wkh
04:29:09 <lambdabot> wkh says: i don't want to write web code in haskell. i wnat to put PHP people out of jobs
04:29:22 <ivanm> lol
04:29:25 <Botje> @quote banana
04:29:25 <lambdabot> br1 says: <br1> un banana me abrió la puerta en la cara y me rompió un pedal de la bici :(
04:29:34 <Botje> que?
04:29:44 <bakert> return $ joinfunction (f1) (f2)
04:29:51 <bakert> where does the liftM2 go???!
04:30:09 <ivanm> joinfunction?
04:30:22 <ivanm> :t liftM2
04:30:24 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:30:31 <bakert> well the function that operates on the un-monad-ed results of f1 and f2.
04:30:44 <bakert> ivanm - that's joinfunction!
04:30:52 <ivanm> liftM2 joinfunction (f1) (f2)?
04:31:09 <bakert> do i still need the return?
04:31:15 <bakert> or does liftM2 drop it back in, too
04:31:28 <ivanm> don't think so... IIRC, liftM2 just returns the type of joinfunction...
04:31:31 <matthew_-> bakert: no return - the type of liftM2 keeps it in the monad
04:31:35 <ivanm> so only a monad if you make it a monad
04:32:03 <Botje> ?src liftM2
04:32:04 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:32:55 <bakert> Oh dear.  I am doing something stoopid.
04:32:57 <bakert> addFunds :: Funds -> Funds -> Funds
04:33:18 <bakert> funds :: String -> String -> String -> BrowserAction Funds
04:33:27 <bakert> BrowserAction is a monad from Network.Browser
04:33:34 <bakert> liftM2 $ addFunds (funds bookie u currency)
04:33:34 <bakert>                                                   (funds bookie us currency)
04:33:41 <bakert> is unhappy
04:33:49 <bakert> does that make any sense?
04:33:50 <bakert> ?paste
04:33:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:34:35 <hpaste>  bakert pasted "liftM2 woes ... perhpas a bit clearer" at http://hpaste.org/894
04:35:07 <bakert> I think the liftM2 has to go somewhere else.
04:35:34 <quicksilver> ahh
04:36:05 <quicksilver> no, that looks right
04:36:09 <quicksilver> let me check your paste
04:36:28 <bakert> Couldn't match expected type `Funds'
04:36:28 <bakert>            against inferred type `BrowserAction Funds'
04:36:28 <bakert>     In the first argument of `addFunds', namely
04:36:29 <SamB> get rid of the $
04:36:39 <SamB> ?
04:36:53 <bakert> aha
04:36:53 <quicksilver> no, the $ is fine
04:37:09 <quicksilver> what's the exact error, bakert? that guard looks odd to me
04:37:26 <bakert> I think it is the $ after all.  I get a new error if I remove it.
04:37:30 <quicksilver> oh, it is the $
04:37:35 <quicksilver> sorry, SamB was quite right :)
04:37:39 <bakert> I think I was trying to do the addFunds before passing the result to liftM2
04:37:43 * quicksilver nods
04:37:44 <quicksilver> you were
04:37:45 <bakert> but that's not how liftM2 works
04:37:47 <quicksilver> right :)
04:37:49 <bakert> got it now!
04:37:57 <bakert> thanks guys you were fabulous as always ...
04:38:44 <bakert> You don't like my guard?
04:38:49 <bakert> Neither does ghc
04:38:53 <opqdonut> :D
04:38:53 <bakert> accepting non-standard pattern guards (-fglasgow-exts to suppress this message)
04:39:06 <quicksilver> :t split
04:39:08 <SamB> Q and Dr. Wily are so lame :-(
04:39:09 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
04:39:15 <bakert> But from previous discussions I think people tend to use -fglasgow-exts for most stuff, right?
04:39:18 <quicksilver> hmm htat's not the right split :)
04:39:20 <opqdonut> quicksilver: split is not very robust iirc
04:39:25 <bakert> sorry my split is this:
04:39:39 <SamB> they won't even play *twenty* questions - only 10!
04:39:40 <bakert> split pattern s = splitRegex (mkRegex pattern) s
04:39:51 <bakert> ugly but effective!
04:39:57 <quicksilver> :t Text.Regex.splitRegex
04:40:01 <lambdabot> Text.Regex.Posix.Wrap.Regex -> String -> [String]
04:40:21 <dons> JaffaCake: right. has anything changed that I should rerun the tests?
04:40:35 <dons> JaffaCake: I should set it up to run a full set once weekly I think
04:41:03 <Igloo> JaffaCake: Cabal doesn't know the module deps currently, does it? So it could only do it if GHC is available, I think
04:43:20 <dons> hey Igloo, what window manager do you use?
04:43:30 <JaffaCake> Igloo: the Makefile could include a depend rule that runs ghc -M
04:43:36 <Igloo> sawfish currently
04:43:50 <matthew_-> is anyone using the fastcgi stuff from  http://www.cs.chalmers.se/~bringert/darcs/haskell-fastcgi/ or is Network.CGI in base now the preferred route?
04:43:52 <lambdabot> Title: Index of /~bringert/darcs/haskell-fastcgi
04:43:55 <Igloo> JaffaCake: That's still ghc-only
04:44:06 <JaffaCake> dons: no, nothing's changed - just wondering how often you were running the tests
04:44:19 <JaffaCake> Igloo: yes, and probably GNU-make only
04:44:34 <bakert> matthew-_, I use Network.NewCGI but I can no longer remember who pointed me at that.
04:44:55 <SamB> JaffaCake: what other makes are there ;-)?
04:45:10 <Igloo> JaffaCake: Re "that would still leave the base package as the bottleneck", breaking base up would help there
04:45:17 <Lemmih> bakert: Network.NewCGI is Network.CGI as of GHC-6.6
04:45:24 <SamB> whoa.
04:45:25 <bakert> ah.  thanks Lemmih
04:45:30 <JaffaCake> Igloo: right
04:45:31 <SamB> no pointers in the text section?
04:45:52 <Igloo> JaffaCake: But good point about building single files and adding flags
04:45:56 <Lemmih> matthew_-: If you want FastCGI, use haskell-fastcgi. If not, go with Network.CGI.
04:46:06 <JaffaCake> Igloo: yes, that worries me a bit
04:46:38 <Lemmih> matthew_-: (They're interchangeable so your initial choice doesn't matter that much)
04:46:41 <matthew_-> Lemmih: tnx
04:47:37 <Igloo> JaffaCake: OK, so maybe "Setup makefile" is the way to go, and it'll just be GHC-only for now
04:48:03 <Igloo> Although having said that, it'd work for hugs too as there's no building to be done
04:48:10 <JaffaCake> I think it's not too hard - just prefix a bunch of declarations onto a template makefile
04:48:41 <SamB> Igloo: "work for hugs"?
04:49:02 <SamB> I think a more accurate statement would be "hugs users won't care"
04:49:03 <matthew_-> right, so whilst Network.CGI is in base, the version that fastcgi depends on is not the version in Base
04:51:48 <Lemmih> matthew_-: It doesn't need really NewCGI if you have 6.6.
04:52:27 <matthew_-> I have 6.7 and fastcgi won't build without newcgi. build-depends: base>=2.0, cgi >= 3000.0.0
04:53:20 <matthew_-> oh, ok, maybe the cabal file's just crazy
04:53:51 <matthew_-> Network/FastCGI.hsc:34:7:
04:53:51 <matthew_->     Could not find module `Network.CGI.Protocol':
04:53:51 <matthew_->       it is a member of package cgi-compat-2006.10.28, which is hidden
04:53:56 <matthew_-> such fun.
04:58:21 <matthew_-> oh, ignore me. I have a different $PATH as root and non-root which was upsetting things. All is fine!
05:02:13 <kaol> I just packaged and uploaded binary and HList libraries for Debian
05:07:00 <matthew_-> mmm. is it just me, or does both -static and -optc-static not do what they should?
05:08:59 <Igloo> You might need -optl-static
05:10:44 <matthew_-> Igloo: yes, just tried that. which gives interesting errors such as (.text+0x112): undefined reference to `pthread_once'
05:11:21 <Igloo> Hmm, I don't suppose -optl-lpthread fixes it?
05:11:53 <matthew_-> 'fraid not
05:12:16 * Igloo wonders what /usr/lib/libpthread_nonshared.a is for
05:14:17 <Igloo> Doesn't look relevant, anyway
05:15:10 <mux> it looks clearly relevant if you wanna build something statically with pthread :)
05:15:33 <mux> this is a bit weird though; it should just be named libpthread.a
05:15:34 <Igloo> The pthread_once symbols are in /usr/lib/libpthread.a, though
05:15:38 <mux> ah
05:15:44 <mux> so there is *also* a libpthread.a
05:15:48 <mux> weird weird
05:15:53 <mux> I can only guess this is Linux ;-)
05:17:10 <kombinator> hello #haskell
05:17:46 <kombinator> is it possible to tell GHC to display lexical stack trace after I blow up its stack?
05:18:11 <kombinator> I get "Stack space overflow: current size 8388608 bytes." and I'm out of ideas for a moment
05:18:34 <kombinator> and my code is quite circular almost everywhere...
05:20:08 <waern> dcoutts, ping
05:26:29 <resiak> Hrm.  Any recommended reading for how to use (Either a) as an Error monad?
05:27:31 <dons> I wrote an article about this earlier in the week in fact
05:28:07 <dons> > do x <- return 7 ; y <- return 2 ; return (x+y) :: Either String Int
05:28:09 <lambdabot>  Right 9
05:28:29 <dons> > do x <- return 7 ; y <- return 2 ; when (y == 2) $ fail "badly" ; return (x+y) :: Either String Int
05:28:30 <lambdabot>  Left "badly"
05:28:54 <dons> so you can string together your Right/Left returning functions, and then inspect the result of the whole thing with case on Left/Right
05:29:09 <resiak> I really, really need to add Planet Haskell to my RSS reader.
05:29:23 <dons> does the above give you an idea?
05:29:42 * earthy reads old parsing literature
05:30:02 <resiak> It looks like what I remembered seeing used here, and your article explains how it's achieved very clearly.
05:30:03 <SamB> hmm.
05:30:14 <SamB> GHC is telling me I need incoherent instances for what I'm trying.
05:30:23 <SamB> it is worse than I had feared it would be.
05:30:26 <SamB> :-(
05:30:43 * SamB was only expecting to need overlapping instances...
05:32:54 <nattfodd> can anyone help me with http://rafb.net/p/IDEavv26.html ?
05:32:55 <lambdabot> Title: Nopaste - No description
05:33:11 <nattfodd> it looks like a cabal issue but I can't be sure
05:33:43 <Stinger> when pattern matching a type with feild names, can you put in a positional pattern? or do you have to bind the field names to variable names?
05:33:55 <Stinger> if that makes any sense
05:34:08 <quicksilver> you can use positionals
05:34:12 <quicksilver> field names are always optional
05:34:23 <quicksilver> data Foo = Foo { a :: Int, b :: String}
05:34:32 <quicksilver> you can still write Foo 12 "hello" if you choose
05:34:38 <quicksilver> (and Foo x y in a pattern)
05:34:45 <matthew_-> the field names just get compiled out to functions don't they?
05:34:54 <Stinger> oh right so no {}s in the pattern
05:34:57 <quicksilver> they get compiled out, yes
05:35:01 <quicksilver> but they're more than that :)
05:35:10 <quicksilver> they're also that wierd update syntax
05:35:25 <matthew_-> yup.
05:37:03 <dcoutts> waern, pong
05:37:16 <quicksilver> Stinger: you can match with the field names if you prefer
05:37:26 <quicksilver> Stinger: then it looks like this:
05:37:39 <quicksilver> myfun Foo { a = x, b = y } = x+y
05:37:47 <quicksilver> I think, I've never used it personally :)
05:37:59 <matthew_-> mmm. is it usual to see "bad eta expands" when compiling ghc6.6 with ghc6.4?
05:38:13 <waern> dcoutts, my Cabal patch went out of synch, so I sent a new one
05:38:38 * nattfodd pokes people again with http://rafb.net/p/IDEavv26.html
05:38:39 <lambdabot> Title: Nopaste - No description
05:38:49 <waern> dcoutts, just wanted to tell you that.. but I've told JaffaCake as well now, so he'll probably take care of it
05:39:31 <JaffaCake> waern: thanks
05:40:25 <waern> JaffaCake, np
05:42:01 <Stinger> yeah I wanted without, just messed up the syntax
05:45:53 <dcoutts> waern, I've let them through to the list
05:56:27 <nattfodd> how can I tell cabal to look at someplace else when he is "chasing modules"?
05:56:58 <nattfodd> I get "Could not find module `Control.Applicative', use -v to see a list of the files searched for"
05:57:41 <mux> that's not really answering your question but it may be helpful to you; I used to need tot build haskell modules on a box when I had no administrative rights, and using the --user flag on the Setup.hs cabal build file works just nice
05:57:46 <nattfodd> and saying "runhaskell -v Setup.hs build" doesn't help much
05:57:55 <mux> then GHC maintains two databases, one in your home directory, and one system-wide
05:58:11 <mux> you need to pass --user to the configure command, and to the install one
05:58:21 <mux> and you need to set --prefix to your home dir, and bingo
05:58:50 <nattfodd> mux: but Control.Applicative is provided with the sources
05:58:56 <nattfodd> it's just in another directory
05:59:39 <mux> ok you're having this error during a build command, and the "missing" sources are supposed to be part of what you're building?
05:59:50 <mux> are you there isn't more than one cabal file maybe?
06:00:16 <mux> I've seen distributions in the past where there were several cabal files to install several parts of the stuff
06:00:21 <resiak> dons: very nice article.  thanks for pointing it out to me
06:00:27 <nattfodd> mux: there are more cabal files in other directories, yes, but the README file doesn't say anything about them
06:01:07 <mux> nattfodd: well if there's a cabal file in the dir where Control.Applicative lives, it seems you should try with that one first
06:01:12 <mux> what code is that btw?
06:01:47 <Pastorn> can i make lambdabot join a channel?
06:01:56 <nattfodd> mux: agda-2
06:02:13 <nattfodd>  http://www.cs.chalmers.se/~ulfn/darcs/Agda2/Agda2.tar.gz
06:02:18 <nattfodd> if you want to take a look
06:02:48 * mux fetches it
06:02:49 <nattfodd> ah, it says I need ghc-6.6
06:03:00 * nattfodd pokes dcoutts and kosmikus 
06:04:14 <mux> well I guess that could explain it
06:04:41 <ttmrichter> Silly security question: how would I go about zeroing memory space in Haskell code?  Only through FFI modules that explicitly do this job?
06:05:04 <nattfodd> now the problem is to have ghc-6.6 on gentoo :)
06:05:21 <kolmodin> hah
06:05:28 <ibid> ttmrichter: not silly at all. the answer is, you can't control memory usage at that level with haskell without using FFI
06:05:34 <kolmodin> ghc-6.6 is hard masked in the tree since two days ago
06:05:43 * mux pats his ghc-6.6-enabled FreeBSD
06:05:48 <kolmodin> but it has no libs, so not many packages will build against it :)
06:05:50 <ibid> ttmrichter: note that normally the runtime is allowed to move stuff around, even
06:05:53 <nattfodd> kolmodin: and does it work?
06:05:57 <kolmodin> I'll try to put more stuff in this weekend
06:05:58 <nattfodd> humpf
06:06:13 <kolmodin> then you can help me test it. excellent!
06:06:19 <kolmodin> :D
06:06:23 <ttmrichter> ibid: I thought as much.  So if I want to do any serious crypto work in Haskell, I'd have to make an FFI module that owns the keys/passwords/etc.
06:06:31 <ibid> ttmrichter: yep
06:06:39 <ttmrichter> ibid: thanks.
06:06:45 <nattfodd> bleh, there's no ghc-bin yet
06:07:13 <Uncountable> what does (^^) do? it seems it's the same as (**)
06:07:17 <kolmodin> things has been moving slowly in gentoo land for a while, but we're picking up speed again
06:07:21 <ibid> ttmrichter: and you need to be careful with that; haskell is usually very liberal about copying stuff
06:07:48 <kaol> what would the implications of running ghc code as root be? a bad idea?
06:08:00 <resiak> @type (^^)
06:08:02 <resiak> @type (**)
06:08:02 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
06:08:04 <lambdabot> forall a. (Floating a) => a -> a -> a
06:08:06 <resiak> Uncountable: ^^
06:08:10 <fasta> Is there a way to get the rhs of a let value evaluated regardless of whether it's "needed" in GHC?
06:08:14 <kolmodin> kaol: running ghc or code compiled by ghc?
06:08:16 <Uncountable> okies
06:08:28 <dylan> fasta: seq?
06:08:28 <kaol> code compiled as ghc
06:08:29 <fasta> The lhs is not used in any location.
06:08:32 <fasta> dylan: no
06:08:33 <kaol> s/as/by/
06:08:43 <kolmodin> kaol: ie ghc itself, you mean?
06:08:47 <mux> Uncountable: that means ^^ works with Complex numbers for instance, and ** doesn't
06:08:58 <fasta> dylan: at least, I do not believe that seq does that.
06:08:59 <ibid> fasta: bang pattern?
06:09:09 <fasta> ibid: could be (never used it)
06:09:11 <ibid> fasta: yes it does, you just have to use it right :)
06:09:23 <ibid> fasta: so, let x = ... in x `seq` ...
06:09:26 <mux> or the opposite or something
06:09:36 <fasta> ibid: ah, of course.
06:09:40 <ibid> fasta: that's roughly what bang pattern desugars into
06:09:47 <fasta> ibid: thanks
06:10:00 <kaol> kolmodin: are you referring to ghc's runtime system?
06:10:27 <Botje> nattfodd: i'm running ghc-6.6 on gentoo..
06:10:37 <Botje> all I had to do was bump the ebuild up to 6.6 manually and let 'er rip
06:11:12 <kolmodin> kaol: I don't follow. do you mean running ghc or a haskell program compiled by ghc?
06:11:21 <nattfodd> Botje: well, I dirtily made symlinks so that cabal can find its missing libs and it looks like it's working
06:11:25 <nattfodd> for the moment
06:11:48 <kaol> running ghc as root would be pretty pointless, of course.
06:11:48 <ibid> fasta: see also http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-bang-patterns.html
06:11:50 <lambdabot> Title: 7.8. Bang patterns, http://tinyurl.com/yywtt4
06:11:54 <kolmodin> Botje: there is a overlay with proper ebuilds for ghc
06:12:48 <fasta> ibid: It works for my problem. Thanks
06:12:55 * kaol gives up; never mind
06:13:29 <ibid> fasta: note that it's a new feature in 6.6
06:14:03 <fasta> ibid: yes, I know and it probably is a mile away from "stable".
06:14:38 <kuribas> Where can I find network-any?
06:14:53 <kolmodin> kaol: we run ghc as root all the time in gentoo, to compile libs. why would that be pointless?
06:15:40 <fasta> How can I have the literal BAR(someargument) expand into let !x = unsafePerformIO (somecall someargument)
06:15:53 <kolmodin> we run darcs as root too to fetch repos, a program compiled by ghc
06:15:56 <fasta> CPP should be able to do that, right?
06:16:07 <allbery_b> freebsd ports and macports both run ghc as root to bootstrap ghc
06:16:19 <mauke> #define BAR(x) let !x = unsafePerformIO (somecall (someargument))
06:16:40 <kolmodin> fasta: #define BAR(foo) !x = unsafeP... ( foo this that )
06:16:51 <mauke> argh
06:17:07 <mauke> s/\(x\)/(someargument)/
06:17:14 <kuribas> Searching on google didn't give my a meaningful result.
06:18:47 <Uncountable> is there a functional power-function in the std libraries? so f *^ n = f.f.f.f.f...f
06:19:05 <fasta> If I import a module containing a #define, is that define also available in that module?
06:19:48 <mauke> @pl \f n x -> iterate f x !! n
06:19:49 <lambdabot> flip . ((!!) .) . iterate
06:20:29 <Uncountable> does @pl look up library functions?
06:20:46 <earthy> no it doesn't. ;)
06:20:47 <mauke> no, it removes points
06:21:09 <mauke> @hoogle (a -> a) -> Int -> a -> a
06:21:10 <lambdabot> No matches, try a more general search
06:21:16 <Botje> but it added points! :p
06:21:23 <beelsebob> lol
06:21:29 <beelsebob> no, it made it pointless
06:21:32 <beelsebob> :P
06:22:20 <kuribas> I didn't find network-any on http://haskell.org/haskellwiki/Libraries_and_tools/Network.
06:22:22 <lambdabot> Title: Libraries and tools/Network - HaskellWiki
06:22:55 <kolmodin> kuribas: that's a package in the ghc-extra-libs
06:23:04 <kolmodin> kuribas: you're using ghc-6.6, right?
06:23:16 <kolmodin> which distro?
06:23:35 <kuribas> yes
06:23:39 <kuribas> Debian.
06:23:51 <kuribas> I compiled ghc from source.
06:23:58 <kolmodin> ah, ok
06:24:06 <Botje> did you unpack the ghc-extras package in the source tree before building
06:24:06 <kolmodin> you need to compile the extra libs too then
06:25:20 <kuribas> Ah, I found it in the at www.haskell.org
06:25:27 <kuribas> kolmodin: thanks
06:25:33 <kolmodin> np
06:27:00 <quicksilver> earthy: it looks up a small number of library functions
06:27:49 <fasta> I defined the macro in a module, but when I use it in another, it claims it cannot find the data constructor BAR.
06:35:53 <allbery_b> fasta: cpp is separate from compilation, you can't just import cpp macros
06:36:12 <allbery_b> use #include like you normally would with cpp
06:37:55 <resiak> @hoogle m [a] -> m a
06:37:56 <lambdabot> Prelude.id :: a -> a
06:37:56 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
06:37:56 <lambdabot> Prelude.asTypeOf :: a -> a -> a
06:38:09 <resiak> hrm, keep forgetting that hoogle doesn't work properly for monadic types
06:38:25 <mauke> what's that, some kind of fold?
06:38:38 <mauke> @type msum
06:38:42 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
06:40:27 <resiak> Yeah, so I have a value of type  Either String [String]  , and I basically want to apply (++) to it.  Right now I'm saying liftM (foldr1 (++)), but that feels sub-ideal
06:40:50 <quicksilver> well foldr1 (++) is called 'concat'
06:40:58 <quicksilver> @src concat
06:40:58 <lambdabot> concat = foldr (++) []
06:41:02 <fasta> allbery_b: This is the first time I use cpp for my own purposes. I put the definition in a file called "foobar.macro", but when I do #include "foobar.macro" it doesn't appear to be working.
06:41:10 * resiak facepalms
06:41:14 <quicksilver> resiak: does 'liftM concat' sounds better?
06:41:29 <fasta> I.e. not in scope data constructor BAR
06:41:46 <resiak> quicksilver: yeah, that's ideal, and actually handles the empty list
06:41:52 <resiak> I need more coffee, obviously :-)
06:42:11 <quicksilver> resiak: get me some too? large latte, full fat please
06:42:38 <resiak> quicksilver: yep!
06:42:56 * resiak notices t he time and runs away to a lecture
06:43:10 <Zeroth|work> howdy folkses
06:47:26 <dons> sjanssen: this firefox toolbar bug is tricksy. we seem to do pretty much everything dwm does with setup and events, as far as i can tell.
06:47:39 <dons> sjanssen: i did manage to reproduce it by break dwm
06:48:08 <fasta> Whoohoo, I found it.
06:48:18 <dons> could one of our Xlib calls be failing, without producing an exception?
06:51:48 <dylan> dons: what's your dwm port called, anyway?
06:52:45 <chessguy> 'morning haskellers
06:52:56 <dons> working title: thunk
06:53:59 <dylan> dons: suggestion: "howm".
06:54:20 * quicksilver suggests wM
06:54:44 <dylan> dons: is it useable yet?
06:55:58 <Ulfalizer> hoe-wm
06:56:10 <Ulfalizer> what does it do?
06:57:04 <dons> yeah, i've been using it for a few days now. its a full screen only dwm (no tiling) with no statusbar
06:57:19 <dons> ?where thunk
06:57:19 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/thunk/
06:57:35 <dons> dylan: you could give it a whirl. note it needs X11-extras (see the readme)
06:57:46 <beelsebob> dons: *fewer* lines of code
06:58:11 <dons> yeah, and 1/10th the codebase
06:58:29 <beelsebob> dons: sorry, being a grammar nazi -- you need to correct your readme
06:59:10 <dons> done.
06:59:26 <dylan> dons: I'll wait for tiling and such.
06:59:31 <beelsebob> :D
06:59:33 <Ulfalizer> dons: kinda like screen?
06:59:40 <dons> yeah.
06:59:55 <dylan> I won't bother updating dwm to 3.8 though, since I don't want to port my runtime tags patch.
07:00:00 <Ulfalizer> screawm :P
07:00:36 <beelsebob> heh
07:00:44 * beelsebob has always wanted screen for X11
07:00:48 <beelsebob> would be shiny
07:00:57 <quicksilver> beelsebob: it's very trendy this days
07:01:02 <Ulfalizer> i think there's already wm's like that
07:01:03 <beelsebob> quicksilver: what is?
07:01:04 <quicksilver> beelsebob: see also ratpoison, and I'm sure others
07:01:05 <tarantoga> beelsebob: that already exists and is called ratpoison
07:01:18 <dons> ratpoison, ion, evilwm, wmii, dwm
07:01:25 <quicksilver> Baughn: minimalist wms
07:01:29 <dons> though only evilwm and dwm are in the 2k loc range
07:01:34 <kzm> Is there a page comparing these?
07:01:40 <beelsebob> quicksilver: that doesn't seem to be what I want
07:01:40 <Ulfalizer> i've tried some of them, but i've always encountered some annoying problem that has kept me from switching from fluxbox :/
07:01:42 <dons> while thunk is in the 0.2k range :-)
07:01:59 <beelsebob> I want something that can store my X session, and restore it when I reconnect from a different machine
07:02:06 <beelsebob> (like screen does with terminals)
07:02:07 <kzm> beelsebob, vnc?
07:02:17 <beelsebob> kzm: not really storing my X session that
07:02:22 <beelsebob> it has a huge overhead
07:02:35 <kzm> huge?
07:02:42 <beelsebob> indeed
07:02:46 <quicksilver> pretty big, yes
07:02:53 <quicksilver> it sends the whole screen as a bitmap
07:02:56 <quicksilver> instead of primitve
07:02:57 <quicksilver> s
07:03:01 <beelsebob> like, running ssh -X is usable over my dsl, wheras vnc isn't
07:03:13 <beelsebob> s/dsl/dsl is bareable/
07:03:14 <kzm> tightvnc, then?
07:03:33 <malcolmw> dons: dcoutts: anyone else: so any good ideas how we should choose mentors for GSoC (and particularly what we should say to google about how we do it)?
07:04:04 <beelsebob> kzm: no OS X client
07:04:06 <kzm> malcolmw, the old way?  Interesting projects, qualified students and mentors?
07:04:31 <quicksilver> beelsebob: there are ways of doing that, anyhow
07:04:37 <dcoutts_> malcolmw, well I expect they're all self-proposed and in the case of a dispute that several mentors want to do the same project... well it's unlikely to be a problem.
07:04:53 <beelsebob> quicksilver: yeh, but not nicely - would be nice just to have a stored session that I could restore
07:05:00 <malcolmw> self-proposal is the honest answer i suppose
07:05:00 <quicksilver> beelsebob: xmove has been around for ages, say
07:05:03 <dcoutts_> malcolmw, do you think we need any vetting process? I don't think we do.
07:05:06 <kzm> how would you implement X disconnect and connect without using bitmaps?
07:05:26 <quicksilver> kzm: by using the X protocol
07:05:30 <malcolmw> dcoutts_: no, I don't think vetting is necessary
07:06:03 <malcolmw> dcoutts_: but I can't help thinking that there is an implicit vetting process happening anyway, and I wonder if we need to reflect on what it might be
07:06:36 <dcoutts_> malcolmw, just say that we expect that mentors will propose themselves and we expect that those people will be known to each other by reputation and via mailing lists etc.
07:06:46 <xs> correlation as evaluated by peers between projects and mentors.
07:07:01 <malcolmw> dcoutts_: yup, that's what I'm thinking
07:07:44 <dcoutts_> malcolmw, and we probably do not need to put any specific measures in place to have that be the outcome. That's enough for google I'd expect.
07:08:07 <dcoutts_> malcolmw, I think they're mostly targeting the disorganised 'orgs'.
07:08:33 <malcolmw> dcoutts_:  OK, understood
07:08:36 <dons> yes, people known in the community is all they can expcet, I think.
07:09:15 <malcolmw> The other question we need to discuss is whether we want to create a student application template
07:09:48 <malcolmw> and if so, is there one we can steal/copy from another project? :-)
07:10:52 <dons> we used apache's last time
07:11:56 <malcolmw> Also Q17: What will you do to ensure that your accepted students stick with the project after GSoC concludes?
07:12:31 <dons> hmm. encourage them into the community during SoC, so they have an interest in continuing development?
07:13:07 <dons> making sure they're in the community during SoC is all we can really do? and maybe we can be more active about the community resources available to the students
07:13:23 <Igloo> You could point out that we succeeded at that last year
07:13:25 <matthew_-> mmm. the number of open source projects that are currently having these discussions...
07:13:37 <malcolmw> dons: but Q16 is What steps will you take to encourage students to interact with your project's community before, during and after the program?
07:13:45 <Igloo> And maybe also mention some of them came to the hackathon
07:14:01 <dons> right. that's a good point
07:14:06 <malcolmw> Igloo: cool data point
07:14:10 <dons> we had several mentors and students at the hackathon, 6 months later
07:14:29 <dons> (the fact we run hackathons is a win for us already..)
07:14:35 <Igloo> And also continued commits, e.g. on the GHC breakpoint stuff
07:14:58 <malcolmw> by Hackathon do you mean Hac07, or the GHC hackathon as well?
07:15:10 <Igloo> Hac07
07:15:18 <Igloo> The GHC hackathon was before SoC, wasn't it?
07:15:31 <dons> in the middle
07:15:38 <malcolmw> Neither
07:15:44 <dons> yeah, Hac07.
07:15:53 <malcolmw> GHC hackathon was in Sept/Oct
07:15:54 <dons> we had people wearing their SoC tshirts to the hackathon
07:16:40 <Igloo> Ah, well, if there were students there then mention that too
07:16:59 <Igloo> Although during (i.e. while being paid) probably isn't as interesting to google
07:17:00 <malcolmw> Igloo: I don't want to mention it unless I have evidence
07:17:33 <malcolmw> No, the GHC hack was definitely . 1 month after the end of SOC
07:17:38 <dons> i'm not aware of any students who went to the first hackathon, but we had some at the jan/oxford one.
07:18:01 <malcolmw> our T-shirts had not arrived by the time of the GHC one
07:18:18 <dons> you could mention that we've increased the community active, e.g. by having hackathons
07:18:30 <dons> s/activity/
07:18:47 <malcolmw> yeah, that might be a good point to make
07:20:43 <malcolmw> dons: I'll need your Google Account name/info when I fill in the application
07:21:53 <waern> do you think we will get as many, or more SoC projects this year?
07:22:07 <waern> granted by google, that is
07:22:13 <malcolmw> more generally, it looks like we will need Google Account information for _all_ mentors
07:22:36 <malcolmw> and I will need that info at the time of application.
07:22:41 <dons> waern: probably around the same
07:22:49 <dons> malcolmw: huh. ok.
07:22:56 <dons> have they changed the process?
07:23:14 <dons> do we just need the account name/gmail addr?
07:23:45 <malcolmw> dons: I dunno, but I'm just going through the list of questions in the FAQ to check what they are asking for this time
07:24:04 <malcolmw> dons: I think account name is probably all they need
07:26:01 <malcolmw> phew: "If you do not enter the information of all of your mentors now, it is no problem; you can add additional mentors later after organizations are accepted"
07:26:36 <dons> :-)
07:27:57 <malcolmw> "We're asking for a lot of information up front this year, partially to better assess our applicants, but also to save student applicants and accepted orgs time later."
07:29:17 <malcolmw> I think we need to cast the net a bit wider to attract more students to our summer-of-code wiki
07:29:32 <malcolmw> There hasn't been much student activity so far
07:29:49 <malcolmw> Didn't we have something on the front page of haskell.org last time?
07:30:06 <malcolmw> what else could we do?
07:30:53 <pejo> Optimally, one would tell the students in the advanced fp class about our SoC projects. :-)
07:30:57 <dylan> I'm a student.. hmm
07:31:04 * therp is a student too
07:31:18 <Baughn> quicksilver: Minimalist wms? Eh?
07:31:33 <dylan> hmm, I'd like to work on don's wm for SoC. ;)
07:31:46 <pejo> What is normally counted as student, everything up until graduation day for phd?
07:31:57 <quicksilver> Baughn: misreply, sorry :)
07:32:10 <quicksilver> Baughn: was talking to beelsebob and tab-completion got it wrong
07:32:34 <Baughn> qwr: See, that's why you should type them all out by hand.
07:32:58 <dons> malcolmw: announcement to haskell-cafe. something on the front page. something in hwn and on reddit
07:33:01 <quicksilver> Baorghgn: *nod*
07:33:02 <malcolmw> pejo: google have a definition of student that includes PhD studies, yes
07:33:31 <pejo> malcolmw, is that common use in english as well?
07:34:01 <malcolmw> pejo: I suppose so, yes
07:34:09 <pejo> malcolmw, thanks.
07:34:47 <malcolmw> pejo: although I suppose the period between having your thesis accepted and the actual graduation ceremony is a grey area
07:35:02 * quicksilver blushes guiltily
07:35:11 <quicksilver> malcolmw: I'm rather a long way into that period myself
07:35:24 <smack_vaio> when's the SoC application deadline?  i thought it had already passed
07:35:32 <pejo> malcolmw, out of those 3+2+3 years of studying, I could live with having the last couple of months a gray area. :-)
07:35:53 <malcolmw> smack_vaio: for mentor orgs, 12th march, for students, 24th March
07:36:14 <smack_vaio> Well, oh.
07:37:55 <huschi_> hi.
07:38:11 <huschi_> is there any implementation for the levenshtein distance in haskell?
07:38:39 <dons> yeah, there's a couple in lambdabot's utils.hs file
07:39:08 <dons> ?suocre
07:39:08 <lambdabot> Unknown command, try @list
07:39:21 <matthew_-> ?where network.http
07:39:21 <lambdabot> I know nothing about network.http.
07:39:22 <huschi_> ?source
07:39:22 <lambdabot>  not available
07:39:59 <huschi_> dons: thx.
07:44:08 <bakert> matthew-_, it's at http://haskell.org/http
07:44:10 <lambdabot> Title: Haskell HTTP package
07:47:15 <chessguy> ?where+ http http://haskell.org/http
07:47:16 <lambdabot> Done.
07:47:21 <chessguy> ?where+ network.http http://haskell.org/http
07:47:22 <lambdabot> Done.
07:57:17 <glguy> how do you install a profiling version of a library like binary or HList?
07:57:28 <glguy> using cabal preferably
07:59:58 <chessguy> @type lift
08:00:01 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
08:00:19 <dons> glguy: configure -p
08:00:25 <dons> to cabal.
08:00:50 <glguy> and it will do both then?
08:00:56 <glguy> or just the profiling version
08:01:45 <quicksilver> both, I believe
08:01:45 <vegai> both, it seems
08:01:51 <vegai> I'm seeing it
08:01:52 <glguy> pimpin'
08:01:52 <dons> both
08:01:56 <glguy> both
08:02:03 <glguy> !say both it seems
08:02:04 <hpaste> both it seems
08:02:06 <glguy> :)
08:02:28 <glguy> ugh, this takes over twice as long!
08:02:29 <glguy> ;)
08:02:31 <vegai> at least
08:03:59 <quicksilver> but it's useful later
08:04:07 <quicksilver> in the end, you probably want both versions, I think
08:04:14 <glguy> I'd think so too
08:04:55 <shapr> Good morning #haskell!
08:05:22 <Nafai> Morning shapr!
08:05:52 <chessguy> @get-shapr
08:05:53 <lambdabot> shapr!!
08:06:55 <shapr> chessguy!
08:06:57 <shapr> Nafai!
08:08:15 <chessguy> man, my google rss reader is getting overloaded
08:11:12 <Pastorn> @google yampa
08:11:14 <lambdabot> http://www.haskell.org/yampa/
08:11:14 <lambdabot> Title: Yampa
08:16:28 <dons> woo! firefox input issues solved
08:16:28 <chessguy> @type foldr (?f . ?g) ?e
08:16:31 <lambdabot> forall b a b1. (?f::b -> b1 -> b1, ?g::a -> b, ?e::b1) => [a] -> b1
08:16:34 <dons> man X is a real beast.
08:16:53 <dons> sjanssen: we were missing a call to XSetInputFocus in manage()
08:17:00 <dons> thunk++
08:17:01 <dons> X--
08:17:53 <therp> dons: huch, you are really coding a window manager?
08:18:12 <dons> yep. using it right now in fact
08:18:21 <dons> its fun trying to get work done while debugging a window manager..
08:18:25 <therp> any special kind of paradigma?
08:18:29 <therp> like ion/stumpwm?
08:18:36 <dons> yeah, ion-ish. based on dwm actually
08:18:43 <quicksilver> chessguy: honestly, implicity parameter will consume your brain and then start on your family. avoid.
08:18:47 <vegai> whoa. That seems like something that can easily be very cool
08:18:59 <therp> dons: nice. In fact I'm preparing to migrate to stumpwm (from ion, because the ion maintainer is a pure idiot)
08:19:02 <chessguy> @pl \x y -> [x,y]
08:19:02 <lambdabot> (. return) . (:)
08:19:07 <chessguy> quicksilver: ?
08:19:18 * dylan loves tagging
08:19:21 <quicksilver> chessguy: I'm not a fan of implicit parameters :)
08:19:25 <chessguy> @type (. return) . (:)
08:19:26 <therp> dons: but I wouldn't mind a Haskell based wm :)
08:19:28 <lambdabot> forall a. a -> a -> [a]
08:19:32 <chessguy> quicksilver: why?
08:19:51 <quicksilver> chessguy: because they break all sorts of invariants I'm used to enjoying in functional programming
08:20:04 <chessguy> quicksilver: such as?
08:20:09 <chessguy> ?hoogle ord
08:20:10 <lambdabot> Char.ord :: Char -> Int
08:20:10 <lambdabot> Prelude.Ord :: class Eq a => Ord a
08:20:10 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
08:21:44 <tuukkah> how would hoogle get updated to match the newest gtk2hs?
08:22:12 <chessguy> > foldr ((:) . ord) [] "haskell"
08:22:15 <lambdabot>  [104,97,115,107,101,108,108]
08:22:48 <chessguy> > map ord "haskell"
08:22:49 <lambdabot>  [104,97,115,107,101,108,108]
08:22:53 <chessguy> huh
08:23:31 <chessguy> is the foldr version there more efficient?
08:24:03 <quicksilver> I would expect them to compile to almost the same code
08:24:41 <chessguy> i don't get it. i'm looking at http://www.haskell.org/haskellwiki/Pointfree and it talks about 'map fusion', giving the above foldr version
08:24:42 <lambdabot> Title: Pointfree - HaskellWiki
08:24:47 * resiak rather belatedly hands quicksilver a latte
08:25:14 <chessguy> dons?
08:26:37 <quicksilver> resiak: amusingly, I just this moment walked back into the office with one :)
08:26:40 <quicksilver> @src map
08:26:41 <lambdabot> map _ []     = []
08:26:41 <lambdabot> map f (x:xs) = f x : map f xs
08:26:43 <chessguy> quicksilver: you still haven't told me why you don't like implicit parameters
08:26:44 <quicksilver> @src foldr
08:26:45 <lambdabot> foldr k z xs = go xs
08:26:45 <lambdabot>     where go []     = z
08:26:45 <lambdabot>           go (y:ys) = y `k` go ys
08:27:00 <resiak> quicksilver: see, that was my fault
08:27:16 <quicksilver> to me, the source of map and foldr looks very similar
08:27:32 <quicksilver> (assuming you replace k with (:).f and z with [])
08:27:44 <chessguy> so what's this "map fusion" stuff?
08:28:28 <quicksilver> chessguy: map fusion is (map f) . (map g)  ----> map (f.g)
08:28:30 <quicksilver> chessguy: I think
08:28:44 <dons> sjanssen: I do need XCrossingEvent support to make firefox work
08:29:06 <chessguy> quicksilver: did you look at the page i linked to?
08:29:09 <quicksilver> chessguy: yes
08:29:15 <chessguy> the section near the beginning talks about map fusion
08:29:20 <quicksilver> yes
08:29:32 <quicksilver> well foldr ... map is another example
08:29:42 <quicksilver> in general you might have foldr ... map ... map ... map
08:30:02 <JaffaCake> dcoutts: we didn't figure out exactly what to do about GHC's Cabal branch
08:30:14 <dons> one bug down, and : Code  Comments
08:30:15 <dons> Main.hs                 149    111
08:30:15 <dons> StackSet.hs              54     93
08:30:15 <dons> WMonad.hs                29     42
08:30:18 <quicksilver> foldr f e . map g . map h. map i ---> foldr (f.g.h.i) e, if I'm not mistaken
08:30:20 <dons> time for bed!
08:30:26 <chessguy> ohhh, i know why i'm confused
08:30:35 <chessguy> (:) was a bad example
08:31:32 <quicksilver> yes, that's probably true
08:31:38 <quicksilver> (:) is somehow 'implicit in' map
08:31:47 <quicksilver> foldr (:) [] is id
08:31:59 <quicksilver> so foldr (:.f) [] is id . map f
08:32:05 <quicksilver> (using the fusion rule in reverse)
08:32:28 <chessguy> > foldr ((+) . (*2)) [1..10]
08:32:30 <lambdabot>   add an instance declaration for (Num [t])
08:32:48 <chessguy> > foldr ((+) . (*2)) 1 [1..10]
08:32:50 <lambdabot>  111
08:33:10 <quicksilver> chessguy: to answer your question about implicit parameters. I'm embarassed to admit that I can't remember. I know I read quite a lot about it 3-4 years ago and that's the conclusion I came to
08:33:15 <quicksilver> chessguy: I can't find the references now
08:33:20 <chessguy> quicksilver: heh
08:33:23 <quicksilver> chessguy: they break referential transparency, basically
08:33:39 <quicksilver> chessguy: because a subexpression's value depends on the 'implicit context'
08:33:44 <chessguy> well, i only use it on here to investicate what functions do
08:33:50 <chessguy> s/c/g/
08:34:20 <chessguy> > sum $ map (*2) [1..10]
08:34:21 <lambdabot>  110
08:34:35 <kc5tja> I think the wiki definition of map fusion is wrong.
08:34:38 <kc5tja> Shouldn't it be:
08:35:06 <glguy> > foldl' (\x y -> x + y * 2) 0 [1..10]
08:35:07 <lambdabot>  110
08:35:10 <chessguy> kc5tja: well, it's dons' area of expertise, but he usually just ignores me
08:35:20 <kc5tja> foldr f' e where f' = f (g a) (g b)?  Remember that foldr "inserts" f in *between* elements of the *same* list, a list which is provided by map g.
08:36:02 <chessguy> kc5tja: wrong in what sense? it looks like it works to me
08:36:08 <glguy> > foldl' ((. (*2)) . (+)) 0 [1..10]
08:36:10 <lambdabot>  110
08:36:18 <kc5tja> I already wrote what sense.
08:36:20 <kc5tja>  foldr f e . map g == foldr f' e
08:36:21 <kc5tja>       where f' a b = f (g a) b
08:36:22 <kc5tja> versus
08:36:24 <kc5tja>  foldr f e . map g == foldr f' e
08:36:27 <kc5tja>       where f' a b = f (g a) (g b)
08:36:46 <kc5tja> OOOHHH...
08:36:57 * chessguy watches kc5tja's brain explode
08:37:00 <kc5tja> Wait, I the 'b' parameter is the "accumulator" for the fold, isn't it?
08:37:01 <malcolmw> kc5tja: no, the latter would recursively apply g several times to the tail
08:38:37 <chessguy> i could see a fun tutorial come out of this
08:38:46 <chessguy> "ways of finding the sums of squares"
08:38:54 <chessguy> s/sums/sum/
08:40:08 <chessguy> er
08:40:28 <chessguy> oh, i was doing *2, not ^2
08:40:44 <quicksilver> chessguy: really I think map fusion is most correctly applied to map f . map g = map f . g
08:41:02 <quicksilver> chessguy: it just happens that the technique can be obviously applied to a foldr at the (left) end of the chain, too
08:41:36 <chessguy> > sum $ map (^2) [1..10]
08:41:37 <lambdabot>  385
08:43:03 <chessguy> > map ((+1) . (^2)) [1..10]
08:43:04 <lambdabot>  [2,5,10,17,26,37,50,65,82,101]
08:43:44 <quicksilver> > foldr1 ((+).(^2)) [1..10]
08:43:46 <lambdabot>  295
08:44:07 <quicksilver> it doesn't get applied to the 10 :)
08:44:17 <quicksilver> > foldr ((+).(^2)) 0 [1..10]
08:44:18 <lambdabot>  385
08:45:09 <chessguy> ?src map
08:45:09 <lambdabot> map _ []     = []
08:45:10 <lambdabot> map f (x:xs) = f x : map f xs
08:45:57 <chessguy> ?src .
08:45:57 <lambdabot> (.) f g x = f (g x)
08:47:13 <chessguy> @type (+1)
08:47:16 <lambdabot> forall a. (Num a) => a -> a
08:49:49 <glguy> If a top-level function with an explicit type signature is polymorphic, is it treated as a CAF?
08:50:27 <quicksilver> glguy: treated as a CAF in what way?
08:50:43 <quicksilver> glguy: being a CAF or not is normally about not having any explicity arguments
08:50:45 <glguy> would the profiler call it a CAF
08:50:50 <quicksilver> rather than mono/polymorphism
08:50:52 <glguy> quicksilver: right
08:50:58 <glguy> quicksilver: but
08:51:08 <chessguy> @type sum . map ?f . filter ?p . scanl (*) 1
08:51:11 <lambdabot> forall b a. (Num b, ?f::a -> b, ?p::a -> Bool, Num a) => [a] -> b
08:51:13 <glguy> if one of the arguments is the dictionary, that gets treated the same way as a function?
08:51:32 <glguy> this is what the monomorphism restriction is about, right?
08:51:33 <quicksilver> glguy: ah, you mean type-class polymorphic
08:51:37 <glguy> yeah
08:51:54 <quicksilver> I don't know, sorry :)
08:51:55 <glguy> that you have to declare explicitly that something is typce-class polymorphic
08:52:09 <glguy> so that you are admiting you know it will be executed everytime
08:52:54 <chessguy> > sum . map ord . filter isUpper . scanl (*1) "haskell"
08:52:55 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
08:52:55 <lambdabot>     Probabl...
08:52:59 <quicksilver> yes, that's certainly one of the justifications given for the  monomorphism restriction
08:53:38 <chessguy> ?type isUpper
08:53:40 <lambdabot> Char -> Bool
08:53:50 <chessguy> ?type ord
08:53:53 <lambdabot> Char -> Int
08:54:04 <chessguy> oh, Num a
08:54:50 <chessguy> > sum . map (^2) . filter (>5) . scanl (*1) [1..10]
08:54:51 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
08:54:51 <lambdabot>     Probabl...
08:55:05 <chessguy> > (sum . map (^2) . filter (>5) . scanl (*1)) [1..10]
08:55:06 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
08:55:06 <lambdabot>     Probabl...
08:55:27 <chessguy> @type scanl
08:55:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
08:55:43 <chessguy> > (sum . map (^2) . filter (>5) . scanl (*)) [1..10]
08:55:44 <lambdabot>  Couldn't match expected type `[a]'
08:56:13 <quicksilver> > sum . map (^2) . filter (>5) . scanl (*1) 1 $ [1..10]
08:56:14 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
08:56:14 <lambdabot>     Probabl...
08:56:22 <quicksilver> :t sum . map (^2) . filter (>5) . scanl (*1) 1
08:56:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
08:56:25 <lambdabot>     Probable cause: `*' is applied to too many arguments
08:56:29 <chessguy> > sum . map f . filter p . scanl (*) 1
08:56:30 <lambdabot>   Not in scope: `p'
08:56:38 <quicksilver> > sum . map (^2) . filter (>5) . scanl (*) 1 $ [1..10]
08:56:40 <lambdabot>  13301522971812
08:56:53 <quicksilver> chessguy: (*1) isn't the same as (*) 1
08:56:59 <chessguy> yeah, typo
08:58:16 <chessguy> > scanl (*) 1 [1..10]
08:58:17 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800]
08:58:59 <quicksilver> > scanl (*) 1 [2..]
08:59:00 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
08:59:11 <quicksilver> slow factorial function?
08:59:24 <quicksilver> > let f n = (scanl (*) 1 [2..]) !! n in f 99
08:59:26 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
08:59:34 <quicksilver> actually I'm not sure it *is* that slow
08:59:45 <quicksilver> with a decent garbage collector and lazy evaluation
08:59:53 <quicksilver> it probably isn't wasting all that much
09:00:04 * chessguy quickly publishes
09:00:27 <quicksilver> in this way, you can use 'scanl' as the generalisation of the [..] notation for making lists
09:00:31 <quicksilver> other kinds of sequences
09:00:46 <quicksilver> hadn't thought of it that way before
09:04:41 <resiak> hrm, so the done thing in LB is to lift into IO when you need to use random number generators, rather than some RandomT goodness?
09:05:11 <quicksilver> resiak: 'in LB' ?
09:05:48 <resiak> sorry, s/LB/lambdabot plugins/
09:05:57 <quicksilver> resiak: I think Random stuff is better than IO, but if you're using IO anyway then the IO way is convenient
09:06:08 <quicksilver> Cale's MonadRandom abstracts the difference neatly
09:06:23 <quicksilver> a, LB plugins I know nothing about I'm afraid
09:06:53 <resiak> I will look at this MonadRandom!
09:07:23 <glguy> does Setup configure -p use -auto, -auto-all?
09:21:24 <shapr> @what CAF
09:21:24 <lambdabot> I know nothing about caf.
09:21:43 <quicksilver> shapr: Constant Applicative Form
09:21:55 <shapr> ok, thanks.
09:23:30 <quicksilver> Has anyone written a TCP proxy in haskell? Basically a port-forwarder which possibly processes the data it receives?
09:24:55 <fax> h
09:24:56 <fax> hi
09:25:02 <fax> can I use ghc without having hcc? :(
09:25:05 <fax> gcc I mean
09:27:56 <astrolabe> fax: I think so.
09:28:16 <astrolabe> (I mean, I think it includes it)
09:28:24 <fax> hm my program runs in ghci
09:28:47 <fax> I kept gettting ghc-6.4.1: could not execute: gcc
09:28:56 <fax> but I suppose I can just use ghci
09:29:27 <fantasma> how do I change the readability of a function
09:29:27 <astrolabe> fax: that's odd.  Sorry I can't help you,.
09:29:39 <fax> its cool I will just use ghci
09:30:01 <fantasma> for example: 1/9 to float 30 digits
09:30:59 <quicksilver> fantasma: you're actually asking 'how do I choose how to format a number as a string'
09:31:48 <fantasma> > show (1 / 9)
09:31:49 <lambdabot>  "0.1111111111111111"
09:31:55 <astrolabe> I haven't come across an arbitrary precision floating point library in haskell, so I'm not sure why you'd want to print out 30 places.
09:32:12 <glguy> > "0." ++ replicate 30 '1'
09:32:13 <lambdabot>  "0.111111111111111111111111111111"
09:32:15 <fax> > "0." ++ repeat '1'
09:32:17 <lambdabot>  "0.1111111111111111111111111111111111111111111111111111111111111111111111111...
09:32:17 <fax> damn!
09:32:20 <fax> you are faster
09:32:28 <fantasma> 1 / 9 was just an example
09:32:28 <glguy> agreed ;)
09:32:50 <fax> grrr
09:32:51 <astrolabe> glguy: now do 30 places of pi :)
09:32:53 <fax> my OpenGL isnt working
09:33:06 <quicksilver> astrolabe: no, nonetheless I'm very surprised the functionality isn't somewher ein core
09:33:07 <fax> 3.14159265358979323846264338327950288419716939937510
09:33:09 <rashakil__> if it's a Float, the decimal expansion won't even reach 30 places.
09:33:10 <fax> muhahaha
09:33:17 <quicksilver> astrolabe: there ought to be Data.Double or something
09:33:22 * astrolabe bows to fax
09:33:25 <quicksilver> :t printf
09:33:27 <lambdabot> forall r. (PrintfType r) => String -> r
09:33:32 <glguy> > take 32 "3.1415926535897932384626433832795028841971693993751058209749445923078164"
09:33:34 <lambdabot>  "3.141592653589793238462643383279"
09:33:53 <quicksilver> printf "%0.6d" (1/9) :: String
09:33:59 <quicksilver> > printf "%0.6d" (1/9) :: String
09:34:00 <lambdabot>  Exception: Printf.printf: bad argument
09:34:08 <quicksilver> > printf "%0.6d" (1.0/9) :: String
09:34:10 <lambdabot>  Exception: Printf.printf: bad argument
09:34:15 <quicksilver> > printf "%0.6f" (1.0/9) :: String
09:34:16 <lambdabot>  "0.111111"
09:34:24 <quicksilver> that's the best way I know of
09:34:25 <fax> :\
09:34:30 <fax> does OpenGL work in GHCI?
09:34:37 <fantasma>  > printf "%1f" (1.0/9) :: String
09:34:42 <fantasma> > printf "%1f" (1.0/9) :: String
09:34:44 <lambdabot>  "0.1111111111111111"
09:34:46 <fax> I get a window open via GLUT but no graphics
09:34:47 <quicksilver> fax it does last time I tried, yes
09:34:50 <fax> hm ok
09:34:54 <fantasma> > printf "%2f" (1.0/9) :: String
09:34:55 <lambdabot>  "0.1111111111111111"
09:35:03 <quicksilver> > printf "%6.2f" (1.0/9) :: String
09:35:04 <lambdabot>  "  0.11"
09:35:21 <quicksilver> fantasma: before the . is total number of chars (includes the decimal), after the dot is decimal places
09:35:39 <fantasma> ah I see
09:35:49 <fantasma> > printf "%0.20f" (1.0/9) :: String
09:35:51 <lambdabot>  "0.11111111111111110000"
09:35:58 <fantasma> of course :(
09:36:05 <quicksilver> now you just need a better precision type
09:36:12 <fantasma> > printf "%0.20f" (1.0/9) :: Double
09:36:13 <lambdabot>   add an instance declaration for (PrintfType Double)
09:36:13 <lambdabot>     In the expression: ...
09:36:19 <astrolabe> @type showEFloat
09:36:20 <quicksilver> > printf "%0.20f" (1%9) :: String
09:36:21 <lambdabot>   add an instance declaration for (PrintfArg (Ratio t))
09:36:21 <lambdabot>     In the expression...
09:36:21 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
09:36:34 <quicksilver> heh. Ratios aren't printf args. Shame.
09:36:48 <fantasma> @src showEFloat
09:36:48 <lambdabot> Source not found. stty: unknown mode: doofus
09:37:02 <fantasma> > showEFloat (1 / 9)
09:37:03 <lambdabot>        add an instance declaration for (Fractional (Maybe Int))
09:37:16 <fantasma> @hoogle showEFloat
09:37:17 <lambdabot> Numeric.showEFloat :: RealFloat a => Maybe Int -> a -> ShowS
09:37:37 <astrolabe> but the sadly, the Maybe Int in ShowEFloat is a maximum only :(
09:38:02 <quicksilver> @instances RealFloat
09:38:04 <lambdabot> Double, Float
09:38:14 <quicksilver> @hoogle BigFloat
09:38:15 <lambdabot> No matches found
09:38:29 <quicksilver> I'm quite surprised no one has bothered to write a big float of one kind or another
09:38:45 <astrolabe> > showEFloat (Just 30) (1/9) ""
09:38:47 <lambdabot>  "1.111111111111111000000000000000e-1"
09:39:01 <hpaste>  fax pasted "basic gl " at http://hpaste.org/895
09:39:03 <quicksilver> you could knock one up using a string representation easily enough
09:39:04 <astrolabe> > showEFloat (Just 50) (1/9) ""
09:39:05 <lambdabot>  "1.11111111111111100000000000000000000000000000000000e-1"
09:39:17 <astrolabe> oh, maybe it isn't a maximum.
09:39:19 <fax> I wonder if it work in ghci..?
09:39:22 <fax> doesnt for me
09:39:28 <fantasma> thanks astrolabe :)
09:39:52 <fantasma> > showEFloat (Just 50) (1/7) ""
09:39:54 <lambdabot>  "1.42857142857142850000000000000000000000000000000000e-1"
09:40:23 <quicksilver> > showEFloat (Just 30) (pi) ""
09:40:25 <lambdabot>  "3.141592653589793000000000000000e0"
09:40:27 * fantasma has to go to class, bbiab
09:41:23 <fax> ugh this is bad
09:41:42 <fax> I dont think I can work on my program until monday: |
09:42:35 <glguy> > let aux a b = intToDigit d : aux (m * 10) b where (d,m) = a `divMod` b in aux 1 9
09:42:36 <lambdabot>  "011111111111111111111111111111111111111111111111111111111111111111111111111...
09:42:40 <glguy> > let aux a b = intToDigit d : aux (m * 10) b where (d,m) = a `divMod` b in aux 2 3
09:42:41 <lambdabot>  "066666666666666666666666666666666666666666666666666666666666666666666666666...
09:42:44 <glguy> > let aux a b = intToDigit d : aux (m * 10) b where (d,m) = a `divMod` b in aux 2 7
09:42:46 <lambdabot>  "028571428571428571428571428571428571428571428571428571428571428571428571428...
09:43:03 <quicksilver> glguy: nice :)
09:43:26 <pjd> which monad tutorial metaphor involved oceans again?
09:43:46 <fax> the one with radioactive waste in a spacesuit in the ocean?
09:44:54 <quicksilver> @karma+ dmhouse
09:44:54 <lambdabot> dmhouse's karma raised to 8.
09:45:02 <quicksilver> correcting SPJ about his own language :)
09:45:06 <quicksilver> (correctly)
09:45:48 <pjd> fax: nah, the real tutorial :)
09:46:36 <dmhouse> quicksilver: hehe :)
09:48:12 <fax> any ideas why ghci is not working well with GLUT/OpenGL?
09:50:03 * fantasma is on irc during english class :)
09:51:02 <arcatan> i don't think chatting on irc necessarily makes your better in english
09:51:34 <fantasma> this class is a joke
09:52:07 <quicksilver> @users
09:52:07 <lambdabot> Maximum users seen in #haskell: 339, currently: 319 (94.1%), active: 57 (17.9%)
09:52:17 * quicksilver wonders what the odds are that one of those 339 is fantasma's teacher
09:52:24 <nominolo> lambdabot: tell joe fantasma that this channel is logged ;)
09:52:45 <nominolo> stupid bot :/
09:52:53 <fantasma> haha
09:53:13 <nominolo> oh, d
09:53:17 <nominolo> d'oh
09:53:35 <nominolo> how did that "joe" get in there?
10:01:22 <sjanssen> @keal
10:01:23 <lambdabot> 99% of my book has been erased by faulty hdd's
10:01:50 <shapr> heh
10:02:03 <shapr> @keal
10:02:03 <lambdabot> there is no way to prove the failsafe exists
10:02:07 <shapr> @protontorpedo
10:02:08 <lambdabot> wat is lazy evaluation?
10:02:33 <fantasma> @fantasma
10:02:34 <lambdabot> Unknown command, try @list
10:02:38 <fantasma> @quote
10:02:39 <lambdabot> mathewm says: I am playing with (.)
10:02:44 <fantasma> lol!
10:03:03 <fantasma> @quote
10:03:04 <lambdabot> Botty says: holy crap, knew smerdy sounded familiar - about 2 years ago he was trying to convince me to throw out my mouse
10:05:12 <fantasma> :t lines
10:05:15 <lambdabot> String -> [String]
10:07:27 <shapr> @quote fanta
10:07:28 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
10:07:32 <shapr> @quote shapr
10:07:32 <lambdabot> shapr says: GHC has more flags than the UN
10:07:37 <shapr> @quote sjanssen
10:07:38 <lambdabot> sjanssen says: <font size="3">did I write something that had HTML in it?</font>
10:07:46 <shapr> @quote dons
10:07:46 <lambdabot> dons says: This is all very nice, but the code feels a bit icky.
10:07:54 <shapr> @quote nom
10:07:55 <lambdabot> ghc says: falls under the monomorphism restriction
10:08:01 <shapr> @quote simon
10:08:02 <lambdabot> sorear says: StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
10:08:17 <fantasma> @quote shapr
10:08:18 <lambdabot> shapr says: Academics are continually chewing pieces off of impossible and making them merely difficult.
10:08:40 <fantasma> @quote lambdabot
10:08:41 <lambdabot> lambdabot says: Nobody brings small problems into a laundromat.
10:09:47 <fantasma> @quote
10:09:48 <lambdabot> ChilliX says: You need to seek a balance between category theory and VLSI
10:11:34 <nominolo> heh
10:13:32 <pjd> haha
10:15:53 <matthew_-> gimme a clue: opening and reading files
10:20:36 <mauke> @hoogle open
10:20:37 <lambdabot> IO.openFile :: FilePath -> IOMode -> IO Handle
10:20:37 <lambdabot> System.IO.openBinaryFile :: FilePath -> IOMode -> IO Handle
10:20:37 <lambdabot> System.IO.openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
10:20:46 <pjd> mathrick: http://www.haskell.org/onlinereport/io-13.html ?
10:20:47 <lambdabot> Title: The Haskell 98 Report: Basic Input/Output
10:22:23 <mathrick> pjd: matthew_-
10:22:29 <fantasma> I use the io functions in prelude -- is the System.IO module better?
10:22:46 <mathrick> pjd: you might want to try /set completion_amount 0
10:23:13 <pjd> mathrick: argh, sorry
10:23:31 <kscaldef> fantasma: more like, more comprehensive
10:23:37 <pjd> hey, thanks
10:24:26 <fantasma> kscaldef: ah, well I'm only doing basic io at the moment and prelude is working fine
10:27:07 <fantasma> @hoogle read
10:27:08 <lambdabot> Prelude.read :: Read a => String -> a
10:27:08 <lambdabot> Text.Read :: module
10:27:08 <lambdabot> Prelude.Read :: class Read a
10:29:34 <quicksilver> Hmm. It looks to me that Networ.accept is intriniscally blocking and the only way to use it in a real server is ghc threads?
10:32:12 <sjanssen> quicksilver: yes, the typical way in Haskell is to use threads
10:32:35 <sjanssen> quicksilver: ghc's thread implementation scales very well, so it shouldn't be a problem
10:37:38 <quicksilver> sjanssen: thanks
10:38:19 <quicksilver> sjanssen: supposing I am proxying TCP (2-way). Shall I then make 2 threads per client and use blocking ops, instead of  trying to handle the non-blokcing myself?
10:39:39 <sjanssen> quicksilver: probably
10:39:41 <SyntaxNinja> kzm: alive?
10:39:49 <sjanssen> there aren't any convenient bindings to select and the like
10:40:01 <SyntaxNinja> malcolmw: alive?
10:40:24 * quicksilver nods
10:40:25 <malcolmw> SyntaxNinja: hi there
10:40:53 <quicksilver> sjanssen: I don't seem to see a simple 'hGet', only 'hGetBuf' which require me to set up a buffer as a Ptr a
10:41:07 <pjd> sjanssen: doesn't it use select under the hood?
10:41:23 <quicksilver> pjd: yes, it does
10:41:27 <sjanssen> pjd: yes, it does.  But you can't directly use select if you need to
10:41:42 <quicksilver> hmph I think I do need hGetNonBlocking
10:41:47 <quicksilver> I never want to wait for data
10:41:56 <pjd> sjanssen: well, you wouldn't need to, would you? :)
10:41:57 <sjanssen> quicksilver: you want something like: hGet :: Handle -> IO [Word8]?
10:42:26 <quicksilver> sjanssen: yes. Which fetches 'a sensible amount, whatever is avaialble, and doesn't block'
10:42:40 <sjanssen> yeah, you need hGetNonBlocking
10:42:48 <quicksilver> well to be more precise. I don't mind if it blocks if nothing is available
10:43:01 <quicksilver> but I don't want it to block just because it thinks it wants to fill a buffer a bit more
10:43:25 <quicksilver> indeed, in an dieal world it would blck if nothing available. Nothing to forward then.
10:43:37 <pjd> quicksilver: wait, were you talking about accept blocking the Haskell thread, or actually blocking at the OS process level?
10:44:05 <quicksilver> pjd: the haskell thread (my only thread)
10:44:18 <quicksilver> pjd: the program isn't using threads yet, but I'm realising it will need to
10:44:34 <pjd> but then it is non-blocking under the hood, right?
10:44:40 <sjanssen> quicksilver: you probably want to use hWaitForInput in combination with hGetNonBlocking
10:44:56 <quicksilver> sjanssen: ah, thank you!
10:45:07 <quicksilver> now how do I allocate a buffer suitable for 'Ptr a' ?
10:45:17 <sjanssen> quicksilver: also, Data.ByteString might have equivalents of this function
10:45:18 <mauke> @hoogle alloca
10:45:19 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
10:45:19 <fasta> Is there something like (gensym) in CPP?
10:45:19 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
10:45:19 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
10:45:38 <mauke> fasta: no, it's generally faked using __LINE__
10:45:41 <quicksilver> sjanssen: I nothiced that bytestring had a slightly different set of hGet prims, yes
10:45:45 <quicksilver> maybe I'll use that one
10:46:03 <quicksilver> hGetNonBlocking :: Handle -> Int -> IO ByteString
10:46:07 <quicksilver> this looks promising
10:46:12 <fasta> mauke: thanks
10:46:14 <quicksilver> saves me from messing with alloca
10:46:58 <malcolmw> SyntaxNinja: not sure whether you can see my PMs
10:48:32 <chessguy> @type StateT
10:48:35 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
10:49:31 <SyntaxNinja> does anyone else have trouble emailing kzm?
10:51:07 <chessguy> can't say i've tried
10:58:19 <resiak> > (('x':) &&& id) ("foo", "bar")
10:58:20 <lambdabot>  Couldn't match expected type `[Char]'
10:58:37 <resiak> I'd expect that to spit out ("xfoo", "bar").  What am i misunderstanding here?
11:00:45 <sjanssen> @hoogle &&&
11:00:46 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
11:01:09 <sjanssen> resiak: you're using the wrong combinator
11:01:11 <resiak> I'm using the wrong arrow!
11:01:20 <resiak> I just figured out that I can't read type signatures
11:01:44 <resiak> Do I in fact want apfst?
11:01:54 <chessguy> :k StateT
11:01:57 <lambdabot> * -> (* -> *) -> * -> *
11:05:08 <resiak> alternativley I could read the documentation and discover that I'm after ***.
11:08:22 <glguy> http://3.141592653589793238462643383279502884197169399375105820974944592.com/
11:08:24 <lambdabot> Title: Pi to 1,000,000 places, http://tinyurl.com/e7v6
11:08:37 <xerox> > first ('x':) ("foo","bar") -- resiak
11:08:39 <lambdabot>  ("xfoo","bar")
11:09:20 <fouad> hi, i am not sure if this is the right channel for my question, but i get this error while trying to compile hugs, jw: No parser available
11:10:00 <resiak> xerox: Yes, read the definition of *** and inferred that that was waht I wanted.  Thanks :-)
11:10:50 <shapr> fouad: I've never seen that before, what platform, version, etc?
11:11:01 <fouad> uname -a gives
11:11:08 <fouad> Linux core 2.6.18-gentoo-r5 #1 SMP Sat Dec 9 22:59:49 UTC 2006 x86_64 AMD Athlon(tm) 64 Processor 3000+ AuthenticAMD GNU/Linux
11:11:30 <fouad> btw ./configure does not complain about anything
11:11:31 <fouad> :(
11:11:33 <shapr> What command are you using to build hugs?
11:11:42 <fouad> ./configure
11:11:44 <fouad> then make
11:11:48 <fouad> and i get this
11:11:50 <shapr> Doesn't gentoo already have a hugs package that you can use?
11:12:16 <sjanssen> shapr: yes, it does
11:12:33 <fouad> it does
11:12:45 <fouad> i just wanted to compile from source
11:16:04 <beelsebob_> if I init a darcs repo does it init it in the directory my project is already in?
11:16:16 <fouad> i was just checking my package management and hugs requires an older version of docbook-sgml-dtd than the one installed, might that be it?
11:16:17 <beelsebob_> as in - does my project directory effectively become the darcs repo?
11:16:32 <sm> beelsebob_: yes
11:16:52 <beelsebob_> so if I have a copy locally already, and want to set up the repo in webspace
11:16:56 <beelsebob_> I should copy to the webspace
11:16:58 <beelsebob_> init there
11:17:04 <beelsebob_> and then checkout to check it all worked?
11:17:05 <chessguy> beelsebob_: yes. http://haskell.org/haskellwiki/How_to_write_a_Haskell_program#Stick_it_in_darcs for an example session
11:17:07 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
11:17:38 <sjanssen> beelsebob_: does the webspace have darcs and ssh installed?
11:17:44 <beelsebob_> sjanssen: yes
11:17:51 <sjanssen> beelsebob_: then use darcs put
11:18:04 <beelsebob_> ah, okay, is there a good example of doing this?
11:18:27 <sjanssen> in the already initialized darcs project: darcs put username@host:directory/to/put/darcs/repo
11:18:38 <beelsebob_> okay
11:18:44 <sjanssen> beelsebob_: you should only use darcs initialize once
11:18:51 <beelsebob_> and that uses scp to copy it up there?
11:18:54 <sjanssen> the rest of the time you use get/put
11:19:12 <beelsebob_> sure, my plan was to copy it there, init, and then get
11:19:19 <beelsebob_> but if I can just init and then put, that works
11:19:21 <sjanssen> beelsebob_: it ssh's to the remote server and calls darcs on the remote server
11:19:27 <beelsebob_> okay
11:19:55 <sjanssen> you could also use scp, but then you wouldn't use darcs init on the remote copy
11:20:31 <sjanssen> beelsebob_: after you darcs init, you need to darcs add all your files, then record
11:20:37 <beelsebob_> indeed
11:20:40 <beelsebob_> done that
11:23:31 <beelsebob_> I take it doing the darcs put may take a while
11:26:22 <dylan> anyone used ikiwiki with darcs here?
11:26:37 <dylan> or written something like ikiwiki that works with darcs?
11:48:32 <smack_vaio> i'm trying to follow the hat docs, but hmake says "unknown package: hat" when i try to build for tracing
11:48:34 * SamB ponders again his type-programming problem
11:48:47 <chessguy> type-programming?
11:48:58 * SamB had thought he had a solution, but sees now that he probably does not
11:49:10 <SamB> chessguy: you know. Like Text.Printf?
11:49:28 <chessguy> not familiar with it
11:49:31 <chessguy> ?hoogle Printf
11:49:32 <lambdabot> Text.Printf :: module
11:49:32 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
11:49:32 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
11:49:48 <SamB> > printf "%d %d" 1 2 :: String
11:49:49 <lambdabot>  "1 2"
11:49:57 <SamB> > printf "%d %d" 1 "hi!" :: String
11:49:58 <lambdabot>  Exception: Printf.printf: bad argument
11:50:18 <SamB> :t printf "%d %d" 1 "hi!"
11:50:20 <lambdabot> forall t t1. (Num t, PrintfType (t -> [Char] -> t1)) => t1
11:50:29 <smack_vaio> @src printf
11:50:29 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:50:43 * chessguy kicks BOB in the shin
11:51:06 <chessguy> wow, that's a weird type signature
11:51:17 <SamB> chessguy: yes. it is.
11:51:26 <chessguy> ?hoogle PrintfyType
11:51:26 <lambdabot> No matches found
11:51:29 <chessguy> ?hoogle PrintfType
11:51:30 <lambdabot> No matches found
11:51:47 <procyon_> @source fromJust
11:51:47 <lambdabot> fromJust not available
11:51:54 <SamB> I don't quite remember why it isn't given as PrintfType t => t
11:52:01 <procyon_> ?hoogle fromJust
11:52:01 <lambdabot> Maybe.fromJust :: Maybe a -> a
11:52:09 <chessguy> @?src fromJust
11:52:13 <chessguy> ?src fromJust
11:52:13 <lambdabot> fromJust Nothing  = undefined
11:52:14 <lambdabot> fromJust (Just x) = x
11:52:29 <SamB> @source Text.Printf
11:52:29 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
11:52:30 <procyon_> thx ;)
11:55:02 * SamB is trying to sort out some incoherently overlapping instances...
11:55:11 <SamB> instance (MarshallOut m a, Adapt m b) => Adapt m (a -> b)
11:55:16 <SamB> instance (MonadAdvent m, MarshallIn m b) => Adapt m (m b)
11:55:17 <smack_vaio> should hat show up in ghc-pkg list?
11:55:25 <procyon_> ?src lookup
11:55:26 <lambdabot> lookup _key []          =  Nothing
11:55:26 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
11:55:26 <lambdabot>                         | otherwise = lookup key xys
11:55:50 <pjd> SamB: do you want to make printf checked at compile-time?
11:56:04 <SamB> pjd: heh
11:56:06 <SamB> no
11:56:19 <pjd> that would be cool :)
11:57:22 * SamB is just trying to find a way to write a function from functions like this:
11:57:40 <SamB> class Monad m => MonadAdvent m where
11:57:46 <SamB>     moveSelfToRoom  :: Room m -> m ()
11:57:46 <SamB>     moveItemToRoom  :: Item m -> Room m -> m ()
11:58:35 <SamB> to functions with the type MonadAdvent m => [Value m] -> m (Value m)
11:58:56 <SamB> making use of:
11:58:58 <SamB> class MarshallIn m a where
11:58:58 <SamB>     marshallIn  :: a -> Value m
11:59:02 <SamB> class MarshallOut m a where
11:59:02 <SamB>     marshallOut  :: Value m -> a
12:02:26 <procyon_> Style question: I run into lots of situations in pattern matching where I want to handle case a -> do something; case b-> do something else; cases c through g->just return x, or alternatively, do nothing.  Now I've heard many times that "overlapping patters are considered harmful."  Stylistically, should I list out cases d through g explicitly, eliminating overlap but bloating the code, or should I overlap with a "match all" pattern?
12:03:24 <SamB> unfortunately, the typechecker cannot tell that I'm not going to make a MonadAdvent instance for an ((->) env) type...
12:03:43 <fantasma> anyone know of a good haskell implementation of Dijkstra's algorithm?
12:04:41 <sjanssen> Data.Graph or Data.Graph.Inductive might have one
12:04:57 <fantasma> @hoogle Data.Graph
12:04:58 <lambdabot> No matches, try a more general search
12:05:06 <fantasma> @hoogle shortest path
12:05:07 <lambdabot> Did you mean: Shortest Path
12:05:07 <lambdabot> Prelude.undefined :: a
12:05:07 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
12:05:36 <fantasma> is hoogle the best api docs for Haskell?
12:05:45 <sjanssen> @docs
12:05:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:05:56 * SamB wonders if he is going about this backwards
12:06:08 <SamB> I have a feeling I've tried this before :-(
12:06:36 <SamB> @hoogle IdT
12:06:37 <lambdabot> Text.Html.marginwidth :: Int -> HtmlAttr
12:06:37 <lambdabot> Text.Html.width :: String -> HtmlAttr
12:06:37 <lambdabot> System.Win32.NLS.lCMAP_FULLWIDTH :: LCMapFlags
12:06:39 <sjanssen> fantasma: hoogle is nice when you don't know which module something might be in, but the link above gives the most comprehensive information
12:07:05 <sjanssen> SamB: you want a transformed identity monad?
12:07:37 <SamB> sjanssen: well, I was pondering the cheap trick of sticking an IdT right before the return type of the functions...
12:08:04 <fantasma> sjanssen: thanks so much...i've been using this crappy reference at zvon.org
12:08:38 <SamB> sjanssen: do you know how to do the opposite of what printf does?
12:08:40 <dino-> fantasma: I did that too before I was directed to the ghc docs, used that zvon shit.
12:08:43 <dino-> not good
12:09:05 <sjanssen> SamB: opposite of what printf does?  Turn one piece of data into many?
12:09:16 <SamB> printf builds a function to match the type you want it to have
12:09:35 <SamB> I want to destroy a function ;-)
12:10:00 <sjanssen> "destroy" meaning completely apply all arguments?
12:10:11 <malcolmw> smack_vaio: yes, package hat should show up in ghc-pkg list
12:10:18 <SamB> well, replace them with a duck-typed argument list
12:10:42 <sjanssen> like an HList?
12:10:45 <malcolmw> smack_vaio: but it might be that ghc-6.6 expects it to be called hat-1.0 or something rather than plain hat
12:10:50 <SamB> HList is not duck typed!
12:11:04 <sjanssen> so you want to stick the arguments in some sort of record?
12:11:08 <smack_vaio> malcolmw: i found a mailing list post describing my problem, i hadn't run sh start
12:11:26 <malcolmw> smack_vaio: OK
12:12:43 <SamB> sjanssen: I want to make a Data.Map of functions with type (MonadAdvent m => [Value m] -> m (Value m))
12:13:36 <SamB> but they don't have that type yet
12:14:14 <sjanssen> and you already have the code to inject potential argument values into a Value m?
12:14:25 <SamB> sjanssen: yeah
12:14:42 <SamB> except I don't want to inject the argument values
12:15:07 <SamB> I want to do ... whatever the opposite of that is
12:16:59 <smack_vaio> malcolmw: (but even after that i have the same problem)
12:17:23 <titus> Hi all, has anybody here read `The Fun of Programming'? I've got a question about an exercise in the chapter on folds
12:17:27 <malcolmw> smack_vaio: and what is the problem exactly?
12:17:47 <smack_vaio> malcolmw: hat doesn't show up as a ghc-pkg
12:17:54 <smack_vaio> so hmake doesn't work
12:18:10 <malcolmw> did you install hat with 'make install'?
12:18:23 <titus> It's a great book btw :-)
12:18:34 <smack_vaio> malcolmw: yeah
12:18:47 <glguy> Cale: you about?
12:18:57 <Cale> yeah?
12:19:04 <smack_vaio> Installing hat as a ghc package:
12:19:04 <smack_vaio> Installing hat package for ghc under /usr/local/lib/hat-2.05/ix86-Linux/ghc-606
12:19:04 <smack_vaio> ghc-pkg: cannot find package hat
12:19:04 <smack_vaio> cp: cannot stat `lib/ix86-Linux/hatlib/ghc/Hat/Data/*.hi': No such file or directory
12:19:10 <glguy> I know you've been asked this before about your RSS aggregator
12:19:11 <smack_vaio> whoops, more spam than i thought, sorry
12:19:31 <malcolmw> smack_vaio: oh wait, that is something different altogether
12:19:32 <glguy> Cale: do you know what the trick was where people would try to do the "atTag" on multiple elements
12:19:41 <glguy> and it wouldn't stack properly and would return no elements
12:19:46 <glguy> something about the order of getChildren
12:20:07 <Cale> uh, I haven't been asked that one before
12:20:11 <malcolmw> smack_vaio: the first message about 'cannot find package hat' comes from the installer attempting to delete any version of hat that is already installed, so don't worry about that
12:20:15 <glguy> then I'm not asking it right :)
12:20:29 <dino-> glguy: Got me interested now too. Can you show an example of what you mean?
12:20:38 <Cale> If you compose two different atTags, then you'll end up with something which will give you nothing, that's obvious. (Or should be)
12:20:54 <malcolmw> smack_vaio: the important part of the message is that it can't find the Hat/Data/*.hi interface files
12:20:56 <hpaste>  glguy pasted "hxt stuff" at http://hpaste.org/896
12:20:58 <Cale> There's only one tag name per tag :)
12:21:06 <glguy> well, I'm not doing *that*
12:21:19 <smack_vaio> malcolmw: ok
12:21:24 <malcolmw> smack_vaio: are you using the darcs version by any chance?
12:22:02 <glguy> the xml is <a><b><FirstName>c</FirstName><LastName>d</LastName></b></a>
12:22:38 <glguy> roughly
12:22:48 <smack_vaio> malcolmw: i am
12:22:56 <Cale> Do they each work individually?
12:23:16 <malcolmw> smack_vaio: OK, I haven't tested installing from the darcs version for a bit.
12:23:21 <glguy> Cale: yes
12:23:27 <glguy> if I comment out one, the other works
12:23:58 <malcolmw> smack_vaio: I recently deleted a lot of the hierarchical library stuff from the default hatlib, with the intention of putting it back in a more up-to-date form
12:24:14 <malcolmw> smack_vaio: but the latter part has not happened yet :-(
12:24:53 <Cale> glguy: interesting :)
12:24:59 <malcolmw> smack_vaio: I suppose you might try unpulling the patches that did the deletion
12:25:01 <Cale> Let me try it
12:25:28 <glguy> I thought it had something to do with doing the getChildren in the wrong place
12:25:37 <glguy> the first atTag was killing the second tag
12:25:50 <glguy> and then the whole thing failed as a result
12:26:18 <malcolmw> smack_vaio: found the relevant patch:  * Remove (or comment out) all the base,mtl,parsec package modules from hatlib
12:26:35 <glguy> Cale: this fixes it:
12:26:39 <glguy> atTag name = getChildren >>> isElem >>> hasName name
12:26:55 <glguy> (I have to delete one of the getChildren calls from my main function then
12:26:57 <Cale> um, I'm not getting any results for just f
12:27:05 <Cale> With the sample XML you provided.
12:27:12 <glguy> OH
12:27:17 <glguy> delete the outer most element
12:27:23 <glguy> I looked at the file I'm using wrong
12:27:32 <titus> what would you understand by "transposition" of a list of lists?
12:27:55 <dino-> You know, the atTag that I shamelessl stole from Cale's code is: deep $ isElem >>> hasName ...
12:28:00 <dino-> shamelessly
12:28:14 <titus> I am doing an exercise on implementing shellsort and I need to define the function:
12:28:25 <titus> trans :: List (List a) -> List (List a)
12:28:32 <glguy> dino-: that might be what I'm doing wrong!
12:28:38 <titus> but I don't know what it's meant to do...
12:28:44 <fantasma> @src Data.Graph.Inductive.Query.SP.dijkstra
12:28:44 <lambdabot> Source not found. You speak an infinite deal of nothing
12:28:59 <sjanssen> SamB: is overlapping/undecidable instances okay?
12:29:01 <dino-> glguy: Without the deep, the isElem >>> hasName has to match the immediate nodes it's being run with.
12:29:08 <glguy> dino-: that was ok
12:29:12 <glguy> dino-: the problem is that if you do that
12:29:14 <Cale> glguy: yeah, that's not the same as my atTag
12:29:19 <glguy> the filter on the first breaks the second
12:29:26 <Cale> Your atTag tests to see if you're at that tag.
12:30:03 <glguy> the ArrowApply instance makes the HXT arrow non-intuitive
12:30:09 <Cale> huh?
12:30:13 <Cale> It makes it a monad
12:30:15 <glguy> right
12:30:20 <glguy> and makes the sequencing meaningful
12:30:21 <pjd> titus: as in zip?
12:30:35 <glguy> so that x going into both lines of my readCustomer function
12:30:37 <glguy> doesn't do what you might thing
12:30:37 <Cale> Only when you use -<<
12:30:38 <glguy> think
12:30:43 <glguy> hmm
12:30:59 <pjd> titus: [[1,2,3],[4,5,6]] -> [[1,4],[2,5],[3,6]] ?
12:30:59 <titus> pjd: don't think so
12:31:13 <glguy> -<< only affects if the variables go into scope
12:31:13 <titus> pjd: ah, maybe!
12:31:21 <glguy> not if sideeffects happen
12:31:24 <glguy> in the context of the arrow
12:31:27 <glguy> right?
12:31:43 <Cale> Oh, side effects.
12:31:46 <pjd> > transpose [[1,2,3],[4,5,6]]
12:31:47 <lambdabot>  [[1,4],[2,5],[3,6]]
12:31:50 <pjd> wooh
12:31:55 <titus> the exercise is to implement it once as a fold and once as an unfold
12:31:57 <Cale> Okay, yeah, the ordering of the lines of the proc matters in that regard.
12:32:09 <Cale> Most of the HXT stuff is relatively side-effect free.
12:32:21 <glguy> but the filtering still works in an ordered fashion
12:32:42 <Cale> You should still get the same results in the end.
12:33:09 <smack_vaio> malcolmw: hmm... now it shows up as:
12:33:18 <smack_vaio> /root/.ghc/i386-linux-6.6/package.conf:
12:33:18 <smack_vaio>     (hat-2.5)
12:33:18 <smack_vaio>  for root, but not as a normal user...
12:33:19 <glguy> the filters that occur in the first line of my proc function affect the stuff in the second line
12:33:30 <glguy> even though they both pretend to refer to the same variable "x"
12:33:41 <malcolmw> smack_vaio: how annoying
12:33:51 <Cale> glguy: and vice-versa :)
12:34:09 <Cale> I hadn't noticed initially that your atTag was missing the deep
12:34:24 <malcolmw> smack_vaio: looks like when you logged in as root to register the package, ghc-pkg decided to make a 'local' configuration for the root user only!
12:34:28 <glguy> the deep just generates a new list, so that it filters a separate list
12:34:32 <xaaax> in the context of functional programming, is a fsm a good way to mantain state?
12:34:33 <glguy> just like it also worked with getChildren
12:34:34 <Cale> (or otherwise you'd need an extra getChildren as you noticed)
12:34:38 <Cale> right
12:34:43 <glguy> which is counter-intuitive, no?
12:34:51 <malcolmw> smack_vaio: have you tried registering the package as yourself rather than root?
12:35:01 <smack_vaio> i haven't
12:35:02 <Cale> What your original code was doing was checking that x was simultaneously a FirstName and LastName
12:35:27 <glguy> hmm
12:35:28 <glguy> ok
12:35:30 <Cale> and only producing a result when there was a result for both f and l
12:35:32 <glguy> right
12:35:36 <glguy> I see it now
12:35:41 <smack_vaio> malcolmw: make install doesn't do anything as normal user
12:35:47 <glguy> I need to look at this like it's running a highly parallel list monad
12:35:47 <Cale> Imagine that x is some position in the XML tree.
12:36:01 <Cale> (fixed position)
12:36:04 <glguy> right
12:36:17 <glguy> ok, that helps
12:37:42 <malcolmw> smack_vaio: maybe try just ghc-pkg register lib/ix86-Linux/hatlib/ghc/pkg.conf (or wherever the cabal-file lives, I can't remember exactly)
12:38:12 <dino-> Aside from talking to Cale, this helped me a lot with seeing the list monadyness: http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml
12:39:32 <smack_vaio> cannot finde libHShat.a
12:39:52 <glguy> too bad there isn't a hit library
12:42:09 <malcolmw> smack_vaio: maybe I need to look into debugging the installer properly.
12:42:27 <bos> glguy: you operate in similar ways to me
12:42:40 <SamB> sjanssen: overlapping I can deal with
12:42:50 <glguy> bos: like a 10 year old?
12:42:51 <SamB> but the compiler tells me that what I have now are incoherent!
12:42:51 <smack_vaio> malcolmw: let me know if something needs testing
12:43:00 <glguy> potty humor!
12:43:12 <glguy> bos: or relating to my coding? :)
12:43:33 <SamB> and I must say I rather agree with it
12:44:19 <glguy> bos: How do you mean ? :)
12:44:39 <SamB> unfortunately, I can't say "not instance MonadAdvent (r ->)"
12:44:57 <SamB> which would let me do what I want
12:45:05 * glguy feels cheated
12:45:29 <bos> glguy: yes, like a 10-year-old :-)
12:52:23 <SamB> @slap glguy
12:52:23 <lambdabot> why on earth would I slap glguy
12:52:25 <malcolmw> smack_vaio: I'm just pushing a new patch to comment out any references to hierarchical library dirs in the installation scripts
12:52:38 * SamB points at the slap feature
12:53:14 <malcolmw> smack_vaio: feel free to test by rebuilding and reinstalling (make clean not necessary first)
12:55:04 <smack_vaio> malcolmw: should i repull that other patch?
12:55:16 <malcolmw> smack_vaio: yeah, probably
13:00:36 <glguy> catA . map (readDocument [(a_validate,v_0)] $ srcs --- does that mean that there isn't a mapA?
13:00:36 <smack_vaio> still no hat package
13:00:43 <glguy> ?hoogle mapA
13:00:43 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
13:00:44 <lambdabot> List.mapAccumR :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
13:00:44 <lambdabot> Monad.mapAndUnzipM :: Monad a => (b -> a (c, d)) -> [b] -> a ([c], [d])
13:00:48 <glguy> ?hoogle catA
13:00:49 <lambdabot> System.Win32.NLS.lANG_CATALAN :: PrimaryLANGID
13:00:58 <malcolmw> smack_vaio: current error message?
13:01:08 <glguy> err, I guess that'd be concatMapA
13:02:04 <smack_vaio> looks like install doesn't install it because it's already in /root/.ghc...
13:02:15 <smack_vaio> so it skips installing the package
13:02:43 <SamB> smack_vaio: sounds like a bug to me
13:03:37 * smack_vaio too
13:04:12 <SamB> so is it a cabal bug or a GHC bug?
13:07:02 <malcolmw> probably a hat install-script bug
13:07:58 <SamB> not cabalized?
13:08:18 <smack_vaio> nope
13:08:34 <SamB> oh. so how does it try to install the package?
13:08:40 <tmoertel> Cale: a moderately evil hack to lazify unfoldTreeM from the outside via the step function: http://programming.reddit.com/info/18mm1/comments/c194u8
13:08:42 <lambdabot> Title: Directory-tree printing in Haskell, part two: refactoring (reddit.com)
13:09:42 <Cale> tmoertel: cool
13:10:10 <tmoertel> I'm not feeling good about the "guarantees" LazyIO offers, however.
13:11:35 <malcolmw> SamB: copies lib and .hi files to system dir, calls ghc-pkg register
13:12:24 <SamB> and ghc-pkg register refuses to register the package globally because it is already registered locally?
13:13:36 <malcolmw> I'm not sure how it came to be registered in root's home directory in the first place
13:14:13 <SamB> malcolmw: that is not the point
13:14:32 <SamB> ghc-pkg should do what it is told
13:14:42 <smack_vaio> i think the install script first checks if it's installed, then doesn't register it if it finds a copy?
13:14:50 <SamB> oh.
13:15:00 <SamB> you really think so?
13:15:25 <malcolmw> smack_vaio: no, no, it always attempts to de-register any existing installation first, then always registers
13:16:09 <malcolmw> if there is no existing installation, then ghc-pkg gives a (harmless, but potentially confusing) warning
13:18:09 <malcolmw> smack_vaio: looking at the install script closer, I'm sure there is no need to run it as root at all, provided you have permission to write files in the dir specified to configure --prefix=...
13:18:31 <Saizan> glguy,Cale re HXT: so when i do x' <- getChildren -< x, x' is only representing one fixed child at a time and not a list of all of them?
13:21:47 <SamB> Saizan: hmm...
13:21:50 <SamB> good question.
13:22:04 * SamB isn't sure x' HAS a value, per se, there
13:23:36 * SamB decides to use incoherent instances for now
13:28:42 <Saizan> SamB: what do you mean?
13:31:52 <SamB> Saizan: well, I think it actually has a stream associated with it
13:37:23 <glguy> Saizan: I think it is actually the list of them
13:38:28 <glguy> the inner workings of HXT's arrow are like Monad []
13:38:45 <glguy> so... maybe you are right and it's each one
13:38:59 <glguy> err
13:39:00 <glguy> heh
13:39:09 <glguy> yeah it is
13:39:17 <glguy> that's what my atTag experiments showed
13:39:52 <pafcu> Hi. I'm having some problems debugging my program
13:40:25 <Botje> pafcu: what kind of problems?
13:40:26 <pafcu> I keep getting "Prelude.init: empty list", but I'm certain that I dont give an empty list to any init function
13:40:43 <Botje> could you put your code on hpaste for us to see?
13:40:45 <Botje> @go hpaste
13:40:49 <lambdabot> http://hpaste.org/
13:40:49 <lambdabot> Title: recent - hpaste
13:41:03 <pafcu> Botje The code is rather long
13:41:05 <glguy> pafcu: the compiler probably isn't lying :)
13:41:26 <Botje> pafcu: try to distill it down to the smallest code that still fails
13:41:37 <Botje> more often than not you find the error before you even get to the pastebin :)
13:41:45 <pafcu> OK. I realised my mistake
13:42:06 <pafcu> I checked for empty lists with assert, but forgot to remove optimizations when compiling
13:43:05 <pafcu> Just curious, if a Prelude function calls init with an empty list, would I see the same error message, i.e would it point at the wring function?
13:43:23 <glguy> pafcu: no
13:43:39 <glguy> ?fptools Prelude
13:43:40 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
13:43:52 <shapr> coi pafcu .i xu do tavla bau la lojban
13:44:45 <pafcu> shapr Sorry don't know enough to actually speak Lojban
13:45:00 <shapr> Ah, ok. Your nickname looks like lojban.
13:45:20 <pafcu> shapr Although I have made several attempts to learn it
13:45:43 <shapr> Ok, what about hyvää huomenta!
13:45:44 <pafcu> shapr: Well not really, since it doesn't end in a consonant
13:46:00 <pafcu> Nyt on kyllä jo ilta :-)
13:46:11 <shapr> True, but you could have picked a non-name word from lojban.
13:46:30 <glguy> ko bajra
13:46:33 <shapr> Minä olen amerikkalainen, muuta Minä en puhun suomea ;-)
13:46:43 <shapr> en puhu*
13:47:21 <shapr> Men, jag kan tala mycket svenska :-) tvärr att finska vill inte tala svenska...
13:47:51 <pafcu> shapr: Jag är finlandssvensk så jag talar gärna båda språken
13:47:59 <shapr> Ah! Vad bra!
13:48:17 <fuzan> lobjan speakers are like the uber nerd elite.
13:48:35 <Nafai> Hey shapr!
13:48:37 <shapr> fuzan: Actually, that was Finnish and Swedish that just went past
13:48:58 <fuzan> alright, you're safe then :)
13:49:05 <shapr> pafcu: Jag är Alabamsk (från Alabama i USA), men jag kan tala mer än bara Engelska.
13:50:13 <shapr> fuzan: Of course, I spoke lojban before that =)
13:50:36 <pafcu> shapr: Har du släkt från Sverige, eller hur kommer det sig att du lärt dig svenska?
13:51:10 <pafcu> Better switch to English so we don't confuse the others :-)
13:51:34 <shapr> Jag bodde i Tornio först, och Boden och Stockholm efter. Tre och ett halft år i varje plats.
13:51:43 <shapr> Well, there are a surprising number of Finns and Sweden here on #haskell.
13:52:09 <shapr> Yeah, I lived in Tornio for 3.5 years, and then Boden for 3.5 years.. and then Stockholm for a few months after that.
13:52:19 <shapr> Now I'm back in Alabama for the time being.
13:53:10 <shapr> pafcu: Since you're finlandssvensk, I don't have to ask you where you learned Finnish and Swedish :-)
13:54:04 <shapr> pafcu: How'd you get into Haskell? Business or pleasure?
13:54:42 <pafcu> Pleasure. I'm actually an physics major.
13:55:12 <pafcu> Sounded like an interesting language, and it just keeps getting more interesting
13:58:04 <glguy> Cale: ?
14:03:52 * nominolo came to sweden and got sucked into haskell-land here, too
14:04:28 <SamB> is there some kind of "type computation cookbook" I can look at?
14:05:02 <nominolo> SamB, what do you want to do?
14:06:14 <SamB> I want to look through it to see if I see some typeclasses that do pretty much what I want to do ;-)
14:06:58 <nominolo> hm, well.  If you find one, I'd like to have a look at it also
14:07:16 <nominolo> ;)
14:14:17 <SamB> oh yay!
14:14:34 <SamB> I figured out how to do what I need
14:15:51 <SamB> wait
14:16:52 <SamB> arg.
14:20:18 <SamB> oh lovely
14:21:07 <fax> hi
14:21:23 <SamB> hello
14:21:41 <nominolo> SamB: i think these lines could be a nice plot for a comic story :)
14:21:52 <SamB> nominolo: heh
14:22:03 <SamB> the compiler is giving me nonsensical error messages
14:22:16 <SamB> @quote to the context of
14:22:17 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
14:22:26 <SamB> @quote to\ the\ context\ of
14:22:26 <lambdabot> No quotes for this person. My pet ferret can type better than you!
14:22:29 <SamB> hmm.
14:23:35 <hpaste>  SamB pasted "program giving nonsensical type error in GHC HEAD" at http://hpaste.org/897
14:24:17 <fax> wooohoo
14:24:24 <fax> finally got GCC and all that crap don
14:24:54 <fax> now I can use ghc again :D
14:25:12 <hpaste>  SamB annotated "program giving nonsensical type error in GHC HEAD" with "nonsensical error" at http://hpaste.org/897#a1
14:25:49 <SamB> arg.
14:25:53 <SamB> my program won't fit...
14:28:22 <SamB> http://naesten.dyndns.org:8080/repos/rmlrun has all of the code...
14:28:29 <lambdabot> Title: Directory listing for /repos/rmlrun/
14:34:06 <hpaste>  titus pasted "transpose as a fold/unfold?" at http://hpaste.org/898
14:35:10 <Cale> glguy: yeah?
14:35:52 <Cale> Er, dinner is here, I'll be back
14:38:57 <SamB> oh, I saw yet another type error and thought it was a bad thing.
14:39:30 <SamB> but guess what? it was just GHCi's way of saying "you've got yourself an expression of polymorphic type! I can't print that!"
14:52:05 <stepcut> anyone seen a quoted-printable encoder in Haskell anywhere ?
14:56:28 <Igloo> I have one in my MIME stuff I think
14:56:39 <stepcut> Igloo: where at ?
14:57:17 <Igloo> Hmm, doesn't seem to be in hackage, but I don't think there's a good reason for that; hang on a tick
14:58:09 <Igloo> stepcut: mime-string in hackage
14:58:17 <stepcut> Igloo: spiffy!
14:58:56 <stepcut> http://urchin.earth.li/~ian/cabal/mime-string/ -> 404 :(
14:59:29 <Igloo> All that would be there is a link to download it, and it's in hackage anyway  :-)
14:59:52 <stepcut> yeah, I just saw the download link, that worked.
15:01:02 <hpaste>  titus annotated "transpose as a fold/unfold?" with "transpose as a fold - bit closer?" at http://hpaste.org/898#a1
15:01:36 <stepcut> Igloo: how much infrastructure does mime-string have for generating mime emails ?
15:02:24 <thedward> is there a library function that will take a string like "192.168.42.23" and give me a HostAddress (as opposed to IO HostAddress); Maybe HostAddress would be even better, actually.
15:02:49 <Igloo> stepcut: Not much - I was writing it while trying to parse e-mails mostly, although I was also generating some
15:03:15 <Igloo> thedward: If you look it up twice you don't necessarily get the same answer, so no
15:03:47 <Igloo> thedward: You could safely unsafePerformIO it if you don't care about that
15:03:55 <thedward> Igloo: um. I hope not.
15:04:00 <stepcut> Igloo: ok. I am trying to put together a nice API for composing emails, but I don't want to duplicate the effort if someone else already did it :)
15:04:03 <bos> thedward: igloo is right.
15:04:28 <thedward> isn't a HostAddress just a Word32 that represents an IP address?
15:04:57 <procyon_> You guys might enjoy this: http://www.youtube.com/watch?v=Fow7iUaKrq4  "kill dash nine" by monzy.  Explicit Lyrics.
15:05:08 <quicksilver> thedward: i think it name-lookups it
15:05:09 <thedward> there should be a one to one mapping between a word32 representation of an IP Address and an integer representation ...
15:05:13 <Igloo> thedward: Oh, sorry, I read it as hostname
15:05:23 <bos> thedward: oh, you want inet_aton then.
15:05:31 <thedward> bos: exactly
15:06:01 <thedward> This isn't something that would be hard to write, but I'd rather not if I don't have to.
15:06:11 <bos> see Network.Socket
15:06:54 <thedward> the closest Network.Socket afaict is inet_addr which I assume actually does host lookup
15:07:01 <fax> urk
15:07:06 <fax> whats the name of that snake eating itself?
15:07:11 <thedward> orobus?
15:07:13 <quicksilver> ourobours
15:07:15 <fax> ah thanks:D
15:07:16 <quicksilver> ouroborus
15:07:23 <thedward> ouroborouous
15:07:39 <bos> inet_addr expects dotted-quad input.
15:07:47 <quicksilver> "Or rob, or Ross" said in a liverpudlian accent, being the punchline to a red dwarf episode
15:07:59 <thedward> then why is does return an IO type?
15:08:21 <bos> because almost everything in the network library does.
15:08:52 <bos> by the way, inet_addr is broken. it will throw an error if given 255.255.255.255
15:08:59 <bos> which is incorrect behaviour.
15:14:59 <sorear> hello.
15:15:01 <sorear> @users
15:15:02 <lambdabot> Maximum users seen in #haskell: 339, currently: 318 (93.8%), active: 33 (10.4%)
15:15:04 <sorear> @uptime
15:15:04 <lambdabot> uptime: 5d 18h 25m 18s, longest uptime: 5d 18h 25m 18s
15:15:21 <bos> lambdabot will be turning grey soon.
15:18:07 <wkh|honkshu> jesus fucking christ
15:18:30 <wkh> one of adobe's stupid example Flex apps brought my browser to a halt and it used up 90 megs of RAM
15:18:36 <wkh> for a retarded, boring, useless CRUD interface
15:18:42 <stepcut> wkh: yay!
15:18:54 <wkh> why do web-based applications need to be "rich"?
15:18:58 <wkh> that was not a rich experience
15:19:16 <quicksilver> If I want to get my finalisers called in the case of ctrl-C, I need to handle SIGINT and turn it into an exception?
15:19:25 <sorear> wkh: do you think I'm less crazy now?
15:19:45 <wkh> sorear: I don't understand what you're referring to
15:20:15 <sorear> I don't use javascript, flash, any graphical environment ... just text-mode and links
15:21:41 <wkh> javascript/dom/ajax, used appropriately, can make a web application more efficient and usable. response time matters. using that for gee-whiz sake is a very bad idea, though
15:21:42 <roconnor_> @seen dcoutts
15:21:43 <lambdabot> dcoutts is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I last heard dcoutts speak 9h 36m 5s ago.
15:21:49 <dcoutts> @arr
15:21:49 <lambdabot> Swab the deck!
15:21:55 <dcoutts> hia roconnor
15:22:07 <roconnor> dcoutts: hey
15:22:33 <roconnor> according to http://www.haskell.org/http/ you suggested removing the crypto dependency from the package
15:22:34 <lambdabot> Title: Haskell HTTP package
15:22:39 <quicksilver> @hoogle withSig
15:22:39 <lambdabot> No matches found
15:22:45 <fax> is there an equivalent to letrec :S
15:22:50 <roconnor> I'm currious as to why you would suggest that?
15:22:52 <bos> fax: let
15:22:52 <sorear> augustss: this was the best ref I could find for the <v,G> machine; do I need to look at anything else: http://citeseer.ist.psu.edu/augustsson89parallel.html
15:22:54 <lambdabot> Title: Parallel Graph Reduction with the -machine (ResearchIndex)
15:22:59 <fax> doh!
15:23:01 <fax> ok thanks
15:23:29 <bos> letrec is only for broken languages :-)
15:23:54 <nominolo> or documentation
15:24:02 * roconnor wonders if mdo is only for broken languages too
15:24:08 <nominolo> (in these languages that us)
15:24:11 <nominolo> *is
15:24:23 <nominolo> roconnor: why?
15:24:29 <roconnor> dcoutts: according to http://www.haskell.org/http/ you suggested removing the crypto dependency from the package
15:24:30 <lambdabot> Title: Haskell HTTP package
15:24:42 <quicksilver> roconnor: people are more used to recursive let bindings than general recursive monad bindings, that's all, I think :)
15:24:51 <nominolo> roconnor: not every monad necessarily has a FP
15:24:53 <roconnor> quicksilver: fair enough
15:25:01 <sorear> roconnor: compatibility
15:25:03 <roconnor> nominolo: good point
15:25:19 <quicksilver> roconnor: recursive monad bindings allow you to 'appear to' subvert the evaluation order by using lazy evaluation
15:25:27 <dcoutts> roconnor, right, because that has it's own massive chain of dependencies, with something unpackagable at the bottom of the dep chain.
15:25:30 <sorear> > do { x <- return 2; x <- return 3; return x } :: Maybe Int
15:25:32 <lambdabot>  Just 3
15:25:38 <quicksilver> (so does fix, w.r.t to the express evaluation semantics, but people are used to that)
15:25:38 <sorear> > mdo { x <- return 2; x <- return 3; return x } :: Maybe Int
15:25:39 <lambdabot>  Parse error
15:25:43 <sorear> @tyj mdo { x <- return 2; x <- return 3; return x } :: Maybe Int
15:25:46 <lambdabot>     Conflicting definitions for `x'
15:25:46 <lambdabot>     In a recursive mdo-expression
15:26:01 * Saizan wonders how many different partial implementation of MIME parsers are floating in the haskell community
15:26:28 <quicksilver> nominolo: do any of the standard haskell monads fail to have fix?
15:26:31 <SamB> Saizan: hmm. perhaps less than in some other communities?
15:26:49 <roconnor> dcoutts, cyrpto has a bunch of dependencies?
15:26:56 <nominolo> quicksilver: no, not the standard ones, afaik
15:27:06 <sorear> @instances MonadFix
15:27:08 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:27:18 <sorear> Cont is missing
15:27:25 <quicksilver> ah
15:27:26 <nominolo> quicksilver: although they do have some different properties if you look closer
15:27:27 <roconnor> quicksilver: monads don't really have anything to do with evalutation order
15:27:27 <sorear> @instances-importing Control.Monad.Cont MonadFix
15:27:29 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:27:40 <sorear> not a scope thing
15:27:57 <sorear> @instances-importing Control.Monad.Cont Monad
15:27:57 <quicksilver> roconnor: they have something to with side-effect order, in several cases
15:27:58 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:27:59 <Saizan> SamB: maybe, i know of the ones in Network.HTTP Network.CGI cgi-compat HAppS haskell-mime string-mime
15:28:14 <quicksilver> roconnor: and some of those side effects force evaluation (and some don't)
15:28:32 <dcoutts> roconnor, yep, it used to at least.
15:28:49 <dcoutts> roconnor, the situation might be better now, feel free to take a look
15:28:50 <quicksilver> sorear: I think it's too late at night for me to get my head around whether ContT should have a fixed point :) ContT hurts my head at the best of times.
15:29:14 <roconnor> dcoutts: Build-Depends:   base, mtl, QuickCheck, HUnit, NewBinary, fps
15:29:22 <roconnor> hmmm
15:30:23 <chessguy> hi haskellites
15:30:26 <roconnor> @type mfix
15:30:29 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
15:30:55 <roconnor> @djinn (a -> ((a -> r) -> r)) -> ((a -> r) -> r)
15:30:56 <lambdabot> -- f cannot be realized.
15:31:33 <roconnor> well, djinn doesn't make fixpoints in any case I suppose
15:31:37 <quicksilver> @djinn (a -> (r->a)) -> (r->a)
15:31:37 <lambdabot> -- f cannot be realized.
15:31:40 <roconnor> @djinn (a -> a) -> a
15:31:40 <lambdabot> -- f cannot be realized.
15:31:48 * quicksilver nods
15:31:52 <quicksilver> not first-order
15:32:09 <Saizan> it doesn't even work with lists
15:32:50 <quicksilver> it probably works with the church encoding of lists
15:32:58 <quicksilver> which I can't be bothered to work out now :)
15:33:02 <Saizan> ah, there's also a Data.MIME.Types in MissingH!
15:33:14 <stepcut> Saizan: :p
15:33:27 <SamB> oh boy :-(.
15:33:28 <Saizan> mmh i think there's a such list on hpaste
15:33:46 <SamB> my asTypeOf doesn't seem to work right !?!
15:33:52 <Uncountable> can you think of an easy way to generate the strings a,b,aa,ab,ba,bb,aaa,aab,..?
15:34:01 <SamB> the arguments don't seem to both be the same type
15:34:08 <sorear> Uncountable: yes
15:34:16 <stepcut> Saizan: haskell-mime is mine ;)
15:34:23 <fax> Uncountable: thats just binary replacing 1 and 0 with a and b?
15:34:32 <sorear> > concatMap (flip replicateM "ab") [1..]
15:34:34 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
15:34:39 <sorear> Uncountable: ?
15:34:46 <Saizan> stepcut: :O
15:34:50 <fax> :O
15:34:50 <SamB> fax: do you normally see "00" in a sequence of binary-represented numbers?
15:35:01 <sorear> > flip replicateM "ab" =<< [1..]
15:35:03 <Uncountable> sorear, thanks :)
15:35:03 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
15:35:29 <Cale> However, it's definitely countable :)
15:35:31 <quicksilver> > concatMap (\n -> sequence (replicate n "ab")) [1..]
15:35:39 <quicksilver> bah, sorear wins
15:35:40 <Saizan> stepcut: i found it searching a way to parse multipart/form-data, but your lib seems more focused on emails, right?
15:35:41 <Uncountable> :)
15:35:43 <stepcut> Saizan: Eventually I would like it to be able to be able to Compose, parse, and transform messages
15:36:24 <stepcut> Saizan: mostly emails/nntp/etc for now
15:37:39 <SamB> what the heck?
15:37:41 <stepcut> Saizan: though, I supose it is valid to receive email with the type multipart/form-data....
15:38:01 * SamB wonders why scoped type variables are on -- he didn't ask for them!
15:38:27 <Saizan> -fglasgow-exts?
15:38:38 <SamB> yes
15:38:44 <SamB> they ought not to be in there
15:38:53 <SamB> because they can mess up code that otherwise works
15:39:13 <Saizan> ah, like?
15:39:18 <SamB> at least, I think they could
15:39:40 <SamB> well, I mean, if you had code that depended on type variables not being scoped
15:39:53 <Saizan> stepcut: really?
15:40:29 <stepcut> Saizan: sure, why not ?
15:41:49 <stepcut> Saizan: according to RF2046: Other "multipart" subtypes are expected in the future. MIME implementations must in general treat unrecognized subtypes of "multipart" as being equivalent to "multipart/mixed".
15:42:47 <quicksilver> installHandler sigINT (Catch (throwTo mainthread (ErrorCall "sigint"))) Nothing
15:42:52 <quicksilver> is that sane?
15:43:10 <Saizan> well, the "form-data" part :) and because each segment must have a name field, and i don't see how well it map to the body of an email, but i must admit i don't know MIME so well
15:43:12 <sorear> SamB: don't you just love the way ghc lumps all the extensions together under -fglasgow-exts?
15:43:26 <sjanssen> sorear: it's probably a good thing
15:43:45 <sjanssen> otherwise we'd all have RSI from typing 10+ flags for every single program
15:43:57 <quicksilver> sjanssen: that signal handler look right? to make sure sigints don't bypass my finalisers?
15:44:01 <sorear> SamB: when I finally get into hacking ghc, my #1 priority will be creating separate options for everything.  -fglasgow-exts will stay for convienience ...
15:44:06 <sorear> sjanssen: just use cabal :)
15:44:39 <sjanssen> quicksilver: I've never worked with signal handlers in Haskell
15:44:39 <chessguy> man, going back and reading about OO after learning haskell for 6 months is weird
15:45:22 <Saizan> ?where FilePath
15:45:22 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
15:45:29 <sorear> sjanssen: we're already going down the separate-flags path for new extentions - witness -fbang-patterns, -fscoped-type-variables, -farrows (all enabled by -fglasgow-exts)
15:45:42 <MarcWebe1> Do you know when mkElement_S and mkElement_T is used in wash? which meaning has STATIC here?
15:45:51 <sjanssen> sorear: yes, separate flags are definitely a good thing
15:45:53 <sorear> @where wash
15:45:53 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
15:46:25 <sjanssen> sorear: I also like the LANGUAGE pragma
15:46:32 <sorear> agreed.
15:47:03 <Saizan> LANGUAGE?
15:47:31 <sjanssen> Saizan: a pragma to declare which language extensions your program uses
15:47:34 <nornagon> {-# LANGUAGE "C++" #-} cout << "HAY GUYZ" << endl;
15:48:05 <sjanssen> {-# LANGAGE MultiParameterTypeClasses #-} for example
15:48:13 <sjanssen> s/LANGAGE/LANGUAGE
15:48:23 <sorear> {-# LUGGAGE ...
15:48:30 <fax> :D
15:48:36 <fax> I manage to get parsec to work interactivly
15:51:26 <sebell> fax: Err, you mean like they show in the documentation? ;)
15:51:41 <fax> no!
15:51:51 <fax> which documentation =_=
15:52:05 <Saizan> ?where parsec
15:52:05 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
15:52:20 <fax> no not like that
15:53:05 <Saizan> http://www.cs.uu.nl/~daan/download/parsec/parsec.html -- btw, someone should move the comments on the functions from here to the standard haddock doc
15:53:14 <Saizan> ops C-b
15:54:30 <fax> I can do "1+ 2 3 *"
15:54:32 <fax> "4"
15:54:39 <fax> and it gives 3 and then 12
15:54:53 <fax> it took a while to work out :
15:56:26 <Saizan> don't you build an AST and then evaluate it?
15:56:42 <fax> no
15:57:38 <fax> hmpf
15:57:41 <fax> I will have to later though
15:59:19 <nattfodd> can anyone tell me what mtl is, please?
15:59:29 <fax> material file for an OBJ model?
15:59:36 <dmhouse> nattfodd: the Monad Template Library.
15:59:53 <dmhouse> nattfodd: it's one package from the standard library that defines most of the standard monads we know and love.
16:00:05 <nattfodd> so it's supposed to be provided with ghc?
16:00:28 <sorear> nattfodd: only if you aren't using 6.6
16:00:44 <nattfodd> *sigh*
16:00:46 <sjanssen> nattfodd: emerge dev-haskell/mtl
16:00:53 <sorear> nattfodd: on 6.6 someone had the "bright" idea of putting it into a separate package
16:01:10 <nattfodd> sjanssen: in the overlay, then?
16:01:11 <dmhouse> nattfodd: what's the problem?
16:01:30 <sorear> nattfodd: they really should have put a Depends: on the standard libs :(
16:01:35 <nattfodd> dmhouse: that I just emerged 6.6 and that cabal complains about not finding it
16:01:39 <sjanssen> nattfodd: I know that it's in the overlay.  It might have been migrated to the main one with ghc 6.6
16:01:58 <nattfodd> sjanssen: ok then no, they haven't migrated it yet
16:02:00 <Saizan> gah, is like putting shipping arrays in a separate library for gcc
16:02:14 <Saizan> s/putting//
16:02:19 <sjanssen> nattfodd: which cabal package are you installing?
16:02:28 <dmhouse> nattfodd: oh, that's definitely wrong, the two should ship together, blame Gentoo :)
16:02:40 <nattfodd> sjanssen: agda2
16:03:02 <nattfodd> dmhouse: ghc-6.6 is still not entirely in, and hard masked
16:03:11 <nattfodd> though you can still blame gentoo if you feel like it :)
16:03:17 <sjanssen> nattfodd: agda2 isn't a gentoo package, is it?
16:03:22 * dmhouse knows nothing about Gentoo's packaging system.
16:03:26 <sjanssen> dmhouse: no, I'm convinced that Gentoo does it the right way
16:03:30 <nattfodd> sjanssen: not until I add it :)
16:03:38 * dmhouse knows nothing about Debian's packaging system either, all he knows is how to use Adept.
16:04:09 <nattfodd> there is an old snapshot of agda in portage, I should update it with 1.0.2 and eventually 2.0 when it gets somewhat finished
16:04:10 <sjanssen> really, any OS with real package management should aim for modular packages
16:06:17 <SamB> sorear: I think only things that can't break your code should be in -fglasgow-exts
16:08:50 <procyon_> ?src flip
16:08:51 <lambdabot> flip f x y = f y x
16:09:16 <nornagon> @. pl src flip
16:09:16 <lambdabot> (line 1, column 1):
16:09:17 <lambdabot> unexpected end of input
16:09:17 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
16:09:20 <nornagon> aw.
16:09:32 <nornagon> @pl (\f x y -> f y x)
16:09:32 <lambdabot> flip
16:09:37 <nornagon> cute
16:18:49 <dons> moin
16:18:58 <araujo> hi dons !
16:20:26 <sorear> hello!
16:20:48 * sorear is writing a Haskell typechecker
16:21:36 <stepcut> sorear: I presume you have read typing haskell in haskell ?
16:22:45 <sorear> no :(
16:22:52 <sorear> @goo "typing haskell in haskell"
16:22:55 <lambdabot> http://citeseer.ist.psu.edu/424440.html
16:22:55 <lambdabot> Title: Typing Haskell in Haskell - Jones (ResearchIndex)
16:23:12 <sorear> blech, typeset
16:23:34 <dancor> > map (zipWith (+)) [[10]] [[4]]
16:23:35 <lambdabot>  Couldn't match expected type `[[t1]] -> t'
16:23:39 <stepcut> sorear: :p
16:23:48 <dancor> zip for 2d lists is blowing my mind
16:24:06 <dancor> i could just 1d-ify them
16:24:08 <araujo> hola sorear !
16:24:16 <dancor> but that seems like giving up
16:25:22 <sorear> dancor: do you want an answer?
16:25:35 <dancor> a hint?
16:25:51 <sorear> the outer map needs to receive two lists
16:26:38 * sorear afk: read thih
16:26:49 <abz> ?doc Network.CGI
16:26:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-CGI.html
16:27:08 <Botje> > zipWith (zipWith (+)) [[10,9]] [[4,2]]
16:27:09 <lambdabot>  [[14,11]]
16:27:13 <Botje> :)
16:27:33 <dancor> ah.
16:30:37 <Botje> @quote monkey
16:30:38 <lambdabot> bfulgham says: I now have trained-monkey-level skills in Haskell.  I can write really bad shootout code (that the real people rewrite correctly), and build stuff like darcs.
16:31:39 <SamB> I didn't think trained monkeys ever got past "bananas, lenses, and barbed wire"
16:32:02 <Botje> mm, monkey.
16:32:27 <SamB> hmm.
16:32:41 <SamB> I think something may be wrong with the GHC simplifier.
16:32:47 <roconnor> I have a string of the form "foo"++data++"bar", and i would like to get data out of it.
16:32:49 <SamB> in HEAD
16:32:57 <roconnor> what is the easiest way of doing that
16:33:05 <roconnor> while still failing of "foo" and "bar" are not there
16:33:13 <roconnor> s/of/if/
16:33:19 <SamB> regex ?
16:33:25 <procyon_> roconnor: parsec?
16:33:43 <roconnor> I don't know how to use either
16:33:49 <roconnor> are they easy to use?
16:33:53 <sorear> roconnor: case myList of ('f':'o':'o':xs) -> case reverse xs of ('r':'a':'b':rxs) -> reverse xs
16:33:54 <SamB> procyon_: that workse great if data is easy to parse
16:34:03 <SamB> well, sorear's works
16:34:09 <SamB> but it is ugly ugly ugly
16:34:14 <roconnor> sorear: that is what I was thinking, but it is a little clumsy
16:34:33 <sorear> @ty Text.ParserCombinators.Parsec.parse
16:34:36 <lambdabot> forall tok a. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
16:35:04 <roconnor> Can I figure out how to use parsec in 60 seconds?
16:35:16 <sorear> so you want parse (string "foo" <* many char *> string "bar") "" myString
16:35:36 <sorear> assuming they thought to add an Applicative instance
16:35:53 <sorear> ok, thih is very different from my algo ...
16:35:56 <roconnor> sorear: yes, but I do know the number of characters in data if that helps
16:35:56 <procyon_> SamB: You can do it without parsing data, similar to TokenParser.perens
16:36:09 * sorear goes back to reading it
16:36:12 <roconnor> sorear: oh wait, is that the code?
16:36:33 <sorear> yeah, that was the (untested) parsec code
16:36:52 <sorear> *> and <* are applicative combinators
16:36:56 <roconnor> damn it, haskell pseudo code is indistinguishable from actual code
16:37:01 <stepcut> sorear: there is also hatchet, I think it uses a somewhat different algorithm (and may not have a nifty paper to go with it)
16:37:38 <roconnor> applicative combinators?
16:38:10 <jcreigh_> @remember roconnor damn it, haskell pseudo code is indistinguishable from actual code
16:38:10 <lambdabot> Done.
16:38:14 <SamB> what od <* and *> do?
16:38:19 <SamB> @hoogle *>
16:38:19 <lambdabot> No matches found
16:38:23 <SamB> @hoogle (*>)
16:38:24 <lambdabot> Did you mean: (*>)
16:38:25 <lambdabot> Prelude.undefined :: a
16:38:25 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
16:38:32 <SamB> yes i did mean that!
16:38:48 <SamB> @tell ndm yes, I did mean (*>)!
16:38:49 <lambdabot> Consider it noted.
16:39:06 <roconnor> <interactive>:1:20: Not in scope: `<*'
16:39:08 <roconnor> :(
16:39:24 <mauke> string "foo" >> many char << string "bar"
16:39:26 <sorear> :m + Control.Applicative
16:39:31 <sorear> mauke: nice try
16:39:33 <mauke> except that doesn't work without backtracking
16:39:38 <sorear> mauke: << doesn't exist
16:39:48 <mauke> it does here :-)
16:39:58 <mauke> a << b = do { x <- a; b; return x }
16:40:03 <sorear> what? parser combinators without backtracking?
16:40:09 <sorear> mauke: << = *>
16:40:17 <fax> woah..
16:40:18 <roconnor> Could not find module `Control.Applicative':
16:40:18 <roconnor>   it is not a module in the current program, or in any known package.
16:40:23 <fax> I could make a lot of use of <<
16:40:25 <fax> is that Parsec?
16:40:25 <sorear> mauke: much simpler: << = liftM2 const
16:40:41 <sorear> roconnor: oh well.  my 6.6 specific tricks must go.
16:40:51 <mauke> ah, right
16:41:00 <mauke> fax: no, my own invention
16:41:05 <fax> oh right
16:41:06 <roconnor> is *> really >> ?
16:41:10 <fax> hm I guess it would work
16:41:21 <roconnor> or << or whatever?
16:42:48 <dmwit> ?src (>>)
16:42:49 <lambdabot> m >> k      = m >>= \_ -> k
16:43:22 <dmwit> :t liftM2 const
16:43:25 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
16:43:58 * roconnor thinks his 60 seconds for parsec are almost up
16:44:19 <stepcut> sorear: isn't 'many char' eager, meaning 'string "bar"' won't be evaluated until 'many char' fails ?
16:44:20 <dmwit> Okay, so << isn't just flip (>>)...
16:44:33 <fax> roconnor: what?
16:45:23 <roconnor> I figured I would give 60 to try to figureout how to use parsec to solve this parsing problem
16:45:33 <roconnor> s/60/60 s/
16:46:15 <dmwit> SamB: (*>) may not be in Hoogle's list of functions.  I tried hoogling (./) the other day and it had the same symptoms...
16:46:52 <stepcut> roconnor: I believe using parsec would be a bit tricky, because it requires lookAhead, to see if the remaining of the string you are parsing starts with "bar"
16:47:10 <roconnor> stepcut: ah, fair enough
16:47:23 <roconnor> and adhoc solution using splitAt should be adequate for me
16:47:58 <stepcut> you can do it with parsec, but the solution is non-obvious if you haven't used parsec before
16:48:39 <stepcut> roconnor: put a PEG-style parser might do it nicely...
16:48:44 <stepcut> s/put/but/
16:49:00 <dmwit> stepcut: Not having used Parsec much, can you parse part of the string, reverse the remainder, then parse that?
16:49:27 <fantasma> @docs
16:49:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:50:04 <dmwit> Like (string "foo" >>= string "bar" . reverse) or something.
16:50:09 <fantasma> where can I get the following library: Data.Graph.Inductive.Query.SP
16:50:40 <stepcut> dmwit: i believe it would require a fair bit of hackery
16:51:33 <roconnor> PEG?
16:51:40 <stepcut> http://en.wikipedia.org/wiki/Parsing_expression_grammar
16:51:55 <roconnor> ah, this goes back to the regexp suggestion
16:52:36 <stepcut> i believe there are a few packrat parser implemented in haskell, but they are not yet in wide-spread usage
16:53:24 <stepcut> http://repetae.net/computer/frisby/
16:54:19 <roconnor> parse l = let ("<TD ALIGN=\"LEFT\">",x) = splitAt (length prefix) l
16:54:19 <roconnor>               (x',"</TD>\r") = splitAt 5 x
16:54:19 <roconnor>            in x'
16:57:05 <dmwit> How about something like (string "foo" >> sequence (repeat 5 char) >>= string "bar")?
16:57:30 <dmwit> Never mind, I'll stop trying to imagine how Parsec works, and just play with it a little first. =P
16:58:06 <stepcut> dmwit: that would parse 5 chars that appaer between "foo" and "bar" ?
16:58:07 <chessguy> @type \l -> let ("<TD ALIGN=\"\">",x) = splitAt (length prefix) l; (x',"</TD>\r") = splitAt 5 x in x'
16:58:09 <lambdabot> Not in scope: `prefix'
16:58:21 <chessguy> @type \l -> let ("<TD ALIGN=\"\">",x) = splitAt (length ?prefix) l; (x',"</TD>\r") = splitAt 5 x in x'
16:58:24 <lambdabot> (?prefix::[a]) => [Char] -> [Char]
16:59:07 <stepcut> roconnor: that is some unusual code you have there...
16:59:16 <dmwit> stepcut: I don't know, I have no idea how Parsec works.
16:59:17 <chessguy> i don't even get how that would be evaluated
16:59:19 <dmwit> That was the intent, though.
16:59:21 <stepcut> > let "hi" = "hello" in putStrLn "hi"
16:59:23 <lambdabot>  <IO ()>
16:59:31 <stepcut> > let "hi" = "hello" in "hi"
16:59:32 <lambdabot>  "hi"
16:59:36 <fax> lol
17:00:03 <chessguy> ?hoogle splitAt
17:00:04 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
17:00:04 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
17:00:04 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
17:00:09 <dmwit> It'll be a pattern match failure if a string of the wrong form is sent in, right?
17:01:56 <stepcut> > let str = "fooapplebar" in parse (do { string "foo" ; s <- count 5 anyChar ;string "bar" ; return s }) str str
17:02:10 <lambdabot>   Not in scope: `string'
17:02:33 <stepcut> hrm, apparently lambdabot does not include Parsec ?
17:03:24 <nominolo> i think there's a hoogle plugin for emacs
17:03:37 <nominolo> then you can use your local ghci/hugs
17:03:55 <nominolo> er
17:04:15 <stepcut> dmwit: parse returns 'Either ParseError a', so if pass in an illegal string, it tells you where the parsing failed, and what it was expecting
17:04:19 <nominolo> admittedly, these things are sort of unrelated ..
17:04:27 <roconnor> stepcut: I know it is 5 chars :)
17:04:39 <stepcut> roconnor: ah
17:04:48 <stepcut> roconnor: I forgot you said that ;)
17:05:00 <roconnor> stepcut: maybe  parsec could work for me afterall
17:05:55 <fax> I think you can make parsec do anything
17:06:33 <stepcut> fax: possibly, but for some grammars, it will have very poor performance
17:07:36 <fax> performance ://
17:07:37 <fax> who cares
17:08:06 <roconnor> stepcut: oh right, prefix = "<TD ALIGN=\"LEFT\">"
17:08:26 <roconnor> stepcut: but I need to rewrite the same string in the let expression for the irrefutable pattern match :(
17:10:28 <stepcut> do { l <- string "foo" ; s <- count 5 anyChar ; r <- string "bar" ; return (l,s,r) }
17:10:29 <stepcut>  ?
17:13:06 <stepcut> :m + Text.Regex.Posix
17:13:08 <stepcut> "fooapplebar" =~ "(foo)(.{5})(bar)" :: (String, String, String, [String])
17:13:41 <stepcut> parsec is probably overkill ...
17:14:39 <mauke> but you can never have too much overkill
17:15:23 <stepcut> overoverkill ?
17:16:57 <roconnor> stepcut: I like this parsec solution
17:17:20 <roconnor>   prs l = let (Right s) = parse (do l <- string prefix
17:17:20 <roconnor>                                     s <- count 5 anyChar
17:17:20 <roconnor>                                     r <- string postfix
17:17:20 <roconnor>                                     return s) "" l
17:17:56 <fax> dont you hav to have ; ?
17:18:01 <fax> for each line in the do
17:18:09 <stepcut> you can get rid of the 'l <- ' and 'r <- ' portions since you don't actually use r or l
17:18:28 <mauke> I bet parsec has a function for that pattern
17:18:40 <stepcut> fax: no, not if you use the whitespace layout rules
17:18:45 <mauke> (bracket?)
17:18:46 <fax> hmm
17:19:18 <stepcut> fax: see how all the lines are nicely indented, making it obvious what is going on ? The compiler gets it too
17:19:30 <roconnor> stepcut: good point
17:19:47 <fax> oh right
17:19:56 <fax> I had ;'s and lined it up
17:22:23 <stepcut> roconnor: I would probably do it more like this:
17:22:24 <stepcut> prs prefix postfix l
17:22:24 <stepcut>     = either (error . show) id $  parse (do l <- string prefix
17:22:24 <stepcut>                                             s <- count 5 anyChar
17:22:24 <stepcut>                                             r <- string postfix
17:22:24 <stepcut>                                             return s) l l
17:23:02 <stepcut> for 'better' error reporting
17:23:42 <dibblego> in attempting to find a sensible description of C as a low-level language, the best I could find is this: "Observing that such languages are not very high level compared with e.g. Prolog, YACC, Lex, ML, Haskell, etc, some people started calling the older high level languages "low level languages", or qualifying them as "higher level languages", etc. This is largely revisionism by SmugLanguageWeenies?, and such terminology is cer
17:23:42 <dibblego> tainly not universally accepted..." http://c2.com/cgi/wiki?HighLevelLanguage -- can anyone provide any other pointers?
17:23:44 <lambdabot> Title: High Level Language
17:25:12 <jcreigh_> note to self: ghc requires -ffi when using the FFI and gives a confusing parse error when you omit it.
17:25:33 <stepcut> dibblego: C is often described, with a mixture of fondness and disdain varying according to the speaker, as "a language that combines all the elegance and power of assembly language with all the readability and maintainability of assembly language." (MIT Jargon Dictionary)
17:26:06 <dibblego> stepcut, that one looks a little better :)
17:27:28 <stepcut> Any sufficiently complicated C or Fortran program contains an ad hoc informally-specified bug-ridden slow implementation of half of Common Lisp. (Philip Greenspun)
17:28:06 <stepcut> The belief is still widespread in the commputing community that C and its derivatives are programming languages -- languages intended for people to write programs in. This is a regrettable misunderstanding. (Bertrand Meyer)
17:28:22 <dibblego> nice one
17:28:39 <allbery_b> C is clearly a C-level language
17:29:22 <stepcut> You can't prove anything about a program written in C or FORTRAN. It's really just Peek and Poke with some syntactic sugar. (Bill Joy)
17:29:54 <dibblego> you're a champion -- I've forgotten half of those
17:29:57 <fax> you can usually prove it doesnt work by using it :D
17:30:50 <stepcut> dibblego: they all came from this page, btw -> http://www.sysprog.net/quotec.html
17:30:51 <ttmrichter> Bertrand Meyer has many stronger things to say about C when you corner him in private....
17:30:51 <lambdabot> Title: Quotes about C and C++
17:31:08 <dibblego> stepcut, nice thanks
17:34:22 <ttmrichter> Why the <expletive deleted!> would sysprog.net be behind the Great Firewall?!?!
17:34:42 <fantasma> :t Real
17:34:44 <lambdabot> Not in scope: data constructor `Real'
17:34:51 <fantasma> :k Real
17:34:51 <allbery_b> Real is a class
17:34:53 <lambdabot> Class `Real' used as a type
17:35:07 <allbery_b> @instances Real
17:35:08 <fantasma> @index Real
17:35:08 <lambdabot> Double, Float, Int, Integer
17:35:08 <lambdabot> Prelude
17:35:18 <fantasma> @src Real
17:35:19 <lambdabot> class  (Num a, Ord a) => Real a  where
17:35:19 <lambdabot>     toRational      ::  a -> Rational
17:35:48 <fantasma> so what's a Real x?
17:35:58 <stepcut> ttmrichter: maybe because it talks smack about 'the Great Firewall' admininstrators favorite language ?
17:36:27 <mauke> fantasma: a rationalizable type
17:36:35 <ttmrichter> stepcut: Nah.  It would have to have porn or something bad about communism, Tibet or Taiwan for that.
17:36:58 <dibblego> ttmrichter, how did you determine that?
17:37:19 <fantasma> so Double, Float, Int, Integer are all instances of the class Real?
17:37:36 <ttmrichter> dibblego: by trying to get to sysprog.net via that earlier URL and finding out I had to activate my SSH proxy.
17:38:41 <stepcut> ttmrichter: from sysprog.net --> Although about three million computers get sold every year in China, people don't pay for the software. Someday they will, though. And as long as they're going to steal it, we want them to steal ours. They'll get sort of addicted, and then we'll somehow figure out how to collect sometime in the next decade. (Bill Gates)
17:38:56 <fantasma> :t asTypeOf
17:38:58 <lambdabot> forall a. a -> a -> a
17:39:02 * stepcut goes out for a walk
17:39:16 <ttmrichter> stepcut: Billy Boy is going to be paying for that comment.  It is a Bad Idea to reinvoke memories of the Opium Wars here....
17:39:24 <fantasma> > 1 `asTypeOf` Int
17:39:24 <lambdabot>   Not in scope: data constructor `Int'
17:40:48 <ttmrichter> "Eiffel borrows quite heavily from some earlier programming languages and I am sure that if we had found a good programming construct in C we would have used it as well. (Bertrand Meyer)"
17:48:16 <stepcut> ttmrichter: heh
17:50:11 <dons> sjanssen: i'm just going to go ahead and add XCrossing ok ? I'm almost done with it now.
17:50:18 <dons> (and i need it for firefox)
17:53:02 <dibblego> dons, is there a GHC 6.6 cabal file for lambdabot?
17:53:33 <dibblego> since, the standard one from lambdabot 4.0.1 was asking for fps >= 0.7
17:54:37 <allbery_b> update
17:54:47 <allbery_b> current lambdabot expects 6.6
17:55:14 <dibblego> yeah and arrows somethinga-rather, which was giving me grief as well
17:55:14 <allbery_b> earlier ones for the past few months came with a lambdabot.cabal-6.6
18:01:09 <UUStudent> Hello all
18:03:34 <dons> dibblego: arrows et al    you just get from cabal
18:03:43 <dons> sjanssen: ok. with XCrossing now firefox works
18:04:00 <dons> most of the time...
18:04:02 <dons> :)
18:04:27 <stepcut> is there a function like this already?
18:04:27 <stepcut> bool :: (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b
18:04:27 <stepcut> bool t f p a = if p a then t a else f a
18:04:53 <araujo> @hoogle (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b
18:04:54 <lambdabot> No matches, try a more general search
18:04:58 <mauke> @pl bool t f p a = if p a then t a else f a
18:04:59 <lambdabot> bool = flip . (ap .) . flip (liftM2 if')
18:05:05 <stepcut> araujo: tried that already
18:05:08 <araujo> @index (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b
18:05:08 <lambdabot> bzzt
18:05:14 <araujo> then there is none
18:05:21 <stepcut> :p
18:05:28 <stepcut> well, there should be ;)
18:05:43 <stepcut> @hoogle+ (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b
18:05:58 <dancor> @hoogle (a, a) -> a
18:05:59 <lambdabot> Prelude.fst :: (a, b) -> a
18:06:00 <lambdabot> Prelude.snd :: (a, b) -> b
18:06:00 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
18:06:18 <jyasskin> @hoogle (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b
18:06:19 <lambdabot> No matches, try a more general search
18:07:13 <dancor> > uncurry (++) (["a"], ["b"])
18:07:14 <lambdabot>  ["a","b"]
18:07:15 <sjanssen> dons: excellent!
18:07:23 <sjanssen> dons: what do you mean by "most of the time"?
18:08:38 <jyasskin> @pl bool p t f a = if p a then t a else f a
18:08:39 <lambdabot> bool = (ap .) . liftM2 if'
18:08:46 <dons> some logical errors while transliterating from C. I think i've fixed them now. testing...
18:08:59 <dons> (the selscreen global variable dwm uses to pass random info around urgh ...)
18:09:11 <dons> lesson: magic globals do not aid reasoning!
18:09:20 <dancor> are you guys rewriting firefox in haskell
18:09:28 <sjanssen> dancor: someday . . .
18:09:31 <jcreigh> dancor: naw, they're just writing a WM
18:10:02 <jyasskin> @type (($) .) . if'
18:10:05 <lambdabot> Not in scope: `if''
18:10:29 * dancor hopes it is like openbox which is pretty sweet
18:10:35 <jyasskin> @type (($) .) . (\p t f -> if p then t else f)
18:10:38 <sjanssen> dancor: it's a clone of dwm
18:10:38 <lambdabot> forall a. Bool -> a -> a -> a
18:11:01 <sjanssen> so even more minimal/lightweight than the *boxen
18:11:55 <sjanssen> dons: most of the code in dwm, but I just gag when I see certain parts of the code
18:12:03 <dancor> cool, no window headers
18:12:08 <sjanssen> s/code in dwm/code in dwm is nice
18:12:19 <sjanssen> nice C that is
18:12:24 <dancor> it's like magic
18:12:29 <jcreigh> sjanssen: are you thinking there will be support for spliting/tiling/whatever workspaces, or is it going to be fullscreen only?
18:13:26 <sjanssen> jcreigh: I can guarantee thunk will have dwm style splitting
18:14:20 <jcreigh> okay, cool.
18:15:04 <stepcut> sjanssen: what about compiz-style Composite effects ?
18:15:13 <stepcut> wobble windows!
18:15:34 <sjanssen> @slap stepcut
18:15:35 * lambdabot smacks stepcut about with a large trout
18:15:40 <stepcut> wobbly types + wobbly windows == ??
18:16:26 <sjanssen> stepcut: boxy types == windows shaped like boxes.  Always.
18:16:28 <sjanssen> :)
18:17:12 <stepcut> it seems like it would be a lot easier to make stupid 3D window manager effects in Haskell than C
18:20:17 <dancor> best way to rip elem with index i out of a list?
18:20:40 <fax> > [1..] !! 7
18:20:41 <lambdabot>  8
18:20:58 <fax> > let add a b = [a..] !! b in add 5 9
18:21:00 <lambdabot>  14
18:21:53 <stepcut> dancor: just be aware that !! can throw a run time error for out-of-bounds indexes
18:21:59 <stepcut> > "hello"!!10
18:22:01 <lambdabot>  Exception: Prelude.(!!): index too large
18:22:21 <dancor> > let del i l = uncurry (++) (second drop (splitAt i l)) in del 4 [1..10]
18:22:23 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
18:23:19 <jyasskin> > let del = uncurry (++) . Arrow.second tail . splitAt i in del 3 [1..]
18:23:20 <lambdabot>   Not in scope: `i'
18:23:25 <jyasskin> > let del i = uncurry (++) . Arrow.second tail . splitAt i in del 3 [1..]
18:23:26 <lambdabot>   Not in scope: `Arrow.second'
18:23:29 <jyasskin> :(
18:23:37 <jyasskin> > let del i = uncurry (++) . Control.Arrow.second tail . splitAt i in del 3 [1..]
18:23:38 <lambdabot>  [1,2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
18:23:48 <dancor> cool
18:24:12 <jyasskin> That will die too if the index is out of bounds.
18:24:41 <int-e> > let del i = uncurry (++) . second (drop 1) . splitAt i in del 10 [1..3]
18:24:43 <lambdabot>  [1,2,3]
18:25:10 <jyasskin> int-e++
18:25:24 <dolio> ?pl drop 1
18:25:24 <lambdabot> drop 1
18:25:53 <dancor> tail is shorter
18:26:02 <dancor> tail++
18:26:05 <dolio> drop won't fail, though.
18:26:09 <dancor> ooh
18:26:11 <dolio> > drop 1 []
18:26:12 <lambdabot>  []
18:26:24 <dancor> but splitAt still can
18:26:53 <int-e> dancor: no
18:26:56 <dancor> oh ok
18:27:09 <dancor> > splitAt 1 ""
18:27:10 <Pastorn> ?src Control.Arrow.second
18:27:10 <lambdabot> Source not found. My pet ferret can type better than you!
18:27:11 <lambdabot>  ("","")
18:27:31 <int-e> @type second
18:27:34 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
18:27:38 <Pastorn> ?src second
18:27:39 <lambdabot> Source not found. My pet ferret can type better than you!
18:27:47 <Pastorn> yay!
18:28:13 <dancor> you found a collision in lb's phrase generator
18:28:15 <Pastorn> @instance Arrow
18:28:15 <lambdabot> Maybe you meant: instances instances-importing
18:28:20 <int-e> ?src (->) second
18:28:20 <lambdabot> second f = id *** f
18:28:21 <Pastorn> @instances Arrow
18:28:22 <lambdabot> (->), Kleisli m
18:28:29 <int-e> ?src (->) (***)
18:28:29 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
18:28:38 <dancor> better switch to hardened lb with 512-bit phrase gen
18:29:05 <Pastorn> the "Kleisli monad"? wtf?
18:31:03 <dolio> Kleisli arrows are a -> m b for some monad m.
18:32:43 * SamB wonders why the firefox on his XP box doesn't want to auto-upgrade to 2.0
18:34:03 <dolio> That's been out a while, hasn't it?
18:34:13 <tankertux> Anyone want to help a noob with some data declarations?
18:34:26 <jcreigh> I don't think they autoupdate to 2.0 yet.
18:34:30 <sjanssen> tankertux: that's what we do here
18:34:40 <tankertux> Awesoem
18:34:58 <jcreigh> many extensions break because they haven't been upgraded to 2.0 yet.
18:35:13 <tankertux> This is for homework, so I just need some hints and/or instructions
18:35:45 <tankertux> I'm trying to translate some BNF statements into data declarations
18:36:18 <tankertux> and I'm having trouble expressing them in terms of each other
18:36:34 <tankertux> For example...
18:37:10 <tankertux> data Myop = Plus | Times
18:37:10 <tankertux> data ArithExp = Int | Variable | ArithExp Myop ArithExp
18:37:10 <tankertux> data Comp = GreaterThan
18:37:10 <tankertux> data BooleanExp = ArithExp Comp ArithExp
18:38:08 <tankertux> I get an error because there are "multiple declarations for constructor ArithExp"
18:38:19 <tankertux> particularly in the Boolean Exp Line
18:38:32 <sjanssen> I think you're confused about data declaration
18:38:33 <sebell> tankertux: You need a data constructor for BooleanExp
18:38:57 <tankertux> Confused is an understatement
18:39:01 <sebell> (well, for all of them)
18:39:24 <tankertux> sebell: I'm confused as to how they aren't data constructors
18:39:30 <sjanssen> data decl's, on the surface, seem quite similar to BNF syntax, but there are some differences
18:39:43 <tankertux> ok
18:40:02 <ClaudiusMaximus> tankertux: you can't have raw types on their own in a data case, otherwise how would you determine the type of the values?  (is the way i understand it)
18:40:03 <dancor> each constructor needs a 'name'
18:40:22 <dancor> for enums, all you need is a name
18:40:32 <dancor> data Enum = Poss1 | Poss2
18:41:01 <tankertux> Ok, so data Value = I Int | F Float is valid
18:41:08 <dancor> yes
18:41:20 <tankertux> but data Value = Int | Float is not
18:41:22 <dancor> right
18:41:26 <tankertux> ok
18:41:35 <sjanssen> well, it /is/ valid, but it doesn't mean what you think it does
18:42:03 <int-e> data Value = Int Int | Float Float is also valid
18:42:24 <tankertux> Alright, now say I have this BNF
18:42:33 <dancor> how about data Int = Int Int  :)
18:42:40 <tankertux> ArithExp ::= Int | Variable | ArithExp + ArithExp | ArithExp * ArithExp
18:42:55 <tankertux> Lol, trying to make my head explode
18:43:00 <int-e> dancor: that is valid if you hide the Int type from Prelude.
18:43:03 <sjanssen> tankertux: for each alternative in the BNF, you'll have to think up a "tag" that describes it
18:43:25 <int-e> dancor: but it's also completely useless *g*
18:43:59 <sjanssen> so you might call the first "I", so the first alternative in your data decl might be I Int
18:44:04 <tankertux> Ok, so data ArithExp = I Int | V Variable | Add ArithExp
18:44:18 <tankertux> Is Variable valid there?
18:44:26 <sjanssen> tankertux: presumably Add takes two ArithExps
18:44:39 <tankertux> I didn't finish my thought, so yes
18:44:41 <sjanssen> tankertux: if you define Variable elsewhere it is valid
18:45:18 <tankertux> Is there something like Int for Variables defined in the prelude?
18:45:27 <sjanssen> String, maybe?
18:45:27 <dancor> int-e: but not _too_ far from data MTree m = MTree (M.Map m (MTree m))
18:45:45 <dfranke> I have a datatype Expr which is an instance of Show.  I want to override the generic rule for showing lists when I show an [Expr] but I can't figure out how to do it.
18:45:53 <dfranke> instance Show [Expr] gives
18:46:07 <sjanssen> dfranke: see the showList method
18:46:19 <dfranke> thanks
18:46:23 <dfranke> ?hoogle showList
18:46:24 <lambdabot> Prelude.showList :: Show a => [a] -> ShowS
18:46:24 <lambdabot> Text.Show.showListWith :: (a -> ShowS) -> [a] -> ShowS
18:46:36 <sjanssen> instance Show Expr where showList = something special
18:47:46 <int-e> dancor: but at least that one can still represent some shape.
18:48:36 <sjanssen> int-e: there are some semi-useful functions you can write with data D = D D
18:50:05 <int-e> sjanssen: ah I had it confused with  newtype D = D D, ok. the data version is slightly more interesting.
18:50:39 <tankertux> sjanssen: what would "data Value = Int | Float" mean?
18:51:14 <int-e> tankertux: same as data Enum = A | B with different names for Value, A and B.
18:51:18 <sjanssen> tankertux: it means Value only stores "tags" called Int and Float
18:51:56 <int-e> tankertux: err, I meant Enum instead of Value of course.
18:51:57 <allbery_b> types and data constructors live in different namespaces
18:52:06 <tankertux> And these tags would presumably be able to be interpreted one way or another eventually?
18:52:21 <allbery_b> so you can have a type called Int and a data constructor, completely unrelated, called Int
18:52:38 <dancor> sjanssen: what can D be like there?  is it like Int?
18:52:45 <dancor> well positive int
18:53:13 <allbery_b> most often this is used to do something like:  data Foo = Foo Int -- Foo is both a type and a data constructor for values of type Foo, containing a value of type Int
18:53:29 <sjanssen> dancor: the only thing that D can store is a certain number (potentially infinite) of D constructors followed by bottom
18:53:58 <tankertux> allbery:  Ok, thanks
18:54:05 <sjanssen> say you wanted to write a function that must terminate in n steps or return _|_
18:54:06 <dancor> sjanssen: so it's Z^+ union {infitity}
18:54:11 <dancor> or something
18:54:14 <allbery_b> in the D example, you'd nirmally do:  data D = Nil | D D
18:54:23 <allbery_b> which gives you something rather like a list
18:54:31 <sjanssen> dancor: not exactly, because you can't exactly detect the bottoms in Haskell
18:54:33 <allbery_b> D (D (D (D (D Nil))))
18:55:03 <dancor> so you could use it to intentionally trigger some bottom after some delay
18:55:05 <dancor> heh
18:55:09 <sjanssen> dancor: correct
18:55:10 <allbery_b> more usefully you'd do:  Data D a = Nil | D a D -- which is a Haskell list without the friendlyt syntax
18:55:30 <sjanssen> and you could use the same system to run forever by suppling (fix D)
18:56:14 <int-e> allbery_b: I'd call it Nat. data Nat = Z | S Nat
18:56:14 <sjanssen> dancor: D is isomorphic to [()]
18:56:36 <allbery_b> int-e: sure
18:56:56 <allbery_b> does he grok Peano numerals?
18:57:07 <sjanssen> rather, D is isomorphic to a [()] that is strict in the ()'s in the list
19:02:16 <fantasma> anyone here use the Functional Graph Library for Haskell (FGL)
19:02:30 <tankertux> So, to translate from BNF to data decl's I'm going to need a data declaration for each non-terminal correct?
19:02:46 <sjanssen> tankertux: yeah
19:02:56 <tankertux> err, I meant each terminal
19:03:36 <tankertux> Am I still correct?
19:04:31 <sjanssen> I think you'll need a data declaration for every terminal and nonterminal
19:05:12 <tankertux> Ok, that clears things up a bit
19:05:29 <sjanssen> unless there is an existing data type that represents the terminal well (like Int for integers, etc.)
19:07:38 <fantasma> do GHC imports have to be compiled as *.hi or can normal *.hs source be used?
19:08:48 <ClaudiusMaximus> fantasma: "ghc --make" works well for me
19:09:34 <fantasma> thanks
19:10:42 <tankertux> How would I represent literal strings?
19:11:00 <sjanssen> tankertux: String, probably
19:11:25 <tankertux> Assuming Variable and ArithExp are defined, how would I represent
19:11:33 <tankertux> Stmt ::= Variable := ArithExp | Stmt ; Stmt
19:12:03 <tankertux> Literal strings being the ":=
19:12:04 <tankertux> "
19:12:42 <sjanssen> you wouldn't represent ':=' literally in your translation
19:12:53 <bd_> in parsec, it'd be more common to just do: many (do { s <- statement; semicolon; return s })
19:13:18 <sjanssen> I'd write data Stmt = Assignment Variable ArithExp | Sequence Stmt Stmt
19:15:12 <tankertux> So, I would just "tag" it with what is happening, and leave it at that until it needs to be interpreted?
19:15:45 <sjanssen> yes
19:15:57 <sjanssen> @where pandoc
19:15:57 <lambdabot> I know nothing about pandoc.
19:16:13 <sjanssen> @where+ pandoc http://sophos.berkeley.edu/macfarlane/pandoc/
19:16:14 <lambdabot> Done.
19:17:00 <fantasma> > zip [1..10] (repeat ())
19:17:02 <lambdabot>  [(1,()),(2,()),(3,()),(4,()),(5,()),(6,()),(7,()),(8,()),(9,()),(10,())]
19:18:22 <dons> ok. seems to be working now , sjanssen
19:18:50 <dons> commit time1
19:19:17 <dons> X sucks
19:19:28 <sjanssen> mostly, yes
19:19:31 * dons feels the wm dev crank syndrome beginning
19:19:38 <dons> its X that does it!
19:20:39 <dons> I have a plan to seperate out io effects from internal W monad actions
19:20:49 <dons> so we can simulate running the entire handler framework in QC
19:21:10 <dons> just by supplying a fake X interface. i'll have to think about it some more, but it seems possible
19:21:31 <dons> then we can generate QC streams of events to check the wm for consistency
19:23:05 <dancor> are you using xlib or xhb or what
19:23:12 <dancor> or is there doc online
19:23:21 <dons> xlib atm
19:23:30 <dons> (since it comes with ghc by default)
19:23:39 <sjanssen> dancor: xhb doesn't exist (yet?)
19:23:45 <dons> there's no other X bindings, afaik.
19:23:57 <dancor> aren't you finding that you can't live without XQueryTree
19:24:13 <sjanssen> dancor: I wrote a binding to XQueryTree
19:24:18 <dancor> oh sweet
19:24:20 <dancor> i want it
19:24:30 <dons> scan dpy rootw = do
19:24:30 <dons>     (_, _, ws) <- queryTree dpy rootw
19:24:30 <dons>     filterM ok ws
19:24:32 <dons> :-)
19:24:42 <sjanssen> @where X11-extras
19:24:43 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/X11-extras
19:24:47 <dancor> thanks
19:25:08 <sjanssen> we'll get all of this stuff into the mainline X11 library at some point
19:25:38 <dancor> hot
19:28:47 <sm> evening all
19:30:51 <dons> sjanssen: ok. pushed patches to both X11-extras and thunk
19:31:03 <dons> firefox now works, and we appear to hndle Enter/Leave events properly
19:31:18 <sjanssen> nice
19:31:32 <sjanssen> I'll try to reproduce some other focus bugs I noticed
19:31:52 <dons> the handle code is the ugly stuff though, in our codebase. all mixing io and W state
19:32:17 <dons> and we don't use most of the data. i'd like to translate the handler into an abstract interpreter of events to actions
19:32:25 <dons> so handle :: Event -> Action
19:32:35 <fantasma> question: If I simply drag new interface libraries into the GHC `imports` directory, will GHC automatically recognize their presence?
19:32:38 <dons> then we can interpret the Action as a state change, and as calls into X
19:32:48 <dons> should make it easier to test too
19:33:05 <dons> fantasma: hmm. probably not.
19:33:12 <sjanssen> fantasma: you probably don't want to do that
19:33:13 <chessguy> i think monads should have been called actions
19:33:13 <dons> you shoudl register and install libs with cabal
19:33:27 <sjanssen> chessguy: they aren't always actions
19:33:40 <chessguy> no, but it gets the idea across
19:33:44 <kc5tja> dons: Will there be an annotated code walkthrough for your software?  I'd like to review the software at some point to learn more about applying Haskell to non-console applications.
19:33:51 <fantasma> dons, I did but I get this error:  Can't find interface-file declaration for dijkstra
19:33:51 <fantasma>   Probable cause: bug in .hi-boot file, or inconsistent .hi file
19:33:52 <sjanssen> you can view the [] Monad both as actions and data structures
19:34:30 <dons> yeah, I think we could turn the code into a tutorial on how to write a WM
19:34:31 <bd_> .utf8
19:34:33 <bd_> errr
19:34:35 <bd_> wrong window
19:34:46 <sjanssen> dons: yes, my focus issues seem to be fixed
19:34:52 <dons> great!
19:35:27 <sjanssen> do you have any objections with increasing default workspace count to 9?
19:35:34 <dons> go for it
19:35:37 <sjanssen> okay
19:35:39 <dons> we could even vary it dynamically
19:35:53 <sjanssen> eventually we're going to need to think about user configuration
19:36:00 <dons> yeah.
19:36:13 <dons> so a nice adt to describe config, then read/show from .thunkrc
19:36:22 <sebell> Command-line arguments!
19:37:15 <kc5tja> hmm..you know, I was about to grab ion3 sources here so I can upgrade from ion2.
19:37:29 <kc5tja> dons: But then I remembered, "Hey, I have GHC 6.4.1.  :)"
19:37:37 <kc5tja> dons: Is there a URL to grab your wm code from?
19:37:46 <kc5tja> @where thunk
19:37:47 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/thunk/
19:37:49 <dons> ah, i wonder if it will work with ghc < 6.6. let me check.
19:38:33 <kc5tja> Well, I'm not spending another 7 hours for GHC 6.4 to compile.  I'll probably kick it off before I go to bed for that to happen.  :)
19:38:34 <dons> nope. needs an undated X11 package at least (missing show instance for Display)
19:38:39 <dons> grab ghc 6.6
19:38:45 <chessguy> so can you hack on thunk from inside of thunk?
19:38:53 <dons> have been doing so for several days now
19:39:02 * sjanssen tries the window manager acid test: running konqueror
19:39:12 <dons> i ran konq-embedded fine
19:39:20 <sjanssen> woo!  it launches
19:39:27 <sjanssen> dons: konq-embedded?
19:39:34 <SamB> is konqueror hard on WMs?
19:39:48 <dons> yeah, its a fork of konqueror aimed at being small.
19:39:53 <dons> not sure if its even maintained now
19:40:00 * dons tries gimp ...
19:40:14 <dons> ok. that's rather exciting.
19:40:16 <dons> it works
19:40:27 <kc5tja> http://darcs.haskell.org/~sjanssen/thunk/README -- "dwm" is mentioned as having a goal of 500 LOC.  I think you mean to say Thunk.  :)
19:40:35 <dons> fixing...
19:40:36 <sjanssen> dons: good luck using gimp with full screen windows :)
19:40:58 <kc5tja> sjanssen: I use gimp with full-screen windows in Ion3 at work sometimes.  It works just fine.
19:41:08 <dons> well, lots of switching back and forwards is all
19:41:10 <kc5tja> Does Thunk support tiling as well as tabbing?
19:41:11 <dons> but it does work
19:41:14 <dons> kc5tja: nope.
19:41:23 <kc5tja> Hmmm....  I wonder if that is something I can add.
19:41:25 <dons> tabbing i guess is what the current case is
19:41:29 <chessguy> does thunk have a good haskell code editor built in?
19:41:29 <sjanssen> kc5tja: thunk will have dwm style dynamic windows
19:41:30 <dons> tiling is sjanssen's job
19:41:38 <dons> @slap chessguy
19:41:38 * lambdabot smacks chessguy about with a large trout
19:41:49 <chessguy> ?
19:42:13 <dons> why would a window manager have a built in editor?
19:42:35 <chessguy> dunno, was just asking
19:42:38 <kc5tja> dwm-style floating windows isn't what I was thinking; those aren't tiles, those are normal, overlapping windows.
19:43:15 <sjanssen> kc5tja: not the floating stuff, I'm referring to dwm's automatic tiling thing
19:43:27 <chessguy> i'm not really sure what usually comes built into a WM
19:43:27 <dons> job offers for Haskell programmers: http://blogs.teamb.com/craigstuntz/archive/2007/03/09/WantedHaskellDeveloper.aspx
19:43:28 <kc5tja> sjanssen: OK, I need screenshots to see what is meant by this.
19:43:30 <lambdabot> Title: Wanted: Haskell Programmer, http://tinyurl.com/2yrghp
19:43:52 <kc5tja> chessguy: Other than eye candy, not much.
19:45:01 <chessguy> dons: it doesn't look like they're actually hiring someone for a haskell job
19:45:25 <SamB> chessguy: they just want someone to whine at them?
19:45:28 <chessguy> not if i read it right
19:45:37 <dons> no. they just are using haskell as a filter to find good programmers
19:45:43 <SamB> ah
19:45:43 <chessguy> "So if you live in the central Ohio area and know Haskell, I'd like to talk to you about working for my company. We don't actually do any Haskell development, mind you, but let's face facts: It's not like you're going to find any paying employment writing Haskell anyway, and I'll at least (sincerely!) respect your interests. :)"
19:45:57 <SamB> well, I think good programmers whine at bad practices anyway
19:45:58 <allbery_b> pthbbbbt
19:46:13 <chessguy> funnily enough, i'm interviewing for a haskell job in central ohio tomorrow :)
19:46:14 <dmwit_> ?google pthbbbbt
19:46:20 <lambdabot> http://www.deardiary.net/show/diaries/124181/1169856000?comments=on
19:46:20 <lambdabot> Title: DearDiary.Net :: hasher :: 27 Jan 2007 :: *pthbbbbt*
19:46:30 <SamB> @quote pthbbbbt
19:46:30 <lambdabot> No quotes match. That's something I cannot allow to happen.
19:46:34 <SamB> @quote pthbbt
19:46:34 <lambdabot> No quotes match. Do you think like you type?
19:46:39 <chessguy> @quote bbb
19:46:40 <lambdabot> shapr says: Today's nifty error message: *Main> thread blotttchhhkrrreeeedaaa dddi   nbbbdllleooofcccikkkneeeidddt   eiiilnnnydddeeefffiiinnniiittteeelllyyy
19:46:42 <SamB> @quote pthb*t
19:46:42 <lambdabot> No quotes match. Take a stress pill and think things over.
19:46:49 <JoshTriplett> @quote pth
19:46:49 <SamB> @quote pill
19:46:50 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
19:46:50 <lambdabot> PaulPotts says: Haskell is an even "redder" pill than Lisp or Scheme
19:47:07 <sjanssen> dons: have you ever heard of/tried conkeror?
19:47:15 <SamB> hmm. I'm guessing the red pill is the one you take if you want to see how deep the rabbit hole goes?
19:47:41 <chessguy> i never could keep them straight
19:47:42 <sjanssen> kc5tja: I don't have any screenshots right now (because I'm running thunk)
19:48:07 <JoshTriplett> SamB: Yes.
19:48:18 <SamB> chessguy: me either
19:48:51 <SamB> all I can remember is that one of them just leaves you thinking it was a dream, the other one leaves you *knowing* it was a dream
19:49:18 <chessguy> ah, the matrix. what a movie
19:49:28 <chessguy> the first time i saw it, i watched it 3 times in the same weekend
19:51:01 <dmwit_> Haha, "thread blocked indefinitely"
19:51:06 <dmwit_> That took me a long time.
19:51:41 <chessguy> that's such an awesome error message
19:55:37 <glguy> ?losers
19:55:38 <lambdabot> Maximum users seen in #haskell: 339, currently: 275 (81.1%), active: 35 (12.7%)
19:56:22 <encryptio> is ghc's -O2 option ever slower than -O1/-O ?
19:56:27 <encryptio> in runtime.
19:56:41 <sjanssen> encryptio: it is possible, but rare
19:57:07 <dmead> ?winners
19:57:07 <lambdabot> Unknown command, try @list
19:57:08 <encryptio> is it bad in those rare cases?
19:58:30 <chessguy> ?losers
19:58:30 <lambdabot> Maximum users seen in #haskell: 339, currently: 295 (87.0%), active: 37 (12.5%)
19:58:46 <sjanssen> encryptio: I've never actually seen it happen, so I'm not sure
19:59:54 <benny> I'm trying to build thunk, but I'm already failing at the point that no interface file for the X11-extras exist. And ghc doesn't understand the Extras.hsc
20:00:29 <glguy> Your mom circulates like a public key,
20:00:30 <glguy> Servicing more requests than HTTP.
20:00:34 <dmead> http://graphics.stanford.edu/~monzy/DramainthePhD.mp3
20:00:37 <dmead> ah man
20:00:38 <dmead> thats lol
20:00:56 <glguy> dmead: Is your name Mario?
20:01:00 <glguy> 'cause you just got 1up'd
20:01:04 <dmead> haha
20:01:05 <glguy> lawlz ;)
20:01:17 <sjanssen> benny: so you're hung up on installing X11-extras?
20:01:26 <benny> sjanssen: yes
20:01:37 <dons> you using ghc 6.6?
20:01:40 <sjanssen> benny: can you paste some error messages?
20:01:41 <sjanssen> @paste
20:01:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:01:43 <benny> yes
20:01:46 <dons> and using caba to build?
20:01:58 <benny> nope, that might be the problem
20:02:03 <dons> yes :-)
20:02:11 <dons> runhaskell Setup.lhs configure --prefix=/foo/bar
20:02:21 <dons> runhaskell Setup.lhs build
20:02:24 <dons> runhaskell Setup.lhs install
20:02:38 <hpaste>  encryptio pasted "IO Monad laziness question" at http://hpaste.org/899
20:02:49 <benny> let me install cabal first :-)
20:03:04 <dmead> i'm an unsigned long int
20:03:14 <sjanssen> encryptio: there is no laziness in your example
20:03:19 <dmead> and your an EIGHT BIT CHAR
20:03:22 <sjanssen> putStr and getLine are strict
20:03:31 <emk> Is http://www.haskell.org/http/ the right choice for a Haskell HTTP library?
20:03:31 <lambdabot> Title: Haskell HTTP package
20:04:15 <encryptio> sjanssen: is strict evaluation the rule rather than the exception in most IO operations?
20:04:28 <sjanssen> encryptio: yes, getContents is magical.  It uses a special operation called unsafeInterleaveIO to achieve the laziness
20:04:45 <sjanssen> encryptio: yes, strictness is the rule in the IO monad
20:05:29 <encryptio> coo...
20:05:58 <glguy> while readFile and getContents are not strict
20:10:29 <sjanssen> dons: I've got a nasty little hack to reduce flicker on workspace change :)
20:10:57 <sjanssen> dons: move the new windows in, then move the old ones out
20:11:05 <dons> ah sjanssen , i wsa just thinking about that :-)
20:11:17 <dons> sjanssen: you want me to add that now? its a 1 line change I think
20:11:24 <sjanssen> dons: I've got it
20:11:34 <glguy> sjanssen: are tags looking any more likely?
20:11:37 <dons> cool (we beat dwm here, I think)
20:11:42 <dons> glguy: how would they work?
20:11:55 <glguy> how do tags work?
20:12:15 <dons> when you say 'tags' what functionality do you mean precisely?
20:12:26 <dons> sjanssen: also, how about "fwm" as the name?
20:12:33 <encryptio> @hoogle unsafeInterleaveIO
20:12:33 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
20:12:34 <glguy> you have N tags, any combination of tags can beactive
20:12:38 <dons> cute, lots of people learning haskell eh? http://programming.reddit.com/info/1962b/comments
20:12:40 <lambdabot> Title: Ask Reddit: What languages are you currently working with and/or learning (reddi ...
20:12:41 <glguy> and each window can have any combination of tags
20:12:52 <dons> glguy: so one window can appear in multiple tagsets?
20:13:01 <sjanssen> glguy: dwm lets a window have multiple tags?
20:13:02 <glguy> dons: correct, like in dwm
20:13:04 <dons> and you do what, bind tagsets to screens?
20:13:19 <dons> i didn't know you could have multiple tags in dwm?
20:13:28 <chr1s__> I think the recent trend of the more practical haskell blogposts encourages people to learn Haskell
20:13:35 <dons> otherwise, i only ever 'tag' with the workspace number.
20:13:43 <chessguy> woohoo! lots of fizzbuzz!! http://tickletux.wordpress.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/
20:13:44 <dons> chr1s__: yeah, i think that might be right.
20:13:45 <lambdabot> Title: Using FizzBuzz to Find Developers who Grok Coding  Imran On Tech, http://tinyurl.com/2v344s
20:13:59 <glguy> MOD SHIFT CTRL 1-9 will toggle a tag for the current window in dwm
20:14:16 <sjanssen> I see
20:14:18 <chr1s__> I guess what's still missing is some good tutorials on STM and/or other distributed things
20:14:20 <glguy> MOD CTRL 1-9 will toggle the visibility of a tag
20:14:26 <chr1s__> and a lot of GUI tutorials
20:14:29 <sjanssen> dons: this seems quite achievable in thunk, I think
20:14:30 <glguy> MOD 1-9 makes that the sole tag
20:14:42 <glguy> MOD SHIFT 1-9 sets a window to havea specific tag only
20:16:06 <sjanssen> glguy: how does tagging interact with dynamic tiling?
20:16:12 <dons> chr1s__: yeah, if you look at the list on http://www.haskell.org/haskellwiki/Blog_articles
20:16:14 <lambdabot> Title: Blog articles - HaskellWiki
20:16:30 <dons> sjanssen: thoguh i wonder: does anyone need tagging beyond simple workspace tags (i.e. the current setup)
20:16:30 <chr1s__> yes, I saw it last week or so
20:16:35 <chr1s__> really great writeup
20:16:47 <dons> i've never needed more than N screens, and the ability to shuffle clients across
20:16:51 <glguy> dons: it lets you do things like having a GAIM window open on multiple "desktops"
20:17:03 <dons> right. but how often do you do that?
20:17:08 <glguy> lots
20:17:17 <glguy> I usually have 2 , one for work and one for play
20:17:19 <sjanssen> I never do it, but some people seem to think it is crucial
20:17:21 <glguy> and then another for email
20:17:29 <glguy> and then another for background tasks
20:17:39 <sjanssen> dons: maybe we should set a LOC cap and let glguy write it? ;)
20:17:39 <glguy> and then I'll put gaim windows for people I'm talking to in floating mode
20:17:44 <glguy> and put them on all of hte tags
20:18:00 <glguy> it also makes it easy to pull in windows and send them away
20:18:24 <glguy> i can't imagine how this increase the complexity too dramatically
20:18:50 <glguy> increases
20:19:19 <glguy> Windows are grouped by tags. Each window can be tagged with one or multiple tags. Selecting certain tags displays all windows with those tags.
20:19:25 <emk> Hmm. HSHTTP includes an MD5 module, but it doesn't export it.
20:19:25 <glguy> This is the third paragraph on the dwm site
20:19:39 <dons> if tags are just screens, then allowing a client to appear on multiple screens wouldn't be too hard
20:19:58 <glguy> tags are conceptually different than workspaces
20:20:03 <glguy> in other wms
20:20:07 <glguy> are not!
20:20:09 <glguy> excuse me
20:20:27 <sjanssen> dons: yes, and turning "current workspace" into "Set Tag" shouldn't be too tough
20:20:27 <glguy> and most other wm's allow you to have windows that exist on all workspaces
20:20:45 <emk> I can't wait wait until GHC ships with a standard tool for finding, downloading and installing packages...
20:20:46 <glguy> this is just more finely grained than that
20:20:51 <matt__r> hi y'all
20:20:59 <dons> hey matt__r
20:21:06 <matt__r> I have a generic haskell question
20:21:16 <sjanssen> emk: at least there's one website to find nearly every package
20:21:17 <matt__r> anyone here able to help?
20:21:19 <sjanssen> @hackage
20:21:20 <lambdabot> http://hackage.haskell.org
20:21:27 <matt__r> hackage++
20:21:30 <glguy> matt__r: like the rest of IRC, you just ask
20:21:32 <chessguy> matt__r: don't ask to ask. ask.
20:21:51 <matt__r> how does generic map work in generic haskell?
20:21:51 <emk> sjanssen: Thanks!
20:22:21 <matt__r> I have the survey paper (Comparing approaches to generic programming in haskell)
20:22:33 <matt__r> but the explanation in there is going over my head just a little
20:22:54 <matt__r> since I am trying to replicate this in another paradigm, I really need to understand it better than I currently do.
20:22:59 * glguy just learned about MOD-i just now
20:23:04 <sjanssen> matt__r: is this the generic map that uses associated data types?
20:23:07 <glguy> and Mod-d
20:23:26 <matt__r> sjanssen: I am afraid I don't even know what an associated data type is :)
20:24:45 <glguy> sjanssen: do you suppose clicking on the "tag names" or "screen names" to active them?
20:26:17 <sjanssen> glguy: you want dwm style clicking on the status bar rather than using key combinations?
20:26:35 <glguy> sjanssen: dwm has clicking and keyboard commands
20:26:46 <glguy> I was going to point out that right clicking on them in dwm toggles them
20:26:51 <glguy> if you ended up supporting toggling them
20:27:01 <emk> OK, more stupid questions. Is there a preferred (fast) XML parsing library for Haskell? There seem to be a bunch out there.
20:27:07 <dons> HaXml
20:27:11 <sjanssen> the current design has the statusbar as a separate program, it might not have workspace switching by clicking at all
20:27:13 * glguy *prefers* HXT
20:27:14 <dons> followed by HXT, I would say.
20:27:33 <dons> HaXml is used at Credit Suisse, if that helps :-)
20:27:59 <dons> doesn't the head HaXml have bytestring support too?
20:28:13 <matt__r> I was used at Credit Suisse for a while
20:28:30 <dons> heh
20:29:12 <matt__r> I would hope HaXml is more use to them than I was
20:29:34 <glguy> did they lay you off? fire you?
20:29:36 <glguy> you quit?
20:29:50 <matt__r> nope, just some summer work in my former incarnation
20:33:04 <glguy> can a thread catch killThread?
20:33:20 <glguy> killThread tid = throwTo tid (AsyncException ThreadKilled)
20:33:49 <glguy> to ensure that a finally clause is executed?
20:35:42 <matt__r> sjanssen: now I know what associated data types are..... the answer is no.  I am talking about Genreic Haskell the programming language (well, I guess it is more a pre-processor, but...)
20:36:00 <emk> dons, glguy: Thanks for recommendations! I'll have to check out HaXML's ByteString support.
20:36:13 <sjanssen> matt__r: oh!  sorry for sending you on a wild goose chase
20:36:24 <matt__r> nope - associated types are cool
20:36:29 <emk> I'm expecting to encounter major performance bottlenecks on the XML parsing, to the extent that it might be worth writing everything in C using libxml2.
20:36:34 <matt__r> I just had to be reminded what they were
20:36:39 <chessguy> this would be an interesting haskell project: www.people.fas.harvard.edu/~albert/cscie220/Asst6.pdf
20:36:50 <matt__r> emk: that depends on your goal
20:37:05 <matt__r> using c over a less efficient alternative should be considered an optimisation
20:37:18 <matt__r> since it speeds up your code while taking away your time
20:37:33 <matt__r> you have to trade off how much time you spend vs how fast you need the code to be
20:40:57 <sm> hmm.. I'm trying to work out a simple algorithm - prune tree A to get tree B, by visiting each node and running some test
20:41:13 <dons> filter on the tree, then?
20:41:15 <sm> and just getting confused. Can anyone point me at some examples ?
20:41:17 <emk> matt__r: I'd be pretty happy if I could parse a megabyte of XML/second. Desirable features include full namespace support, an error-recovery mode, and a lax HTML parser using the same API. So these factors are pushing me very strongly towards a libxml2/C solution in the long run...
20:41:20 <kc5tja> Hey, wow, ion3's sources are available via darcs.  I'm seeing darcs popping up more and more often these days...
20:41:39 <dons> emk, ah right. i'm not sure haxml has nsamespace support
20:41:41 <matt__r> i second dons
20:41:59 <sm> filter, yes.. let me try that again
20:42:01 <matt__r> kc5tja: It is pretty compelling once you see it used
20:42:04 <emk> dons: And the last time I looked, the standards compliance looked pretty dubious.
20:42:07 <glguy> hey MC++, if you're so hardcore, how come your tracks don't start at 0?
20:42:15 <SamB> I believe HXT has a slackish HTML parser
20:42:15 <dons> but it might even be worth asking on haskell-cafe@, since xml is rather hot at the moment
20:43:26 <emk> Hmm: "Graham Klyne has extended the 1.12 version of HaXml significantly, in particular to ensure that the parser passes a large XML acceptance test suite, and to deal more correctly with Unicode, namespaces, and parameter entity expansion. His modifications will eventually be merged back in to the main tree"
20:43:30 <kc5tja> matt__r: I've been using it since 0.xx days.  :)
20:44:24 <tankertux> I'm trying to create an instance of Show for a data decl I made
20:44:31 <dons> emk, ah that's itneresting.
20:44:42 <dons> emk, you could ping him (and CC haskell-cafe@)
20:44:51 <emk> I think I may use HaXml for the light stuff, but that I'll be happiest if I code all the critical stuff using libxml2. That's a pretty long list of missing features.
20:44:55 <tankertux> data Exp = Const Int | Aexp Op [Exp]
20:44:56 <dons> since getting really reallygood xml support is a bit of a niche the haskell community should try to tackle
20:45:19 <emk> dons: Yeah, it definitely sounds worthwhile.
20:45:25 <tankertux> Op is already defined and I'm trying to show Aexp
20:45:32 <Cale> I like the HXT arrow approach quite a lot.
20:45:52 <SamB> I don't like their approach to documentation or exports though
20:45:53 <sm> I need a forest filter.. this is progress
20:45:57 <Cale> Though HXT perhaps needs some refactoring to cut down the size of the library now.
20:46:19 <sjanssen> tankertux: you write instances for data types, not data constructors
20:46:44 <chr1s__> I think HXT is the only one that's ready for production
20:46:48 <tankertux> Ok, I meant I'm trying to show Aexp
20:47:29 <tankertux> I have show for Op written already
20:47:43 <glguy> tankertux: Exp is the type constructor, and you have to write the instance for it
20:48:08 <tankertux> I got that, and have written the show for Const already
20:48:30 <glguy> great, then you just write the one for AExp right underneath
20:48:35 <tankertux> but writing Aexp in terms of map and foldr are a pain
20:48:48 <tankertux> that's where I need help
20:49:05 <dons> chr1s__: haxml is used in production though.
20:49:15 <tankertux> I'm not sure why I need map, which is why this question is killing me
20:49:17 <dons> but it just happens to fit the requirements for credit suisse exactly
20:49:29 <dons> though actually, i think they have an internal fork
20:49:31 <glguy> tankertux: why do you post what you have so far, and what you want the output to look like to
20:49:35 <glguy> !paste
20:49:35 <hpaste> Haskell paste bin: http://hpaste.org/
20:49:41 <glguy> don't you*
20:51:03 <hpaste>  tankertux pasted "Aexp using map and foldr" at http://hpaste.org/900
20:51:52 <hpaste>  glguy annotated "Aexp using map and foldr" with "how is this?" at http://hpaste.org/900#a1
20:52:14 * glguy would have used intercalate, but didn't think that would be as instructive
20:52:50 <ivanm> @hoogle intercalcate
20:52:50 <lambdabot> No matches found
20:52:56 <ivanm> @hoogle intercalate
20:52:57 <lambdabot> No matches found
20:53:04 <glguy> intercalate a b = concat $ intersperse a b
20:53:23 <ivanm> ahhh, k
20:54:27 <emk> dons: Thanks for the input!
20:54:56 <sjanssen> dons: I now understand why dwm uses that annoying stack data structure
20:55:23 <sjanssen> to support tags well, you really need a global order for all of your windows
20:55:23 <hpaste>  (anonymous) annotated "Aexp using map and foldr" with "(no title)" at http://hpaste.org/900#a2
20:55:45 <emk> I'm going to experiment a bit with HaXml and then look into a libxml2-based solution.
20:55:56 <dons> sjanssen: yes, to support it we'd hvae to chance StackSet
20:56:01 <tankertux> glguy: would you chack out my annotation?
20:56:07 <dons> which explicitly disallows windows on multiple stacks
20:56:38 <glguy> tankertux: import Data.List
20:56:42 <glguy> ?index intersperse
20:56:42 <lambdabot> Data.List
20:57:17 * dons isn't convinced about generic tags though . complexity .. grumble grumble
20:57:19 <sjanssen> I think a tag data structure would look like: data TagSet a = TS (Map a (Set tag)) [a]
20:57:30 <dons> sjanssen: did you push the flicker/bg patch?
20:57:41 <sm> dangit
20:57:52 <sjanssen> dons: yeah
20:57:56 <dons> so the [a] is the total ordering? and each Map elem is a tag?
20:58:32 <sjanssen> dons: yeah, the [a] is global ordering, the Map keeps track of the tags that each map is a member of
20:58:33 <tankertux> glguy: It works perfect, but I don't get credit without foldr
20:59:02 <sjanssen> erm, the Map tracks the set of tags that belong to each window
20:59:04 <dons> so maybe data TagSet a = TS (Set a) {- everything -} (Map a (Set tag))
20:59:25 <tankertux> glguy: I'm looking for a suggestion, not necessarily a solution b\c this is homework
20:59:28 <sjanssen> dons: the global ordering is crucial
20:59:38 <dons> ah, so its a nub [a]
21:00:13 <glguy> tankertux: you'll want to handle the case where xs is null specially then
21:00:14 <sjanssen> dons: you can avoid nub
21:00:21 <sjanssen> because every window is already in the Map
21:00:32 <sjanssen> when a new window is created you put it at the top of the stack
21:00:58 <dons> sjanssen: ah i see.
21:01:00 <tankertux> glguy: as in... make sure the Op isn't added an extra time at the end?
21:01:18 <dons> so often you'll know the tag (e.g. the current space) and want to peek the stackfor this tag
21:01:24 <dons> so you'll need a reasonabe way to index by tag
21:01:34 <glguy> tankertux: yeah
21:01:47 <sjanssen> dons: another option is TagSet = TS (Map Tag (Set Window)) [Window]
21:02:04 <sjanssen> I think that gives better amortized performance
21:02:12 <glguy> tankertux: you don't need map for this
21:02:20 <glguy> tankertux: because anything that you would do with the map you can do in the fold
21:02:29 <dons> so the Set Window is the unordered stack for a given tag? and then we find out the actual ordering by inspecting the [Window] ?
21:02:44 <dons> (which seems costly0
21:02:59 <dons> that's why there's the inverse map in StackSet currently, so you can index by both window or tag
21:03:06 <dibblego> dons, was it you who referred to an article that made it clear why loops in imperative languages were unnecessary and error prone and why?
21:03:49 <kc5tja> dibblego: Heh, funny you should mention loop-free code.  I'm studying J right now.  :)
21:03:52 <timthelion> hey, I'm reading http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics and in the section: Higher-Order Types there is a paragraph that refers to "the function f above."  is f the function that takes the expresion (\x y -> 2*x +y) 5 4 and returns the expression (\y -> 2*(5)+y) 4?
21:03:58 <sjanssen> dons: yes, it's O(n log n)ish function to determine the windows for a set of tags
21:04:00 <dibblego> kc5tja, :)
21:04:18 <dons> dibblego: hmm. maybe. i don't recall any particular link
21:04:27 <dibblego> dons, ok I'll keep looking
21:04:31 <kc5tja> Hopefully, learning J will allow me to grok Haskell better.  Plus, there is a really nice Calculus book that uses J (written by Iverson).
21:04:59 <kc5tja> Of course, I think that's why Haskell is so tough for me.  Haskell = discrete math, and I've always been an analysis dude.
21:05:58 <hpaste>  tankertux annotated "Aexp using map and foldr" with "Aexp revision" at http://hpaste.org/900#a3
21:06:03 <dons> discrete math eh?
21:06:14 <dons> what's been hardest, kc5tja ?
21:06:34 <sjanssen> dons: after thinking about it, I think the Map Window (Set Tag) is the best
21:06:39 <tankertux> glguy: I'm trying to figure out something like what I just posted
21:06:50 <tankertux> glguy: any suggestions?
21:06:50 <glguy> tankertux: you don't need concat to do this
21:07:10 <timthelion> anyone know why I was confused by YAHT?
21:07:15 <glguy> you only show the op "a" if the rest isn't null
21:07:21 <dons> sjanssen: ok. so given most operations operate on the current tag (e.g. rotate, peek, push), you want to be abe to do that easily
21:07:23 <glguy> and you don't need to use map to do this
21:07:40 <tankertux> I still get an error when I remove concat
21:08:04 <glguy> tankertux: your first try was closer
21:08:19 <glguy> :t foldr
21:08:22 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:08:32 <dons> sjanssen: and this would give us the ability to have windows on multiple stacks, basically?
21:08:32 <glguy> but the type of your function "f" was wrong
21:08:35 <dons> anything else we get ?
21:08:56 <tankertux> hmm
21:09:05 <glguy> f should take two arguments, not one
21:09:10 <sjanssen> dons: this gives us maximum flexibility.  Many tags can be viewed simultaneously, and each window can have many tags
21:09:22 <Korollary> timthelion: you are right
21:09:28 <glguy> sjanssen: that would be ideal ! :-D
21:09:46 <Korollary> timthelion: It's (\x y -> 2*x + y), but it wasn't named f.
21:09:47 <sjanssen> dons: I'm going to try a preliminary TagStack.hs implementation
21:10:12 <timthelion> Should I edit and put that in parens then?
21:10:46 <dons> sjanssen: ok. sounds reasonable
21:11:12 <tankertux> glguy: I think  that was the hint I needed. You Rock!
21:11:15 <dons> try to keep the interfcae clean and polymorphic (and quickchecable), and thing about the functions needed in the current StackSet api
21:11:25 <Korollary> timthelion: good idea
21:11:26 <glguy> tankertux: it works?
21:11:37 <sjanssen> dons: my first step: cp StackSet.hs TagStack.hs :)
21:12:05 <kscaldef> @src fixM
21:12:06 <lambdabot> Source not found. My mind is going. I can feel it.
21:12:13 <matt__r> no go on generic haskell then :(
21:12:20 <hpaste>  tankertux annotated "Aexp using map and foldr" with "closer" at http://hpaste.org/900#a4
21:12:21 <glguy> mfix?
21:12:28 <kscaldef> @src mfix
21:12:28 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:12:54 <kscaldef> @src fix
21:12:55 <lambdabot> fix f = let x = f x in x
21:12:55 <hpaste>  glguy annotated "Aexp using map and foldr" with "closer still" at http://hpaste.org/900#a5
21:13:06 <glguy> :t mfix
21:13:09 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
21:13:25 <dons> sjanssen: yeah, seems to have reduced the flicker . good
21:14:43 <kscaldef> hmm... where does lambdabot get its sources?  Aren't fix and mfix from the same module?
21:16:13 <Korollary> probably ghc sources
21:16:17 <Korollary> @index fix
21:16:17 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
21:16:20 <Korollary> @index mfix
21:16:21 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
21:16:30 <SamB> kscaldef: I think from the CIA
21:16:51 <Korollary> hm
21:16:58 <kscaldef> haha
21:18:12 <kscaldef> also, can someone explain to me how that definition of fix isn't pure magic?
21:18:19 <dons> ?src fix
21:18:19 <lambdabot> fix f = let x = f x in x
21:18:25 <dons> laziness.
21:18:37 <kscaldef> but, where does it start from?
21:18:39 <SamB> well, in a math book it would look more like...
21:18:49 <SamB> fix(f) = f(fix(f))
21:18:50 <dons> > fix (1:) -- can start producing a 1 : node immediately
21:18:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:19:12 <hpaste>  tankertux annotated "Aexp using map and foldr" with "even closer" at http://hpaste.org/900#a6
21:19:27 <kscaldef> > fix (^2)
21:19:29 <lambdabot>  Exception: <<loop>>
21:19:38 <SamB> ksandstr: it starts at the end
21:19:44 <kc5tja> dons: What's been hardest?  Well, the operator names are 100% non-intuitive at all.  Except for map -- map makes sense.  But fold?  Where did THAT name come from?  We both already know my difficulties with monads, which is all category theory.  I still haven't been successful in making my own to play with, but I haven't tried in the past week due to burnout.
21:20:07 <tankertux> glguy: anyway to incorporate map into this so I get credit?
21:20:26 <glguy> do a map show first
21:20:34 <kc5tja> dons: Overall, FPLs make sense to me as long as they rely on basic, high-school to junior college level algebraic concepts.  But anything beyond that, it just doesn't map (heh!) into my worldview of programming at all.
21:20:44 <SamB> er.
21:20:47 <SamB> kscaldef:
21:20:57 <SamB> > 26^2
21:20:58 <tankertux> glguy: can you give me an example? I'm not sure what you mean?
21:20:58 <lambdabot>  676
21:21:14 <emu> > foldr (:) [] [1..10]
21:21:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:21:51 <SamB> hmm. I suppose it would make sense that I would keep doing that when there somewhere around 300 people in here normally...
21:22:00 <emu> a list is a chain of cons cells, and "folding" collapses the chain of conses using some function
21:22:10 <SamB> birthdays and all...
21:22:21 <kc5tja> emu: I'm well aware of that.  My point is, "fold" is a dumb name for the concept.  :)
21:22:30 <emu> What would you pick?
21:22:32 <kc5tja> emu: I would have chosen something like, "over" (e.g., sum "over" a list)
21:22:57 <emu> to me it's natural, but i have FP background
21:23:03 <Cale> kscaldef: lazy evaluation is defined as outermost-first evaluation, with sharing of results whenever a parameter to a function is duplicated in the body
21:23:07 <kc5tja> E.g., picking names that are in tune with what most people already know and use daily, instead of using specialist language.
21:23:19 <Cale> kscaldef: But the important thing there is the outermost first bit
21:23:29 <kc5tja> emu: I've gone through many Calculus courses, and not once have I ever used or heard the term "fold."
21:23:32 <emu> "fold" is what people know and use
21:23:37 <kc5tja> So that terminology is not generally used in all math branches.
21:23:48 <SamB> kc5tja: have you run into conses?
21:24:04 <kscaldef> Cale: I understand... the problem is that I was overestimating the set of functions for which fix manages to return something
21:24:14 <kc5tja> SamB: Again, the phrase "conses" doesn't appear in calculus.  But I'm aware of it from previous Lisp experience.
21:24:15 <Cale> ah, okay
21:24:37 <SamB> kscaldef: it returns the least fixed point. where _|_ is less than anything else
21:24:39 <Cale> yeah, it finds the least-defined fixed point of a function -- for lots of functions, that's undefined
21:24:50 <tankertux> glguy: can you give me an example of your suggestion to map show?
21:25:02 <glguy> k
21:25:15 <hpaste>  glguy annotated "Aexp using map and foldr" with "map" at http://hpaste.org/900#a7
21:25:17 <kscaldef> hmm... well, in my mind, 0 would be the "least fixed point" of ^2
21:25:22 <SamB> > iterate (error "hi!") (1:)
21:25:22 <Cale> However, if the function sends undefined to an at least partially defined value, the end result will be at least partially defined
21:25:23 <lambdabot>  [<[Integer] -> [Integer]>,<[Integer] -> [Integer]>,<[Integer] -> [Integer]>,...
21:25:26 <emu> kc5tja: they are algebraic data types
21:25:26 <kc5tja> emu: Your statement is overly broad.  Clearly, the "people" I know and converse with on a regular basis do not use "fold" to refer to "reduction".
21:25:30 <SamB> hmm.
21:25:36 <Cale> kscaldef: yeah, that's not the ordering we're using on values
21:25:44 <SamB> > iterate (1:) (error "hi!")
21:25:46 <lambdabot>  Exception: hi!
21:25:50 <SamB> erg.
21:26:24 <emu> kc5tja: i've always thought of it intuitively as taking the list structure (visualize it) and folding the chain like an accordion using some function
21:26:25 <kc5tja> emu: Again, these terms are not in use in the level of courses that I've indicated.  That's all I'm saying.
21:26:38 <Cale> We're using a partial order based on the defined components of the values.
21:27:07 <kc5tja> But, nomenclature aside, it's the more "practical" aspects of Haskell that bother me the most.
21:27:25 <kc5tja> E.g., if I want to do anything involving side effects, it involves monads.  And if it involves monads, and I don't understand monads, I'm screwed.
21:27:27 <SamB> kc5tja: don't you mean the less-practical ones
21:27:35 <SamB> oh, wait, that is practical
21:27:48 <SamB> you haven't gotten to the less-practical parts yet I suppose...
21:28:12 <SamB> (maybe that would be where you write a turing machine in a slightly extended typesystem?)
21:28:23 <Cale> kc5tja: actually, you aren't. You just need to understand IO, which happens to be a monad, but you don't even really need to know that.
21:28:27 <kc5tja> SamB: What are you babbling about?
21:28:43 <Cale> You just need to know how IO alone works.
21:28:55 <Cale> not how monads work, or what it means for something to be a monad.
21:28:56 <emu> kc5tja: why do you need to know anything about monads to use IO?
21:28:59 <SamB> kc5tja: er. not much
21:29:11 <emu> kc5tja: do you need to know the details of java collections to use a linked list in java?
21:29:45 <kc5tja> Cale: Well, in reviewing the source code for thunk, for example, there are nested uses of monads, state transformer monads, and all sorts of other "fun" stuff.  This is just for a lowly window manager, sub-500 lines of code.  What if this were, for example, something vastly more sophisticated, like a spreadsheet program, or a flight simulator?
21:29:58 <sjanssen> glguy: do you know what happens when you try to remove a window's only tag?
21:30:00 <glguy> tankertux: You don't want to know the length, you want ot know "null"
21:30:04 <kc5tja> There'd be *vastly* more sophisticated code all over the place.  IO clearly isn't the end of what I need to grok.
21:30:07 <glguy> sjanssen: dwm laughs at you
21:30:18 <Cale> Oh, for practical reading of experienced Haskell users' code, sure.
21:30:18 <glguy> and then ignores you
21:30:29 <sjanssen> glguy: okay, so the request is ignored?
21:30:35 <glguy> right
21:30:38 <Cale> You eventually need to know about monads to understand other users code.
21:30:44 <kc5tja> emu: Yes.
21:30:46 <Cale> I'll agree with that much.
21:31:16 <Cale> But for writing your own code, you can start smaller :)
21:31:31 * kc5tja sighs
21:31:41 <emu> no you don't. no course would introduce it that way. and monads are much easier than the baroque collections interface.
21:31:53 <kc5tja> What I'm getting at is that I'm trying to learn the fundamentals here.  And the fundamentals aren't easily learnt.
21:32:14 <Cale> Well, okay, let's find you a tutorial then, or answer your questions :)
21:32:25 <kc5tja> Cale: If I knew the questions to ask, I'd ask them.
21:32:27 <Cale> I can point you at a 5 minute intro to how IO works.
21:32:31 <tankertux> glguy: sorry, I lost my connection
21:32:39 <SamB> the fundamentals?
21:32:39 <glguy> tankertux: You don't want to know the length, you want ot know "null"
21:32:45 <SamB> you mean the monad laws?
21:32:49 <kc5tja> I've already received numerous tutorials on monads from you and many others, which I have bookmarked and re-read often.  :)
21:32:56 <kc5tja> But I still fail to be able to write my own.
21:33:03 <SamB> oh.
21:33:09 <emu> do you have a specific project?
21:33:11 <SamB> you want a monad-yourself tutorial?
21:33:12 <glguy> tankertux: or you want to pattern match on xs
21:33:15 <kc5tja> If I can't produce my own, however much a toy it is, then I just don't get the fundamentals.
21:33:21 <Cale> Oh, writing your own monads -- that involves insight.
21:33:34 <Cale> Or monad transformers and a little less insight.
21:33:34 <SamB> I can write state monads
21:33:35 <tankertux> glguy: why is that? I thought that if the tail had nothing more in it then leaving off the Op was ok?
21:33:45 <SamB> but usually I don't
21:33:50 <glguy> tankertux: right
21:33:56 <SamB> kc5tja: you don't need to write your own to do most things
21:33:58 <glguy> tankertux: I'm just saying that length is the wrong function
21:33:59 <kc5tja> emu: No specific project at the present time.  But, like I said above, I'd like the ability to grok other people's code, so that I can learn from them too.
21:34:04 <kc5tja> SamB: To do most *simple* things.
21:34:10 <kc5tja> SamB: That's an important qualifier.
21:34:10 <SamB> kc5tja: seriously
21:34:16 <SamB> I don't write my own
21:34:23 <SamB> I use newtyped mtl stacks
21:34:23 <kc5tja> But you understand them, yes?
21:34:32 <Cale> kc5tja: Designing your own monad is akin to designing a domain specific embedded programming language.
21:34:35 <tankertux> Aexp Plus [Const 1, Const 2, Const 3] is giving me 1+2+3, and at this point, I'm not too concerned about efficiency
21:34:36 <SamB> oh, yes, I can understand most of the monads in the MTL
21:34:39 <Cale> (with a particular structure)
21:34:44 <SamB> I don't fully grok parsec
21:34:45 <kc5tja> Cale: Which is done on an hourly basis in Forth.  :)
21:34:53 <tankertux> I just want it to work, but what would you suggest to detect null
21:34:54 <tankertux> ?
21:34:56 <Cale> Well, sure :)
21:35:04 <emu> kc5tja: typically it's done to provide some kind of domain-specific or sub-language.  so the code should be readable without knowing the monad implementation, unless that's what you want to read.  given some suitable docs about it, i suppose.
21:35:04 <Cale> It's not just any EDSL though.
21:35:12 <Cale> It's a specific kind of EDSL
21:35:37 <SamB> State/StateT and Reader/ReaderT are the most important
21:35:47 <kc5tja> emu: When I write code, I want my code to read as naturally as possible.  Self-documenting code is the goal.
21:35:51 <tankertux> glguy: It works. Why do I need to check for null? Efficiency?
21:35:53 <Cale> When you happen to have an EDSL which is a monad, the benefit is that you can take advantage of all the stuff in Control.Monad for free.
21:35:58 <SamB> kc5tja: so, use the mtl
21:36:09 <kc5tja> SamB: I don't even know what mtl is.
21:36:16 <kc5tja> Is this a library that you wrote or something?
21:36:19 <Cale> But if it's not obvious that your DSL is a monad, then don't worry about it :)
21:36:20 <SamB> no!
21:36:20 <glguy> tankertux: yeah, it's an efficiency issue, but I look at it as an idiomatic one too
21:36:22 <emu> kc5tja: that's why people create the monads
21:36:40 <hpaste>  glguy annotated "Aexp using map and foldr" with "pattern matching" at http://hpaste.org/900#a8
21:36:42 <Cale> The mtl is basically all the libraries hanging off of Control.Monad
21:36:48 <SamB> I was considering porting it to use associated types a while back, but then I learned that associated type synonyms were not yet implemented
21:36:49 <glguy> tankertux: check that annotation
21:36:57 <Cale> Like Control.Monad.State, Control.Monad.Writer and so on
21:37:13 <Cale> They provide building blocks for quickly constructing simple common kinds of monads.
21:37:35 <SamB> so I ported what I had written so far into a demo language and have been waiting for chak to implement AT synonyms since ;-)
21:37:43 <Cale> StateT/WriterT/ReaderT and such
21:37:59 <SamB> StateT is pretty easy
21:38:08 <SamB> ReaderT isn't very hard, either.
21:38:08 <tankertux> glguy: Ah, I see, thanks for all your help
21:38:13 <dmwit_> Bah, the State monad still stymies me.
21:38:14 <Cale> Usually you don't want to use these transformers raw -- you have a specific monad you're aiming for, and you build it up by using those as building blocks.
21:38:18 <kc5tja> And, yet, State is beyond me.
21:38:33 <Cale> okay, State isn't so bad, let's go over it carefully
21:38:39 <SamB> kc5tja: well, how would you pass around a state value right now?
21:38:49 <tankertux> glguy: I have to submit it now, so thanks SO much for your help
21:38:56 <Cale> In the beginning, it's more important to understand the examples of monads than it is to see the big picture.
21:38:57 <kc5tja> SamB: (result, world') = F(inputs, world)
21:39:10 <kc5tja> This is all I can do at the present moment, with my present understanding.
21:39:13 <glguy> tankertux: welcome!
21:39:15 <Cale> @unmtl State
21:39:15 <lambdabot> err: No applications
21:39:20 <Cale> @unmtl State s
21:39:21 <lambdabot> State s
21:39:24 <Cale> @unmtl State s a
21:39:24 <lambdabot> s -> (a, s)
21:39:29 <Cale> there we go :)
21:39:36 <SamB> yeah, see, it does pretty much the same thing
21:39:51 <emu> kc5tja: the basic idea is to remove the plumbing which passes around worlds, and put that behind the scenes
21:39:58 <Cale> A value of type State s a is a function from an initial state, to a value of type a, together with a new state.
21:40:09 <encryptio> kc5tja: so a monad lets you do (f inputs >>= ...), which hides (but still passes) the information - in the State monad, the "world", or state
21:40:14 <kc5tja> emu: I know that's the idea.  But, making it all work -- that's the hard part.
21:40:26 <emu> there's using it, and there's implementing it. which do you mean?
21:40:26 <Cale> okay, so let's go over the code for bind
21:40:40 <SamB> (wrapped up in a nice type)
21:42:07 <SamB> so, the State monad does almost *exactly* what you would do already (it rearranges the arguments a bit, but that isn't terribly interesting ;-)
21:42:40 <kc5tja> SamB: I disagree -- to me, it IS terribly interesting.  :)
21:43:26 <SamB> kc5tja: the interesting part is that you don't have to worry about it once you have your monad
21:43:40 <emu> i basically opened up the GHC Control/Monad/State.lhs file one day just to learn the implementation
21:43:54 <emu> it's really the same as in the tutorials, plus some additional instances
21:43:54 <SamB> @src State >>=
21:43:55 <lambdabot> Source not found. Wrong!  You cheating scum!
21:43:59 <SamB> @src >>= State
21:44:00 <lambdabot> Source not found. It can only be attributed to human error.
21:44:00 <bd_> @src State (>>)
21:44:01 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:44:03 <bd_> @src State (>>=)
21:44:03 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:44:06 <SamB> hmm.
21:44:13 <SamB> dons: make it nice!
21:44:30 <emu> broccoli brains? tasty
21:45:16 <dmwit_> @src (>>=) :: State a -> (a -> State b) -> State b
21:45:17 <lambdabot> Source not found. My mind is going. I can feel it.
21:45:23 <dibblego> is it fair to say that if you find yourself writing functions of type a -> (a, b) (perhaps even c -> d -> a -> (a, b)), then it is almost certainly better written using the State monad?
21:45:34 <glguy> ?src State (>>=)
21:45:34 <lambdabot> Source not found. Where did you learn to type?
21:45:42 <glguy> ?src [] (>>=)
21:45:43 <lambdabot> m >>= k     = foldr ((++) . k) [] m
21:45:52 <glguy> ^^ that's how you specify
21:46:02 <dmwit_> :t State a b
21:46:04 <lambdabot> Not in scope: `a'
21:46:05 <lambdabot>  
21:46:05 <lambdabot> <interactive>:1:8: Not in scope: `b'
21:46:06 <glguy> ?src (State Int) (>>=)
21:46:07 <lambdabot> Source not found. My pet ferret can type better than you!
21:46:10 <glguy> ?src State Int (>>=)
21:46:11 <lambdabot> Source not found. Take a stress pill and think things over.
21:46:16 <glguy> ?src State a (>>=)
21:46:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:46:21 <glguy> I don't know if State works though
21:46:22 <glguy> dons?
21:46:24 <dmwit_> ?src (State Int Int) (>>=)
21:46:24 <lambdabot> Source not found. That's something I cannot allow to happen.
21:47:01 <glguy> :src Monad
21:47:02 <dons> hmm?
21:47:06 <glguy> ?src Monad
21:47:06 <lambdabot> class  Monad m  where
21:47:07 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
21:47:07 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
21:47:07 <lambdabot>     return      :: a -> m a
21:47:07 <lambdabot>     fail        :: String -> m a
21:47:12 <SamB> dons: it not give us MTL sources!
21:47:27 <dons> yeah, no mtl stuff.
21:47:30 <SamB> and worse, it mocks us!
21:47:38 <glguy> dmwit_: dmwit_ State Int Int isn't a monad
21:47:39 <dons> oh, there's ErrorT
21:47:42 <glguy> State Int is :)
21:47:54 <dons> ?src Cont fmap
21:47:55 <lambdabot> fmap f m = Cont $ \c -> runCont m (c . f)
21:47:57 <dmwit_> glguy: Okay.  This one still confuses me (a lot).
21:48:05 <SamB> dons: nicerate it!
21:48:08 <emu> monad is a class of type constructors
21:48:15 <dons> ?src ErrorT (>>=)
21:48:16 <lambdabot> m >>= k  = ErrorT $ do
21:48:16 <lambdabot>     a <- runErrorT m
21:48:16 <lambdabot>     case a of Left  l -> return (Left l)
21:48:16 <lambdabot>               Right r -> runErrorT (k r)
21:48:27 <SamB> or beat plugin author into doing it, if it wasn't you
21:48:40 <glguy> Monad's have kind *->*
21:48:46 <glguy> -'
21:48:52 <dmwit_> Right, that's reasonable.
21:49:03 <dmwit_> Okay, that's a good sanity check, cool.
21:50:35 <dmwit_> :t undefined :: State Int
21:50:37 <lambdabot>     `State Int' is not applied to enough type arguments
21:50:37 <lambdabot>     Expected kind `?', but `State Int' has kind `* -> *'
21:50:46 <glguy> :k State Int
21:50:47 <dmwit_> :t undefined :: State Int Int
21:50:48 <lambdabot> * -> *
21:50:50 <lambdabot> State Int Int :: State Int Int
21:50:55 <dmwit_> ...
21:51:13 <dmwit_> ?src State
21:51:14 <lambdabot> Source not found. stty: unknown mode: doofus
21:51:24 <glguy> :k State
21:51:27 <lambdabot> * -> * -> *
21:51:32 <dons> there's no State in the @src. its not been added.
21:51:34 <glguy> :k []
21:51:37 <lambdabot> * -> *
21:51:38 <dons> ?source Control.Monad.State
21:51:38 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
21:51:50 <emu> :kind lambdabot
21:51:59 <dmwit_> :k lambdabot
21:52:02 <lambdabot> Not in scope: type variable `lambdabot'
21:52:16 <glguy> dmwit_: only capitalized things have kind
21:52:35 <glguy> er, or different kinds than * :)
21:52:42 <glguy> :k 2
21:52:42 <kowey> kc5tja: just as a random burst of encouragement, once you understand how State works, monads will feel a lot less mysterious
21:52:44 <lambdabot> Only unit numeric type pattern is valid
21:52:50 <glguy> :k ()
21:52:53 <lambdabot> *
21:52:54 <glguy> bad example
21:52:58 <kowey> fwiw, the wikibooks tutorial spends quite a bit of time on State
21:52:59 <glguy> :k "a"
21:53:02 <lambdabot> parse error on input `"'
21:53:16 <glguy> oh, maybe I was right after all?
21:55:49 <allbery_b> () is both type and nullary constructor
21:56:26 <glguy> similar to
21:56:26 <allbery_b> 1 possibly "should be" a constructor, except that haskell overloads it
21:56:28 <glguy> :k []
21:56:31 <lambdabot> * -> *
21:56:31 <glguy> :t []
21:56:32 <kc5tja> kowey: Which I've re-re-re-read often.  :)
21:56:34 <lambdabot> forall a. [a]
21:56:40 <allbery_b> :t 'a'
21:56:42 <lambdabot> Char
21:56:44 <allbery_b> k 'a'
21:56:46 <allbery_b> :k 'a'
21:56:49 <lambdabot> parse error on input `''
21:57:06 <allbery_b> should be a constructor, my some theories, but that's not how haskell works
21:57:09 <dmwit_> ?. :k :t 'a'
21:57:09 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: ":k"
21:57:28 <allbery_b> ?. @kind @type 'a'
21:57:28 <kowey> kc5tja: even the stuff that focuses on State? hmm... oh well... it took me a long time too, but then it all just made sense
21:57:28 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "@kind"
21:57:30 <allbery_b> oops
21:57:34 <allbery_b> @. kind type 'a'
21:57:39 <lambdabot> *
21:57:46 <dmwit_> =)
21:57:52 <glguy>  :k is special cased
21:57:56 <glguy> doesn't even work in /query
21:58:00 <allbery_b> in any case, 'a' isn't primitive in ghc
21:58:06 <allbery_b> @src Char
21:58:06 <lambdabot> data Char = C# Char#
21:58:24 <dmwit_> C#?
21:58:34 <allbery_b> so secretly 'a' becomes C# something
21:58:44 <allbery_b> anything suffixed with # is a GHC internal
21:58:52 <allbery_b> :k C#
21:58:53 <dmwit_> aha
21:58:54 <lambdabot> Not in scope: type constructor or class `C#'
21:59:20 <kc5tja> kowey: Yes.  I just "don't get it".
21:59:50 <kowey> don't worry about it then; you probably will get it when you start doing your own State-monad like things
22:00:01 <allbery_b> I *think* the reason for that is that Char is a lifted type:  that is, _|_ can inhabit it
22:00:07 <kc5tja> kowey: I've BEEN trying.  That's the problem.  :(
22:00:07 <allbery_b> :t undefined :: Char
22:00:10 <lambdabot> Char :: Char
22:00:11 <dmwit_> Oh, hey.
22:00:27 <allbery_b> C# is an "unboxed" type; it can never be undefined
22:00:28 <dibblego> I wish someone would post a simple example of using the State monad so I don't have to keep figuring it out
22:00:33 <allbery_b> er, Char#
22:00:49 <SamB> kc5tja: it works best if you have an interface in mind when you are trying to make a monad ;-)
22:01:21 <allbery_b> C# is the data constructor for the unboxed type, and by using it Char can have _|_ (undefined) as a "value"
22:01:29 <kowey> kc5tja: another thing that helps me is trying to write my own tutorial
22:01:43 <glguy> dibblego: I'll paste one
22:01:49 <glguy> :t random
22:01:52 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
22:01:56 <SamB> kowey: are you going to make people read it too?
22:02:06 <dibblego> glguy, that would be handy, especially wrt random number generatiom
22:02:48 <kowey> kc5tja: for a data point, i've been work in Haskell for the past 3 years, and I've never really needed to make my own monads, excluding use of transformers
22:02:59 <kowey> SamB: :-) it's now an official exercise, you know
22:03:16 <dibblego> glguy, or an example where an array is passed around for memoising - *that* would be very handy
22:03:18 <SamB> oh?
22:03:43 <SamB> I haven't finished mine yet :-(
22:04:05 <kowey> quoting http://en.wikibooks.org/wiki/Haskell/Understanding_monads - Write a tutorial explaining how monads work. You might find inspiration in the tutorials listed on the Haskell meta-tutorial. Try to find a new audience for your tutorial, or a new way of explaining things.
22:04:07 <dmwit_> Hmmm... one of these bookmarks is supposed to be to a tutorial on state monads...
22:04:14 <kc5tja> kowey: I tried explaining how State monad worked to a friend of mine, and I couldn't do it.  I eventually just gave up.
22:04:16 <dmwit_> But there seems to be a pattern match failure on titles.
22:04:31 <hpaste>  glguy pasted "state example with random numbers" at http://hpaste.org/901
22:04:37 <glguy> I didn't try compiling that
22:04:40 <glguy> so it could have errors
22:04:40 <SamB> my tutorial was based on building a BF interpreter
22:04:54 <dibblego> glguy, thanks
22:04:58 <allbery_b> this probably isn't tutorial material, since it's StateT IO, but:  http://www.ece.cmu.edu/~allbery/Zemanim.hs
22:05:00 <kowey> kc5tja: well, it works best when you're writing, because you can take your time and figure things out when they don't make sense
22:05:20 <allbery_b> uses a StateT IO with a map and some parameters as state, for memoization
22:05:23 <SamB> I'm pretty sure my BF interpreter was going to use StateT IO, too ;-P
22:05:27 <kowey> kc5tja: but writing really forces you to grapple with the subject in a way that merely reading about it does not... highly recommended
22:05:35 <SamB> it just isn't BF if you don't run the risk of corrupting memory ;-P
22:06:09 <dibblego> glguy, it won't compile, because the last do does not have a return
22:06:14 <glguy> I wrote my bf interpreter in parsec where the parser return an IO ()
22:06:18 <glguy> returned*
22:06:29 <SamB> yeah
22:06:30 <allbery_b> (I'm pretty sure it over-memoizes, but some of the stuff it computes really does want to be memoized because it's used repeatedly.  and the sunrise/sunset calcs are expensive and are at the root of pretty much everything)
22:06:31 <SamB> me too
22:06:33 <glguy> dibblego: ok, so add one :)
22:06:47 <dibblego> glguy, did :)
22:07:02 <SamB> I think I was retconning a bunch of intermediate parts, though
22:07:44 <SamB> (you know, like at one point the interpreter will have an AST, but later you will remove the AST?)
22:08:01 <dmwit_> rollDice ===? rollDie
22:08:08 <glguy> yeah
22:08:11 <glguy> like I said :)
22:08:12 <SamB> actually, I think it returned a StateT IO
22:08:15 <dmwit_> k
22:08:16 <SamB> thingy
22:08:28 <SamB> @roll 1d12
22:08:28 <lambdabot> Consider it noted.
22:08:30 <allbery_b> also, I wrote that while still very new to Haskell so I'm sure both style and execution suck :)
22:08:36 <SamB> what?
22:08:37 <allbery_b> heh
22:08:37 <hpaste>  glguy annotated "state example with random numbers" with "updated" at http://hpaste.org/901#a1
22:08:38 <dmwit_> ?help roll
22:08:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:08:41 <allbery_b> @die
22:08:41 <lambdabot> unexpected end of input: expecting number
22:08:54 <SamB> @die 1d12
22:08:54 <lambdabot> 1d12 => 7
22:09:04 <SamB> @die 152d12
22:09:05 <lambdabot> 152d12 => 981
22:09:18 <dmwit_> ?die 1d7
22:09:19 <lambdabot> 1d7 => 4
22:09:27 <SamB> @dice d1
22:09:27 <lambdabot> unexpected "d": expecting number
22:09:29 <SamB> @dice 1d1
22:09:30 <lambdabot> 1d1 => 1
22:09:35 <dmwit_> ...because a seven-sided die would be pretty neat.
22:09:58 <glguy> Sometimes learning how a monad works is a let down
22:10:11 <glguy> the Cont monad was much more facinating before I looked under the covers
22:10:37 <dibblego> :t evalState
22:10:39 <lambdabot> forall s a. State s a -> s -> a
22:10:43 <SamB> I think it is merely headachey
22:10:47 <glguy> ?src runState
22:10:48 <lambdabot> Source not found. My pet ferret can type better than you!
22:10:49 <dmwit_> dibblego: I was just about to type that.
22:10:58 <glguy> :t runState
22:11:01 <lambdabot> forall s a. State s a -> s -> (a, s)
22:11:15 <glguy> :t State
22:11:18 <lambdabot> forall s a. (s -> (a, s)) -> State s a
22:11:47 <glguy> ?unmtl State Int Double
22:11:47 <lambdabot> Int -> (Double, Int)
22:12:00 <glguy> ?unmtl Cont Int Double
22:12:01 <lambdabot> (Double -> Int) -> Int
22:12:13 <dibblego> why am i getting "empty do construct" when I put return (roll1, roll2) ?
22:13:24 <glguy> replace the $ with a ( ) around that whole thing
22:13:28 <dmwit_> dibblego: Why should you need a return at the bottom of main?
22:13:38 <glguy> dmwit_: no
22:13:46 <dmwit_> Oh, I get it.
22:13:53 <glguy> dibblego: it's probably because my indentation wasn't far enough in
22:14:01 <dmwit_> Well, I get (prev+epsilon) of it. =)
22:15:08 <hpaste>  glguy annotated "state example with random numbers" with "this compiles" at http://hpaste.org/901#a2
22:15:24 <glguy> you people are *needy* :)
22:15:56 <dmwit_> urgh...
22:16:29 <dmwit_> let (roll1, roll2) = ... return (roll1, roll2)
22:17:03 <glguy> dmwit_: don't worry, while it doesn't make a circular reference
22:17:11 <glguy> the roll1 <- shadows the other
22:17:40 <dmwit_> Oh, I know, it just seems less pretty than what is usual in Haskell.
22:17:49 <glguy> you are focusing on the wrong aspect of the code, I'm not making a style statement
22:17:53 <dmwit_> Yes.
22:17:54 <dmwit_> Okay.
22:18:01 <glguy> I threw that up in one go so you people could look at State code :-p
22:18:03 <fantasma> > last 10 [1..50]
22:18:03 <dmwit_> I'm also trying to grok it, don't worry.
22:18:03 <lambdabot>   add an instance declaration for (Num [[t] -> a])
22:18:15 <dmwit_> It's just that my understanding comes slower than my gut reactions. =P
22:18:47 <dmwit_> > take 10 $ reverse [1..50]
22:18:49 <lambdabot>  [50,49,48,47,46,45,44,43,42,41]
22:19:02 <dmwit_> > reverse . take 10 $ reverse [1..50]
22:19:03 <fantasma> wow, how do I always forget that :(
22:19:04 <lambdabot>  [41,42,43,44,45,46,47,48,49,50]
22:21:13 <glguy> > let lastN n xs = aux xs (drop n xs) where aux (_:xs) (_:ys) = aux xs ys; aux xs _ = xs in lastN 10 [1..50]
22:21:15 <lambdabot>  [41,42,43,44,45,46,47,48,49,50]
22:21:21 <dmwit_> :t aux
22:21:23 <lambdabot> Not in scope: `aux'
22:21:35 <dmwit_> Oh.  Man I'm slow.
22:22:29 <fantasma> >  reverse . take 10 . reverse . show $ (28433 * 2**7830457 + 1)
22:22:31 <lambdabot>  "Infinity"
22:22:43 <dons> sjanssen: there's some bug with managing firefox's subwindows. they have funny XIDs (i.e. windows created with 'New window' in firefox), and if you kill them X complains tht the XID isn't valid (and dies)
22:22:44 <dmwit_> =)
22:22:57 <sjanssen> dons: yeah, I've noticed that too
22:23:02 <glguy> > let lastN n xs = fst $ until (null . snd) (tail &&& tail) (xs,drop n xs) in lastN 10 [1..50]
22:23:03 <lambdabot>  Couldn't match expected type `(a1, [a])'
22:24:14 <fantasma> >  reverse . take 10 . reverse . show $ (28433 * 2^7830457 + 1)
22:24:18 <lambdabot> Terminated
22:24:27 <fantasma> cmon crunch it out
22:24:44 <sjanssen> dons: we need to do the handling in dwm's isprotodel function
22:25:00 <glguy> :t tail &&& tail
22:25:02 <lambdabot> forall a. [a] -> ([a], [a])
22:25:05 <glguy> OHHH
22:25:12 <glguy> > let lastN n xs = fst $ until (null . snd) (tail *** tail) (xs,drop n xs) in lastN 10 [1..50]
22:25:13 <lambdabot>  [41,42,43,44,45,46,47,48,49,50]
22:25:22 <dons> ah right
22:25:47 <dons> sjanssen: yes, I see. special WMDelete delete handling
22:26:06 <fantasma> how do you do this calculation in haskell: 28433 * 2^7830457 + 1
22:26:07 <dons> i guess that means we XSendEvent to firefox to close it
22:26:23 <dons> and then firefox says somethign like "you have attempted to close Foo, continue?"
22:27:04 <fantasma> @google 28433 * 2^7830457 + 1
22:27:07 <lambdabot> http://sb.pns.net/stats/
22:27:07 <lambdabot> Title: Seventeen or Bust: Project Stats
22:27:30 <glguy> > let lastN n = fst . until (null . snd) (tail *** tail) . ((,) `ap` drop n) in lastN 10 [1..50]
22:27:31 <lambdabot>  [41,42,43,44,45,46,47,48,49,50]
22:27:55 <sjanssen> dons: that dwm fullscreen mode that you use, is it baked into dwm?
22:28:18 <dons> its just floating mode, with everything maximised (though often it won't maximise fully)
22:28:20 <glguy> > let lastN n = (fst . until (null . snd) (tail *** tail) . ) . ap (,) . drop in lastN 10 [1..50]
22:28:21 <lambdabot>      The operator `.' [infixr 9] of a section
22:28:21 <lambdabot>         must have lower precede...
22:28:32 <dons> so hmm, its not tiled mode
22:28:38 <sjanssen> ahh, I see
22:28:39 <glguy> > let lastN n = ((fst . until (null . snd) (tail *** tail)) . ) . ap (,) . drop in lastN 10 [1..50]
22:28:40 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
22:28:46 <dons> we'd need to support both tiled and stacked mode I think
22:28:52 <dons> where 'stacked' is the current layout
22:29:03 <sjanssen> yes
22:29:04 <dons> fully maximised, stacks
22:29:14 <dons> and tiled takes the stacks in the current tag and tiles them
22:30:30 <sjanssen> did you know that dwm has extensible layout systems?
22:31:16 <sjanssen> the available layouts are stored in an array of function pointers, so an ambitious user could potentially add some new layout algorithm in their config.h
22:31:16 <arcatan> huh, dwm hacking on #haskell?
22:31:25 <sjanssen> arcatan: dwm cloning
22:31:27 <sjanssen> @where thunk
22:31:28 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/thunk/
22:31:33 <arcatan> a-ha
22:32:18 <arcatan> why?
22:32:30 <dons> 'cause we can do it in 200 loc
22:32:34 <glguy> > let lastN = (.) (fst . until (null . snd) (tail *** tail)) . ap (,) . drop in lastN 10 [1..50]
22:32:36 <lambdabot>  [41,42,43,44,45,46,47,48,49,50]
22:32:44 <arcatan> heh
22:32:51 <sjanssen> arcatan: and 'cuz we like hacking Haskell
22:32:55 <dons> sjanssen: you know, just avoiding the flicker makes thunk nicer for me to use than dwm.
22:33:18 <dons> and yeah, its fun.
22:33:27 <dmwit_> What flicker?
22:33:32 * dons <3 writing QC tests for window manager code 
22:33:54 <sjanssen> dons: I'm anxious to see whether things look funky when you've got sparse windows in float mode
22:34:07 <sjanssen> the transition is probably too fast to see anything, though
22:34:14 <glguy> do you support having tiled and floating stuff at hte same time?
22:34:22 <dons> dmwit_: in dwm I get a brief flicker when switching tags, as the current tag set is moved off screen, nd the new set moved in
22:34:27 <sjanssen> glguy: there is no floating stuff yet
22:34:36 <dons> well, its all floating really :-)
22:34:54 <dmwit_> Aha, it's faster than my eye at home, but I know just what you mean when I'm going via VNC... =P
22:35:20 <dons> the solution is to swap in the new tag set first, then once its in place, swap out the old set
22:35:31 <sjanssen> glguy: but we'll probably have to support windows that are always floating, transient windows just won't look right without it
22:35:58 <glguy> sjanssen: transient windows?
22:36:13 <glguy> dialog boxes?
22:36:24 <sjanssen> glguy: little popup windows, like when firefox asks you whether you want to close the window
22:36:42 <glguy> (which is what dwm does now, right?)
22:36:57 <sjanssen> glguy: correct
22:37:18 <sjanssen> dwm also has the ability to set any window into float mode
22:37:27 <mbishop> sadly tiling window managers have problems with some ideas (some have crappy workarounds, but most are still just hackish heh)
22:37:28 <glguy> right, MOD SHIFT SPACE
22:37:45 <mbishop> like the 20 bazillion popups of every browser around
22:38:03 <sjanssen> mbishop: dwm does a surprisingly good job with stupid applications
22:38:17 <sjanssen> better than ion3 when I used it back in the day
22:38:20 <kosmikus> matt__r: still there?
22:38:41 <glguy> sjanssen: thunk... it doesn't even have an 'h' in the name..
22:38:46 <glguy> hardly a haskell application !
22:38:48 <glguy> ;)
22:38:54 <dmwit_> > "thunk" !! 1
22:38:55 <arcatan> htunk
22:38:56 <lambdabot>  'h'
22:38:57 <sjanssen> > elem 'h' "thunk"
22:38:58 <lambdabot>  True
22:39:15 <glguy> yeah whatever
22:39:17 <glguy> :(
22:39:29 * glguy is obviously too tired to recognize letters
22:39:33 <fantasma> it should be called houseWM
22:39:38 <glguy> that might make it time for bed
22:39:49 <arcatan> i should install new version of dwm, hmm..
22:39:57 <sjanssen> I'm a bit tired of h and hs prefixed names
22:40:03 <glguy> sjanssen: i was joking
22:40:19 <dmwit_> glguy: If I have a function that updates state, and I call it in the middle of another stateful function... do I have to grab the state from "get" again?
22:40:43 <bd_> dmwit_: yes. It's generally a good idea to use combinators on top of get and put so you don't make mistakes with them :)
22:40:44 <glguy> dmwit_: if you want to see the modified state value
22:41:48 <glguy> I think that hpaste is a fitting name, since the point was to make a pastebin in haskell and it was replacing lisppaste in channel
22:42:05 <dons> i like 'fwm' for a name, actually
22:42:09 <dons> the functional window manager.
22:42:11 <glguy> "treble" might have been less evocative :)
22:44:11 <sjanssen> dons: the trouble is that: all nameTaken . map (:"wm") ['a'..'z'] == True
22:44:44 <glguy> sjanssen: haskell supports shadowing!
22:45:06 <mbishop> heh
22:45:06 <mbishop> wm'
22:45:07 <sjanssen> fwm does seem like one of the least popular existing applications
22:45:24 <sjanssen> ooh, wm-prime is a decent one
22:45:44 <dmwit_> :t evalState
22:45:47 <lambdabot> forall s a. State s a -> s -> a
22:46:30 <araujo> Haskell ... The language which you play with , and not the opposite.
22:47:12 <sjanssen> dons: funcwm gets only 4 hits on google
22:48:11 <sjanssen> dons: and funkwm gets three
22:48:19 <Cheery> Anyone else likes chiptunes?
22:48:38 <sjanssen> I like chips.  And tunes.
22:48:50 <dons> fpwm ?
22:48:55 <dons> pfwm
22:49:01 <dons> pure-functional ...
22:49:18 <dmwit_> thunk, por favor
22:49:45 <dmwit_> If you think there are to many h* apps, I think there are too many *wm apps...
22:49:52 <dons> heh "Finder Window Manager (FWM) is an application for managing all of your Mac OS X Finder window needs."
22:50:06 <Cheery> funwin
22:50:12 <dmwit_> !
22:50:13 <dmwit_> =D
22:50:31 <sjanssen> win tends to feel like "windows"
22:51:28 <Cheery> who cares except them? ;)
22:51:34 <dons> wmonad ?
22:51:46 <dons> r hits.
22:51:48 <dons> 3
22:52:04 * dons kind of likes the 'monadic window manager' selling point
22:52:45 <merus> monadic windows manager?
22:52:49 <Cheery> monadbox
22:52:51 <dons> secret fp warez
22:52:56 <merus> omg.
22:54:38 <dmwit_> Augh, my error uses the term "functional dependencies."
22:54:40 <sjanssen> we could also play off our dwm heritage: swm, the static(ly typed) window manager
22:54:56 <glguy> oh, i know... dwm2
22:55:00 <dons> ah hehe
22:55:10 <glguy> that wouldn't ruffle any feathers
22:55:12 <dons> swm eh?
22:55:14 <sjanssen> ARG might get grumpy . . .
22:55:39 <glguy> swim?
22:56:06 <sjanssen> swim has all of the problems that thunk has
22:56:08 <dons> swm has a long history though.
22:56:43 <dons> i think we can't use 'wm' as a suffix
22:56:45 <dons> they're all taken.
22:56:53 <glguy> wmh
22:56:58 <glguy> doesn't use wm as suffix
22:57:02 <glguy> doesn't use h as prefix
22:57:08 <glguy> bases covered
22:57:17 <merus> lol.
22:57:21 <dons> xmonad ?
22:57:29 <dons> that sounds like secret alien technology
22:57:33 <glguy> that sound slike an xlogo
22:57:36 <glguy> that brings up a lambda
22:57:59 <glguy> and thing sthat have the x prefix tend to be outdated
22:58:03 <sjanssen> xmonad sounds intriguing
22:58:05 <dons> and we can change the actual W mond to be an X monad.
22:58:39 <dmwit_> layman
22:58:48 <dons> I think I could live with (nd be proud of using) xmonad
22:58:55 <dons> and it'd suck in anyone who was into FP.
22:59:06 <sjanssen> dmwit_: that's a program to handle gentoo portage overlays
22:59:13 <glguy> window manager is so typically... window *supervisor* however
22:59:16 <dmwit_> Bummer.
22:59:33 <glguy> lazywm
22:59:47 <sjanssen> dons: http://www.e-pig.org/darcs/rxr/xmonad/XMonad.hs -- ever seen this?
22:59:53 <dons> yeah. just found it.
23:00:06 <dons> i'm sure conor won't mind.
23:00:48 <sjanssen> it just looks like an internal module, anyway
23:00:56 <dons> yep.
23:01:10 <dons> how about it then? "xmonad" ?
23:01:14 <sjanssen> okay, time to switch to xmonad
23:01:18 <dons> yay
23:01:25 <dons> i'll move the W monad stuff to X now.
23:01:48 <dmwit_> So, I'm trying to write getNthPrime :: Int -> State SType Int.
23:01:57 <dmwit_> Is that a reasonable signature?
23:02:21 <sjanssen> dons: and I'll exterminate all mentions of thunk
23:02:27 <dons> great.
23:03:29 <dmwit_> Err... type SType = (Map Int Int, [(Int, Int)]) holds the current memoized results and an association list of not-yet-memoized primes.
23:04:03 <dons> ok. sjanssen, renamed all to X and XMonad.
23:04:34 <dons> sjanssen: do you want to move sjanssen/public_html/thunk to sjanssen/public_html/xmonad ?
23:04:45 <glguy> > let getNthPrime = (nubBy ((.)(==0).flip mod) [2..] !!) in getNthPrime 10
23:04:47 <lambdabot>  31
23:05:29 <sjanssen> dons: will do
23:05:48 <dmwit_> glguy: I _know_ I don't need all the sophistication.
23:05:57 <dmwit_> I'm just trying to explore the State monad...
23:06:17 <sjanssen> dons: done
23:06:48 <glguy> > let getNthPrime = (!!) . flip nubBy [2..] $ (.)(==0).flip mod in getNthPrime 10
23:06:50 <lambdabot>  31
23:08:17 <sjanssen> @where+ thunk thunk is now known as xmonad
23:08:18 <lambdabot> Done.
23:08:34 <sjanssen> @where+ xmonad darcs get http://darcs.haskell.org/~sjanssen/xmonad
23:08:35 <lambdabot> Done.
23:08:53 <glguy> ?where lazywm
23:08:54 <lambdabot> I know nothing about lazywm.
23:08:56 <glguy> :(
23:09:36 <dons> sjanssen: I wonder if we can put a page up at haskell.org/xmonad ?
23:10:03 <dons> (I should work this out actually, in order to move all my cse stuff to h.o)
23:10:33 <sjanssen> this is a bit of a grey area
23:11:08 <sjanssen> we need forge.haskell.org!
23:11:39 <dons> yeah. bringert's hask-home idea for hackage.hsakell.org
23:11:42 <dons> for project hosting
23:12:21 <petekaz> I'm very excited at the moment.  A couple months ago I wrote my first haskell to summarize the contents of a Maildir (the mailbox format).  But tonight, I rewrote it (took me a few hours) but I think its much nicer!  See here for both new and old: http://hpaste.org/902
23:12:38 <dons> good to know, petekaz !
23:13:02 <petekaz> I take a couple month hiatus from haskell as monads and using them was hurting my head.
23:13:06 <dons> don't like the do notation?
23:13:40 <dons> the code does look pretty good
23:13:47 <petekaz> I don't mind it, but in this case, I think having the previous line define a var, then just using it on the next is sorta ugly.  This reminds me of the point free style.
23:14:16 <petekaz> And even better, parsing a directory of 500+ emails used to take 13s, now it takes 3s.
23:14:31 <dons> oh, you're not even using bytestrings I see.
23:15:14 <petekaz> I should try that.
23:15:39 <dons> 500 mails doesn't sound like much, I'd expect you could use strict bytestrings and do rather well
23:16:01 <petekaz> My favorite part of my code was the 'fuzzy' definition (just taking advantage of HOF).  You should have seen the first version.
23:16:22 <petekaz> or rather how I use it.
23:16:52 <dons> i'm using 'xmonad' now, sjanssen  :-) yay.
23:17:24 <dons> sjanssen: I notice that we start using the same space on the heap as dwm (about 1.2M), but that grows to about 2.6M and stabilises.
23:17:35 <dons> dwm does allocate everything pretty much statically though
23:17:42 <dmwit_> Rrrrr, I had the monad part right, and the Map.lookup part wrong. =(
23:17:56 <dons> and its event space is allocated only once, (while we have to copy and GC)
23:18:14 <dons> still, uses about the heap of xterm.
23:19:03 <sjanssen> can you simulate key and button presses in X11?
23:20:16 <sjanssen> eventually we should work out a way to script intensive X sessions, to get nice profiling data
23:23:30 <dons> yeah. so i've done some profiling (and it all looks very good)
23:23:56 <dons> but i want to use QC to stress test the entire thing. and as you say, do some blackbox stress testing
23:24:52 <sjanssen> even simulating the X server and clients?
23:27:57 <zeeeee> 'reentrance' == 'purity'?
23:29:42 <ibid> no
23:31:39 <sorear> hi.
23:31:57 <sorear> man I've caught the masochism bug this time ...
23:32:09 * sorear is writing an entire Haskell frontend.  In C.
23:32:15 <jcreigh> why?
23:32:32 <fax> in C :/
23:32:36 <sorear> shim (GHC-API) is too slow, and hugs is ... hugs
23:32:50 <fax> but dont write it in C :/
23:32:51 <sjanssen> sorear: I was wondering why you've been quiet lately . . .
23:33:00 <sorear> I think it can be faster if all support for codegen is left out
23:33:15 <sorear> sjanssen: I've discovered I code faster disconnected :)
23:33:28 <sjanssen> sorear: certainly true
23:34:02 <sjanssen> does GHC-API always perform operations related to code generation?
23:34:12 <sorear> no
23:34:29 <sjanssen> in what way is it slow?
23:34:43 <sorear> but eg. the typechecker needs to generate System-FC stuff still, even if the phases that need it never run
23:34:52 <zeeeee> ibid: what's the difference?
23:34:58 <sorear> sjanssen: uh, 10+ secs after every change
23:35:18 <zeeeee> i take it that pure => reentrant, but does reentrant => pure?
23:35:18 <sorear> ndm uses Hugs because it is faster, even with the whole Hugs error messages thing
23:35:41 <sjanssen> so you want to write parser + type checker
23:35:48 <sorear> yeah
23:36:32 <sorear> well, renaming too, but it seems simplist to do that in the parser
23:36:44 <sorear> (since we already need fixity info)
23:36:49 <narain> ?instances Ord
23:36:50 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
23:38:35 <sjanssen> dons: where is that line counting utility?
23:39:12 <bos> could people please take a look at http://darcs.serpentine.com/network6/docs/Network-BSD.html ?
23:39:21 <sorear> sjanssen: sloccount?
23:39:40 <sjanssen> sorear: I find sloccount annoying
23:39:43 <bos> this is the IPv6 support i've been working on.
23:39:46 <sorear> bos: it looks like haddock output?j
23:39:54 <sjanssen> sorear: dons has a homemade tool
23:40:08 <bos> sorear: yes
23:40:12 <sorear> sjanssen: ah ok.  can't help you then :)
23:40:27 <bos> i want to be sure that (a) the haddocks are clean and (b) the new documentation is up to snuff.
23:40:38 <bos> oh, and that the APIs make sense.
23:40:57 <bos> so the two functions you want to look at are getAddrInfo and getNameInfo.
23:41:22 <bos> all of the old IPv4 cruft is still there, but the haddocks now say "don't use me!"
23:41:46 <jcreigh> hmm, what's the easiest way to read out of a C struct from Haskell?
23:41:48 <bos> the actual darcs repo is at http://darcs.serpentine.com/network6
23:41:49 <lambdabot> Title: Index of /network6
23:42:00 <bos> jcreigh: there isn't an easiest way.
23:42:01 <sorear> jcreigh: hsc2hs
23:42:09 <sorear> jcreigh: (standard way)
23:42:10 <bos> use hsc2hs and read up on the FFI.
23:42:32 <ibid> zeeeee: no, not all reentrant functions are pure
23:42:44 <bos> you'll be implementing the Storable typeclass, writing peek and poke.
23:42:54 <zeeeee> ibid: that's what i suspected, but can you explain?
23:43:25 <sjanssen> jcreigh: I recommend you use a tool like hsc2hs
23:43:37 <jcreigh> okay, thanks everyone, I'll look into hsc2hs
23:43:44 <sjanssen> @quote stereo
23:43:44 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
23:44:13 <ibid> zeeeee: a reentrant function can depend on the program state. consider the (nonstandard) C library function strtok_r
23:44:40 <ibid> zeeeee: given the same arguments, it will return different stuff different times
23:44:50 <ibid> zeeeee: but it still is reentrant
23:45:08 <dons> sjanssen: http://www.cse.unsw.edu.au/~dons/tmp/count_lines
23:45:36 <dons> the tools is actually from ghc's utils
23:45:54 <bos> is there a way to turn a pile of darcs patches into one?
23:46:03 <zeeeee> ibid: that seems to disagree with wikipedia..
23:46:19 <dons> bso, hmm. unrecord and record ?
23:46:22 <ibid> zeeeee: how so?
23:46:27 <dons> bos, but why bother, just send it as a bundle
23:46:30 * lispy was thinking strtok was not reentrant
23:46:39 <zeeeee> ibid: "must work only on the data provided to it by the caller"
23:46:49 <jcreigh> lispy: that's why they wrote strtok_r
23:46:51 <ibid> zeeeee: strtok_r does that
23:46:53 <bos> dons: i'm trying tp figure out the best way to get my ipv6 stuff reviewed for inclusion into upstream network
23:46:55 <dons> sjanssen:                       Code  Comments
23:46:55 <dons> Main.hs                 181    115
23:46:55 <dons> StackSet.hs              54     93
23:46:55 <dons> XMonad.hs                29     42
23:46:56 <dons> TOTAL:                  264    250
23:47:05 <ibid> lispy: note i was talking about strtok_r :)
23:47:10 <dons> bos, ok. you propose a patch to libraries@
23:47:12 <bos> i thought one patch would be best, but if you don't think so, i'm all for not creating one :-)
23:47:18 <jcreigh> cue the "stereo" quote again. :)
23:47:23 <dons> one patch is also good.
23:47:25 <lispy> ibid: r for reentrant? ;)
23:47:30 <zeeeee> ibid: oh, i see now...i misunderstood strtok_r
23:47:37 <ibid> lispy: yes
23:47:46 <ivanm> dons: that count_lines program, does it work on Bird-style lhs files?
23:47:54 <dons> I think so (it calls unlit?)
23:47:57 <dons> or else you need to unlit first
23:48:07 <ibid> zeeeee: the key is that the function modifies one of its parameters in place :)
23:48:10 <zeeeee> ibid: the procedure can mutate the state of its parameters
23:48:11 <dons> would be a reasonable little exercise to rewrite it in haskell with proper support for .lhs
23:48:14 <zeeeee> right
23:48:16 <ibid> zeeeee: yep
23:48:36 <ivanm> dons: how do you unlit it?
23:48:44 <ivanm> because it said it couldn't unlit mine :(
23:49:48 <sjanssen> ivanm: you probably need to add unlit to your PATH
23:50:02 <ivanm> sjanssen: where do I get unlit from?
23:50:02 <sjanssen> or provide a suitable path within the script
23:50:35 <ivanm> @google unlit
23:50:38 <lambdabot> http://www.thefreedictionary.com/unlit
23:50:48 <ivanm> I don't think that's it :s
23:50:50 <sjanssen> /usr/lib/ghc-6.6/unlit over here
23:51:44 <ivanm> OK, found it
23:52:02 <fuzan> did ghc-6.6 get masked in x-haskell?
23:52:50 <sjanssen> fuzan: you're a gentoo user?
23:52:58 <fuzan> sjanssen: aye.
23:53:32 <dons> it comes with ghc, iirc.
23:53:38 <ivanm> dons: what does the "not counted in a directory" error mean
23:53:41 <dons> but i've not investigated how to use it with count_lines
23:53:46 <dons> no idea.
23:53:47 <dons> :-)
23:53:55 <ivanm> isn't it your script?
23:53:58 <sjanssen> fuzan: ghc 6.6 has made it's way into the mainline tree, but it is in package.mask
23:54:00 <dons> (I'm not the author, not have I looked t the code much)
23:54:07 <ivanm> ahhh, OK
23:54:11 <ivanm> thought it was yours
23:54:54 <fuzan> sjanssen: i'm using the overlay.
23:54:58 <sjanssen> fuzan: in the future, you should consider asking these questions in #gentoo-haskell (qualified people pay attention there)
23:55:29 <sjanssen> fuzan: the package.mask in the main portage tree also masks the package in the overlay
23:56:00 <fuzan> sjanssen: it must have been added to the main tree then
23:56:20 <fuzan> yup.
23:56:29 <fuzan> that's pretty darn annoying
23:56:48 <fuzan> i get more excited when someone says something in gentoo-haskell than when a lunar eclipse occurs.
23:56:49 <sjanssen> yeah, sucks that emerge applies the contents of package.mask to overlays
