00:01:21 <dataangel> omnId: You mean that it doesn't just have to be IO a? Yes :)
00:01:43 <Cale> yrlnry: I needed this because I was implementing the ring of polynomials in arbitrarily many indeterminates, which you can think of as the monoid ring constructed over the monoid of partitions under concatenation.
00:01:46 <hpaste>  Mitar pasted "Parser" at http://hpaste.org/3253
00:01:58 <dataangel> omnId: Even if I'd been right and it wrapped return around the rhs, I know that return is defined on a per-monad basis :)
00:02:01 <Cale> (partitions of an integer)
00:02:11 <Mitar> what's wrong with this parser so that it cannot parse foo[123]
00:02:33 <omnId> dataangel: though the monad laws *require* that returning a value into a monad and binding it back out *must not change it*!
00:03:01 <omnId> if a type breaks that law, it's not a correctly implemented monad.
00:03:03 <Cale> I also wanted another monoid ring, the so-called plactic ring, whose monoid is the set of Young tableaux under Schensted multiplication.
00:03:03 <hpaste>  Mitar annotated "Parser" with "error message" at http://hpaste.org/3253#a1
00:03:22 <omnId> it'd be like implementing a number where (a) and (a + 0) equal two different things!
00:03:30 <dataangel> omnId: or more practically won't interoperate with any code that expects a correctly implemented monad ;)
00:03:42 <Cale> The nice thing is that you get all these almost for free from this definition, just by specifying the underlying monoid.
00:04:14 <hpaste>  Cale annotated "Monoid rings." with "missing imports" at http://hpaste.org/3252#a1
00:05:03 * dataangel smiles and blinks too much
00:05:18 <omnId> ;)
00:05:35 <Cale> dataangel: Don't worry, I do it too :)
00:05:44 <omnId> (:
00:06:04 <omnId> .^.
00:06:19 <dataangel> O_o
00:06:26 <Syzygy-> ·v·
00:06:55 <Cale> ◐_◐
00:07:04 <Cale> ◑_◑
00:07:35 <Cale> ◑_◐
00:07:45 <omnId> smiley fight! ಠ_ಠ
00:08:46 <Cale> ◎◡◎
00:09:04 <dataangel> What's the reasoning behind having n+k patterns?
00:09:12 <omnId> ¯\(°_o)/¯
00:09:16 <dataangel> Googling is just giving me lots of things saying, "they're bad"
00:09:39 <omnId> simulating naturals with (n+1) I guess
00:09:50 <Cale> omnId is right
00:09:57 <Cale> That's exactly what it's there for.
00:10:24 <dataangel> how does it help you simulate n+1 ?
00:10:37 <dataangel> why not just define for n?
00:10:41 <omnId> n+1 allows you to simulate a Natural type
00:10:52 <omnId> data Natural = Zero | Succ Natural
00:10:56 <dfranke> dataangel: Wikipede "Peano Axioms"
00:11:15 <omnId> so (x + 1) is like (Succ x)
00:11:21 <omnId> (as patterns)
00:12:57 <omnId> @wikipedia peano axioms
00:12:59 <lambdabot> No Result Found.
00:13:30 <sixteencharslong> hmm, 16 is too many
00:13:44 <dataangel> hmm
00:13:49 * dataangel reads the wikipedia entry
00:13:58 <omnId> cool self-referential nick, 16
00:14:34 <sixteencharslong> whoa, it is!
00:14:39 <glguy> ;)
00:15:13 <dataangel> so if I write a function defined for 0 and for (n+1), and then pass it 5, does it run 0, succ(0), succ(succ(0)), etc., or is it simply going to run the n+1 version of the function with n=5?
00:15:22 <ninechars> :)
00:15:37 <omnId> vincenz got the drop on my by two seconds!
00:15:46 <glguy> that was my inspiration, actually
00:15:49 <glguy> err
00:15:56 <sixteencharslong> that was my inspiration, actually.
00:15:57 <Cale> Braille smiley! ⢌⣀⡡
00:16:11 <sixteencharslong> Oh look, a rainbow!
00:16:16 <sixteencharslong> oh, wait...
00:16:44 <omnId> dataangel: 5 = Succ $ Succ $ Succ $ Succ $ Succ Zero, so it'd run the Succ branch and presumably recurse.
00:16:49 <Cale> dataangel: It's going to run the n+1 version with n = 4
00:17:01 <ninechars> Cale: unigeek :)
00:17:04 <ninechars> or is it
00:17:11 <ninechars> uniweenie?
00:17:38 <dataangel> Cale: Then what's the point? Why not just start the function with let actualN = n -1 in ...
00:17:59 <dataangel> omnId: I'm not sure what you mean by run the succ branch, but it sounds like you're contradicting Cale
00:18:03 <sixteencharslong> ninechars: there's probably a unicode character for that
00:18:08 <Cale> dataangel: The point is to pretend that integers are really composed of Succ and Zero
00:18:18 <ninechars> sixteencharslong: for uniweenie?
00:18:22 <sixteencharslong> yeah!
00:18:22 <Syzygy-> Cale: Positive integers.
00:18:25 <Cale> So 5 is really S(S(S(S(S(0)))))
00:18:28 <ninechars> sixteencharslong: so in what font do you measure your 'length'?
00:18:34 <ninechars> that reminds me of this quote
00:18:34 <Cale> Syzygy-: of course
00:18:35 <ninechars> @quote ----
00:18:35 <lambdabot> erg0t says: <erg0t> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
00:18:37 <Syzygy-> I dare you to express -1 with that. :)
00:18:38 <ninechars> @quote ------
00:18:38 <lambdabot> erg0t says: <erg0t> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
00:18:39 <ninechars> @quote ------
00:18:39 <lambdabot> erg0t says: <erg0t> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
00:18:41 <ninechars> grr
00:18:44 <ninechars> @quote ------.* long
00:18:44 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
00:18:47 <ninechars> @quote |
00:18:47 <lambdabot> edwardk says: well, dependent types fuck with compilers ability to get anything done
00:18:53 <ninechars> doh
00:19:00 <sixteencharslong> dude... flooding is never appropriate ;)
00:19:13 <ninechars> I know
00:19:25 <omnId> dataangel: the Succ branch is the n+1 branch, so I'm saying the same as Cale.
00:19:32 <dataangel> I get that 5 is really S(S(S(S(S(0))))), but how is defining your function for n+1 instead of n anymore consistent with that?
00:19:36 <dataangel> omnId: ah
00:19:50 <Cale> dataangel: Because you'd define it for 0 and Sn for some n
00:20:04 <Cale> which is 0 and n+1
00:20:35 <Cale> のつの
00:20:43 <ninechars> aha!
00:20:45 <Cale> Hiragana smiley :)
00:20:49 <ninechars> sixteencharslong: coming back to it, which font?
00:20:51 <sixteencharslong> funny nose
00:20:52 <ninechars> quote \|---
00:20:57 <ninechars> @quote \|---
00:20:57 <lambdabot> glguy says: that's odd, mine is this big : |-----------------------------|
00:20:59 <omnId> dataangel: in order to do let actualN = n - 1 the (-) function would have to match on the Succ constructor in order to get one fewer.
00:21:06 <Mitar> can anybody check http://hpaste.org/3253#a1 ?
00:21:19 <sixteencharslong> ninechars: hey, you can't use my quotes against me!
00:21:20 <omnId> subtractOne (Succ x) = x
00:22:24 <omnId> for the Natural type
00:22:29 <ninechars> sixteencharslong: you're glguy?
00:22:40 <ninechars> glguy: so you shrunk in size?
00:22:47 <dataangel> omnId: typo, I meant let actualN = n + 1
00:22:55 <glguy> vincenz: apparently :)
00:23:29 <vincenz> > map length ["|-----------------------------|", "sixteencharslong"]
00:23:31 <lambdabot>  [31,16]
00:23:35 <vincenz> yeap, nearly half
00:24:57 <vincenz> 'lo bringert
00:25:12 <dataangel> I think I'm going to side with the naysayers on n+k.
00:25:28 <dataangel> but I guess I won't knock it till I've tried it ;p
00:25:34 <vincenz> n+k is useful
00:25:42 <vincenz> though granted, a bit of a corner case
00:25:46 <Syzygy-> What are the arguments against n+k?
00:25:51 <Pseudonym> I think that some kind of view pattern/pattern guard would be more useful.
00:25:52 <vincenz> it's a corner case?
00:25:54 <vincenz> and hello Syzygy-
00:25:56 <vincenz> long time
00:25:58 <Syzygy-> Hiya
00:25:59 <Syzygy-> Yah
00:26:03 <Pseudonym> It's a corner case in the syntax, for sure.
00:26:05 <vincenz> how's the theoretical math?
00:26:16 <Syzygy-> Alive and kicking
00:26:18 <omnId> dataangel: I think the big problem is that matching on an (n+k) pattern performs arbitrary evaluation on a pattern-match, where you wouldn't otherwise expect it.
00:26:23 <vincenz> Syzygy-: in what axiom system?
00:26:31 <vincenz> Syzygy-: I could simply take a different system and it'd be dead |
00:26:34 <vincenz> :|
00:26:49 <vincenz> "is the math system alive" almost becomes a schrodinger question
00:26:52 <glguy> omnId: any more than pattern matching on an other constructor?
00:26:58 <vincenz> "it depends on how you look at it and flatten the quantum waves"
00:27:32 <omnId> glguy: more in that it implicitly injects a call to subtraction.  I didn't say it was a strong argument.
00:27:47 <omnId> and a call to fromInteger 1
00:28:11 <dataangel> How does let work with pattern matching when you're dealing with a union type variable? It seems like you need to assign multiple vars potentially, but those would really need to be different 'in' blocks... but then you have a case statement
00:28:33 <omnId> dataangel: lets can only match on one constructor.
00:28:44 <omnId> > let Just () = Nothing in 1
00:28:46 <lambdabot>  1
00:28:51 <omnId> bah
00:28:54 <omnId> > let Just x = Nothing in x
00:28:55 <lambdabot>   Irrefutable pattern failed for pattern Data.Maybe.Just x
00:29:00 <omnId> silly laziness :)
00:29:10 <omnId> so you get a runtime error.
00:29:27 <dataangel> O_o
00:29:37 <omnId> use a case if you want to match multiple constructors
00:29:47 <dataangel> so basically, if you use a let to pattern match, and you're wrong about the pattern, you shoot yourself in the face :P
00:29:54 <Pseudonym> > case Just 3 of { Nothing -> 1 }
00:29:55 <lambdabot>   Non-exhaustive patterns in case
00:29:56 <omnId> basically, yes
00:30:19 <dataangel> so it only makes sense in situations where you can somehow divine what's in the union ahead of time
00:30:28 <glguy> What's this "union"?
00:30:37 <dataangel> I don't have enough experience yet to know how often that is
00:30:51 <dataangel> glguy: data blarg = foo | bar | zerbit -- union type of foo/bar/zerbit
00:30:55 <omnId> the difference there is that let bindings implicitly insert a ~, or irrefutable match.  So it just goes on none the wiser and only fails when the value is demanded.
00:31:07 <vincenz> Syzygy-: ping?
00:31:21 <omnId> glguy: multiple constructor datatype, I'd assume.
00:31:23 <dataangel> omnId: I'm not familiar with how you're using ~. I thought _ was an irrefutable match?
00:31:34 <glguy> I've just never heard it refered to as such
00:31:39 <Cale> ~ makes any pattern irrefutable
00:31:49 <omnId> dataangel: ~ allows you to do irrefutable match *with* inner bindings.
00:31:54 <Cale> single variables and _ are also irrefutable patterns
00:31:59 <dataangel> I thought #haskell was all academic-y? union datatype is the technical term I thought.
00:32:03 <omnId> > case Just 3 of { (~Nothing) -> 1 }
00:32:05 <lambdabot>  1
00:32:14 <Cale> dataangel: yeah, it's the correct term :)
00:32:21 <glguy> hm, cool :)
00:32:22 <dataangel> omnId: @_@
00:32:29 <Cale> dataangel: Or sum type, perhaps even more properly
00:32:42 <Cale> dataangel: It's a disjoint union
00:32:55 <glguy> union inspires thoughts of C for me
00:33:25 <omnId> dataangel: when evaluation moves into the case and sees a ~ pattern, it assumes that it will succeed and goes to the rhs without bothering to evaluate the constructor.
00:33:30 <Syzygy-> Hmmmm?
00:33:34 <Cale> > let f (x,y) = 5 in f undefined
00:33:35 <lambdabot>  Undefined
00:33:37 <vincenz> Syzygy-: pm
00:33:38 <Cale> > let f ~(x,y) = 5 in f undefined
00:33:39 <lambdabot>  5
00:33:44 <dataangel> omnId: Can you explain how that line works? I'm confused why ~ is being combined with Nothing, if it means irrefutable match... I'm not sure how that functions differently from case Just 3 of { _ -> 1 }
00:33:51 <Cale> > let f ~(x,y) = x+y in f undefined
00:33:52 <lambdabot>  Undefined
00:33:59 <omnId> dataangel: it isn't, in this case.
00:34:16 <dataangel> omnId: Why is the Nothing there? If ~ says irrefutable, shouldn't the constructor not matter?
00:34:28 <omnId> dataangel: you are correct.
00:34:31 <Cale> dataangel: It'll just accept the pattern without doing the evaluation, and only evaluate later when one of the variables bound is needed
00:34:39 <Cale> It's also known as a lazy pattern match
00:34:51 <dataangel> > case Just 3 of { (~) -> 1 }
00:34:51 <lambdabot>  Parse error
00:35:01 <omnId> dataangel: the example isn't the best :)  Usually one binds sub-patterns within the ~pattern.
00:35:17 <omnId> > case Nothing of { Just x -> 1 }
00:35:18 <lambdabot>   Non-exhaustive patterns in case
00:35:22 <omnId> > case Nothing of { ~(Just x) -> 1 }
00:35:23 <lambdabot>  1
00:35:32 <omnId> > case Nothing of { Just x -> x }
00:35:34 <lambdabot>   Non-exhaustive patterns in case
00:35:37 <sioraiocht> no one is #ocaml talks
00:35:38 <omnId> > case Nothing of { ~(Just x) -> x }
00:35:39 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just x)
00:35:41 <sioraiocht> *in
00:35:57 <Pseudonym> > fix (\(as,bs)  -> (1 : bs, 2 : as))
00:35:58 <lambdabot>  Exception: <<loop>>
00:36:03 <Pseudonym> > fix (\~(as,bs)  -> (1 : bs, 2 : as))
00:36:03 <lambdabot>  Parse error
00:36:09 <Pseudonym> Erm.
00:36:15 <glguy> needs a space after \ ?
00:36:16 <Mitar> no luck ...
00:36:17 <dataangel> I think I see
00:36:18 <Cale> > fix (\ ~(as,bs) -> (1 : bs, 2 : as))
00:36:19 <lambdabot>  ([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
00:36:24 <Pseudonym> That's it.
00:36:37 <Pseudonym> That's an example of how it's actually quite useful.
00:36:46 <Mitar> with http://hpaste.org/3253
00:37:04 <omnId> > fix (\ (as,bs) -> (1 : bs, 2 : as)) -- and without
00:37:05 <dataangel> so normally when a pattern match is done, it forces evaluation, so it can see which pattern to match against, but if you have ~ it says, just go ahead and use this match, don't evaluate yet. Why would you want to delay evaluation like that?
00:37:05 <lambdabot>  Exception: <<loop>>
00:37:16 <omnId> erm, Pseudonym already did that
00:37:22 * omnId should pay attention
00:37:29 <glguy> dataangel: the constructor could come from the computation itself
00:37:32 <dataangel> thus ~ doesn't work by itself because it still needs something to evaluate when the evaluation eventually comes
00:37:47 <glguy> dataangel: so you might not know the constructor until you've partially evaluated the thing you are matching
00:38:10 <omnId> GAH!  IT'S ALL RUNNING AROUND IN CIRCLES!!
00:38:13 <Cale> dataangel: well, it modifies the pattern which follows it in that way, so it doesn't mean anything on its own
00:39:06 <Cale> > let fibs@(_:fibs') = 0 : 1 : zipWith (+) fibs fibs'
00:39:06 <lambdabot>  Parse error
00:39:11 <Cale> > let fibs@(_:fibs') = 0 : 1 : zipWith (+) fibs fibs' in fibs
00:39:13 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
00:39:31 <Cale> That's also got a sort of ~ before it
00:39:46 <Cale> because pattern bindings have that automatically
00:40:08 <omnId> in that it modifies the pattern, but this @-pattern case isn't irrefutable!
00:40:09 <glguy> that doesn't really need a lazy pattern match , right?
00:40:27 <glguy> I mean, its a let binding, so it *is*
00:40:32 <glguy> but its not necessary for the example
00:40:35 * dataangel blinks
00:40:42 <omnId> erm, uh, yeah
00:40:51 * dataangel looks up what fix does
00:40:55 <Pseudonym> Erm... no, there's no sort of ~ there.
00:40:55 <glguy> ?src fix
00:40:55 <lambdabot> fix f = let x = f x in x
00:41:00 <omnId> fix f = f (fix f)
00:41:10 <omnId> = f (f (f (f (f (...)))))
00:41:17 <Pseudonym> It works because there are enough cons cells to match eagerly.
00:41:32 <glguy> Pseudonym: that's what I was getting to
00:41:54 <dataangel> glguy: can you give an example of what you meant about not knowing the constructor ahead of time?
00:42:14 <glguy> check out the tying the knot example on the wiki?
00:42:25 * dataangel goes to read
00:46:15 <dataangel> glguy: a search through the 3 versions of tying the knot show none of the versions use ~ except in comments
00:46:27 <dataangel> glguy: also, only the first version is really in my grasp at this point ;p
00:46:48 * dataangel searches for ~
00:48:39 <Pseudonym> TyingTheKnot is more about dynamic programming.
00:48:44 <Pseudonym> Which usually doesn't require !.
00:48:45 <Pseudonym> ~
00:48:52 <Pseudonym> The most common use is on fix/loop-like code.
00:50:35 <dataangel> @src fix
00:50:35 <lambdabot> fix f = let x = f x in x
00:51:42 * omnId wonders why whomever defined that used let instead of where
00:52:01 <omnId> @src cycle
00:52:01 <lambdabot> cycle [] = undefined
00:52:01 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
00:52:02 <Pseudonym> Why not?
00:52:16 <Pseudonym> @src loop
00:52:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:52:22 <Pseudonym> @src Control.Arrow.loop
00:52:22 <lambdabot> Source not found. Where did you learn to type?
00:52:28 <Pseudonym> @src (->) Control.Arrow.loop
00:52:28 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:52:45 <omnId> Just an idle wondering.  They're equivalent of course.  I just see where more often when there's a choice.
00:53:13 <omnId> @src repeat
00:53:13 <lambdabot> repeat x = xs where xs = x : xs
00:53:31 <dataangel> what do I have to import in order to get fix?
00:53:36 <omnId> @index fix
00:53:36 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
00:53:42 <omnId> first one.
00:53:48 <dataangel> it's a monad too? @_@
00:54:00 <omnId> nah
00:54:10 * dataangel experiences a gory cerebral explosion
00:54:25 <omnId> I guess fix was just written around the same time as mfix (which is a different beast)
00:55:04 <omnId> @quote paperwork
00:55:05 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
00:55:21 <omnId> oops
00:55:27 <omnId> someone get a mop!
00:56:10 <dataangel> I'm confused by fix
00:56:15 <dataangel> it only takes a function as a parameter
00:56:24 <dataangel> with no input for it
00:56:34 <dataangel> so shouldn't it just recurse forever into nothingness?
00:56:38 <omnId> it kinda passes it into itself
00:56:49 <omnId> and infinite recursion is no problem if you're lazy :)
00:57:07 <dataangel> true, but I don't see how infinite recursion is useful if you're not building a list
00:57:17 <lament> dataangel: it still takes an argument before it does anything
00:57:37 <lament> dataangel: no, but you are building a call stack :)
00:57:43 <lament> it's not infinite
00:58:40 <dataangel> now I'm really confused
00:58:48 <omnId> > fix (const 1) -- = const 1 (const 1 (const 1 (...))) = 1 (since const ignores the second param regardless)
00:58:50 <dataangel> > let mypow x = x ** 3
00:58:50 <lambdabot>  Parse error
00:58:50 <lambdabot>  1
00:59:10 <dataangel> > let mypow x = x ** 3 in fix mypow
00:59:11 <lambdabot>  Exception: <<loop>>
00:59:24 <dataangel> > fix (\x -> 1)
00:59:25 <lambdabot>  1
00:59:37 <dataangel> why does the first one loop forever, but the second evaluates instantly? @_@
00:59:49 <lament> dataangel: because mypow doen't have a "base case"
00:59:49 <omnId> x is ignored in the second
01:00:13 <omnId> the base case would tend to ignore the infinitely recursing part.
01:00:21 <dataangel> > fix (\x -> x ** 3)
01:00:23 <lambdabot>  Exception: <<loop>>
01:00:24 <dataangel> ah k
01:00:26 <lament> dataangel: where a "base case" is where the function doesn't evaluate its argument
01:01:31 <dataangel> omnId: I haven't seen const before. Does it just always return the first parameter without looking at the second? O_o
01:01:47 <omnId> @src const
01:01:48 <lambdabot> const x _ = x
01:01:52 <omnId> yep!
01:02:09 <omnId> "the constant x function"
01:02:12 <dataangel> haskell has a staggering number of functions that on the surface strike an imperative programmer as useless :)
01:02:30 <Pseudonym> And vice versa, I must say.
01:02:30 <omnId> const x always gives you x regardless of its parameter
01:02:40 <lament> hah!
01:02:47 <lament> dataangel: const is clearly useful, come on!
01:03:06 <Pseudonym> A few years ago, some great Lisp programmer went through "Design Patterns" and showed how many of them were TRIVIAL in Lisp.
01:03:18 <vincenz> meh
01:03:19 <vincenz> that's hard
01:03:21 <quicksilver> geocalc: no, I didn't. Busy busy.
01:03:24 <dataangel> lament: how? Why not just call it firstParamIdentity? :P
01:03:25 <Pseudonym> Without, of course, thinking about how many Lisp idioms are trivial in C++.
01:03:37 <omnId> blech
01:03:42 <Pseudonym> Like, say, thread-local mutable state.
01:03:42 <lament> dataangel: because 'const' makes a lot more sense?
01:03:48 <dataangel> Pseudonym: there are trivial things in C++? :P
01:03:59 <vincenz> dataangel: yes: segfaulting
01:04:04 <Pseudonym> Sure.
01:04:10 <omnId> @quote segfault
01:04:10 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
01:04:10 <Pseudonym> Mutable global state is trivial in C++.
01:04:12 <EvilTerran> dataangel, hemmoraging memory, for one
01:04:12 * dataangel is owned by vincenz
01:04:14 <Pseudonym> In Haskell, it's quite hard.
01:04:36 <dataangel> @quote feature
01:04:36 <lambdabot> olsner says: hmm, so perl basically has all harmful features ever invented?
01:04:47 <omnId> haha
01:04:48 <lament> aren't threads pretty trivial with mvars and stuff?
01:05:15 <lament> Control.Concurrent
01:05:19 <EvilTerran> my proglang lecturer spoke briefly of algol-68 yesterday; it reminded me of perl6
01:05:20 <Pseudonym> Gotta go.
01:05:21 <quicksilver> MVars and sensible abstractions built on them make concurrency much more manageable yes
01:05:21 <Pseudonym> Nytol!
01:05:24 <dataangel> lament: There's no assignment in haskell, so 'const' doesn't make any sense from that viewpoint... and from a math viewpoint.. well what do constants have to do with functions that take two parameters and return their first?
01:05:43 <quicksilver> from a math viewpoint it's a "constant function"
01:05:52 <lament> dataangel: no, no, no.
01:05:55 <quicksilver> but const is actually a 'constant function' generation
01:05:59 <omnId> (\x -> 1) is the constant 1 function, also written (const 1)
01:06:00 <lament> dataangel: 'const' takes _one_ parameter
01:06:01 <quicksilver> const generates constant functions :)
01:06:09 <dataangel> OH
01:06:11 <omnId> it's a function generator!
01:06:14 <dataangel> that's what I was missing :
01:06:15 <dataangel> :)
01:06:27 <lament> dataangel: all haskell functions take one parameter.
01:06:31 <quicksilver> Personall I normally write (\x -> 1) instead of (const 1) though
01:06:40 <quicksilver> I actually think that looks nicer :)
01:07:00 * omnId remembers, I think Logan, writing a neat matrix diagonal-taker with zipWith ($), id, and const 0
01:07:04 * EvilTerran can read "const" as \_-> anyway
01:07:08 <lament> quicksilver: however it has a dummy variable, that is, it introduces the symbol "x" to no purpose
01:07:15 <dataangel> I like the idea of making all values really be functions that return the value. Then we can try to examine the function type and explode :)
01:07:18 <lament> but \_-> works
01:07:33 <quicksilver> lament: not for 'no purpose'. For the purpose (in my biased and subjective opinion) of making it clearer
01:07:40 <mgsloan> dataangel: that's how I see values
01:07:41 <lament> dataangel: yes, you can think of it that way, too.
01:07:55 <EvilTerran> (zipWith.zipWith) ($) (iterate (const 0:) (id:repeat (const 0)))?
01:07:55 <quicksilver> lament: for example if I have a lot of functions on Particles, which I conventionally denote 'p'
01:07:59 <mgsloan> this is particularly supported by the polymorphic literals
01:08:05 <mgsloan> :t 42
01:08:07 <lambdabot> forall t. (Num t) => t
01:08:08 <quicksilver> lament: I'd rather write (\p -> False) than const False
01:08:21 <quicksilver> lament: because (\p -> False) says rather explicitly 'given any particle p return false'
01:08:25 <omnId> @let takeDiag xss = zipWith (zipWith ($)) diags xss where diag = iterate (id :) (const 0 : repeat id)
01:08:25 <lambdabot> <local>:4:37: Not in scope: `diags'
01:08:30 <quicksilver> even used variables can have useful commentary value
01:08:30 <omnId> @let takeDiag xss = zipWith (zipWith ($)) diags xss where diags = iterate (id :) (const 0 : repeat id)
01:08:34 <lambdabot> Defined.
01:08:37 <quicksilver> s/used/unused/
01:08:48 <omnId> > takeDiags [[1,2,3],[4,5,6],[7,8,9]]
01:08:49 <lambdabot>   Not in scope: `takeDiags'
01:08:53 <omnId> > takeDiag [[1,2,3],[4,5,6],[7,8,9]]
01:08:54 <lambdabot>  [[0,2,3],[4,0,6],[7,8,0]]
01:08:58 <omnId> oops
01:09:01 <dataangel> I'm still confused about how to actually use fix
01:09:02 <EvilTerran> omnId, you've got your ids and you const 0s swapped
01:09:08 <omnId> indeed
01:09:11 <EvilTerran> i pasted it above
01:09:11 <lament> quicksilver: yeah, that makes sense
01:09:28 <EvilTerran> i think i wrote it, although it was a while ago and i don't really remember
01:09:31 <lament> quicksilver: but haskell programmers like to think in the abstract :)
01:09:44 <omnId> @undefine
01:09:45 <lambdabot> Undefined.
01:09:47 <quicksilver> yeah. But I choose my abstractions carefully.
01:10:03 <quicksilver> And I eschew unneeded polymorphism.
01:10:08 <omnId> @let takeDiag xss = zipWith (zipWith ($)) diags xss where diag = iterate (const 0 :) (id : repeat (const 0))
01:10:09 <lambdabot> <local>:1:37: Not in scope: `diags'
01:10:18 <quicksilver> not that I necesarrily make the right choices every time :)
01:10:19 <EvilTerran> > (zipWith.zipWith) ($) (iterate (const 0:) (id:repeat (const 0))) [[1,2,3],[4,5,6],[7,8,9]]
01:10:21 <lambdabot>  [[1,0,0],[0,5,0],[0,0,9]]
01:10:21 * omnId is cursed by plurals
01:11:03 <EvilTerran> > catMaybes . (zipWith.zipWith) ($) (iterate (const Nothing:) (Just:repeat (const Nothing))) $ [[1,2,3],[4,5,6],[7,8,9]]
01:11:04 <lambdabot>  Couldn't match expected type `Maybe a' against inferred type `[c]'
01:11:14 <omnId> const is good for replacing some when you a modifying many
01:11:43 <dataangel> quicksilver: What's wrong with polymorphism? Haskell will still catch type snafus
01:11:45 <EvilTerran> > catMaybes . concat . (zipWith.zipWith) ($) (iterate (const Nothing:) (Just:repeat (const Nothing))) $ [[1,2,3],[4,5,6],[7,8,9]]
01:11:47 <lambdabot>  [1,5,9]
01:11:51 <omnId> map (const 0) zeroes a list
01:12:54 <takamura> hi
01:14:02 <quicksilver> dataangel: sometimes I want to be precise about my types. They are part of the interface and documentation to my code.
01:14:16 <quicksilver> dataangel: if the intended type of something is Particle -> Bool that is what I want it to be
01:14:29 <quicksilver> dataangel: no matter if, in fact, the definition I choose could be more polymorphic
01:14:48 <quicksilver> on the other hand, sometimes polymoprhism is a powerful part of the interface
01:14:52 <quicksilver> hence 'unneeded'
01:16:55 <takamura> i'm starting to use gtk2hs and have a question: windows (for example, a dialog window) can have a backaground image?
01:18:12 <takamura> background*
01:22:51 <wsdo_okadr> omnId: hi , where do you live ? and how are you awake at this hour ?
01:23:12 <omnId> ohio, boredom
01:23:57 <lament> er, too bored to sleep?
01:23:59 <omnId> @localtime wsdo_okadr
01:24:03 <lambdabot> Local time for wsdo_okadr is Fri Oct 12 11:24:00 2007
01:24:13 <dataangel> are there haskell bindings for QT?
01:24:34 <omnId> my internal clock is a little fast :)
01:24:44 <dataangel> google has people talking about autogenerating them "potentially" but maybe there's something in an svn somewhere?
01:27:38 <quicksilver> dataangel: i believe not
01:28:04 <dataangel> hrm, apparently linspire is rewriting their tools in haskell
01:28:10 <dataangel> and want to make kde/qt bindings
01:28:19 <dataangel> but no other mention than an initial announcement
01:28:30 <quicksilver> binding a C++ library is never entirely straightforwards
01:29:39 <quicksilver> because of ABI issue
01:29:53 <dataangel> doesn't GCC have a stable C++ ABI now?
01:30:09 <quicksilver> perhaps, but the haskell FFI doesn't support it
01:30:24 <quicksilver> at best you'd have to mangle the symbols yourself :)
01:30:36 <dataangel> oooh fun.... >_<
01:30:41 <glguy> The Haskell FFI doesn't or the GHC implementation doesn't implement that optional part of the spec?
01:30:50 <EvilTerran> might be able to do something with c2hs
01:31:01 <EvilTerran> although it still wouldn't be pretty
01:31:07 <dataangel> whoa, fix + non-recursive functions = turing complete? @_@
01:31:23 <quicksilver> dataangel: you'd use a C++ compiler to compile a thin C wrapper
01:31:30 <quicksilver> that is a wrapper using C calling conventions
01:31:42 <quicksilver> in principle, you'd automate that, because Qt is one hell of a big API
01:31:52 <EvilTerran> yeah. let's have a cxx2hs!
01:31:58 <hpaste>  vincenz pasted "Monoidal Binads" at http://hpaste.org/3254
01:31:58 <quicksilver> it may be that some other foreign-Qt project has already done the hard work
01:32:09 <quicksilver> I'm not sure what other foreign bindings there are for Qt
01:32:19 <dataangel> python and java
01:32:22 <omnId> > fix (\factorial x -> if x == 0 then 1 else x * factorial (x-1)) 5
01:32:24 <lambdabot>  120
01:33:05 <EvilTerran> dataangel, indeed. it's a big part of what makes fix so interesting
01:33:07 <dataangel> I take it to prove that fix + non-recursive = turing complete, I'd need to know the church in church-turing rather than the turing :P
01:33:27 * dataangel has gone through Sipser, which only does turing machines
01:33:33 <EvilTerran> in such things as combinatorial logic and \calc and whatnot, anyway
01:33:54 <quicksilver> dataangel: it's not hard to prove that fix === recursion
01:33:55 <omnId> (\x -> x x) (\x -> x x)
01:34:08 <quicksilver> dataangel: if you are prepared to accept that recursion is turing complete
01:34:16 <quicksilver> the small step from fix to recursion both ways is easy
01:34:57 <quicksilver> you can rewrite any arbitrary recursive function using fix
01:34:57 <quicksilver> (as non-recursive)
01:35:45 <dataangel> is fix-point's point the point in "point free programming" ?
01:35:53 <quicksilver> no
01:35:57 <EvilTerran> and going the other way is a no-op, unless you want to get it into something simply typed
01:35:58 <omnId> point point point
01:36:00 <Cale> yes, it is
01:36:13 <quicksilver> well, ok, it is if you think very clearly
01:36:19 <vincenz> :D
01:36:22 <quicksilver> but it's not immediately equivalent
01:36:24 <pejo> EvilTerran, we don't like the pesky types thing anyways!
01:36:25 <vincenz> nice save :P
01:36:26 <Cale> They both refer to geometric points :)
01:36:34 <quicksilver> the 'points' in 'point free programming' are about actual values
01:36:38 <quicksilver> \x -> f x
01:36:42 <quicksilver> ^^ mentions the 'value' x
01:36:45 <quicksilver> f
01:36:47 <vincenz> quicksilver: was that the "hmm, not certain, but Cale said it so it's bound to be true" escape?
01:36:47 <quicksilver> ^^ doesn't
01:36:54 <quicksilver> vincenz: precisely
01:37:05 * omnId knows that one well
01:37:06 <quicksilver> vincenz: but seriously, the points you are fixing over in fix are indeed values, so it is the same
01:37:14 <vincenz> roight
01:37:15 <EvilTerran> @src fix
01:37:16 <lambdabot> fix f = let x = f x in x
01:37:16 <Cale> quicksilver: A fixed point of a function is a point which it doesn't move.
01:37:17 <quicksilver> vincenz: the 'points' are 'values of types'
01:37:21 <vincenz> I wasn't arguing
01:37:24 <quicksilver> :)
01:37:25 <EvilTerran> look ma, explicitly named parameters!
01:37:32 <Cale> That is, a point x such that x = f x
01:37:56 <vincenz> one is a value point
01:37:59 <vincenz> the other is a variable point
01:38:04 <omnId> for f = (\x -> 1), 1 = (\x -> 1) 1
01:38:04 <vincenz> point free programming: no variables
01:38:30 <dataangel> yeah I read that it was no variables somewhere
01:38:38 <dataangel> I haven't looked at how that actually works yet though
01:38:41 <qwe1234> lol
01:38:42 * dataangel is still trying to grok fix
01:38:56 <EvilTerran> point free programming's like combinatorial logic, pointful's more like \calc
01:39:03 * omnId had a slight heart attack at qwe until he noticed the /nick
01:39:04 <EvilTerran> they're all equivalent in the end, but in terms of style
01:39:11 <qwe1234> :o)
01:39:11 * mgsloan too
01:39:16 <qwe1234> lol
01:39:19 --- mode: ChanServ set +o glguy
01:39:25 * mgsloan was about to scream "bannage!!"
01:39:26 <glguy> damn you!
01:39:38 <EvilTerran> wut?
01:39:46 <omnId> qwe1234
01:39:46 <dataangel> he hates operator status? :P
01:39:50 <omnId> he is a celebrity
01:39:50 <jeffz> who's the other qwe?
01:39:51 <LeCamarade> :o) I dreamt of qwe1234 and worke up screameing.
01:39:55 <matveev> Hi, since you are anyway talking about fix maybe you'll explain the meaning/purpose of this: IOExts.fixIO ( \result -> peek address)
01:40:05 --- mode: glguy set -o glguy
01:40:17 <glguy> that's the second time I've missed my chance at kicking *someone* named qwe1234
01:40:38 <EvilTerran> @quote qwe1234
01:40:38 <lambdabot> qwe1234 says: you forgot the fact that ocaml is used for writing real software that solves real problems, unlike haskell.
01:41:45 <lament> @quote qwe1234
01:41:46 <lambdabot> qwe1234 says: the problem is that ocaml has mandatory garbage collection.
01:41:51 <lament> @quote qwe1234
01:41:51 <lambdabot> qwe1234 says: it all boils down to standard first-year university-level computational theory.
01:41:57 <lament> @quote qwe1234
01:41:58 <lambdabot> qwe1234 says: oh come on, what do 'functional languages' have to do with lambda calculus?
01:42:04 <omnId> BAHAHAHA
01:42:05 <lament> haha
01:42:07 <lament> @quote qwe1234
01:42:07 <lambdabot> qwe1234 says: stfu, troll.
01:42:12 <lament> i see...
01:42:22 <LeCamarade> :o)
01:42:31 <vincenz> he's classic
01:42:32 <omnId> famous on reddit
01:42:32 <vincenz> @proton
01:42:32 <lambdabot> what is so good about continuations/
01:42:34 <vincenz> @proton
01:42:34 <lambdabot> how is smalltalk different from haskell?
01:42:36 <vincenz> @proton
01:42:36 <lambdabot> or does it become a mishmash of code?
01:42:38 <vincenz> @proton
01:42:39 <lambdabot> I am banned from like 6 rooms
01:42:41 <vincenz> @proton
01:42:41 <lambdabot> hakell is not lisp or ml right?
01:42:45 <vincenz> @proton
01:42:45 <lambdabot> so this java guy I know says that java is the best when things get really complex and u need your apps do do real work
01:42:50 <omnId> okay okay!
01:42:52 <lament> hahaha
01:42:52 <omnId> geez
01:42:56 <glguy> 6 times is enough
01:43:01 <omnId> is @proton qwe?
01:43:03 <glguy> no
01:43:04 <vincenz> it was 6 :)
01:43:05 <lament> @. elite proton
01:43:05 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "proton"
01:43:07 <vincenz> @keal
01:43:07 <lambdabot> i think it because mathematics damage you cpu
01:43:10 <vincenz> @keal
01:43:10 <lambdabot> will it return [] if map gives fpu infinite list?
01:43:13 <vincenz> @keal
01:43:13 <lambdabot> all i know is i have experienced my own death unhappening...
01:43:16 * glguy is going to get to start kicking
01:43:19 <vincenz> ok ok
01:43:21 * vincenz shuts up
01:43:25 <vincenz> it's silent here
01:43:32 <glguy> and I'm trigger happy
01:43:37 <vincenz> like this
01:43:38 <glguy> qwe1234 was pulled out from under me!
01:43:39 --- mode: ChanServ set +o vincenz
01:43:40 <vincenz> ?
01:43:43 --- mode: vincenz set -o vincenz
01:43:47 <lament> ban!!!!!!!
01:43:49 <glguy> yeah, like that!
01:43:57 * vincenz has a BIG RED BUTTON for that
01:44:01 <LeCamarade> Kick match! Kick 'til one drops.
01:44:03 <dataangel> Is fix related to the y-combinator?
01:44:10 <lament> yes.
01:44:12 <vincenz> dataangel: yes
01:44:15 <LeCamarade> Rumble in the Freenode - Rope-a-Dope.
01:44:15 --- mode: ChanServ set +v vincenz
01:44:17 <omnId> Y is an fixpoint combinator
01:44:26 <omnId> not typeable in Haskell
01:44:32 <vincenz> bastards
01:44:40 <vincenz> Odd, I kept a voice..
01:44:47 <dataangel> omnId: So you would say the Y combinator is specific version of the fix operator or ... ?
01:45:02 <EvilTerran> fix and Y are both fixedpoint combinators
01:45:05 <omnId> Y and haskell's fix both give fixed points of a function
01:45:05 <vincenz> dataangel:  a speciic implementation
01:45:11 <dataangel> omnId: Not typeable as in can't be typed out, or can't be given a type?
01:45:23 <dataangel> ah k
01:45:26 <vincenz> not typeable = can not typecheck
01:45:36 <EvilTerran> however, haskell's fix is recursive, so unsuitable for faking recursion in a non-recursive language
01:45:38 <vincenz> it leads to infinite types
01:45:47 <EvilTerran> and Y can't be given a finite type in haskell
01:46:14 <LeCamarade> System Fc has the same limitations, right?
01:46:26 <vincenz> though you could give it a finite type...
01:46:28 <vincenz> in a more generic system
01:46:45 <vincenz> what's the expansion of y's type again?
01:46:48 <dataangel> What constitutes a 'finite type' ?
01:47:01 <vincenz> let b = (b -> a)
01:47:02 <EvilTerran> dataangel, one that can be expressed, er, finitely
01:47:18 <vincenz> that can be expressed finitely :), just need sharing and let-recursion in the typelevel :P
01:47:22 --- mode: ChanServ set -v vincenz
01:47:24 <dataangel> I think I understand fix now
01:47:35 <dataangel> at least the fix f = f (fix f) version
01:47:49 <vincenz> > fix show
01:47:51 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
01:47:53 <LeCamarade> dataangel: T1 :: (T1 -> T2) -> T3 is infinite, because it needs to exist before it is expressed (before it exists, that is).
01:48:10 <vincenz> otherwise said
01:48:11 <omnId> Y = \f -> (\x -> f (x x)) (\x -> f (x x)) -- according to wikipedia
01:48:20 <vincenz> substitution will infi-loop
01:48:30 <vincenz> @type \f -> (\x -> f (x x)) (\x -> f (x x))
01:48:33 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
01:48:33 <lambdabot>     Probable cause: `x' is applied to too many arguments
01:48:35 <EvilTerran> (x x) is not permissible in haskell without using typeclasses
01:48:36 <matveev> FIX IN PRACTICE:  what is this IOExts.fixIO ( \result -> peek address) ???
01:48:44 <dataangel> you define your f to take a function as a parameter that will be the 'recursive' call, then call (fix yourfunc) to get recursion going
01:48:46 <EvilTerran> calm down, matveev
01:49:50 <dataangel> what I'm getting out of this is "fix is a hack when you don't have recursion" ;)
01:50:05 <EvilTerran> dataangel, you can also stick another layer in before you apply fix, eg memoisation or something
01:50:16 <EvilTerran> > fix (memoise f)
01:50:17 <lambdabot>   Not in scope: `f'
01:50:34 <EvilTerran> er, of course. i didn't mean that to > that...
01:50:55 <pejo> dataangel, fix is useful if you're working in a small (uncomplicated) calculus.
01:51:05 <dataangel> EvilTerran: oooh, that's nifty
01:51:12 <EvilTerran> dataangel, but yes, the original point of fixedpoint combinators was to show that a non-recursive languge could be as expressive as a recursive one
01:51:52 <dataangel> so recursive just means, referencing its own name. So if it happens to receive its own name as a parameter, that doesn't 'count' ?
01:51:55 <EvilTerran> dataangel, any other layer you want to add between calls works, too; keeping track of every recursive call, for instance, for a progress bar or something
01:52:00 <EvilTerran> indeed
01:52:33 <EvilTerran> in non-recursive languages, the definition of something can't refer to its own name, even indirectly
01:52:49 <omnId> dataangel: indeed, because in practice the function it recieves could be anything, but if you fix it, its parameter happens to be itself.
01:53:00 <dataangel> EvilTerran: Using it to stick memoization into a function would be nice, but then you have to be sure to have defined your function to call the passed function, rather than itself directly. Is there some magic for getting around that?
01:53:19 <EvilTerran> this is normally enforced by saying that a definition can only refer to definitions made strictly before it
01:53:45 <dataangel> omnId: Without the fix operator, in a non-recursive language, what stops you from just passing the function as a parameter to itself?
01:53:49 <EvilTerran> hm...  you can't guarantee that, no, but if someone's built their function to be fix'able, it'd be odd if you couldn't
01:53:57 <dataangel> oh nm
01:54:00 <dataangel> that would only work once :)
01:54:07 <omnId> :)
01:54:16 <EvilTerran> actually, if you write your function as "foo foo x = ...", the parameter foo will mask the function name foo in the body of the function
01:54:31 <EvilTerran> so you can't accidentally invoke the function directly
01:54:39 <wsdo_okadr> is OOP necessar for understanding properly haskell ?
01:54:51 <EvilTerran> and then (fix foo) would act like you'd just written "foo x = ..."
01:54:56 <omnId> wsdo_okadr: probably not :)
01:55:25 * glguy is trying to figure out what OOP is that leads to a meaningful sentence
01:55:25 <EvilTerran> wsdo_okadr, most definitely not; it might even cause confusion to learn OOP first, seeing as we have our own, distinct meanings for "class", "instance", et
01:55:26 <EvilTerran> c
01:55:36 <wsdo_okadr> omnId: probably ?
01:55:45 <omnId> wsdo_okadr: that was heavy sarcasm
01:55:47 * glguy failed at writting the meaningful sentence himself...
01:55:54 <wsdo_okadr> how can haskell be used well for REAL programming tasks ?
01:55:54 <wsdo_okadr> can it ?
01:55:59 <EvilTerran> glguy, I think it was "do i need to learn OOP to properly understand haskell?"
01:56:25 <omnId> wsdo_okadr: the module system gives you excellent control over names and allows implementation hiding
01:56:35 <EvilTerran> wsdo_okadr, it most definitely can; see http://haskell.org/haskellwiki/Haskell_in_industry etc
01:56:36 <lambdabot> Title: Haskell in industry - HaskellWiki
01:56:51 <omnId> polymorphism has more free style than most OOPs
01:57:12 <dataangel> unless your OOP does both, like C++ :D
01:57:42 <EvilTerran> haskell's type system is based on sound mathematical principles; in comparison, fitting a nice algebra to OOP is a relatively recent idea
01:57:53 <EvilTerran> so haskell's is more elegant ;)
01:58:08 <dataangel> template<int n> public Curious : public Curious<n-1> {}; // Noice :D
01:58:09 <osfameron> EvilTerran: I've not found the haskell definition of "class" to be much different from the OO one - at least, I can't see how comparing them would lead to big errors in understanding
01:58:29 <osfameron> "instance" is obviously different and therefore not confusing, just unfamiliar.
01:58:41 <EvilTerran> osfameron, well, a haskell class is always an abstract superclass...
01:58:43 <dataangel> osfameron: there's no state being encapsulated, and no access protection
01:59:08 <osfameron> just like in Perl :-)
01:59:08 <Cale> Haskell's class is closer to Java's interface
01:59:17 <EvilTerran> i only said *might* cause confusion, anyway
01:59:24 <Cale> (but still not the same thing)
01:59:26 <omnId> osfameron: a Java/C++ class is simultaeously a class of types that follow an interface (class), a concrete type with data members (data), and a declaration that the type belongs to the class (instance)
02:00:17 <omnId> the word "class" is justified since subtypes of that type can belong to the same class (i.e. support the function interface).
02:00:29 <dataangel> EvilTerran: I really like the idea of inserting stuff before the fix step
02:00:35 <dataangel> EvilTerran: It reminds me of python decorators
02:00:37 <EvilTerran> dataangel, yeah, it's pretty cool
02:00:43 <Cale> class is just another "set"-like word
02:00:54 <EvilTerran> doesn't happen that often in practice, but it's nifty that you *can*
02:01:14 <osfameron> can you fix non-recursive functions in that way?
02:01:15 <Cale> Which Haskell uses in thinking of type classes as essentially collections of types.
02:01:35 <dataangel> EvilTerran: But I wonder if python decorators work properly on recursive calls, since they're supposed to be syntactic sugar for assigning themselves to the decorator function being applied to them _after_ they're defined. Then again python is dynamic.. which makes it lazy about defs in a way...
02:01:48 <EvilTerran> Cale, yeah, it bugs me that there isn't a nice way of talking about a, er, plurality of stuff when talking to an abstract algebra guy
02:02:14 <Cale> EvilTerran: "collection" is nicely generic
02:02:16 <EvilTerran> "set? no, that's taken. group? no... class? category? ... "
02:02:18 <omnId> dataangel: is a decorator like a function transformer?
02:02:30 <EvilTerran> i'm half joking, anyway ;D
02:02:38 <dataangel> omnId: @foo def somefunc(): stuff()
02:02:42 <Cale> I'm aware of the problem ;)
02:02:44 <dataangel> omnId: foo is the decorator part
02:02:53 <EvilTerran> i quite like the term "plurality", actually
02:02:59 <omnId> what does foo's definition look like?
02:03:00 <Cale> Though usually I'll use the word "set"
02:03:02 <dataangel> omnId: It's syntactic sugar for defining somefunc, then afterwards doing somefunc = foo(somefunc)
02:03:31 <Cale> Because although it's taken, it's essentially a formalised version of dealing with pluralities anyway :)
02:03:32 <EvilTerran> dataangel, hmm... can foo introspect the definition of somefunc in that case?
02:03:35 <dataangel> omnId: So yes, it transforms the function, but the syntax is nicely declarative, so you can make a function logged for example by labeling it as such with an @logged at the top
02:03:35 <omnId> dataangel: in Haskell, just export somefunc = foo somefuncUndecorated, without exported the undecorated one.
02:03:51 <omnId> s/exported/exporting/
02:04:14 <omnId> dataangel: what does foo's definition look like?
02:04:22 <EvilTerran> dataangel, actually, i think i see how that'd work even for recursive calls in the dynamically-scoped case
02:04:33 <dataangel> EvilTerran: python has some introspection stuff but I haven't messed with it a whole lot. But without introspection you could still use it to do logging, memoization, and other stuff
02:04:51 <dataangel> omnId: any arbitrary function
02:05:23 <EvilTerran> omnId, probably something like foo (somefunc): { ...; someFunc () }
02:05:31 <EvilTerran> (except in valid python, naturally)
02:05:46 * EvilTerran has python on his todo list
02:05:57 <dataangel> decorators are one of my favorite python features ^^
02:06:01 <omnId> EvilTerran: I think it'd return a modified version of someFunc to replace the undecorated one
02:06:20 <EvilTerran> omnId, ah, yes, point.
02:06:22 <osfameron> are decorators just like wrappers?
02:06:26 <EvilTerran> @go python manual decorators
02:06:27 <Vq^> dataangel: tuples are one of mine :o)
02:06:29 <lambdabot> http://docs.python.org/ref/function.html
02:06:29 <lambdabot> Title: 7.6 Function definitions
02:07:05 <Vq^> osfameron: they are wrappers
02:07:08 <omnId> osfameron: they seem to be (a->b) -> (c->d) function transformers with a convenient syntax.
02:07:11 <dataangel> osfameron: sort of, you could have a decorator return an equivalent functor
02:07:40 <omnId> "functor" being something you can call like a function?
02:07:57 <EvilTerran> something with a __call__ method, iirc
02:08:06 <dataangel> omnId: Err, I'd say (a -> b) -> (a -> b) _usually_ is how it's used, but since it's a dynamically typed language (a->b) -> (c->d) is technically correct
02:08:19 <dataangel> omnId: Yes, something has the () operator overloaded
02:08:25 <dataangel> *that has
02:08:32 <EvilTerran> well, it's ((forall a.a) -> (forall a.a)) -> ((forall a.a) -> (forall a.a)) :D
02:08:39 <dataangel> lol
02:08:46 <omnId> dataangel: the type I gave is too general to have anything but _|_, the details weren't important, just the structure :)
02:08:49 <vincenz> id
02:09:12 <dataangel> I just mean, you don't usually use a decorator to transform a function into a function meant to interact with wholly different stuffs
02:09:31 <EvilTerran> well, if we were doing dynamic typing in haskell, there'd be a typeclass involved there (Typeable, for example), but still...
02:09:39 <dataangel> or well.. actually maybe that's not entirely true... I could see writing a decorator that handled converting one kind of parameters to a different kind or something
02:09:52 <omnId> (Dynamic -> Dynamic) -> (Dynamic -> Dynamic)
02:09:55 <dataangel> ;)
02:10:03 * dataangel <3 decorators
02:10:09 <omnId> > toDyn 1
02:10:12 <lambdabot>  <<Integer>>
02:10:16 <dataangel> I think it would be nifty
02:10:21 <dataangel> to be able to turn any recursive function
02:10:26 <EvilTerran> http://wiki.python.org/moin/PythonDecorators
02:10:28 <lambdabot> Title: PythonDecorators - PythonInfo Wiki
02:10:28 <dataangel> automagically into a fix'able function
02:11:14 <EvilTerran> dataangel, as i said, if you have access to the source of it, it's just a matter of adding a new first parameter with the same name as the original function. in the simple case, anyway.
02:11:31 <EvilTerran> if you've got mutually-recursive functions or whatever, it gets more fiddly
02:11:55 <dataangel> EvilTerran: right, but it'd be nice if things were just sort of automagically fixable
02:11:59 <dataangel> fixable by default I guess
02:12:17 <EvilTerran> so you could sneak things in between recursive calls and whatnot?
02:12:23 <dataangel> yeah
02:12:26 <dataangel> now that I think about it
02:12:27 <EvilTerran> i suspect that'd do terrible things to encapsulation
02:12:45 <dataangel> for a static language like haskell, I imagine you'd have to do that in order to support decorators
02:13:02 <LeCamarade> Can a comrade put the Haskell videos onto GeekTorrent.com (if it's okay, else ())?
02:13:29 <dataangel> or you'd have to scan through the function definition and replace any recursive calls with the decorator version of the func...
02:13:52 <vincenz> LeCamarade: doesn't type
02:14:29 <dataangel> you could make recursive functions be syntactic sugar for functions that took (fix f) as a parameter ;)
02:14:41 <omnId> dataangel: I don't see the need.  Afaict   @dec def fun: ...   is just short for   def hiddenfun: ... ; fun = dec hiddenfun
02:15:07 <omnId> er dec(hiddenfun)
02:15:25 <dataangel> omnId: python's dynamic'ness means you only need fun, no hiddenfun
02:15:36 <omnId> so?
02:15:42 <dataangel> just saying
02:16:17 <omnId> @dec ; def fun: ...   ->   fun = dec (\... -> ...)
02:16:17 <lambdabot> Maybe you meant: dice dict docs ghc let rc src
02:16:20 <LeCamarade> Can a comrade put the Haskell videos onto GeekTorrent.com (if it's okay else ())? -- That types.
02:17:16 <omnId> certainly parses, but there's an awful lot of not in scope.
02:17:39 <LeCamarade> But ... I was told monads (TM) solve that. (TM).
02:17:43 <LeCamarade> :o)
02:17:49 <omnId> U were told Rong
02:18:01 <omnId> monads (TM) aren't special
02:18:17 <omnId> cool, but not anything magic
02:18:41 <dataangel> omnId: I take it for the lambda there you're inserting the whole original definition of fun?
02:18:41 <vincenz> unsafeMagic
02:18:57 <omnId> dataangel: yeah
02:19:12 <omnId> fun = dec fun' where fun' = ... -- this too
02:21:20 <dataangel> omnId: I think there's still an advantage (although python doesn't support this AFAIK) in making recursive funcs syntactic sugar for passing fix f as regards decorators -- it lets you specify a decorator at call time, not just at function definition time, like in the fix (memoize f) example. We could @memoize def f, but then f is now defined as memoized.
02:23:05 <omnId> wait, f in nonrecursive and built for fixing?
02:23:26 <omnId> memoise takes such defs and inserts memoization?
02:23:38 <omnId> that is pretty cool.
02:23:44 <dataangel> omnId: I'm saying if you wrote f recursively, but that was just syntactic sugar for a nonrecursive function built for fixing that implicitly took (fix func) as its first parameter
02:24:01 <dataangel> omnId: actually I'm not sure, but EvilTerran seemed to use it that way :)
02:24:15 <dataangel> omnId: I can imagine such a decorator for python anyway ;p
02:24:21 <omnId> :)
02:24:32 <omnId> @. elite brain
02:24:33 <lambdabot> W31L, I 7hINk $0, 8raIN, buT 'apPLY NoRTH PO|E' +O W|-|A7?
02:24:51 <dataangel> lol, wut?
02:25:28 <omnId> 4R3 j00 p0/\/dEr1N6 wU+ I'm P()nD3r1nG?
02:25:46 <omnId> (leetspeak is tedious)
02:26:05 <dataangel> lamdabot should have an @l33t function
02:26:10 <omnId> @elite she does
02:26:11 <lambdabot> 5hE D03$
02:26:32 <Japsu> @. elite quote elite
02:26:32 <lambdabot> NO QuOTez0rz /\/\At(|-|. |Izt3n, BROCc0Li braIn5, I DoN'7 |-|aV3 tiM3 +0 1i5teN 7o 7|-|Iz trAsH.
02:26:43 <dataangel> zomgz it's 5:30AM
02:26:46 <omnId> heh heh
02:26:46 <dataangel> curse you haskell
02:26:56 <omnId> indeed it is
02:27:19 <dataangel> @elite I'm afraid I can't do that lambda
02:27:19 <lambdabot> i'm AFr4Id i c4n'T DO 7h4+ L4MBdA
02:28:10 <omnId> @. elite . elite elite pass it through three times
02:28:10 <lambdabot> pAZs0Rs i7 +|-|Rou9|-| 7HrE3 +i/\/\3z
02:28:34 * omnId should leave too
02:28:37 <omnId> 'night
02:28:55 <omnId> 'morning, whatever
02:32:52 <LeCamarade> @. elite . elite elite she does
02:32:52 <lambdabot> 5h3 do3z
02:33:01 <LeCamarade> @. elite . elite she does
02:33:01 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "she"
02:33:28 <LeCamarade> This here 'bot is quite advanced, eh?
02:33:43 <LeCamarade> Since nobody is watching ... ;o)
02:34:01 <qwe1234> @quote qwe1234
02:34:01 <lambdabot> qwe1234 says: sometimes i think lisp is as deadly to programmer competence as java or basic.
02:34:15 <qwe1234> lol i am on #haskell
02:34:39 <qwe1234> @karma+ qwe1234
02:34:39 <lambdabot> You can't change your own karma, silly.
02:35:01 <qwe1234> youre silly bot you need to be written in c++
02:35:13 <qwe1234> @karma
02:35:13 <lambdabot> You have a karma of 0
02:35:21 <qwe1234> lol
02:35:45 <dibblego> look who it is!
02:35:52 <qwe1234> \./ \o/ lol
02:36:07 <qwe1234> haskell is bondage and discipline. evil.
02:36:07 <dibblego> the most clueful person on the planet!
02:36:17 <qwe1234> im honoured
02:36:24 <dibblego> the honour is mine, sir
02:37:22 <qwe1234> snob? lol.
02:37:37 <qwe1234> go to #cplusplus and earn the honour
02:37:45 <dibblego> no no, I am honoured to be your presence, sir
02:37:56 <qwe1234> okay you can depart now
02:37:59 <qwe1234> lol
02:38:12 <dibblego> your knowledge of programming fundamentals awes me
02:38:20 <qwe1234> i came to fight with dons where is he
02:38:31 <qwe1234> and what kind of gun does he carry
02:38:33 <dibblego> I think he has better things to do
02:38:43 <matthew-_> like self-amputation
02:38:49 <qwe1234> haskell gave him carpal tunnel syndrome lol!
02:39:03 <dibblego> a programming language can do that?
02:39:04 <qwe1234> he misses templates
02:39:15 <qwe1234> *needs* templates
02:39:38 <ITS_NOT_QWE> cut it out, LeCamarade
02:39:42 <qwe1234> :-o
02:39:47 <matthew-_> um, you do no that the type classes that haskell has are VASTLY beyond templates in C++ right?
02:39:49 <qwe1234> :o(
02:39:57 <matthew-_> s/no/know/
02:40:03 <dibblego> matthew-_, don't be sucked in
02:40:08 <LeCamarade> :o(
02:40:24 <matthew-_> dibblego: it's alright, I'm about to leave to go to work anyway
02:40:32 <LeCamarade> Sorry, tout le monde.
02:40:55 <matthew-_> ahh, of course, the french are just on edge because they're going to loose to us on Saturday
02:41:12 <osfameron> at what?
02:41:17 <matthew-_> rugby
02:41:19 <LeCamarade> :o) I support the side that wins - the beer has to be drunk, in any case. ;o)
02:41:44 <osfameron> I support the beer, sod the sport.
02:42:12 <LeCamarade> @remember osfameron I support the beer, sod the sport.
02:42:12 <lambdabot> Done.
02:43:30 <LeCamarade> Is there a torrent of the Haskell Workshop videos anywhere?
02:43:42 <LeCamarade> I really need to fetch them on lo-traf.
02:44:19 <LeCamarade> And now that we have GeekTorrent ...
02:51:54 <AshyIsMe> how do i install the ghc package mtl?
02:52:15 <AshyIsMe> i'm trying to compile yi with gtk but i'm a little bit drunk
02:55:23 <quicksilver> you don't need to install it, it's part of ghc by default
02:55:39 <Lemmih> AshyIsMe: Using Debian?
02:55:43 <quicksilver> ah
02:55:50 <quicksilver> apt-get install libghc6-mtl-dev
02:55:53 <quicksilver> in that case :)
02:56:21 <AshyIsMe> Lemmih: ubuntu
02:56:22 <AshyIsMe> colo
02:56:25 <AshyIsMe> ool*
02:59:48 <matveev> any instances of (Storable a) => Storable [a] in the wild (or in standard libs)?
03:07:09 <quicksilver> matveev: StoreableArray and, in particular, withStoreableArray contains that kind of functionality
03:08:23 <matveev> i'll have a look
03:19:48 <ac> A well placed let to hold a partial application can make a world of difference in performance... like a factor of 10
03:20:32 <quicksilver> certainly can :)
03:23:25 <quicksilver> mux: was it you I was arguing with about dell?
03:24:15 <mux> quicksilver: we had some discussion about them yeah, you had some really bad experience with'em IIRC
03:24:34 <quicksilver> mux: you might be amused to read CosmicRay's post at the top of http://planet.haskell.org
03:24:35 <lambdabot> Title: Planet Haskell
03:24:37 <quicksilver> :)
03:24:55 <quicksilver> well, nearly top
03:26:38 <mux> hahaha
03:27:16 <ac> I was just reading "Type Level Instant Insanity" from an issue of The Monad Reader. It was interesting
03:27:36 <mux> quicksilver: sounds pretty bad indeed
03:27:42 <mux> quicksilver: I consider myself lucky for now
03:28:43 <quicksilver> mux: of course, that's only an anecdote. I'm sure I could trawl up some positive ones too :)
03:29:16 <quicksilver> ac: is that the rubix-cube-solver in the type system?
03:29:27 <mux> quicksilver: yeah, probably; in any case if I were to buy a laptop for myself (this one was bought by the company and I had no choice in the brand), I'd probably not go for a Dell :-)
03:29:55 <ac> quicksilver: yeah, they do solve a puzzle using exclusively the type system, but it's the "Instant Insanity" puzzle, far easier than a Rubick's cube
03:30:59 <quicksilver> ac: perhaps you could write up the rubik's cube in a similar way? :)
03:31:36 <ac> quicksilver: hmm. That sounds like an exercise in masochism
03:32:46 <ac> the article brought up too questions for me. The first question is how many other languages boast a type system within which you can write limited programs?
03:33:57 <johnnowak> ac: Qi has a turing-complete type system
03:34:00 <ac> And my second question, is could the type system be integrated more closely with the language, like how I presume Qi is
03:34:26 <matveev> quicksilver: there is no simple way to cast lists/strings to StorableArray provided by Data.Array.Storable. In fact the only constructor involves ForeignPtr wich looks like the road to hell to me
03:34:28 <ac> johnnowak: do you know much about how that works?
03:34:35 <johnnowak> ac: i've never used qi
03:34:46 <ac> johnnowak: yeah neither have I. I was hoping somebody knew something more about it
03:34:49 <AshyIsMe> gtk2hs takes a long time to compile
03:34:51 <johnnowak> ac: as for being more closely integrated, perhaps things like extensible variants/records are what you mean
03:35:07 <quicksilver> matveev: listArray
03:35:18 <quicksilver> matveev: or newListArray, I forget the exact name
03:35:27 <quicksilver> matveev: to construct the StorableArray from the list
03:35:42 <quicksilver> ac: haskell's type system is quite specifically non-turing-complete
03:35:56 <quicksilver> ac: GHC gives you access to turing-completeness if you turn on certain extensions though
03:35:59 <ac> quicksilver: is that to ensure termination?
03:36:07 <quicksilver> most people consider termination a virtue of a type system
03:36:10 <quicksilver> yes, exactly
03:36:24 <quicksilver> IIRC C++ templates are turing complete
03:36:29 <quicksilver> D templates definitely are
03:36:38 <quicksilver> someone wrote a raytracer in teh D type system
03:36:39 <ac> wouldn't it be nice to be able to specify arbitrarily precise qualities about your code using the type system?
03:36:45 <quicksilver> yes, very nice
03:36:52 <quicksilver> q.v. epigram and agda
03:37:06 * integral points at Coq and cringes
03:37:26 <mattam> why cringe ? You can program in Coq as well
03:37:52 <johnnowak> ac: designing a type system is an exercise in making endless tradeoffs
03:37:54 <pejo> mattam, a task that is far too complicated for us mere mortals.
03:38:40 <mattam> well, I think it can be simpler than in epigram and agda, I'm not comparing it to Haskell yet
03:38:56 <quicksilver> I think epigram is 'simpler' than Coq
03:39:07 <mattam> Proving is a different matter.
03:39:11 <quicksilver> it's a question of perspective
03:39:16 <johnnowak> ac: i personally prefer a system that can infer all types and can give clear, succinct type signatures that help me understand a program better very easily to one that can express the most fine qualities
03:39:20 <mux> dependent typing still makes my head hurt
03:39:29 <ac> johnnowak: What sort of tradeoffs do you suffer from making a more expressive type system? (note that I'm rather uninformed about matters such as type systems and proof assistants)
03:40:21 <mux> it's rather convenient to have decidable type checking :)
03:40:25 <johnnowak> ac: losing the ability to infer most/all types is a big one. haskell is perhaps rather close to the limit for what's inferable in a functional language.
03:40:40 <osfameron> 8///dcc
03:40:47 <mattam> You have to restrict your language and/or impose awkward (in my view) distinctions between types and terms.
03:40:59 <johnnowak> at least one based on application... concatenative languages have a lot to explore yet in terms of expressive type systems
03:41:00 <nornagon> ehh... how can I push a darcs repository to a remote host over ssh?
03:41:07 <nornagon> is the only option rsync?
03:41:30 <quicksilver> mattam: epigram does not distinguish between types and values
03:41:35 <swiert> nornagon: darcs push nornagon@host.bla.com:path/to/repos
03:41:36 <mattam> Inference is undecidable, but you can still get most of what Hindley-Milner gives you, ie: simply-typed programs don't need anotations.
03:41:53 <pejo> johnnowak, we seem to be quite happy to annotate stuff sometimes, so having a type inference that isn't complete, but sound, might be a compromise.
03:41:58 <swiert> (hi mattam btw)
03:42:02 <mattam> quicksilver: I mean if you go from a functional language to something with dependent types
03:42:15 <mattam> A functional language with partiality like Haskell
03:42:22 <mattam> hi swiert
03:42:23 * quicksilver nods
03:42:29 <ac> is it possible to create a type system in which general things are infered, but you can add more specific annotations if you want?
03:42:41 <johnnowak> pejo: that's certainly a possibility. would help with subtyping.
03:42:43 <quicksilver> yes, that's more or less what GHC gives you
03:42:49 <quicksilver> GHC permits rank-N types
03:42:49 <mux> if your term language is already quite expressive, and not strongly normalized and you add dependent typing, you necessarily end up with undecidable type-checking
03:42:54 <quicksilver> but only infers rank-1 types
03:42:56 <quicksilver> (for example)
03:42:58 <mux> that I understand
03:43:00 <pejo> johnnowak, heh. For example. I wonder how you could read my mind. :-)
03:43:14 <nornagon> swiert: that doesn't work if there's no repository there already, right?
03:43:22 <swiert> nornagon: nope.
03:43:32 * mux had no difficulties with TAPL, but advanced TAPL is really making my head hurt :)
03:43:42 <swiert> nornagon: just ssh to the remote host, and darcs initialize an empty repos.
03:43:50 <mattam> Yeah, ghc already took that path
03:43:51 <johnnowak> pejo: i think o'haskell has gone down that path
03:44:06 <nornagon> swiert: ah, okay :)
03:44:15 <pejo> johnnowak, yeah, and the sucessor (Timber) too.
03:44:22 <johnnowak> ah
03:44:45 <nornagon> swiert: thanks!
03:44:46 <mattam> and with MLF you get to know exactly where the line is. Maybe this will be adapted to the Constructions too...
03:45:06 <mattam> MLF is reasonnably crazy though...
03:45:16 <ac> johnnowak: You said something about concatenative languages. Were you saying that it may be possible to reason more easily about the types of concatenative languages?
03:45:33 <nornagon> @karma+ swiert
03:45:33 <lambdabot> swiert's karma raised to 5.
03:45:39 <ac> I meant "reason more easily about types in concatenative languages"
03:45:44 <johnnowak> ac: i don't have concrete evidence, but that's my guess
03:46:09 <ac> johnnowak: that's very interesting, because AFAIK, it's only been very recently that type systems in concatenative languages have begun to be explored
03:46:11 <mattam> Anyway, in my experience, lack of inference is not where the trouble is, it's rather proving that becomes an issue.
03:46:35 <johnnowak> i'm writing a type checker now that infers all types for a concatenative language with extensible records/variants, equirecursive types, etc, and it seems relatively straightforward
03:46:52 <johnnowak> i should have something available in a few weeks
03:47:23 <ac> johnnowak: Neat. For what language? I've always been entertained by stack based languages (isn't that what concatenative means?)
03:47:59 <johnnowak> ac: some new language i'm working on. and yes, all cocatenative languages seem to be stack-based.
03:48:04 <quicksilver> in practice it tends to mean that
03:48:11 <quicksilver> ac: have you seen 'JoY' ?
03:48:13 <ac> but apparently they're independent concepts?
03:48:20 <quicksilver> that's a pretty elegant concat. language
03:48:24 <johnnowak> ac: yes. many stack-based languages aren't concatenative
03:48:53 <ac> quicksilver: I've heard of it. And Cat too, but haven't programmed in either one. My experience with stack based languages has been limited to HP's graphing calculater language, post script, and factor
03:48:59 <johnnowak> and you could have a concatenative language without stacks (for example by using only global variables)
03:49:04 <quicksilver> I can't put my hand on my hard and say I'd use joy for real programming. But it's pretty and the author's articles are thought provoking
03:49:26 <ac> what about Cat?
03:49:49 <johnnowak> cat isn't done yet. collections still aren't typed in any way.
03:50:08 <johnnowak> and it's really more focused on being an intermediate language
03:50:57 <ac> so what precisely does "concatenative" mean, or where could I read about it?
03:51:04 <johnnowak> i think what's needed for concatenative languages to be workable is a good type system and an ide closely tied to the language that can make things less painful
03:51:10 <johnnowak> ac: the wikipedia page isn't too bad
03:51:10 <quicksilver> any two programs can be concatenated together
03:51:17 <quicksilver> and produce a valid program
03:51:27 <johnnowak> if 'foo bar baz' is a valid program, then so is 'foo bar', 'bar baz', etc
03:51:56 <quicksilver> a more mathematically oriented person might call them free monoidal languages, or something :)
03:52:09 <johnnowak> it means you can do nice things like automated factoring. you might have the program 'a b c d e', then replace 'b c d' with f, and you can do it for all definitions in the same module automatically without altering the meaning of the program
03:52:26 <ac> but if it's stack based and typed, than only programs that have compatible stack signatures can be concatenated together
03:52:31 * johnnowak might call his language monoid if he can't think of anything better
03:52:43 <ac> johnnowak: that's a boring name
03:52:47 <johnnowak> aye.
03:52:49 <osfameron> think of something that is more googlable than a single name that already has a meaning
03:53:16 <quicksilver> just a string of meaningless but pronouncable letters
03:53:17 <quicksilver> 'google'
03:53:23 <quicksilver> that's a good one. call it google!
03:53:24 <quicksilver> :P
03:53:28 <johnnowak> ac: the type system does ensure you can't combine programs in nonsensical ways, yes
03:56:38 <johnnowak> ac: think of a better name and let me know.
03:57:08 <quicksilver> johnnowak: lambdacat :P
03:58:00 <osfameron> lambdacat should really be a monadic version of the lolcat programming language though
03:58:10 <osfameron> LOLCODE I mean
03:58:24 <osfameron> so no IM IN YR LOOP construct :-(
03:59:46 <roconnor> It's been over a day, and I still get a kick out of flip concatMap
04:00:32 * quicksilver agrees
04:00:52 <ADEpt> roconnor: and I wonder why nobody posted a "Con-cat" along thos lines: http://cbruen.com/blog/cats_prison.jpg :)
04:00:55 <quicksilver>  \ cats -> map lol cats is pretty good, too
04:01:22 <Saizan> flip concatMap?
04:01:33 <Taejo> Is there a tutorial for Parsec?
04:01:42 <Saizan> yes
04:01:45 <ADEpt> Taejo: in the paper accompanying Parsec
04:01:50 <quicksilver> Saizan: http://arcanux.org/lambdacats/concatMap.jpg
04:02:45 <Saizan> :D
04:03:13 <Saizan> ?where parsec
04:03:13 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
04:03:45 <Taejo> thx
04:04:58 <matveev> ?where binary
04:04:59 <quicksilver> You know what would be a really nice thing to have? A tutorial/paper giving explanations and plenty of examples about mapping standard OO styles to Haskell.
04:04:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
04:05:03 <quicksilver> Idiomatically.
04:05:53 <ac> So what should I look at after Haskell? Of the last 7 languages I've played with, Haskell is the only one that's made me think a little. Are there any other languages or concepts that might give me new ideas?
04:05:53 <Saizan> yeah, and abstract them away in a library when possible
04:06:20 <quicksilver> ac: no :)
04:06:40 <quicksilver> ac: if you want to continue down the same path, perhaps epigram or agda2
04:06:47 <ac> Actually, that's not entirely true. Maude made me think a little as well
04:06:55 <quicksilver> ac: if you fancy something similar but very different, maybe erlang?
04:07:15 <quicksilver> ac: if you fancy something *completely* different, TeX :)
04:07:20 <ac> quicksilver: is Erlang really that different from concurrent haskell?
04:07:25 <quicksilver> very, yes
04:07:28 <quicksilver> untyped, impure
04:07:35 <quicksilver> message passing as a fundamental concept
04:07:44 <roconnor> ac: Agda!
04:07:49 <roconnor> or Epigram
04:07:51 <roconnor> ... or Coq
04:08:02 <roconnor> quicksilver: oops, sorry
04:08:10 <Saizan> a logic language?
04:08:19 <roconnor> prolog :D
04:08:37 <roconnor> but prolog is just Haskell's type system :P
04:08:56 <matthew_-> heh, sadly, it's not quite that good.
04:09:39 <ac> which one is the most approachable, or the best to use once you're familiar with, out of epigram, coq, and agda? And are any freely available?
04:09:46 <roconnor> I suppose Prolog is a language that is worth being familiar with.
04:14:43 <noob> what is the simplest way too feed a "string" to "hPutBuf handle pointer size" ??
04:15:09 <roconnor> How do I tell if RFC 2392 is obsolete?
04:17:39 <ADEpt> roconnor: according to http://www.rfc-ref.org/RFC-TEXTS/2392/index.html, it isnt
04:17:41 <lambdabot> Title: Content-ID and Message-ID Uniform Resource Locators [RFC-Ref]
04:18:17 <roconnor> ADEpt: purrfect, thanks.
04:20:42 <roconnor> wow, what a great site
04:21:26 <etnt> are there any good tutorials for Monads programming + exercises perhaps?
04:22:49 <quicksilver> noob: why not just use hPutStr ?
04:23:43 <quicksilver> noob: nonetheless, the answer to your question is probably 'withArray' from Foreign
04:30:36 <Taejo> @fix (\ L -> (L L L L L L L L L L L L L L L L L L L L L L L L L L)) (\ a b c d e f g h i j k l m n o p q s t u v w x y z r -> ( r ( t h i s i s a f i x e d p o i n t c o m b i n a t o r ) ))
04:30:36 <lambdabot> Maybe you meant: faq ft id thx
04:30:45 <Taejo> @pl (\ L -> (L L L L L L L L L L L L L L L L L L L L L L L L L L)) (\ a b c d e f g h i j k l m n o p q s t u v w x y z r -> ( r ( t h i s i s a f i x e d p o i n t c o m b i n a t o r ) ))
04:30:48 <lambdabot> ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap id id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id)
04:30:48 <lambdabot> id ((((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((
04:30:48 <lambdabot> ((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .)
04:30:48 <lambdabot> .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((ap id .) .) .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .)
04:30:51 <lambdabot>  .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((ap .) .) .
04:30:54 <lambdabot> [25 @more lines]
04:30:56 <lambdabot> optimization suspended, use @pl-resume to continue.
04:31:01 <Taejo> BAD lambdabot
04:31:07 <Taejo> the answer is fix
04:31:44 <nominolo> but is it typable?
04:31:48 <AshyIsMe> "compile yi as you would do for any other Cabal package"
04:31:53 <AshyIsMe> how do i do that?
04:32:14 <Taejo> nominolo, I don't know
04:32:14 <nominolo> haskell.org/cabal
04:32:14 <Zao> AshyIsMe: runhaskell configure, runhaskell build, runhaskell install.
04:32:14 <opqdonut> nominolo: fixed point combinators aren't
04:32:16 <AshyIsMe> Zao: hot
04:32:18 <Zao> Possibly sneaking in an --prefix and --user on the first one.
04:32:36 <nominolo> AshyIsMe, it's the first link on the Cabal site
04:32:40 <opqdonut> not in plain strongly typed lambda calculus
04:33:13 <AshyIsMe> nominolo: k
04:33:45 * AshyIsMe is slightly drunk
04:34:01 <quicksilver> depends what you think 'fixed-point' combinator means
04:34:01 <AshyIsMe> and it's raining for the first time in months so double awesome
04:34:02 <nominolo> don't drink and dervie
04:34:06 <nominolo> *derive
04:34:09 <quicksilver> 'fix' is a kind of fixed-point combinator
04:34:13 <quicksilver> and it's perfectly typeable
04:35:04 <nominolo> quicksilver, not in system F without extensions
04:35:25 <quicksilver> in haskell...
04:35:27 <noob> quicksiver:  1) thanks, I was ready to believe that Haskellers live with the only primitive hPutBuf.  2) Does that mean that "withArray" could be used to pass data through FFI?
04:35:32 <AshyIsMe> hmm, could not find module `System.FilePath'
04:35:47 <quicksilver> 1) no, there is putStr :) 2) yes, that's what it's for
04:36:15 <nominolo> AshyIsMe, oh, then you need to add 'filepath' to the build-depends field in Yi.cabal
04:36:43 <oklopl> can you do nice graphics with haskell?
04:36:59 <nominolo> oklopol, you can use cairo
04:37:05 <quicksilver> oklopol: or openGL
04:37:21 <oklopol> ah
04:37:28 <AshyIsMe> nominolo: hmm, filepath>=1.0 is in there
04:37:31 <oklopol> oh course you can
04:37:34 <oklopol> *of
04:37:37 <AshyIsMe> is filepath a library i have to install?
04:37:47 <oklopol> but now s bit of sleep ->
04:37:54 <nominolo> AshyIsMe, hm.  it should be included with ghc 6.6.1
04:38:25 <nominolo> AshyIsMe, which compiler do you use?
04:38:34 <AshyIsMe> $ ghc --version
04:38:34 <AshyIsMe> The Glorious Glasgow Haskell Compilation System, version 6.6
04:39:01 <nominolo> oh, then you need to install it separately.
04:39:20 <nominolo> it should come as a package in most distros
04:39:40 <nominolo> be sure to get "filepath" not "FilePath"
04:40:02 <AshyIsMe> ok
04:40:09 <AshyIsMe> i'm searching synaptic now
04:40:42 <AshyIsMe> i love how none of the haskell packages are authenticated
04:40:44 <nominolo> we hope to soon automate installing most/all of the packages on: http://hackage.haskell.org/packages/archive/pkg-list.html
04:40:47 <AshyIsMe> makes me feel dangerous
04:40:59 <nominolo> unfortunately, we're not there yet
04:41:14 <AshyIsMe> yeah
04:41:19 <nominolo> AshyIsMe, authenticated in what way?
04:41:29 <AshyIsMe> asdf-install is pretty sweet in terms of auto package install
04:41:50 <nominolo> yeah.  though a bit too querty-biased ;)
04:41:53 <AshyIsMe> it's a shame there's no foss cross platform cl with threads and sockets yet
04:42:14 <AshyIsMe> haha, yeah
04:42:17 <nominolo> is SBCL still beta on windows?
04:42:21 <AshyIsMe> it's not too hard to type in dvorak
04:42:23 <AshyIsMe> yeah
04:42:31 <AshyIsMe> i think it's stalled aswell
04:42:53 <AshyIsMe> nyef left a post saying pretty much "windows threads are a bitch" and he hasnt been seen online for like 3 months now
04:43:03 <nominolo> heh
04:45:09 <AshyIsMe> i'm pretty impressed with plt scheme though
04:45:21 <nominolo> sad, actually
04:45:24 <AshyIsMe> it seems like a really no-nonsense language implementation
04:45:46 <AshyIsMe> like "ok, we support osx, *nix, and windows and everything just works"
04:46:05 <ac> AshyIsMe: they're require syntax drives me nuts
04:46:11 <ac> er, their
04:46:23 <AshyIsMe> (require package) ?
04:46:34 <AshyIsMe> or you mean the (module crap ...) stuff
04:46:42 <AshyIsMe> it annoys me that everything is within the module sexp
04:46:43 <ac> AshyIsMe: (require (lib "foo" "path/to/foo") 1 2.1)
04:46:46 <AshyIsMe> ahh, yeap
04:46:58 <AshyIsMe> but what can you do?  it's a small annoyance
04:47:16 <ac> AshyIsMe: I can bitch about it every time I have to type it :P
04:47:20 <AshyIsMe> heh
04:48:05 <ac> AshyIsMe: Haskell has better libraries for some reason
04:48:07 <nominolo> what's so bad with it?
04:48:14 <AshyIsMe> yeah?
04:49:00 <AshyIsMe> im still gonna finish this project in plt
04:49:12 <ac> AshyIsMe: what are you working on?
04:49:14 <AshyIsMe> i still havent decided to learn erlang or haskell next after that
04:49:22 <AshyIsMe> media player
04:49:38 <AshyIsMe> i want a portable media player that i like and havent found one yet
04:49:58 <AshyIsMe> so i'm using vlc as a backend and plt with gtk
04:51:06 <ac> AshyIsMe: how is the gtk library working out?
04:51:11 <nominolo> AshyIsMe, i think erlang is closer to scheme than haskell.  haskell has types and laziness - so if you want to learn something more different, pick haskell ;)
04:51:42 <ac> AshyIsMe: I would agree with nominolo, but that's from someone who's had some experience with Scheme and Haskell, but not Erlang
04:52:23 <AshyIsMe> ac: i'm using gtk-server atm
04:52:27 <AshyIsMe> si working pretty well
04:52:38 <AshyIsMe> hopefully a foreign.ss lib to gtk is fairly easy too
04:52:54 <ac> What's gtk-server?
04:53:15 <AshyIsMe> a process that you can send "gtk_window_new arguments etc" to over a socket
04:53:21 <AshyIsMe> and it'll draw the gui for you
04:53:32 <AshyIsMe> you can use sockets or pipes
04:54:03 <ac> AshyIsMe: hm. Good luck finding a PLT library for GTK that works and is relatively complete
04:54:19 <AshyIsMe> ac: yeah there isnt one, but i think swig does plt
04:54:29 <AshyIsMe> i don't mind hacking one
04:54:47 <ac> AshyIsMe: that's admirable. Personally I get fed up when I can't easily do something so basic as graphics
04:54:59 <AshyIsMe> yeah i usually do
04:55:11 <AshyIsMe> for some reason lisp makes it seem fun
04:55:25 <AshyIsMe> maybe i just like the curvy parens :P
04:55:34 <Vq^> heh
04:55:58 <AshyIsMe> gah, the ubuntu filepath package doesnt satisfy runghc
04:56:08 <AshyIsMe> and the source tarball has all sorts of missing dependencies
04:56:31 <ac> AshyIsMe: I installed it on my Ubuntu system no problem
04:56:40 <AshyIsMe> hmm
04:56:46 <ac> Then I upgraded to 6.8 and compiled that with no problems
04:56:54 <nominolo> AshyIsMe, can you paste the error message and the output of "ghc-pkg list"?
04:56:54 <nominolo> !hpaste
04:56:54 <nominolo> @where hpaste
04:56:55 <lambdabot> I know nothing about hpaste.
04:57:19 <nominolo> http://hpaste.org/new
04:57:54 <AshyIsMe> i'm running $ runghc Setup.hs configure
04:58:07 <AshyIsMe> in the darcs yi directory
04:58:21 <AshyIsMe> Setup.hs: cannot satisfy dependency filepath>=1.0
04:58:34 <nominolo> so did you install filepath?
04:58:40 <ac> AshyIsMe: don't grab the source from darcs, download one of the official releases
04:58:46 <AshyIsMe> i have libghc6-filepath-dev ubuntu package installed
04:58:49 <AshyIsMe> ahh, ok
04:58:56 <ac> than you can just type make
04:59:05 <ac> and it should build with no problems
04:59:27 <nominolo> ac, not if dependencies are missing
05:00:27 <nominolo> AshyIsMe, does "ghc-pkg list filepath" list filepath-1.0 ?
05:00:39 <ac> http://www.haskell.org/ghc/dist/stable/dist/ghc-6.8.0.20071011-i386-unknown-linux.tar.bz2
05:00:41 <lambdabot> http://tinyurl.com/ys6evy
05:00:42 <ac> that's the one I used I think
05:01:09 <AshyIsMe> nominolo: nope
05:01:16 <AshyIsMe> /usr/lib/ghc-6.6/package.conf:
05:01:17 <AshyIsMe> that's it
05:02:02 <AshyIsMe> ac: 42MB, this is gonna take ages to compil eisnt it?
05:02:29 <nominolo> AshyIsMe, ok, then it is not installed
05:02:52 <nominolo> maybe you have to use a new shell or something, to make it visible?
05:02:53 <AshyIsMe> hmm, ubuntu package is installed, weird
05:03:16 <AshyIsMe> nope samething
05:03:37 <nominolo> weird
05:05:32 <ac> AshyIsMe: it compiled fairly quickly for me. gtk2hs on the other hand took ages to compile
05:06:10 <AshyIsMe> oh cool, gtk2hs only took like 15 min
05:06:14 <ac> Unless you're doing something fancy, I'd recommend simply installing the ubuntu packages. Then you don't have to compile any libghc6-*-dev packages you might want
05:06:27 <ac> nevermind
05:07:20 <AshyIsMe> hmm
05:07:25 <AshyIsMe> i just want to try out yi
05:07:44 <nominolo> AshyIsMe, it's actually not too impressive ;)
05:07:59 <AshyIsMe> heh, i didnt expect it to be
05:08:13 <AshyIsMe> my kinesis contoured will arrive soon anyway
05:08:30 <nominolo> i'm not sure it even supports undo yet
05:08:34 <AshyIsMe> at least then i'll have a proper keyboard for emacs
05:08:39 <AshyIsMe> ahh, ok
05:09:42 <nominolo> vincenz, and ivant were working on an algebra for collaborative editing operations that could allow undo in that setting
05:10:24 <AshyIsMe> cool
05:10:48 <nominolo> i wonder how they do it at subethaedit
05:15:09 <Taejo> I just used liftM2 for the first time... it feels awesome
05:16:17 <nominolo> wait until you import Control.Applicative into every file ;)
05:16:51 <ac> liftM2 is just a two argument version of liftM, right?
05:17:24 <Taejo> yes, but i hadn't used that either
05:18:39 <nominolo> :t (+) <$> readLn <*> readLn
05:18:44 <lambdabot> forall a. (Num a, Read a) => IO a
05:19:06 <nominolo> :t liftM2 (+) readLn readLn
05:19:08 <lambdabot> forall a1. (Num a1, Read a1) => IO a1
05:19:45 <nominolo> > (+) (Just 42) (Just 23)
05:19:47 <lambdabot>   add an instance declaration for (Num (Maybe t))
05:19:47 <lambdabot>     In the expression: (+) ...
05:19:57 <nominolo> > (+) <$> (Just 42) <*>  (Just 23)
05:20:00 <lambdabot>  Just 65
05:20:53 <Taejo> so (<$>) is like liftM?
05:20:57 <nominolo> > let plus = liftM2 (+) in Just 4 `plus` Just 7
05:20:59 <lambdabot>  Just 11
05:21:12 <nominolo> Taejo, yep
05:22:54 <nominolo> :t ap . return
05:22:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
05:23:17 <osfameron> heh, I like http://lisperati.com/haskell/ht2.html
05:23:18 <osfameron> Here's the code that reads in this list of numbers. Adding this code to our existing program is super easy: Just paste this new code to the bottom of the "Hello World" program to make the new code work- Do the same thing, as we go along, with all the other code fragments in this tutorial.
05:23:21 <nominolo> :t (<$>)
05:23:23 <osfameron>   
05:23:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:23:29 <osfameron> oops
05:23:52 <osfameron> good old irssi for preventing me from making an even bigger idiot of myself :-)
05:24:07 <osfameron> I like the "IMPORTANT" note.
05:24:22 <nominolo> yeah, conrad writes cool tutorials
05:24:35 <AshyIsMe> <irssi> YOu are about to paste a fuckload of lines, are you really stupid?
05:24:39 <AshyIsMe> heh
05:25:38 <osfameron> heh, indeed
05:27:49 <ac> AshyIsMe: irssi is great
05:27:59 <AshyIsMe> aye laddy
05:28:08 <ac> AshyIsMe: do you use mutt too? ;)
05:28:08 <AshyIsMe> we're old lovers
05:28:17 <AshyIsMe> nope
05:28:33 * osfameron is struggling with mutt
05:28:34 <ac> AshyIsMe: aw. mutt is to email as irssi is te irc
05:29:57 <quicksilver> Lemmih: that's bizarre. LinkedIn.com just suggested I may know you. Not sure how it managed to link us...
05:31:35 * roconnor invents a (not so) new theorem
05:31:42 <roconnor> Theorem (Not-Finite Pigeon Hole Principle): if you have a relation R between the natural numbers and a finitely enumerable set X, such that for every n there classically exists some y in X such that R n y, then there classically exists some x in X whose preimage is not finite.
05:32:14 <roconnor> constructive mathematics *sigh*.
05:32:41 <AshyIsMe> ac: gmail suits me
05:32:57 <AshyIsMe> i'm more of an instant comm man, irc, msn etc.
05:36:13 * roconnor wonders if my conclusion should be not-finitely-enumerable rather than not-finite.
05:36:37 <Lemmih> quicksilver: Perhaps it figures all Haskell users know each other.
05:37:38 <quicksilver> Lemmih: if it does, it's damn clever, becauser my linkedin profile doesn't mention haskell anywhere that I can see :)
05:40:28 <wsdo_okadr> roconnor: that's pretty obvious :)
05:40:42 <wsdo_okadr> roconnor: you follow a course ?
05:40:51 <wsdo_okadr> roconnor: do you have a textbook on that ?
05:48:39 <Taejo> how can I import everything except one name from a module?
05:49:28 <Saizan_> import Module hiding (onename)
05:50:09 <Taejo> thx
05:52:36 <nornagon> why isn't the darcs line-entry stuff readline based? :(
05:52:55 <nornagon> i can't edit commit messages in the terminal, i have to delete them and rewrite
05:53:00 <matthew_-> NIH syndrome
05:53:05 <nornagon> ?
05:53:11 <matthew_-> Not Invented Here
05:53:22 <nornagon> i see
05:53:29 <matthew_-> but it's pretty rife throughout open source
05:53:50 <osfameron> or in this case Not-In-Haskell? (as readline is in C and therefore imperative and BAD :-)
05:53:57 <nornagon> it's a pain not to be able to edit, someone should come up with a 3-line pure haskell replacement for readline already
05:54:00 <dylan> nornagon: when I typo one, I just press 'y' to "Long commit message?"
05:54:03 <matthew_-> why use a library which is only 99% useful for everyone when you can implement it yourself and make it 100% useful for you and 0% useful for everyone eles
05:54:37 <nornagon> dylan: that works, but it's a pain
05:54:40 <matthew_-> monotone has its own implementation of diff in it. wtf is that all about? NIH is quite a big problem
05:54:48 <ibid> osfameron: the libs contain a readline binding
05:54:54 <dylan> I rarely typo a commit message, though
05:55:19 <ibid> and you can edit the commit message in the editor if you answer yes to the question
05:55:46 <nornagon> maybe i should just use -m "foo"
05:56:06 <dylan> BTW, if someone re-implements readline:
05:56:16 <dylan> It *must* allow me a way of turning on vi mode.
05:59:16 <roconnor> wsdo_okadr: things are less obvious in constructive mathematics :(
05:59:19 <osfameron> meh, using the system readline seems infinitely more sensible
06:01:07 <quicksilver> matthew_-: readline is GPL, maybe that's why darcs ddn't want to use it
06:01:33 <ibid> quicksilver: there is a BSD replacement
06:01:58 <quicksilver> yeah, but it's a bit subfunctional IIRC
06:02:54 <osfameron> does using *bindings* to GPL things not distributed with project invoke GPL?
06:04:34 <wsdo_okadr> roconnor: if you understand finite pigeon hole principle , not-finite is really obvious
06:05:35 <quicksilver> osfameron: this is a delicate question, but the short answer is yes
06:05:40 <ddarius> The "pigeonhole principle" is really obvious.
06:05:49 <dylan> ghci uses readline...
06:06:08 <quicksilver> osfameron: the long answer is, if the project cannot reasonably run without Foo, then Foo is part of it, so it is a derived work of Foo, so copyright applies.
06:06:16 <osfameron> quicksilver: gosh.  That's interesting, and makes a bit more sense why people complain about GPL
06:06:36 <quicksilver> osfameron: if, on the only hand, Foo is just 'plugged in' and other stuff can also be 'plugged in' instead, so Foo is just one of several pluggabe alterntaives
06:06:48 <quicksilver> osfameron: then evidently the project doesn't *depend* on it, so that's OK
06:07:10 <wsdo_okadr> roconnor: what are you reading ?
06:07:44 <roconnor> wsdo_okadr: suppose I give you a list l::[A] and function f :: Integer -> A with the promise that f n `elem` l, then return an A which is hit infinitely often.
06:07:46 <ibid> osfameron: the FSF position is that an interface that has both GPL and non-GPL implementations is a GPL boundary, but an interface that has only GPL implementations is not (my words, not theirs)
06:08:36 <roconnor> wsdo_okadr: ie. give me a function of type [A] -> (Integer -> A) -> A satisfying the above specification.
06:09:37 <ddarius> roconnor: Is this list finite?
06:10:35 <Taejo> quicksilver, your "long answer" doesn't seem to work like RMS's mind: CLISP is GPLed because RMS said it had to be to use readline
06:10:52 <quicksilver> right
06:10:54 <ibid> Taejo: when was this?
06:11:04 <quicksilver> it's probably not a good idea to have this conversation in #haskell to be honest
06:11:05 <Taejo> ibid, I'll look it up
06:11:10 <ibid> Taejo: readline was a GPL-only interface for a long time
06:11:13 <ddarius> But yeah, that is, in general, impossible.
06:11:16 <quicksilver> they tend to get long and (for people not interested) boring
06:11:18 <osfameron> so having an alternate implementation of readline in haskell would make it a GPL boundary, even if the end user decided to use the GPL version
06:11:29 <quicksilver> bash went GPL because of readline, IIRC
06:12:26 <ibid> osfameron: there already is a non-GPL implementation of (most of) readline
06:12:33 <roconnor> ddarius: yes, a finite list.  Good point.
06:12:36 <ibid> osfameron: remember that both hugs and ghc use readline :)
06:12:59 <pejo> dylan, didn't some BSD 'reimplement' readline? Atleast NetBSd has libedit in base.
06:13:15 <dylan> pejo: perhaps. does it do vi-mode? :)
06:13:23 <pejo> Oh, ibid mentioned that just a few lines later.
06:13:35 <ibid> yes, libedit is the non-GPL implementation i meant
06:13:47 <quicksilver> pejo: yes, it did, and I believe that was after the Bash and CLISP incidents
06:14:17 <Taejo> ibid, swik.net/CLISP seems to have the story from the google blurb, but my connection is being troublesome
06:14:29 <Taejo> or not
06:14:42 <roconnor> wsdo_okadr: I just wrote this: http://r6research.livejournal.com/16009.html
06:14:43 <lambdabot> Title: r6research: Construcitve Not-Finite Pigeon Hole Principle.
06:15:22 <pejo> ibid, didn't they run a SoC-project on it too?
06:15:40 <ibid> pejo: no idea
06:17:07 <roconnor> I think i've convinced myself that not finite and not finitely enumerable are the same thing.
06:20:46 <hkBst> roconnor: by definition?
06:21:33 <quicksilver> I think roconnor might be making a constructivist distinction
06:21:38 <quicksilver> but to be honest I'm not following him :)
06:22:22 <wsdo_okadr> roconnor: no they're not
06:22:39 <roconnor> X is finite means there exists an n such that there is a bijection between X and Fin n  (Fin n is the finite set of n elements)
06:22:40 <wsdo_okadr> roconnor: at least that's my oppinion
06:23:06 <roconnor> X is finitely enumerable means there exists an n such that there is a injection from X into Fin n
06:23:20 <wsdo_okadr> roconnor: from the cardinality point of view , not finitely enumerable and not finite are not the same
06:23:23 <roconnor> hmm
06:23:33 <roconnor> now that I say that, I'm not sure if that is correct.
06:24:02 <wsdo_okadr> roconnor: check out ordinals
06:24:22 <roconnor> wsdo_okadr: constructively speaking they are distict concepts.
06:24:31 <roconnor> distinct
06:25:24 <roconnor> ah right I defined finitely enumerable wrong
06:25:43 <roconnor> X is finitely enumerable means there exists an n such that there is a surjection from Fin n into X
06:25:52 <roconnor> that makes more sense.
06:26:02 <roconnor> ... for some definition of sense.
06:26:36 <oerjan> i think if X has decidable equality, all three are equivalent
06:26:56 <roconnor> right, only when X has no decidable equality is there a problem.
06:29:12 <oerjan> hm... actually, maybe not the second one
06:30:11 * roconnor needs to start #constructive-math
06:35:41 <foo-nix> Cale: I have little  I think. I'm stuck in inferred and expected types.
06:35:45 <foo-nix> :)
06:36:55 <foo-nix> hugs will take this code perfectly: http://pastebin.com/m10a44831. Although this one is not: http://pastebin.com/m70011fbd, It gives me this error message: http://pastebin.com/m7877d102.
06:38:23 <foo-nix> It is like, I have this expression which ought to return (Int, [([a],[a])]), which is the expected type, only hugs infers that it is (Int, [([_4], [_4])]) where the 4 changes (has been _188, etc).
06:38:52 <twanvl> foo-nix: The 'a' in the type of the definition in the where is not the same as the 'a' in the top level type signature
06:38:56 <quicksilver> foo-nix: it is because that 'a' is not the same as the other 'a'
06:38:59 <quicksilver> ah, too slow :)
06:39:28 <quicksilver> foo-nix: in hugs it is simplest not to give types to 'local' definitons for exactly this reason
06:39:35 <quicksilver> foo-nix: because it is not possible in general
06:39:40 <foo-nix> quicksilver: How can I fix this?
06:39:49 <quicksilver> by not giving the type annotation
06:39:55 <foo-nix> quicksilver: I think I see what you mean.
06:40:14 <foo-nix> It's like I dont gove the definition?
06:40:23 <foo-nix> and let hugs just infer ir?
06:40:25 <foo-nix> *it
06:40:26 <quicksilver> yes
06:40:33 <quicksilver> just miss out the type
06:40:41 <quicksilver> you appear to be in the habit of giving types to everything
06:40:47 <quicksilver> I only ever type top-level definitions
06:40:54 <quicksilver> and, to be honest, only ones with 'interesting' types
06:40:56 <foo-nix> quicksilver: Ok, let me try, but I think there has been this debugging thing where I already tried that, but let me see again :).
06:41:03 <quicksilver> I let the compiler infer the rest :)
06:41:42 <foo-nix> quicksilver: It seems to work, let me check the type optAl..22 now...
06:42:51 <foo-nix> quicksilver: Thanks, it now says optAlignments22 :: (Eq a) => [a] -> [a] -> a -> (Int, [([a], [a])]) on a :type optAl...22
06:43:03 <foo-nix> quicksilver: Thanks, I think You saved my day today :).
06:43:23 <quicksilver> :)
06:43:43 <quicksilver> there is a syntax where you can say that you mean 1 'a' is the same as the other 'a'
06:43:47 <quicksilver> but I don't know what it is in hugs
06:44:34 <foo-nix> quicksilver: I normally use ghci, but atm I use both for the fake of having two error messages when I dont understand :)
06:44:41 <quicksilver> :)
06:45:03 <quicksilver> in ghc, the trick is to insert "forall a ." at the frornt of optAlignments22's signature
06:45:11 <quicksilver> (you probably need -fglasgow-exts)
06:45:36 <quicksilver> that gives the 'a' a scope so that later enclosed as are the same a
06:45:45 <foo-nix> quicksilver: ah, sweet.
06:46:24 <foo-nix> quicksilver: I will see if I can use it, but leaving the definition of optEntry open works two.
06:50:10 <foo-nix> quicksilver: hehe, someone unplugged our switch, and now I had to do <alt> <Ctrl> <bs>
06:51:05 <foo-nix> quicksilver: but thanks for your help. We sorted it out now.
06:52:57 <quicksilver> :)
06:58:14 <foo-nix> quicksilver: I just fiound out about someone else in this channel also being at my uni :)
06:58:39 <twanvl> foo-nix: strange, so did I :)
07:00:04 <foo-nix> twanvl: What you say?
07:00:12 <Beelsebob> what unis are those then?
07:00:19 <foo-nix> RuG is mine.
07:00:37 * Beelsebob wonders if we all go to the same multiversity
07:00:37 <foo-nix> what's yours twanvl ?
07:00:48 <foo-nix> Beelsebob: What uni do you goto?
07:00:53 <Beelsebob> UCK
07:00:55 <Beelsebob> UKC even
07:01:38 <twanvl> foo-nix: rug (it's lower case now), but you knew that
07:01:55 <foo-nix> twanvl: Did I? Ah, how obvious.
07:02:45 <foo-nix> It would be even more of an cowinsidece (never mind my redicilous spelling) if there was a woman in this channel.
07:03:29 <foo-nix> ^^
07:19:35 <foo-nix> Is there a siesta on this channel?
07:19:38 <foo-nix> ;)
07:19:51 <osfameron> hombre!  functional programming, he tiring!
07:20:04 <foo-nix> :p
07:20:08 <foo-nix> roflol
07:22:19 <sjanssen> @remember osfameron hombre!  functional programming, he tiring!
07:22:19 <lambdabot> Done.
07:22:24 <sjanssen> @flush
07:22:48 <mauke> @spleesh
07:22:48 <lambdabot> Unknown command, try @list
07:23:37 <shapr> Good morning #haskell!
07:23:55 <iank> disagree
07:24:49 <oerjan> @splanch
07:24:49 <lambdabot> Unknown command, try @list
07:25:12 <shapr> Good morning iank!
07:25:18 <swiert> hi shapr.
07:25:20 <swiert> how's things?
07:25:23 <iank> Hello shapr!
07:26:18 <shapr> Hoi swiert, code is good, how's things with you?
07:26:48 <swiert> shapr: Pretty busy. Teaching has started again; paper deadlines; all the usual jazz.
07:26:55 <shapr> Yeah, I can dig it.
07:27:58 <swiert> I do get to teach an Introductions to Algorithms course to students who don't have the right A-levels to start a CS degree.
07:28:09 <foo-nix> I need to go home, bye all.
07:28:27 <quicksilver> later
07:28:28 <swiert> It's the first time the course is being taught, so I get to design it myself - which is a lot of fun, but takes up quite a lot of time.
07:28:57 <swiert> Plus, I get to sneak in some functional programming ;)
07:29:20 <suppaman> hello
07:29:41 <swiert> hi suppaman
07:30:01 <amiddelk> hi
07:31:10 <swiert> suppaman: Are you learning Haskell?
07:31:21 <suppaman> I eventually read Why Haskell Matters
07:31:26 <suppaman> and was amazed
07:31:50 <swiert> The John Hughes paper? It's a classic.
07:31:52 <suppaman> I printed A Gentle Introduction and Why Functional Programming matters
07:31:59 <suppaman> and now I'm reading, the latter first
07:32:29 <swiert> I might want to warn you, the Gentle Introduction isn't particularly gentle.
07:32:33 <suppaman> it's like a zen epiphany
07:32:50 <swiert> There are a lot of other good tutorials out there.
07:33:06 <suppaman> I wonder only if functional programming is... functional to problems not strictly mathematical
07:33:12 <suppaman> I think about a web application by instance
07:33:16 <suppaman> or db mining
07:33:17 <swiert> suppaman: Yes!
07:33:31 <swiert> There's all kind of applications written in Haskell.
07:33:54 <suppaman> good
07:34:01 <swiert> Including XMonad (a tiling window manager), webservers, webapps, version control systems, ...
07:34:09 <swiert> The list keeps growing.
07:34:14 <sieni> Gentle Introduction might be reasonably gentle if you already know some functional programming concepts. E.g. have already programmed e.g. in scheme.
07:34:20 <Zao> suppaman: I'm making a tetris :P
07:35:44 <osfameron> shiny!
07:36:12 <Zao> osfameron: Actually, there's not much specular lighting at all yet, so it's all rather diffuse.
07:36:25 <suppaman> sieni: I didn't
07:36:34 <suppaman> I've just notions of procedural programming
07:38:35 <osfameron> Zao: lighting?  For tetris?  Now I'm confused.
07:38:45 <Zao> osfameron: http://www.acc.umu.se/~zao/Hastris/img/screen03.png
07:39:31 <sieni> suppaman: "Yet Another Haskell Tutorial" might then be better suited for you. "Gentle Introduction" is umm... rather dense. :-)
07:40:02 <osfameron> Zao: ah, I see.  I occasionally thing about writing a tetris using a curses interface (but I'm not really competent/interested in graphics programming)
07:40:10 <suppaman> sieni: is there an order ?
07:40:32 <suppaman> sieni: I mean "Why Functional Programming Matters" then "Yet Another Haskell Tut" and "A Gentle Intro" ?
07:41:52 <sieni> suppaman: I guess at least the two first ones might be a good idea (in that order). But I have noticed that planning what to read too much in advance is a bit counterproductive
07:42:07 <suppaman> :-)
07:42:19 <suppaman> I like printing stuffs so I have to know the order
07:42:25 <suppaman> don't like to read on monitor
07:42:46 <sieni> just decide what to read (you could read 2-3 things simultaneously especially if you read books), but generally pick something to read and read it :-)
07:43:25 <sieni> yeah, I usually read a bit with a pdf reader and if looks interesting enough I print it and read the dead tree edition
07:47:29 <shapr> I like to read papers on my Nokia 770.
07:47:53 <shapr> I can fit a lot of research papers on a 1GB card.
07:48:45 <osfameron> shapr: how do you cope with 2-column pdfs ?
07:48:52 * osfameron hates pdf as a screen reader format...
07:48:58 <shapr> I use evince and rotate the document view.
07:50:01 <malcolmw> Are there any people around here who are familiar with the Utrecht parser combinator library?
07:51:03 <swiert> malcolmw: vaguely...
07:51:09 <swiert> But kosmikus or earthy should know more.
07:51:29 <malcolmw> swiert: ah, yes indeed
07:51:32 <swiert> or dblhelix or amiddelk...
07:52:10 <amiddelk> y...
07:52:26 <malcolmw> I'm trying a little experiment to recode an XML parser from the polyparse library into both parsec and UU
07:53:04 <malcolmw> the parsec one was tricky, but I got it right in the end.  The UU has me stuck now
07:53:41 <malcolmw> Is there some way to write my own "primitive" parsers in UU?
07:54:16 <malcolmw> I only need a couple of primitives, e.g. to accept a (Name "msg") token and return the "msg" inside it.
07:54:44 <amiddelk> malcolmw: I would strongly advice against that
07:54:46 <malcolmw> but I couldn't find any way to do it in UU except by delving deep into the UU.Parse.Machine stuff
07:54:51 <amiddelk> yep
07:55:28 <malcolmw> amiddelk: so is UU not suitable for general input token types?
07:56:03 <amiddelk> malcolmw: as long as your grammar isn't left recursive, I don't see the problem with the UU parser library?
07:57:14 <malcolmw> amiddelk: OK, so my input has been lexed by a hand-written scanner, not the UU one.  The tokens are not simple, but include constructors like (Name "n").
07:57:33 <amiddelk> malcolmw: that shouldn't be a problem either (to use your own scanner/lexer)
07:57:57 <amiddelk> malcolmw: i'm sorry, but I have to go now. Contact me later, then I can give more elaborate answers ;-)
07:57:58 <malcolmw> I want to have a primitive parser that will recognise _any_ (Name _), giving me back the string inside it
07:58:07 <malcolmw> amiddelk: OK, bye
07:58:11 <amiddelk> bb
07:58:46 <malcolmw> pSym kind of looks like it should help, but of course, it only matches _whole_ tokens, not partial ones
08:00:35 <malcolmw> alternatively, a primitive parser that does no matching, but just always returns the next token in the stream, would be a great help.
08:01:37 <malcolmw> Is there such a beast in the UU library?  I could not find it.
08:02:55 <twanvl> You might be able to (ab)use the pRange combinator
08:03:54 <malcolmw> twanvl: hmm, yes that is a possibility.  Not sure how to specify the infinite range from null-string to all possible strings :-)
08:04:55 <twanvl> You could have a token type data Token = .. | Name String | NotAName | .. deriving Ord, then [Name []..NotAName] gives you all names
08:05:11 <twanvl> But it feels like a terrible hack
08:05:46 <Japsu> Errrm, can you do that if it's not an Enum?
08:06:17 <twanvl> Not the [x..y] notation, but you don't actually need that
08:06:19 <shapr> Mmm, the selenium binding is so nice for testing websites!
08:06:37 <malcolmw> twanvl: there is a nice <..> combinator for that
08:07:37 <shapr> Oh, I contacted a teacher here at www.cs.ua.edu who's interested in Haskell. Since I live two blocks from campus, I'm trying to find enough type theory/fp interested people to have a weekly lunch or something.
08:07:54 <shapr> The interested teacher is also in charge of the graduate CS program, and seems to want to get me into that :-)
08:10:49 <Nafai> shapr: Cool!
08:11:18 <Nafai> I've heard there are professors at www.cs.utexas.edu that like Haskell so I'm thinking about possibly auditing a course from one
08:11:56 <shapr> Good idea
08:11:57 <Japsu> Hmm
08:12:23 <Japsu> Can Data.Derive or some other fancy thingie like that derive Enum instances for datatypes with non-nullary constructors?
08:12:41 <shapr> I think Data.Default can do something like that.
08:12:52 <Japsu> @where Data.Default
08:12:52 <lambdabot> I know nothing about data.default.
08:13:07 <Japsu> bah, ungoogleable
08:13:35 <Japsu> and unhoogleable also
08:17:54 <shapr> Japsu: It's in HAppS-Data
08:18:45 <Japsu> ok, thanks
08:18:49 * SimonRC laughs at the latest lambdacats
08:19:04 <ski> ?
08:19:05 <Japsu> yes, they win truck-loads of internets
08:19:10 <Japsu> ?where lambdacats
08:19:10 <lambdabot> I know nothing about lambdacats.
08:19:13 <Japsu> !
08:19:21 <Japsu> @where+ lambdacats http://arcanux.org/lambdacats.html
08:19:21 <lambdabot> Done.
08:19:24 <coffeemug> shapr: how does HApps do persistance?
08:19:24 <SaMBuCa_> HI.
08:19:33 <coffeemug> shapr: the store is homegrown?
08:20:26 <shapr> coffeemug: Formerly Read/Show, now Data.Binary
08:21:04 <coffeemug> shapr: what about concurrency issues, indexing, etc?
08:21:27 <coffeemug> or you bypass all that because everything's in memory?
08:21:35 <shapr> IxSet does indexing, and core of HAppS is designed with ACID safety as the first priority.
08:21:51 <shapr> Sorry, Data.ByteString, not Data.Binary
08:23:09 <dons> oh, you do use Data.Binary? oh, no you don't eh
08:23:24 <shapr> mikael: Hej! You're at chalmers now!
08:23:39 <mikael> yes!
08:23:54 <shapr> Are you taking any Haskell courses?
08:24:05 <shapr> Mr Phubuh!
08:24:29 <mikael> not right now... I am labbing in computer graphics right now
08:25:35 <shapr> Will you be taking Haskell courses?
08:27:23 <shapr> KittehT is great!
08:27:54 <osfameron> @where lambdacats
08:27:54 <lambdabot> http://arcanux.org/lambdacats.html
08:29:30 <suppaman> I got this one http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
08:29:38 <suppaman> I see issues on page 159 and laters
08:29:44 <suppaman> is that some tex-related problem ?
08:29:59 <suppaman> nope
08:30:00 <suppaman> my bad
08:31:15 <suppaman> damn I zoomed the file and cut off side comments
08:42:43 <halcyon10> @pl (\p -> (barometricDensity (norm p)) + (cloudDensity p))
08:42:43 <lambdabot> ap ((+) . barometricDensity . norm) cloudDensity
08:43:46 <halcyon10> :t ap
08:43:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:48:14 <suppaman> bye
08:50:24 <shachaf> halcyon10: ap is S, in this case: s x y z = x z (y z)
08:52:58 <malcolmw> The Haskell Workshop videos have now been seen roughly 50,000 times in total (in the last five days!)
08:53:17 <shapr> w00!
08:53:57 <Nafai> I've watched about half of them myself
08:54:03 <malcolmw> The winner so far is Phil Wadler, with the peak number of over 6000 views.  "Polymorphism to the rescue!"
08:54:20 <Nafai> Interesting, that's one of the ones I haven't seen yet
08:54:24 <malcolmw> but there are several others close behind
08:54:57 <halcyon10> shchaf: thanks for the explanation, i haven't encountered ap before
08:55:12 <dons> malcolmw: wow.
08:55:26 <malcolmw> so far, that makes about 7.5Tb of video data transferred in 5 days (thanks to pejo for hosting it!)
08:55:34 <dons> malcolmw: do you have icfp or cufp videos, btw/
08:55:49 <Nafai> Thanks to everyone who recorded those and put them up!
08:55:53 <dons> i'd like to see duncan and spj's stream fusion co-talks
08:56:09 <dcoutts_> @arr!
08:56:09 <lambdabot> Avast!
08:56:14 <halcyon10> shachaf: what do you mean with S in 'ap is S' ?
08:56:20 <dcoutts_> dons: are the videos up yet?
08:56:36 <sjanssen> co-talk?  Is that like co-data? :P
08:56:45 <dons> well, co-routines anyway :)
08:56:48 <malcolmw> dons: I have only a few ICFP vids - Hughes on testing, the contest, dcoutts on string fusion, SPJ on call patterns
08:56:59 <dons> ok, cool. the important ones :)
08:57:01 <dcoutts_> cool :-)
08:57:10 <oerjan> sjanssen: uld be
08:57:24 <dons> i think stefan recorded the whole thing , but we'll have to contact him to find out what they're doing
08:57:41 <malcolmw> dons: but nowhere to host them, unless I can persuade pejo to take them as well
08:58:13 <pejo> malcolmw, how much in total?
08:58:23 <malcolmw> dons: yeah, all of the ICFP sessions was recorded officially, but it is going to take the organisers quite a while to post-process them.
08:58:28 <dons> malcolmw: so you were just unable to load them on blip.tv ?
08:58:37 <dons> or google. due to some problems of unknown nature?
08:58:49 <malcolmw> dons: blip.tv kept stalling on upload - I tried 6 or 7 times
08:59:07 <malcolmw> google video truncated most of the uploads
08:59:33 <malcolmw> dailymotion.com has a max size of 100Mb
08:59:40 <malcolmw> all these limitations...
08:59:54 <dons> hmm. i wonder how the oscon videos made it onto blip.tv
09:00:11 <sjanssen> malcolmw: can you cut the quality down a bit?
09:00:35 <malcolmw> sjanssen: what, even further? :-)
09:00:58 <dons> hah
09:01:03 <dons> sjanssen: you just want sound/
09:01:16 <malcolmw> ivant has complete sound recordings
09:01:35 <dons> hey nominolo
09:01:35 <sjanssen> malcolmw: the quality is pretty good
09:01:52 <sjanssen> it could stand to be worse if it makes distribution easier
09:01:59 <dons> what format were the oscon videos/
09:02:06 <dons> they weren't too large, but were rather crisp
09:03:38 <nominolo> hi dons
09:05:22 <Tac-Work> How would I wrap up the expression: do x1 <- [0..9]; x2 <- [0..9]; ....; x100 <- [0..9]
09:05:57 <malcolmw> dons: I don't think I can tell offhand what format the OSCON video uses.  It has been converted to flash for display.
09:05:58 <shachaf> halcyon10: The S combinator.
09:06:11 <shachaf> halcyon10: \x y z -> x z (y z)
09:06:36 <sjanssen> Tac-Work: you probably want a return statement at the end?
09:07:22 <dons> malcolmw: oh, there's downloadable ones though
09:07:37 <mauke> > replicateM 100 [0 .. 9]
09:07:40 <lambdabot>  [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:07:42 <halcyon10> shachaf: i see, thanks.
09:07:52 <Tac-Work> (sjanssen, yeah, I have return)
09:07:54 <dons> OSCON-OSCON2007SimonPeytonJones914.mov
09:07:54 <dons> OSCON-OSCON2007SimonPeytonJonesATasteOfHaskellPartI455.mov
09:07:59 <mauke> > replicateM 3 [0 .. 9]
09:08:00 <lambdabot>  [[0,0,0],[0,0,1],[0,0,2],[0,0,3],[0,0,4],[0,0,5],[0,0,6],[0,0,7],[0,0,8],[0,...
09:08:14 <dons> OSCON-OSCON2007SimonPeytonJones914.mov: Apple QuickTime movie file (ftyp)
09:08:23 <Tac-Work> > replicateM 3 [0..3]
09:08:25 <lambdabot>  [[0,0,0],[0,0,1],[0,0,2],[0,0,3],[0,1,0],[0,1,1],[0,1,2],[0,1,3],[0,2,0],[0,...
09:08:28 <Tac-Work> cool
09:10:47 <nominolo> malcolmw, were those videos recorded with the camera on the tripod in the middle?  the angle seems different
09:11:23 <malcolmw> nominolo: no, my camera was sitting on a table near the front, at the side
09:12:01 <nominolo> malcolmw, ah, guessed so
09:16:07 <dcoutts_> hia nominolo
09:16:20 <nominolo> anyone tried Frank Pfenning's approach to tridirectional typechecking for Haskell and see if it improves error messages?
09:16:29 <nominolo> hia dcoutts_
09:17:10 <dcoutts_> nominolo: or the helium approach of scripted constraint solving
09:17:44 <nominolo> dcoutts_, haven't heard of that?  got a link? or a name?
09:17:53 <dcoutts_> @where helium
09:17:53 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
09:18:10 <nominolo> ah, nice
09:18:12 <dcoutts_> nominolo: they have a bunch of papers on doing type checking by constraint solving
09:18:42 <dcoutts_> nominolo: the traditional HM algorithm is just one particular order of solving the constraints
09:18:58 <dcoutts_> you can use any order and get the correct result
09:19:05 <malcolmw> the yhc typechecker GSoC project went with constraint-solving as its approach
09:19:14 <dcoutts_> but by being cunning about the order you can get better error messages
09:19:27 <dcoutts_> that's somewhat heuristic
09:19:55 <dcoutts_> and helium then has an extensible scripting system for the solving order heuristics
09:20:01 <dcoutts_> hia SyntaxNinja
09:20:04 <nominolo> i see
09:20:23 <malcolmw> hey, I just discovered there is a "Video resources" page linked from the haskell.org homepage
09:20:44 <dcoutts_> nominolo: so they customised the scripting based on feedback from lots and lots of undergrads solving programming tasks
09:20:54 <ddarius> Actually there are two "traditional" HM algorithms.
09:21:01 <dcoutts_> bottom up and top down
09:21:08 <ddarius> malcolmw: Indeed.
09:21:08 <dcoutts_> two instances of solving orders
09:21:45 <malcolmw> maybe that is where I should have hidden the link to the HW vids, to dampen down demand :-)
09:22:06 <dcoutts_> dons: so you recall the CUFP talk about language promotion and he said you should form an official non-profit to receive donations and hold central funds and resources...
09:22:28 <nominolo> malcolmw, hosting on googlevideo/youtube wasn't an option?
09:22:45 <mux> can someone recommend a gentle introduction to dependent typing? Advanced TAPL is a bit rough for me :-)
09:22:48 <dcoutts_> dons: so for example, we could approach Sun and ask for a donation of one of their multi-core boxes
09:23:19 <SyntaxNinja> y0
09:23:25 <dcoutts_> dons: we have contacts via the oxford comlab, but I expect they'd have to donate it to an 'official' body
09:23:29 <ddarius> mux: Some of the Epigram papers?  E.g. Why Dependent Types Matter?
09:23:45 <nominolo> @yarr! SyntaxNinja
09:23:45 <lambdabot> Drink up, me 'earties
09:23:55 <mux> ddarius: I came across that one but I don't think I read it, is it digestable? =)
09:23:55 <ddarius> "The Foundation for the Embetterment of Software"
09:24:03 <dcoutts_> dons: for example gentoo.org gets machines donated from various hardware vendors to use as build/test machines
09:24:05 <malcolmw> Galois seems to be acting as haskell.org's unofficial treasurer at the moment
09:24:13 <nominolo> mux, it's colo(u)red!
09:24:17 <ddarius> mux: It should be pretty friendly.
09:24:39 <dcoutts_> malcolmw: right, but I'm not sure companies would feel so comfortable with donating to galois.com
09:24:41 <mux> thanks!
09:25:24 <ddarius> Especially if they were competing corporations...
09:25:49 <malcolmw> nominolo: I've had many problems with Google Video this year.
09:25:58 <Igloo> dcoutts_: Where are you going to put this machine?
09:26:05 <dcoutts_> Igloo: no idea :-)
09:26:15 <dcoutts_> Igloo: one of haskell.org's kind sponsors
09:26:21 <dcoutts_> or in the comlab server room or something
09:26:35 <dcoutts_> Igloo: Mike Field seems to think that might be ok
09:26:45 <Igloo> Oh, cool
09:26:48 * sjanssen offers his apartment :)
09:27:01 <Igloo> sjanssen: I'm not sure you'd want the power bill  :-)
09:27:05 <sjanssen> oh, good point
09:27:08 <sjanssen> retracted.
09:27:13 <Igloo> Or the noise, for that matter
09:27:16 <dcoutts_> the multi-core sparc's are only 75 Watts
09:27:33 <malcolmw> I tried asking IBM if they would donate a Cell processor box - but they just pointed me to their downloadable simulator :-(
09:27:49 <glguy> Igloo: When I mentioned to Don that building GHC uses a users installed libraries over the bootstraped libraries (which breaks if you don't have profiling libraries installed in --user) he suggested that you would be interested to hear that.
09:28:10 <dcoutts_> malcolmw: you need to pitch it as parallel performance work, part of solving the multi-core programming headache
09:28:26 <malcolmw> dcoutts_: which is exactly the angle I was coming from...
09:28:31 <dcoutts_> right, oh well
09:28:33 <Igloo> glguy: Hmm, have you got a log showing what happened? And were you using a mk/build.mk?
09:28:46 <shapr> How expensive is it to turn haskell.org into a real separate non-profit organization?
09:28:53 <malcolmw> dcoutts_: the IBM guy seemed to think their C compiler guys had it sorted.
09:28:55 <dcoutts_> malcolmw: from the emails we've been getting from Sun, they might be more receptive
09:28:57 <shapr> Then companies wouldn't be donating to galois directly.
09:29:11 <dcoutts_> shapr: exactly, that's what we should look into
09:29:13 <shapr> malcolmw: Not sure I believe that, no matter how much I've heard about their ... octopus? compiler.
09:29:13 <glguy> Igloo: It happened building one of the 6.8 snapshots. I had X11 built from darcs and installed in my home directory
09:29:33 <glguy> Igloo: but I didn't have profiling version of it. I only added the SplitObj=NO
09:29:36 <glguy> to config.mk
09:30:19 <glguy> the HGL library failed
09:30:29 <glguy> to build because of that
09:30:44 <glguy> to fix it I temporarily renamed my .ghc
09:30:44 <shapr> dcoutts_: I've heard it's expensive/difficult to become a non-profit, mostly because of the accounting.
09:31:04 <glguy> shapr: is that how they ensure you don't make a profit?
09:31:07 <shapr> And I've heard it can easily take six to nine months to get non-profit status.
09:31:11 <shapr> glguy: Probably so :-)
09:31:59 <shapr> The accountants make sure you don't make a profit, mostly from how much they cost ;-)
09:32:36 * dcoutts_ runs off
09:34:12 <Igloo> glguy: Hmm, but wouldn't X11 have been in .ghc/...6.6...?
09:37:19 <rhabbit> has kell
09:37:37 <shapr> @seen thoughtpolice
09:37:37 <lambdabot> I saw thoughtpolice leaving #perl6 and #haskell 15h 25m 37s ago, and .
09:38:46 --- mode: ChanServ set +o shapr
09:39:06 <shapr> rhabbit: You look familiar...
09:39:11 <shapr> @protontorpedo
09:39:11 <lambdabot> is there a decent scheduler in haskell? how about a netwrok monitor?
09:39:52 <rhabbit> well
09:39:59 <rhabbit> I sincrely ask to not be banned
09:40:07 <rhabbit> I will shut it
09:40:11 <rhabbit> if you like
09:40:46 <shapr> There are already two lines in the banlist that refer to you.
09:43:03 <shapr> I think that's clear evidence...
09:43:32 <ddarius> @seen Cale
09:43:32 <lambdabot> Cale is in #oasis, #haskell, #haskell-overflow and #ghc. I last heard Cale speak 7h 40m 1s ago.
09:44:44 * roconnor waves to conal
09:45:06 * conal waves back
09:45:13 <ddarius> @tell Cale Is your "when to use strictness/non-strictness" advice on the wiki?  If not, why not?
09:45:13 <lambdabot> Consider it noted.
09:45:22 * matthew_- performs a man in the middle attack on the waving
09:45:55 <Vulpyne>  /msg lambdabot @pl Just ((\(x,y) -> (x,drop 1 y)) (break (=='?') p))
09:45:59 <Vulpyne> Dammit.
09:45:59 * ski invokes the particle-wave duality
09:46:18 <ski> Vulpyne : `/query lambdabot' ?
09:46:34 * centrinia looks at the particle-wave.
09:46:36 <ddarius> ski: He just had a space.
09:46:44 <Vulpyne> I don't use it enough to use up a window with a query. :)
09:46:59 <Vulpyne> Yeah, I accidently typed a space somehow.
09:47:44 <ski> ddarius,Vulpyne : istr in ircII `query' per default used the current window, nota new one
09:48:18 <Vulpyne> I know, but then I wouldn't be able to type to the channel without turning it off or doing a /msg.
09:48:31 <Saizan_> launching runghc Setup configure(on any package) with ghc-6.8.20071005 kills my machine, known bug?
09:48:54 <centrinia> Woah, that's both old and developmental.
09:49:11 <ski> (Vulpyne : well, couldn't you `/msg #haskell ...' ? :)
09:49:29 <ski> (oh, which was what you said, ignore)
09:49:36 <Vulpyne> No problem.
09:49:47 <centrinia> Sorry, not old. I misread it as 20070105 :(
09:49:59 <ddarius> centrinia: It's a whole week old!
09:50:42 <centrinia> I should stop eatting spoiled Curry. :(
09:51:30 <Vulpyne> Being spoiled gives it character.
09:51:46 <centrinia> Oh, quick question: is it bad practice to use folds to pass along state?
09:53:11 <roconnor> centrinia: it kinda strikes me as a good idea.
09:53:21 <roconnor> but I'm not sure
09:53:24 <centrinia> Oh, good.
09:53:46 <glguy> I do it with foldM
09:53:49 <sjanssen> centrinia: that seems fine to me
09:53:56 <glguy> (in particular)
09:54:24 <Saizan_> i've seen a comment in xmonad like "fold as a poor man state monad"
09:54:42 <sjanssen> foldl in particular is all about repeatedly changing an accumulator, which is just another word for state
09:55:14 <Tac-Work> sjanssesn: One could make the argument that monads are a rich man's way to do state
09:55:23 <centrinia> I used a foldl to do a depth first search topological sort.
09:55:28 <Vulpyne> People sometimes say "poor man's" to mean "lightweight" rather than "inferior".
09:55:28 <roconnor> is light-weight a better phrase than poor-man's
09:55:43 <roconnor> Vulpyne: :)
09:55:50 <Vulpyne> Great minds!
09:56:00 <centrinia> Some say, "poor man's" to mean "requiring less effort to implement".
09:56:37 <dmwit> Depth-first search topological sort seems like a bad idea.
09:57:08 <centrinia> Oh, maybe that's why I got a weird feeling about my program.
09:58:20 <dmwit> I mean, it gives the wrong answer, doesn't it?
09:58:42 <centrinia> No, it doesn't.
09:59:14 <centrinia> I just mark what I have visited. That's the state that I was referring to.
10:00:03 <centrinia> It does get into an infinite recursion upon encountering a loop.
10:00:22 <dons> dcoutts_: hmm!
10:00:36 <dons> i bet we could get some hardware if we had an obvious body to hold the funds
10:01:16 <shapr> dons: Maybe we could use the leftover SoC money (if there is any) to set up such a thing?
10:01:18 <shapr> SyntaxNinja: ping?
10:01:23 <dons> right.
10:03:04 <malcolmw> leftover money?  you mean from last year?  we are about to get paid again, for this year's SoC
10:03:40 <shapr> Works for me.
10:04:15 <malcolmw> but I don't know how much is sitting in the bank right now
10:04:41 <shapr> I bet CosmicRay would know something about non-profit organizations.
10:05:11 <malcolmw> yeah, we vaguely investigated joining the software freedom something or other, that he is affiliated with
10:06:07 <malcolmw> is US non-profit status mainly a way of dealing with tax issues?
10:06:23 <rhabbit> its kind of a weird tax saving maneuver
10:06:35 <malcolmw> because it might be easier to set up a UK organisation
10:08:15 <shapr> malcolmw: But where would the hardware physically live?
10:08:28 <malcolmw> shapr: does it matter?
10:09:11 <malcolmw> dcoutts_ was thinking about locating any donated Sun hardware in Oxford
10:09:48 <dons> yeah, we've places in the UK, the US, Sweden and Sydney at least that could host hardware
10:11:50 * malcolmw -> gone
10:15:06 <SyntaxNinja> hi shapr
10:15:16 <glguy> QUACK
10:15:31 <shapr> hiya SyntaxNinja, did you see the non-profit haskell.org discussion?
10:15:32 <SyntaxNinja> glguy: wrong channel
10:15:49 <glguy> SyntaxNinja: maybe it would catch on
10:16:04 <SyntaxNinja> shapr: nope. whereabouts?
10:16:17 <shapr> Last half hour here on #haskell
10:16:37 <shapr> In short, companies are more likely to donate highly parallel hardware to haskell.org than to galois.
10:17:04 <glguy> without reading up, are companies likely to do either yet?
10:17:11 <centrinia> Is a Message Passing Haskell a good or bad idea?
10:17:22 <glguy> centrinia: Control.Concurrent.Chan
10:17:27 <centrinia> Cool.
10:18:17 <SyntaxNinja> shapr: I do think it would be useful to create a non-profit.
10:18:43 <puusorsa> it would not be profitable to create a non-profit?
10:18:58 <SyntaxNinja> Galois is handy as a legal entity to handle legal thingies relating to getting money from google, but it would probably be better for Haskell.org to handle it themselves
10:19:02 <SyntaxNinja> ourselves ;)
10:20:08 <SyntaxNinja> but a new non-profit is probably not the way to go. we could latch onto the one that Debian uses, whose name escapes me for the moment
10:20:14 <SyntaxNinja> but cosmicray used to be chair or whatever
10:20:40 <SyntaxNinja> SPI?
10:21:30 <SyntaxNinja> but I don't know who would be more likely to donate hardware and bandwidth than Galois
10:22:11 <glguy> Galois might be likely to do it if they could write off the taxes!
10:23:48 <paczesiowa> is it bug or a feature that I can't use '#' at the beginning of a line in literate style?
10:24:40 <glguy> What is an example of why you would want to?
10:24:53 <glguy> OH, you mean in the comment part
10:25:08 <nominolo> paczesiowa, presumably a feature
10:25:20 <glguy> # might make the parser look for cpp preprocessor directives?
10:25:21 <paczesiowa> yes I mean normal line (without "> ")
10:25:29 <paczesiowa> :/
10:25:32 <dmwit> That sounds like a bug to me... what if you want #! lines?
10:26:24 <dons> looks cute, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/flow2dot-0.2
10:26:27 <lambdabot> http://tinyurl.com/2kdbbo
10:26:36 <dons> `Generates sequence diagrams from textual descriptions'
10:26:46 <paczesiowa> if # is the the only character on the last line then there is "lexical error (UTF-8 decoding error)"
10:27:23 <paczesiowa> is it possible to compile the same file as haskell and C?
10:27:42 <roconnor> yes
10:27:58 <roconnor> er, I think
10:28:04 <roconnor> maybe literate haskell is needed..
10:28:22 <paczesiowa> that's what I'm trying atm
10:28:45 <paczesiowa> but I think I need some #define > // and then ghc doesn't want to compile it
10:31:55 <oerjan> :t (//)
10:31:58 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
10:32:28 <conal> idea: let's create a competitor to X that uses Haskell code (in some form) to replace the X protocol.  the win is a huge boost in compression.
10:33:06 <dons> there's XCB, the stripped down X.
10:33:13 <dons> it talks the protocol, but is a lot smaller than Xlib
10:33:17 <dons> sjanssen's done some work on it
10:33:47 <conal> still, it would have to "decompress" before sending over the wire.
10:34:05 <conal> in the sense that a program is a compressed form of its stream of output.
10:34:44 <conal> so X (anything with a wire protocol) is based on the idea of decompressing before transmitting.
10:35:03 <dmwit> You'd still have to provide the X API if you want anybody to adopt it, which would pretty much defeat the purpose of creating a new X.
10:36:17 <conal> dmwit: that's the usual argument against fundamental innovation.  sometimes, however, a good enough idea with at least one clear enough payoff can create its own opportunity to succeed.
10:37:01 <dmwit> 99% of the time, the argument against fundamental innovation is correct.
10:37:06 <n00b> I want to know which is better for GUI creation wxhaskell or Gtk2hs
10:37:07 <n00b> ??
10:37:24 <n00b> @how are you lambdabot ?
10:37:24 <lambdabot> Maybe you meant: show yow
10:37:31 <n00b> @how are you lambdabot
10:37:32 <lambdabot> Maybe you meant: show yow
10:37:34 <dmwit> n00b: It depends on what you want to do, I guess.
10:37:37 <conal> any other reactions, anyone?
10:37:40 <dmwit> @vixen how are you?
10:37:40 <lambdabot> i'm good, you?
10:37:45 <paczesiowa> n00b: do you know wx or gtk api?
10:38:19 <n00b> nope want to learn one for the creation of a email client and calculator for a project
10:38:27 <n00b> which is easier to learn ??
10:38:32 <dmwit> Then it probably doesn't matter which you pick.
10:38:43 <n00b> why ??
10:39:14 <paczesiowa> gtk is installed on almost every unix desktop
10:39:15 <conal> n00b: currently, wxhaskell is more elegant, while Gtk2hs is better supported.
10:39:30 <n00b> ok
10:39:54 <n00b> but I can't seem to find any decent tutorial for wxhaskell
10:40:04 <paczesiowa> but there is nice tutorial for gtk, and there is glade
10:40:09 <n00b> @google wxhaskell tutorial
10:40:11 <lambdabot> http://wxhaskell.sourceforge.net/quickstart.html
10:40:11 <lambdabot> Title: A quick start with wxHaskell
10:40:44 <n00b> i have been fooling around
10:41:01 <n00b> and it takes the work off design the user interface
10:41:14 <n00b> all i would have to do is program
10:41:38 <n00b> but then again, it would make me wayward and probably lazy, you think ??
10:42:08 <dmwit> Lazy is good.
10:42:29 <dmwit> But have you seen glade?  It really helps write a lot of the design code for you.
10:43:39 <paczesiowa> glade doesn't help you write code, it helps you "click" it
10:44:31 <psnively> Testing...
10:44:45 <dmwit> paczesiowa: Oh, really?  Last time I used Glade, it basically reduced all my layout code to "loadXML blargle.xml" or something like that.
10:44:58 <dmwit> No more careful hbox/vbox'ing, packing, etc.
10:46:12 <n00b> i know
10:46:21 <n00b> but it makes you lazy
10:46:34 <paczesiowa> I know that, it's just using glade doesn't have anything with writing code (besides not writing it:)
10:46:36 <conal> doesn't it strike anyone else as odd (and an opportunity) that a wire protocol (X) designed for internet use requires decompression before transmission?
10:46:43 <n00b> I want to learn also, how to write it without
10:46:51 <allbery_b> <paczesiowa> I know that, it's just using glade doesn't have anything with writing code (besides not writing it:)
10:47:00 <allbery_b> well, it does help with code, just not for haskell
10:47:19 <n00b> but, remember you have to program the interface so that it may work
10:47:22 <dmwit> conal: No?  HTTP allows compression, as does SSH, and several other protocols.
10:47:23 <paczesiowa> version 3.* doesn't I think
10:47:29 <allbery_b> there's some foo in there for integrating C code with the interface
10:47:49 <allbery_b> a full visual IDE it is not, but that's what e.g. anjuta is for
10:47:51 <paczesiowa> that was old glade
10:47:58 <paczesiowa> ver 2.*
10:48:04 <allbery_b> hm
10:48:17 <n00b> anjunta works with haskell ???
10:48:20 * allbery_b admits he's not been tracking what they're up to
10:48:26 <allbery_b> n00b: not that I know if
10:48:41 <conal> dmwit: thanks.  i wonder if those compression methods could possibly come anywhere close to transmitting (parameterized, reusable) code instead.
10:48:49 <paczesiowa> there is eclipse plugin for haskell
10:48:51 <allbery_b> if it did maybe "is there a haskell IDE?" wouldn't be quite so much of a faq...
10:49:16 <paczesiowa> and there is plugin for VS but it crashes so much that it's unusuable
10:49:47 <n00b> I use eclipse to write my code
10:49:53 <puusorsa> emacs ftw!
10:49:59 <n00b> there's hIDE
10:50:40 <puusorsa> is it any good?
10:50:58 <n00b> when I create the calculator in glade, wouldn't i have to program it in haskell ???
10:50:59 <paczesiowa> is it finished?
10:51:18 <paczesiowa> you just attach haskell IO actions as signals to widges
10:51:23 <paczesiowa> *widgets
10:51:24 <conal> X protocol is, I think, a filtered execution trace of a program, with loops unrolled, etc.  Sure, one can compress a trace to some degree.  I doubt any post-execution compression could compete with pre-execution information.
10:51:28 <puusorsa> is it usable? i doubt anything in haskell is finished
10:53:22 <n00b> anjunta uses glade dynamic libaries
10:53:50 <Cale> Using gladde with gtk2hs is pretty easy
10:53:50 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:53:51 <n00b> it is a fork
10:53:54 <Cale> glade*
10:54:30 <n00b> anjunta
10:54:31 <dmwit> conal: Part of the reason I use X is so that I can execute the program on a computer I'm not sitting at; if I follow you correctly, your proposal would nullify that advantage.
10:55:14 <sjanssen> conal: what do you mean regarding X protocol compression?
10:55:55 <sjanssen> conal: the X protocol is already pretty compact
10:56:16 <n00b> so which is easier to learn, Gtk2hs or wxhaskell ???
10:56:35 <sjanssen> conal: it only uses extra space in a few places, notably because it uses a constant packet size
10:56:38 <conal> dmwit: remote execution is exactly the case i'm talking about
10:56:42 <dmwit> n00b: In the time you have spent here asking about them, you could have learned one. ;-)
10:56:44 <sjanssen> which has lots of benefits
10:56:59 <paczesiowa> I'd go with gtk, there are probably more ppl who know htk than wx
10:57:02 <glguy> compression can be introduced to the X protocol remotely via SSH
10:57:35 <glguy> tips for being taken seriously. nick /= noob, fewer question marks
10:57:36 <eric-at-bebr> noob: you wanted the easiest. glade was described as being the easiest. you thought it was too easy. is this a correct summary?
10:58:23 * roconnor learned last week that it is indeed possible to install wxHaskell
10:58:25 <conal> sjanssen: i mean that code execution is decompression.  instead of executing and then trying to figure how to compress, transmit the pre-executed form.
10:58:38 <puusorsa> was the problem that glade does not count as programming? :)
10:58:53 <n00b> yes
10:59:01 <n00b> i am going
10:59:07 <n00b> with gtk2hs
10:59:14 <dmwit> conal: I don't even think that's possible, in general.  What if the execution requires files that are on disk, or the remote architecture is different from the execution architecture?
10:59:17 <conal> sjanssen: of course one could additionally compress the (non-executed) code itself.
10:59:28 <eric-at-bebr> n00b: glade is not programming in the sense that any higher level language isn't "real" programming
10:59:30 <sjanssen> okay, I see what you mean here
10:59:32 <n00b> so you know where I can find some good tutorial on wxhaskell (not google)
11:00:12 <conal> dmwit: all great points.  and reasons to use a declarative language as the basis.
11:00:29 <puusorsa> http://wxhaskell.sourceforge.net/quickstart.html
11:00:29 <lambdabot> Title: A quick start with wxHaskell
11:00:44 <sjanssen> conal: you want a domain specific graphics generation code sent over the wire
11:00:45 <n00b> tried that, basic stuff
11:01:05 <n00b> i want some tut on layout and button action
11:01:15 <sjanssen> conal: this could probably be done as an extension to the X protocol, no need to throw out the whole thing
11:01:19 <bos> did anyone go to last night's bayfp meeting?
11:01:52 <conal> sjanssen: oh.  cool.  then there could be a transition path, rather than all-or-nothing.
11:02:51 <sjanssen> conal: I'm not sure that such a thing will gain much traction
11:03:05 <sjanssen> conal: I don't think C programmers will want to generate this code :)
11:03:29 <CosmicRay> shapr: got your email.  does it make sense to discuss this here anymore?
11:04:28 <conal> sjanssen: i don't think so either!  so they'll continue to do their "decompression" (execution) before transmitting, and we'll have better performance.
11:05:10 <sjanssen> conal: and if the C programmers won't use it, I bet you'll have a hard time getting X.org to adopt it
11:06:07 <eric-at-bebr> Every C programmer I've talked too was very performance oriented. If you can make the case that this is faster, I can imagine getting some adoption from the C crowd.
11:06:44 <eric-at-bebr> Just make sure there's a C library that does that generation for them :-P
11:06:53 <conal> sjanssen: is there a notion of "plugin" for extending the X protocol?
11:07:28 <sjanssen> conal: the X protocol does have open extension
11:08:02 <sjanssen> conal: but to use an extension, both the server and the client need to know about it
11:09:43 <sjanssen> conal: I've heard that hacking the X.org server is not pleasant
11:09:57 <rey_> conal: do you know about display postscript?
11:10:23 <n00b> where can i find some tut on wxhaskell
11:10:28 <n00b> @google haskell
11:10:30 <lambdabot> http://www.haskell.org/
11:10:31 <lambdabot> Title: Haskell - HaskellWiki
11:10:37 <conal> rey_: yes.  what i'm suggesting is essentially what Gosling designed for the NeWS windows system, based on display postscript.
11:10:44 <n00b> @google wxhaskell advance tutorial
11:10:45 <lambdabot> http://wxhaskell.sourceforge.net/quickstart.html
11:10:46 <lambdabot> Title: A quick start with wxHaskell
11:12:08 <psnively> Poor NeWS. As usual, the right thing... about a decade and a half too early.
11:12:12 <conal> also what Gosling et al designed as client-side Java.  but done more elegantly, leveraging Haskell's strengths as highly factorable and inherently safe.
11:12:50 <conal> psnively: agreed.  and maybe still ahead of its time.
11:12:55 <hpaste>  twanvl pasted "Just for fun: C and Haskell in the same source file" at http://hpaste.org/3256
11:12:59 <psnively> s/maybe//
11:13:09 <conal> :)
11:13:27 <psnively> :-D
11:16:19 <earthy> actually, NeWS might have made it
11:16:32 <earthy> had it not been Yet Another Sun Product
11:16:51 <rey_> oh, the free DPS project is dead
11:16:55 <nominolo> conal, is there a link to NeWS?
11:16:57 <earthy> it actually had a strong marketing problem in that regard
11:17:02 <rey_> I thought the gnustep folks were still working on it
11:17:06 <nominolo> the name isn't very google-friendly
11:17:38 <conal> nominolo: there's http://en.wikipedia.org/wiki/NeWS
11:17:52 <nominolo> thanks
11:17:57 <rey_> (they claim "For reasons of both efficiency and functionality, it is often better to use DPS as a low-level rendering interface and put high-level libraries on the client side.")
11:18:26 <conal> so, yes, my suggestion is to revive the essential NeWS idea, but replacing display postscript with Haskell.  i wouldn't use IO either, but something much more disciplined about possible effects.
11:18:29 <nominolo> pie menus!
11:18:29 <earthy> that is actually quite complete indeed, nominolo
11:18:41 <earthy> conal: interesting project!
11:19:01 <conal> earthy: thanks!
11:19:08 * earthy just so happens to have the four volumes NeWS lying around. :)
11:19:15 <earthy> NeWS programmer's guide etc.
11:19:41 <dmwit> twanvl: Clever!
11:19:57 <dmwit> int :: Integral c => a -> [b] -> c
11:19:58 <dmwit> =)
11:20:03 <conal> BTW, I worked for a few months on the X/NeWS hybrid window system at Sun.  My first "real job" out of grad school.
11:20:49 <psnively> Yeah, NeWS today would rock.
11:20:58 <psnively> You'd presumably have a JITting PS compiler...
11:21:15 <conal> or a JITting HS compiler!
11:21:35 <psnively> Yeah. Time to translate "Functional PostScript" to Haskell?
11:21:35 <conal> static typing, better modularity, etc.
11:21:41 <sjanssen> I don't see many benefits except for remote clients
11:21:51 <earthy> actually, today i'd build it on either the CLR or the JVM
11:21:51 <sjanssen> remote, low bandwidth clients
11:21:58 <conal> sjanssen: yeah -- remote client is really the point.
11:22:11 <earthy> well.. part of the point
11:22:25 <conal> earthy: go on...
11:22:42 <earthy> the other part of the point is very strong separation between UI and compute code
11:23:22 <earthy> and the ability to upload UI code to the displaying computer, and the fact that the displaying computer has a very well defined runtime environment dedicated to doing UI stuff
11:24:28 * psnively now has mental images of writing a window system entirely in pixel shaders for modern GPUs. Run away!
11:24:59 <roconnor> Unix, I know Unix!
11:25:01 <earthy> um. that's actually not that different from what Core Graphics and Quartz Extreme do already. :)
11:25:13 <conal> psnively: sounds great to me.  of course, a modern GUI framework would target GPUs.
11:25:31 <conal> at least as an option.
11:26:04 <psnively> earthy: That's a bit of a stretch... they really just use FBOs. Which is, I have to admit, a nice start.
11:26:05 <conal> again, a strong argument for a *declarative* approach, abstracted above implementation details.  then we can target CPUs and GPUs both.
11:26:20 <conal> psnively: "FBOs"?
11:26:23 <earthy> but, the main beauty of NeWS was the ability for a program to extend the UI toolkit present on the display server.
11:26:27 <psnively> Frame Buffer Objects.
11:26:39 <conal> oh.
11:27:02 <psnively> A very nice OpenGL 2.x feature, used a lot by folks who do, e.g. do nasty matrix computations by treating OpenGL textures as matrices.
11:27:05 <earthy> uhm, Core Graphics does more, doesn't it?
11:27:23 <psnively> Yeah, but still not with shaders (because it can't assume the existing of pixel/vertex shaders on all hardware it runs on).
11:27:49 <earthy> ISTR it uses shaders when present and CPU code when not...
11:27:57 <earthy> (consequently being a lot slower)
11:28:22 <psnively> Hmmmm. I'd be surprised; how would it know how much VRAM to leave to non-Core Graphics apps?
11:28:37 <psnively> Eh... I imagine these days you're right anyway. :-)
11:28:44 <kscaldef> does anyone have recommendations for tracking down / fixing resource leaks?  In this case, my program appears to have a file descriptor leak
11:28:46 <earthy> anyway, conal, do you have a writeup of your ideas wrt a haskell based windowing system?
11:29:57 <earthy> (I might have to go afk soonish, to change my newborn son's diapers and have him fed)
11:31:01 <conal> earthy: nothing at all.  i just got inspired about the idea at icfp last week.
11:31:31 <conal> earthy: congrats, dad!
11:31:49 <earthy> thanks. it's the reason I wasn't at ICFP in fact. :)
11:32:09 <conal> yep.  baby trumps conference.  :)
11:33:04 <Heffalump> ooh, congratulations
11:38:08 * earthy ponders the idea of NeHWS a bit more...
11:41:05 <conal> i hadn't thought about the aspect of separating UI from application code.  perhaps there's a nice connection to TV (http://haskell.org/haskellwiki/TV), which makes that separation cleanly for Haskell programs.
11:41:06 <lambdabot> Title: TV) - HaskellWiki
11:41:10 * locomalo is away: Ausente
11:41:53 <earthy> conal: there might well be...
11:42:17 <earthy> where you'd upload the TV lib ones, and then only exchange the values over the wire, and not the UI stuff
11:42:24 <earthy> s/ones/onece
11:42:26 <earthy> -e
11:43:23 <conal> earthy: yes, a trick we could play very generally.
11:43:34 <kscaldef> help tracking down resource leaks?  Anyone?   Is this the sort of thing where adding strictness helps?  Or should I be taking another approach?
11:44:25 <conal> i was specifically thinking of TV as a means of pairing UI & functionality, keeping them combined & separable, which is the key to composability of UIs.
11:44:27 <CosmicRay> shapr: you've got mail
11:44:29 <earthy> kscaldef: if you're leaking file descriptors you're obviously hanging on to stuff
11:44:38 <earthy> that you don't want to keep around
11:44:57 <earthy> adding strictness might help, but that's tricky
11:45:15 <kscaldef> earthly: well, _I'm_ not obviously hanging onto stuff, although I suspect HXT might be
11:45:29 <kscaldef> (or, at least, it isn't obvious to me that my code is hanging onto stuff)
11:46:20 <earthy> sorry, diaper time
11:46:24 <kscaldef> basically, I'm writing a web spider.  I read a document with HXT, grab out all the links, and repeat.  Eventually it dies because I run out of file descriptors
11:46:50 <kscaldef> but, I don't see any way to force HXT to close the socket after it's done reading the document
11:46:50 <earthy> ah, but you're doing it lazily and you hang on to the links, right?
11:47:02 <kscaldef> yes
11:47:16 <earthy> there you go then. :)
11:47:39 <earthy> nothing is closed until you actually process all the links
11:47:56 <earthy> because only then they'll be needed
11:48:06 <kscaldef> (or, sort of lazily, since things are happening in the IO monad, so some sequencing is applied)
11:48:09 <earthy> and upto then you need the filedescriptors
11:48:49 <kscaldef> hmm... so probably I need to figure out how to select the links in a strict manner?
11:50:15 <kscaldef> oh, wait... HXT has an ArrowStrict module.  That might be just what I need
12:02:55 <Baughn> @hoogle [a] -> a -> a -> [a]
12:02:56 <lambdabot> No matches, try a more general search
12:10:59 <Baughn> Is there a quicker way to say `foldr (\c l -> (if c == '@' then " (at) " else [c]) ++ l) []' ?
12:11:56 <Botje> not really
12:12:30 <roconnor> > foldr (\c l -> (if c == '@' then " (at) " else [c]) ++ l) [] "foocexample.org"
12:12:35 <lambdabot>  "foocexample.org"
12:12:41 <roconnor> > foldr (\c l -> (if c == '@' then " (at) " else [c]) ++ l) [] "foo@example.org"
12:12:42 <lambdabot>  "foo (at) example.org"
12:13:04 <Botje> Baughn: using concatMap would be a trifle better, i guess
12:13:23 <roconnor> (\c -> if c == '@' then " (at) " else return c) =<< "foo@example.com"
12:13:28 <roconnor> > (\c -> if c == '@' then " (at) " else return c) =<< "foo@example.com"
12:13:30 <lambdabot>  "foo (at) example.com"
12:13:34 <xerox__> > "foo@example.org" >>= (\x -> case x of '@' -> " at "; '.' -> " dot "; c -> [c])
12:13:35 <lambdabot>  "foo at example dot org"
12:13:48 <Baughn> :t concatMap
12:13:50 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
12:14:05 <roconnor> > let f '@' = " (at) "; f c = return c in f =<< "foo@example.com"
12:14:06 <lambdabot>  "foo (at) example.com"
12:15:47 <Baughn> > let if' b c a = if a then b a else c a in concatMap (if' (== '@') (const " (at) ") id) "foo@example.org"
12:15:47 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Char'
12:16:00 <roconnor> Baughn: return, not id
12:16:20 <Baughn> > let if' b c a = if a then b a else c a in concatMap (if' (== '@') (const " (at) ") ([])) "foo@example.org"
12:16:21 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Char'
12:16:34 <roconnor> :[] not []
12:16:40 <Baughn> ..I'll use the foldr.
12:17:45 <EvilTerran> (:[]) = return, if you prefer that
12:19:00 <EvilTerran> hm... yeah, i guess the foldr might work better
12:19:21 <doserj> Baughn: you if' was also wrong
12:19:35 <Baughn> doserj: I should find a different name, I know
12:19:41 <EvilTerran> bool?
12:20:05 <Baughn> doserj: ..probably cond. And a bit of generalization.
12:21:28 <doserj> ehm, I don't yee how you version should work...
12:21:32 <doserj> *see
12:22:19 <doserj> where do you get the first Bool value?
12:27:25 <Botje> .oO(there should be a Golf module)
12:27:34 <doserj> >  let if' b c d a = if b a then c a else d a in concatMap (if' (== '@') (const " (at) ") return) "foo@example.org"
12:27:36 <lambdabot>  "foo (at) example.org"
12:28:40 <EvilTerran> Botje, surely it should be called "G" so it takes less characters to import? :P
12:29:58 <hpaste>  ico pasted "Wheres' my error in this small snippet ?" at http://hpaste.org/3257
12:30:57 <ico> Any of the regulars have a few seconds for me ?
12:31:10 <sjanssen> ico: do you get a compiler error?
12:31:13 <ico> nope
12:31:15 <ico> compiles fine
12:31:20 <ico> but doesn't stop at 80 chars
12:31:22 <ski> > do x <- "foo@example.org"; maybe [x] id (lookup x [('.'," DOT "),('@'," AT ")])
12:31:23 <lambdabot>  "foo AT example DOT org"
12:31:32 <EvilTerran> doserj, that if' looks like liftM3 <normal if'> to me
12:31:32 <dmwit> ico: It drops words that are more than 80 characters (each).
12:31:43 <sjanssen> dmwit: it doesn't even do that
12:31:46 <dmwit> ico: If you want 80 characters total, you'll have to do the dropWhile first, then the other things.
12:31:58 <dmwit> sjanssen: You're right, it stops at the first long word.
12:32:00 <doserj> EvilTerran: yep
12:32:02 <EvilTerran> (into reader)
12:32:03 <sjanssen> right
12:32:08 <ico> hmmm, that's not what I ment no :)
12:32:11 <Baughn> doserj: My version of if' was modified on the fly to fit better, and I kinda forgot about the /condition/
12:32:16 <EvilTerran> mif'? =)
12:33:15 <dmwit> ico: You'll probably need a fold or scan to accomplish what you want.
12:33:21 <ski> m Bool -> m a -> m a -> m a
12:33:40 <ico> problem is that I don't yet see why it behaves as it does now
12:33:58 <dmwit> ico: "hop = unwords . init . words . take 80" gets close, but it might drop the last word, even if it was pre-80 characters.
12:34:18 <Cale> ico: You're forming a list of words, then taking from them so long as you don't run into a word which is greater or equal to 80 chars.
12:34:21 <ico> @init
12:34:21 <lambdabot> Not enough privileges
12:34:34 <dmwit> :t init
12:34:36 <lambdabot> forall a. [a] -> [a]
12:34:37 <ico> sorry :)
12:34:50 <dmwit> ico: I might have a "wrap" function squirreled away here somewhere...
12:36:08 <hpaste>  dmwit annotated "Wheres' my error in this small snippet ?" with "Wraps multiple lines to a given length, preserving "line breaks"" at http://hpaste.org/3257#a1
12:36:08 <ico> but why does the lambda look at the length of each list item from words(), instead of at the total length of s, like I ment to do ?
12:36:27 <Botje> because that's what takeWhile does
12:36:40 <ico> oh ofcourse
12:36:40 <ico> yes
12:36:45 <Botje> it asks if every element in turn still satisfies the predicate
12:36:56 <ico> the s in the lambda is not the same as the outer s of course
12:37:00 <ico> that's stupid of me
12:37:07 <ico> ok, all clear now
12:37:34 <EvilTerran> > (\ws -> zip (scanl ((+).length) 0 ws) ws) (words "the quick brown fox jumped over the lazy dog")
12:37:35 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
12:38:33 <EvilTerran> > (\ws -> zip (scanl ((.length).(+)) 0 ws) ws) (words "the quick brown fox jumped over the lazy dog")
12:38:37 <lambdabot>  [(0,"the"),(3,"quick"),(8,"brown"),(13,"fox"),(16,"jumped"),(22,"over"),(26,...
12:39:59 <dmwit> Ugh, I always get repeat and replicate mixed up.
12:40:40 <Cale> > scanl1 (\(x,y) (x',y') -> (x++" "++x',y+y'+1)) . map (id &&& length) $ (words "the quick brown fox jumped over the lazy dog")
12:40:42 <lambdabot>  [("the",3),("the quick",9),("the quick brown",15),("the quick brown fox",19)...
12:41:02 <ico> wow
12:41:10 <ico> so much for readability
12:41:14 <ico> or is that just me
12:41:36 <Cale> @pl (\(x,y) (x',y') -> (x++" "++x',y+y'+1))
12:41:39 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip (flip . ((+) .) . (+)) 1) . flip . (((.) . (,)) .) . (. (' ' :)) . (++))
12:41:40 <Cale> heh
12:41:45 <dmwit> I was about to do that. =)
12:41:48 <ico> hehe
12:42:30 <hpaste>  Botje annotated "Wheres' my error in this small snippet ?" with "simple tail-recursive version" at http://hpaste.org/3257#a2
12:42:38 <dmwit> ?pl \s -> f (g s) s
12:42:39 <lambdabot> f =<< g
12:42:39 <mgsloan> is there anything like mapWithIndices :: (a -> Int -> b) -> [a] -> [b]
12:42:57 <Cale> mgsloan: map . zip [0..] ?
12:42:58 <ico> Botje: yes, that is what I was looking for
12:43:08 <Cale> er, not quite that :)
12:43:13 <EvilTerran> ?type (\f xs -> map (uncurry f) . zip xs [1..])
12:43:16 <lambdabot>     Couldn't match expected type `a -> [(a1, b)]'
12:43:16 <lambdabot>            against inferred type `[(a2, t)]'
12:43:17 <Cale> :t map ?f . zip [0..]
12:43:20 <lambdabot> forall b t b1. (?f::(t, b1) -> b, Num t, Enum t) => [b1] -> [b]
12:43:25 <EvilTerran> ?type (\f xs -> map (uncurry f) $ zip xs [1..])
12:43:27 <lambdabot> forall b c a. (Num b, Enum b) => (a -> b -> c) -> [a] -> [c]
12:43:37 <olsner> @type let mapWithIndices f xs = zipWith f xs [0..] in mapWithIndices
12:43:39 <lambdabot> forall a b c. (Num b, Enum b) => (a -> b -> c) -> [a] -> [c]
12:43:47 <mgsloan> ah, right, can't believe I forgot I could do that..
12:43:48 <mgsloan> thanks
12:43:58 <Cale> Yeah, zipWith makes it nice
12:44:11 <EvilTerran> ah, yes, zipWith. temporarily forgot that.
12:44:15 <dmwit> olsner++
12:44:22 <EvilTerran> yeah, zipWith f [1..]
12:44:22 <olsner> @pl let mapWithIndices f xs = zipWith f xs [0..] in mapWithIndices
12:44:22 <lambdabot> flip flip [0..] . zipWith
12:44:32 <EvilTerran> (or [0..], even)
12:45:08 <dmwit> :t flip flip
12:45:10 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
12:45:36 <olsner> @unpl flip flip
12:45:36 <lambdabot> (\ b c f -> c f b)
12:46:12 <Baughn> @pl flip.flip.flip
12:46:12 <lambdabot> flip
12:46:21 <kaol> @unpl flip flip flip
12:46:21 <lambdabot> (\ c f -> c f (\ g h i -> g i h))
12:46:30 <EvilTerran> flip.flip = id, surely?
12:46:40 <Heffalump> @type fix flip
12:46:42 <Baughn> It is. I was wondering if @pl would catch that
12:46:42 <lambdabot> forall b c. b -> b -> c
12:46:46 <Baughn> ..it's unreasonably smart.
12:47:01 <EvilTerran> it is surprisingly good, yeah
12:47:02 <olsner> I guess flip.flip constrains the type of the argument though
12:47:08 <olsner> which id wouldn't
12:47:25 <EvilTerran> okay, a more tightly typed id. picky picky! ;_
12:47:29 <EvilTerran> er, ;)
12:47:41 <olsner> this is #haskell, what'd you expect? :P
12:47:42 <Baughn> :t (id :: a -> a -> a) -- ;)
12:47:45 <lambdabot>     Couldn't match expected type `a -> a'
12:47:45 <lambdabot>            against inferred type `a' (a rigid variable)
12:47:55 <EvilTerran> Heffalump, that can't be realisable, can it?
12:47:56 <Baughn> ..er, yeah. Plus parantheses.
12:48:33 <dmwit> :t id :: (a -> a) -> (a -> a) -- and an extra -> a
12:48:35 <lambdabot> (a -> a) -> (a -> a) :: forall a. (a -> a) -> a -> a
12:48:41 <EvilTerran> @djinn b -> b -> c
12:48:41 <lambdabot> -- f cannot be realized.
12:48:52 <Baughn> @djinn a
12:48:53 <lambdabot> -- f cannot be realized.
12:49:09 <huamn_> how can i define a type for a function so that I may use the compare operator "=="?
12:49:18 <dmwit> (Eq a) =>
12:49:25 <huamn_> ok, thanks
12:49:33 <dmwit> :t \x y -> x == y -- like this
12:49:36 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:49:37 <Heffalump> EvilTerran: it's bottom
12:49:41 <Baughn> > id == id
12:49:42 <lambdabot>   add an instance declaration for (Eq (a -> a))
12:49:42 <lambdabot>     In the expression: id == ...
12:49:47 <Heffalump> it's clearly realisable, I did so
12:49:50 <EvilTerran> it's <<loop>>, even, methinks
12:50:07 <EvilTerran> Heffalump, well, i meant realisable in the Djinn sense of "not bottom"
12:50:47 <huamn_> hmm, how can i specify two context items :) I already have like (Ord k) => k ...
12:50:58 <huamn_> didnt seem to work with multiple => or comma-separated
12:51:06 <EvilTerran> (Foo a, Bar b) => ...
12:51:07 <huamn_> still struggling with the syntax...
12:51:10 <huamn_> ah.
12:51:22 <huamn_> works, thanks
12:51:33 <EvilTerran> you don't need the parens if there's only one bit of context, although some think it good style to put them in anyway
12:51:42 <EvilTerran> I think of it as a tuple of class constraints
12:51:53 <huamn_> makes sense
12:55:29 <paczesiowa> why this pragma isn't recognized? > {-# OPTIONS_GHC -x lhs #-}
12:56:51 <Lemmih> paczesiowa: I don't think -x is a dynamic flag.
12:57:23 <paczesiowa> what's a dynamic flag?
12:57:54 <Lemmih> Flags that work in the OPTIONS pragma.
12:58:17 <paczesiowa> I'm trying to write source file which compiles both with gcc and ghc with the same cli args
12:58:27 <olsner> gcc and ghc?
12:58:45 <paczesiowa> yes
12:58:51 <kaol> why?
12:59:06 <olsner> you have something that is both C/C++ source and haskell source?
12:59:08 <paczesiowa> the best reason there is! for fun
12:59:21 <olsner> oh, so it's a polyglot?
13:00:34 <hpaste>  Paczesiowa pasted "compiles in ghc and gcc" at http://hpaste.org/3258
13:01:32 <paczesiowa> funny thing is, it gives different results
13:01:59 <Heffalump> now do it with a .hs extension instead of .lh
13:02:55 <Heffalump> s/lh/lh/
13:02:59 * Heffalump pokes his 's' key
13:03:04 <dmwit> Heffalump: Somebody pasted that already.
13:03:20 <dmwit> http://hpaste.org/3256
13:03:42 <dmwit> To help you decode that, note that ghci will give
13:04:01 <dmwit> int :: (Num c) => a -> [b] -> c
13:04:04 <dmwit> or something like that.
13:04:05 <dmwit> =)
13:04:12 <Heffalump> nice :-)
13:04:50 <olsner> hpaste's haskell highlighting kind of makes it obvious though
13:05:32 <paczesiowa> but still you can't compile it the same way
13:05:39 <paczesiowa> unless it has ".c" extension
13:05:46 <paczesiowa> but that's rather pointless
13:10:33 <dmwit> paczesiowa: For yours, "ghc -x c test.lhs" and "gcc -x c test.lhs" seem to work here.
13:12:38 <Mr_Awesome> how is haskell pronounced? where is the accent?
13:13:28 <olsner> I stress the first syllable, I think
13:13:45 <dmwit> paczesiowa: Oh, never mind, that just processes it as if it were a C file in both cases (i.e. ghc passes it off to gcc in that case).
13:14:12 <mgsloan> I flop between has-cal and has-kell
13:14:46 <mgsloan> and I guess has-kull
13:14:47 <dmwit> SPJ accents the first syllable and makes it rhyme with "skull".
13:14:50 <mgsloan> yeah
13:15:06 <dmwit> But I tend to accent the second syllable and make it rhyme with "fell".
13:16:13 <byorgey> you accent the second syllable, really?  interesting
13:21:24 <yrlnry> Why is the pattern  _@...  illegal?
13:21:43 <dmwit> yrlnry: Because it's better to just omit the _@ entirely?
13:21:53 <dmwit> _@(x:xs) => (x:xs)
13:21:56 <yrlnry> Okay.  Is it a special case?
13:22:11 <dmwit> I don't really know, but is it actually a problem?
13:22:12 <yrlnry> Or is there some general class of patterns that is forbidden in front of @ that includes _?
13:22:16 <Baughn> yrlnry: Could just be a missing case. Technically a bug, maybe, but nobody cares
13:22:21 <yrlnry> No problem here.
13:23:04 <dmwit> > let f (x:xs)@(y:z:rest) = 1 in f [3,4,5] -- huh, I wonder if this is okay
13:23:04 <lambdabot>  Parse error
13:23:33 <dmwit> yrlnry: You're probably not allowed to have any pattern in front of the @, only an identifier.
13:23:37 <dmwit> _ isn't an identifier, so...
13:23:37 <Baughn> let foo (>)@(x:xs) = (>) in foo [2,3]
13:23:47 <yrlnry> could you let f ((x@y):(xs@z:rest)) there?
13:23:51 <Baughn> > let foo (>)@(x:xs) = (>) in foo [2,3]
13:23:53 <lambdabot>  [2,3]
13:24:02 <yrlnry> dmwit: Oho!  thanks.
13:25:11 <dmwit> > let f ((x@y):(xs@z:rest)) = 3 in f [4,5,6,7]
13:25:13 <lambdabot>  3
13:25:35 <yrlnry>  > let f ((x@y):(xs@z:rest)) = y in f [4,5,6,7]
13:25:41 <yrlnry> > let f ((x@y):(xs@z:rest)) = y in f [4,5,6,7]
13:25:42 <lambdabot>  4
13:25:52 <yrlnry> > let f ((x@y):(xs@z:rest)) = z in f [4,5,6,7]
13:25:54 <Baughn> > let f x@y@z = x in f 2
13:25:54 <lambdabot>  5
13:25:55 <lambdabot>  2
13:26:02 <dmwit> > let f ((x@y):(xs@z:rest)) = (x,y,xs,z,rest) in f [4,5,6,7]
13:26:02 <yrlnry> > let f ((x@y):(xs@z:rest)) = rest in f [4,5,6,7]
13:26:05 <lambdabot>  [6,7]
13:26:05 <lambdabot>  (4,4,5,5,[6,7])
13:26:15 <yrlnry> okay.
13:26:41 <yrlnry> < let long = 1:long in long
13:26:47 <yrlnry> > let long = 1:long in long
13:26:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:26:59 <dmwit> > repeat 1 -- shorter
13:27:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:27:08 <Baughn> > fix (1:) -- shorter
13:27:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:27:11 <yrlnry> I always forget about that except when I don't need it.
13:27:26 <dmwit> > fix(1:) -- shorter
13:27:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:27:28 <yrlnry> I didn't know about fix.  Thanks.
13:27:42 <Baughn> > [1,1..] -- ?
13:27:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:27:58 <dmwit> cool
13:28:04 <dmwit> Same length, though. =)
13:28:22 <Baughn> > cycle []
13:28:23 <lambdabot>  Exception: Prelude.cycle: empty list
13:28:26 <yrlnry> let v = 1 + v*v in v
13:28:31 <yrlnry> > let v = 1 + v*v in v
13:28:32 <lambdabot>  Exception: <<loop>>
13:28:39 <yrlnry> Hm.
13:29:17 <yrlnry> > fix \v -> 1 + v*v
13:29:17 <lambdabot>  Parse error
13:29:23 <dmwit> same thing
13:29:26 <yrlnry> > fix (\v -> 1 + v*v )
13:29:27 <lambdabot>  Exception: <<loop>>
13:29:34 <yrlnry> Just making sure.
13:29:35 <Baughn> > let v = 0 : [0 | a<-v, b<-v] in v
13:29:36 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
13:29:38 <yrlnry> Sorry, I should take this offchannel.
13:29:41 <dmwit> That doesn't have a least fixed-point.
13:29:58 <Baughn> yrlnry: There you go. Your arithmetic in unary. ;)
13:30:01 <yrlnry> It does in some domains.
13:30:08 <dmwit> Or, it has a least fixed-point, and that least fixed-point is bottom.
13:30:46 <dmwit> yrlnry: Right, I should say that it has no least fixed-point in Haskell semantics.
13:30:55 <yrlnry> Well, + and * are overloaded...
13:31:08 <dmwit> Doesn't matter, fix doesn't solve equations.
13:31:09 <yrlnry> When it's calculating the fix, does it assume that I want v to be fixed over Integer, or what?
13:31:36 <Baughn> > let (+) = concat, (a*b) = [0|c<-a,d<-b], one = [0] in let v = one + (v*v) in v
13:31:36 <lambdabot>  Parse error
13:31:47 <dmwit> > fix (\x -> sin x) -- doesn't matter, it's a loop
13:31:49 <lambdabot>  Exception: <<loop>>
13:31:52 <yrlnry> Baughn: yeah, that's sort of what I was getting at.
13:32:10 <yrlnry> But there you're askingh for sin(sin(sin....(x)))...)))
13:32:22 <Baughn> yrlnry: By all means, go ahead and instance Num [a]
13:32:38 <dmwit> Right, and you were asking for (1 +(1 + (1 + ...)*(1 + ...)...))
13:32:53 <yrlnry> dmwit: So it does assume the Integer definitions for + and * there.
13:33:07 <dmwit> No, I don't think so.
13:33:08 <yrlnry> dmwit: But what if I somehow demanded that v was of type Foo instead of type integer?
13:33:14 <dmwit> :t fix (\v -> 1 + v*v)
13:33:17 <lambdabot> forall a. (Num a) => a
13:33:25 <Baughn> yrlnry: Then the rules could be different
13:33:43 <Nucleo> are there any resources for Haskell quines?
13:33:54 <dmwit> ?wiki quine
13:33:54 <lambdabot> http://www.haskell.org/haskellwiki/quine
13:33:59 <yrlnry> Nucleo: Have you seen David madore's pages about quines?
13:34:06 <Nucleo> yrlnry: nope?
13:34:11 <Baughn> yrlnry: Oh, and "somehow" == "::"
13:34:12 <dmwit> Bah, that really needs to be smarter.
13:34:22 <yrlnry> Nucleo: It's a sort of general analysis of how to write quines in any languages, based on the "Recursion theorem" of computability theory.
13:34:22 <Nucleo> thanks dmwit
13:34:30 <dmwit> Nucleo: Don't bother, it's empty. =/
13:34:41 <yrlnry> Nucleo: After erading it, I could write quines in many bizarre languages, including Bourne shell.
13:34:57 <Nucleo> yrlnry: nice! I'll have to take a look
13:35:10 <yrlnry> http://www.plover.com/misc/quine/self.sh
13:35:17 <yrlnry> It was really a superb article.  Let me find it.
13:35:29 <yrlnry> http://www.madore.org/~david/computers/quine.html
13:35:31 <lambdabot> Title: Quines (self-replicating programs)
13:36:11 <Nucleo> got it
13:36:35 <dmwit> hpaste.org/2803
13:36:35 <Nucleo> http://www.ipl.t.u-tokyo.ac.jp/~scm/quine.hs
13:38:04 <Nucleo> thanks :)
13:40:21 <EvilTerran> main = putStr s >> print s where s = "main = putStr s >> print s where s = "
13:40:22 <EvilTerran> :D
13:40:52 <Nucleo> > main = putStr s >> print s where s = "main = putStr s >> print s where s = "
13:40:52 <lambdabot>  Parse error
13:40:55 <Nucleo> doh
13:41:25 <dmwit> > let bod = " in  \"let bod = \" ++ show bod ++ bod" in "let bod = " ++ show bod ++ bod
13:41:36 <lambdabot>  "let bod = \" in  \\\"let bod = \\\" ++ show bod ++ bod\" in  \"let bod = \"...
13:41:43 <EvilTerran> you can't do "foo = bar" with lambdabot; can't do IO, either.
13:41:53 <Nucleo> ah, okay
13:43:36 <EvilTerran> > (\s -> s ++ show s) "(\\s -> s ++ show s) " -- nice terse one for strings
13:43:38 <lambdabot>  "(\\s -> s ++ show s) \"(\\\\s -> s ++ show s) \""
13:43:58 <EvilTerran> (although you have to putStr the string or whatever for it to look right)
13:44:16 <Nucleo> works well enough in the interpreter ;)
13:45:14 <EvilTerran> the Show instance for strings makes writing quines pretty trivial, i guess
13:45:37 <dmwit> Yeah, plus they work across encodings.
13:46:37 <Nucleo> I would have thought that something like eval would make things much easier?
13:47:29 <EvilTerran> eeew
13:47:59 <EvilTerran> i don't recall seeing any quines in *any* language that use an eval construct
13:48:22 <opqdonut> i've seen a few perl ones
13:48:41 <EvilTerran> i guess i can kinda see how it'd be useful, thinking about it
13:50:16 <EvilTerran> but you could draw parallels between haskell's read and eval in other languages, so show is *kinda* dual to "eval"
13:50:36 <EvilTerran> so using show in haskell quines could be compared to using eval in other languages
13:52:42 <Nucleo> *nods*
14:07:00 <yrlnry> Haskell has eval?
14:07:10 <xerox> ?where hs-plugins
14:07:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:09:32 <fox86> is haskell a statically typed language?
14:09:41 <sjanssen> yes
14:10:58 <fox86> i see. when i finish reading all these "haskell for C programmers" tutorials, what tutorial do you recommend to understanding monads?
14:11:07 <dmwit> That's a surprising question, coming from someone who's been in this channel so much.
14:11:14 <dmwit> ?go you could have invented monads
14:11:21 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
14:11:21 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
14:11:45 <fox86> dmwit: hmm, me? i hang around here because i want to learn, but i've been too busy to do the switch from python
14:12:01 <dmwit> Also http://www.haskell.org/all_about_monads/html/index.html
14:12:02 <lambdabot> Title: All About Monads
14:12:08 <dmwit> fox86: ah
14:12:12 <fox86> dmwit: thank you
14:14:05 <dino-> Ya, I was just poised to say, All About Monads.
14:14:21 <mm_freak> fox86: there is no easy path from C/python to haskell…  it's best to forget what you think you know about programming and start from scratch…  "Yet another Haskell tutorial" is a good one
14:14:46 <fox86> mm_freak: good, i just printed that one
14:14:49 <ico> fox: I just started doing some haskell about a week ago, and for me 'The haskell school of language [Paul Hudak]" was quite an enlightenment
14:14:57 <ico> but that's a book, not a tutorial
14:15:07 <dino-> fox86: I'm curious if that '..for C programmers' made sense to you. I tried that first and it made me crazy. Ultimately YAHT seemed to be better as bare-assed beginner for me.
14:15:18 <fox86> ico: ah. i'll check it out
14:15:27 <dino-> No offense intended to the '..for C..' author.
14:15:43 <dmwit> fox86: Somebody also suggested this the other day: http://72.14.253.104/search?q=cache:rf-XE7Mch-YJ:blogs.nubgames.com/code/%3Fp%3D22&hl=en&ct=clnk&cd=4&gl=us
14:15:44 <lambdabot> http://tinyurl.com/33jfw9
14:15:51 <ico> it has just the right tempo. A lot of tutorials tend to have a lot of obvious blahblah at the beginnen, and then speedup waaay to fast until I'm lost
14:16:02 <mm_freak> yes…  IMO it's pointless to write about a "switch from C to haskell", since you simply can't
14:16:16 <mm_freak> there is almost no C knowledge to carry to haskell world
14:16:47 <fox86> i see. well, now i have plenty to read. wish me good luck!
14:16:53 <dmwit> g'luck!
14:17:14 <mm_freak> and have fun =)
14:17:19 <dino-> ?go monads as containers
14:17:20 <mm_freak> learning haskell _is_ fun
14:17:21 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
14:17:22 <lambdabot> Title: Monads as containers - HaskellWiki
14:17:31 <dino-> fox86: That one too, pretty short and very good.
14:18:05 <fox86> dino-: thanks, adding to my haskell bookmarks
14:19:40 <pejo> mm_freak, I disagree with you there, recursion isn't unheard of in C.
14:19:57 <mm_freak> pejo: i said "almost"
14:20:04 <dmwit> I find recursion isn't all that common in my Haskell code.
14:20:08 <magnus_> are there any recommendations for module names?
14:20:20 <dmwit> Name it after what it does.
14:20:54 <sarehu> magnus_: how about "Trogdorothy"
14:21:20 <magnus_> all right, Trogdorothy.{Base64,Base32,Uu,..} it is then :-)
14:21:21 <dmwit> Very good sir!
14:21:56 <dmwit> ?remember sarehu <magnus_> are there any recommendations for module names? <sarehu> how about "Trogdorothy"
14:21:57 <lambdabot> Done.
14:22:50 <dmwit> ?quote closes
14:22:50 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
14:22:53 <dmwit> haha
14:23:16 <olsner> that'd be his comind
14:23:26 <yrlnry> Olsner++
14:23:33 <dmwit> Olsner--
14:23:34 <dmwit> olsner++
14:23:37 <dmwit> ;-)
14:23:52 <mauke> @karma OLsner
14:23:52 <lambdabot> OLsner has a karma of 3
14:23:59 <olsner> @karma OLSNER
14:23:59 <lambdabot> You have a karma of 3
14:24:06 <mauke> case insensitive
14:24:11 <dmwit> ...oh
14:24:19 * dmwit shambles off
14:27:50 <magnus_> silly dev question: how do I get `runhaskell ./UnitTest.hs` to find the module Trogdorothy.Base64 which is located in ./Trogdorothy/Base64.hs?
14:28:55 <Saizan_> do you import Trogdorothy.Base64?
14:29:15 <magnus_> Saizan_, yes
14:29:33 <dmwit> It needs to be called
14:29:39 <dino-> magnus_: You can use a switch like -iTrogdorothy
14:29:41 <dmwit> "module Trogdorothy.Base64 where ..."
14:29:42 <dmwit> at the top
14:29:50 <dino-> with runhaskell
14:30:00 <magnus_> dmwit, yes, that's already don in Base64.hs
14:30:04 <dino-> It's in the ghc manpage, for finding imports, -i
14:30:05 <omnId> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id3132189
14:30:07 <lambdabot> Title: 4.17. Flag reference, http://tinyurl.com/ydk2e6
14:30:19 <dmwit> huh
14:30:35 <dmwit> Maybe runhaskell --make to automate that search?
14:30:39 <Saizan_> dino-: yeah but you need -i./ in this case, and it's the default
14:30:46 <dino-> mm
14:31:05 <Japsu> errrr... Trogdorothy?
14:31:24 <Japsu> A dragon-woman that BURNiNATES the countryside and peasants like her male counterpart?
14:32:04 <magnus_> with '-i' I get: file name does not match module name `Trogdorothy.Base32'
14:32:05 <dino-> s/male counterpart/little dog, too/
14:32:11 * magnus_ doublchecking spelling
14:32:20 <Japsu> dino-: ;D
14:32:29 <Japsu> Trogdofido? ;D
14:32:59 <dino-> Hm, that almost sounds like the module line in the src file doesn't match the path the file is stored in.
14:33:32 <dino-> Oh, nm.
14:33:58 <dino-> Adding that -iTrogblahblah is making that one of the top-level dirs it's looking in now (as Saizan said).
14:34:10 <eyeris> Is there a function in the Prelude -- or any std module I guess -- `[a] -> (a, Int)` that retuns the most frequent element and the number of occurances in the list?
14:34:44 <olsner> :t sortOn
14:34:47 <lambdabot> Not in scope: `sortOn'
14:35:05 <omnId> eyeris: you could get a [(a, Int)] that groups by occurance, then maximumBy snd
14:35:21 <omnId> map (head *** length) . group . sort
14:35:28 <omnId> s/***/&&&/
14:35:30 <magnus_> hmm, `runhaskell -i. UnitTest.hs` worked
14:35:31 <dmwit> s/***/&&&/
14:35:40 <eyeris> Cool, that works
14:35:48 <eyeris> But what is the &&& operator?
14:35:58 <omnId> (f &&& g) x = (f x, g x)
14:36:07 <dino-> magnus_: I vaguely feel that it should know . though.
14:36:09 <dmwit> (For the (->) arrow.)
14:36:11 <omnId> (for the function Arrow, specifically)
14:36:20 <omnId> is there an echo in here?
14:36:24 * dmwit lets omnId talk
14:36:32 <omnId> :)
14:36:35 <mauke> liftM (,)
14:36:43 <mauke> er, liftM2
14:36:58 <olsner> I would invoke the stereo quote, if only it was still around
14:37:14 <magnus_> dino-, why should you know?
14:37:21 <omnId> eyeris: if it seems too obscure you can replace it with (\x -> (head x, length x))
14:37:34 <dino-> . should be default
14:37:48 <eyeris> omnId no, I get the purpose now
14:37:51 <magnus_> dino-, yeah, it'd make sense to make it default
14:37:56 <eyeris> omnId I just had never seen it before
14:38:03 <omnId> @index (&&&)
14:38:04 <lambdabot> Control.Arrow
14:38:10 <magnus_> on the other hand I think I prefer sticking source files in a sub-dir anyway
14:38:32 * magnus_ enjoys how HUnit and QuickCheck complements each other
14:38:53 <alexei> hello, anybody here ever tried to instantiate Storable? I seem to get "undefined" passed to the sizeOf function. How am I supposed to estimate the size of it?
14:39:15 <omnId> alexei: iirc, sizeOf should be constant on the type
14:39:19 <mauke> alexei: by the type
14:39:38 <omnId> > sizeOf (undefined :: Int)
14:39:39 <lambdabot>   Not in scope: `sizeOf'
14:39:47 <omnId> @index sizeOf
14:39:48 <lambdabot> Foreign.Storable, Foreign
14:40:04 <magnus_> alexei, where does the type come from, C?
14:40:15 <alexei> omnold: so there is no room for Storable [a]?
14:40:25 <omnId> not sure
14:40:32 <mauke> no
14:40:44 <mauke> unless you can fit any list of any type into constant memory
14:41:02 <alexei> magnus_: I tried to excersize Storable a => Storable [a].
14:41:13 <Saizan_> btw, how do i choose a number for "alignment"?
14:41:57 <alexei> I  tried to place an Int = length list first
14:42:17 <TomMD> trac clearly lists GHC 6.8 as current while haskell.org/ghc lists 6.6.1 as current.  The download also shows 6.6.1 as current.  Is the 'official 6.8 package' just darcs head?
14:42:22 <mauke> Saizan_: for a C type?
14:42:31 <magnus_> Saizan_, there's a good comment on that on this blogpost: http://therning.org/magnus/archives/315
14:42:36 <Saizan_> mauke: yes
14:43:05 <mauke> ah, there's a comment containing my trick there :-)
14:44:00 <olsner> "Whit the help of people on #haskell I found 'with' ..."
14:47:53 <magnus_> seriously, where would modules Base{64,64Url,32,32Hex,16} fit? I noticed haskell-crypto has a Codec.Binary.Base64
14:48:19 <magnus_> there's also a Codec.Binary.Base64.String in base64-string
14:49:04 <alexei> ?where binary
14:49:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
14:49:10 <magnus_> stick them in MissingH?
14:51:20 <Saizan_> "alignment" matters only if i poke, right?
14:52:03 <ddarius> Saizan_: I doubt it.
14:52:08 <mauke> I think it matters for memory allocation
14:53:05 <koxinga> hi
14:53:51 <koxinga> I would like to generate all permutations of 0..9. How can I do this ?
14:55:16 <paczesiowa> to permutate list, you take one element, and stick in front of every permutation of other elements. hte only permutation of empty list is empty list
14:57:13 <Cale> Not quite
14:57:18 <Cale> er
14:57:24 <Cale> Nah, I suppose that works :)
14:57:26 <koxinga> but it is not recursive that way
14:57:37 <Cale> That's recursive
14:57:58 <ddarius> Even if it wasn't, you didn't say anything about it needing to be recursive.
14:58:08 <Cale> Another way is to take the first element and insert it in each possible place in each of the permutations of the rest of the elements.
14:58:19 <koxinga> ddarius:  hum, right :)
14:58:46 <alexei> again about "marshalling":  I tried to cabal-install "binary"  --- it is missing  "containers, array, bytestring>=0.9" --- though I have the latest stable GHC  6.6.1???
14:59:31 <alexei> will these libs ever be backported?
14:59:45 <dmwit> ?pl \x -> randomRIO (0, x)
14:59:45 <lambdabot> randomRIO . (,) 0
14:59:47 <koxinga> I mean the way paczesiowa says it is ok to add one element, but then I have to rotate the lists obtained
14:59:56 <ddarius> > (\xs -> filter (length xs ==) $ filterM (const [True,False]) xs) [1,2,3]
14:59:57 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
15:00:18 <ddarius> > (\xs -> filter ((length xs ==) . length) $ filterM (const [True,False]) xs) [1,2,3]
15:00:19 <lambdabot>  [[1,2,3]]
15:00:30 <ddarius> Okay.  That's what I thought.
15:00:34 <Cale> koxinga: No, because you picked an arbitrary element from the list and you're sticking it at the front
15:01:17 <koxinga> ah ok, thanks
15:01:41 <Cale> koxinga: First write a function pick :: [a] -> [(a,[a])] which takes a list and returns the list of ways of selecting one element from that list.
15:01:52 <Cale> (together with the remainder of the elements)
15:09:16 * omnId wrote a pick, but it took some trickery
15:10:30 <Cale> Should be a straightforward thing to write recursively.
15:10:51 <omnId> who uses direct recursion? :)
15:11:45 <alexei> why "sizeOf list = (padOff elm off) + len * bas" is reported by "ghc -ddump-parsed" as "sizeOf list = ((padOff elm off) + len) * bas" while padOff  :: a -> b -> Int ???
15:12:23 <ddarius> alexei: It shouldn't do that no matter what the type of padOff is.
15:12:24 * omnId would think (*) would have tighter fixity
15:13:19 <Japsu> > 3 + 4 * 5
15:13:21 <lambdabot>  23
15:13:38 <alexei> ddarius: yuou wont believe yuor eyes then ...
15:13:54 <ddarius> alexei: I don't always believe my eyes.
15:14:06 <omnId> is there a different (*) than (Prelude.*) in scope?
15:14:31 <Saizan_> it's a bug in the prettyprinter of the AST i think
15:14:47 <ddarius> alexei: If nothing else, no matter what, typing has nothing to do with parsing, so that part of your comment was a non-sequitur.
15:15:13 <Saizan_> 3 + 5 * 3 -> Just (3 + 5) * 3 but still gives 18
15:15:19 <alexei> one-liner, no imports: sizeOf list = (padOff elm off) + len * bas EOF. Just curious...
15:19:48 --- mode: irc.freenode.net set +o ChanServ
15:19:53 <alexei> Saizan_: hope so. not that I worry much, 'night
15:20:12 <omnId> they did say heavy splitting
15:21:04 <dmwit> *burp*
15:22:02 <omnId> huamn_: maybe you should ask again.
15:22:15 <koxinga> hum, I lost the discussion. Anyway, I did it, thanks everyone and especially Cale ;o)
15:22:28 <huamn_> omnId, yeah maybe :)
15:22:33 <huamn_> Is there some standard way of dealing with numeric infinity-values in haskell?
15:22:52 <omnId> > 1/0 -- not sure what you mean by "dealing with"
15:23:04 <lambdabot>  Infinity
15:23:06 <Cale> > isInfinite (1/0)
15:23:07 <lambdabot>  True
15:23:15 <huamn_> Does that work for every numeric type?
15:23:22 <huamn_> Integers and so on
15:23:22 <omnId> @type isInfinity
15:23:23 <dmwit> :t isInfinite
15:23:24 <lambdabot> Not in scope: `isInfinity'
15:23:26 <Cale> No, 1/0 produces an error in most types
15:23:26 <lambdabot> forall a. (RealFloat a) => a -> Bool
15:23:37 <Cale> and / isn't even defined for Integers
15:23:40 <dmwit> :instances RealFloat
15:23:44 <dmwit> ?instances RealFloat
15:23:45 <lambdabot> Double, Float
15:23:55 <huamn_> So there's no way of defining an infinite Integer?
15:24:00 <Cale> Nope
15:24:04 <huamn_> :(
15:24:12 <Cale> Integer models actual integers
15:24:23 <Cale> Like in mathematics
15:24:37 <dmwit> You can make your own type, called Ordinal or something.
15:24:55 <Japsu> data Superinteger = Finite Integer | Infinite
15:25:04 <Japsu> then derive Num for it
15:25:14 <Japsu> *instantiate
15:25:17 <FMota> #haskell, I need compassion/sympathy. I'm going through the whole college admissions process. I feel like I need to foldl an infinite list...
15:25:31 <Japsu> what a @remember-bait
15:25:39 * Japsu locks @remember
15:25:44 <huamn_> Japsu, mm, ok, thanks.
15:25:46 <allbery_b> heh
15:25:50 <Japsu> @remember FMota #haskell, I need compassion/sympathy. I'm going through the whole college admissions process. I feel like I need to foldl an infinite list...
15:25:50 <lambdabot> Done.
15:25:55 * Japsu releases lock on @remember
15:25:57 <FMota> :o
15:26:00 <FMota> lol
15:26:16 <FMota> Well, I was actually just looking for compassion, but that works too.
15:26:18 <Japsu> college admissions in Finland was really painless ;)
15:26:21 <Japsu> trivial even
15:26:36 <allbery_b>  @remember needs STM? :)
15:26:42 <dmwit> ?quote
15:26:42 <lambdabot> _Stinger_ says: sometimes Haskell seems like an arms race between weird mathematical constructs and my brain
15:26:50 <dmwit> haha
15:27:11 <eth01> meh
15:27:16 <nominolo> true
15:27:19 <eth01> haskell is used for what?
15:27:26 <eth01> i've never heard of it, just happened to join by accident :/
15:27:39 <nominolo> haskell isn't used for anything serious
15:27:42 <Japsu> eth01: it's a general purpose programming language
15:27:44 <eth01> but looks pretty interesting, so thought i'd stick around meh
15:27:46 <nominolo> it's a useless language
15:27:52 <nominolo> @keal
15:27:52 <lambdabot> love a black and white lower 128 from 32 up of ascii glyphs?
15:28:03 <Japsu> the only high-profile application written in haskell I know is DARCS the distributed revision control system
15:28:23 <mauke> and xmonad!
15:28:27 <Saizan_> and compilers/interpreters
15:28:29 <Japsu> yeah, xmonad
15:28:30 <dmwit> hpaste?
15:28:40 <astrolabe> I agree it's interesting.  I don't think it's fully caught on yet.
15:28:42 <Japsu> hpaste doesn't count because it's made _for_ haskell
15:28:46 <dmwit> ok
15:28:55 <eth01> so why would the channel have 354 users if nobody used it?
15:29:05 <dmwit> It's beautiful!
15:29:07 <Saizan_> ?users
15:29:08 <lambdabot> Maximum users seen in #haskell: 420, currently: 354 (84.3%), active: 13 (3.7%)
15:29:08 <Japsu> ;D
15:29:09 <mauke> glitch in the matrix
15:29:11 <dmwit> Beauty attracts people. =)
15:29:14 <nominolo> haskell is only useful for implementing non-blocking file systems, window managers, compilers, DAV servers, web servers, gui toolkits, parser toolkits, etc
15:29:27 <Japsu> ;D
15:29:30 <omnId> how useless!
15:29:31 <eth01> wow... Saizan_: 354 USERS
15:29:32 <eth01> jesus
15:29:43 <Japsu>  18:16  %Makuherra : lakupuu says: [Haskell] on vaan runkkareiden pätemiseen tehty kieli
15:30:18 <nominolo> @seen jesus
15:30:18 <lambdabot> I haven't seen jesus.
15:30:23 <Japsu> freely translated, "Haskell is there only so that wankers can feel clever about it"
15:30:26 <nominolo> guessed so ..
15:30:37 <dmwit> Bummer, we lost one.
15:30:45 <dmwit> We need better propoganda. =)
15:30:47 <Japsu> ;D
15:30:51 <nominolo> haskell is more zen anyways ...
15:30:58 <TomMD> @seen tommd
15:30:58 <lambdabot> You are in #xmonad, #haskell and #ghc. I last heard you speak just now.
15:31:05 <Japsu> @seen lambdabot
15:31:05 <lambdabot> Yes, I'm here. I'm in #oasis, #haskell, #galois, #friendly-coders, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #
15:31:06 <lambdabot> haskell-blah, #scala, #ghc and #darcs
15:31:23 * Japsu never ceases to wonder about lambdabot being in #unicycling
15:31:46 <dmwit> There's probably a very large overlap between #unicycling and Haskell enthusiasts.
15:31:58 <omnId> @users #unicycling
15:31:58 <lambdabot> Maximum users seen in #unicycling: 13, currently: 7 (53.8%), active: 0 (0.0%)
15:32:12 <nominolo> malcom w does
15:32:20 <nominolo> methinks
15:33:25 <dons> ?users #darcs
15:33:26 <lambdabot> Maximum users seen in #darcs: 50, currently: 40 (80.0%), active: 0 (0.0%)
15:33:32 <dons> ?users #perl6
15:33:32 <lambdabot> Maximum users seen in #perl6: 165, currently: 144 (87.3%), active: 1 (0.7%)
15:33:42 <nominolo> ?users #galois
15:33:42 <lambdabot> Maximum users seen in #galois: 2, currently: 1 (50.0%), active: 0 (0.0%)
15:33:51 <dmwit> whoa
15:33:53 <dmwit> That's low.
15:33:54 <glen_quagmire> ?users #ubuntu-women
15:33:55 <lambdabot> Maximum users seen in #ubuntu-women: 1, currently: 0 (0.0%), active: 0 (NaN%)
15:34:06 <dmwit> haha
15:34:45 <nominolo> ?users #ubuntu-men
15:34:45 <lambdabot> Maximum users seen in #ubuntu-men: 1, currently: 0 (0.0%), active: 0 (NaN%)
15:35:05 <omnId> ?users ubuntu-hermaphrodites
15:35:05 <lambdabot> Maximum users seen in ubuntu-hermaphrodites: 1, currently: 0 (0.0%), active: 0 (NaN%)
15:35:11 <omnId> O_o
15:35:18 <nominolo> something doesn't seem right here ...
15:35:26 <iank> ?users ##turtles
15:35:27 <lambdabot> Maximum users seen in ##turtles: 1, currently: 0 (0.0%), active: 0 (NaN%)
15:35:27 <Cale> ?users #57389108hkdlsgda
15:35:27 <lambdabot> Maximum users seen in #57389108hkdlsgda: 1, currently: 0 (0.0%), active: 0 (NaN%)
15:35:28 <glen_quagmire> that's weird. there are many girls on #ubuntu-women now
15:35:41 <iank> I assure you there's more than 1 user in ##turtles!
15:35:48 <dmwit> Looks like a default state, for when there's no data.
15:36:08 <iank> Guess so.
15:36:10 <omnId> lb maybe only sees channels she's @joined?
15:36:17 <iank> Well yeah :P
15:36:30 <FMota> heh
15:36:49 <FMota> er, nvm. scroll bar was not at bottom, etc.
15:37:02 <dmwit> ?pl \xs -> zip xs (tail xs ++ [head xs]) -- this is going to be ugly...
15:37:02 <lambdabot> ap zip (liftM2 (++) tail (return . head))
15:37:35 <omnId> pretty enough
15:37:51 * dmwit wonders if ?pl ever generalizes the lists to something monadic
15:37:57 <dmwit> ?pl x -> [x]
15:37:58 <lambdabot> (line 1, column 3):
15:37:58 <lambdabot> unexpected ">" or "-"
15:37:58 <lambdabot> expecting variable, "(", operator or end of input
15:38:01 <dmwit> ?pl \x -> [x]
15:38:01 <lambdabot> return
15:38:08 <dmwit> neat
15:38:22 <dibblego> ?pl concatMap
15:38:22 <lambdabot> (=<<)
15:38:28 <dmwit> ?pl (:[])
15:38:28 <lambdabot> return
15:38:33 <dmwit> heh
15:38:47 <dibblego> ?pl flip (>>=)
15:38:47 <lambdabot> (=<<)
15:39:01 <dmwit> It pl's things that are already pointless.
15:39:05 <omnId> ?pl flip (concatMap . const)
15:39:05 <lambdabot> (. const) . (>>=)
15:39:11 <omnId> ?pl concatMap . const
15:39:12 <lambdabot> flip (>>)
15:39:13 <dmwit> Which is good in a way, I guess.
15:39:38 <omnId> @pl flip (flip f)
15:39:38 <lambdabot> f
15:45:47 <huamn_> if i have a data type defined in module X like data Foo = ConstA | ConstB, how can i pattern-match it outside that module? seems like writing module X ( Foo ) is not the right way to export that data constructor even though it works for functions?
15:46:24 <mauke> module X ( Foo(..) )
15:46:28 <huamn_> ah
15:46:34 <mauke> otherwise you only export the type, not its guts
15:47:44 <omnId> incidentally, NOT exporting the constructors can be useful.  You can export ordinary functions for constructing and decomposing and are free to change the Foo type's representation.
15:48:24 <huamn_> yeah... I just have a priority queue which i'd like to pattern match to Empty priority queue
15:48:33 <huamn_> don't know how to do it without the constructor :o
15:48:55 <mauke> viewl
15:49:14 <omnId> If you were to do as I explained, you'd export an isEmpty function that did the pattern-matching itself.
15:50:16 <huamn_> amm.. how does the syntax go then in the using function... now I do something like data PSQ = Empty | somethingelse... then I have somefunc :: PSQ and there somefunc Empty = ...
15:50:33 <huamn_> or actually somefunc :: PSQ -> something
15:51:06 <huamn_> I tried something like somefunc empty where empty is a function returning an empty PSQ but it doesn't seem to work
15:51:14 <omnId> huamn_: is somefunc in PSQ's module?  With or without exporting PSQ's constructors?
15:51:23 <huamn_> it's outside PSQ's module
15:51:31 <huamn_> and I'd like to do it without exporting
15:51:34 <huamn_> but I don't know how
15:51:37 <huamn_> with exporting it's easy
15:51:41 <omnId> somefunc empty defines a new name empty that matches all patterns
15:51:52 <huamn_> yeah, i noticed
15:51:57 <omnId> you'd have to do the isEmpty testing and deconstructing on the rhs
15:52:05 <LoganCapaldo> in PSQ's module define isEMpty Empty = True ; isEMpty _ = False
15:52:08 <omnId> or use the pattern guards extension.
15:52:31 <LoganCapaldo> and then do somefunc x | isEmpty x = ...
15:52:33 <omnId> somefunc psq | isEmpty psq = ...
15:52:42 <huamn_> ah okay
15:52:53 <huamn_> that I have used elsewhere, should've known it's the solution
15:53:22 <LoganCapaldo> or just plain old fashioned somefunc x = if isEmpty x then ...
15:53:44 <LoganCapaldo> not as pretty though
15:54:14 <omnId> PSQ'sModule.deconstruct (NonEmptyConstr x y z) = (x, y, z);   ...   ExternalModule.somefunc x | (x, y, z) <- deconstruct x = ...
15:54:50 <omnId> that's a pattern guard
15:55:41 <magnus_> I've just requested a project on communit.haskell.org... does anyone know what happens next?
15:55:43 <omnId> in this case you're using 3-tuples as a "view" type for PSQ
15:56:26 <huamn_> hmm, why that | -syntax
15:56:46 <LoganCapaldo> omnId pattern guards happen in a monad or is it just a case of overlapping syntax?
15:56:49 <huamn_> isn't that the one where i should have Bool and then | iftrue = something
15:57:00 <omnId> LoganCapaldo: overloaded syntax
15:57:07 <huamn_> ok
15:57:20 <omnId> huamn_: yep, pattern guards are an extension to ordinary guards
15:57:40 <huamn_> standard extension still, I suppose? :)
15:58:00 <LoganCapaldo> standard extension does not compute does not compute :)
15:58:14 <huamn_> well, true :P
15:58:19 <omnId> func p | pattern <- expr = ...   matches only if it the result of expr can match pattern.
15:58:26 <LoganCapaldo> (except I guess the hierarchal modules thing is a standard extension)
15:58:43 <LoganCapaldo> (if anything is)
15:58:56 <omnId> even if it wasn't, you could move all the deconstructing and matching to the rhs.
15:59:10 <omnId> somefunc x = case deconstruct x of ...
16:00:12 <omnId> tim toady
16:02:03 <jgrimes> anyone else have issues with Yi.Gtk syntax coloring?
16:02:28 <shapr> I've had issues with it, but haven't tried it in the last coupla months.
16:02:30 <jgrimes> It only seems to color the bits of code around and after an insert or delete
16:02:38 <jgrimes> like lazy syntax coloring
16:02:39 <jgrimes> :p
16:08:36 <huamn_> if i have a 3-tuple how can i extract items from it? fst and snd do not seem to work anymore?
16:09:00 <huamn_> because they are for 2-tuples
16:09:23 <jmob> huamn_: let (x,y,z) = tuple
16:09:41 <huamn_> is that the only way if i need only one of the items?
16:09:48 <omnId> > (\(x,y,z) -> x) (1,2,3)
16:09:50 <lambdabot>  1
16:09:57 <huamn_> ah, lambda :p
16:09:59 <omnId> fst = (\(x,y) -> x)
16:10:23 <omnId> lets and lambdas are both fine for this case
16:10:27 <jmob> > let (_,x,_) = (1,2,3) in x
16:10:29 <lambdabot>  2
16:22:23 <iank> 'spose I have a list of pairs.  I'd like to find the pair which has the largest fst.  I could maximum (map (fst) mylist), but I want to know the pair which has the largest first, not just what the largest first is.
16:22:27 <iank> That make sense?
16:23:27 <omnId> maximumBy fst
16:23:39 <mauke> @src maximumBy
16:23:39 <lambdabot> Source not found. Are you on drugs?
16:23:53 <iank> :'D
16:24:01 <omnId> @index maximumBy
16:24:01 <lambdabot> Data.List
16:25:41 <LoganCapaldo> hmm
16:26:19 <LoganCapaldo> snd . maximum . map (\(x, y) -> (x, (x,y))) would work too i think
16:26:38 <LoganCapaldo> @instances Ord
16:26:39 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
16:26:55 <LoganCapaldo> > (2, "a"
16:26:55 <lambdabot>  Unbalanced parenthesis
16:27:02 <LoganCapaldo> > (2, "a") < (7, "a")
16:27:04 <lambdabot>  True
16:27:07 <omnId> > maximum [(1,1)] -- no Ord?
16:27:09 <lambdabot>  (1,1)
16:27:13 <Liskni_si> LoganCapaldo: if that would work, maximum itself would have to work too.
16:27:21 <LoganCapaldo> true that
16:27:47 <LoganCapaldo> at least for the case of fst
16:28:40 <LoganCapaldo> whether or not maximum works for you I guess depends if you need it to be stable (can I use that term here?) or not
16:28:49 <Liskni_si> but it compares both components of the tuple
16:28:55 <LoganCapaldo> yes
16:29:19 <LoganCapaldo> but its lexographic no?
16:29:35 <Liskni_si> yeah, seems so
16:33:30 <iank> hrum.  I don't seem to be able to get maximumBy to work (I blame user error, but hey :)
16:33:47 <iank> Data.List.maximumBy(fst) [(1,1),(2,2),(8,3)]
16:33:54 <iank> Is what I'm doing to try to test it.
16:34:14 <iank> Occurs check: cannot construct the infinite type: a = (a, b) -> Ordering # is the error ghci gives me
16:35:34 <mauke> maximumBy (\x y -> fst x `compare` fst y) [(1,1),(2,2),(8,3)]
16:35:50 <Liskni_si> or comparing fst
16:36:13 <mauke> > foldl1 max [(1,1),(2,2),(8,3)]
16:36:18 <lambdabot>  (8,3)
16:36:42 <huamn_> what's wrong with my types? i have itemByKey :: (Ord k, Ord p) => k -> PSQ k p d -> Maybe (k, p, d) which returns a 3-tuple if it is found... then i try to create a dataByKey :: (Ord k, Ord p) => PSQ k p d -> d which takes that d(data) from that 3-tuple, but definint dataByKey k q = (\(x,y,z) -> z) . (itemByKey k q) does not seem to work
16:36:54 <iank> > fold1 max [(1,1),(2,2),(8,3),(8,4)]
16:36:55 <lambdabot>   Not in scope: `fold1'
16:36:58 <iank> er
16:37:03 <iank> > foldl1 max [(1,1),(2,2),(8,3),(8,4)]
16:37:04 <lambdabot>  (8,4)
16:37:12 <iank> yeah, need (8,3) -_-
16:37:15 <iank> @index comparing
16:37:15 <lambdabot> bzzt
16:37:25 <iank> <interactive>:1:20: Not in scope: `comparing'
16:38:00 <huamn_> and oh i wrote wrony my dataByKey also has a Maybe before that d in the end :)
16:38:10 <huamn_> so that's not the problem
16:38:22 <Liskni_si> huamn_: you're missing the k param in the type signature
16:38:49 <huamn_> mmm?
16:38:51 <huamn_> where
16:38:59 <huamn_> oh
16:39:10 <huamn_> I wrote again wront to IRC, it's right in my source file :p
16:39:12 <huamn_> should've copy pasted
16:39:16 <Liskni_si> :)
16:39:25 <huamn_> dataByKey :: (Ord k, Ord p) => k -> PSQ k p d -> Maybe d
16:39:33 <huamn_> that's my real type signature
16:39:39 <huamn_> itemByKey :: (Ord k, Ord p) => k -> PSQ k p d -> Maybe (k, p, d)
16:39:42 <Liskni_si> the next thing is the dot
16:39:42 <omnId> huamn_: dataByKey gets both k and q, so you shouldn't uses composing (.)
16:39:53 <omnId> just try deleting the dot
16:40:06 <huamn_> it doesn't help, I tried that :P
16:40:10 <huamn_> I still get an error
16:40:39 <Liskni_si> replace it with `fmap`
16:40:44 <omnId> wait, itemByKey give a Maybe triple, the (\(x,y,z) -> z) expects an ordinary triple
16:40:57 <Liskni_si> so that the lambda gets inside Maybe
16:40:59 <omnId> yeah, use fmap to lift the lambda into the Maybe
16:40:59 <huamn_> so I should write \Maybe(x,y,z) ?
16:41:09 <omnId> @src Maybe fmap
16:41:09 <lambdabot> fmap _ Nothing       = Nothing
16:41:10 <lambdabot> fmap f (Just a)      = Just (f a)
16:41:25 <huamn_> ok, thanks
16:41:39 <omnId> fmap (<(a,b,c)->c>) (<Maybe (a,b,c)>)
16:42:14 <huamn_> yei, it works :)
16:42:14 <omnId> iank: did you see mauke's first version?
16:44:45 <jgrimes> > maximumBy (\x y -> (fst x) `compare` (fst y)) [(1,2),(8,3),(8,4)] --mauke's first version
16:44:47 <lambdabot>  (8,4)
16:44:54 <huamn_> Is there a way to drop the last item from a list? I remember reading that the first item is the only one accessible?
16:44:58 <jgrimes> >  maximumBy (\x y -> case ((fst x) `compare` (fst y)) of EQ -> GT; x -> x) [(1,2),(8,3),(8,4)] --my slightly modified version
16:45:00 <lambdabot>  (8,3)
16:45:00 <omnId> init
16:45:05 <omnId> > init [1,2,3,4]
16:45:07 <lambdabot>  [1,2,3]
16:45:11 <huamn_> oh.
16:45:17 <huamn_> > init []
16:45:19 <lambdabot>  Exception: Prelude.init: empty list
16:45:46 <omnId> (reverse . drop 1 . reverse) if you're crazy
16:46:08 <huamn_> :)
16:46:12 <dmwit> > let safeInit [] = []; safeInit xs = init xs in safeInit []
16:46:13 <lambdabot>  []
16:46:25 <mauke> :t join $ take . (subtract 1 . length)
16:46:27 <lambdabot> forall a. [a] -> [a]
16:47:01 <omnId> I suppose since init has to walk it anyway, length is okay.
16:47:20 <swix> I get a parse error on "-" (when I'm trying to subtract) any ideas?
16:47:27 <omnId> line?
16:47:37 <jgrimes> iank, see my function above. is that what you were looking for?
16:47:42 <omnId> (-1) is negative one.
16:47:46 <allbery_b> swix: haskell's parser has some odd interactions between negative numbers and subtraction
16:48:05 <omnId> (subtract 1) or (+ (-1)) do what you want
16:49:59 <sioraiocht> > - 1
16:50:01 <lambdabot>  -1
16:50:07 <sioraiocht> > 4 + - 1
16:50:08 <lambdabot>      precedence parsing error
16:50:08 <lambdabot>         cannot mix `(+)' [infixl 6] and prefix ...
16:50:13 <omnId> > 4 + (-1)
16:50:15 <lambdabot>  3
16:50:16 <sioraiocht> > 4 + (- 1)
16:50:17 <lambdabot>  3
16:50:21 <Liskni_si> :t join
16:50:23 <LoganCapaldo> prefix ellipses operator?
16:50:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:50:23 <sioraiocht> :t (-)
16:50:25 <lambdabot> forall a. (Num a) => a -> a -> a
16:50:56 <omnId> Liskni_si: m = (b ->), so join :: (b -> (b -> a)) -> (b -> a)
16:51:14 <sioraiocht> :t (-1)
16:51:16 <lambdabot> forall a. (Num a) => a
16:51:20 <LoganCapaldo> > (...) a b = [a..(b - 1)] in 1 ... 10
16:51:20 <lambdabot>  Parse error
16:51:23 <omnId> :t subtract 1
16:51:25 <lambdabot> forall t. (Num t) => t -> t
16:52:10 <omnId> effectively, join f x = f x x
16:52:16 <Liskni_si> ok, thx
16:53:35 <shapr> @yow !
16:53:36 <lambdabot> I know how to do SPECIAL EFFECTS!!
16:53:48 <omnId> @brain Are you pondering what I'm pondering?
16:53:48 <lambdabot> Now, Pinky, if by any chance you are captured during this mission,
16:53:48 <lambdabot> remember you are Gunther Heindriksen from Appenzell. You moved to Grindelwald
16:53:48 <lambdabot> to drive the cog train to Murren.  Can you repeat that?
16:54:00 <shapr> ooh
16:54:03 <shapr> Haven't seen that one before.
16:54:14 <omnId> @list quote
16:54:15 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
16:55:11 <swix> alright, I'm having trouble with something that seems pretty simple: http://hpaste.org/3259
16:55:34 <lament> @girl19
16:55:34 <lambdabot> is this a help channel for hackers-beginners?
16:55:43 <omnId> swix: 1 : (...)?
16:55:57 <mauke> 1 : divisors n (z - 1)
16:56:07 <lament> @girl19
16:56:07 <lambdabot> I have stolen about 50 msn and yahoo accounts
16:56:10 <swix> hmm
16:56:22 <omnId> (:) is cons, :: is type annotation
16:56:25 <swix> woo, it should also be z
16:56:27 <swix> indeed
17:03:42 <Adamant> @quote b52s
17:03:42 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
17:04:21 <Adamant> @quote fortune
17:04:21 <lambdabot> No quotes match. My pet ferret can type better than you!
17:04:34 <omnId> @b52s
17:04:34 <lambdabot> Hot pants explosion at the factory!
17:04:40 <omnId> @fortune
17:04:40 <lambdabot> Is there life before breakfast?
17:05:05 <Adamant> guh.
17:05:26 <omnId> @ghc
17:05:26 <lambdabot> ghc says: invalid character
17:05:29 <Adamant> Adamant just pawn in game of life.
17:17:17 <Cale> I don't know if there's life *before* breakfast, but I could have sworn I saw a glider in my Shreddies.
17:17:58 <dons> Cale sounds like Zippy
17:18:46 <lament> Cale: was it moving at 1/4 the speed of light?
17:19:04 <Cale> hehe
17:22:08 <chessguy> so i've taken the zipper monad from http://haskell.org/haskellwiki/Zipper_monad and adapted it for use with Data.Tree. what would be the best/easiest way to adapt it to also carry around arbitrary state as you traverse the tree?
17:22:09 <lambdabot> Title: Zipper monad - HaskellWiki
17:22:18 <Eelis> dons: the status table in the README of the plugins-1.0 package doesn't list x86_64-linux. what is the status of plugins on x86_64-linux?
17:22:29 <dons> not sure. probably works.
17:22:35 <Eelis> ok, i see
17:22:39 <dons> works on openbsd on that arch
17:23:01 <sjanssen> chessguy: just use StateT instead?
17:23:27 <chessguy> sjanssen, on top of the Zipper monad you mean?
17:23:32 <sjanssen> chessguy: yeah
17:24:10 <chessguy> hmm
17:25:27 <thepointer> hi, i've imported another module which has a function with the same name as one in my current module, i'm getting Ambiguous occurrence errors, and i'm wondering how to address the function that's in my current module?
17:26:03 <omnId> import qualified OtherModule (as NewName if you want)
17:26:25 <omnId> then OtherModule.function vs. function (which is ThisModule)
17:27:02 <dons> thepointer: yeah, import qualified MyModule as M
17:27:06 <omnId> if you still want to import all of OtherModule's other names, then import OtherModule hiding (function) as well.
17:27:07 <dons> then refer to M.foo
17:27:08 <thepointer> would that mean any time i want to use a function out of OtherModule, i'd say OtherModule.function ?
17:27:22 <omnId> thepointer: ^
17:27:26 <thepointer> ahh, i think the hiding would be best :)
17:27:31 <chessguy> sjanssen, should i be making TravelTree a monad instance then too, i guess?
17:27:33 <dons> yes, or just hide
17:27:41 <thepointer> excellent, thank-you sirs.
17:27:58 <sjanssen> chessguy: oh, I thought you meant that you already had a monad?
17:28:34 <chessguy> sjanssen, i have this:
17:28:34 <chessguy> newtype Travel loc a = Travel { unT :: State loc a }
17:28:34 <chessguy>      deriving (Functor, Monad, MonadState loc, Eq)
17:28:52 <chessguy> and then on top of that, i've done this: type TravelTree a = Travel (TreeLoc a) (Tree a)
17:29:04 <chessguy> so i think i should be able to derive Monad on TravelTree too
17:29:31 <omnId> didn't you want a Zipper monad in there somewhere?
17:29:50 <chessguy> Travel is essentially a Zipper monad
17:30:19 <omnId> Travel = State, afaict
17:30:49 * omnId reads the zipper monad thing
17:30:53 <chessguy> so is zipper :)
17:35:29 <swix> does haskell have dictionaries?
17:35:34 <shapr> yes
17:35:40 <shapr> Data.Map, yeah?
17:35:54 <swix> cool
17:36:07 <shapr> Though there may be a successor to that library, I'm not sure.
17:36:25 <omnId> > lookup 1 (M.fromList [(1,'a'), (2,'b'), (3,'c')]) :: Maybe Char
17:36:26 <lambdabot>  Couldn't match expected type `[(t, Char)]'
17:36:37 <omnId> > M.lookup 1 (M.fromList [(1,'a'), (2,'b'), (3,'c')]) :: Maybe Char
17:36:38 <lambdabot>  Just 'a'
17:36:59 <omnId> > M.lookup 4 (M.fromList [(1,'a'), (2,'b'), (3,'c')]) :: Maybe Char
17:37:00 <lambdabot>  Nothing
17:41:21 <paczesiowa> google.com gives me malformed xml file. apocalypse is coming?
17:43:55 <iank> jgrimes: yes.  Thanks!
17:46:49 <jgrimes> iank, :D
17:47:36 <chessguy_> hmm
17:47:50 <chessguy_> the problem seems to be that TravelTree is not a monad itself
17:48:57 <chessguy> and i don't seem to be able to derive Monad in this case
17:50:37 <chessguy> what if i transformed the zipper Monad first, and then adapted it for Data.Tree?
17:50:41 <omnId> TravelTree is a synonym for Travel, right?  And Travel's a Monad, I don't see why TravelTree wouldn't be.
17:50:57 <chessguy> type TravelTree a = Travel (TreeLoc a) (Tree a)
17:51:03 <dmwit> laziness++
17:51:12 <chessguy> and Travel derives Monad, yes
17:51:33 <omnId> hmm, if you want TravelTree to be a monad over its a, you'll need a newtype.
17:52:04 <chessguy> yeah, but if i do a newtype, it complains:
17:52:17 <chessguy> The constructor of a newtype must have exactly one field
17:52:18 <chessguy>       but `Travel' has two
17:52:37 <chessguy> (just changing the 'type' above to 'newtype'
17:52:43 <omnId> newtype TravelTree a = TT (Travel (TreeLoc a) (Tree a))
17:53:03 <omnId> newtypes need a constructor
17:53:27 <chessguy> ooh, now it's very angry
17:53:44 <omnId> :)
17:54:53 <chessguy>     Can't make a derived instance of `Functor TravelTree'
17:54:53 <chessguy>       (even with cunning newtype deriving:
17:54:53 <chessguy>        the eta-reduction property does not hold)
17:54:53 <chessguy>     When deriving instances for `TravelTree'
17:55:21 <chessguy> ditto for the derivations of Monad, MonadState a, and Eq
17:55:27 <chessguy> which Travel derives
17:56:01 <omnId> "even with cunning newtype deriving" =D
17:56:25 <omnId> SRY BUT U CAN'T DO DAT.
17:56:30 <chessguy> lol
17:56:34 <chessguy> it tried hard though :)
17:57:01 <chessguy> so i need to create an explicit instance of Monad?
17:57:40 * omnId has no idea what it would look like.
17:58:10 <chessguy> me neither
17:59:38 <swix> omg
17:59:44 <swix> this is the most ridiculous thing ever
17:59:59 <chessguy> and if i don't try to do 'deriving Monad', it gets very, very angry
18:00:13 <chessguy> several pages of angry
18:01:40 <swix> oh god damnit
18:01:50 <swix> I write the most beautiful thing, and haskell craps out on me with "index too large"
18:02:29 <omnId> @paste
18:02:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:02:53 <swix> are lists serveral million elements long too big?
18:03:34 <omnId> for Int indeces
18:03:38 <sjanssen> swix: that generally means you requested an index larger than the length of the list
18:03:47 <swix> oh right
18:03:48 <swix> indeed
18:04:00 <chessguy> > maxBound :: Int
18:04:02 <lambdabot>  2147483647
18:04:03 <swix> my bad
18:04:18 <omnId> million, billion, same thing :)
18:04:18 <chessguy> a little more than "several million" :)
18:05:15 <omnId> Rawr!  I hate Haskell it's being so stupid!  Oh wait, nvm.
18:06:19 <thorat> billion and billion are not even the same thing: http://en.wikipedia.org/wiki/Billion
18:06:20 <lambdabot> Title: Billion - Wikipedia, the free encyclopedia
18:06:44 <swix> seriously though, this thing is too concise, it's scary
18:06:46 <swix> given what it does
18:06:53 <omnId> ooh!  show!
18:07:22 <omnId> @remember swix  seriously though, this thing is too concise, it's scary, given what it does
18:07:22 <lambdabot> Done.
18:08:20 <newsham> I ran across a blog recently where they showed natural deduction rules using haskell types, and did a few proofs (curry-howard)
18:08:27 <swix> you know the classic problem where, if n | 2 then f(n/2) else f(3*n + 1) and you get the sequences 4, 2, 1 eventually
18:08:29 <newsham> cant find the blog now... anyone know which one it might have been?
18:08:37 <swix> well, this problem asks for the longest chain with the starting number under one million
18:08:39 <newsham> swix: collatz conjecture
18:08:43 <swix> my solution is like 3 lines
18:08:48 <swix> still takes for ever to run...
18:09:11 <jcreigh> sounds like project euler...
18:09:19 <swix> yeah, it's problem 14 :P
18:09:46 <newsham> takeWhile (/=1) $ iterate (\n -> if n `mod` 2 == 0 then n `div` 2 else 3*n+1)
18:10:47 <omnId> you'll need the iterate to have a first value
18:10:54 <omnId> or s/$/./
18:11:04 <iank> swix: heh, I was just working on that.
18:11:08 <newsham> of course you're right
18:11:13 <iank> (well, I still am, but I stopped for a bit -_-)
18:11:21 <newsham> anyone know blog that used haskell types to do logic proofs?
18:11:45 <swix> I have an infinite lists of the depths eg: theList!!4 = 3...
18:12:05 <swix> it's friggin slow though.... :(
18:12:11 <geocalc_> Prelude> maxBound :: Int
18:12:11 <geocalc_> 9223372036854775807
18:12:11 <swix> even doing the first 10,000 is taking ages
18:12:37 <newsham> swix: you could speed it up if you cache results.  long sequences will bump into shorter sequence before they bump into 1
18:12:50 <iank> I have a function that'll generate tuples consisting of the length of the sequence and the starting number.
18:12:50 <swix> yeah, that's how I did it
18:12:57 <swix> I didn't do the tuples bit :P
18:12:58 <iank> But my stack overflows eventually :)
18:13:07 <swix> I'll paste mine
18:13:17 <newsham> of you could just come up with a closed form solution ;-)
18:13:19 <newsham> *ducks*
18:13:36 <iank> I'm also entirely new to haskell, so I'm stumbling around in the dark (dodging grues)
18:13:52 <omnId> @quote grue
18:13:52 <lambdabot> ari says: The problem I have with grues is that although I know that currently, if it is very dark I am likely to be eaten by one... but how can I tell it grues suddenly become benign at, say, the
18:13:52 <lambdabot> year 2010? The evidence I've gathered so far can't support the idea that that *wouldn't* happen.~
18:14:29 <iank> haha
18:14:48 <iank> Perhaps by 2010 I'll know my way around haskell enough to avoid being eaten :)
18:15:25 <hpaste>  swix pasted "(no title)" at http://hpaste.org/3260
18:15:34 <swix> oh weird.
18:15:43 <swix> anyways, that's my infinite list of sequence depths
18:15:52 <swix> and it's self recursive! so it should be fast, but it's not
18:16:32 <jaj> iank, I'm a bit like you. I only played with haskell for a few weeks now. I just bought "The Haskell School of Expressions" and I hope to get going with it
18:16:37 <jaj> looks very promising
18:17:31 <geocalc_> swix-> you should look at maude
18:17:33 <iank> Neat.  I'm working my way through YAHT, and taking breaks to stumble around Euler before getting hopelessly lost and returning to YAHT for another beating :)
18:17:42 <swix> maude?
18:18:54 <geocalc_> @ggl maude language
18:18:54 <lambdabot> Maybe you meant: ghc pl url
18:19:04 <newsham> ?go maude language
18:19:07 <lambdabot> http://maude.cs.uiuc.edu/papers/abstract/Dmodalg_1999.html
18:19:07 <lambdabot> Title: A Reflective Module Algebra with Applications to the Maude Language
18:19:39 <omnId> collatz n = n : collatz m where m | even n = div n 2 - 1 | otherwise = 3 * n   ;   depthOf n = length (takeWhile (/=1) (collatz n)
18:19:48 <shachaf> @let frotz = undefined
18:19:51 <lambdabot> Defined.
18:20:52 <newsham> omnid: but no memoization.  hows it compare speedwise?
18:21:06 <omnId> terribly
18:21:10 <newsham> (otherwise = 3*n+1, btw)
18:21:25 <newsham> even = div 2, oterwhsei = 3*n+1
18:22:05 <swix> mine consumes goobs of memory
18:22:06 <newsham> (at least that's collatz: http://en.wikipedia.org/wiki/Collatz_conjecture)
18:22:06 <lambdabot> Title: Collatz conjecture - Wikipedia, the free encyclopedia
18:22:11 <omnId> I don't see any memoization in swix's paste
18:22:39 <newsham> omniId: isnt the list a memo?
18:22:48 <newsham> recursion checks the list, the list is made of the func results
18:23:10 <omnId> oh, didn't see
18:23:24 <omnId> @slap omnId
18:23:24 * lambdabot slaps omnId
18:23:35 <omnId> @thanks
18:23:35 <lambdabot> you are welcome
18:23:40 <newsham> ?vixen smack omniId
18:23:41 <lambdabot> there are a lot of weirdos on here
18:23:48 <levi13> hi, is there any good reading on CRUD and FP?
18:23:54 <swix> so any ideas why it takes up so much memory?
18:24:45 --- mode: irc.freenode.net set +o ChanServ
18:24:58 <LoganCapaldo> ChanServ! my arch nemesis
18:25:07 <newsham> question:  if you access   theList !! 10,  that doesnt force evaluation of theList !! [0..9]   (necessarily) right?
18:25:22 <newsham> it will leave the members unevaluated unless it needs em?
18:25:27 <LoganCapaldo> it forces the evaluation of the spine
18:25:41 <newsham> spine being (_:xs) right?
18:25:45 <LoganCapaldo> yeah
18:26:15 <swix> wait, so the spine would be in that case... 10 5 16 8 4 2 1?
18:26:28 <LoganCapaldo> no
18:26:31 <swix> damn.
18:26:36 <swix> now my way is ugly
18:26:43 <omnId> the spine is the cons cells with unevaluated heads.
18:27:07 <newsham> swix: if you ask for theList !! 1000 , it wont necessarily have to compute theList !! 999
18:27:34 <newsham> (ie. the list can have "holes" in it)
18:27:43 <newsham> but... I bet you you have a very long list :)
18:27:46 <swix> ok...
18:27:59 <omnId> _ : _ : _ : _ : _ : _ : _ : _ : _ : _ : depthOf 11 : _
18:28:01 <swix> but my naive implementation is soo much faster (goes down each sequence entirely)
18:28:04 <LoganCapaldo> > [undefined, undefined, undefined, 1, undefined] !! 3
18:28:16 <lambdabot>  1
18:28:42 <newsham> swix: btw, was the prob for 3*n+1, n/2  or   3*n, n/2 - 1 ?
18:29:00 <LoganCapaldo> > (undefined : undefined : undefined : 1 : undefined) !! 3
18:29:01 <lambdabot>  1
18:29:09 <swix> well, you have to add one to get the indexes right, so it just gets removed
18:29:35 <omnId> newsham: I think he has to add one to... yeah, but swix, you could just let theList = map depthOf [0..]
18:29:40 <iruew> Is there any way to get the amount of system ticks in haskell?
18:29:51 <LoganCapaldo> @hoogle Clock
18:29:51 <lambdabot> System.Time.ClockTime :: data ClockTime
18:29:51 <lambdabot> System.Posix.Types.ClockTick :: type ClockTick
18:29:51 <lambdabot> Foreign.C.Types.CClock :: data CClock
18:30:09 <LoganCapaldo> @hoogle IO ClockTick
18:30:10 <lambdabot> No matches, try a more general search
18:30:27 <LoganCapaldo> @hoogle IO ClockTime
18:30:27 <lambdabot> Time.getClockTime :: IO ClockTime
18:30:27 <lambdabot> Directory.getModificationTime :: FilePath -> IO ClockTime
18:30:32 <allbery_b> @hoogle ClockTick
18:30:32 <lambdabot> System.Posix.Types.ClockTick :: type ClockTick
18:30:38 <allbery_b> hm
18:30:47 <LoganCapaldo> hm is right
18:30:51 <newsham> ie. the max element in collatz seq for 1000 is 9232
18:31:05 <LoganCapaldo> hoogle, you've failed me for the last time!
18:31:07 <allbery_b> it should be finding the interface to times(), I htink
18:31:10 <omnId> swix: the depthOf 0 in the first cons cell would go unused, but you wouldn't have to re-subtract the base index
18:31:14 * LoganCapaldo force chokes hoogle
18:31:22 <LoganCapaldo> if only it had a neck...
18:31:24 <swix> indeed
18:31:30 <LoganCapaldo> or lungs
18:31:39 <newsham> oh yah, swix' list is off by 1
18:31:55 <newsham> oh!  I see,  thats why his equation has -1 and not for 3*n
18:31:56 <newsham> heh
18:32:24 <omnId> collatz n = theList !! (n - 1), then you could rewrite depthOf to be clearer.
18:32:37 <LoganCapaldo> @docs System.Posix
18:32:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix.html
18:33:10 <jaj> I don't believe lambdabot is actually a bot
18:33:18 <jaj> it's too powerful
18:33:18 <LoganCapaldo> @hoogle IO CClock
18:33:19 <omnId> @quote lambdabot
18:33:19 <lambdabot> No matches, try a more general search
18:33:19 <lambdabot> lambdabot says: I CAN HAS CHEEZBURGER?
18:33:21 <newsham> ?vixen want to grab some dinner?
18:33:21 <lambdabot> yes
18:33:29 <allbery_b> or clock()
18:33:29 <LoganCapaldo> @hoogle CClock
18:33:30 <lambdabot> Foreign.C.Types.CClock :: data CClock
18:33:31 <allbery_b> hmm
18:33:44 * omnId <3 LB
18:33:45 <newsham> would a bot want dinner?
18:33:48 <allbery_b> I don;t even see it in my quick check but IIRC t wasn't defined where I expected it to be
18:35:34 <Adamant> newsham, if you put someone in a robot body I bet they would still want to eat. They'd just like it to be optional.
18:36:05 <LoganCapaldo> @hoogle ProcessTimes
18:36:06 <lambdabot> No matches found
18:36:15 <LoganCapaldo> @hoogle getProcessTimes
18:36:16 <lambdabot> No matches found
18:36:27 <LoganCapaldo> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html#7
18:36:28 <lambdabot> http://tinyurl.com/obhpz
18:37:33 <newsham> ?vixen how's the weather today?
18:37:33 <lambdabot> however you want
18:37:56 <iruew> Well, I'm using Hugs, so I guess I can just use Hugs.Time... but Hugs.Time's clockTicks always returns 1000000 for me for some reason
18:37:59 <newsham> ?vixen give me your number
18:38:00 <lambdabot> give me your phone number and i'll call you
18:38:14 <LoganCapaldo> iruew: that last link was for you
18:38:18 <LoganCapaldo> fyi :)
18:38:27 <iruew> ah, thanks
18:39:00 <LoganCapaldo> I have no idea if this lib is portbale to hugs
18:39:16 <iruew> Yeah, that will probably make it harder :/
18:39:19 <allbery_b> yeh, I saw that one, but the raw unix call returns that info in a struct pointer. and its actual return value is clock ticks from some epoch
18:39:40 <allbery_b> (on osx it seems to be from the unix epoch,m I recall it being from process start and on some systems from system boot)
18:40:12 <LoganCapaldo> well you could save the value at the start of your program
18:40:20 <LoganCapaldo> and subtract
18:40:27 <iruew> :|
18:40:31 <LoganCapaldo> not ideal
18:40:50 <allbery_b> and clock(3) returns ticks since process start
18:41:09 <allbery_b> which I also thought there was a System.Posix interface to, but I didn't notice it
18:42:27 <LoganCapaldo> are we sure elapsedTime vs. systemTime is clock vs. clock(3)?
18:42:35 <LoganCapaldo> *isn't
18:47:37 <swix> in maple how do you find a coefficeint in a polynomial expansion?
18:48:17 <dons> Cale might know
18:48:22 <dons> this is #haskell though :)
18:48:45 <LoganCapaldo> this maple. this is blasphemy.
18:48:52 <LoganCapaldo> this is maple?
18:48:59 <LoganCapaldo> this is #HASKELL!
18:49:12 * LoganCapaldo kicks swix into the abyss
18:49:24 <dons> oh, maple is fine. we like all thing thinkable
18:49:45 <dons> lambdabot has mathematica plugin, you might know
18:50:10 * LoganCapaldo knows but was having fun
18:50:26 <dons> swix: we're a bit wacky in here
18:50:28 <Cale> btw, the "Golly" life program is awesome
18:50:29 <SamB> maple has ugly code :-(
18:50:57 <SamB> (a lot of maple is written in the language, but it's really really ugly code)
18:50:58 <Cale> It has nice hashing algorithms and can simulate life-in-life tolerably quickly.
18:51:14 <Cale> actually, not just tolerably quickly, really insanely quickly :)
18:51:22 <iruew> there's no easy way to get the number of system ticks in hugs? ):
18:51:28 <SamB> quicker than the toplevel life?
18:51:30 <dons> hugs? hmm, +s ?
18:51:40 <dons> you could use ghci -- it uses less ticks in general :)
18:51:55 <SamB> less of what kind of ticks?
18:52:03 <Cale> SamB: Well, the toplevel life can go at hundreds of millions of generations per second, for example.
18:52:18 <Cale> or more, even
18:52:21 <iruew> well, for now I'd just like to get the number of system ticks, not reduce them (;
18:52:31 <Cale> er, oops :)
18:52:34 <dons> Prelude> :set +s
18:52:34 <dons> Prelude> last [1..10000000]
18:52:34 <dons> 10000000
18:52:35 <dons> (0.72 secs, 402117900 bytes)
18:52:37 <dons> that kind of thing?
18:52:51 <iruew> I need to do it in code
18:52:57 <dons> oh, you want system time?
18:53:03 <iruew> yeah
18:53:18 <dons> http://haskell.org/haskellwiki/Timing_computations
18:53:19 <lambdabot> Title: Timing computations - HaskellWiki
18:53:28 <dons> import System.CPUTime
18:53:42 <dons> 'ticks' usually doesn't mean system time, but say, reduction steps
18:53:51 <dons> well, at least i found that ambiguous
18:54:00 <iruew> thanks dons
18:54:06 <dons> no worries
18:54:22 <allbery_b> that's cpu time, not wall time.  not what I was thinking of, but maybe what the OP wanted
18:54:41 <dons> wall time can be obtained similarly
18:55:02 <dons> the trick though, iruew is to force evaluation :)
18:55:12 <dons> timing lazy computations can be an amusing exercise
18:55:34 <jaj> is the source for lambdabot available?
18:55:45 <iruew> I don't need to do any timing, just going to use the cpu time as a seed for generating pseudorandom numbers
18:55:48 <LoganCapaldo> @where lambdabot
18:55:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:56:12 <jaj> LoganCapaldo, thanks!
18:56:31 <LoganCapaldo> welcome
18:56:56 <dons> ?version
18:56:57 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
18:56:57 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:57:23 <dons> iruew: ah, simple then. i believe the native System.Random does that anyway
18:59:34 <hpaste>  (anonymous) annotated "(no title)" with "clean-ups" at http://hpaste.org/3260#a1
19:08:41 <hpaste>  (anonymous) annotated "(no title)" with "DRY" at http://hpaste.org/3260#a2
19:17:45 <hpaste>  newsham pasted "haskell types and natural deduction" at http://hpaste.org/3261
19:24:39 <Tac-Tics> Who here likes SQL?
19:25:40 <Tac-Tics> (Tac is trying to figure out how SQL statements can be formalized in Haskell, but is having issues with GroupBy and aggregate functions)
19:26:29 <jbalint> hrm, whats the issue
19:27:00 <jbalint> have you posted what you've got already somewhere
19:28:40 <newsham> tac: my opinion is db's are large complicated over used and over valued.  rarely needed, doesn't end up saving much time (sometimes costs a lot more time to use) and requires lifetime maintainance (db admin!)
19:29:02 <newsham> but thats just my very opinionated opinion
19:29:32 <newsham> i noticed a bunch of people want to add syntactic sugar to languages (including haskell) to make them more sql-like.
19:29:47 <newsham> not quite sure how I feel about that just yet
19:29:48 <Tac-Tics> newsham, Your opinion is lovely, and here is a chance to spread it if you want..... because that's essentially what I'm trying to do
19:30:23 <Tac-Tics> but I just want to know how to formalize GROUP BY into Haskell
19:30:41 <newsham> tac: wadler just gave a talk about that.  the video is online
22:07:14 --- topic: '["The Haskell programming language: homeground of the lambdacats!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ", "http://arcanux.org/lambdacats.html" ]'
22:07:14 --- topic: set by dons on [Wed Oct 10 16:54:09 2007]
22:07:42 <sclv> I could roll my own pretty easy, but if there's one out there that folks tend to use, i'd prefer that.
22:07:51 <dainanaki> hmm
22:08:02 <dainanaki> seems like if there was, it would be in the prelude
22:21:02 <sclv> >  let chunk x = unfoldr (\a-> let a' = splitAt x a in case a' of ([],[]) -> Nothing; otherwise -> Just a') in chunk 3 [1..10]
22:21:03 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
22:21:15 <sclv> anyone can golf it into something nicer?
22:23:12 <sjanssen> >  let chunk x = unfoldr (\a-> case splitAt x a ([],[]) -> Nothing; a' -> Just a') in chunk 3 [1..10] -- slightly shorter
22:23:13 <lambdabot>  Parse error
22:23:25 <sjanssen> >  let chunk x = unfoldr (\a-> case splitAt x a of ([],[]) -> Nothing; a' -> Just a') in chunk 3 [1..10] -- slightly shorter
22:23:27 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
22:27:34 <sclv> @src Data.Map.map
22:27:35 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:27:52 <sclv> :t Data.Map.map
22:27:54 <lambdabot> forall a b k. (a -> b) -> Data.Map.Map k a -> Data.Map.Map k b
22:28:14 <sclv> grr... why does it do that?
22:29:43 <sclv> even if I do a "import Data.Map as M" it still gives me "ambiguous occurrence" if I try to call the prelude's map. is there something I'm doing wrong in my qualified imports?
22:30:02 <sclv> @instances Map
22:30:02 <lambdabot> Couldn't find class `Map'. Try @instances-importing
22:30:13 <sclv> @instances Data.Map.Map
22:30:14 <lambdabot> Couldn't find class `Data.Map.Map'. Try @instances-importing
22:30:29 <sclv> @instances-importing Data.Map Map
22:30:30 <lambdabot> Couldn't find class `Map'. Try @instances-importing
22:30:55 <sclv> anyway, its a functor, right? so just use fmap frcrying out loud
22:31:01 <sorear> there is no map class!
22:31:17 <sorear> import qualified Data.Map as M
22:31:48 <sclv> oh, right. i wanted to see what it was an instance of, not the other way round. anyway, thanks on the qualified thing.
22:35:34 <sclv> @src maximum
22:35:34 <lambdabot> maximum [] = undefined
22:35:34 <lambdabot> maximum xs = foldl1 max xs
22:41:41 <ibid> sclv: you're missing "qualified" there
22:41:56 <ibid> sclv: "import qualified Data.Map as Map"
22:42:04 <sclv> thx
23:00:12 <sclv> @pl  \x y -> (f x y) x y
23:00:13 <lambdabot> join . (flip =<< f)
23:00:25 <sclv> is there a clearer way to pointfree this?
23:02:38 <sorear> no.
23:05:41 <sarehu> why even pointfree it
23:06:42 <sjanssen> f x y x y -- is a little bit strange
23:07:31 <sjanssen> I'm a little curious where that comes from
23:09:48 <sclv> f is actually a whole sequence of composed functions
23:10:18 <sclv> together they create an edit path for a diff and then a function that applies that path to the original inputs
23:40:07 <takamura> hi
23:40:54 <sarehu> hi takamura
23:58:54 <hpaste>  sclv annotated "A pass at a difflike utility" with "Now using the O(ND) algorithm" at http://hpaste.org/3208#a3
