00:10:30 <Pseudonym> Cale: Running now.  I'll let you know in a moment.
00:11:13 <olsner> omniscientIdiot: I can perhaps elaborate what I meant in 8-9 hours or so, when I'm back from work ;-)
00:11:17 <olsner> gotta run though...
00:13:06 <Cale> Pseudonym: nice :)
00:14:49 <omniscientIdiot> I'm getting closer with that TH thing.  I've pulled all the field names from the type.  Now I need to generate some declarations from them.
00:19:11 <Pseudonym> Nice thing.
00:19:15 <Pseudonym> moves :: Board -> [Board]
00:19:50 <Pseudonym> [initialBoard] >>= moves >>= moves >>= moves -- All positions three moves away
00:19:57 <Pseudonym> With duplicates, sadly.
00:20:21 <Cale> Yeah, I used that technique in my pipeline scheduler way back when
00:20:59 <Cale> (splicing off the finished solutions from just the start of the list on each iteration)
00:21:03 <Pseudonym> How did you do the fancy graphics, BTW?
00:21:08 <Cale> inkscape
00:21:12 * Pseudonym nods
00:21:28 <Pseudonym> A breadth-first search also reveals 18 moves.
00:21:36 <Pseudonym> So that's the shortest.
00:21:40 <Cale> cool
00:21:45 <Cale> I just solved it by hand directly in inkscape.
00:21:53 <Pseudonym> [[1],[0,2],[0,1,3],[0,1,2,4],[0,1,2,3,5],[0,1,2,3,4,6],[0,1,3,3,6],[0,2,3,6],[1,
00:21:53 <Pseudonym> 3,6],[2,6],[2,5,7],[2,4,6,7],[3,6,7],[3,5,7,7],[4,7,7],[4,6,7,8],[5,7,8],[6,8],[
00:21:54 <Pseudonym> 7]]
00:21:57 <omniscientIdiot> You fink!
00:22:01 <Pseudonym> That's in reverse, obviously.
00:22:32 <ttfh> hmmm, can pdf be generated as easily as postscript? it's supposed to contain a subset of ps
00:24:20 <Pseudonym> Modulo some commutative moves around 8-10, it looks like that solution is identical.
00:24:26 <Pseudonym> Next question: How many minimal moves are there?
00:24:48 <Pseudonym> And are they all essentially identical?
00:25:34 <dmwit> ttfh: ps2pdf?
00:26:20 <ttfh> dmwit: yes, but my program is going to be used on systems without ps2pdf
00:26:37 <Pseudonym> No, it's not as easy.
00:26:43 <Pseudonym> PDF is highly structured and random-access.
00:27:30 <dmwit> It looks like there are Haskell PDF libraries, though.
00:27:48 <ttfh> ah, that would take care of it
00:28:00 <omniscientIdiot> Is there a way to see the code TH generates?
00:28:06 <jeffz> ttfh: if you read the PDF standard, you'll quickly find out that it is not the same kettle of fish as PostScript.
00:28:08 <opqdonut> Pseudonym: yeah i did that too in a work project a while back
00:28:31 <opqdonut> had to do loads of optimizations on the lookups tho, it ended up looking nothing like the list monad
00:28:46 <Cale> I like how nicely symmetrical the solution I found is.
00:28:47 <opqdonut> sadly i have no access to the code anymore and can't remember the exact solution
00:28:53 <ttfh> hmm, looks like a haskell pdf library would be the best option then
00:29:39 <Tac-Tics2> hackage doesn't have crypto-4.0.3....
00:29:49 <Tac-Tics2> where can I find it?
00:30:34 <Tac-Tics2> this maybe ----> http://darcs.haskell.org/crypto/
00:30:35 <lambdabot> Title: Index of /crypto
00:31:18 <Tac-Tics2> I spent like 20 minutes chasing dependencies for the wrong version T___T
00:31:27 <ttfh> Pseudonym: random-page-access? to render a ps doc at page x, you have to render all pages up to that one right?
00:31:27 <Tac-Tics2> but I guess the new version probably needs those too
00:31:34 <omniscientIdiot> Does anyone know anything about TH?
00:33:25 <sioraiocht_> depends entirely on what TH is
00:33:36 <omniscientIdiot> template haskell
00:33:40 <sioraiocht_> oh
00:33:40 <Pseudonym> ttfh: That's... uh... well, it's not _entirely true.  But it's definitely not true of PDF.
00:33:40 <ttfh> the Truckdriver from Hell?
00:33:41 <sioraiocht_> nope
00:34:00 <Pseudonym> ttfh: There are conventions for PostScript for delimiting pages.
00:34:36 <ttfh> Pseudonym: but isn't there global state in ps?
00:35:17 <Pseudonym> All covered in the conventions.
00:35:27 <ttfh> alright
00:35:34 <jeffz> ttfh: some people adhere to conventions for pages, some don't, I have written several PostScript programs which don't follow the DSC standard or what not.  They decide it's time for a new page based on the amount of drawing that has been done.
00:35:38 <Pseudonym> Yeah.
00:36:16 <jeffz> it's all nice and flexible really :D
00:36:29 <Tac-Tics2> Network/MySQL/Protocol.hs:23:69:
00:36:30 <Tac-Tics2>     Module `Data.Binary.Get' does not export `getLazyByteStringNul'
00:36:42 <Tac-Tics2> 30 minutes of fighting this, and it won't compile
00:36:58 <ttfh> hehe, I remember when I started at the university, the guys responsible for the intro-programming labs showed us all kinds of fun stuff they did in postscript :-)
00:37:41 <Tac-Tics2> ah good, more people who had this problem
00:37:43 <Tac-Tics2> *tries again*
00:37:46 <Cale> A friend of mine did all his Fractals assignments in postscript
00:38:12 <ttfh> Cale: Just don't send it to the printer...
00:38:18 <opqdonut> :))
00:38:30 <opqdonut> i still think that ps web server is the coolest thing
00:38:32 <Cale> ttfh: heh
00:38:38 <opqdonut> okay, after that raytracer done in sed
00:38:52 <Cale> The university had pretty fast printers actually
00:39:30 <Pseudonym> I did fractals and Penrose tiles in postscript.
00:39:54 <jeffz> opqdonut: I did a ps irc bot, sort of.  It worked but needed more work.
00:40:01 <hpaste>  omniscientIdiot pasted "Not in scope: `field_'" at http://hpaste.org/3018
00:40:21 <ttfh> It was a sport to do the first 3 lab assignments in weird languages, on guy wrote the first lab in Sendmail
00:41:11 <Pseudonym> Anyway, better head off.  Nytol!
00:41:14 <ttfh> then he wrote game of life using some, among other things, some property of symlinks
00:41:55 <opqdonut> :P
00:42:06 <jeffz> opqdonut: http://jeffz.name/gs/ if you haven't seen it already :p
00:42:07 <lambdabot> Title: jeffz.name
00:42:29 <opqdonut> yeh
00:42:30 <jeffz> i'll fix it someday.
00:43:40 <omniscientIdiot> is anyone reading the paste?
00:48:55 <Cale> What's the error?
00:49:00 <Cale> oh
00:49:34 <Cale> hmm
00:50:39 <omniscientIdiot> I'll paste the whole file.
00:51:38 <hpaste>  (anonymous) annotated "Not in scope: `field_'" with "FRef.hs" at http://hpaste.org/3018#a1
00:52:26 <hpaste>  omniscientIdiot annotated "Not in scope: `field_'" with "test.hs" at http://hpaste.org/3018#a2
00:55:29 * omniscientIdiot is writing code / learning TH from the seat of his pants :)
00:56:12 <Cale> Well, obviously the problem is that what is getting spliced in is a literal field_ and not the value of field_
00:56:17 <ttfh> hmm, looks like Cairo might be what I'm looking for, lots of nice output formats
00:56:36 <omniscientIdiot> yes, I tried $(lift field) but that was a syntax error.
00:56:53 <Cale> But I forget too much TH to remember how to handle that...
00:57:08 <Cale> also what TH I remember was before [d| ... |] was syntax
00:57:09 <omniscientIdiot> maybe I should just build the Dec manually...
01:01:16 <omniscientIdiot> strangely, the "not in scope: 'field_'" error refers to the FRef.hs module, not test.hs
01:01:44 <Tac-Tics2> why is the lazy byte string constructor called LPS and not LBS?
01:01:52 <omniscientIdiot> pack?
01:02:02 <Tac-Tics2> good enough
01:02:08 <taruti> PackedString. historical reasons.
01:02:26 <omniscientIdiot> dons is fond of his hysterical raisons
01:06:19 <omniscientIdiot> @seen Igloo
01:06:19 <lambdabot> Igloo is in #haskell-hac07, #haskell-soc, #haskell, #ghc and #darcs. I last heard Igloo speak 3d 8h 18m 28s ago.
01:08:57 <ttfh> does gtkhs work on windows?
01:18:17 <levi13> where does ghci keep its configuration file?
01:21:05 <Cale> ~/.ghci
01:21:29 <roconnor> $ cat ~/.ghci
01:21:29 <roconnor> :set -fno-print-bind-result
01:21:52 <levi13> thanks
01:24:07 <Tac-Tics2> how to you get a [Char] out of a ByteString?
01:24:26 <Tac-Tics2> @hoogle ByteString -> String
01:24:26 <lambdabot> No matches, try a more general search
01:24:35 <shachaf> unpack, I think.
01:25:31 <Tac-Tics2> unpack seems to convert to a list of Word8's
01:25:34 <omniscientIdiot> map (toEnum . fromEnum) . unpack
01:25:54 <Tac-Tics2> eww
01:26:24 <shachaf> Are you using .Char8?
01:26:57 <Tac-Tics2> I want to just go to the regular builtin String
01:35:42 <Tac-Tics2> sometimes Haskell is cool
01:35:47 <Tac-Tics2> other times it is a really big pain in the toosh
01:37:07 <Tac-Tics2> eventually I would like to see why everyone raves over how cool bytestrings are
01:37:19 <Tac-Tics2> but until then, they are my sworn enemy
01:38:15 <kfish> Tac-Tics, why do you want a normal string? is it for unicode?
01:38:29 <Tac-Tics2> because I know how to use normal strings
01:38:32 <Tac-Tics2> =-P
01:38:44 <kfish> heh
01:38:58 <Tac-Tics2> All I wanted to do was convert a ByteString, which is returned by this mysql library I just downloaded
01:39:01 <Tac-Tics2> and print the results to the screen
01:39:10 <Tac-Tics2> it took me like 30 minutes
01:39:42 <Tac-Tics2> also, this is poor design of the library probably, or at least the author didn't feel like making a nicer wrapper for the full function
01:40:04 <Tac-Tics2> but..... connect (Left ((Just "localhost"), (Just 3306))) "root" (Just "pass") (Just "mydb") []
01:40:25 <kfish> which library is that?
01:40:35 <Tac-Tics2> is kinda ridiculous hard to type for such a common action (connecting to the database)
01:40:50 <Tac-Tics2> http://www.serpentine.com/blog/software/mysql/
01:40:51 <lambdabot> Title: teideal glic deisbh√©alach ª mysql - Haskell language bindings for MySQL
01:41:17 <Tac-Tics2> I tried this because the other Haskell MySQL interface was segfaulting my ass
01:41:22 <Tac-Tics2> X-(
01:41:45 <quicksilver> Tac-Tics2: converting a bytestring is 'unpack'
01:41:49 <quicksilver> Tac-Tics2: that's not very hard?
01:42:12 <Tac-Tics2> that translates it to [Word8]
01:42:18 <Tac-Tics2> Chars are unicode, right?
01:42:35 <Tac-Tics2> Is Word8 just an alias of Char?
01:42:45 <kfish> no, word8 is word8
01:42:51 <Tac-Tics2> that's what I thought
01:42:58 <kfish> bytestring does not do any charset conversion
01:43:13 <Tac-Tics2> yeah, which is fine, the data is all just ascii
01:43:24 <dibblego> let f _ [] = []; f x (y:ys) = (x, y) : f y ys -- is there a library function to shorten this?
01:43:32 <Tac-Tics2> but I don't like spending so much time trying to figure out why my types are wrong
01:43:35 <kfish> Tac-Tics2, ok, so how did you end up getting it to work?
01:43:58 <dibblego> > let f _ [] = []; f x (y:ys) = (x, y) : f y ys in f 1 [2..10] -- is there a library function to shorten this?
01:43:59 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
01:44:06 <Tac-Tics2> Omni science idiot said to fromBS = map (toEnum . fromEnum) . LB.unpack
01:44:11 <Tac-Tics2> and that worked
01:44:21 <Tac-Tics2> but that really seems to me like it should be built into the library...
01:44:31 <omniscientIdiot> > (\xs -> zip xs (tail xs)) [1..10]
01:44:33 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
01:44:35 <Tac-Tics2> the ByteString module already redoes about half of the prelude
01:44:43 <dibblego> ah of course, thanks
01:44:47 <Tac-Tics2> I don't see why they can't just add one more function to it
01:47:59 <quicksilver> Tac-Tics2: if you want chars, you should use bytestring.char
01:48:11 <quicksilver> Tac-Tics2: and then unpack gives you [Char]
01:48:54 <Tac-Tics2> ah
01:49:12 <quicksilver> Tac-Tics2: you shouldn't be using the word8 version if it's chars you're after :)
01:49:27 <Tac-Tics2> the word8 version is the default for some reason
01:49:35 <Tac-Tics2> I didn't know the .Char existed
01:49:43 <Tac-Tics2> it's not in the Wikibooks =-(
01:49:44 <Tac-Tics2> hehe
01:50:17 <hpaste>  omniscientIdiot annotated "Not in scope: `field_'" with "it works, but YUUUUCK!" at http://hpaste.org/3018#a3
01:50:59 <kfish> Tac-Tics2, bytestring is basically an alternative implementation of lists, specialized to bytes of data for efficiency (and compatibility with C) -- you can pack/unpack to ordinary lists, but otherwise its not compatibile with the prelude functions
01:51:16 <Tac-Tics2> I figured as much
01:51:20 <omniscientIdiot> Cale: ^^
01:51:45 <Cale> omniscientIdiot: hehe
01:52:01 <omniscientIdiot> now I've run into the MMR
01:52:06 * omniscientIdiot bangs head on desk
01:52:27 <Cale> -fno-monomorphism-restriction
01:52:47 <omniscientIdiot> in the client module?
01:53:05 <Tac-Tics2> that's just lovely >_> this library returns NULL sql values as IO Exceptions
01:53:14 <Cale> omniscientIdiot: oh
01:53:28 <Cale> omniscientIdiot: I suppose maybe you can generate a type signature?
01:53:39 * omniscientIdiot bangs head on desk HARDER
01:54:07 <omniscientIdiot> I suppose I could...
01:54:56 <Cale> omniscientIdiot: I think this kind of code is why TH doesn't really get used too much.
01:55:32 <omniscientIdiot> it was gravy until I couldn't splice into a decl quotation
02:03:48 <omniscientIdiot> oh, damn, the type decl will be a lot harder
02:09:45 <Zevv> 2/cl
02:41:09 <Tac-Tics2> why would HSQL's getFieldValueMB be deprecated???
02:41:17 <Tac-Tics2> Maybe is so much nicer to deal with in Haskell than IO exceptions
02:42:45 <quicksilver> Tac-Tics2: Odd. Which docs show it as deprecated?
02:43:19 <Tac-Tics2> it's not the doc... it's a warning when I run the code
02:43:31 <Tac-Tics2> but thankfully, I found out why my code segfaulted when I tried it a few weeks ago
02:43:57 <quicksilver> Tac-Tics2: I agree that seems very odd. Maybe is the natural way to deal with NULL.
02:44:00 <Tac-Tics2> (you need to call fetch before the first read.... it should probably raise an exception instead of segfaulting....)
02:44:20 <quicksilver> Tac-Tics2: I guess it's annoying if you know that the field is NOT NULL though :)
02:44:21 <Tac-Tics2> the guys who make HSQL really don't want to let their secret out
02:44:30 <Tac-Tics2> the documentation for it is piss poor =-(
02:44:47 <Tac-Tics2> well, they suggest using getFieldValue
02:44:54 <Tac-Tics2> which raises a SQL exception on NULL
02:45:07 <quicksilver> that makes sense for NOT NULL fields :)
02:45:14 <Tac-Tics2> yeah
02:45:20 <quicksilver> but it doesn't make much sense for fields where NULL is an expected value
02:45:21 <Tac-Tics2> which are probably more common
02:45:22 <Tac-Tics2> but still yeah
02:45:38 <Tac-Tics2> I wonder if there's a way to contact the authors and ask about that
02:47:49 <Tac-Tics2> this works just lovely now
02:47:57 <Tac-Tics2> that makes me very happy
02:48:00 <Tac-Tics2> and that's good
02:48:12 <Tac-Tics2> because 2 hours from now when I need to wake up... I'm going to be quite sad
02:50:42 <Tac-Tics2> quicksilver: do you know much about HaskellDB?
02:55:15 <quicksilver> Tac-Tics2: only a little
03:00:50 <Tac-Tics2> I only asked because you seemed to be the only other person awake in the channel ^^;
03:00:58 <quicksilver> ;)
03:01:56 <quicksilver> you coul dalso look at takusen
03:02:35 <infrared> i'm awake :)
03:02:39 <Tac-Tics2> wassat?
03:02:48 <quicksilver> it's another haskell-DB interface
03:02:50 <roconnor> > logBase 2 199
03:02:52 <lambdabot>  7.636624620543649
03:02:58 <Tac-Tics2> how does it differ?
03:03:07 * quicksilver shrugs
03:03:14 <quicksilver> by being different :P
03:03:15 <Tac-Tics2> > 2 ** 7.63552462
03:03:16 <lambdabot>  198.84832783668577
03:03:26 <quicksilver> I've not used any of them, I"m not sure if the details
03:04:14 <Tac-Tics2> I want to start working on a new web app with a friend of mine
03:04:21 <Tac-Tics2> and I was looking into various technologies we could use for it
03:04:32 <quicksilver> hAppS is the coolest :)
03:04:38 <quicksilver> it doesn't use a DB at all
03:04:45 <Tac-Tics2> of course, I was hesitant to use haskell
03:04:48 <Tac-Tics2> because it scares the shit out of me
03:04:52 <Tac-Tics2> and he's a C++ programmer
03:04:58 <Tac-Tics2> so Haskell would probably be fatal to him
03:05:08 <Tac-Tics2> how does hAppS work sans a database?
03:05:38 <Tac-Tics2> (My is a pretty standard database driven app, so I think I probably should look into this anyway)
03:05:55 <quicksilver> hAppS has a transparemnt persistence layer
03:06:03 <quicksilver> it just persists your haskell values
03:06:12 <quicksilver> so you don't need to think about how to map them to a DB
03:06:48 <Tac-Tics2> persistence layer?
03:06:55 <Tac-Tics2> what if it crashes? ^^
03:07:01 <quicksilver> don't be daft
03:07:06 <quicksilver> it's haskell, how could it crash?
03:07:08 <quicksilver> it type checks!
03:07:10 <quicksilver> :P
03:07:11 <Tac-Tics2> hah
03:07:12 <Tac-Tics2> awesome
03:07:29 <quicksilver> well it does write stuff out ot files, I presume
03:07:29 <Tac-Tics2> also, omg my desktop was clean this morning, but after gathering all the dependencies for everything, it's a murky swamp of sourcecode
03:07:36 <quicksilver> so if it crashes you just read them in from the files again
03:07:44 <quicksilver> I've not used hAppS personally
03:07:51 <quicksilver> the point is you don't have to design a schema
03:08:08 <quicksilver> you just use haskell values as normal and the library takes care of making sure they're around for the next request
03:08:21 <Tac-Tics2> huh weird
03:08:32 <Tac-Tics2> what about referencial values?
03:08:44 <roconnor> @dice
03:08:44 <lambdabot> unexpected end of input: expecting number
03:08:45 <Tac-Tics2> like if a department has a manager id in a SQL DB
03:08:51 <roconnor> @dice 1d100
03:08:51 <lambdabot> 1d100 => 3
03:08:53 <roconnor> @dice 1d100
03:08:54 <lambdabot> 1d100 => 62
03:08:55 <Tac-Tics2> then how would it do something like that in Happs?
03:09:25 <igel> @dice 1d0
03:09:25 <lambdabot> 1d0 => 1
03:09:29 <igel> :D
03:09:56 <infrared> Tac-Tics2: if you have to work with legacy databse you don't have the luxury to use a custom persistence layer
03:10:20 <Tac-Tics2> I don't have any legacy, infrared
03:10:22 <Tac-Tics2> not yet at least
03:10:42 <infrared> Tac-Tics2: what about the manager id then?
03:11:25 <Tac-Tics2> nevermind, It's too early in the morning to learn more about neat things
03:11:32 <Tac-Tics2> I'll have to wait until tomorrow I think
03:11:48 <Tac-Tics2> night all~
03:13:58 <quicksilver> Ther is an interesting implied question there
03:14:10 <quicksilver> hmm
03:14:27 <infrared> what question?
03:16:38 <quicksilver> I don't know how it serialise IORefs
03:16:43 <quicksilver> or MVars or whatever
03:16:53 * SamB wonders why he has the GL_EXT_Cg_shader and GL_ARB_shading_language_100 extensions now...
03:17:03 <quicksilver> (supposing you have 3 employees which all "refer" to the same manager)
03:17:14 <infrared> oh, HAppS
03:17:17 <quicksilver> yeah
03:17:30 <quicksilver> TVars, I guess, in fact
03:17:38 <quicksilver> I'm sure they have a good answr :)
03:17:57 <infrared> they say:
03:18:00 <infrared> "You represent state with the Haskell data structure you find most natural for that purpose. Your app then is just a set of state transformer functions (in the MACID Monad) that take an event and state as input and that evaluate to a new state, a response, and a (possibly null) set of sideeffects."
03:18:20 <SamB> quicksilver: I think you don't serialize *them*
03:18:35 <quicksilver> maybe I have to build my own reference scheme then
03:18:43 <quicksilver> like storing my employees in a Data.Map from ints
03:18:48 <quicksilver> and storing int 'employee ids'
03:19:09 <quicksilver> I guess that's a better way to do things than messing about with IORefs/MVars, on reflection
03:19:28 <infrared> there's also HAppS.DBMS
03:19:50 <infrared> which simulates a relational db
03:20:02 <SamB> simulates?
03:20:19 <SamB> how do you simulate a relational DB?
03:20:34 <infrared> well, it acts like one
03:20:53 <infrared> see http://happs.org/src/HAppS/DBMS/Example.hs for an example of how that may look
03:20:57 <taruti> quicksilver: using an MVar would not be a pretty solution in normal Haskell either.
03:21:10 <SamB> wouldn't that be called "implements"?
03:21:16 <taruti> quicksilver: using a ManagerId is quite tidy and is the way it is done in e.g. databases.
03:21:17 <quicksilver> taruti: yes, on reflection I came to that conclusion :)
03:21:36 <quicksilver> taruti: a.k.a. "If something needs identity, give it a name!"
03:21:42 <taruti> yes
03:24:51 <Baughn> SamB: Clearly, it is not a /real/ relational db unless it uses sql. ;)
03:25:12 <SamB> Baughn: uh huh
03:25:29 <SamB> maybe by "simulation" he meant "slow implementation" ;-P
03:26:32 <infrared> that's how it is with simulations ;)
03:26:43 <Baughn> SamB: That does seem to be what simulation means, in cs. Witness my x86 simulator.
03:26:47 <quicksilver> Baughn: s/unless/if/ :P
03:27:03 <quicksilver> Baughn: isn't that an 'emulator' ?
03:27:39 <Baughn> quicksilver: Perhaps. Traditionally, a simulator is more exact - down to cache timings and such.
03:28:09 <quicksilver> ah, right enouh
03:28:18 <SamB> of course, simulations can also be done of things like elevators...
03:28:24 <SamB> with people
03:29:19 <SamB> Baughn: hmm, console emulators are supposed to have pretty exact timing too...
03:29:34 <infrared> leading us to the people simulation.. sims anybody? ;)
03:29:43 <SamB> though I'm not sure it would matter so much for consoles that actually had cache timing to worry about
03:29:57 <SamB> sim tower yay
03:30:05 <Baughn> SamB: Console emulators need exact timing because there are multiple interacting chips
03:30:06 <quicksilver> consoles have video timings to worry about, don't they?
03:30:21 <quicksilver> well sound, too. IO timings.
03:30:48 <SamB> quicksilver: many of them do
03:31:01 <SamB> perhaps all
03:31:19 <SamB> 2600 has extreme video timings ;-P
03:34:42 <quicksilver> on which subjet, I can'tseem to work out how to make haskell/opengl vsync
03:34:53 <quicksilver> there seem to be about 100 different opengl vsync extensions
03:35:02 <quicksilver> but I can't find a haskell interface to any of them
03:36:33 <SamB> 100?
03:36:37 <SamB> what are they all called/
03:37:18 <quicksilver> What word to use for 'surcharge'
03:37:21 <quicksilver> oops
03:37:23 <quicksilver> wrong paste :)
03:38:01 <quicksilver> GLX_MESA_swap_control, GLX_OML_sync_control, GLX_SGI_video_sync,
03:38:05 <quicksilver> SamB: stuff like that
03:38:44 <quicksilver> those are of course GLX extensions, not GL extensions...
03:38:54 <quicksilver> but I dodn't understand if there is or isn't a non-X specific equivalent
03:39:50 <SamB> hmm, there's WGL_OML_sync_control
03:39:56 <Boney> @src foldr
03:39:56 <lambdabot> foldr k z xs = go xs
03:39:57 <lambdabot>     where go []     = z
03:39:57 <lambdabot>           go (y:ys) = y `k` go ys
03:39:58 <Boney> @src foldl
03:39:58 <lambdabot> foldl f z xs = lgo z xs
03:39:58 <lambdabot>     where lgo z []     =  z
03:39:58 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
03:41:07 <jeffz> WGL_ is windows specific
03:41:17 <SamB> jeffz: I know that
03:41:22 <jeffz> ah ok :)
03:41:25 <quicksilver> SamB: right. All the web pages a quick google brought up only dealt with the windows one
03:41:41 <quicksilver> SamB: seemed a bit odd; seemed like something that GLUT should have, really
03:42:03 <quicksilver> after all GLUT knows how to make windows, and make fullscreen. I'd hope it would know how to vsync too.
03:44:19 * Boney thinks.
03:44:45 <Boney> so foldl is the tail-recursive one and foldr is the one that creates N thunks
03:45:22 <quicksilver> foldl creates thunks too
03:45:55 <EvilTerran> foldl is the one that always makes the O(n) thunk
03:46:22 <Boney> so foldl makes one think which is O(n)
03:46:34 <Boney> and foldr makes N thunks which are O(1)
03:46:46 <SamB> okay now remind me what foldl' does differently?
03:47:09 <infrared> SamB: it evaluates thunks as they are being created
03:47:12 <quicksilver> SamB: it tries to force the thunks
03:47:16 <platypus> @src foldl'
03:47:17 <lambdabot> foldl' f a []     = a
03:47:17 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:47:22 <quicksilver> SamB: which works if they're some simple atomic datatype
03:47:30 <quicksilver> SamB: but doesn't really do anything useful if they're more complex
03:47:55 <SamB> quicksilver: does give you a fighting chance, at least
03:48:02 <infrared> unless the operation on those datatypes forces evaluation
03:49:29 <infrared> so it depends what you'll use as an operator
03:50:06 <SamB> honestly, I don't have a clue why there have to be seperate extensions for wgl and glx...
03:50:29 <SamB> the OML ones seem to be virtually identical
03:50:36 <quicksilver> SamB: I agree, it seems very weird to me
03:50:43 <SamB> except for the name of the extension and the function names
03:50:53 <quicksilver> SamB: on the train I develop under OSX (that's what my laptop is) and I see visible tearing :(
03:51:07 <SamB> hmm
03:51:14 <SamB> I found a paragraph that might not be
03:52:15 <SamB>     wglSwapLayerBuffersMscOML works identically to wglSwapBuffersMscOML,
03:52:20 <SamB>     glXSwapBuffersMscOML will return the value that will correspond to
03:54:59 <SamB> oh, apparantly WGL doesn't even have an extension mechanism...
03:58:28 <quicksilver> SamB: what does 'OML' stnad for in that context, do you know?
03:58:37 <SamB> no I don't
03:59:44 * SamB thinks he's late for class...
04:15:04 <araujo> morning
04:25:47 <dons> interesting, http://kevin.scaldeferri.com/blog/2007/09/29/UrlSpider1HaXML.html
04:25:50 <lambdabot> Title: Kevin's Weblog 2007-09-29
05:06:19 * Cale tries to remember whose blog that would be
05:06:40 <Cale> I'm sure there's been someone around here lately asking questions about HaXML and HXT :)
05:17:39 <quicksilver> tagsoup ftw!
05:32:32 <nominolo> > sequence [[2,3],[4,5,6],[7,8],[9,10]]
05:32:37 <lambdabot>  [[2,4,7,9],[2,4,7,10],[2,4,8,9],[2,4,8,10],[2,5,7,9],[2,5,7,10],[2,5,8,9],[2...
05:53:57 <Cale> quicksilver: the application was XHTML verification, so I don't know about that :)
05:57:00 <iguana_> hi, does anyone know a library that converts between color systems?
05:58:50 <Cale> I tend to use wikipedia ;)
05:59:19 <quicksilver> iguana_: the formula are pretty simple and you only need to write them once :)
05:59:21 <Cale> There are formulas for converting between colour systems there
05:59:26 <quicksilver> iguana_: it would be a small library
05:59:32 <quicksilver> iguana_: (but the answer to your question is no)
05:59:55 <Cale> Still, perhaps a good idea for something to put up on hackage.
06:00:25 <quicksilver> certainly I've vaguely wanted HSV when programing in openGL
06:00:41 <quicksilver> HSV is a much more convenient a lot of the time
06:00:41 * ddarius needs HSV conversion so he can make garish rainbow colored text.
06:01:29 * quicksilver wants it for pastel rainbow coloured text
06:01:38 <quicksilver> HSV isn't only for garish!
06:01:44 * ddarius knows.
06:01:51 * ddarius values the saturation direction.
06:02:06 * quicksilver saturates the value direction.
06:02:21 <ddarius> Most people do.
06:05:02 <ddarius> Having Lab* conversion would be sweet too.
06:05:29 <xelxebar> is there a way to pull a case of statement out of infix notation?  (case of) x doesn't seem to work
06:05:52 <quicksilver> xelxebar: not really sure what you mean?
06:05:55 <mrd> xelxebar: what for?
06:06:14 <quicksilver> xelxebar: bear in mind that haskell terms always have types; what would be the type of "(case of)"
06:06:22 <xelxebar> to do something like M >>= (case of) ...
06:06:40 <quicksilver> ah, that is sometimes requested
06:06:44 <mrd> M >>= \x -> case x of
06:06:51 <quicksilver> people call it 'lambdacase'
06:06:55 <quicksilver> or, some people do
06:07:02 <quicksilver> but for now, you have to write it as mrd says
06:07:10 <xelxebar> ah, thanks
06:07:38 <ddarius> Which is far from arduous
06:08:05 <quicksilver> xelxebar: http://hackage.haskell.org/trac/haskell-prime/ticket/41
06:08:06 <lambdabot> Title: #41 (add LambdaCase) - Haskell Prime - Trac
06:08:07 <quicksilver> FYI
06:13:29 <iguana_> when is haskell' planned to be decided upon?
06:13:45 <mrd> sometime in the next century
06:14:10 <iguana_> ok, I'll expect it in 93 years then
06:14:17 <allbery_b> when they stop arguing over features.  which suggests sometime between 10 years and never :)
06:14:38 <iguana_> looks like they need a BDFL
06:14:53 <ddarius> We've gotten along just fine without one so far.
06:14:55 <quicksilver> Cale: ooh, the wikipedia page on HSV has an example of an HSV-separation of an image. That's really pretty.
06:15:46 <gour> quicksilver: why don't you rewrite cinelerra in haskell ;)
06:15:54 <Cale> quicksilver: yeah, it's fun what you can do by taking an image in one colourspace and reinterpreting the components in another
06:15:56 <iguana_> quicksilver: that image looks like a Bob Ross painting :)
06:16:14 <quicksilver> I was interested by the fact that the mountains were uniformly blue in hue
06:16:19 <quicksilver> but varying in saturation and lightness
06:16:25 <quicksilver> that was not at all obvious from the original
06:24:12 <MADnificent> can anyone point me to a good guide about monads? I have some _basic_ understanding about them
06:24:34 <Cale> MADnificent: well, I wrote some tutorials
06:24:49 <MADnificent> Cale: bring em on! :-D
06:24:58 <Cale> MADnificent: is there any aspect in particular that you're interested in?
06:25:38 <fox86> are there any conventions for naming functions and stuff in haskell? like fooBar, foo_bar or foo-bar?
06:25:52 <taruti> fooBar
06:25:54 <quicksilver> fox86: certainly not the last, you can't use '-'
06:26:01 <fox86> ah, okay
06:26:02 <Cale> http://haskell.org/haskellwiki/Monads_as_computation -- this gives a high-level overview from a pragmatic programming perspective
06:26:02 <MADnificent> I'm trying to grasp what they are exactly and how to build them.  But I am interested in everything about them...
06:26:03 <lambdabot> Title: Monads as computation - HaskellWiki
06:26:08 <quicksilver> fox86: the standard libs tend towards fooBar
06:26:13 <quicksilver> fox86: as in hPutStrLn
06:26:24 <fox86> quicksilver: ah. i will stick to that then
06:26:45 <fox86> does ghc work on mac os? i read somewhere that it wasn't supported
06:26:59 <MADnificent> Cale: I'll be back soon!
06:27:01 <Cale> http://haskell.org/haskellwiki/Monads_as_containers -- this takes an alternative route to explaining them, one which I found works very well to get some people started, and often comes in handy in defining monads
06:27:02 <lambdabot> Title: Monads as containers - HaskellWiki
06:27:30 <Cale> I also wrote http://haskell.org/haskellwiki/Introduction_to_IO which is a very short blurb about the right way to think about I/O in Haskell.
06:27:31 <lambdabot> Title: Introduction to IO - HaskellWiki
06:27:45 <Cale> MADnificent: be sure to ask questions :)
06:28:02 <Cale> MADnificent: I can also point you at more comprehensive resources for details about things.
06:28:09 <MADnificent> Cale: ty! I'll start with the last one, I've done some IO already
06:28:10 <quicksilver> fox86: it works well
06:28:15 <quicksilver> fox86: I use it almost every day :)
06:28:46 <fox86> quicksilver: oh, that's great. i read it in an interview with that peyton-jones guy. maybe he meant the ppc architecture or something, because it only said "mac"
06:29:10 <quicksilver> fox86: odd. Maybe he meant that there wasn't much of a native code generator for PPC
06:29:27 <quicksilver> fox86: but even so it works fine going via C and GCC
06:29:30 <fox86> quicksilver: hm, i'll try to find the webpage again
06:29:49 <quicksilver> actually this mac is intel anyway. But I used to have a G4 and run ghc on that.
06:30:19 <iguana_> Cale: it took me a time to figure out that "IO a" is *not* a container for a...
06:30:54 <Cale> iguana_: Well, it's an incredibly strange sort of container for values of type a :)
06:31:36 <iguana_> I really like SPJ's "action that is performed" term
06:31:46 <allbery_b> ppc working fine here
06:31:57 <Cale> iguana_: yeah
06:32:01 <EvilTerran> it's a note from the RTS saying "ask nicely and i'll give you an a"
06:32:03 <allbery_b> in fact I'm building latest ghc head as we speak
06:32:08 <EvilTerran> i guess you could say it's an IO(U) ;)
06:32:12 <Cale> iguana_: I think of values of type (IO a) as literal program scripts.
06:32:26 <MADnificent> iguana_: I currently think about monads as some thing amorph, there are multiple things it can represent.  But to get the first idea, it might be good to focus on one thing...
06:32:28 <allbery_b> ...recent ghc is a *lot* faster than 6.6 on ppc, btw
06:33:12 <Cale> MADnificent: Yeah, the monad abstraction is, well, very abstract. So there are multiple ways to make analogies to more concrete things.
06:33:15 <kpreid> IO a is less strange than a -> b.
06:33:30 <iguana_> the list and maybe monads confused me a bit first
06:33:37 <Cale> MADnificent: This is what happens when you steal ideas from the most abstract branches of mathematics ;)
06:33:40 <iguana_> they are quite different from IO
06:33:48 <quicksilver> I think 'action' is a very good word
06:33:57 <quicksilver> although I also like Moggi's phrase "computation"
06:34:12 <MADnificent> Cale: pure insanity?
06:34:14 <quicksilver> you don't have to understand veru much maths or category theory to skim read moggi's paper and pick up the key ideas
06:34:41 <Cale> Yeah, you have to understand that the 'action' and 'computation' are in some sense nouned verbs though.
06:35:04 <quicksilver> It's also intersting to re-interpret Maybe and [] as actions
06:35:05 <Cale> When you have an IO action, it's not something which is happening, but something which describes something to do.
06:35:18 <quicksilver> [a] is "An action which, when performed produces multiple values of type a"
06:35:30 <quicksilver> Maybe is the same ecept it's always zero or one
06:35:32 <Cale> backtracking makes that strange :)
06:35:38 <iguana_> quicksilver: only that you don't have to perform it any more
06:35:55 <MADnificent> how are IO actions implemented?
06:35:56 <quicksilver> iguana_: I don't think that matters though
06:36:03 <quicksilver> iguana_: that's an implementation detail :)
06:36:09 <Cale> MADnificent: horrible hackery, but this needn't be so.
06:36:16 <iguana_> quicksilver: after you understand it, it doesn't matter anymore, yes
06:36:23 <quicksilver> iguana_: there could be other types *like* [a] which did more work
06:36:24 <allbery_b> madnificent: there are several implementations
06:36:28 <allbery_b> @go IO Inside
06:36:30 <lambdabot> http://haskell.org/haskellwiki/IO_inside
06:36:30 <lambdabot> Title: IO inside - HaskellWiki
06:36:41 <iguana_> are there?
06:36:59 <allbery_b> ghc's, hugs', nhc98's, ...
06:37:38 <Cale> MADnificent: Currently in GHC, they're implemented by functions of type RealWorld -> (RealWorld, a), where the RealWorld type is just a token which is passed around to get the data dependencies right, and the function actually is impure, not a proper pure Haskell function.
06:37:42 <MADnificent> allbery_b: first I'll try to walk, then I'll try to run ^_^
06:37:43 <allbery_b> the appendix to "IO Inside" describes three of the ones in actual use
06:37:55 <quicksilver> iguana_: IO [a] is a monad
06:38:11 <Cale> That is, the evaluator does evil stuff, but since that evl stuff has been packaged up the right way, we can show that it behaves correctly.
06:38:13 <quicksilver> iguana_: I don't recal if [IO a] is, or not
06:38:16 <Cale> evil*
06:38:19 <allbery_b> actually, the real secret to an IO action is that it's just a partially applied function
06:38:33 <quicksilver> Cale: is [IO a] a monad, or is only IO [a] ?
06:38:45 <Cale> quicksilver: neither is a monad
06:38:58 <Cale> [] is a monad, as is IO
06:39:08 <quicksilver> Cale: are they not composable at all?
06:39:10 <allbery_b> in GHC, it's implemented as functions that are waiting for something to apply a RealWorld# value
06:39:24 <quicksilver> Cale: I thought ListT was broken in detail but not in principle
06:39:28 <Cale> no, /\a -> IO [a] and /\a -> [IO a] aren't monads
06:39:44 <Cale> quicksilver: Oh, it's very broken even in practice
06:40:09 <iguana_> what does ListT do?
06:40:10 <MADnificent> Cale: maybe it would be wise to explicitly split IO operations and monads in guides.  I think I'm not the only one that has issues with the forms a monad can take
06:40:11 <Cale> quicksilver: It won't produce a monad when applied to any monad that has state.
06:40:20 <MADnificent> isn't [] a monad too?
06:40:25 <quicksilver> Cale: is it easy to explain why /\ a -> IO [a] can't be a monad?
06:40:31 <Cale> MADnificent: [] is a monad
06:40:56 <Cale> quicksilver: It'll fail the associative law.
06:41:10 <Cale> quicksilver: I might have an example kicking around, and if not, I can produce one.
06:42:13 * Cale roots around in his files
06:42:49 <Cale> oh, haha, still on hpaste
06:42:52 <Cale> http://hpaste.org/2930
06:43:20 <Cale> If ListT applied to State isn't a monad, then surely ListT applied to IO isn't.
06:44:36 <Cale> MADnificent: Perhaps I'll give you an intro to some easier monads. IO is probably the most complicated monad. (But on the other hand, it has some familiarity to it if you're used to imperative programming)
06:44:51 <Cale> MADnificent: The list monad is a good example.
06:45:07 <Cale> So in that monad we have   return :: a -> [a]
06:45:13 <Cale> return x = [x]
06:45:17 <Cale> Pretty easy :)
06:45:22 <MADnificent> Cale: this may be an interesting approach to monads too: You don't really know when a function will be evaluated, it will only be evaluated if the result is needed. This is contrast to monads, which you force to run...  That separation might clear up some minds too...
06:45:46 <quicksilver> Cale: but listt can be fixed, according to http://www.haskell.org/haskellwiki/ListT_done_right ?
06:45:48 <lambdabot> Title: ListT done right - HaskellWiki
06:45:53 <Cale> MADnificent: Oh, you kind of force them to run, but many monads make use of laziness too.
06:46:05 <MADnificent> Cale: but if I'd run return x... I could get [a]  or maybe the return-function of some other monad... how does haskell know which return function I want?
06:46:06 <matthew_-> am I right in thinking that there could many valid (as in obeying the laws) implementations of Monad for the same type which each have different behaviour?
06:46:09 <Cale> quicksilver: Yeah, but that gives something pretty drastically different.
06:46:27 <Cale> MADnificent: type inference
06:46:37 <Cale> > return 5 :: [Integer]
06:46:39 <lambdabot>  [5]
06:46:43 <Cale> > return 5 :: Maybe Integer
06:46:44 <lambdabot>  Just 5
06:46:56 <Cale> > runState (return 5) 7
06:46:57 <lambdabot>  (5,7)
06:47:23 <quicksilver> matthew_-: yes
06:47:30 <Cale> Which monad depends on the context -- which type is demanded by the rest of the program, or by explicit type signatures.
06:47:30 <MADnificent> Cale: and I'd be allowed to type return 5 :: [Integer] in a let-binding too?  (and in a where?)
06:47:35 <Cale> yeah
06:47:44 <Cale> Do you know about typeclasses yet?
06:47:55 <MADnificent> Cale: yes, I've read about it
06:48:06 * MADnificent is astonished
06:48:13 <Cale> It's the exact same mechanism which Haskell uses to decide what to do when you write  5 == 7
06:48:20 <matthew_-> False
06:48:22 <Cale> Or [1,2,3] == [5,6]
06:48:26 <matthew_-> False
06:48:28 <Cale> hehe
06:48:42 * matthew_- does what he's good at. Answering trivial questions
06:48:51 <MADnificent> matthew_-: LoL
06:49:00 <Cale> The code which is needed to make those comparisons is different, but due to the types, it can be determined which is needed.
06:49:06 <opqdonut> matthew_-: welcome, captain obvious! :)
06:49:12 <matthew_-> False
06:49:14 <MADnificent> Cale: I assumed it would do it that way, I like to make things explicit in a learning stage though
06:49:16 <gour> matthew-_: answering or computing?
06:49:19 <quicksilver> Cale: oh, I see. Interesting. THat "ListT done right" is actually a bit like "unsafeInterleaveM done right" :)
06:49:29 <matthew_-> gour: computing sounds a bit too hard...
06:49:31 <quicksilver> Cale: scattering monads right down the ADT
06:49:46 <gour> mattam: dong actions?
06:49:53 <gour> *doing
06:49:58 <MADnificent> Cale: ty for the insights
06:50:00 <Cale> MADnificent: okay
06:50:03 <Cale> MADnificent: so bind
06:50:11 <Cale> (>>=) :: [a] -> (a -> [b]) -> [b]
06:50:17 <gour> matthew-_: doing actions?
06:50:31 <Cale> xs >>= f = concat (map f xs)
06:50:40 <matthew_-> gour: eh?
06:50:44 <MADnificent> Cale: I understand those methods ( return >>= >> )
06:50:50 <Cale> MADnificent: okay
06:51:09 <gour> matthew-_: instead of answering you're doing actions which produce answers :-)
06:51:13 <MADnificent> Cale: at least if I study them for a sec
06:51:20 <matthew_-> gour: err, yeah, ok
06:51:31 <Cale> So in the list monad, "running" a computation is just picking an element of the list. I'll illustrate it:
06:51:37 <matthew_-> False
06:51:42 <Cale> > do { x <- [1,2,3]; y <- [4,5]; return (x,y) }
06:51:44 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
06:52:02 <Cale> x is chosen from [1,2,3] in each possible way
06:52:17 <Cale> and for each of those possibilities, y is chosen from [4,5] in each possible way
06:52:54 <Cale> That's what the xs >>= f = concat (map f xs) definition boils down to.
06:53:01 <MADnificent> Cale: yes, I get it... thought I wouldn't think of it myself just yet
06:53:21 <matthew_-> eeek, that's nastily inefficient, as each of those returns ends up as a single [(a,b)] and then concat shoves em all together doesn't it?
06:53:22 <iguana_> and that's how list comprehensions are implemented?
06:53:42 <Cale> iguana_: used to be, but not anymore unfortunately
06:53:49 <iguana_> unfortunately?
06:54:06 <Cale> There's a function called guard which is effectively defined as  guard p = if p then return () else []
06:54:15 <Cale> (it's actually more general, but I'll ignore that for now)
06:55:21 <quicksilver> matthew_-: not really, no. Trust the optimiser :)
06:56:17 <Cale> The effect (which might be a little hard to see without really blasting all the definitions out) is that it causes backtracking when p is false
06:56:35 <EvilTerran> the asymptotic complexity's still okay, even without optimisation, so it's cool ;D
06:56:47 <Cale> > do { x <- [1..20]; y <- [x..20]; z <- [y..20]; guard (x^2 + y^2 == z^2); return (x,y,z) }
06:56:49 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
06:57:04 <Cale> This is the same as the list comprehension:
06:57:23 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
06:57:24 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
06:57:43 <MADnificent> Cale: okay, gimme a sec to understand it
06:58:08 <MADnificent> Cale: what module is guard in?
06:58:14 <Cale> MADnificent: Control.Monad
07:00:15 <MADnificent> Cale: if it return m () then the values are in the returned monad?
07:00:26 <MADnificent> s/return/returns
07:00:46 <Cale> (return x) produces the computation which always returns x
07:00:56 <Cale> In the case of the list monad,  return x = [x]
07:01:06 <Cale> So return () is just another way to write [()]
07:01:20 <Cale> and picking an element from [()] will succeed
07:01:26 <EvilTerran> [(),()] is also :: m (), where m = [], though
07:01:44 <Cale> because although () is an uninteresting value, it is something :)
07:02:00 <Cale> picking an element from [] on the other hand, fails miserably
07:02:04 <EvilTerran> > do i <- [1..10]; guard (odd i); return i
07:02:06 <lambdabot>  [1,3,5,7,9]
07:02:17 <EvilTerran> > guard False :: [a]
07:02:18 <lambdabot>   [a]
07:02:18 <lambdabot>       Inferred type: [()]
07:02:18 <lambdabot>     In the expression: guard False
07:02:18 <lambdabot>     In the...
07:02:21 <dylan> 6~/msg lambdabot @hoogle guard
07:02:23 <dylan> err
07:02:25 <EvilTerran> > guard False :: [()] -- even
07:02:27 <lambdabot>  []
07:02:33 <Cale> > do { x <- [1,2,3]; []; return x }
07:02:34 <lambdabot>  []
07:02:36 <EvilTerran> > guard True :: [()] -- even
07:02:38 <lambdabot>  [()]
07:02:39 <Cale> > do { x <- [1,2,3]; return x }
07:02:40 <lambdabot>  [1,2,3]
07:02:45 <EvilTerran> > do { x <- [1,2,3]; [()]; return x }
07:02:46 <lambdabot>  [1,2,3]
07:02:59 <Cale> > do { x <- [1,2,3]; [(),()]; return x }
07:03:00 <lambdabot>  [1,1,2,2,3,3]
07:03:08 <Cale> maybe too many examples all at once :)
07:03:08 <MADnificent> Cale: right, and it was mapping all the data...
07:03:21 <EvilTerran> > [1,2,3] >>= join replicate
07:03:22 <lambdabot>  [1,2,2,3,3,3]
07:03:38 <Cale> EvilTerran: no ((->) e) just yet please :)
07:03:43 <EvilTerran> sorry
07:03:48 <MADnificent> :-P
07:03:50 <EvilTerran> (join f x = f x x, here)
07:03:51 <MADnificent> gimme a sec
07:03:52 <Cale> We'll get to it soon :)
07:04:37 <Cale> MADnificent: the important thing I suppose is that [] >> y = []
07:04:42 <EvilTerran> do i <- [1,2,3]; replicate i i -- same thing
07:04:44 <Cale> and [()] >> y = y
07:05:01 <EvilTerran> [undefined] >> y = y, also
07:05:28 <MADnificent> [_] >> y = y
07:05:50 <quicksilver> right
07:05:56 <EvilTerran> replicate n _ >> y = replicate n y
07:06:24 <Cale> > replicate 5 'h'
07:06:25 <lambdabot>  "hhhhh"
07:06:45 <MADnificent> I don't quite get   do { x <- [1,2,3]; [(),()]; return x }    (reading up)
07:06:51 <Cale> okay
07:06:53 <quicksilver> > replicate 5 "ignored" >> 'h'
07:06:54 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Char'
07:06:57 <Cale> So for each x in [1,2,3]
07:06:57 <quicksilver> oops
07:07:09 <Cale> and each element of [(),()]
07:07:16 <sieni> > [1..5] >> "h"
07:07:17 <lambdabot>  "hhhhh"
07:07:19 <Cale> it returns x into the final result
07:07:26 <quicksilver> sieni: yeah, I was missing a 'return'
07:07:35 <Cale> MADnificent: perhaps this would help...
07:07:42 <Cale> > do { x <- [1,2,3]; y <- [(),()]; return x }
07:07:43 <lambdabot>  [1,1,2,2,3,3]
07:08:10 <Cale> does that make more sense?
07:08:20 <Cale> > do { x <- [1,2,3]; y <- [4,5]; return (x,y) }
07:08:21 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
07:08:26 <Cale> > do { x <- [1,2,3]; y <- [4,5]; return x }
07:08:27 <lambdabot>  [1,1,2,2,3,3]
07:08:33 <Cale> > do { x <- [1,2,3]; y <- [(),()]; return x }
07:08:34 <lambdabot>  [1,1,2,2,3,3]
07:08:40 <Cale> > do { x <- [1,2,3]; [(),()]; return x }
07:08:41 <lambdabot>  [1,1,2,2,3,3]
07:08:53 <MADnificent> Cale: sec, I've just written down the  xs >>= f = concat (map f xs)   should be easier to understand with that by my side
07:09:01 <Cale> yeah
07:09:14 <Cale> So perhaps I should actually write that in not-do-notation
07:09:26 <Cale> [1,2,3] >>= \x -> [(),()] >> return x
07:09:44 <Cale> = [1,2,3] >>= \x -> [(),()] >> [x]
07:09:55 <Cale> = [1,2,3] >>= \x -> [(),()] >>= \y -> [x]
07:10:08 <help_me> Hi, is darcs.net down for anybody else? I'm trying to figure out if its just a problem here at work
07:10:13 <Cale> = [1,2,3] >>= \x -> concat (map (\y -> [x]) [(),()])
07:10:32 <Cale> = [1,2,3] >>= \x -> concat [[x],[x]]
07:10:39 <Cale> = [1,2,3] >>= \x -> [x,x]
07:10:44 <MADnificent> Cale: I thought >> dropped the previous result?
07:10:48 <Cale> yeah
07:10:59 <Cale> x >> y = x >>= \k -> y
07:11:17 <MADnificent> Cale: oh sorry, got it...
07:11:33 <Cale> = concat (map (\x -> [x,x]) [1,2,3])
07:11:48 <Cale> = concat [[1,1],[2,2],[3,3]]
07:11:53 <MADnificent> Cale: what did the () return?  it is nothing, then how come do { x <- [1,2,3]; [(),()]; return x } returns a list with two times 1 in it... that is my problem...
07:11:55 <Cale> = [1,1,2,2,3,3]
07:12:14 * mux notes Cale has an in-brain graph reduction machine
07:12:15 <Cale> MADnificent: look up in my calculation there
07:12:41 <Cale> MADnificent: the ()'s each provided a spot for the map to stick something (a constant function got mapped over that list)
07:13:01 <Cale> > map (\y -> [1]) [(),()]
07:13:01 <MADnificent> Cale: I get it!
07:13:03 <lambdabot>  [[1],[1]]
07:13:23 <Cale> > concat (map (\y -> [1]) [(),()])
07:13:24 <lambdabot>  [1,1]
07:13:30 <MADnificent> Cale: going over do { x <- [1,2,3]; y <- [4,5]; return x } to  do { x <- [1,2,3]; y <- [(),()]; return x } again dit it :-)
07:13:37 <Cale> > [(),()] >>= \y -> [1]
07:13:38 <lambdabot>  [1,1]
07:13:43 <Cale> MADnificent: yeah :)
07:13:44 <MADnificent> how stupid of me, not to get it :-)  (ty)
07:13:54 <Cale> MADnificent: no problem :)
07:14:05 <Cale> MADnificent: I know this can be confusing the first time :)
07:14:20 <MADnificent> Cale: that's why I'm so interested \o/
07:15:03 <Cale> So yeah, the list monad is great for small nondeterminism problems, (and even some pretty big ones, because laziness helps out a lot)
07:15:06 * MADnificent gets some coffee to get the knowledge deeper in the brain
07:15:30 <Cale> I actually used the list monad to write a pipeline scheduler for PPC+Altivec assembly :)
07:15:40 <MADnificent> Cale: such a beautifull solution to ugly code
07:15:49 <MADnificent> Cale: LoL
07:17:35 <Cale> > [1,2,3] >>= \x -> [x, x*10]
07:17:37 <lambdabot>  [1,10,2,20,3,30]
07:17:59 <quicksilver> Cale: all those "Examples" of what goes wrong with listT are couched in terms of failure of >> to associate
07:18:13 <Cale> quicksilver: yeah, that's the law which fails
07:18:17 <quicksilver> Cale: I wonder if it's actually easier to see what happens if you look at failure of 'join' instead
07:18:23 <quicksilver> Cale: I normally find join more intuitive than >>
07:18:34 <Cale> quicksilver: ah, yeah, maybe
07:19:21 <Cale> quicksilver: It's possible to understand the problem in terms of >> though
07:19:48 <Cale> quicksilver: The trouble is that when you backtrack, the state doesn't backtrack with you.
07:20:26 <Cale> So it's possible to tell something about the structure of the attempts.
07:20:47 <quicksilver> I note that sigfpe manages to use ListT State in a blog post
07:20:53 <quicksilver> so obviously it did what he wanted it to
07:21:00 <quicksilver> even if it wasn't behaving monadically :)
07:21:02 <Cale> Yeah, you can use it, it just isn't a monad.
07:21:38 <Cale> It's almost possible to comprehend what happens in it, but in a large program, it would be impossible to manage.
07:21:45 * quicksilver nods
07:21:55 <Cale> Because the way in which you factored that program into definitions would change its behaviour.
07:21:59 <MADnificent> Cale: another thing that makes them slightly harder to understand: monads `should' follow some rules, but they work even outside of the boundaries of their own rules...
07:22:00 <phobes> Err, why is there ListT if it's not the monad transformer?
07:22:25 <Cale> MADnificent: that's just a failure of Haskell to check the laws for you
07:22:35 <Philippa> MADnificent: that's just a case of "the type system can't enforce it"
07:22:55 <quicksilver> MADnificent: similarly the type system doesn't check that (+) and (*) satisfy distributivity
07:22:55 <Philippa> and they only 'work' outside those boundaries until someone tries to use a rule
07:23:06 <Cale> MADnificent: If you design a monad that doesn't satisfy the laws, the type system might not complain, but your users will :)
07:23:20 <Cale> a "monad"
07:23:22 <phobes> In LiftT State a, you're getting one copy of the state, right?  Not one for each branch?
07:23:25 * mux demdands a refund!
07:23:27 <MADnificent> so, in fact, it doesn't really 'work' ?
07:23:29 <Cale> phobes: yeah
07:23:42 <Philippa> MADnificent: right, it just looks like it for a long time
07:23:48 <Cale> MADnificent: well, the monad laws effectively tell you that certain refactorings are always safe
07:23:48 <MADnificent> LoL
07:24:11 <Cale> MADnificent: these are very basic refactorings which people will apply without thinking about it
07:24:41 <Cale> like that it's okay to take a chunk of code out of the middle of a do-block, define it as its own do-block and call it.
07:24:51 <Cale> (and have that mean the same thing)
07:24:54 <MADnificent> however, if I don't instantiate from Monad (probably evil), then I don't tell people what will probably work... And that does allow me to build a rule-system of my own (or am I wrong?)
07:25:01 <Cale> sure
07:25:21 <Cale> In fact, there are lots of other systems which your thing might already be
07:25:33 <Cale> For example, maybe it's an Applicative functor
07:25:44 <Cale> or maybe you'd be better off designing an Arrow
07:25:48 <Cale> or a Comonad
07:25:52 <MADnificent> Cale: so, haskell can do it, but by telling others you instantiate the Monad, you explicitly tell them that you will obey these rules...
07:26:01 <Cale> These are all different styles of library which people have abstracted over
07:26:06 <Cale> yeah
07:26:18 <Cale> You could also just define your own operations
07:26:18 <MADnificent> Cale: I wasn't thinking of anything in particular
07:26:24 <Cale> like you said
07:26:44 <quicksilver> although the special do block syntax only exists for monads
07:26:45 <Cale> The point of Monads is that you can define a bunch of things which actually work in all monads.
07:26:52 <Cale> and work reasonably sensibly :)
07:26:59 <quicksilver> so in a sense the rules are much more important for them than for other abstractions
07:27:14 <phobes> Cale:  Like what?
07:27:14 <quicksilver> you might write an applicative which broke the applicative rules, but that would actually cause the same kind of problems
07:27:16 <MADnificent> Cale: once you're used to them, it'll be way more important, I guess
07:27:25 <quicksilver> s/would/wouldn't/
07:27:27 <Cale> phobes: Like all the stuff in Control.Monad :)
07:27:39 <Cale> quicksilver: hm?
07:27:46 <Cale> quicksilver: sure it would :)
07:28:01 <phobes> ya ok
07:28:08 <quicksilver> Cale: the fact that do blocks have special syntax
07:28:18 <quicksilver> Cale: means if you break the monad laws inherent in the desugaring
07:28:20 <Cale> quicksilver: yeah, but that's desugared in a well-defined way
07:28:24 <quicksilver> Cale: then you break stuff
07:28:34 <shapr> @yow !
07:28:35 <lambdabot> I want the presidency so bad I can already taste the hors d'oeuvres.
07:28:43 <Cale> In fact, I really like the look of the monad laws in do-notation
07:28:51 <Cale> They're really quite intuitive then
07:29:05 <Cale> 1. do { w <- return v; f w }
07:29:05 <Cale> == do { f v }
07:29:06 <shapr> Is there anything like Transformers.lhs for Arrows?
07:29:11 <Cale> 2. do { v <- x; return v }
07:29:11 <Cale> == do { x }
07:29:19 <Cale> 3. do w <- do v <- x
07:29:19 <Cale>               f v
07:29:19 <Cale>       g w
07:29:19 <Cale>  
07:29:19 <Cale> == do v <- x
07:29:20 <Cale>       w <- f v
07:29:22 <Cale>       g w
07:29:35 <shapr> That is nice.
07:29:54 <Cale> The 1st and 2nd basically say that return v doesn't do anything but return v.
07:29:55 <quicksilver> Cale: right, exactly.
07:30:02 <shapr> I need to put up a new blog.
07:30:03 <quicksilver> Cale: especially the 3rd
07:30:17 <quicksilver> Cale: my point is that if you break the 3rd law, you 'break' an obvious kind of refactoring
07:30:20 <Cale> The 3rd basically says that it's okay to factor out a block of code from the middle (usually to put it into its own definition)
07:30:28 <Cale> right
07:30:35 <quicksilver> Cale: however, if you break an Applicative law, you won't have any such horrible problems
07:30:42 <Cale> But if you break the Applicative laws, you also break refactorings
07:30:43 <quicksilver> Cale: since Applicative doesn't come with a special syntaxz
07:30:56 <quicksilver> you don't break "obvious" ones like that, though
07:30:57 <quicksilver> :)
07:31:13 <phobes> Well, doesn't the compiler know about the Monad laws in the form of rewrite rules?
07:31:16 <quicksilver> The point I'm trying to make is that a programmer might attempt that 3rd refactoring without thinking he "knows" the monad laws
07:31:21 <Cale> I suppose it's that the laws are what is suggested by the syntax.
07:31:25 <quicksilver> because it's just "obvious" from the syntax
07:31:27 <quicksilver> exactly
07:31:48 <quicksilver> however, with applicative, the program would be very obviously and explicitly applying the laws
07:31:57 <quicksilver> /program/programmer/
07:32:00 <quicksilver> # lazy fingers!
07:32:03 <phobes> Or do rewrite rules never apply to classes?
07:32:20 <quicksilver> phobes: as far as I know, the compiler doesn't have any of the monad laws as RULES
07:32:28 <sjanssen> phobes: there aren't any rewrite rules for the Monad laws
07:32:32 <quicksilver> phobes: because it's not obvious that any of them is an 'optimisation'
07:32:50 <Cale> Well, the unit laws probably always are.
07:32:57 <Cale> But they're tiny
07:32:59 <quicksilver> Cale: but they're caught by inlining
07:33:00 <sjanssen> also because they could potentially change the semantics of a program with -O
07:33:02 <Cale> yeha
07:33:20 <Cale> sjanssen: Only if it doesn't obey the laws!
07:33:23 <quicksilver> phobes: most of the obvious optimisations are caught by existing GHC optimisations, assuming all your methods get inlined
07:33:24 <phobes> or with ListT :)
07:33:32 <sjanssen> even though Monads *should* obey the laws, the compiler doesn't have the right to randomly change the program when they don't
07:33:49 <phobes> ok
07:34:05 <dylan> @quote first monad law
07:34:06 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
07:34:13 <dylan> @quote first.monad.law
07:34:14 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
07:34:20 <dylan> :(
07:34:21 <Cale> Hehe, GHC compiled code can cause segfaults when compiled with bad instances of Ix though...
07:34:24 <pjd> the first law of monads is, you do not talk about monads
07:34:33 <quicksilver> dylan: No compiler shall hurt a monad or, through inaction, allow a monad to come to harm.
07:34:38 <dylan> 22:23 <lament> First monad law: A monad may not injure a human being or, through inaction, allow a human being to come to harm.
07:34:47 <LeCamarade> The second: you don
07:34:52 <LeCamarade> 't tell anyone.
07:35:02 <LeCamarade> The third: GHC is always right.
07:35:08 <quicksilver> sjanssen: I would debate that, actually.
07:35:09 <Cale> MADnificent: want another example monad? Maybe some of the monad operations?
07:35:19 <MADnificent> Cale: sure
07:35:25 <quicksilver> sjanssen: I think the compiler could choose to exercise that right, if it wanted to.
07:35:29 <phobes> So there's no concept of giving the compiler "potential rewrites" and letting it decide if it wants to apply them?
07:35:33 <LeCamarade> The fourth: If this is your first night at #haskell, you should get monads.
07:36:29 <phobes> Has anyone written the "Monads are like a series of tubes" tutorial yet?
07:36:30 <sjanssen> quicksilver: I think it's wrong for a compiler to exploit rules that can't be proven
07:36:31 <Cale> Okay, another sort of easy one, though one which was very poorly understood for a while is the monad ((->) e) -- that is a partially applied function type constructor there
07:36:42 <Cale> So it's the monad of functions from the type e
07:37:26 <MADnificent> Cale: an easy example?
07:37:31 <Cale> A computation in this monad is simply a function which takes a parameter of type e
07:37:35 <quicksilver> sjanssen: I'm not sure why the monad laws are any less "provable" than (say) the build fusion rules
07:37:36 <sjanssen> quicksilver: I also wouldn't be happy if the compiler changed "x+y" to "y+x"
07:37:41 <MADnificent> Cale: okay...
07:37:50 <Cale> and to "run" a computation, you apply it to a parameter, which is passed down to everything
07:37:54 <Cale> so...
07:37:55 <sjanssen> quicksilver: foldr/build fusion is known broken, and that's considered a bug
07:38:02 <quicksilver> sjanssen: right
07:38:08 <quicksilver> sjanssen: but I'm drawing the analogy
07:38:12 <Cale> (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
07:38:14 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
07:38:17 <lambdabot>  ("hello","olleh","HELLO")
07:38:26 <quicksilver> sjanssen: foldr/build is a proof obligation, it can be proved, it's not totally trivial
07:38:32 <quicksilver> sjanssen: and it's a useful optimisation
07:38:47 <quicksilver> sjanssen: the monad laws are a proof obligation, they can be proved, it's not totally trivial...
07:38:48 <Cale> So here, x is id "hello", y is reverse "hello", and z is map toUpper "hello"
07:38:56 <phobes> x+y should equal y+x ...
07:38:57 <quicksilver> sjanssen: the difference is, it's not obvious that they're a useful optimisation :)
07:38:58 <MADnificent> Cale: I was actually looking for that one...
07:39:09 <iguana_> Cale: wow, that is new to me
07:39:12 <sjanssen> quicksilver: note that foldr/build is slated to be replaced by a system that doesn't have the same bug
07:39:18 <quicksilver> sjanssen: right
07:39:29 <quicksilver> sjanssen: but that doesn't change the general thrust of my argument?
07:39:31 <MADnificent> Cale: I've written the same thing as an RMap (or something like that) yesterday or so
07:39:33 <quicksilver> sjanssen: RULES need proving...
07:39:35 <iguana_> Cale: what's fai
07:39:38 <iguana_> l in that monad?
07:39:43 <quicksilver> sjanssen: I think the monad laws are just as eligible as any others to be proved
07:39:44 <Cale> iguana_: undefined
07:39:53 <Cale> iguana_: fail really shouldn't be in the Monad class
07:40:12 <quicksilver> sjanssen: I just don't think that (in practice) they represent code optimisations, so it's not clear the work would be worth it
07:40:15 <Cale> It's a bug in the standard that it is.
07:40:15 <iguana_> why? it's handy for Maybe and List, at least
07:40:24 <EvilTerran> phobes, even in floating point?
07:40:30 <quicksilver> > mzero :: Maybe Int
07:40:32 <lambdabot>  Nothing
07:40:35 <Cale> iguana_: Because many monads (maybe even most monads) are not like Maybe and List in that way
07:40:37 <quicksilver> ^^ better than fail :)
07:40:42 <phobes> EvilTerran:  + shouldn't be defined on floating point :)
07:40:42 <EvilTerran> iguana_, for that, people can use MonadPlus
07:40:49 <iguana_> better? it has no error message :)
07:40:49 <EvilTerran> or fork off MonadZero again
07:40:59 <Cale> iguana_: We used to have MonadZero, and I think it ought to come back
07:41:07 <MADnificent> Cale: why is it a bug? it is a feature...
07:41:08 <EvilTerran> phobes, hehe.
07:41:41 <Cale> MADnificent: fail is a bug in the standard because it's not part of the definition of a monad, and many monads can't define it in any way but "please crash the program now"
07:42:13 * iguana_ looks for the instance for Monad (-> e)
07:42:16 <MADnificent> Cale: yeah, but you can override it, no?
07:42:23 <phobes> EvilTerran:  I'm not really joking ... though I'm not sure haskell is the right language to follow through that program
07:42:24 <MADnificent> Cale: visitor, sorry awk
07:42:31 <sjanssen> quicksilver: I do see your point, various floating point optimizations make similar tradeoffs
07:42:47 <Cale> MADnificent: Well, it's built into the do-syntax translation in a way which makes that hard.
07:42:50 <EvilTerran> i see
07:43:21 <quicksilver> sjanssen: in a similar vein, I wouldn't mind having a CommutativeMonoid class which included a rule that the compiler was permitted to replace x+++y with y+++x
07:43:25 <Cale> MADnificent: specifically, if pattern matches can fail, then the do-notation is translated in a slightly more complicated way, which calls fail when they do.
07:43:39 <MADnificent> Cale: yea, I read about it... you may be right, it isn't really something about monads (maybe the do notation should've been in a different)
07:43:42 <quicksilver> sjanssen: but, in practice it would be very hard to imagine what kind of heuristic the compiler could use to see if that's actually worth doing :)
07:44:04 <Cale> MADnificent: it used to be that using a failable pattern in the do-notation would create a MonadZero constraint -- that is, it would insist that your monad be prepared to handle the failure.
07:44:17 <quicksilver> sjanssen: maybe AssociativeAndCommutativeMonoid and then it could replace a right fold with a left fold :)
07:44:43 <Cale> MADnificent: imo, that was the right thing to be doing
07:44:47 <iguana_> now what's a monoid again...
07:44:54 <EvilTerran> ... isn't there another name for that one, quicksilver?
07:45:04 <quicksilver> EvilTerran: :)
07:45:19 <quicksilver> EvilTerran: well mathematically it's jsut commutative
07:45:26 <quicksilver> EvilTerran: all monoids are suposed to be associative
07:45:30 <Cale> monoids are by definition associative
07:45:32 <Cale> yeah
07:45:32 <quicksilver> EvilTerran: haskell doesn't check though
07:45:36 <EvilTerran> i see
07:45:47 <quicksilver> iguana_: something you can 'add' together
07:45:52 <EvilTerran> but there isn't another term for commutative monoid?
07:45:52 * shapr boings cheerfully
07:45:55 <shapr> Good morning #haskell!
07:45:56 <quicksilver> iguana_: the generic example is lists, with (++)
07:46:02 <Cale> EvilTerran: maybe an Abelian monoid
07:46:02 <quicksilver> EvilTerran: not a commonly used one, no
07:46:11 <EvilTerran> okay
07:46:13 <Cale> EvilTerran: but that's not really any shorter :)
07:46:15 <iguana_> ah
07:46:21 <iguana_> complicated name for that simple thing
07:46:30 <EvilTerran> well, it's shorter, but it's obscurer...
07:46:44 <Cale> http://en.wikipedia.org/wiki/Magma_%28algebra%29
07:46:46 <lambdabot> Title: Magma (algebra) - Wikipedia, the free encyclopedia
07:47:14 <quicksilver> As far as I know abelian is "Really" for groups and it was just 'backported' to monoids
07:47:18 <quicksilver> as it were
07:47:28 <phobes> Maybe the rule should be that unless the pattern match ends with "otherwise...", the Monad it's in requires fail
07:47:32 <EvilTerran> that's what i thought, quicksilver
07:47:56 <Cale> phobes: it's only applied in a place where you only have one pattern
07:48:15 <phobes> ah
07:48:25 <Cale> phobes: specifically,  pat <- expr
07:48:41 <phobes> Clearly I was talking about   otherwise <- expr
07:49:00 <Cale> otherwise would just act like any other variable name in that context
07:49:09 <quicksilver> although that does give rise to a very odd idiom
07:49:10 <Cale> and that kind of pattern isn't the issue
07:49:16 <quicksilver> where you use 'return' just to force something into the monoid
07:49:18 <quicksilver> monad
07:49:18 <quicksilver> bah
07:49:25 <quicksilver> so that you can do a pat-fail on it
07:49:37 <Cale> Really, the pattern should be looked at to see if the match could fail
07:49:39 <quicksilver> (Left x,Right y) <- return foo
07:49:46 <quicksilver> ^^ here 'foo' was n't really in the monad, at al
07:49:50 <quicksilver> but I cheat and use return
07:49:53 <Cale> and if so, then the thing gets translated using mzero somewhere
07:49:56 <quicksilver> because I want the 'fail-on-pattern-mismatch'
07:50:08 <Cale> if not, it gets translated in the plain old lambda way
07:50:20 <quicksilver> which is a daft idiom
07:50:57 <iguana_> which module do I have to import to get that nifty (->) monad instance?
07:51:01 <phobes> Cale:  Do you not think it would be useful in general to express that you don't expect this pattern match to fail (even if you're in a situation where fail is possible)?
07:51:06 <Cale> You'd still be able to do that, just only in a MonadZero
07:51:12 <sjanssen> iguana_: Control.Monad.Instances
07:51:17 <iguana_> huh
07:51:29 <iguana_> why doesn't Control.Monad suffice?
07:51:33 <Cale> phobes: well, you can still bind a single variable and then case-match against it
07:51:49 <quicksilver> iguana_: it does, actually
07:51:54 <Cale> phobes: and provide a real error message while you're at it :)
07:52:03 <iguana_> not here
07:52:19 <quicksilver> and Control.Monad.Reader seems to contain it too
07:52:24 <quicksilver> which is logical, since that's what it is
07:52:27 <phobes> Cale:  But you wouldn't provide an error message in the case where you (the programmer) think it's not failable
07:52:46 <hpaste>  iguana pasted "(no title)" at http://hpaste.org/3019
07:52:54 <psnively> Hello all
07:52:55 <iguana_> at least, that ^^^ doesn't work here
07:53:06 <phobes> Seems like it would make sense to have e.g. <- or <~, one of which allows the possibility of failure
07:53:41 <Cale> I suppose you could do that
07:53:42 <quicksilver> iguana_: works for me, must be a GHC version thing
07:53:47 <iguana_> 6.6.1 here
07:53:59 <quicksilver> I'm on 6.6.1 too
07:54:08 <Cale> It would work for me, so long as <- just lambda bound things and didn't use fail at all.
07:54:37 <Cale> MADnificent: anyway, keep getting sidetracked here :)
07:54:38 <phobes> <~ looks more like the one that might to me anyway :)
07:55:09 <sjanssen> Cale: the existing behavior is really useful, I'd be upset if we got rid of it
07:55:11 <hpaste>  quicksilver annotated "(no title)" with "works here" at http://hpaste.org/3019#a1
07:55:43 <Cale> sjanssen: I'm not suggesting getting rid of it completely, only in those monads where it makes no sense.
07:55:48 <sjanssen> by all means move fail out of Monad, but we need some way to the nice pattern match failure
07:55:55 <Cale> sjanssen: Oh, sure
07:56:13 <Cale> sjanssen: I'd suggested that <- with a failable pattern should produce a call to mzero
07:56:20 <Cale> (like in Haskell 1.4)
07:56:36 <crazy_coder> hi
07:56:40 <Cale> phobes was saying maybe there should be two separate arrows
07:56:43 <phobes> Actually, it sounds like if you wanted to change the language without breaking existing code, you have to introduce a new syntax for infallible pattern matching
07:56:47 <phobes> <= maybe
07:56:54 <sjanssen> personally, I'd introduce an mzeroMsg to the class -- the error messages with line numbers are also really useful
07:57:04 <mux> Cale: but that changes the type of a monadic action if there is a pattern match failure, doesn't it?
07:57:06 <Cale> phobes: that's kinda taken :)
07:57:21 <Cale> mux: If there's the potential for it.
07:57:24 <dylan> <= is taken?
07:57:25 <mux> Monad m => m a becomes (Monad m, MonadPlus m) => m a
07:57:31 <Cale> :t (<=)
07:57:33 <lambdabot> forall a. (Ord a) => a -> a -> Bool
07:57:39 <mux> quite problematic, I'd say
07:57:40 <phobes> <=====
07:57:43 <dylan> oh, right
07:57:49 <idnar> <=====8 ?
07:58:12 <sjanssen> idnar: not a valid operator
07:58:15 <Cale> mux: Or better, (MonadZero m) => m a
07:58:22 <mux> err, right
07:58:34 <Cale> mux: which expresses *exactly* what people have been abusing the Monad class for
07:58:40 <mux> well
07:58:51 <mux> to me it's not much a problem for Monad to have a "fail" method
07:59:03 <Cale> It really annoys me to see people use the Monad class to express failure.
07:59:04 <mux> this is expected since you can do pattern matching in any Monad, so you _have_ to provide a fail
07:59:15 <Cale> mux: No you don't
07:59:22 <Cale> mux: Have you seen how 1.4 handled it?
07:59:24 <mux> and it's not that bad if it doesn't match the mathematical monad
07:59:32 <mux> Cale: I've only read you talking about it
07:59:35 <Cale> okay
08:00:49 <Cale> Basically, when you translate do { pat <- expr; stmts }, you look at pat and see if it's a composition of pattern matches on one-constructor types
08:01:02 <Cale> Because if it is, then the pattern match can't fail
08:01:12 <Cale> Otherwise, the match is failable
08:01:44 <pjd> Cale: what happens when it's failable?
08:01:55 <quicksilver> pjd: then you inject a MonadZero constraint
08:01:56 <mux> Cale: but you can't deduce whether any pattern is failable, can you?
08:01:59 <Cale> If it's failable, you translate that as  let { f pat = do { stmts}; f _ = mzero } in expr >>= f
08:02:08 <Cale> mux: I just told you how
08:02:13 <pjd> quicksilver: ah, cool
08:02:14 <quicksilver> pjd: (well type inference does it automatically, in fact)
08:02:18 <mux> I understood that as only working on some patterns
08:02:18 <quicksilver> because of the mzero
08:02:26 <mux> I don't like it that much anyways
08:02:43 <mux> this is quite surprising to see your types changing out of under you when you change a pattern
08:02:45 <Cale> Well, I missed a case, a pattern is unfailable if it's the composition of matches on one-constructor types, and irrefutable patterns
08:03:11 <Cale> mux: You might get a type error -- that's a good thing, because you might have a failing computation
08:03:30 <Cale> mux: It's better to handle those cases with case
08:03:39 <mux> I'd have to think about it :)
08:03:54 <quicksilver> if you've just made a change which tries to inject a failure into a monad which can't handle failure
08:04:01 <quicksilver> then it's just as well to know about it :)
08:04:05 <Cale> If it's unfailable, of course, you'd translate it as expr >>= \pat -> do {stmts}
08:04:30 <mux> I guess I want to hear about the reasons that led to this being removed >:)
08:04:39 <quicksilver> Of course, IO has a MonadPlus instance which is useful for catching exceptions
08:04:45 <Cale> mux: It was kind of an oversight
08:04:51 <quicksilver> but, annoying, it's not really an mzero I want to use for pattern matching
08:04:52 <quicksilver> shame
08:04:52 <sjanssen> the MonadZero system is a bit complicated
08:04:54 <Cale> mux: They removed monad comprehensions
08:05:07 <mux> that will _have_ to go back in
08:05:10 <Cale> and then someone said "hey, now we don't need MonadZero"
08:05:14 <mux> heh
08:05:36 <Cale> "and all the instances of MonadZero are also instances of MonadPlus in the libraries right now anyway"
08:05:49 <mux> GHC still has monad comprehensions, right?
08:05:52 <Cale> no
08:05:56 <mux> (isn't this how HaskellDB works?)
08:06:01 <sjanssen> it's a bit annoying that adding an alternative to a data type could change the type of your program
08:06:02 <mux> and what about NDP?
08:06:03 <Cale> But if someone submits a patch, it will be accepted
08:06:17 <Cale> NDP is parallel array comprehensions
08:06:19 <quicksilver> mux: no, haskellDB embeds it all in [a]
08:06:20 <mux> this is way too big a task for me, unfortunately
08:06:22 <Cale> which are different
08:06:23 <mux> Cale: oh, right.
08:06:36 <mux> I need to give HaskellDB a try.
08:06:37 <sjanssen> mux: the arrays in NDP aren't Monads
08:06:41 <Cale> sjanssen: I don't see that as annoying
08:06:49 <quicksilver> they're not even warm fuzzy things
08:06:53 <quicksilver> they're cold, spiky things
08:06:56 <Cale> sjanssen: It tells me that *oops*, I need to be able to handle that case now.
08:07:07 <mux> a friend of mine was coding some stupid game with SDL & libflirt (an swf reader library), and he dared me to write bindings to libflirt in haskell, saying he'd rewrite his code in haskell then
08:07:14 <quicksilver> sjanssen: removing an alternative can break your program
08:07:19 <mux> I wrote the bindings, and strangely, I can't hear anything from my friend anymore :-)
08:07:25 <Cale> sjanssen: As it stands, I don't think I'll even get warned about it.
08:07:26 * mux reads some .swf animations with haskell
08:07:29 <quicksilver> sjanssen: adding an alternative can make pattern matchings which were exhaustive, no longer so
08:07:39 <quicksilver> sjanssen: I think this is 'along the same lines' as those two
08:11:41 <phobes> One difference with a special operator for infallible pattern matching is that you can write x:xs <-- foo ++ [1]    and still not get a call to mfail
08:12:10 <quicksilver> that's a point
08:12:36 <Cale> Well, in the list monad, that doesn't matter much, but I get what you mean
08:13:06 <vincenz> phobes: how does the compiler ensure it's infallible?
08:13:08 <Cale> I'm just not 100% certain that I'd care about the distinction often enough that it warrants another syntax.
08:13:23 <Cale> vincenz: it wouldn't
08:13:24 <phobes> vincenz:  If you claim it doesn't fail and it does, _|_ ?
08:13:30 <vincenz> so you error on failure?
08:13:41 <Cale> yeah, it'd be like lambda pattern matching
08:13:42 <phobes> yes, rather than calling some custom failure handler
08:13:43 * vincenz wrinkles his nose
08:13:50 <Cale> > (\(x:xs) -> 5) []
08:13:52 <lambdabot>   Non-exhaustive patterns in lambda
08:14:11 <vincenz> > let cale [] = [cale] in cale [cale]
08:14:12 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t1] -> [t]
08:14:12 <lambdabot>     Pr...
08:16:00 <Cale> I like how it actually says "Occurs check", as if every Haskell programmer should know enough to know what part of the unification algorithm that refers to :)
08:16:47 <Cale> At least it's not patronising :)
08:20:08 <Olathe> @src insulting
08:20:09 <lambdabot> Source not found. Are you on drugs?
08:22:39 <kpreid> @quote insult
08:22:39 <lambdabot> dons says: "academic" is such an amusing insult.
08:35:05 <ramza3> hello
08:36:20 <desp> is anyone aware of Haskell-friendly web hosting?
08:36:50 <desp> I found nearlyfreespeech.net, and it looks great
08:37:14 <ramza3> you could do virtual hosting (eg, do it all yourself)
08:37:47 <desp> sure, but that's usually over a student budget ;)
08:38:06 <ramza3> desp: for example (eapps.com), I dont think you will be happy in a shared environment, because you will probably need a compiler and ghc tools, etc
08:38:23 <desp> NFSN offers Haskell support through CGI
08:38:33 <desp> and it appears their pricing is unbeatable :)
08:38:50 <desp> https://www.nearlyfreespeech.net/about/pocket.php
08:39:43 <psnively> But will they host HAppS?
08:40:04 <desp> probably not
08:40:26 <psnively> Yeah. I want an OpenBSD 64-bit host running HAppS. :-)
08:40:33 <desp> :)
08:40:40 <quicksilver> virtualized hosting is getting relatively cheap
08:41:06 <quicksilver> you should be able to find vmware/usermodelinux style hosts for around $10-20/month, I believe
08:41:24 <vincenz> linode.com = 20$/month
08:41:29 <desp> yeah, eapps.com has a 10$/mo plan
08:41:46 <ramza3> yep.  I think linode is another pretty good one.  I wouldn't touch shared hosting though, ick
08:41:56 <desp> but NFSN has as-you-go pricing
08:42:00 <vincenz> ramza3: why's that?
08:42:09 <quicksilver> amazon has as-you-go pricing, too
08:42:15 <quicksilver> but it may not be suitable for what you need
08:42:20 <quicksilver> (EC2/S3 stuff)
08:42:32 <desp> hmm.
08:43:31 <ramza3> vincenz: because there are so many restrictions on what you can use, install, ports you can open; a virtual host like eapps or linode reduces all of that
08:43:33 <vincenz> desp: eapps doesn't give virtual hosting tho, they give wbhosting
08:43:51 <vincenz> ramza3: Oh, I thought you said linode was that...
08:45:15 <ramza3> eapps supports virtual hosting
08:45:27 <psnively> Yeah, I read that HAppS intends to support EC2/S3. That's exciting.
08:45:31 <vincenz> Hmm, what I wonder about linode... how do they get ports to everyone?  How does that work?
08:45:41 <ramza3> is this offtopic?
08:46:21 <vincenz> Somewhat
08:46:30 <desp> HAppS on EC2/S3?
08:46:32 <desp> more info?
08:46:54 <desp> I think this at least is on topic :)
08:47:51 <dylan> vincenz: linode gives each vm its own IP...
08:47:55 <dylan> (or more than one)
08:48:52 <vincenz> Ah, ok
08:49:53 <ramza3> and I think the way virtual hosts work, they share hardware resources, I guess some kind of hardware switching
08:49:57 <quicksilver> desp: I thought the hAppS team found amazon's model unsatisfactory
08:50:04 <quicksilver> desp: even the small compulsory 'cost-per-push' adds up
08:50:14 <quicksilver> desp: and hAppS by design "commits" after every single atomic change
08:50:40 <desp> quicksilver: yeah, I looked at it, and I don't think I can afford to use it for my experimental stuff
08:51:20 <desp> before the last pricing change it was pretty cool
08:51:46 <psnively> Yeah, I had read that they were exploring it, but if their model isn't suitable, oh well.
08:52:09 <quicksilver> psnively: they would argue that the amazon model is broken for any kind of reliable system
08:52:13 <quicksilver> psnively: (and I would agree)
08:52:27 <quicksilver> psnively: doing a 'push' after after transaction is vital for integrity
08:52:39 <quicksilver> psnively: your EC2 machine can vanish at any moment...
08:52:59 <psnively> Yes, no argument. But it's also hard to argue that their business model is inappropriate (for them).
08:53:24 <iguana_> is there a way to convert Unicode character names to a Char?
08:53:47 <quicksilver> psnively: ;)
08:53:56 <quicksilver> psnively: I guess 'broken' is not really fair
08:53:57 <psnively> :-D
08:54:00 <quicksilver> psnively: 'costs money'
08:54:02 <desp> ;)
08:54:05 <psnively> ==quicksilver
08:54:06 <quicksilver> that's probably not unreasonble..
08:54:21 <psnively> "You get what you pay for."
08:56:24 <iguana_> e.g. a unicode database interface?
08:56:57 <allbery_b> iguana_: no
08:57:07 <quicksilver> anyone happen to be an expert on perlin noise?
08:57:14 <allbery_b> even pugs (perl6 in haskell) deferred to perl5 linkage to get them
08:57:28 <iguana_> :(
08:58:10 * allbery_b parsed that as "perl line noise" before realizing it was probably correct as written in *this* channel :)
08:58:30 <quicksilver> ;)
08:59:01 <Zevv> (can anybody point me to some online documentation describing the 'deriving' clause, with some examples?)
09:00:03 <sjanssen> Zevv: deriving merely tells the compiler to make the type an instance of a class
09:00:14 <sjanssen> you can only derive a few built-in classes
09:00:35 <Zevv> like Read, Show, Enum, etc. Are those defined in the prelude ?
09:00:36 <EvilTerran> or on newtypes!
09:02:21 <sjanssen> Zevv: yes, those and a few others
09:05:02 <infrared> I'm trying to build lambdabot and in the prerequisites there's zlib listed. so I darcs get and do "runghc Setup.hs configure"
09:05:10 <infrared> after that I get "Setup.hs: zlib.cabal:14: Invalid syntax (no colon after field name)"
09:05:41 <infrared> line 14 of zlib.cabal is: "flag bytestring_in_base"
09:05:51 <Saizan> infrared: you can try with the package on hackage
09:05:52 <infrared> any ideas how to fix this?
09:06:02 <sjanssen> infrared: use the version on hackage.haskell.org
09:06:07 <allbery_b> you need a newer Cabal to build that one
09:06:21 <allbery_b> so go with the released one that works with the released Cabal
09:06:40 <infrared> allbery_b: newer? I already got 1.1.6, is this out of date?
09:06:45 <sjanssen> @hackage zlib
09:06:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
09:06:51 <psnively> Perlin noise is pretty simple.
09:07:01 <allbery_b> infrared: cabal 2.x is in development
09:07:36 <infrared> allbery_b: oh, ok
09:07:41 <allbery_b> fixing annoyances like bytestring being in base in recent ghc but a library in non-ghc and older ghcs (with no good way to describe that to cabal), etc.
09:07:54 <psnively> But isn't Perlin noise patented, or somesuch?
09:09:00 <sjanssen> infrared: the README recommends the darcs version for no good reason, you're better off with a released version
09:09:19 <infrared> sjanssen: ok, i'm building the zlib from hackage right now
09:09:36 <sjanssen> don't worry, I've just fixed this documentation oversight and have sent the patch to dons ;)
09:09:47 <infrared> sjanssen: great, thanks :)
09:10:24 <infrared> is there any work in making package installation automatic, so i don't have to download it and build manually?
09:10:33 <allbery_b> not yet
09:10:36 <infrared> something I can help with maybe?
09:10:43 <allbery_b> well, there is some work.  nothing widely deployed
09:10:44 <sjanssen> infrared: there is cabal-install, but it's a little rough around the edges
09:10:56 <allbery_b> look around for cabal-install and maybe contriibute to making it a going concern
09:11:17 <psnively> Yeah, I'm surprised Haskell doesn't have a really good Nix-like story.
09:11:19 <infrared> ok, I'll search for cabal-install then, thanks!
09:11:25 <sjanssen> sadly, you have to play the dependency fetch 'n build game to get cabal-install
09:12:05 <infrared> sjanssen: like for all packages on hackage
09:12:13 <CosmicRay> [ just looking in ] psnively: what do you mean by "good Nix-like story"?
09:12:25 <psnively> http://nix.cs.uu.nl/index.html
09:12:27 <lambdabot> Title: Nix
09:12:34 <sjanssen> infrared: btw, cabal-install could certainly use contributions
09:12:49 <psnively> "Nix is a purely functional package manager. It allows multiple versions of a package to be installed side-by-side, ensures that dependency specifications are complete, supports atomic upgrades and rollbacks, allows non-root users to install software, and has many other features."
09:13:06 <sjanssen> infrared: cabal-install has a couple dependencies you have to grap, like an HTTP lib and a couple other things
09:13:12 <sjanssen> s/grap/grab
09:13:24 <infrared> sjanssen: I'll look into it then, I have some experience with python distutils/setuptools stack, so maybe I'll be able to help here
09:14:51 <infrared> but first I have to get the lambabot running ;)
09:15:42 <infrared> *lambdabot
09:18:09 <infrared> compiling, yes :)
09:18:43 <allbery_b> LB isn't actually that hard
09:19:02 <allbery_b> at least if you're not interested in the IDE bits (which I wasn't)
09:19:50 <dylan> I'm wondering, perhaps a bachelor's degree in some field of mathematics would be more useful than one in computer science.. especially given the state of CS programs at my uni...
09:20:17 <EvilTerran> CS is some field of mathematics ;)
09:20:48 <dylan> yes, but I mean, maybe I'll actually learn something in the math department
09:21:49 <mrd> how about independent study with a professor?
09:22:17 <dylan> *squints* one can do that as an undergraduate?
09:22:21 <mrd> most certainly
09:22:37 <mrd> it is almost imperative if you want to go on into good graduate programs
09:22:47 <psnively> Or just take CS seriously, whether your university does or not.
09:22:51 <dylan> Interesting.
09:23:08 <Choko_> Or choose another university
09:23:13 <infrared> should i submit patches for cabal-install to the hackage trac at http://hackage.haskell.org/trac/hackage/wiki ?
09:23:15 <lambdabot> Title: Hackage - Trac
09:23:17 <dylan> mrd: I'll have to look into that.
09:23:19 <psnively> Work through CTM and you'll have a better CS background than most professors, anyway.
09:23:25 <dylan> Choko_: well, moving isn't an option.
09:23:44 <dylan> and I'm having a small panic attack that I'm 22 and have been in college since I was 17 and have nothing to show for it. :(
09:24:06 <psnively> On the contrary. Well, unless you haven't learned anything.
09:24:11 <scodil> what's the best way to write a function that maps small, contiguous ranges of ints to stuff? If I write a big case table on the input, will it get turned into some kind of jump table? or will the code loop through all the cases? I tried looking at the asm but I can't tell.
09:24:44 <dylan> well, I know a bit of everything, it seems. I've taken electrical engineering courses, 3 semesters of spanish...
09:25:00 <mrd> dylan: most professors will be happy to suggest further courses of study, and if they have time, may even be able to advise you
09:25:01 <psnively> Isn't that the point of a liberal arts education?
09:25:29 <merus> To have nothing to show for four years of effort? Pretty much, yes.
09:25:31 <merus> :)
09:25:47 <dylan> of course, given that I dislike taking more than 3 classes at a time is another reason I'm not degree'd yet.
09:26:14 <sebaseba> dylan: Sometimes I feel the same way. I'm 26, doing a phd now, but I don't feel I've learned much. Except that we usually can't remember how our mind was before; we just don't realize how much we've learned.
09:26:33 <mrd> actually, you should probably feel that you know less than before
09:26:36 <mrd> relatively
09:26:45 <psnively> dylan: Sounds like your first step is to find out, concretely, what you would have to do (yet) to get a degree. In anything.
09:27:28 <dylan> psnively: I'd have to take remedial math classes, or re-take a certain test -- and two humanities classes (bleh)
09:27:52 <psnively> Um, OK. So you could get a degree in, what, another semester?
09:27:55 <mrd> ask to test out of remedial classes
09:28:02 <dylan> perhaps two.
09:28:14 <psnively> Yeah: test out of anything you can.
09:28:26 <psnively> Take the boring stuff. Get it over with.
09:28:30 <dylan> (err, technically, there's more classes after that. I'm 2 sessions and 2 years away from a bachelor's)
09:29:04 <psnively> Sounds like it's time to either a) try to test your way out, or b) give up on the degree and get to work.
09:29:20 <dylan> I also had a bad start with the non-remedial math class -- I would complete 50% of the test perfectly and run out of time. I'm not that obsessive now, luckily...
09:29:27 <psnively> BTW, I do not have an undergraduate, so I know whereof I speak.
09:29:43 <dylan> I have a job. :P
09:29:53 <psnively> At some point, you say "I'm not cut out for academia" and move on.
09:29:59 <psnively> OK, so what, exactly, is the problem?
09:30:19 <dylan> I want a degree, and I also want to teach (eventually)
09:30:27 <vincenz> sebaseba: yeah, phd can lead to existential crises
09:30:32 <psnively> Oy veh is mir. dylan, with all due respect...
09:30:46 <psnively> I think you've already demonstrated that that isn't your future.
09:30:57 <dylan> Bah humbug.
09:31:07 * psnively shrugs.
09:31:08 <vincenz> dylan: teaching in school or uni?
09:31:23 <sebaseba> vincenz: many of my friends complain of the same thing. And those who have already finished say they had the crises too.
09:31:35 <vincenz> sebaseba: yah :)
09:31:39 <vincenz> sebaseba: I'm in my last year now
09:32:10 <vincenz> The "oh my god, I have accomplished nothing, but I just have to finish" stage
09:32:20 <sebaseba> vincenz: shouldn't you be writing your thesis then? :)
09:32:22 <psnively> I think, but can't prove, that a) If you want to teach, there's a subject you're passionate about, b) That passion will even show up as an undergraduate, c) It won't take seven years to get your undergraduate in that major...
09:32:26 <vincenz> sebaseba: Not quite yet, soon
09:32:40 <vincenz> sebaseba: It only takes half a year for the writing
09:32:46 <psnively> I think if you're taking seven years to get your undergraduate, the academy just isn't for you.
09:32:47 * vincenz has 6 months left, but has to finish a last journal
09:32:56 <dylan> psnively: the problem is the things I'm passionate about are far away.
09:33:01 <mrd> one of my friends is in his 9th year of u.g.
09:33:07 <vincenz> psnively: I disagree
09:33:08 <psnively> Far away in what sense?
09:33:12 <vincenz> psnively: I learned about my passions post uni
09:33:19 <vincenz> psnively: I know now I want to do a post-doc in CS
09:33:27 <dylan> psnively: far away from the sod that I actually have to study to graduate.
09:33:33 <psnively> vincenz: Yeah, that happens sometimes.
09:33:43 <psnively> dylan: Oh, you're an American, then. :-D
09:33:47 * vincenz 's background is EE
09:33:54 <dylan> psnively: Precisely.
09:34:02 <psnively> dylan: As am I. LOL
09:34:03 * vincenz thought 'sod' was a british word
09:34:16 <psnively> vincenz: As a description of a person, it is.
09:34:19 <sebaseba> The wind never blows in favor of those who don't know where they are going.
09:34:30 <vincenz> sebaseba: heh, thanks for the vote of confidence :)
09:34:30 <sebaseba> please don't shoot me
09:34:35 <dylan> I'm refering to grass, actually.
09:34:47 * vincenz knows only where he wants to go at most 1 year from now
09:34:50 <vincenz> I don't have a long term route
09:35:03 <vincenz> That's valid for most phd students I know
09:35:08 <sebaseba> and who knows?
09:35:17 <sebaseba> I think that's perfectly OK.
09:35:29 <vincenz> Then the wind does not blow in favour of anyone :)
09:35:35 <sebaseba> which contradicts which I just said, but...
09:35:48 <vincenz> Not like working friends I have "Oh yes, I'm going to do this, then 3 years from now I'll be PM, then after that I can become a partner .."
09:36:09 <vincenz> Seeing those friends brings back existential crises :)
09:36:26 <dylan> bleh, business.
09:37:26 <dylan> I'm trying to formulate why I want to teach. I've done so informally for a long time -- and I've tutored before as well.
09:37:47 <dylan> I like the spark in people's eyes when you open a door for them.
09:37:50 <mrd> ...because you like to torture students?
09:37:53 <vincenz> dylan: there's a difference between teaching at a school and at a uni
09:37:59 <psnively> I'll tell you one thing about the real world: you'll get crucified if you don't learn to focus.
09:38:05 * bos found marc andreeesen's recent blog of career advice to be good reading. you youngsters might learn something from it.
09:38:09 <dylan> vincenz: yes, I'd prefer a uni. I've never been to a "school", so I doubt I'd like that.
09:38:12 <vincenz> psnively: hence why academia is so great
09:38:19 <vincenz> dylan: school...highschool e.g.
09:38:22 <mrd> dylan: lower school?
09:38:23 <psnively> vincenz: Heh.
09:38:25 <dylan> I've never been to highschool
09:38:43 <mrd> home schooled?
09:38:46 <psnively> dylan: You've never been to any real schools? No wonder you lack direction. ;-)
09:38:59 <dylan> I went from being lectured by an engineer and english lit person to college at 16 or so. :)
09:39:11 <vincenz> dylan: homeschooling?
09:39:15 <dylan> vincenz: yes
09:39:16 <psnively> God help the child... LOL
09:39:24 <dylan> I also enjoyed  4.0 for years. :)
09:39:33 <dylan> it's a 3.9.. something now
09:39:45 <dylan> which is also depressing
09:39:46 <vincenz> dylan: you were born underground?
09:39:52 <psnively> OK, so your big challenges are learning how to choose things when you don't have effectively infinite amounts of time.
09:39:59 <vincenz> dylan: part of a timetravel experiment from the 70s and you're from a long line of underground livers?
09:40:02 <bos> dylan: don't get hung up on your GPA. as soon as you graduate, nobody will care about it.
09:40:13 <psnively> bos: What do you mean? No one cares about it now.
09:40:25 <vincenz> No one cares about it period
09:40:38 <bos> psnively: undergraduates occasionally get the notion that it means something.
09:40:47 <dylan> I did not grow up underground, I just never went to a school. :P
09:40:53 <bos> and so they get a bit worked up over its value.
09:41:00 <psnively> bos: He's a bright kid; we can disabuse him of that notion easily enough.
09:41:06 <Nafai> bos: No one cares?  For some reason my current employer wanted my transcript and based my starting salary on my GPA
09:41:25 <Nafai> bos: And I've been out of my undergrad for 3 years
09:41:31 <psnively> Nafai: Find a different employer. :-)
09:41:42 <bos> Nafai: you work for a bank or insurance company or something?
09:41:43 <vincenz> The only people that care about grades are big consulting firms like Boston&...what's the name.  The reason they care is because they know the people with high grades play by the book, and are hard workers.  Not perse because they are smart r not.
09:41:54 <psnively> ==vincena
09:41:58 <psnively> vincenz, even.
09:42:01 <bos> vincenz has hit it on the head.
09:42:03 <vincenz> psnively: what is =?
09:42:08 <psnively> The same folks who use "Be a team player" all the time.
09:42:14 <allbery_b> 'agree with'
09:42:15 <psnively> == == "I agree."
09:42:24 <vincenz> ah :)
09:42:25 <vincenz> new one
09:42:32 <allbery_b> perhaps you'd prefer a LiveJournal/Myspace-ish "IAWTC"
09:42:34 <vincenz> btw, this is really OT, let's move this to the cool channel #oasis
09:42:37 <mrd> a 4.0 says that you are really good at taking classes... which isn't what the real world is about
09:42:41 <vincenz> I've seen "+1"
09:42:51 <dylan> Ah, so having a non-perfect GPA weeds out the stupid jobs, eh?
09:42:52 * vincenz didn't have high grades
09:42:56 <psnively> Yes, the "upmodding" syntax.
09:43:09 <vincenz> That said, I never studed in college, never attended classes... and spent half the time than my peers behind the books
09:43:11 <mrd> and academia isn't about it either
09:43:18 <bos> dylan: some people thrive at consulting companies. it's a funny world we live in.
09:43:24 <Nafai> bos: Government contractor
09:43:25 <vincenz> heh, they even dropped grading phds in kuleuven
09:43:25 <b_jonas> @src (a ->) Monad
09:43:25 <lambdabot> Source not found. Where did you learn to type?
09:43:32 <bos> Nafai: i rest my case :-)
09:43:33 <vincenz> psnively `ap` #oasis
09:43:34 <b_jonas> @src ((->) a) Monad
09:43:34 <lambdabot> Source not found. You speak an infinite deal of nothing
09:43:40 <b_jonas> so how does that even work?
09:43:58 <psnively> Yeah, I've added all I have, I think.
09:44:00 <b_jonas> oh,
09:44:02 <allbery_b> @src (->) Monad
09:44:02 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:44:06 <b_jonas> @src ((->) a) >>=
09:44:06 <lambdabot> Source not found. You type like i drive.
09:44:06 <allbery_b> @src (->) join
09:44:07 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:44:12 <b_jonas> @src ((->) a) return
09:44:12 <lambdabot> Source not found. Do you think like you type?
09:44:13 <allbery_b> @src (->) (>>=)
09:44:13 <lambdabot> f >>= k = \ r -> k (f r) r
09:44:18 <vincenz> psnively: it's a cool channel anyways, it's PL-agnostic
09:44:20 <allbery_b> lots of stuff not in there
09:44:24 <b_jonas> @src ((->) a) (>>=)
09:44:24 <lambdabot> Source not found. You speak an infinite deal of nothing
09:44:36 <allbery_b> btu one key is that the class can't be multiple words, even parenthesized
09:44:44 <allbery_b> so (-> r) must be spelled (->)
09:44:50 <b_jonas> now that's wierd
09:45:02 <b_jonas> monads are * -> *
09:45:03 <allbery_b> no, it's just simpleminded parsing
09:45:10 <b_jonas> @src (->) return
09:45:10 <lambdabot> return = const
09:45:29 <mrd> (-> r) would be flip (->) r
09:45:54 <b_jonas> mrd: but (r ->) is the instance of Monad
09:45:57 <b_jonas> not (-> r)
09:45:59 <mrd> right
09:46:12 <mrd> so ((->) r) is the instance of Monad
09:46:27 <b_jonas> not that the lambdabot output would tell that clearly...
09:46:27 <mrd> at one point i wanted to use sections with ->, but, eh
09:46:42 <vincenz> unsafeForceAp psnively #oasis
09:46:56 <psnively> LOL
09:47:06 <mrd> isn't OASIS the XML organization?
09:47:35 <vincenz> Completely unrelated
09:49:57 <phobes> quicksilver:  You get your perlin noise question answered?
09:50:23 <b_jonas> perl line noise?
09:50:58 <phobes> Someone already made that pun :)
09:51:04 <vincenz> It's still funny :)
09:51:10 <b_jonas> oh sorry, I didn't read the archives
09:51:16 <mrd> i still think perlin noise is perl line noise
09:51:16 <b_jonas> I like perl line noise you know
09:51:28 <mrd> is there a real definition?
09:52:32 <phobes> Perlin noise?
09:52:50 <phobes> @go Perlin noise
09:52:52 <lambdabot> http://freespace.virgin.net/hugo.elias/models/m_perlin.htm
09:52:53 <lambdabot> Title: Perlin Noise
09:53:02 <vincenz> Pink noise is spiffy :)
09:53:53 <phobes> Perlin noise is a cheaply computable "noise" function where you kind of pick a frequency distribution
09:54:10 <b_jonas> hmm
09:54:22 <phobes> I think it's used alot to make things look random when mathematical randomness is not important
09:54:59 <mrd> ah summation
09:55:23 <b_jonas> how's that better than just a wiener-noise by scan summing a sequence of random 1s and -1s?
09:55:56 <phobes> Well, my comment about true randomness not being important was probably misleading... you want particular properties in your "random" function
09:56:01 <Olathe> How's that better than 80s music ?
09:56:11 <iguana_> is there any general advice on optimizing performance?
09:56:18 <b_jonas> Olathe++
09:56:20 <vincenz> question
09:56:24 <vincenz> regarding that article...
09:56:30 <vincenz> why does the random number generator have to be stateless?
09:56:35 <vincenz> (or pure)
09:56:40 <kscaldef> iguana_: profile, profile, profile
09:56:43 <phobes> The article google turned up?
09:56:52 <vincenz> A noise function is essentially a seeded random number generator. It takes an integer as a parameter, and returns a random number based on that parameter. If you pass it the same parameter twice, it produces the same number twice. It is very important that it behaves in this way, otherwise the Perlin function will simply produce nonsense.
09:56:54 <mrd> iguana_: profile.  and make your code stricter.  or lazier.
09:57:22 <vincenz> He doesn't rely on this in the rest of the article
09:57:27 <phobes> vincenz:  So that you get a proper function out of it
09:57:39 <phobes> The way it's often used, it's important that it's deterministic
09:57:54 <vincenz> phobes: why would the perlin function produce nonsense?
09:58:23 <phobes> I'm not familiar with the article ... I'm just saying that's why you want deterministic randomness
09:58:45 <vincenz> right, but that doesn't seem crucial to getting perlin noise
09:58:57 <phobes> I agree
09:59:26 <vincenz> That statement, hence, confused me :)
10:01:58 <phobes> vincenz:  No, sorry, he's right
10:02:22 <vincenz> phobes: how so?
10:02:32 <phobes> You're going to get a function f(x) that returns the random "Perlin noise" value at x
10:03:08 <phobes> If you don't compute the same random values each time, then you lose
10:03:18 <phobes> The same random weights I mean
10:03:27 <vincenz> oh, as actual implementation
10:03:36 <phobes> In that case you're going to get white noise or something out
10:03:38 <vincenz> right, but that's more due to premature optimization :)
10:03:43 <phobes> Howso?
10:03:57 <vincenz> instead of returning a perlin-noise field, you return a function that computes perlin noise at a point
10:04:27 <phobes> Yes, in haskell you could return a Perlin noise function that closed on the chosen random numbers
10:04:52 <phobes> Or you could regenerate them each time
10:04:56 * vincenz nods
10:05:10 <vincenz> but in terms of from one perlin noise to the next
10:05:15 <vincenz> or even from one octave to the next
10:05:22 <vincenz> you don't need purity in the RNG
10:05:22 <phobes> ya
10:05:25 <vincenz> on the contrary
10:05:29 * esap doesn't even know what is a Perlin noise function.
10:05:40 <phobes> See the article link above esap
10:06:19 <vincenz> dpiponi: hey, question about your latest blog.  Is the way the blog is written the way you thought about it, or do you tend to write them the opposite way of how you discovered them? (Namely, after doing it all, seeing the coin game and inventing that for the intro paragraph)
10:06:27 <vincenz> s/blog/blogpost
10:06:54 <phobes> link?
10:07:11 <vincenz> http://sigfpe.blogspot.com/2007/09/arboreal-isomorphisms-from-nuclear.html
10:07:14 <lambdabot> Title: A Neighborhood of Infinity: Arboreal Isomorphisms from Nuclear Pennies, http://tinyurl.com/3d4lf9
10:07:23 <phobes> oh ya I saw that linked earlier
10:07:56 <phobes> dpiponi = sigfpe?
10:08:08 <vincenz> yah
10:10:33 <infrared> i got lambdabot running but i can't evaluate expressions
10:10:36 <infrared> i get "Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString"
10:14:20 <Cale> infrared: make sure that runplugs is installed
10:14:36 <Cale> or built... I'm not the best person to ask :)
10:15:01 <infrared> Cale: it is, I run lambdabot from the build directory for now
10:15:14 <Cale> hmm
10:15:29 <Cale> dons awake?
10:16:25 <vincenz> @seen dons
10:16:25 <lambdabot> dons is in #haskell-hac07, #xmonad and #haskell. I last heard dons speak 5h 50m 38s ago.
10:18:41 <infrared> i'll ask later then :-)
10:29:29 <pixl> is there a nicer way to define bit flags then this: flag1=1; flag2=2; flag3=4; data Struct = Struct { struct_flags :: Int }
10:29:50 <pixl> is it possible to maybe define them inside the Struct?
10:32:19 <sjanssen> data Struct = Struct { flag1, flag2, flag3 :: Bool }?
10:33:10 <pixl> nah.. they should be assigned to different bits in an int
10:33:29 <pixl> wouldnt the above just set all flags to be a single bit?
10:33:48 <esap> There is Data.Bits
10:33:55 <pixl> I just don't want to define them globaly
10:34:41 <pixl> yeah I know, but I want them to be speciffic to the "Struct" only so when I use them later I would have to write simething like Struct.flag1 to access them
10:36:13 * roconnor got a copy of Geometric Algebra for Computer Scence from the library
10:37:25 <vincenz> roconnor: taking it to Hac?
10:37:46 <roconnor> yep, reading material for the train
10:38:04 * vincenz hopes he can take a look then :)
10:38:08 <roconnor> maybe I should write a geometric algebra library for the hackathon
10:38:25 <roconnor> Libraries are even better as a PhD student
10:38:32 <roconnor> you can get them to buy books for you
10:38:45 * vincenz is a book-aholic and he tends to buy books
10:41:22 <tibbe> @src Network.Socket
10:41:22 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:41:34 <tibbe> @source Network.Socket
10:41:34 <lambdabot> http://darcs.haskell.org/packages/network/Network/Socket.hs
10:41:48 <tibbe> what exactly is the difference between @src and @source?
10:42:01 <dylan> @src map
10:42:01 <lambdabot> map _ []     = []
10:42:01 <lambdabot> map f (x:xs) = f x : map f xs
10:42:13 <b_jonas> @source map
10:42:13 <lambdabot> map not available
10:42:33 <int-e> src  shows source code snippets; source gives URLs to module sources.
10:42:40 <b_jonas> dunno,
10:42:47 <b_jonas> lambdabot, help
10:43:14 <int-e> @index map
10:43:14 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
10:43:20 <int-e> @source Data.List
10:43:20 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
10:45:06 <ddarius> roconnor: I'd be interested in knowing what you thought about that when you finish.
10:47:20 <tibbe> ah
10:55:24 <iguana_> is there a guide to GHC profiling?
10:57:08 <elliottt> iguana_: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
10:57:11 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/kwh6c
10:57:26 <iguana_> thank
10:57:27 <iguana_> s
10:57:35 <elliottt> no problem :)
11:02:24 <iguana_> why does ghc with the -prof option complain about a missing Control.Monad.State?
11:02:55 <sjanssen> iguana_: your libraries weren't installed with profiling support
11:03:22 <kscaldef> it would be so nice if profiling didn't require recompiling the world
11:03:38 <iguana_> so I need to recompile GHC?
11:03:51 <iguana_> not nice...
11:03:56 <sjanssen> iguana_: you built it yourself?
11:04:02 <iguana_> I let gentoo build it
11:04:37 <Cale> iguana_: I think there are binaries, even in gentoo
11:04:46 <sjanssen> iguana_: just 'USE=prof emerge mtl'
11:04:58 <iguana_> ah
11:05:03 <iguana_> thanks, I'll try
11:05:28 <dpiponi> vincenz - I wrote that blog completely backwards, as you've spotted :-)
11:05:37 <tibbe> how do I compile a .hsc file
11:05:39 <vincenz> dpiponi: whew :)
11:05:39 <tibbe> ?
11:05:48 <sjanssen> tibbe: hsc2hs
11:05:48 <vincenz> dpiponi: otherwise you were quite the idiot savant :)
11:06:00 <sjanssen> tibbe: though you should probably just use Cabal
11:06:18 <tibbe> sjanssen: it's Network.Socket
11:06:30 <dpiponi> vincenz: But you have to admit it makes more sense to lead in with a simple game.
11:06:30 <Cale> dpiponi: http://cale.yi.org/autoshare/pennies.png -- my solution to the pennies problem
11:06:35 <sjanssen> tibbe:
11:06:41 <sjanssen> tibbe: that uses Cabal, right?
11:06:45 <vincenz> dpiponi: it was a nice read :) Most likely because it took this road which really was like alice in wonderland
11:06:48 <tibbe> sjanssen: I'll look
11:07:05 <Cale> It's minimal and has a nice symmetry to it :)
11:07:08 <sjanssen> tibbe: I'm curious why you're building Network.Socket by itself
11:07:09 <vincenz> Cale: how'd you draw that?
11:07:09 <dpiponi> Cale: nice! I just drew a really crappy version of that diagram myself.
11:07:20 <Cale> vincenz: inkscape as usual :)
11:07:23 <vincenz> oh right
11:07:27 <sjanssen> tibbe: shouldn't you just build and install the whole package?
11:07:36 <tibbe> sjanssen: well, I'm going to port it to strict bytestrings
11:07:43 <tibbe> sjanssen: for hackathon
11:07:48 <vincenz> inkscape always gives me fancy shaded squares and circles when all I want is more plain ones, and not flashy ones that look like they came from the hot 90s
11:07:53 <sjanssen> tibbe: oh, neat
11:08:07 <tibbe> sjanssen: now I'm hunting for the darcs repo, the ghc repo refuses to "get" for me, think it's a mac osx issue
11:08:11 <dpiponi> Cale: Hey! You only have 18 steps. Something weird's going on.
11:08:16 <sjanssen> tibbe: I'd just steal Network.Socket's .cabal file then :)
11:08:26 <Cale> vincenz: hit the button with the paintbrush and black and white square
11:08:34 <dpiponi> Cale: Oh, you have a better solution! :-)
11:08:48 <tibbe> sjanssen: yup :)
11:08:52 <bos> tibbe: have you looked at the network-alt package?
11:08:58 <tibbe> sjanssen: I fear everything is in the ghc repo though
11:09:07 <Cale> dpiponi: yeah I came up with it by hand and then Pseudonym (I think) proved it's minimal by exhaustive search
11:09:18 <sjanssen> tibbe: IIRC, you can only get a partial GHC repository when using a case-insensitive filesystem
11:09:40 <sjanssen> tibbe: nope, it's all nicely chopped up.  darcs get http://darcs.haskell.org/packages/network IIRC
11:09:41 <lambdabot> Title: Index of /packages/network
11:10:03 <dpiponi> Cale: Do you think the type system could do the search (a la that recent TMR article)? Then you could just get the inferencer to figure out how to map T^7 to T.
11:10:20 <Cale> That would certainly be interesting :)
11:11:07 <tibbe> sjanssen: I tried the partial thing too but it failed, also if I want to submit ghc patches I'm supposed to go with a complete repo right because of darcs bugs?
11:11:25 <bos> tibbe: please look at network-alt before you launch into a port
11:11:26 <sjanssen> tibbe: recommended but not required, I think
11:11:35 <tibbe> sjanssen: ok
11:11:39 <bos> tibbe: you don't need a ghc tree to build network by itself
11:11:46 <tibbe> bos: ok, do you have an executive summary? :)
11:12:00 <Cale> The strategy I used to come up with that one was to repeatedly try to reduce the highest occurring degree in as few steps as possible.
11:12:07 <tibbe> bos: no true, thought I might need HEAD for testing though, just to make sure it'll work with the next ghc
11:12:11 <bos> tibbe: it's a nice refactoring of the network api, and it uses Ptr instead of specific types
11:12:28 <bos> so you can use it as a base for String, ByteString, or whatever else
11:13:00 <tibbe> bos: oh cool
11:13:12 <dpiponi> Cale: I've been wondering if there some kind of ordering on the set of positions so that it became obvious what move to take next because you take the one that reduces the position in the ordering. But that might be wishful thinking.
11:13:29 <tibbe> bos: network-alt is not on hackage
11:13:30 <bos> tibbe: that would be a more profitable direction to take than just splatting ByteString in there
11:14:08 <tibbe> bos: as long as it's /simple/
11:14:12 <bos> tibbe: http://www.cs.helsinki.fi/u/ekarttun/network-alt
11:14:15 <lambdabot> Title: network-alt
11:14:24 <bos> tibbe: it's no harder than using ByteString directly
11:16:05 <tibbe> I want a posix interface though, I want it really efficient and low level
11:16:14 <tibbe> others can build things on top if they like
11:16:21 <dpiponi> vincenz: I also used Inkscape BTW
11:16:34 * vincenz tends to use oodraw 
11:17:01 <Cale> dpiponi: I only noticed afterward that the steps 0 to 9 are symmetric in a nice way with the steps from 9 to 18,
11:17:27 <vincenz> yep :)
11:17:43 <vincenz> your diagram is rotationally symmetric
11:17:54 <Cale> yeah
11:19:19 <misterbeebee_>  I'm confused about the conclusions of the pennies article...
11:19:31 <jfredett> I was too
11:19:40 <jfredett> I usually am, when I read NoI...
11:19:46 <dpiponi> What was the confusion about?
11:19:55 <misterbeebee_> It talks about an isomorphism.... trees are not isomorphic to 2-tuples, because you can embed 2-tuples in trees, but you don't
11:20:05 <misterbeebee_> "need" the single-leaf tree,
11:20:10 <vincenz> dpiponi: I do have a question tho.  What's the utility of this?  This tree has no data inside of it!.
11:20:18 <Cale> misterbeebee_: it's not a bijection, in other words
11:20:21 <misterbeebee_> so in a sense the space of trees is wastefully large
11:20:29 <vincenz> I mean data T = 1 + T^2...  you usually want   T = 1 + a*T^2
11:20:35 <tibbe> bos: I will definatly look at network-alt but I want to keep this library dependency free so I will probably not end up using it directly
11:20:45 <misterbeebee_> I get that. So the real prize is in understanding how to biject 7-tuple wth trees.
11:20:48 <jfredett> I thought that the idea was that if you have a board "position" f(x) and a desired goal "position" g(x)
11:21:05 <Cale> vincenz: Moving the data about in a canonical way is easy.
11:21:06 <misterbeebee_> Is there a diagram of that somewhere? should it be inferable form thr 1-step pennies diagram?
11:21:07 <jfredett> where g and f are polynomials with 0 or 1 as coefficients
11:21:07 <bos> tibbe: that's fine, i'm not suggesting you use it, just that you take some ideas from it so you don't end up painting yourself into a corner
11:21:24 <jfredett> then g is only reachable iff g == f
11:21:24 <tibbe> bos: absolutely
11:21:33 <bos> tibbe: for example, exposing a low-level binding via Ptr is spot on because of the flexibility it gives
11:21:35 <misterbeebee_> er, 18-step pennies diagram
11:21:36 <dpiponi> vincenz: The original paper is an attempt to make sense of the idea that the set of trees can be thought of, in a weird way, as having a complex number of elements...
11:21:39 <jfredett> since fission and fusion don't change the polynomials
11:21:45 <jfredett> but I'm pretty sure thats wrong.
11:22:02 <dpiponi> vincenz: ...and the idea of that branch of research is to see how much reasoning about these kinds of objects can be done in this way.
11:22:22 <tibbe> bos: btw, you don't know of any pappers on haskell networking, etc. it's a long shot but if there's any work already done it would be a shame to not study it before.
11:22:23 <dpiponi> vincenz: So in a sense the tree example is just a baby step in attempting to solve something more general.
11:22:26 * vincenz nosd
11:24:42 <bos> tibbe: no, the networking layer is pretty simple and kind of boring; it's just a slapdash adaptation of berkeley sockets.
11:25:02 <bos> i.e. not the kind of thing that gets published.
11:25:31 <tibbe> bos: right
11:25:42 <tibbe> bos: I just want to get it right once so I can then forget it :)
11:26:02 <tibbe> bos: and get on with the project I really want to work on
11:26:12 <dpiponi> misterbeebee_: Did Cale answer your question?
11:26:19 <bos> tibbe: what's that project?
11:26:44 <Cale> misterbeebee_: http://cale.yi.org/autoshare/pennies.png
11:26:52 <misterbeebee_> dpiponi: not completely...   I get that a "1" tree is Leaf, and a T^2 tree is  (Fork T T ).. what's a T^4 tree? Fork (Fork T T) (Fork TT)?  What's a T^5 Tree? (Fork Leaf (Fork (Fork T T) (Fork T T)))
11:26:57 <Cale> misterbeebee_: (I posted it at the start of this conversation)
11:26:58 <tibbe> bos: web application interface ala WSGI, some http work, distributed Map, all kinds of goodies that requires fast networking
11:26:59 <misterbeebee_> Yah, I'm looking at Cale's picture
11:27:29 <bos> tibbe: you know you can get a certain amount of what you want using a socket as a handle, right?
11:28:03 <dpiponi> misterbeebee_: T^n is just shorthand for an n-tuple of trees: (T,T,...,T).
11:28:07 <tibbe> bos: kinda but I reach the limit already in my current implementation. I want to use recv and the rest and they return String
11:28:16 <bos> tibbe: ok, just checking
11:28:40 <misterbeebee_> diponi: but to biject those 7 trees with one tree, there's a certain tree structur to map them too, right?
11:28:49 <tibbe> bos: sure :) and Network.Socket is not documented so I thought I do the ByteString work, document, write a few tutorial (echo server, etc) while I'm at it
11:28:50 <misterbeebee_> Like    {[(L T)(TT)]  [(TT)(TT)]}  ?
11:29:01 <bos> tibbe: and you know that the low-level recvBufFrom will often do what you want, right?>
11:29:01 <misterbeebee_> (using various bracked for the forks)
11:29:06 <misterbeebee_> (er, brackets
11:29:17 <misterbeebee_> or is that not the point at all?
11:29:25 <bos> tibbe: i.e. combine BS.createAndTrim' with recvBufFrom and you can recv a strict ByteString quite nicely
11:29:52 <dpiponi> misterbeebee_: There's no extra structure in the tuples. The tuples are just tuples.
11:29:53 <tibbe> bos: yes
11:30:09 <tibbe> bos: I could work around it but I want to fix it
11:30:10 <bos> tibbe: ok, just making sure
11:30:14 <tibbe> sure, thanks
11:30:15 <misterbeebee_> then what does it mean to say that trees are in bijection with 7-tuples? (confused emoticon)
11:30:54 <bos> tibbe: i say all this because it would be nice to see that stuff fixed, but the barrier to creating changes that other people will use is fairly high.
11:30:58 <dpiponi> misterbeebee_: It means there's a (total) function f:(T,T,T,T,T,T,T) -> T and an inverse f', such that f . f' = id and f' . f = id
11:31:13 <tibbe> bos: right
11:31:28 <misterbeebee_> dpiponi: I get that... is this an existence proof with no (human-followable) construction?
11:31:42 <tibbe> bos: I hope I could solve that with plenty of documentation, tutorials etc
11:31:53 <misterbeebee_> in otherwords, am i expeted to be able to figure out the specific values f(a), f(b) ?
11:31:54 <tibbe> bos: it's my own itch as well
11:31:58 <dpiponi> misterbeebee_: The code is the construction and I QUickCheck it
11:32:01 <tibbe> bos: so it won't be a total waste
11:32:05 <bos> tibbe: alas, no. almost nobody has read the network code much. i'm a rare exception :-)
11:32:42 <misterbeebee_> dpipona: Yah.. I glazed over the code. I believe that the code works... but ....
11:32:52 <byorgey> jfredett: fission and fusion do change the polynomials; it's just that if you want them not to change the value, you have to evaluate them at a value of x for which x^2 + 1 = x
11:33:04 <byorgey> which happens to be a sixth root of 1.
11:33:06 <dpiponi> misterbeebee_: You can just type iso (Leaf,Fork Leaf Leaf,Leaf,...) to pack 7 trees into one. Except that I use a slightly modified way to represent tuples.
11:33:26 <tibbe> bos: so you wrote network-alt?
11:33:35 <dpiponi> misterbeebee_: So you have to write iso (Leaf,(Fork Leaf Leaf,(Leaf,...)))
11:33:48 <Cale> dpiponi: have you ever seen "Combinatorial Enumeration" by Jackson and Goulden?
11:34:12 <bos> tibbe: no, that was einar karttunen
11:34:13 <glen_quagmire> is there typedef like thingy in haskell? so that I can use that type and change the type into Double or Float only once
11:34:19 <misterbeebee_> dpiponi: ok lemme go copy the codce into my ghc, brb
11:34:23 <bos> glen_quagmire: "type"
11:34:48 <byorgey> dpiponi: great article. =)  I had read (the first half of) the Blass paper before, so it was fun thinking about again it from a slightly different angle
11:34:49 <dpiponi> misterbeebee_: It's hard to visualise but it's like a weird jigsaw puzzle in that 7 trees nest together perfectly. This is unusual, you can't next 12 trees together say. So there's something deeper going on.
11:35:16 <bos> glen_quagmire: type ZaphodBeeblebrox = Int
11:35:24 <byorgey> dpiponi: in fact, you've inspired me to write about it on my math blog for high school students
11:35:46 <dpiponi> byorgey: I hope just the game bit and not the tree isomorphisms! :-)
11:35:51 <glen_quagmire> i see. how do you make sure there's no name conflict?
11:35:52 <misterbeebee_> dpipni: The math I follow... it's a case of "all the steps make sense, but I don't have the intuition of what I just read", or I'm looking for the wrong bit of intuition... gimme a sec
11:35:53 <glen_quagmire> :t FP
11:35:55 <lambdabot> Not in scope: data constructor `FP'
11:35:59 <byorgey> dpiponi: right. =)
11:36:18 <byorgey> dpiponi: I plan to present the penny game first, and then show how to analyze it using polynomials etc.
11:37:21 <dpiponi> byorgey: Hmmm...it gives a nice way for high school students to see that complex numbers have surprising applications.
11:37:49 <byorgey> dpiponi: indeed, it does.  I wish I had known about it when I was actually teaching high school math!
11:38:57 <tibbe> bos: just thought that it was you (you're nick doesn't give away your real name) since you were familiar with the network internals
11:39:24 <dpiponi> misterbeebee_: I spent the drive to work thinking about whether or not there's a way to draw exactly how the puzzle pieces fit together but I decided that it needed too much paper and way more colours than I have coloured pens!
11:40:03 <byorgey> on an unrelated subject, does anyone know if there's a way to define an (..) operator, or is it special inviolable syntax?
11:40:32 <therp> (..) ?
11:40:35 <therp> [1..] ?
11:40:35 <iceeey> hi
11:40:47 <EvilTerran> it's reserved by [1..] etc
11:40:57 <EvilTerran> @hoogle enumFrom
11:40:58 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
11:40:58 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
11:40:58 <lambdabot> Prelude.enumFromThenTo :: Enum a => a -> a -> a -> [a]
11:41:00 <therp> ah ok so literally '(..)'
11:41:09 <EvilTerran> you can redefine those, though, for your own types
11:41:16 <byorgey> EvilTerran: and there's no way to say "I don't want to be able to write [1..], I just want to define an (..) operator?
11:41:26 <EvilTerran> not AFAIK
11:41:41 <byorgey> I didn't think so (I've tried) but just thought I would ask =)
11:41:49 <dmwit> > let (..) = const in 3 .. 5
11:41:50 <lambdabot>  Parse error
11:41:55 <EvilTerran> reservedop 	 -> 	 .. | : | :: | = | \ | | | <- | -> | @ | ~ | =>
11:42:01 <byorgey> ah
11:42:58 <iguana_> profiling tells me that a significant amount of time is spent in my "~>>" operator
11:43:03 <tibbe> bos: from a quick browse it looks like it's partly implemented in C, is that the case?
11:43:05 <iguana_> which is defined as
11:43:12 <iguana_> x ~>> y = do { rx <- x; y; return rx }
11:43:17 <iguana_> how can that be?
11:43:24 <misterbeebee_> dpipona: got it linked with an example... it's hard to write tuples in your syntax :)
11:44:00 <misterbeebee_> dpiponi:
11:44:00 <misterbeebee_> >     print $ iso (Leaf , (Leaf , (Leaf , (Leaf , (Leaf , (Leaf , (Leaf, () )))))))
11:44:01 <lambdabot>   Not in scope: data constructor `Leaf'
11:44:07 <misterbeebee_> dpiponi: (Leaf, () )
11:44:17 <misterbeebee_> dpiponi: I am confused
11:44:30 <misterbeebee_> didn't take long :)
11:44:40 <dpiponi> misterbeebee_: What's wrong with (LEaf,())
11:44:58 <byorgey> misterbeebee_: now try running iso' on (Leaf, ())
11:45:38 <dpiponi> You should get 7 leaves. Let me check.
11:45:40 <misterbeebee_>  (Leaf , (Leaf , (Leaf , (Leaf , (Leaf , (Leaf , (Leaf, () ))))))), of course
11:46:01 <misterbeebee_> why am i confused? It's an isomorphism, alright, but....
11:46:15 <misterbeebee_> oh!
11:46:34 <misterbeebee_> for this to works, the leaves must carry no data.
11:46:48 <misterbeebee_> you aren't isomorphing the data cells, just the structure
11:46:52 <misterbeebee_> ?
11:46:52 <misterbeebee_> !
11:46:57 <b_jonas> there's a variant of delete that uses your equalty function: deleteBy
11:47:07 <b_jonas> I was searching for that yesterday
11:47:10 <b_jonas> and didn't find
11:47:15 <dpiponi> misterbeebee_: Yes. These are just binary tree structures.
11:47:18 <misterbeebee_> ohhhhhhhhhh
11:47:21 <misterbeebee_> now i get it :)
11:47:26 <dpiponi> misterbeebee_: :-)
11:48:27 <bos> tibbe: which "it"? network?
11:48:35 <misterbeebee_> dpiponi: funny, as I was walking the dog, I was wondering if there are names for the distinction between    data T a = Leaf a | Fork (T a) (T a)  ,  and data T' a = Leaf a | (Node a) (T a) (T a),
11:48:40 <tibbe> bos: network-alt
11:48:41 <misterbeebee_> (if anyone knows, please share),
11:48:48 <bos> ah, don't remember
11:48:49 <misterbeebee_> and then you come along with data T = Leaf | Fork T T
11:48:57 <misterbeebee_> grr, argh, ahhh
11:49:22 <dpiponi> misterbeebee_: Yes, a naming convention for these trees would be good.
11:49:57 <dmwit> misterbeebee_: dpiponi's tree is just like using your (data T a), but setting a = ().
11:50:15 <iguana_> I get the impression that string operations are really costly
11:50:20 <iguana_> any tips on speeding that up?
11:50:29 <dmwit> Only for really big strings.
11:50:35 <dmwit> Then you want to use Data.ByteString
11:50:50 <misterbeebee_> dmwit: yet, with the important note that     () is isomporphic to    () (), a fact which is unique to unit and critical to dpiponi's analysis.
11:50:53 <byorgey> misterbeebee_: maybe we could call your (data T a) a "leaf-labeled binary tree"
11:50:59 <misterbeebee_> funny how all the details matter :)
11:51:10 <byorgey> and (data T' a) just a "labeled binary tree"
11:51:24 <dmwit> misterbeebee_: () () doesn't make sense.
11:51:36 <misterbeebee_> I mean  Blah () ()
11:51:41 <misterbeebee_> that makes sense, eight?
11:51:44 <misterbeebee_> right?
11:51:46 <vincenz> hmm, no it's not
11:51:47 <dmwit> sure
11:52:11 <vincenz> () has two values: _|_ and ()
11:52:11 <dpiponi> misterbeebee_: There is an isomorphism ((),()) -> (), yes.
11:52:32 <vincenz> Blah () () has 4 values:  _|_ Blah _|_ _|_ Blah _|_ () Blah () _|_ and Blah () ()
11:52:35 <dpiponi> vincenz: Total functions
11:52:35 <vincenz> I guess that's 5
11:52:37 <vincenz> h
11:52:39 <vincenz> s/h/ah
11:52:41 <misterbeebee_> point is,   dpiponi's blog post works with  ( T ()), but not (T Int), so all my confusion around by intuition of (T Int) was pointless.
11:52:57 <misterbeebee_> vincenz: oh I wasn't thinking about bottom
11:53:12 <vincenz> misterbeebee_: right, that was my earlier question.  He works with empty trees, how could this ever work with trees that have data
11:53:42 <misterbeebee_> re _|_, that's, ok, right? when we think about theorems, we presume that bottom doesn't happen, unless where reasoning about algorithm termination.
11:53:49 <misterbeebee_> vincenz: yeah, I finally caught up to you?
11:53:55 <vincenz> misterbeebee_: erm,
11:54:22 <misterbeebee_> vincenz: or, i'm wrong :)
11:55:49 <dpiponi> misterbeebee_: Basically yes. If you know that all of your functions are going to terminate then you can reason differently to when there's some doubt. (In effect you can switch to a different category.)
11:56:26 <misterbeebee_> vincenz: dpiponi's analysis absolutely can't work on trees with data and nothing quite similar to it could. Maybe that should have been a dislcaimer posted at the top. It's an analysis of the algebraic structure of the "skeletons", not of what is usually considered a tree in a program.
11:56:48 <vincenz> misterbeebee_: ok, thanks, now I have  definite answer on that :)
11:57:12 <misterbeebee_> this is why i want different names for different kinds of trees!
11:57:22 <dpiponi> The tree is the data!
11:57:54 <misterbeebee_> because you were doing math, not programming! :-) but you were doing math in a program! argh, haskell! :)
11:57:58 <vincenz> dpiponi: what sort of data?
11:58:03 <vincenz> dpiponi: why not use sets then?
11:58:13 <dpiponi> vincenz: trees of course :-)
11:58:17 <vincenz> heh
11:58:30 <vincenz> seriously, what's a binary tree with no data represent except itself?
11:58:43 <b_jonas> in haskell, if a function definition or lambda contains a subexpression that doesn't depend on the arguments of that function, is that computed only once in the context that function is created or every time I call that function?
11:59:20 <byorgey> a set of binary numbers, none of which is a prefix of another?
11:59:25 <vincenz> b_jonas: you're asking if haskell has partial evaluation?
11:59:36 <vincenz> b_jonas: why not lift it?
11:59:42 <dpiponi> vincenz: http://mathworld.wolfram.com/BinaryTree.html
11:59:43 <lambdabot> Title: Binary Tree -- from Wolfram MathWorld
11:59:54 <misterbeebee_> i think b_jonas is asking about efficiency?
12:00:04 <dpiponi> vincenz: It's a thing in its own right.
12:00:19 <vincenz> dpiponi: oh, I guess I'm not mathematician enough to see the use of that page :)
12:01:00 <kaol> I'm about to set up a daemon, that's written in Haskell, on a server. eep.
12:01:01 <b_jonas> vincenz: not exactly partial evaluation, rather like carrying out expression before a loop, but easier becaue it's pure and lazy
12:01:06 <misterbeebee_> b_jonas, i imagine the answer is compiler-dependent,... in ghc, I think ghc is smart enough to compute top-level functions only once, but no guarantees about subexpressions.
12:01:16 <xerox> b_jonas: no it isn't, there's no automatic CSE (common subexpression elimination)
12:01:23 <dpiponi> vincenz: I wear two hats. I write useful code all day at work, but I like to write useless code at the weekend :-)
12:01:30 <b_jonas> xerox: it's not cse I think
12:01:30 <int-e> b_jonas: the compiler may float out the term to the top level which will have the effect of evaluating it only once.
12:01:33 <misterbeebee_> I used to think that ghc automagically memoized every computation, but my swap-space soon told me I was wrong :)
12:02:09 <b_jonas> cse is like turnign '(g f x, h f x)' to 'let y = f x in (g y, h y)'
12:02:14 <b_jonas> while what I'm asking for is rather
12:02:15 <xerox> b_jonas: I mean something like "x^2 + x^2" computes the square twice, whereas "let y = x^2 in y + y" doesn't
12:02:17 <insanekane> whats the difference between "type-classes" and regular classes ?
12:02:34 <therp> dpiponi: useless code++, non-terminating programs need friends too! :)
12:02:43 <vincenz> dpiponi: I see :) Well you write about it very entertainingly :)
12:02:43 <xerox> insanekane: type classes are just sets of types. Constraints represent set membership. E.g "Num a" means "a is in the set Num".
12:02:56 <insanekane> xerox: ah i get it
12:03:09 <insanekane> sort of like "all fruits that are red"
12:03:10 <b_jonas> turning 'let f x = g y x in ...' to 'let h = g y; f x = h x in ...'
12:03:21 <b_jonas> because g y doesn't depend on x
12:03:31 <misterbeebee_> insanekane? What do you mean by "regular classes"? In haskell, or in another language?
12:03:40 <insanekane> misterbeebee_: in general OO terms
12:03:43 <xerox> insanekane: yeah, you'd do "Fruit t, Red t => ... t ..."
12:04:00 <insanekane> xerox: i get it ... theres something similiar in OWL ... very elegant
12:04:10 <xerox> insanekane: agreed :)
12:04:14 <misterbeebee_> i might get smacked around for this, but coming from OO, a "typeclass" is quite close to a "interface + mixin"
12:04:24 <int-e> insanekane: they're different. type classes are closer to interfaces.
12:04:28 <insanekane> misterbeebee_: whatever
12:04:30 <Baughn> insanekane: It's mostly about protocols
12:04:45 <insanekane> i think, xerox explained it succintly ... its good
12:04:47 <MyCatVer1s> insanekane: "general OO terms" is a wide mark. Java/C++-like, or ObjC or Smalltalk-ey, or what?
12:04:50 <dpiponi> vincenz: Thank you. BTW The tree example might not have an immediate use but the various bit of theory behind them are well used.
12:04:55 <xerox> insanekane: implementatively you might think of them as a dictionary, and the compiler changes "Num t => t -> t -> t" to "Num t -> t -> t -> t" where the first new argument is a dictionary of functions of "Num" for the type t.
12:04:56 <insanekane> MyCatVer1s: it isnt
12:05:27 <xerox> insanekane: bear in mind that the second isn't actual syntax, just a vague idea of how the compiler implements it.
12:06:26 <insanekane> xerox: i dont know much about haskell (in fact I dont know it at all), but I think i see what you mean ... ive seen that when reading a tutorial on functional languages
12:06:40 <insanekane> thats x -> x -> x -> .... currying i guess
12:06:57 <esap> a constraint, e.g. (Num a) =>, is what C++ people call "virtual function table pointer"
12:07:02 <xerox> Currying is going from (a,b) -> c to a -> (b -> c).
12:07:22 <misterbeebee_> there are two things you can do in a typeclass declaration: give method names and signatures--- all "instances of the class" (which are not OO objects!) must implement those functions (=="interface" or "protocol"), and give "default implementations" that depend on the other functions of the typeclass or other imported modules. (which are like "mixins")
12:07:28 <insanekane> xerox: ok nevermind :) ... today is just not my day to learn haskell :)
12:07:46 <xerox> insanekane: okay, have fun :)
12:07:55 <insanekane> thanks misterbeebee_
12:08:03 <insanekane> and thanks xerox
12:08:08 <misterbeebee_> insanekane: you'll have to start by forgetting all the OO vocab words.. many of them are used with different defintions in haskell
12:08:19 <misterbeebee_> i hope we didn't scare insanekane away...
12:08:54 <b_jonas> so what about that latter kind of optimization?
12:08:58 <Zevv> I have a type Ntree defined as '
12:09:02 <Zevv> oops
12:09:03 <Zevv> sorry
12:09:07 <Zevv> let me restate that
12:09:13 <oerjan> Zevv: concise indeed
12:09:22 <Zevv> defined as 'data Ntree a = Ntree a [Ntree a]'
12:09:31 <Zevv> now, this is my 2nd day of haskell
12:09:32 <sjanssen> @src Tree
12:09:32 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:09:40 <Zevv> I want to write a function 'dumpNtree :: Ntree -> IO ()
12:09:53 <misterbeebee_> b_jonas: I think you have to do the work yourself to refactor if you want the guaranteed efficiency. ghc "does it's best" but its ideas of what's reusable might not match yours.
12:10:05 <Zevv> how do I pattern-match that ?
12:10:17 <b_jonas> misterbeebee_: ok
12:10:21 <byorgey> b_jonas: I think ghc does some of that, it's called 'let-floating'
12:10:21 <oerjan> Zevv: unless you want a specific format, just add "deriving Show" and use print
12:10:25 <byorgey> I think
12:10:26 <sjanssen> Zevv: dumpNtree (Ntree x xs) = do ...
12:10:38 <byorgey> b_jonas: try doing a search for 'let-floating' and see what you find
12:10:44 <Zevv> sjannsen:
12:10:44 <Zevv> test.hs:20:13:
12:10:44 <Zevv>     `Ntree' is not applied to enough type arguments
12:10:44 <Zevv>     Expected kind `??', but `Ntree' has kind `* -> *'
12:10:55 <int-e> Zevv: you probably want  dumpNtree :: Show a => Ntree a -> IO ()  as a type.
12:10:57 <b_jonas> I thought it could do that because pureness helps determine when this is possible, and lazyness guarantees that if f is not called, then h isn't evaluated
12:11:03 <misterbeebee_> b_jonas: here's a random example: http://hackage.haskell.org/trac/ghc/ticket/149, milestone 6.8
12:11:04 <lambdabot> Title: #149 (missed CSE opportunity) - GHC - Trac
12:11:06 <sjanssen> Zevv: you've got an error in your type signature
12:11:20 <misterbeebee_> simonmarlow wrote "
12:11:20 <misterbeebee_> Looks like a case where GHC's CSE isn't spotting the common
12:11:21 <misterbeebee_> subexpression.  The CSE in GHC is pretty cheap & cheerful,
12:11:21 <misterbeebee_> there are plenty of ways it could be improved, or even
12:11:21 <misterbeebee_> replaced by a completely new one."
12:11:36 <byorgey> misterbeebee_: b_jonas isn't talking about CSE.
12:11:37 <sjanssen> Zevv: dumpNtree :: Ntree a -> IO ()
12:11:37 <Zevv> int-e: yes, guess you're right. Let me try that.
12:11:57 <Zevv> sjanssen: that's it
12:12:06 <Zevv> pretty obvious, now
12:12:09 <Zevv> thank you
12:12:55 <misterbeebee_> oh, sorry, is the difference that b_jonas is using one expression twice in one superexpression?
12:13:17 <b_jonas> misterbeebee_: let me repeat the examples
12:13:17 <misterbeebee_> anyway, i think the general idea holds, that there aren't formal guarantees around what expressions ghc optimizes.
12:13:30 <b_jonas> 'let f x = g y x in ...' to 'let h = g y; f x = h x in ...' is what I'd like
12:13:41 <b_jonas> '(g f x, h f x)' to 'let y = f x in (g y, h y)' is what I think cse is
12:13:57 <b_jonas> no wait, the latter is wrong
12:14:06 <b_jonas> '(g (f x), h (f x))' to 'let y = f x in (g y, h y)' is what I think cse is
12:14:42 <b_jonas> misterbeebee_: ok
12:15:47 <misterbeebee_> for me and anyone who was unaware: http://www.haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
12:15:49 <lambdabot> Title: GHC/FAQ - HaskellWiki, http://tinyurl.com/ywxcqq
12:16:00 <misterbeebee_> "Bottom line: if you care about sharing, do it yourself using let or where. "
12:17:34 <int-e> b_jonas: you need floating out, i.e. transforming  \x -> let t = <something that doesn't depend on x> in y  to  let t = <something> in \x -> y .  GHC does that sometimes. I don't know what rules it uses for that.
12:19:18 <hpaste>  eyeris pasted "Someone correct my thinking, please." at http://hpaste.org/3020
12:20:00 * monochrom prepares a brain transplant for eyeris.
12:20:16 <eyeris> doh! cfold??? is supposed to be cfold' -- copy/paste from Adobe Acrobat sucks
12:20:33 <yetAnotherOne> is there a good introduction to XSLT with HXT? I looked at the haddock documentation but it is a bit confusing
12:20:45 <int-e> eyeris: note that the function passed to cfold' is not f, but a function that takes 3 parameters instead
12:22:04 <int-e> (\x t g -> f x (g t)) <-- that one
12:22:28 <monochrom> cfold' is different from cfold.
12:22:51 <monochrom> cfoldl' 's f deliberately wants 3 parameters.
12:22:56 <int-e> hrm. 'is not f' == 'is not the same f that was being passed to cfold'
12:22:59 <eyeris> int-e: so g in that lambda is cfold?
12:23:02 <eyeris> erm
12:23:04 <eyeris> int-e: so g in that lambda is cfold'?
12:23:30 <monochrom> You should :type cfold' for wonders.
12:23:40 <int-e> g will be (\y -> cfold' f y xs)
12:24:59 <eyeris> all these single letter param names make my head spin
12:25:21 <monochrom> single letter is not the problem. the problem is same letter.
12:25:25 <eyeris> right
12:25:32 <Zevv> yes, why is it that Haskell programmers don't use 'normal' names for parameters ?
12:25:42 <vincenz> define 'normal'
12:25:45 <Zevv> 'normal', as in, short but descriptive
12:26:08 <eyeris> vincenz a name is supposed to distinguish a variable from other variables
12:26:17 <nomeata> Hi. Just a quick check if I got it right: in the Monad Reader 8, page 33, where MapAppend is defined: Do I really need the instance MapAppend f Nil Nil ? Should this follow from the other instance?
12:26:41 <hpaste>  monochrom annotated "Someone correct my thinking, please." with "renamed" at http://hpaste.org/3020#a1
12:26:55 <vincenz> eyeris: and 'x' == 'y'?
12:26:58 <int-e> Zevv: the functions are very generic, so more meaningful names are hard to find.
12:27:24 <Zevv> int-e: ok, that makes sense
12:27:28 <eyeris> Thanks, monochrom
12:28:20 <int-e> Zevv: so "f" is a function, "x" and "y" are arguments. "xs" is a list. (I think the code should use "xs" instead of "l" actually)
12:29:33 <int-e> (the idea behind "xs" is that it's a plural "x")
12:29:35 <Zevv> 'a' is always for a generic type ?
12:29:47 <int-e> usually.
12:29:52 <Zevv> ok
12:30:00 <Zevv> things start to fall in place in my head
12:30:31 <Zevv> although I never had such a hard time with any language
12:31:10 <eyeris> cfold' :: (t -> t1 -> (t1 -> t1) -> t1) -> t1 -> [t] -> t1
12:31:13 <int-e> Haskell is mind-bending. :)
12:31:19 <eyeris> What is the t -> t1 convention?
12:31:20 <sysfault> haha
12:31:24 <eyeris> What does the 1 mean?
12:31:26 <int-e> @quote rewire
12:31:27 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
12:31:35 <Zevv> it hurts my brain, but I like it, in a masochistic sense
12:32:04 <int-e> eyeris: t1 is just a different type variable from t
12:32:08 <dmwit> eyeris: It just creates a different type variable.
12:32:25 <eyeris> so the t in both doesn't mean that they are related?
12:32:27 <dmwit> eyeris: If you replace t1 with r everywhere, the type is still valid.
12:32:31 <dmwit> Nope!
12:32:47 <byorgey> Zevv: it's exercise for the brain =)
12:33:02 <int-e> eyeris: they're just names really. cfold' :: (barney -> fred -> (fred -> fred) -> fred) -> fred -> [barney] -> fred  would work just as well.
12:33:15 <int-e> eyeris: although it would be very silly to write that.
12:33:18 <kscaldef> and now it is totally clear ;-)
12:34:04 <dmwit> When I write type annotations, I try to choose meaningful names, despite the Haskell convention of one-letter type variables.
12:34:08 <eyeris> it would be better than t, t1, and [t] considering stuff like x:xs is so common, t1 seems like the first element of [t] or something. Stupid inferrence.
12:34:29 * int-e would use  a  and  b  here.
12:34:43 <eyeris> Stupid inferrence = in my brain, not Haskell's type inferrence
12:34:52 <eyeris> Right, a and b are much better
12:36:40 <oerjan> :t let foldl' f z [] = z; f z (x:xs) = f x z (\y -> cfold' f y xs) in cfold'
12:36:42 <lambdabot> Not in scope: `cfold''
12:36:42 <lambdabot>  
12:36:42 <lambdabot> <interactive>:1:67: Not in scope: `cfold''
12:37:06 <oerjan> :t let cfold' f z [] = z; cfold' f z (x:xs) = f x z (\y -> cfold' f y xs) in cfold'
12:37:08 <lambdabot> forall t t1. (t -> t1 -> (t1 -> t1) -> t1) -> t1 -> [t] -> t1
12:37:26 <int-e> ghc isn't so good at inventing type variables :)
12:37:30 <misterbeebee_> I think the one-letter variable names are there to avoid confusing them functions... since so many short words are function names, it's confusing when it becomes unclear whether an identifier is a local variable or a function pulled in from elsewhere.   let length =  1 + blah in ... --oops!
12:37:48 <int-e> "t" is a type. when type variable names clash it appends a number to one of them
12:38:11 <oerjan> :t let map f [] = []; map f (x:xs) = f x:map f xs in f
12:38:13 <lambdabot> Not in scope: `f'
12:38:18 <oerjan> :t let map f [] = []; map f (x:xs) = f x:map f xs in map
12:38:20 <lambdabot> forall t a. (t -> a) -> [t] -> [a]
12:38:40 <int-e> hmm. interesting.
12:38:45 <oerjan> now there it chose different ones (scratching head)
12:39:16 <oerjan> and neither uses any other functions
12:39:40 <int-e> :t (\x -> x)
12:39:42 <lambdabot> forall t. t -> t
12:40:18 <omniscientIdiot> GHC likes t & a
12:40:21 * omniscientIdiot runs
12:40:23 <oerjan> :t (\x y -> x y)
12:40:24 <dmwit> :t let bfold f d (x1:x2:xs) = bfold f d (f x1 x2 : bfold f d xs); bfold f d [x] = x; bfold f d [] = d in bfold
12:40:25 <lambdabot> forall t t1. (t -> t1) -> t -> t1
12:40:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
12:40:27 <lambdabot>       Expected type: [a]
12:40:42 <int-e> @type (:)
12:40:44 <lambdabot> forall a. a -> [a] -> [a]
12:40:47 <oerjan> it seems like it uses t for types generated from pure lambdas, perhaps
12:40:52 <int-e> see that's where it gets the a from
12:41:05 <oerjan> ah
12:41:26 <oerjan> :t ?x
12:41:29 <lambdabot> forall t. (?x::t) => t
12:41:44 <oerjan> or maybe it uses t whenever nothing else determines it
12:41:50 <hpaste>  monochrom pasted "my understanding of what "real" programmers' mean by "normal" "descriptive" names" at http://hpaste.org/3021
12:42:24 <misterbeebee_> monchrom, all method names must be in CamelCase.
12:42:38 <misterbeebee_> and all parameters also
12:43:02 <b_jonas> misterbeebee_: "must" in what sense?
12:43:20 <monochrom> In the RFC sense :)
12:43:41 <omniscientIdiot> monochrom: the_rest_of_that_list_which_is_hitherto_thereof_traversed_left_to_right_using_that_operator_which_is_called_in_the_inductive_case is misleadingly named.  It could be nil. :P
12:43:43 <b_jonas> hitherto_thereof is my fav part of that
12:43:46 <misterbeebee_> http://en.wikipedia.org/wiki/CamelCase#Programming_and_coding_style
12:43:47 <int-e> monochrom: oh yeah, very readable indeed. but you need to spread it over several lines
12:43:49 <lambdabot> http://tinyurl.com/rf4do
12:44:00 <Zevv> monochrom: I get your point :)
12:44:15 <int-e> monochrom: and there goes the 3-fold decrease in code size that haskell code often claims :P
12:44:19 <misterbeebee_> "The Java coding style dictates that UpperCamelCase be used for classes, and lowerCamelCase be used for instances and methods" :-)
12:44:24 <eyeris> monochrom so in that paste, g in cfold becomes the \y lambda that is defined in cfold'?
12:45:05 <int-e> eyeris: yes.
12:45:25 <oerjan> :t let cfold' f z [] = z; cfold' f z (x:xs) = f x z (\y -> cfold' f y xs) in (cfold', cfold')
12:45:27 <b_jonas> int-e: not if you measure in lines of code
12:45:28 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> (t1 -> t1) -> t1) -> t1 -> [t] -> t1, (t2 -> t3 -> (t3 -> t3) -> t3) -> t3 -> [t2] -> t3)
12:46:37 <int-e> b_jonas: I said immediately before that that this code ought to be spread over several lines (for readability)
12:47:18 <b_jonas> yeah, in that case
12:47:44 <b_jonas> though loc is defined in so many ways that you could make these count as one line in your definition
12:47:48 <monochrom> I presume real world programmers use triple-head monitor setups, each head 40" in width.
12:47:51 <twanvl> That function needs a more descriptive name, how are you suppost to understand foldl?
12:48:15 <b_jonas> twanvl++
12:48:31 <monochrom> hehe
12:49:40 <dmwit> ?botsnack
12:49:41 <lambdabot> :)
12:49:57 <int-e> twanvl: reduce_list_starting_by_combining_the_leftmost_element_with_the_second_paramater_using_f_and_then_continue_like_that_until_the_whole_list_is_exhausted_and_finally_return_the_result_of_the_last_call_to_f_or_the_second_parameter_if_there_was_none
12:50:13 <kscaldef> int-e++
12:50:23 <eyeris> monochrom h, in the "real" world would be named something like cb for "callback" -- I know it isn't a callback in haskell, I don't know what the proper term is
12:50:24 <twanvl> What is that 'f' doing in there?
12:50:38 <int-e> twanvl: oops. sorry.
12:50:43 <xerox> haa
12:50:47 <omniscientIdiot> s/f/that_operator_which_is_called_in_the_inductive_case/g
12:51:14 <eyeris> s/f/induc_op/g
12:51:15 <int-e> but that's too long so we'll abbreviate it to rlsbctlewtspufatcltutwlieafrtrotlctfotspitwn
12:51:24 <int-e> that's clearly much better than foldl
12:51:37 <dmwit> > let bfold' f (x1:x2:xs) = bfold' f (f x1 x2 : bfold' f xs); bfold' _ xs = xs; bfold f d xs = head . bfold' f $ d:xs in bfold (*) 1 [1..10]
12:51:39 <lambdabot>  3628800
12:52:12 <monochrom> You will find that in functional programming we use higher-order functions so often, 50% of the parameters are callbacks, the word "callback" no longer means a thing and it's just as well as "f".
12:52:24 <allbery_b> @yhjulwwiefzojcbxybbruweejw
12:52:24 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
12:52:44 <dmwit> Bonus points if you actually typed that command, rather than copy+pasting it.
12:53:18 <monochrom> a "meaningful" name is meaningful only because it is used maybe 5% or 10% of the time. This is straight from information theory.
12:54:30 <Cale> twanvl: The right way to understand foldr and foldl is by treating them as graph transformations
12:54:45 <int-e> to be fair ...  foldl step accum (x:xs) = foldl (step axxum x) xs  would be ok, I think
12:54:46 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
12:54:47 <lambdabot> Title: Fold Diagrams - CaleWiki
12:54:51 <eyeris> monochrom noted
12:55:11 <int-e> s/xx/cc/
12:55:27 <twanvl> Cale: I know what foldl is, but the user of monochrom's horrible definition might not :)
12:55:53 <Cale> what was monochrom's definition?
12:56:01 <int-e> http://hpaste.org/3021
12:56:21 <Cale> oh hehe
12:56:38 <Cale> heh, hitherto thereof
13:00:45 <matthew-_> I take it you've seen foldl.com and foldr.com
13:01:17 <monochrom> hahahahahahaa
13:02:02 <int-e> what monochrom said :)
13:03:05 <matthew-_> and liftM2.com
13:03:15 <matthew-_> ;-)
13:03:37 * matthew-_ wonders how many will actually type that in...
13:03:46 * EvilTerran did
13:03:50 <int-e> I didn't actually type anything ;)
13:03:55 <matthew-_> cheat
13:03:57 <EvilTerran> well, ^C^V
13:04:30 * oerjan did
13:05:08 <oerjan> map.com
13:05:35 <oerjan> fmap.com, even
13:06:09 <matthew-_> nah, I tried those. I thought there was a third one, but I can't remember what it was now
13:06:34 <esap> someone should add the full ghci so you could click on its source code and expand it by clicking '...'
13:07:11 <esap> to see how it evaluates itself :-)
13:08:00 <omniscientIdiot> twanvl: are you the author of 21 thoughts?
13:09:14 <EvilTerran> esap, have you seen hat?
13:09:19 <EvilTerran> @where hat
13:09:19 <lambdabot> http://www.haskell.org/hat/
13:09:22 * esap nods
13:12:27 <twanvl> omniscientIdiot: Yes
13:12:37 <omniscientIdiot> I made a comment on your "functional references" post.  (excellent post, btw)
13:12:57 <b_jonas> ah
13:13:08 <b_jonas> I guess it might work now
13:13:16 <b_jonas> now I have to write a good tester
13:17:58 <tibbe> @paste
13:17:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:18:02 <hpaste>  b_jonas pasted "exact calculations with square roots" at http://hpaste.org/3022
13:18:17 <hpaste>  tibbe pasted "Cabal build errors on Mac OS X" at http://hpaste.org/3023
13:18:24 <b_jonas> do you have any idea what kind of tests I could write for this?
13:18:40 <tibbe> anyone know why the above fails to find readline on mac os x
13:18:48 <b_jonas> it compares real numbers built from integers, arithmetic operatons, and square roots exactly
13:18:49 <tibbe> normally it works since I've installed the lib
13:19:08 <KatieHuber> where did you put the library?
13:22:18 <oerjan> @users
13:22:18 <lambdabot> Maximum users seen in #haskell: 420, currently: 389 (92.6%), active: 19 (4.9%)
13:25:08 <hpaste>  omniscientIdiot annotated "Not in scope: `field_'" with "type contexts in TH" at http://hpaste.org/3018#a5
13:27:17 <tibbe> KatieHuber: /Library/Frameworks/
13:27:50 <KatieHuber> so it's ReadLine.framework, not libreadline.dylib ?
13:28:17 <KatieHuber> you probably need to pass some extra flags to GHC to get it to link the framework
13:28:26 <twanvl> omniscientIdiot: I think ctx should be [ConT "Ref" `AppT` VarT r]
13:29:03 <omniscientIdiot> twanvl: I wasn't sure becuase "Ref" is a class, not a type.
13:29:26 <twanvl> It looks like TH abuses types as classes here, let me see what derive does
13:29:43 <KatieHuber> I can't remember offhand whether it understands -framework ReadLine or whether you need to use -optl- to get that in
13:29:53 * omniscientIdiot tries, cross your fingers
13:31:10 <omniscientIdiot> dang, "FRef.hs:106:19: Not in scope: data constructor `Ref'"
13:33:34 <tibbe> KatieHuber: someone probably forgot to add it to the .cabal file
13:33:36 <omniscientIdiot> silly me, dumb mistake.  IT'S WOOOOOOOOOORKS!!!!!!!!!!!!!!!!
13:34:02 <b_jonas> omniscientIdiot: good
13:34:15 <KatieHuber> the "official" binary distribution of GHC for Mac OS X is really weird, with those silly extra frameworks
13:34:28 * tibbe nods
13:34:28 <KatieHuber> I imagine most people use the macports one
13:34:37 <tibbe> I don't really like macports
13:34:37 <KatieHuber> which won't suffer from the same issue
13:34:41 <tibbe> but I guess I should
13:35:28 <KatieHuber> I'm not sure anyone *likes* MacPorts...
13:35:42 <KatieHuber> it's the worst way to get unix software, except for all the others
13:35:51 <vincenz> haha
13:40:26 <hpaste>  omniscientIdiot annotated "Not in scope: `field_'" with "final version, now for some documentation :)" at http://hpaste.org/3018#a6
13:41:13 <pixl> #join ubuntu+1
13:41:41 <monochrom> #join ubuntu+2, +3, +4, ...
13:41:46 <EvilTerran> no thanks
13:41:57 <pixl> :P
13:42:14 <twanvl> map (#join ubuntu+) [1..]
13:47:59 <misterbeebee> my pac and PC both just crashed within 5 minutes of each other
13:48:18 <monochrom> pac = pacman? :)
13:48:29 <misterbeebee> oops, mac
13:48:37 <monochrom> hehehehe teasing you :)
13:48:38 <misterbeebee> my pacman machine never crashed
13:48:49 <dons> ?yow
13:48:49 <lambdabot> Can I have an IMPULSE ITEM instead?
13:49:00 <fnord123_> Ugh. How do people type in editors that aren't vim or emacs? I opened xcode to bash out a small program and it's so painful.
13:49:02 <bos> dons: guten abend
13:49:10 <misterbeebee> it's hard to type correctly in IRC, the delay in proofreading and correcting is a strain on reaction time
13:49:12 <dons> hey bos :)
13:49:26 <dons> all the HW talks have been videotaped, btw
13:49:35 <bos> sweet!
13:49:36 <dons> so hopefully we'll have them up on google or something soon
13:49:39 <bos> ossm!
13:49:44 <sjanssen> soon?!  now!
13:50:10 * bos wishes, for once, he was in germany
13:50:12 <monochrom> I type in notepad almost the same way I type in emacs.
13:50:24 <opqdonut> ?yow
13:50:24 <lambdabot> I'm ANN LANDERS!!  I can SHOPLIFT!!
13:50:49 <dons> sjanssen: phil wadler asked if he can get a xmonad tshirt :)
13:51:03 <monochrom> Oh, and I type in "cat > x.hs" or "copy con: x.hs" almost the same way I type in notepad. :)
13:51:06 <sjanssen> nice
13:51:10 <misterbeebee> I just re-discovered the RWH chapter outline. It's to see the proposed outline  going further  (Reference: http://www.realworldhaskell.org/blog/2007/05/23/real-world-haskell-its-time/)
13:51:12 <lambdabot> Title: Real World Haskell ª Blog Archive ª Real-world Haskell: it&#8217;s time!, http://tinyurl.com/2ddm5b
13:51:26 <misterbeebee> (20 chapters further) than the 7 currently up on the review website
13:51:44 <misterbeebee> i was worried for a bit that the book wouldn't get far beyond basics.
13:52:29 <monochrom> I believe the word "real" in the title is honest.
13:52:34 <dons> misterbeebee: we want to jump into real stuff
13:52:44 <dons> since there's already lots of basics books
13:53:01 <dons> and thesedays we know how to do pretty much anything in a purely functional language , so time to just do it
13:53:43 <misterbeebee> yeah, i remember getting excited when i saw the announcement in may, and then confused when the draft went up. but I'll be patient while you all write:)
13:54:43 <bos> yeah, we started from the beginning. shocking decision, i know :-)
13:55:02 <misterbeebee> but I always skip to the end when i read!
13:55:34 <omniscientIdiot> any luck taming the onslaught of commentary?
13:55:35 <monochrom> "After reading this book, you will:  * talk to databases;  * display and react with windows and buttons;  * fulfill web requests "
13:56:01 <FMota_> oh dear
13:56:02 <fnord123_> be able to write a proper date class
13:56:05 <FMota_> talk to databases? :o
13:56:13 <monochrom> hehehehe
13:56:30 <bas> Hello, quick question: When in ghci I do: :m System.FilePath I get the error "Could not find module `System.FilePath'" ? But I have filepath-1.0 installed: ghc-pkg -L ... filepath-1.0 ... What can be wrong?
13:56:53 <monochrom> Translation: after reading this book, you will be assimulated into our borg collective, and become one of our computing nodes. Resistence is futile.
13:56:56 <sorear> bas: Many things.  Does ghci -v5 say more?
13:57:01 <fnord123_> i think someone asked on haskell cafe about distghc. did anything become of this idea?
13:57:03 <misterbeebee> what's the deal with "fps" vs "bytestring", the ghc packages? I tried to  install the Chris K's  efficient regex packages in my ghc 6.6 and ran into all manner of package-manager trouble around strings (and other support libs) . Should I just take a long nap until 6.8 is released?
13:57:14 <jcpetruzza> hi, anybody knows if ghc 6.8.0 binaries should come with profiling support?
13:57:22 <sorear> misterbeebee: No, 6.8 will be worse.
13:57:32 <dons> jcpetruzza: they will, yes.
13:57:37 <sorear> jcpetruzza: No, 6.8.0 will never exist.  6.8.1 should have it, though
13:58:51 <jcpetruzza> what i mean is, i downloaded a 6.8 rc, tried to compile with profiling support and got an ld error
13:58:55 <misterbeebee> sorear: then, what release or tool should I wait for (or, heaven help, contribute to)?  Right now, my largest barrier to using haskell is figgering out how to make any really important  non-preinstalled library work on my system.
13:59:09 <jcpetruzza> (-lHSrts_p not found)
14:00:07 <misterbeebee> I've tried cabal-install, my own little cabal-downloader scripts, 6.6 and 6.8, always some trouble.
14:00:29 <sjanssen> jcpetruzza: a stable release might be more reliable
14:01:38 <bos> sjanssen: the problem is that cabal in 6.6.1 isn't capable enough to do the fancy cabal-install and so on stuff
14:01:50 <bos> but cabal 1.2.0 works fine with ghc 6.6.1
14:02:01 <bos> so it's not really necessary to wait for ghc 6.8.1
14:02:27 <jcpetruzza> sjanssen: sure, i know. but i have a program that crashes when compiled with profiling support under 6.6.1 and wanted to see if it was fixed in 6.8 before filing a bug report
14:02:43 <bos> jcpetruzza: eep
14:03:11 <bos> file a bug now, and worry about reproducing it under 6.8 later
14:03:15 <sjanssen> jcpetruzza: in that case disregard my suggestion :)
14:03:21 <dons> the haskell workshop was huge this year. must have been 130 or so registrants
14:03:27 <dons> and a bunch more packed into the room.
14:03:32 <dons> not much smaller than icfp itself
14:03:37 <bos> if you file a bug with a reproducible test case now, someone else can try to reproduce it
14:03:39 <dons> i feel sorry for the scheme workshop next door
14:03:41 <misterbeebee> bos: So does that mean that cabal-install is effectively unusable for any package that is not yet updated to cabal-1.2.0?
14:03:48 <bos> i wonder when the haskell workshop will turn into the haskell conference
14:04:05 <bos> misterbeebee: wouldn't surprise me, but i don't know for sure
14:04:20 <sorear> misterbeebee: all programs should work with cabal-1.2.0
14:04:38 <sorear> misterbeebee: do all your programs break when you upgrade dpkg/rpm/whatever?
14:04:45 <jcpetruzza> bos: ok, i'll do.... but i'm also interested in the profiling output! :)
14:05:18 <bos> sorear: that's not really true, there are plenty of programs whose Setup.{l,}hs breaks with 1.2.0
14:05:33 <Heffalump> bos: I think it'll always be subordinate to ICFP
14:05:37 <sorear> setup.lhs is pure evil!
14:05:37 <misterbeebee> sorear: I don't have any existing programs I'm worried about. My trouble is how to  install new haskell packages. i always get errors
14:05:49 <misterbeebee> let me take a step back.
14:05:56 <dons> misterbeebee: what ghc version are you using?
14:06:10 <dons> if you're using 6.6.x pretty much anything on hackage should work
14:06:33 <misterbeebee> I have both 6.6.1 from macports and 6.6.1 direct form haskell.org, both on Mac OS X Intel
14:06:46 <Heffalump> I've heard talk of it becoming two days, though
14:06:48 <bos> dons: many people in freiburg talking or asking about the book?
14:06:49 <misterbeebee> I'm pretty sure I've had trouble with hackage packages
14:07:11 <omniscientIdiot> hmm, addRefs breaks on paraemterized datatypes...
14:07:21 <misterbeebee> I'll go try to instal some packages now, and let you know what I find, since I don't recall details now.
14:07:31 <dons> bos, yeah, its come up a fair bit.
14:08:06 <bos> dons: what kind of comments/questions?
14:09:12 <dons> mostly about the overall intent, and range of topics. and surprise about the number of reviewers / comments
14:09:22 <dons> so people feeling out what we're doing
14:10:50 <hpaste>  misterbeebee pasted "cabal-install regex weirdness" at http://hpaste.org/3024
14:11:07 <misterbeebee> there's an example of a package I can't install, with contradictory output from cabal-install
14:11:11 <bos> dons: fair enough
14:11:28 <misterbeebee> should I try building the package without cabal-install?
14:12:34 <dons> bos, really good emphasis this year on tools for real world stuff
14:12:46 <dons> the debugger, hpc, QC and xmonad summarsing those
14:13:02 <dons> so there's a nice vibe around `haskell phase 2: the users taking over' :)
14:13:15 * Boney wonders if Bennie Pope went.
14:13:26 <sorear> Bernie?
14:13:35 <Boney> Hrm.  Now I'm not sure.
14:13:44 <dons> havne't seen Bernie
14:13:44 <Boney> he's from Melbourne University.
14:13:47 <bos> dons: the effort involved in avoiding success is becoming too high :-)
14:14:12 * sorear will just switch to pure maths if it gets too bad :)
14:14:15 <Boney> He knows me but I don't know him, he met one of my friends and asked about me.
14:14:35 <oerjan> sorear: i was thinking people might start switching to Agda
14:15:05 <Heffalump> I've not seen him either
14:15:05 <dons> sorear: there were jokes that the phase 1 guys will move to epigram/coq now, -- the guys who don't like writing programs :)
14:15:07 <sorear> I have bad vibes about Agda.  Don't ask me to explain them, though
14:15:24 <hpaste>  twanvl annotated "Not in scope: `field_'" with "Should work on parameterized types (untested)" at http://hpaste.org/3018#a7
14:15:46 <sorear> if epigram existed, I might use it
14:15:55 <sorear> *epigram2
14:16:00 <omniscientIdiot> gotta love (untested) :)
14:16:11 <sorear> but epigram2 doesn't exist and epigram1 is incompatible with xmonad ;)
14:16:53 <twanvl> that just means I am lazy :)
14:17:12 <dons> sorear: and the epigram guys are slowly moving to agda..
14:17:31 <Boney> Does anything about Mercury make it out of csse.unimelb?  I wonder how many FP and Logic programmers know of it.
14:17:35 <matthew-_> dons: oh really? interesting. The epigram blog hasn't been updated for a while
14:17:41 <monochrom> Somehow there ought to be a scheme to transform haskell success into epigram success and coq success. So you can't escape for long.
14:18:19 <bos> Boney: people know it exists.  fergus henderson seems to scare people off.
14:18:42 <twanvl> monochrom: That would probably require a proof of your success
14:18:48 <Boney> heh.  I don't think I know Fergus.
14:19:09 <dons> ?users
14:19:09 <omniscientIdiot> twanvl: refDecls needs a Dec instead of a Type, but I can do that.  Thanks!
14:19:09 <lambdabot> Maximum users seen in #haskell: 420, currently: 386 (91.9%), active: 19 (4.9%)
14:19:19 <misterbeebee> anybody have a look at my hpaste to advise on the regex-base package version incompatibility? Why does cabal-install think I have regex-0.92 installed and not installed?  http://hpaste.org/3024
14:19:25 <dolio> sorear: Agda isn't 2-dimensional enough, clearly. :)
14:19:48 <Boney> I prefer some things in mercury like determinism checking but I think I mostly prefer Haskell.
14:20:07 <Saizan> misterbeebee: how many ghc have you installed?
14:20:55 <newsham> sorear: which proof assistant do you have good vibes about?
14:20:56 <misterbeebee> Looks like I'm up to 4 :-(. 2 of which might be in my PATH. Think they are getting mixed up?
14:21:41 <misterbeebee> let me blow away /usr/local/lib and try again
14:22:45 <misterbeebee> generally speaking ,is it safe to add ghc packages to a macports instal in /opt, or should i install ghc form haskell.org into /usr/local and add packages there?
14:22:56 <sorear> misterbeebee: I blame cabal-install; what happes when you use cabal directly?
14:23:08 <misterbeebee> sorear: I'll try....
14:23:09 <omniscientIdiot> twanvl: will this break if the client module imports FRef qualified?  Would mkName qualify "Ref" and "ref"?
14:24:05 <twanvl> You could try mkName "FRef.Ref"
14:24:20 <omniscientIdiot> import qualified FRef as HaHaGotchaNow
14:25:02 <misterbeebee> sorear: compiling/running  Setup.hs  fro regex-tdfa, gives the same error about missing regex-base
14:25:28 <sorear> misterbeebee: what happens when you run Setup.hs from regex-base?
14:25:36 <omniscientIdiot> seems fragile, but this was just a small exercise so I could learn some TH.
14:26:23 <omniscientIdiot> $(addRefs 'HaHaGotchaNow ''Foo)?
14:27:13 <misterbeebee> ooh, it installs, but it installs to /usr/local/, which is not my current ghc prefix. let me override that and see what happens
14:28:59 <misterbeebee> bingo. I as able to configure regex-tdfa. So the issue is I need to be explicit about  "setup configure --prefix /opt/local", I can't rely on the prefix built into the ghc that compiled setup.
14:29:00 <quicksilver> phobes: no :)
14:29:09 <misterbeebee> Next problem:
14:29:09 <misterbeebee> Text/Regex/TDFA/CorePattern.hs:74:94:
14:29:09 <misterbeebee>     Not in scope: type constructor or class `Monoid'
14:29:19 <misterbeebee> I think that's because ghc move Data.Monoid around in the stdlib
14:29:24 <misterbeebee> (am i right?)
14:29:25 <quicksilver> phobes: but I think I figured it out
14:29:36 <bos> misterbeebee: regex-tdfa has a bunch of compilation problems. i owe chris kuklewicz some patches.
14:29:53 <bos> misterbeebee: also, it's got terrible performance if you try doing any subgroup captures
14:30:19 <misterbeebee> I'm not married to -tdfa. I want the whole set so I can look at the regex wiki page and use whichever I need for a given problem
14:31:02 <sorear> @seen TuringTest
14:31:02 <lambdabot> I saw TuringTest leaving #haskell 1d 5h 9m 52s ago, and .
14:31:04 <misterbeebee> So, should I try to fiddle with my downloaded regex packages to fix "simple" problems like bad imports, or should I wait a while until regex stabilized again?
14:31:52 <misterbeebee> I think last time I tried this, I monkeypatched my downloaded library source and got them to build. but then I lost my work when I cleaned up my multiplicity of ghc installations.
14:31:58 <bos> misterbeebee: up to you, i won't have much time to send chris patches soon
14:34:45 <misterbeebee> bos: if you encourage me by saying I should be able to build the regex suite by lightly fiddling the source Imports and the like), and not hardcore changes, I'm happy to do it.  I'm just confused--- what the heck version of GHC is Chris using to build the package? Does he have some specially-configured cuild environment?
14:35:31 <bos> misterbeebee: i've no idea what chris was using.
14:37:56 <misterbeebee> ok, well I'll have a go at it, and keep careful notes this time (maybe even learn how to use 'patch') and share my results when I have any. thanks.
14:40:01 <Heffalump> I successfully built tdfa and basewith 6.6.1 a few weeks ago, FWIW.
14:40:11 <Heffalump> ISTR the main issue was broken haddock.
14:41:55 <SamB> who is chris?
14:42:30 <sorear> SamB: Chris Kuklewitz, aka TuringTest
14:42:37 <misterbeebee> Heffalump: did you change any source code?
14:42:41 <SaMBuCa_> salve..
14:42:47 <SamB> sorear: ah.
14:42:58 <SaMBuCa_> oi lambdabot
14:42:59 <Heffalump> misterbeebee: not that I recall,  apart from fixing up the haddock comments (and that only to build the docs)
14:43:01 * SamB wants to pass turingtest in the hall
14:43:07 <xerox> SaMBuCa_: hello
14:43:07 <Heffalump> I think I removed a -Werror somewhere
14:43:19 <sorear> SaMBuCa_: hello?
14:43:28 <SaMBuCa_> hello ^^
14:43:29 <sorear> lambdabot's not human, btw
14:43:34 <SaMBuCa_> i know
14:43:42 <misterbeebee> huh. I was guessing that this ticket might have been related to the Data.Monoid methods going missing, but I'm really not sure... http://hackage.haskell.org/trac/ghc/ticket/710
14:43:44 <lambdabot> Title: #710 (library reorganisation) - GHC - Trac
14:43:50 <dolio> @vixen Are you human?
14:43:50 <lambdabot> is that really what you want to know?
14:43:55 <SamB> SaMBuCa_: Hello, person with a name confusingly similar to mine (for completion, anyway)
14:44:19 <SaMBuCa_> SamB: LoL!
14:44:30 <SamB> dolio: you don't have to be human to pass the turing test anyway
14:44:49 <dolio> SamB: And you don't have to be a bot to fail it. :)
14:45:03 <SamB> only capable of human-like discourse
14:45:12 <SamB> well, I meant, you could be vulcan or something too
14:45:28 <dolio> @vixen Are you a vulcan?
14:45:28 <lambdabot> whoa whoa whoa, one question at a time!
14:46:44 <misterbeebee> Is there an easy way to determine if Data.Monoid is exported with all the base/Prelude stuff? where would I look on my system to see the default exports?
14:46:59 <SamB> hmm. what's the point of pitting two individuals against one another for the turing test?
14:47:00 <misterbeebee> (or to modify them)
14:53:10 <kpreid> SamB: to give them reason to think the other might be human?
14:53:27 <SamB> yes but it seems like it's too confusing to set up
14:53:49 <SamB> like what if you run accross an unidentified being
14:54:05 <SamB> how do you know whether to run it against a computer program or against a person?
14:54:10 <SaMBuCa_> SamB: what's the story 4 ur nick?
14:54:27 <SamB> my name is Samuel Bronson
14:54:30 <SamB> I go by Sam
14:54:51 <kpreid> SamB: well, if the matcher knows, then they can include only pairs with humans...
14:55:15 <kpreid> if not, well, a minor cost to make the system work
14:56:05 <SamB> personally I would prefer a solo test ;-)
14:56:11 <SamB> makes things a lot simpler
14:56:26 <SaMBuCa_> SamB: my nick came from the italian liquor
14:57:26 <dons> here's a quick HPC overview (the new code coverage tool in ghc head)
14:57:34 <dons> it really is very nice, here's data.bytestrings' testsuite coverage
14:57:37 <dons>   http://www.galois.com/~dons/Data.ByteString.hs.html
14:57:53 <dons> yellow is untested code
14:58:15 <dons> hpc does a great job highlighting exactly which code we've not tested yet with QC, and suspicious code that always branches to false
14:58:31 <EvilTerran> red and green?
14:58:49 <dons> red is a boolean that always evaluated to False when run
14:58:57 <dons> and green is always True (so 'otherwise' is always green)
14:59:07 <dons> the important thing is the yellow, which is dead code in the testsuite run
14:59:11 <dons> i.e. untested stuff
14:59:19 <bos> very nice
15:00:05 <bos> looks like coverage is generally very good
15:00:12 <dons> so we had i think 74% , and most of that is just missing QC properties. but it does highlight some problems in generating test data around the size of the chunk boundaries
15:00:19 <EvilTerran> there's a big block of whitespace marked red at line #452, is that meant to happen?
15:00:26 <dons> so it should be possible to get to say 95%
15:00:37 <dolio> Heh, it doesn't seem to like your C macros.
15:00:40 <dons> EvilTerran: that's an interaction with cpp
15:00:51 <dons> since its the  seq x `seq` y `seq` False strictness trick
15:01:15 <dons> bos, apparently in big code houses where quality matters 85% is the benchmark to aim for
15:01:33 <dons> we seem to be able to get much further than that in haskell though, since its just easier to test pure code thorougly
15:01:43 <dons> (you have a hard time testing for malloc returning null in C, for example)
15:01:50 <bos> right
15:02:14 <dons> here's xmonad's core, http://www.galois.com/~dons/StackSet.hs.html
15:02:27 <dons> which is 100% covered at the branch and top level, and 99% of the expressions
15:02:42 <dons> so we actually can use HPC to check our QuickChecks are working
15:03:04 <dons> note the entries on the side for how often each function was called
15:03:48 <dbueno> If I'm using the State monad, and I have a function that may update the state, how can I iterate such a function until its return value ceases to change?  My function has type t -> State MyStateData t
15:04:38 <xerox> dbueno: you use >>=, which is read as bind
15:05:22 <dbueno> Okay... my function is written using bind (to do stuff to the state), but I'd like to iterate that function until the value of type t ceases to be changed by the function.  Does that make sense?
15:05:36 <oerjan> yeah
15:06:00 <matthew-_> dbueno: you're calculating a fixed point.
15:06:08 <dbueno> I can't use iterate directly because the function isn't a->a.
15:06:33 <dbueno> matthew-_ Yes.  But I don't have a function of type a -> a.
15:06:34 <dons> bos, i'd love to publish coverage data like this on hackage for each library's testsuite :)
15:06:54 <dons> the social pressure to improve the coverage is pretty great, once you see these big yellow untested things
15:06:58 <matthew-_> but within the function you're already in the State monad, so you can just call yourself again within a do block, no?
15:07:04 <oerjan> iterTest f lastV = do nextV <- f lastV; if nextV == lastV then return nextV else iterTest f nextV
15:07:16 <dons> hpc should have some sloang about 'be warned, i've only proven this haskel lcorrect, not tested it'
15:07:18 <matthew-_> dbueno: yeah, what oerjan said ;)
15:07:31 <dons> ok. and that's enough typos that i should get some sleep.
15:07:32 <dons> night all!
15:07:39 <dbueno> matthew-_ I wanted to separate the iteration logic from the function.
15:07:57 <xerox> ?type \amb -> amb >>= \x -> fix (\rec x -> amb >>= \y -> if x == y then return y else rec y)
15:07:59 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a -> a
15:08:00 <matthew-_> dbueno: ahh, right, so you want to use fix explicitly?
15:08:03 <xerox> hmmm.
15:08:38 <xerox> oops.
15:08:46 <dbueno> matthew-_ That would be fine... If I can somehow make an a -> a function, I could use fix.
15:09:00 <ddarius> @time dons
15:09:02 <lambdabot> Local time for dons is Mon Oct  1 15:07:55 2007
15:09:11 <xerox> ?type \amb -> amb >>= fix (\rec x -> amb >>= \y -> if x == y then return y else rec y)
15:09:12 <Heffalump> no it's not :-)
15:09:13 <lambdabot> forall (m :: * -> *) a. (Eq a, Monad m) => m a -> m a
15:09:14 <SaMBuCa_> what is "dons"?
15:09:14 <xerox> There you go
15:09:21 <Heffalump> it's another bot
15:09:28 <xerox> dbueno: there, above.
15:09:32 <sorear> ddarius: don is in freiburg atm
15:09:35 <SaMBuCa_> Heffalump: tnx ^^
15:09:43 <dbueno> So I can fix the function oerjan wrote...?
15:09:48 <dbueno> The types look right.
15:09:58 <ddarius> Ah yes.  ICFP and co.
15:10:00 <dbueno> xerox: Or do you mean the \amb... thing you wrote?
15:10:07 <xerox> dbueno: right
15:10:17 <matthew-_> dbueno: oerjan's version was self recursive. You want the xerox version
15:10:21 <Heffalump> sorry, I shouldn't wind up people like that. dons is the main author of lambdabot and is a real human being.
15:10:42 * ddarius has never seen dons.
15:10:57 <xerox> ddarius: check out the hackaton pics :)
15:11:01 <dbueno> xerox, thanks.
15:11:03 * sorear has seen photographs of dons
15:11:14 <Heffalump> I've met him several times.
15:11:14 <dbueno> Thanks very much, all; I have to go.
15:11:28 <ddarius> xerox: -Alleged- photographs of dons.
15:11:45 <ddarius> That said, no one has even seen any photographs of me.
15:11:48 <xerox> dbueno: you're welcome.
15:11:49 <SaMBuCa_> Heffalump: wow, tnx ^^
15:13:08 <SamB_XP> oh, that reminds me
15:14:15 <SamB_XP> I should see if anyone has posted any photos of me on facebook yet...
15:16:04 <matthew-_> my god. there's someone on face book with my name
15:16:26 <matthew-_> and they're spelling my surname as my ancestors did. They could well be relations...
15:16:55 <newsham> wow, my ancestors didnt know how to spell :(
15:19:24 <ddarius> My God!  There someone on facebook without my name... but with my face!!!
15:20:31 <SamB_XP> newsham: neither did the majority of my ancestors!
15:29:54 <SamB_XP> hmm, I guess my candidate profile pictures haven't been uploaded yet
15:33:01 <SaMBuCa_> Can u explain 2 me a simply haskell instruction (with dons' sons in this chan^^) ?
15:33:39 <oerjan> fire away
15:33:56 <SaMBuCa_> Sorry?
15:34:08 * oerjan means "yes"
15:34:45 <SaMBuCa_> Oh sorry. I mean...i don't know a simply instruction...can u introduce it to me?
15:35:15 <oerjan> you mean a tutorial?
15:35:21 <monochrom> I think he wants urls of simple tutorials.
15:35:28 <omniscientIdiot> @google yaht wikibook
15:35:31 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
15:35:31 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
15:35:51 <monochrom> For function application is a Haskell instruction and is the simplest one to explain :)
15:35:54 <omniscientIdiot> or if you prefer pdfs:
15:35:57 <omniscientIdiot> @where yaht
15:35:57 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
15:36:26 <SaMBuCa_> hmm.
15:37:14 <SaMBuCa_> no, i mean an introduction here in IRC, if it's possible.. :|
15:38:07 <omniscientIdiot> a high-level tour of what the language is like?
15:38:17 <oerjan> @cale :)
15:38:17 <lambdabot> Unknown command, try @list
15:38:45 <monochrom> @wiki Brief introduction
15:38:46 <lambdabot> http://www.haskell.org/haskellwiki/Brief_introduction
15:39:01 <monochrom> err that doesn't exist.
15:39:14 <oerjan> indeed
15:39:36 <monochrom> http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell
15:39:38 <lambdabot> Title: A brief introduction to Haskell - HaskellWiki, http://tinyurl.com/y6cbnf
15:40:04 <monochrom> Anyway, I only have time to give that url.
15:40:51 <oerjan> "One of the youngest children of ML and Lisp"?
15:41:10 <monochrom> they committed adultery :)
15:41:14 <oerjan> isn't haskell getting a bit old to be that?
15:41:15 <SaMBuCa_> lol
15:41:27 <nelhage> I've written a relatively simple parser for a stupid C-like language using Parsec (about 175 lines of code). It takes > 1 minute to compile on my 2Ghz Core 2 Duo with > .5G of RAM free -- is that normal?
15:41:50 <sorear> nelhage: what compiler are you using
15:42:03 <nelhage> ghc 6.6
15:42:04 <sorear> nelhage: for ghc, no.  for jhc, I'm suprised it was that short
15:43:06 <SaMBuCa_> Yesterday night xerox (->user on this chan) tried 2 explain 2 me what are the potentials of haskell
15:49:17 <dbueno> xerox: In the function you defined earlier, what is the mnemonic of the parameter "amb"?
15:52:13 <oerjan> dbueno: it's the action to be repeated
15:52:46 <dbueno> oerjan: Right, I just wondered if there was anything particularly significant about the name "amb".
15:53:56 <SaMBuCa_> xerox isn't there
15:53:59 <SaMBuCa_> :/
15:54:23 <SaMBuCa_> he's sleeping now ^^
15:54:39 <oerjan> @localtime xerox
15:54:41 <lambdabot> Local time for xerox is Mon Oct  1 23:53:34 2007
15:55:06 <SaMBuCa_> what is "localtime" ?
15:55:17 <oerjan> @help localtime
15:55:18 <LoganCapaldo> @help localtime
15:55:18 <lambdabot> time <user>. Print a user's local time. User's client must support ctcp pings.
15:55:18 <lambdabot> time <user>. Print a user's local time. User's client must support ctcp pings.
15:55:29 <SaMBuCa_> uh
15:55:36 <int-e> s/pings/time requests/
15:55:47 * LoganCapaldo must resist urge to mention stereo
15:56:09 <oerjan> @remember LoganCapaldo * LoganCapaldo must resist urge to mention stereo
15:56:09 <lambdabot> Done.
15:56:10 <monochrom> yeah, the new word is surround sound
15:56:20 <int-e> @quote surround
15:56:21 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
15:56:28 <SaMBuCa_> Look:
15:56:33 <SaMBuCa_> @localtime xerox
15:56:35 <lambdabot> Local time for xerox is Mon Oct  1 23:55:28 2007
15:56:41 <SaMBuCa_> @localtime SaMBuCa_
15:56:42 <lambdabot> Local time for SaMBuCa_ is Tue Oct 02 00:55:22 2007
15:56:47 <nelhage> Any ideas how I can debug why my compile is so slow?
15:56:49 <monochrom> You get 7.1 surround sound. Meaning 7 people replies in the channel, and 1 person replies in msg. :)
15:56:52 <omniscientIdiot> geez, how many metastereo quotes are going to be @remembered?  >_>
15:57:16 <oerjan> @remember omniscientIdiot geez, how many metastereo quotes are going to be @remembered?  >_>
15:57:16 <lambdabot> Done.
15:57:17 <SaMBuCa_> why the time isn't the same 4 me and 4 xerox?
15:57:18 <monochrom> that's a metaphysical question :)
15:57:23 * LoganCapaldo must resist urge to @remmeber what omniscientIdiot just said
15:57:25 <omniscientIdiot> I asked for it, didn't I
15:57:31 <oerjan> indeed :)
15:57:41 * LoganCapaldo is too slow
15:57:42 <twanvl> We need enough stereo quotes, so @quote stereo doesn't bring up the original one with a high probability
15:57:57 <monochrom> The original one is erased.
15:58:01 <vincenz> hah
15:58:08 <LoganCapaldo> i thought the original was gone, hence all the metaness about it lately
15:58:09 <newsham> ?remember lambdabot Listen, broccoli brains, I don't have time to listen to this trash.
15:58:09 <lambdabot> Done.
15:58:15 <newsham> ?quote lambdabot
15:58:15 <lambdabot> lambdabot says: I CAN HAS CHEEZBURGER?
15:58:22 <monochrom> Anyway, 5/0 is just as good as 0/0.
15:58:46 <LoganCapaldo> SaMBuCa_: Yu're in different time zones?
15:58:46 <int-e> @quote glorious
15:58:46 <lambdabot> No quotes match. I've seen penguins that can type better than that.
15:58:57 <SaMBuCa_> Xerox lives 15 km far from me, so why the time isn't the same?
15:59:29 <SaMBuCa_> (the time displaed with @localtime)
15:59:30 <LoganCapaldo> you can live 15km from someone and still be in a different timezone
15:59:42 <int-e> SaMBuCa_: maybe his client lies to us all
15:59:46 <SaMBuCa_> O.o
15:59:46 <int-e> SaMBuCa_: or yours
15:59:49 <LoganCapaldo> You can live 15ft from someone and be in a different timezone <g>
15:59:54 <monochrom> you can live in the same bed with someone and still use different ISPs in different time zones.
16:00:09 <SaMBuCa_> my client showed the same as the system clock
16:00:21 <omniscientIdiot> @localtime SaMBuCa_
16:00:22 <lambdabot> Local time for SaMBuCa_ is Tue Oct 02 00:59:02 2007
16:00:26 <geocalc>       @localtime geocalc
16:00:34 <SaMBuCa_> but maybe xerox has his computer in stand-by mode?
16:00:42 <geocalc> @localtime geocalc
16:00:43 <lambdabot> Local time for geocalc is Tue Oct  2 00:56:45
16:00:49 <LoganCapaldo> Maybe xerox beleive in DST and you don't or vice versa?
16:00:53 <vincenz> \o/ Europeans
16:00:54 <monochrom> xerox is in Italy?
16:00:58 <SaMBuCa_> yep
16:01:01 <vincenz> SaMBuCa_ obviously is italian
16:01:01 <SaMBuCa_> and me too ^^
16:01:05 <vincenz> the drink :)
16:01:09 <SaMBuCa_> yeah :D
16:01:16 * vincenz has lived a long long long time in italy
16:01:19 <SaMBuCa_> and the way I wrie in english :D
16:01:22 <SaMBuCa_> *write
16:01:46 <monochrom> Is xerox's computer set in the Italy timezeone?
16:01:52 <SaMBuCa_> uhm...
16:01:59 <SaMBuCa_> this could be the prolem
16:02:01 <oerjan> monochrom: well it is not UTC either...
16:02:16 <LoganCapaldo> xerox has become unstuck in time?
16:02:29 <monochrom> I live in Canada. If I travel to Italy, I may be too lazy to change timezone on my computer.
16:02:47 <monochrom> I may even be too lazy to change my watch, for the hell of it.
16:03:12 * oerjan had to go to the watchmaker to ask how to change his watch today
16:03:19 <SaMBuCa_> xerox's got a program that show different hours in different places...maybe cold be this?
16:03:22 <SaMBuCa_> *could
16:03:35 <LoganCapaldo> that complicated eh oerjan?
16:03:58 <LoganCapaldo> How many little knobbies does it have?
16:04:01 <LoganCapaldo> 4?
16:04:03 <oerjan> LoganCapaldo: it's the first watch i've had with both weekday and date
16:04:11 <oerjan> just 1 knob
16:04:35 * LoganCapaldo tries to remember if his other watch with the broken clasp has weekday and date. 
16:04:37 * LoganCapaldo thinks so
16:04:42 <monochrom> Counterintuitively, but intuitively, fewer knobs <=> harder to use.
16:05:06 <LoganCapaldo> I need to get that fixed
16:05:15 <LoganCapaldo> I'v ebeen putting it off for like enternity
16:05:26 <oerjan> the complication was you change the weekday in the same position as you change the date, but turn the opposite way
16:05:37 <LoganCapaldo> yeah that's confusing
16:06:07 <monochrom> See? If you have 10 knobs, it's easily 1 knob for date, 1 knob for weekday, no problem.
16:06:16 <SaMBuCa_> Do u believe could exist a unique algorith to elaborate a number from a numeric base to another one without passing throu binary?
16:06:24 <SaMBuCa_> *algotithm
16:06:34 <SaMBuCa_> *algorithm -_-'
16:06:45 <monochrom> I don't believe in uniqueness.
16:07:06 <LoganCapaldo> I'm pretty sure that algorithm exists
16:07:07 <Tac-Tics> I could write a program in C that does that and then one in Haskell
16:07:14 <Tac-Tics> that would mean two different algorithms
16:07:20 <SaMBuCa_> Myfrase = Myfrase - "unique". Re-elaborate my sentence pls.
16:07:27 <monochrom> Haha, I actually write one in Haskell first and then I see how to do it in C.
16:07:57 <Tac-Tics> haha, yeah
16:08:05 <Tac-Tics> compile it to C
16:08:06 <monochrom> Good imperative programming is inspired by functional programming.
16:08:07 <Tac-Tics> from hs
16:08:08 <SaMBuCa_> Did u write on paper this algorithm, using only math?
16:08:45 <int-e> monochrom: now imagine you have 182 knobs, one for each date, weekday, hour, minute and second ;)
16:09:17 <oerjan> SaMBuCa_: you just do calculation in the final base
16:09:25 <monochrom> If they are arranged in a very nicely organized manner, I like it.
16:09:43 <SaMBuCa_> (4 all: what's the relation between a number in base B and another one in base b ? And for viceversa?
16:10:03 <oerjan> step 1: realize that a number, by itself, has no base
16:10:03 <SaMBuCa_> oerjan: i don't understand, sorry :/
16:10:21 <SaMBuCa_> Stop.
16:10:28 <SaMBuCa_> Can't realize...how to?
16:10:51 <omniscientIdiot> bases are a consequence of the representation of the number.  They've nothing to do with the number itself.
16:10:53 <monochrom> I highly recommend Jef Raskin's "The Humane Interface" on this issue of, at least, too few buttons ==> harder to use.
16:10:57 <oerjan> a number is a number.  there is no base involved in the definition of a number.
16:11:05 <SaMBuCa_> omniscientIdiot: interesting!
16:11:21 <Tac-Tics> numbers can be represented by lists
16:11:30 <Tac-Tics> [] = 0, [()] = 1, [(), ()] = 2
16:11:35 <int-e> monochrom: yes, but too many buttons can also lead to a lot of confusion.
16:11:39 <SaMBuCa_> s(0) ?
16:11:46 <Tac-Tics> plus would be defined by concatenation of lists
16:11:49 <omniscientIdiot> twelve is still twelve whether it's written 12, 1100, XII, or whatever
16:12:06 <Tac-Tics> > [(), ()] ++ [(), ()]
16:12:08 <lambdabot>  [(),(),(),()]
16:12:12 <Tac-Tics> (2 + 2) = 4
16:12:16 <vincenz> > length [(), (), ()]
16:12:17 <lambdabot>  3
16:12:39 <omniscientIdiot> flip replicate () :: Integer -> ListNum :)
16:12:55 <SaMBuCa_> I have a question: 12 is twelve in base 10! I can realize that....bu it seems isn't true!
16:12:56 <int-e> > let two f x = f (f x) in two two two succ 0
16:12:58 <lambdabot>  16
16:13:12 <int-e> 2^(2^2) = 16
16:13:23 <omniscientIdiot> 1100 is twelve in base 2.  It's still the number twelve.  It represents twelve things.
16:13:30 <vincenz> > [(), (), ()] >> [(), ()]
16:13:31 <lambdabot>  [(),(),(),(),(),()]
16:13:34 <SaMBuCa_> yep
16:13:35 <vincenz> multiplication :)
16:13:45 <allbery_b> what base is XLIV?
16:13:50 <SaMBuCa_> but WHY we use decimals as start?
16:13:56 <allbery_b> 10 fingers
16:14:02 <vincenz> 10 toes
16:14:09 <vincenz> mayans used base 60 afaik
16:14:18 <oerjan> > (.) `join` (.) `join` (.) `join` succ $ 0
16:14:19 <lambdabot>      Occurs check: cannot construct the infinite type:
16:14:19 <lambdabot>       b = b -> t -> t ...
16:14:22 <allbery_b> ...keep in mind that the Babylonians used base 60 and base 120
16:14:27 <oerjan> eek
16:14:27 <omniscientIdiot> (The Riven game uses base 25) :)
16:14:28 <allbery_b> (which is where we got the clock from)
16:14:39 * vincenz thinks better based would be prime numbers
16:14:54 <SaMBuCa_> but these are only conventions!
16:15:02 <allbery_b> exactly
16:15:03 <misterbeebee> http://www.amazon.com/Your-Fingers-Toes-Step-Step/dp/193186814X
16:15:09 <SaMBuCa_> can't u see a number like a smbol, and nothing more?
16:15:13 <SaMBuCa_> *symbol
16:15:53 <oerjan> vincenz: base 20 (with 18 for the second last digit)
16:15:55 <kscaldef> darcs.net down?
16:16:06 <omniscientIdiot> base 10 is only a convention, too.  768 has a seven-hundred-sixty-eight-ness, regardless of how you write it (or what you call it)
16:16:23 <SaMBuCa_> yep
16:16:39 <vincenz> oerjan: hmm?
16:17:06 <oerjan> vincenz: the mayans
16:17:12 <vincenz> oh
16:17:13 <vincenz> thx
16:17:22 <SaMBuCa_> this is the stage i'e arrived in my calculation of an algorithm to pass from a base to another one withous the binary system...(uuuffff....i don't know how to explain.. :( )
16:18:18 <oerjan> SaMBuCa_: do you know how to pass from an arbitrary base to base 10?
16:18:38 <vincenz> oerjan: why the 18 on second last digit? (and second last from which side?)
16:18:48 <SaMBuCa_> arb -> 2 -> 10 ? it's the paper-method i've learned at school :|
16:19:00 <oerjan> vincenz: because 18*20 = 360, approximately a year
16:19:04 <oerjan> iirc
16:19:25 <vincenz> nod
16:19:35 <omniscientIdiot> you could start with a String of digits in one base, read into whatever representation the computer uses, and show into a String of digits in another base.
16:19:40 <oerjan> oh, so you don't know how to avoid binary in that case?
16:19:46 <vincenz> I know they had something based on time, thought it was 60, but indeed, year-based makes more sense since they prolly didn't have minutes bak hten
16:20:04 <kscaldef> when http://www.haskell.org/haskellwiki/Wanted_libraries says "The core HTTP libraries need a lot of work", which core HTTP lib are they talking about?  Network.HTTP isn't considered "core", right?
16:20:05 <lambdabot> Title: Wanted libraries - HaskellWiki
16:20:46 <SaMBuCa_> oeran: sorry, no :/
16:21:00 <SaMBuCa_> *oerjan: sorry, no :/
16:21:03 * edwardk sits here bored waiting for another catsters video =/
16:22:08 <vincenz> :i Num
16:22:10 <oerjan> so if you pass from base 7 to 10, you pass through binary?
16:22:15 <vincenz> @info Num
16:22:16 <lambdabot> (Num)
16:22:22 <oerjan> that's weird...
16:23:33 <oerjan> let's say we have 345 in base 7.
16:23:35 <SaMBuCa_> at school i've learned to use the weight of a digit...
16:23:48 <vincenz> > signum 5
16:23:55 <vincenz> @bot
16:23:55 <lambdabot> :)
16:23:57 <oerjan> then that is (3*7+4)*7+5
16:23:59 <vincenz> > signum 5
16:24:00 <lambdabot>  1
16:24:01 <lambdabot>  1
16:24:18 <vincenz> > signum 0
16:24:19 <lambdabot>  0
16:24:25 <Tac-Tics> > signum (-1)
16:24:27 <lambdabot>  -1
16:25:14 <SaMBuCa_> oerjan: i dont't understand :(
16:25:37 <omniscientIdiot> 768 base 10 = (7*10 + 6)*10 + 8
16:25:45 <SaMBuCa_> O.O
16:26:00 <SaMBuCa_> H YEAH
16:26:03 <SaMBuCa_> OK!
16:26:04 <SaMBuCa_> :D
16:26:06 <SaMBuCa_> sorry
16:26:13 <SaMBuCa_> i'm really n00b.
16:26:25 <SaMBuCa_> be patient pls :/
16:27:06 <SaMBuCa_> ok, then?
16:27:19 <oerjan> in that way you can turn a number in any base into a formula
16:27:29 <vincenz> eh
16:27:31 <vincenz> ok, this is wrong
16:27:41 <vincenz> > take 5 $ iterate (`div` 10) 100
16:27:42 <lambdabot>  [100,10,1,0,0]
16:27:46 <vincenz> > take 5 $ iterate (`div` 10) (-100)
16:27:48 <lambdabot>  [-100,-10,-1,-1,-1]
16:27:50 <vincenz> what's with the repeating -1?
16:27:54 <oerjan> now, if you calculate that formula in the way you are used to, you get the number in base 10
16:28:09 <vincenz> bug!
16:28:13 <oerjan> > divMod (-1) 10
16:28:15 <lambdabot>  (-1,9)
16:28:20 <oerjan> no bug
16:28:37 <vincenz> crud
16:28:52 <newsham> > (-1) `rem` 10
16:28:54 <lambdabot>  -1
16:28:56 <oerjan> you may want quot instead of div
16:28:58 <newsham> > (-1) `mod` 10
16:28:59 <lambdabot>  9
16:29:24 <newsham> oops, misread
16:29:34 <edwardk> > foldl ((+).(10*)) 0 [1,2,3]
16:29:35 <lambdabot>  123
16:29:49 <SaMBuCa_> oerjan: sorry, can't understand your sentence...
16:30:24 <newsham> > (-1) `quot` 10
16:30:26 <lambdabot>  0
16:30:31 <newsham> > 1 `quot` 10
16:30:33 <lambdabot>  0
16:30:46 <EvilTerran> @check \x y -> x `div` y == x `quot` y
16:30:47 <oerjan> SaMBuCa_: if you calculate (3*7+4)*7+5 in the usual base 10 way which you learned in school, you get a number
16:30:47 <lambdabot>  Add a type signature
16:30:51 <EvilTerran> @check \x y -> x `div` y == x `quot` (y::Int)
16:30:52 <lambdabot>  Falsifiable, after 1 tests: -1, 2
16:30:55 <newsham> > iterate (`div` 10) (-100)
16:30:56 <lambdabot>  [-100,-10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,...
16:30:59 <oerjan> > (3*7+4)*7+5
16:31:01 <lambdabot>  180
16:31:03 <newsham> > iterate (`quot` 10) (-100)
16:31:04 <lambdabot>  [-100,-10,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
16:31:27 <oerjan> SaMBuCa_: so that means 345 in base 7 is 180 in base 10
16:31:36 <vincenz> hmm
16:31:38 <EvilTerran> isn't it easier to think about the difference between mod and rem?
16:31:44 <vincenz> why does 'Integral' require 'Real'?
16:31:46 <SaMBuCa_> 180(base 10) rapresents 374(base 7) ?
16:31:47 <vincenz> that is just odd
16:31:53 <SaMBuCa_> omg
16:31:57 <edwardk> > foldl ((+).(7*)) 0 [3,4,5]
16:31:58 <lambdabot>  180
16:32:04 <oerjan> yep
16:32:12 <oerjan> er, no
16:32:17 <SaMBuCa_> so i've lose 3 entire days serachin' 4 something already exist?
16:32:18 <oerjan> , 345 (base 7)
16:32:20 <SaMBuCa_> good -.-'
16:32:42 <edwardk> 374 isn't a base 7 number =) there are digits with value n in base n
16:32:55 <edwardk> er aren't
16:33:00 <SaMBuCa_> (yeah sorry misread)
16:33:29 <SaMBuCa_> ahahah looool so 've loss all this time 4 nothing. Really n00b -_-'
16:34:05 <SaMBuCa_> please say me i'm n00b so i can believe this is reality.
16:34:35 <oerjan> SaMBuCa_: unless you have a university education in mathematics, or have at least done maths for a long time, chances are _everything_ you can think of has already been thought of by somebody else
16:35:06 <omniscientIdiot> If you haven't been taught bases there's not much reason to expect you to understand them :)
16:35:32 <edwardk> having the university education in mathematics or computer science just helps you learn how much more of what you think is cool and new has been done before - probably by someone named Wadler ;)
16:35:37 <SaMBuCa_> i'm sorry 2 make u waste ur time with me.. :|
16:38:26 <vincenz> why does Integral require Real?
16:38:39 <oerjan> SaMBuCa_: no problem
16:38:44 <oerjan> @src Integral
16:38:44 <lambdabot> class  (Real a, Enum a) => Integral a  where
16:38:44 <lambdabot>     quot, rem, div, mod :: a -> a -> a
16:38:44 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
16:38:44 <lambdabot>     toInteger           :: a -> Integer
16:39:06 <oerjan> @src Real
16:39:06 <lambdabot> class  (Num a, Ord a) => Real a  where
16:39:07 <lambdabot>     toRational      ::  a -> Rational
16:39:08 <SaMBuCa_> before knowing all that u tell me now, my mind elaborated a way to see relations between different bases as "loops"
16:39:39 <oerjan> vincenz: for one thing, toRational is obvious once you have toInteger
16:40:36 <vincenz> how so?
16:41:01 <vincenz> Perhaps the choice of the name 'Real' is what put me off
16:41:06 <vincenz> And what you're saying
16:41:08 <vincenz> it should be more like
16:41:11 <oerjan> @check \x -> (toRational . toInteger) x == toRational (x::Int)
16:41:15 <vincenz> (Integral a) => (Real a)
16:41:22 <lambdabot>  OK, passed 500 tests.
16:41:37 <SaMBuCa_> do u think i need more edu in maths before learning haskell?
16:41:58 <oerjan> vincenz: um, that would mean _every_ real type consisted only of integers
16:42:04 <vincenz> point
16:42:14 <vincenz> ok, maybe I thought Real represented more
16:42:18 <vincenz> it's more a poor choice of 'real
16:42:23 <vincenz> (like division for isntance)
16:42:44 <oerjan> vincenz: Real is a poor choice of name, i think most people agree
16:43:03 <oerjan> it really means subset of the rationals
16:43:42 <oerjan> and Integral intuitively means subset of the Integers (although overflow behavior may differ)
16:44:19 <gigamonkey_> Any word on when the content of Real World Haskell is going to be visible to the public?
16:44:48 <LoganCapaldo> Can you preorder real world haskell yet?
16:45:46 <vincenz> gigamonkey_: eh?
16:46:32 <vincenz> There's a book on real world haskell coming out?
16:46:41 <gigamonkey_> vincenz: the folks at http://www.realworldhaskell.org/blog/
16:46:43 <lambdabot> Title: Real World Haskell
16:46:49 <vincenz> Thank you for the link
16:47:07 <vincenz> Oh right, O'sullivan.  Completely forgot about that
16:47:55 <EvilRanter> hm.
16:48:31 <oerjan> EvilTerran: darn, i was going to comment on the nick similarity :D
16:49:11 <EvilTerran> 't's ananananagram
16:49:59 <LoganCapaldo> It's time for anangramaniacs, and they're zany to the max
16:50:13 <EvilTerran> aaaaaargh earworm!
16:51:51 <SaMBuCa_> what's the syntax for "successor" function?
16:51:58 <vincenz> > succ 3
16:51:59 <lambdabot>  4
16:52:03 <SaMBuCa_> tnx ^
16:52:22 <LoganCapaldo> @hoogle (Enum a) => a -> a
16:52:23 <lambdabot> Prelude.pred :: Enum a => a -> a
16:52:23 <lambdabot> Prelude.succ :: Enum a => a -> a
16:52:23 <lambdabot> Prelude.id :: a -> a
16:52:34 <EvilTerran> (+1) works, too...
16:52:45 <EvilTerran> (depending on what you're up to)
16:52:47 <vincenz> EvilTerran: not always
16:52:48 <LoganCapaldo> > succ EQ
16:52:48 <SaMBuCa_> > (+1)
16:52:50 <lambdabot>  GT
16:52:51 <lambdabot>  <Integer -> Integer>
16:52:57 <SaMBuCa_> GT?
16:53:01 <LoganCapaldo> > (+1) EQ
16:53:02 <lambdabot>   add an instance declaration for (Num Ordering)
16:53:02 <lambdabot>     In the expression: (+ 1)...
16:53:03 <EvilTerran> @src GT
16:53:03 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:53:12 <EvilTerran> data Ordering = LT | EQ | GT
16:53:21 <LoganCapaldo> @src Ordering
16:53:21 <lambdabot> data Ordering = LT | EQ | GT
16:53:34 <SaMBuCa_> ?_?
16:53:34 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
16:53:53 <EvilTerran> @src compare
16:53:54 <lambdabot> compare x y | x == y    = EQ
16:53:54 <lambdabot>             | x <= y    = LT
16:53:54 <lambdabot>             | otherwise = GT
16:54:07 <SaMBuCa_> tnx ^^
16:54:18 <LoganCapaldo> @type toEnum . (+1) . fromEnum
16:54:20 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
16:54:25 <EvilTerran> amusingly, there's an instance Ord Ordering :D
16:54:47 <vincenz> which makes sense
16:54:52 <nelhage> Can I persuade cabal not to build things with -O ?
16:54:59 <EvilTerran> > (1 `compare` 2) `compare` (2 `compare` 1)
16:55:00 <lambdabot>  LT
16:55:08 <vincenz> here's a simple example
16:55:09 <LoganCapaldo> No, but I think it takes bribes
16:55:13 <newsham> > EQ < LT
16:55:15 <lambdabot>  False
16:55:25 <vincenz> > compare' (a,b) (c,d) = compare (compare a c) (compare b d)
16:55:25 <lambdabot>  Parse error
16:55:34 <vincenz> > let compare' (a,b) (c,d) = compare (compare a c) (compare b d) in compare' (1,2) (1,3)
16:55:36 <lambdabot>  GT
16:55:38 <LoganCapaldo> vincenz: clever
16:55:42 <vincenz> welcome to lexicographic ordering
16:56:02 <EvilTerran> isn't there an instance (Ord a, Ord b) => Ord (a,b) for that?
16:56:15 <vincenz> > let compare' l1 l2 = foldr compare EQ (zip compare l1 l2) in compare1 [1,2,3] [1,2,4]
16:56:16 <lambdabot>   Not in scope: `compare1'
16:56:19 <LoganCapaldo> yeah but you still have to write the instance
16:56:19 <vincenz> > let compare' l1 l2 = foldr compare EQ (zip compare l1 l2) in compare' [1,2,3] [1,2,4]
16:56:20 <lambdabot>  Couldn't match expected type `[a]'
16:56:20 <newsham> i thinmk he ws demonstrating how its done, et
16:56:34 <vincenz> > let compare' l1 l2 = foldr compare EQ (zipWith compare l1 l2) in compare' [1,2,3] [1,2,4]
16:56:35 <lambdabot>  LT
16:56:43 <oerjan> @src (,) Ord
16:56:43 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:56:45 <EvilTerran> cunning
16:56:47 <vincenz> again, legicographic ordering
16:57:06 <SaMBuCa_> oerjan: returning to bases (sorry 4 that -_-) do u think that is possible to interpretate a number in base N as a number in base N of base N2 ?
16:57:18 <EvilTerran> although the zipWith version will bork on lists of different lengths
16:57:26 <LoganCapaldo> will it?
16:57:31 <vincenz> > compare [1,2,3] [1,2,3,4]
16:57:33 <lambdabot>  LT
16:57:36 <vincenz> > let compare' l1 l2 = foldr compare EQ (zipWith compare l1 l2) in compare' [1,2,3] [1,2,3,4]
16:57:37 <lambdabot>  EQ
16:57:38 <EvilTerran> let compare' l1 l2 = foldr compare EQ (zipWith compare l1 l2) in compare' [1,2,3] [1,2,3,4]
16:57:40 <vincenz> yep
16:57:42 <EvilTerran> heh
16:57:51 <oerjan> SaMBuCa_: i don't understand the question
16:57:53 <vincenz> can be easily fixed
16:57:53 <EvilTerran> i missed the '>' =/
16:57:56 <vincenz> here is the fix
16:58:05 <vincenz> though it's ot safe for infilists
16:58:10 <EvilTerran> @src [] compare
16:58:10 <lambdabot> Source not found. I feel much better now.
16:58:18 <vincenz> > let compare' l1 l2 = foldr compare (compare (length l1) (length l2)) (zipWith compare l1 l2) in compare' [1,2,3] [1,2,3,4]
16:58:19 <lambdabot>  GT
16:58:25 <Pseudonym> @src [] Ord
16:58:25 <LoganCapaldo> well compare aint safe for inf lists period no?
16:58:26 <lambdabot> Source not found. Where did you learn to type?
16:58:27 <vincenz> > let compare' l1 l2 = foldr compare (compare (length l2) (length l1)) (zipWith compare l1 l2) in compare' [1,2,3] [1,2,3,4]
16:58:29 <lambdabot>  LT
16:58:37 <EvilTerran> hmm
16:58:40 <vincenz> though obviously, this isn't a dececnt implementation
16:58:57 <SaMBuCa_> oerjan: sorry :| i'll retry: how ca i rapresent in this "chat" a number whit his base (graphically)
16:59:17 <SaMBuCa_> ?
16:59:21 <vincenz> that's odd
16:59:25 * EvilTerran would like a zipAllWith (a -> b -> c) -> ([a] -> [c]) -> ([b] -> [c]) -> [a] -> [b] -> [c]
16:59:30 <vincenz> o.O
16:59:50 <vincenz> > compare 4 3
16:59:51 <lambdabot>  GT
16:59:55 <vincenz> o.O
17:00:00 <vincenz> why did it require me to put l2 first?
17:00:11 <vincenz> oh, duh
17:00:13 <vincenz> foldr
17:00:18 <oerjan> SaMBuCa_: i think it is common to write the base as an index at the end, in irc you could use _, so 345_7 = 180_10
17:00:21 <vincenz> > EQ `compare` GT
17:00:22 <lambdabot>  LT
17:00:44 <EvilTerran> zipAllWith f g h (x:xs) (y:ys) = f x y : zipAllWith f g h xs ys; zipAllWith f g h xs [] = g xs; zipAllWith f g h [] ys = h ys; -- kinda thing
17:01:01 <LoganCapaldo> EvilTerran: maybe I'm missing something but why wouldn't the type be (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c] ?
17:01:49 <EvilTerran> mine's more general, i think. the output elements after one list runs out don't have to be in 1-1 correspondence with the tail of the other input
17:02:00 <EvilTerran> alternatively, that could be a good requirement to have. meh.
17:02:11 <LoganCapaldo> I dunno
17:02:15 <SaMBuCa_> oerjan: thanks ^^ so, where N is any number and b is his base, is it possible to write N_b_b(b) ?
17:02:28 <LoganCapaldo> [a] -> [c] feels so general I feel like I'm doing all the work anyway :)
17:02:33 <SaMBuCa_> Base-of-base--of-number, i mean..
17:04:00 <EvilTerran> it only adds a map, if that's what you want...
17:04:01 <oerjan> SaMBuCa_: not really that way
17:04:16 <oerjan> because N is a numeral, not a number
17:04:18 <EvilTerran> and it makes it possible to write normal zip(With) as instances of it
17:04:37 <LoganCapaldo> yeah I see what you mean
17:04:41 <oerjan> N_b is the number, but it is not a numeral so you cannot add more indices to it
17:04:50 <EvilTerran> zipWith f = zipAllWith f (const []) (const []) -- no way of doing the same thing with the less general one
17:05:04 <SaMBuCa_> oerjan: thanks, understood ^^
17:05:11 <EvilTerran> as you said, though, more general => more work to use. that's kinda what i meant by <EvilTerran> alternatively, that could be a good requirement to have. meh.
17:05:18 <LoganCapaldo> [a] -> [c] makes more sense if you reat zipWithAll as a pritiive from which to build zipWith, etc.
17:05:52 <oerjan> SaMBuCa_: however i think what you mean has been done
17:05:57 <EvilTerran> (a -> c) -> (b -> c) -> fits the name better, though
17:06:36 <SaMBuCa_> oerjan: yeah i suppose too..
17:07:37 <SaMBuCa_> and now a very difficult question about irc: how to change background and text color?
17:07:47 <oerjan> SaMBuCa_: look at          original question :P
17:07:47 <oerjan> 02:04  GregorR> s/asking/answering/ >_O
17:08:03 <oerjan> (argh, bad cut and paste)
17:08:15 <oerjan> http://en.wikipedia.org/wiki/Goodstein%27s_theorem
17:08:17 <lambdabot> Title: Goodstein's theorem - Wikipedia, the free encyclopedia
17:08:24 <oerjan> (that's a use of changing base)
17:08:44 <allbery_b> <SaMBuCa_> and now a very difficult question about irc: how to change background and text color?
17:08:48 <allbery_b> depends on your client
17:09:40 <SaMBuCa_> allbery_b: i have base mIRC
17:09:46 <SaMBuCa_> for win
17:10:21 <SaMBuCa_> oerjan: thanks for the link ;P
17:10:39 <LoganCapaldo> just because allbery_b says it depends on your client doesn't mean he knows the details of all IRC clients :)
17:11:04 <SaMBuCa_> ooh. Sorry :(
17:11:38 <LoganCapaldo> No need to be sorry, I just don't want you to get your hopes up
17:11:49 <LoganCapaldo> Maybe he does
17:12:19 <LoganCapaldo> @go mirc change background color text color
17:12:22 <lambdabot> http://www.mirc.co.uk/help/color.txt
17:12:39 <SaMBuCa_> I have to wake up, the answer could be find by searchin in the client website i think, not by stealing u time 2 answer stupid questions -_-'
17:12:55 <SaMBuCa_> ops..too slow in writing..
17:13:10 <SaMBuCa_> anyway, thanks..
17:13:29 <SaMBuCa_> i feel useless.
17:13:46 <allbery_b> I don't use windows, sorry, so can't help with mIRC
17:14:06 <allbery_b> I generally use xchat (gui) or bitchx (text) on unixy systems
17:14:40 <EvilTerran> > "xchat" > "mirc"
17:14:41 <lambdabot>  True
17:14:43 <EvilTerran> :D
17:14:50 <allbery_b> my point was more that, without knowing what client, we have no idea how to answer or where to point you
17:14:58 <allbery_b> xchat exists for windows :)
17:15:06 <EvilTerran> @go silverex
17:15:08 * allbery_b has actually used ti, when visiting his sister
17:15:10 <lambdabot> http://www.silverex.org/
17:15:10 <lambdabot> Title: X-Chat 2 for Windows
17:15:22 <SaMBuCa_> allbery_b: as LoganCapaldo said, not to be sorry, especially with me :)
17:15:48 <SaMBuCa_> it's not easy to find people like u.
17:16:49 <allbery_b> hm?  whole channel full of people as helpful and (generally) smarter than me :)
17:17:46 <SaMBuCa_> yep, in irc.
17:18:04 <int-e> @users
17:18:04 <lambdabot> Maximum users seen in #haskell: 420, currently: 358 (85.2%), active: 15 (4.2%)
17:18:29 <SaMBuCa_> Considering the whole world, u're (unfortunately) a minorance.. :/
17:19:14 <int-e> minority
17:19:22 <SaMBuCa_> sorry, minority.
17:20:54 <vincenz> minorance = minority ignorance
17:21:02 <SaMBuCa_> omg :D
17:21:23 <SaMBuCa_> i'm really sorry, the 2nd word indicates me :D
17:21:35 * vincenz was just joking
17:22:07 * SaMBuCa_ is feeling stupid.
17:22:27 <omniscientIdiot> @wn ignorance
17:22:29 <lambdabot> *** "ignorance" wn "WordNet (r) 2.0"
17:22:29 <lambdabot> ignorance
17:22:29 <lambdabot>      n : the lack of knowledge or education
17:22:31 <vincenz> that's good, that happens to me often as well, that means you're learning :)
17:23:06 * SaMBuCa_ is feeling happy considering words from vincenz :)
17:23:20 <allbery_b> one gets that "feeling stupid" a lot with haskell
17:23:40 <Tac-Tics> Haskell is the language of the humble
17:23:47 <oerjan> @quote stupid
17:23:47 <lambdabot> EvilRanter says: I went off scheme, because the fundemental keywords of the language had stupid names
17:23:54 <oerjan> @quote stupid
17:23:55 <lambdabot> tizoc says: <tizoc> es una mierda, es feo y estupido, como pingondga
17:24:00 <LoganCapaldo> Hmm
17:24:04 <Tac-Tics> It's also the language of the people who like to make jokes about Monads
17:24:05 <dv____> hello
17:24:09 <LoganCapaldo> I don't get the feeling stupid vibe so much from haskell
17:24:28 <LoganCapaldo> I get the "wow these other people are waaaaaay smarter than me vibe" from Haskell
17:24:28 <oerjan> @quote stupid
17:24:28 <lambdabot> EvilRanter says: I went off scheme, because the fundemental keywords of the language had stupid names
17:24:35 <dv____> I noticed there is hopengl and hugs glut
17:24:39 <dv____> which one is recommended?
17:24:41 <dv____> is one obsolete?
17:24:46 <LoganCapaldo> I tend to feel stupid more around "lesser" languages
17:24:46 <Tac-Tics> hehe
17:24:55 <Tac-Tics> call-with-concurrent-continuation ftl
17:24:59 <LoganCapaldo> Like "I forget to free that pointer!"
17:25:03 <Pseudonym> You have to be REALLY smart to think down to their level, right Logan?:
17:25:22 <LoganCapaldo> Pseudonym: lol something like that
17:25:26 <int-e> I dumbed myself down. Then I felt stupid.
17:25:34 <int-e> or something like that.
17:26:22 <dv____> cause in debian I see only hugs packages, but many tutorials are about hopengl
17:26:26 <oerjan> Tac-Tics: _con_current? that might be awkward, yes.
17:26:46 <Tac-Tics> hehe
17:26:48 <Tac-Tics> oops
17:27:05 <Tac-Tics> though I don't know how much more awkward you can be with the darned things
17:27:26 <EvilTerran> lack of enforced purity FTL
17:27:28 <int-e> you could add nondeterminism and side-effects
17:27:51 <SaMBuCa_> I have to go to bed now...but i'm really grate for what u all teach me tonight..so i have do make a present for u!
17:27:51 <EvilTerran> (my comments in @quote FTW, mind. shame i was under the wrong nick at the time)
17:28:07 <SaMBuCa_> Because in haskell chan u teach me maths and english :D
17:28:36 <SaMBuCa_> So choose your present and i'll do my best to make it real ^^
17:28:46 <newsham> hookers and blow?
17:29:09 <omniscientIdiot> one hundred thousand dollars.
17:29:10 <vincenz> a bottle of sambuca
17:29:20 <EvilTerran> a good record system
17:29:28 <SaMBuCa_> Vincenz's idea is more possible :D
17:29:37 <omniscientIdiot> EvilTerran: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
17:29:40 <newsham> yes, I second that.  sections for record settors.
17:29:41 <dv_> hello?
17:29:42 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
17:30:11 <SaMBuCa_> lol, i've found the way to wake up all the channel.
17:30:31 <EvilTerran> hmm
17:30:32 <SaMBuCa_> PrEsEnTs 4 aLL!
17:30:37 <oerjan> bribes will get you everywhere
17:30:47 <omniscientIdiot> @. elite keal
17:30:47 <lambdabot> (An h4zKell c0/\/\PI|e F1ash aNiM4tIONz aNd Java 4Pps?
17:30:50 <vincenz> especially in bed with a politician
17:30:55 <LoganCapaldo> @remember newsham hookers and blow?
17:30:55 <lambdabot> Done.
17:31:05 <LoganCapaldo> I think it's funnier out of context
17:31:06 * omniscientIdiot high-fives LoganCapaldo 
17:31:52 <newsham> hookers and blow are always funny
17:32:15 <vincenz> what is 'blow'?
17:32:15 <vincenz> coke?
17:32:16 <tankgirl> yah
17:32:16 * vincenz peers at 'tankgirl'
17:32:16 <SaMBuCa_> i won't be in a bed with a politician
17:32:16 <SaMBuCa_> especially here in italy -_-'
17:32:21 <tankgirl> dont know much about haskell, just hookers and blow
17:32:49 <Pseudonym> "Fine, I'll go build my own lunar lander!"
17:32:51 <newsham> vincenz: http://www.nypost.com/seven/09302007/news/regionalnews/ex_is_hit_with_100g_sin_tax.htm
17:32:55 <lambdabot> Title: EX IS HIT WITH 100G &#39;SIN TAX&#39;, http://tinyurl.com/2f8vre
17:32:59 <vincenz> 100g syntax?
17:33:22 <Pseudonym> 100G is a lot of accelleration.
17:33:22 <newsham> different syntax/sin tax
17:33:56 <Pseudonym> And 100 grams is a lot of... never mind.
17:34:33 <dv_> indeed
17:34:35 <SaMBuCa_> bye bye, good night to u all ^^
17:34:35 <LoganCapaldo> when you use too much syntactic sugar you have to pay the syn tax
17:34:53 * omniscientIdiot groans
17:35:00 <Pseudonym> "Syntactic sugar" sounds like a euphemism for coke.
17:37:59 <Pseudonym> OK, I think we just killed the conversation.
17:38:01 <Pseudonym> So how about that Haskell, then?
17:38:09 <Pseudonym> Jolly good programming language, if you ask me.
17:39:09 <omniscientIdiot> Right-o, good boy.  Jolly good.
17:41:04 <omniscientIdiot> mother of netsplits!
17:41:04 <allbery_b> meep?!
17:41:38 <omniscientIdiot> LB!!! NO!!!!!
17:41:38 <merus> Oh man, #haskell hasn't been this empty since 1998.
17:41:38 <omniscientIdiot> @users
17:41:41 <lambdabot> Maximum users seen in #haskell: 420, currently: 63 (15.0%), active: 2 (3.2%)
17:42:33 <omniscientIdiot> gawd
17:42:34 --- mode: irc.freenode.net set +o ChanServ
17:42:42 <Pseudonym> My head is still spinning.
17:42:42 <Pseudonym> ?users
17:42:48 <waern_> what's the standard way of replacing elements in a list... i.e filter, but with a supplied replacement argument
17:42:48 <newsham> sambuca: have you looked at "two dozen short lessons"?
17:42:48 <newsham> it covers that
17:42:48 <misterbeebee> and we're back!
17:42:48 <omniscientIdiot> can mommy make the bad man go away?
17:42:48 <waern_> or actually, filter (==x) xs, replacing with y
17:42:48 <waern_> there's no such standard list function it seems
17:42:49 <waern_> replace 'a' 'b' "abc" = "bbc"
17:42:49 <lambdabot> Maximum users seen in #haskell: 420, currently: 358 (85.2%), active: 3 (0.8%)
17:42:49 <SaMBuCa_> newsham: no, what's that?
17:42:49 <newsham> waern: map?
17:42:49 <lament> :t replace
17:42:52 <lament> er ;)
17:42:53 <lambdabot> Not in scope: `replace'
17:43:00 <newsham> sambuca: http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml
17:43:05 <dibblego> waern_, map
17:43:05 <lambdabot> Title: Two Dozen Short Lessons in Haskell, http://tinyurl.com/hl9mm
17:43:13 <omniscientIdiot> map (\x -> if x == 'a' then 'b' else x)
17:43:30 <SaMBuCa_> oerjan: so it's not possible to pass from a base X to a base Y without converting the first to base 10 and then to base Y ?
17:43:30 <dons> > 1+2
17:43:30 <lambdabot>  3
17:43:48 <newsham> ?pl \x -> if x == 'a' then 'b' else x
17:43:49 <vincenz> @bot
17:43:50 <SaMBuCa_> newsham: thanks ^^
17:43:50 <lambdabot> flip if' 'b' =<< ('a' ==)
17:43:50 <lambdabot> :)
17:44:39 <oerjan> SaMBuCa_: of course there is.  note that the formula is _not_ base 10 - it is completely independent of base
17:45:16 <newsham> sambuca: a number is a number.  bases only come into play when you try to write them down or represent them.
17:46:32 <oerjan> but to get from the formula to a special base, you have to know how to calculate in that base.
17:46:32 <dibblego> > let f = 1 in f
17:46:32 <oerjan> for base 10 that is easy - you learned that in school.
17:46:32 <SaMBuCa_> uhm
17:46:32 <newsham> and oct 31 = dec 25
17:46:32 <lambdabot>  1
17:46:32 <oerjan> for any other base, you have to know how to modify the way you calculate, to use a different base.  that is, if you really want to avoid passing through base 10.
17:46:32 <SaMBuCa_> i think that's impossible we have to change our way of calculation dpending on the base considered.
17:47:01 <SaMBuCa_> I'll continue workng n my algorithm :)
17:47:07 <SaMBuCa_> *on
17:47:09 <oerjan> yes, but that is not impossible.  you can calculate in any base,  10 is arbitrary
17:48:57 <oerjan> could someone @flush lambdabot?
17:49:07 <Tac-Tics> @flush
17:49:07 <lambdabot> Not enough privileges
17:49:10 * oerjan is a bit paranoid
17:49:20 <Tac-Tics> what does flush do?
17:49:31 <oerjan> it saves lambdabot's state
17:49:32 <SaMBuCa_> you said that "for any other base, you have to know how to modify the way you calculate", so avoiding arbitrary base and commons for all the oter possibly bases (that are infinites?) we have to change our way to calculate?
17:49:35 <Pseudonym> ?flush
17:49:47 <Pseudonym> Did that work/
17:49:50 <Pseudonym> ?botsnack
17:49:50 <lambdabot> :)
17:49:53 <Pseudonym> Guess so.
17:49:58 <newsham> 251 is prime no matter if you write it "251", 0xfb, or 0373
17:50:29 <xelxebar> does anyone know of a way to deal with numbers independent of base?
17:50:32 <oerjan> SaMBuCa_: yes.  but of course it is simpler in practice to use some common base to pass through.
17:50:49 <newsham> sambuca: if you calculate in another base, for example multiply 6 x 2 in bsae 10 you get "2 carry 1"
17:50:51 <xelxebar> e.g. independent of their representation
17:50:57 <newsham> but if you did "6 x 2" in hexademical you'd get "c"w with no carry
17:51:15 <newsham> thats an example of how you have to adjust your calculations
17:51:19 <oerjan> ?flush
17:51:19 <lambdabot> Not enough privileges
17:51:21 <dmwit> In fact, it's prime even if you write 0x251.  (Just a coincidence, though.)
17:51:24 <SaMBuCa_> oerjan: it's simpler until there will be an algorithm valid for all the possibly bases (that are infinite). So it will be a "full-valid" algorithm..?
17:51:42 <dmwit> xelxebar: Church numerals?
17:52:10 <EvilTerran> o/` peah peah peano! o/`
17:52:26 <dmwit> Yes!  Base 1!
17:52:45 <oerjan> SaMBuCa_: well, binary is usually simpler regardless.  that's why computers use it.
17:52:57 <SaMBuCa_> newsham: understood, now i have to find some kind of rule for that..
17:53:31 <Tac-Tics> @let peano 0 = []; peano n = () : peano (n - 1)
17:53:35 <lambdabot> Defined.
17:53:37 <Tac-Tics> > peano 3
17:53:38 <lambdabot>  [(),(),()]
17:53:55 <Tac-Tics> @let s n = () : peano n
17:53:57 <dmwit> > repeat 3 ()
17:53:59 <lambdabot> Defined.
17:53:59 <lambdabot>  Couldn't match expected type `() -> t' against inferred type `[t1]'
17:54:05 <dmwit> > replicate 3 ()
17:54:06 <lambdabot>  [(),(),()]
17:54:08 <xelxebar> church numerals are still just a representation
17:54:29 <waern_> dibblego: haha. duh. *tired*
17:54:39 <dibblego> waern_, foldr too :)
17:54:51 <waern_> I think it's time to go to bed now.
17:54:54 <dibblego> waern_, i.e. a generalisation of both map and filter
17:54:54 <dmwit> xelxebar: Maybe you should make your question slightly more precise.
17:54:56 <Tac-Tics> @let s :: [()] -> [()]; s n = () : n
17:54:56 <dibblego> waern_, indeed :)
17:54:56 <lambdabot> <local>:13:19:     Multiple declarations of `L.s'     Declared at: <local>:12...
17:55:01 <waern_> dibblego: I know
17:55:01 <SaMBuCa_> oerjan: that's true.
17:55:08 <Tac-Tics> @let suc n = () : n
17:55:12 <lambdabot> Defined.
17:55:14 <vincenz> > let x *** y = length $ replicate x () >> replicate y () in 5 ** 10
17:55:15 <lambdabot>  9765625.0
17:55:16 <vincenz> > let x *** y = length $ replicate x () >> replicate y () in 5 *** 10
17:55:17 <lambdabot>  50
17:55:21 <Tac-Tics> > peano 0
17:55:22 <lambdabot>  []
17:55:29 <Tac-Tics> > suc $ peano 0
17:55:31 <lambdabot>  [()]
17:55:44 <Tac-Tics> @let pzero = peano 0
17:55:48 <lambdabot> Defined.
17:55:49 <vincenz> @let pmult = (>>)
17:55:50 <lambdabot> <local>:15:8:     Ambiguous type variable `m' in the constraint:       `Monad...
17:55:51 <SaMBuCa_> orejan: maybe finding this algorithm (not me, i'm doing this little stupid reserach only 4 fun) could open more doors to informatics?
17:56:11 <EvilTerran> dreaded monomorphism?
17:56:18 <vincenz> @let pmult (a :: [()]) (b :: [()]) = a >> b
17:56:18 <lambdabot>  Parse error in pattern
17:56:18 <xelxebar> dmwit: I'm not exactly sure how to be more precise.  How could one perform numeric tranformations/calulations whilst circumventing representation
17:56:27 <vincenz> wtf
17:56:31 <EvilTerran> abstractions!
17:56:59 <EvilTerran> @let pmult :: [()] -> [()] -> [()]; pmult = (>>)
17:57:04 <lambdabot> Defined.
17:57:19 <vincenz> oooh
17:57:27 <vincenz> > pmult (peano 4) (peano 10)
17:57:28 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
17:57:37 <vincenz> @let pshow = length
17:57:41 <lambdabot> Defined.
17:57:42 <EvilTerran> i think types-in-patterns is an extension
17:57:46 <vincenz> > pshow $ pmult (peano 4) (peano 10)
17:57:47 <lambdabot>  40
17:57:56 <newsham> sambuca: rule is simple.  take digit*digit divMod your base.
17:58:04 <newsham> > (6*2) `divMod` 10
17:58:05 <lambdabot>  (1,2)
17:58:13 <EvilTerran> either that or it's not supported by Language.Haskell for whatever other reason
17:58:13 <SaMBuCa_> newsham: u speak arabian :D
17:58:14 <newsham> 6*2 = 2 carry the 1
17:58:17 <oerjan> SaMBuCa_: i think the algorithm for doing arithmetic in any base is well known.
17:58:41 <newsham> wow, I dont even know arabian
17:58:57 <oerjan> a problem is that you always are going to need some common representation for the _digits_, even if you vary the base
17:59:35 <newsham> data BasedNum = BasedNum [Int]
17:59:44 <vincenz> newsham: it should be
17:59:51 <vincenz> data Number a = Number a [a]
17:59:54 <vincenz> where the first a is the base
17:59:58 <vincenz> I was workng on that priorly
18:00:00 <vincenz> @hpaste
18:00:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:00:04 <oerjan> newsham: that will still be binary for the digits under the hood
18:00:06 <newsham> vinc: yah, better.
18:00:27 <hpaste>  vincenz pasted "Number" at http://hpaste.org/3025
18:00:37 <newsham> oerjan: you can use the Int as an abstract data type and do the math for the legs of your number.
18:00:45 <vincenz> nt sure if I agree with how I do signs
18:00:48 <vincenz> maybe a bool would be better
18:01:08 <newsham> vincenz: "haskell road to maths" did Z by using a pair of (N, N)
18:01:41 <newsham> where the semantic is (x,y) represents the number x less y
18:01:50 <vincenz> x less y?
18:01:56 <newsham> and (a,b) == (c,d) if a+d == b+c
18:01:58 <vincenz> you mean (x-y)?
18:02:12 <newsham> yah, except not the subtract from N
18:02:20 <vincenz> well no
18:02:21 <vincenz> more like
18:02:27 <vincenz> fromIntegral x - fromIntegral y
18:02:31 <SaMBuCa_> oerjan: what a stupid thing...we can invent all thwt we want but we have to choose only one thing cause we need common agree..
18:02:55 <hpaste>  ramza3 pasted "(no title)" at http://hpaste.org/3026
18:03:29 <ramza3> I am trying to understand data types, how would you describe the syntax in that post.  I couldn't find the !(...) part in any docs
18:03:46 <vincenz> newsham: feel like golfing the end to get it finished?
18:04:01 <dibblego> ramza3, it's called a strictness annotation
18:04:06 <vincenz> notice how I kept the places where negatives are defined to a minimum
18:04:08 <vincenz> namely signum and negate
18:04:11 <newsham> EPARSE.  golfing?
18:04:12 <dmwit> > let mapping x = (x+1) `div` 2 * if even x then 1 else -1 in map mapping [0..]
18:04:13 <lambdabot>  [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13,...
18:04:35 <ramza3> dibblego, ok, googling now
18:04:36 <Cale> ramza3: It's a strictness annotation -- it basically means that if the Camera is evaluated, then so will those triples (though not necessarily their components, strangely enough)
18:04:42 <vincenz> newsham: yes, as in collab online by bouncing ideas
18:05:09 <vincenz> Cale: thoughts on the repr of negative numbers?
18:05:09 <newsham> haskell-road-to-maths signed nubmers are here, btw: http://www.cwi.nl/~jve/rcrh/WWN.hs  see NatPair
18:05:33 <newsham> vincenz: sounds like fun, but I'm supposed to be working at the moment :\
18:05:36 <vincenz> ok
18:06:12 <SaMBuCa_> @localtime newsham
18:06:13 <Cale> vincenz: I like the pair of nats -- it's elegant, but it's not a bijective representation of course. Storing a pair of a boolean and a nat is perhaps more efficient.
18:06:18 <newsham> Mon Oct  1 15:03:28 HST 2007
18:06:19 <dibblego> ?where strictness
18:06:19 <lambdabot> I know nothing about strictness.
18:06:21 <vincenz> Cale: this was to represent based-numbers
18:06:25 <vincenz> Cale: so hence a list of integers
18:06:26 <vincenz> aka
18:06:32 <dibblego> ?where+ strictness http://en.wikibooks.org/wiki/Haskell/Strictness
18:06:32 <lambdabot> Done.
18:06:39 <dibblego> ramza3, http://en.wikibooks.org/wiki/Haskell/Strictness
18:06:40 <lambdabot> Title: Haskell/Strictness - Wikibooks, collection of open-content textbooks
18:06:40 <vincenz> 130 in base 13 = [0, 10]
18:07:05 <vincenz> 131 in base 13 = [1,10]
18:07:11 <vincenz> -131 in base 13 = [-1, -10]
18:07:38 <SaMBuCa_> @localtime SaMBuCa_
18:07:43 <Cale> Um, that page is a little unclear, I think.
18:08:01 <vincenz> Cale: which?
18:08:02 <newsham> why not stick to natural numbers and then build support for negative numbers at a higher layer?
18:08:10 <Cale> vincenz: the Strictness page
18:08:27 <vincenz> newsham: natural numbers are below the level of abstraction?
18:08:33 <vincenz> newsham: I need full Integrals anyways
18:08:34 <vincenz> for div and mod
18:08:36 <oerjan> @bot
18:08:36 <lambdabot> :)
18:08:46 <SaMBuCa_> hihihi it's time to sleep for me. Thank you all for the teachings, i'll be back soon with a big bottle of italia Sambuca ^^
18:08:48 <SaMBuCa_> bye!
18:08:48 <newsham> how about:   Num Bool Int [Int] ?
18:09:24 <oerjan> bye SaMBuCa_
18:09:49 <vincenz> newsham: thought of that
18:09:56 <vincenz> newsham: not sure which is better tbh
18:10:10 <newsham> or alternately how about attaching the sign only to the most significant value?
18:10:37 <newsham> sort of like how 2s comp does
18:10:44 <vincenz> newsham: requres me to go to the end of the list
18:11:16 <newsham> only for operations that need to know about the sign
18:11:24 <newsham> for example you can do 2s comp arithmetic without worrying about the sign
18:11:33 <vincenz> sure
18:11:35 <EvilTerran> everything negative makes addition quite easy, i think
18:11:40 <vincenz> but is that valid for non-base2?
18:11:49 <EvilTerran> zipWith (+) then flatten out the bumps
18:11:55 <vincenz> yep
18:12:05 <vincenz> and force single sign
18:12:08 <vincenz> cause otherwise you can have
18:12:17 <vincenz> [-4, 10] in base 13 to represent 126
18:12:33 <newsham> I think in base ten the top digit would be values n-5
18:12:35 <vincenz> though maybe that's fine for intermediate numbers
18:12:48 <newsham> in "tens complement"
18:13:10 <newsham> ie:  -5, -4, -3, -2, -1, 0, 1, 2, 3, 4  instead of 0..9
18:13:25 <vincenz> I disagree
18:13:25 <newsham> but yah might be more headache than worth
18:13:30 <vincenz> how can you get for instance 9?
18:13:51 <newsham> same way you get 1 in 2's comp in base 2.    01.  you need more than one digit for that
18:13:56 <vincenz> newsham: erm...
18:14:07 <vincenz> newsham: in base 2, it's not n-1/2
18:14:12 <vincenz> oh wait
18:14:15 <dibblego> > 1.618 / 0.618
18:14:15 <newsham> yah, its n-1 :)
18:14:20 <vincenz> newsham: no, still how do you do 9?
18:14:22 <vincenz> newsham: show me 9
18:14:26 <lambdabot>  2.6181229773462786
18:14:26 <newsham> 09
18:14:31 <dibblego> 0.618 / 1.618
18:14:34 <vincenz> newsham: oh you force a 0
18:14:38 <vincenz> newsham: rather arbitrary
18:14:44 <vincenz> just put a bit there then
18:14:48 <vincenz> no point in having up to n-5
18:14:57 <newsham> vincenz: in 2ns comp with 8 bits you only get values -128 to +127.
18:15:05 <vincenz> newsham: I know
18:15:07 <newsham> in 2 bits you'd only get -2 to 1
18:15:15 <vincenz> but you only need 1 bit in 10 comp
18:15:16 <newsham> same with other bases, you'd need more digits.
18:15:18 <vincenz> no
18:15:21 <vincenz> you only need a bit on top
18:15:37 <vincenz> to say, do we do -10^bitlength
18:15:38 <newsham> not if the top digit was biased by half the base negative
18:15:46 <vincenz> there's no need for that
18:15:51 <vincenz> if anything you make it more complex than required
18:15:55 <newsham> you'd get -50 to +49 with 2 digits in bsae 10 with the same system as 2's comp
18:16:06 <vincenz> ...
18:16:12 <vincenz> you get -100 - 99
18:16:15 <vincenz> with a simple extra bit
18:16:37 <vincenz> (and less custom logic)
18:16:38 <newsham> no, you'd get -99 to 99 (and two zeros0
18:16:46 <vincenz> not really
18:16:55 <vincenz> the bit means: add -100
18:17:08 <vincenz> so 10s complement
18:17:09 <newsham> I see how you're interpretting it.  yah, you could do that
18:17:41 <newsham> but if you biased the whole top digit the rules for bsae 10 arithmetic stay unchanged
18:17:50 <newsham> if you have a sign bit you have to accomodate that as a special case
18:18:04 <newsham> (not that it matters much, you still need custom rules for multiplication)
18:18:10 <newsham> anyway, back to work w/ me :)
18:19:51 <jaredj> sudden question!
18:19:58 <bjornbm> Anyone here with hs-plugins experience? I'm running into a not so friendly error message...
18:20:04 <vincenz> multiplication with plain lists is just a >>=
18:20:10 <vincenz> and then making sure to do proper bubbling
18:20:21 <newsham> bubbling = carry prop?
18:20:23 <jaredj> is there an hstags, or does LXR do haskell, or what - what is there for following names around a codebase to definitions?
18:20:32 <vincenz> bubble = carry numbers > base
18:21:10 <bjornbm> My application (foo) gives me the following message when attempting to make and load a plugin:
18:21:13 <bjornbm> foo: Ix{Int}.index: Index (327680) out of range ((0,15))
18:21:31 <vincenz> > [1,2,3] >>= \x -> map (*x) [2,2,2]
18:21:32 <lambdabot>  [2,2,2,4,4,4,6,6,6]
18:21:39 <vincenz> wrong ordering
18:21:57 * vincenz snaps
18:22:22 <newsham> multiplication is correlation, no?
18:22:35 <vincenz> yeah
18:22:58 <vincenz> mult [] y = []
18:23:05 <vincenz> mult [x] y = map (*x) y
18:23:08 <vincenz> (then bubble of course
18:23:33 <vincenz> mult (x:xs) y = map (*x) y + [0]:mult xs y
18:24:02 <vincenz> similarly, bubble at the end
18:24:02 <oerjan> newsham: convolution, you mean?
18:24:10 <vincenz> oerjan: correlation is a form of convolution
18:24:22 <oerjan> oh
18:24:30 <vincenz> but yeah, he probably meant convolution
18:27:14 <vincenz> though afaik
18:27:19 <vincenz> convolution flips it's second argument
18:27:26 <vincenz> so correlation x y = convolution x (flip y)
18:27:33 <vincenz> which makes correlation more apt for multiplication
18:27:42 <vincenz> (cause multiplication doesn't flip one of the args)
18:33:09 <oerjan> actually multiplication does flip too
18:33:58 <vincenz> only if you use convolution
18:35:08 <oerjan> or rather, the flipping is a technical thing: the arguments of the functions should sum to the index you are trying to find
18:36:08 <vincenz> look
18:36:13 <vincenz> mult [a,b,c] [x,y,z] =
18:36:20 <oerjan> the flipping only happens when you express the argument of one function in terms of that of the other
18:36:31 <vincenz> a*[x,y,z] + b*[0,x,y,z] + c*[0,0,x,y,z]
18:36:55 <vincenz> if look at that like sliding x,y,z to the right
18:36:59 <vincenz> then they're in the same direction
18:37:15 <vincenz> hmm
18:37:22 <vincenz> oh wait, you've got a point, looking at this from the wrong angle
18:37:37 <vincenz> yes, then indeed, mult is more like a convolutoin :)
18:39:01 <vincenz> hmm... which actually makes sense... sinice convolution is often shown as (*)
18:39:07 <vincenz> 'multiplication for signals'
18:39:12 * vincenz groans and checks the hour
18:41:16 <oerjan> indeed, good night
18:41:24 <vincenz> night
18:57:13 <jaredj> jaredj@harpster:~/src/darcs/cac-unstable$ haddock -o haddock -v $(find . \! -regex '.*/_darcs/.*' \( -name \*.lhs -o -name \*.hs \))
18:57:17 <jaredj> ./src/Autoconf.lhs:"./src/Autoconf.lhs": 1:1: Parse error
18:57:24 <jaredj> does haddock not do lhs's?
19:08:50 <jaredj> argh, i can't think functionally
19:09:33 <jaredj> how do i turn ["1", "  2", "  3", "4"] into [["1", "  2", "  3"], ["4"]]?
19:09:40 <LoganCapaldo> if a file is .lhs doesn't that sort of imply its already docu-a-mafied
19:09:43 <LoganCapaldo> ?
19:10:05 <jaredj> LoganCapaldo: er, yes. i was really seeking after the clickiness though.
19:10:10 <jaredj> hasktags isn't working for me.
19:10:15 <nick_> what's up in the haskell hood?
19:10:33 <jaredj> hasktags doesn't put out a sorted tags file, so vim is unhappy with it
19:10:34 <LoganCapaldo> > groupBy ((==) . head) ["1", "  2", "  3", "4"]
19:10:41 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
19:10:42 <lambdabot>       Expected...
19:10:51 <LoganCapaldo> I fail
19:11:06 <LoganCapaldo> > groupBy (\ a b -> head a == head b) ["1", "  2", "  3", "4"]
19:11:07 <lambdabot>  [["1"],["  2","  3"],["4"]]
19:11:11 <sarehu> > let xs = ["1", "  2", "  3", "4"] in [init xs, last xs]
19:11:12 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
19:11:29 <sarehu> > let xs = ["1", "  2", "  3", "4"] in [init xs, [last xs]]
19:11:30 <lambdabot>  [["1","  2","  3"],["4"]]
19:11:33 <jaredj> LoganCapaldo: beautiful, that's halfway there!
19:12:17 <sarehu> oh, grouping lines by indentation levels?
19:12:57 <jaredj> > groupBy (\ a b -> (not (head a) `elem` " \t") and ((head (head b)) `elem` " \t") [["1"], [" 2"," 3"], ["4"]]
19:12:57 <lambdabot>  Unbalanced parenthesis
19:13:01 <jaredj> dooh
19:13:31 <jaredj> sarehu: grouping indented lines with the next unindented line up
19:14:14 <jaredj> in order to sort the output of hasktags properly
19:14:23 <jaredj> i started it in ruby, a quick five-liner
19:14:27 <jaredj> and i said, no wait
19:14:48 <sarehu> > groupBy (\a b -> (head b `elem` " \t")) ["1", "  2", "  3", "4']
19:14:48 <lambdabot>  Improperly terminated string
19:14:52 <sarehu> > groupBy (\a b -> (head b `elem` " \t")) ["1", "  2", "  3", "4"]
19:14:54 <lambdabot>  [["1","  2","  3"],["4"]]
19:15:16 <sarehu> that's wrong though... empty strings.
19:15:25 <jaredj> ?
19:15:31 <sarehu> > groupBy (\a b -> null b || head b `elem` " \t") ["1", "  2", "  3", "4"]
19:15:32 <lambdabot>  [["1","  2","  3"],["4"]]
19:15:38 <jaredj> there aren't any in this case
19:16:00 <sarehu> well if this case is the only one that matters, use [init xs, [last xs]].....
19:16:25 <LoganCapaldo> lol
19:16:53 <LoganCapaldo> [["1", " 2", " 3"], ["4"]] is more optimized :)
19:17:01 <jaredj> gah
19:19:15 <dmwit> > groupBy (comparing (length . takeWhile (==' '))) ["1", " 2", " 3", "4"]
19:19:16 <lambdabot>  Couldn't match expected type `Bool'
19:19:25 <dmwit> :t comparing
19:19:26 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
19:19:37 <dmwit> :t on
19:19:39 <lambdabot> Not in scope: `on'
19:20:03 <sarehu> :t equating
19:20:05 <lambdabot> Not in scope: `equating'
19:20:07 <sarehu> :t eqing
19:20:09 <LoganCapaldo> lol
19:20:09 <lambdabot> Not in scope: `eqing'
19:20:11 <sarehu> bah!
19:20:15 <LoganCapaldo> :t lol
19:20:17 <lambdabot> Not in scope: `lol'
19:20:29 <dmwit> > let on p x y = p x == p y in groupBy (on (length . takeWhile (==' '))) ["1", " 2", " 3", "4"]
19:20:31 <lambdabot>  [["1"],[" 2"," 3"],["4"]]
19:20:45 <LoganCapaldo> yeah that's pretty much the soln I got
19:20:58 <LoganCapaldo> except smarterer
19:21:13 <LoganCapaldo> handles varying levels of "       "
19:21:41 <dmwit> Oh, yours is cute.
19:22:20 <dmwit> > groupBy (((==) .) . join head) ["1", " 2", " 3", "4"] -- what are the chances I can get it on the first try?
19:22:21 <lambdabot>      Occurs check: cannot construct the infinite type:
19:22:21 <lambdabot>       a = [a] -> a1 ->...
19:23:19 <dmwit> ?pl \f g x y -> f (g x) (g y)
19:23:19 <lambdabot> join . ((flip . ((.) .)) .) . (.)
19:23:43 <dmwit> Ooof.  There's a very, very low chance I would have gotten _that_ on the first try. =/
19:24:10 <jaredj> lol
19:24:17 <LoganCapaldo> p knows about applicative and arrow right?
19:24:20 <LoganCapaldo> *pl
19:24:46 <monochrom> yeah
19:24:50 <dmwit> ?pl \f g (x, y) -> (f x, g y)
19:24:50 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
19:25:02 <dmwit> Doesn't seem to know much about arrows.
19:25:19 <monochrom> I've seen it use ap. No longer sure about arrows.
19:25:42 <dmwit> heh
19:25:47 <LoganCapaldo> is ap from applicative? I thoght it was from Control.Monad?
19:25:54 <LoganCapaldo> @index ap
19:25:54 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
19:25:55 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
19:25:56 <monochrom> I am a moron.
19:26:21 <LoganCapaldo> you can't be a moron
19:26:30 <sorear> right
19:26:34 <sorear> he's a monochrom
19:28:30 <Pseudonym> "Moron" is the ancient Greek word for a black mulberry.;
19:28:39 <Pseudonym> So apparently he's a black mulberry.
19:28:56 <LoganCapaldo> well I guess a black mulberry is monochromatic
19:29:07 <monochrom> hahahahahaha
19:30:22 <LoganCapaldo> they should sell textbooks in paperback novel format
19:30:42 <LoganCapaldo> not because they'd then be cheaper but because then I'd be more willing to read on my commute
19:30:51 <LoganCapaldo> *to read them
19:31:00 <jaredj> w00t
19:31:38 <dmwit> jaredj: Nice work!
19:31:41 <hpaste>  jaredj pasted "sort-tags.hs" at http://hpaste.org/3027
19:31:53 <jaredj> whoa, what?
19:32:07 <jaredj> DID YOU HACK MY COMPUTER
19:32:39 <jaredj> lol
19:32:41 <dmwit> Nope, I just assumed that w00t meant you had accomplished something tricky.  ;-)
19:32:53 <jaredj> eh tricky for me.
19:32:57 <hpaste> haxored
19:33:03 <jaredj> !!
19:33:07 <jaredj> ??
19:33:08 <dmwit> whoa
19:33:11 <hpaste> jaredj: whoa
19:33:27 <jaredj> aw look it's a puppet
19:33:34 <jaredj> hpaste want a cracker?
19:33:46 <hpaste> jaredj: wow, that hardly took you any time at all!
19:33:49 <dmwit> I think you might have mentally misspelled "parrot".
19:33:57 <jaredj> well - no
19:34:06 <jaredj> i just don't know what you say to the puppet
19:34:14 <jaredj> i know he says fresh things at you -
19:34:56 <glguy> jaredj: how about: lines `fmap` readFile "tags"
19:35:39 <jaredj> http://www.junkyardclubhouse.com/2007/05/27/how-to-tell-if-your-ventriloquist-puppet-is-evil/
19:35:41 <lambdabot> Title: How To Tell If Your Ventriloquist Puppet Is Evil ª Junkyard Clubhouse, http://tinyurl.com/2xhx86
19:35:42 <jaredj> that kind of puppet
19:35:48 <jaredj> glguy: that would work, yes
19:36:03 <jaredj> then i wouldn't have had to look up that pesky mode flag
19:37:04 <jaredj> wtf!
19:37:23 <hpaste> zomg!
19:37:36 <dmwit> interact (unlines . concat . sortem . groupem . lines)
19:37:47 <dmwit> interact: Learn it, love it!
19:37:51 <jaredj> tags: [...] DarcsOption     ./src/Darcs/Arguments.lhs       125 [...]
19:37:54 <shachaf> Why not s/`fmap`/<$>/g?
19:38:08 <jaredj> vim: E426: tag not found: DarcsOption
19:38:23 <jaredj> shachaf: YOU PEOPLE AND YOUR MONEY
19:38:28 <dmwit> Of course, then you have to send the file to stdin manually, but that's okay.
19:38:33 <jaredj> MONEY ISN'T EVERYTHING
19:38:42 <jaredj> dmwit: yeh. that's quite cool
19:39:03 <jaredj> but i sorted the tags and vim still isn't happy :(
19:41:38 <jaredj> hmph
19:41:45 <jaredj> vim doesn't like the punctuatey tags
19:41:52 <dmwit> jaredj: How are you generating the tags?
19:41:56 <jaredj> hasktags
19:43:15 <jaredj> Ookay. Now i'm tagging. Sucks if I want to find the definition of an operator. But we'll see.
19:46:34 <phobes> Should we start a #haskell-base-conversion?
19:46:58 <dmwit> Hey, this Kolmogorov complexity thing is pretty neat.
19:51:57 <Pseudonym> It is, isn't it.
19:52:15 <Pseudonym> The information theory bit is the coolest, IMO.
19:56:28 <dmwit> ?users
19:56:28 <lambdabot> Maximum users seen in #haskell: 420, currently: 349 (83.1%), active: 10 (2.9%)
20:05:47 <dmwit> Pseudonym: I was thinking about a similar problem recently.
20:06:30 <dmwit> The problem was to encode your position along a tape of binary symbols, so that you could know your position in the least number of "moves" along the tape.
20:06:43 <dmwit> (Assuming a circular tape, and you can only see the symbol that you are directly over top of.)
20:07:16 <dmwit> I eventually ended up with the de Bruijn sequence: http://en.wikipedia.org/wiki/De_Bruijn_sequence
20:08:03 <jaredj> hooray for graph theory!
20:11:39 <platypus> dmwit: How long is the tape?
20:12:18 <dmwit> Say, 2000 bits.
20:12:25 <dmwit> 2048, if that is convenient. ;-)
20:12:30 <sorear> dmwit: I'd go for a pseudonoise sequence
20:12:34 <dmwit> Why do you ask?
20:12:49 <dmwit> sorear: Rationale?
20:12:56 <platypus> Well if you defined the tape as being one cell long the problem becomes trival.
20:12:59 <jaredj> sorear: odds are nonzero that you could mistake your place
20:13:49 <sorear> jaredj: PN sequences have exactly one occurence of each k-bit fragment, where k is the deepst tap
20:14:28 <dmwit> sorear: A de Bruijn sequence also has this property.
20:14:46 <sorear> yes, but I didn't know about de Bruijn sequences prior to today :)
20:14:47 <jaredj> thus the pseudo.
20:14:59 <dmwit> sorear: In fact, the de Bruijn sequences are merely a generalization of your pseudo-noise sequences to arbitrary alphabets. =)
20:15:24 <dmwit> sorear: okay =)
20:15:46 <dmwit> I didn't know about de Bruijn sequences until I started tackling this problem, so you're already doing better than me. =)
20:20:35 <LoganCapaldo> night boils and ghouls
20:20:39 * SamB_XP wonders how massive fingerprints are...
20:22:03 <dmwit> SamB_XP: You are wondering how much mass the particles in a fingerprint have?
20:22:15 <dmwit> Or are you using "massive" in a more figurative way?
20:22:22 <SamB_XP> dmwit: exactly
20:22:34 <dmwit> huh
20:23:20 <dmwit> Depending on how they're formed, it may be negative.
20:23:49 <dmwit> i.e. If you see my fingerprint on a dusty car, it's because the dust *isn't* where my fingerprint shows up.
20:23:53 <dons> http://programming.reddit.com/info/2vknb/details
20:23:54 <lambdabot> Title: Higher-dimensional Enumeration (reddit.com)
20:25:22 <platypus> dmwit: However the fingerprint itself is made up of oil from the skin.
20:30:35 <oklopol> > bot
20:30:38 <lambdabot>   Not in scope: `bot'
20:30:45 <dmwit> > undefined
20:30:47 <lambdabot>  Undefined
20:31:01 <dmwit> > let bot = bot in bot -- also acceptable
20:31:02 <lambdabot>  Exception: <<loop>>
20:33:47 <oklopol> i see
20:33:47 <dmwit> oklopol: Which paper are you reading?
20:33:52 <dmwit> paper/tutorial/whatever
20:34:49 <oklopol> http://haskell.org/tutorial/patterns.html <<< i'm not reading this, was checking pattern matching syntax, but the problem was the fact i can't have multiple definitions of a function separately in the interpreter
20:34:50 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
20:35:06 <oklopol> i think i've read it though, somewhere in time
20:35:24 <dons> http://programming.reddit.com/info/2vlc9/comments  didn't know about these nice ones
20:35:25 <lambdabot> Title: XML hacking in Haskell with HXT (reddit.com)
20:45:20 <dons> rock out! http://programming.reddit.com/info/2vlf8/comments
20:45:21 <lambdabot> Title: Live from the Haskell Workshop: HPC: Haskell Program Coverage :: Video (reddit.c ...
20:45:35 <dons> more apearing here, http://video.google.com/videosearch?q=haskell+workshop
20:45:36 <lambdabot> Title: haskell workshop - Google Video
20:48:56 <dons> http://programming.reddit.com/info/2vlg6/comments also
20:48:57 <lambdabot> Title: Live from IFL: The Reduceron: Compiling Haskell to FPGA :: Video (reddit.com)
20:49:08 <bos> dons++
20:49:22 <bos> can ye nae sleep, man?
20:49:41 <dons> no :( ah well
20:49:55 <dons> nae, i canna get no sleep
20:50:42 <bos> the video is strangely choppy, like 2 frames/sec
20:50:55 <jaredj> right? it's like, are we about to see him shoplift?
20:50:58 <jaredj> :)
20:51:05 <dons> maybe they're still uploading?
20:51:11 <Pseudonym> dons: Still on Sydney time?
20:51:22 <dons> what about the reduceron one, that was uploaded a couple of days ago
20:51:24 <SamB_XP> dons: did you post that to reddit?
20:51:34 <dons> Malcolm says, `Videos of the Haskell Workshop 2007 talks and discussion are now beginning to appear on Google Video. The upload connection speed from the conference venue is slow, so more talks will appear gradually over the next day or two.'
20:52:06 <bos> reduceron is maybe 8 frames/sec
20:52:50 <jaredj> this is great
20:52:51 <dons> so there's original master tapes, but maybe the encoding isn't right? talk to malcolm if he comes online
20:53:02 <jaredj> i have no clue at the start about fpga's
20:53:15 <Spark> why is the net connection always shit at computer science conferences
20:53:21 <SamB_XP> I thought it was megahurtz
20:53:25 <jaredj> right?
20:53:32 <SamB_XP> Spark: it isn't
20:53:38 <SamB_XP> but there are too many people using it
20:54:34 <Spark> i remember trying to work over ssh from concur in lisbon to london
20:54:47 <Spark> it was mostly ok, but kept drifting offline for a while and then coming back again
20:55:19 <Spark> it was like someone kept rebooting the accesspoint
20:55:29 <monochrom> Is the conference at a hotel? A hotel typically subscribes to one home-user-grade line and shares it among all customers!
20:55:49 <Spark> it's usually really bad if it's in a hotel
20:56:15 <jaredj> bleah
20:56:20 <sorear> One home user line could serve a small city if people only used efficient services like IRC and plaintext e-mail/web
20:56:31 <jaredj> if, if
20:56:48 <Spark> irc stops being efficient if you run irssi in a screen
20:57:14 <Spark> and i hate to think how much bandwidth i use when scrolling through mutt over ssh
20:57:15 <monochrom> Makes you wish you were in Africa, OLPC and foot-pedal power and everyone tries to conserve. :)
20:57:43 <jaredj> while america uses youtube.
20:57:54 <sorear> Spark: ssh/screen was not in my list, IRC and e-mail were.  You have to run irssi and mutt locally :)
20:58:33 <Spark> but then it's not so convenient :)
20:59:22 <DRMacIver> Hm. I'm trying to build the darcs version of hdbus, but it can't seem to find dbus.h. It clearly exists, so it must be looking in the wrong place for this, but I have no idea how to fix it. :(
22:21:26 <omniscientIdiot> IT'S TOO QUIET IN HERE
22:22:36 <pizza_> WHAT?!
22:23:17 <omniscientIdiot> I SAY IT'S TOO QUIET IN HERE!!
22:24:10 <lambdabot> ssh!
22:24:31 <pizza_> rsh!
22:26:59 <misterbeebee> does anyone else get a feeling that  haskell is in a state like the early years of linux: ghc is like a kernel, and hackage has a pile of packages, but there we're missing "distributions" that put all the packages together in a user-friendly way and provide safe upgrade paths?
22:27:00 <misterbeebee> stuff breaks so frequently, when ghc changes, or when cabal changes, that it's hard to get a foothold once and then move forward when new stuff comes out.
22:29:26 <sjanssen> misterbeebee: sometimes
22:30:15 <misterbeebee> just after saying that, I realized that macports has more haskell packages, hs-*, that I missed when I installed ghc, so maybe things aren't quite as bad as I thought.
22:31:08 <sjanssen> I think it requires an undue amount of knowledge to know what works on which platforms
22:31:09 <misterbeebee> and then I see that the port of hs-plugins is broken because my haskell is missing the 'posix' package. :-/
22:31:26 <sjanssen> hs-plugins doesn't have a stable release that works with 6.6
22:32:25 <sjanssen> misterbeebee: part of your problem might be macports
22:32:32 <sjanssen> macports isn't very good IME
22:32:45 <misterbeebee> that's unfortunate, but I can deal. I'm not happy that macports doesn't know that fact... isn't that the point of package managers, to manage dependencies? not blaming the macports volunteers, I'd like to know how to help
22:33:18 <misterbeebee> so if I discard macports, is there a better alternative? cabal + hand-managing on mac, or switch to debian/redhat/???
22:34:38 <sjanssen> I think Gentoo has pretty nice Haskell packages
22:34:42 <bos> you'll probably end up doing a lot by hand anywhere
22:34:57 <misterbeebee> my meta question is, do the haskell super-gurus have these problems, do they not use very many 3rd-party libs, or have they hacked them into their systems and it "Works For Them" ?
22:34:59 <sjanssen> if Gentoo is your sort of thing (it is a far cry from OS X)
22:35:22 <sjanssen> misterbeebee: I think the super-gurus know all of the pitfalls before hand
22:35:45 <sjanssen> because they spend time reading mailing lists, keeping up with the latest developments
22:35:56 <misterbeebee> I have a spare machine that could be imaged with gentoo, and I could ssh in to my "haskell box", but that is highly suboptimal
22:36:01 * bos stitches "super-guru" into sjanssen's shirt
22:36:22 <bos> misterbeebee: you're unlikely to have any easier time with gentoo than macports
22:36:55 <bos> debian might be a bit of a step up, but really if you're trying to mix a bunch of independent libraries, you're going to end up doing a lot by hand anywhere
22:36:59 <sjanssen> with Gentoo, you'll probably waste your time getting your sound card (or some other fiddly bit) instead of Haskell
22:37:10 <newsham> (err yah, I meant convolution, not correlation, way back 3-4hrs ago)
22:37:34 <misterbeebee> there's all this talk of "haskell can no longer avoid success", but really for a new user starting from 0, there are still tons of discouraging traps.
22:38:12 <misterbeebee> I've been fiddling with haskell on and off for a few years, i'm no expert, sure, but I'm competent with a unix box, and I can learn tons of cool stuff from the tutorials and stuff, but whenever I try to write stuff for my own project ideas, wham into a wall.
22:38:14 <misterbeebee> </rant>
22:38:19 <sjanssen> misterbeebee: out of curiousity, what trouble are you having?
22:38:21 <bos> misterbeebee: it's no worse than python or ruby or perl, really
22:38:54 <kscaldef> bos: wrong
22:39:15 <sorear> misterbeebee: thank you, I was starting to lose hope
22:39:17 <misterbeebee> sjanssen: my latest is trouble setting up the regex libs I mentioned earlier today. I got regex-tdfa to compile by fiddling the source, and I sent an email to chris k.
22:39:42 <bos> misterbeebee: but that's just broken library badness. that's not a haskell problem.
22:40:08 <sjanssen> misterbeebee: you were building a release from hackage with ghc 6.6 and it didn't work?
22:40:10 <misterbeebee> bos: sure, ok. what's the haskell equivalent of "GNU/Linux"
22:40:28 <dmwit> House
22:40:32 <bos> there isn't one.
22:40:36 <kscaldef> bos: libraries are a major part of how people judge a language.  If there aren't decent libraries for common tasks, most people will just switch to a different language
22:40:54 <misterbeebee> bos: that's the problem for us newbs.
22:41:07 <bos> kscaldef: people are working on libraries and on the infrastructure to make them easily available.
22:41:21 <misterbeebee> sjanssen: I downloaded a cabal bundle for 6.6. bos mentioned he knows that regex-tdfa has problems....
22:41:30 <ddarius> Haskell may not be able to avoid success, but we certainly aren't there yet either.
22:41:42 <ddarius> misterbeebee: Things have improved dramatically in the past few years.
22:42:05 <ddarius> And they are still being actively improved.
22:42:16 <misterbeebee> bos:  is there a roadmap or buglish for the library ecosystem. I'm happy to help out, but I don't have time to lead or understand the whole everything by following mailing lists.
22:42:22 <kscaldef> bos: that's good.  But saying "that's just broken library badness. that's not a haskell problem." is counterproductive and will make newbies go elsewhere
22:42:45 <bos> misterbeebee: no, there's not really a roadmap. people work on the stuff they feel is important, or interesting, or whatever.
22:43:11 <bos> kscaldef: what? if someone packages a library that doesn't compile, how is that anything other than a broken library?
22:43:18 <misterbeebee> bos: understand that I'm not petulantly demanding that stuff gets fixed now now now.
22:43:41 <misterbeebee> but a unified list of known issues is critical to the success of a dsitributed effort.
22:43:53 <misterbeebee> cf ubuntu's awesome online bugtracking system
22:44:21 <bos> kscaldef: i ran into the problem with regex-tdfa about a week before misterbeebee did, and i mentioned it to chris k, and ... that's it.
22:44:27 <misterbeebee> ubuntu's had great success by making bug reporting and fix submission easy across  thousands of independently owned packages.
22:44:41 <bos> misterbeebee: haskell isn't funded by a fella with half a billion dollars in his pocket :-(
22:45:01 <misterbeebee> bos: i know, i know... there's a bootstrapping challenge here.
22:45:13 <sjanssen> misterbeebee: I just tried to build regex-tdfa-0.92, doesn't work here either.  Is TuringTest releasing bogus packages?
22:45:31 <bos> sjanssen: yes, most of the regex packages are broken
22:45:40 <sjanssen> bos: I wonder how that happends
22:45:45 <sjanssen> happens
22:45:46 <bos> all in small ways, like he's using some weird combination of local packages
22:45:49 <misterbeebee> how hard would it be to open up or clone the ghc trac system to handle library bug reports for hackage packages?
22:46:09 <sorear> misterbeebee: ... some of us hold very low opinions of the Ubuntu Way ...
22:46:10 <bos> trac is a nightmare to administer.
22:46:11 <kscaldef> bos: why do I (i.e. some random user) have to download the library and discover it doesn't work on my system?  On CPAN, I can view PASS/FAIL information for dozens of platforms before I downloaad
22:46:42 <geocalc> broken mind
22:46:44 <sjanssen> I fixed a broken module by adding "import Data.Monoid; import Control.Monad".  No offense to the maintainer, but that is a bit pathetic
22:46:56 <misterbeebee> i have to go for a while... the wife is jealous of you guys. I think there's an important and productive discussion to have, and I'd like to continue it
22:47:05 <bos> kscaldef: there are build logs in hackage, though not with a good interface yet
22:47:06 <misterbeebee> sjanssen: that is exactly the fix i emailed to chris today
22:47:19 <misterbeebee> talk to you all later... g'night for now
22:47:50 <sorear> but regexes are evil, the harder they are to use the better?
22:47:56 <sjanssen> heh
22:48:17 <kscaldef> heh... unnecessary use of regexes are evil, but they have their place
22:48:39 <kscaldef> XML validation is not one of those places.... grumbles at HXT
22:48:48 <bos> yeah, ugh.
22:49:10 <kscaldef> HXT uses a regex to validate the ANY content model!
22:49:26 <kscaldef> it could just return true, unconditionally
22:49:49 <kscaldef> anyway, I'm going to try to fix that later this week
22:53:06 <sjanssen> grr, why does regex-tdfa use -Werror if there are warnings?!
22:53:46 <geocalc> lol
22:55:02 <olsner> it didn't have warnings when I installed regex-tdfa, so I guess it indicates a "newly" introduced mistake ;-)
22:56:11 <olsner> or perhaps I quick-hacked a fix for it and forgot about it... those things happen too
22:56:50 <sjanssen> I saw this with the darcs version, last patch "Fri May  4 10:01:12 CDT 2007"
22:57:26 * misterbeebee is back online.. is there a realtime online log to catch what I missed past 10minutes?
22:57:41 <sjanssen> misterbeebee: yep, in the topic
22:58:21 <misterbeebee> oh! i misread that.. i though that page said it had only 2004-05 logs. cool. /me reads...
22:58:22 * sorear thinks the unmaintainedness of regex-* is due to us beleiving jwz' dictum
22:58:26 <sjanssen> misterbeebee: I think regex-tdfa is fairly unique amongst Haskell packages, especially those on hoackage
22:58:31 <olsner> sjanssen: lol, yep, darcs diff shows that I added import Data.Monoid; import Control.Monad
22:59:37 <misterbeebee> sjanssen: the unlucky of me to pick that, maybe i made a tempest in a teapot.
22:59:44 <olsner> sorear: jwz' dictum?
23:01:28 <sorear> http://regex.info/blog/2006-09-15/247
23:01:30 <lambdabot> Title: Jeffrey Friedl&#8217;s Blog ª Blog Archive ª Source of the famous &#8220;Now you ...
23:06:20 <misterbeebee> regex-pcre is close on the heels of regex-tdfa:
23:06:22 <misterbeebee> [1 of 6] Compiling Text.Regex.PCRE.Wrap ( dist/build/Text/Regex/PCRE/Wrap.hs, dist/build/Text/Regex/PCRE/Wrap.o )
23:06:22 <misterbeebee> Text/Regex/PCRE/Wrap.hsc:111:0: Not in scope: `retOk'
23:07:29 <qubit> hello room
23:08:09 <misterbeebee> hi qubit
23:08:55 <qubit> may i ask a quick question im new to Haskell
23:09:08 <sorear> Don't ask to ask.
23:09:12 <sorear> We don't bite.
23:09:31 <sorear> misterbeebee: line 111?  wow, it got far!
23:09:32 <qubit> thankyou
23:09:40 <misterbeebee> sorear: that was cabal-install
23:09:42 <ddarius> sorear: Some of us bite.
23:09:55 <misterbeebee> when i use cabal Setup.lhs directly, I get this:
23:09:56 <misterbeebee> setup: At least the following dependencies are missing:
23:09:56 <misterbeebee>     fps >=0.7
23:10:07 <misterbeebee> which let me to ask earlier today about "fps" vs "bytestring"
23:10:36 <sjanssen> misterbeebee: strong indication of an outdated package
23:10:42 <sorear> very strong
23:10:55 <sjanssen> fps is Data.ByteString, which was rolled into base for ghc 6.6
23:11:10 <sjanssen> misterbeebee: which version of regex-pcre are you building?
23:11:19 <misterbeebee> http://darcs.haskell.org/packages/regex-pcre/
23:11:20 <lambdabot> Title: Index of /packages/regex-pcre
23:11:27 <misterbeebee> 05-Mar-2007 ?
23:11:56 <misterbeebee> I'd have guess that darcs.haskell.org is authoritative
23:12:01 <qubit> I need to write the prelude identity function as recusive, I tried return, but that is a -> m a, not a -> a..
23:12:24 <misterbeebee> I'm picking on regex a bit here, but it's gotten a lot of conversation and attention and it's new in 2007, i believe, so it should be ghc-6.6 friendly...
23:13:00 <sorear> misterbeebee: None of the people curently here wrote regex, so all you'll get is sympathy
23:13:03 <ddarius> qubit: ... what?  That doesn't make sense.  Perhaps you want the identity function restricted to some type?
23:13:03 <sorear> not results
23:13:53 <sjanssen> misterbeebee: try the version on hackage.haskell.org
23:14:03 <sjanssen> misterbeebee: always try releases before the development version
23:14:14 <qubit> no, it has to be a direct translation id_rec : a -> a, using recursion
23:14:18 <omniscientIdiot> id x = x
23:14:27 <sjanssen> development versions reserve the right to be broken on any given day :)
23:14:34 <omniscientIdiot> not sure what you mean by recursive.
23:14:36 <qubit> yes, but resursivly
23:14:49 <shachaf> id x = let _ = id x in x
23:15:02 <misterbeebee> oh, sorry, I wasn't distinguishing... i use hackage when i click to download, and i use darcs when i run my little homebrew  imitation of cabal-install. that was my mistake to  overlook.
23:15:09 <qubit> so use let with a wild card?
23:15:18 <ttfh> shacaf: but why?
23:15:23 <shachaf> qubit: (It was a joke.)
23:15:32 <shachaf> Why do you want it to be recursive?
23:15:40 <sjanssen> misterbeebee: regex-pcre-0.92 builds okay here
23:15:51 <qubit> ummm. its for a book voucher at uni, first week of haskell and i need to buy the book -> very poor student
23:15:54 <sjanssen> with regex-base-0.91, if that matters
23:16:05 <misterbeebee> lemme go try the hackage version before i embarass myself again..brb
23:16:14 <qubit> lecturers challange......
23:16:27 <omniscientIdiot> I don't understand what you would recurse over, what structure you would break down.  id's type says it knows nothing of its argument.
23:17:00 <misterbeebee> quick question, can i use darcs with a certain argument to get a released package version via darcs?
23:17:03 <ttfh> a trick question maybe?
23:17:10 <qubit> yes trick i think
23:17:18 <omniscientIdiot> you could write idList :: [a] -> [a], id [] = [], id (x:xs) = (x:xs) -- :)
23:17:36 <qubit> the task was to write a function that is recursive and peforms the same as id
23:17:39 <omniscientIdiot> or rather (x : id xs), to be recursive
23:17:40 <sorear> omniscientIdiot: not recursive enough
23:19:24 <hpaste>  misterbeebee pasted "regex-pcre 0.92 build failure" at http://hpaste.org/3028
23:19:46 <misterbeebee> regex-pcre-0.92  has the same problem as the darcs version. possibly bad/missing regex-base?
23:19:49 <ttfh> unless...
23:20:23 <sjanssen> misterbeebee: what version of regex-base do you have?
23:21:44 <qubit> thanks for the help guys, I hope no one else has answered the challenge yet, I;d love to save $50
23:21:45 <sjanssen> misterbeebee: actually, it looks like you might not have libpcre installed, or Cabal isn't finding it
23:21:51 <misterbeebee> i just now installed 0.92 to be  sure
23:22:04 <misterbeebee> i just installed libpcre also... let me check my LDPATH and such
23:23:46 <hpaste>  misterbeebee annotated "regex-pcre 0.92 build failure" with "looks like i have libpcre installed." at http://hpaste.org/3028#a1
23:24:01 <misterbeebee> that shows i have libpcre installed where cabal wants it
23:24:14 <misterbeebee> i assume the cabal message is a preemptive warning, not a dianosis
23:24:34 <sjanssen> probably, I get the warning too
23:25:12 <misterbeebee> someone who has regex-pcre istsalled.... where is retOk  defined in your system? (which file?)
23:25:54 <misterbeebee> wait a sec...
23:25:59 <misterbeebee> Text/Regex/PCRE/Wrap.hsc:111:0: Not in scope: `retOk'
23:26:03 <misterbeebee> but that line is this:
23:26:10 <misterbeebee> > retOk :: ReturnCode
23:26:11 <lambdabot>   Not in scope: type constructor or class `ReturnCode'
23:26:19 <misterbeebee> that's a declaration of retOk!
23:26:26 <misterbeebee> how is not in scope?
23:26:34 <misterbeebee> it's a type declaration
23:26:36 <sjanssen> misterbeebee: only a type declaration
23:26:46 <misterbeebee> line 169:
23:26:47 <misterbeebee> retOk = ReturnCode 0
23:26:59 <misterbeebee> there's the definition
23:27:08 <sjanssen> misterbeebee: GHC is complaining because there's a typedef, but not a binding
23:27:28 <misterbeebee> isn't line 169: "retOk = ReturnCode 0", the binding?
23:27:32 <sjanssen> misterbeebee: that's wrapped inside an ifdef, which apparently isn't being included
23:27:38 <misterbeebee> aah
23:27:48 <misterbeebee> so maybe it goes pack to pcre.h problems
23:28:12 <sjanssen> grep for retOk in Text/Regex/PCRE/Wrap.hs
23:28:17 <geocalc> @type retOK
23:28:19 <lambdabot> Not in scope: `retOK'
23:28:57 <misterbeebee> your comment about the ifdef makes sense, so now i'm looking to see how HAVE_PCRE_H gets set.
23:29:43 <hpaste>  twifkak pasted "SwapWorkspaces" at http://hpaste.org/3029
23:31:04 <misterbeebee> HAVE_PCRE_H is set in the cabal file as a CC-opton, so HAVE_PCRE_H should be true when Wrap.hsc is compiled, so line 169 should be seen and the binding accepted..
23:31:59 <misterbeebee> I copied the retOk = ReturnCode 0 line   up earlier in the file, which "fixed" that error.
23:34:12 <misterbeebee> if I remove "-Werror" from the cabal file, the compilation/install succeeds.... I'll have to make up some sample code to see if it's actually going to succeed at runtime
23:39:46 <hpaste>  twifkak pasted "SwapWorkspaces (v2)" at http://hpaste.org/3030
23:41:36 <hpaste>  (anonymous) annotated "SwapWorkspaces (v2)" with "(no title)" at http://hpaste.org/3030#a1
23:42:56 <hpaste>  twifkak annotated "SwapWorkspaces" with "v3" at http://hpaste.org/3029#a1
23:48:24 <bos> > [1..1.8]
23:48:25 <lambdabot>  [1.0,2.0]
23:48:37 <bos> that's peculiar.
23:49:08 <bos> Enum for Doubles is weird.
23:49:49 <misterbeebee> and at runtime:
23:49:49 <misterbeebee> "test: WrapPCRE.hsc was not compiled against pcre library with HAVE_PCRE_H defined"
23:50:07 <bos> ah yes, yet more library crapology.
23:50:09 <misterbeebee> so the compile didn't really work, as I'd feared.
23:50:20 <bos> just forcibly define HAVE_PCRE_H at the top of the .hsc file
23:52:27 <misterbeebee> bos: Bingo. that worked. So maybe cabal or the user caused some trouble.
23:52:29 <misterbeebee> wednet% ghc --make -o test /tmp/test-regex.hs && ./test
23:52:29 <misterbeebee> Linking test ...
23:52:29 <misterbeebee> "True"
23:52:36 <olsner> argh, mixing up &&& and *** lead me into an hour of type error debugging
23:52:59 <olsner> and apparently, Text.Regex.Posix lacks a lazy bytestring interface
23:53:17 <bos> olsner: fixed in more recent versions
23:53:33 <bos> misterbeebee: it's just more weirdness in chris's builds
23:54:01 <misterbeebee> So now I think I have a working Text.Regex.PCRE and Text.Regex.TDFA. I'd like to help whoever I can to fix this issue so no one else has to repeat this effort....
23:54:42 <misterbeebee> but maybe there's nothing really I can do that will be an incremental value add.. maybe chris just needs to borrow someone else's machine when he has free time and run his build and tweak bits to make it work?
23:55:31 <sjanssen> misterbeebee: darcs patches are probably helpful
23:55:44 <sjanssen> especially when you're fixing things like missing imports
23:56:11 <misterbeebee> sjanssen: for the missing imports, on the TDFA version, I think you or someone said that was already submitted?
23:56:43 <sjanssen> misterbeebee: I haven't heard anything about that
23:57:04 <sjanssen> the last patch in -tdfa is from May
23:57:13 <bos> misterbeebee: it was probably me. i just told chris about the problem, didn't send a patch.
23:58:31 <LeCamarade> Um ... I heard the next SML is going to use Monads. True | False?
23:58:46 <serishema> ooh. ML
23:58:52 * serishema hasn't done anything with ML for about 4 years
23:58:58 <ari> next-sml-will-use-monadsp
23:59:06 <olsner> LeCamarade: don't forget FileNotFound when enumerating Bool types
23:59:10 <LeCamarade> T
23:59:22 <misterbeebee> i must have misremembered. according to teh logs, two people said they've fixed it, but no one said they submitted it to darcs.
