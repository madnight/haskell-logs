00:03:46 <ac> Zao: still around?
00:04:00 <Zao> ac: Kind of.
00:04:31 <hpaste>  ac pasted "openGL draw test" at http://hpaste.org/3465
00:04:40 <ac> Zao: mind if I ask you a question?
00:05:29 <Zao> You can at least try to :)
00:05:37 <ac> Zao: nevermind. Just answered it myself. doh
00:06:23 <Zao> The best kind of answers.
00:06:55 <ac> If you change "RGBA" to "RGB" and add a "* 3" to "byteCount =" that code is a nice little demo :)
00:19:58 <ivanm> If I have a custom class and simple operations for that class, what's better? To write them as part of the class definition, or to write them separately but depending upon that class?
00:20:19 <sjanssen> depends
00:20:35 <sjanssen> do you anticipate that instances will need to override these operations?
00:20:39 <ivanm> no
00:20:59 <ivanm> so write them separately?
00:21:04 <sjanssen> separate is better in that case
00:22:24 <ivanm> *nod*
00:52:37 <LeCamarade> Any of you guys understand Wikipedia format syntax? I was 'pposed to add Haskell to the Serialization page, but ... I may fuck things up.
00:52:58 <LeCamarade> Serialization, with deriving (Read, Show)
00:53:48 <LeCamarade> ?users
00:53:48 <lambdabot> Maximum users seen in #haskell: 420, currently: 352 (83.8%), active: 5 (1.4%)
00:54:39 <jeffz> LeCamarade: it's not hard to get right if you preview your edits before submitting the change.
00:55:16 <LeCamarade> Yeah, but I'm fresh from a shock. I nearly murdered a whole page. Need to spend a week in the sandbox.
00:58:00 <hpaste>  ac pasted "Why does this cause a stack space overflow?" at http://hpaste.org/3466
00:58:20 <LeCamarade> The best part about having a single point where internal state is constructed (like Haskell constructors) is with serialization.
00:58:26 <ac> (when w is semi-large)
01:00:15 <LeCamarade> w is semi-large and ^ 3?
01:00:21 <LeCamarade> And made ^ 3?
01:00:28 <doserj> ^2
01:00:40 <LeCamarade> ^ 2, yes.
01:00:59 <LeCamarade> And the result * 3. Heh. You're a sadist, ac.
01:01:03 <sjanssen> ac: the problem is mapM, most likely
01:01:07 <sjanssen> @type mapM
01:01:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:01:23 <ac> lambdabot: a sadist?
01:01:40 <sjanssen> the m [b] return type makes it run in O(n) stack
01:01:45 <sjanssen> @type mapM_
01:01:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
01:02:09 <ac> I see
01:02:11 <sjanssen> notice the m (), it forgets the result of mapping and is O(1) stack
01:03:04 <ac> but pokeByteOff returns -> IO ()
01:03:27 <sjanssen> mapM still has to build the list, even though it's just a list of ()'s
01:04:01 <ac> surprise! it's much faster now too
01:04:28 <ac> I figured that was taking too long for me to be doing things right
01:04:43 <sjanssen> ac: your mapM looks a bit like pokeArray
01:04:47 <sjanssen> @hoogle pokeArray
01:04:48 <lambdabot> Foreign.Marshal.Array.pokeArray :: Storable a => Ptr a -> [a] -> IO ()
01:04:48 <lambdabot> Foreign.Marshal.Array.pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
01:05:52 <sjanssen> ac: also, it is generally a good idea to use pokeElemOff over pokeByteOff -- it is more robust to changes in the Ptr's type
01:06:16 <ac> yeah, you mentioned that a little earlier, but this is a quick and dirty experiment
01:06:20 <ac> I copied Zao
01:07:01 <ac> sjanssen: and indeed, pokeArray works splendidly
01:07:16 <joelr1> morning
01:07:31 <ac> sjanssen: what exactly is pokeArary0 for?
01:07:53 <sjanssen> ac: it pokes a 'nil' element at the end, like the C string convention
01:10:03 <ac> sjanssen: is there a way to create a larger chunk, and slide your pointer to it around?
01:10:51 <sjanssen> ac: I don't follow
01:11:08 <sjanssen> ac: you mean pointer arithmetic?
01:11:53 <ac> sjanssen: yeah, I want to make another pointer to buf that's say, 1200 bytes forward
01:12:11 <sjanssen> @hoogle plusPtr
01:12:15 <lambdabot> Foreign.Ptr.plusPtr :: Ptr a -> Int -> Ptr b
01:12:34 <sjanssen> I think that one advances by bytes, but you should double check
01:12:48 <ac> neat. Haskell's C interface is similar to Chicken Scheme's
01:13:21 <ac> I guess I shouldn't call it "C". In Chicken it's called lolevel
01:14:01 <pierre-> hello
01:17:02 <pierre-> can you recommend me some library for dynamic arrays -- which performs O(1) for insertion?
01:17:16 <ketil> ac: s/C interface/FFI/?
01:17:33 <ac> ketil: I just mean its library for bit twiddling
01:18:03 <sjanssen> pierre-: do you mean insertion or update?
01:18:26 <ketil> ac: okay, never mind, I just popped by without reading too much of the preceeding discussion.
01:18:27 <sjanssen> pierre-: DiffArray provides O(1) update
01:19:04 <pierre-> sjanssen: i'm mostly interested in insertion
01:19:12 <pierre-> thanks, i'll take a look
01:20:14 <sjanssen> pierre-: you probably want to use Data.Map
01:20:36 <sjanssen> insertion is O(log n), which is O(1) in practice
01:21:22 <quicksilver> lists have O(1) insertion
01:21:27 <quicksilver> at the 'preferred end'
01:22:04 <quicksilver> Data.Sequence.Seq's have O(1) insertion at both ends
01:22:10 <pierre-> quicksilver: i need also O(1) access
01:22:19 <pierre-> like arrays have
01:22:43 <quicksilver> good luck building that infinite width address bus, then
01:22:48 <quicksilver> cos O(1) access doesn't exist :)
01:23:34 <sjanssen> pierre-: O(1) access and update are difficult in a pure context (impossible actually, without cheating)
01:24:41 <quicksilver> fortunately, O(log n) is better than most people think :)
01:24:54 <quicksilver> in the end the constant factors dominate, for practical programming
01:25:26 <quicksilver> so the question becomes 'is this fast enough in practice for my task' rather than 'what is its asymptotic complexity'
01:25:53 <osfameron> quicksilver++ # pragmatic
01:26:34 <doserj> you can think of O(log n) as a moderately large constant factor
01:27:52 <Thunder> Hi, what's the name of the standard function for divideAndConquer :: ([a] -> ([a],[a])) -> ([a] -> [a] -> [a]) -> [a] -> [a] ?
01:29:47 <mux> I'm not sure there's a standard function for that, though you can implement the first part of this with partition
01:30:27 <quicksilver> there are some fairly natural higher list combinators that don't seem to have names
01:30:52 <pierre-> in fact i want to implement "upside down trees", where for every element i can determine its parent
01:31:17 <quicksilver> there is one which I call 'morph' :: ([a] -> Maybe (b,[a])) -> (b -> [a]) -> [a] -> [a]
01:31:24 <quicksilver> which somehow generalises search and replace
01:32:18 <pierre-> maybe that's already implemented somewhere?
01:32:41 <quicksilver> pierre-: sounds a bit like a zipper?
01:34:55 <pierre-> quicksilver: yes, but i can't figure out how to use it here
01:36:15 <pierre-> perhaps because i'm not so familiar with it
01:37:24 <ac> @hoogle unsafeWrite
01:37:25 <lambdabot> No matches found
01:38:18 <oerjan> @index unsafeWrite
01:38:18 <lambdabot> bzzt
01:48:10 <Thunder> quicksilver: Thanx for the morph.
01:48:19 <tibbe> anyone know if LazyByteString has an invariant that says that Chucks must not be empty?
01:48:29 <sjanssen> tibbe: yes, it does
01:48:43 <tibbe> sjanssen: great
01:48:48 <sjanssen> unless dcoutts changed that with the recent rewrite?
01:49:36 <tibbe> dcoutts: ping
01:49:42 <tibbe> @seen dcoutts
01:49:43 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 1h 2m 8s ago.
01:50:10 <sjanssen> tibbe: I'm fairly certain the invariant still holds
01:50:33 <sjanssen> and by "recent rewrite" I mean the very new stuff in the unreleased bytestring-0.9
01:50:34 <tibbe> sjanssen: ok, I need to find out if it's a part of the interface though, probably not
01:51:07 <sjanssen> it is definitely an invariant in the old list based code
01:52:23 <oerjan> hugs source shows fromChunks ls = LPS $ L.filter (not . P.null) ls
01:53:11 <oerjan> and i guess that is the only function which could have leaked the invariant?
01:54:17 <ac> quicksilver: would you mind pasting/uploading that code?
01:58:06 <LeCamarade> The guy who did reduce definitely didn't know about foldl.
01:58:17 <LeCamarade> It's such a pain when you are used to foldl.
01:58:33 * LeCamarade has to use reduce instead of foldl in Ruby. :o(
01:58:38 <sjanssen> reduce probably predates foldl
01:58:52 <LeCamarade> Yeah, reduce is really old.
01:59:06 <LeCamarade> But its horridness birthed the need for foldl.
01:59:16 <LeCamarade> So, that reduce still. :o)
01:59:25 <LeCamarade> s/that/thank/
02:01:09 <vegai> didn't ruby have something called inject, which is like a fold?
02:02:08 <LeCamarade> vegai: It is like reduce.
02:02:11 <vegai> or was it just an alias for reduce... hmm
02:02:17 <quicksilver> accord to cale's wikipedia page on fold, it's called inject :)
02:02:19 <vegai> oh, ok.
02:02:44 <quicksilver> but rumours suggest Cale is not entirely infallible.
02:02:49 <quicksilver> I've never caught him out myself, mind.
02:03:00 <Cale> quicksilver: Someone else added that comment after
02:03:05 <LeCamarade> But at least there is a lame way to fake pattern matching, which helps reduce (read inject) suck a little less.
02:03:46 <LeCamarade> Cale: cgibbard, Cale, Cale Gibbard, same guy/girl?
02:03:53 <osfameron> "inject" is a terrible name for it
02:03:57 <Cale> Same guy
02:04:10 <vegai> osfameron: and 'foldl' is a great name?
02:04:20 <LeCamarade> I stumble often on your stuff.
02:04:45 <LeCamarade> I wonder who _exactly_ you are. If you are comfortable telling.
02:04:49 <osfameron> vegai: funnily enough, I can understand "folding" the list over and over on itself until it's a single value.  I don't get what "inject" means at all there.
02:04:59 <LeCamarade> (Most people, like me, maintain a bit of anonymity. :o) )
02:05:14 <osfameron> vegai: I do like "reduce" as a name though. Though "reducel" and "reducer" would be odd
02:05:20 <vegai> osfameron: was it like that also before you learned foldl?
02:05:23 <LeCamarade> osfameron: Names are hard. :o)
02:05:26 * vegai shrugs.
02:05:58 <osfameron> vegai: fair enough - maybe I would "get" inject as a name if I used it, dunno
02:06:46 <LeCamarade> I just read `inject' as `reduce' and life goes on.
02:07:09 <LeCamarade> And I use it obscenely frequently - my boss complained, even.
02:08:31 <LeCamarade> Maybe I am just perverted by Haskell. :o(
02:08:39 <osfameron> heh.  I use grep/map/join a lot in Perl and am infecting my colleagues too
02:08:49 <LeCamarade> You know.
02:08:50 <LeCamarade> :o)
02:08:53 <osfameron> don't use the library "reduce" that much, though I do use its max and sum
02:09:31 <LeCamarade> I map over args and then reduce the exit codes of each mapping, and return the result. Very unlike the vanilla thing. :o)
02:10:23 <osfameron> in a dispatcher?
02:10:38 <LeCamarade> In the main function.
02:11:12 <LeCamarade> I write one to deal with a single arg, then map that across @ARGV, then reduce the result with maybe |.
02:11:29 <LeCamarade> And I get to miss lazy eval intermittently. :o)
02:11:51 <osfameron> so that you map over all the args, but return the first valid answer ?
02:12:24 <LeCamarade> Should. Without lazy eval, I just go over all args, even if the first is what I wanted.
02:12:40 <LeCamarade> Haskell can actually do harm if you go back to using inferior tools.
02:12:59 <LeCamarade> Nobody ever warns you, and I think that is unfair. :o)
02:14:05 <osfameron> I think you could do it lazily in Perl with something like firstval map { defer { foo($_) } } @args
02:14:13 <osfameron> (using List::MoreUtils and Scalar::Defer)
02:14:26 <osfameron> granted, that would be a monstruous hack compared to built in laziness :-)
02:14:38 <EvilTerran> map defer { foo $_ }, @args would work, too
02:15:02 <LeCamarade> And considering I moved over to Ruby, CPAN lies beyond reach like the woman on the magazine covers ... :o(
02:15:11 <EvilTerran> and almost makes "defer" look like a proper keyword; a modifier to map() or something
02:15:11 <osfameron> well, you'd need firstval {$_ } or similar to get the first of those that was true
02:15:21 <osfameron> (I think firstval short circuits)
02:15:44 <osfameron> EvilTerran: yes, but non-block map is largely evil (in the sense of biting you in the arse when you least expect it)
02:15:59 <EvilTerran> i've never had any trouble with it, but okay.
02:16:17 <EvilTerran> the trouble with relying on defer{} and whatnot is that it probably won't play nice with existing code
02:16:34 <osfameron> yeah, the source of defer scares me
02:16:52 <EvilTerran> or existing code won't play nice with it; a lot would be stricter than necessary, because they're not expecting laziness
02:17:30 <osfameron> oh, in that sense
02:18:00 <osfameron> well, I think as a perl programmer you wouldn't normally be using laziness-with-everything. Just sprinkling it into use cases like LeCamarade's there
02:18:20 <osfameron> though that might change if it's implemented well and comes into the culture in Perl 6 ;-)
02:18:54 <EvilTerran> that and every other programming novelty ever conceived
02:19:03 <osfameron> :D
02:22:15 <LeCamarade> Perl 6 will rock, irrespective of what happens when it comes out.
02:24:26 <profmakx> Igloo, have you come around to bootstrapping ghc on FreeBSD7/amd64? I cannot seem to make any noteable progress, though i will try again this weekend..
02:29:20 <Radek> Hi. I'm having following newbie problem. Let's say I have expression: (ceiling $ sqrt 10 :: Int) that is of a type Int. But if try to define function : foo :: Int -> Int ; foo x = ceiling $ sqrt x; I get errors . Why??
02:30:13 <EvilTerran> ?type sqrt
02:30:16 <lambdabot> forall a. (Floating a) => a -> a
02:30:23 <EvilTerran> ?instances Floating
02:30:24 <lambdabot> Double, Float
02:31:26 <EvilTerran> do you see?
02:31:26 <tibbe_> can I have pattern guards in lambda expressions?
02:31:54 <Radek> Nope. I don't see how ghci is able to calculate it and give me type Int, and the function I try to write does not compile
02:31:55 <EvilTerran> tibbe_, as far as i know, you can't have any guards in lambdas. but if you can have any, you can almost certainly have pattern guards
02:32:03 <tibbe_> heh
02:32:05 <Radek> :t ceiling
02:32:07 <EvilTerran> Radek, what about the parameter type?
02:32:07 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
02:32:19 <EvilTerran> ?type ceiling . sqrt
02:32:21 <lambdabot> forall b a. (RealFrac a, Integral b, Floating a) => a -> b
02:32:44 <EvilTerran> the first parameter has to be a "Floating" type
02:32:49 <EvilTerran> Int is not Floating
02:32:52 <Radek> EvilTerran: My bad.
02:32:55 <Radek> wait a sec.
02:34:05 <EvilTerran> ?type fromIntegral
02:34:08 <lambdabot> forall a b. (Num b, Integral a) => a -> b
02:34:14 <Radek> so. Now my function looks like: foo x = ceiling $ sqrt (fromInteger x) . It does not compile too.
02:34:23 <EvilTerran> ?type fromInteger
02:34:25 <lambdabot> forall a. (Num a) => Integer -> a
02:34:28 <EvilTerran> Integer /= Int
02:34:45 <EvilTerran> > maxBound :: Int
02:34:47 <lambdabot>  2147483647
02:34:48 <EvilTerran> > maxBound :: Integer
02:34:49 <lambdabot>   add an instance declaration for (Bounded Integer)
02:34:49 <lambdabot>     In the expression: ma...
02:34:57 <Radek> I dont care about maxBound
02:35:01 <Radek> I know about limitation
02:35:08 <Radek> I just want to cut it down to INt
02:35:09 <EvilTerran> Integers are arbitrary length. Ints aren't. is my point.
02:35:13 <Radek> no matter the risk
02:35:22 <EvilTerran> they're different types.
02:35:34 <EvilTerran> the maxBound thing was just my way of illustrating how
02:35:51 <EvilTerran> ?type fromIntegral -- as i was saying
02:35:54 <lambdabot> forall a b. (Num b, Integral a) => a -> b
02:35:56 <EvilTerran> ?instances Integral
02:35:57 <lambdabot> Int, Integer
02:36:25 <Radek> Thanks!
02:36:39 <Radek> I should have used fromIntegral and not fromInteger
02:37:44 <EvilTerran> > map (\x -> (x, head $ dropWhile (\i -> i^2 < x) [0..])) [1..]
02:37:46 <lambdabot>  [(1,1),(2,2),(3,2),(4,2),(5,3),(6,3),(7,3),(8,3),(9,3),(10,4),(11,4),(12,4),...
02:38:37 <EvilTerran> yes
02:38:45 <EvilTerran> hm.
02:39:38 <oerjan> > [(m,n) | n <- [0..], m <- [(n-1)^2+1 .. n^2]]
02:39:40 <lambdabot>  [(1,1),(2,2),(3,2),(4,2),(5,3),(6,3),(7,3),(8,3),(9,3),(10,4),(11,4),(12,4),...
02:41:14 <EvilTerran> well, yes, but i was trying to illustrate the (\x -> ...) bit as a (perhaps better) alternative to ceiling.sqrt.fromIntegral
02:44:43 <LeCamarade> Oh, wait.
02:45:28 <LeCamarade> Oops. Wrong channel.
02:46:10 <oerjan> you mean we can stop waiting now?
02:48:54 <ZeD> lol
02:58:11 <ZeD> Hey guys, I've got a coursework at uni and my code needs some debugging: http://pastebin.com/d6bd1eefc Could anyone help me with this?
03:00:20 <oerjan> you are using a lot of == comparisons where you could use pattern matching
03:00:31 <oerjan> which is more in the haskell style
03:01:15 <mux> yeah
03:01:34 <hpaste>  Japsu pasted "nondeterministic finite automaton" at http://hpaste.org/3467
03:01:34 <mux> I'd write the complement function for BaseUnit, and then I'd juste use map complement to apply it to Strand
03:01:58 <mux> and that would allow to removfe pattern guards in favor of the usual pattenr matching
03:02:22 <ZeD> i see
03:02:24 <mux> ie complement A = T; complement T = A; ...
03:04:15 <oerjan> i see a bug in the first case of myHead
03:04:52 <oerjan> remove :, i think
03:05:19 <ZeD> hmm, cool
03:05:25 <oerjan> and head(x:xs) is just x
03:06:18 <oerjan> myHead and myTail actually exist in the libraries, but i'll leave it to you to find them if you want :)
03:06:28 <oerjan> (under different names)
03:06:55 <ZeD> they are called as head and tail as i remember but they told us to write the functions on our own
03:07:15 <oerjan> no, take and drop
03:08:36 <ZeD> I've found them, will read how they work, hope it helps.
03:43:14 <osfameron> EvilTerran, LeCamarade: that's uglier in Perl than I'd thought http://rafb.net/p/jtkOHN60.html
03:43:16 <lambdabot> Title: Nopaste - lazy list processing in Perl
03:43:40 <osfameron> and also processes the target value twice for some reason
03:47:09 <nominolo> @seen swiert
03:47:09 <lambdabot> I saw swiert leaving #haskell 17m 7s ago, and .
04:05:12 <roconnor> there was no team size limit for ICFP programming prizes?!
04:05:45 <byorgey> roconnor: nope.
04:05:48 <osfameron> so an infinite number of monkeys programming in VBscript could have won!
04:06:04 <osfameron> (if correctly parallelized)
04:06:08 <roconnor> wow
04:06:12 <byorgey> indeed!
04:06:17 <roconnor> I should have got some team members
04:07:06 <mux> osfameron: the problem is that infinitely large groups of monkeys tend to write shakespeare plays for some reason
04:07:19 <byorgey> mux: hahahaha!!
04:07:41 <osfameron> hmmm, that could be a problem
04:10:11 <EvilTerran> @go shakespeare programming language
04:10:13 <lambdabot> http://shakespearelang.sourceforge.net/report/shakespeare/
04:10:13 <lambdabot> Title: The Shakespeare Programming Language
04:10:16 <EvilTerran> problem solved :)
04:10:23 <byorgey> brilliant!
04:10:30 <mux> heh :)
04:12:53 <byorgey> hiya phlpp =)
04:16:46 <phlpp> hi all
04:16:48 <phlpp> :_
04:16:50 <phlpp> :)
04:17:31 <roconnor> next time I'm going to rent a wearhouse and fill it with hackers
04:17:50 <matthew_-> will there be a free coffee machine?
04:18:42 <roconnor> on every desk
04:18:59 <roconnor> there will be no doors
04:19:01 <byorgey> sign me up!
04:19:10 <byorgey> huh, no doors?
04:19:12 <scook0_> roconnor: I see a problem with your cunning plan
04:19:26 <roconnor> The wearhouse will be assembled around the people.
04:19:41 <scook0_> ah, I underestimated your ingenuity
04:19:48 <byorgey> <byorgey> sign me up!  <-- hmm, forget that =)
04:20:16 <Botje> don't worry, monadic escape hatches will be installed.
04:20:17 <matthew_-> ahh, so the first task is to build a warehouse of suitable size?
04:20:57 <mux> byorgey: oh, I meant to tell you, Math.OEIS is sexy :-)
04:20:59 <mux> and fun
04:21:07 <byorgey> thanks, mux!
04:21:41 <roconnor> http://video.google.com/videoplay?docid=147448380581901698
04:21:42 <lambdabot> Title: our ICFP Programming Contest 2006 team
04:21:43 <roconnor> *L*
04:22:06 <roconnor> okay, my team has to make a video afterwards too.
04:22:19 <phlpp> is it possible to download google videos?
04:22:24 <phlpp> i mean when using opera
04:33:15 <quicksilver> 10^17 entries?
04:33:17 <quicksilver> erm...
04:33:26 <quicksilver> I hope he's feeling patient..
04:33:50 <SamB_XP> who's blog are we talking about?
04:34:07 <byorgey> a message on -cafe
04:34:09 <roconnor> > 72*6
04:34:12 <lambdabot>  432
04:34:16 <quicksilver> I'm talking about http://article.gmane.org/gmane.comp.lang.haskell.cafe/30706
04:34:18 <lambdabot> Title: Gmane -- Mail To News And Back Again
04:34:21 <Botje> everybody knows ghc 12.5 can do an infinite amount of work in constant time.
04:34:44 <roconnor> > 17*logBase 2 10
04:34:45 <lambdabot>  56.472777613085164
04:34:49 <SamB_XP> Botje: but that won't be released for another 20 years
04:34:55 <byorgey> assuming you have installed System.Monkeys
04:35:01 <SamB_XP> wait a minute
04:35:08 <SamB_XP> that's not even a release version
04:35:09 <roconnor> > 10^17
04:35:10 <lambdabot>  100000000000000000
04:35:13 <SamB_XP> that's a development version
04:35:21 <roconnor> that seems like a big list
04:35:22 <Botje> of course.
04:35:29 <SamB_XP> I'll wait for 12.6, thank you!
04:35:41 <Botje> Intel and AMD will grant the haskell foundation lots of money to remove that feature in 12.6
04:35:54 <Botje> imagine people not having to buy faster processors!
04:36:10 <scook0_> Botje: hey, there's still scope for decreasing the constant
04:36:10 <quicksilver> well supposing a 1Ghz CPU manage to process 1 entry per second, you're still looking at 10^8 seconds to completion, which is about 1000 years...
04:36:32 <byorgey> you mean 1 entry per cycle?
04:36:57 <wli> quicksilver: So put 12000 1GHz CPU's on it?
04:37:08 <roconnor> @go 10^17 nanoseconds in years
04:37:10 <lambdabot> (10^17) nanoseconds = 3.16887646 years
04:37:18 <quicksilver> wli: yes, that seems like a good plan
04:37:43 <quicksilver> roconnor: do, 1000 DAYS not years :)
04:37:56 <wli> quicksilver: A cluster of 24 SGI Altix systems each with 512 CPU's, perhaps?
04:38:16 <roconnor> @go 1/(1 Gs)
04:38:20 <lambdabot> http://www.amazon.com/Bose-3-2-1-GS-DVD-Entertainment/dp/B0002JY6SQ
04:38:21 <byorgey> well, he DID say he's trying to use parallelism... =)
04:38:46 <wli> quicksilver: Maybe only 4 systems larger than NASA's. Or maybe throw more Altixes at it than that, even, since it's all pure fantasy.
04:39:16 <phlpp> hehe, Math.OESIS could help me with some euler problems i guess ;P
04:39:22 <roconnor> @go 1/(1 nanosecond) in GHz
04:39:23 <lambdabot> 1 / (1 nanosecond) = 1 gigahertz
04:39:39 <roconnor> quicksilver: I stand by my computation
04:40:52 <roconnor> quicksilver: oh wait, you are agreeing with me :)
04:41:01 <roconnor> do = doh
04:41:22 <byorgey> @go 10^17 bytes in PB
04:41:23 <lambdabot> (10^17) bytes = 88.817842 petabytes
04:41:37 <ricky_clarkson> @go 1 AU in furlongs
04:41:38 <lambdabot> 1 Astronomical Unit = 743,647,101 furlongs
04:42:18 <byorgey> so, is someone going to write back to -cafe and call him on the 10^17 thing?
04:42:40 <byorgey> I guess  it probably doesn't matter =)
04:43:07 <Cale> hm?
04:43:36 <koala_man> @go 88 USD/barrel in EUR/liter
04:43:37 <lambdabot> 88 (U.S. dollars / barrel) = 0.527658147 Euros / liter
04:43:59 <byorgey> Cale: meta-hm?
04:44:02 <phlpp> i once subscribed to -cafe
04:44:08 <Cale> 10^17 thing?
04:44:11 <phlpp> few hours later, i noticed it was a mistake :D
04:44:27 <roconnor> I tried compute a list of length 2^308 once
04:44:32 <roconnor> I didn't get very far.
04:44:45 <roconnor> ... stupid powersets
04:44:47 <Cale> oh
04:44:52 <Cale> I see what it is
04:45:21 <Cale> What's wrong with operating on a list of length 10^17?
04:45:31 <roconnor> @go 10^17 nanoseconds in years
04:45:32 <lambdabot> (10^17) nanoseconds = 3.16887646 years
04:45:38 <Cale> so?
04:45:47 <Cale> Maybe you won't use all of it.
04:46:14 <byorgey> that's true, I suppose
04:46:25 <scook0_> Cale: if that's the case, the 10^17 figure isn't really worth mentioning
04:46:52 <scook0_> and remember, that figure assumes one cycle per element, at 1GHz
04:46:59 <Cale> It's worth mentioning because it means that you don't want to do things which are strict in the spine.
04:47:15 <scook0_> if you actually want to *do* something with these elements, that'll cost extra ;)
04:47:38 <scook0_> I see your angle, though
04:47:52 <Cale> It's very easy to have useful lists on that (and larger) orders of magnitude.
04:48:16 <scook0_> but a list of length 10^17 isn't really distinguishable from infinite, is it?
04:48:23 <Cale> Not really.
04:48:52 <ricky_clarkson> > length [1..10^17]
04:48:53 <Cale> Unless, of course, you have a long time.
04:48:53 <byorgey> it is if you employ those monkeys.
04:48:56 <lambdabot> Terminated
04:49:33 * viklund tries to wrap his head around lazily evaluated parallel lists
04:52:27 <Cale> viklund: Supposing you had N processors, you could, when the head of the list was forced, start computing the first N elements in parallel, and only proceed with further computation once the tail was needed.
04:53:17 <viklund> Cale, yes sure, it's just a fun concept
04:53:19 <viklund> I just recently discovered haskell
04:53:41 <Cale> cool, how are you finding it? :)
04:53:45 <viklund> it's fun really fun
04:54:05 <Cale> great :)
04:54:11 <viklund> I have already implemented "Hunt the Wumpus"
04:54:16 <Cale> Let us know if you have any questions of course :)
04:54:35 <viklund> I'm currently reading the "all about monads" tutorial
04:54:50 <viklund> I thought that after that one I will add some monad transformers to the game
04:55:06 <viklund> particularly StateT
04:56:38 <viklund> if anyone could look at my Hunt the Wumpus code and come with critizisms and suggestions that would be great though
04:56:53 <viklund> If you feel you have the time (it's ~400 lines)
04:57:06 <Heffalump> sure
04:57:19 <Cale> I could take a look too, but I'm about to take a nap (I haven't slept)
04:57:42 <viklund> I can paste it on hpaste.org
04:57:55 <viklund> maybe...
04:57:58 <viklund> or online
04:58:20 <Cale> hpaste's size limitation ought to be increased a bit
04:58:36 <roconnor> Cale:  you think?
04:58:38 <viklund> 5k...
04:59:00 <Cale> roconnor: not much, maybe double it.
04:59:06 <viklund> the basic code I found was 200 lines (half of mine) ;(
04:59:33 <roconnor> posters should pay with computing time ... preferably helping do Dominik Luecke's computation :P
04:59:54 <Cale> hehe
05:00:24 <wli> What computation is that?
05:00:27 <hpaste>  viklund pasted "Humpus" at http://hpaste.org/3468
05:00:58 <viklund> didnt work, I'll just put it online then...
05:01:04 <Heffalump> your Eq instance looks a bit dodgy
05:01:24 <viklund> hmm?
05:01:40 <Heffalump> well, it's not equality, or anything close to it
05:01:56 <Heffalump> but if you're aware of the effect this might have on standard functions that use it, it's ok
05:02:57 <viklund> there should only ever be one vertex with each number, so if the numbers are equal, it's the same vertex
05:02:59 <Cale> I find it fun to define instances of Ord which are screwy and see what happens to things like sort ;)
05:03:09 <Heffalump> it's the NullVertex case that's dubious
05:03:22 <Heffalump> you haven't said NullVertex == NullVertex
05:03:27 <viklund> ok, I don't know why I added that really, can't remember...
05:03:29 <viklund> ahh
05:03:30 <roconnor> wli: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/30706
05:03:32 <lambdabot> Title: Gmane Loom
05:04:07 <Cale> concat (map f) x = concatMap f x
05:04:12 <Cale> er
05:04:16 <Cale> concat (map f x) = concatMap f x
05:04:51 <viklund> yes, thx. I just recently discovered concatMap...
05:05:05 * roconnor wonder if NullVertex should be elimitated in favour of using Maybe Vertex
05:05:10 <Heffalump> basically all looks fine, though. Your data structures are rather inefficient but for standard Wumpus boards I doubt that matters.
05:06:10 <Cale> another small style thing is that it's generally considered a little nicer to use (.) when you have long composition chains and apply the resulting function with a $ at the end, rather than using multiple $'s in a row
05:06:52 <roconnor> Also maybe eleminate the Dead player and use a Maybe Player.
05:06:53 <Cale> This is because (f . g) . h = f . (g . h), which means that subsections of the composition chain are then meaningful on their own
05:06:53 <viklund> I haven't gotten used to the . operator yet...
05:07:15 <viklund> I often use lots of $'s and think (I should be able to do this some other way) :)
05:07:25 <Cale> Whereas with f $ g $ h, the f $ g is very unlikely to be meaningful (and certainly won't mean the same thing)
05:07:41 <mux> Cale: yeah, f . g . h $ x is nicer than f $ g $ h $ x
05:07:42 <Cale> You can always rewrite f $ g $ h $ x  as f . g . h $ x
05:08:00 <mux> I actually try to use ($) only rarely
05:08:10 <Cale> and as an added bonus, this sometimes lets you remove the x :)
05:08:15 <mux> right
05:08:18 <mux> that too
05:08:40 <Cale> (and eventually you get used to leaving the x out ahead of time, and then you're a real functional programmer ;)
05:08:58 <mux> wow, I'm a real functional programmer !
05:09:00 <viklund> :D
05:09:14 <roconnor> ... and then you hit the monomorphism restriction :(
05:09:22 * SamB_XP measures mux's nose
05:09:26 <viklund> ok, here they are online:
05:09:28 <Cale> The MR really is very evil.
05:09:28 <viklund> http://artedi.ebc.uu.se/viklund/main.hs
05:09:29 <viklund> and
05:09:41 <viklund> http://artedi.ebc.uu.se/viklund/humpus.hs
05:10:28 <Cale> Do you know about mapM/mapM_ ?
05:10:32 <mux> SamB_XP: how naughty
05:10:48 <MyCatVerbs> viklund: humpus? Hunt the Wumpus in Haskell?
05:10:52 <viklund> cale: yes
05:10:59 <viklund> MyCatVerbs: Yes!
05:11:13 <Cale> viklund: It can be nicer to use than repeated putStrLn's :)
05:12:05 <viklund> yes, well, that was a quick-hack in vim actually..
05:12:18 <Cale> mostly this looks rather well-written, I'd say
05:12:26 <viklund> thanks ;)
05:12:49 <viklund> the thing I'm most dissatisfied with is the user interaction loop
05:12:59 <roconnor> I wish i could convince firefox to interpret haskell files in the same way as text/plain
05:13:00 <Cale> You might try a proper type with record syntax for your game state
05:13:14 <viklund> cale: ?
05:13:30 <Cale> You're currently using a plain triple, which works
05:13:32 <viklund> ahh
05:13:37 <viklund> I understood...
05:13:50 <viklund> took a while though
05:15:09 <viklund> but as I said, I think that the StateT transformer is the next step
05:15:17 <Cale> yeah
05:16:18 <Cale> When you do that, it's a good idea to use a newtype around your StateT or State monad, and use newtype deriving to derive instances of Functor and Monad, but possibly not MonadState, depending on how you want to handle things.
05:17:01 <Cale> If you don't derive MonadState, and don't export the data constructor for your newtype from the module, then it restricts that module to the place where operations acting on the state can be defined
05:17:26 <Cale> and you can enforce guarantees (from outside the module) about the consistency of the state
05:17:37 <viklund> ok, nice
05:17:46 <Cale> I have a little article about that...
05:18:13 <viklund> good, I think I need to ponder that a bit
05:18:26 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
05:18:28 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
05:20:44 <viklund> thanks a lot for the input, I'll post my progress with the State transformer
05:26:22 <phlpp> hm
05:27:22 <phlpp> > (\x n -> (x^2^(n+1)) * (x^2^(n+1))) == (\x n -> x^(4*n+4)
05:27:22 <lambdabot>  Unbalanced parenthesis
05:27:24 <phlpp> > (\x n -> (x^2^(n+1)) * (x^2^(n+1))) == (\x n -> x^(4*n+4))
05:27:27 <lambdabot>   add an instance declaration for (Eq (a -> a1 -> a))
05:27:27 <lambdabot>     In the expression:
05:27:27 <lambdabot> ...
05:27:46 <phlpp> hm, is it possible to prove 'abstract' expressions on equality?
05:28:03 <phlpp> what i want to 'proof' is if (x^2^(n+1)) * (x^2^(n+1)) is x^(4n+4)
05:28:16 <nornagon> i think that's a little bit tricky to do in general
05:28:21 <nornagon> you can use quickcheck
05:29:09 <nornagon> @check (\x n -> (x^2^(n+1))*(x^2^(n+1)) == (x^(4*n+4)))
05:29:10 <lambdabot>  Add a type signature
05:29:23 <nornagon> @check (\x n -> (x^2^(n+1))*(x^2^(n+1)) == ((x::Double)^(4*(n::Double)+4)))
05:29:24 <lambdabot>   add an instance declaration for (Integral Double)
05:29:39 <nornagon> @check (\x n -> (x^2^(n+1))*(x^2^(n+1)) == ((x::Integer)^(4*(n::Integer)+4)))
05:29:41 <lambdabot>  Falsifiable, after 2 tests: 2, -1
05:29:57 <phlpp> hmm, that's odd.
05:30:13 <nornagon> maybe check precedences?
05:30:17 <phlpp> because when evaluating this on a sheet of paper, i come to this resul
05:30:19 * SamB_XP hopes he isn't becoming lactose intollerant like his mother
05:30:28 <phlpp> its because of
05:30:33 <nornagon> phlpp: maybe you made a mistake ;P
05:30:36 <phlpp> x^y^z = x^(y*z)
05:30:50 <phlpp> and x^z * x^y = x*(z+y)
05:30:51 <nornagon> or maybe you typo'd
05:31:42 <nornagon> @check (\x n -> ((x^2)^(n+1))*((x^2)^(n+1)) == ((x::Integer)^(4*(n::Integer)+4)))
05:31:43 <lambdabot>  Exception: Prelude.^: negative exponent
05:32:14 <nornagon> @check (\x' n' -> let { x = abs x'; n = abs n' } in ((x^2)^(n+1))*((x^2)^(n+1)) == ((x::Integer)^(4*(n::Integer)+4)))
05:32:16 <lambdabot>  OK, passed 500 tests.
05:32:28 <phlpp> ah, so it's ok?
05:32:32 <nornagon> yep
05:32:34 <phlpp> cool
05:32:48 <phlpp> i thought a theorem prover is for sth. like this
05:32:49 <phlpp> hehe
05:33:05 <nornagon> i imagine there are some
05:34:14 <SamB_XP> @check proves very little
05:34:14 <lambdabot>   Not in scope: `little'
05:34:18 <SamB_XP> heh
05:34:32 <SamB_XP> I never understand why GHC complains last-to-first...
05:41:59 <haraldk> The gtk2hs packages in Ubuntu Gutsy gibbon...
05:42:25 <haraldk> do they really depend on ghc being version 6.6 and not 6.6.1?
05:42:33 <haraldk> Or do they just say that?
05:42:56 <ivanm> haraldk: probably compiled with 6.6, so yes
05:43:23 <ivanm> @doc IArray
05:43:23 <lambdabot> IArray not available
05:43:28 <ivanm> @doc Array
05:43:28 <lambdabot> Array not available
05:43:28 <masak> @join #bioclipse
05:43:29 <lambdabot> Not enough privileges
05:43:38 <ivanm> @doc Data.Array.IArray
05:43:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
05:43:38 <masak> :( does anyone here have enough privileges?
05:43:51 <ivanm> masak: dons, I guess :p
05:43:56 <SamB_XP> masak: you could build your own...
05:44:05 <masak> SamB_XP: :)
05:44:15 <SamB_XP> it's been done before
05:44:29 <ivanm> yeah, _someone_ had to write lambdabot after all!
05:44:44 <SamB_XP> and how do you think all these plugins were tested?
05:45:11 <SamB_XP> I had to build it to test @google, etc.
05:45:37 <SamB_XP> but some others have actually built it in order to use it, too
05:45:42 <masak> SamB_XP: I guess that's really what I should do. not sure I have a convenient place to run it from, though
05:45:49 <nornagon> i thought someone just wrote a lambdabot plugin to write lambdabot
05:46:10 <ivanm> nornagon: lol
05:46:25 <ivanm> @quote nornagon i thought someone just wrote a lambdabot plugin to write lambdabot
05:46:25 <lambdabot> No quotes for this person. stty: unknown mode: doofus
05:46:30 * SamB_XP waits for someone with privs to bring lambdabot into the conversation
05:46:34 <ivanm> hmmm???
05:46:45 <nornagon> ivanm: i think it's @remember
05:46:49 <ivanm> duh
05:46:53 <ivanm> @remember nornagon i thought someone just wrote a lambdabot plugin to write lambdabot
05:46:53 <lambdabot> Done.
05:47:39 <allbery_b> @listchans
05:47:40 <lambdabot> ##logic #darcs #friendly-coders #gentoo-haskell #ghc #haskell #haskell-blah #haskell-overflow #haskell-soc #haskell.es #jtiger #parrot #perl6 #scala #scannedinavian #unicycling #xmonad weird#
05:47:40 <lambdabot> quakenet:#kedja
05:49:13 <MyCatVerbs> How do you put guards into anonymous functions, please? GHC seems to be telling me that both (\l -> | bool1 = foo; | bool2 = foo2;) and (\l | bool1 = foo; | bool2 = foo2) are illegal.
05:49:24 <ivanm> with arrays, I want to be able to update some values by applying a function to them... is there any way of doing this without either 1) getting the assocs list, mapping and then converting back into the array or 2) extracting the values, applying the function and then updating with the new values?
05:50:51 <SamB_XP> @hoogle (e -> e') -> Array i e -> Array i e'
05:50:51 <lambdabot> Did you mean: (e -> E') -> Array i e -> Array i E'
05:51:12 <SamB_XP> @hoogle (a -> b) -> Array i a -> Array i b
05:51:13 <lambdabot> No matches, try a more general search
05:51:19 <SamB_XP> @doc Data.Array
05:51:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
05:51:20 <allbery_b> ivanm: (//)?
05:51:37 <ivanm> allbery_b: but that replaces the values... I want to apply a function to two specific values only
05:51:48 <ivanm> and arrays can only map on either the elements or the indices, not both
05:51:49 <Heffalump> MyCatVerbs: you can't do it without a case
05:51:51 <SamB_XP> fmap!
05:52:07 <ivanm> SamB_XP: what's the fmap for arrays?
05:52:08 <SamB_XP> ivanm: oh, only two falues>?
05:52:14 <ivanm> yeah
05:52:18 <Heffalump> \x -> case x of _ | bool1 = foo ; _ | bool2 = bar -- yes, I know it's ugly
05:52:20 <MyCatVerbs> Heffalump: ah, I see. \l->case l of...?
05:52:24 <ivanm> an object is moving from one cell to another
05:52:33 <SamB_XP> / and !, then
05:52:40 <SamB_XP> er
05:52:50 <SamB_XP> stupid client swallowed a /
05:52:56 <MyCatVerbs> Heffalump: thanks. Guess I'll just use a named function instead then, it's not like where clauses are particularly onerous. Handy to know. ^_^
05:52:58 <allbery_b> leading / is command
05:53:13 <SamB_XP> I know, I know
05:53:18 <ivanm> SamB_XP: yeah, so I have to extract them and then update?
05:53:23 <SamB_XP> but I wish these clients could read minds :-(
05:53:26 * ivanm was hoping there'd be a better way
05:53:30 <ivanm> SamB_XP: true
05:53:31 <MyCatVerbs> SamB: /say /read /my /mind
05:53:42 <ivanm> /read /my /mind
05:53:43 * allbery_b thought there was something like State's modify, but apparentlynot
05:53:49 <ivanm> MyCatVerbs: didn't do much...
05:53:55 <SamB_XP> //
05:53:58 <MyCatVerbs> SamB_XP: alternatively, start typing RFC1459 natively into netcat. Screw IRC clients. :)
05:54:14 <SamB_XP> MyCatVerbs: I'm not fast enough on the login :-(
05:54:15 <MyCatVerbs> That way there are *no* /foo commands.
05:54:35 <MyCatVerbs> SamB_XP: you don't need to be particularly fast. I do it to freenode all the time.
05:54:49 <MyCatVerbs> SamB_XP: only IRC network I ever have difficulty getting into that way is gamesurge.
05:54:51 <SamB_XP> O'
05:55:01 <SamB_XP> I've timed out several times trying that trick
05:55:07 <phlpp> @check (\x n -> ((x**2)**(n+1))*((x**2)**(n+1)) == ((x::Double)**(4*(n::Double)+4)))
05:55:09 <lambdabot>  Falsifiable, after 8 tests: 3.2, -4.25
05:55:14 <phlpp> ._
05:55:21 <MyCatVerbs> NICK MyCatSchemes \n PASS FooBarBaz \n USER richard a a :Richard B -- done
05:55:22 <SamB_XP> phlpp: floating point is evil
05:55:24 <allbery_b> "yay" floating point
05:55:28 <phlpp> ah
05:55:31 <phlpp> that's the point
05:55:36 <MyCatVerbs> (Obviously my password isn't actually FooBarBaz, but you get the picture.)
05:55:58 <SamB_XP> MyCatVerbs: I sure hope that's not your password for at least two reasons
05:56:07 <phlpp> so you mean it's possible this expression is true, but because of floating point numbers it gets falsifiable?
05:56:32 <SamB_XP> phlpp: hmm, probably not
05:56:43 <MyCatVerbs> SamB_XP: it isn't. I'm not *that* stupi... well, I *am* that stupid, but not in this instance.
05:57:09 <SamB_XP> phlpp: unless that's a really crazy expression
05:57:12 <MyCatVerbs> Anyway, lecture.
05:57:19 <SamB_XP> since -4.5 and 3.2 are really far apart
05:57:33 <phlpp> SamB_XP: hmm, see above. when using integers and ^, it's true for 500 tests
05:57:41 <phlpp> (so only positive nums were tested)
05:58:06 <SamB_XP> no, wait, that was input...
05:58:11 * SamB_XP silly
05:58:20 <phlpp> but it has to be true for negative values, too. or do 'power laws' (dont know english term) are only correct for natural N?
05:58:24 <phlpp> or lets say integers
05:58:50 <phlpp> ah i see
05:58:52 <SamB_XP> > (\x n -> (((x**2)**(n+1))*((x**2)**(n+1)), ((x::Double)**(4*(n::Double)+4)))) 3.2 (-4.5)
05:58:54 <lambdabot>  (8.47032947254299e-8,8.470329472542997e-8)
05:59:03 <SamB_XP> ah, yes, those are really close
05:59:05 <SamB_XP> see?
05:59:27 <phlpp> je
05:59:38 <wli> Integer powers.
06:00:03 <wli> You get multivalued shenanigans for non-integral powers.
06:00:23 <SamB_XP> wli: true...
06:01:19 <quicksilver> although there are ways of choosing a principal value
06:01:24 <quicksilver> which make sense of them in many cases
06:01:33 <SamB_XP> @check (\x n -> ((x^2)^^(n+1))*((x^2)^^(n+1)) == ((x::Rational)**(4*(n::Integer)+4)))
06:01:33 <quicksilver> there are still singularities in the picture though
06:01:34 <lambdabot>  Couldn't match expected type `Rational'
06:02:10 <SamB_XP> @check (\x n -> ((x^2)^^(n+1))*((x^2)^^(n+1)) == ((x::Rational)^^(4*(n::Integer)+4)))
06:02:13 <lambdabot>  Exception: Ratio.%: zero denominator
06:03:02 <SamB_XP> @check (\x n -> (n /= -2) ==> ((x^2)^^(n+1))*((x^2)^^(n+1)) == ((x::Rational)^^(4*(n::Integer)+4)))
06:03:03 <lambdabot>  Exception: Ratio.%: zero denominator
06:03:21 <SamB_XP> @check (\x n -> (x /= 0) ==> ((x^2)^^(n+1))*((x^2)^^(n+1)) == ((x::Rational)^^(4*(n::Integer)+4)))
06:03:23 <lambdabot>  OK, passed 500 tests.
06:04:44 <phlpp> ah cool
06:05:04 <phlpp> ^^ is operator for 'to the power of' for rationals?
06:05:26 <quicksilver> it's a more general (^)
06:05:31 <quicksilver> it's not only for rationals
06:05:32 <quicksilver> :t (^)
06:05:35 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:05:36 <quicksilver> :t (^^)
06:05:38 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
06:05:42 <phlpp> ah ok
06:05:44 <phlpp> cool
06:06:00 <quicksilver> it is still only integer exponents
06:06:04 <quicksilver> but it permits negatives
06:06:10 <quicksilver> and thus, requires a fractional base
06:06:31 <phlpp> maybe it's because of my bad english, but when is 'Integral' used, when Integer, and when is Int used? i know there are differences in the size of Int and Integer. but its also because of something like 'fromIntegral'
06:06:33 <quicksilver> then (**) is the more general one
06:06:50 <phlpp> is this just becaues of strict typing? in other languages it would be sth. like 'fromInteger' i think
06:06:52 <opqdonut> phlpp: Integral is the typeclass of Int and Integer
06:06:55 <quicksilver> phlpp: Integral is for any type which (only) supports whole numbers
06:07:07 <quicksilver> phlpp: so there is Int, Integral but also smaller things like Int16, Word16 etc etc
06:07:11 <opqdonut> ?instances Integral
06:07:12 <lambdabot> Int, Integer
06:07:15 <SamB_XP> quicksilver: uh
06:07:17 <phlpp> ah ok
06:07:25 <SamB_XP> you said Int, Integral
06:07:30 <quicksilver> oops
06:07:40 <quicksilver> Int, Integer but also smaller things like Int16, Word16, etc :)
06:07:54 <phlpp> hehe
06:08:10 <phlpp> one day i have to study the whole prelude and the stuff around it :D
06:08:50 <allbery_b> @instances-importing Data.Word Foreign.C.Types Integral
06:08:51 <lambdabot> CChar, CInt, CIntMax, CIntPtr, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort, CWchar, Int, Integer, Word, Word16, Word32,
06:08:51 <lambdabot> Word64, Word8
06:11:37 <SamB_XP> you forgot Data.Int
06:13:49 <Thunder> @hoogle app
06:13:49 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
06:13:49 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
06:13:49 <lambdabot> Ratio.approxRational :: RealFrac a => a -> a -> Rational
06:14:31 <Thunder> @hoogle ap
06:14:31 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
06:14:32 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
06:14:32 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
06:15:43 <Thunder> @pl what f x = (x,f x)
06:15:44 <lambdabot> what = ap (,)
06:16:18 <opqdonut> :))
06:16:44 <mux> Thunder: another usual way to write this is "second f"
06:17:01 <quicksilver> although I dislike the name 'second'
06:17:08 <opqdonut> :t second
06:17:08 <mux> *nods*
06:17:13 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
06:17:17 <wli> id &&& f
06:17:19 <quicksilver> I prefer the suggested mapSnd or fmapSnd
06:17:21 <mux> first/second aren't really good names
06:17:29 <mux> mapFst and mapSnd look ugly to me
06:17:34 <quicksilver> yes, they are ugly
06:17:35 <mux> but I agree they are better names.
06:17:39 <quicksilver> but at least they say what they mean :)
06:17:58 <mux> > (second (+2)) ('a',1)
06:18:00 <lambdabot>  ('a',3)
06:18:03 <quicksilver> it would be nice if we could selector Functor instances with some syntax
06:18:11 <wli> second f . join (,)
06:18:14 <quicksilver> and perhaps write fmap<snd> or fmap#snd
06:18:29 <quicksilver> although those are also both a bit ugly
06:18:32 <opqdonut> quicksilver: it would be nice if we could selector instance with some syntax
06:18:37 <opqdonut> *instances
06:18:40 <mux> fmap<snd> looks like C++ templates stuff :-)
06:18:53 <quicksilver> opqdonut: well yes, that's what I meant
06:18:55 <nornagon> don't swear :(
06:18:59 <quicksilver> mux: yes, because it's a similar idea :)
06:19:05 <Heffalump> nornagon: it's a functional language...
06:19:08 <opqdonut> for example Ord and Monoid instances are in dire need of something like that
06:19:14 <quicksilver> agreed entirely
06:19:15 <opqdonut> different tuple orderings for example
06:19:29 <quicksilver> I quite like the idea of lexical instance chooser
06:19:39 <opqdonut> lexical as in?
06:19:43 * Thunder will not use Control.Monad.ap in the (-> r) Monad for his lecture.
06:19:54 <quicksilver> with (MultiplicativeMonoid Int) (4 `mappend` 5)
06:20:08 <opqdonut> ah
06:20:17 <quicksilver> in the scope of the 'with', the chosen Monoid instance is the 'default' one
06:20:32 <quicksilver> of course mappend itself is ugly, but that's a different debate :)
06:20:38 <opqdonut> yep
06:20:41 <quicksilver> if choosing instances was easier maybe we could use ++ for mappend :)
06:20:43 <Thunder> @pl \xs@(x:_) -> partition (<x) xs)
06:20:44 <lambdabot> (line 1, column 4):
06:20:44 <lambdabot> unexpected "@"
06:20:44 <lambdabot> expecting letter or digit, operator, pattern or "->"
06:20:49 <mux> I think the Monoid class should just be rewritten with ATs
06:21:04 <quicksilver> does that solve the instance selection issue?
06:21:22 <wli> scoped instances would help a lot of things
06:21:28 <Thunder> quickSort = divideAndConquer null (\xs@(x:_) -> partition (<x) xs) (++)  -- Much cleaner now.
06:21:43 <mux> quicksilver: mm, I think I may have just said bullshit =)
06:22:19 <hpaste>  thammers pasted "nix expression for i810switch" at http://hpaste.org/3469
06:22:22 <quicksilver> Thunder: yes, that's ratehr nice
06:23:11 <Thunder> quicksilver: I'm brushing up the Sedgwick for C-starters while explaning the algorithms in Haskell on the slides.
06:23:20 <wli> (++) was historically for mplus, not mappend.
06:24:04 <quicksilver> wli: that's fair enough. I find myself using monoids more often than monadplusses, personally
06:24:19 <quicksilver> wli: but the thing is, I never actually bother to declare my monoids as instance Monoid
06:24:27 <quicksilver> because there is no real advantage in doing so
06:24:37 <quicksilver> (unless you want to use them in a MonadWriter)
06:25:24 <hpaste>  thammers pasted "nix expression for i810switch" at http://hpaste.org/3470
06:25:26 <wli> It's for the sake of invocation, not implementation.
06:25:36 <quicksilver> also things are quite often monoids in more than one way
06:25:43 <quicksilver> I have animations which are monoidal for example
06:25:57 <quicksilver> but they are monoidal both in parallel as well as serial composition
06:28:24 <wli> Scope control over instances solves it.
06:28:37 <quicksilver> indeed :)
06:28:39 <wli> You need two things.
06:28:43 <igel> hi
06:29:00 <igel> does someone have the link of spj's talk on data parallel haskell?
06:29:15 <wli> (1) some sort of local module importing directive like "local open" in SML
06:29:56 <wli> (2) instances being hideable, qualifiable, and so on in module import directives
06:30:04 <quicksilver> nameable as well
06:30:09 <mux> I wonder if first-class modules could allow us to implement those features directly
06:30:28 <mux> first-class modules + merge of the module and terms languages
06:30:33 <wli> I'm not sure (1) has a direct relationship.
06:30:58 <Heffalump> igel: it should be on www.londonhug.net
06:31:26 <wli> I think (1) can be done without much in the way of other changes.
06:31:46 <quicksilver> (1) is a peice of finer-grained namespace control than we have now
06:31:52 <wli> (2) is the big nasty.
06:31:54 <quicksilver> it's basically just syntax but it would definitely be nice
06:31:57 <igel> Heffalump: thanks :)
06:32:51 * igel is working on parallelism via in functional languages in the seminar :)
06:33:21 <wli> It'd be nice if there were toy language examples showing how to do modules.
06:33:38 <wli> I'm having a tough time brewing up such myself.
06:37:56 <wli> I can see the inference rules etc. for module systems but can't quite figure out from those how they really work in any detail.
06:40:28 <wli> I feel like I understand it until I actually think about doing it.
06:43:08 <pythonist> I need to interface a simple C library, written by myself. I'm considering c2hs and greencard, the first being a bit too complicated and doc-lacking, the second being simpler but (seems to be) unmantained. Any advice?
06:43:42 <mux> pythonist: I've found that if your library is really simple, you won't even need c2hs or anything but you can just use the FFI directly
06:44:17 <mux> c2hs is mostly useful (to me) when you need to deal with many structures, because writing Storable instances isn't exactly super-fun
06:45:42 <pythonist> mux: this is my exact feeling. I haven't investigated using FFI directly as I've found no good tutorial but only the reference specificiations. Any pointer?
06:46:57 <hpaste>  n00b pasted "unlucky & most unlucky" at http://hpaste.org/3471
06:47:06 <n00b> look at that
06:47:33 <Heffalump> pythonist: I generally find Haskell standards, including the FFI one, quite readable and usable directly, but YMMV.
06:49:02 <hpaste>  n00b annotated "unlucky & most unlucky" with "first attempt" at http://hpaste.org/3471#a1
06:49:29 <n00b> look at the previous vs the next attempt
06:49:35 <n00b> see the difference
06:51:08 <pythonist> Heffalump: I'm giving it a second try. Maybe I gave up too early...
06:54:30 <quicksilver> pythonist: see also http://haskell.org/haskellwiki/FFI_Introduction
06:54:31 <lambdabot> Title: FFI Introduction - HaskellWiki
06:54:35 <quicksilver> pythonist: and the cookbook linked from there
06:57:30 <nominolo> @seen swiert
06:57:31 <lambdabot> swiert is in #haskell. I don't know when swiert last spoke.
07:00:57 <hpaste>  lutz@iks-jena.d pasted "Is there a name for this common contruct?" at http://hpaste.org/3472
07:01:23 <pythonist> Heffalump: sorry, I was reading some blog post about FFI...
07:01:28 <pythonist> Heffalump: thanks for the links
07:02:26 <Heffalump> quicksilver provided the links, not me :-)
07:04:34 <mux> pythonist: sorry, got distracted by work; I've used the wiki articles to get up to speed with the FFI
07:12:37 <swiert> hi nominolo
07:12:37 <lambdabot> swiert: You have 1 new message. '/msg lambdabot @messages' to read it.
07:18:09 <mae> is there any way to do variable arguments in haskell (besides passing in an array explicitly)
07:18:48 <allbery_b> @source Text.Printf
07:18:49 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
07:18:51 <Heffalump> you can play games with type classes
07:19:02 <allbery_b> you probably do not want to do this :)
07:19:16 <Heffalump> doing it explicitly would normally be done with an array
07:19:48 <Heffalump> s/array/list/
07:24:08 <quicksilver> hmm
07:24:33 <quicksilver> I wonder if it would be fun to have combinators for graphics which could (a) run in a window and (b) compile to a javascript <canvas>
07:26:12 <dcoutts> I'm sure it would, Richard Bird co-authored a student paper on something like that a few years back
07:26:36 <dcoutts> not with javascript but with the idea of combinators and targeting multiple backends
07:26:42 <dcoutts> like screen, ps etc
07:26:50 <pythonist> mux, Heffalump : I wrote my first (working) FFI's program... thank you!
07:27:31 <Heffalump> dcoutts: who with?
07:27:45 <dcoutts> Heffalump: hmm, don't recall, it's online somewhere
07:28:20 <Heffalump> I'm just failing to find it on his publications page
07:28:41 <mux> pythonist: cool :)
07:29:06 <pythonist> btw, I'm just a novice in Haskell,
07:29:15 <Rebooted> is anyone building web apps with Haskell? what frameworks are you using?
07:29:37 <ivanm> HApps
07:29:53 <pythonist> but I got the Monad wave some time ago, so now lots of previously obscure Haskell snippet are now clear.
07:30:03 <Rebooted> ivanm: not WASH?
07:30:17 <ivanm> I don't use it, so I wouldn't know, but I have heard of HApps
07:30:24 <ivanm> that's what hpaste is written with
07:31:29 <pythonist> I was considering to join a Haskell project to help the community and, at the same time, getting deeper into Haskell under some competent Haskell mentor.
07:31:33 <pythonist> Do you advice any project_
07:31:34 <pythonist> ?
07:32:38 <Rebooted> ivanm: ok, thanks. I'm using Wash but I'm having to constantly patch it myself, so I'm thinking about maybe writing my own framework... i'll check HApps out properly
07:39:14 <Heffalump> pythonist: the database access situation is a bit of a mess
07:39:29 <Rebooted> HApps does seem quite low level compared to WASH
07:41:08 <pythonist> Heffalump: I was thinking of something easier :D
07:42:10 <Heffalump> pick something you're interested in and you think needs improvement
07:47:13 <ivanm> pythonist: pick just about anything, and it needs improvement! :p
07:47:24 <ivanm> maybe look at some of the summer of code proposals or something
07:53:09 <Saizan_> Rebooted: can you point me to a good explanation of the WASH architecture? i.e. which pdf on the homepage should i read first?.)
08:01:08 <wli> I need to figure out how to deal with databases at some point.
08:03:18 <byorgey> wli: send them to their rooms without any supper?
08:03:23 <quicksilver> wli: brutally and with a big stick
08:05:33 <vegai> wli: ditch'em in the gutter
08:09:24 <takamura> hi
08:10:54 <byorgey> hey takamura
08:12:15 <slim> hi, if i have something like: http://rafb.net/p/oyrLAt39.html , what happens on line 7? does y initially have a value ? so that when i compare it to x it's comparing it to what y has, or is y like some sort of null value, so that i'm just checking if x is null
08:12:16 <lambdabot> Title: Nopaste - No description
08:13:26 <quicksilver> slim: you're defining a new function 'newenv'
08:13:35 <quicksilver> slim: and that function takes one paramter, which you've called 'y'
08:13:41 <ZeD> hey, what is arity?
08:13:48 <quicksilver> ZeD: number of parameters
08:14:08 <quicksilver> slim: so the only you actually call newenv, y is set to be te2
08:14:18 <slim> quicksilver: thanx it just clicked :P
08:14:46 <ZeD> cheers
08:17:27 <HaskellBoy> a
08:17:54 <byorgey> b
08:20:28 <matthew_-> the precedence of function application is beyond 9 isn't it?
08:20:45 <mauke> IT'S OVER 9000!!
08:20:47 <matthew_-> which is why you have to have $ with . right?
08:20:56 <mauke> I mean yes
08:20:58 <Syzygy-> mauke: 9000!! is a pretty darn big number.
08:21:02 <quicksilver> function application doesn't have a precedence
08:21:15 <quicksilver> it's in a different syntactic class from the binary ops
08:21:18 <matthew_-> yep.
08:21:23 <matthew_-> that makes sense
08:21:28 <quicksilver> so yes, it binds tighter than any of the binaries
08:22:01 <matthew_-> so the reason why you have to write f . g $ a rather than f . g a is due to the attempt to apply a to g rather than a to f . g right?
08:22:03 <quicksilver> it also binds tighter than the only unary :)
08:22:09 <byorgey> matthew_-: right.
08:22:19 <quicksilver> although normally we talk of applying g to a
08:22:22 <quicksilver> not a to g
08:22:23 <quicksilver> but, yes :)
08:22:25 <matthew_-> ahh. my bad"
08:22:32 <matthew_-> cool. that's good. It means I didn't just lie to the 1st year!
08:22:35 <quicksilver> you could also write (f . g) a
08:22:51 <quicksilver> as opposed to f . (g a)
08:22:57 <quicksilver> and avoid the $ issue for the time being
08:23:01 <matthew_-> good point
08:23:33 <quicksilver> I sometimes prefer that notation
08:23:39 <quicksilver> I've never been keen on $ as a symbol
08:23:45 <quicksilver> a purely aesthetic objection
08:23:56 <quicksilver> reminds me too much of perl and BASIC :)
08:24:09 <matthew_-> heh. I like the f . g . h . ... idea
08:24:30 <Tac-Work> $ is a godsend
08:24:39 <Tac-Work> without it, haskell would look like lisp >____>
08:25:00 <quicksilver> long expressions of one operator are much more pleasant if that operator happens to be associative
08:25:04 <quicksilver> which . is
08:25:17 <quicksilver> that's one good reason to like f . g . h . i . ....
08:25:30 <Tac-Work> there are reasons in haskell not to like . though too
08:25:42 <quicksilver> because you can pull any chunk out as a subexpression, by associativity
08:25:44 <quicksilver> Tac-Work: are there?
08:25:48 <Tac-Work> since it belongs to the clique of syntactic weirdos in the synax of the language
08:26:00 <Tac-Work> along with -
08:26:03 <mauke> huh?
08:26:05 <quicksilver> oh, w.r.t. module names and numbers?
08:26:10 <mauke> oh, that
08:26:12 <Tac-Work> yeah
08:26:15 <quicksilver> yes, true
08:26:25 <quicksilver> it's just too nice a symb ol not to be overloaded
08:26:38 <quicksilver> with spaces areound it there is no risk of ambiguity at least :)
08:26:52 <Tac-Work> really, I'd like to see a language where . is used instead of the `f` in Haskell
08:27:03 <quicksilver> `f`?
08:27:09 <Tac-Work> the backticks
08:27:21 <Tac-Work> and allow it to be used in a unary sense as well
08:27:22 <quicksilver> you want . as an outfix operate which 'infixifies' things?
08:27:29 <Tac-Work> so you could choose between (length x) and x.length
08:27:35 <mauke> ew
08:27:54 <Tac-Work> go ew yourself mauke >___>
08:28:00 <quicksilver> and instead of min x y, you write x.min y?
08:28:00 <mauke> spaces around operators!
08:28:04 <mauke> x . length
08:28:12 <mux> that looks like some OO abuse
08:28:18 <Tac-Work> it would make record syntax nicer, and closer to how it looks in "normal" languages
08:28:24 <matthew_-> hah!
08:28:28 <mrd> objectionable!
08:28:30 <Tac-Work> (it would be syntax, not an operator)
08:28:38 <Tac-Work> (so no spaces!)
08:29:00 <mauke> what does that have to do with it?
08:29:16 <mux> I don't see much sense in syntaxically binding a function with its first parameter
08:29:21 <mauke> also, I don't see how x.length can work with . as syntax
08:29:26 <mauke> lists aren't records
08:29:29 <matthew_-> it creates an even stronger broken illusion to OO languages
08:29:34 <mux> it makes sense for objects, because the dictionary is attached to the value
08:29:50 <mrd> single dispatch OO is already broken, this would be doubly so
08:30:04 <Tac-Work> mattew: every natural language has the idea of a subject or topic, why shouldn't it be at least optional in programming languages?
08:30:23 <mrd> Tac-Work: what's the topic of 1+1?
08:30:28 <mauke> are you talking about perl's $_?
08:31:02 <matthew_-> Tac-Work: why should we pay any attention to languages which are continually evolving due to ill-education, changing media and are observably inefficient?
08:31:08 <idnar> mrd: (1, 1)
08:31:26 <mauke> for (1, 1): +
08:31:28 <mrd> mm, op+ (1,1)
08:31:29 <matthew_-> Tac-Work: sure, we can learn from what's out there, but I don't see any need to conform to it
08:31:30 <Tac-Work> brb
08:31:57 <mrd> we can make our own dumb language design mistakes, tyvm, without any help from java
08:32:07 <idnar> and, yeah, natural languages are probably not the best example to follow :P
08:32:07 <matthew_-> well quite
08:33:51 <Tac-Work> Well, I still feel record syntax in haskell is fugly
08:34:09 <Tac-Work> and no amount of anticonformist radicalism will change my mind on that =-P
08:34:40 * mrd is quite accustomed to accessors, coming from lisp
08:35:00 <mauke> (setf (sqrt x) 2)
08:35:05 <mrd> hehe
08:35:15 <quicksilver> I would like record syntax to autogenerate not only selectores
08:35:22 <quicksilver> but selectors, settors and updators
08:35:34 <quicksilver> that would help the record noise quite a bit in my code
08:35:52 <quicksilver> at the very least it could autogenerate a lens
08:35:55 <Tac-Work> And for the record, no OOP language does selectors right
08:35:56 <quicksilver> then the rest can just be library
08:36:08 <Tac-Work> public int getMyFieldWhichIFrickenDefinedAbove()
08:36:30 <osfameron> selectors == getters ?
08:36:36 <Tac-Work> more or less
08:36:40 <mauke> Tac-Work: not even lisp?
08:36:42 <viklund> quicksilver: what's a lens?
08:36:51 <idnar> Tac-Work: not every OOP language is Java
08:36:54 <quicksilver> viklund: a pair of a gettor and a settor
08:37:01 <mrd> ?quote objectionable
08:37:01 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
08:37:01 <lambdabot>  but then I look at some java code and I'm all happy again
08:37:05 <Tac-Work> C# does it the same way idnar, so does C++
08:37:06 <quicksilver> viklund: (s -> a, s -> a -> s)
08:37:17 <Tac-Work> Java, C#, and C++ are the three most prominent OOPers
08:37:19 <mrd> Tac-Work: yes, but those are all incestuous cousins
08:37:20 <idnar> Tac-Work: you don't need to do that in Python or Ruby, though
08:37:24 <idnar> (for example)
08:37:28 <mauke> Tac-Work: how about javascript?
08:37:39 <mauke> that's very common
08:37:40 <mrd> Tac-Work: think outside the OO box
08:37:45 <idnar> Java, C#, C++ might as well be the same lanugage from that altitude
08:37:56 <mrd> ?quote objectionable
08:37:57 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
08:37:57 <lambdabot>  but then I look at some java code and I'm all happy again
08:37:57 <quicksilver> well you can access fields directly if you wish to
08:38:00 <mrd> darn
08:38:17 <quicksilver> it's just that the common convention is to make fields private and add pointless methods to your interface
08:38:25 <Tac-Work> I use direct access of fields in python all the time
08:38:28 <Tac-Work> is nice
08:40:28 <osfameron> direct access is nice until you realise that you needed to wrap a behaviour around it and then have to refactor all your code
08:40:55 <Saizan_> ruby is nice since you can overload the = operator indipendently for each field
08:41:25 <Tac-Work> python has the generic get and setattr special methods
08:41:31 <Tac-Work> but even those aren't as nice as they could be
08:41:37 <quicksilver> you can do such trickery in C++ too
08:41:46 <quicksilver> although the implementation details of acheiving it may make you ill :)
08:41:59 <quicksilver> such as remembering the difference between a copy constructor and operator=
08:42:21 <mauke> osfameron: in Perl I can go all meta
08:42:25 <quicksilver> lua has a pretty simple metamethod set up that is quite nice
08:42:28 <mauke> tied hashes, etc
08:42:33 <Tac-Work> copy constructors are for when an object is passed over the stack, either as a param or a return value, right? and = is for any inplace assignment
08:42:50 <mauke> C++ doesn't define a stack
08:42:59 <Tac-Work> eh?
08:43:06 <mauke> copy constructors are used for initializing
08:43:11 <mauke> that's why they're constructors
08:43:19 <mauke> operator= is used when you already have an object
08:43:23 <Tac-Work> ah
08:43:52 <mauke> so MyType x = y; // doesn't use operator=
08:44:01 * Tac-Work wonders if he had memory leaks in his data algorithm assignments because of that
08:44:51 <mauke> rule of 3: if you have a non-default implementation of any of {destructor, copy constructor, operator=}, you should probably define all three
08:45:13 <Tac-Work> I try not to use C++ as much as I can humanly help it
08:46:53 <mauke> you should learn about a language's weaknesses so you can quickly kill it if it gets in your way
08:52:26 <osfameron> mauke: yeah, tied hashes are cute.  Or evil (I forget which)
08:52:55 <mauke> osfameron: do you know Attribute::Property?
08:53:36 <chessguy> osfameron, there's a large overlap between those two sets
08:55:24 <osfameron> mauke: nope... I've not really used the attribute modules.  These days to go meta I'd probably start with Moose
08:55:44 <mauke> you're doing it right.
08:56:11 <osfameron> but cute - I always liked lvalue accessors (from my time with VB/VBScript's properties)
08:56:31 <integral> c++ fqa :-)
08:57:20 <mauke> semi-unrelated: if I want to implement MVars in C#, are two semaphores the easiest solution?
09:01:41 <HaskellBoy> lol
09:02:46 <osfameron> integral: yeah!  I like the overview a lot (the individual pages are less funneh)
09:03:49 <integral> I didn't realise C++ was nearly so bad;  I've only written about 20 lines this year :-P
09:18:34 <dons> http://programming.reddit.com/info/5z3xg/comments/
09:18:35 <lambdabot> Title: programming: Simpler, Easier! Or, how to write a simple dependent type checker
09:19:54 <waern> dons: hah! :)
09:22:55 <SUS> HI
09:28:42 <hkBst> what does this @-notation mean? __ where sub e@(Var i) = if i == v then x else e __ Is `e' then a synonym for `Var i' ?
09:29:12 <mauke> yes
09:29:30 <mauke> @ makes aliases
09:31:03 <ukl> like using: hmm@(x:xs)  to access x, the head of the list hmm and xs, its tail while still being able to refer to the whole list using "hmm" (I've seen this once, not sure if it's much of an achievement)
09:33:41 <quicksilver> it saves a bit of memory in principle
09:34:10 <quicksilver> binding a new name to an existing thing, as opposed to constructing a new thing
09:34:29 <quicksilver> in some pathalogical cases it could save a lot of memory
09:35:39 <ukl> ah, i see. thank you :)
09:38:46 <quicksilver> we'd rather shuffle pointers around than construct new data
09:39:01 <quicksilver> although as a result of this philosophy haskell code spends a *lot* of time pointer-shuffling
09:39:04 <quicksilver> ;)
10:07:01 <hpaste>  dons pasted "binary literals in Haskell" at http://hpaste.org/3473
10:07:07 <dons> anyone got some comments on this?
10:07:09 <dons> sorear: ^^
10:07:30 <dons> i'm pondering adding a QC for it, and sticking it on hackage. and filling out the Num class a bit
10:08:13 <twanvl> It looks rather evil to me
10:08:23 <matthew_-> it's not a good idea
10:08:24 <Heffalump> <aol>
10:08:31 <Heffalump> there must be some laws it violates
10:08:51 <matthew_-> literal binaries are needed, but the fact that it's not even statically checked that 2 is not a binary literal is very bad
10:08:56 <sorear> I don't like it
10:08:58 <ddarius> dons: There's not much point.
10:09:03 <dons> hah
10:09:06 <dons> oh you guys!
10:09:18 <matthew_-> you asked, you got a unanimous opinion!
10:09:34 <dons> well, fine, you embed it in the type system then
10:09:35 <ddarius> Since you probably want an actual Integer you'd have to write unBinary 101 in which case you might as well have written bin 101
10:09:59 <ddarius> And as others have said unBinary 123 will just not do the right thing
10:10:14 <dons> i'm not actually suggesting anyone use this library :)
10:10:25 <dons> its just the lightest approach
10:10:37 <matthew_-> do it with TH or something else where you could properly check the minimum requirements
10:10:44 <matthew_-> or just add it to ghc!
10:10:54 <matthew_-> sorry, there should have been quotes around "just"
10:10:56 <lament> :t bin
10:10:57 <ddarius> dons: Again, the lightest approach is probably to use the bin function that was suggested.
10:10:58 <lambdabot> Not in scope: `bin'
10:11:32 <mauke> adding it to ghc shouldn't be too hard. just copy the code for octal constants :-)
10:11:47 <dons> do any languages actually have binary literals?
10:11:50 <matthew_-> yes
10:11:52 <ddarius> Sure
10:12:09 <quicksilver> nobody cares about binary literals. except people who want them.
10:12:14 <mauke> Perl, Lisp
10:12:18 <matthew_-> yeah, I've wanted them in the past
10:12:32 <quicksilver> I've programmed for the best part of 20 years and I never remember wanting them :)
10:12:35 <mauke> perl also supports %b in printf
10:12:38 <lament> i'm guessing more people want binary literals than octal literals?
10:12:39 <ddarius> Anyone who would want them damn well better be able to instantaneously translate to/from hexadecimal
10:12:39 <quicksilver> I may have blotted out the memory though
10:12:44 <wli> Not many. I'd bet endianness usually makes them useless.
10:13:03 <mauke> ddarius: ew, no
10:13:15 <mauke> I'd rather use decimal than hex
10:13:23 <mauke> binary would be best, though (for bit masks, etc)
10:13:29 <ddarius> mauke: For a bit mask?
10:13:34 <mauke> yes
10:13:38 <ddarius> (re using decimal rather than hex)
10:13:53 <mauke> I know my powers of 2, and I know them in decimal
10:13:56 <EvilTerran> i'd use, er, bitshifts
10:14:00 <ddarius> You'd rather write 65535 rather than 0xFFFF?
10:14:00 <dons> we should have something to throw to people who ask for it.
10:14:12 <EvilTerran> and let the compiler inline it if it likes
10:14:16 <dons> so either this or the bin function should be packaged, for those who really care.
10:14:17 <floatcake> hello. i cen not understand the variabels on haskell. where can i find good informations
10:14:19 <mauke> ddarius: hmm, that's a special case. 0xFFFF wins there
10:14:21 <ddarius> mauke: I know my powers of 2 in binary, octal, decimal and hexadecimal
10:14:24 <dons> since its unlikely anyone wants to extend the language for this
10:14:28 <mauke> ddarius: but I'd use 128 over 0x80
10:14:45 <Heffalump> what is the 'bin' function?
10:14:46 <lament> floatcake: it's very easy! Haskell doesn't have variables.
10:14:57 <floatcake> lament: oh how cen i make a value then
10:15:00 <dons> floatcake: do you have a haskell tutorial?
10:15:03 <EvilTerran> Heffalump, it converts 10110 to 0b10110
10:15:03 <Heffalump> can't we just throw a definition to anyone who asks for it, instead of creating a proliferation of tiny packages?
10:15:09 <dons> ?yaht
10:15:09 <lambdabot> Maybe you meant: fact part yarr
10:15:12 <floatcake> dons: no. where cen i find a good one please
10:15:12 <dons> ?where yaht
10:15:12 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
10:15:16 <dons> ^^ is the best one
10:15:23 <dons> you introduce variables with 'let'
10:15:27 <dons> > let x = 2 in x + x
10:15:29 <lambdabot>  4
10:15:32 <dons> or with 'where'
10:15:35 <EvilTerran> it's not in any standard, afaik, but it's quite easy to write
10:15:44 <matthew_-> binary would be good for certain pattern matching
10:16:08 <floatcake> dons: thenks man
10:16:45 <lament> "a constant by any other name..." :)
10:16:52 <floatcake> dons: do haskell use most let or most where
10:17:13 <ddarius> mauke: But what if you want to bitmask off the top three bits of a 16-bit number?  What's the decimal number for 0xE000 or worse, 0xE070 say or any more complicated ones.
10:17:16 <dons> `where' is nice.
10:17:24 <floatcake> dons: okey. thenk u
10:17:31 <dons> do you have ghc or hugs installed?
10:17:41 <mauke> ddarius: I have no idea what 0xE000 is
10:17:47 <mauke> ddarius: I'd use 0b for that
10:17:50 <puusorsa> E IS FOR PANTS
10:18:13 <ddarius> mauke: It's the hex for my description, top 3 bits set for a 16-bit number.
10:18:15 <floatcake> dons: i hev installed ghc from the web
10:18:28 <mauke> ddarius: I'd have to use a calculator
10:18:43 <mauke> or rather, perl -wle 'print for sprintf "%b", 0xE000'
10:18:43 <ddarius> mauke: The benefit of hexadecimal is that you don't.
10:23:29 <ZeD> ---------------------------------------
10:23:29 <ZeD> taxCode :: Int -> Int
10:23:29 <ZeD> taxCode x
10:23:46 <ZeD> sorry, dind't want to paste this
10:24:47 <shapr> @yow
10:24:47 <lambdabot> Was my SOY LOAF left out in th'RAIN?  It tastes REAL GOOD!!
10:27:50 <byorgey> ZeD: what's the problem?
10:32:00 <dcoutts_> @seen pgavin
10:32:01 <lambdabot> I saw pgavin leaving #haskell 1h 52m 34s ago, and .
10:32:32 <dcoutts_> @tell pgavin I'm still having trouble with the gstreamer patches, not all of them apply cleanly. I get conflicts.
10:32:32 <lambdabot> Consider it noted.
10:36:23 <fons> hi all
10:37:09 <byorgey> hi fons!
10:38:14 <ZeD> byorgey: real problem is this
10:38:14 <ZeD> unCompress :: [(BaseUnit, Int)] -> Strand
10:38:14 <ZeD> unCompress [] = []
10:38:14 <ZeD> unCompress [(b, n)] = duplicate (b, n) : unCompress (drop 1 [(b, n)]) n
10:38:33 <ZeD> how shall i place the brackets in order to call every function fine?
10:38:43 <ZeD> (where)
10:39:26 <byorgey> ZeD: I think the [(b,n)] in the second line is probably not what you want.
10:39:36 <ZeD> duplicate :: (BaseUnit, Int) -> Strand
10:39:36 <ZeD> duplicate (b, n)
10:39:36 <ZeD>   | n == 0 = []
10:39:36 <ZeD>   | otherwise = b : duplicate(b, n-1)
10:39:41 <byorgey> ZeD: [(b,n)] is a pattern which only matches a list with a single element.
10:39:59 <ZeD> : byorgey i see
10:40:04 <byorgey> ZeD: also, as an aside, there's already a 'replicate' function in the Prelude
10:40:08 <ZeD> so shall i use (x:xs) then?
10:40:16 <byorgey> > replicate 3 5
10:40:21 <lambdabot>  [5,5,5]
10:40:43 <byorgey> ZeD: probably something like unCompress ((b,n):bns) = ...
10:41:04 <byorgey> which is like (x:xs), but also destructures the x into (b,n)
10:41:07 <ZeD> cool, however it's better for us to define our own functions... Uni exercise...
10:41:17 <byorgey> fair enough =P
10:41:57 <byorgey> ZeD: then, of course, you don't need to use 'drop 1', just call unCompress on bns
10:42:00 <ZeD> however i might try to get it working with replicate and if works, insert my own function
10:42:10 <byorgey> sure
10:42:21 <ZeD> yup but i just suffered so much there that i decided to use drop
10:42:23 <ZeD> (A)
10:42:26 <byorgey> your 'duplicate' looks fine though
10:42:39 <ZeD> yeah, it works
10:42:42 <byorgey> except that it's more common to see it with a type like BaseUnit -> Int -> Strand
10:42:49 <byorgey> i.e. 'curried'
10:43:19 <ZeD> yeah, but they told us what the imput shall be
10:43:30 <byorgey> ZeD: the input for what?
10:43:39 <ZeD> eg parameter for the function
10:43:53 <ZeD> i used the wrong word.
10:44:05 <byorgey> ZeD: right, for which function?  duplicate?
10:44:32 <ZeD> yup, for duplicate... for the second they just told us what it shall do
10:44:39 <byorgey> ah, ok, that's fine then
10:44:45 <ZeD> and obviously they want us to make use of duplicate there
10:44:49 <byorgey> right
10:45:02 <Heffalump> dons: have you heard anything about QC2 getting released?
10:46:19 <dons> Heffalump: we've formed a consortium :)
10:47:45 <Heffalump> so who is working on what?
10:51:00 <dons> Heffalump: the src is at http://code.haskell.org/QuickCheck/
10:51:01 <lambdabot> Title: Index of /QuickCheck
10:51:09 <dons> and we've got koen on board, thanks to andy gill's work
10:51:35 <ZeD> byorgey: I think this is getting closer to the solution but still not sure about the square brackets
10:51:36 <ZeD> unCompress :: [(BaseUnit, Int)] -> Strand
10:51:36 <ZeD> unCompress [] = []
10:51:36 <ZeD> unCompress (x:xs) = duplicate x : unCompress drop (1 (x:xs))
10:53:18 <ZeD> anyone any suggestion?
10:54:33 <asmanur> isn't drop 1 (x:xs) equivalent to xs ?
10:54:35 <Botje> i'm guessing it's probably duplicate x : unCompress xs
10:55:29 <Heffalump> dons: yeah, I've got that. Cool.
10:56:25 <ZeD> ERROR "/home/u06/a6365684/CSC2001/assignment.hs":62 - Type error in application
10:56:25 <ZeD> *** Expression     : duplicate x : unCompress xs
10:56:25 <ZeD> *** Term           : duplicate x
10:56:25 <ZeD> *** Type           : [BaseUnit]
10:56:25 <ZeD> *** Does not match : BaseUnit
10:57:03 <asmanur> ZeD: what should your function do ?
10:57:18 <ZeD> interesting coz unCompress xs shall be on [BaseUnit] I'd guess
10:58:12 <ZeD> a function duplicate which given a (base, number) pair returns a sequence consisting of that base duplicated the appropriate number of times.
10:58:12 <ZeD> (ii)	a function which can uncompress a run-length encoding sequence into the corresponding strand of DNA.
10:58:43 <ZeD> duplicate :: (BaseUnit, Int) -> Strand
10:58:43 <ZeD> duplicate (b, n)
10:58:43 <ZeD>   | n == 0 = []
10:58:43 <ZeD>   | otherwise = b : duplicate(b, n-1)
10:58:43 <ZeD> -- Task 5 part ii
10:58:44 <ZeD> unCompress :: [(BaseUnit, Int)] -> Strand
10:58:46 <ZeD> unCompress [] = []
10:58:48 <ZeD> unCompress (x:xs) = duplicate x : unCompress xs
10:59:22 <mauke> ZeD: what does : do?
11:00:50 <ZeD> yeah (forgot the name) append operator, add value to the front of the list
11:01:31 <asmanur> ZeD: does duplicate return a 'value' ?
11:02:12 <ZeD> a Strand that is a list of base types (eg G, T, A and C enums)
11:02:39 <mauke> ZeD: that's not "append"
11:02:41 <ZeD> so yes it does
11:02:55 <mauke> append would join two lists
11:03:05 <mauke> (:) doesn't take two lists
11:06:16 <ZeD> ok, managed to return a list of Strands, now will just "add them all together"
11:06:20 <ZeD> and it shall work ;)
11:06:45 <mauke> do you know about (++)?
11:06:56 <ZeD> yeah ;)
11:08:24 <tibbe> can I use coarbitrary in QuickCheck to generate functions of type Word8 -> Bool ?
11:08:36 <ZeD> mauke: cheers, it works now
11:08:37 <ZeD> unCompress :: [(BaseUnit, Int)] -> Strand
11:08:37 <ZeD> unCompress [] = []
11:08:37 <ZeD> unCompress (x:xs) = duplicate x ++ unCompress xs
11:08:55 <mauke> looks sane
11:10:50 <asmanur> but you're not returning a list of strands ZeD (maybe it's not what you want).
11:11:17 <ZeD> i wanted to return a single strand so hence i'm done with this part
11:11:29 <asmanur> ok ok
11:12:30 <ZeD> next exercise is to give two strands and the program shall tell, if the 1st strand is the substrand of the second
11:12:43 <lament> Would "let unCompress = join . (map duplicate)" do the same thing?
11:12:53 <ZeD> is there any library function for searching for sublists?
11:13:01 <mauke> :t join . (map ?duplicate)
11:13:04 <lambdabot> forall a a1. (?duplicate::a1 -> [a]) => [a1] -> [a]
11:13:33 <lament> where Strand is [a]
11:13:37 <mauke> lament: yes. and since join on lists == concat, you can just use concatMap duplicate
11:13:49 <mauke> or concatMap (uncurry replicate)
11:13:51 <lament> oh
11:14:06 <mauke> ZeD: isInfixOf
11:14:23 <ZeD> it's getting a bit high level for me atm, will read upon concatMap and then on isInfixOf
11:15:51 <asmanur> can darcs push via ftp ?
11:16:03 <mrd> augustss: nice post
11:16:03 <lament> ZeD: it seems that whenever there's a (x:xs) type of recursion, it can be made implicit by the use of primitives
11:16:24 <lament> (usually)
11:20:02 <exDM69> lament: what are primitives? (newbie question)
11:20:13 <exDM69> fold, filter, etc?
11:20:15 <ZeD> like integers, floats, booleans
11:20:22 <lament> sorry, i didn't mean primitives, i meant fold, filter, etc
11:20:32 <exDM69> ah, yes
11:20:35 <ZeD> okey-dokey
11:20:44 <lament> they're usually defined in prelude
11:23:12 <augustss> mrd: thanks
11:25:22 <byorgey> augustss: I concur.  I think my mind just expanded by 2 sizes. =)
11:27:58 <mrd> augustss: one quick question. sometimes you write "\x:*;..."
11:28:04 <mrd> is that a typo?
11:28:08 <augustss> yes
11:28:16 <ZeD> When was this isInfixOf function added to the libraries?
11:28:31 <ZeD> We use an archeological version of Hugs.
11:28:33 <mauke> recently
11:28:45 <byorgey> ZeD: have you imported Data.List?
11:28:47 <mauke> hugs may not even have it
11:29:07 <ZeD> cool, i'll find it's source code and use it as an idea to write mine
11:29:38 <augustss> mrd: there's so many ';' when typing the HTML for all that greek :)
11:29:40 <byorgey> @src isInfixOf
11:29:41 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
11:29:52 <mrd> wow you typed that in html?
11:29:58 * byorgey boggles
11:30:12 <oerjan> hm, isInfixOf is in my hugs
11:30:34 <byorgey> oerjan: but is yours archaeological?
11:30:48 <oerjan> no, it's the latest release
11:30:55 <dons> oerjan: you don't have a ghc?
11:31:02 <oerjan> nope :)
11:31:04 <dons> why?
11:31:23 <ZeD> Prelude> :version
11:31:23 <ZeD> -- Hugs Version December 2001
11:31:24 <oerjan> because i'm even lazier than haskell?
11:31:39 <ZeD> oerjan: lol
11:31:45 <dons> ZeD: whoa.
11:32:36 <ZeD> i dunno if it knows isPrefixOf :S
11:32:45 <byorgey> @src isPrefixOf
11:32:45 <lambdabot> isPrefixOf [] _          = True
11:32:45 <lambdabot> isPrefixOf _  []         = False
11:32:45 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
11:32:54 <oerjan> isPrefixOf is from the report, i think
11:32:59 <ZeD> i might use this lambdabot
11:33:38 <ZeD> how do you feed into it multiple lines of code?
11:33:41 <mrd> that isInfixOf isn't so wonderfully efficient though
11:33:46 <mauke> ZeD: you need to import List first
11:33:48 <dons> ZeD: you load it from a file.
11:33:56 <dons> but for the best haskell experience, I strongly suggest installing ghc
11:34:06 <dons> its just a lot more useful than hugs
11:34:17 <byorgey> ZeD: you mean how do you feed lambdabot multiple lines of code?
11:34:20 <ZeD> yeah but i started to work with haskell yesterday :P
11:34:27 <ZeD> byorgey: yes
11:35:03 <byorgey> > let foo [] = "bar"; foo (x:xs) = x ++ "bar" in foo "blah"
11:35:05 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
11:35:11 <byorgey> woops
11:35:14 <byorgey> well, that's the general idea
11:37:07 <Tobsan> @src map
11:37:07 <lambdabot> map _ []     = []
11:37:08 <lambdabot> map f (x:xs) = f x : map f xs
11:39:05 <ZeD> @src div
11:39:05 <lambdabot> Source not found. You untyped fool!
11:39:17 <ZeD> @ im not a fool
11:40:09 <mauke> @vixen you are the fool
11:40:09 <lambdabot> eh?
11:44:30 <ZeD> and how do you import a source code into ur own?
11:44:43 <augustss> import Foo
11:46:00 <ZeD> my 2001 version of hugs doesnt eat the import function
11:46:11 <mauke> import is not a function
11:46:16 <ZeD> okey, command
11:46:18 <allbery_b> it won't work from the command line, if that's what your'e doingh
11:46:21 <mrd> augustss: hmm, I'm translating a -> b into (Pi "_" (Var "a") (Var "b")), sounds right?
11:46:34 <ZeD> i wanted to correct myself. so it doesn't like the List.hs i downloaded
11:46:36 <augustss> Exactly
11:46:41 * allbery_b doesn't recall how to do it with hugs on the commandline
11:46:56 <ZeD> i've added it to my source code... to the top
11:47:16 <ZeD> and it started to complain about it's syntax
11:47:17 <augustss> mrd: it will become clearer when I add the parser and pretty printer
11:47:27 <allbery_b> @paste it
11:47:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:47:31 <mrd> i've typed in pair, but it fails with an error
11:47:37 <oerjan> ZeD: that's the most annoying thing about Hugs really, you can only use one module from the command line, although that one can import others (i made a Basic.hs module containing just lots of imports to make it easier)
11:48:06 <mrd> "Bad abstraction" because one of the "kinds" works out to a Pi-type
11:48:16 <oerjan> well that and the memory bug that hits you on large calculations
11:48:44 <oerjan> but only in the most recent versions, so you should be safe :S
11:48:48 <augustss> mrd: Hmmm, well, I've not really tested the examples with the implementation, so it could be wrong.
11:48:51 <hpaste>  mrd pasted "pair" at http://hpaste.org/3474
11:48:55 <ZeD> yeah, sounds like a sound idea, however what I'll do is as I'm flying home for the weekend tomorrow (thus rushing with coursework) I just want to finish now so will copy paste the needed parts from List.hs to my code
11:49:14 <mauke> what do you need from List.hs?
11:49:46 <ZeD> just the isPrefixOf, isInfixOf functions (and anything they rely on)
11:49:50 <augustss> mrd: I'll check what's going on in a moment.
11:50:05 <mauke> ZeD: isn't isPrefixOf in your local List library?
11:50:11 <ZeD> thus i wont hand in the most professional solution
11:50:45 <ZeD> Prelude> isPrefixOf "boo" "oo"
11:50:45 <ZeD> ERROR - Undefined variable "isPrefixOf"
11:51:09 <mauke> yeah, you need to import List
11:51:12 <omnId> I think in Hugs you use :add Module to import
11:51:12 <lambdabot> omnId: You have 1 new message. '/msg lambdabot @messages' to read it.
11:51:20 <oerjan> omnId: :load Module
11:51:39 <mauke> :also Module
11:51:39 <ZeD> yup but i want my code to include the import bit
11:51:51 <oerjan> mauke: which is just a synonym for :load
11:51:56 <mauke> :(
11:52:39 <omnId> zed: put your code in a pastebin.  We can't see the error if we don't see the code.
11:52:55 <omnId> import Data.List -- this should work fine.
11:53:28 <ZeD> omnId: there is no error yet (A) I just wanted to do the last exercise by importing a predefined function instead of creating my own
12:02:15 <nominolo> @seen swiert
12:02:15 <lambdabot> I saw swiert leaving #haskell 3h 59m 1s ago, and .
12:03:59 <dons> ?quit update
12:04:19 <Heffalump> what's wrong with the dynamic reloading? :-)
12:04:32 <omnId> @seen twanvl
12:04:39 <lambdabot> twanvl is in #haskell. I don't know when twanvl last spoke.
12:04:43 <twanvl> @seen me
12:04:49 <omnId> hi, twan
12:04:49 <lambdabot> me has changed nick to olsner.
12:04:55 <lambdabot> olsner is in #haskell. I don't know when olsner last spoke.
12:04:56 <Jaak> @join #gentoo-haskell --- kthxbye
12:05:01 <lambdabot> Not enough privileges
12:05:21 <dons> Jaak: i'll add the others in a sec.
12:05:28 <Jaak> :)
12:06:58 <omnId> twanvl: You wanted to use my Template Haskell code?  Sure thing.  I'm adding more comments and I've fixed the last error on that hpaste code.
12:07:17 <dons> ?seen lambdabot
12:07:17 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #ghc and #darcs
12:07:21 <dons> ?version
12:07:22 <lambdabot> lambdabot 4p568, GHC 6.6 (Linux i686 2.66GHz)
12:07:22 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:07:24 <dons> ^^ new home
12:07:28 <twanvl> Thanks
12:07:29 <lambdabot> twanvl: You have 1 new message. '/msg lambdabot @messages' to read it.
12:12:09 <hpaste>  omnId annotated "Not in scope: `field_'" with "twanvl:" at http://hpaste.org/3018#a12
12:13:24 <omnId> oops, that should say ''Ref, not ''FRef.Ref
12:14:01 <ZeD> @src isInfixOf
12:14:02 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
12:14:21 <ZeD> @src isPrefixOf
12:14:21 <lambdabot> isPrefixOf [] _          = True
12:14:21 <lambdabot> isPrefixOf _  []         = False
12:14:21 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
12:21:04 <earthy> drat. why does FileManip sort the result of find?
12:21:26 <augustss> mrd: there was a typo in the definition of pair, the Pi should be a Lam
12:22:30 <mrd> aha
12:22:34 <mrd> i was wondering about that
12:22:35 <allbery_b> eartyhy: platform?  NTFS file enumeration returns dorted names
12:22:38 <allbery_b> sorted, even
12:22:51 <earthy> getDirContents :: FilePath -> IO [FilePath]
12:22:51 <earthy> getDirContents dir = (sort . filter goodName) `liftM` getDirectoryContents dir
12:22:51 <earthy>     where goodName "." = False
12:22:51 <earthy>           goodName ".." = False
12:22:51 <earthy>           goodName _ = True
12:23:05 <earthy> this is from the sources of System.FileManip.Find
12:23:10 <allbery_b> hm
12:23:15 <earthy> err.. FilePath.Find
12:23:38 <earthy> so  yeah, it returns all files in sorted order, always
12:23:49 <Shubalub> because ls sorts?
12:24:04 * earthy goes 'duh'
12:24:06 <mrd> still some typoes there, i guess you're sorting them out now
12:24:06 * earthy can read code
12:24:19 <earthy> *why* does it sort? :)
12:24:35 * earthy doesn't see the reason at all
12:24:49 <phobes> :type (*)
12:24:56 <Shubalub> scanning through a listing manually is easier if it's sorted
12:24:57 <phobes> @type (*)
12:25:06 <lambdabot> forall a. (Num a) => a -> a -> a
12:25:14 <phobes> @let foo = (*):foo
12:25:21 <lambdabot> Defined.
12:25:26 <phobes> @type foo
12:25:27 <lambdabot> Not in scope: `foo'
12:25:34 <phobes> oh right, they're not connected
12:25:35 <allbery_b> not sure @type sees those
12:25:45 <phobes> So I try this in GHCI
12:25:45 <allbery_b> if it did it'd likely be L.foo
12:25:45 <mauke> foo :: [Integer -> Integer -> Integer]
12:25:53 <phobes> mauke: can you explain that?
12:26:03 <mauke> monomorphism restriction + defaulting
12:26:08 <phobes> ok thanks1
12:26:13 <phobes> thanks!
12:26:28 <mauke> adding an explicit type signature "fixes" it
12:26:42 <phobes> ya I figure that out
12:26:48 <phobes> but was wondering how it got "Integer"
12:27:16 <phobes> @unlet foo
12:27:16 <lambdabot>  Parse error
12:27:20 <phobes> @undef foo
12:27:21 <lambdabot> Undefined.
12:27:37 <omnId> @let x = 1
12:27:40 <lambdabot> Defined.
12:27:40 <omnId> @let y = 2
12:27:41 <oerjan> @help undefine
12:27:42 <lambdabot> Defined.
12:27:43 <lambdabot> undefine. Reset evaluator local bindings
12:27:44 <omnId> @undef x
12:27:46 <lambdabot> Undefined.
12:27:47 <omnId> > y
12:27:48 <lambdabot>   Not in scope: `y'
12:28:01 <omnId>  @undef kills 'em all
12:28:04 <oerjan> xactly
12:28:07 <phobes> my bad
12:28:30 <mauke> @let nom x = fmap x
12:28:32 <lambdabot> Defined.
12:28:52 <mauke> > nom nom nom sqrt (Just [1 .. 4])
12:28:53 <omnId> > let om = (+); nom = 2 in om nom nom
12:28:54 <lambdabot>  Just [1.0,1.4142135623730951,1.7320508075688772,2.0]
12:28:55 <lambdabot>  4
12:30:51 <augustss> mrd: I think I've fixed the typos.  And I've even test run fst on a pair.  It's painful without a parser.
12:31:17 <dons> i count 63 libraries uploaded to hackage since the last hwn just before the haskell workshop!
12:31:32 <dons> so "holy crap" is an appropriate response, I feel.
12:31:41 <omnId> best get crackin'
12:31:43 <omnId> :P
12:32:00 <dons> when do we start seeing "haskell has too many libraries" posts?
12:32:21 <mrd> augustss: ya
12:32:26 <puusorsa> holy crack!
12:32:47 <mrd> Pair still has one
12:33:09 <newsham> "Haskel/Lisp hackers, I enjoy reading books you write, blogs you maintain and I find your comments on most programming topics on slashdot very insightful. However, if your language is so superior and it makes you guys so much more productive, why don't you flood us with actual software written in it? Besides your own server-side web applications?"
12:33:16 <newsham> dons: that would be an appropriate response to this guy
12:33:20 <newsham> http://kontsevoy.blogspot.com/
12:33:21 <lambdabot> Title: cat /dev/urandom > ~/blog
12:33:48 <phobes> So if you eliminate the monomorphism restriction, as I sometimes hear advocated, what type would my foo above have?  anyone know?
12:33:50 <dons> ah yes, that guy
12:34:17 <oerjan> phobes: Num a => [a -> a -> a]
12:34:58 <phobes> oerjan:  I figured that's what it had to be, ... but hmm...
12:35:09 <mrd> phobes: supply an explicit type annotation and the restriction will go away
12:35:17 <dons> newsham: i think it is valid to some degree: we do need to write more open source projects for linux and the mac
12:35:28 <dons> and less internally-focused tools
12:35:29 <hellblade> hey guys. any place where i could get Hugs 2001 for ubuntu?
12:35:40 <dons> hellblade: why hugs 2001??
12:35:43 <newsham> no doubt, but placed into context its a somewhat silly argument.  there are haskell apps, there are a lot more C apps.  there are a lot omre c programmers.
12:35:52 <dons> right.
12:36:02 <newsham> also "we're too busy writing code to write blogs bashing your language"
12:36:02 <dons> and darcs/pugs/xmonad are really rather visible.
12:36:08 <newsham> except for his blog bashing your language
12:36:11 <dons> i can't think of a common lisp app in wide use
12:36:19 <dons> nor a ruby one..
12:36:22 <hellblade> dons: my uni has this version and my code wont run in my pc. i think they use different libs?
12:36:27 <newsham> dons: lisp machine was in wide use at one point.
12:36:31 <mrd> wide use meaning non-server side?
12:36:31 <brad__> trying to build HTTP-3001 on 6.6.1: getting an error: Setup: HTTP.cabal:19: 'Executable' stanza starting with field 'flag old-base description'
12:36:40 <brad__> any idea how to fix this?
12:36:40 <dons> brad__: you need a new cabal
12:36:52 <brad__> is the new cabal on hackage?
12:37:01 <newsham> if anyone wants to argue the usefulness of C vs. lisp it would be worthwhile to see what a state-of-the-art lisp environment looked like a decade ago compared to a similar C based environment
12:37:04 <Shubalub> I don't think there are any CL implementations that produce decent executables
12:37:12 <mrd> sure there are
12:37:15 * mrd uses one every day
12:37:17 <mauke> dons: the regex coach is semi-used
12:37:20 <mrd> it just costs $$$
12:37:37 <brad__> is cabal 1.2.1 sufficient to get around this problem?
12:37:53 <dons> brad__: yes.
12:37:58 <brad__> thanks!
12:37:59 <Shubalub> okay, there aren't any free CL implementations that produce decent executables
12:38:06 <oerjan> phobes: i think you may be able to get [forall a. a -> a -> a] if you annotate it as such
12:38:11 <mrd> sbcl can, i guess, for some value of decent
12:38:17 <newsham> shab: sbcl ranks above ghc in the language shootout when measured by speed.
12:38:45 <newsham> not th eomst scientific argument, but still somewhat convincing
12:38:46 <mrd> i'm not sure i see the point though.  all of them offer delivery options, even if it is a shell script which runs the runtime + image.
12:38:51 <oerjan> in case that's what you were hoping for
12:40:10 <Shubalub> that's a problem on windows
12:40:18 <pejo> dons, ruby on rails, isn't that fairly well used?
12:40:31 <dons> server-side :)
12:40:51 <dons> even haskell beats up on ruby on the client side :)
12:41:03 <Shubalub> lacking decent binaries isn't a sufficient explanation though
12:41:20 <Shubalub> I mean, there's bunches of python apps around
12:41:34 <newsham> yay for python apps!
12:41:41 <mrd> but seriously, what kind of application is in wide use?
12:41:52 <dons> yeah.
12:41:55 <mrd> web browser, text editor, spreadsheet
12:42:02 <mrd> do we really need another?
12:42:10 <dons> window manager.
12:42:12 <dons> ;)
12:42:18 <mrd> that we always need another
12:42:20 <newsham> not many proof assistants written in python :(
12:42:21 <dons> revision control system.
12:42:23 <brad__> shell
12:42:37 <mrd> rcs, shell, proof assistant are all specialized tools
12:42:49 <mrd> so do they count as "wide use"?
12:42:53 <Shubalub> antivirus! spyware remover!
12:42:57 <mrd> in that case, shouldn't a compiler count as "wide use"?
12:43:00 <brad__> a shell is not specialized. you have to use one.
12:43:01 <newsham> mrd: some shells are in "wide use"
12:43:21 <mrd> well, a "shell" which isn't a piece of shit like Windows
12:43:25 <newsham> is Explorer a shell?
12:43:27 <mrd> is definitely not in wide use
12:43:41 <augustss> who wants to write bland tools anyway?
12:43:51 <mrd> exactly
12:44:01 <mrd> but bland has mass appeal
12:44:14 <augustss> Haskell is not about mass appeal
12:44:24 <newsham> this is kinda silly, special tools are why people use computers.
12:44:35 <newsham> just cause not everybody uses mathematica doesnt mean its not a very useful thing
12:44:37 <mrd> sure, but what is "wide use"?
12:44:42 <shapr> augustss: I'm not convinced of that.
12:45:10 <shapr> augustss: In my opinion, Haskell removes more accidental difficulty from programming than other languages.
12:45:24 <earthy> there's still some though
12:45:50 <dons> anyone have a 6.8.2 release candidate handy?
12:47:23 <augustss> shapr: Haskell might well be good for the masses, but if it is, it's more of an accident :)
12:47:42 <puusorsa> 6.8.2 release candidate candy
12:47:52 <dons> Igloo: with a recent snapshot (2 weeks old) this program, http://www.galois.com/~dons/publish.hs , causes a panic
12:48:02 <dons> ghc --make -O -fasm -funbox-strict-fields publish.hs -o publish
12:48:02 <dons> [1 of 1] Compiling Main             ( publish.hs, publish.o )
12:48:02 <dons> ghc-6.9.20070916: panic! (the 'impossible' happened)
12:48:02 <dons>   (GHC version 6.9.20070916 for x86_64-unknown-openbsd):
12:48:02 <dons> 	applyTypeToArgs
12:48:23 <dons> 5 weeks old, actually
12:49:46 <Jaak> i managed to stack overflow same release candidate while ago
12:50:18 <dons> did you report it?
12:50:22 <Heffalump> Jaak: the type-checker?
12:50:25 <Jaak> yeah
12:50:36 <Heffalump> there's a few bugs open in that area atm
12:50:37 <Jaak> type checker. but didn't report
12:50:42 <Jaak> good then
12:51:37 <augustss> a few too many type checker bugs this close to release :(
12:51:57 <Heffalump> http://hackage.haskell.org/trac/ghc/ticket/1795
12:51:58 <lambdabot> Title: #1795 (typechecker loops on simple program with fundep) - GHC - Trac
12:52:12 <Heffalump> perhaps it's not very close to release :-)
12:52:23 <dons> if we can submit a few more, we can push the release back a bit...
12:52:31 <swiert> @seen nominolo
12:52:32 <lambdabot> nominolo is in #haskell-soc, #haskell and #ghc. I don't know when nominolo last spoke.
12:53:04 <dcoutts> swiert: nominolo was about an hour ago
12:53:17 <dcoutts> swiert: btw, Richard Bird thinks TMR is great
12:53:31 <swiert> dcoutts: Thanks. And thanks!
12:53:31 <lambdabot> swiert: You have 1 new message. '/msg lambdabot @messages' to read it.
12:54:22 <brad__> confirm upgrading Cabal from hackage fixes problem i discussed earlier, thanks again
12:55:06 <dons> http://hackage.haskell.org/trac/ghc/ticket/1804
12:55:09 <lambdabot> Title: #1804 (Panic: applyTypeToArgs with -O) - GHC - Trac
12:58:28 <dcoutts> dons: btw, it looks like I've got a masters student to work on fusible unicode bytestrings, so that might help with your web xml things
12:58:49 <dcoutts> as his Msc project
12:59:00 <Heffalump> that's early in the year for them to be choosing
12:59:04 <dcoutts> indeed
12:59:15 <dcoutts> this one is keen and wants to get PhD funding
12:59:20 <dons> cool
13:00:13 <dcoutts> so is starting very early, Oege is encouraging him to do the project early
13:00:15 <augustss> heh, I see that I'm getting down voted on reddit.  Some people can't handle a few lambdas :)
13:00:22 <dons> heh
13:00:24 <dcoutts> augustss: heh
13:00:37 <dons> yeah, that would have been a straight  +40 a few months ago
13:00:48 <Heffalump> augustss: a post or a comment?
13:00:56 <augustss> post
13:00:58 <dons> you're getting beaten out by "It had to happen: a LOLcode compiler for .NET (blog.notdot.net)"
13:01:24 <conal> on the topic of more Haskell apps, how about a weblog analyzer DSEL.  Efficient, flexible, elegant.
13:01:27 <augustss> I know.  I need "LOLcode gets dependent types"
13:01:32 <dons> exactly!
13:02:06 <dons> yeah, that would be a good candidate, conal. and you could parallelise it
13:02:18 <conal> dons: oooh -- i like that angle!
13:03:08 <dons> conal: see bos kicking python's butt with a parallel log grepper, http://www.serpentine.com/blog/2007/09/25/what-the-heck-is-a-wide-finder-anyway/
13:03:08 <Heffalump> so where is this post?
13:03:10 <lambdabot> Title: teideal glic deisbhalach  Blog Archive  What the heck is a Wide Finder, anyw ..., http://tinyurl.com/2mcz47
13:04:01 * conal reads
13:05:09 <nominolo> swiert, hi there
13:05:10 <lambdabot> nominolo: You have 1 new message. '/msg lambdabot @messages' to read it.
13:05:43 <conal> dons: that blog post is a great start.  a next step could be DSEL design.
13:06:02 <nominolo> I have to write one more section.  i'll send it to you tonight or tomorrow noon.  ok?
13:06:03 * Heffalump finally realises why he can't find the post, some fool used tinyurl :-p
13:06:08 <conal> combinators related to parsing, munging, and unparsing.
13:06:43 <dons> Heffalump: blogspot posts are blocked on the new reddit, bizarrely
13:07:39 <Heffalump> that is indeed bizarre
13:29:55 <fasta> Do you know of a program that can LaTeX as much as needed?
13:30:14 <fasta> s/can/can run
13:30:27 <Heffalump> I just stick a while loop in my Makefiles
13:30:49 <fasta> Heffalump: but it needs to terminate, right?
13:30:56 <Heffalump> $(DOC).dvi:
13:30:56 <Heffalump>         latex $(DOC) || (rm $(DOC).aux $(DOC).dvi ; false)
13:30:56 <Heffalump>         while grep "Rerun to get" $(DOC).log ; do latex $(DOC) ; done
13:31:40 <fasta> Heffalump: Can you dcc me the whole file? :)
13:32:56 <Heffalump> I can mail it to you if you like
13:33:33 <fasta> Heffalump: thank you
13:38:45 <kosmikus> fasta: you can also look at http://www.pps.jussieu.fr/~beffara/soft/rubber/
13:38:47 <lambdabot> Title: Rubber
13:38:49 <sioraiocht> @type fix
13:38:51 <lambdabot> forall a. (a -> a) -> a
13:39:18 <sioraiocht> I forget howt o use fix...
13:39:25 <fasta> kosmikus: thanks, looks good
13:39:33 <sioraiocht> > fix (
13:39:33 <lambdabot> Unbalanced parentheses
13:39:39 <sioraiocht> damn enter key...
13:40:15 <sioraiocht> > fix (\f x -> if x == 0 then 1 else x * (f (x-1))) 3
13:40:16 <lambdabot>  6
13:40:20 <sioraiocht> yay
13:47:38 <byorgey> > fix (1:)
13:47:50 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:48:04 <sioraiocht> > fix (+1)
13:48:05 <lambdabot>  Exception: <<loop>>
13:48:06 <sioraiocht> ?
13:48:10 <puusorsa> @src fix
13:48:11 <lambdabot> fix f = let x = f x in x
13:48:13 <byorgey> hehe
13:48:20 <omnId> > let x = (+1) x in x
13:48:21 <lambdabot>  Exception: <<loop>>
13:48:28 <sioraiocht> > iterate (*2) 1
13:48:29 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:48:33 <omnId> = 1 + 1 + 1 + 1 + 1 + ...
13:48:39 <byorgey> > fix ((1:) . scanl (+) 1)
13:48:40 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:49:15 <Jaak> > "zomg" ++ fix ('!':)
13:49:17 <lambdabot>  "zomg!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
13:49:26 <omnId> fix f is kinda like last . iterate f
13:49:50 <omnId> except more likely to terminate :)
13:50:21 <arcatan> what's fix good for, btw?
13:50:43 <shapr> @index break
13:50:43 <lambdabot> Data.List, Prelude
13:51:15 <omnId> arcatan: cyclic structures, tying loops in the call graph.
13:51:21 <shapr> arcatan: You could write one step of an algorithm (maybe a gameboard searcher) and then repeat that until you like the result.
13:51:57 <omnId> you don't *really* need it since haskell has built-in recursion, though.
13:51:57 <augustss> fix serves no particular purpose since "let" is recursive
13:52:00 <byorgey> @go "that about wraps it up" McAdam
13:52:03 <lambdabot> http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-375/
13:52:04 <lambdabot> Title: That About Wraps it Up
13:52:10 <byorgey> arcatan: see ^^
13:52:23 <byorgey> for some interesting examples of fix's possible usefulness
13:54:03 <quicksilver> omnId: fix is rather likely not to terminate, in fact
13:54:12 <quicksilver> omnId: but may produce something useful in finite time
13:54:22 <omnId> quicksilver: usages of it might, due to laziness.
13:55:10 <omnId> last . iterate f won't, since there is no nil at the end for last to produce something.
13:56:42 <augustss> omnId: last (iterate f undefined) is more likw fix
13:57:03 <augustss> except it doesn't work, as you said
13:58:24 <augustss> > let pfac fac n = if n == 0 then 1 else fac (n-1); almostFac = iterate pfac undefined 100 in almostFac 10
13:58:31 <lambdabot>  Couldn't match expected type `t1 -> t'
13:58:33 <oerjan> iiuc, technically fix f is the limit of the sequence (iterate f undefined)
13:59:22 <augustss> > let pfac fac n = if n == 0 then 1 else fac (n-1); almostFac = iterate pfac undefined !! 100 in almostFac 10
13:59:26 <lambdabot>  1
13:59:35 <augustss> hmmmm
13:59:54 <augustss> non-standard fac
14:00:09 <omnId> n * fac (n-1)
14:00:13 <augustss> > let pfac fac n = if n == 0 then 1 else n*fac (n-1); almostFac = iterate pfac undefined !! 100 in almostFac 10
14:00:15 <lambdabot>  3628800
14:00:27 <omnId> > let pfac fac n = if n == 0 then 1 else n*fac (n-1); almostFac = iterate pfac undefined !! 100 in almostFac 102
14:00:28 <lambdabot>  Undefined
14:00:33 <omnId> :)
14:08:00 <olsner> hmm... who pinged me? you went past my scrollback buffer
14:08:51 <Cale> <twanvl> @seen me
14:08:51 <Cale> <omnId> hi, twan
14:08:51 <Cale> <lambdabot> me has changed nick to olsner.
14:08:51 <Cale> <lambdabot> olsner is in #haskell. I don't know when olsner last spoke.
14:09:10 <Cale> That's the last occurrence of your nick.
14:09:42 <olsner> ah, thanks ;-) Cale++
14:09:58 <omnId> so twan pinged "me".  :)
14:11:56 <shapr> @seen protontorpedo
14:11:56 <lambdabot> I haven't seen protontorpedo.
14:11:59 <twanvl> No one should call himself "me", it makes you unslapable
14:12:39 <shapr> @slap me
14:12:39 * lambdabot slaps shapr
14:12:42 <shapr> hm, I see
14:13:04 <olsner> @protontorpedo
14:13:04 <lambdabot> hakell is not lisp or ml right?
14:13:52 <Olathe> @slap 
14:13:52 * lambdabot clobbers  with an untyped language
14:14:07 <Tobsan> haha
14:16:19 * olsner was the one who pulluted that namespace, apparently
14:16:33 <Olathe> Polluter !
14:17:33 <olsner> @slap herself
14:17:33 * lambdabot orders her trained monkeys to punch herself
14:18:14 <olsner> hmm, the reflexive pronoun's not quite right in that sentence, is it?
14:18:50 <b_jonas> Hi. I'd like to have a datastructure that represents a set of real intervals in such a way that for any input real, it's easy to find all the intervals containing that number.
14:19:06 <b_jonas> My problem is that I seem to remember that something like that was described in Knuth,
14:19:21 <b_jonas> but I've borrowed a Knuth 3 from the library today and it seems it's not in it.
14:19:33 <b_jonas> Can anyone tell if it's in Knuth vol 1?
14:20:06 <twanvl> Can a number be in multiple intervals?
14:20:32 <olsner> 2.5 is in [1..3] and [2..4] at the same time, for example
14:21:22 <b_jonas> twanvl: yes
14:23:05 <b_jonas> The problem the Knuth book was describing might not have been exactly the same though,
14:23:19 <nomeata> lambdabot: are you a her? that name doesnt sound feminine to me
14:23:22 <b_jonas> I'd just like to know if I should look in vol 1 or I just misremember that.
14:23:34 <oerjan> hm... you could make a map from minimal intersections to original intervals
14:23:57 <oerjan> except maybe that would be huge
14:24:17 <twanvl> I would suggest: Map Real [Interval]. For each right end of an interval, you give the number of intervals that end at or past that point, ordered by descending start point.
14:24:46 <omnId> nomeata: how presumptuous of you!
14:24:52 <omnId> @vixen Are you female?
14:24:53 <lambdabot> is that really what you want to know?
14:24:59 <omnId> @quote female
14:24:59 <lambdabot> lambdabot says: Of course i'm female
14:25:07 <oerjan> twanvl: i guess that's essentially what i meant too
14:25:35 <nomeata> omnId: not really, its just that the word bot is masculine in German, so it sounds wrong to me.
14:25:46 <nomeata> (grammatically wrong, that is :-))
14:25:52 <omnId> nomeata: :P
14:26:15 <nomeata> also, I wonder if lambdabots realname really fits to her claim about her gender
14:26:19 * nomeata ducks
14:28:53 <b_jonas> twanvl: I don't really understand that: "number of " ... "ordered by descending start point" -- if the value is just the count of some intervals, what does the order mean/
14:29:17 <twanvl> That should be "list of..."
14:31:07 <twanvl> For example: the intervals [1,5],[2,4],[3,6]  give: {4 -> [(2,4),(1,5)], 5 -> [(3,6),(1,5)], 6 -> [(3,6)]}
14:31:52 <cjay> is there a way to get automatic memoization from ghc?
14:32:19 <cjay> I mean, not throwing away old function results and caching them
14:32:35 <cjay> ideally only for a certain annotated function
14:32:36 <b_jonas> twanvl: hmm. I'll think about that. I think I really need the case when I also want to change the structure by adding intervals
14:32:38 <b_jonas> thanks for the help
14:32:51 <sjanssen> cjay: not really, but there are some tricks
14:33:14 <b_jonas> WAIT
14:33:26 * twanvl waits
14:33:30 <cjay> sjanssen: tricks.. you mean using unsafePerformIO and a Map?
14:33:53 <b_jonas> this problem is discussed in Cormen
14:34:07 <b_jonas> (which I've had on my shelf all along)
14:34:17 <b_jonas> so I misremembered that it's in Knuth
14:34:29 <b_jonas> how stupid from me that i didn't even check that
14:34:37 <cjay> btw, are there languages or compilers with the kind of automatic memoization I want?
14:35:09 <sjanssen> cjay: GHC will hold on to top-level values, so you can use an array, map, or list containing results
14:35:09 <mrd> no. just arrange for your function results to appear in some data structure
14:35:13 <b_jonas> (Cormen = Cormen--Leiserson--Rivest--Stein: Intr. to Algorithms)
14:35:41 <mrd> you can build an "infinite" data structure containing your results computed lazily
14:35:42 <nomeata> b_jonas: how about having the list sorted twice, once per first and once per second number. then you can use binary search to split the list in halfs, and then use the intersection
14:35:56 <sjanssen> cjay: is the domain of your function reasonably small?
14:36:09 <b_jonas> nomeata: I don't know, but I'm really too tired to think that over now
14:36:18 <b_jonas> I only really wanted to hunt down the reference
14:36:23 <b_jonas> because I know I've seen it in some book
14:36:25 <nomeata> b_jonas: ok :-)
14:37:18 <cjay> sjanssen: well.. what is reasonably
14:37:35 <nomeata> I guess (\x -> filter ((<=x).snd) . filter ((=>x).fst)) is not good enough :-)
14:37:52 <sjanssen> cjay: small enough that O(n) memory use wrt. the size of your domain is reasonable
14:38:18 <dons> @url http://www-users.cs.york.ac.uk/~ndm/downloads/paper-uniform_boilerplate_and_list_processing-30_sep_2007.pdf
14:38:18 <lambdabot> I know nothing about http://www-users.cs.york.ac.uk/~ndm/downloads/paper-uniform_boilerplate_and_list_processing-30_sep_2007.pdf.
14:38:23 <dons> @tiny-url http://www-users.cs.york.ac.uk/~ndm/downloads/paper-uniform_boilerplate_and_list_processing-30_sep_2007.pdf
14:38:24 <lambdabot> http://tinyurl.com/yulkt4
14:38:26 <dons> ah
14:38:55 <cjay> sjanssen: you mean when caching ALL results? then the memory complexity is n**2 in that case
14:39:14 <nominolo> @seen jyp
14:39:14 <lambdabot> I saw jyp leaving #xmonad and #haskell 9d 1h 13m 44s ago, and .
14:39:21 <puusorsa> http://blog.notdot.net/archives/32-LOLCode.net-Now-your-LOLCats-can-use-the-CLR!.html
14:39:24 <lambdabot> Title: LOLCode.net - Now your LOLCats can use the CLR! - Nick's blog, http://tinyurl.com/3coe2q
14:39:55 <ac> so renderPrimitive is analagous to glBegin, what's glEnd?
14:39:59 <cjay> sjanssen: I already wrote it with an array to memoize the relevant stuff, but it's much uglier than the trivial solution that would benefit from memoization
14:40:15 <cjay> automatic memoization I mean
14:40:19 <sjanssen> cjay: yes, caching all resuls.  We don't have to calculate all of them, but we need a box to store each thunk
14:40:30 <sjanssen> cjay: oh, I might have a nice link for you, one moment
14:40:51 <kilimanjaro> dons, what audio player are you using in http://www.xmonad.org/images/screen-dons-tall-status.png ?
14:41:09 <sjanssen> cjay: check out Okasaki's memoizing fixpoint http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo
14:41:12 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/u45vz
14:41:20 <cjay> thanks
14:41:26 <Lemmih> kilimanjaro: hmp3
14:41:30 <arcatan> kilimanjaro: inspired guess: hmp3
14:41:46 <sjanssen> kilimanjaro: iTunes
14:41:50 <kilimanjaro> ohh, I had no clue such a thing existed
14:41:52 <ac> oh I see, it takes a do block
14:42:21 <sjanssen> s/do block/monadic value
14:49:07 <visof^> we can define angular momentum as w= r*p , r=position of particle of the orign and p = linear momentum
14:49:32 <visof^> what about if the particle move arount itself?
14:49:46 <visof^> is r equal the its raduis?
14:49:59 <visof^> or what?
14:50:07 <visof^> oh sorry
14:50:09 <oerjan> particles by definition have no extent
14:50:26 <oerjan> in this case
14:50:30 <visof^> i think this is #physics
14:50:35 <visof^> sorrrry
14:54:16 <Eelis> is there a way to say "fully evaluate this term now" in an IO action? in my case i have a term representing data read from a file with readFile, but at some point in the function i chroot into another file, after which the file is no longer accessible
14:54:28 <Eelis> so i want the reading to take place before the chroot
14:54:34 <bos31337> you shouldn't be using readFile in that case.
14:54:47 <Eelis> ok. what should i be using?
14:55:00 <bos31337> something non-lazy.
14:55:07 <Eelis> right
14:55:37 <dolio> @type evaluate
14:55:39 <lambdabot> Not in scope: `evaluate'
14:55:49 <dolio> @type rnf
14:55:51 <lambdabot> forall a. (NFData a) => a -> Done
14:56:31 <allbery_b> @type Control.Exception.evaluate
14:56:32 <lambdabot> forall a. a -> IO a
14:56:35 <omnId> readFile' name = length file `seq` file where file = readFile name -- strict readFile
14:56:40 <dolio> Ah, that's where it is.
14:56:57 <allbery_b> @index evaluate
14:56:57 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
14:57:20 <Eelis> omnId: heh, evil. oh well, if that's what it takes.. :) thanks
14:57:36 <omnId> depends what you want.
14:57:51 <dolio> Anyhow '... ; () <- evaluate (rnf stuffFromFile) ; ...' probably works.
14:58:04 <omnId> that gets the whole thing all at once.
14:58:22 <omnId> er, once any part of it is forced, that is.
14:58:27 <omnId> iiuc
14:58:53 <dolio> Yeah. It's still delayed until you start to use it, if that matters.
14:58:56 <Cale> you don't need the () <-
15:00:25 <dolio> Oh, yeah, I suppose the 'evaluate' takes care of forcing the ().
15:00:26 <Eelis> wait, reading the documentation for evaluate, shouldn't   s <- readFile >>= evaluate  be sufficient?
15:00:35 <Eelis> evaluate has type  a -> IO a
15:00:45 <Cale> dolio: if it didn't, binding like that wouldn't help
15:00:52 <omnId> evaluate only gets the whnf
15:01:06 <omnId> you need rnf to reduce the whole thing.
15:01:10 <Eelis> ah, i see
15:01:18 <Cale> (at least, I don't think it would)
15:01:49 <Eelis> the rnf stuff is listed as "experimental" :/
15:02:12 <dolio> Well, it's been experimental for years. :)
15:03:19 <phlpp> http://weblog.raganwald.com/2007/10/challenge-of-teaching-yourself.html
15:03:21 <lambdabot> Title: The challenge of teaching yourself a programming language, http://tinyurl.com/26czay
15:03:23 <phlpp> good article btw.
15:04:16 <n00b> hey guys have any of you tried hIDE
15:04:39 <Lemmih> I've tried it. Didn't like it much.
15:04:54 <n00b> hey guys have any of you tried hIDE
15:04:59 <Eelis> omnId: isn't whnf enough if i just read a String ?
15:04:59 <n00b> hey guys have any of you tried hIDE
15:05:03 <n00b> hey guys have any of you tried hIDE
15:05:13 <omnId> type String = [Char]
15:05:29 <omnId> you'd get one cons cell: (_ : _)
15:06:13 <Eelis> omnId: ok. the "weak = no reduction under lambdas" part in the wikibook definition led me to think the whole list would be evaluated
15:06:35 <TSC> I understand weak as "first data constructor"
15:08:09 <dolio> Cale: Well, "do () <- return (rnf undefined) ; return 1" is undefined, but "do return (rnf undefined) ; return 1" isn't, so something is getting evaluated differently.
15:09:10 <omnId> do action ; blah becomes action >> blah, and (>>) tends to use (\_ -> ...) which ignores the argument.
15:09:16 <Cale> ah, okay
15:09:26 <Cale> yeah, I suppose it would affect things
15:09:35 <Cale> But evaluate is supposed to handle the evaluation itself.
15:10:21 <omnId> I guess binding on (\() -> ...) would force evaluating the unit.  To get to the unit, you have to do the evaluating that's been piled on it.
15:10:35 <omnId> subtle
15:10:50 <SamB_XP> >>! could force the thing it throws away
15:10:54 <fox86> hmm. i am learning haskell because i think it's very exciting... but when people ask "doesn't it take a lot of effort to learn haskell? why put in the extra effort when you can learn a simple language, such as ruby/python?"... and thoughts regarding that? how would a, say, hobby programmer benefit from using haskell?
15:11:06 <dolio> I suppose that'd be useful if you wanted to force things in a monad other than IO.
15:11:12 <fox86> any*
15:11:18 <SamB_XP> fox86: well what does a hobby programmer program for?
15:11:28 * omnId is a hobby programmer.  The brainhurt feels so good!
15:11:40 <thoughtpolice> fox86: it's lots of fun. :) although, I guess ymmv
15:12:08 <fox86> SamB_XP:  hmm, i suppose for fun? perhaps he/she needs to produce something
15:12:18 <SamB_XP> dolio: even in IO you could use it
15:12:29 <heatsink> How does precedence in showsPrec work?  "I appear in parentheses if my own precedence is greater or equal to my context"?
15:12:34 <dolio> SamB_XP: Yeah, but 'evaluate' is shorter.
15:12:45 <SamB_XP> hmm.
15:13:02 <SamB_XP> depends on the context, doesn't it?
15:13:16 <ddarius> heatsink: It doesn't have any inherent meaning, but something like that.
15:13:39 <SamB_XP> @hoogle paren
15:13:40 <lambdabot> Text.PrettyPrint.HughesPJ.parens :: Doc -> Doc
15:13:40 <lambdabot> Language.Haskell.TH.Ppr.parensIf :: Bool -> Doc -> Doc
15:13:40 <lambdabot> Text.ParserCombinators.Parsec.Token.parens :: TokenParser st -> CharParser st a -> CharParser st a
15:13:48 <SamB_XP> @hoogle parens
15:13:48 <lambdabot> Text.PrettyPrint.HughesPJ.parens :: Doc -> Doc
15:13:48 <lambdabot> Text.ParserCombinators.Parsec.Token.parens :: TokenParser st -> CharParser st a -> CharParser st a
15:13:48 <lambdabot> Language.Haskell.TH.Ppr.parensIf :: Bool -> Doc -> Doc
15:13:52 <dolio> > (length "evaluate (rnf ...)", length "() <- return (rnf ...)")
15:13:54 <omnId> @hoogle+
15:13:54 <lambdabot>  (18,22)
15:13:54 <heatsink> I'm just trying to figure out how to do something for showsPrec that will put parentheses where I expect them.
15:13:56 <SamB_XP> hmm.
15:14:14 <omnId> SamB_XP: dolio got an @run in before the @hoogle+
15:14:19 <ddarius> heatsink: Use the number however you feel like to get that result.
15:14:27 <heatsink> kay :)
15:14:28 <omnId> use @hoogle+ for more results.
15:16:36 <Eelis> dolio: shouldn't something like:    full_evaluate x = do () <- evaluate (rnf x); return x    be part of the standard library?
15:17:29 <Eelis> to complement ordinary evaluate
15:18:23 <Taejo> @pl fix (\ A m n -> if m == 0 then n+1 else (if n == 0 then A (m - 1) 1 else A (m-1) (A m (n-1))))
15:18:26 <lambdabot> fix (ap (ap . (. (1 +)) . if' . (0 ==)) . ap (ap . ((ap . flip (if' . (0 ==))) .) . flip flip 1 . (. subtract 1)) (ap (ap . ((.) .) . (. subtract 1)) (flip flip (subtract 1) . ((.) .))))
15:18:27 <lambdabot> optimization suspended, use @pl-resume to continue.
15:19:07 <Taejo> @where if
15:19:07 <lambdabot> I know nothing about if.
15:19:09 <Taejo> @where if'
15:19:09 <lambdabot> I know nothing about if'.
15:19:18 <sorear> it's not a real function
15:19:19 <Taejo> @hoogle if'
15:19:19 <lambdabot> No matches found
15:19:31 <sorear> it's actually impossible to @pl code that uses if
15:19:32 <dolio> There could be, I suppose. I don't know how commonly people want to force their stuff.
15:19:49 <sorear> so @pl uses a fake function
15:19:59 <sorear> @pl \a b c -> if a then b else c
15:19:59 <lambdabot> if'
15:20:37 <Taejo> sorear, why do you say "impossible"? you just need to add an extra function to the vocabulary
15:21:51 <sorear> pointfree code can't define functions!
15:22:36 <Eelis> dolio: ok. anyway, thanks for your help
15:23:03 <SamB_XP> sorear: o rly
15:23:26 <SamB_XP> oh, you mean it can't give them NAMES
15:23:30 <SamB_XP> that's true
15:25:37 <fox86> is there a way to start ghci without the ascii logo appearing?
15:25:45 <ivanm> @hoogle [Maybe a] -> [a]
15:25:46 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
15:26:04 <sorear> fox86: ghci -v0
15:26:26 <Taejo> sorear, why are ab and fix and (-) allowed, but if' isn't?
15:26:39 <fox86> sorear: aah, great. thank you!
15:26:39 <sorear> @hoogle ap
15:26:46 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
15:26:46 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
15:26:46 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
15:26:58 <sorear> because ap and fix and (-) are standard
15:28:42 <Taejo> sorear, so it isn't that you *can't*do* ifs in PFS... you just can't do them with standard Haskell libraries
15:29:13 <sorear> right.
15:29:20 <sorear> sorry for the confusion.
15:29:49 <dolio> Couldn't you replace "if'" with some conglomeration of ap, const and (==True) or some such?
15:30:01 <dolio> Although, that'd look even uglier.
15:30:29 <sorear> oh right, yes
15:30:55 <dolio> Or, I suppose (==True) is worthless...
15:30:57 <sorear> @pl \b t f -> [f,t] !! fromEnum b
15:30:57 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
15:31:02 <fox86> hmm, does sin() take radians or degrees?
15:31:05 <sorear> radians
15:31:21 <sorear> dolio: ugly enough for you? :P
15:31:26 <LoganCapaldo> @type sin
15:31:27 <lambdabot> forall a. (Floating a) => a -> a
15:31:56 <dolio> sorear: Once you substitute it in for every occurrence of "if'" in some other expression, it will be. :)
15:32:14 <fox86> @ sin pi
15:32:18 <fox86> @pl sin pi
15:32:18 <lambdabot> sin pi
15:32:22 <fox86> hmm
15:32:24 <omnId> > sin pi :: Double
15:32:27 <LoganCapaldo> I guess it would be counterproductive to annotate the type as (Floating radians) => radians -> radians
15:32:29 <lambdabot>  1.2246063538223773e-16
15:32:51 <omnId>  '>' is short for the '@run' command
15:32:58 <fox86> omnId: thanks
15:33:00 <Cale> Radians are the only real way to measure angles ;)
15:33:30 <fox86> > sin (pi/2)
15:33:31 <lambdabot>  1.0
15:33:39 <fox86> > sin (pi)
15:33:40 <lambdabot>  1.2246063538223773e-16
15:34:02 <Cale> > sin pi :: Float
15:34:03 <lambdabot>  -8.742278e-8
15:34:20 <LoganCapaldo> > sin pi :: Exact
15:34:20 <lambdabot>   Not in scope: type constructor or class `Exact'
15:34:24 <LoganCapaldo> heh
15:34:31 <fox86> Double is doubly exact
15:34:33 <fox86> ;)
15:34:49 <LoganCapaldo> @type pi
15:34:51 <lambdabot> forall a. (Floating a) => a
15:34:55 <LoganCapaldo> hmm
15:35:10 <LoganCapaldo> is it pi = 3.14.... in a file somewhere?
15:35:22 <sorear> @src Double pi
15:35:22 <lambdabot> Source not found. My mind is going. I can feel it.
15:36:02 <fox86> i like pi
15:36:20 <LoganCapaldo> I hope it's instance FLoating Foo pi = ...
15:36:44 <Tobsan> fox86: me too :)
15:36:49 <LoganCapaldo> @src Floating
15:36:49 <lambdabot> class  (Fractional a) => Floating a  where
15:36:49 <lambdabot>     pi                                                      :: a
15:36:49 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
15:36:49 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
15:36:49 <lambdabot>     (**), logBase                                           :: a -> a -> a
15:36:59 <LoganCapaldo> hooray
15:37:09 <LoganCapaldo> @src Fractional
15:37:10 <lambdabot> class  (Num a) => Fractional a  where
15:37:10 <lambdabot>     (/)             :: a -> a -> a
15:37:10 <lambdabot>     recip           :: a -> a
15:37:10 <lambdabot>     fromRational    :: Rational -> a
15:37:15 <fox86> Tobsan: i am trying to memorize as much of it as i can
15:37:25 <Tobsan> fox86: how many digits do you know?
15:37:26 <LoganCapaldo> fromRational, nice
15:37:33 <Tobsan> i've been doing the same thing =)
15:37:34 <fox86> Tobsan: i know 100 now
15:37:39 <Tobsan> oh
15:37:41 <LoganCapaldo> I was afraid of a fromDouble or similar
15:37:42 <fox86> Tobsan: but it's getting hard
15:37:43 <Tobsan> i know 45 only :/
15:37:50 <omnId> I can go to 535
15:37:59 <omnId> those digits, anyway :)
15:38:03 <Tobsan> hey fox86 i heard of some japanese guy who knew the 86000 first o_O
15:38:08 <olsner> I used to remember 120, but I've regressed to 60 decimals now
15:38:14 <fox86> cool
15:38:32 <fox86> i've never met other people with that interest for pi.. seems there are several in this channel
15:38:33 <Cale> I know infinitely many digits of pi. pi = 2 * integral from -1 to 1 of sqrt(1 - x^2)
15:38:50 <LoganCapaldo> Know, or can compute?
15:38:59 <Cale> Is there a difference?
15:39:00 <omnId> what's the difference :)
15:39:12 <fox86> Tobsan: ah. that's a lot
15:39:19 <LoganCapaldo> That's something only a Haskell programmer would say ;)
15:39:19 <Tobsan> indeed it is
15:39:31 <Cale> I once memorised the digits of e to 100 places.
15:39:41 <Cale> and gamma to 50 or so
15:39:49 <Cale> but I never did pi
15:40:06 <ddarius> Congratulations?
15:40:14 <fox86> Cale: ooh, very cool. i remember 2.718281828 because it has 1828 twice after 2.7... and 1828 is the year when Henrik Ibsen was born
15:40:15 <Cale> Yeah, it's pretty silly
15:40:28 <Tobsan> i found my birthday in pi :o
15:40:42 <Tobsan> The string 880730 occurs at position 1,083,966 counting from the first digit after the decimal point.
15:40:45 <Tobsan> :o
15:40:49 <Cale> Digits are the wrong way to look at most numbers anyway.
15:40:56 <fox86> nice, i will look for mine
15:41:02 <Cale> I have no idea why they have such a fixation on them in highschool.
15:41:23 <fox86> i only did it to find out what kind of tricks i would have to use to memorize numbers... and i found out that sound works best for me
15:42:40 <heatsink> You perceive numbers as sounds?  Are you synaesthetic?
15:42:41 <heatsink> ;)
15:42:51 * LoganCapaldo is synthetic
15:43:02 <monochrom> I perceive IRC as sound.
15:43:18 <SamB_XP> monochrom: do you cheat or not?
15:43:19 <LoganCapaldo> I perceive sound as text
15:43:22 <omnId> I percieve pi as a primitive
15:43:25 <sorear> > 4 * atan(1/5) - atan(1/139)
15:43:27 <lambdabot>  0.782388118909231
15:43:32 <fox86> heatsink: no, not like that. it's just that when i try to memorize pi, i remember the sound of how the numbers would sound when i speak them out loud
15:43:39 <sorear> that's how I ... uh don't know it after all
15:44:02 <fox86> heatsink: so, if i try to memorize pi in english, which is not my native language, i have to stop and think a lot
15:45:11 <fox86> Tobsan: my birthday is in pi as well. near 4 million
15:45:55 <heatsink> fox86, The thinking to remember english digits helps?
15:46:51 <SamB_XP> I think my birthday can be found in pi in the klingon system of dates
15:46:51 <fox86> heatsink: no. i just don't see the numbers, so in order to speak them in english, i have to "listen" to them in my native language and say them a few at a time
15:47:05 <fox86> SamB_XP: heheheh
15:47:27 <SamB_XP> also GHC 6.10.1
15:47:37 <sorear> It *would* be mathematically interesting if your birthday wasn't in pi.
15:48:09 <sorear> Since that would disprove the conjecture that pi is normal (contains all digit strings with equal asymptotic frequency)
15:48:43 <olsner> but I have the feeling I've read somewhere that someone's proven that pi eventuelly must contain any arbitrary digit sequence
15:48:47 <heatsink> fox86: hmm, that's pretty normal.
15:49:09 <fox86> heatsink: yep
15:49:14 <SamB_XP> sorear: also that pi contains all digit strings
15:50:03 <TomMD> But none of this matters to the common man, unless you can prove his stomach contains pi!
15:51:01 <augustss> mmmmm, apple pi
15:51:11 <sieni> olsner: I'm not sure if that has been proven, unless it's a recent result
15:51:26 <Cale> pi compresses my birthday.
15:51:34 <Cale> The string 19830421 occurs at position 2,310,735 counting from the first digit after the decimal point.
15:52:02 <sieni> olsner: http://en.wikipedia.org/wiki/Pi#Open_questions
15:52:03 <mrd> augustss: normal order without going inside lambdas is call-by-name, not lazy evaluation (necesarily)
15:52:37 <augustss> mrd: I know
15:52:56 <augustss> but some people call it that anyway
15:54:35 <sieni> the trouble with such problems is that, while almost all real numbers are normal, it seems to be quite difficult to prove it for a paarticular number
15:54:44 <sieni> http://en.wikipedia.org/wiki/Normal_number
15:54:45 <lambdabot> Title: Normal number - Wikipedia, the free encyclopedia
15:54:46 <Cale> Heh, it's not known which of the digits 0,...,9 occur infinitely often in pi, so at some point, there could be no further 0's, or perhaps it just turns into a sequence of 7's and 2's.
15:55:57 <augustss> that would be truly odd
15:56:06 <SamB_XP> heh
15:56:20 <Mr_Awesome> and would change if you used a different radix
15:56:36 <omnId> Cale: but only after ack(g_64, g_64) digits :)
15:56:43 <Cale> yeah, something like that
15:59:22 <dibblego> ?hoogle (a -> Bool) -> [a] -> [[a]]
15:59:26 <lambdabot> No matches, try a more general search
16:02:08 <omnId> dibblego: like words?
16:02:19 <dibblego> ?type words
16:02:21 <dons> get yr hwn! http://sequence.complete.org/hwn/20071025
16:02:24 <lambdabot> String -> [String]
16:02:24 <lambdabot> Title: Haskell Weekly News: October 25, 2007 | The Haskell Sequence
16:02:24 <dons> libraries for all!
16:02:32 <dibblego> omnId, yeah kind of
16:02:36 <mrd> dons: cool
16:02:42 <omnId> f isSpace "blah blah" = ["blah", "blah"] -- ?
16:02:44 <dibblego> omnId, I'll just write it
16:02:55 <omnId> there's one on hpaste
16:03:04 <dibblego> ok thanks
16:03:30 <omnId> http://hpaste.org/3418
16:03:48 <dibblego> ah great thanks
16:04:01 <omnId> @bot
16:04:01 <lambdabot> :)
16:04:33 <omnId> lambdabot: why no title?
16:05:05 <dons> sweet, http://programming.reddit.com/info/5z4yr/comments/
16:05:06 <lambdabot> Title: programming: Haskell Weekly News: 50+ New Libraries, Haskell Workshop Roundup, J ...
16:05:42 <sorear> omnId: lambdabot is rigged to never react to hpaste urls
16:05:57 <omnId> I see.
16:05:57 <sorear> dons: now that we have @ignore, is that still useful/needed?
16:06:20 <dons> in one month we produced more libraries than the ocaml community produced in the last year?
16:06:51 <dons> sorear: i'm not sure. you know where the lambdabot src lives though, if you want to patch it
16:07:21 <sorear> well, I've had some pretty dumb ideas in the past :/
16:07:36 <omnId> > ":)"
16:07:37 <dons> yeah, maybe best not to let you touch lambdabot again
16:07:37 <lambdabot>  ":)"
16:07:45 <omnId> :O
16:11:12 <dons> get some up mods on this, eh? http://programming.reddit.com/info/5z4yr/details :) 1up/1dn isn't so great for such an historic number of new libs. we're past the 1 library per day mark :)
16:11:13 <lambdabot> Title: programming: Haskell Weekly News: 50+ New Libraries, Haskell Workshop Roundup, J ...
16:11:31 <Runaro_BRS> Looking through the yhc source... not big on comments are we?
16:12:04 <Pseudonym> Type declarations ARE comments.
16:12:08 <sorear> Runaro_BRS: which yhc?  the compiler or the runtime?
16:12:23 <Runaro_BRS> looking at the type system at the moment
16:12:34 <Cale> hehe, my MonadRandom library is in Hackage and I didn't have to do anything :)
16:12:37 <sorear> Runaro_BRS: yeah, Rjemo's a bit... infamous
16:12:54 <Runaro_BRS> not just famous...
16:12:55 <sorear> he also seems to have disappeared off the face of the internet
16:13:06 <Runaro_BRS> uh oh
16:13:15 <sorear> there is real intent to rewrite the whole thing
16:13:22 <Runaro_BRS> cool!
16:13:28 <Runaro_BRS> by whom?
16:13:38 <sorear> Runaro_BRS: get in touch with mboes, he's rewriting the typechecker for SOC
16:13:43 <sorear> @seen mboes
16:13:43 <lambdabot> I saw mboes leaving #xmonad and #haskell 1m 4d 7h 58m 1s ago, and .
16:14:00 <sorear> wait, lambdabot keeps state for more than a week now?
16:14:02 <sorear> dons++
16:14:35 <dons> crazy stuff
16:14:38 <allbery_b> was there actually a fix there?  lopbot *usually* keeps its state (excpt when it deadlocks)
16:14:38 <dons> ?users
16:14:38 <lambdabot> Maximum users seen in #haskell: 420, currently: 387 (92.1%), active: 22 (5.7%)
16:14:47 <Runaro_BRS> Hmm... looks like #haskell hackers are disappearing like Spinal Tap drummers.
16:14:51 <allbery_b> but I have seen it lose its state
16:15:31 <newsham> its no longer summertime and the livin is no longer easy
16:15:43 <Runaro_BRS> See, I really wonder if it would be possible to imitate yhc in Scala
16:16:16 <newsham> any reason "in scala" rather than just straight to bytecode?
16:16:21 <omnId> "HCL 1.2. Uploaded by Justin Bailey."  Whoa, a celebrity!
16:16:35 <Runaro_BRS> well, scala compiles to bytecode
16:16:40 <newsham> yup
16:17:29 <LoganCapaldo> i thought there was a haskell on the jvm...
16:17:52 <Runaro_BRS> I thought so too, but I found none.
16:17:52 <newsham> speaking of haskell on vm's.  is there a haskell for the CLR?
16:17:55 <LoganCapaldo> or maybe it was just a haskell written injava
16:18:06 <Runaro_BRS> There's Scheme on JVM
16:18:10 <Runaro_BRS> yay
16:18:16 <andyjgill> There was a Haskell -> JVM, but it compiled from Hugs, not GHC.
16:18:23 <dibblego> there is lambdavm and jaskell, but that doesn't allow transparent use of existing Java gumph like Scala does
16:19:07 <newsham> sounds like they're working hard on supporting languages like python, ruby and ml/ocaml (f#) on the clr
16:19:19 <newsham> you'd think haskell would be in the mix
16:19:19 <LoganCapaldo> augustss++
16:19:31 <newsham> (I assume visual-haskell didnt compile down to clr earlier?)
16:19:32 <augustss> LoganCapaldo: ?
16:20:15 <sorear> newsham: there is haskell on the CLR, but the simons decided it was useless and never released
16:20:25 <LoganCapaldo> untyped ----> depedently typed in a single easy to rad blog post
16:20:34 <LoganCapaldo> *read
16:20:36 <sorear> since getting the FFI to work is somewhat head
16:20:54 <Runaro_BRS> that's very promising
16:21:04 <newsham> interesting
16:21:16 <SamB_XP> I suspect running Haskell on the CLR helps very little with getting FFI going between it and .NET
16:21:49 <augustss> LoganCapaldo: :)  And soon the will be examples too!
16:21:50 <SamB_XP> sure, I guess it avoids having to worry about whether you are using Mono or MS .NET...
16:23:57 <augustss> dons: I like the Jon Harrop quote on HWN, especially since it's false.
16:24:41 <augustss> If I had some more time I'd redo his ray tracing benchmarks.  My figures look totally different.
16:25:05 <n00b> @check and
16:25:07 <lambdabot>  Falsifiable, after 0 tests: [False]
16:25:09 <dons> augustss: yeah, i love his comments :)
16:25:15 <dons> there's some other good ones i'm saving up.
16:25:16 <n00b> :t and
16:25:17 <lambdabot> [Bool] -> Bool
16:26:02 <newsham> > and []
16:26:04 <lambdabot>  True
16:26:23 <augustss> @check or
16:26:24 <lambdabot>  Falsifiable, after 0 tests: []
16:26:42 <dibblego> heh, I like enterprise monads => fail :)
16:26:56 <n00b> > let allSame x = and[head (y) == x | tail (y) == x] in allSame [1,1,1,1]
16:26:57 <lambdabot>   Not in scope: `y'
16:27:31 <n00b> > let allSame x = and[head (x) == y | tail (x) == y] in allSame [1,1,1,1]
16:27:32 <lambdabot>   Not in scope: `y'
16:27:34 <n00b> > let allSame x = and[head (x) == y | tail (x) == y] in allSame [1,1,1,1]
16:27:35 <lambdabot>   Not in scope: `y'
16:27:59 <n00b> > let allSame l = and [ head l == y | y <-tail l ] in allSame [1,1,1,1]
16:28:00 <lambdabot>  True
16:28:10 <n00b> > let allSame l = and [ head l == y | y <-tail l ] in allSame [1,1,1,1,2]
16:28:12 <lambdabot>  False
16:28:20 <n00b> > let allSame l = and [ head l == y | y <-tail l ] in allSame [1,1,1,1]
16:28:21 <lambdabot>  True
16:28:29 <n00b> @vixen thanks
16:28:29 <lambdabot> you're very welcome!
16:29:16 <n00b> @vixen how are you today
16:29:17 <lambdabot> i'm good, you?
16:29:24 <n00b> @vixen good
16:29:24 <lambdabot> good? not great?
16:29:38 <n00b> @vixen nah far from it
16:29:38 <lambdabot> i didn't think so
16:29:55 <n00b> @vixen got to go do some studying later
16:29:55 <lambdabot> psychology
16:30:09 <n00b> @vixen Computer Science
16:30:09 <lambdabot> i like your screen name... what does it mean?
16:30:22 <n00b> @vixen beginner
16:30:22 <lambdabot> you seem upset...
16:30:30 <puusorsa> wanna?
16:30:39 <n00b> @vixen just a hard day bye
16:30:40 <lambdabot> where are you going?
16:30:45 <n00b> @vixen to bed
16:30:46 <lambdabot> why me? :)
16:30:51 <puusorsa> k thx bye
16:31:05 <n00b> @vixen you are my only friend
16:31:05 <lambdabot> i find it hard to masturbate when the lights are on.
16:31:13 <Pseudonym> ...
16:31:42 <Pseudonym> I think we really need to look at turning off or censoring Vixen in #haskell.
16:31:48 <Pseudonym> Not in #haskell-blah.
16:32:19 <n00b> why  ???
16:32:41 <Pseudonym> Because #haskell is a place that we direct people to.
16:33:07 <Pseudonym> Like I said, it'd still be fine in #haskell-blah.
16:33:09 <TomMD> And the PHBs don't like vixens associated with their star project?
16:33:15 <n00b> i'm just  testing the articial capabilities of Elica
16:33:32 <sjanssen> @quote JonHarrop
16:33:32 <lambdabot> JonHarrop says: Absolutely, but you don't want laziness everywhere all the time because it means you can't write fast code.
16:33:35 <sjanssen> @quote JonHarrop
16:33:35 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
16:33:56 <n00b> why did you put it in the first place if you don't want it to be used
16:33:58 <Pseudonym> n00b: Well, it's not eliza.
16:34:13 <n00b> @vixen what is your name
16:34:14 <lambdabot> My name is Emily
16:34:18 <Pseudonym> See?
16:34:26 <n00b> sorry
16:34:29 <TomMD> @vixen who made you
16:34:29 <lambdabot> i dunno, who?
16:34:35 <n00b> but i like it
16:34:44 <n00b> very great program
16:34:50 <puusorsa> WHO IS YOUR DADDY AND WHAT DOES HE DO?!!
16:34:50 <Pseudonym> Sure, and it would still be available via /msg or by joining #haskell-blah.
16:35:02 <puusorsa> who is your daddy and who does he do???
16:35:26 <n00b> talking to me?
16:35:35 <n00b> @slap puusora
16:35:35 <puusorsa> depdeds
16:35:35 * lambdabot moulds puusora into a delicous cookie, and places it in her oven
16:36:16 <n00b> @google Lambdabot commands
16:36:19 <lambdabot> http://ircarchive.info/haskell/2007/5/9/71.html
16:36:19 <lambdabot> Title: haskell Unknown command, try @list @list http://www.cse.unsw.edu.au/~dons/lambda ...
16:36:23 <Pseudonym> The other option is to clean up the responses.
16:36:35 <Pseudonym> Vixen was designed to be an IM bot.
16:36:46 <Pseudonym> On a public channel, that's a bit less appropriate.
16:36:49 <n00b> and ???
16:37:06 <n00b> i am talking to it
16:37:11 <n00b> do you mind ?
16:37:22 <Pseudonym> I'm not concerned about having an AI bot here.
16:37:26 <n00b> isn't it "open" source
16:37:40 <Pseudonym> I'm concerned that unprofessional and arguably NSFW responses come automatically from our bot.
16:37:54 <n00b> i see
16:38:05 <n00b> well the bot needs to be talk to
16:38:09 <Pseudonym> Yes.
16:38:22 <Pseudonym> ?vixen Wash your mouth out!
16:38:22 <lambdabot> I have a boyfriend, but he likes to watch.
16:38:30 <puusorsa> lambdabot, <3
16:38:34 <puusorsa> lambdabot, wanna????
16:38:38 <Pseudonym> ?vixen TMI.  Really.
16:38:38 <lambdabot> cool
16:39:07 <n00b> leave her alone
16:39:52 <Olathe> @kick @vixen
16:39:52 <lambdabot> Maybe you meant: dice dict kind
16:40:11 <n00b> @kick Olathe
16:40:12 <lambdabot> Maybe you meant: dice dict kind
16:40:25 <n00b> what does @kick do ??
16:40:33 <puusorsa> try
16:40:36 <n00b> kick out someone ??/
16:40:50 <n00b> @kick puusorsa
16:40:51 <lambdabot> Maybe you meant: dice dict kind
16:41:06 <chessguy> @. kick vixen
16:41:06 <lambdabot> Plugin `compose' failed with: Unknown command: "kick"
16:41:28 <Olathe> @compose kick vixen
16:41:29 <lambdabot> Plugin `compose' failed with: Unknown command: "kick"
16:41:33 <Olathe> orly
16:41:56 <n00b> @compose s
16:41:56 <lambdabot> Not enough arguments to @.
16:42:06 <n00b> @
16:42:11 <n00b> @help
16:42:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:42:14 <kscaldef> vixen is considerably less offensive than the typical conversation on the IRC channels of many more commonly used languages
16:42:17 <puusorsa> wanna?
16:42:27 <n00b> help list
16:42:32 <n00b> @list
16:42:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:42:52 <n00b> @version
16:42:52 <lambdabot> lambdabot 4p568, GHC 6.6 (Linux i686 2.66GHz)
16:42:53 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:43:17 <Philippa> kscaldef: yeah, but we do actually /aim/ to be better than them. And vixen's definitely off-topic
16:43:25 <n00b> @babel hola
16:43:25 <lambdabot>   bzzt.
16:43:31 <n00b> @babel chica
16:43:31 <lambdabot>   bzzt.
16:44:02 <Philippa> IIRC vixen predates the #haskell/#haskell-blah split
16:44:13 <ac> anybody here used HOpenGL?
16:44:17 <n00b> @hoogle and
16:44:18 <lambdabot> Prelude.and :: [Bool] -> Bool
16:44:18 <lambdabot> Prelude.significand :: RealFloat a => a -> a
16:44:18 <lambdabot> System.Process.runCommand :: String -> IO ProcessHandle
16:44:20 <Pseudonym> Yeah, I think that's right.
16:44:27 <kscaldef> Philippa: sure... I'm just saying that I think the PHB argument doesn't hold water
16:44:48 <Pseudonym> The proposal, anyway, is that vixen will still be around, just not as easy to get to in the forum that we point everyone to.
16:45:01 <ac> I'm looking for some example code that uses textures. I've found 3 or 4 example programs, but no texture stuff
16:45:16 <Pseudonym> ?listchans
16:45:16 <lambdabot> ##logic #darcs #gentoo-haskell #ghc #haskell #haskell-blah #haskell-overflow #haskell-soc #jtiger #parrot #perl6 #scala #scannedinavian #unicycling #xmonad
16:45:20 <Pseudonym> Hey, I got an idea!
16:45:30 <Pseudonym> Turn it off in #haskell, and make it mandatory in #perl6!
16:45:31 <allbery_b> ah, finally starting to do per-channel stuff.  I've been prcrastinating doing that to lopbot
16:46:06 <Philippa> I suspect we'd tell someone to turn off an equivalent feature in any other bot these days
16:46:15 <Pseudonym> Yeah.
16:46:26 <Philippa> hell, I know I would
16:47:10 * allbery_b has vixen compiled out anyway, but wanted per-channel @url-off last night and has one channel where automatic @tiny-url is not wanted (an existing bot with mroe functionality, specifically remembering who and where originally pasted it if appropriate)
16:47:30 <Philippa> yeah, per-channel config makes sense
16:48:12 <panagos> where can i find a full table with all haskell builtin operators, their precedence and their associativity? like what "man operator" does for C ;)
16:48:39 <mauke> depends on your definition of "builtin operator"
16:48:52 <panagos> mauke: + - == >>= etc etc
16:49:01 <mauke> those aren't built into the language
16:49:06 <mauke> they're just part of the standard library
16:49:09 <bobafett> @source Prelude
16:49:10 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
16:49:16 <Philippa> panagos: there's one in the Report somewhere
16:49:34 <mauke> http://haskell.org/onlinereport/decls.html
16:49:35 <lambdabot> Title: The Haskell 98 Report: Declarations
16:49:47 <mauke> search for "right assoc"
16:49:55 <panagos> all "punctuation only" unary/infix binary operators...
16:50:10 <Philippa> http://www.haskell.org/onlinereport/decls.html#prelude-fixities
16:50:11 <lambdabot> Title: The Haskell 98 Report: Declarations
16:50:12 <mauke> there are no unary punctuation operators
16:50:16 <mauke> except for -, which is evil
16:50:37 <LoganCapaldo> that's really annying in haskell
16:50:52 <LoganCapaldo> (unary -)
16:51:15 <panagos> excuse me for my C nomenclature :D
16:51:37 <bobafett> http://zvon.org/other/haskell/Outputprelude/index.html
16:51:38 <lambdabot> Title: Zvon - Haskell Reference
16:51:56 <mauke> of course that table doesn't list <|>, <||>, .&., .|., ~>, ***, &&& or >>>
16:52:28 <Pseudonym> I personally don't see why Haskell shouldn't have unary punctuation.  I think the exception is more evil than officially blessing a clean solution.
16:52:38 <Pseudonym> But I know I'm in a minority on that one.
16:52:56 <LoganCapaldo> I don't have a problem with unary punction, just -.
16:53:19 <panagos> well, (a >>= b >>= c) is ((a >>= b) >>= c) or (a >>= (b >>= c)) ?
16:53:27 * wli thinks parsing is easy enough to support unary prefix, unary postfix, mixfix/whatever, etc. without issue.
16:53:49 <mauke> panagos: >>= is left associative
16:54:22 <LoganCapaldo> panagos: if lambdabot was ghci you coud type :info (>>=) and it would tel you if it were infixl or infixr
16:54:50 <LoganCapaldo> so instead you can just type that into ghci
16:56:58 <n00b> what language didi they use to write haskell
16:57:00 <n00b> ???
16:57:15 <LoganCapaldo> haskell
16:57:15 <allbery_b> haskell :>
16:57:19 <mauke> what do you mean by "write haskell"?
16:57:25 <mauke> I think they used English
16:57:30 <n00b> @source ubuntu
16:57:31 <lambdabot> ubuntu not available
16:57:31 * allbery_b is not clear on whether the initial bootstrap was from gofer or from miranda
16:57:43 <Pseudonym> Gofer post-dates GHC.
16:57:58 <Pseudonym> But it could have been one of the pre-Haskell Miranda-alikes.
16:58:03 <allbery_b> (and hugs is written in C so has no bootstrap issues)
16:58:03 <wli> hbc, Lazy ML?
16:58:03 <Pseudonym> Like Miracula or Orwell.
16:58:10 <n00b> programming language
16:58:16 <Pseudonym> Unlikely to be Orwell specifically.  I think that was Macintosh-only.
16:58:31 * Pseudonym only used it on a Mac, anyway
16:58:33 <mauke> programming languages aren't written in programming languages
16:58:33 <n00b> what programming language did the use to compile haskell
16:58:37 <LoganCapaldo> Big brother is watching, but only a on a mac!
16:58:38 <puusorsa> haskell
16:58:48 <Pseudonym> GHC is written in Haskell.
16:58:48 <mauke> n00b: haskell is not a program
16:58:49 <omnId> n00b: GHC is written in haskell, Hugs I think in C.
16:58:53 <Pseudonym> Yeah.
16:58:58 <n00b> haskell to write haskell
16:59:10 <wli> Neither Miracula nor Orwell are described in wikipedia.
16:59:12 <LoganCapaldo> C is written in C usualy too
16:59:17 <Pseudonym> wli: I have a long memory.
16:59:26 <Pseudonym> Orwell was Phil Wadler's Miranda-alike.
16:59:26 <n00b> that doesn't make sense
16:59:26 <SamB_XP> LoganCapaldo: I never will figure out why :-(
16:59:27 <LoganCapaldo> Lisp often as well
16:59:30 * wli continues to point to hbc.
16:59:51 <Pseudonym> And it had a few particularly bizarre features, which I'm very pleased Haskell didn't touch.
16:59:55 <omnId> n00b: something else compiled a first compiler long ago, then that was used to compile the first one, then that for the second, etc.
16:59:55 <n00b> how can you use  a language to create a language compiler that haven't been made
16:59:57 <n00b> ??
16:59:58 <ac> n00b: http://en.wikipedia.org/wiki/Self-hosting
16:59:59 <lambdabot> Title: Self-hosting - Wikipedia, the free encyclopedia
16:59:59 <SamB_XP> n00b: heck, I can't understand why we don't write C compilers in Haskell
17:00:08 <Pseudonym> wli: And hbc was written in...?
17:00:18 <SamB_XP> well, I probably would write a stupid one if Language.C existed
17:00:39 <n00b> so what was the first compiler ???
17:00:42 <Pseudonym> ?foldoc Miracula
17:00:44 <lambdabot> *** "miracula" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
17:00:44 <lambdabot> Miracula
17:00:44 <lambdabot>  
17:00:44 <lambdabot>         An implementation of a subset of {Miranda} by Stefan Kahrs
17:00:44 <lambdabot>         <smk@ed.ac.uk>, LFCS, no modules or files.  Can be
17:00:46 <lambdabot> [3 @more lines]
17:00:46 <n00b> written in???
17:00:47 <Pseudonym> n00b: FLOW_MATIC
17:00:52 <Pseudonym> And it was written in assembler.
17:01:05 <Pseudonym> FLOW-MATIC, with a hyphen.
17:01:11 <Olathe> Assembler is written in letters.
17:01:14 <omnId> And assemblers were written by twiddling machine addresses.
17:01:19 <Olathe> So is Haskell.
17:01:30 <Pseudonym> Although interpreters are very old.
17:01:40 <Pseudonym> CSIRAC had a high-level language interpreter in 1950.
17:01:40 <omnId> And the green grass grows all around all around.
17:02:02 <Pseudonym> I got that first-hand from someone who worked on it.
17:02:17 <n00b> so are new features implemented in the old compiler if they have never been implemented before ??/
17:02:21 <wli> wikipedia documents the language as INTERPROGRAM
17:02:42 <Pseudonym> n00b: New features are bootstrapped from old features.
17:02:54 <mauke> @go "trusting trust"
17:02:55 <n00b> ok
17:02:57 <Pseudonym> You don't need type families to write a Haskell compiler.
17:02:58 <lambdabot> http://www.acm.org/classics/oct95/
17:02:58 <lambdabot> Title: TOC
17:03:06 <Pseudonym> ?foldoc Orwell
17:03:07 <lambdabot> *** "orwell" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
17:03:07 <lambdabot> Orwell
17:03:07 <lambdabot>  
17:03:07 <lambdabot>         Lazy functional language, Miranda-like.  List comprehensions
17:03:07 <lambdabot>         and pattern matching.  "Introduction to Orwell 5.00",
17:03:09 <lambdabot>         P.L. Wadler et al, Programming Research Group, Oxford U, 1988.
17:03:10 <wli> And describes it as a sort of precursor of BASIC or otherwise similar to early forms of BASIC.
17:03:11 <lambdabot>  
17:03:16 <n00b> weird but i understand
17:03:33 <Olathe> O-o
17:03:49 <mauke> http://cm.bell-labs.com/who/ken/trust.html
17:03:51 <n00b> i see it is like writing functions in haskell then implementing in Prelude
17:03:51 <lambdabot> Title: ACM Classic: Reflections on Trusting Trust
17:03:53 <Olathe> @foldoc foldoc
17:03:53 <lambdabot> Error: connect: does not exist (No route to host)
17:03:56 <n00b> right ???
17:04:36 <Pseudonym> OK, I tell a lie.  INTERPROGRAM comes from 1960.
17:04:41 <Pseudonym> http://www.csse.unimelb.edu.au/dept/about/csirac/emulator.html <- Emulator
17:04:49 <Olathe> # Liar ! #
17:05:39 <EvilTerran> @yow
17:05:39 <lambdabot> I've got an IDEA!!  Why don't I STARE at you so HARD, you forget your
17:05:39 <lambdabot> SOCIAL SECURITY NUMBER!!
17:06:09 <wli> Fortran (1954) is usually described as the first full-fledged programming language in various senses.
17:07:08 <wli> Grace Hopper's A-1 (1951), for example, was more akin to what people would call a macroassembler, and much the same held for other early languages predating Fortran AIUI.
17:07:18 <mauke> Plankalkl ftw
17:07:35 <n00b> so how was the  first programming language implemented / written
17:08:06 <lament> on paper
17:08:13 <n00b> you know what, let's just drop this subject
17:08:30 <n00b> but how was it implemented on the computer
17:08:31 <puusorsa> punchcards for teh win!
17:08:31 <EvilTerran> in ada lovelace's head!
17:08:31 <wli> Plankalkul never went anywhere, though.
17:08:49 <puusorsa> n00b, punching holes in paper cards probably
17:08:51 <Pseudonym> n00b: Programmers used to enter programs via switches.
17:08:57 <wli> http://en.wikipedia.org/wiki/Timeline_of_programming_languages
17:08:58 <lambdabot> Title: Timeline of programming languages - Wikipedia, the free encyclopedia
17:08:58 <Pseudonym> Writing directly to memory.
17:09:05 <Pseudonym> Before that, it was plugboards.
17:09:06 <Olathe> Rewiring circuits is better.
17:09:11 <Philippa> right, the lowest level languages are just wired into the hardware
17:09:17 <Olathe> Plugboards is for wimpy men !
17:09:38 <n00b> i se4e
17:09:43 <Olathe> Real mean assemble special-purpose computers from spare parts !
17:09:49 <Philippa> yeah yeah yeah, when I were a lass every time we found a bug we had to rebuild the whole damn stone circle and wait another millennium!
17:09:52 <n00b> thanks for the history lesson
17:10:02 <augustss> n00b: hand translated to machine code, then entered with switches/buttons
17:10:07 <EvilTerran> hehe
17:10:09 <lament> Philippa: and execute the QA!
17:10:12 <scook0__> Olathe: reusing existing else's spare parts? weak! ;)
17:10:17 <Olathe> Heheh
17:10:22 <n00b> you guys are better than any book
17:10:24 <EvilTerran> @quote Philippa yeah yeah yeah, when I were a lass every time we found a bug we had to rebuild the whole damn stone circle and wait another millennium!
17:10:24 <lambdabot> No quotes match.
17:10:27 <augustss> n00b: that's what I did when I built my first computer
17:10:31 <EvilTerran> @remember Philippa yeah yeah yeah, when I were a lass every time we found a bug we had to rebuild the whole damn stone circle and wait another millennium!
17:10:31 <lambdabot> It is stored.
17:10:34 <wli> The story appears to be complex.
17:10:48 <puusorsa> oh damn
17:10:50 <LoganCapaldo> it is stored?
17:10:53 <puusorsa> i really think i'm in love
17:10:54 <LoganCapaldo> nicee
17:11:01 <EvilTerran> wli, i likewise get the impression that it's partly imaginary... ;)
17:11:21 <n00b> @quite augustss that must have been difficult
17:11:21 <lambdabot> Maybe you meant: quit quote
17:11:27 <n00b> @quote augustss that must have been difficult
17:11:28 <lambdabot> No quotes match. It can only be attributed to human error.
17:11:43 <Olathe> @. vixen quit
17:11:43 <lambdabot> Plugin `compose' failed with: Privledged commands cannot be composed
17:11:45 <augustss> n00b: redious
17:11:56 <augustss> noob: tedious, even
17:12:17 <n00b> you can write a GUI in asm
17:12:20 <n00b> ??
17:12:25 <Pseudonym> People have.
17:12:25 <augustss> It got easier after I had a monitor and assembler burnt into EEPROM
17:12:29 <Pseudonym> GEOS
17:12:32 <EvilTerran> compilers do
17:12:41 <augustss> Who wants a GUI?
17:12:48 <n00b> ok\
17:12:49 <lament> i do!
17:12:52 <wli> Not really. There's a lot of reality here. The "concept" bits mean "failed attempt" or "attempt begun" depending on whether "implementation" appears later.
17:12:56 <Philippa> they're nice for arranging where all the text goes
17:12:57 <Pseudonym> http://en.wikipedia.org/wiki/GEOS_(8-bit_operating_system)
17:13:04 <n00b> blank screen was your friend
17:13:51 <n00b> is there a emacs version that runs in terminal mode
17:14:01 <lament> it's called... "emacs"?
17:14:16 <n00b> I have a computer but i want to try using it without gui
17:14:19 <puusorsa> n00b, are you serious or just trolling
17:14:21 <puusorsa> emacs -nw
17:14:33 <puusorsa> try man emacs
17:14:42 <lament> also, GUI is nice because otherwise it's hard to show pictures/movies
17:14:56 <qwr> n00b: or screen + vim
17:14:57 <augustss> pictures?  movies?
17:14:59 <glguy> and its good that you have a computer or emacs use would be hard
17:15:00 <lament> youtube, for example, would not work well without GUI
17:15:20 <augustss> computers are for programming, not playing with ;)
17:15:23 <n00b> i want to take away the GUI so i can concentrate more on my school work
17:15:23 <fons> n00b, just type "emacs -nw" in a terminal
17:15:34 <puusorsa> like i said..
17:15:34 <lament> just don't run X
17:15:36 <n00b> i don't like vim
17:15:45 <lament> then the command is just "emacs"
17:16:01 <n00b> the only command i know for vim is :qa!
17:16:07 --- mode: ChanServ set +o glguy
17:16:12 <lament> oh no
17:16:16 <LoganCapaldo> programming is definitely playing
17:16:17 --- mode: glguy set +b *!*=41b708c2@gateway/web/cgi-irc/ircatwork.com/x-0a663347d1364343
17:16:17 --- kick: n00b was kicked by glguy (i don't get it)
17:16:18 <lament> turns out vim was glguy's favourite editor!
17:16:20 <Philippa> augustss: false dichotomy
17:16:40 <augustss> LoganCapaldo, Philippa: I know :)
17:16:44 <SamB_XP> augustss: please explain to me the difference between the too
17:16:45 <SamB_XP> er.
17:16:45 <fons> oh C'mon
17:16:46 <SamB_XP> tow
17:16:48 <SamB_XP> two
17:16:50 <SamB_XP> to
17:16:57 <Philippa> SamB_XP: one is a subset of the other
17:17:08 <SamB_XP> I think that's incorrecxt
17:17:21 <augustss> extended subset
17:17:26 <SamB_XP> wli: what do you think?
17:21:18 --- mode: glguy set -b *!*=41b708c2@gateway/web/cgi-irc/ircatwork.com/x-0a663347d1364343
17:22:46 --- mode: glguy set -o glguy
17:23:23 <glguy> :oS
17:23:30 --- mode: ChanServ set +o glguy
17:23:32 --- mode: glguy set +b *!*=41b708c2@gateway/web/cgi-irc/ircatwork.com/x-26e89f2b52c2f49a
17:23:32 --- kick: n00b was kicked by glguy (glguy)
17:23:38 <glguy> I guess the ban stays
17:23:41 --- mode: glguy set -o glguy
17:23:58 <joed> That many pm
17:24:27 <EvilTerran> ... i'm confused. why the ban?
17:24:50 <puusorsa> "ignorance can be cured, stupidity is for life" ?
17:25:01 <glguy> I read the /lastlog n00b
17:25:10 <lament> i'm even more confused, why the unban followed by the ban?
17:25:19 <glguy> I usually /kn
17:25:31 <glguy> which sets a temp ban with the idea that the person moves on
17:25:37 <glguy> so the list don't just fill up
17:25:59 * EvilTerran also reads said /lastlog
17:26:06 <EvilTerran> ... yeah. i can see where you're coming from.
17:26:52 <lament> is it because of the multiple question marks???
17:27:07 <glguy> even if he wasn't just trying to be a pest he isn't going to be up to programming competence for another decade
17:27:07 <n00b> why did i get kick out
17:27:17 <TSC> There's your answer!
17:27:28 <sorear> EvilTerran:  #haskell is different because we ban annoying people in addition to malicious ones
17:27:51 <LoganCapaldo> the iron fist in the velvet glove
17:27:55 <lament> sorear: that's not what i heard shapr say.
17:28:02 <sorear> makes the place a LOT nicer than most other channels, if you're one of the people who stays
17:28:10 <glguy> ?users
17:28:10 <lambdabot> Maximum users seen in #haskell: 420, currently: 389 (92.6%), active: 21 (5.4%)
17:28:15 <glguy> of which there are many
17:28:20 <Philippa> lament: it's a valid approximation
17:28:23 <EvilTerran> lambdabot, what did shapr say?
17:28:44 <LoganCapaldo> lambdabot's AI isn't  _that_ strong
17:28:45 <lambdabot> No idea, sorry.
17:29:13 <Philippa> n00b: evading bans is a bad idea, and in some countries arguably constitutes a criminal offence. Go away.
17:29:36 <Pseudonym> If the ban comes off by itself, it's probably not criminal.
17:29:40 <Pseudonym> Just sayin'.
17:29:57 <mauke> glguy: +b *!i=41b708c2@gateway/web/cgi-irc/*
17:30:04 <lament> EvilTerran: i suppose he did say something like that, except that you'd have to be really annoying
17:30:04 <glguy> kk
17:30:04 <Pseudonym> Right, I see.
17:30:11 --- mode: ChanServ set +o glguy
17:30:21 --- mode: glguy set +b *!i=41b708c2@gateway/web/cgi-irc/*
17:30:29 --- kick: n00b was kicked by glguy (glguy)
17:30:29 <mauke> cool
17:30:37 <mauke> hmm, let's see ...
17:30:42 --- mode: glguy set -b *!*=41b708c2@gateway/web/cgi-irc/ircatwork.com/x-26e89f2b52c2f49a
17:30:48 <mauke> glguy: +o mauke
17:31:06 --- mode: glguy set +v mauke
17:31:17 <mauke> you're doing it wrong!
17:31:26 <glguy> oh, I must have remapped the keyboard wrong :-/
17:31:37 <mauke> this exploit sucks. I want my money back.
17:31:46 --- mode: glguy set -o glguy
17:32:39 <glguy> sorear: I don't know if your statement for for or against me removing him, but I don't think he constitutes a positive addition to the channel
17:32:46 <Pseudonym> Did anyone give n00b a warning before banning, BTW?
17:32:48 <glguy> s/for for/was for
17:32:54 <Pseudonym> Just asking.
17:33:51 <sorear> glguy: I was trying to defend you.
17:33:54 <glguy> ah, ok
17:34:31 <glguy> anyway, if someone else wants to remove the ban they can, I don't feel that strongly about it. I just didn't think he was fitting in so well, so to speak..
17:35:00 <Pseudonym> Sure, I'm not saying it was a bad decision.
17:35:00 <Olathe> I ignored him a few days ago.
17:35:14 <Pseudonym> It's just that whenever a decision like this is made, it's good to sit down and think about future implications.
17:35:14 <lament> I'll at least ask shapr what he thinks, if nobody gets there first
17:35:32 <glguy> dons is the one to ask
17:35:38 <glguy> I think that shapr handed the channel along
17:35:42 <Pseudonym> shapr vs dons deathmatch!
17:35:45 <lament> possibly, but shapr seems nicer :)
17:35:53 <Pseudonym> dons doesn't bite, AFAIK
17:35:54 <puusorsa> then ask dons
17:36:53 <ac> glguy: what does your 'gl' stand for?
17:37:04 <glguy> originally "gamma lambda"
17:37:13 <Philippa> it's probably a good rule to warn before banning unless you've got very good grounds for immediately removing someone from a chan
17:37:19 <Pseudonym> Yeah.
17:37:29 <Pseudonym> A spammer, for example.
17:37:48 <Pseudonym> Anyway, something to think about.
17:37:50 <Philippa> assuming the spam wasn't reasonably on-topic, in which case a warning's appropriate
17:38:00 <glguy> I know at least one of you has +o, feel free to talk it over with n00b and see if he wants to behave and then unban if he does
17:38:16 <Philippa> I mean... Jon Harrop doesn't quite warrant kickbanning on sight
17:38:16 * Pseudonym isn't going to bother, but thanks for the offer :-)
17:38:28 <glguy> qwe1234 does
17:38:28 <Pseudonym> Yeah, or keal.
17:38:33 <Pseudonym> keal was amusing
17:38:38 <EvilTerran> @keal
17:38:39 <lambdabot> when i put what i dat recoved from that tile into a ti92. the damn thing blew up
17:38:50 <Philippa> has qwe1234 shown up here before?
17:38:58 <Pseudonym> Oh yes.
17:38:59 <glguy> only people pretending to be him
17:39:02 <Pseudonym> Oh, right.
17:39:09 * Pseudonym thought it was him
17:39:10 <lament> @qwe1234
17:39:10 <lambdabot> Unknown command, try @list
17:39:11 <glguy> which is grounds enough, imho
17:39:31 <glguy> I want a record of my kicking him in the logs, I don't care who it actually is
17:39:42 <lament> oh, heh, i just realized qwe1234 is really easy to type on a qwerty keyboard
17:39:44 <EvilTerran> who is qwe1234?
17:39:48 <Philippa> I'd probably be inclined to leave that ban nick-specific, mind
17:39:51 <glguy> a reddit troll
17:39:57 <EvilTerran> ah
17:39:58 <glguy> Philippa: sure
17:41:01 <glguy> Philippa: oh, I wasn't proposing a ban :)
17:41:03 <glguy> Philippa: just a kick
17:41:18 <qwe1234> Just checking.
17:41:25 <glguy> I'm not that fast
17:41:34 <Philippa> should've scripted it, then
17:41:34 <Pseudonym> ha!
17:41:38 <glguy> yeah :(
17:41:38 <Pseudonym> Yeah.
17:41:52 <glguy> damn, that's the 3rd time its been pulled out from under me
17:42:04 <lament> we could play "whack-a-mole", with different people changing their nick to qwe1234 and back and glguy trying to ban them.
17:42:15 <Pseudonym> He'd just write a script, then.
17:42:21 <lament> Objective: to get 388 points.
17:42:31 <Pseudonym> lambdabot could record the scores.
17:42:35 <mauke> @karma qwe1234
17:42:35 <lambdabot> qwe1234 has a karma of 0
17:42:40 <Pseudonym> Surely it would be whack-a-troll.
17:42:45 <ivanm> @doc Data.Complex
17:42:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Complex.html
17:44:17 <EvilTerran> wow, something on-topic. how rare.
17:44:23 <ivanm> lol
17:44:25 <glguy> yw
17:44:32 <Pseudonym> Oh, maths question.
17:44:32 <ivanm> I'm sorry, I'll say something irrelevant
17:44:40 <Pseudonym> Does anyone know why it's called "evaluation at infinity"?
17:44:44 <Pseudonym> That's poetic licence, right?
17:44:58 <EvilTerran> > (sort "irrelevant", sort "evilterran")
17:45:00 <lambdabot>  ("aeeilnrrtv","aeeilnrrtv")
17:45:09 <ivanm> lol
17:45:20 <ivanm> so EvilTerran == irrelevant? :p
17:45:24 <Pseudonym> pi_inf(p) == p(infnity) / infinity^deg(p)
17:45:27 <Pseudonym> More or less.
17:46:02 <monochrom> Yay! Haskell Quaterly News!
17:46:16 <EvilTerran> ivanm, indeed; i used Irrelevant as a nickname before i used EvilTerran as such, but Irrelevant was taken on freenode
17:46:21 <lament> Pseudonym: it evaluates at infinity
17:46:27 <ivanm> EvilTerran: ahhh
17:46:37 <ivanm> monochrom: sure you mean the Haskell _Weekly_ News!
17:46:47 <Pseudonym> lament: ?
17:46:48 <idnar> hahaha
17:46:55 <ivanm> despite the fact that dons seems to use a different definition of "week" from the rest of us?
17:47:14 <monochrom> Yeah, his week is our quarter. :)
17:47:22 <Runaro_BRS> "Fortnightly news"
17:47:27 <LoganCapaldo> a week is about a quarter
17:47:30 <ivanm> "Random interval" news
17:47:33 <idnar> a quarter of what?
17:47:36 <LoganCapaldo> (of a month)
17:47:37 <ivanm> a month
17:47:40 <Olathe> The Haskell Periodic News
17:47:43 <SamB_XP> an apple
17:47:51 <ivanm> Olathe: with a varying period!
17:47:53 <monochrom> "Dons sees a quarter as a week, a week as a random number of weeks."
17:48:00 <lament> Pseudonym: Do you mean the evaluation at infinity of a polynomial?
17:48:05 <Pseudonym> Yes.
17:48:09 <ivanm> monochrom: a week as a random number of weeks? :s
17:48:11 <Olathe> The Haskell Intermittent News ?
17:48:12 <TomMD> That lazyness is just rubbing off on him.
17:48:20 <ivanm> so x = a * xs ?
17:48:26 <Pseudonym> It's obviously not just p(infinity)
17:48:29 <glguy> dons manages to keep pretty busy
17:48:40 <ivanm> glguy: sure, make up excuses for him!
17:48:42 <Pseudonym> But it's kind of p(infinity) / infinity^degree(p)
17:48:51 <TomMD> glguy: Oh, I'm sure.  Just have to throw the word 'lazy' in once a day.
17:48:53 <Runaro_BRS> The Haskell non-time-indexed news.
17:49:06 <ivanm> the Haskell "Whenever dons feels like it" news
17:49:16 <lament> Pseudonym: hm what the hell is that
17:49:33 <EvilTerran> dons has to unsafeInterleaveIO it with the rest of his work, so it tends to happen at unexpected times
17:49:38 <SamB_XP> the haskell semi-whenever news
17:49:41 <EvilTerran> (and usually later than you intended ;] )
17:49:41 <monochrom> Dons probably spends his clock and runs a garbage collector once in a while. :)
17:49:52 <monochrom> s/spends/suspends/
17:49:56 <Pseudonym> lament: The evaluation at infinity of a polynomial is essentially the leading coefficient, IIRC.
17:49:58 <TomMD> Where did unsafeInterleaveIO go though?  It moved with the new bytestring library!
17:50:11 <SamB_XP> TomMD: nonsense
17:50:19 <SamB_XP> @hoogle unsafeInterleaveIO
17:50:20 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
17:50:44 <TomMD> Was it always there and I am just losing my mind?
17:50:56 <lament> Pseudonym: so it's 1 for both x and x^2? I've never heard of this thing
17:50:57 <SamB_XP> well, it may or may not have undergone movement
17:51:03 <TomMD> What was the 'unsafe' that they made for ByteString?
17:51:37 <SamB_XP> TomMD: perhaps you are thinking of the blackhole/greyhole versions?
17:51:53 <SamB_XP> or whatever I mean
17:52:04 <SamB_XP> the non-dupable ones, anyway
17:52:16 <Pseudonym> lament: Yes, I believe.
17:52:47 <ivanm> without causing offence, I'd like to get back on topic for a bit here :p
17:52:48 <Pseudonym> Obviously p(infinity) is going to be either infinity or -infinity for any real polynomial.
17:52:49 <ivanm> is that OK?
17:52:52 <TomMD> SamB_XP: I am thinking of 'inlinePerformIO' which is poorly named / unsafe.
17:53:01 <Pseudonym> ivanm: That's cool. :-)
17:53:06 <ivanm> *phew*
17:53:14 * Pseudonym is actually asking this question because of a Haskell problem.
17:53:19 <Pseudonym> So it's kind of on-topic.
17:53:25 <ivanm> I meant the news discussion
17:53:27 <ivanm> ;-)
17:53:49 <TomMD> actually, if compiler /= ghc then inlinePerformIO = unsafePerformIO
17:53:53 <lament> Pseudonym: is it related to the residue?
17:54:04 <lament> Pseudonym: that's what it looks like
17:54:54 <ivanm> OK, so I've representing a 2D area using a 2D array... and I want a function that - relative to (0,0) - lists all the indices around element in compass order, starting with (-1,1) for the NW corner
17:54:56 <Pseudonym> Yeah, and it's also related to the order function.
17:54:59 <SamB_XP> wow this code is scary: http://www.haskell.org/pipermail/haskell-cafe/2007-March/023592.html
17:55:01 <lambdabot> Title: [Haskell-cafe] Does inlinePerformIO = unsafePerformIO . unsafeInterleaveIO seman ..., http://tinyurl.com/2nug2x
17:55:11 <Pseudonym> It's also defined on rational polynomials which don't have a pole at infinity
17:55:17 <ivanm> atm, I've hardcoded in "[(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]", but I'd like to have a generating function if possible
17:55:20 <ivanm> any ideas?
17:55:29 <lament> Pseudonym: surely it's not called "evaluation", though?
17:55:57 <Pseudonym> It's called the "value at infinity" or "evaluation at infinity".
17:56:47 <Pseudonym> > [ (dx,dy) | dx <- [-1..1], dy <- [-1..1], dx /= 0 || dy /= 0 ]
17:56:55 <lambdabot>  [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
17:57:11 <Pseudonym> It's not necessarily that much shorter, though.
17:57:13 <lament> Pseudonym: seems very odd, why treat infinity as special
17:57:14 <EvilTerran> (dx,dy) /= (0,0), if you prefer
17:57:32 <lament> i don't think it's general-purpose terminology
17:57:49 <Pseudonym> lament: It's not p(infinity).
17:58:00 <Pseudonym> It has a notation more pile \pi_{\infinity}(p)
17:58:03 <Pseudonym> more like
17:58:33 <ivanm> Pseudonym: whoops, that's not what I wanted... that's when I sorted it :s
17:58:38 <lament> and the pi is called "evaluation"?
17:58:55 <ivanm> "[(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1),(-1,0)]" <-- this is what it should be
17:59:05 <Pseudonym> Here's the definition from the book I'm reading:
17:59:29 <ivanm> however, the only way I can think of generating these values in that order is by using trig, which involves rounding, etc. to get the Ints
17:59:44 <Pseudonym> We define the "value at \infinity" to be the map \pi_{\infinity} : O_\infinity -> F given by:
17:59:45 <Pseudonym> etc etc
18:00:23 <lament> what's the book on?
18:00:44 <Pseudonym> http://books.google.com.au/books?id=8SAaSd89sSkC&dq=bronstein+symbolic+integration&pg=PP1&ots=QUrJSzlMLB&sig=Q0eCkb94pbikYth6pIeyKXzq5uQ&prev=http://www.google.com.au/search%3Fsource%3Dig%26hl%3Den%26rlz%3D%26q%3Dbronstein%2Bsymbolic%2Bintegration%26btnG%3DGoogle%2BSearch%26meta%3D&sa=X&oi=print&ct=title&cad=one-book-with-thumbnail
18:00:46 <lambdabot> Title: Symbolic Integration I ... - Google Book Search, http://tinyurl.com/24x25s
18:00:51 <Pseudonym> It's that one.
18:00:53 <Pseudonym> Let me find the page.
18:01:19 <Pseudonym> Ah, if you search for "value at" and select page 117.
18:01:23 <lament> symbolic integration...
18:01:26 <ivanm> Pseudonym: couldn't you find a longer url? :p
18:01:35 <Pseudonym> ivanm: No, sadly.
18:01:41 <lament> then it's probably just some shortcut to make things easier
18:01:41 <ivanm> :(
18:02:08 <Pseudonym> The tinyurl is good.
18:02:14 <lament> made up by engineers :)
18:02:25 <ivanm> @slap engineers for ruining all our fun
18:02:25 * lambdabot pushes engineers for ruining all our fun from his chair
18:02:36 <ivanm> is it just me, or is lambdabot inherently sexist?
18:02:39 <glguy> whoa, lambdabot is male
18:02:45 <EvilTerran> what?!
18:02:49 <ivanm> i.e. she thinks only males deserve to be @slapped
18:02:57 <glguy> nono, that means that lambdabot is male
18:03:16 <ivanm> to me it sound like that lambdabot is pushing the slappee from their chair
18:03:25 <Pseudonym> Yes.
18:03:32 <Pseudonym> But it means that if lambdabot slaps a female...
18:03:40 <glguy> while sitting in a chair, lambdabot is slapping
18:03:41 <monochrom> @slap Philippa
18:03:42 * lambdabot pokes Philippa in the eye
18:03:43 <glguy> err, pushing
18:03:43 <ivanm> no, it means that lambdabot won't slap females
18:03:59 <lament> @slap females
18:03:59 * lambdabot will count to five...
18:04:01 <monochrom> But Philippa is female.
18:04:15 <Pseudonym> > [1..5]
18:04:16 <lambdabot>  [1,2,3,4,5]
18:04:20 <ivanm> lol
18:04:26 <lament> lambdabot: now what?
18:04:29 <Pseudonym> Oh, hang on.
18:04:34 <Pseudonym> Counting begins at zero.
18:04:36 <Pseudonym> > [0..5]
18:04:38 <lambdabot>  [0,1,2,3,4,5]
18:04:41 <lament> @slap females
18:04:42 * lambdabot clobbers females with an untyped language
18:04:43 <Pseudonym> Phil Wadler says so, so it must be true.
18:05:05 <sjanssen> @remember Pseudonym Phil Wadler says so, so it must be true.
18:05:05 <lambdabot> Good to know.
18:05:07 <lament> Pseudonym: counting also ends at the number one less than specified
18:05:28 <Pseudonym> ?go "proof by eminent authority"
18:05:30 <lambdabot> http://www.maths.uwa.edu.au/~berwin/humour/invalid.proofs.html
18:05:30 <lambdabot> Title: Invalid techniques of proof
18:05:33 <ivanm> every CS student knows that there are only two numbers that matter!
18:05:45 <lament> > let countTo x = [0..(x-1)] in countTo 5
18:05:46 <ivanm> i.e. 0 and 1
18:05:47 <lambdabot>  [0,1,2,3,4]
18:05:57 <lament> ivanm: what about 69?
18:05:58 <Pseudonym> All numbers matter, duh.  There's a simple proof by induction.
18:06:06 <ivanm> lambdabot: but then you're not counting "to" 5, you're only counting "up to" 5
18:06:23 <ivanm> lament: seriously, how many CS students are likely to have experienced that? :p
18:06:37 <lament> Pseudonym: surely that only works for countably many numbers?
18:06:45 <ivanm> Pseudonym: I beg to differ... only computable numbers matter!
18:06:54 <lament> still countably many
18:07:36 <Pseudonym> Good point, yes.
18:07:40 <Pseudonym> All natural numbers matter.
18:08:13 <Pseudonym> Clearly zero matters.
18:08:32 <Pseudonym> Now, let n > 0 be the smallest number which doesn't matter.
18:08:57 <Pseudonym> n, being the smallest irrelevant number, is important to this proogf.
18:08:59 <Pseudonym> proof
18:09:01 <Pseudonym> Therefore, it matters.
18:09:10 <lament> this argument is very easily extended to computable numbers as well
18:09:14 <Pseudonym> It follows, by contradiction, that all natural numbers matter.
18:09:15 <Pseudonym> Yes.
18:09:28 <Pseudonym> By Goedel numbering.
18:09:29 <ivanm> which is what I said... only computable numbers matter
18:09:44 <ivanm> so pi, e, sqrt 7, etc. all matter
18:09:54 <ivanm> but a random real with random digits doesn't
18:10:24 <lament> a good argument for that is "well, if you think this number matters, why don't you show it to me"
18:10:49 <Pseudonym> Oh, man.
18:11:01 <Pseudonym> The two main proof techniques in modern cryptography:
18:11:11 <Pseudonym> 1. Proof by demonstrating equivalence to a problem thought to be hard.
18:11:18 <Pseudonym> 2. Proof by unclaimed monetary reward.
18:11:24 <ivanm> lol
18:11:47 <ivanm> in terms of proof that that technique is good?
18:12:13 <Pseudonym> Given that a "real" proof is impossible, I guess it's as good as any.
18:12:41 <ivanm> *nod*
18:12:53 <Philippa> 2. has to be large enough to exceed the value of just keeping it to yourself, mind
18:12:55 <ivanm> proof in crypto = absence of inverse proof in rest of maths
18:13:24 <Philippa> there's something of a history of the spooks finding something first and never telling anyone
18:13:24 <ivanm> Pseudonym: I like the "Proof by Recess"
18:13:29 <Pseudonym> The invisible hand of the market says it's true!
18:13:33 <Philippa> the British discovery of RSA, for example
18:13:35 <ivanm> can anyone say "NSA" ?
18:13:40 <ivanm> true
18:13:55 <Pseudonym> Yeah.
18:14:04 <Pseudonym> And differential cryptanalysis, too.
18:14:37 * ivanm goes to uni
18:14:56 <ivanm> and I learnt my lesson... no trying to truncate it using a hyphen and greater-than sign
18:15:03 <ivanm> @slap pedantic haskellers
18:15:03 * lambdabot hits pedantic haskellers with an assortment of kitchen utensils
18:15:29 <ivanm> mrsolo was _that_scared by lambdabot that both his nicks quit? :o
18:15:45 <lament> does that really count as "solo"?
18:16:20 <Olathe> The first one is solo. The second one is a fill-in-the-blank puzzle.
18:16:20 <monochrom> heehee
18:20:29 <newsham> phila: reference to brits discovering rsa
18:21:36 <newsham> nevermind, wikipedia
18:22:21 <lament> all i can think of is Solon, an ancient greek politician
18:22:24 <lament> as in mrsolon
18:23:30 <fons> All Haskell type constructors are left-associative except (->) ?
18:23:49 <EvilTerran> fons, in haskell98, i think so
18:24:02 <EvilTerran> actually, in haskell98, no others are infix
18:24:41 <EvilTerran> in ghc, though, they can be named in infix/infixl/infixr declerations
18:26:12 <fons> The thing is, I'm parsing types with template haskell and ..
18:26:24 <fons> (Int -> Bool) is represented as
18:26:32 <fons> AppT (AppT ArrowT (ConT GHC.Base.Int)) (ConT GHC.Base.Bool)
18:26:41 <fons> while (Int,Bool) is
18:26:49 <fons> AppT (AppT (TupleT 2) (ConT GHC.Base.Int)) (ConT GHC.Base.Bool)
18:27:03 <EvilTerran> that should deal with the fixities automatically; doesn't it give you a tree-like structure with everything worked out?
18:27:36 <fons> yep, but in Bool -> Int the first type you have access to in the tree is Int
18:27:45 <fons> sorry
18:27:53 <fons> yep, but in Bool -> Int the first type you have access to in the tree is Bool
18:28:24 <fons> whereas in (Bool, Int) you first access Int, and then Bool
18:29:21 <monochrom> Your examples above show that the only difference is ArrowT vs (TupleT 2).
18:29:40 <EvilTerran> they look the same way round to me
18:30:11 <fons> Either Bool Int
18:30:19 <fons> AppT (AppT (ConT Data.Either.Either) (ConT GHC.Base.Bool)) (ConT GHC.Base.Int)
18:30:25 <fons> You have access to Int first
18:30:44 <EvilTerran> you keep swapping Bool and Int around
18:30:57 <monochrom> You yourself are switching between Int->Bool and Bool->Int too. Could you fix all your typos first?
18:31:09 <fons> ops hold on
18:31:17 <fons> let me post it again
18:31:42 <EvilTerran> this will have nothing to do with fixity, anyway
18:31:50 <fons> ok, Bool -> Int
18:31:54 <EvilTerran> a -> b will be resolved as if it were (->) a b
18:32:04 <fons> AppT (AppT ArrowT (ConT GHC.Base.Bool)) (ConT GHC.Base.Int)
18:32:23 <EvilTerran> (a,b) as if it were (,) a b
18:32:27 <EvilTerran> Either a b as itself
18:32:32 <fons> AppT (AppT (TupleT 2) (ConT GHC.Base.Bool)) (ConT GHC.Base.Int)
18:32:57 <fons> that's (Bool,Int)
18:33:12 <EvilTerran> apart from "ArrowT" vs "(TupleT 2)", they're the same. so what?
18:33:47 <fons> I'm trying to understand why is Arrow treated differently
18:34:04 <EvilTerran> how is it treated differently?
18:34:08 <EvilTerran> they're the same!
18:34:33 <fons> hold on
18:34:33 <monochrom> Bool sits in the same position in both trees. Int sits in the same position in both trees. What were you saying again?
18:35:07 <fons> uhm ok
18:35:09 <monochrom> In five minutes you'll be saying, "I swear I saw it did the wrong thing! But I can't reproduce it now!", I prophesize.
18:35:18 <fons> I've just been stupid
18:35:27 <fons> ;)
18:35:49 <fons> the problem comes when chaining (->)
18:35:51 <EvilTerran> the only possible confusion i can fathom would be the difference between a -> b -> c (= (->) a ((->) b c))) and a `Either` b `Either` c (= Either (Either a b) c)
18:36:08 <fons> that's it EvilTerran
18:36:42 <EvilTerran> (as things default to infixl unless you say otherwise)
18:36:47 <monochrom> a->(b->c) and Either a (Either b c) will look alike.
18:37:36 <fons> yes, but the base of my problem was comparing (a,b,c) and  a -> b -> c
18:37:41 <fons> which of course are not the same
18:38:07 <fons> I was just comparing different things
18:39:55 <fons> thanks guys, it's late (and I was being stupid, no excuses ;))
18:58:13 <thoseion> hey folks, just starting out with haskell/functional prog and wondering if someone could help with a Q?
18:58:31 <Cale> thoseion: sure
18:58:46 <thoseion> thanks!..
18:59:02 <Cale> dons: Hey, any idea what could cause "Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString" when using @let (in my own bot)
18:59:18 <Cale> (or anyone else who works on lambdabot for that matter :)
18:59:19 <sorear> thoseion: It helps alot if you ask. :P
18:59:21 <LoganCapaldo> Cale: welcome to the club! Nice to see you here
18:59:25 <thoseion> I'm trying to take in a list of boolean values and return true if exactly one is true and fase otherwise
18:59:34 <sorear> Cale: upgrade regex-*
18:59:36 <LoganCapaldo> dons said something about regex
18:59:37 <Cale> ah
18:59:40 <Cale> okay cool
18:59:42 <sorear> Cale: there's an egregious bug
18:59:54 <gwern> 'I heard GHC 13 will spawn millions of parallel universes in order to find the optimal compilation by brute force.' <-- well, y'see it lazily generates them, sorts them, and takes the head...
19:00:10 <thoseion> so I guess essentially an xor
19:00:23 <sorear> > ((==[True]) . filter id) [False, False, False, False]
19:00:28 <sorear> > ((==[True]) . filter id) [False, False, True, False]
19:00:33 <sorear> > ((==[True]) . filter id) [False, True, True, False]
19:00:34 <lambdabot>  False
19:00:35 <lambdabot>  True
19:00:35 <Pseudonym> gwern: Right, so it actually does a finite amount of work.
19:00:36 <lambdabot>  False
19:00:59 <lament> so if the current universe is not the optimal one, it terminates?
19:01:08 <lament> something could go terribly, terribly wrong
19:01:36 <Cale> thoseion: well, sort of, but not quite the usual generalisation of xor, since that would give you the parity
19:02:24 <Cale> thoseion: sorear gave a suitable solution -- filter the list using the identity function to remove all the False elements, and then check if the list is equal to [True]
19:02:26 <gwern> lament: by the anthropic principle, we'd never realize any such termination. so the only observers would be in an optimal universe. (We can't lose!)
19:03:44 <lament> i think that's called quantum immortality, not anthropic principle, and if i believed in it i would have killed myself a long time ago.
19:03:45 <thoseion> Cale/sorear - thanks I'll look into that and give it a go although I've not used filters at all yet
19:04:18 <Cale> thoseion: (filter p xs) just forms the list of elements of xs for which p gives True
19:04:26 <Cale> > filter even [1..10]
19:04:28 <lambdabot>  [2,4,6,8,10]
19:04:45 <Cale> filter isVowel "Hello there!"
19:04:49 <Cale> > filter isVowel "Hello there!"
19:04:50 <lambdabot>   Not in scope: `isVowel'
19:04:53 <Cale> err...
19:05:00 <thoseion> I was attempting something like: onetrue (x:xs) = (x || onetrue xs) && not (x && onetrue xs)
19:05:00 <Cale> > filter isAlpha "Hello there!"
19:05:01 <lambdabot>  "Hellothere"
19:05:13 <gwern> lament: no, you would have *not* killed yourself. that's the whole point...
19:05:15 <Cale> > filter (`elem` "aeiou") "Hello there!"
19:05:17 <lambdabot>  "eoee"
19:05:17 <thoseion> but of course doesnt work the way I want it  to ;p
19:05:45 <lament> gwern: i suppose it must be true, then :)
19:06:17 <Cale> thoseion: well, if you wrote a function to determine if all the elements are False, then that would be useful
19:06:32 <Cale> (along with recursion of a similar sort)
19:06:54 <gwern> lament: it is unfalsifiable!!111! kekeke
19:06:59 <Cale> You'd walk along until you found a True, then check that all the rest were False
19:07:09 <Cale> oneTrue [] = False
19:07:20 <Cale> oneTrue (False:xs) = oneTrue xs
19:07:31 <Cale> oneTrue (True:xs) = allFalse xs
19:08:05 <omnId> allFalse = all not
19:08:14 <thoseion> ah ok
19:08:33 <TomMD> Hope no one minds my reasking:  Anyone know of HFUSE users other than Halfs?
19:09:10 <Cale> btw, there's an annoying bug in cabal-install. It refuses to download and set up a new package if you already have an older version installed.
19:11:18 <lament> gwern: watch this! *bang*
19:11:59 <LoganCapaldo> > (== 1) . foldl ((+) . fromEnum)) 0 [False, False]
19:11:59 <lambdabot> Unbalanced parentheses
19:12:07 <LoganCapaldo> > (== 1) . foldl ((+) . fromEnum) 0 [False, False]
19:12:08 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
19:12:25 <LoganCapaldo> > (== 1) . foldr ((+) . fromEnum) 0 [False, False]
19:12:25 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Int'
19:12:32 <LoganCapaldo> boo
19:12:32 <omnId> > (== 1) . foldl ((+) . fromEnum) 0 $ [False, False]
19:12:33 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
19:12:52 <twanvl> > (== 1) . sum . map fromEnum $ [False, False]
19:12:57 <lambdabot>  False
19:13:04 <LoganCapaldo> but I didn't want to map sum
19:13:42 <Cale> It's the misused .
19:13:50 <Cale> > (== 1) . foldr ((+) . fromEnum) 0 $ [False, False]
19:13:52 <lambdabot>  False
19:13:59 <Cale> > (== 1) . foldr ((+) . fromEnum) 0 $ [False, False, True]
19:14:00 <lambdabot>  True
19:14:04 <Cale> > (== 1) . foldr ((+) . fromEnum) 0 $ [False, False, True, True]
19:14:05 <lambdabot>  False
19:14:16 <thoseion> thankyou Cale - works a treat!
19:14:38 <Cale> > sum . map fromEnum is more readable, I think
19:14:39 <lambdabot>   parse error on input `,'
19:14:52 <LoganCapaldo> > probablu
19:14:52 <lambdabot>   Not in scope: `probablu'
19:14:55 <LoganCapaldo> err
19:14:57 <LoganCapaldo> probaby
19:15:02 <LoganCapaldo> probably
19:15:04 <thoseion> I'm sure I'll be visiting here often in the future :D
19:15:26 <jaj> ?karma lambdabot
19:15:27 <lambdabot> lambdabot has a karma of 49
19:16:47 <Cale> thoseion: Yeah, ask lots of questions :)
19:17:03 <LoganCapaldo> > (== 1) . length . filter id $ [True, True, False]
19:17:05 <lambdabot>  False
19:17:10 <LoganCapaldo> > (== 1) . length . filter id $ [True, False]
19:17:11 <lambdabot>  True
19:17:57 <LoganCapaldo> o' course that's just the [True]== son but dumber
19:18:06 <LoganCapaldo> s/son/solution/
19:18:15 <Cale> s'on, heh
19:20:23 <user317> is there a program argument parser somewhere?
19:21:47 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
19:21:49 <lambdabot> http://tinyurl.com/yyvufm
19:22:05 <Cale> Something like that?
19:22:18 <user317> perfect, thanks Cale
19:24:05 <monochrom> Oh! It's in base. No wonder I can't find it on hackage. :)
19:24:36 <ddarius> I'm glad that lament guy is gone.
19:25:52 <monochrom> Why?
19:26:37 <sorear> Lament is gone?!
19:26:44 <omnId> <!lament> gwern: watch this! *bang*
19:26:47 <omnId> killed himself.
19:26:57 <omnId> :'(
19:27:38 <omnId> something about quantum physics...
19:28:07 <Korollary> ?
19:28:45 <omnId> it was ten minutes ago, scoll up :P
19:29:25 <monochrom> He sacrificed his life for physics? :)
19:29:41 <omnId> poor bastard.
19:29:48 <Korollary> poor physics
19:29:57 <monochrom> hehe
19:30:34 <LoganCapaldo> may physics have mercy on your sole
19:30:51 <TomMD> If we are going to personify physics then I'll tell you that he is the most snide and tricky bastard I know.
19:31:27 <Cale> hmmm
19:31:39 <Korollary> MD's don't do much physics anyway
19:31:44 <Cale> Still not working, despite that I've upgraded regex-compat/etc.
19:32:22 <TomMD> Korollary: LOL, I don't intend to mislead, but 'Tom' was taken when I signed up and my initials are 'TMD'... so... no PhD.
19:32:28 <salierix> I'm trying to learn haskell but I really don't like this lazy aspect to the language.
19:32:42 <LoganCapaldo> I don't know that other MDs have phds either
19:32:58 <Cale> salierix: what don't you like about it?
19:33:01 <LoganCapaldo> salierix: are you a workaholic?
19:33:10 <Korollary> There are MD/PhD's. It takes a long time to get both degrees.
19:33:14 <ddarius> salierix: So learn a different language.
19:33:17 <Cale> salierix: If you want, I can do a little overview of how lazy evaluation works.
19:33:20 <TomMD> LoganCapaldo: I was always under the impression it is a medical equiv to PhD.  You get my point at any rate.
19:33:32 <salierix> It makes reasoning about another person's code difficult.
19:33:34 <omnId> double, double, toil and trouble
19:33:37 <Cale> salierix: oh?
19:33:46 <Cale> salierix: why is that?
19:33:52 <ddarius> salierix: Actually, quite the opposite until you get to performance.
19:33:59 <omnId> fire burn and Caledron bubble
19:34:00 <chessguy_> macbeth?
19:34:09 <Cale> and even when you do get to performance, it's not *that* bad
19:34:09 <salierix> ddarius, what do you mean?
19:34:49 <Cale> salierix: One thing you should notice is that if a function terminates under strict evaluation, then it terminates under lazy evaluation and produces the same result.
19:34:52 <Korollary> salierix: You said you were trying to learn haskell. You can't really reason about code until you finished learning.
19:34:53 <ddarius> salierix: The full beta rule holds for call-by-name/need, but not for call-by-value.  I.e. equational reasoning holds even stronger in Haskell because it is lazy.
19:36:18 <monochrom> I believe lazy evaluation is perceived to be difficult because "woah! take 5 [1..] works?! My brain has exploded!"
19:37:19 <Cale> salierix: If you want, I can show you how it works, it's actually quite simple.
19:37:40 <TomMD> monochrom: I disagree.  Lazy annoys me sometimes because of silly things like:
19:37:40 <TomMD> handle <- openFile "blah" "r"
19:37:40 <TomMD> let hash = sha1file handle
19:37:40 <TomMD> closeFile handle
19:37:40 <TomMD> putStrLn $ show hash
19:37:54 <TomMD> That won't work too well *sigh*
19:37:55 <salierix> I'm also having trouble dealing with mutable state... I'm so used to being able to mutate things.
19:38:01 <LoganCapaldo> wel lazy + sideeffects is bound to wreak havoc
19:38:37 <TomMD> err... sorry... that example is rather bad... I should have expanded sha1file as: sha1 `liftM` hGetContents
19:38:42 <sorear> TomMD: if you call fclose() twice in C, you break things.  What makes you think it's different in Haskell?
19:38:56 <astrolabe> salierix: It is difficult to get the hang of, but worth it in my opinion.
19:38:59 <sorear> TomMD: Remember that hGetContents closes the file.
19:39:02 <ddarius> lazy and IO are far from a match made in Heaven.
19:39:43 <Cale> salierix: yeah, so there's a little bit of strangeness there, but one thing you should learn early on is how to use lists like you would loops
19:39:46 <sjanssen> I'd say they're a match made far from Heaven
19:39:48 <Korollary> salierix: Yes, it takes practice and getting used to. But once you get the hang of it, it's almost second nature.
19:39:53 <monochrom> Yes, TomMD, but I'm talking about beginners who are still looking at the pure fragment, no IO yet.
19:40:14 <Cale> salierix: A list is kind of like a loop waiting to happen.
19:40:23 <TomMD> sorear: All I am saying in this example is, if you open a file, let hash = sha1 handle then close, depending on how the code was written, that 'let hash = ' was lazy and won't get the hash before the file closes.
19:40:45 <sorear> TomMD: Why are you closing the file TWICE?
19:40:52 <salierix> Can I write the performance critical part of my program in C and just call it from haskell?
19:40:55 <omnId> salierix: I think you'll find that, though you're used to mutating things, immutable data structures are far more capable than you might realize.
19:40:59 <sorear> salierix: Absolutely.
19:41:01 <sorear> @where ffi
19:41:01 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
19:41:17 <sorear> Haskell has one of the best C interfaces in existance.
19:41:39 <sorear> Only C++ does a better job.
19:41:42 <TomMD> sorear: Let us drop that IRC code bug, I've stated the lazy-can-cause-confusion comment I desired.  Just one of those things that can confuse the uneducated (or the tired, etc).
19:42:00 <monochrom> Remember C has the best C interface!
19:42:23 <LoganCapaldo> I'm with monochrom on this one
19:42:35 <Korollary> What's wrong with C++'s C interface?
19:42:50 <monochrom> Nothing wrong, if you ask me.
19:42:56 <Pseudonym> Korollary: It doesn't play nicely with its C++ interface.
19:43:18 <Pseudonym> 1. extern "C"
19:43:23 <Korollary> Pseudonym: That wasn't a requirement (nor is it met by C of course)
19:43:25 <Pseudonym> 2. C APIs are often not const-correct.
19:43:30 <salierix> omnId, What about large arrays? Copying them each time a change is made would be horrible.
19:43:48 <monochrom> Arrays are overrated.
19:43:48 <Pseudonym> Those are the two main issues that have bugged me.
19:44:19 <Pseudonym> Oh, things have improved a bit since STL vectors mandated that they are layout-equivalent to C arrays.
19:44:33 <sorear> salierix: 90% of array uses are monolithic constructions, like 'all the elements of a[] multiplied by 2'
19:44:58 <sorear> salierix: the remaining 10% can use the (ugly, but workable) STArrays
19:44:58 <omnId> salierix: don't use arrays.  You usually don't need them.  If you do, Haskell has mutable arrays.
19:45:07 <TomMD> Curiously, does anyone else see FFI overuse as a potential for dependency bloat and portability issues?
19:45:13 <Philippa> sorear: don't forget the ones that're really implementing another structure
19:45:21 <monochrom> For the odd case when you really need an array, i.e., linear algebra, there is a mutable array.
19:45:36 <sorear> TomMD: No.  C is vastyl more portable than Haskell.  Besides, Cabal can handle C+haskell just fine.
19:45:42 <LoganCapaldo> Philippa: please don't remind anyone of those
19:45:53 <monochrom> The other day I was saying the same thing Philippa is now saying.
19:47:43 <monochrom> For a long time, imperative languages provide arrays and nothing else. So programmers encoded, repeat encoded, everything into arrays. You want a list? It's an array. You want a set? It's an array. To the point they can't cope when real list libraries and real set libraries come about.
19:48:06 <Philippa> sorear: easy to say if you don't use windows, there're still often lib portability and ease of building issues there
19:48:21 <sorear> Philippa: even with cabal?
19:48:31 <Philippa> I didn't have much luck with yi
19:48:33 <TomMD> sorear: I do see it as an issue.  This is talking less about technological 'can' and more about simplicity in an enterprise environment.  A simple example would be someone deploying an app needing crypto.  That would probably be done with SSL bindings.  Suddenly all the windows machines have a new requirement and things have bloated.  Also, I don't think any of or FPGA loving friends want openssl on the FPGA ;-).  But I recognize I am in 
19:48:36 <astrolabe> Haskell arrays are pretty useful I find, even with lists available.
19:48:56 <Philippa> I should check out an SDL binding at some point, I imagine cabal makes that sort of thing a lot easier
19:49:31 <Philippa> TomMD: so don't use that lib in your enterprise
19:49:35 <salierix> What's cabal?
19:49:55 <Philippa> it's a tool for installing libraries and applications written in Haskell
19:50:03 <salierix> Oh.
19:50:16 <astrolabe> I seem to have just managed to install hxt on my home machine, but when I try it on my work machine, the 'runhaskell install' stage grumbles about 'LICENCE' :(
19:50:25 <Korollary> also for building
19:50:39 <Philippa> sorear: additionally, there's a risk of packages becoming a semi-standard answer to a problem when they require an external lib not available on windows
19:50:41 <TomMD> Philippa: Precisely.  A Haskell app that has an internal routine or two instead of an entire external library dependency is a win.
19:51:15 <Philippa> however, having that external library available is also a win for the community as a whole
19:51:17 <allbery_b> salierix: cabal is likethe local side of CPAN, but for Haskell.  (Hackage is the remote half.)
19:51:30 <Philippa> not all of us are in an enterprise situation, not all of us can reinvent every wheel
19:51:42 <Korollary> Enterprises don't reinvent wheels either
19:51:54 <allbery_b> as yet they're not entirely hooked together although you can find two tools that are evolving into doing so (cabal-install and cabal-setup) on hackage
19:52:07 <allbery_b> (hackage == hackage.haskell.org)
19:52:24 <Philippa> Korollary: SAP configs? :-)
19:52:32 <TomMD> I am talking more about 'Haskell community reinventing wheels' and producing native modules.  This, in comparison with excessive FFI.
19:52:56 <salierix> Is the ghc garbage collector reference count based?
19:53:03 <LoganCapaldo> dear god no
19:53:20 <Philippa> TomMD: it happens for some things and not others
19:53:26 <omnId> It's a copy collector, but I know little of GC.
19:53:27 <sjanssen> TomMD: you have to consider manpower too
19:53:37 <LoganCapaldo> sorear knows what it is
19:53:48 <LoganCapaldo> I know sorear knows because I asked about it before
19:53:49 <monochrom> Dear God, reference counting is kid's toy garbage collection.
19:53:51 <Philippa> the likelihood of a reimplementation depends on a number of things, including the amount of effort involved in doing it right and the potential gain...
19:53:52 <LoganCapaldo> and he answered
19:53:53 <TomMD> sjanssen: On that note - you're still graduating on time, right? ;-)
19:54:16 <Philippa> salierix: no, it's a proper GHC. We've got too much recursion going on for refcounting
19:54:21 <Philippa> er, it's a proper GC even
19:54:23 <sjanssen> TomMD: there are so many developer-hours available for Haskell library hacking.  Usually, I'd prefer that the hacker writes a small binding to C and writes more libraries :)
19:54:33 <sjanssen> TomMD: after this summer
19:55:22 <Philippa> OTOH, it's a good thing that we're not stuck with lex/yacc clones for parsing
19:55:45 * omnId <3 Parsec
19:55:57 * sorear finds the mere notion of GHC using reference counts quite annoying.
19:56:02 <TomMD> Yes, your previous response 'it happens for some things and not others'  is really where we should be, I think.
19:56:05 <sorear> s/annoying/insulting
19:56:42 <salierix> My excuse is that I'm completely ignorant of such things, sorry :P
19:56:46 <omnId> sorear: you mustn't take things too personally, a person doesn't know until they find out.
19:57:05 <Philippa> for salierix's information:
19:57:12 <Philippa> One day a student came to Moon and said: I understand how to make a better garbage collector. We must keep a reference count of the pointers to each cons.
19:57:15 <Philippa> Moon patiently told the student the following story:
19:57:21 <Philippa>     One day a student came to Moon and said: I understand how to make a better garbage collector...
19:58:01 <TomMD> I could put that into a list... of coarse it would be infinite.  Looks like I know what language I'll use.
19:58:19 <ddarius> reference counting is how you get incrementality
19:58:48 <monochrom> Why was the person called Moon? :)
19:58:58 <lament> it's a historical figure
19:59:11 <gwern> most of the ai koans were based on real incidents
19:59:18 <lament> just like most real koans
19:59:21 <Philippa> "David Moon wrote much of Lisp Machine Lisp", to quote the page
19:59:25 <gwern> for example, the checkers one is taken almost straight from Levy's ''hackers''
19:59:59 <ddarius> monochrom: You didn't immediately know it was David Moon?!
20:00:05 <monochrom> No.
20:00:14 <LoganCapaldo> I thought it was the moon
20:00:20 <gwern> myself, I like the powercycling one best
20:00:20 <LoganCapaldo> that woud've been cooler
20:00:40 <omnId> lament: aren't you dead?
20:00:52 <ddarius> Anyway, I need to switch back to Linux.
20:01:15 <lament> omnId: in that universe, yes.
20:01:16 <TomMD> from?
20:02:20 <Philippa> salierix: was the koan suitably enlightening?
20:03:43 <salierix> Well...
20:09:48 <monochrom> Haskell makes you think and go "hmm". :)
20:10:17 <lament> much unlike matlab
20:10:30 <lament> which makes you close your ears with your fingers and SCREAM
20:10:34 <allbery_b> matlab just makes you want to rip your brain out
20:11:08 <lament> nah, you probably won't even feel that
20:17:38 * wli wonders how to cross-build for Windows.
20:30:13 <astrolabe> Does anyone know who 'bitwize' on reddit is?
20:30:56 <ddarius> @seen bitwize
20:30:56 <lambdabot> I saw bitwize leaving #haskell 1m 22d 13h 47m 20s ago, and .
20:31:53 <astrolabe> ooh thanks.
20:50:23 <omnId> @quote
20:50:23 <lambdabot> z0d says: What was the stereo quote?
21:03:41 <glguy> bos: you about?
21:03:45 <runar> Xmonad ftw!
21:04:36 <sorear> @users
21:04:36 <lambdabot> Maximum users seen in #haskell: 420, currently: 377 (89.8%), active: 9 (2.4%)
21:04:36 <runar> but... can't... stop... tweaking
21:04:51 <kilimanjaro> runar, I just set up xmonad today as well :)
21:05:01 <sorear> wow, #xmonad has grown a lot since... uh... this isn't #xmonad
21:05:02 <wifs> strangely, I was just browsing xmonad.org
21:05:02 <runar> great minds, and all that
21:06:21 <sorear> @users
21:06:21 <lambdabot> Maximum users seen in #haskell: 420, currently: 376 (89.5%), active: 11 (2.9%)
21:06:27 <sorear> oh right
21:06:31 <sorear> I just checked
21:06:56 <runar> @users xmonad
21:06:57 <lambdabot> Maximum users seen in xmonad: 1, currently: 0 (0.0%), active: 0 (NaN%)
21:07:06 <runar> @users #xmonad
21:07:06 <lambdabot> Maximum users seen in #xmonad: 82, currently: 64 (78.0%), active: 8 (12.5%)
21:07:10 <runar> there we go
21:40:17 <bos> glguy: yep
21:44:56 <bos> @seen glguy
21:44:57 <lambdabot> glguy is in #haskell and #xmonad. I last heard glguy speak 41m 15s ago.
22:14:36 <vBergmann> what am i doing wrong in this statement?
22:14:53 <vBergmann> [ (x,y) | x <- [1..a], y <- [1..b] ] where b = 7, a =6
22:15:05 <Korollary> the comma
22:15:19 <Korollary> b=7,
22:15:22 <vBergmann> what is an alternative?
22:15:43 <Korollary> you can use layout or semicolon
22:16:04 <vBergmann> ah works great now thanks
23:02:32 <bos> @seen dons
23:02:32 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 6h 37m 17s ago.
23:08:03 <kolmodin> nice HWN
23:13:02 <vBergmann> i'm using pattern matching as one of my base cases (a leaf node) in a Quad Tree i'm writing. I want to throw an error if the user enters a negative number (basically no negative dimensions) but right now i am matching to any number. Is it possible to "restrict" my matches to numbers greater than or equal to zero?
23:13:30 <vBergmann> or perhaps detect when a match is greater than zero and write a useful error message
23:13:54 <sorear> vBergmann: guards
23:13:57 <vBergmann> i can post the code if this doesn't make much sense
23:15:05 <glguy> vBergmann: did sorear's answer make sense?
23:15:22 <vBergmann> i've used guards to catch errors later on in the code (general case) but the problem is that if i'm entering into the base case right away i don't nkow how to write useful error messages
23:15:42 <glguy> ?src take
23:15:42 <lambdabot> take n _      | n <= 0 =  []
23:15:42 <lambdabot> take _ []              =  []
23:15:42 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
23:16:03 <Korollary> You can restrict your matches, but you may also have to deal with bad input.
23:16:17 <vBergmann> i'll paste the code
23:16:46 <glguy> 18 hours, 45 minutes, 45 seconds till OS 1.5
23:16:57 <hpaste>  vbergmann pasted "error messages for base case" at http://hpaste.org/3477
23:17:04 <glguy> whose going to the release party
23:17:24 <sorear> what OS?
23:17:30 <Korollary> leopard I guess
23:17:42 <glguy> on, OS X*.5
23:17:48 <glguy> oh*
23:18:00 <glguy> Ah, good old typos in the typo correction
23:18:33 <glguy> who's*
23:18:34 <glguy> :)
23:19:02 <vBergmann> so the problem is basically i have used guards to catch errors but if i go right into the base case if it's possible to return a value and print an error message
23:19:13 <vBergmann> it's seems like i can only do one or the other
23:19:27 <vBergmann> how can i restrict my matches?
23:19:44 <glguy> You could return an: Either String Char
23:19:54 <glguy> if one of the results is an error message
23:21:02 <vBergmann> oh ok that seems pretty simple
23:21:14 <vBergmann> not sure why i didn't think of that ><
23:21:49 <glguy> why does a function "getPixel" return a Char though?
23:22:31 <vBergmann> this is an quad tree that holds ascii characters
23:22:56 <vBergmann> it's an assignment and i think it's to keep things simple
23:26:57 <quicksilver> ASCII art ftw!
23:27:14 * quicksilver fondly remembers the ascii-art SDL drivers and ascii quake
23:27:49 <glguy> libaa and libcaca?
23:29:06 <quicksilver> http://webpages.mr.net/bobz/ttyquake/ss/
23:29:07 <lambdabot> Title: Textmode Quake Screenshots
23:34:13 <vBergmann> lol apparently there's text mode unreal tournament as well
23:34:20 <vBergmann> http://offload2.icculus.org/~chunky/ut/aaut/scrshots/1.png
23:35:50 <OceanSpray> Oh you crazy ass kids today with your fancy graphics!
23:36:36 <LeCamarade> So ... I get MD5 from the crypto package _only_?
23:36:45 <LeCamarade> @hoogle md5
23:36:46 <lambdabot> No matches found
23:36:57 <LeCamarade> @hoogle MD5
23:36:57 <lambdabot> No matches found
23:37:04 <LeCamarade> ,,|,,
23:57:41 <hoelzro> hello fellow Haskellers!
23:57:59 <hoelzro> is there a Haskell implementation that can be embedded into a C application?
23:58:17 <KatieHuber> what's wrong with GHC?
23:58:25 <hoelzro> nothing
23:58:43 <hoelzro> but I'd like to write a plugin for Pidgin that allows a user to write a plugin in haskell
23:58:43 <KatieHuber> I mean, you can call C from GHC-compiled Haskell, and vice versa
23:58:49 <hoelzro> really?
23:58:51 <hoelzro> cool
23:58:58 <hoelzro> learning something new everyday
23:59:13 <KatieHuber> Not sure whether it needs control of main() though, which'd be a downer
23:59:29 <wli> I'm mostly clueless as to how to compile Haskell on Windows.
23:59:31 <hoelzro> I'm not sure
23:59:42 <KatieHuber> oh, and GHCi is a library too, so you could allow interpeted haskell plug-ins
23:59:42 <hoelzro> Windows is irrelevant to me =D
