00:25:57 <sili> can anyone help me define primitive recursion? the intarweb isn't being helpful to me
00:26:22 <quicksilver> just recursion on the natural numbers
00:26:27 <quicksilver> @src take
00:26:27 <lambdabot> take n _      | n <= 0 =  []
00:26:27 <lambdabot> take _ []              =  []
00:26:27 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
00:26:32 <quicksilver> rather like that
00:26:42 <quicksilver> must be a number auxiliary, and a base case at '0'
00:28:41 <quicksilver> the technical definition seen is normally more complex, but that's the nub
00:29:19 <sili> YAHT says "A primitive recursive function is essentially one which can be calculated using only for loops, but not while loops."
00:29:28 <quicksilver> that's fair
00:29:34 <quicksilver> you have to 'bound' the recursion some how
00:29:49 <sili> that confuses me because I don't know of any for loops that can't be written as while loops
00:29:50 <quicksilver> primitive recursive functons are always total
00:30:02 <quicksilver> what it means is, for loops over the natural numbers
00:30:09 <quicksilver> for (x = 0; x < n; x++)
00:30:14 <quicksilver> not general conditions
00:30:39 <quicksilver> with general conditions then of course for == while
00:31:05 <sili> I see
00:31:42 <dmwit> sili: The sentence is ambiguous.  What it means is, "functions which can be written using 'for' as its only looping construct" rather than "functions which can be written with 'for' but cannot be written with 'while'".
00:32:06 <sjanssen> how about this: "A primitive recursive function is essentially one which can be calculated using only "enumFromTo" loops, but not "enumFrom" loops." :P
00:33:52 <sili> Wikipedia defines it as: The primitive recursive functions are defined using primitive recursion
00:34:07 <sili> that must be a joke.
00:36:43 <sclv> A primitive recursive function can also be seen as a function such that the number of recursions it performs can be calculated without calculating the function itself, i think.
00:37:31 <sili> that seems to line up with the bit about being defined with only for()
00:38:13 <sili> anyway, I've been stealing syntax from haskell all day
00:39:07 <omnId> stealing syntax?
00:39:35 <therp> primitive recursive is a function that calls itself when it can be proven that the arguments decrease in order in the (partially-)ordered input domain the
00:40:04 <sili> omnId: I'm writing a language for some sick and twisted reasons
00:40:06 <therp> -the at the end
00:45:51 <therp> sclv: I'm not sure if that's a sufficient condition. I'd say GCD is primitive recursive, but you can not calculate the number of recursions of GCD without actually calculating the function
00:48:05 <sclv> therp: you're right, your definition makes more sense. the point as i understand it is that you can calculate a bound, however, so you can reason about it?
00:49:44 <therp> sclv: yes, given a partial-order a bound isn't hard. when the distance (graph-wise) from the root-node is n, then at maximum n recursive calls can be carried out.
00:52:15 <Philippa> therp: what does your primitive-recursive GCD implementation look like?
00:54:47 <therp> philippa: http://planetmath.org/encyclopedia/Haskell.html -- but as you ask that question, you made me remember a paper that said "GCD is not primitive recursive"
00:54:49 <lambdabot> Title: PlanetMath: Haskell
00:55:34 <Philippa> yeah, there's a call in there which just swaps the input parms around which definitely /isn't/ primitive recursive
00:56:09 <Philippa> primitive recursion != structural recursion
00:56:20 <Philippa> though that particular call isn't structural recursion either
00:56:51 <therp> philippa: why is primitive recursion different from structural recursion?
00:56:55 <therp> philippa: why is primitive recursion different from structural recursion?
00:57:24 <Philippa> ...wait, no, fair enough if you're using a lexicographic ordering on the two inputs I guess. But still not primitive recursive
00:57:55 <Philippa> because primitive recursion is pretty much folds
00:57:56 <therp> http://www.math.ucla.edu/~ynm/papers/primgcd.ps
00:58:11 <Philippa> and you don't get HOFs
01:01:19 <sieni> and anyway, aren't all recursive functions on naturals recursive in the structural sense?
01:01:35 <therp> philippa: probably my definition is wrong then, and I was talking about structural recursion.
01:03:12 <therp> probably I was talking about Walther recursion.. consumer/preserver vs. reducer functions
01:03:32 <Philippa> I think so, I suspect that with a lexicographic ordering I could make the ackermann function (the textbook terminating non-primitive-recursive function on naturals) meet your definition
01:04:43 <therp> philippa: right
01:06:10 <therp> sclv: please forget my definition wrt primitive recursion. I think that was Walther recursion, but I have to look that up so I'm not saying something wrong again.
01:21:49 <LeCamarade> You know, I just spent all of ten minutes fighting a one-liner that was probably twenty gigabytes big, and then I paused, in a moment of inspiration, and decided point-free is a good toy but little else.
01:23:29 <quicksilver> point-free is certainly not useful as an end in itself
01:23:31 <omnId> twenty gigabytes as in it used a lot of memory or are you just saying the line was long? :)
01:23:42 <quicksilver> there is a reason that the lb plugin is called 'pointless'
01:23:52 <LeCamarade> Long. Longer than the road.
01:24:06 <omnId> where clauses are gravy, you know
01:24:06 <quicksilver> however, pointfee style is helpful in certaqin definition where the points are annoying and get in the way
01:24:26 <quicksilver> but it's unhelpful where the practice of anming the points makes it clearer
01:24:33 <quicksilver> anming = naming
01:25:35 <LeCamarade> Point-free is basically when Haskell envies APL or J.
01:26:16 <LeCamarade> Haskell goes like /me can also do it in Greek and have it run! Fun, but there should be a law out there about PF.
01:30:51 <Philippa> out of interest, does flip (.) have a name in the standard libraries at the moment?
01:31:21 <quicksilver> Philippa: >>> (more general type)
01:32:05 <Philippa> d'oh, of course. I really ought to use that instance more
01:37:21 <quicksilver> LeCamarade: I still prefer map f to map (\x -> f x), map (+1) to map (\x -> x+1) and f.g.h to \x ->f (g (h x)), etc
01:37:24 <quicksilver> it's a question of degree
01:38:31 <opqdonut> between needless verbosity and obfuscation lies clarity
01:38:50 <sclv> I like my lines to be short, and if possible, arranged pyramidally so that the declarations get progressively longer.
01:39:15 <sclv> It somehow just feels right.
01:39:41 <quicksilver> I like my lines to be short, and arranged so the the source code graphically resemles the output of the program
01:39:43 <sclv> and yeah, no lambda expressions if possible.
01:39:45 <quicksilver> quite hard to arrange, though
01:40:11 <sclv> luckily my programs only print pyramids!
01:40:31 <LeCamarade> Philippa: You mean flip or flippac? :o)
01:40:32 <omnId> poor unwanted lambda.  All he wants is to help you!
01:40:51 <sclv> I've coded twenty variations of stepinski so far. *rimshot*
01:41:03 <LeCamarade> Yeah, no \ if possible. And dots. And imports.
01:41:22 <LeCamarade> It's why I use fmap on IO, instead if Monad.liftM
01:43:35 <LeCamarade> @hoogle sleep
01:43:35 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
01:43:55 <omnId> @hoogle threadDelay
01:43:56 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
01:44:05 <quicksilver> LeCamarade: fmap is only partial enlightenment
01:44:13 <quicksilver> LeCamarade: the higher plane is <$>
01:44:24 <LeCamarade> @hoogle <$>
01:44:24 <lambdabot> No matches found
01:44:31 * quicksilver does 3D trig and vector math by trial and error
01:44:31 <wli> What's so much higher about <$>?
01:44:40 <Cale> Yeah, I'm not sure I get that either :)
01:44:46 <omnId> (<$>) = fmap, so I don't see anything higher, like wli
01:44:48 <quicksilver> it's symbolic, and shorter :)
01:44:57 <Cale> (.) would be nicer still ;)
01:44:58 <sjanssen> fmap is clearly better
01:45:01 <LeCamarade> Shorter wins in my books.
01:45:05 * earthy likes both
01:45:08 <sjanssen> (.) is scary
01:45:18 <earthy> they have their uses in different contexts
01:45:22 <omnId> (<$>) is a great name, but not much more enlightening
01:45:41 <wli> map would be nice.
01:45:49 <LeCamarade> Whence doth an handmaid find <$>?
01:45:56 <omnId> @index (<$>)
01:45:56 <lambdabot> bzzt
01:46:01 <wli> Control.Applicative
01:46:04 <quicksilver> I wasn't entirely serious
01:46:06 <earthy> Control.Applicative indeed
01:46:12 * omnId hits Cale on the head with an ambiguous type error.
01:46:22 <Cale> omnId: oh?
01:46:46 <omnId> "What?  Functor?  I just want to compose functions!"
01:47:01 <omnId> I jest, though.
01:47:33 <LeCamarade> Aw! Behold, <$> is yet more-elavated!
01:47:35 <sjanssen> I think that's a valid point
01:47:46 <quicksilver> I find that if you just keep flipping the arguments to atan2, and negating angles
01:47:54 <quicksilver> eventually you find the trig function you were looking for :)
01:48:15 <LeCamarade> Shall it tarry then against mine heart, for behold /me loveth his code short, even to the detriment of all else.
01:48:17 <osfameron> (<$>) is one more character than fmap...
01:48:27 <quicksilver> osfameron: not when used infix :)
01:48:33 <omnId> though I suppose you could extend that: "What?  Functor?  I just want to map over a list!"  A we have a slippery slope.
01:48:43 <osfameron> (and requires you to keep your pinky on the shift key for longer, if you care about RSI...)
01:48:50 <quicksilver> > (length "<$>",length "`fmap`")
01:48:52 <lambdabot>  (3,6)
01:49:15 <LeCamarade> For I loved thine heart, O Haskell, knight of the gleaming lambda, because thou madest mine code shorter and thou had not the dreaded for-loop. Behold I learn thine pleasures anew everyday!
01:49:32 <Cale> :t forM
01:49:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
01:49:56 <omnId> oops, it's a for loop.  Better pack our bags and jump ship.
01:49:56 <Cale> clearly a for loop ;)
01:50:13 <LeCamarade> My lord! Thou hast betrayed mine love!
01:53:37 <Cale> :t let { for init test incr body = let loop = do b <- test; if b then do {body; incr; loop} else return () in do init; loop } in for
01:53:39 <lambdabot> forall (t :: * -> *) t1 t2 t3. (Monad t) => t t1 -> t Bool -> t t2 -> t t3 -> t ()
01:54:33 <Cale> C-style :)
01:55:17 <omnId> init, test, and incr should be in a triple for maximum C-ness.
01:55:37 <Cale> :t let { for (init, test, incr) body = let loop = do b <- test; if b then do {body; incr; loop} else return () in do init; loop } in for
01:55:38 <lambdabot> forall (t :: * -> *) t1 t2 t3. (Monad t) => (t t1, t Bool, t t2) -> t t3 -> t ()
01:57:52 <omnId> loop = fmap (flip when (body>>incr>>loop)) test
01:58:32 <dcoutts> aleator: ./configure --disable-gnomevfs
01:59:38 <omnId> @type let for (init, test, incr) body = init >> fix \loop -> flip when (body >> incr >> loop) <$> test in for
01:59:39 <lambdabot> parse error on input `\'
01:59:48 <omnId> @type let for (init, test, incr) body = init >> fix $ \loop -> flip when (body >> incr >> loop) <$> test in for
01:59:50 <lambdabot>     Couldn't match expected type `()' against inferred type `f ()'
01:59:50 <lambdabot>       Expected type: f ()
01:59:50 <lambdabot>       Inferred type: f (f ())
02:00:00 <omnId> bah
02:00:19 <dcoutts> newsham: no, the zlib package does not provide any api to get at the crc32, do you need it?
02:00:20 <omnId> @type let for (init, test, incr) body = init >> fix (\loop -> flip when (body >> incr >> loop) <$> test) in for
02:00:21 <lambdabot>     Couldn't match expected type `()' against inferred type `f ()'
02:00:21 <lambdabot>       Expected type: f ()
02:00:21 <lambdabot>       Inferred type: f (f ())
02:00:34 * omnId goes to /msg
02:01:58 * LeCamarade stops the @slap in the middle
02:02:16 <LeCamarade> :o)
02:02:22 <omnId> @slap me
02:02:22 * lambdabot will count to five...
02:03:25 <omnId> LB needs to be more violent, more often.  These non-slaps are too frequent.
02:04:58 <LeCamarade> You're a pain freak?
02:05:01 <omnId> oh!  Silly me, the when's arg is monadic, so I wanted (=<<) instead of (<$>)
02:05:21 <LeCamarade> Hey, does everyone find Crypto as hard-to-use as I do?
02:05:33 <omnId> LeCamarade: it's the principle of the thing 8)
02:05:54 <LeCamarade> omnId: Heh. Its use is also encrypted? :o)
02:06:48 <sclv> grr. i spent all this time messing with HAppS and only now do I discover that somehow it never ended up with built-in session support. tomorrow I'm just going with fastcgi.
02:07:29 <omnId> @type let for (init, test, incr) body = init >> fix $ \loop -> test >>= flip when (body >> incr >> loop) in for
02:07:31 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => ((m () -> m ()) -> a, m Bool, m a1) -> m a2 -> m ()
02:07:41 * omnId is victorious.
02:09:18 <omnId> wait, what the hell's with that type?
02:10:08 <omnId> oh, ($) grouped (init >> fix)
02:10:26 * omnId is not victorious.
02:10:31 <scook0_> (init >>) $
02:10:49 * scook0_ crosses fingers
02:11:12 <omnId> oh geez, how clumsy.
02:11:35 <omnId> @type let for (init, test, incr) body = (init >>) $ fix $ \loop -> test >>= flip when (body >> incr >> loop) in for
02:11:37 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (m a, m Bool, m a1) -> m a2 -> m ()
02:12:10 <omnId> I totally understand that particular bit, though, which strikes me as somehow wrong that I do.
02:13:10 <omnId> maybe I should change the first ($) to a (.) to appease Cale's crusade for a left-associative ($).
02:13:53 <LeCamarade> sclv: I stuck to CGI. It serves well.
02:14:13 <LeCamarade> And works outta-de-box
02:14:24 <LeCamarade> And is portable like mad.
02:15:03 <LeCamarade> And kicks on any server and the sun. With or without fcgi thingies.
02:15:09 <profmakx> hm. anyone noticed any problems with freenode ipv6?
02:30:18 <LeCamarade> As it turns out, seeing IO as a Functor instance is a very enlightening experience.
02:31:05 <opqdonut> is it?
02:31:17 <sili_> very good, grasshappa
02:31:27 <opqdonut> isn't that just the "monad as container" metaphor?
02:32:41 <LeCamarade> You know, having seen IO as a Monad for so long, seeing the way Control.Applicative ignores the Monad part and still feels like a cold drink is very enlightening.
02:33:27 <aleator> dcoutts: Thanks! One other thing? How do I catch the toggled signal from cellRendererToggle?
02:33:50 <LeCamarade> Yeah. Monad-as-container. But C.A feels cleaner than C.M for some reason.
02:34:35 <opqdonut> perhaps you have a point, yes
02:36:11 <LeCamarade> I guess the only reason I couldn't insist on IO being a Functor is because Functor doesn't obey those purity-preserving rules.
02:37:33 <hpaste>  aleator pasted "dcoutts: Sorry, but gtk2hs just fights me." at http://hpaste.org/3515
02:38:00 <omnId> LeCamarade: hm?  Which rules doesn't Functor follow?
02:38:34 <quicksilver> LeCamarade: Functor doesn't allow you to build or chain IO actions, only manipulate their results
02:38:37 <quicksilver> LeCamarade: that's "very very pure"
02:38:46 <LeCamarade> The Monad rules?
02:38:49 <LeCamarade> Oh.
02:38:51 <quicksilver> LeCamarade: Applicative allows you to sequence IO actions, but not feed the output of one into the input of the next
02:38:52 <LeCamarade> Wait.
02:38:57 <quicksilver> that's "pretty damn pure"
02:39:11 <LeCamarade> That's some weakness. No ``bind''.
02:39:24 <quicksilver> Monad allows you to sequence actions and thread output from one into the input for the next, so that one can depend on the earlier
02:39:27 <LeCamarade> No =<< or >>=
02:39:31 <quicksilver> that's "only just pure"
02:39:31 <quicksilver> :)
02:39:32 <laziest> LeCamarade: what is bind with respect to Functor?
02:39:50 <quicksilver> each of them has their interesting place
02:39:52 <Syzygy-> laziest: Nonexistent?
02:39:56 <laziest> LeCamarade: I mean your idea?
02:39:56 <quicksilver> Cale: w.r.t our conversation about Kleisli
02:40:08 <quicksilver> Cale: does this mean that Kleisli isn't an instance of arrow after all?
02:40:24 <LeCamarade> laziest: Functor doesn't have either return or >>=. :o(
02:40:32 <omnId> quicksilver: (Kleisli m) is an Arrow when m is a Monad
02:40:37 <quicksilver> omnId: I think it isn't
02:40:59 <quicksilver> I think it fails the rules for first, second, *** and &&&
02:41:06 <quicksilver> Kleisli categories are not CCC
02:41:10 <laziest> LeCamarade: I meant what is your meaning of >>= if it were there for Functors?
02:41:15 <omnId> oh?  That'd be somewhat damning.
02:41:58 <LeCamarade> Doesn't work on Functors, of course. They are too sealed for this kind of thing, I guess. They only contain and stop there.
02:42:04 <quicksilver> I mean, you can define first and second, and you can understand what they mean.
02:42:12 <quicksilver> but they fail the universal properties
02:43:17 <LeCamarade> @djinn a -> (a -> b) -> b
02:43:17 <lambdabot> f a b = b a
02:44:45 <LeCamarade> > length <$> (pure "")
02:44:46 <lambdabot> Terminated
02:44:55 <LeCamarade> Why?
02:45:08 <quicksilver> :t pure ""
02:45:10 <lambdabot>     Ambiguous occurrence `pure'
02:45:10 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
02:45:10 <lambdabot>                           or `pure', imported from Control.Arrow
02:45:29 <LeCamarade> > length <$> Control.Applicative.pure ""
02:45:30 <lambdabot>   add an instance declaration for (Show (f Int))
02:45:49 <LeCamarade> :t length <$> Control.Applicative.pure ""
02:45:50 <lambdabot> forall (f :: * -> *). (Applicative f) => f Int
02:46:08 <quicksilver> I'm not sure why you're getting odd errors
02:46:17 <quicksilver> but you need a type sig to choose which applicative instance you want
02:46:19 <omnId> let me see if I can define a first, first
02:46:23 <omnId> @type let first (Kleisli k) = Kleisli $ \(x, y) -> k x >>= \x' -> return (x', y) in first
02:46:24 <lambdabot> forall (m :: * -> *) t t1 t2. (Monad m) => Kleisli m t t1 -> Kleisli m (t, t2) (t1, t2)
02:46:31 <omnId> ^ is that a suitable first, quicksilver?
02:46:46 <quicksilver> omnId: I think so, yes
02:46:47 <LeCamarade> > pure "Just" :: Maybe String
02:46:48 <lambdabot> Terminated
02:47:02 <quicksilver> very strange
02:47:15 <omnId> > pure Just :: Kleisli Maybe a a
02:47:15 <lambdabot> Terminated
02:47:27 <quicksilver> omnId: I may be wrong; it may be that the "obvious" identities are not, in fact, required of arrow instance
02:47:28 <omnId> > Control.Arrow.pure Just :: Kleisli Maybe a a
02:47:29 <lambdabot>   pure Just
02:47:29 <lambdabot>     In the expression: pure Just :: Kleisli Maybe a a
02:47:35 <LeCamarade> @slap lambdabot
02:47:35 * lambdabot clobbers lambdabot with an untyped language
02:47:41 <LeCamarade> :o)
02:47:53 <omnId> lambdabot: what?
02:48:03 <LeCamarade> That's cruel.
02:48:09 <quicksilver> :t pure fst
02:48:11 <lambdabot>     Ambiguous occurrence `pure'
02:48:11 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
02:48:11 <lambdabot>                           or `pure', imported from Control.Arrow
02:48:17 <quicksilver> :t arr fst
02:48:19 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) a
02:48:41 <quicksilver> :t \f g -> (f *** g) >>> (pure fst)
02:48:42 <lambdabot>     Ambiguous occurrence `pure'
02:48:42 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
02:48:42 <lambdabot>                           or `pure', imported from Control.Arrow
02:48:51 <quicksilver> :t \f g -> (f *** g) >>> (arr fst)
02:48:52 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') c
02:49:15 <quicksilver> omnId: the issue is that that kind of thing appears to "only do f"
02:49:21 <quicksilver> omnId: but actually it carries out the effects of g, too
02:49:35 <quicksilver> omnId: which violates the universal properties of project and ***
02:49:44 <quicksilver> omnId: but, maybe that's OK. Maybe arrows aren't intended to be CCC.
02:49:49 <quicksilver> omnId: I should go read the paper :)
02:49:53 <omnId> quicksilver: I think f *** g = first f >>> second g is a law.
02:50:36 <omnId> "project"?
02:51:28 <quicksilver> 'arr fst' is one of the projections
02:52:10 <omnId> @type \f -> Kleisli (return . f)
02:52:11 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> Kleisli m a b
02:52:33 <quicksilver> omnId: ah, it's ok, I"m wrong
02:52:51 <quicksilver> omnId: Hughes explicitly makes clear that there isn't a product in the arrow catgeory
02:52:58 <LeCamarade> omnId: f***? You dare say that to my face?
02:53:00 <LeCamarade> X^(
02:53:06 <opqdonut> ;D
02:53:18 <omnId> @slap LeCamarade hard
02:53:19 * lambdabot will count to five...
02:53:25 * LeCamarade ducks
02:53:36 <opqdonut> :D
02:53:38 <profmakx> uhh lambdabot has new slapping methods?
02:53:39 <quicksilver> omnId: "Beware! In fact there is no reason to expect Haskell's pair type to be a categorical product in the category of arrows, or indeed expect any categorical product to exist"
02:53:49 <quicksilver> omnId: (p13-14 of arrows.pdf)
02:54:12 <omnId> quicksilver: my understanding of that is sketchy at best :)
02:54:50 * omnId hits LeCamarade with a side-effect
02:55:37 * LeCamarade holds up Perl to absorb the shock.
02:56:18 <Cale> Categorical products satisfy a property which is too strong to be expected of Hughes Arrow products.
02:56:20 <LeCamarade> :t pure "Just" :: Maybe String
02:56:21 <lambdabot>     Ambiguous occurrence `pure'
02:56:21 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
02:56:21 <lambdabot>                           or `pure', imported from Control.Arrow
02:56:39 <LeCamarade> :t Control.Applicative.pure "Just" :: Maybe String
02:56:40 <lambdabot> Maybe String
02:56:57 <Cale> In particular, Arrows are permitted to have things like side effects, which really spoils the idea of there being a categorical product.
02:56:58 <LeCamarade> Control.Applicative.pure "Just" :: Maybe String
02:57:20 <LeCamarade> > Control.Applicative.pure "Just" :: Maybe String
02:57:21 <lambdabot>  Just "Just"
02:58:19 <omnId> > return "ice" :: Maybe String
02:58:21 <lambdabot>  Just "ice"
02:58:30 <quicksilver> Cale: are you following the thread on libraries@ at the moment about this class hierarchy?
02:58:46 <Cale> quicksilver: slightly
02:58:55 <omnId> is that the Control.Compositor thread?
02:58:59 <quicksilver> yes
02:59:06 <Cale> I made my comment about it.
02:59:09 * omnId saw it on HWN
02:59:24 <quicksilver> Cale: it seems to me that perhaps (some) people in that thread are under the misapprehension that arrow products are intended to be category products
02:59:37 <Cale> Well, that's not true.
02:59:38 <quicksilver> Cale: certainly it managed to give me that impression, which caused my current confusion
02:59:45 <quicksilver> Cale: I know realise that, yes :)
02:59:47 <quicksilver> erm
02:59:51 <quicksilver> s/know/now/
03:00:09 <quicksilver> but possibly I misread/misconstrued
03:02:35 * omnId checks out twanvl's c.h.o/category
03:02:35 <LeCamarade> ?where \cats
03:02:36 <lambdabot> http://arcanux.org/lambdacats.html
03:02:56 * LeCamarade needs to laugh a bit.
03:03:58 <pjd> there hasn't been an "applicative" one yet
03:04:33 <LeCamarade> The once of cycle really kicks me.
03:07:12 <LeCamarade> Who has managed to compile Crypto on Windows?
03:07:22 <LeCamarade> It keeps failing for me on build.
03:10:30 <LeCamarade> Oh. I see the problem. :o)
03:10:54 <profmakx> hm. it seems i managed to build an unregisterised ghc on freebsd7/amd64. Now it segfaults when i try to build the libraries :(
03:12:26 <profmakx> oh well. I will try booting a 6.2-release and use the binary that can be d/l from haskell.org
03:18:31 * omnId arrives at the 'Static' type in http://code.haskell.org/category/Control/Category.hs
03:18:37 * omnId spontaneously explodes
03:20:33 <DRMacIver> Why?
03:21:17 <omnId> Too much indirection I guess :P
03:21:17 <LeCamarade> Me, I want to see one human being who has used Data.Digest.MD5
03:21:34 <Cale> newtype Static f cat a b = Static { runStatic :: f (cat a b) }
03:24:53 <DRMacIver> I don't see what it's for, but it doesn't seem too confusing... Am I misunderstanding what it means?
03:26:30 <Cale> The idea is that f is an applicative functor.
03:27:01 <Cale> instance (Applicative f, Category cat) => Category (Static f cat) where
03:27:02 <Cale>       id = Static (pure id)
03:27:02 <Cale>       Static f . Static g = Static $ (.) <$> f <*> g
03:27:21 <DRMacIver> I see
03:31:12 <omnId> so id first instantiates in the inner category, pure puts that categorical whatzit into the app functor, and Static wraps the newtype.
03:32:34 <omnId> Static f . Static g = Static (liftA2 (.) f g) -- maybe I could understand this easier
03:34:59 <omnId> if cat is a category, cat a b is called an arrow, yes?  I don't know category theory.
03:35:39 <Cale> These things aren't really categories in general.
03:36:06 <Cale> but sure, that's how the correspondence goes
03:36:33 <omnId> Cale: I can call an 'm' a monad and an 'm a' an action.  I was wondering what I should call something of type 'Category cat => cat a b'
03:36:38 <Cale> These are sort of categories whose objects are exactly the set of Haskell types.
03:37:24 <Cale> arrow is fine, apart from the potential confusion with Hughes Arrows :)
03:37:45 <quicksilver> I recommend 'warm, sleek thing'
03:37:51 <MyCatSchemes> omnId: if cat is a category, category wants fried chicken and will meer at you until it gets it.
03:37:52 <quicksilver> c.f. warm fuzzy thing
03:38:01 * wli says morphism (along with epimorphism, monomorphism, etc.)
03:39:51 <omnId> okay, so Static's (.) takes two Applicative actions which each 'contain' a morphism.  Then hooks everything up into one Applicative action with a morphism from g's input to f's out.
03:40:00 * omnId waves his hand about wildly
03:41:07 <omnId> Cale: this is a fair description?
03:42:15 <Cale> essentially it produces the applicative computation which runs f and g and then composes their results
03:42:56 <omnId> ah!  How visceral :)
03:45:58 <omnId> I wonder what the name 'Static' signifies.
04:15:06 <sili> how does haskell implement its infix magic :(
04:16:04 <dcoutts_> sili: do you mean parsing or what?
04:16:16 <dcoutts_> to what bit of magic are you referring?
04:16:23 <sili> dcoutts_: ya, something to that extent.
04:16:59 <dcoutts_> sili: parsing infix expressions with known precedence is easy, so the issue is how does it do it when the precedence is user defined?
04:17:33 <dcoutts_> one solution is just to parse without respect for precedence initially and then re-associate afterwards using the user-given precedence
04:17:44 <oerjan> fact 1: no compiler does it perfectly according to the standard report
04:17:57 <dcoutts_> oerjan: really?
04:18:02 <omnId> oerjan: really?
04:18:02 <opqdonut> any pointers for analyzing asymptotic run-times of lazy algorithms?
04:18:22 <omnId> what does GHC get wrong?
04:18:29 <sili> dcoutts_: that's part of it. I'm trying to figure out how ((1 + 2)) or ((1)) results in 3 or 1 without trying to "apply" those values
04:18:42 <dcoutts_> opqdonut: the book on purely functional data structures has some nice analysis methods for lazy data structures
04:18:46 <sili> dcoutts_: that sounds crazy. I'm thinking in lispyness. I'm just confused
04:19:14 <oerjan> expressions like a == b == c
04:19:20 <aleator> dcoutts_: sorry for bothering, but did you notice http://hpaste.org/3515
04:19:32 <omnId> > 1 == 2 == True
04:19:37 <dcoutts_> sili: it's really just a parsing problem, nothing to do with semantics or application
04:19:40 <lambdabot>      precedence parsing error
04:19:40 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
04:20:42 <oerjan> well not that exact case
04:21:05 <quicksilver> sili: ((1 + 2)) is (((+) 1 2))
04:21:26 <dcoutts_> aleator: ah, I can guess what that is.. gimme a sec
04:21:30 <quicksilver> sili: but unlike in lisp, there is no sense in which extra layers of parenthesis 'apply more'
04:21:47 <quicksilver> sili: parentheses are only there to group applications, nothing more or less
04:21:49 <sili> ((+) 1 2) -- returns 3. how does it know not to try application on (3)? does it infer that we should only be applying on function types?
04:21:50 <omnId> oerjan: stuff like do () == () == () should parse do {() == ()} == ()?
04:21:56 <quicksilver> (ignoring tuples)
04:22:07 <dcoutts_> aleator: these are all bugs where people have added new support for gtk features, but not guarded them with the proper #if checks, so for people with old gtk like you, it fails.
04:22:08 <quicksilver> sili: it doesn't apply it because you didn't give it any parameters
04:22:18 <oerjan> omnId: that may be it
04:22:19 <quicksilver> sili: ((+) 1 2) 4
04:22:21 <dcoutts_> aleator: we try to support all old versions of gtk, so I'll fix it up
04:22:28 <quicksilver> sili: that would try to "apply" 3 to 4
04:22:32 <quicksilver> sili: (and give an error)
04:22:33 <omnId> oerjan: that's a type error, but still :)
04:22:38 <oerjan> except Bool is not a monadic action
04:22:56 <aleator> dcoutts: Thought it was something like this, but I'm stuck with department-machine that is practically unupdateable.
04:23:09 <aleator> dcoutts: dcoutts:_ Also, It might be that CellRendererToggle is missing onToggle?
04:23:30 <dcoutts_> aleator: it's not a problem, we do just need to test it with older gtk
04:23:48 <sili> quicksilver: eh? groups without arguments don't apply (get applied?)?
04:24:02 <oerjan> the report example: let x = True in x == x == True
04:24:07 <oerjan> > let x = True in x == x == True
04:24:08 <lambdabot>      precedence parsing error
04:24:08 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
04:24:26 <omnId> sili: right.  If you don't give it an argument, what are you applying?
04:25:05 <oerjan> (the report says not to rely on this parsing correctly, but nevertheless that's the ideal)
04:25:17 <sili> omnId: maybe my function just returns a constant?
04:25:22 <aleator> dcoutts: Well. I'm good at at hitting bugs, obviously. :/
04:25:40 <omnId> sili: nullary functions are indistinguishable from constants in Haskell.
04:25:41 <oerjan> sili: in haskell nothing is a function unless it can take an argument
04:25:47 <dcoutts_> aleator: :-)
04:25:56 <sili> I guess that makes plenty of sense.
04:26:13 <dcoutts_> aleator: btw, the cell toggle has a different name I think to not clash with the toggle of some other widget
04:26:31 <omnId> sili: if you *really* want functiony behaviour, you could "thunk" it, by turning your constant into a function from unit.
04:26:45 <omnId> 1 vs. (\() -> 1)
04:26:45 <aleator> dcoutts: Let me guess, it is not in 0.9.12 yet?
04:27:22 <dcoutts_> aleator: should be in .12
04:27:35 <dcoutts_> aleator: oh, hmm, perhaps it does have the same name. in which case you'll have to import that module explicitly and use it qualified. let me check...
04:27:36 <omnId> > (\() -> 1) () -- a pair of parens by itself is a value in the unit type, effectively the empty tuple.
04:27:39 <lambdabot>  1
04:28:25 <wli> Trouble with that is that it may be valid for the compiler to optimize it out to a constant.
04:28:27 <aleator> dcoutts: Not in 0.9.12 but is in darcs version, it seems.
04:28:43 <sili> shoot. I guess I can't apply that sweetness to my typeless language
04:29:03 <dcoutts_> aleator: ah yes, for the new ModelView.CellRendererToggle
04:29:15 <oerjan> sili: nothing about this that requires static typing
04:29:48 <quicksilver> sili: to a first approximation, you may think a value in haskell is either a Constructor (conventional notion of value) or a Lambda (waiting for a parameter before it can reduce further)
04:30:09 <quicksilver> sili: constructors can be inspected, shown, etc, with 'case'
04:30:17 <quicksilver> sili: Lambdas need another parameter
04:30:28 <quicksilver> sili: you can do that style without types
04:30:36 <quicksilver> types just ensure you never try to apply a constructor
04:30:42 <quicksilver> and never case a lambda
04:31:10 <omnId> sili: referential transparency means if a function will always return the same result for the same argument.  So if it doesn't take any arguments, it's just constant.  Without ref trans, you must distinguish between a 'value' and a nullary 'function' which could take different values.
04:31:31 <omnId> s/means if a/means a/
04:31:45 <wli> And if an argument is useless it can be optimized out.
04:31:48 <quicksilver> so to follow up omnId's point: what matters is being pure, not being typed
04:31:58 <quicksilver> you could imagine a pure but untyped language
04:32:10 <sili> sure. I have lots if "impurity"
04:32:21 <sili> side-effects :<
04:32:51 <osfameron> could you ghettoise side effects in a pure-but-untyped language ?
04:33:35 <dcoutts_> osfameron: if it's pure it has no side effects
04:33:38 <omnId> osfameron: you could do the same as Haskell.  build and chain actions purely, those actions are run later.
04:34:10 <wli> If there are truly no side effects, what you have is a calculator.
04:34:11 <dcoutts_> osfameron: your language has to be able to make side effects for the question of ghettoising to make sense
04:34:14 <sili> what I have is really a scheme-like, and I want cool infix operations :(
04:34:14 <omnId> typing makes building actions with (>>=) not entirely insane.
04:34:31 <osfameron> dcoutts_: well by "pure" I mean "as pure as Haskell" rather than necessarily "as pure as the driven snow"
04:36:16 <osfameron> omnId: ok, I was wondering how it would be enforced that actions are here, and pure functions are there, without types
04:36:40 <dcoutts_> osfameron: if you don't do it with types you might be able to do it syntactically
04:37:08 <dcoutts_> @seen pgavin
04:37:09 <lambdabot> pgavin is in #haskell. I don't know when pgavin last spoke.
04:37:44 <oerjan> actions and functions don't need to have the same dynamic type
04:38:21 * sili cries
04:38:28 <omnId> oerjan: I guess you'd just get runtime type errors
04:38:29 <dcoutts_> right, so you could enforce it in a dynamically typed language
04:38:41 <dcoutts_> I'm not sure if that's what osfameron meant
04:38:54 <omnId> erm, osfameron:, rather
04:39:31 <osfameron> ah, so the types wouldn't be at the level of the function, but at the difference between "function" and "action" in the first place
04:39:31 <oerjan> sili: you might look at ML.  it is impure but it's got essentially the same infix system as haskell
04:39:46 <oerjan> although types as well
04:40:03 <sili> oerjan: aye. I was hoping to implement it in my own language
04:40:26 <quicksilver> sili, oerjan: the problem is that 'parentheses for listbuilding/application' is not compatibility with 'parentheses for grouping'
04:40:38 <quicksilver> sili: you're going to need a 'different' parenthesis
04:40:49 <quicksilver> which does the grouping stuff (for over-riding infix precedence)
04:40:50 <sili> quicksilver: that's basically my conclusion. I can work around it by adding syntax, but then I'll hate myself
04:40:57 <quicksilver> without doing the listbuilding/application stuff
04:41:08 <quicksilver> (3 * <2 + 8>)
04:41:11 <quicksilver> for example
04:41:31 <quicksilver> the outer () trigers a real function application (top-level is '*')
04:41:40 <quicksilver> the inner <> is just to override default precedence
04:42:37 <sili> can you fiddle with operator fixity at runtime?
04:43:26 <quicksilver> in haskell, operator fixity doesn't even exist at runtime
04:43:29 <quicksilver> it's only a parsing hack
04:43:34 <sili> gotcha
04:43:39 <quicksilver> you can imagine a language in which you could, sure
04:44:07 <quicksilver> (3*2+4) is just notation for (*) 3 ((+) 2 4)
04:44:09 <sili> I'd imagine you just apply some parse magic to the parameter list before application
04:44:20 <quicksilver> (in haskell)
04:45:15 <LeCamarade> Comrades, can one do the following with wxHaskell?: (1) Transparent windows (2) Tray icon.
04:45:20 * wli would be happy enough if he could figure out enough about how the Hell to do anything with modules to get higher-order recursive parametrized modules atop H98 - MR + MPTC + FD.
04:46:15 <dcoutts_> aleator: ok, I've pushed a fix
04:46:27 <dcoutts_> LeCamarade: you can with gtk2hs
04:47:10 <aleator> dcoutts_: cool, thanks. Let me see if I can find other problems now :)
04:47:22 <dcoutts_> aleator: :-)
04:47:31 <dcoutts_> aleator: btw, what're you building?
04:47:32 <LeCamarade> dcoutts: Both? Bon. Now ... is Gtk2Hs Win32-good?
04:48:23 <dcoutts_> LeCamarade: yep, though I've never tried the transparent windows on Win32
04:48:49 <LeCamarade> :o)
04:48:57 <dcoutts_> LeCamarade: oh, hmm, I'm not sure the transparent windows is in the latest release, at least not easily
04:49:00 <aleator> dcoutts_: A simple gui for sorting images and selecting feature vectors for classification system.
04:49:15 <dcoutts_> LeCamarade: since I could not test it since my X server was too old
04:49:58 <dcoutts_> aleator: sounds interesting. If you ever want to show anything off, we're always looking for nice examples for the gtk2hs website, like a paragraph explanation and a couple screen shots
04:51:03 <aleator> dcoutts: I think I promised something in that vein. But let's see how I manage.
04:51:17 <dcoutts_> aleator: ok :-)
04:51:49 <roconnor> > length $ takeWhile (>0.001) (iterate (*(99/100)) (1::Rational))
04:51:51 <lambdabot>  688
04:51:55 <roconnor> > length $ takeWhile (>0.001) (iterate (*(99/101)) (1::Rational))
04:51:57 <lambdabot>  346
04:52:16 <aleator> dcoutts: And you can probably count on me bugging you for a while.
04:52:22 <wli> > floor logBase (99/101) 0.001
04:52:24 <lambdabot>        add an instance declaration for
04:52:24 <lambdabot>       (RealFrac (a -> a -> a), Integra...
04:52:31 <wli> > floor $ logBase (99/101) 0.001
04:52:32 <lambdabot>  345
04:52:48 <dcoutts_> aleator: np
04:52:54 <roconnor> wli:  thanks
04:53:06 <wli> > ceiling $ logBase (99/101) 0.001
04:53:08 <lambdabot>  346
04:53:13 <wli> > ceiling $ logBase (99/100) 0.001
04:53:14 <lambdabot>  688
04:53:37 <aleator> dcoutts: Just let me know when I'm a p.
04:54:03 <dcoutts_> aleator: heh, if you find bugs that's a "Good Thing"tm as we can then fix them.
04:56:50 <Jiten> when you define something like length $ takeWhile (>0.001) (iterate (*(99/101)) (1::Rational)), does ghc precalculate it's value when it doesn't depend on any input?
04:57:32 <laziest> Jiten: cannot! It might be an infinite list.
04:57:42 <wli> I'd recommend bracketing by squaring.
04:57:54 <quicksilver> Jiten: no. ghc does rather little constant folding.
04:58:30 <quicksilver> turns out to be a "hard" research problem
04:58:34 <quicksilver> to decide how much to do
04:58:39 <quicksilver> thye call it 'partial evaluation'
04:59:24 <wli> First bracket by squaring. So you have r^(2^n) < x < r^(2^(n+1))
05:00:17 <wli> Then try factors of r^(2^(n-1))
05:00:24 <quicksilver> Jiten: quite an interesting area though :)
05:00:33 <Jiten> I guess the only problems with that aren't infinite lists?
05:00:34 <laziest> quicksilver: perhaps one cannot calculate the values compile time, since they may turn out to be _|_, am I right?
05:01:18 <laziest> Jiten: consider 'undefined'
05:01:25 <laziest> undefined = undefined
05:01:28 <laziest> It is not a list
05:01:30 <quicksilver> laziest: *shrug*
05:01:40 <quicksilver> laziest: GHC already does strictness analysis
05:01:41 <wli> Basically reconstructing the k in r^k from its most significant bit downward.
05:01:52 <quicksilver> laziest: it's not that hard to catch many common cases
05:02:29 <quicksilver> laziest: although Jiten's particular example, definitely. That requires a pretty good model of the rationals to prove terminating ;)
05:02:30 <laziest> quicksilver: ya.. I remember that now...
05:03:35 <laziest> quicksilver: And full convergence tests applied analytically :)
05:04:06 <dcoutts_> LeCamarade: ah, it seems that gtk can do non-rectangular windows on Win32, it's less clear about semi-opaque/translucent ones
05:04:27 <Jiten> quicksilver: if those don't terminate, isn't that a bug the compiler should complain about anyhow?
05:05:14 <LeCamarade> Hmm. Non-rec may suffice.
05:05:15 <laziest> Jiten: You want some of them to be nonterminating. Again: undefined = undefined
05:06:01 <Jiten> even when the whole calculation is based on constants defined in the source and no input?
05:06:33 <laziest> Then running your program is the only way to see whether it will terminate
05:06:40 <laziest> It's the halting problem!!
05:08:25 <Jiten> I mean, all that's really required is to compile it once without partial evaluation, run it, if it worked out ok, take the values and use them as precalculated values for the next compile?
05:08:34 <wli> Jiten: I suggest using the algorithm I described if you just want it fast.
05:08:58 <Jiten> wli: I'm not talking about any specific case
05:09:07 <pgavin> @seen dcoutts
05:09:07 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #gentoo-haskell and #ghc. I last heard dcoutts speak 3h 8m 48s ago.
05:09:13 <dcoutts_> hia pgavin
05:09:20 <pgavin> hi
05:09:33 <pgavin> what's up?
05:09:33 <dcoutts_> pgavin: so we've still got issues with gstreamer compiling, it's changes in the bytestring stuff
05:09:37 <pgavin> hmm
05:09:39 <wli> Jiten: The algorithm with powers of your ratio that are powers of 2 should be fast enough.
05:09:43 <Jiten> maybe a compile parameter for whether the compiler will attempt that :)
05:09:45 <pgavin> what version of bytestring?
05:10:01 <dcoutts_> pgavin: bytestring-0.9
05:10:02 <wli> Or maybe a "partially evaluate this" pragma.
05:10:08 <dcoutts_> pgavin: let me push all the patches I've got from you and you can look at it
05:10:24 <pgavin> dcoutts_: ok
05:10:49 <pgavin> dcoutts_: I've gotten it to compile completely with GHC-6.6 and 6.8
05:11:02 <laziest> wli: do you actually have such a pragma (or a plan for it?)
05:11:06 <dcoutts_> pgavin: so it does not compile for me with 6.8
05:11:20 <wli> laziest: Not really. It just doesn't seem terribly far out.
05:11:39 <Jiten> yes, a pragma would work too.
05:12:06 <pgavin> dcoutts_: hmm, ok... let me try one more time
05:12:18 <pgavin> dcoutts_: so 6.6 is ok for you, right?
05:12:22 <dcoutts_> pgavin: just pushing, wait a sec..
05:15:39 <aleator> dcoutts_: Well. It seems that the patch didn't help (same error). What should I look at to fix this?
05:15:45 <Saizan> Jiten: well, you could use TH, and insert the value as it was a literal in your source
05:16:10 <pgavin> dcoutts_: I think I know what the problem is
05:16:22 <dcoutts_> aleator: ./configure again, since the patch touched Makefile.am
05:16:25 <roconnor> No one here seems to prefer arcTanh over arTanh execpt for wikipedia
05:16:27 <wli> That's even better than a pragma.
05:16:30 <roconnor> maybe I should ask in #math
05:16:38 <roconnor> er
05:16:44 <dcoutts_> aleator: and perhaps rm gtk/Graphics/UI/Gtk.hs (since we changed it to gtk/Graphics/UI/Gtk.hs.pp)
05:16:45 <wli> roconnor: What about arctanh???
05:16:50 <roconnor> I should say everyone here preferes arcTanh over arTanh
05:16:54 <aleator> Ah.. Yes.. That was it
05:17:07 <roconnor> wli: wikipedia calls it artanh
05:17:31 <aleator> dcoutts_: maybe..
05:17:32 <wli> roconnor: wikipedia must be typo'ing or on crack. arctanh or atanh are the typical names for it besides tanh^-1
05:17:58 <roconnor> http://en.wikipedia.org/wiki/Inverse_hyperbolic_function
05:18:07 <roconnor> ``The acronyms arcsinh, arccosh etc. are commonly used in the US, even though they are – technically speaking – misnomers.
05:18:13 <wli> roconnor: atanh being the exclusive province of programming languages.
05:18:53 <Jiten> Saizan: of course, it just requires doing it again if you change any of the constants (which might be defined all over the place)
05:19:34 <wli> roconnor: I've seen foreign (in particular British) literature and never has any of it used "artanh" or the others.
05:19:57 <dcoutts_> pgavin: seems I cannot apply some of your gstreamer patches, they're taking for ever to apply which usually indicates darcs conflicts
05:20:22 <pgavin> dcoutts_: should I redo them?
05:20:47 <dcoutts_> pgavin: perhaps, let me try applying a subset of them
05:21:14 <pgavin> dcoutts_: k
05:22:02 <roconnor> wli: interesting, but you aren't british yourself.
05:22:10 <roconnor> ?
05:25:09 <wli> roconnor: I obviously go for English-language papers in preference to other languages I can't read quite as easily.
05:28:30 <roconnor> :)
05:36:49 <dcoutts_> pgavin: ah, managed to push everything
05:36:59 <pgavin> dcoutts_: cool :)
05:37:08 <pgavin> you need one more patch though :)
05:37:11 <dcoutts_> pgavin: so try the current darcs version and see if it builds for you with ghc-6.8
05:37:38 <pgavin> k, I'm still compiling 6.8, but I'll try to get it done today
05:38:05 <pgavin> hmm
05:38:20 <pgavin> dcoutts_: actually, I'm going to send you a patch, see if it fixes it
05:38:26 <dcoutts_> pgavin: ok
05:38:55 * roconnor started an argument in #math
05:40:13 <fox86> hmm, if i'm writing some math in a report, is it okay to say \n -> n/100? or is that for functional programmers only? isn't that general lambda calculus?
05:41:30 <pgavin> dcoutts_: ok, I sent the patch to you and the list
05:41:40 <dcoutts_> pgavin: ta
05:41:42 <Jiten> fox86: isn't the usual way of saying that in math f(n)=n/100?
05:41:44 <roconnor> sadly it is for functional programmers only, but it shouldn't be that way.
05:41:57 <pgavin> dcoutts_: I actally fixed the problems you were talking about
05:42:03 <pgavin> dcoutts_: but I forgot :)
05:42:04 <fox86> Jiten: yes, but i feel like i'm defining a function for something so small
05:42:05 <dcoutts_> great
05:42:12 <fox86> roconnor: i agree
05:42:29 <Jiten> well, it's not going to change unless it starts getting used ;)
05:42:35 <pgavin> dcoutts_: I fixed them but just checking the GHC version
05:42:37 <fox86> Jiten: hehehe
05:42:51 <pgavin> dcoutts_: but it's actually the bytestring version that's important
05:43:09 <pgavin> dcoutts_: I wasn't sure if there was a way to check just the bytestring version
05:43:12 <Jiten> just remember that you won't have a name with which to refer to the function in that case.
05:43:29 <shapr> Good morning #haskell!
05:43:30 <shapr> @yow !
05:43:30 <lambdabot> does your DRESSING ROOM have enough ASPARAGUS?
05:43:36 <Jiten> though, for a simple function like that, it might be better to just include it verbatim.
05:44:10 <Jiten> fox86: if you do decide to use it, make sure to include an explanation on how to read it.
05:44:14 <quicksilver> fox86: lambda x . x/100 (with the proper greek letter lambda) would be understood by many matehmaticians
05:44:24 <quicksilver> fox86: mostly those with a computer science bent
05:44:37 <fox86> quicksilver: ah, nice. that's the proper notation
05:44:49 <Cale> Most mathematicians would write it with a symbol that looks like  |-->
05:44:56 <Cale> (if you want an unnamed function)
05:45:07 <Cale> n |--> n/100
05:45:13 <fox86> Caelum: is that more common that using lambda?
05:45:17 <quicksilver> yes
05:45:20 <Cale> yeah
05:45:22 <fox86> okay, thank you
05:45:25 <quicksilver> more common in the general mathematical community
05:45:37 <quicksilver> the lambda stuff is understood by those who model computation
05:45:42 <Syzygy-> fox86: Lambda notation is common in certain subareas of computer science and logic.
05:45:46 <quicksilver> which is the 'computer science end' of mathematic
05:45:51 <Cale> In TeX, I believe the symbol is called \mapsto
05:45:55 <Syzygy-> Whereas |---> is the way almost all mathematicians deal with it.
05:45:56 <Syzygy-> Cale: It is.
05:46:07 <quicksilver>  /mathlig{|->}{\mapsto}
05:46:09 <Cale> ↦
05:46:14 <quicksilver> herm
05:46:16 <fox86> cool
05:46:21 <quicksilver> s/\//\\/
05:46:22 <Cale> quicksilver: uh, no, it's standard
05:46:24 <aleator> dcoutts_: Cleaned, configured and rmd the file. Still the same error.
05:46:28 <Cale> er...
05:46:41 <quicksilver> Cale: mathlig is a package which lets you write the three characters |->
05:46:46 <dcoutts_> aleator: you did pull again from darcs.h.o/gtk2hs right?
05:46:48 <quicksilver> Cale: and have them translated to \mapsto :)
05:46:50 <Cale> oh, that's interesting
05:46:57 <aleator> dcoutts_: Naturally
05:46:59 <fox86> i am writing a report on the neural net that i tried to write in haskell without knowing haskell
05:47:34 <aleator> dcoutts_: Well, wait a sec. Let me pull a whole new repo, in case it got broken somehow..
05:47:47 <dcoutts_> aleator: try autoreconf && ./configure
05:47:53 <dcoutts_> aleator: or just make clean
05:48:12 <dcoutts_> aleator: and check that line 424 of Makefile.am does say Gtk.hs.pp and not Gtk.hs
05:48:13 <Cale> I've been playing around with the cellular automaton rule B3678/S34678, also known as "Day and Night". It's really quite an interesting rule!
05:48:31 <quicksilver> Cale: how so?
05:48:52 <pgavin> dcoutts_: email me if the patch doesn't work, I gotta go now
05:49:07 <Cale> It generates very organic looking things, but also appears to support spaceships and puffers. It's also the same under inversion of cells.
05:49:08 <dcoutts_> pgavin: ok
05:49:38 <aleator> dcoutts_: Ok, clean, autoreconf, configure, check makefile (correct), make. Lets see what happens
05:50:01 <matthew-_> what does fail do for State ?
05:50:50 <Saizan> > flip runState 1 $ fail ""
05:50:51 <lambdabot>  Exception:
05:51:15 <Saizan> i.e. fail = error
05:51:19 <matthew-_> yay. so that's like, super useful
05:51:26 <Saizan> yeah :)
05:51:43 <wli> > flip runState (1 :: Integer) $ modify (+1)
05:51:44 <lambdabot>  ((),2)
05:52:21 <quicksilver> Cale: hmm intriguing
05:52:42 <quicksilver> Cale: I'm always on the lookout for ways to produce nice pictures :)
05:53:01 <Cale> Wow, someone's managed to create a gun already too :)
05:53:05 <quicksilver> matthew-_: there is no sensible definition of fail for many monads
05:53:07 * wli needs to eke out a GUI hello world at some point.
05:53:15 <quicksilver> matthew-_: that's why it's so stupid to have fail in the monad class :(
05:53:19 <matthew-_> quicksilver: well quite.
05:53:32 <wli> Haskell 1.3 or 1.4 Preludes would help.
05:53:48 <roconnor> isn't fail there for pattern match failures in do bindings?
05:53:57 <quicksilver> Cale: any nice web pages I can look at?
05:54:07 <quicksilver> roconnor: yes. that's not good enought hough :)
05:54:18 <Cale> quicksilver: Do you have golly or another life simulator which supports .l files?
05:54:40 <Cale> http://www.tip.net.au/~dbell/archive/b3678s34678.tar.gz
05:54:52 <quicksilver> Cale: I can download golly easily enough :)
05:55:09 <roconnor> I'm really tempted to name my function arTanh
05:55:14 <ddarius> roconnor: Yes, but many would prefer a MonadZero constraint to be generated instead.
05:55:45 <roconnor> ddarius: sounds good
05:57:42 <Cale> When you get it, open up puff/p1100.l
05:57:50 <Cale> (from that tarball)
06:02:05 <shapr> mmm code
06:02:16 <matthew-_> @src evalStateT
06:02:16 <lambdabot> Source not found.
06:02:18 <matthew-_> ffs
06:02:26 <shapr> @index evalStateT
06:02:26 <lambdabot> Control.Monad.State, Control.Monad.RWS
06:02:33 <shapr> @source evalStateT
06:02:33 <lambdabot> evalStateT not available
06:02:35 <shapr> aww
06:02:55 <Saizan> @src StateT
06:02:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:05:20 <quicksilver> Cale: cool :)
06:08:23 <Cale> They seem to be able to get lots of different effects from those funky "zapping" oscillators. Have a look at gate/p32turn.l
06:09:02 <aleator> dcoutts_: Yep, still the same error.
06:09:48 <quicksilver> Cale: "Mostly, only patterns with at least bilateral symmetry display behavior I'd call interesting - asymmetrical patterns almost always decay (though they can be quite long-lived)."
06:09:54 <quicksilver> Cale: that's an intruiging observation
06:10:10 <quicksilver> Cale: that symmetry is involved in long lived behaviour
06:10:44 <Cale> Yeah, I noticed that too.
06:11:02 <dcoutts_> aleator: in gtk2hs-config.h what is the value of _GTK_MINOR_VERSION ?
06:11:43 <aleator> dcoutts: #define _GTK_MINOR_VERSION (6)
06:12:04 <Cale> If the thing is symmetrical, there seems to be a better chance that the oscillations in the boundary between white and black cancel each other out and end up keeping the thing alive.
06:12:51 <Cale> If it's asymmetrical, it seems like most patterns will slowly shrink and become the surrounding colour.
06:13:02 <Cale> (but not all of them)
06:13:15 <dcoutts_> aleator: ah, I might be being stupid, in gtk/Graphics/UI/Gtk.hs.pp on line 252 change #ifdef to #if
06:13:36 <dcoutts_> aleator: in fact I'm almost certainly being stupid
06:13:39 <Cale> check out obj/ripples.l
06:13:59 <dcoutts_> aleator: I reckon thats the mistake, tell me if changing that fixes it and I'll push another patch
06:14:38 <aleator> dcoutts: give me a sec.
06:15:24 <Cale> (btw, if you unpack the archive into Golly/Patterns, it'll get listed in the sidebar)
06:15:57 <aleator> dcoutts: Yep. Works! Now it says gtk/Graphics/UI/Gtk/ModelView/ComboBox.chs.pp:629:2 Not in scope: `comboBoxGetTitle'
06:16:18 <dcoutts_> aleator: heh, ok
06:17:47 <quicksilver> Cale: ah, I was doing to ask about that :)
06:19:18 <dcoutts_> aleator: pushing fixes...
06:19:43 <dcoutts_> done
06:20:30 <aleator> dcoutts: Ok, testing.
06:20:47 <quicksilver> Cale: how do I load the "rules" of day&night without loading a particular pattern?
06:22:01 <aleator> dcoutts: Ok, pulling, testing.. seems to compile..
06:22:09 <dcoutts_> aleator: great
06:22:42 <Cale> Control -> Rule -> Named Rule: Day and Night
06:23:19 <quicksilver> oh, obvious :) thanks
06:28:53 <quicksilver> Cale: ship/mother.l is awesome
06:29:00 <quicksilver> Cale: a ship containing two anti-ships!
06:29:35 <Cale> :)
06:34:09 <aleator> dcoutts: It works. One more question: onEdited a b is now "on a edited b"? What do I need to import?
06:36:50 <dcoutts_> aleator: I'm not sure we've really converted yet to that style yet, which bit are you missing?
06:37:45 <aleator> dcoutts: No worries, I can still do onBlah. Just trying to get celltoggles to toggle.
06:39:01 <dcoutts_> aleator: ah yes, those ModelView modules have been converted already
06:39:19 <dcoutts_> aleator: so yeah, you can use toggled and on, both should be in scope
06:39:34 <aleator> dcoutts_: Oh btw. Why is onToggle's (for cells) type String->IO. Shouldn't it give a tree path?
06:39:45 <aleator> dcoutts: on is not on path I think.
06:40:29 <joelr1> good day
06:41:19 <dcoutts_> aleator: you're quite right, it should be a path, rather than it's string representation
06:41:29 <dcoutts_> aleator: we should have gtk2hs do the conversion rather than you
06:41:49 <aleator> Is it hard to patch? Can I try?
06:42:16 <dcoutts_> aleator: it's a matter of calling the string -> path function
06:42:24 <quicksilver> Cale: the crystal stuff is pretty freaky too
06:42:55 <joelr1> did the quasiquotation patch ever make it into ghc?
06:46:44 <shapr> mmm code!
06:47:23 <roconnor> w00t first to down vote qwe1234's comment
06:47:34 <shapr> Cale, quicksilver: What are you guys looking at?
06:47:57 <Cale> shapr: Cellular automata :)
06:48:24 <shapr> Where's the code?
06:48:28 <Cale> shapr: In particular some cellular automata using the "Day and Night" rule
06:48:46 <osfameron> how do you represent cells in haskell?  A really complex form of tying the knot?  Or a grid object that knows where cells are in relation to each other?
06:48:55 <Cale> You can download Golly, and unpack http://www.tip.net.au/~dbell/archive/b3678s34678.tar.gz into its Patterns directory
06:48:56 <joelr1> roconnor: what's the article?
06:49:04 <quicksilver> osfameron: I'd just use an array for cells
06:49:23 <quicksilver> (Golly wasn't written in haskell though)
06:49:47 <osfameron> yeah, was just something I was thinking about the ohter day...  till I hurt my head
06:50:12 <quicksilver> for grids of cells, where you need every cell to have a value (i.e. not sparse) then I think arrays really are the right structure
06:50:43 <quicksilver> if you wanted to explicitly model sparseness and small changes you might do well with a Data.Map (Int,Int) Value though
06:50:45 <Cale> Golly uses some crazy hash structure.
06:51:01 <Cale> (if you turn that option on)
06:51:38 <osfameron> ah, like you would do with a theoretically infinite spreadsheet structure
06:51:47 <Cale> yeah
06:51:57 <quicksilver> if you have small changes between generations
06:52:03 <quicksilver> then Data.Map gives you nice sharing between generations
06:52:06 <quicksilver> so that would be good
06:52:16 <quicksilver> the 'overhead' per populated cell is massive though
06:52:20 * osfameron at one point did a lot of thinking about spreadsheets (to thr point of being able to understand some otherwise insane-seeming design decisions on Excel :-)
06:52:34 <Cale> It can exploit repetition to simulate many life patterns exponentially quickly too.
06:52:53 <quicksilver> I imagine a single (Int,Int) -> Val mapping might well occupy 40-60 bytes
06:53:26 <Cale> It also makes things like life-inside-life actually reasonable.
06:53:31 <quicksilver> however, that might still look like a decent tradeoff if you're enjoying the sharing between generations and you're modelling something moderately sparse
06:56:44 <shapr> Good morning byorgey!
06:56:56 <byorgey> morning shapr!
06:56:56 <hpaste>  aleator pasted "Is this anyway near correct, dcoutts?" at http://hpaste.org/3516
06:57:05 <byorgey> how's code? =)
06:57:48 <dcoutts_> aleator: that looks fairly reasonable
06:58:20 <shapr> byorgey: just strting to flow, how's code for you?
06:59:21 <byorgey> shapr: well, code is taking a backseat to grad school applications at the moment, but those are going pretty well.
06:59:32 <shapr> Where are you hoping to go to grad school?
07:00:13 <aleator> dcoutts: Cool. Can I send a patch? (ok, this one is really really simple, but in case I can figure out other similar things?)
07:01:16 <byorgey> well I'm applying to Yale, Princeton, CMU, UPenn, Rutgers, McGill, PSU.  ATM I think McGill is my top choice.  But we'll see... in general, somewhere I can study Haskell/other declarative langs/type systems etc. =)
07:01:39 <dcoutts_> aleator: sure, it might be nicer to do it inline, with a lambda than another top level function
07:02:17 <LeCamarade> Woah. SaMBuCa_ !
07:02:24 <LeCamarade> Nice name.
07:02:32 <LeCamarade> Sambuca, eh? ;o)
07:02:42 <aleator> dcoutts: Sure. It was just easier to see types like this.
07:03:00 <SaMBuCa_> LeCamarade: tnx ^^ why do u think that?
07:03:23 <LeCamarade> It's potent Italian brew.
07:03:35 <LeCamarade> @go define: sambuca
07:03:36 <lambdabot> No Result Found.
07:03:44 <LeCamarade> @go define sambuca
07:03:49 <lambdabot> http://foodgeeks.com/encyclopedia/254/sambuca/
07:03:49 <lambdabot> Title: Sambuca Definition :: Food Encyclopedia :: Foodgeeks.com
07:04:00 <SaMBuCa_> LeCamarade: and i like it so much :) cos i'm italian :P
07:04:21 <dcoutts_> aleator: aye, we should really add an attribute/signal fmap function
07:04:22 <SaMBuCa_> *-cos
07:04:25 <LeCamarade> :o) I'm not Italian, but some character in a novel liked it, and the name feels rich.
07:04:33 <dcoutts_> aleator: to make it easier to make derived signals/attributes
07:05:06 <aleator> dcoutts: Probably yes. Still can't really see my way in the code..
07:06:13 <SaMBuCa_> LeCamarade: look at this: http://lab.passiomatic.com/image-bin/2803962036.jpe
07:08:22 <SaMBuCa_> LeCamarade: what is the name of the novel u're talkin about?
07:08:59 <LeCamarade> Gold Coast, by Nelson DeMille.
07:11:07 <SaMBuCa_> LeCamarade: http://www.nelsondemille.net/books/gold_coast.asp -> seems interesting, maybe i'll buy it.
07:11:09 <lambdabot> Title: Nelson DeMille - The Gold Coast
07:11:41 <LeCamarade> It rocks. Was my fave the year I read it.
07:11:47 <pgavin> @seen dcoutts
07:11:47 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #gentoo-haskell and #ghc. I last heard dcoutts speak 5h 11m 28s ago.
07:11:54 <dcoutts_> hia pgavin
07:11:59 <pgavin> i'm back :)
07:12:07 <dcoutts_> @arr!
07:12:07 <lambdabot> I'll crush ye barnacles!
07:12:17 <pgavin> no, please don't crush my barnacles
07:12:20 <pgavin> I need them
07:12:22 <dcoutts_> oh ok :-)
07:12:24 <pgavin> lol
07:12:39 <pgavin> did you get those patches to work?
07:12:59 <dcoutts_> pgavin: I've been distracted with other things, will apply those in a min
07:13:05 <pgavin> ok, cool :)
07:14:25 <pgavin> dcoutts_: do we have a way to check for specific Haskell packages (like bytestring) in gtk2hs?
07:14:51 <dcoutts_> pgavin: only in configure.ac and setting cpp defines
07:15:07 <dcoutts_> pgavin: eg see HAVE_MTL, though we can also check ghc version
07:15:29 <pgavin> dcoutts_: ok, I guess we'll need to check which version of bytestring is available though
07:15:34 <pgavin> not just if it exists
07:17:06 <dcoutts_> pgavin: well with ghc-6.6 we use the one in base, otherwise we use the standalone bytestring-0.9
07:17:18 <dcoutts_> pgavin: so we can use that with ghc-6.4 and 6.8
07:18:16 <pgavin> ok, so you want to require bytestring-0.9 regardless of which ghc is in use?
07:20:53 <dcoutts_> pgavin: no, we can only use bytestring-0.9 with ghc-6.4 and 6.8. For ghc-6.6 we must use the version included in base.
07:21:08 <dcoutts_> it's not possible to use the separate bytestring package with ghc-6.6
07:21:47 <pgavin> dcoutts_: oh, ok
07:22:03 <pgavin> dcoutts_: so I'll just check if the ghc version == 6.6 instead
07:22:16 <pgavin> or, >= 6.6 and < 6.7
07:23:04 <dcoutts_> pgavin: right
07:23:14 <pgavin> kk
07:33:41 <mdmkolbe|ubunt1> is readFile the right way to slurp up a binary file or will that function do funky unicode char stuff?
07:35:25 <roconnor> mdmkolbe|ubunt1: I don't think readFile is the right way to read binary files
07:35:32 <quicksilver> mdmkolbe|ubunt1: it doesn't do anything remotely funky
07:35:40 <quicksilver> mdmkolbe|ubunt1: btu it does give you something with entirely the wrong type :)
07:35:45 <roconnor> do we have a right way of doing Binary IO yeat?
07:35:48 <roconnor> yet
07:36:08 <roconnor> anything in Data.Bytestring?
07:36:16 <roconnor> there must be something
07:36:17 <pgavin> roconnor: yeah, Bytestring is the way to go
07:36:21 <quicksilver> yes, there is
07:36:30 <pgavin> roconnor: Data.ByteString has IO operations
07:37:12 <roconnor> Data.ByteString.readFile
07:37:38 <roconnor> mdmkolbe|ubunt1: Data.ByteString.readFile for small files
07:38:02 <roconnor> Data.ByteString.Lazy.readFile for big files
07:38:38 <quicksilver> well, BS.Lazy for big files which you will still use linearly
07:38:50 <quicksilver> for big files random access you'll want to roll your own IO with hSeek
07:38:58 <quicksilver> I would imagine
07:39:51 <mdmkolbe|ubunt1> awsome. (for now, I just need the first 1000 elements in a list, so I sounds like BS.lazy is the right way)
07:40:17 <roconnor> 1000 bytes?
07:41:10 <mdmkolbe|ubunt1> roconnor: for now.  this is just a prototype.  the next stage is to take the first 1000 words and see if my algorithms behave differently
07:41:53 <roconnor> 1000 * 4 bytes is still pretty small
07:42:17 <quicksilver> more than small
07:42:20 <quicksilver> it's miniscule!
07:42:22 <quicksilver> :)
07:42:29 <quicksilver> it'll fit in a cache
07:42:48 <roconnor> mdmkolbe|ubunt1: for large, think too big to fit in physical memory.
07:43:19 <pgavin> roconnor: or so big swapping will happen
07:44:17 <roconnor> w00t, I proved e <= 3
07:44:43 <wli> What definition of e?
07:45:08 <roconnor> e is defined to be the inverse of 1/e, which is defined by it's alternating series.
07:45:27 <roconnor> euler's number
07:45:34 <mdmkolbe|ubunt1> roconnor: ah.  that makes sense
07:46:04 <mdmkolbe|ubunt1> @hoogle argv
07:46:05 <lambdabot> No matches found
07:46:10 <byorgey> roconnor: hm, you use the alternating series because it's easy to prove convergence?
07:46:37 <wli> No, because the convergence is nice in terms of upper and lower bounds.
08:00:35 <wli> > let psums = scanl (+) 0 $ zipWith ((recip .) . (*)) (1 : scanl1 (*) [1..]) (cycle [1,-1]) :: [Rational] in take 10 [(1/y, 1/x) | (x, y) <- zip psums (tail psums), y > x, x > 0]
08:00:37 <lambdabot>  [(8%3,3%1),(144%53,30%11),(5760%2119,280%103),(44800%16481,45360%16687),(435...
08:03:03 <wli> There's a sequence of nesting, shrinking bounding intervals with rational endpoints derived from the alternating series.
08:04:38 <wli> 8/3 <= e <= 3 is only the first.
08:05:48 <byorgey> I see, nice.
08:06:48 <wli> They are quite good (IOW, convergence is relatively swift).
08:06:54 <wli> > (44800/16481, 45360/16687) :: (Double, Double)
08:06:56 <lambdabot>  (2.7182816576664037,2.71828369389345)
08:07:10 <byorgey> and the series for e itself gives you lower bounds but no nice upper bounds, I suppose?
08:07:56 <wli> It's not as easy to derive useful ones, no.
08:09:49 <wli> The continued fraction for e doesn't actually converge very quickly, or at least not the usual one, which is for e^x at x = 1.
08:10:18 <wli> The continued fraction for e^x converges rapidly only for large x > 1.
08:10:36 <ricky_clarkson> Are there any languages for which someone has used, say, a macro system to graft typeclasses on, instead of supporting them as part of the core?
08:12:00 <byorgey> uh... C++?
08:14:10 <dons> interesting, maybe we should do these , http://bc.tech.coop/blog/071028.html
08:14:11 <lambdabot> Title: Bill Clementson's Blog: More LispCasts
08:15:19 <quicksilver> dons: I postulate that would be interesting. Based on the fact that you learn a lot by watching a good programmer for 15 minutes
08:15:22 <byorgey> wli: I don't see what the continued fraction has to do with anything...?
08:15:29 <quicksilver> dons: compared to, say, talking on IRC for 6 hours :)
08:15:54 <shapr> yeah, haskellcasts!
08:15:57 <wli> byorgey: They produce rational approximants with the smallest possible denominator for a given error.
08:17:49 <byorgey> wli: right.  I thought we were talking about the series expansion, which surely converges much faster.  I just didn't understand how your statement about the continued fraction related to your previous statements.
08:18:32 <byorgey> wli: by the way, I don't know how my tone is coming across, but I'm not trying to challenge your statements, just trying to understand. =)
08:20:46 <dons> quicksilver: right.
08:31:21 <hpaste>  ry pasted "Kind error: `AbstractInteger' is not applied to enough type arguments???" at http://hpaste.org/3518
08:31:57 <_ry> anyone know what that paste is about?
08:32:51 <doserj> abstractIntegerCmp :: AbstractInteger a -> AbstractInteger a -> Ordering
08:33:24 <doserj> but are you sure that you need the phantom argument?
08:33:36 <_ry> why doesn't Ordering require a type variable?
08:33:53 <doserj> because it is nor parameterized
08:33:56 <doserj> *not
08:34:06 <_ry> oh okay
08:34:15 <doserj> @src Ordering
08:34:15 <lambdabot> data Ordering = LT | EQ | GT
08:34:36 <_ry> phantom argument? which?
08:34:47 <_ry> to abstract integer?
08:34:51 <doserj> yes
08:35:09 <doserj> it is not really used on the right side of the datatype definition
08:35:10 <_ry> hm - not sure. i think so :/
08:35:33 * wli is wrong about the continued fraction; it does better than the series.
08:35:49 <_ry> Succ (AbstractInteger c)  <-- used here
08:35:53 <doserj> data AbstractInteger = Zero | Succ AbstractInteger | Pred AbstractInteger
08:36:13 <_ry> ah
08:36:19 <faxathisia> Hello
08:36:46 <wli> let step (cur, prev) a = (a * cur + prev, cur) ; evalCF ((hST, kST), ~(a:as)) = ((step hST a, step kST a), as) ; cvgts = tail $ (map (uncurry ((/) `on` fromIntegral) . (fst *** fst) . fst) $ iterate evalCF (((1, 0), (0, 1)), 2 : 1 : concat [[2*n, 1, 1] | n <- ([1..] :: [Integer])]) :: [Rational]) in mapM_ print . take 10 $ [(a, b, fromRational (b - a) :: Double) | (a, b) <- zip cvgts (tail cvgts), a < b]
08:37:36 <doserj> _ry: do you want to distinguish an "AbstractInteger String" from an "AbstractInteger (Maybe Bool)"?
08:38:02 <_ry> doserj: no, i just want a nested type
08:38:22 <byorgey> hi faxathisia
08:38:58 <_ry> I thought by saying Succ (AbstractInteger c) it meant that Succ has a parameter of type AbstractInteger
08:39:45 <doserj> it means it has a parameter of type (AbstractInteger c) :)
08:47:42 <quicksilver> Cale: Ah. I see now, rereading the thread, that apfelmus was making that exact point about &&&/fst
08:47:53 <quicksilver> Cale: I was reading it first time with the wrong colourer spectacles on.
08:49:54 <vvv> Hi,  Shouldn't compiler complain, when `otherwise' is used in case expressions?
08:50:12 <vvv> instead of `_' (underscore) wildcard?
08:50:24 <quicksilver> vvv: otherwise is just a boolean value
08:50:24 <dons> nope :)
08:50:31 <quicksilver> vvv: it's not a keyword
08:50:31 <byorgey> vvv: otherwise == True =)
08:50:34 <quicksilver> > otherwise
08:50:34 <dons> vvv: in a cast alternative?
08:50:36 <lambdabot>  True
08:50:46 <dons> vvv: in which case its a new variable you bound...
08:50:49 <vvv> e.g.: foo, bar :: Int
08:50:59 <vvv> case (foo, bar) of
08:51:00 <dons> case x of 1 -> .. ; otherwise {-!!-} -> 2
08:51:11 <vvv>   (1, 1) -> "all ones"
08:51:24 <vvv>   (2, 3) -> "not equal"
08:51:49 <vvv>   otherwise -> "compiler doesn't complain, but it *should*, IMHO"
08:51:50 <dons> its binding a new variable called 'otherwise' to what you matched. if you use -Wall you'll get a name shadowing warning.
08:52:16 <quicksilver> otherwise -> "this is a variable with tuple type, look : otherwise = " ++ show otherwise
08:52:29 <byorgey> since otherwise isn't special syntax, I don't see why the compiler should give an error.
08:52:40 <dons> well, it will give a name shadowing error
08:52:44 <quicksilver> > case (4,3) of (1,1) -> "boo" | otherwise -> "look at this, otherwise = " ++ show otherwise
08:52:44 <lambdabot>  Parse error at "|" (column 30)
08:52:54 <quicksilver> > case (4,3) of (1,1) -> "boo" ; otherwise -> "look at this, otherwise = " ++ show otherwise
08:52:56 <lambdabot>  "look at this, otherwise = (4,3)"
08:52:57 <vvv> dons: Ah, I see. In my case `otherwise' will be bound and its type will be :: (Int, Int).
08:53:01 <dons> yep
08:53:03 <byorgey> dons: I was using "error" in the technical sense of "not just a warning" =)
08:53:04 <vvv> dons: Am I right?
08:53:31 <dons> its not really an error. depends on how 'built in' you think `otherwise` is :)
08:53:45 <dons> vvv: but yes, that's exactly what's happenign. otherwise is bound to your tuple
08:54:47 <vvv> dons: the strange thing is my GHC doesn't warn of any shadowing. It knows, how to do this :), but not in this case.
08:54:57 <dons> another guy saying he interviews people esp. if they have haskell et al in their resume, http://blog4aurobindo.blogspot.com/2007/10/write-resume-that-will-land-you_8065.html
08:55:00 <lambdabot> Title: blog4aurobindo: Write a resume that will land you a programming job..PART 3, http://tinyurl.com/2f7pny
08:55:04 <dons> vvv: use -Wall
08:55:11 <dons> and then -Werror to make it fatal
08:55:48 <vvv> Oh, thanks! Let me try..
08:56:50 <zeloran> hi
08:56:54 <faxathisia> Hello zeloran
08:57:01 <dons> welcome, zeloran.
08:57:07 <zeloran> can i ask you something about haskell?
08:57:14 <dons> definitely! this is #haskell :)
08:57:32 <zeloran> I have:        data Expr = Con Int | Var String | Sum[Expr] | Prod[Expr]
08:57:50 <zeloran> and i'm trying to call: Prod[Con 5,Sum [Var"x",Con 2,Con 3]]
08:57:56 <zeloran> i got an show error
08:58:09 <faxathisia> Oh you can put, Prod[Expr] deriving show
08:58:20 <faxathisia> And then it will try to create an instance of the show class
08:58:20 <dons> yes, you need to derive Show first.
08:58:27 <dons> data A = B deriving Show
08:58:40 <zeloran> hmm
08:58:46 <zeloran> can you help a little more
08:58:53 <zeloran> so i need to write my own show function?
08:58:54 <dons> data Expr = Con Int | Var String | Sum[Expr] | Prod[Expr] deriving Show
08:59:10 <dons> no! you let the compiler write it for you, using the 'deriving' keyword, as above
08:59:23 <dons> which creates the show function for your type
08:59:33 <zeloran> okay i will give it a try
08:59:36 <faxathisia> It is possible to write your own show instance, but easier to have it done :)
09:00:06 <quicksilver> still, I wish ghci had a default way to display data that didn't have show defined
09:00:16 <zeloran> oh cool worked for me
09:00:21 <zeloran> thx very mush :)
09:01:23 <roconnor> byorgey: yes.
09:03:20 <faxathisia> Can you help think of a name for a function?
09:03:30 <faxathisia> <?> [F, G] 2 = [FF, FG, GF, GG]
09:03:57 <mrd> sequence
09:04:05 <surripui> any good STM examples?
09:04:15 <mrd> > sequence "FG"
09:04:18 <dons> surripui: on the wiki there's a collection
09:04:23 <lambdabot>  Couldn't match expected type `m a' against inferred type `Char'
09:04:24 <byorgey> > ((sequence .) . flip replicate) ['F', 'G'] 2
09:04:29 <lambdabot>  ["FF","FG","GF","GG"]
09:04:40 <mrd> > sequence ["F","G"]
09:04:41 <dons> surripui: http://haskell.org/haskellwiki/Concurrency_demos
09:04:41 <lambdabot>  ["FG"]
09:04:42 <lambdabot> Title: Concurrency demos - HaskellWiki
09:04:45 <byorgey> > sequence $ replicate 2 ['F','G']
09:04:47 <lambdabot>  ["FF","FG","GF","GG"]
09:04:48 <mrd> right
09:04:48 <surripui> dons: is this the best resource: http://www.haskell.org/haskellwiki/Software_transactional_memory
09:04:49 <lambdabot> Title: Software transactional memory - HaskellWiki
09:04:51 * mrd is tired
09:04:55 <faxathisia> cool :D
09:04:56 <surripui> dons: thanks! ;-)
09:04:56 <quicksilver> > replicateM 2 "FG"
09:04:57 <lambdabot>  ["FF","FG","GF","GG"]
09:05:16 <mrd> so, <?> = flip replicateM
09:05:41 <faxathisia> > map (\f -> f (1,1)) $ replicateM 2 (\(x,y)->(x+y,y)) (\(x,y)->(x,y+x))
09:05:42 <lambdabot>      The lambda expression `\ (x, y) -> ...' has one argument,
09:05:42 <lambdabot>     but its ty...
09:05:57 <dons> surripui:also, ask in here, since people have a lot of experience with STM
09:05:59 <quicksilver> otherwise known as mEtacilper
09:06:04 <faxathisia> > map (\f -> f (1,1)) $ replicateM 2 [(\(x,y)->(x+y,y)), (\(x,y)->(x,y+x))]
09:06:05 <lambdabot>  Couldn't match expected type `(t, t1) -> b'
09:06:16 <hpaste>  vvv pasted "`otherwise' as case pattern" at http://hpaste.org/3519
09:06:17 <surripui> dons: thanks
09:06:20 <ndm> is Ketil Malde on IRC?
09:06:22 <dons> ?users
09:06:22 <lambdabot> Maximum users seen in #haskell: 423, currently: 399 (94.3%), active: 18 (4.5%)
09:06:37 <dons> ndm: yes
09:06:40 <dons> sometimes
09:06:42 <ndm> would be nice to have a @name plug for lambdabot to tell me :)
09:06:44 <ndm> dons: as?
09:06:44 <surripui> oh, so is it true that Microsoft sponsors all the development of Haskell?
09:06:49 <dons> hmm, 'kzm'
09:06:51 <dons> ?seen kzm
09:06:51 <lambdabot> I haven't seen kzm.
09:06:54 <ndm> surripui: no, not even slightly
09:06:57 <vvv> dons: no, -Werror doesn't help [http://hpaste.org/3519]
09:07:00 <dons> surripui: not all of the development :)
09:07:00 <ndm> (although they do sponsor quite a lot)
09:07:05 <surripui> ndm: that is what Microsoft just told me
09:07:11 * ndm wants microsoft sponsorship
09:07:15 <surripui> I am at the Microsoft Web Developer Summit
09:07:16 <ndm> surripui: who exactly?
09:07:16 <dons> just some of it. data parallel haskell is sponsored by microsoft, for example
09:07:21 <dons> and ghc development
09:07:45 <faxathisia> Where is replicateM from?
09:07:53 <ndm> @src replicateM
09:07:53 <lambdabot> replicateM n x = sequence (replicate n x)
09:07:57 <conal> surripui: who at MS is talking about haskell?
09:07:59 <ndm> @index replicateM
09:07:59 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:08:00 <dons> surripui: some key things are sponsored by MS.
09:08:02 <surripui> Sam Ramji said it
09:08:13 <conal> anyone know who that is?
09:08:14 <vvv> @hoogle replicateM
09:08:14 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
09:08:14 <faxathisia> thank you :0
09:08:14 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
09:08:18 <conal> surripui: what's the context?
09:08:30 <dons> http://samus.typepad.com/
09:08:31 <ndm> i think MS sponsor some bits, but I think Galois sponsors more general "Haskell" things that MS
09:08:32 <lambdabot> Title: What Do You Care What Other People Think?
09:08:32 <surripui> conal: their efforts in OSS
09:08:49 <byorgey> :t let f (x,y) = (x+y,y); g (x,y) = (x,x+y) in replicateM 2 [f,g]
09:08:49 <conal> surripui: oh.
09:08:50 <lambdabot> forall t. (Num t) => [[(t, t) -> (t, t)]]
09:09:19 <surripui> I was shocked to hear it
09:09:26 <byorgey> :t let f (x,y) = (x+y,y); g (x,y) = (x,x+y) in map (msum . map Endo) $ replicateM 2 [f,g]
09:09:27 <lambdabot>     No instance for (MonadPlus Endo)
09:09:27 <lambdabot>       arising from use of `msum' at <interactive>:1:49-52
09:09:27 <lambdabot>     Possible fix: add an instance declaration for (MonadPlus Endo)
09:09:34 <byorgey> :t let f (x,y) = (x+y,y); g (x,y) = (x,x+y) in map (mconcat . map Endo) $ replicateM 2 [f,g]
09:09:35 <lambdabot> forall t. (Num t) => [Endo (t, t)]
09:09:35 <faxathisia> map (\f -> f (1,1)) $ replicateM 2 [(\(x,y)->(x+y,y)),(\(x,y)->(x,x+y))]
09:09:46 <faxathisia> doesn't work :p
09:09:51 <faxathisia> I think it's a list of functions
09:09:58 <byorgey> :t let f (x,y) = (x+y,y); g (x,y) = (x,x+y) in map (($(1,1)) . getEndo . mconcat . map Endo) $ replicateM 2 [f,g]
09:10:00 <lambdabot> Not in scope: `getEndo'
09:10:09 <byorgey> > let f (x,y) = (x+y,y); g (x,y) = (x,x+y) in map (($(1,1)) . appEndo . mconcat . map Endo) $ replicateM 2 [f,g]
09:10:10 <lambdabot>  [(3,1),(3,2),(2,3),(1,3)]
09:10:13 <faxathisia> > apply [id,(+1),(*2)] 1
09:10:13 <vvv> well, concerning `otherwise' in case expressions...
09:10:14 <lambdabot>   Not in scope: `apply'
09:10:53 <faxathisia> Who is Endo?
09:10:58 <byorgey> faxathisia: ^^^ that does what you want, I think, although there are probably less obfuscated ways of doing it. =)
09:11:28 <byorgey> faxathisia: hehe, well, if you ask "who" is Endo, Endo is the protagonist of the recent ICFP programming contest.
09:11:45 <byorgey> faxathisia: but in the code above, it is short for "endomorphism", i.e. a function of type a -> a
09:12:00 <byorgey> faxathisia: it's the Monoid instance for endomorphisms.
09:12:21 <byorgey> faxathisia: but don't panic if that doesn't mean anything to you =)
09:12:29 <faxathisia> byorgey: I'm so confused!
09:12:29 <faxathisia> :p
09:12:29 <faxathisia> That's really cool though
09:12:29 <faxathisia> :t ($(1,1))
09:12:31 <lambdabot> forall b t t1. (Num t, Num t1) => ((t, t1) -> b) -> b
09:12:46 <byorgey> faxathisia: ($(1,1)) is just (\f -> f (1,1))
09:12:59 <faxathisia> I read a little about Morphism
09:13:05 <faxathisia> Morphisms*
09:13:46 <vvv> Could you assure me that `otherwise' in http://hpaste.org/3519 is used incorrectly? Compiler (GHC 6.6.1) can't.
09:13:55 <byorgey> faxathisia: right, an "endomorphism" is just a morphism from something to itself.  so in this case, a function of type (a -> a).
09:14:21 <hpaste>  EvilTerran annotated "`otherwise' as case pattern" with "(no title)" at http://hpaste.org/3519#a1
09:14:30 <EvilTerran> @src otherwise
09:14:30 <lambdabot> otherwise = True
09:14:38 <EvilTerran> 'nuff said
09:15:12 <hpaste>  EvilTerrran annotated "`otherwise' as case pattern" with "alternatively" at http://hpaste.org/3519#a2
09:15:12 <mux> @src inits
09:15:13 <lambdabot> inits []     =  [[]]
09:15:13 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
09:15:19 <vvv> EvilTerran: is there a way to make compiler reject invalid use of `otherwise'?
09:15:39 <EvilTerran> vvv, it's just a value that's defined to be =True.
09:15:42 <byorgey> faxathisia: the problem is that when you do replicateM 2 [f,g]  you get a list of lists of functions.
09:15:49 <faxathisia> yes
09:15:56 <byorgey> faxathisia: like [[f,f], [f,g], [g,f], [g,g]] or whatever
09:16:05 <EvilTerran> vvv, you'll get a type error if you try to use it anywhere where a Bool would be invalid, but it's just an expression
09:16:08 <byorgey> faxathisia: but you can't apply a list of functions as if it were a function.
09:16:09 <faxathisia> f and g are endomorphisms?
09:16:12 <EvilTerran> like any other
09:16:20 <quicksilver> EvilTerran: yes, he knows that
09:16:24 <byorgey> faxathisia: in this case, yes, because they have type (a,b) -> (a,b)
09:16:32 <quicksilver> EvilTerran: he was just annoyed that it gets silently rebound on the LHS of a case
09:16:39 <quicksilver> EvilTerran: he was hoping for a shadowing warning at least
09:16:49 <quicksilver> (we just went through all this with him :)
09:16:53 <EvilTerran> ah, okay. i haven't read the scrollback
09:16:53 <faxathisia> :t (map Endo)
09:16:54 <lambdabot> forall a. [a -> a] -> [Endo a]
09:17:08 <faxathisia> byorgey: Wow :D
09:17:19 <dozer> HI
09:17:44 <byorgey> faxathisia: so that turns each list of functions into a list of Endo objects.
09:17:56 <EvilTerran> is there a standard diverging expression in the untyped \calc?
09:18:00 <faxathisia> I suppose Endo is also a monad?
09:18:06 <faxathisia> and that's why you do mconcat
09:18:12 <byorgey> faxathisia: no, it's a Monoid
09:18:17 <faxathisia> oops
09:18:24 <byorgey> faxathisia: =)
09:18:25 <arcatan> monocat
09:18:25 <EvilTerran> the monadplus one is msum
09:18:34 <conal> all applications of Endo are monoids
09:18:35 <faxathisia> so mconcat is short for monoid concant?
09:18:39 <quicksilver> yes
09:18:40 <conal> Endo is an applicative functor
09:18:43 <byorgey> faxathisia: do you know about monoids?
09:18:49 <faxathisia> byorgey: No :(
09:18:55 <quicksilver> the confusion between mconcat and msum and mappend and mplus is really annoying
09:19:01 <quicksilver> namespace overlap bleh
09:19:06 <quicksilver> well not really namespace
09:19:09 <quicksilver> but the initial 'm'
09:19:09 <byorgey> faxathisia: a monoid is just a set with an associative binary operation and an identity.
09:19:11 <quicksilver> feel a bit like it
09:19:15 <mux> @src tails
09:19:16 <lambdabot> tails []         = [[]]
09:19:16 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
09:19:17 <faxathisia> quicksilver: I would call it oidconcat
09:19:28 <conal> oops -- never mind about Endo and AF
09:19:31 <byorgey> faxathisia: for example, the nonnegative integers with identity 0 and operation +
09:19:33 <twanvl> We need a way to say (forall a. Monoid (m a)) => ...
09:19:49 <byorgey> faxathisia: or, the positive integers with identity 1 and operation *
09:20:06 <byorgey> faxathisia: or, endomorphisms with identity id and operation (.)   =)
09:20:14 <faxathisia> byorgey: aha!
09:20:33 <byorgey> faxathisia: mconcat is just a shorthand for a fold using the monoid operation.
09:20:43 <conal> twanvl: yes!
09:21:08 <conal> more generally, we need to write instances in lambda prolog
09:21:33 <byorgey> faxathisia: so calling mconcat on a list of Endo's composes them all into one.
09:21:43 <mux> :t foldr mappend mempty
09:21:45 <lambdabot> forall a. (Monoid a) => [a] -> a
09:21:52 <byorgey> faxathisia: i.e. mconcat [Endo f, Endo g, Endo h] === [Endo (f . g . h)]
09:23:49 <byorgey> faxathisia: make sense?
09:23:55 <faxathisia> yes it does
09:23:58 <faxathisia> It's super neat
09:24:04 <byorgey> indeed =)
09:24:07 <dozer> I'm trying to remember how to take a list of nodes (a,b) representing a directed graph, and produce all predicesors/successors for each node
09:24:14 <dozer> is ther something I'm missing in the standard libs?
09:24:49 <opqdonut> lookup
09:24:52 <faxathisia> @hoogle (a -> Bool) -> [a] -> [a]
09:24:52 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
09:24:52 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
09:24:52 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
09:24:58 <opqdonut> or filter, yes
09:25:05 <opqdonut> or:
09:25:58 <conal> [ b | (a,b) <- l ]
09:26:26 <opqdonut> > let pred x edges = [a | (a,b) <- edges, a == x] in pred 1 [(2,1),(1,1)]
09:26:28 <lambdabot>  [1]
09:26:44 <opqdonut> > let pred x edges = [a | (a,b) <- edges, b == x] in pred 1 [(2,1),(1,1)]
09:26:45 <lambdabot>  [2,1]
09:26:46 <opqdonut> stupid typo
09:26:57 <conal> oh -- of course you need the ==
09:27:06 <opqdonut> yep, otherwise it matches
09:27:14 <opqdonut> something like that would be nice, tho
09:27:25 <opqdonut> [b | (=a,b) <- l] or something
09:27:40 <conal> i wonder if view patterns help
09:28:00 <opqdonut> view patterns?
09:28:17 <conal> @go haskell view patterns
09:28:21 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg20390.html
09:28:21 <lambdabot> Title: Re: [Haskell] View patterns in GHC: Request for feedback
09:28:37 <conal> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
09:28:39 <lambdabot> Title: ViewPatterns - GHC - Trac
09:28:54 <opqdonut> thx
09:30:04 <dozer> > let pred x edges = [a | (a,b) <- edges, a == x] in pred 1 [(3,2),(2,1),(1,1)]
09:30:07 <lambdabot>  [1]
09:30:08 <opqdonut> well, they'd help a bit yes
09:30:29 <dozer> > let pred x edges = [a | (a,b) <- edges, a == x] in pred 1 [(2,3),(1,2),(1,1)]
09:30:31 <lambdabot>  [1,1]
09:30:31 <faxathisia> I would like a show for functions
09:30:34 * byorgey just found out that "endomorphism" is also the name of a Finnish band composed of angsty young men
09:31:01 <opqdonut> dozer: yeah it should be "b ==" instead of "a =="
09:31:10 <dozer> > let pred x edges = [b | (a,b) <- edges, a == x] in pred 1 [(3,2),(2,1),(1,1)]
09:31:11 <lambdabot>  [1]
09:31:35 <byorgey> faxathisia: that's a common desire, but unfortunately it's not really possible.  not very easily at least.
09:31:35 <dozer> > let pred x edges = [b | (a,b) <- edges, a == x] in pred 3 [(3,2),(2,1),(1,1)]
09:31:37 <lambdabot>  [2]
09:31:42 <faxathisia> instance Show (a -> b) where show x = "a->b"
09:31:48 <faxathisia> It's not a really good one :p
09:31:53 <opqdonut> :D
09:32:00 <dozer> right, but that is only finding the emediate children, not all the 'reachable' ones
09:32:10 <byorgey> faxathisia: the problem is that such an instance of show would break referential transparency.
09:32:15 <opqdonut> dozer: ok, misunderstood
09:32:24 <faxathisia> byorgey: why?
09:32:47 <byorgey> faxathisia: I was afraid you were going to ask that.  =)  let me think for a minute to remember why...
09:32:50 <opqdonut> dozer: but finding all of them is quite simple
09:33:12 <opqdonut> because you can use the list monad to operate on sets of nodes
09:33:13 <dozer> opqdonut_: well, it is if you don't care about repetitions or loops
09:33:17 <opqdonut> like so:
09:33:48 <opqdonut> > let pred x edges = [a | (a,b) <- edges, b == x] in flip pred [(1,2),(2,3),(3,4)] =<< [1,2]
09:33:50 <lambdabot>  [1]
09:33:57 <opqdonut> woops
09:34:00 <opqdonut> > let pred x edges = [a | (a,b) <- edges, b == x] in flip pred [(1,2),(2,3),(3,4)] =<< [2,3]
09:34:01 <lambdabot>  [1,2]
09:34:03 <opqdonut> better example :)
09:34:15 <opqdonut> dozer: well loops can be taken care of
09:34:41 <opqdonut> we feed the set of reachable nodes into pred and stop when no new nodes appear, basically
09:35:56 <zeloran> oh
09:36:19 <zeloran> another nice question
09:36:31 <zeloran> i still have: data Expr = Con Int | Var String | Sum [Expr] | Prod [Expr]  deriving Show
09:36:44 <zeloran> and
09:36:46 <zeloran> simplify :: Expr -> Expr
09:36:46 <zeloran> simplify (Prod (Con 0:_)) = Con 0
09:36:46 <zeloran> simplify x = x
09:37:19 <zeloran> so if a Product-Expression starts with 0 it should be simplifyd
09:37:33 <zeloran> this works, but only if the 0 is the first element in the list
09:37:43 <zeloran> anyway todo thi for all elements of the list?
09:38:03 <faxathisia> simplify (Prod things) | there is a Constant 0 in things = Con 0
09:38:08 <faxathisia> Maybe you can do this way?
09:38:16 <zeloran> yes
09:38:24 <zeloran> how to do?
09:38:25 <byorgey> @type elem
09:38:26 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:38:35 <vincenz> two problems faxathisia
09:38:37 <vincenz> first of all
09:38:39 <opqdonut> > 0 `elem` [1,2,3,0,5,6]
09:38:40 <vincenz> simplify should be buttom up
09:38:40 <lambdabot>  True
09:38:45 <vincenz> bottom even
09:39:03 <byorgey> zeloran: and you'll also want to add an Eq to your deriving clause.
09:39:04 <vincenz> meaning you'd need to simplify the elements of Prod first, before testing whether there's a constant 0
09:39:09 <vincenz> secondly, wait, there's no secondly
09:39:12 <opqdonut> yeah, if one of the terms in a product simplifies to zero you want the prod to be zero
09:39:44 <quicksilver> the problem with Show is that we have multiple specifications for it
09:39:56 <quicksilver> (*) Show is for debugging it should be human readable
09:40:04 <zeloran> yes opqdonut
09:40:08 <quicksilver> (*) the details of show don't matter as long as read . show is id
09:40:09 <zeloran> how do i do this?
09:40:23 <quicksilver> (*) show should produce valid haskell code which can be copy-pasted into a haskell file
09:40:37 <quicksilver> these three are not always perfectly aligned
09:40:58 <opqdonut> zeloran: simplify (Prod xs) = doSomething (map simplify xs) -- for example
09:41:00 <luqui> might be worth splitting them up...
09:41:16 <opqdonut> where doSomething then checks for zero
09:41:35 <quicksilver> I think that haskell debuggers/REPLs should be prepared to do their own data inspection
09:41:51 <quicksilver> but this is in conflict with the way they're currently implemented, I think
09:42:03 <EvilTerran> @src show
09:42:03 <lambdabot> show x = shows x ""
09:42:09 <EvilTerran> @src shows
09:42:10 <lambdabot> Source not found. :(
09:42:10 <quicksilver> in particular, ghci used to work over compiled code, and the information wasn't even there
09:42:16 <quicksilver> and it still runs on compiled code
09:42:20 <quicksilver> optionally
09:42:42 <quicksilver> (but you could have an equivalent of "compiling with -g")
09:44:31 <byorgey> anyone else who can explain to faxathisia why having a Show instance for functions (which actually showed the implementation) would break referential transparency?
09:44:43 <byorgey> I know I've seen it explained before, I just can't remember how the argument goes
09:44:51 <faxathisia> I would just like to see the types
09:44:59 <faxathisia> <<function Int -> Sheep >>
09:45:01 <byorgey> faxathisia: oh!  well, that's possible =)
09:45:02 <faxathisia> or somthing
09:45:10 <byorgey> http://hpaste.org/2814
09:45:16 <byorgey> how about that?
09:45:26 <faxathisia> cool thanks!
09:45:36 <zeloran> what is "doSomething" @ donut
09:45:46 <byorgey> I just found that while googling to try to answer what I thought your question was =)
09:45:58 <EvilTerran> would instance Typeable (a -> b) => Show (a -> b) work, too?
09:46:13 <EvilTerran> seems more self-documenting, if it does...
09:46:50 <faxathisia> EvilTerran: with -fglasgow-exts -fallow-undecidable-instances
09:46:50 <byorgey> no idea.  I assume there is an instance (Typeable a, Typeable b) => Typeable (a -> b) ?   then it should work, I guess...
09:46:54 <faxathisia> *Main> (1+)
09:46:54 <faxathisia> *** Exception: stack overflow
09:47:25 <EvilTerran> never mind, put it back ;)
09:47:38 <byorgey> hehe
09:52:55 <puusorsa> any idea when ghc 6.8 would be a good idea_
09:53:38 <quicksilver> byorgey: it doesn't break r.t.
09:53:40 <hpaste>  vvv annotated "`otherwise' as case pattern" with "no more problems with `otherwise'" at http://hpaste.org/3519#a3
09:53:50 <quicksilver> byorgey: but it does break the invariants of Show
09:54:00 <quicksilver> byorgey: which I was trying to argue is becaue Show is a bit too overloaded
09:54:16 <faxathisia> > let f (x,y) = (x+y,y) ; g (x,y) = (x,y+y) in map (($(1,1)) . appEndo . mconcat . map Endo) $ replicateM 2 [f,g]
09:54:18 <byorgey> quicksilver: oh, I agree with that.
09:54:18 <lambdabot>  [(3,1),(3,2),(2,2),(1,4)]
09:54:53 <faxathisia> > let f (x,y) = (x+y,y) ; g (x,y) = (x,y+y) in map (\f -> f (1,1)) $ map (foldl1 (.)) $ replicateM 2 [eucF,eucG]
09:54:54 <lambdabot>   Not in scope: `eucG'
09:54:55 <byorgey> quicksilver: hmm, really?  I was sure that I saw someone explain how it would break r.t. once... perhaps I am mistaken.
09:54:58 <faxathisia> aw
09:55:10 <faxathisia> I think I found another way though: map (foldl1 (.))
09:55:30 <byorgey> faxathisia: yup.  that's one of the "less obfuscated ways" I referred to =)
09:55:56 <doserj> byorgey, quicksilver: should "let f x = 1+1 in show f" give the same result as "let f x = 2 in show f"?
09:56:13 <quicksilver> ah well
09:56:15 <doserj> referential transparency says it should
09:56:24 <quicksilver> it would break r.t. if you implement it to return the actual source code, yes
09:56:33 <quicksilver> but not if it just returns "Int -> Int"
09:56:36 <byorgey> doserj: ah, there we go!
09:56:38 <quicksilver> or "<<function>>"
09:56:41 <byorgey> quicksilver: yes, that's what I was referring to
09:56:45 <quicksilver> which is what I thought we were discussion :)P
09:57:15 <quicksilver> it also breaks r.t. if you define it to return "<<anon function defined at line 342 of Foo.hs>>"
09:57:21 <quicksilver> which is what some other languages do in their debuggers
09:57:38 <byorgey> quicksilver: well, it turns out you're right, that IS what we were discussing, but I thought faxathisia actually wanted a show instance that would display source code.
09:57:39 <quicksilver> IF you think of it purely as a debugging tool, that doesn't matter much though
09:57:53 <byorgey> quicksilver: right.
09:57:54 <faxathisia> I see now though
09:59:09 <Rebooted> i think you have to keep functions opaque really unless you have proper eta expansion
09:59:25 <Rebooted> in which case those functions would be recognised as equal
09:59:40 <Rebooted> and shown as the same thing, i *think*
10:00:22 <hpaste>  Rebooted pasted "IO code" at http://hpaste.org/3520
10:00:36 <Rebooted> can anyone help me with that
10:00:53 <Rebooted> i want to try refactor it to use a stream of actions and sequence
10:01:03 <Rebooted> but i can't figure out how to do it, or if it's possible
10:01:17 <quicksilver> you can't
10:01:22 <Rebooted> right
10:01:28 <quicksilver> sequence is for when earlier actions don't influence later ones
10:01:36 <quicksilver> if you're using "<-" to influence later actions
10:01:43 <quicksilver> it's not applicative style any more
10:02:13 <Rebooted> ok, thanks
10:02:17 <hpaste>  faxathisia pasted "infinities" at http://hpaste.org/3521
10:02:29 <faxathisia> here is my code then :)
10:03:38 <faxathisia> I think I can prove that x and y have GCD 1 in (x,y) in fracs by euclidean algorithm
10:04:05 <luqui> faxathisia, http://svn.luqui.org/svn/misc/luke/work/code/haskell/bfm.hs
10:04:07 <Rebooted> quicksilver: if IO was comonadic, do you think it could be done then?
10:04:14 <luqui> a "list monad" which does diagonal iteration...
10:06:12 <faxathisia> that's really nice
10:06:22 <faxathisia> it sort of makes sense
10:07:01 <faxathisia> What do {}'s mean in newtype?
10:07:16 <luqui> faxathisia, same as in data
10:07:21 <luqui> record naming
10:07:40 <luqui> newtype Foo = { foo :: Int }    ;  foo (Foo 42)  ==> 42
10:08:16 <Rebooted> just an inkling
10:08:27 <luqui> er.. newtype Foo = Foo { foo :: Int }
10:08:59 <_ry> where can i get the documentation for Num class? (like what I must implement and such)
10:09:26 <mauke> @where report
10:09:26 <lambdabot> http://www.haskell.org/onlinereport/
10:09:55 <luqui> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#7
10:09:56 <mauke> @docs Prelude
10:09:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
10:09:58 <lambdabot> http://tinyurl.com/y4wexy
10:10:05 <Rebooted> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3ANum
10:10:07 <lambdabot> http://tinyurl.com/ovjef
10:11:00 <luqui> that was... a lot of links
10:11:29 <faxathisia> what is tinyurl for?
10:11:37 <quicksilver> to make a long url... tiny!;2~
10:11:41 <faxathisia> haha
10:11:46 <byorgey> faxathisia: also, if you're just interested in generating a list of all rationals, see http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/rationals.pdf
10:11:48 <lambdabot> http://tinyurl.com/3dj4lx
10:11:50 <quicksilver> easier to copy and paste
10:12:08 <faxathisia> byorgey: cool thanks
10:13:45 <matthew-_> does -main-is take path/to.hs or module.name or module.name.func ?
10:14:07 <dons> ?seen ibid
10:14:08 <lambdabot> ibid is in #haskell. I don't know when ibid last spoke.
10:15:19 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#id3125904
10:15:20 <lambdabot> Title: 4.10. Options related to a particular phase, http://tinyurl.com/smq5n
10:18:03 <matthew-_> tnx mauke
10:18:34 <matthew-_> Setup.lhs: binary.cabal:22: Invalid syntax (no colon after field name)
10:18:56 <matthew-_> so data.binary 0.4.1 is being prepared for ghc 6.8 then I assume.
10:18:58 <matthew-_> back to 0.3
10:28:37 <shapr> @yow !
10:28:37 <lambdabot> Psychoanalysis??  I thought this was a nude rap session!!!
10:28:50 <mauke> @yow!
10:28:50 <lambdabot> I wish I was on a Cincinnati street corner holding a clean dog!
10:28:53 <phlpp> hi!
10:29:12 <shapr> hiya phlpp
10:29:14 <shapr> how's code?
10:30:59 <dons> matthew-_: hmm, no, you need a new cabal
10:31:29 <dons> other than that it should work find with 6.6
10:32:06 <phlpp> shapr: ah, there wasn't much code like a week ago :?
10:32:08 <phlpp> :/
10:32:18 <phlpp> but, i'm feeling fine.
10:32:32 <phlpp> forget about that 'feeling' :>
10:34:10 <matthew-_> dons: yeah, but that's not going to happen
10:34:25 <matthew-_> dons: I need to make code work with a basic 6.6 install
10:34:47 <matthew-_> dons: does binary not work at all with hugs? I'm getting syntax errors...
10:34:56 <dons> ok. 0.3 should be fine
10:35:05 <dons> it should work with hugs
10:35:12 <dons> at least 0.2 did.
10:35:13 <matthew-_> without compilation?
10:35:21 <matthew-_> ERROR "./Data/Binary/Builder.hs":19 - Syntax error in input (unexpected selector "#if")
10:35:24 <dons> you still need to instal with hugs
10:35:28 <dons> sorry, cabal
10:35:28 <matthew-_> drat
10:35:37 <dons> that's a missing cpp flag
10:35:49 <dons> so install as per usual, or find the missing flags to hugs
10:35:59 <dons> note that performance sucks in hugs :)
10:36:19 <matthew-_> yeah, I don't care about performance
10:36:27 <matthew-_> ...for this project ;)
10:36:32 <dons> why hugs, may i ask?
10:36:38 <dons> is it for uni?
10:37:23 <matthew-_> ok, so to keep the first year students exciting, I'm running a competition. I'm getting them to write bots for whist. Now I've been trying to ween them off hugs, but I think some may still prefer it
10:37:37 <matthew-_> so it would be ideal if I could make my code happy in hugs and ghc
10:38:04 <matthew-_> s/ween/wean/
10:38:28 <hpaste>  raedwald pasted "profil.py" at http://hpaste.org/3523
10:38:28 <ricky_clarkson> The subtle difference between exciting and excited..
10:38:31 <faxathisia> Why do they prefer hug?
10:38:41 <faxathisia> matthew-_
10:38:52 <matthew-_> they don't. it's just the lecturer who teaches the main course teaches in hugs
10:39:00 <ndm> compilation times 1000 times faster does it for me :)
10:39:05 <matthew-_> I've been doing an optional course and I've been using ghc
10:39:13 <faxathisia> is there a lot of hugs specific stuff in the course? :|
10:39:21 <matthew-_> yeah, unless you're on a 386, compilation time ain't an issue for me
10:39:36 <matthew-_> no, nothing is specific to either, and it would be nice to keep it that way
10:39:37 <ndm> Yhc is 200 modules larger
10:39:44 <quicksilver> matthew-_: not an issue is a bit far
10:39:44 <phlpp> hm
10:39:47 <ndm> compilation time is significant, as in 5 mins
10:39:56 <phlpp> i wish we could have 36h days
10:39:59 <quicksilver> matthew-_: takes over a minute to compile my current app on a dual core
10:40:03 <quicksilver> matthew-_: that's enough to annoy me
10:40:06 <dons> matthew-_: yeah, so binary should work in both
10:40:09 <mrd> phlpp: work on slowing down the Earth
10:40:12 <matthew-_> they're first years. They don't care about GADTs or any other advanced hackery that's only possible in ghc
10:40:13 <phlpp> i mean, time for work etc. doesn't change, but the rest of the time would be spare time
10:40:20 <quicksilver> ndm: hugs isn't 1000 times faster than ghci though, is it?
10:40:24 <phlpp> mrd: please do so then
10:40:27 <quicksilver> ndm: ghc is slow but ghci seems pretty fast to me
10:40:29 <phlpp> :)
10:40:34 <mrd> phlpp: I have the Moon working on it
10:40:35 <ndm> quicksilver: no, 100 times is perfectly realistic though
10:40:42 <dons> ghci is fastter, at runtime, yes.
10:40:50 <matthew-_> dons: right, but I'm not going to be able to install binary under hugs on the lab machines in time
10:40:55 <dons> something like 20x slower than ghc code, versus 30 for hugs
10:40:56 <phlpp> mrd: hehe. it's really annoying that only some days in the week i can spend my time with haskell :(
10:40:59 <matthew-_> so I was just going to give them the source
10:41:10 <ndm> teach them how to use cabal :)
10:41:12 <mrd> phlpp: it's being really slow about it, but it's old and I can't fire it
10:41:13 <matthew-_> and thus I was hoping it would "just work" in the interpreters
10:41:15 <dons> matthew-_: then they'll need the cpp flags
10:41:20 <dons> or else --user
10:41:32 <matthew-_> ndm: nope, they're not going to care about that. cabal isn't a minefield I want them to cross right now.
10:41:49 <matthew-_> ok, I'll figure out the cpp flags
10:42:13 <matthew-_> why does it "just work" with ghc then without the cpp flags?
10:42:27 <dons> it uses cabal, doesn't it?
10:42:51 <dons> oh, ghc respects the LANGUAGE pragmas
10:43:05 <hpaste>  SaMBuCa_ pasted "php thumbs visual" at http://hpaste.org/3524
10:43:11 <dons> spam eh?
10:43:47 <matthew-_> right.
10:44:09 <SaMBuCa_> me?
10:44:45 <dons> SaMBuCa_: oh, right.
10:44:57 <mauke> lenght is misspelled
10:45:30 <SaMBuCa_> what i've done?
10:47:51 <jfredett> roconnor, isn't e = sum 1/n from n = 0 to infinity? I don't think you need all that 1/e business.
10:48:06 <jfredett> oh shoot, my window was scrolled back
10:48:11 <jfredett> that convo was over like- days ago
10:48:12 <jfredett> :/
10:48:33 <jfredett> nevermind
10:48:35 <shapr> jfredett: #haskell has a long memory, you can always jump into the continuation, right?
10:48:41 <byorgey> jfredett: no, e = sum 1/n! from n = 0 to infinity
10:48:52 <jfredett> thats what I mean
10:48:58 <jfredett> i missed an exclamation point
10:49:00 <jfredett> meant*
10:49:01 <byorgey> jfredett: ok =)
10:49:07 <jfredett> i'm missing letters everywhere today
10:49:08 <jfredett> :/
10:49:31 <byorgey> jfredett: as wli explained to me, using the series for 1/e means you get better upper + lower bounds, since it's alternating
10:49:49 <jfredett> i suppose
10:49:51 <byorgey> if you just use the 1/n! series for e, you can get lower bounds, but it's difficult to get good upper bounds
10:50:01 <jfredett> but I'm a mathematician, so I couldn't care less about numbers. :)
10:50:17 <jfredett> we just call it e, :)
10:50:28 <jfredett> byorgey: makes sense
10:51:25 <jfredett> anywho- back to work
10:51:49 * mrd wonders if there are an uncountable number of irrationals
10:51:55 <mrd> irrational people, that is
10:52:16 <ricky_clarkson> There are approximately 5 million Java programmers.
10:52:48 <jfredett> but certainly that only constitutes a subset of the set of irrational people
10:53:05 <jfredett> I suppose though- it must be countable, since the set of all people is finite.
10:53:29 <alar> how can I find maintainer of Network.HTTP & Network.Browser modules? E-mail says "no such address"
10:53:42 <dons> alar: who's the maintainer?
10:53:44 <jfredett> alar: hitmen are always a good option
10:53:50 <dons> isn't it libraries@haskell.org?
10:53:59 <dons> or is it bjorn?
10:54:09 <shapr> It's bjorn
10:54:12 <shapr> Last I checked, at least.
10:54:18 * shapr looks
10:54:33 <EvilTerran> why do you need to contact him, alar?
10:54:44 <dons> yeah http-3000-to-the-max.tar.gz looks like bringert package :)
10:54:45 <alar> oinutter@hotmail.com
10:54:48 <dons> hmm
10:54:52 <alar> Author is Warrick Gray
10:54:56 * shapr laughs
10:55:01 <dons> oh, old old version, alar
10:55:10 <dons> grab http-3000 off hackage.haskell.org
10:55:18 <alar> ok
10:55:20 <alar> thanks
10:57:39 <nominolo> dons: xmonad-0.4 doesn't build with ghc 6.8
10:57:58 <nominolo> the 'containers-0.1' dependency is missing
10:58:11 <nominolo> (so it's just the .cabal)
10:58:13 * alar thinks RequestMethod lacks Read instance
10:58:23 <puusorsa> thanks, i was wondering if i should install 6.8 or wait
10:59:19 <dons> nominolo: right. see the faq :)
10:59:26 <dons> we're waiting on the release before we update
10:59:49 <newsham> seems to be a general problem -- with every new release of ghc, package cabals need to be updated.
11:00:05 <puusorsa> isn't there new version of cabal too
11:00:10 <newsham> also vice versa, lots of new packages dont work with slightly older ghc versions because package juggling
11:00:10 <dons> that should be somewhat alleviated by the new cabal
11:01:20 <nominolo> newsham: with cabal 1.2.1 this should become easier
11:01:22 <newsham> what does the new cabal do?
11:01:27 <newsham> conditionals in the cabal file?
11:01:31 <nominolo> yep
11:01:57 <nominolo> for example: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install-0.4.0
11:01:58 <newsham> inelegant, but pragmatic I guess.
11:01:59 <lambdabot> http://tinyurl.com/yss6oz
11:02:29 <newsham> otherwise competent C programmers tend to turn into idiots when given the option of #ifdef.
11:02:36 <newsham> lets hope Haskell programmers are better
11:02:47 <faxathisia> newsham: What do you mean?
11:03:26 <newsham> fax: people dont abstract out non-portabilities as much as they should, leaving a jumble of speghetti code which is fragile and subtly broken on some systems
11:03:58 <psykon> everyone loves a good spaghetti
11:04:00 <psykon> :)
11:04:18 <dons> at least they're conditonals at the package level
11:04:21 * nominolo prefers gniocchi
11:04:27 <dons> not the symbol or expression level...
11:04:33 <newsham> dons: *nod* yah, hopefully very few will be required
11:04:39 <dons> right.
11:04:47 <dons> dcoutts: around?
11:04:55 <newsham> I just hope that people who write new packages will allow them to run on versions of ghc one or two generations old
11:04:58 <dons> i think we need a head branch of X11 too :)
11:05:02 <nominolo> just document the right way on the wiki and hardly anyone will try differently
11:05:10 <dons> yep
11:05:44 <nominolo> newsham: ideally that could be tested by hackage
11:05:54 <newsham> nominolo: excellent idea.
11:06:17 <nominolo> it does already to some degree
11:07:18 <newsham> i'm aware of the hackage web page which is very useful... but was wondering if there is more to it than that?  are the scripts that interact with hackage remotely?  auto find and fetch dependencies?
11:07:25 <dcoutts_> dons: just back from teaching Haskell to youngsters :-)
11:07:26 <newsham> s/the/there/
11:07:40 <dons> dcoutts_: i'm doing the same head/stable split for the X11 package now
11:07:41 <newsham> dcoutts: awesome.  what kinda stuff?
11:07:48 <nominolo> newsham: yep, cabal-install
11:07:55 <dons> since its a extra lib, the head lives on darcs.haskell.org/X11, right?
11:07:55 <newsham> I always thought the "two dozen lessons" intro was perfect for school kids
11:07:59 <dons> and stable in package/X11
11:08:10 <nominolo> newsham: $ cabal install xmonad works like a charm (on 6.6.1)
11:08:10 <dcoutts_> dons: that's fine yes
11:08:12 <newsham> nominolo: where is that stuff documented?
11:08:15 <faxathisia> I wish I had haskell classes :p
11:08:21 <faxathisia> Seems like everyone does
11:08:40 <dcoutts_> dons: since it's an extra rather than core lib, I don't see that it must live on darcs.h.o, but certainly it can if you like
11:08:42 <newsham> fax: I am also similarly  deprived.
11:08:58 <faxathisia> ah well all the best stuff I learned myself :0
11:09:20 <dcoutts_> newsham: the first practical is a bit of recursion and factoring numbers, the second practical we start next week is much more cool :-)
11:09:21 <newsham> dcoutts: wrote up a tiny (special-cased) png generator.  just does 1-bit monochrome.
11:09:31 <dcoutts_> newsham: oh nice
11:09:53 <nominolo> newsham: http://hackage.haskell.org/trac/hackage/wiki/HackageDB <-- there's a link to the source
11:09:54 <lambdabot> Title: HackageDB - Hackage - Trac
11:10:01 <newsham> its not as complicated as I had first thought, although it does have a dependency on zlib (so if you had to write everything from scratch, it wouldnt be that easy)
11:10:13 <newsham> nom: "rtfs"? :)
11:10:22 <dcoutts_> newsham: I'm glad my zlib package is useful :-)
11:10:42 <EvilTerran> dcoutts_, are you doing the L-systems again this year?
11:10:47 <nominolo> in advanced functional programming we had to write our own turtle-graphics DSL and a backtracking monad
11:10:47 <dcoutts_> EvilTerran: yep
11:10:49 <newsham> dcoutts: yes, definitely, although I had to try three (starting with the most recent) before I found one that didnt require me to upgrade my cabal.
11:10:57 <EvilTerran> that one was pretty fun
11:11:01 <dcoutts_> EvilTerran: though this time with more OpenGL bling since we've got nicer computers now
11:11:10 <EvilTerran> :D
11:11:24 <dcoutts_> newsham: upgrading Cabal is good for you ;-)
11:12:01 <newsham> dcoutts: yah, well on this particular system my ghc is only half-functional anyway (freebsd/amd64) so I've been putting off doing substantial work on installing packages as much as possible waiting for a new fixed version.
11:12:44 <newsham> no ghci/runhaskell.  compilation works though.
11:13:27 <yitz> dcoutts_: sorry didn't get a chance to answer you on cafe about the zlib API. I meant that what ever is the idiom - types, classes, whatever - for one should be the same for all.
11:13:55 <dcoutts_> yitz: aye, we should be able to use them together nicely
11:14:20 <dcoutts_> yitz: in my opinion we should try to make them simple functions on sensible data types
11:14:28 <yitz> makes sense
11:14:45 <dcoutts_> since we already have excellent support for composing functions :-)
11:14:46 <yitz> should work for String, various ByteString, etc.
11:15:10 <yitz> Also, we should be careful to be consistent about laziness.
11:15:28 <dcoutts_> yitz: though I think one has to be a bit careful about trying to generalise too much since a String is not the same thing as a ByteString when we're talking about encoding etc
11:15:58 <yitz> Well, OK, that's the point. The solution should be the same for all kinds of codecs.
11:16:03 <dcoutts_> yitz: and it's just one function call to convert a ByteString into [Word8] so do we really need that much generalisation just to save one function call?
11:16:17 <yitz> Maybe not. But the same for all.
11:17:44 <yitz> Problem is, unicode codecs will be used more often with stringy things, whereas you may see Word8s more often with binary stuff.
11:18:09 <dcoutts_> indeed, and Word8 stuff is really different from Char stufff
11:18:14 <yitz> So that's why if you just pick one function, it tends to be a different one for various cases.
11:18:32 <dcoutts_> encoding/decoding converts between Unicode representations and byte representations
11:18:52 <yitz> So is there something we can do that feels right for everything, or that varies in a way that people will just assume?
11:18:58 <dcoutts_> yitz: I'm not so sure, for different cases you'd pick different compositions of functions
11:19:01 <newsham> stringCodec codec xs = map (toEnum.fromEnum) (B.unpack (codec (B.pack (map (toEnum.fromEnum) xs)))))
11:19:07 <yitz> yuck
11:19:12 <newsham> stringCodec compress "testing"
11:19:28 <faxathisia> :t (toEnum.fromEnum)
11:19:29 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
11:19:43 <newsham> fax: converting from Word8 to Char and back
11:20:06 * dcoutts_ isn't sure what this proves
11:20:24 <newsham> dont need a bunch of "String" versions of all the codecs
11:20:27 <newsham> just one lifting function
11:21:43 <twanvl> stringCodec codec = P.unpack . P.decode . codec . P.encode . P.pack  -- where P is a packed string type
11:22:05 <newsham> ooh, P.decode and P.encode do the [Char] -> [Word8] bit?
11:22:31 <newsham> *fixes his code*
11:23:02 <twanvl> encode/decode :: PackedString <-> ByteString;  pack/unpack :: String <-> PackedString
11:23:12 <twanvl> for some PackedString type that doesn't exist yet
11:23:17 <dcoutts_> yes
11:23:17 <newsham> oh
11:23:30 <dcoutts_> yes, I like that.
11:23:45 <dcoutts_> it's simple. Different compositions give you all the conversions.
11:24:40 <yitz> Without too many compositions...
11:24:48 <dcoutts_> (P.unpack . P.decode) is so simple, it's not clear we need trivial wrappers like stringCodec
11:25:03 <dcoutts_> yitz: there's nothing wrong with compositions
11:25:03 <twanvl> and where I said "doesn't exist yet", I meant "actually mostly does exist as Data.CompactString"
11:25:41 <yitz> No, but it is just not intuitive that you would need a whole multi-line chain of them every time you want to read or write something.
11:26:01 <dcoutts_> it's pretty explicit, it says what you're doing
11:26:11 <newsham> String codec is going to be the most often used function next to ByteString codec
11:26:18 <newsham> why not make the common case simple?
11:26:19 <dcoutts_> if some are very very common then one might want names for special cases
11:26:45 <twanvl> Also, this example is quite wrong, you are for example zipping a UTF-8 representation of a string, and trying to interpret the result as UTF-8 again
11:26:49 <dataangel> What would you call haskell's parameter passing mechanism? "Call by thunk"? ;p
11:27:15 <dcoutts_> dataangel: lazy evaluation
11:27:19 <newsham> call-by-name?
11:27:23 <faxathisia> call by need isn't it?
11:27:30 <faxathisia> although It could be slightly different..
11:28:34 <dataangel> dcoutts: A language can be eagerly evaluated but not call-by-value can't it? So it seems a language should be able to be lazily evaluated but have a different calling mechanism
11:28:53 <dcoutts_> dataangel: I don't think so
11:29:17 <newsham> http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_name and following "call by need"
11:29:22 <newsham> look appropriate
11:30:47 <yitz> How about: "codec (Utf8 :> Utf16 :> Gzip) inp" where codec is appropriately polymorphic
11:31:20 <yitz> Or maybe a monad
11:31:24 * yitz ducks
11:31:37 <twanvl> What is the point?
11:32:03 <dons> dcoutts_: can you do a test build (not install) of darcs.haskell.org/X11
11:32:21 <luqui> can someone show me a semantic difference between newtype A a = A a and data B b = B b ?
11:32:22 <dons> anyone else too, this is the merged X11-extras/X11 package
11:32:34 <dcoutts_> ah, cool
11:32:41 * dcoutts_ darcs gets
11:32:56 <dons> http://haskell.org/haskellwiki/Newtype
11:32:58 <lambdabot> Title: Newtype - HaskellWiki
11:33:07 <dcoutts_> dons: cd /srv/darcs/X11 && darcs optimize --checkpoing :-)
11:33:09 <Saizan> luqui: case undefined of A _ -> 1 === 1, case undefined of B _ -> 1 === undefined
11:33:36 <yitz> It is silly to have a separate function for every (input,output) pair. You just want to specify the steps along the way and let the correct transformers be chosen automatically. The choice between String, ByteString, Word8 should just come through polymorphism, without having to specify them.
11:33:42 <dons> dcoutts_: done.
11:34:11 <dcoutts_> yitz: it would be silly to have one for every pair, but we don't. Only m pairs, not n*m pairs.
11:34:33 <luqui> Saizan, thanks.  I had heard it differed in strictness, but now I can see it :-)
11:34:45 <yitz> dcoutts_: why?
11:34:59 <dcoutts_> yitz: and I'm not sure I agree about having it be chosen automatically, the difference between String and ByteString is not irrelevant, it's important.
11:35:08 <twanvl> while ByteString and [Word8] are roughly the same, String is completely different
11:35:18 <ski> luqui : also compare with `data C c = C !c'
11:35:27 <twanvl> The only functions that are unimportant are pack and unpack
11:35:27 <yitz> Of course, but you get it from the usage context (or specify ::ByteString)
11:36:11 <dcoutts_> yitz: we're not proposing a function for doing utf8 encodings,  [Char] -> ByteString just one for [Char] -> [Word8] and another for [Word8] -> ByteString and you get the one you want by composing the other two
11:36:30 <dcoutts_> yitz: but it means something quite different when you get different types
11:36:41 <dcoutts_> it means you're doing an encoding or decoding
11:36:50 <dcoutts_> not just a change of representation
11:37:05 <dcoutts_> that should be explicit
11:37:17 <dcoutts_> decode . unpack
11:37:28 <dcoutts_> quite different from just unpack
11:37:31 <yitz> I am suggesting that the two are orthogonal
11:37:57 <dcoutts_> dons: Xinerama.hsc:11:31:  X11_extras_config.h: No such file or directory
11:37:58 <roconnor> ski: there is some difference between data C c = C !c and a newtype that involves pattern-matching... but I forget.
11:38:14 <dcoutts_> dons: X11_extras_config.h is not in the repo
11:38:28 <yitz> unpack = codec ID :: Word8 -> String
11:38:56 <dons> dcoutts_: autoreconf
11:39:03 <dcoutts_> dons: ta
11:39:17 <yitz> pack = codec ID :: String -> [Word8]
11:39:36 <twanvl> yitz: What encoding does that use? UTF-8? UTF-16? ASCII? EBCDIC?
11:39:52 <dcoutts_> yes, that's the other important question
11:40:15 <dcoutts_> having that implicit in the type is a bit scary
11:40:42 <yitz> No, never mind "ID", unless that makes sense. You specify it.
11:40:56 <yitz> Only the type is implicit in the type.
11:42:01 <dcoutts_> so you're specifying the encoding with an explicit type annotation, why not just specify it with a function name or function parameter?
11:42:16 <dcoutts_> decode utf8 . unpack . decompress
11:43:02 <yitz> What does "decompress" mean? arj? rar? compress? bzip2?
11:43:18 <yitz> Seems that an ADT is natural here to specify that.
11:43:37 <twanvl> unpack . decode utf8 . Zlib.decompress -- for a ByteString -> PackedString decode function
11:44:38 <dcoutts_> import 	Codec.Compression.GZip
11:44:38 <dcoutts_>  decode utf8 . unpack . GZip.decompress
11:44:44 <dcoutts_> erm
11:44:49 <dcoutts_> import 	Codec.Compression.GZip as GZip :-)
11:45:15 <dcoutts_> it's all nicely explicit and we can build any pipeline we want pretty easily
11:45:58 <yitz> what is the type of decode and what is the type of utf8?
11:46:16 <dcoutts_> utf8 :: Codec :-)
11:46:20 <newsham> class ByteStringPackable [Char] where
11:46:30 <newsham> err instance
11:46:36 <newsham>     fromBS = ...
11:46:37 <twanvl> a Char is not Byte!
11:46:40 <newsham>    toBS = ...
11:46:59 <dcoutts_> decode :: Codec -> [Word8] -> [Char]
11:46:59 <newsham> twanvl: it is when I "putStr" it
11:47:14 <twanvl> Then that is a bug
11:47:16 <dcoutts_> newsham: that's only because it's wrong broken and bad :-)
11:47:26 <newsham> runCodec codec = fromBS . codec . toBS
11:47:29 <newsham> polymorphism
11:48:02 <dcoutts_> newsham: that only makes sense if your codec is [Word8] -> [Word8]
11:48:18 <newsham> true.
11:48:19 <dcoutts_> which fits a few, like compression etc
11:48:25 <dcoutts_> but not string encoding decoding
11:48:39 <yitz> Also some string codecs
11:48:42 <newsham> yitz: the type of utf8 is [Word8]
11:48:49 <yitz> There are all kinds of things
11:49:05 <dcoutts_> yitz: presumably they would be [Char] -> [Char] though
11:49:17 <yitz> You don't want to set it in stone, but you also don't want it to be too confusing.
11:49:22 <dcoutts_> newsham: not in my example it wasn't
11:49:24 <newsham> as long as IO is in terms of [Char], I think its fair for programmers to be expecting to use [Char] to do IO
11:49:58 <yitz> we want to get away from that, but still need to support it. another complexity.
11:50:00 <dcoutts_> newsham: they have to accept there is an implicit encoding/decoding going on if they do IO in terms of Char
11:50:09 <twanvl> We need both [Char]/PackedString IO and binary [Word8]/ByteString IO
11:50:16 <dcoutts_> yes we do
11:50:40 <newsham> actually there should only be [Word8] IO
11:50:40 <dcoutts_> newsham: and the default encoding/decoding for text IO probably should be the locale not latin1
11:50:44 <newsham> and the rest should be built on top of that
11:50:47 <dcoutts_> newsham: right
11:50:51 <yitz> String/PackedString uses the system codec implicitly?
11:50:58 <twanvl> It can't be built on top of it
11:51:17 <dcoutts_> newsham: and to support the old IO api that does not specify an encoding we pick a sensible default, like utf8 or the locale
11:51:31 <newsham> twanvl: utf-8 is [Word8], utf-16-le is [Word8], utf-16-be is [Word8], etc..
11:51:36 <twanvl> The operating system has many functions that take a string
11:51:45 <twanvl> (in some encoding)
11:51:55 <newsham> ahh, yes, some OS's have unicode string APIs for IO.
11:52:13 <newsham> like taking a unicode path string
11:52:21 <twanvl> Most OSs do
11:52:41 <newsham> linux/bsd/etc.. dont do any special unicode IO do they?
11:52:50 <dcoutts_> no
11:52:50 <twanvl> it is UTF-8 I think
11:52:50 <newsham> ie. paths are 8-bit char strings
11:53:12 <newsham> they dont interpret the paths as utf-8
11:53:22 <newsham> the fact that you can put utf-8 paths in is just the flexibility of the utf-8 encoding
11:53:28 <dcoutts_> twanvl: it's whatever, that's the problem. The convention is to use the current locale encoding for text files, which is usually utf8
11:53:41 <dcoutts_> and unix paths are not unicode, they're uninterpreted binary
11:53:44 <yitz> dcoutts_: no assumptions
11:53:45 <newsham> you could just as easily put in a malformed utf-8 string
11:53:56 <newsham> dcoutts: they are interpreted (re: "/" characters)
11:54:05 <dcoutts_> yes, that's the only interpretation
11:54:32 <newsham> if you had a utf-8 string with "/" as a constituent, it would still take that "/" as "/" not part of a larger character
11:54:35 <yitz> Ah, another issue: the standard API should handle illegal sequence exceptions in a uniform way.
11:54:42 <dcoutts_> yitz: certainly we cannot assume the locale is utf8,  one has to check
11:54:44 <newsham> (actually thats not possible is it?)
11:54:51 <newsham> moot point
11:55:07 <dcoutts_> yitz: when it's done implicitly in readFile it should just be another IO exception
11:55:21 <yitz> no, no, bad.
11:55:25 <dcoutts_> yitz: in pure conversion functions there are other ways of handling conversion errors.
11:55:41 <dcoutts_> if you want to handle them explicitly then do not use readFile
11:56:16 <yitz> this is getting really messy. I pity beginners trying to learn this. And I guarantee it will be a source of bugs even for gurus.
11:56:47 <dcoutts_> yitz: readFile is only a convenience api, it should be defined in terms of binary IO and pure decoding functions
11:57:17 <yitz> In general, codec functions are not pure.
11:57:46 <dcoutts_> doesn't matter, most are, the ones that are not are just less convenient
11:57:49 <yitz> They are often stateful, as well as not complete
11:58:08 <yitz> not true at all. how about ccjk?
11:58:08 <conal> yitz: *internally* stateful?
11:58:09 <dcoutts_> then if you want to deal with conversion errors explicitly then you'd do the binary IO and decode using a function that gives you control over conversion errors
11:58:24 <dcoutts_> yitz: it's a pure conversion on streams of data
11:58:38 <dcoutts_> even the stateful string encodings
11:59:10 <newsham> putStrLn $ encodeUtf8 ....
11:59:25 <newsham> python has a rich set of encoders and decoders.. it basically works like that
11:59:38 <dcoutts_> right, and that's what we should do too
11:59:41 <newsham> print u"unicode string here".encode('utf-8')
11:59:46 <dcoutts_> but distinguishing strings and binary data
12:00:00 <yitz> internally stateful, but the state sometimes needs to be kept for a while...
12:00:03 <twanvl> putStrLn should take a string
12:00:09 <newsham> ustr = utf8str.decode('utf-8')
12:00:38 <dcoutts_> twanvl: aye, it should be defined in terms of a binary put and the default locale string encoding
12:00:48 <twanvl> yes
12:01:43 <newsham> you know whats weird?  unicode has Ｗｉｄｅ Ｃｈａｒａｃｔｅｒ variants of the ascii character set
12:01:59 <dcoutts_> yitz: yes, that doesn't fit so easily, but it's still pure, you might just want to pass in the starting state of the encoder and get out the end state, so you can stitch several chunks together.
12:02:25 <dcoutts_> yitz: but doing that would be pretty uncommon
12:02:26 <yitz> right.
12:02:32 <yitz> also right.
12:02:35 <newsham> for encodign the start/end states shoudl always be the same
12:02:43 <newsham> for decoding you might get caught in the middle of a character
12:02:54 <yitz> newsham: he is thinking about when things get chunked
12:03:17 <dcoutts_> eg, iconv has to deal with that
12:03:29 <dcoutts_> the iconv_t holds the current state for stateful encodings
12:03:38 <yitz> it's not just characters - every see bidi stuff?
12:03:40 <dcoutts_> and you give it a sequence of string chunks
12:03:55 <newsham> not familiar with "chunked"
12:04:07 <dcoutts_> newsham: think reading files in 4k chunks, or lazy bytestrings
12:04:49 <newsham> so the encoder emits chunks?
12:05:14 <newsham> if the encoder just has to deal with reading chunks, the start/end state is always the same.  you always get whole characters.
12:05:24 <newsham> though the decoder needs to worry about boundaries breaking up a character
12:05:35 <dcoutts_> right, my iconv binding does that
12:05:45 <dcoutts_> and the external api is just a lazy bytestring
12:05:54 <dcoutts_> so you never have to deal with the issues of chunks
12:06:27 <newsham> does haskell allow you ot use utf-8 in .hs src files?
12:06:51 <allbery_b> ghc >=6.6 does, to some extent
12:06:53 <yitz> it should but it doesnt
12:07:06 <newsham> > let ａ = 5 in ａ + 3
12:07:06 <lambdabot>  Illegal character ''\189''
12:07:07 <lambdabot>  at "" (column 6)
12:07:29 <allbery_b> lambdabot has additional limitations in that area
12:07:30 <newsham> ?info
12:07:30 <lambdabot> ()
12:07:36 <newsham> ?version
12:07:36 <lambdabot> lambdabot 4p571, GHC 6.6 (Linux i686 2.66GHz)
12:07:36 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:07:54 <yitz> ugh, kirc is bad for this. gotta get back to my mac :)
12:09:30 <ski> roconnor : yes .. `case C undefined of C _ -> ()' vs. `case A undefined of A _ -> ()'
12:10:34 <faxathisia> > () :: ()
12:10:39 <roconnor> right
12:10:42 <lambdabot>  ()
12:10:48 <roconnor> ski: I'll never be able to remember that :)
12:11:02 <roconnor> I hope there is a wiki page on the difference
12:11:03 <Botje> ()::() -- It's a spider! run!
12:11:11 <roconnor> :[]
12:12:06 <ski> roconnor : matching a strict `data'-constructor-application forces the strict argument(s), while matching a `newtype'-constructor-application is O(0)
12:12:51 <roconnor> ski: which of the two cases returns undefined?
12:13:22 <ski> the strict-`data' one
12:13:35 <roconnor> oops, I assumed the other way
12:13:50 <roconnor> definitely need a wiki page :)
12:14:06 <dcoutts_> twanvl: we need to document the right design somewhere
12:14:08 <ski> newtype Newtype a = N a
12:14:12 <ski> data Data a = D a
12:14:20 <ski> data StrictData a = SD a
12:14:36 <ski> case undefined of N _ -> ()  =  ()
12:14:45 <ski> case undefined of D _ -> ()  =  _|_
12:14:49 <ski> case undefined of SD _ -> ()  =  _|_
12:14:56 <ski> case N undefined of N _ -> ()  =  ()
12:15:05 <ski> case D undefined of D _ -> ()  =  ()
12:15:11 <ski> case SD undefined of SD _ -> ()  =  _|_
12:15:16 <ski> that sums it up, i think
12:15:19 <sclv> ski: shoudn't the StrictData type have a bang pattern somewhere?
12:15:29 <twanvl> dcoutts_: Do you have a suggestion?
12:15:37 <ski> sclv : er, sorry .. forgot that ! :)
12:15:48 <ski> data StrictData a = SD !a   -- correction :)
12:16:56 <dcoutts_> twanvl: on the haskell wiki and in a post to the libraries list, what the standard IO should look like, using bytestring and packedstring with pure encoding functions and then the H98 IO defined in terms of those, pack/unpack and the current locale
12:19:25 <yitz> Every codec - data or character - should have a "pure" version that throws IO errors, and a Maybe version.
12:19:44 <Raguel> hi
12:19:57 <Philippa> ITYM a monadic version for the latter
12:20:06 <Philippa> specialising to maybe is a bad idea
12:20:12 <liyang> Raguel: yhalothar
12:20:25 * Raguel feeds liyang waffles
12:20:35 <dcoutts_> yitz: yes, though you mean error, not IO error. In the iconv lib I've got the most general version being one that returns the result lazily but in a way that allows you to get the decoding errors
12:20:36 <yitz> Philippa - I don't think it matters much here.
12:20:53 * Raguel goes back to fluid dynamics journal papers
12:21:13 <yitz> dcoutts_: so in the Error monad?
12:21:19 <dcoutts_> yitz: no
12:21:22 <yitz> ?
12:21:27 * dcoutts_ finds the api
12:21:38 <Philippa> I guess the upside of having dropped out is that nobody expects me to know Raguel
12:21:58 <roconnor> yitz: can't those both be captured by a Monad(Zero) verison?
12:22:09 <dcoutts_> yitz: http://hackage.haskell.org/packages/archive/iconv/0.4/doc/html/Codec-Text-IConv.html#3
12:22:11 <lambdabot> http://tinyurl.com/246esj
12:22:36 <dcoutts_> yitz: the most general form produces a list of spans, where a span can be a bit of output or a decoding error
12:22:38 <roconnor> Philippa: specializing with a SPECIALIZE pragma might be good.
12:22:54 <dcoutts_> yitz: it's not very convenient, so I also provide the Maybe, Either and pure versions
12:23:19 <Raguel> people know me :|
12:23:50 <Philippa> Raguel: I probably don't though - I dropped out from UoN officially earlier this year having not studied properly for a couple of years
12:24:10 <Raguel> ooer
12:24:14 <dcoutts_> yitz: but it is more general than Maybe, or Either since it allows you to get at the partial results before and maybe after a conversion problem. The fact that the result spans can be calculated lazily can also be important.
12:24:15 <Raguel> i'm still in :)
12:24:16 <Philippa> assuming, of course, that you're actually connected with the uni. But most people from Nottingham in here are
12:24:23 <Raguel> arr
12:24:24 <yitz> dcoutts_: yes, need those. And ErrorT. getting complicated...
12:24:27 <Raguel> what department?
12:24:41 <dcoutts_> yitz: I don't see the need for arbitrary errorT
12:24:44 <Philippa> CSiT - I was an undergrad
12:24:57 <dcoutts_> yitz: lifting the Maybe/Either version into that would be easy
12:24:57 <Raguel> comp sci?
12:25:01 <Philippa> right
12:25:03 <Raguel> i'm mech eng
12:25:11 <Raguel> but latched onto comp sci
12:25:28 <Raguel> well specifically graham hutton
12:25:29 <Philippa> aha. There's a girl in mech eng I'm rather fond of...
12:25:34 <Raguel> i say
12:25:39 <Raguel> what year?
12:25:47 <Philippa> third now
12:25:47 <yitz> whatever, that's always how it goes with MonadFoos. Anyway...
12:25:51 <Raguel> (as in i'm doing both his modules to learn programming)
12:25:57 <Raguel> ah what's her name - she probably knows me
12:26:18 <dcoutts_> dons: it failed at the -fvia-C step, Xutils.h: No such file or directory
12:26:40 <dcoutts_> dons: I don't have any Xutils.h on my machine and I'd expect to have all the usual X header files installed
12:27:22 <olsner> hmm, I don't have Xutils.h either...
12:27:26 <yitz> I can just see someone trying to use a codec for the first time. It could be daunting - where do you look first? You already need lots of pieces. Can't it be simpler?
12:27:28 <Raguel> how many people here are at UoN?
12:27:48 <dcoutts_> yitz: the simple case is not caring about conversion errors (ie just calling error)
12:27:50 <olsner> but I do have an Xutil.h
12:28:34 <dcoutts_> yitz: so that case should be prominent, the other more complicated versions are for the few apps where they want to deal more precisely with decoding errors and do not want to just throw an exception
12:28:45 <yitz> right, not just that. lots of types, different kinds of combinators that are going to be in various modules...
12:29:01 <dcoutts_> yitz: the common case should just be composing simple functions
12:29:25 <yitz> even that - where do find all these functions? how do guess what their types are?
12:29:34 <dcoutts_> yitz: though you're right that knowing where to look might be a problem, we do need to think about that
12:30:24 <dcoutts_> dons: here it's defined in Xutil.h
12:31:09 <newsham> dcoutts: does zlib expose its crc32?
12:31:27 <conal> does anyone have sample code for making & using pixel arrays in OpenGL?
12:31:33 <newsham> png uses both zlib compression and the same crc algorithm (I just wrote one in haskell)
12:31:48 <dcoutts_> newsham: no, do you need it?
12:31:58 <newsham> would be useful to have.
12:32:05 <dcoutts_> newsham: as a separate function?
12:32:10 <newsham> yah
12:32:22 <dcoutts_> newsham: then no, that's not even used internally.
12:32:50 <dcoutts_> newsham: the only thing zlib gives you is access to the crc it is calculating itself of the data you're compressing
12:33:00 <newsham> png is defined to crc32 each section of its file with the same crc function as zlib uses, and compress the image data with the zlib compression algorithm.
12:33:13 <newsham> I noticed that python's zlib bindings expose crc32, as well.
12:33:18 <ibid> dons: you know, /whois would tell you my away reason too :)
12:33:43 <dcoutts_> newsham: in what form?
12:34:25 <newsham> python's is   zlib.crc32(string, optional-init-value)
12:34:53 <dcoutts_> newsham: they must not be using zlib directly then, or compressing the data too and discarding it
12:35:07 <dcoutts_> newsham: as I'm pretty sure zlib does not provide a separate crc32
12:35:44 <newsham> ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
12:36:03 <dcoutts_> newsham: oh, you're quite right
12:36:12 <dcoutts_> and adler32
12:37:51 <dcoutts_> newsham: so what api would you like, crc32, adler32 :: Lazy.ByteString -> Word32
12:39:08 <dcoutts_> I could export those from the Codec.Compression.Zlib.Internal module
12:40:18 <newsham> yes, those would be perfect
12:40:21 <therp> I apologize for the OT question, but does anyone by incidence know how to get the double bracket symbol in LaTeX  [[ with a negative kerning, crammed together? (hoping for a lot of academical writers in here)
12:40:46 <dcoutts_> newsham: ok, I might get round to it some time, or send a patch :-)
12:41:06 <newsham> dcoutts: thanks.. not super urgent, just seems like something that should be in there eventually
12:41:14 <dcoutts_> newsham: I agree
12:41:29 <dcoutts_> newsham: if it's used in things like the png spec and it's exported from zlib
12:41:35 <dcoutts_> that makes a lot of sense
12:41:36 * dcoutts_ disappears
12:42:09 <opqdonut> in a puff of logic
12:42:11 <mrd> therp: can look it up in tables, one sec
12:44:44 <therp> mrd: haven't found it in amsfont and lshort
12:44:47 <newsham> i hope that some day things like zlib will be written in haskell and outperform the C versions ;-)
12:44:54 * Raguel hides
12:44:59 <newsham> (and be guaranteed safe)
12:45:43 <mrd> therp: perhaps stmarysrd?
12:46:25 <mrd> yes its in there
12:46:32 <mrd> \llbracket \rrbracket
12:46:53 <mrd> http://www.cs.cmu.edu/~shaoml/symbols-a4.pdf
12:47:02 <mrd> that's a really comprehensive list
12:47:19 <mrd> stmaryrd is a latex package with lots of functional-programming oriented symbols
12:47:20 <therp> mrd: great, didn't know that! thanks!
12:48:25 <RyanT5000> is there a unit type that isn't lifted to include bottom?
12:49:04 <RyanT5000> presumably that would allow good optimizations, e.g. "type Set a = Map a ()"
12:49:11 <RyanT5000> (with some interface modifications)
12:49:11 <mrd> !() ?
12:49:58 <oerjan> you cannot put an unlifted type in another datatype unless it is prepared for it
12:50:00 <mrd> hah, astrological LaTeX symbols
12:50:11 <oerjan> i think
12:50:13 <RyanT5000> oerjan: is there any particular reason for that?
12:50:57 <oerjan> RyanT5000: unlifted types don't have the same format so they cannot be put in polymorphic "slots"
12:51:02 <RyanT5000> hm
12:51:05 <twanvl> dcoutts_: how should things like byte order marks work in the 'default encoding' system? I think the most sensible thing to do would be to store the encoding in a Handle (where needed). Or better: have a separate handle type for binary and for text.
12:51:17 <mrd> why stick to boring variables like \tau when you can have \Taurus
12:51:20 <oerjan> at least that's my guess
12:51:27 <RyanT5000> right, and i guess you couldn't guarantee all the Map functions would actually return that value
12:51:46 <RyanT5000> well, i'm sure you could for the case of Map, but in general it's the halting problem
12:52:20 <oerjan> you could make a version of Map with strict value fields though
12:52:33 <RyanT5000> yeah... but that's lame
12:52:37 <oerjan> and possibly ghc might unbox it then, i'm not sure
12:52:39 <RyanT5000> the whole idea is to reduce code duplication
12:52:52 <mrd> if Church had the "wasysym" package we might have ended up with the \frownie-calculus
12:53:34 <oerjan> probably only for monomorphic datatypes, because of the format variation?
12:53:41 <byorgey> mrd: haha!
12:53:42 <RyanT5000> hm
12:53:57 <RyanT5000> i mean, there's no *semantically* valid reason to separate Set a from Map a (), right>?
12:54:23 <RyanT5000> and the code should be identical
12:55:27 <oerjan> RyanT5000: you might be able to use Void instead of () - then bottom is the _only_ value
12:55:40 <RyanT5000> oerjan: interesting...
12:56:19 <oerjan> you would need to use lookup functions that distinguished a non-existing value from a bottom one, then
12:56:39 <RyanT5000> oerjan: no you wouldn't; sets *never* have to look at the value
12:56:42 <RyanT5000> the key wouldn't be Void
12:56:59 <RyanT5000> lookup would return either "Just undefined" or "Nothing"
12:57:20 <RyanT5000> as long as you never inspect the field of the Just, it's fine
12:57:26 <oerjan> right
12:57:27 <xerox> Maybe you can encode type (Hashable a) => Set a = IntMap Void together with hash :: Hashable a => a -> Int
12:57:43 <dons> dcoutts_: that Xutil.h thing should be fixed now
12:57:48 <RyanT5000> xerox: actually, my overall goal is to eliminate typeclasses :P
12:57:57 <RyanT5000> this is sort of a side concept
12:58:27 <RyanT5000> i've gotten increasingly annoyed at the concept of typeclasses
12:58:44 <RyanT5000> while undoubtedly cool, i don't like that they don't have any reasonable scoping rules
12:59:37 <Philippa> you mean instances? They're more reasonable when you consider the consequences of having two different instances for the same type collide
13:00:17 <RyanT5000> Philippa: well, practicality aside (for the moment), it's difficult to say what instance Ord String should do
13:00:38 <RyanT5000> should it sort in Unicode order? English order? Local order?
13:01:02 <RyanT5000> the very idea that there's a "default" ordering for Strings is fairly flawed, IMO
13:01:16 <Philippa> the multiple instance issue's a problem, yeah
13:01:25 <dmwit> newtype?
13:02:03 <RyanT5000> dmwit: that might necessitate sweeping changes, unless the underlying code is *really* well-written polymorphism-wise
13:02:16 <dmwit> true
13:02:25 <RyanT5000> however, even if it is, it's usually a pain
13:02:35 <RyanT5000> and it calls into question our understanding of "type"
13:02:53 <RyanT5000> should you really have to explicitly convert a value between "string sorted as English" and "string sorted as Finnish"?
13:03:54 <opqdonut> well more generally, sorting datums by different fields/methods is quite useful
13:03:58 <faxathisia> what about sortBy ?
13:04:00 <opqdonut> see relational databases etc
13:04:15 <faxathisia> functions that order strings should work on it :|
13:04:21 <RyanT5000> faxathisia: i have no complaint (of this kind) about sortBy, because it doesn't use typeclasses :P
13:04:30 <opqdonut> and having instance selection for Eq, Monoid, Functor and Ord would be nice
13:04:54 <oerjan> it could be nice to be able to declare instances on single variables, like in mathematics "Consider the set M equipped with the group operation from the arglemorphism of bargle"
13:04:57 <opqdonut> or rather, having instance selection would be nice, especially because of the listed classes
13:05:01 <RyanT5000> right; it's always really annoying to have to choose a sort order when you don't care
13:05:08 <opqdonut> oerjan: yep
13:05:08 <RyanT5000> so that's the argument *for* typeclasses
13:05:57 <schemelab> @src scanl
13:05:58 <lambdabot> scanl f q ls = q : case ls of
13:05:58 <lambdabot>     []   -> []
13:05:58 <lambdabot>     x:xs -> scanl f (f q x) xs
13:05:58 <RyanT5000> oerjan: sounds like a reasonable alternative way of scoping default arguments or whatever they're called
13:06:04 <vincenz> oerjan: the arglemorphism of bargle is completely subsumed by the bargle-morphism on burgle
13:06:07 <RyanT5000> (the ones with the question marks)
13:06:14 <vincenz> oerjan: get your facts straight
13:06:48 <RyanT5000> so basically what we're trying to get at with typeclasses is some notion of defaults
13:06:55 <RyanT5000> "when you don't care, you get X"
13:07:05 <RyanT5000> but we don't have a very smooth transition from noncaring to caring
13:07:13 <sclv> Ord instances are important even when you don't care *what* the ordering is though -- for example, something in a b-tree needs to be an ord, but you don't care how they're ordered, just that you *can* order them.
13:07:13 <RyanT5000> each library is written either for people who care or people who don't
13:07:22 * ski used `Void' in a useful way in a program
13:07:32 <opqdonut> ski: pray tell?
13:07:44 <RyanT5000> sclv: however, even with, e.g. Map, you *might sometimes care*
13:08:00 <RyanT5000> sclv: for instance, suppose you have a list of Strings ordered in German
13:08:15 <RyanT5000> sclv: and you want to build a Map in O(n) rather than O(n log n)
13:08:32 <ski> opqdonut : i had `kill :: SystemM Void' for monad supporting threads
13:09:25 <RyanT5000> sclv: you *must* use the German ordering, either by newtyping or providing it (if Map had that feature, which it doesn't), or you must reorder the list in O(n) to the default ordering
13:09:31 <RyanT5000> (which sounds difficult)
13:09:54 <ski> opqdonut : (modulo `undefined'), that ensured that operation didn't really return  (initially i used ugly `undefined' things .. later i reformulated using `Void', in a nicer and clearer way)
13:10:09 <opqdonut> mmh, okay
13:11:00 <sclv> RyanT500: right, but suppose you have a list of (Int, Int, Int) ordered by the middle value first, then the first, then the third -- you have the same issue! I agree that a map specialized on a custom comparator function is a good idea, and I think there might be some already in the various other collections libraries. It's just not an argument against the general case of Ord.
13:11:01 <RyanT5000> my point is not that custom orderings or default orderings are bad - each one has its place - only that we shouldn't have to decide which to use at library-design-time
13:11:10 <ski>   newtype SystemM a = MkSM {unSM :: MR.ReaderT Resolution (MS.StateT SnailState (MS.StateT [Thread] (MC.ContT () IO))) a}
13:11:36 <RyanT5000> sclv: right; i'm not saying there shouldn't be default orderings; just that the library shouldn't care whether the ordering is default or custom
13:11:42 <ski>   type Program = Action Void
13:11:51 <ski>   run :: Resolution -> Program -> IO ()
13:12:09 <RyanT5000> sclv: i don't think it should be possible (or, at least, natural) to design a library that cares whether you're using the default Ord or providing your own
13:12:38 <sclv> RyanT5000: Ok, I think I see where you're coming from, but I don't see exactly how you'd work around that.
13:12:45 <RyanT5000> sclv: neither do i :P
13:13:09 <RyanT5000> i think default arguments are an interesting potential solution
13:13:12 <_ry> how do i give a constructor for type Quaternion = (Double, Double, Double)
13:13:31 <mrd> > (1.0,2.0,3.0)
13:13:34 <lambdabot>  (1.0,2.0,3.0)
13:13:52 <oerjan> you would want some scoped instance declarations on specific variables or types
13:13:57 <byorgey> _ry: It depends what you mean.  What are you trying to do?
13:14:05 <faxathisia> _ry: Why do you use quaternion with only 3 parts?
13:14:06 <RyanT5000> oerjan: yeah, that could also work
13:14:07 <ski> _ry : type synonyms do not have constructors of their own
13:14:19 <_ry> oh
13:14:35 <faxathisia> newQuat = (,,,)
13:14:35 <_ry> okay - nevermind!
13:14:47 <faxathisia> _ry: I'm still wondering why you use 3 part quaterins..
13:14:49 <mrd> can do
13:15:00 <ski> faxathisia : possibly the real part is omitted, for use with rotations
13:15:01 <_ry> faxathisia: oh, yeah, forgot the constant
13:15:08 <opqdonut> :D
13:15:28 <faxathisia> ski: Just wondering if they assume normalized and have some clever set of optimizations
13:15:39 <RyanT5000> oh, here's a really weird case for typeclasses
13:15:53 <RyanT5000> suppose you have a simple language that lets the user write ordering functions
13:15:58 <oerjan> @users
13:15:59 <lambdabot> Maximum users seen in #haskell: 424, currently: 417 (98.3%), active: 22 (5.3%)
13:16:02 <RyanT5000> and you take as input from the user a list of values and an ordering function
13:16:07 <_ry> do i want a type synonym if i want to be able to inherit from Num ?
13:16:30 <RyanT5000> now you'd like to build a Map of those values under that ordering in O(n)
13:16:49 <opqdonut> isn't that kinda like a minimalistic database, yes?
13:16:50 <mrd> what do you mean "inherit"
13:17:17 <oerjan> _ry: usually you want data or newtype, but i don't see how you can inherit Num for quaternions any way
13:17:24 <RyanT5000> opqdonut: i suppose you could say that; do most databases allow custom orderings?
13:17:44 <opqdonut> at least sql queries do
13:17:47 <_ry> oerjan: to define multiplication and additon?
13:17:59 <RyanT5000> opqdonut: yeah, but for storage purposes
13:18:10 <mrd> write an instance? then you want data or newtype
13:18:11 <allbery_b> some do for at least some things
13:18:19 <allbery_b> (dbmses that is)
13:18:21 <opqdonut> RyanT5000: not sure what they do on the storage level
13:18:27 <sclv> RyanT5000: I think you can build pretty much whatever custom indexes you want
13:18:31 <oerjan> _ry: you want to define an instance, but you cannot inherit it directly because there is nothing in the standard library corresponding to quaternions
13:18:32 <opqdonut> but there is a "primary" field that is used to index
13:18:35 <mrd> haskell is not OO there is no "inherit"
13:19:06 <_ry> okay, instance. right. that's what i meant. excuse my noob-ness
13:19:07 <mrd> the only inheritance you get from haskell is if you were written in his will
13:19:55 <RyanT5000> oh, speaking of inheritance, btw, what are people's thoughts on subtypes? e.g.: product types (or records) with "at least all the required fields" and sum types with "at most all the same fields"
13:20:10 <mrd> more trouble than its worth
13:20:18 <sclv> _ry: quartinions don't commute, so treating them as an instance of Num seems weird?
13:20:38 <shapr> I work at home, does that mean I'm a quartinion?
13:20:42 <oerjan> mrd: oh, i meant deriving
13:20:55 <_ry> sclv: does Num need commuting?
13:21:06 <byorgey> sclv: I don't think Num depends on the commutativity of *.
13:21:07 <pgavin> is there a flag I can pass to ghc's configure that will make it always look in some directory for includes and libs?
13:21:20 <Philippa> mrd: I disagree muchly, inheritance is far more problematic than subtyping. But then, I run into situations where having polymorphic variants'd be useful rather a lot
13:21:36 <pgavin> if I do CFLAGS=-I... it doesn't get used sometimes
13:21:37 <nominolo> @hoogle (a -> Maybe b) -> Set a -> Set b
13:21:41 <lambdabot> No matches, try a more general search
13:21:41 <_ry> i think i had to explicitly define the commuting for addition earlier today for a different data type
13:21:48 <sclv> _ry: it doesn't, but it still seems like it would be fairly unintuitive compared to a custom operator.
13:21:58 <mrd> perhaps, i have some perhaps unwarranted distaste for subtyping because of its company
13:22:22 <mrd> however subtyping does kill type inference pretty badly, which sucks
13:22:29 <_ry> sclv: huh.. do you have a problem with complex numbers multiplying?
13:22:48 <Philippa> yeah, row kinds are a much better approach in that regard
13:23:01 <byorgey> shapr: hehe =)
13:23:08 <oerjan> @check \x y -> x*y == (y*x :: Complex Double)
13:23:12 <lambdabot>        add an instance declaration for (Arbitrary (Complex Double))     In th...
13:23:18 <oerjan> sheesh
13:23:28 <mrd> killing type inference to obtain dependent types of some sort seems like a better trade off in that regard
13:23:50 <RyanT5000> mrd: i agree heartily :)
13:23:56 <RyanT5000> <3 dependent types
13:24:07 <schemelab> @src scanl
13:24:07 <lambdabot> scanl f q ls = q : case ls of
13:24:08 <lambdabot>     []   -> []
13:24:08 <lambdabot>     x:xs -> scanl f (f q x) xs
13:24:11 <oerjan> @check \xr xi yr yi -> let x = xr:+xi; y = yr:+yi in x*y == (y*x :: Complex Double)
13:24:16 <lambdabot>  OK, passed 500 tests.
13:24:40 <opqdonut> oerjan: :)
13:25:54 <faxathisia> > check \n -> sum [1..n] == n*(n+1) `div` 2
13:25:55 <lambdabot>  Parse error at "\n" (column 7)
13:26:04 <faxathisia> @check \n -> sum [1..n] == n*(n-1) `div` 2
13:26:05 <lambdabot>  Add a type signature
13:26:08 <faxathisia> >:\
13:26:46 <oerjan> @check \n -> sum [1..n] == (n*(n-1) `div` 2 :: Integer)
13:26:48 <lambdabot>  Falsifiable, after 0 tests: 1
13:26:56 <oerjan> @check \n -> sum [1..n] == (n*(n+1) `div` 2 :: Integer)
13:26:57 <lambdabot>  Falsifiable, after 11 tests: -8
13:27:09 <oerjan> @check \n -> n >= 0 ==> sum [1..n] == (n*(n+1) `div` 2 :: Integer)
13:27:10 <lambdabot>  OK, passed 500 tests.
13:27:16 <faxathisia> :D
13:27:36 <byorgey> @check \n -> n >= 0 ==> sum [1..n] == (n*(n+1) `div` 2 :: Int)
13:27:38 <lambdabot>  OK, passed 500 tests.
13:27:41 <opqdonut> ?src (==>)
13:27:41 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:27:43 <faxathisia> Why isn't there a type for natural numbers though?
13:27:52 <opqdonut> is that quickcheck's?
13:28:09 <byorgey> opqdonut: yes.
13:28:15 <oerjan> :t (Test.QuickCheck.==>)
13:28:16 <ari> :t (==>)
13:28:17 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
13:28:18 <lambdabot> Not in scope: `==>'
13:28:53 <byorgey> faxathisia: good question.
13:29:08 <_ry> is there a way to inject a variable into a string. for example in ruby you can do world = "world; "hello #{world}"
13:29:09 <mrd> a type for peano numbers would have to look like this: data Nat = Z | S !Nat and that introduces all sorts of fun
13:29:24 <oerjan> faxathisia: there are libraries on hackage implementing them
13:29:42 <opqdonut> _ry: well, you want something like:
13:29:54 <nominolo> _ry: tom moertel blogged about that
13:29:57 <opqdonut> > let world = "world" in "hello "++world++"!"
13:29:58 <lambdabot>  "hello world!"
13:30:12 <RyanT5000> _ry: surround it with "++ and ++" ;)
13:30:22 <_ry> RyanT5000: :)
13:30:25 <oerjan> > printf "hello %s!" "world" :: String
13:30:26 <lambdabot>  "hello world!"
13:30:39 <RyanT5000> @t printf
13:30:39 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:30:41 <_ry> oerjan: oh, that's good
13:30:44 <RyanT5000> @type printf
13:30:46 <lambdabot> forall r. (PrintfType r) => String -> r
13:30:50 <RyanT5000> ew
13:30:56 <oerjan> @quote printf
13:30:56 <lambdabot> No quotes match. Sorry.
13:31:09 <RyanT5000> @source PrintfType
13:31:10 <lambdabot> PrintfType not available
13:31:12 <nominolo> > let world = "hello " ++ tail world in world
13:31:13 <lambdabot>  "hello ello ello ello ello ello ello ello ello ello ello ello ello ello ello...
13:31:27 <oerjan> @source Text.Printf
13:31:27 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
13:31:28 <faxathisia> cool :D
13:31:47 <RyanT5000> it's like dependent types without any of the benefits!
13:31:50 <RyanT5000> yay!
13:32:39 <mrd> > let world = "hello " ++ concat (tails world) in world
13:32:40 <lambdabot>  "hello hello hello hello hello hello hello hello hello hello hello hello hel...
13:32:51 <opqdonut> :D
13:33:01 <oerjan> > fix (tail . printf "hello %s")
13:33:02 <lambdabot>  Add a type signature
13:33:08 <oerjan> > fix (tail . printf "hello %s") :: String
13:33:10 <lambdabot>  Exception: stack overflow
13:33:12 <opqdonut> :E
13:33:15 <oerjan> bah
13:33:22 <faxathisia> > concat $ tails "hello"
13:33:23 <lambdabot>  "helloellolloloo"
13:33:24 <mrd> > let world = "hello " ++ concat (inits world) in world
13:33:25 <lambdabot>  "hello hhehelhellhellohello hello hhello hhhello hhehello hhehhello hhehehel...
13:33:38 <faxathisia> > concat $ insert ' ' $ tails "hello"
13:33:39 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
13:33:46 <faxathisia> > concat $ insert [' '] $ tails "hello"
13:33:47 <lambdabot>  " helloellolloloo"
13:33:51 <faxathisia> >:|
13:34:17 <byorgey> faxathisia: maybe you want intersperse?
13:34:45 <oerjan> > printf "hello %s" $ repeat "ello " :: String
13:34:46 <lambdabot>   add an instance declaration for (IsChar [Char])
13:34:55 <oerjan> > printf "hello %s" $ cycle "ello " :: String
13:34:59 <lambdabot> Terminated
13:35:02 <faxathisia> > concat $ intersperse [' '] $ tails "hello"
13:35:04 <lambdabot>  "hello ello llo lo o "
13:35:11 <oerjan> apparently printf is not lazy at all
13:35:50 <mrd> > fix (\ x -> "hello":intersperse "," x)
13:35:52 <lambdabot>  Exception: <<loop>>
13:36:24 <mrd> > intersperse 1 [1..10]
13:36:25 <lambdabot>  [1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10]
13:36:27 <mrd> > intersperse 1 [1..]
13:36:28 <lambdabot>  [1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,13,1,14,1,15,1,16,1,17,1...
13:36:32 <mrd> weird
13:37:42 <oerjan> > fix (\ x -> "hello":intersperse ',' x)
13:37:43 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
13:37:50 <oerjan> oh
13:37:55 <oerjan> > fix (\ x -> "hello"++intersperse ',' x)
13:37:57 <lambdabot>  "helloh,e,l,l,o,h,,,e,,,l,,,l,,,o,,,h,,,,,,,e,,,,,,,l,,,,,,,l,,,,,,,o,,,,,,,...
13:38:38 <oerjan> was that what you wanted?
13:38:50 <mrd> sure, why not
13:39:04 <dmwit> mrd: Just playing?
13:39:05 <dmwit> =)
13:39:31 <mrd> when do you really need exponential increase of commas, after all
13:39:50 <oerjan> > intersperse 1 (2:undefined)
13:39:52 <lambdabot>  Undefined
13:40:00 <oerjan> > take 1 $ intersperse 1 (2:undefined)
13:40:02 <lambdabot>  Undefined
13:40:05 <EvilTerran> my lecturer mentioned a nice explanation of the least fixed point of a function today; he described it as (to paraphrase) "the limit of (iterate f _|_)"
13:40:45 <faxathisia> > iterate ((1+)1/) 1
13:40:46 <lambdabot>  [1.0,2.0,1.0,2.0,1.0,2.0,1.0,2.0,1.0,2.0,1.0,2.0,1.0,2.0,1.0,2.0,1.0,2.0,1.0...
13:41:00 <faxathisia> > iterate ((1+).(1/)) 1
13:41:02 <lambdabot>  [1.0,2.0,1.5,1.6666666666666667,1.5999999999999999,1.625,1.6153846153846154,...
13:41:10 <faxathisia> ok
13:41:19 <faxathisia> why do you start with _|_ ?
13:41:32 <_ry> how do i import a module in prelude?
13:41:38 <opqdonut> because we want the least fixed point
13:41:42 <faxathisia> _ry: I think you can use :module Monad or whatever
13:41:45 <opqdonut> domain theoretically, not numerically
13:41:45 <oerjan> faxathisia: to get the _least_ possible fixpoint you start with the least possible value
13:41:55 <opqdonut> yep
13:42:24 <faxathisia> _ry: probably :add is better
13:42:39 <glguy> Has anyone had any success in installed GHC on OS X.5?
13:42:40 <faxathisia> wait no I am confsued
13:42:49 <oerjan> _ry: um, Prelude is a module, i guess you mean in the interactive interpreter?
13:42:55 <KatieHuber> glguy: yes, with the binary package, not macports
13:42:56 <lambdabot> KatieHuber: You have 1 new message. '/msg lambdabot @messages' to read it.
13:43:10 <glguy> KatieHuber: OK, thanks
13:43:24 <oerjan> Prelude is just the only module imported into it by default, so it may be the default prompt
13:43:36 <byorgey> for example, iterate (1:) undefined === [undefined, 1 : undefined, 1 : 1 : undefined, ...]
13:43:47 <byorgey> and fix (1:) === [1,1,1,1,1,1...]
13:43:51 <byorgey> > fix (1:)
13:43:53 <glguy> I can't even use the ssh(1) from macports
13:43:54 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:44:02 <oerjan> @users
13:44:02 <lambdabot> Maximum users seen in #haskell: 424, currently: 423 (99.8%), active: 26 (6.1%)
13:44:04 <glguy> percent_expand: NULL replacement
13:44:09 <KatieHuber> glguy: most of macports is broken, the BSD-level stuff changed quite a lot
13:44:24 <faxathisia> @check (\x-> last $ fix (1:) == undefined)
13:44:25 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
13:44:26 <EvilTerran> however, iterate id _|_ = [_|_, _|_, _|_, ...], but iterate id 42 = [42, 42, 42...]
13:44:29 <EvilTerran> > fix id
13:44:30 <lambdabot>  Exception: <<loop>>
13:44:36 <oerjan> faxathisia: :D
13:44:37 <faxathisia> @check (\x-> (last $ fix (1:)) == undefined)
13:44:37 <lambdabot>  Add a type signature
13:44:39 <EvilTerran> <<loop>> is a type of _|_
13:45:01 <EvilTerran> "type"'s not a good word. "variety", maybe. "flavor"?
13:45:14 <glguy> KatieHuber: is there a solution beyond "don't use macports" ? is fink better?
13:45:38 * allbery_b suspects both are broken right now if the topic is leopard
13:46:01 <pejo> KatieHuber, they changed stuff in 10.5?
13:46:39 <glguy> heh, the first line of the code for uninstalling macports is: rm -fr \
13:46:49 <glguy> that seems dangerously close to : rm -fr /
13:47:11 <KatieHuber> glguy: fink uses binary packages, so they're likely to *work*, I just don't think anyone'd actually *want* to use fink
13:47:20 <EvilTerran> as long as the next one's not "/", you should be alright, glguy ;)
13:48:00 <dcoutts> dons: ok, builds now. not -Wall clean as I'm sure you realise.
13:48:15 <dons> dcoutts: yes, some patches for that on its way
13:48:20 <dons> its never been wall clean
13:48:30 <dcoutts> dons: yeah I'm sure :-)
14:00:58 <_ry> is there a better way to do this using composition:   negate (Quaternion a b c d ) = Quaternion (-a) (-b) (-c) (-d)
14:01:49 <faxathisia> _ry: that looks good
14:01:55 <faxathisia> I don't think there is any possible improvement
14:01:56 <exDM69> _ry: would it be better to have a, b, c and d in a list?
14:02:00 <dons> yeah, there's no simpler way without tricks
14:02:09 <oerjan> @pl \f a b c d -> f (-a) (-b) (-c) (-d)
14:02:09 <dons> and lists make it less efficient
14:02:10 <lambdabot> flip flip negate . ((flip . ((flip . ((.) .)) .)) .) . flip flip negate . ((flip . ((.) .)) .) . flip flip negate . ((.) .) . (. negate)
14:02:12 <faxathisia> I would imagine any such tricks are rather confusing
14:02:16 <oerjan> eek
14:02:17 <conal> and less precise
14:02:21 <dons> since you probably also want strict fields and so on
14:02:38 <conal> and static checking of fourness.
14:02:42 <dons> yep
14:03:29 <olsner> @pl \f g a b c d -> f (g a) (g b) (g c) (g d)
14:03:32 <lambdabot> join . ((flip . ((flip . ((flip . ((.) .)) .)) .)) .) . join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
14:04:07 <dmwit> join, flip, (.) -- a new calculus
14:04:23 <conal> _ry: btw, why Quaternion as Num?
14:04:35 <_ry> conal: for fun?
14:04:36 <conal> maybe Monoid instead
14:04:39 <conal> :)
14:04:55 <conal> will you use + for composition?
14:04:56 <_ry> no, i'm just practicing
14:05:01 <faxathisia> > case (map (-) [3,6,8,4]) of [x', y', z', w'] -> (x', y', z', w')
14:05:02 <lambdabot>  (<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
14:05:03 <conal> oh
14:05:10 <faxathisia> oop: |
14:05:12 <_ry> conal: no, for addtion :)
14:05:31 <conal> is addition meaningful on Quaternions?
14:05:34 <olsner> dmwit: is that turing complete too?
14:05:41 <faxathisia> conal: quaternions are just like complex numbers
14:05:43 <_ry>   (+) (Quaternion a0 b0 c0 d0) (Quaternion a1 b1 c1 d1)  =
14:05:44 <_ry>     Quaternion (a0+a1) (b0+b1) (c0+c1) (d0+d1)
14:05:55 <faxathisia> conal: we define i*i = j*j = k*k = -1
14:05:59 <dmwit> olsner: It's doubtful.
14:05:59 <oerjan> conal: addition, multiplication, division
14:06:16 <dmwit> olsner: Although "ap" and "const" together seem to be Turing complete. =)
14:06:21 <oerjan> but the two latter are weird because of noncommutativity
14:06:26 <faxathisia> conal: but j*k = i, i*k =  j, i*j = k
14:06:29 <olsner> btw, what is it that make them a "calculus" as opposed to just a bunch of functions?
14:06:46 <marceau> pretension
14:07:31 <conal> does Quaternion addition have an interpretation in terms of rotation?
14:07:41 <oerjan> (.) and flip are B and C as combinators
14:07:50 <faxathisia> conal: So they are just numbers but I don't think they fit in haskells Num
14:07:51 <roconnor> conal: not really
14:07:57 <oerjan> BCI and BCK are known calculi
14:07:58 <_ry> conal: it's vecotr addition in R^4
14:08:10 <oerjan> not sure about join though
14:08:17 <faxathisia> conal: rotation (q*v*q') is a linear transformation only when q is normalized
14:08:21 <roconnor> unit quaternions are used for spherical rotation in the same way that unit complex number are for circular rotation.
14:08:31 <faxathisia> conal: And given two rotations, normalized quations their addition is not a normalized quat
14:08:36 <conal> roconnor: gotcha.
14:08:54 <faxathisia> conal: So it is not meaningful when you use them as rotations
14:08:56 <EvilTerran> hm... how do you check for end of input in a ReadP parser?
14:09:10 <conal> faxathisia: got it.  thanks.
14:09:16 <_ry> robozni: 3d spheres - right?
14:09:40 <_ry> (S^3 i mean)
14:11:23 <marceau> conal: yeah, something like that, in analgy to S^1 as the unit circle in the complex plane
14:13:04 <conal> btw, just found this: http://citeseer.ist.psu.edu/346751.html
14:13:06 <lambdabot> Title: Lazy Functional Quaternions (ResearchIndex)
14:13:25 <conal> _ry: not to dissuade you.  just looks interesting.
14:13:38 <EvilTerran> i guess readS_to_P (\s -> guard (null s) >> return s) would work...
14:14:26 <_ry> oh - i'm doing it for my homework :)
14:15:33 <faxathisia> conal: oops defining i, j k is kind of meaningless without defining quaternions in terms of them
14:15:36 <KatieHuber> looks like they don't check their lists are 3-long anywhere :/
14:15:44 <faxathisia> conal: I should have said {1, i, j, k} spans Quaternions
14:16:03 <faxathisia> conal: so you can write any quaternion as w + i*x + j*y + k*z
14:18:41 <oerjan> @check \x y z -> ((join .) . (.) . flip) x y z == (ap x (y::Bool -> Bool) z :: Bool)
14:18:43 <lambdabot>  OK, passed 500 tests.
14:19:59 <oerjan> dmwit: as you see ap (S) can be expressed with join, (.), flip
14:22:40 <dcoutts> @seen nominolo
14:22:40 <lambdabot> nominolo is in #haskell-soc, #ghc and #haskell. I last heard nominolo speak 51m 28s ago.
14:22:46 <nominolo> dcoutts !!!
14:22:52 <dcoutts> nominolo !!
14:22:54 <dcoutts> :-)
14:22:59 <nominolo> wassup?
14:23:38 <dcoutts> nominolo: if you want to help with QC properties for make, the code is accruing at http://haskell.org/~duncan/cabal/dep-experiment/
14:23:39 <lambdabot> Title: Index of /~duncan/cabal/dep-experiment
14:23:47 <dcoutts> nominolo: darcs send your patches to me
14:24:04 <dcoutts> nominolo: kolmodin is thinking about it a bit too, though he really wants to do parallel builds asap :-)
14:24:15 <dcoutts> nominolo: I want to specify things asap
14:24:30 <kolmodin> :D
14:24:36 <dcoutts> nominolo: so we can then go adding features while keeping things correct
14:24:58 * nominolo votes for correct first, faster later
14:25:11 <_ry> @doc Prelude
14:25:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
14:25:15 <dcoutts> @yrr!
14:25:15 <lambdabot> Maybe you meant: arr yarr
14:25:18 <dcoutts> @yarr!
14:25:18 <lambdabot> Get out o' me way, yeh landlubber
14:25:22 <dcoutts> nominolo: indeed
14:25:32 <kolmodin> I simply want us to think about how to make it parallel so we don't need to change everything later
14:25:44 <dcoutts> kolmodin: yes I understand
14:25:44 <kolmodin> of course I want it correct :)
14:25:58 <oerjan> @check \y z -> ap (flip id) y z == (join y (z::Bool) :: Bool)
14:26:03 <dcoutts> I'd also like it to be modular and comprehensible
14:26:10 <lambdabot>  OK, passed 500 tests.
14:26:27 * nominolo probably has to implement CHR for Haskell sooner or later for his MSc thesis ...
14:26:42 <kolmodin> nominolo: CHR?
14:26:43 <dcoutts> constraint handling rules?
14:26:49 <nominolo> yup
14:27:00 <dcoutts> @yerp
14:27:00 <lambdabot> Maybe you meant: help temp vera yarr
14:27:07 <nominolo> maybe i should use Curry ... :/
14:27:11 <kolmodin> @yarp!
14:27:11 <lambdabot> Aye
14:27:15 <dcoutts> kolmodin: heh
14:27:32 <nominolo> @gulp"
14:27:32 <lambdabot> Unknown command, try @list
14:27:42 <kolmodin> ?narp..?
14:27:42 <lambdabot> Unknown command, try @list
14:28:00 <nominolo> @eek
14:28:00 <lambdabot> Maybe you meant: ask let seen
14:28:12 <kolmodin> with a nice design making it parallel should really come almost for free
14:28:31 * faxathisia wonders if anyone uses pH?
14:28:44 <dcoutts> faxathisia: not so far as I know
14:28:53 <kolmodin> me neither
14:28:58 <faxathisia> I am just waiting for something in pH to code :p
14:29:28 <faxathisia> It seems very cool from the book I can't remember the name
14:33:50 <tieTYT> can anyone recommend a haskell tutorial meant for someone that's not familiar with functional programming?
14:34:15 <EvilTerran> @go haskell for c programmers
14:34:18 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
14:34:18 <lambdabot> Title: Haskell for C Programmers
14:34:37 <tieTYT> cool, thanks
14:34:58 <tieTYT> see ya
14:41:03 * EvilTerran realises to his horror that ReadP appears to not support input streams of anything other than characters
14:42:19 <viklund_> @src interact
14:42:19 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:42:48 <EvilTerran> putStr . f =<< getContents, if you prefer
14:43:05 <viklund_> hmm, yes, I'm writing a slightly different one...
14:44:19 <viklund_> or maybe not... haven't thought the getContents through, I guess... hmm
14:50:42 <kolmodin> g'night nominolo
14:50:59 <nominolo> alreadY?
14:51:09 <nominolo> ah, working people ...
14:51:18 <nominolo> g'nite :)
14:57:11 <yrlnry_> http://blog.plover.com/prog/perl/undefined.html#5 has a discussion of Haskell's n+k patterns in the context of "undefined behavior" that might possibly be interesting to regulars of this channel.
14:57:12 <lambdabot> Title: The Universe of Discourse : Undefined behavior in Perl and other languages
14:58:47 <newsham> "for" loops in Unreal: 40% are comprehensions, 50% are folds.
14:58:48 <newsham> wow
14:59:25 <olsner> newsham: where from?
14:59:25 <yrlnry_> newsham: URL?
14:59:34 <pgavin> unreal the FPS game?
14:59:40 <newsham> http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt
14:59:47 <newsham> the engine
15:00:13 <pgavin> it's written in haskell?
15:00:18 <yrlnry_> Darn, I had that downloaded and opened u pon my computer last week, and then decided not to read it.
15:00:19 <profmakx> nuahaha
15:00:26 <newsham> no
15:00:48 <profmakx> but, why does that surprise anyone in here?
15:00:52 <newsham> "Factoid: C# exposes omre than 10 integer-like data types, none of which are those defined by (Pythagoras, 500BC)."
15:00:56 <newsham> heh
15:01:02 <conal> viklund_: for a combinator library generalizing interact, see TV
15:01:07 <conal> @wiki TV
15:01:07 <lambdabot> http://www.haskell.org/haskellwiki/TV
15:01:46 <profmakx> or rather "why should that surprise anyone in here"
15:02:34 <Pseudonym> The impossible does happen, profmakx.
15:02:36 <Pseudonym> GHC told me so.
15:02:55 <profmakx> *g*
15:02:56 <RemiTurk> good evening to everybody
15:03:16 <profmakx> wait! you are the guy with the hswm right?
15:03:18 <TSC> Hello
15:03:29 <RemiTurk> that's right yeah :)
15:03:41 <RemiTurk> yay, somebody noticed? ;)
15:04:14 <viklund_> conal: thx
15:04:18 <allbery_b> dons was poking at it last night over in #xmonad :)
15:05:22 <RemiTurk> :)
15:06:43 <RemiTurk> I'm curious about other people's opinions, even though the project is rather dead
15:10:17 <Pseudonym> ?go hswm
15:10:19 <lambdabot> http://groups.yahoo.com/group/hswm/
15:10:20 <lambdabot> Title: hswm : Homeschool Webmasters
15:10:44 <RemiTurk> http://www.haskell.org/pipermail/haskell-cafe/2007-October/033790.html
15:10:45 <lambdabot> Title: [Haskell-cafe] ANNOUNCE / POST MORTEM: hswm, version (), http://tinyurl.com/2y2wy3
15:10:57 <Pseudonym> Yeah, I know. :-)
15:15:44 <fox86> are there any good libraries for making graphs? i need to plot some dots...and then for each run in a neural net i need to update the graph
15:16:20 <xerox> graphviz
15:16:21 <RemiTurk> there is Data.Graph.Inductive.Graphviz ..
15:17:00 <fox86> oh. thank you
15:26:35 * bos puts some hating on darcs
15:27:53 <olsner> wow, haskell has a graphviz package?
15:29:50 <yrlnry_> Am I approximately correct that the ambivalence of the Haskell 98 report to (n+k) patterns is the result of arguments between the committee members who thought it would be useful in undergrad education, and those who didn't care and didn't want it anyway?
15:30:10 * EvilTerran wonders if it's worth trying to make a generalised version of ReadP that accepted other input type
15:30:17 <EvilTerran> *input token types
15:30:46 * twanvl has done that exact thing
15:30:54 <Pseudonym> yrlnry: You're a little bit correct.
15:30:56 <EvilTerran> wondered, or done it?
15:31:01 <twanvl> done
15:31:04 <bos> yrlnry_: haskell inherited n+k patterns from miranda
15:31:17 <Pseudonym> There was a lot of existing code that used n+k patterns.
15:31:21 <twanvl> http://twan.home.fmf.nl/parsep/
15:31:22 <lambdabot> Title: ParseP
15:31:24 <EvilTerran> in my case, it's most definitely yak shaving, so i'd be interested in seeing your implementation
15:31:26 <EvilTerran> ah, thank
15:31:27 <EvilTerran> s
15:31:29 <Pseudonym> So backwards-compatibility was an issue.
15:31:45 <Pseudonym> Also, n+k patterns complicate the syntax and create some bizarre corner cases.
15:31:58 <Pseudonym> These cases, interestingly, don't turn up in Miranda.
15:32:15 <Pseudonym> Because Miranda didn't have lambda expressions, case statements or let expressions.
15:32:22 <yrlnry_> I didn't realize that backward compatibility with Miranda was an issue.
15:32:47 <Pseudonym> It kind of half was.
15:33:01 <Pseudonym> Miranda didn't have those things that I mentioned.
15:33:04 <yrlnry_> Miranda programs will actually compile as Haskell?  I had no idea.
15:33:12 <bos> miranda may have inherited those patterns from KRC. i can't follow the trail back that far.
15:33:18 <Pseudonym> So n+k expressions really were only the clean way to write certain kinds of program.
15:33:29 <bos> yrlnry_: only a few trivial miranda programs can compile to haskell
15:33:50 <LoganCapaldo> Miranda didn't have lambda expressions? Did it have 'where' ?
15:33:57 <Pseudonym> They did, I think, want to minimise the amount of hard thinking you had to do to translate Miranda programs into Haskell.
15:34:14 <bos> miranda had where, yes.
15:34:20 <Pseudonym> Yes, but not let.
15:34:23 <conal> like iswim
15:34:45 <LoganCapaldo> yeah i only ask cause you said "not let", I felt like where was suspiciously abset from the list of things it didn't have
15:34:51 <Pseudonym> Right.
15:34:58 <bos> for example, miranda has list comprehensions, but the separator for clauses inside a list comprehension is semicolon, not comma.
15:35:06 <conal> postfix let
15:35:10 <Pseudonym> However, one more thing to keep in mind.
15:35:38 <bos> also, miranda's guards are postfix expressions, not prefix as in haskell.
15:35:38 <Pseudonym> Haskell was partly a replacement for Miranda, but mostly a consolidation of a number of Miranda-like languages that researchers wanted to hack on.
15:35:39 <hpaste>  _ry pasted "why doesn't this work?" at http://hpaste.org/3525
15:35:48 <Pseudonym> Right.
15:36:12 <Cale> _ry: you need a numeric conversion
15:36:16 <hpaste>  conal annotated "why doesn't this work?" with "(no title)" at http://hpaste.org/3525#a1
15:36:16 <Cale> _ry: try fromIntegral
15:36:20 <Pseudonym> And all of those languages had (n+k) patterns.
15:36:30 <EvilTerran> ?type fromIntegral
15:36:31 <lambdabot> forall a b. (Num b, Integral a) => a -> b
15:36:32 <_ry> can i just do (n::Double)
15:36:32 <Cale> (or fromInteger)
15:36:47 <_ry> (to cast to double?)
15:36:49 <allbery_b> no
15:36:50 <Cale> _ry: No, because you explicitly said it was an Integer already
15:36:52 <yrlnry_> I tried to find information about ISWIM about 15 years ago and couldn't locate anything at all.
15:36:57 <conal> _ry: no casts in haskell.
15:36:58 <bos> yrlnry_: you can find out more about miranda by sending mail to mcvax!ukc!mira-request :-)
15:37:00 <allbery_b> there's no casting like in C, you need to use something liek fromIntegral
15:37:11 <LoganCapaldo> no ou can't just do (n :: Double) it wouldn';t type check (just like it doesn't now)
15:37:14 <conal> @go "the next 700 programming languages"
15:37:16 <lambdabot> http://www.cs.utah.edu/~eeide/compilers/old/papers/p157-landin.pdf
15:37:25 <Pseudonym> Oh, man.
15:37:29 <Pseudonym> LOL
15:37:33 <bos> yrlnry_: http://www.cs.utah.edu/~wilson/compilers/old/papers/p157-landin.pdf
15:37:38 <bos> @quote stereo
15:37:38 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
15:37:38 <lambdabot> http://tinyurl.com/2qxrr
15:37:45 <yrlnry_> Thanks.  15 years ago there was not very much WWW.
15:37:48 <LoganCapaldo> @quote trademark
15:37:49 <Pseudonym> You can still get Miranda.
15:37:49 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
15:38:21 <Pseudonym> Only about 2 or 3 people on #haskell ever used Miranda.
15:38:24 <conal> classic paper.  haskell is today's iswim.  DSELs is the main idea of the "next 700" paper
15:39:01 <bos> 15 years ago, we were all posting haiku on talk.bizarre
15:39:26 <Pseudonym> 15 years ago, I was using Orwell!
15:39:29 <allbery_b> speak for yourself :p
15:39:36 <hpaste>  conal annotated "why doesn't this work?" with "(no title)" at http://hpaste.org/3525#a2
15:39:47 <Cale> alt.religion.kibology!
15:39:52 <EvilTerran> what
15:39:54 <Pseudonym> Cale: Unexploded Kibo.
15:40:06 <Cale> hehe
15:40:11 <Pseudonym> Serdar Argic!
15:40:14 <Pseudonym> Steve Winter!
15:40:25 <Pseudonym> Robert McElwaine!
15:40:28 <Pseudonym> Man, the memories!
15:40:28 * allbery_b wwas in semi-retuirement from usenet around then
15:40:35 <LoganCapaldo> 15 yeas ago, I was learning basic? I might've been on prodigy.
15:40:46 <quicksilver> Pseudonym: I have used miranda!
15:40:55 <EvilTerran> 15 years ago, i was too young to use a computer \(O.o)/
15:41:05 <Pseudonym> quicksilver: Yup.  You, me, and one or two others.
15:41:14 <quicksilver> Pseudonym: (only because I had a mate at imperial and he needed help with his first year courses )
15:41:17 <LoganCapaldo> EvilTerran: you younger than 15?
15:41:28 <yrlnry_> Oh, it's Bryan O'Sullivan.
15:41:32 <EvilTerran> :P
15:41:33 <yrlnry_> I just made the connection.
15:41:46 <quicksilver> ZOMG! It's Bryan O'Sullivan!
15:41:47 <yrlnry_> 15 years ago you were a mewling newbie!
15:42:03 <EvilTerran> LoganCapaldo, okay, too young to program. it's kinda tricky to write code when you can't write.
15:42:16 <EvilTerran> (for "write", include "speak", "type", etc)
15:42:28 <quicksilver> pascal was my first language
15:42:32 <quicksilver> english took me years longer
15:42:37 <mrd> i think i was learning C 15 years ago
15:42:40 <_ry> is there a very simple technique for putting some assertions into a module? For example, to check that 1+1 = 2 or so
15:42:51 <allbery_b> QuickCheck?
15:42:59 <Pseudonym> bos: So you'd be the only person on #haskell who's given a Google Tech Talk, then?
15:43:03 <mrd> ?check \_ -> 1+1=2
15:43:03 <lambdabot>  Parse error at "=2" (column 10)
15:43:11 <bos> Pseudonym: i guess
15:43:14 <faxathisia> > 1+1==2
15:43:16 <lambdabot>  True
15:43:23 <mrd> ?check \_ -> 1+1==2
15:43:24 <lambdabot>  Add a type signature
15:43:24 <Cale> 15 years ago was around when I started.
15:43:32 <mrd> ?check \_::Unit -> 1+1==2
15:43:33 <lambdabot>  Parse error at "::Uni..." (column 3)
15:43:33 <EvilTerran> my parents weren't particularly CS types, unfortunately, so I wasn't taught to program before i was taught a natural language
15:43:34 <quicksilver> _ry: how often when writing a module do you feel the need to check that 1+1 is 2?
15:43:36 <mrd> blah!!!
15:43:38 <quicksilver> _ry: ;)
15:43:50 <Pseudonym> bos: Note that of all the things in your career, for some reason that's the one I chose to mention.
15:43:53 <LoganCapaldo> @check (\_ -> 1 + 1 == 2) :: (() -> Bool)
15:43:54 <lambdabot>  OK, passed 500 tests.
15:43:57 <Pseudonym> My priorities are skewed.
15:44:07 <Cale> On Mercurial?
15:44:15 <LoganCapaldo> @scheck (\_ -> 1 + 1 == 2) :: (() -> Bool)
15:44:16 <lambdabot>   Completed 1 test(s) without failure.
15:44:20 <bos> Cale: yes
15:44:27 <LoganCapaldo> Proof by exhaustion! :)
15:44:31 <mauke> @check 1+1 == 2
15:44:32 <lambdabot>  OK, passed 500 tests.
15:44:46 <bos> Pseudonym: well, it's particularly easy to find on google :-)
15:44:50 <mauke> @scheck 1+1 == 2
15:44:51 <lambdabot>   Completed 1 test(s) without failure.
15:44:53 <LoganCapaldo> @check True -- this doesn't seriously work?
15:44:54 <lambdabot>  OK, passed 500 tests.
15:45:02 <Pseudonym> bos: Well, yeah, but I'd already seen it. :-)
15:45:07 <faxathisia> @check otherwise
15:45:09 <lambdabot>  OK, passed 500 tests.
15:45:39 <LoganCapaldo> I'm really surprised they wroe the code to enable that
15:45:43 <LoganCapaldo> *wrote
15:45:52 <_ry> but how should i group a bunch of tests like 1+1==2 together and run them? is there a pattern for this?
15:45:54 <bos> Pseudonym: should i die happy, then? i am preserved in the amber of google video?
15:45:55 <EvilTerran> what 500 tests? wouldn't it run out?
15:46:17 <faxathisia> EvilTerran: haha
15:46:20 <Pseudonym> bos: If you want to.
15:46:21 <EvilTerran> like in the () case it only does one test, i mean
15:46:31 <EvilTerran> i'd expect it to only do two tests in the Bool case
15:46:36 <TSC> @scheck True
15:46:38 <lambdabot>   Completed 1 test(s) without failure.
15:46:40 <LoganCapaldo> That's what smallcheck does
15:46:42 <oerjan> LoganCapaldo: it's probably a side effect of some instance a to instance b -> a thing; you need plain Bool to start
15:46:53 <LoganCapaldo> oerjan: ah that makes sense
15:47:02 <sjanssen> @check \() -> True
15:47:04 <lambdabot>  OK, passed 500 tests.
15:47:22 <quicksilver> EvilTerran: it does two in the Bool -> case
15:47:26 <EvilTerran> ah, i see. missed the s on Logan's @scheck lines above
15:47:33 <quicksilver> EvilTerran: but only one in the Bool case :)
15:47:44 <quicksilver> EvilTerran: "Bool -> " /= "Bool"
15:47:50 <EvilTerran> so i see
15:47:53 <mauke> @scheck id
15:47:53 <lambdabot> Add a type signature
15:48:13 <mauke> @scheck \x -> x ::Bool
15:48:14 <lambdabot>   Failed test no. 2. Test values follow.: False
15:50:52 <EvilTerran> @scheck ap (&&) not
15:50:53 <lambdabot>   Failed test no. 1. Test values follow.: True
15:51:00 <EvilTerran> @scheck ap (||) not
15:51:01 <lambdabot>   Completed 2 test(s) without failure.
15:51:03 <EvilTerran> rather
15:51:34 <mauke> @scheck max`ap`not
15:51:35 <lambdabot>   Completed 2 test(s) without failure.
15:52:12 <EvilTerran> @scheck \x y -> x `max` y == x || y
15:52:14 <lambdabot>   Completed 4 test(s) without failure.
15:53:02 <twanvl> conal: Do you think it would be possible to do your TV/DeepArrow stuff with InvArrow?
15:53:19 <johan___> given a coordinate (x,y) find all it's neighbours (x + 1, y), (x, y + 1) etc in a list. can i do that with list comprehensions or sequence or something?
15:54:04 <oerjan> _ry: it's a bit awkward since not all the things you test need have the same type, so you cannot easily make a list of them.  But you can write a list of check statements in a do expression
15:54:10 <conal> twanvl: hm.  the DeepArrow class contains fstA, which InvArrow doesn't have.  but i'm not sure it's necessary.  let me noodle a bit.
15:54:28 <twanvl> conal: Maybe RefArrow?
15:54:50 <conal> twanvl: RefArrow pointer?
15:55:06 <mauke> > let x = 10; y = 20 in [ (x + a, y + b) | a <- [-1, 0, 1], b <- [-1, 0, 1] ]
15:55:09 <lambdabot>  [(9,19),(9,20),(9,21),(10,19),(10,20),(10,21),(11,19),(11,20),(11,21)]
15:55:25 <twanvl> arrRef :: (a -> b) -> (b -> a -> a) -> (a ~> b)
15:55:30 <twanvl> functional references
15:55:32 <Saizan> ?where DeepArrow
15:55:33 <lambdabot> I know nothing about deeparrow.
15:55:33 <hpaste>  _ry pasted "is there a better way to write my tests? I don't know where it fails" at http://hpaste.org/3526
15:56:21 <conal> @wiki DeepArrow
15:56:22 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
15:57:13 <jberg> hey. give a coordinate (x,y) generate a list with its neighbours (x + 1, y) (x, y + 1) etx
15:57:23 <conal> twanvl: arrRef's arguments are getter & setter?
15:57:30 <twanvl> yes
15:57:50 <jberg> can i do that in some neat way with list comprehensions or sequence or something?
15:58:02 <mrd> why not just a list?
15:58:12 <mrd> etc? what does that mean here
15:58:24 <conal> twanvl: i've been wondering about functional references and TV/Eros.  the main idea of "deep application" is kind of like functional references, but not quite.
15:58:57 <conal> in particular, arrRef's don't seem to have a way to do "result", i.e., modify a function's result.
15:59:04 <conal> like first & second, but for functions.
15:59:10 <LoganCapaldo> > [ (f x, g y) | (x, y) <- [(2,3)] , f <- [ (+1), (-1), id ], g <- [ (+1), (-1), id ] ]
15:59:11 <lambdabot>   add an instance declaration for (Num (a -> a))
15:59:12 <lambdabot>     In the expression: (- 1)...
15:59:28 <LoganCapaldo> > [ (f x, g y) | (x, y) <- [(2,3)] , f <- [ (+1), (subtract 1), id ], g <- [ (+1), (subtract 1), id ] ]
15:59:30 <lambdabot>  [(3,4),(3,2),(3,3),(1,4),(1,2),(1,3),(2,4),(2,2),(2,3)]
15:59:44 <jberg> LoganCapaldo: ah neat
15:59:45 <conal> but a simple generalization of function references would, i think: arrRef :: (a -> b) -> ((b->b) -> a -> a) -> (a ~> b).
16:00:20 <conal> well, that's not quite right.  there can't be a getter for a function's result
16:00:40 <conal> the ideas are tantalizingly similar, but i don't know what the relationship is.
16:03:23 <hpaste>  oerjan annotated "is there a better way to write my tests? I don't know where it fails" with "one way" at http://hpaste.org/3526#a1
16:03:24 <conal> twanvl: InvArrow couldn't do funF & funS, since they're not invertible.  but those methods are really there to implement funFirst, funSecond (see the Eros paper).
16:03:50 <ddarius> bos gave a google tech talk?
16:04:08 <twanvl> But can TV implement InvArrow at all?
16:04:18 <oerjan> > findIndices not [a^2 > 4 | a <- [-10..10]]
16:04:20 <lambdabot>  [8,9,10,11,12]
16:04:32 <bos> ddarius: yeah, a year or two ago
16:05:19 <conal> twanvl: TV, not DeepArrow?
16:05:28 <ddarius> bos: On?
16:05:39 <bos> ddarius: mercurial
16:05:45 <ddarius> Ah.
16:05:54 <oerjan> _ry: see paste
16:06:16 <twanvl> TV is the thing you needed DeepArrow for, right?
16:06:21 <conal> bos: how does one get invited to do a google tech talk?  i'm going to give talks at apple & intel next week.  i'd love to meet google folks as well.
16:06:31 <_ry> oerjan: ah, okay cool
16:06:41 <conal> twanvl: no. DeepArrow and TV are needed for Eros.
16:06:50 <bos> conal: what are you going to be talking about?
16:07:15 <_ry> @doc findIndices
16:07:15 <lambdabot> findIndices not available
16:07:19 <conal> Eros as the talk.  then individually about data parallel graphics etc.
16:07:47 <conal> bos: where do you work?
16:07:55 <sjanssen> oh, you know
16:08:05 <oerjan> @index findIndices
16:08:05 <bos> conal: the tangible values stuff? ok.
16:08:05 <lambdabot> Data.List
16:08:11 <jberg> LoganCapaldo: do you know how to translate that to lisp?
16:08:24 <conal> bos: yes, tangible functional programming.
16:08:26 <LoganCapaldo> um
16:08:46 <conal> it's the non-textual interface to tangible values (TVs).  there's also a programmatic interface.
16:08:50 <LoganCapaldo> concat + map + lambda + funcall
16:08:58 <LoganCapaldo> it won't be nearly as pretty
16:09:00 <bos> conal: i can have a word with some googlers. i doubt they could pull something together on such short notice; they have a rather busy pipeline. but i'll see.
16:09:11 <conal> bos: you work at google?
16:09:13 <LoganCapaldo> but it's pretty simple to transform mechanically
16:09:14 <bos> conal: i work at linden lab.
16:09:20 <conal> bos: what's that?
16:09:36 <conal> bos: oh -- second life?
16:09:45 <bos> conal: right
16:09:54 <LoganCapaldo> of course in lisp there's probably a way to do it with loop in a tenth of the code ;)
16:09:55 <conal> bos: neat!
16:10:00 <jberg> LoganCapaldo: ok. Im still a bit confused how that monad magic works to try the different combinations
16:10:22 <conal> bos: and you have some kind of google connection?
16:10:23 <Pseudonym> Linden is like a mini-Google, in the sense that you're surrounded by smart people.
16:10:38 <bos> conal: i just know some googlers, is all
16:10:49 <twanvl> if you want to replace some of DeepArrow (say curry,uncurry,swap,assoc) with InvArrow, then everything that is an instance of DeepArrow now should become an instance of InvArrow
16:11:14 <conal> bos: got it.  btw, were you at icfp?
16:11:42 <bos> conal: no, between the book, job, and kids, i ran out of hours in the month.
16:12:16 <conal> bos: sure.  the talk videos should be available at some point.
16:13:11 <conal> twanvl: is InvArrow a class?  do you mean i could derive DeepArrow from InvArrow?
16:13:44 <twanvl> class InvArrow (~>) where arrInv :: (a -> b) -> (b -> a) -> (a ~> b)
16:14:00 <conal> twanvl: that's it?
16:14:11 <twanvl> yes
16:14:24 <conal> i read "there & back again", but not recently
16:14:27 <SamB_XP> twanvl: interesting
16:14:44 <twanvl> with a Category/Morphism/Compositor/whatever-you-want-to-call-it superclass
16:15:36 <conal> twanvl: okay.  i'm looking at the paper now.  i see BiArrow is a subclass of Arrow adding <--> (arrInv) and inv
16:16:03 <twanvl> It is not really a subclass, more like a superclass
16:16:37 <ddarius> bos: How is the book coming?
16:16:57 <conal> twanvl: it's neither, since BiArrow is missing arr and Arrow is missing inv, right?
16:17:10 <bos> ddarius: almost halfway through
16:17:12 <twanvl> Yes
16:17:25 <bos> i need to post some new chapters soon.
16:17:26 <twanvl> inv should go in a subclass, arrInv in a superclass
16:17:45 <bos> our goal is to have 16 chapters in first draft form by november 15.
16:17:46 <conal> twanvl: oh -- sure.
16:18:04 <bos> i have about 1.2 chapters to write to hit that point, and CosmicRay too i think.
16:18:20 <conal> twanvl: and some of DeepArrow could move into BiArrow/InvArrow.
16:18:41 <conal> twanvl: i'm for it.
16:18:47 <twanvl> The heirarchy can be greatly expanded
16:18:56 <twanvl> See http://code.haskell.org/category/
16:18:57 <lambdabot> Title: Index of /category
16:19:08 <conal> curry, uncurry, lAssoc, rAssoc, id.
16:19:34 <conal> and swap
16:19:56 <conal> and funR / flip
16:20:41 <conal> twanvl: "result" also
16:20:53 <twanvl> yes
16:21:59 <bos> @seen dons
16:21:59 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 2h 19m 17s ago.
16:22:16 <ddarius> bos: Good. It's been pretty quiet on the realworldhaskell.org front
16:22:22 <conal> twanvl: i also want to remove the input/output distinction from TV (& Eros) and have a single symmetric notion.  there may be a nice tie-in to inversion there.
16:23:33 <user317> @src dropWhile
16:23:33 <lambdabot> Source not found.
16:24:41 <conal> in a symmetric TV, there'd be a single thing that could act to send *or* receive any value.  for IO that'd be a bundling of putchar and getchar (for instance).  for GUIs, an input slider or an output slider.  depending on context.
16:25:14 <bos> ddarius: thank you for reminding me to blog
16:26:19 <conal> bos: though it's probably too short notice, i could be available for a google tech talk and meeting folks on wednesday of next week (nov 7).
16:26:47 <conal> bos: otherwise some other time.
16:27:31 <bos> conal: ok, i've pinged a friend who works in that team
16:27:40 <conal> bos: thanks :)
16:27:50 <conal> bos: "that team"?
16:28:08 <ddarius> That was my reaction.
16:28:13 <bos> the google open source team handles some of the tech talk scheduling stuff
16:28:41 <conal> bos: okay.  thanks for clarifying.
16:28:59 <conal> bos: btw, your lazy quaternions paper came up today.
16:29:23 <bos> oh, that's old. i had forgotten i even wrote it until Cale mentioned it a few months ago.
16:30:09 <bos> conal: where did it come up?
16:30:39 * ddarius effectively walked a coworker through implementing quaternions for rotations via the geometric algebra today.
16:30:47 <conal> bos: _ry and faxathisia were talking about quaternions.  i googled.
16:31:04 <bos> ah
16:31:33 <_ry> it's from this homework assignment: http://www.cs.caltech.edu/courses/cs11/material/haskell/lab3/lab3.html
16:31:35 <lambdabot> Title: CS 11: Haskell track: assignment 3, http://tinyurl.com/279zfm
16:32:04 <conal> bos: also, i'm poking into OpenGL, mainly to add 3D to Eros, and i wondered if anyone had done virtual trackball in haskell.  as i recall, quaternions are useful there.
16:32:32 <conal> ddarius: where do you work?
16:32:51 <ddarius> conal: Goodfellow AFB
16:32:56 <bos> _ry: tell your instructor that their suggestion about writing a Show instance is wrong
16:33:17 <_ry> bos: why?
16:37:34 <Cale> huh?
16:37:34 <bos> _ry: well, "wrong" would be a better way to put it. it's usual (but not required) to write Show instances so that they display in the same way as the constructor notation. i.e. show (3.0 :+ 1.0) == "3.0 :+ 1.0" for Complex
16:38:05 <Cale> Yeah, but the point is probably to make the students familiar with the Show class, and writing instances.
16:38:11 <bos> so writing "3+4i+5j+6k" looks strange, given that convention.
16:38:22 <bos> yeah.
16:38:42 <Cale> Also, quite a few things show as something other than their structure.
16:39:07 <Cale> (But not so many of the things in H98)
16:39:14 <bos> right.
16:40:13 <bos> i'm glad they teach haskell in california at all.
16:40:20 <oerjan> > 1/0
16:40:21 <lambdabot>  Infinity
16:40:43 <LoganCapaldo> > Infinity
16:40:44 <lambdabot>   Not in scope: data constructor `Infinity'
16:40:46 <LoganCapaldo> hey
16:40:55 <LoganCapaldo> Infinity's not a contructor?
16:41:03 <LoganCapaldo> Show has lied to me for the last time!
16:41:06 <omnId> LoganCapaldo: nope, just a Shown representation.
16:41:06 <bos> > read "Infinity"::Double
16:41:08 <lambdabot>  Infinity
16:41:13 <oerjan> that's sort of why i wrote that example :)
16:41:15 * LoganCapaldo takes out a hit on Show
16:41:24 <dcoutts> @slap Show
16:41:24 * lambdabot locks up Show in a Monad
16:41:26 <Cale> > 0/)
16:41:26 <lambdabot> Unbalanced parentheses
16:41:27 <Cale> > 0/0
16:41:28 <lambdabot>  NaN
16:41:36 * omnId wouldn't mind Complex Read/Show "a + bi"
16:42:18 <hpaste>  _ry annotated "is there a better way to write my tests? I don't know where it fails" with "what about this?" at http://hpaste.org/3526#a2
16:43:24 <omnId> putStrLn . printf = printf, and you'll need sequence too
16:43:33 <_ry> how can i putStrLn for each item in a list?
16:43:50 <LoganCapaldo> forM_ list putStrLn
16:44:02 <LoganCapaldo> or mapM_ putStrLn list
16:44:06 <omnId> or mapM, which is sequence (map ...)
16:44:29 <omnId> @type map print [1,2,3]
16:44:31 <lambdabot> [IO ()]
16:44:32 <conal> or remove IO altogether.
16:44:34 <omnId> @type mapM print [1,2,3]
16:44:35 <lambdabot> IO [()]
16:44:43 <omnId> @type mapM_ print [1,2,3]
16:44:44 <lambdabot> IO ()
16:44:44 <conal> _ry: you don't need any IO here
16:45:16 <omnId> drop the putStrLn from testPrint and you can get some Strings.
16:45:18 <LoganCapaldo> but I wants the IO
16:45:22 <LoganCapaldo> my precious
16:45:45 <oerjan> _ry: if you include both arguments you can show them instead of making an explicit string
16:46:01 <omnId> then you can putStrLn (unlines thoseStrings) later on.
16:46:44 <_ry> oerjan: how? show(i*i) won't give me "i * i"
16:46:54 <LoganCapaldo> but it cooooould
16:47:11 <LoganCapaldo> ooooon hlloweeeen
16:47:14 <oerjan> show i ++ " * " ++ show i
16:47:45 <oerjan> i meant by splitting the product, having both arguments available
16:47:47 <omnId> do you have i, j, and k, showing to "i", "j", and "k" elsewhere?
16:47:55 <_ry> oerjan: oh okay
16:48:22 <_ry> omnId: i = Quaternion 1 0 0 0 ; j = Quaternion 0 1 0 0
16:48:28 <_ry> etc
16:48:46 <_ry> omnId: oh, no. sorry misunderstood you.
16:48:49 <omnId> instance Show Quaternion where show (Quaternion 1 0 0 0) = "i" -- this?
16:49:09 <_ry> i could do that!
16:49:11 <LoganCapaldo> data Evil = I | J | K | Mul Evil Evil | Plus Evil Evil | ... ; instance Num Evil where ... ; instance Show Evil ...; class Ijk a where i :: a, j :: a, k, :: a ...
16:49:12 <omnId> I'd probably put the real part in the first field, though :)
16:49:13 <_ry> okay :)
16:49:59 <pgavin> I think ghc should be able to derive Monad
16:50:04 <LoganCapaldo> it can!
16:50:08 <pgavin> can it?
16:50:15 <LoganCapaldo> ... for newtypes ...
16:50:18 <pgavin> ok
16:50:21 <pgavin> that's all I want
16:50:32 <pgavin> is there a special flag needed?
16:50:33 <LoganCapaldo> great! :)
16:50:40 <LoganCapaldo> I don't know
16:50:45 <pgavin> ok, I'll look it up
16:50:51 <LoganCapaldo> glasgow-exts definitely does it
16:50:51 <dcoutts> pgavin: {-# LANGUAGE GeneralizedNewtypeDeriving #-}
16:51:09 <dcoutts> pgavin: or the same in the extensions field in your .cabal file
16:51:33 <pgavin> ah, ok
16:51:50 <pgavin> dcoutts: I'm looking at your dep code
16:51:59 <pgavin> dcoutts: is there anything I should pay attention to?
16:52:14 <dcoutts> pgavin: oh great, btw I just posted another item on doing parallel builds
16:52:20 <pgavin> I say that :)
16:52:25 <pgavin> s/say/saw/
16:52:31 <dcoutts> pgavin: and yesterday I posted on specifying make
16:52:33 <pgavin> nice ideas
16:52:44 <dcoutts> some informal properties we'd like to formalise
16:53:09 <pgavin> yeah, I understand...
16:53:27 <pgavin> basically you want a set of base test-cases that show the algorithm does what we want
16:53:45 <pgavin> and make the algorithm wrap the users monad to provide added functionality
16:54:19 <pgavin> so we can test the algorithm independently of what the actual objects being manipulated are
16:54:42 <dcoutts> pgavin: right
16:54:46 <LoganCapaldo> It would be cooler if it was {-# LANGUAGE CunningNewtypeDeriving #-}
16:55:01 <dcoutts> pgavin: and so we can experiment with different base monads
16:55:05 <pgavin> right
16:55:29 <dcoutts> pgavin: eg ones that provide optimisations like caching file stats etc
16:55:43 <pgavin> right, and dependencies, etc.
16:56:25 <dcoutts> oh, you mean caching dependencies
16:56:35 <pgavin> yeah
16:56:37 <dcoutts> right
16:56:41 <ddarius> bos, dcoutts, dons: You may be interested in the new section of http://www.haskell.org/haskellwiki/Performance/Monads about what roconnor, Saizan, ski and I were talking about the other day.
16:56:43 <lambdabot> Title: Performance/Monads - HaskellWiki
16:56:45 <nominolo> @src Maybe fail
16:56:45 <lambdabot> fail _      = Nothing
16:57:14 <bos> ddarius: is this about CPS transformation?
16:57:23 <ddarius> bos: Yes.
16:57:27 <bos> yes, ok. cool.
16:57:40 <dcoutts> pgavin: eg in my example so far I was caching deps in a .dep file. But it'd make more sense to cache them in some central db managed by the build monad.
16:57:56 <dcoutts> pgavin: so we have fewer little files
16:58:08 <pgavin> dcoutts: right, better disk utilization
16:58:13 <bos> ddarius: thanks for the pointer, very nice.
16:58:13 <dcoutts> pgavin: so yes, that's an optimisation that we could provide later
16:58:22 <dcoutts> pgavin: well, mainly better throughput
16:58:36 <dcoutts> pgavin: latency is the killer with disk IO
16:58:44 <pgavin> right
16:58:50 <dcoutts> reading one larger file is so much faster than 100's of little ones
16:59:05 <pgavin> and one big file caches better
16:59:08 <dcoutts> yes
16:59:27 <dcoutts> anyway, don't need to think about that yet, it's just an optimisation
16:59:37 <pgavin> ok, so...
16:59:40 <ddarius> bos: I should probably at least type check the code though...
16:59:52 <pgavin> where should I focus if I'm going to write code?
17:00:20 <ddarius> (That said I did implement ErrorCPS and Error2CPS correctly the first time the other day, as in it compiled the first time.)
17:00:23 <dcoutts> ddarius: yes, I've looked before at unrolling mtl, it can be a massive boost, it's not just to do with inlining, unrolling also allows you to improve the data representation of your monad
17:00:38 <ddarius> dcoutts: I was specifically referring to section 2.
17:00:40 <dcoutts> ddarius: eg by uncurrying the function that represents your monad
17:00:57 <dcoutts> ddarius: sure, but it's an interesting point I think, especially with Cont monads
17:01:44 <kunal_> hi
17:01:59 <kunal_> how does one create temporary variables in a function?
17:02:08 <dcoutts> ddarius: when you stack things on Cont you end up with a monad that has things like: ((a,b) -> c) -> (a,b) -> c
17:02:23 <mauke> kunal_: let
17:02:28 <dcoutts> ddarius: which one can obviously optimise by unpacking that (,)
17:02:51 <dcoutts> ddarius: the monad in Data.Binary.Put is an example of that. It's an unrolled stack of StateT ContT IO
17:03:12 <kunal_> mauke: i don't want to use let. is there no way to create a temporary variable other than let?
17:03:14 <ddarius> dcoutts: Why the ContT?
17:03:32 <dcoutts> ddarius: to produce the list of chunks lazily
17:03:34 <Jiten> kunal_: I use: func a = b*5 where b = a + 2
17:03:47 <Jiten> kunal_: that fit your idea of temporary variables?
17:03:49 <mauke> kunal_: where
17:04:03 <dcoutts> ddarius: we do some strict IO to write out a chunk, then flush the chunk, suspend and then write out the next when the consumer forces the next chunk.
17:04:13 <conal> kunal_: watch it though, since "where" goes with declarations, not expressions.
17:04:28 <Jiten> it does essentially the same as let though, just different syntax.
17:04:47 <dcoutts> ddarius: so the continuation is the tail of the list of chunks basically, it allows us to generate the chunks lazily.
17:05:15 <dcoutts> ddarius: I'm sure the unrolling in that case was worth well over 3x factor speed up
17:05:25 <omnId> > x + x where x = 5 -- not valid
17:05:25 <lambdabot>  Parse error at "where" (column 7)
17:05:27 <dcoutts> ddarius: I'm thinking more like 10x or more.
17:05:29 <Jiten> kunal_: you should note about haskell that it doesn't actually have variables :)
17:05:31 <omnId> > let {result = x + x where {x = 5}} in result -- here, the where clause is attached to the 'result' declaration
17:05:33 <lambdabot>  10
17:06:07 <dcoutts> ddarius: from initial prototype based on stacked monads in mtl to the current impl we got a 600x speedup
17:06:12 <dcoutts> or thereabouts
17:06:12 <omnId> Jiten: *mutable* variables, and yes it does you silly person!
17:06:21 <_ry> @index join
17:06:21 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
17:06:29 <ddarius> 600 times!
17:06:51 <dcoutts> ddarius: not all of that is due to mtl of course
17:07:00 <Jiten> omnId: a variable is not a variable if it's not mutable :)
17:07:03 <_ry> is there something that can do this:    join "," ["this", "is", "a", "list"]
17:07:07 <omnId> Jiten: incorrect!
17:07:10 <dcoutts> ddarius: I'd not realised all of the stuff you note in point 2 btw.
17:07:12 <Botje> _ry: intersperse
17:07:16 <mauke> _ry: yes, concat and intersperse
17:07:34 <omnId> Jiten: a programmer's usual notion of "variable" is not exactly right.
17:07:36 <dcoutts> ddarius: in particular that cont allows you to use the underlying monad more selectively, for just some operations rather than for everything
17:07:37 <mauke> > concat $ intersperse ","  ["this", "is", "a", "trap"]
17:07:39 <lambdabot>  "this,is,a,trap"
17:07:40 * conal wonders why the word "variable" is used in math.
17:08:00 <dcoutts> ddarius: I think that point could be quite significant for stacking
17:08:11 <omnId> let f x = x + 1 in (f 3, f 4) -- here, x "varies".  It takes on the values of 3 and 4.
17:08:24 <omnId> > let f x = x + 1 in (f 3, f 4)
17:08:25 <lambdabot>  (4,5)
17:08:27 <Jiten> omnId: The other way I could think of to express that is that haskell doesn't have variables, just functions, some of them constant.
17:08:38 <ddarius> dcoutts: I'm not quite sure how it works out for stacked CPS implemented monads, though probably still better than a "direct" implementation.
17:09:34 <ddarius> I'm not sure if Cont (StatetT s Maybe r) a is better or worse than StateTCPS s MaybeCPS a.
17:09:45 <ddarius> I guess I should implement them and try it.
17:09:57 <dcoutts> ddarius: so errors are a really good example, I sometimes worry about introducing a maybe monad since it'll make things slower by checking for failure all the time. for performance I'd sometimes just use calls to error.
17:10:39 <Saizan> ddarius: Cont (StateT s [] r) a is 2x better than StateT s [] a in Cale's sudoku solver
17:10:40 <dcoutts> ddarius: so if we can make the error checking cheaper so that we only have to pay the cost of an error when one happens, like with the pure error function, that'd be great
17:11:10 <ddarius> Saizan: Yes, that's the easy part.  But what if we stack CPS implemented ones rather than CPS implementing a stack?
17:11:49 <omnId> Jiten: but yes, I usually just call everything "names" which are bound to values, since "variable" is such a loaded word to the usual programmer :)
17:12:16 <ddarius> dcoutts: Indeed.  Maybe/Either are particularly good and clear examples.  How the continuation code works is easily understood (relatively speaking) and it is easy to see what problem is being solved.
17:13:07 <bos> ddarius++
17:13:50 <dcoutts> @arr!
17:13:50 <lambdabot> I want me grog!
17:13:53 <dcoutts> ddarius++
17:13:54 <conal> Jiten: from another angle, all haskell functions are constant, as are all haskell values.
17:14:11 <omnId> conal: Jiten said that :P
17:14:29 <twanvl> I wonder how State s a compares with IORef s -> IO a
17:14:35 <conal> omnId: you sure?
17:15:06 <ddarius> twanvl: Indeed, I've thought that.  I never benchmarked my State implementation that used ReaderT (STRef s s') (ST s)
17:15:24 <omnId> conal: I think I see the distinction now.
17:15:38 <Cale> Variables don't have to be mutable to take on different values
17:15:56 <Cale> For example map (\x -> x^2) [1..10]
17:16:05 <Cale> What value does x have in that?
17:16:24 <omnId> 1 though 10, once each.
17:16:32 <Cale> right
17:16:49 <conal> also 11
17:16:52 <conal> just not in that example.
17:16:56 <Cale> (This is mostly directed at Jiten)
17:16:57 <ddarius> dcoutts: I'd like to reimplement the MTL using this CPS style and seeing how it fares.  Even if it does only 10% better that would be rather significant as practically all Haskell code uses the MTL.
17:17:12 <bos> ddarius: that would be great.
17:17:15 <dcoutts> ddarius: indeed
17:17:18 <Jiten> conal: the constant you mean is the norm in haskell, so there isn't much sense in talking about that... except for introducing the concept to people.
17:17:40 <conal> Jiten: which "constant" do you mean?
17:17:47 <dcoutts> ddarius: I've wondered before about optimising mtl, though I was thinking more of representation changes when one stacks monads
17:18:33 <conal> how about this: imperative languages have a semantic notion of variable, while functional languages have no semantic notion of variable, just a syntactic one.
17:18:37 <_ry> sorry for using you all as my personal documenation machine. but haskell.org seems to be down. how do I find all the elements of a list that satisfy a certain boolean function?
17:18:49 <conal> _ry: filter
17:18:55 <dcoutts> ddarius: and perhaps look at the core output of a few examples and see if there's anything in mtl that obviously ought to be inlined but is not getting inlined
17:19:04 <Jiten> conal: constant as in what "constant function" means in math or in other words, if f(x) is constant, f'(x) = 0
17:19:05 <mauke> @hoogle (a -> Bool) -> [a] -> [a]
17:19:09 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
17:19:09 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
17:19:09 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
17:19:10 <Cale> In imperative languages, most variables are used to refer to mutable cells.
17:19:11 <mauke> _ry: ^
17:19:15 <hpaste>  LoganCapaldo annotated "is there a better way to write my tests? I don't know where it fails" with "No strings, and I think it's all H98" at http://hpaste.org/3526#a3
17:19:18 <Cale> Which is where the confusion arises, I think
17:19:35 <_ry> cool
17:19:37 <LoganCapaldo> Note that my math is totally lousy
17:19:44 <conal> Jiten: so equal to const x for some x.
17:19:47 <Cale> People confuse the variable, which is just a name for something, with the cell, which is what is being referred to.
17:20:17 <conal> Cale: the syntactic and semantic notions.
17:20:21 <ddarius> dcoutts: I'm not sure if there is a reasonable way to "auto" flatten monad stacks.
17:20:34 <Jiten> Cale: my note about variables was to kunal_ since he clearly had the programmers idea of variable.
17:20:40 <ddarius> dcoutts: Using things within Haskell/GHC.
17:20:42 <conal> part of a wider syntax/semantics confusion
17:20:43 <Cale> In C, if I write "int x", I'm creating a cell for storing an int value, together with a variable x, which immutably(!) refers to it.
17:21:00 <ddarius> readIORef x
17:21:29 * ddarius is very keen on explicit reference types.
17:21:49 <dcoutts> ddarius: my thought was that you'd extend the compiler, you'd say something like: newtype MyMonad a = MyMonad {-# UNPACK #-} (StateT (ContT Blah) Blah a)
17:22:14 <Jiten> conal: yes, that's right.
17:22:18 <ddarius> dcoutts: Yeah, right now I was wonder if a type level RULES pragma would provide what was needed.
17:22:43 <dcoutts> ddarius: then inside the MyMonad newtype wrapper you could use an optimised representation of the type, doing obvious things like unpacking structures in arguments
17:23:10 <dcoutts> ddarius: and you may have to convert between the representations when you apply on unwrap the newtype wrapper
17:23:21 <dcoutts> ddarius: type functions might give you that
17:24:11 <dcoutts> ddarius: we might be able to calculate the desired representation using the new type functions language extension
17:24:14 <ddarius> dcoutts: Actually, they could.
17:24:32 <dcoutts> ddarius: in a similar way to the way type functions are used to calculate the representation of parallel arrays
17:25:10 <ddarius> Yeah, I think that that may be doable.
17:25:16 <dcoutts> ddarius: presumably we'd be looking for some canonical representation in Cont style
17:26:09 <dcoutts> ddarius: then we transform things like Cont (a,b) which normally would be (((a,b) -> cont) -> (a,b) -> cont) into ((a -> b -> cont) -> a -> b -> cont)
17:26:30 <dcoutts> ddarius: and do similar things for other state structures types, ErrorT etc
17:26:38 <sjanssen> @src State
17:26:38 <lambdabot> Source not found. Just try something else.
17:26:42 <dcoutts> certainly worth investigating
17:27:17 <sjanssen> aren't most of the Monads represented as newtypes anyway?
17:28:00 <sjanssen> it seems that they'll already be in the optimal representation anyway
17:28:17 <dcoutts> sjanssen: oh no they're not :-)
17:28:34 <dcoutts> sjanssen: there's no change of representation when you use a newtype
17:28:38 <sjanssen> ReaderT r (State s a) is (r -> s -> (a, s))
17:28:45 <sjanssen> isn't that perfect?
17:29:03 * dcoutts ponders
17:29:14 <dcoutts> sjanssen: well even if that example is good, there are others which are not
17:29:34 <dcoutts> basically when you end up with (r -> (s1,s2) -> (a, s))
17:29:36 <ddarius> sjanssen: There is clearly some overhead from stacked monads.
17:29:48 <dcoutts> where you could get (r -> s1 -> s2 -> (a, s))
17:31:45 <dcoutts> sjanssen: so yes, that example is pretty good, except when the state or reader types are compound and used a lot
17:31:56 <dcoutts> where we could benefit from unpacking the structure
17:32:29 <sjanssen> perhaps with a monad like StrictState
17:32:41 <dcoutts> that will not help
17:32:50 <sjanssen> right
17:32:52 <dcoutts> unless we change the representation of the monad
17:33:04 <dcoutts> which newtype does not let us do directly
17:33:04 <sjanssen> but if you could unpack the StrictState, there will be big wins
17:33:24 <dcoutts> we have to manually unroll the types and make the obvious representation improvements
17:33:58 <pgavin> dcoutts: I'm going to sleep soon... did you have any luch with those other gtk2hs patches?
17:34:00 <sjanssen> eg. StrictState Int a should be Int# -> (a, Int#)
17:34:05 <pgavin> s/luch/luck/ :)
17:34:23 <dcoutts> pgavin: yes, finally, I had some problem which turned out to be transient issue solved with make clean
17:34:46 <pgavin> dcoutts: ok, good... I think I sent another bundle to the list
17:35:28 <dcoutts> pgavin: oh right
17:35:52 <pgavin> this bundle is much better than the last though :)
17:36:10 <dcoutts> sjanssen: right
17:36:41 <dcoutts> sjanssen: and we were speculating that that's the kind of representation transformation we could calculate using type functions
17:37:07 <nominolo> why doesn't a -> (b,c) -> d get optimized to a -> b -> c -> d via constructor specialization?
17:37:22 <SamB_XP> @kind (->)
17:37:23 <lambdabot> ?? -> ? -> *
17:37:35 <dcoutts> pgavin: when did you send the improved patch bundle?
17:37:45 <sjanssen> dcoutts: it may be difficult to get Int# with type functions -- they can't be polykinded
17:37:46 <SamB_XP> especially if you could have type functions of kind * -> ?
17:37:55 <pgavin> dcoutts: hmm, nevermind
17:37:57 <dcoutts> pgavin: I'm trying to work out which one I applied
17:38:04 <dcoutts> pgavin: ok
17:38:06 <pgavin> dcoutts: looks like you got that one
17:38:12 <dcoutts> pgavin: ok great
17:38:19 <_ry> i want to do something like where I show a Double, but if it's an integer i show it like an integer
17:38:22 <pgavin> dcoutts: looks like you skipped one which fooled me :)
17:38:23 <SamB_XP> 'twould be SOOO LEET
17:38:33 <dcoutts> sjanssen: hmm, perhaps it can be in the result of a type function rather than in the arg
17:39:46 <nominolo> _ry: use a type class
17:39:52 <pgavin> ok, off to bed, gnight all
17:39:56 <dcoutts> nominolo: the problem is that we have to pack one of those into the newtype and pass it on as the monad value. So that newtype has a specific type and a specific generic representation.
17:39:57 <nominolo> _ry: btw, show should do that
17:40:03 <omnId> _ry: show d = if isIntegral d then show (turnIntoInteger d) else show d -- now write isIntegral and turnIntoIntegral
17:40:17 <dcoutts> nominolo: so we cannot optimise it without looking at all the places that manipulate things inside that newtype
17:40:27 <mauke> > let d :: Double; d = 42 in printf "%g" d :: String
17:40:29 <lambdabot>  "42.0"
17:40:36 <mauke> hmm. that looks broken
17:40:40 <nominolo> dcoutts: i see.
17:40:58 <dcoutts> so although a bunch of monad operations all in one function could be optimised locally, when we pass the monad value on it has to go back into the generic representation
17:41:10 <SamB_XP> > show (1 :: Double)
17:41:11 <lambdabot>  "1.0"
17:41:30 <dcoutts> nominolo: you can see this problem in the Binary serialisation monad, we're having to box up arguments which we'd prefer to keep unboxed
17:41:36 <nominolo> dcoutts: but we could do so if we don't export the newtype constructor, don't we?
17:42:08 <dcoutts> nominolo: if we manually changed the representation inside the newtype to use Int# -> etc etc then yes
17:42:25 <dcoutts> nominolo: but we can't get it done for us nicely with an {-# UNPACK #-}
17:42:50 <nominolo> hm.  i have to think about this.  tomorrow.
17:43:04 <dcoutts> (a -> Buffer -> [B.ByteString]) -> Buffer -> [B.ByteString]
17:43:10 <dcoutts> there's an example
17:43:34 <dcoutts> we actually have to allocate a Buffer constructor, rather than passing on the Buffer components unboxed
17:43:55 <dcoutts> we could manually change the representation to:
17:44:07 <_ry> omnId: thanks
17:44:10 <dcoutts> (a -> Addr# -> ForeignPtrContents -> Int# -> Int# -> Int# -> [B.ByteString])
17:44:10 <dcoutts>                      -> Addr# -> ForeignPtrContents -> Int# -> Int# -> Int# -> [B.ByteString]
17:44:31 <dcoutts> but we'd rather not do that manually, it's annoying and ugly and non-portable
17:44:35 <dcoutts> we'd prefer to say:
17:44:42 <dcoutts> newtype Put a = Put {
17:44:42 <dcoutts>         runPut :: (a -> {-# UNPACK #-} !Buffer -> [B.ByteString])
17:44:42 <dcoutts>                      -> {-# UNPACK #-} !Buffer -> [B.ByteString]
17:44:54 <nominolo> yeah
17:44:55 <dcoutts> and have ghc derive the above representation
17:45:52 <dcoutts> I sent in a proposal with that suggestion, SPJ thought it was not a bad idea, but it's effort to implement
17:46:54 <nominolo> sounds useful, yes
17:57:11 <Nucleo_> Is haskell.org page down?
17:57:35 <ddarius> Apparently.
17:57:40 <Cale> Nucleo_: not for me
17:57:54 <hpaste>  _ry pasted "quaternions. any criticisms?" at http://hpaste.org/3527
17:57:57 <Cale> It works just fine here.
17:58:25 <Nucleo_> Odd. It's not responding to ping for me.
17:58:35 <TomMD> I can't bring it up
17:58:38 <Cale> 128.36.229.215
17:58:40 <ddarius> _ry: Is "Quaternions are ugly" a valid criticism?
17:58:45 <_ry> :)
17:58:47 <Cale> Check that it's resolving correctly.
17:58:58 <Cale> ddarius: How are they ugly?
17:59:02 <allbery_b> haskell.org working fine for me
17:59:55 <TomMD> Nucleo_: US east coast?
17:59:56 <Nucleo_> cale: it resolves to that for me too.
17:59:59 <ddarius> Cale: I'm just a Geometric Algebra fan.  Though they are fine as the only associative non-commutative algebra.
18:00:09 <Nucleo_> TomMD: yes, NYC, roadrunner
18:00:10 <mauke> yay, haskell.org is back
18:00:30 <_ry> ddarius: is that true?
18:00:43 <ddarius> _ry: I'm missing some adjective.
18:00:51 <TomMD> @quote Cale
18:00:51 <lambdabot> Cale says: Ruby is kind of a nice language, for an imperative object oriented language that isn't smalltalk.
18:00:58 <_ry> what about n dim matrices or something
18:02:03 <ddarius> Associative non-commutative division ring containing the real numbers as a subring.
18:02:49 <Cale> It's the only noncommutative associative real normed algebra (with a multiplicative identity).
18:03:53 <ivanm> in ghci, is there any way of telling what variables are hanging around?
18:04:19 <mauke> ivanm: press tab
18:04:43 <ivanm> mauke: and that enters in some whitespace...
18:04:58 <mauke> hmm. no readline/tab completion?
18:05:17 <ivanm> not by the looks of things...
18:05:41 <ivanm> I'm running it within emacs, btw...
18:07:40 <Cale> mauke: tab completion completes filenames here
18:07:54 <Cale> er, oh, no it doesn't anymore :)
18:07:57 <ivanm> heh
18:08:01 <Cale> That's cool.
18:08:12 <Cale> (In 6.4 I believe it completed filenames)
18:08:19 <_ry> oh haskell is so much fun. i want to make real things with it soon. i hope i get better.
18:08:24 <ivanm> well, running it within an xterm results in less memory usage than running it within emacs (about 10 MB less)
18:10:09 <TSC> ivanm: Try  ":show bindings"
18:10:53 <ivanm> TSC: comes up with "it :: ()"
18:11:15 <ivanm> I'm asking cos I thought maybe somehow some variables are left hanging around...
18:11:26 <_ry> is there a haskell EcmaScript interpreter?
18:11:26 * ivanm is pretty sure he's killed off all his threads...
18:18:44 <TomMD> Is there an example of someone using the Error monad and the Binary monad together?
18:18:47 <Cale> hmm, that's a good question. We had someone in here who was working on the next version of EcmaScript
18:19:18 <sorear> TomMD: A while ago Binary used an error monad internally
18:19:32 <Cale> And IIRC there are people who are working on a Haskell -> EcmaScript compiler.
18:19:38 <TomMD> But now we can't tell the caller that something like 'put' failed.
18:19:39 <sorear> but they changed it; this being dons it's a safe bet that performance was involved
18:19:50 <TomMD> So I am needing to make a new monad like 'SafeBinary'
18:19:55 <sorear> error is faster than >>=
18:20:17 <TomMD> That will check lengths on 'get' and ensure valid internal structure during 'put' operations.
18:20:27 <TomMD> sorear: but
18:20:32 <sorear> TomMD: there is no binary monad, and if you think there is you're using the wrong binary lbirary
18:21:03 <TomMD> sorear: but 'error' will require me to use the IO monad to catch.  I would rather avoid unsafePerformIO and I want the library to be pure.
18:21:26 <sorear> TomMD: I had the same concerns.  Go plead with dons directly, please.
18:21:38 <TomMD> sorear: I mean the binary library.  I need a new library 'SafeBinary'  I am a bit tired.
18:21:48 <sorear> fair enough
18:21:51 <TomMD> @seen dons
18:21:51 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 4h 19m 9s ago.
18:25:17 <TomMD> @ask dons I've a need (and heard a number of other people agree with this) for a 'SafeBinary' library or a modification to the current Data.Binary.  I desire a pure way to catch and report errors on with put (ex: when internal state is invalid) and with 'get' it would be nice to have lengths checked automatically (in some cases).  Would you be willing to work with me on this, or perhaps give pointers for me to work on it?
18:25:17 <lambdabot> Consider it noted.
18:25:46 * KatieHuber floats gently upward
18:26:52 * omnId reminds KatieHuber about gravity
18:27:00 <KatieHuber> it just left the room
18:27:08 <omnId> oh, I see
18:27:20 <TomMD> let gravity = 0
18:27:36 <Pseudonym> You wouldn't float upward without an impulse, surely?
18:27:50 <KatieHuber> I'm an impulsive person
18:27:52 <ari> Even if you defined gravity = 0 now I'm still bound to the earlier definition
18:27:59 <Pseudonym> Ah, yes, the restoring force on your chair.
18:28:06 <Pseudonym> You push down, chair pushes back.
18:28:19 <TomMD> ari: You are assuming the earlier definition.  I, for one, don't think most people have 'gravity' in their scope.
18:28:22 <Pseudonym> If gravity were turned off, the restoring force would pushyou.
18:28:59 <omnId> Pseudonym: if gravity were turned off, you wouldn't exert any force on the chair, so it wouldn't push back.
18:29:06 <sorear> How many of us are under some kind of ceiling ATM?
18:29:24 <sorear> omnId: the chair is under compression.  EVERYTHING is springy.
18:29:24 <omnId> uh, oh, gravity has re/joined, better brace yourself KatieHuber!
18:29:31 <omnId> sorear: true.
18:29:35 * KatieHuber lands with a small thump
18:29:37 <Cale> The only force on IRC is the force of new words pushing up the old ones.
18:29:38 <TomMD> Its too cold outside, count me in the ceiling group.
18:29:53 <gravity> Sorry about that, I'm beating up my X server a bit
18:30:08 <Pseudonym> omnId: No, see, the thing is, while you're sitting on your chair, the chair is pushing back.
18:30:18 <Pseudonym> It has a certain amount of stored energy, like a spring.
18:30:25 <omnId> Pseudonym: right, the compression soreaer mentioned.
18:30:29 <Pseudonym> If you instantaneously turned off gravity, the energy would be released.
18:30:34 <Pseudonym> Pushing you away from it.
18:30:35 <omnId> sorear, even
18:30:39 <Pseudonym> Yeah.
18:33:25 <omnId> this is under the unusual circumstance of gravity instantaneously vanishing.  The compression would probably just slowly reduce if gravity itself only slowly reduced.
18:34:01 <omnId> though I suppose either is as likely as the other :)
18:34:21 <ivanm> there is no such thing as gravity, it's all just intelligent falling! :p
18:34:26 <eventualbuddha> i think the bigger problem is the forces inside the planet pushing outward, causing it to break apart. that and the atmosphere drifting away... :)
18:34:43 <mauke> gravity is a myth, the earth sucks
18:34:46 <sorear> the atsmosphere wouldn't 'drift' away
18:34:54 <eventualbuddha> sorear: why not?
18:35:05 <sorear> it's under 15 PSI pressure, it would explode away!
18:35:09 <ivanm> heh
18:35:19 * sorear should calculate this someday
18:35:24 <omnId> :)
18:35:24 <mauke> it would just fall down
18:35:32 <omnId> Just another day in #haskell
18:35:35 <mauke> I mean, if the earth can't hold its atmosphere anymore ...
18:35:57 <ivanm> there's one SF novel that had the theory that since the atmosphere has no hard and fast boundary, space must be filled with air and so you can just fly through space
18:36:11 <eventualbuddha> i think a more interesting thing to see is if the electromagnetic forces holding molecules together stopped working. everything would just dissolve...
18:36:13 <shubalub> somebody should tell nasa
18:36:22 <omnId> eventualbuddha: like the decompression you see in spacecraft in sci-fi films.
18:36:25 <Pseudonym> Yeah, they'd save money on ceramic tiles.
18:36:27 <ddarius> eventualbuddha: Seeing wouldn't work then.
18:36:44 <KatieHuber> guys, guys, problem:
18:36:50 <eventualbuddha> ddarius: obviously we'd have two physics at that point: one for the earth and one for the observers  :D
18:36:51 <KatieHuber> nobody has said "monad" for like 5 minutes
18:36:56 <allbery_b> heh
18:36:56 <ari> It would be rather difficult to fly through space at a decent speed if we had all the air in the way that we do in the atmosphere
18:37:01 <Pseudonym> You did!
18:37:19 <KatieHuber> well, um.
18:37:26 <KatieHuber> carry on then.
18:37:37 <Pseudonym> What about them monads, then?
18:37:57 <shubalub> They scare me.
18:38:02 <KatieHuber> I just thought the spacetime continuum was more in danger of collapsing than gravity, with so little talk of monads in here
18:38:21 <ivanm> ari: well, they had less air, but there still was air...
18:38:29 <shubalub> >>= should bitshift-and-assign, as Kernighan and Richie intended, Amen.
18:38:41 <KatieHuber> ooh, fight!
18:38:47 <ivanm> googlefight?
18:39:05 <omnId> bitshift sounds like such a rude word.
18:39:31 <ivanm> http://googlefight.com/index.php?lang=en_GB&word1=bind&word2=bitshift
18:39:34 <lambdabot> Title: Google Fight : Make this fight with googleFight bind VS bitshift, http://tinyurl.com/2g8l8z
18:39:49 <ivanm> sorry Kernighan and Richie, but "bind" wins over "bitshift" :p
18:39:54 <jcreigh_> "bind"?
18:40:01 <jcreigh_> that's a little vague...
18:40:11 <omnId> that's *very* vague
18:40:13 <ivanm> isn't =<< (and >>=) pronounced "bind" ?
18:40:17 <LoganCapaldo> how about "monadic bind" vs. "bitshift and assign"
18:40:18 <ivanm> omnId: it was meant to be :p
18:40:24 <ivanm> LoganCapaldo: you do that then
18:40:59 <LoganCapaldo> http://googlefight.com/index.php?lang=en_GB&word1=monadic+bind&word2=bitshift+and+assign
18:40:59 <omnId> 10:1
18:41:00 <lambdabot> Title: Google Fight : Make this fight with googleFight monadic bind VS bitshift and ass ..., http://tinyurl.com/2xzo4p
18:41:04 <LoganCapaldo> monadic bind still wins :)
18:41:13 <ivanm> \o/
18:41:13 <omnId> @slap lambdabot
18:41:13 * lambdabot throws some pointy lambdas at lambdabot
18:41:16 <omnId> no swearing!
18:41:34 <ivanm> heh
18:41:36 <allbery_b> C should go back to the old style of =-ops.  it's not fair that only haskell should have confusion about -1 :)
18:41:44 <ivanm> how come lambdabot slaps herself now?
18:41:50 <LoganCapaldo> lawl
18:41:53 <LoganCapaldo> http://googlefight.com/index.php?lang=en_GB&word1=monadic+bind&word2=bitshift
18:41:55 <lambdabot> Title: Google Fight : Make this fight with googleFight monadic bind VS bitshift, http://tinyurl.com/2rskyr
18:42:00 <LoganCapaldo> monadic bind beats bitshift
18:42:32 <LoganCapaldo> that is a pretty definitive victory IMO
18:42:32 <Pseudonym> Actually...
18:42:52 <Pseudonym> >> is an I/O operation in C++.
18:43:05 <shubalub> nope
18:43:10 <omnId> "monadic bind" in the quotes got 0 in googlefight, 467 in plain google.
18:43:17 <shubalub> stream extraction is an overload of >>
18:43:24 <Pseudonym> Still...
18:43:31 <jcreigh> hmm: http://www.googlefight.com/index.php?lang=en_GB&word1=Google+Fight&word2=Rational+Argument
18:43:33 <lambdabot> Title: Google Fight : Make this fight with googleFight Google Fight VS Rational Argumen ..., http://tinyurl.com/35nyav
18:43:34 <shubalub> I mean, yes it is, but it's also horrible
18:43:42 <sorear> Pseudonym: yes, >> is input.  It's also bit shifting!
18:43:43 <omnId> lawl
18:43:48 <Pseudonym> So there you go!
18:43:55 <Pseudonym> "Both" is an acceptable answer!
18:44:29 <shubalub> You can make Pizza::operator++() change the kind of toppings though :(
18:45:11 <Pseudonym> BBS
18:45:17 <Pseudonym> Gotta bleed for my country.
18:46:13 <ivanm> hmmm??? you going off to war or something?
18:46:19 <jcreigh> giving blood?
18:46:44 <ricky_clarkson> Period.
18:46:53 <ivanm> http://www.googlefight.com/index.php?lang=en_GB&word1=%22Google+Fight%22&word2=%22Rational+Argument%22
18:46:54 <lambdabot> Title: Google Fight : Make this fight with googleFight \"Google Fight\" VS \"Rational A ..., http://tinyurl.com/2epdd6
18:47:14 <ivanm> ^^ proves it even better than jcreigh's :p
18:47:55 <jcreigh> if you actually google "google fight" it only has about 7,000,000 vs. "rational argument" with about 14,000,000 (without the quotes in both cases)
18:48:00 <jcreigh> so googlefight is smoking something.
18:51:42 <omnId> @quote
18:51:42 <lambdabot> SeanRussell says: [On the wmii (window manager) mailing list] Hah!  That's a laugh.  Since when does "it compiles" equate to "it will run (correctly)"?  We're talking about C, after all... not
18:51:42 <lambdabot> Haskell.
18:53:50 <ivanm> lol
18:53:53 <ivanm> @quote
18:53:53 <lambdabot> oklopol says: you shouldn't code haskell just before going to sleep, i had this nightmare where i couldn't get this program to compile
18:54:50 <boyscared> @t fmap
18:54:50 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:54:57 <boyscared> @type fmap
18:54:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:55:27 <boyscared> @type fmap fmap
18:55:28 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
18:55:46 <boyscared> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
18:55:47 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
18:55:54 <ivanm> now that's just mean
18:58:38 <omnId> someone worked out that a string of applications of (.) to itself eventually goes into a cycle of 4 types.
18:59:42 <omnId> @type let x y = (.) y in [x x x x x x x x x x x x, x x x x x x x x]
18:59:43 <lambdabot> forall a a1 b c a2. [(b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c]
18:59:55 <omnId> (multiples of 4 applications)
19:00:40 <omnId> @type let x y = (.) y in [x x x x x x x x, x x x x x x x x x x x x, x x x x x x x x x x x x x x x x, x x x x x x x x x x x x x x x x x x x x]
19:00:41 <lambdabot> forall a a1 b c a2. [(b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c]
19:00:42 <KatieHuber> @type (.)(.)(.)(.)(.)(.)
19:00:44 <lambdabot> forall b a b1 c a1. (b -> b1 -> c) -> (a -> b) -> a -> (a1 -> b1) -> a1 -> c
19:00:49 <KatieHuber> seems to be the start of the loop
19:00:58 <KatieHuber> and it repeats every 4 .s
19:01:11 <KatieHuber> hugs gives a nicer-looking type :/
19:02:17 <omnId> @type let x y = fmap y in [x x x x x x x x, x x x x x x x x x x x x, x x x x x x x x x x x x x x x x, x x x x x x x x x x x x x x x x x x x x] -- lets see if it applies more generally
19:02:18 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => [(a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))]
19:04:11 <omnId> $(return $ foldl1' AppE $ replicate (4^1000) (VarE (mkName "fmap"))) -- who's willing to try this :)
19:04:42 <omnId> warning: may thrash violently.
19:12:52 <KatieHuber> omnId: what exactly should I be testing?
19:13:42 <omnId> KatieHuber: that splices in an expression with (4^1000) applications of fmap to itself.
19:14:03 <KatieHuber> what do I need for AppE and VarE and foldl1?
19:14:13 <omnId> one second, pasting
19:14:51 <omnId> hehe, I'm laggy as hell, locally :)
19:15:28 <hpaste>  omnId pasted "futz with the application count for fun and profit." at http://hpaste.org/3528
19:16:06 <KatieHuber> what should I do with that?
19:16:39 <omnId> copy/paste, load into ghci, :type f
19:17:16 <omnId> change the literal '38' to however many applications you're willing to.
19:17:24 <boyscared> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:17:26 <lambdabot> forall a b (f :: * -> *) a1 (f1 :: * -> *). (Functor f, Functor f1) => (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
19:17:55 <KatieHuber> it's going to hit the 3GB barrier before it gets anywhere :/
19:18:12 <omnId> 26 already takes at least 20 seconds to compile.
19:19:26 <KatieHuber> huh, it broke 3GB... I didn't know that was possible :|
19:19:38 <KatieHuber> breaking 4GB *isn't* possible, anyway :/
19:19:59 <KatieHuber> unless someone's built an x86_64 GHC for Leopard yet ^_^
19:20:06 <SamB_XP> KatieHuber: you are compiling JHC's libraries?
19:20:32 <KatieHuber> I'm just doing whatever silly thing omnId says to ;)
19:20:38 <KatieHuber> memory allocation failed :'(
19:21:09 <omnId> emphasis on "silly"
19:21:10 <SamB_XP> that was the only thing I could think of that came close to eating 3g before getting anywhere ;-)
19:21:40 <KatieHuber> for 25: f :: (Functor f3, Functor f2, Functor f1, Functor f) =>
19:21:40 <KatieHuber> f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
19:22:12 <KatieHuber> for 30: f :: (Functor f1, Functor f) =>
19:22:12 <KatieHuber> (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
19:22:18 <ricky_clarkson> What's that nice permutation function that lets me give it [1,2] [1,2] and get [[1,1],[1,2],[2,1],[2,2]] out?
19:22:49 <omnId> looks like sequence
19:22:54 <omnId> > [[1,2],[1,2]]
19:22:55 <lambdabot>  [[1,2],[1,2]]
19:23:04 <omnId> > sequence [[1,2],[1,2]] -- heh
19:23:04 <ricky_clarkson> @type sequence
19:23:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:23:06 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
19:23:12 <ricky_clarkson> Thanks.
19:23:36 <omnId> > (\xs -> sequence $ map (const xs) xs) [1,2,3]
19:23:37 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
19:23:39 <KatieHuber> > (\as bs -> [[a, b] | a <- as, b <- bs]) [1, 2] [1, 2]
19:23:40 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
19:24:18 <KatieHuber> for 34: f :: (Functor f1, Functor f) =>
19:24:18 <KatieHuber> (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
19:24:28 <KatieHuber> not sure I dare go further :p
19:24:34 <KatieHuber> clearly there's some cliff before 38
19:25:15 <omnId> I don't think TH was designed for such rediculous things ;D
19:25:38 <omnId> (gah, I misspelled ridiculous.  I hate that)
19:28:06 <omnId> @pl \xs -> mapM (const xs) xs)
19:28:06 <lambdabot> (line 1, column 26):
19:28:06 <lambdabot> unexpected ")"
19:28:06 <lambdabot> expecting variable, "(", operator or end of input
19:28:10 <omnId> @pl \xs -> mapM (const xs) xs
19:28:11 <lambdabot> mapM =<< const
19:28:19 <omnId> > mapM =<< const $ [1,2,3]
19:28:21 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
19:28:25 <omnId> :)
19:29:56 <shubalub> I want to map the elements of a list 3-at-a-time...is there a good way to do that?
19:30:44 <shubalub> (a -> a -> a -> b) -> [a] -> [b] is what I want to do
19:31:41 <omnId> blah f [1,2,3,4,5,6] = [f 1 2 3, f 2 3 4, f 3 4 5, f 4 5 6] or [f 1 2 3, f 4 5 6]?
19:32:01 <shubalub> [f 1 2 3, f 4 5 6]
19:32:39 <shubalub> @src map
19:32:39 <lambdabot> map _ []     = []
19:32:39 <lambdabot> map f (x:xs) = f x : map f xs
19:32:48 <omnId> you might chunk into length-3 sublists, then map (\[x,y,z] -> f x y z)
19:33:58 <ricky_clarkson> > filter (\xs -> (head xs+(head (tail xs)))==21) $ sequence [1..20] [1..20]
19:33:59 <lambdabot>   add an instance declaration for (Num ([t] -> [a]))
19:33:59 <lambdabot>     In the expression: 20
19:34:22 <ricky_clarkson> I'm missing something there that no amount of extra parens seems to fix.
19:34:37 <omnId> @type sequence [1] [1]
19:34:38 <lambdabot> forall a. (Num ([Integer] -> a)) => [a]
19:34:56 <omnId> sequence (replicate 2 [...])
19:35:17 <ivanm> is there a function that will let me test equality between a and Maybe a?
19:35:30 <omnId> @type liftM (== ?x)
19:35:31 <lambdabot> forall a1 (m :: * -> *). (?x::a1, Eq a1, Monad m) => m a1 -> m Bool
19:35:34 <shubalub> omnId: thanks
19:36:02 <omnId> > liftM (== 1) (Just 2)
19:36:07 <lambdabot>  Just False
19:36:22 <ivanm> > liftM (== 1) Nothing
19:36:23 <lambdabot>  Nothing
19:36:36 <ivanm> well, I'd want that one to return False
19:36:49 <omnId> @type maybe False (== x)
19:36:50 <lambdabot> Not in scope: `x'
19:36:51 <omnId> @type maybe False (== ?x)
19:36:52 <lambdabot> forall a. (?x::a, Eq a) => Maybe a -> Bool
19:37:04 <ivanm> i.e. I want x == Nothing = False, x == Just y = x == y
19:37:12 <omnId> Nothing turns to False, Just turns to (== ?x)
19:37:20 <ivanm> hmmmm....
19:37:24 <omnId> maybe is case analysis on Maybes
19:37:28 <omnId> @src maybe
19:37:28 <lambdabot> maybe n _ Nothing  = n
19:37:29 <lambdabot> maybe _ f (Just x) = f x
19:37:32 <ivanm> *nod*
19:37:46 <omnId> > maybe False (== 1) (Just 2)
19:37:48 <lambdabot>  False
19:37:51 <ricky_clarkson> @pl \x -> head (tail x)
19:37:51 <lambdabot> head . tail
19:37:53 <omnId> > maybe False (== 1) Nothing
19:37:53 <ivanm> > maybe False (== 1) Nothing
19:37:55 <lambdabot>  False
19:37:56 <lambdabot>  False
19:38:00 <ivanm> > maybe False (== 1) (Just 2)
19:38:01 <lambdabot>  False
19:38:07 <ivanm> thanks omnId! :D
19:38:20 <omnId> ricky_clarkson: (!! 1)
19:38:38 <omnId> (!!) is index
19:38:47 <ricky_clarkson> Aha.
19:39:23 <LoganCapaldo> (!!) -- be excited!! I'm O(n)!!
19:39:32 <omnId> !!!!!
19:39:57 <LoganCapaldo> @type (!!) . (!!0
19:39:58 <ricky_clarkson> I seem to have difficulty typing !! instead of ||. ;)
19:39:58 <lambdabot> parse error (possibly incorrect indentation)
19:40:01 <LoganCapaldo> @type (!!) . (!!)
19:40:02 <lambdabot>     Couldn't match expected type `[a]'
19:40:02 <lambdabot>            against inferred type `Int -> a1'
19:40:02 <lambdabot>     In the second argument of `(.)', namely `(!!)'
19:40:46 <LoganCapaldo> @type (. (!!))
19:40:48 <lambdabot> forall c a. ((Int -> a) -> c) -> [a] -> c
19:40:57 <omnId> ooh
19:40:58 <LoganCapaldo> punctuation function
19:42:15 <omnId> > (. (!!)) (\int2a -> "blah") [1..5]
19:42:17 <lambdabot>  "blah"
19:42:35 <omnId> > (. (!!)) (\int2a -> int2a 4) [1..5]
19:42:36 <lambdabot>  5
19:42:47 <LoganCapaldo> what have I done
19:42:50 <omnId> > (. (!!)) (\int2a -> int2a 2) "helpme!"
19:42:52 <lambdabot>  'l'
19:42:55 <LoganCapaldo> I've created a monster
19:43:03 <omnId> > (. (!!)) ($ 2) "helpme!"
19:43:04 <lambdabot>  'l'
19:43:11 <omnId> indeed
19:43:21 <omnId> lessee...
19:43:43 <omnId> (. (!!)) ($ 2) "helpme!" = (($ 2) . (!!)) "helpme!"
19:43:59 <ricky_clarkson> @pl \x -> x !! 0+x !! 1==21
19:44:00 <lambdabot> (21 ==) . liftM2 (+) (!! 0) (!! 1)
19:44:06 <omnId> (($ 2) . (!!)) "helpme!" = ($2) ((!!) "helpme!")
19:44:18 <omnId> = (!!) "helpme!" 2
19:44:51 <ricky_clarkson> > filter (21 ==) . liftM2 (+) (!! 0) (!! 1) sequence [[1..20],1..20]]
19:44:51 <lambdabot>  Parse error at "]" (column 67)
19:44:58 <ricky_clarkson> > filter (21 ==) . liftM2 (+) (!! 0) (!! 1) sequence [[1..20],[1..20]]
19:44:59 <lambdabot>  Couldn't match expected type `[t1 -> a -> [t]]'
19:45:06 <ricky_clarkson> > filter (21 ==) . liftM2 (+) (!! 0) (!! 1) $ sequence [[1..20],[1..20]]
19:45:06 <lambdabot>   add an instance declaration for (Num [t])
19:45:16 <omnId> parens around (sequence [...])?
19:45:26 <ricky_clarkson> That's what the $ is for.
19:45:44 <omnId> ricky_clarkson: the $ applies it to *both* parts of the composed function.
19:45:46 <LoganCapaldo> That's what $ are for, in good times and bad times
19:45:53 <ricky_clarkson> > filter ((21 ==) . liftM2 (+) (!! 0) (!! 1)) $ sequence [[1..20],[1..20]]
19:45:55 <lambdabot>  [[1,20],[2,19],[3,18],[4,17],[5,16],[6,15],[7,14],[8,13],[9,12],[10,11],[11,...
19:46:07 <LoganCapaldo> > [ x | x <- [x] ]
19:46:08 <lambdabot>   Not in scope: `x'
19:46:18 <omnId> oh, your filter was different.
19:46:39 <omnId> liftM2 (+) blah blah = sum, I believe :P
19:47:05 <omnId> > filter ((21 ==) . sum) $ sequence [[1..20],[1..20]]
19:47:07 <lambdabot>  [[1,20],[2,19],[3,18],[4,17],[5,16],[6,15],[7,14],[8,13],[9,12],[10,11],[11,...
19:47:20 <omnId> slightly easier to understand :)
19:47:24 <ricky_clarkson> Now that's pretty.
19:49:13 <omnId> @type \targetsum termcount -> filter ((targetsum==) . sum) . sequence . replicate termcount
19:49:15 <lambdabot> forall a. (Num a) => a -> Int -> [a] -> [[a]]
19:49:41 <omnId> > (\targetsum termcount -> filter ((targetsum==) . sum) . sequence . replicate termcount) 21 2 [1..20]
19:49:43 <lambdabot>  [[1,20],[2,19],[3,18],[4,17],[5,16],[6,15],[7,14],[8,13],[9,12],[10,11],[11,...
19:49:50 <omnId> > (\targetsum termcount -> filter ((targetsum==) . sum) . sequence . replicate termcount) 25 3 [1..20]
19:49:52 <lambdabot>  [[1,4,20],[1,5,19],[1,6,18],[1,7,17],[1,8,16],[1,9,15],[1,10,14],[1,11,13],[...
19:51:12 <omnId> > (\targetsum termcount -> filter ((targetsum==) . sum) . sequence . replicate termcount) 6 1 [1..20]
19:51:13 <lambdabot>  [[6]]
19:51:17 <omnId> :)
20:01:55 <wli> Where's that super-sexy parallel sudoku solver in Haskell?
20:05:26 <shubalub> Data.Time is making my head hurt :(
20:22:29 <ptolomy> I sorta wish Merd were being actively developed.
20:37:59 <jbalint> what is Merd
20:50:19 <brad____> is there a simple way using hackage packages to uninstall?
20:57:42 <dons> bran__: ghc-pkg unregister foo
20:57:43 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:03:39 <ac> Is there a library for sending Haskell values between computers?
21:05:49 <newsham> you mean to "pickle" the data in some format for transit?
21:05:54 <newsham> I think you can use the Binary package for that
21:06:06 <newsham> you can also use "read" and "show" for that
21:06:31 <serishema> ghc is reasonably available for most not x86 CPU types?
21:07:00 <newsham> most cpu types?  or most operating systems?
21:07:29 <serishema> Well ghc is available for Mac OS X on ppc g4, i'm hoping it's available for linux on ppc g4 also
21:07:50 <newsham> thats not an x86 cpu type
21:08:03 <newsham> i dont know the answer to your quesiton
21:08:10 * serishema nods
21:08:49 <dons> shapr, interesting photo a friend took today, http://www.galois.com/~dons/types.jpg
21:08:54 <sjanssen> serishema: most linux distributions have a ghc package
21:08:59 <bos> whoa.
21:09:10 <serishema> coolies
21:09:15 <bos> serishema: there are 32-bit linux ppc builds.
21:09:23 <serishema> sweet
21:10:01 <shubalub> yeah, I dunno about other distros but gentoo provides ghc for ppc
21:10:11 <ddarius> dons: That's kind of disturbing.
21:10:23 <shubalub> (up to 6.4.2)
21:10:32 <brad____> i don't get the picture
21:11:23 <dons> he's just some graphic designer, and that was on his whiteboard
21:11:54 <Cale> hehehe
21:11:59 <brad____> oh. hey dons, i pestered you and one of your galois-friends a while ago about the curl binding. i never heard back. any idea what is happening with it?
21:12:08 <dons> code.haskell.org/curl ?
21:12:13 <brad____> yes
21:12:22 <dons> that's it. you want it tagged and uploaded? :)
21:12:43 <brad____> doesn't build for me, no docs, etc
21:13:06 <dons> ah ok. there's stuff that definitely does build (and works with concurrency) internally, i'll see what i can dig up
21:13:18 <dons> there's no problem releasing this, afaik
21:13:39 <brad____> just some basic basic docs would be cool too, even just code snippets without explanation
21:14:48 <dons> ok. i'll ask iavor and glguy, they use it a lot
21:14:56 <glguy> ?
21:14:57 <brad____> cool, thanks!!
21:15:03 <dons> have you seen the soc curl bindings?
21:15:15 <brad____> yes i saw those too, but was unsure which were more mature
21:15:19 <glguy> the curl binds I posted aren't going ot make sense if you haven't used libcurl before
21:15:22 <dons> glguy: brad wants curl bindings with haddocks that build
21:15:50 <brad____> i have used libcurl glguy, just wanted to see some basic use examples with the haskell binding
21:16:04 <brad____> i would even be happy to make further docs myself once i could get started
21:16:22 <brad____> curl is hugely important, probably the only realistic way to get https etc in haskell
21:16:58 <brad____> i need https to write my haskell del.icio.us lib!
21:18:27 <dons> right. maybe you need to start adding haddocks as you go through the curl src?
21:18:31 <newsham> dons: busy type checking?
21:18:34 <dons> if we don't have anything with more docs?
21:19:03 <brad____> i would be happy to build haddocks once i get the code working on freebsd and can see some basic useage
21:19:22 <newsham> i thought there was already bindings for gnutls
21:20:21 <brad____> i saw that newsham, but it didn't mention https support, for which i suspect it would also need the basic vanilla http support as well
21:21:10 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP-3001.0.0 ?
21:21:12 <lambdabot> http://tinyurl.com/yu99ae
21:21:39 <brad____> newsham - yes i use that lib, just unsure how to use that and tls bindings together
21:21:50 <brad____> curl sort of solves all these problems and more
21:22:08 <newsham> seems like you just need to instance Network.Stream to do it
21:22:31 <hpaste>  glguy pasted "untested after cut/paste Curl examples" at http://hpaste.org/3529
21:22:36 <brad____> i'm not sure how i would do that
21:22:50 <brad____> thanks glguy, i will look at that!
21:23:25 <bos> glguy: dons tells me you're using git. now i can't be your bestest ever buddy any more.
21:23:35 <brad____> thanks glguy, that looks like a great place for me to start!
21:23:50 <glguy> bos: I don't know you that well, but I know you well enough to know you aren't so petty ;)
21:24:48 <glguy> dons sure has a lot to say about me, "glguy's submitting dwm patches" "glguy's using git"
21:25:02 <bos> wow, talk about letting the side down
21:25:13 <glguy> I use xmonad at work :-p
21:25:20 <bos> next thing, you'll be developing porn sites using ruby on rails.
21:25:43 <glguy> No one uses ruby on rails anymore
21:26:01 <bos> yeah, they've all switched to happs.
21:26:13 <dons> oh man
21:26:37 <dons> i heard glguy saying bad things about types
21:27:05 <glguy> My types are more static than yours
21:27:16 <dons> that's true.
21:27:35 <newsham> did you hear what ghc said about python?  "it takes all types..."
21:27:46 <dons> class Typeable a => Message a
21:27:51 <dons> data SomeMessage = forall a. Message a => SomeMessage a
21:27:52 <dons> :)
21:27:57 <dons> fromMessage :: Message m => SomeMessage -> Maybe m
21:27:57 <dons> fromMessage (SomeMessage m) = cast m
21:28:02 <dons> ain't so static :)
21:30:41 <P_D> newsham:  =)
21:33:50 <ac> newsham: I was wondering if there's something like Control.Concurrent that works over sockets
21:34:18 <bos> ac: no, there isn't.
21:34:27 <bos> ac: it's pretty easy to write something basic, though.
21:34:42 <bos> ac: i assume you mean Control.Concurrent.Chan
21:36:10 <ac> yeah
21:38:13 <dons> newsham: your little .png writer looks cute/fast
21:38:31 <dons> maybe upload it to the wiki?
21:39:51 <Cale> Where is that?
21:40:43 <ddarius> Haskell-Cafe
21:41:30 <newsham> dons: is it appropriate to the wiki?  lemme know where it goes and i'll put it up
21:41:48 <dons> sure it is.
21:42:04 <ddarius> There should be a category for code.
21:43:01 <dons> there is!
21:43:30 <dons> http://haskell.org/haskellwiki/Category:Code
21:43:31 <lambdabot> Title: Category:Code - HaskellWiki
21:44:05 <ddarius> I was saying that there was, not that it needed to be made
21:44:54 <dons> `should' is a funny word
21:45:14 <newsham> oh, huh, there's code for ppm on the wiki
21:54:48 <omnId> Prelude> ((let x + 1 = x in 3 + 1), (let (x + 1) = x in 3 + 1)) -- oh god...
21:54:48 <omnId> (3,4)
21:55:19 <ddarius> Welcome to n+k patterns
21:55:33 <omnId> I read that in a blog article.
21:55:42 <omnId> I physically shivered.
21:56:01 <ddarius> Yeah... those superfluous parens.
21:56:06 <omnId> though LB's parser doesn't understand it.
21:57:20 <newsham> how can you do "[[Bool]]" in wiki text without special meaning of [[ ]] ?
21:57:31 <newsham> ahh, <hask>?
21:57:46 <omnId> maybe, though there's alway the six-quotes hack.
21:57:57 <newsham> found it
22:00:50 <newsham> http://haskell.org/haskellwiki/Library/PNG
22:00:51 <lambdabot> Title: Library/PNG - HaskellWiki
22:14:08 <ac> say I wanted to write something like gnuplot. What would be the easiest way to turn a string containing a Haskell expression in to a function of type Float -> Float?
22:14:42 <dons> compile it and link the resulting module?
22:15:25 <dons> or could you use an embedded language for plotting
22:15:28 <dons> a bit like parsec
22:16:11 <newsham> hs-plugins is prob what you want
22:16:18 <newsham> if you really want haskell exprs.
22:17:11 <ac> newsham: what is hs-plugins?
22:17:25 <newsham> it lets you dynamically load haskell code
22:17:30 <newsham> including from strings
22:17:34 <newsham> http://www.cse.unsw.edu.au/~dons/hs-plugins/index.html
22:17:34 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
22:17:41 <newsham> dons might know more about it
22:17:42 <dons> > 1+2 -- like this
22:17:44 <lambdabot>  3
22:17:51 <dons> but ghc-api also works, and is better supported :)
22:18:51 <dmwit> ac: I guess you've already positively decided you want Haskell expressions, and not your own custom language?
22:18:53 <ac> what would be the advantages of hs-plugins over the ghc-api?
22:19:06 <ac> dmwit: yeah
22:20:55 <ac> I assumed lambdabot used ghci
22:21:36 <newsham> so the options are supported vs. documented? :)
22:21:44 <dons> sort of
22:21:55 <dons> hs-plugins is fairly well unmaintained, but does work, as we know
22:22:03 <dons> ghc-api gives you the option of interprted code
22:22:06 <dons> but few docs
22:22:19 <dmwit> I guess hs-plugins predates ghc-api?
22:22:32 <dons> yep
22:26:30 <newsham> anyone have thoughts on wolframs NKOS book?
22:27:53 <dons> cool name for a band
22:28:06 <newsham> five mathemetician band?
22:28:28 <dmwit> Heard of the Klein Four?
22:28:34 <newsham> nope.
22:28:36 <Pseudonym> That's the best name.
22:28:36 <sorear> newsham: I have to agree with the Skeptic Magazine article.  He reinvented chaos theory and then wrote a dissertation instead of reading one.
22:28:40 <Pseudonym> Klein Four-Group.
22:28:45 <sorear> newsham: OTOH, it's a pretty good dissertation.
22:29:03 <dfranke> http://en.wikipedia.org/wiki/Ultraviolet_catastrophe
22:29:09 <dfranke> That should be a metal group.
22:29:12 <newsham> well he has more experience than most people who write dissertations ;-)
22:29:36 <Pseudonym> If it had been anyone but Stephen Wolfram, he'd be dismissed as a kook.
22:30:17 <newsham> dont a lot of people dismiss him as a (very knowledgeable) kook?
22:30:22 <Pseudonym> Yes.
22:30:27 <Pseudonym> Well...
22:30:32 <Pseudonym> Not dismiss, so much.
22:30:38 <ac> Pseudonym: isn't he dismissed as a kook as it is?
22:31:15 * ac needs to read to the bottom before responding
22:31:16 <newsham> i watched a sussman lecture recently where someone asked him about wolfram "I do not care for him"
22:31:19 <newsham> heh
22:31:38 <newsham> sussman, on the other hand, is just an unqualified joy to be around ;-)
22:31:53 <ac> newsham: I've read parts of it based on a syllabus for a course at University of Michigan
22:32:45 <ac> newsham: are you looking for discussion on the book, or a review?
22:33:45 <newsham> i just noticed it was online and was wondering wether its something i want to spend time reading or not
22:33:53 <newsham> i'm leaning against it, although it does sound like it has some interesting ideas
22:34:01 <newsham> there's no shortage of cool things to read
22:34:12 <ac> newsham: yeah, if you have other things to read, I'd recommend the other things
22:34:34 <ac> newsham: I could give you the page ranges that I read, which I found somewhat interesting
22:35:10 <newsham> thats alright, though thanks.
22:44:16 <ivanm> Pseudonym: I read NKOS (OK, I skimmed it)... AFAICT it was a load of garbage, and a lot of people have dismissed it
22:44:21 <TSC> Is there a nice expression with the type (a -> b) -> (a,a) -> (b,b) ?
22:44:34 <ivanm> (f *** f)
22:44:39 <wli> What's NKOS?
22:44:44 <ivanm> New Kind of Science
22:44:53 <Pseudonym> I skimmed the first bit of it.
22:44:53 <newsham> ?djinn (a -> b) -> (a, a) -> (b, b)
22:44:53 <lambdabot> f a (b, _) = (a b, a b)
22:44:59 <dmwit> :t join (***)
22:45:01 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
22:45:05 <wli> Never heard of it. The title sounds crackpot-ish.
22:45:10 <Pseudonym> I found it interesting, but not "a new kind of science".
22:45:12 <TSC> join, of course
22:45:13 <ivanm> Wolfram basically says "hey, cellular automata are cool... guess what, Mathematica happens to be the best language to do them in"
22:45:18 <TSC> Thanks ivanm, dmwit
22:45:25 <ivanm> no probs
22:45:29 <Pseudonym> Look, as a textbook on cellular automata, it's... ok.
22:45:36 <ivanm> true
22:45:37 <wli> Sounds dull.
22:45:39 <ivanm> except rather... big
22:45:44 <ivanm> and yes, it's deathly dull
22:45:46 <Pseudonym> It could be toned down into a very good textbook on that topic.
22:45:53 <kfish> http://www.cscs.umich.edu/~crshalizi/reviews/wolfram/
22:45:54 <lambdabot> Title: Stephen Wolfram, A New Kind of Science
22:45:54 <Pseudonym> All the material is there.
22:45:59 <ivanm> though implementing a turing machine using cellular automata is rather cool
22:46:16 <Pseudonym> My wife (who was my gf at the time) used to work in the same building as Wolfram.
22:46:19 <Pseudonym> A few floors down.
22:46:24 <Pseudonym> Just thought I'd mention that.
22:46:27 <ivanm> did he steal her ideas as well? :p
22:46:36 <Pseudonym> Nah, she was just a support tech.
22:46:41 <Pseudonym> Nothing worth stealing.
22:46:56 <kfish> ^^^ review: "A Rare Blend of Monster Raving Egomania and Utter Batshit Insanity"
22:47:01 <wli> What's this idea stealing stuff?
22:47:28 <newsham> you better not let your wife hear you say that
22:47:43 <ivanm> wli: wolfram was accused of stealing a lot of ideas in his book
22:47:47 <Pseudonym> newsham: She would be the first to agree that that particular job was not conducive to original ideas.
22:48:07 <newsham> "she was not worth stealing" is what I meant
22:48:36 <Pseudonym> I said "nothing worth stealing" in response to "did he steal her ideas".
22:48:55 <Pseudonym> But I think this thread of conversation is now spoiled completely.
22:51:39 <ivanm> @type any
22:51:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:53:44 <Cale> serishema: How's code? (I'm the person who commented on your blog the other day :)
22:53:49 <omnId> Pseudonym: perhaps instead of clarifying you could have said, "Yes, that too :)" and we could wink at each other while the females present deride us for our chauvinism. :)
22:54:29 * Cale systematically goes through google blog search looking for new users and people with questions about Haskell
22:54:29 <serishema> cale: at the moment i'm working on a horrible polytech assignment from hell
22:54:45 <Cale> serishema: Oh?
22:55:08 <serishema> cale: right now though i'm recovering from having my heart ripped to peices by a guy recently, so not coding or doing anything much effectively right now.
22:55:26 <serishema> cale: i haven't been doing much haskelling.
22:55:32 <Pseudonym> serishema: Join #haskell-blah.  That's where misery loves company.
22:55:38 <ricky_clarkson> serishema: As in an operation, or heartbreak?
22:55:56 <serishema> ricky_clarkson: heartbreak of course
22:56:12 <Cale> Ah, sorry to hear about that.
22:56:46 <serishema> anyways no matter
22:57:04 <serishema> a friend recently emailed me something about binding haskell types to sql
22:57:08 <serishema> so i'll be having a look at that later on
22:57:16 <serishema> trying out linux again
22:57:21 <serishema> just waiting for install CDs to verify
22:57:29 <Cale> Neat, which distribution?
22:57:40 <serishema> ubuntu ppc
22:57:47 <serishema> or kubuntu rather
22:57:49 * serishema is a kde person
22:57:54 <Cale> Ubuntu is great :)
22:58:18 * ac is an ubuntu suer
22:58:21 <ac> *user
22:58:22 <serishema> unless you have hardware stuff just works
22:58:26 <serishema> which is win
22:59:07 <Cale> Yeah. I actually had an easier time installing it on my dad's machine than XP, and he actually prefers it anyway. :)
22:59:45 <serishema> verify successful, win
22:59:56 <Cale> :)
22:59:58 <serishema> currently working with a pc laptop of mine that hates linux
23:00:03 <serishema> want to see if 7.10 will work
23:05:54 <ivanm> if I've got a polymorphic datatype, with differing number of parameters for the different constructors, how can I do an equality test to see which which constructor was used for a given type?
23:07:19 <Cale> ivanm: case works
23:07:35 <Cale> A good trick is that even if you haven't used record syntax to declare the type
23:07:39 <ivanm> well, I wanted to be able to pass the constructor through as a parameter... would that still work?
23:07:54 <Cale> you can write  case foo of Con {} -> ...; Con2 {} -> ...
23:08:22 <Cale> So that if the number of parameters changes later, you don't have to edit the pattern matches
23:08:36 <Cale> There's no general way to take a value and turn it into the constructor function though.
23:08:46 <ivanm> :(
23:08:48 <Cale> (because the type of such a thing would be strange)
23:08:53 <ivanm> heh
23:09:03 <ivanm> yeah, didn't think about that
23:09:06 <omnId> If you change a constructor's arity, you'll likely have to change a lot of code anyway :P
23:10:06 <Cale> omnId: Sometimes, but if a given piece of code only cares about which constructor and not the values it holds, then it'll likely stay that way
23:10:15 <Cale> (and so it's nice not to have to edit that)
23:10:36 <Cale> It also looks nicer than writing  (Con _ _ _) -> ...
23:10:38 <ivanm> well, so if I'm only likely to test for 2 types anyway, I might as well hard-code those functions in?
23:10:54 <Cale> You could write a function like 'isFoo'
23:11:00 <Cale> :t isJust
23:11:02 <lambdabot> forall a. Maybe a -> Bool
23:11:02 <ivanm> yeah, that's what I meant
23:11:05 <Cale> yeah
23:11:08 <omnId> ivanm: the Typeable class associates a runtime TypeRep representation with each type you have, and the library gives ways to inspect these TypeReps
23:11:12 <phlpp> good morning
23:11:13 <dmwit> Or a function like hasSameConstructor.
23:11:17 <ivanm> and as it is, I'm using a fair bit of record syntax atm anyway, _except_ for this datatype
23:11:34 <ivanm> omnId: that sounds like too much work :p
23:11:41 <omnId> deriving (Typeable)
23:11:44 <omnId> boom
23:11:49 <ivanm> boom?
23:11:54 <omnId> boom.
23:11:55 <ivanm> :i Typeable
23:12:14 <ivanm> I thought lambdabot had a full ghci session going...
23:12:21 <omnId> nah
23:12:29 <omnId> @docs Data.Typeable
23:12:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
23:12:54 <omnId> though this does add overhead in having to construct these runtime TypeReps.
23:15:53 <omnId> > tyConString $ typeRepTyCon $ typeOf $ Just 1
23:15:56 <lambdabot>  "Maybe"
23:16:23 <omnId> I might be thinking of the 'Data' class.
23:17:58 <omnId> > toConstr (Just 1)
23:18:00 <lambdabot>   Not in scope: `toConstr'
23:18:11 <omnId> > Data.Generics.Basics.toConstr (Just 1)
23:18:12 <lambdabot>   Not in scope: `Data.Generics.Basics.toConstr'
23:20:04 <omnId> > Data.Generics.toConstr (Just 1) -- weird
23:20:05 <lambdabot>  Just
23:20:31 <dmwit> > Just
23:20:32 <lambdabot>  Add a type signature
23:20:39 <dmwit> > Just :: Maybe ()
23:20:40 <lambdabot>  Couldn't match expected type `Maybe ()'
23:20:48 <dmwit> > Just :: () -> Maybe ()
23:20:50 <lambdabot>  <() -> Maybe ()>
23:20:52 <omnId> @type Data.Generics.toConstr (Just 1)
23:20:53 <lambdabot> Data.Generics.Basics.Constr
23:21:26 <omnId> I think you can use 'deriving (Data)' to get toConstr for your type.
23:22:34 <omnId> dmwit: the 'weird' was directed at the 'Not in scope'.  Generics just re-exports toConstr from Generics.Basics.
23:35:11 <newsham> this is cool: http://www.cs.chalmers.se/~ulfn/darcs/Agda2/examples/Introduction/Unicode.agda
23:35:14 <lambdabot> http://tinyurl.com/29wysy
23:51:42 <goalieca> whoah. there is a dude in the haskell-cafe that wrote a haskell native png lib
23:52:13 <ivanm> goalieca: B&W only, IIRC
23:52:16 <goalieca> libpng is quite a mess to work with even in C. congrats to this guy!
23:52:48 <goalieca> ya. it is B&W only. SHouldn't take too much work to support color (and gamma).
23:54:33 <ivanm> goalieca: do it then! oh, and finishing it in the next 5 hours or so so I can use it for this assignment I'm working on would be most appreciated! :p
23:55:20 <goalieca> lol. first i gotta finish my assignment
23:55:38 <goalieca> well.. in truth i probably shouldn't get involved in anything more until exams are finished
