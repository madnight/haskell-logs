00:00:22 <sclv> omnId: for some reason I've noticed that Debug.trace doesn't always get executed in ghci, or at least the way I expect, and end up defining my own trace function that's more like the one you wrote
00:01:00 <omnId> @source Debug.Trace
00:01:00 <lambdabot> http://darcs.haskell.org/packages/base/Debug/Trace.hs
00:01:23 <ttfh> http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
00:01:24 <lambdabot> Title: Longest common subsequence problem - Wikipedia, the free encyclopedia
00:01:32 <sclv> it might be because it writes to stderr and there's buffering involved?
00:01:45 <wli> The patch(1) side is the hard part.
00:01:49 <ttfh> you can use that for diff right?
00:02:07 <sclv> ttfh: that's pretty much what I did
00:02:24 <omnId> debugBelch is a great name
00:02:26 <sclv> the big problem in efficiency also arises because I'm going char by char instead of line by line
00:02:32 <ttfh> sclv: i used that for a similar problem in my thesis
00:03:44 <ttfh> sclv: do you use mutable arrays? I wonder if there's some clever haskell-ish way to implement that without them
00:05:53 <sclv> ttfh: take a look at my code on hpaste. i used a self-referential array as a memotable. i didn't worry about being efficient in space though, so all the different subsequence combinations (+ their edit-paths) are thrown in the table as well, although thanks to laziness they're not actually constructed.
00:15:10 <ttfh> sclv: It sounds like one of the labs in "Functional Programming" at my university, but when I took the course I didn't understand it :-)
00:15:49 <sclv> Pseudonym: btw, are you andrew b?
00:16:22 <Pseudonym> Yup.
00:17:42 <sclv> Pseudonym: Cool. I learned a bunch about haskell by looking through your code.
00:18:12 <Pseudonym> Oh, thanks.
00:19:44 <Pseudonym> Gotta go.
00:19:45 <Pseudonym> Nytol!
00:22:00 <dataangel> What NxN board sizes is nqueens not solveable for?
00:24:17 <roconnor> 2
00:25:00 <roconnor> 3
00:25:15 <roconnor> that's all I can do in my head
00:25:23 <fox86> anyone know the results from ICFP?
00:26:23 <roconnor> c++ is teh awsome
00:26:58 <roconnor> I mean c++ is the programming tool of choice for discriminating hackers
00:29:02 <dataangel> for some reason my implementation craps out on n=6
00:29:09 <dataangel> says its exhausted solutions @_@
00:30:01 <omnId> @wikipedia n queens
00:30:02 <lambdabot> No Result Found.
00:30:08 <omnId> @go n queens
00:30:09 <lambdabot> http://en.wikipedia.org/wiki/Eight_queens_puzzle
00:30:10 <lambdabot> Title: Eight queens puzzle - Wikipedia, the free encyclopedia
00:31:46 * fox86 shudders
00:32:03 <omnId> "There is a simple algorithm yielding a solution to the n queens puzzle for n = 1 or any n â‰¥ 4:"
00:36:23 <dataangel> my check-board-is-ok function is broke
00:36:32 <dataangel> it's rejecting some solutions
00:39:02 <amiddelk> fox86: http://johanjeuring.blogspot.com/
00:39:03 <lambdabot> Title: Johan Jeuring's blog
00:39:21 <fox86> amiddelk: thanks!
00:41:12 <fox86> i thought team smartass won last year as well, making haskell the language of choice for discriminating hackers
00:43:05 <newsham> > uncurry (/) foldr (\n -> (+n) *** (+1)) (0,0) [1,2,3,4,5]
00:43:13 <lambdabot>  Couldn't match expected type `(a, a)'
00:43:13 <dataangel> if the same team wins for several years in a row, they should have to use a different language the following year, as a control against their cleverness ;)
00:43:23 <newsham> > uncurry (/) $ foldr (\n -> (+n) *** (+1)) (0,0) [1,2,3,4,5]
00:43:28 <lambdabot>  3.0
00:43:48 <omnId> > foldr (\n -> (+n) *** (+1)) (0,0) [1,2,3,4,5]
00:43:50 <lambdabot>  (15,5)
00:44:21 <newsham> > foldr (\n -> (+n)) 0 [1,2,3,4,5]
00:44:23 <lambdabot>  15
00:44:29 <omnId> sum/count, thus mean?
00:44:30 <newsham> > foldr (\n -> (+1)) 0 [1,2,3,4,5]
00:44:32 <lambdabot>  5
00:45:17 <omnId> cool, my eyes are adjusting to it :)
00:45:47 <newsham> > fold (\n (x,y) -> (n+x, 1+y)) (0,0) [1,2,3,4,5]
00:45:48 <lambdabot>   Not in scope: `fold'
00:45:52 <newsham> > foldr (\n (x,y) -> (n+x, 1+y)) (0,0) [1,2,3,4,5]
00:45:54 <lambdabot>  (15,5)
00:46:35 <omnId> @pl \n -> (+n) *** (+1)
00:46:35 <lambdabot> (*** (1 +)) . (+)
00:49:05 <newsham> wonder if you could somehow automatically go from (sum *** avg) to that
00:49:27 <newsham> > uncurry (/) (sum *** length) [1,2,3,4,5,6]
00:49:28 <lambdabot>  Couldn't match expected type `(b, c)'
00:49:36 <newsham> > uncurry (/) (sum &&& length) [1,2,3,4,5,6]
00:49:37 <lambdabot>  Couldn't match expected type `(a, c)'
00:50:01 <newsham> > uncurry (/) $ (sum &&& length) [1,2,3,4,5,6]
00:50:02 <lambdabot>   add an instance declaration for (Fractional Int)
00:50:12 <newsham> > uncurry div $ (sum &&& length) [1,2,3,4,5,6]
00:50:13 <lambdabot>  3
00:50:26 <omnId> > uncurry (/) $ (sum &&& genericLength) [1,2,3,4,5,6]
00:50:27 <lambdabot>  3.5
00:50:30 <newsham> so that traverses the list twice.
00:50:35 <omnId> right
00:50:55 <newsham> but foldr (\n (x,y) -> (n+x, 1+y)) (0,0)   just goes once
00:51:29 <newsham> and sum and length can be written as foldr's
00:51:36 <omnId> you mean turning a pair of folds into a fold into a pair
00:51:59 <newsham> yah, taking an arrow combination of foldr's and making an arrow with a single foldr
00:52:53 <sclv> the folks involved with the diff discussion are probably mainly gone now -- but i think i get what's happening in the diff variation poster Pseudonym linked to -- it looks like it's flipping the depth-first algorithm into a breadth-first one.
00:53:50 <newsham> ?hoogle genericLength
00:53:50 <lambdabot> List.genericLength :: Integral a => [b] -> a
00:53:50 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
00:56:15 <omnId> Data.List is the newer module I believe, why would one generalize length to nonintegral types?
00:57:42 <newsham> omni: why did you just use it as a nonintegral type?
00:58:00 <sclv> and.... scene
00:58:21 * omnId looks at his navel.
00:58:23 <omnId> Huh?  What?
00:58:30 <omnId> Oh, right.
00:58:50 <omnId> @slap omnId
00:58:50 <lambdabot> why on earth would I slap omnId
00:59:05 <omnId> 'cause he needs to go to bed!
00:59:16 <lament> @slap omnId
00:59:16 * lambdabot beats up omnId
00:59:19 <lament> :D
00:59:21 <omnId> thank you
01:00:20 <hpaste>  newsham pasted "foldr fusion?" at http://hpaste.org/3228
01:10:29 <quicksilver> I note that 'f x' style definitions aren't permitted inside record syntax. Odd.
01:12:15 <Vq^> maybe it's because the resulting arguments of the name would get confusing (althought not that confusing)
01:13:45 <olsner> do you mean that (f x :: b) would be a field named f of the type (a -> b)?
01:14:12 <quicksilver> well I mean in the value not the type
01:14:18 <newsham> example?
01:14:24 <quicksilver> so, suppose Foo { f :: a -> b }
01:14:39 <quicksilver> then I want to write myFoo = Foo { f x = (x+1) }
01:14:51 <quicksilver> instead of myFoo = Foo { f = \x -> x+1 }
01:14:53 <newsham> Foo { f = \x -> x+1 }
01:15:00 <quicksilver> yes, I know :)
01:15:17 <quicksilver> it's just that with the = sign there, my brain 'knew' that it could use function definition syntax
01:15:32 <quicksilver> because everywhere '=' is valid syntax, function definition is valid syntax :)
01:15:39 <quicksilver> or, that's what my foolish brain assumed
01:15:39 <newsham> how about  Foo { f = let g x = x + 1 in g }  ;-)
01:15:48 <newsham> record syntax is a bit of an afterthought..
01:15:55 <newsham> lots of things that dont quite fit in with the language
01:16:05 <newsham> like no settor sections
01:16:31 <newsham> x {f = 5};    but no (x {f=}) 5
01:17:03 <quicksilver> yeah
01:17:29 <quicksilver> but, in my very biased opinion, function definition syntax inside record value syntax would be a 'small and natural' change
01:17:41 <quicksilver> while settor sections would be useful but t.b.h. slightly ugly :)
01:17:43 <newsham> yah, seems to make sense
01:17:50 <Vq^> quicksilver: i think youre right
01:17:57 <newsham> yah, not sure what the right syntax for that would be, but not the one I typed :)
01:18:15 <newsham> in fact, it prob shouldnt even be   (x {f=5})
01:18:37 <newsham> perhas {f=5} x   and  {f=} 5 x
01:19:16 <doserj> what is the x for?
01:19:18 <Vq^> setf x
01:19:29 <newsham> x is an instance of Foo
01:19:38 <quicksilver> newsham: yes, well it's not optimal that the 'magic selector trick' only generates a selector
01:19:54 <quicksilver> newsham: ideally you want a 'magic trick' which generates a selector, a settor, and a modificator
01:20:00 <quicksilver> newsham: all at once in some pleasant way
01:20:03 <newsham> data Foo = Foo { x :: Int, y :: Int };  a = Foo 3 5;  a {x=5}; a {y=7}
01:22:04 <quicksilver> newsham: and in a *really* ideal world, you want it all tied up neatly with what twanvl calls 'functional references'
01:22:25 <newsham> i dont know what 'functional references' means
01:22:34 <newsham> (or who twavnvl is :)
01:22:58 <quicksilver> @go overloading functional references
01:23:00 <lambdabot> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
01:23:01 <lambdabot> Title: Overloading functional references - 21 thoughts
01:23:26 <quicksilver> basically a pair of getter and setter functions
01:23:39 <quicksilver> but the point is you can compose them to 'get' and 'set' into indefinitely deep structures
01:27:17 <quicksilver> newsham: you could magic the whole thing up with some typeclass helpers too
01:27:28 <quicksilver> newsham: the thing is, intuitively I don't really like records
01:27:51 <Vq^> special set, get and modify keywords for records might be a solution
01:27:52 <quicksilver> newsham: normally I avoid them and write my ADTs the 'old fashioned' way. But, I'm using some in a current project maybe I'll start to understand how to use them well.
01:27:53 <newsham> i like the auto gettors and the half-almost-settors
01:28:00 <quicksilver> yes
01:28:06 <quicksilver> auto modificators would be nice too though
01:28:16 <Vq^> that would solve the  (x {f=}) 5  problem
01:28:19 <newsham> sometimes you got so much state you dont wanna pile it into a untagged bucket
01:28:24 <quicksilver> I have a lot of crap in my code like :
01:28:38 <quicksilver> env $~ (\nds -> nds { foo = f (foo nds) } )
01:28:55 <newsham> yah  :(
01:28:55 <quicksilver> which is a very verbose way of modifying one field inside a record inside an IORef
01:29:06 <Vq^> :/
01:29:12 <quicksilver> I mean, what I do in practice is call that 'modifyFoo'
01:29:15 <quicksilver> and then just use 'modifyFoo'
01:29:24 <quicksilver> but my code ends up with a lots of modifyFoo functions in it...
01:29:35 <newsham> I wrote several cmd line parsers that parsed into a record and all of the options in the getopt table were those wacky field updators lambda expressions
01:29:49 <newsham> (at the end it would compose em all together and apply them to the starting config)
01:29:51 <Vq^> then maybe there should be a 'modify Foo' way of writing it
01:30:04 <newsham> yah, that would be a good start vq :)
01:30:04 <Vq^> (without coliding with State)
01:30:27 <quicksilver> Vq^: yes that's what I meant
01:30:40 <quicksilver> Vq^: if you read twanvl's blog post you'll see he does present a way to do that
01:30:56 <quicksilver> Vq^: and what's nice, is that his solution is composable for foos embedded in bars embedded in bazs
01:31:09 <Vq^> oh, i missed that one, /me reads
01:31:27 <newsham> ie the "-f optarg" might map to \arg r -> r {file=arg}
01:36:04 <quicksilver> nice write-up of one guy's ICFP experience
01:36:05 <quicksilver> http://www.celestial-dire-badger.com/icfp/2007/report.html
01:36:09 <lambdabot> Title: And I Have Come Upon This Place By Lost Ways; or, team Celestial Dire Badger's 2 ...
01:58:07 <roconnor> quicksilver: is accumulator-passing ocaml's way of saying state monad?
02:00:50 <EvilTerran> isn't that just tacking on an extra parameter with the state in it when you recurse?
02:01:04 <EvilTerran> ...actually, that's pretty much state monad too, isn't it.
02:03:22 <roconnor> EvilTerran: oh, you are saying it means tail-recursion.
02:03:52 <EvilTerran> that seems closer, yes. if ocaml has some way of making the extra parameter implicit, *that*'d be more like the state monad
02:04:04 <quicksilver> roconnor: I think accumulator passing is just a common trick for hiding state in a closure
02:04:16 <quicksilver> roconnor: I use it often myself
02:04:27 <quicksilver> it's lighter-weight than using the state monad explicitly
02:07:20 <roconnor> quicksilver: is it the thing where you explicity thread state through your recursive calls?
02:08:29 <quicksilver> yes
02:08:34 <quicksilver> that's what I assume they mean
02:08:42 <roconnor> thx
02:09:34 <quicksilver> newtype Animation = Animation ( IO Animation )
02:09:37 <quicksilver> for example
02:09:50 <quicksilver> and each time you run the action, it returns a modified version of itself
02:09:56 <quicksilver> with the 'new' state trapped in the closure
02:10:11 <quicksilver> it makes the type of the state irrelevant to code using it
02:16:52 <roconnor> quicksilver: that type makes my head expode.
02:17:16 <roconnor> oh right, the IO may have side effects
02:17:41 <roconnor> so it is some way of stepping through a stream of IO actions?
02:19:10 <Beelsebob> ghci's shiny new debugger?
02:24:42 <roconnor> [11:09] <quicksilver> newtype Animation = Animation ( IO Animation )
02:25:52 <quicksilver> roconnor: yes, and you hide the state inside
02:26:00 <quicksilver> roconnor: it doesn't have to be IO, really
02:26:02 <roconnor> using IORefs?
02:26:08 <quicksilver> no, trapped as a parameter
02:26:18 <roconnor> oh
02:26:30 <roconnor> ... I don't get it
02:26:35 <quicksilver> foo s = Animation (do something with s; return Animation (foo (s+1)) }
02:26:50 <quicksilver> then foo :: Int -> Animation, say
02:26:57 <roconnor> whoa
02:26:58 <quicksilver> so "foo 1" is your starter Animation
02:27:04 <quicksilver> and each time you run it, it returns a new one
02:27:15 <quicksilver> with a 'different' state trapped in the new closure
02:28:42 <quicksilver> it doesn't have to be IO of course
02:28:57 <quicksilver> this works in any side-effect monad, which might not have its own 'Ref' type like IO does
02:30:47 <roconnor> it doesn't really have to be a monad at all does it?
02:31:06 <quicksilver> no, it doesn't
02:31:16 <quicksilver> but there has to be some meaningful sense of 'side-effect'
02:31:17 <roconnor> wait, how is this different from explicit state passing?
02:31:20 <quicksilver> otherwise it's not really doing anything
02:31:29 <roconnor> right
02:31:39 <quicksilver> operationally there is no difference at all
02:31:57 <quicksilver> I just find it simpler than passing the state :)
02:32:05 <quicksilver> or, I think it promotes a simpler model
02:32:15 <roconnor> But there is something unique here with your stepping process.
02:32:20 <quicksilver> it's more flexible too in the sense that 'foo' can arbitrarily turn into 'bar'
02:32:22 <quicksilver> if it wants to
02:32:32 <quicksilver> it's not forced to return 'foo s' for some s
02:32:37 <quicksilver> it can return any other animation :)
02:33:04 <roconnor> Why to you return Animation (foo...) instead of just doing foo?
02:33:19 <quicksilver> so you can single-step it
02:33:31 <quicksilver> e.g. once per 50ms, just before your display loop
02:33:35 <roconnor> did you do this for your ICFP entry?
02:33:36 <quicksilver> well, during your display loop
02:33:45 <quicksilver> no, I didn't enter ICFp
02:33:46 <roconnor> or just some animations you are doing?
02:33:58 <quicksilver> the latter
02:34:03 <roconnor> It's a really cool idea.
02:35:07 <quicksilver> newtype Animation = Animation { runAnimation :: IO (Maybe Animation) }
02:35:11 <quicksilver> is what I actually use
02:35:17 <quicksilver> the Maybe is so it can signal when it's time to stop
02:35:40 <quicksilver> then you can write combinators for running animations in series and in parallel
02:36:07 <roconnor> hackage?
02:36:18 <quicksilver> no, it's not isolated at the moment
02:36:25 <quicksilver> it's all bound up in the program itself
02:36:31 <quicksilver> I'm exploring a bunch of related issues
02:36:37 <quicksilver> at the moment I'm writing a particle system
02:36:46 <quicksilver> once I manage to understand it well enough to abstract it right :)
02:37:07 <roconnor> :)
02:37:13 <geocalc> you speak of animations but we don't see them quicksilver
02:37:33 <geocalc> ;)
02:37:47 <quicksilver> I'm embarassed to admit but I have no idea how I would turn it into an mpeg to show someone
02:38:17 <geocalc> post the code
02:38:25 <quicksilver> it's too long for hpaste
02:38:28 <quicksilver> IIRC
02:38:39 <quicksilver> I shoulud put it on a web page I guess
02:38:52 <quicksilver> roconnor: I'm not entirely content with that anmation abstraction, I have a higher level one too
02:38:58 <quicksilver> runAnim :: (s -> GLdouble -> IO s) -> Int -> s -> Animation
02:39:12 <EvilTerran> gzip it on maximum compression, base64-encode it, then see if it fits on hpaste? :P
02:39:33 <quicksilver> roconnor: that int parameter tells it how many iterations to run that action, and it automatically builds an 'Animation' which calls it 'n' times with 'n' values of time, from 0..1
02:39:38 <quicksilver> (the GLdouble parameter is "time")
02:39:42 <geocalc> a free host for upload quicksilver
02:39:51 <quicksilver> that makes a frame-rate independent animation, in principle
02:39:57 <roconnor> code.haskell.org
02:40:00 <quicksilver> btu I'm still not really sure I have the abstractions right
02:40:35 <quicksilver> I have my own colo actually :)
02:40:44 <quicksilver> hosting space is not the issue
02:40:47 <quicksilver> laziness is
02:40:55 <geocalc> so you need testers
02:41:51 <quicksilver> ok, well I'll see about putting up a web page after work, or something
02:42:13 <geocalc> thanks quicksilver
02:46:02 <roconnor> I usually just mirror my darcs repo
02:46:18 <roconnor> quality not guarenteed
02:51:32 <quicksilver> I'm a heathen, I don't use darcs
02:52:50 <thetallgu1> Anyone know if there is a decent way to derive PrettyPriint support?
02:54:52 <roconnor> quicksilver: does that make it hard to mirror your repos?
02:55:04 * roconnor grubles about the burocracy of arch
02:55:11 <roconnor> grumbles
02:55:47 <haraldk> Arch? GNU Arch?
02:55:54 <quicksilver> I use bzr
02:55:55 <roconnor> yep
02:55:57 <quicksilver> tis pretty easy
02:56:01 <quicksilver> 'bzr push'
02:56:36 <quicksilver> thetallgu1: I'm not aware of one. Should be a fairly easy project using one of the derive tools I would think.
02:57:21 <haraldk> But bzr does not have much in common with old Tom Lord's arch, does it?
02:58:21 <haraldk> because that was... tricky to use, to put it mildly
02:59:42 <quicksilver> haraldk: only some underlying design ideas
02:59:50 <quicksilver> haraldk: but the UI is quite different
03:00:05 <quicksilver> haraldk: the bzr UI is fairly 'natural' to people used to svn or cvs
03:00:15 <roconnor> We started using Arch for one of our projects here 2 years ago.
03:00:29 <roconnor> It was an improvement over cvs
03:00:52 <roconnor> but after some experience it became clear that arch is not a useable system.
03:01:13 <quicksilver> meanwhile I remain stubbornly unconvinced by darcs commuting patches model
03:01:16 <geocalc> now that i run the new ghc trying to build haddock it say me that System.Directory is hidden but in fact this module is exposed, any suggestions ???
03:01:21 <roconnor> 2 years ago the alternatives seemed less clear
03:01:26 <quicksilver> and foolishly scared of the FUD about non-termination
03:01:44 <quicksilver> roconnor: it's around 2 years ago that I made the decision to choose bzr, actually
03:01:46 * roconnor is scared about the FUD about exponential patching
03:02:06 * osfameron is still trying to get his head around git as a change from svk
03:03:03 <roconnor> quicksilver: what I learned from arch is that you cannot use a system that (effectively) requires a star-topology.
03:03:18 <roconnor> darcs' patch system clearly does not require a star topology
03:03:26 <quicksilver> roconnor: elaborate?
03:03:36 <roconnor> But I fear most other VCs require a star topology (although I don't know)
03:04:03 <geocalc> osfameron-> try to put your head around my problem ;)
03:04:21 <quicksilver> roconnor: require star topology in what sense?
03:04:47 <roconnor> the repositories are nodes in a graph
03:05:03 <quicksilver> by repositories you mean what I'd call branches, I think
03:05:13 <roconnor> the edges are where you pull from one repo to another
03:05:15 <geocalc> quicksilver, roconnor you too
03:05:18 <roconnor> yes, branches
03:06:14 <quicksilver> with bzr you can merge from any branch to any other branch
03:06:18 <roconnor> if you end up with cycles in this graph, arch gets quite confused
03:06:29 <quicksilver> and you can pull IFF one branch is "strictly superset" of the other
03:06:41 <quicksilver> i.e. it contains every patch that contains, plus some more
03:07:01 <quicksilver> pulling always makes two branches equal, if it succeeds
03:07:15 <quicksilver> merging attempts to apply the patches and lets you resolve conflicts before you commit
03:07:19 <roconnor> that sounds like an unreasonable restriction.
03:07:56 <roconnor> We we both extend a repo, then I cannot merge from you.
03:07:56 <quicksilver> which part?
03:08:03 <quicksilver> no, you misundersood
03:08:10 <quicksilver> there is a difference between 'pull' and 'merge'
03:08:16 <roconnor> oh
03:08:21 <quicksilver> 'pull' is for the case when one is a strict extension of the other
03:08:26 <quicksilver> in this case, nothing can go wrong
03:08:30 <quicksilver> so it's a non-interactive process
03:08:36 <quicksilver> 'merge' is for the general case
03:08:41 <quicksilver> here something can go wrong :)
03:08:45 <quicksilver> so it's two-step
03:08:58 <quicksilver> merge - (maybe fix problems) - commit
03:09:03 <roconnor> right
03:09:38 <roconnor> so if you have cycles in this graph, arch does stupid things like trying to apply the same patch twice
03:09:43 <quicksilver> ah
03:09:44 <quicksilver> nasty
03:09:47 <quicksilver> no bzr doesn't do that
03:09:51 <roconnor> because the same patch got pulled in two different directions.
03:10:00 <quicksilver> it recognises that case quite happily
03:10:12 <roconnor> Now, I like star topologies as much as the next guy.
03:10:17 <roconnor> but they are a global property
03:10:30 <roconnor> and people only can see the local part of the graph.
03:10:42 <roconnor> so no one can enforce it
03:10:45 <roconnor> so that is the problem.
03:11:19 <roconnor> that I have with arch, or any other version control system that would effectively require a star-topology.
03:11:31 <roconnor> ... I need to write a blog rant sometime.
03:11:41 <roconnor> fortunately not many people seem to use arch now-adays.
03:11:43 <roconnor> or even before.
03:11:50 <osfameron> heh
03:12:56 <roconnor> right, lunch time.
03:13:13 <roconnor> still arch is better than cvs
03:13:46 <mux> about everything else is better than cvs, if you exclude rcs and sccs :-)
03:15:36 <osfameron> rcs has a niche for version controlling system files in place
03:17:31 <quicksilver> rcs is fine, but it's single-file based
03:17:40 <quicksilver> if single-file based is what you want, it's a great solution
03:17:47 <quicksilver> in practice that doesn't seem to be a very common need :)
03:17:53 <quicksilver> normally files don't exist in isolation
03:18:40 <osfameron> as I say, I've seen sysadmins use it for version controlling conf files on live systems.  For those cases they absolutely have to modify online.
03:21:13 <haraldk> I've looked into Mercurial. Darcs issues scare me as well
03:21:38 <haraldk> I'm suprised that old arch is still in active use, really
03:21:58 <quicksilver> I don't think it is, much
03:22:02 <quicksilver> ;)
03:22:34 <JohnMeacham> rcs is great as long as your project consists of a single file.
03:22:41 <JohnMeacham> which is not entirely uncommon.
03:23:08 <osfameron> arch always put me off by the geeky in jokes (like the client being called "tla") and the hostility to Windows as an inferior OS
03:23:22 <quicksilver> you're quite right
03:23:24 <osfameron> (of course now I use linux and git, which is probably just about as hostile to windows...)
03:23:33 <quicksilver> it behoves users of superior OSes to be kind to the inferior ones
03:23:38 <quicksilver> that's just common courtesy
03:24:00 <osfameron> and it proves your moral superiority as well
03:24:18 <JohnMeacham> in all fairness windows is a PITA to do anything with. anyone that doesn't want to use linux should get a mac. the sooner all the worlds a unix, the sooner a lot of wasted effort doesn't take place.
03:25:11 <osfameron> it would be nice if the next version of windows sat on top of a unix, like Mac now does...
03:25:28 <osfameron> because windows isn't going to go away any time soon, whatever a handful of geeks say :-)
03:25:36 <quicksilver> all the world's a stage, and all the men and women merely pipelines?
03:25:37 <JohnMeacham> I mean, microsoft unix would be just fine. I have nothing against closed source or anything. as a developer, the windows api is just hard to use and wastes the time of devolopers. it is purely a pragmatic thing.
03:27:02 <JohnMeacham> I recently bought a friends iBook to hack my iPhone, I was really really impressed. I have no problem recommending macs to anyone nowadays. the OS and design is pretty solid.
03:27:47 <quicksilver> I ended up using an iBook because an IT department said they were able to support them much better than linux on laptops due to compatibility issues
03:27:56 <quicksilver> since they were paying for it, I followed their advice.
03:28:09 <osfameron> really?  how odd
03:28:16 <quicksilver> I must admit I find myself subject to the allure of something that looks nice and 'Just Works(TM)'
03:28:38 <quicksilver> Yes, they had considerable difficulty getting linux working consisently with wireless chipsets, for example
03:28:54 <quicksilver> because hardware manufacturers will often change the chipset without changing the model number, so you don't know what you're getting.
03:29:11 <JohnMeacham> at my work they give linux, mac, or pc. whatever anyone asks for. it works really nicely.
03:29:28 <quicksilver> JohnMeacham: That is the policy here, certainly. (I've moved since that incident)
03:29:32 <exDM69> I have always used Linux at work
03:29:51 <exDM69> sometimes it has been hard to do, because not everyone knows how to make build files, etc
03:30:06 <exDM69> although you could use virtually anything for Java devlopment
03:30:46 <exDM69> but if your ant scripts or makefiles call windows .bat scripts, it won't work out
03:31:00 <quicksilver> JohnMeacham: but curiously most of the techies I hired wanted macs
03:31:06 <quicksilver> (well I was surprised at the time)
03:31:09 <JohnMeacham> It was a requirement I gave at interviews. I made the mistake of not doing that before and ended up on a job using windows. it was just demoralizing. I mean. I was good at it, it was just programming, but just knowing I was being a quarter as efficient as I could be was so depressing.
03:31:21 <exDM69> actually I've had the same problem (with build files) in several jobs
03:31:29 <JohnMeacham> so. I said it was a dealbreaker if I can't use linux. it wasn't an issue where i work now of course.
03:31:58 <quicksilver> to be fair to QM's IT department, they didn't forbid me from having a linux laptop. They just made a recommendation.
03:32:28 <osfameron> I'm finding linux hardware compat quite good these days, and if you go with a dell/hp/thinkpad/whatever that's known to usually work with its hardware on linux you should be ok
03:32:37 <quicksilver> well this was 5 years ago
03:32:39 <quicksilver> or maybe four
03:33:04 <quicksilver> Back then macs seemed to have a distinct advantage on consistent working with OHPs too
03:33:09 <quicksilver> which is pretty important in the academic world
03:33:20 <quicksilver> the number of seminars I've been to where the speaker's PC woudln't talk to the OHP...
03:33:21 <ttfh> hehe, at my current job, it's forbidden to install software, period.
03:33:32 <wangzhifen> Is here "chat.freenode.org"
03:33:32 <quicksilver> and VGA is a 'standard'.
03:33:59 <earthy> wangzhifen: it is
03:34:08 <quicksilver> wangzhifen: this is irc.freenode.org, and you're in a channel called #haskell which is a for discussion of a programming language called haskell
03:34:10 <wangzhifen> :)
03:34:15 <quicksilver> although you wouldn't know, from the last 15 minutes discussion
03:35:53 <osfameron> quicksilver: at YAPC I saw about 3 or 4 presenters using Linux waste 5 minutes trying to get their laptops to connect to beamers
03:36:07 <osfameron> they ended up either rebooting or borrowing someone else's laptop
03:36:28 <osfameron> (mine worked perfectly, first time, as a different datapoint)
03:36:50 <quicksilver> osfameron: yeah, its' a common experience
03:37:13 <quicksilver> osfameron: "just working" with projectors and "just working" with wireless, the macs seem to do very well
03:37:24 <quicksilver> osfameron: and those things are really important to a modern laptop-carrying academic
03:37:28 <osfameron> I was surprised the presenters didn't just reboot immediately, as some of them were pretty experienced and that's always the stupid but worky solution
03:37:29 * earthy nods
03:37:33 <quicksilver> osfameron: perhaps begins to explain their recent popularity
03:37:38 <osfameron> yeah
03:37:46 <osfameron> it's just the UI I hate.  The rest of it is fine.
03:37:50 <quicksilver> :)
03:37:54 <quicksilver> I'm used to the UI now
03:37:58 <quicksilver> but I hardly use it
03:37:59 <earthy> which is one of the reasons I tend not to use the compaq provided me by the university
03:38:06 <quicksilver> 99% of my time in emacs or iTerm
03:39:39 <pejo> (The mac doesn't feel very different from X imho, if you fill your screen with xterms).
03:40:13 <earthy> well, the click-to-focus does annoy
03:40:23 <quicksilver> you can turn that off
03:40:30 <quicksilver> at least you can for X11 and iTerm
03:40:32 <quicksilver> and I have :)
03:40:35 <wli> Click-to-focus is showstopping.
03:40:57 <earthy> yeah, I have done so as well for X11
03:40:58 <quicksilver> I use point to focus in iTerm and X11, which is close enough for my needs
03:41:05 * osfameron tried mouseover to focus on ubuntu and went slightly insane before switching it off
03:41:07 <earthy> but everything else is click to focus
03:41:13 <quicksilver> I don't use much else :)
03:41:14 <osfameron> guess it's what you're used to
03:41:22 <earthy> osfameron: focus-to-front is a stupidity
03:41:26 <schemelab> what language did jed Davis use for judges prize in icfp?
03:41:28 <pejo> earthy, I agree. But turning it off for X11 makes it behave fairly much like a real computer. (Word i've heard is that they will solve it in next version of OS).
03:41:30 <earthy> especially with focus-follows-mouse
03:41:32 <tarrybone> tiling wms! the drumbeat marches on
03:41:41 <earthy> pejo: that would be *great* :)
03:41:53 <quicksilver> So, is there an isotrophic parameterisation of the surface of the sphere?
03:42:06 <quicksilver> or do all parameterisations involve singularities?
03:42:08 <osfameron> earthy: I dislike having the mouse pointer where I'm typing, so I often move it away... which would then focus me on another window... aargh :-)
03:42:12 <ttfh> earthy: it breaks gimp and cinerella and some other things
03:42:37 <earthy> ttfh: I know. gimp is exactly why I've turned off click-to-focus
03:43:09 <pejo> osfameron, in that case you won't have much trouble with the macs.
03:43:16 <ttfh> also gimp and xmonad becomes weird in my opinion
03:43:29 <geocalc> @hoogle Distibution.Setup
03:43:30 <lambdabot> No matches, try a more general search
03:43:31 <wli> I've used autoraise in conjunction with autofocus since the early 90's.
03:43:32 <earthy> osfameron: macs hide the mouse pointer when you're typing
03:43:38 <pejo> earthy, have you had any trouble focusing on windows after pressing F9 under X?
03:43:48 <earthy> nope
03:43:57 <osfameron> pejo: I hate the fact you can't have full screen windows, the weird lozenges, and various other things.  All in all gnome is slighty more usable
03:44:01 <earthy> not really that is
03:44:21 <quicksilver> at the recent hac, didn't someone improve xmonad's floating palette support?
03:48:11 <wangzhifen> lambdabot: does lambdabot a robot?
04:07:55 <wang> I am using irc for the first time. How can I thank someone who answers my questions?
04:08:23 <huamn_> You can try saying "thank you"
04:08:36 <kalven> wang: write: /me hugz <person>
04:08:45 <huamn_> :]
04:09:11 <koala_man> aww
04:09:16 * wang hugs kalven
04:09:37 <wang> thank you very much!
04:10:47 <kalven> you're welcome
04:11:39 <ivan`> wang: in some channels it takes hours for a question to be answered and you can thank people by not leaving the channel after asking
04:11:47 <ivan`> common newbie pattern there
04:33:23 <wang> join go
04:34:05 <ivan`> try /join #go
04:34:25 <ivan`> ah you made it
04:38:48 <HairyDude> anyone else having trouble compiling xmonad with ghc 6.9 ?
04:39:08 <iank> I'm pretty sure other dudes had problems.  Haven't tried it myself.
04:42:00 <araujo> morning
04:43:17 <Vq^> hello mr araujo
04:43:39 <araujo> Hi there Vq^ :-)
04:45:22 <pBot-> Hello folks! :D
04:45:31 <pBot-> *** Expected type : (Real a, Floating a) => String -> String -> a
04:45:31 <pBot-> *** Inferred type : (Real Int, Floating Int) => String -> String -> Int
04:45:37 <pBot-> It says "inferred type is not general enough"
04:45:47 <pBot-> what's that supposed to mean? which class is Int in?
04:46:58 <doserj> definitely not in Floating
04:47:40 <pBot-> Real?
04:47:44 <doserj> but your code also claims to work for any Floating a, whereas apparently it requires a to be int
04:49:02 <doserj> @instances Real
04:49:03 <lambdabot> Double, Float, Int, Integer
04:49:11 <doserj> @instances Floating
04:49:12 <lambdabot> Double, Float
04:49:58 <pBot-> oh, so Real a should be enough?
04:52:14 <quicksilver> pBot-: well your code (apparently) restrictis to Int anyway
04:52:25 <quicksilver> pBot-: in which case, the type is just String -> String -> Int
04:52:46 <quicksilver> pBot-: constraints in type signatures are customarily for unknown types. They're not so useful for known types :)
04:53:28 <pBot-> http://pastebin.com/m13c9fc66 <- there it is
04:53:50 <pBot-> Well, my function has to return a real, says my teacher... :o(
04:54:54 <quicksilver> pBot-: which function give the error?
04:55:10 <Vq^> pBot-: then it should be just (Real a)
04:55:11 <pBot-> jukesCantor
04:55:24 <quicksilver> I suspect the fault might lie with diffCount?
04:55:57 <quicksilver> jukesCantor will return the same type as diffCount, as you've written it there
04:56:17 <pBot-> diffCount needs to return Real too?
04:56:22 <Vq^> yes
04:56:29 <quicksilver> no
04:56:29 <wang> :)
04:56:31 <quicksilver> it doesn't
04:56:39 <quicksilver> but you have to convert diffCount's return value
04:56:43 <quicksilver> if it isn't what you want
04:56:57 <Vq^> right
04:57:02 <quicksilver> incidentally, jukesCantor can definitely never return (Real a) => a
04:57:15 <pBot-> it's Int, I tried changing it to Real a
04:57:26 <quicksilver> because jukesCantor uses /
04:57:28 <quicksilver> and Real doesn't have /
04:57:46 <quicksilver> (Int is an instance of Real, and Ints don't support /, for example)
04:58:09 <quicksilver> also you use log
04:58:11 <quicksilver> which is in Floating
04:58:39 <quicksilver> I think the most general constraint you can hope for is (Real a, Floating a)
04:58:42 <pBot-> Floating is in real though?
04:58:46 <quicksilver> no
04:58:50 <pBot-> oh ok
04:58:51 <quicksilver> Ints are Real but not Floating
04:59:23 <DRMacIver> Unless you chuck them in the water.
04:59:28 <pBot-> :D
04:59:44 <pBot-> Unless they are made of iron, then they are Sinking
04:59:44 <pBot-> :o
04:59:48 <quicksilver> Rationals are Real but not Floating, too
04:59:54 <ttfh> but what floats besides Ints?
05:00:00 <quicksilver> haskell uses Real in the sense of 'strictly not complex'
05:00:06 <ttfh> very small rocks?
05:00:16 <quicksilver> rather than the more common (but incorrect) computer science sense of 'floating point'
05:00:39 <birkenfeld> hey, I have another lambdacat picture
05:00:43 <birkenfeld> http://pocoo.org/~gbrandl/monomorph.png
05:01:49 <Vq^> ttfh: A Duck!
05:02:17 <DRMacIver> quicksilver: A more accurate description would probably be "can be embedded in the infinite precision real numbers".
05:02:20 <osfameron> burn it!
05:02:38 <DRMacIver> quicksilver: There are strictly not complex ordered number systems which you can't give a valid Real instance for.
05:02:48 <DRMacIver> (those containing infinitesimals for example)
05:03:14 <quicksilver> DRMacIver: well a literal interpretation of the haskell type is actually 'subset of the rationals'
05:03:30 <quicksilver> unless you believe that toRational is allowed to be non-injective
05:03:31 <Vq^> so if an Int uses more memory than a duck feather then quicksilver is a wizkid
05:04:53 <quicksilver> DRMacIver: by which argument, you'd think that implementations of the computable (potentially irrational) reals can't be a member of Real
05:05:02 <quicksilver> DRMacIver: in which light, it seems like a badly named class :)
05:05:46 <DRMacIver> quicksilver: Ha. True.
05:06:10 <SamB_XP> hmm. what would you talk about if you had 10 minutes to talk about functional programming?
05:06:17 <quicksilver> DRMacIver: but the thign is, I wasn't talking about 'putative other Num instances'. I was talking about 'those Num instances in the standard library'
05:06:36 <quicksilver> DRMacIver: and looking at those instances, the purpose of 'Real' really does seem to be 'not-Complex'
05:06:43 <Vq^> SamB_XP: to what crowd?
05:06:44 <quicksilver> DRMacIver: because everything except Complex is in Real
05:06:54 <sieni> SamB_XP: about how it kicks object-oriented programming's ass and how Java and Python suck
05:06:56 <SamB_XP> engineering freshman
05:07:04 <SamB_XP> sieni: in ten minutes?
05:07:32 <sieni> I guess you just have to include the flamebait and leave the argumentation part out
05:07:35 <quicksilver> if they're motivated engineers
05:07:41 <quicksilver> then something about it being good for safety
05:07:44 <quicksilver> programs without bugs
05:07:47 <SamB_XP> they are FRESHMAN
05:07:50 <quicksilver> they're pretty important for avionics and stuff
05:08:05 <quicksilver> if they're not motivated, tell them it will get them sex and free beer
05:08:15 <quicksilver> I don't think that's true, but it's all they'll be interested in
05:08:34 <DRMacIver> quicksilver: ok. Fair point. :)
05:08:37 <SamB_XP> also this is for class
05:08:50 <DRMacIver> SamB_XP: What's the class?
05:09:15 <SamB_XP> "What kind of Engineer do you want to be when you grow up?" class, basically
05:09:52 <sieni> I guess the moest will answer "A married engineer or one with a girlfriend."
05:10:15 <SamB_XP> well they don't call it that
05:10:33 <DRMacIver> SamB_XP: What do you use Haskell for? Anything interesting you could demo?
05:11:09 <SamB_XP> it actually has two purposes: to help people decide which engineering major to take, and to prepare them for the writing they'll have to do later
05:11:29 * DRMacIver thinks "ooh, cool! Now lets take it apart to see how it works." is a useful reaction to foster. :)
05:12:04 <SamB_XP> DRMacIver: hmm, I don't think I'm supposed to do a demo exactly
05:12:24 <SamB_XP> I was thinking maybe a side-by-side comparison with imperative code or something ;-)
05:12:41 <DRMacIver> Don't. Please.
05:13:04 <SamB_XP> hmm.
05:13:09 <DRMacIver> This constant "We're so much better than imperative code!!!" pissing match is *so* tiresome, and I'm already on the FP side.
05:13:28 <SamB_XP> well, I wasn't necessarily going to say that it was better always
05:13:51 <SamB_XP> in fact I'd be first in line to argue if I said that
05:14:43 <DRMacIver> That's something at least. :) Still, I don't think compare and contrast is a useful thing to do in a 10 minute talk.
05:15:08 <DRMacIver> I stand by the "Show them something cool" approach, even if it's code rather than a demo.
05:15:41 <SamB_XP> I was going to do it on Lava... but that would probably be over their heads
05:16:00 <SamB_XP> apparantly digital logic is not a required course in most highschools
05:19:55 <DRMacIver> Hm. I don't actually know enough to know what you could do in Haskell that would count as "something cool".
05:20:56 <osfameron> for an audience of programmers some examples of pattern matching and how nice the syntax is might be convincing
05:21:09 <osfameron> also, how easy it is to work with user defined types
05:22:01 <DRMacIver> Hm. The danger of that is of turning into a slightly higher version of the class "Here's how to write factorial in my favouritest language ever!"
05:22:27 <DRMacIver> Giving people solutions to problems they don't care about in languages they don't know isn't the best introduction. :)
05:22:44 <DRMacIver> Although it's a good idea if you can come up with nice examples.
05:30:45 <osfameron> I went through some haskell with my cousin (who admittedly is a maths/financial-computing wizzkid) and he seemed pretty impressed
05:31:08 <osfameron> (bear in mind I only know some baby haskell, but we looked at some of the project euler stuff)
05:31:37 <osfameron> probably to someone less mathsy there's more the "woah, that's weird syntax" thing to get over
05:31:46 <DRMacIver> Hm.
05:33:26 <DRMacIver> How many of you would claim to know Haskell reasonably well and how many are in a similar boat to osfameron (and me) in only knowing relatively basic Haskell?
05:33:26 <pejo> osfameron, the 'nice' syntax was mentioned as one thing that scares people in the speech by Tim Sweeney on POPL'06.
05:34:12 <DRMacIver> Because I've noticed at the London HUG that we tend to have a handful of people who actually know the language well and lots of frustrated Java/C#/etc. programmers who just dabble with it. :)
05:35:00 <mrd> I know relatively haskell Basic
05:35:47 <pejo> DRMacIver, you can do surprisingly 'difficult' stuff without knowing much Haskell though.
05:36:05 <SamB_XP> define "basic haskell"
05:36:32 <DRMacIver> pejo: Yes, I know.
05:36:45 <DRMacIver> SamB_XP: I'd rather let people define that for themselves.
05:38:12 <DRMacIver> I'm not trying to make any deep observation here. Just curious as to how people will self-evaluate. :)
05:39:14 <SamB_XP> I can do basic type hackery
05:39:51 <quicksilver> type hackery is traditionally measured in milliolegs
05:40:03 <quicksilver> I believe my ability is somewhere around 10mo
05:44:19 <osfameron> my self-definition of "basic" is I'm comfortable with map, filter, folds, and basic currying, regularly get confused with function composition, and cry at fix :-)
05:44:41 <osfameron> also, I've *heard* of type hackery :D
05:47:33 <DRMacIver> Hm. Ok. My self definition is a little less basic than that. :)
05:47:51 <SamB_XP> haskell type hackery is less obscure, I think, than C++ template hackery at least
05:48:35 <DRMacIver> (Mine is that I start to struggle when writing non-trivially large Haskell programs - more than a dozen lines or so)
05:49:44 <DRMacIver> (well, a few dozen lines these days I suppose)
05:50:18 <osfameron> my first sketch at a Dope Wars clone is already 118 lines... I must be doing it wrong :-)
05:50:43 <haraldk> DRMacIver: it may be a good idea to just code uncritically for a while
05:50:56 <DRMacIver> haraldk: That's what I'm doing.
05:51:11 <haraldk> I'm not very good at haskell, but I did make a minesweeper clone :-)
05:51:26 <DRMacIver> haraldk: "start to struggle" doesn't mean I can't write it. It means that I run into hairy problems I don't understand and get stuck for a while trying to fix them. :)
05:51:40 <haraldk> Probably not very functionally correct (especially not the gtk2hs GUI) but interesting experience
05:52:20 <haraldk> DRMacIver: What are you trying to do, then? Something a trifle more ambitious than me, probably :-)
05:53:39 <EvilTerran> i keep ending up yak-shaving whenever i try to do something sizable in haskell
05:54:16 <DRMacIver> A couple of things. Right now I'm playing with some code for generating searchable indexes of texts (it's basically a String indexed map which can answer questions like "Give me all key value pairs where the key matches <regexp>").
05:54:41 <DRMacIver> I've also played around with parsec a bit. Some things worked really nicely, but when I tried to turn it to parsing some email files (bastardised mbox format basically) I got completely stuck.
05:55:08 <DRMacIver> Other than that I've done a little bit with quad trees and HOpenGL and played around with a lot of one liners.
05:56:01 <DRMacIver> (Hm. That sounds less basic than I thought now that I say it 'out loud'. But it still feels basic)
06:00:14 <ToRA> DRMacIver: what have you been doing in opengl?
06:00:31 <quicksilver> I don't really like parsec
06:00:37 <quicksilver> I don't like its interface
06:00:56 <mux> parsec is one of those things that sold me to haskell :p
06:00:59 <quicksilver> in particular the fact it doesn't backtrack by default
06:01:07 <mux> if you don't like parsec, I dare say you haven't used lex/yacc enough :-)
06:01:08 <quicksilver> oh, the idea of parser combinators is lovely
06:01:10 <DRMacIver> ToRA: Very little. I wrote some code and wanted to hook up a way of visualising the results to it, so I did.
06:01:16 <quicksilver> I just don't think parsec is a very pretty one
06:01:24 <mux> you like PolyParse bette?
06:01:26 <quicksilver> thus far I have mostly written my own on demand
06:01:35 <quicksilver> I did look at polyparse, yes I think it's prettier
06:01:59 <quicksilver> but I view parser combinators more as an implementation technique
06:02:00 <mux> I found the API to be very similar, but I didn't have a very close look
06:02:04 <quicksilver> tha somethin you actually need a library for
06:02:22 <quicksilver> I don't find there is much duplicated code in just writing it each time
06:02:29 <quicksilver> and it means you can specialise it to your needs
06:03:04 <quicksilver> mind you, I think that's partly because I've never been CPU-bound on parsing
06:03:08 <quicksilver> mostly parsing small files and stuff
06:05:38 <pejo> quicksilver, have you seen Parsek?
06:05:55 <quicksilver> pejo: no
06:06:32 <mux> I'd like it a lot if there was a broad consensus on some monadic parsing library to use with haskell
06:06:46 <pejo> quicksilver, http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/koen/Parsek.hs
06:06:48 <lambdabot> http://tinyurl.com/yxnngl
06:08:10 <quicksilver> pejo: that would seem to solve my most serious objection, yes :)
06:08:19 <mux> indeed
06:08:57 <mux> it seems there isn't any user-state in Parsek, while there is one in Parsec
06:09:12 * quicksilver nods
06:09:25 <mux> I wouldn't mind at all if there was a ParsekT monad combinator
06:09:29 <mux> but it seems there isn't either
06:09:42 <quicksilver> a general truth with parser combinators seems to be that it's easy to write a simple, elegant parser system with combinators
06:09:49 <quicksilver> as long as you don't care about error messages
06:09:57 <osfameron> hehe
06:09:58 <quicksilver> or (even harder) recovery
06:09:59 <mux> Parsec is very good at error messages
06:10:08 <EvilTerran> that Parsek thing looks vaguely similar to ReadP, what with the parallel choice idea
06:10:12 <mrd> Parsek is GPL, ugh
06:10:20 <quicksilver> but once you try to solve the error message problem you screw up your elegance
06:10:23 <mux> ew, didn't see that
06:11:00 <mux> s/didn't see/I hadn't seen/
06:11:05 <mux> I'll try to speak a correct english for a change
06:11:08 <quicksilver> since my parsers have all been for toy projects, I haven't bothered with error mesags and not recovery
06:11:19 <mrd> that's lame since Parsec is not GPL
06:11:31 <EvilTerran> @docs Text.ParserCombinators.ReadP
06:11:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadP.html
06:11:59 <osfameron> most programming/query langauges don't bother with decent error reporting either...
06:12:06 <_fang> hello, how can i get this function to return a list of Integers?
06:12:08 <hpaste>  _fang pasted "returning [Integer]" at http://hpaste.org/3230
06:14:45 <quicksilver> _fang: 'round' them first?
06:14:54 <quicksilver> _fang: round converts Float to Integer
06:14:58 <_fang> sorry guys, if the computer doesn't crash before i can read you it would be better =]
06:15:21 <_fang> quicksilver: i should round the 'h's ?
06:15:27 * earthy mumbles 'UU.Parser'
06:15:29 <twanvl> Or use `div` instead of / (assuming the algorithm is still correct if you do that)
06:15:43 <quicksilver> you could just 'map round' the output of linhaTriangulo'
06:15:47 <earthy> error-correcting deterministic parsercombinators, and faster than Parsec to boot
06:15:59 <earthy> not sure about the license though
06:17:59 <_fang> quicksilver: thank you very much! \o
06:23:15 <quicksilver> _fang: :)
06:24:38 <hpaste>  n00b pasted "recursve power" at http://hpaste.org/3231
06:24:59 <n00b> what is wrong with my recursive power function
06:26:04 <pejo> n00b, that it actually computes the factorial?
06:26:16 <n00b> ok
06:26:25 <n00b> can you anonate for me please
06:26:35 <n00b> where I am going wrong
06:27:20 <pejo> n00b, what should a power function take as input?
06:28:04 <matthew_-> fuel
06:28:09 <hpaste>  n00b pasted "recursve power 2" at http://hpaste.org/3232
06:28:35 <n00b> look at the new one
06:29:10 <n00b> > let power = n ^ n in power 2
06:29:18 <lambdabot>   Not in scope: `n'
06:29:26 <n00b> > let power  n = n ^ n in power 2
06:29:31 <lambdabot>  4
06:29:36 <n00b> > let power  3 = n ^ n in power 2
06:29:37 <lambdabot>   Not in scope: `n'
06:29:44 <n00b> > let power  n = n ^ n in power 3
06:29:46 <lambdabot>  27
06:31:18 <n00b> <pejo> how does the new one looks ??/
06:33:38 <pejo> n00b, does it work?
06:33:53 <n00b> yes
06:34:06 <n00b> but i dont want two inputs
06:34:23 <n00b> i only w3ant one. Can it be done that way ??/
06:34:31 <dcoutts_> @seen SyntaxNonja
06:34:31 <lambdabot> I haven't seen SyntaxNonja.
06:34:33 <dcoutts_> doh
06:34:35 <dcoutts_> @seen SyntaxNinja
06:34:36 <lambdabot> I saw SyntaxNinja leaving #haskell, #haskell-blah and #haskell-soc 12h 54m 18s ago, and .
06:34:48 <pejo> n00b, how is the function supposed to know what to compute the power of if you only have one input?
06:35:37 <n00b> can't it take one input and  find the power of it?
06:36:17 <hpaste>  noob pasted "non recursive" at http://hpaste.org/3233
06:36:28 <n00b> like the the none recursive
06:37:32 <pejo> n00b, so you don't want to be able to compute x^y for any x, y, but rather x^x for any x?
06:37:39 <pgavin> > let power a = a ^ a in power 2
06:37:50 <n00b> yes
06:37:50 <lambdabot>  4
06:37:57 <n00b> but it suppose
06:37:58 <pgavin> > let power x y = x ^ y in power 2 3
06:37:59 <lambdabot>  8
06:38:01 <n00b> to be recursive
06:38:11 <pejo> n00b, make an internal helper function that takes two parameters then.
06:38:25 <n00b> > let power p = p * p in power 3
06:38:26 <lambdabot>  9
06:38:29 <pgavin> > let power x y = x * power x (y-1) in power 2 3
06:38:32 <lambdabot> Terminated
06:38:34 <pgavin> lol
06:38:51 <n00b> but wouldn't that be iteratieve ??
06:38:52 <pgavin> let power x 0 = 1 ; power x y = x * power x (y-1) in power 2 3
06:39:10 <pgavin> > let power x 0 = 1 ; power x y = x * power x (y-1) in power 2 3
06:39:12 <lambdabot>  8
06:39:55 <pgavin> n00b: recursion and iteration are the same thing
06:40:15 <pgavin> n00b: well actually, recursion is more powerful than iteration
06:40:35 <doserj> ?
06:40:46 <pgavin> n00b: anything you can do with iteration you can do with recursion
06:41:11 <hpaste>  n00b pasted "iterative power" at http://hpaste.org/3234
06:41:26 <n00b> look at that
06:41:38 <pgavin> uggh
06:41:47 <mauke> that's an error
06:41:56 <n00b> it works for me
06:41:59 <mauke> multiple errors, actually
06:42:12 <mauke> no, it doesn't
06:42:45 <pgavin> > let power x 0 acc = acc ; power x y acc = power x (y-1) (acc*x) in power 2 3 1
06:42:47 <lambdabot>  8
06:43:08 <pgavin> n00b: ^^^
06:44:14 <hpaste>  noob annotated "iterative power" with "iterative power" at http://hpaste.org/3234#a1
06:44:28 <n00b> sorry left out something
06:44:31 <n00b> look at it now
06:44:55 <doserj> ...
06:45:40 <doserj> n00b: how many times do you think the "otherwise" branch will be taken?
06:46:33 <mauke> n00b: that's recursive
06:46:33 <mauke> pow calls itself
06:47:03 <hpaste>  n00b annotated "iterative power" with "iterative power" at http://hpaste.org/3234#a2
06:47:05 <pgavin> n00b: haskell doesn't support iteration in the C sense
06:47:14 <n00b> look at it now
06:47:21 <n00b> make some changes
06:48:06 <hpaste>  noob annotated "iterative power" with "iterative power" at http://hpaste.org/3234#a3
06:48:21 <n00b> how does it look now (iterative)
06:48:35 <doserj> I think you want "step == n = total ; otherwise = pow (step+1) (total*step)""
06:48:38 <mauke> n00b: that's recursive
06:48:44 <mauke> pow calls itself
06:49:33 <EvilTerran> it's iterative in the sense of tail-recursive
06:49:43 <EvilTerran> not that that's particularly meaningful in a lazy language
06:49:46 <doserj> erm... otherwise = pow (step+1) (total*n), rather
06:50:33 <mauke> yeah, it's not strict
06:50:51 <pgavin> n00b: that's a really awkward way to write your function
06:50:57 <doserj> I'm getting confused by this code and worried about off-by-one errors...
06:51:47 <osfameron> yeah
06:51:47 <n00b> <doserj> that doesn't work
06:52:06 <ttfh> don't they talk about "iterative procedures" vs "recursive procedures" or some such in SICP? they call something thats tail-recursive an iterative procedure?
06:52:24 <n00b> <doserj> giving ,e factorial
06:53:11 <pgavin> ttfh: sure, but its better not to call it iterative
06:53:15 <doserj> n00b: the (total*step) version gives a factorial, yes. the (total*n) version should give some power of n
06:54:00 <pgavin> ttfh: plus, that's scheme, and scheme isn't lazy
06:54:14 <n00b> <doserj> tiried and keep getting factorial
06:55:02 <Olathe> Scheme isn't lazy like *some* languages that need not be named around here.
06:55:32 <n00b> I did a function trace and keeps getting errors
06:55:48 <n00b> how do I write it in a recursive form ???
06:55:57 <mauke> n00b: it already is recursive
06:56:07 <mauke> doserj: it computes n^(n-1)
06:56:34 <mauke> except you have to fix the indentation because it doesn't parse as pasted
06:56:38 <doserj> mauke: I said I was worried about off-by-one errors :)
06:56:50 <pgavin> n00b: you want a function that computes n^n, right?
06:57:38 <doserj> but too lazy to fix it when there is no danger of an off-by-one error in the right approach
06:58:24 <DRMacIver> I always get this confused look on my face when I manage to produce off by one errors in Haskell.
06:58:34 <DRMacIver> It feels like something that shouldn't happen. :)
06:59:32 <n00b> yes
06:59:46 <n00b> <pgavin>  yes, recursive with only one input
06:59:54 <n00b> Int -> Int
07:04:10 <pgavin> n00b: sorry, was afk
07:04:21 <pgavin> n00b: well, I gave you an example earlier
07:04:47 <pgavin> > let power x 0 acc = acc ; power x y acc = power x (y-1) (acc*x) in power 3 3 1
07:04:49 <lambdabot>  27
07:05:46 <pgavin> > let power x = power' x x 1; power x 0 acc = acc; power' x y acc = power' x (y-1) (acc*x) in power 3
07:05:47 <lambdabot>  arity mismatch for 'power'
07:06:18 <pgavin> > let power x = power' x x 1 ; power' x 0 acc = acc ; power' x y acc = power' x (y-1) (acc*x) in power 3
07:06:19 <lambdabot>  27
07:06:38 <pgavin> that's recursive
07:08:50 <doserj> > let power n = pow n n ; pow n 0 = 1 ; pow n k = n * pow n (k-1) in power 4
07:08:52 <lambdabot>  256
07:08:56 <vincenz> pgavin: that's iterative
07:09:05 <doserj> that is the "idiomatic" version
07:09:25 <Olathe> let power = join pow; pow n 0 = 1; pow n k = n * pow n (k-1) in power 4
07:09:31 <Olathe> > let power = join pow; pow n 0 = 1; pow n k = n * pow n (k-1) in power 4
07:09:32 <lambdabot>  256
07:09:46 <EvilTerran> there's the O(log k) algorithm for n^k, too...
07:09:47 <doserj> that is even more idiomatic :)
07:10:25 <pgavin> :t runState
07:10:27 <lambdabot> forall s a. State s a -> s -> (a, s)
07:10:43 <EvilTerran> > product . join replicate $ 4
07:10:45 <lambdabot>  256
07:10:53 <pgavin> nice
07:10:59 <EvilTerran> in terms of idiomatic :D
07:11:04 <Olathe> O-o
07:11:17 <EvilTerran> > join replicate 4
07:11:18 <lambdabot>  [4,4,4,4]
07:11:20 <Olathe> @unpl product . join replicate $ 4
07:11:20 <lambdabot> (product ((replicate >>= \ f -> f) 4))
07:11:24 <Olathe> Eww.
07:11:35 <EvilTerran> \x -> product $ replicate x x
07:11:43 <Olathe> That's neat.
07:11:54 <mauke> join (^)
07:12:04 <vincenz> > product . join replicate $ x
07:12:05 <lambdabot>   Not in scope: `x'
07:12:07 <vincenz> > product . join replicate $ 4
07:12:09 <lambdabot>  256
07:12:11 <pgavin> > foldr (\x acc -> x * acc) 1 (replicate 4 4)
07:12:13 <lambdabot>  256
07:12:14 <vincenz> join ftw
07:12:20 <mauke> > join (^) 5
07:12:22 <lambdabot>  3125
07:12:25 <EvilTerran> vincenz, i just said that a minute ago..
07:12:26 <vincenz> reader monad is ugly :)
07:12:30 <Olathe> @pl \x -> product . join replicate $ x
07:12:30 <lambdabot> product . join replicate
07:12:38 <vincenz> EvilTerran: heh, too much spam and was just peeping in
07:12:47 <EvilTerran> okay then :)
07:12:59 <osfameron> @index join
07:12:59 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:13:02 <pgavin> > foldr (*) 1 (replicate 4 4)
07:13:03 <lambdabot>  256
07:13:22 <Olathe> @src product
07:13:23 <lambdabot> product = foldl (*) 1
07:13:28 <pgavin> lolz
07:13:42 <pgavin> I need to learn my prelude better :)
07:14:55 <byorgey> pgavin: doesn't everyone? =)
07:20:01 <vincenz> product should be foldl'!
07:20:28 <doserj> if foldl' would be in the prelude...
07:20:34 <vincenz> meh
07:20:39 <vincenz> so many open holes
07:20:46 <EvilTerran> what if (*) isn't strict in some number representation?
07:21:04 <vincenz> EvilTerran: doesn't change anything
07:21:12 <byorgey> well, then you probably know enough to define your own version of product using lazy foldl.
07:21:27 <EvilTerran> i say there should be sum' and product' in Numeric
07:21:34 <sioraiocht> actually
07:21:37 <vincenz> I say we should have TC aliases and numeric prelude
07:21:39 <sioraiocht> sum and product should jsut be strict anyway
07:22:00 <hpaste>  matveev pasted "binary write" at http://hpaste.org/3235
07:22:05 <pgavin> hmm, the haskell wikibook says that foldl should almost never be used
07:22:09 <pgavin> didn't realize that
07:22:18 <EvilTerran> vincenz, why doesn't it change anything?
07:22:23 <sioraiocht> TC?
07:22:29 <pgavin> http://en.wikibooks.org/wiki/Haskell/List_Processing
07:22:59 <EvilTerran> in the (admittedly unlikely) case that (*) can be non-strict in its first parameter, forcing stricture of the accumulator could introduce bottoms that weren't there previously
07:23:41 <EvilTerran> > foldl (flip const) undefined [undefined,undefined,undefined,1]
07:23:42 <lambdabot>  1
07:23:44 <EvilTerran> > foldl' (flip const) undefined [undefined,undefined,undefined,1]
07:23:45 <lambdabot>  Undefined
07:24:04 <Olathe> Why is foldl bad ?
07:24:04 <vincenz> EvilTerran: ok, I assume that foldl' is something like
07:24:11 <vincenz> foldl' f !a l
07:24:12 <vincenz> right?
07:24:17 <vincenz> so we strictify a
07:24:46 <vincenz> If the number representation is lazy, then although we mighgt be strictifying the data-constructor, we're not strictifying its fields which will not posisbly be strict, otherwise the number representation can not be lazy.
07:25:16 <matveev> Hello. Cannot implement fortran "write" equivalen that takes anything and dumps to file. Whats wrong with "save" in http://hpaste.org/3235.  (also tried Storable a =>)
07:26:10 <mauke> what's the error?
07:26:14 <EvilTerran> we're still strictifying the top constructor, though, and someone might trip over that if they're not expecting it
07:26:25 <vincenz> EvilTerran: not really
07:26:29 <vincenz> EvilTerran: it's like writing
07:26:32 <EvilTerran> hence my suggestion that the strict functions follow the existing naming convention
07:26:35 <vincenz> foldl' f (Foo x) l = ...
07:26:41 <vincenz> we're not strictifying 'x'
07:26:45 <EvilTerran> I KNOW
07:26:59 <vincenz> ok
07:27:08 <EvilTerran> but someone might happen to write a Num instance where { _ * 0 = 0 }, say
07:27:20 <mauke> they can write their own product
07:27:32 <vincenz> correct
07:27:36 <mauke> stuff should be optimized for the most common use
07:28:08 <vincenz> EvilTerran: btw, there you're fully strictifying the second element..
07:28:17 <EvilTerran> yeah. so?
07:28:39 <EvilTerran> not fully strictifying the first, so doing a product of a list ending in 0 will work
07:28:49 <EvilTerran> even with _|_s earlier in the list
07:28:54 <pgavin> matveev: why are you using storable? that's for pointers and FFI stuff
07:28:54 <EvilTerran> but not if you force stricture
07:28:59 <hpaste>  matveev annotated "binary write" with "(no title)" at http://hpaste.org/3235#a1
07:29:36 <pgavin> try replacing the "a" in save's type with Int
07:29:37 <EvilTerran> mauke, ah, there's a difference of opinion. i'd rather take the theoretically pure tack rather than the pragmatist's one ;)
07:29:54 <pgavin> matveev: save :: (Int -> IO ()) -> IO ()
07:30:42 <matveev> pgavin: hPutBuf accepts only pointers. That is why. with a (\x -> hPutBuf h x) needs pointer
07:30:45 <EvilTerran> i'd intuitively make product a foldr, actually, although i'm sure there was a good reason they used foldl in the standard
07:31:10 <EvilTerran> but, as i said, i'd appreciate strict *alternatives* to sum and product, with primes, in the standard libraries
07:31:13 <pgavin> matveev: ok... have you thought about using Show instead?
07:32:28 <pgavin> matveev: the problem with your save function is that the type wf is (Storable a => a -> IO ())
07:32:35 <matveev> pgavin:  (writef handle)  is of type Storable a => a -> IO (), why cannot "save" accept that?
07:32:49 <pgavin> matveev: but you're trying to force it to be  Int -> IO()
07:33:04 <pgavin> matveev: when you actually don't know what the type a is
07:33:28 <vincenz> EvilTerran: if your number is lazy, you want the laziness to below it's datga-constructor, not above.  foldl' just makes sure the expressions above your data-constructor are strictified, and I think that is a good idea.
07:33:57 <EvilTerran> why do i always want the laziness below the data constructor?
07:34:05 <vincenz> what?
07:34:09 <pgavin> matveev: try this:  save :: Storable a => a -> (a -> IO ()) -> IO ()
07:34:09 <vincenz> EvilTerran: that's up to you
07:34:13 <vincenz> EvilTerran: that's orthoggonal to the issue
07:34:20 <EvilTerran> it's what you just asserted
07:34:21 <vincenz> if you don't want laziness there, perfect
07:34:32 <vincenz> I asserted that laziness above teh data-constructor is not useful.
07:34:40 <EvilTerran> and why isn't it?
07:34:45 <pgavin> matveev: then: save x wf = wf x
07:34:51 <matveev> pgavin: I want to call both "wf (1::Int)" and "wf (1::Double)" (and more) from "save". Better name --- "save_all_poosible_staff_to_disk"
07:35:04 <pgavin> matveev: right, I understand
07:35:06 <vincenz> EvilTerran: I can't answer to that, gut feeling
07:35:12 <vincenz> EvilTerran: I'll think on it a bit.
07:35:21 <EvilTerran> what's the harm in being able to multiply _|_ by 0 and getting 0?
07:35:29 <EvilTerran> (in a numeric type without infinities, anyway)
07:35:38 <vincenz>           ^^^^^^^^^^^
07:35:39 <vincenz> erm
07:35:42 <vincenz> add more spacs
07:35:45 <pgavin> matveev: the type of wf is more general than just Int -> IO(), that's why the compiler is complaining
07:36:23 <EvilTerran> was that supposed to point to "infinities"?
07:36:33 <doserj> > (1/0)*0
07:36:35 <lambdabot>  0.0
07:37:00 <doserj> i will never understand IEEE floats...
07:37:08 <sioraiocht> doserj: what don't you understand?
07:37:30 <mauke> that's supposed to be NaN
07:37:39 <vincenz> EvilTerran: yep :)
07:37:41 <sioraiocht> > 1 / 0
07:37:42 <lambdabot>  Infinity
07:37:45 <matveev> pgavin: how do I make the type of "save" more general to match that/use with the "(writef handle) :: Storable a => (a -> IO())" below?
07:37:53 <mauke> @let inf = 1/0
07:37:59 <lambdabot> Defined.
07:38:03 <sioraiocht> inf * 0
07:38:03 <mauke> > inf*0
07:38:04 <EvilTerran> okay then
07:38:05 <lambdabot>  0.0
07:38:11 <pgavin> matveev: don't pass wf the value (1 :: Int)
07:38:11 <sioraiocht> *shrugs*
07:38:14 <sioraiocht> that's how it should be
07:38:28 <mauke> > inf - inf
07:38:29 <lambdabot>  NaN
07:38:43 <EvilTerran> i thought inf*0 was NaN?
07:38:48 <sioraiocht> why?
07:38:53 <sioraiocht> 0 of anything is 0
07:38:59 <sioraiocht> > 0 / 0
07:39:00 <lambdabot>  NaN
07:39:03 <EvilTerran> infinity of anything is infinity
07:39:06 <matveev> pgavin: and how am I supposed to write things? As (1::Storable)?
07:39:06 <vincenz> sioraiocht: no it's not
07:39:13 <sioraiocht> vincenz: ?
07:39:15 <vincenz> sioraiocht: ever heard of hopital?
07:39:20 <sioraiocht> vincenz: yes
07:39:28 <pgavin> matveev: you could do (1 :: (Storable a, Num a => a))
07:39:31 <vincenz> well, when you just have 0 and inf, you dont know their assymptotic behaviour
07:39:33 <vincenz> hence it's NaN
07:39:49 <EvilTerran> 0*inf = 0 * (1/0) = (0*1)/0 = 0/0 = NaN, as i intuit it
07:39:59 <pgavin> matveev: errm, that wont work
07:40:13 <sioraiocht> infinity isn't equivalent to 1/0, though
07:40:23 <EvilTerran> incidentally, http://en.wikipedia.org/wiki/NaN#How_is_a_NaN_created.3F says lambdabot's doing it wrong, i think
07:40:34 <sioraiocht> *shrugs*
07:40:35 <EvilTerran> "The following practices may cause NaNs: ... The multiplications 0Ã—âˆž and 0Ã—-âˆž"
07:40:36 <pgavin> matveev: umm, you'll have to give save a second argument
07:40:46 <sioraiocht> yeah
07:40:50 <sioraiocht> ghci does NaN
07:42:21 <vincenz> > 1/0 * 0
07:42:22 <lambdabot>  0.0
07:42:33 <quicksilver> I thought IEEE said 0 * inf was NaN, yeah
07:42:43 <quicksilver> I strongly suspect LB compiles code with slightly funky options
07:42:45 <vincenz> it is in ghci
07:42:46 <quicksilver> I'm not sure
07:42:47 <vincenz> lb is bugggy
07:42:54 <pgavin> quicksilver: that's right, I think
07:43:04 <pgavin> quicksilver: because 0/0 is definitely nan
07:43:45 <pgavin> > 0. / 0.
07:43:45 <lambdabot>  Parse error
07:43:50 <pgavin> > 0.0 / 0.0
07:43:51 <doserj> than my understanding of IEEE isn't that bad after all (puh)
07:43:52 <lambdabot>  NaN
07:44:00 <pgavin> > 1.0 / 0.0 * 0.0
07:44:01 <lambdabot>  NaN
07:44:07 <matveev> pgavin:  I ahve such "writef handle storable" and wanted to write "save_the_state_with_this_writer_function (writef handle)"
07:44:11 <pgavin> gotta use doubles :)
07:44:29 <mauke> -O breaks it
07:44:52 <pgavin> matveev: ok, so you'll have to pass an argument to save_the_state...
07:45:25 <pgavin> matveev: save_the_state :: Storable a => a -> (a -> IO ()) -> IO ()
07:45:30 <pgavin> afk
07:47:05 <matveev> pgavin:  That is not "save_the_whole_state", that is "save_only_one_var". I am trying to do this "save_the_state writer_function = ???" :: ???
07:49:41 <vincenz> matveev: what will you do with lazy values?
07:49:49 <vincenz> matveev: the question you're asking is antything but trivial
07:58:53 <hpaste>  quicksilver annotated "binary write" with "the answer is rank-2 types" at http://hpaste.org/3235#a2
07:58:58 <quicksilver> matveev: there you go
07:59:08 <quicksilver> matveev: you had a forall where you really wanted an exists
08:00:49 <quicksilver> matveev: or, alternative, a nested forall. Known as rank-2 types.
08:01:42 <matveev> vincenz, quicksilver:  i dont need "forall", I need (Storable  a => (a -> IO()) -> IO() ). See "writef" it is half-way there already.
08:02:04 <quicksilver> matveev: did you read my paste?
08:02:12 <dons> ?yow
08:02:13 <lambdabot> Now my EMOTIONAL RESOURCES are heavily committed to 23% of the SMELTING
08:02:13 <lambdabot> and REFINING industry of the state of NEVADA!!
08:02:17 <quicksilver> matveev: I made your code compile
08:02:18 <dons> ?users
08:02:18 <lambdabot> Maximum users seen in #haskell: 420, currently: 369 (87.9%), active: 12 (3.3%)
08:03:25 <matveev> quicksiver: I did read -- dindnt get.
08:03:47 <quicksilver> wel, it's the answer :)
08:04:09 <quicksilver> your type Storable a => (a -> IO()) -> IO () means:
08:04:39 <quicksilver> "given, for some Storable type a, an action a -> IO ()), this is an IO () action
08:04:56 <quicksilver> my type (forall a . Storable a => a -> IO () ) -> IO () means :
08:05:16 <quicksilver> given a generic actions a -> IO() which works on *every* Storable a, produce an IO() action
08:05:20 <glen_quagmire> that means you print a to IO
08:05:25 <quicksilver> it's the different between 'every' and 'some'
08:05:43 <quicksilver> or 'all' and 'any'
08:06:07 <matveev> quicksiver: thanks. I would never have come to that!
08:06:12 <doserj> or moving "forall" over an implication...
08:08:42 <quicksilver> matveev: I would caution you that this isn't permitted in haskell-98
08:08:49 <quicksilver> matveev: rank-2 types are a GHC extension
08:08:51 <quicksilver> they are handy
08:09:03 <quicksilver> (although actually I'd not used them myself except via ST)
08:09:37 <quicksilver> doserj: am I right in thinking that existential types give you a way to encode rank-2 types, albeit with a constructor in the way?
08:09:55 <doserj> yep
08:10:07 <quicksilver> why are they different extensions
08:10:13 <quicksilver> what is the key difference? :)
08:10:27 <quicksilver> I've used existentials quite a lot, I find them very handy
08:11:17 <EvilTerran> am i right in thinking you can express existentials as GADTs?
08:11:53 <vincenz> erm
08:11:54 <EvilTerran> data Foo :: * -> * where Foo :: (b -> a) -> b -> Foo a; kinda thing
08:11:54 <quicksilver> EvilTerran: well only by having polymorphic constructors
08:12:04 <vincenz> you can express existential as normal data types
08:12:06 <quicksilver> EvilTerran: which is the same way you make existentials without GADTs...
08:12:18 * vincenz says the same as quicksilver 
08:12:36 <EvilTerran> quicksilver, er, don't you need explicit forall.s in the case of normal data types?
08:12:39 <quicksilver> EvilTerran: maybe they make the syntax look slightly more uniform? but otherwise it's no change I don't think
08:13:53 <EvilTerran> i was thinking that there seems to be quite a bit of functionality between explicit forall.ing and GADTs without such, is all
08:30:05 <_ry> what does the <- operator do?
08:30:30 <ski> it extracts the monadic result of a monadic action, locally
08:30:34 <int-e> <- is not an operator. it's part of the  do  syntax.
08:30:42 <ski> it is syntactic sugar for `(>>=)'
08:30:46 <crazy_coder> is it possible to do neural network programming in haskell ?
08:30:51 <int-e> do a <- b; c --> b >>= \a -> do c
08:31:13 <puusorsa> crazy_coder, why wouldn't it be_
08:31:25 <yaarg> it's possible to do neural network programming in basic
08:31:29 <ski> also, `<-' is used in list comprehensions, and in pattern guards
08:31:29 <int-e> crazy_coder: be more specific. it's a general purpose language, so of course it's possible.
08:31:36 <ivan`> i would love a QBASIC neural network
08:31:56 <ivan`> if i load up QBASIC i will probably have nightmares though
08:32:06 <yaarg> 3heh
08:32:11 <ski> _ry : ok ?
08:32:15 <quicksilver> the problem with neural networks is you can't actually solve any useful problems with them
08:32:24 <quicksilver> so it's quite difficult to test your neural network code :)
08:32:27 <ivan`> evolutionary computing can though
08:32:47 <_ry> ski: yeah - i don't get it yet. but i think i have to do more reading.
08:32:49 <ivan`> anyway the tests just need to be a neural network too
08:33:02 <quicksilver> GAs? Yes, in restricted cases GAs can be useful. Although I strongly suspect it's more monte-carlo method than anything really evolutionary, in most cases.
08:36:16 <byorgey> _ry: if there's a specific example of something you're having trouble understanding, we could help you with that too.
08:36:44 <byorgey> _ry: if it's short (one or two lines) you can just paste it in here, otherwise use hpaste.
08:36:46 <crazy_coder> I want to learn how to do neural network programming for creating an othello playing bot
08:36:51 <byorgey> @hpaste
08:36:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:37:04 <crazy_coder> but I am confused with the selection of programming language
08:37:15 <crazy_coder> I have C as an option
08:37:36 <crazy_coder> also, i didn't find any code that can actually teach me the basics of it
08:38:07 <byorgey> crazy_coder: I would say (although some might disagree with me) that if your purpose is to learn about neural network programming, then you should use whatever language you are most comfortable with.
08:38:30 <DRMacIver> I agree. And if that language isn't Haskell then clearly you are evil heathen scum. ;)
08:38:39 <ivan`> there's some sort of superbot for othello
08:38:44 <byorgey> hehe, I wasn't going to mention that part =)
08:38:45 <ivan`> it's beaten the human champ
08:38:50 <_ry> byorgey: thanks, ski is helping me privately
08:39:00 <byorgey> _ry: ok, cool
08:39:12 <ivan`> check out 'logistello'
08:39:21 <ivan`> it never compiled for me but it's the best othello AI
08:39:46 <crazy_coder> Haskell is pretty good for rapid prototyping. So i thought I could use Haskell ....
08:39:54 <Olathe> http://jpmoresmau.blogspot.com/2007/06/very-dumb-neural-network-in-haskell.html
08:39:56 <lambdabot> Title: JP Moresmau's Programming Blog: A very dumb neural network in Haskell, http://tinyurl.com/273o85
08:39:56 <crazy_coder> even if i am not very good at it :)
08:40:54 <byorgey> crazy_coder: that's true, although I think most descriptions of neural networks are from an imperative perspective
08:40:58 <fasta> Is there an easy way to override the built-in if syntax?
08:41:11 <fasta> I'd rather just have if True 1 2
08:41:13 <byorgey> so you might have trouble for that reason.
08:41:37 <byorgey> fasta: I don't think there is, I just always define if'
08:41:50 <crazy_coder> hmm
08:41:58 <fasta> I also don't like that I need to put "do" everywhere.
08:42:36 <fasta> When I use a <- b, it implies that I want to use do-notation.
08:43:00 <fasta> Needing "do" is just a nuisance.
08:43:16 <byorgey> crazy_coder: I'm not trying to say you shouldn't use Haskell. =)  I'm just saying it would be a shame if you didn't end up learning anything about neural networks because you were struggling with Haskell. =)
08:43:44 <quicksilver> fasta: but when you write "a \n b"
08:43:53 <quicksilver> fasta: this means something quite different in do-notation or not
08:43:56 <crazy_coder> yeah. I understand.
08:44:17 <fasta> quicksilver: ok, then in the cases were it can decide it.
08:44:30 <fasta> quicksilver: I almost never use the case you mention.
08:44:35 <quicksilver> the thing about neural networks which will become very clear in a functional implementation are the way the order of propogation affects the results
08:44:56 <mauke> fasta: what's so bad about having to type two characters?
08:44:59 <ivan`> is there a way around that limitation, quicksilver?
08:45:09 <ivan`> N^2?
08:45:18 <ski> (mauke : mayhaps the extra indentation ?)
08:45:23 <fasta> mauke: it's not just two chars, it's also "then" and "else"
08:45:23 <byorgey> crazy_coder: but definitely check out that blog about a simple neural network in Haskell, that might be just what you need to get started
08:45:27 <quicksilver> fasta: *nod* certainly there are cases when it's not ambiguous. But the disadvantage of non-uniform syntax like that is that making a small change to code suddenly makes a big change to the way the syntax is parsed
08:45:30 <fasta> mauke: and it blurs the logic.
08:45:49 <quicksilver> ivan`: which limitation
08:45:52 <mauke> fasta: what? you can write your own if
08:45:57 <ivan`> that order affects the results
08:45:59 <fasta> mauke: I cannot override it.
08:46:01 <ivan`> which seems less than ideal?
08:46:08 <mauke> fasta: so use a different name
08:46:19 <quicksilver> ivan`: well you choose what order you want :)
08:46:36 <quicksilver> ivan`: you could do all time (t) propagation based entirely on (t-1) values
08:46:47 <quicksilver> ivan`: that is, of course, easier if you're thinking functionally
08:47:06 <quicksilver> ivan`: a traditional imperative program might already have stamped all over some of the (t-1) values
08:47:20 <ivan`> i don't think i'm capable of thinking functionally
08:47:22 <ivan`> i'm trying to learn though
08:47:23 <quicksilver> ivan`: or you can decide on a 'ripple path' which you think is right
08:47:39 <ivan`> i can convert imperative to functional but I can never understand it after that
08:47:41 <fasta> This syntax element should not be set in stone, imho.
08:47:57 <byorgey> ivan`: you are certainly capable, but perhaps it doesn't come naturally to you yet.  you'll get there. =)
08:48:04 <ski> fasta : `do' or `if' ?
08:48:18 <fasta> ski: I find if more annoying.
08:48:29 <fasta> ski: do is already rebindable, IIRC
08:48:55 <ski> perhaps it would be nicer if we had a `cond' ?
08:49:16 <fasta> ski: I already have one
08:49:41 <fasta> The nice thing about the if syntax is that it doesn't need one extra pair of parentheses.
08:50:29 <mauke> if_ x `then_` y `else_` z
08:51:43 <fasta> Creative, but not something I will use.
08:51:56 <fasta> I guess I will just use the fundepped cond again.
08:52:23 <fasta> That allows me to write cond (return True) 1 2 and cond True 1 2
08:52:41 <fasta> Er cond (return True) (return True) (return True)
08:53:30 <ski> fasta : i was thinking special syntax, probably with layout
08:54:28 <fasta> Anyway, macros are not useless, and I would use TH if it was documented properly.
08:55:32 <EvilTerran> it being complete would be a good start, too
09:00:43 <doserj> haskell's syntax not being so broad would help :)
09:00:52 <Beelsebob> @hoogle Integral a => [b] -> a -> [b]
09:00:53 <lambdabot> List.genericDrop :: Integral a => a -> [b] -> [b]
09:00:53 <lambdabot> List.genericTake :: Integral a => a -> [b] -> [b]
09:00:53 <lambdabot> Data.List.genericDrop :: Integral i => i -> [a] -> [a]
09:01:07 * Beelsebob pokes lambdabot 
09:01:12 <Beelsebob> ah, better
09:01:37 <Beelsebob> no List.removeAtIndex
09:03:20 <chessguy> @hoogle Int -> [b] -> [b]
09:03:20 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
09:03:21 <lambdabot> Prelude.take :: Int -> [a] -> [a]
09:03:21 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
09:03:42 <chessguy> that would be the more likely type
09:04:04 <Beelsebob> I assumed that hoogle would find them with the more general type specified
09:04:45 <doserj> @type Data.Map.delete
09:04:47 <lambdabot> forall k a. (Ord k) => k -> Data.Map.Map k a -> Data.Map.Map k a
09:05:03 <Beelsebob> this isn't a map
09:05:08 <Beelsebob> it's a list
09:05:16 <doserj> maybe you should use a map :)
09:05:27 <Beelsebob> maybe, but that isn't the question
09:05:32 <Beelsebob> I chose this data type for a reason
09:05:57 <Beelsebob> I'm surprised there isn't something like (!-) :: [a] -> Int -> [a], but nvm, easy enough to define
09:06:23 <chessguy> from a practical standpoint, the Int should come first
09:06:29 <chessguy> (probably)
09:07:17 <chessguy> because you're more likely to want a partial applcation like (!-) 3 than (!- myList)
09:08:26 <vincenz> erm
09:08:32 <vincenz> or just use sections :)
09:08:45 <vincenz> (! xs)
09:08:53 <chessguy> well sure, the same argument could be applied with sections
09:08:54 <vincenz> (xs !) even
09:09:06 <vincenz> in general
09:09:09 <vincenz> it's a good idea to have any operation do
09:09:15 <vincenz> bla -> bli -> blo -> foo -> foo
09:09:21 <vincenz> cause it's easier to foldr with and iterate with
09:09:37 <chessguy> what's bl?
09:09:40 <vincenz> whatever :)
09:09:48 <vincenz> just that you want foo -> foo as last
09:09:58 <vincenz> instead of foo -> bla -> bli -> blo -> foo
09:09:58 <chessguy> yeah
09:10:05 <chessguy> isn't that pretty much what i said? :)
09:10:10 <vincenz> yep :)
09:10:27 <Beelsebob> chessguy: yes, but it's infix
09:10:32 <Beelsebob> so you can do (!- 3)
09:10:32 <vincenz> and in detail, those practical reasons have to do with ease of use with iterate, foldr & co
09:10:44 <Beelsebob> and xs !- 3 makes more sense than 3 !- xs
09:10:49 <vincenz> Beelsebob: right
09:10:51 <vincenz> Beelsebob: and that is !
09:11:01 <quicksilver> consistency with !! and ! is nice, too
09:11:05 <vincenz> oh wait, nm
09:11:07 <vincenz> @type (!)
09:11:09 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
09:11:13 <quicksilver> since it's (list!!3) and (array!3)
09:11:17 <Beelsebob> sorry?
09:11:18 <vincenz> what does !- do?
09:11:52 <Beelsebob> it doesn't in general -- I was proposing that it should be added to List as an indexed item removal operator
09:11:58 <vincenz> oh
09:12:03 <Beelsebob> (xs !- 3) == xs with it's third item removed
09:12:10 <vincenz> I see
09:12:17 <Beelsebob> I do however appreciate that's not the way lists are meant to work
09:12:24 <vincenz> like ... let (h, t) = splitAt i in h ++ drop 1 t
09:12:27 <Beelsebob> so I see there's reasons for it not being there
09:12:39 <vincenz> > splitAt 5 [1,2,3]
09:12:41 <lambdabot>  ([1,2,3],[])
09:12:42 <Beelsebob> yeh
09:13:01 <vincenz> @uncurry \i l -> let (h, t) = splitAt i l in h ++ drop 1 t
09:13:01 <lambdabot> Unknown command, try @list
09:13:05 <vincenz> @pl \i l -> let (h, t) = splitAt i l in h ++ drop 1 t
09:13:05 <lambdabot> (line 1, column 13):
09:13:05 <lambdabot> unexpected "("
09:13:05 <lambdabot> expecting natural, identifier or "in"
09:13:25 <Beelsebob> although I think I'd give a recursive definition
09:13:33 <Beelsebob> to save traversing the first n items twice
09:13:35 <vincenz> reuse existing stuff
09:13:45 <vincenz> why does that not parse?
09:13:56 <chessguy> vincenz, @pl can't handle let, i think
09:13:59 <vincenz> doh
09:14:02 <Beelsebob> not sure -- should do
09:14:23 <vincenz> @pl \(h,t) -> h ++ drop 1 t
09:14:23 <lambdabot> uncurry ((. drop 1) . (++))
09:14:27 <Beelsebob> reuse yes... but efficient no
09:14:38 <Beelsebob> on the other hand... this function is inefficient by design
09:14:38 <Beelsebob> so who cares
09:14:59 <vincenz> @pl \i l -> uncurry ((. drop 1) . (++)) $ splitAt i l
09:14:59 <lambdabot> (uncurry ((. drop 1) . (++)) .) . splitAt
09:15:24 <Beelsebob> lovely
09:15:30 <vincenz> it can be made prettier
09:15:32 <Beelsebob> I think I'll have your first definition thanks :P
09:15:36 <vincenz>  (uncurry ((. drop 1) . (++)) .) . splitAt
09:15:52 <Beelsebob> that's not prettier
09:15:53 <Beelsebob> that's pointless
09:15:55 <vincenz> @type  (uncurry (++) . ((drop 1) &&& id) .) . splitAt
09:15:57 <Beelsebob> litterally
09:15:57 <lambdabot>     The operator `.' [infixr 9] of a section
09:15:57 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
09:16:08 <vincenz> @type  ((uncurry (++) . ((drop 1) &&& id)) .) . splitAt
09:16:10 <lambdabot>     Couldn't match expected type `[a]'
09:16:10 <lambdabot>            against inferred type `([a1], [a1])'
09:16:15 <vincenz> hmm I guess it's not &&&
09:16:22 <vincenz> @type (&&&)
09:16:24 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:16:38 <vincenz> @type  ((uncurry (++) . (first (drop 1)) .) . splitAt
09:16:40 <lambdabot> parse error (possibly incorrect indentation)
09:16:47 <vincenz> well, you get the idea :)
09:16:55 <ma807> hi, i am trying to create a function on modular arithmetic called modPow which gives (x mod y) ^ y mod n for any x y n qithout any immediate calculations exceeding maxint
09:16:58 <ma807> any help
09:17:09 <vincenz> @type  ((uncurry (++) . (first (drop 1))) .) . splitAt
09:17:10 <lambdabot> forall a. Int -> [a] -> [a]
09:17:30 <Beelsebob> vincenz: I'll still take your first one
09:17:35 <vincenz> :)
09:17:35 <Beelsebob> much more readable
09:17:35 <puusorsa> @type uncurry
09:17:37 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:17:41 <vincenz> or even better
09:17:46 <vincenz> if you remove some .s
09:18:07 <vincenz> @type  curry (uncurry (++) . first (drop 1))  . uncurry splitAt)
09:18:09 <lambdabot> parse error on input `)'
09:18:17 <vincenz> @type  curry (uncurry (++) . first (drop 1)  . uncurry splitAt)
09:18:19 <lambdabot> forall a. Int -> [a] -> [a]
09:19:14 <hpaste>  mauke pasted "modpow" at http://hpaste.org/3236
09:19:42 <vincenz> and obviously that should be second, not first *cough*
09:19:49 <ma807> thanx hpaste
09:20:38 <vincenz> mauke: 1 `mod` c == 1
09:20:58 <mauke> > 1 `mod` 1
09:21:01 <vincenz> not only that, you can do (b `mod` c)
09:21:03 <lambdabot>  0
09:21:04 <vincenz> iirc
09:21:31 <vincenz> exponentiation has a cycle of c-1 iirc
09:21:33 <mauke> > 1 `mod` (-1)
09:21:34 <lambdabot>  0
09:21:46 <vincenz> so make that b `mod` (c-1)
09:21:59 <mauke> hmm
09:22:00 <vincenz> or is it c...damn one-off-errors
09:22:14 <mauke> @check \c -> 1 `mod` c == 1
09:22:15 <lambdabot>  Add a type signature
09:22:23 <mauke> @check \c -> 1 `mod` (c::Integer) == 1
09:22:24 <lambdabot>  Falsifiable, after 0 tests: 1
09:22:38 <chessguy> so it seems to me that when i read code from people who are better at haskell than i, i see a lot more functions in 'where' blocks than in my code. i wonder why that is
09:22:40 <vincenz> @check \c -> c > 1 ==> 1 `mod` (c::Integer) == 1
09:22:41 <lambdabot>  OK, passed 500 tests.
09:22:53 <quicksilver> chessguy: it's just taste
09:22:56 <quicksilver> chessguy: I don't like them :)
09:23:00 * vincenz likes where
09:23:03 <quicksilver> chessguy: I prefer 'let' to 'where' 90% of the time
09:23:13 <vincenz> quicksilver: let obscures your top-exp
09:23:15 <quicksilver> chessguy: and I make new top-level definitions more often than I use let
09:23:15 <Beelsebob> hmm
09:23:19 <chessguy> i would think it would make sense to make the function global, just incase you want it elsewhere
09:23:20 <Beelsebob> I tend to prefer where rather than let
09:23:31 <quicksilver> yes, I'm in a minority for prefering let
09:23:33 <mauke> @check \c -> c < (-1) ==> 1 `mod` (c::Integer) == 1
09:23:34 <vincenz> the advanage of where over toplevel: you can use parameters :)
09:23:34 <lambdabot>  Falsifiable, after 0 tests: -2
09:23:38 <quicksilver> but, nonetheless I do :)
09:23:43 <chessguy> i'm not talking about where vs. let, i'm talking about where vs. top-level
09:23:49 <vincenz> chessguy: you don't have to haev so many parameters
09:23:57 <Beelsebob> chessguy: I only tend to use where when I really think that the function needs a free variable captured by an outer scope
09:23:59 <chessguy> true
09:24:04 <quicksilver> I like to float to top-level if there aren't capturing issue
09:24:08 <quicksilver> like Beelsebob says
09:24:17 <quicksilver> partly because I like to test the small functions independently
09:24:22 <kilimanjaro> yea, same here
09:24:28 <quicksilver> I don't really see top-level pollution as an issue since we have export lists
09:24:29 <chessguy> that's my thinking too
09:24:43 <vincenz> anywho, returning to modPow, if we stick to c > 1, then we can do (b `mod` (c-1))
09:25:02 <chessguy> sorry, didn't mean to sidetrack the discussion. just curious
09:25:27 <vincenz> though maybe that's only true if b and c are coprime...
09:25:29 <vincenz> erm
09:25:31 <vincenz> I mean a and c
09:26:22 * vincenz `ap` meeting :: AFK
09:26:38 <mauke> @check \a b c -> c > 1 ==> (a^b `mod` c) == (a^(b `mod` (c-1)) `mod` c) :: Integer->Integer->Integer->Bool
09:26:39 <lambdabot>  Couldn't match expected type `Integer
09:26:47 <chessguy> the meeting is of type AFK?
09:27:03 <ddarius> chessguy: No vincenz `ap` meeting :: AFK
09:27:05 <mauke> @check (\a b c -> c > 1 ==> (a^b `mod` c) == (a^(b `mod` (c-1)) `mod` c)) :: Integer->Integer->Integer->Bool
09:27:06 <lambdabot>  Couldn't match expected type `Bool'
09:27:13 <mauke> oh, right
09:27:32 <chessguy> hm. function application binds tighter than type annotation?
09:27:39 <mauke> @check \a b c -> c > 1 ==> (a^(b::Integer) `mod` c :: Integer) == (a^(b `mod` (c-1)) `mod` c)
09:27:41 <lambdabot>  Exception: Prelude.^: negative exponent
09:27:47 <quicksilver> chessguy: yes
09:27:54 <mauke> @check \a b c -> b > 0 && c > 1 ==> (a^(b::Integer) `mod` c :: Integer) == (a^(b `mod` (c-1)) `mod` c)
09:27:55 <lambdabot>  Falsifiable, after 1 tests: 2, 1, 2
09:27:58 <quicksilver> chessguy: type annotation is in a different syntactic class
09:28:08 <quicksilver> chessguy: it binds more weakly than any 'expression' builder
09:28:15 <chessguy> interesting
09:28:21 <quicksilver> chessguy: (application, abstraction, operators)
09:28:52 <quicksilver> :t \x -> x :: (Int->Int)
09:28:54 <lambdabot> (Int->Int) :: (Int -> Int) -> Int -> Int
09:28:58 <quicksilver> ah, I'm wrong
09:29:05 <quicksilver> it binds more strongly than abstraction
09:29:07 <quicksilver> that's odd :)
09:29:19 <quicksilver> but more weakly than the others
09:42:42 <ski> Turrican !
10:15:20 <luqui> hi
10:16:15 <byorgey> hi there luqui
10:16:52 <shapr> Good morning #haskell!
10:16:53 <shapr> @yow !
10:16:53 <lambdabot> This ASEXUAL PIG really BOILS my BLOOD ... He's so ... so ... URGENT!!
10:16:59 <shapr> It's that wonderful time of day ...
10:17:01 <shapr> it's time for ..
10:17:02 <shapr> CODE!
10:17:05 <byorgey> hey shapr!
10:17:06 <shapr> Haskell code of course..
10:17:09 <byorgey> "morning", eh?
10:17:17 <shapr> Ok, it's actually afternoon
10:17:19 <shapr> @localtime shapr
10:17:20 <lambdabot> Local time for shapr is Thu Oct 11 12:17:20 2007
10:17:25 <shapr> But just barely!
10:17:42 <shapr> Plus I spent my morning getting contacts so I can wear my antique shades!
10:17:43 <byorgey> ah, I didn't realize we were in different time zones!
10:17:45 <luqui> why does this take so much memory:  print $ filter (const False) $ sequence $ replicate 32 [0,1]
10:18:43 <mauke> whoa. you're iterating over all ints?
10:19:04 <luqui> mauke, sure
10:19:10 <luqui> it should take a long time
10:19:18 <luqui> but it shouldn't use much memory
10:19:21 <byorgey> luqui: are you using -O2?
10:19:25 <luqui> no
10:19:30 <luqui> just -O
10:19:51 <byorgey> does it still use a lot of memory if you use -O2?  my understanding is that -O doesn't really do much
10:19:55 <hpaste>  gwern pasted "setWMName is teh borked" at http://hpaste.org/3237
10:20:09 <luqui> byorgey, yes, it still does
10:20:39 <Baughn> luqui: Does it actually use much memory, or just produce a lot of garbage?
10:20:42 <luqui> but if I replace sequence with "sequencer", which is sequence in reverse order, then it's fine
10:21:08 <luqui> Baughn, I don't know how to tell.  top just keeps giving me higher and higher % mem usage
10:21:41 <Baughn> luqui: If it was just garbage, the heap wouldn't grow. I thought you might be using the ghc profiler.
10:21:51 <luqui> sequencer [] = return []; sequencer (x:xs) = do { ts <- sequencer xs; t <- x; return (t:ts) }
10:27:11 <luqui> holy crap, sequencer is nowhere near equivalent.. heh...
10:27:45 <luqui> oh no, it's pretty close, I'm just dumb
10:27:56 <byorgey> > let sequencer [] = return []; sequencer (x:xs) = do { ts <- sequencer xs; t <- x; return (t:ts) } in sequencer [[1,2], [3,4], [5,6]]
10:27:58 <lambdabot>  [[1,3,5],[2,3,5],[1,4,5],[2,4,5],[1,3,6],[2,3,6],[1,4,6],[2,4,6]]
10:28:23 <Saizan> > sequence [[1,2], [3,4], [5,6]]
10:28:25 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
10:28:37 <Cale> > let sequencer = sequence . reverse in sequencer [[1,2], [3,4], [5,6]]
10:28:39 <lambdabot>  [[5,3,1],[5,3,2],[5,4,1],[5,4,2],[6,3,1],[6,3,2],[6,4,1],[6,4,2]]
10:28:49 <Cale> not quite :)
10:28:57 <byorgey> map reverse . sequence . reverse
10:28:58 <Cale> > let sequencer = map reverse . sequence . reverse in sequencer [[1,2], [3,4], [5,6]]
10:28:59 <lambdabot>  [[1,3,5],[2,3,5],[1,4,5],[2,4,5],[1,3,6],[2,3,6],[1,4,6],[2,4,6]]
10:29:06 <Cale> yeah
10:30:16 <Saizan> so, it uses less memory because it can GC the tails earlier?
10:31:13 <Cale> I don't think that would use less memory
10:31:42 <Cale> I think the ordinary sequence would.
10:31:44 <luqui> it most certainly does
10:31:54 <Cale> Okay, why is that?
10:31:58 <luqui> see example above
10:32:02 <luqui> I have no idea why
10:32:10 <Cale> Oh, which monad? Just the list monad?
10:32:13 <luqui> yeah
10:32:16 <Cale> Ah, okay
10:32:46 <Cale> Yeah, it gets done with the heads of the lists more quickly.
10:33:12 <Cale> er, hmm
10:34:11 <Cale> How are you counting memory usage, btw?
10:35:27 <luqui> Cale, "top" :-)
10:36:27 <Baughn> luqui: GHC's profiler will be more accurate. IIRC it gives both peak usage and total allocation, not to mention it can tell you /what/ is responsible for the allocation
10:37:55 <luqui> Baughn, that's nice, but I kind of have a problem with my program going up to 80%
10:38:09 <luqui> tends to, um, slow things down
10:38:21 <Cale> luqui: so hit ctrl-c ?
10:38:26 <luqui> yes, I hit ctrl-c
10:38:33 <luqui> and the problem I'm solving prints no solutions
10:38:45 <luqui> but with sequencer, memory never exceeds 0.3 :-)
10:38:53 <luqui> so I think there's a big difference
10:39:27 <luqui> (and I am using map reverse . sequence . reverse, so that is the critical point)
10:40:44 <Baughn> luqui: Reverse would necessarily reduce the least to WHNF before yielding a single element. Just how long /is/ that list?
10:41:40 <Cale> luqui: that's odd.
10:41:51 <Cale> I'm seeing similar memory usage from both
10:42:04 <luqui> Baughn, it's about six elements long.  no big deal
10:42:24 <luqui> Cale, are you using my benchmark
10:42:27 <luqui> maybe we can figure this out
10:42:35 <Baughn> luqui: six elements? After the sequence?
10:42:44 <luqui> Baughn, yeah
10:42:59 <Baughn> luqui: Did you paste the complete on rafb.net?
10:43:14 <Cale> Er, are you sure you're using map reverse . sequence . reverse?
10:43:25 <luqui> I am for my actual program
10:43:32 <luqui> let me do it on my bench and see if it does the same thing
10:44:43 <luqui> yep.  pasting
10:44:47 <luqui> uh...
10:44:48 <luqui> ?paste
10:44:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:45:12 <Cale> I'm pretty sure that the reason sequencer is much more efficient is that elements of the output list share tails, which I don't think they will with map reverse . sequence . reverse
10:45:22 <hpaste>  (anonymous) pasted "sequence takes up tons of memory for some reason" at http://hpaste.org/3238
10:45:51 <Cale> Oh, you're not doing what I'm doing at all :)
10:46:04 <Cale> You're implementing sequence in terms of sequencer
10:46:29 <luqui> hmm?
10:46:50 <luqui> oh, i see
10:46:53 <luqui> you were going the other way..
10:47:07 <Cale> But yeah, that may still be more efficient.
10:47:22 <luqui> it's quite dramatic... i don't really get it
10:47:26 <Cale> Okay
10:47:34 <Cale> Consider the order in which we traverse the list
10:48:19 <Cale> With ordinary sequence, we pick an element of the first list, then build a sequence of the elements of the remaining lists
10:48:38 <hpaste>  (anonymous) pasted "number game" at http://hpaste.org/3239
10:49:17 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3240
10:50:00 <Cale> er, hmm
10:50:55 <Cale> Right, right
10:50:59 <Cale> v <- x
10:51:04 <Cale> vs <- sequence xs
10:51:08 <Cale> return (v:vs)
10:51:31 <mauke> each v gets its own set of tails?
10:51:52 <Cale> So we pick some v from x, then go through all the possible sequences of the tail, adding v to the beginning of each
10:52:05 <Cale> No, the tails all hang around.
10:52:16 <Cale> But they hang around a long time.
10:52:34 <luqui> ahh, because of the order in which sequence returns...
10:52:40 <luqui> they have to
10:52:50 <Cale> They are shared, but the length of time over which they're shared is much longer
10:53:14 <luqui> okay I see it
10:53:16 <Cale> You essentially have to hold on to them forever
10:53:43 <Cale> With the other order, the tails are actually used up.
10:53:55 <Cale> vs <- sequence xs
10:53:58 <Cale> v <- x
10:54:00 <luqui> because the head varies faster than the tail
10:54:01 <Cale> return (v:vs)
10:54:03 <Cale> right
10:54:34 <Cale> Once v runs through all possibilities, we move on to the next tail, and get to throw away the one we're finished with.
10:56:17 <Cale> Who is working on the number game?
10:58:45 <byorgey> Cale: the number game?
10:59:20 <Cale> byorgey: someone pasted on hpaste but didn't ask a question :)
11:00:04 <Cale> whoa, that's funky, they have a do-block on a line in another do-block :)
11:00:14 <Cale> <hpaste>  (anonymous) pasted "number game" at http://hpaste.org/3239
11:00:30 <Cale> byorgey: that was just before you joined actually ;)
11:00:42 <byorgey> ah, that would explain it =)
11:00:52 <byorgey> stupid server at my work always takes a lunch break.
11:01:13 <byorgey> without fail, the network goes down for about a half hour around 1:30 or so.
11:01:21 <luqui> the do block thing is just scoping, gotta make sure the if can't see that x! :-)
11:01:58 <Cale> hehe
11:02:08 <Cale> (it can't anyway, of course)
11:02:20 * luqui just realized that I never use if anymore...
11:02:33 <luqui> er, "he never uses", I guess
11:02:55 <hpaste>  Cale annotated "number game" with "saner indentation" at http://hpaste.org/3239#a1
11:03:16 <foo-nix> Would someone know how to fix http://pastebin.com/m36a5b389 in  http://pastebin.com/m2206d6d5 ?
11:04:02 <hpaste>  Cale annotated "number game" with "remove spurious do's, add let-binding for read n" at http://hpaste.org/3239#a2
11:04:20 <hpaste>  byorgey annotated "number game" with "remove unnecessary do's" at http://hpaste.org/3239#a3
11:04:44 <vwx> hello. how can i call a c function that takes a struct parameter?
11:05:32 <Cale> byorgey: beat you to it :)
11:05:49 <byorgey> yup, I'll have to be faster next time =)
11:05:51 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3241
11:06:14 <foo-nix> hpaste: Are you a bot?
11:06:14 <Cale> foo-nix: sure
11:06:27 <foo-nix> Cale: Ah, so he is a bot.
11:06:45 <Cale> yeah, also I'll help with your type error :)
11:07:01 <foo-nix> Cale: I would like to give the function as an argument.
11:07:08 <Cale> foo-nix: maximaBy :: (Ord b) => (a -> b) -> [a] -> [a]
11:07:19 <Cale> You're passing it stringScore
11:07:31 <Cale> Which has type String -> String -> Int
11:07:39 <foo-nix> yes, stringscore goes from a String to a ordening (namely integer)
11:07:42 <Cale> So that makes a = String, and b = String -> Int
11:07:45 <hpaste>  luqui annotated "(no title)" with "remove dummy variables... see, we can't help but mess with everything we see" at http://hpaste.org/3241#a1
11:08:08 <Cale> But there is no Ord instance of String -> Int
11:08:23 <foo-nix> Cale, I want b to be Int.
11:09:01 <Cale> foo-nix: Perhaps you intended to partially apply stringScore?
11:09:34 <foo-nix> Cale uhh? stringScore is a ->b, right?
11:09:34 <Cale> Or uncurry it?
11:09:39 * locomalo is away: Ausente
11:09:45 <Cale> Well, with a function type for b
11:09:57 <Cale> stringScore :: String -> (String -> Int)
11:10:01 <blarz> is there some site where I can have some small Haskell programming exercises to get into this wonderfull language practically?
11:10:35 <Cale> blarz: I think lots of people do the Project Euler problems
11:10:46 <EvilTerran> yeah, PE's pretty good for that
11:10:55 <foo-nix> Cale: I see now, shit, it has two Strin gs as an argument, how could I have been so stupid, indeed, I will curry it ;).
11:11:01 <Cale> uncurry :)
11:11:19 <EvilTerran> most of the first few problems are pretty trivial in haskell. arbitrary-length Integers are really helpful there :)
11:11:32 <foo-nix> Cale: I want this:     stringScore :: (String, String) -> Int
11:11:35 <foo-nix> ;)
11:11:48 <Cale> :t uncurry
11:11:50 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
11:12:26 --- mode: ChanServ set +o sjanssen
11:12:33 <Cale> blarz: If you do a search on google for "Haskell exercises", you'll get a million homework problems ;)
11:12:43 --- mode: sjanssen set -b *!*@88.232.*
11:12:50 <blarz> Cale: ok, thanks :)
11:13:00 <cizra> â™¡Haskellâ™¥
11:13:02 <foo-nix> Cale: Thank you, it works ;)
11:13:04 <blarz> perhaps there was THE site for this or something
11:13:06 <Cale> blarz: There were also some ruby exercises which we stole
11:13:07 <cizra> Mind-bending for sure, if not easy to use.
11:13:14 <blarz> Cale: yes I saw that *g*
11:13:20 --- mode: ChanServ set +b *!*@88.232.*
11:14:27 --- mode: sjanssen set -b *!*@88.232.*
11:14:33 <EvilTerran> ... spambot?
11:14:57 <Cale> http://haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
11:14:58 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
11:15:43 <vwx> how do i use the FFI foreign import to call a c function that takes a struct parameter?
11:15:52 <blarz> this Project Euler things sounds nice
11:15:58 <Cale> vwx: Make an instance of Storable for the structure
11:16:04 <EvilTerran> vwx, directly, or a pointer to it?
11:16:07 --- mode: ChanServ set +b *!*@88.232.*
11:16:14 <Cale> vwx: That is, for the Haskellized version of the structure
11:16:16 <vwx> EvilTerran: directly
11:16:31 <vwx> Cale: I tried that but it gave me a compile error about it being an unsupported type
11:16:46 <Cale> vwx: You tried writing an actual instance?
11:16:54 <EvilTerran> i suggest c2hs, which can generate the appropriate haskell+FFI based on the header file
11:17:28 <vwx> Cale: yes. i did instance Storable TheType where sizeOf = ...
11:17:30 <EvilTerran> if not to actually use, to run and get an idea how to do it manually
11:17:42 <vwx> i am using hsc2hs
11:17:45 <sjanssen> why is ChanServ re-setting a ban after I've removed it?
11:18:00 <glguy> sjanssen: because its in the autorem list
11:18:09 <sjanssen> glguy: how do I remove it?
11:18:09 <glguy> ?
11:18:19 <profmakx> Baughn
11:18:19 <glguy> chanserv help autorem
11:18:21 <profmakx> arx
11:18:22 <profmakx> srx
11:18:24 <EvilTerran> /msg chanserv help autorem
11:18:24 <glguy> I don't remember exactly
11:18:27 <cizra> I need some help. I'm a Haskell newbie. I need to find the smallest element of list of integers. I'm thinking about this approach: min (x:xs) = if x < min xs then return x else return the other one. How to write it down correctly? In an imperative language I'd create a variable, but here I don't know...
11:18:44 <glguy> :t minimum
11:18:47 <lambdabot> forall a. (Ord a) => [a] -> a
11:18:48 <vwx> i tried making a wrapper function inline the hsc file with: #def function wrapper(T*) { return f(*t); }   // but then i got an unresolved symbol for wrapper when linking
11:18:50 <Cale> cizra: You basically did write it down correctly.
11:18:51 <glguy> ?src minimum
11:18:51 <lambdabot> minimum [] = undefined
11:18:51 <lambdabot> minimum xs = foldl1 min xs
11:18:52 <EvilTerran> cizra, that's not what return means in haskell. get rid of the returns
11:19:02 <Cale> cizra: Minus some additional returns :)
11:19:10 <glguy> cizra: you won't be using "return" in this function
11:19:17 <Cale> right
11:19:37 <EvilTerran> > let f x y = if x < y then x else y in f 4 2 -- the 2-ary case
11:19:38 <cizra> But won't the function min xs be called twice?
11:19:38 <lambdabot>  2
11:19:41 <glguy> whoa, you got triple jumped for that return.. (just read up)
11:19:44 <Cale> You may also want to use let in order to only compute the min of the tail of the list once.
11:19:45 <glguy> I* just
11:19:54 --- mode: sjanssen set -b *!*@88.232.*
11:19:58 <vwx> Cale: are Storable types supposed to work?
11:20:00 <Cale> cizra: yes, the way you wrote it
11:20:12 <Cale> vwx: Let me look, it's been a while since I used the FFI
11:20:25 <EvilTerran> cizra, you could use the `min` function to assist
11:20:29 <EvilTerran> @type min
11:20:31 <lambdabot> forall a. (Ord a) => a -> a -> a
11:20:37 <EvilTerran> > 4 `min` 2
11:20:39 <lambdabot>  2
11:20:47 <cizra> Aha!
11:21:06 <byorgey> > min 4 2  -- same thing
11:21:07 <lambdabot>  2
11:21:20 <EvilTerran> vwx, iirc, the FFI only works for linking to dynamic libraries
11:21:25 --- mode: sjanssen set -o sjanssen
11:21:32 <EvilTerran> so building a .o to link in wouldn't work
11:21:54 <EvilTerran> @where c2hs
11:21:55 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
11:21:57 <vwx> EvilTerran: I'm actually linking with a .o in another project just fine
11:22:02 <EvilTerran> ^^ seriously, that's really good
11:22:08 <EvilTerran> i may be mistaken on that account
11:22:10 <luqui> ?src sort
11:22:10 <lambdabot> sort = sortBy compare
11:22:13 <luqui> ?src sortBy
11:22:14 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:22:28 <EvilTerran> ?src insertBy
11:22:28 <lambdabot> insertBy _   x [] = [x]
11:22:29 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
11:22:29 <lambdabot>                                  GT -> y : insertBy cmp x ys'
11:22:29 <lambdabot>                                  _  -> x : ys
11:22:44 <luqui> just wondering what kind of sort it did...
11:22:57 <EvilTerran> insertion sort, apparently
11:22:58 <luqui> I think insertion is my favorite, because it works well lazily
11:23:06 <luqui> (favorite for haskell, that is)
11:23:11 <EvilTerran> means head.sort is O(n) :D
11:23:14 <Cale> EvilTerran: hm
11:23:24 <EvilTerran> hm?
11:23:26 <cizra> Aha, now I see!
11:23:27 <Jedai> From I've seen, the sort in GHC6.6.1 was mergesort
11:23:40 <Cale> vwx: Ah, yeah, the types you can use are restricted. You can use any pointer type though.
11:23:43 <cizra> minList (x:xs) = let y = minList xs in if x < y then x else y -- here I create a scope for the variable y.
11:23:55 <cizra> But how does the scope end? With a newline?
11:23:56 <Cale> vwx: Then do additional marshalling once you get the pointer.
11:24:03 <Jedai> I wonder if it got changed or if ?src is mistaken someway
11:24:12 <Cale> EvilTerran: The FFI works with .o files
11:24:20 <vwx> Cale: unfortunately this means i must write a wrapper function in c :(
11:24:21 <luqui> cizra, end of the expression
11:24:22 <int-e> Jedai: head . sort is still O(n)
11:24:25 <EvilTerran> minList (x:xs) = if x < y then x else y where y = minList xs -- also works; some prefer where{} to let{}in
11:24:32 <cizra> luqui: What is an expression here?
11:24:34 <Cale> EvilTerran: In fact, you can call GHC with C files on the commandline and it will build and link them in for you :)
11:24:50 <cizra> EvilTerran: Yes, I know they're equivalent.
11:24:51 <EvilTerran> Cale, ah, yes, i remember now. never mind my confused rambling. ;)
11:24:54 <Jedai> int-e: Yes, but last . sort is O(n log n) and not O(n^2) ...
11:25:00 <luqui> cizra, uh... so if ... then ... else ... is one expression
11:25:03 <Cale> vwx: hmm...
11:25:03 <int-e> Jedai: right
11:25:14 <luqui> cizra, including everything in the ...
11:25:24 <cizra> luqui: Well, how do I end it then?
11:25:30 <luqui> cizra, it just... ends
11:25:32 <EvilTerran> > (if False then (1+) else (2*)) (if True then 3 else 4)
11:25:34 <lambdabot>  6
11:25:42 <cizra> luqui: S'pose I want to write stuff after that if. So that it won't get swallowed into the "else" clause.
11:25:57 <luqui> cizra, you would have to figure out *how* to write stuff after that if
11:26:00 <EvilTerran> cizra, don't think of if/then/else as a control structure, just as another kind of expression
11:26:03 <luqui> you can't unless you're in a do block
11:26:06 <Cale> http://www.haskell.org/haskellwiki/FFICookBook#Calling_C_functions
11:26:11 <lambdabot> Title: FFI cook book - HaskellWiki, http://tinyurl.com/32xoop
11:26:17 <cizra> Arh. I think imperative.
11:26:18 <EvilTerran> it's more like the ?: ternary operator from C than a conventional if
11:26:21 <cizra> Please bear with me.
11:26:34 <luqui> cizra, bearing is what we're here for
11:26:37 <luqui> :-)
11:26:48 <cizra> \o/
11:27:00 <cizra> Anyway, I feel smart when doing Haskell.
11:27:14 <cizra> I know I'm probably of the 1% that actually enjoys this subject of ours.
11:27:16 <EvilTerran> that's great! most newbies seem to feel lost
11:27:28 <cizra> No, I feel smart in comparison.
11:28:02 <cizra> Y'know, people do the minimum to get the subject done and then they go and write some PHP to wipe the last traces of Haskell outta their minds.
11:28:09 <Cale> heh
11:28:13 * byorgey cheers for cizra 
11:28:34 <cizra> \o/
11:28:35 <EvilTerran> and then get you to help them with their haskell homework?
11:28:46 <cizra> Oh, yes. Of course.
11:29:06 <vwx> Cale: yeah, i've read that page, but it's for passing pointers
11:29:27 <cizra> A strange girl, an aquaintance of mine tells me I'm a damned fool. "What have those blondes ever given back to you?"
11:29:39 <iesahin> another newbie here
11:30:01 <iesahin> in hudak's book, there is an exercise that says
11:30:08 <iesahin> fill f1 & f2 in
11:30:29 <iesahin> f1 (f2 (*) [1, 2, 3, 4]) 5
11:30:40 <iesahin> to give [5, 10, 15, 20]
11:30:59 <iesahin> f1 and f2 should be something of map or foldl
11:31:08 <iesahin> or foldr, i guess
11:31:14 <iesahin> f2 looks like map
11:31:20 <cizra> f2 should be map
11:31:25 <EvilTerran> map looks likely
11:31:31 <iesahin> but I couldn't find f1
11:31:34 <EvilTerran> > map (*)  [1, 2, 3, 4]
11:31:36 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
11:31:43 <cizra> f1 -- an almost empty function that returns just the first argument.
11:31:55 <Cale> cizra: not quite :)
11:32:01 <cizra> Mh?
11:32:02 <Cale> You have to do something with that 5 :)
11:32:06 <luqui> cizra, const?
11:32:23 <EvilTerran> okay, so you've got a list of functions on integers; [(1*),(2*),(3*),(4*)], and you want to apply each of those to the 5 in turn, right?
11:32:29 <cizra> > let f1 a b = a in f1 (map (*)  [1, 2, 3, 4]) 5
11:32:31 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
11:32:40 <iesahin> it must apply 5 to each element of [1 *, 2 *, 3*, 4 *]
11:33:00 <iesahin> map 5 (map * [1, 2, 3, 4])
11:33:03 <iesahin> does it, i think
11:33:05 <cizra> Oh! Now I see.
11:33:20 <cizra> > map 5 (map * [1, 2, 3, 4])
11:33:20 <Cale> map ($5) (map (*) [1,2,3,4])
11:33:21 <lambdabot>  Couldn't match expected type `(a -> b) -> [a] -> [b]'
11:33:30 <Cale> > map ($5) (map (*) [1,2,3,4])
11:33:31 <lambdabot>  [5,10,15,20]
11:33:34 <Cale> so...
11:33:35 <cizra> Why $?
11:33:36 <iesahin> EvilTerran: yes
11:33:40 <int-e> sequence!
11:33:40 <EvilTerran> so f1 [g,h,i,...] x = [g x, h x, i x, ...]
11:33:43 <Cale> ($) is function application
11:33:49 <EvilTerran> @src ($)
11:33:50 <lambdabot> f $ x = f x
11:33:57 <Cale> int-e: yeah, that's what I was thinking, but I think it's inappropriate in this context :)
11:33:59 <cizra> You mean the precedence-changing thing, equivalent with parens?
11:34:19 <int-e> @type map 5
11:34:20 <Cale> > (map . ($)) 5 (map (*) [1,2,3,4])
11:34:21 <lambdabot>   add an instance declaration for (Num ((a -> a) -> b))
11:34:21 <lambdabot> forall a b. (Num (a -> b)) => [a] -> [b]
11:34:24 <EvilTerran> yeah, kinda. it's just an infix op, though, so it's handy for sections as well
11:34:28 <cizra> Oh, by the way, can I treat strings as lists?
11:34:38 <EvilTerran> @src String
11:34:38 <lambdabot> type String = [Char]
11:34:42 <EvilTerran> yes :D
11:34:49 <cizra> cool
11:34:50 <int-e> map  takes a function as its first argument.  map 5  would need a number that is also a function ...
11:34:53 <Cale> > (map . flip ($)) 5 (map (*) [1,2,3,4])
11:34:55 <lambdabot>  [5,10,15,20]
11:35:02 <Cale> > flip (map . flip ($)) (map (*) [1,2,3,4]) 5
11:35:03 <lambdabot>  [5,10,15,20]
11:35:16 <Cale> Well, there's a slightly cheesy answer :)
11:35:46 <iesahin> Cale: but book doesn't mention flip here
11:35:57 <Cale> You can write it explicitly as a lambda
11:36:05 <Cale> (\xs x -> ...)
11:36:08 <int-e> > (*) <$> [1,2,3,4] <*> [5] -- more cheese
11:36:10 <lambdabot>  [5,10,15,20]
11:36:14 <int-e> (sorry)
11:36:23 <Cale> > sequence (map (*) [1,2,3,4]) 5
11:36:24 <lambdabot>  [5,10,15,20]
11:36:28 <EvilTerran> it's dangerously cheesy!
11:36:49 <luqui> :t <$>
11:36:51 <lambdabot> parse error on input `<$>'
11:37:02 <luqui> :t (<$>)
11:37:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:37:05 <Cale> See, but then you want to know what sequence is, and then I have to start talking about the ((->) e) monad :)
11:37:10 <EvilTerran> hey, so sequence in reader's like an n-ary fanout operation? that's damn cool
11:37:15 <cizra> > let remSpaces (x:xs) = if x == " " then remSpaces xs else x ++ xs in remSpaces "  foo"
11:37:16 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
11:37:17 <iesahin> Cale: then f1 is sequence :)
11:37:20 <EvilTerran> makes perfect sense, too, i guess
11:37:21 <cizra> Why doesn't it work?
11:37:28 <Cale> iesahin: the equivalent of it, anyway
11:37:29 <EvilTerran> ?type " "
11:37:30 <lambdabot> [Char]
11:37:31 <EvilTerran> ?type ' '
11:37:33 <lambdabot> Char
11:37:35 <cizra> \o/
11:37:37 <int-e> applicative is cool :)
11:37:37 <Cale> iesahin: but you should probably write it in terms of map
11:37:38 <foo-nix> Would someone know what a "Non-exhaustive patterns in function stringScore" is?
11:37:50 <Heffalump> it means stringScore uses pattern matching, but doesn't cover all possible patterns
11:37:57 <int-e> > (map (*) [1,2,3,4]) <*> [5] -- works too.
11:37:59 <lambdabot>  [5,10,15,20]
11:38:05 <Cale> iesahin: sequence is a generic monad function which I'm applying in the case of the monad of functions from a particular type
11:38:07 <foo-nix> Heffalump: ah, thanks.
11:38:12 <cizra> Uh.. Now ++ doesn't work. How do I concatenate a char into a list?
11:38:22 <EvilTerran> cizra, which end?
11:38:22 <Heffalump> Or that you have covered them all, but only with guards and GHC can't be certain if that's ok, or that GHC has a bug in its coverage checker, which occasionally happens.
11:38:26 <int-e> cizra: is the list a string?
11:38:28 <Cale> cizra: (++) is for concatenating two lists
11:38:31 <Olathe> > ['t', 'e', 's'] ++ ['t']
11:38:33 <lambdabot>  "test"
11:38:39 <cizra> EvilTerran: first
11:38:42 <int-e> > 't' : 'e' : "st"
11:38:43 <lambdabot>  "test"
11:38:48 <iesahin> Cale: Yeah, I got it ;)
11:38:49 <Cale> cizra: x : xs will add a single element x to the start of xs
11:38:54 <Olathe> @pl \a b -> a ++ [b]
11:38:54 <lambdabot> (. return) . (++)
11:38:57 <cizra> *doh*
11:39:20 <EvilTerran> cizra, er, what Cale said. also, we don't add single elements onto the end of lists 'round 'ere ;)
11:39:23 <luqui> is the (->) t monad not defined by default?
11:39:40 <Cale> luqui: It's in Control.Monad.Instances
11:39:40 <cizra> EvilTerran: This must be some inside joke I'm missing.
11:39:42 <EvilTerran> luqui, i think it's in Control.Monad.Reader and Control.Monad.Instances
11:39:47 <luqui> ok
11:39:51 <Cale> luqui: But it *ought* to be in the Prelude :)
11:39:53 <foo-nix> Heffalump: I found the bug, But I think it means ghc calls the function without finding a pattern to apply.
11:40:10 <Cale> cizra: It's actually an efficiency tip
11:40:11 <EvilTerran> cizra, no, but you can only do it as (snoc xs x = xs ++ [x]), and...
11:40:13 <EvilTerran> @src (++)
11:40:13 <lambdabot> (++) []     ys = ys
11:40:13 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
11:40:25 <Heffalump> foo-nix: you get that error at runtime?
11:40:28 <EvilTerran> xs ++ ys takes O(length xs)
11:40:31 <Heffalump> if so, yes, it does. What else would it do?
11:40:33 <foo-nix> Heffalump: yes
11:40:38 <EvilTerran> so we don't do it
11:40:41 <Cale> cizra: It takes O(n) time and a complete reconstruction of the list, to do xs ++ [x]
11:40:46 <Heffalump> you've written an incomplete function
11:40:51 <Heffalump> and then asked to call it
11:40:54 <foo-nix> Heffalump: Thenks for your help, I learned something today :).
11:40:56 <cizra> Oof. OK
11:41:01 <Cale> cizra: on the other hand (x:xs) is constant space and time
11:41:03 <cizra> remSpaces (x:xs) = if x == ' ' then remSpaces xs else x:xs
11:41:03 <EvilTerran> instead, it's best to try to structure algorithms to only work on the head of the list
11:41:14 <EvilTerran> or to use Data.Sequence
11:41:18 <EvilTerran> @docs Data.Sequence
11:41:18 <lambdabot> Data.Sequence not available
11:41:22 <EvilTerran> ...
11:41:30 <Mr_Awesome> Data.Sequence is excellent
11:41:30 <cizra> This works well for spaces. And as you say, is efficient too. How do I make it accept any whitespace? I can think of two ways:
11:41:44 <cizra> boolean logic, x == ' ' or x == '\n'
11:41:44 <EvilTerran> @index isSpace
11:41:44 <lambdabot> Data.Char
11:41:49 <EvilTerran> @src isSpace
11:41:49 <lambdabot> Source not found. Wrong!  You cheating scum!
11:42:02 <Olathe> > isSpace '\t'
11:42:04 <lambdabot>  True
11:42:05 <cizra> or, alternatively, make a list of whitespace chars and make the function search through it.
11:42:10 <EvilTerran> alternatively, (`elem` " \t\r\n\v") or something
11:42:41 <EvilTerran> but isSpace should be locale-dependent, so might work for unicode whitespace characters as well (if there are such a thing, and you're very lucky)
11:42:44 <Cale> cizra: || is the or operator, or else you can use elem
11:42:55 <EvilTerran> the locale thing's more important for such things as isAlpha
11:42:58 <EvilTerran> @docs Data.Char
11:42:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
11:43:09 <cizra> *nod* I think I'll try to figure out how to include that isSpace.
11:43:23 <Cale> cizra: Note that || is just an ordinary Prelude function which you could write yourself too :)
11:43:23 <cizra> import Data.Char does the magic.
11:43:28 <EvilTerran> @src (||)
11:43:28 <lambdabot> True  || _ =  True
11:43:28 <lambdabot> False || x =  x
11:43:42 <cizra> _ means anything, right?
11:43:46 <Cale> right
11:44:09 <Mr_Awesome> so does x in this case
11:44:10 <EvilTerran> "or" also exists, but it's the n-ary equivalent
11:44:13 <Cale> You can't normally write (||) properly in a strict language, because it would always compute both its parameters.
11:44:15 <Mr_Awesome> but x actually binds something
11:44:23 <EvilTerran> or = foldr (||) False
11:44:46 <Cale> So just about every strict language in existence defines || as a primitive.
11:45:11 <luqui> @src putStr
11:45:12 <lambdabot> putStr s  = hPutStr stdout s
11:45:18 <luqui> @src hPutStr
11:45:18 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:45:25 <luqui> had to try ;-)
11:45:33 <EvilTerran> heck, we don't even define *Bool* as a primative
11:45:36 <EvilTerran> @src Bool
11:45:36 <cizra> lastElem (x:xs) = if xs == [] then x else lastElem xs
11:45:36 <lambdabot> data Bool = False | True deriving (Eq, Ord)
11:45:40 <cizra> Why doesn't it work?
11:46:04 <Cale> cizra: Don't test for the empty list using ==
11:46:05 <EvilTerran> > let lastElem (x:xs) = if xs == [] then x else lastElem xs in lastElem "fnord"
11:46:07 <lambdabot>  'd'
11:46:12 <EvilTerran> it does work :)
11:46:16 <Cale> It does work, but it has a silly type
11:46:18 <hpaste>  int-e pasted "unremovable "Pattern match(es) are non-exhaustive" warning with GADTs" at http://hpaste.org/3242
11:46:18 <luqui> Cale, why not?
11:46:24 <Olathe> (||) True = const True; (||) False = id
11:46:26 <cizra> lastElem :: [a] -> a
11:46:28 <luqui> oh, vecause there's no (Eq a)
11:46:30 <Cale> Because you'll get an Eq constraint
11:46:31 <EvilTerran> luqui, it imposes an Eq constraint
11:46:34 <cizra> I have this thing just above it, so maybe this matters.
11:46:48 <int-e> Is that a known problem with GADTs?
11:47:08 <cizra> What the bleep is an Eq constraint? We were told about Eq today, this is a class of types that can be compared with ==.
11:47:16 <EvilTerran> @src (==)
11:47:17 <lambdabot> x == y = not (x /= y)
11:47:21 <EvilTerran> @type (==)
11:47:23 <lambdabot> forall a. (Eq a) => a -> a -> Bool
11:47:28 <Cale> cizra: Right, so, what if the type of your list isn't in Eq?
11:47:33 <EvilTerran> "(Eq a) => " is an Eq constraint
11:47:49 <sjanssen> int-e: yes, I doubt the overlap checker knows about GADTs
11:47:50 <EvilTerran> specifically, an Eq constraint on a in the following type expression
11:47:54 <Cale> :t let lastElem (x:xs) = if xs == [] then x else lastElem xs in lastElem
11:47:56 <lambdabot> forall t. (Eq [t]) => [t] -> t
11:47:58 <cizra> Hmmhmm. But I want to compare lists, not list contents. However, list comparing is defined through content comparing.
11:48:01 <cizra> What should I do?
11:48:07 <sjanssen> int-e: use f _ = False?
11:48:08 <EvilTerran> pattern matching
11:48:12 <Cale> cizra: use pattern matching or the function null
11:48:17 <luqui> int-e, that error makes sense to me
11:48:18 <Cale> :t null
11:48:18 <EvilTerran> @src null
11:48:18 <lambdabot> null []     = True
11:48:18 <lambdabot> null (_:_)  = False
11:48:20 <lambdabot> forall a. [a] -> Bool
11:48:36 <EvilTerran> you can do null's pattern-match yourself, or use null
11:48:43 <cizra> I think I'll go with pattern matching.
11:48:53 <EvilTerran> what'd you write, then?
11:48:58 <luqui> @src (/=)
11:48:58 <lambdabot> x /= y = not (x == y)
11:49:05 <cizra> oh, wait, no
11:49:10 <Mr_Awesome> why not null _ = False for the second clause?
11:49:33 <int-e> ah. http://hackage.haskell.org/trac/ghc/ticket/366 covers this.
11:49:36 <lambdabot> Title: #366 (incomplete patterns and GADT) - GHC - Trac
11:49:38 <EvilTerran> lastElem [x] = x; cizra?
11:49:44 <cizra> \o/ works
11:49:52 <cizra> EvilTerran: Yes, figured it out before you typed it (=
11:49:53 <Cale> Mr_Awesome: Just because it's aesthetically nicer not to overlap patterns
11:50:08 <Mr_Awesome> i see
11:50:10 <EvilTerran> remembering, of course, that [x] is shorthand for (x:[])
11:50:43 <int-e> luqui: yes, the error is good. the problem is just that the warning becomes less useful. it's not a big deal.
11:51:06 * EvilTerran wanders off
11:51:15 * glguy follows EvilTerran 
11:51:23 <Olathe> > let null = (== []) in [null [], null [1, 2, 3]]
11:51:25 <lambdabot>  [True,False]
11:51:25 <vincenz> fat [] = False
11:51:29 <vincenz> fat (_:_) = True
11:51:32 <vincenz> null = not . fat
11:51:35 <int-e> sjanssen: nice trick. although I wanted to abuse ghc with GADTs as a theorem prover and a catch-all case like that would defeat the purpose :)
11:51:41 <EvilTerran> > let null = (== []) in [null [], null [id, id, id]]
11:51:41 <lambdabot>   add an instance declaration for (Eq (a -> a))
11:51:41 <lambdabot>     In the expression: (== []...
11:51:52 <Olathe> Lies.
11:52:06 <EvilTerran> and *that*'s why it uses pattern-matching
11:52:18 <int-e> sjanssen: (of course it's not the right tool for the job. Coq works better.)
11:52:21 * EvilTerran hopes his doubling-back has successfully thrown off glguy, and leaves properly this time
11:52:28 <Olathe> Bad == !
11:54:18 <ico> Hi. What is the convention for some functions in Prelude ending with an underscore ?
11:54:26 <ico> the name of the functions, that is
11:55:03 <sjanssen> ico: monadic functions which throw away the result
11:55:25 <sjanssen> @type sequence -- run a list of monadic actions, yielding a list of their results
11:55:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:55:39 <sjanssen> @type sequence_ -- run the actions, throw away the results
11:55:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
11:56:04 <ico> I see. What is the primary documentation for these kind of things ?
11:56:14 <sjanssen> @docs Prelue
11:56:15 <lambdabot> Prelue not available
11:56:16 <Cale> ico: The library documentation
11:56:16 <sjanssen> @docs Prelude
11:56:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
11:56:29 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
11:56:37 <Cale> http://haskell.org/onlinereport/standard-prelude.html
11:56:38 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
11:56:53 <ico> Yes, I found that, but I believe it doesn state things like 'functions ending with an underscore are monads throwing away the results'
11:57:04 <Cale> ico: No, those are unwritten conventions
11:57:05 <ico> (the prelude docs, I found, not the h98 report)
11:57:12 <ico> yes, so that's why I asked :)
11:57:22 <ico> glad #haskell is here :)
11:57:24 <Cale> They're not even followed rigourously.
11:57:52 <ico> ok, thanks, things start making a bit more sense now.
11:58:01 <Cale> Adding a prime (') to the end of the name of a function is often used for a stricter variant, but in general it just means some variant or perhaps a helper.
11:58:43 <Cale> Something related to, but not the same as, the original one :)
11:58:57 <ico> isn't there a generic FAQ somewhere that tells about these things ?
11:58:59 <byorgey> and adding M to the end of a function name usually indicates some sort of monadic generalization/counterpart to the original function.
11:59:04 <ico> especially conventions and such
11:59:07 <byorgey> i.e. map vs. mapM
11:59:29 <ico> Yes, those made sense already
11:59:29 <Cale> I think you're just expected to pick this up by osmosis :)
11:59:46 <ico> Oh, I do, and it's not a problem
11:59:50 <byorgey> ...although creating a wiki page isn't a bad idea =)
12:00:04 <ico> but if it weren't for things like IRC, it would be hard to get over the first few walls when starting
12:00:32 <ico> byorgey: we could start a FAQ, I ask the stupid questions, you answer them :)
12:00:37 <Cale> The naming conventions typically reflect the fact that lots of people have contributed to the libraries ;)
12:01:17 * Cale glowers at whoever picked out the names for Data.Graph.Inductive ;)
12:01:23 <byorgey> ico: technically, that would be a SAQ. but your questions aren't stupid =)
12:01:52 <ico> hehe
12:02:19 <byorgey> although a page of Stupidly Asked Questions would be amusing.
12:02:53 <byorgey> "Uh, you said 'Pascal', right?"
12:02:59 <Cale> Functions named  with*  typically take a function as a parameter which they pass something they manage the allocation of.
12:03:51 <byorgey> functions named unsafe* typically do things like launch missiles.
12:04:02 <Cale> and break the type system :)
12:04:36 <ico> But seriously, a wiki page with these kind of things might be helpful to others as well.
12:04:47 <ico> both for library users and writers
12:04:49 <ico> i guess
12:04:50 <Cale> The best thing to do is to pretend that functions starting with "unsafe" don't exist.
12:05:07 <mauke> invisibleBike
12:05:17 * byorgey just used unsafePerformIO legitimately for the first time today!
12:05:34 <byorgey> uh, I mean, of course I didn't, since it doesn't exist
12:05:46 <Cale> byorgey: What language primitive are you adding?
12:05:58 <byorgey> Cale: OEIS lookup =)
12:06:04 <Cale> ah, haha!
12:06:13 <Heffalump> it does exist, in the FFI spec
12:06:44 <Cale> Heffalump: Yeah, all the FFI stuff is best considered not to exist under ordinary circumstances :)
12:07:13 <Heffalump> it's an approved addendum :-p
12:07:25 <Cale> With a particular purpose.
12:07:47 <Heffalump> well, yes. But it does exist.
12:07:56 <Cale> That purpose is to allow people to write bindings to low-level libraries.
12:08:01 <mauke> flip withCString (mkFun . castPtrToFunPtr) "\232\14\0\0\0Hello, world!\n\186\14\0\0\0\89\187\1\0\0\0\184\4\0\0\0\205\128\49\192\195"
12:08:05 <byorgey> Heffalump, shh!  some newbies writing missile-control software might hear you!
12:08:11 <Cale> Unless you're doing that, you should pretend that it doesn't exist :)
12:08:35 <byorgey> mauke, my eyes!
12:08:55 <Cale> unsafePerformIO is essentially a way to add features to Haskell without recompiling GHC.
12:09:09 <Cale> But as such, you shouldn't take it lightly :)
12:10:34 <cizra> isOrderedBy :: (a -> a -> Bool) -> [a] -> Bool
12:10:36 <cizra> isOrderedBy func [] = True
12:10:41 <cizra> isOrderedBy (>) []
12:10:44 <cizra> Why doesn't it work?
12:11:06 <Heffalump> Cale: Hah. GHC doesn't exist.
12:11:18 <cizra> Ambiguous type variable ' in the constraint: `Ord a' arising from use of `>'
12:11:53 <Cale> cizra: You can't pattern match against functions
12:12:02 <Cale> cizra: (<) isn't a constructor
12:12:10 <int-e> heh you rebind the (>) symbol
12:12:12 <cizra> I don't want to. I want to pattern match against the second thing, the list.
12:12:20 <int-e> > let f (>) = 1 > 2 in f (<)
12:12:22 <lambdabot>  True
12:12:23 <Cale> okay
12:12:35 <Cale> oh, I see what you wrote now
12:13:18 <Cale> > let { isOrderedBy :: (a -> a -> Bool) -> [a] -> Bool; isOrderedBy func [] = True } in isOrderedBy (>) []
12:13:20 <lambdabot>  True
12:13:33 <Cale> That definition appears to work so far :)
12:14:40 <cizra> Meh? It doesn't work on this continent.
12:14:42 <Cale> > let { isOrderedBy :: (a -> a -> Bool) -> [a] -> Bool; isOrderedBy (<) [] = True; isOrderedBy (<) [x] = True; isOrderedBy (<) (x:y:xs) = x < y && isOrderedBy (<) (y:xs) } in isOrderedBy (>) [5,2,1,3,1]
12:14:44 <lambdabot>  False
12:14:49 <Cale> > let { isOrderedBy :: (a -> a -> Bool) -> [a] -> Bool; isOrderedBy (<) [] = True; isOrderedBy (<) [x] = True; isOrderedBy (<) (x:y:xs) = x < y && isOrderedBy (<) (y:xs) } in isOrderedBy (>) [5,2,1,0]
12:14:50 <lambdabot>  True
12:15:52 <Cale> > let { isOrderedBy :: (a -> a -> Bool) -> [a] -> Bool; isOrderedBy (<) [] = True; isOrderedBy (<) [x] = True; isOrderedBy (<) (x:y:xs) = x < y && isOrderedBy (<) (y:xs) } in isOrderedBy (<) [1,2,3,4,5]
12:15:53 <lambdabot>  True
12:15:57 <Cale> > let { isOrderedBy :: (a -> a -> Bool) -> [a] -> Bool; isOrderedBy (<) [] = True; isOrderedBy (<) [x] = True; isOrderedBy (<) (x:y:xs) = x < y && isOrderedBy (<) (y:xs) } in isOrderedBy (<) [1,2,3,3,4,5]
12:15:59 <lambdabot>  False
12:16:13 <cizra> Cale: Are you trying to show me something?
12:16:28 <Cale> cizra: Well, that seems to work :)
12:16:37 <cizra> Not for me.
12:16:40 <cizra> isOrderedBy func [] = True
12:16:47 <cizra> This thing complains.
12:17:01 <Cale> Where are you typing that?
12:17:14 <Cale> and is there a type signature, or any other lines in the file?
12:17:17 <cizra> yes
12:17:20 <cizra> isOrderedBy :: (a -> a -> Bool) -> [a] -> Bool
12:17:33 <cizra> It's a separate file, later run by runhaskell.
12:17:41 <Cale> that's a valid type signature for it
12:17:51 <Cale> Do you define a main?
12:17:57 <cizra> yes
12:18:03 <Cale> okay, let's look at main :)
12:18:04 <cizra> main = print (isOrderedBy (>) [] )
12:18:20 <mauke> ...
12:18:43 <Cale> oh, I see
12:18:46 <cizra> I don't
12:18:54 <Cale> It doesn't know which instance of Ord to use for (>)
12:19:09 <Cale> even though it's never actually going to apply (>)
12:19:36 <int-e> try  isOrderedBy (>) ([] :: [Int])
12:19:41 <mauke> :t (and .) . flip ap tail . zipWith
12:19:43 <lambdabot> forall b. (b -> b -> Bool) -> [b] -> Bool
12:19:47 <Cale> yes, I was about to suggest that :)
12:19:58 <mauke> try isOrderedBy (>) "" :-)
12:20:27 <cizra> Ooh, works
12:20:52 <byorgey> @type ap
12:20:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:21:16 <mauke> @unpl (and .) . flip ap tail . zipWith
12:21:16 <lambdabot> (\ g s -> and (((zipWith g) >>= \ l -> tail >>= \ k -> return (l k)) s))
12:21:33 <cizra> Oof. My brain just ran out of blood sugar. Good night.
12:21:43 <byorgey> night, cizra
12:25:05 <Cale> Haha, my reddit new-all page is doing quite nicely at the moment: 76,97,118,133,151,154,197,208,264,284,297,299,305,324,328,329,335,344,360,375
12:26:13 <Olathe> What are all those numbers ?
12:27:21 <Cale> The indices of the not-modded-down articles :)
12:28:37 <luqui> I have a function which returns a list of things that I'm computing... but I can't tell how long each element of the list is going to take to compute (some might take forever)
12:29:03 <luqui> I want to make an interface that prints solutions as they are found, but allows the user to interrupt and redirect the calculation
12:29:07 <luqui> any ideas?
12:29:20 <Olathe> > let a ||| b = 1%(1%a + 1%b) in ((((1 ||| 1) + 1) ||| ((1 ||| ((1 ||| 1) + 3)) + 4)) + 2)
12:29:27 <lambdabot>   add an instance declaration for (Integral (Ratio t))
12:29:31 <Olathe> :|
12:29:31 <Cale> threads with a channel that they dump the solutions to when they're finished?
12:29:41 <Olathe> What is the way to get that working ?
12:29:59 <luqui> Cale, so I need to rework my current list-returning function?
12:30:06 <byorgey> Olathe: use 1/(1%a + 1%b)
12:30:11 <Cale> luqui: no, not necessarily
12:30:12 <mauke> > let a ||| b = 1/(1/a + 1/b) in ((((1 ||| 1) + 1) ||| ((1 ||| ((1 ||| 1) + 3)) + 4)) + 2)
12:30:14 <lambdabot>  3.1415929203539825
12:30:18 <mauke> > let a ||| b = 1/(1/a + 1/b) in ((((1 ||| 1) + 1) ||| ((1 ||| ((1 ||| 1) + 3)) + 4)) + 2) :: Rational
12:30:19 <Olathe> Ah, thanks :)
12:30:19 <lambdabot>  355%113
12:30:35 <Cale> luqui: You just need a generic function which takes a list and spawns threads which evaluate each of the elements
12:30:38 <byorgey> Olathe: % is a constructor that makes a Ratio out of two things, not a function for doing division.
12:30:42 <Olathe> Ahh.
12:31:07 <luqui> hmm.. infinitely many elements...
12:31:09 <luqui> :-)
12:31:15 <luqui> but ok, I think i see a solution
12:31:20 <Cale> luqui: It's important though that they write into a Chan -- you can't get the behaviour you want with par because it's semantically deterministic.
12:31:43 <Cale> Oh, well, you'll want to bound the number of unfinished threads then
12:32:12 <Japsu> @index (%)
12:32:12 <lambdabot> Data.Ratio
12:32:14 <Japsu> k
12:33:11 <Cale> (you can still use your infinite list, it's just you'll have an infinite loop which occasionally blocks to wait for more solutions to come back)
12:33:33 <Cale> You'll want Control.Exception.evaluate
12:33:42 <Cale> (Kind of silly that it's in Control.Exception)
12:34:18 <Cale> In order to ensure that the evaluation is actually done in the thread. :)
12:35:32 <vincenz> ooh, a kiwi
12:35:47 <vincenz> KatieHuber: are there kiwi birds in NZ?
12:36:03 <KatieHuber> yup
12:36:13 <vincenz> They're so cute
12:36:22 <KatieHuber> where can you see kiwis? only in nz!
12:36:31 <KatieHuber> where can you see keas? only in nz!
12:36:32 <vincenz> how big are they?
12:36:38 <KatieHuber> come to nz, we've got kiwis and keas!
12:36:51 <vincenz> keas?
12:36:53 <KatieHuber> chicken-sized
12:37:01 <vincenz> I've seen only a picture, but they look cute :)
12:37:04 <KatieHuber> (from very small chicken to rather large chicken)
12:37:28 <KatieHuber> http://en.wikipedia.org/wiki/Kea
12:37:30 <lambdabot> Title: Kea - Wikipedia, the free encyclopedia
12:37:42 <vincenz> looks like a parrot
12:38:36 <KatieHuber> it's an unusual parrot
12:38:50 <vincenz> it doesn't talk?
12:38:51 <sieni> my favourite bird: http://www.youtube.com/watch?v=VjE0Kdfos4Y
12:38:52 <lambdabot> Title: YouTube - Attenborough - Lyre Bird
12:39:07 <KatieHuber> these days, its natural habitat is ski-field carparks, where it pulls rubber off windscreen wipers, deflates tires, and generally makes a cute pest of itself
12:39:21 <vincenz> the kea?
12:39:23 <vincenz> or the kiwi?
12:39:47 * vincenz curses at youtube buffering
12:39:53 <vincenz> the image ain't changin
12:39:55 <vincenz> all I hear is sound
12:40:07 <KatieHuber> kea
12:40:18 <vincenz> is it true kiwis and ozzies don't get along?
12:40:36 * vincenz assumes that KatieHuber has proper typechecking as 'kiwi' is a type-class method
12:42:00 <KatieHuber> we're like siblings... at each others throats most of the time, but we stick together if anyone else threatens us ;)
12:42:14 <vincenz> how was nz born?
12:42:30 <KatieHuber> in what sense?
12:42:41 <byorgey> well, there were these volcanos, see...
12:42:44 <vincenz> well au was originally a colony for prisoners
12:42:50 <KatieHuber> geologically, it split from gondwanaland long before even madagascar
12:42:52 <vincenz> I mean the nation
12:42:55 <vincenz> not the geography
12:44:09 <vincenz> aha, the dutch
12:45:00 <KatieHuber> maori people sailed in from the pacific about a thousand years ago, killed the moriori who were already here... then in the late 1800s whalers and sealers came.  then in 1840 the brits signed the treaty of waitangi with some maori chiefs, which put NZ under british rule, and things've been a bit hostile since
12:45:33 <KatieHuber> it was never a penal colony or anything like that
12:46:47 <Cale> sieni: Yeah, the Lyre bird is awesome :)
12:50:00 <blarz> I have a list1 [0,1,0] and a list2 [1,2,3]. How can I get a new list with list2 entrys that are null in the index of [0,1,0]. (in this case [1,3])
12:50:09 <blarz> (did I make myself clear? :D)
12:51:51 <kaol> > map snd $ filter ((==0) . fst) $ zip [0,1,0] [1,2,3]
12:51:52 <lambdabot>  [1,3]
12:52:06 <omnId> > concat $ zipWith ($) (map (\x -> if x == 0 then (:[]) else const []) [0,1,0]) [1,2,3]
12:52:07 <lambdabot>  [1,3]
12:52:14 <Olathe> @pl \list1 list2 -> map snd (filter (\a -> fst a /= 0) (zip list1 list2))
12:52:14 <lambdabot> ((map snd . filter ((0 /=) . fst)) .) . zip
12:52:15 <mauke> > [ y | (x, y) <- zip [0,1,0] [1,2,3], x == 0 ]
12:52:16 <lambdabot>  [1,3]
12:52:32 <Olathe> > (((map snd . filter ((0 /=) . fst)) .) . zip) [0, 1, 0] [1, 2, 3]
12:52:33 <lambdabot>  [2]
12:52:36 <Olathe> Heh
12:52:40 <blarz> ok *g*
12:52:40 <Olathe> > (((map snd . filter ((0 ==) . fst)) .) . zip) [0, 1, 0] [1, 2, 3]
12:52:42 <lambdabot>  [1,3]
12:52:50 <roconnor> > [ y | (x, y) <- zip [Flase,True,False] [1,2,3], x ]
12:52:50 <lambdabot>   Not in scope: data constructor `Flase'
12:52:56 <roconnor> > [ y | (x, y) <- zip [False,True,False] [1,2,3], x ]
12:52:57 <lambdabot>  [2]
12:53:06 * roconnor suspects using 0 and 1 is a bad idea
12:53:10 * shapr agrees
12:53:38 <mauke> > [ y | (x, y) <- zip [False,True,False] [1,2,3], not x ]
12:53:40 <lambdabot>  [1,3]
12:53:48 <shapr> My solution uses an ugly case statement.
12:53:48 <Olathe> @pl \list1 list2 -> map snd (filter fst (zip list1 list2))
12:53:49 <lambdabot> ((map snd . filter fst) .) . zip
12:54:07 <Olathe> > (((map snd . filter fst) .) . zip) [True,False,True] [1,2,3]
12:54:09 <lambdabot>  [1,3]
12:54:23 <omnId> > concat $ zipWith (\t x -> if t == 0 then [x] else []) [0,1,0] [1,2,3]
12:54:24 <lambdabot>  [1,3]
12:56:04 <monochrom> Boole was the culprit for 0 and 1.
12:56:04 <vincenz> roconnor: ping
12:56:09 <roconnor> vincenz: ack
12:56:11 <Olathe> > let f [] _ = []; f (x:xs) (y:ys) = if x then y:(f xs ys) else (f xs ys) in f [True,False,True] [1,2,3]
12:56:12 <lambdabot>  [1,3]
12:56:13 <vincenz> roconnor: what would be an example of something that is not associative?
12:56:18 <roconnor> -
12:56:22 <vincenz> hmm
12:56:26 <Olathe> > let f [] _ = []; f (x:xs) (y:ys) = if x==0 then y:(f xs ys) else (f xs ys) in f [0,1,0] [1,2,3]
12:56:27 <lambdabot>  [1,3]
12:56:33 <roconnor> ... stupid -
12:56:35 <mauke> > zipWith id (map (\x -> if x == 0 then (:) else const id) [0,1,0]) [1,2,3] []
12:56:36 <lambdabot>  Couldn't match expected type `[a] -> t'
12:56:39 <mauke> :(
12:56:40 <vincenz> roconnor: right I thoguht of that one, but I meant ... more generic
12:56:46 <vincenz> - is a bit odd
12:56:48 <vincenz> it's + negate
12:56:59 <mauke> > foldr id [] $ zipWith id (map (\x -> if x == 0 then (:) else const id) [0,1,0]) [1,2,3]
12:57:00 <lambdabot>  [1,3]
12:57:04 <roconnor> is the octernion multiplicaiton associative?
12:57:26 <monochrom> IIRC no.
12:57:36 <kaol> > concatMap (\(n,x) -> take (1-n) $ repeat x) $ zip [0,1,0] [1,2,3]
12:57:38 <lambdabot>  [1,3]
12:57:43 <vincenz> roconnor: what does that look like?
12:57:43 <omnId> mauke: zipWith id (map f xs) ys = zipWith f xs ys, I think
12:58:08 <blarz> thank you guys :)
12:58:37 <omnId> > foldr id [] $ zipWith (\x -> if x == 0 then (:) else const id) [0,1,0] [1,2,3]
12:58:38 <lambdabot>  [1,3]
12:58:40 <omnId> yerp
12:59:03 <roconnor> @go octernion
12:59:05 <lambdabot> http://en.wikipedia.org/wiki/User:Octernion/Boxen
12:59:10 <roconnor> :/
12:59:13 <monochrom> haha
12:59:14 <roconnor> @spell octernion
12:59:39 <dmwit> > [ x | (x, y) <- zip [0,1,0] [1,2,3], y /= 0 ]
12:59:41 <lambdabot>  [0,1,0]
12:59:48 <Olathe> http://en.wikipedia.org/wiki/Octonion
12:59:49 <lambdabot> Title: Octonion - Wikipedia, the free encyclopedia
12:59:50 <dmwit> > [ y | (x, y) <- zip [0,1,0] [1,2,3], x /= 0 ]
12:59:52 <lambdabot>  [2]
13:00:01 <dmwit> I think that style is much more readable.
13:00:04 <Olathe> According to that, it's nonassociative.
13:00:06 <dmwit> (In this case.)
13:00:48 <roconnor> oooh the Fano Plane!
13:03:06 <omnId> > do (x, y) <- zip [0,1,0] [1,2,3] ; guard (x == 0) ; return y
13:03:07 <lambdabot>  [1,3]
13:03:41 <Olathe> @pl \a b -> do (x, y) <- zip a b ; guard (x == 0) ; return y
13:03:41 <lambdabot> (line 1, column 30):
13:03:42 <lambdabot> unexpected ";"
13:03:42 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
13:03:46 <Olathe> @pl \a b -> (do (x, y) <- zip a b ; guard (x == 0) ; return y)
13:03:46 <lambdabot> (line 1, column 31):
13:03:46 <lambdabot> unexpected ";"
13:03:46 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
13:03:47 <Olathe> :(
13:04:02 <omnId> @. pl undo \a b -> (do (x, y) <- zip a b ; guard (x == 0) ; return y)
13:04:03 <lambdabot> flip flip (uncurry ((. return) . (>>) . guard . (0 ==))) . ((>>=) .) . zip
13:04:29 <Olathe> Yay !
13:04:49 <mauke> @. unpl . pl undo \a b -> (do (x, y) <- zip a b ; guard (x == 0) ; return y)
13:04:50 <lambdabot> (\ l f -> (zip l f) >>= (uncurry (\ o aa -> (guard (0 == o)) >> (return aa))))
13:05:05 <Olathe> > (flip flip (uncurry ((. return) . (>>) . guard . (0 ==))) . ((>>=) .) . zip) [0,1,0] [1,2,3]
13:05:07 <lambdabot>  [1,3]
13:05:33 <mauke> unpl++  # for guard (0 == o)
13:06:00 <Olathe> Heheh
13:06:23 <roconnor> Olathe: definitely the most clear answer
13:06:46 <roconnor> but shouldn't Data.Zippable be involved somewhere?
13:15:54 <_ry> anyone use vim?
13:16:06 <dmwit> _ry: Yes.
13:16:16 <_ry> dmwit: are you using anything special for haskell?
13:16:32 <dmwit> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
13:16:32 <lambdabot> Title: Haskell mode for Vim
13:18:21 <vincenz> emacs
13:20:08 <ico> yes, go for it!
13:20:11 <ico> fight fight
13:20:41 <vincenz> heh
13:20:44 <vincenz> funny thing is, I'm a vimmer
13:20:54 <ico> ah, just trolling eh :)
13:20:58 <vincenz> yeah :)
13:21:04 <vincenz> I should've added </troll>
13:21:21 <ico> I missed the sign "don't feed the trolls" at the entrance
13:21:24 <ico> sorry for that
13:21:36 * vincenz was joking
13:21:54 <ico> Yes, I know :)
13:22:14 <mauke> @quote emacs
13:22:14 <lambdabot> Philippa says: because emacs wasn't a good enough OS after all
13:22:24 <mauke> @quote vim
13:22:24 <lambdabot> No quotes match. My pet ferret can type better than you!
13:22:50 <oerjan> @remember mauke @quote vim
13:22:50 <lambdabot> Done.
13:22:59 <mauke> what
13:23:10 <Philippa_> hmm, as luck'd have it I'm currently trying to write a better haskell mode for jEdit
13:23:14 <oerjan> cannot have no quotes for vim, can we?
13:23:21 <Olathe> @quote vim
13:23:21 <lambdabot> mauke says: @quote vim
13:23:32 <matthew-_> Philippa_: err, I've actually read some of the source for jEdit
13:23:37 <Philippa_> doing it really really /right/ requires being able to match brackets though - I would love to be able to highlight types everywhere
13:23:53 <Philippa_> matthew-_: yeah, but I don't like emacs or vim and I'm on windows. Next best alternative's something like TextPad
13:23:55 <omnId> @remember @quote says:
13:23:55 <lambdabot> Done.
13:23:57 <matthew-_> Philippa_: thus I feel that I speek with some knowledge when I say, Are you totally stark raving mad?
13:24:02 <omnId> @quote says:
13:24:02 <lambdabot>  @quote says: says:
13:24:08 <vincenz> ...
13:24:11 <Olathe> @quote @quote
13:24:11 <lambdabot>  @quote says: says:
13:24:23 <Philippa_> the existing mode gets some fairly basic stuff wrong that I should be able to fix
13:24:25 <omnId> @forget @quote says:
13:24:25 <lambdabot> Done.
13:24:56 <oerjan> @quote says:
13:24:56 <lambdabot> No quotes match. My mind is going. I can feel it.
13:25:25 <mauke> @quote
13:25:25 <lambdabot> adept says: I think I need cobrain to understand coeffects
13:25:30 <Cale> http://www.primidi.com/2007/09/14.html -- damn, you can see the outer 4p orbitals of the individual germanium atoms!
13:25:31 <lambdabot> Title: The most powerful microscope in the world
13:25:35 <olsner> My mind *is* going. I *can* feel it.
13:25:49 <Philippa_> matthew-_: unless you could recommend a better editor for my situation?
13:25:53 <tibbe> @karma tibbe
13:25:53 <lambdabot> You have a karma of 1
13:25:54 <omnId> olsner: where to?
13:26:16 <olsner> omnId: I'd need my mind in the right place to tell you
13:26:21 <matthew-_> Philippa_: no sorry. I don't use windows at all
13:26:37 * monochrom loves orbitals
13:26:43 <oerjan> omnId: don't worry, i think it's actually just his comind
13:27:26 <KatieHuber> I've never used it, but if I were subjected to windows, I'd be trying this: http://www.e-texteditor.com/
13:27:27 <lambdabot> Title: E - TextEditor | The power of TextMate on Windows
13:27:41 <KatieHuber> TextMate on the Mac is far and away the best editor I've ever used
13:27:43 * omnId looks at E
13:27:49 * omnId is a windozer
13:28:32 <omnId> oh noes teh shareware!!
13:28:53 <olsner> oerjan: I think I need a cobrain to tell the difference
13:29:00 <Japsu> now we need to write F, a free clone
13:29:27 <matthew-_> yeah, editors are hard to get write
13:29:28 <KatieHuber> TextMate was the best 39 euro I ever spent... as a programmer, living in the editor, I don't mind paying a few bucks for a really good one ;)
13:29:41 <matthew-_> @slap matthew-_
13:29:41 * lambdabot slaps matthew-_
13:29:42 <Cale> vim!
13:29:56 <Zao> cat!
13:30:02 <matthew-_> edlin
13:30:14 <Cale> ed
13:30:21 <mauke> dd
13:30:28 <matthew-_> beav
13:30:34 <Cale> dd is the all-purpose unix tool
13:30:42 <mauke> s/dd/perl/
13:30:45 <omnId> @man dd
13:30:45 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
13:30:54 <omnId> lol, @map
13:31:23 <olsner> any unix tool that replaces more than one other tool has already become too complex
13:31:24 <Olathe> Not found.
13:31:30 <Olathe> We can't be found :(
13:31:36 <mauke> perl is unix in a box
13:31:55 <omnId> HaWiki was beleeted.
13:32:02 <olsner> * rule also applicable to perl
13:32:04 <oerjan> ghc -e interact
13:32:05 <omnId> (or taken down at least)
13:32:25 <monochrom> Cale: each dumbbell is one atom, not a combination of two?
13:32:33 <Cale> monochrom: yeah
13:32:55 <monochrom> Damn quantum mechanics and counterintuitive orbital wave functions. :)
13:32:58 <Cale> http://en.wikipedia.org/wiki/Image:AtomicOrbital_n4_l1.png
13:39:42 <newsham> quantum mechanics and intuition?
13:42:56 <vwx> how can i test true or false if a list has any duplicate elements?
13:43:42 <newsham> > (\x -> nub x == x) "testing"
13:43:45 <lambdabot>  False
13:43:48 <newsham> > (\x -> nub x == x) "tes"
13:43:48 <vincenz> eww
13:43:49 <lambdabot>  True
13:44:11 <Heffalump> unsafeCatch :: a -> (IOError -> a) -> a
13:44:13 <Heffalump> unsafeCatch x f = unsafePerformIO ((x `seq` return x) `catch` (return . f))
13:44:29 <sioraiocht> or you can could sort it, and step through and see if two adjacent elements are equal
13:44:30 <omnId> dupes (x:xs) = any (==x) xs
13:44:32 <Heffalump> anyone have any idea why that doesn't seem to work when I pass it something like case foo of Just x -> x ; Nothing -> error "foo" ?
13:44:52 <roconnor> > (\x -> 1 == product $ map length $ group $ sort x) "testing"
13:44:53 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
13:45:09 <omnId> (\(x:xs) -> any (==x) xs) "testing"
13:45:10 <roconnor> > (\x -> 1 == (product $ map length $ group $ sort x)) "testing"
13:45:12 <lambdabot>  False
13:45:15 <roconnor> > (\x -> 1 == (product $ map length $ group $ sort x)) "tes"
13:45:16 <omnId> > (\(x:xs) -> any (==x) xs) "testing"
13:45:18 <lambdabot>  True
13:45:18 <lambdabot>  True
13:45:21 <omnId> > (\(x:xs) -> any (==x) xs) "tesing"
13:45:22 <lambdabot>  False
13:45:26 <Heffalump> roconnor: all (==1) is much better than 1 == (product $
13:45:27 <newsham> > let x = sort "testing" in all zipWith (<) x (drop 1 x)
13:45:27 <lambdabot>  Couldn't match expected type `Bool'
13:45:28 <roconnor> omnId: ah
13:45:42 <roconnor> Heffalump: damn my math background
13:45:43 <newsham> > let x = sort "testing" in all $ zipWith (<) x (drop 1 x)
13:45:44 <lambdabot>  Couldn't match expected type `a -> Bool'
13:45:54 <newsham> > let x = sort "testing" in and $ zipWith (<) x (drop 1 x)
13:45:55 <lambdabot>  False
13:46:00 <newsham> > let x = sort "tes" in and $ zipWith (<) x (drop 1 x)
13:46:02 <lambdabot>  True
13:46:34 <Olathe> > ((++ "!!") . (>> "AA")) "hello"
13:46:35 <lambdabot>  "AAAAAAAAAA!!"
13:46:44 <omnId> er, mine's wrong, I think.
13:46:47 <sioraiocht> lol
13:46:58 <omnId> map (...) tails, maybe?
13:47:56 <omnId> > (\(x:xs) -> any (==x) xs) "really testing"
13:47:58 <lambdabot>  False
13:48:19 <omnId> > or $ map (\(x:xs) -> any (==x) xs) (tails "really testing")
13:48:21 <lambdabot>  True
13:48:37 <newsham> doesnt that traverse multiple times?
13:48:43 <omnId> n times
13:48:44 <newsham> as opposed to zipWith (<) on sorted list
13:48:51 <newsham> which is just once on n log n sorted list
13:51:26 <vwx> is (map f (concat x)) the same as (concatMap f x)   ?
13:51:34 <twanvl> > any (not . null . tail) . group . sort $ "testing"
13:51:35 <lambdabot>  True
13:52:02 <twanvl> concatMap f xs == concat (map f xs)
13:52:16 <oerjan> Heffalump: x `seq` return x evaluates x as part of the evaluation of the whole, not as part of its execution.  i think catch is only guaranteed to work for the latter. try with evaluate?
13:52:20 <sioraiocht> @src concat
13:52:20 <lambdabot> concat = foldr (++) []
13:52:26 <twanvl> so it's the other way around
13:52:33 <dmwit> ?hoogle [m Bool] -> m Bool
13:52:33 <lambdabot> No matches, try a more general search
13:52:34 <oerjan> :t evaluate
13:52:36 <vwx> twanvl: but isn't it still equal?
13:52:36 <lambdabot> Not in scope: `evaluate'
13:52:51 <twanvl> no
13:52:54 <sioraiocht> ?hoogle [m a] -> m a
13:52:54 <lambdabot> Prelude.head :: [a] -> a
13:52:54 <lambdabot> Prelude.last :: [a] -> a
13:52:54 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
13:52:58 <Heffalump> oerjan: I tried evaluate previously
13:53:06 <dmwit> ?hoogle (Monad m) => [m a] -> m a
13:53:06 <lambdabot> Prelude.head :: [a] -> a
13:53:06 <lambdabot> Prelude.last :: [a] -> a
13:53:06 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
13:53:10 <Heffalump> it seems that the actual fix is to use the Control.Exception catch rather than the IO one.
13:53:12 <newsham> wait..I jus tthought of something..  qsort is n-log-n (almost) and in the proces can discover if th elist is unique or not
13:53:12 <vincenz> Cale: a personal message for you: http://lemonodor.com/images/mccarthy-youre-doing-it-wrong-s.jpg
13:53:18 <Heffalump> This distinction always catches me out and always confuses me.
13:53:20 <newsham> why not just write a qsort-like function to test for uinqueness.
13:53:21 <oerjan> Heffalump: oh, of course
13:53:28 <Cale> vincenz: heh
13:53:29 <tibbe> @src Data.ByteString.concat
13:53:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:53:33 <vincenz> :P
13:53:36 <Heffalump> well, I don't really understand, since I thought error calls were in the IOError type.
13:53:49 <tibbe> @source Data.ByteString
13:53:49 <lambdabot> Data.ByteString not available
13:55:58 <oerjan> Heffalump: certainly not
13:56:07 <Cale> vincenz: did you see http://tnx.nl/php.jpg ?
13:56:12 <Heffalump> oh, ok :-)
13:57:35 <hpaste>  newsham pasted "uniq based on qsort" at http://hpaste.org/3244
13:57:38 <vincenz> Cale: I did now :D
13:58:20 <oerjan> Exception has an ErrorCall constructor for the former, and IOException for the latter
13:59:26 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#1
13:59:28 <lambdabot> http://tinyurl.com/sqmlj
14:01:59 <dmwit> :t cmp
14:02:01 <lambdabot> Not in scope: `cmp'
14:02:05 <dmwit> :t compare
14:02:07 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
14:02:30 <dmwit> > [LT..GT] --?
14:02:30 <lambdabot>  Parse error
14:02:36 <Olathe> @hoogle String -> IO ()
14:02:36 <lambdabot> Prelude.putStr :: String -> IO ()
14:02:36 <lambdabot> Prelude.putStrLn :: String -> IO ()
14:02:36 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
14:02:38 <mauke> > [LT .. GT]
14:02:42 <lambdabot>  [LT,EQ,GT]
14:03:13 <dons> > [LT ..]
14:03:15 <lambdabot>  [LT,EQ,GT]
14:03:24 <vincenz> > [ .. GT]
14:03:25 <lambdabot>  Parse error
14:03:27 <vincenz> :|
14:03:28 <oerjan> > [LT..GT] -- it's the comment
14:03:28 <lambdabot>  Parse error
14:03:36 <vincenz> oerjan: obviously that fails :)
14:03:44 <mauke> > [minBound .. maxBound] :: [Ordering]
14:03:46 <lambdabot>  [LT,EQ,GT]
14:03:46 <oerjan> huh?
14:03:49 <vincenz> CapitalizedIDentifier. is parsed as access to a module
14:03:57 <mauke> > [LT .. GT] -- ur mom's a comment
14:03:58 <lambdabot>  [LT,EQ,GT]
14:04:02 <omnId> @src Ordering
14:04:02 <lambdabot> data Ordering = LT | EQ | GT
14:04:20 <newsham> wow, you did not just eval that about my mom
14:04:42 <dmwit> > [LT..GT]
14:04:42 <lambdabot>  Parse error
14:04:45 <dmwit> > [LT .. GT]
14:04:46 <lambdabot>  [LT,EQ,GT]
14:04:47 <dmwit> It's the spaces.
14:05:03 <Olathe> > [1%4 .. 6%5]
14:05:05 <lambdabot>  [1%4,5%4]
14:05:09 <oerjan> > [LT .. GT] --? comment too, i think
14:05:09 <vincenz> dmwit: yes
14:05:09 <lambdabot>   parse error on input `,'
14:05:17 <vincenz> > [LT ..GT] -- this works
14:05:18 <lambdabot>  [LT,EQ,GT]
14:05:24 <vincenz> the issue is with CapitalizedIdentifier.
14:05:31 <vincenz> (module access)
14:06:01 <wolverian> > --?
14:06:01 <lambdabot>   parse error on input `--?'
14:06:06 <vincenz> > -- foo
14:06:06 <omnId> > let x --? y = "lol" in 1 --? 2
14:06:07 <lambdabot>   parse error on input `}'
14:06:08 <lambdabot>  "lol"
14:06:08 <newsham> > [Prelude.LT .. GT]
14:06:09 <lambdabot>  [LT,EQ,GT]
14:06:13 <newsham> > [Prelude.LT..GT]
14:06:13 <lambdabot>  Parse error
14:06:35 <hpaste>  dmwit annotated "uniq based on qsort" with "Slight optimization?" at http://hpaste.org/3244#a1
14:08:17 <puusorsa> just tried few things with nub and Data.Set .. the latter seems to be a lot faster
14:08:30 <byorgey> puusorsa: it should be
14:08:41 <mauke> nub is like O(n^2)
14:08:56 <byorgey> nub is O(n^2), whereas Data.Set uses a balanced binary tree, so should be O(n lg n)
14:09:00 <newsham> dmwit: wouldnt tuple be faster?
14:09:01 <puusorsa> hooray!
14:09:33 <newsham> (lt, eq, gt)
14:09:37 <dmwit> newsham: Probably, but then you couldn't use "and" and "zipWith ($) [uniq, null, uniq]" to obfuscate uniq more. ;-)
14:10:33 <newsham> could always add unzips ;-)
14:10:38 <dmwit> heh
14:29:16 <stef_> I have a question
14:29:22 <stef_> I know in mathematics what the composition operator is
14:30:00 <stef_> but here in haskell
14:30:06 <stef_> it doesn't make allot of sense to me
14:30:12 <omnId> > let f x = x + 3; g x = x * 2 in (f . g) 3
14:30:14 <lambdabot>  9
14:30:18 <Lemmih> ?src (.)
14:30:18 <lambdabot> (.) f g x = f (g x)
14:30:20 <stef_> (f.g)h=f(gh)
14:30:39 <mauke> (f . g) x = f (g x)  -- valid haskell definition
14:30:39 <olsner> mathrick: (f o g) x = f(g(x)); haskell: (f . g) x = f (g x)
14:31:02 <mathrick> olsner: *mauke?
14:31:09 <stef_> mauke: aren't you in perl as well ?
14:31:14 <olsner> mathrick: no, "math:" :P
14:31:17 <mauke> stef_: yes
14:31:19 <dmwit> (f . g) x = f(g(x)) -- also a valid haskell definition, and almost exactly like the math definition.
14:31:23 <wsdo_okadr> mauke: :)
14:31:28 <olsner> argh, darned auto-complete
14:31:31 <mathrick> olsner: ah, disable auto-completion then
14:31:43 <mathrick> it's a stupid feature
14:31:50 <mathrick> *misfeature
14:31:54 <dmwit> disagree
14:32:10 <wsdo_okadr> dmwit: only prblem is I see in this article I'm reading (f.g)h = f(gh) wich I interpret as f(g(h(x)))
14:32:12 <olsner> but I still can't type t e h
14:32:13 <wsdo_okadr> I hope so ...
14:32:18 <dmwit> Or, does auto-completion imply that there's no tab needed?
14:32:24 <wsdo_okadr> ok thanks all I understood now :)
14:32:33 <olsner> math:
14:32:49 <olsner> teh speling is worng
14:32:51 <wsdo_okadr> what does cons do as a function ?
14:33:05 <dmwit> It prepends an element to a list.
14:33:08 <dmwit> > 3 : [4,5,6]
14:33:10 <lambdabot>  [3,4,5,6]
14:33:15 <omnId> > 1 : [\
14:33:15 <lambdabot>  Parse error
14:33:18 <omnId> > 1 : []
14:33:20 <lambdabot>  [1]
14:33:44 <dmwit> wsdo_okadr: In Haskell, juxtaposition is function application, which may cause the confusion.
14:33:47 <wsdo_okadr> dmwit: is prepend analogous to append but only that it "appends" in front of the list ?
14:33:50 <omnId> [1,2,3] = 1:[2,3] = 1:(2:[3]) = 1:(2:(3:[]))
14:33:55 <dmwit> i.e. (g h) = g(h)
14:34:14 <dmwit> wsdo_okadr: yes
14:34:28 <Olathe> > 1:2:3:4:[]
14:34:29 <lambdabot>  [1,2,3,4]
14:34:59 <dmwit> > (,,) 3 4 5 -- dmwit attempts to derail and confuse
14:35:00 <lambdabot>  (3,4,5)
14:35:42 <mauke> it takes more than that to confuse a perl programmer!
14:35:43 <wsdo_okadr> does reduce mean to run the recurrence ?
14:35:54 <wsdo_okadr> it's not very clear YET to me what reduce does
14:36:00 <mauke> reduce?
14:36:01 <wsdo_okadr> I'm reading john hughes article
14:36:03 <dmwit> It depends on context.
14:36:07 <mauke> as in List::Util::reduce?
14:36:09 <wsdo_okadr> john hughes has this article
14:36:09 <dmwit> Has he defined a "reduce" function?
14:36:17 <wsdo_okadr> "Why functional programming matters"
14:36:21 <wsdo_okadr> I'm reading it
14:37:08 <hpaste>  gwern pasted "hslock build failure" at http://hpaste.org/3246
14:37:57 <sioraiocht> wsdo_okadr: link?
14:38:17 <omnId> foldr f z (a : (b : (c : []))) = (a `f` (b `f` (c `f` z)))
14:38:22 <newsham> wsdo: reduce as in [1,2,3,4] ->  1+2+3+4 ?
14:38:44 <newsham> > foldr (+) 0 [1,2,3,4]
14:38:46 <lambdabot>  10
14:38:50 <newsham> > foldr (*) 1 [1,2,3,4]
14:38:52 <lambdabot>  24
14:39:13 <dmwit> > foldr (-) 0 [1,2,3,4]
14:39:14 <lambdabot>  -2
14:39:26 <newsham> hand wavy description: replace the commas in a list with some binary operator
14:39:46 <Vulpyne> How insane am I to try to implement a SQL connection pool like this? http://hpaste.org/3245
14:39:54 <Vulpyne> It's weird enough to seem like it couldn't be the ideal way.
14:40:03 <wsdo_okadr> mauke: so you're doing perl at work ?
14:40:03 <wsdo_okadr> sioraiocht: google for "Why functional programming matters" and take the first link
14:40:09 <sioraiocht> kk
14:40:16 <oerjan> newsham: it needs to have the right associativity
14:40:21 <newsham> ?google why functional programming matters
14:40:22 <dmwit> ?go why functional programming matters
14:40:23 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
14:40:23 <lambdabot> Title: Why Functional Programming Matters
14:40:24 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
14:40:24 <lambdabot> Title: Why Functional Programming Matters
14:40:29 <dmwit> heh
14:40:35 <Jaak> > foldr ((.) . (+)) id [1,2,3] 0
14:40:37 <lambdabot>  6
14:40:37 <newsham> oerjan: and the right types.  thats why i said hand wavy :)
14:40:43 <fnord123> Has anyone installed xmonad on os x? And if so, did they run into dependency satisfaction issues w/ X11?
14:41:00 <omnId> wsdo_okadr: Another short but good advocacy read is:
14:41:01 <omnId> @go Haskell IO for imperative programmers
14:41:03 <lambdabot> http://blogs.nubgames.com/code/?p=22
14:41:06 <dmwit> fnord123: I think somebody has, check #xmonad.
14:41:26 <dmwit> omnId: 404
14:41:28 <fnord123> Oh thanks. I didnt realize there was a specific channel for xmonad
14:41:37 <omnId> :(
14:41:41 <newsham> you can stay here and talk haskell too :)
14:41:43 <wsdo_okadr> omnId: I don't know crap about haskell.I'm pushing my way through functional programming,and at the same time learning about formal languages grammars etc...
14:41:52 <wsdo_okadr> omnId: thanks for the article tough,I'll read it
14:42:02 <newsham> wsdo: shoulda took the blue pill
14:42:11 <newsham> enjoy the ride
14:42:26 <wsdo_okadr> omnId: the link you gave doesn't work
14:42:46 <wsdo_okadr> omnId: the site ... it asks me for password
14:42:46 <FMota> I've been experimenting mentally (and on paper) with a more generalized IO monad.
14:43:01 <omnId> I know.  It *was* a blog last time I checked.
14:43:31 <wsdo_okadr> omnId: do you have that thing saved/cached somewhere ?
14:43:33 <omnId> cached: http://209.85.135.104/search?q=cache:rf-XE7Mch-YJ:blogs.nubgames.com/code/%3Fp%3D22+http://blogs.nubgames.com/code/%3Fp%3D22&hl=en&ct=clnk&cd=1&gl=us
14:43:35 <lambdabot> http://tinyurl.com/2czo6j
14:43:43 <FMota> so, instead of IO x,  you'd have something like (A >> B) C
14:43:53 <wsdo_okadr> omnId: very nice
14:44:16 <olsner> FMota: what would (A>>B) C mean?
14:44:30 <FMota> IO x   =   (Char >> Char) x
14:44:34 <FMota> basically
14:44:56 <omnId> maybe (:>>)?
14:44:58 <newsham> so only character io?
14:45:10 <FMota> (A >> B) C   has A as input, B as output, and C as a result
14:45:23 <olsner> a -> (b,c)
14:45:29 <olsner> I think that's even a monad :P
14:45:40 <FMota> olsner, no
14:45:55 <FMota> it's more like  [a] -> ([a], [b], c)
14:46:26 <newsham> fmota: you might enjoy this:  http://www.cs.nott.ac.uk/~wss/Publications/BeautyInTheBeast.pdf
14:46:29 <FMota> why is this interesting
14:46:37 <olsner> well, no, but the right-hand argument to >>= for the (b,) monad is of the type a -> (b,c)
14:46:40 <Jaak> > evalState (put 1 >> modify (+1) >> get >>= return) 0
14:46:41 <lambdabot>  2
14:46:42 <newsham> they wrote a pure functional model of the IO monad and use dit to quickcheck things
14:46:45 <Jaak> that >>?
14:47:01 <newsham> there's also a video of his presentation online
14:47:07 <FMota> ? because you can reduce strings into this type, and you have map and fold that fit this model perfectly.
14:47:11 <olsner> granted, that has to take all of a instead of returning a tail of a for the rest of IO to work on
14:48:21 <FMota> ofc, the A >> B syntax is kinda flawed.
14:48:27 <FMota> (for haskell)
14:48:39 <Jaak> huh?
14:48:41 <omnId> you can use : to start infix type constructors
14:48:51 <wsdo_okadr> what kind of mind could one have to write a compiler for a functional programming language ?
14:49:17 <Jaak> spineless and tagless
14:49:26 <FMota> wsdo_okadr: a very s(;)ick mind indeed. :)
14:49:29 <FMota> *(l)
14:49:42 <omnId> I think it'd help to use one first and get used to the way of thinking.
14:49:57 <olsner> a mind won't be enough, you need a comind to go with it
14:50:03 <FMota> lol
14:50:07 <Japsu> lol
14:50:23 <FMota> @remember olsner a mind won't be enough, you need a comind to go with it
14:50:24 <lambdabot> Done.
14:50:25 <omnId> > cycle "lo"
14:50:27 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
14:50:43 <FMota> er, I didn't put any context :/   oops
14:50:46 <Japsu> > unwords $ repeat "lol"
14:50:47 <lambdabot>  "lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol...
14:51:01 <newsham> ?vixen they're laughing at you
14:51:01 <lambdabot> I have 2 c what u look like.. u have pic?? URL?? NOT a fake please.. ill know!
14:51:04 <ddarius> > cycle "lol "
14:51:05 <lambdabot>  "lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol...
14:51:35 <dmwit> > repeat () >> ["lol "]
14:51:37 <lambdabot>  ["lol ","lol ","lol ","lol ","lol ","lol ","lol ","lol ","lol ","lol ","lol ...
14:51:45 <dmwit> > repeat () >> "lol "
14:51:47 <lambdabot>  "lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol...
14:51:54 <Japsu> !
14:52:01 <Japsu> evil list monad trickery
14:52:31 <omnId> x >> y = x >>= const y = concatMap (const y) x
14:52:40 <FMota> so, if you have this special monad   (A :>> B) C,  you can envision the type [T] as (T :>> T) ()
14:52:53 <omnId> > concatMap (const "lol ") (repeat ())
14:52:54 <lambdabot>  "lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol...
14:52:56 <_ry> i'm having trouble getting indention working in vim. anyone have some tips? (i'm using http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/)
14:52:56 <lambdabot> Title: Haskell mode for Vim
14:53:19 <Japsu> > fix ("lol ":)
14:53:21 <lambdabot>  ["lol ","lol ","lol ","lol ","lol ","lol ","lol ","lol ","lol ","lol ","lol ...
14:53:25 <Japsu> :o
14:53:28 <ddarius> _ry: Use autoindent.
14:53:29 <Japsu> > fix ("lol " ++)
14:53:30 <omnId> s/:/++/
14:53:31 <lambdabot>  "lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol...
14:53:34 <Japsu> \o/
14:53:45 <dmwit> _ry: That doesn't have an indent file.
14:54:13 <dmwit> _ry: I just use :set autoindent.
14:54:34 <olsner> @src cycle
14:54:34 <lambdabot> cycle [] = undefined
14:54:35 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:55:00 <wsdo_okadr> what is the difference between haskell and lisp ?
14:55:01 <sioraiocht> > cycle [1,2,3]
14:55:03 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
14:55:03 <olsner> but why, when you have fix (xs ++)
14:55:10 <wsdo_okadr> what does lisp know and haskell doesn't ?
14:55:14 <omnId> wsdo_okadr: haskell is non-strict, for one.
14:55:28 <vwx> lisp has macros
14:55:31 <dmwit> Haskell has more syntax and is not eager; lisp does macros.
14:55:31 <_ry> yeah, :set autoindent isn't working - no idea why
14:55:32 <sioraiocht> wsdo_okadr: they're both turing-complete, they can do the same thing =[
14:55:44 <dmwit> _ry: What do you mean by "not working"?
14:55:49 <dmwit> sioraiocht: bah
14:55:56 <dmwit> You know that's not the point.
14:56:08 <sioraiocht> dmwit: Yes I know, I was feeling contrary.
14:56:13 <FMota> so...  map :: (A -> B) -> (A >> B) ()   and     map f = { until end { c <- get; put (f c) } }
14:56:21 <wsdo_okadr> I'm familiar with macros only in the context of fucking C
14:56:28 <wsdo_okadr> what do you people understnad by macros ?
14:56:29 <ddarius> Haskell has a friendly community.
14:56:30 <balodja> sioraiocht: c++ templates are also turing-complete :)
14:56:32 <FMota> ... where { } is an abbreviation for do { }
14:56:34 <FMota> :/
14:56:35 <_ry> dmwit: for example, if i do hello = do x <- blah (newline) it takes me to column 1
14:56:39 <sioraiocht> balodja: yes, so is TeX ;)
14:56:45 <wsdo_okadr> omnId: ?
14:56:50 <dmwit> _ry: Yes, autoindent keeps the same indent from the previous line.
14:56:53 <wsdo_okadr> omnId: whatd you understand by macros ?
14:57:05 <wsdo_okadr> dmwit: eager ?
14:57:16 <omnId> wsdo_okadr: complie-time code changing?
14:57:17 <sioraiocht> wsdo_okadr: eager is the opposite of lazy
14:57:39 <sioraiocht> wsdo_okadr: macros in C are the same concept
14:57:41 <Japsu> @src (&&)
14:57:41 <lambdabot> True  && x = x
14:57:41 <lambdabot> False && _ = False
14:58:00 <dmwit> wsdo_okadr: Sorry, I said Haskell is not eager (i.e. it doesn't evaluate function arguments right away), but I really meant Haskell as implemented by GHC is not eager.
14:58:05 <sioraiocht> @type ($$)
14:58:07 <lambdabot> Doc -> Doc -> Doc
14:58:10 <sioraiocht> @type (&&)
14:58:12 <lambdabot> Bool -> Bool -> Bool
14:58:13 <dmwit> ?index ($$)
14:58:13 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
14:58:22 <omnId> Pretty printing
14:58:24 <wsdo_okadr> where does one learn properly Formal Languages and where does one learn some real-world applications for them ?
14:58:44 <wsdo_okadr> dmwit: who is GHC ?
14:58:58 <omnId> Glasgow Haskell Compiler
14:59:09 <sioraiocht> wsdo_okadr: formal languages is a pretty broad concept, what doyou mean specifically?
14:59:21 <omnId> "functional"?
14:59:46 <wsdo_okadr> sioraiocht: what one learns in college about them
14:59:49 <olsner> dmwit: but I thought haskell required lazy evaluation? or are things like fix ("a" ++) actually undefined by the language?
15:00:03 <dmwit> olsner: Eager != strict.
15:00:11 <newsham> there are various college courses in formal languages
15:00:11 <sioraiocht> wsdo_okadr: that varies. a lot.  if you mean programming languagues, there are lots of good books
15:00:12 <dmwit> olsner: Haskell must be non-strict, but it need not be lazy.
15:00:18 <olsner> dmwit: oh, I see
15:00:36 <dmwit> ?go eager haskell
15:00:43 <lambdabot> http://csg.csail.mit.edu/pubs/haskell.html
15:00:43 <glguy> @yow
15:00:43 <lambdabot> Title: Computation Structures Group
15:00:43 <lambdabot> Wait ... is this a FUN THING or the END of LIFE in Petticoat Junction??
15:00:44 <raxas> formal language is what diplomats use to talk to other diplomats
15:00:47 <olsner> lazy is an opposite of strict, but eager is the opposite of lazy, or something like that
15:00:58 <FMota> > fix ("lol " ++)
15:00:59 <lambdabot>  "lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol lol...
15:01:02 <FMota> :)
15:01:04 <vincenz> @join #oasis
15:01:08 <glguy> raxas: you are thinking of lies and deceit
15:01:21 <omnId> strict/non-strict, eager can be an evaluation optimization for non-strict languages
15:01:28 <newsham> ?brain are you pondering what i'm pondering?
15:01:28 <lambdabot> Brain! Brain! You aren't going to leave me!!!???You know what happened to Jerry Lewis after Dean Martin left him!!!
15:01:34 <olsner> FMota: "<Japsu> > fix ("lol " ++)"
15:01:47 <sioraiocht> I always associated eagerness with parameter passing methods
15:02:00 <olsner> lambdabot should have an OLD! feature when evaluating something it recently evaluated :P
15:02:04 <Japsu> ;D
15:02:07 <FMota> btw, you can still have    fix ("lol " ++)  in a strict, pure language.
15:02:09 <omnId> > it
15:02:10 <lambdabot>   Not in scope: `it'
15:02:23 <raxas> glguy: yes. math logic theory is missing theory of lies. would be a pretty concept in startegy modelling
15:02:25 * sioraiocht has to program in OCaml this term
15:02:39 <glguy> raxas: doesn't that fit into game theory?
15:03:28 <olsner> FMota: I may be mixing up terms here, but my idea of strict is that f (f x) must have (f x) completely evaluated, and (f x) must have x completely evaluated, so that fix would never return
15:03:48 <olsner> (but that was also my idea of "eager" about three minutes ago)
15:04:12 <FMota> well, I *may* be mixing up strict and eager
15:04:20 <raxas> glguy: not quite, when you come to meta-lies, you'll need broader existential theory than fits in games
15:04:43 <omnId> @wiki Lazy vs. non-strict
15:04:43 <lambdabot> http://www.haskell.org/haskellwiki/Lazy_vs._non-strict
15:04:57 <FMota> but you can have that fix function in C, which is a strict language.
15:05:37 <FMota> obv, it needs a bit of support from the data types being used.
15:05:37 <olsner> I think that would need some explicitly coded delayed evaluation
15:05:42 <sioraiocht> has anyone here used happy?
15:05:45 <hpaste>  newb annotated "Friday 13" with "(no title)" at http://hpaste.org/3219#a8
15:06:04 <FMota> if you use pointers, then you have a circular list, just fine.
15:06:05 * locomalo is away: Ausente
15:06:40 <ddarius> > fix ((0:) . (1:) . ap (zipWith (+)) tail)
15:06:42 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:06:54 <vincenz> @join #oasis
15:07:19 <puusorsa> @type fix
15:07:21 <lambdabot> forall a. (a -> a) -> a
15:09:27 <omnId> @src fix
15:09:28 <lambdabot> fix f = let x = f x in x
15:09:46 <omnId> fix ("lol " ++) = let x = ("lol " ++) x in x
15:19:32 <newsham> olsner: not just while(1) { x2 = f(x); if(x == x2) break; x = x2; } ?
15:19:45 <newsham> (ie. standard convergence function)
15:24:43 <FMota> obv that won't ever converge for something like a c++ string
15:24:48 <FMota> (or C string)
15:25:00 <FMota> but you can have a linked list converge:
15:25:56 <FMota> *list = *conc("lol ", list)
15:26:04 <FMota> (if "lol " were a linked list)
15:28:13 <FMota> (basically, list points to a linked list node. conc creates a (temporary, probably leaky) list node, whose values are assigned to the node pointed by list.
15:28:28 <FMota> )
15:28:49 <_ry> is there some library like ragel (http://www.cs.queensu.ca/~thurston/ragel/) for haskell?
15:28:50 <lambdabot> Title: Ragel State Machine Compiler
15:30:31 <Cale> _ry: A parser generator?
15:30:45 <_ry> yes
15:31:05 <sioraiocht> _ry: Happy
15:31:10 <sioraiocht> @where happy
15:31:10 <lambdabot> http://www.haskell.org/happy/
15:31:12 <Cale> There's Happy, and a bunch of others.
15:31:19 <Cale> There are also parser combinator libraries
15:31:24 <vincenz> and it has GLR :)
15:31:37 <sioraiocht> GLR?
15:31:46 <vincenz> generalized L R
15:32:13 <vincenz> i.o.w it supports ambiguity
15:32:18 <sioraiocht> ah
15:32:57 <Cale> http://www.informatik.uni-bonn.de/~ralf/frown/
15:32:58 <lambdabot> Title: Frown - an LALR(k) parser generator for Haskell
15:33:06 <Cale> http://www.ki.informatik.uni-frankfurt.de/~klose/lucky.html
15:33:07 <lambdabot> Title: Lucky
15:33:27 <Cale> well, look here :) http://haskell.org/haskellwiki/Applications_and_libraries/Compiler_tools
15:33:29 <lambdabot> Title: Applications and libraries/Compiler tools - HaskellWiki, http://tinyurl.com/2p8tax
15:33:48 <Cale> Parsec is probably what you really want though :)
15:34:06 <Cale> It's more fun to build your parsers at runtime ;)
15:34:35 <Cale> Plus, it comes with GHC.
15:35:43 <bishopHU> re
15:35:50 <Cale> There's an only slightly outdated tutorial here: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html (The only thing which you'll have to change are the imports, the modules are under Text.ParserCombinators.Parsec)
15:38:25 <vincenz> @join #scheme
15:39:35 <dibblego> what does SPJ mean when he says that purity is more important than laziness?
15:40:00 <ddarius> dibblego: Exactly what he says.
15:40:12 <dibblego> more important to what?
15:40:14 <glguy> he finds the safety provided by purity more important for equational reasoning and composability than laziness?
15:40:36 <vincenz> @join #scheme
15:42:56 <Notrix> do I have to include a module to use digitToInt ?
15:43:04 <ddarius> @index digitToInt
15:43:05 <lambdabot> Data.Char
15:43:22 <Notrix> thank you :)
15:45:50 <Notrix> how can I find the source code of this function ? I can't find it in Char.hs :(
15:46:15 <ddarius> @src digitToInt
15:46:15 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:46:19 <ddarius> @source Data.Char
15:46:19 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
15:47:20 <Notrix> thank you :)
15:52:12 <Notrix> I have another question, when I use map is there a variable that represents the current element in the list ? I want to pass chr (x + value) where x is supposed to be the current element in the list
15:52:48 <dibblego> ?type map
15:52:50 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:52:57 <dibblego> the a in (a -> b)
15:53:10 <ddarius> Notrix: Look up lambda abstractions or go through some Haskell tutorial.
15:53:17 <dibblego> ?type map (\x -> chr (x + 7))
15:53:19 <lambdabot> [Int] -> [Char]
15:53:46 <ddarius> :t map (chr . (7+))
15:53:48 <lambdabot> [Int] -> [Char]
15:54:09 <Notrix> Okay thank you, yeah I have to read some tutorial
15:54:23 <oerjan> > map (\x -> chr (x + 7)) "Hello, world!\n"
15:54:24 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
15:55:20 <oerjan> > map (\x -> chr (x + 7)) [65,98]
15:55:22 <lambdabot>  "Hi"
15:55:50 <ddarius> > map (chr . (7+) . ord) "Hello, world!\n"
15:55:51 <lambdabot>  "Olssv3'~vysk(\DC1"
15:55:55 <Olathe> Eww
16:18:23 <shapr> hoi ChilliX
16:18:27 <shapr> Hoe gaat het?
16:27:21 <vincenz> ChilliX: ben jij nederlands?
16:28:29 <luqui> @source words
16:28:30 <lambdabot> words not available
16:28:38 <luqui> @source unwords
16:28:38 <lambdabot> unwords not available
16:28:44 <oerjan> @src words
16:28:44 <lambdabot> words s = case dropWhile isSpace s of
16:28:44 <lambdabot>     "" -> []
16:28:44 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:28:53 <luqui> @help source
16:28:53 <lambdabot> source <lib>. Lookup the url of fptools libraries
16:29:44 <hpaste>  FMota pasted "What MY IO monad would look and work like // IO in Sei" at http://hpaste.org/3247
16:32:49 <luqui> FMota, (Input >> Output) Value
16:33:07 <FMota> yep
16:33:32 <FMota> I like the last line :)
16:33:34 <luqui> so what's the reason for this abstraction?
16:33:49 <FMota> it's safer than IO?
16:33:53 <luqui> explain
16:33:59 <luqui> I'm just having a hard time understanding...
16:34:04 <FMota> well, with IO, you only have one type of file
16:34:11 <luqui> the world?
16:34:20 <luqui> RealWorld, I suppose
16:34:27 <FMota> heh, I suppose
16:35:35 <FMota> the purpose of the abstraction is that it can replace different monads for different things, but in a safe way.
16:35:55 <FMota> whereas with IO you just add features.
16:36:16 <luqui> okay, get a little more concrete
16:36:20 <luqui> example maybe?
16:36:36 <FMota> okay
16:36:59 <sjanssen> FMota: is this actually a monad?
16:37:28 <FMota> sjanssen: yes. It's a single monad. The monad is (A >> B).
16:37:38 <luqui> FMotaIO i o a
16:37:42 <FMota> lol
16:37:59 <sjanssen> oh, is that the Haskell equivalent?
16:38:17 <FMota> it would be, if it were implemented..
16:38:42 <sjanssen> FMota: this seems like a monad transformer
16:38:42 <FMota> hmm
16:39:03 <FMota> sjanssen: maybe. Do you have any papers I can read on that?
16:39:10 <luqui> sjanssen, quiet, still looking for an example :-)
16:39:13 <FMota> lol
16:39:38 <FMota> well, I believe I can give you an example of usefulness
16:39:45 <ChilliX> Hi shapr!
16:39:52 <ChilliX> vincenz: Why do you think so?
16:40:05 <vincenz> ChilliX: cause shapr was talking dutch to you
16:40:12 <vincenz> of belg misschien
16:40:13 <FMota> essentially, that map, foldl, and foldr can be used for things that aren't lists.
16:40:30 <FMota> that's useful.
16:40:40 <ChilliX> shapr ist just random ;)
16:40:44 <ChilliX> ist = is
16:40:45 <vincenz> dat is waar
16:40:50 <ChilliX> :)
16:41:02 <ChilliX> And being German, I can guess some dutch
16:41:14 <ChilliX> *Dutch
16:41:15 <vincenz> heh, remembers me of this chinese girl I know that barely speaks dutch, hearing her say 'dat is waar' is comic
16:41:34 <ChilliX> :)
16:41:36 <FMota> as for safety...  it probably isn't any more safe, but it beats having to go around finding a way to integrate two different monads
16:41:55 <luqui> FMota, Data.Foldable does something like that..
16:42:12 <FMota> although I can imagine that opening a file of Ints and only being able to get ints is safer than opening a file with IO and then getting ints.
16:42:22 <luqui> FMota, so what is the type of a function which copies one file into another?
16:42:38 <FMota> do you mean cat?
16:42:53 <FMota> (as in, the program cat)
16:42:54 <luqui> that question may have demonstrated my complete lack of understanding
16:43:03 <luqui> uh, but with the files hard coded
16:43:20 <jmob> How would I build a type that enforce an "invariant", like say I want a type that defines a strin that's at most 10 characters?
16:43:29 <Olathe> Does ghc take into account processor cache effects ?
16:43:55 <FMota> luqui:    cat = { until end { c = get; put c } }
16:43:56 <luqui> jmob, some sort of virtual constructor
16:44:20 <FMota> or,    pass = { c = get;  put c }    ;    cat = until end pass
16:44:21 <shapr> ChilliX: It's true, I am quite random.
16:44:34 <FMota> oh, you mean the type?
16:44:43 <FMota> um,  (A >> A) ()
16:44:44 <luqui> FMota, so is it just like IO in that I could open one file and copy it to another without any problems?
16:44:44 <vincenz> shapr lives in the random-monad
16:44:52 <vincenz> shapr :: Gen a
16:44:52 <FMota> yep.
16:44:55 <shapr> I could make a living as /dev/urandom
16:45:07 <sjanssen> jmob: there are two ways: make an abstract newtype and maintian invariants in all the primitive operations (easy, but no proof of correctness)
16:45:21 <FMota> I haven't decided what the syntax for opening files is yet
16:45:45 <luqui> just make some up
16:45:45 <FMota> but I can envision something of the sort:
16:45:46 <sjanssen> jmob: or use type programming techniques like GADTs and type classes (unwieldy, but you get a proof of correctness)
16:46:03 <dons> shapr :: Gen a -- hah
16:46:09 <ChilliX> shapr: lol - maybe it is also just your way of demonstrating how international this channel is ;)
16:46:12 <luqui> FMota, okay, so, what is this business where it beats trying to integrate several different monads
16:46:17 <FMota> open "source.txt" >>> create "dest.txt"
16:46:31 <jmob> sjanssen: I must admit I don't quite understand the diff b/t newtype and data
16:46:39 <eyeris> What is the /= operator?
16:46:55 <luqui> eyeris, not equal
16:46:59 <eyeris> ahh
16:47:03 <sjanssen> jmob: a newtype is just data with no runtime overhead
16:47:23 <luqui> FMota, create :: String -> (Char >> ()) ()  ?
16:47:24 <FMota> luqui: as far as I can tell, if you have two completely independent monads, you have to _create_ some _new_ functions in order to reconcile them
16:47:26 <luqui> do I have that right?
16:47:43 <FMota> er, the other way around
16:47:56 <FMota> create :: String -> (() >> Char) ()
16:47:58 <FMota> :)
16:48:03 <FMota> ohj
16:48:04 <FMota> wait
16:48:07 <FMota> no, you have it right
16:48:09 <FMota> lol
16:48:14 <FMota> *oh
16:48:29 <luqui> seems a little similar to arrows in that it parameterizes over inputs
16:48:34 <FMota> and   open :: String -> (Char >> ()) ()
16:48:39 <luqui> but there are two different types of "output" so that's a bit different
16:48:48 <FMota> well
16:49:01 <FMota> It's easy to think of it as a C program
16:49:09 <FMota> in C you have three things in main:
16:49:11 <FMota> stdin
16:49:12 <FMota> stdout
16:49:20 <FMota> and the value that you return  (usually 0)
16:49:38 <FMota> this is similar :)
16:49:46 <luqui> it's a little bit like formalizing shell commands
16:49:53 <FMota> XD
16:50:27 <luqui> I still don't really grok how this avoids the monad reconciliation problem
16:50:35 <jmob> sjanssen: So, how would you do that with a GADT?  data Sz10 = Sz10 [ Char, Char, Char, ... ] ?
16:50:43 <luqui> could I use a List monad as a FMotaIO?
16:50:57 <sjanssen> jmob: the example is somewhat involved
16:51:05 <FMota> luqui: I grant that you still need to reconcile _different_ monads
16:51:19 <sjanssen> jmob: you encode the length of the list into a type, which is a parameter of the list type
16:51:29 <FMota> but this monad is so general that that should only have to happen rarely.
16:52:05 <FMota> and so you can use different semantics for the same monad safely
16:52:05 <sjanssen> something like: data List n a where Nil :: List Zero a; Cons :: a -> List n a -> List (Succ n a)
16:52:06 <luqui> FMota, an RWSIO of sorts
16:52:14 <FMota> RWSIO?
16:52:18 <luqui> RWS + IO
16:52:37 <luqui> or is it the other way
16:52:46 <FMota> for example:    [1,2,3,4] -> create_Int "data_file.dat"
16:53:09 <luqui> which... writes... binary representation of the list to that file?
16:53:10 <FMota> I don't know what the acronym(s) mean...
16:53:15 <FMota> yep
16:53:20 <luqui> FMota, RWS is a monad in the standard library
16:53:29 <FMota> er, I didn't mean ->
16:53:29 <luqui> Reader + Writer + State
16:53:32 <FMota> meant >>>
16:53:40 <FMota> ah, I see
16:53:53 <luqui> it's convenience mostly
16:54:04 <FMota> concenience is important. :)
16:54:07 <FMota> *convenience
16:54:11 <FMota> I can't type today :/
16:54:23 <luqui> could use ReaderT r (WriterT w (State s)) ()
16:54:24 <jmob> sjanssen: Succ?
16:54:38 <luqui> but ugh, look at that beast
16:54:45 <Pseudonym> You know, I think people use the combination of Reader + State more often than R+W+S.
16:54:47 <FMota> lol
16:55:00 <sjanssen> jmob: just a dummy data type that means successor, +1
16:55:00 <luqui> I hardly ever use reader anymore
16:55:04 <luqui> just use implicit params instead
16:55:10 * ddarius never uses Writer
16:55:18 <sjanssen> jmob: type level peano arithmetic
16:55:21 * Pseudonym never uses Writer either
16:55:34 <Pseudonym> If I need that, I stack on top of IO.
16:55:43 <Pseudonym> I do use Reader, though.
16:55:44 <luqui> FMota, look at arrows a bit.  You can do a lot of control flow abstraction with them
16:55:48 <jmob> sjanssen: right, but I don't see where the length of the list is limited
16:55:48 <luqui> very general in a way
16:55:55 <luqui> I had fun writing a "quantum computation" arrow
16:56:01 <FMota> ooh
16:56:04 <luqui> you can overload the meaning of "if"
16:56:04 <FMota> :p
16:56:07 <sjanssen> jmob: yeah, we're only half way there
16:56:07 <Pseudonym> A ReaderT with a record of IORefs on top of IO is a great combination.
16:56:34 <FMota> well, I crated "if" in my hpaste (btw)
16:56:56 <luqui> FMota, and it went completely over my head! :-)
16:57:05 <luqui> as did arrows when I learned about them
16:57:06 <luqui> :-)
16:57:14 <sjanssen> jmob: next step, you define data Char10 where C10 :: (LessThan n 10) => List n Char -> Char10
16:57:24 <FMota> :)
16:57:33 <FMota> well, I'm learning these things one by one
16:57:43 <sjanssen> jmob: where LessThan is a typeclass that ensures that n is less than Ten
16:57:51 <FMota> learn by design... is a very good way of learning.
16:58:19 <luqui> FMota, you explore a lot of space that way.  I was a designer on perl 6 for quite a while
16:58:35 <FMota> :) yep
16:58:38 <ddarius> I should benchmark ReaderT (STRef s) ST v. State s
16:58:39 <eyeris> I have a data type `data Rec = MkRec { age :: Int ; name :: String }. I want to sort them by age. I can make Rec an instance of Eq and Ord with `instant Eq Rec where (==) a b = (age a) == (age b) ...`, but knowing Haskell, there must be a higher order function for this type of thing.
16:58:53 <luqui> a good combination of designing new things and learning mind-blowing things is my favorite way to learn
16:59:14 <allbery_b> (==) `on` age -- ?
16:59:28 <sjanssen> jmob: as I said earlier, all this is rather unwieldy and you're better off just using an abstract data type
16:59:41 <luqui> eyeris, you can use a deriving clause
16:59:44 <luqui> eyeris, or use sortBy
16:59:45 <allbery_b> for sorting, that'd be (comparing age)
16:59:57 <FMota> luqui: totally agree
17:00:09 <eyeris> Awesome. Thanks.
17:01:09 <allbery_b> ("haskell: higher order fun(ctions)!")
17:03:59 <luqui> allbery_b, what... are you talking about?
17:04:19 <luqui> (==) `on` age     -- what does this mean?
17:04:40 <allbery_b> see eyeris's question, then I riffed on the "selling haskell" thread on -cafe
17:04:55 <TSC> @src on
17:04:55 <lambdabot> (*) `on` f = \x y -> f x * f y
17:05:07 <allbery_b> so I gave him the HOF answer to his instance Eq then told him how to do the sorting
17:05:29 <luqui> @src comparing
17:05:29 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:05:31 <TSC> So, (==) `on` age means: \x y -> (age x) == (age y)
17:05:32 <allbery_b> (him?  her?  on irc nobody knows you're a lolcat)
17:05:33 <oerjan> @let (~~ `on` f) x y = f x ~~ f y
17:05:33 <lambdabot>  Parse error
17:05:35 <nornagon> woah... (*) in argument list?
17:05:51 <luqui> nornagon, yeah, pretty cool huh
17:05:58 <allbery_b> why not?  it's a perfectly valid haskell name
17:06:02 <luqui> there's nothing special about operators
17:06:08 <nornagon> neat
17:06:16 <jmob> sjanssen: I think this addresses what I want to know http://en.wikibooks.org/wiki/Haskell/GADT
17:06:18 <lambdabot> Title: Haskell/GADT - Wikibooks, collection of open-content textbooks
17:06:21 <oerjan> @let ((~~) `on` f) x y = f x ~~ f y
17:06:28 <lambdabot> Defined.
17:06:50 <sjanssen> jmob: yep, that SafeList example should be a good start
17:07:29 <dibblego> can you create a type-class for join, then write a function :: (MonadPlus m, Monoid b) => m a -> b ?
17:07:52 <dibblego> actually, you can already call join, so just, can you create that function?
17:08:05 <jmob> sjanssen: thanks :)
17:08:07 <dibblego> instance even
17:08:25 <ddarius> instance of what?
17:08:38 <dibblego> of Monoid
17:08:39 <oerjan> dibblego: your type doesn't make sense
17:09:06 <luqui> (MonadPlus m, Monoid a) => m a -> a maybe?
17:09:07 <oerjan> you mean m b -> b?
17:09:15 <dibblego> yes, I do
17:09:48 <oerjan> :t liftM mconcat . foldr mplus mzero
17:09:50 <lambdabot> forall a (m :: * -> *). (Monoid a, MonadPlus m) => [m [a]] -> m a
17:10:04 <oerjan> er..
17:10:09 <luqui> :t mconcat
17:10:11 <lambdabot> forall a. (Monoid a) => [a] -> a
17:10:38 <oerjan> oh right, you cannot escape the monad
17:10:40 <dibblego> Monoid just looks like a more general MonadPlus
17:11:28 <luqui> (MonadPlus m, Monoid (m a)) => ... something ...
17:12:26 <oerjan> MonadPlus is a Monoid in several different ways
17:12:35 <dons> more db bindings, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsSqlite3-0.0.1
17:12:37 <lambdabot> http://tinyurl.com/ys3kgd
17:13:01 <oerjan> er, maybe not
17:13:20 <ddarius> mplus/mzero (>>)/return
17:13:42 <oerjan> ddarius: doesn't quite work
17:13:49 <oerjan> no right identity
17:14:12 <ddarius> (>>)/return () specifically
17:14:20 <jmob> sjanssen: so I guess there's no what to describe a hierarchy of data types in haskell?
17:14:50 <sjanssen> jmob: hierarchy?  Do you mean OO style subtyping?
17:15:31 <jmob> sjanssen: yes
17:15:38 <sjanssen> jmob: no, not natively
17:15:49 <sjanssen> jmob: I don't see what this has to do with length limited lists, though
17:16:27 <luqui> you can do some form of OO subtyping with type classes; much more with GHC's existential types
17:16:43 <luqui> (though those usually represent a non-functional implementation of a solution)
17:16:56 <ddarius> Actually, the subtyping is pretty much what you can't do.
17:17:07 <jmob> sjanssen: the wikibook example pretty much states that you can't have a function that returns an empty list and a non empty list
17:17:57 <sjanssen> jmob: where does it say that?
17:18:26 <jmob> sjanssen: at the bottom
17:18:27 <luqui> ddarius, covariant subtyping is possible with existential types though, isn't it?
17:18:40 <jmob> sjanssen: the example "Trouble with GADTs"
17:19:05 <ddarius> luqui: You can do the "dynamic dispatch", you can't do the actual subtyping.  Some coercion needs to be explicit.
17:19:06 <jmob> sjanssen: since Empty and NonEmpty are separate types?
17:19:24 <sjanssen> jmob: I wouldn't really call that a problem
17:19:37 <luqui> ddarius, oh, right, there's no equivalent of dynamic_cast, is that what you mean?
17:19:43 <sjanssen> jmob: the entire point of the GADT is to make empty lists and non empty lists incompatible
17:20:19 <ddarius> luqui: No.  I mean there's no subtyping.  You can't use a type for another type (except via instantiation).
17:20:47 <ddarius> There is, actually, a dynamic_cast equivalent
17:21:09 <jmob> hmmm
17:21:47 <luqui> you can achieve the same modular design, modulo syntactic hiccups which aren't there in subtyping languages
17:21:57 <luqui> what
17:22:02 <luqui> is this dynamic_cast
17:22:11 <luqui> (without making a visitor in the typeclass def)
17:22:12 <oerjan> :t cast
17:22:21 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
17:22:29 <luqui> oh, Typable doesn't count
17:22:33 <luqui> :-)
17:22:36 <ddarius> luqui: It would depend on the encoding of "objects" or whatever, but cast is an example.
17:24:47 <ddarius> The issue is I can't use a triple where a pair is requested and I can't encode them so that it works.  I can make a "coerce" function to do it, but I have to explicitly apply that coercion.  Of course, I could -always- have written a (a,b,c) -> (a,b) function anyway so...
17:33:08 <dibblego> why is mconcat on Monoid? especially when no instances provide "an optimized version can be provided for specific types."?
17:33:35 <sjanssen> dibblego: but they *might* provide an optimized version
17:33:47 <sjanssen> dibblego: mconcat is a foldr by default
17:33:58 <dibblego> sjanssen, ok, so why a [a] and not a (Foldable f) => f a ?
17:34:16 <luqui> Foldable wasn't around when Monoid was?
17:34:23 <sjanssen> but that's horribly inefficient if mappend is strict in both arguments -- so I might use foldl' instead
17:34:39 <dibblego> right I agree with that
17:35:22 <sjanssen> dibblego: no good reason, really
17:35:25 <dibblego> would it be changed to (Foldable f) => f a -> a if we could?
17:36:38 <sjanssen> maybe
17:37:01 <sjanssen> dibblego: there are hundres of these issues in the standard libraries
17:37:24 <sjanssen> why doesn't (++) = mappend, why doesn't concat work on any Foldable, etc.
17:37:31 <dibblego> I know; I'm just thinking of writing them in Scala, so I don't want to repeat them :)
17:37:43 <dibblego> you mean the source for (++)?
17:37:52 <sjanssen> dibblego: I mean the type
17:38:00 <dibblego> ah righy
17:38:03 <dibblego> *right
17:38:04 <sjanssen> (++) :: Monoid a => a -> a -> a
17:38:13 <dibblego> yep; that's what I am hoping to achieve :)
17:39:06 <sjanssen> dibblego: isn't Scala strict?
17:39:14 <dibblego> by default yes
17:39:20 <sjanssen> in that case, I don't think mconcat should be a class member at all
17:39:32 <dibblego> I can make it lazy
17:39:33 <sjanssen> erm, maybe not
17:39:46 <dibblego> I have a lazy cons list for example
17:39:50 <sjanssen> I suppose early exit is still useful, even if the input is totally evaluated
17:40:41 <dibblego> if it's a foldable, then why would it matter?
17:48:03 <chessguy> the new lambdacats pictures are getting markedly less funny
17:48:32 <ddarius> They were funny?
17:48:50 <Pseudonym> I thought they were supposed to be dumb.
17:49:13 <sjanssen> Pseudonym: did you send in Oleg cat and Simon cat?
17:49:18 <chessguy>  some of the originals are pretty funny
17:49:29 <Pseudonym> Yes.
17:49:45 <Pseudonym> And I finally did a Moggi reference.
17:50:04 <Pseudonym> Not sent in yet.
17:50:07 <Pseudonym> http://andrew.bromage.org/eugenio.jpeg
17:50:37 <Pseudonym> I have a few ideas for a Wadler joke, but I need a good picture.
17:50:53 <sjanssen> hopefully shillelagh puts those up soon, Oleg cat is very funny
17:51:07 <ddarius> Oleg cat?
17:51:07 <Pseudonym> He's going to do them over a few days.
17:51:18 * Pseudonym won't spoil it
17:51:20 <sjanssen> makes sense
17:51:23 <Pseudonym> You'll see it when it's posted.
17:51:36 <ddarius> Only if I look.
17:51:38 <sjanssen> @seen shillelagh
17:51:38 <lambdabot> shillelagh is in #gentoo-haskell and #xmonad. I last heard shillelagh speak 3h 1m 19s ago.
17:51:54 <sjanssen> @tell shillelagh you should ask ibid to put lambdacats on planet.haskell.org
17:51:54 <lambdabot> Consider it noted.
17:51:57 <chessguy> i thought it was byorgey's site
17:52:10 <Pseudonym> No, it's not.
17:52:14 <Pseudonym> He just submitted a bunch.
17:58:41 <sarehu> Can type families allow you to describe sets of types with union and intersection operations and equivalence?
18:06:59 <luqui> can someone give an example use case for the ST monad?
18:07:19 <mauke> in-place sorting
18:07:29 <sarehu> you stole my answer
18:07:59 <luqui> mauke, make one STRef for each element of the list?
18:07:59 <Pseudonym> Mucking around with arrays, in general.
18:08:04 <luqui> oh of course
18:08:06 <luqui> arrays
18:08:09 <luqui> I remember that those exist
18:08:12 <luqui> :-)
18:08:24 <mauke> haha
18:09:31 <Pseudonym> :t runSTUArray
18:09:39 <lambdabot> Not in scope: `runSTUArray'
18:09:41 <Pseudonym> One of the most useful functions in ST.
18:09:49 <Pseudonym> :t Data.Array.ST.runSTUArray
18:09:51 <lambdabot> forall i e. (Ix i) => (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
18:10:06 <Pseudonym> Also runSTArray, obviously.
18:51:14 <shapr> I wonder if I could mix HAppS and pandoc to make a nice wiki for HAppS 0.9.1
18:51:16 <shapr> hmm
18:51:17 * shapr tries
19:01:21 <tehgeekmeister> what's the use of runWriter in the writer monad?
19:02:16 <mauke> getting the result
19:02:58 <lament> tehgeekmeister: note how the monad type class provides a function for sticking data into a monad ("return"), but nothing for getting the data back
19:04:17 <tehgeekmeister> so it'd be the same for runReader, i'd assume?
19:07:02 <shapr> Does the pandoc author show up on #haskell?
19:07:43 <dcoutts> yay, my great ADSL blackout is over
19:08:03 <shapr> happiness!
19:08:10 <cjay> \o/
19:08:11 <Zao> dcoutts: Welcome back to improductivity.
19:52:07 <Boney> @src ([] >>=)
19:52:07 <lambdabot> Source not found. My mind is going. I can feel it.
19:52:18 <sorear> @src [] >>=
19:52:18 <lambdabot> Source not found. Do you think like you type?
19:52:20 <sorear> @src [] (>>=)
19:52:21 <lambdabot> m >>= k     = foldr ((++) . k) [] m
19:53:10 <Boney> cheers.
19:53:15 <mauke> @src concatMap
19:53:15 <lambdabot> concatMap f = foldr ((++) . f) []
19:57:19 <Cale> What a silly definition for bind there
19:57:29 <Cale> Why not just define it as concatMap?
19:57:38 <ddarius> @index concatMap
19:57:39 <lambdabot> Data.List, Prelude
19:57:45 * ddarius shrugs
19:58:29 <Beelsebob> Cale: because both have the same result, but that definition highlights that the two are essentially unrelated in terms of what they're meant to mean
19:58:38 <Beelsebob> they may turn out to be the same function
19:58:38 <shapr> @yarr
19:58:38 <lambdabot> Drink up, me 'earties
19:58:48 <Cale> Beelsebob: um, but they're completely related
19:58:56 <Beelsebob> but that doesn't mean they should be defined in terms of each other
19:59:04 <ddarius> Indeed. You're not going to change concatMap without changing (>>=)
19:59:27 <ddarius> Them being exactly equal suggests that you should.
19:59:35 <Beelsebob> I may be missing something... but why should bind and concatMap be the same
19:59:44 <Beelsebob> am I missing an obvious logical step here?
19:59:45 <ddarius> Well, almost
19:59:47 <Cale> The only valid reason I can think of for defining them separately would be not expecting the compiler to do inlining.
19:59:56 <ddarius> :t concatMap
19:59:59 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
20:00:01 <ddarius> :t flip concatMap
20:00:03 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
20:00:03 <Cale> Beelsebob: because in the list monad, join is concat, and map is map
20:00:22 <Beelsebob> Cale: yes, that doesn't mean that monads should be defined in terms of list functions though
20:00:29 <Cale> huh?
20:00:36 <Korollary> it's the list instance's bind
20:00:36 <Beelsebob> that means list functions might be defined in terms of monad functions
20:00:40 <Cale> The list monad is obviously going to be defined in terms of list functions
20:00:47 <Beelsebob> yes
20:00:47 <iank> awesome
20:00:50 <iank> how that lined up there
20:00:54 <Beelsebob> but bind is not only for the list monad
20:00:57 <Beelsebob> it's for many monads
20:01:08 <mauke> Beelsebob: so are liftM and join
20:01:08 <Korollary> but that's bind's definition for lists only
20:01:21 <Korollary> so you can use concatMap freely
20:01:22 <Beelsebob> mauke: oh, duh
20:01:29 <Beelsebob> yeh... I knew there was a logical step I was missing
20:01:32 <Beelsebob> too late at night it is
20:51:31 <hpaste>  gwern pasted "cut-alike: how to check input elegantly?" at http://hpaste.org/3248
20:52:30 <gwern> I've been trying to figure out a neat way to check that the indices aren't too big or too small in my cutR function, but everything I get is a big buggy mess
20:52:35 <gwern> any ideas?
20:54:44 <Cale> gwern: Implement an indexing function with a parameter to use as a default?
20:55:15 <gwern> Cale: I'm not quite following
20:56:56 <oerjan> another possibility: use zipWith (-) ns (0:ns).  use drop as your lookup function
20:57:35 <gwern> that's worth trying
20:57:37 <Cale> That is (indexWithDefault x xs n) will give x if n is out of bounds
20:58:06 <oerjan> this has the advantage you don't need to traverse string several times
20:58:26 <Cale> You shouldn't have to anyway :)
20:58:26 <oerjan> (assuming ns is ordered)
20:58:32 <gwern> Cale: oh. so in this case, the sensible default is an empty string, for example, right?
20:58:37 <Cale> yeah
20:59:34 <Cale> indexWithDefault is a useful enough function that I don't know why it's not in the library. I tend to want it more often than I want !!
21:00:32 <gwern> maybe they figure you could just uses indexing like normal and catch if that makes you unhappy
21:01:05 <oerjan> > scanl drop "testing" [1,2,3]
21:01:06 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
21:01:36 <gwern> > :t scanl
21:01:36 <lambdabot>   parse error on input `:'
21:01:41 <oerjan> > scanl (flip drop) "testing" [1,2,3]
21:01:42 <lambdabot>  ["testing","esting","ting","g"]
21:02:21 <Cale> gwern: catch is a pain in the ass with exceptions thrown by error.
21:02:55 <Cale> (because you have to ensure that the evaluation causing the error is sequenced correctly with the IO call to catch
21:05:00 <oerjan> > map (take 1) . scanl (flip drop) "testing" . ap (zipWith (-)) (0:) $ [1,2,5,9]
21:05:02 <lambdabot>  ["t","e","s","n",""]
21:05:20 <gwern> oerjan: I gotta say, looking at that scanl one-liner is quite frustrating, because I sense that if I were smarter or thinking harder I could come up with a nice solution
21:05:46 <oerjan> hm, something wrong here
21:06:20 <oerjan> oh right, scanl gives the original value first
21:06:44 <oerjan> > map (take 1) . tail . scanl (flip drop) "testing" . ap (zipWith (-)) (0:) $ [1,2,5,9]
21:06:46 <lambdabot>  ["e","s","n",""]
21:08:02 <oerjan> now any empty lists in the result indicates an index too large
21:09:20 <oerjan> > sequence . map (take 1) . tail . scanl (flip drop) "testing" . ap (zipWith (-)) (0:) $ [1,2,5,9]
21:09:22 <lambdabot>  []
21:09:27 <gwern> a counterintuitive error message to be sure...
21:09:27 <oerjan> > sequence . map (take 1) . tail . scanl (flip drop) "testing" . ap (zipWith (-)) (0:) $ [1,2,5]
21:09:28 <lambdabot>  ["esn"]
21:11:15 <dmwit> I got it.
21:11:58 <oerjan> it's the usual for lists as Monad(Plus), empty means error
21:12:11 <dmwit> > [ x | elem y [1,2,5,9], (x, y) <- zip "testing" [0..] ]
21:12:12 <lambdabot>   Not in scope: `y'
21:12:30 <dmwit> > [ x | (x, y) <- zip "testing" [0..], elem y [1,2,5,9] ]
21:12:32 <lambdabot>  "esn"
21:13:05 <dmwit> The advantage here is that [1,2,5,9] need not be nondecreasing.
21:13:31 <oerjan> dmwit: that will ignore any error indices
21:13:39 <dmwit> Yes.
21:13:44 <dmwit> So will your last one, right?
21:14:09 <oerjan> no, with sequence it makes the whole things empty if there are errors
21:14:22 <dmwit> > [ x | (x, y) <- zip "testing" [0..], elem y [32,45] ]
21:14:24 <lambdabot>  ""
21:14:25 <oerjan> *thing
21:14:32 <dmwit> Mine too?
21:15:00 <oerjan> > [ x | (x, y) <- zip "testing" [0..], elem y [32,1,3,45]]
21:15:01 <lambdabot>  "et"
21:15:36 <dmwit> o
21:18:09 <dmwit> > sequence [[x] | (x,y) <- zip "testing" [0..], elem y [32,1,3,45]]
21:18:10 <lambdabot>  ["et"]
21:18:17 <hpaste>  gwern annotated "cut-alike: how to check input elegantly?" with "shortened version" at http://hpaste.org/3248#a1
21:18:27 <dmwit> Oh, right.
21:19:23 <gwern> add in some clever way to easily turn the list of Strings into a String, and I think that'd be a wrap
21:20:01 <gwern> concat $ is the obvious way
21:20:03 <dmwit> You mean like "unwords" or something?
21:20:07 <dmwit> Yeah, concat.
21:20:22 <dmwit> Or, better,
21:20:29 <dmwit> concat . intersperse [delim] $
21:20:41 <gwern> dmwit: you beat me to the punch :)
21:20:47 <gwern> (I was about to type that)
21:21:04 <sclv> @quote stereo
21:21:04 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
21:21:13 <dmwit> Bwahaha!
21:22:08 <gwern> wait, perhaps it could be '[x:delim |'  instead
21:22:57 <oerjan> gwern: that would give a delim at the end
21:23:20 <gwern> oh. hmm.
21:26:34 <dmwit> gwern: do [[delim, x] | ..., then drop 1.
21:27:32 <dmwit> or [delim:x | ... or whatever
21:29:41 <hpaste>  eyeris pasted "Why doesn't this quicksort terminate? It stack overflows." at http://hpaste.org/3249
21:30:05 <eyeris> I think I am misunderestimating something about the scoping
21:30:20 <Pseudonym> eyeris: quicksort []
21:30:32 <eyeris> doh
21:30:35 <gwern> I notice two different as, it seems. could be confusing
21:30:49 <dmwit> They are the same as.
21:30:51 <eyeris> that's what I meant by the (a:[]), I know it's wrong now
21:31:02 <dibblego> eyeris, [a] is prettier anyway :)
21:31:23 <dmwit> Is "as" only a keyword if there's an "import" before it?
21:31:42 <eyeris> dmwit it must be, because I see it used a lot
21:32:04 <gwern> dmwit: yes, that works. you need to reverse the order of concat and drop 1, but it works
21:58:46 <dibblego> is there a type-class for (:) ?
21:59:10 <vincenz> no
22:00:33 <dibblego> should there be one?
22:04:43 <_achilles_> can anyone explain why I might be getting a stack overflow in what seems like a pretty simple program?
22:05:22 <_achilles_> if I break the computation up into chunks, it works, but not when I try and do it all at once
22:05:38 <sjanssen> _achilles_: using foldl somewhere?
22:06:01 <_achilles_> indirectly through maximum?
22:06:02 <sjanssen> _achilles_: or perhaps a recursive function with an accumulator that isn't being forced?
22:06:24 <sjanssen> hmm, maybe maximum
22:06:36 <_achilles_> @src maximum
22:06:36 <lambdabot> maximum [] = undefined
22:06:36 <lambdabot> maximum xs = foldl1 max xs
22:06:38 <sjanssen> _achilles_: your problem might disappear with ghc -O
22:07:02 <dibblego> class Cons t where
22:07:02 <dibblego>   (+:) :: a -> t a -> t a -- is this silly?
22:07:29 <sjanssen> dibblego: presumably you'd have uncons too
22:07:46 <dibblego> doesn't Traversable do that?
22:07:58 <Pseudonym> Data.Sequence, of COURSE, implements its own.
22:08:04 <_achilles_> sjanssen, looks like the -O may have taken care of it
22:08:14 <Pseudonym> Because it can't do anything the way anyone else does it.
22:08:52 <_achilles_> I just wish I could run it in ghci though
22:13:23 <jmelesky> so, i know i can use readInt to convert a ByteString to an Int, but is there any way to convert it to a Float?
22:17:04 <hpaste>  sjanssen pasted "Why don't the standard libraries use this maximum?" at http://hpaste.org/3250
22:17:32 <Pseudonym> Because it's not in the spec.
22:17:34 <Pseudonym> Next question/
22:17:35 <Pseudonym> ?
22:17:40 <hpaste>  sjanssen annotated "Why don't the standard libraries use this maximum?" with "as found in Data.List" at http://hpaste.org/3250#a1
22:18:01 <sjanssen> Pseudonym: the report should probably be changed too
22:18:15 <sjanssen> Pseudonym: not to mention we diverge from the report in other places
22:18:33 <Pseudonym> I suggest you dump CORE for both of these and see if there's any real difference, then report back.
22:18:55 <sjanssen> the core is different -- that's the point
22:19:08 <sjanssen> are the semantics any different?
22:19:21 <Pseudonym> ?src compare
22:19:22 <lambdabot> compare x y | x == y    = EQ
22:19:22 <lambdabot>             | x <= y    = LT
22:19:22 <lambdabot>             | otherwise = GT
22:19:39 <sjanssen> the only potential problem is a non-default definition of max
22:19:46 <sjanssen> max probably shouldn't be in Ord anyway
22:19:52 <Pseudonym> Probably, yes.
22:19:57 <Pseudonym> OK, that makes sense.
22:19:58 <dibblego> ?check \xs f -> map f (xs :: [Int]) == foldr (\x y -> return (f x) `mappend` y) []
22:20:05 <lambdabot>  Couldn't match expected type `[b]'
22:20:09 <Pseudonym> I can imagine faster implementations of max for some types.
22:20:11 <dibblego> ?check \xs f -> map f (xs :: [Int]) == foldr (\x y -> return (f x) `mappend` y) [] xs
22:20:12 <lambdabot>  Add a type signature
22:20:25 <dibblego> ?check \xs f -> map (f :: Int -> Int) (xs :: [Int]) == foldr (\x y -> return (f x) `mappend` y) [] xs
22:20:31 <lambdabot>  OK, passed 500 tests.
22:20:45 <dibblego> MonadZero + Foldable -> Functor?
22:21:19 <sjanssen> isn't Functor a super class of Foldable?
22:21:27 <omnId> @src Foldable
22:21:27 <lambdabot> Source not found. I feel much better now.
22:21:40 <omnId> @source Data.Foldable
22:21:40 <lambdabot> Data.Foldable not available
22:21:42 <dibblego> don't think so
22:21:46 <sjanssen> no, it isn't
22:21:47 <dibblego> class Foldable t where
22:22:20 <sjanssen> dibblego: there are certainly Functors that aren't MonadPlus
22:22:35 <dibblego> yep
22:22:47 <dibblego> it seems I can write that function though, right?
22:23:00 <sjanssen> s/MonadPlus/MonadZero
22:23:57 <dibblego> but this particular Functor is
22:24:12 <dibblego> ?check \xs f -> fmap (f :: Int -> Int) (xs :: [Int]) == foldr (\x y -> return (f x) `mappend` y) [] xs
22:24:15 <lambdabot>  OK, passed 500 tests.
22:24:27 <dibblego> ?check \xs f -> fmap (f :: Int -> Int) (xs :: [Int]) == foldr (\x y -> return (f x) `mappend` y) mzero xs
22:24:29 <lambdabot>  OK, passed 500 tests.
22:24:56 <AshyIsMe> does the Yi editor compile on windows?
22:25:04 <sjanssen> dibblego: this won't always work, see the Monoid instance for Maybe
22:25:06 <AshyIsMe> or rather, does ghc?
22:25:14 <Pseudonym> Ah.
22:25:51 <dibblego> sjanssen, I don't see how it won't always work
22:26:13 <sjanssen> see the Monoid instance for Maybe, it doesn't have this property
22:26:19 <sjanssen> IIRC, Maybe is Foldable
22:26:24 <dibblego> I'm not using a Monoid
22:26:25 <sjanssen> if it isn't, it could be
22:26:32 <sjanssen> dibblego: mappend
22:26:37 <dibblego> gah I am
22:27:03 <dibblego> I will use MonadPlus and MonadOr!
22:27:17 <dibblego> ?check \xs f -> fmap (f :: Int -> Int) (xs :: [Int]) == foldr (\x y -> return (f x) `mplus` y) mzero xs
22:27:20 <lambdabot>  OK, passed 500 tests.
22:27:26 <dibblego> and morelse
22:28:14 <dibblego> http://haskell.org/haskellwiki/MonadPlus_reform_proposal
22:28:16 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
22:28:20 <dibblego> using that
22:45:50 <olsner> hehe, "For instance:" followed by an instance ;-)
23:04:45 <geocalc> quicksilver-> did you post sources ?
23:05:23 <mgsloan> oh no... this project has the same name as my robot simulator.. http://code.google.com/p/raskell/
23:05:24 <lambdabot> Title: raskell - Google Code
23:06:11 <geocalc> try rhaskell
23:07:11 <yrlnry> In Hugs, is there a way to ask for the type of a particular instance of an overloaded operator, say (*), with ":t"
23:08:15 <mgsloan> constrain one of the parameters
23:08:19 <sjanssen> @type (*)
23:08:20 <mgsloan> this will imply an instance
23:08:21 <lambdabot> forall a. (Num a) => a -> a -> a
23:08:39 <sjanssen> yrlnry: the above is all you need to know about *'s type
23:09:15 <sjanssen> for any instance of Num called a, (*) :: a -> a -> a
23:09:22 <mgsloan> oh, /me didn't read the whole question
23:10:06 <yrlnry> I have defined an instance of Num a, called Poly a, and I've defined an overloaded definition of (*) for it.  I want to see if the overloaded definition of (*) at Poly a has the type I( expect.
23:10:28 <mgsloan> if there aren't any compilation errors, then it's the correct type
23:11:07 <omnId> instance Num a => Num (Poly a)?
23:11:27 <yrlnry> omnId: Yes.
23:11:29 <geocalc> :t (poly.*) ?
23:11:31 <lambdabot> parse error (possibly incorrect indentation)
23:11:48 <yrlnry> mgsloan: no, because I might inadvertently have defined it for a subtype of the type I want.
23:12:00 <omnId> pass some Poly Doubles to (*) and see if you get what you expect.
23:12:27 <Pseudonym> Unfortunately, this is where numeric prelude would be handy.
23:12:50 <mgsloan> (*) :: (Num a) => Poly a -> Poly a -> Poly a
23:12:51 <sjanssen> yrlnry: if you've written "instance Num a => Num (Poly a)" then Haskell guarantees the type of (*) you write in that instance body is Poly a -> Poly a -> Poly a
23:12:58 <yrlnry> I want it to be (Poly a) -> (Poly a) -> (Poly a), but it is possible to screw up and get (Poly Integer) -> (Poly Integer) -> (Poly Integer) instead.
23:13:08 <geocalc> :t (poly.*)
23:13:09 <lambdabot> Not in scope: `poly'
23:13:09 <lambdabot>  
23:13:09 <lambdabot> <interactive>:1:5: Not in scope: `.*'
23:13:17 <mgsloan> yeah, haskell's numerics are pretty bad, for a language which claims mathematical basis
23:13:32 <sjanssen> yrlnry: that is not a problem if the instance head is right
23:13:34 <omnId> yrlnry: if the compiler didn't complain that "type of (*) less polymorphic than expected", you're fine.
23:14:09 <yrlnry> That seems not to be the case.
23:14:14 <mgsloan> yeah, all you have to do is look at the instance head, and you know the types of the rest
23:14:14 <yrlnry> I'll paste some code.
23:14:21 <omnId> good idea :)
23:21:56 <hpaste>  yrlnry pasted "Type of Poly.(*) shouldn't be general enough?" at http://hpaste.org/3251
23:23:09 <yrlnry> I don't understand why this even type checks.
23:24:16 <omnId> yrlnry: do you get a runtime error complaining about fromInteger if you try to multiply polys?
23:24:28 <yrlnry> expression (inside2 polyTimes 3 4) should fail, because (inside2 polyTimes) has type Num a => Poly a -> Poly a -> Poly a, and 3 is not a Poly a.
23:24:38 <omnId> 3 = fromInteger 3
23:24:51 <omnId> all numeric literals are polymorphic
23:24:55 <omnId> @type 3
23:25:04 <lambdabot> forall t. (Num t) => t
23:25:07 <yrlnry> Oh!   So 3 *could* be a Poly a!
23:25:23 <omnId> yrlnry: except your Num instance doesn't have a fromInteger
23:25:36 <yrlnry> Sure, but it might once I finished implementing it.
23:25:58 <omnId> so that would be (inside2 polyTimes (fromInteger 3) (fromInteger 4))
23:26:26 <yrlnry> Right, and I do get a runtime error about my failure to implement fromInteger.
23:27:15 <mgsloan> and all the other functions, I'd imagine
23:27:17 <yrlnry> And if fromInteger had type Integer -> Poly a, then this definition would have the fully-polymorphic type.
23:27:20 <sclv> @hoogle toList
23:27:21 <lambdabot> Data.HashTable.toList :: HashTable key val -> IO [(key, val)]
23:27:21 <lambdabot> Data.IntMap.toList :: IntMap a -> [(Key, a)]
23:27:21 <lambdabot> Data.IntSet.toList :: IntSet -> [Int]
23:27:28 <omnId> @type fromInteger
23:27:30 <lambdabot> forall a. (Num a) => Integer -> a
23:27:32 <yrlnry> Thanks, all.
23:27:37 <omnId> indeed that is one of its possible types :)
23:28:00 <omnId> and the one that will get chosen to unify with polyTimes' type.
23:28:17 <omnId> (inside2 rather)
23:28:47 <yrlnry> Oh, I had one other question.  It seemed to me that this doofus thing I'm doing with inside2 would be better done by making Poly an instance of Monad, so that instead of inside2 I would use monad operators.  Does that make sense?  If so, does it seem correct?
23:29:01 <omnId> Functor
23:29:13 <omnId> @type fmap
23:29:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:29:41 <omnId> er, no
23:29:50 <omnId> that's liftM2, not just fmap
23:30:15 <omnId> (a -> b -> c) -> Poly a -> Poly b -> Poly c
23:31:00 <geocalc> :t liftM2
23:31:02 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:31:40 <omnId> I'm not sure it'd fit into Monad.  Monad's (>>=) requires that the kleisli operate on the component type, not (as in this case) a *list* of the component type.
23:32:04 <omnId> does :t inside2 give ([a] -> [b] -> [c]) -> Poly a -> Poly b -> Poly c?
23:32:11 <yrlnry> In my case the component type is a list.
23:32:27 <omnId> yrlnry: component as in the argument to the Poly type
23:32:34 <omnId> i.e. just 'a'
23:33:11 <yrlnry> inside2 :: ([a] -> [b] -> [c]) -> Poly a -> Poly b -> Poly c
23:33:21 <omnId> if Poly were a monad, Poly a an action of the Poly monad, then bind must take just a, not [a].
23:33:37 <yrlnry> Hm.
23:34:05 <roconnor> presumably all analytic functions are conformal maps of the complex plane?
23:34:39 <omnId> @type (>>=)
23:34:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:35:58 <geocalc> btw a list is one element
23:36:12 <omnId> geocalc: hm?
23:36:32 <geocalc> no ?
23:36:42 <omnId> I don't understand your assertion.
23:36:52 <omnId> the list type is a monad?
23:37:35 <roconnor> Cale: first time I ever got a useful answer from #math
23:38:11 <geocalc> is there a list monad ?
23:38:21 <omnId> @src [] return
23:38:21 <lambdabot> return x    = [x]
23:38:24 <omnId> @src [] (>>=)
23:38:25 <lambdabot> m >>= k     = foldr ((++) . k) [] m
23:38:29 <omnId> == concatMap
23:38:42 <Cale> roconnor: hehe
23:38:44 <roconnor> flip concatMat
23:38:51 <Cale> geocalc: absolutely, yes
23:39:07 <omnId> roconnor: there was an implicit (modulo argument order) there. :)
23:39:10 <Cale> > [1,2,3] >>= \x -> [x,x*10]
23:39:11 <lambdabot>  [1,10,2,20,3,30]
23:39:30 <Cale> xs >>= f = concat (map f xs)
23:39:35 <Cale> return x = [x]
23:39:46 <roconnor> http://arcanux.org/lambdacats/concatMap.jpg
23:39:54 <geocalc> eheh
23:40:04 <Cale> Yeah, I saw that :)
23:40:14 <Cale> Mine isn't up on that site yet
23:41:24 <Cale> http://cale.yi.org/autoshare/coequaliser.jpg http://cale.yi.org/autoshare/hasmonad.jpg
23:42:12 <omnId> yrlnry: Poly may still have a sensible Monad instance, but bind wouldn't look like inside2
23:42:31 <yrlnry> Cale: the coequalizer thing made me laugh.
23:43:13 <yrlnry> omnId: no, but I wasn't expecting it to.
23:43:30 <yrlnry> but I could define some monad lifting operator that would be like inside2.
23:45:13 <omnId> yrlnry: can you think of a sensible join :: Poly (Poly a) -> Poly a?
23:45:38 <Cale> omnId: Is Poly some kind of polynomial representation?
23:45:53 <omnId> http://hpaste.org/3251
23:46:08 <omnId> data Poly a = P [a]
23:46:51 <yrlnry> omnId: Hmm.  I'm not sure.  Maybe.
23:47:31 <omnId> polySum looks like zipWith (+), except that it keeps leftovers
23:47:49 <yrlnry> The missing coefficients are assumed to be 0.
23:48:04 <yrlnry> It is a representation of polynomials over a.
23:48:25 <omnId> gotcha
23:48:34 <yrlnry> My boss asked me to calculate the coefficient of the x^59 term of p^2, where p is (1 + x + 2x^2 + 5x^3 + 14x^14...)
23:48:52 <Cale> Is the transformation R[x][y] -> R[x] by sending y to x natural?
23:48:56 <yrlnry> This is very easy to do manually, but I thought it would be fun to write the code in Haskell anyway.
23:49:46 <yrlnry> I have Perl code for this somewhere, but I thought it might be easier to write in Haskell than to dig up the Perl code.
23:50:42 <Cale> er, yes, of course
23:50:48 <mgsloan> I'm pretty sure someone's written some nice poly code before
23:50:58 <mgsloan> perhaps part of the numeric prelude
23:51:34 <yrlnry> The point is not to have it, but to *write* it.  To goal here is no longer calculating with polynomials, but to get better at Haskell.
23:51:50 <Pseudonym> Exactly.
23:51:57 <Cale> yrlnry: I found monoid rings to be a nice way to set all that up
23:52:13 <yrlnry> My first cut at it had    (P (a:as)) + (P (b:bs)) = (a+b) : ((P as) + (P bs))  .  That is not too bad.
23:52:20 <Cale> So then you get polynomial rings by using the natural numbers under addition for your monoid :)
23:52:20 <Pseudonym> Although in this case, surely it'd be easier not to compute the whole polynomial.
23:52:31 <Pseudonym> If you just want the x^59 term.
23:52:36 <yrlnry> But when I tried to write the definition of multiplication it started to suck.
23:52:58 <yrlnry> Every time I wanted to do a list operation I had to remove the P and then put it back again afterward.
23:53:18 <Pseudonym> yrlnry: P as + P bs = P (add as bs)
23:53:27 <Pseudonym> where add ... ... = ...
23:53:43 <yrlnry> That's what I ended up doing.
23:54:04 <dataangel> I'm reading the wikibook -- why is it that if you use 'let' inside a do block, then you don't have to worry about the rhs function taking an a instead of an IO a? Does it implicitly wrap the rhs in a return()?
23:54:40 <yrlnry> Cale: I'm not sure what you mean when you suggest using monoid rings.
23:54:49 <omnId> dataangel: a let expression is just subexpression renaming in the context of a larger expression.
23:55:55 <omnId> dataangel: those subexpressions can have any type, so long as the whole expression (the part in the 'in' clause, which is implied in do blocks) is correct for its context.
23:56:05 <mgsloan> a let causes the rest of the do expression to be wrapped in a lambda, I think
23:56:06 <therp> dataangel: I don't think so. do { a <- b; let c=a; d; } just changes the desugaring to add a let binding block such as in: b >>= (\a -> let { c = a } in d}
23:56:12 <Cale> newtype MonoidRing n a = MonR (Map a n) deriving (Eq, Ord)
23:56:26 <Cale> instance (Ord a, Show a, Num n, Monoid a) => Num (MonoidRing n a)
23:56:37 <mgsloan> or I guess let ... in ... works too
23:57:42 <omnId> do { let <decls> ; <stmts> } = let <decls> in do { <stmts> }
23:57:51 <hpaste>  Cale pasted "Monoid rings." at http://hpaste.org/3252
23:57:51 <dataangel> omnId: I understand that generally, but specifically in the context of do blocks, let makes it so you ... oic :P let isn't doing anything special, it's just that it's not the <- arrow, which expects an IO a on the rhs.
23:58:04 <yrlnry> Cale: What does "Map" mean there?
23:58:21 <Cale> yrlnry: Data.Map is an implementation of finite maps
23:58:30 <omnId> dataangel: pretty much, yeah.
23:58:53 <mgsloan> (->) is an implementation of infinite maps, I suppose :)
23:59:15 <Cale> Er, that's odd, somehow all the imports got deleted from this module
23:59:17 <omnId> (though technically bindings with '<-' can expect an action of any monad, whichever is inferred for the block)
23:59:34 <yrlnry> Cale: OK, I think I see vaguely what is going on there.
23:59:50 <omnId> dataangel: do you understand the desugaring I gave there?
