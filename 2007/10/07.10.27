00:07:42 <bparkis> Suppose that instead of having a finite state machine, a Turing-like machine has a function from A^n to {A^n union {left, right, finish}} where A is your alphabet, and n depends on the function you want to compute
00:08:53 <bparkis> at each step it looks at a contiguous block of n symbols on the tape, evalutes its function on those symbols, and outputs onto that block the result of the function and moves the "viewing block" left, right, or declares it is done accordingly
00:09:02 <bparkis> is that Turing complete?
00:10:37 <Cale> bparkis: Does it continue to move in the direction that it last moved in after each step?
00:10:55 <bparkis> i hadn't imagined that it does, i don't think it matters
00:11:12 <bparkis> i was thinking it would either output a block of numbers or move left, right, or finish, actually, not do both at once
00:11:27 <Cale> ah, all right
00:11:42 <Cale> When the viewing block moves, does it move by n spaces?
00:12:06 <bparkis> by 1 space, if it moved by n spaces then it obviously wouldn't be turing complete
00:12:11 <Cale> oh?
00:12:26 <bparkis> because in that case it would reduce to a turing machine with 1 state and an alphabet of size A^n
00:13:01 <Cale> Couldn't you use one symbol in the alphabet to signal to yourself that you wanted to move left or right on the next step?
00:13:16 <Cale> (Say written at the leftmost position in the block)
00:14:02 <bparkis> you could but you would have no memory of where you came from
00:14:15 <Cale> Ah, I see.
00:14:37 <Cale> hmm, it's possible this could work out
00:14:41 <bparkis> if you did that you would know where you wanted to go when you next returned, independent of whatever you did in btween then
00:14:50 <Cale> Especially if the alphabet is allowed to be specified.
00:15:35 <bparkis> you can specify n so you can give yourself a bigger alphabet effectively by increasing n
00:15:43 <Cale> right, okay
00:15:45 <bparkis> you know, using 2 spaces for each 1 symbol
00:15:50 <Cale> yes, of course
00:16:11 <Cale> Yeah, I'm pretty convinced that'll be Turing complete.
00:17:00 <Cale> You can use symbols in your alphabet to denote the states of the original Turing machine.
00:17:09 <bparkis> yeah that works
00:18:25 <bparkis> you would put the Turing machine representation in the center of your viewing block, and move it every time you moved, and you could 'teleport' symbols across it
00:21:05 <Cale> hmm, I was thinking of putting more data into the transition function than that, but that works rather nicely as well.
00:29:06 <bparkis> this would correspond loosely to a pattern matching function with 2 stacks/lists and a buffer type of size n, such as Buffer a a a a a a a for the case n = 7
00:30:06 <bparkis> the 2 stacks/lists representing the tape on either side of your viewing block, and the buffer representing the state of the tape in your viewing block
00:31:44 <bparkis> ViewingBlockMachine :: [a] -> [a] -> Buf a -> Buf a where Buf a = Buffer a a ... a
00:33:36 <wli> What about ends of the tape or short tapes where there's not enough to fill the buffer?
00:33:51 <bparkis> infinite tape
00:34:06 <atom> hi everyone.
00:34:33 <atom> got a n00b q: why is this syntax wrong? "sqeq        :: Float -> Float -> Float -> (Complex, Complex)"
00:34:39 <wli> Infinite capacity, but its contents may not be infinite (or not infinite in both directions).
00:35:22 <atom> hugs says Illegal type "(Complex,Complex)" in constructor application
00:35:44 <atom> all I want is to return a Complex tuple...
00:35:48 <wli> Complex has the wrong kind.
00:35:56 <wli> Try Complex Double
00:36:03 <wli> @kind Complex
00:36:05 <lambdabot> * -> *
00:36:23 <atom> oh... So complex needs a type argument? Haven't thought of that...
00:36:28 <bparkis> well i don't know, i guess it would be initialized to some symbol, if the tape had an end on one side you could do the same trick as with normal turing machines of moving everything over to the right when you need to move left
00:37:26 <wli> Okay, so you use a blank symbol instead of a buffer state.
00:40:40 <bparkis> i wonder if i should suggest this to somebody as an exercise to a textbook
00:40:46 <atom> another thing. When I tried the Complex Float type, I started getting errors in unrelated code that just weren't there before. Right now, it's saying this:
00:41:05 <atom> 12 sqeqDet         :: Float -> Float -> Float -> Float
00:41:05 <atom> 13 sqeqDet a b c   = (b*b - 4*a*c)
00:41:18 <atom> ERROR "tryouts.hs":13 - Ambiguous variable occurrence "*"
00:41:18 <atom> *** Could refer to: Main.* Hugs.Prelude.*
00:41:30 <atom> What am I doing wrong?
00:41:39 * wli isn't sure.
00:41:50 <newsham> âˆƒï¼¬âˆŠâˆ€âŠ¤
00:42:26 <birkenfeld> have you defined a "*" operator yourself?
00:42:34 * wli sees that it works here.
00:43:06 <atom> birkenfeld: good point. I tried to, well, overload it for my own data Sign = Negative | Positive type
00:43:41 <birkenfeld> ok... you have to do that in an "instance Num Sign" block
00:43:49 * wli expects that may have been done wrongly.
00:44:16 <atom> wli: probably, yes. I haven't been studying haskell for more than a few hours...
00:44:34 <atom> birkenfeld: um... wait till I look that block thing up :)
00:45:05 <birkenfeld> basically, you use the same "*" operator, but add a prescription to it how to handle the Sign type
00:45:46 <atom> birkenfeld: yeah, but I need to look up the syntax, and... well... "tour of haskell syntax" doesn't have anything on that instance block
00:47:03 <atom> google yields pretty useless results, at least useless for my understanding of the subject, so I guess I'll have to go to the report...
00:47:15 <birkenfeld> for example:
00:47:18 <birkenfeld> instance Num Sign where
00:47:24 <birkenfeld>   a * b = <whatever>
00:47:38 <omnId> @src Num
00:47:38 <lambdabot> class  (Eq a, Show a) => Num a  where
00:47:38 <lambdabot>     (+), (-), (*)           :: a -> a -> a
00:47:38 <lambdabot>     negate, abs, signum     :: a -> a
00:47:38 <lambdabot>     fromInteger             :: Integer -> a
00:47:49 <birkenfeld> look in the docs for Num to know which functions you have to define
00:48:07 <omnId> you should provide all of those except just one of negate and (-), I think.
00:50:45 <atom> ok...
00:50:52 <shubalub> @list
00:50:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
01:00:59 <atom> ok... Can someone explain to me how this should be done? I basically just need a type that can only have two values: Positive and Negative. Adding it does not make sence, so + should not be defined on it. Multiplication and unary negation make sence, so these should be implemented (Internally -  between Sign values, and also externally - so you can multiply other numeric types with them)
01:02:09 <atom> and I'm really at a loss as to how to do that - I fear the answer will be so strikingly simple that I just couldn't think of it :).
01:02:54 <birkenfeld> for the +, you can do
01:03:02 <birkenfeld> a + b = error "Sign can't be added"
01:03:23 <birkenfeld> (*) has type Num a => a -> a -> a
01:03:32 <birkenfeld> so it can only take two arguments of the same type
01:04:19 <DRMacIver> Morning
01:04:54 <atom> birkenfeld: um... it can take any number belonging to the Num class right? Sign also belongs to that same class... or should
01:05:33 <omnId> atom: since it uses the 'a' type variable in both places, the type of both arguments must be the same.
01:05:55 <birkenfeld> otherwise it would be (Num a, Num b) -> a -> b -> (something)
01:06:03 <atom> oh, ok.
01:06:07 <birkenfeld> or (Num a, Num b, Num c) => a -> b -> c
01:06:27 <atom> so I can't add Ints and Floats?
01:06:30 <atom> that's weird
01:06:34 <TSC> Not with (+)
01:06:42 <omnId> use conversion
01:07:00 <omnId> > fromIntegral (1 :: Int) + (1 :: Float)
01:07:02 <lambdabot>  2.0
01:07:26 <omnId> > (1 :: Int) + (1 :: Float) -- type error
01:07:27 <sjanssen> atom: in that way we neatly sidestep the complicated rules other languages have with mixed operands
01:07:27 <lambdabot>  Couldn't match expected type `Int' against inferred type `Float'
01:08:03 <atom> sjanssen: true...
01:08:50 <atom> so I should make a conversion function that casts my Sign to float and everything should work fine?
01:09:24 <omnId> maybe use should just use signum.
01:09:41 <omnId> maybe you*
01:10:12 <atom> what does that do? return 1/-1 depending on the sign of the number?
01:10:24 <omnId> > map signum [-10, -5, 0, 12]
01:10:25 <lambdabot>  [-1,-1,0,1]
01:10:30 <atom> nice
01:10:49 <omnId> > signum (2 :+ 3 :: Complex Double)
01:10:50 <lambdabot>  0.5547001962252291 :+ 0.8320502943378437
01:11:15 <omnId> > let x = 2 :+ 3 in signum x * abs x
01:11:16 <lambdabot>  2.0 :+ 3.0
01:11:56 <atom> abs signum (2 :+ 3 :: Complex Double)
01:11:58 <atom> > abs signum (2 :+ 3 :: Complex Double)
01:11:59 <lambdabot>        add an instance declaration for
01:11:59 <lambdabot>       (Num (Complex Double -> Complex ...
01:12:07 <omnId> parens
01:12:17 <omnId> > abs (signum (2 :+ 3))
01:12:19 <lambdabot>  1.0 :+ 0.0
01:12:35 <atom> oh. ok.
01:12:36 <birkenfeld> hm
01:12:42 <atom> thought so
01:12:42 <profmakx> signum of a complex number o.O
01:12:49 <birkenfeld> has the signum of Complex any good interpretation?
01:13:01 <omnId> the unit vector in the direction of x.
01:13:09 <birkenfeld> ok, right
01:13:15 <birkenfeld> handy actually
01:13:17 <omnId> abs is the euclidean distance from zero.
01:13:47 <birkenfeld> > signum (0 :+ 0)
01:13:48 <lambdabot>  0.0 :+ 0.0
01:14:04 <omnId> that's the odd case :)
01:14:11 <sorear> no more odd than
01:14:14 <sorear> > signum 0
01:14:15 <lambdabot>  0
01:14:18 <omnId> right
01:14:20 <birkenfeld> > exp (pi * (0 :+ 1))
01:14:21 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
01:14:34 <birkenfeld> ok, almost :)
01:14:36 <omnId> IEEE--
01:15:08 <birkenfeld> for that, a pi-ary number system would be good :)
01:15:32 <atom> birkenfeld: just make Pi unit length :)
01:16:10 <wli> Try Knuth's high school science project.
01:16:29 <birkenfeld> which does what?
01:16:50 <wli> Base 2i or some such.
01:18:24 <birkenfeld> Data.Complex should really define i :: RealFloat a => Complex a
01:19:05 <omnId> > let i = 0:+1 in 2 + 3*i
01:19:07 <lambdabot>  2.0 :+ 3.0
01:19:32 <atom> um... what does this mean? Haskell 98 does not support pattern type annotations
01:19:34 <newsham> let j = (0-i)
01:20:09 <omnId> atom: move the type annotations to a signature by itself, instead of on the left-hand-side of your function.
01:20:30 <omnId> > let f (x :: Int) = x + 1 in f 2 -- this is an extension.
01:20:30 <lambdabot>  Parse error in pattern at "in" (column 26)
01:20:50 <omnId> > let f x = x + 1; f :: Int -> Int in f 2 -- the standard way
01:20:52 <lambdabot>  3
01:21:20 <omnId> the 'x' on the lhs is called a pattern.
01:22:05 <birkenfeld> omnId: I know that it's trivial, but nevertheless handy
01:22:22 <omnId> birkenfeld: I didn't disagree :)
01:23:02 <omnId> atom: what tuts have you read?
01:23:22 <atom> omnId: haskell for C programmers, mostly
01:23:33 <omnId> @where yaht
01:23:33 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
01:23:39 <omnId> ^ this is usually recommended
01:23:43 <atom> i gave "a gentle introduction to haskell" a try
01:23:51 <omnId> atom: that's more for MLers :)
01:24:54 <atom> omnId: my real problem is that I can't think in haskell... If you've programmed in procedural/imperative languages from your 6th grade of primary school, your brain is wired in a certain way
01:25:29 <atom> omnId: this is even more of a problem since I haven't absorbed all of the syntax yet, and so I'm just feeling my way around
01:25:34 <omnId> atom:  :D  If programmed just as long, and it was indeed quite painful, but it's a *good* pain, trust me :)
01:25:38 <omnId> I've
01:25:39 <omnId> *
01:26:07 * wli is a kernel programmer.
01:26:16 <atom> omnId: that's why I'm learning... :)
01:26:29 * wli isn't the most stellar example of a Haskell programmer, though.
01:27:18 <Cale> atom: The "Gentle" intro is only gentle if you already know ML or something.
01:27:37 <atom> omnId: I found my error though, I must have deleted the 1st line of the funcdef somehow
01:27:48 <atom> and haven't noticed it
01:27:58 <Cale> I think it would have to win for the "Most Inappropriately Titled Haskell Tutorial"
01:28:00 <atom> Cale: that's what I found out shortly after starting to read it
01:28:16 <omnId> atom: the best advice I have is to stick around here and ask tons of questions :)
01:28:20 <newsham> the "gentle" intro is about as "gentle" as "honest joe's car sales" is "honest"
01:28:23 <newsham> ie.. if you have to say it....
01:28:31 <atom> haskell for C programmers is ok though...
01:28:39 <Philippa> the "gentle" intro was from a time when it could be reasonably assumed that anyone interested in Haskell was already a functional programmer
01:28:48 * wli ponders a "Rough Guide to Haskell."
01:28:48 <atom> omnId: that I also figured out :). If only you guys can bear with me :)
01:29:43 <atom> does wli only talk about himself in the 3rd person?
01:30:07 <wli> No. I use the third person when using /describe
01:30:10 <omnId> Oh, no, he's been thouroughly long-winded :)
01:30:27 <Cale> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
01:30:27 <lambdabot> Title: Tour of the Haskell Syntax
01:30:37 <Cale> That might be helpful
01:30:39 <atom> Cale: i've got that open as well
01:30:40 <wli> It would be grammatically incorrect to refer to myself by name via describe and then in the first person afterward in the same sentence.
01:31:20 <atom> wli: I just thought you never talk the <nick> way :)
01:32:07 <atom> Cale: found it quite useful, only a bit brief...
01:32:17 <atom> Cale: so i've got the Report open as well :)
01:32:53 <Cale> The Report is actually really good if you can manage it.
01:32:59 <omnId> atom: the specification of the Prelude is good to look through.
01:33:10 <Philippa> The Report's definitely useful for checking stuff
01:33:24 <Philippa> for example, if you want to be really sure about the layout rule
01:33:34 <omnId> @where report
01:33:34 <lambdabot> http://www.haskell.org/onlinereport/
01:33:57 * omnId ponders changing that to the expanded index.  It's easier to find-in-page when you have the whole thing.
01:34:22 <atom> Philippa: you have an uncanny knack for stating the exact problem I'm having right now :)
01:35:52 <omnId> tabs are generally discouraged, spaces are more predictable.
01:36:18 <wli> I always use tabs.
01:36:31 <wli> Then again, I always use nvi-1.79
01:36:53 <Cale> I think tabs should be considered lexical errors.
01:37:22 <wli> I'll fork ghc if you try to pull anything like that.
01:37:48 <omnId> generally, the first token after a layout-introducing keyword (do, let, where) sets a rigid column.  Any other token appearing on that column in subsequent lines inserts a semi.
01:37:51 <Cale> I'll help you write a program to convert your tabs to spaces ;)
01:38:04 <newsham> the lsat person who fork()'d ghc had his processes HUP'd
01:38:26 <omnId> any token to the left of that column ends the layout group.
01:38:29 <atom> omnId: actually, i'm trying to define a function with guards (|)
01:38:47 <omnId> guards don't introduce any layout.
01:38:56 <Cale> The general rule of indentation is to line up the things which are at the same level of structure
01:39:08 <Cale> You still ought to line up guards though
01:39:15 <omnId> yeah
01:39:19 <atom> omnId: yeah, but still, i'm getting Syntax error in declaration (unexpected `;', possibly due to bad layout)
01:39:41 <omnId> atom: if you put the (|) at the same column as the function name, you get the semi :)
01:39:45 <Cale> atom: paste the code and I'll have a look
01:40:09 <Cale> Oh, also, things which are inside other things should be indented more.
01:40:11 <atom> @where rafb
01:40:11 <lambdabot> http://rafb.net/paste
01:40:19 <Cale> !paste
01:40:19 <hpaste> Haskell paste bin: http://hpaste.org/
01:40:40 <Cale> (either one, but the haskell paste bin announces automatically)
01:41:44 * omnId waits to race Cale for the correct answer when he pastes.
01:41:54 <hpaste>  atom pasted "noobish stuff" at http://hpaste.org/3488
01:42:02 <omnId> off we go!
01:42:21 <atom> omnId: thanks
01:43:18 <omnId> Complex needs a type param, for one
01:43:29 <omnId> (in sqeqX's sig)
01:43:48 <atom> omnId: thought so, but it didn't throw any errors, so I just... :)
01:44:03 <atom> done
01:44:16 <atom> the syntax error's still there
01:44:37 <omnId> delete the params in the same sig.
01:44:51 <omnId> signatures don't include function parameters
01:45:07 <omnId> that should get the parse error
01:45:30 <atom> omnId: done that. Good spot.
01:45:52 <atom> omnId: another error on the next line: Ambiguous use of operator "(+)" with "(:+)"
01:46:09 <newsham> use parenthesis to tell it what you mean?
01:46:59 <atom> newsham: already done. Thought it would solve it. Thanks for the tip though.
01:47:24 <omnId> atom: sqeqDet takes three params, but the parens effectively pass b and c into a as though it were a function.
01:48:27 <atom> omnId: so, delete the parantheses there?
01:48:46 <omnId> sqeqDet(a b c) -> sqeqDet a b c
01:50:29 <omnId> > let f x = x * 2 in f -1 -- surround negatives in parens, otherwise it thinks you're subtracting from functions.
01:50:30 <lambdabot>   add an instance declaration for (Num (a -> a))
01:50:31 <lambdabot>     In the expression: let f...
01:50:40 <omnId> > let f x = x * 2 in f (-1)
01:50:41 <lambdabot>  -2
01:52:11 <atom> omnId: ok, fixed about 4 or 5 further errors with the code, it's now significantly different...
01:54:53 <omnId> atom: add an annotation
01:55:03 <atom> that being...
01:55:38 <omnId> click the annotate link on the paste page and paste the updates.
01:55:46 <atom> oh, that :)
01:57:11 <hpaste>  atom annotated "noobish stuff" with "noobish stuff mark 2" at http://hpaste.org/3488#a1
01:57:48 <omnId> atom: the sqeqDet call in the first guard needs arguments.
01:58:13 <atom> how the hell did that happen? :)O
01:58:21 <omnId> nice mustache
01:58:33 <atom> isn't it?
01:58:50 <omnId> you could add a 'where det = sqeqDet a b c' clause after the last guard clause and use 'det' where you're using 'sqeqDet a b c'
01:59:31 <omnId> a where clause scope over all guards in a group.
02:00:34 <omnId> remember to add parens around the -1 in the 'sqeq'.
02:00:54 <atom> thanks
02:00:56 <omnId> naturals = [1..], btw :P
02:01:42 <atom> yay! compiles
02:01:56 <omnId> *high-five*
02:02:02 <atom> omnId: the naturals was a tryout in list comprehensions :)
02:02:23 <omnId> > fix ((1:) . map (+1))
02:02:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
02:02:44 <atom> fix?
02:02:48 <omnId> magic
02:03:01 <omnId> fix f = x where x = f x
02:03:38 <omnId> let x = ((1:) . map (+1)) x in x
02:03:48 <omnId> let x = 1 : (map (+1) x) in x
02:04:24 <atom> this kind of reminds me of perl's "there's more than one way to do it" :)
02:04:33 <omnId> oh lord
02:04:46 <omnId> tim toady has his work cut out for him in Haskell.
02:05:34 <omnId> you often see on-the-spot compititions to produce as many of the most obscure ways to do things here.
02:05:57 <atom> lol
02:06:05 <omnId> > cycle "lo"
02:06:07 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
02:06:23 <wli> > take 10 $ fix ((0:) . (1:) . join (zipWith (+) . tail))
02:06:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
02:06:40 <omnId> > map toUpper $ "argh!" >>= replicate 8
02:06:42 <lambdabot>  "AAAAAAAARRRRRRRRGGGGGGGGHHHHHHHH!!!!!!!!"
02:06:49 <atom> k, gtg...
02:07:19 <atom> got a house to clean up
02:07:20 <atom> :)
02:07:31 <omnId> see you later
02:07:37 <atom> definitely. and thanks.
02:07:56 <cizra> Is there a list function similar to tail, which takes 2 arguments, list and how many to drop?
02:08:10 <wli> drop
02:08:15 <cizra> Thanks.
02:08:46 <cizra> Just what I needed.
02:11:14 <hpaste>  omnId annotated "noobish stuff" with "(no title)" at http://hpaste.org/3488#a2
02:11:52 <wli> > let facs = 1 : scanl1 (*) [1..] ; eInvPSums = map numerator . drop 2 . zipWith (*) facs . scanl1 (+) . zipWith ($) (cycle [id, negate]) $ map recip facs in take 10 eInvPSums
02:11:54 <lambdabot>  [1,2,9,44,265,1854,14833,133496,1334961,14684570]
02:12:55 <Syzygy-> wli: Aaaaaaand what's that's actually computing?
02:13:19 <wli> Syzygy-: Derangements of n distinct letters for n <- [1..]
02:13:23 <Syzygy-> Ah.
02:13:36 <wli> Syzygy-: Or the number thereof.
02:14:37 <wli> Syzygy-: When the letters aren't distinct and you want the corresponding permutations also, see http://hpaste.org/3363#a2
02:14:58 <Syzygy-> Ok
02:17:51 <wli> It was more of a whiz-bang sort of thing for the newbies.
02:22:09 <ivanm> @protontorpedo
02:22:09 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
02:22:17 <ivanm> ^^ I think lambdabot is dead again :s
02:22:34 <wli> I don't understand why the random bits are so hard.
02:26:36 <sjanssen> wli: it isn't hard, really
02:26:39 <omnId> 02:14 <sor!ear> @tell do!ns Lambdabot's failing is due to twanvl's refactoring of random to make the core pure.  It returns an error, which getStdRandom obligingly sets as the new seed.  All future attemptts to acces the RNG fail.  (This insight brought to you by Spencer Janssen)
02:26:45 <omnId> (names have been mangled to avoid unneccessary pinging)
02:27:05 <sjanssen> some plugin is sticking a _|_ in the generator
02:27:08 <wli> Yeah, I remember.
02:27:29 <sjanssen> it'll be fixed whenever dons applies the patches
02:27:36 <omnId> sjanssen: that only happens after the first call to getRandItem with a nil, right?
02:27:44 <sjanssen> omnId: correct
02:30:06 <wli> I guess I now have to figure out what to do at the module level now that I've got data structures for terms laid out.
02:30:24 <omnId> getStdRandom [] g = (error "...", g) -- would fix it I gather?
02:30:39 <sjanssen> omnId: yes
02:30:57 <omnId> er, getRandItem, not getStdRandom
02:37:03 <allbery_b> omnId: you failed to whack tw!anvl... :)
02:37:21 <omnId> I did, thankfully he's not here.
02:44:36 <wli> I don't have the foggiest idea of what I should even try at the module level.
02:45:54 <wli> Any suggestions?
02:46:47 <hpaste>  loki pasted "parse errors" at http://hpaste.org/3489
02:47:05 <lokimaf_> hey i got some parse errors in that code snipet at putStrLn
02:47:45 <omnId> lokimaf_: forgot the 'do'
02:47:50 <lokimaf_> thanks :)
02:56:57 <Cale> wli: Um, I don't understand your question?
03:06:07 <scriptdevil> can anybody explain why -1 doesnt match a pattern (x+1).. since it can be represented by (-2) + 1. So x must be -2
03:07:48 <laziest> the standard says this
03:09:33 <wli> Cale: I'm trying to implement a module system for a toy language to learn more about module systems.
03:09:46 <scriptdevil> laziest: well. so .. it is the rule of thumb.. and we need not waste time understanding why, right??
03:10:13 <laziest> well, I don't know more details regarding the motivation behind the restriction...
03:10:18 <wli> Cale: Trick is that I'm not even sure where to start on a module system. There aren't walkthroughs like for term languages.
03:10:25 <sjanssen> scriptdevil: n+k patterns are widely regarded as a warty part of the language
03:10:51 <laziest> but must be the usual convention that n+k patterns are used in 'induction' kind of activities, which stop at 1 or 0, don't go below that...
03:11:02 <laziest> but this is my guess..
03:11:04 <wli> Remind me again why they're considered bad?
03:11:32 <sjanssen> wli: well, most language's modules are simple namespace control, I suppose you're implementing something more interesting?
03:12:23 <wli> sjanssen: No. I just don't understand all the typing rules, recursive module issues, parametrized higher-order module issues, etc.
03:12:28 <Cale> Matching an n+k pattern against a value x succeeds if x >= k, resulting in the binding of n to x - k, and fails otherwise.
03:12:45 <Cale> The reason is that n+k patterns are really only there to simulate naturals.
03:13:11 <scriptdevil> sjanssen: yeah.. i was half expecting a stack error..on the contrary.. i write a prog that matches with -2 and 0 directly. the third is an n + 1 . when i give -1, i should expect that it terminates. but it gives an error
03:13:26 <wli> I don't want to rehash the debate so I'll let the answer stand otherwise uncommented on.
03:14:03 <Philippa> wli: the chapter in ATTaPL isn't a walkthrough per se, but shouldn't be too hard to get an implementation rolling from
03:14:13 <sjanssen> wli: n+k patterns have some weird consequences for the parser, they perform silent computation (which isn't true for other types of patterns), they should be part of a more general mechanism (like views)
03:15:00 * wli checks the budget and guesstimates that mid-November at earliest is when he can book-shop due to a rather severe budget crisis.
03:15:25 <scriptdevil> ok.. Cale .thanks . that was a neat summary. they exist for naturals. and we must not force it to do anything outside its domain. i will keep that in mind
03:16:19 <Cale> scriptdevil: Really, they're probably best avoided altogether
03:16:32 <Cale> Just match n and subtract later.
03:16:46 <scriptdevil> is there an unsigned int type in haskell?
03:16:57 <sjanssen> scriptdevil: yep, in Data.Word
03:17:01 <scriptdevil> ok
03:17:38 <scriptdevil> Data.Word... err.. that seems to be qualified..  will it work directly in hugs?
03:17:50 <wli> http://holomorphy.com/~wli/Natural.lhs
03:17:55 <sjanssen> you probably need to :load Data.Word first
03:17:56 <Cale> yeah, hugs supports the hierarchical modules
03:18:03 <scriptdevil> sjanssen: ok.
03:18:18 <Cale> ah, that's what you were asking about :)
03:18:24 <sjanssen> (is it :load?, I don't use Hugs often)
03:18:43 <sjanssen> scriptdevil: once you've got Data.Word in scope, the type is just called 'Word'
03:18:47 <Cale> :also ?
03:19:19 <Cale> yeah :also appears to be Hugs' version of :m+
03:21:02 <Cale> hmm, except that trying to have multiple modules in scope at the hugs commandline at the same time seems tricky/impossible
03:21:37 <scriptdevil> Cale: i imported it in a .hs file and then did a :load myFile.hs
03:22:57 <Cale> That should work :)
03:23:08 <scriptdevil> that did.. useful trick. :D
03:23:26 * wli ponders what to do for the next couple of weeks.
03:23:47 <hpaste>  atom annotated "noobish stuff" with "compiles, but doesn't work" at http://hpaste.org/3488#a3
03:24:24 <scriptdevil> i am watching that video tutorial from that german lecturer JÃ¼rgen Giesl... luckily it is in english. :)
03:24:26 <atom> anyone want to take a look at that?
03:25:03 <wli> atom: You're trying to solve a quadratic equation?
03:25:07 <birkenfeld> scriptdevil: do you have an URL?
03:25:09 <Cale> atom: I just get some complex NaN's
03:25:21 <atom> wli: yes
03:25:23 <Cale> I might know what's going on...
03:25:49 <atom> wli: don't suggest a module, i'm doing it to learn haskell, not learn libraries :)
03:26:23 <wli> Not at all.
03:26:58 <atom> Cale: um... care to share it with me?
03:27:14 <Cale> ah, yeah, I see
03:27:16 <laziest> do you mean sqrt (-det) in the 'otherwise' part?
03:27:21 <Cale> You're converting to complex too late
03:27:32 <atom> laziest: um... probably.
03:27:34 <Cale> The sqrt is the Float sqrt
03:27:41 <Cale> not the Complex Float one
03:28:27 <atom> Cale: laziest was right
03:28:42 <Cale> er, that too
03:28:51 <Cale> But you wouldn't need the cases if you did the conversion early.
03:29:06 <atom> Cale: the complex sqrt probably returns a tuple
03:29:12 <atom> Cale: I'm trying to do that by hand
03:29:26 <Cale> > sqrt (0 :+ 1)
03:29:28 <lambdabot>  0.7071067811865476 :+ 0.7071067811865475
03:29:36 <Cale> > sqrt (-1 :+ 0)
03:29:36 <lambdabot>      precedence parsing error
03:29:37 <lambdabot>         cannot mix prefix `-' [infixl 6] and `(...
03:29:41 <Cale> > sqrt ((-1) :+ 0)
03:29:42 <lambdabot>  0.0 :+ 1.0
03:31:17 <atom> Cale: interesting... so the 2nd root is the negative of that...
03:31:32 <atom> Cale: and it expects you to know that.
03:31:36 <Cale> well, yeah
03:31:52 <Cale> It's a particular branch of the complex square root
03:31:52 <atom> Cale: what about the 3rd root?
03:32:03 <Cale> x**(1/3) should work
03:32:35 <Cale> Or do you mean a third square root? There isn't one.
03:32:43 <atom> Cale: I meant the former
03:33:53 <atom> Cale: it's just that x**(1/3) is pretty useless for getting all 3 roots... unless you then convert it to (|z|, angle) and do the math
03:34:08 <atom> but i'm getting ahead of myself
03:34:39 <laziest> atom: you can divide x by (x**(1/3)) and then take the square root of the result
03:34:42 <wli> I blamed numerical stability and cooked up a homebrew method of getting sqrt.
03:35:05 <hpaste>  Cale annotated "noobish stuff" with "simpler with inferred types" at http://hpaste.org/3488#a4
03:35:07 <laziest> no I am wrong!
03:35:14 <atom> wli: you mean use taylor series?
03:35:16 * laziest slaps himself
03:35:19 <wli> No.
03:35:21 <oerjan> laziest: doesn't work for positive reals at least
03:35:24 <wli> Like this:
03:35:27 <wli> let w z = let { c = realPart z ; d = imagPart z } in if c == d && d == 0 then 0 else if abs c >= abs d then sqrt (abs c) * sqrt ((1 + sqrt (1 + (d/c)^(2::Int))) / 2) else let t = c/d in sqrt (abs d) * sqrt ((abs t + sqrt (1 + t^(2::Int))) / 2) ; cSqrt z = let { c = realPart z ; d = imagPart z ; ww = w z } in if ww == 0 then 0 else if c >= 0 then ww :+ (d/(2*ww)) else if c < 0 && d >= 0 then (abs d)/(2*ww) :+ ww else (abs d)/(2*ww) :+ (negate ww)
03:35:32 <Cale> heh
03:35:53 <Cale> I suppose you can do that
03:36:17 <oerjan> > (-1)**(1/3) :: Complex Double
03:36:18 <lambdabot>  0.5000000000000001 :+ (-0.8660254037844386)
03:36:21 <Cale> uh, why not just use Newton's method though... or are you doing that?
03:36:23 <wli> Does the library sqrt actually work?
03:36:27 <Cale> yes it does
03:36:38 <wli> Cale: No reason to bother with this, then.
03:37:04 <wli> Cale: This assumes the real sqrt works and gets branch cuts and numerical stability blah blah blah.
03:37:14 <scriptdevil> birkenfeld: i am sorry for the delay
03:37:23 <scriptdevil> it is there in the haskell site
03:37:25 <scriptdevil> wait.
03:38:02 <scriptdevil> birkenfeld: http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
03:38:04 <oerjan> > [((-1)**(1/3) :: Complex Double)^n | n <- [2,4..]]
03:38:06 <lambdabot>  [(-0.4999999999999998) :+ (-0.8660254037844388),(-0.5000000000000006) :+ 0.8...
03:38:06 <lambdabot> Title: S-INF.de - Vorlesungsvideos, http://tinyurl.com/y4m979
03:38:57 <oerjan> > [((-1)**(1/3) :: Complex Float)^n | n <- [2,4..]]
03:38:58 <lambdabot>  [(-0.5000001) :+ (-0.8660254),(-0.49999988) :+ 0.86602557,1.0000001 :+ (-2.6...
03:39:00 <atom> Cale: looked at your annotation... Interesting, and a lot plainer
03:39:28 <wli> If you can assume (**) produces the Cauchy principal value (or some other useful branch) you can just multiply by roots of unity.
03:39:46 <atom> wli: true.
03:39:49 <birkenfeld> scriptdevil: thanks!
03:40:10 <oerjan> wli: um, multiplying by roots of unity works in any case, just reordering?
03:40:47 <Cale> All you really care about is that it gives *some* nth root.
03:40:53 <wli> oerjan: I thought you were trying to produce all roots for an n-th root?
03:40:57 <Cale> (at least in this case)
03:41:20 <oerjan> wli: yes
03:42:19 <oerjan> and any two of those can be turned into each other by multiplying with a root of unity
03:45:16 <wli> > let nthRoots :: Integer -> Complex Double -> [Complex Double] ; nthRoots n z = let w = z ** (1/(fromIntegral n)) in w : map (w*) [exp (0 :+ (2*pi*fromIntegral k/(fromIntegral n))) | k <- [1..n]] in nthRoots 3 (-1)
03:45:18 <lambdabot>  [0.5000000000000001 :+ (-0.8660254037844386),0.5000000000000001 :+ 0.8660254...
03:45:32 <wli> Not the most numerically stable method.
03:46:51 <wli> I'm not up to the task of reconstituting Jenkins-Traub or hammering out an eigensolver.
03:47:00 <opqdonut> :)
03:48:12 <oerjan> that's still better than those of us who haven't heard those names at all :)
03:49:38 <wli> Slightly better is:
03:49:40 <wli> > let w = (realPart $ abs z) ** (1/(fromIntegral n)) in (w :+ 0) : map ((w :+ 0)*) [exp (0 :+ (2*pi*fromIntegral k/(fromIntegral n))) | k <- [1..n]] in nthRoots 3 (-1)
03:49:40 <lambdabot>  Parse error at "in" (column 148)
03:49:51 <wli> ergh
03:49:57 <wli> > let nthRoots :: Integer -> Complex Double -> [Complex Double] ; nthRoots n z = let w = (realPart $ abs z) ** (1/(fromIntegral n)) in (w :+ 0) : map ((w :+ 0)*) [exp (0 :+ (2*pi*fromIntegral k/(fromIntegral n))) | k <- [1..n]] in nthRoots 3 (-1)
03:49:59 <lambdabot>  [1.0 :+ 0.0,(-0.4999999999999998) :+ 0.8660254037844387,(-0.5000000000000004...
03:50:58 <wli> The upper limit should be n-1
03:51:23 <atom> sqeq :: Complex Float -> Complex Float -> Complex Float -> (Complex Float, Complex Float) -- is there a way of turning this line into something shorter?
03:51:45 <opqdonut> newtype C = Complex Float
03:51:47 <opqdonut> :Å
03:51:55 <opqdonut> *:P
03:52:23 * Beelsebob wonders if Wolfgang will update HOC to work with Leopard's new Bridging support
03:52:36 <oerjan> opqdonut: type not newtype
03:53:07 <opqdonut> i never remember the type/newtype distinction :/
03:53:20 <atom> what about not defining a new type? I thought I saw something along the lines of a -> a -> a -> (a, a) somewhere...
03:53:32 <oerjan> well type is just the same old type, renamed...
03:53:53 <opqdonut> ah and a newtype had two bottoms?
03:54:11 <oerjan> no, just one
03:54:17 <oerjan> data has an extra
03:54:24 <opqdonut> ok
03:55:03 <Cale> atom: The inferred type is pretty clean
03:55:12 <Cale> (but polymorphic)
03:55:48 <atom> Cale: it is clean, the only problem I have with it is that it inevitably REQUIRES a complex result.
03:56:04 <atom> Cale: I mean, it requires the type of one variable to be declared complex
03:56:15 <atom> in order to not get an error when det < 0
03:56:32 <Cale> atom: You shouldn't get an error message, I don't think, just a NaN
03:56:56 <Cale> *Main> sqeq 1 0 (-2)
03:56:56 <Cale> (1.4142135623730951,-1.4142135623730951)
03:56:56 <Cale> *Main> sqeq 1 0 2
03:56:56 <Cale> (NaN,NaN)
03:56:58 <atom> Cale: well... true, only hugs can't print a NaN and it's not happy about it
03:57:04 <Cale> huh
03:57:08 <Cale> that's odd
03:57:21 <atom> says "argument out of range"
03:57:29 <Cale> yeah, it does
03:58:25 <atom> but you are correct, the inferred type is better
03:58:30 <Cale> funny, since Hugs does have non-signalling NaNs.
03:58:44 <Cale> (e.g. try 0/0)
03:58:54 <atom> hugs says nan
03:59:05 <atom> that _is_ weird.
03:59:22 <Cale> I'd consider it weird enough to be a bug
03:59:31 <atom> Cale: um.. do I report it?
03:59:40 <atom> Cale: I mean, should I?
03:59:50 <Cale> I suppose you could
04:00:32 <Cale> hugs-bugs@haskell.org
04:01:17 <Cale> It's probably easy to fix
04:01:35 <Cale> I suspect it's just a bug in the Complex library.
04:01:58 <snhmib> uhm, what are the indentation rules for nested if-statements?
04:02:07 <laziest> none
04:02:10 <snhmib> i can't find it and ghc keeps complaining =(
04:02:14 <Cale> if foo
04:02:17 <Cale>    then bar
04:02:20 <Cale>    else quux
04:02:29 <laziest> snhmib: it's a single expression
04:02:43 <Cale> The important thing being that the 'then' and 'else' are lined up and indented more than the 'if'
04:02:44 <laziest> so 'then' and 'else' should be indented deeper than 'if'
04:02:57 <snhmib> ! oh ok
04:03:15 <Cale> (that's stricter than the actual rule, but it's how everyone will expect you to indent them)
04:03:22 <snhmib> i had else unindented =( thanks!
04:03:46 <Cale> Another common form when 'foo' is short is:
04:03:52 <Cale> if foo then bar
04:03:57 <Cale>        else quux
04:04:32 <laziest> Cale: or even a single liner if bar and quux are short
04:04:37 <Cale> right
04:04:45 <atom> Cale: it's not a bug
04:04:54 <wli> Okay, I think this is better.
04:04:57 <wli> > let nthRoots :: Integer -> Complex Double -> [Complex Double] ; nthRoots n z = let w = (realPart $ abs z) ** (1/(fromIntegral n)) in (w :+ 0) : map ((w :+ 0)*) (let omega = exp (0 :+ (2 * pi / fromIntegral n)) in (genericTake (n `div` 2) (tail $ iterate (/omega) 1)) ++ (genericTake (n `div` 2) (tail $ iterate (*omega) 1))) in tail $ nthRoots 3 (-1)
04:04:59 <lambdabot>  [(-0.49999999999999983) :+ (-0.8660254037844388),(-0.4999999999999998) :+ 0....
04:05:05 <atom> Cale: it's a behaviour of the sqrt function, watch
04:05:07 <snhmib> wait ghc is still saying it's wrong :S
04:05:14 <atom> > sqrt(-1)
04:05:16 <lambdabot>  NaN
04:05:16 <Cale> atom: yes, a bug in its behaviour
04:05:35 <Cale> atom: It should return NaN rather than throwing an exception.
04:05:43 <laziest> snhmib: can you paste it?
04:05:46 <atom> Cale: ok... Well, ok. I guess i'll report it then
04:06:04 <Cale> (At least, this would conform with GHC better and be more useful.)
04:07:44 <snhmib> i have: http://rafb.net/p/NXco4E44.html
04:07:45 <lambdabot> Title: Nopaste - haskell newbie troubles
04:08:03 <snhmib> and ghc says  Syntax error in expression (unexpected `}', possibly due to bad layout)
04:08:28 <Cale> you're missing an else
04:08:29 <laziest> you missed an 'else'
04:08:50 <snhmib> !
04:08:50 <laziest> since you are in IO monad, try using when
04:09:01 <Cale> If you don't want to do anything, use  return ()
04:09:03 <laziest> if requires both parts
04:09:15 <Cale> if is an expression, not a statement
04:09:48 <snhmib> ok thanks =)
04:10:09 <Cale> So it must have a value, which means the else is not optional :)
04:10:23 <Cale> (even when that value is an action to be carried out)
04:11:00 <snhmib> oh offcourse :S
04:11:18 <oerjan> @src when
04:11:19 <lambdabot> when p s = if p then s else return ()
04:11:34 <Cale> yeah, there are some handy functions :)
04:11:43 <oerjan> @index when
04:11:44 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:11:57 <Cale> @src unless
04:11:57 <lambdabot> unless p s = if p then return () else s
04:12:14 <Cale> You can write your own as well, if that doesn't cover it.
04:12:48 <snhmib> hehe i do import Control.Monad to use it?
04:12:51 <Cale> yeah
04:13:11 <laziest> Cale: I don't think so!
04:13:34 <Cale> You type "import Control.Monad" at the top of your module
04:13:42 <Cale> (I'm assuming that's what was meant)
04:14:03 <Cale> laziest: What don't you think?
04:14:28 <laziest> Cale: no, you are right... I thought it was in Prelude
04:14:29 <snhmib> it's working now =) thanks Cale/oerjan
04:14:31 <atom> Cale: bug sent. Somehow, I don't think anyone will correct it, but what the hey
04:14:52 <Cale> atom: It's worth a shot. I bet it's easy. I could probably try fixing it myself.
04:15:09 <atom> Cale: the only thing is that the last hugs version is 2005.3
04:15:10 <atom> :)
04:15:42 <atom> at least in portage, which is usually fairly up to date
04:16:18 <Cale> no, that's old actually
04:16:28 <atom> Cale: hm...
04:17:04 <Cale> May 2006 is the latest release version
04:17:13 <atom> damn, that is old. I just checked as well...
04:17:19 <Cale> (Probably be a new version soon)
04:17:35 <taruti> Was there a nice way of globbing filenames? Something like globFilePath :: FilePath -> IO [FilePath] ?
04:17:45 <Cale> er, heh
04:17:46 <atom> hm... that just has to be fixed. I might just write a new ebuild for the new hugs
04:17:54 <Cale> I'm actually running September 2006
04:17:57 <EvilTerran> @hoogle glob
04:17:57 <lambdabot> Language.Haskell.TH.global :: Name -> ExpQ
04:17:58 <lambdabot> System.Win32.Mem.globalAlloc :: GlobalAllocFlags -> DWORD -> IO HGLOBAL
04:17:58 <lambdabot> System.Win32.Mem.globalFlags :: HGLOBAL -> IO GlobalAllocFlags
04:18:17 <atom> i'll be back. Got something to do
04:18:25 <Cale> But it has the same flaky behaviour with sqrt
04:19:25 <Cale> mm... sqrt is defined as primSqrtDouble
04:19:38 <Cale> I could edit this, but it wouldn't be the real way to fix it :)
04:21:03 <Cale> haha, well, I have a decent workaround
04:21:22 <spx2> is there any big project written in haskell ?
04:21:28 <wli> spx2: Yes.
04:21:28 <spx2> something really big
04:21:42 <spx2> wli,ok can I know its name ?
04:21:42 <psykon> the universe!
04:21:43 <Cale> Simply edit /usr/lib/hugs/packages/hugsbase/Hugs/Prelude.hs
04:21:56 <wli> spx2: ghc
04:22:03 <laziest> spx2: darcs
04:22:13 <Cale> and in the instance of Floating for Float, replace
04:22:21 <Cale> sqrt = primSqrtFloat
04:22:23 <Cale> with
04:22:30 <Cale> sqrt x = if x >= 0 then primSqrtFloat x else 0/0
04:22:40 <Cale> and similarly with Double
04:22:46 <spx2> wli: ghc is the ahskell compiler...I was reffering to something other than the haskell compiler ... something wich a final user could use to do something in particular ...
04:22:52 <Cale> But that's obviously somewhat of a silly way to fix it.
04:22:58 <spx2> laziest: what is darcs ?
04:23:12 <laziest> spx2: a version control system
04:23:13 <Cale> (however, it works without recompiling hugs, which is nice)
04:23:23 <wli> spx2: Lava
04:23:23 <laziest> (un)like CVS, SVN, GIT, etc.
04:23:49 <Cale> Hugs> sqrt (-1)
04:23:49 <Cale> nan
04:23:51 <scook0> @where darcs
04:23:51 <lambdabot> http://darcs.net/
04:23:59 <ukl> xmonad could also be mentioned, i think...?
04:24:12 <wli> ukl: It's not large.
04:24:49 <ukl> wli: ok...
04:24:53 <wli> spx2: One issue is that Haskell code is typically at least 10 times smaller than the equivalent C.
04:25:07 <Cale> @tell atom see what I did above for a quick workaround if you're interested.
04:25:07 <lambdabot> Consider it noted.
04:25:13 <oerjan> iiuc xmonad is impressive _because_ it is small
04:25:18 <wli> spx2: With some nonlinearities.
04:25:54 <wli> spx2: i.e. the bigger the project the bigger the code density ratio vs. C gets.
04:25:56 <Cale> spx2: I've written 600 line haskell programs which would have been 15000 line C programs.
04:26:21 <Cale> (and that's using the judgement of an expert C programmer)
04:26:42 <kalven> did it involve a lot of list manipulation?
04:26:50 <Cale> Yes, in fact it did.
04:26:55 <Cale> And *lots* of laziness.
04:27:08 <kalven> how unsurprising!
04:27:34 <Cale> Well, given that lists in Haskell are what loops are in C, yeah.
04:28:06 <wli> When things like monad transformer stacks get involved you're slinging around what would be enormous interfacing and integration tasks effectively effortlessly.
04:28:56 <Cale> Lazy evaluation let me write my program naturally, whereas figuring out how to turn it inside out would have been a horrible horrible pain.
04:29:40 <Cale> (That is, if I couldn't just work with combinatorially large lists, and had to actually construct things in a strict fashion.)
04:29:59 <oerjan> surely there must be some InsideOut Monad >:)
04:30:10 <Cale> Not in C there isn't ;)
04:30:36 <EvilTerran> that's what the preprocessor's for >:]
04:30:47 <wli> You simulate laziness in C with thunks etc.
04:31:23 <wli> You don't do it the hard way because the hard way is so much code you'll be buried under it.
04:31:28 <Cale> Yeah, explicit laziness would have still been pretty annoying.
04:31:48 <Cale> But maybe doable.
04:32:18 <Cale> anyhow, I'm going to sleep
04:32:31 <kalven> perhaps using laziness wouldn't be the idiomatic thing to do in a language like c.
04:32:49 <wli> It's not but when your problem demands it you do it.
04:33:10 <EvilTerran> when your problem demands laziness, you switch to haskell
04:33:24 <wli> C is so low-level that when high-level tasks demand things you must obey lest you be buried under such massive amounts of code you'll never get it done.
04:33:38 <kalven> ah
04:33:50 <EvilTerran> if it ever does; thinking that your problem demands laziness may be symptomatic of too much haskell already ;)
04:34:22 <wli> Well, most of the laziness in C is centered around IO.
04:34:49 <laziest> wli: can you elaborate?
04:35:03 <laziest> wli: do you mean the buffering in stdio?
04:35:20 <wli> Basically loading things via IO on-demand, like paging in nodes of a B-tree.
04:35:42 <wli> No, not stdio. "Materializing pages" and so on.
04:36:19 <wli> I guess I'm thinking of the Linux VM.
04:36:31 <wli> And program loading.
04:36:37 <laziest> ah.
04:36:49 <wli> i.e. demand paging
04:36:49 <laziest> So you mean using IO to simulate laziness.
04:36:59 * oerjan for a moment was thinking "Linux has a virtual machine?"
04:37:08 <wli> No, implementing lazy IO like hGetContents by hand.
04:37:11 <oerjan> darn acronyms
04:37:35 <wli> Except it's random access, but never mind that.
04:37:55 <laziest> hmm.
04:39:27 <wli> Paging in nodes of a B-tree would be filesystem metadata.
04:40:55 <laziest> I am inclined to think of it more of memory management than lazy 'evaluation'... But may be I did not get you correcly..
04:43:32 <wli> Memory management is programming, too.
04:43:57 <kalven> how do you manage memory in haskell?
04:44:15 <oerjan> you pray
04:45:06 <laziest> wli: Of course it is! I said I could not see lazy evaluation in it. Memory management is ofcourse a lot of sweat.
04:45:32 <wli> Demand paging is lazy program loading.
04:46:04 <wli> File IO is lazy, too. Part of a file get loaded only when accessed, and sometimes not even then.
04:46:09 <laziest> Ah! Now it strikes me. Sorry for being dumb :)
04:48:24 <EvilTerran> hm. how would you express "a0..aN is a permutation of b0..bN" in FOL?
04:48:51 <laziest> EvilTerran: what is FOL?
04:48:55 <EvilTerran> first-order logic
04:50:08 <EvilTerran> that should've been a(0)..a(n) and b(0)..b(n), i guess; functions're better defined than subscripts...
04:50:12 <oerjan> (a0=b0 or a0=b1 or ...) and (a1=b0 or ...) ... and (b0=a0 or b0=a1 ...) ...
04:50:58 <oerjan> i.e. each element occurs somewhere in the opposite sequence
04:51:09 <EvilTerran> i was kinda hoping for an expression that didn't change shape based on n, and didn't have ellipses
04:51:10 <quicksilver> {a0,a1,...,aN} = {b0,b1,...,bN}
04:51:17 <oerjan> assuming they are distinct
04:51:18 <quicksilver> set equality
04:51:22 <quicksilver> indeed
04:51:25 <oerjan> that's not FOL
04:51:38 <quicksilver> if not, then {(0,a0),(1,a1),..,(n,aN)} = ...
04:51:43 <quicksilver> it's not hard to put sets into FOL
04:51:47 <quicksilver> and it's a good idea
04:51:56 <quicksilver> and it's not hard to write a definition of equality, either
04:52:09 <oerjan> for all i, exists j,k: a(i)=b(j) and b(i)=a(k)
04:52:15 <oerjan> better? :)
04:52:15 <quicksilver> well therre's more than one possibile choice but for finite sets it's easy
04:52:17 <quicksilver> right
04:52:22 <EvilTerran> oerjan, aha, that's what i was after
04:52:52 <oerjan> might want to split the exists
04:52:53 <wli> Try formulating it much as one would in a programming language.
04:52:56 <EvilTerran> i guess. i'll say "assuming all a(i) distinct, likewise b(i)" or whatever, i guess
04:53:22 <EvilTerran> wli: sort (map a [0..n]) == sort (map b [0..n])
04:53:24 <EvilTerran> :P
04:53:41 <wli> That's what I would try.
04:53:56 <EvilTerran> i have no idea how i'd express sorting in FOL
04:54:19 <EvilTerran> but it's an interesting problem
04:54:43 <oerjan> i think sorting is harder
04:54:46 <wli> If you can't assume an Ord instance you get something more like oerjan's.
04:55:00 <EvilTerran> if the a(i)s don't have to be distinct, i'm not sure how else i'd express the permutations aspect
04:55:40 <wli> Counting repetitions.
04:55:54 <EvilTerran> hm.
04:56:12 <oerjan> you need to have numbers then
04:56:35 <wli> Strike out all subsequent equal elements while tagging the first element with some value with the number of repetitions.
04:56:38 <ZsoL> 'his[6~[6~aw
04:56:50 <EvilTerran> @go cat-like typing detected
04:56:53 <lambdabot> http://bitboost.com/pawsense/
04:56:53 <lambdabot> Title: PawSense helps you catproof your computer.
04:56:57 <wli> Then do the a(i) = b(j) and b(i) = a(k) test.
04:57:01 <oerjan> wli: i don't think you can actually tag in FOL
04:57:31 <wli> It takes a lot of machinery to do useful things.
04:57:54 <wli> I'm relatively sure you can tag, but it's painful to set it up from scratch.
04:57:55 <JohnMeacham> hello
05:32:14 <raxas> EvilTerran: while pawsense is funny, it can also easily disguise a keylogger
05:34:21 <EvilTerran> true. i guess you could deny it network access with a firewall, if you were sufficiently paranoid
05:35:23 <ddarius> Or reverse engineer the code.
05:40:58 <raxas> actually, my cat is happy enough with her own keyboard she can walk on at will, placed at the top of bookcase
05:50:31 <Baughn> raxas: Okay, that's clever
05:50:49 <Baughn> Gotta try that. Though I suspect half the reason they like to walk on /mine/ is for the reactions
05:56:54 <profmakx> its for getting attention
05:57:07 <Baughn> Indeed
05:57:09 <profmakx> though, my cat likes to lie on my notebook, because its warm
05:57:13 <ac> would someone mind explaining how to use { } types?
05:57:28 <Baughn> ac: That's not type, that's syntax
05:58:04 <ac> Baughn: Is { } syntactic sugar for records, allowing you to fetch elements by name?
05:58:24 <ac> Baughn: s/records/tupples/
05:58:31 <scook0> well, that's one of its (syntactic) uses
05:58:38 <scook0> for records, anyway
05:58:55 <scook0> actually...
05:59:13 <scook0> to fetch a record element by name, you just use the field name as a function
05:59:26 <scook0> the {} come in handy when you want to create/update a record
05:59:34 <oerjan> as well as for pattern matching
05:59:41 <scook0> ah, yes
05:59:46 <Baughn> ac: When you specify field names in a data declaration, the compiler automagically makes a function of the same name to extract it
06:00:26 <scook0> data MyRec = MkRec { field :: Type }
06:00:29 <ac> say I have a type "Thing" with a bunch of fields, and an instance of Thing called foo. How can I make another instance called bar with the same values in all the fields except one?
06:00:52 <ac> (or two)
06:00:59 <scook0> let bar = foo { theField = newVal }
06:01:17 <scook0> separate multiple fields with commas, iirc
06:01:18 <ac> cool
06:01:45 <ac> what's the difference between records and tupples?
06:02:08 <scook0> tuples are the types (a,b), (a,b,c) etc.
06:02:22 <scook0> you can't match on them by name, because they don't have field names
06:02:31 <oerjan> tuples are a predefined type, not compatible with anything else
06:02:43 <Baughn> Records create new types, tuples don't
06:02:49 <oerjan> in principle fst and snd could have been made field names, but aren't
06:02:56 <ac> oerjan: that's what I'd expect
06:03:07 <ac> oerjan: except I'd expect the field names to be "1", "2", etc
06:03:19 <ac> why isn't a tupple a record with numeric fields?
06:03:21 <scook0> Baughn: careful ... I see what you're saying, but that could be a confusing statement
06:03:33 <oerjan> well haskell doesn't allow different types to share field names
06:03:58 <scook0> (the Oz language does what you describe, I believe)
06:04:00 <oerjan> so (a,b) and (a,b,c) are not the same
06:04:11 <oerjan> also ML i think
06:04:42 <Baughn> ac: Hmm, right.. records create a new, singular, /named/ type. Tuples don't create a new type, because it's already there; the type doesn't have a single name, though you could identify it as (Int,Int) or whatever.
06:04:45 <oerjan> i mean, ML has #1, #2 or something like that
06:06:11 <ac> I like the ML way, because then you could create new tupples conveniently like: bar = foo { #5 = blah }
06:06:33 <oerjan> the lack of field names for tuples may be tied in to how they've never agreed on similar extensible records
06:07:02 <scook0> in Haskell, if your tuples are bigger than 2-3 fields, I suspect you should probably be using records
06:07:05 <ivanm> I've tried hoogle, but it revealed nothing... is there a function with a type signature of: (Monad m) => m a -> (a -> b) -> m b ?
06:07:12 <Baughn> "#5" sounds like a good field name. Is it in use for anything?
06:07:18 <ac> oerjan: are you saying hugs and ghc have different records?
06:07:21 <oerjan> ivanm: flip fmap
06:07:23 <scook0> @type flip liftM
06:07:24 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
06:07:33 <scook0> gah, beaten!
06:07:42 <ivanm> well, the order of arguments isn't really importange
06:07:44 <wli> oerjan: Who's never agreed?
06:07:45 <ivanm> *important
06:07:53 <oerjan> ac: hugs has something , i am not sure ghc has any at all
06:08:03 <oerjan> wli: the standards committees
06:08:17 <scook0> and I suppose I should give (<$>) a mention, since you used fmap ;)
06:08:44 <ac> are records and tupples considered a minor wart?
06:08:57 <scook0> ac: how do you mean?
06:09:10 <scook0> you mean the fact that they're not the same thing?
06:09:16 <ac> yeah
06:09:20 <wli> So what's the general plot with extensible records? What do people want from them, want to use them for, etc.?
06:09:29 <wli> Oh, and what are they?
06:09:37 <Baughn> wli: We don't agree.
06:10:01 <Baughn> ..well, mostly /they/ don't agree. I'm in perfect consensus with myself.
06:10:13 <scook0> wli: in haskell, you can't define a record type that's "just like that other type, with some more fields tacked on"
06:10:26 <wli> Well, I don't care. Just give me something to get an idea about.
06:10:36 <wli> scook0: That would be handy, sure.
06:10:51 <EvilTerran> there's papers on extensible records
06:10:55 <wli> Is there anything else to it?
06:11:04 <EvilTerran> some of 'em look pretty good; i don't remember any links, off-hand
06:11:05 <oerjan> wli: it would make it easier when you actually _do_ want to use OOP, i think
06:11:06 <Baughn> See: Subclassing
06:11:06 <wli> Like do people want subtyping etc.?
06:11:16 <EvilTerran> all we need is some implementations, so we can play with 'em a bit.
06:11:43 <wli> EvilTerran: The papers answer very different sorts of questions.
06:11:56 <Baughn> wli: I want a perfect language. In my mind, a perfect language should allow arbitrary sub- and supertyping
06:12:11 <wli> So basically you want subtyping eventually, and record usage convenience otherwise?
06:12:22 <pejo> wli, most people seem to hate the idea of subtyping. A few seem to kind of like the idea.
06:12:23 <scook0> Baughn: and have decidable type-checking. and solve the halting problem ;)
06:12:28 <oerjan> Baughn: unfortunately someone proved type inference to be undecidable with subtyping
06:12:42 * ac is pleased with stirring up a debate on records :P
06:12:50 <EvilTerran> but is it decidable-enough-in-most-cases?
06:12:56 <wli> pejo: I think records are overemphasized wrt. subtyping; I want them on coproducts/etc.
06:12:56 <Baughn> oerjan: I'm sure you could still make it work in /most/ cases, and write a warning (plus add runtime checking) for the rest
06:13:03 <pejo> oerjan, isn't type inference on rank-n polymorphism undecidable as well, in that case?
06:13:17 <EvilTerran> ac, ah, don't get too pleased with yourself; we have at least one of these most days
06:13:20 <Baughn> oerjan: The monomorphism restriction is because of similar issues, and /that/ can be turned off
06:13:28 <pejo> wli, and in laymans terms - is that on your datatypes?
06:13:32 <wli> oerjan: ISTR something like HM(X) which got type inference very useful/tractable.
06:13:35 <ac> EvilTerran: I figured as much
06:13:48 <oerjan> pejo: er, i think you went a little beyond my knowledge here (mostly picked up from various discussions)
06:13:53 <Baughn> oerjan: ..after all, if it's undecidable then humans can't decide either; I doubt most people will write code they don't understand.
06:14:11 <wli> pejo: data Foo = A | B | C ... ; data Bar extends Foo by D | E | F | ...
06:14:28 <EvilTerran> the undecidable-instances extension, likewise, makes typechecking undecidable in the general case, but still fine in most normal cases
06:14:30 <wli> pejo: Foo can be used anywhere Bar is used etc.
06:14:38 <pejo> oerjan, the tricky part is to make the type inference complete afaik. O'Haskell had an incomplete type inference for example.
06:15:12 <Baughn> Is complete type inference really worth restricting the language?
06:15:22 <oerjan> pejo: i tried reading the MLF paper but my brain wasn't quite cooperating
06:15:34 <wli> pejo: What are the issues here? Completeness, decidability, what else?
06:15:37 <scook0> heck, Hindley-Milner is technically exponential anyway, isn't it?
06:15:49 <scook0> which is no different from undecidable, if you never hit those corner cases
06:16:08 <scook0> (for practical purposes, anyway)
06:16:17 <Baughn> Somehow "intractable" sounds better than "undecidable" if you're a theoretician
06:16:23 <wli> pejo: What's completeness in a layman's term?
06:16:35 <pejo> Baughn, most Haskell programmers seem to put type annotations in their code although they don't need it. I don't think we're dealing with a technical issue here.
06:16:40 <Baughn> wli: All inputs produce well-behaved outputs in finite time
06:17:09 <wli> Baughn: That sounds like some sort of efficiency criterion similar to decidability.
06:17:20 <Baughn> wli: If it's /infinite/ time, then it's undecidable
06:17:31 <pejo> wli, you can construct programs that typecheck if they have type annotations, but if you remove the type annotations they won't type check.
06:17:35 <Baughn> pejo: Being human, most issues are with humans, yes. I find the annotations useful, though.
06:18:07 <oerjan> well, haskell has a long-standing tradition of adding type extensions that require annotations
06:18:10 <wli> Okay, there's tons of that already with rank-N polymorphism etc.
06:18:22 <Baughn> wli: To be sure, some undecidable problems will terminate in finite time, too - with "no answer".
06:18:37 <pejo> Baughn, oh, I'm not arguing against you. We have accepted annotations for rank-n-polymorphism, might as well throw in subtyping in there from a programmers pov.
06:18:48 <oerjan> even data types can be considered such (although there the annotation is the definition itself)
06:19:30 <wli> I think structural subtyping on variants will prove vastly more useful than on records in practical programming terms, but that's just me.
06:20:53 <wli> e.g. if a case statement only handles certain constructors only types with variants that are a subset of that case statement are allowed.
06:22:10 <wli> Things get curious, I suppose, with variant records where you have mixes of record fields extending things and a superset of variants.
06:22:41 <wli> Or vice-versa, or the same set of variants and a mixture of record subsets and supersets.
06:24:07 <wli> I'm not really sure what the inference and/or checking algorithms do when they hit types that aren't entirely comparable like that, but are partially comparable.
06:24:42 <wli> There are cases where they can be used in the same place and others where they can't.
06:25:39 <scook0> I wonder how much subtyping complicates the use of type operators
06:25:43 <pejo> wli, I think the type checking is fairly well studied for systems with subtyping.
06:25:48 <scook0> (variance issues and such)
06:26:10 <scook0> from a practical perspective
06:26:21 <wli> pejo: That's handy. I wonder how H98 - mono. rest. + MPTC + fundeps does with subtyping.
06:26:49 <wli> I guess that's H98 - MR + MPTC + FD
06:27:01 <pejo> wli, O'Haskell was built on Hugs 1.3 iirc. Think you had MPTC in there, but no fundeps I guess.
06:28:28 <wli> pejo: What was the basic look/feel of the typesystem? Clunky? Corner cases easily visible but not overwhelming?
06:28:47 <wli> pejo: Possibly even totally unproblematic for normal programming?
06:30:01 <pejo> wli, I don't think Nordlander is aware of any 'real' programs that suffer from the incompleteness of the type inference. It's of course easy to construct an example that triggers the problem.
06:31:18 <pejo> wli, there's a bunch of examples of O'haskell programs at http://www.cs.chalmers.se/~nordland/ohaskell/
06:31:19 <lambdabot> Title: O'Haskell
06:33:00 <ac> It would be a lot better to create a cycled list and "drop n" from it, rather than "!!(mod n (length l))", right?
06:33:36 <scook0> hmm
06:33:40 <wli> oic
06:33:50 <scook0> more elegant, I suppose
06:34:03 <scook0> depends what you want to be "better"
06:34:27 <ac> more efficient I guess. I suppose it's obviously easier to read and write a cycled list
06:35:00 <scook0> are you doing this multiple times for the same list?
06:35:13 <ac> (by "read" and "write" I mean for a person to read and write the code)
06:35:28 <ac> scook0: yes
06:36:02 <scook0> if you saved the length of the list, later operations could theoretically be more efficient
06:36:12 <scook0> O(n mod l) instead of O(n)
06:36:23 <wli> A safe, polymorphic type system with declared record and datatype subtyping, supported by a powerful partial type inference algorithm
06:36:31 <wli> Hmm, no structural subtyping.
06:36:33 <scook0> but if n is small you probably don't care
06:37:07 <ac> I think it's nice using the cycled list, because then I don't need an offset variable
06:37:08 <scook0> also, the mod/length version doesn't reallocate the entire list spine
06:37:31 <scook0> but if you keep the cycled version, I guess that's only one spine-copy
06:37:57 <scook0> if elegance is your thing and you have no pressing need for super-performance
06:38:01 <pejo> wli, Glenn Strong had an 'extended abstract' at IFL this year about approaches to subtyping in functional languages. He had a software engineering perspective on his research - which according to my understanding means he wants to be able to write real programs. I'm hoping he will submit a paper to the real proceedings.
06:38:05 <scook0> I'd just go with the cycled list because it's cooler :)
06:38:12 <ac> scook0: yeah :)
06:38:47 <scook0> out of curiosity, what kind of n/length would be typical for your application?
06:38:57 <ac> 10 or 20
06:39:09 <ac> maybe 100 at the very most
06:41:22 <wli> pejo: That would be very cool. It's very under-studied.
06:41:54 <wli> I'm very very big on structural subtyping for variants.
06:42:10 <ac> is there an if like construct without a then?
06:42:16 <wli> Named subtyping for records is a double doorstop for me.
06:42:18 <wli> ac: when
06:42:51 <pejo> wli, you program in C for a living, right?
06:43:02 <wli> pejo: Yep.
06:43:12 <ac> I meant else actually... what's the syntax of when?
06:43:33 <scook0> @hoogle when
06:43:34 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
06:43:34 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
06:44:03 <Botje> @hoogle unless
06:44:04 <lambdabot> Monad.unless :: Monad a => Bool -> a () -> a ()
06:44:04 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
06:44:04 <lambdabot> System.Win32.Types.failUnlessSuccess :: String -> IO ErrCode -> IO ()
06:44:18 <wli> ac: Control.Monad.when
06:44:22 <scook0> ac: you're working in a monad, I presume?
06:44:26 <wli> ac: It's just an ordinary function.
06:44:37 <ac> scook0: yeah, otherwise it wouldn't make sense not to have an else
06:44:37 <scook0> (otherwise a one-sided if doesn't make a lot of sense)
06:44:41 <pejo> wli, so effectively you picked a job with a language that doesn't give you any of the features you like. :-)
06:44:55 <wli> pejo: I didn't really pick it. It picked me.
06:45:07 <wli> pejo: I was like a leaf blown by the wind.
06:45:46 <wli> pejo: I got out of college right in the midst of the dot com bubble bursting, with layoffs happening even as I was hired.
06:46:08 <wli> pejo: Choices were extremely limited.
06:47:58 * wli decides subtyping is too far out for a toy language, or at least the term language.
06:49:06 <SamB> wli: I thought far-out stuff was what toy languages were for
06:49:25 <wli> H98 - MR + MPTC + FD is already blowing past the limits of what should really go on in the term language.
06:49:38 <wli> SamB: Modules are supposed to be the focus.
06:49:46 <SamB> ah
06:49:59 <SamB> so you want far-out modules
06:50:09 <pejo> Heh, exactly what I was thinking SamB.
06:50:38 <wli> SamB: Not really. Just analogues of Standard ML's higher-order modules with some mutual recursion.
06:51:23 <wli> SamB: Layered atop H98 - MR + MPTC + FD, as it requires nontrivial term language typing to "stress" the module language.
06:51:32 <pejo> wli, check out Nordlander's thesis though, it gives a very good overview of O'Haskell.
06:51:57 <wli> I'll reread it. I've got it saved somewhere.
06:52:11 <pejo> Oh, ok - I'm too late. :-)
06:54:22 <wli> Hmm. Saved a fresh copy. ISTR reading it around the same time as Dilip Siquiera's thesis, though.
06:56:20 <wli> O'Haskell uses name-oriented subtyping, though, which is very different from structural subtyping wrt. inference.
06:59:20 <wli> I ultimately want to stick to very well-understood type systems for the term language and I don't see that for subtyping. I'd like to stick to a well-understood module system, too, for that matter, but I don't think they're out there and that's the whole point of it.
07:00:16 <TomMD> Is it possible to make a FFI binding at runtime?  The latest version of FUSE provides a (void *)(int, ... other args...) and I don't know how to make use of that from Haskell.
07:00:47 <therp> tommd: create a wrapper in C maybe
07:01:05 <EvilTerran> foreign import "& foo" might be what you want
07:01:06 <therp> tommd: I presume the ..other args.. are C-s "..." notation in function declarations, right?
07:01:12 <Zola> hi... i got a little data structure question
07:01:27 <Zola> Given the message...
07:02:12 <Zola>  global { freq 255 cutoff 444 flop 0.9 } myvoice { 0 { note c-4 samp 12 velo 80 fxcmd { 0 { e 8 9 0.1 } 1 { p -127 12 0.2 } } } 1 { note e-4 samp 11 } }
07:02:23 <Zola> e 8 9 0.1 is a tuple
07:02:37 <TomMD> therp: No, I'm not being clear.  One function call (this is a 'C' system call INTO haskell, for which I have an FFI binding already) provides, as an input, another C function with a type like: (void *)(int, void *, int).
07:02:50 <Zola> myvoice.0 == note c-4 samp 12 velo 80 fxcmd { 0 { e 8 9 0.1 } 1 { p -127 12 0.2 } }
07:03:02 <Zola> myvoice.0.fxcmd.0 == e 8 9 0.1
07:03:18 <Zola> myvoice.0.fxcmd.0.e == 8 <--- WRONG ... contents are "e 8", e is not a key
07:03:31 <Zola> contents are "e 8 9 0.1" rather
07:03:31 <EvilTerran> TomMD, er? so it needs to take a function as a parameter?
07:03:52 <TomMD> Yes, my haskell function must take a 'C' function as a parameter and USE that C function to perform its job.
07:04:01 <Zola> while parsing and generating this tree, it doesn't know if something is a tuple or a k,v pair
07:04:19 <Zola> that doesn't matter, while I *use it manually*, cause I always go, like:
07:04:43 <therp> tommd: ah alright, still this can be solved via a proxy ... just create a function callThisFun and hand over the given argument..
07:04:44 <Zola> s = "global { freq 255 cutoff 444 flop 0.9 } myvoice { 0 { note c-4 samp 12 velo 80 fxcmd { 0 { e 8 9 0.1 } 1 { p -127 12 0.2 } } } 1 { note e-4 samp 11 } }"
07:05:07 <EvilTerran> TomMD, where's this C function coming from? is it an "extern (void *foo)(int, void *, int)" in a C header?
07:05:18 <Zola> voices = Route(s, "myvoice")
07:05:29 <Zola> now voices == 0 { note c-4 samp 12 velo 80 fxcmd { 0 { e 8 9 0.1 } 1 { p -127 12 0.2 } } } 1 { note e-4 samp 11 }
07:05:31 <therp> tommd: then you have a fixed binding.. but I'm not sure if there is something more direct than these. maybe have a look at the Foreign.* modules whether there is something that already provides this service
07:05:33 <Zola> and then I go
07:05:57 <Zola> tuple = Route(s, "myvoice.0.fxcmd.0")
07:06:03 <therp> tommd: ah sorry, callThisFun lives in the C world (if that was unclear)
07:06:11 <Zola> tuple simply becomes "e 8 9 0.1"
07:06:16 <Zola> however...
07:06:34 <Zola> if I want to generate a visualization of the message, or show it in a tree
07:06:36 <TomMD> Therp: I'll give that a try.
07:06:36 <TomMD> EvilTerran: All I see is a typedef for the function in fuse.h, no actual function prototype.
07:06:50 <Zola> it chokes up and becomes confused at the tuple part
07:07:05 <Zola> and cant decide if its pairs of k,v e,8 9,0.1
07:07:14 <Zola> etc
07:07:25 <Zola> What to do?
07:07:32 <EvilTerran> TomMD, I'd suggest seeing what c2hs makes of it; that can work out a lot of this fiddling with types out itself
07:08:07 <EvilTerran> even if you don't use it in your final solution, you can use it to help work out the relationship between some more complex C types and haskell types
07:08:35 <Zola> none knows?
07:08:54 <wli> I'm sorry. I don't know anything about FUSE. I might be able to help if it were low-level privileged state manipulation on one of several arches.
07:09:18 <TomMD> wli: Sounds like you've been gray-hatting too long.
07:09:46 <wli> TomMD: I'm not involved with security at all, either.
07:11:24 <wli> TomMD: Very little kernel/user interface affairs, to the point the filesystem layer(s) and drivers are above the level I work at. I have done some core work, though, like kernel/profile.c, kernel/wait.c, and kernel/pid.c
07:12:02 <wli> TomMD: I guess I'm technically the hugetlbfs maintainer, though for reasons other than fs driver affairs.
07:14:47 <wli> TomMD: It needs arch stubs for low-level arch code for every arch it's on, which sort of low-level multi-arch bits are what I'm on about.
07:15:37 <wli> TomMD: The filesystem driver is largely trivial.
07:31:45 <matthew-_> you can't use strings as a list in a pattern match can you?
07:33:32 <scook0> sure you can (depending on what you mean)
07:33:49 <matthew-_> pattern match using ("foo":_) as the pattern
07:34:06 <scook0> nah, that won't work as you've written it
07:34:19 <scook0> but ('f':'o':'o':_) will
07:34:31 <scook0> (yes, it's a pain, but it makes sense)
07:34:45 <matthew-_> yeah, I realise that
07:34:57 <scook0> if "foo" is on the LHS of the cons
07:35:12 <scook0> it would have to be a [String], not a String that you're decomposing
07:35:22 <scook0> because string literals include the final []
07:35:55 <scook0> ideally you'd want ("foo"++_), but obviously that doesn't work
07:36:24 <matthew-_> well, given we have n + 1 patterns, having "foo" ++ _ could be argued for
07:37:12 <scook0> or general view-based pattern matching, for that matter
07:37:13 <kpreid> But how do you define ++ then?
07:37:44 <Saizan> you can use a guard | "foo" `isPrefixOf` xs = .. or pattern guards and a function isPrefixOf' :: Eq a => [a] -> [a] -> Maybe [a]
07:37:45 <matthew-_> scook0: well quite
07:39:35 <Jaak> @hoogle isPrefixOf
07:39:36 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
07:42:44 <matthew-_> hmmm. is it just me or does using the list monad for readsPrec scare other people too?
07:43:07 <matthew-_> given that it does a cartestian product, I do wonder if it's going to read stuff that wasn't intended...
07:44:04 <ddarius> matthew-_: Read stuff that wasn't intended?
07:44:38 <fxr> hi, I'm trying to write a simple utility that replaces an html tag with given input. My first try seems to be fine but I need your advices.
07:44:46 <hpaste>  fxr pasted "html replace by id" at http://hpaste.org/3490
07:45:24 <fxr> I'm now trying to use xpath queries with hxt but couldn't find any help.
07:45:46 <matthew-_> ddarius: well, if the type you're reading is a compound, say data Card = Card Suit Rank; you then have do { (rank, rankRest) <- readsPrec d r; (suit, suitRest) <- readsPrec d rankRest; return (Card suit rank, suitRest)}
07:46:29 <matthew-_> but the two <- worries me about the cartesian product thing - like if there is one rank and two suits then I'll get two Cards won't I?
07:46:57 <ddarius> matthew-_: Okay...
07:47:58 <matthew-_> err - am I right or am I confused?
07:54:15 <Saizan> i think the only thing that matters is if readsPrec for Suit and Rank is deterministic or not
07:55:39 <matthew-_> ok, well they're derived
07:55:53 <Saizan> so they should
07:56:46 <Saizan> and if they're deterministic you only have one "thread" in that do block, so the list monad does very little
07:57:07 <LeCamarade> Which is the HTTPd poster child of Haskell, again? HAppS?
07:57:44 <LeCamarade> ?where hws
07:57:45 <lambdabot> I know nothing about hws.
07:57:47 <divip> hi, what "ap" means in the answers of @pointless ?
07:57:58 <Saizan> ?type ap
07:58:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:58:49 <divip> seems too difficult for @pointless \x y = x (y x)
07:58:56 <divip> @pointless \x y = x (y x)
07:58:56 <lambdabot> (line 1, column 6):
07:58:57 <lambdabot> unexpected "="
07:58:57 <lambdabot> expecting pattern or "->"
07:59:05 <divip> @pointless \x y -> x (y x)
07:59:06 <lambdabot> ap (.) (flip id)
07:59:25 <Saizan> it's a polymorphic function, so it depends on the context, but in the @pl results it is usually used with m = (->) r, in that case ap f g x = f x (g x)
07:59:48 <Saizan> @pl \f g x -> f x (g x)
07:59:48 <lambdabot> ap
08:00:07 <divip> ok, thanks, i understand with (->) r
08:02:21 <ddarius> @unpl join ($)
08:02:21 <lambdabot> ((\ a b -> a b) >>= \ c -> c)
08:02:31 <divip> @pointfull ap (.) (flip id)
08:02:31 <lambdabot> ((\ a b c -> a (b c)) >>= \ i -> (\ e f -> f e) >>= \ h -> return (i h))
08:02:41 <ddarius> @pl x x
08:02:41 <lambdabot> x x
08:02:45 <divip> can i simplify it?
08:02:46 <ddarius> @pl \x -> x x
08:02:46 <lambdabot> join id
08:05:41 <Jaak> @type join id
08:05:44 <ddarius> matthew-_: The readsPrec for the suit only operates on the rankRest, it's not going to read some from rankRest and then read some more from the remainder a second time.
08:05:46 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
08:05:46 <lambdabot>     Probable cause: `id' is applied to too many arguments
08:05:46 <lambdabot>     In the first argument of `join', namely `id'
08:06:46 <ac> why does HOpenGL only eat textures with dimensions of perfect squares? The OpenGL 2.1 spec relaxed that constraint
08:07:02 <ac> That really killed me earlier today
08:08:05 <ac> the worst part is that there are no errors; it just fails to draw the texture
08:10:40 <noteventime> ac: Maybe you need to load an extension?
08:10:52 <ac> noteventime: how do I do that?
08:10:53 <noteventime> Or is HOpenGL 2.1 compliant?
08:11:16 <noteventime> ac: I don't know how HOpenGL does it, check if there are any language bindings for GLEW
08:11:30 <noteventime> GLEW does all the stuff for you :-)
08:11:36 <ac> noteventime: what's GLEW?
08:11:53 <noteventime> ac: A library that handles OpenGL extensions
08:13:04 <noteventime> I'm pretty sure non-power-of-two textures needed an extension before you could load them
08:13:21 <LoganCapaldo> Question, does the value [] inhabit all types of the form [a], or is there a separate [] value for every type of the form [a] ?
08:13:36 <LoganCapaldo> and related question, does it matter?
08:13:47 <noteventime> ac: The extension is called ARB_texture_non_power_of_two
08:13:48 <ac> noteventime: you're right, I guess it does require an extension.
08:14:13 <ac> noteventime: I don't really know much about OpenGL. Are extensions a formal part of the spec?
08:14:44 <noteventime> How do you mean, if the extensions themselves are or if the concept of an extension is?
08:15:06 <Philippa> LoganCapaldo: For Haskell, it doesn't matter
08:15:32 <ac> the extensions themselves.
08:15:56 <noteventime> I think the ones beginning with ARB may be, ARB == Architectural Review Board
08:16:05 <noteventime> They're still optional though
08:16:17 <LoganCapaldo> Philippa: I assume the same applies for Nothing?
08:16:18 <noteventime> So you have to check that your OpenGL implementation supports it
08:16:22 <ac> noteventime: meaning I'd have to bundle an extra library if I used one
08:16:33 <noteventime> Not really
08:16:44 <noteventime> Extensions aren't extra libraries
08:16:52 <noteventime> As much as plugins
08:16:57 <noteventime> I'm no expert in this
08:17:22 <noteventime> But I think manually loading extensions in C involves using function pointers and lots of casting
08:17:53 <ac> sounds exciting
08:18:04 <Botje> a bit of trivia: does anyone know what "ld" stands for? if this isn't the appropriate channel i'll try ##c
08:18:17 <SamB> hmm, I thought extensions were implemented in your libGL.so
08:18:24 <SamB> dunno...
08:18:36 <Jaak> "ld - The GNU linker"
08:18:39 <SamB> well, not actually implemented per se
08:18:46 <LoganCapaldo> Link eDitor apparently
08:19:55 <desegnis> LoganCapaldo: You could say that ([] :: [a]), ([] :: Show a => [a]), ([] :: [Integer]) all are different values
08:20:35 <SamB> certainly looks as if my libGL exports lots of extension functions...
08:20:52 <desegnis> LoganCapaldo: Just as in mathematics functions with different domains are different from each other, even if they are defined by the same term
08:20:55 <LoganCapaldo> desengis: You could say that, I'm just wondering if there's a definitive answer.
08:22:55 <SamB> LoganCapaldo: I think we can say that they have the same values where they overlap
08:23:14 <dons> ?yow
08:23:14 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
08:23:16 <dons> ?quite
08:23:16 <lambdabot> Maybe you meant: quit quote
08:23:20 <dons> ?quit you!
08:23:25 <desegnis> LoganCapaldo: I am not sure about, er, definitivity, but all there lists behave differently, so they are different for me
08:24:59 <ddarius> SamB: All types, except perhaps polymorphic types, are disjoint.
08:25:08 <ddarius> (in Haskell)
08:26:23 <SamB> ddarius: those types were all polymorphic types
08:26:31 <SamB> except [Integer]
08:29:14 <ddarius> SamB: I'm not even sure that I would want to say [a] and [Integer] overlap.  At any rate, [] :: [Integer] and [] :: [Double] are different values.
08:30:59 <desegnis> ddarius: It's tempting to call it overlapping because you can say  ([] :: [a]) :: [Integer]  as well as  ([] :: [a]) :: [Double]
08:31:20 <matthew-_> where is the monad instance for Either e defined?
08:31:32 <SamB> ddarius: quite so
08:31:33 <ddarius> @instances Monad
08:31:34 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:31:39 <desegnis> ddarius: er, I realize now that that didn't quite fit to your comment about [a] and [Integer]
08:31:45 <matthew-_> ahh, cmi
08:31:51 <SamB> ddarius: at least they are until you get past types
08:32:18 <SamB> once type erasure has occured, they might be the same value...
08:32:44 <SamB> but that's kinda irrelevant
08:32:57 <ddarius> SamB: Agreed.
08:33:20 <matthew-_> hmm. I can't find it in cmi
08:33:30 <matthew-_> cmi has Either a for Functor, but not for Monad
08:33:44 <ddarius> Control.Monad.Error ?
08:34:29 <SamB> huh?
08:34:40 <matthew-_> yay! thank you
08:34:44 <SamB> @instances-import Control.Monad.Error Monad
08:34:45 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:34:47 <matthew-_> @slap the blind matthew-_
08:34:47 <lambdabot> *SMACK*, *SLAM*, take that the blind matthew-_!
08:35:05 <SamB> oh, right, cmi is Control.Monad.Instances...
08:35:20 * SamB wonders why Monad (Either e) isn't in there, anyway
08:35:21 * ddarius should rewrite the MTL so that all the "standard" instances use CPS if possible.
08:35:32 <SamB> hmm?
08:35:40 <SamB> ddarius: what would that look like?
08:35:48 <ddarius> I believe it should be in Control.Monad.Instances.  I thought that was part of the point of that module.
08:36:01 <SamB> ticket it
08:36:04 <Axioplas1> Hi.
08:36:35 <matthew-_> hmm. given that fail :: String -> m a; why is Monad defined on Either e and not Either String ?
08:36:37 <ddarius> SamB: I'd probably do it ad-hocly to specialize to each.
08:36:57 <SamB> ddarius: hmm?
08:36:59 <ddarius> SamB: There would be no change in interface except perhaps strictness properties.
08:37:06 <Saizan> matthew-_: it's defined on Error e => Either e, iirc
08:37:11 <Axioplas1> How can I define transitivity of an order ? I have a sum with a dozen constructors, I said A < B, then B < C and so on. How can it infer that A < C ?
08:37:12 <Saizan> ?src Error
08:37:12 <lambdabot> class Error a where
08:37:12 <lambdabot>     noMsg  :: a
08:37:12 <lambdabot>     strMsg :: String -> a
08:37:17 <SamB> could you give an example of such an instance?
08:37:30 <Axioplas1> Should I script the instance Ord to generate it or what ?
08:38:05 <matthew-_> oh ffs, why does :b not show instances?
08:38:11 <Saizan> Axioplas1: do you have a reason for not deriving Ord?
08:38:35 <Axioplas1> Saizan: How would it understand which one is smaller than the other ?
08:38:48 <Axioplas1> given the declaration order ?
08:38:52 <Saizan> Axioplas1: yes
08:39:03 <Axioplas1> ok, then it's great.
08:39:32 <ddarius> SamB: The one for Error would pretty much be Cont (Either e a) a
08:39:44 <SamB> ddarius: hmm?
08:40:03 <ddarius> SamB: With throwError and catchError using call/cc like tricks.
08:41:32 <ddarius> Maybe forall r. Cont (Either e r) a.  I'd actually have to start working it out.
08:41:59 <ddarius> I'm not sure if (a -> r) -> (e -> r) -> r would be better or not.
08:44:27 <Saizan> ddarius: the aim is better performance?
08:44:42 <ddarius> Saizan: Hopefully.  It would be interesting to compare.
08:48:58 <matthew-_> @hoogle (a -> b) -> (c -> d) -> Either a c -> Either b d
08:49:02 <lambdabot> No matches, try a more general search
08:51:26 <dons> ?quit new patches
08:53:03 <ddarius> :t (|||)
08:53:05 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
08:53:14 <ddarius> :t (+++)
08:53:15 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
08:53:49 <Saizan> ?src (->) (+++)
08:53:50 <lambdabot> Source not found. Wrong!  You cheating scum!
08:56:03 <ddarius> @src MonadError
08:56:04 <lambdabot> class (Monad m) => MonadError e m | m -> e where
08:56:04 <lambdabot>     throwError :: e -> m a
08:56:04 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
08:57:54 <matthew-_> > case 3 of n | (m+1) <- n && even m -> m
08:57:54 <lambdabot>  Parse error at "<-" (column 21)
08:57:58 <matthew-_> that's rather annoying
08:58:11 <matthew-_> the pattern guard thingy is only in scope after the ->
09:04:22 <pmatos> Hello, does anybody know if it is possible within emacs mode to access the doc for a given function?
09:04:22 <ski> matthew-_ : shouldn't there be something else than `&&' .. like maybe `,' ?
09:05:59 <ski> Prelude> case 3 of n | (m+1) <- n, even m -> m
09:05:59 <ski> 2
09:06:42 <ski> @djinn (a -> b) -> (c -> d) -> Either a c -> Either b d
09:06:43 <lambdabot> f a b c =
09:06:43 <lambdabot>     case c of
09:06:43 <lambdabot>     Left d -> Left (a d)
09:06:43 <lambdabot>     Right e -> Right (b e)
09:07:00 <matthew-_> sik: ahh, thanks
09:07:08 <matthew-_> ski: rather
09:07:46 <matthew-_> > case 4 of n | (m+1) <- n, even m -> m; otherwise -> 0
09:07:47 <lambdabot>  Parse error at "<-" (column 21)
09:07:56 <matthew-_> ok
09:07:59 <matthew-_> that works in ghc
09:08:00 <matthew-_> ta
09:08:07 <ski> matthew-_ : memory-help : it's like a list comphrension, except the type of `p' and `e' in `p <- e' should be the same
09:08:37 <ski> s/ren/rehen/
09:09:40 <matthew-_> gotcha - you mean like the filter at the end of a list comp?
09:10:02 <ddarius> !paste
09:10:02 <hpaste> Haskell paste bin: http://hpaste.org/
09:11:37 <ski> matthew-_ : i mean like the `q' part of a list comphrehension `[ e | q ]'
09:11:41 <ski> ddarius : interesting idea
09:12:19 <matthew-_> yep
09:12:39 <centrinia> [h x | x <- a , f x] = map h (filter f a)
09:13:31 <hpaste>  ddarius pasted "two CPS error monads" at http://hpaste.org/3491
09:13:47 <ski> in list comphrehensions you can mix generators and filters how you like .. similar for pattern guards, except s/generator/matcher/
09:17:56 <geocalc> > :set +s
09:18:00 <lambdabot>   parse error on input `:'
09:18:33 <ski> ddarius : "using call/cc like tricks", being just CPS, or actual continuation manipulation ?
09:18:52 <geocalc> @set +s
09:18:53 <lambdabot>  Parse error
09:19:22 <ski> ?
09:26:18 <ddarius> ski: continuation manipulation, that's how the effects get realized.  Admittedly simpler continuation manipulation than call/cc.
09:26:36 <ddarius> The code is in that paste.  All it needs now is to be tested and benchmarked.
09:27:50 <ddarius> I've written too much CPS code...
09:27:54 <ski> ddarius : and by continuation manipulation, do you mean treating functions as continuations, or do you mean "real" ones (such that don't return) ?
09:28:12 <ski> (yes, simpler than call/cc)
09:29:43 * ski has a loose idea about unboxed (or maybe "counboxed") variant types that he thinks should enable e.g. error monad without interpreting all the time
09:38:33 <Saizan> is there a particular reason for r@_ -> r instead of r -> r in ErrorCPS' catchError ?
09:39:20 <ddarius> Saizan: No, I was originally going to explicitly pattern match on the Right constructor, but changed my mind.
09:39:43 <ddarius> I.e. r@(Right _) -> r
09:39:52 <ski> are the two implementations isomorphic ?
09:40:30 <ddarius> I doubt it.  Error2CPS is isomorphic to Either so it should behave comparably (but maybe not...).
09:40:47 <ddarius> ErrorCPS is the one that probably has the best performance, but I haven't made a benchmark yet.
09:41:51 <ski> why would that be ?
09:44:50 <ddarius> ErrorCPS is straight CPS except where it deals with the effect.  "Pure" code should run normally.
09:47:27 <ski> wouldn't "pure" code run normally with `Error2CPS', too ?
09:47:37 <ski> (trying to understand what you mean)
09:48:28 <ski> ddarius : btw, have you read Olin Shiver's "Multi" paper ?
09:48:50 <ddarius> ski: Not exactly since it has to carry around the extra continuation, but to some extent yes.  However, Error2CPS shouldn't really be any faster than Either since they are isomorphic and GHC does/did use a similar representation internally.
09:48:59 <ddarius> ski: Probably, but it doesn't ring a bell.
09:49:59 <ski> they essentially pass multiple (alternative) continuations, so the function can pick which to return through
09:50:15 <pheaver> hi dons
09:50:37 <dons> hey pheaver :)
09:50:40 <ski> this is similar to return `Left x', or `Right y', except you can elide interleaving interpreting/percolating, thus getting "semi-tail calls"
09:50:51 <wli> re dons
09:50:53 <dons> pheaver: how's code? :)
09:50:59 <pheaver> uhhh....
09:51:03 <dons> lovely day in portland, today, wli :)
09:51:27 <pheaver> I spent all day yesterday rewriting the FPGA backends :p
09:51:27 <dons> pheaver: have i bugged you to use xmonad yet, btw?
09:51:32 <dons> fun fun!
09:51:35 <pheaver> no you haven't :)
09:51:42 <dons> hey, pheaver, you should try out xmonad :)
09:51:47 <pheaver> heh
09:51:49 <wli> True. I'm in a panic prepping to get lasered. I'll be back in a couple of hours.
09:51:53 <ddarius> ski: Indeed, this is roughly the crux of the "left adjoint" to +
09:52:18 <ski> ddarius : e.g., such a function can call itself semi-tail-recursively, meaning that if it decides to return through one of the continuations, that's be a tail-call that'll jump past (and discard) an arbitrarily large part of the stack holding frames for the other continuation
09:52:20 <roconnor> Is CPS style more effecient/
09:52:22 <roconnor> Is CPS style more effecient?
09:52:30 <newsham> eye-lasered?  tatoo-lasered?
09:52:36 <dons> pheaver: so what you up to today?
09:52:43 <pheaver> still playing with the code
09:52:47 <dons> newsham: or laser implants?
09:52:47 <pheaver> it's mostly broken now :)
09:52:50 <dons> heh
09:53:01 <ski> ddarius : are you referring to a "subtraction" type ?
09:53:12 <pheaver> dons: i was getting annoyed that the interpreter's state was just being passed around all over... so you'd have these functions that don't actually modify the state directly, but call other functions that modify the state... but they had to keep track of, for example, st, st', st'', st''' everytime the state changes
09:53:22 <dons> oh urg
09:53:25 <dons> State monad time!
09:53:26 <pheaver> so I finally rewrote it all to use the state monad
09:53:28 <dons> or maybe a Reader
09:53:29 <dons> yeah
09:53:31 <pheaver> and then hit a snag
09:53:36 <pheaver> state is more appropriate
09:53:36 <ski> roconnor : i think it can be
09:53:38 <pheaver> for this
09:53:52 <dons> ok. that's not atypical.
09:53:53 <roconnor> ski: oh wow.  I was about to give up on CPS.
09:53:53 <ddarius> ski: I believe subtraction types are related or the same thing.  I'm in particular referring to the left adjoint discussed in Filinski's paper on the Symmetric Lambda Calculus.
09:54:10 <pheaver> there's one little part where an Exception is caught, a message is printed, then the exception is re-thrown
09:54:13 <ski> roconnor : `(>>=)' can be simpler in CPS ..
09:54:16 <dons> pheaver: right, ok.
09:54:19 <pheaver> and I don't know how to make it play nicely with MonadState
09:54:20 <pheaver> yeah
09:54:39 <dons> pheaver: ah,you can use MonadError to lift the error handling into your state monad
09:54:55 <pheaver> yeah i tried that
09:55:03 <ddarius> roconnor: Allegedly GHC does a good job on CPS code and by using continuations you can avoid dealing with the "effects" a monad represents except where you perform one.
09:55:03 <pheaver> but i was not very good at it heh
09:55:05 <ski> ddarius : well .. i wasn't speaking directly of a *reified* continuation (or pair of continuation and value) .. just a kind of unboxing
09:55:13 <dons> pheaver: oh?
09:55:18 <pheaver> oh wait
09:55:21 <pheaver> I think I misread
09:55:34 <newsham> why is there no state in the lambda calculus?
09:55:39 <newsham> separation of Church and state.
09:55:41 <dons> so you can define 'throwError' and 'catchError' for your new state monad
09:55:47 <dons> e.g. lambdabot usees,   throwError (IRCRaised e)    = io $ throwIO e
09:55:56 <pheaver> hmm...
09:56:00 <ski> ddarius : as soon as you can reify (*and* reuse/discard values as you like), then continuations can become more expensive (and possibly side-effectful)
09:56:05 <dons> i wrote a blog post about this somewhere. hmm, let me see.
09:56:09 <pheaver> yeah
09:56:17 <pheaver> i noticed that you had a thread on ways of error reporting
09:56:20 <SamB> newsham: so you mean in the old days there was state in lambda calculus?
09:56:40 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons
09:56:41 <lambdabot> Title: Haskell hacking, http://tinyurl.com/ywdjsr
09:56:45 <newsham> before Church was around perhaps
09:56:47 <SamB> newsham: I almost wish that argument would have worked for schools
09:56:53 <dons> scroll down to 'improving error handling'
09:56:59 <ddarius> ski: linearly typing them significantly curtails their expense and power.
09:57:09 <roconnor> ddarius: hmm, intersting
09:57:10 <ski> ddarius : indeed
09:57:17 <pheaver> one restriction I have, though... the frontend that interacts with the user does not use state monad or anything like that... and that code belongs to too many other people to modify
09:57:25 <dons> sure.
09:57:28 <newsham> my wife's cross word puzzle last week "The father of computer science"  the answer was "TURING".
09:57:29 <roconnor> ddarius: think my DNAMonad could be speed up by using CPS?
09:57:33 <newsham> I thought that was a little irritating
09:57:35 <dons> presumably you run the backend with a runState or something?
09:57:37 <pheaver> so after the FPGA backend is done with it, it needs to be back to IO a, no State
09:57:39 <newsham> no love for his phd advisor?
09:57:41 <pheaver> yes
09:57:43 <ddarius> roconnor: What is it?
09:57:47 <ski> roconnor : `DNAMonad' being ?
09:57:54 <pheaver> that's what I have now, and it works well except the one backend that catches the error
09:57:59 <dons> pheaver: so similarly, you can runErrorT . runState
09:58:02 <dons> or something like that
09:58:03 <SamB> should have said "a father of computer science"
09:58:13 <dons> pheaver: ok, sounds tractable at least
09:58:16 <pheaver> you know what's even more annoying?  the only reason it has to catch the error is because xilinx tools are weird
09:58:21 <dons> heh
09:58:27 <pheaver> dons: yes I was hoping for something like that
09:58:39 <newsham> I think "cracked codes with bomb" woulda been better
09:58:39 <pheaver> one of the xilinx tools reports some errors over stdout instead of stderr
09:58:46 <roconnor> data DNAState a = Done
09:58:46 <roconnor>                 | Cont DNA a
09:58:46 <roconnor> newtype DNAMonad a = DNAMonad
09:58:46 <roconnor>                 { runDNA :: DNA -> ([RNA]->[RNA], DNAState a)}
09:58:51 <dons> pheaver: oh, i hate tools like that!
09:58:52 <ski> ddarius,roconnor : hm, a bit noise .. would you mind continuing in #haskell-overflow ?
09:58:57 <pheaver> so if it crashes, we catch the error and print its stdout, otherwise we don't
09:58:59 <roconnor> some sort of mix of the Exit, state, writer monad.
09:59:46 <dons> pheaver: yep, definitely doable. the backend that needs to catch things can runErrorT I think, with a custom catchError that does what you ask
10:00:01 <dons> pheaver: or can you just catch at the top level of your backend?
10:00:14 <pheaver> probably
10:00:33 <pheaver> the xilinx executable is only called one place in all the backends, so if it dies, I know it will be from that one call
10:00:42 <dons> right.
10:00:46 <dons> so you could wrap it right there
10:00:46 <pheaver> man, that would actually be a really easy fix
10:00:48 <dons> and isolate it
10:00:54 <pheaver> after i've already done runStateT
10:01:01 <pheaver> and have an IO () anyway
10:01:03 <dons> you could even be tricky and run it in its own Xilinix monad
10:01:08 <dons> so you have to wrap it any time it is used
10:01:11 <pheaver> heh
10:01:23 <dons> to prevent evil code infecting your nice app
10:01:26 <pheaver> that's an interesting idea
10:01:32 <dons> (i'm thinking of doing this for xmonad user extensions right now, actually)
10:01:35 <pheaver> i see
10:01:37 <dons> run them in their own sandbox monad
10:01:48 <dons> so the type checker will warn if you call "untrusted" code in the wrong place
10:01:53 <pheaver> yeah
10:02:01 * SamB wishes darcs trackdown could solve the halting problem
10:02:12 <dons> actually, xmonad has catches for user code too, since they can fail
10:02:31 <dons> userCode :: X () -> X ()
10:02:31 <dons> userCode a = catchX (a >> return ()) (return ())
10:02:44 <pheaver> so would I need to define transformers between the Xilinx monad and others?
10:02:45 <dons> so user-contributed (aka untrusted) code gets run inside that
10:02:52 <pheaver> oh
10:02:55 <pheaver> that looks really simple
10:02:56 <dons> pheaver: you could use newtype deriving to derive all the instances
10:03:06 <pheaver> oh, neato
10:03:11 <dons> newtype Xilinx a = Xilinx (StateT ... IO a )
10:03:17 <dons> deriving (MonadError, MonadState)
10:03:21 <pheaver> ah
10:03:29 <dons> then you can use it as before, but it will be tagged as having a different type
10:03:35 <dons> so that would be the "industrial" solution
10:03:36 <pheaver> so, my functions aren't of type StateT ... IO a
10:03:41 <dons> you might be able to get away with something easier
10:03:49 <pheaver> they're (MonadState .. m, MoandIO m) => ... -> m a
10:04:06 <dons> right, but presumably your runState fixes it to a specific monad?
10:04:11 <dons> specific state type, anyway
10:04:24 <pheaver> right, at the top-level of the backend
10:04:25 <dons> i was thinking of this in xmonad,
10:04:26 <dons>  newtype X a = X (ReaderT XConf (StateT XState IO) a) deriving (Functor, Monad, MonadIO, MonadState XState, MonadReader XConf)
10:04:31 <pheaver> ah
10:04:36 <dons> so that's a reader/state stack, that we newtype
10:04:55 <dons> so that it is behaviourly the same as ReaderT (StateT), but as a distinct type
10:04:56 <pheaver> but... the top-level function calls these (MonadState ... m, MonadIO) functions, which then call the Xilinx tools
10:05:09 <pheaver> wouldn't calling the Xilinx tools restrict those functions to StateT .. IO
10:05:16 <dons> i'd probably try to just wrap the xilinx calls in catch then
10:05:27 <dons> oh, it doesn't need to be in StateT -- i only used that as an example
10:05:32 <pheaver> ahhh, ok!
10:05:40 <dons> the newtype T a = T ( ... ) is the thing i was trying to illustrate
10:05:48 <pheaver> yea
10:06:05 <pheaver> hmm.. i guess i'm not asking my question clearly :p
10:06:22 <dons> so the main thing is to catch any error thrown by the xilinx code
10:06:28 <pheaver> yeah
10:07:03 <pheaver> and the problem is that I can only use catch in IO, not just any m that satisfied MonadIO m
10:07:31 <dons> but you can lift catch
10:07:41 <pheaver> hmmm... i tried that
10:07:41 <dons> liftIO catch, or else use MonadError to do the lifting in the background
10:07:49 <dons> giving you `catchError`
10:08:22 <dons> so we run untrusted code in xmonad with:
10:08:23 <dons>   userCode a = catchX (a >> return ()) (return ())
10:08:32 <dons> where catchX is the lifted catch function, with special behaviour:
10:08:39 <dons> catchX :: X a -> X a -> X a
10:08:39 <dons> catchX job errcase = do
10:08:44 <dons> ...
10:08:44 <dons>     (a, s') <- io $ runX c st job `catch`
10:08:45 <dons>                     \e -> case e of
10:08:45 <dons>                             ExitException {} -> throw e
10:08:45 <dons>                             _ -> do hPrint stderr e; runX c st errcase
10:09:22 <dons> which seems something like what you're trying to do? catch errors in low code, before they leak into the monadic layer above
10:09:27 <dons> so something like that might work
10:09:32 <pheaver> right
10:10:17 <dons> this code is defined here, code.haskell.org/xmonad/XMonad.hs
10:10:20 <pheaver> k
10:10:51 <pheaver> it makes sense the way you've written and explained it, but it's still confusing how to integrate that into cryptol, which is really messy
10:11:14 <dons> yeah, you can get into some hairy type hacking to make things glue together
10:11:30 * dons is reminded of this in lambdabot:
10:11:31 <dons> lbIO :: ((forall a. LB a -> IO a) -> IO b) -> LB b
10:11:31 <dons> lbIO k = LB . ReaderT $ \r -> k (\(LB m) -> m `runReaderT` r)
10:11:37 <pheaver> heh
10:12:04 <dons> you're gluing programs   together in different execution environments
10:12:12 <Jaak> that code makes grown men whimper
10:12:16 <dons> so we're working on a very high level of abstraction
10:12:30 <dons> since the result we are trying to achieve is already pretty hardcore
10:12:58 <dons> i don't think perl programmers try to statically separate program contexts like this
10:13:18 <dons> though hmm, taint checking is an interesting backed in error monad
10:13:30 <dons> baked.
10:17:06 <SamB> dons: error monad?
10:17:12 <pheaver> dons: my handler wants to access the state
10:17:18 <pheaver> or rather, I want it to
10:17:29 <SamB> dons: that's an error monad?
10:17:39 <dons> SamB: hmm, so what are the rules?
10:17:54 <dons> you get some value v :: Tainted a
10:17:55 <SamB> well, in RML, the rules are:
10:18:01 <dons> which you must eliminate with s//
10:18:10 <dons> yielding an 'a' that is safe to use in the rest of your program
10:18:34 <dons> so there's some io operations in Tainted, e.g. getstuff :: String -> Tainted String
10:19:04 <dons> so really its a simple tagging monad, with s// as the runTainted function
10:19:17 <SamB> if a value is classified, a case analysis of it returns a classified value, and primitives functions return a classified value if passed a classified value
10:19:18 <dons> s/// = unTaint
10:19:40 <dons> and its a static error to use a tainted value elsewhere, iirc?
10:19:44 <dons> or a warning, at least
10:20:05 <dons> so what monad would that be? Identity ?
10:20:38 <SamB> dons: static?
10:20:42 <dons> you can't hook in handling behaviour, so its not an error monad.
10:20:57 <dons> oh, its been a *long* time since i've done perl, but iirc the perl interpreter would warn on startup about unsafe use
10:21:00 <dons> of tainted data
10:21:06 <dons> so yeah, a static error
10:21:16 <SamB> oh
10:21:44 <SamB> RML handles classified data dynamically
10:22:39 <SamB> I still haven't figured out a nice way to write an RML interpreter
10:22:50 <dons> so you know what I'm talking about with perl -T ?
10:23:06 <dons> ah, but it is a runtime check, of course.
10:23:21 <dons> checking every perl reduction step and looking at dynamic tags
10:23:45 <dons> `The major caveat is that taint mode is not a compile time check. It is a run-time check.'
10:23:56 <dons> so it only checks executed code paths.
10:23:59 <dons> silly dynamic languages
10:24:03 <SamB> how would you incorporate tainting into a simple scheme interpreter?
10:24:30 <SamB> dons: they can't help it
10:24:43 <dons> push unsafe operations into their own monad
10:24:48 <dons> e.g. tagged at runtime
10:24:51 <dons> then check tags on use
10:25:07 <dons> `To untaint a variable, you use regular expressions'
10:25:15 <dons> more unsafe than unsafePerformIO! :)
10:25:28 <SamB> how would you handle e.g. a cons which has a tainted car and cdr but is not itself tainted?
10:25:32 <dons> who needs a type system proof when you can use regexes to get at evil data :)
10:25:48 <dons> SamB: you'd have to unwrap the car first.
10:25:51 <Axioplase> Can I define different orders on a data struct ?
10:26:04 <SamB> in RML, you have to rearrange objects in the world model
10:26:10 <dons> Axioplase: yeah, you want a custom Ord instance?
10:26:13 <SamB> dons: hmm?
10:26:13 <mrd> why even bother have tainted expressions
10:26:32 <Axioplase> dons: yes. Say, onw where I compare cards by values only, and one by colours
10:26:34 <mrd> (in that case)
10:26:39 <ddarius> Axioplase: It depends on what you mean and if you are willing to make small changes.
10:26:47 <dons> mrd, yeah, you really want it statically checked
10:27:13 <dons> its a simple case of the generic problem of injecting data (like tmoertel's strings problem with databases)
10:27:16 <SamB> mrd: well, so you can test your RML code without dealing with the really bad thrashing caused by the garbage collector in the codex...
10:27:18 * mrd shrugs. perl is dumb. what else is new.
10:27:38 <SamB> mrd: personally, I think I would prefer to leave their garbage collector off and use libgc's instead
10:27:47 <mrd> i don't know about RML
10:27:59 <SamB> did you play ICFP 2006 yet?
10:28:00 <dons> mrd, well, its cute they approximated a partial, ad hoc implementation of an Identity monad :)
10:28:04 <mrd> no
10:28:09 <dons> with regexes as the runIdentity function
10:28:09 <SamB> do so
10:28:38 <SamB> play the adventure game
10:28:50 <Axioplase> ddarius: well, if I could Derive Num, in order to associate a natural to each of my constructors and be able to quantify the distance between two constructors...
10:28:53 <mrd> was that the CMU one
10:28:58 <SamB> yeah
10:29:15 <SamB> it's a really fun game
10:29:27 <mrd> dons: heh
10:29:30 <SamB> you don't need to a degree in reverse engineering to play
10:29:44 <mrd> SamB: cool.  another distraction to keep me from finishing my homework =)
10:30:02 <SamB> mrd: what classes are you taking>?
10:30:14 <mrd> this one is from parallel algo.
10:30:37 <SamB> ICFP 2006 will keep fine until summer 2008 anyway
10:39:42 <mrd> hm the makefile in this is not terribly useful
10:43:31 <atom> Cale: here?
10:47:56 <ski> tombola !
10:49:25 <Axioplase> @paste
10:49:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:49:33 <jedbrown> Which library do people use for plotting.  In particular, is there an easy way to get a color/surface plot of an irregularly sampled function of 2 variables?
10:50:07 <Botje> i'd say gnuplot
10:50:24 <jedbrown> With the hssl interface?
10:52:52 <dons> jedbrown: there's a couple of good plotting libs
10:52:58 <dons> the 'chart's binding to gtk, iirc
10:53:01 <dons> and i use gnuplot
10:53:47 <hpaste>  Axioplase pasted "Instance Num type error..." at http://hpaste.org/3492
10:54:50 <sjanssen> Axioplase: you probably mean Concrete (a - b)
10:55:13 <jedbrown> dons: Is chart flexible?  The examples look like it's just 2D data.
10:55:33 <dons> i've not used it, so am unsure. you could mail the author
10:55:43 <dons> a binding to the gtk science lib might be nice...
10:55:47 <dons> that definitely supports 3d stuff
10:55:50 <dons> but you'd be writing the binding
10:56:15 <Axioplase> sjanssen: ha yes. Indeed... thanks. I am very tired...
10:57:40 <jedbrown> dons: I'm not familiar with that.  I haven't used gnuplot much for a while, but I recall irregularly sampled data to be a problem.  Maybe I have to do the interpolation manually?
10:57:59 <dons> i've used gnuplot well for regular samples
10:58:53 <dons> the graph on page 7 here was done with gnuplot, http://www.cse.unsw.edu.au/~chak/papers/polymer.pdf
11:01:48 <dons> xmonad users, feel free to upload screenshots/config files! http://haskell.org/haskellwiki/Xmonad/Config_archive
11:01:49 <lambdabot> Title: Xmonad/Config archive - HaskellWiki
11:02:01 <jedbrown> dons: That's regular samples.  The irregular case requires some interpolation scheme.  One method is to perform a delaunay triangularization.  There are many other methods.  I was hoping to get away with not doing that.
11:02:13 <dons> right.
11:02:21 <dons> that's beyond my expertise :)
11:03:09 <jedbrown> dons: Thanks though.  I'll just make gnuplot work for now.
11:11:44 <asmanur> does anybody know what is wrong with "instance Monad (Either String) where return k = Right k" ?
11:12:07 <asmanur> (ghc tells me "Illegal instance declaration for `Monad (Either String)'")
11:12:11 <dons> ?src return Error
11:12:11 <lambdabot> Source not found. :(
11:12:17 <dons> ?src return Either
11:12:17 <lambdabot> Source not found. I am sorry.
11:12:31 <dons> ?src Either return
11:12:31 <lambdabot> return        = Right
11:12:32 <sjanssen> asmanur: you'll have to turn on FlexibleInstances
11:12:47 <dons> yeah, the type synonym
11:12:54 <sjanssen> @src Either fail
11:12:55 <lambdabot> fail msg      = Left (strMsg msg)
11:13:12 <asmanur> sjanssen: that is .. ?
11:13:30 <sjanssen> asmanur: {-# LANGUAGE FlexibleInstances #-} in your source will work
11:13:55 <asmanur> hum
11:14:15 <sjanssen> asmanur: Haskell '98 says that an instances must be a type constructor applied to type variables
11:14:24 <sjanssen> FlexibleInstances lifts that restriction
11:14:36 <asmanur> ok thanks
11:19:29 <n00b> I was working on my encryption homework. i was to use the integer 13 to encrypt a String. Look at it for me please and tell me what you think
11:20:24 <hpaste>  noob pasted "encryption" at http://hpaste.org/3493
11:20:58 <dons> have you written some tests for it?
11:21:19 <n00b> I just post it. Look at it
11:21:20 <dons> the functions ord and chr already exist, so you don't need to redefine them
11:21:27 <dons> just import Data.Char
11:21:30 <jaredj> we are the test :o
11:21:38 <dons> ah
11:21:50 <n00b> i know, but my teacher said i must not use the import function
11:21:57 <hpaste>  sjanssen annotated "encryption" with "use pattern matching rather than head/tail" at http://hpaste.org/3493#a1
11:21:58 <dons> ah ok.
11:22:32 <hpaste>  sjanssen annotated "encryption" with "use map rather than recursion" at http://hpaste.org/3493#a2
11:22:54 <n00b> that certainly looks better thanks
11:22:55 <sjanssen> n00b: see my annotations for some tips
11:23:15 <dmwit> n00b: Is this supposed to be rot13 encoding?
11:23:37 <dmwit> (What you are doing is similar, but not quite the same.)
11:23:38 <n00b> the question said integer 13
11:24:04 <jaredj> well, you are using 13
11:24:19 <dons> the local type signatures aren't required
11:24:20 <jaredj> *shrug*
11:24:34 <dmwit> There are many possible ways to use the number 13 in an algorithm. =P
11:24:37 <n00b> sjanssen: I can't use the map function. My teacher said no hig order functions
11:24:39 <dons> and the loop is a map
11:24:48 <dons> you could define your own local version
11:24:50 <jaredj> issue is, chr (ord 'Z' + 13) = ...
11:24:57 <dons> oh, higher order is cheating? :)
11:25:11 <n00b> yes
11:25:11 <jaredj> whaat
11:25:33 <dmwit> But higher-order is like, one of the big selling points of Haskell.
11:25:36 <dons> heh
11:25:37 <n00b> she want us define and use our functions and depend on inbuilt
11:25:39 <dons> dmwit: cheating!
11:25:43 <dons> n00b: fair enough.
11:25:45 <jaredj> maybe they'll get to it
11:25:49 <dons> if you want, you could define a local version of map
11:25:50 <dons> ?src map
11:25:51 <lambdabot> map _ []     = []
11:25:51 <n00b> rather like writing your own Prelude
11:25:51 <lambdabot> map f (x:xs) = f x : map f xs
11:25:58 <dons> which abstracts out the loop in both your functions
11:26:01 <dons> so you can reuse code
11:26:29 <n00b> I understand, but rules are rules
11:26:30 <ricky_clarkson> > chr (mod ord 'Z'+13-ord 'A' 26+ord 'A')
11:26:32 <lambdabot>  Couldn't match expected type `Char -> Int'
11:26:41 <hpaste>  dons annotated "encryption" with "test your homework with QuickCheck" at http://hpaste.org/3493#a3
11:26:43 <dons> ^^ that shows how to test it with QuickCheck, n00b
11:26:48 <n00b> plus not everyone in the class no what "map" is
11:26:54 <dons> which is a good way to ensure your assignment solutions are correct
11:27:14 <ricky_clarkson> n00b: They can read your code to learn then.
11:27:17 <dons> man, i wish i was back in my undergrad class
11:27:17 * dmwit would tell his friends to get a new teacher if their current one was holding them back
11:27:29 <dons> using quickcheck would be so much fun -- almost like cheating :)
11:27:38 <johnnowak> dmwit: there's always a few students that are ahead of the class
11:27:45 <dons> iirc roconnor once submitted isabelle proofs instead of testing
11:27:50 <n00b> cool
11:27:52 <johnnowak> dmwit: it can't really be helped. perhaps if he addressed the instructor he could get additional work.
11:27:53 <dons> i'm not sure the tutor liked that
11:28:00 <n00b> you guys make me be ahead of the class
11:28:12 <dons> n00b: try out quickcheck, it's really useful to ensure your code works
11:28:15 <ZsoL> it's always like that :-)
11:28:24 <dmwit> johnnowak: Yeah -- most of the people here are in that set.  Nevertheless, I've never had, i.e., a math teacher tell me I *couldn't use algebra* to solve a problem or something ridiculous like that.
11:28:28 <dons> n00b: if its a haskell class, you can encourage them to use the wiki and hte irc channel
11:28:47 <ricky_clarkson> dons: Ever used a port of QC?  How'd it go?
11:29:04 <dons> ricky_clarkson: i only ever used the haskell one, though i've used that to test C code succesfully
11:29:31 <ricky_clarkson> Have you documented that somewhere?
11:29:35 <dons> i should write a blog post on QC as a secret weapon for undergrad assignments
11:29:35 <n00b> I post it on the school  forum, but no one reads
11:29:41 <dmwit> dons: Via the FFI or so?
11:29:41 <dons> yes, everyone keeps asking about how to QC C functions
11:29:44 <dons> right
11:29:46 <n00b> or should i say like to read
11:29:48 <johnnowak> dmwit: It makes perfect sense to restrict students to solving a problem a certain way to make sure they know it. I'm sure you'd not be saying the same thing if the rule was that you must solve it with a functional approach, disallowing mutation.
11:30:02 <n00b> so what does this quickcheck do
11:30:17 <dons> it test a property holds of your code, using random data as input
11:30:22 <pejo> dons, that blog post would be much appreciated. Well, or anything else that's a quick start to QC.
11:30:24 <dmwit> johnnowak: No, I don't think that's reasonable.
11:30:27 <n00b> ok
11:30:28 <ddarius> QC+HPC the secret weapon
11:30:33 <dons> so it says that for 100 input cases, decrypt . encrypt was the same as the original string
11:30:37 <dmwit> johnnowak: If he wanted to use the State monad, that would be fine. ;-)
11:30:41 <dons> pejo: yeah ok. cool
11:30:44 <dons> that's a lot of interest
11:30:57 <dons> so what would it look like: quickcheck + hpc, then show how to do the same to C code?
11:31:03 <n00b> rot13 is that what i wrote ???
11:31:11 <ricky_clarkson> I can use QC, I can implement it in Java, but I really don't understand Haskell's implementation.
11:31:18 <dons> ricky_clarkson: oh?
11:31:25 <dons> its just dispatching to instances based on the type
11:31:29 <monochrom> I believe that most students struggle at the type checking level. They don't even have something ready to be tested.
11:31:35 <dons> where the instances define generators for the inhabitants of the type
11:31:40 <dmwit> n00b: I don't think so, rot13 is a bit different.
11:31:41 <dons> monochrom: heh
11:31:48 <ricky_clarkson> How does dispatching on type happen?
11:32:00 <dons> its resolved statically
11:32:07 <ddarius> (most of the time)
11:32:09 <sjanssen> ricky_clarkson: instances of the Testable class
11:32:49 <n00b> ok
11:33:03 <sjanssen> instance Testable Bool; instance (Arbitrary a, Testable b) => Testable (a -> b)
11:33:06 <dmwit> johnnowak: Perhaps you're right.  Maybe I should revise (and tone down) my position: I think teachers should not prevent students from trying new approaches.  Is that a fair compromise?
11:33:30 <dons> dmwit: yeah, always provide a hook for advanced/real world solutions, I reckon
11:33:45 <ricky_clarkson> I once got marked down 30% for writing code that the lecturer didn't understand.  I got other lecturers to talk to him and got the marks back.
11:33:47 <johnnowak> dmwit: Well the teacher isn't preventing anything. They're free to try other approaches. They simply have to show they know what's required at this point.
11:33:53 <dons> as well as more pedagogical approaches
11:34:21 <johnnowak> Just because someone know how to use map doesn't mean they can do it without map.
11:34:24 <dons> since usually there's  some training you're trying to have take place by requiring a solution from a restricted space
11:34:25 <pejo> dons, the approach for blog postings sounds very reasonable to me. Or you can split it in several posts too, if that's more convenient for you.
11:34:41 <dons> e.g. "implement numbers using functoins of 1 argument as your only data type" ... :)
11:35:08 <dons> so presumably n00b is being pushed towards abstracting out `map' as his own function
11:35:08 <johnnowak> dmwit: I agree though that it can be irritating to be in that position of having to do it a certain way when you know that another is better. All you can do is talk to your instructor about it.
11:35:23 <dons> pejo: ok.
11:35:51 <pejo> dons, hm, speaking of those things - aren't you writing a book that will cover much of this? :-)
11:35:54 <ricky_clarkson> Can anyone explain how Haskell dispatches on static type, or tell me where to look?
11:36:02 <dons> pejo: right :)
11:36:05 <monochrom> I TA a class on proving programs correct against specifications. Though it is not testing, you see the overlap with "QC as secret weapon": we both require students to write specifications formalized in first-order logic. So now I tell you my frontline observation: Their biggest obstacle is in formalizing their specifications and properties. They can hack their programs until they work, they can write a million test cases, but
11:36:05 <monochrom>  they can't write a simple property.
11:36:14 <ddarius> ricky_clarkson: That's what typeclasses do.
11:36:16 <dons> ricky_clarkson: so all types are inferred statically and erased at runtime
11:36:42 <ricky_clarkson> Ok.
11:36:47 * ricky_clarkson shifts his paradigm.
11:36:48 <dons> so you can use that to find which `dictoinary' -- or bundle of methods -- a function is looking for
11:37:05 <ricky_clarkson> What's the simplest thing you could write that way?
11:37:07 <dons> which can then either be passed as an argument at runtime, or the methods can be invoked directly
11:37:24 <dons> Eq a => a -> a -> Bool ?
11:37:29 <pejo> dons, hm. Guess I'll get the book when it's ready then.
11:37:38 <dons> instance Eq () where _ == _ = True
11:37:55 <dons> so then any call to () == () is replaced at compile time with the Eq () definition of ==
11:37:59 <dons> which is constant.
11:38:14 <dons> since the type of () is obviously knowns statically (as are all types)
11:38:14 <ricky_clarkson> Ok, I get that.  I think I'll be able to take it from here, thanks.
11:38:26 <dons> as long as you spot that == is overloaded here
11:38:31 <ricky_clarkson> I think I had the idea that Eq stuff was checked statically but done dynamically.
11:38:58 <dons> the call to == might be via an indirection into an instance dictionary
11:39:06 <dons> depending on what the compiler could work out
11:39:07 <phlpp> hi
11:39:33 <dons> hey phlpp
11:39:35 <phlpp> dons: is it possible that your talk, xmonad.mov, has some sound issues?
11:39:41 <phlpp> it's around minute 14, or 15
11:39:47 <dons> oh, hmm. i'd not noticed any
11:39:55 <dons> the sound is a bit poor, but not too bad
11:39:56 <ricky_clarkson> Does Scala have something equivalent, but probably with a different name?
11:39:59 <phlpp> perhaps it's just a bug of my VLC
11:40:01 <dmwit> phlpp: It seemed okay when I watched it.
11:40:05 <dons> unless you consider my accent a bug?
11:40:14 <dons> which apparently some people do, LoganCapaldo !
11:40:14 <phlpp> :D
11:40:19 <dmwit> heh
11:40:32 <phlpp> dons: no, your accent is ok. it's was just a bit to fast for me. a lil bit ;)
11:40:32 <dons> ricky_clarkson: i think it has type classes
11:40:35 <pejo> dons, what's wrong with your accent?
11:40:44 <dons> pejo: my vowels aren't american
11:40:49 <dons> :)
11:40:49 <ddarius> polymorphic recursion... existential types...
11:40:49 <LoganCapaldo> huh?
11:41:05 <dons> LoganCapaldo: weren't you complaining about my pronunciation of "API" the other day?
11:41:15 <LoganCapaldo> I have no idea how you pronounce API :)
11:41:26 <dons> oh, ok. someone else with a long camel case nick
11:41:27 <LoganCapaldo> So if I was complaining about it , it was completely baseless
11:41:57 <phlpp> "a -pi" versus "a p i"? :>
11:42:11 <dons> i think the idea was that the 'a' and the 'i' sound too similar
11:42:20 <dons> .nz/.au vowel shift
11:42:27 <dons> ah!
11:42:28 <dons> 07.10.13:06:06:57 <LeCamarade> @tell dons I'm watching your xmonad.mov ... why do you Australians say IPI when you mean API? :o)
11:42:28 <pejo> dons, hm, an australian accent?
11:42:46 * ddarius wants to look at xmonad.mov again now.
11:42:48 <dons> LoganCapaldo: sorry, it was LeCamarade
11:42:55 <pejo> ddarius, heh - I just did.
11:43:18 <dons> not as funny as when my mum mailed me to say that "effectful" wasn't a word
11:43:22 <ricky_clarkson> dons: Londoners do the same.
11:43:22 <dons> so i should stop using it in my talks
11:43:27 <Heffalump> lol
11:43:36 <dons> her suggestion: "effective"
11:43:37 <dons> doh!
11:43:38 <Heffalump> a Haskell fan, then?
11:43:47 <dons> "imperative languages are too effective" doesn't sound right...
11:44:06 <dons> apparently a C fan :)
11:44:23 <pejo> dons, heh. She's obviously interested in how you appear to the world!
11:44:29 <sieni> side-effective
11:44:42 <ddarius> I think I deleted it.
11:44:46 <Korollary> ricocheting
11:44:52 <dons> heh
11:44:55 <LoganCapaldo> Imperative languages are too effecting?
11:45:15 * omnId thinks you should just go with effectful.
11:45:26 <dons> Imperative languages are effectful, Haskell is effective!
11:45:37 <conal> :)
11:45:52 <kolmodin> :D
11:47:28 <omnId> > let f''ktorial n = x where Just x = find (>= 10) (iterate (\i -> (i+1) * (i+2)) 0) in f''ktorial 5
11:47:29 <lambdabot>  12
11:48:16 <LoganCapaldo> you can have ' in the middle of identifiers?
11:48:28 <LoganCapaldo> that question was rhetorical
11:48:38 <dons> > let yes'you'can = True in yes'you'can
11:48:39 <lambdabot>  True
11:48:58 <dons> let heads'n'tails = id in heads'n'tails "haskell"
11:49:01 <dons> :)
11:49:15 <dons> its an underappreciated style
11:49:25 <dons> the only user of which i know if is malcolm wallace
11:49:39 <LoganCapaldo> > let thirty'three'' = (30, 3) in ()
11:49:41 <lambdabot>  ()
11:49:57 <ricky_clarkson> Perhaps useful in copying maths, f, f', f''...
11:50:13 <Korollary> > let guns'n'roses = "never liked them" in True
11:50:13 <LoganCapaldo> well yeah
11:50:14 <lambdabot>  True
11:50:18 <dons> heh
11:50:21 <omnId> yes, priming the end of a name is pretty common.
11:50:30 <LoganCapaldo> I knew you coud have ident', ident'', etc.
11:50:37 <dons> conal: have you heard about or seen these new 'compositing' window managers?
11:50:51 <dons> they use opengl for post-processing the framebuffer, to do arbitrary graphics effects to the desktop
11:50:52 <LoganCapaldo> I was just hiretofore unaware of x'y
11:51:08 <ddarius> LoganCapaldo: Oleg likes that style.
11:51:11 <dons> conal: i'm pondering how we can add support for user-specified compositing to xmonad
11:51:44 <conal> dons: haven't heard of them.  how about a pointer?
11:51:48 <dons> conal: the best example of which is the compiz wm, http://compiz.org/Home/Screenshots
11:51:55 <lambdabot> Title: Compiz.org :: Home/Screenshots - Compiz
11:51:59 <dons> nice examples of say, transparency, 3d effectss and so on
11:52:14 <dons> since you can run arbitrary graphics code after the desktop is drawn, yet still with access to window informatoin
11:52:26 <conal> good idea these days, with so much graphics power.
11:52:44 <dons> a really simple example is shadows around the focused window, http://xmonad.org/images/xmonad_xcompmgr.png
11:53:23 <dons> so its an interesting area, since its really is user-specified graphics manipulation
11:53:31 <ddarius> Yes, because having your desktop on a rotating cube significantly maximizes productivity.
11:53:34 <dons> so needs a reasonable language to make it possible for users to have any hope of writing stuff
11:53:48 <ricky_clarkson> That screenshots page gets my vote, if only for having Hitchhiker's Guide to the Galaxy playing in a window there.
11:53:54 <dons> ddarius: yes, i'm more inclined towards the subtle hints about focus/resizing etc
11:54:21 <dons> conal: more info, http://en.wikipedia.org/wiki/Compiz
11:54:22 <lambdabot> Title: Compiz - Wikipedia, the free encyclopedia
11:54:26 <conal> dons: it'd be a fun project to do something very functional, perhaps in the spirit of pan/pajama or vertigo.
11:54:48 <dons> conal: yeah, its just begging for a good, fast graphics dsl for these user plugins
11:54:52 <dons> to compiz, or others
11:56:19 <conal> one basic question is whether to have a discrete or continuous rendering model before warping.  continuous is more composable with warping, but i don't know if it's practical, given X (and all other window systems afaik).
11:56:59 <monochrom> dons: Oleg writes zip'term in his generic zipper haskell code.
11:57:43 <dons> conal: right, so they might be discrete pixel-ish systems?
11:57:51 <dons> monochrom: oh, good reference
11:58:03 <dons> i'm pondering collecting together all these 'schools' of haskell style
11:58:13 <conal> dons: yeah, usually.  other than NeWS and NeXTstep.
11:58:14 <dons> the { ;; } school of jaded C programmers
11:58:53 <dons> i need to find time to investigate the api they use
11:59:23 <dons> presumably something like render :: FrameBuffer -> [Window Geometries] -> Focus Geometry -> ..
11:59:32 <conal> dons: in any case, it's worth pursuing.  i'm certainly interested.  i've been wanting to get back into 3D stuff.
11:59:43 <dons> its a very user-visible area, and quite active
11:59:56 <dons> a good system could be usable by 10s of thounsands using compiz :)
12:00:10 <monochrom> Methinks all these computationally intensive, heating-producing, CO2-emitting 3D mutilations to the desktop are evil. But I'm old-school.
12:00:46 <conal> dons: that's great motivation. :)
12:00:49 <dmwit> dons: It may need some state; the "wobbly windows" effect, for example, is time-dependent.
12:01:07 <ricky_clarkson> dons: You pointed at http://fiatdev.com/2007/10/09/is-java-dying in hwn for oct 25th, but the link is dead.
12:01:12 <egl> newby question:  i'm looking for a precise description of the Haskell evaluation model.   i'd like someting a bit more than "rewriting plus evaluation only when needed".
12:01:26 <ricky_clarkson> I think the blog's software's messed up because you can see the content on the main page, but can't follow links.
12:01:33 <dmwit> egl: I think it isn't specified in the Report.
12:01:55 <dons> ricky_clarkson: ah, thanks.
12:02:13 <omnId> dmwit, egl: just that it's non-strict.
12:02:23 <dons> egl: specific implementations use their own models. the report is very loose in terms of what will work
12:02:28 <dons> ?google the spineless tagless G machine
12:02:31 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
12:02:31 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
12:02:32 <monochrom> Hahahaha.  Blog: Java is dying.  Java: That blog is already dead.
12:02:46 <dons> egl: ^^ is a great paper on the ghc runtime
12:02:47 <omnId> GHC uses the STG machine?
12:03:14 <therp> omnid: yes
12:03:18 <conal> dons: i guess the idea would be to make an open-source generator of Compiz plugins, provide some docs, start cranking out cool plugins, and support others making more plugins.
12:03:36 <omnId> therp: I gathered from dons' immediate next comment :)
12:03:57 <dons> conal: yeah, hmm, a generator using one of the guis would be nice.
12:04:08 <dons> which just spits out the plugin out the backend
12:04:17 <conal> dons: "one of the guis"?  do you mean like Eros?
12:04:20 <dons> yeah
12:04:31 <dons> a lot of the plugins are 2d effects, actually
12:04:31 <conal> dons: totally.
12:04:32 <egl> dons: doesn't this make writing portable problems impossible.  similarly in R5RS "implementations of Scheme are required to be properly tail-recursive", but i didn't find anything comparable in the report.
12:04:34 <dons> though 3d is clearly possible
12:05:06 <dons> egl: haskell programs can't depend on implementations details by default. but yes, tail recursion is implemented on all known haskell systems, afaik
12:05:23 <dons> its certainly possible to rely by accident on optimisations that aren't available everywhere
12:05:23 <conal> dons: that's (2d/3d) where a polymorphic framework pays off.
12:05:40 <dons> egl: in practice everyone uses ghc though
12:05:47 <dons> which has its good and bad sides
12:06:09 <Mr_Awesome> i think its mostly good
12:06:14 <dons> though i note all succesful languages have a single implementation which focuses all development effort -- so maybe the benefits of not diluting your developer tool are worth it
12:06:23 <dons> developer /pool/
12:06:29 <Mr_Awesome> agreed
12:06:53 <dons> while lisp and scheme struggle around with too many implementations, with incompatibilities beyond the reports
12:06:59 <conal> dons: i'm planning to release Eros soon.  waiting for Haddock 2.0 & base libs to get along.  i'd love to start doing 3d with it soon.  Compiz would be a great focus.
12:06:59 <LoganCapaldo> dont want to dilute your developer tool :)
12:07:03 <dons> divide and conquer
12:07:19 <LoganCapaldo> I don't know if that applies for C and C++ though
12:07:39 <LoganCapaldo> maybe not as many impls as scheme and lisp, but there are a lot
12:07:41 <dons> if only lennart had been working on ghc for the last 10 years.
12:07:51 <monochrom> C++ has three single implementations. :)
12:08:02 <dons> why waste good compiler people working on minor systems, hmm.
12:08:27 <monochrom> C also has three.
12:08:41 <pejo> dons, re-engineering large parts of an existing compiler to get support for your new cool thing is something most people shy away from.
12:08:42 <dons> icc, gcc, pcc, there's others
12:08:53 <dons> pejo: yes, for research you need small systems
12:09:06 <dufflebunk> Hackage recently had a bktree package added, does anyone have an online reference to what a bktree is?
12:09:07 <pejo> dons, well, by any measure GHC isn't small.
12:09:20 <dons> with the upside that if you get your new idea into ghc, everyone uses it
12:09:34 <dons> dufflebunk: oh, there's a link
12:09:44 <dons> Burhard-Keller trees
12:09:53 <pejo> dons, agreed. It's also dragging along some cruft, and it's "hard" to get things into the 'official' tree.
12:09:55 <egl> dons:  "all successful languages..."  In research languages, yes, but C and Fortran IV provided huge benefits from portability.  Admittedly simpler semantics.
12:10:00 <dons> hmm
12:10:15 <dons> egl: you want *portability* but not nec. multiple compiler implementations
12:10:16 <dufflebunk> dons: Yeah, a google search turned up 3 hits
12:10:23 <dons> dufflebunk: hmm.
12:10:54 <dons> egl: e.g. haskell code is portably by default, since you can't see the underlying hardware anyway. so as long as ghc is portable in turn...
12:11:10 <pejo> dons, of course you have a very valid point that a few more good people could make an enormous impact on the state of GHC, or any other tool.
12:11:19 <dons> dufflebunk: you might want to mail Josef :)
12:11:37 <dons> pejo: yeah, i just lament the talent wasted on hugs/nhc/hbc
12:11:52 <dons> good for research papers, but not the success of haskell in the long run
12:11:54 <sjanssen> egl: Haskell eschews operational semantics in favor of denotational semantics
12:11:59 <dons> same goes for the clean compiler
12:12:02 <sjanssen> egl: this gives implementations much more freedom
12:12:22 <dons> there needs to be a garbage collection of implementations that shouldn't be maintained
12:12:38 <dons> and the developers given commit access to one of the remaining systems :)
12:12:45 <sjanssen> egl: in fact, a language specification that is too narrow could make many optimizations we have now illegal
12:12:47 <dufflebunk> dons: Ok, thanks
12:14:04 <earthy> clean predates haskell
12:14:10 <dmwit> dufflebunk: Probably the result of this blog post:
12:14:12 <dmwit> http://blog.notdot.net/archives/30-Damn-Cool-Algorithms,-Part-1-BK-Trees.html
12:14:12 <pejo> sjanssen, have any examples of optimizations that are allowed with denotational semantics but not operational?
12:14:15 <lambdabot> Title: Damn Cool Algorithms, Part 1: BK-Trees - Nick's blog, http://tinyurl.com/2lnsx7
12:14:54 <dons> ah
12:14:59 <monochrom> without an operational semantics, you can't tell an optimization from a pessimization.
12:15:11 <sjanssen> pejo: strictness analysis evaluates some function arguments earlier than regular laziness
12:15:39 <dons> dufflebunk: yeah, looks like a typo in the .cabal file
12:16:30 <pejo> sjanssen, if that changes termination behavoiur you have an unsound transformation. If not, how can you tell the difference?
12:16:56 <sjanssen> pejo: denotationally, you can't
12:17:13 <monochrom> ok, some optimizations are obvious with just denotational semantics.  id . id = id, the right hand side ought to be clearly more efficient.
12:17:15 <sjanssen> pejo: but strictness analysis does changes the operational semantics
12:18:29 <CUBErt> Is there some library that fetches an webpage and saves the source as a long string?
12:19:00 <CUBErt> Saves the source == make a list of char representing the source code of the html document
12:19:00 <dmwit> I wonder if curl has an Haskell binding.
12:19:06 <masquerade> it does
12:19:07 <masquerade> http://varsztat.com/projects/curl/
12:19:08 * roconnor thinks haskell's denotational semantics are too strict.
12:19:10 <lambdabot> Title: Haskell bindings for libcurl
12:19:13 <dons> CUBErt: sure, the HTTP library, or curl, or tagsoup, or even just calling wget
12:19:21 <sjanssen> roconnor: oh?
12:19:37 <roconnor> case x of () -> foo  should be allowed to optimize to foo.
12:19:39 <CUBErt> dons: wget saves to a file, i dont want to save, i want to put the chars in a list :)
12:19:47 <CUBErt> dons: thx :)
12:19:57 <dmwit> masquerade: Link doesn't work.
12:20:01 <roconnor> stupid CPO
12:20:10 <masquerade> dmwit, check your DNS :)
12:20:11 <allbery_b> wget -O - ?
12:20:16 <dons> CUBErt: see for example http://cale.yi.org/index.php/HRSS
12:20:18 <lambdabot> Title: HRSS - CaleWiki
12:20:21 <monochrom> roconnor: hehehehe
12:20:21 <dmwit> masquerade: Nope, check my spelling. =P
12:20:24 <dmwit> Sorry
12:20:41 <allbery_b> ...but I think someone recently demonstrated that System.Process and pipes don't quite mix
12:20:58 <roconnor> I wonder if it would acceptable to say that it is okay for optimizations to move programs up the CPO
12:21:01 <sjanssen> roconnor: why is this useful?
12:21:01 <CUBErt> Thank you dons
12:21:09 <dons> there's simpler ways too.
12:21:20 <pejo> sjanssen, you must have some transformation using that strictness information, right? If so, why not show that the a program before the transformation is operationally equivalent to the semantics you have for the language?
12:21:24 <dons> i use getHtmlPage :: URI -> Proxy -> IO [String]
12:21:27 <dons> in lambdabot.
12:21:27 <roconnor> sjanssen: um, because it gets rid of an entire case analysis.
12:21:42 <pejo> sjanssen, err, is operationally equivalent to the transformed program.
12:21:48 <roconnor> (causing a memory leak, but that's operational ;)
12:21:53 <dons> from this module, http://code.haskell.org/lambdabot/Lib/Url.hs
12:22:06 <dons> but i'm not sure what the best implementation currently available is. possibly the libcurl bindings
12:22:06 <sjanssen> roconnor: but, in practice, programs don't have stupid case analyses
12:22:16 <dons> in this library, http://code.haskell.org/curl/
12:22:16 <lambdabot> Title: Index of /curl
12:22:40 <roconnor> sjanssen: how about (case x of p1 -> foo; p2 -> foo ...) being reduced to foo
12:22:51 <roconnor> that could happen after inlining
12:22:52 <monochrom> Hmm, depends on who you ask. My supervisor unifies "termination" with "timing", and I agree with him. If you speed up a program "from 10 seconds to 1 second", or "from oo seconds to 1 second", I say it's optimization.
12:23:50 <sjanssen> pejo: the point is that they're not operationally equivalent
12:23:59 <ricky_clarkson> I will double the speed of my non-terminating algorithm.
12:25:00 <sjanssen> pejo: they execute different steps in a different order
12:25:07 <pejo> sjanssen, then you are not observing termination from the outside.
12:25:22 <conal> maybe there's a nice denotational way to unify optimization & termination: as a function from computation ticks to what's known about the value after that many ticks of computation.
12:25:52 <conal> then an optimization makes a value more defined.
12:25:56 <monochrom> Yes, conal, that's what my supervisor does.
12:25:59 <conal> and pessimization makes it less defined.
12:26:09 <conal> monochrom: who's your supervisor?
12:26:17 <monochrom> Eric C. R. Hehner.
12:26:18 <roconnor> stick all your code in the optimizing monad!
12:27:14 <monochrom> Actually, not exactly the same. But his semantics includes a ghost variable for an imaginary clock. Also his does imperative programming.
12:27:42 <pejo> conal, Sands has described ticks in the improvement theory papers as well. But that's operational semantics though.
12:27:46 <sjanssen> pejo: perhaps I mean "equivalent, but not the same"?
12:28:25 <roconnor> @quote equality
12:28:25 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
12:28:35 <sjanssen> pejo: of course the end result of the program is the same.  But, adhering to a very strict operational semantics can outlaw certain evaluation schemes, right?
12:29:11 <roconnor> @quote divides
12:29:11 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
12:32:30 <conal> speaking of semantics, I've started to play with the "model-based testing" idea from bytestring (or did it come from somewhere else?).  the trick is to provide a model for a type, and then specify operations in terms of corresponding operations on the model.
12:32:56 <monochrom> Hmm, function from time to the answer CPO is something I haven't really thought of. May be very useful!
12:32:56 <dons> i think its been thought of before, i suspect the first QC paper mentions it
12:33:03 <dons> we certainly discussed it interms of bytestring the other day
12:33:11 <dons> since that's the main testing mechanism in bytestring
12:33:30 <dons> conal: so its a cheap approximating of model checking, i guess
12:33:43 <dons> which makes it feasible to do for small projects
12:33:53 * dons out and about
12:34:12 <conal> it's making a big impact on my programming process.  now i'm making simple denotational-semantics-style models, whose purpose is just to specify other types.
12:34:20 <roconnor> model for a type?
12:34:33 <monochrom> model for a data structure
12:34:56 <roconnor> isn't the data structure itself a model of the data structure?
12:35:24 <conal> perhaps model for an "interface"
12:35:38 <pejo> sjanssen, I was kind of hoping that someone would jump in and tell us all the details. Half of the point of having a semantics is to outlaw certain evaluation schemes though.
12:35:42 <roconnor> are we taking about two implementations of an interface, and secifying one implemenation in terms of the other?
12:35:43 <monochrom> You implement a data structure two ways. One is beautiful and "so simple it's obviously correct", but inefficient. The other is efficient but ugly. Use one to verify the other.
12:35:55 <roconnor> ah
12:35:55 <conal> roconnor:  yes
12:36:33 <conal> and one can still specify properties on the simple implementation ("semantics").
12:36:36 <roconnor> I do that with my real numbers in Coq.  My proof that my functions are correct say that my functions do the same thing that Luis's functions do.
12:36:52 <monochrom> You can of course replace my "data structure" with "abstract type", "module", "API", ...
12:36:54 <roconnor> but my functions run faster
12:37:19 <roconnor> but his functions are easier to reason about.
12:37:22 <conal> for instance, i have infinite binary trees modeled by functions from direction streams to values.
12:37:26 <pejo> conal, that stuff sounds very interesting, too.
12:37:32 <conal> and bi-directionally infinite streams modeled as functions from integers to values.
12:38:18 <conal> pejo: and very simple
12:38:42 <monochrom> "data refinement", "simulation", "bisimulation"
12:39:01 <jgrimes> I like the haskell solution on this page: http://www.paulgraham.com/accgen.html
12:39:23 <jgrimes> I wonder if that was on purpose...
12:39:36 <monochrom> In industry there is also the related notion of "reference implementation".
12:39:52 <conal> i'm working on a representation for functions over continuous domains -- one that exploits the caching nature of lazy evaluation on data structures.
12:40:17 <conal> the usual function representation is the model.
12:41:54 <conal> if it works out, it will address a fundamental shortcoming of Pan, which is that it rerenders discrete images from scratch when the user zooms/pans, or tweaks parameters.
12:42:19 <monochrom> wicked
12:43:12 <conal> and a drawback of memoization, which is that it requires exact hits.
12:43:17 <monochrom> math pays off!
12:43:47 <pejo> conal, speaking of things you're working on - you mentioned writing a blogpost about reactivity (?) earlier?
12:43:49 <monochrom> "The best practice is inspired by theory." - Donald Knuth.
12:46:06 <conal> pejo: yes i did, and no i haven't written it up yet.  there are some notes on my online journal at http://conal.net/journal/#2007-10-10 .
12:46:48 <conal> pejo: probably too terse to be helpful for anything but reminding me of the idea.
12:48:21 <conal> monochrom: thanks.  i like that DK quote.
12:48:57 <monochrom> Do you also know his other quote, "The best theory is inspired by practice." :)
12:49:16 <conal> monochrom: nope.  great one also!
12:49:44 <ricky_clarkson> EWD seems more quotable.
12:49:56 <monochrom> He gave a talk to say how the two work hand-in-hand. The two sentences were shown at the end.
12:50:49 <conal> monochrom: i think i heard that talk (or similar) in 1989 or 1990 in san francisco.
12:51:20 <conal> he also posed a challenge of understanding everything going on in your computer's CPU during a 1 second interval.
12:52:10 <monochrom> That is tall order. I have only come to terms to a qualitative picture of the quantum mechanics going on there lately! XD
12:52:48 <conal> monochrom: right :)  what i really meant was the instructions executed and why.
12:55:21 <hpaste>  conal pasted "model example: bi-directional streams" at http://hpaste.org/3495
13:01:01 <hpaste>  conal annotated "model example: bi-directional streams" with "representation example" at http://hpaste.org/3495#a1
13:03:36 <kolmodin> http://www.ubergeek.tv/article.php?pid=54
13:03:37 <lambdabot> Title: ::uberGeek::Toons::Switch to Linux()
13:10:19 <roconnor> why is NondetT faster than ListT?
13:10:42 <dons> different representation type?
13:10:57 <roconnor> newtype NondetT m a
13:10:57 <roconnor>   = NondetT { foldNondetT :: (forall b. (a -> m b -> m b) -> m b -> m b) }
13:11:08 <roconnor> how can that be a better representation?
13:11:16 <sjanssen> @src ListT
13:11:17 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:11:18 <dons> Igloo: last night's snapshot is failing with,
13:11:20 <dons> echo "<!DOCTYPE sect1 [<!ENTITY ndash  \"-\"> \ <!ENTITY ldquo  \"\`\"> \ <!ENTITY rdquo  \"'\">]>" >> flags.xml
13:11:23 <dons> tail -n +2 ../users_guide/flags.xml >> flags.xml
13:11:26 <dons> flags.xsl flags.xml > ghc.1
13:11:28 <dons> /bin/sh: flags.xsl: not found
13:11:43 <roconnor> maybe the operations are better somehow.
13:15:00 <ddarius> roconnor: ListT m would be isomorphic to m (forall b. (a -> b -> b) -> b -> b)
13:16:19 <roconnor> well, forget about the monad transfomer part
13:16:46 <roconnor> just [a] vs (forall b. (a -> b -> b) -> b -> b)
13:16:58 <roconnor> I mean, I half expect [a] to be implemented as (forall b. (a -> b -> b) -> b -> b)
13:18:08 <ddarius> There shouldn't, but might, be a meaningful difference in performance between those types.
13:18:32 <roconnor> ``It's twice as fast when compiled with optimisations but a little slower without.
13:18:33 <ddarius> Actually, I take that back.
13:18:47 <ddarius> roconnor: What is that quote referring to?
13:18:54 <roconnor> http://www.haskell.org/haskellwiki/Sudoku#Monadic_Non-Deterministic_Solver
13:18:56 <lambdabot> Title: Sudoku - HaskellWiki, http://tinyurl.com/y4lh72
13:19:17 <ddarius> But anyways, I take it back because the Church encoded version does not support certain operations efficiently.
13:19:17 <roconnor> [Nondet] is twice as fast [as lists]...
13:19:40 <ddarius> You have to do everything with foldr effectively.
13:19:49 <roconnor> indeed, we are just looking a the list operation involved for the monad
13:20:04 <roconnor> but still, I don't see why it would be faster
13:20:17 <roconnor> maybe it could be
13:21:23 <volk> how can I convert an integer into a string?
13:21:41 <viklund> volk: show
13:21:55 <ddarius> roconnor: Well one thing we can say is that forall b. (a -> b -> b) -> b -> b is a more restricted type than [a]
13:21:55 <Laney> @t read
13:21:55 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:22:01 <Laney> @type read
13:22:03 <lambdabot> forall a. (Read a) => String -> a
13:22:11 <Laney> @type show
13:22:11 <viklund> hehe
13:22:12 <lambdabot> forall a. (Show a) => a -> String
13:22:18 <viklund> @type show
13:22:19 <lambdabot> forall a. (Show a) => a -> String
13:23:10 <roconnor> ddarius: I notice that Nondet a is Cont (b -> b) a
13:23:23 <roconnor> er
13:23:30 <roconnor> Nondet a is forall b. Cont (b -> b) a
13:23:31 <Igloo> dons: Thanks, should already be fixed
13:24:49 <wli> back
13:49:43 <viklund> aha!
13:50:02 <omnId> aha?
13:50:08 <viklund> i'm getting closer to understand the powerset definition
13:50:57 <omnId> just take the definition and substitute in the definitions of (>>=) and return for the [] Monad.
13:51:20 <viklund> yes, and what I'm starting to understand is the list monad...
13:52:02 <viklund> it was the if part in filterM that didnt make sense before with the constant [True, False] function
13:52:08 <viklund> not it clicked
13:52:13 <viklund> s/not/now/
13:52:33 <viklund> http://www.haskell.org/haskellwiki/Monads_as_Containers
13:52:35 <lambdabot> Title: Monads as containers - HaskellWiki
13:52:36 <viklund> is really good
13:53:18 <omnId> (>>=) is concatMap (modulo arg order), so the if flg then (x:) else id is mapped over the [True, False] given from each element, and the results concatted.
13:54:08 <viklund> yes, if you had given that explanation an hour ago I wouldn't have understood it
13:54:14 <omnId> in the list monad, you can think of "the rest of the do block" as concatMapped over each bound result.
13:54:14 <viklund> now I did
13:54:24 <earthy> !sigh
14:05:38 <Cale> > filterM (const [True, False]) [1..3]
14:05:43 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
14:06:01 <viklund> ;)
14:06:29 <Cale> It's actually surprisingly clear once you know what the list monad is all about.
14:06:41 <viklund> yes
14:06:48 <Cale> "for each element of the list, keep it, or don't."
14:06:55 <viklund> playing around with >>= has helped alot
14:10:11 <enzo> hey, how can i make lambdabot eta reduce an expression to point-free form?
14:10:29 <omnId>  @pl
14:10:29 <monochrom> @pl \x -> f x
14:10:29 <lambdabot> f
14:10:39 <enzo> thanks
14:10:48 <omnId> for "pointless" :)
14:10:52 <lament> @pl \x -> oerjan
14:10:52 <lambdabot> const oerjan
14:11:13 <oerjan> @pl \x y -> lament y x
14:11:13 <lambdabot> flip lament
14:11:30 <enzo> @pl \u v -> sqrt (foldr ((+) . (^2)) 0 (zipWith (-) u v))
14:11:30 <lambdabot> ((sqrt . foldr ((+) . (^ 2)) 0) .) . zipWith (-)
14:11:34 <enzo> awesome
14:12:29 <TomMD> @pl \c a b -> c ? a : b
14:12:29 <lambdabot> ((:) .) . (?)
14:13:14 <omnId> > let pset [] = [[]]; pset (x:xs) = concatMap (\flg -> concatMap (\ys -> [if flg then x:ys else ys]) (pset xs)) [True, False] in pset [1..3]
14:13:15 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
14:13:18 <omnId> viklund: ^
14:13:25 <TomMD> lambdabot assumes '?' is valid?
14:13:41 <omnId>  @pl doesn't touch your names
14:13:44 <allbery_b> it;'s as valid an indentifier as any ther
14:13:53 <allbery_b> @src on
14:13:54 <lambdabot> (*) `on` f = \x y -> f x * f y
14:14:03 <viklund> nice
14:14:54 <enzo> lambdabot is cool
14:14:55 <omnId> viklund: just substituted in [True, False] for p x, translated from do notation to (>>=), and changed (>>=) to concatMap
14:15:00 <enzo> whoever wrote him is the man
14:15:04 <omnId> @botsnack
14:15:04 <lambdabot> :)
14:15:09 <oerjan> TomMD: unless you use the implicit variable extension, ? is a valid operator name
14:15:14 <omnId> lambdabot++
14:15:20 <enzo> > 3 + 4
14:15:22 <lambdabot>  7
14:15:26 <TomMD> @botsmack
14:15:26 <lambdabot> :)
14:15:47 <TomMD> ... I think something is wrong with this bot.  Mentally, I mean.
14:16:07 <omnId> @quote lambdabot
14:16:08 <lambdabot> lambdabot says: Listen, broccoli brains, I don't have time to listen to this trash.
14:16:08 <oerjan> @abusers
14:16:09 <lambdabot> Maximum users seen in #haskell: 420, currently: 402 (95.7%), active: 17 (4.2%)
14:16:17 <ari> @ari
14:16:18 <lambdabot> Drink up, me 'earties
14:16:21 <monochrom> The bot excuses your typos.
14:28:00 <TomMD> can lambdabot automagically convert monadic operators into a do notation?  That would be scary ugly, but kinda neat.
14:29:30 <omnId> @undo do {pat <- expr; stmt}
14:29:30 <lambdabot> expr >>= \ pat -> stmt
14:30:00 <omnId> @redo expr >>= \ pat -> stmt
14:30:00 <lambdabot> do { pat <- expr; stmt}
14:30:52 <oerjan> @redo liftM f x
14:30:53 <lambdabot> liftM f x
14:30:58 <oerjan> bah
14:30:59 <omnId> not much magic there.  The translation is pretty mechanical
14:31:06 <omnId> @. redo src liftM
14:31:06 <lambdabot> ()
14:31:17 <allbery_b> heh
14:31:20 <omnId> doesn't like declarations, only expressions.
14:31:23 <omnId> @src liftM
14:31:23 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:31:24 <TomMD> @undo do { pat1 <- expr1; pat2 <- expr2; stmt }
14:31:24 <lambdabot> expr1 >>= \ pat1 -> expr2 >>= \ pat2 -> stmt
14:32:02 <TomMD> Let me guess, there is a quickcheck that undo ( redo x) == x
14:32:16 <TomMD> I love referential transparency.
14:32:24 <omnId> @undo do {(x:xs) <- ys; return x}
14:32:24 <lambdabot> ys >>= \ a -> case a of { (x : xs) -> return x; _ -> fail ""}
14:32:36 <omnId> gotta love fail.
14:33:10 <TomMD> Not really
14:33:19 <allbery_b> sarcasm
14:33:27 <TomMD> I wish we had a pure method to simulate thrown exceptions.
14:33:28 <omnId> @. redo undo do {(x:xs) <- ys; return x}
14:33:29 <lambdabot> do { (x : xs) <- ys; return x}
14:33:38 <omnId> TomMD: mzero
14:33:47 * oerjan suddenly visualizes @undo putting one of lambdabot's usual friendly error messages in fail
14:33:50 <TomMD> Yes, well then you must lift everything.
14:34:18 <monochrom> ys >>= \ a -> case a of { (x : xs) -> return x; _ -> fail "and you call yourself a computer scientist!"}
14:34:21 <TomMD> oerjan: lol, thats a good idea
14:35:15 <TomMD> @src humanBrain
14:35:15 <oerjan> well, except for the length limit
14:35:15 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:35:35 <omnId> @source Bot.Brain
14:35:35 <lambdabot> Bot.Brain not available
14:36:03 <allbery_b> @source Bot.Pinky
14:36:03 <lambdabot> Bot.Pinky not available
14:36:04 <allbery_b> ")
14:36:30 <omnId> @brain Are you pondering what I'm pondering?
14:36:30 <lambdabot> Promise me something, Pinky. Never breed.
14:36:48 <omnId> aww, that only works when it's a Pinky line.
14:37:20 <omnId>  @pinky should be seperate from @brain
14:37:31 <mae> hi i'm having an issue with building the SAX part of Haxml, can someone plese have a look at this pastebin, I used verbosity level 5: http://rafb.net/p/wu9IWN93.html
14:47:44 <twanvl> omnId: fixed in the head
14:48:17 <omnId> twanvl: hm?  The @brain thing?  I was half joking!
14:48:57 <omnId> or the @pl thing?
14:49:05 <omnId>  @undo rather
14:50:13 <allbery_b> heh
14:51:56 <monochrom> http://arcanux.org/lambdacats_2.html#entry3
14:51:57 <lambdabot> Title: Lambdacats
14:53:55 <Saizan> @pinky
14:53:56 <lambdabot> ()
14:54:59 <oerjan> hm, does that numbering system shift everything when someone adds a new cat?
14:55:33 <byorgey> oerjan: I think it does.
14:56:01 * omnId laughs a the latest one, concerning the MR.
14:56:05 <omnId> at*
14:56:40 <omnId> MONOMORFIZM RESTIKSHUN
15:02:08 <monochrom> lambdacats comics uses de Bruijn numbering.
15:02:31 <dons> what else? :)
15:03:29 <Igloo> Higher order abstract comics?
15:03:40 <dons> this is a great one, http://arcanux.org/lambdacats/type-woes.jpg
15:06:05 <byorgey> heh, yeah, I love that one
15:08:08 <SamB> hehehe
15:08:34 <eventualbuddha> is there a good place to get an explanation for how haskell works, in particular how it determines the type of variables/functions when it is left implicit?
15:08:53 <allbery_b> @googlel hindley-milner type inference
15:08:56 <lambdabot> http://en.wikipedia.org/wiki/Type_inference
15:08:56 <lambdabot> Title: Type inference - Wikipedia, the free encyclopedia
15:09:06 <allbery_b> hm, tht might not be the ideal starting point
15:09:31 <omnId> well, it know that if f :: a -> b, then in the expression (f x), x :: a, and the whole expression :: b.
15:09:50 <oerjan> er, that page's technical description is pretty awful, i recall
15:10:10 <Cale> Or if it knows that x :: a, and the whole expression :: b, then f :: a -> b
15:10:11 <allbery_b> <allbery_b> hm, tht might not be the ideal starting point'
15:10:40 <allbery_b> I think the best place for an explanation is _Types and Programming Languages_
15:11:07 <omnId> simple data constructors have the type declared at definition, they hook together with others in expressions to give an overall type
15:11:08 <dons> eventualbuddha: haskell uses a general type inferences scheme called 'hindley-milner type inference'. a good introductoin is here, http://web.cecs.pdx.edu/~mpj/pubs/thih.html
15:11:09 <lambdabot> Title: Typing Haskell in Haskell
15:11:11 <Cale> Basically what it does is collects up a set of equations on the types of every expression and variable, and then solves that system of equations.
15:11:57 <dons> for a good intro see www.cs.cmu.edu/~rwh/plbook/book.pdf
15:12:19 <omnId> for this definition: compose f g x = f (g x), it starts not knowing anything about f, g, and x's types, so it assigns them catch-all variables: f :: a, g :: b, x :: c
15:12:32 <dons> yeah, all the possible types yield a set of contraints, which are then solved, yielding most general types for every variable
15:12:37 <eventualbuddha> dons: cool, thanks
15:12:41 <omnId> now, x is being passed to g so we can refine g's type into: g :: c -> d
15:13:10 <omnId> so (g x) :: d
15:13:26 <dons> eventualbuddha: reimplementing the type inference system is a tutorial question for a course i tutored, http://cgi.cse.unsw.edu.au/~cs3161/tutorials.php
15:13:27 <lambdabot> Title: Tutorials : COMP3161/9161 Concepts of Progamming Languages 2007/S2
15:13:27 <omnId> (g x) is being passed into f, so we know f :: d -> e
15:13:38 <dons> eventualbuddha: so you could implement it in 50 lines of haskell or less for a small language
15:13:45 <omnId> x :: c, g :: c -> d, f :: d -> e
15:13:48 <dons> if you're keen to really grok it (which is very worthwhile)
15:14:14 <eventualbuddha> dons: sweet. i'm toying around with creating my own language and that's a feature i'd like to have, so i want to understand what's involved in it
15:14:24 <omnId> compose takes these three arguments (in f,g,x order) and makes a new values of some type t.
15:14:39 <omnId> compose :: (d -> e) -> (c -> d) -> c -> t
15:14:49 <omnId> @type \f g x -> f (g x)
15:14:53 <lambdabot> forall t t1 t2. (t1 -> t2) -> (t -> t1) -> t -> t2
15:15:06 <omnId> modulo names, that's the same type.
15:15:17 <eventualbuddha> nifty, thanks omnId
15:15:43 <omnId> the inferencer matches up parts where it can based on the info it already knows.
15:16:19 <dons> eventualbuddha: i'd definitely recommend bob harper's programming language design book then, www.cs.cmu.edu/~rwh/plbook/book.pdf
15:16:37 <dons> maybe along with doing that course http://cgi.cse.unsw.edu.au/~cs3161
15:16:37 <lambdabot> Title: Notices : COMP3161/9161 Concepts of Progamming Languages 2007/S2
15:16:40 <dons> in your spare time.
15:18:05 <dons> esp. if you want to grok standard haskell-like type systems
15:22:04 <omnId> oops, my explanation had a whole.  I said (g x) :: d, and f :: d -> e, so the right-hand-side of compose, (f (g x)) :: e.
15:22:53 <omnId> thus compose :: (d -> e) -> (c -> d) -> c -> e.  You just put the param types on the left of the last -> and the rhs's type on its right.
15:24:07 <omnId> (if you didn't know, you can read '::' as 'has type', to make the sentence flow better)
15:24:52 <omnId> had a hole*, sentences*
15:25:00 * omnId is typoey today
15:25:13 <omnId> NEED FOODZ
15:29:44 <dons> re. lisp: "Most developers know it as the language with all the parenthesis which is loved
15:29:47 <dons> by academic nerds who have no girl friends and get paid to grade papers. Maybe, but that is actually
15:29:50 <dons> more true about Erland and Haskell than about LISP."
15:30:19 <dons> we get paid to *write* papers! how offensive
15:30:46 <monochrom> Didn't you also get paid to grade student homework?
15:30:50 <dons> the erlang guys would be really pissed though, since they don't write or grade papers, since they're too busy reimplementing the web
15:30:52 * allbery_b doesn't get paid for either...
15:31:28 <pejo> dons, 'reimplementing the web'?
15:33:46 <monochrom> Methinks there is no reason to pay attention to ignorant remarks.
15:34:16 <monochrom> Also, if you respond with "we write papers", that's just strengthen the "academic nerd" image.
15:34:51 <dons> no, i just thought it was funny :)
15:35:11 <monochrom> Yes. :)
15:35:22 <oerjan> you could make all parentheses expandable into layout
15:35:31 <oerjan> (wrong channel)
15:37:18 <Korollary> everybody loves a nerdfight
15:37:44 <Korollary> glasses fly, profanities are uttered with a stutter
15:39:20 <dons> its no fun picking on lisp though. dead corpses don't answer back with witty replies
15:40:14 <dons> Korollary: so when are you going  to upload a library to hackage?
15:40:23 <dons> i figure your yearly dues are up now
15:41:18 <Korollary> dons: Before that, when am I going to download a library from hackage?
15:41:42 <dons> good question1
15:42:02 <dons> we had 63 updates since the last hwn, so its about time you used some of that code
15:59:03 <enzo> hey, does anyone know how i would check my computer's ip address using haskell?  i know the name of the interface
15:59:33 <enzo> it's kind of low-level so i'm not sure where to proceed
15:59:56 <psykon> can you even do that in POSIX ?
16:01:02 <mrd> System.Posix.* if so
16:01:22 <mrd> maybe it's part of the Network.BSD interface?
16:01:30 <allbery_b> enumerating interface addresses is extremely system dependent
16:01:56 <enzo> so maybe i should just read /proc/net/dev directly then
16:02:04 <pejo> enzo, how would you do it in any language?
16:02:07 <allbery_b> pretty much the most portable way to do it (and even that has problems) is to parse ifconfig -a output
16:02:13 <psykon> why do you need to do that ?
16:02:27 <psykon> i mean, know the address of a specific device
16:02:31 <allbery_b> if all you care about is linux, /proc/net is probably the way to go
16:02:36 <enzo> just for fun
16:02:40 <enzo> no particular reason
16:02:49 <enzo> i naively assumed it wouldn't be too complex
16:03:01 <enzo> so far all my haskell programs have been very functional
16:03:13 <psykon> it isn't, there's just no portable way to do it
16:03:14 <enzo> i thought it might be nice to try to do some IO monad stuff
16:03:37 <allbery_b> you have chosen... poorly
16:03:39 <allbery_b> :>
16:03:49 <enzo> sure looks that way :)
16:03:54 <mrd> parsing /proc/net is a good exercise
16:04:03 <enzo> yeah, i guess so
16:04:24 <enzo> thanks guys
16:34:58 <gwern> so I'm interested at looking at a shell written in haskell. is there anything more advanced or capable than hashell?
16:35:32 <gwern> (by advanced, I'm referring to completion, not power)
16:42:49 <pmatos> Hello, I'm trying to use the ByteString stuff at http://haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html but I'm importing it as  import qualified Data.ByteString as B and I'm getting Could not find module `Data.ByteString' from GHC.
16:42:50 <lambdabot> http://tinyurl.com/wn5rt
16:42:51 <pmatos> Why is this?
16:43:26 <allbery_b> ghc --make ?
16:43:48 <allbery_b> (is it actually in base still at this point?  lot of unbundling going on...)
16:44:02 <allbery_b> what ghc version?
16:44:08 <pmatos> allbery_b: ? I'm trying to load the file in emacs in ghci
16:44:14 * omnId has it in 6.6.1, and hasn't installed any libraries
16:44:41 <pmatos> allbery_b: ghci 6.4.2
16:44:43 <allbery_b> 6.6/6.6.1 have it in base.  6.4 and earlier don't.  6.87+ I'm not sure if ti's been unbundled again or not
16:45:02 <pmatos> allbery_b: oh, that's it then. thanks... I'll update my GHC. :-)
16:59:27 <sorear> pmatos: get 'fps'
17:00:03 <sorear> pmatos: 6.4.2 supports bytestrings perfectly well, they just weren't assimilated into the standard libraries until 6.6.0
17:00:33 <sorear> @where fps
17:00:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
17:01:00 <sorear> ah good, don's page at UNSW is still accessible
17:04:08 <pmatos> sorear: what do you mean fps?
17:04:23 <pmatos> sorear: oh, sorry lambdabot explained
17:04:23 <pmatos> heh
17:14:29 <ac> > take 10 $ iterate ((+1).(flip mod 10)) 3
17:14:31 <lambdabot>  [3,4,5,6,7,8,9,10,1,2]
17:14:37 <ac> how do I get a 0 in place of the 10?
17:15:32 <conal> > take 10 $ iterate ((flip mod 10).(+1)) 3
17:15:34 <lambdabot>  [3,4,5,6,7,8,9,0,1,2]
17:16:06 <ac> right. :)
17:17:11 <_achilles_> makes sense! :)
17:17:46 <omnId> > drop 2 (cycle [0..9])
17:17:48 <lambdabot>  [2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9...
17:18:18 <ac> omnId: I figured there was a much more elegant way
17:18:24 <omnId> > take 10 $ drop 3 (cycle [0..9])
17:18:25 <lambdabot>  [3,4,5,6,7,8,9,0,1,2]
17:19:08 <omnId> > take 10 . cycle $ [3..9] ++ [0,1,2] -- without the drop even
17:19:09 <lambdabot>  [3,4,5,6,7,8,9,0,1,2]
17:19:36 <omnId> erm, I guess the cycle and take isn't neccessary in that case :)
17:21:37 <ac> omnId: I don't think that quite works...
17:21:45 <ac> > [9..9] ++ [0..9]
17:21:47 <lambdabot>  [9,0,1,2,3,4,5,6,7,8,9]
17:21:55 <omnId> > [3..9] ++ [0..2]
17:21:57 <lambdabot>  [3,4,5,6,7,8,9,0,1,2]
17:22:26 <ac> er, I guess it would be
17:22:33 <ac> > [9..9[ ++ [0..8]
17:22:34 <lambdabot>  Parse error at "++" (column 8)
17:22:39 <ac> of course it works
17:23:10 <ac> > [10..9] ++ [0..9]
17:23:11 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
17:25:05 <ac> omnId: any way, that method is confusing me a lot more than: take 10 $ drop n $ cycle [0..9]
17:25:12 <omnId> :)
17:25:31 <omnId> it's just that you do the cycle/take yourself :)
17:26:28 <omnId> though, yes, it's not as simple to do with varying parameters
17:26:47 <ac> ah, that's what it would be for the edge case:
17:26:56 <ac> > [0..9] ++ [0..(-1)]
17:26:58 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
17:27:26 <omnId> hehe, you just can't break it :)
17:27:45 <ac> I figured negative numbers wourd break the .. operator
17:28:21 <omnId> enumFromTo is defined as going up.  You must use enumFromThenTo to go backwards.
17:28:31 <omnId> > [0,-1..(-3)]
17:28:33 <lambdabot>  [0,-1,-2,-3]
17:41:42 <ac> does foo { ... } bind tighter than function application?
17:42:03 <sphynx> hi all!
17:42:56 <ac> meaning, in "func foo { blah = ... }" does the record modifier apply to "foo", or "func foo"?
17:43:23 <sphynx> can I use Data.Binary.Put from binary-0.3 for serialization of custom types or it can put only some standard types like Word8, etc. etc. ?
17:43:46 <omnId> ac: not sure, try an expression.
17:45:38 <sphynx> I've read 'Pickler combinators' functional pearl recently and just want to know about haskell serialization-related libraries - what features do they support
17:46:01 <omnId> data Foo = Foo {x :: Int} deriving (Show); foo = Foo {x=1}; bar f = f {x=x f + 1}
17:46:01 <omnId> *Main> bar foo {x = 3}
17:46:01 <omnId> Foo {x = 4}
17:46:15 <sjanssen> sphynx: you can build serializers from the primitives for Word8, Int, etc.
17:46:24 <omnId> looks like (bar (foo {...}))
17:46:26 <Saizan> sphynx: you can write your own Binary instance, or use "tools" like the derive package to derive it automatically with TH
17:46:27 <thoughtpolice> sphynx: you can create binary instances for any arbitrary data type
17:46:52 <thoughtpolice> as long as your data type is an instance of the Binary class.
17:47:04 <ac> how do I IO-ify a variable? I want a data constructor for the IO monad
17:47:13 <Japsu> ac: return
17:47:13 <sjanssen> ac: return
17:47:14 <omnId> return
17:47:18 <ac> hah
17:47:20 <Japsu> @quote stereo
17:47:20 <lambdabot> z0d says: What was the stereo quote?
17:47:23 <Japsu> @quote stereo
17:47:23 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
17:47:25 <thoughtpolice> sphynx: see here for an example, http://www.cse.unsw.edu.au/~dons/binary.html
17:47:26 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
17:47:27 <Japsu> @quote stereo
17:47:28 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
17:47:36 <thoughtpolice> basic example of serializing a small AST
17:47:41 <Saizan> Japsu: the real one has been removed
17:47:49 * omnId would laugh if there was a stereo '@quote stereo'
17:48:04 <sjanssen> omnId: it's happened
17:48:05 <Japsu> Saizan: yeah, now we need three metastereo quotes just to make up for the loss :<
17:48:15 <ari> I think we need to move on to 5.1
17:48:23 <sphynx> thanks!
17:49:05 <thoughtpolice> sphynx: no prob. :) binary is the only serialization library I've used and I've only used it in my irc bot, but from what I hear its really nifty :)
17:49:23 <thoughtpolice> it's worked well for what my bot needed it for.
17:49:48 <Japsu> sphynx: Data.Derive can also automatically derive Binary instances for your data types
17:50:17 <sphynx> automatical deriving looks cool! :)
17:50:35 <Japsu> yeah, reduces the manual labor ;)
17:52:26 <thoughtpolice> speaking of, I think I just eliminated the last major bug I can see in my bot. :)
17:52:48 <thoughtpolice> monad transformers rule.
17:52:59 <thoughtpolice> or I guess I should just say monads in general. :)
17:53:04 <omnId> mtl++
17:56:01 <ddarius> omnId: I think there is one
17:56:07 <ddarius> @quote quote.stereo
17:56:08 <lambdabot> No quotes match. Where did you learn to type?
17:56:11 <ddarius> Or not.
17:57:02 <omnId> not a '@quote stereo' quote, a stereo '@quote stereo'.  Though I suppose a stereo '@quote stereo' quote would be okay :)
17:57:49 <ddarius> There has definitely been stereo @quote stereo-ing
17:59:54 <omnId> now if only others wondered this, too, there could be a stereo "'stereo "@quote stereo"' quote" quote.
18:00:46 <ac> Silly question: is it possible to have recursive type signatures? Like "foo :: a -> a -> a -> a -> ...."
18:00:54 <omnId> ac: with typeclasses
18:01:07 <sjanssen> ac: type signatures must be finite
18:01:11 <omnId> Result r => a -> r
18:01:19 <omnId> instance Result SomeType
18:01:29 <sjanssen> you can work around that with newtypes
18:01:30 <omnId> instance Result r => Result (a -> r)
18:02:21 <ac> what I want is a function that takes a type a, and performs a side effect, then returns a different function that takes type a
18:02:30 <ddarius> ac: Use a newtype.
18:02:55 <ddarius> newtype InfinitaryTree a = IT (a -> IT a)
18:04:04 <ac> I guess what I want is foo :: a -> (IO a, a -> (IO a, a -> (IO a, ...
18:04:10 <ddarius> :t \a -> do putStrLn "Foo"; return (\b -> a + b)
18:04:11 <lambdabot> forall a. (Num a) => a -> IO (a -> a)
18:04:35 <ddarius> newtype IOStream a = IOStream (a -> (IO a, IOStream a))
18:04:40 <ac> meaning it takes a, and returns a tupple of IO a and a new function
18:05:01 <ac> yeah that
18:05:28 <ddarius> Actually, InfinitaryIOTree is probably better for than (though it isn't infinitary if a is a type with a finite number of values...)
18:06:24 <ddarius> If this was O'Caml and you enabled the -rectypes extension you could make f :: b where b = a -> (IO a, b)
18:06:55 <omnId> could you type a working Y with rectypes?
18:07:05 <ddarius> omnId: Yes.
18:08:19 <ac> another way of doing this would be to simply stick an IORef in my function, I think
18:08:30 <ac> that would be a lot simpler
18:09:15 <ddarius> There's nothing wrong with the IOStream type.  Similar things are very common for things like the semantics of concurrent programs.
18:10:03 <ac> I guess the IOStream is more specific for what I'm doing, and for that reason may be easier to understand
18:11:51 <glguy> ?seen dons
18:11:51 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 13m 41s ago.
18:11:58 <glguy> dons: ?
18:20:11 <pmatos> If my function is to receive a list of strings, why can't I have a pattern like: parseHeaderAux "p" : "cnf"  : v : [c] = ...
18:20:21 <mauke> precedence
18:20:29 <mauke> needs more ( )
18:20:30 <pmatos> so I need parens?
18:20:35 <pmatos> okidoki, thank you
18:21:06 <mauke> : [c] looks suspicious
18:21:06 <mauke> did you mean : c?
18:23:58 <allbery_b> cs?
18:27:20 <omnId> if you want to match exactly four strings, the pattern ["p", "cnf", v, c] would be clearer.
18:43:14 <pmatos> omnId: Indeed, that's clearer and that's what I want! :-) Thank you!
18:43:17 <pmatos> heh
18:43:28 <pmatos> oh well, going to bed now. Thank you guys for your help!
18:44:12 <ac> "Couldn't match expected type `[t]' against inferred type `IO ()'"
18:44:14 <ac> Aaaaaaarhg
18:44:24 <mauke> what, that one's easy
18:44:53 <mauke> try to fix "... is less polymorphic than expected"
18:45:10 <ac> but there IS NO [t]
18:45:27 <mauke> don't you believe your compiler? :-)
18:46:56 <ac> Hah. I'm glad I haven't seen "... less polymorphic than expected"
18:48:59 <mauke>     Could not deduce (LayoutTransformer t a1)
18:49:01 <mauke>       from the context (LayoutTransformer t a)
18:49:01 <mauke>       arising from use of `transform' at <interactive>:1:50-60
18:49:01 <mauke>     Possible fix:
18:49:01 <mauke>       add (LayoutTransformer t a1) to the expected type of an expression
18:53:41 <ac> Might there be any way I can get a more specific type than `[t]'?
18:54:16 <wli> Make everything monomorphic. Annotate everything.
18:54:29 <ac> you mean put :: everywhere, and see where your expectations are contradicted?
18:54:52 <omnId> start where it says there's a problem :)
18:54:53 <wli> Yes, though I really do mean monomorphic.
18:54:58 <mauke> you could also hpaste the relevant parts and ask #haskell :-)
18:55:10 <omnId> ac: if it says 'expecting IO ()', then maybe you're using just a list where you should be printing one?
18:55:48 <ac> omnId: the problem is I don't see any lists to speak of on that line
18:56:04 <omnId> you know where hpaste lives :)
18:58:23 <hpaste>  ac pasted "can you solve my type problem?" at http://hpaste.org/3497
18:58:36 <ac> the offending line is #7
18:59:45 <mauke> textureBinding Texture2D $= (Just (panels sliderState ! texNum))
19:00:13 <ac> so where's the [t] in that?
19:00:19 <LoganCapaldo> @type ($=) -- I dunno what this is
19:00:20 <lambdabot> Not in scope: `$='
19:00:28 <sorear> ac: 't' is a tyvar
19:00:38 <omnId> @index
19:00:39 <lambdabot> bzzt
19:00:41 <omnId> @index (!)
19:00:42 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
19:00:43 <mauke> what's the type of ($=) and textureBinding?
19:00:51 <sorear> ac: unification variable, if you know prolog
19:00:52 <ac> ($=) :: forall (s :: * -> *) a. (HasSetter s) => s a -> a -> IO ()
19:01:04 <ac> textureBinding :: TextureTarget -> StateVar (Maybe TextureObject)
19:01:16 <ac> They're both from HOpenGL
19:01:23 <mauke> then I don't know which subexpression the error refers to
19:01:25 <ac> sorear: I know it's a type variable, I'm just not seeing where the list is
19:01:41 <sorear> ac: it's created by the use of a polymorphic function.  if you don't want to see stuff like [t] that isn't in the source code, use a language without type inference
19:01:44 <sorear> oh.
19:01:45 <Adamant> what are some good Haskell programs for newbies to read?
19:01:48 <omnId> what's the first subexpression in the context list.
19:01:51 <sorear> I completely misunderstood your question, sorry
19:02:00 <scook0> ac: that sort of error usually indicates a problem with do-notation, in my experience
19:02:15 <scook0> i.e. the compiler thinks you're in the list monad instead of the IO monad
19:02:19 <ac> scook0: I do have the slightly funky nested do blocks
19:02:33 <scook0> ac: those big lambdas seem hairy too
19:02:33 <mauke> ac: could it be line 13?
19:02:47 <sorear> ac: function application binds tighter than ++
19:02:49 <omnId> forM_ [...] $ \pat -> do ... -- this could help with mess.
19:02:50 <mauke> you're trying to ++ to mapM_
19:02:51 <scook0> ac: I'd factor out all the lists and lambdas, and see if that helps
19:02:57 <LoganCapaldo> ph that's so it
19:03:23 <ac> weee
19:03:28 <ac> you're right. I put ( ) around that last list
19:03:30 <LoganCapaldo> (mapM_ f [a,b,c]) ++ [c,d,e]
19:03:39 <ac> right
19:03:49 <scook0> ac: you might want to try forM_ instead of mapM_
19:03:58 <scook0> which lets you put the list first
19:04:01 <ac> and wow, my program compiles and almost works
19:05:05 <omnId> ac: forM_ is good, and you could use do-lets to put the long lists into their own lines.
19:05:30 <ac> :t forM_
19:05:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
19:05:35 <omnId> let xyuvs = [...]; forM_ xyuvs $ \(x,y,u,v) -> do ...
19:05:45 <omnId> just flip mapM_
19:06:04 <scook0> also, with forM_ you can avoid parenthesising the lambdas (as omnId just showed)
19:06:04 <mauke> @src forM_
19:06:04 <lambdabot> forM_ = flip mapM_
19:07:21 <ari> :t forM_
19:07:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
19:08:10 <hpaste>  omnId annotated "can you solve my type problem?" with "forM_ + do-lets" at http://hpaste.org/3497#a1
19:09:37 <omnId> The dollar-lambda-do idiom is pretty common.
19:13:51 <ac> omnId: thanks, I didn't quite see what you meant. That does look nicer
19:16:17 <omnId> ac: is texNums the result of the cycle/take exercise earlier?
19:17:19 <ac> omnId: Yeah, that's it. Do you see something wrong with it?
19:17:47 <omnId> nah, I just think using cycle/take would be quite a bit clearer.
19:17:56 <ac> omnId: heh. This is shorter :P
19:19:44 <omnId> let texNums = take n . drop panelOffset . cycle $ [0..n] where n = panelCount sliderState
19:19:57 <omnId> (I think that's right)
19:21:07 <ac> omnId: yeah looks right. If you're wondering what the hell I'm doing, the idea is to create a smooth endlessly scrolling pattern
19:21:23 <ac> Using 10 or so textures that get rotated
19:44:37 <P_D> I've got a class with a set of quickcheck propositions.  I want to quickcheck the propositions for a particular instance.  Is there a way to specialize those functions?  At the moment I'm typing quickCheck (prop_x :: inst -> inst -> Bool)
19:45:01 <P_D> And I'd like something more along the liens of quickCheck (prop_x :: Inst)
19:53:33 --- mode: irc.freenode.net set +o ChanServ
19:57:27 <allbery_b> @bot
19:57:27 <lambdabot> :)
20:07:45 <Nico_Reed> If you have a tuple (1,2,3) how do you access the various elements (because you are unable to use fst/snd)?
20:07:55 <allbery_b> pattern matchinjg
20:08:21 <Nico_Reed> so can you show me how you would access 3?
20:08:38 <allbery_b> > let (_,_,c) = (1,2,3) in c
20:08:39 <scook0> e.g. thd3 (_, _, z) = z
20:08:40 <Nico_Reed> like "let (x,y,z) = (1,2,3)" work?
20:08:40 <lambdabot>  3
20:08:55 <mauke> > (\(_,_,c) -> c) (1,2,3)
20:08:56 <Nico_Reed> ah thanks
20:08:56 <lambdabot>  3
20:09:42 <mauke> > let sevenOfNine (_,_,_,_,_,_,x,_,_) = x in sevenOfNine (1,2,3,4,5,6,"butter",8,9)
20:09:44 <lambdabot>  "butter"
20:10:02 <omnId> @slap mauke
20:10:02 <lambdabot> *SMACK*, *SLAM*, take that mauke!
20:12:21 <lament> > let x = (1,2,3,4,5,6,x,8,9), sevenOfNine (_,_,_,_,_,_,x,_,_) = x in sevenOfNine x
20:12:21 <lambdabot>  Parse error at "," (column 28)
20:12:44 <lament> > let x = (1,2,3,4,5,6,x,8,9); sevenOfNine (_,_,_,_,_,_,x,_,_) = x in sevenOfNine x
20:12:44 <allbery_b> semicolon
20:12:45 <lambdabot>      Occurs check: cannot construct the infinite type:
20:12:45 <lambdabot>       t = (t1, t2, t3,...
20:13:24 <omnId> x = (... x ...) is recursive
20:13:36 <mauke> > fix ((,) 1)
20:13:37 <lambdabot>      Occurs check: cannot construct the infinite type: a = (t, a)
20:13:37 <lambdabot>       Expec...
20:15:36 <Beelsebob> How would one go about calling Haskell from C?
20:16:13 <allbery_b> with great trepidation
20:16:18 <Beelsebob> bugger
20:16:44 <dons> its pretty easy
20:16:45 <allbery_b> it can be done (FFI is bidirectional) but haskell from C is rather mroe complex than the othjer way
20:16:54 <dons> only slightly more complex
20:17:01 <Beelsebob> where are the relevant docs on doing it in that direction?
20:17:01 <dons> you do have to link your app against the haskell runtime, of course
20:17:05 <dons> but its 3 lines of code.
20:17:08 <mauke> @where ffi
20:17:08 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:17:11 <dons> Beelsebob: the FFI spec
20:20:32 <sorear> also note that your nice little C program suddenly grows by the size of HSrts and HSbase
20:20:45 <Beelsebob> that's no prob
20:20:50 <Beelsebob> it's not a nice little C program
20:20:56 <Beelsebob> it's a great big gui program
20:21:27 <Beelsebob> in reading the spec, I don't see anything of the form of "here's what you do from the forgien language's point of view"... only how to export a function
20:22:37 <sorear> Beelsebob: Take a guess.  (Hint: The Haskell FFI is designed to be *completely* transparent.)
20:22:55 <sorear> The only catch is that you have to initialize the RTS first.
20:22:59 <Beelsebob> exactly
20:23:04 <Beelsebob> so how does one do that?
20:23:19 <thoughtpolice> hs_init iirc.
20:24:01 <monochrom> It is remarkable how we vary in rating the difficulty of things. For example I rate monad as straightforward, others rate it as holy mystery; I rate time-and-space cost as analytic, others rate it as black magic, lots of profiling and blind guesses.
20:24:28 <mauke> Beelsebob: http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-ffi-ghc.html#using-own-main
20:24:31 <lambdabot> Title: 8.2. Using the FFI with GHC, http://tinyurl.com/ylojgn
20:24:40 <Beelsebob> mauke: cheers :)
20:30:58 <newbie> just wrote a cocat function and I want you to check it out
20:31:07 <newbie> concatl :: [[a]] -> [a]concatl (x:xs)  = x ++ concat xs
20:31:26 <newbie> how does it look ??
20:31:31 <sorear> newbie: Misspelled.
20:31:33 <Cale> newbie: missing a base case
20:31:42 <Cale> (and yeah, there's the spelling bit :)
20:31:56 <newbie> concat [] : []
20:31:57 <sorear> newbie: You're calling the standard concat function instead of recursing.
20:32:35 <newbie> so how do I approach this without usingg (++)
20:32:40 <omnId> import Prelude hiding (concat) -- do this and you can write your own.
20:32:43 <sorear> (you don't have to use standard english, but consistency is pretty important... perhaps moreso in Haskell because of the way definitions work)
20:32:43 <Beelsebob> can one not export functions that return strings?
20:32:50 <newbie> i am building the concat
20:32:50 <omnId> newbie: no, not (++), Prelude.concat
20:32:59 <Beelsebob> or must it be marshalled to a CString first?
20:33:02 <sorear> Beelsebob: sure you can.  just remember this is C>
20:33:14 <newbie> YEAh, that's what i was writing
20:33:27 <mauke> you're not writing the Prelude
20:33:31 <mauke> concat already exists
20:33:37 <newbie> import Prelude hiding (concat)
20:33:38 <sorear> Beelsebob: all types should be marshalled to Cfoo unless you really know what you are doing
20:33:45 <omnId> newbie: the code you gave: concatl (x:xs) = x ++ concat xs -- this uses Prelude.concat on the right-hand-side.
20:33:56 <newbie> i remained in concatl
20:33:58 <monochrom> It is best to base your concat on (++). If you don't want to use the provided (++), you should still write your own.
20:34:07 <newbie> I renamed it concatl
20:34:16 <sorear> Beelsebob: Int in haskell / int in C will work fine for several years and then make somebody waste weeks tracking down a heisenbug (cf. X11)
20:34:19 <omnId> newbie: so the 'concat' on the rhs was a typo?
20:35:16 <newbie> yes
20:35:34 <newbie> made a mistake in the last part
20:36:32 <omnId> newbie: if you gave it the base case, it looks correct.
20:36:47 <newbie> import Prelude hiding (concat)concat :: [[a]] -> [a]concat [] = []concat (x:xs) = x ++ concat xs
20:37:08 <omnId> (use semicolons to seperate declarations)
20:37:23 <scook0> newbie: that looks pretty good to me
20:37:31 <newbie> thanks
20:38:02 <omnId> incidentally, definitions like: f [] = z; f (x : xs) = k x (f xs); can be written: foldr k z
20:38:05 <mauke> import Prelude hiding (concat); concat :: [[a]] -> [a]; concat = join  -- hax
20:38:28 <scook0> mauke: heh
20:38:28 <omnId> mauke: needs import Control.Monad(join) :P
20:38:56 <omnId> > let concat = foldr (++) [] in concat ["foo","bar",baz"]
20:38:56 <lambdabot>  Improperly terminated string at ""]" (column 54)
20:39:07 <omnId> > let concat = foldr (++) [] in concat ["foo","bar","baz"]
20:39:09 <lambdabot>  "foobarbaz"
20:39:24 <newbie> I was working the function or what do you think ???
20:39:44 <omnId> hm?  your concat is correct.
20:39:51 <mauke> > msum ["foo","bar","baz"]
20:39:52 <lambdabot>  "foobarbaz"
20:40:09 <newbie> import Prelude hiding (or)or :: [Bool] -> Boolor [] = Falseor (x:xs) = x || or xs
20:40:16 <omnId> > mconcat ["foo","bar","baz"] -- lolz0rz
20:40:18 <lambdabot>  "foobarbaz"
20:40:44 <omnId> newbie: or looks correct, too
20:40:46 <scook0> > ["foo","bar","baz"] >>= id -- variation on a theme
20:40:47 <mauke> or = maximum  -- hax
20:40:48 <lambdabot>  "foobarbaz"
20:41:15 <omnId> > concatMap id ["foo","bar","baz"] -- scook0's is no magic.
20:41:16 <lambdabot>  "foobarbaz"
20:41:31 <newbie> import Prelude hiding (and)and :: [Bool] -> Booland [] = Trueand(x:xs) = x && and xs
20:41:47 <mauke> and = minimum
20:41:55 <newbie> what i don't get with the or is why the base case as to be false ?
20:42:02 <newbie> can you explain..
20:42:07 <mauke> because otherwise it always returns True
20:42:08 <Nico_Reed> is there a way to get a subsection of a list.. something like: list[1...4]?
20:42:12 <mauke> every list ends in []
20:42:16 <newbie> ok
20:42:19 <omnId> newbie: anything || False = that anything
20:42:33 <mauke> Nico_Reed: you could combine drop and take
20:42:34 <omnId> Nico_Reed: take/drop
20:42:50 <newbie> ok
20:42:56 <monochrom> You would love the identity: or (xs ++ ys) = or xs || or ys. But you break it in case xs is empty and or [] = True.
20:42:59 <newbie> i understand now, thnks
20:43:18 <monochrom> This is also why product [] = 1.
20:43:28 <Cale> You could write [x | (n,x) <- zip [0..] xs, 1 <= n <= 4]
20:43:50 <omnId> Cale: s/n/n && n/
20:43:56 <Cale> er, yes
20:44:01 <omnId> this isn't maths :P
20:44:11 <Cale> not quite, yeah :)
20:45:00 <Cale> > let subsection l u xs = [x | (n,x) <- zip [0.. xs, l <= n, n <= u] in subsection 1 4 "Hello, there!"
20:45:00 <lambdabot>  Parse error at "," (column 50)
20:45:17 <Cale> > let subsection l u xs = [x | (n,x) <- zip [0..] xs, l <= n, n <= u] in subsection 1 4 "Hello, there!"
20:45:19 <lambdabot>  "ello"
20:45:20 <Nico_Reed> thanks mauke and omnId
20:45:55 <Beelsebob> mauke/dons: what's the library that I need to link into my C that contains symbols like hs_init?
20:46:10 <Cale> Generally if you'd like to operate on the indices of a list, you can zip it with [0..]
20:46:15 * ddarius whispers "monoid homomorphism"
20:56:32 <Nico_Reed> On http://www.haskell.org/~pairwise/intro/section4.html, line "calcMMoD obj@(m1, pos1) ((m2, pos2):rest)".. what does that @ actually do?
20:56:33 <lambdabot> Title: Haskell for C Programmers
20:57:14 <JohnMeacham> wow. it is surprisingly easy to write a haskell interpreter in haskell. given the power of packrat parsing and some compiler writing experience...
20:57:34 <allbery_b> it lets you name the entire pattern while simultaneouly breaking it up into parts
20:57:39 <JohnMeacham> well, most of haskell. all the nooks and crannys take a bit more work.
20:58:35 <luqui> > let foo a@(ah:at) = (a,ah,at) in foo [1,2,3]
20:58:37 <lambdabot>  ([1,2,3],1,[2,3])
20:59:05 <monochrom> Note that (ah:at, ah, at) is slightly less efficient than (a, ah, at)
20:59:10 <omnId> Nico_Reed: name@pat matches the value against pat, then binds the whole thing to name if the match succeeds.
20:59:54 <Nico_Reed> and if the match fails?
21:00:03 <omnId> goes onto the next case, as usual
21:00:43 <omnId> in the above, obj@(m1, pos1) matches against a pair, binding m1 to the first, pos1 to the second, and obj to the whole pair.
21:01:09 <Nico_Reed> alright can someone explain to me the one luqui's one?
21:01:20 <Nico_Reed> posted*
21:01:41 <monochrom> [1,2,3] is 1:[2,3].
21:01:55 <omnId> wholeList@(headOfList : tailOfList)
21:02:12 <Nico_Reed> ah.. i see
21:02:22 <monochrom> 1:[2,3] matches ah:at. ah=1, at=[2,3]. Moreover, "a@(ah:at)" says that we also set a to 1:[2,3].
21:02:22 <Nico_Reed> wow thanks
21:02:54 <omnId> > (\xs@(x:_) -> x:xs) [1,2,3] -- this duplicates the head, putting onto the list that already has that head.
21:02:55 <lambdabot>  [1,1,2,3]
21:04:02 <Nico_Reed> gah.. haskell's syntax is pretty amazin
21:04:48 <omnId> yes, expressions are delightfully regular and usually simple.
21:05:14 <Nico_Reed> rather amazing compared to C.. i will agree
21:05:20 <Nico_Reed> but it makes you think hehe
21:05:28 <luqui> but compared to APL...           :-p
21:06:10 <Beelsebob> Bah, I'm missing symbols after linking in everything appropriate I can think of...  "_EnterFunCCS",   "_era", and   "_entering_PAP"
21:06:18 <Beelsebob> where would they come from?
21:06:25 <omnId> expressions are great, patterns can sometimes be unusual, declarations are good, but there's a bunch to remember starting out.  Not much else to the language.
21:06:28 <Nico_Reed> is there a good tutorial to explain all this pattern patching stuff?
21:06:38 <Nico_Reed> matching*
21:07:38 <omnId> lessee... there's names, constructors-with-arguments, and some odd cases like ~ and n+k.
21:07:48 <luqui> n+k--
21:08:05 <omnId> also as-patterns as just discussed.
21:08:32 <omnId> views++ a nice generalization of n+k
21:08:44 <monochrom> All good tutorials explain pattern matching. http://www.haskell.org/haskellwiki/Books_and_tutorials lists all books and tutorials.
21:08:46 <lambdabot> Title: Books and tutorials - HaskellWiki
21:10:18 <omnId> _, name, (Cons args), name@pat, ~pat, n+k... I think that's all of them.
21:10:47 <mauke> C{ l = v }
21:10:51 <omnId> ah yes
21:11:05 <omnId> (Cons {field = param})
21:12:05 <omnId> the syntax sugars for list patterns...
21:13:20 <omnId> even record patterns can be though of as sugar to data patterns.
21:13:28 <scook0> numeric literals...
21:13:37 <omnId> those are constructor.
21:13:42 <omnId> constructors*
21:13:48 <scook0> I guess
21:14:18 <scook0> but probably worth mentioning explicitly in an exhaustive list
21:14:45 <omnId> well, they do insert a fromInteger or fromRational, so that's a little weird.
21:17:31 <Beelsebob> @hoogle CInt -> IO Int
21:17:32 <lambdabot> No matches, try a more general search
21:17:42 <Beelsebob> how does one marshal an integer from C to Haskell?
21:18:32 <omnId> if it's in Integral you might use fromIntegral
21:18:38 <mauke> :t fromIntegral :: CInt -> Int
21:18:39 <mrd> it is, I think
21:18:40 <lambdabot> Not in scope: type constructor or class `CInt'
21:18:47 <Beelsebob> ah, cool, cunning
21:18:50 <mrd> @instances Num
21:18:51 <lambdabot> Double, Float, Int, Integer
21:18:54 <mrd> @instances Integral
21:18:55 <lambdabot> Int, Integer
21:18:57 <omnId> @instances-importing Foreign Integral
21:18:59 <lambdabot> Int, Int16, Int32, Int64, Int8, IntPtr, Integer, Word, Word16, Word32, Word64, Word8, WordPtr
21:19:04 <omnId> @instances-importing Foreign.C.Types Integral
21:19:05 <lambdabot> CChar, CInt, CIntMax, CIntPtr, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort, CWchar, Int, Integer
21:19:09 <Beelsebob> win :)
21:19:10 <Beelsebob> thanks a lot
21:20:08 <mauke> use toEnum . fromEnum for quad damage
21:20:38 <omnId> ERROR INT OUT OF RANGE ZOMG OHNOES!!!!
21:21:09 <omnId> odd that those two use Int rather than Integer
21:21:37 <Beelsebob> blargh
21:21:49 <Beelsebob> using Haskell from C is causing the whole thing to explode
21:22:14 <Beelsebob> rts_evalIO causes my C to exit (status 1)
21:53:31 * omnId . o O (since there's a newtype Fix a = Fix (a (Fix a)), I wonder what I direct translation of Y into a type would look like.)
21:56:02 <ac> would someone with a working HOpenGL installation mind testing something for me?
21:56:29 <ac> try compiling this and tell me if it flickers:
21:56:31 <ac> http://hpaste.org/3499
21:57:57 <monochrom> omnId: That Fix type constructor is Y, isn't it?
21:58:26 <ac> (does it even compile?)
21:58:31 <omnId> monochrom: it's a fixpoint, but I was thinking something that looked more like Y.  I guess that'd need type lambdas.
21:59:21 <monochrom> I see. It is not Y.
22:00:17 <omnId> ac: I copy/pasted and it seemed to compile.
22:00:36 <ac> omnId: does it run? Flicker when it runs? Crash?
22:00:47 <allbery_b> works here
22:00:48 <omnId> running now, I can't see any flicker
22:00:58 <ac> huh. maybe my computer is deficient
22:01:00 <allbery_b> scrolls witgh periodic pauses, doesn't flicker
22:01:02 <omnId> quite cool
22:01:12 <allbery_b> (G4 mac mini, so slow would not be horribly surprising)
22:01:21 <ac> question: how could I compute the chunks incrementally, so it doesn't pause?
22:02:00 <ac> omnId: do you have an LCD?
22:02:08 <omnId> ancient CRT
22:02:21 <omnId> modernish video card
22:02:35 <ac> I've got a laptop with a most likely pretty crappy video card. I bet that's the problem
22:02:57 <ac> You can see why I want textures with non-perfect-square dimensions
22:03:31 <ac> I tried this with gtk2hs and it was unacceptably slow
22:03:47 * omnId is trying a compile -O2 to see what happens
22:04:15 <ac> oh wow
22:04:24 <omnId> faster, pauses almost not noticeable.
22:04:28 <ac> I just did -O3 and it seems a little smoother
22:04:36 <ac> but it still flickers!!
22:04:47 <ac> it's double buffered for christ sake
22:04:54 <Cale> -O3 should be the same as -O2
22:05:01 <ac> I was doing no -O before
22:05:18 <allbery_b> if your video card doesn't have hardware gl acceleration, you're going to lose regardless
22:05:35 <ac> allbery_b: it's a hell of a lot better than gtk so far
22:06:36 <ac> what's interesting is if I make the cells any perfect-square width, than the pattern immediately dies out
22:06:46 <ac> that's why I did 1000 and added 24 black pixels
22:09:51 <ac> If you're curious you can change cellsInit to:
22:09:53 <ac> let cellsInit = take 1000 $ randoms $ mkStdGen 1 :: [Bool]
22:10:09 <ac> and "makeRule 90" to "makeRule 110"
22:10:22 <omnId> g <- newStdGen; let cellsInit = take 1000 $ randoms g
22:10:31 * dmwit is doing Java and misses :t
22:11:19 <ac> omnId: I actually had: mkStdGen (read (args!!1) :: Int)
22:11:29 <ac> omnId: so I could get repeatable results
22:11:59 <omnId> :)  You could use newStdGen in the absence of an argument.
22:12:50 * omnId wonders why there's no randomsIO = liftM randoms newStdGen
22:13:55 <ac> @hoogle getArgs
22:13:56 <lambdabot> System.getArgs :: IO [String]
22:14:24 <omnId> @type replicateM 1000 (State random)
22:14:26 <lambdabot> forall s a. (Random a, RandomGen s) => State s [a]
22:15:17 <omnId> runState (replicateM 1000 (State random)) g = ([ ... 1000 bools ...], g')
22:18:17 <omnId> args <- getArgs; g <- case args of {[seed] -> return (mkStdGen seed); _ -> newStdGen}
22:18:31 <omnId> er, no, you'd need to parse the seed
22:18:49 <omnId> args <- getArgs; g <- case args of {[seed] -> return $ mkStdGen $ read seed; _ -> newStdGen}
22:19:24 <ac> I'm considering showing several simulations at the same time, and maybe adding mouse interaction, and maybe some sort of GA to select initial conditions ;)
22:19:57 <omnId> ooh!  If I click on it can you make a circular explosion like Worms?
22:20:07 <ac> something like that
22:21:26 <ac> I also want to make it continuous, so it's not so uggly
22:21:37 <ac> But I need to read up on sensible rules for continuous automata
22:23:12 <omnId> continuous as is doesn't just end at the sides?
22:23:28 <ac> omnId: If I'm going to do many of them, I want a cleaner way to associate a "nextPanel" function with the sliderState record. Have any ideas? That's why I was asking about IOStreams and whatnot
22:23:41 <ac> omnId: no, continuous as each sell is an integer rather than a Bool
22:23:48 <omnId> ah
22:23:53 <ac> so it would be greyscale rather than B&W
22:29:45 <ac> So if I made the current cellState modifyable, I'd have to stick it in an IORef, and then pass that IORef to the mouse handler?
22:32:11 <Cale> I'll give a UArray of Bool a shot.
22:33:39 <ac> Cale: where?
22:33:53 <Cale> For the rows of cells.
22:34:22 <Cale> UArrays of boolean values are actually bitfields, so it ought to be fast.
22:34:24 <ac> Cale: I was going to do that initially, but then I realized I only needed to make one pass after adding the last to the beginning, and the head to the end
22:34:31 <Cale> really?
22:34:39 <ac> Cale: so I went with [Bool]
22:34:44 <ac> check out cellulate in that code I pasted
22:34:45 <Cale> Can't you just do a nice little trick with mod?
22:35:49 <ac> Cale: sure if it was a UArray
22:36:15 <ac> Cale: I was lazy. I don't think performance is too bad as it is
22:37:50 <ac> Cale: I especially liked my idea of Rule as an Array, and I couldn't figure out a clean way to do that if the Cells were also in an Array
22:40:09 <omnId> ac: you might even do type Rule = (Bool,Bool,Bool) -> Bool, then add a (... !) around your rule generator.
22:40:33 <omnId> that way the actual lookup could use any data structure.
22:40:47 <omnId> even bare cases if you were so inclined.
22:40:57 <Cale> ac: I can. Give me a minute :)
22:41:09 <ac> cool! this is where I'm going:
22:41:11 <ac> http://forum.wolframscience.com/archive/topic/549-1.html
22:41:12 <lambdabot> Title: [Coloured continuous cellular automata] - A New Kind of Science: The NKS Forum
22:42:07 <ac> LOL, that's coded in PHP
22:43:03 <omnId> maybe add a type Cell = Bool; alive = True; dead = False; then when you want to change the Cell type the compiler will tell you what to edit.
22:43:33 <omnId> newtype Cell = Cell Integer; -- type errors!  change this and this and this.
22:44:55 <ac> how is newtype different from data?
22:46:13 <omnId> it may only have one field, to start
22:46:39 <omnId> the representation disappears at runtime, it adds no overhead to just using the underlying type.
22:47:06 <ac> can you use newtype to create records?
22:47:36 <omnId> if they have one field (which may be a tuple that itself can have multiple fields)
22:47:37 <ac> if you only have one field (like a record), than is there ever any reason to use data?
22:48:04 <omnId> but really that's no different than using a plain datatype.
22:48:34 <omnId> ac: hrm, well, the "liftedness" (as in, how many bottoms the type has) is different.
22:49:26 <ac> hm... does one of them not have "Just Bottom"? or something like that? (I have no idea what I'm talking about)
22:49:27 <omnId> but no, they're pretty much interchangeable when there's only one field.
22:50:17 <ac> er, "Just undefined"
22:51:14 <omnId> data D = D (); newtype N = N (); thus D = {_|_, D _|_, D ()}, while N = {_|_, N ()}
22:52:54 <omnId> Maybe () = {_|_, Nothing, Just _|_, Just ()}
22:53:06 <omnId> () = {_|_, ()}
22:53:37 <ac> so Maybe is from "data"
22:54:08 <omnId> yeah, it has multiple cases, so it can't be a *new* of some already existing type.
22:54:20 <omnId> @src Maybe
22:54:20 <lambdabot> data Maybe a = Nothing | Just a
22:54:53 <omnId> @bot
22:54:53 <lambdabot> :)
22:55:38 <monochrom> If you only have one field, you may use newtype.
22:56:02 <ac> I don't think I'll understand this until I'm more awake
22:56:26 * omnId was making up notation on the spot, with no idea of the convention :)
22:56:31 <dibblego> is there a function to go from [1..10] to [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]  ?
22:56:50 <monochrom> Not in the library.
22:56:56 <dibblego> ok ta
22:57:23 <omnId> zip xs (tail xs) gets you the inbetweens too
22:57:25 <bd_> > groupBy (join ((==) . succ)) [1..10]
22:57:26 <lambdabot>  Couldn't match expected type `a -> Bool'
22:57:30 <bd_> hm
22:58:39 <omnId> takeWhile (not . null) . map (take 2) . iterate (drop 2) will get you sublists instead of pairs.
22:59:06 <ac> > map (take 2) $ iterate (drop 2) [1..10]
22:59:08 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
22:59:20 <omnId> iterate keeps going
22:59:43 <omnId> > drop 2 []
22:59:45 <lambdabot>  []
22:59:50 <ac> > map \[x,y] -> (x,y) $ takeWhile (not . null) $ map (take 2) $ iterate (drop 2) [1..10]
22:59:50 <lambdabot>  Parse error at "\[x,y..." (column 5)
22:59:51 <dibblego> > let pairs xs = case xs of [] -> []; [_] -> []; (x:y:ys) -> (x, y) : pairs ys in pairs [1..10]
22:59:52 <bd_> @pl \l -> groupBy (\x y -> succ x == y) (zip l $ tail l)
22:59:52 <lambdabot> groupBy ((==) . succ) . ap zip tail
22:59:52 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
23:00:39 <ac> > map (\[x,y] -> (x,y)) $ takeWhile (not . null) $ map (take 2) $ iterate (drop 2) [1..10]
23:00:40 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
23:00:42 <omnId> dibblego: oh, sure, who pattern-matches bare lists these days when there's perfectly good hofs?  ;)
23:00:53 <dibblego> omnId, :)
23:01:16 <bd_> > groupBy ((==) . succ) . ap zip tail [1..10]
23:01:16 <dibblego> ?hoogle [a] -> b -> (a -> [a] -> b) -> b
23:01:17 <lambdabot> No matches, try a more general search
23:01:17 <lambdabot>  Couldn't match expected type `a -> [a1]'
23:01:20 <bd_> bah
23:01:25 <bd_> > (groupBy ((==) . succ) . ap zip tail) [1..10]
23:01:25 <lambdabot>   add an instance declaration for (Enum (a, a))
23:01:37 <ac> > zip [1..10] [2..11]
23:01:38 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
23:01:54 <wli> > > let chunk n xs = unfoldr (\ys -> case ys of { [] -> Nothing ; _:_ -> Just . first (take n) $ splitAt n ys } ) xs in chunk 3 [1..12]
23:01:54 <lambdabot>   parse error on input `>'
23:01:57 <omnId> > zip [1,3..10] [2,4..10]
23:01:58 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
23:02:03 <wli> > let chunk n xs = unfoldr (\ys -> case ys of { [] -> Nothing ; _:_ -> Just . first (take n) $ splitAt n ys } ) xs in chunk 3 [1..12]
23:02:04 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
23:02:07 <dibblego> it may not be an ordered list y'know
23:02:58 <ac> > zip [1,3..10] [2,4..11]
23:03:00 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
23:03:05 <ac> yay :)
23:03:44 <ac> omnId: oh I didn't see yours above
23:03:49 <omnId> > let odds (x:_:xs) = x : odds xs; odds xs = xs; xs = [1..10] in zip (odds xs) (tail (odds xs))
23:03:50 <lambdabot>  [(1,3),(3,5),(5,7),(7,9)]
23:04:00 <ac> omnId: I was concentrating too hard
23:04:00 <omnId> heh, not quite
23:04:08 <omnId> > let odds (x:_:xs) = x : odds xs; odds xs = xs; xs = [1..10] in zip (odds xs) (odds (tail xs))
23:04:09 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
23:04:15 <omnId> ac: happens to me all the time.
23:05:03 * wli guesses no one likes his chunk function.
23:05:17 <omnId> wli: unfoldr's great
23:05:24 <dibblego> I love it
23:05:35 <dibblego> I love just about every use of unfoldr
23:06:21 <ac> dibblego: I'm guessing the "zip [1,3..10] [2,4..11]" won't work because you're not dealing with lists of integers
23:06:35 <dibblego> ac, correct; I went with the case of, thanks :)
23:06:52 <ac> dibblego: still, it would be cool if it was needed
23:07:31 <laziest> > let chunk n xs@(_:_) = take n xs : chunk n (drop n xs); chunk _ _ = []; in chunk 2 [1..10]
23:07:33 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
23:08:25 <ac> laziest: how'd you get the newline in there?
23:08:41 <laziest> ac: which newline?
23:09:06 <laziest> it's the client that's splitting the lines
23:09:22 <ac> it's just a bunch of spaces you mean
23:09:38 <omnId> ac: you mean the multiple cases for f in the let decls?
23:09:50 <eventualbuddha> did anyone here have a hard time coming from an OO language? and if so, how did you get past it?
23:10:45 <omnId> imperative programming imposes a lot of assumptions about how computation works that don't always hold true in Haskell, regardless of OOyness.
23:10:58 <jql> I have to use the mental muscles I developed for sql rather than the mental muscles I developed for C++
23:11:18 <laziest> exactly which part of OO are you referring to, eventualbuddha ?
23:11:21 <eventualbuddha> jql: hmm, good analogy
23:11:26 <jql> care more about the result than the computation
23:11:42 <Cale> ac: hmm, what are these panels?
23:12:03 <eventualbuddha> laziest: partially the syntax, partially being aghast at all the functions living at the top level (or in modules)
23:12:23 <ac> Cale: they're OpenGL textures of blocks of simulation. It's a 1 dimensional automata, so each row in the texture is step
23:12:32 <ac> *a step
23:12:33 <Cale> right
23:12:51 <omnId> and a panel is a group of steps?
23:13:23 <ac> Cale: and I just picked an arbitrary height for them... well not completely arbitrary. 16 was small enough to not generate noticable pauses when it crunched out a block 1000 cells wide
23:13:33 <Cale> hmm
23:13:35 <laziest> eventualbuddha: whether top level or not, the functions can still be polymorphic.
23:13:55 <ac> I figured it would be excessive to make a texture for each row
23:13:55 <eventualbuddha> laziest: yeah, i know
23:14:06 <Cale> Something has gone a bit funny with some recent modifications I've made. panelH = 1 works and is quite fast, but other sizes no longer work.
23:14:22 <ac> Cale: they must be a power of two, due to limitations of OpenGL
23:14:38 <omnId> eventualbuddha: I think I remember being surprised at how many toplevel names there were.  I've largely forgotten any concern I had.  :)  The scoping and name control you have is quite sufficient, actually.
23:14:41 <eventualbuddha> laziest: i was investigating making a language that had some of the features of haskell with a more OO syntax. i ran into a few problems
23:14:42 <Cale> Right, in particular, the 16 which you had no longer works.
23:14:57 <ac> does it segfault, or show nothing?
23:14:57 <Cale> So I suppose I should sort out what's happening :)
23:15:15 <omnId> eventualbuddha: if you *really* don't like so many names, import stuff qualified
23:15:19 <ac> Cale: you're right, height 1 works fine. I had not tried it
23:15:20 <laziest> eventualbuddha: I have heard of O'Haskell, but never seen it. What about you?
23:15:21 <Cale> It shows a junky version of the automaton, which is mostly black rows.
23:15:24 <omnId> import Prelude as P
23:15:37 <omnId> 3 P.+ 2 P.* 5
23:15:58 * allbery_b started out in the pre-OO age so is not so troubled by it
23:16:04 <eventualbuddha> laziest: for example, i wanted currying but it turns out that currying typically has as its last argument what would be the receiver in an OO language
23:16:06 <ac> man, that hurts my eyes when full screened
23:16:10 <eventualbuddha> so that's problematic
23:16:18 <Cale> ac: Is it still flickering?
23:16:23 <ac> Cale: not really
23:16:35 <ac> it just looks twitchy due to the checkered nature of the pattern
23:16:45 <laziest> eventualbuddha: I got an emergency call now, have to leave...
23:16:48 <allbery_b> mmm, sierpinski
23:16:55 <ac> Cale: I think the flickering was being caused by pauses when it crunched out a block
23:17:24 <ac> Cale: The flickering was probably mostly in my eyes
23:18:01 <omnId> eventualbuddha: an object is a data structure, a naming group, and a data hiding facility.  Data stuctures in Haskell are simple, names and data hiding are both controlled with the module system.
23:18:20 <ac> Cale: yeah definitely. with height 2, the flickering is at a higher frequency
23:18:40 <Cale> I had a bit of flickering before. One thing which I thought was a bit strange was that it wasn't really storing the previous iterations of the automaton, but recomputing them on each refresh
23:19:01 <Cale> So I've fixed that, but broken something else :)
23:19:57 <wli> @type chunk n = unfoldr ((=<< listToMaybe) . (return .) =<< fmap . const . first (take n) . splitAt n)
23:19:59 <lambdabot> parse error on input `='
23:20:11 <wli> @type \n -> unfoldr ((=<< listToMaybe) . (return .) =<< fmap . const . first (take n) . splitAt n)
23:20:12 <lambdabot> forall b. Int -> [b] -> [[b]]
23:20:30 <omnId> wli did you pointlessify that yourself? :)
23:20:33 <ac> Cale: what do you mean? I'm not recomputing anything that I know of
23:20:49 <wli> omnId: I used @pl's output as a guide. I'm still not happy with it.
23:20:55 <Cale> in cellTex, you're doing an iterate cellulate on each step
23:21:23 <ac> Cale: oh, I assumed that internally that was using the value from the previous iteration
23:21:30 <Cale> no
23:21:43 <ac> Cale: that's terrible!
23:21:44 <omnId> wli: is that second (=<<) in ((->) r)?
23:21:54 <wli> omnId: yeah
23:22:15 <Cale> You're throwing away the block every time, because you don't return it.
23:22:44 <omnId> why the first (take n), doesn't splitAt already give n elements in the fst?
23:23:03 <ac> Cale: but iterate itself isn't doing repeated computations?
23:23:23 <Cale> Well, that whole iterate is repeating all the cellulate calls.
23:23:43 <ac> Cale: as long as iterate works as I'd expect it to, I'm not doing any extra computation, because I I say "return last block" at the end
23:24:09 <ac> Cale: are you saying that return computes it a second time?
23:24:21 <Cale> hmm, no, it doesn't do that
23:24:38 <Cale> Perhaps I don't understand the control flow here.
23:25:18 <Cale> ah, I think I might understand what's going on
23:25:32 <ac> Cale: cellTex basically takes a state, skips a bunc of states, and returns height states later, while at the same time creating a side affect of making a texture of the intermediate states
23:26:19 <Cale> and you just move the rectangles around rather than doing the computation of one row every frame
23:26:49 <ac> Cale: exactly, except it seems it works best to do 1 pixel rectangles :P
23:28:47 <Cale> It's just because your cellulate is kind of slow, I think.
23:29:11 <ac> Cale: yeah I'd like to see how it works with a UArray
23:29:38 <ac> Cale: my Rule type will be irrelavent when I switch to continuous automata
23:30:06 <ac> a rule will have to be a function then, rather than an array
23:34:57 <omnId> ac: you could make it a function now, partially applying (!) to your current Rules.
23:35:43 <Cale> yeah, but not quite the right kind of function -- you'd have to do a little more than that
23:47:53 <wli> unfoldr (fmap (first (take n) . splitAt n) . (join $ (. listToMaybe) . fmap . const))
23:47:58 <wli> That looks better.
23:48:49 <Botje> :t unfoldr (fmap (first (take n) . splitAt n) . (join $ (. listToMaybe) . fmap . const))
23:48:51 <lambdabot> Not in scope: `n'
23:48:51 <lambdabot> Not in scope: `n'
23:48:54 <Botje> awwh
23:48:59 <Botje> :t \n -> unfoldr (fmap (first (take n) . splitAt n) . (join $ (. listToMaybe) . fmap . const))
23:49:01 <lambdabot> forall a. Int -> [a] -> [[a]]
23:49:07 <omnId> @type  (join $ (. listToMaybe) . fmap . const)
23:49:08 <lambdabot> forall a. [a] -> Maybe [a]
23:49:20 <omnId> > (join $ (. listToMaybe) . fmap . const) [1,2,3]
23:49:22 <lambdabot>  Just [1,2,3]
23:49:35 <Botje> any reason for the Maybe transformation?
23:49:52 <omnId> > (join $ (. listToMaybe) . fmap . const) []
23:49:54 <lambdabot>  Nothing
23:49:58 <wli> unfoldr wants maybes.
23:49:59 <omnId> > (join $ (. listToMaybe) . fmap . const) [1]
23:50:00 <lambdabot>  Just [1]
23:50:28 <omnId> so case xs of [] -> Nothing; ys -> Just ys?
23:50:41 <wli> That's what it does pointfreely.
23:51:03 <wli> Rather, that's what join ((. listToMaybe) . fmap . const) does pointfreely.
23:51:56 <wli> The real work is done by fmap (first (take n) . splitAt n)
23:52:01 <omnId> right
23:52:11 <omnId> I understand that part :)
23:52:30 <omnId> though isn't the (first (take n) .) unneccessary?
23:52:42 <omnId> fmap (splitAt n)
23:52:59 <wli> Apparently so.
23:53:15 <omnId> the splitAt already gives n elements in the fst.
23:53:28 <wli> wait...
23:53:45 <omnId> @src splitAt
23:53:45 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
23:53:46 <wli> No, it's right.
23:53:52 <omnId> :P
23:54:06 <wli> The test use case I had is wrong.
23:54:15 <wli> (map (\[x,y,z] -> (x,y,z)) $ chunk 3 [1..14] :: [(Integer, Integer, Integer)])
23:55:14 <omnId> that'll fail if there aren't three in the last list.
23:55:23 <wli> Yes.
23:56:39 <wli> I'm all ears for a better pointfree conversion method than join ((. listToMaybe) . fmap . const)
23:57:34 <omnId> @. pl unpl join ((. listToMaybe) . fmap . const)
23:57:34 <lambdabot> id =<< (. listToMaybe) . fmap . const
23:58:02 <wli> I wouldn't count that as much of an improvement. =)
23:58:10 <omnId> me neither :P
23:59:09 <omnId> so it's join (\x y -> fmap (const x) (listToMaybe y))
23:59:50 <omnId> \f g h x y -> f (g x) (h y) would be nice :)
