00:00:17 <wli> Mostly to me, too, but I've got some cellular modem card that's bloze-only.
00:00:34 <Cale> Subtext is getting pretty cool.
00:00:39 * hoelzro pats wli on the shoulder.
00:01:18 <ac> Cale: do you know the author of Subtext? Which Subtext are you speaking of, BTW?
00:01:28 <Cale> http://subtextual.org/subtext2.html
00:01:29 <lambdabot> Title: Created with Camtasia Studio 5
00:02:13 <hoelzro> KatieHuber: where would I find info on calling haskell from C
00:02:14 <hoelzro> ?
00:02:48 <ac> Cale: I've been keeping an eye on that project
00:03:52 <hoelzro> nvm, I found something
00:04:03 <hoelzro> thanks for all the help everyone!
00:04:11 <LeCamarade> ?where ffi
00:04:11 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
00:04:24 <LeCamarade> Oh, he's gone.
00:04:50 <LeCamarade> @tell hoelzro You wanted info on how to call C from Haskell: http://www.cse.unsw.edu.au/~chak/haskell/ffi/
00:04:50 <lambdabot> Consider it noted.
00:06:14 <wli> I only "care" about bloze in the sense that if I don't come up with some use for it, it's useless.
00:06:27 <quicksilver> how disappointing
00:06:30 <Cale> bloze?
00:06:35 <wli> Windows
00:06:50 <quicksilver> my nice little dual monoid strcuture for animatons has turned itself into (yet another) monad
00:07:33 <arcatan> hmmmph
00:08:02 <LeCamarade> ?where hunit
00:08:02 <lambdabot> http://hunit.sourceforge.net/
00:08:19 <arcatan> wrong abstractions...
00:11:04 <goalieca> @src product
00:11:04 <lambdabot> product = foldl (*) 1
00:11:14 <goalieca> of course
00:11:22 <takamura> hi
00:11:22 <goalieca> i win :-)
00:11:36 <LeCamarade> takamura: Hi.
00:16:28 <LeCamarade> Gusts! Crypto has SHA512? Bon.
00:17:03 <LeCamarade> Although the build coughs way too many errors.
00:23:32 <raxas> quicksilver: please can you show us your cute animation monad so we could admire your ingenuity?
00:24:07 <wli> I just want to try out some GUI stuff and all my *NIX boxen are headless.
00:24:55 <hpaste>  quicksilver pasted "animation monad" at http://hpaste.org/3479
00:25:08 <quicksilver> raxas: there you are, although I still haven't forgiven it for turning out to be a mond
00:25:24 <quicksilver> I wonder why foldl (>>=) doesn't have a name
00:25:28 <quicksilver> it strickes me as useful
00:36:10 <phlpp> hi
00:36:15 <Pseudonym> :t foldl (>>=)
00:36:16 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
00:42:19 <sjanssen> quicksilver: foldr (>>=) has a space leak in most monads
00:42:24 <sjanssen> s/foldr/foldl
00:44:24 <sjanssen> @type flip $ foldr (\m ms x -> m x >>= ms) return
00:44:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> [a -> m a] -> m a
00:48:35 <raxas> quicksilver: very interesting. I like the parallel animation combinator
00:48:50 <phlpp> @type flip
00:48:52 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
00:55:04 <quicksilver> sjanssen: I'm not sure I care. I'm not planning to fold together millions of actions :)
00:55:30 <quicksilver> sjanssen: was your point that foldr (=<<) is better, though?
00:56:16 <sjanssen> foldr (=<<) isn't so great either
00:56:22 * quicksilver nods
00:56:27 <quicksilver> I didn't think it would be better
00:56:33 <quicksilver> and it does things backwards, too :)
00:56:51 <quicksilver> anyhow I'l talking about folding together lists of 10, 15, 100 actins
00:56:56 <quicksilver> I doubt the space leak matters much
00:57:48 <quicksilver> raxas: yes, well I had the parallel combinator first
00:58:04 <quicksilver> raxas: it was just <|> and <-> effectively two pseudo-monoids
00:58:10 <quicksilver> (the identity wasn't quite an identity)
00:58:24 <quicksilver> but then I discovered that I did actually need to thread return values, sometimes, so it became a monad after all
01:00:11 <dmwit> @vixen I know this is sort of silly.
01:00:11 <lambdabot> Plugin `vixen' failed with: getRandItem: empty list
01:03:29 <quicksilver> dons++ # HWN!
01:06:34 <quicksilver> hmm that subtextual thing looks interesting, but I have not time to watch it properly now
01:07:33 <LeCamarade> Is there a module that maps the POSIX things to the Win32 versions?
01:08:10 <LeCamarade> Like a fork(3) call that does the Win32 equivalent?
01:08:31 <sjanssen> LeCamarade: not exactly
01:08:47 <sjanssen> LeCamarade: there are cross platform APIs like System.Process
01:08:47 <quicksilver> LeCamarade: there are lowest-common-denominator modules which work on both
01:08:54 <quicksilver> LeCamarade: but they may not do what you need :)
01:09:08 <LeCamarade> Hmm.
01:09:09 <quicksilver> i.e they are actually probably somewhat lower than the true l.c.d.
01:09:24 <quicksilver> "very low common denominator" ?
01:09:35 <LeCamarade> Plus I know some abstractions would leak ...
01:09:55 <LeCamarade> But how do I compile a same file for POSIX and Win32? No #define, as it is ...
01:10:14 <quicksilver> use CPP or something similar
01:10:29 <quicksilver> or use a higher level library which was itself compiled using CPP :P
01:10:36 <raxas> quicksilver: I think your concept of animation is worth for complete decouple from GL, so it could be used for GUIs also
01:11:04 * vegai tries to desperately see what the small text in Hwn-cover.png reads
01:11:29 <quicksilver> raxas: the coupling to openGL is entirely trivial
01:11:33 <LeCamarade> Preprocessor is evil. :o) But still.
01:11:42 <quicksilver> raxas: just my choice to use 'GLdouble' as a 'time variable'
01:11:51 <quicksilver> raxas: other than that, the code is graphics layer independent
01:11:51 <wli> I'm just lost for the moment wrt. how to build Haskell apps on Windows.
01:12:13 <vegai> hmm, could libmpd be easily included in xmobar...?
01:12:17 <sjanssen> wli: ghc --make?
01:12:21 <quicksilver> wli: simple three step algorithm
01:12:27 <vegai> I currently have a c-program that I call every second... that's a bit wasteful
01:12:35 <quicksilver> wli:  (1) find ndm (2) ask ndm to build your app (3) hope he has time.
01:14:28 <wli> Well, if ghc --make works I just need to figure out how to do that in Windows.
01:14:40 <sjanssen> vegai: that should be pretty easy, assuming libmpd's API is nice
01:15:09 <earthy> wli: doing ghc --make in windows is as simple as navigating to the right directory in cmd.exe and typing it in
01:15:44 <earthy> (and doing cabal installs is almost as easy)
01:15:59 <earthy> ofcourse, you could go for VSHaskell... but that's pushing it imho
01:16:20 <wli> It doesn't seem to have a good idea of where paths are, and I've not worked out how to save one.
01:19:05 <wli> But I think I can work around it once I find the ghc binary.
01:22:56 <wli> earthy: That's pretty good news.
01:23:19 <earthy> hm. must be some of that way-old dos knowledge still lingering around, but, um, %PATH% should give you your path, right? :)
01:24:12 <wli> I see something.
01:24:26 <wli> ghc is actually in my path.
01:43:15 <hpaste>  iesahin pasted "basic IO problem" at http://hpaste.org/3480
01:44:21 <iesahin> hello all, a newbie here :)
01:45:08 <iesahin> i'm trying to understand how to use IO with non-IO for the file I just pasted
01:45:13 <quicksilver> iesahin: what seems to be the problem?
01:45:20 <iesahin> it gives following
01:45:27 <iesahin> /home/iesahin/Research/Current/program/CaseLibrary.lhs:241:64:
01:45:27 <iesahin>     Couldn't match expected type `Case' against inferred type `IO Case'
01:45:27 <iesahin>       Expected type: [Case]
01:45:27 <iesahin>       Inferred type: [IO Case]
01:45:30 <iesahin>     In the second argument of `($)', namely
01:45:33 <iesahin> 	`map buildCaseFromFile initialCaseList'
01:45:37 <iesahin>     In a 'do' expression:
01:45:40 <iesahin> 	records <- (indexify (Map.empty))
01:45:43 <iesahin> 		 $ (map buildCaseFromFile initialCaseList)
01:45:46 <iesahin> Failed, modules loaded: Infon, SITARUtils.
01:45:59 <iesahin> in the last function, buildInitialCaseLibrary
01:46:07 <quicksilver> iesahin: in future put the error in hpaste too, if it's more than a couple of lines
01:46:17 <quicksilver> iesahin: anyhow, the problem lies with your use of 'map'
01:46:18 <iesahin> ok
01:46:24 <quicksilver> iesahin: since buildCaseFromFile is in the IO monad
01:46:32 <quicksilver> iesahin: you want to use mapM
01:46:35 <quicksilver> :t mapM
01:46:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:46:53 <iesahin> oh
01:46:59 <quicksilver> iesahin: mapM buildCaseFromFile initialCaseList will have type 'IO [Case]\
01:47:16 <quicksilver> iesahin: then you want to change that $ to a `liftM`
01:47:30 <quicksilver> liftM is the way to apply a pure function (indexify) to a monadic value
01:47:34 <quicksilver> putting it all together, it is
01:47:49 <quicksilver> records <- indexify (Map.empty) `liftM` mapM buildCaseFromFile initialCaseList
01:48:45 <iesahin> liftM in which module?
01:49:26 <iesahin> let me find myself, thanks quicksilver, i couldn't find this myself, thank you very much
01:49:35 <iesahin> :)
01:50:54 <aleator> Hey, is there example of using IconView in gtk2hs anywhere?
01:51:36 <dcoutts> aleator: I don't think there is actually, if you'd like to contribute one that'd be great.
01:51:56 <quicksilver> iesahin: Control.Monad
01:52:07 <quicksilver> @index liftM
01:52:08 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
01:52:15 <quicksilver> iesahin: lambdabot knows many things :)
01:52:55 <quicksilver> iesahin: if you choose to import Control.Applicative, you can actually write `liftM` as <$>. Which looks nicely 'like but slifhtly different' to the $ you had before
01:53:52 <aleator> dcoutts: If I manage to make one, I'll contribute. How do I set the pixbuf column with Graphics.UI.Gtk.ModelView?
01:53:55 <iesahin> quicksilver: lambdabot knows, but i don't :)
01:56:10 <dcoutts> aleator: iconViewSetPixbufSource
01:56:19 <iesahin> quicksilver: it worked, thanks a lot
01:56:52 <aleator> dcoutts: Oh. I see. Didn't find that in the api doc.
01:57:06 <dcoutts> aleator: so you have to set the IconView's model and then use iconViewSetPixbufSource suppling an extractor function that gets Pixbufs from the model
01:57:47 <dcoutts> aleator: ah, seems that's only in the darcs version, not in 0.9.12
01:58:03 <aleator> Ok.. I thought I was blind.
01:58:11 <dcoutts> no :-)
01:58:11 <aleator> So, darcs version it is then..
01:59:14 <aleator> dcoutts: I think that is enough for some example, I'll get back to you when I get something working.
01:59:30 <dcoutts> aleator: ok great
02:16:15 <roconnor> is a -> b -> m c isomorphic to a -> m (b -> m c) ?
02:17:29 <wolverian> I wish hackage had the haddock docs too. they tell so much mor about a package than a simple description
02:18:52 <aleator> Could not find module `Distribution.Simple.Program' ? while installing happy.
02:20:10 <aleator> ah.. old version
02:25:19 <EvilTerran> ?quote
02:25:19 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
02:25:26 <EvilTerran> -.-
02:26:04 <astrolabe> roconnor: It seems like it to me, but I'm not positive.
02:26:47 <Cale> Not quite, I don't think.
02:27:57 <Cale> You can turn one into the other, but the composition of the obvious maps doesn't seem to be the identity
02:28:10 <Cale> a -> m (b -> m c) is conceptually "larger"
02:29:33 <aleator> Is happy supposed to build with cabal-1.1.6.2?
02:30:03 <mux> http://xkcd.com/303/
02:30:03 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
02:30:41 * mux note it's hard to use the "compiling" excuse at work for him, since he's doing perl
02:34:22 <Taejo> mux, I prefer it to Wednesday's, but I still think xkcd was better when he worked at Nasa
02:35:15 <hpaste>  Cale pasted "not quite an isomorphism" at http://hpaste.org/3481
02:35:40 <osfameron> mux: you could be running your test suite :-)
02:37:16 <mux> osfameron: *nods*
02:38:08 <Cale> Kind of like a closure operator of sorts.
02:39:54 <Cale> Under a funny ordering where one value is considered larger than another if it has the same effects, but they happen later.
02:40:57 <quicksilver> Cale: they're isomorphic if the intention is that you supply 'a' and 'b' at the same time
02:41:33 <quicksilver> maybe that's a silly way of putting it
02:41:41 <Capso> Any Haskell Web Servers out there?
02:41:56 <Capso> Or implementations of Haskell for Apache?
02:42:16 <Capso> I know HWS... but is there any other that is more preferred by you guys?
02:42:27 <quicksilver> haskell-for-apache most people use fastcgi
02:42:31 <Cale> well, and you only intend to use the returned function once
02:42:31 <quicksilver> seems like the sensible choice
02:43:04 <quicksilver> Cale: yes, if you supply a and b "at the same time" then you don't save the intermediate value. But yes. :)
02:43:17 <hpaste>  Cale annotated "not quite an isomorphism" with "additional examples" at http://hpaste.org/3481#a1
02:43:19 <quicksilver> Cale: hAppS also embeds its own HTTP server I believe
02:43:50 <quicksilver> Capso: that was for you :P
02:44:03 <Cale> hmm...
02:44:11 <quicksilver> Cale: I think they might be isomorphic if you restrict to Applicative
02:44:20 <quicksilver> Cale: because Applicative has this normal-form theorem
02:44:51 <Cale> Capso: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hxweb-0.1 maybe?
02:44:54 <lambdabot> http://tinyurl.com/33x9ha
02:45:09 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Web -- there's not enough here at the moment ;)
02:45:35 <Cale> You can write CGI programs fairly easily using the Network.CGI library.
02:46:00 <Cale> http://haskell.org/haskellwiki/Applications_and_libraries/Web_programming -- there's a good deal more web stuff listed here
02:46:02 <lambdabot> Title: Applications and libraries/Web programming - HaskellWiki, http://tinyurl.com/253xhy
02:46:11 <roconnor> Cale: I was expecting reasoning with monad laws :)
02:46:12 <Capso> Cale: I didn't really want to use *CGI.
02:46:33 <Capso> Cale: I find it more secure to either have a dedicated Apache module, or to just use a backend webserver.
02:46:42 <Cale> roconnor: I suppose I haven't shown that an isomorphism doesn't exist.
02:47:02 <Cale> roconnor: However, the example provided is sort of convincing that they're not the same thing.
02:47:33 <Cale> Capso: more secure?
02:48:04 <roconnor> really? I'm not convinced.  I figure what is going on is some sort of effect of GHCi not perfectly respecting the semantics of IO.
02:48:12 <roconnor> but that is just a gues
02:48:22 <Cale> roconnor: Well, with a -> m (b -> m c)
02:48:58 <Cale> you have a function which returns an action which you can run (just once), and get a function which you can use a bunch of times thereafter, with later effects
02:49:01 <roconnor> Cale: oh I see your other example
02:49:27 <roconnor> I missed the double a in the first part of your second example
02:49:31 <Cale> Yeah
02:49:34 <Capso> Cale: Than FastCGI, yes.
02:49:34 <roconnor> yeah, that is pretty convincing
02:49:48 <Cale> roconnor: It's basically the same issue as m (m a) not being isomorphic to m a
02:49:53 <Capso> Cale: Is there anything particularly wrong with, or bad about, HWS?
02:50:17 <Cale> I don't know anything about HWS
02:50:29 <Cale> It's kind of old though
02:50:43 <roconnor> Cale: hmm.  I sort of was reasoning that a -> m (b -> m c) would be the natural way of writing a curried function in the Kleisli catagory.
02:50:48 <matthew-_> is there a nice curses binding for haskell?
02:51:13 <Cale> roconnor: Well, of course, when you curry, there's potential for side effects after each parameter then.
02:51:53 <Cale> whereas the "uncurried" form only allows for side effects to all happen at once when all the parameters are finally supplied
02:51:55 <roconnor> but a curried function ought t be isomorphic to (a,b) -> m c shouldn't it?
02:52:40 <quicksilver> Capso: people thing writing a web server is pretty easy
02:52:46 <Cale> So I suppose that in the Kleisli category, currying/uncurrying isn't quite an isomorphism.
02:52:54 <quicksilver> Capso: they are quite horrendously mistaken
02:53:03 <roconnor> that strikes me as very odd
02:53:07 <quicksilver> Capso: writing a webserver is phenonmenally fiddly and quite dull
02:53:35 <roconnor> Cale: Are Kleisli categories not CCC?
02:53:38 <quicksilver> Capso: it's better to use the work produced by the apache project than re-write :)
02:53:43 <Cale> hmm...
02:53:46 <Botje> I wrote a tiny webserver in haskell
02:53:48 <Botje> 200 lines :)
02:54:02 <quicksilver> the isomorphism between a -> b -> m c and (a,b) -> m c is a true isomorphism
02:54:06 <quicksilver> (modulo bottoms)
02:54:08 <Capso> quicksilver: Generalised 'solutions' tend to be worse.
02:54:21 <quicksilver> the isomorphism only falls down when you pull the m further back along the chain
02:54:22 <Capso> quicksilver: When it comes to efficiency and security.
02:54:41 <quicksilver> Capso: quite true, but the apache project has a pretty good reputation for both those things.
02:54:41 <Cale> Yeah, maybe we're just misjudging what the exponential object is
02:55:08 <quicksilver> I'd wager that if you write your own CGI implementaiton (for your own web server) you'd introduce security issues
02:55:09 <Cale> Of course it ought to be c^b = (b -> m c)
02:55:13 <quicksilver> it's not easy to get that right :)
02:55:18 <Cale> So yeah, that makes sense then :)
02:55:21 <roconnor> Cale: so you think Kleisli categories outght to be CCC?  I really wasn't sure
02:55:35 <Cale> Yeah, it seems like they should be...
02:55:58 <roconnor> and we want (c^b)^a isomorphic to (c^(b*a)) right?
02:56:06 <roconnor> hence my confusion
02:56:15 <roconnor> I hate it when my intuition leads me astry
02:56:24 <roconnor> It means there is something I don't understand
02:56:34 <roconnor> or worse, something that I wrongly understand
02:56:34 <Capso> quicksilver: With multiple users to support, FastCGI implementation tends to be horrendous on all aspects.
02:56:54 <Cale> We want a -> c^b to be isomorphic to (a,b) -> c
02:57:29 <roconnor> and b -> c isomorphic to 1 -> c^b ?
02:57:35 <Cale> Hehe, did you put that citation needed into wikipedia?
02:57:37 <roconnor> oh
02:57:53 <roconnor> 1 -> c^b isn't quite the same as c^b is it?
02:57:54 <Cale> http://en.wikipedia.org/wiki/Cartesian_closed_category#Equational_theory -- hehe, check out the last equation
02:57:55 <lambdabot> http://tinyurl.com/28sgjw
02:58:47 <roconnor> citation needed!
02:59:00 <Cale> Yeah, I think someone else had some doubts :)
02:59:33 * roconnor grabs a random catagory theory book
02:59:41 <Capso> Cale: Do you use Haskell on your wiki?
02:59:52 <Cale> Capso: no, it's a mediawiki
03:00:05 <Cale> Capso: I have Haskell syntax highlighting though :)
03:00:54 <Cale> Hmm, we have that X x 1 is isomorphic to X
03:01:43 <roconnor> my book says Hom(a,c^b) isomorphic to Hom(a*b,c)
03:01:47 <Cale> So if that's the case, then  X -> Y is isomorphic to 1 x X -> Y, which is isomorphic to 1 -> Y^X
03:02:15 <Cale> But 1 -> Y^X isn't necessarily quite the same thing Y^X
03:02:29 <Cale> as*
03:03:00 <Cale> Yeah, your book's isomorphism is all I think we get
03:03:15 <roconnor> a -> m b needs to be isomorphic to () -> m (b^a)
03:03:29 <quicksilver> erm 1 -> Y^X is a homset, clearly that's not the same as Y^X which is an obejct
03:03:39 <quicksilver> do you perhaps mean (Y^X)^1 ?
03:03:52 <Cale> well, right
03:04:02 <Cale> They're not even the same kind of thing :)
03:04:34 <quicksilver> X^1 is isomorphic to X in all CCCes, certainly
03:04:41 <Cale> But in, say, Set, Y^X is "morally" the same thing as X -> Y
03:04:54 <Cale> As it is in Hask
03:05:07 <quicksilver> of course, but when try to reason carefully about Kleisli categories you have to be precise
03:05:15 <Cale> But apparently not in CCC's in general.
03:05:18 <roconnor> does this mean that a -> b is the exponential object rather than a -> m b?
03:05:21 <quicksilver> or you'll get vconfused between arrows in one cat and arrows in the other
03:05:51 <Cale> The Kleisli category has the same objects as the original, but different arrows.
03:06:02 <roconnor> is () -> m (a -> b) isomorphic to a -> m b ... probably not.
03:06:10 <Cale> no
03:06:27 <quicksilver> definitely not
03:06:33 <roconnor> well then, I shall head off to lunch, still puzzled.
03:06:36 <quicksilver> :)
03:06:59 <quicksilver> I think you need two different arrow symbols to express this comfortably in IRC
03:07:00 <Cale> Well, I think Y^X consists of the arrows X -> MY
03:07:07 <Cale> (in the original category)
03:07:26 <Cale> Or the arrows X -> Y in the Kleisli category
03:07:42 <quicksilver> and then, Y^1 is arrows () -> M Y
03:07:56 <quicksilver> which is isomorphic to M Y *but* NOT to Y
03:07:57 <quicksilver> :)
03:08:56 <Cale> Okay, hmm. I thought I'd sorted this out, but it's still kind of strange. :)
03:09:05 <quicksilver> which leads me to think that that is the wrong exponential
03:09:27 <Cale> Maybe there really isn't a proper exponential.
03:09:30 <quicksilver> I think the exponential must be 'normal arrow objects' not 'kleisli arrow object'
03:10:00 <Cale> still...
03:10:31 <quicksilver> then hom(a,c^b) is hom (a,(b->c)) which is a -> m (b -> c)
03:10:52 <quicksilver> and we claim that corresponds to (a,b) -> m c
03:11:28 <Cale> which is a lie, isn't it?
03:11:36 <quicksilver> there's certaily a bijection
03:11:43 <quicksilver> you showed it wasn't an isomorphism
03:11:47 <quicksilver> but of course it doesn't have to be
03:11:52 <quicksilver> it just has to be a natural bijection
03:11:54 <Cale> It's not a bijection even, is it?
03:12:03 <Cale> err...
03:12:25 <Cale> Well, it'll be natural if we can write it in Haskell with a polymorphic type. We don't have to worry about that :)
03:12:41 <Cale> But hmm
03:13:16 <quicksilver> I'm surprised that google can't tell me if kleisli of CCC is CCC
03:13:27 <quicksilver> I'm sure it's really obvious to anyone who knows
03:14:42 * wli goes about a GUI hello world.
03:15:02 <wli> In the 14 years I've been programming I've never touched a GUI before.
03:15:32 <Cale> quicksilver: that's no fun
03:15:41 <quicksilver> :)
03:16:06 <quicksilver> I note that 'isomorphism' between homsets doesn't mean anything anyway
03:16:08 <Cale>  ((a,b) -> m c) -> (a -> m (b -> c))
03:16:13 <Cale> no, it does
03:16:14 <quicksilver> homsets don't have any structure
03:16:19 <quicksilver> they're just sets...
03:16:19 <Cale> yes they do
03:16:25 <Cale> Hom is a bifunctor
03:16:35 <quicksilver> yes, that's the naturality part
03:16:42 <quicksilver> a particular homset is structureless though
03:17:04 <quicksilver> it's just that taken as a whole, they line up like neat little soldiers
03:17:04 <Cale> I wouldn't say that.
03:17:53 <Cale> ((a,b) -> m c) -> (a -> m (b -> c)) -- is it even possible to write a function of this type?
03:18:20 <Cale> We need monad-djinn :)
03:19:01 <Cale> @djinn Monad m => ((a,b) -> m c) -> (a -> m (b -> c))
03:19:02 <lambdabot> Cannot parse command
03:19:16 <Cale> @djinn (Monad m) => ((a,b) -> m c) -> (a -> m (b -> c))
03:19:29 <quicksilver> no, I don't believe there is
03:19:34 <quicksilver> I think I was mistaken :)
03:20:02 <Cale> I'm starting to think it's not really a CCC
03:20:04 <quicksilver> you can't apply the action on the left until you get A and B
03:20:13 <Cale> right
03:20:18 <quicksilver> but the result you want to give causes its effects before getting B
03:20:39 <quicksilver> so I think that convinces me it's not CCC with the 'normal' exponential
03:20:57 <quicksilver> and I previously convinced myself it's not CCC with the 'kleisli exponential'
03:21:06 <quicksilver> simply because M Y is not isomrophic to Y
03:22:06 <Cale> Hang on, does the Kleisli category even have products?
03:22:15 <quicksilver> according to Taylor, if C is symmetric monoidal closed, then the *co*-Kleisli is CCC
03:23:05 <Cale> There's only one natural object to assign to X x Y in the Kleisli category, as far as I can imagine
03:23:11 <Cale> and yet
03:23:39 <Cale> If you have Kleisli arrows Y -> X1 and Y -> X2
03:23:50 <Cale> There's supposed to be a *unique* map Y -> X1 x X2
03:23:53 <quicksilver> the obvious choice for projections is return .fst and return . snd, I suppose
03:24:19 <Cale> (call it f) such that f . pi_1 = f_1 and f . pi_2 = f_2
03:24:25 <Cale> But that's totally false
03:24:44 <Cale> Because there's at least two choices for that map.
03:25:03 <Cale> You can do the effects in either order.
03:25:38 <Cale> Or only half of the effects
03:25:44 <quicksilver> looks like you couldn't get a symettric product
03:25:46 <Cale> but you can't get the composites to work out
03:25:54 <quicksilver> you could get an asymmetric pseudo-product that way
03:26:11 <Cale> You're supposed to have  f . pi_1 = f_1
03:26:13 <quicksilver> "carry out all effects, left-to-right"
03:26:20 <quicksilver> oh yes hmm
03:26:26 <Cale> But f_2's effects would have to be carried out by f
03:26:27 <quicksilver> it needs to forget the effects you didn't choose
03:26:30 <Cale> yeah
03:26:35 <quicksilver> I agree, that doesn't sound possible
03:26:51 <Cale> So products don't even exist.
03:27:02 <Cale> Is there a terminal object?
03:27:17 <Cale> No!
03:27:35 <Cale> (In general, at least)
03:28:00 <Cale> For example, with IO. Its Kleisli category can't have a terminal object.
03:28:18 <aleator> How am I supposed to compile happy? Old cabal, darcs cabal or maul the happy Setup.lhs?
03:28:32 <Cale> Because you can always print out one of two different things, so there's at least two distinct maps going to any object.
03:29:39 <Cale> aleator: I've been taking the approach of using cabal install and hoping for the best
03:30:15 <Cale> (though cabal-install has at least one very annoying bug)
03:30:32 <aleator> it fails with cannot find 'Distribution.Simple.Program'.
03:31:16 <Cale> That's not listed in the GHC docs, so maybe it's new
03:31:46 <Cale> http://www.haskell.org/cabal/release/rc/doc/API/Cabal/Distribution-Simple-Program.html -- it is listed here though
03:31:48 <lambdabot> http://tinyurl.com/2w4t24
03:31:59 <aleator> So I get to build myself a new cabal as well?
03:32:29 <Cale> It appears to only occur in that rc branch...
03:32:33 <sjanssen> aleator: or use an older version of happy
03:32:51 <Cale> er, oh
03:32:54 <Cale> It's also in 1.2.1
03:33:05 <Cale> and 1.2.0
03:33:22 <Cale> But not 1.1.6.2
03:33:37 <aleator> yep. new cabal it is then..
03:33:49 <Cale> quicksilver: so that's kind of embarassing :)
03:35:07 <Cale> roconnor: In the general case, the Kleisli category will fail all three of the properties to be a CCC.
03:35:56 <Cale> roconnor: (check out the Kleisli category for IO or State Bool, say)
03:36:05 <quicksilver> Cale: ok, well I think that makes sense at least
03:36:09 <quicksilver> Cale: why did we want it to be CCC?
03:36:20 <EvilTerran> CCC?
03:36:21 <Cale> Because we wanted to talk about currying
03:36:24 <SamB_XP> a CCC?
03:36:28 <SamB_XP> credit card company?
03:36:32 <Cale> Cartesian closed category
03:36:41 <Cale> Currying only makes sense in CCC's.
03:36:53 <SamB_XP> ahhh
03:36:56 <SamB_XP> more Cs!
03:36:59 <quicksilver> ah yes, I remember
03:37:19 <quicksilver> yeah, I agree with teh conclusion. currying make no sense in general monads
03:37:20 <SamB_XP> that's more Cs than my old school
03:41:56 * EvilTerran was thinking "christchurch college"...
03:42:25 <quicksilver> there is something called 'Cambridge College Cambridge'
03:42:35 <quicksilver> it is, however, not one of the colleges of the main university :)
03:46:01 <EvilTerran> there seems to be no christchurch college cambridge, unfortunately. i was hoping there'd be a CCCC
03:49:23 <aleator> Gah! "Preprocessing executables for happy-1.17... Setup.lhs: The program happy is required but it could not be found"
03:57:49 <dcoutts> aleator: you didn't do clean before building did you?
03:59:01 <aleator> dcoutts: I need to do that with just opened tar of the sources?
03:59:08 <dcoutts> JaffaCake: it seems people are running into problems even though they did not clean. I'm not sure why yet.
03:59:21 <dcoutts> aleator: no, it should just work, but cleaning first might make it go wrong.
03:59:39 <aleator> Well, didn't clean, does not work even with cleaning.
03:59:52 <JaffaCake> hmm, let me try that again here
04:00:06 <JaffaCake> aleator: you definitely have dist/build/Parser.hs?
04:00:10 * dcoutts deletes happy and tries
04:00:54 <aleator> JaffaCake: no..
04:01:04 <JaffaCake> in the tarball, that file should be there
04:01:17 <dcoutts> JaffaCake: it wants dist/build/happy/happy-tmp/Parser.hs I think
04:01:40 <dcoutts> executables and libs have different build dirs
04:01:54 <JaffaCake> why's that? it didn't here
04:02:10 <dcoutts> JaffaCake: using recent Cabal ?
04:02:16 <aleator> JaffaCake: Ah, now I have. I cleaned when dcoutts mentioned that.
04:02:34 <JaffaCake> dcoutts: yes
04:02:42 <JaffaCake> well, a couple of weeks or so old
04:03:03 <dcoutts> there was a bug a while ago where we were putting exe's generated files in the wrong place
04:04:05 <dcoutts> JaffaCake: so when I move the files to dist/build/happy/happy-tmp/ then it works
04:04:45 <dcoutts> which makes sense since that is where it would put generated files for an executable
04:04:50 <aleator> dcoutts: Ah! Thanks. Now it builds.
04:05:12 <dcoutts> JaffaCake: I'd forgotten exactly where they go
04:05:30 <JaffaCake> hmm, maybe the Cabal I was using had that bug, then
04:06:23 <JaffaCake> I'll fix the tarball and upload a new one
04:08:51 <dcoutts> and at some point Cabal will catch up and put generated-shipped files in the right place in the tarball
04:37:52 <Igloo> dons: publish.hs works for me with the 6.8 branch
05:02:38 <vincenz> hallo
05:16:06 <aleator> dcoutts, jaffacake: Alex has the same problem as happy.
05:16:51 <JaffaCake> aleator: I haven't uploaded a new Alex version yet
05:17:07 <aleator> Ok. Just making sure you know.
05:17:26 <JaffaCake> thanks - I'll try to get to it soon
05:29:54 <aleator>  gtk2hs is not yielding to my efforts: http://pastebin.com/d79e5eef9
05:30:15 <ddarius> aleator: Perhaps you should get it drunk first.
05:30:46 <dcoutts_> aleator: hmm
05:30:48 <aleator> ddarius: Doesn't work with girls so probably doesn't either with computers.
05:32:16 <dcoutts_> aleator: ok, gimme a sec. I'll tell you when to pull.
05:32:28 <aleator> dcoutts: Ah cool!
05:33:06 <aleator> dcoutts: Seems that you should be packaged with each gtk2hs distribution :)
05:33:15 <dcoutts_> heh
05:33:41 <waern> hehe :)
05:34:08 <waern> the day dcoutts can package himself, Cabal has become the ultimate build system
05:43:00 <vincenz> augustss: ping
05:43:11 <roconnor> vincenz: ack
05:43:16 <vincenz> roconnor: wrong person?
05:43:22 * roconnor man-in-the-middles
05:43:28 <vincenz> roconnor: oh, ask him why he sent me that email?
05:43:34 <vincenz> It was a bit out of the blue.
05:43:39 <roconnor> :)
05:43:51 <nopoints> hello roconnor :)
05:44:22 <roconnor> nopoints: Did you get your package to install locally?
05:44:36 <nopoints> no I am here to ask about that
05:45:18 <nopoints> ./Setup.hs configure --user --prefix=`pwd`   doesn't work for installing pointfree
05:45:48 <nopoints> (or for installing lambdabot)
05:46:11 <vincenz> roconnor: oh you're Eve? I thought you were a valid man-in-the-middle
05:46:46 <nopoints> has anybody installed lambdabot locally?
05:47:17 <roconnor> vincenz: um... he says that he sent the mail by mistake.
05:47:20 <vincenz> ah ok
05:47:26 <vincenz> roconnor: that clears up confusions :)
05:47:32 <roconnor> vincenz: btw, I'm just making up the response
05:47:33 <vincenz> well thanks for the raytracer :)
05:47:36 <roconnor> I really have noidea
05:47:39 <vincenz> roconnor: damn you
05:48:07 * vincenz spams roconnor with papers about c-types
05:50:29 <ZsoL> hi
05:52:08 <roconnor> @seen dons
05:52:09 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 13h 26m 53s ago.
05:55:28 <MyCatSchemes> foldM_ can eat an infinite list, right?
05:55:37 <vincenz> yes
05:56:32 <roconnor> nopoints: I thought you were just going to install the pointless package.
05:57:59 <nopoints> roconnor: it is called pointfree http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointfree-1.0.1
05:58:01 <MyCatSchemes> vincenz: danke. It was the "foldM is analogous to foldl", and since foldl can't touch infinite lists, that would be a bummer.
05:58:02 <lambdabot> http://tinyurl.com/362ljm
05:58:38 <MyCatSchemes> nopoints: it may be *called* pointfree, but everyone knows that what it really *is* is pointless. :)
05:59:46 <nopoints> yes it is callled pointless when it is part of lambdabot
06:00:15 <ddarius> :t foldl
06:00:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:00:17 <ddarius> :t foldM
06:00:18 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
06:00:37 <ddarius> It is analogous to foldl, but you can, for example, "throw an exception".
06:07:32 <nopoints> > pl  \hs \n -> liftM (map Data.ByteString.length) (sequence $ map (\h->Data.ByteString.hGet h n) hs)
06:07:32 <lambdabot>  Parse error at "\hs" (column 5)
06:08:24 <Saizan_> @pl  \hs n -> liftM (map Data.ByteString.length) (sequence $ map (\h->Data.ByteString.hGet h n) hs)
06:08:24 <lambdabot> ((fmap (map Data . ByteString . length) . sequence) .) . flip (map . (((Data . ByteString) .) .) . flip hGet)
06:08:33 <Saizan_> lol
06:08:50 <Saizan_> @pl  \hs n -> liftM (map length) (sequence $ map (\h-> hGet h n) hs)
06:08:50 <lambdabot> ((fmap (map length) . sequence) .) . flip (map . flip hGet)
06:08:52 <nopoints> thanks Saizan_, I have never used lambdabot before
06:11:07 * vincenz groans at subtext
06:11:54 <ddarius> Seems like an appropriate response.
06:12:24 <vincenz> he's so overfocused on syntax
06:12:36 <vincenz> and IDE
06:12:44 <vincenz> "look you can google your code, look you can see your expressions nicely"
06:13:02 * vincenz bets it's insane to use on anything bigger than fibonacci
06:13:09 <vincenz> I've seen an earlier version of it, it was insane
06:13:24 <matthew_-> where's the monadic fibonacci code?
06:13:45 <vincenz> and seriously, how often do you deal with that many conditions
06:13:45 <osfameron> @index unfoldr
06:13:45 <lambdabot> Data.List
06:15:33 <vincenz> haha
06:15:34 <shapr> @yow
06:15:35 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
06:15:41 <vincenz> 'real programs have much hairier conditionals'
06:15:44 <vincenz> no git, they have harier cflow
06:15:45 <shapr> aww
06:16:57 <perspectival> gwern: hello?
06:40:39 <roconnor> @hoogle a -> a
06:40:40 <lambdabot> Prelude.id :: a -> a
06:40:41 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
06:40:41 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
06:40:46 <roconnor> @hoogle sequence
06:40:46 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
06:40:46 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
06:40:46 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
06:41:24 <roconnor> throwError is near the top of my list when I think of a -> a :P
06:41:56 <nopoints> @hoogle hGet
06:41:56 <lambdabot> IO.hGetBuffering :: Handle -> IO BufferMode
06:41:56 <lambdabot> IO.hGetChar :: Handle -> IO Char
06:41:56 <lambdabot> IO.hGetContents :: Handle -> IO String
06:42:30 <nopoints> so he doesn't search Data.Bytestring?
06:42:45 <quicksilver> well you only see the first three hits
06:42:48 <quicksilver> @hoogle chunks
06:42:49 <lambdabot> No matches found
06:42:57 <quicksilver> but, it looks like not
06:43:07 <quicksilver> @hoogle fromChunks
06:43:07 <lambdabot> No matches found
06:43:58 <nopoints> @hoogle Handle -> Int -> IO ByteString
06:43:58 <lambdabot> No matches, try a more general search
06:46:06 <nopoints> @hoogle hGetNonBlocking
06:46:06 <lambdabot> No matches found
07:24:35 <dcoutts_> aleator: darce pull
07:24:56 <dcoutts_> aleator: you'll also want to ./configure --disable-gstreamer as that bit is not compiling atm.
07:25:32 <MyCatSchemes> *darcs
07:25:44 <MyCatSchemes> (I know it's obvious but it's not nice to confuse people.)
07:26:07 <profmakx> OMG! darce the new haskell RCS?
07:26:12 <profmakx> *duq*
07:27:39 <ricky_clarkson> Halp, I can't build darce on Windows.
07:27:59 <profmakx> hm. i still cant build ghc on freebsd :(
07:28:28 <arcatan> I can't build houses
07:30:39 <MyCatSchemes> I can't build programs that work.
07:30:46 <Zao> profmakx: 6.6.1 built fine out of ports the other day here, what's wrong?
07:31:15 <profmakx> Zao, amd64, FreeBSD7 :)
07:31:42 <Zao> Ah, on the wild side. i386, 6.2-REL here :)
07:31:48 <Zao> I like my binary nvidia blobs.
07:34:51 <profmakx> well... i played with the thought of going back to 6.2-release
07:35:04 <jedbrown> Is it okay to have an instance of Num where ``_ * _ = undefined'' or is this bad?
07:35:06 <profmakx> i386
07:35:09 <profmakx> but then again
07:35:19 <pgavin> dcoutts: what's not compiling in gstreamer?
07:35:20 <lambdabot> pgavin: You have 1 new message. '/msg lambdabot @messages' to read it.
07:36:26 <dcoutts_> pgavin: lemme check again...
07:36:45 <pgavin> k
07:37:16 <dcoutts_> pgavin: I was having problems applying all your patches
07:37:17 <dcoutts_> some did not apply
07:37:26 <pgavin> ok
07:37:42 <pgavin> lemme see what you've got in the repo already
07:37:53 <dcoutts_> but that might have been because I had some patches from you from earlier which you ended up not using
07:38:05 <dcoutts_> so I unrecorded all the extra patches I had
07:38:13 <dcoutts_> and applied your cumulative patch again
07:38:24 <dcoutts_> I'm trying with that and I'll see if I can push without conflicts
07:38:26 <pgavin> dcoutts_:
07:38:38 <pgavin> dcoutts_: ok
07:38:56 <pgavin> dcoutts_: I just got a macbook so I'm trying to get gtk2hs compiling on it
07:39:49 <dcoutts_> ah nice
07:40:10 <pgavin> it took me a bit just to get ghc to compile
07:40:58 <pgavin> dcoutts: oh, I saw your message on the cabal list
07:41:12 <quicksilver> pgavin: a bit being 'port install ghc' ?
07:41:14 <pgavin> dcoutts_: about deps
07:41:17 <quicksilver> pgavin: or you chose a different path?
07:41:34 <pgavin> quicksilver: well, I'm using fink
07:41:47 <quicksilver> I use fink and macports :P
07:41:48 <pgavin> quicksilver: and I wanted ghc 6.8
07:41:51 <quicksilver> but I don't use fink for ghc
07:41:55 <quicksilver> ah well, that's fair enough
07:42:11 <pgavin> quicksilver: I used fink's ghc to bootstrap
07:42:18 <dcoutts_> pgavin: yes, so we looked at your dep code at the hackathon. kolmodin studied it for some time and could not understand it or debug it :-(
07:42:29 <pgavin> dcoutts_: lol
07:42:33 <dcoutts_> pgavin: we need something that's comprehensible as well as something that works
07:42:35 <pgavin> dcoutts_: is it that bad?
07:42:49 <pgavin> dcoutts_: I'm not the best at documenting I suppose
07:43:00 <dcoutts_> pgavin: apparently it worked first time, but doing a re-build did not work properly
07:43:06 <pgavin> dcoutts_: hmm
07:43:26 <dcoutts_> pgavin: I don't think it's that. The issue is cleanly separating things and being able to specify and test a design.
07:43:28 <pgavin> dcoutts_: yeah, it's still a bit buggy
07:43:44 <pgavin> dcoutts_: right
07:44:00 <dcoutts_> pgavin: being able to write a QC specifications of what make should actually do is pretty important
07:44:15 <pgavin> dcoutts_: good point
07:44:52 <pgavin> dcoutts_: It's more important to me that cabal has some kind of dependency system than that it has *my* dependency system
07:45:49 <dcoutts_> pgavin: we'd love to have your contributions
07:46:20 <pgavin> dcoutts_: sure, if there's anything you have in mind thaqt I can do
07:46:24 <dcoutts_> pgavin: perhaps you can help us with specification / unit tests or torture tests
07:46:30 <pgavin> sure
07:46:47 <dcoutts_> pgavin: tricky examples that we need to get right, and ways of checking we're doing those examples correctly
07:47:01 <dcoutts_> pgavin: eg search path shadowing bugs, they're nice
07:47:32 <pgavin> dcoutts_: ok, maybe like a test suite of example cabal packages
07:48:03 <dcoutts_> pgavin: have you looked at the code I posted
07:48:26 <pgavin> I scanned it
07:49:06 <dcoutts_> pgavin: I was hoping we'd be able to express most of the tricky cases in that pure framework
07:49:18 <dcoutts_> it being pure makes it much easier to automate tests
07:49:39 <pgavin> ok, gotcha
07:49:40 <dcoutts_> as we get more info on the internals, and we can use QC
07:49:58 <dcoutts_> pgavin: try the trace stuff, it's really cute
07:50:26 <dcoutts_> pgavin: we get the full history of the build process in terms of the primitive actions like reading & writing files
07:50:40 <dcoutts_> pgavin: if we need more actions recorded in the trace we can do that, eg running programs
07:51:03 <pgavin> dcoutts_: I saw that, its pretty cool
07:51:05 <quicksilver> dcoutts_: that sounds intriguingly clever?
07:51:17 <quicksilver> dcoutts_: are you autogenerating dependencies based on system traces?
07:51:50 <dcoutts_> quicksilver: no, generating traces from simulations of build processes
07:51:51 <dcoutts_> http://www.haskell.org/pipermail/cabal-devel/2007-October/001297.html
07:51:53 <lambdabot> Title: proptotype of make style dep stuff, http://tinyurl.com/2odhmr
07:51:56 <pgavin> dcoutts_: and write out those straight line build scripts you were talking about before
07:52:38 <dcoutts_> pgavin: I'd not thought of that. I was more thinking that the traces are the right thing to be making specifications about.
07:52:54 <pgavin> dcoutts_: ah, ok
07:52:58 <dcoutts_> pgavin: I mean, how exactly do we specify make?
07:53:10 <dcoutts_> what does it do? how do we see what it does?
07:53:20 <dcoutts_> how do we know it's doing the right thing
07:53:22 <pgavin> dcoutts_: by the resulting commands that are executed?
07:53:39 <dcoutts_> yes, and the order and stuff like that
07:53:59 <dcoutts_> and possibly the state of the system at various intermediate stages
07:54:12 <pgavin> dcoutts_: the idea to parameterize the monad is really great
07:54:24 <dcoutts_> it's pretty cunning, not my idea I think
07:54:41 <dcoutts_> I think it was nominolo's idea, or maybe kolmodin
07:54:47 <dcoutts_> but it is a good idea I think
07:55:01 <pgavin> dcoutts_: for testing it's perfect
07:55:17 <nominolo> i wanted easy testing of this stuff
07:55:25 <dcoutts_> and it allows optimising, since the monad can carry caches etc
07:55:28 <nominolo> the Cabal test suite is terrible to maintain
07:55:34 <dcoutts_> heh, yeah.
07:55:45 <dcoutts_> note how we don't maintain it
07:55:48 <pgavin> lol
07:56:06 <nominolo> yeah, we don't even try ...
07:56:25 <dcoutts_> quicksilver: mind you you could get a similar trace from a real build, using strace on the processes. You could find out what files they read and check your deps are correct.
07:56:35 <pgavin> @type (<?>)
07:56:36 <lambdabot> Not in scope: `<?>'
07:56:48 <quicksilver> dcoutts_: yes, it would be very similar
07:56:57 <pgavin> @hoogle <?>
07:56:57 <lambdabot> Text.ParserCombinators.Parsec.Prim.(<?>) :: GenParser tok st a -> String -> GenParser tok st a
07:56:59 <quicksilver> dcoutts_: someone did something rather like that for debian, years ago
07:57:11 <dcoutts_> quicksilver: it might allow us to check our QC specs on real builds
07:57:26 <dcoutts_> quicksilver: it'd be a pretty heavy weight but possibly very effective QA tool
07:57:59 * quicksilver nods
07:58:16 <quicksilver> the only really reliable way to check your deps are right is to build test in a sandbox
07:58:22 <quicksilver> which is what debian does anyway
07:58:31 <quicksilver> not for that reason; it does that for cross-compilation
07:58:39 <quicksilver> but the side-effect is that the build deps get checked
07:59:13 <mrd> @seen augustss
07:59:14 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
07:59:42 <pgavin> dcoutts_: ok, well I gotta go for now, I'll play with the code some when I get a chance
07:59:55 <dcoutts_> pgavin: ok, see you
08:02:52 <mrd> @tell augustss another small error: snd = \a:*.\b:*.\p:(Pair a b).split a b b (\x:a.\y:b.y) p  -- rather than "split a b a"
08:02:52 <lambdabot> Consider it noted.
08:03:36 <sebell> Hmm. Can I use groups/registers with Text.Regex.Posix? I'd like to get a list of all groups in the match
08:13:42 <quicksilver> sebell: yes
08:13:48 <quicksilver> sebell: it's all overloaded into the return type
08:14:00 <quicksilver> sebell: accept some suitably sick looking return type and you get all the groups
08:14:47 <sebell> quicksilver: Ah I see that in RegexContext. Thanks!
08:19:00 <quicksilver> actually I think it's suddenly dawned on me what my *real* objection to regexes overloading is
08:19:09 <quicksilver> it's not the horrendous numbers of overloads
08:19:19 <quicksilver> it's the way it overloads innocent looking types like lists of tuples
08:19:24 <quicksilver> would be much nicer with named types
08:19:35 <quicksilver> I must tell ChrisK (?) if I ever see him again
08:19:51 <shapr> @seen TuringTest
08:19:52 <lambdabot> Last time I saw TuringTest was when I left ##logic, #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #parrot, #perl6, #scala, #scannedinavian, #
08:19:52 <lambdabot> unicycling and #xmonad 6d 23h 6m 3s ago, and .
08:20:41 <bos> @seen glguy
08:20:41 <lambdabot> I saw glguy leaving #haskell and #xmonad 5h 20m 23s ago, and .
08:20:52 <quicksilver> (foo =~ bar) :: ListOfAllGroups
08:21:02 <quicksilver> sort of thing
08:21:05 <quicksilver> would be much nicer
08:21:40 <roconnor> > ln 100
08:21:41 <lambdabot>   Not in scope: `ln'
08:21:46 <roconnor> > log 100
08:21:48 <lambdabot>  4.605170185988092
08:22:23 <sebell> quicksilver: It looks like I have to use MatchResult or MatchText -- both are kindof ugly.
08:23:33 <byorgey> @src unfoldr
08:23:33 <lambdabot> unfoldr f b  = case f b of
08:23:33 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
08:23:33 <lambdabot>    Nothing        -> []
08:24:21 <luqui> @t unfoldr
08:24:22 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:24:27 <luqui> :t unfoldr
08:24:29 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:24:41 <quicksilver> sebell: matchResult is most general
08:24:51 <luqui> could have sworn it didn't mention maybe...
08:25:07 <quicksilver> sebell: otherwise there is the (String,String,String,[String]) form
08:26:12 <mcp_>   | (head e == last e) = istPal(e)            <-- Is the code i currently have. I'd like to print e to stdout. How can i add a print statement (without getting syntax errors)
08:26:40 <quicksilver> mcp_: short answer you cant, this is a pure language
08:26:49 <quicksilver> mcp_: however there is something called Debug.Trace which cheats
08:27:10 <quicksilver> even then you may not find the results as you expect, due to laziness
08:27:11 <mcp_> quicksilver, can u tell me how that would work?
08:27:29 <sebell> quicksilver: That's ok -- now how to determine what RegexContext a b (b, b, b, [b]) is supposed to mean without you telling me? ;)
08:27:32 <mcp_> quicksilver, wrong oder of outputs is no problem for me
08:27:32 <quicksilver> :t Debug.Trace.trace
08:27:34 <lambdabot> forall a. String -> a -> a
08:27:58 <quicksilver> mcp_: trace ("Hello I am here " ++ show e) istPal(e)
08:31:22 <mcp_> quicksilver, i get "undefine variable trace". So I tried "import Debug" but that didnt work either.
08:31:30 <quicksilver> mcp_: import Debug.Trace
08:31:56 <mcp_> quicksilver, stupid me, works now, thanks
08:32:01 <quicksilver> oh, I bracketted it wrong of course
08:32:08 <quicksilver> mcp_: trace ("Hello I am here " ++ show e) (istPal e)
08:32:12 <quicksilver> would be more likely to work :)
08:34:17 <dcoutts> yo SyntaxNinja
08:34:22 <SyntaxNinja> y0
08:34:26 <dcoutts> :-)
08:35:09 <dcoutts> SyntaxNinja: we've finally started looking at doing dep analysis in Cabal
08:35:35 <cizra> I bet there's a function in haskell that produces every possible pair out of a list. Is that true?
08:35:55 <dcoutts> SyntaxNinja: I sent a overly long code walk through to cabal-devel this morning with code from nominolo, kolmodin and me.
08:35:57 <kpreid> > liftM2 (,) [1,2,3] "abc"
08:36:02 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
08:36:23 <kpreid> > let l = [1,2,3] in liftM2 (,) l l
08:36:24 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
08:36:34 <kpreid> > join (liftM2 (,)) [1,2,3]
08:36:36 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
08:36:43 <cizra> ahha!
08:36:51 * dcoutts prefers (\xs -> (,) <$> xs <*> xs)
08:37:19 <cizra> Thank you very much.
08:37:22 <kpreid> @type <*>
08:37:24 <lambdabot> parse error on input `<*>'
08:37:26 <allbery_b> liftA2?
08:37:27 <kpreid> @type (<*>)
08:37:28 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:37:33 <kpreid> ah, ap
08:38:06 <sebell> quicksilver: Hmm.. I have to add a type annotation even when matching (_,_,_,g) = s =~ pat
08:38:16 <luqui> @type <$>
08:38:17 <lambdabot> parse error on input `<$>'
08:38:21 <luqui> @type (<$>)
08:38:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:38:22 <luqui> duh
08:38:52 <quicksilver> sebell: yeah, the instance selection isn't that clever
08:39:06 <sebell> :(
08:39:11 <quicksilver> kpreid: <$> is fmap and <*> is ap
08:39:40 <dcoutts> well, for a monad they are
08:39:45 <quicksilver> right
08:39:45 <kpreid> I figured, just from the usage pattern
08:40:05 <dcoutts> but there are types that are instances of Applicative which are not in the Monad class
08:53:15 <MyCatSchemes> :t forkIO
08:53:17 <lambdabot> Not in scope: `forkIO'
08:54:37 <darrint> Need help with stupid math question. (Not my homework, I swear.) m log (base x) m = n, I want to solve that for x, the log base.
08:54:59 <Botje> have you tried #math ?
08:55:09 <darrint> Botje: No. I will. Thanks.
08:55:20 <cizra> darrint: hey
08:55:25 <Botje> that said
08:55:34 <cizra> darrint: You can stick that first m into the logarithm argument
08:55:41 <Botje> log_x m = log m / log x
08:55:42 <cizra> log_x m^m = n
08:55:45 <darrint> ah.
08:55:51 <cizra> m^m = x * n
08:56:14 <mrd> x^n
08:56:37 <cizra> oh, yes, sorry
08:56:47 <mrd> root(n,m^m) = x
08:56:55 <darrint> so x is nth root of m^m? Bizarre!
08:57:05 <cizra> Not at all. Figure out what logarithm really means.
08:57:08 <Botje> m&ms? I could go for some.
08:57:18 <cizra> By the way, I've got a stupid math question also.
08:57:31 <cizra> (It's my homework, I swear) -- how do I take abs of a number?
08:57:41 <darrint> Thanks. I knew I'd find help here. :-)
08:57:44 <cizra> absolute value, I mean. What's the Haskell way to do this?
08:57:49 <ZsoL> abs
08:57:51 <mrd> abs isn't it
08:57:53 <mrd> @hoogle abs
08:57:54 <lambdabot> Prelude.abs :: Num a => a -> a
08:57:54 <lambdabot> System.IO.AbsoluteSeek :: SeekMode
08:57:54 <lambdabot> Language.Haskell.Syntax.HsEAbs :: HsQName -> HsExportSpec
08:57:58 <Botje> sure it is
08:58:05 <cizra> Oh my. Too intuitive to be true.
08:58:13 <MyCatSchemes> Gah. My program dies with no output whenever I try hPutStrLn into a Handle from a process opened with System.Process.runInteractiveCommand.
08:58:43 <MyCatSchemes> Is the System.Process module horribly buggy, or am I doing something horribly wrong?
08:58:55 <Botje> whichever it is, at least it's horrible.
08:59:03 <allbery_b> sounds like the command you ran didn't actually run and haskell got SIGPIPEd
08:59:46 <cizra> Uh.. about those join and liftM2, they are in some library I must import, right?
08:59:54 <allbery_b> Control.Monad
08:59:59 <allbery_b> @index liftM2
08:59:59 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:00:03 <cizra> OK, thanks.
09:00:11 <MyCatSchemes> allbery_b: yay, pinned it. runInteractiveProcess is failing.
09:00:20 <allbery_b> you may want Control.Monad.Reader instead for the definition of (->) r
09:00:32 <MyCatSchemes> Er, runInteractiveCommand. Hmmm.
09:00:40 <allbery_b> (since many interesting uses of liftM2 use the function monad)
09:01:33 * MyCatSchemes wonders what the heck exit code 13 indicates in this case. Oh, bother.
09:01:47 <quicksilver> unlucky for some
09:02:00 <quicksilver> full moon obstructing electron flow
09:02:03 <quicksilver> south bridge overheating
09:02:36 <MyCatSchemes> quicksilver: east bridge collapsed.
09:02:46 <allbery_b> MyCatSchemes: it confirms my suspicion:  program died on SIGPIPE
09:02:57 <MyCatSchemes> quicksilver: PEBCAK, probably, since I did write most of the programs being called out to here.
09:03:15 <allbery_b> (basically, nuked by the OS for writing on a closed pipe)
09:04:13 <MyCatSchemes> Prelude.head: empty list.
09:04:26 <MyCatSchemes> Huh. That's weird, since that list was produced by hGetContents.
09:05:23 <luqui> good ol' evil hGetContents
09:06:50 <cizra> I wrote a function that takes a (possibly empty) list that contains some pairs, and returns an integer. I can't figure out how to write a signature declaration for it. Help?
09:07:22 <Botje> have you tried asking your haskell interpreter?
09:07:28 <cizra> uh..
09:07:28 <cizra> no
09:07:31 <cizra> How to do this?
09:07:35 <Botje> :t function
09:07:41 <lambdabot> Not in scope: `function'
09:07:44 <luqui> haha
09:07:49 <Botje> I know. shut up, \bot
09:08:41 <cizra> Parse error on :
09:08:42 <quicksilver> cizra: Botje means, you don't need to write the signature declaration. If you miss it out, haskell will infer the type and then you can ask the interpreter.
09:08:50 <MyCatSchemes> ...huh. Weird.
09:08:55 <Botje> cizra: what interpreter?
09:09:02 <cizra> ghc and ghci, both
09:09:02 <quicksilver> cizra: ghci says 'parse error on :' ?
09:09:07 <cizra> main =         print $ :t sumItUp
09:09:11 <Botje> cizra: no no
09:09:16 <Botje> cizra: ghci yourfile.hs
09:09:29 <Botje> then enter :t sumItUp there
09:09:33 <allbery_b> the :-commands are handed by the ghci toplevel prompt
09:09:38 <allbery_b> they're not Haskell code
09:09:41 <cizra> \o/
09:10:07 <cizra> OK, that works. What is Num?
09:10:12 <phlpp> heja
09:10:15 <phlpp> :-)
09:10:24 <cizra> sumItUp :: (Num b) => [(b, b)] -> b
09:10:31 <allbery_b> Num is a typeclass
09:10:43 <cizra> OK, sorta like Integer, Integral and the like.
09:10:44 <allbery_b> it's the most general class describing numbers
09:10:52 <luqui> it means "b is some kind of numeric type" roughly.  b could be Integer, Double, ...
09:10:59 <cizra> Secondly, what is =>? I've only seen -> in function declarations so far.
09:11:10 <ddarius> class Thing a where {}
09:11:12 <allbery_b> Integer is a concrete type for arbitrary precision integers; Integral is a typeclass for integral values (Int, Integer, the Word* types, etc.)
09:11:22 <allbery_b> => is a typeclass constraint
09:11:30 <cizra> OK
09:11:44 <phlpp> byorgey: your southpark char looks like how i'd you expect you in real life :D
09:11:45 <ddarius> Better: class Type a where {}
09:11:54 <allbery_b> (Num b) => [(b,b)] -> b basically says any type b as long as it is a member of typeclass Num
09:11:58 <quicksilver> cizra: you can ignore the bit before the =>, at a first glance
09:12:02 <cizra> OK
09:12:03 <phlpp> arr, forget about one of that yous
09:12:06 <quicksilver> cizra: so the type is [(b,b)] -> b
09:12:16 <quicksilver> cizra: but then ther eis an aditional restriction on b
09:12:22 <cizra> *nod* but with the added constraint that b is numeric.
09:12:26 <quicksilver> cizra: so it's not "Any type b" but "Any type b which is a number"
09:12:28 <quicksilver> exactly
09:12:29 <cizra> Clear as soapy water.
09:12:37 <SyntaxNinja> dcoutts: cool.  do you want me to check it out?
09:12:39 <quicksilver> don't get it in your eyes.
09:13:38 <dcoutts> SyntaxNinja: sure, if you have time to read it through and think about it a bit and comment that'd be much appreciated
09:13:59 <MyCatSchemes> quicksilver: there has *got* to be a Sexy Losers reference hiding there somewhere.
09:14:49 <SyntaxNinja> dcoutts: cool.
09:20:03 <cizra> http://pastie.caboo.se/111213 -- Haskell error messages are still somewhat cryptic..
09:20:05 <lambdabot> Title: #111213 - Pastie
09:21:16 <luqui> cizra, they stay that way... usually I just look at the line number
09:21:43 <luqui> (if I _really_ think about it sometimes I can figure out what it's whining about)
09:21:58 <cizra> It probably thinks that I'm misusing that join.
09:22:26 <cizra> Frankly, I don't know even what it's supposed to do. http://www.haskell.org/onlinelibrary/monad.html this place isn't very helpful. Is there a good reference available somewhere?
09:22:27 <lambdabot> Title: The Haskell 98 Library Report: Monad Utilities
09:22:35 <kpreid> cizra: I'd recommend not using join
09:23:00 <cizra> kpreid: You're welcome to suggest something that 1) works, 2) is simple enough for me to understand.
09:23:02 <kpreid> cizra: the *reason* that doesn't work is you haven't imported Control.Monad.Reader. but don't do that.
09:23:09 <kpreid> just use the second of my examples :)
09:23:27 <kpreid> liftM2 (,) lst lst
09:24:02 <luqui> or heaven forbid something concrete like [ (a,b) | a <- lst, b <- list ]
09:24:13 <cizra> Oh!
09:27:10 <cizra> How do you debug Haskell code? I get wrong answers, although I suppose that most of my code is correct.
09:27:32 <kpreid> well, there's Debug.Trace
09:27:36 <madnificent> cizra: you can just call every function you care about from ghci too....
09:27:50 <kpreid> also, make sure it's broken up into bits you can usefully test
09:27:52 <kpreid> then test them
09:28:00 <dcoutts> and ghc-6.8.1 includes a debugger
09:28:05 <kpreid> either poke at them from ghci, or use a test tool, e.g. QuickCheck
09:28:16 <madnificent> cizra: or you could write unit tests ^_^
09:28:19 * cizra tries ghci
09:28:52 <madnificent> cizra: I only used ghci, it might not be there if you're using another implementation ^_^
09:29:49 <cizra> I'm using GHC.
09:31:06 <wsdo_okadr> if I have a CFG
09:31:45 <luqui> if I want to keep track of a "seen" set (for a graph traversal), what's the best way to do that
09:31:49 <luqui> Data.Map inside ST?
09:32:16 <luqui> I'm not sure about how lazy I want such a thing...
09:33:57 <luqui> or is there a better way to go about graph traversals altogether?
09:34:21 <cizra> Okie, now that I have those permutations, I wish to filter out those pairs that consist of identical members. filter looks like the right choice. I should write something like "filter (fst FOO == snd FOO) myList", right? But what's that FOO I should supply in?
09:34:27 <luqui> (I don't think fgl does what I want tho...)
09:35:03 <dcoutts> luqui: you can use a Data.Map without ST, but it costs log n for a lookup or to mark
09:35:05 <luqui> cizra, the parameter to the lambda:  filter (\x -> fst x ...
09:35:22 <cizra> Ow, lambda. I fear that word, I fear everything unknown..
09:35:30 <dcoutts> luqui: inside ST you could use an STUArray of Bools which gives you O(1) mark and test
09:35:41 <nopoints> @pl \h xss -> sequence $ map sequence (map (map (hGet h)) xss)
09:35:41 <lambdabot> ((sequence . map sequence) .) . map . map . hGet
09:35:51 <luqui> yum... I wonder if my problem maps into a space that small
09:35:53 <dcoutts> luqui: if your graph nodes are dense integers of course
09:36:37 <dcoutts> luqui: I usually find I have to keep bi-directional maps between graph node ids and their real names, which are often strings.
09:37:09 <luqui> pairs of (concievably long) lists of bools...
09:37:37 <luqui> hmm... kinda sounds like hashing to me actually
09:41:45 <cizra> OK, about those permutations again: [(a, b) | a <- lst, b <- lst] -- this makes all possible pairs of elements of lst. But how to ensure that it doesn't create pairs different only by the placement of the elements? Like.. the list [2, 3] should have only one pair, [(2, 3)] and not [(2, 3), (3, 2)]
09:41:56 <cizra> I'm still hazy about [(a, b) | <- stuff.
09:43:18 <dcoutts> cizra: then you'll have to filter out the ones that are swapped or change the way you generate them
09:43:19 <EvilTerran> as you've written it there, you'll get every arrangement of (one item from lst in a) and (one item from lst in b)
09:43:46 <EvilTerran> the cartesian product, if you're familiar with the term. iirc, it's called an outer join in databases.
09:44:13 <exDM69> haskell never stops to amaze me
09:44:18 * exDM69 is a C++ coder
09:44:55 <quicksilver> cizra: for example a <- lst, b <- (lst \\ [a])
09:45:07 <quicksilver> cizra: that ensures you don't pick the 'same' a
09:45:09 <cizra> Hmm.. lst without [a]?
09:45:14 <quicksilver> right
09:45:15 <EvilTerran> > (\lst -> [(a,b) | (a:as) <- tails lst, b <- as]) [1..6]
09:45:16 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(2,3),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6),(4,...
09:45:23 <quicksilver> of course, it doesn't help if there is more than one of the same in the list
09:45:28 <quicksilver> depends what you actually one
09:45:33 <EvilTerran> in that formulation, b will always be taken from after a in the list
09:45:33 <quicksilver> > [1,2,3] \\ [2]
09:45:35 <lambdabot>  [1,3]
09:45:41 <quicksilver> > [1,2,3,4,2,4,2] \\ [2]
09:45:43 <lambdabot>  [1,3,4,2,4,2]
09:46:03 <EvilTerran> so, if your list starts out with no duplicates, you won't get any duplicate pairs
09:46:06 <cizra> kodune1.hs:26:62: Not in scope: \'
09:46:10 <cizra> \\, actually
09:46:27 <EvilTerran> you won't get (2,2), say, either, though
09:46:34 <cizra> I don't want it.
09:46:48 <quicksilver> cizra: import Data.List to get \\
09:46:54 <cizra> Thanks.
09:47:02 <quicksilver> @index (\\)
09:47:02 <lambdabot> bzzt
09:47:04 <desegnis> > let lst = [1..3] in [ (a,b) | a <- lst, b <- lst, a <= b ]  -- Numbers have an order defined, so ...
09:47:05 <lambdabot>  [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
09:47:22 <allbery_b> hm, @index needs to be insultized :>
09:51:50 <cinimod> I've generated a C program and now I want to compile and run it. Any ideas on how to do this via Haskell?
09:52:50 * EvilTerran puts "write a modular C compilation system in haskell" on his big list of things to never get round to doing
09:52:55 <quicksilver> cinimod: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
09:52:57 <lambdabot> http://tinyurl.com/lw4ug
09:53:20 <quicksilver> cinimod: presumably, runCommand "gcc -o foo foo.c"
09:53:54 <cinimod> quicksilver: almost but that's what I need - thanks
09:55:55 <cizra> let lst = [4, 2] in [(a, b) | a <- lst, b <- (lst \\ [a])]
09:55:58 <cizra> > let lst = [4, 2] in [(a, b) | a <- lst, b <- (lst \\ [a])]
09:56:06 <cizra> lambdabot: *nudge*
09:56:09 <lambdabot>  [(4,2),(2,4)]
09:56:10 <chessguy> @bot
09:56:10 <lambdabot> :)
09:56:34 <cizra> quicksilver: Here's a proof that your suggestion doesn't work.
09:58:48 <quicksilver> cizra: ah, well, I misread your question :)
09:58:57 <quicksilver> cizra: I thought you jsut wanted to exclude (2,2) :)
09:59:11 <quicksilver> if you want to exclude all such things I suggest that ordering is the best option
09:59:26 <quicksilver> one way or another
10:00:09 <EvilTerran> nub $ sort $ [ (a,b) | a <- lst, b <- lst ] --?
10:00:15 <cizra> Uh, actually, theoretically the list might have multiple equal values. In this case, ordering-uniqueizing would destroy them.
10:00:23 <roconnor> > log pi
10:00:25 <lambdabot>  1.1447298858494002
10:00:54 <quicksilver> > let {perms [] = [[]]; perms (x:xs) = perms xs ++ map (x:) (perms xs)} in perms [1,2,4]
10:00:56 <lambdabot>  [[],[4],[2],[2,4],[1],[1,4],[1,2],[1,2,4]]
10:01:05 <desegnis> EvilTerran: You mean either (nub) or (map head . group . sort), I s'pose
10:01:08 <cizra> (\lst -> [(a,b) | (a:as) <- tails lst, b <- as]) lst -- this works \o/
10:01:29 <cizra> I'm not exactly sure what it does, but it does it well.
10:01:34 <EvilTerran> desegnis, what?
10:01:40 <EvilTerran> yes. quite.
10:01:52 <EvilTerran> never mind.
10:01:58 <quicksilver> cizra: possibly my version is 'clearer' although it's not very fast
10:01:59 <desegnis> fine :)
10:02:02 <EvilTerran> > tails [1..5]
10:02:03 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
10:02:05 <Cale> cizra: It picks all pairs (a,b) of elements of the list where a occurs before b in the list
10:02:23 <EvilTerran> > [a | (a:as) <- tails [1..5]]
10:02:24 <lambdabot>  [1,2,3,4,5]
10:02:30 <cizra> Cale: Just what I needed to do, by definition. However, how does it work? /me ponders
10:03:02 <cizra> > [a | a < [1..5]]
10:03:03 <lambdabot>   Not in scope: `a'
10:03:04 <quicksilver> @tell Cale my former phd supervisor replied and confirmed that we're absolutely right. He did think he remembers that the Kleisli over a symettric monoidal category can be monoidal, if the monad itself respects the tensor.
10:03:04 <lambdabot> Consider it noted.
10:03:08 <EvilTerran> if it helps, it desugars to approximately
10:03:14 <Cale> Well, first it picks a nonempty tail of the list, deciding that a is the first element of that. Then it picks b from the rest of that tail.
10:03:14 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
10:03:23 * quicksilver laughs
10:03:31 <quicksilver> speak of the devil
10:04:01 <EvilTerran> er, never mind. the desugaring's messy.
10:06:19 <Cale> cizra: does that make sense?
10:06:29 <cizra> Sorta.
10:06:34 <cizra> Well, yes, actually
10:06:37 <Cale> > [(a,as) | (a:as) <- tails [1..3]]
10:06:39 <lambdabot>  [(1,[2,3]),(2,[3]),(3,[])]
10:06:54 <cizra> .. except the lambda thing, which I'm unfamiliar with.
10:06:54 <Cale> > [(a,as,b) | (a:as) <- tails [1..3], b <- as]
10:06:55 <lambdabot>  [(1,[2,3],2),(1,[2,3],3),(2,[3],3)]
10:07:06 <Cale> > [(a,b) | (a:as) <- tails [1..3], b <- as]
10:07:07 <lambdabot>  [(1,2),(1,3),(2,3)]
10:07:19 <Cale> Oh, the lambda's not much
10:07:40 <Cale> (\x -> ...) is the function which takes x as a parameter and returns ...
10:08:04 <cizra> That's all?
10:08:09 <Cale> yep
10:08:25 <cizra> Uh.. What's the simplest way you can use this?
10:08:36 <cizra> A newbie example for easier comprehension
10:09:18 <Cale> > (\x -> x^2 + 1) 5
10:09:20 <lambdabot>  26
10:09:33 <Cale> > (\x -> x^2 + 1) 10
10:09:34 <lambdabot>  101
10:09:41 <Cale> > map (\x -> x^2 + 1) [1..10]
10:09:43 <lambdabot>  [2,5,10,17,26,37,50,65,82,101]
10:09:44 <cizra> Oh, so it turns a bunch of code into an operator, sorta like
10:09:55 <Cale> an anonymous function
10:09:59 <quicksilver> > [ x^2 + 1 | x <- [1..10]]
10:10:00 <lambdabot>  [2,5,10,17,26,37,50,65,82,101]
10:10:08 <cizra> Nifty...
10:10:09 <quicksilver> ^^ the connection between lambdas and list notation
10:11:21 <Cale> There are a *lot* of places in functional programming where defining a named function separately is just way too heavy syntactically.
10:11:43 <Cale> and you just want to be able to specify something in-place
10:12:07 <Cale> In your case though, I probably would just name the function though.
10:12:38 <cizra> Nah, it'll do when I understand it.
10:13:16 <Cale> (or if I was only going to use that in one place, I'd likely unwrap the lambda)
10:13:35 <cizra> "unwrap?"
10:13:43 <Cale> (\xs -> [(a,b) | (a:as) <- tails xs, b <- as]) lst
10:13:47 <Cale> is the same as
10:13:55 <Cale> [(a,b) | (a:as) <- tails lst, b <- as]
10:14:04 <Cale> (by definition)
10:14:05 <cizra> umm.. yes, I see
10:14:24 <quicksilver> just as you'd never write (\x -> x + 1) y
10:14:29 <quicksilver> you'd just write y + 1
10:14:33 <cizra> yesyes, I see.
10:16:04 <Cale> If lst is something complicated though, you still may want to define it in a let, so that the memory usage will be the same as with the function
10:16:14 <Cale> let lst = ... in [(a,b) | (a:as) <- tails lst, b <- as]
10:16:28 <Cale> well, here it can't make a difference
10:16:38 <Cale> But it could if lst occurred multiple times
10:16:53 <Cale> (and was not just a variable)
10:17:49 <cizra> No, it's fine when unwrapped. It is an easy function.
10:18:50 <cizra> What I'm really worried about is that altogether I see the fun of list manipulations etc, I really can't see why I should prefer Haskell over, say, Ruby or something in real world.
10:19:08 <Cale> Yeah, I'm just awkwardly trying to say that when a parameter to a lambda (or any other function) is duplicated in the body, it's still only computed once, even though it's computed after the function is applied.
10:19:45 <Cale> Well, that'll come with time, I suppose :)
10:19:49 <cizra> lazy evaluation FTW
10:23:15 <Cale> > mapM (\x -> [1..x]) [2,3,4]
10:23:17 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,2,1],[1,2,2],[1,2,3],[1,2,4],[1,3,1],[1,...
10:24:07 <Cale> > length . mapM (\x -> [1..x]) $ [2,3,4]
10:24:08 <lambdabot>  24
10:24:09 <EvilTerran> cizra, the type system is a pretty big selling point
10:24:14 <Cale> > 2 * 3 * 4
10:24:16 <lambdabot>  24
10:24:20 <Cale> Yeah, hehe
10:24:31 <cizra> Huh? It looks just like object-oriented inheritance to me.
10:24:34 <Cale> That would be one major issue for me
10:24:36 <cizra> Nothing spectacular nor innovative.
10:24:43 <EvilTerran> oh, heavens no!
10:24:53 <Cale> cizra: No, it's very different from that.
10:25:00 <cizra> Always ready to admit my mistakes. What's the difference?
10:25:10 <EvilTerran> regardless, i meant type inference more than anything
10:25:33 <Cale> And we don't even really have anything like inheritance.
10:25:35 <EvilTerran> although that requires a good arrangements of types underneath to be really useful
10:26:17 <EvilTerran> analogies could be drawn between haskell's "class"es and, say, Java's "interfaces"
10:26:26 <Cale> The closest thing is perhaps the ability to constrain classes such that if you want to write an instance of one, you must write an instance of the other.
10:26:41 <EvilTerran> and likewise haskell's "instance"s and java's "class ... implements"
10:26:42 <Cale> EvilTerran: kind of weak analogies, really :)
10:26:53 <cizra> Uh.. OK
10:27:06 <EvilTerran> Cale, well... it's the best analogy to OO I can think of
10:27:10 <Cale> yeah
10:27:17 <Cale> cizra: We don't really use subtype polymorphism
10:27:30 <Cale> cizra: Instead we use something called parametric polymorphism
10:27:34 <cizra> Eek
10:27:39 <Cale> length :: [a] -> Int
10:28:03 <cizra> I'm tired and it'll be pretty useless to tell me about new stuff now..
10:28:03 <Cale> length takes a list whose values are of any type a, and returns an Int
10:28:10 <EvilTerran> however, there's a load of stuff that comes much more easily in our type system than in standard OO; Cale's example there, for instance, either requires unsafe casting or generics
10:28:54 <EvilTerran> well, that in particular wouldn't, but having a type-agnostic linked-list class would
10:29:01 <EvilTerran> in general
10:29:08 <mrd> and java generics are retarded and will probably require unsafe casting anyhow
10:29:29 <Cale> cizra: Suffice it to say that our type system is completely upside down and backwards from your typical OO language's, and that it's probably a good thing ;)
10:29:50 <mrd> upside down and backwards from an upside down and backwards OO language is a good thing
10:30:04 <mrd> straight up and forwards
10:30:21 <cizra> Okie
10:31:15 <Cale> The type inference is one major difference, when you're talking about ease of use
10:32:12 <EvilTerran> inference is brilliant; that's why C# stole it
10:32:21 <Cale> In OO languages, they tend to force you to make a decision between explicitly stating every one of your types in a verbose mess to get some static guarantees, or not specifying much of anything and having no compile-time guarantees at all.
10:32:50 <ricky_clarkson> Every language uses stuff from other languages, stealing seems to have inappropriate negative connotations.
10:33:03 <ricky_clarkson> Cale: See Scala.
10:33:04 <EvilTerran> ah, it was only meant in jest
10:33:05 <Cale> C# stole it somewhat, but I think there are fundamental limitations on how far it can be taken in a language with subtype polymorphism
10:34:02 <EvilTerran> Cale, indeed. such as that you can't say "var foo = new Bar" if you want foo to have a type superclassing Bar, i believe
10:34:23 <Cale> That makes sense
10:34:26 <EvilTerran> although it may be able to infer that a superclass is necessary based on behaviour elsewhere
10:34:34 <ricky_clarkson> EvilTerran: Why would you care whether foo was of type Bar or a supertype thereof?
10:34:47 <mrd> unique typing goes all to hell with subtypes
10:35:06 <EvilTerran> or indeed it might be able to pick the biggest superclass based on which members you've used
10:35:26 <EvilTerran> I don't know. this is idle speculation.
10:35:50 <Cale> I seem to recall there are some cases where it becomes computationally intractable.
10:36:17 <Cale> (like, not impossible, just horribly complex)
10:36:19 <mrd> parametric polymorphism is much cooler, anyhow, because while at the same time as giving you more flexibility, it also allows you to limit what kind of programs can possibly satisfy the type
10:36:29 <cizra> OK, here's a question about a special case: isOrderedBy checks if the list is ordered by this function.
10:36:32 <cizra> isOrderedBy func [] = True
10:36:38 <cizra> (by definition of the task, this must be so)
10:36:42 <Cale> sure
10:36:55 <cizra> However, when compiling isOrderedBy (<5) [], Haskell complains.
10:37:09 <EvilTerran> how many parameters does func take?
10:37:13 <cizra> > let isOrderedBy func [] = True in isOrderedBy (<5) []
10:37:13 <EvilTerran> how many does (<5) take?
10:37:14 <lambdabot>  True
10:37:24 <cizra> EvilTerran: Just one, I suppose?
10:37:36 <Cale> You probably want func to take two parameters
10:37:37 <cizra> Hmm, lambdabot likes it...
10:37:38 <EvilTerran> how can you check for ordering with only one parameter to your function?
10:37:39 <mrd> shouldn't the 'func' be a -> a -> Order
10:37:52 <mrd> @hoogle Order
10:37:52 <lambdabot> Prelude.Ordering :: data Ordering
10:37:53 <lambdabot> Distribution.GetOpt.RequireOrder :: ArgOrder a
10:37:53 <lambdabot> Distribution.GetOpt.ReturnInOrder :: (String -> a) -> ArgOrder a
10:37:56 <EvilTerran> mrd, or a -> a -> Bool, if it's just a (<=) parallel
10:37:57 <mrd> Ordering
10:38:00 <cizra> Well, (<5) is an one-parameter function.
10:38:05 <mrd> well, fix it =)
10:38:24 <mrd> what does it mean to say "list is ordered by (<5)?"
10:38:29 <EvilTerran> cizra, does it make sense to call (<5) an ordering?
10:38:31 <Cale> cizra: What does it mean for a list to be ordered by (<5)... damn you
10:38:39 <mrd> we've gone beyond stereo
10:38:41 <cizra> nope
10:38:44 <mrd> surround sound
10:38:45 <byorgey> > let isOrderedBy func [] = True in isOrderedBy [1,2,3] []
10:38:46 <lambdabot>  True
10:38:46 <cizra> Actually, I'm confused.
10:38:57 <mrd> or is it just a fugue
10:39:02 <opqdonut> :D
10:39:05 <byorgey> if that's the only definition you give for isOrderedBy, the 'func' parameter just gets ignored.
10:39:39 <Cale> Presumably in the non-base-case, you'll want to use func to compare pairs of adjacent elements of the list
10:39:57 <Cale> So it shouldn't be a one-parameter function
10:40:24 <cizra> *sigh* my mistake
10:40:33 <cizra> The function must look like this:
10:40:33 <cizra> isOrderedBy :: (a -> a -> Bool) -> [a] -> Bool
10:40:37 <Cale> right
10:40:44 <cizra> And yes, it's a two-parameter function.
10:40:46 <EvilTerran> > zipWith (<=) =<< drop 1 $ [1,2,3,4,3,3,2,5]
10:40:47 <lambdabot>  [False,False,False,True,True,True,False]
10:40:51 <Cale> so (<5) is not an appropriate first parameter, but you could pass (<)
10:40:58 <cizra> yes, that was my bad.
10:41:04 <EvilTerran> <.< >.>
10:41:15 <Cale> ap (zipWith (<=)) (drop 1) [1,2,3,4,3,3,2,5]
10:41:17 <Cale> > ap (zipWith (<=)) (drop 1) [1,2,3,4,3,3,2,5]
10:41:18 <lambdabot>  [True,True,True,False,True,False,True]
10:41:22 <mrd> > let 1 <.< 2 = True in 1 <.< 2
10:41:24 <lambdabot>  True
10:41:30 <Cale> > ap (zipWith (>)) (drop 1) [1,2,3,4,3,3,2,5]
10:41:31 <lambdabot>  [False,False,False,True,False,True,False]
10:42:17 <byorgey> > length . filter id $ ap (zipWith (>)) (drop 1) [1,2,3,4,3,3,2,5]
10:42:18 <lambdabot>  2
10:42:24 <Cale> > ap (zipWith (>=)) (drop 1) [1,2,3,4,3,3,2,5]
10:42:25 <lambdabot>  [False,False,False,True,True,True,False]
10:42:28 <Cale> aha
10:42:45 <Cale> or just and
10:42:51 <Cale> > and . ap (zipWith (>=)) (drop 1) $ [1,2,3,4,3,3,2,5]
10:42:53 <lambdabot>  False
10:43:04 <Cale> > and . ap (zipWith (>=)) (drop 1) $ [1,2,3,4,4,5]
10:43:05 <lambdabot>  False
10:43:07 <byorgey> Cale: but that discards information =)
10:43:30 <Cale> > and . ap (zipWith (>=)) (drop 1) $ [4,3,3,2,2,1]
10:43:32 <lambdabot>  True
10:43:38 <EvilTerran> ?type (<*)
10:43:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
10:43:44 <byorgey> nice
10:43:48 <EvilTerran> hm
10:43:54 <EvilTerran> ?docs Control.Applicative
10:43:54 <lambdabot> Control.Applicative not available
10:44:01 <Cale> haha
10:44:24 <byorgey> EvilTerran: whatcha looking for?
10:44:32 <EvilTerran> jus' thinking
10:44:49 <byorgey> hm, I suppose that's allowed =)
10:45:00 <EvilTerran> ?type ap
10:45:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:45:47 <Cale> > and . zipWith (>=) <*> drop 1 $ [4,3,3,2,2,1]
10:45:48 <lambdabot>  Couldn't match expected type `[Bool]'
10:45:55 <EvilTerran> ah. that's the one. ap = (<*>).
10:46:10 <Cale> > and . (zipWith (>=) <*> drop 1) $ [4,3,3,2,2,1]
10:46:11 <lambdabot>  True
10:46:25 <EvilTerran> *doh* of course it does, i should've remembered that from the Applicative paper
10:46:28 <Cale> Rrright
10:47:00 <cizra> http://pastie.caboo.se/111213 -- Why does this neat simple little piece of code not work?
10:47:02 <lambdabot> Title: #111213 - Pastie
10:48:46 <byorgey> yeesh
10:48:58 <byorgey> is it because of the empty list?
10:49:08 <cizra> yep
10:49:29 <byorgey> does it work if you do isOrderedBy (<) [1,2,3]?
10:49:52 <cizra> Yes. Well, I didn't paste the other pattern-matchings, but it generally works.
10:50:02 <byorgey> yeah, that's a subtle problem.
10:50:31 <byorgey> the empty list has type [a], where a could be anything, and it can't prove that a is in the Ord class (as is required to use <).
10:50:45 <byorgey> of course, you and I both know that it doesn't matter since there's nothing to compare, but...
10:50:55 <cizra> well, yeah
10:50:55 <byorgey> you can fix it by giving [] an explicit type
10:51:10 <byorgey> i.e. isOrderedBy (<) ([] :: [Int]), for example
10:51:36 <cizra> Can I somehow do this in the function declaration?
10:51:51 <cizra> Force the argument to be of [Int] type
10:52:08 <Cale> yeah
10:52:13 <byorgey> well, if you want, you could make isOrderedBy of type (Int -> Int -> Bool) -> [Int] -> Bool
10:52:18 <EvilTerran> it'd kinda defeat the object of your nice polymorphic function, though
10:52:22 <byorgey> but in practice it shouldn't really be necessary.
10:52:39 <byorgey> in practice you probably won't ever apply isOrderedBy explicitly to [].
10:52:40 <Botje> cizra: you can write the sig yourself and restrict it
10:52:48 * EvilTerran wonders if he can work the monomorphism restriction into this somewhere
10:53:12 <Botje> cookies?
10:53:25 <Cale> cizra: I agree with byorgey. If you ever do apply it to an empty list, it'll most likely be an empty list whose type is known
10:53:28 <cizra> Myeah. I've the type declaration supplied to me, so it won't work either. Well, I'll just accept the sad truth that it won't work on empty lists.
10:53:37 <Cale> It will, in general
10:53:41 <byorgey> cizra: no, it works fine on empty lists.
10:54:22 <EvilTerran> usually the type of the list will be concrete enough for that to not be a problem, in practice
10:54:43 <EvilTerran> you'll never actually need to type "isOrderedBy (<) []", 'cos you know what the answer is ;)
10:55:03 <cizra> yep
10:55:14 <Cale> however, if you apply it to another list, which just happens to be empty, you must know what the type of that list is
10:55:42 <cizra> Okie, another question.
10:55:47 <cizra> > True && False
10:55:59 <lambdabot>  False
10:56:22 <Cale> btw, did everyone see that new subtext demo?
10:56:37 <bakert> is there any way to get the name of a record field?
10:56:46 <byorgey> Cale: no, what's that?
10:56:51 <bakert> A { b :: String }
10:56:53 <Cale> http://subtextual.org/subtext2.html
10:56:54 <bakert> I want "b"
10:56:54 <lambdabot> Title: Created with Camtasia Studio 5
10:57:00 <byorgey> bakert: given what?
10:57:00 <dmwit> bakert: Not really.
10:57:01 <Nafai> Cale: Yeah, it was interesting...not sure how I feel about it yet
10:57:07 <bakert> byorgey: given the record
10:57:12 <bakert> a record
10:57:30 <byorgey> bakert: well, if it derives Show, you could show it and then parse the result...
10:57:33 <Cale> Well, it's a neat way to visualise a functional language :)
10:57:34 <byorgey> kind of ugly though =)
10:57:34 <desegnis> bakert: A record can have multiple fields
10:57:52 <bakert> desegnis: that was my simple example :)
10:58:19 <bakert> records are just atrocious really, aren't they?  i need to get more functional in my thinking.  good articles/bools?
10:58:24 <bakert> s/bools/books/g
10:58:34 <dmwit> bakert: Given the entire record, or the value of "b" only?
10:58:58 <bakert> dmwit: given a record with whatever value in b.  can i get "b" without horrible parsing-show contortions?
10:59:10 <bakert> perhaps i should implement show on the record somehow
10:59:11 <desegnis> bakert: And if you know the record's type, you (the programmer) know the fields anyway. And if you don't know the precise type, you don't even know whether you have a record
10:59:22 <dmwit> i.e. if data R = A {b :: String}; getRecordName :: {- ??? -}
10:59:42 <bakert> OK, so say I have a record that is like this:
10:59:53 <bakert> X { a :: Int, b :: Int, c :: Int }
10:59:55 <byorgey> cizra: what was your other question?
11:00:00 <bakert> and i want to know all those fields that are > 16
11:00:05 <bakert> how would i do that?
11:00:10 <cizra> byorgey: Why the hell doesn't my line nr 10 work
11:00:34 <cizra> isOrderedBy func lst = (func (lst !! 0) (lst !! 1)) && (isOrderedBy (tail (tail lst)))
11:01:08 <oerjan> bakert: in that case you can map ($ r) [a,b,c] since they are all the same type
11:01:13 <dmwit> bakert: [["a"]|a > 10] ++ [["b"]|b > 10] ++ [["c"]|c > 10]
11:01:14 <Cale> cizra: That misses every other pair
11:01:26 <Cale> cizra: also, use pattern matching ;)
11:01:31 <cizra> oh!
11:01:44 <cizra> Cale: Hmm? Pattern matching? How?
11:02:08 <Cale> isOrderedBy f (x:y:xs) = f x y && isOrderedBy f (y:xs)
11:02:08 <cizra> You mean, (a:b:remainder)?
11:02:33 <Nafai> Cale: In a way, it seemed like the fibonacci example he gave showed the equivalent of requiring (what's the term?) exhaustive pattern matching, right?
11:02:45 <byorgey> pattern matching lets you destructure the list right up front so you don't need all that !! 0, !! 1, tail tail stuff =)
11:02:50 <Nafai> Cale: Where it would show when certain cases weren't covered?
11:02:50 <cizra> \o/
11:02:58 <Cale> Nafai: well, at least it will warn you
11:03:15 <Cale> Nafai: with a nice big red column :)
11:03:35 <Nafai> Right
11:04:34 <dmwit> oerjan: Something like this?  filter snd . zip ["a", "b", "c"] . map ((>16) . ($ r)) $ [a, b, c] -- ewww, not that my solution was better
11:04:51 <dmwit> oh no
11:05:47 <oerjan> you could actually do filter ((>16) .($r)) [a, b, c]
11:05:58 <dmwit> Yes, but that wouldn't give the names of the records.
11:06:01 <dmwit> Only the values.
11:06:05 <dmwit> Unless that's what he wanted?
11:06:06 <oerjan> indeed
11:06:07 <bakert> mm
11:06:25 <bakert> there are 13 of them you see (not three) so i was trying to avoid typing all the names
11:06:32 <bakert> but maybe i should just use a Map or something
11:06:37 <dmwit> yeah
11:06:47 <oerjan> however, those values could at least be used on other records of the same type
11:06:48 <dmwit> If you really need the names of the records (why?), then maybe a Map is better.
11:06:56 <oerjan> except not for pattern matching
11:07:10 <bakert> although that gives me problems elsewhere that my records with functional references solve
11:07:12 <bakert> :(
11:07:32 <dmwit> So, what is the motivation behind this question?
11:07:36 <bakert> dmwit: i just need the names for a string representation of remarkable attributes.  these things are notable about this object
11:08:01 * bakert notes my giveaway use of the word object
11:08:15 * bakert needs to think functionally, somehow
11:08:25 <blsecres> is there a way to pass flags to ld via cabal?  I'm running into issues building X11
11:08:33 <augustss> yo
11:08:33 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
11:08:57 <dmwit> bakert: How about this:
11:09:31 <dmwit> bakert: never mind
11:09:33 <dmwit> =/
11:09:34 <bakert> :)
11:11:35 <vincenz> augustss: ping
11:11:45 <augustss> Hi
11:11:50 <vincenz> the email?
11:11:56 <vincenz> Was that accidental?
11:12:06 <augustss> Wrong vincent :)
11:12:12 <vincenz> Ok :)
11:12:49 <roconnor> wow, I was right!
11:13:02 <vincenz> augustss: roconnor was pretending to speak for you
11:13:09 <vincenz> augustss: I would crucify him
11:13:17 <vincenz> The biblical way
11:13:22 <roconnor> I guess I make a pretty fair augustss imposter.
11:13:25 <augustss> as long as he speaks the truth I don't have a problem with it
11:13:36 <vincenz> roconnor: you're an augustss-oracle?
11:13:41 <roconnor> yep
11:13:49 <dmwit> He speaks the truth, never fronts one bit!  He and DJ So-Sincere don't quit!
11:13:52 <dmwit> wikka wikka
11:13:54 <vincenz> roconnor: should publish a paper with your markov model
11:14:20 <augustss> it's all in his brain
11:15:09 <vincenz> roconnor: sacrifice your brain in the name of science
11:15:24 <augustss> I should have suspected something as we stared each other down over a beer.  (One beer, mine, if I remember right.)
11:15:38 <vincenz> Fighting over the last beer?
11:16:05 <augustss> last beer in germany?  I don't think so!
11:16:24 <vincenz> augustss: you were at icfp?
11:16:29 <vincenz> augustss: should've stuck around for hac :)
11:16:48 <augustss> well, i had a plane to catch to new york on saturday.  from london
11:16:52 <vincenz> ah
11:16:55 <roconnor> I absorbed augustss mind
11:17:22 <augustss> stored it in a constructive real, no doubt
11:17:37 <roconnor> :)
11:17:44 <vincenz> better than a destructive imaginary
11:18:53 <hpaste>  Julien Oster pasted "permtree2.hs" at http://hpaste.org/3484
11:21:37 <excitingjelly> hello
11:21:44 <excitingjelly> can you delete something from hpaste?
11:21:46 <vincenz> augustss: what are the major additions w.r.t. your f-omega implementation (besides more base types) that GHC has?
11:22:24 <excitingjelly> i'd like to resubmit it with a fixed comment because I screwed it up
11:22:48 <excitingjelly> http://hpaste.org/3484
11:23:17 <excitingjelly> (the comment should read "printing out a subdirectory only if its mode differs from its parent's mode")
11:23:40 <dons> there's no need to delete it, is there?
11:23:57 <dons> we like our variables, and pastebins, to be immutable :)
11:24:10 <excitingjelly> well, people could think I suck at writing english (yes, I know I'm extreme 8) )
11:24:37 <vincenz> dons: you mean monoidal, with only an append operation :)
11:26:03 <yeoh> @type map
11:26:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:26:06 <hpaste>  Julien Oster pasted "permtree2.hs" at http://hpaste.org/3485
11:26:09 <dmwit> excitingjelly: You could annotate it.
11:26:22 <excitingjelly> dmwit, hmm. yes, I'll do that. thanks.
11:26:33 <hoelzro> when I export a Haskell function via the FFI, and I call it from C, what object files do I need to link to when I call gcc?
11:26:33 <lambdabot> hoelzro: You have 1 new message. '/msg lambdabot @messages' to read it.
11:26:56 <dons> hoelzro: check the ffi guide, ghc will generate some .h files and .c files to link against
11:27:27 <hpaste>  Julien Oster annotated "permtree2.hs" with "permtree2.hs" at http://hpaste.org/3484#a1
11:27:48 <hoelzro> I checked, and linked against the stubs, but I have a bunch of unresolved symbols like base... and stg...
11:28:40 <yeoh> Does any monad-fu know of a shorter way of expressing this: m >>= return . f
11:28:48 <dmwit> liftM/fmap
11:29:17 <dons> ?pl m >>= return . f
11:29:18 <lambdabot> f `fmap` m
11:29:29 <dons> <$> is also an optoin
11:29:36 <dons> :t toUpper `fmap` getChar
11:29:38 <lambdabot> IO Char
11:29:44 <dons> :t toUpper <$> getChar
11:29:46 <lambdabot> IO Char
11:29:56 <dons> :t getChar >>= return . toUpper
11:29:58 <lambdabot> IO Char
11:29:58 <roconnor> :t toUpper `liftM` getChar
11:29:59 <lambdabot> IO Char
11:30:56 <yeoh> hmm, obviously so in hindsight
11:31:08 <yeoh> thx everyone
11:31:14 <byorgey> yeoh: that's ok, it always is =)
11:41:10 <Cale> grr
11:41:30 <Cale> hoelzro left before I could answer
11:41:59 <byorgey> =(
11:42:45 <Cale> Oh, dons answered him, I missed that.
11:43:19 <araujo> http://www.cs.nott.ac.uk/~wss/repos/IOSpec/www/unsafe.jpg
11:43:32 <Cale> Isn't the real answer (at least for convenience's sake), just to compile your C program with ghc?
11:44:11 <dmwit> araujo: hehe
11:44:46 <dmwit> Oh noes, arcanux.org is down!
11:44:52 <dmwit> Where will I get my lambdacats fix?
11:45:18 <Cale> http://cale.yi.org/autoshare/coequaliser.jpg
11:46:56 <dmwit> HaskellWiki is on the first page of results for a Google Image search. =P
11:50:34 <roconnor> what's the relationship between epigram and simple easy!?
11:51:17 <Cale> They're both dependently typed?
11:52:51 <roconnor> but they aren't the same?
11:52:58 <roconnor> epigram 2 core and simple easy!
11:55:00 <Cale> I don't know.
12:29:55 <augustss> roconnor: I think epigram core is more complex.  isn't it based on OTT?
13:10:07 <hpaste>  sebell pasted "'do' notation woes" at http://hpaste.org/3486
13:11:07 <conal> sebell: "data" is a keyword
13:11:16 <sebell> Of course it is.
13:11:22 <sebell> Thanks :)
13:11:38 <conal> :)  it only occurred to me because hpaste colored it.
13:12:03 <sebell> It did indeed!
13:13:17 <Cale> Kind of odd that it would give that particular error message, actually.
13:13:41 <conal> yeah -- pretty obscure.  must be an inner logic.
13:13:43 <sebell> I can't say that I wasn't confused by it...
13:14:10 <Cale> That's a worse kind of syntax error than the usual sort which triggers that message.
13:14:22 <conal> oh -- the "data" declaration was taken to end the "do", in order to parse.
13:14:23 <byorgey> you'd think it would give some sort of parse error or something.
13:15:41 <Cale> Yeah, I would have thought layout would have ended up making that  do { ... ; data <- ... ; ... }
13:16:09 <Cale> But I suppose that it makes it into  do { ... ls <- ... } data <- mapM ...
13:16:39 <oerjan> Cale: it inserts }'s by the parse-error rule
13:17:17 <oerjan> but it could have done better given that data cannot work even after that
13:17:40 <omnId> It could be helpful if, when the parse-error-insertion rule *itself* causes a parse error, it'd tell you.
13:18:02 <oerjan> since a ; is needed before data - but perhaps ghc relaxes that?
13:18:38 <omnId> oerjan: hm?  ; before data?
13:18:54 <oerjan> omnId: a layout newline is equivalent to ;
13:19:04 <oerjan> if at the same indentation
13:19:17 <omnId> oerjan: you're talking about the ; seperating toplevel decls?
13:19:23 <oerjan> yep
13:19:29 <TomMD> Does GHC6.8 remove the readline4.3 requirement?
13:20:23 <sebell> TomMD: 6.6.1 doesn't require readline, nor readline4 AFAIK -- at least my build doesn't use either.
13:20:29 <sjanssen> TomMD: readline is still used
13:20:40 <sebell> And I've built it against readline5 also
13:21:50 <exDM69> you might be able to disable readline with a compile time flag?
13:22:02 <exDM69> IMO readline is good
13:22:05 <TomMD> I was just curious if I would need to install the compat library.
13:23:04 <viklund> I'm going through the all_about_monads document, can someone explain what the pipe here means:
13:23:08 <viklund> class (Monad m) => MonadError e m | m -> e where
13:23:49 <sjanssen> viklund: it's called a functional dependency
13:24:26 <dmwit> It means that the type "m" must completely determine the type "e".
13:24:56 <viklund> ahh, ok, that makes it a bit clearer at least. Thanks
13:24:59 <dmwit> So you couldn't have both "instance MonadError Foo Bar" and "instance MonadError Baz Bar".
13:25:32 <viklund> aha
13:25:43 <omnId> maybe one of the instances of MonadError could help:  instance MonadError String (Either String) where ...
13:25:58 <omnId> (not quite it, I think instead of String it's Error a => a
13:26:43 <omnId> given that instance, you couldn't have an instance MonadError AnyOtherType (Either String)
13:27:29 <fox86> how big can i make an Integer or an Int? or a Double? can i check from ghci?
13:27:41 <omnId> This helps inference.  If the inferencer can infer the Either String part, it knows there's only one other type that can fit into the 'e' variable.
13:27:44 <roconnor> > maxBound :: Int
13:27:46 <lambdabot>  2147483647
13:27:50 <roconnor> > maxBound :: Double
13:27:51 <omnId> fox86: Integers are unbounded
13:27:51 <lambdabot>   add an instance declaration for (Bounded Double)
13:27:51 <lambdabot>     In the expression: max...
13:27:56 <roconnor> :(
13:28:04 <viklund> hmm, I think I might understand a bit more now, for a while at least ;)
13:28:09 <oerjan> > product [1..10000]
13:28:11 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
13:28:16 <viklund> thanks again
13:28:54 <omnId> thus it's read that "'m' (uniquely) determines 'e'"
13:28:55 <fox86> roconnor: thank you
13:28:58 <dmwit> > 10e30
13:29:00 <lambdabot>  1.0e31
13:29:03 <dmwit> > 10e300
13:29:06 <lambdabot>  1.0e301
13:29:13 <dmwit> > 10e3000
13:29:16 <lambdabot>  ghc: failed with error code 9
13:29:24 <newsham> (last $ show $ product [1..2342349325324]) == '0'
13:29:38 <dmwit> True
13:29:57 <Cale> dmwit: Very large floating point constants use lots of memory to evaluate at compile time, due to their meaning.
13:30:20 <Cale> they're fromRational (something derived from what you typed)
13:30:26 <dmwit> Cale: Please tell me that doesn't become (fromInteger 1000....).
13:30:29 <dmwit> ouch
13:30:41 <Cale> This is because they're polymorphic
13:30:59 <Cale> (at least initially)
13:31:14 <byorgey> > 10 ** 3000
13:31:16 <dmwit> At first blow, I would consider that a wart.
13:31:16 <lambdabot>  Infinity
13:31:22 <dmwit> I understand the reasoning, though.
13:31:45 <Cale> At least you'll never actually want a Double constant that large, because it's Infinity anyway
13:32:05 <dmwit> Yeah, I was trying to find maxBound :: Double.
13:32:14 <Cale> > maxBound :: Double
13:32:15 <lambdabot>   add an instance declaration for (Bounded Double)
13:32:15 <lambdabot>     In the expression: max...
13:32:18 <Cale> hehe :)
13:32:33 <roconnor> I guess the problem with a bounded Double would be that infinity is larger
13:32:38 <oerjan> > floor (1/0)
13:32:40 <dmwit> yeah
13:32:40 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
13:32:53 <dmwit> oerjan++
13:33:00 <Cale> ahaha
13:33:10 <dmwit> > fromInteger (floor (1/0)) :: Double
13:33:11 <lambdabot>  Infinity
13:33:38 <Cale> > log (fromIntegral (floor (1/0) `div` 2))
13:33:40 <lambdabot>  709.0895657128241
13:33:53 <dmwit> > length . show . floor $ (1/0)
13:33:54 <Cale> > log (fromIntegral (floor (1/0) `div` 2)) / log 10
13:33:55 <lambdabot>  309
13:33:56 <lambdabot>  307.95368556425274
13:34:18 <Cale> > 10**307
13:34:19 <lambdabot>  1.0e307
13:34:20 <dmwit> > 1e309
13:34:21 <Cale> > 10**308
13:34:23 <lambdabot>  1.0e308
13:34:23 <lambdabot>  Infinity
13:34:27 <sorear> IF we could assume instances obey the laws, we could turn 1.0e100000 into (fromRational (1%1) * (fromRational (10%1) ^^ 100000))
13:34:45 <oerjan> > (2**1023, 2**1024)
13:34:47 <lambdabot>  (8.98846567431158e307,Infinity)
13:35:04 <dmwit> aha
13:35:09 <dmwit> 10 bits for the exponent, then?
13:35:32 <dmwit> I guess there's probably a spec somewhere I should just go read.
13:36:10 <viklund> is this "type ParseMonad = Either ParseError" the same thing as "type ParseMonad a = Either ParseError a"?
13:36:23 <omnId> viklund: yes
13:36:36 <viklund> omnId: thx, it's getting ever clearer...
13:36:36 <sjanssen> though the former requires an extension
13:36:45 <oerjan> > floatRange 1.0
13:36:47 <lambdabot>  (-1021,1024)
13:37:30 <dmwit> > floatRange undefined
13:37:31 <lambdabot>  (-1021,1024)
13:38:39 <dmwit> Oh, it needs "undefined" to tell what the type is?
13:38:43 <dmwit> sneaky
13:38:50 <viklund> and then when you use "ParseMonad Integer" it gets bound, right
13:39:00 <sjanssen> dmwit: it just needs any inhabitant of that type
13:39:02 <oerjan> viklund: actually not quite because only the first allows you to pass ParseMonad to a monad transformer, i think (because type synonyms must be fully applied)
13:39:06 <viklund> so it's not really "ParseMonad a", it's more like a curried type?
13:39:09 <dmwit> sjanssen: Sorry, yeah, that's what I meant.
13:39:34 <omnId> viklund: yep, simple beta subtitution (of types!)
13:39:40 <viklund> cool!
13:42:29 <Cale> Yeah, it's nice to be able to put it that way, because ParseMonad *is* the actual monad.
13:46:30 <viklund> I find it hard to understand single lines of code in haskell, most programming languages I've come across so far it's generally pretty easy to grok the meaning of stuff
13:46:58 <viklund> but on the other hand I feel extremely happy every time I understood something in haskell
13:47:08 <viklund> that has never happened before either...
13:47:46 <viklund> I've had some gentle introductions to lisp and prolog but nothing like in haskell
13:48:05 <viklund> it's better than drugs!
13:48:13 <dons> :)
13:48:16 <byorgey> yes, Haskell tends to have that effect =)
13:48:21 <byorgey> glad you're enjoying it!
13:48:36 <dons> there's no superficial clutter
13:48:39 <ricky_clarkson> Point-free seems to go in slowly.
13:48:39 <viklund> a few days ago I entertained my self with ghci writing stuff like:
13:48:50 <dons> so you get at the core of programming immediately, rather than wasting time reading for loops
13:49:10 <viklund> > [3,2] >>= \x -> [x,x+2]
13:49:21 <lambdabot>  [3,5,2,4]
13:49:29 <dons> right, all depends on what  >>=  means :)
13:49:41 <byorgey> hehe, yes, the list monad is quite entertaining
13:49:41 <ricky_clarkson> @pl \x -> [x,x+2]
13:49:41 <lambdabot> ap (:) (return . (2 +))
13:49:44 <dons> concatMap (\x -> [x,x+2]) [3,2]
13:49:49 <dons> > concatMap (\x -> [x,x+2]) [3,2]
13:49:50 <lambdabot>  [3,5,2,4]
13:50:02 <Japsu> http://hpaste.org/3467 <-- NFA using list monad
13:50:11 <dons> > \x -> [x,x+2] `concatMap` [3,2]
13:50:12 <lambdabot>  Couldn't match expected type `a -> [b]'
13:50:14 <Saizan_> > [id,(+2)] `ap` [3,2]
13:50:16 <lambdabot>  [3,2,5,4]
13:50:19 <dons> heh
13:50:29 <Saizan_> modulo order :)
13:50:29 <ricky_clarkson> nice
13:51:08 <viklund> fascinating...
13:52:02 <oerjan> > [3,2] >>= sequence [id,(+2)]
13:52:03 <lambdabot>  [3,5,2,4]
13:52:21 <oerjan> *cackle*
13:52:41 <omnId>  no fair using ((->) r)!
13:53:07 <oerjan> but using just one monad is so boring ;)
13:53:12 <wli> Arrow stuff on (->) is useful, too.
13:53:49 <oerjan> > liftM2 (+) [3,2] [0,2]
13:53:50 <lambdabot>  [3,5,2,4]
13:56:10 <byorgey> > map (id &&& (+2)) [3,2]
13:56:12 <lambdabot>  [(3,5),(2,4)]
13:58:01 <byorgey> > map (id &&& (+2)) [3,2] >>= liftM2 (:) fst (return . snd)  -- how's this for gratuitous?
13:58:03 <lambdabot>  [3,5,2,4]
13:58:11 <Japsu> urgh
13:58:33 <omnId> liftM2 (:) fst (return . snd) (x,y) = [x,y]
13:58:48 <dmwit> ?pl \xs -> map (id &&& (+2)) xs >>= liftM2 (:) fst (return . snd)
13:58:49 <lambdabot> (liftM2 (:) fst (return . snd) =<<) . map (id &&& (2 +))
13:58:55 * omnId prefers (\(x,y)->[x,y]) -- :P
13:59:09 <byorgey> well, so do I of course, I was just being silly =)
13:59:32 <dmwit> > (liftM2 (:) fst (return . snd) =<<) . map (id &&& (2+)) $ [3, 2]
13:59:33 <lambdabot>  [3,5,2,4]
14:00:42 * wli prefers [x + y | x <- [3, 2], y <- [0, 2]]
14:01:42 <omnId> > do x <- [3, 2]; y <- [0, 2]; return (x + y)
14:01:44 <lambdabot>  [3,5,2,4]
14:02:55 <Saizan_> ?type let foo m x = m x >> return x
14:02:56 <lambdabot> <command line>:
14:02:56 <lambdabot>     Could not find module `L':
14:02:56 <lambdabot>       Use -v to see a list of the files searched for.
14:02:59 <Saizan_> ?type let foo m x = m x >> return x in foo
14:03:01 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (b -> m a) -> b -> m b
14:03:52 <omnId> s/m/k/g to fit convention
14:04:31 <Saizan_> k?
14:04:42 <omnId> (a -> m b) is a Kleisli
14:04:45 * viklund wonders if anyone is sane
14:04:58 <byorgey> oh, THAT'S why it's k!!
14:05:03 <byorgey> viklund: define sane.
14:05:05 <wli> viklund: [x + y | x <- [3, 2], y <- [0, 2]] is sane.
14:05:20 <Capso> Set conditionals?
14:05:25 <Capso> Like... real Math?
14:05:34 <Saizan_> omnId: ah, k makes me think of a continuation :)
14:05:34 <byorgey> Capso: yup =)
14:05:36 <jleedev> > [y x | x <- [3,2], y <- [id, (+2)]]
14:05:38 <lambdabot>  [3,5,2,4]
14:05:46 <Capso> byorgey: I might love this language. :)
14:05:46 <omnId> > runKleisli $ Kleisli (\x -> [x, x+2]) >>> Kleisli (\y -> [y, y*3]) $ 1
14:05:47 <lambdabot>  Couldn't match expected type `a -> c'
14:06:06 <omnId> > runKleisli (Kleisli (\x -> [x, x+2]) >>> Kleisli (\y -> [y, y*3])) 1
14:06:08 <lambdabot>  [1,3,3,9]
14:06:23 <byorgey> > [ (a,b,c) | a <- [1..100], b <- [a..100], c <- [b..100], a^2 + b^2 == c^2 ]
14:06:25 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(9,40,41),(10,24,2...
14:06:29 * omnId was channeling Cale for a second there
14:06:31 <byorgey> Capso: ^^^ =)
14:06:43 <viklund> heh
14:07:08 <omnId> @src Kleisli (>>>)
14:07:08 <lambdabot> Plugin `source' failed with: getRandItem: empty list
14:07:14 <omnId> :(
14:07:21 <byorgey> @src Arrow Kleisli
14:07:21 <lambdabot> Plugin `source' failed with: getRandItem: empty list
14:07:27 <dmwit> ?src map
14:07:28 <lambdabot> map _ []     = []
14:07:28 <lambdabot> map f (x:xs) = f x : map f xs
14:07:42 <Capso> byorgey: Hehe, that's awesome.
14:07:42 <dmwit> Okay, so it only complains when it can't find the source.
14:07:43 <omnId> Kleisli f >>> Kleisli g = Kleisli (\x -> f x >>= g)
14:07:47 <exDM69> if I have a list of things, is there a simple way of making all possible combinations of those?
14:08:12 <omnId> exDM69: the powerset?
14:08:17 <Capso> > (foldl (.) id [\x -> x*k | k <- [1..n]]) 1
14:08:18 <lambdabot>   Not in scope: `n'
14:08:22 <twanvl> > filterM (const [True,False]) [1,2,3]
14:08:23 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
14:08:29 <omnId> or all the permutation?
14:08:34 <omnId> -s.
14:09:02 <exDM69> let's say I have [1,2,3] and I want [[1], [1,2], [1,3], [1,2,3], [2], [2, 3], [3]]
14:09:19 <ddarius> exDM69: What about [] ?
14:09:22 <byorgey> exDM69: twanvl illustrated that above.
14:10:03 <exDM69> ddarius: [] doesn't matter, I don't want it but I can handle it
14:10:11 <byorgey> easy enough to remove with \\ [].
14:10:11 <exDM69> byorgey: oh, I see
14:10:32 <exDM69> twanvl: can you explain how that works? (I'm a newbie)
14:10:49 <byorgey> exDM69: how much do you know about monads?
14:10:56 <byorgey> the list monad, in particular
14:10:59 <exDM69> byorgey: very little
14:11:11 <byorgey> exDM69: well, perhaps you should just accept it as magic for now =)
14:11:21 <exDM69> sigh
14:11:27 <byorgey> exDM69: but if you want, I wrote a blog post explaining that very code a while ago
14:11:30 <oerjan> > filterM (const [False,True]) [1,2,3]
14:11:30 <exDM69> what's filterM?
14:11:32 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
14:11:41 <exDM69> byorgey: I'd love to see it
14:11:48 <byorgey> @go filterM code from types
14:11:53 <lambdabot> http://byorgey.wordpress.com/2007/06/26/deducing-code-from-types-filterm/
14:11:53 <lambdabot> Title: Deducing code from types: filterM  blog :: Brent -> [String]
14:12:06 <Saizan_> > let pset [] = [[]]; pset (x:xs) = map (x:) (pset xs) ++ (pset xs) in pset [1,2,3]
14:12:07 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
14:12:16 <jleedev> http://community.livejournal.com/evan_tech/220036.html
14:12:17 <lambdabot> Title: evan_tech -- powerset
14:12:27 <omnId> @source Control.Monad
14:12:28 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
14:12:31 <Saizan_> easier to understand, maybe? ^^^
14:13:00 <byorgey> exDM69: filterM is similar to filter, but monadic.
14:13:20 <exDM69> byorgey: I don't understand monads
14:13:23 <exDM69> but I'd like to
14:13:29 <Capso> byorgey: Are all sets ordered, or is there an inherent distinction, by Haskell, of Sets and PoSets?
14:13:43 <byorgey> exDM69: essentially, the 'const [True, False]' says to both include and not include each element
14:13:52 <omnId> filterM _ []     =  return []
14:13:53 <byorgey> exDM69: the list monad takes care of listing all the possibilities.
14:13:57 <omnId> filterM p (x:xs) =  do
14:13:57 <omnId>    flg <- p x
14:13:57 <omnId>    ys  <- filterM p xs
14:13:57 <omnId>    return (if flg then x:ys else ys)
14:14:00 <exDM69> byorgey: I somewhat understand the "real world example" in YAHT
14:14:20 <omnId> you can think of an inserted concatMap between each line of a list monad do block.
14:14:41 <byorgey> exDM69: don't worry, you'll get there.  try reading Cale's "monads as computation" tutorial, perhaps?
14:14:42 <dmwit> Wow, WASH sucks it hard at concurrent connections.
14:14:50 <ddarius> Capso: They aren't sets, they are lists.
14:14:53 <dmwit> 650 seconds to serve 100 simultaneous connections.
14:15:01 <byorgey> Capso: well, the [ foo | blah ] notation you saw are really list comprehensions.
14:15:05 <exDM69> byorgey: I was thinking about writing a card game
14:15:09 <dmwit> (of an essentially static page)
14:15:12 <Cale> Oh, someone asking about monads?
14:15:15 <byorgey> Capso: so they are ordered.
14:15:20 <exDM69> byorgey: would it be a good idea to write the deck module as a monad
14:15:24 <exDM69> Cale: yes, I was
14:15:29 <omnId> Cale: powerset via filterM
14:15:34 <Cale> ah
14:15:35 <Cale> okay
14:15:38 <byorgey> exDM69: I don't think that's necessary.
14:15:39 <Capso> byorgey: Ah, OK.
14:15:57 <Cale> exDM69: Do you understand it now or would you like my take on it?
14:15:59 <byorgey> Capso: there is Data.Set if you want actual sets (i.e. no duplicates).
14:16:25 <Capso> byorgey: All right. :)
14:16:32 <Cale> Unfortunately there's no Data.Poset
14:16:39 <Cale> That would be cool though.
14:16:59 <byorgey> Cale: hmm... what would such a module do?
14:17:02 <Capso> Cale: Is Data.Set just a restriction on the lists?
14:17:11 <Capso> byorgey: Partially Ordered Sets.
14:17:14 <Cale> Capso: No, it maintains binary balanced trees
14:17:34 <byorgey> Capso: right, I know what a poset is, just wondering what an equivalent Haskell formulation might look like.
14:17:43 <Capso> Oh, OK.
14:17:53 <Cale> Capso: and elements of Sets are required to have an ordering defined on them
14:18:05 <ddarius> class POrd a where comparing' :: a -> a -> Maybe Ordering
14:18:06 <Cale> (otherwise there's no way to maintain the data structure)
14:18:18 <byorgey> ddarius: makes sense.
14:18:32 <Cale> well, that would be a global partial ordering on the type
14:19:19 <Cale> Ideally, a Poset data structure would be like a Data.Set together with ordering information for the members
14:20:09 <Capso> Cale: In which topic in mathematics, do Sequences belong?
14:20:14 <byorgey> wouldn't you want something like (POrd a) => Data.Set a?
14:20:34 <byorgey> if it was just a Set with ordering information, it would be hard to enforce the fact that it defined a partial ordering.
14:20:40 <Cale> Capso: analysis?
14:20:52 <Cale> They're used all over the place.
14:21:21 <byorgey> also, if you mean integer sequences, perhaps number theory or combinatorics?
14:21:25 <Capso> Cale: Why not some part of Set Theory or the like?
14:21:44 <Capso> They are so similar...
14:21:49 <astrolabe> Does anyone here have the power to edit pages on http://hackage.haskell.org?
14:22:02 <Cale> Well, okay
14:22:13 <Cale> sequences are just functions from the natural numbers (to some set)
14:23:06 <Cale> They're not typically studied in and of themselves. Usually you're interested in the sequences of values in a particular set, and usually that set has some additional structure.
14:23:08 <calvins> Does anybody know what happened with the google soc project relating to bytestring-enabling parsec?
14:23:34 <pitecus> Is there some way of including a large literal  multiline string in Haskell source?
14:23:39 <astrolabe> calvins: was that the one that philippa and xerox were doing?
14:23:43 <calvins> yes
14:23:52 * byorgey `ap` "volleyball game"
14:24:00 <calvins> i'm having trouble finding information about it
14:24:28 <wli> viklund: Also try let perms [] = [[]] ; perms (x:xs) = let allInsert [] = [[x]] ; allInsert (y:ys) = (x:y:ys) : map (y:) (allInsert ys) in concatMap allInsert $ perms xs in perms [1,2,3] :: [[Integer]]
14:24:45 <astrolabe> @seen philippa
14:24:45 <lambdabot> philippa is in #scannedinavian, #haskell-soc, #haskell-overflow, #haskell-blah and #haskell. I don't know when philippa last spoke.
14:25:25 <Capso> Cale: Ah, I see.
14:25:31 <astrolabe> calvins: I got the impression it was going quite well at the time of anglo-haskell
14:25:52 <calvins> astrolabe: hmm, that's good news
14:26:16 <Cale> Capso: For example, topological structure, so that you can talk about whether the sequence converges, or metric/uniform structure, so you can talk about whether the sequence is Cauchy.
14:26:25 <calvins> i was expecting bad news (like darcs conflict bug) since I couldn't find much about it...
14:26:33 <ddarius> What?!  If we go to ordered linear logic then sequences will become just as relevant as sets.
14:26:58 <Cale> Except that nobody uses ordered linear logic except logicians.
14:27:36 <ddarius> My impression is that even logicians don't use ordered linear logic.  It's mostly computer scientists.
14:27:49 <Capso> I would sure like to know WTF it is. :)
14:28:02 <ddarius> Capso: Do you know what linear logic is?
14:28:05 <pitecus> So no multiline strings?
14:28:16 <Capso> Oh, wow...
14:28:19 <bos> pitecus: sort of
14:28:26 <Capso> Google for the term, and it's *all* programming and applications.
14:28:34 <Cale> pitecus: I'd usually use unlines, applied to a list
14:28:36 <bos> pitecus: start a string with a double quote, end a line with a backslash
14:28:43 <Cale> pitecus: Or you can use string gaps
14:28:58 <Cale> bos: You also have to start the next line with a backslash
14:29:01 <bos> pitecus: then start the next line with a backslash, and on and on until the last line ends with a double quote
14:29:05 <Cale> right
14:29:08 <bos> Cale: i can only type so fast :-)
14:29:10 <pitecus> Cale, string gaps?
14:29:17 <bos> pitecus: what i just said
14:29:20 <Cale> also, if you want the newlines, then you'll need to include them specifically
14:29:25 <pitecus> OK bos
14:29:25 <twanvl> > "string\          \gap"
14:29:25 <bos> right
14:29:26 <lambdabot>  "stringgap"
14:29:33 <Capso> ddarius: Ah, no.
14:30:00 <pitecus> So basically no
14:30:01 <ddarius> Capso: Do you know what the logic rules of contraction and weakening are?
14:32:37 <omnId> > "string gap \n\           \with newline"
14:32:39 <lambdabot>  "string gap \nwith newline"
14:32:45 <Capso> ddarius: Nope, not read up on these things yet. Any suggested material? :)
14:34:01 <Cale> pitecus: unlines works well
14:34:13 <Cale> unlines ["This is the first line.",
14:34:22 <Cale>          "This is the second line."]
14:34:57 <ddarius> Hmm. "Fac-simile of original preprint (Oct. 1990) never published, a pure waste of paper !"
14:35:03 <pitecus> Cale, its a whole file of data, not just a few lines, its a bit of a hassle to have to put it ina list of strings
14:35:28 <Cale> pitecus: You could put it in a separate file and load it.
14:35:57 <pitecus> That means being in IO
14:36:19 <Cale> Well, you are in IO in main. You can then pass the String down to whatever it is that needs it.
14:36:40 <ddarius> Capso: I haven't read these, but they're probably good.
14:36:43 <ddarius> http://iml.univ-mrs.fr/~girard/coursang/coursang.html
14:36:44 <lambdabot> Title: The Blind Spot
14:37:05 <ddarius> Beyond that, there are these http://iml.univ-mrs.fr/~girard/Articles.html of which I have read some.
14:37:06 <lambdabot> Title: Articles Jean-Yves Girard
14:37:27 <pitecus> Cale thats what I'm trying to avoid, having to change a lot of functions to take an additional argument
14:38:25 <Capso> ddarius: Cool, thanks.
14:38:44 <Cale> Well, you can do some awful hack like unsafePerformIO (readFile "..."), I suppose.
14:39:08 <Cale> http://iml.univ-mrs.fr/~girard/0.pdf.gz is awesome, btw
14:39:12 <omnId> pitecus: if you're only putting it in a file out of convenience, and you could see yourself putting it as a toplevel string variable in your code, then the unsafePerformIO could be justified.
14:39:45 <pitecus> omnId, I was thinking along those lines...
14:40:00 <Cale> What is this file?
14:40:14 <pitecus> Its some lexicon data
14:40:27 <dmwit> LexiconData.hs ;-)
14:40:37 <pitecus> yep
14:40:43 <Cale> Doesn't it make sense to have that be a parameter?
14:42:00 <pitecus> It would be OK but its just inconvenient to have to pass it down thru all the functions to the ones that are going to use it
14:42:13 <dmwit> suck it up
14:42:19 <dmwit> just my 2c
14:42:55 <Cale> It also makes it somewhat clearer that those functions actually do depend on it.
14:43:23 <Cale> If the lexicon data ever changes, you know which functions then could have their results change.
14:43:54 <pitecus> I guess
14:43:58 <omnId> pitecus: presumably you'd have one function that takes it as a parameter and itself calls smaller functions which do a part of the job.  In that case, the smaller functions could be in the where clause of the larger and inherit the data via scoping.
14:44:24 <Cale> That's also possible
14:44:35 <omnId> f data = foo bar baz where foo x y = ...; bar = ...; baz = ...
14:44:45 <omnId> er, data's a keyword, though :)
14:44:49 <Cale> hehe
14:44:53 <Cale> twice in one day
14:44:55 <omnId> s/data/dat/
14:45:05 <omnId> then dat is visible in the defs of foo bar and baz
14:46:42 * Cale flips through Locus Solum
14:46:46 <omnId> if these smaller functions aren't used anywhere, it makes sense to limit their scope, anyway
14:46:50 <Cale> It's so ridiculous :)
14:46:53 <omnId> elsewhere* rather
14:49:58 <Cale> http://iml.univ-mrs.fr/~girard/0.pdf.gz -- it's a tour-de-force, I'm telling you!
14:51:07 <pitecus> yep I knew about lexical scoping. The functions are defined in several modules tho, so its not really too doable
14:51:34 * wli mutters something about parametrized modules.
14:52:29 <Cale> You could use implicit parameters too.
14:52:32 <wli> (pitecus' case is one of the times I'd use them)
14:53:52 <pitecus> In that case I only need to change all the function signatures, which is bit less of a hassle but still
14:54:09 <Cale> hmm...
14:54:11 <omnId> let f x = x + ?y in (let ?y = 2 in f 3)
14:54:14 <omnId> > let f x = x + ?y in (let ?y = 2 in f 3)
14:54:15 <lambdabot>  Parse error at "?y" (column 15)
14:54:31 <mauke> :t let f x = x + ?y in (let ?y = 2 in f 3)
14:54:32 <lambdabot> forall t. (Num t) => t
14:54:51 <Cale> :t let f x = x + ?y in (let ?y = 2 in (f 3)^2)
14:54:52 <lambdabot> forall t. (Num t) => t
14:55:00 <Cale> see, you don't have to change them all
14:55:19 <Cale> (^) doesn't know about the implicit parameter of course, that's what makes it implicit
14:55:45 <Cale> You just have to change the type signatures of the functions which use the implicit parameter
14:56:13 <omnId> I dunno, implicit params make me feel icky. :)
14:56:27 <Cale> Yeah, it's basically the reader monad with Haskell syntax.
14:58:26 <pitecus> OK Cale that sounds a bit better
15:08:34 <wli> Interesting. ghci doesn't like let ?y :: Integer = 2 in ... (where it does like let x :: Integer = 2 in ...)
15:13:47 <augustss> omnId: implicit params are icky
15:14:37 <wli> This weekend I'm going to try to write an interpreter for a toy language and add modules to it.
15:15:46 <newsham> wli: have you tried playing with any OS concepts in haskell?
15:16:26 <wli> newsham: Not entirely sure what would qualify as that. I've done statistics collection and analysis in Haskell.
15:16:52 <wli> newsham: (Easily doable in e.g. perl or shell scripts also but I despise perl.)
15:17:29 <newsham> wli: you're the kernel hacker, right?
15:17:39 <wli> Yeah.
15:17:40 <newsham> or am i confusing you with someone else
15:18:02 <wli> I'm the guy in MAINTAINERS, kernel/profile.c, kernel/wait.c, kernel/pid.c, etc.
15:18:19 <newsham> there's several things I've seen recently using haskell for OS stuff..  like House, SeL4, l4verified, zipper fs, etc
15:18:33 <augustss> wli: for some unnamed OS :)
15:18:46 <wli> augustss: Linux
15:19:03 <augustss> wli: I suspected as much.
15:19:14 <augustss> kernel hacking is fun
15:19:18 <newsham> the zipperfs is kinda amusing because its a tiny multitasking filesystem in about 1kloc.  not using any thread runtime or anything liek that (although they do use sockets from the runtime)
15:19:18 <wli> cpumask_t, pgcl, highpmd, hugetlbfs, sparc32, etc.
15:20:03 <wli> (I'm clearly resting on my laurels here to some notable extent.)
15:20:49 <augustss> wli: I used to do a lot of OS hacking
15:21:13 <wli> augustss: Nice. Which kernel(s)?
15:21:20 <augustss> NetBSD
15:21:35 <augustss> and some generic driver stuff at work
15:21:57 <augustss> I wrote almost all the USB driver code that *BSD uses
15:21:59 <wli> augustss: Lots of architecture support there. Lots of fun.
15:22:25 <newsham> no plan9 kernel hackers here? ;-)
15:23:14 <wli> I used to think I'd want to hammer out my own kernel from scratch at some point. Then I burned out and got other things to do with my spare time.
15:24:54 <wli> I hammered out something but it wasn't functional [sic] enough to be interesting.
15:27:50 <wli> The concept was dull anyhow. Coremaplessness, range-based memory management at all levels, interrupt model of programming, then fight all that sucking in C and generally being a PITA to work with.
15:29:07 <wli> It wasn't even far enough along to have an idea of what the vfs should look like.
15:31:15 <wli> Haskell wouldn't have been a good FP lang for it. Something strict and non-GC'd (possibly sacrificing higher-order functions for such) might have flown. Most extant langs, no. Cyclone might've been appropriate.
15:31:17 <newsham> i like designs without fs in kernel
15:32:00 <wli> newsham: It all sounds clean until you try to handle memory exhaustion.
15:32:12 <monochrom> You are all wimps. Wirth envisioned eliminating much of the kernel at all. :)
15:32:54 <newsham> wire down the important parts of your critical filesystem?
15:33:19 <wli> newsham: That ends up being all of them.
15:33:27 <newsham> nah
15:33:52 <wli> newsham: Yes.
15:34:32 <wli> monochrom: My considerations were different from Wirth's.
15:34:52 <newsham> i've used several systems without fs in kernel and they handled memory exhaustion gracefully
15:35:32 <ddarius> Exokernels ho!
15:35:45 <SamB_XP> newsham: how did they load the non-kernel code?
15:35:47 <LoganCapaldo> Exo Exo Exo kernels ho!
15:35:58 <LoganCapaldo> Exokernels are on the hunt, Exokernes are loose
15:36:07 <sorear> wli: How gracefully does linux handle memory exhaustion?  How much can still get done if kmalloc doesn't work?
15:36:25 <newsham> samxp: not sure how you mean.  the fs server?  gets loaded during boot.
15:37:11 <sorear> SamB_XP: Well, you have to load the kernel without a FS driver somehow too.  It's not a great leap to load programs as well from the bootloader.
15:37:20 <newsham> for example, grub supports loading modules into memory at boot time.
15:37:47 <ddarius> Forth pages!
15:38:00 <newsham> l4 has some distinguished process that gets initialized during boot
15:38:29 <SamB_XP> sorear: who the heck loads kernels without filesystem drivers anymore?
15:39:00 <wli> sorear: It's not that things can get done. It's that OS continues to respond in some fashion.
15:39:18 <sorear> SamB_XP: the people who accidentally draw a distinction between bootstrap filesystem drivers and real ones  :)
15:39:26 <SamB_XP> newsham: however, you have a point
15:39:43 <ptolomy> Now that all my recreational coding is in Haskell and in languages that support the equivalent of 'Show' natively, I have a bit of a hard time using languages where I have to hand-code pretty printing of my data types.
15:40:00 <SamB_XP> ptolomy: you mean like Haskell?
15:40:02 <wli> The concept was a mishmash of a number of of ideas going around from various research kernels.
15:40:07 <newsham> ptolomy: you could always write a preprocessor to do that for you
15:40:14 <SamB_XP> Show is kinda ugly
15:40:25 <user317> is there anything in parsec that scans a string and returns a list of (stuff,string) pairs for the stuff and the string that caused teh match?
15:40:56 <SamB_XP> user317: you are confused with the Dr Suess. parser monad
15:41:05 <ptolomy> Show isn't beautiful, but at least it means that if I'm constructing a list of tuples of 'Maybe' or what have you, I can just do 'print' and I'll see it.
15:42:37 <user317> is thre anything in parsec that will return the string that caused the match?
15:43:05 <user317> i guess, that would be the intire input string
15:43:06 <LoganCapaldo> WriterT Parsec?
15:43:11 <newsham> you could write such a thing.
15:43:31 <newsham> each individual parser returns the parsed data and the remaining string
15:43:52 <newsham> you could write a wrapper which take orig-remaining and tacks that into the return result
15:43:56 <user317> yea, i was hoping someone else did the work for me already
15:43:59 <Saizan_> newsham: it would be useful to be able to write a general combinator for it
15:44:16 * LoganCapaldo wonders if such a thing woud be easier with an arrow based parser
15:46:14 <newsham> i would think you could write a lifter to lift parsers into the WriterT Parsec monad
15:46:25 <newsham> pretty easily
15:46:44 <monochrom> @type Text.ParserCombinators.Parsec.string
15:46:46 <lambdabot> forall st. String -> Text.ParserCombinators.Parsec.Char.CharParser st String
15:46:59 <monochrom> That one returns the matching string.
15:47:19 <monochrom> For example, (string "xxx") returns "xxx".
15:47:35 <newsham> right, but he wants to parse arbitrary data out and get a copy of the strings as well as the data
15:47:45 <Saizan_> monochrom: it's different, we wand foo p = (string parsed by p, p result)
15:48:56 <newsham> ParserT ? :)
15:49:40 <Saizan_> i don't see how using the transformer help finding how much input p has consumed
15:50:35 <newsham> hrmm.
15:51:48 <newsham> if you imported parsec's Parse (qualified) and defined your own Parse in terms of it, but with a Writer in it, and reproduced all of the primitives using a lift function
15:52:05 <newsham> the rest of your parser would work fine with it, and you could keep track of all of the parsed input for each parser
15:59:28 <newsham> lift (P.Parser p) = Parser p2  where p2 inp = let (r,resid) = parse p inp in (r,resid,take (length inp - length resid) inp))
16:02:16 <newsham> btw, does the parsec library keep track of parsing position (line number, column) for error reporting?
16:02:34 <newsham> that might be useful for extracting the info you need
16:02:42 <user317> yea, it does
16:03:01 <user317> i think i could write a parser that does what i want
16:03:13 <user317> in parsec, that just made my head spin
16:07:07 <Philippa> the easiest thing to do re consumption is just to compare the positions before and after parsing something
16:07:14 <Philippa> there's a combinator lets you do that
16:07:16 <user317> yea, thats what i am doing
16:10:16 <Philippa> unfortunately the standard position type only works in line/column, I guess if xerox and I had time we should've generalised on the position type as well
16:11:04 <SamB_XP> at least included the offset as well
16:27:06 <user317> there is no character position?
16:28:33 <sioraiocht> leopard broke GNUreadline ;)
16:28:38 <sioraiocht> :( even
16:29:44 <dons> you should get some linuxes ;)
16:29:48 <sioraiocht> GROSS
16:29:52 <sioraiocht> I mean, uhh, no thanks
16:31:06 <dons> eye candy freaks
16:31:19 <sioraiocht> i can't live without antialiased fonts anymore
16:31:22 <allbery_b> beta testers :>
16:31:28 <sioraiocht> hahah
16:31:35 <sioraiocht> i686-apple-darwin9-gcc-4.0.1: -compatibility_version only allowed with -dynamiclib
16:31:36 <Zao> sioraiocht: s/antialiased/blurred to kingdom come/
16:31:37 <sioraiocht> bummer
16:31:44 * allbery_b usually waits for the first bugfix release.  with good reason
16:31:44 <sioraiocht> Zao: I disagree =p
16:31:50 <dons> I guess you know X has anti-aliased fonts.
16:31:59 <mauke> yeah, I had to disable them
16:32:00 <dons> my vera sans is blurred all up nicely :)
16:32:10 <sioraiocht> X and I never get along
16:32:10 <sioraiocht> ever
16:32:14 <sioraiocht> I've tried
16:32:15 <Excedrin> I run linux on my macbook pro, it's OK, but I liked my thinkpad better
16:32:15 <dons> pity the window manager sucks on the mac so much ;)
16:32:17 * Zao pets Terminus 9
16:32:31 <dons> gotta install X just to get productive
16:32:47 * sioraiocht puts on his fanboy ear muffs.
16:33:06 <EvilTerran> who needs being able to maximise windows, anyway?
16:33:11 <sioraiocht> lol
16:34:26 <user317> what are windows?
16:34:29 <sioraiocht> and is it just me, or is the task of correctly compiling libgmp somewhat daunting?
16:34:47 <sioraiocht> ./configure is telling me I have a pentium3
16:34:50 <sioraiocht> do I listen to it?
16:34:52 <EvilTerran> is that the arbitrary-precision numbers thingy?
16:35:06 <sioraiocht> yes, the WORST arbitrary precision numbers thingy ever
16:35:08 <EvilTerran> if so, yes it's daunting. if not, probably yes anyway. ;)
16:35:09 <sioraiocht> but it's the only one =/
16:35:46 <sioraiocht> I'm trying to get the GIMPS people to code their stuff properly
16:35:55 <sioraiocht> they have some really fast bignum FFT code
16:36:03 <sioraiocht> but they can't be bothered to clean it up
16:36:13 <sioraiocht> it's riddle with gotos and 10,000 line functions
16:37:23 <Spark> is it asm? :)
16:37:27 <sioraiocht> no
16:37:29 <sioraiocht> it's C
16:37:38 <Spark> "damnit, i knew there were a lot of gotos"
16:37:52 <mauke> well, better than 10,000 functions on a single line
16:38:07 <sioraiocht> mauke: you laugh, but I had to work on this code all summer
16:38:25 <dons> mauke: or 1 function 10,000 chars long, on a single line :) list comprehensions ho!
16:38:30 <sioraiocht> this guy was like, "I wonder why I always find all the compiler and optimisation limits with my code"
16:38:37 <mauke> haha
16:39:02 <sioraiocht> i sent him http://xkcd.com/292/ in response
16:39:03 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
16:39:03 <Spark> program analyses work best on inlined code and are very happy with gotos
16:39:27 <mauke> "that's nothing, I made gcc crash by declaring a pointer to pointer to ... pointer to int, a few million levels deep"
16:39:41 <LoganCapaldo> did you really?
16:39:54 <mauke> yes :(
16:40:00 <Spark> you can set up a tree of macros to do that
16:40:03 <mauke> it's a stack overflow in the rec-descent parser
16:40:03 <Botje> you sad sad man.
16:40:12 <mauke> Spark: that doesn't crash the parser
16:40:18 <mauke> er, wait. it does.
16:40:30 <Spark> #define A **   #define B A A    #define C B B    #define D C C
16:40:30 <Spark> etc
16:40:45 <Spark> i'm sure something will break :)
16:40:57 <mauke> Botje: someone in #c wanted to know the limits of pointer nesting so I had to test it
16:41:06 <Spark> but gcc docs say that various things are limitted only be available memory
16:41:10 <LoganCapaldo> why a millionish levels of indirection?
16:41:12 <sioraiocht> mauke: and...?
16:41:18 <LoganCapaldo> oh
16:41:20 <mauke> it segfaulted
16:41:25 <LoganCapaldo> you alreayd answered that question
16:41:30 <Spark> mauke: due to lack of memory?
16:41:42 <mauke> <mauke> it's a stack overflow in the rec-descent parser
16:41:53 <Spark> ah right of course
16:42:53 <Mr_Awesome> but really, what other kind of parser is there?
16:43:11 <wli> Shift/reduce.
16:43:31 <wli> Chart parsers.
16:43:42 <mauke> the old parser was machine generated, I think
16:43:44 <mauke> yacc or something
16:43:48 <Mr_Awesome> hmm. touch
16:44:08 <mrd> LR grammars aren't recursive descent
16:44:34 * wli wishes for GLR parser combinators.
16:47:27 * Mr_Awesome wishes he understood parsing theory more
16:48:38 <EvilTerran> that's what the internet's for!
16:49:16 <LoganCapaldo> the internet is for parsers
16:50:32 <Philippa> for that, you should write the filk
16:50:50 <Philippa> except you'll have hell making it scan
16:51:16 <wli> Filk?
16:51:18 <allbery_b> 'the internet's for parsers' - works for me
16:51:26 <allbery_b> not quite a s filky though
16:51:34 <allbery_b> might work I suppose
16:51:56 <omnId> @jargon filk
16:51:57 <allbery_b> @all-dicts filk
16:51:57 <lambdabot> *** "filk" jargon "Jargon File (4.3.1, 29 Jun 2001)"
16:51:57 <lambdabot> filk /filk/ n.,v. [from SF fandom, where a typo for `folk' was adopted
16:51:58 <lambdabot>    as a new word] Originally, a popular or folk song with lyrics revised or
16:52:00 <lambdabot>    completely new lyrics and/or music, intended for humorous effect when
16:52:02 <lambdabot>    read, and/or to be sung late at night at SF conventions. More recently
16:52:04 <lambdabot> [8 @more lines]
16:52:06 <lambdabot> *** "filk" jargon "Jargon File (4.3.1, 29 Jun 2001)"
16:52:08 <lambdabot> filk /filk/ n.,v. [from SF fandom, where a typo for `folk' was adopted
16:52:10 <lambdabot>    as a new word] Originally, a popular or folk song with lyrics revised or
16:52:12 <lambdabot>    completely new lyrics and/or music, intended for humorous effect when
16:52:14 <lambdabot> Plugin `dict' failed with: thread killed
16:52:21 <EvilTerran> \(O.o)/
16:52:36 <allbery_b> *bonk*
16:52:42 <LoganCapaldo> Thread ressurected
16:52:42 <allbery_b> @bot
16:52:43 <lambdabot> :)
16:52:51 <LoganCapaldo> Thread necromancy
16:53:09 <wli> Philippa: Burning question. How does one get up to speed on working with module systems on a practical level. e.g. for interpreters for toy languages, how/where does one get module systems added to the type system etc.?
16:54:18 <wli> Philippa: ISTR you did something with module systems at one point, which is why I ask.
16:59:49 <bobafett>  
17:00:13 <bobafett> q
17:00:47 <newsham> wli: why parser combinator?  why not just GLR parse engine from spec?
17:01:29 <wli> newsham: Because grammars are often meant to be generated on the fly from fixity decls and similar.
17:02:11 <newsham> you can use on-the-fly disambiguation rules in a GLR parser
17:03:14 <newsham> this sounds like a good project
17:04:01 <newsham> hmm.. except dealing with state in GLR parser is hard.
17:09:27 <wli> newsham: Yeah, building up a data structure to drive an on-the-fly GLR parsing engine would be very useful in a number of ways.
17:09:47 <wli> newsham: The use case I envisioned was fixity decls at a repl prompt.
17:11:01 <newsham> one possibility is to perform an ambiguous parse and then filter the resulting tree with your precedence rules.
17:11:25 <wli> You don't want to know the time/space behavior of that strategy.
17:12:02 <wli> It also behaves quite poorly when infix/prefix/postfix/mixfix operators aren't lexically distinct from other tokens.
17:12:33 <newsham> GLR parsers can efficiently share ambiguous parse nodes
17:12:53 <wli> There are limits to what even that can accomplish.
17:12:56 <newsham> its just a big DAG instead of a tree.
17:16:18 <LoganCapaldo> DAG! You're it!
17:16:45 <newsham> dont not cross the pointers
17:16:58 <Nico_Reed> what does bracket in IO do?
17:17:07 <wli> newsham: Try counting the number of parses of a string of juxtaposed tokens where every token may be an infix, prefix, postfix, or a part of a mixfix operator.
17:17:24 <LoganCapaldo> @type bracket
17:17:26 <lambdabot> Not in scope: `bracket'
17:17:27 <mauke> @src bracket
17:17:27 <lambdabot> bracket before after thing = block $ do
17:17:28 <lambdabot>     a <- before
17:17:28 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
17:17:28 <lambdabot>     after a
17:17:28 <lambdabot>     return r
17:17:43 <LoganCapaldo> ah
17:17:54 <LoganCapaldo> it's "finally"-esque
17:18:03 <wli> newsham: That's the sort of situation you end up in when the operators aren't lexically distinct and there are a substantial variety of them.
17:18:05 <mauke> acquire, process, release.
17:18:25 <Nico_Reed> i still do not really understand what it does.. and how its related to IO
17:18:35 <Nico_Reed> it looks like it catchs exceptions/
17:19:02 <mauke> only temporarily because it also rethrows them
17:19:04 <LoganCapaldo> it makes sure after gets run, whether or not an exception is caught
17:19:17 <Nico_Reed> ah nvm i found it
17:19:23 <Nico_Reed> oh and thanks logan
17:19:37 <omnId> @src block
17:19:37 <lambdabot> Plugin `source' failed with: getRandItem: empty list
17:20:43 <omnId> some sort of threadsafeness hof?
17:21:22 <omnId> @docs Control.Exception
17:21:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
17:25:55 <LoganCapaldo> heheh
17:26:07 <LoganCapaldo> lambdabot is almost case insensitive
17:26:13 <LoganCapaldo> @RUN 2 + 2
17:26:13 <lambdabot> Unknown command, try @list
17:26:18 <LoganCapaldo> @Run 2 + 2
17:26:20 <lambdabot>  4
17:26:21 <JFT> @list
17:26:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:26:25 <LoganCapaldo> @RUn
17:26:25 <lambdabot> Maybe you meant: run wn
17:26:33 <omnId> LoganCapaldo: probably the spellchecker
17:26:38 <LoganCapaldo> I know :)
17:26:44 <LoganCapaldo> @rUn 3 * 2
17:26:45 <lambdabot>  6
17:27:07 <wli> http://holomorphy.com/~wli/Simple.lhs might be good to add modules to.
17:28:52 <newsham> http://www.thenewsh.com/%7Enewsham/x/ambiguous.jpg
17:30:15 <newsham> daggy
17:30:23 <monochrom> hehe
17:30:39 <newsham> parses of "1 + 2 * 3 + 4"
17:31:00 <wli> newsham: Just imagine how much bigger that'd be if everything were potentially an operator and there were as many kinds of operators as I mentioned.
17:31:01 <newsham> Expr -> Expr PLUS Expr | Expr TIMES Expr | NUM ;
17:31:02 <LoganCapaldo> it's almost symmetrical
17:31:44 <mauke> yeah, make 1 3 a circumfix operator, and + and 2 prefix
17:31:45 <mauke> * is a value
17:32:10 <wli> Something like that, yeah.
17:32:58 <wli> I suppose multipass parsing where expressions are sufficiently bracketable and there's a phase where expressions are just lists of tokens to be dealt with later might work better.
17:34:10 <newsham> why is dotty's syntax different every time i download it?
17:34:12 <wli> If you can extract the operator precedence info during the first pass while expressions are in such an unresolved form then you're golden.
17:34:22 <user317> does anyone know how getPosition works in parsec, i seem to get incorrect values when i try to get the position before i match something
17:34:25 <LoganCapaldo> I'm silver
17:35:57 <Philippa> user317: what's wrong about it?
17:36:35 <allbery_b> user317: at a guess it's lazy and if you force it before you force a match the current location will bewhatever was last forced
17:37:28 <hpaste>  user317 pasted "scanParser" at http://hpaste.org/3487
17:39:09 <user317> so i am trying to a list of [(a, start, end)]
17:40:29 <user317> but the startpos that i get seems wrong, its not at the start of the point where parser pp matches
17:42:27 <Philippa> where is it instead?
17:42:52 <user317> first character for teh first match, but that match is on line 149...
17:43:05 <reffie> hm
17:43:41 <reffie> i have a simple recursive fibonacci function (f 1 = 1; f 2 = 1; f x = f (x - 1) + f (x - 2)" but it takes a long time if the argument is relatively large (for example 200)
17:43:50 <reffie> isn't GHC able to memoize it?!
17:44:01 <wli> You have to tell it to yourself.
17:44:10 <reffie> that's lame
17:44:12 <wli> There are also better ways to compute it.
17:44:21 <reffie> yea i know
17:44:25 <newsham> one mans memo is another mans garbage
17:44:36 <user317> hmm, i have a better idea on how to do this
17:44:47 <kpreid> reffie: what newsham said. just define "fibs"
17:47:04 <reffie> kpreid what do you mean?
17:47:23 <kpreid> define a list such that fib x = fibs !! x
17:47:35 <allbery_b> user317: sounds like laziness to me, yeh
17:47:37 <kpreid> this can be done very efficiently
17:47:44 <kpreid> and it will memoize
17:48:11 <wli> http://holomorphy.com/~wli/Fib.hs
17:49:58 <wli> See also http://hpaste.org/1945#a1
17:54:51 <wli> reffie: Might as well go for the hpaste.org version.
17:56:30 <reffie> 1thanks
17:56:35 <Philippa> user317: wait, what's the difference between 'the first match' and 'the point where pp matches'?
18:01:50 <bparkis> do any languages have a 'mixed' static and dynamic type system--with runtime type tags when type cannot be inferred, but no runtime type tags and compile-time type checking when type can be inferred?
18:02:22 <wli> Remind me how to write .hi-boot files again.
18:03:30 <mauke> did someone say perl6?
18:03:43 <bparkis> oh perl6 does that?
18:03:54 <mauke> perl6 does *everything*
18:04:36 <puusorsa> hooray!
18:04:52 <newsham> perl6 = sh+sed+awk+perl5+haskell+jvm+... ?
18:05:04 <newsham> require Language::Haskell;
18:05:14 <dons> bparkis: haskell has this too
18:05:20 <dons> ?docs Data.Dynamic
18:05:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
18:05:35 <puusorsa> require Language::Haskell; .. really?
18:06:15 <omnId> > typeOf (+2)
18:06:17 <lambdabot>  Integer -> Integer
18:06:57 <mauke> > typeOf typeOf
18:06:58 <lambdabot>  Add a type signature
18:07:01 <mauke> fail!
18:07:24 <newsham> > (x -> x+1) 3
18:07:24 <lambdabot>  Illegal character ''\187''
18:07:25 <lambdabot>  at "x" (column 3)
18:08:05 <omnId> @type [toDyn (+2), toDyn "blah", toDyn (map (/3))]
18:08:07 <lambdabot> [Dynamic]
18:09:06 <newsham> > let  = 5 in 
18:09:06 <lambdabot>  Illegal character ''\187''
18:09:06 <lambdabot>  at "" (column 6)
18:09:09 <mauke> > join (. fix) typeOf
18:09:11 <lambdabot>  TypeRep
18:09:43 <newsham> ?unpl join (. fix) typeOf
18:09:43 <lambdabot> ((\ a f -> a (fix f)) >>= \ b -> b) typeOf
18:10:10 <omnId> join (. fix) x = (. fix) x x = (x . fix) x
18:10:50 <Olathe> @src join
18:10:50 <lambdabot> join x =  x >>= id
18:10:56 <omnId> > let t = typeOf in t (fix t)
18:10:57 <lambdabot>  TypeRep
18:11:10 <omnId> x (fix x) = fix x by definition, right?
18:11:11 <Olathe> What's the point of join ?
18:11:16 <omnId> > fix typeOf
18:11:18 <lambdabot>  TypeRep
18:11:39 <omnId> Olathe: join in the reader monad: join f x = f x x
18:11:56 <newsham> > join (*) 5
18:11:57 <lambdabot>  25
18:12:07 <newsham> > join (+) 5
18:12:08 <lambdabot>  10
18:12:23 <omnId> join (. fix) = fix, iiuc
18:12:29 <Olathe> > ((+) >>= id) 5
18:12:30 <lambdabot>  10
18:12:33 <Olathe> O-o
18:12:44 <omnId> @src (->) (>>=)
18:12:45 <lambdabot> f >>= k = \ r -> k (f r) r
18:13:03 <omnId> > (\r -> id ((+) r) r) 5
18:13:04 <lambdabot>  10
18:13:13 <omnId> any mystery there?
18:13:34 <Olathe> Is (+) a monad or something ?
18:13:42 <omnId> ((->) e)
18:13:52 <omnId> types are monads
18:14:00 <newsham> function types
18:14:41 <omnId> (+) :: Num a => a -> a -> a
18:14:52 * wli goes about hammering out a tiny interpreter to add modules to.
18:14:57 <omnId> (+) :: Integer -> Integer -> Integer -- to keep it simple
18:15:25 <ddarius> Monads are type constructors and some other stuff.  Types aren't monads and not all type constructors are monads and even ones that "are" aren't by themselves.
18:15:37 <omnId> (+) :: (->) Integer ((->) Integer Integer) -- another way to write it.
18:16:25 <omnId> given type IntegerReader = (->) Integer, (+) :: IntegerReader (IntegerReader Integer)
18:16:34 <omnId> join (+) :: IntegerReader Integer
18:16:39 <omnId> @type join
18:16:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:17:01 <newsham> > (+3) >>= (*) $ 5
18:17:02 <lambdabot>  40
18:17:05 <Olathe> @src (->) return
18:17:06 <lambdabot> return = const
18:17:25 <omnId> i.e., return the result while ignoring the function input.
18:18:02 <Olathe> @src (Maybe) return
18:18:02 <lambdabot> Plugin `source' failed with: getRandItem: empty list
18:18:09 <Olathe> getRandItem ?
18:18:09 <omnId> > (do x <- (+3); y <- (*x); return (y-x)) 2
18:18:11 <lambdabot>  5
18:18:20 <Olathe> @src Maybe return
18:18:20 <lambdabot> return              = Just
18:18:43 <Olathe> @src Maybe >>=
18:18:43 <lambdabot> Plugin `source' failed with: getRandItem: empty list
18:18:48 <Olathe> @src Maybe (>>=)
18:18:49 <lambdabot> (Just x) >>= k      = k x
18:18:49 <lambdabot> Nothing  >>= _      = Nothing
18:18:58 <omnId> const :: a -> (b -> a), so, given an 'a', it promotes it to an ((->) b) action.
18:19:36 <newsham> maps-b-to actions
18:20:16 <omnId> ddarius: I still say the word 'type' includes 'higher-order type'.
18:20:29 <Olathe> (f >>= g) v is g (f v) v
18:20:36 <Olathe> What is that monad useful for ?
18:20:41 <newsham> pointless code?
18:20:55 <newsham> combining pure arrows?
18:21:07 <mauke> reading
18:21:17 <omnId> it's Reader, but without the newtype.
18:21:31 <Olathe> @src Reader return
18:21:31 <lambdabot> Plugin `source' failed with: getRandItem: empty list
18:21:44 <omnId> return x = Reader (const x)
18:21:53 <mauke> return = Reader . return
18:21:58 <Olathe> What's >>= ?
18:22:24 <omnId> m >>= k = Reader (\r -> runReader k (runReader m r) r)
18:22:32 <omnId> same, modulo newtypes
18:24:24 <omnId> @go dons reader monad interpreter
18:24:26 <lambdabot> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/11
18:24:26 <lambdabot> Title: Haskell hacking
18:24:59 <LoganCapaldo>  i <3 reader
18:25:26 <LoganCapaldo> it's like State but with less guilt :)
18:25:29 <newsham> can you explain why?  I dont think i've ever used reader
18:25:49 <newsham> i use state and I feel like a naughty imperative programmer
18:25:53 <newsham> (which is usually what I am)
18:26:48 <omnId> newsham: like State, your actions read from a shared state, but they don't return any updated versions of it, the state is the same throughout the actions.
18:27:08 <newsham> i'm aware
18:27:09 <omnId> @unmtl State s a
18:27:10 <lambdabot> s -> (a, s)
18:27:14 <omnId> @unmtl Reader s a
18:27:14 <lambdabot> s -> a
18:30:24 <omnId> newsham: I suppose if you already have a newtype'd monad stack and you discover that you need to parameterize on a previously-unknown input, you could put Reader or ReaderT into your stack.
18:36:20 <newsham> "How I started off with Haskell and wound up with Lisp "
18:37:17 <newsham> heh
18:37:20 <SamB> is that a new tutorial?
18:37:40 <newsham> just some silly blog of some guy who learned a little haskell, did the "schem in 48 hours" and learned about this crazy thing called lisp
18:37:43 <newsham> and started to learn that instead
18:38:34 <SamB> um
18:38:36 <SamB> okay
18:39:32 <newsham> I think that appropriately sums it up, samb.
18:39:46 <SamB> heh
18:40:29 <dons> yes, that is an accurate summary.
18:40:40 <dons> we should implement haskell 1.0 in 48 hours instead.. :)
18:40:47 <newsham> "Every useful Haskell program somehow relies on unsafePerformIO"
18:40:48 <newsham> heh
18:40:59 <dons> oh, i hate that quote. what was Eric on??
18:41:06 <dons> apparently he doesn't write much haskell these days :(
18:41:07 <SamB> not every one
18:41:09 <SamB> just lots of them
18:41:12 <newsham> high on MSFT stock, apparently.
18:41:19 <newsham> they got a 3% boost yesterday and 9% today
18:41:30 <dons> SamB: i think unsafePerformIO is pretty rare
18:41:40 <SamB> okay
18:41:42 <dons> and what's the argument? that we give up on purity?
18:41:53 <SamB> so say we also include unsafeInterleaveIO
18:41:58 <thetallguy> There's nothing wrong with unsafePerformIO anyway, if used properly
18:42:04 <newsham> *shrug* I'm reading a blog about a paper.. so I dont see the original text
18:42:06 <dons> well, that's no unsafe in the same way.
18:42:08 <dons> thetallguy: right.
18:42:17 <SamB> dons: true...
18:42:23 <thetallguy> It's just that it's probably often misused...
18:42:25 <newsham> "Visual Basic is the ultimate language to democratize programming against the Cloud"
18:42:33 <newsham> I havent even programmed near the cloud :(
18:42:45 <newsham> but I guess I'm not a democrat either
18:42:46 <SamB> at least unsafeInterleaveIO won't confuse the optimizer
18:42:49 <dons> that's why you don't want freedom from it!
18:43:16 <SamB> is that the same cloud we use in circuit diagrams sometimes?
18:43:39 <newsham> i'm not sure.
18:43:40 <reffie> man those fibonacci implementations are fucking gross
18:44:01 <newsham> i guess "the cloud" is some new fangled lingo for "web 2.0 applications"?
18:44:32 <newsham> i'm not sure why we need to bring democracy to it, but I hope it goes better than our project in iraq.
18:44:50 <LoganCapaldo> Liberate the cloud!
18:45:05 <SamB> internet democracy works better
18:45:16 <SamB> because you can always start your own country if you need to
18:45:25 <dons> newsham: gotta bring democracy everywhere dude. nothing else to do with our  time.
18:45:31 <SamB> without all the inconvenience of having to find unused land
18:45:41 <dons> lets democratise haskell!
18:45:50 <dons> no more dictatorship of the professoriate!
18:45:54 <SamB> then again, so does dictatorship
18:45:59 <dons> haskell for the masses!
18:46:04 <dons> haskell for the clouds!
18:46:07 <SamB> since you can, again, always start your own country
18:46:13 <monochrom> o noes, they'll add downcasting to haskell!
18:46:23 <dons> let anyone commit to ghc's type checker!
18:46:34 <newsham> are you now or have you ever been a member of the university faculty?
18:46:35 <dons> because who knows better than the masses what things should be well typed?
18:46:38 <SamB> dons: dude, that's called anarchy
18:46:47 <SamB> we don't want anarchy in the typechecker
18:46:58 <dons> popular vote, i say
18:47:10 <SamB> and anyway knowing what should be well typed is different from knowing how to get the typechecker to agree with you
18:47:14 <monochrom> o noes, time to move on to Coq
18:47:15 <dons> and anyone with sufficiently popular ideas can commit
18:47:16 <newsham> czecks dont type
18:47:29 <thetallguy> Shouldn't you say something like: lets make Haskell an element of the anamorphism from political systems with small numbers of leaders to systems with large numbers?
18:47:32 * dons will run on a platform for implicit IO monads!
18:47:32 <newsham> my coq book arives next week
18:47:55 * dons no child will be born into untypesafety!
18:47:59 <SamB> dons: I will personally cast this platform into the ocean
18:48:08 <SamB> that kinda sounds unsafe to me
18:48:20 * thetallguy will be left behind no matter what.
18:48:42 <SamB> no child shall be left behind in the transition to the next small thing
18:48:53 * dons will provide continuation monads to ensure no programmer is left behind!
18:49:09 <thetallguy> May take a while to type check.
18:49:16 <SamB> alternatively, we could avoid defining a data constructor Behind
18:49:38 <newsham> what is the relationship between Behind and _|_ ?
18:49:41 <dons> yes, it will be statically impossible to be Left Behind
18:49:54 <SamB> or, we could make Behind take an argument
18:50:07 <thetallguy> I'm right behind you with this whole argument.
18:50:13 <SamB> of an uninhabited type?
18:50:17 <newsham> lazy Behinds
18:50:44 <LoganCapaldo> but where did it come from?
18:51:12 * thetallguy smells dinner and leaves the political type jokes behind
18:51:26 <monochrom> is dons drunk?
18:52:18 <LoganCapaldo> this is at least the second time dons has been accused of being drunk in this channel
18:52:24 <omnId> drunk on Haskell!
18:52:30 <monochrom> no, not accusing. asking.
18:52:43 <newsham> ?vixen buy us some beer
18:52:44 <lambdabot> Plugin `vixen' failed with: getRandItem: empty list
18:52:53 <SamB> ?vixen beer
18:52:54 <lambdabot> Plugin `vixen' failed with: getRandItem: empty list
18:53:04 <SamB> ?vixen hi
18:53:05 <lambdabot> Plugin `vixen' failed with: getRandItem: empty list
18:53:10 <ddarius> Yay
18:53:12 <SamB> dons: what did you do
18:53:15 <SamB> ?vixen
18:53:15 <lambdabot> Plugin `vixen' failed with: getRandItem: empty list
18:53:32 <LoganCapaldo> Didn't you get the memo? Questions are accusations now
18:53:51 <monochrom> I didn't get memoize.
18:53:53 <omnId> LoganCapaldo: Are you sure?
18:53:55 <SamB> yeah, like just now I accused dons of doing something
18:53:59 <omnId> (You are sure!)
18:54:03 <SamB> in the form of a question
18:54:48 <newsham> ?quote unlearn
18:54:48 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
18:55:04 <thoughtpolice> dons: there any plans to upgrade lb to accomodate cabal 1.2.1 or bytestring 0.9? or will that wait until 6.8? (I've missed lambdabot in my ghci sessions since I upgraded :()
18:57:46 <newsham> these agda blogs look really cool
18:57:50 <newsham> i need to learn that
19:18:59 <dons> thoughtpolice: i'm in the process of doing so, yes.
19:19:37 <thoughtpolice> dons: good to hear. :)
19:23:00 <wli> dons: Which is this?
19:24:48 <newsham> Setup.lhs Could ont find module `Distribution.Simple.Program'
19:24:50 <newsham> hrmmm.
19:25:25 <newsham> i guess Happy1.16 is a better bet?
19:26:23 <newsham> yes, that did it
19:26:27 <ddarius> Haskell has such a paradoxical relationship with Microsoft.
19:26:46 <araujo> hello
19:27:21 <Philippa> I'm not sure I find it paradoxical. Complicated, yes
19:27:33 <SamB> unexpected, on the face of it
19:27:53 <allbery_b> enh
19:28:33 <allbery_b> only unexpected if you expect MSR to be fully and only driven by the business end's concerns
19:28:51 <SamB> I said "on the face of it"
19:29:13 <wli> Business concerns can be less direct than selling a product. Building up the patent war chest is very simple.
19:29:19 <Zao> The fact that being good at Haskell and being named Simon are related is scarier.
19:29:40 <SamB> I mean it's not typical for MS to fund open source language development that has nothing to do with .NET or Windows, is it?
19:29:45 <SamB> Zao: yeah
19:29:47 <SamB> i you're good
19:29:57 <SamB> we might force you to change your name
19:29:59 <newsham> unix came out of the labs of the evil phone company monopoly
19:30:01 <newsham> go figure
19:30:02 <SamB> that is indeed scary
19:30:02 <Philippa> SamB: "nothing to do with .NET"?
19:30:04 <Philippa> Hah
19:30:22 <Philippa> they're taking a /lot/ of inspiration for where to go with .NET from haskell
19:30:23 <SamB> well, okay, so maybe they use it to steal ideas from
19:30:36 <SamB> I guess that is kinda the point of research...
19:30:37 <newsham> embrace, extend, destroy
19:30:51 <SamB> they aren't doing too well on the destroy aspect
19:30:57 <newsham> f# to destroy ocaml?
19:31:01 <SamB> possibly because they are incompatible from the start
19:31:07 <SamB> oh, destroy ocaml sure
19:31:12 <SamB> ocaml users aren't very civil anyway
19:31:12 <Philippa> I dunno, they've got to the point where haskell's no longer avoiding success
19:31:31 <dfranke> I don't think F# is malevolent.
19:31:47 <newsham> well if they spin it right they can claim MS invented haskell (like it invented the interweb)
19:31:50 <newsham> way back when
19:31:52 <dfranke> Why would Micros~1 want to destroy OCaml?  It's not like it's a threat.
19:32:08 <dfranke> and I'd rather use F#.
19:32:17 <goalieca> why doesn't microsoft make a .net backend for haskell
19:32:17 <Philippa> no, but someone else building an ML-flavoured Java-successor is one
19:32:19 <SamB> dfranke: maybe that's why they want to destroy ocaml
19:32:21 <SamB> ;-P
19:32:33 <dfranke> It adds a couple minor kludges, but it's well-worth getting the CLR.
19:32:33 * allbery_b sighs
19:32:47 <Philippa> an ML with haskell-like syntax and a good type class/module unification could go a very long way
19:32:48 <SamB> 'cause they'd rather not use it either
19:33:00 <dfranke> It's not like IE's HTML where the incompatibilities are gratuitous.
19:33:15 <wli> Philippa: I'd be all for that.
19:33:19 <SamB> goalieca: they have one
19:33:22 <Philippa> that, and it has the decency to acknowledge that it's a different language
19:33:32 <SamB> simons apparantly decided it wasn't useful
19:33:35 <SamB> and didn't release it
19:34:06 <SamB> (I assume it had horrid performance)
19:35:02 <n00b> hey guys how do I create the and function in haskell without using the foldr
19:35:36 <dfranke> why don't you want to use foldr?
19:35:49 <goalieca> use foldl
19:35:55 <Philippa> dfranke: homework says not to?
19:35:57 <SamB> you could substitute (&&) in the body of the foldr ...
19:36:04 <n00b> yes
19:36:10 <dfranke> Philippa: that's what I'm figuring :-)
19:36:22 <newsham> philippa: yah, i often wished there was haskell-pure-lazy and haskell-occaml-style
19:36:28 <newsham> with the same syntax and similar libraries
19:36:33 <n00b> I know it suppose to be and :: [Bool] -> Bool
19:36:39 <goalieca> > product $ map (==3) [1..6]
19:36:46 <lambdabot>   add an instance declaration for (Num Bool)
19:36:59 <goalieca> bah.. well product $ map f set should do
19:37:01 <SamB> occaml as in ocamms razor?
19:37:02 <goalieca> for and
19:37:04 <Philippa> n00b: do you know how to use recursion?
19:37:09 <n00b> yes
19:37:28 <wli> newsham: I'm just crying out in desperation for more of a module system and less bizarre things I never use like implicit parameters.
19:37:30 <Philippa> okay. So define it inductively: what's your base case? What do you do with a cons?
19:38:04 <omnId> n00b: Base case: What does (and []) equal?
19:38:10 <ddarius> newsham: I believe what you want to say is that you often wish O'Caml and the ML family in general wasn't so gosh-darn ugly.
19:38:12 <n00b> my base would be and [] = True
19:38:22 <newsham> > let and [] = True; and (x:xs) = x && and xs in and [True,True,True]
19:38:27 <lambdabot>  True
19:38:31 <newsham> > let and [] = True; and (x:xs) = x && and xs in and [True,True,False]
19:38:33 <lambdabot>  False
19:39:02 <newsham> ddarius: I wouldnt say 'gosh darn ugly' I would say 'wish they were more haskell-beautiful'
19:39:02 <SamB> newsham: didn't you just do his homework for him?
19:39:10 <newsham> samb: I dunno, possibly
19:39:28 <newsham> sorry :(
19:39:31 <Olathe> > all [True, True, False]
19:39:32 <lambdabot>  Couldn't match expected type `a -> Bool'
19:39:35 <Olathe> :(
19:39:35 <n00b> nice
19:39:44 <ddarius> newsham: O'Caml and SML looking ugly is part of why I ended up learning Haskell.
19:39:47 <omnId> > all id [True, True, False]
19:39:47 <SamB> > all id [True, True, False]
19:39:50 <lambdabot>  False
19:39:51 <lambdabot>  False
19:39:58 <Olathe> Ahh.
19:40:04 <SamB> I guess probably omnId was first?
19:40:14 <goalieca> ddarius, but monad's make haskell ugly IMO
19:40:24 <goalieca> a cleaner imperative syntax would be nice
19:40:31 <dfranke> I'm lucky I got talked into learning Haskell.  Getting frustrated with ML left me with a vendetta against strong typing.
19:40:34 <newsham> ?src and
19:40:35 <lambdabot> and   =  foldr (&&) True
19:40:38 <newsham> ?src foldr
19:40:39 <lambdabot> foldr k z xs = go xs
19:40:39 <lambdabot>     where go []     = z
19:40:39 <lambdabot>           go (y:ys) = y `k` go ys
19:40:43 <Philippa> monads're one of the nicest things about haskell in many ways, though a prettier syntax would have value
19:41:00 <newsham> and = go xs where go [] = True; go (y:ys) = y &&` go ys
19:41:01 <goalieca> typing monad code doesn't feel "natural" to me
19:41:03 <wli> Overloading... algebra is a disaster in ML.
19:41:09 <newsham> lambdabot practically does your homework for you
19:41:11 <omnId> Philippa: I'd say typeclasses in general, not just Monad.
19:41:26 <Philippa> newsham: telling that to newbies isn't a good idea either
19:41:36 <ddarius> goalieca: Then don't.
19:41:48 <goalieca> i don't :-)
19:42:00 <SamB> goalieca: what syntax do you want?
19:42:00 <ddarius> goalieca: Good.=
19:42:04 <newsham> phila: 1) can still do monads even in ocaml-like language (why not), 2) teaching kids to use equational reasoning doesnt sound like a bad idea to me :)
19:42:19 <dfranke> I wish I had homework in Haskell :-(
19:42:31 <dfranke> I graduated from a Javaschool.
19:42:33 <goalieca> SamB, i'm not sure. i'm by no means a language expert. All i can say though is that currently it feels messy and overcomplicated
19:42:34 <newsham> dfranke: heh, I was thinking that when I got caught doing his homework.
19:42:40 <araujo> the 'do' syntax is a very clean imperative syntax .....
19:42:47 <Philippa> goalieca: if you think it's overcomplicated you probably haven't got it yet
19:42:53 <araujo> and consistent
19:42:55 <newsham> araujo: too much heavy lifting involved.
19:43:14 <newsham> where in other imperative languages everythin is lifted to your general super monad for you
19:43:19 <n00b> what about or
19:43:23 <n00b> :t or
19:43:24 <Philippa> a good assembler's a very clean, consistent imperative syntax...
19:43:24 <lambdabot> [Bool] -> Bool
19:43:27 <SamB> n00b: it's the identical code
19:43:32 <newsham> _n00b: you saw us do "and", "or" should be a piece of cake now
19:43:39 <ddarius> Philippa: Why does it need to be good?
19:43:40 <SamB> except with one or two obvious substitutions
19:43:42 <n00b> ok
19:43:49 <araujo> newsham, too much?
19:43:50 <wli> Am I the only one crying out for a more full-featured module system here?
19:43:53 <SamB> if you can't figure it out you need to like study or something ;-)
19:44:02 <n00b> or does the opposite
19:44:05 <n00b> right ???
19:44:13 <ddarius> wli: The problem is people want The Right module system.
19:44:18 <omnId> n00b: base case: or [] == ?
19:44:19 <araujo> hah
19:44:20 <SamB> n00b: go look it up in the dictionary?
19:44:23 <Philippa> ddarius: because otherwise I can pull some assembler with godawful syntax out of my arse :-) The basic "this then that then that" is still hopefully clean and consistent, sure
19:44:31 <newsham> araujo:    int(readline().strip) + 25 * int(argv[5])
19:44:35 <n00b> ok
19:44:45 <n00b> i just wrote thanks
19:44:45 <wli> ddarius: I've never heard a peep about that.
19:44:46 <newsham> in haskell:  liftM this, liftM that
19:44:46 <araujo> and everyone has an idea about the ideal module system
19:44:59 <SamB> wli: something better would sure be nice
19:45:03 <n00b> i got a question on encryption
19:45:08 <SamB> but I haven't got a clue what that might be
19:45:13 <ddarius> wli: It's been relatively quiet on that front for a while.  People are waiting.
19:45:22 <n00b> says i must use the integer 13 to encrypt
19:45:23 <Philippa> wli: there's been little list talk about it, partly because it's rather a lot like records
19:45:30 <newsham> (or alternately, l <- readline; a <- args; let res = (int l) + 25 * (int (a !! 5))
19:45:30 <SamB> n00b: read the spec!
19:45:35 <newsham> either way.. more work involved
19:45:37 <n00b> encrypt "What a fine day!"
19:45:42 <Philippa> only worse, because there're issues with first-classness if people want that
19:45:44 <SamB> n00b: read spec!
19:45:49 <n00b> "dun\129-n-sv{r-qn\134."
19:45:51 <wli> Philippa: How is it like records?
19:46:06 <ddarius> Records and modules are intimately related.
19:46:12 <araujo> newsham, i don't find that ugly really, i find it very concise and consistent
19:46:14 <SamB> they SHOULD be
19:46:15 <SamB> that is
19:46:15 <n00b> that's what it would be encrypted
19:46:31 <araujo> it makes the code very easy to read an follow
19:46:36 <araujo> and*
19:46:39 <wli> I wish I understood how records and modules were related. I don't have the foggiest idea what the connection might be.
19:46:40 <newsham> araujo: it can get a lot more complicated when you have monad stacked up, and such.
19:46:43 <ddarius> SamB: Yes, I guess I should be clear that I'm not talking about Haskell's but the general notions.
19:46:54 <newsham> I wouldnt say its really ugly, but its sometimes overly complicated
19:47:03 <araujo> newsham, things *always* can get more complicated
19:47:04 <Philippa> wli: think of a module (or a structure, if you're MLish) as a record of values
19:47:06 <n00b> i was thinking of using the ord and char function to convert it
19:47:10 <ddarius> wli: Have you ever looked at Cayenne for example?
19:47:20 <Philippa> (and types)
19:47:32 <ddarius> Philippa: I was waiting for that.
19:47:35 <wli> Yeah. I never figured out how its records plus modules things worked.
19:47:42 <SamB> wli: they are records
19:48:02 <Philippa> if you build a pure type system you can actually /have/ modules as a form of records, and it'll work and be consistent
19:48:02 <SamB> but they can be used as modules too
19:48:03 <wli> Don't modules have types where records don't?
19:48:06 <SamB> also tas typeclasses
19:48:13 <newsham> python modules are also very "record" (object)-like
19:48:14 <SamB> wli: cayenne is dependantly typed
19:48:22 <Philippa> wli: yeah, but that's just a trivial generalisation
19:48:22 <SamB> types, values, doesn't matter!
19:49:01 <Philippa> pretty much the one from algebraic datatypes to algebraic datatypes with existential parms
19:49:35 <Philippa> on the other hand, most of us want our module systems to either always terminate or have a significant subset that always terminates
19:49:37 <wli> Well, the way I understand modules is as namespace affairs.
19:49:48 <wli> And records as value affairs.
19:50:23 <Philippa> let <bigpileodecls> in <record>, then have an import construct
19:51:20 <Philippa> just occasionally you see people using an import-like construct with records, too - more common in languages with dynamic scope
19:51:49 <wli> Well, first-class modules and/or modules-as-records aside, I can't smoke out what the heck is going on with what modules do to the type system of a module-less language.
19:51:59 <ddarius> Indeed by having modules be records, namespace management is pushed back on the general mechanism for it, scoping.
19:52:12 <Philippa> wli: they don't, they just have their own type system with equivalent problems
19:52:31 <wli> The type systems interact, though.
19:52:32 <Philippa> plus in haskell's case there's the relationship between modules and type classes, which is going to make people really picky
19:52:47 <wli> That is, the type system of the module and term languages.
19:52:53 <ddarius> People want a beautiful and grand unification and they are waiting for it to pop out.
19:53:04 <Philippa> barely, you can parameterise a module system on the term language's type system to a significant extent
19:53:30 <Philippa> not least because the peril with not waiting is not getting that unification without a lot of pain once it arrives
19:54:14 <Philippa> re interactions: you only really need a subsumption relationship and a typechecker for the most part
19:54:29 <wli> The type systems for module systems also behave differently in a way that completely baffles me.
19:55:15 <tomodiz> i have data Shape = terms Circle Float | Triangle Float Float | Square Float
19:55:25 <wli> Translucent sums, general products, impredicativity, and other things I don't get at all.
19:55:35 <wli> e what that might be
19:55:35 <wli> <ddarius:#haskell> wli: It's been relatively quiet on that front for a while.
19:55:35 <wli> +People are waiting.
19:55:35 <wli> <n00b:#haskell> says i must use the integer 13 to encrypt
19:55:35 <wli> <Philippa:#haskell> wli: there's been little list talk about it, partly
19:55:36 <wli> +because it's rather a lot like records
19:55:38 <wli> <newsham:#haskell> (or alternately, l <- readline; a <- args; let res = (int
19:55:40 <wli> +l) + 25 * (int (a !! 5))
19:55:42 <wli>  07:46PM [ircII] wli (+ei) (Query: #haskell) #godflesh (+cnt)  ircII-EPIC4 -- T
19:55:44 <wli> >
19:55:46 <wli> Sorry.
19:56:05 <Saizan_> translucent sums?
19:56:07 <Philippa> translucency's a bit complicated, yeah. Impredicativity's an issue in ordinary type systems too
19:56:23 <Philippa> by "general products" you mean pi types?
19:56:30 <tomodiz> i have data Shape = terms Circle Float | Triangle Float Float | Square Float
19:56:31 <tomodiz> i want to make a function 'area' that can take either a circle triangle or square
19:56:36 <wli> Yeah, big Pi types.
19:56:48 <tomodiz> can somebody help me out with that
19:56:56 <Philippa> those're from dependent type systems
19:56:59 <tomodiz> area :: Shape -> Float
19:56:59 <tomodiz> area (Circle r) = pi * (r ^ 2 :: Float)
19:57:58 <Saizan_> tomodiz: you just need to write the other cases, area (Triangle b h) = ..; area (Square l)
19:58:10 <Philippa> 'lo ChilliX
19:58:24 <tomodiz> and then it will accept it?
19:58:28 <ChilliX> Hi Philippa
19:58:55 <Philippa> your data declaration shouldn't have the "terms" in it
19:59:25 <tomodiz> wat do u mean by terms
19:59:38 <omnId> <tomodiz> i have data Shape = *terms* Circle Float | Triangle Float Float | Square Float
20:00:07 <omnId> delete that
20:00:16 <tomodiz> the whole data thing?
20:00:24 <omnId> the word "terms"
20:00:30 <tomodiz> its not in there
20:00:47 <tomodiz> o i left that in ther by accident it was in a comment
20:01:00 <tomodiz> data Shape =
20:01:00 <tomodiz> 	Circle Float
20:01:00 <tomodiz> 	| Triangle Float Float
20:01:00 <tomodiz> 	| Square Float
20:01:35 <Philippa> okay. What's the error you get at the moment?
20:02:11 <tomodiz> No instance for (Num Shape)
20:02:11 <tomodiz>       arising from the literal `4' at <interactive>:1:5
20:02:11 <tomodiz>     Possible fix: add an instance declaration for (Num Shape)
20:02:59 <omnId> tomodiz: try: area (Circle 4) instead when you test it.
20:03:19 <omnId> 4 isn't a Shape.
20:03:53 <tomodiz> i think i got it
20:04:44 <tomodiz> thanks
20:05:41 <omnId> incidentally, the annotation (r ^ 2 :: Float) isn't necessary since you've already said Cirle's argument is a Float.
20:05:58 <tomodiz> yea i just put that in there  from another error message
20:06:03 <tomodiz> its gone now
20:06:23 <tomodiz> i had all the shapes as ints instead of floats
20:08:33 <tomodiz> if i were to enter a String like KMnO and i wanted to make it into a list ["K","Mn","O"] what would the best way of doing that be
20:12:15 <omnId> you could unfold, spanning isLower after each upper head.
20:12:43 <tomodiz> alright thanks
20:14:39 <omnId> > let f (c:cs) = Just (first (c:) (span isLower cs)); f [] = Nothing in unfoldr f "KMnO"
20:14:40 <lambdabot>  ["K","Mn","O"]
20:14:54 <omnId> (this isn't homework, is it?)
20:15:13 <omnId> ('spose I shoulda asked that before posting the answer)
20:15:14 <tomodiz> no i was just doing it on my own time
20:16:08 <tomodiz> i dont think theyd make u program in haskell for chemisty
20:16:28 <omnId> :)  You never know.
20:16:33 <tomodiz> yea
20:17:00 <omnId> maybe break isUpper would be a better choice
20:17:14 <omnId> > let f (c:cs) = Just (first (c:) (span isLower cs)); f [] = Nothing in unfoldr f "KMn*%xO"
20:17:16 <lambdabot>  ["K","Mn","*","%x","O"]
20:17:28 <omnId> > let f (c:cs) = Just (first (c:) (break isUpper cs)); f [] = Nothing in unfoldr f "KMn*%xO"
20:17:30 <lambdabot>  ["K","Mn*%x","O"]
20:20:00 <tomodiz> circumference is 2(pi)r and area of a circle is 2(pi)^2 correct?
20:20:13 <omnId> pi*r^2
20:20:30 <tomodiz> srry yea thats wat i meant
20:20:45 <omnId> you'd have to have r in there somewhere, 2pi^2 is a constant :P
20:21:42 <tomodiz> yea i just made a typo
20:21:55 <ddarius> That's a hell of a typo.
20:22:00 <tomodiz> i just wanted to make sure i didnt have them backwards
20:22:13 <tomodiz> i wasnt really thinking about was i was typing for the are
20:22:14 <tomodiz> a
20:22:49 <ddarius> It should be no problem to keep them straight.  Even a straight dimensional analysis should get you ballpark right off the bat.
20:24:20 <bparkis> hey let's say i'm looking for a grammar for a minimal Haskell-like language, with just simple data declarations and pattern matching
20:24:44 <bparkis> does such a thing already exist or do i just need to make one up myself?
20:25:01 <ddarius> Look at baskell perhaps?
20:25:58 <Philippa> I made one up years back - it's not too hard if you define the abstract syntax before the concrete
20:26:29 <Philippa> don't have the code around, sorry :-(
20:27:10 * ddarius wonders how much code he's lost that he might miss in some way or another.
20:33:39 <wli> Type qualifier handling seems tricky to me.
20:36:57 <wli> During type inference that is.
20:37:33 <wli> NFI where to start on MPTC.
20:38:05 <mrd> ML requires qualifiers to be in prenex form in order to ease inference
20:38:19 <mrd> in general, rank-n polymorphism is going to make inference impossible
20:38:24 <mrd> (full inference)
20:38:56 <wli> I didn't even want to handle that.
20:39:14 <ddarius> Haskell 98 has that restriction too and it's still not possible to type infer Haskell even ignoring type classes in all cases.
20:39:41 <wli> MPTC are the bare minimum to get monad transaformers going.
20:39:51 <mrd> well prenex polymorphism is simple H-M, then there's type classes
20:40:06 <ddarius> You don't need MPTC for monad transformers.
20:40:13 <mrd> MPTC isn't going to work as is, you need some way of disambiguating like fundeps or type fams
20:40:20 <mrd> and yea
20:40:29 <wli> ddarius: Eh?
20:41:08 <ddarius> While convenient, the classes like MonadState aren't needed.
20:42:07 <wli> How do you get StateT otherwise?
20:42:29 <ddarius> StateT is a newtype, it has nothing to do with classes.
20:43:54 <wli> The instanceson it make it meaningful.
20:45:26 <wli> I don't get what you mean by a monad transformer if not MonadState, StateT, et al.
20:45:27 <mrd> MPTC + type families is new and i don't know how well the reconstruction is understood.
20:45:53 <mrd> StateT isn't a class
20:45:55 <ddarius> StateT is the monad transformer, though I guess lift can be considered a part of it.
20:46:17 <wli> mrd: StateT is what the instances in the library are defined on.
20:53:16 <wli> Well, I don't understand how monad transformers are done if not with MPTC.
20:58:49 <Philippa> wli: you don't actually need MPTC for transformers per se
20:59:00 <Philippa> they only need to parameterise on the underlying monad
20:59:15 <Philippa> and that's totally parametric in most cases
20:59:37 <ddarius> and we delude ourselves for most of the remaining cases
20:59:43 <wli> You mean in terms of StateT s m a you hard-code s and a?
21:00:04 <wli> And hammer out a fresh instance for every variation?
21:00:26 <Philippa> a doesn't need hard-coding
21:00:29 <ddarius> You can't hardcode a and you wouldn't need to
21:00:40 <Philippa> and s is an additional parameter you've chosen to add
21:01:19 <Philippa> so you're just left with a type constructor of kind (*->*) -> * -> *
21:01:43 <Philippa> you can define a single-parm class for that
21:01:53 <ddarius> Personally I don't consider MonadState and co. part of the definition of the monad transformer.  Convenient, but not necessary.
21:01:59 <Philippa> exactly
21:02:08 <ddarius> lift is trickier but still straight forward to handle.
21:02:43 <wli> How do you recover the operations in the MonadState class?
21:02:49 <Philippa> I don't, not my problem
21:03:00 <wli> So you never use them?
21:03:08 <wli> So you never use monad transformers?
21:03:19 <Philippa> MPTC are the minimum for a /nice/ monad transformer library, that's not the same thing
21:03:49 <wli> Well, you can encode monad transformers in assembly language if sufficiently pressed...
21:04:04 <Philippa> but that's not what we're talking about
21:04:05 <ddarius> It's not all that bad without them, but you lose (without some other cleverness) a decent chunk of the flexibility of your code.
21:04:26 <Philippa> we're talking about the difference between having monad transformers at all and having the nice pretty shiny libraries we're used to
21:04:49 <wli> Yeah. I'm not seeing how they wouldn't suck from a software engineering POV sans MPTC.
21:04:49 <Philippa> (how do I get the MonadState ops? Well, I write the ops for StateT and leave it at that)
21:05:14 <Philippa> right. That's important, but a much weaker (and incidentally probably correct) statement
21:05:52 <ddarius> Haskell has spoiled you.
21:06:11 <wli> This is the whole of the impedance mismath.
21:09:57 <wli> Not sure if there's a useful version of MPTC where type inference isn't a research problem. Fundeps, type families, etc. are all pretty far out. So basically the useful incarnations of monad transformers fall into a nasty category.
21:11:22 <wli> "Nasty" in terms of "not so completely understood as to make toy interpreters truly toys."
21:43:10 * wli doesn't know offhand what the "general picture" wrt. type inference and MPTC's is. I'm guessing there are no useful things there that aren't research problems.
21:44:21 <newsham> reduceron talk neat
21:46:09 <wli> http://research.microsoft.com/~simonpj/papers/fd-chr/esop04.ps
21:48:01 <wli> Sounds like FD's are actually solved problems.
21:52:04 <newsham> its kinda weird that these languages are really made up of two languages..  an undecidable programming language and a similar, but decidable, type language.
21:52:53 * sorear prefers decidable programming languages
21:53:05 <newsham> and they cant borrow from each other.. wonder if there's more you could do about that (and keep it decidable)
21:53:12 <dons> i can't decide if my program is going to terminate. i wish it would make up its mind
21:53:16 <newsham> sorear: are you a total functional programmer?
21:53:29 <newsham> i hope my server doesnt terminate
21:53:38 <newsham> i have decided that it might
21:54:05 <sorear> newsham: yup
21:54:25 <wli> So basically MPTC + fundeps is a solved enough problem for toy languages.
21:54:39 <newsham> sorear: so no interpreters for you?
21:55:06 <sorear> newsham: I have interpreters, they just aren't guaranteed to terminate.
21:55:34 <sorear> newsham: Writing nonterminating functions in total languages is as easy as doing IO in Haskell.
21:55:42 <sorear> All you need is the right monad.
21:55:46 <conal> dons: i'm using "model-based" testing now.  i like it a lot as a design tool as well.  much like a denotational semantics and then testing the implementation by consistency with the semantics.
21:56:24 <sorear> CoInductive NT (a : Set) : Set := NT_return a | NT_defer (NT a).
21:56:40 <sorear> defining the monadic structure is left as an excersize for the reader
21:57:14 <newsham> ?remember sorear Writing nonterminating functions in total languages is as easy as doing IO in Haskell.
21:57:15 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
21:57:37 <newsham> "doing IO in Haskell" is widely considered (outside of #haskell) as difficult ;-)
21:58:13 <sorear> Difficult, yes.  Impossible, far from it.
21:58:18 <newsham> *nod*
21:59:12 <newsham> i hope some day to understand why writng non-terminating functions is easy in total functional programming
22:01:47 <newsham> so there are a lot of interesting programming properties that are undecidable in general languages.  in total functional programming these are generally decidable, yes?  What is the state of the art, do people know algorithms for finding interesting program properties?
22:02:15 <newsham> can static analysis of total functional programs automatically decide useful properties?
22:02:26 <wli> I think it's focused mostly around avoiding pattern match failure exceptions.
22:02:49 <sorear> "properties", sure.  "useful" would require a mathematical model of the human mind
22:03:57 <newsham> ok, lets say a useful property is "does not launch the missile without confirmation from two terminals", and the program was not written a prior to make proof of this property obvious..
22:04:14 <newsham> this is kind of a vague question, I know..
22:05:27 <bparkis> well it is certainly possible to write a program and prove things about its behavior, and writing a functional program can make the proof easier
22:05:34 <newsham> commercial static analyzers for C and Java look for buffer overflows, use of tainted data in filesystem operations and program execution, use of unfiltered tainted data in HTML output, for example (but in unsound analysis)
22:05:51 <newsham> now lets say someone wanted to write a static analyzer for some total functional programs...
22:06:50 <newsham> bparkis: not talking just about pure/referentially transparent.. but even more, a "total" language
22:07:29 <wli> Avoid Turing completeness?
22:07:47 <bparkis> what do you mean by total, you mean the programs always terminate?
22:07:52 <newsham> wli: total functional programming avoids turing completeness, and the programs are decidable.
22:08:07 <newsham> some from a theoretical point of view, it should be possible to do sound analysis
22:08:15 <newsham> my question is from a practical point of view, how far along is the state of the art
22:08:53 <wli> Of termination analysis?
22:08:53 <bparkis> do you have a particular language in mind?
22:09:00 <newsham> (or at the least, it has not yet been proven to be impossible/undecidable)
22:09:28 <wli> I think there's something like Charity or Chorus along these lines.
22:10:30 <newsham> http://www.rubrication.net/2007/01/26/total-functional-programming/
22:10:34 <lambdabot> Title: Rubrication  Total Functional Programming, http://tinyurl.com/2gxmes
22:10:36 <wli> It's not all that far out. Just ban constructs that introduce undecidability of termination or run a termination analyzer and reject programs that don't provably terminate.
22:11:59 <wli> There are, of course, other considerations, like "effective nontermination" for things that run too slow.
22:14:59 <wli> e.g. the algorithm's guaranteed to terminate within 1000 years but the hardware will die before then
22:30:40 <newsham> 
22:30:41 <newsham> weird
22:34:34 <bos> newsham: fullwidth unicode, eh?
22:34:48 <newsham> yah
22:35:33 <goalieca> fancy pants
22:37:27 <ski> wli : "Chorus" ?
22:37:46 <wli> ski: I think it's the name of a programming language.
22:38:06 <wli> vi Qual.lhs
22:38:25 <ski> wli : being different from Charity, then ?
22:39:21 <wli> ski: I'm having a tough time remembering. The thought is that there was a relevant programming language called one of those two or that there may have been languages called each of those names.
22:39:56 <ski> @where Charity
22:39:56 <lambdabot> I know nothing about charity.
22:40:03 <ski> @where+ Charity http://pll.cpsc.ucalgary.ca/charity1/www/home.html
22:40:03 <lambdabot> Plugin `where' failed with: getRandItem: empty list
22:41:01 <ski> anyway, Charity is total
22:41:18 <ski> data is terminating, codata is productive
22:48:07 <Gaea_Owl> So is it too late at night to ask a few really basic questions?
22:48:09 <allbery_b> @ask dons LB: does @seen normally get confused when you ask about someone who has just joined a channel but not spoken yet?  I've just reproduced a report that you get "I don't know when $nick last spoke" in such cases
22:48:09 <lambdabot> Consider it noted.
22:48:22 <allbery_b> #haskell is international in scope
22:48:36 <allbery_b> (admittedly less so now that dons has relocated to the US...)
22:48:53 <sorear> Gaea_Owl: what's night?
22:49:29 <Gaea_Owl> Awesome. Guten morgen, goedemorgen, bonjour, and a variety of others I can't think of at the moment.
22:50:01 <omnId> Good morning perhaps?
22:50:12 <sorear> @time sorear
22:50:13 <newsham> aloha
22:50:15 <Gaea_Owl> Well, yes, that too.  See, it's late *here*. ;)
22:50:15 <lambdabot> Local time for sorear is Fri Oct 26 22:50:09 2007
22:50:19 <sorear> @time dcoutts
22:50:20 <lambdabot> Local time for dcoutts is Sat Oct 27 06:53:18
22:50:29 <sorear> @time JohnMeacham
22:50:29 <omnId> anyway, you had some questions?
22:50:30 <lambdabot> Local time for JohnMeacham is Fri Oct 26 22:50:29
22:50:34 <allbery_b> boker tov
22:50:40 <sorear> @time lament
22:50:41 <lambdabot> Local time for lament is Fri Oct 26 22:50:40 2007
22:50:52 <allbery_b> @time
22:50:53 <lambdabot> Local time for allbery_b is Sat Oct 27 01:50:53
22:50:55 <Gaea_Owl> I'm stuck a bit in shifting my thinking away from object-based state machines. The more I read about functions, I can't get away from seeing functional programs like a script - they execute from top to bottom through main and that's it.
22:51:00 <sorear> did everone move to the west coast when I wasn't looking?
22:51:15 <sjanssen> @time sjanssen
22:51:16 <lambdabot> Local time for sjanssen is Sat Oct 27 00:51:15 2007
22:51:31 <allbery_b> maybe galois is sucking in all the haskellers
22:51:43 * sorear kinda expects people with names like "Nikita Ayzikovsky" to not live in the US
22:51:46 <Gaea_Owl> Great, if you need to do a particular action. But how would this move up to, say, a more interactive type of program? I'm not explaining that well.
22:52:02 <allbery_b> gaea_owl: absent the IO monad, haskell acts like a set of equations
22:52:11 <Gaea_Owl> A script runs top to bottom. Pour some data in the top, add some in the sides, and out pops the answer.
22:52:26 <sorear> Gaea_Owl: that's what case is for
22:52:40 <sorear> > case 2 > 3 of True -> 'x' ; False -> 'y'
22:52:42 <lambdabot>  'y'
22:52:42 <newsham> sorear: over here in america we take people with all sorts of names (except mohammed)
22:52:52 <sorear> if you want loops you use recursion
22:53:05 <wli> They don't seem to like "Saddam" or "Hussein," either.
22:53:07 <newsham> well, we used to at least
22:53:13 <sorear> @remember newsham over here in america we take people with all sorts of names (except mohammed)
22:53:13 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:53:16 <sorear> @remember newsham over here in america we take people with all sorts of names (except mohammed)
22:53:16 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:53:23 <newsham> thank goodness that cant be remembered.
22:53:38 <sorear> Why does this bug only manifest right after twanvl goes to sleep?
22:53:41 * omnId goes to a Dr. Husain.
22:53:47 <allbery_b> the same folks that don't like mohammed also don't like much of anything else that doesn't sound sufficiently "american" :/
22:53:49 <sjanssen> sorear: perhaps he flips a switch :)
22:53:51 <newsham> sorear: it happened to me an hour ago or more
22:54:03 <sjanssen> and why is @remember calling getRandItem?
22:54:04 <newsham> [18:56] < newsham> ?remember sorear Writing nonterminating functions in total
22:54:30 <omnId> sjanssen: someone changed the "Done." response to a random one.
22:54:33 <sorear> sjanssen: twanvl's variety patch
22:54:37 <sjanssen> @quote we.take.people
22:54:37 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:54:44 <sjanssen> lambdabot: I hate you
22:54:51 <newsham> ?slap lambdabot
22:54:51 <lambdabot> Plugin `slap' failed with: getRandItem: empty list
22:54:52 <omnId> that's the insults failing :)
22:54:53 <allbery_b> hm.  does that mean the quote got remembered (twice)?
22:54:59 * wli is un-American.
22:55:06 <omnId> @quote mohammed
22:55:06 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:55:08 <allbery_b> I don't think LB does transactions
22:55:20 <newsham> america is still a great country, despite the idiots temporary running it
22:56:04 * wli sings, "'Cause I'm proud to be a Canadian, where at least I know I'm free. And I won't forgive the right-wingers who lied to take my rights from me."
22:56:05 <allbery_b> newsham: that is in some ways the most frustrating part.  as bad as things havebecome, it's still better than pretty much anywhere else in many, many ways
22:56:28 <newsham> hopefully that continues to remain true, allb.
22:56:48 <newsham> wli: send me loonies.
22:57:02 <newsham> $1.04 today
22:57:39 <newsham> last time I was in canadia it was $0.75
22:57:59 <wli> newsham: They're worth more than USD these days anyway. Sadly, my claim to being Canadian is pure hopes, dreams, and the thought I might be able to pass as such to avoid getting bashed by those who might hold US foreign policy against me.
22:58:34 <Cale> Go Canada! :)
22:59:22 <allbery_b> you're an obvious candidate for that Tshirt which has "I'm sorry my President is an idiot" written in multiple languages
22:59:44 <newsham> i'd prefer a "Kip Hawley is an Idiot" ziplock bag.
22:59:52 * omnId double-checks which channel he's in.
23:00:32 <wli> Odds are I'd not actually be singled out for such treatment given my appearance.
23:01:18 <sjanssen> sorear: have you looked at this getRandItem bug at all?
23:01:23 <sorear> no
23:01:35 <sjanssen> @elite foo
23:01:35 <lambdabot> Plugin `elite' failed with: getRandItem: empty list
23:01:39 <sjanssen> even that is broken
23:01:56 <wli> I think I know how to represent qualified types with MPTC's but have no idea of what to do with fundeps.
23:01:56 <newsham> out of entropy.  come back later.
23:02:32 <sjanssen> getRandItem [] _       = error "getRandItem: empty list"
23:02:37 <sjanssen> is the only place that string occurs
23:03:54 <sorear> wli: you don't, they only figure into context reduction (and ambiguity testing, if you're into things like that)
23:04:35 <wli> sorear: Well, those are part of type inference, so I need them somewhere. Where, I have no idea.
23:05:18 * allbery_b does a pull in the pristine copy, just for grins
23:05:20 <sorear> sjanssen: might be laziness
23:05:39 <sjanssen> hmm yes, a bad thunk somewhere
23:05:49 <sjanssen> @src getStdRandom
23:05:50 <lambdabot> Plugin `source' failed with: getRandItem: empty list
23:05:54 <sjanssen> fuck you
23:05:59 <omnId> oh geez
23:06:03 <sjanssen> excuse my language
23:06:16 <omnId> @type getStdRandom
23:06:18 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
23:06:22 <wli> sorear: I don't want to spend too much time on the term language, though, as the point of all this is supposed to be the module language.
23:06:32 <omnId> @type getStdRandom (randomR (0,10))
23:06:34 <lambdabot> forall t. (Num t, Random t) => IO t
23:06:52 <sjanssen> getStdRandom :: (StdGen -> (a,StdGen)) -> IO a
23:06:52 <sjanssen> getStdRandom f = atomicModifyIORef theStdGen (swap . f)
23:06:52 <sjanssen>   where swap (v,g) = (g,v)
23:07:06 <sjanssen> if f give _|_ ...
23:07:09 * sorear mutters something provokative about rewriting lambdabot in a real language
23:07:32 <wli> sorear: A real language being?
23:08:06 <sorear> dons!! we found it!!
23:08:10 <sorear> @seen dons
23:08:10 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 14m 58s ago.
23:09:31 <goalieca> wli: vhdl
23:09:56 <sorear> @tell dons Lambdabot's failing is due to twanvl's refactoring of random to make the core pure.  It returns an error, which getStdRandom obligingly sets as the new seed.  All future attemptts to acces the RNG fail.  (This insight brought to you by Spencer Janssen)
23:09:56 <lambdabot> Consider it noted.
23:10:18 <newsham> real languages are languages written in pencil, right?
23:11:46 <goalieca> newsham, in spice actually. cuz you have to simulate the transistors themselves
23:12:11 <sorear> Note that this bug could not exist in a strict language.
23:13:45 <newsham> spice is unsound.
23:14:29 <sjanssen> anybody around that can add me to the lambdabot group on code.h.o?
23:15:28 <sorear> laziness and transactions don't mix - laziness is all about delaying failures, transactions are all about "fail now or forever work properly"
23:15:42 <newsham> so then STM is doomed to fail?
23:16:35 <sorear> *thinks* No, because the core ideas can be transplanted to a non-lazy language.
23:17:22 <sjanssen> sorear: hmm, you might be able to make the case that TVars should be strict
23:17:27 <goalieca> sorear, huh? isn't haskell a shining model of STM being implemented
23:18:03 <Philippa> sjanssen: it's worse than that, you want deepSeq
23:18:04 <sorear> implemented =/=> good idea
23:18:14 <sjanssen> and I don't think the "Crouching Laziness, Hidden Bottom" problem is unique to transactions
23:18:29 <sorear> so many quotable lines
23:29:03 <sjanssen> @tell dons can you add me to the lambdabot group on code.h.o?  Also, the new repo doesn't have 'email' set
23:29:04 <lambdabot> Consider it noted.
23:30:48 <sjanssen> well, hopefully that bug is fixed the next time dons rebuilds lambdabot
