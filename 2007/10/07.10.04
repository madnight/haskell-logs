00:01:12 <Mr_Awesome> is there a function that makes a pair out of two things?
00:01:23 <Pseudonym> (,)
00:01:28 <Heffalump> (,)
00:01:43 <Mr_Awesome> but its not possible to use a section with it?
00:01:59 <Mr_Awesome> > (1 ,)
00:01:59 <lambdabot>  Parse error
00:02:10 <Mr_Awesome> (, 1)
00:02:14 <Pseudonym> > let f = (,) 1 in f 2
00:02:15 <lambdabot>  (1,2)
00:02:16 <Mr_Awesome> > (, 1)
00:02:16 <lambdabot>  Parse error
00:02:25 <omnIdiot> the closest are ((,) x) and (flip (,) y)
00:03:14 <Heffalump> correct
00:11:16 <quicksilver> anyone know about mainLoop and GLUT and threads ?
00:16:41 <quicksilver> I feared not.
00:16:43 <quicksilver> :)
00:20:08 <dolio> I would guess: don't use GL in multiple threads.
00:20:34 <dolio> If that's the question.
00:27:56 <quicksilver> dolio: yeah, I guessed that much to
00:29:13 <quicksilver> dolio: and, I'm not
00:29:13 <quicksilver> dol	but my worker thread is making the GUI unresponsive
00:30:34 <quicksilver> dolio: I think my RTS isn't being 'threaded enough'
00:30:56 <quicksilver> dolio: it needs to run the mainLoop in a separate OS thread so that the GUI is responsive but my worker thread still runs
00:31:14 <dolio> Ah.
00:36:13 <quicksilver> dolio: ah! the answer was as simple as 'remember to link with -threaded'
00:37:24 <quicksilver> dolio: still slightly unresponsive but much much better
00:38:10 <dolio> At least it was easy. :)
00:38:35 <quicksilver> and if I run the app with -RTS -N2 +RTS then it's lovely :)
00:38:37 <quicksilver> but I'd like to be able to run on single CPU machines too
00:39:59 <quicksilver> oh
00:40:01 <quicksilver> -C0
00:40:07 <quicksilver> make context switches as often as possible
00:40:08 <quicksilver> nice
00:40:15 <quicksilver> that makes it run well even on one core
00:56:43 <tibbe> @source Network
00:56:43 <lambdabot> http://darcs.haskell.org/packages/network/Network.hs
00:59:48 <xelxebar> what's the converse of liftM?
01:04:16 <pjd> xelxebar: converse?
01:06:04 <pjd> if you mean (m a -> m b) -> (a -> b), there's no general way
01:06:51 <pjd> you can lift a -> m a with return, but you can't generally extract m b -> b
01:09:46 <tuomov_> Isn't there a variant of quickcheck that can do IO?
01:11:03 <glguy> hunit?
01:11:12 <glguy> for some value of variant
01:11:26 <tuomov_> as simple to use?
01:11:33 <glguy> I thought so...
01:15:01 <tuomov_> doesn't seem quite as simple, but maybe tolerable
01:18:03 <xelxebar> pjd: thanks
01:23:04 <tuomov_> umm... but hunit doesn't actually generate test cases?
01:23:10 <tuomov_> s/cases/data/
01:23:11 <tuomov_> worthless
01:23:44 <tuomov_> the nice thing about quickcheck is the data generation.. otherwise one could just write ad hoc code for the tests
01:25:01 <Heffalump> so it's hard to write equational properties for IO
01:26:02 <tuomov_> doesn't seem hard to me. Of course there are things that could go wrong, but the test code itself shouldn't differ that much from non-IO code
01:26:05 <shteou> Take care my friends, off to York for the new term!
01:26:07 * shteou waves
01:26:19 <Heffalump> well, just use some unsafePerformIOs and don't complain when all hell breaks loose
01:26:52 <tuomov_> I'm doing unsafePerformIOs now, for tests that can safely run in parallel with their own IORefs and stuff
01:27:11 <Heffalump> what's the problem then?
01:27:14 <tuomov_> but unsafePerformIO doesn't seem it would work that well for file IO
01:27:43 <tuomov_> unless I create a new random file for every test, but that gets ugly
01:27:55 <therp> unsafePerformIO makes SPJ cry
01:27:55 <Heffalump> I expect not, no. That's why there are problems with using IO and equational properties together.
01:28:33 <tuomov_> all the tester has to do, is to run the tests in a sequence, in IO monad
01:28:47 <tuomov_> it's up to the author to make sure the tests are free of other interference
01:28:53 <Heffalump> well, go ahead and fix it to do that
01:28:59 <tuomov_> but quickcheck doesn't provide a function for testing IO, and HUnit doesn't seem to generate data
01:29:03 <Heffalump> I expect quite a lot of people would like that.
01:33:59 <misterbeebee> > mkf 2 2 2
01:34:00 <lambdabot>  4
01:44:04 <misterbeebee> -- @let ki = (flip $ flip (!!) . pred)
01:44:11 <misterbeebee> -- @let mkf n = case n of 0 -> (+); _ -> ki . ((mkf $ pred n) >>= iterate)
01:44:16 <misterbeebee> -- @let knuth_up_arrow = mkf 3
01:44:26 <misterbeebee> >  [(a,b, knuth_up_arrow a b) | a <- [2,3], b <- [1,2,3,4]]
01:44:28 <lambdabot>  Exception: stack overflow
01:44:56 <misterbeebee> > [(a,b, knuth_up_arrow a b) | a <- [2], b <- [1,2,3,4]]
01:44:57 <lambdabot>  [(2,1,2),(2,2,4),(2,3,16),(2,4,65536)]
01:45:15 <misterbeebee> [(a,b, knuth_up_arrow a b) | a <- [3], b <- [1,2]]
01:45:31 <misterbeebee> >  [(a,b, knuth_up_arrow a b) | a <- [3], b <- [1,2]]
01:45:32 <lambdabot>  [(3,1,3),(3,2,27)]
01:45:40 <misterbeebee> knuth_up_arrow 3 3
01:45:49 <misterbeebee> > knuth_up_arrow 3 3
01:45:51 <lambdabot>  Exception: stack overflow
01:45:58 <misterbeebee> > 3 ^^ 27
01:45:59 <lambdabot>  7.625597484987e12
01:47:09 <EvilTerran> > 3 ^ 27
01:47:10 <lambdabot>  7625597484987
01:49:11 <misterbeebee> so... how to optimize mkf without losing the conciseness?
01:49:45 <quicksilver> run everything with -O2 for strictness analysis?
01:49:54 <quicksilver> although, actually I think lambdabot does use O2...
01:50:01 <quicksilver> > sum [1.1000000]
01:50:02 <lambdabot>  1.1
01:50:05 <quicksilver> > sum [1..1000000]
01:50:07 <lambdabot>  500000500000
01:50:10 <quicksilver> yes, must do
01:50:12 <Cale> heh
01:50:15 <quicksilver> otherwise that would overflow
01:50:26 <dons> http://programming.reddit.com/info/2wfq9/comments
01:50:27 <lambdabot> Title: From type checker to GADT - the full implementation of a typed DSL :: Oleg (redd ...
01:50:30 <dons> ;)
01:51:39 * misterbeebee is super excited that he learned (->) monad today and used it in a relevant mathematical diversion
01:53:01 <Cale> I love the ((->) e) monad.
01:55:15 <xelxebar> > if (parse >>= (liftM elem '.')) then 1 else 0 where parse = many1 (oneOf ".123")
01:55:15 <lambdabot>  Parse error
01:56:04 <EvilTerran> where{} only works in bindings and case statements. use let{} instead
01:56:23 <EvilTerran> > let parse = many1 (oneOf ".123") in if (parse >>= (liftM elem '.')) then 1 else 0
01:56:24 <lambdabot>   Not in scope: `oneOf'
01:56:39 <EvilTerran> oh, and lambdabot doesn't have Parsec
01:56:54 <xelxebar> ahh
01:58:01 <xelxebar> however, that doesn't actually work, i'm getting a type error
01:58:06 <dv^^> the ((->) e) monad?
01:58:08 <quicksilver> Cale: except sometimes I want than one leading parameter
01:58:32 <xelxebar> basically how can one use elem if the list is monadic?
01:59:33 <EvilTerran> i think you want liftM (elem '.') parse
01:59:47 <EvilTerran> sorry, liftM (elem '.') . parse
02:00:13 <quicksilver> Cale: /\ x  e -> (f -> x)
02:04:13 <Cale> dv^^: yeah, functions from a fixed type e form a monad
02:04:14 <xelxebar> EvilTerran: Couldn't match expected type `a -> m [Char]' against inferred type `GenParser Char st [Char]'
02:04:23 <EvilTerran> hmm
02:04:37 <Cale> > (do { x <- id; y <- reverse; z <- map toUpper; return (x,y,z) }) "hello"
02:04:39 <lambdabot>  ("hello","olleh","HELLO")
02:05:09 <pjd> dv^^: functions of a shared environment, basically
02:05:49 <Cale> > join (++) "hello"
02:05:50 <lambdabot>  "hellohello"
02:06:08 <EvilTerran> xelxebar, sorry, yes, the first version (without the .) was right
02:06:10 <Cale> > sequence [id,(+2),(*2),(^2),(2^)] 5
02:06:12 <lambdabot>  [5,7,10,25,32]
02:06:29 <EvilTerran> i got confused and thought parse was a function
02:06:48 <ac> how do globals work?
02:07:01 <sieni> what globals?
02:07:05 <Cale> ac: globals? You can define module level constants.
02:07:12 <quicksilver> ac: pi = 3.14 --- global
02:07:13 <EvilTerran> xelxebar, also, i seem to recall Parsec already has a function called parse.
02:07:24 <EvilTerran> ?index pi
02:07:24 <lambdabot> Prelude
02:07:49 <Cale> > pi :: Double
02:07:50 <lambdabot>  3.141592653589793
02:07:53 <Cale> > pi :: Float
02:07:54 <lambdabot>  3.1415927
02:08:03 <EvilTerran> > pi :: Rational
02:08:03 <lambdabot>   add an instance declaration for (Floating Rational)
02:08:04 <lambdabot>     In the expression: ...
02:08:05 <EvilTerran> bother.
02:08:08 <ac> Is there a way to change them?
02:08:14 <ac> Let's say I didn't want the pi global
02:08:16 <Cale> ac: nope
02:08:30 <int-e> ac: you can hide it when importing Prelude
02:08:30 <Cale> You can shadow them in your own module
02:08:31 <EvilTerran> import Prelude hiding (pi)
02:08:31 <xelxebar> EvilTerran: yeah, parse is a funcion.  badly chosen name on my part.  anyway, the first proposal still complains:  Couldn't match expected type `Bool' against inferred type `GenParser Char st Bool'
02:08:34 <Cale> and hide it, yeah
02:08:35 <quicksilver> ac: No. Definitions in haskell are values, not 'variables' in the varying sense
02:08:55 <int-e> @type pi
02:08:56 <quicksilver> ac: it's surprising how rarely you need 'varying' global variables.
02:08:57 <lambdabot> forall a. (Floating a) => a
02:09:15 <ac> quicksilver: well I don't want them to vary over the course of the program, I just want to redefine them in the beginning
02:09:19 <int-e> it's surprising how many values are functions :)
02:09:28 <EvilTerran> xelxebar, ah, i see the problem. that expression is of type GenParser Char st Bool, and if's condition must be a bool
02:09:38 <xelxebar> EvilTerran: exactly
02:09:57 <quicksilver> ac: the traditional solution is to stick them in a data type which represents your 'context' or 'configuration' and pass them to all functions which need them
02:10:04 <xelxebar> do we then liftM the if??!
02:10:11 <quicksilver> ac: that makes the config-dependence explicit in the types, which is nice
02:10:23 <EvilTerran> may i suggest do { cs <- many1 (oneOf ".123"); return $ if '.' `elem` cs then 1 else 0 }
02:10:34 <quicksilver> ac: there are monads which can hide the troublesome plumbing work, to a large extent.
02:11:07 <glguy> implicit vars?
02:11:08 <ac> Well, for example (I'm still stuck on random numbers :), how could I shadow the global StdGen?
02:11:13 <xelxebar> hahaha, I was hoping to avoid the a do
02:11:24 <EvilTerran> xelxebar, unfortunately, there's no way of lifting if, other than saying liftM (\x -> if x then ...)
02:11:55 <mux> does someone know the Cabal field to use for adding a .c file to the build?
02:12:27 <EvilTerran> xelxebar, some people define a function "if' :: Bool -> a -> a -> a" that does the obvious for such purposes
02:12:44 * EvilTerran prefers bool :: a -> a -> Bool -> a, actually, but that's just me
02:12:56 <mux> ah, c-sources
02:13:28 <quicksilver> glguy: wash your mouth out :)
02:13:36 <quicksilver> ac: there isn't a global StdGen
02:13:41 <xelxebar> hmmm, interesting...
02:13:41 <quicksilver> ac: not in the sense you think
02:13:43 <EvilTerran> a monadic if _would_ be nice, but probably not necessary
02:14:03 <ac> quicksilver: guess the docs do say it's implicit
02:14:12 <quicksilver> a problem with a monadic if is that there are a variety of different ways to lift it
02:14:16 <quicksilver> ac: no, it's not just that
02:14:21 <quicksilver> ac:  you can get it and set it easily enough
02:14:32 <quicksilver> ac: (getStdGen and setStdGen, I think? something like that)
02:14:47 <quicksilver> ac: the point is, it isn't global. It's in the IO monad. Different.
02:15:13 <ac> ok. I'll defer the explenation of that to my future self
02:15:22 <quicksilver> ac: there is no symbol 'globalStdGen :: StdGen' which is in scope throughout your program. *that* would be a global stdgen
02:15:38 <quicksilver> ac: instead, there is something you can ask the operating system for, in the IO monad
02:15:52 <quicksilver> ac: and you get back something different each time (I think it's seeded based on clock time or something)
02:16:03 <EvilTerran> yeah, that's true. i'd say only linking in the predicate and the "followed branch" would be most intuitive, especially for a special language construct
02:16:27 <xelxebar> > (\x if x then 1 else 2) 1==1
02:16:28 <lambdabot>  Parse error
02:16:28 <quicksilver> EvilTerran: right. But, obviously, that's different from "liftM3 if'"
02:16:34 <EvilTerran> indeed.
02:16:43 <quicksilver> EvilTerran: not that that's a problem, But it's a gotcha to be aware of.
02:16:45 <ac> quicksilver: so when is it asked for?
02:16:55 <ac> quicksilver: every call to getStdGen?
02:16:56 <EvilTerran> another reason to have it; it's clumsy to do at the moment
02:17:03 <quicksilver> ac: it's asked for implicitly when you use the IO flavours of the random functions
02:17:14 <quicksilver> ac: and explicitly if you decide to call getStdGen
02:17:19 <ac> so every time you call randomIO, it calls getStdGen to get its StdGen
02:17:31 <EvilTerran> mif mp x y = do p <- mp; if p then x else y; i guess
02:17:42 <quicksilver> ac: well, morally it does
02:18:01 <quicksilver> ac: I'm not sure how it's implented in fact :)
02:18:07 <sieni> ac: http://www.cs.chalmers.se/~rjmh/Globals.ps
02:18:55 <quicksilver> ac: ah yes, it does in practice too
02:19:10 <quicksilver> ac: if you just want to change or set the gen, just call setStdGen
02:19:20 <quicksilver> ac: and then subsequent calls to randomIO will use that
02:19:41 <ac> quicksilver: what I want to do is a little different. I want all calls to randomIO use a StdGen of my own definition
02:20:01 <ac> but the solution to that is to just make myRandomIO
02:20:03 <quicksilver> ac: then call setStdGen with that StdGen?
02:20:36 <ac> quicksilver: that doesn't work because a new global StdGen is seeded from /dev/random theoretically
02:20:55 <ac> ... with every call to randomIO
02:21:00 <quicksilver> ac: no no
02:21:04 <quicksilver> ac: it's not making a new one
02:21:13 <quicksilver> ac: it's accessing the same underlying one, which is buried in the IO monad
02:22:57 <ac> I'm hopeless
02:23:09 <quicksilver> ac: no, I explained it badly
02:23:13 <quicksilver> ac: sorry :)
02:23:27 <quicksilver> ac: I was trying to distinguish between 'global value' and 'global IO variable'
02:23:32 <quicksilver> because they're different things
02:23:35 <quicksilver> but I think I just confused you :)
02:24:00 <ac> so the StdGen buried in the IO monad is not necessarily implemented in haskell?
02:24:16 <ac> meaning it could be part of the runtime?
02:24:31 <quicksilver> it could be
02:24:37 <quicksilver> actually, I believe it *is* implemented in haskell
02:24:38 <ac> so that means it's completely inaccesible
02:24:42 <quicksilver> only the seed value comes from the runtime
02:24:50 <EvilTerran> well, GHC's implemented in haskell too...
02:24:56 <quicksilver> EvilTerran: not entirely
02:25:06 <ac> if only the seed value comes from the runtime, then randomIO shouldn't have a type of IO
02:25:06 <EvilTerran> i know, i know. it's a nice idea though.
02:25:28 <EvilTerran> speaking of random numbers, has anyone done a mersenne twister for haskell?
02:25:35 <quicksilver> no, I wish someone would
02:25:40 <quicksilver> do you feel like doing so? ;)
02:25:49 <ac> I would if I knew what it was, perhaps
02:25:57 <quicksilver> it's a better RNG than the one we have
02:26:11 <EvilTerran> i'm thinking about it
02:26:22 <EvilTerran> looking up the algo as we speak ;)
02:26:34 <quicksilver> ac: anyhow, guideline for using random in haskell is don't use RandmIO
02:26:45 <ac> it's there for convenience
02:27:11 <quicksilver> ac: for anything more than a quick hack which happens to be in IO anyway
02:27:27 <quicksilver> ac: use the non-IO calls
02:27:30 <ac> ok. I'll keep that in mind here
02:27:40 <quicksilver> it's much nicer to have pure functions
02:27:48 <quicksilver> (which take a gen as a parameter, presumably)
02:28:23 <ac> but what if you don't feel like passing around the generator all the time?
02:28:49 <quicksilver> ac: you should feel like doing that :P It's the right thing to do.
02:28:59 <quicksilver> Trust the type system, make your state explicit.
02:29:05 <quicksilver> You will be thankful later.
02:29:22 <quicksilver> There are techniques including monads to hide the syntax noise, or most of it.
02:29:43 <ac> well right, but what I was actually asking is if there's some short of sort hand for it sort of like "do"
02:29:53 <EvilTerran> MonadState StdGen?
02:29:59 <quicksilver> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
02:30:00 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
02:30:11 <quicksilver> ^^ that's Cale's answer
02:30:13 <EvilTerran> (with a couple of helper functions to deal with the state)
02:30:14 <ac> ah yes, that's what I was looking for
02:30:22 <quicksilver> a generic typeclass for monads which can produce random values
02:30:55 <quicksilver> that should really be in the default libraries, but it isn't
02:31:20 <EvilTerran> that's pretty much my suggestion with nice newtyping so you can't muck about with the generator except through the "helper functions", isn't it?
02:31:27 <quicksilver> yes
02:31:36 <quicksilver> and it doesn't use StdGen, it uses RandomGen g
02:32:05 <ac> before I jump to using that, I think I'll pass it around for a little while
02:32:15 <quicksilver> I would :)
02:32:22 * EvilTerran likes it when that happens. something satifying about "I have an idea that i think's quite good" "oh, someone's already done that" "hooray, i'm not the only one who thought it was a good idea!"
02:32:23 <quicksilver> in small programs I just pass it around
02:32:34 <ac> EvilTerran: indeed
02:32:39 <quicksilver> EvilTerran: especially if it's someone as smart as Cale :)
02:32:45 <EvilTerran> indeed
02:36:46 <xelxebar> grrr... we need unliftM :P
02:36:58 <MADnificent> If I'd like to know the type of the bind function for the list-Monad through ghci, what should I type then?  ( :t (>>=) ) gives me the general function
02:37:02 <Cale> xelxebar: what would its type be?
02:37:32 <xelxebar> Cale: exactly, that's what makes it silly
02:37:44 <quicksilver> MADnificent: interestingly, I don't think there is a direct way to do that
02:37:59 <EvilTerran> :t \x -> (>>=) (x::[a])
02:38:01 <lambdabot>     Inferred type is less polymorphic than expected
02:38:02 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
02:38:07 <EvilTerran> ...
02:38:09 <xelxebar> i'm just floundering over this problem of getting a monadic value unmonadified
02:38:24 <gvdm> xelxebar: you don't
02:38:29 <quicksilver> xelxebar: you can't do it in general. You have to accept this fact and make peace with it.
02:38:33 <EvilTerran> that's not a problem, you're not supposed to be able to!
02:38:33 <gvdm> monads are one way
02:38:45 <EvilTerran> it's a key bit of what makes the magic work
02:38:47 <quicksilver> xelxebar: syntactically, you do this " unwrapped <- monadic_thing "
02:38:58 <pjd> xelxebar: you can have that, but it's an additional property on top of general monads
02:39:00 <gvdm> but it never really unwraps
02:39:05 <quicksilver> xelxebar: if you like to think of that way, '<-' is the only general way to unwrap things
02:39:18 <quicksilver> xelxebar: (but you're still "stuck in the monad". That's OK, though.)
02:39:19 <pjd> xelxebar: not all monads can support it
02:39:50 <quicksilver> xelxebar: most monads have a special-purpose specific way, of course
02:39:58 <quicksilver> xelxebar: it's normally got a name like 'runFoo'
02:40:03 <ac> It's ok because everything you get from <- goes back in to a monad, right?
02:40:09 <EvilTerran> hm. i think the best way of getting a mersenne twister in haskell would be to hook in the "SIMD-oriented Fast Mersenne Twister" C implementation
02:40:11 <quicksilver> xelxebar: and, depending on the monad, it takes some extra parameters
02:40:31 <quicksilver> xelxebar: like runState, or runWriter
02:40:40 <xelxebar> well, maybe i'm just thinking incorrectly, but the do statements feel too imperative, so i'd like to minize their use. thus i'm running into this problem
02:40:52 <quicksilver> you are correct to minimize their use
02:41:05 <quicksilver> normally you do this by using pure functions from inside the do blocks
02:41:13 <EvilTerran> it's meant to be quite a lot better than the standard one, and it uses low-level hackery to go fast, so doesn't translate nicely into haskell
02:41:14 <xelxebar> does Parsec have a runFoo?
02:41:17 <quicksilver> then the do block becomes a 'small warapper function'
02:41:19 <pjd> Control.Applicative helps!
02:41:23 <quicksilver> xelxebar: runParser, IIRC
02:41:29 <quicksilver> ac: yes, correct.
02:41:41 <xelxebar> hahaha, that's too obvious.  thanks
02:41:58 <ac> weee, I'm already getting some sort of grasp of monads
02:41:59 <quicksilver> do block becomes a 'small wrapper' and all your hard work is done in the pure function
02:42:27 <quicksilver> do { x <- some_monadic_bit ; y <- some_other_monadic_bit ; return (pure_function x y) }
02:42:34 <quicksilver> is a very typical pattern
02:42:44 <quicksilver> then "most of" your program is in the pure_function part
02:43:19 <xelxebar> okay, that makes sense and is basically what i'm doing
02:43:51 <xelxebar> though possibly I'm trying too hard to avoid the do?
02:43:57 <xelxebar> thanks for your help
02:43:59 <ac> :type (<-)
02:44:00 <quicksilver> :)
02:44:08 <quicksilver> you can hide the do, of course
02:44:08 <pjd> quicksilver: pure_function <$> some_monadic_bit <*> some_other_monadic_bit
02:44:16 <quicksilver> and pjd just showed how :)
02:44:25 <ac> (that didn't work)
02:44:45 <pjd> or liftM2 pure_function m1 m2
02:44:55 <ac> why isn't <- a normal operator?
02:45:04 <idnar> it's part of the do block syntax
02:45:10 <quicksilver> ac: because it can't be :)
02:45:17 <quicksilver> ac:  it's syntactic sugar
02:45:39 <quicksilver> do { x <- f ; g x } is just sugar for f >>= g
02:45:41 <ac> hmmm. I guess it's a sort of macro, which aren't generalized in haskell right?
02:45:56 <EvilTerran> in a manner of speaking, yes. it's sugar.
02:45:58 <quicksilver> you could think of it as a syntactic macro, yes
02:46:08 <quicksilver> in the same sense that [1,2,3,4] is a macro for 1:2:3:4:[]
02:46:11 <xelxebar> is there a shorter way of writing (x `elem` z || y `elem` z)?
02:46:24 <EvilTerran> but then, everything's sugar except case, lambda, and =
02:46:25 <ac> quicksilver: yeah, that sort of thing is familiar to me from scheme
02:46:25 <quicksilver> xelxebar: x `elem` (y ++ z) ?
02:46:25 <EvilTerran> :P
02:46:36 <quicksilver> xelxebar: oh, sorry misread it :)
02:46:55 <idnar> @pl \x y -> (x `elem` z || y `elem` z)
02:46:56 <lambdabot> (. (`elem` z)) . (||) . (`elem` z)
02:46:59 <idnar> @pl \x y z -> (x `elem` z || y `elem` z)
02:46:59 <lambdabot> (. elem) . ap . ((||) .) . elem
02:47:02 <quicksilver> :t any
02:47:03 <EvilTerran> any (`elem` z) [x,y]?
02:47:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:47:11 <idnar> @pl \z -> (x `elem` z || y `elem` z)
02:47:11 <lambdabot> liftM2 (||) (x `elem`) (y `elem`)
02:47:13 <ac> EvilTerran: hmmm. that's not a very meaningful statement because haskell is an implementation of much higher level primitives
02:47:15 <idnar> heh
02:47:17 <quicksilver> yeah, what EvilTerran said
02:47:52 <quicksilver> ac: I don't understand your objection? Everything is sugar except case, lambda, = and application ("")
02:48:04 <quicksilver> ac: and datatypes of course, but they're different in some sense.
02:48:24 <EvilTerran> ah, yes, forgot application. that's an important one. ;)
02:48:51 <ac> but hankell is not an implementation consisting of those things, so it's not very meaningful to think of programming in Haskell in that way
02:49:04 <ac> s/hankell/Haskell :P
02:49:08 <xelxebar> also, what are these liftM2, liftM3 functions that keep getting referred?
02:49:12 <quicksilver> how is haskell not an implementation consisting of those things?
02:49:19 <quicksilver> surely that is exactly what haskell is?
02:49:22 <EvilTerran> xelxebar, alternatively, not $ null $ intersection [x,y] z should work
02:49:23 <pjd> ac: Haskell implementations *do* consist of pretty much just those things
02:49:28 <quicksilver> an implementation of case/lambda/apply
02:49:33 <EvilTerran> ?docs Control.Monad
02:49:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
02:49:41 <EvilTerran> that explains 'em, xelxebar
02:49:42 <ac> huh. So internally everything is simplified down to a much simpler syntax tree?
02:49:46 <quicksilver> right
02:49:50 <ac> which is then converted to machine code
02:49:50 <EvilTerran> ?src liftM2
02:49:51 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:50:11 <quicksilver> there is a language called 'Core' which is pretty much case/lambda/apply
02:50:25 <EvilTerran> and that simpler syntax tree is pretty much comprised of only the things i mentioned. as quicksilver says, it's called core.
02:50:33 <quicksilver> you can see it with ghc -fdump-simpl or -fdump-core
02:50:41 <ac> quicksilver: that's fascinating. No other compiler is that modularized
02:50:55 <EvilTerran> heh, interesting double meaning in "dump core" there
02:51:14 <pjd> ac: most functional languages are probably implemented in this style;  Haskell isn't unique
02:51:36 <EvilTerran> lisp might not be, but only because it's already little more than case/lambda/apply
02:51:41 <EvilTerran> ;)
02:51:44 <quicksilver> ac: in fact, the ghc compilation pipeline is something like Haskel -> Core -> C-- [ -> C ] -> asm
02:51:50 <ac> pjd: depends on what you mean by functional. I know most Scheme implementations are far from that
02:51:57 <quicksilver> the [ -> C ] step is mostly optional
02:52:11 <EvilTerran> isn't C-- a subset of C anyway?
02:52:16 <quicksilver> since ghc can do native code gen on most common architectures
02:52:19 <quicksilver> EvilTerran: no, not really
02:52:21 <ibid> EvilTerran: no
02:52:33 <EvilTerran> hm. i should look into C-- at some point.
02:52:48 <quicksilver> reading one of SPJ's intro papers/presentations is a good start
02:52:56 <quicksilver> I went to one of his seminars on it and enjoyed it very much
02:52:58 <idnar> yeah, Haskell is far from the only language defined like that
02:53:03 <ac> EvilTerran: it's interesting. I've read a little of the C-- documentation
02:53:27 <quicksilver> of course it's worth pointing out that ghc is EXTREMELY SLOW :)
02:53:34 <quicksilver> I mean, it's quite tolerable on modern machines
02:53:53 <quicksilver> but it's a handy two orders of magnitude slower than a good C compiler in many cases
02:54:06 <quicksilver> it does pay a price for the complex compilation technique
02:54:15 <quicksilver> on the other hand it does produce pretty good code
02:54:24 <quicksilver> faster than C, in some case :)
02:55:55 <ibid> i'd assume that some of ghc's slowness comes from having been implemeted in haskell which means unpredictable time and space behavior
02:56:08 <ibid> and not from the implementation strategy per se
02:56:58 <quicksilver> I'm not sure if that's true or not
02:57:10 <quicksilver> I think that if anyone understands the time and space constraints of ghc-compiled code
02:57:14 <quicksilver> it would be the GHC team :)
02:58:06 <ibid> i'm not sure either
02:58:14 <ibid> that's why i said i would assume :)
02:59:13 <mux> ibid: I don't see why the language in which a compiler is written should have consequences over the code it generates?
02:59:26 <quicksilver> mux: we're talking about its running time
02:59:29 <quicksilver> mux: not the code it generates
02:59:35 <mux> ah, gotcha, my bad :)
02:59:42 <quicksilver> mux: although the argument is recursing slightly since ghc compiles ghc :)
02:59:42 <ibid> what quicksilver said :)
02:59:46 <EvilTerran> what do ForeignPtr and StablePtr have different from Ptr?
02:59:54 <quicksilver> EvilTerran: names
02:59:56 <quicksilver> (sorry!)
02:59:59 <mux> EvilTerran: cos ForeignPtr's are associated with finalizers?
03:00:10 <MADnificent> if I specify type Path = [Tree] will the bind monad work like it was a list? or won't it?
03:00:11 <mux> don't know for StablePtr, but it seems logical that ForeignPtr != Ptr
03:00:12 <quicksilver> GC behaviour, I believe
03:00:18 <EvilTerran> okay
03:00:31 <EvilTerran> i'll find that bit in the docs
03:00:33 * mux notes finalizers, and the FFI in general, is neat
03:00:51 <mux> compare Haskell bindings to a C lib, and Perl XS bindings to the same lib :-)
03:01:42 <sieni> EvilTerran: Haskell objects might get moved during GC. A StablePtr is guaranteed not to move, so you can give the pointer to external code.
03:02:09 <quicksilver> mux: considering how complex an issue FFI is, the haskell FFI is admirably simple
03:02:13 <quicksilver> mux: I'm very impressed with it
03:02:15 * mux nods
03:02:18 <mux> it's a breeze to use
03:02:25 <quicksilver> mux: many other languages have *really* painful FFIs
03:02:33 <mux> everytime you think you need something specific, you stumble upon existing stuff
03:02:38 <ibid> the haskell FFI is the best FFI i've ever encountered
03:02:44 <mux> like, throwErrnoIfNull
03:02:48 <mux> peekArray !
03:02:51 <mux> yum um
03:03:34 <quicksilver> Also the haskell threading API is the simplest yet most powerful I've used
03:03:47 <quicksilver> MVars and Chans and immutable values are a great combination
03:03:50 <EvilTerran> hm. how does it decide when it's safe to run a finalizer? as soon as there's no references to the value directly from haskell, or does it look through other foreign structures for indirect references too?
03:04:21 <mux> quicksilver: oh yes!
03:04:42 <hpaste>  xelxebar pasted "Function behaving unexpectedly - should act like readFloat" at http://hpaste.org/3078
03:04:51 <quicksilver> it's so nice that you can share almost everything between threads
03:04:58 <quicksilver> because immutable values are immutable!
03:05:01 <quicksilver> it's just *safe* by definition
03:05:10 <quicksilver> a real win for the immutable style
03:05:24 <quicksilver> and then you MVar the (in practice very small) number of things you do need to pass back and forth
03:05:47 <xelxebar> if someone is up to it, would you mind helping me figure out why this function is behaving unexpectedly... still?
03:06:06 <tolik> EvilTerran: gc doesn't know about foreign structures
03:06:08 <mux> quicksilver: everyone who did extensive multi-threaded programming in C, either with pthreads or in the kernel, cannot but get incredibly impressed by concurrent programming in haskell :)
03:06:14 <quicksilver> xelxebar: incidentally, the 'List, Ratio and Char' modules are obsolete
03:06:31 <quicksilver> mux: right. I've done pthreads in C and java threads and old-style fork() IPC
03:06:32 <xelxebar> haha, okay what is a better replacement for them?
03:06:43 <quicksilver> xelxebar: Data.List, Data.Char and, erm...
03:06:52 <pjd> Data.Ratio
03:06:54 <mux> mutexes, condition variables, read/write locks, semaphores, etc are "fun", but if you can do without it, it's good :)
03:06:56 <quicksilver> thanks
03:07:09 <mux> not even mentioning sysV IPC
03:07:09 <EvilTerran> tolik, ah, okay. that nixes the possibility of me using finalizers in this case, i think.
03:07:12 <quicksilver> mux: "fun" like a good crossword puzzle is fun
03:07:22 <mux> quicksilver: right :)
03:07:23 <quicksilver> mux: which means, a nice challenge if you're in the mood
03:07:28 <EvilTerran> i was thinking more "fun" like being stabbed in the eye with a fork
03:07:33 <quicksilver> mux: but not what you want to get in the way of your simple program :)
03:07:57 <mux> quicksilver: I once rewrote a Modula-3 program which is using threads quite extensively in C
03:08:02 <mux> that wasn't really fun =)
03:08:11 <mux> well, it's fun until you need to fix bugs
03:08:25 <mux> and then gdb is totally useless, your only hope is valgrind :-)
03:09:04 <tolik> EvilTerran: and what's your case? I'm lazy to read irc logs ;)
03:09:32 <hpaste>  xelxebar annotated "Function behaving unexpectedly - should act like readFloat" with "Replaced outdated modules. . . no noticeable change." at http://hpaste.org/3078#a1
03:09:34 <EvilTerran> i'm fiddling with doing bindings to Allegro, which has a Bitmap object...
03:10:00 <EvilTerran> ...which, if it's representing a sub-bitmap of another Bitmap object, has a pointer to such
03:10:05 <quicksilver> xelxebar: no, wasn't expecting it to fix a bug :)
03:10:10 <quicksilver> xelxebar: just lettin gyou know about it :)
03:10:15 <quicksilver> xelxebar: reading your code now, anyhow
03:10:36 <EvilTerran> (but otherwise acts like any other bitmap)
03:10:37 <quicksilver> EvilTerran: I think if the objects live in the 'C Heap' that's what foreignptrs are for
03:10:44 * mux wonders if anyone in here knows about libflirt
03:10:47 <quicksilver> EvilTerran: then haskell doesn't memory manage the object at all
03:10:54 <quicksilver> EvilTerran: it just keeps a pointer to it :)
03:10:55 <EvilTerran> isn't that stableptr?
03:11:05 <quicksilver> EvilTerran: no, stableptr is in a special part of the haskell heap
03:11:05 <EvilTerran> foreignptr's the one with finalizers
03:11:10 <quicksilver> but it's still managed by haskell
03:11:14 <quicksilver> foreignptr is managed by C
03:11:16 <quicksilver> (I think)
03:11:29 <quicksilver> so : if the foreign lib allocates the memory fo rthe object, use foreignptr.
03:11:39 <quicksilver> If you allocate the memory haskell-side, use StablePtr
03:11:51 <EvilTerran> what's Ptr for, then?
03:11:51 <tolik> quicksilver: stableptrs are not pointers at all
03:12:01 <mux> ForeignPtr a is just Ptr a + a finalizer of the form FunPtr (Ptr a -> IO ())
03:12:19 <mux> and then when the GC ditches the Ptr, it calls the finalizer
03:12:20 <ac> every function exposed through the ffi must have an IO type, right?
03:12:27 <mux> ac: not necessarily
03:12:32 <EvilTerran> okay, so if i'm not using finalizers, Ptr's the way to go, then
03:12:32 <quicksilver> ac: not if you're prepared to 'pormise' that it's pure
03:12:41 <mux> functions like sin() should be pure
03:12:45 <quicksilver> mux: 'Ptr' is C-heap not haskell heap, too?
03:12:50 <quicksilver> ac: 'promise' ;)
03:12:51 <ac> I see. The compiler might create bugs if it's not pure
03:12:55 <mux> quicksilver: I only it's representing a C pointer
03:12:58 <mux> +know
03:13:06 <mux> ie FILE * becomes Ptr CFile
03:13:31 <mux> ie, fclose() has a "haskell" type of Ptr CFile -> IO CInt
03:13:33 <quicksilver> mux: right. That's "yes" then.
03:13:34 <quicksilver> :)
03:13:37 <mux> ok :)
03:14:01 <quicksilver> so 'withArray' must copy its data out of the haskell heap
03:14:04 <quicksilver> and stick in it C heap
03:14:09 <quicksilver> so that it's safe to pass it over the FFI?
03:15:27 <mux> well it serializes the array so that it can be read/written by C code
03:15:52 <mux> since as you obviously know, [Int] isn't represented as a contiguous memory location filled with int's in haskell :)
03:15:59 <mux> for instance
03:16:06 * quicksilver ndos
03:16:09 <quicksilver> yes, that too
03:16:19 <quicksilver> but it *also* moves it out of GC'able memory
03:16:22 <quicksilver> if I understand right
03:16:26 <mux> I suppose so
03:16:32 <mux> or maybe it just manages to "freeze" it?
03:16:38 <mux> I guess that's implementation details now
03:16:42 <quicksilver> true :)
03:17:44 <Ben`> where's the best place for a Haskell newbie to learn about monads?
03:17:48 <quicksilver> mux: I actually use withStorableArray because I use StorableArray to force value-strictness
03:18:06 <pjd> Ben`: forget about monads first, and learn about functors
03:18:31 <pjd> when you understand functors, monads are a very small step
03:18:31 <quicksilver> mux: which is a bit of a strange reason to do it
03:18:44 <Ben`> pjd: ok, thanks
03:18:48 <mux> I didn't know about StorableArray's
03:18:57 <quicksilver> mux: but I want to make sure the work is actually *done* in the worker thread. Bit daft to create a lazy array in the worker thread
03:19:03 <pjd> Ben`: functors can be summed up by one type signature
03:19:05 <pjd> @type fmap
03:19:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:19:09 <quicksilver> mux: and then hand it back to the main thread which forces it when it accesses it :)
03:19:24 <Ben`> and where's a good place to learn about functors? :)
03:19:38 <quicksilver> mux: and, storablearray is an efficient way to store in memory too so that's handy.
03:19:59 <quicksilver> mux: I'm wondering if this is one-copy or zero-copy :)
03:20:43 <mux> sounds like it is indeed zero-copy, in the sense that the underlying memory representation is supposed to be compatible with C
03:21:13 <mux> I suppose that's good for bindings to code where you keep arrays around for a long time
03:21:27 <SamB_XP> sure, if your storable has a C counterpart
03:21:38 <pjd> Ben`: sadly, writing functor tutorials is not as popular as writing monad tutorials
03:21:47 <SamB_XP> oww my thumb still hurts...
03:21:47 <quicksilver> SamB_XP: well, withStorableArray goes from Array e to Ptr e
03:21:56 <quicksilver> SamB_XP: I'm wondering if it does that without copying
03:22:02 <SamB_XP> quicksilver: sure
03:22:07 <quicksilver> SamB_XP: (or if it has to copy it to non-GCable memory)
03:22:31 <mux> I was impressed with how easy it was for me to write bindings to a C function, which gets a struct foo ** and an int * to return an array of stuff to the cdaller
03:22:40 <pjd> Ben`: try http://haskell.org/haskellwiki/Monads_as_containers
03:22:41 <lambdabot> Title: Monads as containers - HaskellWiki
03:22:53 <SamB_XP> quicksilver: not sure what region the Ptr points to
03:23:11 <hpaste>  mux pasted "FFI rocks!" at http://hpaste.org/3079
03:23:12 <pjd> and ask questions here :)
03:23:13 <mux> as simple as that :-)
03:23:21 <quicksilver> hmm. It is just a thing wrapper around withForeignPtr
03:23:21 <SamB_XP> quicksilver: but really that's the point ;-)
03:23:23 * mux hearts alloca, peekArray, and the rest
03:23:27 <quicksilver> SamB_XP: yeah :)
03:23:33 <SamB_XP> you don't have to worry ;-)
03:23:45 <quicksilver> SamB_XP: even if it does copy, a memcpy of 256x256x4 bytes is really not something to lose sleep over :)
03:23:55 <Ben`> pjd: thank you
03:24:01 <mux> ain't that just neat?
03:24:09 <SamB_XP> that would be exactly one page, no?
03:24:15 <SamB_XP> well.
03:24:22 <SamB_XP> except that pesky header...
03:24:30 <quicksilver> mux: yeah, nice
03:25:03 <quicksilver> Anyhow, I'm pleased with how it all works. ON the train in today, I got a subthread producing dynamically better and better renderings of the current texture
03:25:05 <xelxebar> good night, guys.  thank you for all your help and putting up with all the quenhiotn
03:25:12 <quicksilver> while the main thread/GUI remains perfectly responsive
03:25:24 <xelxebar> questions*
03:25:40 <mux> quicksilver: still working on your chess-like 3D board game?
03:26:11 <quicksilver> mux: yes, but I got distracted by doing a procedural texture engine
03:27:09 <SamB_XP> um
03:27:09 <SamB_XP> okay...
03:28:30 <quicksilver> mux: limited train time each day and I end up writing whatever code feels cool at the time :)
03:31:30 <quicksilver> pjd: it was you I was babbling to about messing with the recursive references in a recursive type, wasn't it?
03:32:07 <pjd> quicksilver: i think so
03:32:35 <quicksilver> pjd: turns out it's called "datatypes as fixed-points of functors" and goes back at least as far as Lambek
03:32:45 <quicksilver> pjd: conor answered my email. I had a hunch he'd know about it :)
03:32:57 <pjd> quicksilver: ah, nice!
03:33:06 <quicksilver> pjd: He's dug up some references for me to read so I shall digest those when I have time.
03:34:43 <pjd> quicksilver: i don't suppose you can repeat those references?
03:34:45 <mux> quicksilver: I look forward playing this game :)
03:35:51 <EvilTerran> hm, is {# fun unsafe allegro_init as ^ -> `Bool' #} right for turning int allegro_init() into allegroInit :: IO Bool (return value inducating success/failure)?
03:36:33 * mux wouldn't know, he's been doing bare FFI only, without c2hs
03:37:24 <quicksilver> pjd: of course, one moment
03:37:44 <quicksilver> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/dgp.pdf
03:37:46 <lambdabot> http://tinyurl.com/2ghjbw
03:37:56 <quicksilver> http://www.cs.nott.ac.uk/~ctm/CJ.pdf
03:47:32 <qubit> hi room
03:48:20 <pjd> quicksilver: cool, thanks
03:49:43 <axm> @msg lambdabot @pl bl
03:49:44 <lambdabot> Not enough privileges
03:49:58 <axm> \msg lambdabot @pl bl
03:51:15 <qubit> I really need to get this solved, i need to copy id :: a -> a in the same way with the same type and smae result, but the catch, it has to be recursive, I think from a clue that I have to involve a prelude function in solution... im perplexed. the recursion has to happen in the body, and i cant define a new class..
03:54:04 <axm> i would try and help, but i really do not see the point to do a no-op with recursion? may it be a no-op recursion as well?
03:54:22 <qubit> i suppose
03:54:48 <DRMacIver> I think you've probably misparsed the question. Are you sure you're not supposed to define the identity function *for a particular type* recursively?
03:54:53 <qubit> it maust be a prelude funct that i can use
03:55:02 <DRMacIver> The question doesn't make much sense as it stands.
03:55:03 <qubit> nope
03:55:04 <Olathe> That's a very strange request.
03:55:05 <qubit> id
03:55:07 <qubit> same as
03:55:11 <qubit> recursivly
03:55:14 <qubit> i know
03:55:22 <qubit> my lecturer is a guru
03:55:35 <EvilTerran> or a nut
03:55:38 <quicksilver> this isn't guru, it's crossword puzzle
03:55:43 <quicksilver> no offense, i'm sure he's smart
03:55:50 <Olathe> > let id2 a = id3 5 a where id3 0 a = a; id3 n a = id3 (n - 1) a in id2 192
03:55:52 <quicksilver> guru is oleg :P
03:55:53 <qubit> http://www.cs.mu.oz.au/172/exercises/tourofprelude.html
03:55:54 <lambdabot> Title: A Tour of the Haskell Prelude
03:55:56 <EvilTerran> likewise. a lot of smart people are a bit barmy.
03:56:01 <lambdabot>  192
03:56:06 <qubit> he wrote it
03:56:08 <Olathe> There. Recursive id.
03:56:22 <EvilTerran> 11:52> c2hs Allegro.chs
03:56:22 <EvilTerran> 'cpp' is not recognized as an internal or external command,
03:56:22 <EvilTerran> operable program or batch file.
03:56:22 <EvilTerran> c2hs: Error during preprocessing custom header file
03:56:23 <qubit> hmmm, now
03:56:26 <EvilTerran> \o/
03:56:29 <qubit> what do you think?
03:56:41 <qubit> any one
03:57:22 <qubit> talked to him a few hours ago told me that i was on the right path with idrec :: a -> a
03:57:22 <qubit> idrec x = let _ = idrec x in x
03:57:23 <Olathe> @pl let id3 n a = if (n == 0) a else id3 (n - 1) a in id3
03:57:24 <lambdabot> (line 1, column 29):
03:57:24 <lambdabot> unexpected reserved word "else"
03:57:24 <lambdabot> expecting variable, "(", operator or "then"
03:57:36 <Olathe> @pl let id3 n a = if (n == 0) then a else id3 (n - 1) a in id3
03:57:36 <lambdabot> fix (ap (ap . if' . (0 ==)) . (. subtract 1))
03:57:40 <quicksilver> qubit: I think that if you're solving a puzzle to get a reward, it is your job to solve it.
03:57:44 <quicksilver> qubit: not #haskells
03:57:56 <Olathe> > let id2 = fix (ap (ap . if' . (0 ==)) . (. subtract 1)) 5 in id2 109
03:57:57 <lambdabot>   Not in scope: `if''
03:58:01 <Olathe> Bah.
03:58:02 <qubit> but he sent me an email that said i can use prelude funcitons ... which lkeads me to think that  i should use one
03:58:06 <Olathe> Bad @pl !
03:58:17 <qubit> np
03:58:22 <qubit> tnx
03:58:54 <qubit> i need the money qubit -> poor student
03:59:56 <qubit> hmm a prelude function that i can recurse over a -> a...
04:00:14 <EvilTerran> @djinn a -> a
04:00:14 <lambdabot> f a = a
04:00:22 <qubit> abs.... nope
04:00:31 <qubit> ah ha
04:00:35 <qubit> f a -> a
04:01:02 <axm> was the link supposed to lead to the original task definition?
04:01:03 <qubit> gmmm
04:01:05 <qubit> hmmm
04:01:12 <qubit> nope
04:01:21 <qubit> hangon
04:01:24 <quicksilver> you could do id a = f 100 a where f 0 a = a ; f n a = f (n-1) a
04:01:35 <quicksilver> that uses recursion in f
04:01:40 <quicksilver> and you can even change the amount ;P
04:01:42 <EvilTerran> you can't do anything useful to a value that you know nothing of the type of
04:01:53 <EvilTerran> except push it around without changing it or looking into it
04:01:54 <DRMacIver> You could define an Id type class with a single method id' : a -> a and define id recursively for each prelude type.
04:02:03 <EvilTerran> so there's no meaningful recursion to be done
04:02:15 <DRMacIver> That's the closest I can think to something that actually answers the question, but it's still idiotic. :)
04:02:40 <therp> evilterran: another options is to diverge, 'return' _|_. that's some kind of meaningful recursion, but not really imho
04:02:56 <EvilTerran> myid x = myid x?
04:03:02 <qubit> Challenge
04:03:02 <qubit> • Here is the identity function from the Prelude:
04:03:02 <qubit>      id :: a -> a
04:03:02 <qubit>      id x = x
04:03:02 <qubit> • Write a recursive version of this function. It must have the same type and
04:03:03 <qubit>   behaviour as the deﬁnition above.
04:03:05 <qubit> • First correct solution emailed to me will win a bookroom voucher.
04:03:22 <therp> imho there is no such function
04:03:27 <EvilTerran> he's taking the piss
04:03:30 <axm> maybe the solution might be just that
04:03:44 <quicksilver> my solution was recurisve
04:03:56 <quicksilver> in a useless way, obviously
04:04:01 <quicksilver> but what else could you do :P
04:04:22 <platypus> How does he define recursive in this context?
04:04:30 <EvilTerran> id' x = const id' x -- does this count as recursive?
04:05:00 <EvilTerran> it's a recursive *binding*, at least
04:07:14 <EvilTerran> ... i thought ghc came with a c preprocessor?
04:07:31 <therp> evilterran: add -cpp to the flags
04:07:49 <EvilTerran> flags to what? c2hs?
04:08:24 <therp> evilterran: ghc's C preprocessor is activated by adding -cpp. no idea how c2hs works sorry
04:09:17 <EvilTerran> "c2hs --cpp=ghc --cppopts=-cpp" seems to work. ish.
04:10:13 <fasta> Can anyone explain the rationale for the text rendering of the module dependency graph in case of a cycle? Why not just only show one cycle?
04:10:27 <EvilTerran> actually, no, that's a load of nonsense. never mind.
04:11:20 <qubit> the recursive property is within the body of the function, after the =, probably parrtern mathcing, the dude is a guru
04:11:49 <EvilTerran> you can't pattern-match on a value you know nothing about!
04:11:59 <pjd> qubit: i think the point of the challenge is demonstrating that you cannot structurally recurse on something if you don't know its structure
04:12:03 <qubit> i understand
04:12:09 <pjd> so it's designed to be impossible
04:12:11 <qubit> thats why i cant work it out 2
04:12:12 <qubit> !
04:12:18 <qubit> maybe
04:12:20 <fasta> Where is this challenge?
04:12:21 <qubit> maybe nit]
04:12:28 <qubit> i think the know how
04:12:31 <EvilTerran> as i said, the most sensible version i can think of is "id' x = const id' x"
04:12:51 <EvilTerran> it doesn't recurse at runtime, but it's recursive in the sense of having a self-referential definition
04:13:14 <therp> fix (const id)?
04:13:29 <qubit> trien id' : *** Term           : id'
04:13:30 <qubit> *** Type           : b -> a
04:13:30 <qubit> *** Does not match : a
04:13:30 <qubit> *** Because        : unification would give infinite type
04:14:02 <EvilTerran> sorry, that should be const x id'
04:14:18 * EvilTerran headdesks.
04:14:33 <qubit> k
04:15:01 <EvilTerran> ?type let id' = const x id' in id'
04:15:06 <lambdabot> Not in scope: `x'
04:15:11 <EvilTerran> ?type let id' x = const x id' in id'
04:15:13 <lambdabot> forall a. a -> a
04:15:26 <pjd> id' = flip const id'
04:15:31 <qubit> yes, works!
04:15:37 <therp> evilterran: but actually it's not really self-referential in the definition either. id' x = const x undefined would be ok too. so there is on reason why id' should be there
04:15:39 <qubit> indeeed
04:15:56 <pjd> qubit: it doesn't recurse, though
04:16:02 <qubit> it needs to be recursive
04:16:03 <EvilTerran> i know. it makes no less sense than anything else, though
04:16:15 <qubit> hmm nice 1
04:16:39 <pjd> qubit: which is impossible
04:16:42 <therp> i'm pretty sure there is no solution to this, when it comes to run-time recursion.
04:16:53 <EvilTerran> doesn't have a runtime penalty like facetiously recursing on an irrelevant int parameter
04:16:53 <qubit> ok
04:17:26 <pjd> qubit: you can only do irrelevant recursion, as with the int example
04:17:49 <quicksilver> therp: that is really self-referential
04:18:00 <qubit> thats ok
04:18:00 <quicksilver> therp: the fact that it never uses the self-reference is irrelevant
04:18:17 <qubit> its a trick question
04:18:20 <therp> quicksilver: by 'that' you mean id' x = const x id' ?
04:18:26 <EvilTerran> in lisp, you'd need letrec to write it, therefore it's recursive! :P
04:18:27 <qubit> i think
04:18:31 <quicksilver> therp: yes
04:18:38 <qubit> leterec?
04:18:43 <EvilTerran> @go letrec
04:18:47 <lambdabot> http://www.federated.com/~jim/schintro-v14/schintro_66.html
04:18:48 <lambdabot> Title: An Introduction to Scheme and its Implementation - Local Procedures and letrec
04:18:48 <qubit> whats dat?
04:18:56 <qubit> k
04:19:03 <EvilTerran> letrec is lisp's equivalent to let in haskell
04:19:11 <quicksilver> and ML too
04:19:22 <quicksilver> or, slightly variations on the name
04:19:28 <qubit> k
04:19:35 <qubit> tnx
04:19:43 <EvilTerran> in lisp, let bindings are non-recursive - you can't refer to foo in the definition of foo
04:19:45 <quicksilver> qubit: haskell is unusual in making everything 'potentially recursive' by default
04:19:59 <quicksilver> qubit: most other languages require you to flag that explicitly somehow
04:20:09 <qubit> bummer old sckool
04:20:11 <quicksilver> EvilTerran: unless you have an earlier foo in scope ;(
04:20:28 <therp> quicksilver: yes, it is self-referential, but if you spell that out (statically) by using the type of const, it's not really self-referential. just as "x=1+(x-x)" isn't really a recursive definition.
04:20:33 <qubit> higher level language haskell?
04:20:44 <EvilTerran> well, yes
04:20:49 <qubit> nice
04:20:55 <qubit> just what we want?
04:20:57 <qubit> yesQ!
04:21:01 <qubit> A!
04:21:05 <quicksilver> EvilTerran: I've written (broken) ML programs where what was intended to be a recursive foo ended up to be a reference to an earlier foo in the file
04:21:12 <quicksilver> EvilTerran: very very annoying :P
04:21:14 <EvilTerran> ouchie
04:22:12 <qubit> youch
04:25:40 <idnar> :t fix
04:25:42 <lambdabot> forall a. (a -> a) -> a
04:25:49 <therp> :t (\a -> const a (a + 1))
04:25:51 <lambdabot> forall a. (Num a) => a -> a
04:25:59 <therp> that's disappointing
04:26:18 <idnar> :fix $ const id 5
04:26:23 <idnar> > fix $ const id 5
04:26:24 <lambdabot>  Exception: <<loop>>
04:26:25 <pjd> :t \a -> const a undefined
04:26:26 <lambdabot> forall a. a -> a
04:26:35 <therp> shouldn't we be able to remove the type class here?
04:26:50 <therp> > fix (const id) 5
04:26:51 <lambdabot>  5
04:26:55 <Saizan> how much work is writing a non-optimizing h98 interpreter?
04:26:58 <idnar> er yeah, that
04:27:03 <idnar> although that's not much of a recursion
04:27:25 <therp> same as evilterran's version.
04:27:43 <ibid> Saizan: first guess, a couple of weeks (depends on experience and skill, of course)
04:27:51 <therp> the challenge of the challenge is to find out that it's impossible to solve
04:28:10 <quicksilver> Saizan: the parser alone is worth a few days :)
04:28:11 <fasta> Saizan: I guess about 15KLOC for complete correctness with some usability.
04:28:32 <fasta> Saizan: which would bring it more to a year or so
04:28:33 <therp> saizan: in what kind of language?
04:28:39 <quicksilver> I would be very surprised if it's as much as 15KLOC for a simple graph-reduction interpreter
04:28:44 <Saizan> therp: prolog :)
04:28:49 <ibid> Saizan: that's if you write your own haskell parser etc and don't steal it from somewhere else
04:28:56 <fasta> Saizan: (assuming Haskell)
04:29:06 <quicksilver> therp: no of course not
04:29:25 <qubit> whATS 15KLOC?
04:29:27 <quicksilver> therp: type inference doesn't know about semantics, it's a static process
04:29:32 <quicksilver> qubit: 15,000 lines of code
04:29:38 <qubit> nice...
04:29:40 <qubit> hmm
04:29:41 <therp> quicksilver: that's not entirely correct
04:29:47 <qubit> not really
04:29:52 <therp> quicksilver: as we see from "theorems for free" from wadler
04:29:54 <fasta> quicksilver: that figure is slightly based on Helium.
04:29:55 <Saizan> mmh maybe i should pick something else as a project for this course..
04:30:06 <ac> out of wxFruit, Phooey, Grapefruit, FrankTK, and FG
04:30:10 <ac> which one is the best?
04:30:21 <quicksilver> therp: theorems for free shows what you can learn from paramteric polymorphism. It doesn't change type inference.
04:30:22 <therp> quicksilver: and from the type of const :: a -> b -> a we should be able to judge that the second argument to const will never have an effect on its type
04:30:24 <qubit> helium uis better than hydrogen for flying a led zepplin'
04:30:46 <fasta> ac: just use GKT2HS for an actual application.
04:30:54 <fasta> GTK2HS*
04:31:04 <qubit> tnx therp
04:31:04 <ac> fasta: I am using it, and it's a little ugly. It certainly works though
04:31:29 <ac> fasta: I thought it would be interesting to try out one of the many more functional and declarative style GUI libraries
04:31:30 <fasta> ac: you are using what?
04:31:35 <ac> fasta: gtk2hs
04:31:49 <fasta> ac: it isn't since it's all academic work(in the negative sense of the word)
04:31:57 <xelxebar> is there a more effecient way of writing this: foo ('b':'a':'r':cc) = [('\n', cc)]?
04:32:10 <ac> fasta: so you're saying none of them are practical to use?
04:32:14 <fasta> ac: unless you want to do a "research project".
04:32:23 <ac> fasta: My only requirements are basic widgets and a canvas
04:32:25 <xelxebar> i tried foo ("bar"++cc), but that didn't work out
04:32:25 <fasta> ac: yes, since nobody has demonstrated that they work.
04:32:26 <therp> quicksilver: we could change type inference to take into account this kind of information. constraints generated from "b" (as in const :: a -> b -> a) should be discarded. they are not meaningful and we can guarantee statically that b will never be evaluated. hm (unless seq is involved which should be forbidden anyway!)
04:32:37 <therp> quicksilver: ok my argument falls apart in the face of seq.
04:32:44 <quicksilver> therp: actually it doesn't :P
04:32:54 <fasta> ac: e.g. there is no Azureus written with those fantastic declarative GUI tool-kits.
04:33:07 <ac> fasta: well that doesn't bother me because mainly I'm just fooling around
04:33:10 <quicksilver> therp: ah, yes it does.
04:33:21 <fasta> ac: in that case, probably the newest one.
04:33:32 <fasta> ac: Pho<something>
04:33:41 <ac> Phooey
04:34:07 <ac> fasta: are you saying they're all spirritually decended from one another?
04:34:12 <fasta> ac: no
04:34:20 <iguana_> quick MTL question
04:34:28 <fasta> iguana_: just ask
04:34:34 <iguana_> if I have a computation that generates a list as a side effect
04:34:39 <iguana_> should I use State or Writer?
04:34:51 <fasta> iguana_: if you don't read anything, a writer.
04:35:18 <fasta> iguana_: OTOH, it doesn't really matter that much.
04:35:26 <iguana_> fasta: well, there's one difference
04:35:39 <fasta> iguana_: most of the time later on you find that you did need some extra read state too.
04:35:47 <iguana_> the writer appends to the list which
04:35:53 <iguana_> is inefficient
04:36:03 <iguana_> while with the state I can do  modify (newitem:)
04:36:07 <fasta> iguana_: that's why you have difference lists...
04:36:08 <iguana_> and reverse the list once at the end
04:36:28 <fasta> iguana_: and you can do that same with the writer, btw.
04:36:34 <iguana_> difference lists?
04:36:49 <fasta> iguana_: google knows
04:36:57 <iguana_> and how to do it with the writer?
04:37:10 <fasta> iguana_: there's even a library on Hackage for it named DList, IIRC
04:37:53 <SamB_XP> yeah. I made it work with Writer ;-)
04:37:56 <fasta> iguana_: well, you just write to it in the same way as for state and when you extract the transscript you reverse it.
04:37:58 <ac> Is there a phooey API reference somewhere? All I can find is a little overview on the haskellwiki
04:38:14 <fasta> ac: yes, on the same page in some link.
04:38:20 <fasta> ac: unless it's already dead
04:38:30 <iguana_> fasta: but how do I "write" to it differently? all I can do is "tell [item]"
04:38:57 <fasta> iguana_: you can just do tell item
04:39:04 <SamB_XP> fasta: eh?
04:39:08 <SamB_XP> no you can't
04:39:22 <fasta> Ok, let me look at the API docs.
04:40:03 <SamB_XP> tell (DL.singleton item) would probably work
04:40:11 <fasta> iguana_: right, tell [item]
04:40:49 <fasta> iguana_: then monoid instance is ++, so it will be [newvalue] ++ oldvalue_long_list
04:40:52 <SamB_XP> anyway you probably should wrap that up so you don't have to repeat it everywhere, which also makes changing representations a snap
04:40:57 <xelxebar> :t foo ('b':'a':'r':s) = [('\n', s)]
04:40:57 <xelxebar> > :t foo ('b':'a':'r':s) = [('\n', s)]
04:40:58 <lambdabot>  Parse error
04:40:59 <lambdabot> parse error on input `='
04:41:00 <xelxebar> > foo ('b':'a':'r':s) = [('\n', s)] :: String -> ReadS Char
04:41:00 <lambdabot>  Parse error
04:41:06 <fasta> iguana_: that runs in time proportional to the size of newvalue.
04:41:06 <xelxebar> > 5+5
04:41:06 <SamB_XP> fasta: eh?
04:41:08 <iguana_> won't it be oldvalue ++ [newvalue] ?
04:41:10 <lambdabot>  10
04:41:31 <SamB_XP> oldvalue ++ newvalue
04:41:36 <fasta> iguana_: right, it is, just ignore me :)
04:41:37 <quicksilver> iguana_: you don't have to tell [item]
04:41:37 <SamB_XP> I bet
04:41:44 <SamB_XP> I'm not sure though
04:41:44 <quicksilver> iguana_: you can tell <any monoid>
04:41:56 <SamB_XP> hmm.
04:42:01 <quicksilver> @instances Monoid
04:42:02 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
04:42:05 <SamB_XP> I guess it associates the other way though?
04:42:15 <iguana_> quicksilver: so :)
04:42:16 <SamB_XP> hmm...
04:42:28 <quicksilver> iguana_: so use ([a] -> [a]) as your monoid
04:42:28 <SamB_XP> I guess it depends on how you do it...
04:42:33 <quicksilver> iguana_: tell (item:)
04:42:34 <fasta> iguana_: ok, so using [] as monoid is not going to work.
04:42:40 <xelxebar> :t foo ('b':'a':'r':t) = [('\n', t)]
04:42:41 <lambdabot> parse error on input `='
04:42:45 <SamB_XP> quicksilver: that monoid is gone now
04:42:52 <fasta> iguana_: just use DList (which is what quicksilver also says)
04:43:00 <fasta> iguana_: another option is to use Data.Sequence
04:43:10 <SamB_XP> quicksilver: which is why I had to make DList a newtype
04:43:15 <quicksilver> SamB_XP:: tell (Endo (item:))
04:43:19 <quicksilver> SamB_XP: then?
04:43:23 <SamB_XP> quicksilver: that gets ugly :-(
04:43:29 <quicksilver> not all that ugly
04:43:43 <SamB_XP> well, DList is prettier IMO, anyway
04:43:49 <iguana_> I get the impression though that just using the State will be easiest
04:43:54 <quicksilver> mytell i = tell . Endo $ (i:)
04:43:56 <iguana_> (or is it worse, performance-wise?)
04:43:58 <SamB_XP> same representation though
04:44:03 <quicksilver> iguana_: don't use state! be strong!
04:44:09 <quicksilver> iguana_: use the right type for what you're doing
04:44:11 <SamB_XP> iguana_: writer is fun
04:44:16 <iguana_> lol
04:44:32 <SamB_XP> state is good when you actually wanted state
04:44:47 <SamB_XP> sometimes you want all three, so there is RWS and RWST
04:44:50 <fasta> Before you know it you use MyT (ContT (WriterT (ST :)
04:45:15 <quicksilver> iguana_: use either Endo or Seq, if you care about performance
04:45:15 <iguana_> @hoogle Endo
04:45:16 <lambdabot> System.Win32.File.c_SetEndOfFile :: HANDLE -> IO Bool
04:45:16 <lambdabot> System.Win32.File.setEndOfFile :: HANDLE -> IO ()
04:45:24 <iguana_> hm
04:45:28 <iguana_> where is Endo?
04:45:31 <quicksilver> iguana_: both perfectly respectable monads
04:45:31 <SamB_XP> quicksilver: shouldn't DList perform well too?
04:45:35 <quicksilver> maybe Seq is simplest
04:45:42 <quicksilver> SamB_XP: yes, of course, but isnt it just Endo?
04:45:51 <quicksilver> (when viewed as a monoid)
04:45:58 <SamB_XP> quicksilver: essentially
04:46:08 <SamB_XP> but it has a nicer interface
04:46:09 <iguana_> so I use Data.Sequence
04:46:17 <quicksilver> iguana_: Data.Monoid
04:46:20 <fasta> iguana_: that costs you a constant factor of 14
04:46:31 <quicksilver> iguana_: that includes most of the random instances
04:46:32 <fasta> iguana_: when compared to reversing in State
04:46:37 <SamB_XP> DList has O(1) appends
04:47:09 <iguana_> why 14?
04:47:14 <fasta> iguana_: well, on my machine.
04:47:19 <SamB_XP> fasta: 14 what/what?
04:47:31 <iguana_> ah
04:47:32 <fasta> SamB_XP: time units
04:47:48 <mux> I soemtimes think that main shouldn't be just IO (), but something like type IOEHandles = (Handle,Handle,Handle); and main :: ReaderT IOEHandles (IO ())
04:47:55 <SamB_XP> what time units?
04:48:08 <mux> there are a few more things than stdin/out/err that could go there
04:48:16 <fasta> SamB_XP: what part of constant factor do you not understand?
04:48:24 <iguana_> btw, how do you return a exit status if main is IO ()?
04:48:29 <SamB_XP> mux: hmm, someone has expressed a similar opinion about std{in,out,err}
04:48:47 <SamB_XP> @hoogle ExitStatus
04:48:47 <lambdabot> No matches found
04:48:50 <SamB_XP> @hoogle Exit
04:48:50 <lambdabot> System.Exit :: module
04:48:50 <lambdabot> Control.Exception.ExitException :: ExitCode -> Exception
04:48:50 <lambdabot> System.Exit.ExitFailure :: Int -> ExitCode
04:49:19 <SamB_XP> @hoogle ExitCode -> IO ()
04:49:19 <lambdabot> No matches, try a more general search
04:49:24 <SamB_XP> @hoogle ExitCode -> a
04:49:24 <lambdabot> No matches, try a more general search
04:49:31 <SamB_XP> @hoogle exit
04:49:32 <lambdabot> System.Exit :: module
04:49:32 <lambdabot> System.exitFailure :: IO a
04:49:33 <lambdabot> System.exitWith :: ExitCode -> IO a
04:49:35 <fasta> SamB_XP: do you understand already?
04:49:40 <iguana_> ah, exitWith
04:49:41 <ToRA> @type System.exitWith
04:49:43 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
04:49:45 <mux> SamB_XP: I think an "augmented" monad for main would be both convenient, and more consistent
04:50:07 <SamB_XP> fasta: I don't understand how you can have a constant factor with no real units at all
04:50:40 <quicksilver> SamB_XP: if code using one method takes 1 sec, code using the other will take 14 * 1 sec = 14 seconds
04:50:42 <fasta> SamB_XP: if I see that algorithm X is 5 times faster than algorithm Y, you do not need units.
04:50:42 <SamB_XP> iguana_: so exitWith (ExitFailure n)
04:50:47 <SamB_XP> quicksilver: ah.
04:50:51 <fasta> SamB_XP: say*
04:50:52 <quicksilver> SamB_XP: constant factors are unitless by nature
04:50:57 <SamB_XP> a constant factor ratio
04:50:59 <mux> and then we can have stdin = asks (\(x,_,_) -> x), stdout = asks (\(_,x,_) -> x) etc
04:51:09 <SamB_XP> against a baseline
04:51:24 <quicksilver> mux: it's an interesting point but it's just one small thing
04:51:29 <mux> right
04:51:30 <quicksilver> mux: cos IO has all sorts of hidden state like that
04:51:38 <mux> true
04:51:41 <quicksilver> mux: how far along that path is it comfortable to go? :)
04:51:48 <mux> I'm not sure :)
04:52:24 <quicksilver> in a sense, stdin and stdout are writeable too
04:52:26 <SamB_XP> well, before it has been said that it would be really nice to be able to have a certain part of the program run with stdin/out/err redirected easily...
04:52:30 <quicksilver> depending what you think a Handle is
04:52:47 <SamB_XP> quicksilver: stdout is supposed to be writeable...
04:52:53 <quicksilver> SamB_XP: the handle, not the file :)
04:52:57 <mux> well the Handle's themselves aren't writable though
04:53:00 <quicksilver> they are
04:53:03 <quicksilver> you can re-open them
04:53:06 <quicksilver> point them to another file
04:53:11 <quicksilver> in a sense that's writing
04:53:13 <mux> oh, you meant close() dup2() etc
04:53:15 <quicksilver> in another sense it isn't
04:53:18 <mux> good point
04:53:24 <quicksilver> depending what abstraction level you think at
04:53:31 <quicksilver> in a sense stdout is actually just the constant '1'
04:53:35 <quicksilver> stdin is '0'
04:53:40 <quicksilver> and stderr is '2' :)
04:53:42 <mux> or just STDOUT_FILENO, more correctly =)
04:53:50 <SamB_XP> it would really be nice to be able to redirect one or another temporarily
04:54:01 <SamB_XP> but I guess that wouldn't be very threadsafe
04:54:34 <SamB_XP> not unless stdin/out/err are thread-local. which they aren't...
04:56:29 <quicksilver> well I think that would be the programmer's problem, to be honest
04:56:44 <quicksilver> I see no reason not to support fdopen or rdreopen or whatever it's called
04:56:56 <quicksilver> but I can't see it in the standard libs I must admit
04:57:03 <quicksilver> perhaps it's not a portable notion?
04:57:37 <mux> at least freopen() is in the C standard
04:57:51 <quicksilver> on the other hand, it's not hard to make your 'subaction' take three parameters :)
04:57:56 <quicksilver> much like mux's suggested type
04:58:04 <quicksilver> and just initialise them correctly at the top level
04:58:20 <quicksilver> and run subactions with parameters other than stdin stdout stderr if you choose to...
04:58:39 <mux> there's room for thought here
04:58:48 <fasta> If you are in a directory Foo/Bar. How do _you_ name the modules in that directory? Foo.Bar.Baz? Or just Baz? ByteStrings uses FQN's AFAIK.
04:59:06 <quicksilver> fasta: the normal answer is Foo.Bar.Baz
04:59:19 <quicksilver> fasta: so Baz.hs in Foo/Bar is "module Foo.Bar.Baz where"
04:59:26 <SamB_XP> this isn't Python, you know...
04:59:46 <quicksilver> fasta: you dont *have* to do it that way, but it helps ghc find the right file at the right time if you do.
05:01:10 <quicksilver> another obvious choice is : lib1/Foo/Bar.hs being Foo.Bar, lib2/Foo/Baz.hs being Foo.Baz and then run ghc with -Ilib1 -Ilib2
05:01:16 <quicksilver> at least, I thin I got that right
05:01:44 <fasta> One semantic change requires the refactoring of 10 modules. (only because there is no mutual recursion)
05:01:52 <fasta> Not good...
05:02:40 <SamB_XP> fasta: yeah
05:03:08 <fasta> Laundry lists of imports also make me think: why not just have everything there by default? (See Smalltalk)
05:05:15 <SamB_XP> I'm more like "why doesn't Smalltalk have namespaces?"
05:06:22 <fasta> SamB_XP: I am more like: who cares about '.' in names having special meaning in the minds of programmers?
05:07:12 <fasta> SamB_XP: What's the technical difference between import Foo.Bar.Zork and Foo.Bar.Zork (where in the latter case it's merely a convention)
05:07:23 <fasta> ?
05:08:03 <SamB_XP> hmm?
05:08:44 <fasta> The former case is Haskell's system, the latter case is an imaginary system in which one also can use . in module names.
05:09:08 <fasta> It's not as if only a small piece of the name space is allocated to one party.
05:09:30 <fasta> There is no global naming mechanism, so hierarchical modules do not solve anything.
05:10:37 <Saizan> what would that solve?
05:12:23 <quicksilver> fasta: erm, we *are* in the latter case
05:12:30 <quicksilver> fasta: it is merely a convention
05:12:43 <fasta> quicksilver: well, the '.' does mean something in GHC.
05:12:47 <quicksilver> fasta: it's just a convention that ghc --make uses to find files
05:12:58 <quicksilver> you don't need to respect the conventions of ghc --make
05:13:26 <quicksilver> you can call the files what you like, put them where you want, and then use a makefile to get them right place at right time, I believe
05:13:26 <fasta> quicksilver: ok, so given a only the current directory I can name a module in that directory Foo.Bar.Zork?
05:13:36 <quicksilver> I believe so
05:13:52 <fasta> quicksilver: oh, right a MakeFile (which is rather impractical)
05:14:08 <fasta> quicksilver: unless one writes a tool to generate the dependencies(e.g. hmake)
05:14:19 <quicksilver> quite
05:14:23 <quicksilver> it *is* only a convention
05:14:28 <quicksilver> but tools find the convention useful
05:15:38 <quicksilver> you're free to arrange the system differently (and pass flags to ghc so it still knows where to find stuff)
05:16:19 <quicksilver> having said that, I find it a useful convention :)
05:16:28 <quicksilver> but I would certain love to have whole-project refactoring tools
05:19:34 <axm> > let out = foldr (out2) (return ())::[String]->IO(); out2 a b = (((>>).print) a b) >> putStrLn [] in out ["b","l","a"]
05:19:35 <lambdabot>  <IO ()>
05:19:58 <axm> i thought this would emit newlines after each string, it emits 3 newlines after the strings. why?
05:20:53 <quicksilver> well think about out2
05:21:07 <quicksilver> and the way its result gets embedded into the next copy of itself
05:21:47 <quicksilver> :t foldr
05:21:49 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:22:06 <axm> @src foldr
05:22:06 <lambdabot> foldr k z xs = go xs
05:22:06 <lambdabot>     where go []     = z
05:22:06 <lambdabot>           go (y:ys) = y `k` go ys
05:22:11 <quicksilver> basically the 'last' version becomes the next 'b'
05:22:14 <quicksilver> in out2 a b
05:22:24 <quicksilver> and all the putStrLns pile up to the right of the b
05:22:42 <tibbe> @seen dons
05:22:42 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 3h 8m 13s ago.
05:22:51 <quicksilver> the second interation looks like this, for example:
05:23:04 <tibbe> anyone have the date of a good ghc 6.8 build?
05:23:13 <tibbe> the ones I tried all fails to compile
05:23:15 <quicksilver> (((>>).print) a ((((>>).print) a b) >> putStrLn []) ) >> putStrLn []
05:23:33 <quicksilver> axm: does that help? you see how the putStrLns are piling up on the right?
05:23:47 <axm> gimme a minute to overcome my misconception
05:24:34 <iguana_> hah, now I've ended up with RWS
05:25:12 <iguana_> actually RWST Error :)
05:26:15 <ToRA> tibbe: 20070919 is what i'm currently using
05:26:35 <tibbe> ToRA: compiled with the extra libs?
05:26:39 <ToRA> tibbe: yeah
05:26:42 <tibbe> great
05:27:01 <quicksilver> axm: incidentally, I personally wouldn't write "((>>).print) a b". I woudl write "print a >> b" :)
05:28:52 <EvilTerran> isn't that mapM_ print, anyway?
05:29:18 <quicksilver> well he's putting in some extra newlines
05:29:32 <quicksilver> but I imagine his goal is learning rather than acheiving, if you see what i meant
05:29:39 <EvilTerran> yeah
05:30:52 <tibbe> @src foldr
05:30:52 <lambdabot> foldr k z xs = go xs
05:30:52 <lambdabot>     where go []     = z
05:30:52 <lambdabot>           go (y:ys) = y `k` go ys
05:31:12 <tibbe> can't the compiler figure out the specialization on its own?
05:31:19 <tibbe> i.e. write "go"
05:31:42 <quicksilver> not sure what you mean about specialization in this context?
05:32:40 <tibbe> so would the definition of foldr with go instead of recursively calling foldr be more efficient in say ghc?
05:32:49 <quicksilver> yes, it is
05:32:51 <tibbe> save some parameter passing
05:32:56 <quicksilver> no, not for that reason
05:33:00 <tibbe> oh
05:33:02 <tibbe> why?
05:33:11 <EvilTerran> it improves sharing. it's not a specialisation as such, though.
05:33:14 <quicksilver> tehre's no difference between an explicit parameter and once reference in a closure
05:33:19 <axm> quicksilver, got it thx
05:33:22 <quicksilver> they're both a pointer
05:33:24 <EvilTerran> wrong terminology
05:33:35 <quicksilver> the reason for 'go' is to hide the recursion
05:33:43 <quicksilver> because the inliner won't inline recursive functions
05:33:47 <quicksilver> but it will inline that :)
05:33:54 <quicksilver> at least, I think that's the reason
05:33:57 <tibbe> but go is recursive,, no?
05:34:03 <quicksilver> yes, but foldr isn't
05:34:10 <tibbe> right
05:34:14 <quicksilver> so all of foldr gets inlined (including the recursive body of go)
05:34:16 <tibbe> so it will inline what exactly?
05:34:24 <tibbe> hmm
05:34:35 <quicksilver> it's a hack around a particular optimizer peculiarity
05:34:37 <tibbe> why couldn't a recursive foldr get inlined if go gets inlined?
05:35:08 <quicksilver> as I understand it, go isn't being inlined
05:35:10 <ac> if I was to upgrade ghc6.6 to get type families, should I upgrade to 6.7 or 6.9?
05:35:18 <quicksilver> 'inlining' is replacing the call site with the body
05:35:22 <ac> is 6.9 unstable in any way?
05:35:39 <quicksilver> but I don't claim to be a ghc optimisation expert :)
05:36:54 <tibbe> quicksilver: ok, but it sounds like very little gets inlined
05:37:07 <ac> doh. 6.8 is in the stable folder. that sounds like the appropriate version
05:37:10 <tibbe> basically a call to go without one parameter that foldr has
05:37:25 <tibbe> anyway, I have to go to german class
05:37:31 <tibbe> prepare for freiburg tomorrow ;)
05:37:59 <lispnik> hello
05:38:49 <lispnerd> I'm having a heck of a time understanding monands
05:38:59 <axm> bring it on ;)
05:40:41 <lispnerd> so basically, they are a way to force strict evaluation by chaining expressions together?
05:40:50 <axm> what helped me is to look at the types. >>= would be the basic function to take a value out of a container resembling a special context (the "monad") and pass it to the following function that makes a monad of the same type from that value
05:40:55 <quicksilver> lispnerd: hmm, not really.
05:41:10 <quicksilver> lispnerd: it happens that some monads have a >>= which enforces some kind of strictness
05:41:17 <quicksilver> lispnerd: but strictness isn't really the 'essence'
05:41:32 <ac> lispnerd: I _think_ that forcing strict evaluation is just one use of monads
05:41:45 <axm> another example of tat pattern would be managing state
05:41:47 <tibbe> lispnerd: you could have invented monads helped me a bit
05:41:47 <ac> nm. quicksilver beat me
05:41:49 <matthew-_> it's just some functions that tend to be used to sequence values where the values are themselves computations
05:41:51 <tibbe> lispnerd: google it
05:42:00 <quicksilver> the essence is about encapsulating behaviour, especially state and side-effects
05:42:07 <therp> lispnerd: probably you meant "the way to force sequence is by chaining together expressions." then that's true
05:42:47 <therp> (one question about monads and the channel becomes alive :))
05:43:06 <matthew-_> therp: heh, yeah, we're all practised on this one!
05:43:25 <axm> was confusing enough at first
05:44:16 <DRMacIver> matthew-_: And eager to show off the fact. ;)
05:44:23 <lispnerd> I'm checking out "you could have invented monads", any other links or google terms you guys could recommend?
05:44:55 <ToRA> dunno if it was just me, but the thing that made monads click for me was the introduction to one of the arrows papers :)
05:45:01 <therp> lispnerd: http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
05:45:02 <lambdabot> Title: Wadler: Monads
05:45:28 <quicksilver> lispnerd: http://www.haskell.org/haskellwiki/Monads_as_computation
05:45:30 <lambdabot> Title: Monads as computation - HaskellWiki
05:45:45 <lispnerd> monads, at the moment, with my limited understanding a monad is a nebulous concept that is meant to allow you to step out of the pureness of haskell and do things imperatively for a bit
05:46:03 <quicksilver> that's true up to a point.
05:46:10 <lispnerd> thing is, I'm trying to resolve some of that nebulousness
05:46:10 <quicksilver> but you actually never do step out of the pureness
05:46:23 <axm> the first stanzas here for a general definition: http://www.linuxjournal.com/comment/reply/8850
05:46:24 <lambdabot> Title: Add new comment | Linux Journal
05:46:30 <scook0> that's true of some, but not all monads
05:46:32 <quicksilver> more, monads are a structure which enable you to describe apparently imperative stuff in a pure way
05:46:49 <quicksilver> lispnerd: I strongly recommend 'monads as computation' which I just pasted
05:47:08 <lispnerd> great, thanks guys
05:47:15 <quicksilver> If you want more monad tutorials than you can shake a stick at, and also some historical background, check out http://www.haskell.org/haskellwiki/Monad_tutorials_timeline
05:47:16 <therp> lispnerd: monads are more general then that. it's a "mathematical" abstract construction that can be filled with an implementation serving one purpose or another (State monad to maintain state, Writer monad to give you output, Reader monad to give you a "monad global" environment, Continuation monad to give you continuations)
05:47:17 <lambdabot> Title: Monad tutorials timeline - HaskellWiki
05:47:27 <ToRA> lispnerd: section 2 of http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf is actually a very good introduction
05:47:44 <ToRA> lispnerd: (just ignore the rest of the 'arrowsy' stuff for the moment) ;)
05:47:50 <ac> lambdabot should have chat fascilities for explaining monads :)
05:48:05 <therp> ac: yes, an eliza module for monad questions
05:48:07 <therp> :)
05:48:10 <ac> exactly
05:48:25 <scook0> @vixen What are monads?
05:48:25 <lambdabot> i think you know the answer to that one, silly
05:48:28 <ac> it probably would have/will help me
05:48:39 <scook0> amazing!
05:49:00 <quicksilver> @vixen how should we explain monads to lispnerd?
05:49:00 <lambdabot> i dunno how so, it's just so
05:53:11 <EvilTerran> hm... when i try to give c2hs the -t option, it breaks with the error "c2hs: does not exist". whaa?
05:53:41 <quicksilver> EvilTerran: it's having an existential crisis
05:53:47 <quicksilver> EvilTerran: probably it needs absinthe
05:53:57 <EvilTerran> is that on hackage?
05:53:58 <EvilTerran> ;)
05:54:23 <EvilTerran> {-# LANGUAGE ExistentialCrisis #-}
05:57:29 <EvilTerran> -t . works, but -t <anything else> doesn't seem to
05:58:11 <EvilTerran> i'm guessing it means the folder doesn't exist, but it abundantly clearly *does*
05:59:11 <EvilTerran> aha! gotta make matching subfolders in the output directory to go with the folder i'm working from in the input directory
06:12:18 <fasta> What's a meta-circular interpreter according to #haskell(references to wikipedia are forbidden)?
06:12:45 <DRMacIver> Isn't it just an interpreter written in the language it interprets?
06:12:53 <fasta> DRMacIver: no
06:12:57 <ac> there's more to it than that in my understanding
06:12:58 <DRMacIver> ok.
06:14:06 <fasta> Of all the examples I found of meta-circular interpreters it seems that the feature that makes them meta-circular is that large pieces of functionality of the interpreter are handled by delegating to the host-interpreter in a lot of cases.
06:14:09 <ac> The key I think is that the language the meta-circular interpreter interprets represents the code being interprented in itself
06:14:53 <EvilTerran> "GenBind.applyBin: Not yet implemented operator in constant expression."
06:15:05 <fasta> EvilTerran: TH?
06:15:09 <EvilTerran> okay, c2hs is nice, but its error messages leave something to be desired.
06:15:32 <EvilTerran> c2hs, fasta. trying to use an {# enum #} hook
06:17:07 <EvilTerran> (i've narrowed it down to that by commenting/uncommenting bits)
06:18:08 <ac> fasta: I think your description is as clear as it gets. I don't think it's a very well defined concept
06:19:10 <fasta> Often people include that it needs to be homonomionic(or something cannot be bothered to lookup the real word).
06:19:40 <ac> oh yes, that's what I was describing in my original response
06:20:12 <fasta> But I haven't seen a clear written explanation of that by anyone.
06:20:18 <EvilTerran> ah, it seems to be trouble with getting values out of #defines
06:20:22 <ac> homoiconic, meaning the code is represented as a first class data structure
06:20:45 <ac> esentially it means "like lisp's eval"
06:21:48 <fasta> That implies that one could write  host-interpreter for Pascal with that feature.
06:22:09 <ac> just having eval is not enough, you need to have an eval that takes a structured type. You can add that feature to anly language, it's just a matter of efficiency
06:22:27 <ac> you simply embed the compiler in to the runtime
06:23:27 <ac> well, you embed the part that takes an AST as input
06:25:14 <quicksilver> 'homoiconic' means that programs are data
06:25:36 <quicksilver> more informally it's taken to mean that programs are a 'natural kind' of data, like other kinds of data in the language
06:25:46 <ac> quicksilver: I don't like that definition, because given that definition, only assembly programs are homoiconic
06:25:58 <quicksilver> i.e. in LISP programs are lists, and lists are a natural data type
06:26:26 <quicksilver> in a homoiconic language you can actualy inspect a function value and perform surgery on it before invoking it
06:26:31 <ac> quicksilver: in lisp programs are not lists. the original representation is a list, but its compiled during runtime and you have no idea what the original structure is
06:26:36 <quicksilver> (compiled LISPs often lost that ability)
06:26:49 <ac> er... right
06:27:29 <ac> I've never run accross a lisp system that maintains function's structure by default
06:28:06 <ac> in some implementations there is a compiled? predicate that will tell you if a given function is accessible or not
06:28:11 <puusorsa> http://www.news.com.au/perthnow/story/0,21598,22492511-5005375,00.html
06:28:14 <lambdabot> Title: The Right Brain vs Left Brain test | PerthNow, http://tinyurl.com/33va3f
06:28:53 <EvilTerran> puusorsa, #haskell-blah is for offtopic
06:29:00 <ac> AFAIK, homoiconicity is simply having a runtime interpreter available
06:29:16 <ac> s/K/U
06:29:43 <sieni> ac: isn't compiled-function-p part of cl or are you talking about something else?
06:30:01 <ac> uhm, I've never really used common lisp, just scheme
06:30:27 <ac> I thought that was standard, but I wasn't sure
06:31:06 <SamB_XP> I think CL implementations tend to keep the list representation around if you don't specifically ask for stuff to be compiled?
06:32:55 <sieni> depends on the implementation
06:33:04 <ac> SamB_XP: most likely is true with most implementations. I think I'm wrong... I have come accross a system that doesn't compile by default... emacs lisp I believe does that
06:33:19 <sieni> at least sbcl used to be such that it always compiled all functions
06:33:29 <SamB_XP> compiled how far?
06:34:05 <sieni> what do you mean how far?
06:34:08 <sieni> to native code
06:34:22 <EvilTerran> > let (<<) = shiftL; al_id [a,b,c,d] = (((a)<<24) .|. ((b)<<16) .|. ((c)<<8) .|. (d)) in al_id (map ord "SAFE")
06:34:24 <lambdabot>  1396786757
06:34:49 <EvilTerran> yuck yuck yuck. what were they thinking?!
06:35:19 <DRMacIver> ?
06:35:40 <EvilTerran> there's a #define AL_ID(a,b,c,d)     (((a)<<24) | ((b)<<16) | ((c)<<8) | (d))
06:35:41 <EvilTerran>  in this library i'm trying to bind to
06:36:10 <EvilTerran> and then #define GFX_SAFE AL_ID('S','A','F','E') elsewhere. and i'm trying to get that value out in c2hs.
06:36:33 <EvilTerran> but c2hs apparently can't cope with bitwise operations in {# enum #}s
06:36:40 <ttfh> couldn't you build something like that in scheme yourself? with macros, quoting, procedure? and eval?
06:37:16 <fasta> puusorsa: that's seriously cool. I can see them both, you? Go to #haskell-blah
06:38:24 <EvilTerran> fasta, puusorsa, btw, i've seen that several times before, and never associated with left/right-brain-ness. i think someone made that up. the only point of it that i know of is that it can seem to spin either way.
06:38:45 <fasta> EvilTerran: oh, well, I agree with that
06:38:48 <EvilTerran> someone's been creative with the truth in the interests of making it look more interesting than it is, IMO
06:38:52 <puusorsa> EvilTerran, that's offtopic, go to #haskell-blah
06:38:55 <puusorsa> :-p
06:39:01 <EvilTerran> you started it!
06:39:05 <EvilTerran> :P
06:39:06 <ac> ttfh: then everything would be ran inside eval and it would be terribly slow. Also, in many implementations of Scheme, the eval isn't complete (it doesn't eval modules and such things properly)
06:39:06 <fasta> puusorsa: we kick smartasses ;)
06:39:16 <EvilTerran> anyway, i'm off
06:39:26 <EvilTerran> .away
06:39:29 <EvilTerran> er
06:39:39 <quicksilver> ac: well in principle you can clearly compile but still keep the list rep around
06:39:51 <quicksilver> ac: and then 'invalidate' the compiled copy if the program changes the code
06:39:51 <ac> quicksilver: ah good point.
06:40:04 <quicksilver> ac: personally I don't think homoiconicity is that great, but...
06:40:12 <ac> quicksilver: you would need runtime incremental compiling though to make it all work nicely
06:40:28 <ac> quicksilver: yeah, it sounded fancy when I first heard the term, but I've come to the same conclusion
06:40:56 <ttfh> you could redefine define to make a pair of the compiled function and the original unevaluated lambda?
06:41:14 <ttfh> and then you would have to redefine apply as well
06:41:38 <hkBst> quicksilver: why not? How else are you gonna get supernice metaprogrammability?
06:43:05 <ac> fasta: I only see clockwise. Waaah
06:44:33 <ac> fasta: if I turn my head upside down I see it counterclockwise though ;)
06:44:52 <mrd> CL defines function-lambda-expression to obtain the original source if it is available
06:45:06 <mrd> emacs lisp is not CL
06:45:42 <ac> mrd: I never said emacs lisp is CL, just that it was "a lisp implementation"
06:45:56 <mrd> emacs lisp is an implementation of stallman's ego
06:46:36 <ttfh> quicksilver: how would you detect if the code for a function is changed?
06:47:41 <ac> ttfh: seems like you'd need some sort of type system for that.... right?
06:48:11 <ttfh> or redefine "set!"?
06:50:24 <ac> ttfh: seems to me that functions should be immutable
06:50:34 <ac> ttfh: then you can just forget about the problem
06:56:53 <quicksilver> ac: but that's the whole point of homoiconic :)
06:57:02 <quicksilver> ac: the point of homoiconic is runtime code generation and modification
06:57:11 <quicksilver> I'm not a particularly big fan of those techniques
06:57:17 <quicksilver> but, that is why homoiconic is cool...
06:59:02 <ac> quicksilver: that doesn't mean you have to make inpure modifications of existing functions... you can modify them, making new ones, then run those
07:05:16 <quicksilver> ac: oh, I see. Yes, that's fair enough.
07:05:27 <quicksilver> ac: I don't like code modification or mutability anyway :)
07:06:22 <ac> quicksilver: who needs 'em? :)
07:06:53 <ac> I have never ever come accross a case where I say "oh I need homoiconicity to solve this!"
07:07:05 <quicksilver> no, indeed not
07:07:11 <fasta> quicksilver: what's the difference between using set!(Scheme) in a module instead of modify(Haskell)?
07:07:28 <quicksilver> :t modify
07:07:33 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
07:07:42 <quicksilver> fasta: modify doesn't modify values
07:07:48 <quicksilver> fasta: it generates a new value based on an old one
07:08:03 <quicksilver> fasta: if unevaluated thunks somewhere link the old value in their closures
07:08:12 <quicksilver> then that isn't affected
07:08:30 <fasta> quicksilver: someone once implemented do notation in Scheme and it sure did _look_ the same.
07:08:51 * quicksilver nods
07:09:03 <quicksilver> it might look the same, but there is a big different
07:09:10 <quicksilver> set! lets you break stuff other code is relying on
07:09:24 <quicksilver> modify allows the type system to keep you sane
07:09:28 <fasta> If you have a module system there's little that can do wrong.
07:09:38 <fasta> go*
07:09:43 <Botje> (set! car (destroy-system))
07:09:56 <fasta> Botje: module system
07:10:16 <fasta> Botje: it would be a module local problem.
07:10:23 <quicksilver> I'm not going to argue about it. I've written plenty of programs in languages with mutability, and even been paid for them.
07:10:32 <quicksilver> I just hold the view that immutable languages are nicer.
07:10:42 <quicksilver> It is just an opinion.
07:10:50 <fasta> quicksilver: yeah, arguing is useless.
07:11:25 <fasta> If the mailing lists logs size divided by 10 would be new libraries we would have about everything in 5 years or so. :)
07:11:49 <quicksilver> I was thinking earlier on today that immutable values are one of the key things that makes threading so simple in haskell, though.
07:13:21 <iguana_> /U/part
07:15:09 <hkBst> quicksilver: homoiconicity is also about compile time metaprogrammablity, right?
07:18:40 <quicksilver> hkBst: yes, compile time and runt ime
07:19:01 <quicksilver> hkBst: typically homoiconic languages don't have a very strong compile time / run time distinction
07:19:27 <quicksilver> hkBst: they more-or-less have to "appear interpreted" even if, behind the scenes, they are compilde for optimisation.
07:19:57 <quicksilver> hkBst: I'm only really aware of two classes of homoiconic languages
07:20:19 <quicksilver> hkBst: (1) List-like/Stack-like languages : LISP, Joy, etc
07:20:34 <quicksilver> hkBst: (2) macro-expansion-like: TeX, some older similar systems
07:22:46 <twanvl> (almost) (3) Type Theory like: epigram, coq, etc.
07:23:18 <quicksilver> twanvl: epigram isn't homoiconic is it? You don't have access to the representation of the program...
07:24:43 <twanvl> true, but you do have the ability to work directly with the types of the program
07:24:59 <quicksilver> homoiconic at the type level but not the code level ? :)
07:24:59 <geocalc> rewriting-logic ?
07:25:06 <quicksilver> I'm not sure that counts as homo-iconic though
07:36:29 <byorgey> good morning, #haskell!
07:42:43 <Zevv> Is the 'chr()' function part of Prelude ?
07:42:59 <mux> nope, it's in Data.Char
07:43:05 <mux> you can use toEnum though, this one is in the Prelude
07:43:13 <Zevv> Ah, ok thank you. What is the easiest way to find out where things live ?
07:43:15 <mux> > toEnum 65 :: Char
07:43:17 <lambdabot>  'A'
07:43:20 <quicksilver> @index chr
07:43:20 <mux> Zevv: with lambdabot :-)
07:43:20 <lambdabot> Data.Char
07:43:21 <mux> @index chr
07:43:22 <Zevv> ah thanks
07:43:22 <lambdabot> Data.Char
07:43:25 <Zevv> mux: hehe
07:43:26 <mux> damn quicksilver :D
07:43:30 <quicksilver> Zevv: but it's often not too hard to guess
07:43:33 <mux> he's quick, as his name suggests =)
07:43:41 <quicksilver> Zevv: if it's about data type 'Foo', it is often in Data.Foo
07:43:45 <Zevv> quicksilver: ok, but it takes some time to know *what* to guess
07:43:49 <quicksilver> Zevv: or, Control.Food
07:43:53 <quicksilver> right :)
07:43:55 <Zevv> hehe
07:43:57 <quicksilver> asking here is pretty fast
07:43:58 <mux> true that
07:43:59 <quicksilver> ;)
07:44:00 <Zevv> anyway, thanks again
07:44:53 * mux wonders if he did enough perl commits today to be able to sleep during the rest of his work hours
07:45:06 * mux will toss in a few more for good measure
07:49:33 <tibbe> Zevv: www.haskell.org/hoogle
07:54:55 <ac> @hoogle CUInt
07:54:59 <lambdabot> Foreign.C.Types.CUInt :: data CUInt
07:55:34 <quicksilver> ac: that's a wrapper for 'unsigned int'
07:55:51 <quicksilver> ac: it's more haskell-like to use the exactly named data types though, like Word16 or Word32
07:55:58 <daniel_larsson> Anyone running HAppS as a daemon?
07:55:59 <quicksilver> if you have exact needs
07:58:19 <quicksilver> the 'unspecified precision' types thing was one of the biggest errors in K&R C, in my opinion
07:58:26 <ac> quicksilver: I'm getting compile errors from gtk2hs about CUInt not being in scope
07:58:40 <mux> quicksilver: oh yes
07:58:45 <mux> they caused so much suffering
07:58:54 <quicksilver> ac: from your own code, or from trying to compile gtk2hs iteslf?
07:58:59 <ac> I'm wondering where in the build system I add -P mtl, or something like that
07:59:02 <mux> that is, they are not bad per-self, it's bad that they weren't any fixed-width types before C99
07:59:06 <ac> from trying to compile gtk2hs
07:59:27 <quicksilver> ac: yuck. that should be a core type, you shouldn't need a package for that I thought
07:59:34 <quicksilver> dcoutts_: ping?
07:59:51 <quicksilver> mux: it's surprisingly rare that you really don't care how big your data type is
08:00:01 <quicksilver> mux: short throwaway programs, sure
08:00:06 <ac> hmm. I'm using ghc6.8
08:00:07 <quicksilver> mux: but most real programs need to care
08:00:21 <quicksilver> ac: and using Cabal? Which version of cabal?
08:00:39 <ac> cabal doesn't appear to be in my path...
08:00:48 <mux> quicksilver: back in the days, they thought it would help portability
08:01:02 <quicksilver> mux: yeah. They were wrong :P
08:01:06 <mux> but it only helps portability in the sense that the same code would compile, just it wouldn't work on the "other" archs =)
08:01:10 <quicksilver> mux: porting is one of the times you *really* need to care how long your ints are :)
08:01:15 <ac> cabal must be part of my haskell installation, if I have it
08:01:16 <mux> heh, yes
08:01:30 <quicksilver> mux: it is fine for short throwaway demo code
08:01:30 <daniel_larsson> shapr: ping
08:01:36 <quicksilver> mux: but that's just about all, IMO
08:01:58 <mux> quicksilver: on the other hand, with or without fixed-width types, there are sufficiently bad C coders to still fuck themselves up; storing pointers in ints or storing pointers in int32_t's doesn't change much :-)
08:02:09 <quicksilver> true enough :)
08:02:18 <quicksilver> that's the best thing about 64-bit machiines
08:02:18 <hpaste>  Zevv pasted "(no title)" at http://hpaste.org/3080
08:02:20 <quicksilver> they're not any more powerful
08:02:20 <mux> int is better cos it would at least work with ILP64 heh.
08:02:29 <mux> but not with LP64, obviously
08:02:30 <quicksilver> but at least they break stupid people's code :)
08:02:30 <Zevv> Can anybody shed some light on the error message and the cause in that snippet ?
08:03:08 <quicksilver> Zevv: (chr (round c))
08:03:28 <quicksilver> Zevv: you are passing hPutChar 3 arguments: 'fh' 'chr' and '(round c)'
08:03:28 <Zevv> hmm. back to the books for me then
08:03:34 <Zevv> Ah ofcourse
08:03:48 <Zevv> I still have some problems grokking the compilers messages
08:03:51 * quicksilver nods
08:04:06 <quicksilver> well the second arg to hPutChar should be a 'Char'
08:04:10 <quicksilver> but you're giving it 'chr'
08:04:14 <quicksilver> and 'chr :: Int -> Char'
08:04:17 <quicksilver> which is not a Char :)
08:04:22 <quicksilver> that's what the meassge is talking about
08:04:24 <Zevv> yes, now that you explain, it's clear
08:04:40 <quicksilver> if you have '->' in a type mismatch it's normally a bracketting error
08:04:47 <quicksilver> applying somethign to too many, or too few, arguments
08:04:48 <Zevv> that's good to remember
08:05:02 <Zevv> mental note
08:05:06 <Zevv> ok, thank you once again
08:05:09 <Zevv> and again and again
08:05:38 <quicksilver> not at all
08:13:57 <phlpp> hi
08:19:27 <JohnnyL> @total
08:19:28 <lambdabot> Unknown command, try @list
08:19:30 <JohnnyL> @list
08:19:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:19:54 <JohnnyL> @users
08:19:54 <lambdabot> Maximum users seen in #haskell: 420, currently: 371 (88.3%), active: 11 (3.0%)
08:21:19 <ac> gtk2hs is a beast to compile
08:21:43 <quicksilver> ac: I've not tried. The man you want is dcoutts_ but he's not around.
08:22:44 <quicksilver> ac: you could look around http://news.gmane.org/group/gmane.comp.lang.haskell.gtk2hs/last=/force_load=t
08:22:47 <lambdabot> Title: Gmane -- Gmane Loom: gmane.comp.lang.haskell.gtk2hs, http://tinyurl.com/24qxv2
08:22:51 <quicksilver> ac: and see if you learn anything
08:23:56 <shapr> daniel_larsson: You called?
08:26:26 <Mortez> umm how can I cons (:) a Maybe Integer to a list of Integers? e.g Maybe Integer : [Integer] , and I do know that in this case it is Just an Integer
08:27:01 <Zevv> interesting
08:27:05 <Zevv> I'm listening :)
08:27:25 <oerjan> Mortez: maybeToList x ++ l
08:27:32 <oerjan> works also if Nothing
08:27:48 <Zevv> @index maybeToList
08:27:48 <lambdabot> Data.Maybe
08:28:08 <quicksilver> Mortez: if you *know* something is just, you can always 'fromJust' it
08:28:16 <EvilTerran> ?hoogle Integral i => Int -> i
08:28:17 <lambdabot> Data.Graph.Inductive.Example.starM :: GraphM m gr => Int -> m (gr () ())
08:28:17 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
08:28:17 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
08:28:34 <quicksilver> Mortez: beware that your program will explode (and possibly your monitor) if it is Nothing though
08:28:35 <ac> quicksilver: a guy on that list suspects the problem has to do with cpphs. Somebody using gentoo has the problem too, but no clear cut solutions
08:28:35 <Saizan> > let f (Just x) = (x:); f Nothing = id in (f (Just 1) [1..3],f Nothing [1..3])
08:28:38 <lambdabot>  ([1,1,2,3],[1,2,3])
08:28:47 <quicksilver> EvilTerran: 'fromIntegral'
08:28:53 <EvilTerran> ?type fromIntegral
08:28:56 <lambdabot> forall a b. (Num b, Integral a) => a -> b
08:28:58 <tehgeekmeister> what does one do to make something like this more efficient: length $ replicateM 1000 [True,False]
08:29:07 <oerjan> quicksilver: don't forget the nose demons
08:29:13 <tehgeekmeister> it made my whole system freeze for a minute or two.
08:29:23 <Olathe> > length $ replicateM 1000 [True, False]
08:29:26 <lambdabot> Terminated
08:29:30 <EvilTerran> there isn't one ->Integral?
08:29:33 <Olathe> > length $ replicateM 5 [True, False]
08:29:35 <lambdabot>  32
08:29:36 <Mortez> quicksilver: thanks
08:29:42 <quicksilver> EvilTerran: it is, try it :P
08:29:53 <quicksilver> EvilTerran: all integrals are also Nums, and Int is Integral
08:30:01 <Olathe> > length $ replicateM 5 [True, False, True]
08:30:02 <lambdabot>  243
08:30:06 <quicksilver> EvilTerran: thus, "toIntegral" is also "fromIntegral" :)
08:30:11 <EvilTerran> ah, yes, i see. jolly good.
08:30:16 <EvilTerran> albeit disorientating.
08:30:21 <quicksilver> agreed
08:30:39 <Olathe> @pl \n xs -> (length xs)^n
08:30:40 <quicksilver> there are approximately two 'type-cast' functions for numbers
08:30:40 <lambdabot> flip ((^) . length)
08:30:47 <quicksilver> that is 'fromIntegral' and 'realToFrac'
08:30:49 <sieni> > (\x l -> case x of {Just n -> n : l}) (Just 8) [1,2,3]
08:30:51 <lambdabot>  [8,1,2,3]
08:30:57 <Olathe> tehgeekmeister: flip ((^) . length) 1000 [True, False]
08:31:00 <quicksilver> they cover more cases than you expect :)
08:31:05 <sieni> @src fromJust
08:31:05 <lambdabot> fromJust Nothing  = undefined
08:31:05 <lambdabot> fromJust (Just x) = x
08:31:11 <Olathe> > flip ((^) . length) 1000 [True, False]
08:31:13 <lambdabot>  0
08:31:17 <Olathe> Hmm...
08:31:19 <tehgeekmeister> that's not right.
08:31:22 <Olathe> > (flip ((^) . length)) 1000 [True, False]
08:31:23 <lambdabot>  0
08:31:48 <quicksilver> > (realToFrac pi) :: Rational
08:31:49 <lambdabot>  884279719003555%281474976710656
08:32:27 <tehgeekmeister> Olathe: what was that ^n at the end of that lambda meant to do?
08:32:33 <Olathe> to the power of n.
08:32:40 <tehgeekmeister> yes, of course
08:32:42 <Olathe> How do you get an Int to an Integer ?
08:32:44 <tehgeekmeister> but for what purpose?
08:32:57 <quicksilver> Olathe: fromIntegral
08:32:59 <oerjan> @pl \n l -> length l ^ n
08:32:59 <lambdabot> flip ((^) . length)
08:33:12 <Olathe> length $ replicateM 1000 [True,False] == (length [True, False])^1000
08:33:39 <Olathe> @pl \n xs -> (fromIntegral (length xs))^n::Integer
08:33:40 <lambdabot> flip ((^) . fromIntegral . length) . (:: Integer)
08:33:44 <oerjan> ah!
08:33:47 <Olathe> @pl \n xs -> (fromIntegral (length xs))^n
08:33:47 <lambdabot> flip ((^) . fromIntegral . length)
08:33:54 <quicksilver> tehgeekmeister: the fundamental problem with replicateM 1000 is that it has to keep the entire 999th list in memory
08:33:56 <Olathe> > flip ((^) . fromIntegral . length) 1000 [True, False]
08:33:58 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
08:34:01 <Olathe> There we go.
08:34:06 * EvilTerran sniggers as he realises he's just defined a function with the exact same name, type signature, and body as one in module C2HS
08:34:09 <quicksilver> tehgeekmeister: because it's going to build the 1000th list from the 999th
08:34:23 <quicksilver> tehgeekmeister: and, the 999th list is rather long :)
08:34:42 <quicksilver> tehgeekmeister: you can imagine a way to build that list lazily. but replicateM is not it.
08:34:44 <tehgeekmeister> quicksilver: yes, it is.  this is where custom solutions start to be useful, i'd assume?
08:34:50 <oerjan> :t genericLength
08:34:51 <quicksilver> right
08:34:52 <lambdabot> forall b i. (Num i) => [b] -> i
08:35:23 <quicksilver> replicateM, since it's just reusing the monad operations, is just repeatedly calling concatMap, and you get some pretty big intermediate lists
08:35:41 <quicksilver> you can devise something which produces 'all binary numbers of length 1000' efficiently if you choose, though
08:35:47 <Olathe> > (length . replicateM) 5 [True, False]
08:35:48 <lambdabot>  Couldn't match expected type `[a]'
08:35:53 <quicksilver> well, 'relatively' efficiently, at least :)
08:36:10 <Olathe> @pl \a xs -> length $ replicateM a xs
08:36:11 <lambdabot> (length .) . replicateM
08:36:12 <tehgeekmeister> as long as it doesn't freeze my whole system, i'd be happy.
08:36:37 <Olathe> How do you get the compiler to realize that (length .) . replicateM can be replaced with flip ((^) . fromIntegral . length) ?
08:37:04 <oerjan> Olathe: ghc rules?
08:37:13 <Olathe> Yeah.
08:38:24 <Olathe> Ahh, cool: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
08:38:26 <lambdabot> Title: 7.11. Rewrite rules, http://tinyurl.com/y7rk9g
08:38:35 <daniel_larsson> shapr: Hi, just had a slight HAppS problem. Trying to run my program as a daemon, but it wants stdin. Just wondering how this is generally handled
08:39:16 <Olathe> > length $ replicateM 0 []
08:39:17 <lambdabot>  1
08:39:24 <Olathe> orly
08:39:28 <Olathe> > replicateM 0 []
08:39:29 <lambdabot>  [[]]
08:40:05 <shapr> daniel_larsson: Are you using 0.9.1 ?
08:40:14 <shapr> I think I'm going to delete 0.8.8 off the server...
08:40:24 <daniel_larsson> No, not yet, still on 0.8.8 I'm afraid :/
08:41:01 <oerjan> @src replicateM
08:41:01 <lambdabot> replicateM n x = sequence (replicate n x)
08:41:48 <daniel_larsson> shapr: ah, I see that 0.9.1 handles this differently
08:42:34 <phobes> You could make that fast mechanically by making a NewList Monad that, instead of applying (++) to concat lists, built up the AST with a Concat datatype, and then define newLength on that
08:43:14 <tehgeekmeister> how would one get the functionality that lambdabot has of truncating output and terminating calculations that are too processor/memory intensive?
08:43:20 <tehgeekmeister> phobes: AST?
08:43:24 <oerjan> > let f n l = iterate (liftM2 (:) l) [] !! n in genericLength 1000 [True,False]
08:43:25 <lambdabot>   add an instance declaration for (Num [b])
08:43:29 <quicksilver> tehgeekmeister: fork()
08:43:34 <oerjan> > let f n l = iterate (liftM2 (:) l) [] !! n in genericLength $ f 1000 [True,False]
08:43:36 <lambdabot>  0
08:43:38 <quicksilver> tehgeekmeister: as in, separate OS-level process
08:43:47 <tehgeekmeister> quicksilver: thanks.
08:43:48 <phobes> tehgeekmeister:  Abstract Syntax Tree
08:44:01 <oerjan> > let f n l = iterate (liftM2 (:) l) l !! (n-1) in genericLength $ f 1000 [True,False]
08:44:02 <lambdabot>      Occurs check: cannot construct the infinite type: a1 = [a1]
08:44:02 <lambdabot>       Expect...
08:44:08 <oerjan> bah
08:44:36 <ac> would it be possible to use gtk2hs compiled for ghc6.6 with 6.8?
08:44:43 <ac> I'm guessing no
08:44:53 <oerjan> > let f n l = iterate (liftM2 (:) l . return) l !! (n-1) in genericLength $ f 1000 [True,False]
08:44:54 <lambdabot>      Occurs check: cannot construct the infinite type: a1 = [a1]
08:44:54 <lambdabot>       Expect...
08:45:15 <Olathe> I expected your expectation.
08:45:24 <phobes> tehgeekmeister:  Basically just have the Monad return an unevaluated datatype holding the result, and let the length function lazily evaluate it
08:45:45 <phobes> That way you get depth first traversal
08:46:05 <oerjan> > let f n l = iterate (liftM2 (:) l) [[]] !! n in genericLength $ f 1000 [True,False]
08:46:09 <lambdabot> Terminated
08:47:26 <tehgeekmeister> phobes: what would this Concat datatype look like?
08:47:34 <oerjan> now wait a minute...
08:47:59 <quicksilver> tehgeekmeister: data Concat a = Unit [a] | Concat (Concat a) (Concat a)
08:48:02 <oerjan> a 2^1000 length list would take longer to traverse than the lifetime of the universe o_O
08:48:04 <quicksilver> tehgeekmeister: (for example)
08:48:39 <quicksilver> i.e. a binary tree with lists at the nodes
08:48:43 <oerjan> forget all about making the list itself efficient :D
08:48:48 <quicksilver> that's the "abstract stucture" of ++
08:48:52 <phobes> oerjan:  True, but at least you won't run out of memory!
08:48:58 <tehgeekmeister> okay
08:49:22 <quicksilver> oerjan: at least it becomes O(universe) and not O(2^universe) :)_
08:50:44 <oerjan> > logBase 10 2 * 1000
08:50:45 <lambdabot>  301.02999566398114
08:51:02 <oerjan> > 2.0^1000
08:51:03 <lambdabot>  1.0715086071862674e301
08:53:48 <Olathe> > foldr (+1) 1 $ replicateM 1000 [True, False]
08:53:49 <lambdabot>  Couldn't match expected type `b -> b'
08:54:01 <Olathe> @type foldr
08:54:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:54:41 <Olathe> > foldr (const (+1)) 0 $ replicateM 1000 [True, False]
08:54:45 <lambdabot> Terminated
08:54:56 <phobes> > foldr (const (+1)) 0 $ replicateM 20 [True, False]
08:55:00 <lambdabot>  1048576
08:55:05 <phobes> > foldl (const (+1)) 0 $ replicateM 20 [True, False]
08:55:06 <lambdabot>   add an instance declaration for (Num [Bool])
08:55:15 <phobes> eh?
08:55:24 <phobes> :t foldr
08:55:26 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:55:27 <phobes> :t foldl
08:55:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:55:41 <phobes> oh right nm
08:58:22 <ac> is there any concepts of namespaces in Haskell? Can you use module definitions without poluting your namespace?
08:59:05 <oerjan> ac: modules are the namespaces
08:59:34 <oerjan> there are export lists to limit what you export
08:59:48 <ac> can you choose not to accept export lists, like in perl?
08:59:59 <oerjan> not portably
09:00:22 <oerjan> in interactively loaded modules, you may see the internals
09:01:22 <dylan> ac: import Module (name, name2) limits the symbols exported to name and name
09:01:30 <oerjan> but compiled code may not contain unexported identifiers at all
09:01:51 <dylan> s/exported/imported/
09:01:56 <oerjan> oh right
09:02:03 <oerjan> you can import less, but not more
09:02:29 <dylan> it's not generally considered good to import functions a module does not export, in perl. :P
09:07:07 <olsner> woah, so in perl, it is possible to import things that a module doesn't export? that sounds... well, perlish I guess
09:08:01 <ac> olsner: indeed :)
09:08:35 <tuukkah> i suppose it's the same in python
09:08:53 <olsner> hmm, so perl basically has all harmful features ever invented?
09:09:09 <oerjan> @remember olsner hmm, so perl basically has all harmful features ever invented?
09:09:10 <lambdabot> Done.
09:09:12 <tuukkah> you can do you what you want and it's supposed you know what you're doing
09:10:05 * oerjan waits for the lynch mob from #perl6 :)
09:10:31 <tuukkah> perl /= perl6
09:10:50 <Zevv> How would I formulate a function to add the numbers in a list of lists as in 'add :: [[Float]] -> [Float]'
09:10:55 <Zevv> I'm stuck on the pattern matching here
09:10:58 <oerjan> Zevv: map sum
09:11:06 <Zevv> ah yes
09:11:21 <Zevv> but the pattern would be ?
09:11:33 <oerjan> as in map i guess
09:11:42 <Zevv> ok, let me check. Thanks!
09:11:43 <ac> I guess there would be perl6 people in here... considering pugs
09:11:43 <quicksilver> sumLL (x:xs) = sum x + (sumLL xs)
09:11:51 <quicksilver> Zevv: like that, perhaps?
09:11:59 <ac> hello perl6 people?
09:12:01 <quicksilver> Zevv: sumLL [] = 0, as well
09:12:13 <oerjan> quicksilver: i think he wants : not +
09:12:18 <quicksilver> oh, right
09:12:20 <quicksilver> duh
09:12:29 <leila> hi all\
09:12:32 <quicksilver> sumLL (x:xs) = sum x : sumLL xs
09:12:43 <quicksilver> Zevv: the point is that I match on the 'outer list'
09:12:54 <quicksilver> Zevv: it happens that the value I match 'x' is "also a list"
09:12:57 <quicksilver> Zevv: but that's OK
09:12:57 <Zevv> Yes, I just figured that out :)
09:13:07 <quicksilver> Zevv: variables can match complex types, in patterns
09:13:12 <byorgey> hi leila
09:13:14 <oerjan> then sum, if you define it yourself would match on the inner one
09:13:26 <oerjan> *,
09:13:43 <Zevv> that was what I needed, yes
09:13:44 <olsner> instance Num a => SumType a where gSum = id
09:14:43 <olsner> hmm... or is it map sum that is sought
09:14:43 <leila> i tried to program some in haskell (http://hpaste.org/3063) but i think i made things to complicated ~_~ any pointers on how to improve it?
09:14:53 <oerjan> ac: also, i believe lambdabot is in #perl6
09:15:49 <oerjan> improving your haskell is a gradual process as you learn - there is always something more
09:16:12 <shapr> yeah, like music
09:16:12 <leila> that be so very true
09:16:18 <leila> or cooking
09:16:22 <shapr> So what should I improve today?
09:16:23 <quicksilver> perl6 is doomed because it's being prototyped in haskell
09:16:34 <quicksilver> therefore all the perl6 coders will eventually realise they'd rather just program in haskell
09:16:40 <quicksilver> and lose their motivation to write perl6
09:16:43 <fax> lol
09:16:49 <leila> lol quicksilver
09:16:52 <quicksilver> ^^ the above is (mostly) a joke by the way :)
09:17:01 <byorgey> leila: for one thing, there are already various collection libraries, you might want to take a look at them
09:17:15 <byorgey> there's Edison and collections, I think
09:17:36 <leila> those seperate or in the prelude ?
09:17:38 <olsner> quicksilver: you're missing the point! that is exactly how perl6 will succeed! (in bringing world domination to haskell)
09:18:12 <quicksilver> olsner: yes, that is certainly success in one sense :)
09:18:21 <quicksilver> olsner: I personally would be happy with that result
09:18:54 <quicksilver> leila: getting a generic collections library right is much harder than it looks
09:19:13 <byorgey> leila: they are separate.
09:19:15 <ac> quicksilver: I was thinking the same thing about perl6. I want to ask some perl6 people if they're afraid of haskell
09:19:30 <leila> quicksilver, i know
09:19:38 <quicksilver> leila: You seem very fond of using recursion directly
09:19:52 <leila> its a pain, but it was usefull to get to know the class / instance thing
09:20:01 <quicksilver> leila: you might find it instructive to abstract some of those patterns using common higher order functions
09:20:36 <leila> quicksilver, i think the problem there could be my lack of knowledge as far as the prelude goes
09:20:50 <oerjan> leila: the prelude is just one module.
09:20:57 <quicksilver> leila: for example. getTokens could be written as : getTokens state mappings = map (\(node,_) -> getToken state node) mappings
09:21:18 <oerjan> it contains some of the functions but not all.  Look in Data.List for starters.
09:21:25 <quicksilver> leila: removeTokens also reduces to a single 'map'
09:21:40 <byorgey> leila: as another example, mergeInMapping could be written as: mergeInMapping = concat . map snd
09:21:44 <oerjan> @docs Prelude
09:21:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
09:21:49 <oerjan> @docs Data.List
09:21:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
09:22:21 <oerjan> when you are familiar with Data.List, it's time to look at Control.Monad.  and then, the world.
09:23:48 <leila> byorgey, i tried function composition a couple of times, but my brain didnt get it ^^;
09:23:54 <quicksilver> leila, byorgey: this is where taste comes into it. I tend to prefer not to use 'fst' or 'snd'
09:24:21 <quicksilver> leila: I think the very explicit (\(node,_) -> getToken state node) is more readable that (getToken state . fst)
09:24:26 <quicksilver> this is totally subjective
09:24:51 <quicksilver> but the expicit lambda-binding gives a name to what you're keeping and lets you see what you're thowing away
09:25:14 <leila> interesting
09:25:29 <quicksilver> also, fst and snd don't scale to tuples bigger than 2
09:25:34 <quicksilver> another reason I avoid them
09:25:34 <olsner> also, Bag is simply [[a]] and Set is [a], afaics
09:26:15 <leila> olsner, basically yes, but its the operations that make it a bag or a set
09:26:33 <quicksilver> I wouldn't discourage leila's newtypes
09:26:42 <quicksilver> I think some nice newtypes make the intention more clear
09:26:46 <ac> what does this mean: "ghc-6.8.0.20071003: panic! (the 'impossible' happened)"
09:27:02 <quicksilver> (although a reason they can be annoying is that you can't use generic higher order functions over them
09:27:07 <sjanssen> ac: GHC bug
09:27:18 <Zao> ac: Great fun, that.
09:27:20 <olsner> I was thinking more of that the operations will probably be a lot easier to express as operations on lists, but keeping them as distinct types is probably a good thing
09:27:34 <leila> quicksilver, yup or need to instance the classes ~_~
09:27:44 <olsner> i.e. data Bag a = Bag [[a]] or similar
09:27:54 <ac> oh, fortunately I already know what it is. It's arrow syntax apparently
09:28:26 <tolik> leila: merge is just "flip (foldl merge2)"
09:28:29 <oerjan> olsner: you mean newtype
09:28:47 <olsner> oerjan: yeah, that'd be similar ;-)
09:28:54 <quicksilver> leila: I think that code is actually very nie
09:29:10 <quicksilver> leila: the main point that most of us are making is 'you are using well known recursion patterns, these have names'
09:29:26 <quicksilver> leila: and most people prefer to use named patterns of recursion than explicit recursion, where possible
09:29:40 <quicksilver> it's another kind of abstraction
09:29:51 <quicksilver> you could easily name the patterns yourself instead of using the prelude names
09:29:53 <leila> with good reason of course, since those are probably chewed down triple verified and though of function
09:29:54 <leila> s
09:30:05 <quicksilver> they are familiar to other readers, too
09:30:10 <quicksilver> there is value in 'common names' for things
09:30:24 <fax> monads -_-
09:30:34 <leila> "conventions" always nice to have
09:30:42 <birkenfeld> I finally finished my first larger Haskell program/library, and I must say it's been a really good experience, also thanks to the great help from this channel
09:32:43 <quicksilver> birkenfeld: cool! What does it do?
09:32:52 <quicksilver> leila: there's a balance, actually
09:32:53 <birkenfeld> it's a preprocessor for CSS
09:33:01 <birkenfeld> I actually ported it from Python code
09:33:03 <quicksilver> leila: too many conventions make for jargon and inaccessibility
09:33:05 <leila> also must say that i created this with the very limited knowledge that was retained from my university studies
09:33:14 <quicksilver> leila: too few conventions mean re-inventing the wheel all the time
09:33:20 <quicksilver> the correct balance isn't always obvious
09:33:21 <birkenfeld> and surprisingly it's 1.5 times less code :)
09:33:33 <quicksilver> birkenfeld: only 1.5? You're not trying hard enough! :)
09:33:44 <quicksilver> birkenfeld: I've seed code-reduction ratios of 5x and more
09:33:45 <byorgey> hehe, quicksilver beat me to it =)
09:33:53 <leila> less code does not always means better code
09:33:58 <quicksilver> that is true
09:34:02 <birkenfeld> quicksilver: I believe that...
09:34:16 <birkenfeld> having just started
09:34:17 <quicksilver> but it very often is :)
09:34:32 <quicksilver> it is said that most of the time people bring problems to #haskell
09:34:37 <quicksilver> they start with a 20 line program
09:34:41 <quicksilver> and leave with a one-liner
09:35:01 <birkenfeld> if you want to look at it, it's at http://dev.pocoo.org/hg/sandbox/file/c06e7db6968d/haskell/clevercss/
09:35:03 <lambdabot> Title: sandbox: Manifest, http://tinyurl.com/27y2qr
09:35:21 <leila> befire i forget: thanks all for giving the tips
09:35:24 <byorgey> birkenfeld: sorry, what exactly is a CSS preprocessor?
09:35:26 <leila> before*
09:35:29 <byorgey> I'm curious
09:35:37 <birkenfeld> byorgey: well, it allows you to have variable definitions and arithmetic
09:35:56 <quicksilver> color: $link_color.darken(30%)
09:35:58 <quicksilver> nice!
09:36:04 <leila> and constants too ?? like red=<somehex> ?
09:36:05 <quicksilver> I've always wanted 'named colours' in CSS
09:36:07 <byorgey> oh, I see.  so you can "program" your CSS. nifty =)
09:36:12 <birkenfeld> exactly
09:36:20 <quicksilver> http://dev.pocoo.org/hg/sandbox/file/c06e7db6968d/haskell/clevercss/example.ccs
09:36:22 <lambdabot> Title: sandbox: haskell/clevercss/example.ccs@c06e7db6968d, http://tinyurl.com/yudpgc
09:36:23 <leila> lol quicksilver looks like we had the same idea :)
09:36:43 <birkenfeld> I thought that was a good exercise because it involved parsing and many monads :)
09:36:55 <quicksilver> :)
09:37:06 <birkenfeld> ah, and you can also nest the definitions as you can see
09:37:15 <byorgey> birkenfeld: that's neat.  you should package it up and put it on hackage!
09:37:34 <ac> hmm. actually it's not arrow syntax I don't think... ghc panics on the following:
09:37:36 <byorgey> I'll definitely use it next time I have the misfortune of needing to write some CSS
09:37:37 <hpaste>  ac pasted "(no title)" at http://hpaste.org/3081
09:37:59 <birkenfeld> byorgey: wow, thanks...
09:38:07 <leila> the nesting looks nice
09:38:53 <birkenfeld> unfortunately, documentation is missing altogether
09:38:55 <byorgey> ac: what's with the tilde?
09:39:04 <ac> don't ask me, I sure as hell didn't write that code
09:39:11 <ac> it's part of grapefruit
09:39:17 <byorgey> oh, I see
09:39:22 <birkenfeld> byorgey: but I'm not sure whether the code is fit for hackage
09:39:31 <byorgey> birkenfeld: well, then make it so =)
09:40:13 <leila> anyway, need to pick up the gm now, will be back at a later time :)
09:40:23 <quicksilver> byorgey: I think it's an infix class name
09:40:41 <byorgey> quicksilver: you're probably right
09:40:46 <quicksilver> byorgey: like writing Arrow a b as (a ~> b)
09:40:54 <ac> so the suspicious tilde is probably not the issue?
09:41:13 <oerjan> er, ~ would not be a class name, those would have to start with :
09:41:24 <quicksilver> oerjan: ~> does not start with :
09:41:35 <oerjan> wasn't ~ used for something in the new type families?
09:41:36 <idnar> :t (a ~> b)
09:41:38 <lambdabot> Not in scope: `a'
09:41:38 <lambdabot>  
09:41:38 <lambdabot> <interactive>:1:3: Not in scope: `~>'
09:41:44 <quicksilver> oerjan: and yet, ~> can be used as a class name in some versions of GHC, I'm sure
09:41:46 <idnar> er, duh
09:41:47 <byorgey> oerjan: yes, I think so
09:42:01 <oerjan> quicksilver: not class name, type variable
09:42:01 <ac> oerjan: GrapeFruit does use type families, which is why I had to upgrade to 6.8
09:42:12 <quicksilver> oerjan: Oh, I see
09:42:13 <quicksilver> hmm
09:43:01 <ac> perhaps I should upgrade again to 6.9?
09:43:05 <byorgey> hehe
09:43:09 <ddarius> It's an equality constraint.
09:43:32 <oerjan> ac: i guess you have to expect things with something as experimental as type families
09:43:34 <ddarius> And 6.8 is somewhat not ready, 6.8.1 should be what you want when it is released.
09:43:53 <olsner> has 6.8 been released at all?
09:44:20 <ac> olsner: yeah I just downloaded it from the stable directory
09:44:30 <olsner> cool
09:47:28 <quicksilver> erm that's odd
09:47:32 <quicksilver> I didn't see a release announcement
09:48:07 <quicksilver> I'm pretty sure that's some kind of prerelease or similar
09:48:13 <birkenfeld> doesn't the "ghc-6.8.0.20071003" mean that it's only a snapshot?
09:48:53 <quicksilver> yes, I would have thought so
09:49:59 <sjanssen> ac: type families are not officially supported in ghc 6.8, so you're to expect bugs
09:50:49 <ac> sjanssen: I hope GrapeFruit's authors had a good reason for using them
09:55:38 <sjanssen> ac: they're much nicer than the older alternatives
09:56:16 <sjanssen> I bet most code that uses fundeps now will gradually migrate to type families as the implementation becomes more mature
09:58:54 <Baughn> 6.8? What happened to 6.7?
09:59:26 <sjanssen> Baughn: GHC uses the old Linux-style versioning scheme
09:59:32 <sjanssen> odd points are development releases
09:59:49 <Baughn> sjanssen: Ah.
10:00:01 <fax> I just read Typed Logical Variables in Haskell?
10:00:03 <fax> @_@
10:00:03 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
10:00:14 <Baughn> Could be worse. The last program I released used the tarball hash for a version number.
10:01:01 <fax> this is well confusing
10:01:38 <fax> I couldn't see solve implemented anywher
10:02:32 <fax> can you get the whole code?
10:06:43 <fax> did anyone read this paper?
10:06:48 <fax> (Typed Logical Variables in Haskell)
10:06:56 <fax> How can you understand it without seeing the code for solve?
10:09:43 <ddarius> fax: There is a footnote which describes what solve is.
10:09:53 <ddarius> solve isn't particularly important.
10:10:31 <therp> fax: I read it. iirc solve is rather trivial
10:11:34 <dons> therp: you made it home ok?
10:11:47 <therp> dons: yes thanks for asking
10:12:15 <therp> dons: hope Hac II turns out to be nice
10:12:25 <fax> if solve is so trivial why didn't they show it :[
10:12:36 <dons> yeah, should be good i think
10:12:44 <fax> Do you just understand everything from the definition of some monads?
10:13:36 <therp> fax: it's not that hard but I read it a few months ago
10:14:00 <fax> I suppose I'll need to write more code or something so I have better intuition about it
10:15:25 <fax> do you think that's a good idea?
10:15:28 <therp> fax: I'll look up solve when the rest of my computer starts responding again (rsync + stupid linux IO policy)
10:16:43 <ddarius> fax: solve is just a driver program (function) to display results.  It isn't necessary.
10:17:11 <therp> fax: http://darcs.liskell.org/tech-demos/prolog/Prolog.lsk -- search for solve. I hope you can make a sense of this. I think that's only solve for the first Prolog variant they give (untyped prolog)
10:17:39 <fax> ok thank you
10:17:58 <therp> fax: or translated into Haskell this should be "solve p = map fst (p ([], varstream))"
10:20:33 <therp> fax: varstream is essentially an infinite stream of (Var ...) instances..
10:23:14 <ac> can type classes have type arguments?
10:24:38 <kpreid> ac: a type class with no arguments would be rather useless...
10:25:00 <kpreid> or do you mean that the instances have parameters? still yes; Monad is an example
10:25:37 <ac> OK, so how would you define a function that takes a type class as an argument, where one of the parameters of that type class is returned?
10:26:00 <kpreid> uh, you don't. functions don't operate on types
10:26:12 <ac> I didn't word that correctly
10:26:34 <kpreid> @src MonadReader
10:26:35 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:26:58 <kpreid> I think MonadReader's "get" is a function of the sort you're thinking of
10:27:22 <kpreid> oops, it's called "ask"
10:27:23 <ac> I have type class Foo, and instances have parameters a and b. I want a signature like: func :: Foo a b => a -> b
10:27:41 <kpreid> sure, that's fine
10:27:48 <ac> does that work? where b is the type of the paramater of the type of a
10:28:18 <kpreid> uh?
10:28:21 <kpreid> a and b are both parameters of Foo
10:29:23 <Baughn> But b is also a parameter of a?
10:29:32 <Baughn> Sounds like dependent typing
10:30:03 <ac> yeah. Here's what I'm doing, to make it clear...
10:30:35 <xerox> class Foo m a | m -> a where foo :: m a -> a -- ?
10:30:37 <ac> foo :: Random g a => g -> range -> a
10:30:49 <ac> er... -> [a]
10:31:13 <ac> so I want g to be an instance of the Random class, and a to be the paramater to g
10:32:03 <oerjan> ac: perhaps try g a -> range -> a
10:32:06 <xerox> ac: in class Random g a where .. g and a are independent.
10:32:38 <oerjan> :t (>>=)
10:32:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:32:53 <xerox> There could be defined a functional dependency between them.
10:32:54 <oerjan> like with monads, m takes a parameter
10:33:33 <oerjan> this sounds similar to the new associated type synonyms
10:34:14 <oerjan> gtg
10:36:19 <ac> nevermind, I shouldn't be taking a Random, I should be taking a RandomGen. I don't need anything complex
10:36:36 <birkenfeld> hm, emerging gtk2hs fails...
10:36:42 <Pastorn_> @src join
10:36:42 <lambdabot> join x =  x >>= id
10:37:01 <ac> birkenfeld: what's the build error? I was just dealing with building gtk2hs
10:37:09 <birkenfeld> gtk/Graphics/UI/Gtk/Types.chs:4659:27:
10:37:09 <birkenfeld>     Not in scope: type constructor or class `CUInt'
10:37:25 <ac> brushbox: hah. I had the same problem. I just manually addded it to the import to several files and it compiled
10:37:50 <ac> er, birkenfeld:
10:37:55 <ac> birkenfeld: it takes forever though
10:37:59 <birkenfeld> I noticed :)
10:38:09 <birkenfeld> I'll just try 0.9.11 then
10:38:50 <ac> I doubt that will fix it. I think the problem is due to some dependency with an older version of ghc or something like that
10:39:00 <birkenfeld> oh
10:39:17 <birkenfeld> yes, that may be -- most people seem to use the binary GHC package
10:39:29 <birkenfeld> which doesn't have 6.6 yet
10:39:39 <ac> I just compiled it with 6.8.0
10:40:25 <birkenfeld> ok, then I'll build it myself
10:40:55 <birkenfeld> and fix the errors when they occur
10:41:27 <Pastorn_> @src fix
10:41:28 <lambdabot> fix f = let x = f x in x
10:41:29 <ac> yeah it's only in like 8 or so files. I edited both the .hs and .chs files, though I'm not sure that was necessary
10:42:04 <birkenfeld> @hoogle CUInt
10:42:08 <lambdabot> Foreign.C.Types.CUInt :: data CUInt
10:42:13 <Pastorn_> @type fix
10:42:14 <birkenfeld> is that the correct one?
10:42:15 <lambdabot> forall a. (a -> a) -> a
10:42:27 <ac> birkenfeld: hah. yep. I did the same @hoogle query a little bit ago
10:42:54 <ac> Just add CUint next to where you see import ... (CULong)
10:43:05 <birkenfeld> I think I'll compile with -O0...
10:43:51 <birkenfeld> -O seems to increase compile time by a factor of 10
10:44:02 <ac> hah. You'll probably run out of memory too
10:49:18 <ac> How come when I compile and run my program it works fine, but when I :load it in ghci it complains about things not in scope?
10:49:50 <ac> and if I say :add foomodule it complains about it being a package module
10:50:10 <monochrom> Did you write foomodule yourself?
10:50:18 <ac> no, it's System.Random
10:50:30 <monochrom> Use :module + System.Random
10:51:46 <ac> hm. it also worked to simply explicitly declare everything I was using after the import
10:53:04 <ac> also I'm getting a linking error from Sgtk.o in ghci, but again it works fine outside of ghci
10:53:59 <birkenfeld> hah, in that Gtk.Types module the export list alone has 800 lines
10:54:23 <EvilTerran> > let (<<) = shiftL; al_id [a,b,c,d] = (((a)<<24) .|. ((b)<<16) .|. ((c)<<8) .|. (d)) in al_id (map ord "NONE")
10:54:28 <lambdabot>  1313820229
10:55:08 <mux> I wish Control.Monad's >> had been named >>_
10:55:43 <birkenfeld> mux: but it doesn't have type "m ()"
10:55:46 <mux> but well, it's not like we do bit shifts everyday in haskell :)
10:56:02 <mux> birkenfeld: hm? what are you talking about?
10:56:25 <birkenfeld> well, isn't the convention that functions whose names end in _ return Monad m => m ()?
10:56:58 <mux> M_ !
10:57:11 <mux> well, there's sequence_
10:57:22 <mux> I don't think that would cause much confusion though..
10:57:30 <mux> but it seems >>_ is not a valid operator identifier
10:57:32 <birkenfeld> apart from that, >>_ is ugly
10:57:53 <mux> how is it more ugly than >>=, >>, <insert ten million other operators here> ?
10:58:12 <byorgey> I prefer *.%%$ myself
10:58:21 <birkenfeld> it's kind of hard to explain one's sense of aesthetics
10:58:35 <mux> > (first (+1) >>> second (+2)) (1,2)
10:58:37 <lambdabot>  (2,4)
10:58:51 <birkenfeld> isn't that ((+1) *** (+2))?
10:58:54 <byorgey> >>_ doesn't have bilateral symmetry =)
10:59:01 * mux shrugs.
10:59:07 <byorgey> yes.
10:59:13 <sjanssen> mux: that is an interesting idea
10:59:13 <mux> the point was to show the >>> operator
10:59:19 <byorgey> @src (***)
10:59:19 <lambdabot> f *** g = first f >>> second g
10:59:21 <sjanssen> nice symmetry with sequence_ and friends
10:59:23 <mux> sjanssen: thanks, I feel much better now =)
10:59:31 <mux> finally someone who understands me!
10:59:40 <byorgey> I actually like the >>_ idea, too
10:59:55 <birkenfeld> okay, I give up :)
10:59:59 <sjanssen> though changing the grammar for it might be a problem
11:00:01 <mux> yay! ;-)
11:00:07 <mux> sjanssen: *nods*
11:00:14 <byorgey> it is also reminiscent of using _ for an ignored place in a pattern match
11:00:23 <byorgey> ...which I guess is the point with sequence_ etc.
11:05:38 <ac> lovely: randomIntRs g range = map (flip mod range) (randoms g)
11:06:11 <xerox> You could also write map (`mod` range) (randoms g)
11:06:33 <ac> what's the tick syntax?
11:06:48 <xerox> It makes prefix ops infix
11:07:01 <xerox> Much like parens make infix ops prefix
11:07:37 <xerox> > ((+) 2 3, (+2) `fmap` (Just 3))
11:07:39 <byorgey> and then you can use sections to partially apply the second parameter: (`mod` range) is like (+4)
11:07:48 <lambdabot>  (5,Just 5)
11:08:06 <byorgey> so (flip mod range) == (`mod` range)
11:08:08 <ac> interesting
11:08:18 <byorgey> and (mod range) == (range `mod`)
11:08:23 <ac> that's a little confusing to me, but great in a perlish sort of way
11:08:34 <byorgey> hehe
11:08:40 <byorgey> if used well, it makes things more readable
11:08:51 <byorgey> if not used well...
11:08:56 <ac> the infamous "if used well" qualifier
11:09:19 <byorgey> of course, every language has that =)
11:09:23 <monochrom> Nothing is abuse-proof. Nothing.
11:09:39 <byorgey> hm, I bet I could abuse Nothing
11:09:48 <birkenfeld> :)
11:09:52 <monochrom> haha
11:10:13 <birkenfeld> I think I recall SPJ calling Just and Nothing "cute".
11:10:20 <monochrom> Anyway, even something as elegant and nice as the Hindley-Milner type system can still be abused.
11:10:53 <ac> SPJ is amusing
11:12:54 <therp> are there papers on how to design the process of compilation/module/compilation units/module dependencies?
11:13:32 <therp> so that the compilation system is able to handle recursive module dependencies, and is able to feed them into smaller compilation units to the compiler?
11:14:39 <MyCatVerbs> therp: if you give it a hand, AFAIK, yesh.
11:16:00 <therp> yesh?
11:16:09 <therp> is this the name of such a system?
11:16:20 <therp> (or I misgoogled that)
11:30:49 <cpfr> howdy
11:31:16 <byorgey> hi there cpfr
11:31:29 <cpfr> what does the @ character do in haskell
11:31:55 <byorgey> it binds a name to whatever matched the pattern on its right.
11:32:07 <byorgey> for example:
11:32:33 <byorgey> > let f list@(x:xs) = xs ++ list in f [1,2,3]
11:32:35 <lambdabot>  [2,3,1,2,3]
11:32:42 <cpfr> hmm
11:33:02 <byorgey> when f gets called on [1,2,3], x gets bound to 1, xs gets bound to [2,3], and list gets bound to the whole thing.
11:33:13 <cpfr> ah
11:33:30 <cpfr> what if there are _
11:33:37 <cpfr> it binds everything sans that
11:33:44 <byorgey> _ matches anything, it just gets ignored.
11:33:57 <byorgey> > let f _ x = x in f 2 3
11:33:58 <lambdabot>  3
11:34:11 <cpfr> right
11:34:21 <byorgey> oh, I see what you're asking
11:34:31 <byorgey> no, whatever is to the left of @ would still bind everything
11:34:38 <cpfr> > let f list@(x:_) = x ++ list in f
11:34:39 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
11:34:39 <lambdabot>       Expected...
11:34:40 <ac> byorgey: in your "list@(x:xs)" example, list is the original argument, x is the head, and xs is the tail?
11:34:45 <byorgey> the _ just means that you don't care about the value of that part.
11:34:49 <byorgey> ac: right.
11:34:53 <cpfr> > let f list@(_:xs) = xs ++ list in f
11:34:53 <lambdabot>  Add a type signature
11:35:16 <byorgey> > let f list@(_:xs) = xs ++ list in f [1,2,3]
11:35:17 <lambdabot>  [2,3,1,2,3]
11:35:21 <ac> (x:_) dies because it throws away the tail infinitely?
11:35:29 <byorgey> that's actually equivalent to my first example, since x got ignored
11:35:46 <byorgey> ac: no, (x:_) is fine
11:35:55 <ac> what's with the error up there?
11:36:03 <cpfr> ok so list just returns the whole thing
11:36:05 <byorgey> > let f list@(x:_) = [x] ++ list in f [1,2,3]
11:36:06 <lambdabot>  [1,1,2,3]
11:36:11 <cpfr> before it is deconstructed
11:36:12 <cpfr> ok
11:36:14 <cpfr> thanks!
11:36:16 <byorgey> the error was with x ++ list, x and list had different types
11:36:27 <byorgey> cpfr: that's right.
11:37:00 <cpfr> ok  i get it
11:37:00 <cpfr> thank
11:37:15 <byorgey> cpfr: you're welcome =)
11:37:29 <ac> so if you don't care about the original list, you'd say "_@(x:xs)"
11:37:54 <byorgey> ac: well, in that case you wouldn't use @ at all
11:38:01 <byorgey> you'd just say (x:xs)
11:38:03 <ac> oh :P
11:38:08 <byorgey> hehe
11:38:21 <byorgey> > let f _@(x:xs) = x:x:xs in f [1,2,3]
11:38:22 <lambdabot>  Parse error
11:38:28 <byorgey> yeah, _@ doesn't even parse
11:41:08 <cpfr> i think its there if you want to still have it in that form
11:46:47 <Zevv> Hi; I'm trying to create a kind of 'lowpass filter' function ([Float] -> [Float]) that is supposed to calculate the moving average over the last 3 Floats in a list. I'm a bit stuck on how to access the last n elements of a list during recursion. Any ideas for this ?
11:47:45 <fasta> Zevv: efficiently?
11:48:09 <byorgey> Zevv: maybe something like zipWith3 avg list (tail list) (tail $ tail list)?
11:48:29 <Zevv> efficiency would eventually be an issue
11:48:40 <Zevv> since I'm trying to construct a software synth as a learning project
11:48:47 <Zevv> The first filter is just a moving average
11:48:55 <Zevv> but my plan is to create FIR and IIR filters as well
11:49:03 <Zevv> which should be able to act on infinite length arrays
11:49:11 <cpfr> ok
11:49:12 <Zevv> its basically just convolution
11:49:20 <monochrom> w00t very convolved!
11:49:34 <Japsu> ooooh
11:49:40 <monochrom> infinite impulse response <3
11:49:42 <Zevv> so element n is calculated by taking element n, n-1, n-2, ..., n-x from the incoming list
11:49:48 <Zevv> ok, lets skip the IIR
11:49:54 <Zevv> just take the FIR :)
11:50:06 <fasta> Zevv: so the incoming list is finite?
11:50:07 <Japsu> Zevv: I wrote convolution and IIR filtering a while ago, you interested in making it yourself or do you just want the solution? ;)
11:50:12 <Zevv> fasta: yes
11:50:22 <Zevv> Japsu: a hint would be fine
11:50:27 <Japsu> a hint... well
11:50:32 <Zevv> and maybe more hints if i'm not smart enough to fix this myself
11:50:41 <Zevv> its my 3d day of haskell, so be kind to me :)
11:50:52 <Zevv> I'm quite proud of my oscillators, mixers and envelopes already :)
11:51:04 <Japsu> I did it by drawing the block diagram and then finding repetitive blocks, which I then used recursively
11:51:23 <Zevv> Japsu: ok, that's the definition of convolution
11:51:32 <Japsu> yeah
11:51:32 <Zevv> my problem is that I just don't know how to write this down in haskell
11:51:35 <fasta> Zevv: the easiest solution is to turn the list into an array and then all your index operations on those arrays, I think. But I have no idea of audio processing algorithms.
11:51:47 <Zevv> fasta: the problem is that the list is endless
11:51:48 <fasta> er that array
11:51:50 <Zevv> it's a continous stream
11:51:52 <Japsu> Zevv: Well consider a "building block" that takes two input and gives two outputs
11:51:57 <fasta> Zevv: you just said it was finite.
11:52:06 <Zevv> fasta: no, sorry, that was a misunderstanding
11:52:18 <Zevv> Japsu, yes, continue ? :)
11:52:45 <Japsu> Zevv: I wrote that as a function :: Num a => a -> ([a], [a]) -> ([a], [a])
11:52:59 <Zevv> but why a pair in and a pair out
11:53:05 <Zevv> which is which ?
11:53:06 <fasta> Zevv: so, what should happen when one has been given only one element? The moving average is not defined yet then.
11:53:14 <Zevv> fasta: yes, that's a problem
11:53:15 <Japsu> where the first "a" is a constant factor used in the specific block
11:53:22 <fasta> Zevv: try to specify it completely first, then ask.
11:53:34 <Zevv> fasta: but a filter acting on the n last elements, could assume the negative indexed elements are zero
11:53:42 <fasta> Zevv: or jus talk to Japsu who already knows what you want.
11:53:44 <Japsu> Zevv: A pair out and a pair in because, well, my building block just happened to have two ins and two outs ;)
11:53:49 <Zevv> Ah ok :)
11:53:55 <fasta> just*
11:54:02 <Zevv> sorry?
11:54:06 <Japsu> The first block would get the zero signal in one of the ins
11:54:14 <Japsu> and in the last block I just discarded the other out
11:54:19 <Zevv> ok, clear
11:54:19 <monochrom> You need internal state to remember a small part of the stream you have seen before.
11:54:33 <Zevv> monochrom: I guess so. This leads to monads, no ?
11:54:49 <Japsu> Oh, cool
11:54:53 <Japsu> I've an image: https://pajukanta.fi/temp/konvoluutio.png
11:55:03 <Japsu> The text is in Finnish but just look at the block diagram
11:55:12 <Zevv> The diagram is clear
11:55:30 <monochrom> In orthodox DSP, the "delay elements" are the internal state. :)
11:55:31 <Japsu> A "building block" has been outlined in blue and the handling for the extra output and extra input is in green.
11:55:35 <Japsu> Well
11:55:36 <Zevv> I understand you added the two green signals just for technical reasons
11:55:51 <Japsu> I did delays as "delay = (0:)"
11:56:05 <Zevv> ah!
11:56:12 <Zevv> so there is my answer
11:56:15 <Zevv> :)
11:56:17 <monochrom> Or rather, "delay elements" mimic internal state.
11:56:18 <Japsu> that is, "prepend zero to the input signal"
11:56:22 <ac> how do I round a float to an int?
11:56:25 <Zevv> so you create n delayed streams
11:56:33 <dmwit> :t round
11:56:35 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:56:36 <Japsu> and my solution overflows the stack if I try to compute the millionth value in an IIR output signal
11:56:43 <Zevv> haha
11:56:44 <ac> that's a weird type signature for round
11:56:46 <Japsu> ;)
11:56:51 <dmwit> ac: Why do you say that?
11:57:03 <Zevv> Japsu: thanks for the hint so far. The delay was the missing link for me
11:57:07 <monochrom> I think there is an easy but subtle way to eliminate the stack overflow.
11:57:22 <ac> oh I see my problem. I typed "round .2" instead of "round 0.2" in ghci
11:57:29 <dmwit> heh
11:58:02 <monochrom> Apparently my feeble DSP-fu has not entirely gone down the drain. :)
11:58:26 <ac> if you say .2, "." is compose, right?
11:58:44 <dmwit> right
11:59:12 <Japsu> Zevv: I'll paste my solutions for convolution and IIR on hpaste for reference. Don't look at them yet if you don't want spoilers ;)
11:59:19 <xerox> ?type (.2)
11:59:20 <lambdabot> forall b c a. (Num (a -> b)) => (b -> c) -> a -> c
11:59:43 <hpaste>  Japsu pasted "Convolution and IIR filtering" at http://hpaste.org/3083
11:59:43 <Zevv> Japsu: thanks a lot!
11:59:49 <Japsu> There
11:59:51 <Japsu> no problem ;)
12:00:21 <Japsu> Note that my solution's suboptimal for sure... if someone comes up with better ones, I'll be interested
12:00:46 <Zevv> I'll let you know as soon as I outperform you :)
12:00:57 <Japsu> Looking forward to it ;)
12:01:25 <dmwit> Doesn't the LGPL require you to give a copy of the license with the source code?  Naught, naughty... =P
12:01:42 <Japsu> dmwit: It requires absolutely nothing from me, the copyright holder ;)
12:03:42 <fasta> Japsu: well, this certainly isn't recommended.
12:03:59 <fasta> Japsu: then again, who cares about your code? :)
12:04:10 <Japsu> Or should it actually require something, I sure as hell won't sue myself for copyright infringement ;)
12:04:22 <Japsu> fasta: err which one do you mean, the LGPLv2 or the code itself?
12:05:00 <dmwit> Probably the owner of hpaste would be the one getting in trouble for distributing your code without following the rules of the LGPL.
12:05:07 <fasta> Japsu: I mean that you didn't reproduce the full license, and I mean that the code probably isn't practical neither.
12:05:16 <Japsu>  21:59   Japsu : Note that my solution's suboptimal for sure... if someone comes up with better ones, I'll be interested
12:05:18 <fasta> either*
12:05:46 <fasta> Japsu: (yes, I read that)
12:07:06 <jatqceer> hi, I want to log some activities in ST, what should I use?  StateT?
12:07:31 <bos> jatqceer: WriterT
12:08:17 <jatqceer> thanks
12:08:49 <ac> how do I turn an Int to a Float?
12:09:02 <allbery_b> :t fromIntegral
12:09:10 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:09:30 <fasta> jatqceer: or WriterT
12:09:52 <fasta> jatqceer: is this for debugging purposes?
12:10:51 <jatqceer> fasta: half
12:11:16 <fasta> jatqceer: you need to consider strictness properties then.
12:11:24 <fasta> jatqceer: it's a pain, I can tell you that.
12:11:25 <jatqceer> fasta: basically i want to know what is going in there
12:11:33 <fasta> jatqceer: on?
12:11:40 <jatqceer> *on
12:12:02 <fasta> jatqceer: what seems to work best is to just use unsafePerformIO
12:12:06 <ac> arhg this is frustrating me. I can't figure out how to get the types to work on this
12:12:11 <ac> cosInterp :: Int -> Int -> Float -> Int
12:12:12 <fasta> jatqceer: consider a call to error
12:12:14 <ac> cosInterp from to at = round (((from - to) / 2) * (1 + cos (pi * at))) + to
12:12:31 <fasta> jatqceer: when you call error the entire computation just stops without producing anything in the writer monad.
12:12:33 <mrd> fromIntegral from, fromIntegral to
12:12:54 <hpaste>  monochrom annotated "Convolution and IIR filtering" with "trying to eliminate stack overflow" at http://hpaste.org/3083#a1
12:13:13 <jatqceer> fasta: but i want the function to work as normal, only when something bizarre happens, will I look into that log
12:13:15 <mrd> ac: fromIntegral loosens the concrete Int into any Num
12:13:25 <monochrom> Japsu: could you test out that idea to see if stack overflow goes away?
12:13:54 <ac> the function works fine in ghci, but it doesn't like the signature I gave it when I compile it
12:14:04 <Japsu> monochrom: cool, I'll try
12:14:15 <fasta> jatqceer: ok, well, then use the writer monad,  but it is only useful when your code always returns a non-bottom value.
12:14:38 <hpaste>  Japsu annotated "Convolution and IIR filtering" with "the test program that overflows" at http://hpaste.org/3083#a2
12:14:43 <fasta> jatqceer: and it also depends on where the condition for something bizar is located, etc.
12:14:55 <jatqceer> fasta: I see.
12:14:57 <fasta> jatqceer: it's non-trivial to make the right decision.
12:15:17 <mrd> ac: did you do :t cosInterp in ghci to see what it inferred?
12:15:41 * mrd bets Float -> Float -> Float -> Int
12:15:54 <mrd> :t cos
12:15:56 <lambdabot> forall a. (Floating a) => a -> a
12:16:02 <mrd> or maybe (Floating a) =>...
12:16:02 <ac> huh. must have changed something, because now it doesn't work in ghci
12:17:06 <Japsu> monochrom: YAY
12:17:12 <monochrom> -5.0e-324  looks like an awfully small number. But success!
12:17:12 <Japsu> monochrom: that fixes it
12:17:35 <Japsu> yeah well, it's a stable IIR filter so getting an awfully small number is nothing out of the ordinary ;)
12:17:39 <ac> > cosInterp from to at = round (((from - to) / 2) * (1 + cos (pi * at))) + to
12:17:40 <lambdabot>  Parse error
12:17:47 <ac> > let cosInterp from to at = round (((from - to) / 2) * (1 + cos (pi * at))) + to
12:17:47 <lambdabot>  Parse error
12:17:54 <Japsu> the test program, I mean
12:18:16 <Zevv> you guys do black magic
12:18:16 <ac> lambdabot != ghci
12:18:17 <Japsu> monochrom: so hmm, what does that do... remove some unnecessary laziness?
12:18:20 <monochrom> Incidentally, suppose you don't do "print (z !! 100000)"; suppose you do "print z". Then there is no stack overflow even if you use the Prelude map and zipWith.
12:18:41 <jatqceer> fasta: now i believe that i love IO so much that i can't live without it
12:18:43 <hpaste>  mrd pasted "cosInterp" at http://hpaste.org/3084
12:18:46 <Japsu> monochrom: :o
12:18:48 <Japsu> monochrom: how come
12:19:09 <monochrom> I have explained this phenomenon somehwere on comp.lang.haskell
12:19:23 <ac> mrd: thanks!
12:19:27 <mrd> > let cosInterp from to at = round (((fromIntegral (from::Int) - fromIntegral (to::Int)) / 2) * (1 + cos (pi * (at::Float)))) + fromIntegral to :: Int in cosInterp 1 1 2.4
12:19:29 <lambdabot>  1
12:20:00 <mrd> so, you can get rid of the inline type-annotations
12:20:08 <ac> right
12:20:25 <monochrom> http://groups.google.com/group/comp.lang.haskell/msg/0d76a3e201b3e2cf
12:20:27 <lambdabot> Title: accumulation function - comp.lang.haskell | Google Groups, http://tinyurl.com/2zs737
12:21:15 <byorgey> does anyone here use hpaste.el for emacs/hpaste integration?
12:21:43 <byorgey> I tried installing it but it complains that it can't load url.el
12:21:45 <ac> mrd: the last fromIntegral is unnecessary because it's outside the round
12:21:48 <Japsu> monochrom: Oh, I see
12:21:55 <byorgey> and I'm not sure where to get url.el
12:22:07 <mrd> ac: good point
12:22:12 <Japsu> It builds up the whole monster polynomial before actually evaluating any of it? Wicked.
12:22:38 <monochrom> Indeed.
12:23:12 <monochrom> Or you can keep displaying early answers to avoid monster buildup. Later monsters are built from earlier bacteria.
12:23:25 <Japsu> Right
12:25:08 <monochrom> But I'm still fond of map' and zipWith' since they are of the right eagerness (in the elements) and laziness (in the streaming) for this application.
12:25:25 <Japsu> yeah
12:25:48 <Japsu> Are there any advantages in the Standard Prelude implementations of map and zipWith over those implementations, then?
12:29:48 <perspectivet> what's the best way to fork a bunch of IO worker threads and return an operation completion status to the thread spawning the workers?
12:29:56 <monochrom> Some. There is theoretical uniformity in pure non-strictness. Also sometimes they are used in one-shot way --- you "map f xs" but that's it, you don't further apply another level of map to that --- and then you may prefer it lazy.
12:30:03 <perspectivet> best/simplest/idiomatic
12:30:47 <Japsu> perspectivet: I've read something about using an empty MVar () for each of the threads that the worker threads fill upon execution and the main thread reads
12:30:58 <Japsu> s/execution/completion/
12:31:08 <newsham> hmm.. would be nice if there were pre-implemented thread barriers in the libs, no?
12:31:10 <Japsu> I've never actually tried this, though
12:31:44 <perspectivet> newsham: yes
12:31:57 <sendo> good evenin
12:32:12 <monochrom> Control.Concurrent doc has an example IIRC.
12:32:26 <ac> how do I expand a stream? I mean I want a function that returns n elements of a list for every 1 element it consumes. I have: "biggerStream (x:y:ys) n = (makesubstream x y n) : (biggerStream (y:ys) n)" but that doesn't work because the left side of : is a list and it should be an element
12:32:28 <perspectivet> monochrom: checking...
12:33:11 <ac> I think I need a list append in there somewhere
12:33:15 <newsham> > let double [] = []; double (x:xs) = x:x:(double xs) in double "test"
12:33:17 <Mr_Awesome> is anyone here familiar at all with yampa or frp that could explain how to use the "accumFilter" function in yampa? i can paste the code if you dont have it
12:33:17 <lambdabot>  "tteesstt"
12:33:32 <kpreid> ac: yes, you do
12:33:35 <idnar> ac: how about ++ instead of : on the RHS there?
12:33:35 <monochrom> Under "Terminating the program"
12:33:43 <ac> idnar: yes, that's what I need
12:33:48 <ac> idnar: didn't know about ++
12:33:52 <newsham> ac: like so?
12:34:04 <ac> it works
12:34:10 <dmwit> > let double xs = [(),()] >> xs in double "test"
12:34:11 <lambdabot>  "testtest"
12:34:13 <perspectivet> monochrom: ah, missed that the first time through, thanks a lot.
12:34:42 <monochrom> [x,x] ++ double xs
12:34:48 <newsham> > "test" >> \x -> [x,x]
12:34:48 <lambdabot>      The lambda expression `\ x -> ...' has one argument,
12:34:49 <lambdabot>     but its type `[...
12:35:02 <dmwit> > "test" >>= \x -> [x, x]
12:35:03 <lambdabot>  "tteesstt"
12:35:09 <newsham> oops
12:35:29 <newsham> ac: if you know about the list monad, that would do pretty much what you want
12:35:55 <ac> newsham: what's wrong with ++?
12:35:58 <dmwit> > "test" >>= replicate 2
12:36:00 <lambdabot>  "tteesstt"
12:36:07 <dmwit> There we go, that's prettier.
12:36:08 <newsham> the list monad kinda uses ++ internally.
12:36:20 <ac> newsham: are you saying I could get rid of recursion if I used the list monad?
12:36:28 <newsham> ac: yes.  you could.
12:36:33 <ac> newsham: cool. how do I do it?
12:36:55 <newsham> > "this is my list" >>= (\x -> [toUpper x, x])
12:36:56 <lambdabot>  "TtHhIiSs  IiSs  MmYy  LlIiSsTt"
12:37:05 <newsham> just take your list and >>= it into your expand function
12:37:16 <Japsu> > (>>=) [1,2,3] (replicate 2)
12:37:18 <lambdabot>  [1,1,2,2,3,3]
12:37:26 <Japsu> > (flip concatMap) [1,2,3] (replicate 2)
12:37:28 <lambdabot>  [1,1,2,2,3,3]
12:37:30 <Japsu> \o/
12:37:31 <ac> interesting
12:37:40 <ac> cool. that's even SIMPLER
12:37:43 <newsham> ac: it basically maps your function over the list, and then concats the results
12:37:49 <dmwit> :t concatMap . replicate 2
12:37:51 <lambdabot>     Couldn't match expected type `a -> [b]'
12:37:51 <lambdabot>            against inferred type `[a1]'
12:37:56 <ac> I'm blown away by how concise my program is so far
12:38:03 <newsham> > concat (map (\x -> [toUpper x, x]) "testing")
12:38:05 <lambdabot>  "TtEeSsTtIiNnGg"
12:38:07 <Japsu> and concatMap = concat . map
12:38:20 <dmwit> :t concatMap (replicate 2)
12:38:22 <lambdabot> forall a. [a] -> [a]
12:38:52 <dmwit> Nice, I like concatMap over (>>=) in this case.
12:39:16 <newsham> yah, concatMap might make more reading sense
12:40:54 <ac> concatMap won't work in my case because I process two at a time
12:41:25 <dmwit> What do you mean by that?
12:41:54 <ac> I mean the function you pass to concatMap only takes one argument at a time from the input list
12:41:58 <ac> mine needs two
12:42:13 <ac> so I need >>=, right?
12:42:27 <dmwit> (>>=) = flip concatMap
12:42:45 <dmwit> If you need two arguments, zip it with its tail.
12:43:02 <ac> oh no. another construct... what's zip?
12:43:05 <dmwit> > let pairs xs = zip xs (tail xs) in pairs [1,2,3,7,9]
12:43:07 <lambdabot>  [(1,2),(2,3),(3,7),(7,9)]
12:43:16 <dmwit> Oh, don't worry about zip!
12:43:19 <ac> oh I get it
12:43:19 <dmwit> It's easy!
12:43:20 <ac> that's simple
12:43:34 <dmwit> > zip [1,2,3,6,7] ["hey", "ho", "the", "dairy", "oh"]
12:43:35 <lambdabot>  [(1,"hey"),(2,"ho"),(3,"the"),(6,"dairy"),(7,"oh")]
12:44:45 <allbery_b> <pedant> "derry-o" </pedant>
12:45:06 <dmwit> haha, sorry
12:45:08 <lament> I never close <pedant> tags. I just nest them.
12:45:52 <ac> lament: does that mean you just get more and more pedantic?
12:45:58 <lament> Yes.
12:46:12 <ac> lament: wouldn't you suffer from some sort of stack overflow eventually?
12:46:42 <dmwit> Humans have very large stacks.
12:46:43 <lament> no, because i'm lazy.
12:46:52 <ac> saw that one coming
12:47:00 <phobes> Why are undecidability results always stated as e.g. "*If* ZFC is consistent, then it is incomplete"?
12:47:31 <dmwit> Does completeness make sense for inconsistent axiom systems?
12:47:47 <lament> phobes: we would like to think it's consistent.
12:48:05 <lament> but we can't prove it, so...
12:48:15 <liyang> dmwit: not sure about that. We just don't know it when our stacks overflow.
12:48:34 <phobes> lament:  My point is that you never see people stating theorems like "If ZFC is consistent, then this theorem in algebra is true"
12:49:31 <lament> phobes: perhaps because if ZFC is inconsistent, the theorem is still true? :)
12:49:38 <phobes> exactly :)
12:49:56 <phobes> err no, you're making another point
12:50:15 <phobes> My point is that most results are proven in something like ZFC
12:50:17 <Olathe> @src break
12:50:18 <lambdabot> break p =  span (not . p)
12:50:24 <Japsu> hmm?
12:50:26 <Japsu> @type break
12:50:29 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:50:32 <Japsu> @index break
12:50:33 <lambdabot> Data.List, Prelude
12:50:34 <Japsu> ah
12:50:36 <Japsu> cool
12:50:44 <phobes> (maybe they're not proven formally, but they often rely on ZFC-esque reasoning)
12:50:45 <Olathe> > break (== 0) [1, 2, 0, 5, 1]
12:50:50 <lambdabot>  ([1,2],[0,5,1])
12:50:53 <Japsu> > break (== ",") "hey, look"
12:50:54 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
12:51:01 <Japsu> > break (== ',') "hey, look"
12:51:02 <lambdabot>  ("hey",", look")
12:51:19 <Japsu> @index split
12:51:19 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.TH.Ppr, System.Random
12:51:19 <dmwit> > "(" -- is this fixed yet?
12:51:20 <lambdabot>  Unbalanced parenthesis
12:51:22 <Olathe> @src span
12:51:22 <lambdabot> Source not found. Take a stress pill and think things over.
12:51:27 <dmwit> > "(" -- how about now)
12:51:28 <Japsu> Hmm
12:51:29 <lambdabot>  "("
12:51:33 <dmwit> > -- =(
12:51:34 <lambdabot>  Unbalanced parenthesis
12:51:37 <Olathe> @hoogle span
12:51:37 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
12:51:37 <lambdabot> Data.PackedString.spanPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
12:51:37 <lambdabot> Text.Html.colspan :: Int -> HtmlAttr
12:51:50 <Japsu> is there a string split operation?
12:52:05 <Japsu> also known as explode for those tainted by perl
12:52:06 <lament> phobes: relying on ZFC is not the same as relying on its being consistent
12:52:12 <dmwit> ?hoogle [a] -> [[a]]
12:52:13 <lambdabot> List.inits :: [a] -> [[a]]
12:52:13 <lambdabot> List.tails :: [a] -> [[a]]
12:52:13 <lambdabot> List.group :: Eq a => [a] -> [[a]]
12:52:31 <dmwit> Japsu: Well, there's at least words and lines.
12:52:32 <Japsu> ?hoogle [a] -> [a] -> [[a]]
12:52:32 <lambdabot> No matches, try a more general search
12:52:33 <Olathe> @hoogle [a] -> [[a]] -> [[[a]]]
12:52:33 <lambdabot> No matches, try a more general search
12:52:39 <phobes> lament:  But if it's not consistent, then you can prove anything with it, so...
12:52:43 <lament> phobes: if ZFC is inconsistent, the theorem in algebra is still true (because we have proof. But then, it's opposite is presumably also true)
12:52:49 <Japsu> dmwit: yeah well, they cover 95% of the cases, but sometimes I also need to split by ", "
12:53:02 <lament> phobes: but if ZFC is inconsistent, then the theorem about ZFC being incomplete doesn't work.
12:53:06 <ttfh> q
12:53:14 <Japsu> so a general split function would be cool
12:53:26 <lament> *its opposite
12:53:43 <phobes> the theorem and its opposite are both true?  eh?
12:53:51 <dmwit> Japsu: Have you looked in the regex libraries?  I seem to remember something in there...
12:53:53 * dmwit goes hunting
12:53:54 <phobes> For true = provable in ZFC?
12:54:01 <lament> phobes: right...
12:54:09 <Japsu> dmwit: I don't even need it for regexen, just for string delimiters for starters
12:54:13 <dmwit> :t splitRegex
12:54:14 <lament> phobes: true = provable from axioms
12:54:15 <lambdabot> Not in scope: `splitRegex'
12:54:21 <Japsu> @index splitRegex
12:54:21 <lambdabot> Text.Regex
12:54:27 <Japsu> Hmm
12:54:40 <lament> phobes: inconsistent axioms => a whole bunch of useless true stuff
12:54:45 <phobes> lament:   But if ZFC is inconsistent, then the theorem about ZFC being incomplete is still true in ZFC, right?
12:55:10 <Japsu> @type splitAt
12:55:12 <lambdabot> forall a. Int -> [a] -> ([a], [a])
12:55:14 <lament> phobes: no, because it assumes consistency for its proof to work
12:55:15 <Japsu> :o
12:55:29 <Japsu> ?hoogle split
12:55:30 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
12:55:30 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
12:55:30 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
12:55:35 <phobes> lament:  But if ZFC is inconsistent, then every statement in ZFC is true :)
12:56:20 <dmwit> http://julipedia.blogspot.com/2006/08/split-function-in-haskell.html
12:56:20 <lament> phobes: i guess you have to look at the theorem and see what exactly it does
12:56:22 <lambdabot> Title: The Julipedia: A split function in Haskell, http://tinyurl.com/fhss7
12:56:57 <Japsu> ok thanks
12:57:01 <Olathe> @src words
12:57:01 <lambdabot> words s = case dropWhile isSpace s of
12:57:01 <lambdabot>     "" -> []
12:57:01 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:57:01 <Japsu> @src words
12:57:01 <lambdabot> words s = case dropWhile isSpace s of
12:57:02 <lambdabot>     "" -> []
12:57:03 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:57:04 <Japsu> lol
12:57:06 <sendo> does _ serve as a wildcard variable, as in, a variable i wont mention in a funciton but that i want to pass to another? like in prolog?
12:57:10 <dmwit> Japsu: Actually, the one I was looking for is actually this:
12:57:17 <dmwit> http://gimbo.org.uk/blog/2007/04/20/splitting-a-string-in-haskell/
12:57:19 <lambdabot> Title: gimboland  Python-style string split (and strip / trim) in Haskell, http://tinyurl.com/344k4u
12:57:28 <Olathe> sendo: It's an argument that's completely ignored.
12:57:32 <Japsu> hmm
12:57:39 <Olathe> sendo: You can't pass it on.
12:57:40 <sendo> nice.
12:57:49 <Japsu> though writing one myself would be trivial, given the source of words
12:57:55 <sendo> ok so i'll just invent yet another variable name
12:57:56 <sendo> cheers.
12:58:01 <Japsu> at least for single-char delims
12:58:25 <Olathe> > "" == []
12:58:27 <lambdabot>  True
12:58:42 <Japsu> ok cool, http://gimbo.org.uk/blog/2007/04/20/splitting-a-string-in-haskell/ has a String -> String -> [String] split
12:58:44 <lambdabot> Title: gimboland  Python-style string split (and strip / trim) in Haskell, http://tinyurl.com/344k4u
12:59:05 <Olathe> sendo: You can be evil and use @pl
12:59:09 <Japsu> unfoldr... gaah... hurt.. brain
12:59:19 <Japsu> @source unfoldr
12:59:19 <lambdabot> unfoldr not available
12:59:24 <Japsu> @src unfoldr
12:59:24 <lambdabot> unfoldr f b  = case f b of
12:59:24 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
12:59:24 <lambdabot>    Nothing        -> []
12:59:35 <Olathe> @pl \a b -> b*(otherfunc a)
12:59:35 <lambdabot> (*) . otherfunc
12:59:45 <Don_> @src asks
12:59:45 <lambdabot> asks f = do
12:59:45 <lambdabot>     r <- ask
12:59:45 <lambdabot>     return (f r)
12:59:45 <Olathe> No need for argument names.
13:00:03 <Japsu> @src ask
13:00:03 <lambdabot> Source not found. You speak an infinite deal of nothing
13:00:12 <Olathe> @src @src
13:00:12 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:00:18 <dmwit> ?quote ?quote
13:00:19 <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"Invalid preceding regular expression")
13:00:22 <Japsu> So hmm
13:00:35 <Olathe> ?quote \?quote
13:00:35 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
13:00:41 <Japsu> oh, cool
13:00:42 <dmwit> Japsu: Still stuck on unfoldr?
13:00:46 <Japsu> Nope
13:00:48 <Japsu> level up
13:00:51 <dmwit> =)
13:00:53 <Japsu> ;)
13:01:02 <Japsu> That kinda illustrates unfoldr pretty well
13:01:35 <Japsu> but hmm
13:01:50 <Japsu> ah, no, break works on an element-by-element basis
13:02:21 <Japsu> and with lists, not maybes
13:06:20 <newsham> ?remember lament I never close <pedant> tags. I just nest them.
13:06:20 <lambdabot> Done.
13:09:50 <Japsu> I never open </troll> tags, I leave that to the reader
13:09:59 <Japsu> ;)
13:10:14 <dmwit> > unfoldTree (\x -> ((), replicate 2 x) 1
13:10:14 <lambdabot>  Unbalanced parenthesis
13:10:24 <Olathe> > <troll>
13:10:24 <lambdabot>  Parse error
13:10:26 <dmwit> > unfoldTree (\x -> ((), replicate 2 x)) 1
13:10:27 <Japsu> no, wait! I never open </troll> tags, I have an infinite supply of them open anyway
13:10:34 <lambdabot>  Node {rootLabel = (), subForest = [Node {rootLabel = (), subForest = [Node {...
13:11:33 <newsham> JAPSU(1)   ARGUMENTS  Japsu is never invoked without an argument.
13:11:43 <Japsu> ;D
13:12:35 <Japsu> hmm
13:12:37 <Japsu> @type unfoldr
13:12:39 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:13:07 <newsham> blatently stolen from NeTw1z man page at: http://www.phrack.org/issues.html?issue=36&id=2
13:13:09 <lambdabot> Title: .:: Phrack Magazine ::.
13:13:33 <Japsu> if I were to write one that used lists instead of Maybe, that'd be "(b -> ([a], [b]) -> b -> [a]", right?
13:13:50 <Japsu> aaand
13:13:52 <Japsu> @type break
13:13:54 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:14:16 <dmwit> :t Data.Tree.unfoldTree -- this is what it would really look like.
13:14:17 <Japsu> hmm
13:14:18 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
13:14:21 <Japsu> oh
13:14:21 <Japsu> right
13:14:35 <Don_> :t ask
13:14:37 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
13:14:46 <Japsu> someone brought up unfoldTree but I kinda missed it back then
13:15:46 <dmwit> I think unfoldr is mainly unused because "iterate" is so similar.
13:15:49 <dmwit> :t iterate
13:15:51 <lambdabot> forall a. (a -> a) -> a -> [a]
13:17:31 <dmwit> :t \f -> unfoldr (\x -> (x, Just (f x)))
13:17:33 <lambdabot>     Couldn't match expected type `Maybe (a, b)'
13:17:33 <lambdabot>            against inferred type `(a1, b1)'
13:17:45 <newsham> seems lots of people use iterate and takeWhile to do unfolds
13:17:53 <dmwit> yeah
13:18:24 <newsham> maybe if there were more tools for Maybe, unfoldr would be more popular
13:18:48 <newsham> like  if p x then Just (f x) else Nothing
13:18:53 <bos> more tools for Maybe?
13:18:54 <dmwit> :t \f -> unfoldr (\x -> Just (x, f x))
13:18:56 <lambdabot> forall b. (b -> b) -> b -> [b]
13:19:20 <newsham> most unfolds use a function like:   if p x then Just (f x) else Nothing
13:20:13 <Olathe> Maybe Tool = Just Tool | Nothing
13:20:32 <Mr_Awesome> why does pl keep introducing monadic functions?
13:20:43 <dmwit> I guess there aren't many functions for creating Maybe's.
13:20:49 <Olathe> Because @pl is evil.
13:20:56 <dmwit> There's lots of functions for consuming them, though. =)
13:20:58 <sjanssen> @hoogle when
13:20:58 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
13:20:58 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
13:21:05 <Japsu> we need a real @obfuscate instead of @pl ;)
13:21:48 <idnar> but @pl is cool, it's like subterfuge
13:22:11 <idnar> it has an innocent explanation for everything it does :P
13:22:17 <newsham> > unfoldr (\x -> if x /= 0 then Just (x `mod` 10, x `div` 10) else Nothing) 123
13:22:19 <dmwit> :t \f p x -> if p x then return (f x) else mzero
13:22:19 <lambdabot>  [3,2,1]
13:22:20 <lambdabot> forall t a (m :: * -> *). (MonadPlus m) => (t -> a) -> (t -> Bool) -> t -> m a
13:22:39 <newsham> unfoldr doesnt really make that a lot easier than the recursive solution
13:24:10 <newsham> ?pl \x -> (x `mod` 10, x `div` 10)
13:24:10 <lambdabot> liftM2 (,) (`mod` 10) (`div` 10)
13:24:29 <newsham> ?pl \x -> let (d,m) = x `divMod` 10 in (m,d)
13:24:30 <lambdabot> (line 1, column 11):
13:24:30 <lambdabot> unexpected "("
13:24:30 <lambdabot> expecting natural, identifier or "in"
13:24:48 <Olathe> @unpl line-noise
13:24:48 <lambdabot> (line - noise)
13:25:08 <dmwit> > let toMaybe f p x = if p x then return (f x) else mzero in unfoldr (toMaybe (divMod 10) (/= 0)) 123
13:25:10 <lambdabot>  [0,1]
13:25:16 <dmwit> > let toMaybe f p x = if p x then return (f x) else mzero in unfoldr (toMaybe (flip divMod 10) (/= 0)) 123
13:25:17 <lambdabot>  [12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:25:23 <dmwit> :t divMod
13:25:25 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
13:25:41 <dmwit> > 123 `divMod` 10
13:25:43 <lambdabot>  (12,3)
13:25:51 <dmwit> Oh.
13:26:11 <Olathe> takeWhile
13:27:25 <dmwit> > let toMaybe f p x = if p x then return (f x) else mzero; modDiv x y = (y `mod` x, y `div` x) in unfoldr (toMaybe (modDiv 10) (/= 0)) 123
13:27:26 <lambdabot>  [3,2,1]
13:28:18 <dmwit> That seems mildly mind-bending compared to the divMod/takeWhile approach.
13:28:29 <hpaste>  newsham pasted "unfoldr decimal" at http://hpaste.org/3086
13:29:02 <MyCatVerbs> :t unfoldr
13:29:04 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:29:08 <dmwit> newsham: Yeah, basically what I came up with, too.
13:29:28 <dmwit> I like your name "guarded" better, though.
13:29:28 <newsham> return/mzero better.  good idea.
13:30:17 <newsham> guarded matches funmath's abstraction:    x : X /.\ p x = e
13:30:26 <MyCatVerbs> > join $ Just $ Just $ 4
13:30:27 <newsham> (been reading funmath lately)
13:30:27 <lambdabot>  Just 4
13:31:03 <Don_> hi, i'm reading "roll your own IRC bot" on haskell.org
13:31:25 <Don_> and having some trouble understanding what function "asks" from Reader monad does
13:31:42 <newsham> item 1 under syntax: http://www.funmath.be/LRRL.pdf
13:31:47 <dmwit> Don_: It just gets the value stored in the monad and applies a function to it.
13:32:07 <newsham> asks f is f composed with ask
13:32:19 <dmwit> asks f = liftM f ask, I think.
13:32:40 <newsham> data Foo = Foo { f1 :: String, f2 :: Int },   then   "asks f1" gets you f1 if your state is Foo
13:33:10 <Don_> thanks! how simple is that ;)
13:33:15 <newsham> yah, i'm being fast/loose with my words.  the liftM kinda compose :)
13:33:47 <dmwit> newsham: Aha, I was a bit confused for a moment; the first hit on Google for funmath is... less advanced. =)
13:34:00 <newsham> yah, not the first hit :)
13:34:01 <Olathe> @pl produces if', but > can't use it.
13:34:01 <lambdabot> (line 1, column 13):
13:34:01 <lambdabot> unexpected ","
13:34:01 <lambdabot> expecting variable, "(", operator or end of input
13:34:24 <dmwit> Olathe: Right, it's defined in the module for @pl.
13:34:28 <Olathe> How do I get @pl to produce things without if' ?
13:34:34 <dmwit> if' p x y = if p then x else y
13:35:22 <newsham> came across funmath here: https://cgi.cse.unsw.edu.au/~cs4181/07s2/cgi-bin/moin.cgi/Schedule
13:35:24 <lambdabot> http://tinyurl.com/2kt7qz
13:35:26 <Don_> newsham: perhaps you could submit some documentation, because I didn't find any text Control.Monad.Reader
13:35:42 <Don_> any text in help *for*
13:36:00 <dmwit> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
13:36:02 <lambdabot> http://tinyurl.com/y5j3az
13:36:11 <dmwit> ?docs Control.Monad.Reader
13:36:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
13:36:28 <Don_> yes, I was reading that before I asked about "asks"
13:36:32 <dmwit> ...oh, I see what you mean.
13:36:36 <dmwit> It's a bit empty, hey?
13:36:39 <Don_> yep
13:36:48 <Don_> unfortunately
13:37:11 <newsham> don: there's more information in the State docs than in the Reader docs: http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Class.html
13:37:13 <lambdabot> http://tinyurl.com/yuyeqp
13:37:28 <newsham> "gets" is similar to "asks"
13:38:42 <Don_> as you've probably guessed already, I'm a beginner with Haskell, so pardon my ignorance -
13:38:56 <Don_> is a State monad a specfic kind of a Reader monad?
13:39:01 <sendo> ?hoogle type Name = String
13:39:01 <lambdabot> hoogle: Hoogle.Parser.readType: ([type,Name,=,String],BItem =)
13:39:01 <lambdabot>  
13:39:11 <dino-> @paste
13:39:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:39:22 <newsham> State lets you read and write state where Reader lets you read state.
13:39:33 <newsham> also no need to pardon your ignorance. :)
13:39:37 <dmwit> The State monad allows "put" and "get", Reader allows only "get", and Writer allows only "put".
13:39:40 <newsham> the docs could definitely be better
13:39:51 <dmwit> But Reader/Writer have different names for their actions. ;-)
13:40:30 <newsham> > runState (do { x <- get; put (x+1); return (3*x)}) 5
13:40:31 <sendo> i get a parse error on the line "type Name = String"
13:40:35 <lambdabot>  (15,6)
13:40:59 <hpaste>  dino- pasted "STM problem" at http://hpaste.org/3087
13:41:11 <newsham> > runReader (do {x <- ask; return (3*x)}) 5
13:41:12 <lambdabot>  15
13:41:20 <dino-> I'm trying to learn about STM using SPJ's chapter in _Beautiful Code_
13:41:20 <dmwit> sendo: You may have an error before that line.
13:41:26 <sendo> oki
13:41:45 <Don_> thanks, newsham
13:41:46 <dino-> Specifically, writing some code which will wait for forkIO'd children to finish before the program ends.
13:41:55 <dino-> But it's not working as expected and I'm not sure why.
13:41:57 <dmwit> sendo: Specifically, check your indentation.
13:42:20 <sendo> Prelude> type LineLabel = String
13:42:21 <sendo> <interactive>:1:0: parse error on input `type'
13:42:30 <sendo> even if i do it on the command line
13:42:34 <dino-> I'm wondering if anyone here can help.
13:42:51 <dmwit> sendo: I don't think you can declare type synonyms in GHCi.
13:42:53 <newsham> > runReader (asks (*3)) 5
13:42:54 <lambdabot>  15
13:43:00 <dmwit> Try putting it in a file and loading the file instead.
13:43:34 <sendo> yea that is what i was trying
13:43:39 <sendo> lets see
13:45:21 <TSC> dino-: Is the problem that the watcher finishes too early?
13:45:29 <dino-> TSC: yes
13:47:36 <newsham> when is UNSW gonna follow MIT and Berkeley and start putting video lectures online?
13:49:44 <TSC> dino-: I think the problem is that there's a race condition
13:49:44 <Botje> why bother? just strap a camera to dons and have it run 24/7
13:49:56 <byorgey> the donscam!
13:50:00 <TSC> dino-: The counter starts at zero, so the watcher returns immediately
13:50:46 <dino-> TSC: That makes sense, the messages from the watcher output first, before the children messages. (if that's even any indication of anything)
13:51:06 <hpaste>  TSC annotated "STM problem" with "changes" at http://hpaste.org/3087#a1
13:51:20 <TSC> If I make those changes in the annotation, it works correctly (I think)
13:53:13 <dino-> Hm, but I want many children.
13:53:29 <dino-> A simple non-zero counter may not work here.
13:54:06 <TSC> I didn't mean that as a proper solution; it's just to demonstrate breaking the race
13:54:09 <dino-> :)
13:54:42 <TSC> What exactly is the behaviour you want?
13:55:06 <TSC> You have lots of children, and you want to stop when all of them have stopped, but only after at least one has started?
13:55:27 <dino-> TSC: Right, many children. All of them finished before the program quits.
13:55:49 <dino-> sorry
13:56:09 <dino-> Many children, running different lengths of time. Program to wait for all of them to finish before ending.
13:56:29 <newsham> botje: dons not at unsw, also i want to see chakravarty's comp4181 course
13:57:25 <newsham> (i would also tune into doncam ;-)
13:57:46 <dino-> Certainly, if this is a poor way to approach this type of requirement, design advice would be exellent.
13:57:54 <TSC> dino-: Put the incrCounter before the forkIO
13:57:56 <dino-> <- not a thread master
13:58:02 <TSC> Then you eliminate the race condition
13:58:17 <TSC> I'm no thread master (seamstress?) either
13:58:23 <dino-> :D
13:58:38 <dino-> huh, I hadn't thought about that, outside the new process.
14:00:16 <Olathe> Forum moderator
14:00:43 <TSC> Yep, that seems to fix it
14:01:32 <dino-> TSC: That's terrific. Thank you very much.
14:01:42 <dino-> You are most definitely the threadmistress. Oh yes.
14:02:34 <TSC> Ah, "seamster" is the word I wanted (:
14:02:39 <dino-> heh
14:02:56 <lament> seamstress, as in, a member of the seamstresses' guild?
14:03:00 <Olathe> tailor
14:04:00 <dino-> I'm working towards a more complex problem though, where these children may spawn their own and 'main' must wait for everthing to stop.
14:04:13 <dino-> Which I realize is not going to be solved by this either.
14:04:54 <sendo> can i define a list over many lines? something like:
14:05:03 <sendo> let x = [ 1,
14:05:04 <TSC> dino-: I think this way should still work
14:05:09 <sendo>              2,
14:05:18 <sendo>                  3]
14:05:22 <sendo> like that?
14:05:29 <byorgey> sendo: sure
14:05:37 <TSC> As long as one child is still running, the watcher will wait
14:05:43 <dino-> The won't be able to until they're in their forked process though.
14:05:43 <sendo> well ghci gets angry at me!
14:05:45 <dino-> ya
14:05:54 <byorgey> sendo: well, sometimes you have to be careful with breaking things up over lines and indentation
14:05:59 <sendo> parse error (possibly incorrect indentation)
14:06:22 <byorgey> sendo: are you trying to type it into ghci, or load it from a file into ghci?
14:06:48 <sendo> load from a file
14:06:53 <sendo> i know typing wont work.
14:07:25 <byorgey> sendo: it may be that you have to line up the list elements underneath one another
14:07:34 <byorgey> I know I've written lists over several lines before
14:07:46 <sendo> i've done it to the best of my knowledge
14:07:48 <sendo> i'll have a look.
14:08:17 <byorgey> sendo: if you can't figure it out easily, try pasting the code on hpaste
14:09:57 <sendo> how does hpaste work?
14:10:06 <sendo> ?hpaste
14:10:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:10:10 <sendo> nice
14:11:40 <hpaste>  sendo pasted "list of nodes" at http://hpaste.org/3088
14:14:11 <hpaste>  sendo pasted "full list" at http://hpaste.org/3089
14:15:31 <omnIdiot> sendo: do you have this declaration at top level?
14:15:51 <omnIdiot> delete the 'let' if so.
14:17:49 <sendo> nope
14:17:54 <sendo> its at the end of the code
14:18:21 <omnIdiot> I don't get a parse error if I put it in a file and delete the let.
14:18:54 <sendo> cool it works
14:18:55 <yrlnry> In HUGS, can I bind a name to a value at the prompt, or do I have to put the definition in a file and then :load the file?
14:19:20 <byorgey> "at the top level" meaning not a part of another definition, not "at the top of the file"
14:19:40 <omnIdiot> sendo: lets are expressions.  They introduce local names in the context of another expression, not a toplevel declaration.
14:19:48 <omnIdiot> toplevel declarations have already been introduced by the 'module Blah where ...' at the top of the module.
14:20:13 <omnIdiot> (which is inserted if omitted)
14:20:41 <omnIdiot> (with the name 'Main', btw)
14:21:02 <yrlnry> Also, is it that case that \f -> (f $) is exactly the identity function?
14:21:14 <omnIdiot> ($) = id
14:21:19 <yrlnry> Okay, thanks.
14:21:26 <omnIdiot> (\f -> ($) f) = ($)
14:22:13 <yrlnry> Yesterday, monochrom suggested a change to a program that involved replacing func a b   with seq a $ func a b.  Why not replace it with seq a (func a b) ?
14:22:36 <omnIdiot> $ has low fixity, so you can use it to omit parens.
14:22:37 <monochrom> I seldom write $ actually.
14:22:58 <monochrom> I actually wrote seq a (func a b) IIRC.
14:23:28 <yrlnry> I'm pretty sure you didn't, because I wouldn't have had to look up ($) in the manual if you had done that.  :)
14:23:59 <yrlnry> But thanks, that answers my question.
14:24:35 <omnIdiot> I tend to avoid using ($) when teaching something, it's just one more thing for a newbie to worry over.  They're usually familiar with parens :)
14:24:36 <monochrom> Damn. I used $ yesterday indeed.
14:25:01 * monochrom goes revise history to cover up the coup.
14:25:11 <yrlnry> That's okay, now I know about ($).
14:25:18 <yrlnry> Thanks again.
14:25:39 <omnIdiot> it's also right-associative, so (f $ g $ x) = (f $ (g $ x)) = (f (g x))
14:26:46 <byorgey> but it shouldn't be =)
14:27:06 <omnIdiot> nobody mention Cal*!
14:27:10 <byorgey> hehe
14:27:28 <monochrom> It should read your eye motions to find out how you want them grouped.
14:27:41 <yrlnry> If you consider (.) as an abbreviation for \x y z. x (y z), is there a standard abbreviation for \x y z -> y (x z)  ??
14:28:01 <byorgey> yrlnry: yes, flip (.)
14:28:09 <omnIdiot> f (g x) = f $ g x = (f . g) x = f . g $ x
14:28:14 <monochrom> >>> is becoming popular.
14:28:23 <byorgey> oh yeah, that too =)
14:28:31 <omnIdiot> (>>>) (for functions) is flip (.)
14:28:42 <omnIdiot> so (f >>> g) = (g . f)
14:28:51 <monochrom> Note that >>> is very general, i.e., works for all "Arrows", not just functions.
14:29:02 <yrlnry> Okay, I know something about arrows.
14:29:13 <byorgey> @type (>>>)
14:29:21 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
14:29:22 <omnIdiot> 'a' here is (->)
14:29:40 <omnIdiot> so (->) b c -> (->) c d -> (->) b d
14:29:47 <yrlnry> * -> * -> * is a "kind", right?
14:29:50 <omnIdiot> yep
14:29:57 <omnIdiot> (->) takes two types
14:30:05 <omnIdiot> each type has kind *
14:30:29 <yrlnry> OK, must go.  Thanks again.
14:30:34 <monochrom> happy joy
14:30:47 <byorgey> monochrom: ?
14:31:58 <monochrom> Aren't you happy joy that another programmer begins to like haskell or at least us? :)
14:32:28 <omnIdiot> It seemed like you were saying "happy joy" at "I have to go."
14:32:35 <byorgey> monochrom: yes, of course =)
14:32:38 <omnIdiot> "Good riddance!"
14:32:54 <monochrom> I cannot prove or disprove the latter conjecture. :)
14:46:05 <xelxebar> why are lists implemented via monads? is it simply to allow list comprehensions?
14:46:24 <oerjan> they are not
14:46:34 <oerjan> lists are one instance of monad
14:46:54 <oerjan> lists are simply an algebraic data type
14:46:58 <oerjan> @src []
14:46:58 <lambdabot> data [] a = [] | a : [a]
14:47:14 <oerjan> (that's not legal haskell, only an intuitive definition)
14:47:42 <xelxebar> oh, okay.  however >>= if defined for lists as m >>= k = concat (map k m)
14:47:50 <oerjan> in haskell 1.4, comprehensions were generalized to all monads
14:48:09 <xelxebar> oh, okay
14:48:21 <oerjan> but it was removed to reduce incomprehensible type errors
14:48:49 <oerjan> (for people using them on lists and not expecting messages about monads)
14:49:03 <xelxebar> makes sense
14:49:22 <oerjan> there are talk about adding it back as an option
14:49:34 <oerjan> (probably with some compiler flag)
14:49:43 <oerjan> *is talk
14:50:16 <xelxebar> is this 'talk' fairly substantial inasmuch as we could expect it in the near future?
14:50:57 <oerjan> apparently it only requires someone to be brave enough to dive into the relevant ghc code and change it.
14:52:38 <oerjan> in any case, it would be just an equivalent alternative to do syntax, which some people like better in some cases
14:53:31 <oerjan> (er, "which" referring to comprehensions)
14:58:24 <desp> hmm
14:58:37 <desp> there's a vaguely Haskell-related job opening in my city
14:58:58 <desp> but the descriptions rings a ton of alarm bells in my head
14:59:00 <desp> http://careers.nokiasiemensnetworks.com/hr/recru.nsf/vwJobs/E830EF0394D9566FC2257333002FB484
14:59:04 <lambdabot> Title: Rule-module developer for Project view, http://tinyurl.com/yvwtqa
14:59:14 <desp> what do you guys think?
14:59:45 <desp> will this crush my soul?
15:01:00 <dmwit> MARKETROID ALERT
15:02:13 <desp> yeah
15:03:13 <xelxebar> it sounds too enthusiastic, though maybe you should check it out a little.  It doesn't hurt to apply - you can always decline if you get accepted and don't want the job.
15:03:39 <olsner> plus it's been newline-munged into oblivion... it's mostly unreadable as it is
15:03:47 <desp> true
15:04:09 <olsner> "These configurators are the guidedance ..."
15:04:54 <olsner> but it involves haskell!
15:05:27 <xelxebar> that's definitely a trup card
15:06:27 <dmwit> No it's not!
15:06:35 <dmwit> Soul-crushing jobs crush souls in every language.
15:06:39 <Olathe> Yes it isn't !
15:06:52 <dmwit> It's really nice that it uses Haskell, but I don't think it's the only possible deciding factor...
15:07:22 <dmwit> (The description doesn't sound all that bad to me.  I'm just playing devil's advocate.)
15:08:06 <olsner> I think it's been written by a swede (or a fin, considering the nokia in the domain) ... Civil Engineer in english means builder of bridges and roads and stuff, right?
15:08:19 <dmwit> yes
15:08:20 <xelxebar> well, usually it helps to talk to someone in person.  I've found that doing that can give a better indicator of job satifiability
15:08:27 <desp> olsner: that's what I thought
15:09:03 <olsner> haskell wouldn't be too well-known in that field :P
15:09:53 <oerjan> 100% safe bridges and roads, with NO side effects!
15:11:52 <olsner> arrange to have yourself cloned on the other side of the bridge - it's not fast, but you won't have to worry about the bridge falling down under you!
15:13:30 <Cale> http://programming.reddit.com/info/2wjai/comments/c2womz ;)
15:13:31 <lambdabot> Title: Defanging the multi-core werewolf (reddit.com)
15:14:22 <olsner> (but as usual, there's always some way to mutate... call it ionizing radiation, call it unsafePerformIO)
15:14:51 <Cale> unsafePerformIO "doesn't exist", though :)
15:15:40 <Cale> I consider unsafePerformIO as just being a way to modify GHC without having to recompile it.
15:16:06 <Cale> (or other Haskell implementations)
15:16:48 <lament> waitForRiverToDry >> crossLand
15:18:10 <olsner> lament: I'll forkIO and floodRiver
15:18:50 <lament> on a geological time scale, your flood is irrelevant.
15:18:56 <lament> Just wait till the next glaciation.
15:20:49 <olsner> lament: oh, so you meant waitForRiverToDry >> growGills >> crossLand?
15:21:08 <Botje> wait, how do Gills help with crossLand?
15:21:31 <olsner> Botje: you missed what I did in the other thread
15:22:13 <Botje> i did? :p
15:22:25 <FMota> oh wow.
15:22:34 <FMota> I believe I have had some sort of revelation
15:22:52 <olsner> Botje: you see? shared-state parallelism is bad for your health!
15:23:08 <lament> (waitForRiverToDry >> crossLand)`orElse` (growGills >> crossWater)
15:23:15 <Botje> :)
15:23:19 <lament> much better!
15:23:45 <FMota> lisp-like regularity and parens, but what's inside the parens makes for a very interesting programming syntax -- and ultimately language
15:24:32 <lament> sounds like... lisp?
15:24:39 <FMota> nope!
15:25:03 <FMota> the syntax is smalltalk-like, from what little smalltalk I've seen
15:25:29 <FMota> instead of parens being used for lists, the parens are there for table
15:25:30 <FMota> *tables
15:25:49 <FMota> which are kind of like python dictionaries, but they can have a name.
15:26:39 <MyCatVerbs> http://blogs.msdn.com/ericlippert/archive/2007/10/04/path-finding-using-a-in-c-3-0-part-two.aspx <-- saw this on reddit today.
15:27:16 <FMota> i.e.    (def fact n as: (fact n times: 1))
15:27:18 <MyCatVerbs> Surely I'm not the only one here thinking, "Duh, that exactly fits the description of linked lists in Haskell."?
15:28:16 <FMota>       (def (fact n times: t) as: (if n = 0 then: t else: (fact n-1 times: t*n)))
15:28:28 <FMota> It looks nice with newlines in there. :)
15:30:01 <FMota> now, I obviously need to find an appropriate name :/
15:30:16 <olsner> astrolabe: (if)
15:30:22 <olsner> wtf, auto-tab
15:30:24 <MyCatVerbs> FMota: "jabberwocky"
15:30:29 <olsner>  as: if
15:30:32 <FMota> lol :)
15:30:39 <MyCatVerbs> FMota: that name is appropriate in all situations, provided no one has beaten you to it first.
15:32:12 <newsham> ?pl \y x -> x*5+y
15:32:12 <lambdabot> (. (5 *)) . (+)
15:32:20 <newsham> ?pl \x y -> x*5+y
15:32:20 <lambdabot> (+) . (5 *)
15:32:31 <oerjan> lispy but no programming language: http://jabberwocky.sourceforge.net/
15:32:32 <lambdabot> Title: Jabberwocky
15:32:58 <FMota> lol.
15:34:41 <FMota> :o How about TAB?
15:34:43 <FMota> *tab
15:34:46 <olsner> or Jobberwacky (it's strange *and* mispeld)
15:34:57 <FMota> lol, olsner.
15:37:27 <olsner> btw, the swedish police is putting "data ships" in the special Schengen-compatible ID cards
15:39:47 <FMota> wow, data ships
15:46:28 <monochrom> What is a data ship? Is it a natural extension to the information superhighway?
15:48:19 <olsner> it's information supertankers these days
15:55:10 <fax> Hi
15:56:46 <Zao> What exactly has happened when my program terminates with 'progname: <<loop>>'?
15:57:15 <fax> I think it means an infinite loop
15:57:23 <fax> > let id = id in id id
15:57:25 <lambdabot>  Exception: <<loop>>
15:57:28 <oerjan> some expression depends recursively on itself, in a strict way
15:57:38 <Olathe> > <<loop>>
15:57:39 <lambdabot>  Parse error
15:57:44 <oerjan> > let id = id in id
15:57:45 <lambdabot>  Exception: <<loop>>
15:58:09 <oerjan> > let id = 1 + id in id -- strict function +
15:58:11 <Olathe> @pl let id = id in id
15:58:11 <lambdabot>  Exception: <<loop>>
15:58:11 <lambdabot> fix id
15:58:11 <Heffalump> precisely, I believe it means that the black-hole detector has triggered
15:58:18 <Olathe> > fix id
15:58:19 <lambdabot>  Exception: <<loop>>
15:58:22 <Olathe> Yay !
15:58:25 <oerjan> > let id = 1 : id in id -- nonstrict function :
15:58:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:58:41 <Olathe> > fix fix
15:58:42 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
15:58:42 <lambdabot>     Probabl...
15:58:44 <Olathe> > fix fix id
15:58:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
15:58:45 <lambdabot>     Probabl...
15:58:47 <Heffalump> which happens when you enter a thunk while evaluating that same thunk
16:00:17 <oerjan> : t fix . fix
16:00:21 <oerjan> :t fix . fix
16:00:23 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
16:00:31 <oerjan> :t fix . fix . fix
16:00:33 <lambdabot> forall a. (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> a
16:00:42 <fax> L-systems!
16:00:52 <Olathe> :t (fix . fix . fix) id
16:00:54 <lambdabot> forall a. a
16:01:15 <olsner> > (fix . fix . fix) id :: Int
16:01:17 <lambdabot>  Exception: <<loop>>
16:01:19 <fax> :t (!!2) iterate (fix .)
16:01:20 <lambdabot>     Couldn't match expected type `[t -> t1]'
16:01:20 <lambdabot>            against inferred type `(a -> a) -> a -> [a]'
16:01:22 <Olathe> @unpl (fix . fix . fix) id
16:01:22 <lambdabot> (fix (fix (fix (\ a -> a))))
16:01:26 <oerjan> :t (fix . fix) (join (.))
16:01:28 <lambdabot> forall a. a
16:01:37 <fax> damn
16:01:41 <EvilTerran> anything :: forall a. a has to be _|_, dunnit?
16:01:51 <fax> :t id
16:01:53 <lambdabot> forall a. a -> a
16:01:58 <Zao> Time to dig into the STM documentation then, I suppose :)
16:02:11 <Olathe> :t \a
16:02:13 <oerjan> :t iterate (fix .)
16:02:13 <lambdabot> parse error (possibly incorrect indentation)
16:02:14 <Olathe> :t \a -> a
16:02:16 <lambdabot> forall t. t -> t
16:02:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
16:02:17 <lambdabot>     Probable cause: `.' is applied to too many arguments
16:02:28 <EvilTerran> yeah, but that's significantly more specific than forall a. a
16:02:49 <fax> oerjan: can one make (fix . fix . fix . fix . fix . fix . fix . fix . fix) using fix and 9 ?
16:02:52 <Olathe> forall 6pm. sleep
16:03:01 <oerjan> EvilTerran: id or _|_
16:03:17 <Olathe> @src iterate
16:03:17 <lambdabot> iterate f x =  x : iterate f (f x)
16:03:19 <oerjan> or const _|_
16:03:21 <EvilTerran> i'm talking "forall a. a", not "forall a. a -> a"
16:03:28 <oerjan> er, yes
16:03:34 <fax> :t (fix . fix . fix . fix . fix . fix . fix . fix . fix
16:03:36 <lambdabot> parse error (possibly incorrect indentation)
16:03:38 <fax> :t (fix . fix . fix . fix . fix . fix . fix . fix . fix)
16:03:40 <lambdabot> forall a. (((((((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a ->
16:03:40 <lambdabot>  a) -> ((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (
16:03:40 <lambdabot> ((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((((a ->
16:03:40 <lambdabot>  a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((((((a -> a) ->
16:03:42 <lambdabot>  a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((((a -> a) -> a -> a)
16:03:44 <EvilTerran> good lord!
16:03:45 <lambdabot> [11 @more lines]
16:03:46 <fax> oh no
16:03:47 <fax> :(
16:03:51 <fax> phew
16:04:06 <Olathe> @hoogle (a -> a) -> Int -> (a -> a)
16:04:07 <lambdabot> No matches, try a more general search
16:04:17 <Olathe> @hoogle Int -> (a -> a) -> (a -> a)
16:04:18 <lambdabot> No matches, try a more general search
16:05:20 <oerjan> fax: i strongly doubt it :D
16:05:51 <oerjan> :t fix (fix .)
16:05:53 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
16:05:53 <lambdabot>     Probable cause: `.' is applied to too many arguments
16:05:58 <Heffalump> fax: no, because the type would depend on the 9.
16:06:11 <fax> Is that called a dependant type?
16:06:17 <oerjan> that would have to type check if (fix .) should be iterable
16:06:18 <fax> or is this something else
16:06:25 <oerjan> fax: i think so
16:06:41 <Heffalump> yes
16:07:49 <oerjan> maybe with higher rank types it would work?
16:08:20 <oerjan> if you made a list of type [forall a. (a -> a) -> a]
16:08:41 <oerjan> then you could probably fold it with .
16:08:51 <fax> can you do that in like template haskell or O'haskell or somehing?
16:09:00 <fax> (I haven't looked at any of those)
16:09:14 <oerjan> higher rank types are just a compiler flag i guess
16:09:34 <Heffalump> what type would you expect the result to have?
16:09:49 <oerjan> :t replicate 9 fix :: [forall a. (a -> a) -> a]
16:09:51 <lambdabot> [forall a. (a -> a) -> a] :: [forall a. (a -> a) -> a]
16:10:11 <oerjan> :t foldr (.) id (replicate 9 fix :: [forall a. (a -> a) -> a])
16:10:13 <lambdabot>     Couldn't match expected type `a -> a'
16:10:13 <lambdabot>            against inferred type `forall a1. (a1 -> a1) -> a1'
16:10:28 <Heffalump> you couldn't use (.), cos Haskell doesn't have impredicative polymorphism
16:10:48 <oerjan> :t foldr (.) (id :: forall a. (a -> a) -> a) (replicate 9 fix :: [forall a. (a -> a) -> a])
16:10:49 <Heffalump> actually, perhaps that's not true
16:10:50 <lambdabot>     Couldn't match expected type `a' (a rigid variable)
16:10:50 <lambdabot>            against inferred type `a -> a'
16:11:17 <oerjan> :t foldr (.) (id :: forall a. a -> a) (replicate 9 fix :: [forall a. a -> a])
16:11:19 <lambdabot>     Couldn't match expected type `a' (a rigid variable)
16:11:19 <lambdabot>            against inferred type `a1 -> a1'
16:12:00 <oerjan> might need to wrap the forall in a datatype?
16:12:03 <ddarius> Heffalump: My understanding is that 6.6.1 does but that 6.8 won't.
16:13:28 <Heffalump> if any version has it, it's just a left-to-right hack
16:13:36 <Heffalump> and it was removed pretty quickly
16:13:39 <fax> > fix show
16:13:41 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:13:44 <oerjan> :t foldr ((.)::forall a. (forall a. a -> a) -> a -> a) (id :: forall a. a -> a) (replicate 9 fix :: [forall a. a -> a])
16:13:46 <lambdabot>     Couldn't match expected type `forall a. a -> a'
16:13:46 <lambdabot>            against inferred type `b -> c'
16:14:03 <SamB_XP> what is this about "."?
16:14:36 <oerjan> :t foldr ((.)::forall a. (forall a. (a -> a) -> a) -> (forall a. (a -> a) -> a) -> (forall a. (a -> a) -> a)) (id :: forall a. a -> a) (replicate 9 fix :: [forall a. a -> a])
16:14:37 <lambdabot>     Couldn't match expected type `forall a. (a -> a) -> a'
16:14:37 <lambdabot>            against inferred type `b -> c'
16:15:15 <oerjan> :t foldr ((.):: (forall a. (a -> a) -> a) -> (forall a. (a -> a) -> a) -> (forall a. (a -> a) -> a)) (id :: forall a. a -> a) (replicate 9 fix :: [forall a. a -> a])
16:15:15 <fax> > fix (1:)
16:15:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:15:18 <lambdabot>     Couldn't match expected type `forall a. (a -> a) -> a'
16:15:18 <lambdabot>            against inferred type `b -> c'
16:15:51 <oerjan> oh wait
16:15:57 <oerjan> :t foldl ((.):: (forall a. (a -> a) -> a) -> (forall a. (a -> a) -> a) -> (forall a. (a -> a) -> a)) (id :: forall a. a -> a) (replicate 9 fix :: [forall a. a -> a])
16:15:59 <lambdabot>     Couldn't match expected type `forall a. (a -> a) -> a'
16:15:59 <lambdabot>            against inferred type `b -> c'
16:16:36 <oerjan> :t foldr1 ((.):: (forall a. (a -> a) -> a) -> (forall a. (a -> a) -> a) -> (forall a. (a -> a) -> a)) (replicate 9 fix :: [forall a. a -> a])
16:16:37 <lambdabot>     Couldn't match expected type `forall a. (a -> a) -> a'
16:16:38 <lambdabot>            against inferred type `b -> c'
16:17:14 <oerjan> whatever
16:18:53 <fax> hum
16:18:54 <oerjan> SamB_XP: seeing if it is possible to fold a list of fix'es using (.)
16:18:56 <fax> :t (fix .)
16:18:58 <lambdabot> forall a a1. (a1 -> a -> a) -> a1 -> a
16:19:12 <oerjan> it won't type easily
16:19:35 <oerjan> despite the fact fix . fix . fix . ... does (but with exponentially growing type)
16:19:38 <fax> ?djinn (a1 -> a -> b) -> (a -> b) -> a1
16:19:38 <lambdabot> -- f cannot be realized.
16:19:46 <fax> Why?
16:19:56 <ddarius> djinn doesn't do recursion
16:20:03 <ddarius> :t fix id
16:20:03 <fax> ?djinn (a1 -> a -> b) -> a -> b -> a1
16:20:04 <lambdabot> -- f cannot be realized.
16:20:05 <lambdabot> forall a. a
16:20:08 <ddarius> @djinn forall a.a
16:20:08 <lambdabot> -- f cannot be realized.
16:20:13 <fax> ?djinn (a1 -> a -> b) -> a1 -> a -> b
16:20:14 <lambdabot> f a = a
16:20:26 <fax> :t f a = a
16:20:27 <lambdabot> parse error on input `='
16:20:35 <fax> :t let f a = a in f
16:20:37 <lambdabot> forall t. t -> t
16:20:47 <fax> ack, thats a cop out
16:20:53 <ddarius> No it isn't.
16:21:23 <sjanssen> fax: (f x) y z = x y z
16:21:31 <dino-> TSC: The code does indeed work when I have the initial group spawn their own children. Thanks again for help with that race action.
16:21:37 <fax> :t let (f x) y z = x y z in f
16:21:39 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
16:21:41 <TSC> You're welcome
16:21:45 <fax> sjanssen: ye :D
16:21:46 <oerjan> if you allow recursion, _any_ type is possible as let f = f in f
16:22:06 <fax> :t let (f x) y z = x y z in (fix . f . fix . f)
16:22:08 <lambdabot> forall t t1. (((t -> t1) -> t -> t1) -> (t -> t1) -> t -> t1) -> t -> t1
16:22:13 <FMota> ooh
16:22:21 <FMota> I think I've found a name... sort of.
16:22:21 <EvilTerran> well, bottoms are another problem again
16:22:26 <FMota> stable? :o
16:22:37 <olsner> :t let f = f in f
16:22:39 <lambdabot> forall t. t
16:22:39 <fax> FMota: name for what?
16:22:45 <olsner> cool
16:22:57 <FMota> this programming language revalation I had today.
16:23:07 <FMota> that revolves around tables.
16:23:08 <fax> tell me about it ? :D
16:23:23 <FMota> I guess I can just hpaste it.
16:23:24 <FMota> Sec.
16:24:16 <FMota> My hobby: using hpaste for exotic new programming languages only horizontally related to Haskell.
16:24:59 <ddarius> FMota: Do you have implementations of any of them yet?
16:25:08 <FMota> no!
16:25:14 <FMota> although
16:25:16 <FMota> in reality
16:25:21 <FMota> this one would be the easiest to implement
16:26:49 <fax> :t (>>-)
16:26:51 <lambdabot> Not in scope: `>>-'
16:27:03 <fax> :t (>>≠)
16:27:05 <lambdabot> lexical error at character '\137'
16:27:40 <olsner> @quote
16:27:40 <lambdabot> spb says: [in ##freenode-social] because monads are a nasty hack to get around a language deficiency
16:28:18 <EvilTerran> whut?
16:28:32 <int-e> that's quote-worthy? hmm
16:28:37 <lament> now if that were spj...
16:28:51 <int-e> @quote
16:28:51 <lambdabot> liyang says: My coffee machine isn't l33t enough. I'm planning to make it l33t.
16:29:16 <oerjan> :t (??)
16:29:18 <lambdabot> Not in scope: `??'
16:29:27 <oerjan> oh, right
16:29:49 <fax> @pl (\y -> you y off)
16:29:49 <lambdabot> flip you off
16:30:32 <oerjan> @remember fax @pl (\y -> you y off)
16:30:32 <lambdabot> Done.
16:30:49 <fax> I just read it from the @quoet!
16:30:52 <ddarius> oerjan: That was done a really really long time age.
16:31:14 <fax> :S
16:32:00 <oerjan> whatever :/
16:32:18 <ddarius> @forget fax @pl (\y -> you y off)
16:32:18 <lambdabot> Done.
16:32:33 <oerjan> eek
16:32:36 <oerjan> @quote
16:32:36 <lambdabot> MyCatVerbs says: [talking about #haskell] seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychic MegaHelpFulness.
16:32:53 <oerjan> someone said @forget was broken?
16:33:23 <fax> This one <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
16:33:23 <oerjan> and caused massive state destruction
16:34:39 <EvilTerran> sure that's not @undef you're thinking of?
16:34:39 <hpaste>  dino- annotated "STM problem" with "STM yay, working" at http://hpaste.org/3087#a2
16:34:45 <dino-> For the curious.
16:34:57 <oerjan> quite sure
16:35:12 <EvilTerran> 'cos that does more than one'd intuitively expect
16:35:36 <LoganCapaldo> i recalll thi convo
16:35:49 <oerjan> it wasn't just wiping out a file, it was making @quote unusable until lambdabot was reset
16:35:59 <LoganCapaldo> i think it was sorear who described  the brokeness of forget
16:36:05 <ddarius> It would be
16:36:21 <oerjan> maybe it has been fixed then
16:36:58 <oerjan> (+ losing all the data)
16:37:02 <lament> forget @forget
16:37:26 <oerjan> lament is a preservationist :D
16:37:34 <FMota> @quote
16:37:34 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
16:37:58 <FMota> lol :(
16:38:01 <FMota> *:)
16:38:08 <oerjan> :t fmap fix return
16:38:13 <ddarius> FMota hates Euler with a passion
16:38:17 <lambdabot> forall a. a -> a
16:38:21 <FMota> lol
16:38:40 * ddarius decides to put his pants on before his shoes.
16:39:09 <oerjan> :t fix . id
16:39:11 <lambdabot> forall a. (a -> a) -> a
16:39:42 <Saizan> :t fix . const
16:39:44 <lambdabot> forall a. a -> a
16:39:58 <oerjan> oh right
16:40:02 <oerjan> except...
16:40:22 <ddarius> @check \ x -> (fix . const) x == id (x :: Int)
16:40:24 <lambdabot>  OK, passed 500 tests.
16:40:46 <oerjan> why is return = const there? return is not itself an action
16:41:02 <ddarius> oerjan: So?
16:41:13 <Saizan> ?type [return,const]
16:41:15 <lambdabot> forall a b. [a -> b -> a]
16:41:36 <oerjan> i mean, return as an action in the -> monad is not necessarily const
16:41:43 <Saizan> ((->) b) monad
16:42:14 <Saizan> oerjan: no?
16:42:15 <oerjan> :t fix . return
16:42:16 <lambdabot> forall a. a -> a
16:42:51 <oerjan> Saizan: return a is const a, but return itself is not
16:43:07 <oerjan> the fix seems to force it
16:43:34 <Saizan> well if the "m" of return is unified with (->) r then it's const
16:43:46 <oerjan> > ap (:) return 3
16:43:47 <lambdabot>  [3,3]
16:43:55 <lament> > fmap fix return 42
16:43:56 <lambdabot>  42
16:44:16 <oerjan> here return is an action in the -> monad, which happens to become (:[])
16:44:24 <Saizan> no
16:44:28 <oerjan> yes it is
16:44:32 <Saizan> there return is in the list monad
16:44:45 <oerjan> not as far as the ap is concerned
16:44:47 <Saizan> because (:) forces it to return a list
16:44:55 <Saizan> ?type ap
16:44:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:45:03 <oerjan> no, return 3 is in the list monad
16:45:10 <oerjan> but the return _itself_ is in ->
16:45:19 <Saizan> ah well, return there is in both :)
16:45:51 <lament> does the -> monad have a more pronounciable name?
16:45:58 <Saizan> lament: reader monad
16:46:03 <lament> pronounceable
16:46:11 <oerjan> this is of course wonderfully confusing
16:46:41 <oerjan> now, the issue with fmap fix return is somewhat similar - return is _first_ interpreted as an action in ->
16:46:45 <Saizan> it's just that different parts of the type of return can be considered the monad
16:47:34 <oerjan> this then becomes fix . return, at which point return is interpreted as a function returning an action in ->
16:48:35 <mauke> heh
16:48:37 <oerjan> i guess this shows why the quote is appropriate :)
16:48:41 <Saizan> ah, well i would have said that fmap is in the -> functor and return in the -> monad
16:48:45 <mauke> talking about fmap fix return, eh? :-)
16:48:55 <oerjan> yeah
16:49:11 <fax> I don't understabd fmap fix return
16:49:41 <oerjan> step (1) return needs to be f a for some functor f
16:50:11 <oerjan> since return :: x -> m x, we get f = (x ->) and a = m x
16:50:17 <ddarius> :t fmap fix return
16:50:19 <lambdabot> forall a. a -> a
16:50:31 <ddarius> There is only one (terminating) function of that type
16:50:45 <oerjan> thus the functor is (x ->), for which fmap = (.)
16:50:55 <oerjan> thus fmap fix return = fix . return
16:51:07 <ddarius> @src (->) return
16:51:07 <lambdabot> return = const
16:51:31 <fax> > (fmap fix return) 4
16:51:33 <oerjan> only at this point does it start to matter what monad return is the method for
16:51:35 <lambdabot>  4
16:51:49 <cpfr> hey what is the most succient way to make a function return 0 if both its arguments have the same value
16:52:02 <cpfr> let f a b = 0 where a = b
16:52:03 <mauke> f x y | x == y = 0
16:52:09 <oerjan> :t fix . ?r
16:52:11 <lambdabot> forall a a1. (?r::a1 -> a -> a) => a1 -> a
16:52:38 <fax> > let f = (-) in f 3 3
16:52:40 <lambdabot>  0
16:52:45 <oerjan> return needs to have type a1 -> a -> a, which means it is from the -> monad, thus const
16:52:58 <oerjan> so fix . return = fix . const
16:53:01 <gkr> Why it's type isn't (Monad (-> a), Fucntor (-> a)) => a -> a?
16:53:04 <mauke> > let f = xor in f 3 3
16:53:05 <lambdabot>  Add a type signature
16:53:29 <mauke> gkr: because -> is not a variable
16:53:52 <mauke> or rather, -> a is already a Monad/Functor
16:53:54 <gkr> Prelude> :t fmap fix return
16:53:54 <gkr> fmap fix return :: (Functor ((->) a), Monad ((->) a)) => a -> a
16:54:34 <mauke> how did you do that?
16:54:45 <lament> your Prelude has fix?
16:54:55 <gkr> I wrote down "let fix f = fix (f x)" before
16:55:00 <gkr> sorry
16:55:03 <gkr> f (fix x)
16:55:04 <shachaf> You mean f (fix f)?
16:55:07 <gkr> Yep.
16:55:13 <oerjan> gkr: the instances are in Control.Monad.Instances
16:55:33 <gkr> I don't know how to load modules :-/
16:55:37 <oerjan> so they cannot be reduced away unless you import that
16:55:39 <mauke> :m +Control.Monad.Reader
16:55:46 <gkr> Ahh, ok.
16:55:49 <gkr> Thanks.
16:55:52 <mauke> or :m +Control.Monad.Fix
16:55:56 <mauke> that should give you fix
16:56:04 <ddarius> @index fix
16:56:04 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
16:56:22 <gkr> Now it works.
16:56:26 <idnar> :t fmap fix return
16:56:28 <lambdabot> forall a. a -> a
16:57:15 <gkr> Else it wouldn't know that (->) a is a monad?
16:57:22 <oerjan> gkr: yep
16:57:26 <gkr> :-)
16:57:32 <dmwit> > let f = fromEnum . (/=) in f 3 3
16:57:33 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Int'
16:57:47 <dmwit> > let f = (fromEnum.).(/=) in f 3 3
16:57:48 <lambdabot>  0
16:58:29 <lament> > let f x y = 0 in f 3 3
16:58:31 <lambdabot>  0
16:58:51 <mauke> you win the prize!
16:58:55 <lament> it satisfies the requirements :)
16:59:23 <dmwit> nice
17:01:00 <oerjan> > (fix . const) 1
17:01:02 <lambdabot>  1
17:01:17 <dmwit> :t const const 0
17:01:19 <lambdabot> forall a b. a -> b -> a
17:01:27 <dmwit> :t const . const 0
17:01:28 <oerjan> now i only need to understand the simple part :/
17:01:29 <lambdabot> forall b b1 a. (Num b) => a -> b1 -> b
17:01:49 <oerjan> ah, of course
17:02:15 <oerjan> it's not const . const ... but const 1 . const 1 ...
17:03:22 <dmwit> oerjan: We're working on diferent problems...
17:03:43 <oerjan> ok
17:04:05 <oerjan> :t fmap fix ask
17:04:07 <lambdabot> forall a (f :: * -> *). (MonadReader (a -> a) f, Functor f) => f a
17:04:48 <oerjan> :t fix . ask
17:04:49 <lambdabot> forall a. (a -> a) -> a
17:05:00 <oerjan> oh right
17:05:19 <oerjan> :t fix . asks
17:05:21 <lambdabot> forall a. (a -> a) -> a
17:05:25 <dmwit> :t ask
17:05:26 <mauke> > fmap fix return `asTypeOf` ask
17:05:27 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
17:05:27 <lambdabot>  Add a type signature
17:05:30 <mauke> :t fmap fix return `asTypeOf` ask
17:05:32 <lambdabot> forall a. a -> a
17:05:35 <oerjan> :t fmap fix asks
17:05:36 <lambdabot> forall a. (a -> a) -> a
17:05:46 <oerjan> yeeha
17:06:04 <dmwit> fix is a strange beast
17:07:14 <oerjan> :t flip fmap asks
17:07:16 <lambdabot> forall b r a (m :: * -> *). (MonadReader r m) => (m a -> b) -> (r -> a) -> b
17:07:39 <dmwit> ?botsnack
17:07:40 <lambdabot> :)
17:09:41 <idnar> > fmap fix asks id
17:09:46 <lambdabot>  Exception: <<loop>>
17:09:47 <idnar> er
17:09:48 <oerjan> :t fmap flip fix
17:09:50 <lambdabot> forall a b c. ((a -> b -> c) -> a -> b -> c) -> b -> a -> c
17:09:54 <idnar> hmm, nm
17:10:00 <oerjan> ooh
17:10:35 <dmwit> > fmap flip fix id 3 4
17:10:36 <lambdabot>  Exception: <<loop>>
17:10:39 * sjanssen wishes for (Read a, Typeable a) => String -> Maybe a
17:10:44 <oerjan> :t flip fmap fix
17:10:46 <lambdabot> forall b a. (a -> b) -> (a -> a) -> b
17:11:24 <oerjan> > fmap flip fix (1:)
17:11:25 <lambdabot>  Couldn't match expected type `[t]'
17:11:54 <oerjan> > fmap fix asks (1:)
17:11:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:13:34 <dmwit> > fix (1:)
17:13:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:16:44 <mauke> mommy, darcs is eating my cpu again
17:17:02 <LoganCapaldo> tell it to stop being sucha pig
17:17:46 <ddarius> mauke: You should have eaten your vegetables.
17:17:51 <mauke> it doesn't listen
17:18:05 <dmwit> Oh, you children and your conflicts.
17:18:05 <mauke> rt_sigprocmask(SIG_BLOCK, [HUP INT ABRT PIPE TERM], [], 8) = 0
17:18:06 <mauke> rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
17:21:08 <fax> The LogicT Monad transformer thing is well cool
17:21:48 <newsham> dmwit: were you the one working on digit arithmetic a few days ago?
17:22:00 <dmwit> Nope, but I was mildly interested.
17:22:05 <dmwit> Did you come up with something interesting?
17:22:10 <newsham> remember who it was that was pasting code?
17:22:35 <dmwit> I suppose you've already checked hpaste's logs... =/
17:22:48 <newsham> looking at it now..
17:22:56 <newsham> ahh, found, it was vincenz
17:22:59 <fax> FMota: Did you die?
17:23:03 <fax> :[
17:24:11 <hpaste>  newsham pasted "numbers as digits" at http://hpaste.org/3091
17:32:59 <alexj> anyone know how to extract items from a Data.Map in reverse order?
17:33:13 <dmwit> reverse . items ?
17:33:16 <alexj> (without traversing the entire map to do so?)
17:33:35 <alexj> I just want the last 10 items in the map.
17:33:53 <sjanssen> alexj: you can findMax and deleteMax several times
17:34:41 <alexj> sjanssen: i guess that works.  its ugly.  but it works.
17:34:45 <oerjan> alexj: some combination of findIndex and split?
17:34:54 <dmwit> I would create a newtype that has the opposite sort order, then do (take 10 . elems).
17:35:03 <dibblego> I would do what dmwit said
17:35:06 <alexj> sometimes I want the lowest 10 items.
17:35:13 <dmwit> two maps
17:35:15 <dibblego> then you don't want a Map
17:35:16 <dmwit> ;-)
17:35:24 <alexj> the map stores it all in order.
17:35:37 <dibblego> change the definition of "order" (instance Ord ...)
17:35:53 <sjanssen> alexj: or let s = Map.size m in [ | i <- [s, x-1 .. x-10], x <- Map.lookupIndex
17:36:43 <alexj> sjanssen: not sure I understand that one.
17:37:06 <fax> $ plays havok with monad transformers?
17:37:20 <ddarius> fax: No.
17:37:34 <sjanssen> alexj: or let s = Map.size m in map (snd . flip Map.elemAt m) [s, s-1 .. s-10] -- sorry, wasn't done editing
17:38:03 <dmwit> Huh, I'm really surprised that Data.Map has *no* functions like toDescList.
17:38:23 <alexj> dmwit: yes that is what I am looking for.
17:38:24 <dmwit> It seems like in most sane Map implementations, this would have the same performance characterstics as toAscList.
17:39:32 <sjanssen> alexj: you could also use Data.Foldable
17:39:42 <oerjan> sjanssen: isn't it better to use split with a single elemAt?
17:40:28 <sjanssen> oerjan: perhaps.  For only 10 elems, I'd suspect that repeated elemAts are faster
17:40:55 <oerjan> i guess it depends on whether split avoids calculating the half you don't look at...
17:40:56 * sjanssen goes off to write toDescList
17:41:24 <dmwit> oerjan: It avoids calculating the values, but it still has to calculate the "spine" of the list.
17:41:51 <dmwit> oerjan: That means it effectively traverses the entire tree.
17:41:58 <oerjan> dmwit: i mean if it doesn't look at what's to the left of the split at all
17:42:07 <sjanssen> alexj: do you need the keys as well as the elems?
17:42:10 <oerjan> *you don't
17:43:07 <alexj> sjanssen: I would like the pairs.
17:43:25 <sjanssen> mmm, Data.Foldable won't work in that case
17:44:05 * dylan cackles evily.
17:44:40 <oerjan> hm, minView and maxView have the wrong result order to use with unfoldr
17:44:53 <dylan> I've been introducing my 4 year old step son to algebra, and also a command line jocky. Mwahaha. :-D
17:44:59 <sjanssen> rev = getDual . foldMap (Dual . return) -- would work if you only need the elems
17:45:18 <drunkenmonkee> is this the place where i can get help with hpodder working with cron?
17:45:18 <dylan> *making him a command line jocky, rather.
17:45:50 <mansu> hi all
17:45:57 <oerjan> > unfoldr (fmap (snd ** fst) . M.maxView) $ M.fromList [1..100]
17:45:59 <lambdabot>  Couldn't match expected type `M.Map k a'
17:46:18 <dmwit> drunkenmonkee: The problem is likely to be with cron rather than hpodder; and the problems vary by which implementation of cron you're using.
17:46:28 <oerjan> > unfoldr (fmap (snd ** fst) . M.maxView) $ M.fromList [(i,i^2)| i <- [1..100]]
17:46:29 <lambdabot>  Couldn't match expected type `M.Map k a'
17:46:29 <hpaste>  mansu pasted "(no title)" at http://hpaste.org/3092
17:46:37 <dmwit> drunkenmonkee: Often, environment variables are not what you expect them to be.
17:46:44 <dmwit> drunkenmonkee: But what problem are you seeing?
17:46:46 <oerjan> > M.fromList [(i,i^2)| i <- [1..100]]
17:46:47 <lambdabot>  fromList [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,10...
17:47:05 <mansu> why does loading http://hpaste.org/3092 the program above give an error while evaluating at the ghci not give errors?
17:47:13 <oerjan> :t unfoldr
17:47:15 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:47:27 <drunkenmonkee> well i checked my mail log and this is what i get........podder: exception :: Database.HDBC.SqlError hpodder: thread blocked indefinitely
17:47:28 <dmwit> mansu: Where did you define cons?
17:47:30 <dmwit> :t cons
17:47:31 <mansu> lambdabot, ones = 1: ones
17:47:32 <lambdabot> Not in scope: `cons'
17:47:37 <mansu> lambdabot, ones
17:47:46 <dmwit> > let ones = 1 : ones in ones
17:47:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:48:00 <oerjan> > unfoldr (fmap (snd *** fst) . M.maxView) $ M.fromList [(i,i^2)| i <- [1..100]]
17:48:00 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/3092#a1
17:48:01 <lambdabot>  Couldn't match expected type `(a, b)'
17:48:08 <mansu> dmwit, sorry thats ones...
17:48:10 <dmwit> drunkenmonkee: Ooo, never mind, that doesn't sound like cron's fault. =P
17:48:16 <mansu> dmwit, changed the code
17:48:22 <LoganCapaldo> > exp (pi * sqrt (-1)) :: Complex Double
17:48:24 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
17:48:37 <sjanssen> mansu: ghci accepts expressions, not declarations
17:48:41 <dmwit> mansu: In a file, having an expression on its own is meaningless and hence is a parse error.
17:48:52 <dmwit> So the "ones" line should be omitted.
17:48:58 <dmwit> (i.e. line 2)
17:48:59 <unthunk> Hey, can anyone point me at the current state of the art of doing numeric analysis in lazy functional langs?  I can find libraries with google, but I'm more interested in understanding how something like an update to a fluid dynamics state is best represented in a functional lang.
17:49:42 <mansu> dmwit, yeah i know what to do.. i don't understand why I shud do that... i mean any function invocation is an expression right
17:50:03 <mansu> dmwit, shud we omit it because we are not using its value
17:50:12 <dmwit> mansu: Haskell files are composed pretty much solely of definitions; anything else doesn't make sense.
17:50:19 <drunkenmonkee> dmwit: thanks, but i'm ready to just give up on hpodder.....can't even find anything on google
17:50:29 <dmwit> mansu: "ones" on its own is not a definition.
17:50:39 <dmwit> mansu: What you could do is something like...
17:50:55 <oerjan> :t unfoldr (fmap (snd *** fst) . M.maxView)
17:50:57 <lambdabot> Couldn't find qualified module.
17:51:03 <hpaste>  dmwit annotated "(no title)" with "make it a definition" at http://hpaste.org/3092#a2
17:51:05 <oerjan> :t unfoldr (fmap (snd *** fst) . Data.Map.maxView)
17:51:07 <lambdabot>     Couldn't match expected type `(a, b)'
17:51:07 <lambdabot>            against inferred type `Data.Map.Map k a1'
17:51:39 <mansu> dmwit, why does ones print an infinite list at command line when in ghci, i wasn't expecting it since haskell is lazy
17:52:00 <mauke> what did you expect it to do?
17:52:08 <dmwit> When you put a value on its own in GHCi, the interpreter calls "print" on your behalf... which forces evaluation.
17:52:40 <oerjan> argh
17:52:47 <oerjan> :t unfoldr (fmap (snd &&& fst) . Data.Map.maxView)
17:52:49 <lambdabot> forall k a. Data.Map.Map k a -> [(k, a)]
17:53:00 <oerjan> > unfoldr (fmap (snd &&& fst) . M.maxView) $ M.fromList [(i,i^2)| i <- [1..100]]
17:53:02 <lambdabot>  [(100,10000),(99,9801),(98,9604),(97,9409),(96,9216),(95,9025),(94,8836),(93...
17:53:13 <mansu> dmwit, hmm ok.. so print is calling ones till it returns an empty list ?
17:53:36 <sjanssen> @pl uncurry (flip (,))
17:53:37 <lambdabot> uncurry (flip (,))
17:53:40 <dmwit> oerjan: Nice!  But... then it has to calculate an entirely new map, once for each item in the resulting list...
17:53:42 <oerjan> > unfoldr (fmap (snd &&& fst) . M.maxView) $ M.fromList [(i,i^2)| i <- [1..5]]
17:53:43 <lambdabot>  [(5,25),(4,16),(3,9),(2,4),(1,1)]
17:53:57 <oerjan> dmwit: bah, you're right
17:54:08 <sjanssen> oerjan: splitting is likely to be quite expensive
17:54:14 <dmwit> mansu: No, the definition of ones itself is an infinite list.
17:54:17 <TSC> mansu: print will try to display the whole list, which is infinite
17:54:28 <dmwit> Yeah, what TSC said. =)
17:54:39 <LoganCapaldo> print fought the list and the list one
17:54:56 <dmwit> ... >_<
17:56:13 <oerjan> sjanssen: not like with finger trees, which are designed to do it efficiently :/
17:56:34 <sjanssen> oerjan: yep, clearly we should be using those :)
17:58:16 <oerjan> although there is probably only O(log(n)) extra overhead with Map?
17:58:43 <mansu> dmwit, and others thx for the info
17:59:50 <fax> What are the monad transformer rules?
18:00:31 <oerjan> fax: i guess lift should commute with the other methods
18:00:59 <oerjan> lift (a >>= f) = lift a >>= lift . f and such
18:01:40 <oerjan> lift . return = return
18:01:59 <sendo> how can i "or" over a whole list of bools?
18:02:04 <oerjan> :t or
18:02:12 <lambdabot> [Bool] -> Bool
18:02:24 <sendo> super.
18:02:29 <mauke> a SAQ
18:02:30 <ddarius> oerjan: Or another way to put that is that lift is a functor between the Kleisli categories.
18:02:43 <ddarius> (or specifically, the action on arrows of a functor ...)
18:02:43 <dmwit> sendo: haskell.org/hoogle
18:02:49 <dmwit> ?hoogle [Bool] -> Bool
18:02:49 <lambdabot> Prelude.and :: [Bool] -> Bool
18:02:49 <lambdabot> Prelude.or :: [Bool] -> Bool
18:03:14 <mauke> @src or
18:03:14 <lambdabot> or    =  foldr (||) False
18:05:09 <fax> How long does it take to read a haskell paper? :p
18:05:26 <LoganCapaldo> depends how strict your papaer evaluator is
18:05:31 <LoganCapaldo> *paper
18:05:35 <TSC> Or how lazy you are (:
18:05:36 <mauke> _|_
18:05:48 <fax> heh
18:05:49 <fax> ehe
18:06:22 <fax> how often do you write a monad transformer?
18:06:32 <LoganCapaldo> Lately I've been writing one about once a week
18:06:42 <LoganCapaldo> but none of them ar eoriginal ;)
18:06:45 <fax> aw
18:06:59 <fax> are any realtivley straightfoward
18:07:06 <sarehu_> does newtyping them count as 'writing'? :)
18:07:08 <dmwit> IdT ;-)
18:07:21 <fax> @srd IdT
18:07:21 <lambdabot> Source not found. You type like i drive.
18:07:28 <LoganCapaldo> MaybeT is starightforwrd i guess
18:07:31 <fax> ...lambdabot is smart
18:07:34 <LoganCapaldo> *straightforward
18:07:43 <LoganCapaldo> i can't type today
18:08:09 <fax> I want to see more examples of Monad Transformers which make something hard into ridiculously easy
18:08:21 <LoganCapaldo> Oh is that what they do?
18:08:33 <fax> don't think so but it's what I want to see ":p
18:08:35 <sjanssen> fax: you don't see too many unique transformers, the toolkit of ReaderT, StateT and WriterT fill most needs
18:08:41 <LoganCapaldo> no one told me :(
18:08:45 <sjanssen> and then there's always ContT :)
18:08:55 <dmwit> ContT makes me go =(
18:08:59 <LoganCapaldo> Oh ContT isn't one I've done yet
18:09:06 <fax> hmm
18:09:07 <LoganCapaldo> that's gotta go on the list
18:09:11 <fax> I wish I knew what they all do
18:09:14 <LoganCapaldo> Maybe I should try Cont first
18:09:36 <dibblego> ?type flip
18:09:38 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:09:47 <ddarius> fax: Read "The essence of functional programming" by Wadler
18:09:48 <LoganCapaldo> djinn can write Cont :)
18:09:57 <fax> ddarius: ok
18:10:54 <ddarius> Actually, that's just on monads not monad transformers.  But still, if you've got that down right then you should have no trouble understanding what, say, StateT should do.
18:11:57 <ddarius> If you want something more particularly on monad transformers, there's "Monad Transformers and Modular Interpreters". (Though, I'd recommend reading Wadler's paper if you haven't already regardless; it's enjoyable.)
18:12:16 <fax> cool I'll check them both out
18:15:58 <sjanssen> the haskell.org mailing lists seem to be stuck, who do we contact?
18:16:45 * oerjan vaguely recalls it's Simon Marlow
18:16:48 <TSC> I'm getting some mail from there, but it seems pretty late
18:20:06 <monochrom> The latest mail is seen at Google in 12:30 EDT, and next seen at haskell.org in 21:06 EDT. 8.5 hours.
18:20:47 <monochrom> 21:06 EDT is just 15 minutes ago.
18:21:32 <monochrom> Similarly for the recent mails in haskell@haskell.org
18:21:53 <fax> :(
18:22:05 <monochrom> My first sentence refers to the latest mail in haskell-cafe.
18:22:42 <fax> This is the LogicM code http://img518.imageshack.us/img518/7460/logicmna1.png
18:22:55 <fax> Can you edit haskell like this?
18:23:01 <fax> Instead of using some fixed width font and stuff
18:23:36 <TSC> You could with the right editor, I suppose
18:23:44 <STreggae> Hi guys, can wxhaskell be implemented in winhugs
18:23:50 <fax> some kind of emacs mode exists?
18:24:00 <fax> or any other program
18:24:07 <STreggae> I want to create a gui in winhugs
18:24:28 <TSC> fax: I don't think so, but if you used a proportional font you'd be most of the way there
18:24:55 <fax> :(
18:25:04 <fax> So nobody does this?
18:25:19 <fax> and it is only typesetting for printing
18:25:49 <oerjan> fax: lhs2tex, i think
18:25:58 <ddarius> Who in God's name would want to program in a proportional font?
18:26:00 <TSC> You might have trouble with the layout rule
18:26:12 <fax> ddarius: me after seeing this code :p
18:26:36 <STreggae> can wxhaskell be implemented in winhugs
18:26:41 <STreggae> ???
18:26:47 <oerjan> the problem is lining up blocks that don't start at the beginning of a line
18:26:53 <oerjan> like those do blocks
18:26:56 <TSC> Yes
18:27:01 <fax> what do you mean
18:27:14 <fax> the :: and ='s ?
18:27:24 <LoganCapaldo> you don't need to line up do blocks just use { ; } with your proportional font
18:27:31 <fax> ach
18:27:42 <oerjan> fax: do r <- msplit sg and then the following lines must line up with the r
18:27:53 <fax> oh but it should work fine
18:28:01 <fax> The editor would need to parse your code a bit though
18:28:23 <fax> oh well it seems to not exist
18:28:33 <oerjan> yes it would, and haskell is hard to parse
18:28:59 <fax> really ?
18:29:07 <fax> but well you could steal a parser :D
18:30:01 <oerjan> not even the compilers try to do it perfectly ;)
18:30:34 <STreggae> from where ???
18:30:47 <oerjan> (i.e. there are things in the report that are ill-defined or just plain wrong)
18:30:58 <fax> ah that's a shame
18:31:28 <STreggae> so i have to use ghc
18:31:54 <dmwit> fax: Are you talking about the "elastic tabs" editor thing?
18:31:58 <dmwit> If not, have you seen it?
18:32:09 <fax> I hadn't heard of that
18:32:26 <dmwit> ?go elastic tabstops
18:32:28 <lambdabot> http://nickgravgaard.com/elastictabstops/
18:32:28 <lambdabot> Title: Elastic tabstops - the solution to the tabs-versus-spaces issue
18:33:01 <fax> right yes
18:33:05 <fax> elastic tabstops would be essential
18:33:13 <fax> I didn't know it had a name though
18:35:21 <fax> h cool
18:35:26 <fax> he uses proportional font
18:35:43 <fax> It looks awful though
18:36:10 <fax> it does Haskell or just C?
18:36:24 <dmwit> I think it does elastic tabstops, and it is up to the user what language to use them in.
18:36:39 <dmwit> (You have to press the "tab" key yourself.)
18:36:44 <fax> hehe
18:36:53 <fax> well I suppose that means it wont work well with haskell
18:37:00 <dmwit> Why?
18:37:14 <Cale> Well, it would work with Haskell, if GHC were designed to use them.
18:37:31 <dmwit> Cale: It can save the file with spaces. ;-)
18:37:37 <Cale> ah, okay
18:37:47 <Cale> Well, that'll work fine then :)
18:38:06 <Cale> Actually I kind of think that Haskell implementations should treat a tab character as a lexical error.
18:38:15 <dmwit> hahahaha
18:38:22 <dmwit> I like it.
18:38:39 <LoganCapaldo> tab == 8spaces as far as haskell is concerned correct?
18:38:45 <Cale> Sort of
18:38:55 <Cale> tab aligns to the nearest 8-space boundary
18:38:56 <LoganCapaldo> only sort of?
18:39:01 <LoganCapaldo> crud muffins
18:39:10 <LoganCapaldo> tahts sounds awful
18:39:12 <TSC> Nearest, or next? (:
18:39:12 <oerjan> tabstops = 8 spaces
18:39:17 <dmwit> next
18:39:20 <oerjan> it's the unix convention
18:40:32 <LoganCapaldo> so 6 spaces followed by a tab will be 8 spaces?
18:40:42 <LoganCapaldo> am I understanding this correctly?
18:40:44 <dmwit> At the beginning of a line, that is true.
18:40:53 <LoganCapaldo> gah
18:41:01 <Cale> Yeah, the nearest *following* multiple of 8 spaces..
18:41:01 * LoganCapaldo joins the tabs == lexical error camp
18:41:08 <oerjan> it's also what you would expect from actual typewriters
18:41:16 <oerjan> which had physical tabstops
18:41:23 <TSC> It's tab to next tab-stop; that's pretty standard
18:41:26 <dmwit> But at the beginning of a line, 'aa' followed by a tab will be expanded to 'aa' followed by six spaces... =P
18:43:02 <Cale> I really think we need an editor which is aware of the offside rule. So if you type some extra text before a 'do', it will push the whole block along with it.
18:43:18 <LoganCapaldo> Cale: that would be super convient
18:43:44 <dmwit> Dunno, sometimes I outdent my do blocks.
18:43:50 <dmwit> something really really long $ do
18:43:59 <dmwit>     return outdented, in a way
18:44:12 <Cale> well, yeah, the block starts on the next non-whitespace character after the do
18:44:20 <Cale> So it's really that character which it would track
18:44:55 <dmwit> Cale: Incidentally, the "elastic tabs" editor above will do that for you. =)
18:45:19 <Cale> Will it do it when opening a file?
18:45:30 <Cale> (I don't think it would)
18:45:33 <dmwit> Yes, though you have to manually click "translate from spaces" or some such.
18:45:47 <dmwit> ...
18:45:47 <dmwit> wait
18:45:47 <Cale> Well, it can't know about do, can it?
18:46:09 <Cale> It'll know about where the rest of the block should go, at least.
18:46:12 <dmwit> I don't know.  It might be smart enough, or it might not.
18:46:17 <Cale> Which would still be more convenient than nothing.
18:58:00 <SamB_XP> hmm, I'm not sure I've heard of the journal comp.lang.functional before...
18:58:51 <platypus> SamB_XP: Its a Usenet newsgroup.
18:58:53 <jaredj> journal?
18:58:56 <jaredj> heh
18:59:09 * SamB_XP was looking at some of oleg's publications
18:59:41 <SamB_XP> or, really, just at the abstracts
18:59:50 <platypus> He includes Usenet posts as publications?
19:00:01 <SamB_XP> well, he mixes them willy-nilly anywys
19:00:16 * platypus thinks he will include IRC logs then.
19:00:18 <SamB_XP> given the quality of the material he posts, it really isn't very silly
19:00:32 <platypus> True.
19:01:16 <SamB_XP> I wonder how you cite that in a bibliography?
19:01:42 <mauke> by msgid
19:01:43 <Beelsebob> probably best left as personal communications?
19:02:17 <SamB_XP> well, he does have slightly amended versions on his site...
19:04:25 * SamB_XP wonders how rendering scheme code into XML can be called "pretty-printing"
19:04:52 <oerjan> O_O
19:20:59 <oerjan> @users
19:20:59 <lambdabot> Maximum users seen in #haskell: 420, currently: 353 (84.0%), active: 7 (2.0%)
19:21:28 <geocalc>  
19:21:43 * lament
19:29:33 <dmwit> ?slap
19:29:33 <lambdabot> why on earth would I slap
19:30:07 <Cale> http://cale.yi.org/autoshare/Screenshot-Collatz.png -- neat self-similarity in the set of values for which the number of up-steps and down-steps are equal under iteration of the Collatz function.
19:31:06 <fax> It looks someone sat on the devils staircase :D
19:31:12 <Cale> indeed :)
19:50:26 <fax> ugh
19:50:38 <fax> man the haskell mode for emacs doesn't define its own font faces
20:01:31 <nick_> what is a haskell combinator?
20:01:45 <RyanT5000> what happened to Data.Time.Format?
20:01:49 <mudge> anyone?
20:01:58 <mudge> what is a haskell combinator?
20:02:08 <RyanT5000> mudge: you mean as opposed to a normal combinator?
20:02:12 <fax> dammit
20:02:20 <fax> haskell mode for emacs is like impossible to customize
20:02:24 <mudge> what's a normal combinator?
20:02:39 <mudge> what's any kind of combinator?
20:03:06 <fax> @google combinator
20:03:08 <lambdabot> http://ycombinator.com/
20:03:08 <lambdabot> Title: Y Combinator
20:03:12 <omnIdiot> @wn combinator
20:03:13 <lambdabot> No match for "combinator".
20:03:15 <Cale> hehe
20:03:16 <RyanT5000> mudge: it's a function that combines other functions
20:03:17 <fax> hm ignore that
20:03:20 <ddarius> @foldoc combinator
20:03:21 <lambdabot> *** "combinator" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
20:03:21 <lambdabot> combinator
20:03:21 <lambdabot>  
20:03:21 <lambdabot>         <theory> A function with no {free variables}.  A term is
20:03:21 <lambdabot>         either a constant, a variable or of the form A B denoting the
20:03:23 <lambdabot> [28 @more lines]
20:03:29 <omnIdiot> @more
20:03:29 <lambdabot>         {application} of term A (a function of one argument) to term
20:03:29 <lambdabot>         B.  {Juxtaposition} associates to the left in the absence of
20:03:29 <lambdabot>         parentheses.  All combinators can be defined from two basic
20:03:31 <lambdabot>         combinators - S and K.  These two and a third, I, are defined
20:03:33 <lambdabot>         thus:
20:03:34 <RyanT5000> mudge: "A combinator is a higher-order function which, for defining a result from its arguments, solely use function application and earlier defined combinators."
20:03:35 <lambdabot> [23 @more lines]
20:03:45 <RyanT5000> mudge: (from http://en.wikipedia.org/wiki/Combinator)
20:03:46 <lambdabot> Title: Combinatory logic - Wikipedia, the free encyclopedia
20:03:53 <dmwit> ?docs data.time
20:03:53 <lambdabot> data.time not available
20:03:53 <Cale> In the informal sense though, a combinator is just a function which combines computations.
20:03:58 <dmwit> ?docs Data.Time
20:03:58 <lambdabot> Data.Time not available
20:04:24 <ddarius> Cale: Define "computations"
20:04:38 <Cale> ddarius: anything which we're thinking of as computations :)
20:04:42 <mudge> RyanT5000 oh thanks
20:04:43 <dmwit> RyanT5000: I still have Data.Time.Format here.
20:05:09 <Cale> So even, for example, data structures which represent something to be done at a later time.
20:05:33 <RyanT5000> dmwit: what version of GHC are you in? is it in a package or something?
20:05:41 <RyanT5000> dmwit: i can't use it in GHCi
20:05:43 <dmwit> 6.6.1
20:05:47 <oerjan> parser combinators being a common example
20:05:50 <dmwit> :m + Data.Time.Format doesn't work?
20:05:52 <RyanT5000> dmwit: ah, i just have 6.6; damn debian
20:06:29 <dmwit> RyanT5000: ghc-pkg list | grep time
20:06:33 <dmwit> I have time-1.1.1
20:06:43 <RyanT5000> 1.-
20:06:45 <RyanT5000> 1.0
20:06:52 <dmwit> hm
20:06:53 <RyanT5000> updating that will probably help
20:19:39 <mudge> Monads combine functions,   are they combinators?   the "."   operator comines functions,  is that a combinator?
20:20:00 <RyanT5000> (.) is a combinator
20:20:04 <newsham> compos and bind are combinators
20:20:23 <mudge> sweet spegetti
20:20:31 <RyanT5000> monad functions are sometimes combinators, i think
20:23:08 <ddarius> mudge: Combinator used in an informal sense is a buzzword almost devoid of meaning.
20:23:50 <oerjan> > 1 + 2 -- look, a number combinator!
20:23:54 <lambdabot>  3
20:24:06 <RyanT5000> mudge: ddarius makes a good point; why, exactly, do you care which things "are combinators"?  I can't say I've ever encountered a time when that distinction was important
20:24:17 <omnIdiot> "Combinator", formally, is something involving functions with a very specific definition that I don't know exactly enough to tell.
20:24:52 <RyanT5000> omnIdiot: i think it just means it has no free (e.g. global) variables
20:25:11 <RyanT5000> omnIdiot: although it means that very strictly, so literals, etc., are all illegal
20:25:28 <omnIdiot> ah yes, and a supercombinator is one in which every subexpression is a combinator, yes?
20:26:42 <RyanT5000> omnIdiot: yeah
20:27:43 <omnIdiot> (\x y z -> (x z) (y z)) and (\x y -> x) would be combinators.  :)
20:29:42 <oerjan> :t ap return return
20:29:44 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> a
20:30:46 <omnIdiot> SKK = I
20:31:10 <oerjan> that was the idea, but why doesn't it throw away the monad context?
20:31:21 <rictic> How can I find out GHC's module load path?  (or, where can I put QuickCheck.hs so that any of my programs can import it, wherever they are on my system)
20:31:36 <omnIdiot> :O, that is strange
20:32:05 <oerjan> :t return return (return return)
20:32:07 <ddarius> oerjan: SKX for any X is I
20:32:08 <lambdabot>     Ambiguous type variable `m1' in the constraint:
20:32:08 <lambdabot>       `Monad m1' arising from use of `return' at <interactive>:1:15-27
20:32:37 <ddarius> It doesn't know how to resolve the m in the type of the second return.
20:32:43 <oerjan> why didn't the first give that error?
20:32:50 <RyanT5000> oerjan: it will when you try to use it
20:33:03 <RyanT5000> oerjan: it doesn't know how to instantiate m, which it still needs to do
20:33:05 <omnIdiot>  > (ap return return) ()
20:33:07 <RyanT5000> oerjan: (or, that's my guess, anyway)
20:33:11 <oerjan> :t let x = return in return x (return x)
20:33:13 <omnIdiot> > (ap return return) ()
20:33:13 <lambdabot> forall (m :: * -> *) a a1 (m1 :: * -> *). (Monad m, Monad m1) => a -> m a
20:33:14 <lambdabot>  Add a type signature
20:33:32 <omnIdiot> I can't!  There's no m to instantiate!
20:34:05 <ddarius> You need to add a type signature to the second return.
20:34:12 <omnIdiot> right.
20:34:16 <oerjan> now there are _two_ monads
20:34:27 <omnIdiot> > (ap return (return :: a -> b -> a)) ()
20:34:31 <lambdabot>  ()
20:34:39 * omnIdiot is a dummy
20:34:59 <ddarius> > ap return undefined ()
20:34:59 <ac> Is there a function that will take a list of streams and return a stream of lists?
20:35:00 <lambdabot>  ()
20:35:13 <oerjan> oh wait
20:35:15 <ddarius> transpose
20:35:27 <ddarius> Well, actually, there are tons of such functions.
20:35:27 <ac> :t transpose
20:35:29 <lambdabot> forall a. [[a]] -> [[a]]
20:35:45 <ac> what does "forall a." mean?
20:35:51 <oerjan> :t let x = return in \x -> return x (return x)
20:35:53 <lambdabot>     Ambiguous type variable `m' in the constraint:
20:35:53 <lambdabot>       `Monad m' arising from use of `return' at <interactive>:1:8-13
20:35:54 <ddarius> Exactly what it says.
20:36:17 <ac> ddarius: so any type a?
20:36:22 <omnIdiot> it works on all lists of lists, regardless of the inner type 'a'
20:36:31 <ddarius> ac: Yes.
20:36:41 <ac> @src transpose
20:36:42 <lambdabot> transpose []             = []
20:36:42 <lambdabot> transpose ([]   : xss)   = transpose xss
20:36:42 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
20:36:50 <omnIdiot> > transpose [[1..3],[4..6]]
20:36:52 <lambdabot>  [[1,4],[2,5],[3,6]]
20:37:04 <ac> yep, that's my functionw
20:37:30 <omnIdiot> "Streams"?  Are these newtype'd lists?
20:37:47 <ac> omnIdiot: I call infinite lists streams. What's the Haskell name?
20:38:20 <omnIdiot> That works.
20:38:22 <ddarius> ac: Often "Stream" is used specifically for types that can only be infinite.
20:38:46 <ddarius> E.g. data Stream a = SCons a (Stream a)
20:46:39 <omnIdiot> @type (\x -> x (\x y z -> x z (y z)) (\x y -> x))
20:46:41 <lambdabot> forall t t1 t2 t3 t4 t5. (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (t3 -> t4 -> t3) -> t5) -> t5
20:48:32 <oerjan> :t let x = (\x -> x (\x y z -> x z (y z)) (\x y -> x)) in x (x x)
20:48:34 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t -> t2
20:48:34 <lambdabot>     Probable cause: `x' is applied to too many arguments
20:49:00 <oerjan> er...
20:49:05 <oerjan> darn MR
20:49:12 <oerjan> oh wait, no
20:49:20 <oerjan> no classes
20:49:26 <oerjan> :t let x = (\x -> x (\x y z -> x z (y z)) (\x y -> x)) in x x
20:49:28 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t -> t2
20:49:28 <lambdabot>     Probable cause: `x' is applied to too many arguments
20:49:37 <omnIdiot> haskell is too typed :)
20:50:19 <oerjan> :t let x = (\x -> x (\x y -> x) (\x y z -> x z (y z)) (\x y -> x)) in x
20:50:21 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. ((t -> t1 -> t) -> ((t2 -> t3 -> t4) -> (t2 -> t3) -> t2 -> t4) -> (t5 -> t6 -> t5) -> t7) -> t7
20:50:27 <oerjan> :t let x = (\x -> x (\x y -> x) (\x y z -> x z (y z)) (\x y -> x)) in x x
20:50:29 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> t1
20:50:35 <oerjan> aha
20:51:53 <omnIdiot> > let x = (\x -> x (\x y -> x) (\x y z -> x z (y z)) (\x y -> x)) in (x x) (undefined "blah" undefined)
20:51:54 <lambdabot>  Add a type signature
20:52:03 <omnIdiot> > let x = (\x -> x (\x y -> x) (\x y z -> x z (y z)) (\x y -> x)) in (x x) (() "blah" ())
20:52:04 <lambdabot>  Couldn't match expected type `[Char] -> () -> t'
20:53:17 <oerjan> omnIdiot: you don't put parentheses around arguments
20:53:28 <oerjan> (more than one)
20:53:35 <omnIdiot> oh, blah.  I TOO SLEEPY
20:53:40 <omnIdiot> > let x = (\x -> x (\x y -> x) (\x y z -> x z (y z)) (\x y -> x)) in (x x) () "blah" ()
20:53:42 <lambdabot>  "blah"
20:53:47 <omnIdiot> yay!
20:55:39 <oerjan> :t let x = (\x -> x (\x y -> x) (\x y z -> x z (y z)) (\x y -> x)) in x (x x)
20:55:41 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
20:55:55 <oerjan> :t let x = (\x -> x (\x y -> x) (\x y z -> x z (y z)) (\x y -> x)) in (x x) x
20:55:56 <lambdabot> forall t t1. t -> t1 -> t
20:56:06 <oerjan> yay, both S and K work
20:56:41 <omnIdiot> is the x there given a name?
20:56:52 <oerjan> X
20:56:57 <oerjan> is what i've seen
20:57:09 <omnIdiot> (\f -> f S K) is called iota
20:57:57 <oerjan> yep
20:58:08 <oerjan> the other one is also mentioned on the Iota page
20:58:25 <omnIdiot> I'm getting a 404
20:59:10 <oerjan> me too, i looked at the google buffer
21:00:32 <omnIdiot> I like that every binary number is a valid jot program :)
21:01:26 <ddarius> omnIdiot: Every binary number is a valid program for any processor.
21:02:22 <omnIdiot> never looked at it that way
21:02:57 <RyanT5000> ddarius: that depends on your definition of "valid"
21:18:22 <doctormach> Is there a standard way to generate all of the elements of an algebraic data type that contain a certain number of terms?
21:19:25 <omnIdiot> > [minBound..maxBound] :: [Ordering] -- if the type is Enum(erable) and Bounded:
21:19:27 <lambdabot>  [LT,EQ,GT]
21:19:59 <doctormach> I'm using the type http://hpaste.org/3094
21:20:19 <doctormach> And I want all the elements with a certain number of Nodes
21:21:18 <doctormach> I'm not sure how to start writing a function to generate them
21:21:22 * sarehu prays that's supposed to be a tree, not a graph.  
21:21:44 <ac> isn't it not strictly necessary but considered good practice to always give functions type signatures?
21:21:54 <omnIdiot> so f 2 = [Node (Node Input Input) Input, Node Input (Node Input Input)]?
21:22:15 <doctormach> Yeah
21:22:18 <sarehu> ac: yes (I guess)
21:22:29 <glguy> ac: maybe at the top level..
21:22:29 <oerjan> sized 0 = [Input]; sized n = [Node x y | m <- [0..n], x <- sized m, y <- sized (n-m)]
21:23:00 <ddarius> Sometimes it's necessary.
21:23:02 <oerjan> oh wait
21:23:22 <omnIdiot> do you mean for 'a' to be a phantom type?
21:23:23 <sarehu> [0..n-1]
21:23:30 <oerjan> sized 0 = [Input]; sized n = [Node x y | m <- [0..n-1], x <- sized m, y <- sized (n-1-m)]
21:23:31 <sarehu> n-1-m
21:23:34 <sarehu> ok.
21:24:10 <doctormach> No, I was thinking about doing something else and forgot to take it out
21:24:11 <dibblego> how do you explain to the layperson that "if(p) then q" is a true statement for p is False?
21:24:16 <dibblego> I am having difficult
21:24:32 <dibblego> y
21:25:05 <doctormach> oerjan: Thanks, that works perfectly
21:25:22 <sarehu> dibblego: "true" really means not-proven-false.
21:25:23 <omnIdiot> dibblego: maybe the word "implies" would be more viscerally useful.
21:28:49 <dibblego> I said it means "cannot be shown to contain logical inconsistency"
21:28:53 <dibblego> that kind of helped
21:28:55 <dibblego> thanks
21:29:20 <sarehu> dibblego: it really doesn't make sense to say that "if p then q" is a true statement when p is false.  i.m.o. propositions like p /\ q and such should be viewed as functions mapping universes into {True,False}.
21:30:05 <dibblego> sarehu, yes I agree
21:31:20 <ddarius> dibblego: You could consider what the case would be if it was otherwise.
21:33:01 <sarehu> Or just stop worrying and learn to consider "p -> q" as shorthand for "not p \/ q"
21:34:50 <Cale> sarehu: why not?
21:35:35 <Cale> sarehu: That's the meaning: "if p then q" simply means "q or not p"
21:35:49 <sarehu> why not what?
21:35:53 <sorear> My recent messages to the haskell-foo mailing lists have been delayed a rather long time.
21:36:07 <Cale> Why doesn't it make sense to say that "if p then q" is true when p is false?
21:36:55 <fax> Wouldn't it need to be, if p then q else True ?
21:37:14 <Cale> fax: We're presumably talking about the logical connective.
21:37:44 <geocalc> :t (\)
21:37:46 <lambdabot> parse error on input `)'
21:38:04 <Cale> geocalc: \ is syntax for lambda
21:38:10 <sarehu> Cale: I'm not saying it makes sense to say that "if p then q" is false, or anything.  it's just that "if p then q" and "p implies q" aren't really nice language, if you ask me
21:38:17 <fax> (p /\ q) \/ (~p /\ True)
21:38:19 <Cale> geocalc: \x -> x^2 is the function which takes a parameter x and squares it.
21:38:32 <geocalc> yes
21:38:50 <Cale> sarehu: why not?
21:39:04 <Cale> sarehu: you'd rather p -> q ?
21:39:22 <Cale> Or (q \/ ~p) ?
21:39:35 <ddarius> Cale: Probably due to a kind of desire for causality (not necessary explicitly)
21:39:37 <sarehu> The confusion (that people get) comes from the fact that having one example (where p is false) does not mean that p implies q (generally), and that's what goes on in newbies' heads.
21:40:34 * oerjan is trying to find the wikipedia article he read about that test where you ask people which of four cards they need to turn over to verify an implication
21:40:47 <Cale> oerjan: :)
21:40:49 <oerjan> but i just cannot get it
21:40:56 <sorear> sarehu: If p is false in one example, p is always false.  Logic is timeless.
21:41:08 * sorear mutters something about ground instantiations
21:41:19 <dibblego> "if p then q" simply means "q or not p" wouldn't it be the other way around? (since if False then undefined -> True)
21:41:52 <sarehu> sorear: ok... but I'm talking about explaining (p -> q) to people
21:42:07 <sarehu> and you might have a good part of the explanation
21:42:16 <ddarius> The problem is clearly the people.  I say we do away with the people.
21:42:21 <dibblego> you see the difficulty I am having in explaining this to someone :)
21:42:35 <oerjan> but i do recall it said that people performed much better on such implications if they were phrased as legal/moral restrictions rather than logic
21:42:43 <sorear> ddarius: if we kill all the mathematicians, who will manipulate the symbols?
21:43:20 <ddarius> sorear: Well, we have computers now...
21:43:39 <Cale> oerjan: I have a book on cognitive science which describes it, I'll see if I can get the name...
21:44:49 <Cale> Watson's selection task
21:45:21 <monochrom> There are two "if p then q"s, and people mix them up. Logician's "if p then q" is just "p implies q"; what if not p? Could be anything. Programmer's "if p then q" is really "if p then q else nop"; the "else nop" part makes a whole world's difference, since in case of not p, it is no longer "anything", it has to be specifically nop, not anything else.
21:46:01 <Tac-Tics2> If computers compute, then do mathematicians math? Or logicians logish?
21:46:17 <Tac-Tics2> (or is that just a common misconception?)
21:46:21 <ddarius> monochrom: There is no nop in Haskell
21:46:29 <oerjan> Cale: and i _still_ cannot find the wikipedia article, even with the name O_O
21:46:29 <Cale> Tac-Tics2: mathematician doesn't end in er :)
21:46:32 <monochrom> There is also no "if p then q" in Haskell.
21:46:33 <sarehu> Tac-Tics2: mathematicians mathturbate
21:46:55 <Tac-Tics2> NOP as in no instruction?
21:47:16 <monochrom> Sometimes you have "if p then q else return ()", sometimes you have "if p then f else id", depending on whether you're monadic or pure functional.
21:47:19 <Tac-Tics2> Haskell has 'return' which does the same thing in many cases
21:48:00 <monochrom> Haskell does it right! You have to be aware of the else branch, and write explicitly what's in it.
21:48:41 <monochrom> Most imperative languages cause brain damage because they thought the shorthand "if p then q" was cool.  Well it proves to be misleading and very damaging to people's logics.
21:51:17 * sorear does not think implication and case are related
21:52:29 <monochrom> Here is the brain damage. "if c=0 then x:=x+1". Programmer reasons: suppose I test the program and finds that x is increased, then this must be because c=0 right? Therefore "x:=x+1 implies p"!
21:53:51 <Tac-Tics2> monochrom, can you explain that some more
21:54:01 <Tac-Tics2> my imperative-damaged brain is not clear what you mean ;-)
21:54:03 <monochrom> Here is the brain damage repaired. "if c=0 then x:=x+1 else nop". Suppose I test the program and find that x is increased, then nop is not executed, therefore "not (c=0)" is false, therefore c=0 is true.
21:55:20 <Cale> oh, heh, there was a typo in my book
21:55:30 <Cale> oerjan: Wason selection task
21:55:46 <monochrom> In fact there is a sense in which "if c=0 then x:=x+1 else nop" can be written as "(c=0 implies x:=x+1) and (c/=0 implies nop)". You need the (c/=0 implies nop) clause to do backward inference, to refute c/=0.
21:55:51 <Tac-Tics2> If you chose the blue pill, you'd learn there IS no nop
21:55:53 <Cale> http://en.wikipedia.org/wiki/Wason_selection_task
21:55:54 <lambdabot> Title: Wason selection task - Wikipedia, the free encyclopedia
21:56:15 <Tac-Tics2> There is only MOV EAX, EAX
21:57:57 <reffie> MOV EAX,EAX is not the only nop
21:58:17 <Tac-Tics2> It's a really good nop among nops
21:58:34 <reffie> in some cases you want to use nops that take more space
21:58:45 <reffie> instead of using multiple mov eax,eax
21:59:05 <sorear> xchg eax, eax FTW
21:59:33 <Tac-Tics2> NOPs remind me of UltraSparcII =-(
21:59:53 <Tac-Tics2> "So it reads the call/jump, executes the instruction AFTER it.... and THEN jumps??"
22:00:08 <sorear> Nah, it reads the call/jump and changes IP
22:00:10 <sorear> immediately
22:00:17 <reffie> delay slots make sense!
22:00:24 <sorear> "jumping" is a figment of your imagination
22:00:25 <Tac-Tics2> it had something to do with the instruction pipeline
22:00:29 <reffie> Tac-Tics2 yes
22:00:32 <sorear> no, delay slots are BRILLIANT
22:00:46 <Tac-Tics2> I had a terrible prof, so I didn't really understand the principle behind it
22:00:59 <monochrom> I understand it.
22:00:59 <sorear> if it weren't for the curse of binary compatibility, every processor would use them
22:01:40 <Tac-Tics2> Backwards compatibility... pfft
22:01:44 <sorear> as it stands, MIPS is stuck in the CPU dark ages because binary compatibility with old-school delay slots effectively locks them into old-school design
22:01:54 <reffie> MIPS is great
22:02:00 <sorear> if they could revise the ABI, they could revise the architecture
22:02:05 <reffie> simplest ISA ever
22:02:17 <fax> http://img518.imageshack.us/img518/7460/logicmna1.png
22:02:21 <sorear> but noo, people want their binary payware to keep working
22:02:27 <fax> Do you know the name of this font?
22:02:47 <monochrom> money die die die!
22:02:51 <sorear> Computer Modern
22:03:14 <sorear> it's the standard TeX font... not suprising for lhs2TeX output
22:03:39 <Cale> I love Computer Modern Roman.
22:03:47 <misterbeebee> why is so much in Italics?
22:04:00 <Cale> uh, also, that's not computer modern roman.
22:04:38 <fax> I must have the font installed somewhere
22:05:05 <omnIdiot> misterbeebee: ask the typesetter.
22:05:17 <Cale> http://www.identifont.com/show?763 -- CMR looks like this
22:05:19 <lambdabot> Title: Identifont - Computer Modern Roman (CMR)
22:05:45 <monochrom> Apparently identifiers are in italics.
22:06:19 <monochrom> I suppose you could reverse the style. Keywords italic, identifiers upright.
22:07:19 <Cale> CMR's italic z doesn't look like the z in mzero there.
22:07:40 <Cale> In particular, it has a curvy top, not a straight one.
22:08:24 <misterbeebee> is there a wysiwyg text editor that will render that font (or similar), with the elegant looking operators? It reminds me of the ThinkPascal realtime prettyprinter l from Mac System 7.
22:08:38 <fax> I think emacs can do it
22:08:43 <fax> I am hoping so....
22:08:59 <fax> yeah emacs can do it
22:10:06 <sorear> Cale: duh, mzero is in italics, CMR by definition isn't
22:10:24 <Cale> I'm talking about the italic variant of CMR
22:10:39 <Cale> Er, I suppose that would make it CMI :)
22:11:04 <earnest> :)
22:11:05 <Cale> The italic text there seems suspiciously similar to FreeSerif Italic
22:11:13 <hpaste>  Tac-Tics pasted "Problem with hs-plugins" at http://hpaste.org/3095
22:11:27 <Tac-Tics2> can someone help me figure out why I'm getting an error with hs-plugins doing what I am?
22:11:49 <sorear> Tac-Tics2: No.
22:12:00 <Tac-Tics2> oh?
22:12:20 <sorear> No error message; not much to go on.
22:12:26 <Cale> My eyes are not good enough to tell the difference between the italic font in that image and FreeSerif Italic.
22:12:30 <Tac-Tics2> I'm getting ["load: couldn't find symbol <<main>>"]
22:13:14 <Cale> and the bold text is FreeSerif bold.
22:13:51 <sorear> Tac-Tics2: Main.main maybe?
22:14:35 <Tac-Tics2> same deal, can't find Main.main
22:17:24 <fax> damn
22:17:29 <fax> FreeSerif looks really nice
22:17:35 <fax> I can only get corrupt version fo it though :|
22:18:04 <Cale> corrupt?
22:18:10 <fax> missing OpenType dat
22:18:11 <fax> data
22:19:09 <Cale> what does that imply?
22:19:25 <fax> I'm not sure but I get the wrong letters
22:19:44 <Cale> huh
22:20:04 <Cale> It's freely available, as the name implies, so you should be able to get hold of a good copy.
22:21:13 <Cale> http://www.nongnu.org/freefont/ -- I think they're from here
22:21:15 <lambdabot> Title: Free UCS Outline Fonts
22:22:40 <Tac-Tics2> weird, I get a different error when I try to compile it
22:22:50 <Tac-Tics2> plugins: Test.o: unknown symbol `base_GHCziBase_unpackCStringzh_closure'
22:22:50 <Tac-Tics2> plugins: user error (resolvedObjs failed.)
22:32:13 <Tac-Tics2> stupid plugins
22:32:28 <Tac-Tics2> it sounds so cool, but of course it's a pain to get to work =-(
22:32:40 <Tac-Tics2> that's like the entire experience with haskell, I think
22:32:53 <Tac-Tics2> Cool, but a major pain in the butt the first time you do anything
22:33:25 <ac> @hoogle transpose
22:33:25 <lambdabot> List.transpose :: [[a]] -> [[a]]
22:33:25 <lambdabot> Data.Graph.transposeG :: Graph -> Graph
22:35:20 <dons> today is hackathon day one everyone
22:35:25 <dons> yay for code
22:35:34 <dons> Tac-Tics2: you'll need the darcs version of hs-plugins
22:35:59 <araujo> dons, ping
22:36:19 <dons> pong
22:36:48 <monochrom> do more docs
22:36:55 <dons> of course!
22:38:17 <monochrom> Do you know what's on the agenda today?
22:41:30 <ac> Is there a way to import a list of modules on one line?
22:42:33 <dons> separate the statements with ;
22:42:42 <ac> then you have to repeat "import"
22:42:53 <dons> right
22:43:02 <ac> I want to say "import [foo, bar, ...] :-|
22:43:05 <ac> "
22:43:15 <dons> that's not valid haskell, though.
22:43:36 <sjanssen> import Foo, Bar, Baz would be really handly
22:43:42 <dons> yeah
22:43:52 <ac> that would be easy to add too
22:44:09 <dibblego> import package.{Foo, Bar, Baz} // Scala
22:44:16 <ac> especially because modules often can be grouped semantically
22:44:29 <dons> semantic groups are usually solved by having a module rexport its children
22:44:34 <dons> so import OpenGL
22:44:38 <dons> brings in things under that
22:44:46 <dons> but its up to the library author to remember to do taht
22:45:14 <sjanssen> it'd be nice even ignoring semantic grouping
22:45:58 <sjanssen> 'import Data.' is annoying enough to type that I usually copy a previous line and edit it
22:46:02 <mudge> I'm looking at the GHC libraries: http://www.haskell.org/ghc/docs/latest/html/libraries/    how does the library structuring work?   Like there is Network and Network.CGI and Network.CGI.Cookie
22:46:14 <mudge> what is the relation between Network and Network.CGI ?
22:46:26 <mudge> are they different libraries or connected?
22:46:30 <sjanssen> mudge: just a similarity in name
22:46:39 <ac> if you import Foo in to program bar, are definitions imported by Foo available in bar?
22:46:42 <dons> there's a small set of top level names
22:46:59 <dons> ac, if Foo reexports them
22:47:03 <sjanssen> ac: not usually, but you can re-export a module
22:47:21 <ac> what's the syntax for that?
22:47:30 <ac> or is it generally not a good idea?
22:47:44 <sjanssen> module Foo (module Bar) where import Bar; ...
22:48:20 <ac> sjanssen: that's simple enough. Is there any reason that would be bad practice?
22:48:24 <sjanssen> ac: it's a great idea when used in moderation
22:51:45 <ac> is there an infinity constant? So I could say "take infinity foolist"?
22:52:01 <dons> foolist itself then
22:52:05 <dons> > [1..]
22:52:07 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:52:21 <ac> I know, but I want one function to provide either an infinite list or a finite list, but I don't want to add a conditional
22:52:21 <sjanssen> ac: no
22:52:22 <dons> interesting question
22:52:32 <xelxebar> > map (+1) [1..10]
22:52:34 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
22:52:42 <dibblego> wasn't there a recent Haskell-Cafe thread about that?
22:52:45 <dons> let the demand drive how much is taken
22:52:59 <dons> case Nothing -> xs ; Just n -> take n xs
22:53:12 <dons> but its a bit odd -- i've never seen someone need to do this before
22:53:18 <sjanssen> ac: maxBound :: Int might be effectively infinite in your case
22:53:19 <dons> what with infinite structures taking infinite time ..
22:53:42 <shachaf> Could it work with Nat and genericTake?
22:53:47 <sjanssen> ac: or 2^1024 :: Integer
22:54:07 <ac> I like dons case solution the best
22:54:28 <sjanssen> I agree that is cleanest
22:55:35 <luqui> When I try to pull ghc I get this error:
22:55:38 <luqui> darcs failed:  Pristine tree doesn't exist.
22:55:38 <luqui> darcs failed: 512 at ./darcs-all line 59.
22:56:25 <luqui> also, is there opengl support for ghc > 6.4?
22:56:26 * Heffalump wonders if dons ever sleeps :-)
22:57:01 <dons> mornig Heffalump !
22:57:11 <Syzygy-> luqui: I'm pretty certain I've gotten OpenGL up and running with 6.6
22:57:27 <quicksilver> luqui: oh definitely
22:57:34 <quicksilver> luqui: 6.6 comes with an openGL which works very well
22:57:41 <luqui> "comes with"?
22:57:43 <luqui> where?
22:57:59 <quicksilver> Graphics.Rendering.OpenGL
22:58:03 <quicksilver> and Graphics.UI.GLUT
22:58:08 <luqui> which I can get where?
22:58:15 <luqui> it's not in the source tree
22:58:29 <quicksilver> it is installed with every GHC installation I've ever done
22:58:33 <Syzygy-> Which are either in the source ball or in the additional libraries ball which you can getfrom the same webpage.
22:58:33 <quicksilver> by source or by binary
22:58:40 <Syzygy-> @where ghc
22:58:40 <lambdabot> http://haskell.org/ghc
22:58:46 <luqui> ah, maybe I didn't sync libs
22:59:03 <Syzygy-> luqui: Grab the extralibs tarball and look in there.
22:59:49 <luqui> ahh there it is
23:00:14 <fax> There http://img120.imageshack.us/img120/3581/picture1ms8.png
23:00:28 <fax> The spacing is totally screwed up though
23:00:52 <fax> I got haskell-mode in emacs to do that
23:01:04 <KatieHuber> there was someone talking somewhere recently about an editor where a tab character meant "intelligently line up with adjacent lines"
23:01:08 <KatieHuber> I wonder where I saw that
23:01:27 <quicksilver> that does describe emacs' haskell-mode
23:01:31 <quicksilver> it's just far from perfect :P
23:01:35 * omnIdiot knows what katie's talking of
23:01:36 <fax> heh
23:01:40 <fax> it's really bad
23:01:52 <fax> I had to redo the fontification stuff
23:01:55 <KatieHuber> maybe it was the textmate guy on his blog
23:02:38 <Cale> KatieHuber: It was brought up earlier, elastic tabs
23:02:49 <Cale> http://nickgravgaard.com/elastictabstops/
23:02:49 <lambdabot> Title: Elastic tabstops - the solution to the tabs-versus-spaces issue
23:03:06 <Cale> er, elastic tabstops ;)
23:03:15 <misterbeebee> fax: awesome. In Mac Vim, a proportional font gets de-proportionalized with awkward spaces. haskell-mode might swing me over to the emacs side.
23:03:50 <fax> misterbeebee: well if I could just get the thing to line up right ..
23:03:55 <fax> :)
23:03:55 <ac> dons: actually, I don't need case or even pattern matching, I just define two functions with different numbers of arguments
23:04:04 <luqui> misterbeebee, you could use console vim on mac
23:04:08 <ac> one with a "count" argument that calls take on the one without
23:04:34 <quicksilver> Cale: a mapping from that to something that haskell's layout rule agrees with would be decidedly non-trivial
23:05:11 <ac> nevermind, that doesn't work because I end up with two different signatures for the same function
23:05:24 <Cale> quicksilver: actually, not that hard. You just need to interpret the layout rule, and stick tabs in for each nested block level.
23:05:33 <ac> that's not possible, is it?
23:05:43 <quicksilver> Cale: I disagree
23:05:45 <Cale> ac: Not without typeclasses.
23:05:51 <quicksilver> Cale: after the line "do blah"
23:06:03 <quicksilver> Cale: the next line it needs to be clever enough to emit precisely three spaces for 'that tabstop'
23:06:07 <Cale> blah is the start of a block, so insert a tab before it
23:06:12 <misterbeebee> luqui: but does console vim work with proportional fonts(and elegenat rendering of operators like in fax's pic)?
23:06:42 <Cale> then the tabs on the following line will line the text up with the blah
23:06:42 <luqui> uh... no
23:06:51 <quicksilver> Cale: ah, ok, that helps
23:06:53 <luqui> never used vim for that... didn't even know it was capable of that
23:07:09 <misterbeebee> i don't know that it is.. which is why I'm now impressed by emacs
23:07:12 <quicksilver> Cale: not totally trivial though IMO
23:07:46 <Cale> yeah, it's about as nontrivial as implementing the layout rule
23:07:55 <KatieHuber> that gedit video is really nice
23:07:57 <omnIdiot> quicksilver: are you talking about the elastic tabs?  That page gives a gedit plugin that translates elastic tabs to spaces and back.
23:08:16 <quicksilver> omnIdiot: I'm talking about using elastic tabs in a way compatible with haskell's layout-mode
23:08:26 <quicksilver> omnIdiot: so the compiler correctly interprets your code ;)
23:08:40 <quicksilver> Cale: which is more complex that your typical editor's haskell-mode
23:08:50 <quicksilver> Cale: maybe partly just because most editor mode writers are lazy :P
23:09:15 <omnIdiot> quicksilver: as in, using literal tab characters with an elastic-tab representation, and expecting the existing definition of haskell to accept it?
23:09:36 <ac> What's the opposite of Nothing?
23:09:36 <quicksilver> omnIdiot: using some sensible elastic tab representation, but exporting (saving) your file with spaces
23:09:46 <quicksilver> omnIdiot: in a way with works with haskell's rules
23:09:46 <Cale> quicksilver: You can't even really correctly syntax colour Haskell code without writing half a compiler anyway ;)
23:10:07 <quicksilver> Cale: No, quite. Fortunately doing it 'not remotely correctly' is good enough for most purposes ;)
23:10:09 <ac> I want to pattern match a value that's not nothing... like "foofunc param@Something ..."
23:10:14 <fax> Someone should write a haskell editor :E
23:10:18 <fax> in haskell
23:10:20 <quicksilver> ac: "Just _"
23:10:26 <Cale> fax: there's yi
23:10:34 <fax> but yi doesn't do all this cool stuf
23:10:41 <Cale> right
23:10:47 <fax> I guess it could be addded to maybe
23:11:04 <Cale> Something using Gtk2Hs would be cool.
23:12:06 <quicksilver> whilst the elastic tabstop guy makes some good points, I don't feel he addresses the 'tabs for alignment' issue very well
23:12:15 <quicksilver> he's covered the indentation part well enough
23:12:30 <quicksilver> if (foo == 1 &&
23:12:35 <quicksilver>     bar == 2)
23:12:46 <quicksilver> that kind of alignment doesn't fit very well in his model does it?
23:12:55 <quicksilver> you need to put a 'zero-width tab' before foo
23:13:54 <omnIdiot> quicksilver: indeed he does just that in the parameters to his someDemoCode function.
23:14:07 <omnIdiot> quicksilver: though it shows up with a nonzero width
23:15:04 <omnIdiot> int someDemoCode(<tab>int fred,
23:15:05 <omnIdiot> <tab>int wilma)
23:15:40 <quicksilver> omnIdiot: oh yes, I'm blind
23:15:45 <Cale> You might end up wanting something like shift-tab for inserting a tab initially set to zero space.
23:15:50 <quicksilver> omnIdiot: I'd prefer it to be zero width (on the first line)
23:16:03 <omnIdiot> quicksilver: I'd tend to agree.
23:16:20 <quicksilver> omnIdiot: or at least, if there's going to be space between ( and int, there should be matching space between wilma and )
23:16:23 <Cale> For Haskell code, yeah.
23:16:32 <Cale> You'd always want to start with a zero space tab.
23:16:39 <Cale> (or maybe one space)
23:16:51 <quicksilver> at least if you're in the habit of starting your 'lets and dos' on the same line
23:16:56 <quicksilver> as the keyword itself
23:17:04 <quicksilver> which more-or-less everyone does for let
23:17:06 <Cale> right, which most people are, I think :)
23:17:10 <quicksilver> not everyoone for do, perhaps
23:17:31 <quicksilver> then, to be really clever, you want 'implicit zero-width tabstops'
23:17:42 <quicksilver> automatically inserted after certain constructs
23:17:52 <Cale> Right :)
23:17:59 <quicksilver> ....which brings us full circle, because that's exactly how the emacs mode works
23:18:06 <omnIdiot> Cale: I think if the line's characters-so-far do not exceed some arbitrary "natural" first tabstop, then stops at that natural tabstop.  (like the green colored one in his example)
23:18:29 <omnIdiot> s/then stops/then a new tab stops/
23:18:30 <quicksilver> the only thing the emacs mode does really poorly is making a reasonable guess for what order to give you choices in
23:19:11 <Cale> Oh, it does some other things really poorly too
23:19:33 <Cale> At least, I quickly found myself frustrated with it not giving me the choices I wanted.
23:20:44 <quicksilver> it makes some surprising choices in "non-layout" cases
23:20:45 <Cale> like, when you've done a 'let', and you're finished with the declarations inside it
23:20:55 <quicksilver> with strict layout it seems to get it pretty much right
23:20:56 <Cale> try getting it to put you in the right place to type 'in'
23:21:04 <quicksilver> Cale: type 'in' first and then hit TAB
23:21:07 <ac> is there a short way of saying: (\x -> foofunc a (barfunc b c x))?
23:21:08 <omnIdiot> {-# LANGUAGE ElasticTabstops #-} anyone?
23:21:16 <Cale> oh, that's *really* strange.
23:21:19 <quicksilver> Cale: that instantly flicks to same place as the let
23:21:34 <quicksilver> Cale: it's because the "place" you want is invalid for any normal thing you might type :)
23:21:41 <quicksilver> it's only valid if that thing is 'in'
23:21:54 <Cale> 'in' is a normal thing to type :)
23:22:01 <Cale> especially at that point :)
23:22:01 <quicksilver> ac: foofunc a . barfunc b c
23:22:06 <quicksilver> that's a fair argument
23:22:09 <quicksilver> but you know what I meant
23:22:10 <ac> ahhah. I thought it could be done with compose
23:22:12 <Cale> yeah
23:22:43 <omnIdiot> ac: (f . g) x = f (g x) where f = (foofunc a) and g = (barfunc b c)
23:22:44 <Cale> I also don't know how happy I am with tab after some characters moving those characters.
23:23:05 <Cale> I suppose one could get used to it.
23:24:38 <Cale> well, at least I know how that works now ;)
23:26:36 <nornagon> ac: also commonly expressed as f . g $ x
23:26:55 <ac> nornagon: what's '$'?
23:27:00 <omnIdiot> f $ x = f x
23:27:10 <ac> different precedence?
23:27:13 <nornagon> it's a precedence helper
23:27:19 <omnIdiot> f (g x) = (f . g) x = f $ g x = f . g $ x
23:27:23 <nornagon> saves writing too many brackets :)
23:27:27 <omnIdiot> ($) has low fixity
23:27:32 <ac> that's handy to know
23:27:37 <omnIdiot> so yeah, you can omit parens.
23:27:40 <fax> > fix $
23:27:40 <lambdabot>   parse error on input `}'
23:27:41 <fax> > fix ($)
23:27:42 <lambdabot>  Add a type signature
23:27:50 <ac> I'll have to go over my code and apply $ appropriately
23:27:51 <fax> > fix ($ :: a -> a)
23:27:51 <lambdabot>  Parse error
23:27:57 <fax> bah
23:28:00 * omnIdiot throws fax into the nearest black hole.
23:28:13 <nornagon> > fix (($) :: a -> a)
23:28:14 <lambdabot>   `$' is applied to too few arguments
23:28:14 <lambdabot>     In the expression: ($)
23:28:22 <nornagon> :t fix
23:28:23 <lambdabot> forall a. (a -> a) -> a
23:28:32 <nornagon> huh
23:28:35 <nornagon> :t ($)
23:28:37 <lambdabot> forall a b. (a -> b) -> a -> b
23:28:45 <ac> Is there a way to "split" a stream, so that [a,b,c,d,e,f ...] -> ([a,c,e,...],[b,d,f,...])?
23:28:47 <sorear> the problem is in the ($) :: a -> a
23:29:01 <sorear> ac: sure...
23:29:05 <nornagon> ac: there's a filtering function that gives you two lists
23:29:08 <fax> @hoogle Int -> [a] -> (a,a)
23:29:08 <lambdabot> No matches, try a more general search
23:29:09 <nornagon> but i forget its name
23:29:20 <fax> @hoogle (a -> Bool) -> [a] -> (a,a)
23:29:20 <lambdabot> No matches, try a more general search
23:29:22 <nornagon> @hoogle (a -> Bool) -> [a] -> (a,a)
23:29:22 <lambdabot> No matches, try a more general search
23:29:24 <nornagon> drat
23:29:27 <sorear> > foldr (\ a ~(x,y) -> (y, a:x)) ([],[]) [1..]
23:29:28 <lambdabot>  ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
23:29:31 <omnIdiot> > fix ($) ()
23:29:35 <lambdabot> Terminated
23:29:35 <sorear> > snd $ foldr (\ a ~(x,y) -> (y, a:x)) ([],[]) [1..]
23:29:36 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
23:29:49 <ac> sorear: that's a little complicated
23:29:57 <fax> @src break
23:29:57 <lambdabot> break p =  span (not . p)
23:30:01 <nornagon> sorear: i'm sure there's a prelude function or something for it...
23:30:04 <nornagon> :t break
23:30:06 <ac> I've come to expect better of haskell
23:30:06 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
23:30:12 <nornagon> oh heh
23:30:13 <fax> > beak (=3) [3,3,3,3,2,1,3,4,5]
23:30:13 <lambdabot>  Parse error
23:30:18 <fax> > break (=3) [3,3,3,3,2,1,3,4,5]
23:30:18 <lambdabot>  Parse error
23:30:21 <omnIdiot> (==)
23:30:22 <nornagon> ==
23:30:25 <fax> dohh
23:30:57 <nornagon> @hoogle (a -> Bool) -> [a] -> ([a],[a])
23:30:57 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
23:30:57 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
23:30:57 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
23:31:02 <nornagon> there we go
23:31:08 <fax> nornagon: aha!
23:31:25 <ac> so how do you make a (a -> Bool) function alternate between true and false?
23:31:32 <omnIdiot> > map (take 2) . iterate (drop 2) $ [1..]
23:31:33 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,...
23:31:34 <fax> ac: A function cannot do that
23:31:45 <fax> ac: Only a procedure (which yo can't write in haskell)
23:31:45 <ac> fax: right... so partition, break, and span don't work
23:31:46 <Heffalump> well, it can vary depending on the a
23:31:54 <nornagon> ac: use `mod` 2
23:31:59 <nornagon> for even/odd
23:32:01 <quicksilver> > transpose . map (take 2) . iterate (drop 2) $ [1..]
23:32:02 <lambdabot>  [[1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
23:32:07 <quicksilver> that works
23:32:31 <nornagon> :t transpose
23:32:33 <lambdabot> forall a. [[a]] -> [[a]]
23:32:39 <nornagon> @src transpose
23:32:39 <lambdabot> transpose []             = []
23:32:39 <lambdabot> transpose ([]   : xss)   = transpose xss
23:32:39 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
23:32:49 <nornagon> scary
23:32:57 <ac> transpose is simple to understand though
23:33:01 <omnIdiot> > transpose [[1..3],[4..6],[7..9]]
23:33:01 <quicksilver> > (\l -> zip (zipWith (!!) l [0,2..]) (zipWith (!!) l [1,3..])) [1..]
23:33:02 <lambdabot>   add an instance declaration for (Num [a])
23:33:03 <lambdabot>     In the expression: 1
23:33:03 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
23:33:22 <ac> > take 10 (transpose [0..] (map (^2) [0..]))
23:33:22 <lambdabot>  Couldn't match expected type `[a1] -> [a]'
23:33:36 <ac> why do things work in ghci but not in lambdabot?
23:33:36 <omnIdiot> transpose transposes a list of lists
23:33:40 <quicksilver> > (\l -> zip (map (l!!)  [0,2..]) (map (l!!) l [1,3..])) [1..]
23:33:41 <lambdabot>  Couldn't match expected type `[t] -> [b]'
23:33:46 <quicksilver> bah
23:33:50 <quicksilver> > (\l -> zip (map (l!!)  [0,2..]) (map (l!!) [1,3..])) [1..]
23:33:52 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
23:33:57 <quicksilver> there's another way
23:34:05 <quicksilver> although I zipped the lists this time for easier viewing
23:34:06 <omnIdiot> oh, geez
23:35:57 <ac> "map (take 2) . iterate (drop 2)" is the simplest
23:36:11 <omnIdiot> > zipWith (\i j xs -> (xs !! i, xs !! j)) [0,2..] [1,3..] <*> [1..]
23:36:12 <lambdabot>   add an instance declaration for (Num [a])
23:36:12 <lambdabot>     In the expression: 1
23:37:11 <omnIdiot> what dumb thing did I do there?
23:37:36 <omnIdiot> @type (<*>)
23:37:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:38:01 <omnIdiot> > zipWith (\i j xs -> (xs !! i, xs !! j)) [0,2..] [1,3..] <*> repeat [1..]
23:38:03 <lambdabot>  [(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,...
23:38:08 <omnIdiot> almost :)
23:38:48 <misterbeebee> > (  map fst *** map fst) $  (List.partition (even . fst))  (zip [0..] [1,2,3,4])
23:38:49 <lambdabot>  ([0,2],[1,3])
23:39:08 <misterbeebee> > (  map snd  *** map snd) $  (List.partition (even . fst))  (zip [0..] [1,2,3,4])
23:39:09 <lambdabot>  ([1,3],[2,4])
23:39:40 <omnIdiot> > let fs <*> xs = zipWith ($) fs xs in zipWith (\i j xs -> (xs !! i, xs !! j)) [0,2..] [1,3..] <*> repeat [1..] -- wrong Applicative :)
23:39:40 <lambdabot>  Unbalanced parenthesis
23:39:40 <ac> misterbeebee: this is actually a list of type a, so I can't use even
23:39:49 <omnIdiot> > let fs <*> xs = zipWith ($) fs xs in zipWith (\i j xs -> (xs !! i, xs !! j)) [0,2..] [1,3..] <*> repeat [1..] -- wrong Applicative :/
23:39:50 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
23:39:57 <misterbeebee> even is used for the index I zipped in
23:40:11 <misterbeebee> > (  map snd  *** map snd) $  (List.partition (even . fst))  (zip [0..]  ["a", "b", "c", "d"])
23:40:12 <lambdabot>  (["a","c"],["b","d"])
23:40:21 <ac> misterbeebee: oh. I don't understand that code obviously
23:40:31 <misterbeebee> @pl ( \(x,y) -> (map fst x, map fst y) )  $  List.partition (even . fst)
23:40:31 <lambdabot> (map fst *** map fst) (List . partition (even . fst))
23:40:39 <misterbeebee> (I wrote it without @pl first :) )
23:41:29 <misterbeebee> It zips [0..]  (indices) with your list, then partitions on the indices, then throws away the indices
23:41:41 <omnIdiot> > zipWith ($) (zipWith (\i j xs -> (xs !! i, xs !! j)) [0,2..] [1,3..]) (repeat [1..])
23:41:42 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
23:41:45 <misterbeebee> variant of http://en.wikipedia.org/wiki/Schwartzian_transform
23:41:51 <omnIdiot> can you understand that? :)
23:42:46 <omnIdiot> the inner zipWith produces a [[a] -> (a, a)], a list of indexing functions.  The zipWith ($) applies these indexing functions to the input list.
23:43:02 <ac> I'm just surprised there isn't something predefined that will let me do it in one function or a simple composition, like everything else I've done
23:43:34 <ac> seems like it would be a common thing to do
23:43:35 <misterbeebee> @let acSplit = (  map snd  *** map snd) $  (List.partition (even . fst))  . (zip [0..])
23:43:36 <lambdabot> Couldn't match expected type `([(a, b)], [(a1, b1)])'
23:44:17 <ac> :t (***)
23:44:19 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:44:25 <misterbeebee> > acSplit "abcdef"
23:44:25 <ac> oh my
23:44:26 <lambdabot>  ("ace","bdf")
23:44:43 <ac> misterbeebee: thanks... I think I'll just paste that in to my code :P
23:45:09 <omnIdiot> ac: a = (->), so that becomes (->) b c -> (->) b' c' -> (->) (b, b') (c, c')
23:45:25 <ac> the prime notation is new to me
23:45:33 <omnIdiot> orbitz: (b -> c) -> (b' -> c') -> ((b,b') -> (c,c'))
23:45:34 <ac> or is that just another variable?
23:45:42 <omnIdiot> er, s/orbitz/or/
23:45:49 <omnIdiot> yep
23:47:06 <omnIdiot> it "multiplies" two functions into a function on pairs.
23:50:51 <ac> star3 f g = (\x -> (f (fst x), g (snd x)))
23:51:01 <ac> @src (***)
23:51:01 <lambdabot> f *** g = first f >>> second g
23:51:28 <ac> hmmm
23:51:44 <ac> @src (>>>)
23:51:45 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:52:05 <ac> :t (>>>)
23:52:07 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
23:53:07 <misterbeebee> @let genericSplit splitter p =  ( map snd  *** map snd) .  (splitter (p . fst)) . zip [0..]
23:53:09 <omnIdiot> = (b -> c) -> (c -> d) -> (b -> d), where a = (->), which you'll see is just function composition with a different arg order
23:53:12 <lambdabot> Defined.
23:53:13 <omnIdiot> @type (.)
23:53:15 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
23:53:25 <misterbeebee> > genericSplit List.Partition even "abcdefgh"
23:53:26 <lambdabot>   Not in scope: data constructor `List.Partition'
23:53:36 <misterbeebee> > genericSplit List.partition even "abcdefgh"
23:53:37 <lambdabot>  ("aceg","bdfh")
23:53:54 <misterbeebee> ac: genericSplit might be definde (better) in some lib....
23:56:06 <sjanssen> @type \splitter p ->  ( map snd  *** map snd) .  (splitter (p . fst)) . zip [0..]
23:56:08 <lambdabot> forall a b a1 b1 c a2 b2 t b3. (Num t, Enum t) => (((a2, b2) -> c) -> [(t, b3)] -> ([(a, b)], [(a1, b1)])) -> (a2 -> c) -> [b3] -> ([b], [b1])
23:56:23 <omnIdiot> > map snd *** map snd $ partition fst $ zip (cycle [True, False]) [1..]
23:56:24 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
23:56:34 <ac> I might as well have /topic fancy list splitation
23:56:40 <ac> ;)
23:57:40 <omnIdiot> @let both f = f *** f
23:57:45 <lambdabot> Defined.
23:58:06 <omnIdiot> > both (map snd) . partition fst . zip (cycle [True, False]) $ [1..]
23:58:08 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
