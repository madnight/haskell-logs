00:00:02 <newsham> so this "applicative" stuff is a lot like some of the concepts in "funmath"
00:00:10 <newsham> where you write hats over functiosn and operators to lift them
00:18:45 <Cale> newsham: yeah, I think there is a list of papers to read on various topics
00:18:59 <Cale> newsham: I'll find it.
00:19:58 <Cale> yeah, http://haskell.org/haskellwiki/Research_papers
00:19:59 <lambdabot> Title: Research papers - HaskellWiki
00:20:22 <Cale> That has a list of the research papers relevant to Haskell broken down roughly by topic.
00:20:45 <Cale> The Functional Pearls section has quite a lot of particularly good ones.
00:21:44 <Kyzia> hello
00:21:46 <Kyzia> http://globalchat.pp.net.ua/
00:21:47 <lambdabot> Title: √ÎÓ·‡Î_◊‡Ú - √Î‡‚Ì‡ˇ ÒÚ‡ÌËˆ‡
00:28:14 <Cale> I wish that as an op, I could edit the past conversation on the channel, so as to remove the effects of spammers ;)
00:28:34 <TSC> Censorship!
00:28:41 <Beelsebob> yes
00:28:43 <Beelsebob> and?
00:28:48 <Beelsebob> isn't that the point of an op
00:30:54 <Shimei> So I made this mini-mini-combinator language to make turing maching programs, but it's really ugly looking with nested functions. I wonder if this is a good place to stick a monad.
00:31:56 * jeffz wonders how effective spamming a non-english language website amongst mainly english speakers is.
00:32:14 <Korollary> it's cheaper than it is effective.
00:32:15 <glguy> maybe its just the get the url into logs?
00:32:25 <jeffz> glguy: ah good point.
00:32:28 <Shimei> Google spamming.
00:32:31 <Shimei> Pagerank.
00:33:52 <Cale> Shimei: Well, a monad is just a combinator language which has the right kind of combinators in it.
00:35:51 <Cale> SEO is a pretty skeevy profession.
00:44:50 <roconnor> skeevy executaive officer?
00:46:28 <roconnor> oh search engine optimization
00:50:30 * mgsloan wonders if there are people who just optimize programs
00:51:13 <Aperculum> yes there is
00:51:17 <Aperculum> they're called ricers
00:51:30 <ari> There certainly are people whose job it is to take code written by physicists and the like and make it run properly on a supercomputer
00:51:45 <mgsloan> hah
00:51:54 <mgsloan> that's interesting
00:52:32 <mgsloan> I wonder what physicists use..  with some nice syntax haskell could be pretty good for physicists
00:52:47 <sieni> fortran and matlab?
00:52:49 <ari> Fortran, what else?
00:52:53 <mgsloan> I suppose so
00:53:46 <Adamant> Fortran is insanely well optimized for it's problem domain
00:53:54 <Adamant> compiler-wise, anyway
00:55:55 <mgsloan> yeah, I seem to recall hearing that in general
00:56:26 <Adamant> there were some attempts to make a Lisp fast enough to beat Fortran, and the end result did so. the problem is that there are way more people working on optimizing Fortran than there are optimizing Lisp or Haskell.
00:56:32 <mgsloan> pretty ugly language though
00:56:40 <Adamant> so, it's hard to maintain an advantage
00:56:43 <mgsloan> right
00:57:02 <Adamant> oh yeah, Fortran is gross
00:57:16 <Shimei> Ironically the first language on my programming language timeline that I have taped to the wall. 1954...
00:57:26 <Shimei> (first and still strong?)
00:57:38 <mgsloan> If I had to use it I'd probably write a language that outputs fortran code
00:57:45 <Adamant> Lisp was #2 and is still being used.
00:57:49 <ibid> fortran and lisp are the oldest languages still in use
00:58:03 <ibid> and yeah, fortran came first
00:58:04 <Aperculum> basic is still used!
00:58:06 <Shimei> B-O comes next on my chart. :p
00:58:16 <ibid> Aperculum: basic is young
00:58:17 <Shimei> With a name like that, no surprise it died.
00:58:23 <Adamant> there were some kind-of languages written for earlier computers, I think the first one was designed by Zuse
00:58:34 <ibid> lisp was originally intended to be a fortran variant, iirc
00:58:37 <Aperculum> ibid, basic is oldest highlevel language after fortran and lisp
00:58:43 <ibid> plankalk√ºl
00:58:49 <Shimei> What about algol?
00:58:57 <ibid> Shimei: not in use
00:58:58 <Adamant> BASIC is not that old
00:59:07 <Shimei> Oh, right. High level languages in use.
00:59:42 <Shimei> Given that the "basic" in use is VB.Net, I'm not sure it really passed on much lineage.
00:59:52 <Adamant> it will be interesting to see how Fortress turns out.
01:00:20 <ibid> Aperculum: hm, right, 1963. i though it was late 60s
01:00:44 <Aperculum> yeah, only 5 years after lisp
01:00:55 <Aperculum> although 5 years is long
01:01:44 <ibid> Aperculum: cobol is older than basic, btw, pre-60s
01:01:58 <ibid> and it's still in use, though mostly in legacy systems
01:06:27 <glguy> XML is like violence: if it doesn't solve your problem, you aren't using enough of it.
01:06:44 * jeffz wonders how you define a legacy system.
01:07:39 <quicksilver> glguy: ;)
01:07:57 <ibid> jeffz: do you mean that cobol is used in many new projects?
01:08:42 <ibid> jeffz: by legacy, i mainly mean systems that were built long ago and are in maintenance mode
01:13:36 <quicksilver> I would define legacy as "a old system with known flaws or limitations which in an ideal world we would replace, but it's so hardwired in that that is expensive or difficult to do"
01:13:40 <quicksilver> something like that
01:14:37 <osfameron> the flaw may just be that "noone knows how to make any changes to it, in the future, even though right now it works perfectly"
01:14:49 <ibid> cobol was still a mandatory course in the business oriented it program here when i started studying (not on that program, fortunately)
01:14:53 <ibid> not anymore though
01:15:21 <jeffz> ibid: well, where I work, some new cobol programs are written, nothing very large though.
01:15:38 <osfameron> isn't SAP's ABAP language largely cobol ?
01:15:43 <ibid> jeffz: "mostly" leaves room for exceptions :)
01:16:27 <Shimei> I sometimes think I might've had more fun doing COBOL than Java.
01:16:41 <ibid> quicksilver: it is my impression that most legacy systems by my definition are legacy systems by your definition :)
01:17:07 <jeffz> ibid: I guess =)  though, I still think the term legacy system is ambiguous and lends itself to be used where people think they can do a better job, often with some misunderstanding.
01:17:38 <quicksilver> legacy can mean something as simple as "not conforming to the standards we use now, because it was written before we had them"
01:17:44 <ibid> jeffz: :) what i was trying to convey is that its use is winding down
01:20:03 <jeffz> ibid: that's probably just a matter of time, I don't think I know anyone who is under 40 years of age who programs cobol.
01:21:58 <ibid> jeffz: yep
01:22:14 <ibid> jeffz: though, it was still taught here ten years ago :)
01:47:23 <Aperculum> so, the indentation matters in haskell
01:47:26 <Aperculum> like in python?
01:49:42 <ac> quicksilver: I "finished" my code
01:51:42 <ibid> Aperculum: yes, indentation matters in python too
01:51:58 <ibid> Aperculum: but the rules are different, so it's not exactly "like in python"
01:52:11 <masak> ibid: is there a main difference?
01:52:47 <ibid> masak: it's been a long time since i last looked at python :)
01:53:05 <masak> to me, there seems to be a main similarity, namely that things that are semantically subordinate other things are further to the right
01:53:11 <ibid> masak: but for one, in haskell, layout is lexical sugar for { ; }
01:53:12 <sieni> yes, the indentation dependent syntax is optional, you can throw in braces and semicolons to get a sensible syntax
01:53:34 <ac> @seen quicksilver
01:53:34 <lambdabot> quicksilver is in #haskell and #ghc. I last heard quicksilver speak 35m 56s ago.
01:54:07 <masak> there's brace syntax in python too
01:54:24 <masak> ...I think
01:54:26 <osfameron> oh python has braces too?  Well I never!
01:54:35 <masak> let me check :)
01:54:36 <ibid> masak: wasn't when i did python
01:54:47 <ibid> masak: of course it's possible they've stolen them from haskell since :)
01:54:55 <masak> I'm probably wrong, actually
01:55:23 <ibid> masak: and, of course, in python the layout enabler is ':', while haskell uses a number of keywords
01:55:43 <masak> right
01:55:58 <masak> I was thinking of this piece of code
01:56:00 <masak> http://www.freedom-to-tinker.com/tinyp2p.html
01:56:03 <lambdabot> Title: TinyP2P
01:56:07 <masak> which actually does without braces
01:56:18 <masak> so I guess python doesn't have them :)
01:58:31 <masak> ibid: yes, I'd say that is the main difference then
01:58:56 <ibid> which "that"? :)
02:01:49 <quicksilver> ac: pleased to hear it :)
02:02:05 <ac> quicksilver: it was much easier generalizing it then I was expecting
02:04:46 <pjd> masak: Python has braces, but they're for dictionaries
02:10:53 <Japsu> err, I've also heard of a python brace syntax replacing indentation, but that might have been some web service thingy's own quirk
02:14:34 <Cale> Japsu: I think that exists for blind people.
02:49:37 <yitz> Anyone here ever spend time computing lambda expressions?
02:49:54 <dibblego> yes, we do that all day long
02:50:15 <sior|sleep> yitz: Is that a question? =p
02:51:00 <yitz> I haven't so much, but I just noticed a weird identity: let c=(.), and let c4=c c c c. Then we have that c c4 == c c4 c c c c. Ever see stuff like that?
02:52:43 <sior|sleep> @pl let {c = (.); c4 = c c c c} in c4
02:52:43 <lambdabot> (line 1, column 5):
02:52:43 <lambdabot> unexpected "{"
02:52:43 <lambdabot> expecting natural, identifier or "in"
02:53:00 <opqdonut> unpl i'd think
02:53:07 <sior|sleep> right
02:53:10 <sior|sleep> either way it hates me
02:53:25 <yitz> It was probably the "sleep".
02:53:32 <opqdonut> @unpl let c = (.); c4 = c c c c in c c4
02:53:32 <lambdabot> let { c a b d = a (b d); c4 = c c c c} in c c4
02:53:42 <opqdonut> bah
02:53:45 <opqdonut> no help
02:54:03 <yitz> @type (.) ((.)(.)(.)(.))
02:54:05 <lambdabot> forall a a1 b c a2 a3. (a3 -> a -> a1 -> b -> c) -> a3 -> a -> a1 -> (a2 -> b) -> a2 -> c
02:55:18 <yitz> Given a func w/ 4 params, it composes on the 3rd, w/ the composing func. specified between params 2 and 3.
02:55:50 <yitz> @type let{c=(.);c4=c c c c}in c c4 c c c c
02:55:52 <lambdabot> forall a a1 a2 b c a3. (a -> a1 -> a2 -> b -> c) -> a -> a1 -> a2 -> (a3 -> b) -> a3 -> c
02:56:53 <yitz> Same type. In fact, they are equal. Prove it by repeatedly applying the identity x (y z)==c x y z.
02:58:44 <yitz> In fact, that identity is a semi-associativity condition that makes the entire lambda calculus into a semi-monoid. Apparently with quite interesting structure, as my example shows.
02:59:49 <yitz> c c2 == c4. c c3 == c7. But c cn cannot be reduced for n>3. More interesting stuff like that if you throw flip into the mix.
03:03:15 <yitz> Oops, sorry, composing func. specified between 3 and 4. Anyway.
03:05:49 <opqdonut> yes, interesting
03:07:46 <yitz> I discovered these things while playing with @pl, some strange and vary surprising patterns start to appear.
03:11:47 <yitz> Maybe I'll post it to the cafe.
03:36:32 <apfelmus> :'( I'd like to create a Geometry.2D module namespace
03:36:32 <yitz> Hi apfelmus. We were just discussing something I noticed yesterday. I posted it to the cafe. Do you know anything about that stuff?
03:37:03 <apfelmus> but 2D is not a valid module name. any alternative thoughts?
03:37:13 <ToRA> TwoDee ?
03:37:28 <apfelmus> yitz: uh, oh? /me looks
03:37:55 <yitz> Planar
03:38:25 <apfelmus> Planar sounds good. But is there a nice name with the numeral 2 in there?
03:39:28 <yitz> PlanarInOtherWords2Dimensional. um...
03:39:39 <apfelmus> short if possible :)
03:39:44 <ToRA> Space2D?
03:40:07 <apfelmus> Plane2D ?
03:42:22 <yitz> I guess the "InOtherWords" is implicit...
03:43:42 <apfelmus> :) It's a bit redundant, though since Plane or 2D alone would be enough
03:53:41 <apfelmus> yitz: my head hums. how do you prove c c4 = c c4 c c c c ?
03:53:53 <apfelmus> I just get stuck :)
03:54:20 <geocalc> is it better to install haddock, pfesetup, alex, c2hs, cpphs, greencard before installing happy to compile and install ghc-head ???
03:54:51 <kaol> > let reg = mkRegex "(\\d)" in show $ matchRegex reg "d123"
03:54:52 <lambdabot>   Not in scope: `matchRegex'
03:56:03 <quicksilver> apfelmus: Geometry.TwoD
03:56:26 <quicksilver> kaol: no regex in lambdabot
03:56:46 <kaol> I just wanted to check if it would give Just ["d"] as the result, too
03:57:41 <kaol> bah. good for nothing Text.Regex, if it doesn't even understand \d
03:58:15 * geocalc =<< help !!!
03:58:22 <quicksilver> text.regex uses yoru system regexp library, I thought
03:58:37 <hpaste>  yitz pasted "Proof that c c4 == c c4 c c c c" at http://hpaste.org/3172
03:58:51 <quicksilver> kaol: I don't think \d is regexp
03:59:00 <quicksilver> kaol: I think that's a perl-only thing?
04:00:05 <kaol> looks like so... Hmpf.
04:00:35 * kaol considers using FFI to call perl
04:00:57 <quicksilver> !
04:01:13 <quicksilver> I have two alternatives to suggest
04:01:30 <quicksilver> a. use the regexp notation for that, which is [[:digit:]]
04:01:51 <quicksilver> b. observer that regexps are extraordinarily ugly and use some nicer looking parser combinators
04:02:07 <yitz> c. let d = [0-9]
04:02:09 <SamB_XP> or regexp combinators
04:02:19 <SamB_XP> they aren't quite as ugly
04:03:03 <quicksilver> SamB_XP: I've never understood the point, though. why not just use parser combinators?
04:03:18 <quicksilver> The point of regexp is they are a convenient language for expressing matching
04:03:23 <kaol> I have bunch of stuff in the DB and some of the items have a regexp attached to them.
04:03:36 <quicksilver> btu as technoloogy has evolved they no longer seem so attractice
04:03:40 <quicksilver> ah
04:03:42 <quicksilver> in perl format?
04:03:45 <kaol> yes
04:04:04 <quicksilver> well that does explain it
04:04:08 <kaol> though I don't think that there's anything in there that I couldn't express as POSIX regexpes too
04:04:10 <quicksilver> have you considered Text.Regex.PCRE
04:04:12 <SamB_XP> quicksilver: they aren't so bad when you are making a two-level parser...
04:04:26 <SamB_XP> also Yi uses them for key bindings
04:04:28 <SamB_XP> doesn't it?
04:04:58 <quicksilver> SamB_XP: no, they're not that bad. ~But I don't think they're that good, either :) I just don't know why any new system would choose to use them.
04:05:17 <SamB_XP> quicksilver: I certainly don't like a lot of the things regexps are used for
04:05:18 <apfelmus> yitz: ah, i found one, too. interesting, interesting. i don't know anything about it, but digging under "Combinatory Logic" should reveal interesting things
04:06:31 <kaol> yup, looks like the most exotic thing I've used was \d. Easy enough to replace with [0-9]
04:06:36 <apfelmus> yitz: http://en.wikipedia.org/wiki/Combinatory_logic#Combinators_B.2C_C
04:06:47 <apfelmus> apparently, c is the B combinator
04:07:14 <apfelmus> unfortunately, I've got to run off for lunch
04:07:15 <apfelmus> see you
04:07:35 <geocalc> is it better to install haddock, pfesetup, alex, c2hs, cpphs, greencard before installing happy to compile and install ghc-head ???
04:08:09 <malcolmw> I don't think happy requires haddock, cpphs, or greencard
04:08:09 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
04:08:45 <geocalc> ok malcolmw thanks
04:08:48 <malcolmw> geocalc: maybe Cabal's generic warnings are confusing
04:09:12 <geocalc> hahhh
04:14:43 <profmakx> hm. Has anyone bootstrapped GHC for FreeBSD7/amd64 yet?
04:17:34 <yitz> apfelmus: yes, and flip is C.
04:17:46 <geocalc> profmakx-> by looking at ghc state page seems no
04:18:04 <profmakx> well
04:18:10 <profmakx> then i will do that tonight i think
04:18:23 <geocalc> cool
04:24:07 <SamB> hmm, shouldn't http://darcs.haskell.org/generics/comparison/ have a _darcs directory?
04:24:08 <lambdabot> Title: Index of /generics/comparison
04:24:22 <SamB> oh, it's parent has one...
04:31:39 <SamB> smash your boilerplate is interesting...
04:43:27 <dcoutts_> ac: ping, you were having issues with gtk2hs timeouts? what was the problem exactly?
04:43:59 <quicksilver> dcoutts_: I think he was struggling to get IORefs working so the timeout could share state
04:44:06 <quicksilver> dcoutts_: I believe he got it working in the end
04:44:12 <dcoutts_> ah ok, good
04:44:21 <quicksilver> although I suggested IORefs were overkill and just capturin the state in the closure is easier and more functional :)
04:46:36 <quicksilver> I noticed somethign about refactoring in haskell, actually
04:46:47 <quicksilver> if you make a pretty broad-ranging change to your code
04:46:56 <quicksilver> (like changing the data representation of something)
04:47:06 <quicksilver> if the old code works, and the new code typechecks, it generally works
04:47:44 <quicksilver> this is in contrast to dynamic languages where after a big change you have to check *ever* piece of code which directly or indirectly depends on what you changed... or there may be bugs lurking in rarely used code-paths
04:49:09 <birkenfeld> quicksilver: I noticed that too, and it gave me a warm fuzzy feeling ;)
04:50:04 <SamB> ooh, scratch your boilerplate is really neet...
04:50:05 <profmakx> i noticed quite a few positive things about refactoring and changing haskell code
04:51:23 <quicksilver> of course, it's not a rigorous theorem. Clearly you can choose to use wooly dynamic data structures and get wooly dynamic problems :)
04:51:30 <quicksilver> but it's an observation about code in practice
04:53:51 <SamB> quicksilver: but hopefully you don't use any given one very often in a program
04:54:13 <SamB> JHC uses a few dynamic things
04:54:33 <SamB> I think changing one would still cause the code using it to not typecheck, though
04:54:46 <quicksilver> SamB: sometimes I wish for a nice automatic derivation thingy to make wooly structures from wool-free structures
04:55:06 <quicksilver> SamB: e.g. given data Foo a = Bar a (Foo a) | Baz (Foo a) (Foo a)
04:55:12 <SamB> quicksilver: if you could have wool-free ones, why would you need them woolified
04:55:38 <SamB> or rather if you had already written it that way
04:55:52 <SamB> wouldn't wool-free be the way you'd want it to stay?
04:55:57 <quicksilver> SamB: for generic programming type stuff
04:56:01 <SamB> oh.
04:56:01 <quicksilver> traversing the tree generically
04:56:07 <quicksilver> a type for 'current branch'
04:56:15 <quicksilver> a type for 'other gunk attached to this branch'
04:56:32 <quicksilver> autmatic construction of zipper from data
04:56:34 <quicksilver> that sort of thing
04:56:46 <quicksilver> It would be sledgehammer to crack nut type stuff, a lot of the time
04:56:47 <quicksilver> and very ugly
04:56:53 <quicksilver> so it's not a serious proposal :)
04:57:06 <malcolmw> seen Uniplate?
04:57:09 <quicksilver> yes
04:57:16 <quicksilver> helps somewhat :)
04:57:22 <quicksilver> a case in point, actually
04:57:32 <quicksilver> suppose you have a structure Foo, and a zipper FooZipper
04:57:37 <quicksilver> and you write pretty-printers for both
04:57:48 <quicksilver> the pretty-printer for FooZipper does the "same thing" at each actual node
04:57:58 <quicksilver> but it passes continuations back up the tree
04:58:09 <quicksilver> whereas the pretty-printer for Foo works 'forwards/downwards' like always
04:58:25 <quicksilver> so you have a backwards/CPS version, and a forwards/recdescent version
04:58:31 <quicksilver> but they do teh same thing at each actual node
04:58:35 <quicksilver> and you can't share the code :(
04:58:37 <quicksilver> annoying
04:58:47 <malcolmw> you sure?
04:58:51 <quicksilver> no
04:58:57 <quicksilver> I'll hpaste some code if you like
04:59:01 <quicksilver> and you can tell me I'm being stupid :)
04:59:15 <malcolmw> I thought it would be possible to use combinators for traversal which have a different strategy
04:59:34 <malcolmw> and you plug in the same action for each node, independent of strategy
05:00:30 <hpaste>  quicksilver pasted "zipper pretty print: boilerplate?" at http://hpaste.org/3174
05:00:34 <quicksilver> there you are
05:00:47 <quicksilver> displayPt for the object itself, displayContext for the zipper
05:00:53 <quicksilver> very similar code btu I couldn't see how to unify
05:02:27 <malcolmw> hmm, the types are not isomorphic though, are they?
05:03:10 <quicksilver> well zippers aren't normall isomorphic to the object they zip
05:03:12 <quicksilver> that's rather the point
05:03:27 <quicksilver> the zipper doesn't have any constructor for the 'Leaf' nodes (Gradient and Noise)
05:03:33 <quicksilver> because you can never been 'in' a 'Leaf'
05:03:48 <quicksilver> and the zippper has two constructors for binary nodes like Blend
05:03:52 <quicksilver> and, of course, the zipper has a Top
05:04:46 <malcolmw> well, I'm not sure there is much boilerplate in your example really
05:05:08 <quicksilver> well the drawStrs and the indents
05:05:09 <malcolmw> I mean, the drawStr stuff is different for every constructor
05:05:25 <quicksilver> yes, but it's the same for corresponding constructors in type and zipper
05:05:48 <malcolmw> the indents look like you could do something
05:06:32 <malcolmw> "corresponding constructors" - but how do we know they are corresponding?  only by the name I guess
05:07:04 <quicksilver> well the correspondance is formalised by the definitions of 'up' and 'down'
05:07:07 <quicksilver> (not shown)
05:07:26 <quicksilver> e.g: ptc_down' (PTC c (Scale s pt))           = Just$PTC (PTCScale s c) pt
05:07:39 <quicksilver> but yes, that is the nub of it
05:07:46 <malcolmw> even with the indents, I'm not sure you could generate them automatically, because the pattern is non-regular (cf. PTCBlendRight)
05:07:52 <quicksilver> makes me want a third type
05:07:56 <quicksilver> 'FTNode'
05:08:05 <quicksilver> which can then be used in both plain and zipper versions
05:08:54 <quicksilver> such that PTCScale s c' becomes (PTC (NodeScale s) c'), while Scale s text becomes PT (NodeScale s) tex
05:09:06 <quicksilver> but that doesn't quite work because the arities aren't always the same
05:09:12 <quicksilver> and it makes my basic ADT less natural...
05:09:26 <quicksilver> hence, my comments about wooly and non-wooly and automatic type generation
05:09:49 <malcolmw> type families perhaps?
05:09:58 <quicksilver> I wondered that
05:10:08 <quicksilver> but I haven't explored them yet
05:10:32 <quicksilver> I mean, you could have a totally generic syntax tree type, parameterised by node types
05:11:42 <quicksilver> data SyntaxTree n = Nullary n | Unary n (SyntaxTree n) | Binary n (SyntaxTree n) (SyntaxTree n) | ....
05:11:55 <quicksilver> and then you could have a single generic zipper corresponding to that
05:12:03 <quicksilver> and parameterise the whole lot by a node type
05:12:22 <quicksilver> ... but, that isn't type safe, because it doesn't force you to only use binary nodes in a binary way
05:12:32 <quicksilver> I think you could solve *that* using GADTs
05:13:59 <quicksilver> but whatever you do, it's a whole lot less convenient than your original ADT.
05:32:07 <matt__r> I have a simple cabal script (distribution.Simple) set up and it *seems* to rebuild everything every time
05:34:46 <matthew_-> and you're just doing "runhaskell Setup.hs build" between builds?
05:35:06 <matt__r> yep
05:35:16 <matt__r> I am just getting some empirial evidence now
05:35:54 <matt__r> time for first build is 26 secs; touch one source file and build again - 27sec.
05:36:30 <matt__r> touch nothing and build takes 24 secs
05:36:31 <matthew_-> do you have -fforce-recomp in any file or options anywhere?
05:36:39 <matt__r> give or take a second or two
05:36:46 <fasta> Why doesn't this work? :t \a -> fst $ runST a By that I mean: is it just an implementation problem or is it a more serious problem?
05:37:04 <matt__r> matthew-_:  nope
05:37:31 <matthew_-> matt__r: is the filesystem mounted with noatime or anything odd like that?
05:38:02 <matt__r> I can't imagine, this is (fairly) vanilla osx and the files are on my boot disk
05:38:35 <matt__r> :q
05:38:37 <fasta> matt__r: maybe everything depends on the file you touched?
05:38:39 <matt__r> oops
05:39:05 <matt__r> but what about the untouched one, with no changes between builds, I still get 20+ seconds
05:39:11 <fasta> matt__r: and you don't use the module system.
05:39:19 <fasta> (quite unlikely)
05:39:19 <matt__r> you bet I do
05:39:30 <fasta> matt__r: ok, then file a bug :)
05:39:35 <matt__r> how could you not?
05:40:00 <matt__r> cool
05:40:18 <matthew_-> matt__r: how much code are we talking about here?
05:40:32 <matthew_-> dumping a few thousand lines of code in a bug report is not a good idea
05:40:46 <matt__r> not huge amounts - ummm, I would guess around 1500 lines ????
05:41:03 <fasta> matt__r: you should try to simplify the problem.
05:41:15 <matthew_-> and which versions of everything?
05:41:18 <fasta> A universal simplifier would be so nice :)
05:41:21 <matt__r> you mean before I file the bug?
05:41:24 <matthew_-> yep
05:41:51 <matthew_-> cabal tells you what the first file is that it's trying to compile
05:42:00 <matthew_-> does that give you any clues?
05:42:08 <hpaste>  matt__r pasted "versions of everything" at http://hpaste.org/3175
05:42:37 <matt__r> it just compiles everything everytime
05:42:56 <fasta> matt__r: when you do what?
05:43:02 <matt__r> regardless of dependencies or even if any of the files changed
05:43:23 <matt__r> ??
05:43:42 <fasta> matt__r: you must give the machine some command before compilation begins.
05:43:46 <fasta> matt__r: what is that command?
05:43:46 <matthew_-> do you have another machine you can test on? - will the code compile on a linux or windows box, for example?
05:44:12 <matt__r> runhaskell ./Setup.hs build
05:45:02 <fasta> matt__r: I have no idea, simplify(test on another platform) and file a bug.
05:45:16 <matthew_-> hmmm. does it still do it if you do a clean and configure
05:45:27 <matt__r> Well, I will make a little project that stil exhibits the behaviour and post it up on my public repo and then test it on a few machines tomorrow when I am back at work.
05:45:29 <matthew_-> I'm just wondering whether the config files have got confused
05:45:34 <matt__r> thanks for the suggestions
05:45:45 <matt__r> I have tried clean and reconfigure
05:46:05 <matthew_-> try another platform if you can to see if it's something odd with your local install
05:46:16 <matthew_-> but I'm outta ideas too on that one
05:47:15 <matthew_-> or just install linux on your mac, replacing OSX. Then try again.
05:47:17 * matthew_- ducks
05:48:07 <glen_quagmire> > 2**(-1) - 2**(-55)  -- how come when exponent is different by 54, the smaller number becomes 0.0 ?
05:48:09 <lambdabot>  0.5
05:48:38 <EvilTerran> @go what every computer scientist should know about floating point
05:48:40 <lambdabot> http://docs.sun.com/source/806-3568/ncg_goldberg.html
05:48:40 <lambdabot> Title: What Every Computer Scientist Should Know About Floating-Point Arithmetic
05:48:40 <EvilTerran> explains
05:49:24 <roconnor> > 2^^(-1) - 2^^(-55)
05:49:25 <lambdabot>  0.5
05:49:32 <roconnor> > 2^^(-1) - 2^^(-55)::Rational
05:49:33 <lambdabot>  18014398509481983%36028797018963968
05:49:59 <roconnor> > 2**(-1) - 2**(-30)
05:50:00 <lambdabot>  0.4999999990686774
05:50:04 <roconnor> > 2**(-1) - 2**(-30)::Float
05:50:05 <lambdabot>  0.5
05:50:20 <glen_quagmire> for Float it's different by 25
05:50:28 <quicksilver> fasta: did anyone answer your $ runST question?
05:50:32 <fasta> quicksilver: no
05:50:46 <glen_quagmire> > 2**(-124) - 2**(-149) :: Float
05:50:48 <lambdabot>  4.7019774e-38
05:50:50 <quicksilver> fasta: it's because $ is polymorhic
05:50:57 <glen_quagmire> > 2**(-124)  :: Float
05:50:58 <lambdabot>  4.7019774e-38
05:50:59 <quicksilver> fasta: but polymorphism is only over rank-1 types
05:51:15 <quicksilver> fasta: so a polymorphic function can't be instantiated at a rank-2 type like runST
05:51:15 <glen_quagmire> even for denormalized numbers, it's number of fraction bits + 2
05:51:23 <fasta> quicksilver: that doesn't answer the question, does it?
05:51:26 <roconnor> > floatDigits 0
05:51:27 <lambdabot>  53
05:51:30 <quicksilver> fasta: I'm getting there :)
05:51:36 <roconnor> > floatDigits (0::Float)
05:51:37 <lambdabot>  24
05:51:40 <fasta> quicksilver: (since that part I already knew)
05:51:42 <quicksilver> fasta: the reason for this restriction is to make type inference work
05:51:51 <glen_quagmire> Float has 23 bits for fraction . So, exponents should be different by 24 or more. For Double, 52 + 2 = 54
05:51:57 <glen_quagmire> I can't find why +2 is needed
05:52:10 <glen_quagmire> s/24/25
05:52:16 <roconnor> glen_quagmire: It will always be one more than the numbe returned by floatDigits
05:52:24 <quicksilver> fasta: the augmented H-M algorithm used for type inference makes certain assumptions which wouldbe violated by instantiating polymorphics at rank-2 types.
05:52:29 <roconnor> at least assuming isIEEE is true
05:52:35 <roconnor> > isIEEE 0
05:52:36 <lambdabot>  True
05:52:42 <roconnor> > isIEEE (0::Float)
05:52:43 <lambdabot>  True
05:52:51 <quicksilver> fasta: certainly people have discussed whether or not you can improve on this situation, but GHC can't
05:53:09 <fasta> quicksilver: well, I am interested in the outcome of the discussion :)
05:53:34 <fasta> quicksilver: or did they just talk and it was just that nothing came of it? ;)
05:54:29 <fasta> In the case I shown it doesn't look like an incomputable function.
05:54:36 <fasta> +have
05:55:23 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-January/021047.html
05:55:25 <lambdabot> Title: [Haskell-cafe] Composing functions with runST, http://tinyurl.com/ytrq68
05:55:41 <quicksilver> fasta: that post might be helpful (or possibly some of the rest of the thread)
05:55:50 <quicksilver> certainly conor's post, which it quotes
05:55:56 <glen_quagmire> roconnor: oh It kinda makes sense. floatDigits (0::Float) is 24. When exponent is different by 25, there will be 24 leading 0's when exponents are matched up for arithmetic
05:56:17 <fasta> quicksilver: I think I saw that post, but I will read it again. Thanks
05:56:57 <roconnor> glen_quagmire: I think it is more of a matter that the result gets truncated to 24 digits
05:57:55 * roconnor tries to remember what the IEEE says about subtraction
05:58:39 <quicksilver> roconnor: a - b will calculate a number almost, but not entirely, unlike the difference between a and b
05:59:20 * EvilTerran refers to the link he @go'd earlier
06:02:06 <opqdonut> :D
06:07:23 <Taejo> quicksilver, what does that mean?
06:09:07 <EvilTerran> Taejo, it means it might not be very accurate when numbers of widely different magnatudes are involved, and that quicksilver has read HHGG
06:09:47 <EvilTerran> ;)
06:09:47 <Taejo> ah, yes, I thought I recognised some HHGG there, but I still can't remember the reference
06:10:07 <EvilTerran> the drinks machine on the heart of gold produced something almost, but not entirely, unlike tea, iirc
06:10:19 <Taejo> indeed
06:21:04 <fasta> The module system was inconvenient so I just dumped everything in one file. (there must be a refactoring for that, and also for the inverse operation)
06:22:23 <quicksilver> fasta: I was wanting that earlier today, for an optimisation experiment
06:22:50 <quicksilver> fasta: in module optimisation can be more aggressive than cross-module, and I was curious if it would make a different for my program. But not curious enough to try it and see :)
06:23:03 <fasta> quicksilver: oh, I wanted it to debug something
06:23:11 <fasta> quicksilver: I need lots of imports otherwise.
06:23:41 <fasta> quicksilver: a module with 3800 lines of code result :P
06:23:45 <fasta> results*
06:23:56 <fasta> (well, that's not everything (of course))
06:24:06 <fasta> Just everything that's relevant.
06:25:38 <fasta> quicksilver: that shows that tool support is important
06:26:19 <fasta> I fixed my bug, though. :)
06:26:51 <fasta> I handled a situation twice (on two data structure levels)
06:27:12 <fasta> Thereby producing the complete opposite effect.
06:27:26 <fasta> Which of course only occurs for more complicated cases...
06:33:58 <pejo> fasta, I think it's fairly well known that good tools are important. (Hence GHC HQ putting in the debugger, for example).
06:34:29 <quicksilver> some good refactoring tools would be lovely
06:34:36 <fasta> pejo: sure, but the debugger is not ready.
06:34:41 <quicksilver> I keep meaning to look at hare and see how far they got, and whether the code is dead
06:36:17 <kaol> I find myself doing stuff like return . foo >>= return . bar >>= return . baz. It seems to me that having a monad in a chain like that is just useless baggage. Is there some simpler idiom for this that I've missed?
06:37:05 <Cale> kaol: ordinary function composition?
06:37:06 <TSC> baz . bar . foo ?
06:37:07 <EvilTerran> liftM (baz.bar.foo)?
06:37:11 <fasta> kaol: you don't have to use a monad
06:37:17 <matthew_-> http://www.flickr.com/photos/carlzimmer/1414689773/in/set-72157601351535771/
06:37:20 <lambdabot> Title: The Y Combinator.jpg on Flickr - Photo Sharing!, http://tinyurl.com/22xofm
06:37:29 <glen_quagmire> once a Float becomes Infinity, i can't subtract enough number to make it normal again?
06:37:40 <glen_quagmire> > (5e35 * 5e35) / 5e35:: Float
06:37:42 <lambdabot>  680.56476
06:37:47 <fasta> matthew_-: isn't that a fake?
06:37:58 <fasta> matthew_-: it looks like someone creative with PS.
06:38:00 <glen_quagmire> weird, on my machine, that's Infinity
06:38:04 <Cale> glen_quagmire: no, you can't. You can think of Infinity as a kind of error value giving information about divergence.
06:38:07 <fasta> matthew_-: and it's old
06:38:07 <kaol> it's that simple? perhaps I just haven't thought this out.
06:38:15 <glen_quagmire> Cale: ah thank you
06:38:55 <Cale> glen_quagmire: subtracting it from itself will give NaN
06:39:09 <Cale> and NaN doesn't turn into anything else.
06:39:27 <quicksilver> > reverse "NaN"
06:39:28 <lambdabot>  "NaN"
06:39:32 <quicksilver> damn it, cale's right!
06:39:33 <quicksilver> magic
06:40:02 <kaol> @pl (flip (.))
06:40:02 <lambdabot> flip (.)
06:40:27 * quicksilver peers at kaol 
06:40:36 <quicksilver> kaol: it didn't have any points in :P
06:40:45 <sieni> > let a = 5e35 :: Float in (a * a) / a
06:40:46 <lambdabot>  680.56476
06:40:58 <sieni> > let a = 5e35 :: Float in (a * a)
06:40:58 <TSC> You could define a "reverse ." operator
06:40:59 <lambdabot>  Infinity
06:41:09 <sieni> that's very peculiar
06:41:21 <glen_quagmire> maybe lambdabot optimizes stuff
06:41:29 <quicksilver> probably lambdabot is useing -fexcess-precision
06:42:27 <glen_quagmire> there is not such option quicksilver
06:42:34 <quicksilver> what do you mean?
06:42:35 <glen_quagmire> @g -fexcess-precision
06:42:35 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google gsite gwiki . v
06:42:38 <quicksilver> of course there is
06:42:42 <quicksilver> it's a ghc option
06:42:46 <quicksilver> and lambdabot uses ghc :P
06:42:59 <glen_quagmire> i mean, google doesn't return that
06:43:06 * glen_quagmire searches on haskell.org
06:43:07 <quicksilver> it allows it to store intermediate values of calculations in registers
06:43:24 <quicksilver> and since registers have more precision, you may get slightly different answers
06:43:31 <quicksilver> that is, excess precision :)
06:43:49 <idnar> hmm, no google hits, for that flag
06:43:51 <idnar> that's pretty interesting
06:43:55 <fasta> quicksilver: does that also work for ints or only floating point?
06:43:57 <glen_quagmire> oh. google interprets - in -fexcess-precision in its own way
06:43:57 <idnar> oh
06:44:00 <idnar> you need to quote it
06:44:07 <glen_quagmire> @g fexcess-precision
06:44:07 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google gsite gwiki . v
06:44:08 <sieni> glen_quagmire: you should perhaps google for fexcess-precision, - in the front of a search term causes the pages not containing that word to be searched
06:44:10 * idnar smacks forehead
06:44:18 <quicksilver> I have 468 hits for it :)
06:44:35 <sieni> glen_quagmire: oh, you noticed already :-)
06:45:26 <glen_quagmire> hrm with -fexcess-precision, I still get Infinity for (5e35 * 5e35) / 5e35 :: Float
06:45:44 <quicksilver> odd. try with -O2 as well?
06:46:28 <glen_quagmire> still Infinity. I 'm trying it in ghci -fexcess-precision -O2
06:46:56 <quicksilver> you might have to compile it
06:47:07 <quicksilver> I shouldn't think -fexcess-precision makes any different to interpreted coe
06:47:08 <quicksilver> code
06:47:20 <glen_quagmire> but isn't lambabot interpreter?
06:47:32 <EvilTerran> not exactly, iirc
06:47:34 <quicksilver> I'm not sure if -O2 makes any different
06:47:42 <quicksilver> (to interepreted code)
06:47:45 <EvilTerran> it's hsPlugins, whatever that does
06:47:52 <quicksilver> glen_quagmire: well obviously lambdabot is an interpreter
06:47:55 <quicksilver> > 3+4
06:47:56 <lambdabot>  7
06:48:01 <quicksilver> since it interprets :)
06:48:07 <quicksilver> however, it does so by compiling
06:48:16 <quicksilver> It is an interpreter which works by using ghc to compile code
06:48:43 <quicksilver> unlike ghci which is an interpreter which does not compile to native code, but compiles to a kind of VM/bytecode
06:51:13 <glen_quagmire> this is weird
06:51:26 <glen_quagmire> when I compile with -O2 only, I get 680.56476, same as lambdabot
06:51:44 <glen_quagmire> when I compile with -O2 with -fexcess-precision, I get 5e35
06:51:49 <quicksilver> interesting
06:52:09 <quicksilver> I suspect you've found a bug in the interpreter then
06:52:28 <quicksilver> I think that 680.56476 is the "correct" answer for IEEE 32-bit floats
06:52:28 <glen_quagmire> No i actually compiled to native binary
06:52:52 <quicksilver> and the interpreter giving 'Infinity' is in fact a bug in the way that the ghci interpreter implements Float
06:52:56 <quicksilver> however, that is only a guess
06:53:12 <quicksilver> I'm no expert on floating-point edge cases
06:53:31 <glen_quagmire> --make -fexcess-precision -O    for the win
06:54:41 <matthew_-> do you get different behaviour with -fvia-C and -fasm ?
06:55:37 <quicksilver> glen_quagmire: if you can be bothered, it would be interesting to try the C program "a = 5e35; b = (a*a)/a;"
06:55:40 <quicksilver> with 'float a'
06:55:44 <quicksilver> (well and gloat b)
06:55:54 <glen_quagmire> matthew_-: --make -fvia-C -fasm  returns Infinity for (5e35 * 5e35) / 5e35
06:56:07 <matthew_-> glen_quagmire: no, one or the other.
06:56:24 <matthew_-> "--make -fvia-C" vs "--make -fasm"
06:56:29 <idnar> maybe it's optimizing that to 5e35?
06:57:36 <glen_quagmire> matthew_-: both version returns 5e35. I think -fexcess-precision with -O will figure out 5e35 can be cancelled out on (5e35 * 5e35) / 5e35
06:58:38 <glen_quagmire> from #geordi, geordi: {float a = 5e35; cout<<(a*a)/a; }  returns 5e35
06:58:58 <idnar> I get 499999980845158122682707800104108032 with gcc
06:59:31 <yitz> > (1.7976931348623158e308, 1.7976931348623159e308)
06:59:34 <lambdabot>  (1.7976931348623157e308,Infinity)
06:59:41 <yitz> Same as on my machine.
06:59:42 <idnar> which I guess is pretty close to 5e35
07:00:13 <yitz> but (5e35 * 5e35) / 5e35 :: Float is Infinity on my machine
07:00:21 <matthew_-> it works correctly in lua
07:00:27 <matthew_-> (you get back 5e35)
07:03:48 <yitz> Forget the divide: 5e35*5e35 is Infinity in ghci
07:04:12 <matthew_-> it works in perl aswell
07:04:24 <glen_quagmire> > Infinity / 0
07:04:25 <lambdabot>   Not in scope: data constructor `Infinity'
07:04:33 <glen_quagmire> > Inf / 0
07:04:33 <lambdabot>   Not in scope: data constructor `Inf'
07:04:35 <yitz> It should be 2.5e70, well within the limit of 1e308. Looks like a bug.
07:05:37 <yitz> Wait a second - you are saying ::Float, I was looking at Double, duh
07:06:11 <quicksilver> matthew_-: that's not really "correct"
07:06:23 <quicksilver> matthew_-: it's supposed to give junk, since it overflows the range of Float
07:06:27 <quicksilver> matthew_-: that's ratehr the point :)
07:06:37 <quicksilver> matthew_-: the only question is what kind of junk you expect
07:06:45 <matthew_-> quicksilver: meh, potato, potato ;)
07:06:51 <quicksilver> lua + perl almost surely use double behind the scenes
07:06:55 <yitz> > 5e35*5e35::Float
07:06:56 <quicksilver> so are useless for this test
07:06:56 <lambdabot>  Infinity
07:07:06 <matthew_-> quicksilver: indeed.
07:07:14 <yitz> > (5e35*5e35)/5e35::Float
07:07:16 <lambdabot>  680.56476
07:07:24 <glen_quagmire> how can I get largest Float?
07:07:26 <Japsu> lol
07:07:31 <matthew_-> maxBound
07:07:33 <Japsu> > maxBound :: Float
07:07:34 <lambdabot>   add an instance declaration for (Bounded Float)
07:07:34 <lambdabot>     In the expression: maxB...
07:07:38 <Japsu> nope!
07:07:38 <cpoucet> > 1/ 0
07:07:39 <lambdabot>  Infinity
07:07:40 <matthew_-> oopsy!
07:07:41 <cpoucet> there you go
07:07:43 <cpoucet> maximum float :)
07:07:55 <yitz> @let binSearch p a b|c<=a||c>=b=a|p c==LT=binSearch p c b|otherwise=binSearch p a c where{c=(a+b)/2}
07:07:58 <matthew_-> > pred ((1/0)::Float)
07:08:02 <lambdabot>  Infinity
07:08:03 <lambdabot> Defined.
07:08:10 <Japsu> what
07:08:12 <Japsu> > succ 1.0
07:08:13 <lambdabot>  2.0
07:08:15 <Japsu> evil
07:08:21 <matthew_-> highly
07:08:27 <Japsu> I mean, EVIL
07:08:39 <Japsu> or well
07:08:42 <Japsu> floats are numerable
07:08:47 <Japsu> but real numbers aren't
07:08:59 <quicksilver> the enum instance for float and double is quite humorous
07:09:05 <quicksilver> since it doesn't enumerate them at all
07:09:20 <glen_quagmire> what should I pass to maxBound? Bounded are enums?
07:09:20 <yitz> > binSearch (flip compare (1e100::Float).(*1e38)) 1 10
07:09:21 <lambdabot>  9.999999
07:09:23 <quicksilver> its entire raison-d'etre is the [a..b] syntax, which is pretty daft
07:09:24 <idnar> > [1.0..5.0]
07:09:26 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
07:09:29 <idnar> ah
07:09:30 <Japsu> perhaps it's needed for the betweenum trick?
07:09:31 <Japsu> ah
07:09:33 <Japsu> that, too
07:09:45 <yitz> > 9.999999e38
07:09:46 <lambdabot>  9.999999e38
07:09:49 <quicksilver> yes, really that should be a different type-class
07:09:50 <matthew_-> > let inf = ((1/0)::Float) in take 10 . iterate pred $ inf
07:09:51 <lambdabot>  [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Inf...
07:09:53 <quicksilver> 'rangeable' or something
07:09:53 <yitz> > 9.9999991e38
07:09:54 <lambdabot>  9.9999991e38
07:09:58 <glen_quagmire> I want the largest valid Float, not Infinity
07:10:01 <yitz> hmm
07:10:02 <EvilTerran> > binSearch (flip compare (1/0)) 1 10
07:10:03 <lambdabot>  9.999999999999998
07:10:06 <Japsu> quicksilver: yeah
07:10:10 <quicksilver> but the haskell committee were opposed to proliferation of typeclasses
07:10:13 <EvilTerran> oh, wait
07:10:27 <quicksilver> so we have to live with a broken Monad class and a broken Enum class
07:10:27 <yitz> > 9.999999999999998e38
07:10:28 <Japsu> > (toEnum . fromEnum $ 42 :: Integer) :: Double
07:10:29 <lambdabot>  9.999999999999998e38
07:10:29 <lambdabot>  Couldn't match expected type `Double'
07:10:31 <EvilTerran> never mind, that's not helpful
07:10:33 <cpoucet> we need more typeclasses
07:10:40 <yitz> > 9.9999999999999999e38
07:10:41 <EvilTerran> we need Bind and Return! ;)
07:10:42 <lambdabot>  1.0e39
07:10:45 <quicksilver> as well as no Tuple class, or other obvious things
07:10:45 <idnar> :t pred
07:10:47 <lambdabot> forall a. (Enum a) => a -> a
07:10:54 <yitz> > 9.999999e38::Float
07:10:56 <lambdabot>  Infinity
07:10:58 <ToRA> > take 4 [1.1 , 1.2 ..]
07:10:59 <lambdabot>  [1.1,1.2,1.2999999999999998,1.3999999999999997]
07:11:09 <cpoucet> > 4e38::Float
07:11:10 <lambdabot>  Infinity
07:11:11 <yitz> > 9.999998e38::Float
07:11:13 <lambdabot>  Infinity
07:11:15 <glen_quagmire> > (2**(128) :: Float)
07:11:15 <cpoucet> > 04e38::Float
07:11:17 <cpoucet> > 0.4e38::Float
07:11:21 <lambdabot>  Infinity
07:11:21 <lambdabot>  Infinity
07:11:22 <yitz> > 9.99999e38::Float
07:11:22 <lambdabot>  4.0e37
07:11:23 <lambdabot>  Infinity
07:11:34 <cpoucet> yitz: stop asking the same thign
07:11:47 <cpoucet> or at least, use a binary search
07:12:00 <glen_quagmire> > (2^128 - 1 :: Float)
07:12:01 <lambdabot>  Infinity
07:12:24 <yitz> > binSearch (flip compare (1e100::Float).(*1e38::Float)) 1 10
07:12:24 <lambdabot>  Parse error
07:12:34 <yitz> > binSearch (flip compare (1e100::Float).((*1e38)::Float)) 1 10
07:12:34 <lambdabot>      The section `(* 1.0e38)' takes one argument,
07:12:35 <lambdabot>     but its type `Float' ha...
07:12:54 <yitz> > binSearch (flip compare (1e100::Float).(*(1e38::Float)) 1 10
07:12:54 <lambdabot>  Unbalanced parenthesis
07:12:55 <EvilTerran> > 1e100 :: Float
07:12:56 <lambdabot>  Infinity
07:13:00 <EvilTerran> > 1e100 :: Double
07:13:01 <lambdabot>  1.0e100
07:13:10 <yitz> > binSearch (flip compare (1e100::Float).(*(1e38::Float))) 1 10
07:13:11 <lambdabot>  9.999999
07:13:19 <EvilTerran> @hoogle Double -> Float
07:13:20 <lambdabot> No matches, try a more general search
07:13:23 <yitz> > binSearch (flip compare (1e100::Float).(*(1e38::Float))) 1 10 :: Float
07:13:24 <lambdabot>  9.999999
07:13:42 <yitz> > 1e39::Float
07:13:43 <lambdabot>  Infinity
07:14:26 <quicksilver> you can work it out from floatRange, can't you?
07:14:34 <quicksilver> > floatRange (undefined :: Float)
07:14:35 <lambdabot>  (-125,128)
07:14:57 <matthew_-> you can work it out from the spec for IEEE floating point numbers...
07:15:03 <EvilTerran> > binSearch (flip compare (1/0 :: Float) . realToFrac) 1 (1e100::Double)
07:15:05 <lambdabot>  9.999999999999998e99
07:15:58 <idnar> > 6.8e38
07:15:59 <quicksilver> matthew_-: well Float isn't guaranteed to be IEEE, let alone n-bit IEEE for any particular value of 'n'
07:15:59 <lambdabot>  6.8e38
07:16:01 <EvilTerran> ...
07:16:12 <EvilTerran> ?type flip compare (1/0 :: Float) . realToFrac
07:16:13 <lambdabot> forall a. (Real a) => a -> Ordering
07:16:23 <idnar> > 6.81e38
07:16:24 <EvilTerran> ?type flip compare (1/0 :: Float)
07:16:26 <lambdabot>  6.81e38
07:16:26 <lambdabot> Float -> Ordering
07:16:35 <idnar> > 6.9e38
07:16:37 <lambdabot>  6.9e38
07:16:38 <idnar> hrm.
07:16:44 <quicksilver> idnar: you're using Doubles.
07:16:54 <quicksilver> idnar: this does not appear relevant to the current discussion :P
07:17:05 <idnar> oh yeah
07:17:08 <idnar> silly me
07:17:13 <idnar> > 6.8e38 :: Float
07:17:14 <lambdabot>  Infinity
07:17:17 <quicksilver> > 2 ^ 128
07:17:17 <idnar> > 3.4e38 :: Float
07:17:19 <lambdabot>  340282366920938463463374607431768211456
07:17:19 <lambdabot>  3.4e38
07:17:27 <idnar> > 3.41e38 :: Float
07:17:29 <lambdabot>  Infinity
07:17:30 <yitz> > (3.4028235e38::Float, 3.4028235e39::Float)
07:17:31 <lambdabot>  (3.4028235e38,Infinity)
07:17:32 <idnar> I believe that's the right one
07:17:33 <cpoucet> pm please
07:17:39 <quicksilver> yeah, it's what I said
07:17:42 <quicksilver> it's 2^128
07:17:54 <quicksilver> where 128 is given by 'floatRange'
07:18:06 <quicksilver> which would be the quicker way to work it out :P
07:18:12 <yitz> > (3.4028235e38::Float, 3.4028236e38::Float)
07:18:13 <lambdabot>  (3.4028235e38,Infinity)
07:18:27 <EvilTerran> > compare (1/0) (1/0)
07:18:29 <lambdabot>  EQ
07:18:35 <quicksilver> > (fromIntegral $ 2^128) :: Float
07:18:36 <lambdabot>  Infinity
07:18:37 <EvilTerran> > compare (1/0) (2/0)
07:18:38 <lambdabot>  EQ
07:19:03 <yitz> Same as on my machine. Except the binSearch worked for me here, but not on the bot. Interesting.
07:20:30 <byorgey> hm, I come in #haskell to escape from the messy, impure world, and everyone's playing with floating-point.  Looks like it's going to be a long day. =P
07:20:34 <djfroofy> can some explain what `(1:)' means in the context of this: fix ((1:) . scanl (+) 1)
07:20:49 <byorgey> oh, that's better =)
07:20:50 <Botje> > (1:) [2,3,4,5]
07:20:52 <lambdabot>  [1,2,3,4,5]
07:21:06 <EvilTerran> @unpl (1:)
07:21:06 <lambdabot> (\ a -> 1 : a)
07:21:20 <EvilTerran> it's a section of (:)
07:21:37 <byorgey> djfroofy: does that answer your question?
07:22:07 <osfameron> I'm more scared by the scanl (and the fix :-)
07:22:26 <EvilTerran> is that another scary fibonacci numbers?
07:22:29 <djfroofy> byorgey: I got a wide array of answers, but my interpretation is its a function that takes a list and returns 1 consed with the list?
07:22:36 <byorgey> EvilTerran: of course =)
07:22:43 <byorgey> djfroofy: that's right.
07:23:05 <osfameron> @index fix
07:23:05 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
07:23:07 <EvilTerran> (foo ??) = (\bar -> foo ?? bar), regardless of what expression foo is, and what operator ?? is
07:23:16 <EvilTerran> (:) is an operator like any other in that respect
07:23:26 <EvilTerran> similarly, there's (?? foo) = (\bar -> bar ?? foo)
07:23:29 <djfroofy> EvilTerran: this goes back to my rant yesterday about having to read a phd thesis to understand a function - fix in this case
07:23:43 <EvilTerran> fix *is* pretty hairy
07:23:59 <EvilTerran> operator sections, however, are pretty fundamental haskell
07:24:00 <Olathe> @src fix
07:24:00 <lambdabot> fix f = let x = f x in x
07:24:27 <Olathe> @type fix (1+)
07:24:29 <lambdabot> forall t. (Num t) => t
07:24:34 <djfroofy> EvilTerran: yes, the pretzel semantics scare me
07:24:44 <Olathe> > fix (+1)
07:24:45 <lambdabot>  Exception: <<loop>>
07:25:00 <EvilTerran> Olathe, are we back to discussing infinity again? ;)
07:25:34 <quicksilver> djfroofy: yah, definitely seperate your concerns into (1:) and fix
07:25:38 <byorgey> djfroofy: the thing is, you don't have to understand fix to understand Haskell, the language.  It isn't part of the language proper.
07:25:44 <quicksilver> djfroofy: most people find fix a bit mysterious at first
07:25:46 * MyCatSchemes wonders how 'big' aleph-(aleph one) is?
07:25:49 <byorgey> but Haskell is general and powerful enough that you can easily define things such as fix.
07:25:53 <quicksilver> djfroofy: however (1:) is not too unpleasant
07:26:01 <Olathe> > fix (1:) []
07:26:02 <lambdabot>  Couldn't match expected type `[a] -> t'
07:26:13 <byorgey> Olathe: you don't need the [].
07:26:17 <Olathe> > fix (1:)
07:26:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:26:23 <Olathe> O-o
07:26:49 <MyCatSchemes> > fix (\l -> head l : map (+1) tail l)
07:26:50 <lambdabot>  Couldn't match expected type `[a]'
07:26:53 <EvilTerran> MyCatSchemes, i was under the impression that alephs were only defined for natural number subscripts
07:26:55 <byorgey> fix (1:) says, "find a list which is invariant under the operation of adding a 1 to the front."
07:26:56 <djfroofy> byorgey: agreed.  though. i don't like running into a line of code and taking it for granted.  My journey down the rabbit hole started here: http://haskell.org/haskellwiki/Implement_a_chat_server
07:26:57 <lambdabot> Title: Implement a chat server - HaskellWiki
07:27:10 <byorgey> Obviously, the infinite list of all 1's fits that bill.
07:27:11 <yitz> > take 20 $ fix ((1:) . scanl (+) 1)
07:27:12 <quicksilver> djfroofy: then you can understand fix as "(1:) is all very well but we need a list to apply it to. What list shall we apply it to? I know, let's apply it to *itself*, recursively"
07:27:12 <MyCatSchemes> EvilTerran: yeah, and Euclid was under the impression parallel lines didn't meet. Fuck that. ;)
07:27:12 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
07:27:15 <Olathe> > fix (\x -> (x + 1):x)
07:27:16 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
07:27:16 <lambdabot>       Expected...
07:27:36 <EvilTerran> to be honest, fix really isn't all that useful in haskell, except for golfing, and occasionally for equational reasoning and whatnot
07:27:42 <byorgey> djfroofy: yup, I understand.  "journey down the rabbit hole" is a very good way to describe it =)
07:27:47 <Olathe> > fix (\x -> ((head x) + 1):x)
07:27:48 <lambdabot>  Exception: <<loop>>
07:27:51 <EvilTerran> especially not fix without a 2-ary function as its first parameter
07:28:46 <djfroofy> I guess the haskell irc channel is my new and improved hoogle ;)
07:29:03 <Olathe> @hoogle irc people
07:29:04 <lambdabot> Did you mean: Irc People
07:29:04 <lambdabot> Prelude.undefined :: a
07:29:04 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
07:29:15 <EvilTerran> > fix (\f x -> x + if x > 0 then f (x-1) else 0) 10
07:29:16 <byorgey> Olathe: that won't work since there's nothing for it to "get started" on
07:29:16 <lambdabot>  55
07:29:16 <Olathe> Heh. ask.
07:29:36 <EvilTerran> ... why did that come up with ask?
07:29:46 <idnar> that's amusingly appropriate
07:29:50 <byorgey> hehe, nice
07:29:56 <yitz> fix is useful if you want to use mdo (recursive do notation) - you don't use fix directly, but you need to define in order to give your Monad an instance of MonadFix so that you can use mdo. Of course, most common monads are predefined with the instance so we don't have to worry about fix too much.
07:30:06 <oerjan> @hoogle a b
07:30:07 <lambdabot> Prelude.undefined :: a
07:30:07 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
07:30:07 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
07:30:41 <EvilTerran> weird
07:30:45 <byorgey> fix is also useful for expressing recursive functions in a form which can be extended and manipulated using various combinators.
07:31:02 <EvilTerran> byorgey, as i said, equational reasoning and whatnot
07:31:14 <EvilTerran> i call that "whatnot" ;)
07:31:16 <byorgey> EvilTerran: that's not equational reasoning.
07:31:19 <oerjan> EvilTerran: probably the first thing whose result matches the t1 t2 form
07:31:20 <byorgey> oh.
07:31:37 <byorgey> for example, writing a recursive function in a fix-able form allows you to easily add memoization.
07:31:56 <EvilTerran> sorry, i said "as i said" before i'd finished parsing your prior sentence
07:32:06 <EvilTerran> hence my attempted save
07:32:08 <quicksilver> byorgey: but of course, that's orthogonal to the invention of 'fix' as a named thingy
07:32:22 <quicksilver> byorgey: that's just "if you write your recursive functions like this, then you can'
07:32:42 <quicksilver> byorgey: although, certainly, it does rather beg for you to give a name to the canonical knot-tyer
07:32:48 <yitz> @go haskell mdo
07:32:48 <quicksilver> maybe we should call fix 'boyscout'
07:32:49 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
07:32:49 <lambdabot> Title: 7.3. Syntactic extensions
07:33:01 <yitz> @go haskellwiki recursive do
07:33:03 <lambdabot> http://www.haskell.org/haskellwiki/Recursion_in_a_monad
07:33:03 <lambdabot> Title: Recursion in a monad - HaskellWiki
07:33:04 <byorgey> quicksilver: right.  I was just pointing out that fix turns out to be useful for more than just writing concise Fibonacci numbers.
07:33:10 <quicksilver> true
07:33:18 <byorgey> hehe
07:33:20 <quicksilver> type-level fix would be useful for similar reasons
07:33:28 <byorgey> yup
07:33:32 <quicksilver> you can transform Stream into List using type-level fix
07:33:39 <quicksilver> if you stick a 'Maybe' in
07:33:51 <quicksilver> if I'm not mistaken
07:34:14 <sarehu> Stream?
07:35:58 <byorgey> sarehu: a stream is a data structure that stores a current value, and a function for getting the next value from the current one.
07:36:12 <birkenfeld> does anyone else have problems with haskell.org right now?
07:36:32 <Olathe> It works for me.
07:36:58 <byorgey> works for me too.
07:37:14 <quicksilver> sarehu: or, if you like, a Stream is a List without the 'Nil' case
07:37:20 <quicksilver> sarehu: or without the [] case
07:37:26 <Olathe> http://haskell.org/testthesiteformelambdabot
07:37:36 <quicksilver> sarehu: so, since it can never end, it is 'forced' to be infinite
07:37:36 <sarehu> ok, just wondering about the capitalization
07:37:43 <Olathe> I guess lambdabot hates 404s
07:37:56 <quicksilver> http://haskell.org # go LB go
07:37:57 <lambdabot> Title: Haskell - HaskellWiki
07:38:04 <Olathe> Yay lambdabot !
07:38:25 <birkenfeld> strangely, it works through tor
07:38:28 <birkenfeld> must be routing problems
07:38:51 <fasta> Meh, I am printing a number somewhere, but I have have no idea where exactly...
07:39:00 <oerjan> sarehu: all haskell type constructors are capitalized
07:41:13 <sarehu> I was wondering if whoever was referring to some specific datatype that existed in the wild
07:41:28 <birkenfeld> how do you "multiply" a list? is (concat . replicate n) the canonical way?
07:41:33 <nominolo> hm, what is the preferred data structure for "a map without values" or "a map where key = value" ?
07:41:48 <quicksilver> nominolo: Data.Set ?
07:41:54 <quicksilver> nominolo: not quite sure what you mean :)
07:42:00 <quicksilver> nominolo: in what respect is it not a list?
07:42:11 <nominolo> i need fast lookup
07:42:28 <quicksilver> nominolo: sounds like Data.Set
07:42:30 <nominolo> but, well, Set seems amazingly obvious
07:42:38 <quicksilver> as long as you don't mind uniqueness being forced
07:42:42 <byorgey> birkenfeld: it depends what you want.  (concat . replicate n) seems reasonable for multiplying by a positive integer.
07:42:56 <quicksilver> Data.Set is implemented, roughtly, as Data.Map with key = value
07:42:57 <quicksilver> I think
07:43:30 <nominolo> quicksilver, i'm porting an ML implementation.  they used a map, i think
07:43:53 <birkenfeld> byorgey: it seems to even accept negative integers, handling them as zero
07:43:59 <birkenfeld> which is fine
07:44:06 <EvilTerran> @src replicate
07:44:06 <lambdabot> replicate n x = take n (repeat x)
07:44:10 <EvilTerran> @src take
07:44:10 <lambdabot> take n _      | n <= 0 =  []
07:44:10 <lambdabot> take _ []              =  []
07:44:10 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
07:44:51 <byorgey> birkenfeld: yup.
07:45:20 <dcoutts_> nominolo: got that link to the make filesystem simulator?
07:45:34 <nominolo> dcoutts_, one sec
07:45:43 <birkenfeld> btw, where does one report bugs in the GHC library docs?
07:45:44 <dcoutts_> kolmodin: got the make code we started writing?
07:45:57 <dcoutts_> I wrote a bit more on the train home
07:45:58 <djfroofy> @src scanl
07:45:58 <lambdabot> scanl f q ls = q : case ls of
07:45:58 <lambdabot>     []   -> []
07:45:58 <lambdabot>     x:xs -> scanl f (f q x) xs
07:45:58 <quicksilver> nominolo: I'm pretty sure Data.Set is what you want
07:46:02 <dcoutts_> pencil and paper :-)
07:46:15 <oerjan> birkenfeld: ghc trac?
07:46:19 <birkenfeld> ok
07:46:40 <nominolo> dcoutts_, http://code.haskell.org/~nominolo/
07:46:41 <lambdabot> Title: Index of /~nominolo
07:46:46 <dcoutts_> nominolo: ta
07:47:05 <nominolo> quicksilver, they use a unique-map.  i guess that's faster than a normal map
07:48:01 <birkenfeld> hm, maybe it's a haddock bug
07:48:14 <byorgey> birkenfeld: what's the bug?
07:48:29 <dons> moin!
07:48:30 <nominolo> is IntMap deprecated now?
07:48:38 <birkenfeld> in the docs for Prelude.elem, it says "...usually written in infix form, e.g., x elem xs."
07:48:47 <birkenfeld> that is, the backquotes are missing
07:48:52 <birkenfeld> but they seem to be in the source
07:48:53 <Olathe> The bug is one of those that can sit on the surface of a pond.
07:49:03 <dons> hey nominolo
07:49:14 <nominolo> hi dons
07:49:26 <nominolo> back in OR?
07:49:41 <dons> yeah, finally.
07:49:47 <dons> mwhha, xmonad lambdacats, http://arcanux.org/lambdacats.html
07:49:47 <lambdabot> Title: Lambdacats
07:49:50 <stoic_> "fillBelly = foldr (++) [] fridgeContents"
07:49:56 <stoic_> just saw that!
07:50:15 <byorgey> as soon as someone makes a 'catamorphism' one, I will be happy =)
07:50:18 <dons> hah!
07:50:27 <dons> byorgey: you know what you need to do.
07:51:05 <djfroofy> is there something similar to the lambdabot `@src' that i can use in ghci or elsewhere?
07:51:22 <dons> not really.
07:51:33 <dons> we should bundle up these things in a tiny tool that we can embed easily in ghci
07:51:35 <Mortez> private msg
07:51:38 <dons> (unlike lambdabot, which is a bit hard)
07:51:42 <oerjan> in hugs you can do :f function
07:51:45 <nominolo> you can print lines of the source, iirc
07:52:03 <dons> :list works for local files
07:53:39 <stoic_> cant GHCi on Acid do @src?
07:53:52 <dons> yeah, but its hard to get it to work
07:54:03 <allbery_b> yes.  see "unlike lambdabot, which is a bit hard [to embed]"
07:54:18 <allbery_b> (come to think ofit, last I'd heard GOA was broken)
07:54:21 <dons> goa is the lambdabot binding
07:54:22 <dons> right
07:55:56 <birkenfeld> byorgey: haddock seems to take the `elem` as a link to elem
07:56:21 <byorgey> birkenfeld: oh, yes, that's Haddock syntax.
07:56:39 <Olathe> Haddock is kind of fishy.
07:56:50 <byorgey> so it's a bug in the documentation.  it needs some sort of escape characters or something to display the ` characters.
07:56:54 <byorgey> haha
07:56:57 <birkenfeld> the docs mention only '...' and `...' though
07:57:03 <quicksilver> dons: is hs-plugins a "sanitisation" of the GHC API, or is it something else entirely?
07:57:07 <byorgey> oh, really?  hm
07:57:42 <allbery_b> quicksilver: something else, currently.  we were all hoping porting it to use ghc-api would happen this hackathon...
07:57:53 <oerjan> hs-plugins is older than the GHC API, isn't it?
07:58:13 <quicksilver> allbery_b: hmm. which parts are 'else'. It has its own linker?
07:58:23 <quicksilver> allbery_b: presumably it doesn't have its own parser?
07:58:38 <allbery_b> it does have its own parser
07:58:47 <allbery_b> (for .hi files)
07:58:49 <quicksilver> ah
07:58:52 <quicksilver> right
07:59:03 <quicksilver> but the haskell code itself it runs 'ghc' as a sub process ?
07:59:10 <allbery_b> yes
07:59:21 <quicksilver> and then it dynamically loads the .o file produced?
07:59:26 <allbery_b> yep
07:59:30 * quicksilver nods
07:59:43 <birkenfeld> I'll put it on the ghc trac in any case
08:00:09 <dons> quicksilver: it predates the ghc-api
08:00:26 <quicksilver> dons: *nod*
08:00:26 <fasta> I wish I could tell the debugger: halt on IO and show the LOC that caused it.
08:02:57 <roconnor> ohh, the austrailian dollar hits 90 cents US.
08:03:02 <roconnor> ... poor dons
08:03:27 <roconnor> time to ask for a raise
08:06:13 * oerjan wonders if one could implement a magical kind of ?line implicit variable
08:06:35 <dylan> oerjan: for ghci?
08:06:50 <oerjan> for ghc profiling
08:07:19 <dylan> ah. For a minute I thought you meant something like the "it" variable in ghci
08:07:43 <oerjan> no, i meant a variable that could be used by a function to fine the line _calling_ it
08:07:49 <oerjan> *find
08:08:00 <oerjan> fine, too i guess
08:08:36 <EvilTerran> <insert pun about expensive functions and fines>
08:08:44 <oerjan> if a function included it explicitly in its type, error messages could use it
08:09:10 <oerjan> such as those dreader pattern matching errors in Prelude functions
08:09:29 <oerjan> *dreaded, whatever happened to my typing skills :(
08:09:31 <EvilTerran> maybe something more general - the call stack, or something?
08:09:50 <EvilTerran> something like what http://perldoc.perl.org/functions/caller.html returns
08:09:51 <lambdabot> Title: caller - perldoc.perl.org
08:10:47 <fasta> Can I ask the ghci debugger to step 1000 times?
08:11:06 <fasta> Then I could use binary search to find the problem
08:11:12 <fmardini> hi, just installed 6.6.1 on osx 10.4 using ports, but when i run examples from soe i get Unable to open X display :0.0, all works great in ubuntu, is this related to a missing haskell library or do i have an issue with my x11 installation
08:11:21 <dons> roconnor: hah
08:11:34 <quicksilver> fmardini: maybe you don't have X running?
08:11:54 <quicksilver> fmardini: I don't believe the haskell/X stuff will autorun it
08:11:54 <swiert> fmardini: Have you installed all the additional X stuff that comes with XCode?
08:12:17 <fmardini> quicksilver: yeah i did
08:12:19 <swiert> I seem to remember that it doesn't install by default.
08:12:26 <fmardini> quicksilver: how can i make sure its running
08:12:39 <puusorsa> apple-tab
08:12:44 <roconnor> dons: soon your Galios salery will match your university salery :P
08:12:45 <puusorsa> do you see x in there?
08:13:11 <dons> roconnor: :P
08:13:29 <dons> damn this economy
08:13:29 <swiert> dons: travel back ok?
08:13:29 <fmardini> puusorsa: what is apple tab
08:13:41 <puusorsa> fmardini, the apple key on your keyboard
08:13:50 <puusorsa> and tab key. you know, how you switch between apps
08:13:52 <dons> swiert: yeah, flight was pretty good. though got detained briefly at frankfurt :(
08:14:03 <roconnor> detained?
08:14:04 <fmardini> puusorsa: silly me :), no no x
08:14:12 <fmardini> puusorsa: how can i start it
08:14:19 <puusorsa> click on the icon?
08:14:24 <roconnor> xmonad is contraband
08:14:24 <swiert> fmardini: In applications/X11
08:14:27 <fmardini> no icon
08:14:46 <puusorsa> maybe you don't have it installed?
08:14:47 <swiert> fmardini: Applications/Utilities/X11 actually.
08:14:58 <dons> roconnor: yeah, something like that. they let me on the flight though, so that's ok.
08:15:07 <puusorsa> use quicksilver and type in x11
08:15:28 <fmardini> puusorsa: thanks man
08:15:31 <fmardini> all works now
08:15:32 <birkenfeld> dons: who detained you?
08:16:11 <dons> oh, it was no big deal
08:17:50 <dons> swiert: hackathon was lots of fun.
08:18:07 <dons> next one will be at chalmers
08:18:37 <swiert> dons: cool. too bad I missed it.
08:18:48 <swiert> Any idea when?
08:19:14 <dons> 6 months time, roughly. so between feb-apr i suppose
08:19:22 <dons> then another one following that at icfp in canada
08:19:38 <dons> we'll have details in the coming weeks about the the chalmers one
08:20:05 <swiert> dons: right. Any plans to get it officially associated with ICFP?
08:20:05 * dons hunts for vegemite in the cupboard. bbl
08:20:10 <dons> yeah, that's on the cards
08:20:13 <matthew_-> icfp 2008 is in canada?
08:20:22 <dons> yep, in BC.
08:20:22 <kosmikus> oh, chalmers sounds nice
08:20:23 <Taejo> victoria, british columbia
08:20:31 <quicksilver> dons: woudl be nice if someone wrote up a hac report
08:20:35 <matthew_-> any skiing there and then?
08:20:40 <quicksilver> dons: not that I'm trying to volunteer you :)
08:21:09 <swiert> If anyone is interested in writing up a Hac report, there's a TMR special on the SoC coming up...
08:21:18 <swiert> I'm sure I could fit in a Hac report.
08:22:55 <kosmikus> swiert: isn't the PDF full already? ;)
08:23:03 <mrd> did they announce the contest winners
08:23:21 <oerjan> mrd: no, they forgot
08:23:46 * matthew_- slaps himself. Whistler is in BC. Of course there's good skiing. September's a bit early though
08:24:20 <mrd> er?
08:24:29 * oerjan is joking
08:24:37 <mrd> they  forgot to update the web site
08:24:50 <oerjan> well, that i may believe
08:24:56 * mrd is not joking
08:25:14 <swiert> kosmikus: Well, I want to be considerate of people who don't have broadband ;)
08:25:36 <oerjan> mrd: there was a reddit post about a blog on the results, though
08:26:14 <kosmikus> mrd: I'm sorry that the webpage is not updated yet. It will be during the next days, though.
08:26:51 <doserj> is any report about it written up?
08:27:10 <kosmikus> doserj: yes, there is. it'll also become available on the webpage really soon.
08:27:15 <doserj> great!
08:28:49 <mrd> oh. i'm reddit-free since march.
08:29:48 <dmwit> Also subreddit free?
08:30:13 <mrd> yes, completely clean
08:34:39 <cpoucet> mrd: how was the transition
08:35:37 <mrd> well, i suppose it was eased by the fact that i had plenty of work to do.
08:36:21 <mrd> i still sometimes think of perhaps checking out the site, when bored, but i always find something else to do
08:36:37 <mrd> like banging my head on a wall
08:36:44 <matthew_-> mrd: or writing some haskell
08:36:57 <matthew_-> oh wait, that's what you meant right?
08:36:58 <matthew_-> ;)
08:37:14 <mrd> no that's more like writing mechanized proofs =)
08:37:31 <matthew_-> well that sounds fun too!
08:38:55 <MyCatSchemes> mrd: that must've been one Hell of a productivity boost.
08:39:31 <mrd> i suppose.  i was taking 2 classes while working full-time.  something had to go.
08:40:59 <mrd> which i'm doing again, for some reason.  but it's not quite as much work this time around.  but it is time for class... bbl
08:44:44 <byorgey> dons: http://wso.williams.edu/~byorgey/catamorfizm.png  =)
08:46:18 <quicksilver> awesome :)
08:46:21 <quicksilver> byorgey++
08:47:44 <dons> sweet.
08:50:52 <byorgey> the wonders of Google image search =)
08:52:49 <DarthJesus> http://mediaplague.com/?cat=serial
08:52:51 <lambdabot> Title: Media Plague :: cat=serial
08:53:01 <DarthJesus> http://mediaplague.com/boards/showthread.php?p=33#post33
08:53:32 <oerjan> Ah, a message from the dark side
08:53:49 <DarthJesus> :D
08:54:37 <DarthJesus> http://mediaplague.com/?cat=serial is everything @keal from 2001 to 8000
08:54:38 <lambdabot> Title: Media Plague :: cat=serial
08:55:55 <dons> wow
08:56:09 <dons> that's true keal,
08:56:09 <dons> I made this from scratch in one night using Quick Basic 7.1 PDS.
08:56:09 <dons> It runs virtually flawless minus shifting overflows.
08:56:10 <dons> Uses just integers and operator codes.
08:56:49 <dmwit> Also, RPN=no parsing necessary, really.
08:56:53 <dmwit> =P
08:57:23 <DarthJesus> http://mediaplague.com/boards/showthread.php?p=33#post33 is my program i made last night :)
08:57:27 <byorgey> up-to OR over 256 tokens! wow!
08:57:40 <byorgey> hehe =)
08:57:44 <DarthJesus> :P
08:58:08 <DarthJesus> over 256 if you dont have endless series of numbers in a row
08:58:23 <DarthJesus> :)
08:59:10 <DarthJesus> comes with source code :)
08:59:27 <halcyon10> RPN for the win, i still have a 20 zear old HP calculator around for that reason :)
08:59:56 <dmwit> Yes, why create a parse tree when you have a human compiler?
09:00:21 <DarthJesus> o.o
09:00:26 <halcyon10> ;)
09:00:34 <dmwit> ;-)
09:00:55 <DarthJesus> this is my 70th or so calculator program btw
09:01:30 <DarthJesus> one of them emualating doing all sorts of math using just your fingers on your hands
09:01:41 <cpoucet> DarthJesus: erm
09:01:48 <cpoucet> how is this relevant to haskell
09:02:21 <DarthJesus> did any of you make haskell
09:03:02 <DarthJesus> which of you invented haskell?
09:03:13 <dons> DarthJesus: cute, but please be less like @keal
09:03:31 <DarthJesus> i am serious who invented haskell?
09:03:36 <shapr> @yow !
09:03:36 <lambdabot> Do you guys know we just passed thru a BLACK HOLE in space?
09:03:50 <oerjan> @go haskell history
09:03:52 <lambdabot> http://www.haskell.org/haskell-history.html
09:03:52 <lambdabot> Title: The History of Haskell
09:04:17 <shapr> Good morning #haskell!
09:04:26 <dons> DarthJesus: so you don't use the nick `keal' anymore?
09:04:29 <dons> heya shapr !
09:04:37 <shapr> Live fast, die old, and leave behind some beautiful code!
09:04:38 * dons throws energetic lambdas at shapr 
09:04:57 * shapr throws not-so-depressed lambdas at dons
09:05:01 * dmwit eats marshmallows in an attempt to match enthusiasm with the best
09:05:09 <shapr> hej augustss, god morgon!
09:06:10 <shapr> It's a beautiful day for some code!
09:06:17 <byorgey> good morning, shapr!
09:06:20 <matthew_-> it's been raining here most of the day.
09:06:33 <dons> dons sings the lovely day song: "its a lovely day today, for whatever you like to code"
09:06:37 <shapr> It's raining here too, that's why I not unicycling :-)
09:06:39 <dylan> matthew_-: that is so you won't be tempted to go outside instead of coding. :)
09:06:40 <dons> "its a lovely day for coding things! its a lovely day!"
09:06:50 * cpoucet sings "It's a lovely day today, for running in a monad"
09:07:00 <dons> heh
09:07:05 <shapr> cpoucet: Is that a big lambda shaped wheel for hamsters?
09:07:07 <matthew_-> it's a lovely day for finding that apostrophe key on your keyboard...
09:07:17 <dons> overrated
09:07:21 <cpoucet> shapr: yes, and you're bound to the wheel
09:07:33 <cpoucet> with sharp >>=s
09:07:41 <shapr> or shapr >>=s
09:07:49 <cpoucet> sharp shapr
09:08:23 <DarthJesus> haskell is for lazy people
09:08:26 * byorgey tries to imagine a "lambda shaped wheel"
09:08:26 <DarthJesus> :|
09:09:01 <shapr> DarthJesus: So you're keal?
09:09:27 <dons> yeah, i think so
09:09:46 <shapr> DarthJesus: Ya know, I thought you were a markov bot for days and someone was showing off their code, that's the only reason I didn't ban you before.
09:09:54 <cpoucet> I'm pretty certain he is
09:09:57 <DarthJesus> i don't see how haskell can produce math that isnt known of yet
09:09:58 <dylan> the forum linked to contains the word "keal"
09:10:07 <shapr> DarthJesus: ooh, proof!
09:10:21 <roconnor> @keal
09:10:21 <lambdabot> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
09:10:30 <dylan> "Timothy Robert Keal's Reverse Polish Notation Calcultator 0.02"
09:10:41 <cpoucet> and the link is to a folder of username DarthJesus
09:11:01 <dylan> Prozactly.
09:11:26 <DarthJesus> just look at the membercount and whois
09:11:33 <dons> its kind of sad when you become a parody of yourself, DarthJesus
09:11:35 <Japsu> @pl \x y -> x + length y
09:11:35 <lambdabot> (. length) . (+)
09:11:40 <Japsu> bah
09:12:03 <DarthJesus> http://mediaplague.com/pk/ my old dada comies series
09:12:04 <lambdabot> Title: pooter comiks
09:12:06 <dons> @pl \(x,y) -> x + length y
09:12:07 <lambdabot> uncurry ((. length) . (+))
09:12:09 --- mode: ChanServ set +o dons
09:12:11 --- mode: dons set +b *!*=Godsmith@unaffiliated/jargon
09:12:11 --- kick: DarthJesus was kicked by dons (off topic)
09:12:13 --- mode: ChanServ set -o dons
09:12:26 <dons> oh, i was hoping for some arrows from the bot
09:12:42 <Japsu> hehe
09:12:44 <cpoucet> dons: arrows don't combine arguments afaik
09:12:59 <oerjan> > liftM2 (+) id length
09:13:00 <byorgey> that would be (id *** length) >>> uncurry (+)
09:13:00 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
09:13:01 * Japsu is still calling for a real @obfuscate to replace @pl
09:13:08 <dons> right.
09:13:17 <oerjan> oh wait
09:13:19 <dylan> :t second length
09:13:21 <lambdabot> forall a d. (d, [a]) -> (d, Int)
09:13:32 <cpoucet> byorgey: right, but the combination happens in uncurr
09:13:48 <therp> ok does anyone have a nice haskell job position available, or am I going to sell my soul to the .NET job offer? Ph.D. doesn't finance itself :/
09:13:52 <cpoucet> @pl \(x,y) -> let a = x in let b = length y in (a,b)
09:13:52 <lambdabot> second length
09:13:57 <cpoucet> @pl \(x,y) -> let a = x in let b = length y in a+b
09:13:57 <lambdabot> uncurry ((. length) . (+))
09:14:18 <quicksilver> therp: occasionally they get posted on haskell-cafe. PhDs do finance themselves in many countries, where are you based?
09:14:25 <therp> quicksilver: austria
09:14:33 * therp subscribes to haskell-caffe
09:14:42 <quicksilver> I suspect your odds of an austria-based post are low :(
09:14:49 <cpoucet> relocation is key
09:14:50 <dons> therp: and check the haskell weekly news archives
09:14:53 <matthew_-> come to the UK!
09:14:55 <dons> all the jobs get posted there
09:15:07 <quicksilver> but as a european you are eligible for all kinds of pan-european PhD grants
09:15:18 <dons> yeah, that'll make the phd a lot easier
09:15:19 <therp> pan-european PhD grants? hmm that sound interesting
09:15:28 <cpoucet> Yes
09:15:29 <cpoucet> Marie Curie
09:15:33 <quicksilver> it's not exactly big money
09:15:35 <cpoucet> It is
09:15:38 <quicksilver> but it's enough to support yourself and enjoy the phd
09:15:45 <cpoucet> Marie Curie fellowships pay more than normal phd fellowships
09:15:55 <matthew_-> the EU spends *a lot* of money on stuff. Some of which includes funding projects which include hiring PhD students
09:15:59 <cpoucet> right
09:16:04 <cpoucet> again, Marie Curie
09:16:05 <cpoucet> :)
09:16:20 <phlpp> http://arcanux.org/lambdacats.html
09:16:20 <lambdabot> Title: Lambdacats
09:16:23 <phlpp> :D
09:16:46 <therp> hey!
09:17:05 <therp> I wanted to do overgeeky haskell related lolcats :)
09:17:27 <therp> cpoucet: thanks for the pointer. will have a look at that
09:17:41 <byorgey> therp: well, get to work! =)
09:17:44 <MyCatSchemes> therp: then for \'s sake, go ahead and do so, then email them in to that blog so they can be added.
09:17:56 <MyCatSchemes> therp: 'cuz if you're going to make them, I wanna see 'em.
09:17:58 <dmwit> ?hoogle constM
09:17:59 <lambdabot> No matches found
09:18:02 <therp> byorgey: http://clemens.endorphin.org/TypeSystem.jpg :)
09:18:13 <therp> but hm my dns seems dead.
09:18:19 <cpoucet> won't load for me
09:18:48 <dmwit> :t \x m -> m >> return x
09:18:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => b -> m a -> m b
09:18:54 <byorgey> me neither
09:19:00 <dmwit> ?hoogle b -> m a -> m b
09:19:01 <lambdabot> Prelude.asTypeOf :: a -> a -> a
09:19:01 <lambdabot> Prelude.const :: a -> b -> a
09:19:01 <lambdabot> Prelude.seq :: a -> b -> b
09:19:20 <quicksilver> matthew_-: If I'm not mistaken many of the specific countries research bodies will fund european students
09:19:27 <matthew_-> quicksilver: yep, that too
09:19:28 <byorgey> @type return . const
09:19:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> m (b -> a)
09:19:41 <quicksilver> E.g. an austrian can get an EPSRC grant
09:19:43 <matthew_-> quicksilver: I'm partially funded by the EC and partially by the DTA
09:19:44 <byorgey> @type const . return
09:19:46 <lambdabot> forall b a (m :: * -> *). (Monad m) => a -> b -> m a
09:19:52 <quicksilver> I think they have to meet *slightly* tougher conditions, but..
09:19:55 <therp> EPSRC...EC..DTA?
09:19:57 <matthew_-> quicksilver: ahh I see.
09:19:59 <byorgey> oh, never mind
09:20:06 <matthew_-> EC = european comission
09:20:16 <quicksilver> therp: EPSRC is a UK-based research council which gives PhD grants to brits
09:20:16 <dmwit> byorgey: It has to have a (>>) in there somewhere or its useless to me. ;-)
09:20:19 <matthew_-> DTA = UK Department of somethingarouther
09:20:22 <quicksilver> therp: but other europeans are also eligible
09:20:23 <halcyon10> has anybody experience installing ghc under os x? the description at http://www.haskell.org/pipermail/glasgow-haskell-users/2007-May/012576.html is way too technical for me :(
09:20:25 <lambdabot> Title: ghc-6.6.1 Mac (Darwin) Binary Dists, http://tinyurl.com/2hya9r
09:20:33 <therp> what would be an appropriate place to post a question for grants? haskell-cafe?
09:20:38 <quicksilver> therp: you could contact a good computer science department and they would be able to explain this
09:20:58 <byorgey> dmwit: right.  for a moment I stupidly confused ignoring the return value and ignoring m itself.
09:21:06 <quicksilver> therp: you could speak to the head of phd applications at, say, imperial college london, or queen mary london
09:21:10 <MyCatSchemes> http://en.wikipedia.org/wiki/Catamorphism <-- looking at the code example there, shouldn't treeDepth = (const 1, \l r-> 1+ max l r) rather than (1,\k r->1 + max l r) ?
09:21:11 <lambdabot> Title: Catamorphism - Wikipedia, the free encyclopedia
09:21:16 <quicksilver> Does microsoft research cambridge ever fund PhD places?
09:21:26 <quicksilver> I don't remember it doing so but it sounds like the kind of thing they might
09:21:33 <matthew_-> therp: good compsci departments are used to dealing with phd students from all over the place and will have $$$
09:21:47 <matthew_-> therp: and if you come to Imperial then you can have lunch with me and ToRA!
09:21:47 * quicksilver nods
09:22:13 <matthew_-> or go to glasgow and have lunch with quicksilver (I think)
09:22:16 <therp> matthew: hm I'm kinda emotionally bond to this place. so relocation isn't really an option for me I'm afraid
09:22:18 <byorgey> MyCatSchemes: yes.
09:22:35 <MyCatSchemes> byorgey: thank you. I thought that looked fishy, just wanted to make sure.
09:23:01 <matthew_-> therp: well that's fair enough too. But if your computer department isn't used to attracting money from the EC or other funding bodies then it may make your life harder
09:24:01 <therp> I should probably spend some time updating my PhD expos√© instead of working on the PhD itself, because this way I will run out of money in about 3-4 months..
09:24:51 <oerjan> :t liftM . const
09:24:54 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => a -> m a1 -> m a
09:25:17 <Arnar> hey guys..
09:25:38 <oerjan> :t (<$)
09:25:40 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
09:26:20 <oerjan> dmwit: ^
09:26:47 <cpoucet> :t (<3)
09:26:49 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
09:27:25 <Arnar> Do you recommend any Haskell books? I've a bsc. in mathematics and currently doing msc. in theoretical comp.sci, I grok functional programming, lazyness, type inference, pattern matching, I mostly need to learn Haskell's "standard" libraries, conventions etc. - and, get a little closer to fitting monads in my head
09:27:34 <dmwit> > 3 <$ [32]
09:27:35 <lambdabot>  [3]
09:27:41 <dons> probably read the wikibook then?
09:27:47 <Arnar> dons: yes..
09:27:47 <quicksilver> Arnar: yes, but it doesn't exist yet
09:27:57 <Arnar> quicksilver: oh, something upcoming?
09:28:00 <dons> yeah. that book is on its way
09:28:01 <quicksilver> Arnar: you sound like a perfect customer for 'haskell for the working programmer'
09:28:03 <dmwit> > 3 <$ [32, 45]
09:28:05 <lambdabot>  [3,3]
09:28:08 <dmwit> Sweet!
09:28:11 <dons> until then, hang out on this channel , read hackage.haskell.org
09:28:16 <quicksilver> Arnar: which is being written by some inhabitants of this channel
09:28:22 <dons> and the other things on the haskell.org wiki
09:28:29 <Arnar> quicksilver: ah, sound about right. I've programmed professionally for some 6-7 years
09:28:41 <Arnar> quicksilver: any way to become a reviewer? :)
09:29:04 <Arnar> dons: yes.. this channel is extremely helpful I must say
09:29:13 <Arnar> hackage.haskell.org I didn't know about though..
09:29:21 <quicksilver> Arnar: you should beg, pray, bribe and make friendly noises to bos and CosmicRay
09:29:49 <quicksilver> I'm not sure if they're interested in more reviewers or not, at this stage
09:30:19 <quicksilver> Arnar: hmm it's called "Real World Haskell"
09:30:22 <quicksilver> Arnar: I have a terrible memory :)
09:30:26 <quicksilver> Arnar: http://www.realworldhaskell.org/blog/
09:30:28 <lambdabot> Title: Real World Haskell
09:30:52 <Arnar> quicksilver: thanks..
09:31:29 <Arnar> that's what you referred to "haskell for the working programmer" before, or is it a different book?
09:31:38 <dons> that's the focus of the new book
09:31:50 <dons> Arnar: oh, you might also like to go through the videos of the haskell workshop
09:31:58 <dons>  to get up to speed on some of the latest things happening in the language
09:32:05 <Arnar> dons: ah, yes.. definitely
09:32:24 <dons> there's a link from the haskell.org frontpage to videos recorded by malcolmw
09:33:29 <Arnar> dons: thanks.. see it
09:33:30 <quicksilver> Arnar: that's what I meant, I had the idea right but that wasn't actualy the title :)
09:34:04 <Arnar> quicksilver: ok, just asked to be sure :)
09:34:07 <hpaste>  dmwit pasted "half-hour RPN calculator" at http://hpaste.org/3177
09:35:20 <ddarius> dmwit: expressions' [] >>= return . head = liftM head (expressions' [])
09:35:31 <dmwit> I didn't want to import Control.Monad.
09:35:38 <ddarius> @index fmap
09:35:38 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:35:41 <ddarius> fmap then
09:35:41 <dmwit> It turns out to be a few characters less typing. =P
09:36:23 <cpoucet> dmwit: boo
09:36:30 <dmwit> Okay, fmap is fine. =)
09:36:46 <ddarius> forever = fix . (>>) +1 insanity
09:36:51 <matthew_-> ddarius: is >>= return . f frowned on?
09:37:09 <cpoucet> dmwit: why do you pass a known value to expression'
09:37:16 <cpoucet> dmwit: why even give expression' a parameter if it'll be an empty list
09:37:22 <oerjan> operator xs = choice [char c >> operate op xs | (c,op) <- [('+',(+)),('-',(-)),('*',(*)),('/',(/))]]
09:37:28 <dmwit> cpoucet: Because it won't be empty in the recursion.
09:37:36 <cpoucet> ah, right, my irc window was hiding gthat
09:38:20 <dmwit> oerjan: Ooo, I like the choice combinator.
09:39:00 <ddarius> matthew-_: It's not that big a deal either way, but usually liftM is clearer and slightly more compact.
09:39:43 <quicksilver> ddarius: fmap is even more compact :)
09:40:05 <quicksilver> matthew_-: infix `fmap` (or liftM) is quite an attractive idiom
09:40:19 <matthew_-> quicksilver: ahh, good thinking batman.
09:40:20 <dons> http://programming.reddit.com/info/2yb35/comments
09:40:21 <lambdabot> Title: Live from the Haskell Workshop: Run-time Code Generation in Haskell :: Video (re ...
09:40:28 <dons> the harpy video, great demo.
09:40:34 <quicksilver> matthew_-: if you previously had a non-monadic expressions, you might write "head (expressions' [])"
09:40:40 * ddarius doesn't like infix fmap or liftM.
09:40:50 <quicksilver> matthew_-: then, when you moved it into a monad, you could write "head `fmap` (expressions' [])"
09:41:03 <quicksilver> matthew_-: which is 'syntactically similar' making it feel like an evolutionary step
09:41:14 <ddarius> quicksilver: So is liftM head (expressions' [])
09:41:18 <matthew_-> damnit, I'd imagined that with a flip
09:41:28 <quicksilver> matthew_-: actually I like it even more when the thing on the left is a constructor
09:41:43 <quicksilver> a <- make_foo ; return (Foo a) --- ugly
09:41:47 <matthew_-> I was thinking of: (expressions' []) `fmap` head
09:41:51 <Taejo> for what f is (foldl f) == (foldr f)? f must be commutative, and f :: a -> a -> a, right?
09:41:54 <quicksilver> Foo `fmap` (make_foo)  -- prettier
09:41:58 <quicksilver> IMO, of course
09:42:00 <oerjan> dmwit: since you are already importing Applicative you can use <$>
09:42:15 <ddarius> Taejo: f needs to be associative and strict in both arguments.
09:42:17 <matthew_-> I discovered the other day that you could happily write [] Int rather than [Int], which I quite liked
09:42:21 <dmwit> :t (<$>)
09:42:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:42:38 <quicksilver> matthew_-: yes, the 'punning' of [] is slightly unsatisfactory
09:42:39 * ddarius has no problem with Foo <$> make_foo
09:42:52 <CosmicRay> Arnar: what does hackage not know about?
09:42:55 <quicksilver> matthew_-: that is [a] as a type and [a] as a value, but with subtly different sense.
09:42:57 <matthew_-> quicksilver: you mean the hardwiring of it to pre+post fix?
09:43:04 <matthew_-> ahh
09:43:12 <quicksilver> matthew_-: well [a] as a value being a list with exactly one member
09:43:22 <quicksilver> but [a] as a type is just a plain unary type constructor
09:43:24 <quicksilver> it's a bit odd :)
09:43:33 <matthew_-> sure, but I was ignoring values, and just thinking of [] as a type function of kind * -> *
09:43:45 <quicksilver> yes. it's the only 'outfix' unary we have
09:43:49 <quicksilver> 'bra-ket-fix'
09:43:50 <ddarius> :k []
09:43:52 <lambdabot> * -> *
09:43:57 <matthew_-> that's the one! ;)
09:44:28 <doserj> quicksilver: there are a couple of others...
09:44:48 <doserj> (,),(,,),(,,,),(,,,,),...
09:45:01 <matthew_-> @type let f :: (,) Bool Int; f = (True, 5) in f
09:45:03 <lambdabot> (,) Bool Int; f = (True, 5) in f :: (Bool, Int)
09:45:09 <oerjan> doserj: not unary
09:45:21 <doserj> ah
09:45:27 <quicksilver> doserj: not unary, but yes :)
09:45:39 <quicksilver> also [,] [,,] [,,,] if we're not restricting to unary
09:45:46 <quicksilver> and you can't section any of them, more's the pity
09:45:48 <dmwit> ?index fix
09:45:48 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
09:45:58 <matthew_-> quicksilver: err, but not type functions
09:46:06 <Japsu> hmm
09:46:24 <ddarius> dmwit: Unfortunately fix is not in the Prelude
09:46:26 <quicksilver> matthew_-: indeed not
09:46:46 <quicksilver> matthew_-: it's the non-quite-parallel between type and value which I think is quite odd
09:46:47 <Japsu> @type uncurry
09:46:49 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:46:53 <quicksilver> matthew_-: not that I actually suggest it should be changed :)
09:46:56 <Japsu> is there an uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d?
09:46:56 <matthew_-> quicksilver: yes indeed.
09:46:59 <quicksilver> matthew_-: just that it can and does sometimes confuse
09:47:15 <quicksilver> :t uncurry3
09:47:17 <lambdabot> Not in scope: `uncurry3'
09:47:21 <quicksilver> Japsu: apparnetly not :)
09:47:26 <hpaste>  dmwit annotated "half-hour RPN calculator" with "with some suggestions from #haskell to make it denser" at http://hpaste.org/3177#a1
09:47:28 <matthew_-> quicksilver: yep. I think a careful comparison with something like Maybe should clear up any confusion :)
09:47:39 <Japsu> quicksilver: ;D
09:47:51 <quicksilver> matthew_-: right. The point being that 'Maybe' is a different word from 'Just'
09:47:55 <matthew_-> indeed
09:47:56 <quicksilver> matthew_-: and a damn good thing that is :)
09:48:10 <oerjan> main = getLine >>= parseTest expression >> main
09:48:22 <dmwit> yes
09:48:47 <dmwit> (But probably not worth an annotation this time. =)
09:49:01 <matthew_-> maybe types should only be written using greek characters and values in roman characters
09:49:16 <quicksilver> matthew_-: yeah, that would actually be quite nice
09:49:24 <matthew_-> then it would be clear, the difference between [] as a type function and [] as a value. ;-)
09:49:44 <quicksilver> well you'd still be overloading the symbols [] themselves
09:49:45 <matthew_-> because [] and [] look very different in greek and roman character sets...
09:49:48 <quicksilver> ;)
09:51:02 <osfameron> heh, zip "+-*/" [(+),(-),(*),(/)]] is cute
09:51:16 <dmwit> =)
09:52:24 <Japsu> cool
09:53:33 <osfameron> though if there was a operatorFromString function, that would be nice too :-)
09:54:05 <quicksilver> doesn't help much in general
09:54:14 <quicksilver> normally you want your own custom AST type in there anyhow
09:54:16 <osfameron> guess not.  And I guess not typable in haskell
09:54:38 <quicksilver> so you have [(Plus,(+)),(Minus,(-))...]
09:54:41 <MyCatSchemes> Hrmn. The IO monad makes the first few pages of CAR Hoare's CSP book really intuitive.
09:54:45 <quicksilver> or write it as a zip if you like
09:55:01 <quicksilver> but I find writing as a list of pairs scales better
09:55:09 <quicksilver> once your assoc list is more than a few lines long
09:55:15 <quicksilver> you want to see which bit lines up with which bit :)
09:55:46 <osfameron> yeah, definitely.  That's why I said "cute" rather than "a sound engineering practise"
09:56:41 <MyCatSchemes> Also, I get the impression that this stuff could *totally* be implemented directly in Haskell as data structure traversals, thanks to laziness. ^^
09:56:43 <quicksilver> however the practice of using lists of pairs and doing something with them to build tables is really nice
09:57:06 <hpaste>  quicksilver pasted "keymap as list of pairs" at http://hpaste.org/3178
09:57:23 <quicksilver> osfameron: consider the above rather short code to set up some keybinds
10:00:13 <osfameron> quicksilver: ok, I can see that's a dispatch table, but I don't know what the Turbulence and modifyPT stuff is
10:00:41 <quicksilver> osfameron: modifyPT just knows how to find the particular little bit of state inside the global state
10:00:51 <quicksilver> osfameron: Turbulence doesn't matter, it's just a constructor
10:01:26 <quicksilver> osfameron: the point is you can write a modification function for a tiny bit of state, and then use something like modifyPT in this case to 'lift' that tiny modification into an IO () action
10:01:42 <quicksilver> osfameron: (which goes and looks up an IORef and finds the right bit and changes it and saves the changes)
10:01:58 <quicksilver> osfameron: and still the main chunk of the keymap looks nice and neat and easy to read :)
10:02:12 <osfameron> quicksilver: I'm missing too much background to understand that (e.g. the IORef stuff)
10:02:39 <osfameron> I've got wedged in haskell studies for about a month... hoping to get more time from November...
10:03:51 <quicksilver> ok, well if you wrote it out in full it would look like: \env -> do state <- readIORef env ; let pt = (selector function here) state; let Turbulence x y z = pt in writeIORef env (state { selector = Turbulence x (y+1) x }) }
10:04:17 <quicksilver> osfameron: it's (a) shorter than that and (b) more resilient to re-arrangements of your data structure
10:05:01 <Taejo> can anyone work out which built-in function is ((. (scanr (.) id . repeat)) . map . flip id)?
10:05:13 <cpoucet> freak
10:05:30 <oerjan> @unpl ((. (scanr (.) id . repeat)) . map . flip id)
10:05:30 <lambdabot> (\ l u -> map (\ h -> h l) (scanr (\ a b c -> a (b c)) (\ d -> d) (repeat u)))
10:05:40 <cpoucet> @type  ((. (scanr (.) id . repeat)) . map . flip id)
10:05:42 <lambdabot> forall c. c -> (c -> c) -> [c]
10:05:46 <osfameron> quicksilver: right.  But presumably even without modifyPT you could presumably extract the bit that gets the IORef and writes it as part of the dispatch?
10:05:48 <cpoucet> iterate
10:05:54 <cpoucet> Taejo: iterate
10:05:59 <quicksilver> osfameron: yeah, that's all modifyPT is
10:06:00 <Taejo> correct
10:06:05 <quicksilver> osfameron: it's just that patter extracted
10:06:05 <cpoucet> typing ftw
10:06:24 <Taejo> cpoucet, indeed. Such is the Haskell way
10:06:28 <quicksilver> osfameron: so this is just a nice example of abstraction really :)
10:06:33 <osfameron> quicksilver: ah, ok.  So instead of doing an inversion of control thingy, you just compose the function that does the whole thing.
10:06:44 <osfameron> quicksilver: sorry, got to head off.  That's interesting though...
10:11:42 <halcyon10> has anyone here installed ghc on an intel mac before?
10:12:13 <dons> halcyon10: its certainly been done
10:13:35 <halcyon10> dons: my problem is: i am no unix expert so the installation guidelines at http://www.haskell.org/pipermail/glasgow-haskell-users/2007-May/012576.html are too complicated for me
10:13:36 <lambdabot> Title: ghc-6.6.1 Mac (Darwin) Binary Dists, http://tinyurl.com/2hya9r
10:14:45 <halcyon10> i hoped that someone here has done it before and could help me with the steps
10:16:03 <yitz> I've done it. Nothing special for the installer. But...
10:16:18 <glguy> those aren't really installation guidelines
10:16:25 <yitz> you also need to make sure you have the two required frameworks in
10:17:07 <halcyon10> ok, i downloaded and extracted the ghc package and the GMP and readline frameworks, what do i have to do now?
10:17:40 <yitz> -- /Library/Frameworks first.
10:18:07 <yitz> Drag the two frameworks into /Library/Frameworks. Then run the installer. That's it.
10:18:09 <halcyon10> -- ?
10:18:42 <yitz> (sorry, my irc client kept eating the / at the beginning of the line, so I put --) :)
10:19:35 <halcyon10> ah :) ok i'm in the frameworkfolder now. The GMP framework is already in there, perhaps from some other installation?
10:19:43 <MyCatSchemes> /say, yitz :)
10:19:54 <yitz> Could be, then that's fine.
10:20:03 <yitz> Hi MyCatSchemes
10:20:20 <yitz> Ah, that's what I'm supposed to write?
10:20:36 <yitz> /say /say
10:20:43 <MyCatSchemes> yitz: that's what most IRC clients do, anyway.
10:20:46 <yitz> Got it! Thanks.
10:21:44 <cpoucet> dons: ozzies can make some disgusting commercials
10:21:46 <MyCatSchemes> HTH, HAND.
10:21:55 <sjanssen> halcyon10: do you happen to have macports installed?
10:22:06 <cpoucet> dons: e.g. the movie in http://www.anti-smoke.com/every-cigarette-is-doing-you-damage-part-1/
10:22:08 <lambdabot> Title: Every Cigarette is Doing you Damage, Part 1Anti-Smoking Blog, http://tinyurl.com/34gdch
10:22:13 <halcyon10> i have darwinports and fink installed
10:22:37 <sjanssen> halcyon10: ghc is in darwinports IIRC, that is probably the easiest route for you
10:23:19 <halcyon10> sjanssen: i already tried that, but portage only seems to have a PowerPC version available :/
10:24:39 <yitz> No, ports is NOT the easiest route. It compiles ghc and a bunch of other stuff. FIne if you want to let your mac churn for a few hours.
10:25:05 <dons> cpoucet: pretty big anti smoking movement in .au
10:25:40 <cpoucet> yeah, I was surprised to find out I was the only smoker
10:25:44 <cpoucet> well except from the guy from valencia
10:25:50 <cpoucet> beppe
10:26:16 <yitz> Oops, forgot, it's not an installer. Or an app (so don't drag it to Applications). Instead:
10:30:21 <yitz> Unzip the archive (double-click works for me..) Then open a Terminal, type "cd (path to where you unzipped)", and follow the instructions in the file called INSTALL.
10:30:30 <geocalc> dons-> can you update pages of your maintened haskell modules to give the darcs repo in hackageDB ? ie ports repo give not a repository
10:31:13 <yitz> Which is: type "make install". That's it. (wish it were an installer or app, though).
10:31:30 <halcyon10> yitz: do you mean the ghc archive or the readline archive?
10:31:52 <yitz> ghc. The 2 frameworks you just drag into /Library/Frameworks.
10:32:28 <halcyon10> yitz: oh, and where is the readline framework located?
10:33:11 <yitz> ghc download page says: http://www.haskell.org/ghc/dist/mac_frameworks/GNUreadline-framework.zip
10:33:13 <lambdabot> http://tinyurl.com/2gxmur
10:34:16 <halcyon10> yitz: yes, i downloaded that but i'm not sure if i have to rum some script first to make the framework or if it is already compiled
10:34:35 <yitz> No, it's all ready to go.
10:35:41 <EvilTerran> mmm, rum!
10:35:55 <geocalc> btw when i compile a module where is the best to install it ?
10:36:01 <halcyon10> yitz: the file with the name GNUreadline (540kb,09.03.07)
10:36:07 <halcyon10> yitz?
10:36:16 <EvilTerran> import Jamaica (rum)
10:36:21 <yitz> Um
10:36:47 <geocalc> canabis*
10:37:21 <yitz> When I downloaded it with Safari, it got automatically unzipped to GNUreadline.framework (could be the "framework" part doesn't appear for you)
10:37:50 <yitz> So yeah. Just drag that to /Library/Frameworks.
10:38:04 <halcyon10> yitz: ah, now i understand how these frameworks are organized, they are folders, i thought they were files, sorry for the confusion
10:38:38 <halcyon10> yitz:ok, i have the frameworks ready
10:38:40 <yitz> Apps are also folders, btw, with (sometimes hidden) extension .app
10:39:15 * geocalc should ask again 
10:39:16 <halcyon10> yitz: yeah, i just didn't know that this applied also to frameworks
10:39:17 <lament> I loved it when I upgraded to the next OS X and all hidden .app extensions became visible.
10:39:32 <yitz> Open a terminal (/Applications/Utilities)
10:39:54 <yitz> lament: I think that is a Finder preference.
10:40:17 <halcyon10> yitz:ok
10:40:33 <yitz> Yep, the Advanced tab.
10:40:45 <lament> yeah, there it is :)
10:41:24 * geocalc asked : " when i compile a module where is the best to install it ? "
10:42:03 <dons> install it in your home directory?
10:42:13 <sjanssen> geocalc: make a Cabal package and install it
10:43:33 <geocalc> √π√πh happy want user local for exemple
10:45:51 <geocalc> dons-> you saw my question about all your maintened modules ?
10:47:14 <geocalc> oops
10:48:00 <oerjan> geocalc: i don't know about dons, but i vaguely recall some irc clients may only highlight one's nick if it is followed by :
10:48:21 <halcyon10> yitz: what do i have to do next?
10:48:57 <yitz> What are you up to?
10:49:37 <yitz> Do you have a terminal window yet?
10:50:00 <halcyon10> yitz: i have both frameworks in my library/frameworks folder and i have the terminal window with path /Applications/Utilities
10:50:17 <dons> geocalc: you were asking about the `ports' package?
10:50:29 <geocalc> how is the speed of compiled haskell versus C ? oerjan didn't know that thanks
10:50:34 <yitz> Type "cd <path-to-where-you-unzipped-ghc>"
10:50:55 <geocalc> yes dons
10:51:07 <halcyon10> ok
10:51:34 <yitz> type "make install"
10:51:39 <geocalc> and elses too dons
10:52:02 <halcyon10> yitz: it says: make: Nothing to be done for `install'.
10:52:49 <yitz> hmm...
10:53:01 <yitz> OK. Try this Type "./configure"
10:53:02 <halcyon10> do i have to configure first?
10:53:42 <geocalc> --help yitz
10:53:46 <halcyon10> ok, that worked, now im trying make install
10:54:47 <Taejo> I'm trying to teach my friend quickcheck, but I'm having trouble with polymorphism: propSorted = forAll arbitrary $ \ xs -> sorted(insertionSort(xs))
10:54:57 <Taejo> insertionSort :: Ord a => [a] -> [a]
10:56:10 <halcyon10> yitz: it worked! now it says: To use, add /usr/local/bin to your PATH.
10:56:14 <mrd> you need concrete types for quickcheck
10:56:24 <Taejo> mrd, how do I get that?
10:56:28 <mrd> :: [Int]
10:56:30 <geocalc> :t arbitrary
10:56:32 <lambdabot> Not in scope: `arbitrary'
10:56:33 <Taejo> where?
10:56:45 <mrd> somewhere it will annotate xs
10:57:08 <Taejo> I tried arbitrary::(Gen [Int]) and \ xs::[Int]
10:57:13 <mrd> the forall arbitrary isn't needed
10:57:32 <Taejo> ok
10:57:39 <mrd> ?check \ xs -> sort (xs :: [Int]) == sort xs
10:57:41 <lambdabot>  OK, passed 500 tests.
10:57:46 <yitz> halcyon10: Great! OK. There are two parts to "adding it to your PATH" - once for now, in the current Terminal window, and another for the future.
10:58:01 <mrd> prop_blah xs = sort (xs :: [Int]) == sort xs
10:58:22 <mrd> the elusive lambdaphant!
10:58:30 <yitz> For now - well, let's see if it's already there. Type "ghci".
10:58:54 <halcyon10> yitz: no, it says command not found
10:59:04 <mrd> ?check \ xs -> (xs :: [Int]) == reverse (reverse xs)
10:59:06 <lambdabot>  OK, passed 500 tests.
10:59:44 <EvilTerran> ?check -> \xs -> reverse (sort xs :: [Int]) == sortBy (flip compare) xs
10:59:44 <lambdabot>  Parse error
10:59:53 <geocalc> PATH=$PATH:/usr/local
10:59:53 <EvilTerran> ?check \xs -> reverse (sort xs :: [Int]) == sortBy (flip compare) xs
10:59:54 <lambdabot>  OK, passed 500 tests.
10:59:54 <yitz> Alright. Type "export PATH=$PATH:/usr/local/bin"
11:00:00 <yitz> Then try it again.
11:00:48 <geocalc> why bin ?
11:01:07 <halcyon10> yitz: wow, it works :)
11:01:36 <yitz> Good, almost done. Now for the future -
11:01:42 <EvilTerran> "To use, add /usr/local/bin to your PATH."
11:02:01 <geocalc> now put it in your bashrc halcyon10
11:02:56 <yitz> In your favorite text editor, open the file /Users/<username>/.bash_profile
11:03:28 <geocalc> bashrc better
11:03:53 <geocalc> in /etc
11:04:31 <halcyon10> yitz: if the file doesnt exist i just create one with that name, right?
11:04:43 <geocalc> now put it in your bashrc halcyon10
11:04:47 <geocalc> in /etc
11:05:08 <kosmikus> geocalc: er, /etc/bashrc is certainly not what you mean?
11:05:35 <geocalc> work for all users
11:05:49 <yitz> geocalc: Hmm, we can do /etc. But PATH is usually done in profile, other variables in bashrc. That's the way it is on most Unixes.
11:05:56 <geocalc> even root
11:06:20 <geocalc> ?
11:06:22 <kosmikus> geocalc: my bash manpage says that /etc/bashrc isn't even read by bash
11:06:43 <geocalc> no _profiles here
11:06:53 <yitz> halcyon10: OK, on geocalc's suggestion we'll look in /etc. So instead, open the file /etc/profile in your text editor. OK?
11:07:30 <pejo> Bash is non-standard under most unices, as a small side note.
11:07:34 <yitz> kosmikus: bashrc is usually called from the profile script, not automatically by the shell.
11:08:01 <halcyon10> yitz:ok, the file exists, now i just copy the "export PATH=$PATH:/usr/local/bin" in there?
11:08:03 <yitz> pejo: used to be csh, ksh, and sh were more popular. Not any more.
11:08:37 <kosmikus> yitz: yes, but I don't see a point in creating a system-wide bashrc if there isn't one already
11:08:41 <kosmikus> yitz: can as well do it in profile
11:08:55 <yitz> OK, that's fine. Put it near the bottom (after anything else that deals with PATH).
11:08:57 <pejo> yitz, systems aren't replaced that quickly, even if it might be 'standard' today.
11:08:59 <halcyon10> yitz:ah, the path is defined in that file, now i see
11:09:12 <yitz> You can just add it in there
11:10:11 <halcyon10> yitz: ok. Hey, Thanks very much! That helped me alot
11:10:19 <yitz> Linux users have been using bash almost exclusively for, oh, fifteen years or so. It's also standard on Darwin - which is where we are right now.
11:10:53 <yitz> halcyon10: final test: close the Terminal window. Open a new one (any folder will do) and type "ghci"
11:11:25 <halcyon10> yitz: yup, it works, very nice :)
11:11:28 <flux-_> I think zsh is a strong contender too.. but of course, bash being the default shell in most of the distributions (all non-minimal?), it must be the most used too
11:11:56 <yitz> kosmikus: yes, we did it in /etc/profile. Thanks.
11:12:56 * geocalc asked : how is the speed of compiled haskell versus C ?
11:13:06 <yitz> flux: right zsh is fun. Hey, what about the Haskell shell? But right now I just want halcyon10 to get up and running as fast and easy as possible. (Boy this is a pain, we really need a mac installer for this.)
11:13:13 <halcyon10> yitz: now i don't have to rely on hugs anymore...
11:13:36 <dons> yitz: ghc compiled haskell programs can be optimised to between twice as fast and twice as slow as C.
11:13:41 <kosmikus> geocalc: that's really difficult to answer, because it depends very much on the exact program you're going to compile.
11:13:51 <yitz> I like ghc - but I'm not trying to encourage anyone to convert or anything :)
11:13:55 <dons> typically, 2 or 4x slower for medium ability programmers
11:14:13 <flux-_> yitz, a real programming language in a shell can be fun, but I wonder if a strongly typed language is the right choice for a string-oriented environment, from usability point of view
11:14:14 <dons> compared to similar level languages: python, ruby, erlang, ghc haskell is 10+ x faster
11:14:37 <dons> comparing haskell to C is not too useful, I think, since the main competitors are the much slower interpreted, dynamic languages
11:14:53 <yitz> Just mentioned it because someone (forget who) has been working on it...
11:15:00 <kosmikus> dons: you're only comparing it to languages without a type system ;)
11:15:00 <dons> of course, there's a haskell hacker faction who live soley to defeat gcc
11:15:16 <dons> kosmikus: well, our serious competitors, who happen not to do types , yeah :)
11:15:21 <dons> much to their cost.
11:15:46 <yitz> dons: we won't mention any names from that hacker faction, of course.
11:16:17 <flux-_> dons, supero?-)
11:16:21 <dons> heh
11:16:30 <Cale> I love taking other people's arguments and replacing terms in them systematically to derive arguments for more extreme positions.
11:16:38 <dons> you can make a reasonable research career trying to outperform C in Haskell
11:16:39 <geocalc> mmh anyway since i discovered haskell i don't want to use else language !
11:16:45 <dons> Cale: :)
11:16:49 <Cale> http://programming.reddit.com/info/2y9jb/comments/c2yce9
11:16:50 <lambdabot> Title: Testing Misconceptions #1: Exploratory Programming (a response to redditors and  ...
11:17:08 <CosmicRay> Cale: then you should run for president
11:17:14 <pejo> dons, people typically use the 'speed' as an argument against whatever language they don't want to switch to though.
11:17:16 <Spark> i don't think haskell is 10x faster than lua
11:17:22 <Spark> maybe with a contrived example
11:17:36 <CosmicRay> pejo: "ram usage" is also effective against Java ;-)
11:17:39 <Spark> the problem is mainly that lua allows the programmer so much power, than program analysis doesn't have a leg to stand on
11:17:44 <yitz> @go language shootout
11:17:46 <dons> i'd be surprised if lua could outperform ghc haskell in any area
11:17:46 <lambdabot> http://shootout.alioth.debian.org/
11:17:46 <lambdabot> Title: The Computer Language Benchmarks Game
11:17:53 <dons> native code wins out every time
11:18:04 * CosmicRay hands dons /usr/bin/as
11:18:09 <Spark> yeah of course
11:18:25 <dons> CosmicRay: :)
11:18:33 <olsner> CosmicRay: all you need is echo -e
11:18:45 <CosmicRay> heh
11:18:57 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=lua
11:19:02 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/24lznt
11:19:04 <dons> lua v ghc, in heavily optimised code
11:19:23 <dons> looks like we're only down on meteor-contest, which is a naive haskell entry.
11:19:43 <dons> between 34 and 1.1x faster than lua
11:19:52 <dons> wha'ts the average, 4x?
11:20:11 <Spark> yeah looks that way
11:20:20 <Spark> i wonder how naive the lua entries are
11:20:33 <Qerub> What's the nicest way to fail hard (with error) when I get a Nothing instead of a Just?
11:20:36 <Spark> you can certainly give it a kick up the arse by avoiding allocating new objects and that kind of thing
11:20:46 <oerjan> Qerub: fromJust
11:20:59 <Qerub> oerjan: And if I want to specify the error message?
11:21:13 <oerjan> fromMaybe (error "whatever")
11:21:14 <integral> fromMaybe (error "woops") ...
11:21:49 <Qerub> Thank you!
11:22:09 <dons> Qerub: failing hard is a bit unhaskelly though :)
11:22:43 <Qerub> dons: I'm just following instructions for this assignment :)
11:23:13 <kosmikus> <religion>you should write *total* functions! partiality is bad!</religion>
11:23:19 <dons> yeah!
11:23:29 <dons> kosmikus: didn't you hear, 2007 is the year of total haskell :)
11:23:40 <Cale> Qerub: Of course, you could also just use case
11:23:50 <dons> the backlash against IO, fail, error begins *now*
11:23:56 <Cale> case foo of Nothing -> error "..."; Just x -> ...x...
11:24:06 <Qerub> Cale: That doesn't qualify as nice in my world, I'm afraid, but thanks.
11:24:14 <kosmikus> dons: I know that I still have a couple of years until I have to switch to Epigram 2 because I'm not interested in writing programs.
11:24:26 <dons> heh
11:24:35 <Cale> Qerub: It's about the same as using fromMaybe
11:24:54 <kosmikus> dons: is Lennart's timeline online?
11:24:59 <dons> i'd love to hack in epigram, and extract total haskell from it directly
11:25:06 <dons> oh, good question.
11:25:09 <EvilTerran> ?src fromJust
11:25:09 <lambdabot> fromJust Nothing  = undefined
11:25:09 <lambdabot> fromJust (Just x) = x
11:25:09 <dons> augustss: ?
11:25:11 <kosmikus> augustss: is your timeline online?
11:25:23 <kosmikus> augustss: the one from the "Future" discussion, I mean ...
11:26:09 <dons> i'd like to see a mirror universe future of haskell, that countered lennart's predictions :)
11:26:14 <kosmikus> dons: why not run Epigram directly?
11:26:21 <kosmikus> dons: not right now, of course.
11:26:29 <dons> beginnging with the dumping of the IO monad, integration of the Epigram type system, ... golden age of total haskell around 2012
11:26:42 <dons> yeah, i've played around with it.
11:26:59 <oerjan> kosmikus: where was this discussion?
11:27:13 <kosmikus> dons: I think the predictions might turn out to be quite accurate. And that doesn't even have to be a bad thing.
11:27:14 <dons> easy integration with haskell would be a killer app for any Epigram-2/Agda/.. potential haskell killer language
11:27:26 <dons> well, implicit IO is scary :)
11:27:36 <dons> but it may well be the golden age we're entering, i suspect.
11:27:40 <kosmikus> dons: if Haskell's ideas flow into lots of other languages, I don't think that Haskell itself necessarily has to survive.
11:27:43 <dons> we've got 10 years to go.
11:27:58 <dons> kosmikus: you've seen the new pure data structures for C#?
11:28:07 <dons> if that's the future, i'm sad ;)
11:28:09 <kosmikus> no
11:28:13 <kosmikus> I haven't
11:28:23 <kosmikus> but as you said, we have 10 years or so ;)
11:28:31 <dons> "http://blogs.msdn.com/ericlippert/archive/2007/10/04/path-finding-using-a-in-c-3-0-part-two.aspx",
11:28:31 <lambdabot> http://blogs.msdn.com/ericlippert/archive/2007/10/04/path-finding-using-a-in-c-3-0-part-two.aspx"
11:28:32 <kosmikus> let's use them
11:28:35 <dons> "Immutable data structures are the way of the future in C#"
11:28:47 <dons> yeah, we've 10 years. and maybe 5 to get parallelism to work (if that)
11:29:17 <dons> we need to find some compiler hackers for the theorem proving/epigram/agda crowd
11:29:33 <dons> to finish the tools, and get them usable by a broader group.
11:30:05 <kosmikus> I'm not a compiler hacker, but I'm definitely going to work more on Epigram/Agda from now on.
11:30:42 <dons> yeah, i'd like to experiment a bit more too
11:31:09 <Heffalump> I'd love to see proofs of stuff darcs does
11:31:14 <pjd> proof-driven development
11:31:14 <kosmikus> you have to give those languages a couple of years extra. with those languages, we're still in a phase where we don't know ourselves what we can do with them and how.
11:31:19 <pjd> now there's a worthy buzzword
11:31:23 <kosmikus> reminds me of Haskell when I started with it
11:31:32 <pjd> Cale++
11:31:44 <halcyon10> what can i do when ghci gives me a stack overflow?
11:32:16 <kosmikus> Heffalump: aren't you trying to already "prove" that stuff by using GADTs?
11:33:16 <geocalc> reworj your code halcyon10
11:33:16 <kosmikus> but I guess darcs would really make a nice project for programming in Coq and using code extraction
11:33:45 <geocalc> s/j/k
11:34:04 <Heffalump> kosmikus: we're trying to prove a very coarse abstraction
11:34:17 <halcyon10> geocalc: the code works fine for a smaller problem, it just gives the stack overflow for a bigger problem size :(
11:34:38 <Heffalump> which in effect only operates locally, since we lose any global information once we quantify out one of the type witnesses we use
11:35:01 <kosmikus> right
11:35:12 <Qerub> halcyon10: Maybe you rewrite it using tail recursion.
11:35:45 <oerjan> halcyon10: maybe you _think_ you are using tail recursion but are really building up thunks
11:36:14 <Qerub> +can
11:36:17 <halcyon10> hm, honestly i don't have a clue what tail recursion is...
11:36:37 <oerjan> are you using foldl without ' ?
11:36:46 <geocalc> hpaste  halcyon10
11:36:58 <halcyon10> oerjan:yes
11:37:08 <oerjan> always a prime suspect
11:37:13 <oerjan> try adding '
11:37:31 <EvilTerran> hehe, prime suspect
11:38:34 <oerjan> and if that doesn't help, hpaste
11:38:40 <byorgey> note you'll need to import Data.List to use foldl'
11:39:12 <Arnar> hey folks.. is the source code to lambdabot available?
11:39:25 <profmakx> sure arnar
11:39:28 <oerjan> @where lambdabot
11:39:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:39:36 <Arnar> cool, thanks
11:40:39 <Arnar> oh, brilliant, I can get it in my ghci :)
11:40:41 <Arnar> didn't know that..
11:41:44 <byorgey> eh, apparently GOA is broken...?
11:41:59 <hpaste>  halcyon10 pasted "stack overflow problem (execute command at the bottom)" at http://hpaste.org/3180
11:41:59 <swiert> malcolmw++
11:42:06 <byorgey> I haven't tried it but that's what I've heard.
11:42:07 <swiert> Haskell Workshop videos!
11:42:31 <oerjan> byorgey: i thought i saw someone install it successfully just the other day
11:42:42 <byorgey> oh, really?  I stand corrected then
11:42:59 <Arnar> I'll let you know if I try it..
11:43:02 <dons> swiert: yeah, malcolm did a great job!
11:43:11 <byorgey> well, Arnar, at the very least be prepared for some difficulty in getting everything built =)
11:43:19 <hpaste>  halcyon10 pasted "stack overflow problem (execute command at the bottom)" at http://hpaste.org/3181
11:43:33 <swiert> dons: definitely!
11:43:42 <dons> crikey `The first location we hosted these at chewed through 100Gb of transfers in 24 hours'
11:43:54 <halcyon10> i'm the code is too large for hpaste it seems
11:44:00 <dons> i'm not sure 'go easy' is going to work :}
11:44:13 <halcyon10> - i'm
11:44:19 <Arnar> when compiling with ghc, is there some runtime embedded in the executable?
11:44:23 <dons> yeah
11:44:28 <dons> the 'rts' package
11:44:34 <dons> $ ghc-pkg list rts
11:44:34 <dons> /home/dons/lib/ghc-6.9.20070916/package.conf: rts-1.0
11:44:38 <halcyon10> i'll post it in 2 parts
11:44:45 <Arnar> dons: ok, thanks
11:45:01 <hpaste>  halcyon10 pasted "stack overflow problem (part1)" at http://hpaste.org/3182
11:45:13 <hpaste>  halcyon10 pasted "stack overflow problem (part2)" at http://hpaste.org/3183
11:45:59 <pejo> dons, it slowed down a lot after that, roughly 50G since they came online again.
11:46:01 <oerjan> halcyon10: strange choice of pred vs. succ for Face...
11:46:17 <oerjan> sure you haven't reversed them?
11:46:20 <dons> pejo: is your uni happy/aware of this? :)
11:46:28 <dons> (or is someone else hosting?)
11:46:31 <hpaste>  halcyon10 pasted "stack overflow problem (part3)" at http://hpaste.org/3184
11:46:55 <DRMacIver> Hm. So if I want fast mutable arrays, which of the bewilderingly large selection in the standard library should I be using?
11:47:43 <DRMacIver> err.
11:47:50 <sjanssen> DRMacIver: there aren't that many selections
11:47:52 <DRMacIver> I suppose I mean the 'nonstandard library' :)
11:47:52 <dons> fast mutable arrays? Data.Array.Unboxed or Foreign.Array
11:47:54 <sjanssen> you want IOUArray
11:47:57 <DRMacIver> ok
11:47:59 <DRMacIver> Thanks.
11:48:01 <halcyon10> oerjan: ok, i'll replace the foldl's now
11:48:24 <pejo> dons, lets not hurt the cause with politics. :-)
11:50:50 <halcyon10> oerjan: ok, i just saw, i don't ave any foldl's in my code, what can i do else? and why strange choice of pred/succ? because Ace comes before King?
11:51:33 <Arnar> dons++ byorgey++
11:51:45 <Arnar> ^^ is this how to give karma points?
11:52:05 <dons> yep :)
11:52:10 <dons> ?karma byorgey
11:52:10 <lambdabot> byorgey has a karma of 3
11:52:13 <oerjan> halcyon10: because pred is usually one smaller, not larger
11:52:18 <Arnar> cool, sorry I didn't know about it before :)
11:52:18 <oerjan> and reverse for succ
11:52:57 <Arnar> EvilTerran++
11:53:09 <halcyon10> oerjan: it bugged me that sort sorted in ascending order, since i needed it in descending order i changed succ and pred
11:53:15 <EvilTerran> what?
11:53:37 <Arnar> EvilTerran: oh, sorry.. should have privmsgd lambdabot on that, just adding karma for your help yesterday
11:53:48 <EvilTerran> oh, right. you're welcome. :)
11:54:41 <oerjan> halcyon10: er... your Ord uses fromEnum, not succ and pred
11:56:33 <halcyon10> oerjan:mmh, you're right, i was a bit confused by the whole ordering i must admit :/
11:56:34 <roconnor> do we neet .torrent files for the Haskell Workshop Videos?
11:57:02 <byorgey> apparently =)
11:57:08 <halcyon10> oerjan: i think it would be good to go through that code again...
11:57:21 <roconnor> byorgey: is that easy to setup?
11:57:30 <byorgey> I have no idea
11:57:41 * roconnor has never run a tracker before
11:58:01 <Qerub> Use The Pirate Bay :)
11:58:16 <byorgey> dons, I liked your xmonad talk from the HW
11:58:19 <roconnor> when I read ``go easy on the server'' as ``get everything while you still can''
11:58:21 <monochrom> I vote for torrenting the haskell workshop videos too.
11:58:27 <oerjan> halcyon10: what happens if you replace sum by foldl' (+) 0 in mean?
11:58:28 <roconnor> s/when //
11:58:32 * byorgey is going to get around to installing xmonad RSN...
11:59:23 <monochrom> Some torrent clients like Azereus double as trackers too.
11:59:42 <halcyon10> oerjan: ghci tells me that foldl' is not in scope
11:59:43 <dons> byorgey: cheers :)
11:59:50 <oerjan> halcyon10: import Data.List
12:00:01 <halcyon10> oerjan: oh, ok
12:01:14 <roconnor> @vote TorrentifyHW2007Videos yes
12:01:14 <lambdabot> voted on "yes"
12:01:41 <Botje> @vote SPJforPrez yes
12:01:42 <lambdabot> No such poll:"SPJforPrez"
12:01:44 <Botje> boo
12:02:09 <oerjan> @help vote
12:02:09 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
12:02:57 <halcyon10> oerjan: it still computing, that's a good sign i suppose :)
12:03:05 <halcyon10> 's
12:03:30 <oerjan> longer than previously?
12:04:02 <halcyon10> oerjan: yes, before it threw the exception in under a minute
12:04:16 <geocalc> lonf computing on poker !
12:04:16 <jonathanv> guys
12:04:26 <jonathanv> i hope you aren't using a naive simple majority vote counting system
12:04:31 <pizza_> how can i grab the nth item in a list?
12:04:36 <geocalc> s/f/g
12:04:40 <swiert> pizza_: xs !! i
12:04:41 <halcyon10> geocalc: lonf?
12:04:53 <geocalc> s/f/g
12:04:58 <jonathanv> the only true way to count votes is ranked pairs
12:05:01 <pizza_> swiert: thanks
12:06:06 <oerjan> > product[48..52]/product[1..5] :: Double
12:06:08 <halcyon10> geocalc: hehe, yes, it computes the equity to win in a headsup pokermatch  so it has to look at at all possibilities to choose the five community cards out of the 52-3-3 cards
12:06:08 <lambdabot>  2598960.0
12:07:03 <sior|away> @src product
12:07:03 <lambdabot> product = foldl (*) 1
12:07:14 <sior|away> ahhhh, it's lazy
12:08:24 <oerjan> it's strange that foldl' (+) 0 should work better than sum on a list of Doubles
12:08:39 <_roconnor> @show-poll TorrentifyHW2007Videos
12:08:39 <lambdabot> Unknown command, try @list
12:08:40 <sioraiocht> @src sum
12:08:40 <lambdabot> sum = foldl (+) 0
12:08:43 <monochrom> Not very strange.
12:08:44 <sioraiocht> oerjan: why?
12:08:56 <sioraiocht> @src foldl'
12:08:56 <lambdabot> foldl' f a []     = a
12:08:56 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:08:56 <oerjan> wouldn't ghc's strictness analyser know about Double?
12:09:02 <_roconnor> @poll-show TorrentifyHW2007Videos
12:09:02 <lambdabot> ["yes"]
12:09:25 <dolio> It shouldn't be a problem on -O2, no?
12:09:29 <_roconnor> jonathanv: only one option available, so majority rule is just as good as anything else
12:09:37 <monochrom> OK, that's strange, but I expect strictness analysers to be strange too. (Doesn't that make it unstrange? :) )
12:10:05 <lament> two stranges don't make an unstrange
12:10:16 <_roconnor> @poll-result TorrentifyHW2007Videos
12:10:16 <lambdabot> Poll results for TorrentifyHW2007Videos (Open): yes=1
12:10:46 <monochrom> (Define "strange" = "unexpected". If you expect it strange, is it still strange? :) )
12:11:12 <monochrom> (Kind of like: the smallest uninteresting natural number is going to be interesting afterall :) )
12:11:33 <oerjan> halcyon10: so if you didn't compile with -O2, it is possible that it would have worked without change if you had
12:11:38 <Heffalump> why not just do it, rather than making a poll?
12:12:02 <oerjan> and if you actually did, we think it is strange that changing sum improved it
12:12:49 <jonathanv> of course, condorcet winners are still chosen by people, which of course is a huge flaw
12:12:50 <Lemmih> Heffalump: We need to expand the bureaucracy to meet the needs of the expanding bureaucracy.
12:13:36 <jonathanv> +more use of the term "of course"
12:14:01 <_roconnor> jonathanv: ?
12:14:15 <_roconnor> should they be selected by robots?
12:14:20 <halcyon10> oerjan: ok, i see. At the moment i'm just using ghci but i'll try compiling, it's too slow at the moment anyway...
12:14:30 <jonathanv> that's a good question
12:15:51 <jonathanv> i lost a lot of faith in people choosing their leaders after we elected certain individuals into our government not once, but twice
12:17:20 <_roconnor> well clearly by the definition of voting, people should select the winner
12:17:31 <_roconnor> so you are asking if voting is a good idea or not
12:17:44 <jonathanv> i guess
12:18:00 <_roconnor> jonathanv: I'm not sure that Bush was a condorcet winner.
12:18:05 <_roconnor> esp. in 2000
12:18:10 <jonathanv> that's true
12:18:15 <jonathanv> nader was in that election
12:20:26 <halcyon10> since i was bored, i just tested, sum [1..520175] still works on my machine, sum [1..520176] throws an exception, so that seems to be the size of the stack
12:24:14 <_roconnor> jonathanv: well, I agree with you.  We want anarchy as much as is reasonable
12:25:08 <halcyon10> Oh, and the computation with foldl' just finished. The chance to win with a pair of aces vs a pair of kings is 81% :)
12:25:33 <byorgey> > takeWhile even . iterate (`div` 2) $ 520176
12:25:34 <lambdabot>  [520176,260088,130044,65022]
12:26:21 <byorgey> > 2^19
12:26:22 <lambdabot>  524288
12:27:02 <geocalc> > sum [1..520175]
12:27:04 <lambdabot>  135291275400
12:27:15 <_roconnor> halcyon10: go aces
12:27:27 <geocalc> > sum [1..520176]
12:27:29 <lambdabot>  135291795576
12:27:44 <oerjan> geocalc: lambdabot uses -O2
12:28:04 <jonathanv> there's also the question of whether bush was actually elected at all
12:28:24 * halcyon10 goes back to the table
12:29:21 <roconnor> is halcyon10 playing poker?
12:29:28 <halcyon10> yep
12:29:49 <jonathanv> texas holdem???
12:29:58 <halcyon10> yes
12:30:03 <jonathanv> \m/
12:30:53 <roconnor> halcyon10: do your opponents enjoy you going to your computer to compute odds?
12:31:05 <halcyon10> i was just interested how good a flop is vs various hands so i thought i'll program something in haskell to get familiar with the language again and do something for my pokerknowledge :)
12:31:53 <sendark> i am trying to compile hat and i get this error: hmake: the compiler 'ghc' is not known.
12:31:56 <sendark> any ideas?
12:32:08 <sendark> i have ghc installed
12:32:10 <halcyon10> roconnor: surely not. But i'll just use it offline i suppose
12:33:03 <sendark> nevermind, i found a package
12:34:59 <roconnor> halcyon10: okay.  I thought you were in the middle of playing, then went to check the odds of winning with a pair of aces, and then went back to the game with that info.
12:36:14 <halcyon10> roconnor: no, i was just kidding. either my code or ghci isn't fast enough for that anyway...
12:36:49 <halcyon10> i think it took 20 minutes for that result...
12:37:07 <Botje> predict which hand you'll have 20 minutes from now!
12:37:32 <sjanssen> halcyon10: you'll likely see huge improvements with ghc -O
12:37:49 <halcyon10> Botje: hehe, yes, i just have to learn th perfect shuffle
12:38:54 <halcyon10> sjanssen: yes, i'll do that, i just have to write a small parser to input the pokerhands on the commandline
12:54:21 <Baughn> Is there a simple, known algorithm for dicing a rectangle into N equal-sized pieces, such that the total perimeter length of the pieces is as small as possible?
12:55:13 <cpoucet> for a square it'd be easy
12:55:19 <cpoucet> not sure about rectangle
12:55:33 <Baughn> It's probably a square. How does it work, then?
12:55:38 <cpoucet> well for a square
12:55:39 <cpoucet> take N
12:55:43 <cpoucet> and find it's prime factors
12:55:54 <cpoucet> as we know, the shortest length is when your parts are as close to a square as possible
12:55:57 <cpoucet> so
12:56:00 <cpoucet> if N = x*y*z*w
12:56:05 <cpoucet> where those are prime factors
12:56:17 <cpoucet> find such a combination such that you get two divisors of N that are as close as possible to one another
12:56:20 <cpoucet> or otherwise said
12:56:30 <cpoucet> start from sqrt(N) and go downwards until you find a divisor and it's co-divisor
12:56:45 <Tela> hi
12:57:00 <Baughn> That was my intuition, but I wasn't entirely sure about the "as we know" bit
12:57:04 <balodja1> Baughn: that sounds like problem of bubbles :)
12:57:19 <Baughn> balodja1: Bubbles?
12:57:32 <cpoucet> it's easy to prove that a square is the shortest perimeter for a given area
12:57:56 <oerjan> cpoucet: a disk
12:57:59 <Baughn> Oh... oh. Yes. That /is/ obvious, since N is constant.
12:58:04 <cpoucet> oerjan: Ii meant for rectangular shapes
12:58:04 <byorgey> hi Tela
12:58:30 <oerjan> well must the boundaries be horizontal/vertical lines?
12:58:44 <halcyon10> i claim that it's irrelevant where you cut the rectangle as long as the cuts are parallel to one side of the rectangle
12:58:56 <cpoucet> given a and b.... a.b=A (fixed... area) hence b = A/a .... perimeter = 2*a+2*b = 2*a + 2*A/a
12:59:08 <cpoucet> then just find the minimum by differentiating with respect to a and settingg equal to 0
12:59:12 <cpoucet> oerjan: "rectangular shape"
12:59:14 <Baughn> oerjan: I'm dicing a finite element model, so.. no, not necessarily horizontal or vertical, but it'll be quite jagged if not
12:59:25 <cpoucet> oh the cuts
13:00:09 <balodja> Baughn: pieces must be rectangular?
13:00:47 <oerjan> for example, if you divide a square in two, it seems to me a diagonal cut is best
13:00:48 <Baughn> balodja: The length of a diagonal piece would be the horizontal distance *plus* the vertical distance it stretches
13:01:06 <Baughn> balodja: No square roots need apply
13:01:15 <cpoucet> so hamming-distance
13:01:28 <oerjan> Baughn: oh, so not ordinary perimeter length?
13:01:37 <halcyon10> because if you cut a square in half and shift a vertical cut on the horizontal axis for example, then one of the new rectangles gains in perimeter what the other loses, so it doesn't affect the total perimeter where you start the cut as long as you don't cut diagonal
13:01:41 <Baughn> cpoucet: Wiki says yes
13:02:03 <Baughn> oerjan: I prefer to stick with horizontal/vertical for another reason: It makes my code far simpler
13:02:18 <byorgey> halcyon10: yes, but it still matters how many vertical/horizontal cuts you make
13:02:19 <cpoucet> it's gonna suck if you have a prime number of elements
13:02:22 <Baughn> oerjan: And the inner loop here is hand-tuned assembly
13:02:40 <oerjan> Baughn: it is easy to simplify code by solving a different problem :)
13:02:40 <cpoucet> halcyon10: he did say 'equal sized pieces'
13:02:43 <byorgey> halcyon10: e.g. making one horiz. + one vert. is better than making three vertical cuts
13:02:49 <cpoucet> halcyon10: which makes N=prime a pain
13:02:57 <halcyon10> ok, i see
13:03:08 <Baughn> N represents computers. It would take a *lot* of communication to make up one node, but if anyone suggests a prime number of nodes I'll accidentally break one. ;)
13:03:12 <halcyon10> have you looked into delaunay triangulation?
13:03:35 <cpoucet> Baughn: with a hammer?
13:03:51 <Baughn> cpoucet: tail -n -1 should do
13:04:05 <Tela> Anyone want to help with some monad juggling?
13:04:11 <hpaste>  Tela pasted "Making monads look like russian dolls..." at http://hpaste.org/3185
13:04:32 <oerjan> another question: must the cuts be at integer coordinates?
13:04:39 <cpoucet> Tela: easy to fix ;)
13:05:00 <Baughn> cpoucet, halcyon10: Computation time absolutely dwarfs communication time, and the latter can be done simultaneously. Getting this separation perfect isn't that high a priority, I just need to avoid complete horror.
13:05:19 <Baughn> Getting the sizes /equal/ /is/ a priority, however
13:05:23 <hpaste>  (anonymous) annotated "Making monads look like russian dolls..." with "(no title)" at http://hpaste.org/3185#a1
13:05:30 <cpoucet> Tela: look at that
13:05:31 <Baughn> That said.. I'll go with counting down from the square root. That should suffice.
13:05:43 <cpoucet> Tela: the problem was that 'Maybe' is the outer type, and that's not a MonadState
13:05:53 <cpoucet> but, maybe -is- a monad
13:06:11 <cpoucet> Baughn: well I have no idea what this is for, you just asked about splitting a rectangle..
13:06:26 <byorgey> but the map holds FAction () values.
13:06:29 <Baughn> cpoucet: Yes, and it's diced very nicely now, thank you. :)
13:06:36 <jonathanv> man, there is always some serious computer science going down in this channel
13:06:41 <Tela> cpoucet Hm, but that's not the goal. That dict has FAction () values, and lookupVal will maybe return one, if it is stored.
13:06:51 <sieni> win 28
13:06:54 <sieni> eiku
13:07:01 <cpoucet> Tela: the issue is that you were workingg in monad "Maybe"
13:07:03 * sieni hands himself a /
13:07:07 <cpoucet> Tela: monad maybe is not a monadstate
13:07:09 <byorgey> I think you want a type of FVal -> FAction (Maybe (FAction ()))
13:07:13 <cpoucet> Tela: and you're using 'get'
13:07:27 <cpoucet> right, that's just a specification of 'a'
13:07:32 <balodja> russian dolls :) matreshka :) That's closer to monad transformers maybe.
13:07:52 <byorgey> but just saying 'a' isn't correct if it only returns Faction () values.
13:08:08 <cpoucet> true
13:08:11 <cpoucet> but it's more correct :)
13:09:15 <Tela> Hmm. Ok, that's something I didn't think of that's more toward what I want it to do. It's still failing to load, but let me play with it for a bit. Thanks :)
13:09:18 <cpoucet> Tela: so either
13:09:22 <cpoucet> FAction (Faction ())
13:09:23 <cpoucet> or
13:09:28 <cpoucet> FAction (Maybe (Faction())
13:09:31 <Taejo> Stats I test: *do not want*
13:09:32 <cpoucet> ni the second case you need a return
13:09:58 <Tela> I put the return in and it's having problems matching the monotype
13:10:24 <hpaste>  Tela annotated "Making monads look like russian dolls..." with "(no title)" at http://hpaste.org/3185#a2
13:10:56 <Tela> Oh, wait. Is that because Map.lookup doesn't necessarily return in Maybe?
13:11:11 <cpoucet> no
13:11:14 <cpoucet> it returns in any monad
13:11:15 <oerjan> :t Data.Map.lookup
13:11:17 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
13:11:51 <Tela> Yeah. But shouldn't the type of lookupVal unify m and Maybe?
13:12:00 <cpoucet> I would think so
13:12:37 <Tela> Hm. Then I can't think where the error would be coming from :S
13:12:39 <cpoucet> though I have to admit
13:12:44 <cpoucet> I would newtype Faction's
13:12:49 <cpoucet> your definition is odd
13:13:08 <cpoucet> newtype factin and make it an instance of monad
13:13:15 <cpoucet> nobody makes monad stacks like that
13:13:19 <Tela> Heh. I avoid newtype because I'm not sure I fully understand it and I've gotten really weird errors off it
13:13:46 <Tela> Could you show me what you mean by that?
13:14:38 <Tela> erk, although, afk 10 minutes. Sorry
13:15:45 <oerjan> type FAction a = (MonadState FState m, MonadIO m) => m a is not a legal declaration, i think
13:15:53 <ibid> newtype is almost like a special case of data
13:16:15 <oerjan> although why doesn't ghc complain...
13:16:27 <hpaste>  vincenz annotated "Making monads look like russian dolls..." with "fix" at http://hpaste.org/3185#a3
13:16:33 <cpoucet> Tela: chheck that out
13:16:37 <ibid> and i can't offhand figure any reason why the differences would elicit weird errors
13:17:15 <cpoucet> Tela: truth be told, storing actions of a certain monad within a state of that monad usually gives problems
13:18:30 <hpaste>  (anonymous) annotated "Making monads look like russian dolls..." with "(no title)" at http://hpaste.org/3185#a4
13:18:33 <cpoucet> like so
13:18:57 <cpoucet> but anyways, I've always encountered problems with storing monadic actions of a state monad within that same monad
13:19:20 <oerjan> cpoucet: you need to pass through a data or newtype definition
13:19:40 <cpoucet> oerjan: a second one?
13:19:52 <oerjan> i.e. type MyMonad a = State (MyMonad ()) a won't work
13:19:59 <cpoucet> I did newtype
13:20:01 <cpoucet> check the latest post
13:20:12 <cpoucet> http://hpaste.org/3185#a4
13:20:19 <cpoucet> that's why I said it was so odd
13:21:28 <Tela> There's also a data declaration of FState, unless that's not good enough?
13:21:42 <Tela> I had FState as a type synonym at first, but GHC refused due to cyclic types
13:21:59 <Tela> Which is obvious... :)
13:23:27 <Tela> I feel like this is necessary though. I'm writing an interpreter for False, and I need to be able to define operators outside of the language itself. That makes me think that I need that map to have values of FAction ()
13:25:40 <omnId> Tela: I think FDict should be a Map FName FVal, where FVal also contains FActionTs.
13:25:52 <sioraiocht> is the constant e programming into haskell anywhere?
13:26:03 <oerjan> > exp 1
13:26:07 <lambdabot>  2.718281828459045
13:26:08 <sioraiocht> riiiight
13:26:23 <Tela> How is that going to improve it? I'm still going to have a loop back to FAction, no?
13:26:40 <dataangel> If I'm interested in learning about type theory, where should I start? Preferably free resources :)
13:26:58 <omnId> Tela: names should also be able to hold Integers.
13:27:54 <Tela> I was just going to have such a name hold the action to push some integer on to the stack. FInt is translated into that anyway
13:28:05 <omnId> oh, okay
13:29:25 * oerjan cannot see anything wrong with FAction (Maybe (FAction ())), if that's what you want
13:29:51 <cpoucet> oerjan: FACtion is a transformer
13:29:56 <cpoucet> oerjan: meaning that you need an 'm'
13:30:05 <cpoucet> so what m do you place there?
13:30:12 <cpoucet> it's not fully free as it depends on the m that called it
13:30:21 <cpoucet> unless he makes FAction a specific monad
13:30:21 <cpoucet> like
13:30:29 <cpoucet> StateT FSTate IO a
13:31:25 <Tela> I could do that. Hah
13:31:54 <Tela> It's always amusing when the simpler answer works best...
13:32:37 <omnId> Tela: you can generalize once everything's working :)
13:34:05 <Tela> I feel like I'm really close. I didn't realize how quickly you could bring a language like this up with a monad like that. I still have to write a parser, but I need to learn more about Parsec anyway.
13:34:38 <omnId> Parsec makes it gravy :D
13:35:07 <Tela> I went through that Scheme in 48 hours tutorial and have been drooling to play with Parsec again
13:35:50 <monochrom> I have always thought of writing a Parsec parser for bibtex stuff.
13:36:32 <monochrom> Alternatively, Scheme in 48 hours doesn't do full Scheme. For example it omits the macro language IIRC. You can do that.
13:36:50 <Tela> (Coincidentally, the whole reason I ran into this specific problem ‚Äî though I imagine it was only a matter of time ‚Äî was because I saw how easy it'd be to add generic name assignment to False)
13:37:51 <Tela> monochrom, I started on that, but then stopped when I realized I'd rather do the CL Macros instead.
13:39:07 * dylan likes schemes that have define-macro
13:41:28 * cpoucet likes haskell with side-effects :P
14:01:22 <jerbear> i've been looking at fp languages recently, but i don't know anyone who uses any of them... can someone explain to me what the advantage is over procedural languages?
14:01:37 <mrd> ?users
14:01:37 <lambdabot> Maximum users seen in #haskell: 420, currently: 382 (91.0%), active: 13 (3.4%)
14:01:44 <mrd> you now know 382 people who use them
14:02:14 <mrd> 381
14:02:16 <omnId> @google haskell io for imperative programmers
14:02:18 <lambdabot> http://blogs.nubgames.com/code/?p=22
14:02:37 <mrd> advantages? concise programs, easier to reason about
14:02:39 <balodja> mrd: 380
14:02:39 <sioraiocht> jerbear: clarity, easier to do a lot of things
14:02:40 <Lemmih> 380. I don't really use Haskell. I just hang out here for the chicks.
14:02:41 <omnId> ^ that shows some nice advantages
14:02:52 <balodja> minus lambdabot
14:02:57 <mrd> ah good point
14:02:57 <jerbear> sorry, i wasn't trying to say nobody uses it, just that i don't know anyone personally (and consequently, have nobody to bounce questions off of)
14:02:58 <balodja> 379 now
14:03:06 <sioraiocht> jerbear: easier to model many different ways to compute things, depending on your application
14:03:14 <oerjan> minus cmeme, clog
14:03:36 <oerjan> and ChanServ
14:03:53 <mrd> actually, +1 for lambdabot. she's definitely the biggest FP user I know.
14:04:02 <monochrom> hahaha
14:05:21 <mrd> > map chr [73,32,108,105,118,101,32,70,80]
14:05:23 <lambdabot>  "I live FP"
14:05:42 <omnId> > "yes!" >>= replicate 5
14:05:43 <lambdabot>  "yyyyyeeeeesssss!!!!!"
14:06:11 <Arnar> hey there..
14:06:46 <lambdabot> Stop abusing me
14:07:47 <lambdabot> > "no!" >>= replicate 5
14:07:49 <Arnar> I've installed GOA, but I don't know how to start ghci with it..
14:10:02 <Arnar> ?type (^)
14:10:04 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:10:13 <omnId> doesn't GOA's readme say to copy some commands to your .ghci that shorcut :! lambdabot blah?
14:10:34 <balodja> Some day lambdabot will pass Turing's test...
14:10:56 * mrd will never pass a Turing test
14:10:56 <omnId> @vixen are you a bot?
14:10:56 <lambdabot> no, why? do i seem "botty"?
14:11:02 <Arnar> oh, omnId you're right, sorry..
14:11:21 <mrd> @vixen are you a pot?
14:11:21 <lambdabot> i truely am
14:11:46 <omnId> @spell truely
14:11:49 <mrd> @vixen can't spell
14:11:49 <lambdabot> Does your mommie know you're here, little naughty boy?
14:12:59 <omnId> @help spell
14:12:59 <lambdabot> spell <word>. Show spelling of word
14:13:03 <omnId> @spell borked
14:14:58 <Arnar> byorgey, dons: tried GOA, not working like I think it should :/
14:16:18 <omnId> as far as I understand, GOA is just lambdabot + ghci commands that shell out to lambdabot.
14:17:26 <byorgey> Arnar: sorry, I don't actually know much about it
14:19:02 <glguy> halcyon10: you might consider the annotate functionality on hpaste when you have a lot of related pastes
14:21:01 <halcyon10> glguy: thanks for the tip
14:21:47 <sorear> If GOA works at all, I'm suprised.  Lambdabot is a horrific mess. :(
14:22:07 <Arnar> byorgey: don't worry, sorry for the ping
14:22:14 <byorgey> no problem
14:22:38 <Arnar> mostly I'm just reporting.. not looking for help :)
14:52:59 <omnId> @. elite brain
14:52:59 <lambdabot> iT iz0rz HEr3 +h47 /\/\Y (|-|e4p WORKphORCE 0F TRaINED iGUANa$ \/\/ill \/\/0rk ni9h+ anD Day TO /\/\Axe oUR S|-|OES tO mY 3X4(TiN9 sp3cIFIca+IOns!
14:54:02 <fasta> Is there a substring function for normal Strings?
14:54:42 <omnId> take len . drop index
14:55:25 <fasta> omnId: ?
14:55:36 <omnId> > (take 3 . drop 2) "hello, there"
14:55:37 <lambdabot>  "llo"
14:57:17 * SimonRC goes to bed
15:02:01 <hpaste>  dibblego pasted "What's going on with the inferencing here?" at http://hpaste.org/3186
15:02:38 <Qerub> @pl (\ ((a,b),c) -> If a b c)
15:02:38 <lambdabot> uncurry (uncurry If)
15:03:00 <omnId> dibblego: a name = val definition involves the monomorphism restriction
15:03:19 <dibblego> omnId, thought so, thanks
15:09:55 <vwx> hello! how do i convert say a Int32 to little-endian format?
15:13:55 <dons> using Data.Bits or Data.Binary
15:14:17 <dcoutts_> dons: have a good trip home btw?
15:14:33 <dibblego> ?where hackage
15:14:33 <lambdabot> http://hackage.haskell.org/trac/hackage
15:14:37 <dons> using Data.Binary, you'd say, putWord32le (7 :: Int32)
15:14:40 <dons> something like that
15:14:47 <dons> dcoutts_: yeah, it was ok. nice and short, anyway
15:14:51 <dcoutts_> dibblego: hmm, that's not a good link
15:14:59 <dcoutts_> @where+ hackage http://hackage.haskell.org/
15:14:59 <lambdabot> Done.
15:15:00 <dons> we're moving into our new apartment today, which is exciting
15:15:02 <vwx> dons: i don't want to use Data.Binary because i want to stick with the stuff that already comes with ghc
15:15:05 <dibblego> dcoutts_, indeed, I just want FilePath
15:15:09 <dibblego> dcoutts_, thanks
15:15:15 <dons> ok. then Data.Bits, and you'll need to reimplement putWord32le
15:15:44 <dons> using shiftR
15:16:01 <vwx> dons: but how can i implement convert (Int32) into (Word8, Word8, Word8, Word8) ordered in host endianness?
15:16:12 <dons> using shifting and masking
15:16:19 <dons> would you know how to do it in C?
15:16:24 <dons> (because the operators are basically the same)
15:16:43 <vwx> dons: but how can i tell if the system is big or little endian?
15:16:48 <dons> > fromIntegral (7 `shiftR` 24) :: Word8
15:16:56 <lambdabot>  0
15:17:07 <dcoutts_> vwx: same way you'd do that in C
15:17:10 <dibblego> are there instructions for using packages of hackage? or do you just download source, compile and install?
15:17:20 <vwx> dcoutts:_: in C the only way to do it is with a cast
15:17:20 <dibblego> s/of/off
15:17:39 <dons> dibblego: you can download, compile and install, or try the experimental 'cabal install' command (but you probably don't want to experiemnt :)
15:17:48 <dibblego> dons, not now, thanks :)
15:17:48 <dons> vwx: fromIntegral performs the required cast
15:18:23 <dons> ?docs Data.Bits
15:18:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
15:18:28 <vwx> dons: i need to call a c function that wants an array of c ints. i want to make this array in haskell using ByteString
15:18:29 <fasta> Can I use $HOME in :set -i?
15:18:42 <ddarius> fasta: Try it.
15:18:56 <dcoutts_> vwx: wouldn't you just write a 32bit int and then read in 4 bytes and check that way if the 32bit write was big or little endian?
15:19:05 <fasta> ddarius: I don't know how to verify unless I load a file in that directory.
15:19:21 <vwx> dcoutts_: write to where?
15:19:24 <fasta> ddarius: i.e. is there a kind of query command?
15:20:24 <dcoutts_> vwx: you might want to use a Storable array of Int32
15:20:31 <dcoutts_> vwx: rather than a bytestring
15:20:47 <vwx> dcoutts_: hm....
15:20:51 <dcoutts_> an Array of Int32 is what you really want, not an array of Word8, which is what a ByteString is
15:21:00 <dcoutts_> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Storable.html
15:21:02 <lambdabot> http://tinyurl.com/ys3foq
15:21:25 <dcoutts_> vwx: in fact you want a StorableArray Int CInt
15:21:38 <dcoutts_> that is a 1 dimensional array of C ints
15:21:39 <hpaste>  vwx pasted "float" at http://hpaste.org/3187
15:22:04 <vwx> hm.... also, i need to work with floats. i managed to write that function, but writing the inverse is tricky
15:22:24 <dcoutts_> vwx: again, use an array of CFloat
15:22:40 <dcoutts_> and if necessary do the byteswap on the array as a whole first
15:22:58 <dcoutts_> to convert little/big endian if you're getting data that's not native endian
15:23:21 <vwx> for now i am only sending data
15:24:01 * dcoutts_ departs
15:24:42 <dons> vwx: hmm, Data.Binary would probably make this easdier, vwx, since it is designed for this job
15:24:53 <dons> is there a convincing reason you can't use it?
15:24:59 <dons> since you'll be duplicating the functionality
15:25:03 <dcoutts_> dons: btw, if you can validate in the ghc-6.8 branch perhaps you can help us push some of those cabal patches into the cabal-1.2 branch
15:25:16 <vwx> dons: i'll look into it, but Storable and StorableArray look like they will work
15:25:23 <dons> yeah
15:25:28 <dons> dcoutts_: ah ok.
15:25:37 <dons> i'll see if i can set up my tree for that
15:25:45 <dcoutts_> dons: aye, the conversion via binary looks like it was quite unnecessary anyway
15:26:08 <dcoutts_> dons: just a case of people having heard of ByteString but not the other nice things like "array"s :-)
15:26:51 <dcoutts_> and generic storable / foreign arrays at that
15:27:02 <dcoutts_> they clearly don't get enough press coverage :-)
15:27:11 <vwx> i've actually used StorableArray before
15:27:25 <vwx> but i didn't think of using it now
15:27:59 <vwx> since ByteStrings are pure, and i figured that if it's doable in pure ByteStrings then it's preferable then mutable StorableArray
15:28:00 <dcoutts_> vwx: it's not immediately obvious from the docs that you can do IO using them
15:28:22 <dcoutts_> vwx: hmm, that's true
15:28:38 <dcoutts_> vwx: but if you're building ByteStrings bit by bit, you'd really want to use Data.Binary
15:28:58 <dcoutts_> otherwise it's quite inefficient unless you can write your producer as an unfoldr or something
15:29:30 <dcoutts_> dons: aye, so that'd be quite helpful, you know the patches we need to get cabal-install working
15:30:08 <dcoutts_> dons: and there are some others we should move over too, basically all the patches in cabal head that are not related to dynamic libraries
15:30:24 <vwx> in case you guys are curious i'm working on a quake 2 model viewer:
15:30:24 <vwx> http://img402.imageshack.us/img402/7205/modelviewerop9.png
15:30:31 <dcoutts_> vwx: oh, cool
15:30:44 <dcoutts_> using GL I guess
15:31:03 <dons> i'm not sure cabal-install will be ready to go though
15:31:08 <vwx> yes. i want to make it faster by using opengl vertex buffers. these require me to make a big array of float to upload to the graphics card
15:31:09 <dons> we need a firm deadline from Igloo et al
15:31:42 <dcoutts_> dons: no, but like we said, we need the patches to cabal-1.2 so that we'll be able to build cabal-install easily with the version of cabal that ghc-6.8 comes with
15:31:48 <dons> yep
15:31:57 <sioraiocht> is there any good stuff to get started on ghc hacking?
15:32:11 <dcoutts_> sioraiocht: the ghc developers wiki
15:32:11 <dons> the ghc hackers videos from the hackathon?
15:32:14 * sioraiocht might be doing so for his dissertation.
15:32:20 <dons> cool!
15:32:24 <sioraiocht> dcoutts_: thanks
15:32:26 <dcoutts_> there's the ghc commentary on the ghc wiki
15:32:29 <dons> we need more ghc hackers with 4 years of their lives to donate :)
15:32:33 <sioraiocht> ha
15:32:38 <dcoutts_> yes indeed
15:32:41 <dons> and if you're looking for jobs, dcoutts_ and I have a list of things we want to go faster
15:32:48 <dcoutts_> right, I'm really off this time
15:32:54 <dcoutts_> ghc-6.8 is building again
15:32:57 <dons> cool
15:33:02 <dcoutts_> so time to leave it 'til morning...
15:33:16 <dcoutts_> g'night folks
15:33:34 <dons> night duncan.
15:33:52 <vwx> @seen Lemmih
15:33:53 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 1h 31m 12s ago.
15:34:04 <Lemmih> Yo.
15:34:21 <sioraiocht> dons: how far are you into your PhD?
15:34:25 <vwx> Lemmih: hi. did you get that patch i emailed you for hsSDL?
15:35:49 <Lemmih> vwx: Applied and pushed. Thanks.
15:36:03 <vwx> cool
15:36:34 <vwx> Lemmih: btw  i pasted a few lines up a screenshot of a windows hsSDL application
15:38:10 <Lemmih> Neat.
15:39:21 <fasta> Oh, great...(Text.Regex.Posix.String died: (ReturnCode 11,"Invalid range end"))
15:39:28 <shapr> @where hsSDL
15:39:29 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
15:39:51 <fasta> I finally thought I had it working, a library function ***** up.
15:40:00 <TSC> With a function like this:   f Nothing = Just 1 ; f (Just x) = Just (x+1)    , what's the easiest way to strictify the addition?
15:40:21 <ddarius> Just $! x+1
15:40:33 <TSC> Ah, thanks
15:40:41 <shapr> vwx: Is the source for that viewer online?
15:41:01 <shapr> vwx: If so, it might be used to fix Frag on 64bit systems.
15:41:38 <vwx> shapr: it's just a little demo, nothing close to the scope of Frag :) but i did write a custom PCX image loader for it =]
15:41:50 <vwx> shapr: i'll put the source online soon, after i fix it up
15:42:06 <shapr> Frag crashes on 64 bit systems when loading BSPs, it has some 32bitness hidden somewhere.
15:42:08 <vwx> vwx: also, it loads quake 2 models. Frag is based on quake 3 assets i believe
15:42:13 <shapr> Ah
15:42:22 <fasta> Is there any other functionality besides regex that checks whether a certain string is a substring of another one?
15:42:25 <vwx> the quake 3 model format is a lot more complicated
15:42:46 <shapr> Even so, your model viewer might be used to make something that that doesn't do by-hand memory layout.
15:42:47 <sjanssen> fasta: newer version of Data.List have isInfixOf
15:42:55 <ddarius> @src isInfixOf
15:42:55 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
15:43:30 <fasta> sjanssen: how helpful, thank you
15:43:45 <shapr> @users
15:43:45 <lambdabot> Maximum users seen in #haskell: 420, currently: 356 (84.8%), active: 12 (3.4%)
15:43:55 <vwx> shapr: i have a few ideas in mind
15:44:04 <fasta> The efficiency of that prodecure is a joke, but I don't need anything fancy now.
15:45:01 <fasta> Wouldn't it be better to call something like that isInfixOfUltraSlowForLargeStuff?
15:45:09 <dons> sioraiocht: finishing up
15:45:32 <sioraiocht> dons: ah, was wondering given you're writing a book and such
15:47:13 <sioraiocht> which, btw, I can't wait to come out ;)
15:48:04 <fasta> Hmm, is there any way to write ghci commands and reload them all?
15:48:12 <fasta> Now, I need to exit Emacs and then try again.
15:49:34 <fasta> Cool, I automated stepping :)
15:49:57 <fasta> I wonder how ultra slow it will be...
15:50:33 <fasta> It would be better if I could someone tell ghci not to print anything after a step command.
15:51:14 <fasta> I guess that's what the GHC API is for?
15:55:13 <LoganCapaldo> Cale: re: PDD how serious were you?
15:55:29 <LoganCapaldo> @seen Cale
15:55:29 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 4h 30m 54s ago.
15:55:54 <thoughtpolice> when I was messing with the API for a lib I've yet to release (mainly out of needing to, well, test it better) you can't capture the output of runStmt in any form
15:56:03 <thoughtpolice> well, I found that out, at least.
15:56:32 <thoughtpolice> i was going to use it for an eval mechanism but instead I just fell back on writing eval in terms of a temp file and loading it.
15:56:53 <fasta> thoughtpolice: I use emacsclient for that now.
15:57:04 <thoughtpolice> but I don't know what's changed in the new API with the debugger release and all.
15:57:36 <fasta> But it seems I need a THz machine for it to complete.
15:57:45 <thoughtpolice> i guess i'll have to investigate it when 6.8 hits. it's very soon, is it not?
15:58:10 <fasta> thoughtpolice: you can better investigate with the rc
15:58:19 <fasta> thoughtpolice: then things can still be changed.
15:58:50 <fasta> Hmm, I cannot even switch buffers anymore.
15:59:10 <thoughtpolice> fasta: i'll download a 6.8 snapshot onto openbsd when I have the time.
15:59:34 <thoughtpolice> on a completely different note, my first alex/happy experiance went pretty well.
16:00:05 <thoughtpolice> although I feel the AST is a bit ugly. maybe by the end of the day I can plug harpy into it...
16:00:07 <fasta> thoughtpolice: my define a ghci macro experience too, too bad it's too slow.
16:00:53 <fasta> It seems Emacs cannot cope with it.
16:01:04 <fasta> That's using more than 8 times as much CPU
16:01:56 <SamB_XP> what AST is a bit ugly?
16:02:00 <dibblego> the link to the Applicative Programming paper in Control.Applicative gives a 404; anyone know where it is available?
16:02:48 <SamB_XP> yay. I am no longer faceless!
16:04:09 <thoughtpolice> SamB_XP: the one my program generates for basic arithmetic expressions.
16:04:56 <SamB_XP> dibblego: google still gets that
16:04:57 <byorgey> dibblego: try http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf
16:05:06 <dibblego> cheers!
16:05:13 <byorgey> I found it with Google scholar search
16:05:14 <thoughtpolice> ex: the expression "20 + (30 / 2)" gives a tree of Op (Add (IntT 20) (Brack (Op (Div (IntT 30) (IntT 2)))))
16:05:47 <thoughtpolice> which is insanely hideous I would imagine; but I've never done parsing work like this before (i basically wanted an excuse to use harpy)
16:06:15 <Pseudonym> I find parsing oddly fun.
16:06:23 <Pseudonym> And I find that oddly disturbing.
16:06:58 <SamB_XP> you could also have grabbed the copy from the other authors web site
16:09:25 <monochrom> Brack and Op seem spurious. Otherwise the AST is ok.
16:10:44 <ddarius> Pseudonym: You should.
16:11:06 <Pseudonym> monochrom: Brack isn't so dumb, sometimes.
16:11:22 <Pseudonym> Fortran's semantics are that parentheses are never "broken".
16:11:33 <SamB_XP> broken?
16:11:34 <Pseudonym> So a + b + c could be (a + b) + c or (a + c) + b
16:11:48 <SamB_XP> oh, that
16:11:48 <Pseudonym> But a + (b + c) never breaks the (b + c) addition.
16:11:59 <Pseudonym> It could be (c + b) + a, but never (a + b) + c
16:12:11 <SamB_XP> this only matters in floating-point right?
16:12:13 <Pseudonym> Right.
16:12:18 <Pseudonym> Which is important in Fortran.
16:12:24 <Pseudonym> Since God is real unless explicitly declared integer.
16:12:44 <SamB_XP> heh
16:14:34 <Pseudonym> There is no standard priority queue that people use, right?
16:14:46 <mrd> Data.Set :/
16:14:58 <Pseudonym> Which doesn't help.
16:14:59 <SamB_XP> that's not a real priority queue...
16:15:03 <Pseudonym> Right.
16:15:09 <SamB_XP> Pseudonym: I guess not
16:15:10 <Pseudonym> Data.Multiset might, if we had that.
16:15:30 <SamB_XP> steal something from okasaki or something
16:15:33 <sjanssen> edison
16:15:35 <mrd> works for me, because the last time i used a pqueue, i needed it to be a Set too
16:16:00 <Pseudonym> Yeah, I know about Edison, having briefly been its maintainer.
16:16:30 <SamB_XP> that's probably the closest you'll get to a standard priority queue :-(
16:16:39 <Pseudonym> I'm wondering whether collections is the right place for this.
16:16:58 * Pseudonym has just re-implemented his own priority queue type for about the 10th time
16:17:00 <mrd> findMin on Data.Map can be a multiset =)
16:17:21 <Pseudonym> newtype PQueue p a = PQueue (M.Map p (S.Sequence a)) -- Not the most efficient possible type.
16:17:51 <sjanssen> Pseudonym: why don't you use edison?
16:18:01 <sjanssen> oh, sorry
16:18:20 <sjanssen> didn't read the scrollback, you know about it :)
16:19:18 <sjanssen> Pseudonym: I suppose the question still stands, why not edison?
16:19:57 <Pseudonym> Edison has some problems.
16:20:45 <fasta> Pseudonym: like?
16:20:46 <Pseudonym> Fewer, since we broke compatibility with H98, but still problems.
16:21:08 <fasta> The only problem I have with Edison is that it doesn't work in 6.8
16:21:10 <Pseudonym> One philosophy behind Edison is that every data structure implements every operation.
16:21:21 <Pseudonym> That makes it very hard to add a new data structure.
16:21:26 <fasta> That seems an odd philosophy
16:21:42 <fasta> The point of a data structure is that it does one set of operations very fast.
16:21:48 <Pseudonym> Sure.
16:21:52 <Pseudonym> But... OK, here's the thing.
16:23:00 <matthew-_> But the play's the thing!
16:23:01 <bos> why does every type implement every operation? are they hidden behind a typeclass or something?
16:23:12 <monochrom> Yes, typeclass.
16:23:36 <monochrom> [1..] !! 10000 is very slow, but still supported.
16:24:03 <Pseudonym> Sorry, boss key.
16:24:07 <monochrom> haha
16:24:24 <Pseudonym> Yeah, I've done stuff... say you're implementing a virtual machine.
16:24:27 <Pseudonym> And you need a stack.
16:24:38 <Pseudonym> In C++, you'd say "Cool, std::stack it is."
16:24:56 <Pseudonym> Only to find that std::stack doesn't support peering at the second element.
16:25:45 <Eelis-> which is the point of using std::stack
16:25:45 <Eelis-> if you want to peer at the elements, you might as well use a deque or something directly
16:25:45 <Pseudonym> Right.
16:25:47 <nornagon> darcs add -r . should take longer, dammit!
16:25:49 <Pseudonym> But you don't know that in advance.
16:25:55 <monochrom> Yes, that is why a data structure should support the slow operations too. Document it as slow. But let people use it.
16:25:56 <Pseudonym> That's the Edison idea.
16:25:59 <Pseudonym> Right.
16:26:01 <Eelis-> Pseudonym: not unless you've ever opened a C++ book
16:26:16 <Pseudonym> Eelis: No, you might not know in advance that you need to peer at the second element.
16:26:57 <Eelis-> oh. yes. fortunately, changing from std::stack to something like std::deque is really easy
16:27:04 <Pseudonym> Right.
16:27:09 <Pseudonym> And that's also true in Edison.
16:27:11 <monochrom> Remember we're talking about abstract data types. If you hide the implementation, and your external interface lacks something, the user is SOL.
16:27:16 <Pseudonym> Bingo.
16:27:30 <Pseudonym> If you find a performance issue, you change one typedef, and then you're done.
16:27:59 <nornagon> type Arr a e = UArray a e :)
16:28:43 <monochrom> If some nice data structure doesn't really support an operation (not even if you allow slow), perhaps the external type class needs to be factored.
16:29:06 <monochrom> (Like the infamous Num hierarchy! XD)
16:29:11 <matthew-_> or just use pointers...
16:29:24 <LoganCapaldo> Yeah to peer at the second element you can pop ...
16:29:47 <LoganCapaldo> as sucky as that might be
16:30:47 <SamB_XP> why does flixster assume that just because I want to see a movie I'll think it's good...
16:30:57 <monochrom> This example you can work around. In general there may be no workaround, or the workaround is 100 times more sucky than this example.
16:31:10 <ddarius> SamB_XP: Clearly if you didn't want to see the movie...
16:31:22 <MyCatVerbs> SamB_XP: because they might've assumed you aren't a masochist...?
16:31:24 <ddarius> E.g. peer at the 100th element.
16:31:33 <monochrom> haha
16:31:38 <SamB_XP> I want to see Episode III regardless
16:31:54 <ddarius> SamB_XP: Principle of Revealed Preference
16:32:44 <monochrom> Related OT: I know people who reason like this: "this movie sucks, therefore I'm right in watching a pirated copy"
16:32:56 <monochrom> (I don't actually follow the logic.)
16:33:18 <fasta> Pseudonym: ok, sounds sensible.
16:33:23 <SamB_XP> yeah, really
16:33:58 <SamB_XP> if you're going to pirate a movie, you might as well do it for a GOOD movie
16:34:41 <matthew-_> quite. otherwise the mpaa ain't going to loose too much
16:34:50 <sjanssen> how embarassed would you be if you were taken to court over a bad movie?
16:34:51 <Pseudonym> Or do it for a movie that you can't get.
16:34:57 <Pseudonym> Something rare.
16:35:03 <fasta> matthew-_: you need to reach the 58 billion of course :P
16:35:07 <Pseudonym> Like the original theatrical release of Star Wars.
16:35:20 <SamB_XP> is it available online?
16:35:28 <Pseudonym> No clue.
16:35:51 <sjanssen> or Star Wars Holiday Special
16:35:52 <Pseudonym> Actually, that'd be a way to get me to pay up.
16:36:06 <Pseudonym> MPAA: I accuse you of pirating "Dude, Where's My Car"!
16:36:16 <Pseudonym> Me: I'll pay you $10k if you never repeat that.
16:36:25 <fasta> Isn't pirating selling a non-retail copy?
16:36:27 <sjanssen> they've released the THX remaster of Star Wars IIRC
16:36:44 <SamB_XP> I've heard of I, II, and III
16:36:46 <SamB_XP> but not IIRC
16:37:02 <sjanssen> SamB_XP: release candidate
16:37:19 <monochrom> hahahaha!
16:37:25 <sjanssen> it was great, but they scrapped it and made Attack of the Clones
16:37:36 * Pseudonym laughs
16:37:39 <matthew-_> MPAA: We accuse you of pirating "Lord of the Rings" and we congratulate you on your choice of movie
16:38:23 <Pseudonym> One issue with that is that the better the movie, the less money it's worth, so the less actual damages they incurred.
16:38:34 <Pseudonym> MPAA: We accuse you of pirating "Adaptation"!
16:38:45 <Pseudonym> Me: OK, here's your $20.
16:39:32 <SamB_XP> what movie would they then say "we didn't think we could get that much for the rights!" about?
16:39:47 <dolio> Glitter.
16:39:52 <Pseudonym> Pi?
16:41:27 <Pseudonym> I think this also works for music.
16:41:51 <Pseudonym> RIAA: We accuse you of pirating Britney!  Haha, we can't believe people actually pay for it.
16:41:59 <Randroid> Glitter is my favorite movie, just as Visual Basic is my favorite programming language.
16:42:17 <lament> Visual Basic: The Movie
16:42:22 <Pseudonym> RIAA: How do we sleep at night?  On top of a large pile of money with many beautiful ladies.
16:42:57 <dolio> I'm not sure Visual Basic is bad enough to justify that analogy.
16:43:17 <lament> ouch
16:43:27 * Pseudonym is happy to say he has no clue what Glitter is about
16:43:33 <Pseudonym> All I know is who's in it, and that's enough.
16:43:43 <dolio> It's like 8 Mile, only with Mariah Carey.
16:43:51 <Pseudonym> Also haven't seen 8 Mile.
16:44:02 <Randroid> 8 Mile was not bad. Never saw Glitter.
16:44:05 <Pseudonym> I'm guessing that it helps to watch Glitter if you turn the sound down.
16:44:28 <Randroid> I happen to like Eminem, even if most of my musical taste is indie and punk.
16:44:39 <dolio> Yeah, 8 Mile was actually a decent film.
16:44:44 <Pseudonym> I've heard that, yeah.
16:45:25 <Pseudonym> Eminem seems a bit like Enya, though.  Quite different at the time, but career not moving in any direction to speak of.
16:46:14 <Randroid> I think that's because he's made his pile of cash and is now enjoying it. Man, that's what I want. As much as I love programming, I'd never write another line if I had a huge pile of cash.
16:46:25 <Pseudonym> I would.
16:46:26 <matthew-_> gah. get out!
16:46:28 <Pseudonym> But I'd write what I wanted.
16:46:36 <matthew-_> Pseudonym: me too.
16:46:47 <matthew-_> I'd write games all day long, until I got bored of that
16:46:54 <Pseudonym> I'd churn out Haskell libraries.
16:47:02 <Pseudonym> For a while, anyway.
16:47:14 <lekro> hi. what happened to the Control.Monad.State documentation? The results for "put" don't lead me to the right place (or I didn't see it): http://www.haskell.org/hoogle/?q=put
16:47:15 <lambdabot> Title: put - Hoogle
16:47:16 <Randroid> I used to be a nightclub doorman, so I still like that partying lifestyle.
16:47:22 <Pseudonym> Actually, if I was a musician, I'd go like Radiohead.
16:47:30 <Pseudonym> Still make music, but not require anyone to pay for it.
16:47:35 <lekro> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html#v%3Aput is just a nearly empty page
16:47:37 <lambdabot> http://tinyurl.com/yy4aqu
16:47:55 <TSC> Follow the link to .Lazy
16:48:10 <lament> if i had all the money i wanted, i would very likely make music.
16:48:18 <lekro> TSC: still no reference to put and get there
16:48:33 <TSC> Yeah, I see
16:48:35 <Pseudonym> lament: Cool!  Can I be your producer?  I'm pretty handy with a mixer.
16:48:38 <Randroid> I'd chase women. Not something I'm proud of, but I know myself.
16:49:30 <lament> Pseudonym: sorry, i don't have all the money in the world yet :)
16:49:34 <Pseudonym> Damn.
16:49:44 <fasta> *** Exception: Prelude.read: no parse
16:49:46 <fasta> ghc-6.9.20070927: panic! (the 'impossible' happened
16:49:56 <fasta> That doesn't sound too good.
16:50:02 <TSC> lekro: It's in Control.Monad.State.Class: http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Class.html#v%3Aput
16:50:02 <lament> Randroid: well that goes without saying.
16:50:03 <lambdabot> http://tinyurl.com/yuyeqp
16:50:27 <ddarius> Randroid: It's not something to be proud of but it's not something to be ashamed of either.
16:50:35 <Randroid> ddarius: So true.
16:50:48 <lament> depending on how good you're at it, you could be proud
16:50:53 <lekro> TSC: thanks. So is it a problem with hoogle that it doesn't link to this place?
16:51:14 <TSC> I guess so
16:51:30 <Randroid> lament: I generally do well.
16:52:00 <ddarius> My tastes for "doing well" would quickly lead me to not need the skill any longer.
16:52:18 <ddarius> So, I guess by metric, I don't do all that well...
16:52:22 <Randroid> heh
16:53:23 <lament> just marry and get it over with? :)
16:54:51 <Randroid> I almost went down that road. I'm almost 40, so I don't think it's going to happen, but I could be wrong.
16:55:01 <ddarius> lament: My main problem is finding a woman I'd actually be interested in.
16:58:22 <Randroid> I generally don't have any problem finding attractive women. It's attractive women who are a bit geeky that are hard to find. That'd be my perfect girl.
16:58:42 <Randroid> A Haskell hottie. Imagine that.
16:58:59 <pp> _|_
16:59:28 <thoughtpolice> that would be, illogical.
16:59:39 <dmwit> pp: Oh, you're more of a "bottom" man than a "(.) . (.)" man?
16:59:39 <Randroid> hehe
16:59:55 <Randroid> dmwit: That made me laugh out lod.
16:59:57 <Randroid> *loud
17:00:13 <Randroid> I'm definitely a _|_ man.
17:00:15 <Randroid> Don't know about pp, though.
17:00:16 <fasta> Why is it that everytime I try to build something, GHC breaks?
17:00:27 <Randroid> fasta: I've never had that problem.
17:00:43 <Randroid> Type errors of all kinds, yes, but I've never broken GHC.
17:00:46 <fasta> Randroid: that's probably because you don't use extensions.
17:01:03 <fasta> Randroid: I lost count, I think I am at about 50.
17:01:09 <Randroid> Wow.
17:01:46 <Randroid> Most of my errors can be fixed by -fallow-overlapping-instances and such.
17:01:59 <Randroid> Simple stuff.
17:02:12 <fasta> Randroid: I am talking about panics.
17:02:14 <dmwit> fasta: 50 extensions?
17:02:31 <fasta> dmwit: 50 different GHC panics/crashes.
17:02:35 <Randroid> fasta: I know. I'm saying I don't get them, and the worst I get are simple compilation errors.
17:02:37 <dmwit> aha
17:03:28 <dibblego> is there a function : (Monad m) => m [a] -> [m a] ?
17:03:39 <fasta> @src read
17:03:40 <lambdabot> read s = either error id (readEither s)
17:03:46 <fasta> @src readEither
17:03:46 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:03:53 <fasta> Yes, it is.
17:04:32 <dmwit> dibblego: Sounds like that would be a way to escape the monad...?
17:04:49 <dibblego> dmwit, yeah I got it wrong anyway (I don't want that function)
17:04:56 <dmwit> ok =)
17:05:40 <dibblego> I just wanted fmap :)
17:06:56 <dibblego> ?hoogle (Functor f) => (a -> IO ()) -> f a -> IO ()
17:06:56 <lambdabot> No matches, try a more general search
17:07:13 <mrd> ?type flip bind
17:07:18 <mrd> ?type flip (>>=)
17:07:18 <lambdabot> Not in scope: `bind'
17:07:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
17:07:24 <dibblego> of course, cheers
17:07:32 <dmwit> ?hoogle (MonadIO m) => (a -> m ()) -> m a -> IO ()
17:07:32 <lambdabot> No matches, try a more general search
17:07:35 <sorear> dibblego: That function is in general impossible, you may be looking for Data.Foldable.mapM_
17:07:45 <sorear> dibblego: e.g. consider f = (Double ->)
17:07:54 <sorear> @ty Data.Foldable.mapM_
17:07:56 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Foldable.Foldable t) => (a -> m b) -> t a -> m ()
17:08:01 <dibblego> sorear, agreed
17:08:20 <shachaf> sorear: < dibblego> dmwit, yeah I got it wrong anyway (I don't want that function)
17:08:38 <dibblego> shachaf, I keep screwing up!
17:09:11 <fasta> > read ""::Int
17:09:12 <lambdabot>  Exception: Prelude.read: no parse
17:09:28 <fasta> Ok, good I found the bug now.
17:09:37 <shachaf> > read "" :: ()
17:09:39 <lambdabot>  Exception: Prelude.read: no parse
17:09:42 <dmwit> > read ""
17:09:43 <lambdabot>  Exception: Prelude.read: no parse
17:09:51 <fasta> GHC panics when you define a command that should take an argument, but don't give it.
17:10:06 <shachaf> read defaults to Integer on lambdabot, right?
17:10:13 <fasta> So, it's a minor issue, but still should never happen.
17:10:26 <fasta> At least, that's what I think it is.
17:10:29 <fasta> Verifying it now
17:10:57 <dmwit> > let argumentless :: Int; argumentless x = 3 in argumentless 5
17:10:58 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Int'
17:11:05 <dmwit> > let argumentless :: Int; argumentless x = 3 in argumentless
17:11:06 <lambdabot>      The equation(s) for `argumentless' have one argument,
17:11:06 <lambdabot>     but its type `...
17:11:30 <dmwit> > let argumentless :: Int -> Int; argumentless = 3 in argumentless
17:11:31 <lambdabot>   add an instance declaration for (Num (Int -> Int))
17:11:31 <lambdabot>     In the expression: 3...
17:12:06 <fasta> Hmm, it is somewhat more complicated..
17:12:55 <fasta> Does lambdabot also do the :def command?
17:13:02 <sorear> no.
17:13:13 <fasta> Too bad, I could crash it easily.
17:13:22 <fasta> :def foof (\a -> let z = read a::Int in return (show z))
17:13:25 <fasta> :foof
17:13:33 <fasta> That will crash your favorite new GHC.
17:14:00 <dmwit> I just get an exception.
17:14:11 <fasta> dmwit: what version?
17:14:20 <dmwit> 6.6.1
17:14:39 <fasta> dmwit: is :def even implemented in 6.6.1?
17:14:42 <shachaf> ":def foof (return . show . read)" is simpler. :-)
17:14:47 <dmwit> It seems to be.
17:15:01 <sorear> fasta: of course GHC crashes
17:15:10 <Pseudonym> > let argumentless :: Int -> Int; argumentless x = 3 in argumentless 5
17:15:12 <lambdabot>  3
17:15:16 <sorear> fasta: you just injected a bug!
17:15:26 <fasta> sorear: I know I miss an argument
17:15:33 <fasta> sorear: that's no reason for panic
17:15:50 * Olathe panics for no reason.
17:15:51 <sorear> fasta: yes it is, 'panic' means there was an exception in code called by GHC
17:15:59 <Pseudonym> Don't Panic.
17:16:00 <shachaf> :def foof (return . undefined)
17:16:02 <sorear> fasta: which fits your situation perfectly
17:16:02 <Pseudonym> X <- You are here.
17:16:24 <dmwit> :def foof undefined
17:16:25 <hpaste>  mycatverbs pasted "trivial uniq example" at http://hpaste.org/3188
17:16:35 <fasta> sorear: well, then maybe it should know when it is executing user code?
17:17:03 <fasta> sorear: and then throw a "you suck"-exception?
17:17:16 <shachaf> MyCatVerbs: How about: interact $ unlines . nub . lines
17:17:17 <fasta> Or a more nice message, of course.
17:17:20 <hpaste>  Pseudonym annotated "trivial uniq example" with "(no title)" at http://hpaste.org/3188#a1
17:17:46 <hpaste>  dmwit annotated "trivial uniq example" with "shorter?" at http://hpaste.org/3188#a2
17:17:49 <MyCatVerbs> shachaf: that's what I'd do in ghc -e, but I wanted to demonstrate IO.
17:18:01 <shachaf> Or what Pseudonym said, if you don't want interact.
17:18:41 <fasta> sorear:  :def foof undefined does not make GHC manic.
17:18:48 <fasta> panic*
17:18:58 <fasta> sorear: so, those cases are not the same.
17:19:05 <hpaste>  Pseudonym annotated "trivial uniq example" with "(no title)" at http://hpaste.org/3188#a3
17:19:30 <shachaf> fasta: :def foof return . undefined does.
17:19:33 <Pseudonym> And, of course, there's no reason for handle I/O in this trivial example.
17:19:52 <vincenz> even better
17:19:53 <Pseudonym> But I'm going with the flow.
17:20:06 <fasta> shachaf: indeed, it does here too.
17:20:11 <hpaste>  vincenz annotated "trivial uniq example" with "even nicer" at http://hpaste.org/3188#a4
17:20:44 <shachaf> Hmm, this doesn't happen in 6.6.1.
17:21:12 <vincenz> damn, forgot to remove hPutstr
17:21:16 <vincenz> and replace by simple putStr
17:21:40 <dmwit> We are now ready to thoroughly confuse whoever MyCatVerbs was trying to teach about IO. =D
17:22:01 <vincenz> suffice to say
17:22:02 <vincenz> nub is bad
17:22:05 <vincenz> it's O(n^2)
17:22:28 <shachaf> Pseudonym: Also, this doesn't behave like the UNIX uniq.
17:22:36 <shachaf> s/Pseudonym/MyCatVerbs/
17:22:38 <hpaste>  vincenz annotated "trivial uniq example" with "better" at http://hpaste.org/3188#a5
17:22:39 <Pseudonym> Yeah, for that you want noDups.
17:23:21 <shachaf> noDups?
17:23:25 <Pseudonym> Which, I note, isn't in Data.List.
17:23:37 <Pseudonym> noDups (x1:x2:xs) | x1 == x2 = noDups x2:xs
17:23:43 <Pseudonym> noDups (x:xs) = x : noDups xs
17:23:46 <Pseudonym> noDups [] = []
17:23:51 <vincenz> Pseudonym: so it's only local
17:24:12 <shachaf> > map head . group $ [1,2,3,3,2,4,1]
17:24:14 <lambdabot>  [1,2,3,2,4,1]
17:24:16 <shachaf> Maybe?
17:24:18 <Pseudonym> Left out some parens on that first rule.
17:24:28 <Pseudonym> @let noDups (x1:x2:xs) | x1 == x2 = noDups (x2:xs)
17:24:32 <Pseudonym> @let noDups (x:xs) = x : noDups xs
17:24:33 <lambdabot> Defined.
17:24:36 <lambdabot> Defined.
17:24:36 <Pseudonym> @let noDups [] = []
17:24:39 <lambdabot> Defined.
17:24:44 <Pseudonym> > noDups [1,2,3,3,2,4,1]
17:24:45 <lambdabot>  [1,2,3,2,4,1]
17:24:45 <vincenz> > noDups [1,2,2,3,2,4,4,]
17:24:46 <lambdabot>  Parse error
17:24:46 <vincenz> > noDups [1,2,2,3,2,4,4,1]
17:24:47 <lambdabot>  [1,2,3,2,4,1]
17:25:07 * vincenz wishes there were a 2 element foldr
17:25:14 <dmwit> shachaf: I like your version better. =)
17:25:23 <dmwit> vincenz: foldr + zip?
17:25:37 <Pseudonym> Sachaf's version has the advantage that it gets deforested/stream fused/whatever.
17:25:38 <shachaf> dmwit: No, two elements from the same list (I assume).
17:25:39 <vincenz> dmwit: no, foldr down 1 list
17:25:49 <Pseudonym> shachaf
17:25:49 <vincenz> sur, I could foldr . zip l (tail l)
17:25:50 <stepcut> vincenz: foldr . uncurry ?
17:25:51 <vincenz> but that sounds nasty
17:26:05 <Pseudonym> Oh, nice idea!
17:26:12 <dmwit> vincenz: That's what I meant.
17:26:15 <vincenz> especially since it fails on one element lists
17:26:25 <vincenz> > let l = [1] in zip l (tail l)
17:26:27 <lambdabot>  []
17:26:30 <stepcut> oh. yeah a two element foldr would be nice
17:26:32 <shachaf> use drop 1 instead of tail.
17:26:39 <vincenz> that's exactly the same
17:26:44 <vincenz> you don't get a last tuple is my point
17:26:48 <dmwit> vincenz: But... what would you prefer as behavior for 1-element lists?
17:26:49 <stepcut> foldr with lookahead
17:26:59 <vincenz> dmwit: a finial case of course
17:27:07 <Pseudonym> > map snd . filter (not . (==)) . ap zip id tail $ [1,2,2,3,2,4,4,1]
17:27:08 <lambdabot>  Couldn't match expected type `Bool'
17:27:13 <vincenz> just like foldr expects something to be done on empty lists (z), you want something for 1 element lists (f)
17:27:19 <vincenz> and then something for whenever you have 2 elements (g)
17:27:21 <Pseudonym> > map snd . filter (not . uncurry (==)) . ap zip id tail $ [1,2,2,3,2,4,4,1]
17:27:22 <lambdabot>  Couldn't match expected type `a -> [(a1, a1)]'
17:27:26 <Randroid> Recently I've been showing Haskell to a colleague of mine, who was intrigued but described it as too clever for its own good. According to him, it will never catch on because your average corporate programmer will never get it. However, I imagine the same was said about object-oriented languages when they first debuted.
17:27:32 <Randroid> (I realize functional languages are even older.)
17:27:40 <shachaf> > ap zip tail [1,2,3]
17:27:41 <lambdabot>  [(1,2),(2,3)]
17:27:47 <shachaf> Maybe?
17:27:53 <Pseudonym> ?pl \ (x,y) -> not (x == y)
17:27:53 <lambdabot> uncurry (/=)
17:27:59 <ddarius> Randroid: And the average corporate programmer still doesn't get OO
17:27:59 <vincenz> > ap zip tail [1]
17:28:01 <lambdabot>  []
17:28:02 <Pseudonym> > map snd . filter (uncurry (/=)) . ap zip id tail $ [1,2,2,3,2,4,4,1]
17:28:02 <lambdabot>  Couldn't match expected type `a -> [(a1, a1)]'
17:28:15 <Pseudonym> ?pl \x -> zip x (tail x)
17:28:15 <lambdabot> ap zip tail
17:28:20 <vincenz> @let foldr2 z f g [] = z
17:28:20 <Pseudonym> > map snd . filter (uncurry (/=)) . ap zip tail $ [1,2,2,3,2,4,4,1]
17:28:22 <lambdabot>  [2,3,2,4,1]
17:28:26 <lambdabot> Defined.
17:28:32 <vincenz> @let foldr2 z f g [a] = f a z
17:28:33 <Pseudonym> Yeah, almost works, apart from the first element.
17:28:36 <lambdabot> Defined.
17:28:42 <Pseudonym> > map snd . filter (uncurry (/=)) . ap zip tail $ [1,1,2,2,3,2,4,4,1]
17:28:43 <lambdabot>  [2,3,2,4,1]
17:28:52 <vincenz> @let foldr2 z f g (a:b:xs) = foldr 2 (g a b z) f g xs
17:28:52 <lambdabot> Couldn't match expected type `[a]'
17:29:03 <Randroid> ddarius: That's so true. I can't tell you how many times I've seen developers simply fail to use inheritance and polymorphism in a dirt-simple language like C#.
17:29:05 <vincenz> @let foldr2 z f g (a:b:xs) = foldr2 (g a b z) f g xs
17:29:08 <lambdabot> Defined.
17:29:11 <vincenz> : foldr2
17:29:13 <vincenz> :t foldr2
17:29:15 <lambdabot> Not in scope: `foldr2'
17:29:17 <vincenz> :t L.foldr2
17:29:19 <lambdabot> Couldn't find qualified module.
17:29:22 * vincenz mutters
17:29:26 <dmwit> foil'd
17:29:56 <dmwit> > typeOf foldl2
17:29:56 <EvilTerran> foil'dr2?
17:29:57 <lambdabot>   Not in scope: `foldl2'
17:30:02 <dmwit> > typeOf foldr2
17:30:03 <lambdabot>  Add a type signature
17:30:09 <vincenz> @unlet
17:30:10 <dmwit> > show (typeOf foldr2)
17:30:11 <lambdabot>  Add a type signature
17:30:13 <lambdabot> Defined.
17:30:15 <vincenz> @unlet foldr2
17:30:15 <lambdabot>  Parse error
17:30:16 <shachaf> @ty typeOf
17:30:18 <lambdabot> forall a. (Typeable a) => a -> TypeRep
17:30:20 <vincenz> there was an error in it
17:30:35 <vincenz> @let foldr2 z f g [] = []
17:30:35 <lambdabot> <local>:9:0:     Warning: Pattern match(es) are overlapped              In th...
17:30:38 <EvilTerran> there is no @unlet, only @undefine, which takes everything
17:30:41 <vincenz> @unlet foldr2
17:30:42 <lambdabot>  Parse error
17:30:44 <vincenz> @undefine foldr2
17:30:46 <lambdabot> Undefined.
17:30:49 <vincenz> @let foldr2 z f g [a] = []
17:30:52 <lambdabot> Defined.
17:30:52 <vincenz> @forget foldr2?
17:30:52 <lambdabot> Incorrect arguments to quote
17:30:54 <vincenz> @undefine foldr2
17:30:56 <lambdabot> Undefined.
17:30:59 <EvilTerran> it takes everything! it doesn't take a parameter, just resets the whole @let state
17:31:29 <vincenz> @let foldr2 z f g [] = z; foldr2 z f g [a] = f a z; foldr2 z f g (a:b:xs) = foldr2 (g a b z) f g (b:xs)
17:31:30 <lambdabot> Defined.
17:31:33 <Randroid> ddarius: I think learning Haskell makes one a better programmer overall, though. I've found my day-to-day corporate code, mostly written in Ruby or C#, has tightened up a bit.
17:31:52 <ddarius> Randroid: I agree.
17:31:53 <vincenz> > foldr2 [] (:) (\a b l -> if a == b then l else a:l) [1,2,2,3,4,2,1]
17:31:55 <lambdabot>  [1,2,4,3,2,1]
17:31:58 <vincenz> there w go
17:32:06 <dmwit> Except the answer is wrong.
17:32:13 <Tac-Tics> @src foldl2
17:32:13 <lambdabot> Source not found. Take a stress pill and think things over.
17:32:21 <dmwit> Oh, it's backwards.
17:32:23 <vincenz> right, I oughta do this in vim instead of irc
17:32:24 <dmwit> That's okay.
17:32:34 <vincenz> it's foldr, not foldl :)
17:32:44 <Tac-Tics> @src foldr2
17:32:44 <lambdabot> Source not found. Take a stress pill and think things over.
17:32:46 <vincenz> > foldr [] (:) [1..10]
17:32:46 <lambdabot>  Couldn't match expected type `a -> b -> b'
17:32:54 <vincenz> > foldr [] (flip (:)) [1..10]
17:32:55 <LoganCapaldo> but vim doesn't talk back
17:32:55 <lambdabot>  Couldn't match expected type `a -> b -> b'
17:32:58 <vincenz> meh
17:32:58 <dmwit> Tac-Tics: It was ?let a little bit up, scroll back and you'll see it.
17:33:00 <vincenz> ok, emacs then
17:34:29 <fasta> I am stepping through the code at the speed of snails.
17:35:06 <LoganCapaldo> snails...on speed?
17:35:17 <fasta> A few hundred a second I guess.
17:35:37 <fasta> But since the code normally executes at probably millions of steps a second...
17:36:06 <dmwit> step fasta!
17:36:11 <dmwit> Sorry, couldn't resist.
17:36:18 <LoganCapaldo> lol
17:36:49 <fasta> If I was just born a few millenia later, I could ignore more constant factors..
17:37:29 <ddarius> fasta: Well, you were born with a constant factor of that time.
17:39:29 <Cale> LoganCapaldo: It was sort of a haha-only-serious thing.
17:41:03 <Cale> LoganCapaldo: I was pointing out another good approach while mocking their hard-line take on TDD.
17:45:44 <halcyon10> i just used parsec the first time. Man, i didn't know parsing is soo much fun :)
17:45:56 <stepcut> halcyon10: haha
17:46:18 <LoganCapaldo> Cale: that's what i thought but it was so well executed I couldn't tell if it was a _complete_ joke or if you were also throwing in some proof advocacy while you were at it
17:47:37 <dibblego> can you open a file for write, but create it and its parent directories if it doesn't exist?
17:48:08 <Cale> There might be something in the filepath module for that.
17:48:17 <dibblego> I've been looking for it
17:48:21 <Cale> But I don't think it's in System.Directory directly.
17:48:45 <dibblego> there is createDirectoryIfMissing; I could putsomething together with that
17:50:00 <halcyon10> :r
17:50:20 <halcyon10> *doh*
17:50:44 <vwx> Cale: what comment are you talking about?
17:50:57 <Cale> http://programming.reddit.com/info/2y9jb/comments/c2yce9
17:50:58 <lambdabot> Title: Testing Misconceptions #1: Exploratory Programming (a response to redditors and  ...
17:51:06 <Cale> It parodies the article that it's attached to.
17:51:28 <Cale> I basically replaced "unit testing" with "identifying and proving algebraic properties"
17:51:33 <SamB_XP> a stress pill?
17:51:40 <SamB_XP> lambdabot: you must be kidding!
17:53:24 <vwx> Cale: do you personally ever use unit testing?
17:53:39 <Cale> Somewhat.
17:53:45 <Cale> I've used quickcheck.
17:53:56 <Tac-Tics> @src List.(>>=)
17:53:57 <lambdabot> Source not found. stty: unknown mode: doofus
17:54:10 <dibblego> quickcheck is haddock on steroids
17:54:12 <Cale> Most of the time I really do informally prove things in my head.
17:54:37 <dibblego> expressing algebraic properties > writing them in English
17:55:46 <augustss> dons talk at the Haskell WS about xmonad and property driven development was excellent
17:56:41 <vwx> augustss: is there a video online?
17:56:51 <augustss> I don't know
17:56:51 <Cale> http://www.ludd.ltu.se/~pj/hw2007/HaskellWorkshop.html
17:56:52 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
17:56:54 <Cale> yes
17:57:25 <Cale> There are links there to all the Haskell Workshop talks. I've been watching them on and off all day :)
17:57:31 <augustss> yes, there seems to be :)
17:57:34 <vwx> wow super sweet
17:58:11 <augustss> Cale: did you see my 50 year retrospective?
17:58:34 <Cale> Not yet, which one is that in?
17:58:50 <augustss> It's a 3 minute intro to the discussion
17:58:54 <Cale> ah, cool
17:59:06 <augustss> I mention that 1.3 was the last sane versio
17:59:09 <Cale> heh
17:59:13 <sjanssen> ooh, discussion
17:59:17 <sjanssen> I bet that's the most interesting one
17:59:24 <user317> hmm anyone know if netbsd linker supports -rpath=\$$ORIGIN ?  readelf -d shows that the RPATH is in the binary like on linux, but it doesn't seem to do anything
17:59:26 <augustss> well, according to Aione in 2035
17:59:37 <Cale> augustss: What do you think was the problem with 1.4?
18:00:27 <augustss> Maybe I meant 1.4.  I didn't have any internet connection when i prepared the slide
18:00:44 <augustss> and it was )):30 after 5 beers
18:00:47 <augustss> 00:30
18:01:08 <Cale> hehe :)
18:05:42 <hpaste>  dataangel pasted "more newb compile problems :P" at http://hpaste.org/3189
18:05:44 <vwx> any ideas how to make an inverse of this function? http://hpaste.org/3187
18:06:30 <dataangel> Anyone help with a newb compile problem? http://hpaste.org/3189
18:06:41 <sjanssen> dataangel: min (x, y) is a problem
18:06:44 <Cale> dataangel: min(n,length board - 1) :: (Int, Int) -> (Int, Int)
18:06:52 <Cale> It's partially applied to a pair.
18:06:54 <sjanssen> dataangel: min x y -- is what you want
18:06:55 <dataangel> oh @_@
18:07:07 <dataangel> blinded by years of C++
18:07:13 <augustss>  vwx: you can do it with decodeFloat
18:07:30 <sorear> vwx: deconFloat (F# f#) = Word32# (unsafeCoerce# f#)
18:07:37 <Cale> Yeah, there's encodeFloat and decodeFloat
18:07:58 <vwx> i couldn't figure out how to tell how many bits the mantissa has with decodeFloat
18:08:07 <sorear> W32# rather
18:08:14 <augustss> vwx: you'd have to know
18:08:29 <sorear> vwx: you don't need to know
18:08:34 <sorear> > decodeFloat 1.5
18:08:36 <lambdabot>  (6755399441055744,-52)
18:08:41 <sorear> see that -52?
18:08:56 <sorear> > let (a,b) = decodeFloat 1.5 in a * 2^b
18:08:57 <lambdabot>  Exception: Prelude.^: negative exponent
18:08:59 <augustss> vwx: you can figure out the number of bits with some of the other operations of floats
18:09:00 <sorear> > let (a,b) = decodeFloat 1.5 in a * 2^^b
18:09:01 <lambdabot>   add an instance declaration for (Fractional Integer)
18:09:05 <Cale> **
18:09:10 <sorear> > let (a,b) = decodeFloat 1.5 in fromInteger a * 2^^b
18:09:11 <lambdabot>  1.5
18:09:31 <vwx> @type (^^)
18:09:34 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
18:09:45 <augustss> :i RealFloat
18:09:59 <Cale> er, yeah, not ** :)
18:10:32 <Cale> I really liked SPJ's response to Harpy :)
18:10:34 <augustss> vwx: floatRadix, floatDigits, and FloatRange help
18:10:46 <augustss> but in the end, they don't give you the layout
18:11:00 <Cale> (At least, I'm pretty sure that was SPJ's voice :)
18:11:16 <augustss> vwx: if you really want the sequence of bytes, I'd just do some horrible thing with a memory buffer
18:12:18 <vwx> augustss: but is Float guaranteed to always have the same representation  on all haskell systems? and even if yes then there is still the need to deal with endian issues
18:12:38 <Cale> vwx: No, but decodeFloat always has to produce the same thing.
18:12:49 <Cale> (or equivalent things)
18:13:31 <augustss> vwx: it's not guaranteed in the standard, but it is in practice
18:13:31 <halcyon10> what unary function always returns the empty list?
18:13:49 <augustss> halcyon10: const []
18:13:57 <halcyon10> ah thanks!
18:14:47 <vwx> is there a remote possibility that floatRadix will not be 2?
18:15:13 <dataangel> if you have a list of lists, is indexing an element: mylist !! x !! y, or is there a better idiom?
18:15:57 <augustss> vwx: there's a remote one.  IBM360/370 would have 16
18:16:02 <chessguy> @type (!! 1 !! 1)
18:16:04 <lambdabot>     The operator `!!' [infixl 9] of a section
18:16:04 <lambdabot>         must have lower precedence than the operand `(!!)' [infixl 9]
18:16:25 <vwx> augustss: is there a haskell system for that computer?
18:16:29 <dataangel> chessguy: I have no idea what that means
18:16:39 <chessguy> @type ((!! 1) . (!! 1))
18:16:40 <lambdabot> forall a. [[a]] -> a
18:16:46 <augustss> vwx: I'm sure Hugs could be made to run
18:17:02 <dataangel> ah that makes sense
18:17:05 <augustss> vwx: I've implemented arbitrary precision floats where I used 10 as a base
18:17:31 <chessguy> @pl \xys x y -> ((xys !! x) !! y)
18:17:31 <lambdabot> ((!!) .) . (!!)
18:17:57 <chessguy> @pl \x y xys -> ((xys !! x) !! y)
18:17:57 <lambdabot> flip . ((!!) .) . flip (!!)
18:18:06 <vwx> does CLDouble have the same representation of Double?
18:18:11 <chessguy> lots of ways to do it :)
18:19:05 <sjanssen> vwx: on my system, yes
18:19:18 <sjanssen> vwx: try :info CLDouble in ghci
18:20:10 <vwx> sjanssen. yes. so if i copy a "long double" from c into haskell and then back into c, i will lose precision?
18:20:38 <sjanssen> vwx: CLDouble should be the same as C's 'long double'
18:20:52 <sjanssen> that's the entire purpose to the Cfoo types
18:21:22 <vwx> hm... so haskell Double is actually c "long double" and not "double" ?
18:22:09 <sjanssen> there are no guarantees on the relation of Foo to CFoo types
18:22:22 <vwx> > sizeOf (1 :: Float)
18:22:23 <lambdabot>   Not in scope: `sizeOf'
18:22:47 <sjanssen> on my particular platform, Double, CDouble and CLDouble happen to be the same
18:23:24 <vwx> sjanssen: yes. this means that precision must be lost when a c "long double" (which is 10 bytes for 8 bytes for CLDouble) passes from c to haskell and back to c
18:23:58 <sjanssen> GHC must be wrong, then
18:24:10 <sjanssen> CLDouble *should* be the same as a 'long double'
18:25:37 <vwx> maybe a LongDouble type should be added to haskell?
18:27:38 <sjanssen> vwx: this is probably worth a bug report or email to the glasgow-haskell-users mailing list
18:27:57 <vwx> surely they are already aware of this issue
18:28:40 <sjanssen> vwx: it should at least be documented
18:28:53 <Pseudonym> "LongDouble" is different on different platforms.
18:29:03 <Pseudonym> It's 128 bit on Sparc, 80 bit on x86.
18:29:16 <Pseudonym> And moreover, on Sparc it's software-emulated.
18:34:04 <dibblego> ?type isSuffixOf
18:34:13 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:35:06 <dataangel> Is there a way to pass the elements of a tuple as the parameters of a function without writing them out? Like apply.
18:35:29 <dataangel> in python you can write f(*[3, 4, 5]) and it's the same as writing f(3, 4, 5)
18:36:05 <sjanssen> dataangel: you can use uncurry for 2-tuples
18:36:59 <dataangel> sjanssen: that's good enough for now but why aren't their n-ary versions?
18:37:04 <dataangel> *there
18:38:43 <sjanssen> dataangel: Haskell doesn't provide any generic programming for tuples
18:39:42 <dons> its just so rarely needed, you use lists and algebraic types instead
18:39:50 <dons> particularly the latter
18:40:39 <dibblego> is there a library to recurse down a directory, returning all filepaths?
18:40:46 <sjanssen> dataangel: usually 3-tuples or larger are the wrong thing, anyway
18:41:29 <dons> dibblego: yeah, bos wrote a lib for this. check hackage
18:41:33 <dons> FileSomething
18:41:36 <dibblego> thanks
18:41:42 <dons> though its fun to write yourself
18:41:59 <dibblego> FileManip?
18:42:12 <dibblego> yeah I've written it; I just hate writing it twice :)
18:42:34 <dons> FileManip, yeah
18:46:14 <sjanssen> why are some packages missing haddocks on hackage?
18:51:30 <dibblego> that library is very well written
18:51:53 <dibblego> I wish the core of Haskell was like that
18:52:10 <dons> sjanssen: some didn't generate
18:52:15 <dibblego> ?type find
18:52:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
18:52:27 <sjanssen> dons: I'm especially curious why X11-extras doesn't have haddocks
18:52:38 <dons> oh, might not have been regenerated
18:52:41 <dons> check an older version
18:53:16 <sjanssen> 0.2 has haddocks
18:54:12 <sjanssen> dons: so, are these manually generated every month or something?
18:54:17 <dons> something like that
18:54:21 <dons> a cronjob seems like a good idea.
18:54:28 <dons> or some on-demand script
18:54:34 <sjanssen> X11-extras 0.3 has been on hackage for a very long time
18:54:43 <dons> did we check it works ?
18:54:59 <sjanssen> 'Setup haddock' works on my machine
18:56:34 <dibblego> is the ap function named after applicative (function application in a monad) and not its similarity to fmap?
18:57:59 <sjanssen> dibblego: after 'apply', I think
18:58:08 <dibblego> ah ok cheers
18:58:49 <dibblego> ?hoogle (Monad m) => (a -> b) -> m [a] -> m [b]
18:58:50 <lambdabot> No matches, try a more general search
19:04:56 <byorgey> @type liftM . fmap
19:05:01 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Functor f) => (a -> b) -> m (f a) -> m (f b)
19:05:04 <byorgey> erm
19:05:07 <byorgey> @type liftM . map
19:05:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
19:05:21 <byorgey> dibblego: ^^
19:05:29 <dibblego> ta
19:10:36 <falconair_> I noticed that there was some talk of a library to communicate with erlang's binary protocol...is there actual work being done on it?
19:11:21 <dibblego> ?type fmap . map
19:11:23 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> b) -> f [a] -> f [b]
19:19:35 <hpaste>  Gwern pasted "xmonad build error" at http://hpaste.org/3190
19:25:25 <iank> <3 xmonad
19:25:57 <dons> iank: :)
19:25:57 <dibblego> ?hoogle (Functor f) => (a -> f b) -> [a] -> f [b]
19:25:58 <lambdabot> No matches, try a more general search
19:26:07 <dons> iank: you should join #xmonad :)
19:27:09 <dibblego> why do people use liftM all the time when fmap will do?
19:27:38 <dons> it can be more intuitive
19:27:43 <dons> liftM (+)
19:27:46 <dons> versus fmap (+)
19:28:25 <Korollary> Are there any ICFP videos?
19:29:49 <ChilliX> Korollary: everything was filmed, but it may take a while to psot-process
19:30:23 <ChilliX> *post
19:31:10 <sjanssen> Korollary: http://www.ludd.ltu.se/~pj/hw2007/HaskellWorkshop.html
19:31:10 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
19:31:32 <dibblego> ?hoogle (a -> IO b) -> [a] -> IO [b]
19:31:33 <lambdabot> No matches, try a more general search
19:31:35 <dons> everything was filmed for the ACM library, so we'll probably never see it again...
19:31:49 <dons> it won't be freely available, I guess?
19:33:25 <falconair_> aren't these the ones: http://www.ludd.ltu.se/~pj/hw2007/HaskellWorkshop.html
19:33:26 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
19:33:28 <ChilliX> dons: Are you sure that was meant to be exclusive>
19:33:30 <ChilliX> ?
19:33:44 <ChilliX> I thought its justa  way of archiving it
19:34:13 <dibblego> I'm having trouble thinking about how I'd write this function; is it even possible? (a -> IO b) -> [a] -> IO [b]
19:34:32 <dons> ChilliX: hmm, well malcolm recorded his own versions. it was only rumour that it was exclusive. it was definitely stated it was for the digital library
19:34:40 <dons> which usually means its non-free, doesn't it?
19:34:46 <sorear> dibblego: mapM
19:34:56 <ChilliX> dons: But it wasn't on the initiative of the ACM
19:34:59 <dibblego> oh
19:35:01 <dibblego> ?type mapM
19:35:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:35:07 <dibblego> cheers :)
19:35:13 <ChilliX> we should ask stefan
19:35:23 <dons> ah yes, i saw him changing tapes
19:35:23 <sorear> which one?
19:35:31 <ChilliX> sorear: stefan wehr :)
19:35:32 <dons> so maybe the rumours were misguided.
19:35:41 <dons> sorear: unless you know the answer? :)
19:35:47 * FMota_ wonders
19:36:04 <FMota_> would you have a turing machine if you had a scanner, a printer, and infinite amounts of paper?
19:36:04 <ChilliX> dons: it is supposed to go into the DL; it's just that I assumed it not to be exclusive
19:36:05 <FMota_> :o
19:36:19 <ddarius> FMota_: Not without some logic.
19:36:23 <dons> i'd hope its non-exclusive, if ACM didn't do the work
19:36:44 <sorear> FMota_: You'd also need to find some way to stop the paper from collapsing into a black hole
19:36:49 <FMota_> ddarius: the logic is already there.
19:37:01 <FMota_> sorear: smart-ass.
19:37:07 <FMota_> ;)
19:37:17 <ddarius> sorear: Just do the same thing Turing did with his tape.
19:37:19 <sorear> FMota_: in general, the maximum amount of matter in a spherical region of space is proportional to the *radius*, not the volume
19:37:30 <SamB_XP> dons: pirate pirate!
19:37:53 <FMota_> :o
19:38:11 <_achilles_> is there a way to cast a type in a where/let?
19:38:13 <FMota_> hey, it's proportional to the circumference too! ;o
19:40:05 <_achilles_> ?
19:40:06 <LoganCapaldo> _achilles_: you mean add type annotations?
19:40:14 <_achilles_> yeah
19:40:24 <pgavin> is there a purely functional computer architecture?
19:40:37 <LoganCapaldo> > let { foo :: Int -> Int -> Int ; foo x y = x +y } in foo 2
19:40:39 <lambdabot>  <Int -> Int>
19:40:45 <LoganCapaldo> > let { foo :: Int -> Int -> Int ; foo x y = x +y } in foo 2 3
19:40:47 <lambdabot>  5
19:40:59 <sorear> pgavin: No.  You would generate infinite amounts of garbage. :)
19:41:05 <LoganCapaldo> in other words, just like you would otherwise
19:41:06 <pgavin> lol
19:41:29 <pgavin> sorear: I think you could get close... at least on a small level
19:41:30 <LoganCapaldo> > let f = g where { g :: Int ; g = 3 } in f
19:41:31 <lambdabot>  3
19:42:11 <pgavin> if you took a normal risc isa and got rid of all the registers
19:42:17 <LoganCapaldo> you can use layout of course in an actual file
19:42:51 <_achilles_> ok...
19:43:03 <_achilles_> apparently that doesn't work for my case however
19:43:12 <dataangel> Why does List.insert put its argument before the first element which is greater than it? Coming from C++ that seems like odd behavior -- I'd expect you'd give an index for where to insert the element
19:43:27 <_achilles_> but the help is appreciated
19:43:30 <ddarius> :t insert
19:43:32 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
19:43:34 <TSC> insert means "insert into a sorted list"
19:43:45 <TSC> It's not a general "add to the list" function
19:43:56 <SamB_XP> @hoogle Int -> a -> [a] -> [a]
19:43:56 <lambdabot> No matches, try a more general search
19:43:57 <LoganCapaldo> _achilles_: what's the problem?
19:44:02 <SamB_XP> @hoogle a -> [a] -> [a]
19:44:03 <lambdabot> List.intersperse :: a -> [a] -> [a]
19:44:03 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
19:44:03 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
19:44:08 <dataangel> it's just called insert though
19:44:15 <TSC> Yes, as in insertion sort
19:44:22 <_achilles_> I'm looking to do: timeDiv n d = case n `mod` d of 0->1 + timeDiv (n/d) d; _ -> 0
19:44:28 <ddarius> dataangel: You, usually don't want to be inserting elements into the middle of lists.
19:44:36 <dataangel> true
19:44:39 <dataangel> not in haskell
19:44:44 * sjanssen laughs out loud at augustss's 'Haskell 2037' presentation
19:44:51 <wli> I've discovered that there is some interest in NIH'ing IMVU.
19:45:02 <_achilles_> looks like I want quot?
19:45:05 <LoganCapaldo> @type mod
19:45:07 <lambdabot> forall a. (Integral a) => a -> a -> a
19:45:12 <LoganCapaldo> @type (/)
19:45:13 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:45:19 <_achilles_> @type quot
19:45:21 <lambdabot> forall a. (Integral a) => a -> a -> a
19:45:31 <LoganCapaldo> or div
19:45:34 <LoganCapaldo> @type div
19:45:36 <lambdabot> forall a. (Integral a) => a -> a -> a
19:45:40 <_achilles_> ah
19:45:43 <_achilles_> mk
19:45:50 <wli> They may also be interested in using Haskell to speed up program development (they're largely content creators).
19:46:10 <LoganCapaldo> (IIRC div quot and rem / mod differ mainly in their behavior with negative numbers)
19:46:38 <LoganCapaldo> So you probably want to use quot and rem or div and mod but not mod and quot or rem and div
19:47:07 * LoganCapaldo thinks theres a divmod too
19:47:09 <jcreigh> oh, somebody had a good blog post on when to use one set over the other...lemme see if I can find it...
19:47:14 <LoganCapaldo> @hoogle divmod
19:47:14 <lambdabot> Prelude.divMod :: Integral a => a -> a -> (a, a)
19:47:21 <LoganCapaldo> @hoogle quotRem
19:47:21 <lambdabot> Prelude.quotRem :: Integral a => a -> a -> (a, a)
19:48:21 <hpaste>  chessguy pasted "first pass at a generalized class for an interpreter" at http://hpaste.org/3191
19:49:06 <jcreigh> here it is: http://praisecurseandrecurse.blogspot.com/2006/12/divisive-aftermath.html
19:49:08 <lambdabot> Title: Praise, Curse, and Recurse: The Divisive Aftermath, http://tinyurl.com/269574
19:49:10 <_achilles_> I'm planning to use divMod
19:49:20 <_achilles_> appreciate your help!
19:50:56 <chessguy> i wonder how restrictive this class will be in that the code and data types are the same
19:53:25 <chessguy> @seen sorear
19:53:25 <lambdabot> sorear is in ##logic, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell. I last heard sorear speak 7m 43s ago.
19:53:28 <sorear> ?
19:53:45 <chessguy> hey, you've written some interpreters, haven't you?
19:53:51 <sorear> yes
19:54:00 <halcyon10> @pl (\x -> (take 4 (show x))++" %")
19:54:00 <lambdabot> (++ " %") . take 4 . show
19:54:03 <chessguy> i'm curious what you'll think of my idea
19:54:21 <chessguy> i want to have a class like the one i just pasted, and then write a generalized REPL around it
19:54:37 <chessguy> so that writing an interpreter is as easy as implementing this class
19:55:26 <chessguy> so the scheme interpreter would be instantiating Interpret LispVal LispError
19:56:54 <chessguy> (the scheme interpreter from the 48-hour tutorial, that is)
19:59:23 <chessguy> heh. i've stunned him into silence with my brilliance
20:00:17 <sorear> :)
20:00:26 <dataangel> I have a function that takes a list and an integer. The function is only valid over a range that is a function of the length of the list. Is there a way to enforce (a C++ style runtime assertion?) this? I figure I add pattern matches for the invalid cases, but I'm not sure what to set the function to then
20:00:52 <dataangel> err, the function is only valid when its integer parameter is within a range that is a function of the length of the list :)
20:00:53 <wli> Yes
20:00:58 <sorear> I'm not too optimistic.  What if you have site effects?  What if your language isn't homoiconic?  What if evaluation can fail?
20:01:06 <wli> Check your assertion, use error when it fails.
20:01:11 <chessguy> what the heck is homoiconic?
20:01:34 <sorear> http://en.wikipedia.org/wiki/Homoiconicity
20:01:37 <Syzygy-> A weakening of isoiconic.
20:01:40 <Syzygy-> :)
20:01:52 <chessguy> right, ok
20:02:09 <chessguy> well, i could introduce a third type parameter into the class to handle that
20:02:10 <adamjones> dataangel: by "a function of the length of the list" do you mean within the 1..n bounds of the list or something else?
20:02:47 <chessguy> sorear, as for side effects, the scheme interpreter code allows for that
20:03:18 <sorear> chessguy: a -> a isn't good enough though.  LispVal -> LispVal has no side effects.
20:03:36 <FMota_> chessguy: Something along the lines of Freddie Mercury.
20:03:58 <chessguy> sorear, err, you're right, that type isn't right
20:03:58 <FMota_> Or Alan Turing.
20:04:03 * wli resembles that remark.
20:04:17 <sorear> chessguy: You're going to need to add more and more and more things to your class, to the point where I think you'd likely be better off with repl :: (String -> IO String) -> IO ()
20:04:51 <dataangel> adamjones: it's a list of lists representing a grid of squares, and its only valid over the outermost "border" of squares. So for a 3x3 grid, it's valid for 0-7 (eight squares surrounding the middle) and for a 4x4 grid it's valid for 0-11 (12 squares surrounding the inner four)
20:05:06 <dibblego> ?hoogle (Monad m) => ([a] -> b) -> m [a] -> m b
20:05:07 <lambdabot> No matches, try a more general search
20:05:20 <dino-> I was just looking for the Example link from the Haskell Home, the place where the source code for the Prelude and other basic things was. Has it moved?
20:06:28 <chessguy> sorear, fair enough. do you think the idea of a generalized REPL is worth pursuing in a different fashion?
20:06:31 <adamjones> dataangel: wli's suggestion would work pretty well.
20:07:14 <sorear> chessguy: maybe...
20:07:15 <wli> Anybody remember my suggestion about the fashion design assistant program?
20:07:36 <adamjones> nope.
20:07:48 <SamB_XP> sorear: uh, what about completion!
20:08:10 <dataangel> brb
20:09:03 <wli> Given that there's only one response and it's "no," I'll take that as "no one remembers and no one cares."
20:09:46 <ddarius> wli: I'm sure I didn't hear it at all and I don't care.
20:10:15 * Korollary pats wli's back
20:10:20 <Korollary> there there
20:10:51 <hpaste>  adamjones pasted "(no title)" at http://hpaste.org/3194
20:11:20 <adamjones> hmm, figures as soon as I contribute an answer the guy leaves.
20:12:06 <adamjones> oh well, I'm still claiming this as "I finally knew enough to answer a question about haskell." Yay me!
20:12:23 <dino-> Ah, Haskell Home Page history: 18:49, 4 October 2007 DonStewart (I don't think the example code page has value anymore)
20:12:28 <dino-> Well, boo.
20:12:30 <dino-> It had value to me.
20:12:49 <lament> was it positive?
20:13:20 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3195
20:13:36 <dino-> I understand it wasn't exactly the true source, but it was good to take a look at how some things were implemented.
20:14:05 <ddarius> dino-: Why not just look at the Report?
20:14:24 <dino-> ddarius: The report tells you the implementation of, say, reverse or foldl' ?
20:16:42 <ddarius> dino-: It has definitions for every function in the standard libraries that it could define.
20:17:30 <chessguy> it's not possible to define things like groups (in the abstract algebra sense) with type classes, is it?
20:17:34 <ddarius> dino-: If that's not enough, you can readily get the source of the actual libraries.
20:17:42 <ddarius> chessguy: No more than monads.
20:18:05 <gvdm> you need something between the scanner and printing (to decide what to print based on what was scanned)
20:18:09 <chessguy> ddarius, you mean the monad laws?
20:18:21 <ddarius> chessguy: Yes.
20:18:24 <dino-> ddarius: Ah, I see it. Thank you, I didn't know that was in there.
20:19:03 <ddarius> dino-: Also, every (or most?) pages in the hierarchical libraries have a Source Code link at the top that takes you straight to the source.
20:19:06 <gvdm> hmm, perhaps seeing that the scroll bar is not at the bottom before trying to reply to something would be an idea...
20:19:45 <ddarius> chessguy: You can easily write: class Group g where (*) :: g -> g -> g; e :: g; inverse :: g -> g
20:20:31 <ddarius> :t recip
20:20:37 <lambdabot> forall a. (Fractional a) => a -> a
20:20:38 <chessguy> so it's the axioms that they have to satisfy that's the problem
20:21:32 <chessguy> what if you could somehow attach QC properties to a class so that you could instantiate it and then check to see if it's valid
20:21:59 <chessguy> it wouldn't be a proof or a guarantee, but it would be a check
20:22:41 <ddarius> You could add some quickcheck properties as default class members.
20:23:26 <chessguy> it adds an Arbitrary requirement though
20:23:44 <chessguy> an arbitrary one at that :)
20:23:59 <dibblego> ?hoogle (a, a) -> [a] -> [a]
20:23:59 <lambdabot> No matches, try a more general search
20:24:02 <ddarius> chessguy: Everyone should be quickchecking all their code anyway!
20:24:06 <dibblego> ?hoogle a -> a -> [a] -> [a]
20:24:06 <lambdabot> No matches, try a more general search
20:24:45 <ddarius> chessguy: You could just have some properties in the module that you export.
20:25:32 <chessguy> but you still have no way of enforcing that instances pass the test
20:25:53 <ddarius> If you want that then you need to use a different language.
20:26:24 <chessguy> right, that's what i thought. i was just checking
20:28:15 <dino-> ddarius: Ya, hadn't thought of that either, the Source code link. Which even works using the locally-installed copy of the API docs on my system.
20:28:33 <chessguy> it still might be fun to write some classes for such algebraic structures, for instructive purposes
20:29:36 <Syzygy-> chessguy: One benefit of class Group as sketched above is that with a diagonal :: g -> (g,g) you actually have all you need for group objects in generic categories.
20:30:09 <chessguy> Syzygy-, i have no idea what that means
20:30:13 <dino-> I'm confused about something. I'm trying to hack some code that's got mplus being called with two IO actions as arguments. But I don't see the docs showing IO as being an instance of MonadPlus.
20:30:23 <Syzygy-> chessguy: In that case just ignore it.
20:30:24 <chessguy> Syzygy-, i don't know anything about abstract algebra
20:30:34 <Syzygy-> It's something cool from my corner of mathematics... :)
20:30:35 <chessguy> i would be doing this to learn along the way
20:30:46 <Syzygy-> A group is essentially a group object in the category of Sets.
20:30:46 <ddarius> @instances MonadPlus
20:30:51 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
20:31:07 <ddarius> Syzygy-: You own a corner of mathematics?
20:31:11 <Syzygy-> Whereas a ring is a Semigroup (or Monoid) object in the category of abelian groups.
20:31:31 <Syzygy-> ddarius: My corner of mathematics in the same sense of the word my as used in "my country" or "my neighbourhood"
20:31:33 <ddarius> chessguy: Maybe formalize these things in Agda or Yarrow or Coq or Isabelle/HOL or Alf or Twelf or ...
20:31:52 <Syzygy-> chessguy: Speaking of that ... http://blog.mikael.johanssons.org/archive/2007/08/coq-and-simple-group-theory/
20:31:55 <lambdabot> Title: Michi&#8217;s blog ª Blog Archive ª Coq and simple group theory, http://tinyurl.com/yvzdr7
20:31:58 <chessguy> ddarius, i've not even heard of most of those :)
20:32:03 <Syzygy-> You will recognize the beginning there.
20:32:20 <Syzygy-> chessguy: Most fo those are proof assistant systems.
20:32:32 <dino-> Huh. But I don't see it in the instances list here: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#t%3AMonadPlus
20:32:34 <lambdabot> http://tinyurl.com/y25qsm
20:32:38 <chessguy> Syzygy-, i guessed as much from the inclusion of Coq
20:32:52 <Syzygy-> Aaaaanyway. Take a look at my blogpost there.
20:32:56 <dino-> Where this is going is I don't understand what mplus means applied to IO actions.
20:33:24 <chessguy> @src MonadPlus
20:33:25 <lambdabot> Source not found. Wrong!  You cheating scum!
20:33:56 <allbery_b> @src IO mplus
20:33:56 <ddarius> dino-: Essentially catch
20:33:56 <lambdabot> m `mplus` n = m `catch` \_ -> n
20:34:16 * allbery_b *headdesk*
20:34:30 <allbery_b> I should be using that... was wondering how to clean that code up
20:35:22 <ddarius> I actually find that mildly ugly.
20:35:46 <Pseudonym> Well, it's an implementation.
20:35:52 <Pseudonym> You don't have to see it, exactly.
20:36:04 <allbery_b> hm, except I'm not sure when that hit the libs.  is it in 6.6.1?
20:36:14 <ddarius> That's been there for a long long time.
20:36:20 <allbery_b> ah
20:36:24 <chessguy> by the way, i heard today that lazy expressions are supposedly going to get added to javascript in the near future
20:36:47 * allbery_b has some places where he does an IO actuion and if it fails supplies a default.  mplus should clean those up nicely
20:39:43 <allbery_b> could even encapsulate it further:  flip mplus . return
20:41:05 <Syzygy-> :t flip mplus . return
20:41:13 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => a -> m a -> m a
20:41:17 <kpreid> allbery_b: I think that pointfreeness is obfuscatory
20:41:58 <Pseudonym> Sometimes it is, sometimes it isn't.
20:42:10 <Pseudonym> Pointfreeness does help you avoid names for things that don't need names.
20:42:13 <kpreid> that's why I said "that".
20:42:13 <chessguy> @pl \x y -> x + y -- hardly obfuscatory
20:42:13 <lambdabot> (+)
20:42:21 <Pseudonym> On the other hand, it avoids names for things that should have names.
20:42:22 <kpreid> Oh, sorry.
20:42:30 <kpreid> I think that *that* pointfreeness is obfuscatory.
20:42:46 * kpreid grumbles at English.
20:43:07 * nornagon does likewise.
20:43:23 <chessguy> @pl \m n -> c m \_ -> n
20:43:23 <lambdabot> (line 1, column 13):
20:43:23 <lambdabot> unexpected "\\"
20:43:23 <lambdabot> expecting variable, "(", operator or end of input
20:43:45 <chessguy> @pl \m n -> m `c` \_ -> n
20:43:45 <lambdabot> (. const) . c
20:44:00 <allbery_b> keep in mind that occurs only once (think withDefault val $ (some IO action))
20:44:24 <Pseudonym> @pl \c m n -> m `c` \_ -> n
20:44:24 <lambdabot> flip flip const . ((.) .)
20:44:45 <allbery_b> a comment will deal well enough, or I can expand it but I'm not sure (f `mplus` return dft) is that much better
20:45:07 <ddarius> (`mplus` return default)
20:46:32 <ddarius> What's a good Haskell Workshop video besides the Harpy one, the Debugger one, the HPC one or the Beauty in the Beast one?
20:47:52 <allbery_b> ddarius: that's even worse :)
20:48:06 <dino-> Does that mean (above with the `catch`) if m results in mzero, it will go on to execute n ?
20:48:34 <dino-> referring to: m `mplus` n = m `catch` \_ -> n
20:49:11 <allbery_b> yes.
20:49:16 <allbery_b> @src IO mzero
20:49:16 <lambdabot> mzero       = ioError (userError "mzero")
20:49:29 <dino-> Man, I wish that was in the HTML docs. :o
20:49:50 <allbery_b> any I/O error is effectively mzero, so mplus gives you a convenient way to catch the error and supply a default
20:51:19 <dino-> ddarius, allbery_b: Ok, thank you.
20:54:51 <dataangel> If I want to list-ify all of the elements of a list, is this the best way to do that?: [ [elem] | elem <- mylist ]
20:55:27 <TSC> map return
20:55:35 <glguy> dataangel: your way is fine
20:55:48 <glguy> map return , map (:[]) work too
20:55:51 <TSC> map (:[]) is common too
20:56:10 <glguy> dataangel: but since elem is a function in the Prelude
20:56:15 <glguy> you'd be better off not shadowing it
20:56:28 <dataangel> k
20:56:34 <TSC> It's a shame there's no "singleton" function, like Data.Set.singleton
20:57:33 <nornagon> return and :[] are the singleton functions :)
20:57:41 <TSC> Yeah, but with that name
20:57:47 <Pseudonym> Why?
20:57:50 <nornagon> ?let singleton = return
20:57:51 <lambdabot> <local>:2:12:     Ambiguous type variable `m' in the constraint:       `Monad...
20:57:56 <nornagon> ?let singleton = return :: [a]
20:57:57 <lambdabot> Couldn't match expected type `[a]'
20:58:04 <Pseudonym> The operation is usually called "box", BTW.
20:58:16 <Pseudonym> Though (:[]) is pronounced "the robot ninja monkey operator".
20:58:23 <nornagon> haha
20:58:24 <nornagon> ?let singleton = (:[])
20:58:25 <glguy> ?let singleton = return :: a -> [a]
20:58:26 <lambdabot> Defined.
20:58:26 <lambdabot> <local>:3:0:     Multiple declarations of `L.singleton'     Declared at: <loc...
20:58:31 <glguy> heh
20:58:34 <nornagon> beatcha!
20:58:39 <nornagon> > singleton 3
20:58:40 <lambdabot>  [3]
20:59:00 <glguy> nornagon: looks like it used *my* version
20:59:03 <glguy> ;)
20:59:23 <kig> do any haskell gui toolkits assert at compile-time that e.g. initGUI is called before mainGUI?
20:59:44 <nornagon> glguy: not from here...
21:00:43 <glguy> They are playing a documentary about meth on every channel here
21:01:20 <Pseudonym> It's the meth channel!  All meth, all the time!
21:01:37 <Pseudonym> That's from the Robert Crumb version of Elmo's World.
21:02:55 <allbery_b> kig: you can't at compile time, unless the toolkit has its own monad and initGUI is really withGUI $ gui-using-code
21:07:57 <glguy> I switched to a different channel and they have a show on called "Jail"
21:08:14 <glguy> like cops, but just the part where they put people in jail
21:08:31 <glguy> I guess this is what you get when you don't pay for cable..
21:08:42 <wli> Well, in the US, such a large fraction of the population goes to jail that it's a shared experience.
21:08:59 <ddarius> You've gone to jail wli?
21:09:06 <Pseudonym> glguy: No, it's what you get when you don't live on another continent.
21:09:24 <Pseudonym> ddarius: No, but he was involved in a Milgram experiment.
21:09:27 <glguy> and you are groomed to think that's ok from an early age, think monopolly "go directly to jail, do not pass go, do not collect $200"
21:09:44 <glguy> Monopoly*
21:09:46 <wli> ddarius: No.
21:10:26 <wli> ddarius: But look for statistics on the subject some time, esp. those comparing them between contries.
21:11:05 <ddarius> wli: You feel you have the experience of going to jail?
21:11:13 <wli> ddarius: No.
21:11:40 <Pseudonym> Hey, nobody here knows anything about it.  You know what that means... Uninformed Opinion Time!
21:12:26 <Pseudonym> Well _I_ think some time in jail is character-building.  Except for me, of course.
21:13:59 <ddarius> Well -I- think some time in jail would lead to the revocation of my clearance, so I'll refrain.
21:14:46 <Pseudonym> Ah, but what if it was time in an enemy jail for espionage?
21:14:53 <wli> Compare the fraction of the population incarcerated between countries.
21:15:06 <ddarius> Pseudonym: My clearance would at least be suspended for that.
21:15:18 <lament> spending time in jail certainly does little good to your employability.
21:15:55 <reffie> #haskell-blah
21:16:05 <Pseudonym> Good point.
21:16:09 <Pseudonym> Or just stop.
21:16:12 <ddarius> Sleep.
21:18:26 <glguy> reffie: you have to type /join first
21:18:41 <reffie> ?
21:19:17 <sjanssen> glguy: reffie wasn't trying to get to the OT channel, he was trying to send you there! :P
21:19:26 <glguy> </sarcasm>
21:21:12 <dmwit> sjanssen: Yeah, IRC needs a /send command.
21:21:28 <sorear> it exists
21:21:30 * sorear demos
21:22:41 * dmwit doesn't notice anything different
21:23:05 <sorear> hmm. apparently it doesn't work if you're already there?
21:23:23 * sorear tries it on glguy
21:23:23 <glguy> sorear: are you talking about /invite?
21:23:44 <sorear> yes
21:23:45 <dataangel> What's the preferred way to strip off the first and last elements of a list? I've written my own func but I dunno if there's something nicer builtin
21:23:57 <sorear> init.tail
21:26:36 <bos> > (init.tail) []
21:26:38 <lambdabot>  Exception: Prelude.tail: empty list
21:26:47 <dmwit> > init . drop 1 $ []
21:26:48 <lambdabot>  Exception: Prelude.init: empty list
21:26:57 <bos> ah, partial functions, how we love thee
21:27:08 <dmwit> > drop 1 . reverse . drop 1 . reverse $ []
21:27:09 <lambdabot>  []
21:27:14 <dmwit> =P
21:27:28 <sproingie> @pl  init . drop 1 $ []
21:27:29 <lambdabot> init (drop 1 [])
21:27:35 <sproingie> meh
21:27:39 <chessguy> err, do you need to reverse it twice?
21:27:47 <dmwit> yes?
21:27:56 <glguy> chessguy: to maintain the order
21:28:00 <chessguy> oh, right
21:28:07 * chessguy shuts up
21:28:23 <chessguy> @pl \xs -> init . drop 1 xs
21:28:23 <lambdabot> (init .) . drop 1
21:28:33 <chessguy> sproingie, i think that's what you were looking for
21:28:37 <glguy> nope
21:28:39 <sproingie> there we go
21:28:40 <chessguy> err
21:28:54 <chessguy> @pl \xs -> (init . drop 1) xs
21:28:54 <lambdabot> init . drop 1
21:28:57 <dmwit> ?pl \xs -> init . drop 1 $ xs
21:28:57 <lambdabot> init . drop 1
21:29:18 <chessguy> @type (init .) . drop 1
21:29:20 <lambdabot>     Couldn't match expected type `a1 -> [a]'
21:29:21 <lambdabot>            against inferred type `[a2]'
21:29:23 <sproingie> that one was pretty obvious
21:29:25 <chessguy> nice
21:31:29 <badkins> Is there something I can do to get ghci to work more similarly to ghc? In other words, in other REPL's I'm familiar with, I can feed them input similar to what I'd feed the compiler/interpreter, but ghci seems quite different. I've been able to placate it by prefixing let in places, but I'm sure there's a better way.
21:31:52 <bos> no, you can't
21:31:59 <dmwit> badkins: Write a file, and load it with : repeatedly.
21:32:09 <badkins> you're serious??
21:32:16 <sjanssen> badkins: yes
21:32:20 <badkins> rats :(
21:32:45 <badkins> thx for the info. I guess I've been spoiled with irb and clisp
21:32:48 <sjanssen> badkins: Haskell is hard to parse and interpret incrementally
21:32:51 <sproingie> emacs has a haskell-mode
21:33:09 <chessguy> emacs' haskell mode isn't too bad
21:33:24 <sproingie> you can reload the buffer with a key
21:33:27 <badkins> I'm a vim guy, but I'll keep an open mind if it makes Haskelling easier
21:33:37 <chessguy> well, two keys
21:33:37 <dd> all this fuss about no shared state and you cant inject new functions into a runtime?
21:33:37 <sproingie> shouldn't be too hard to do something in vi
21:33:42 <dmwit> badkins: There's some nice vim things, too.
21:33:42 <sproingie> someone might have already written it
21:33:45 <chessguy> C-c C-r
21:33:54 <dmwit> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
21:33:56 <lambdabot> Title: Haskell mode for Vim
21:33:56 <sjanssen> badkins: two terminals with ghci and vim works well for me
21:34:05 <sjanssen> badkins: so emacs isn't required by any means :)
21:34:06 <sproingie> i always remap those C-c prefixed commands to something else
21:34:13 <sproingie> well the common ones anyway
21:34:14 <badkins> I wonder if I have that already, at least it does syntax highlighting.
21:34:37 <dmwit> No, this is more than syntax highlighting.
21:34:42 <badkins> ok
21:34:43 <sproingie> two terminals is good too, not too hard to hit up-arrow and enter to reload
21:34:57 <dmwit> badkins: It can create type declarations for you and do some minor introspection.
21:35:00 <sjanssen> sproingie: or even : and enter
21:35:49 <dmwit> badkins: It also knows enough about GHC to jump to the position of errors (which is more useful than it sounds like it should be).
21:37:07 <badkins> Here's another newbie question. Prior to being exposed to Haskell, I was all set to learn Scheme followed by Lisp (I'm a Ruby programmer). After browsing through the Haskell School of Expression the other day, I'm really tempted to learn Haskell first. I'm sure I'll learn all 3 eventually - can anyone who knows Lisp & Haskell comment on a preferred order for ease of learning Lisp -> Haskell vs. Haskell -> Lisp ?
21:37:22 <sproingie> we're partial to haskell :)
21:37:29 <dmwit> ?quote lisp
21:37:29 <lambdabot> qwe1234 says: every half-assed dynamically-typed, ass-slow scripting language is Lisp but a bit different
21:37:33 <dataangel> alright, I must be stupid, but no matter of googling is helping me find the difference between (.) and ($)
21:37:35 <dmwit> ?quote lisp
21:37:35 <lambdabot> qwe1234 says: sometimes i think lisp is as deadly to programmer competence as java or basic.
21:37:48 * dataangel doesn't know how to search for symbols correctly
21:37:53 <dmwit> :t (.)
21:37:54 <dmwit> :t ($)
21:37:57 <TSC> dataangel: (.) composes functions; ($) applies functions to arguments
21:37:59 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:37:59 <lambdabot> forall a b. (a -> b) -> a -> b
21:38:00 <sjanssen> dataangel: (function1 . function2) vs. (function1 $ argument1)
21:39:02 <dataangel> sjannsen: err, what's the difference between function1 $ argument1 and function1 argument1?
21:39:09 <chessguy> Warning, completely off topic: http://xkcd.com/327/
21:39:10 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
21:39:12 <sjanssen> dataangel: none
21:39:23 <badkins> Yeah, I'm sure you're partial to Haskell, that's why I didn't ask a "which is better" question. I was just curious if there would be a natural order i.e. if one direction would have a natural progression of concepts.
21:39:28 <dataangel> sjanssen: Then there must be a little more to it, or that is a totally useless operator ;p
21:39:38 <sjanssen> dataangel: it's a precedence hack
21:39:39 <blackdog_> i think it's easiest to think of $ as a grouping operator
21:39:47 <blackdog_> what sjanssen said
21:39:52 <smack__> dataangel: function1 $ function2 argumentToFunction2
21:39:58 <sjanssen> dataangel: you can replace (f (g x)) with (f $ g x)
21:39:58 <dmwit> ?quote #lisp
21:39:59 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
21:40:01 <dmwit> hee-hee!
21:40:38 <TSC> dataangel: $ is also useful for sections (e.g. map ($5) [f1, f2, f3])
21:40:40 <sproingie> everything after the $ is effectively in parens
21:41:03 <dataangel>  I see
21:41:21 <dataangel> So is there any diff between f . g x and f $ g x?
21:41:23 <sproingie> i often find myself wishing other languages had a $ operator
21:41:23 <sjanssen> TSC: pssh, obviously you use flip sequence 5 instead :P
21:41:35 <sjanssen> dataangel: yes, there is a difference
21:41:51 <sjanssen> dataangel: f . g x == \y -> f (g x y)
21:41:52 <dmwit> f . g x = \y -> f (g x) y
21:42:03 <dmwit> f $ g x = f (g x)
21:42:29 <sjanssen> @unpl f . g x
21:42:29 <lambdabot> (\ c -> f (g x c))
21:42:33 <dmwit> Oh, sjanssen's right.
21:42:52 <dataangel> err, so it thinks you're doing f . (g x) ?
21:43:10 <TSC> But f $ g x is equivalent to (f . g) x, right?
21:43:14 <sjanssen> dataangel: f . g x and f . (g x) are the same thing
21:43:16 <sproingie> generally speaking, $ is for application, . is for composition
21:43:27 <badkins> @lambdabot: you're not quite getting it, it's either a then b or b then a not a or b
21:43:27 <lambdabot> Unknown command, try @list
21:44:05 <dataangel> sjanssen: I guess I'm still confused then. I don't understand why it becomes a new function that thinks g takes another parameter.
21:44:07 <dmwit> badkins: uh?
21:44:27 <sjanssen> dataangel: look at the type:
21:44:29 <sjanssen> @type (.)
21:44:31 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:44:39 <sproingie> that's currying for you
21:44:46 <sjanssen> dataangel: takes two functions, and produces a function
21:44:50 <sjanssen> @type ($)
21:44:50 <dataangel> sjannsen: Right
21:44:52 <lambdabot> forall a b. (a -> b) -> a -> b
21:45:15 <sjanssen> $ takes a function and a value, and yields the result of applying that value to the function
21:45:20 <cognominal_> @src init
21:45:20 <lambdabot> init [x]    = []
21:45:20 <lambdabot> init (x:xs) = x : init xs
21:45:20 <lambdabot> init []     = undefined
21:45:20 <dataangel> sjannsen: So f . g x should take f, take g, make a new function (composition) and apply x to it.
21:45:36 <TSC> That would be (f . g) x
21:45:37 <sjanssen> dataangel: no, it doesn't parse that way
21:46:08 <sjanssen> dataangel: (f . g x) parses as (f . (g x)).  It does *not* parse as ((f . g) x)
21:46:13 <dataangel> sjanssen: ah
21:46:43 <dataangel> sjannsen: But (f $ g x) and ((f . g) x) would be the same?
21:46:52 <sjanssen> dataangel: application (which is whitespace) binds tighter than any operator
21:46:59 <sjanssen> dataangel: yep, those are the same
21:47:07 <dataangel> sjannsen: guess that makes sense :)
21:47:22 <sproingie> think of $ as application, but binding more loosely than anything else
21:47:34 <dmwit> dataangel: and application (which is $) binds looser than any operator.
21:47:39 <dmwit> ;-)
21:48:06 <sjanssen> (it's also infixr instead of infixl, but that's another matter)
21:48:14 <dmwit> It shouldn't be.
21:48:25 <Syzygy-> I'm getting tempted to write a module for euclidean construction in either Haskell or Coq.
21:48:36 <Syzygy-> Should get my ass back to research work instead though...
21:48:37 <sjanssen> damnit, the parentheses were supposed to avoid this old argument! :)
21:55:43 <badkins> dimwit: ah, it took me a while
22:04:20 <bos> http://programming.reddit.com/info/2yj08/comments
22:04:21 <lambdabot> Title: Using Emacs to remove some of the drudgery of Haskell leak hunting (reddit.com)
22:05:06 <chessguy> hm, now that sounds interesting
22:06:26 <badkins> > reverse "?olleh"
22:06:28 <lambdabot>  "hello?"
22:06:51 <chessguy> bos++ nice one
22:08:25 <badkins> > map reverse ["olleH", "!dlrow"]
22:08:26 <lambdabot>  ["Hello","world!"]
22:11:46 <badkins> > sum [sum [1..5] .. sum [1..10]]
22:11:47 <lambdabot>  1435
22:12:15 <badkins> cool, a replacement for ghci
22:12:35 <Korollary> you can run lambdabot locally as well
22:12:49 <badkins> why?
22:13:53 <Korollary> people use some of its features for development, such as @pl, @src, etc.
22:14:11 <badkins> interesting
22:14:56 <dmwit>  ?hoogle is also very nice
22:15:35 <badkins> Haskell plus Google ?
22:15:57 <Korollary> ?hoogle a -> a
22:15:58 <lambdabot> Prelude.id :: a -> a
22:15:58 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
22:15:58 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
22:16:19 <Korollary> search based on type signature
22:16:23 <Mr_Awesome> is it possible to have a variant with type different type variables in each case?
22:16:49 <opqdonut> well you can have something like data Maybe a b = Left a | Right b
22:17:25 <bos> more commonly known as Either a b
22:17:29 <Mr_Awesome> heh
22:18:26 <opqdonut> ah yes
22:18:33 <opqdonut> blame it on the morning
22:19:53 <Mr_Awesome> well im trying to do something like this: data X a b = F (a -> b) | G (a -> c, c -> b), but apparently its impossible to get a type like that in haskell
22:20:09 <sorear> what's c?
22:20:32 <sorear> you need to give bindings for all variables
22:20:51 <opqdonut> yeah, you need to either have "X a b c" or use forall x.
22:20:51 <Mr_Awesome> i know, but c can just be anything
22:21:00 <sorear> maybe you meant an existential, like data X a b = F (a -> b) | forall c. G (a -> c, c -> b) ?
22:21:00 <opqdonut> then use forall
22:21:13 <sorear> think about what type you want for G
22:21:20 <Mr_Awesome> oh, is that how you do it?
22:21:27 <sorear> G :: (a -> c, c -> b) -> X a b -- with the forall
22:21:34 <sorear> G :: (a -> c, c -> b) -> X a b c -- with the parameter
22:21:35 <sorear> etc
22:21:38 <Mr_Awesome> thats definitely the type i want
22:21:50 <Mr_Awesome> X should not know the intermediate type in G
22:22:00 <Mr_Awesome> thanks
22:22:50 <sorear> also look into GADT syntax, which lets you write the constructor types you want - often much more intuitive than the current layer cake of position-sensitive modifiers
22:23:21 <sorear> (you don't pay for GADTs unless you make essential use of the flexibility, so go ahead and use where-syntax for normal types)
22:24:32 <Mr_Awesome> ok, ill look into i
22:24:34 <Mr_Awesome> *it
22:24:54 <Mr_Awesome> is it possible to restrict the a and b to be certain types for a variant of X ?
22:25:19 <sorear> ... yes
22:25:21 <sjanssen> Mr_Awesome: yes, this is the 'G' in GADT
22:25:48 <Mr_Awesome> so i should basically just use GADT
22:26:25 <sorear> Mr_Awesome: Why do you want to restrict a and b?
22:27:08 <Mr_Awesome> for one of the variants, a and b should only be able to be certain types
22:27:43 <Mr_Awesome> but for the other variants, they can be anything
22:33:36 <badkins> I've been reading up on the value of Haskell's type system. My exposure to static typing is C++/Java, so I was thrilled when I moved to Ruby. I'm getting the impression that Haskell's type system is quite different and I shouldn't be too influenced from my C++/Java experience. Fair assessment?
22:34:08 <sarehu> badkins: yes
22:34:43 <sarehu> badkins: you will find Haskell's to be much more frustrating!  And much more liberating...
22:35:05 <badkins> interesting juxtaposition
22:35:26 * serishema smirks
22:35:45 * serishema until recently said that haskell was incomprehensible goblydegook, or a form of encryption.
22:37:20 <badkins> Any satisfied customers here from a dynamically typed language background? Difficult transition?
22:37:53 <sarehu> I had same background as you; don't remember the transition
22:38:12 <twifkak> i'm mid ruby->haskell transition
22:38:13 <encryptio> i was (and still am) a Perl guru, haskell took a long time to grasp
22:38:38 <encryptio> but the type system had nothing to do with the mental issues i was having
22:38:47 <twifkak> 1. it's true, you don't have to annotate types all the time in haskell
22:39:19 <twifkak> 2. for practical purposes, you tend to do it at the function level
22:39:34 <sarehu> the top-level definition level
22:40:06 <twifkak> 3. despite (or maybe because of?) the magic auto-inferencing, you'll still fight the compiler from time to time
22:40:24 <twifkak> 4. only in haskell, you /get/ something for it -- type safety really is safe
22:40:32 <opqdonut> you only fight the compiler when you think it's wrong and you're right
22:40:42 <opqdonut> :)
22:41:04 * serishema is investigating haskell as an alternative to php
22:41:12 <badkins> I had a BASIC->Assembler->C->C++->Java->Ruby, so Haskell would be continuing forward on the functional dimension, but backwards on the static->dynamic dimension. I'm just trying to get a feel for what the static typing is buying me besides having the compiler catch errors since that simply hasn't been a problem with Ruby.
22:41:16 <twifkak> also, all the cool ruby things like closures, haskell has exponentially more of
22:41:48 <twifkak> so it doesn't feel ridiculously verbose like java (quite the opposite)
22:41:51 <Tela> I found that, for some time, you can nearly pretend Haskell is dynamic. Then you hit the edge cases and once you learn enough to debug them you realize that it's really pretty smart to have types work like they do.
22:41:59 <badkins> What hooked me while browsing SOE was the beauty of function composition. Quite nice.
22:42:46 <badkins> ***serishema: are you serious about alternative to php? that seems like quite a jump! Deployment alone sounds painful.
22:42:46 <twifkak> badkins: perhaps an interesting example of a use for static typing is QuickCheck
22:43:05 <encryptio> I found that the type system never got in the way of me wanting to do what i wanted, and later found out how cool it was.
22:43:22 <encryptio> er, 'doing what i wanted'
22:43:33 <bos> twifkak: you're aware that there are QuickCheck implementations for dynamically typed languages, yes?
22:43:44 <twifkak> bos: no, i'm not
22:43:48 <Shimei> When using dynamic languages, like Ruby, I found the lack of types more confusing than worth it. I still like Ruby for other reasons though.
22:43:55 <bos> http://www.cs.chalmers.se/~rjmh/ErlangQC/
22:43:57 <lambdabot> Title: Erlang QuickCheck
22:43:58 <Shimei> *lack of static typing
22:44:02 <serishema> badkins: i really hate php
22:44:18 <encryptio> serishema: what language(s) do you like?
22:44:21 <serishema> badkins: staticly compile, dump in the cgi-bin directory, i don't see the issue with deployment
22:44:34 <encryptio> eheh...
22:44:41 <twifkak> bos: interesting, i'll look :)
22:45:16 <twifkak> in any case, i think it still applies -- QC automatically polymorphs on the statically inferred type of the function you pass it, and determines what random crap to throw at your function
22:45:25 <badkins> serishema: I can understand hating php, but it seems unlikely that you'll find a Haskell equivalent.
22:45:57 <serishema> badkins: there seem to be Network.CGI and Text.XHtml packages that can do what i want?
22:46:23 <encryptio> in a VERY different way
22:46:24 <sjanssen> hmm, how does this Erlang thing work?
22:46:30 <serishema> encryptio: for web programming i'm used to asp .net. I like things that abstract all the CGI / HTML rubbish.
22:46:31 <sjanssen> explicit types for the generators?
22:46:48 <badkins> serishema: php is fast because mod_php runs in Apache. If you simply use Haskell as a cgi script, it'll be *way* slow
22:47:07 <opqdonut> not necessarily
22:47:13 <opqdonut> compiled vs. interpreted
22:47:15 <serishema> badkins: it's only an assignment, i don't care about real world performance.
22:47:42 <serishema> apparently there is FastCGI or something where it stays loaded.
22:47:47 <opqdonut> yeah, i've been planning on doing my "database application project" (really web programming...) in Haskell too
22:47:58 <opqdonut> yeah Fastcgi is nicer with haskell
22:48:08 * twifkak is waiting for somebody to mention HappS
22:48:13 <opqdonut> you don't have to worry about efficiently storing state so much
22:48:17 <dataangel> I'm doing [ fst full ++ snd full | full <- zip inner outer] where outer and inner are lists of lists, and outer always has 1 more list than inner. Is there an elegant way to append the last list in outer to this comprehension?
22:48:37 <badkins> opqdonut: even with a compiled app, cgi is not the way to go
22:49:03 <Tela> I've heard people critique HAppS pretty hard. I haven't really spent enough time with it to know. Is it nice?
22:49:06 <quicksilver> badkins: sure enough, but still the speed will be much less of an issue
22:49:28 <twifkak> sjanssen: judging from the first few pages, it's using erlang's pattern matching to specify input types
22:49:30 <badkins> well if folks are just talking about school assignments, then sure. I do this for a living, so it's a tad different.
22:49:37 <quicksilver> badkins: the main problem with CGI was perl scripts which took 2 seconds to load all their modules each time you ran them :)
22:49:47 <sjanssen> dataangel: zip (inner ++ []) outer -- hackish, but it will work
22:49:51 <twifkak> Tela: i have no idea -- i haven't heard much about it actually :/
22:49:58 <quicksilver> badkins: compared to that a compiled haskell app launches instantly...
22:50:05 <sjanssen> dataangel: also, note that you can rewrite that as (zipWith (++) inner outer)
22:50:06 <smack__> dataangel: zipWith (++) inner outer
22:50:31 * dataangel looks up zipWidth
22:50:40 <flux-_> badkins, not every, even professional, web service needs high throughput - internal software, which is the majority of written software [citation needed ;)], might not have too many simultaneous users
22:50:42 <smack__> @type zipWith
22:50:44 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
22:51:13 <sjanssen> twifkak: I'm not up on Erlang, what is the significance of ? in ?FORALL?
22:51:29 <badkins> quicksilver: and db connection pooling, etc. ? The difference between theory and practice is much greater in practice than in theory.
22:51:35 <twifkak> sjanssen: dunno :)
22:51:51 <quicksilver> badkins: not every web application needs a database :)
22:52:00 <badkins> right ;)
22:52:16 <quicksilver> badkins: but yes, there may be other resources which take time to acquire, I agree
22:52:36 <dataangel> sjannsen: zipWith works :)
22:52:38 * quicksilver knows whereof he speaks. He's been writing web applications on and off since 1994
22:52:48 <twifkak> i think what quicksilver meant to say was "not every web application needs a *relational* database"
22:52:50 <dataangel> sjannsen: I still have the problem though of tacking the extra element in outerDiag on to the end though
22:52:53 <badkins> quicksilver: in Haskell? :)
22:53:02 <dataangel> sjannsen: err, nm, get your trick now
22:53:05 <sjanssen> ah yes, page 8 finally tells me what I want to know: the generator is an explicit argument to FORALL
22:53:31 <dataangel> sjannsen: I think a lot of this feels hackish sinces I'm using lists to represent a rigid square grid (more like an array :P)
22:53:34 <sjanssen> not quite as nice as Haskell, where the generator is implicit, but workable
22:53:35 <badkins> I'm sure an excellent Haskell web framework can be invented, but it seems like Python before Django/Turbogears and/or Ruby before Rails currently.
22:54:00 <quicksilver> badkins: no, back in 1994 it was perl4 and CGI all the way :)
22:54:24 <quicksilver> badkins: and if things were too slow we rewrote them in C! Yay!
22:54:49 <twifkak> sjanssen: perhaps ? is a "adverb" on a predicate to mean "return a boolean" rather than "abort if false"?
22:55:06 <quicksilver> badkins: But, anyhow, there is hAppS and Hope, which are interesting in different ways
22:55:17 <sjanssen> lol, page 9 invents the Gen Monad with Erlang macros ;)
22:55:34 <Tela> Ooh. I hadn't heard of Hope before...
22:55:45 <badkins> quicksilver: probably as interesting as the Lisp stuff I dug up. yes it's used in production by a few folks, just not quite ready to abandon Rails for yet.
22:56:01 <quicksilver> badkins: of course very few people are using haskell for web apps, either as a proportion of haskell users or of web-app writers
22:56:07 <quicksilver> very very few
22:57:45 <badkins> right. My current research into Scheme,Lisp,Haskell, etc. is for *way* down the road. One *big* plus with Haskell I see is ghc. The open source Lisp compiler market is fragmented and struggling. ghc seems to be a very nice compiler and the fact that it stands out as the leading one should attract more development resources.
22:58:22 <quicksilver> I have little doubt that haskell is an excellent language for web application development
22:58:27 <quicksilver> in fact, I have no doubt at all
22:58:39 <quicksilver> but it doesn't have library maturity in that area yet
22:58:47 <badkins> agreed
22:58:52 <quicksilver> so you'd end up writing (partly) your own libraries on the way
22:59:15 <Korollary> I don't think any language is incapacitated for web apps by its own very nature. It's all about libraries.
22:59:33 <quicksilver> Korollary: right, but some languages are pretty poor for it. Like C.
22:59:43 <badkins> that's why it's a future oriented task for me, in the short run there would be a loss of productivity, but with a language that is productive enough, it would be recouped later (in theory)
23:00:25 <badkins> Korollary: to some degree yes, but some languages are worth a long term commitment in library development
23:00:28 <quicksilver> empirically haskell lets me (makes me?) write code with fewer bugs, and easier to refactor without introducing bugs
23:00:45 <quicksilver> that alone is a good reason to find it interesting
23:01:15 <newsham> I'm watching lectures from Haskell Workshop 2007.  are the papers also available online?
23:01:51 <Tela> I had an interesting experience several hours ago where I did a major refactor of structure of my code. I just changed the most relevant part then let the type-checker tell me all the places that broke. Refactored in like 20 seconds :)
23:03:30 <quicksilver> Tela: yes, I was talking about that yesterday
23:03:40 <badkins> Tela: that's something I was used to doing in the Java world and thought I would miss. So far (18 months) I haven't missed it in Ruby, but I can see how I might possibly get bit by a refactoring at some point (I'm far from 100% test coverage).
23:03:56 <quicksilver> Tela: really striking. If code works before, and you refactor something, then by the time it compiles again, it works again
23:04:26 <badkins> quicksilver: assuming no semantic changes from refactoring ;)
23:04:29 <quicksilver> badkins: yes, it's true that Java is so cumbersome you are forced to refactor *often* which makes tool support for refactoring feel really important
23:04:49 <quicksilver> badkins: right, it's not some magic rule. But in practice if you're using the type system well, it seems to guide you correctly
23:05:21 <badkins> quicksilver: I don't miss all the tools! It's been wonderful only needing vim :)
23:07:09 <badkins> quicksilver: did you try other functional languages prior to Haskell, or come directly here?
23:07:35 <sjanssen> I don't think I could ever get used to a dynamic language.  How do people cope when simple misspellings are run-time errors?
23:08:13 <Tela> I had done some large ruby refactors before that I couldn't work through. Generally, it led to complete rewrites on large sections of code. I'm not all that familiar with other static typed languages, so when things like that work in Haskell, I get ecstatic
23:08:13 <badkins> sjanssen: it happens, but it's rare and quickly caught - things tend to not pass tests when they aren't spelled correctly :)
23:09:00 <quicksilver> sjanssen: well at least perl has 'use strict' which catches most mis-spellings and you're a fool if you don't use it. I imagine the others have similar.
23:09:16 <quicksilver> badkins: I have used a couple of varieties of ML
23:09:25 <quicksilver> badkins: I've played with lisps, but never used them for anything serious
23:10:08 <Tela> Lisp... If you want to talk about crippled libraries...
23:11:55 <badkins> Tela: I do find it odd that some very capable languages have poor library support. It doesn't seem like time is the main impediment. Maybe the programmers that are attracted to such languages aren't interested in library development.
23:12:52 <Tela> badkins: concerning Lisp, I feel like it's in the culture of the language. Everyone wants to do things their own way, so collaborative efforts are terribly scattered and redundant
23:13:34 <badkins> Tela: how is the situation for Haskell? I would think it might be similar - intelligent, independent programmers, etc.
23:14:35 <Tela> I'm always reassured by the strength of ghc. There are a lot of language extensions which are well supported because of it being fairly ubiquitous
23:14:47 <badkins> Tela: I don't mind writing a ton of internal code, but I'd prefer to avoid the external facing stuff: relational db libraries, network protocols, foreign function interfaces, etc.
23:15:28 <quicksilver> the haskell library situation is in a period of rapid growth
23:15:38 <quicksilver> the rate of haskell library release in teh last 12 months has been impressive
23:16:04 <quicksilver> http://hackage.haskell.org/packages/archive/pkg-list.html
23:16:05 <badkins> Functional languages are getting a big boost, and I expect that to continue indefinitely.
23:16:14 <quicksilver> (indeed, not everything is in that list but it's a good start)
23:16:21 <badkins> 'hackage' what a great name :)
23:16:47 <Korollary> There are a lot of perl modules that implement the same thing. Eventually, one of them wins out. It's a numbers game.
23:18:35 <badkins> You guys have been helpful. Before I take off, any book recommendations? I think I'll pick up "The Haskell School of Expression". Any others that come highly recommended?
23:19:32 <Tela> Not a book, but I had the biggest "clicking" moment when reading Write Your Own Scheme in 48 Hours
23:19:40 <Tela> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
23:19:42 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
23:20:00 <Pseudonym> ?quote brain-dead
23:20:00 <lambdabot> Pseudonym says: The Scheme programming language is optimised for writing small brain-dead tutorial compilers for.
23:20:25 <Tela> I liked it as a Parsec example :)
23:20:28 <badkins> Tela: thanks for the link
23:21:08 <badkins> it's been del.icio.us'ified
23:21:17 <bos> wow, we're almost to 2100 comments on the first 4 chapters of the book.
23:21:52 * sorear derived a great deal of enlightenment from The_Implementation_of_Functional_Programming_Languages, Simon Peyton-Jones, 1984; but I doubt it's "good for beginners"
23:21:53 <badkins> ah, bos must be Bryan O'Sullivan - I'm in ur blog readin ur codz
23:22:07 <sorear> badkins: /whois
23:22:23 <bos> heh
23:22:28 <quicksilver> badkins: I recommend Bryan's book when he's finished it :)
23:22:40 <Pseudonym> sorear: Actually, that's the first book on functional programming that I read.
23:22:47 <quicksilver> badkins: Huttons book programming in haskell comes highly recommended but it may be too basic for you :)
23:23:02 <badkins> So can total newbies view the pages?
23:23:09 <Pseudonym> No good for beginner programmers, perhaps, but I didn't understand lazy FP until I read it.
23:23:24 <bos> badkins: not yet
23:23:38 <Pseudonym> In fact, my first serious Orwell program (yes, Orwell) was a SK combinator compiler/interpreter.
23:23:45 <badkins> np, with the amount of comments you're getting, you don't need more line noise :)
23:23:47 <sorear> badkins: Of course they can.  This isn't one of those things where the unworthy just see blank papaer.  Anyone can read IFPL.
23:24:12 <Pseudonym> And by "serious" I mean "non-assignment".
23:24:25 <sorear> my first non-exercise Haskell program did symbolic differentiation
23:25:06 <Korollary> Purely Functional Data Structures is also a good read.
23:25:07 <Pseudonym> That's a good one.
23:25:24 <Pseudonym> PFDS wasn't written in 1992 when I read SPJ's book.
23:25:47 <Tela> My first one was the Text Munger Ruby Quiz. That was such a bad choice, heheh :)
23:26:54 <badkins> quicksilver: I don't think a book on Haskell could be too basic for me at this point
23:27:37 <Pseudonym> badkins: This is called a "keyboard".  Don't be frightened by all the buttons!  You don't need to press them all at once.
23:27:47 <quicksilver> :)
23:27:51 <quicksilver> actually you do
23:28:03 <quicksilver> the secret omega-combinator is entered by hitting all the buttons at once
23:28:16 <Korollary> SOE is good enough
23:28:16 <Tela> or, if you use emacs
23:28:22 <Pseudonym> Only if you need to type the hypothesised unicode replacement for function composition.
23:28:36 <Pseudonym> Triple-bucky coke bottle, isn't it?
23:28:46 <badkins> Pseudonym: huh?
23:29:25 <Pseudonym> badkins: The snarky comment about function composition you don't need to worry about.
23:29:27 <Pseudonym> However...
23:29:36 <Pseudonym> http://catb.org/jargon/html/C/cokebottle.html
23:29:37 <lambdabot> Title: cokebottle
23:30:28 <Pseudonym> And the last comment in: http://catb.org/jargon/html/Q/quadruple-bucky.html
23:30:29 <lambdabot> Title: quadruple bucky
23:31:18 <sorear> badkins: seriously, think of Haskell as O'Caml but without the val/fun distinction, the rec/nonrec distinction, the value restriction, or the need for user-defined numeric functions to be monomorphic
23:31:29 <sorear> badkins: the languages really are very similar
23:31:42 <Pseudonym> i.e. O'Caml without the arbitrary restrictions.
23:31:51 <badkins> sorear: thx, if I knew OCaml, that would be helpful I'm sure
23:31:55 <Pseudonym> Which made some kind of sense in 1976.
23:31:56 <Tela> Oh, and without that funky ;;
23:32:01 <quicksilver> sorear: funnily enough the thing I like best is that constructors are first-class functions :)
23:32:05 <sorear> badkins: oh, sorry, I thought you said you came from there
23:32:09 <badkins> ;; is just in the repl, I know that much :)
23:32:18 <quicksilver> sorear: I hate that in ocaml you can't do "map some"
23:33:18 <Tela> badkins: I learned juust enough OCaml to realize that ;; is rare, but it's still just so striking that it's the first thing I see whenever I look at OCaml code
23:33:31 <dataangel> How do I get the last two elements from a list? (take 2 $ reverse mylist) seems hackish, and (last mylist) only returns 1 item
23:33:38 <badkins> Dr. Jon Harrop is reason enough for me to avoid OCaml ;)
23:33:49 <dibblego> badkins, he's infiltrated Scala lately
23:34:00 <sjanssen> quicksilver: that is interesting, when can you apply constructors?
23:34:01 <Korollary> holy moly
23:34:04 <Mr_Awesome> @src (->) loop
23:34:05 <lambdabot> Source not found. Do you think like you type?
23:34:17 <Mr_Awesome> the hell?
23:34:48 <badkins> ?quote hell
23:34:48 <lambdabot> puusorsa says: do not try this in a shell: :() { :&:; } ;:
23:35:24 <Korollary> @src last
23:35:24 <lambdabot> last [x]    = x
23:35:25 <lambdabot> last (_:xs) = last xs
23:35:25 <lambdabot> last []     = undefined
23:35:30 <sjanssen> dataangel: hackish: last $ zip xs (tail xs) -- will return the last two elements as a tuple
23:35:45 <quicksilver> sjanssen: constructors are only applied to values
23:36:00 <quicksilver> sjanssen: 'some 1' is fine and has type 'int option'
23:36:09 <quicksilver> sjanssen: but 'some' is not a well-typed term in its own
23:36:11 <Mr_Awesome> anyone happen to know offhand how loop is implemented for (->) ?
23:36:35 <sjanssen> quicksilver: interesting, I wonder why they have that restriction
23:36:56 <quicksilver> sjanssen: they've got constructors in a different syntax class from functions. I don't know why
23:36:59 <dataangel> this is why I need to rewrite this to use an array type later ;p
23:37:04 <quicksilver> you have to write "fn x => some x"
23:37:06 <quicksilver> annoying
23:37:22 <quicksilver> sjanssen: well, of course, I do know why, it's because they can appear in pattern matches ;)
23:37:28 <quicksilver> sjanssen: but I don't know why they don't generalise
23:37:39 <Pseudonym> > last . ap zip tail $ [1,2,3,4,5]
23:37:41 <lambdabot>  (4,5)
23:37:52 <quicksilver> sjanssen: I used to define a constructor-function for each of my constructors. But that's boring.
23:38:31 * serishema wants to write a simple interpreter for a simple programming language
23:38:45 <sorear> unlambda!
23:38:45 <serishema> not sure how to go about doing it in haskell though
23:38:51 <serishema> the lack of state is breaking my brain again.
23:38:59 <Korollary> There's allegedly a write your own scheme guide in haskell.
23:39:04 * oerjan heard the word unlambda
23:39:19 * Pseudonym respectfully occurs to the "brain-dead" quote above
23:39:23 <Pseudonym> refers, not occurs
23:39:31 <Korollary> brain-dead, eh?
23:39:32 <dataangel> I'd prefer to see a write your own C compiler in Haskell tutorial ;p
23:39:37 <Pseudonym> ?quote brain-dead
23:39:37 <lambdabot> Pseudonym says: The Scheme programming language is optimised for writing small brain-dead tutorial compilers for.
23:40:13 <Pseudonym> In fact, a C compiler isn't a dumb idea.
23:40:21 <Pseudonym> Something about as sophisticated as Allan Holub's book.
23:40:27 * serishema has written both interpters and compilers in C, but her brain just isn't getting around haskell today.
23:40:37 <Korollary> baby steps
23:41:04 <ttfh> serishema: maybe write a state-less interpreter first? then extend it with state
23:41:31 <lekro> is there a function that separates lists like this: [1,2,3,4] -> [(1, [2,3,4]), (2, [1,3,4]), (3, [1,2,4]), (4, [1,2,3])]
23:41:42 <Pseudonym> Half the problem is that the answer is probably easier in Haskell than in C.
23:41:48 <badkins> "all lined up with the the first non-whitespace character after the do" bummer, I thought I left white space sensitivity behind with Python :(
23:41:58 <Pseudonym> serishema: How simple is your language?
23:42:05 <dataangel> lekro: that looks vaguely similar to List.inits but not the same thing
23:42:15 <TSC> badkins: the layout-style is optional
23:42:25 <Pseudonym> My first real interpreter in Haskell was for a subset of Lisp.  Essentially an SECD machine.
23:42:26 <dataangel> lekro: actually nm I misread your example, it's not even close ;p
23:42:34 <Pseudonym> And it was about 20 lines not including parser.
23:42:41 <badkins> TSC: ghc didn't think so :)
23:43:08 <TSC> You have to use braces and semicolons instead
23:43:08 <badkins> no biggy, gotta take the whole package
23:43:17 <TSC> (like C)
23:43:17 <badkins> like in C ?
23:43:19 <badkins> :)
23:43:24 <Tela> badkins do {x <- foo; y <- bar; return $ fn x y}
23:43:31 <oerjan> lekro: i've heard that question before.  here's my solution:
23:44:19 <Pseudonym> ?whois serishema
23:44:19 <lambdabot> Unknown command, try @list
23:44:22 <Pseudonym> Whoops.
23:44:25 <oerjan> > let extract l = [(x,bef++aft) | (bef,x:aft) <- zip (inits l) (tails l)] in extract [1,2,3,4]
23:44:26 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
23:44:28 <Pseudonym> Ah, now I know!
23:44:34 <Pseudonym> s/?/\//
23:45:11 <goalieca> > 450!
23:45:12 <lambdabot>   parse error on input `}'
23:45:34 <lekro> I thought it might be an idiom. Actually I'm trying to write a function that takes a list and generate a list of successors. A successor is defined as the original list with one element altered. But the elements don't have a meaningful Eq instance
23:45:52 <lekro> oerjan: thanks, I'll have a look at this
23:46:16 * pjd wrote that one just recently
23:46:29 <pjd> > zip <*> (zipWith (++) <$> inits <*> tail.tails) $ [1..4]
23:46:31 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
23:46:36 <lekro> the order doesn't need to preserved for the successor
23:46:42 <lekro> +be
23:47:12 <lekro> ? <*>
23:47:29 <lekro> oh, what was the syntax lambdabot likes
23:48:03 <pjd> lekro: Control.Applicative
23:48:07 <lekro> ?hoogle <*>
23:48:08 <lambdabot> No matches found
23:48:10 <oerjan> lekro: just use my (bef,x:aft) trick and do something different with the result
23:49:13 <oerjan> lekro: hoogle is broken on * and $
23:49:35 <dataangel> after several hours of painstakingness, I have implemented an obscure recursive algorithm for checking if a given set of queen positions is valid for nqueens
23:49:56 <dataangel> it handles the diagonal case without resorting to +/- 1 iterating ugliness
23:50:00 <pjd> lekro: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
23:50:02 <lambdabot> http://tinyurl.com/yyo64c
23:50:50 <pjd> lekro: <$> and <*> is like fmap/liftM and ap, respectively
23:50:54 <pjd> but nicer!
23:51:07 <badkins> Wow, that "Write Yourself a Scheme in 48 Hours" tutorial looks great. Is Jonathan Tang now Audrey Tang (associated with pugs) ?
23:53:54 <Pseudonym> badkins: Different person, I think.
23:53:59 <pjd> lekro: that example is the (e ->) functor
23:54:39 <pjd> each argument to <*> is a function of [1..4], which is like a shared environment
23:55:00 <Korollary> badkins: why would you even think that??
23:55:25 <quicksilver> lekro: I'd write [(a,l\\[a]) | a <- l]
23:55:41 <quicksilver> badkins: no, Audrey's name used to be Autrijus, not Jonathan :)
23:55:56 <badkins> quicksilver: right, I should check wiki before posting in future :(
23:56:07 <pjd> quicksilver: duplicates!
23:56:14 <badkins> Korollary: How many Haskell experts with the last name of Tang do you know?
23:56:27 <badkins> Korollary: it's a tiny community, no?
23:56:32 <lekro> quicksilver: there can be duplicates in the list that must be considered both
23:57:18 <lekro> also, testing for Eq can be quite expensive
23:57:38 <Pseudonym> It's not that tiny any more.
23:57:58 <Korollary> badkins: but why would you think that a Jonathan would become an Audrey somehow?
23:58:39 <badkins> Korollary: Well, Autrijus (guy) became Audrey (girl) and is a well known Haskell hacker - not that big of a stretch
23:59:41 <lekro> pjd: that's interesting. Do you know of a nice tutorial or introductory paper about those functions?
23:59:48 <badkins> Pseudonym: tiny is relative. Try monster.com for 'Java', 'Python', 'Ruby', 'Lisp', 'Haskell'  I'd say that might qualify as tiny :)
