00:00:43 <Tac-Tics> I need to figure out a cooler version of that
00:00:50 <omnIdiot> Prob r = State StdGen (Maybe r), to start
00:02:12 <Tac-Tics> I said _I_ need to figure it out omni =-P
00:02:15 <Tac-Tics> err
00:02:17 <Tac-Tics> I*
00:02:19 <Tac-Tics> not bottom
00:02:51 <omnIdiot> then return = Prob . return . return -- :)
00:04:25 <omnIdiot> @. pl undo do { g <- getStdGen ; let (g1, g2) = split g ; setStdGen g1 ; return g2 }
00:04:25 <lambdabot> (line 1, column 21):
00:04:25 <lambdabot> unexpected "{"
00:04:25 <lambdabot> expecting variable, "(", operator or ")"
00:05:18 <Tac-Tics> I have to get some sleep
00:05:26 <Tac-Tics> all this haskell is making me dread tomorrow enough already
00:06:09 <omnIdiot> @pl liftM split getStdGen >>= \(g1, g2) -> setStdGen g1 >> return g2
00:06:10 <lambdabot> uncurry ((. return) . (>>) . setStdGen) =<< fmap split getStdGen
00:06:11 <Tac-Tics> I'm going to monads to.... it ran my program despite the connection to the database failed??? and two of my variables were never set, but it never threw an error?????????
00:06:26 <Tac-Tics> so I bid ye farwell #haskell
00:06:32 <omnIdiot> night
00:07:08 <misterbeebee> gnight
00:07:22 <omnIdiot> @type uncurry (>>) (setStdGen *** return)
00:07:28 <lambdabot>     Couldn't match expected type `(b, c)'
00:07:28 <lambdabot>            against inferred type `StdGen -> IO ()'
00:08:28 <drtomc> Hi all
00:09:01 <omnIdiot> @type uncurry (>>) . (setStdGen *** return)
00:09:03 <lambdabot> forall b'. (StdGen, b') -> IO b'
00:09:13 <omnIdiot> awesome
00:09:41 <omnIdiot> @type uncurry (>>) . (setStdGen *** return) . split =<< getStdGen
00:09:43 <lambdabot> IO StdGen
00:10:40 <drtomc> A little paradigm question - I have a string composed of a sequence of '0' and '1' characters representing the bits of an integer, with the first bit being least significant. I want to construct the corresponding Integer. My question is, how do I doit so that I avoid using O(N) stack space?
00:10:40 * omnIdiot hugs Haskell
00:11:12 <drtomc> i.e. mkBitString :: [Char] -> Integer
00:11:28 <omnIdiot> @type readBin
00:11:30 <lambdabot> Not in scope: `readBin'
00:11:37 <omnIdiot> @docs Numeric
00:11:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
00:13:19 <drtomc> The obvious solution is to use foldr, but will that be efficient?
00:16:24 <misterbeebee> >  foldl (\(val,pos) digit -> (val + digit * 2^pos, pos+1)) (0,0) [1,1,0,1]
00:16:26 <lambdabot>  (11,4)
00:16:29 <misterbeebee> ?
00:16:32 <omnIdiot> > readInt 2 (`elem` "01") digitToInt "101010"
00:16:33 <lambdabot>  [(42,"")]
00:16:48 <hpaste>  drtom pasted "(no title)" at http://hpaste.org/3047
00:17:50 <drtomc> See my hpaste - it's simple, possibly even elegant, but is it O(1) in stack space?
00:18:37 <misterbeebee> I think you want foldl'....
00:18:54 <drtomc> misterbeebee: without aggressive optimization, that'll do a lot of memory allocations
00:19:23 <drtomc> the nice thing about foldr is that the order in which the bits get processed is terribly convenient
00:20:58 <misterbeebee> It's too late at night for me to be smart about folds..... but my rule of thumb is that foldl' is for finite data that is accumulated, and foldr is for  searches on indefinite data
00:21:03 <omnIdiot> > (sum . zipWith (*) (map (2^) [0..]) .  map digitToInt) "010101"
00:21:05 <lambdabot>  42
00:21:42 <sarehu> the thing is foldl' will be strict in the (,) but will it be strict in the arithmetic?
00:21:44 <misterbeebee> omnidiot: that looks good.
00:21:44 <sjanssen> drtomc: your solution uses O(n) stack
00:22:15 <drtomc> I'm still coming to terms with folds in Haskell - I grew up on Prolog, which being strict has very different behaviour
00:22:58 <drtomc> sjanssen: I suspected so. It's just hard to walk away from the simplicity of it. :-
00:23:21 <sarehu> > foldl' ((+) . (*2)) . map digitToInt . reverse $ "010101"
00:23:23 <lambdabot>   add an instance declaration for (Num [Int])
00:23:26 <sarehu> whatever.
00:23:36 <sarehu> does reverse use stack?
00:23:45 <omnIdiot> @src reverse
00:23:45 <lambdabot> reverse = foldl (flip (:)) []
00:24:02 <drtomc> er, looks like it to me.
00:24:04 <sjanssen> sarehu: nope, heap
00:24:27 <drtomc> damn. My intuition's all wrong <sigh>
00:25:44 <sarehu> drtomc: foldl (flip (:)) [] isn't how it's implemented in the libraries
00:25:56 <sjanssen> drtomc: your program is little-endian, is that intentional?
00:26:03 <sarehu> unless #ifdef USE_REPORT_PRELUDE
00:26:06 <omnIdiot> @index foldl
00:26:06 <lambdabot> Data.List, Prelude
00:26:10 <omnIdiot> @source Prelude
00:26:10 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
00:26:29 <sarehu> look in base/GHC/List.lhs
00:26:46 <sjanssen> the real source is equivalent
00:26:51 <drtomc> Yes - that's part of the specification (ASN.1, as it happens).
00:27:02 <sjanssen> they've just inlined the body of foldl, basically
00:27:50 <sjanssen> drtomc: oh, too bad.  Big endian is just as easy with a foldl, and is faster to boot
00:28:59 <sjanssen> how about: sum . zipWith (*) (iterate (2*) 1)?
00:30:36 * omnIdiot always forgets iterate
00:30:46 <sjanssen> or even sum [i | (i, '1') <- zip (iterate (2*) 1) bits]
00:30:48 <drtomc> sjanssen: If you happen to examine the ASN.1 standard, it does make sense that they do it little endian.
00:30:57 <drtomc> @t iterate
00:30:57 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
00:31:02 <sjanssen> @type iterate
00:31:05 <drtomc> :t iterate
00:31:08 <lambdabot> forall a. (a -> a) -> a -> [a]
00:31:09 <lambdabot> forall a. (a -> a) -> a -> [a]
00:31:14 <sjanssen> > iterate (2*) 1 -- just powers of 2
00:31:18 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
00:31:59 <sarehu> I thought sum uses stack space
00:32:22 <sjanssen> O(1) stack space
00:32:28 <drtomc> sjanssen: Nice solutions! The trick will be efficiency.
00:32:52 <sarehu> ok.. why is sum [1..1000000] overflowing?
00:32:55 <sjanssen> drtomc: the list comprehension one should be pretty speedy, I think
00:33:05 <sjanssen> sarehu: all bets are off without -O :)
00:33:08 <drtomc> It is possible that the ASN.1 value could have 1000 '0's then a '1'.
00:33:13 <sarehu> sjanssen: good point
00:33:23 <sarehu> foldl' (+) 0 works
00:34:33 <sjanssen> sarehu: the Haskell spec doesn't allow sum to be written strictly
00:34:42 <sarehu> yes
00:34:55 <sjanssen> with -O, GHC is able to figure out that sum on [Int] can be strict
00:34:59 <drtomc> sjanssen: I'll plug it in. As Knuth is reputed to have said "premature optimization is the root of all evil".
01:16:15 <wli> I'd say the opposite.
01:16:34 <wli> Too late of optimization is the root of all evil.
01:18:27 <wli> Bad optimizations are all about not understanding the problem up-front.
01:18:43 <sieni> well, premature pessimization also sucks
01:21:31 <ttfh> or choosing a bad algorithm/design is the root of all evil
01:21:47 <wli> ttfh gets my drift.
01:22:18 <wli> It's the high-level algorithm, not bit twiddling passes after everything's already been written.
01:22:40 <ttfh> trying to fix the bad design with hacks
01:23:16 <wli> Or trying to speed up the dumb algorithm with bit twiddling.
01:24:12 <wli> Of course, reality is that most algorithmic efficiency issues are idiotic, like linear search etc.
01:24:18 <ttfh> the project I'm currently on could do with some design optimization, redesigning the whole thing from scratch...
01:25:52 <wli> ttfh: Reminds me of most operating system kernels I've seen.
01:26:49 <wli> OS kernels are horrible about abusing hash tables where they don't belong, and grow quite dependent on the data structure.
01:26:59 <dolio> That's why we need new operating systems built from the ground up using UML!
01:27:12 <gvdm> :/
01:27:17 <wli> Then they link through in several different ways, often involving linear search and linked lists.
01:27:18 * mux is not convinced about using FP languages for kernels yet
01:27:31 <gvdm> house anybody?
01:27:38 <mux> kernels also use red-black trees, splay trees, etc
01:27:45 <wli> I'm not either, actually. House et al notwithstanding.
01:28:09 <glguy> man, the guys at work are going to be bummed out to hear that :)
01:28:09 <wli> RB trees and splay trees are actually both not great choices anymore.
01:28:21 <ttfh> One of the subsystem-contractors on this project proudly state that their sollution features something called "garbage collection"
01:28:24 <mux> in case of kernel C code, for some things, they proved very fit
01:28:38 <mux> for instance, we now store the vm_map structs in a splay tree in the FreeBSD kernel
01:28:41 <mux> it has proved very efficient
01:29:08 <wli> One of the big issues with kernels is cache cleanliness and being block-oriented in various fashions for cache and TLB efficiency.
01:29:27 * mux whispers: judy :)
01:29:30 <wli> B+ trees do that; RB trees don't and splay trees dirty the cache horribly.
01:29:49 <mux> splay trees dirty the cache for precisely the same reason they are efficient in some cases
01:29:51 <wli> Judy and other radix trees have issues with sparsity.
01:29:57 <mux> they greatly amortize the lookup costs
01:30:04 <mux> for vm_map's it's good
01:30:11 <mux> for other things, it might not be optimal at all, of course
01:30:19 <wli> The cache dirtiness is suicide on SMP.
01:30:45 <mux> you know, there are a lot of factors that come into play
01:31:01 <wli> I say B+ trees just about everywhere.
01:31:09 <mux> when you deal with fine-grained locked kernels, you have many other things to worry about, some of those being 'bottleneck' enough to prevent any other optimisations
01:31:45 <mux> some things that should be theoritically faster end up being slower, etc
01:31:54 <wli> mux: I'm coming at it from high-level considerations, namely cache and TLB footprint.
01:32:30 <mux> wli: we have a very nice new feature that should land in FreeBSD's CVS very soon now, that you may be interested in: superpages
01:32:36 <mux> they are a great way of reducing TLB misses
01:32:41 <wli> mux: That means the theory is insufficiently well-developed to accurately predict performance, or was inappropriately applied (e.g. constant factors not factored in).
01:32:58 <mux> wli: yes, and that happens an awful lot when optimising kernels :)
01:33:01 <wli> mux: That's rather orthogonal to all this; it only applies to userspace.
01:33:14 <mux> wli: no it doesn't, superpages benefit the kernel memory too
01:33:27 <mux> you are confusing with Linux's way, which is to just add new syscalls for allocating bigger pages
01:33:30 <mux> the FreeBSD way is transparent
01:33:36 <wli> mux: The kernel is all one huge linear mapping anyway; it could literally be a single base/bounds pair.
01:33:40 <mux> it merges adjacent pages in bigger pages with a binary buddy allocator
01:33:50 <wli> mux: And that goes for BSD as well as Linux.
01:33:54 <mux> wli: that's wrong, the kernel does an awful lot of dynamic allocations
01:34:02 <mux> no, Linux doesn't have a similar mechanism yet
01:34:20 <mux> some kernels' memory (AIX) are even pageable
01:34:39 <wli> mux: BSD does more in the way of dynamic kernel virtual memory but still has a large statically mapped region.
01:34:45 <wli> mux: I know. I've hacked on AIX.
01:35:03 <mux> we have a contiguous address space, of course
01:35:12 <sieni> pageable kernel memory doesn't prevent aix from sucking, though
01:35:17 <mux> that doesn't prevent superpages optimizations
01:35:34 <wli> AIX calls it static kernel virtual memory and dynamic kernel virtual memory.
01:36:13 <wli> (AIX also has interesting NUMA -related nomenclature, like srads, irads, and mrads, which are not entirely unique to it, and publicly used in e.g. papers, but anyway).
01:36:36 <mux> we are not up to speed NUMA-wise
01:37:11 <mux> that's one area where FreeBSD is lacking
01:37:43 <wli> mux: I'm not terribly concerned about implicit large page mappings for dynamic kernel virtual memory. I'm on about virtual contiguity of data structures within whatever sort of kernel virtual  memory.
01:37:54 <Adamant> Matasano Blog had an interesting rant on AIX
01:38:01 <wli> mux: If the data structures aren't virtually contiguous what good is the superpage optimization?
01:38:29 <mux> this is all much complicated if you consider that on recent 64bit architectures with large address spaces, we have some memory with PA == VA to speed things up
01:38:39 <mux> wli: superpages is at the VM level
01:38:49 <mux> it has no consideration about the data structures used within the pages it manages
01:38:59 <mux> that's what makes it transparent and thus useful
01:39:25 <mux> it'll just do its best to use big pages if available on the architecture, to increase TLB coverage and thus reduce TLB misses
01:39:25 <wli> Adamant: Whatever faults AIX may have its taxonomy of system-level phenomena is quite good.
01:39:53 <wli> mux: If the kernel data structures aren't contiguous those transparent bits don't apply.
01:40:03 <wli> mux: Virtually contiguous, that is.
01:40:09 <mux> so whatever data structures you use, whether they are contiguous or not, doesn't matter
01:40:12 <mux> no
01:40:20 <wli> mux: It does.
01:42:49 <wli> mux: Easy example.
01:43:01 <mux> err, not; what matters is to have sufficient contiguous *physical* memory
01:43:05 <wli> mux: Splay or RB tree vs. B+ trees.
01:43:11 <mux> which is the job of the binary's buddy allocator
01:43:20 <mux> any higher-level consideration doesn't come into play
01:43:35 <mux> you always essentially end up with contiguous virtual memory, since this is what VM is all about
01:43:55 <wli> mux: The pointer chasing in binary trees can get you each tree node in a different 2MB page.
01:43:59 <mux> splay trees, RB trees, B+ trees can all benefit from superpages
01:44:11 <mux> wli: and superpages can merge these pages together
01:44:37 <mux> without any notion of what's in it
01:45:05 <wli> mux: In B+ trees each internal node smashes what amounts to some large number of RB or splay tree nodes into a single contiguous chunk.
01:45:16 <mux> that doesn't matter at all
01:45:25 <mux> it matters for other considerations, such as cache locality
01:45:53 <mux> which I agree is a very important thing nowadays, performance-wise
01:45:55 <wli> mux: If/when the data structure is in a leaf node and contiguous there, you get an analogous TLB footprint effect in the data.
01:46:07 <wli> mux: The TLB is just another kind of cache with a larger granularity.
01:46:51 <wli> mux: This matters. "Blockiness" for TLB footprint effects is extremely important and only gets more so when using transparent superpages.
01:47:29 <mux> wli: my point is that it doesn't matter for superpages, in the sense that one way or the other won't prevent the superpages optimizations
01:47:36 <mux> now I'm not sure what you're talking about
01:47:52 <wli> mux: This is not some crackpot pet theory of mine. I'm literally reciting standard optimization techniques for numerical linear algebra and other affairs.
01:47:54 <mux> but we're being really off-topic, maybe we should go on with this in pm?
01:48:08 <glguy> yeah, you're really disturbing the rest of the conversations ;)
01:48:28 <mux> I'm not doubting that; just saying that what you're pointing doesn't come into play in the superpages framework I'm talking about
01:48:37 <wli> mux: It matters for superpages because you won't make large allocations to be backed by large pages if you don't do this sort of thing.
01:48:52 <mux> wli: huh?
01:49:05 <mux> I could allocate a linked list and benefit from superpages
01:49:10 <wli> mux: It matters because without doing it transparent superpages won't be driven in such a fashion that it will be used as much as it could be.
01:50:04 <mux> wli: if your program uses bad data structures, with bad locality, but that all its pages are merge in one superpage, resulting in a TLB coverage sufficient to map the whole working set of a process in one TLB entry, I still benefit from superpages
01:50:26 <mux> wli: and I benefit without going into that extreme either
01:50:32 <wli> mux: Yes, that's coincidence/etc.
01:50:39 <mux> please consider that a kernel tends to run many processes
01:50:51 <mux> so superpages optimization help a lot, whatever the said processes are doing
01:50:56 <mux> for the mere sake of reducing TLB misses
01:51:42 <wli> That's userspace, though. You can't really do much about that but hope that programs are well-written and most of the time they won't be.
01:52:02 <mux> I'm mostly talking about userspace, this is where superpages are a BIG win
01:52:32 <mux> especially if you also have some primitives in the CPU to not flush the whole TLB at context switch time
01:52:46 <wli> The comments I made do apply to writing userspace programs, not that I deal much with that.
01:52:50 <mux> such as with the PGE extension and x86
01:53:13 <mux> I fully agree that most of the userspace programs are badly written by the way :-)
01:53:30 <wli> Range flushing for the TLB would help a lot, not that AMD and Intel have their heads far enough out of their backsides to do something so intelligent.
01:53:54 <mux> PGE is better than nothing, but right, that would be nice
01:54:04 <wli> FWIW the considerations I mentioned come into play in RTS's.
01:54:16 <mux> I'm not well versed in RTS's
01:54:27 <wli> RTS's try to arrange generations to fit into the pagesize spectra for GC.
01:54:46 <wli> So basically one large page for each generation.
01:54:51 <mux> sorry, $real_work, I'll bbl
01:55:21 <wli> Real work doesn't begin here for at least 5 hours.
01:55:33 <wli> glguy: Were you following much of this?
01:56:02 <ttfh> I understood almost nothing
01:56:13 <wli> ttfh: Want me to go over it in slow motion?
01:56:36 <ttfh> hehe, I don't think I'm ready for it
01:56:54 <wli> ttfh: It's far simpler than it sounds. A lot of it is jargon.
01:57:09 <glguy> wli: I'm reading along, but I don't know what TLB is
01:57:12 <ttfh> Its about mapping virtual memory to physical memory?
01:57:20 <wli> ttfh: Yeah.
01:57:40 <wli> glguy: Okay, virtual memory involves translating virtual to physical addresses. A TLB caches those translations.
01:58:54 <wli> glguy: So there will be a process, a kernel programs translations from one address to another, the TLB caches those translations. It basically ends up just being a mapping between numbers.
01:59:09 <ttfh> so if I write a C program that fiddles around with pointers, those pointers are a physical or virtual address? when does the translation happen?
01:59:19 <wli> Those mappings are per-process.
01:59:19 <glguy> C pointers are virtual ones
01:59:26 <wli> ttfh: Virtual.
01:59:32 <glguy> (at least in userspace)
01:59:51 <wli> ttfh: Physical only really ever happens at early boot. Even kernels use virtual addresses.
01:59:59 <glguy> ah,ok
02:00:10 <wli> glguy: Okay, anyway, the usual granularity is 4KB for these mappings.
02:01:09 <wli> glguy: There's something called superpages that lets you have variable mapping granularity, so one translation will be 4KB, another 64KB, another 256KB, another 1MB, another 4MB, another 16MB, etc. (well, it's architecture-dependent, but powers of 4 make it simpler to see what's happening).
02:01:32 <ttfh> so if i write to a virtual adress, what happens?
02:01:46 <wli> glguy: Overlapping the things is basically "kernel, you screwed up, time to reboot."
02:02:19 <wli> ttfh: It gets translated to a write to a physical address, modulo protection business I'm going to ignore for now.
02:02:48 <wli> glguy: Anyway, you really want to avoid cache misses on this TLB thing because they're not cheap on any arch.
02:03:01 <glguy> and you avoid misses by
02:03:07 <glguy> locality?
02:03:14 <glguy> keeping accesses inside a block of
02:03:18 <glguy> 4k, traditionally?
02:03:31 <wli> glguy: So when you make a data structure, you allocate things you think will be TLB entry -sized and cram everything into those.
02:03:42 <mux> each TLB entry caches a single virtual -> physical address translation for one page
02:03:42 <wli> glguy: Yes, "blockiness" as I was talking about.
02:04:00 <mux> if your TLB can have entries for 4k pages, but also, say, 4M
02:04:02 <wli> glguy: Superpages change the equation somewhat though not drastically.
02:04:11 <mux> the (usually very limited) entries in the TLB cover more memory
02:04:15 <glguy> and the kernel decides what size entry you need?
02:04:16 <mux> so you have fewer TLB misses
02:04:23 <mux> no, the architecture determines this
02:04:33 <ttfh> and if I read from a virtual address, that bit of memory could be swapped to disc, so then something reads it into memory again for me, right?
02:04:35 <mux> some architectures even have several TLBs, for several different page sizes
02:04:38 <wli> glguy: You basically want to use huge blocks when you can.
02:04:46 <mux> (eg UltraSPARC III)
02:05:33 <mux> a TLB usually holds 64, 128, maybe 256 entries
02:05:34 <mux> it's small
02:05:55 <wli> glguy: The point I was making was that for the sake of "blockiness" you'd want to use things like B+ trees instead of e.g. RB trees.
02:06:20 * mux is now really gone :)
02:06:35 <glguy> and mux was trying to say that typical datastructures would fit comfortably into a "superpage"
02:06:47 <glguy> so the emphasis on blockiness wasn't as important?
02:06:57 <mux> it's only important for cache locality
02:07:03 <glguy> I thought you were gone ;)
02:07:03 <mux> which is very important.
02:07:08 <mux> right, I thought so too
02:07:12 <mux> heh
02:07:16 <mux> but the boss isn't here yet...
02:07:35 <mux> and the alternative to having a nice discussion in here is hacking some perl code, so I'm a bit reluctant :-)
02:07:45 <ketil> about quickCheck - should I define 'coarbitrary', and if so, why, and how?
02:07:47 <wli> glguy: I can't make out what he's on about. Cramming things into (super)pages is how you optimize for TLB.
02:08:22 <wli> glguy/mux: How many pages do you touch in a traversal? This is the metric for the TLB.
02:08:36 <glguy> 7
02:08:48 <glguy> oh, you weren't asking? ;)
02:08:52 <wli> glguy: The answer comes out as a big O.
02:09:10 <wli> glguy: Or otherwise f(n) + O(g(n)).
02:09:30 <wli> Most blockiness bits improve the constant factors vs. the big O.
02:09:49 <wli> But they improve them by large constant factors, like 512 or 1024 or more.
02:10:06 <mux> if your data structure spans many pages, it sure will be harder to optimize it into superpages, depending on the available page sizes
02:10:17 <mux> by the way, ia64 has pages as big as 256MB, IIRC
02:10:32 <wli> mux: McKinley has 4GB pages.
02:10:41 <mux> nice :-)
02:10:54 <mux> one page to rule them all...
02:10:58 <mux> and in the TLB bind them.
02:11:19 <glguy> lol, maybe you *should* go hack some perl code ;)
02:11:24 <wli> Anyway, optimizing it into something "blocky" is what I was on about. The same sort of way you do chunking for cache locality you do for TLB locality, albeit on a larger scale.
02:11:39 <mux> glguy: heh, maybe yeah :-)
02:12:02 <wli> Compilers literally do this sort of chunking in array traversals for numerical code as things stand.
02:12:09 <mux> wli: what I was on about is that you can have awfully sparse data structures, intertwinned with code even, and still get huge benefits from superpages
02:12:19 <mux> but you'll lose on cache locality, for sure
02:12:42 <wli> Sure, it can still happen, but that's not how you write to get maximal benefits from superpages.
02:12:49 <wli> Not just cache, but TLB locality.
02:13:09 <wli> There is a hierarchy of locality here.
02:13:15 <mux> not TLB locality if the pages are still big enough to hold the whole sparse thing
02:13:33 <mux> you won't have any more TLB misses with a sparse data structure if it still fits one page
02:13:35 <draggor> So, general question, I'm interested in learning Haskell, and am currently a Lisp guy (at least I started it this past spring).  Any books to recommend for someone who's at least familiar with functional programming?
02:13:37 <wli> That's often hoping beyond hope.
02:13:39 <mux> this is what I'm trying to say since some time now :-)
02:13:53 <mux> and with the modern page sizes available, this ain't unrealistic
02:13:55 <wli> For any moderately-sized data set that hope is dashed.
02:14:31 <mux> but there's no doubt about sparse data structures being less efficient overall
02:15:26 <wli> You can hope it happens, and maybe recover something for userspace oblivious to it all, but it's not how you write to actually get speed on the algorithmic level.
02:15:44 <glguy> draggor: have you looked at the books like on haskell.org?
02:15:50 <mux> wli: sure
02:16:18 <wli> It's hopeful programming vs. thoughtful programming. ;)
02:16:42 <EvilTerran> my programming is hopeless ;)
02:16:56 <wli> Well, sort of, since you were going on about userspace that is/was totally oblivious and unmodified.
02:17:17 <mux> wli: note I'm certainly not advocating using bad data structures and "let the OS optimize it"; I mostly meant to point out that superpages help whether or not you design your data structures efficiently, because it's working at a lower level
02:17:18 <draggor> Yes, and really, at least half of those look appealing.  To give an idea for what works for me, Practical Common Lisp is what let that language really click with me.
02:17:53 <wli> mux: And I was pushing for the use of "blocky" data structures like B+ trees as opposed to RB/splay trees in-kernel.
02:18:11 <drtomc> wli & mux: I've just spent the last five minutes trying to find a paper about btree optimization to reduce tlb pressure - it seemed slightly relevant.
02:18:27 <draggor> My main problem with Lisp, as nice as it is, that there's no good cross platform gui toolkit for it, and I found for Haskell there's gtk2hs.
02:18:38 <wli> drtomc: It works for the precise same reason it reduces disk reload pressure.
02:19:15 <drtomc> wli: sure - the main idea was buffering updates at each level of the tree and pushing them down incrementally.
02:19:17 <wli> drtomc: Every time things talk about loading a page from disk or writing one out to disk just substitute TLB and/or cache operations.
02:20:03 <drtomc> wli: absolutely.
02:20:36 <wli> drtomc: Radix trees are harder to find material on pertinent to external algorithms.
02:20:49 <drtomc> wli: I just wish I could find the paper, if only to fix the mental blank about the author - he did a sebatical at Melbourne Uni when I was there, and we played bridge.
02:21:24 <wli> drtomc: The ideas there are far more elementary. They're basically taken from the various extremely crude radix tree -based filesystems.
02:21:26 <drtomc> wli: Actually, andrew bromage (pseudonym) and I worked on just that at one time.
02:22:18 <wli> drtomc: No one sane uses naked radix trees anyway; their behavior in the presence of sparsity is explosive.
02:22:31 <quicksilver> It's reasonable to suggest that a FP compiler could try to help with locality, isn't it?
02:22:45 <quicksilver> it could heuristically try to allocate recursive data types locally, for example
02:22:54 <drtomc> wli: well, no. We were using them as a way of optimizing external sorting.
02:22:58 <wli> drtomc: But the more advanced algorithms all carry over the same basics from the crude historical fs's.
02:23:42 <wli> quicksilver: Yes, there are numerous methods of making the GC and allocator try to exploit superpages.
02:24:40 <wli> quicksilver: Maybe the simplest is to make one generation for each power of 4 size of some superpage and then try to minimize cross-generational pointer links.
02:25:18 <wli> quicksilver: I think Jones & Lins discuss this very briefly.
02:25:53 <wli> quicksilver: Though not in such specific terms as to make a concrete suggestion like I did.
02:26:09 <mux> the self-updating model of the STG machine doesn't seem well suited to cache locality to me
02:27:28 <wli> I think you have to group the self-updating structures into larger structures to pull it off.
02:28:35 <wli> One self-updating cons cell per-integer for a list of integers, for example, will blow.
02:30:02 <wli> Some kind of deforestation or something to chunk that into one cons cell per-structure for some structure close to the size of some unit in the memory hierarchy is what you want.
02:30:06 <drtomc> To some extent, the biggest win for locality is to exploit strictness so you don't have to update. That plus unboxing
02:45:01 <roconnor> @bab de en Forschungsseminar
02:45:02 <lambdabot>   Research seminar
03:10:40 * mux wonders if withCAString is significantly faster than withCString
03:38:35 <ari> @src Functor ((,) a)
03:38:35 <lambdabot> Source not found. Do you think like you type?
03:43:38 <quicksilver> @src Functor Maybe
03:43:39 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:43:47 <quicksilver> ari: I don't think @src does whole classes
03:43:51 <quicksilver> ari: it does methods, though
03:43:56 <quicksilver> @src fmap Maybe
03:43:56 <lambdabot> Source not found. I feel much better now.
03:44:01 <quicksilver> hmm. sometimes.
03:44:04 <quicksilver> @src Maybe fmap
03:44:04 <lambdabot> fmap _ Nothing       = Nothing
03:44:04 <lambdabot> fmap f (Just a)      = Just (f a)
03:44:06 <dolio> @src (,) fmap
03:44:06 <lambdabot> fmap f (x,y) = (x, f y)
03:44:29 <ari> quicksilver: It's simpler than that afaik
03:44:45 <quicksilver> ?
03:44:52 <dolio> @src Functor
03:44:52 <lambdabot> class  Functor f  where
03:44:52 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
03:46:18 <ari> quicksilver: AFAIK @src just looks at State/source, which is a flat list of standard implementations of functions that comes with lambdabot
03:46:41 <SamB_XP> s/standard //
03:47:24 <quicksilver> ari: but the conventions used to store that src :)
03:47:43 <quicksilver> ari: are that you ask for instance/method or class, but not class/instance
03:48:36 <ari> quicksilver: Ahhh, yes. I blame mathematicians for infecting me with their abuse of notation :(
03:51:14 <arcatan> by the way, are there any haskell webservers?
03:51:37 <opqdonut> anyone know of sites that use happs?
03:51:41 <arcatan> oh, I forgot happs
03:51:53 <ari> @go haskell web server
03:51:54 <lambdabot> http://darcs.haskell.org/hws/
03:51:55 <lambdabot> Title: Index of /hws
03:52:14 <opqdonut> arcatan: heh, i asked that independently
03:55:00 <arcatan> great timing
03:55:34 <quicksilver> is hAppS a full HTTP server, or does it expect to run under (e.g.) fastcgi?
03:57:28 <arcatan> iirc it supports both
04:09:43 <fax> hi
04:09:52 <tibbe> hi
04:10:19 <fax> do you know any list of interactive geometry programs in haskell ?
04:11:33 <tibbe> no sorry
04:11:41 <fax> ok :(
04:12:51 <roconnor> @type (>>=)
04:12:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:12:59 <roconnor> @type (=<<)
04:13:00 <EvilTerran> interactive geometry? Geometer's Skechpad kinda thing? (in that case, no, but GSP is awesome enough for my purposes =])
04:13:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
04:13:34 * roconnor wants to wrige an interactive geometry program in haskell
04:13:37 <roconnor> write
04:13:52 <fax> tell me when you are finished :D
04:14:19 * EvilTerran is also interested in such a thing, actually. GSP isn't *quite* awesome enough for my purposes.
04:14:38 <EvilTerran> but i'll want to finish my Allegro bindings first... ;)
04:14:39 <roconnor> I have a geometric algebra library
04:14:53 <roconnor> ... not that I've used it for anything
04:15:01 <fax> roconnor: Is it online?
04:15:05 <fax> (can I download it)
04:16:10 <tibbe> where's the network package's darcs repo hiding?
04:18:15 <roconnor> er, I guess it isn't online
04:18:20 <roconnor> maybe I can paste it
04:22:02 <hpaste>  roconnor pasted "Clifford.hs" at http://hpaste.org/3049
04:22:44 <EvilTerran> the big red dog?
04:23:00 <hpaste>  roconnor annotated "Clifford.hs" with "Math.hs" at http://hpaste.org/3049#a1
04:23:15 <hpaste>  roconnor annotated "Clifford.hs" with "Algebra.hs" at http://hpaste.org/3049#a2
04:23:29 <roconnor> I cut out the quickcheck stuff.
04:23:49 <fax> coool
04:23:53 <fax> thanks roconnor I am reading :D
04:24:00 <roconnor> Like I said, I've never used it, so it could suck in several ways
04:24:31 <roconnor> I also have a more specific version for 3D geometry
04:26:06 <hpaste>  roconnor annotated "Clifford.hs" with "Clifford3.hs" at http://hpaste.org/3049#a3
04:26:40 <roconnor> hmm, Clifford3.hs is too long to paste
04:26:57 <roconnor> stupid boilerplate
04:27:32 <EvilTerran> could you refactor it away somehow? **looks**
04:27:41 <fax> this is so cool
04:27:42 <fax> :o
04:28:13 <fax> so you can easily make complex numbers then quaternions and other stuff from Clifford Algebra?
04:28:17 <EvilTerran> roconnor, you could make all your default<blah> things actual default methods of Reverse
04:28:19 <roconnor> yep
04:28:37 <ketil> Anybody have an example/tutorial on how to use Parsec to parse a tokenized stream ([Foo] instead of [Char])
04:28:59 <roconnor> EvilTerran: yeah, I think there is some reason I didn't do that.
04:29:18 <roconnor> EvilTerran: but I have no idea what that reason would have been.
04:29:30 <fax> ketil: I have um some code
04:29:33 <fax> ketil: It's really simple
04:30:05 <EvilTerran> roconnor, i hate it when that happens. "why the heck did i do that? there must've been some good reason, there's obviously a better way if there isn't one"
04:30:24 <roconnor> EvilTerran: seems like I should have put in a comment.
04:30:36 <EvilTerran> ah, hindsight.
04:30:36 <fax> ketil: What you do is, define a tokenParser for your type of token
04:30:50 <EvilTerran> who comments their toy modules anyway?
04:31:04 <fax> ketil: Once you did that everything just works in the same way really
04:31:07 <EvilTerran> ;)
04:31:19 <Philippa> ketil: use the token, tokenPrim and/or tokenPrimEx functions to build tokenParser-style parsers
04:31:22 <roconnor> EvilTerran: maybe it has something to do with the class constraints on the default<blah> functions.
04:31:24 <ketil> fax: Okay, I'll see if I can grok it.
04:31:29 <Philippa> and then as fax says, it's just the same after that
04:31:55 <EvilTerran> hmm
04:32:07 <EvilTerran> i see what you mean
04:32:38 <roconnor> It does seem like I could put in a default definition for norm :)
04:33:18 <roconnor> {- Rotors are unit quaternions -}
04:33:18 <roconnor> data Rotor = Rotor Scalar BiVector deriving (Read, Show)
04:33:39 <roconnor> :)
04:35:03 <hpaste>  roconnor annotated "Clifford.hs" with "last bit of Clifford3.hs" at http://hpaste.org/3049#a4
04:36:20 <hpaste>  roconnor annotated "Clifford.hs" with "EuclideanSpace.hs" at http://hpaste.org/3049#a5
04:36:33 <roconnor> Wow, this is more complete than I remembered
04:36:39 <roconnor> maybe I should darcs it up
04:41:34 <tibbe> :t concatMap
04:41:36 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
04:41:44 <tibbe> @src concatMap
04:41:44 <lambdabot> concatMap f = foldr ((++) . f) []
04:45:54 <harlekin> Hello. (:
04:47:59 <harlekin> I am new to haskell and am trying to write a tiny practise program. But ghc is giving me an error I cannot handle. May you please have a look at line 3 and 4 (where the error occurs) and tell me what's going wrong? (:
04:48:03 <harlekin> http://pastebin.archlinux.org/15443
04:48:48 <quicksilver> harlekin: the [ | ] notation is a list comprehension
04:48:56 <quicksilver> harlekin: that's for producing lists
04:49:04 <quicksilver> you just want a single value
04:49:10 <harlekin> Do I have to use the "do" notation for my particular purpose?
04:49:18 <ukl> harlekin: you might want to use "any" or "all" on the list comprehension
04:49:22 <ukl> (just a guess, tho)
04:49:23 <quicksilver> harlekin: no
04:49:32 <quicksilver> harlekin: I am pasting a corrected version, 1 moment
04:49:34 <DRMacIver> You never have to use do notation. It's just sometimes convenient.
04:49:45 <harlekin> quicksilver: That's kind of you. Thanks. (:
04:50:00 <harlekin> DRMacIver: That's why I was trying to avoid it. (:
04:50:19 <quicksilver> harlekin: http://pastebin.archlinux.org/15444
04:50:31 <quicksilver> harlekin: the idea of what you had written was fine
04:50:44 <quicksilver> harlekin: just the [] were out of place, because it wasn't about lists
04:50:59 <harlekin> quicksilver: That's great. Thank you. (: I didn't know let was capable of this.
04:50:59 <quicksilver> mind you I didn't compile it. maybe there's another problem I didn't spot
04:51:20 <harlekin> Yeah. The general concept of how to do this is definitely enough. (:
04:52:00 <quicksilver> harlekin: 'let' is a convenient way of 'destructing' values
04:52:07 <quicksilver> that is, inspecting their contents
04:52:19 <quicksilver> (in this case, it's destructing the tuple produced by the two analize functions)
04:52:31 <harlekin> Yeah. I see. I thought it was just to build functions in functions. Like a more expressive way of using lambda functions.
04:52:40 * quicksilver nods
04:52:40 <harlekin> *way instead of
04:52:46 <quicksilver> there are multiple ways to deconstruct
04:52:52 <quicksilver> another way is to use 'case'
04:52:59 <quicksilver> but that looks a bit funny when there is only one case
04:53:41 <quicksilver> you could say "case analizeType ss of (t,ns) -> case analizeName ns of (n,vs) -> n && t"
04:53:49 <quicksilver> that would be the same but, IMO, uglier
04:54:07 <harlekin> quicksilver: Yes. I'll stick to the let method. But thanks for pointing this out, too. (:
05:03:01 <ketil> fax: Followed 2.11 "Advanced: Separate scanners" in the Parsec docs. Okay, so far so good.  But any idea what to do with the SourcePos values?
05:03:13 <ketil> (I'm happy to ignore them, if that is easiest)
05:03:22 <bringert> "analize"? I'm not sure I want to know...
05:03:33 <ketil> (Or Philippa?)
05:03:38 <fax> ketil: I did this nextPos pos x xs = incSourceColumn pos 1
05:03:45 <fax> ketil: so I just increment by 1 for each token read
05:04:30 <ketil> um.. I tried to use testParse, but it now needs input on the format of [SourcePos,MyToken]
05:04:42 <ketil> [(SourcePos,MyToken)], that is.
05:04:55 <quicksilver> bringert: yeah, I know ;P
05:05:52 <ketil> Oh wait: there's setSourceXXX functions in there.  Let me try those :-)
05:05:52 <karisma> Hi any GHC dev guys here?! I need some help in a project proposal
05:06:15 <karisma> i am looking forward to develop a incremental GC for haskell, GHC
05:06:37 <karisma> Does anyone know the status of GC in the current GHC?
05:06:39 <roconnor> karisma: you may be interested in #ghc
05:07:14 <karisma> Thanks rconnor, I not get any replies from that channel. So thought I will get some pointers here..
05:07:21 <karisma> *did
05:07:23 <roconnor> karisma: fair enough
05:07:26 <roconnor> :)
05:07:33 <karisma> any idea?!
05:07:45 <roconnor> not me sorry. :(
05:08:04 <karisma> oh ok.. Thanks anyways :)
05:08:11 <ketil> :-( There seems to be no way to artificially create a SourcePos.
05:08:55 <quicksilver> remind me, what's the differene between incremental GC and generational?
05:09:35 <Philippa> ketil: yes there is, read the docs for the Parsec.Pos module
05:09:49 <Philippa> incremental GC can be 'paused'
05:10:03 <dolio> Generational has different areas that it sticks stuff in depending on how long the memory has been allocated, and runs GC on the areas with different frequency.
05:10:03 <quicksilver> ah, right
05:10:17 <dolio> Or something like that.
05:10:53 <quicksilver> yeah, I'm happy with generational
05:11:01 <quicksilver> I saw a nice seminar given on that
05:12:00 <quicksilver> http://www.dcs.qmul.ac.uk/research/logic/seminars/abstract/JonesR03.html
05:12:03 <quicksilver> that one
05:12:03 <ketil> Philippa: would you mind telling me what it is called?  I seem unable to see it.
05:12:08 <lambdabot> http://tinyurl.com/ywqecc
05:12:27 <ketil> The constructor is hidden, and every single function takes a previous SourcePos as argument(!?)
05:12:35 <karisma> Thanks guys, Yeah incremental is something which makes sure that GC doesnt disrupt the actual program activity and vice versa
05:13:02 <karisma> I found this project proposal in GSOC
05:13:17 <mux> ForeignPtr are really nice
05:13:37 <karisma> thot it will be interesting to work on
05:14:04 <karisma> thanks for the link quicksilver
05:15:46 <Philippa> newPos doesn't
05:16:44 <ketil> Philippa: right!  Thanks.
05:17:20 <ketil> Apologies for my mental density and poor eyesight.
05:23:44 <Philippa> ketil: it's easily missed, it took me a couple of passes to spot it the first time
05:26:29 <ketil> Philippa: one might argue that it might be mentioned in the documentation as well.
05:34:31 <quicksilver> ketil: one might argue that the parsec docs are deficient in many ways, actually :)
05:34:38 <quicksilver> ketil: mostly you have to guess what things do from their types...
05:40:42 <ketil> quicksilver: well - I added some haddock notes and restructure, and will submit a patch to the repo on haskell.org.
05:41:08 <quicksilver> yay :)
05:41:53 <quicksilver> @karma+ ketil
05:41:53 <lambdabot> ketil's karma raised to 1.
05:45:16 <ketil> quicksilver: Unfortunately, parsec is one of the libraries "maintained" by libraries@, which of course is only open for posts by subscribers...
05:45:58 <ketil> In other words, patches will bounce.  I've raised this issue before, without really getting anywhere.  Sigh.
05:46:09 <ketil> @karma- libraries@haskell.org
05:46:09 <lambdabot> libraries@haskell.org's karma lowered to -1.
05:46:16 <quicksilver> you can subscribe and opt not to receive email
05:46:25 <quicksilver> which, effectively, just gives you permission to post
05:46:52 <ketil> quicksilver: hmm...yes.  I'm subscribed already, too, but with an email address that is ...inconvenient to use ATM.
05:47:23 <ketil> *I* can work around it - the *main* point is that darcs repo maintainers should be able to receive email from ..well, anybody.
05:48:23 <ketil> darcs makes it damn easy to fix issues like this.  Too bad if political decisions stop patches from reaching its destination.
05:48:42 * quicksilver writes a meta-spambot which scans the web for darcs repos and automatically 'darcs send's patches which incorporate automatic spam features into the project
05:48:59 <ketil> Or: if you want help, don't make it harder than necessary for people to help you.
05:49:02 <ketil> quicksilver: :-)
05:50:09 <ketil> quicksilver: well - any patch will presumably pass through a person before hitting the main repo.  And harvesting darcs repos for mail addresses seems a lot of work to reach very few targets.  So I'm not overly worried.
05:50:34 <quicksilver> tis fair :)
05:51:59 * roconnor sends a patch to disable quicksilvers meta-spambot
05:53:29 <EvilTerran> "if you want help, don't make it harder than necessary for people to help you." -- very succinctly put. hey, at least they aren't using bugzilla.
05:54:05 * EvilTerran wants to stab people who have bugzilla as their user-facing bug report system
05:57:12 <EvilTerran> instead, i take the passive-agressive route, and don't report their bugs ;)
06:00:27 <mrd> how's icfp going
06:01:04 <mrd> must be good, everyone's busy=)
06:08:22 <ketil> EvilTerran: actually, I think we should integrate some kind of ticket system with Hackage.
06:08:47 <ketil> Probably trac (not that I'm enthusiastic about it, but it seems to be what people are using these days)
06:08:47 <EvilTerran> i guess that'd work
06:09:05 <ketil> Hackage -> HaskellForge :-)
06:09:35 <EvilTerran> it's having to go through a sign-up process to submit one bug that annoys me about bugzilla
06:09:51 <Igloo> ketil: The problem is balancing making it easy for users (all packlages use the same BTS) vs forcing developers to use a particular BTS
06:10:16 <EvilTerran> if i didn't have to register, or could do so once for everything on hackage, i'd be happy
06:10:55 <allbery_b> I'm mixed onm the registration thng
06:10:59 <allbery_b> yes, it's annoying
06:11:11 <allbery_b> spam, however, is often worse than merely annoying
06:11:28 <quicksilver> does trac have darcs integration yet?
06:11:33 <quicksilver> I thought it was pretty well tied to svn?
06:11:40 <EvilTerran> spam blocking/filtering can be done pretty effectively
06:12:27 <quicksilver> with' [lighting := Enabled, currentColor := Color4 1 0 1 0]
06:12:31 <quicksilver> ^^ I'm quite happy with that
06:12:40 <quicksilver> passing a "list of temporary assignments"
06:12:43 <quicksilver> and it's type-safe, too
06:17:38 <SaMBuCa_> hi
06:24:59 <EvilTerran> the FFI doesn't support access to global variables, does it?
06:25:46 <EvilTerran> the c2hs docs mention explicitly that *that* doesn't do 'em, but i can't find an explicit "i cannae do it, cap'n" in the FFI docs
06:26:29 <dylan> global C variables?
06:26:35 <EvilTerran> yes
06:26:37 <dylan> I believe you can.
06:27:16 <dylan> when I wrote a SLang binding, I had to read/write some globals.
06:27:56 <EvilTerran> i can't see a way of doing it without writing a getter and setter in C
06:30:30 <EvilTerran> could do it with hsc2hs
06:31:17 <dvde> hello is there anybody?
06:32:11 <EvilTerran> actually, couldn't, without writing getter/setters myself again.
06:33:25 <EvilTerran> ah, there it is
06:33:46 <EvilTerran> "For import declarations, the syntax for the specification of external entities under the ccall calling convention is as follows: ... The first alternative either imports a static function cid or, if & precedes the identifier, a static address."
06:34:35 <EvilTerran> "...foreign import ccall "&" bar :: Ptr CInt"
06:37:45 <Tac-Tics2> In Haskell, can you mix brackets and Offsides rule in the same file?
06:37:56 <matthew_-> yep
06:38:09 <Tac-Tics2> I must be doing something wrong
06:38:33 <matthew_-> the only thing you can mix is literal and non-literal
06:38:39 <matthew_-> use hpaste?
06:38:49 <Tac-Tics2> can't*? right?
06:38:58 <matthew_-> right, sorry
06:39:09 <EvilTerran> if a block is delimited with {}s, you have to break lines with ;, iirc
06:39:15 <matthew_-> yes
06:39:28 <EvilTerran> the { turns off layout entirely for that block
06:39:29 <matthew_-> but you can have nested blocks within that that use offside
06:40:20 <hpaste>  Tac-Tics pasted "wayward 'in' in mixed brackets and offsides" at http://hpaste.org/3051
06:40:27 <Tac-Tics2> I got it working
06:40:40 <Tac-Tics2> but I would still like to know why the "in" keyword was causing issues
06:40:44 <Tac-Tics2> because deleting it fixed it
06:41:33 <EvilTerran> try putting the in back, with no newline after it?
06:42:34 <matthew_-> you don't need in with a do block
06:42:53 <matthew_-> and it might be a syntax error to have one - not sure
06:43:16 <Tac-Tics2> that got it
06:43:17 <EvilTerran> i think it's seeing that as main = do { let { list = do { ... } } in; print list }
06:43:22 <matthew_-> personally, if you use { and }, I really hate trailing ;. leading ; (line them up under the { and above the } is much prettier
06:44:02 <matthew_-> on the other hand, I have been known to have endless arguments about formatting...
06:44:03 <EvilTerran> matthew_-, it may be more consistent, but it does require separating one's concept of ;-in-haskell from ;-in-english
06:44:23 <quicksilver> "in" is not correct in a do block
06:44:25 <EvilTerran> (not that that's necessarily a bad thing, but it's unnatural 'til you get used to it)
06:44:31 <quicksilver> or, to be slightly more precise
06:44:32 <Tac-Tics2> matthew_-: I was born a ; trailer, and I will die a bloody ; trailer
06:44:35 <EvilTerran> > do let x = 1 in return x
06:44:36 <lambdabot>   add an instance declaration for (Show (t1 t))
06:44:42 <EvilTerran> > do let x = 1 in [x]
06:44:43 <quicksilver> "in" is perfectly correct, but it introduces an expression
06:44:43 <lambdabot>  [1]
06:44:51 <quicksilver> not the special 'do' form of 'let'
06:45:00 <EvilTerran> > do let x = 1 in; [x] -- this is what was happening, i think
06:45:00 <lambdabot>  Parse error
06:45:06 <quicksilver> excatly
06:45:16 <quicksilver> you could move 'print list' up onto the same line as the 'in'
06:45:21 <quicksilver> then it would be an expression-let
06:45:24 <quicksilver> instead of a do-let
06:45:43 <quicksilver> and you'd have a do block containing only one statement
06:45:49 <quicksilver> (which is permitted, of course)
06:45:50 <hpaste>  Tac-Tics annotated "wayward 'in' in mixed brackets and offsides" with "Empty 'do' construct line 4" at http://hpaste.org/3051#a1
06:45:55 <Tac-Tics2> what about that one?
06:46:08 <EvilTerran> "do { let {BINDS}; EXPS }" is the same as "let {BINDS} in do {EXPS}" anyway, isn't it?
06:46:22 <quicksilver> Tac-Tics2: you need to indent 'x <-' at least one more char
06:46:29 <matthew_-> Tac-Tics2: there you're trying to print an expression of type IO [Int]
06:46:39 <quicksilver> Tac-Tics2: where it stands it looks like it's part of the let
06:46:47 <Tac-Tics2> bah
06:46:48 <quicksilver> EvilTerran: yes, it is
06:46:55 <matthew_-> you might want to actually evaluate that expression with <- or >>= so that print prints the [Int] rather than the expression
06:46:55 <quicksilver> Tac-Tics2: remember lets are layout, too
06:46:59 <quicksilver> Tac-Tics2: not only dos
06:47:02 <Tac-Tics2> Haskell is annoying with that "variable tab" nonsense
06:47:11 <Tac-Tics2> with python, it's 4 spaces or go home!
06:47:27 <quicksilver> even under the 4 spaces rule you'd be in violation
06:47:34 <quicksilver> since x<- is 4 spaces past the 'let'
06:47:35 <Tac-Tics2> I know
06:47:40 <quicksilver> so therefore it's part of the let :)
06:47:41 <Tac-Tics2> my least favorite keyword in haskell is "where"
06:47:44 <idnar> Tac-Tics2: mixing tabs and spaces is pretty much discouraged for python code, too
06:47:50 <Tac-Tics2> because it's two letters too long!
06:47:54 <sysfault> python allows any amount of spaces, as long as they're consistent.
06:48:16 <Tac-Tics2> idnar, I use only spaces. I didn't mean literal \t chars
06:48:31 <idnar> Tac-Tics2: ah. then I'll refer you to what sysfault said
06:48:34 <Philippa> you just shouldn't use \t really
06:48:42 * EvilTerran tends to put the "where" at the end of the line, if it's part of a one-line definition (not counting the where block)
06:48:51 <EvilTerran> foo = bar baz where
06:48:54 <EvilTerran>     bar = ...
06:49:01 <EvilTerran>     baz = ...
06:49:04 <sysfault> idnar is referring to the tab key, which can configured to be any amount of spaces with most editors.
06:49:35 <quicksilver> EvilTerran: I don't like that idiom much anyhow
06:49:48 <quicksilver> EvilTerran: (very short initial definition with all subterms being defined in where clause)
06:50:03 <EvilTerran> otherwise, i put it on a line on its own, to put a bit of space between the big block above and the big block below
06:50:12 <EvilTerran> what's to dislike, quicksilver?
06:50:13 <hpaste>  Tac-Tics annotated "wayward 'in' in mixed brackets and offsides" with "Solving the "where" issue" at http://hpaste.org/3051#a2
06:50:22 <Tac-Tics2> but anyway
06:50:24 <quicksilver> EvilTerran: just not the order I choose to present my code :)
06:50:25 <Philippa> EvilTerran: it's top-down vs bottom-up, quicksilver's a bottom-up type
06:50:26 <Tac-Tics2> I'm late for work~
06:50:31 <Tac-Tics2> bye for now
06:50:39 <EvilTerran> i see. i like top-down for that sort of thing
06:50:48 <quicksilver> the coolest use for where clauses is sharing common definitions between guarded clauses
06:51:04 <quicksilver> to be honest, I also avoid local definitions because I like separable testability
06:51:16 <EvilTerran> i can get the gist of the function from one line, or i can look further down for more detail if i want it
06:51:20 <quicksilver> if something can be hoisted to the global scope (i.e. doesn't capture local variables) I often do
06:51:31 <EvilTerran> yes, that's definitely true
06:51:31 <quicksilver> EvilTerran: If that was true, then I'd agree entirely
06:51:35 <EvilTerran> code re-use!
06:51:45 <quicksilver> EvilTerran: but all too often, it's literal "foo = bar baz"
06:51:52 <quicksilver> EvilTerran: that doesn't give you the gist at all
06:52:04 <quicksilver> EvilTerran: the *entire* ifnormation content of that is "this is defined by an application"
06:52:06 <Philippa> I'm trying not to hoist too much, though I realise testability's a cost
06:52:16 <EvilTerran> yeah, that sucks
06:52:16 <quicksilver> and, that's not very suprising, given that this is lambda-calculus :)
06:52:25 <quicksilver> most things are either applications or abstractions..
06:52:25 <takamura> hi
06:52:26 <quicksilver> ;)
06:52:47 <Philippa> that's only the entire info content if you assume identifiers don't carry any info that wouldn't be in, say, a numeral
06:53:12 <quicksilver> Philippa: true
06:53:14 <EvilTerran> i was thinking more of things like "foo = foldr pushDigit 0 where\npushDigit x e = 10 * e+x"
06:53:18 <quicksilver> Philippa: I exaerrate slightly
06:53:27 <quicksilver> or perhaps more than slightly :)
06:53:37 <quicksilver> I'm saying, I particularly don't like that approach when taken to extremes
06:53:55 <quicksilver> EvilTerran: but foldr (\x e -> 10 * e+x) 0 is much nicer, IMO :)
06:54:08 <EvilTerran> well, that's a matter of opinion
06:54:12 <quicksilver> of course
06:54:16 <quicksilver> hence the "IMO" tag!
06:54:17 <quicksilver> :P
06:54:23 <EvilTerran> i'd almost be tempted to write foldr ((+).(10*))
06:54:24 <quicksilver> all of this is matters of opinon
06:54:39 <EvilTerran> actually, that'd need a flip, wouldn't it? never mind
06:54:51 <quicksilver> @pl \x e -> 10 * e + x
06:54:51 <lambdabot> (. (10 *)) . (+)
06:54:55 <EvilTerran> (or a (.) section)
06:55:10 <EvilTerran> mine would work for foldl ;)
06:55:11 <quicksilver> but, the fact that neither of us knew immediately which was correct is strong evidence that that's not a great idea :)
06:55:33 <EvilTerran> as i said, "almost tempted"
06:55:45 * quicksilver nods
06:56:06 <EvilTerran> i try to avoid lambdas most of the time, anyway
06:56:30 <quicksilver> curry $ (uncurry (+)) . (first (10*)) ?
06:56:40 <quicksilver> at least then it's very clear which part is getting the 10*
06:56:44 <quicksilver> because 'first' is clear :)
06:56:50 <EvilTerran> they've got their uses, but anything much longer than (\x e -> 10 * e+x) warrants its own binding
06:56:52 <EvilTerran> imo
06:57:14 <quicksilver> I use quite long lambdas with some constructs
06:57:28 <quicksilver> 'withArray' type stuff
06:57:31 <EvilTerran> shouldn't that be "second" in this case, anyway?
06:57:39 <quicksilver> yes :)
06:57:57 <quicksilver> withArray [1..100] $ \a -> do ......
06:57:59 <EvilTerran> liftM2 (+) id (10*) -- :D
06:58:43 <EvilTerran> yes, they make sense for those sort of faux-imperative-blocks structures
06:59:00 <EvilTerran> forM and whatnot
07:00:16 <quicksilver> binding constructs, in other words
07:00:30 <EvilTerran> yeah, that's closer to the term i was looking for
07:00:30 <quicksilver> because lambda is the binder we have to play with
07:01:23 <EvilTerran> but particularly when the "callback" is a do block
07:04:03 <hpaste>  EvilTerran pasted "where{} is also useful if your helper function needs to pattern-match" at http://hpaste.org/3052
07:06:14 <hpaste>  quicksilver annotated "where{} is also useful if your helper function needs to pattern-match" with "why not this?" at http://hpaste.org/3052#a1
07:06:24 <quicksilver> oh, I see
07:06:28 <quicksilver> sorry being stupid
07:06:57 <hpaste>  quicksilver annotated "where{} is also useful if your helper function needs to pattern-match" with "this, rather" at http://hpaste.org/3052#a2
07:07:17 <EvilTerran> terseness, in that particular case
07:07:27 <EvilTerran> i think my version's more elegant; less repeating myself
07:08:00 <EvilTerran> i'm betting you used copy-and-paste (or equivalent) in the process of writing that; that's never a good sign ;)
07:13:16 <quicksilver> actually I used rectangular editing to edit 3 lines at once :)
07:13:29 <EvilTerran> "(or equivalent)"
07:14:03 <EvilTerran> by which i meant "used mechanical methods to make it easier to write the redundant bits"
07:14:13 <quicksilver> I agree there is some textual redundancy
07:14:26 <quicksilver> but I also think it looks nice
07:14:31 <quicksilver> subjective again
07:14:36 <EvilTerran> yeah. i think mine looks nice ;)
07:15:03 <EvilTerran> yeah, it can be very subjective, though. even though i prefer mine there, i really don't like
07:15:06 <EvilTerran> @src foldr
07:15:06 <lambdabot> foldr k z xs = go xs
07:15:06 <lambdabot>     where go []     = z
07:15:06 <lambdabot>           go (y:ys) = y `k` go ys
07:16:38 <EvilTerran> sjanssen, i was randomly looking at http://hpaste.org/3044 just there -- there's a {-# LANGUAGE UndecidableInstances #-}, btw.
07:17:00 <dino-> Haddock can't be used, period, with any source that's using TH?
07:17:09 <quicksilver> EvilTerran: that form isn't designed to look nice
07:17:20 <EvilTerran> quicksilver, yes, i know, it's marginally more efficient
07:17:26 <sjanssen> EvilTerran: yep, I had to turn those on because I nested type families
07:17:30 <quicksilver> EvilTerran: it exploits ghc's pecularities to get slightly more sharing
07:17:40 <sjanssen> eg. n :*: Factorial n
07:18:02 <EvilTerran> sjanssen, figures, i was just observing that you used the {-# OPTIONS #-} version, even though you did everything else by {-# LANGUAGE #-}
07:18:18 <sjanssen> EvilTerran: I don't think there's a LANGUAGE pragma for undecidable instances
07:18:21 <sjanssen> is there?
07:18:48 <EvilTerran> yup
07:19:05 <EvilTerran> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html#v%3AUndecidableInstances
07:19:07 <lambdabot> http://tinyurl.com/2c2g5y
07:20:25 <EvilTerran> (i seem to recall L.H.Extension is deprecated, but regardless, it's the only list of LANGUAGE things i know of
07:22:00 <sjanssen> EvilTerran: also http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html
07:22:02 <lambdabot> http://tinyurl.com/37zxes
07:22:07 <sjanssen> the list of extensions Cabal knows about
07:22:38 <EvilTerran> hm. that'll be handy to know if i ever get around to doing something cabal-worthy.
07:23:18 <mux> heh, same thing here; I keep writing lots of useless code, fooling around with bindings to useless libs and such :)
07:23:21 <mux> nothing cabal-worthy
07:23:33 <EvilTerran> yak-shaving!
07:24:05 <fasta> How can I load modules A and B in GHCi? Currently only the symbols from A are exported and not from B. The lines looks like *A B. Do I have to touch B first?
07:24:17 <mux> :m +B
07:24:24 <fasta> mux: no, that doesn't work
07:24:28 <mux> ah?
07:24:28 <quicksilver> sjanssen: weirdly, Distribution.Exension claims to be deprecated in favour of L.H.Extension :P
07:24:47 <EvilTerran> (http://sethgodin.typepad.com/seths_blog/2005/03/dont_shave_that.html)
07:24:48 <lambdabot> Title: Seth's Blog: Don't Shave That Yak!, http://tinyurl.com/6er93
07:25:23 <quicksilver> fasta: *A B means you have all *exported* modules from B, but not the unexported ones
07:25:30 <quicksilver> fasta: s/module/symbol/
07:25:49 <fasta> quicksilver: right, but that's not what I want. I just exported everything as a work around now.
07:26:03 <quicksilver> fasta: :m *+B
07:26:07 <quicksilver> or :m +*B
07:26:11 <quicksilver> can't remember
07:26:45 <fasta> Reloading the current module set is also still not implemented, right?
07:27:12 <quicksilver> not as far as I know
07:30:59 <Tac-Tics> back~
07:45:18 <TSC`> If I have a QuickCheck generator, is there an easy way to generate a few values from the generator, just to see if it's working?
07:46:33 <xerox> TSC: maybe |quickCheck $ \x -> trace (x :: TestType) True|
07:47:35 <ac> Hello
07:48:52 <stoic> ?bot
07:48:52 <lambdabot> :)
07:49:09 <ac> huh?
07:49:42 <TSC> xerox: That's not bad, but it would be nice to do it with a "Gen a" instead of an Arbitrary instance
07:50:02 <TSC> What I'd really like is if "generate" returned the modified StdGen...
07:50:52 <stoic_> Why isn't lambdabot responding in PM?
07:51:37 <Tac-Tics> because she doesn't love us any more
07:51:48 <stoic_> :-\
07:51:56 <ac> newbie question: is there a quick version of (\x -> (x, 0))? (,0) doesn't work...
07:52:10 <quicksilver> ac: no, not really
07:52:21 <quicksilver> ac: for \x -> (0,x) you can use "(,) 0"
07:52:23 <quicksilver> but that's all
07:52:27 <quicksilver> you can't section the comma
07:52:39 <quicksilver> TSC: why isn't 'generate' what you want?
07:52:40 <ac> ok thanks :)
07:52:54 <quicksilver> stoic_: perhaps you're not registered with freenode
07:53:18 <stoic_> > sum [ logBase 10 x | x <- [1..86000] ]
07:53:20 <lambdabot>  387020.40770284936
07:54:25 <TSC> quicksilver: It takes a StdGen but doesn't return the modified one
07:54:42 <stoic_> I registered but she still wont respond
07:54:56 <TSC> Doing "map (\n -> generate 10 (mkStdGen n) generator) [1..10]" feels a bit wrong
07:55:01 <ari> I think it's because it's lambdabot that's not identified
07:55:21 <stoic_> has anyone ever considered making a web interface for lambdabot?
07:55:26 <Tac-Tics> @type generate
07:55:28 <lambdabot> forall a. Int -> StdGen -> Gen a -> a
07:55:42 <xerox> ?where lambdaweb
07:55:42 <lambdabot> http://lambdabot.codersbase.com
07:55:52 <quicksilver> Tac-Tics: you don't need a new stdgen each time
07:56:08 <Tac-Tics> I don't?
07:56:18 <quicksilver> no, cos you vary the '10'
07:56:23 <quicksilver> the first parameter to generate
07:56:23 <stoic_> xerox: amazing, thank you very much...wish I had known about that sooner
07:56:33 <xerox> ac: flip (,) 0
07:56:36 <ari> stoic_: Try /msg nickserv set unfiltered on
07:56:37 <dino-> :t ((,) 0)
07:56:40 <lambdabot> forall t b. (Num t) => b -> (t, b)
07:56:49 <quicksilver> Tac-Tics:  map (\n -> generate n gen (arbitrary :: Gen Int)) [1..20]
07:56:50 <Tac-Tics> quicksilver, I wasn't saying anything about StdGen, I just wanted to know what generate did
07:57:06 <quicksilver> Tac-Tics: that gives you 20 items
07:57:06 <dino-> :t (flip (,) 0)
07:57:08 <lambdabot> forall a b. (Num b) => a -> (a, b)
07:57:16 <quicksilver> Tac-Tics: here 'gen' is a StdGen I made earlier
07:57:22 <quicksilver> Tac-Tics: it doesn't relaly matter where you get it from :)
07:57:25 <ac> clever
07:57:26 <xerox> ac: or even (id &&& const 0) but that might be too much.
07:57:27 <TSC> What is the first parameter to generate?
07:57:32 <stoic_> ari: that works thanks
07:57:41 <quicksilver> TSC: it's a sequence number
07:57:43 <xerox> stoic_: hope it works still (:
07:57:50 <dino-> I was thinking, wait, (,) 0 wrong position..
07:57:52 <quicksilver> Tac-Tics: I address one of those comments to you when I meant to address it to TSC
07:58:01 <dino-> in the tuple
07:58:01 <quicksilver> Tac-Tics: sorry :)
07:58:03 <Tac-Tics> hehe
07:58:05 <Tac-Tics> sallright
07:58:14 <quicksilver> TSC: did you see my map?
07:58:22 <quicksilver> TSC:  map (\n -> generate n gen (arbitrary :: Gen Int)) [1..20]
07:58:59 <stoic_> xerox: it doesn't "No lambdabot process" :P but I will try to implement it with my lambdabot if the source for the web interface is available
07:59:09 <LeCamarade> Comrades, I am in the middle of the most sneaky Haskell propaganda I've ever read. I'm writing it for internal circulation, but I guess I will push it out as well. It's neat.
07:59:09 <TSC> quicksilver: It seems to return the same thing 20 times
07:59:13 <xerox> stoic_: yup, I believe they are.
07:59:36 <TSC> Wait, maybe my generator is broken
08:01:15 <TSC> Thanks, quicksilver, that's clearly what I need, but I have to fix my generator
08:01:53 <ac> What's the quick answer to way I can't simply paste haskell code in to ghci?
08:02:24 <ibid> you can, if it's expressions
08:02:36 <byorgey> ac: you can't define data types in ghci.
08:02:39 <ibid> but ghci doesn't do declarations
08:02:53 <byorgey> ac: just put the stuff in a file, and load it in ghci using :load.
08:02:54 <ibid> (apart from what you can do inside do expressions:)
08:03:20 <ac> byorgey: right. this is what I'm doing... easy enough. I was just curious what the underlying issue was
08:03:31 <quicksilver> TSC: good :) because now you found the bug in your generator
08:03:38 <quicksilver> TSC: which is what you wanted, I think :)
08:03:41 <ac> "can't define data types in ghci" was the answer I was looking for
08:03:54 <ibid> ac: the underlying reason is a bit complex :)
08:04:08 <quicksilver> in fact, it's not a ridiculous idea to ask for local data type definitions
08:04:11 <quicksilver> some languages permit it
08:04:22 <quicksilver> but I think the haskell committee thought the power-weight ratio wasn't that good
08:04:45 <integral> lots of small modules, I guess
08:05:12 <ibid> typelet? :)
08:06:43 <quicksilver> integral: well given that types don't really exist at runtime in, say, GHC, local types aren't an efficiency issue at all
08:06:57 <fasta> Does adding type annotations speed up the the type-inference process?
08:07:02 <quicksilver> integral: they're just "another feature" making compilers more complex
08:07:21 <quicksilver> fasta: I wouldn't think they speed it up asymptotically
08:07:33 <ibid> fasta: not in the common cases, i'd think
08:07:34 <quicksilver> fasta: in some cases they might make a type mismatch appear earlier, saving a constant factor
08:07:50 <quicksilver> fasta: I don't think it should make any difference on correct code
08:07:57 <quicksilver> (might catch bugs slightly faster in incorrect code)
08:08:13 <dino-> LeCamarade: Reading or writing this propoganda yourself? Send us a link!
08:08:14 <ac> since y'all are so helpful, I'll pester you with more questions... What arguments (if "arguments" is the term... type variables?) does the Array type expect
08:08:22 <fasta> Reloading a module should work in < 0.3 seconds not the 5 seconds or more it's taking now.
08:08:27 <hpaste>  TSC pasted "sized or not" at http://hpaste.org/3053
08:08:29 <quicksilver> ac: the type of 'index' and the type of 'element'
08:08:41 <TSC> I think my problem is a misunderstanding of how QuickCheck works at all...
08:08:45 <ac> so you can have non-integer indexing?
08:08:49 <quicksilver> ac: right
08:08:51 <fasta> I wonder how fast the same amount of code would load in a Scheme implementation.
08:08:52 <TSC> I don't see how "sized" makes it different
08:08:53 <quicksilver> ac: tuples are the most common
08:08:58 <ac> cool
08:09:09 <quicksilver> ac: to make 'multi dimensional arrays'
08:09:15 <quicksilver> ac: e.g. (0,0) -> (10,15)
08:09:34 <quicksilver> ac: you can use any type which you can make an instance of the class 'Ix'
08:11:39 <ac> could you look at a 2x2x3 array as a 2x2 array of 3-tuples? I mean wouldn't Array (Int,Int) (Int,Int,Int) be the same as Array (Int,Int,Int) Int?
08:12:24 <fasta> ac: it depends on boxing properties.
08:13:04 <ac> fasta: so you're saying that's actually sometimes true
08:13:36 <byorgey> ac: you could look at it that way, but the type checker certainly wouldn't consider them the same.
08:13:41 <fasta> ac: if you look at it semantically, yes.
08:14:10 <quicksilver> ac: right, there is a difference in terms of where non-terminaation can occur
08:14:30 <quicksilver> ac: also, Array (Int,Int,Int) Int doesn't prove that the 3rd coordinate only has the range [1..3]
08:14:40 <quicksilver> ac: the bounds aren't stored in the type, in fact
08:15:10 <quicksilver> ac: in fact, everything is isomorphic to Array (Int) at some level, since you can obviously transform your indexes to the integers. It's just convenient.
08:16:41 <ac> I see, so there must be runtime bound checking. I read somewhere about how you can bypass it with something like unsafeWrite. But is there a compile time bound checking alternative?
08:17:10 <ac> nevermind. stupid question
08:17:16 <quicksilver> it's not a stupid question
08:17:20 <quicksilver> but there isn't, as it happens
08:17:30 <quicksilver> compile-time bound checking in haskell requires type-level numbers
08:17:38 <ac> right. that's what I realized
08:17:44 <quicksilver> which tends to be a bit sntactically ugly
08:17:46 <quicksilver> but you can do it
08:18:32 <phobes> but you shouldn't do it !
08:33:49 <Tac-Tics> why didn't they just call it Text.Parser?
08:34:22 <Tac-Tics> module names are as far from the terseness of the remainder of the language as you can get
08:35:31 <Cale> heh, we should add Module or Library to the end of all the module names, just to make them longer :)
08:36:29 <Cale> ControlModules.ConcurrentLibraries.STMLibraries.TChanModule -- and mix it up a bit, to make it hard to remember
08:36:30 <byorgey> TextModules.ParserCombinatorLibraries.ParserCombinatorLibraryNamedParsec
08:36:33 <phobes> Haskell would benefit from auto-complete-and-add-import that you find in Eclipse
08:36:45 <Tac-Tics> how would one use Parsec to match the longest string in an input where a pair of terminal characters are not found?
08:37:09 <Cale> notFollowedBy ?
08:37:26 <Tac-Tics> ah thank you
08:37:36 <Cale> Heh, there's Text.ParserCombinators.Parsec.Combinator
08:37:50 <Tac-Tics> yeah
08:37:56 <quicksilver> Cale: it would be good if there was also Text.ParserCombinators.Parser.Combinator
08:38:10 <quicksilver> Cale: which should export exactly the same symbols, at the same types, but doing something totally different
08:38:31 <mux> Graphics.Rendering.OpenGL.GL.PixelRectangles.Rasterization
08:38:36 <mux> now that's a long module name
08:38:42 <Tac-Tics> is there a regular "many"?
08:38:45 <Tac-Tics> not many1?
08:38:49 <mux> Tac-Tics: yes
08:38:50 <fasta> Tac-Tics: yes
08:38:54 <Tac-Tics> err
08:38:56 <Tac-Tics> hm
08:38:58 <fasta> Tac-Tics: it's called many
08:39:02 <mux> @hoogle many
08:39:03 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
08:39:04 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
08:39:04 <lambdabot> Text.ParserCombinators.ReadP.many1 :: ReadP a -> ReadP [a]
08:39:12 <Tac-Tics> I was going to ask what it was called, then I realized I was being dumb
08:39:18 <Tac-Tics> I'm looking in the docs, and I didn't see it
08:39:22 <Cale> GAP seriously needs a module system
08:39:25 <Tac-Tics> but I remember there being one and I got confused
08:39:40 <Tac-Tics> It's in Prim I guess
08:39:46 <fasta> @where GAP
08:39:46 <lambdabot> I know nothing about gap.
08:40:26 <Cale> the libraries that get loaded when you start it have functions with names like SetCanonicalRepresentativeDeterminatorOfExternalSet
08:41:14 <byorgey> yeesh
08:41:34 <Cale> AugmentedCosetTableNormalClosureInWholeGroup
08:41:34 <LeCamarade> dino-: I will! :o)
08:42:08 <dino-> I find that avoiding use of IDEs with autocomplete stuff helps me to learn the APIs myself. But it's important to be able to run API doc generation.
08:43:21 <Cale> HasUnderlyingSemigroupElementOfMonoidByAdjoiningIdentityElt
08:43:33 <fasta> Cale: how would a module system help?
08:43:45 <Cale> It would allow some of these things to be hidden.
08:44:03 <fasta> In Haskell it would be hidden in the type.
08:44:12 <fasta> (assuming type class structure)
08:45:39 <Cale> IsMultiplicativeElementWithInverseByPolycyclicCollectorCollection -- heh, that's just ridiculous :)
08:47:19 <ramza3_> cale: at least they didnt use acronyms
08:47:22 <phobes> You just need ctrl-space... then you'll be generating LoC at a quicker clip than you ever have before!
08:47:34 <dino-> Also, ctags is useful for non-IDE editors like vim.
08:48:13 <Cale> phobes: well, tab completion works at its commandline at least
08:49:22 <fasta> When are people going to stop suggesting inferior incorrect tools like ctags?
08:50:08 <Zevv> so, what is your superior and correct suggestion ?
08:50:56 <fasta> Zevv: Eclipse, NetBeans, Smalltalk IDEs, IntelliJ all do it right, AFAIK.
08:51:38 <Zevv> unfortunately those scale a bit different then a simple tool as ctags
08:51:50 <phobes> Those are IDEs with intimate knowledge of the language
08:51:56 <fasta> Zevv: what do you mean by "scale"?
08:52:32 <Zevv> sorry, that was not very clear. I mean that cscope is a small tool you can integrate in whatever environment you prefer, while all the others are huge and bring their own IDE's, editors and all
08:53:00 <Zevv> so I was actally hoping you know an 'instant replacement' of cscope
08:53:07 <Zevv> which could integrate with my enviroment of choice
08:53:12 <Zevv> s/know/knew/
08:53:29 <fasta> Zevv: you cannot have a non-language aware tool be language aware from nothing.
08:53:59 <Zevv> Ok, but why is it then that things like Eclipse cna do the job, while - for example - vim/cscope will fail ?
08:58:40 <quicksilver> Zevv: there's  nothing wrong with ctags in principle
08:58:55 <quicksilver> Zevv: but hasktags is imperfect in practice
08:59:44 <quicksilver> Zevv: however, certainly one difference is that the posh IDEs update instantly as you edit
09:00:01 <quicksilver> Zevv: you're not alone in wanting a nice type-aware addon for vim/emacs
09:00:11 <Zevv> that would me nice yes
09:00:35 <Zevv> ctags does the job just fine for me for now, still
09:00:44 <Zevv> I guess you don't miss what you don't have
09:02:46 <quicksilver> Zevv: don't miss what you've never had, perhaps?
09:02:55 <quicksilver> Zevv: I think people frequently do miss stuff they don't have :)
09:14:32 <ac> quicksilver: yes, that describes me whenever I'm programming (or using a computer for that matter)
09:20:23 <andun> @pl \x y -> compare (snd x) (snd y)
09:20:23 <lambdabot> (. snd) . compare . snd
09:22:09 <allbery_b>  @pl doesn't know about on yet, I see
09:22:18 <allbery_b> = compare `on` snd
09:22:57 <idnar> @src on
09:22:58 <lambdabot> (*) `on` f = \x y -> f x * f y
09:23:24 <idnar> huh
09:23:45 * idnar twists his brain a little bit
09:23:46 <quicksilver> idnar: they are by no means working from the same database
09:24:01 <idnar> quicksilver: no, I was just confused for a little bit by that definition of on
09:24:04 * quicksilver nods
09:24:08 <quicksilver> local binding of *
09:24:13 <quicksilver> shadowing the global one
09:24:14 <quicksilver> cute ;)
09:24:30 <quicksilver> just a parameter binding
09:24:39 <idnar> that's equivalent to this, right? -- on product f = \x y -> product (f x) (f y)
09:24:48 <quicksilver> right
09:25:00 <idnar> great
09:25:04 <quicksilver> its just using (*) as a local name instead of product
09:25:10 <quicksilver> and also using the infix form of on
09:25:21 <idnar> yeah
09:25:33 <Tac-Tics> @index join
09:25:33 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:26:40 <fasta> Is there a foldM like function that can take more than 1 list elements at a time depending on user-code?
09:27:12 <quicksilver> :t foldM
09:27:15 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
09:27:34 <quicksilver> fasta: you mean a -> b -> b -> b -> m a ?
09:27:34 <fasta> quicksilver: I sometimes want to get two b's
09:27:37 * quicksilver nods
09:27:42 <quicksilver> no, there isn't
09:27:51 <quicksilver> how do you decide how many bs you want?
09:28:24 <quicksilver> based on the outcome of the previous 'action' ?
09:28:34 <fasta> quicksilver: No, based on the first b
09:28:41 <quicksilver> interesting
09:28:55 <quicksilver> no, there isn't anything like that
09:29:10 <quicksilver> I'd probably pair up the list
09:29:31 <fasta> I first had it written with manual recursion, which was a mess and buggy. Then I rewrote it to foldM, which seemed to work for a long time.
09:29:40 <quicksilver> and fold against something of the form (a -> (b,b) -> m a) -> a -> [(b,b)]
09:29:45 <fasta> But although "beautiful", was incorrect.
09:29:50 <quicksilver> :)
09:30:04 <quicksilver> it is so sad when the beautiful choice is not the correct choice
09:30:12 <quicksilver> many a married person will surely attest to that...
09:30:19 <fasta> heh
09:30:56 <Tac-Tics> I can't get this to work quite right
09:31:08 <Tac-Tics> parsing the longest string that does not contain 2 consecutive ;;'s
09:39:01 <vincenz> hey Cale ?
10:01:51 <tolik> @type tails
10:01:53 <lambdabot> forall a. [a] -> [[a]]
10:02:40 <tolik> fasta: you can combine foldM with tails, probably
10:04:01 <fasta> tolik: The space usage is O(length of list) for tails when used in combination with foldM?
10:04:51 <fasta> tolik: and the time usage should also be linear.
10:05:04 <fasta> (which I believe should be possible)
10:05:14 <ac> how do you make a 0 argument lambda?
10:05:24 <Olathe> let f = 5 in f
10:05:28 <Olathe> > let f = 5 in f
10:05:30 <lambdabot>  5
10:06:04 <Olathe> So, you use (result), I suppose.
10:06:19 <Olathe> Like, for f, (5) would work.
10:06:19 <fasta> @source tails
10:06:19 <lambdabot> tails not available
10:06:22 <hkBst> > let f = (\ -> 5) in f
10:06:22 <lambdabot>  Parse error
10:06:23 <tolik> fatsa: i think space usage is O(1)
10:06:46 <tolik> @source Data.List.tails
10:06:46 <lambdabot> Data.List.tails not available
10:07:05 <Olathe> @src tails
10:07:05 <lambdabot> tails []         = [[]]
10:07:05 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
10:07:20 <Botje> ac: you can't create thunks in haskell. but you can just generate a value and let it be evaluated when necessary, i guess
10:07:23 <hkBst> ac: it would just be a constant
10:08:33 <ac> hm. I have a function that returns IO () and I want it to return IO Bool. Perhaps I should just read one of those many monad tutorials :P
10:09:27 <tolik> ac: and what that Bool would be?
10:10:02 <ac> Always True
10:10:03 <MADnific1nt> ac: newFunk = oldFunk >>= \x -> return True    (I'm just a n00b, so I'm not sure at all)
10:10:29 <monochrom> That works. Or do it to the source code of oldFunk.
10:10:37 <tolik> ac: or just oldFunk >> returb True
10:10:42 <tolik> *return
10:10:59 <MADnific1nt> tolik: ooh, non-n00b
10:11:15 <MADnific1nt> tolik: my thought was silly
10:11:23 <ac> tolik: excellent
10:12:01 <tolik> MADnific1nt: your thought was equivalent :)
10:12:37 <MADnific1nt> tolik: yes, but I didn't use what I learned... I should've found the 'right' answer
10:27:25 <misterbeebee> aaargh.. I just fell into the cabal profiling trap. I installed a bunch of cabal pkgs without profiling. Now I can't profile my programs that use those pkgs until I rebuild all the cabal pkgs with profiling.
10:27:32 <ac> well thanks y'all for the help. This has been quite a productive first day of Haskell. It is a great language.
10:27:56 <misterbeebee> is there a way to compile my program in a way that tells ghc to not use profiling versions of certain underlying modules?
10:28:18 <misterbeebee> i don't see an option chapter 5: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
10:28:21 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/kwh6c
10:31:24 <xored> what should i better use, ghc or hugs ( gentoo =
10:31:40 <sjanssen> misterbeebee: non-profiling modules are incompatible with profiling modules
10:32:02 <sjanssen> xored: ghc
10:32:47 <misterbeebee> sjanssen: ok, thanks. when I catch my breath I'll rebuild my cabal packages. should be faster this time now that I'm getting the hang of the cabal build/install process
10:32:48 <sjanssen> xored: USE=binary if you don't want to want to wait a few hours for it to compile
10:32:58 <xored> sjanssen: fine
10:33:04 <fasta> xored: ghc is a compiler, ghci is the interpreter that you want to use for complex development. hugs loads faster for H98 code
10:33:27 <xored> iam a student learning haskell
10:33:44 <sjanssen> GHC is the better implementation overall
10:33:44 <fasta> xored: in that case maybe you even should use Helium.
10:33:51 <xored> so no need for any performance related things :) i just need the "easy to start" package..exams are tomorrow :)
10:34:04 <xored> fasta: Helium, one second, checking
10:34:17 <fasta> xored: Helium is not H98 compatible, though.
10:34:29 <sjanssen> fasta, xored: Helium is fairly incompatible with Haskell, probably not a good idea if you're taking a test over it
10:34:30 <fasta> xored: it makes some simplifications.
10:34:47 <fasta> sjanssen: I didn't know about the test when I suggested it.
10:34:49 <xored> no, i need the "defined" one
10:35:06 <xored> nothing which enhance the lang or simplifys
10:35:13 <xored> thank you guys, a lot of help in here
10:35:14 <fasta> xored: then take ghci
10:35:28 <xored> fasta: only have ghc or ghc.bin
10:35:42 <sjanssen> ghc-bin is fine
10:35:47 <fasta> xored: those are probably packages, and probably ghc includes ghci
10:36:02 <fasta> But sjanssen knows better obviously.
10:36:08 <fasta> I am not a Gentonian.
10:36:15 <xored> ok, last thing, iam "vim`er"..any plugins for syntax highlighting there ?
10:36:24 <puusorsa> both have ghci too
10:36:42 <puusorsa> take the bin one unless you particularly enjoy waiting
10:37:01 <fasta> Are those binary packages in Gentoo up to date?
10:37:02 <xored> puusorsa: done that, as sjanssen adviced me to do so
10:37:05 <puusorsa> no
10:37:11 <xored> fasta: i dont care :)
10:37:18 <fasta> xored: I do
10:37:25 <puusorsa> USE=binary emerge ghc .. installs the newer binary version
10:37:26 <xored> fasta: then use the source one
10:37:27 <puusorsa> iirc
10:37:37 <sjanssen> fasta: 6.4.2 is the stable one right now
10:37:49 <fasta> xored: I build from darcs directly.
10:37:59 <fasta> sjanssen: conservative bunch.
10:38:17 <fasta> Bugs probably don't get backported.
10:38:35 <puusorsa> 'USE=binary emerge ghc' gets you ghc 6.6.1 binary
10:38:40 <sjanssen> fasta: it took them awhile to do the switch from 6.4 to 6.6, the package is currently in the mandatory waiting period to be stabilized
10:38:58 <puusorsa> oh right, i have unstable
10:39:15 <takamura> xored: vim has haskell syntax highlighting by default in debian, maybe also in gentoo
10:40:14 <xored> takamura: thank you
10:42:35 * SimonRC goes to dinner
11:01:17 <Soroush82> ohhhh. many people in this room
11:02:02 <kaol> @users
11:02:03 <lambdabot> Maximum users seen in #haskell: 420, currently: 372 (88.6%), active: 12 (3.2%)
11:03:54 <Soroush82> haskell is just educational, isn't it?
11:04:16 <Soroush82> it isn't used for commerce seriously. is it
11:04:18 <Soroush82> ?
11:04:21 <elliottt> it's used seriously :)
11:04:31 <Soroush82> It can't give bin code
11:04:37 <elliottt> it can
11:04:40 <elliottt> ghc is a compiler
11:04:43 <Soroush82> it always need its compiler
11:05:05 <Soroush82> ghc compiles...
11:05:13 <takamura> the window manager i'm using is written in haskell
11:05:14 <elliottt> Soroush82: http://haskell.org/haskellwiki/Jobs#Industry_positions
11:05:15 <lambdabot> Title: Jobs - HaskellWiki
11:05:22 <elliottt> takamura: me as well :)
11:05:23 <Soroush82> you mean it gives independent exe file
11:05:27 <Zao> Soroush82: Since ghc is written in Haskell, how does it run itself then?
11:05:30 <elliottt> Soroush82: yes
11:05:48 <ac> Soroush82: AFAIK, the Haskell runtime is much smaller than many other popular "serious" languages
11:05:54 <Soroush82> great. what is an editor for haskell
11:06:05 <Zao> Soroush82: Any.
11:06:11 <Olathe> Soroush82: Which editor do you like ?
11:06:20 <dino-> Zao: You need a prior version of GHC in place to build a newer GHC. There's a bootstrapping process for new platforms, the GHC can output C source code.
11:06:30 <Zao> dino-: Aye. I've built a couple of them.
11:06:34 <Zao> Too bad none work :P
11:07:06 <dino-> Zao: Sorry, didn't recognize the rhetorical..
11:07:12 <Soroush82> I read sth about haskell and learned about it a little 2 years ago. I didn't find it useful then. especially just notpad could be
11:07:12 <Soroush82> used to edit its files
11:08:01 <Zao> dino-: Text is an awful medium.
11:08:32 <Soroush82> Olathe, I wnat sth some intelligent
11:08:52 <Soroush82> highlight code and complete
11:08:57 <Soroush82> what I write
11:09:01 <xored> what is the cmd line for ghc under unix ? ghc test.hs ist not working
11:09:04 <jr__> Soroush82: http://haskell.org/haskell-mode/
11:09:05 <lambdabot> Title: Haskell Mode for Emacs
11:09:30 <Zao> xored: ghc --make -o blah blah.hs   tends to float most boats.
11:09:35 <mux> xored: use ghc --make test.hs to compile it, or ghci test.hs to open the file in the interactive environment
11:09:48 <Soroush82> and when sb is in windows? is there an editor then
11:09:52 <Soroush82> ?
11:10:01 <Zao> Both emacs and vim have windows binaries.
11:10:06 <jr__> Soroush82: http://www.haskell.org/visualhaskell/
11:10:07 <xored> Zao: oO weired, its not working for me..what the heck. Checking.
11:10:07 <lambdabot> Title: Visual Haskell
11:10:08 <elliottt> actually, there's a visual studio plugin too
11:10:27 <elliottt> (iirc :)
11:10:27 <mux> Soroush82: haskell, like most languages is just plain text, and you can always use whatever editor you want
11:10:53 <xored> eix ghc -I -> i get that 6.4.2 is installed. What could be actualle the problem , that iam not able to run ghc?
11:11:05 <sjanssen> xored: ghc-bin installs somewhere in /opt, adjust your PATH
11:11:17 <mux> xored: both Zao and I already answered you
11:11:23 <xored> sjanssen: thank you.,
11:11:32 <mux> xored: do you have an error message or something?
11:11:45 <xored> mux: yes...but it was not thing i needed
11:11:51 <xored> Thank you together
11:11:53 <Soroush82> mux, can Haskell have a gui
11:11:59 <Soroush82> I mean the programs
11:12:06 <Soroush82> are written in that
11:12:29 <takamura> Soroush82, there is gtk2hs
11:12:30 <mux> Soroush82: there is a Visual Studio plugin for haskell if you are looking after an integrated development environment
11:12:59 <mux> to create a GUI program, there is gtk2hs yes, and other libs
11:13:00 <Soroush82> great
11:13:05 <mux> wxHaskell, etc
11:13:15 <Soroush82> I never thought these things about haskell
11:14:04 <araujo> dons, ping
11:14:09 <ac> Soroush82: For graphics there is HOpenGL, wxHaskell, and gtk2hs (which I am developing with right now)
11:14:19 <ac> Soroush82: there is also HGL
11:14:51 <Soroush82> great ac. Can you show me some real applications written in haskell
11:15:05 <Soroush82> Why people very very rarely use haskell
11:15:12 <mux> @where xmonad
11:15:12 <lambdabot> http://xmonad.org/
11:15:14 <elliottt> Soroush82: http://www.xmonad.org
11:15:15 <lambdabot> Title: xmonad : a tiling window manager
11:15:18 <elliottt> hah
11:15:22 <Soroush82> and a very few people know about it
11:15:23 <takamura> @where darcs
11:15:23 <lambdabot> http://darcs.net/
11:15:25 <kscaldef> Soroush82: because people rarely use haskell
11:15:26 <mux> @quote stereo
11:15:26 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
11:15:30 <mux> :)
11:15:31 <kscaldef> it's a catch-22
11:15:43 <ac> Soroush82: Haskell is relatively popular in my opinion
11:15:53 <kaol> http://haskell.org/haskellwiki/Applications
11:15:54 <lambdabot> Title: Haskell in practice - HaskellWiki
11:15:57 <elliottt> @where frag
11:15:57 <lambdabot> http://www.haskell.org/haskellwiki/Frag
11:16:06 <mux> Soroush82: haskell is quite different from the mainstream languages, and is thus often considered 'hard'
11:16:08 <ac> Soroush82: You've heard about it...
11:16:18 <elliottt> http://haskell.org/haskellwiki/Applications_and_libraries
11:16:20 <lambdabot> Title: Applications and libraries - HaskellWiki
11:16:43 <xored> !paste
11:16:44 <hpaste> Haskell paste bin: http://hpaste.org/
11:16:51 <elliottt> hey, good point :)
11:16:56 <ac> Soroush82: there are hundreds of programming languages, most of which you have not heard of
11:17:08 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3054
11:17:18 <Tac-Tics> bah
11:17:33 <Tac-Tics> how does one read in characters into Parsec in a nongreedy fashion?
11:17:34 <xored> what is actually wrong on mine example ( laste paste ) http://hpaste.org/3054
11:17:51 <Soroush82> ac, right. but I compared it with sth like python and other things like it. I mean functional programming isn't known
11:17:59 <Soroush82> for many people
11:18:04 <sjanssen> xored: please fill in the author and title blanks next time (hpaste's maintainer gets grumpy when you don't)
11:18:04 <Saizan> ac: there are thousands
11:18:08 <Philippa> Tac-Tics: use try if you need to backtrack
11:18:12 <xored> sjanssen: ok, sorry.
11:18:16 <sjanssen> xored: also, notice that hpaste will dump a link for you :)
11:18:28 <Olathe> xored: 'int x' doesn't seem right.
11:18:33 <xored> sjanssen: "new here" .. will addpet sir! :)
11:18:40 <sjanssen> xored: 'int x' is wrong, this is not C/Java/... ;)
11:18:40 <Soroush82> and I learned a bit about haskell when a profesor had a course about it in our university
11:18:56 <Soroush82> it's course was in Math department
11:19:09 <Soroush82> not in computer engineering :)
11:19:10 <sjanssen> xored: if you want to declare that x is an Int, "x :: Int"
11:19:27 <xored> sjanssen: ah it works like in methods, sorry, missunderstood that, thank you
11:19:33 <Tac-Tics> is there a way to write a combinator for nongreedy consumption using 'try' then?
11:19:38 <xored> sjanssen: *for* methods
11:19:39 <sjanssen> xored: next problem is that lonely 'print x' line -- it needs to be inside a function
11:19:49 <Tac-Tics> something like "longestWithout str :: Parser String"
11:20:03 <xored> sjanssen: wow, ok, ill fix that
11:20:13 <Tac-Tics> which takes a string and returns the longest string next up in the input until eof or until just before 'str' is found
11:20:17 <sjanssen> xored: you probably want to stick it inside the 'main' function
11:21:19 <Philippa> Tac-Tics: yep, in fact there's a combinator in the lib that does something like that
11:21:34 <Philippa> (I forget whether it returns the data it consumes)
11:21:37 <Tac-Tics> oh?
11:22:09 <Philippa> manyTill, IIRC
11:22:34 <Tac-Tics> I tried that, but maybe I didn't do it quite right
11:23:02 <elliottt> Tac-Tics: many . noneOf (str) ?
11:23:08 <elliottt> err, many1 :)
11:23:35 <Philippa> elliottt: no
11:23:59 <Philippa> consider what happens if you're after anything up to "#STOP"...
11:24:08 <elliottt> right
11:24:23 <Philippa> and feed it "STOP #STO PSTOPSTOP#STOP"
11:24:25 <elliottt> stops at any of # S T O or P
11:25:04 <hpaste>  xored pasted "first steps" at http://hpaste.org/3055
11:25:35 <sjanssen> xored: print :: Show a => a -> IO ()
11:25:39 <Philippa> Tac-Tics: try \str -> anyChar `manyTill` string str?
11:25:40 <sjanssen> notice the IO part
11:27:11 <xored> sjanssen: not sure i get this right, iam corrected it that way :
11:27:36 <hpaste>  xored annotated "first steps" with "first steps" at http://hpaste.org/3055#a1
11:29:08 <sjanssen> xored: yep, printit is okay now
11:29:31 <xored> haskell.hs:10:0: parse error (possibly incorrect indentation)
11:30:16 <monochrom> main = printit (foo 4)
11:30:16 <sjanssen> xored: you need to put the last line in a function
11:30:18 <sjanssen> main = ...
11:31:03 <xored> sjanssen: one second, my tutorial completly missed that. Do i need a kind of this "main" function?
11:31:20 <sjanssen> yes
11:31:31 <newsham> ?djinn (a -> b -> c) -> ((a,b) -> c)
11:31:32 <lambdabot> f a (b, c) = a b c
11:31:33 <sjanssen> monochrom's line above will work nicely
11:31:34 <takamura> which tutorial?
11:31:35 <newsham> is that right?
11:31:49 <sjanssen> newsham: looks right to me
11:31:51 <xored> takamura: http://www.haskell.org/~pairwise/intro/section1.html
11:31:52 <lambdabot> Title: Haskell for C Programmers
11:31:53 <monochrom> I learned Haskell from first principles.
11:32:04 <sjanssen> @type \a (b, c) -> a b c
11:32:06 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t1) -> t2
11:32:19 <newsham> ?type uncurry
11:32:21 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
11:32:32 <xored> guys i please you not to get angry about my, actually stupid questions. Iam trying my best to read it up in the docs first
11:32:56 <xored> monochrom: thank you
11:33:04 <newsham> ?djinn (a -> b -> c) -> (a, b) -> c
11:33:04 <lambdabot> f a (b, c) = a b c
11:33:41 <newsham> oh, heh, my bad.
11:33:45 <newsham> looks good to me too :)
11:34:16 <Olathe> @pl \a (b, c) -> a b c
11:34:16 <lambdabot> (`ap` snd) . (. fst)
11:34:34 <newsham> > (\a (b,c) -> a b c) (+) (2,3)
11:34:36 <lambdabot>  5
11:35:11 <ttfh> xored: I don't think there's anythin about IO in that section
11:35:43 <xored> ttfh: jap, sure, but iam trying always to do examples my way..but iam right now confused.
11:36:16 <xored> ttfh: i compiled it with ghc --make haskell.hs ...then started it with ghci haskel.o but there is not proper output...what iam getting wrong ?
11:36:35 <mux> xored: the output of ghc --make is a binary, an executable
11:36:36 <Zao> xored: ghci interprets .hs files.
11:36:54 <ttfh> xored: IO in haskell is confusing at first, it can be a good idea to just load your "foo" function into ghci to try it out
11:37:14 <monochrom> Your way seems too overwhelming for you.
11:37:19 <mux> depending on version/os you should have a haskell/haskell.exe/a.out/a.out.exe executable IIRC :-)
11:37:25 <xored> ttfh: oh ok, so there are diffrent ways to work with haskell, one way as executable and one with "live interpretar" right ?
11:37:55 <xored> mux: yeah i missunderstood that there are too way.
11:38:09 <ttfh> xored: just start ghci, then 'load "haskell.hs"'
11:38:43 <xored> ttfh: done it, iam getting "prelude->" ?
11:38:58 <ttfh> xored: then you can run your foo function and see it's result without having to worry about IO yet
11:39:03 <monochrom> You can then enter "foo 14" and see what you get.
11:39:13 <xored> monochrom: ah!
11:40:09 <xored> how do i get out of ghci ? exit / quit / ctrl + c does not work
11:40:15 <monochrom> :quit
11:40:22 <omnIdiot> use ":?" for help
11:40:37 <Olathe> Ctrl-D, Ctrl-Z
11:41:36 <xored> oh the vim way :)
11:41:44 <omnIdiot> :something is a direct command to ghci, without the colon, ghci interprets it as a Haskell expression.
11:43:02 <xored> ok it works great, thank you.
11:44:40 <hpaste>  yrlnry pasted "Why does this run out of memory for n=1000?" at http://hpaste.org/3056
11:44:55 <yrlnry> It seems to me that it shouldn't be so expensive.
11:45:11 <yrlnry> Did I make some bonehead mistake?
11:46:25 <Botje> yrlnry: i'd say it's keeping every instance of cats around
11:46:28 <elliottt> yrlnry: i think  you're running into unwanted lazyness
11:46:41 <yrlnry> Botje: that's what I was afraid of.
11:46:52 <hpaste>  (anonymous) pasted "how to make this accumulate" at http://hpaste.org/3057
11:46:52 <xored> _wow_
11:46:53 <yrlnry> So the memory use is quadratic in n instead of linear.
11:47:13 <yrlnry> Botje: Is that what you meant?
11:47:19 <Botje> yrlnry: yeah.
11:47:19 <qazwsx> http://hpaste.org/3057 <-- how can I make this accumulate (and display) all keys pressed, rather than just the last key pressed
11:47:45 <Botje> qazwsx: store the keys somewhere :) you can use an IORef for that.
11:47:48 <elliottt> qazwsx: that requires state
11:47:53 <Botje> err
11:47:58 <Botje> nvm me
11:48:00 <yrlnry> Botje: what should I do about that?  Rewrite it to be tail-recursive?
11:48:04 <Botje> didn't see the runGraphics
11:48:14 <elliottt> yrlnry: that's an option.  you could use a StateT
11:48:36 <yrlnry> elliottt: that really seems like the Wrong Thing, don't you agree?
11:48:44 <elliottt> yrlnry: why is that?
11:48:50 <qazwsx> Botje, elliottt can either of you explain this more? I'm a bit new to haskell
11:49:10 <Botje> yrlnry: i'm thinking :)
11:49:17 <yrlnry> I'm programming in a functional language.  It doesn't do what I want, so I force it to be imperative instead.  Wrong Thing.
11:49:33 <xored> One second, i guess nobody of you ever heared of a "tool" called "calculater" with an gui? Because right now looking on haskel..i cant see any reason for them to exist...wow
11:49:36 <elliottt> yrlnry: sorry, i tab completed the wrong nick -_-
11:49:40 <yrlnry> I mean, I could implement the algorithm in C and then use a state monad to simulate the computation in C, so...
11:49:42 <Botje> yrlnry: how is catalans defined, exactly?
11:49:45 <elliottt> i was trying to address qazwsx's question
11:49:54 <yrlnry> Botje: sorry, I don't understand the question.
11:49:57 <yrlnry> elliottt: Oho.
11:50:03 <elliottt> yrlnry: my mistake :)
11:50:04 <Botje> yrlnry: what's the mathematical definition of catalans?
11:50:16 <Botje> or is it only defined inductively like that?
11:50:17 <yrlnry> Botje: One possible definition is as you see there.
11:50:22 <qazwsx> elliottt: wait, sorry, can you repeat that, I don't see what I'm doing wrong
11:50:23 <elliottt> qazwsx: what you're trying to do is introduce some state, where you can keep track of the keys pressed
11:50:29 <qazwsx> okay
11:50:32 <qazwsx> how do I approach this problem?
11:50:35 <elliottt> well
11:50:37 <yrlnry> You can also make C(n) = (2n choose n) / (n+1) or somethi8ng like that.
11:50:39 <qazwsx> do I want a monad?
11:50:45 <elliottt> qazwsx: that's an option
11:50:54 <qazwsx> what are my other options?
11:50:57 <elliottt> what's the main monad you're dealing with in the SOE?
11:51:11 <qazwsx> I don't know
11:51:11 <yrlnry> But what I hoped for here was a way to get this algorithm to work, not an alternative algorithm.
11:51:18 <Botje> yeah.
11:51:23 <Botje> I can see that
11:51:24 <qazwsx> elliottt: I just do "ghci Window.hs; main"
11:51:26 <Botje> lessee
11:51:26 <yrlnry> The goal here is not to calculate catalan numbers, but to understand Haskell better.
11:52:29 <elliottt> qazwsx: actually, the easiest option may be the state monad :)
11:52:33 <qazwsx> okay
11:52:36 <qazwsx> what should I read up on?
11:52:41 <elliottt> hrm
11:52:42 <elliottt> well
11:52:51 <Botje> yrlnry: one thing I can think of is to pass cats as an extra parameter
11:52:57 <elliottt> the biggest problem is that you'll have to use a StateT, so you'll have to read up on monad transformers
11:53:07 <yrlnry> Botje: the usual trick for making a function tail-recursive?
11:53:12 <yrlnry> Lemme try that.
11:53:13 <Botje> yes
11:53:17 <qazwsx> hmm; is this a 5 line hack?
11:53:23 <elliottt> pretty much
11:53:24 <Botje> or you can try working _up_ from catalans 0
11:53:25 <qazwsx> if so, could someone write the hack for me and I learn from taht?
11:53:38 <qazwsx> (much easier to understand concrete code than read abstract things)
11:53:43 <qazwsx> http://www.haskell.org/haskellwiki/Simple_StateT_use
11:53:44 <lambdabot> Title: Simple StateT use - HaskellWiki
11:53:49 <qazwsx> is the same state monad that you're referring to?
11:53:57 <elliottt> yes
11:55:12 <elliottt> qazwsx: so, you'll want to create some new type, that keeps track of the keys pressed as a list
11:55:23 <qazwsx> say a list of chars?
11:55:47 <qazwsx> I guess if someone could show me two things, I'd be set:
11:55:59 <qazwsx> one, the equiv of writing ":=" with monads and (2) reading back the value with monads
11:56:35 <Botje> upCata cats = cn1 : cats where cn1 = sum (zipWith (*) cats (reverse cats)) -- then just apply upCata a number of times.
11:56:37 <dmwit> It depends which monad you're in, I guess.
11:57:02 <dmwit> :t set -- for the State monad
11:57:05 <lambdabot> Not in scope: `set'
11:57:12 <elliottt> qazwsx: i guess that the only trouble is that once you wrap the state monad around your IO monad, all your graphics calls have to be lifted with liftIO
11:57:21 <elliottt> just ends up looking kinda gross :)
11:57:24 <yrlnry> Botje: I did something similar, but it still runs out of memory.  I'm going to paste it.
11:57:34 <qazwsx> elliottt: okay, what is the right way to do this?
11:57:40 <Botje> k
11:57:43 <qazwsx> I don't mind changing the graphics code
11:57:50 <omnIdiot> > runState (do { a <- get ; set (a + 2) ; b <- get ; return [a,b]}) 1
11:57:50 <lambdabot>   Not in scope: `set'
11:58:03 <Botje> elliottt: fwiw: runGraphics is of type IO () -> IO (). so you could tell him how to use IORef
11:58:06 <omnIdiot> > runState (do { a <- get ; put (a + 2) ; b <- get ; return [a,b]}) 1
11:58:08 <lambdabot>  ([1,3],3)
11:58:24 <dmwit> ah, put
11:58:29 <hpaste>  yrlnry pasted "tail-recursive catalans function" at http://hpaste.org/3058
11:58:58 <Botje> yrlnry: you can annotate your previous paste with a new version too, makes it easier to compare
11:59:02 * Botje checks paste
11:59:44 <hpaste>  yrlnry annotated "Why does this run out of memory for n=1000?" with "annotated" at http://hpaste.org/3056#a1
11:59:50 <qazwsx> is the stuff that omnIdiot pasted useful for my task?
11:59:52 <yrlnry> Thanks.
12:00:23 <Botje> hmm
12:00:31 <Botje> your second version does not run out of memory for me
12:01:10 <Botje> then again, neither does the other :/
12:01:51 <Botje> although it's still using a lot of memory
12:02:51 <Botje> ah
12:02:54 <omnIdiot> qazwsx: you'll probably need a (StateT [Char] WhateverTheSOEMonadIs a).  When you runStateT that, passing in the empty list, you can put keys into that list using get and put.  After running, you'll get a SOEMonad (a, [Char])
12:03:03 <Botje> you're using Integers
12:03:10 <yrlnry> All three versions  fail for me with n=1000.
12:03:18 <Botje> omnIdiot: runGraphics is of type IO () -> IO ()
12:03:29 <reilly> question:  Given the new features for type level programming, why doesn't GHC implement some mechanism for type level integers?  Every example of type-level programming starts with its own implementation of Peano arithmetic.  You'd think you'd want 1 implementation and some mechanism for short-circuiting all the pattern matching in the compiler.
12:03:35 <omnIdiot> ah, that's seems simple then.
12:03:36 <yrlnry> So now I begin to think that the problom is not with my original implementation.
12:03:42 <Botje> yrlnry: haskell is forcing the types to Integer
12:03:56 <yrlnry> Isn't that just what it should be doing?  These are bignums.
12:04:01 <Botje> indeed
12:04:10 <yrlnry> Okay, and?  They're not *that* big.
12:04:19 <yrlnry> C(n) is on  the order of 4^n.
12:04:25 <Botje> bah, indeed.
12:04:35 <dmwit> > 2^2000
12:04:36 <olsner> > 4^1000
12:04:37 <lambdabot>  1148130695274254524232833201177681984022317702088695200477642736825766261392...
12:04:37 <lambdabot>  1148130695274254524232833201177681984022317702088695200477642736825766261392...
12:04:45 <Botje> what haskell interpreter are you using?
12:04:49 <yrlnry> hugs.
12:04:51 <Botje> ah.
12:04:54 <Botje> i'm testing with ghci
12:04:57 <Botje> i'll test hugs
12:05:13 <yrlnry> I was going to run it through GHC, but I thought I'd come ask if I was doing anything obviously dumb.
12:05:22 <yrlnry> Now it seems that perhaps I wasn't, which is useful to know.
12:05:24 <byorgey> reilly: I don't know.  That would be nice.
12:05:26 <Botje> yeah
12:05:30 <quicksilver> reilly: Good question. We lack a library for type-level hackery, basically.
12:05:31 <Botje> hugs is rather weak resrouce-wise
12:05:52 <Botje> yup, hugs runs out of memory.
12:05:57 <Botje> yrlnry: you know about ghci, right?
12:06:05 <quicksilver> reilly: You don't really want peano numbers, if you're planning to use it in practice. You want some fancy binary-at-the-type-level
12:06:16 <yrlnry> what's ghci?
12:06:26 <reilly> quicksilver: exactly
12:06:29 <yrlnry> i = interpreter?
12:06:32 <Botje> yes
12:06:40 <Botje> ah.
12:06:47 <Botje> hugs only has a heap of 250k by default
12:06:50 <Botje> that might not be enough
12:06:59 <quicksilver> reilly: I don't think many programmers are using that kind of stuff in 'real' programs.
12:07:17 <quicksilver> Anyone know about forkIO and GLUT's mainLoop?
12:07:26 <Botje> aha
12:07:39 <ac> What's the difference between => and ->?
12:07:40 <Botje> yrlnry: I added -h16M to my hugs invocation
12:07:42 <Botje> it works now
12:07:47 <Botje> kaabuntu% hugs boe.hs -h16M
12:07:50 <Botje> Main> catalan 1000
12:07:50 <quicksilver> ac: => demarks the type class context
12:07:54 <Botje> 204610552146802169264251...
12:07:55 <quicksilver> ac: it doesn't actualy change the type
12:08:02 <quicksilver> ac: it just 'annotates' the type with some constraints
12:08:04 <reilly> quicksilver: I think HList qualifies as useful for real programs
12:08:20 <ac> quicksilver: you mean the part of the left side of the "=>"?
12:08:20 <Botje> so if you want to use hugs, don't forget to increase the base heap size
12:08:30 <Botje> hope that solves it for you, too
12:08:34 <quicksilver> ac: yes, the type is on the right and the contraints ('context') are on the left
12:08:38 <Botje> oh.
12:08:48 <Botje> gotta go
12:08:51 <Botje> *waves*
12:08:51 <ac> thanks
12:08:57 <quicksilver> reilly: I don't think many real programs use it. Perhaps I'm wrong. Certainly the ones whose code I've read don't.
12:09:15 <byorgey> ac: so, e.g. (Show a) => a -> String means "a function from type a to type String, where a is any type which is an instance of Show"
12:09:36 <quicksilver> ac: but, fundamentlly, you should still think of it as a type "a -> String"
12:09:41 <ac> right. I don't understand type classes, but I get the general idea
12:09:45 <quicksilver> ac: it's just that you know something extra about 'a' this time
12:10:00 <quicksilver> ac: you could still pass it to any function which expected "a -> b" or "a -> String" etc
12:10:29 <yrlnry> Botje: thanks a lot for your help.
12:10:36 <iguana_> @djinn (a -> b -> c -> d) -> (d -> e) -> (a -> b -> c -> e)
12:10:36 <lambdabot> f a b c d e = b (a c d e)
12:10:51 <Botje> yrlnry: you're welcome. have fun!
12:10:56 <Botje> i'll be back in an hour or so
12:11:17 <reilly> quicksilver:  You certainly *do* see that level of type hackery in C++ ... and a lot of it looks like haskell trying to escape from the miserable confines of the C++ template system
12:11:27 <quicksilver> @. pl djinn  (a -> b -> c -> d) -> (d -> e) -> (a -> b -> c -> e)
12:11:27 <lambdabot> f = flip ((.) . (.) . (.))
12:11:34 <iguana_> nice
12:11:35 <quicksilver> awesome
12:11:39 <quicksilver> the triple-breast combinator
12:11:57 <quicksilver> reilly: yes, I'm not speaking very precisely
12:12:07 <quicksilver> reilly: of course, lots of prorams use typeclasses and stuff, and that's very handy
12:12:17 <quicksilver> reilly: but very few go as far as mirroring data up to the type-level
12:12:28 <eyeris> I'm trying to understand monads. All of the texts I've read explain this as something along these lines "a monad is a bit like a function World -> (a, World)", then goes on to explain that 'x <- getLine; putStr x' is the same as 'getLine >>= putStr'. I understand both of those ideas but I don't see where 'World' is in the example 'getLine >>= putStr'
12:12:29 <quicksilver> reilly: the line between the two kinds of type hackery is not well-defined
12:12:55 <quicksilver> reilly: in particular, most of the tricks you can do in C++ templates are much easier in haskell. But not all.
12:13:00 <iguana_> eyeris: that's not true for every monad
12:13:03 <iguana_> just for state-like monads
12:13:07 <quicksilver> reilly: the ability to have 'ints' as a template parameter is certainly very handy.
12:13:26 <yrlnry> eyeris: I thought a much better explanantion was at http://sigfpe.blogspot.com/2007/04/trivial-monad.html
12:13:27 <lambdabot> Title: A Neighborhood of Infinity: The Trivial Monad
12:13:38 <quicksilver> eyeris: hidden
12:13:42 <yrlnry> eyeris: I recommend it, and that blog in general.
12:13:44 <quicksilver> eyeris: getLine returns a (hidden) world
12:13:45 <reilly> quicksilver: are you familiar with the blitz library in c++?  computes optimal evaluation strategies for matrix calculations at compile time.
12:13:48 <hpaste>  monochrom annotated "Why does this run out of memory for n=1000?" with "more eager, less memory" at http://hpaste.org/3056#a2
12:13:53 <quicksilver> eyeris: that hidden world is passed on to putStr automatically
12:13:58 <quicksilver> eyeris: and that's what >>= does
12:14:02 <quicksilver> eyeris: "hide the world and pass it on"
12:14:04 <omnIdiot> eyeris: that's a rather narrow definition of monads, but for statelike monads, try to remember that actions like "getLine" and "putLine blah" act like functions themselves, and (>>=) is a fancy function composition.
12:14:18 <quicksilver> reilly: I've read about it although I've not looked in detail.
12:14:24 <eyeris> quicksilver so the monad keeps the "World" inside itself? Kinda like a static variable inside a function in C?
12:14:34 <quicksilver> eyeris: yes, rather like that
12:14:40 <eyeris> oh
12:14:43 <monochrom> yrlnry: I have tried that eager version on hugs with catalan 1000. It passes.
12:14:43 <yrlnry> monochrom: thanks, that's just the sort of thing I was looking for that I don't know how to do yet.
12:14:44 <quicksilver> eyeris: sometimes you have to supply an initial world, though
12:14:58 <quicksilver> eyeris: but in the case of IO, the compiler/runtime system supplies the initial world for you
12:15:11 <quicksilver> reilly: in haskell I would think such compile-time organisation is best done in TH
12:15:13 <betty> eyeris: like you, I am trying to learn about monads.  I find the explanation by "All About Monads" to be the most helpful.
12:15:16 <reilly> quicksilver: it's nicely done, but hopelessly obfuscated by the template syntax.
12:15:25 <quicksilver> reilly: rather than using the type system purely
12:15:33 <eyeris> I know I complain about naming in Haskell a lot but World is a bad choice because it seems to refer to everything, hinting at what is the global scope in C or something like that :0
12:15:40 <eyeris> I just read into names _way_ too much I guess
12:15:51 <reilly> quicksilver: I have to admit I've never used template haskell
12:16:01 <omnIdiot> getLine :: IO String, which is short for World -> (String, World), putLine line :: IO (), which is World -> ((), World), (>>=) composes these together: (getLine >>= \l -> putLine l) :: IO (), or World -> ((), World)
12:16:08 <quicksilver> reilly: the C++ template system is turing complete. The typeclass system is (by design) guaranteed to terminate and hence not turing complete
12:16:16 <quicksilver> reilly: (unles you turn on the options that break it)
12:16:49 <quicksilver> reilly: If you want to do computation at compile-time why not use a language designed for it, in other words. That is what TH is for :)
12:17:10 <eyeris> omnIdiot I see
12:17:18 <reilly> quicksilver: understood.  The type-family stuff in head makes a lot of type hackery much less obfuscatory
12:17:26 <quicksilver> eyeris: it does refer to everything in the specific case of IO
12:17:32 <quicksilver> eyeris: in that case, 'World' is a good name
12:17:36 <quicksilver> eyeris: for other monads, it doesn't
12:17:39 <yrlnry> monochrom:  it works for me too.  Thanks again; that is exactly what I was hoping for.
12:17:41 <quicksilver> eyeris: and so it's a bad name...
12:17:52 <monochrom> happy happy joy joy
12:17:59 <quicksilver> eyeris: but if you're hopign to get an intuition by comparing, it's not a bad start
12:18:11 <omnIdiot> @src State (>>=)
12:18:11 <lambdabot> Source not found. You speak an infinite deal of nothing
12:18:12 <reilly> quicksilver: I will take a look at it ... does it place any limitations on the generated haskell?
12:18:22 <jleedev> @src join
12:18:23 <lambdabot> join x =  x >>= id
12:18:27 <quicksilver> reilly: I don't think so. I think you can write anything
12:18:37 <quicksilver> reilly: although it's not always fun dealing with syntax so concretely.
12:18:46 <eyeris> ok, so I should probably learn about the other Haskell monads before I try to write one myself. What is one of the simpler ones?
12:18:47 <quicksilver> reilly: I've not used it much though
12:19:15 <quicksilver> eyeris: 'Maybe' and 'List' and 'State' are three fairly simple, but genuinely different from each other, examples
12:19:32 <eyeris> great, I will learn those next.
12:19:36 <eyeris> Thank you all
12:19:41 <quicksilver> eyeris: Maybe is about computaitons which can fail. List is about computations which might produce more than one answer. State is a about computations which use state, obviously :)
12:20:38 <omnIdiot> {- for State s a -} action >>= function = (\s -> let (result, s2) = action s; (result2, s3) = (f result) s2 in (result2, s3)) -- (>>=) makes a new function that threads them together.  The new function accepts the starting state, gets a new state from the action, and threads the new state into the second action.
12:21:51 <omnIdiot> (modulo wrapping and unwrapping all these functions with the State data constructor, which we'll ignore for simplicity's sake)
12:22:09 <ac> If the >> operator takes a Monad a and a Monad b, why do I keep getting "Couldn't match expected type ... blah blah" errors in my do expression?
12:22:30 <leila> Hi all
12:22:33 <ac> I must be making a really common newbie mistake here
12:22:36 <omnIdiot> ac: what is the expression?
12:22:44 <quicksilver> ac: got to be same monad?
12:23:29 <ac> omnIdiot: the do list is a bunch of gtk calls
12:24:11 <ac> the actual error is "Couldn't match expected type `IO Bool -> IO t' against inferred type `IO (ConnectId Window)'
12:24:47 <quicksilver> sounds like you didn't give something a parameter it needed
12:24:54 <quicksilver> or you gave something one too many parameters
12:25:21 <yrlnry> I just went over to MAGnet and told them I had a perfect IRC experience, where I got exactly what I hoped for with no fuss, and everyone was polite, friendly, and helpful, and understood the real point of my question.
12:25:22 <omnIdiot> eyeris: did you understand that?  Read through that code slowly and ask questions if you need.
12:25:27 <yrlnry> Thanks again.  You folks rock.
12:26:00 <omnIdiot> @help karma+
12:26:00 <lambdabot> karma+ <nick>. Increment someone's karma
12:26:01 <ac> quicksilver: I was thinking it might be something like that, but I double checked the problem call... it has two arguments and it's expecting two
12:26:14 <omnIdiot> yrlnry: @karma+ is a good way to show appreciation :)
12:26:45 <quicksilver> ac: could you http://hpaste.org/ it ?
12:26:58 <omnIdiot> or nick++ for short.  ( nick-- so this message doesn't change nick's karma :)
12:27:00 <ac> uhm sure... it's not the pretiest of code, but give me a second
12:27:23 <idnar> @karma nick
12:27:23 <lambdabot> nick has a karma of 2
12:27:25 <idnar> poor nick
12:27:25 <yrlnry> @karma+ botje
12:27:26 <lambdabot> botje's karma raised to -1.
12:27:26 <quicksilver> or a chunk of the code and the exact error, at least :)
12:27:32 <omnIdiot> haha
12:27:36 <eyeris> omnIdiot I'm reading through it still...
12:27:37 <yrlnry> @karma+ monochrom
12:27:37 <lambdabot> monochrom's karma raised to 17.
12:27:42 <yrlnry> @karma+ #haskell
12:27:43 <lambdabot> #haskell's karma raised to 6.
12:28:29 <omnIdiot> eyeris: I made one mistake.  I called (>>=)'s second param 'function', but said 'f' in the definition.
12:29:42 <ac> hpaste.org/3061
12:30:12 <ac> the problem is line 24
12:30:13 <omnIdiot> action >>= f = (\s -> let (result, s2) = action s; action2 = f result; (result2, s3) = action2 s2 in (result2, s3)) -- here it makes it explicit that (>>=)'s second argument needs action's result to produce a new action.
12:30:17 <ac> if I comment it out it throws a type error
12:30:35 <ac> line 20 does not produce a type error, for some reason
12:30:36 * shapr boings
12:31:10 <eyeris> omnIdiot I get the concept, but could you give me an example of using this?
12:31:36 <eyeris> where does `action' come from?
12:32:02 <eyeris> oh wait I think I get it now
12:32:29 <eyeris> monad is a type class with (>>=) and return functions, so action is the (>>=) function?
12:32:51 <Philippa> action is just anything of type m a
12:32:55 <quicksilver> ac: what's the exact error?
12:33:05 <Philippa> where (Monad m)
12:33:10 <byorgey> eyeris: often a monadic value is referred to as an 'action' or a 'computation'
12:33:12 <omnIdiot> > do { State (\s -> ((), 1) ; State (\s -> ((), s + 2) ; State (\s -> (s - 1, s) } -- puts 1 into the state, updates it, result in the state minus 1.  Or more conventionally:
12:33:12 <lambdabot>  Unbalanced parenthesis
12:33:20 <omnIdiot> > do { put 1 ; modify (+2) ; v <- get ; return (v-1) }
12:33:21 <lambdabot>   add an instance declaration for (Show (t s))
12:33:39 <Olathe> > complain complain
12:33:40 <lambdabot>   Not in scope: `complain'
12:33:57 <omnIdiot> > runState (do { put 1 ; modify (+2) ; v <- get ; return (v-1) }) 9284 {- the initial state is overwritten on the first put -}
12:33:59 <lambdabot>  (2,3)
12:34:11 <quicksilver> Philippa: is it safe to forkIO with GLUT's mainLoop? it seems to be working so far...
12:34:44 <ac> quicksilver: that is missing a few lines of one of the referenced functions that I can add if you want to actually compile it
12:34:48 <omnIdiot> > runState (do { State (\s -> ((), 1) ; State (\s -> ((), s + 2) ; State (\s -> (s - 1, s)) }) 9284
12:34:48 <lambdabot>  Unbalanced parenthesis
12:34:52 <omnIdiot> rawr
12:35:04 <quicksilver> ac: the code's ok but what is the exact error?
12:35:53 <omnIdiot> eyeris: that should be equivalent to the version with get, put, modify.  That's how those functions are defined.
12:37:33 <leila> Hi all, i wrote a little haskell code but i think it lacks some ellagance / grace. Is anyone online that is willing to take a peak and give me some pointers ?
12:37:49 <omnIdiot> > runState (do { State (\s -> ((), 1)) ; State (\s -> ((), s + 2)) ; State (\s -> (s - 1, s)) }) 9284 -- ENOUGH PARENTHESES FOR YOU????
12:37:51 <lambdabot>  (2,3)
12:37:53 <omnIdiot> yay!
12:38:10 <ac> quicksilver: if I uncomment "pixbufSetPixelsRGB8 pixbuf checker" and surround it with parenthesis, I get the error mentioned before, but if I don't add the grouping I get a rather complex type error
12:38:54 <ac> The change of behavior depending on parenthesis led me to believe something had the wrong number of arguments, but that's not the case
12:39:00 <omnIdiot> > runState (do { State (\s -> ((), 1)) ; State (\s -> ((), s + 2)) ; v <- State (\s -> (s, s)) ; State (\s -> (v - 1, s)) }) 9284 -- this is actually closer
12:39:01 <lambdabot>  (2,3)
12:39:11 <quicksilver> ac: sounds like when you add the parens, you're changing the indentation?
12:39:18 <omnIdiot> get = State (\s -> (s, s))
12:39:32 <omnIdiot> it copies the state into the action's result
12:39:40 <quicksilver> ac: if it's indented differently it will be on the 'same line' as the onDestroy line
12:39:40 <ac> quicksilver: oooh noooooooo
12:39:51 <quicksilver> ac: which would give you a funny type error...
12:39:58 <ac> quicksilver: you're right. Man I spent way too long beating my head against a spurious tab character
12:39:59 <eyeris> omnIdiot so the lambda functions are the actions?
12:40:10 <omnIdiot> eyeris: for the State monads, yes
12:40:10 <quicksilver> yes, it is annoying
12:40:14 <ac> hahaha
12:40:20 <quicksilver> quite often type errors are caused by incorrect indentation
12:40:35 <eyeris> omnIdiot ok, I get that, but where is it getting the initial state?
12:40:36 * ac :set expandtab
12:40:47 <omnIdiot> eyeris: runState (...) 9826
12:41:26 <eyeris> omnIdiot so 9826 is the initial state?
12:41:28 <omnIdiot> eyeris: the do block is effectively one long chained-together function.  runState provides it with an argument
12:41:45 <omnIdiot> yes
12:42:22 <omnIdiot> but you'll notice the first action, put 1 (or State (\s -> ((), 1)), completely ignores the initial state
12:42:44 <eyeris> omnIdiot oh! you said that!
12:42:53 <eyeris> @karma omnIdiot ++++++++++++++++++++
12:42:53 <lambdabot> omnIdiot has a karma of 0
12:43:04 <omnIdiot> heh
12:43:32 <ac> I'm reading realworldhaskell, which definitely warned me about the tab issue, but I didn't listen, did I?
12:43:50 <eyeris> ok, let me try my hand at this...
12:44:27 <glguy> You're reading realworldhaskell? are you a reviewer?
12:45:37 <leila> Q_Q
12:47:54 <ac> glguy: yeah, someone gave me a password (they said they sort of weren't supposed to, but I've found it pretty useful)
12:48:09 <leila> lol
12:48:25 <ac> maybe after I've read the rest of it I'll contribute my own reviewing
12:48:29 <Zevv> Is there a way to make hugs or ghci show intermediate results for debugging purposes. For example, when evaluating a recursive function, show the results between calls ?
12:48:52 <eyeris> runState (do State (\s -> not s) ; State (\s -> not s) ; State (\s -> not s)) True -- should return False
12:49:02 <Heffalump> you can just subscribe to the mailing list and get the password legitimately
12:49:11 <eyeris> > runState (do State (\s -> not s) ; State (\s -> not s) ; State (\s -> not s)) True -- should return False
12:49:18 <ac> Heffalump: I didn't know about that :P
12:49:19 <lambdabot>  Couldn't match expected type `(t, Bool)'
12:49:23 <omnIdiot> eyeris: not quite, each State (\s -> ...) should have a pair where the ... is.
12:49:30 <eyeris> oh, right
12:49:54 <Heffalump> at least, bos has mentioned it on here, IIRC
12:50:00 <omnIdiot> eyeris: the first element of the pair is the action's result (possibly bound by 'v <- action') the second is the new state to be threaded forward
12:50:32 <omnIdiot> but yes, your understanding seems correct
12:50:42 <bos> hm?
12:50:46 <ac> my understanding is that the point of the password is to prevent exposure when the book is not yet in its ideal form
12:50:59 <ac> I'm not going to write any public reviews of it or anything
12:51:21 <bos> cosmicray and i are rewriting the early password-protected chapters. we'll then make those publicly accessible.
12:51:37 <Heffalump> have you posted any more chapters?
12:51:56 <omnIdiot> eyeris: in practice, nobody makes State actions using the State constructor and lambda functions.  All the useful action generators are in Control.Monad.State already
12:51:57 <bos> the purpose of the password protection is just to reduce the number of people who see first drafts, so we can offer something more polished to the world at large.,
12:51:57 <eyeris> omnIdiot so in my simple bool flipping example, I would want (\s -> (not s, not s))?
12:52:02 <bos> Heffalump: not yet.
12:52:17 <bos> Heffalump: next week or the week after, perhaps
12:52:28 <omnIdiot> eyeris: since you aren't binding the results of any of your actions, you could put anything you wanted in the fst of each pair.
12:52:33 <eyeris> omnIdiot which illustrates why my example is such a bad one -- there is really no state :)
12:52:57 <ac> bos: are you the author? It's been quite useful. I've been reading Real World Haskell, A Gentle Introduction to Haskell, and en.wikibooks.org/wiki/Haskell for learning the basics
12:53:08 <omnIdiot> the usual convention when an action doesn't result in anything useful is to use ().
12:53:15 <eyeris> ok
12:53:20 <omnIdiot> @docs Control.Monad.State
12:53:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
12:53:25 <Heffalump> you will post to the list when you do, though?
12:53:33 <bos> ac: yes, i'm one of the authors
12:53:50 <omnIdiot> hmm, not terribly useful...
12:53:59 <bos> Heffalump: yes of course
12:54:29 <omnIdiot> modify f = State (\s -> ((), f s))
12:54:42 <omnIdiot> so (modify (+1)) increases the state by one.
12:55:26 <eyeris> ok
12:56:06 <omnIdiot> gets f = State (\s -> (f s, s)), so it returns an f-modified value from the state, without changing it itself.
12:56:36 <omnIdiot> > runState (do {  v <- gets (+5) ; return v }) 1
12:56:41 <lambdabot>  (6,1)
12:57:13 <omnIdiot> > runState (do { v <- gets chr ; return v }) 96
12:57:14 <lambdabot>  ('`',96)
12:57:33 <eyeris> ok
12:58:09 <omnIdiot> return x = State (\s -> (x, s)), injects 'x' as the return value, doesn't change state.
12:58:11 <eyeris> I gotta get going. Thanks for you help!
12:58:19 <omnIdiot> you're welcome!
12:58:24 <eyeris> Anyone know off hand how to save a bitchx buffer?
13:03:01 <hpaste>  xored pasted "incrementer" at http://hpaste.org/3064
13:03:32 <xored> hello, did my paste arrive?
13:04:17 <ac> oh, I see what the announce checkbox does. cool
13:04:45 <xored> does someone has an idea why my "tail res +1" is wrong ? http://hpaste.org/3064
13:05:15 <omnIdiot> xored: (tail res) is a list, 1 is an integer
13:05:23 <omnIdiot> try map (+1) (tail res)
13:05:36 <omnIdiot> map changes each element of a list
13:05:43 <xored> oh my goodness.
13:06:03 <xored> tail [a] does not return the last element, it returns the list without the last
13:06:04 <Zao> It transforms the list into a new list by applying the function passed in to every element.
13:06:07 <xored> iam so dump. Thank you omnIdiot
13:06:37 <jcreigh> > tail [1,2,3]
13:06:41 <omnIdiot> 'last' returns the last element
13:06:49 <lambdabot>  [2,3]
13:07:01 <jcreigh> xored: tail returns everything except the first element, not everyting except the last
13:07:08 <ac> I am confused about the relation between RandomGen, StdGen, and Random
13:07:24 <omnIdiot> StdGen is a random number source
13:07:44 <omnIdiot> RandomGen is a class of random number sources, so you could provide another type instead of StdGen
13:07:58 <xored> jcreigh: oh! why is it called tail then? "get me the tail" like this ?
13:07:58 <omnIdiot> Random is the class of types that can have random elements produced.
13:10:32 <bos> love lotte for arranging nicholaz's mac
13:10:37 <omnIdiot> data MersenneTwister = ...;  instance RandomGen MersenneTwister where ...
13:10:39 <bos> bollocks, wrong channel
13:16:20 <xored> omnIdiot: res = 0 : [ x | x <- (last res), x < 6]
13:16:31 <xored> omnIdiot: thats somehow still wrong, what iam doing wrong ?
13:16:49 <omnIdiot> xored: x <- ... expects a list
13:17:02 <omnIdiot> "x is drawn from the list ..."
13:17:04 <xs> xored: and last res won't work..
13:17:18 <omnIdiot> I'm not sure what you're trying to do there.
13:17:48 <xored> omnIdiot: iam just trying to produce as much intuitive things
13:18:09 <omnIdiot> xored: are you thinking "last" as in "last that I have defined so far"?
13:18:13 <xored> omnIdiot: the get all the "errors" iam making intuitive to get, what iam missunderstanding. Thats my way to learn
13:18:39 <omnIdiot> so the first "x" would be zero, then the second would be the result from that?
13:18:41 <xored> omnIdiot: no i thought, last as "get me the lat element out of the list, x should be that element and should be put in the list
13:18:50 <xored> thats what was my "thought`s"
13:18:59 <omnIdiot> if it's inifinite, it by definition has no last element.
13:19:08 <sjanssen> xored: you gotta stop thinking imperatively
13:19:28 <sjanssen> you can't put things in lists -- they're immutable
13:19:28 <xored> omnIdiot: ye thats clear, but the firs tthing i missunderstood i guess ist, that <- expects a List as RValue, right ?
13:19:38 <xored> sjanssen: yeah sure, not that easy, iam trying
13:19:38 <omnIdiot> yes
13:19:49 <omnIdiot> I think you want "tail res"
13:19:54 <MADnificent> How can I write http://www.killthenorm.com/tmp/tree.hs so it works?
13:19:54 <xored> omnIdiot: ok than its clear what the compiler drops as the error.
13:20:19 <omnIdiot> or even just "res"
13:20:31 <MADnificent> I'm first trying to get it to work, then I'll try to figure out how to take advantage of the Maybe monad...
13:20:46 <omnIdiot> would should res look like when it's finished?  [0, 1, 2, 3...?
13:20:49 <Cale> When you have a generator  x <- xs  in a list comprehension, xs must be a list, and x will have the type of the elements of that list
13:21:02 <sjanssen> MADnificent: what is the problem?
13:21:35 <sjanssen> MADnificent: line 23, Just (x:as)
13:21:44 <MADnificent> sjanssen: the compiler says: 'tree.hs:23:42: Not in scope: `as''
13:21:54 <MADnificent> sjanssen: and that makes it work? lemme test...
13:21:56 <xored> omnIdiot: exactly thats my aim, but iam trying it intuitivly to get more the feeling of haskell while getting int working..hope you can undestand
13:22:02 <sjanssen> MADnificent: no, it's still broken
13:22:08 <xored> omnIdiot: first of al
13:22:27 <sjanssen> MADnificent: "(deptFirst x) == Just as" is a test for equality, not a binding
13:22:49 <sjanssen> MADnificent: you should do something like "case deptFirst x of Nothing -> ...; Just as -> ..."
13:22:57 <MADnificent> sjanssen: hmmm, lemme try something
13:23:05 <omnIdiot> xored: sure I understand.  In [ x | x <- xs ], x takes on each element of xs in turn, and the results are collected into the result list.
13:23:43 <hpaste>  omnIdiot annotated "incrementer" with "can you understand this?" at http://hpaste.org/3064#a1
13:23:47 <hpaste>  xored pasted "test on lists" at http://hpaste.org/3065
13:24:12 <omnIdiot> "The list of all x + 1, such that x is drawn from res and x < 6"
13:24:49 <xored> omnIdiot: did i get this right, the definition, that last is not returning a list, more the last element of the list as type Int in that case
13:25:09 <MADnificent> sjanssen: check the error on http://www.killthenorm.com/tmp/tree.hs
13:25:27 <omnIdiot> xored: look at the annotation I put on your other paste.
13:25:29 <Cale> xored: yeah, last just gives the last element
13:25:30 <MADnificent> sjanssen: except from the fact that the alg is currently broken, it gives an error too ^_^
13:25:36 <Cale> > last [1,2,3,4,5]
13:25:38 <lambdabot>  5
13:25:52 <omnIdiot> > last [0..] -- will take a while ;)
13:25:53 <lambdabot>  Unbalanced parenthesis
13:25:56 <omnIdiot> bah
13:25:57 <xored> omnIdiot: hmm i just missed the link..hm could you paste the link ?
13:26:00 <sjanssen> MADnificent: read what I wrote about "test for equality, not a binding" and the case statement
13:26:05 <omnIdiot> http://hpaste.org/3064#a1
13:26:25 <omnIdiot> look up into the scrollback
13:26:52 <MADnificent> sjanssen: but I must be able to match on the Node thing somehow? you told me I can't bind a variable to it... That's fine by me, but I'd like this to match (even though, you showed me a working alternative)
13:27:17 <MADnificent> sjanssen: the point is that I'm learning, so I'm more keen on understanding it, then on finding a correct answer :-)
13:27:50 <sjanssen> MADnificent: I'm saying that you *can* bind a variable to it, but == isn't the way :).  Use a case statement instead
13:28:29 <xored> omnIdiot: ok, thats not clear to me. You use res, which is a list, and  you take "a element" out of it, while i have no clue which element you get with x <- [a]...then you increment the value and store it in res..thats clear to me. What i dont get is, while x is a list because of x <- and you still do something like x+1
13:29:03 <sjanssen> MADnificent: you can delete those two guards, then fill in the blanks "case deptFirst x of Nothing -> ...; Just (a:as) -> ..."
13:29:21 <omnIdiot> xored: list comprehensions make a result for each element in each generator list.
13:29:42 <MADnificent> sjanssen: but I should be able to *match*, no? not bind... I'll take care of that in a later stage...  I'm now wondering how I would match with something like 'Just Path' so the equality won't fail...
13:30:04 <MADnificent> sjanssen: I do understand that that is not going to give me a good solution, but it might give me a better understanding
13:30:15 <sjanssen> MADnificent: you could use isJust from Data.Maybe
13:30:39 <sjanssen> MADnificent: that lets you determine that the result of (deptFirst x) isn't Nothing, but it doesn't help you get the result out
13:30:44 <xored> omnIdiot: i mean iam sure you get what iam trying to explaing myself. I want to clearify the "lazzyness of haskell" n the fact, how i build a list out of itself recursivly
13:31:25 <MADnificent> sjanssen: is there a more general method that is always useable? or must it always be implemented in a separate function?
13:31:27 <sjanssen> MADnificent: to get the result out, you need to use pattern matching with case
13:31:38 <sjanssen> MADnificent: for the third time, case! :P
13:32:25 <MADnificent> sjanssen: for the third time: I want to _understand_ :-P
13:32:41 <xored> omnIdiot: doint it as a mathimaticaly expression i would explain your statement like : { x | x element of res : x +1 }
13:32:58 <MADnificent> sjanssen: I *know* I have to use case now (from the first time you told me), but I want to look at the possible ways to match :-)
13:33:00 <omnIdiot> xored: the similarity isn't accidental :)
13:33:16 <MADnificent> sjanssen: I guess the answer to my last question is 'no'?
13:33:19 <sjanssen> MADnificent: okay.  case is just like the pattern matching you're doing in the deptFirst function, but it's an expression instead of a function declaration
13:33:55 <sjanssen> MADnificent: case expressions (and function declarations, which turn into case expressions) are the only way
13:34:06 <omnIdiot> res is 0, followed by something.  That something is a list.  That list is a list comprehension that pulls each element out of res.  Given the first element, 0, the comprehension produces 1.  That 1 is used in the comprehesion's next result, producing 1 + 1, or 2.  That 2 is used as the next x, producing 2 + 1, or 3.  etc. etc.
13:34:26 <xored> omnIdiot: sure, but i dont get it really exact. x <- [res] ...expects the RValue to be a List and the LValue to be of the element type of the list, so x will be an element of the list, in our example its always the last element
13:34:41 <MADnificent> sjanssen: okay, thanks!
13:35:54 <xored> omnIdiot: so x < res is similar to the mathimatical x element of ?
13:36:04 <xored> %s/</<-
13:36:10 <omnIdiot> xored: did you read my explanation?
13:36:15 <xored> omnIdiot: yes.
13:36:26 <omnIdiot> similar, yes
13:36:43 <Japsu> Hmm
13:36:54 <Japsu> > [maxBound-1 ..] :: [Int]
13:36:56 <lambdabot>  [2147483646,2147483647]
13:36:59 <Japsu> !
13:37:11 <xored> omnIdiot: so in out case, x <- res means, "take the last element you did not use to compute the new value"
13:37:20 <Japsu> So there actually _is_ a last in [0..]!
13:37:32 <Japsu> Hmm
13:37:36 <Japsu> > maxBound :: Integer
13:37:37 <lambdabot>   add an instance declaration for (Bounded Integer)
13:37:37 <lambdabot>     In the expression: ma...
13:37:39 <opqdonut> yeah, Int defaulting you see
13:37:46 <omnIdiot> xored: it means x starts as the first element of res.  the comprehension produces a value and then looks at the next elemtn of res.
13:38:09 <xored> omnIdiot: and for haskell it makes no problem, that the list itself is growing while that. Thats because of the "lazzyness" fact, haskell is only computing new values while they are needed, right ?
13:38:25 <xored> omnIdiot: ok i think you got me on the road :)
13:39:43 <omnIdiot> (incidentally, [ f x | x <- xs ] can be written (map f xs), here, f is (+ 1))
13:40:12 <omnIdiot> > map (\x -> x + 1) [1..10]
13:40:14 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
13:40:14 <xored> omnIdiot: thank you. Iam not that far, yet no clue of map..lies on my way i guess
13:40:29 <omnIdiot> > [ x + 1 | x <- [1..10] ]
13:40:30 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
13:40:49 <xored> the last thing is know..jeeppee :)
13:41:20 <vagif> I know how to pattern match list to first:rest. Question, is it possible to pattern match first:rest:last ?
13:41:27 * omnIdiot almost never uses list comprehensions
13:41:49 <omnIdiot> vagif: that becomes: (first : (second : rest))
13:42:36 <byorgey> vagif: you can't pattern-match on the last element of a list, no.
13:42:38 <vagif> yes, but i want last, not the second
13:42:45 <vagif> ok
13:42:59 <omnIdiot> the last function has to walk down the list
13:43:01 <omnIdiot> @src last
13:43:01 <lambdabot> last [x]    = x
13:43:01 <lambdabot> last (_:xs) = last xs
13:43:01 <lambdabot> last []     = undefined
13:43:33 <vagif> in REFAL you can write like this:
13:43:34 <vagif> IsPalindrome {
13:43:34 <vagif>     = true
13:43:34 <vagif> s.1 = true;
13:43:34 <vagif> s.1 e.2 s.1 = IsPalindrome e.2;
13:43:34 <vagif> e.1 = false;
13:43:36 <vagif> }
13:43:57 <xored> list = [ x +1 | x < [1..10], length list < 5]
13:44:01 <xored> >list = [ x +1 | x < [1..10], length list < 5]
13:44:09 <xored> > list = [ x +1 | x < [1..10], length list < 5]
13:44:09 <lambdabot>  Parse error
13:44:12 <xored> *sorry*
13:44:34 <omnIdiot> > (let list = [ x +1 | x < [1..10], length list < 5 in list) -- I don't think it'll work
13:44:34 <lambdabot>  Parse error
13:44:41 <omnIdiot> hehe
13:44:51 <omnIdiot> > (let list = [ x +1 | x < [1..10], length list < 5 ] in list) -- I don't think it'll work
13:44:52 <lambdabot>  Couldn't match expected type `(((t -> t1 -> t2)
13:45:14 <xored> omnIdiot: why i cant simply work with the length ?
13:46:06 <omnIdiot> length list is always 10
13:46:25 <xored> i thought, every step he generates a new element, he evaluates the logical expression, in out case given by (length list < 5)
13:46:49 <omnIdiot> length by definition must force the list to evaluate fully, in order to take its length
13:47:33 <omnIdiot> (though I don't quite understand that type mismatch error :/ )
13:47:48 <omnIdiot> @src length
13:47:48 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:47:56 <xored> lol
13:48:08 <xored> i guess lambdabot gets angry :O)
13:50:29 <omnIdiot> length [] = 0; length (x:xs) = 1 + length xs; so it has to walk down the list until it finds the nil at the end.
13:51:00 <xored> omnIdiot: but why it this a problem ?
13:51:02 <MADnificent> sjanssen: can I steal some time of you once more?
13:51:52 <xored> omnIdiot: i mean, ah..you mean, even the lazzyness does not help here, becaue i "want haskell to give me the full length"..so haskell has to compute the whole list, which is not possible because he cannot evalute the logical expression
13:51:56 <MADnificent> it still gives me a type error, but I don't see it... http://www.killthenorm.com/tmp/tree.hs
13:52:07 <omnIdiot> xored: you're in the middle of producing list, and trying to take its length.  Taking its length forces it to be produced, and you have a circular dependency
13:52:19 <xored> omnIdiot: clear.
13:52:56 <xored> i just realized that "head" is the inverse to last, what is the inverse to tail than ?
13:53:18 <omnIdiot> er, init makes a new list with all but the last element
13:53:26 <omnIdiot> > init [1..10]
13:53:31 <lambdabot>  [1,2,3,4,5,6,7,8,9]
13:53:56 <Zao> xored: If no-one else has recommended it yet, Hoogle is a great way of exploring the libraries available.
13:54:28 <MADnificent> ahm, can anyone find the type-error on the link I just posted?
13:54:33 <omnIdiot> And I would recommend /msging lambdabot and using some of her facilities, but she seems to be ignoring /msgs at the moment.
13:54:38 <sjanssen> xored: inverse isn't quite the right term
13:55:29 <omnIdiot> though head : last :: tail : init
13:55:38 <xored> sjanssen: ok, i ask the other way. What gives me all elements exept the last on of a list -> WithoutLast :: [a] -> [a]
13:55:49 <sjanssen> init
13:56:12 <sorear> omnIdiot: /msg nickserv set unfiltered on
13:56:14 <xored> ah it was for me ?! i though it was something like a "make an interval" command for MADnificent
13:56:16 <xored> sorry, missed that
13:56:20 <sorear> omnIdiot: and complain loudly to dons
13:56:51 <Botje> I return
13:56:58 <omnIdiot> @tell dons lambdabot seems to be ignoring /msgs at the moment :/
13:56:59 <lambdabot> Consider it noted.
13:57:30 <sorear> @tell dons lambdabot IS listening to msgs, but can't reply because the auto-identify is broken :/
13:57:30 <lambdabot> Consider it noted.
13:57:49 <sorear> omnIdiot: you can listen with /msg nickserv set unfiltered on
13:57:52 <sjanssen> MADnificent: line 22, Just (Node (a:as))
13:57:58 <omnIdiot> right, doing that now
13:58:09 <sjanssen> MADnificent: btw, this would be much easier on hpaste
14:00:24 <MADnificent> sjanssen: hmmm, don't know that one.. but I don't like pasties in general (my mind will probably change about that soon)    (you want the pastie for the syntax highlighting?
14:00:42 <Mr_Awesome> @pl \f g x -> f x >> g x
14:00:43 <lambdabot> liftM2 (>>)
14:00:44 <sjanssen> MADnificent: nah, mostly the annotation feature
14:00:52 <xored> strange that i need brackets arround f (tail list) while f :: [a] -> [a] .. which it "f tail list" not working? i mean tail would be a keyword or ?
14:01:01 <MADnificent> sjanssen: it had to be Just ((Node [a]):as) but your comment cleared it out for me :-D (thanks again)
14:01:07 <omnIdiot> f tail list = (f tail) list
14:01:08 <bos> xored: functions are parsed left to right
14:01:10 <Zao> xored: It's just another function.
14:01:11 <sjanssen> MADnificent: I could hit 'annotate', and demonstrate more directly how I'd change it
14:01:22 <MADnificent> sjanssen: ah, that's pretty nice
14:01:25 <sjanssen> MADnificent: then you could even hit 'diff' to see exactly what I changed
14:01:34 <MADnificent> sjanssen: but pasties are remembered... like forever
14:01:35 <alzxul> Hi
14:01:35 <bos> so it's reading the unbracketed form as f tail, and trying to apply list to the result of that
14:01:58 <sjanssen> MADnificent: this is true
14:02:03 <xored> bos: but to evaluate, he needs first to calculate the parameter for f?
14:02:31 <int-e> lambdabot is identified again :)
14:02:31 <omnIdiot> xored: f expects a list, but (f tail) list passes it a function
14:03:07 <omnIdiot> (tail list) is a list
14:03:15 <xored> omnIdiot: hmm, i though the parse will get that, that "oh its a function, lets evaluate it first"..bt it seems like a have to be more presize in haskell
14:03:43 <omnIdiot> xored: it's perfectly fine to pass functions to other functions in haskell, but f doesn't expect it.
14:03:52 <int-e> sorear: @rc passwd.rc  did the trick.
14:04:26 <sorear> bad dons!
14:04:46 * sorear remembers leaving that in the online.rc; why wasn't it autosourced?
14:04:50 <sorear> hmm
14:04:53 <alzxul> I just started Haskell today :)
14:04:54 <sorear> race condition?
14:04:57 <xored> omnIdiot: got that. Short question on the definition is that "function :: [] -> []" full aquivalent to "function :: [a] -> [a]" ?
14:05:04 <sorear> alzxul: Great!
14:05:26 <sjanssen> @yow
14:05:26 <lambdabot> ... I think I'd better go back to my DESK and toy with a few common
14:05:26 <lambdabot> MISAPPREHENSIONS ...
14:05:40 <MADnificent> alzxul: you're on for a trip
14:06:08 <omnIdiot> xored: [] -> [] isn't valid
14:06:45 <omnIdiot> ([] a) is another way to write [a], so [] all by itself is just "List of ...".  It needs to be a list of *something* to be a valid type.
14:06:49 <hpaste>  xored pasted "implementing "init"" at http://hpaste.org/3066
14:07:25 <xored> omnIdiot: does [a] means a list of characters ? could i also write [1] ?
14:07:28 <int-e> sorear: maybe there was a netsplit when lambdabot logged in? it doesn't have to go wrong on lambdabot's side.
14:08:24 <omnIdiot> [Char] means a list of characters.  [a] means list of a's, an as-yet-unspecified type.
14:08:39 <xored> omnIdiot: perfectly clear, thank you
14:09:38 <omnIdiot> in your last paste, length mylist will always be the same, so the comprehension will either produces all of mylist's elements or none (if length mylist <= 1).
14:09:42 <MADnificent> omnIdiot: allso "I am cool" has type [Char] so you can do all operations you would do on a list of Chars, to a String
14:09:54 <omnIdiot> @src String
14:09:54 <lambdabot> type String = [Char]
14:10:29 <xored> @src init
14:10:29 <lambdabot> init [x]    = []
14:10:29 <lambdabot> init (x:xs) = x : init xs
14:10:29 <lambdabot> init []     = undefined
14:10:39 <jr__> hm. maybe this is a stupid question, but is it somehow possible to access infix operators in a qualified fashion (qualified meaning qualified module access, such as Char.toUpper for non-infix functions)
14:11:14 <sjanssen> > 1 Prelude.+ 2 -- like so, jr__
14:11:15 <omnIdiot> "the init of a list containing only x is [], the init of a list starting with x followed by xs is the new list x followed by init xs"
14:11:16 <lambdabot>  3
14:11:44 <jr__> ah...
14:12:16 <omnIdiot> > (Prelude.+) 1 2 -- or this for prefix form :)
14:12:16 <lambdabot>  Unbalanced parenthesis
14:12:20 <omnIdiot> bah!
14:12:26 <omnIdiot> > (Prelude.+) 1 2 -- or this for prefix form :|
14:12:27 <lambdabot>  3
14:12:48 <sorear> it seemed like a good idea at the time :/
14:13:27 <MADnificent> jr__: does Something.(==) work, perhaps?
14:13:36 <omnIdiot> MADnificent: nope
14:14:24 <MADnificent> that would also removes it's infix qualities...
14:15:35 * merus is surprised that he managed to install darcs properly.
14:15:57 <jr__> sjanssen, omnIdiot: thanks! MADnificient: thought that before, too:-)
14:16:03 <xored> omnIdiot: sorry i have to as this, but what does this (x:xs) mean..is that like a matching? i mean, if a list is past, he splitts the list up in "firstlement:rest"? what does this xs stands for, is it like a keywords?
14:16:15 <xored> %s/as this/ask this
14:16:27 <Zao> xored: It's convention for the rest of the Xes.
14:16:40 <omnIdiot> xored: that's right.  'xs' can be thought of as the plural of 'x'.
14:16:48 <Zao> c:cs, x:xs, and so on.
14:17:06 <xored> ah ok.
14:17:26 <xored> thank you!
14:18:24 <omnIdiot> xored: and you shouldn't apologize for asking questions!
14:18:36 <omnIdiot> :D
14:18:36 <hpaste>  xored pasted "just another implementation of init" at http://hpaste.org/3068
14:18:37 <swix> how does one get the nth element from a list?
14:18:46 <omnIdiot> > [1..5] !! 3
14:18:47 <lambdabot>  4
14:18:51 <bos> > [1,2,3]!!1
14:18:52 <lambdabot>  2
14:18:54 <swix> cool beans
14:19:00 <bos> @quote stereo
14:19:00 <lambdabot> z0d says: What was the stereo quote?
14:19:06 <MADnificent> xored: you aren't forced to follow that convention, but it is very clear (ie (x:a) would work too)
14:19:18 <bos> @quote majestic
14:19:18 <lambdabot> No quotes match. The more you drive -- the dumber you get.
14:19:23 <bos> gnaargh
14:19:28 <xored> MADnificent: my professor is using the same convetion, so i will use it
14:19:29 <omnIdiot> xored: part of the way there, but it'll blow up when it reaches the end.  There's no base case.
14:20:00 <hpaste>  omnIdiot annotated "just another implementation of init" with "with base case" at http://hpaste.org/3068#a1
14:20:09 <MADnificent> xored: it's best to do it, it makes your code clear! I just wanted to note that it's not a -limitation- that is enforced on you :)
14:20:40 <omnIdiot> oops!  I got that wrong!
14:20:58 <hpaste>  omnIdiot annotated "just another implementation of init" with "d'oh!" at http://hpaste.org/3068#a2
14:21:20 <jr__> @type (Prelude.+)
14:21:22 <lambdabot> forall a. (Num a) => a -> a -> a
14:21:29 <jr__> @type Prelude.+
14:21:31 <lambdabot> parse error on input `Prelude.+'
14:21:38 <jr__> why the parse error?
14:21:43 <xored> omnIdiot: the ORDER matters ?
14:22:06 <omnIdiot> jr__: @type takes an expression.  '+' isn't a valid expression.
14:22:08 <sorear> jr__: Because Prelude.+ is a qop, and there is no qop production in expr.
14:22:23 <sjanssen> @type +
14:22:26 <lambdabot> parse error on input `+'
14:22:42 <omnIdiot> xored: each case is tried in turn.  If it matches, it evaluates to the rhs, if not, it tries the next case.
14:23:00 <omnIdiot> (x:xs) includes (x:[]), when xs = []
14:23:08 <xored> omnIdiot: ah, ok.
14:24:06 <xored> omnIdiot: ([x])  = (x:[]) as you told me before...so what exactly are the brackets in here. I case your style of writing is much more clear to me ( and what its stand for )..what does actually the brackets mean there ?
14:24:25 <omnIdiot> parens are just grouping
14:24:40 <sjanssen> xored: [] means empty list
14:24:42 <fasta> When I run code that uses an assertion in ghci it doesn't ignore the assertion, but when run in ghc it does ignore it. I am compiling without a -O2 flag.
14:24:50 <fasta> What is going on?
14:25:00 <omnIdiot> withoutlast x:xs would be a parse error, since you can define operators infix in haskell.
14:25:16 <xored> sjanssen: thats clear, but as i suspect it, the match is dont by everting in that parens"
14:25:29 <xored> omnIdiot: got to read up what infix means, one second
14:25:42 <omnIdiot> (+) x y, vs. x + y
14:26:17 <xored> omnIdiot: was that + y x and y '+' x ?
14:26:43 <omnIdiot> > let x !!! y = x * (y + x) in 3 !!! 5
14:26:48 <lambdabot>  24
14:27:02 <omnIdiot> I defined a new operator (!!!)
14:27:23 <dino-> xored: No actually functions whose names are symbols need no decoration to be infix but require ( ) to be prefix.
14:27:40 <omnIdiot> so the parser would see 'withoutlast x:xs'' as defining (:), but 'withoutlast x' isn't valid on the left side
14:28:13 <xored> omnIdiot: ok ok, i guess iam getting it slowly
14:28:25 <omnIdiot> use parens for your patterns :)
14:28:32 <xored> yes sir
14:28:37 <fasta> I might have found it.
14:29:46 <hpaste>  xored pasted "the meaning of "|"" at http://hpaste.org/3069
14:30:30 <omnIdiot> | introduces a guard, it's more low-level syntax, i.e. not a pattern.
14:30:57 <fasta> xored: you had an exam tomorrow, right?
14:30:58 <dmwit> xored: "|" is used to make guards.  The thing between "|" and "=" must evaluate to a Bool.
14:31:05 <xored> fasta: yes
14:31:09 <omnIdiot> > let f x | even x = div x 2; | otherwise = 3 * x + 1 in f 5
14:31:09 <lambdabot>  Parse error
14:31:09 <fasta> xored: don't go :)
14:31:12 <misterbeebee-1> is there a way to run ghci/ghc or somesuch in "sugar-free" mode, so that one does not get confused by accidentally using syntax that does not mean what one thinks? It would be helpful for newbies.
14:31:26 <dmwit> > let f x | even x = div x 2 | otherwise = 3 * x + 1 in f 5
14:31:28 <lambdabot>  16
14:31:41 <dmwit> > let f x | even x = div x 2 | otherwise = 3 * x + 1 in iterate f 5
14:31:42 <lambdabot>  [5,16,8,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,...
14:31:43 <xored> fasta: haskell is 20% part of it..so dont worry. That iam doing haskell that much is just personal interest
14:32:13 <pejo> misterbeebee, why do you think that desugared haskell is better for editing?
14:32:27 <dmwit> misterbeebee-1: What syntax would you drop?
14:33:00 <dmwit> I find the clause "syntax that does not mean what one thinks" highly suspect.
14:33:07 <misterbeebee-1> pejo: I think it's easier to learn the concepts when the syntax is more literal.
14:33:34 <misterbeebee-1> at least at first.
14:34:20 <pejo> misterbeebee, so you want to write "fac = \n -> case n of 0 -> 1; _ -> n*fac (n-1)"?
14:34:55 <omnIdiot> ((*) n fac ((-) n 1))
14:34:59 <fasta> sjanssen: can I run both cpphs and drift as a preprocessor or do I need to specify a script for that? I.e. something like -pgmP foo -pgmP bar?
14:35:10 <omnIdiot> :P
14:35:16 <sjanssen> fasta: I don't know
14:35:18 <misterbeebee-1> omnIdiot: yeah :-)
14:35:36 * omnIdiot feels lispy
14:36:02 <misterbeebee-1> I'm not sure exactly what I'd propose...
14:36:21 <misterbeebee-1> the right choice probably depends on the assumptions and previous experience of  the individual
14:37:21 <xored> while "+ 1 2" produces a compiler erro, "(+) 1 2" does work, This is because in the second case (+) is evaluated as a function which needs to parameters, right ?
14:37:42 <misterbeebee-1> I think it'd be helpful to have a one-pager of the haskell sytactic sugars, and maybe to launch ghci with a bunch of flags enabling the ones that I have learned and understand.
14:37:49 <dmwit> xored: Pretty much, yes.
14:38:09 <dmwit> misterbeebee-1: -fno-monad-comprehensions
14:38:19 <dmwit> =)
14:38:38 <omnIdiot> @go tour of the haskell syntax
14:38:39 <lambdabot> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
14:38:39 <lambdabot> Title: Tour of the Haskell Syntax
14:39:08 <xored> dmwit: i hopefully can translate that right into english. (+) 1 2 is a reductable expression while "3" would be its "normal form", right ?
14:39:13 <omnIdiot> not exactly one page, though :)
14:39:39 <misterbeebee-1> and it doesn't separate basic syntax from sugar.
14:40:10 <misterbeebee-1> maybe that's the point of Helium
14:40:10 <xored> omnIdiot: you should work on your precision level :)
14:40:17 <dmwit> xored: I'm not totally sure; I've never studied far enough to get to understand normal forms.
14:40:51 <xored> dmwit: everything "unreductable" is normal form
14:40:58 <omnIdiot> xored: eh? my last comment was re: misterbeebee-1
14:41:04 <xored> dmwit: i just maybe call it the wrong way
14:41:13 <fasta> xored: AFAIK, yes
14:41:19 <xored> omnIdiot: i know, just was referencing to "not exactly on page" :)
14:41:28 <fasta> xored: there's also a function called rnf
14:41:40 <xored> fasta: and this function does ?
14:41:44 <fasta> xored: which Reduces to Normal Form
14:42:03 <fasta> > rnf []
14:42:04 <lambdabot>  Add a type signature
14:42:08 <fasta> > rnf [1]
14:42:10 <lambdabot>  ()
14:42:14 <jr__> hm, just trying to understand IO. I have some problems with IO.bracket at the moment, see here: http://hpaste.org/3070 why does variant 1 not work as expected (by me, at least)
14:42:16 <olsner> > 2*(product [1..11])
14:42:18 <dmwit> :t rnf
14:42:18 <lambdabot>  79833600
14:42:20 <lambdabot> forall a. (NFData a) => a -> Done
14:42:26 <omnIdiot> @src Done
14:42:27 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:42:29 <fasta> xored: never mind the return value
14:42:30 <dmwit> heh
14:42:37 <omnIdiot> :)
14:42:44 <fasta> xored: what's important is the internal evaluation effect.
14:42:44 <xored> hey guys..but i wanna listen !! :)
14:43:43 <sjanssen> @type Control.Exception.bracket
14:43:45 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:44:08 <misterbeebee-1> oh, here: but quite incomplete: http://en.wikibooks.org/wiki/Haskell/Syntactic_sugar
14:44:10 <sjanssen> jr__: the first one doesn't work because hGetContents is lazy
14:44:33 * dmwit attempts to write seq in terms of rnf
14:45:00 <xored> fasta: how to understnad that clearly, so only constants are in normal form? i mean: f :: Int -> Int .. f i = i ... is f 1 normal form ?
14:45:01 <sjanssen> jr__: it doesn't actually read from the Handle until the string is demanded
14:45:25 <sjanssen> jr__: so, when you close the handle, the output of hGetContents is truncated
14:45:30 <fasta> xored: read a book if you want to know
14:45:35 <dmwit> I am not succeeding.
14:45:35 <jr__> sjanssen: ah, ok. and the string is not demanded until the putStrLn?
14:45:42 <sjanssen> jr__: yep
14:45:54 <xored> fasta: hehe, great :)
14:46:31 <jr__> sjanssen: is it perhaps possible to "force hGetContents into strictness"
14:47:06 <sjanssen> jr__: yeah, you could use something like Control.Parallel.Strategies.rnf to force it
14:48:44 <misterbeebee-1> @src rnf
14:48:44 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:48:51 <jr__> ok, off reading yet more... thank you sjanssen
14:49:52 <misterbeebee-1> dmwit: rnf is defined in terms of seq.
14:50:14 <dmwit> rnf a = seq a ()
14:50:15 <dmwit> ?
14:50:23 <misterbeebee-1> yes
14:50:31 <sjanssen> no
14:50:48 <fasta> no :) majority is always right ;)
14:50:49 <sjanssen> rnf is a deep seq, so the definition depends on the type
14:50:52 <misterbeebee-1> well, yes and no:
14:50:52 <misterbeebee-1> http://darcs.haskell.org/ghc-6.6/packages/base/Control/Parallel/Strategies.hs
14:50:55 <lambdabot> http://tinyurl.com/22ed3w
14:51:02 <misterbeebee-1> yes, in some times, rnf a = seq a ()
14:51:10 <misterbeebee-1> er, in some types
14:51:50 <sjanssen> eg. [a]'s rnf looks like: rnf xs = foldr (\y ys -> rnf y `seq` ys) () xs `seq` xs
14:52:03 <dmwit> Yes, okay.
14:52:05 <dmwit> Very cool!
14:52:28 <dmwit> Oh, I see in that file: rwhnf x = x `seq` () -- default definition of rnf
14:53:13 <sjanssen> @type Control.Parallel.Strategies.rnf
14:53:18 <dmwit> Hey, they only go to 9-tuples! =P
14:53:21 <lambdabot> forall a. (NFData a) => a -> Done
14:53:22 <fasta> dmwit: that's Weak Head Normal Form
14:53:41 <omnIdiot> who needs more than pairs? :)
14:56:36 <xored> why is that one interrupting : test i = i + i where i = 3 ... but that one test i = i + i where i = i * i ... infinite ?
14:57:24 <sjanssen> xored: i = i * i is cyclic
14:57:40 <shachaf> xored: Maybe it's confusing because you're using the same name.
14:58:00 <shachaf> The first is like "test i = let j = 3 in j + j".
14:58:16 <shachaf> The second is like "test i = let j = j * j in j + j".
14:58:38 <omnIdiot> sjanssen: hmm, doesn't 'where i = ...' shadow the 'i = ...'?
14:58:45 <xored> shachaf: yeah but accourding to sjanssen the second one is not j*j + j*j
14:59:19 <shachaf> xored: You can ignore the argument here -- you're not using it in either function.
14:59:22 <ddarius> omnIdiot: That's irrelevant to what sjanssen said.  He's only talking about the where clause.
14:59:23 <sjanssen> "test i = i + i where i = i * i" is the same as "test _ = x + x where x = x * x"
14:59:34 <xored> sjanssen: where exactly is the cycle? i thought just like the "i" is replaced ( reduced ) by the parameter, so there is like i = 3*3 or similar
14:59:45 <omnIdiot> oh, I didn't see the second part of xored's question.
14:59:47 <sjanssen> xored: "x = x * x"
15:00:03 <ddarius> x = x * x = (x * x) * (x * x) = ...
15:01:06 <xored> ddarius: ok, but why is he not just inserting the parameter, because i cant use the parameter in the "where class" ? i was supsecting him to reduce x = x *x to x = 4*4
15:01:24 <omnIdiot> it'd be like defining 'int i(void) {return (i() * i());}'
15:01:30 <xored> "where class" = where case...man my brain is a brocoli right now
15:01:31 <ddarius> xored: where and let bindings are recursive
15:02:01 <ddarius> > let f = xs where xs = 1 : xs in f
15:02:02 <xored> ddarius: ok
15:02:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:02:27 <xored> ddarius: perfectly clear
15:02:56 <omnIdiot> > let { f = xs where { xs = 1 : xs } } in f -- more explicit bracketing if it's confusing
15:02:58 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:03:33 <xored> is that "let" acutally needed ? did not face it yet
15:03:35 <dmwit> > let f = 1 : f in f
15:03:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:03:40 <omnIdiot> xs is defined as '1', followed by 'xs'
15:03:57 <ddarius> xored: lambdabot (and GHCi for that matter) can't take top-level function declarations.
15:04:13 <ddarius> (actually, lambdabot can, but not with @run)
15:04:45 <omnIdiot> just expressions.
15:05:09 <omnIdiot> 'let decls in expr' is the way to introduce (possibly recursive) names in an expression
15:06:12 <xored> ok ok, iam getting closer. Infix means, 3 +3..+ is infix in this case, praefix is + 3 3, right ?
15:06:35 <dmwit> Right.
15:06:39 <omnIdiot> that would be prefix, yes, but in Haskell you must surround ops in parens to make them prefix
15:06:56 <dmwit> All alphanumeric function names in Haskell are prefix by default; all symbolic function names are infix by default.
15:06:59 <sioraiocht> or a function in backticks to make it infix
15:07:02 <Saizan> is there a guide to prolog for functional programmers?
15:07:08 <ddarius> > (3 + 3, (+) 3 3)
15:07:10 <lambdabot>  (6,6)
15:07:19 <omnIdiot> > (div 6 2, 6 `div` 2)
15:07:20 <lambdabot>  (3,3)
15:07:42 <sioraiocht> and, thankfully, there's no postfix syntanx
15:07:43 <ddarius> Saizan: Most introductions to Prolog should be very easy to read as a functional programmer
15:07:45 <sioraiocht> *syntax
15:08:13 <ddarius> > let (n !) = product [1..n] in (5 !)
15:08:13 <lambdabot>  Parse error in pattern
15:08:23 <shachaf> > let (!) n = product [1..n] in (5 !)
15:08:24 <lambdabot>  120
15:08:30 <dmwit> nasty
15:08:42 <fax> Hello
15:08:45 <dmwit> It fails if you leave parens off the (5!).
15:08:46 <dmwit> =(
15:09:05 <omnIdiot> (unfortunately, the report says (x !) = (\y -> x ! y), so that'd be an error in ordinary H98)
15:09:17 <ddarius> correct
15:09:19 <shachaf> Yes, it's a GHC extension.
15:09:25 <Saizan> ddarius: but then i want to write map and it seems impossible
15:09:34 <shachaf> Though there are no flags to enable it.
15:09:52 <ddarius> Saizan: That's because it kind of is.  (Okay, it is possible, but you don't want to see the solution.)
15:10:03 <ddarius> Saizan: Prolog doesn't support higher-order "functions".
15:10:17 <ddarius> Saizan: Prolog is a nasty language.
15:10:21 <fax> :/
15:10:28 <fax> Prolog is beautiful
15:10:28 <dmwit> Hi, fax!
15:10:29 <omnIdiot> :O!  No hofs?!
15:10:30 <xored> so product is a function which takes a [Int] to multiply each element and return it ?
15:10:37 <fax> Lambda Prolog has HOFs
15:10:37 <omnIdiot> xored: yep
15:10:41 <omnIdiot> @src product
15:10:42 <lambdabot> product = foldl (*) 1
15:10:57 <xored> aand let is just like a "predeclaratin"
15:11:05 <ddarius> fax: -Prolog- is ugly.  Logic programming can be nice and already LambdaProlog (which is a different language) is much much nicer.
15:11:27 <dmwit> Not foldl'?  All my beliefs are shattered!
15:11:29 <fax> ddarius: Well I have different eyes
15:11:50 <Saizan> ddarius: and even things like defining neq/2 as the "negation" of eq/2 is "impossible"? (i guess this follows from being first order)
15:11:52 <ddarius> Unfortunately, Prolog is the archetype and thus the one everyone should learn at the very least.
15:12:18 <fax> ddarius: Do you think there is something which would describe the concepts of Logic programming better than Prolog?
15:12:38 <fax> The system from Reasoned Schemer might suit, Curry might be too complex..
15:12:43 <ddarius> fax: Practically any other logic language.
15:12:59 <ddarius> fax: Particularly ones that are more serious about purity.
15:13:00 <fax> Name some? :)
15:13:05 <fax> ah ok
15:13:26 <omnIdiot> No hofs + side effects!!!???
15:13:27 <ddarius> Mercury, LambdaProlog, Twelf and many other LF based systems.
15:14:07 <fax> I came to ask about some logic programming implementation in Haskell :)
15:14:13 <fax> I was searching but couldn't find...
15:14:14 <ddarius> Unfortunately, there is no logic language with anywhere near the backing of Prolog.
15:14:31 <ddarius> fax: There should be tons of stuff.
15:14:37 <fax> So I wondered.. does anyone know where to get the one written by Amr Sabry?
15:14:45 <fax> It's a haskell version of the one from Reasoned Schemer
15:14:50 <fax> I checked his site but it's not ther :[
15:15:42 <ddarius> I don't know about that, but lookup "Typed Logical Variables in Haskell" for a good basis for a logic language implementation.
15:16:07 <ddarius> I built a pure Prolog on top of that in 80ish lines with the first cut, parser and all.
15:16:17 <xored> what is wrong with that : let q x y = x + y in (3 'q' 4)
15:16:25 <Saizan> does those  other languages typed?
15:16:25 <fax> :o
15:16:26 <omnIdiot> xored: backticks
15:16:26 <ddarius> ' /= `
15:16:30 <fax> thanks ddarius
15:16:44 <omnIdiot> 'q' is a Char.  `q` is an operator
15:16:47 <Saizan> err, are those other logic languages typed?
15:16:47 <xored> omnIdiot: hm i defined q as prefix, 'q' would make the infix, or ?
15:17:12 <ddarius> Saizan: I'm not exactly sure about LambdaProlog but the others I listed are.
15:17:43 <omnIdiot> xored: you use backticks to infixize a function (they should be located on the upper-left of your keyboard).  Quotation marks make a Char literal.
15:17:47 <ddarius> There's also Goedel and Escher, but I haven't really looked at Goedel and Escher is a functional logic language.
15:17:58 <xored> sorry...my professor uses " ' " instead of " ` " what is wrong i guess
15:18:18 <xored> omnIdiot: got that, thank you
15:18:27 <omnIdiot> Is there a Bach language :3
15:18:44 <ddarius> (For logic languages in general, I don't know whether Goedel is typed or not.)
15:18:47 * Cale solves problems meant for computers by hand :)
15:18:49 <xored> if ddarius woudl have write ' != ` i would even get it faster..but iam not haskelled yet :)
15:18:58 <xored> *written*
15:19:00 * fax cries
15:19:06 <fax> Cale: I wish I could!
15:19:25 * fax has been struggling with some maths for a week... I can solve this in 1 min on a computer though :p
15:19:26 <omnIdiot> xored: if you like you could define 'x != y = x /= y'  :)
15:19:40 <omnIdiot> or '(!=) = (/=)'
15:19:44 <Cale> Anyone feel like writing a solution to this problem? Find a cycle of length 21 where for every two adjacent elements (n,m) either n is a divisor of m or m is a divisor of n.
15:20:00 <Cale> Oh, with minimal elements.
15:20:06 <ddarius> Solving computer programs by hand would in most cases be boring as hell.
15:20:19 <xored> omnIdiot: no :) i guess i will really stick with haskell :) I must really admit, iam totaly suprised how it works so effectivly for anything math related..
15:20:20 <lament> Cale: you mean like 1,2,4,8,....
15:20:26 <Cale> lament: yeah.
15:20:40 <lament> or 42,42,42,42...
15:20:54 <Cale> no
15:20:59 <Cale> heh, distinct :)
15:21:15 <lament> 42,-42,42... :D
15:21:18 <Cale> My best attempt: 1, 27, 9, 18, 2, 14, 28, 7, 21, 3, 15, 5, 20, 10, 30, 6, 12, 24, 4, 8, 16
15:21:35 <ddarius> Cale: How do you know it's minimal?
15:21:56 <Cale> I don't, but I could almost be bothered proving it
15:22:08 <ddarius> Cale: I had meant in the general case.
15:22:30 <ddarius> That part of the problem as well.
15:22:42 <omnIdiot> sum (map abs list) is the smallest?
15:23:00 <Cale> No, max (map abs list) is the smallest
15:23:05 <Cale> maximum*
15:23:19 <Cale> (though, really, just work with positive integers)
15:23:50 <omnIdiot> (that was to prevent against large negatives :)
15:23:55 <Cale> 1 is the minimum allowed number
15:24:13 <Cale> (I really should have been more careful about phrasing the problem :)
15:24:17 <omnIdiot> hehe
15:24:19 <lament> so all the elements have to be distinct?
15:24:23 <Cale> yeah
15:25:29 <omnIdiot> so a list such that all (<30) would be more minimal than yours?
15:25:36 <TSC> That means that some numbers can be ruled out (large primes, e.g. 23, 29, 17, 19)
15:25:46 <Cale> yeah
15:26:10 <Cale> 31 too, of course
15:26:20 <misterbeebee-1> the only possible tweak could be to use 26 instead of 30
15:26:22 <Cale> er, my max was 30, yeah :)
15:26:38 <misterbeebee-1> but it has fewer useful factors
15:26:43 <Cale> right
15:27:05 <Cale> 26 just goes to 13, which doesn't go anywhere (except back to 1)
15:27:24 <Cale> er, and 2 of course
15:27:48 <TSC> 1 is neighboured by 27 and 16; it seems like it would be more useful to use 1 to go to and from primes
15:28:13 <lament> true
15:28:30 <hpaste>  xored pasted "test of cases" at http://hpaste.org/3071
15:28:39 <Cale> but what would join 16 to 27? :)
15:28:57 <misterbeebee-1> ah, relative primes
15:29:04 <Cale> That's my highest power of 2 and my highest power of 3
15:29:17 <TSC> Yeah
15:29:28 <omnIdiot> xored: since you are using the (==) operator on l, you assert that l's elements can be compared for equality, so null's type would be :: Eq a => [a] -> Int
15:29:28 <TSC> How amenable is the problem to exhaustive search?
15:29:45 <Cale> Well, I did this by hand using a graph manipulation tool.
15:29:48 <lament> pretty amenable i say.
15:29:54 <Cale> yeah, you can do it :)
15:30:04 <Cale> Basically, it's a longest cycle problem
15:30:25 <Cale> In the divisibility graph for the first n positive integers.
15:30:47 <xored> omnIdiot: Wah!! what...second, what is actually working is null l = (l==[]) with an definition of null :: [a] -> Bool
15:30:58 <TSC> Are there polytime algorithms for longest cycle?
15:31:02 <xored> xored: so what changes if i use the guards ?
15:31:13 <Cale> xored: (l == []) isn't the same as null l
15:31:19 <omnIdiot> xored: it changes when you use the (==) operator on l.
15:31:23 <Cale> xored: because it requires == to be defined
15:31:59 <Cale> TSC: Are there polytime algorithms for Hamiltonian cycle?
15:32:05 <omnIdiot> @type (==)
15:32:08 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:32:19 <Cale> ;)
15:32:23 <omnIdiot> this adds the Eq constraint to both arguments of (==)
15:32:27 <Cale> It's NP-complete
15:32:48 <xored> Cale: one second, i find some :)
15:33:00 <Cale> (but at this size, that's not so bad)
15:33:11 <TSC> Ah, oh well
15:33:47 <xored> > let null l = (l==[]) in null []
15:33:48 <lambdabot>  True
15:33:59 <xored> omnIdiot: but why is that working then ?
15:33:59 <Cale> hehe
15:34:13 <Cale> It's working because the type of the list is being defaulted.
15:34:28 <omnIdiot> xored: that's because the [] in (null []) is inferred to be :: [Integer], and Integers are in the Eq class.
15:34:30 <Cale> > let null l = (l==[]) in null ([] :: [a])
15:34:32 <lambdabot>  True
15:34:36 <Cale> nice, heh
15:34:37 <xored> omnIdiot: ok..
15:34:44 <Cale> :t let null l = (l==[]) in null
15:34:46 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
15:34:57 <Cale> :t let null l = (l==[]) in null [id]
15:34:59 <lambdabot>     No instance for (Eq (a -> a))
15:34:59 <lambdabot>       arising from use of `null' at <interactive>:1:24-32
15:35:13 <dino-> I note that the impl of null uses pattern match for []  http://www.cse.unsw.edu.au/~dons/data/Prelude.html
15:35:13 <lambdabot> Title: Haskell 98 Prelude
15:35:17 <Cale> :t let null l = (l==[]) in null ([] :: [a -> a])
15:35:19 <lambdabot>     No instance for (Eq (a -> a))
15:35:20 <lambdabot>       arising from use of `null' at <interactive>:1:24-44
15:35:34 <Cale> right, that's the right way to define it
15:35:54 <dino-> But I wonder why the other case had to be: null (_:_) = False
15:35:55 <Cale> :t let null [] = True; null _ = False in null ([] :: [a -> a])
15:35:57 <lambdabot> Bool
15:36:00 <dino-> Why not just null _ = False
15:36:00 <Cale> > let null [] = True; null _ = False in null ([] :: [a -> a])
15:36:02 <lambdabot>  True
15:36:09 <dino-> If the first case gets the empty?
15:36:14 <Cale> dino-: It could be.
15:36:25 <Cale> dino-: It's just nice to have nonoverlapping patterns
15:36:34 <dino-> ah, compiler warning?
15:36:46 <Cale> Nah, it shouldn't warn about them like that
15:37:05 <Cale> However,
15:37:15 <Cale> > let null _ = False; null [] = True in null ([] :: [a -> a])
15:37:16 <lambdabot>      Warning: Pattern match(es) are overlapped
15:37:16 <lambdabot>              In the definition...
15:37:27 <Cale> reordering the definitions produces problems
15:37:30 <dino-> ya
15:37:35 <Cale> > let null (_:_) = False; null [] = True in null ([] :: [a -> a])
15:37:37 <lambdabot>  True
15:37:50 <omnIdiot> sorry, got disconnected..
15:38:03 * omnIdiot checks logs
15:38:51 <xored> what does [3, 4..12] actually mean in haskell? i first thought is "rest classes" but it aint
15:38:52 <fax> hrmmm :|
15:38:57 <fax> Should I email someone asking for haskell code?
15:39:02 <Cale> > [3,4..12]
15:39:03 <fax> I wonder i fthey get mad
15:39:04 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
15:39:06 <Cale> > [3,5..12]
15:39:07 <lambdabot>  [3,5,7,9,11]
15:39:10 <Cale> > [3,6..12]
15:39:11 <lambdabot>  [3,6,9,12]
15:39:19 <fax> I really wanna see this logic stuff though
15:39:21 <Cale> It sets the skip
15:39:31 <omnIdiot> [3, 4 .. 12] = enumFromThenTo 3 4 12
15:40:05 <MyCatVerbs> xored: linear interpolation. [x,x+y..z] creates a list of numbers between x and z by adding y each time. :)
15:40:05 <ddarius> fax: Unless you make an ass of yourself, they'll probably respond reasonably.
15:40:39 <Cale> > [0,5..]
15:40:41 <lambdabot>  [0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,1...
15:40:47 <ddarius> The Giant Voice System is saying something unintelligible and really long.
15:40:54 <dino-> Oh wow, I didn't know that about the skip.
15:40:56 <fax> > [0,0.001...1]
15:40:56 <lambdabot>   Not in scope: `...'
15:41:02 <fax> > [0,0.001..1]
15:41:04 <lambdabot>  [0.0,1.0e-3,2.0e-3,3.0e-3,4.0e-3,5.0e-3,6.0e-3,7.0e-3,8.0e-3,9.0000000000000...
15:41:08 <dino-> I would have thought it would do the entire contiguous list for the range part.
15:41:17 <ddarius> @pl [2,4..]
15:41:18 <lambdabot> [2,4..]
15:41:30 <byorgey> dino-: nope.  if you want that, do something like [2] ++ [5..12]
15:41:37 <byorgey> > [2] ++ [5..12]
15:41:38 <omnIdiot> @pl enumFromThen 2 4
15:41:38 <lambdabot> [2,4..]
15:41:39 <lambdabot>  [2,5,6,7,8,9,10,11,12]
15:41:40 <ddarius> @pl \x y -> [x,y..]
15:41:40 <lambdabot> enumFromThen
15:41:48 <ddarius> @pl \x y z -> [x,y..z]
15:41:48 <lambdabot> enumFromThenTo
15:42:00 <Cale> @pl fac n = product [1..n]
15:42:00 <lambdabot> fac = product . enumFromTo 1
15:42:51 <Cale> @pl multifac n k = product [n,n-k..1]
15:42:51 <lambdabot> multifac = (product .) . flip flip 1 . liftM2 (.) enumFromThenTo (-)
15:43:16 <byorgey> flip flip!
15:43:34 <Cale> :t flip flip
15:43:37 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
15:43:47 <ddarius> I like liftM2 (.)
15:44:02 <iguana_> :t liftM2 (.)
15:44:04 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
15:44:32 <Cale> (e -> b -> c) -> (e -> a -> b) -> e -> a -> c
15:44:39 <hpaste>  omnIdiot annotated "test of cases" with "(no title)" at http://hpaste.org/3071#a1
15:44:50 * fax hopes for the best :S
15:45:27 <hpaste>  Cale annotated "test of cases" with "Num!" at http://hpaste.org/3071#a2
15:45:34 <fax> >:|
15:45:45 <omnIdiot> oh crud.
15:46:22 * omnIdiot should have left it out :D
15:46:45 <omnIdiot> @type [1]
15:46:48 <lambdabot> forall t. (Num t) => [t]
15:47:00 <omnIdiot> @type \l -> l == [1]
15:47:02 <lambdabot> forall t. (Num t, Eq [t]) => [t] -> Bool
15:47:13 <Cale> Yeah, but that's redundant :)
15:47:14 <hpaste>  byorgey annotated "test of cases" with "what's wrong with pattern-matching?" at http://hpaste.org/3071#a3
15:47:30 <Cale> Because somewhat stupidly, Num is a subclass of Eq
15:48:14 <omnIdiot> Num is kind of a field, right?  Are there fields such that (==) makes no sense?
15:48:35 <Cale> omnIdiot: yeah, but only because (==) becomes uncomputable
15:48:44 <ddarius> omnIdiot: The reals to pick an example.
15:48:46 <lament> num is kind of a ring i'd think?
15:48:46 <hpaste>  iguana annotated "test of cases" with "pointless!" at http://hpaste.org/3071#a4
15:48:54 <hpaste>  xored pasted "which variant is better" at http://hpaste.org/3072
15:49:26 <Cale> Yeah, Num is more like rings (with absolute value for some reason)
15:49:53 <iguana_> oh, I misread "1" as "l"
15:49:54 <byorgey> iguana_: except that version doesn't work for infinite lists...
15:49:59 <misterbeebee-1> Cale:do you think the "interestingness" of the cycle problem is in some cool closed-form expression for f(21) = 30, or do you think the best solution would be a non-NP search that generates 21 numbers in a cycle using 4 prime factors?
15:50:09 <xored> i woudl say, the [] ( set ) varian is better, because i can even select some element by a expression
15:50:10 <hpaste>  omnIdiot annotated "which variant is better" with "this one :)" at http://hpaste.org/3072#a1
15:50:30 <omnIdiot> @src map
15:50:30 <lambdabot> map _ []     = []
15:50:30 <lambdabot> map f (x:xs) = f x : map f xs
15:50:51 <omnIdiot> map already does the recursion you have in your second definition
15:51:10 <byorgey> xored: of those two, I'd prefer the first, but yeah, you should definitely use map instead =)
15:51:24 <xored> guys you are struggling me to death !
15:51:37 <xored> i mean i learn something new each 20 seconds.. :)
15:51:45 <omnIdiot> it's a *good* pain :D
15:51:58 <xored> ;)
15:52:06 <lament> xored: "Ursula" is Latin for "little bear".
15:52:26 <omnIdiot> bahahahaha, took me a second there
15:52:28 <xs> xored: "bear" is latin for small child
15:53:34 <lament> xored: Rafflesia Arnoldii has individual flowers over a meter in diameter, and smells like rotten meat.
15:54:00 <byorgey> xored: actually, the second version you posted there ('double') does not work, since it has no base case.
15:54:00 <omnIdiot> Samus Aran is a woman.
15:54:18 <byorgey> > let double (x:xs) = (x*2):double xs in double [1,2,3]
15:54:19 <lambdabot>   Non-exhaustive patterns in function double
15:54:33 <byorgey> you have to add a case that says what happens when you call double on an empty list.
15:54:55 <ddarius> > let double (x:xs) = 2*x:doulble xs in double [1..]
15:54:56 <lambdabot>   Not in scope: `doulble'
15:55:00 <ddarius> > let double (x:xs) = 2*x:double xs in double [1..]
15:55:01 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
15:55:03 <omnIdiot> double (3 : []) -> (3 * 2) : double [] -- double [] isn't defined
15:55:19 <lament> ddarius: cheater!
15:55:39 <Cale> misterbeebee-1: I don't know :)
15:55:42 <omnIdiot>  > let double (x:xs) = (x*2):double xs in take 2 (double [1,2,3])
15:55:49 <omnIdiot> > let double (x:xs) = (x*2):double xs in take 2 (double [1,2,3])
15:55:50 <lambdabot>  [2,4]
15:56:09 <xored> you guys are totaly crazy :D
15:56:16 <omnIdiot> it works fine until you get to the nil at the end.
15:56:18 <Cale> misterbeebee-1: Though it would be really cool to see a closed form for f(n), that sounds like something which is beyond the grasp of contemporary mathematics.
15:56:55 <Cale> (well, a useful closed form)
15:57:04 <misterbeebee-1> I have a feeling that since you're dealing with both multiplaction of primes an addition, there isn't a useful closed form
15:57:12 <Cale> right
15:57:14 <omnIdiot> xored: we are Haskellers, it's in the job description
15:57:36 <misterbeebee-1> but still, an efficient enumeration of (max value, cycle, length) would be a nice pearl.
15:58:17 <byorgey> misterbeebee-1, Cale: what function are you talking about?
15:58:38 <misterbeebee-1> cale: definitely feels like a monoid or functor or something
15:58:41 <misterbeebee-1> byorgey: <Cale> Anyone feel like writing a solution to this problem? Find a cycle of length 21 where for every two adjacent elements (n,m) either n is a divisor of m or m is a divisor of n.
15:58:51 <xored> omnIdiot: but honestly, there arent much channel in freenode, which are that helpfull and acquiescent ...iam extremly suprised
15:59:00 <oerjan> misterbeebee-1: um, what addition?
15:59:21 <oerjan> however, comparing might be a problem
15:59:22 <Cale> byorgey: also, the elements are positive integers, and the maximum element of the cycle is minimal
15:59:32 <Cale> oerjan: in the definition of <
15:59:34 <byorgey> interesting
15:59:49 <Cale> blah, *distinct* positive integers :)
16:00:00 <byorgey> ok, right, I figured that =)
16:00:36 <omnIdiot> length (nub xs) = length xs = 21, xs :: NatGTZero
16:01:06 <xored> its unbelieveable how fast you can implement a quicksort in haskell...
16:01:29 <lament> yes, haskell is optimized for implementing quicksort.
16:01:39 <misterbeebee-1> oerjan: i don't know :-)  something like... an space of sets that allow a sequence (like [2,10,30,15,5]) with a characteristic (max n, length) , and a union operation over them
16:01:47 <omnIdiot> haskell is optimized for implementing
16:01:49 <fax> hm
16:01:53 <omnIdiot> end of sentence
16:01:56 <lament> haskell is.
16:02:28 <misterbeebee-1> "Haskell." is the answer. "Java?" is the question.
16:02:32 <xored> omnIdiot: are there actually application written in haskell? I guess, haskell is no touring complete or ?
16:02:35 * misterbeebee-1 starting a Java job in two weeks 
16:02:37 <fax> damn where is that pdf about quicksort
16:02:47 <omnIdiot> xored: of course it's turing complete!
16:02:53 <xored> omnIdiot: honestly ?
16:02:55 <omnIdiot> @wiki Applications and libraries
16:02:55 <lambdabot> http://www.haskell.org/haskellwiki/Applications_and_libraries
16:03:01 <omnIdiot> honestly!
16:03:08 <misterbeebee-1> xored: you've offended lambdabot
16:03:12 <lament> haskell is a programming language?? I thought it was just a math notation system!
16:03:13 <xored> ohoh
16:03:25 <omnIdiot> @vixen You're written in Haskell, aren't you?
16:03:26 <lambdabot> Ooh, functional programmers are so hot!
16:03:28 <fax> xored: You've seen quicksort in haskell?
16:03:39 <xored> fax: yeh
16:03:46 <xored> fax: oneliner
16:03:55 <fax> That is quadratic sort I thought
16:04:13 <omnIdiot> pugs, an implementation of perl6; darcs, a drcs; xmonad, and x11 window manager; house, an operating system
16:04:21 <fax> There was a really good paper about writing actual quicksort in haskell I can't find it though :/
16:04:36 <sjanssen> fax: it's quadratic in the worst case, just like any other naive quicksort
16:04:40 <omnIdiot> frag, a first person shooter
16:05:11 <hpaste>  xored pasted "quicksort" at http://hpaste.org/3073
16:06:31 <hpaste>  omnIdiot annotated "quicksort" with "the libs are full of chocolatey goodness" at http://hpaste.org/3073#a1
16:08:07 <xored> omnIdiot: ye ye ye give me one week !!!
16:08:33 <omnIdiot> CHOCOLATEY GOODNESS!!
16:09:08 <byorgey> speaking of chocolatey goodness, there's also Data.List.sort...
16:09:25 <sioraiocht> @src sort
16:09:25 <lambdabot> sort = sortBy compare
16:09:34 <sioraiocht> @src sortBy
16:09:34 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:09:40 <byorgey> look! more chocolatey goodness!
16:09:46 <sioraiocht> @src insertBy
16:09:46 <lambdabot> insertBy _   x [] = [x]
16:09:47 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
16:09:47 <lambdabot>                                  GT -> y : insertBy cmp x ys'
16:09:47 <lambdabot>                                  _  -> x : ys
16:09:55 <byorgey> hm, is that insertion sort?
16:09:55 <omnIdiot> insertion sort.  The actual implementation is mergesort iirc.
16:09:59 <sioraiocht> THERE's the recursion
16:10:01 <byorgey> ah, ok
16:10:22 <sioraiocht> but, conveniently
16:10:39 <sioraiocht> head . sort runs in linear time
16:11:16 <omnIdiot> as does minimum :)
16:11:25 <sioraiocht> omnIdiot: but that's no fun
16:11:31 <sioraiocht> @src minimum
16:11:31 <lambdabot> minimum [] = undefined
16:11:31 <lambdabot> minimum xs = foldl1 min xs
16:11:42 <oerjan> take n . sort presumably too
16:12:04 <oerjan> (for a fixed n)
16:12:31 <misterbeebee-1> where's a good university to do a research masters in functional programming theory (with an eye to software engineering, not higher algebra)?
16:12:41 <sjanssen> interestingly, the canonical Haskell quick sort isn't actually a quick sort -- it's a deforested tree sort
16:12:49 <sioraiocht> misterbeebee-1: is a taught masters with a dissertation out of the question?
16:13:25 <misterbeebee-1> I think that's the same as what I'm thinking.... (I'm in the US) about 8 semesters of coursework plus a research project
16:13:26 <sioraiocht> misterbeebee-1: Oxford's MSc in CS woud allow you to do that nicely
16:14:23 <oerjan> > M.toList . M.fromList $ [sin n | n <- [1..20]]
16:14:24 <lambdabot>   add an instance declaration for (Enum (k, a))
16:14:25 <lambdabot>     In a list comprehension: ...
16:14:56 <oerjan> > S.toList . S.fromList $ [sin n | n <- [1..20]]
16:14:57 <lambdabot>   Not in scope: `S.fromList'
16:15:07 <sjanssen> oerjan: fromList . toList
16:15:09 <oerjan> > Data.Set.toList . Data.Set.fromList $ [sin n | n <- [1..20]]
16:15:11 <lambdabot>  [-0.9999902065507035,-0.9613974918795568,-0.9589242746631385,-0.756802495307...
16:15:13 <sjanssen> erm, nevermind
16:15:18 <omnIdiot> @docs Data.Set
16:15:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
16:15:22 <fax> > Data.Set.fromList $ [sin n | n <- [1..20]]
16:15:24 <lambdabot>  fromList [-0.9999902065507035,-0.9613974918795568,-0.9589242746631385,-0.756...
16:15:31 <fax> :\
16:15:49 <sioraiocht> misterbeebee-1: http://web.comlab.ox.ac.uk/oucl/courses/grad07-08/cs/prospective.html
16:15:51 <lambdabot> Title: The MSc in Computer Science, http://tinyurl.com/ywbx9c
16:16:28 <misterbeebee-1> sioraiocht: thanks for the pointer. I didn't know about Oxford, I only knew of the universities that have hosted ICFP contests. :)
16:16:37 <sioraiocht> hahaha
16:17:57 <EvilTerran> come to oxford, we've got lions! lions and tigers, only in oxford!
16:18:09 <omnIdiot> forget yale
16:18:17 <sioraiocht> EvilTerran: btw, I hate your college, it rejected me
16:18:25 <sioraiocht> EvilTerran: what program are you in?
16:18:29 <EvilTerran> what, keble? that harsh....
16:18:43 * EvilTerran is in the four-year compsci course
16:18:54 <sioraiocht> ah, I'm sure I'll see you around ;)
16:19:02 <EvilTerran> (undergrad. planning to do DPhil)
16:19:18 <sioraiocht> hehe I'm doing my MSc, planning on doing my Dphil
16:19:38 <Syzygy-> Already doing dr.rer.nat :)
16:19:54 <Syzygy-> And I've taken fil.kand. and fil.mag.
16:20:30 <EvilTerran> keble's really well-placed for CS
16:20:43 <sioraiocht> EvilTerran: rub it in =p St anne's put me in summertown
16:20:56 * sioraiocht did NOT choose St anne's on his application
16:21:41 <EvilTerran> ach, i'll have to live out in 3rd year. probably near Marston.
16:22:38 <misterbeebee-1> keble doesn't look well-placed for CS: http://www.google.com/search?q=keble&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:en-US:official&client=firefox-a
16:22:40 <lambdabot> Title: keble - Google Search, http://tinyurl.com/2wsyek
16:22:48 <EvilTerran> keble's nice if you can live in, for CS especially, but otherwise it's nothing special
16:22:49 <sioraiocht> misterbeebee-1: it's across the street from the lab
16:22:51 <xored> iam of to bed, good night
16:22:56 <misterbeebee-1> click on the tob-result, keble misparses the google query string
16:23:09 <misterbeebee-1> good luck on your test, xored
16:23:18 <xored> > "Good nigth"
16:23:29 <lambdabot>  "Good nigth"
16:23:31 <EvilTerran> literally one block from the lab, likewise the maths institute and the lecture theatre the maths people use (in the natural history museum)
16:23:40 <xored> misterbeebee-1: thank you, and thank you for all your helps guys, n
16:23:47 <misterbeebee-1> sioraiocht: (I'm just poking fun at keble's website programmers)
16:23:50 <sioraiocht> heh
16:24:03 <EvilTerran> the website's a bit crummy, ja
16:25:18 <misterbeebee-1> (btw, in case the effect I saw isn't visible to you: when I follow the google link, kebel website parses aq=t as teh search query, and highlights all the "t" characters)
16:25:18 <sioraiocht> EvilTerran: would you stay in keble for your dphil?
16:25:47 <EvilTerran> ideally, yeah. i don't know how friendly keble is to postgrads.
16:26:17 <EvilTerran> i know they throw third-years out if they're doing a four year course, but i think they let 'emin again afterwards
16:26:18 <sioraiocht> EvilTerran: from what i've heard the MCR is really nice, and they house them just up banbury road, but still within site of the science complex
16:26:40 <EvilTerran> yeah, the MCR room itself is well plush. dunno 'bout the rooms.
16:27:55 <Beelsebob> @seen jaffacake
16:27:55 <lambdabot> I saw jaffacake leaving #ghc and #haskell 6d 4h 22m 53s ago, and .
16:28:25 * sioraiocht might try to apply to Keble for his DPhil.
16:28:36 <TSC> Cale: I've coded your cycle problem to see what I can find
16:28:54 <blarz> err, nice. is it right the "[3, 5..23]" gives me all primes between 3 to 23?
16:29:13 <fax> blarz: is 15 prime ?
16:29:13 <omnIdiot> > [3, 5.. 23] -- not exactly
16:29:15 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23]
16:29:24 <blarz> no it's not
16:29:37 <blarz> hm 21 is not
16:29:42 <TSC> And 9
16:29:47 <blarz> ok ;)
16:29:50 <blarz> hmm...
16:29:53 <TSC> But apart from those, sure
16:30:10 <P_D> It gives you all the primes between 3 and 23, with a few bonus approximate primes.
16:30:20 <sioraiocht> > map head $ iterate (\ (p:xs) -> [ x | x <- xs, x `mod` p /= 0]) [2..]
16:30:22 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:30:25 <sioraiocht> there ay go
16:30:32 <sgillespie> hello
16:30:57 <fax> > last $ map head $ iterate (\ (p:xs) -> [ x | x <- xs, x `mod` p /= 0]) [2..]
16:31:01 <lambdabot> Terminated
16:31:08 <fax> :I
16:31:10 <sioraiocht> lol
16:31:18 <omnIdiot> @. elite run last [1..]
16:31:22 <lambdabot> T3R/\/\InAT3d
16:32:20 <sioraiocht> > let sieve (x:xs) = x: sieve [ y | y <- xs, y `mod` x /= 0] in sieve [2..]
16:32:22 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:32:43 <omnIdiot> why the LC instead of filter?
16:32:58 <sioraiocht> because it's the first way I thoght of to do it?
16:33:05 <hpaste>  ryani annotated "how to make this accumulate" with "accumulate state" at http://hpaste.org/3057#a1
16:33:06 <oerjan> > nubBy (((>1).).gcd) [2..]
16:33:08 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:33:08 <LoganCapaldo> @bot
16:33:08 <lambdabot> :)
16:33:51 <sgillespie> hello
16:33:52 <omnIdiot> oerjan: evil :)
16:34:06 <omnIdiot> hiya sgill
16:34:09 <fax> > map (((>1).).gcd) [2..]
16:34:10 <lambdabot>  [<Integer -> Bool>,<Integer -> Bool>,<Integer -> Bool>,<Integer -> Bool>,<In...
16:34:14 <sgillespie> so I'm trying to find the ghc tests (according to the devwiki its in tests/ghc-regress)
16:34:21 <sgillespie> where is it or how do I get it?
16:34:57 * omnIdiot doesn't know, sorry
16:35:08 <sgillespie> damn...
16:35:20 <omnIdiot> @src nubBy
16:35:20 <lambdabot> nubBy eq []             =  []
16:35:20 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:37:06 <omnIdiot> it gets the unique elements from [2..], where x == y = gcd x y > 1
16:37:55 <ddarius> sgillespie: Presumably it's in the source tree.
16:38:26 <sgillespie> its in a different repo apparently
16:38:54 <sgillespie> http://darcs.haskell.org/testsuite
16:38:57 <lambdabot> Title: Index of /testsuite
16:55:26 <oerjan> @users
16:55:26 <lambdabot> Maximum users seen in #haskell: 420, currently: 353 (84.0%), active: 14 (4.0%)
16:56:03 <blarz> how's the activity measured?
16:56:18 <lament> within the last something minutes
16:56:26 <oerjan> @users
16:56:26 <lambdabot> Maximum users seen in #haskell: 420, currently: 353 (84.0%), active: 14 (4.0%)
16:58:51 <ddarius> Whoa, 420
17:03:58 <sioraiocht> we're popular
17:04:19 <sioraiocht> at least, amongst the sort of nerds that would frequent a functional programming langauge irc channel
17:04:34 <sioraiocht> and that sort is like...the nerd's nerd
17:04:58 <oerjan> nerdus nerdorum
17:07:11 <blarz> that's quite a good explanation I guess
17:22:25 <sioraiocht> lol
17:26:39 <LoganCapaldo> > 'a':"ab"
17:26:41 <lambdabot>  "aab"
17:28:50 <LoganCapaldo> > 0:[]
17:28:52 <lambdabot>  [0]
17:30:16 <TSC> It's cons
17:30:28 <LoganCapaldo> you some kind of cons artist?
17:32:45 <idnar> hahaha
17:36:22 <ramza3> I see "data ABC = ABC" and then "type ABC = (Float)" ...etc, what is the difference
17:36:43 <TSC> "data" makes a new data type; "type" makes an alias for an existing type
17:36:53 <ramza3> a
17:36:55 <ramza3> h
17:36:55 <ramza3> ah
17:37:37 <ramza3> will I get a error if I define a "data" type for an existing "type"
17:37:50 <LoganCapaldo> (a :: ABC) = 3 :: Float would work
17:38:14 <LoganCapaldo> data ABC = F Float (a :: ABC) = 3 :: Float woudl not
17:38:21 <LoganCapaldo> I think I screwed up the parens
17:38:26 <LoganCapaldo> but you get the idea
17:38:31 <ramza3> nod
17:38:34 <TSC> I don't think you can redefine existing types, as in "data Int = ..."
17:39:34 <LoganCapaldo> you can do something like import Prelude hiding (int) data Int = .. I don't know how hot that would work for Int
17:39:40 <LoganCapaldo> but it'll work for thing slike Maybe etc.
17:39:57 <Beelsebob> hiding Int sounds fun
17:40:09 <Beelsebob> then I can redefine data Int = Zero | Succ Int
17:40:26 <ramza3> in the frag source, they have "type Vec3 = (Double,Double,Double)" that could just as easily be a data Vec3 = Vec3 Double Double Double
17:40:53 <Beelsebob> ramza3: depends on the rest of the source
17:41:09 <Beelsebob> first thing you'd abviously need to do is change the syntax wherever you use a Vector
17:41:25 <Beelsebob> but with type Vec3 = (Double,Double,Double) there's slightly more flexibility
17:41:37 <Beelsebob> e.g. if I define type Col3 = (Double,Double,Double)
17:41:42 <Beelsebob> the two are literally the same type
17:41:50 <Beelsebob> so I can take a vector, and call it a colour
17:41:53 <Beelsebob> because they're the same thing
17:42:08 <Beelsebob> if I'd defined a data type with data or newtype, I couldn't do that
17:42:24 <ramza3> really, what error would Iget
17:42:25 <ramza3> get
17:42:39 <Beelsebob> well, if I were to define the colour type with data... I would do
17:42:47 <Beelsebob> data Col3 = Col3 Double Double Double
17:42:56 <Beelsebob> a value would look like Col3 0.5 0.3 0.4
17:43:00 <ramza3> ok
17:43:07 <Beelsebob> the type checker would be able to tell, "that's a Col3"
17:43:20 <Beelsebob> and would complain if it tried to unify that with Val3
17:43:28 <ramza3> christ
17:43:41 <Beelsebob> so you would get something like type error blah... expected type Val3, infered type Col3
17:44:09 <ramza3> is there a wiki page on this
17:44:54 <ramza3> I guess this will work. http://haskell.org/haskellwiki/GHC/Indexed_types
17:44:58 <lambdabot> Title: GHC/Type families - HaskellWiki
17:45:11 <Beelsebob> http://en.wikibooks.org/wiki/Haskell/Type_declarations too
17:45:13 <TSC> http://www.haskell.org/haskellwiki/Type
17:45:14 <lambdabot> Title: Type - HaskellWiki
17:45:49 <misterbeebee> is there a way to get the extra type-safety of newtype ("newtype T  = Tuple (Double,Double ); ") but still get all the tuple functions to work on T? Or would that require tuple to have been defined as a typeclass, which is not the Prelude reality?
17:45:59 <ddarius> Go Wouter!
17:46:11 <Beelsebob> misterbeebee: no, because the tuple functions expect something of type (a,b)
17:46:18 <Beelsebob> not something of type Tuple (a,b)
17:46:21 <LoganCapaldo> Hmm a pair type class could be cool
17:46:47 <LoganCapaldo> instance Pair (a, b) where fst (a,  _) = a ...
17:46:50 <misterbeebee> os I have to write stuff like   fstT (Tuple a)= fst a
17:46:50 <Beelsebob> although as LoganCapaldo points out -- it could be reimplemented to have a class of functions that operate on pair like things
17:47:16 <Beelsebob> misterbeebee: with the prelude as it is, yes
17:47:28 <misterbeebee> I guess I could use preprocessor to template haskell to generate all the required defs, plus a new typeclass.
17:47:37 <misterbeebee> (if this was so important to me)
17:48:03 <LoganCapaldo> newtype T a b = T { unT :: (a, b) } ; fst . unT $ foo
17:49:06 <misterbeebee> LoganCapaldo: ah... then I just have to litter my code with unT, just like we have fromIntegral all over the place
17:49:25 <LoganCapaldo> well I wasn't suggesing it was a great soln.
17:50:16 <_Zaph0d_> I'm trying to understand the 'mcons' function in 'sequence'. mcons p q = p >>= \x -> q >>= \y -> return (x:y)   What value is x getting if i do mcons Nothing (Just 1)   ?
17:50:22 <misterbeebee> it's fair. I can't sit on the fence "it's a tuple...unless I decide it isn't later. .... but I still want tuple functions to work" have cake and eat it too ... need a typeclass
17:50:44 <_Zaph0d_> I guess it's more of a trying to understand monads question.
17:51:07 <LoganCapaldo> _Zaph0d_: won't even get to binding a value to x
17:51:16 <LoganCapaldo> @src Maybe (>>=)
17:51:17 <lambdabot> (Just x) >>= k      = k x
17:51:17 <lambdabot> Nothing  >>= _      = Nothing
17:51:42 <LoganCapaldo> mcons Nothing x = Nothing
17:52:32 <LoganCapaldo> also mcons Nothing (Just 1) doesn't type check
17:52:37 <_Zaph0d_> So how does ( return(x:y) ) become Nothing ?
17:52:43 <LoganCapaldo> you want something like mcons Nothing (Just [1])
17:52:59 <LoganCapaldo> look up at the definition of >>= for maybe
17:53:01 <_Zaph0d_> oops yes ( Just [1] )
17:53:10 <_Zaph0d_> ok I will thanks
17:53:18 <LoganCapaldo> Nothing >>= anything = Nothing
17:53:21 <misterbeebee> the return doesn't get evaluated at all. that's part of the "_" that gets ignored
17:53:26 <LoganCapaldo> doesn't amtter what anything is
17:53:35 <LoganCapaldo> it won't even look at it
17:54:04 <LoganCapaldo> make sense?
17:54:15 <_Zaph0d_> *mind clicks* Now I got it TYVM
17:54:21 <LoganCapaldo> 9you don't even need laziness for that to work)
17:55:30 <_Zaph0d_> (OT) Funny how when a concept makes sense the beauty of the language comes through
17:55:57 <misterbeebee> can I run lambdabot on my local console (so I don't send my lambdabot chatter to the whole channel)? when I run the lambdabot program locally, every command results in   " fd:7: hClose: resource vanished (Broken pipe)"
17:57:10 <LoganCapaldo> lambdabot ill respond to messages
17:57:13 <LoganCapaldo> *will
17:57:35 <LoganCapaldo> /msg lambdabot > 2 + 2
17:57:50 <misterbeebee> oh, awesome. (IRC newb)
17:58:25 <misterbeebee> still weird to private-message to lambdabot across all of North America, but it works
18:00:35 <oerjan> _Zaph0d_: btw, mcons = liftM2 (:)
18:02:01 <oerjan> misterbeebee: although you _should_ be able to run lambdabot locally somehow
18:02:34 <LoganCapaldo> @type liftM2
18:02:36 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:03:01 * LoganCapaldo writes ListT
18:10:21 <misterbeebee> oerjan: oh, duh, it's supposed to be a ghci plugin, not standalone
18:10:50 <oerjan> ok
18:10:52 <shachaf> ?where goa
18:10:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
18:11:22 <misterbeebee> shachaf: yes, thanks I forgot abotu ghc on acid. thanks for the pointer
18:32:25 <hpaste>  LoganCapaldo pasted "ListT, comments, insults?" at http://hpaste.org/3074
18:34:21 <oerjan> 1) unListT could be the field name
18:37:16 * LoganCapaldo is mostly looking for comments of the "this is how you screwed up the semantics of ListT" variety
18:37:50 <LoganCapaldo> I know I could do things like map (a . b) xs instead of map a $ map b xs
18:37:54 <oerjan> well given that i haven't much read the original ListT...
18:38:08 <LoganCapaldo> I haven't read it all :)
18:38:32 <oerjan> although i recall reading that the most original one is buggy by being too strict
18:38:32 <LoganCapaldo> I'm trying to learn monad transformers by reverse engineering them
18:38:57 <oerjan> and doesn't satisfy the monad laws
18:39:02 <dolio> It doesn't look any more screwed up than ListT is anyway.
18:39:25 <LoganCapaldo> Did I pick a bad one?
18:39:31 <Pseudonym> LoganCapaldo: How about just deriving them?
18:39:37 <LoganCapaldo> ?
18:39:38 <hpaste>  ryani annotated "ListT, comments, insults?" with "(no title)" at http://hpaste.org/3074#a1
18:39:57 <dolio> 'ListT m' is only a monad if 'm' is a commutative monad.
18:40:14 <LoganCapaldo> ah
18:40:30 <LoganCapaldo> Pseudonym: what do you mean by deriving them?
18:40:50 <Pseudonym> Logan: Just a moment, annotating.
18:42:42 <oerjan> hpaste seems to think as is a keyword...
18:43:15 <LoganCapaldo> well it is
18:43:18 <dolio> It is, sometimes.
18:43:26 <oerjan> though not there
18:43:35 <dolio> import qualified Foo as Bar
18:43:43 <LoganCapaldo> but I'd be impressed if newtype ListT  = ListT (m [a]) deriving Monad worked
18:44:01 <LoganCapaldo> oh I misread what oerjan said
18:44:24 <oerjan> LoganCapaldo: i'm not sure you did
18:44:25 <hpaste>  Pseudonym annotated "ListT, comments, insults?" with "(no title)" at http://hpaste.org/3074#a2
18:44:35 <oerjan> i forgot about imports
18:45:16 <LoganCapaldo> woah
18:45:33 <LoganCapaldo> woah
18:45:39 <LoganCapaldo> Pseudonym you just blew my mind
18:45:53 <LoganCapaldo> I'ts gonna take me another 6 months to figure out how to do that
18:46:07 <hpaste>  Pseudonym annotated "ListT, comments, insults?" with "The easy cases" at http://hpaste.org/3074#a3
18:46:23 <oerjan> essentially he just defined the AST for ListT
18:46:42 <oerjan> pushing everything into runListT
18:46:47 <Pseudonym> Right.
18:46:58 <LoganCapaldo> I'm pretty sure I know what he did, its what he didn't do and the implication that it can done that is mind boggling
18:47:08 <LoganCapaldo> to me anyway
18:48:05 <dolio> There are a paper or two at least that show how to derive monads that way easily.
18:48:19 <oerjan> in some way what he defined isn't a monad - it cannot satisfy the monad laws unless you identify some terms
18:48:28 <dolio> And then use semantics-preserving transformations to optimize the implementation.
18:49:10 <dolio> Because building an AST and then interpreting it isn't necessarily the fastest implementation strategy.
18:50:15 <dolio> My brain says that searching for words like "free term algebra monad" would yield such papers, but it doesn't seem to work.
18:50:18 <hpaste>  Pseudonym annotated "ListT, comments, insults?" with "The bind cases" at http://hpaste.org/3074#a4
18:50:35 <dolio> On google, at least.
18:50:51 <Pseudonym> dolio: What you can do, however, is make the laws correct under observation.
18:50:58 <Pseudonym> Where "observation" means runListT.
18:51:08 <Pseudonym> As you can see, you just apply monad laws as they show up.
18:51:19 <dolio> You mean, 'oerjan:'?
18:51:24 <Pseudonym> Er, yes.
18:51:26 <Pseudonym> Sorry.
18:51:29 <dolio> :)
18:51:31 <oerjan> thought so
18:51:40 <LoganCapaldo> this is nuts :)
18:51:46 <Pseudonym> This, BTW, I think _is_ the fastest implementation strategy, in the sense, that you get an implementation fast.
18:51:55 <Pseudonym> The run-time isn't so fast.
18:52:12 <dolio> Ah, that's true. :)
18:52:19 <LoganCapaldo> Is this how deriving monad works?
18:52:23 <Pseudonym> Yup.
18:52:27 <Pseudonym> Uhm.
18:52:27 <LoganCapaldo> zomg
18:52:31 <Pseudonym> You mean deriving (Monad)?
18:52:35 <LoganCapaldo> yes
18:52:37 <Pseudonym> No.
18:52:39 <LoganCapaldo> oh
18:52:41 <Pseudonym> deriving(Monad) works with newtype.
18:52:54 <Pseudonym> If the underlying type has a Monad instance, then so does the newtype wrapper.
18:53:00 <LoganCapaldo> oh that's just the cunning newtype thing
18:53:20 <LoganCapaldo> Could you do this mechanically though?
18:53:24 <dolio> http://www.informatik.uni-bonn.de/~ralf/publications/ICFP00.ps.gz
18:53:28 <dolio> There's one.
18:53:31 <Pseudonym> dolio: That's the one.
18:55:06 <geocalc> is it in english dolio ?
18:55:13 <Pseudonym> It is.
18:55:26 <geocalc> ok
18:55:44 <sorear> Functional programming is new enough that essentially all the interesting papers are in English.
18:57:17 <platypus> sorear: Isn't that true for most of computer science?
18:57:33 <geocalc> ~
18:58:03 * SamB_XP wants to catch whoever it is that designs cellphone packages and make them open some
18:58:40 <LoganCapaldo> my phone came in a box
18:58:47 <LoganCapaldo> it had a lid that  slid off
18:58:58 <dolio> The plastic sort of package, that requires a blade to open?
18:58:58 <hpaste>  Pseudonym annotated "ListT, comments, insults?" with "The final cases" at http://hpaste.org/3074#a5
18:59:06 <Pseudonym> Warning: I've only proven this code correct, not tried to run it.
18:59:31 <LoganCapaldo> you really want to catch people who design those stupid plastic packaging
18:59:55 <Adamant> your monad was a hamster
18:59:57 <ramza3> anyone wanna stay up all night hacking.  I havent done an all nighter in a while.  sleep is overrated
19:00:34 <oerjan> ramza3: i understand the haskell hackaton is only a few days away
19:01:10 <misterbeebee> ramza3: dons just jused said hello to the room in #haskell-hac07
19:01:35 <tehgeekmeister> i'm trying to write a simple function to generate the sample space of k fair coin tosses, i'm certain this will be made much easier by the list monad but i'm not exactly sure how.  foldM doesn't seem to be exactly what i want.  how do i do this right?
19:01:36 <sysfault> ?
19:01:48 <sysfault> was that proper english
19:02:02 <misterbeebee> me?
19:02:14 <misterbeebee> correction: ramza3: dons just said hello to the room in #haskell-hac07
19:02:15 <oerjan> > replicateM 5 [True,False]
19:02:16 <dolio> tehgeekmeister: replicateM k flip ?
19:02:17 <lambdabot>  [[True,True,True,True,True],[True,True,True,True,False],[True,True,True,Fals...
19:02:33 <ramza3> misterbeebee, I used my lazy evaluation, I understood what you meant
19:02:53 <platypus> @src replicateM
19:02:54 <lambdabot> replicateM n x = sequence (replicate n x)
19:03:42 <tehgeekmeister> thanks, i knew i was reinventing the wheel.
19:03:53 <misterbeebee> tehgeekmeister: http://community.livejournal.com/evan_tech/220036.html
19:03:54 <lambdabot> Title: evan_tech -- powerset
19:04:38 <misterbeebee> oh, but then you lose ordering.. nvermind
19:04:47 <ac> how do I hoogle something from the command line or within ghci?
19:05:06 <ac> @hoogle replicateM
19:05:07 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
19:05:07 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
19:05:07 <misterbeebee> ?where goa
19:05:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
19:05:22 <misterbeebee> ac: install GOA
19:06:19 <LoganCapaldo> a) isn't goa a bit undermaintained and b) what's the advantage exactly of GOA over just having a local lambdabot?
19:06:35 <misterbeebee> I just installed both, and GOA works, lambdabot didn't :)
19:07:14 <LoganCapaldo> I was under the impression GOA depended on lambdabot
19:07:34 <tehgeekmeister> ?src sequence
19:07:34 <lambdabot> sequence ms = foldr k (return []) ms
19:07:35 <lambdabot>     where
19:07:35 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
19:08:05 <misterbeebee> GOA depends on the lambdabot resources, but my isntallation of the lambdabot top-level application doesn't work. I dunno why. I might have installed it wrong.
19:09:38 <LoganCapaldo> well I know nothing having installed neither
19:10:15 <misterbeebee> anyway, goa is slick, it gives you lambdabot, hoogle, djinn, etc, in ghci, right where they are most useful.
19:10:26 <oerjan> tehgeekmeister: that k is the same mcons = liftM2 (:) mentioned earlier today
19:10:41 <xelxebar> >readHex "FF"
19:10:51 <xelxebar> > readHex "FF"
19:10:59 <lambdabot>  [(255,"")]
19:11:03 <tehgeekmeister> oerjan: i'll look into that, thanks.
19:11:23 <oerjan> tehgeekmeister: it's not much more than what you just saw
19:11:27 <oerjan> @src liftM2
19:11:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:11:53 <LoganCapaldo> @type \a b -> liftM a `ap` b
19:11:55 <lambdabot> forall a1 r a. (a1 -> r) -> ((a -> a1) -> a) -> (a -> a1) -> r
19:12:08 <LoganCapaldo> n
19:12:33 <xelxebar> > readBaseFloat     :: (RealFrac a) => ReadS a
19:12:33 <LoganCapaldo> @\f a b -> liftM f `ap` a `ap` b
19:12:33 <xelxebar> readBaseFloat r   = [(fromRational ((m%1)*b^^(k-d)),t) | (b, q, readBase, isBaseDigit) <- readBaseFix r,
19:12:33 <xelxebar>                                                        (n,d,s) <- readFix q isBaseDigit,
19:12:33 <xelxebar>                                                        (k,t)   <- readExp s readBase,
19:12:33 <xelxebar>                                                        (m, p)  <- readBase n] ++
19:12:33 <xelxebar>                     [ (0/0, t) | ("NaN",t)      <- lex r] ++
19:12:33 <lambdabot>  fd:22: hClose: resource vanished (Broken pipe)
19:12:34 <lambdabot>   Not in scope: `readBaseFloat'
19:12:46 <dolio> @type \f a b -> f `liftM` a `ap` b
19:12:48 <lambdabot> forall a1 a b (m :: * -> *). (Monad m) => (a1 -> a -> b) -> m a1 -> m a -> m b
19:12:54 <LoganCapaldo> thanks
19:14:02 <tehgeekmeister> oerjan: okay, i get it now.  thanks.
19:22:07 <SamB_XP> dolio: the sort of package where you cut your finger trying to open it
19:22:54 <SamB_XP> LoganCapaldo: yeah, well, I meant the ones that designed the packaging that THIS phone came in...
19:23:26 <tehgeekmeister> ?src sequence_
19:23:26 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
19:26:24 <FMota> Okay, so I've decided to give up on trying to implement Sei.
19:26:35 <FMota> It's beyond my scope... and it's not a very interesting goal either.
19:26:38 <LoganCapaldo> Sei?
19:26:44 <FMota> Sei = My FPL
19:27:15 <geocalc> fpl ?
19:27:25 <FMota> FPL = Functional programming language
19:27:36 <oerjan> @remember sorear (after someone complains of ghc using much memory) Only 500M?  encode for lists is strict, I would have expected around
19:27:37 <lambdabot> Done.
19:27:49 <oerjan> what the heck
19:27:56 <oerjan> where did that newline come from
19:27:57 <FMota> yep, it got cut.
19:28:01 <LoganCapaldo> What Haskell not good enough for ya?
19:28:11 <FMota> Haskell is already implemented.
19:28:17 <FMota> :p
19:28:34 * sorear pines for a working @forget
19:28:36 <LoganCapaldo> I somehow don't see that as a downside ;)
19:28:45 <FMota> Okay, what I'm actually going to do, is implement a different programming language, called Boa.
19:28:52 <oerjan> @forget sorear Only.500
19:28:52 <lambdabot> No match.
19:28:56 <LoganCapaldo> @lethe
19:28:56 <lambdabot> Maybe you meant: leave let
19:29:16 <oerjan> sorear: forget has been added, doesn't it work?
19:29:17 <Cale> FMota: Is it a constraint programming language?
19:29:25 <LoganCapaldo> I'm working up the courage to do a Haskell interpreter
19:29:25 <FMota>  Nope.
19:29:35 <sorear> oerjan: you need the full text (no regexes, for safety) but it causes massive state corruption and makes @quote unusable until a bot restart
19:29:36 <FMota> It's pretty much constrants-free
19:29:45 <LoganCapaldo> and by Haskell I mean small subset thereof
19:29:46 <FMota> I suspect it doesn't interest haskellers too much,
19:30:08 <FMota> although it is functional (haven't decided on purity, though)
19:30:09 <ac> FMota: have you given up ae?
19:30:14 <dolio> Is it yet another take on Lisp? We need some more of those. :)
19:30:25 <FMota> ac: ae was renamed to Sei
19:30:28 <oerjan> sorear: eek
19:30:31 <FMota> so, yeah
19:30:58 <ac> FMota: I kind of figured... your blog was unnaturally quiet
19:31:19 <FMota> You kept track? Awww, I'm flattered...
19:31:27 <FMota> (Don't answer that question XD)
19:31:31 <ac> FMota: I'm a sucker for new languages
19:31:56 <FMota> Well, I'll probably make a blog just for Boa. :/ I know what I'm like.
19:32:29 <qubit> hi room
19:32:39 <ac> FMota: what's exciting about Boa?
19:32:41 <sorear> hello?
19:32:48 <FMota> hi qubit
19:32:57 <geocalc> FMota-> what is the problem ?
19:32:57 <oerjan> @remember sorear (after someone complains of ghc using much memory) Only 500M?  encode for lists is strict, I would have expected around 80GB usage...
19:32:57 <lambdabot> Done.
19:33:00 <FMota> ac: It's fun. :)
19:33:17 <FMota> geocalc: ?
19:33:22 <FMota> what do you mean?
19:33:32 <oerjan> FMota: Cale is right, a language named Boa simply has to be constraint-based
19:33:40 <geocalc> with boa
19:33:43 <FMota> lol
19:33:48 <FMota> good point
19:33:49 <LoganCapaldo> boa constrainter
19:34:41 <ac> FMota: Yeah, it would be a total waste of a name if Boa wasn't constraint-based
19:34:47 <qubit> colud someone help me, I'm trying to write a function for cosine using the taylor's polynomial theory. I have this but there is a type problem..: mycos x 0 = 1,
19:34:47 <qubit> mycos x n = (nthT x n) + (mycos x (n-1))
19:34:47 <qubit> ,	where nthT x n = ((((-1)^n)*(x)^(2*n))/(2*n))
19:34:47 <qubit>  it needs to be recursive, I just cant figure how to do it
19:35:08 <FMota> well
19:35:12 <oerjan> @quote
19:35:12 <lambdabot> Gwern says: actually, i define bottom to equal 1 in all my programs, so I can guarantee they will never crash
19:35:19 <FMota> now you're all making me look up constraint programming. :)
19:35:26 <FMota> maybe I can make something of it
19:36:08 <ac> FMota: check out Alice or Oz
19:36:17 <FMota> ok
19:36:25 <FMota> Thank you. :)
19:36:47 <oerjan> qubit: you need to use fromIntegral on the n that you divide by
19:37:08 <ac> FMota: AFAIK, Alice is a dialect of ML that adds constraint and logic programming and built in distributed computing. It was inspired by Oz which has the same capabilities but is far from ML in that it's dynamically typed
19:37:14 <qubit> h ok, I had a felling that was an issue
19:37:34 <oerjan> because / doesn't take Integrals
19:37:37 <ac> FMota: Alice and Oz used to run on the same VM, but now Alice has its very own
19:37:39 <qubit> thanks
19:38:22 <FMota> ok. So you can have dynamically typed constraint-based programming.
19:38:46 <geocalc> FMota-> you can look at maude too
19:39:11 <ac> ah yes, maude is an interesting language based on a rewrite logic
19:40:24 <ac> FMota: Oz is the language of choice of the programming book Concepts, Techniques, and Models of Computer Programs
19:41:12 <FMota> ok, thanks :)
19:42:22 <ac> Which reminds me of something I've been wondering: can you pipe arbitrary values through channels to separate OS threads in Haskell like you can in Alice, Oz, or Erlang?
19:43:03 <SamB_XP> no
19:43:16 <SamB_XP> or, wait, threads?
19:43:17 <SamB_XP> yes
19:43:29 <ac> But not accross machines yet
19:43:41 <SamB_XP> not sure
19:44:02 <SamB_XP> nyhc would be the place to ask about that
19:44:09 <SamB_XP> or people
19:44:11 <syntaxfree> so, how would I go about emulating a DEC Alpha on a PPC Mac?
19:44:29 <ac> nyhc?
19:44:43 <SamB_XP> nhc and yhc are semi-merged
19:44:49 <oerjan> @docs Control.Concurrent.Chan
19:44:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
19:47:11 <xelxebar> why would haskell complain "couldn't match expected type 'Integer' against inferred type 'Int' ", then stop complaining when the value inquestion (say m) is processed like follows: read (show m)
19:47:37 <ddarius> :t read . show
19:47:40 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
19:47:53 <ddarius> read . show is a generic conversion routine
19:48:06 <P_D> Using read and show gives a specific, arbitrary and lossy way to map between the types
19:48:46 <xelxebar> thanks, though in this particular instance that seems like a bit of a hack
19:48:53 <oerjan> > (read . show) (1::Int) :: Integer
19:48:55 <lambdabot>  1
19:49:00 <oerjan> > (read . show) (1::Int) :: Double
19:49:02 <P_D> no kidding.
19:49:02 <lambdabot>  1.0
19:49:20 <oerjan> > (read . show) (1::Double) :: Int
19:49:22 <lambdabot>  Exception: Prelude.read: no parse
19:49:47 <P_D> > (read . show) (1.::Double) :: Int
19:49:48 <lambdabot>   Not in scope: data constructor `Double'
19:49:54 <P_D> > (read . show) (1.0::Double) :: Int
19:49:57 <lambdabot>  Exception: Prelude.read: no parse
19:49:57 <oerjan> xelxebar: fromIntegral may be what you want
19:50:52 <tehgeekmeister> is it safe to think of sequence as sequence_ using >>= instead of >>?
19:51:37 <oerjan> tehgeekmeister: sequence doesn't really use >>= into the next element
19:51:55 <tehgeekmeister> oh, no, it doesn't really.  that's right.
19:52:01 <oerjan> only for collecting
19:52:09 <tehgeekmeister> yep.
19:52:47 <ddarius> tehgeekmeister: It's safe to think of sequence as sequence_ using (liftM2 (:)) instead of (>>)
19:52:55 <xelxebar> hmm, though in this case i'm doing something like foo r = [(m%1,t) | (moo,t) <- bar r, (m, s) <- moo]
19:53:20 <xelxebar> the bar function returns some given function depending on r
19:54:02 <ac> How smart is the hoogle type signature search? Are variable names arbitrary (Does a -> a match b -> b) and can everything but the right most side of -> be reorganized?
19:54:06 <xelxebar> however, if i hard code moo to one specific function, the error disappears"
19:54:49 <ddarius> ac: It definitely can handle alpha conversion and it does seem like it will effectively rearrange arguments in some cases.
19:55:09 <ddarius> ac: There's a blog post or webpage on Neil's site that describes what all the various versions of Hoogle used.
19:55:22 <xelxebar> the bar function would be something like bar 1 = [(func1, 1)]; bar 2 = [(func2, 2)]
19:55:28 <ac> hm. This function has to be somewhere...
19:56:24 <oerjan> xelxebar: hard to say why some are Int and some Integer without seeing the exact code.  Could you paste?
19:56:27 <oerjan> !paste
19:56:28 <hpaste> Haskell paste bin: http://hpaste.org/
19:56:45 <xelxebar> sure
19:57:08 <xelxebar> how do we paste?
19:57:34 <oerjan> ^^
19:58:05 <geocalc> clik
19:58:18 <oerjan> ac: might be something that is a simple combination of two functions?
19:58:49 <ddarius> Or, as is often the case, a specialization of a more general function.
19:58:59 <oerjan> also, hoogle is severely broken with monads and type classes
19:59:00 <xelxebar> the problem is that it's about 45 lines of code, and pasting that directly onto the chat board would be disatrous
19:59:16 <oerjan> xelxebar: did you not see the link?
19:59:20 <oerjan> !paste
19:59:20 <hpaste> Haskell paste bin: http://hpaste.org/
19:59:33 <oerjan> xelxebar: yeah, we all saw that :D
19:59:33 <geocalc> clik
19:59:45 <xelxebar> oh, okay, thanks
20:00:09 <oerjan> ac: what type did you search for?
20:00:59 <ac> oerjan: well it sort of a simple combination of two functions... I'm looking for n compose which can be written as "take n (iterate f x)" but that generates an intermediate list
20:01:36 <ac> I was searching for Int -> (a -> a) -> a
20:01:40 <hpaste>  xelxebar pasted "Integer/Int error on m" at http://hpaste.org/3075
20:01:55 <oerjan> you mean iterate f x !! n ?
20:02:18 <oerjan> ac: actually that will _not_ generate an intermediate list
20:02:21 <ac> :type (!!)
20:02:22 <oerjan> in ghc
20:02:41 <oerjan> i am pretty sure it is optimized away
20:03:02 <ac> oerjan: I figured that was probably the case actually. What's the meaning of !!?
20:03:04 <geocalc> !!
20:03:19 <oerjan> :t (!!)
20:03:22 <lambdabot> forall a. [a] -> Int -> a
20:03:39 <P_D> x !! y = drop (y-1) $ take y x
20:03:56 <TSC> I don't think so
20:04:04 <Olathe> @src (!!)
20:04:04 <lambdabot> xs     !! n | n < 0 = undefined
20:04:05 <lambdabot> []     !! _         = undefined
20:04:05 <lambdabot> (x:_)  !! 0         = x
20:04:05 <lambdabot> (_:xs) !! n         = xs !! (n-1)
20:04:16 <P_D> could be off by one.
20:04:20 <xelxebar> oops, on that hpaste, in (show m%1)  the show isn't supposed to be there
20:04:27 <TSC> The return type is wrong; drop returns a list
20:04:42 <geocalc> > x !! y
20:04:43 <lambdabot>   Not in scope: `y'
20:04:43 <P_D> Ok, prop head in front.
20:04:53 <P_D> or some version of drop which does the same
20:07:38 <hpaste>  (anonymous) annotated "Integer/Int error on m" with "(no title)" at http://hpaste.org/3075#a1
20:08:18 <ac> replicate n x = repeat x !! n
20:08:18 <ac> ?
20:08:38 <xelxebar> I just removed the extraneous show
20:08:45 <misterbeebee> replicate n x = take n (repeat x)
20:08:55 <ac> nevermind. that only returns one value
20:09:25 <oerjan> adapted from readFloat i take
20:09:40 <Olathe> @src replicate
20:09:40 <lambdabot> replicate n x = take n (repeat x)
20:09:50 <misterbeebee> I am lambdabot! :)
20:09:57 <ac> hah
20:10:05 <Olathe> @misterbeebeesnack
20:10:06 <lambdabot> Unknown command, try @list
20:10:21 <misterbeebee> Olathe: Chex Mix :)
20:10:28 <Olathe> :)
20:12:03 <ac> So I guess you generate a list of random numbers with something like "replicate 10 (getStdRandom next)" but apparently you can't Show an IO Int. Also what if you want a list between 0 and n? I'd want "mod (getStdRandom next) 10" but you can't mod IO Int's either...
20:12:48 <ac> How do I incapsulate the IOness of random?
20:13:22 <TSC> random's not inherently IO
20:13:39 <ac> TSC: how could it not be? It's not pure
20:13:43 <TSC> You only need IO if you want to use the system to seed the generator
20:13:52 <P_D> :t randoms
20:13:54 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
20:14:01 <P_D> It gets an infinite list of the random numbers
20:14:04 <P_D> you split that up as you wish.
20:14:11 <TSC> It's only a pseudo-random number generator, so it's pure
20:14:35 <ac> TSC: so what if I wanted a truely random list, like if I was using it for cryptography?
20:15:02 <hpaste>  FMota pasted "Boa -- this is what I have. Questions inside." at http://hpaste.org/3076
20:15:02 <ac> Is there a way to save up a giant seed, and than feed that out one number at a time?
20:15:12 <P_D> Write IO code to talk to your noise source
20:15:28 <FMota> Actually, there aren't really many / any questions.
20:15:32 <TSC> Yes, you'd need some source of random data, and probably use IO to talk to it
20:15:35 <ac> I see. So you have getAllNoise, and that's evaluated lazily
20:15:54 <ddarius> :t randomRs
20:15:56 <P_D> that's how the built in RNG works
20:15:56 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
20:16:34 <ac> this is all a little mind altering
20:16:42 * ac is on his second day of haskell
20:17:03 <oerjan> ac: for pseudorandom numbers you may want to use randomIO or randomRIO
20:17:09 <FMota> so, essentially, the constraint matching in boa would look like this:
20:17:09 <oerjan> :t randomRIO
20:17:11 <lambdabot> forall a. (Random a) => (a, a) -> IO a
20:17:32 <FMota> ((vec2 <> <>).mag = 5).has? (3, 4)
20:17:35 <oerjan> if you don't actually want the pureness so much
20:17:40 <FMota> would return true
20:17:49 <FMota> ((vec2 <> <>).mag = 5).search
20:17:59 <FMota> might return (5, 0)
20:18:14 <xelxebar> any ideas on the Integer/Int issue?
20:18:32 <ddarius> Blech, are the <>'s some kind of crappy placeholder notation
20:18:59 <FMota> ddarius: they work better than lambddas.
20:19:02 <FMota> *lambdas
20:19:16 * ddarius disagrees
20:19:23 <FMota> lambda expretions, I should say.
20:19:31 <FMota> *expressions
20:19:32 <FMota> wow
20:19:51 <FMota> never misspelled expressions like that before.
20:20:22 <tehgeekmeister> ?src ($)
20:20:22 <lambdabot> f $ x = f x
20:20:25 <tehgeekmeister> ?src (.)
20:20:26 <lambdabot> (.) f g x = f (g x)
20:20:28 <ddarius> At the very least you should at least give them names so vec2 A A can be told from vec2 A B
20:20:28 <xelxebar> replacing m with any integer seems to also circumvent the error
20:20:56 <P_D> (m::Int) ?
20:20:57 <dons> ?users
20:20:57 <lambdabot> Maximum users seen in #haskell: 420, currently: 349 (83.1%), active: 16 (4.6%)
20:21:07 <FMota> ddarius: but it can
20:21:34 <FMota> when you have to, use a lambda expression.
20:21:55 <FMota> ((\ x -> vec x x) <> = 9).search
20:22:23 <FMota> er
20:22:27 <FMota> that makes no sense
20:22:32 <ddarius> Whew!
20:23:07 <tehgeekmeister> where does one find fixity of operators?
20:23:24 <oerjan> ah yes, fromRational would demand Integer
20:23:24 <shachaf> tehgeekmeister: :info in ghci.
20:23:42 <FMota> ((\ x -> (vec x x).mag) <> = 18.sqrt).search
20:23:48 <FMota> will probably return 3
20:24:25 <ddarius> "will probably"?
20:24:28 <SamB_XP> oooh
20:24:34 <FMota> well, it might return -3, of course
20:24:38 <SamB_XP> my cellphone has a lantern feature built in
20:24:45 <SamB_XP> my palm pilot didn't have that
20:24:46 <FMota> lol SamB
20:25:03 <SamB_XP> I had to start an app that displayed all (or mostly) white
20:25:20 <ac> wow. Haskell is the first language I've come accross that does pseudo random numbers the way I would expect
20:25:53 <ac> or perhaps the way I secretly wanted them
20:25:55 <SamB_XP> ac: I guess you've been searching for Haskell for a while then?
20:26:00 <ac> yes.
20:26:06 <FMota> x.sqrt = (<>.sq = x).search
20:26:21 <misterbeebee> ac: I'm no expert, but here's an example:
20:26:23 <misterbeebee> >  sequence $ map (liftM even) $  replicate 10 (randomIO::(IO Int))
20:26:32 <lambdabot>  <IO [Bool]>
20:26:39 <misterbeebee> replicate... generates your random number stream
20:26:48 <misterbeebee> "even" is your function that consumes random data
20:26:59 <misterbeebee> sequence cleans up the IO and makes the result outputtablw
20:27:06 <misterbeebee> now one of the experts can clean it up
20:28:20 <ddarius> misterbeebee: That's a bizarre way to write that.
20:28:53 <xelxebar> are there any suggestions for the hpast post i last made?
20:28:58 <misterbeebee> that's why I wrote it... so someone can show a better way.
20:29:45 <ddarius> Directly "simplifying" that, I would write (at least) liftM (map even) $ replicateM 10 randomIO
20:30:06 <oerjan> ah!
20:30:53 <tehgeekmeister_> practically speaking, the only difference between ($) and (.) is precedence, right?
20:31:00 <ddarius> tehgeekmeister_: Wrong.
20:31:04 <oerjan> xelxebar: it all boils down to your use of "length"
20:31:13 <ddarius> tehgeekmeister_: They're totally different functions
20:31:15 <ddarius> :t ($)
20:31:17 <ddarius> :t (.)
20:31:18 <lambdabot> forall a b. (a -> b) -> a -> b
20:31:19 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:31:43 <ac> misterbeebee: aren't you wasting entropy converting random integers to random bools?
20:31:45 <oerjan> it causes d to be Int, which trickles down to m
20:31:46 <ac> ;)
20:32:42 <misterbeebee> Yeah.... "even" was just a placeholder, as was "IO Int". Choose the random type you need, and the function you care about that consumes them
20:32:43 <xelxebar> length?!
20:32:54 <oerjan> :t length
20:32:56 <lambdabot> forall a. [a] -> Int
20:33:17 <ac> misterbeebee: I see. I didn't recognize that "::(IO Int)" was sellecting the type of generator
20:33:43 <misterbeebee> yeah, otherwise ghci compained at me that I needed to give a type
20:34:02 <ac> if you just type randomIO in ghci, it somehow infers integer
20:34:03 <misterbeebee> (well, it did an in earlier iteration of my 1-liner)
20:34:11 <oerjan> the strange thing is that it was in the original readFloat from the report, hm
20:34:15 <ddarius> ac: That is defaulting.
20:34:23 <xelxebar> yeah
20:34:35 <xelxebar> I actuall stole that code, trying to generalize it
20:34:42 <FMota> ddarius: you'd prefer this syntax, right?:   x.sqrt = (\y -> x = y.sq).search.abs
20:34:52 <misterbeebee> > randomIO
20:34:53 <lambdabot>  Add a type signature
20:35:03 <misterbeebee> randomIO (::Int)
20:35:07 <DJ-DrIP[AR]> bbl
20:35:10 <FMota> Good news is, they can both mean the same thing.
20:35:11 <misterbeebee> > randomIO (::Int)
20:35:12 <lambdabot>  Parse error
20:35:21 <misterbeebee> > (randomIO)::Int
20:35:22 <lambdabot>  Couldn't match expected type `Int' against inferred type `IO a'
20:35:27 <ddarius> FMota: But one is ambiguous in many cases and the other isn't.
20:35:30 <misterbeebee> darn bot
20:35:31 <FMota> (mostly, anyway)
20:35:46 <misterbeebee> randomIO::(IO Int)
20:35:51 <misterbeebee> > random::(IO Int)
20:35:52 <lambdabot>  Couldn't match expected type `IO Int'
20:35:55 <misterbeebee> I give up.
20:36:00 <misterbeebee> > randomIO::(IO Int)
20:36:04 <FMota> ddarius: unless you consider that <> can only be used when creating constraint matches, and so it must pair up with the =
20:36:05 <lambdabot>  <IO Int>
20:36:44 <misterbeebee> ac: anyway, you get the drift, even if I can't write it in irc properly
20:36:44 <oerjan> xelxebar: let me look a little further. the Int infects k through k-d
20:37:33 <hpaste>  (anonymous) annotated "Integer/Int error on m" with "(no title)" at http://hpaste.org/3075#a2
20:38:56 <oerjan> ah, and k infects readBase, which infects m
20:39:32 <ddarius> FMota: Can you nest constraints in any way?
20:39:59 <ddarius> FMota: The two things that come up most with such notations are: scoping and aliasing.
20:41:38 <ac> Is there a way to provide your own entropy source to StdGen or would you have to make your own instance of RandomGen?
20:42:32 <oerjan> in the original version readDec was polymorphic so it could return Int and Integer in different places. Curious.
20:42:36 <ddarius> ac: Are you talking about making your own seed?  Otherwise there is no "entropy source".
20:42:58 <oerjan> but in the new one readBase is passed around so it has to have just one type.
20:43:14 <xelxebar> oerjan: the thing that seemed odd to me is that if you replace 'readBase n' with 'readBin n' or even 'readHex n" then that clears the error message, despite the fact that readBase should be getting bound to readBin or readHex etc from readBaseFix
20:43:38 <xelxebar> oh
20:43:38 <ddarius> @src RandomGen
20:43:39 <lambdabot> class RandomGen g where
20:43:39 <lambdabot>    next     :: g -> (Int, g)
20:43:39 <lambdabot>    split    :: g -> (g, g)
20:43:39 <lambdabot>    genRange :: g -> (Int,Int)
20:44:03 <oerjan> xelxebar: indeed, but that it because readBin etc. can have different types in different parts of the code.
20:44:46 <oerjan> but readBase is returned from readBaseFix and must from there on be fixed
20:45:14 <oerjan> any way...
20:46:17 <ac> I guess what I'm imagining is a new instance of RandomGen that doles out a set number of pseudo random numbers, and then picks a new seed from a given source of entropy, and then doles out a few more. This would give you potentially very random but repeatable series
20:46:18 <Cale> http://cale.yi.org/autoshare/Screenshot-21.png -- found a better solution to the puzzle just now :)
20:46:40 <Cale> (with max 27)
20:46:45 <BoudewijnE> hi
20:46:52 <xelxebar> which leaves me just as clueless as before.  I had played around with readBaseFix, having thought that was the issue, but to no avail
20:46:57 <misterbeebee> Cale: Wow!
20:46:57 <hpaste>  oerjan annotated "Integer/Int error on m" with "fix" at http://hpaste.org/3075#a3
20:48:10 <oerjan> this cuts it off at the source, replacing length with genericLength which can return Integer
20:48:18 <BoudewijnE> if I have a datatype called (for instance) PosX, and I want to declare it in ghci using a value of 5 (integer) and calling it abc , how to do so?
20:48:31 <ac> this isn't entirely academic btw
20:48:49 <oerjan> since the error trickles down through several variables, there are several other places where you could have inserted fromIntegral instead
20:49:26 <Pseudonym> http://www.bitsavers.org/pdf/mit/cadr/LISPM_WindowSystem_Aug83.pdf
20:49:28 <lambdabot> http://tinyurl.com/29krep
20:49:36 <Pseudonym> It's an interesting read.
20:49:45 <xelxebar> thank you very much oerjan
20:50:15 <oerjan> you're welcome :)
20:51:05 <xelxebar> where is genericLength defined?
20:51:17 <Pseudonym> Data.List
20:51:34 <oerjan> BoudewijnE: let abc = PosX 5 or something like that
20:52:27 <BoudewijnE> thanks
20:52:49 <BoudewijnE> now its not in scope, but that is another problem
20:52:55 <Pseudonym> @let refineByDoubling s = s / sqrt (2 + sqrt (4 - s*s))
20:53:01 <lambdabot> Defined.
20:53:03 <Pseudonym> iterate refineByDoubling (sqrt 2)
20:53:08 <Pseudonym> > iterate refineByDoubling (sqrt 2)
20:53:10 <lambdabot>  [1.4142135623730951,0.7653668647301796,0.39018064403225655,0.196034280659121...
20:53:36 <Cale> Now it's *really* looking minimal. The 2-26-13 chain is equivalent to the 2-22-11 I'm already using. I can't really put the 15 anywhere else, because it's only connected to the 1,3, and 5, and putting it next to the 3 would cut off the 21 which is of degree only 2 (so it can't go elsewhere). Because the 15 can't move, the 25 can't fit in next to the 1.
20:53:59 <oerjan> BoudewijnE: if PosX is not the data constructor name, replace it by whatever is
20:54:16 <BoudewijnE> I know, but its more difficult
20:54:16 <Cale> (and the other high primes are of course useless)
20:54:24 <BoudewijnE> data Point = Point PosX PosY
20:54:24 <BoudewijnE> type PosX = Int
20:54:24 <BoudewijnE> type PosY = Int
20:54:36 <BoudewijnE> I got this, and load the file in GHCi
20:54:41 <BoudewijnE> sorry for huge paste btw
20:54:58 <Cale> er, hmm...
20:55:29 <oerjan> BoudewijnE: oh.  in that case there is no difference between PosX and Int
20:55:31 <Pseudonym> > [ s * 2^n * 0.5 | (s,n) <- zip (iterate refineByDoubling (sqrt 2)) [2..] ]
20:55:33 <lambdabot>  [2.8284271247461903,3.0614674589207183,3.1214451522580524,3.1365484905459393...
20:55:38 <Pseudonym> > [ s * 2^n * 0.5 | (s,n) <- zip (iterate refineByDoubling (sqrt 2)) [2..] ] !! 20
20:55:39 <lambdabot>  3.1415926535895
20:55:40 <oerjan> so just use 5 directly
20:55:47 <BoudewijnE> ok
20:56:00 <BoudewijnE> but that cant be done explicitely?
20:56:50 <oerjan> well, let abc = 5
20:56:59 <Cale> well, actually the 15 can go next to the 3 on the other side, but that doesn't help either, because it moves the 5 and 25 away from the 1...
20:57:43 <ac> @src repeat
20:57:43 <lambdabot> repeat x = xs where xs = x : xs
20:59:41 <ac> why can't that be: "repeat x = x : repeat x"?
21:00:27 <dolio> It can, but the former gets compiled more efficently, I suspect.
21:00:39 <oerjan> ac: the former makes xs literally contain a cyclic list
21:01:06 <oerjan> but the latter may not necessarily
21:01:21 <ac> huh. I won't think about that too much
21:02:10 <oerjan> basically, variable names get shared in memory, but function applications that happen to have the same arguments usually don't.
21:02:11 <dolio> If you think about pointers...
21:02:46 <ac> I think I have a very fuzzy grasp
21:03:04 <dolio> The first list is a head and a pointer to itself.
21:03:05 <ac> which is good enough for me (for now, while I'm focusing on semantics)
21:03:06 <oerjan> technically this is an implementation matter - there is nothing in the standard that says it has to be that way
21:03:19 <oerjan> i.e. the semantics are identical
21:03:21 <dolio> The second is a head and a pointer to code that generates some other infinite list of xs.
21:03:59 <ac> so for every access to the pointer, another call needs to be made
21:04:07 <ac> (in the second case, at least potentially)
21:04:14 <dolio> Yeah.
21:04:18 <oerjan> not to _the_ pointer
21:04:25 <oerjan> but to the next pointer in the list
21:04:29 <ac> right
21:04:38 <oerjan> because the second does not guarantee they are the same
21:04:48 <ac> It's conceivable that that particular aspect will be optimized, and the source will be simplified for repeat, right?
21:05:01 <oerjan> yes
21:05:36 <oerjan> although ghc is somewhat careful - there may be cases where the programmer wants one behavior rather than the other for space reasons
21:05:52 <oerjan> and it can go both ways, depending on the program
21:06:05 <Pseudonym> @let zenoSequence xs p = zipWith (\rh rh2 -> ((2^p * rh2) - rh) / (2^p-1)) xs (tail xs)
21:06:17 <lambdabot> Defined.
21:07:42 <Pseudonym> @let zenoTableau xs p q = let sequences xs order = xs : sequences (zenoSequence xs order) (order+q) in sequences xs p
21:07:47 <lambdabot> Defined.
21:09:03 <Pseudonym> @let richardsonSequence xs p q = map head (zenoTableau xs p q)
21:09:05 <ddarius> No good will come of this.
21:09:09 <lambdabot> Defined.
21:09:26 <Pseudonym> > richardsonSequence [ s * 2^n * 0.5 | (s,n) <- zip (iterate refineByDoubling (sqrt 2)) [2..] ]
21:09:28 <lambdabot>  <Integer -> Integer -> [Double]>
21:09:32 <Pseudonym> > richardsonSequence [ s * 2^n * 0.5 | (s,n) <- zip (iterate refineByDoubling (sqrt 2)) [2..] ] 2 2
21:09:33 <lambdabot>  [2.8284271247461903,3.1391475703122276,3.1415903931299374,3.141592653286045,...
21:09:36 <Pseudonym> Woo!
21:09:38 <Pseudonym> Quick pi.
21:09:44 <Pseudonym> Sorry, no good will come of what?
21:10:32 <dolio> > richardsonSequence [ s * 2^n * 0.5 | (s,n) <- zip (iterate refineByDoubling (sqrt 2)) [2..] ] 2 2 !! 8
21:10:33 <lambdabot>  3.1415926535897927
21:10:40 <dolio> > pi
21:10:41 <lambdabot>  3.141592653589793
21:10:46 <P_D> that's a darn fast series
21:10:58 <Pseudonym> Thanks to lazy evaluation.
21:11:23 <Pseudonym> It's the Archimedian approximation, accellerated with a Richardson extrapolation.
21:11:35 <Pseudonym> Which just goes to show, simple approximations can still work.
21:11:41 <P_D> richardson = rational?
21:12:14 <Pseudonym> http://en.wikipedia.org/wiki/Richardson_extrapolation
21:12:15 <lambdabot> Title: Richardson extrapolation - Wikipedia, the free encyclopedia
21:12:59 <ac> lambdabot has got to be the most useful bot I've come accross
21:13:26 <Pseudonym> @let derivative f x h = f(x+h) - f(x-h) / (2*h) : derivative f x (h * 0.5)
21:13:33 <lambdabot> Defined.
21:13:42 <P_D> I was thinking of romberg integration, but I guess I confused it with bulirsch-stoer
21:13:45 <Pseudonym> > derivative (^2) 1.0 0.001
21:13:47 <lambdabot>  [-497.998499,-997.9992497500002,-1997.9996249375001,-3997.999812484374,-7997...
21:14:00 <Pseudonym> @let derivative f x h = (f(x+h) - f(x-h)) / (2*h) : derivative f x (h * 0.5)
21:14:00 <lambdabot> <local>:22:0:     Warning: Pattern match(es) are overlapped              In t...
21:14:04 <Pseudonym> Grrrr.
21:14:09 <dolio> @undefine
21:14:11 <lambdabot> Undefined.
21:14:17 <Pseudonym> Did you just undefine everything?
21:14:21 <dolio> > derivative (^2) 1.0 0.001
21:14:21 <lambdabot>   Not in scope: `derivative'
21:14:30 <dolio> > richardsonSequence [ s * 2^n * 0.5 | (s,n) <- zip (iterate refineByDoubling (sqrt 2)) [2..] ] 2 2
21:14:31 <lambdabot>   Not in scope: `refineByDoubling'
21:14:33 <P_D> I seem to recall seeing a nice example of richardson extrapolation for derivatives in scheme somewhere
21:14:35 <dolio> Whoops.
21:14:37 <dolio> Carp.
21:14:47 <Pseudonym> @let refineByDoubling s = s / sqrt (2 + sqrt (4 - s*s))
21:14:49 <lambdabot> Defined.
21:15:01 <Pseudonym> @let zenoSequence xs p = zipWith (\rh rh2 -> ((2^p * rh2) - rh) / (2^p-1)) xs (tail xs)
21:15:02 <lambdabot> <local>:2:0:     Warning: Pattern match(es) are overlapped              In th...
21:15:19 <Pseudonym> @let richardsonSequence xs p q = map head (zenoTableau xs p q)
21:15:20 <lambdabot> <local>:3:38: Not in scope: `zenoTableau'
21:15:29 <oerjan> o_O
21:15:41 <Pseudonym> @let zenoTableau xs p q = let sequences xs order = xs : sequences (zenoSequence xs order) (order+q) in sequences xs p
21:15:43 <lambdabot> Defined.
21:16:05 <Pseudonym> @let richardsonSequence xs p q = map head (zenoTableau xs p q)
21:16:07 <lambdabot> Defined.
21:16:16 <Pseudonym> @let derivative f x h = (f(x+h) - f(x-h)) / (2*h) : derivative f x (h * 0.5)
21:16:18 <vincenz> > zenoTableau [1..] 4 5
21:16:20 <lambdabot> Defined.
21:16:21 <lambdabot>  [[1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
21:16:24 <vincenz> ?
21:16:26 <Pseudonym> > derivative (^2) 1.0 0.001
21:16:27 <lambdabot>  [1.9999999999998352,1.9999999999997797,2.000000000000446,1.9999999999997797,...
21:17:12 <P_D> symmetric derivative is perfect to second order
21:17:18 <P_D> not going to work =)
21:17:28 <P_D> > derivative (^3) 1.0 0.001
21:17:28 <Pseudonym> Aha.
21:17:29 <lambdabot>  [3.0000009999997523,3.0000002499998013,3.000000062500563,3.0000000156240603,...
21:17:37 <Pseudonym> Good point.
21:17:37 <P_D> > derivative (^3) 1.0 0.1
21:17:38 <lambdabot>  [3.0100000000000016,3.002500000000002,3.000624999999999,3.00015624999999,3.0...
21:17:41 <vincenz> what's zeno?
21:17:44 <vincenz> nd richardson
21:18:00 <Pseudonym> Zeno is the guy who proved that the hare can't beat the tortoise.
21:18:06 <Pseudonym> By halving distances.
21:18:09 <ac> what does it mean to say "foo is not strict"?
21:18:16 <vincenz> Pseudonym: I mean what does it calculate here
21:18:22 <vincenz> > zenoTableau [1,2,3] 4 5
21:18:23 <lambdabot>  [[1.0,2.0,3.0],[2.066666666666667,3.066666666666667],[3.0686236138290934],[]...
21:18:26 <Pseudonym> > richardsonSequence (derivative (^3) 1.0 0.1) 2 2
21:18:27 <lambdabot>  [3.0100000000000016,3.000000000000002,2.999999999999998,2.9999999999999862,3...
21:18:34 <P_D> Sexy
21:18:41 <Pseudonym> Cool.
21:18:49 <P_D> down to double precision in one sweep
21:18:54 <Pseudonym> That's good enough for Newton-Raphson, I suspect.
21:19:04 <oerjan> ac: foo undefined is not undefined
21:19:20 <Pseudonym> > richardsonSequence (derivative sqrt 0.5 0.1) 2 2
21:19:21 <lambdabot>  [0.7107056860390376,0.7070908441153795,0.7071068048102919,0.7071067811765142...
21:19:32 <ac> couldn't there be a non-strict type class?
21:19:43 <Pseudonym> > richardsonSequence (derivative sqrt 1.0 0.1) 2 2
21:19:44 <lambdabot>  [0.5006277505981893,0.49999931133478487,0.5000000002540212,0.499999999999970...
21:19:49 <Pseudonym> Damn, nice.
21:19:51 <Pseudonym> I like this.
21:20:01 <P_D> did you define a raphson sqrt up there somewhere?
21:20:08 <Pseudonym> Nope.
21:22:18 <P_D> > iterate (\x -> x - (x^2 - 2) / (2 x)) 1.0
21:22:19 <lambdabot>   add an instance declaration for (Num (a -> a))
21:22:40 <P_D> > iterate (\x -> x - (x^2 - 2) / (2 * x)) 1.0
21:22:41 <lambdabot>  [1.0,1.5,1.4166666666666667,1.4142156862745099,1.4142135623746899,1.41421356...
21:23:40 <Pseudonym> @let trapezoid f x0 x1 n = let h = (x1-x0)/fromIntegral n in sum [ 0.5 * (f a + f b) | i <- [0..n-1], let { a = fromIntegral i * h + x0; b = fromIntegral (i+1) * h + x0 } ]
21:23:45 <lambdabot> Defined.
21:24:09 <Pseudonym> > trapezoid (\x -> 4 / (x^2 + 1)) 10
21:24:10 <lambdabot>  <Double -> Integer -> Double>
21:24:16 <Pseudonym> > trapezoid (\x -> 4 / (x^2 + 1)) 10 0 1
21:24:17 <lambdabot>  2.01980198019802
21:24:27 <Pseudonym> > trapezoid (\x -> 4 / (x^2 + 1)) 100 0 1
21:24:29 <lambdabot>  2.000199980002
21:24:49 <Olathe> @src doesn't work for this.
21:24:50 <lambdabot> Source not found. Are you on drugs?
21:24:57 <Olathe> @src trapezoid
21:24:57 <lambdabot> Source not found. Wrong!  You cheating scum!
21:25:24 <Pseudonym> @let romberg f x0 x1 n = let h = (x1-x0)/fromIntegral n in sum [ 0.5 * (f a + f b) | i <- [0..n-1], let { a = fromIntegral i * h + x0; b = fromIntegral (i+1) * h + x0 } ] / fromIntegral n
21:25:30 <lambdabot> Defined.
21:25:31 <Pseudonym> > romberg (\x -> 4 / (x^2 + 1)) 100 0 1
21:25:33 <lambdabot>  2.000199980002
21:25:37 <Pseudonym> > romberg (\x -> 4 / (x^2 + 1)) 10000 0 1
21:25:38 <lambdabot>  2.00000002
21:25:40 <Pseudonym> Grm.
21:25:46 <P_D> shouldn't you be getting pi?
21:25:46 <Pseudonym> Something wrong there.
21:25:49 <Pseudonym> Yes.
21:25:50 <Pseudonym> I should.
21:26:17 <Pseudonym> @let romberg' f x0 x1 n = let h = (x1-x0)/fromIntegral n in sum [ 0.5 * h * (f a + f b) | i <- [0..n-1], let { a = fromIntegral i * h + x0; b = fromIntegral (i+1) * h + x0 } ]
21:26:18 <P_D> romberg (\x -> 4 / (x^2 + 1)) 0 1 10
21:26:22 <P_D> > romberg (\x -> 4 / (x^2 + 1)) 0 1 10
21:26:25 <Pseudonym> > romberg' (\x -> 4 / (x^2 + 1)) 10000 0 1
21:26:27 <lambdabot>  3.1399259889071587
21:26:27 <lambdabot>   Not in scope: `romberg''
21:26:27 <lambdabot> Defined.
21:26:32 <Pseudonym> Ah!
21:26:35 <Pseudonym> D'oh.
21:26:37 <P_D> mixed up order =)
21:26:44 <Pseudonym> > romberg (\x -> 4 / (x^2 + 1))  0 1 10000
21:26:46 <lambdabot>  3.141592651923131
21:26:48 <Pseudonym> Yay.
21:27:29 <Pseudonym> > richardsonSequence [ romberg (\x -> 4 / (x^2 + 1)) 0 1 (2^n) | n <- [1..] ] 2 2
21:27:32 <lambdabot> Terminated
21:27:40 <Pseudonym> > richardsonSequence [ romberg (\x -> 4 / (x^2 + 1)) 0 1 (2^n) | n <- [2..] ] 2 2
21:27:44 <lambdabot> Terminated
21:27:53 <Pseudonym> Dammit.
21:28:43 <Pseudonym> > richardsonSequence [ romberg (\x -> 4 / (x^2 + 1)) 0 1 n | n <- [2..] ] 2 2
21:28:45 <lambdabot>  [3.1,3.1307692307692307,3.1340834590246365,3.1363649549339283,3.137767655634...
21:28:55 <Pseudonym> > richardsonSequence [ romberg (\x -> 4 / (x^2 + 1)) 0 1 (n*2) | n <- [2..] ] 2 2
21:28:56 <lambdabot>  [3.131176470588236,3.138891931765606,3.1397150841909482,3.1402857266598576,3...
21:29:02 <Pseudonym> > richardsonSequence [ romberg (\x -> 4 / (x^2 + 1)) 0 1 (n^2) | n <- [2..] ] 2 2
21:29:05 <lambdabot>  [3.131176470588236,3.1423212353429655,3.1413497501811434,3.1414587242064056,...
21:29:15 <Pseudonym> Right, it's just the 2^n aspect.
21:29:22 <Pseudonym> > richardsonSequence [ romberg (\x -> 4 / (x^2 + 1)) 0 1 (n^6) | n <- [2..] ] 2 2
21:29:26 <lambdabot> Terminated
21:29:30 <Pseudonym> > richardsonSequence [ romberg (\x -> 4 / (x^2 + 1)) 0 1 (n^3) | n <- [2..] ] 2 2
21:29:34 <lambdabot> Terminated
21:29:39 <BoudewijnE> ok, Ive got another noob question (i just dont see it... it s 6:28AM, and I have not slept yet)
21:29:50 <Pseudonym> OK, enough. :-)
21:29:51 <P_D> > richardsonSequence [ (1 + 1/n)^n | n <- [1..]] 2 2
21:29:52 <lambdabot>  Add a type signature
21:30:08 <BoudewijnE> I need to create a recursive function, which takes an int and returns all multiples of it in a list
21:30:20 <Pseudonym> > richardsonSequence [ ( 1 + 1 / fromIntegral n) ^ n | n <- [1..] ] 2 2
21:30:21 <lambdabot>  [2.0,2.3333333333333335,2.4156378600823043,2.469566921418773,2.5072972362862...
21:30:25 <ddarius> BoudewijnE: Why not sleep and ask tomorrow?
21:30:27 <BoudewijnE> I decided, it has to be like this:
21:30:29 <BoudewijnE> multiples :: Int -> [Int]
21:30:29 <BoudewijnE> multiples 0  = [0]
21:30:29 <BoudewijnE> multiples x  =
21:30:31 <Pseudonym> > richardsonSequence [ ( 1 + 1 / fromIntegral n) ^ n | n <- [2,4..] ] 2 2
21:30:32 <lambdabot>  [2.25,2.5052083333333335,2.5512436175887845,2.583144850271331,2.604998926142...
21:30:40 <nornagon> > let multiples n = map (n*) [1..] in multiples 10
21:30:41 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
21:30:43 <BoudewijnE> well, I couldnt sleep so I went doing haskell
21:30:44 <Pseudonym> > richardsonSequence [ ( 1 + 1 / fromIntegral n) ^ n | n <- [10,20..] ] 2 2
21:30:45 <lambdabot>  [2.593742460100002,2.673149453492561,2.681870889175798,2.6892487873183955,2....
21:31:00 <P_D> Need to iterate the richardson application
21:31:04 <nornagon> @type let multiples n = map (n*) [1..] in multiples
21:31:06 <lambdabot> forall a. (Num a, Enum a) => a -> [a]
21:31:18 <Pseudonym> > richardsonSequence [ ( 1 + 1 / fromIntegral n') ^ n' | n <- [1..], let { n' = 2^n } ] 2 2
21:31:20 <lambdabot>  [2.25,2.5052083333333335,2.6140463087293835,2.6664440435500274,2.69239773518...
21:31:29 <Pseudonym> > richardsonSequence [ ( 1 + 1 / fromIntegral n') ^ n' | n <- [1..], let { n' = 2^n } ] 2 2 !! 10
21:31:30 <lambdabot>  2.717877570458169
21:31:54 <Pseudonym> > richardsonSequence [ ( 1 + 1 / fromIntegral n') ^ n' | n <- [1..], let { n' = 2^n } ] 2 2 !! 100
21:31:55 <lambdabot>  1.0
21:31:57 <nornagon> Pseudonym: why not n <- map (2^) [1..] ?
21:32:04 <Pseudonym> Why not indeed.
21:32:07 <BoudewijnE> @nornagorn, thats not recursive
21:32:07 <lambdabot> Unknown command, try @list
21:32:09 <Pseudonym> > richardsonSequence [ ( 1 + 1 / fromIntegral n') ^ n' | n <- [1..], let { n' = 2^n } ] 2 2 !! 50
21:32:10 <lambdabot>  2.718281808182473
21:32:11 <BoudewijnE>  @nornagorn, thats not recursive
21:32:18 <nornagon> BoudewijnE: so?
21:32:27 <nornagon> if you need it to be recursive
21:32:28 <Pseudonym> Slow convergence.  There mus be a better way to express that.
21:32:29 <BoudewijnE> I want to create a recursive function
21:32:36 <nornagon> i'm guessing you're trying to get us to do your homework
21:32:41 <P_D> > iterate (\x -> richardsonSequence x 2 2) [ (1 + 1 / fromIntegral n)^n | n <- [1..]]
21:32:42 <lambdabot>  [[2.0,2.25,2.3703703703703702,2.44140625,2.48832,2.5216263717421143,2.546499...
21:32:45 <nornagon> which is not what #haskell is for
21:32:49 <BoudewijnE>  @nornagon: nop Im not
21:32:58 <nornagon> so why does it have to be recursive?
21:32:58 <P_D> > iterate (\x -> richardsonSequence x 2 2) [ (1 + 1 / fromIntegral n)^n | n <- [1..]] !! 20
21:33:00 <lambdabot>  [2.0,80.83421380030434,-612.2665863150922,1943.985711833269,-3668.4964948975...
21:33:07 <Pseudonym> @yow
21:33:07 <lambdabot> Everywhere I look I see NEGATIVITY and ASPHALT ...
21:33:08 <P_D> > (iterate (\x -> richardsonSequence x 2 2) [ (1 + 1 / fromIntegral n)^n | n <- [1..]]) !! 20
21:33:09 <lambdabot>  [2.0,80.83421380030434,-612.2665863150922,1943.985711833269,-3668.4964948975...
21:33:15 <BoudewijnE> because I want to get more experienced using recursive functions
21:33:16 <Pseudonym> Anyway, fun stuff.
21:33:31 <nornagon> how will getting #haskell to write it for you make you more experienced? :)
21:33:40 <oerjan> > let mults n = [n,2*n..] in map (take 3 . mults) [-2,0,1.1]
21:33:42 <lambdabot>  [[-2.0,-4.0,-6.0],[0.0,0.0,0.0],[1.1,2.2,3.3000000000000003]]
21:33:46 <P_D> yes, I love seeing numerical stuff in haskell.
21:33:54 <BoudewijnE> Ive been thinking about it for some time now
21:34:03 <oerjan> > let mults n = [n,2*n..] in map (take 3 . mults) [-2,0,1]
21:34:04 <lambdabot>  [[-2,-4,-6],[0,0,0],[1,2,3]]
21:34:05 <BoudewijnE> and I didnt grasp it
21:34:16 <oerjan> > [0,0..]
21:34:17 <P_D> someone should translate SICM to haskell
21:34:17 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:34:20 <Pseudonym> OK, what a seriously cool paper title.
21:34:23 <Pseudonym> Richardson, L. F. (1910). "The approximate arithmetical solution by finite differences of physical problems including differential equations, with an application to the stresses in a masonry dam". Philosophical Transactions of the Royal Society of London, Series A 210: 307357.
21:34:39 <Pseudonym> Woo!  Masonry dam!
21:36:06 <nornagon> > let { mults' a n = a*n ++ mults (a+1) n ; mults = mults' 1 } in mults 10
21:36:07 <lambdabot>  Couldn't match expected type `[a] -> [a]'
21:36:16 <nornagon> rats.
21:36:51 <nornagon> > let { mults' a n = a*n ++ mults' (a+1) n ; mults = mults' 1 } in mults 10
21:36:52 <lambdabot>   add an instance declaration for (Num [a])
21:36:52 <lambdabot>     In the expression: mults' 1
21:36:52 <lambdabot>  ...
21:37:08 <BoudewijnE> well, i just wrote it myself
21:37:09 <nornagon> > let { mults' a n = a*n : mults' (a+1) n ; mults = mults' 1 } in mults 10 -- third time's a charm
21:37:11 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
21:37:38 <int-e> > iterate (10+) 10
21:37:39 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
21:37:43 <BoudewijnE> darn, when asking people about it, finding out how to write it yourself sucks
21:38:12 <nornagon> > let mults a = iterate (a+) a in mults 10
21:38:15 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
21:38:35 <nornagon> i still like the map solution i gave best
21:38:40 <ddarius> @pl \a -> iterate (a +) a
21:38:49 <BoudewijnE> me too
21:38:51 <lambdabot> iterate =<< (+)
21:38:55 <nornagon> oh man
21:38:59 <nornagon> that's head-breaky
21:39:03 <BoudewijnE> I just wrote something which kind of works...
21:39:07 <int-e> > let mults a = fix ((a:) . map (a+)) in mults 10
21:39:10 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
21:39:19 <int-e> @src iterate
21:39:29 <lambdabot> iterate f x =  x : iterate f (f x)
21:45:24 <oerjan> > flip map [1..] . (*) $ 3
21:45:26 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
21:45:59 <Pseudonym> > map (\n -> log n - sum (map (1/) [1..n]) [1..]
21:46:00 <lambdabot>  Unbalanced parenthesis
21:46:04 <Pseudonym> > map (\n -> log n - sum (map (1/) [1..n])) [1..]
21:46:06 <lambdabot>  [-1.0,-0.8068528194400547,-0.7347210446652235,-0.6970389722134425,-0.6738954...
21:46:23 <Pseudonym> > map (\n -> sum (map (1/) [n,n-1..n]) - log n) [1..]
21:46:24 <lambdabot>  [1.0,-0.1931471805599453,-0.7652789553347765,-1.1362943611198906,-1.40943791...
21:46:36 <Pseudonym> > map (\n -> sum (map (1/) [n,n-1..1]) - log n) [1..]
21:46:38 <lambdabot>  [1.0,0.8068528194400547,0.7347210446652235,0.6970389722134425,0.673895420899...
21:46:52 <Pseudonym> > richardsonSequence (map (\n -> sum (map (1/) [n,n-1..1]) - log n) [1..]) 2 2
21:46:53 <lambdabot>  [1.0,0.742470425920073,0.7085575659949602,0.6823217576681356,0.6646098181262...
21:47:08 <Pseudonym> > richardsonSequence (map (\n -> sum (map (1/) [n,n-1..1]) - log n) (map (^2) [1..])) 2 2
21:47:10 <lambdabot>  [1.0,0.5960519629512566,0.6109070191151414,0.5994463217792895,0.592805885513...
21:47:17 <Pseudonym> > richardsonSequence (map (\n -> sum (map (1/) [n,n-1..1]) - log n) (map (2^) [1..])) 2 2
21:47:20 <lambdabot>  Exception: stack overflow
21:47:29 <Pseudonym> > richardsonSequence (map (\n -> sum (map (1/) [n,n-1..1]) - log n) (map (^4) [1..])) 2 2
21:47:33 <lambdabot> Terminated
21:48:41 <Pseudonym> > richardsonSequence (map (\n -> sum (map ((1/) . fromIntegral) [n,n-1..1]) - log n) (map (2^) [1..])) 2 2
21:48:42 <lambdabot>  Add a type signature
21:48:52 <Pseudonym> > richardsonSequence (map (\n -> sum (map ((1/) . fromIntegral) [n::Integer,n-1..1]) - log n) (map (2^) [1..])) 2 2
21:48:53 <lambdabot>   add an instance declaration for (Floating Integer)
21:49:11 <Pseudonym> > richardsonSequence (map (\n -> sum (map ((1/) . fromIntegral) [n::Integer,n-1..1]) - log (fromIntegral n)) (map (2^) [1..])) 2 2
21:49:14 <lambdabot>  Exception: stack overflow
21:49:20 <Pseudonym> Oh well.
21:51:16 <misterbeebee> is there a way to ask lambdabot to give the definition of a function, for a given typeclass instance. e.g:
21:51:19 <misterbeebee> @src (>>)
21:51:19 <lambdabot> m >> k      = m >>= \_ -> k
21:51:20 <misterbeebee> ok
21:51:26 <misterbeebee> @src (>>=)
21:51:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:51:28 <misterbeebee> not ok
21:51:40 <bos> hmm. dunno.
21:51:54 <Korollary> it wouldn't know which >>=
21:51:56 <oerjan> @src Maybe (>>=)
21:51:56 <lambdabot> (Just x) >>= k      = k x
21:51:56 <lambdabot> Nothing  >>= _      = Nothing
21:52:01 <misterbeebee> d'oh.
21:52:11 <misterbeebee> I tried (Maybe.>>=)
21:52:13 <bos> @src (>>=) :: a -> Maybe b
21:52:13 <lambdabot> Source not found. That's something I cannot allow to happen.
21:52:26 <misterbeebee> @src (->) (>>=)
21:52:26 <lambdabot> f >>= k = \ r -> k (f r) r
21:52:28 <misterbeebee> aha
21:53:05 <misterbeebee> the infamous Function Mona
21:53:06 <misterbeebee> d
21:53:16 <Korollary> @src Int (==)
21:53:16 <lambdabot> (==) = eqInt
21:53:25 <Korollary> @index eqInt
21:53:25 <lambdabot> bzzt
21:53:32 <misterbeebee> (->) (>>=)   -- NOT google-searchable :-/
21:53:59 <Korollary> it now may be since the channel is logged.
21:54:21 <misterbeebee> google doesn't index punctuation
21:59:21 <dolio> Why would you search google for that anyway?
21:59:41 <misterbeebee> dolio: to find its definition
22:03:31 <dolio> I'm not sure that's a very good strategy for any particular haskell function.
22:04:48 <misterbeebee> it's not bad: http://www.google.com/search?q=haskell+maybe http://www.google.com/search?q=haskell+functor http://www.google.com/search?q=haskell+monoid
22:04:48 <lambdabot> Title: haskell maybe - Google Search
22:08:52 <dolio> Yeah, but instead of that, you can do:
22:08:57 <dolio> @index (>>=)
22:08:57 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:09:05 <dolio> @source Control.Monad
22:09:05 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
22:09:37 <dolio> Or use hoogle, or :i in ghci.
22:11:00 <kalmar> are weeks or months a better unit for ghc 6.8 eta?
22:12:54 <sorear> weeks
22:13:13 <Pseudonym> Some multiple of four weeks, to be precise.
22:13:15 <misterbeebee> dolio: even with what you posted, I don't know where to find the definition of (->)(>>=). ... I don't see it in Control/Monad.hs.... my point simply was (and still is), if my question is "what is (>>=) in the function monad?" it's hard craft an effective search.
22:13:42 * Pseudonym suggests measuring in Planck time units
22:13:44 <oerjan> misterbeebee: (->)(>>=) is a special case
22:13:58 <misterbeebee> yes, that 's why I commented on it!
22:14:20 <oerjan> in most cases, the definition of an instance will either be in the module defining the class, or the module defining the data type
22:14:30 <misterbeebee> I agree completely.
22:14:46 <oerjan> anything else is an orphan instance, which is frowned upon
22:15:45 <oerjan> however, in this case both -> and >>= are defined in H98, but no instance
22:16:06 <oerjan> so it cannot be put there without breaking the standard
22:16:41 <oerjan> those are therefore put in Control.Monad.Instances
22:17:16 <oerjan> at least that is what i gathered so far
22:17:24 <misterbeebee> aha! http://darcs.haskell.org/packages/base/Control/Monad/Instances.hs
22:18:04 <misterbeebee> thx.
22:19:56 <misterbeebee> it would be lovely if haskell had an equivalent of http://perldoc.perl.org/English.html to make beauties like "(->)" more discoverable
22:19:57 <lambdabot> Title: English - perldoc.perl.org
22:20:31 <dolio> ((->) e) is called Reader e.
22:20:58 <dolio> And ((,) w) is Writer w.
22:21:50 <misterbeebee> ohhhhhhhh
22:22:49 <misterbeebee> wait... huh? Is that same or different to  (Reader r a), as in http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
22:22:51 <lambdabot> http://tinyurl.com/ona24
22:23:12 <dolio> They're different types, so not interchangeable, but they do the same thing.
22:23:36 <dolio> Reader and Writer use newtypes, so they require a runFoo function, also.
22:24:25 <dolio> (->) e and (,) w do the same thing, but you work with the type directly.
22:24:37 <dolio> Note, (->) r a = r -> a.
22:24:42 <dolio> @type runReader
22:24:44 <lambdabot> forall r a. Reader r a -> r -> a
22:25:02 <dolio> You give it a Reader r a, it gives you an r -> a.
22:26:13 <dolio> > runReader (a <- ask ; return (a + 1)) 0
22:26:13 <lambdabot>  Parse error
22:26:19 <dolio> > runReader (do a <- ask ; return (a + 1)) 0
22:26:20 <lambdabot>  1
22:26:27 <dolio> > (do a <- ask ; return (a + 1)) 0
22:26:28 <lambdabot>  1
22:26:48 <misterbeebee> hmm. I'll go read up on that connection and sleep on it. thanks for the pointer.  I knew Reader and Writer existed but haven't studied them yet. I thought they were IO or State related, from the names.
22:27:18 <misterbeebee> I'm sure there's some deep mathematical connection, of course....
22:27:32 <dolio> Ah, they're sort of related to state, in some ways.
22:27:51 <sjanssen> misterbeebee: nah, the names are supposed to indicate their capabilities
22:28:00 <sjanssen> Reader is like a read-only state
22:28:13 <sjanssen> Writer is like write-only state
22:29:01 <olsner> @type ask
22:29:03 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
22:30:37 <misterbeebee> My puzzlement now is what the connection between the notion of "reader' and (->) monad, which I have only ever seen used to implement the  "function-call" tricks [1] . but don't tell me,  I'll go do some book-learnin' and come back edumicated :)
22:30:39 <misterbeebee> [1] http://www.haskell.org/haskellwiki/Blow_your_mind#Monad_magic
22:30:40 <lambdabot> Title: Blow your mind - HaskellWiki
22:30:51 <misterbeebee> g'night all
22:36:31 * bos wonders if edward kmett's blog is syndicated on planet haskell
22:36:58 <bos> hm, apparently not.
22:43:45 <Pseudonym> @let approxLog x = sum . reverse . take 10000 $ [ (if even k then (-1) else 1) * x^k / fromIntegral k | k <- [1..] ]
22:43:53 <lambdabot> Defined.
22:43:53 <Pseudonym> > approxLog 0.01
22:43:55 <lambdabot>  9.950330853168083e-3
22:43:55 <Pseudonym> > log 0.01
22:43:57 <lambdabot>  -4.605170185988091
22:44:01 <Pseudonym> > log 1.01
22:44:02 <lambdabot>  9.950330853168092e-3
22:45:03 <Pseudonym> @let approxLog' x n = sum . reverse . take n $ [ (if even k then (-1) else 1) * x^k / fromIntegral k | k <- [1..] ]
22:45:10 <lambdabot> Defined.
22:45:37 <Pseudonym> > approxLog' 0.1) [1..]
22:45:37 <lambdabot>  Unbalanced parenthesis
22:45:43 <Pseudonym> > map (approxLog' 0.1) [1..]
22:45:44 <lambdabot>  [0.1,9.5e-2,9.533333333333334e-2,9.530833333333334e-2,9.531033333333334e-2,9...
22:45:53 <Pseudonym> > log 1.1
22:45:54 <lambdabot>  9.531017980432493e-2
22:46:08 <Pseudonym> > richardsonSequence (map (approxLog' 0.1) [1..]) 2 2
22:46:09 <lambdabot>  [0.1,9.333333333333334e-2,9.558518518518519e-2,9.528569077013523e-2,9.531217...
22:46:17 <Pseudonym> > richardsonSequence (map (approxLog' 0.1) [1..]) 2 2 !! 10
22:46:18 <lambdabot>  9.531017980518923e-2
22:46:52 <Pseudonym> > richardsonSequence (map (approxLog' 0.01) [1..]) 2 2 !! 10
22:46:54 <lambdabot>  9.950330853168083e-3
22:46:55 <Pseudonym> > log 1.01
22:46:56 <lambdabot>  9.950330853168092e-3
22:51:22 <Pseudonym> > romberg (\x -> -log (log (1/x))) 0 1 10
22:51:24 <lambdabot>  NaN
22:51:34 <Pseudonym> > romberg (\x -> -log (log (1/x))) 0.001 1 10
22:51:35 <lambdabot>  Infinity
22:52:02 <tehgeekmeister_> in the monad magic bit up there, there's a tidbit: sequence [even,odd] 4
22:52:09 <tehgeekmeister_> this doesn't work for me in ghci
22:52:12 <tehgeekmeister_> is the wiki wrong?
22:52:27 <oerjan> > sequence [even,odd] 4
22:52:29 <lambdabot>  [True,False]
22:52:42 <tehgeekmeister_> huh.
22:52:49 <Pseudonym> > [ let n1 = 1 / fromIntegral n in 1/n1 - approxLog n1 | n <- [1..] ]
22:52:53 <lambdabot> Terminated
22:52:54 <oerjan> Control.Monad.Instances, same as misterbeebee asked about
22:53:50 <tehgeekmeister_> wow, i didn't even know that bit existed.
22:54:07 <Pseudonym> > [ let n1 = 1 / fromIntegral n in n1 - approxLog n1 | n <- [1..] ]
22:54:10 <lambdabot> Terminated
22:54:16 <Pseudonym> > [ let n1 = 1 / fromIntegral n in n1 - approxLog n1 | n <- [1..10] ]
22:54:19 <lambdabot>  [0.3069028169400547,9.453489189183562e-2,4.565126088155241e-2,2.685644868579...
22:54:26 <Pseudonym> > sum . reverse $ [ let n1 = 1 / fromIntegral n in n1 - approxLog n1 | n <- [1..10] ]
22:54:28 <lambdabot>  0.5311229786698834
22:54:45 <Pseudonym> > sum . reverse $ [ let n1 = 1 / fromIntegral n in n1 - approxLog n1 | n <- [1..20] ]
22:54:49 <lambdabot>  0.5532672169202589
22:54:58 <Pseudonym> Hmm, kinda slow.
22:55:48 <Pseudonym> > let { euler nn = sum . reverse $ [ let n1 = 1 / fromIntegral n in n1 - approxLog n1 | n <- [1..nn] ] } in richardsonSequence (map euler [1..]) 2 2
22:55:52 <lambdabot> Terminated
22:55:54 <Pseudonym> > let { euler nn = sum . reverse $ [ let n1 = 1 / fromIntegral n in n1 - approxLog n1 | n <- [1..nn] ] } in richardsonSequence (map euler [1..]) 2 2 !! 10
22:55:58 <lambdabot> Terminated
22:56:07 <Pseudonym> > let { euler nn = sum . reverse $ [ let n1 = 1 / fromIntegral n in n1 - approxLog n1 | n <- [1..nn] ] } in richardsonSequence (map euler [1..]) 2 2 !! 2
22:56:09 <lambdabot>  0.4642631711547241
22:56:14 <Pseudonym> > let { euler nn = sum . reverse $ [ let n1 = 1 / fromIntegral n in n1 - approxLog n1 | n <- [1..nn] ] } in richardsonSequence (map euler [1..]) 2 2 !! 5
22:56:18 <lambdabot>  0.5092501646319828
22:56:45 <Pseudonym> > let { euler nn = sum . reverse $ [ let n1 = 1 / fromIntegral n in n1 - approxLog n1 | n <- [1..nn] ] } in richardsonSequence (map euler [1..]) 2 2 !! 8
22:56:48 <lambdabot> Terminated
22:57:05 <Pseudonym> > let { euler nn = sum . reverse $ [ let n1 = 1 / fromIntegral n in n1 - approxLog' n1 n | n <- [1..nn] ] } in richardsonSequence (map euler [1..]) 2 2 !! 8
22:57:06 <lambdabot>  0.2500839317689342
22:57:10 <Pseudonym> > let { euler nn = sum . reverse $ [ let n1 = 1 / fromIntegral n in n1 - approxLog' n1 n | n <- [1..nn] ] } in richardsonSequence (map euler [1..]) 2 2 !! 10
22:57:11 <lambdabot>  0.2579117923652534
22:57:13 <Pseudonym> > let { euler nn = sum . reverse $ [ let n1 = 1 / fromIntegral n in n1 - approxLog' n1 n | n <- [1..nn] ] } in richardsonSequence (map euler [1..]) 2 2 !! 100
22:57:16 <lambdabot>  0.29365017116076597
22:57:16 <tehgeekmeister_> is it not worthwhile to try and understand why sequence works on a list of functions?
22:59:06 * Pseudonym thanks dons for providing a free CPU
22:59:21 <Pseudonym> Saves me doing number crunching on my own.
23:00:42 <olsner> is the CPU you're on now incapable of operating on numbers?
23:00:46 <tehgeekmeister_> how does one search for definitions >>= in various monads?
23:01:02 <tehgeekmeister_> *definitions of
23:01:06 <olsner> @src Reader (>>=)
23:01:06 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:01:37 <olsner> @src Maybe (>>=)
23:01:37 <lambdabot> (Just x) >>= k      = k x
23:01:37 <lambdabot> Nothing  >>= _      = Nothing
23:01:46 <tehgeekmeister_> thanks
23:03:12 <tehgeekmeister_> are functions a monad?  if not, why does sequence work on a list of them?
23:04:41 <misterbeebee> tehgeekmeister_: yes.. http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Instances.html
23:04:43 <lambdabot> http://tinyurl.com/2epohf
23:05:21 <tehgeekmeister_> whoa!  sorry, i wasn't paying attention before when it seems all this was discussed.
23:05:23 <misterbeebee> you're asking questions very similar to ones I just asked a few minutes ago.
23:07:38 <tehgeekmeister_> ?src (->) >>=
23:07:38 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:08:38 <sarehu> if you want the source, click on the 'source code' button at the top of the page in the previous URL.
23:09:21 <tehgeekmeister_> just realized that.
23:09:28 <tehgeekmeister_> thanks tho.
23:24:07 <hpaste>  twifkak pasted "QuickCheck for SwapWorkspaces" at http://hpaste.org/3077
23:24:38 <Syzygy-> tehgeekmeister_: (-> a) is a monad for sufficiently nice types a.
23:25:51 <oerjan> er, (->) a is always a monad.  i was not aware that (-> a) was.
23:27:33 <Syzygy-> oerjan: Sorry.
23:27:41 <Syzygy-> I meant (->) a
23:27:56 <quicksilver> not to be pedantic, but "nice types" a?
23:28:45 <segher> nice types.  you know, the kind you would lend money to.
23:28:49 <oerjan> Writer and Either/Error have restrictions, but not -> as far as i know
23:29:23 <oerjan> *ErrorT
23:29:24 <pjd> (-> a) is a contravariant functor, though
23:30:48 <oerjan> and self-adjoint, thus the Cont monad.
23:31:45 <hpaste>  twifkak annotated "QuickCheck for SwapWorkspaces" with "revise mostlyEqual" at http://hpaste.org/3077#a1
