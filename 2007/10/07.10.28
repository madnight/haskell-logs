00:00:00 <omnId> @pl \f g h x y -> f (g x) (h y)
00:00:01 <lambdabot> ((flip . ((.) .)) .) . (.)
00:00:05 <omnId> gah!
00:01:39 <omnId> @type join ((((flip . ((.) .)) .) . (.)) listToMaybe fmap const)
00:01:47 <lambdabot>     Couldn't match expected type `b -> c'
00:01:48 <lambdabot>            against inferred type `Maybe a'
00:01:48 <lambdabot>     In the first argument of `((((flip . (((.) .))) .)) . (.))', namely
00:02:47 <omnId> @pl \f g h x -> f (g x) (h x) -- isn't this liftM2?  you should be able to drop the join
00:02:47 <lambdabot> liftM2
00:02:52 <omnId> aha!
00:03:11 <omnId> @type liftM2 fmap const listToMaybe
00:03:12 <lambdabot> forall a. [a] -> Maybe [a]
00:03:13 <wli> I guess I'm killing time until Monday so I might as well try to solve the Lagrange-Hermite interpolation problem for rational funcitions.
00:03:19 <omnId> score!
00:03:31 <bparkis> wow why do i have reisio on ignore
00:03:40 <wli> omnId: Fantastic.
00:03:56 <bparkis> sorry wrong channel
00:04:28 <wli> omnId: Want to help me take a stab at the Lagrange-Hermite interpolation problem for rational functions?
00:04:42 <omnId> I have no idea what you just said %)
00:04:54 <wli> omnId: Do you know about Lagrange interpolation?
00:04:59 <omnId> nope
00:05:11 <wli> omnId: Do you know what an interpolating polynomial is?
00:05:25 <omnId> sorry
00:05:41 <P_D> Change basis of functions to some orthogonal polynomial basis, truncate, result is an interpolation
00:06:31 <wli> P_D: That's great for when you're working with polynomials and are not trying to interpolate derivatives as well, both of which are the case in the Lagrange-Hermite interpolation problem for rational functions.
00:06:57 <wli> P_D: Corrected so I actually said what I meant anyway.
00:07:54 <wli> P_D: Lagrange Hermite interpolation is interpolating 0-th through n_k-th derivatives at the n-th knot where k depends on n, and this is for rational functions, not polynomials.
00:10:29 <wli> P_D: Basically, there are N knots, and at the n-th knot the 0-th through n_k-th derivatives are specified. The problem is then to determine a rational function of specified feasible degree type whose derivatives (including the 0-th derivatives a.k.a. the ordinary function values) take on the specified values.
00:11:51 <wli> (degree type is the degree of the numerator and denominator as a pair of natural numbers; it's feasible if the degree type has high enough numerator and denominator degrees for a solution to the problem to exist)
00:12:14 <ac> is there any way to get NaN other than (/0)?
00:12:49 <wli> I'd think there'd be a NaN constructor of sorts.
00:13:56 <ac> well I'm wondering where NaN is coming from... I don't actually want it
00:14:47 <ac> AFAIK, I don't have any cases of (/0). I get Infinity or 0 after a number of iterations, and then after a 10 or so more I get NaN
00:15:16 <wli> P_D: Any thoughts/advice/etc.?
00:15:30 <P_D> I'm still looking for basic information on it.
00:15:38 <scook0> > let inf = (1/0) in inf - inf
00:15:39 <P_D> ac:  sounds like something is unstable
00:15:43 <lambdabot>  0.0
00:15:59 <sarehu> > (0 / 0) :: Double
00:16:00 <lambdabot>  NaN
00:16:03 <goalieca> > 1/0
00:16:05 <lambdabot>  Infinity
00:16:09 <P_D> > 10.0**10000.0
00:16:10 <lambdabot>  Infinity
00:16:12 <scook0> > let inf = (1/0::Double) in inf - inf
00:16:13 <lambdabot>  0.0
00:16:20 <wli> P_D: It doesn't exist. It's part of something I've been kicking around for a while.
00:16:20 <scook0> o_O
00:16:30 <jql> hey...
00:16:35 <jql> that's not right
00:17:01 <P_D> what's that then?  Lagrange Hermite interpolation seems to exist
00:17:23 <omnId> Prelude> let inf = 1/0::Double in inf - inf
00:17:23 <omnId> NaN
00:17:25 <wli> P_D: For polynomials. Nothing really discusses it for rational functions.
00:17:33 <omnId> looks like an overacheiving optimization
00:18:10 <ac> P_D: Indeed. I experimented with the initial parameters to get between tending towards 0 and tending towards Infinity, and now it's going directly from a very large value to NaN
00:18:49 <ac> P_D: the only division is by 3
00:18:55 <P_D> you want to construct rational interpolations with good derivative errors?
00:19:08 <P_D> ac:  what's the general thing you're doing that's failing?
00:19:35 <wli> P_D: No, specified derivatives at knots.
00:19:42 <ac> P_D: I'm fooling with rules for a continuous 1D cellular automata
00:20:17 <P_D> ac:  your rule is a PDE?
00:20:24 <ac> P_D: PDE?
00:20:33 <P_D> your rules compute derivatives?
00:20:45 <ac> P_D: what the heck is that?
00:20:55 <P_D> partial differential equation
00:21:11 <ac> what's a function that takes the fractional part of a number?
00:21:21 <sclv> the chunk I wrote the other day, maybe not pointfree enough? chunk x = unfoldr (\a -> case splitAt x a of ([],[]) -> Nothing; a' -> Just a')
00:21:56 <ac> P_D: I don't follow... I don't think any partial derivation is involved
00:22:11 <P_D> ac:  properFraction
00:22:12 <wli> sclv: It does look simpler.
00:22:28 <ac> snd . properFraction
00:22:31 <P_D> ac:  paste your rule
00:22:44 <P_D> wli:  What's a knot?
00:23:02 <wli> P_D: One of the x coordinates where interpolation is done at.
00:23:38 <P_D> where you sample the function?
00:23:47 <P_D> or where you apriori intend to evaluate it
00:24:01 <ac> P_D: currently it's: cRule1 a b c = snd $ properFraction $ 1.2 * a * b * c / 3
00:24:06 <wli> Sampling the function and its derivatives.
00:24:34 <P_D> > 1.2**10
00:24:46 <lambdabot>  6.191736422399997
00:24:52 <P_D> that's not so bad =)
00:24:56 <omnId> @type unfoldr . (. liftM2 fmap const listToMaybe) . fmap . splitAT
00:24:57 <lambdabot> Not in scope: `splitAT'
00:24:58 <omnId> @type unfoldr . (. liftM2 fmap const listToMaybe) . fmap . splitAt
00:24:59 <lambdabot> forall a. Int -> [a] -> [[a]]
00:25:12 <wli> omnId: Very nice.
00:25:12 <ac> P_D: that immediately drops to 0
00:25:35 <omnId> wli: just what you had, with the additional n pl'd
00:25:42 <P_D> a b c are adjacent values in a row?
00:25:47 <ac> P_D: yeah
00:25:57 <eventualbuddha> wow, that is so unreadable to my eyes
00:26:09 <omnId> mine, too.  Don't worry :)
00:26:19 <ac> + 1 makes something like static
00:26:38 <P_D> if a b c ~ 1/2, then you have (1.2 * (1/8) /3 )**10
00:26:50 <P_D> > (1.2 * (1/8.0) / 3.0)**10
00:26:51 <omnId> eventualbuddha: it equals: \x -> unfoldr ((. blahblah) (fmap (splitAt x)))
00:26:52 <lambdabot>  9.765624999999992e-14
00:26:56 <P_D> that's pretty much zero.
00:27:00 <P_D> you need a b c ~ 1
00:27:17 <omnId> eventualbuddha: which equals: \x y -> unfoldr (fmap (splitAt x) . blahblah)
00:27:21 <wli> P_D: The coefficients are not of interest so if anything like Neville or Aitken come out they're fine.
00:27:25 <omnId> erm, s/y//
00:27:47 <omnId> which equals: \x -> unfoldr (\y -> fmap (splitAt x) (blahblah y))
00:27:50 <eventualbuddha> that looks a little easier, but i guess that's the way it works when you add explicit vars :)
00:28:18 <omnId> where blahblah = liftM2 fmap const listToMaybe, of course :)
00:28:31 <bparkis> is there a general advanced algorithms book where the pseudocode is Haskell-like?
00:28:54 <eventualbuddha> lambdabot: help
00:28:55 <bparkis> or even with Haskell implementations of the algorithms in a supplement?
00:29:02 <omnId> @help
00:29:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:29:08 <eventualbuddha> @list
00:29:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
00:29:14 <goalieca> bparkis, or how about a book without imperative-only versions
00:29:16 <P_D> wli:  Is this general interest or do you have an application in mind?
00:29:24 <omnId> eventualbuddha: she listens to /msgs, if you want to futz around.
00:29:47 <ac> P_D: currently I'm trying to reproduce this: http://forum.wolframscience.com/archive/topic/549-1.html
00:29:48 <lambdabot> Title: [Coloured continuous cellular automata] - A New Kind of Science: The NKS Forum
00:29:50 <bparkis> yes that's the thing goalieca, many of the algorithms i've seen are only presented in an imperative style
00:29:56 <ac> P_D: I don't understand how his rules are working
00:30:11 <eventualbuddha> omnId: cool
00:30:24 <bparkis> so any pure functional algorithms book would be a step up
00:30:24 <omnId> @quote lambdabot
00:30:25 <lambdabot> lambdabot says: Will I get a treat if I join #gentoo-uy?
00:30:28 <wli> P_D: Oh, I have several applications in mind. I've actually had this on the back burner along with several things I intend to use it for for some time.
00:30:40 <ac> P_D: AFAIK, his rule is: snd $ properFraction $ 1.02 * a * b * c / 3
00:30:53 <ac> P_D: which doesn't work at all for me
00:30:58 <bparkis> i'm looking for something that covers the same stuff as in, say, CLRS introduction to algorithms
00:31:26 <bparkis> cormen leiserson rivest stein
00:31:27 <P_D> ac:  I see a rule like (a + b + c) /3 *1.02  (order of operations?  I should think 1.02 is on top like you have)
00:31:42 <wli> P_D: I think it may be flat out sufficiently obscure for no one else to do anything with.
00:32:08 <P_D> wli:  what's that?  I've only ever used rational "interpolation" for extrapolating to infinity
00:32:45 <P_D> e.g. I just had an experiment go bad halfway through, so I extrapolated to t= infinity to get some "data"
00:33:00 <wli> P_D: Rational functions have far nicer stability properties than polynomials because things like poles in the complex plane are easily captured.
00:33:10 * P_D nods
00:33:46 <P_D> but why the derivatives?  that can't be something physical, and if you can evaluate the function, why do you need to interpolate?
00:33:52 <wli> P_D: The gist of the plot is to use them in several places where polynomials are more typically used.
00:34:35 <goalieca> offtopic: wow. chevy chase did the weekend update on SNL
00:34:43 <wli> P_D: I'll give away one element of the plot, then.
00:35:00 <ac> P_D: man I must be tired, I s/+/*/
00:35:44 <wli> P_D: The way splines work is basically two stages. First you solve for the "moments," which are the higher derivatives at the interpolation points, then you reconstruct the functions of whatever sort you're using (typically polynomials) to get an approximant.
00:35:47 <P_D> ac: =) this is why people should specify properties of their code
00:36:20 <ac> P_D: what do you mean by that?
00:36:32 <wli> P_D: For the first stage, it doesn't matter what you're using. Trigonometric, exponential, polynomial, rational, you don't care. You just solve for derivatives at the knots.
00:36:39 <ac> (ooh this is pretty)
00:37:00 <P_D> ac: some predicates their functions satisfy.  like rule x 0 0 proportional to x (as opposed to rule x 1 1)
00:37:34 <ac> P_D: ah interesting
00:37:52 <wli> P_D: Well, the specific linear equations for those derivatives will depend on the sorts of functions you're using, but it's basically plug-and-chug with a linear system solver.
00:37:52 <P_D> ac: check out QuickCheck for haskell, it's pretty nice
00:38:01 <P_D> wli:  Sure
00:38:31 <P_D> wli:  I took a class on FEM awhile ago
00:38:57 <wli> P_D: The observation motivating this is that "rational splines" tend to be utter bullcrap as typically done. Basically some kind of garbage with homogeneous coordinates is done and so on.
00:40:09 <wli> P_D: There's another line of thought here relating to Pade approximants...
00:40:31 * P_D was typing a suggestion to look at pade approximants
00:40:51 <P_D> wli: so you want to make non shitty rational splines
00:40:52 <P_D> ?
00:41:48 <wli> P_D: The linear systems to determine the rational functions arise from the methods used to compute Pade approximants in conjunction with the Lagrange-Hermite bases for polynomials.
00:42:15 <wli> P_D: It's a general approximation technique, so that's one application.
00:42:35 <ac> P_D: can you think of something more interesting than properFraction to make it tend back towards 1? properFraction just makes it go from white to a black line in one step
00:43:08 <P_D> ac:  normalize the entire thing to sum to 1 or sumsquare to 1?
00:43:25 <P_D> ac: or rather sum to N
00:44:12 <ac> I see, so crunch the row, and then normalize it to .5 or something
00:44:26 <P_D> wli:  there's some method for estimating the location / order of a pole from a power series.  maybe you could do that at each point, then take a sum of rational functions with singularities at those spots
00:45:03 <wli> P_D: That would be a different technique for constructing rational functions.
00:45:38 <wli> P_D: The parts of this I'm actively working on are elsewhere anyway.
00:46:40 <P_D> wli: are working strictly in one dimension?
00:46:43 <wli> I just want a Haskell implementation.
00:47:28 <wli> P_D: Essentially yes. The methods for moving to multiple dimensions are essentially using vectors as coefficients like one does for polynomial splines.
00:48:07 <wli> Or otherwise repeating the process for each coordinate.
00:48:15 <P_D> wli:  for X -> X^N sure but X^N -> X^M is trickier
00:48:51 <wli> I have no plausible X^N -> X^M strategies yet.
00:49:16 <P_D> wli: so you do have math worked out for what you want to do?
00:49:18 <wli> The rational function analysis does not generalize to X^N -> X^M as easily as polynomials.
00:50:32 <wli> P_D: Depends. I have computational methods for the 1D splines but I've not recapitulated the error analysis from the polynomial case yet. There are other things like mesh refinement where the computational methods aren't worked out.
00:51:42 <wli> P_D: Things like X^N -> X^M aren't even conceptually worked out.
00:52:43 <ac> P_D: guess it makes sense... normalizing it to N simply causes it to gradually fade to that value
00:53:05 <wli> P_D: Use for non-spline-related function approximation in the complex plane is also not very well-analyzed in terms of error bounds.
00:53:47 <P_D> ac: yep.  you can show that algebraically by writing your rule in terms of finite differences, then fourier transforming
00:54:28 <ac> P_D: but you said normalize so it sums to 1, which is different
00:54:48 <wli> P_D: IOW I'm largely at a loss to derive error bounds for any of this. There are various uses to put the things to that I'm working through the computational methods for without really much concern for error bounds yet.
00:55:54 <wli> P_D: The promise of all this is that it sort of acts like a multi-centered Pade approximant while at the same time acting as something of a polynomial interpolant.
00:56:34 <P_D> it's something like du/dt = d^2u/dx^2 - u -> du/dt = w^2 u - u -> du/dt = (w^2 - 1)u.  you choose w to be less than 1 by your normalization criterion, so all components descend away except DC
00:58:45 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3502
00:59:07 <P_D> wli:  I can see it being hard.  I seem to recall bounds being derived in terms of the next term in the series.  you have quite a combinatorial explosion of possible next terms
00:59:36 <P_D> add a derivative anywhere, add a point anywhere
00:59:42 <wli> P_D: Yeah.
01:00:58 <wli> P_D: Numerical experiments sort of need to be broader in scope. Ordinary interpolation problems suggest error behavior within the interpolation interval similar to polynomials with the same number of degrees of freedom, except that outside the bounding interval Pade approximant -like extrapolatory behavior holds (which I'm not all that interested in).
01:01:22 <wli> s/bounding/interpolation/
01:02:46 <wli> P_D: I'm basically lacking a general enough computational framework to look for counterexamples where polynomials are thrown off by nearby singularities in the plane while these things hold up.
01:02:58 <ac> P_D: normalizing it to a multiple of the number of cells creates pillars of that multiple that gradually expand
01:03:54 <sclv> found in source of haxml:     blah [st] [v] =
01:03:55 <sclv>         blahblahblah st (text "c0")
01:04:02 <sclv> this can't be best coding practices.
01:04:16 <P_D> well just toss it some functions with conjugate poles close to the real axis
01:05:04 <P_D> something that regular splines would choke horribly on
01:05:05 <sclv> there's a blah and a blahblah too!
01:05:31 <goltrpoat> what do regular splines choke horribly on?
01:05:33 <P_D> ac:  got any pretty pictures?
01:05:53 <wli> What I've done so far is one-offs in Maple thus far. I've only recently (within the past year) hammered out the computational methods.
01:05:59 <P_D> goltrpoat:  functions with a small radius of convergence
01:06:05 <ac> P_D: only the first one was sort of pretty (snd $ propperFraction $ 1.01 * (a + b + c) / 3
01:06:11 <goltrpoat> p_d:  oh, of course
01:06:19 <ac> P_D: and it's basically a greyscale version of the images in that page I linked too
01:06:45 <wli> sech(x)?
01:06:49 <goltrpoat> wli:  you should do a writeup on your pade generalization btw
01:07:13 <wli> goltrpoat: I'm hoping to get a paper out of it if I can muster enough coherent thought on it all.
01:07:24 <goltrpoat> ah cool.  let me know if you do.
01:07:32 <P_D> wli:  nah, just something like 1 / (x-ai+b_j)^n + 1 / (x+ai+b_j)^n for small a and many b_j
01:07:52 <wli> P_D: That's sort of too blatant, though.
01:07:59 <P_D> blatant?
01:08:26 <wli> P_D: Well, it's a rational function.
01:09:01 <P_D> So you had better recover it well...
01:09:03 <wli> sech(x) has poles at pi*i/2 so it'll blow things away as desired.
01:09:22 <P_D> You want to see how it breaks down as the poles get closer to the real axis
01:09:43 <P_D> I think your error bounds will have to include the distance to at least the closest pole
01:10:14 <wli> The closest poles and denominator degrees will factor into it.
01:10:59 <wli> You can't capture more poles than the denominator's degree.
01:11:21 <P_D> can you even capture more than one pole per knot?
01:11:26 <P_D> (experiment)
01:11:43 <wli> Well, bear with me.
01:11:53 <goltrpoat> can someone catch me up with what the conversation is about?  because this seems to be up my alley.
01:12:15 <P_D> error analysis of wli's unspecified magic rational interpolation box
01:12:17 <wli> Assuming the poles are complex conjugate then you basically capture the closest deg(denom) poles.
01:12:23 <goltrpoat> oh
01:13:16 <wli> The next closest pole after that is what screws the rationals over.
01:13:27 <goltrpoat> if it's the same magical rational interpolation box, then it seemed to be quite well specified to me
01:13:27 <wli> Polynomials will get hit immediately by the closest pole.
01:13:40 <P_D> unspecified to me =)
01:14:32 <P_D> wli:  that behavior sounds familiar, the same thing happens when you try to use radius of convergence estimation to take big steps through many terms of a differential equation
01:14:39 <wli> Does my anticipation of the effect of poles on all this sound plausible?
01:14:41 <ac> P_D: here's an interesting one:
01:14:43 <ac> http://img156.imageshack.us/my.php?image=cellularscreenvj3.png
01:14:44 <lambdabot> Title: ImageShack - Hosting :: cellularscreenvj3.png
01:14:50 <ac> sorry I didn't crop it
01:15:06 <ac> cRule2 a b c = snd $ properFraction $ 1.01 * max (a + b) (b + c) / 2
01:15:22 <wli> P_D: I'll take that as a yes.
01:15:41 <P_D> ac: that's very pretty, it looks like one metal dissolving in another; the PDEs are probably related
01:15:50 <P_D> wli: indeed
01:16:50 <ytshen> hi i am a new haskell learner, if i want to join some little open source project, can any one give me soem suggest?
01:17:01 <ytshen> i mean in haskell
01:17:26 <P_D> ac:  why does the growth of a wedge stop?
01:17:39 <P_D> ac: or does time increase downwards?
01:17:53 <TSC> ytshen: xmonad, if you use X11 -- you can write your own modules for it without breaking the main core
01:18:07 <goltrpoat> on an utterly different note, is there a way to derive an interesting type system from temporal logic?
01:18:24 <ac> P_D: it's scrolling up, so yeah time increases downwords. You can see the effect of properFraction
01:18:32 <wli> goltrpoat: I'd expect it to be related to logic programming.
01:18:33 <goltrpoat> i just end up with things that are well-typed some of the time.
01:18:45 <ac> and the max creates the triangles
01:18:49 <goltrpoat> wli:  what isn't? :)
01:19:07 <wli> goltrpoat: Specifically for modelling the effect of making and retracting assertions.
01:19:10 <scook0> is there an unfoldM sitting around anywhere?
01:19:42 <omnId> @hoogle unfoldM
01:19:42 <lambdabot> No matches found
01:20:07 <scook0> hmm, maybe I'll write my function longhand first
01:20:39 <omnId> @type unfoldTreeM
01:20:42 <goltrpoat> wli:  oh sure.  but trying to wedge it into H-M is just not doing anything interesting.  a -> W b?  U a -> b?  we can do something like n -> W (n > 5) b, which brings in a huge amount of typechecking machinery and it's still not useful
01:20:44 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (b -> m (a, [b])) -> b -> m (Tree a)
01:23:54 <goltrpoat> scook0:  do you want (b -> m (a, b)) -> b -> [a]?
01:24:30 <scook0> I ended up writing it without an unfoldM
01:24:38 <scook0> and it's probably clearer that way :)
01:30:35 <ac> http://img88.imageshack.us/my.php?image=rule3ai6.png is "snd $ properFraction $ min (a + b) (b + c) / 1.8"
01:30:36 <lambdabot> Title: ImageShack - Hosting :: rule3ai6.png
01:31:25 <goltrpoat> ac:  where are a,b,c,d coming from?
01:31:58 <ac> goltrpoat: only 3; the previous cell, the previous cell to the left, and the previous cell to the right
01:32:05 <P_D> that's more interesting, something nonlinear now.
01:32:25 <P_D> I would have a hard time constructing the PDE that approximates
01:32:38 <ac> P_D: have any intereseting candidates for rules?
01:32:55 <P_D> how about some transcendental functions?
01:33:16 <P_D> sin^2(a+b) + cos^2(b + c)
01:33:28 <ac> P_D: ooh, interesting
01:34:38 <P_D> I would like to see something with a conservation law for which we could try to compute statistical properties
01:34:46 <wli> tanh(x) = W(x)? (W being Lambert's W, y s.t. y*exp(y) = x)
01:35:49 <P_D> if it were that, why would it be called the lambert function?
01:36:53 <wli> It's named after him.
01:36:57 <wli> NFI why.
01:37:39 <goltrpoat> reminds me (in an utterly unrelated manner) of an idea i had a while back, that i never implemented:  come up with a random group of order n (fun all by itself), fill a grid with pixels of n different colors (256, say), and have each pixel act on its lower-right neighbors at each iteration
01:37:43 <goltrpoat> or something along those lines
01:37:54 <goltrpoat> the idea was that eventually you'd have stuff settle into normal subgroups
01:38:37 <P_D> they're clearly not the same
01:38:42 <P_D> your function is unbounded
01:39:30 * wli devised a locking algorithm based on a group derived from various antichains in the NUMA memory topology graph.
01:41:25 <wli> It was in part an effort to participate in a software patent initiative going on within IBM at the time.
01:41:41 <asmanur> Does Control.Monad.Error.Class exist in  ghc ? (it seems that i have no such file :()
01:41:51 <ac> http://img508.imageshack.us/my.php?image=sincosht9.png is "cRule4 a b c = sin (a + b) ^ 2 + cos (b + c) ^ 2"
01:41:52 <lambdabot> Title: ImageShack - Hosting :: sincosht9.png
01:41:58 <ac> P_D: it stabalizes pretty quickly after that
01:42:26 <wli> There was little or no interest in pushing that patent along. Instead, some random question (I presumed for homework for grad school or similar) I answered for some guy in a neighboring cube snowballed into a patent.
01:42:26 <goltrpoat> wli:  oh those :)
01:43:08 <wli> I was thoroughly appalled. All the effort and originality went right down the toilet and instead total triviality got patented.
01:43:12 <P_D> ac:  ugly!
01:43:18 <goltrpoat> i worked at a company where the CEO (total lunatic) devised a per-patent scheme at some point
01:43:43 <goltrpoat> if your work results in a patent, you get some silly bonus.
01:43:56 <wli> goltrpoat: IBM had that and a lot more, including little rewards for each step of the way toward getting a patent.
01:43:58 <P_D> ac:  weird that there are different slopes in the picture
01:44:11 <goltrpoat> so i made sure to describe all of my work to everyone i knew outside the company, to make sure it didn't result in a patent
01:44:20 <ac> P_D: that's starting with a random initial condition. I'm going to try to start that with two points
01:44:35 <goltrpoat> luckily, the company imploded a year later, so i didn't get sued.
01:45:07 <wli> goltrpoat: Even that wasn't enough to convince people to hammer out patents, so there were "PR campaigns" of sorts internal to IBM to convince people to file for patents as much as possible.
01:45:49 <Adamant> how much does IBM make a year on patents? something insane, I believe.
01:46:00 <Adamant> $2 billion or so.
01:46:13 <wli> Adamant: Not really sure. It was just a big deal while I was still there.
01:46:13 <goltrpoat> actually, i think that might be about right
01:46:55 <goltrpoat> i wouldn't normally know this, but with this patenting-patent-trolls-patent thing going on, i see a lot of figures being published
01:47:01 <Adamant> yeah. at this point the patent system needs to either die or be totally scrapped and rewritten for the modern age.
01:47:07 <wli> goltrpoat: Anyhow, I was gung-ho enough to actually try to participate in it until the travesty with the homework problem patent going through while the stuff that actually required work and thought didn't even get off the ground.
01:48:24 <goltrpoat> wli:  in my case, no one ever collected the bonus -- i was in the R&D group, and we actually did do some good work, and came up with a lot of new stuff.  no one there was particularly excited about having their work patented in the company's name though, and no one higher up had any clue what was important work and what wasn't
01:49:46 <goltrpoat> one of my partners in my current company though, was unwittingly responsible for starting the biggest patent war in my industry
01:49:57 <goltrpoat> or.. the most publicised one anyway
01:50:33 <goltrpoat> so we're all a little jumpy at this point.
01:50:48 <goltrpoat> i just hope someone at the patent office suddenly gets a ginormous infusion of clue.
01:52:19 <wli> goltrpoat: One of the reasons there was so little interest in my algorithm is that it was largely generalizing locking algorithms to cases where topologies were non-hierarchical, asymmetrical, and highly irregular. The interest in systems of that sort was negligible at the time.
01:53:53 <wli> goltrpoat: Well, it was more like generating an anti-starvation-oriented handoff scheduling policy from a topology description than an algorithm per se, but anyway.
01:55:24 <TSC> Isn't an anti-starvation algorithm exactly what you need now? (:
01:55:29 <goltrpoat> i forgot, you used to be a kernel guy, right
01:55:41 <wli> goltrpoat: It's also literally true that there has never been a system made that would've actually used all its properties at once.
01:55:48 <wli> goltrpoat: Still am.
01:55:53 <goltrpoat> or.. hell.  i think i've known you for a good 5 years now, i still have no clue what you do :)
01:56:27 <wli> goltrpoat: Rather, it was more that it could've been used on any of a collection of systems each having some radical assumption-breaking property.
01:57:35 <wli> goltrpoat: None of which were made by IBM. It could also have been used on a system with all those properties simultaneously, but nothing of the sort has ever been made and no one's ever had plans to make such even to this day.
01:58:16 <goltrpoat> is this in any way related to cardelli's agent stuff?
01:58:29 <goltrpoat> i'm having trouble placing what you're talking about.
01:58:46 <wli> goltrpoat: No. It's all ugly low-level systems crap. It's locking stuff like spinlocks, MCS locks, etc.
01:59:21 <goltrpoat> so you're talking about low-level scheduling given a network topology?
01:59:37 <goltrpoat> with some traditional system on top?
02:00:18 <P_D> there's a new computational cosmology group at LBL looking for programmers to make their ~10k processor computers cook
02:00:21 <wli> goltrpoat: Yeah. When releasing a lock, who you hand it off to next. The system on top is sort of not relevant but a traditional system is largely expected.
02:00:34 <goltrpoat> ah right, i see what you're saying.
02:01:02 <wli> goltrpoat: One can, in principle, run number crunching stuff on the bare metal and do all the low-level system poking and prodding yourself, including locking stuff like I'm on about.
02:02:29 <wli> P_D: It's very doubtful they've concocted a system that would need anything like what I did. And it's more so that the kernel (or executive) can adapt to radically different topologies without prior knowledge, which doesn't really happen either.
02:03:01 <P_D> yes, they are looking for people who can abstract away the work of writing parallel apps.
02:03:42 <wli> P_D: Also HPC is very much its own affair. It's not general systems programming. And it also involves a lot of userspace, of which I'm completely ignorant.
02:04:00 <P_D> M'k
02:04:43 <P_D> they came down to present their work so far.  stuff like a library to read 100TB datasets.
02:04:51 <LeCamarade> ?src hashString
02:04:51 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:05:05 <LeCamarade> ?src Data.HashTable.hashString
02:05:05 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
02:05:24 <LeCamarade> Anybody know which algo dem a use in-a de hashString?
02:06:01 <wli> P_D: I can see the Linux kernel breaking down under such stress, at least in terms of degenerate performance. I don't have any idea whether they're using Linux.
02:06:06 <roconnor> @hoogle RInt
02:06:07 <lambdabot> Char.isPrint :: Char -> Bool
02:06:07 <lambdabot> IO.hPrint :: Show a => Handle -> a -> IO ()
02:06:07 <lambdabot> Prelude.print :: Show a => a -> IO ()
02:06:14 <wli> P_D: Odds are they'll need superpages, too.
02:07:26 * P_D shrugs
02:07:42 <P_D> the experiment I'm working on is tiny, will only be ~10TB of data =)
02:08:22 <wli> P_D: What kernel?
02:08:34 <P_D> They didn't say!
02:08:39 <roconnor> Can I use darcs to ``diff'' two branches
02:08:47 <roconnor> telling me which patches differ?
02:08:51 <P_D> I think there are many
02:08:52 <wli> P_D: Linux, Solaris, IRIX, UNICOS?
02:09:09 <P_D> They have 6 computers, I think one or so every 2 years
02:09:10 <wli> P_D: Windows?
02:09:18 <sjanssen> roconnor: darcs pull --verbose, perhaps?
02:09:20 <P_D> Each is probably set up completely differently.
02:11:02 <roconnor> sjanssen: hmm
02:11:20 <roconnor> sjanssen: I don't want to see the diffed code
02:11:34 <roconnor> sjanssen: for the moment just the descriptions of patches in one but not the other would do
02:11:42 <sjanssen> roconnor: it should spit out something like "New to them", "New to us" before starting the interactive pull
02:12:34 <P_D> The oldest is AIX
02:12:42 <roconnor> oh
02:12:50 <P_D> one of the newers ones is linux
02:13:28 <P_D> peak: 1.5GFlops vs 3.3 TFlops
02:24:16 <LeCamarade> Dear God, the GHC in Fink is horridly-old. 6.4.
02:24:55 <gabor> LeCamarade: switch to macports :-)
02:25:17 <LeCamarade> I failed to get MacPorts running on this here box.
02:25:26 <LeCamarade> It's old as they come. iMac G3.
02:25:35 <LeCamarade> PowerPC. Slow as melting.
02:25:43 <KatieHuber_> 10.4?
02:25:53 <LeCamarade> I don't even have room for Xcode, so I can't compile.
02:25:57 <LeCamarade> Yes, 10.4
02:26:01 <KatieHuber_> MacPorts like to break on anything but the latest and greatest in my experience
02:26:02 <KatieHuber_> :o
02:26:11 <KatieHuber_> well macports won't work without xcode :p
02:26:28 <LeCamarade> And 10.4 feels really heavy on such an old box.
02:26:57 <gabor> yep. it works on my pre-tiger Mac mini, though
02:27:02 <LeCamarade> Network.CGI is so old, and yet I may need to dabble about with it.
02:27:13 <KatieHuber_> one of my friends likes to run it on a G3 powerbook 266, and he claims it's the fastest Mac OS ever :)
02:27:53 <KatieHuber_> gabor: are we in all the same channels?
02:27:57 <LeCamarade> Mine feels like an ENIAC. But it's part of the joy. It should be home for composing essays and the like. Not making GHC. :o)
02:28:44 <gabor> KatieHuber_: if your list contains #llvm and #gcc too, then yes
02:29:51 <KatieHuber_> #llvm is what I was referring to
02:31:04 <gabor> there are interesting coincidences all the time. like MonkeyPox telling that he speaks German and Hungarian (same for me)
02:31:38 * KatieHuber_ wonders if MonkeyPox is the same as TheMonkey, who also speaks those languages :|
02:32:11 <KatieHuber_> and also hangs out in #llvm on occasion
02:32:21 <gabor> and you are a kiwi (I have some friends in DU)
02:33:02 * wli attempts to figure out the Wronskian determinant of of x^m*e^(n*x) for 0 <= m <= M and 0 <= n <= N (call it W_{M,N}).
02:33:14 <KatieHuber_> did you come to the dylan hackers' "conference" when it was in wellington?
02:33:21 <gabor> yep
02:33:31 <KatieHuber_> thought so
02:33:37 <KatieHuber_> was it you with the pickles?
02:33:38 <gabor> fun time
02:34:09 <gabor> pickles (for eating or serializing)?
02:34:13 <KatieHuber_> the former
02:34:31 <KatieHuber_> one of the two of you imports had a big jar of pickles to eat
02:34:32 <P_D> wronskian tensor?
02:34:37 <gabor> possibly (I love them, esp. the water)
02:34:54 <P_D> or are you going to drop one of those parameters
02:35:36 <wli> P_D: It's just a doubly-indexed collection of functions to find the Wronskian determinant (a scalar function of a scalar variable) of.
02:36:00 <P_D> fair enough
02:36:27 <P_D> e^(x^n) m x^(m-1) + e^(x^n) n x^(m + n - 1)
02:36:34 <P_D> for the first row.
02:36:50 <P_D> I don't think there's a nice rule for the jth row.
02:37:41 <wli> I think induction on each index separately ends up being necessary.
02:51:04 <wli> W_{0,N} seems to be V_{N+1}*e^(N*(N+1)*x/2) where V_N is the Vandermonde determinant with x_k = k for 1 <= k <= n.
02:53:33 <wli> W_{M, 0} seems to be just V_{M+1}.
03:00:42 <wli> Now for W_{M+1,N} and W_{M,N+1}... and to write Haskell functions to compute them. ;)
03:15:03 * desegnis wonders what is the best way to understand the Miller/Myers diff algorithms
03:15:51 <wli> desegnis: I'd be far more concerned about patching algorithms to apply such diffs as they're far harder and less well-understood.
03:16:57 <desegnis> wli, your statement surprises me, actually
03:17:14 <wli> How and why?
03:18:29 <desegnis> I imagine a patch to be a mere receipt that is no sweat to apply, while for a diff algorithm you have to contemplate what is the best way to find the shortest/best diff
03:18:39 <roconnor> @seen ski
03:18:40 <lambdabot> ski is in ##logic, #haskell-overflow and #haskell. I last heard ski speak 16h 29m 38s ago.
03:19:11 <wli> No way. Patching is complete voodoo once you get to guessing how to get around various sorts of conflicts, fuzz, offsets, and so on.
03:19:53 <wli> There aren't even real algorithms for any of it. It's 100% heuristics.
03:20:34 <desegnis> My /usr/bin/patch is voodoo? Mummy!
03:20:56 <wli> Very much so. There are no books to help you here.
03:21:51 <desegnis> Still, if you say so, it should be better for me to look at diffing first, where there are books to help me.
03:21:58 <wli> And this is Larry Wall's code we're talking about.
03:22:48 <wli> No one else has repeated the effort in part because it's very hard, and also in part because of the nature of the original code.
03:23:15 <wli> (i.e. nasty, unreadable, etc.)
03:23:27 <roconnor> @tell ddarius I see about a 20% speed increase by using DNAMonadCPS.
03:23:27 <lambdabot> Consider it noted.
03:24:16 <desegnis> I now realize, Larry Wall is the one with the Perl language... Really, that does not trigger me to look at the patch sources
03:24:40 <roconnor> Um, I suppose I should check if I get the right answer
03:26:33 <desegnis> wli: I'd suppose that RCS authors do have repeated the effort?
03:27:24 <goltrpoat> wli:  well, i'd amend the "100% heuristics" bit with david roundy's work
03:27:41 <wli> designis: AFAICT most invoke it externally.
03:28:14 <wli> designis: There are exceptions I know little about (darcs as goltrpoat mentioned?).
03:28:59 <Botje> yay
03:29:03 <Heffalump> darcs runs lcs internally to calculate it's own "diff-like" thing, and only ever uses exact application
03:29:10 <Heffalump> which doesn't require any cleverness
03:29:16 <Botje> -O2 brought my silly bubblesort from 15s to 10s
03:30:01 <desegnis> Ah. I suppose my lack of understanding for the hardness of patching is related to Heffalump's comment on exact application?
03:30:30 <Heffalump> exact application is just trivial, since you have line numbers
03:30:49 <Heffalump> patch tries to get clever when a diff doesn't exactly apply, i.e. when the source has changed
03:31:10 <desegnis> Ah. That makes sense to me now
03:31:11 <Heffalump> whereas darcs keeps track of the other changes and uses commutation to be "clever" - but that's not approximate, it's well-defined.
03:31:58 <roconnor> gee, writing output take so much longer!
03:33:39 <roconnor> but the output is correct
03:33:44 <desegnis> I actually considered just reading Darcs' Lcs.lhs instead of reading Myers' online paper (which is written very concise, but not always very exact), but the first function in there spans two and a half pages on printed paper and scared me off
03:33:57 <roconnor>  mapM_ (putChar . toEnum . fromIntegral) is sooo slow.
03:34:50 <roconnor> maybe I can enable buffering
03:34:56 <roconnor> @hoogle buffer
03:34:56 <lambdabot> System.IO.BufferMode :: data BufferMode
03:34:57 <lambdabot> Network.Socket.RecvBuffer :: SocketOption
03:34:57 <lambdabot> Network.Socket.SendBuffer :: SocketOption
03:35:06 <roconnor> @hoogle BufferMode
03:35:07 <lambdabot> System.IO.BufferMode :: data BufferMode
03:35:19 <roconnor> @hoogle BufferMode -> IO ()
03:35:19 <desegnis> roconnor: Probably it's slow because of the many uses of putChar?
03:35:19 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
03:35:36 <roconnor> desegnis: is there any way around using putChar?
03:35:58 <KatieHuber> maybe you could putStr $ foldl (:) [] $ map (toEnum . fromIntegral) $ list
03:36:03 <desegnis> roconnor: There should be
03:36:23 <roconnor> KatieHuber: that could be a good idea
03:36:42 <KatieHuber> er, last $ definitely unnecessary :|
03:37:20 <roconnor> KatieHuber: any reason for the foldl?
03:37:35 <desegnis> foldl (:) [] is a type error
03:38:00 <roconnor> I'm thinking putStr $ map (toEnum . fromIntegral) x
03:38:20 <desegnis> roconnor: That's what I had had in mind, I only didn't dare to write it out
03:38:55 <qwr> foldr (:) ...
03:39:20 <roconnor> foldr (:) [] = id
03:39:42 <roconnor> I wonder if -O2 would do that.
03:39:42 <Saizan> in ByteString they use (chr . fromEnum), not sure if it changes anything
03:40:09 <roconnor> Saizan: I expect chr and toEnum to compile to the same thing ... I hope
03:40:29 <Saizan> ?src fromIntegral
03:40:29 <lambdabot> fromIntegral = fromInteger . toInteger
03:40:30 <desegnis> Well, chr is more specific in its type than toEnum, and fromEnum is more general in its type than fromIntegral
03:40:36 <KatieHuber> roconnor: yeah, the reason was my not thinking cleary ;)
03:40:40 <KatieHuber> *clearly
03:41:02 <desegnis> So it's more a question of programming Zen, I s'pose
03:41:15 <Saizan> ?type fromIntegral
03:41:17 <lambdabot> forall a b. (Num b, Integral a) => a -> b
03:41:24 <Saizan> ?type fromEnum
03:41:26 <lambdabot> forall a. (Enum a) => a -> Int
03:41:33 <Saizan> more general?
03:42:00 <oerjan> @src Integral
03:42:01 <lambdabot> class  (Real a, Enum a) => Integral a  where
03:42:01 <lambdabot>     quot, rem, div, mod :: a -> a -> a
03:42:01 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
03:42:01 <lambdabot>     toInteger           :: a -> Integer
03:42:08 <desegnis> Saizan: er, in its first parameter only
03:43:13 <desegnis> I meant, in the type of the input (a)
03:43:18 <roconnor> desegnis: chr require another import :)
03:43:38 <bparkis> is Purely Functional Data Structures by Chris Okasaki a good book?
03:43:59 <roconnor> Damn, putStr is way faster
03:44:04 <roconnor> *sigh*
03:44:08 <roconnor> my contest code sucks
03:44:20 <roconnor> it lots of little easy to fix ways
03:44:23 <ricky_clarkson> :t fringe
03:44:25 <lambdabot> Not in scope: `fringe'
03:44:50 <roconnor> @tell KatieHuber Thanks, the putStr code is way faster.
03:44:51 <lambdabot> Consider it noted.
03:45:03 <roconnor> @karma+ KatieHuber
03:45:04 <lambdabot> KatieHuber's karma raised to 1.
03:45:24 <roconnor> ddarius++ and ski++ while I'm at it
03:45:43 <oerjan> @karma
03:45:44 <lambdabot> You have a karma of 7
03:49:58 <roconnor> I still have a long way to go to catch up to the speed of at lisp code
03:51:14 <abell> Does anybody know how to save a CalendarTime into a timestamp field with HDBC? Using Database.HDBC.PostgreSQL seems to force it into an integer before passing it to the database, which raises an error.
03:51:34 <abell> Namely, -> Cannot read "2007-10-28 11:46:20" as Integer <-
03:52:50 <abell> Oops, sorry. Wrong error. It's actually: -> invalid input syntax for type timestamp with time zone: "1193562900"
03:54:06 <yitz> I'm not up on HDBC, but I need to learn. How did you "force it into an integer before passing it to the database"?
03:55:01 <yitz> Rather, how did you "pass it into the database" (which then forced it into an integer)?
03:55:37 <abell> The driver forces it. I pass a "toSql ct", where ct is a CalendarTime, and then call the quickQuery function from Database.HDBC
03:55:56 <Saizan> abell: what does show ct gives?
03:57:02 <abell> It should be something like "CalendarTime {ctYear = 2007, ctMonth = October, ctDay = 28, ctHour = 11, ctMin = 58, ctSec = 2, ctPicosec = 195360000000, ctWDay = Sunday, ctYDay = 300, ctTZName = "CET", ctTZ = 3600, ctIsDST = False}"
03:58:02 <abell> But somehow in the way from the CalendarTime to SqlValue to the db, it gets converted into an integer, which postgresql rejects, expecting a timestamp
03:58:58 <Saizan> abell: i think you've to write a function CalendarTime -> String yourself and compse it with SqlString to get a SqlValue
04:02:46 <abell> That's what I did, but then I get the other error -> fromSql: Cannot read "2007-10-28 11:46:20" as Integer <- which probably means I also need to write a parser :-(
04:03:15 <Saizan> yes
04:03:42 <abell> Do you know how I should override fromSql and toSql just for CalendarTimes, leaving it the same for all other types?
04:03:53 <Saizan> and you can use a newtype of CalendarTime to put both in a SqlType instance
04:04:24 <Saizan> this way ^^^ :)
04:04:29 <bparkis> code that doesn't talk directly to other code is more abstract
04:04:32 <abell> :-)
04:05:12 <yitz> mmm... quick look at HDBC haddocks... looks like there should be some way to just supply something to toSql and get an SqlEpochTime, which sounds like what you want. Question is - which type?
04:05:25 <bparkis> a part of a program that does a lot of interaction with domain specific modules and libraries is less abstract in relation to those modules and libraries
04:05:35 <bparkis> more coupled to them
04:06:10 <abell> yitz, actually that's what toSql :: CalendarTime -> SqlValue does
04:06:26 <abell> but then the database receives an integer and not a timestamp
04:06:33 <yitz> or is supposed to...
04:06:57 <yitz> The postgresql driver is supposed to do that, no?
04:06:59 <Saizan> yitz: it's easy to check, show $ toSql ct
04:07:29 <bparkis> a part of abstraction is separating one block of code from another so that they depend on each other less
04:08:10 <abell> Saizan, getClockTime >>= toCalendarTime >>= return . toSql  shows  SqlEpochTime 1193569722
04:09:44 <bparkis> in fact i can't think of an example of abstraction off the top of my head that does not involve reducing the dependency of one block of code on another
04:10:37 <yitz> abell: that looks right
04:11:07 <yitz> so the problem appears to be with the postgresql driver, not toSql.
04:12:26 <abell> yitz, yes it seems the driver doesn't turn the SqlEpochTime back into the date-time format which the db expects
04:13:26 <abell> So I have to resort to tricks to perform the conversion myself along the way
04:14:24 <Saizan> is the driver supposed to do that conversion? and how does it know that you've a TIMESTAMP field and not an INT?
04:15:15 <abell> either by making my own SqlType class or boxing the CalendarTime into a NewType
04:15:19 <yitz> Saizan: the docs seem to claim that this is supported/
04:15:50 <Saizan> abell: yes ok, i was wondering if the driver is to blame
04:15:50 <abell> Saizan, I suppose that a SqlEpochTime converts more "naturally" into a timestamp than into an int
04:16:58 <abell> Maybe I should just convert all my timestamp columns into integers...
04:17:42 <yitz> abell: if you want actual pg timestamps, sounds like you'll have to format them yourself and pass them as SqlString.
04:17:58 <abell> but as today we swapped back to winter time in Italy I am particularly sensitive to the time-saving issues :-)
04:18:24 <abell> yitz, I think that's what I'll do
04:19:34 <abell> Thanks everybody for the help
04:20:12 <yitz> I would also post a note to the cafe about this. Either we are missing something, or this ought to be fixed.
04:20:30 <Saizan> abell: sei invitato su #haskell.it allora :)
04:21:13 <abell> Saizan, grazie :-)
04:27:37 <abell> yitz, suggestion noted. But now I have to solve the problem asap, because my project is due tomorrow and I can't show off my Haskell skillz if my app doesn't work :-)
04:28:11 <yitz> abell: know the feeling :) good luck!
04:29:32 <abell> Thanks. I am confident I will make it :-)
04:29:52 <abell> After all, winter time gives me one more hour to work :-))))
04:30:43 <yitz> we programmers always burn up that hour fixing bugs in programs that deal with times. :)
04:31:16 <abell> yitz: lol
04:31:53 * yitz notes that after a month, clock in car still shows summer time
04:46:49 <ricky_clarkson> :t fix
04:46:54 <lambdabot> forall a. (a -> a) -> a
04:47:06 <ricky_clarkson> @src fix
04:47:06 <lambdabot> fix f = let x = f x in x
04:47:37 <ddvlad> > fix abs
04:47:40 <lambdabot>  Exception: <<loop>>
04:48:59 <ricky_clarkson> I don't understand fix's source.
04:50:18 <ddvlad> hmm... it seems me neither
04:50:39 <scook0> an easier-to-grasp version is:
04:50:48 <scook0> fix f = f (fix f)
04:51:03 <TSC> > fix (1:)
04:51:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:51:37 <wilx> > fix (+ 1)
04:51:38 <lambdabot>  Exception: <<loop>>
04:51:47 <wilx> > fix (+ 1) 1
04:51:47 <lambdabot>   add an instance declaration for (Num (t -> a))
04:51:49 <ac> how do you take fractional exponents?
04:52:05 <ricky_clarkson> Presumably at some point it has to decide on an argument to pass to f.
04:52:24 <Saizan> > let fac f n = if n == 0 then 1 else n * f (n-1) in fix fac 5
04:52:25 <lambdabot>  120
04:52:58 <ac> like square roots, cube roots, etc
04:53:24 <xerox> :t ((^),(^^),(**))
04:53:26 <lambdabot> forall a b a1 b1 a2. (Integral b, Num a, Integral b1, Fractional a1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
04:53:47 <xerox> the third one
04:53:48 <Saizan> fix fac 5 = fac (fix fac) 5 = 5 * (fix fac) (n-1) = 5 * fac (fix fac) (n-1) = ...
04:53:55 <ac> xerox: thanks
04:54:04 <xerox> you're welcome
04:54:15 <ricky_clarkson> Saizan: then how does the base case happen?
04:54:50 <scook0> ricky_clarkson: take the example of (1:) ... there is no base case!
04:55:14 <scook0> it's up to the consumer to not force the entire (infinite) lazy list
04:55:15 <Saizan> ... = 5 * 4 * 3 * 2 * 1 * fac (fix fac) 0 = 5 * 4 *3 *2 *1 * 1
04:55:40 <xerox> what is the list which is the same if we append a 1 on top of it? the infinite list of ones!
04:55:51 <Saizan> ricky_clarkson: with fix you can either produce an infinite value with no base case, or the base case will discard the first argument of the function you fix
04:56:59 <ricky_clarkson> Do the first argument and the return type have to be the same?
04:57:01 <ricky_clarkson> :t fix
04:57:03 <lambdabot> forall a. (a -> a) -> a
04:57:08 <ricky_clarkson> ..yes :)
04:58:06 <Saizan> in the case of fac, a = Int -> Int
04:58:18 * roconnor ponders why CPS style is more efficent
04:58:21 <oerjan> > fix (const True)
04:58:22 <lambdabot>  True
04:58:51 <scook0> > fix (True ||)
04:58:53 <lambdabot>  True
04:59:28 <pjd> ricky_clarkson: i visualize it as fix f --> f (fix f) -> f (f (fix f)) -> f (f (f (f ...)))
04:59:29 <ricky_clarkson> > fix (False ||)
04:59:31 <lambdabot>  Exception: <<loop>>
05:00:06 <ricky_clarkson> pjd: I can see that working for infinite loops, but not for bounded ones like fac.
05:00:26 <oerjan> fix f = undefined <=> f undefined = undefined, i think
05:00:29 <pjd> i.e., forget about the fix;  f just gets called with an infinite "supply" of copies of itself
05:00:42 <Saizan> the point is that (fix f) is expanded only when needed due to lazy eval
05:00:56 <pjd> Haskell evaluation is from the outside in, so evaluation starts at the outer f
05:01:06 <ricky_clarkson> I'm testing out a prototype Java 7 compiler, and thought this would be a good test case.  Turns out my brain fails it.
05:01:48 <Saizan> ricky_clarkson: is java 7 lazy?
05:01:49 <pjd> which can choose whether to "use" an f (recursing), or return something else
05:01:53 <pjd> (the base case)
05:02:10 <ricky_clarkson> Saizan: No.  Would I need laziness to make fix fac 5 work?
05:02:26 <Saizan> yes, with this definition of fix
05:02:35 <ricky_clarkson> Ah.
05:02:59 <Saizan> there are other fixed point combinators for eager evaluation
05:03:15 <ricky_clarkson> I know one, but it doesn't work in Java or Haskell.
05:03:20 <ricky_clarkson> Infinite types..
05:03:32 <ricky_clarkson> \f x -> f f x
05:04:24 <opqdonut> there is no fixed point combinator that has a non-infinite type
05:04:32 <opqdonut> in strictly typed lambda calculus that is
05:04:54 <opqdonut> that's why recursion has to be brought from the "outside", i.e. with recursive let or a combinator
05:05:47 <ac> what's a function that causes a non linear increase and works for values under 1?
05:06:06 <wli> cosh
05:06:19 <oerjan> exp
05:06:41 <ac> oerjan: exp will cause a nonlinear decrease for values under 1
05:06:59 <wli> ac: What?
05:07:02 <oerjan> huh? exp x > x for all real x
05:07:30 <ricky_clarkson> @check \x -> exp x>x
05:07:33 <ac> oerjan: oh, I was thinking exp == exponent
05:07:37 <lambdabot>  Add a type signature
05:07:52 <ricky_clarkson> @check \x -> exp (x :: Double)>x
05:07:55 <ac> as in squaring
05:07:57 <lambdabot>  OK, passed 500 tests.
05:08:12 <opqdonut> ac: well if it's even then yes
05:10:02 <ddvlad> is it possible to integrate haskell and c? if so, how easy is it?
05:10:12 * ac needs to pound some elementary mathematics into his skull
05:10:20 <oerjan> @where ffi
05:10:20 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
05:10:31 <oerjan> ddvlad: ^^
05:10:42 <ddvlad> oerjan: thank you
05:11:25 <roconnor> > expo 0
05:11:26 <lambdabot>   Not in scope: `expo'
05:11:28 <roconnor> > exp 0
05:11:29 <lambdabot>  1.0
05:11:54 <roconnor> @check \x -> exp (x :: Double) - 1 > x
05:11:56 <lambdabot>  Falsifiable, after 1 tests: 0.0
05:11:59 <roconnor> @check \x -> exp (x :: Double) - 1 >= x
05:12:00 <lambdabot>  OK, passed 500 tests.
05:13:29 <ac> "a + (exp a - a) / 100" works pretty well
05:14:07 <snhmib> hey i have a question... i'm just learning haskell, and reading an article about how to make graphs in haskell
05:14:36 <wli> snhmib: An article where?
05:14:37 <snhmib> and they have a type Vertex, and they said it can be any kind of thing that belongs to the index class
05:15:30 <snhmib> but i'm not sure how to say that in haskell... i can do type Vertex = Int, or type Vertex = char, but can i do 'both at the same time'?
05:15:35 <snhmib> wli 1 sec
05:15:59 <snhmib> www.cse.ogi.edu/~jl/Papers/dfs.ps
05:16:28 <wli> snhmib: I thought it was in some publication.
05:18:03 <byorgey> snhmib: you need to learn about type classes.
05:19:09 <byorgey> snhmib: I'd suggest reading about them in some tutorial or in the wikibook.
05:19:56 <snhmib> ok =)
05:21:28 <byorgey> snhmib: or you could just go straight for the Haskell 98 report =)
05:23:54 <snhmib> heh
05:39:30 <vincenz> lo
05:52:01 <ricky_clarkson> Can anyone tell me in less than 5000 words what disjunctive types are?
05:53:35 <ricky_clarkson> Everything I read about them seems to jump from conversational to full-on maths complete with Greek symbols without me grasping it.
05:55:54 <therp> ricky: think of union types in C
05:56:10 <therp> oh maybe I'm confusing disjunctive, and sum types..
05:56:26 <therp> but disjunctive sounds similar.
05:56:31 <Heffalump> I thought they were just sum types.
05:57:38 <Philippa> ricky_clarkson: roughly speaking, "this OR that" - as opposed to conjunctive types ("this AND that", better known to most people in here as tuples)
05:59:05 <ricky_clarkson> Philippa: Thanks.
06:01:46 <ac> I'm not sure if anyone's around from when I was initially fooling with this, but this one's pretty interesting: http://img528.imageshack.us/my.php?image=rule4lo8.png
06:06:38 <pjd> ricky_clarkson: algebraic data types (as in Haskell etc.) are all disjunctions of conjuctions, or conjuctions of disjunctions
06:07:23 <byorgey> ac: I have no idea what that is, but it's freakin' awesome. =)
06:07:50 <ac> byorgey: continuous 1D cellular automata
06:07:53 <therp> ac: looks like a cellular automata
06:08:10 <ac> (with a funky function)
06:08:11 <pjd> ricky_clarkson: the type of (proper) lists: List a = Cons a (List a) | Nil
06:08:28 <therp> ac: I have "a new kinds of science" on my book shelf, half read, but I never never seen a drawing like this. really nice
06:08:39 <therp> s/ds/d/
06:08:40 <ac> therp: I would not recommend reading most of that book
06:08:43 <pjd> is a a disjunction of Nil and a conjuction of a and List a
06:08:47 <therp> ac: why not?
06:08:54 <pjd> s/is a/is/
06:09:06 <ac> therp: I'd recommend reading sellected portions
06:09:09 <therp> ac: except that it's trying to see cellular automata everywhere
06:09:10 <ricky_clarkson> The particular case the term was used for, though the context wasn't aparent, is for catching multiple exceptions at once in a prototype for Java.
06:09:32 <ricky_clarkson> catch (Blah | Other e).  It doesn't seem to have been extended to things other than exceptions, sadly.
06:09:41 <therp> ac: any reason, except that it might be a waste of time?
06:09:49 <ac> therp: of course not
06:09:59 <ac> here's the function for that picture...
06:10:00 <EvilTerran> ac, do you know the function for that automaton? i'm intrigued
06:10:01 <ac> cRule4 a b c = if elem True $ map ((>0.2).abs) [a-b,a-c,b-c] then ((min a b) + (min (max a b) c)) / 2.04 else let avg = (a + b + c) / 3 in avg + (exp avg - avg) / (500 * (avg / 3)
06:10:02 <EvilTerran> ah.
06:10:26 <EvilTerran> (elem True) = or, surely?
06:10:45 <therp> ac: generated with haskell?
06:10:47 <therp> neat :)
06:11:00 <ac> therp: of course :). I'm using HOpenGL to smoothly scroll it continuously
06:11:05 <WillyTheDisk> Is there a fastCGI module for Haskell?
06:11:32 <Japsu> @go haskell fastcgi
06:11:33 <ac> You can create interesting variations by adjusting "0.2", "2.04" and "500"
06:11:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fastcgi
06:11:44 <ac> oops, I don't actually have "(avg / 3)" in there. that does something weird
06:11:59 <WillyTheDisk> Thanks, Japsu
06:12:57 <hpaste>  ac annotated "Cellular automata + OpenGL" with "Now with continuous rules" at http://hpaste.org/3499#a1
06:13:34 <EvilTerran> ac, "elem True $ map p xs" looks to be "any p xs", btw
06:14:21 <Heffalump> and anyway elem True == or
06:15:10 <ac> EvilTerran: much better :)
06:47:03 <roconnor> can't load .so/.DLL for: Xmu (libXmu.so: cannot open shared object file: No such file or directory)
06:47:36 * roconnor install libxmu-dev
06:47:45 <roconnor> ... not sure what it is
06:47:51 <roconnor> or why it is reqiured
06:48:06 <bartw> error message is a bit redundant
06:48:20 <roconnor> freeglut (foo.hs): Unable to create direct context rendering for window 'cellular'
06:48:20 <roconnor> This may hurt performance.
06:48:25 <bartw> can't load -> cannot open -> file not found
06:48:57 <roconnor> ooh, pretty serpinski gasket
06:49:03 <roconnor> slow and flickery
06:50:06 * roconnor wonders how to give it a direct context rednering
06:51:00 <roconnor> ah
06:51:46 <ac> roconnor: the continuous one is a lot more interesting
06:52:03 <roconnor> ac the end of the paste seemed cut off
06:52:25 <roconnor> ac: do you have the same direct context rendering warning?
06:52:29 <ac> roconnor: oh you're right. but the end isn't changed
06:52:38 <ac> roconnor: no, it's nice and smooth on my machine
06:53:35 <roconnor> :(
06:54:12 <roconnor> ac: Prelude.(!!): index too large
06:54:28 <ac> roconnor: ah it's a little hacky right now. You need two arguments
06:54:34 <ac> roconnor: the first is discarded, and the second is the random seed
06:55:26 <ac> at some point I'll probably add colors, and more interactivity, like being able to insert cell values with the mouse, and changing the parameters of the rules in real time
06:59:53 <ac> roconnor: any luck?
07:06:42 <roconnor> ac: yeah it works
07:06:54 <ac> roconnor: let me know if you come up with some interesting rules
07:07:05 <roconnor> I was just browsing to figure out how to enable direct redering for my laptop
07:08:17 <roconnor> ``The driver supports hardware accelerated 3D via the Direct Rendering Infrastructure (DRI), but only in depth 16 for the i810/i815
07:08:23 <roconnor> WTF?
07:08:30 <roconnor> is my computer from the bronze age?
07:10:09 <ac> roconnor: lol, I have an intel 945
07:40:15 <roconnor> @source Control.Monad.Cont
07:40:15 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Cont.hs
07:40:45 <roconnor> ahhhh firefox!!!
07:40:56 <roconnor> just show me the darned file!
07:41:32 <Saizan> the server should set content-type: text/plain for .hs files
07:42:02 <LoganCapaldo> text/haskell ;)
07:42:07 <mauke> no, firefox should be fixed
07:42:50 <flux> so it should display whatever unknown mime type it encounters as a web page? well, actually, an option to do so would be nice, it has the dialog already..
07:43:20 <mauke> no, it should let you set the handling for mime types
07:43:29 <mauke> or rather, include "display as text/plain" in the mime options
07:43:44 <roconnor> mauke: I'll give you 20 euros to fix it. :)
07:43:53 <roconnor> we can start a pool
07:44:22 <wli> What's that today? $50?
07:44:30 <wli> (50 USD)
07:45:09 <mauke> 1 EUR makes 1.4398 USD
07:45:31 <LoganCapaldo> I thought I was kidding. it really is text/haskell (well text/x-haskell)
07:45:32 <roconnor> @go 20 euros in USD
07:45:33 <lambdabot> 20 Euros = 28.70800 U.S. dollars
07:45:46 <mauke> > 20 * 1.4398
07:45:47 <dylan> firefox should display text/* as text.
07:45:48 <lambdabot>  28.796
07:45:56 <mauke> dylan: except for text/html
07:46:05 <dylan> unless a more specific handler is in place.
07:46:26 <roconnor> maybe I should switch to IE
07:46:32 <LoganCapaldo> I'd like it to syntax hilight text/x-haskell now :)
07:46:50 <mauke> roconnor: the problem is that any non-firefox browser is unusable due to lack of Adblock Plus
07:46:58 <roconnor> mauke: :)
07:47:21 <roconnor> ooh, I should use that haskell web browser
07:47:46 <wli> There's a Haskell web browser? Cool1
07:48:23 <awwaiid> Hello
07:49:16 <roconnor> were did that web browser go?
07:49:35 <roconnor> http://www.cs.chalmers.se/~hallgren/Thesis/wwwbrowser.html
07:49:37 <lambdabot> Title: HacWrite - 32 WWWBrowser -- a WWW client
07:50:01 <roconnor> it's only 13 years old
07:50:03 <mauke> heh. 1994.
07:50:12 <awwaiid> Why do so many haskell programs have explicit type declarations for functions when it seems they could be inferred? Seems to be a cultural norm rather than a technical one.
07:50:17 <roconnor> in 1997 it was ported to Haskell 1.4
07:50:30 <flux> awwaiid, explicit type declarations can be helpful to the reader
07:50:34 <roconnor> awwaiid: it improves error reporting when type errors are made
07:50:37 <mauke> awwaiid: because ghc warns you about top-level bindings without type signatures
07:50:57 <roconnor> apparently there are lots of reasons
07:51:01 <awwaiid> hah
07:51:10 <allbery_b> also useful deugging type errors; also, can speed things up if haskell infers greater polymorphism than you intewnded
07:51:29 <awwaiid> I'm picking up Haskell coming from an OCaml background and it feels very extraneous
07:51:46 <roconnor> hmm, the same reasons should appy to OCaml
07:51:51 <flux> awwaiid, don't you write .mli-files?
07:51:55 <mauke> I often miss type signatures when reading OCaml code
07:52:07 <roconnor> maybe the type classes make haskell type errors worse.
07:52:10 <mauke> I feel kind of lost as to what function arguments really are
07:52:22 <awwaiid> naw, ocaml writes the .mli files for me -- I try to only do a type declaration when it is necessary to disambiguate
07:52:25 <flux> awwaiid, also I've learned to use the syntax let foo : int -> string = fun s -> ..; others may prefer let foo (i : int) : string = ..
07:52:32 <Axioplase> If I have "data Foo a = Constructor".  Can I transport a Foo Int object to a Foo String one? What should the functor look like?
07:53:02 <mauke> Axioplase: convert :: Foo Int -> Foo String; convert Constructor = Constructor
07:53:22 <awwaiid> the type classes make more situations where disambiguation is necessary, roconnor, but certainly not needed for every function definition
07:53:30 <roconnor> wow, I can run Endo DNA on my laptop in 2 minutes now!
07:53:52 <mauke> awwaiid: also, for many functions I write the type signatures first
07:53:58 <roconnor> I probably could get 1 minute on a faster machine
07:54:03 <Axioplase> mauke: So, I can't just do convert :: Foo Int -> Foo string; convert a = a  ? I have to explicitely write the case for each constructor ?
07:54:04 <mauke> with a dummy foo = undefined body, for rapid prototyping
07:54:13 <roconnor> maybe I'm on par with the lisp implementation
07:54:29 <mauke> Axioplase: convert :: Foo a -> Foo b; convert _ = Constructor
07:54:35 <mauke> that should cover all cases :-)
07:54:40 <awwaiid> I'm reading "Haskell: The Craft of Functional Programming" and type declarations are used throughout, to the point where it isn't even mentioned that they were optional.
07:54:52 <Axioplase> (Well, I have many constructors in my real implementation)
07:54:59 <awwaiid> if I _was_ a new functional programmer it would be pretty hard to come up with the types beforehand while also learning
07:55:33 <awwaiid> well, thanks for the responses, they all make sense
07:55:45 <roconnor> ... almost no one is in #haskell-icfp07 :(
07:56:28 <allbery_b> I find it helpful to work out the types beforehand, it forces me to think about what I'm doing
07:56:45 <oklopol> > "o"
07:56:57 <lambdabot>  "o"
07:57:09 <LoganCapaldo> Yeah I've found if I can't write the type signature, I don't know what I'm doing :)
07:57:23 <oklopol> so, to do make los graphicos with haskell, what's the simplest way?
07:57:23 <awwaiid> but if you can why bother? :)
07:57:29 <oklopol> *-do
07:58:04 <EvilTerran> oklopol, do you want them to just appear on the screen, to be in a bitmap file, or for printing on paper?
07:58:28 <oklopol> i want to make a simple program for drawing
07:58:32 <oklopol> drawing stuff
07:58:34 <Saizan> awwaiid: btw, there are scripts that use ghci to insert the signatures automatically
07:59:13 <EvilTerran> something a bit like MSPaint?
07:59:15 <awwaiid> ah, that's good to know, Saizan. Then I can make socially compliant code without effort :)
07:59:24 <oklopol> EvilTerran: a bit like that
07:59:33 <oklopol> the drawing part isn't much more complex
08:00:10 <sioraiocht> has anyone managed to compile ghc on leopard yet?
08:01:17 <desegnis> > 0 : ([1..] >>= \x -> [x,-x]) :: [Int]
08:01:19 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,...
08:01:36 <desegnis> Is there a shorter way to define this list?
08:02:29 <oklopol> EvilTerran: for a minute there i thought you were gonna help me ;) or perhaps you are, but i'm being too impatient
08:02:46 <EvilTerran> oklopol, i'm thinking
08:02:50 <roconnor> @time ski
08:02:51 <lambdabot> Local time for ski is Sun Oct 28 16:12:15 2007
08:03:01 <roconnor> @time ddarius
08:03:19 <roconnor> @bot
08:03:20 <lambdabot> :)
08:03:36 <EvilTerran> oklopol, i would suggest looking into SDL
08:04:04 <LoganCapaldo> @pl  0 : ([1..] >>= \x -> [x,-x])
08:04:04 <lambdabot> (line 1, column 22):
08:04:04 <lambdabot> unexpected "["
08:04:04 <lambdabot> expecting lambda abstraction or expression
08:04:05 <puusorsa> gtk2hs could help too
08:04:30 <wli> desegnis: I think that might be it.
08:04:51 <snhmib> uhm, another newbie question: how do (can?) i make this work: type Set s = MutArr s Int Bool
08:04:57 <EvilTerran> @hackage SDL
08:04:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL
08:04:59 <oklopol> i'm actually thinking it might be time to switch to haskell, can't get dev-cpp to work, and i'm getting tired of asking people for help when i always get the same advice, which simply doesn't work :P
08:05:03 <EvilTerran> ^^ that one, oklopol
08:05:04 <oklopol> so... hmm
08:05:10 <oklopol> oh cool
08:05:13 <wli> desegnis: @pl \x -> x : negate x : []
08:05:13 <oklopol> i'll try
08:05:20 <sioraiocht> > 0:concat [[x,-x] | x <- [1..]]
08:05:22 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,...
08:05:25 <mauke> snhmib: how does it not work?
08:05:28 <EvilTerran> @hackage SDL-image <- you'd need this too, for loading/saving images
08:05:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL-image <- you'd need this too, for loading/saving images
08:05:29 <snhmib> i can't find the right import (?) for MutArr
08:05:41 <sioraiocht> @pl 0:concat [[x,-x] | x <- [1..]]
08:05:41 <lambdabot> (line 1, column 10):
08:05:41 <lambdabot> unexpected "["
08:05:41 <lambdabot> expecting variable, "(", operator, ":", "++" or end of input
08:05:52 <sioraiocht> @pl fun = 0:concat [[x,-x] | x <- [1..]]
08:05:52 <lambdabot> (line 1, column 16):
08:05:53 <lambdabot> unexpected "["
08:05:53 <lambdabot> expecting variable, "(", operator, ":", "++" or end of input
08:06:01 <EvilTerran> hm, actually, that doesn't mention saving. oh well, it's probably worth a look anyway.
08:06:22 <snhmib> i tried import GHC.Prim and GHC.Exts because those are supposed to have a MutArr but no success =(
08:06:37 <wli> @pl 0 : concatMap (\x -> x : negate x : []) [1..]
08:06:37 <lambdabot> 0 : (ap (:) (return . negate) =<< [1..])
08:06:54 <mauke> snhmib: why do you need GHC internals?!
08:07:02 <mauke> especially if you're a newbie
08:07:06 <snhmib> oh so that's not it, heh
08:07:17 <snhmib> i looked in the library index for MutArr =)
08:07:50 <Lemmih> snhmib: How about using IOArray?
08:07:51 <wli> @pl \x -> x : negate x : []
08:07:51 <lambdabot> ap (:) (return . negate)
08:08:12 <wli> Finding a comprehensible pointfree version of that would help.
08:08:29 <desegnis> wli, thanks. Hm, lambdabot's point-free version isn't strictly shorter :)
08:10:53 <snhmib> Lemmih: Not sure .. never heard of it =)
08:11:57 <Lemmih> ?docs Data.Array.MArray
08:11:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
08:12:53 <snhmib> mutable things let me write without making a whole new one right?
08:12:56 <snhmib> thanks!
08:18:47 <oklopol> EvilTerran: how do i actually install that?
08:19:03 <oklopol> there's instructions for unix...
08:19:09 <EvilTerran> are you using ghc?
08:19:16 <oklopol> yep
08:19:28 <oklopol> Setup.lhs?
08:19:40 <EvilTerran> following the unix instructions should pretty much work
08:20:16 <EvilTerran> although you may come upon some dependencies they don't mention; stuff that every unix-alike has but windows doesn't
08:20:38 <oklopol> "runghc Setup.hs configure"
08:20:45 <oklopol> i have no idea where to write that :
08:20:46 <oklopol> :)
08:21:11 <oklopol> how do i "perform them" on a file? there's no runghc.exe...
08:21:34 <wli> The non-ap @pl I get is horrendous, ($ []) . join (((flip (.) ((:) . negate)) . (.)) . (:))
08:21:56 <EvilTerran> write that in a command-line window that's running in the folder with Setup.hs in it
08:21:56 <Saizan> oklopol: have you ever used the command prompt?
08:23:17 <oklopol> yeah :P
08:23:39 <oklopol> but... shouldn't runghc be an exe of a com to be "performable" on a file?
08:23:53 <Saizan> it is
08:24:14 <Saizan> it's in the bin directory of your ghc installation
08:24:40 <oklopol> damn, so it is; shouldn't search manually :)
08:25:38 <Saizan> the installer should have put that directory in your %Path%, so you can just use "runghc" and it will find the executable for you
08:25:53 <oklopol> i put it in the path now
08:26:09 <wli> Looking better is uncurry ((. return) . (:)) . (id &&& negate)
08:26:20 <cinimod> @src remQuot
08:26:20 <lambdabot> Source not found. It can only be attributed to human error.
08:26:29 <cinimod> @src quotRem
08:26:29 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:26:44 <cinimod> @src quot
08:26:44 <lambdabot> Source not found.
08:27:25 <cinimod> @src tail
08:27:25 <lambdabot> tail (_:xs) = xs
08:27:25 <lambdabot> tail []     = undefined
08:27:37 <oklopol> "no happy found" how sad :<
08:27:46 <cinimod> @src mod
08:27:46 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:30:14 <wli> > take 10 . (0 :) $ uncurry ((. (:[])) . (:)) . (id &&& negate) =<< [1..]
08:30:15 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5]
08:30:53 <hpaste>  Axioplase pasted "Illegal instance and phantom types" at http://hpaste.org/3503
08:31:44 <EvilTerran> > let #1 = 2 in #1
08:31:45 <lambdabot>  Parse error at "#1" (column 5)
08:31:53 <mauke> Axioplase: -fglasgow-exts
08:31:57 <Saizan> Axioplase: -fglasgow-exts or LANGUAGE FlexibleInstances
08:32:28 <EvilTerran> shame
08:32:39 <desegnis> wli, lol
08:32:48 <Axioplase> mauke: Saizan : thanks.  However, what does this error actually hide ?
08:33:57 <mauke> huh?
08:34:12 <Saizan> Axioplase: it's just an arbitrary restriction in h98 to the shape of instance heads, to assure termination of typechecking, but with only -fglasgow-exts the termination is still guaranteed
08:34:46 <Axioplase> Alright, thanks.
08:36:14 <oklopol> EvilTerran: "got error code while preprocessing: Graphics.UI.SDL.General"
08:36:21 <oklopol> sorry for the slowness
08:36:33 <EvilTerran> er. i don't know what that means. sorry.
08:36:45 <oklopol> :)
08:36:45 <Lemmih> oklopol: More info, please.
08:36:46 <oklopol> yay!
08:36:52 <oklopol> i'm installing SDL on ghc
08:36:54 <oklopol> on windows
08:37:07 <oklopol> tried what http://www.haskell.org/haskellwiki/How_to_install_a_Cabal_package sugests
08:37:09 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki
08:37:12 <oklopol> *suggests
08:37:45 <Jaak> > take 10 . (0:) $ uncurry (:) . (id &&& return . negate) =<< [1..]
08:37:53 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5]
08:38:08 <Lemmih> oklopol: Installing SDL on windows is a pita. Read WIN32.
08:38:22 <oklopol> WIN32?
08:38:35 <oklopol> where do i read that, and what is that? :)
08:38:46 <EvilTerran> > ap [id,negate] . return $ 2  -- wli, ?
08:38:48 <lambdabot>  [2,-2]
08:39:08 <Lemmih> oklopol: It's a text file shipped with SDL-0.5.1.
08:39:49 <oklopol> oh
08:39:51 <oklopol> i shall
08:49:06 <fxr> with hxt, I wonder if it's possible to use insertTreeTemplate with XPath query patterns?
08:56:40 <atom> just wanted to ask: is this the right way of defining the function that gets the last element of a (finite) list?
08:56:49 <atom> 1 taile (x:xs)
08:56:49 <atom>   2     | xs == [] = x
08:56:49 <atom>   3     | otherwise = taile xs
08:57:07 <atom> I mean it works, but is obviously recursive...
08:58:00 <EvilTerran> everything non-trivial in haskell is recursive
08:58:05 <EvilTerran> that's pretty much right
08:58:23 <atom> EvilTerran: there might have been a better way. Like... um...
08:58:23 <EvilTerran> however, it may be better to write
08:58:27 <EvilTerran> taile [x] = x
08:58:33 <EvilTerran> taile (x:xs) = taile xs
08:59:05 <ari> @src last
08:59:05 <lambdabot> last [x]    = x
08:59:05 <lambdabot> last (_:xs) = last xs
08:59:05 <lambdabot> last []     = undefined
08:59:08 <Heffalump> that way is significantly better, as it avoids an Eq constraint on the elements
08:59:45 <EvilTerran> yeah, i was getting to that, Heffalump. was trying to phrase it in a way that wouldn't baffle a newbie too much, though. ;)
09:00:18 <atom> I kind of think heffalump's comment was recorded with the source, and you should be saying that to ari...
09:01:25 <atom> but... Eq constraint?
09:01:37 <EvilTerran> there we go
09:02:01 <LoganCapaldo> @type (==)
09:02:02 <lambdabot> forall a. (Eq a) => a -> a -> Bool
09:02:03 <EvilTerran> in order to compare two lists for equality, haskell compares each element of each list for equality in turn, pairwise
09:02:05 <TomMD>  > let x = 1 : x in x
09:02:08 <atom> and stupid of me heffalump's comment was recorded with the source.
09:02:32 <EvilTerran> as well as making sure the two lists are the same length
09:02:44 <TomMD> Isn't it supposed to tell me I'm an idiot when I give such an input?
09:03:17 <LoganCapaldo> @type let nullish xs = xs == [] in nullish
09:03:19 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
09:03:39 <EvilTerran> so, you can only compare two lists for equality (with ==) if the type of the elements is one for which == is defined
09:03:47 <LoganCapaldo> @type let { nullish [] = True ; nullish _ = False } in nullish
09:03:48 <lambdabot> forall t. [t] -> Bool
09:03:53 <LoganCapaldo> Eq constraint.
09:03:58 <EvilTerran> those types are known as types "with an Eq constraint"
09:04:00 <atom> EvilTerran: ok. I get it now.
09:04:33 <EvilTerran> this is denoted in a type annotation by "Eq (constrained type) => " at the start
09:04:35 <atom> however, isn't it supposed to short-circuit when I complare something to an empty list?
09:04:58 <EvilTerran> you're still using ==, though, is the problem.
09:05:00 <mauke> types are checked at compile time, not runtime
09:05:08 <atom> I mean, yes, obviously, it doesn't, because otherwise you wouldn't be telling me this.
09:05:23 <mauke> the Eq think is purely a type constraint
09:05:59 <EvilTerran> anyway, the point is, pattern-matching against [] doesn't impose an Eq constraint, while (==[]) does
09:06:01 <atom> mauke: still, [] should be of type "empty list", and therefore, logically, it can only be equal to another empty list
09:06:10 <mauke> atom: "empty list" is not a type
09:06:13 <EvilTerran> there is no type for "empty list"
09:06:13 <LoganCapaldo> empty list isn't a type
09:06:15 <LoganCapaldo> it's a value
09:06:20 <EvilTerran> there's types for "list of <blah>"
09:06:22 <allbery_b> not in haskell at least.  (dependent types?)
09:06:26 <atom> mauke: i said it *should* be
09:06:31 <atom> :)
09:06:32 <mauke> you can make it one, but then your functions can get a lot more complicated :-)
09:06:33 <EvilTerran> the type doesn't include the length of the list
09:06:43 <EvilTerran> because you don't always know the length at compile-time
09:06:59 <mauke> atom: then you have to tag all lists with their length at compile time
09:07:05 <EvilTerran> sure, this might be special-case-able, but it'd be messy, and would complicate everything else
09:07:08 <atom> mauke: only hardcoded ones.
09:07:17 <mauke> atom: no, all of them
09:07:42 <mauke> == requires its arguments to have the same type
09:07:49 <mauke> so [] == foo wouldn't compile if foo wasn't an empty list
09:07:58 <atom> mauke: I yeld.
09:08:14 <LoganCapaldo> hehe
09:08:14 <Richard> I also have a problem with equality ( http://hpaste.org/3504#a0 ) - I'm trying to replace the n'th value of a list with a different value - the problem lies in the "replace" function..there is probably a really simple solution, too
09:08:17 <oklopol> is there a program using sdl i could test? WIN32 says there's an Examples\ directory, but there isn't, and i'm not really capable of writing an SDL program in haskell well enough to know whether the problem is in my code or in the installation (or actually at all)
09:08:17 <LoganCapaldo> yeld
09:09:12 <mauke> Richard: why are your indices 1-based?
09:09:37 <LoganCapaldo> your type annotation for replace is wrong fyi
09:09:38 <EvilTerran> Richard, "replace :: Eq a => a -> [a] -> a -> [a]"
09:09:53 <EvilTerran> sorrt, "replace :: Eq a => a -> [a] -> [a]"
09:09:53 <LoganCapaldo> and by extensions so is setelt's
09:09:57 <atom> mauke: and I agree. It would indeed be very hard to do it properly. However, making | [] == list-type-variable and funcname[] equivalet in a syntactic sugar sort of way wouldn't be that hard.
09:10:13 <Richard> Ah, okay
09:10:16 <EvilTerran> atom, it'd be a messy special case, though
09:10:28 <atom> EvilTerran: that I agree with as well.
09:10:29 <mauke> LoganCapaldo: but setelt shouldn't need Eq
09:10:30 <EvilTerran> if you want to do that, use null
09:10:31 <EvilTerran> @src null
09:10:32 <lambdabot> null []     = True
09:10:32 <lambdabot> null (_:_)  = False
09:10:48 <LoganCapaldo> -setelt is implemented in terms of replace though
09:10:49 <EvilTerran> funcname | null xs = ...
09:10:56 <mauke> LoganCapaldo: which doesn't make sense
09:10:57 <allbery_b> I think doing that via a GHC RULE has been discussed
09:11:01 <LoganCapaldo> I agree :)
09:11:30 <EvilTerran> can you do type-unsafe fiddling in RULEs?
09:11:59 <oklopol> are there any SDL examples for haskell? :)
09:12:14 <EvilTerran> oklopol, we don't know any more than we did when you asked three minutes ago.
09:12:24 <EvilTerran> patience, grasshopper.
09:12:28 <oklopol> did you say you didn't?
09:12:30 <oklopol> oh
09:12:30 <allbery_b> ghc won't stop you from doing something stupid...
09:12:40 <oklopol> well yeah, no one answered
09:12:56 <oklopol> i usually just ask till someone does, but i can wait for a while.
09:13:09 <LoganCapaldo> sometimes no one knows :)
09:13:17 <EvilTerran> if everyone who didn't know an answer to a question said so, #haskell would alternate between one question and about 300 "sorry, dunno"s
09:13:33 <oklopol> yeah, true.
09:13:56 <EvilTerran> if no-one answers, it's likely that #haskell doesn't know the answer, and you should try google instead.
09:14:06 <oklopol> you'd just think *someone* here would know... but true, prolly not much change in active users in a few minutes.
09:14:38 <oklopol> i tried, but it just gives me the link for installing sdl
09:14:48 <LoganCapaldo> well once you find out, congratulations you've just become the resident SDL expert ;)
09:15:15 <oklopol> heh, so none of you ever made a haskell program with graphics?
09:15:23 <Lemmih> oklopol: Did you manage to build the binding?
09:15:28 <oklopol> other than the basic query window stuff
09:15:53 <oklopol> perhaps... did what WIN32 said, told me to "ignore the errors", i have no idea whether it's installed now
09:16:03 <oklopol> since... i don't really know how to use sdl for haskell
09:16:34 <Lemmih> oklopol: The NeHe tutorials have been ported to Haskell several times.
09:16:50 <raxas> oklopol: most of us use good old opengl for _real_ graphics, sdl is so strange to us
09:17:03 <allbery_b> oklopol: SDL is not the only way to do graphics with haskell.  gtk2hs, HOpenGL, SOE are alternatives
09:17:15 * allbery_b does gtk2hs, not familiar with the others
09:17:44 <allbery_b> most of us didn't even know there *were* SDL bindings for haskell until recently
09:17:45 <oklopol> sdl is what i was instructed to use, if anyone knows how to install something else, that will do :P
09:17:52 <Lemmih> raxas: SDL is not an alternative to OpenGL. I originally wrote the binding because GLUT doesn't play nice with GHCi.
09:17:55 <oklopol> i'm a haskell noob though, and on windows :)
09:17:59 <oklopol> that might be a problem
09:19:09 <Shurique> is it likely that the Prelude list operations such as length, take and drop will be replaced with the more generic variants of Data.List anytime in the near future?
09:19:40 <twanvl> no
09:20:03 <dcoutts> @seen pgavin-away
09:20:04 <lambdabot> pgavin-away is in #haskell. I last heard pgavin-away speak 1h 27m 5s ago.
09:20:07 <dcoutts> @seen pgavin
09:20:07 <lambdabot> pgavin has changed nick to pgavin-away.
09:20:07 <lambdabot> pgavin-away is in #haskell. I last heard pgavin-away speak 1h 27m 9s ago.
09:21:52 <twanvl> Shurique: At least, I haven't heared anyone proposing it; and the normal drop/take/length are good enough for 99% of the uses
09:22:15 <dons> its good to get some Ints in there :)
09:22:20 <raxas> oklopol: consider switching to some more usable platform, then. It could be fruitfull to your coding skills
09:22:30 <Shurique> okay, thanks :)
09:22:51 <raxas> Lemmih: what problem with glut you had in ghci?
09:26:00 <vBergmann> why does "succ (succ 4)" work but not "succ.succ 4"?
09:26:12 <mauke> (succ.succ) 4
09:26:14 <Lemmih> raxas: GLUT kills GHCi instead of just handing over control when you quit your application.
09:26:36 <mauke> vBergmann: because that's parsed as succ . (succ 4) and succ 4 is not a function
09:26:48 <dcoutts> vBergmann: function application binds tighter than any operator
09:27:02 <vBergmann> right, thanks
09:31:58 <raxas> Lemmih: ghci is somewhat strange itself. on which platform, linux or windows?
09:31:58 <oklopol> raxas: are you saying i shouldn't use windows? now why would you say that!
09:32:11 <Lemmih> raxas: Linux.
09:32:44 <oklopol> i don't think i could live without the 5 minute pauses when a program crashes and taskmanager won't open.
09:32:57 <oklopol> i think i'll install linux tomorrow
09:33:18 <raxas> oklopol: sdl is just another layer made for the purpose of portability. it is quite ineficient on every platform
09:34:01 <raxas> oklopol: and on any non-windows platforms, opengl implementations are not intentionally crippled
09:35:09 <raxas> Lemmih: it is worth to investigate more deeply, for it certainly could be fixed some way
09:36:11 <oklopol> i tried HelloWorld.hs @ http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/ and installed glut32.dll that was required... getting errors about redisplay etc :D
09:36:14 <lambdabot> Title: Michi&#8217;s blog  Blog Archive  OpenGL programming in Haskell - a tutorial ( ..., http://tinyurl.com/ea6tc
09:36:49 <oklopol> been trying to get a way to draw on the screen since thursday
09:37:03 <oklopol> *find a way
09:39:12 <EvilTerran> oklopol, if you just want to draw on the screen, HGL may be enough
09:39:27 <EvilTerran> ah, that tutorial!
09:39:43 <EvilTerran> oklopol, skip the first example on that tutorial; the others work, iirc
09:39:58 <oklopol> oh :O
09:39:59 <oklopol> i'll try
09:40:04 <Lemmih> raxas: It's easier just to use SDL+OpenGL.
09:40:31 <EvilTerran> apparently, since that was written, something was updated so things refuse to work without you settingt a displayCallback
09:41:20 <oklopol> cool, the next one worked, although it doesn't display correctly
09:43:01 <raxas> Lemmih: I agree
09:44:04 <conal> Lemmih: do you have a pointer to info on SDL+OpenGL (for Haskell)?
09:45:09 <oklopol> heyyy it works! thanks ppl
09:45:24 <oklopol> i'll install linux next week if i have the time, though
09:46:15 <Tac-Tics2> > 9
09:46:17 <lambdabot>  9
09:47:03 <conal> i'd like to start working with OpenGL.  what's a recommended getting-started path?  libs, tutorials, GUI support?
09:47:09 <Lemmih> conal: Nothing beyond pointers to the respective packages on hackage.
09:47:23 <conal> (on windows)
09:47:30 <conal> Lemmih: okay, thanks.
09:50:28 <Lemmih> conal: There aren't really any good toturials. hsSDL is pretty much a one-to-one binding to libSDL, and the Redbook examples is the best introduction to HOpenGL, I believe.
09:50:39 <oklopol> > 0 -- now was this the comment syntax...
09:50:41 <lambdabot>  0
09:50:46 <oklopol> good
09:53:34 <conal> Lemmih: thanks.
09:53:49 <conal> oklopol: are you working on windows?
09:54:22 <oklopol> yeah
09:54:53 <conal> i'm installing GLUT (on Win) and got an error after autoreconf: "configure: error: no GLUT header found, so this package cannot be built"
09:55:36 <conal> where did you get GLUT?
09:57:15 <oklopol> god haskell's indentation syntax is flexible and intuitive <3
09:57:17 <oklopol> hmm
09:57:25 <conal> i guess there's a pre-haskell install phase i missed
09:57:33 <oklopol> i dl'd glut32 on google
09:57:42 <SamB> oklopol: it's lulling you into a false sense of security
09:57:50 <oklopol> perhaps :)
09:58:15 <oklopol> i'll learn it's specifics once i fail to guess how it works
09:58:18 <conal> oklopol: did you install the OpenGL SDK??
09:58:41 <oklopol> i installed nothing, i just tried the thingies at http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/ an
09:58:43 <lambdabot> Title: Michi&#8217;s blog  Blog Archive  OpenGL programming in Haskell - a tutorial ( ..., http://tinyurl.com/ea6tc
09:58:45 <oklopol> *and they worked
10:01:09 <conal> oklopol: do you mean you installed nothing but the OpenGL and GLUT Haskell packages?
10:01:38 <oklopol> i have ghc installed on my computer, i don't think i had to install anything to get opengl to work
10:01:38 <conal> oklopol: plus glut32.dll?
10:01:44 <oklopol> yeah
10:01:47 <oklopol> that i dl'd
10:01:52 <raxas> Lemmih: well, it seems ghci exits when it receives sigterm, so that behavior is correct when you have no signal handler
10:02:15 <raxas> not a glut problem at all
10:02:29 <conal> oklopol: okay, thanks.  did you do the "autoreconf" step for the GLUT package?
10:02:40 <oklopol> nope, i did nothing but dl the dll
10:03:51 <conal> oklopol: did you get OpenGL and GLUT as tar.gz files from Hackage, or via darcs?
10:03:55 <conal> or neither
10:04:08 <conal> did they just come along with ghc?
10:04:38 <oklopol> just came with ghc
10:04:54 <oklopol> or else i don't think i could run the programs in the tutorial
10:04:55 <conal> oklopol: okay.  i'm trying too hard. :p
10:05:01 <oklopol> heh :D
10:05:22 <Beelsebob> supposing you guys had to justify the statement "with a functional language, if it compiles, it usually works"... how would you go about it?
10:05:34 <oklopol> actually, i may have downloaded opengl in the past, and just don't remember it
10:05:38 <conal> when i do "ghc -package GLUT HelloWorld.hs -o HelloWorld", as in that tutorial, i get "ghc.exe: unknown package: GLUT"
10:05:38 <oklopol> though i doubt that.
10:06:08 <oklopol> the first one doesn't work
10:06:14 <oklopol> try the next example
10:06:39 <vBergmann> how is the function "filter' any different than a list comprehension?
10:06:57 <mrd> list comprehensions translate into a use of filter
10:06:58 <conal> oklopol: what does your compile command look like?
10:07:07 <mrd> (possibly)
10:07:10 <oklopol> exactl what you had there
10:07:11 <oklopol> *exactly
10:07:15 <dons> morning all
10:07:16 <oklopol> or...
10:07:17 <oklopol> wait
10:07:20 <conal> ho dons
10:07:26 <oklopol> yep, exactly the same
10:07:28 <conal> i meant "yo dons"
10:07:30 <conal> :)
10:07:30 <thetallguy> conal: you're doing this under windows?
10:07:36 <conal> thetallguy: yep
10:07:43 <thetallguy> dons a ho, dons a ho
10:07:54 <thetallguy> Morning dons. ;-)
10:08:07 <conal> this is how rumors get started :D
10:08:08 <dons> :)
10:08:13 <thetallguy> conal: well, then I can't help you
10:08:30 <thetallguy> conal: re: rumors, trying my best.
10:08:47 <dons> oh you kids! always with the games.
10:09:27 <oklopol> i'm not making a game!
10:10:56 <pgavin> @seen dcoutts
10:10:56 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #gentoo-haskell and #ghc. I last heard dcoutts speak 44m 8s ago.
10:11:34 <vBergmann> hmmm are there any situations where you might prefer "filter" over a list comprehsion?
10:12:17 <vBergmann> filter seems redundant to me
10:12:46 <nominolo> @seen dcoutts
10:12:46 <dons> filter is often shorter
10:12:46 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #gentoo-haskell and #ghc. I last heard dcoutts speak 45m 58s ago.
10:12:49 <mrd> > filter (<1)
10:12:49 <EvilTerran> if you're getting a function in as a parameter, day
10:12:51 <lambdabot>  <[Integer] -> [Integer]>
10:12:52 <EvilTerran> *say
10:12:55 <thetallguy> conal: if you need to do it on Linux, let me know
10:13:01 <mrd> you can't curry list comprehensions
10:13:04 <EvilTerran> it's good for pointsfree stuff
10:13:09 <mrd> at least, not in haskell syntax
10:13:09 <conal> thetallguy: sigh.  thanks.
10:13:21 <dons> filter also optimises better
10:13:24 <EvilTerran> with a list comprehension, you have to give a name to the elements in the list
10:13:37 <thetallguy> conal: we are tinkering with our autobuilder, getting closer to being able to keep current Debian repositories for all hackage packages
10:13:39 <dons> since list comps turn into concatMaps
10:13:40 <mrd> list comprehensions are syntactic sugar, not primitive
10:13:50 <raxas> dcoutts is also in #gentoo-haskell, but she keeps that for herself as a secret
10:13:56 <EvilTerran> > [x | x <- xs, p x] vs (filter p x) -- i vastly prefer the latter
10:13:57 <lambdabot>   Not in scope: `x'
10:14:08 <EvilTerran> whups. shouldn't've put a > there, not paying attention ;)
10:14:27 <thetallguy> conal: so eventually setting up a linux system to do what you want will be minimal work
10:14:28 <nominolo> raxas, "she"?
10:14:38 <raxas> nominolo: lambdabot is she
10:14:48 <thetallguy> conal: what does ghc-pkg say on your system?
10:14:55 <EvilTerran> @vixen good evening.
10:14:55 <lambdabot> good good
10:15:14 <nominolo> raxas, ah right.  but she doesn't.  look again
10:15:25 <conal> thetallguy: ghc-pkg list shows OpenGL-2.2.1 and no GLUT
10:15:27 <soncek> what's wrong with this: (s <- stringLiteral >> return (SynStringConst s))
10:15:46 <nominolo> soncek, missing parans
10:15:47 <raxas> oh, am i blind or what...
10:15:49 <nominolo> *parens
10:15:55 <EvilTerran> conal, GHC doesn't seem to come with GLUT; iirc, it's fairly straightforward to download
10:15:56 <thetallguy> conal: well there's your problem
10:15:59 <EvilTerran> etc
10:16:11 <nominolo> soncek, s <- (stringLiteral >> return (SynStringConst s))
10:16:15 <EvilTerran> soncek, <- only has meaning in a do{} block; are you in a do block?
10:16:26 <soncek> no, i am not
10:16:27 <thetallguy> conal: yes, it got factored out.
10:16:39 <thetallguy> conal: there's an alternative
10:16:44 <soncek> i would like to make a simple "packing" monad action
10:16:44 <EvilTerran> (liftM SynStringConst stringLiteral) would do what you want
10:16:49 <EvilTerran> i suspect
10:16:49 <conal> i downloaded GLUT, but i can't install it.
10:16:56 <thetallguy> conal: I don't particularly like GLUT.
10:17:03 <thetallguy> conal: what happens on install?
10:17:05 <EvilTerran> or (stringLiteral >>= \s -> return (SynStringConst s))
10:17:06 <nominolo> soncek, oh, right then it's  stringLiteral >>= return . SynStringConst
10:17:16 <EvilTerran> or (do s <- stringLiteral; return (SynStringConst s))
10:17:28 <conal> thetallguy: i'll toss out GLUT anyway.  i was just trying to get one ogl example to run.
10:17:45 <soncek> thanks
10:18:08 <conal> i'll probably hook up ogl to wxhaskell instead. or try.
10:18:19 <thetallguy> conal: Hmm....
10:18:34 <nominolo> soncek, of course, it'll be insightful to figure out how all these variants work :)
10:19:39 <thetallguy> conal: well, here's what I know.  SDL is a library that wraps up the OS dependent parts of opengl, sound, mouse and window handling, without using callbacks
10:19:51 <soncek> yes ... i am just checking them :-)
10:20:11 <conal> thetallguy: i think that's what Lemmih was suggesting as well.
10:20:21 <eventualbuddha> what's a simple example for liftM? i'm not sure what "promotes a function to a Monad" means
10:20:56 <thetallguy> conal: I hate callbacks.  So some time ago I tried to do some haskell/opengl coding using that, but I didn't know enough about FFIs, or Haskell i general at the time.
10:21:13 <thetallguy> Regardless of whether you use the code or not, it's a good reference.
10:21:31 <idnar> @src liftM
10:21:32 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:22:23 <conal> thetallguy: i'm intrigued about SDL not using "callbacks".  what does it do instead?
10:22:34 <thetallguy> stepcut was also working on this and may have some code lying around.  I eventually went with just raw X calls because I couldn't get sdl working
10:22:42 <thetallguy> conal: you write your own event loop
10:22:47 <Philippa> conal: event queue
10:22:52 <nominolo> > liftM (3+) (Just 4) -- eventualbuddha
10:22:54 <thetallguy> conal: it's very low level
10:23:02 <conal> thetallguy: okay, i get it.
10:23:04 <lambdabot>  Just 7
10:23:16 <Philippa> intentionally so. Callbacks're the wrong model for games
10:23:26 <nominolo> > liftM (3+) Nothing
10:23:28 <lambdabot>  Nothing
10:23:30 <conal> Philippa: how so?
10:23:35 <Philippa> you want to collate all your input before a frame and process it at once
10:23:37 <thetallguy> conal: it's goals are to keep things portable
10:23:57 <eventualbuddha> hmm. thanks nominolo
10:24:00 <Philippa> you /will/ be rendering as many frames as you can
10:24:03 <idnar> Philippa: you might want to do that, but that doesn't mean it's a great idea
10:24:07 <conal> Philippa: why collate?
10:24:18 <thetallguy> conal: so I'm not sure how it would mix with wx
10:24:44 <thetallguy> conal: but the code is very small, and it is easy to see exactly how things work.
10:24:44 <idnar> most games don't need to render as many frames as they can, and in any case, you usually don't want the render loop coupled to the rest of the game logic because that means the game runs differently if it's rendering faster
10:24:50 <conal> thetallguy: no, i don't think sdl & wx would mix.
10:25:00 <Philippa> idnar: way to oversimplify there
10:25:20 <nominolo> conal: gtk2hs has a GLWindow
10:25:37 <conal> nominolo: nice to know.
10:25:44 <thetallguy> conal: I expect not, but if I were adding ogl to wx, I would use SDL as a reference
10:25:51 <thetallguy> for swiping code, that is.
10:26:01 <Philippa> actually, most games historically /have/ needed to render as many as they could. You want to hit the monitor's refresh rate where possible
10:26:08 <conal> wxhaskell has GLCanvas.  the simple demos compile & run fine for me.  so i have a starting place.
10:26:13 <fasta> There isn't a Mozart Oz channel?
10:26:49 <idnar> Philippa: that hasn't been an issue for ages, though
10:26:54 <Philippa> the game logic needs to be sampled each frame, or there's a whole pile of stuff that aliases as you render
10:27:24 <Philippa> idnar: funny, there's still a market for increasingly fast hardware to run games on
10:27:47 <fasta> Philippa: AFAIK, you just want a multiple of 30fps bounded to the maximum refresh rate of your monitor.
10:27:56 <nominolo> conal: i have an incomplete patch lying around where you could use cairo to draw GL textures.
10:28:01 <idnar> Philippa: yes, but that's not because you're getting graphics corruption due to updating outside of the vertical retrace window
10:28:09 <Philippa> fasta: oversimplification
10:28:11 <conal> does anyone have (haskell) code for interactively viewing 3d models?  say virtual trackball, for rotating?
10:28:28 <conal> nominolo: cool
10:28:39 <puusorsa> conal, not yet :)
10:28:40 <Philippa> idnar: there is /no point/ in updating faster than the monitor's refresh, that's the only reason I mention it
10:28:47 <idnar> Philippa: ok
10:28:56 <conal> nominolo: is cairo in haskell separable from gtk2hs?
10:29:03 <EvilTerran> but there's still reason for the game logic to perhaps have a higher framerate
10:29:03 <smtms> what's the max refresh rate used by monitors today?
10:29:05 <puusorsa> i've been thinking about doing haskell bindings for ogre or something
10:29:09 <fasta> Philippa: that's hardly a rebuttal.
10:29:16 <nominolo> conal: in theory, yes.
10:29:21 <conal> fasta: why multiple of 30fps
10:29:25 <Philippa> nevertheless, it's still the case that most /new/ games struggle to do that on current hardware, because that's what people aim for
10:29:26 <EvilTerran> many frames of simulation to one frame of redrawing
10:29:27 <puusorsa> smtms, lower than it was few years ago
10:29:37 <Philippa> the multiple of 30fps is irrelevant for a PC game
10:29:42 <idnar> I don't think there's even any point in updating faster than 60Hz even if the monitor refresh rate is higher
10:29:45 <puusorsa> crts had higher hzs than lcds
10:29:47 <nominolo> conal: however, it's packaged with gtk2hs for now.  but it could be separated
10:29:57 <tibbe> I'm stupid
10:30:03 <fasta> conal: can't rememmer, but I read it in some OpenGL book.
10:30:07 <fasta> conal: remember*
10:30:18 <Philippa> idnar: avoiding temporal aliasing, unless the monitor's running at a multiple of 60
10:30:21 <tibbe> I just implemented a satisfy p function and forgot to actually apply p, hmpf
10:30:25 <idnar> but for example, if you sample physics at a rate dependent on how fast the display is being updated, then you end up with silliness like being able to jump further if you're rendering faster
10:30:34 <tibbe> no wondering the coverage page shows that my coverage sucks
10:31:08 <nominolo> idnar: but physics usually runs at a lower sampling rate
10:31:10 <Philippa> that depends on what you mean by 'sample physics'
10:31:18 <fasta> It's also rather pointless to talk about games in #haskell, since there isn't a real-time GC implementation (or something that looks like it).
10:31:40 <Philippa> fasta: games aren't actually real time applications
10:31:41 <nominolo> fasta: you could use region-alloc :)
10:31:52 <nominolo> Philippa: huh??
10:32:09 <Philippa> nominolo: they don't suddenly 'fail' because you dropped a frame
10:32:20 <fasta> Philippa: well, they need to have an answer every 1/60th of a second.
10:32:22 <nominolo> Philippa: that's called soft real-time
10:32:23 <mrd> generational gc should be fine for games
10:32:50 <Philippa> fasta: no, they don't, not per se
10:32:55 <mrd> also you can fine tune the gc a bit to cause any global GCs to happen during Loading
10:32:58 <nominolo> games don't allocate.  or they allocate upfront
10:33:35 <vBergmann> is "foldr (+) 0" equivalent to "foldr1"?
10:33:37 <fasta> Philippa: that's a pointless discussion.
10:33:41 <conal> nominolo: cairo sounds pretty cool.  would be great to separate it from gtk2hs.
10:33:41 <Philippa> games these days use all kinds of homebrew memory management. The fact they allocate from the OS up front doesn't tell you much about what's going on logically
10:33:42 <thetallguy> conal: re virtual trackbal, I don't
10:33:46 <nominolo> vBergmann: no
10:33:58 <nominolo> vBergmann: foldr1 doesn't accept []
10:34:00 <fasta> vBergmann: try foldr1 on an empty list
10:34:12 <Philippa> fasta: no, it's not. You don't need real-time GC, you just need GC to not choke you for ages
10:34:20 <fxr> any help about HXT?
10:34:20 <thetallguy> conal: and I've never seen that level of thing in the small apps
10:34:24 <nominolo> Philippa: i mean the internal allocation
10:34:38 <thetallguy> conal: I might have a quaternion based controller in C++ on some old disk.
10:34:56 <mrd> fxr: anything specific?
10:34:58 <Philippa> then you're wrong: a good many games don't behave like that internally, not for all resources
10:34:58 <fasta> Philippa: and ages is 1/60th of a second or a small multiple of it.
10:35:09 <thetallguy> conal: I agree on cairo, the gtk mixin seemed unfortunate to me.
10:35:13 <nominolo> conal: yes.  you could ask dcoutts how hard that would be
10:35:35 <Philippa> fasta: funny how that starts to look like an age in terms of cycles
10:35:57 <mrd> std malloc/free can take arbitrary amounts of time
10:36:27 <conal> thetallguy: i imagine someone would have done virtual trackball in haskell.  the algorithm i've read looks very imperative, but underneath i think it's a simple ode, i.e., purely functional if you treat (continuous) functions of time as first class values.
10:37:05 <hpaste>  fxr pasted "replace html parts" at http://hpaste.org/3505
10:37:10 <fxr> mrd: here it is
10:37:17 <mrd> fxr: wait
10:37:19 <thetallguy> conal: yes, I expect so.
10:37:24 <mrd> ?paste
10:37:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:37:25 <fxr> mrd: I cannot XPath thing to work
10:37:29 <mrd> use that
10:38:43 <fxr> aready did
10:40:08 <thetallguy> conal: the quaternion controller was nice in that it was quite simple mathematically, as well, and the interaction was easy to understand, but it might not have been suitable for kids.
10:40:19 <mrd> oh oops
10:40:26 <conal> thetallguy: oh -- why not for kids?
10:41:25 <conal> is anyone interested in collaborating on a nice functional layer over OpenGL?  i've done a few similar things in the past, but i'm always intimidated about learning another complex imperative API.
10:41:29 <thetallguy> conal: my memory is that there was a quirk  that bothered people who didn't understand the math.
10:41:38 <thetallguy> conal: yes.
10:41:58 <thetallguy> stepcut and I would be happy to help with that.
10:42:07 <thetallguy> I'm facing the same problem with the flash api
10:42:22 <mrd> fxr: which part?
10:42:33 <conal> thetallguy: who's stepcut?
10:42:40 <thetallguy> conal: Jeremy Shaw
10:42:57 <thetallguy> conal: the third piece of the SeeReason puzzle
10:43:07 <conal> thetallguy: great.  do you guys use ogl now?
10:43:33 <thetallguy> conal: we've played with it.  We're still getting started.
10:43:43 <fxr> mrd: I'm sorry I'll anotate working version now, there are errors on this one
10:44:05 <thetallguy> conal: first priority is haskell->flash, but I would like to try and have an -> ogl as well, because we could scale better.
10:44:15 <conal> thetallguy: what are you doing for gui?
10:44:34 <thetallguy> conal: flash
10:45:01 <thetallguy> conal: exactly how that is structured is still up in the air.  I was working my way through the problem when the fires hit.
10:45:39 <conal> thetallguy: how did the fires effect you?
10:45:51 <thetallguy> conal: but I'm thinking a Fran derivative that I can compile to flash or ogl.
10:46:05 <tibbe> I need a C function that compare two char[] and returns the first index which doesn't max, anyone know of such a function?
10:46:07 <oklopol> ghc doesn't know -make used at http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-2/ how do i make it compile multiple files :|
10:46:11 <lambdabot> Title: Michi&#8217;s blog  Blog Archive  OpenGL programming in Haskell, a tutorial (P ..., http://tinyurl.com/yl5ljl
10:46:43 <sorear> tibbe: c=a;while(*a++!=*b++);return c-a?
10:46:45 <conal> oklopol: --make
10:46:46 <thetallguy> conal: exactly what parts of fran we use is unclear.  I know you're unhappy with som of it.
10:46:59 <thetallguy> conal: but I want a dclarative model for making games
10:47:09 <oklopol> oh
10:47:11 <tibbe> sorear: right, then I'll implement it myself in haskell
10:47:26 <tibbe> sorear: I could try word by word comparison too for greater speed :)
10:47:50 <conal> thetallguy: totally.  and i think the fran model is fixable.  semantically, yampa was on the right track with arrows.
10:47:57 <thetallguy> conal: Ideally, one should be able to write a little game very concisely and then use other tools to fill in language, graphics
10:48:02 <hpaste>  fxr annotated "replace html parts" with "how to use processXPathTrees" at http://hpaste.org/3505#a1
10:48:05 <fxr> mrd: here it is
10:48:17 <conal> oklopol: does that ghc line work for you?
10:48:22 <thetallguy> conal: yes, I've been reading about arrows and AFs to catch up.
10:49:04 <oklopol> conal yep
10:49:05 <oklopol> :
10:49:10 <thetallguy> conal: but I got distracted by a grilled lam stew
10:49:16 <thetallguy> s/lam/lamb
10:49:23 <conal> thetallguy: sounds like a good project to link up on then.  i've been wanting to revisit frp.
10:49:24 <fxr> mrd: I cannot see the replacement being done in output file
10:49:29 <conal> thetallguy: lamb stew?
10:49:55 <thetallguy> conal: recipe here: http://cliffordbeshers.blogspot.com/
10:49:56 <lambdabot> Title: RuMiNaTiOnS
10:50:19 <thetallguy> conal: it was an experiment that worked really well, so I took time out to write it up.
10:50:52 <conal> thetallguy: i just subscribed to your blog.
10:51:18 <thetallguy> Cool.  As soon as I have a real Haskell post, I'll send it off to planet haskell
10:51:21 <mrd> where do you call replaceById?
10:52:12 <fxr> mrd: I don't call it, it can be commented
10:52:33 <fxr> mrd: I wanna do something like: echo "<p>qwerty</p>" | ./xmltr -i example.html -o /tmp/tmp.html -q "/html/body"
10:52:50 <fxr> mrd: which basically replaces a part of an HTML with given input
10:59:50 <fasta> What is the syntax for "exists only once" again in e.g. LaTeX?
11:00:55 <fasta> Never mind
11:03:03 <mrd> fxr: i don't think the first param to replaceChildren is correct
11:05:19 <fxr> mrd: it is (constA "<p>qwerty</p>" >>> xread) :: (ArrowXml a) => a b XmlTree
11:08:32 <mrd> hmm
11:09:00 <mrd> the output is the same as the input?
11:09:32 <fxr> yes
11:10:22 <hpaste>  mrd annotated "replace html parts" with "is this what you meant to happen?" at http://hpaste.org/3505#a2
11:12:41 <fxr> mrd: exactly :)
11:15:25 <mrd> i would fiddle with it at the ghci prompt like i was doing, to see what's going on
11:18:27 <mrd> if you invoke replaceByPath from ghci does it work?
11:19:37 <fxr> checking
11:21:02 <roconnor> @doc Control.Monad.Cont
11:21:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
11:22:40 <hpaste>  fxr annotated "replace html parts" with "using readDocument instead of readString" at http://hpaste.org/3505#a3
11:22:59 <fxr> mrd: using readDocument instead of readString does nothing
11:23:35 <mrd> readDocument doesn't work?
11:23:41 <fxr> mrd: yes
11:23:58 <mrd> check your working directory
11:24:00 <mrd> :!pwd
11:25:08 <fxr> mrd: I'm giving absoulte paths, I wrote example.html for ease of read
11:25:43 <mrd> well, let's test readDocument alone
11:26:35 <fxr> mrd: it works alone
11:27:48 <fxr> mrd: "readDocument opts file >>> writeDocumentToString []" yields file contents
11:29:22 <mrd> works here
11:29:43 <hpaste>  fxr annotated "replace html parts" with "changed XPath Query to "/html"" at http://hpaste.org/3505#a4
11:30:02 <mrd> paste the contents of example.html
11:33:26 <fxr> mrd: well I thing hpaste.org not functioning :(
11:34:45 * sorear wonders how to get irssi to highlight complaints about the status of hpast 
11:35:13 <sorear> fxr: what d you mean?  it seems to worked?
11:35:23 <fxr> mrd: http://paste.lisp.org/display/49966 here it is
11:35:35 <sorear> what's wrong with hpase?
11:35:50 <dons> screenshots gallery for xmonad, http://haskell.org/haskellwiki/Xmonad/Screenshots
11:35:51 <lambdabot> Title: Xmonad/Screenshots - HaskellWiki
11:35:55 <fxr> sorear: I cannot paste, after submit, it redirected me to the main page
11:35:58 <dons> if anyone else has something cool, do drop me a link!
11:36:31 <sorear> glguy!!!
11:37:49 <mrd> well i was using <html><body>test</body></html>
11:38:53 <fxr> mrd: which version of hxt you are using?
11:39:15 <mrd> 7.2
11:39:50 <Saizan> dons: the second "gnome support" should be "kde support"
11:39:55 <mrd> i get utf8 encoding errors
11:40:41 <dons> Saizan: ah thank you.
11:40:49 <dons> my knowledge of kde/gnome land is super limited, as to be zero
11:41:17 <mrd> ok i eliminated the encoding errors
11:41:20 <Saizan> dons: when there's a big K is usually kde :)
11:41:36 <mrd> now i am getting your problem
11:42:19 <dons> Saizan: oh, that's a good rule!
11:43:49 <mrd> interesting. the problem occurs when I put a newline after <html>
11:44:10 <sorear> and the hpaste repository is broken
11:44:21 <mrd> in fact, putting a space in between <html> and <body> is enough to break it
11:44:23 <fxr> I'll try to unpull and try 7.3
11:45:31 <hpaste>  mrd annotated "replace html parts" with "example" at http://hpaste.org/3505#a5
11:46:50 <mrd> looks like a bug. maybe i'm misinterpreting xpath semantics
11:47:59 <fxr> mrd: I used (a_remove_whitespace,v_1) with your example and it works for that case
11:48:11 <mrd> hmm
11:48:22 <sorear> fxr: I'd fix hpaste, but the repository just broke :(
11:48:28 <mrd> yea but any other tags break it too
11:48:40 <mrd> any separate between html and body
11:58:03 <fxr> what a compilation :)
11:58:13 <dons> http://programming.reddit.com/info/5zaxr/details
11:58:14 <lambdabot> Title: programming: Using continuation passing style for high performance monadic code
11:58:15 <fxr> I need to buy a new processor
11:58:53 <sorear> ghc is one of the slowest compilers I've ever seen
11:59:14 <sorear> if compilation time is an issue for you, use a different language
11:59:20 <dons> the java compilers i've seen are fairly slow too. but i'm not sure anything beats g++
12:00:44 <olsner> eclipse's java compiler is "blazingly fast" though
12:01:11 <P_D_> stalin scheme.
12:01:36 <dons> sorear: jhc surely wins though :)
12:01:40 <dons> mlton is up there too
12:01:43 <sorear> ddarius:
12:01:47 <sorear> blech
12:01:48 <dons> the compilers that think harder, take longer :)
12:02:03 <dons> P_D_: is stalin scheme a whole program optimising compiler?
12:02:04 <fxr> when you express 10x loc with 1x loc, compilation time doesn't matter much
12:02:16 <P_D_> Yes
12:02:21 <sorear> dons: yeah, jhc is the reason I had to put in the "one of" qualifier
12:02:25 <dons> right. so the "thinking harder" rule applies
12:03:03 <sorear> dons: but gcc can process the york backend at 2000 loc/second
12:03:19 <dons> it doesn't think very hard :)
12:03:28 <P_D_> gcc is still pretty slow for a C compiler
12:03:31 <dons> thetallguy: you should get your blog on planet.haskell.org
12:03:51 <dons> yes, the -fasm backend makes a noticably improvement to ghc, as opposed to the gcc backend
12:04:06 <dons> thetallguy: you can find the address of ibid on the planet page
12:04:09 <sorear> yes, ghc thinks very hard.  but I have yet to see proof that this thinking helps at all
12:04:09 <P_D_> I think they garbage collect internally
12:04:27 <dons> sorear: try using -Onot :)
12:04:42 <mrd> strictness analysis is slow
12:04:50 <andyjgill> I've made a request to add my blog to  planet, but have not received a response yet.
12:04:51 <dons> and constructor specialisation
12:05:08 <dons> andyjgill: cool, ibid should process it in good time. ping him here to speed up the process
12:05:21 <dons> and the rewrite rules engine
12:05:27 <dons> all sources of slow downs.
12:05:39 <dons> esp. when all are firing :)
12:05:46 <byorgey> andyjgill: it took him a while to add mine too, but he got around to it eventually =)
12:05:56 <andyjgill> Okay. it is the weekend.
12:05:56 <hpaste>  mrd annotated "replace html parts" with "a curious difference" at http://hpaste.org/3505#a6
12:06:18 <thetallguy>  dons: yes, I will do that as soon as I have a haskell post on it.
12:06:53 <thetallguy> andygill: I send you email after ICFP about your HTML paper link going stale.  Did you get it?
12:07:17 <DRMacIver> RE the recent post on continuation passing style in monads, I've been wondering recently if you couldn't convert most instances of pattern matching into continuation passing style anyway (automatically in the compiler that is)
12:07:26 <thetallguy> andygill: I think OGI has cleaned up some.  The hyperfunctions paper by John Launchbury is also missing.
12:07:28 <DRMacIver> Does GHC already do anything to this effect?
12:08:07 <andyjgill> No. Sorry! my email is andy (at) unsafeperformio (dot) com
12:08:25 <thetallguy> I thought I sent it there, but I may have used the galois address.
12:08:30 <thetallguy> I'll try again.
12:08:44 <SamB> DRMacIver: hmm?
12:08:58 <SamB> DRMacIver: oh, like vectored returns?
12:09:06 <andyjgill> I've got a backup of OGI, so I can recover it.
12:09:21 <DRMacIver> SamB: I'm not sure what vectored returns are, but probably. :)
12:09:23 <SamB> apparantly that confuses modern CPUs or something
12:10:08 <DRMacIver> SamB: Where matching on the results of a computation returning some time Foo | Bar gets replaced with passing two functions in, one for the Foo case one for the Bar case.
12:10:15 <DRMacIver> Oh, really? Why?
12:10:57 <SamB> it reduced the effectiveness of branch prediction, I think
12:11:08 <DRMacIver> Ah
12:11:16 <thetallguy> andyjgill: resent to the correct address
12:11:28 <andyjgill> Thanks
12:11:40 <thetallguy> andyjgill: where in academia are you headed?
12:11:56 <andyjgill> Do not know yet!
12:12:01 <SamB> though I'm honestly not sure how branch prediction is able to work with GHC's returns anyway
12:12:38 <thetallguy> andyjgill: Oh!
12:12:41 <andyjgill> Looking for a good place to explore ideas.
12:13:08 <thetallguy> andyjgill: isn't that a truism? ;-)
12:13:14 <SamB> since, you know, GHC doesn't use the stack pointer for its stack...
12:13:26 <SamB> or the ret instruction for its returns
12:14:33 <newsham> http://www.tilera.com/products/processors.php huh, 64-cores.  when willthere be a ghc port? :)
12:14:34 <lambdabot> Title: Tilera Corporation
12:14:35 <andyjgill> But we may end up back in the UK.
12:14:49 <SamB> and it says in the optimization manual that modern IA-32 CPUs have a predicted return stack
12:15:05 <sorear> DRMacIver: why do you want CPS?  It simplifies the compiler but wrecks performance
12:15:38 <DRMacIver> I don't particularly. I was just wondering if it would help.
12:15:54 <ADEpt> Is it something wrong with my setup (debian etch), or this is an outdated package? "libghc6-haskell-src-dev: Depends: ghc6 (< 6.6+) but 6.6.1-2 is to be installed"
12:16:09 <thetallguy> andyjgill: good luck
12:16:11 <DRMacIver> And the recent post by _roconnor reminded me.
12:16:28 <SamB> ADEpt: it looks like an outdated package
12:16:37 <Saizan> using CPS to implement common monads gains in performance because you avoid pattern matching unless when necessary, not because you encode it as CPS
12:16:38 <andyjgill> Thanks. I'm hoping to get a chance to push HERA some more.
12:17:16 <fxr> mrd: even 7.3 not working
12:17:24 <ADEpt> SamB: thnx
12:21:03 <mrd> its a bug i think
12:21:30 <SamB> ADEpt: it seems like there should be a newer one. Igloo ought to know what the deal is...
12:22:19 <ADEpt> SamB: according to https://bugs.launchpad.net/debian/+source/haskell-haskell-src/+bug/145541, a simple rebuild fixes that
12:22:20 <lambdabot> http://tinyurl.com/2zko9w
12:23:06 <DRMacIver> Saizan: Well, given what I was asking about was using a transformation to CPS to avoid pattern matching, I'm not sure what you're trying to correct?
12:23:35 <SamB> ADEpt: it is Igloo's job to do these rebuilds, though
12:23:43 <SamB> at least for this package
12:24:03 <SamB> assuming debian
12:24:24 <ADEpt> SamB: yep, in the larger scae of things. But here and now, i'll make do with "fakeroot dpkg-buildpackage" for myself :)
12:24:29 <ADEpt> @seen Igloo
12:24:29 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I don't know when Igloo last spoke.
12:24:40 <ADEpt> Igloo: are you here?
12:24:41 <Saizan> DRMacIver: well, you said "convert pattern matching to CPS"
12:25:10 <Saizan> DRMacIver: instead the trick is to "avoid pattern matching with CPS"
12:25:10 <SamB> ADEpt: I suspect his client has been triggered by now
12:25:34 <newsham> saizan: doesnt the "conversion" "avoid pattern matching" ?
12:25:53 <newsham> I liked the examples in the reduceron talk (hand-written slides are cool, too :)
12:25:57 <DRMacIver> Saizan: I'm not sure I follow the distinction.
12:26:59 <swiert> @users
12:26:59 <lambdabot> Maximum users seen in #haskell: 423, currently: 419 (99.1%), active: 25 (6.0%)
12:27:06 <Saizan> DRMacIver: think of the Either e monad, you're constantly branching on Left and Right constructors, if you literally convert that to CPS, you're branching on which continuation you use
12:27:06 <DRMacIver> Saizan: Converting the pattern matching into CPS would avoid the pattern match. (Whether or not it's a good idea is a separate question. I'm entirely prepared to believe that it's not. :) )
12:27:46 <Saizan> DRMacIver: instead with CPS you can write a monad that cares about the Left only when there's a need for it
12:27:54 <sorear> you could just use exceptions
12:28:07 <sorear> optionally with newtypes and upio
12:28:28 <SamB> does this CPS deal allow more laziness?
12:30:50 <Saizan> that's a good question, however this started yesterday with this paste: http://hpaste.org/3491
12:31:03 <DRMacIver> Saizan: Hm. Ok.
12:33:06 <oerjan> ooh
12:33:08 <oerjan> @users
12:33:09 <lambdabot> Maximum users seen in #haskell: 423, currently: 420 (99.3%), active: 25 (6.0%)
12:33:19 <sorear> @tell glguy I removed the a href block - read at 11:35 clog time for an explanation
12:33:19 <lambdabot> Consider it noted.
12:33:40 <sorear> fxr: hpaste should work now
12:33:53 * byorgey goes off to convince four random people off the street to log into #haskell
12:34:46 <byorgey> @users
12:34:46 <lambdabot> Maximum users seen in #haskell: 423, currently: 423 (100.0%), active: 23 (5.4%)
12:35:06 <Saizan> do you know if compiling mtl with -O2 or copying the modules in my source tree makes any difference wrt inlining?
12:35:42 <Saizan> s/or/instead of/
12:36:24 <hpaste>  newsham pasted "cps data structs?" at http://hpaste.org/3507
12:37:55 <dons> Saizan: in the local module certainly helps
12:38:09 <dons> oh, new high score eh?
12:38:13 <dons> very cool
12:38:14 <Heffalump> not, just equal so far
12:38:15 <sorear> Saizan: compiling mtl with -O2 helps, a lot
12:38:22 <dcoutts> newsham: that's the Church encoding of data types I think
12:38:24 <Heffalump> NOONE LEAVE!
12:38:24 <dons> 423 is still new
12:38:28 <Heffalump> ah, ok
12:38:31 <sorear> tibbe--
12:38:32 <dons> sunday is a busy day, eh?
12:38:36 <dons> weekend fp hackers :P
12:38:42 <jcreigh> sorear: oh come now. that's not fair.
12:38:43 <ddarius> newsham: To turn a data structure into it's equivalent, just fold it.  I.e. for lists foldr will turn a list into it's Church encoding.
12:38:45 <jcreigh> tibbe++
12:38:51 <byorgey> dons: no, not quite =(
12:39:34 <Korollary> Frack. We lost our 420 reference.
12:39:36 <dons> we're larger than #ruby-lang!
12:39:37 <dons> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
12:39:39 <lambdabot> Title: Search IRC, displaying all channels on freenode
12:39:46 <dons> #11 is the highest yet
12:39:54 <ddarius> Korollary: We should have stuck it on a shelf in France!
12:40:18 <fox86> are there any well documented libraries for coding 2d graphics (games) in haskell? such as pygame for python
12:40:22 <newsham> ddarius/dcoutts: so how does that differ from the "cps translation of data structures" being discusseD?
12:40:29 <Korollary> ddarius: Oh well. The French kids would have vandalized it anyways.
12:40:52 <dons> fox86: no game libraries, other than yampa, but some good examples
12:40:56 <dcoutts> newsham: it doesn't, that's just the name for it.
12:41:05 <fox86> dons: ah, okay
12:41:15 <sorear> fox86: gtk2hs is pretty good, if a tad generic
12:41:15 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Games
12:41:17 <lambdabot> Title: Applications and libraries/Games - HaskellWiki
12:41:24 <dons> lots of games these days
12:41:25 <newsham> ahh.. thx.
12:41:33 <dons> oh,
12:41:34 <dons> "FunGEn - a game engine for Haskell FunGEn (Functional Game Engine) is a 2D platform-independent game engine implemented in and for Haskell, using HOpenGL. It is intended to help game programmers in the game development process, in a faster and automated way.
12:41:38 <dons> "
12:41:47 <dons> fox86: apparently we *do* have game libs :)
12:41:54 <fox86> great, thank you!
12:41:55 <newsham> isnt the SOE library kinda for games (or often used for it)?
12:42:16 <SamB> it's for little things
12:42:27 <SamB> it doesn't have any text measuring :-(
12:43:47 <ddarius> newsham: No, the Church encoding of a list would handle the recursion for you.  I.e. length' would be simply length' l = 0 (const (+1))
12:44:04 <ddarius> Just like length = foldr (const (+1)) 0
12:44:51 <newsham> where's l?
12:45:11 <ddarius> Oops, length' l = l 0 (const (+1))
12:46:20 <ddarius> DRMacIver: In that hpaste, http://hpaste.org/3491, Error2CPS corresponds to simply Church-encoding Either while ErrorCPS embeds Either into the answer type of Cont.
12:47:21 <SamB> ddarius: so does one of those improve the laziness?
12:51:12 <ddarius> I doubt it.  I'm not really sure how strictness is affected.  Though Error2CPS is "isomorphic" to Either so should have the same behaviour, though if that isomorphism were to be broken, strictness would do it.
12:52:58 <lola> Hi! I'm looking for a function that does array.get(index) (except in haskell).. ;) all I found was elemIndex and find... but thats not exactly what I was looking for. Any tips?
12:53:08 <ddarius> :t (!)
12:53:10 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
12:53:21 <ddarius> But you may well want to try something else all together.
12:53:52 <ddarius> If you want the similar thing for lists, which suggests that you are -really- doing something wrong it is (!!).
12:53:54 <ddarius> :t (!!)
12:53:55 <lambdabot> forall a. [a] -> Int -> a
12:54:03 <lola> ok.. thanx :)
12:54:10 <nominolo> hm, has anyone tried to implement HList using ATs?
12:57:18 <ari> I don't think I'm ever going to get over the similarity of Lennier and Lennart and stop thinking of augustss as a Minbari
12:57:54 <newsham> mmm minibar
13:00:45 <sorear> lola: but as ddarius says, (!!) strongly suggests you are doing something wrong
13:01:14 <sorear> > repeat 1 !! 10000000
13:01:20 <lambdabot>  1
13:01:26 <sorear> notice how slow that is!
13:01:45 <newsham> log shows answer in the same minute as query :)
13:02:04 <dmwit> sorear: It's very fast, just the network is slow.
13:02:08 <dmwit> (Try it at ghci, for example.)
13:02:25 <newsham> > 1 -- ping
13:02:27 <lambdabot>  1
13:02:30 <dmwit> Correction: It may be slow, but it isn't noticeable to humans.
13:02:30 <newsham> slow!
13:02:53 <shachaf> Add a few more zeros. :-)
13:02:57 <sorear> dmwit: tack on two more zeros
13:03:13 <dmwit> shachaf: Yeah, or do it once for each element up to that number, or... =)
13:03:20 <sorear> dmwit: it doesn't change my essential point
13:03:27 <Japsu> @ping
13:03:27 <lambdabot>   CSE	 : "Abdullah","Lili Marziana","Program Director - Computer Science","ATP  Australian Technology Park","","lilia"
13:03:27 <lambdabot> CSE	 : "Ahmed","Nadeem","Research Fellow","K17 501E","56908","nahmed"
13:03:27 <lambdabot> CSE	 : "Ahmed","Shabbir","PhD Student","K17 501-19","55301","shabbira"
13:03:27 <lambdabot> CSE	 : "Akand","Elma Hussana","PhD Student","K17 401-02","56913","akande"
13:03:27 <lambdabot> CSE	 : "Al-Kilidar","Hiyam","PhD Student","ATP Australian Technology Park","","hiyama"
13:03:28 <dmwit> sorear: No fair, any algorithm can be made slow by "tacking on zeros".
13:03:29 <lambdabot> [330 @more lines]
13:03:35 <Japsu> wtf just happened
13:03:37 <dmwit> sorear: But yes, I understand your point.
13:03:41 <sorear> dmwit: Not O(1) algorithms
13:03:49 <sorear> Japsu: There is no ping command
13:04:02 <Japsu> sorear: so what did lambdabot take my ping for, then?
13:04:18 <sorear> Japsu: Lambdabot has the greatest feature ever to grace an IRC bot - SPELLING CORRECTION
13:04:26 <sorear> @hooogle Char -> Int
13:04:27 <lambdabot> Char.digitToInt :: Char -> Int
13:04:27 <lambdabot> Char.ord :: Char -> Int
13:04:27 <Japsu> sorear: yeah, but which command was that, then
13:04:33 <sorear> @help ring
13:04:33 <lambdabot>  @ring <user>, CSE phonebook
13:04:38 <Japsu> lol
13:04:57 <newsham> ?eliot testing 1 2 3
13:04:58 <lambdabot> Maybe you meant: elite list
13:05:21 <sorear> Japsu: fwiw, the standard ping command here is @bot
13:05:27 <augustss> ari: there are worse things than being Minbari
13:05:32 <Japsu> sorear: botsnack, that is?
13:05:36 <sorear> yes
13:05:45 <sorear> prefix expension!
13:05:48 <newsham> @bot turn that frown upside down
13:05:48 <lambdabot> :)
13:06:31 <SamB> no, no, like this
13:06:35 <SamB> ):
13:06:45 <dmwit> @bot turn that frown sideways
13:06:45 <lambdabot> :)
13:06:52 <ddarius> Spend your prefixes now!
13:07:03 <SamB> spend my whats?
13:07:19 <byorgey> prefices?
13:09:41 <oerjan> @boss
13:09:42 <lambdabot> Maybe you meant: b52s docs
13:10:04 <oerjan> @b5
13:10:04 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
13:10:22 <olsner> that's gotta be from the song Quiche lorraine
13:10:25 <Torment> @b52s
13:10:26 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
13:10:38 <oerjan> @botsma
13:10:39 <lambdabot> Unknown command, try @list
13:11:01 <oerjan> so the prefix check and spelling check don't combine...
13:11:15 <sorear> cirrect.
13:12:08 <olsner> btw, he quite obviously says "30 foot leash"
13:12:43 <oerjan> @help b52s
13:12:44 <lambdabot> b52s. Anyone noticed the b52s sound a lot like zippy?
13:13:26 <paczesiowa> is it possible to search through hpaste?
13:13:56 <dmwit> Yup, use google with its site:hpaste.org command.
13:14:00 <Heffalump> @users
13:14:00 <lambdabot> Maximum users seen in #haskell: 423, currently: 422 (99.8%), active: 21 (5.0%)
13:14:16 <dmwit> We just need two more for a new record!
13:15:19 <axm> who would consider that cheating?
13:15:21 <byorgey> hm, I think that's cheating.
13:15:28 <olsner> @users
13:15:29 <lambdabot> Maximum users seen in #haskell: 423, currently: 423 (100.0%), active: 23 (5.4%)
13:15:29 <lambdabot2> Maximum users seen in #haskell: 423, currently: 423 (100.0%), active: 5 (1.2%)
13:15:44 <olsner> we're only cheating ourselves though, so I guess it's fair game ;-)
13:15:45 <newsham> ?vixen will the real lambdabot please stand up?
13:15:46 <lambdabot> you're so polite :)
13:15:46 <lambdabot2> you're so polite :)
13:15:54 <dmwit> ?vixen always the same?
13:15:54 <lambdabot2> always always, or just most of the time?
13:15:54 <lambdabot> always always, or just most of the time?
13:16:03 <newsham> ?vixen sex
13:16:03 <lambdabot2> Shouldn't we get to know each other before we talk about sex?
13:16:03 <lambdabot> It's all about sex isn't it? :)
13:16:09 <paczesiowa> dmwit: big thx!
13:16:22 <dmwit> ?users
13:16:23 <lambdabot2> Maximum users seen in #haskell: 423, currently: 422 (99.8%), active: 8 (1.9%)
13:16:23 <lambdabot> Maximum users seen in #haskell: 423, currently: 422 (99.8%), active: 23 (5.5%)
13:17:22 * shachaf resists the urge to ?where zap.
13:17:48 <dmwit> heh
13:17:56 <dmwit> Two lambdabots are indeed dangerous.
13:18:29 <olsner> @echo
13:18:29 <lambdabot2> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot2", msgPrefix = "olsner!n=salparot@cust.fiber-lan.vnet.lk.85.194.50.194.stunet.se", msgCommand = "PRIVMSG", msgParams = ["#haskell"
13:18:29 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "olsner!n=salparot@cust.fiber-lan.vnet.lk.85.194.50.194.stunet.se", msgCommand = "PRIVMSG", msgParams = ["#haskell",
13:18:29 <lambdabot> ":@echo"]} rest:""
13:18:29 <lambdabot2> ,":@echo"]} rest:""
13:18:41 <olsner> @echo @echo
13:18:41 <lambdabot2> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot2", msgPrefix = "olsner!n=salparot@cust.fiber-lan.vnet.lk.85.194.50.194.stunet.se", msgCommand = "PRIVMSG", msgParams = ["#haskell"
13:18:41 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "olsner!n=salparot@cust.fiber-lan.vnet.lk.85.194.50.194.stunet.se", msgCommand = "PRIVMSG", msgParams = ["#haskell",
13:18:42 <lambdabot> ":@echo @echo"]} rest:"@echo"
13:18:42 <lambdabot2> ,":@echo @echo"]} rest:"@echo"
13:19:01 <olsner> @help echo
13:19:01 <lambdabot2> echo <msg>. echo irc protocol string
13:19:01 <lambdabot> echo <msg>. echo irc protocol string
13:19:06 <olsner> oh
13:19:36 <olsner> hmm... so echo /quit would do bad things to the bot?
13:19:48 <oerjan> @id @id
13:19:48 <lambdabot2>  @id
13:19:48 <lambdabot>  @id
13:19:50 <smtms> olsner, just try it :-)
13:19:50 <shachaf> olsner: Why?
13:19:54 <sorear> olsner: why?
13:20:01 <shachaf2> olsner: Why?
13:20:09 <dmwit> gah
13:20:17 <sorear> olsner: besides, /-commands are strctly a ircii and clones thing
13:20:26 <olsner> I should stereo-quote you for that! if I could... ;-)
13:20:37 <sorear> olsner: the protocol uses side channels
13:20:49 <oerjan> @where report
13:20:49 <lambdabot2> http://www.haskell.org/onlinereport/
13:20:49 <lambdabot> http://www.haskell.org/onlinereport/
13:20:51 <lambdabot2> Title: The Haskell 98 Language Report
13:20:51 <lambdabot> Title: The Haskell 98 Language Report
13:21:01 <sorear> PRIVMSG #haskell :/quit bah   is completely different from    QUIT :bah
13:21:02 <olsner> hmm, yeah, I guess /-commands have different IRC protocol strings
13:21:07 <dmwit> Who's in control of these bots?
13:21:09 <dmwit> ?users
13:21:09 <lambdabot2> Maximum users seen in #haskell: 423, currently: 423 (100.0%), active: 13 (3.1%)
13:21:09 <lambdabot> Maximum users seen in #haskell: 423, currently: 423 (100.0%), active: 25 (5.9%)
13:21:29 <sorear> lambdabot2: @admin + dmwit
13:21:40 <shachaf> /quit is just a string.
13:21:40 <shachaf2> /quit is just a string.
13:21:43 <olsner> so, would @echo QUIT make the bot quit from irc then?
13:21:46 <dmwit> As much as I love \bot, it's mildly annoying to have two of them...
13:21:54 <dmwit> lambdabot2: ?part #haskell
13:21:55 <lambdabot2> Not enough privileges
13:21:55 <shachaf> olsner: No, it's still be a PRIVMSG.
13:22:19 <sorear> lambdabot2: @part #haskell
13:22:31 <dmwit> thx =)
13:22:43 <newsham> hot swappable dual redundant irc bots
13:22:59 <newsham> perhaps it would be useful for bots to detect each others presencen back back off?
13:23:10 <newsham> symmetrical multi-botting?
13:23:24 <olsner> self-organizing bot clusters
13:23:39 <Heffalump> that would seem the obvious solution
13:23:45 <Heffalump> they need a way to exchange state, too
13:23:56 <shachaf> How big are those #haskell.\w\w channels anyway?
13:24:08 <newsham> this is my bot, there are many like it, but this one is mine.
13:24:11 <Heffalump> 20 or 30 people typically
13:24:29 <Heffalump> oh, the country ones, sorry, not sure about them
13:24:36 <Heffalump> I was thinking of -blah and -overflow
13:26:52 <dons> 10-15 usually
13:26:55 <dons> ?users #xmonad
13:26:55 <lambdabot> Maximum users seen in #xmonad: 82, currently: 74 (90.2%), active: 9 (12.2%)
13:27:19 <newsham> ?users #haskell-sex
13:27:19 <lambdabot> Maximum users seen in #haskell-sex: 1, currently: 0 (0.0%), active: 0 (NaN%)
13:31:16 <oklopol> how do i convert a Double to GLdouble?
13:31:23 <sorear> realToFrac
13:31:35 <roconnor> @type realToFrac
13:31:37 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
13:32:35 <roconnor> ddarius: It is sooo much faster
13:32:36 <Heffalump> ?users
13:32:36 <lambdabot> Maximum users seen in #haskell: 423, currently: 420 (99.3%), active: 25 (6.0%)
13:32:45 <Heffalump> we're slipping, it seems
13:33:14 <oerjan> that's what you get for starting to cheat ;)
13:40:11 <LoganCapaldo> @index GLDouble
13:40:11 <lambdabot> bzzt
13:40:16 <LoganCapaldo> @index GLdouble
13:40:16 <lambdabot> Graphics.Rendering.OpenGL.GL.BasicTypes, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
13:40:31 <LoganCapaldo> OpenGL has it's own double?
13:41:07 <LoganCapaldo> whyfor?
13:42:11 <Syzygy-> LoganCapaldo: Because it implements its own set of datatypes, and the Haskell wrapper wraps that.
13:43:29 <dons> sorear: where did you get this idea that IO prevents unboxing?
13:43:33 <LoganCapaldo> Syzygy-: thanks, I assumed that. but why does OpenGL implement its own set of datatypes, specifically double>
13:43:40 <LoganCapaldo> ?
13:43:56 <dons> i can imagine extra RealWorld# possibly triggering cutoffs earlier
13:44:07 <dons> but I've not seen it prevent unboxing taking place
13:44:07 <sorear> dons: trac has a feature where if you subscribe to cvs-ghc@ you get emailed about new bugs
13:44:39 <sorear> @go site:hackage.haskell.org Unexpected boxing in generated code ndm
13:44:40 <lambdabot> No Result Found.
13:44:41 <dons> maybe there's some specific corner case, but not in general. /me tries to infer what sorear is hinting at
13:44:53 <dons> corner cases always exist in the heuristic-full ghc
13:45:08 <ddarius> roconnor: It's cool that you did benchmark it.
13:45:10 <sorear> it's pretty general, the unboxing system is turned off when it sees RealWorlds
13:45:10 <dons> ndm's case was a bit unusual, iirc
13:45:26 <ddarius> roconnor: Have you tried it with and without Endo [RNA]?  It should take no effort to change.
13:45:29 <dons> hmm, I'm not sure that's right.
13:45:39 <dons> e.g. bytestrings..
13:45:46 <sorear> only unusual insofar as he was doing heavy computation in IO
13:45:54 <conal> roconnor: what did you benchmark?
13:46:11 <sorear> consider  foo f x = do f; evaluate x
13:46:18 <sorear> foo is obviously strict in x
13:46:19 <ddarius> conal: http://r6.ca/blog/20071028T162529Z.html
13:46:19 <dons> you can certainly get the usual optimisations when in IO -- IO-heavy bytestring inner loops are always unboxed
13:46:20 <lambdabot> Title: Continuation Passing Style for Monads
13:46:29 <conal> ddarius: thanks
13:46:41 <dons> so i think you're making a general statement that's untrue, while it may be true for some corner case.
13:46:53 <sorear> but we must not optimize it!! consider foo (exitWith ExitSuccess) undefined
13:47:07 <newsham> hmm.. is it impossible to write church-encoding in typed lambdacalculus (ie. haskell)?
13:47:23 <dnm> Heh.
13:47:31 <mrd> newsham: you need recursive types, which are part of datatypes
13:47:43 <pgavin> newsham: if it's possible in any language, it's possible in Haskell
13:47:49 <sorear> newsham: it's not impossible, you just need to fix the answer type
13:47:51 <dons> sorear: i don't think that issue applies here. the code is strict enough that ghc just flattens the whole thing
13:47:51 <sorear> @k Cont
13:47:51 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
13:47:54 <sorear> @ki Cont
13:47:56 <oerjan> sorear: foo is not strict in x if f never terminates
13:48:02 <lambdabot> * -> * -> *
13:48:12 <dmwit> :k Cont
13:48:12 <dons> s/here/for the issue raised on the list/
13:48:13 <lambdabot> * -> * -> *
13:48:16 <sorear> dons: Have you checked -ddump-simpl?  If you have, I'll drop it.
13:48:17 <newsham> sorear: could you show a simple example?  ie. for http://hpaste.org/3507 ?
13:48:19 <dons> yes.
13:48:23 <dons> sorear: see my reply on the list
13:48:35 <dons> and half a year spent reading bytestring inner loops :)
13:48:43 <newsham> hey dnm.
13:49:03 <ddarius> type List a = forall b. (a -> b -> b) -> b -> b
13:49:09 <dnm> Howdy newsh.
13:49:50 <dons> dcoutts: can you think of a reason why i shouldn't tag list-0.1 and upload it to hackage?
13:49:59 <dons> did we only not do that due to anonymity requirements?
13:50:12 <dons> since i keep using the fusion lib, even without the extra sugar in base
13:51:12 <ddarius> nil c n = n; cons a as c n = c a (as c n)
13:51:28 <ddarius> :t \a as c n = c a (as c n)
13:51:30 <lambdabot> parse error on input `='
13:51:35 <ddarius> :t \a as c n -> c a (as c n)
13:51:36 <lambdabot> forall t t1 t2 t3. t -> ((t -> t2 -> t3) -> t1 -> t2) -> (t -> t2 -> t3) -> t1 -> t3
13:52:41 <ddarius> foldr c n [] = n;foldr c n (a:as) = c a (foldr c n as)
13:53:04 <ddarius> foldr for a Church-encoded list is just id.
13:53:30 <dons> sorear: there's a much more interesting issue working out why the fully unboxed/fused loop still runs 2-3x slower than naive C in this program
13:53:46 <dons> i didn't look too hard at the core, but there's something going slightly wrong
13:53:57 <oklopol> > [0.0, 0.1.. 1]
13:53:59 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
13:54:06 <oklopol> niec
13:55:17 <LoganCapaldo> stupid floats
13:55:39 <LoganCapaldo> > [0.0,0.1 .. 1] :: Rational
13:55:40 <lambdabot>  Couldn't match expected type `Rational' against inferred type `[a]'
13:55:49 <LoganCapaldo> > [0.0,0.1 .. 1] :: [Rational]
13:55:50 <lambdabot>  [0%1,1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1]
13:56:02 <pgavin> > [0, 1%10..1]
13:56:03 <lambdabot>  [0%1,1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1]
13:56:08 <dmwit> What was that crazy one that looked like it should be [0,1,2,3,4] but was actually [0,1,2] or something?
13:56:15 <LoganCapaldo> arg
13:56:16 <dmwit> > [0.0..5.0]
13:56:17 <lambdabot>  [0.0,1.0,2.0,3.0,4.0,5.0]
13:56:19 <LoganCapaldo> no, not those
13:56:48 <dmwit> hmm
13:57:23 <sorear> > [0%1, 1%1 .. 5%1]
13:57:24 <lambdabot>  [0%1,1%1,2%1,3%1,4%1,5%1]
13:57:34 <sorear> hm, not that one either
13:57:42 <sorear> > [0%10, 1%10 .. 1%1]
13:57:43 <lambdabot>  [0%1,1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1]
13:57:45 <newsham> ddarius: thank you
13:58:00 <bartw> > PI
13:58:01 <lambdabot>   Not in scope: data constructor `PI'
13:58:06 <LoganCapaldo> > pi
13:58:08 <lambdabot>  3.141592653589793
13:58:20 <bartw> and as rational ?
13:58:28 <TSC> > 22%7
13:58:30 <lambdabot>  22%7
13:58:30 <LoganCapaldo> you're funny :)
13:58:38 <LoganCapaldo> > pi :: Rational
13:58:39 <lambdabot>   add an instance declaration for (Floating Rational)
13:58:39 <lambdabot>     In the expression: ...
13:58:41 <hpaste>  newsham annotated "cps data structs?" with "fixed" at http://hpaste.org/3507#a1
13:58:59 <dmwit> > [1.0 .. 4.9]
13:59:01 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
13:59:04 <dmwit> Yow!
13:59:05 <dmwit> That was it.
13:59:11 <bartw> auch
13:59:22 <TSC> > approxRational pi 0.000000001
13:59:24 <lambdabot>  103993%33102
13:59:24 <bartw> > [0.99... .. 1.0]
13:59:24 <lambdabot>  Parse error at ".." (column 10)
13:59:30 <bartw> doh
13:59:38 <ddarius> newsham: In general, you need rank-2 types if you want to pass Church-encoded lists around.
13:59:39 <sieni> > [1.0 .. 4.1]
13:59:40 <lambdabot>  [1.0,2.0,3.0,4.0]
13:59:44 <sieni> > [1.0 .. 4.5]
13:59:46 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
13:59:50 <sieni> > [1.0 .. 4.49]
13:59:50 <ddarius> E.g. if you want to write reverse.
13:59:51 <lambdabot>  [1.0,2.0,3.0,4.0]
13:59:53 <dmwit> sieni: It must be rounding?
14:00:02 <sieni> I guess so
14:00:05 <shachaf> > 355%113
14:00:06 <lambdabot>  355%113
14:00:15 <dmwit> > [1 .. 49%10]
14:00:17 <lambdabot>  [1%1,2%1,3%1,4%1,5%1]
14:00:20 <dmwit> heh
14:00:30 <LoganCapaldo> @type approxRational
14:00:30 <bartw> you would expect a <= for the last case
14:00:31 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
14:00:34 <sieni> [1.0, 1.1 .. 1.45]
14:00:41 <sieni> > [1.0, 1.1 .. 1.45]
14:00:42 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004]
14:00:51 <sieni> > [1.0, 1.1 .. 1.49]
14:00:53 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
14:01:02 <sieni> > [1.0, 1.1 .. 1.451]
14:01:02 <dmwit> buh
14:01:03 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
14:01:10 <dmwit> > 1.45
14:01:12 <lambdabot>  1.45
14:01:24 <dmwit> > [1.0 .. 4.5]
14:01:25 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
14:01:33 <dmwit> Why wouldn't 1.45 round to 1.5 in that one?
14:01:49 <sieni> dmwit: I guess 1.45 isn't exactly representable as a float
14:01:52 <bartw> rounding to a fractionpart ?
14:02:00 <dmwit> > [2.0, 2.1 .. 2.45]
14:02:01 <lambdabot>  [2.0,2.1,2.2,2.3000000000000003,2.4000000000000004]
14:02:18 <newsham> ddarius: does this definition of "cons" limit you to primitive recursion?
14:02:28 <bartw> > [2.0, 2.1 .. 2.4501]
14:02:30 <lambdabot>  [2.0,2.1,2.2,2.3000000000000003,2.4000000000000004,2.5000000000000004]
14:02:33 <bartw> righty
14:02:50 <ddarius> newsham: Yes and no.
14:02:51 <dmwit> That is a very strange feature.
14:02:51 <sieni> nor 2.45, since 0.45 = 9/20, whose denominator has other factors than 2
14:02:54 <bartw> wonder how this is defined, smells like a bug
14:03:17 <newsham> ddarius: thanks for the clarification ;-)
14:03:17 <dmwit> bartw: Apparently it's in the report.
14:03:22 <dmwit> (According to my #haskell logs.)
14:03:24 <ddarius> newsham: You should still be able to use the general recursion in the language to get general recursion, but using only the representation, it can only do foldrs.
14:04:03 <bartw> dmwit: so it is be design ?
14:04:06 <ddarius> newsham: In particular, that definition is completely doable in the second-order polymorphic lambda calculus which is strongly normalizing.
14:04:06 <newsham> ddarius: my original definition (which doesnt type check) more closely parallels the original code and seems to be more flexible.. is there any way to fit it into the type system?
14:04:15 <bartw> rounding 0.5 down is not what i would expect
14:04:40 <bartw> hmz
14:04:40 <newsham> I'm not terribly familiar with "second-order" types/polymorphic lambda calculus and no idea about "strongly normalizing"
14:04:41 <shachaf> > round 1.5
14:04:42 <lambdabot>  2
14:04:52 <Shurique> > round 2.5
14:04:52 <shachaf> > round 2.5
14:04:54 <lambdabot>  2
14:04:54 <lambdabot>  2
14:05:01 <bartw> ah right
14:05:06 <bartw> now it makes sense
14:05:10 <ddarius> newsham: Your original definition is a Church encoding of Maybe effectively and from there you represent lists essentially as List a = Maybe (a,List a)
14:05:26 <bartw> this is a bad way to reduce offset due to rounding
14:05:39 <mrd> sums and recursive types, essentially
14:05:41 <sieni> > [1.0, 1.1 .. 1.35]
14:05:43 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003]
14:05:50 <sieni> what about that
14:05:56 <sieni> > [1.0, 1.1 .. 1.351]
14:05:57 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004]
14:06:01 <ddarius> newsham: The second order polymorphic lambda calculus is an impressive thing and strongly normalizing implies everything terminates.
14:06:02 <sieni> > round 3.5
14:06:04 <lambdabot>  4
14:06:31 <LoganCapaldo> no halting problem
14:06:39 <bartw> it rounds some .5 up and some down to reduce cummulative errors
14:06:48 <LoganCapaldo> we should all just program in the second order polymorphic lambda calculus
14:07:04 <LoganCapaldo> mmm
14:08:09 <newsham> first step: learn wtf that means ;-)
14:08:26 <newsham> sounds like another red pill i should probably avoid
14:08:38 <newsham> but will probably end up swalling anyway
14:08:59 <oerjan> > "System "++fix('F':)
14:09:00 <lambdabot>  "System FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...
14:09:17 <ddarius> newsham: It shouldn't really be much of a problem if you are comfortable with Haskell and it's type system.
14:09:20 <LoganCapaldo> where's the omega at?
14:09:36 <oklopol> lambdabot is a much more fun interpreter than my ghc, if i test something on ghc, i get a result, here i get the result, and tons of fun watching people start playing with whatever i tested :P
14:10:13 <LoganCapaldo> #haskell - programming as collaborative artwork
14:10:17 <newsham> but people keep erasing your ?let's, and you cant define types and doing multi-line examples is a pain
14:10:29 <newsham> maybe there should be a #haskell-interactive
14:10:39 <newsham> devoted to code running and comments
14:10:47 <EvilTerran> everyone gets their own module
14:10:57 <shachaf> Maybe there should be a #haskell Obby session.
14:11:03 <EvilTerran> EvilTerran.foo :D
14:11:09 <newsham> ET: as long as I can Import EvilTerran
14:11:09 <LoganCapaldo> I don't want my own module. I want Oleg's module :)
14:11:30 <newsham> #haskell-byoc
14:11:35 <newsham> bring-your-own-code
14:11:43 <EvilTerran> what's obby?
14:12:19 <LoganCapaldo> opensource subethaedit IIRC
14:12:36 <newsham> group interactive programming, the new frontier in online multi-user entertainment?
14:13:26 <LoganCapaldo> I think it was named obby so that you could feel clever when linking the library
14:13:36 <shachaf> EvilTerran: A multi-user text editing protocol.
14:14:05 <EvilTerran> like one of those java doodads where you can collaborate on a drawing in realtime, only code? that'd be cool
14:14:06 <LoganCapaldo> ld -o myeditor myeditor.o -lobby
14:15:03 <dmwit> Should have been called "ink". ;-)
14:16:40 * EvilTerran sets about banging his head against some deathly boring OO classwork
14:16:48 <EvilTerran> everyone loves Java!
14:16:55 <dmwit> =(
14:17:00 <Heffalump> it's good for the soul.
14:17:08 <Heffalump> helps build character, that sort of thing
14:17:09 <dmwit> I just started learning Java last night for an OO class.
14:17:19 <EvilTerran> especially when you tell 'em to implement the same abstract data type five different ways, just to drive home the point of abstraction!
14:17:25 <EvilTerran> >.<
14:17:33 <dmwit> Java/C/C++/Python... they're all the same, in the hands of a sane programmer.
14:17:50 <Taejo> Does anybody here know anything about image registration or optical mark recognition, perchance?
14:18:04 <sorear> Taejo: Yes.
14:18:35 * shachaf wishes vim had obby bindings.
14:18:35 <Taejo> sorear, can you point me in the direction of some good resources? Papers, implementations?
14:18:35 <ddarius> Something like what EvilTerran said seems like an appropriate solution.
14:18:35 <ddarius> Mainly @undefine needs to not undefine everything
14:18:42 <shachaf> Emacs has something, I think.
14:18:42 <sorear> Taejo: No.
14:18:50 <sorear> Taejo: I know *almost* ntohing.
14:18:58 <Taejo> oh, ok
14:19:19 * EvilTerran finally gets around to installing gvim locally
14:19:38 <olsner> java in gvim? ouch!
14:19:55 <sorear> dons: yep, we seem to have quite good C at the STG layer; the simplifier and coreprep are working well
14:20:08 <dons> sorear: hmm, did you compare against a C program?
14:20:13 <sorear> dons: what's the status of the project to make stg2cmm not suck?
14:20:31 <hpaste>  dons pasted "something .c" at http://hpaste.org/3508
14:20:34 <EvilTerran> olsner, the IDE they want us to use is significantly more painful, especially for someone accustomed to vim
14:20:43 <mrd> java has forever tarnished the name of a perfectly good island
14:20:46 <EvilTerran> (bluej, to be specific)
14:21:11 <newsham> there's always sumatra and toba
14:21:23 <olsner> for java, you really need a proper IDE to cut through the boilerplate code
14:21:30 <dons> sorear: well, we have a new register allocator, and normal ramsay rewrote the C-- layer
14:21:39 <dons> sorear: so i think its heading towards sucking less
14:21:41 <EvilTerran> the input method is quirky enough to be a pain, and it's nowhere near IDE-y enough to be worth getting the hang of it
14:22:19 <dons> sorear: did you see the final stream fusion program with mapM_ -- nice that the entire program fuses. i love when that happens
14:22:58 <sorear> yes
14:23:10 <dons> we really want base compiled against the fusible defintiions of lists though
14:23:22 <dons> rather than having to reimplement them to use Data.List.Stream.foldr and friends
14:24:03 <sorear> the main problem with the new C-- work is that it can't fix the mess codegen makes
14:24:22 <sorear> that nice loopy Stg turns into a bunch of stack munging
14:24:23 <mrd> ghc will turn into a thermonuclear weapon if this fusion trend continues
14:24:43 <sorear> when it could just turn into a Cmm program with a few variables
14:24:52 <olsner> EvilTerran: hmm... so use eclipse instead?
14:24:54 <sorear> hmm...
14:25:09 * sorear tries to install GHC 6.9
14:25:12 <ddarius> dons: How fast does the mapM_ version run?
14:25:41 <dons> ddarius: only marginally faster
14:25:44 <sorear> dons: what do you want to know about that C program?
14:26:02 <dons> sorear: is it 3-4x faster than the fused (or manual) haskell one on your machine?
14:26:05 <dons> with -Onot
14:26:35 <sorear> all the Haskell ones are about 1.5s with -O2
14:26:47 <dons> right, i get 1.25s here
14:26:54 <dons> while the C programs was 0.3s
14:27:42 <dons> though i guess that fits this similar benchmark, http://shootout.alioth.debian.org/gp4/benchmark.php?test=recursive
14:27:44 <sorear> handfused -O0 is 19.7s
14:27:44 <lambdabot> Title: recursive benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/yrp7xm
14:28:06 <dons> sorear: no, the C program, with -O0, on your arch
14:28:11 <dons> what does it do?
14:28:17 <sorear> 0.87
14:28:25 <dons> oh, ok. that's not so bad then
14:28:53 <sorear> 0.83 at -O2 :)
14:28:53 <dons> 2x is satisfactory, given the C program is manually compiled, in effect
14:29:05 <phyrephox> hello
14:29:07 <dons> cute
14:29:14 <phyrephox> are you not allowed to use type synonyms in instance declarations?
14:29:22 <dons> phyrephox: its a ghc extension
14:29:25 <dmwit> phyrephox: You can, but its a GHC extension.
14:29:42 <dmwit> -fglasgow-extensions, or somebody will point you to the appropriate LANGUAGE pragma.
14:29:44 <phyrephox> why can't you in haskell98?
14:29:48 <oklopol> hmm, is the only way to get something out of a 3-tuple to pattern match on it?
14:29:53 <sorear> phyrephox: because it leaks information
14:29:54 <oklopol> > (1,2,3)!2!
14:29:55 <lambdabot>   parse error on input `}'
14:29:55 <sorear> oklopol: yes
14:29:56 <dmwit> oklopol: Yep.
14:29:59 <oklopol> > (1,2,3)!!2
14:29:59 <oklopol> yeah
14:30:00 <lambdabot>  Couldn't match expected type `[a]'
14:30:13 <dmwit> I usually define frst, scnd, thrd if I'm working with triples.
14:30:16 <oklopol> > (\(_,a,_)->a) (1,2,3)
14:30:17 <lambdabot>  2
14:30:21 <phyrephox> do not understand ;_;
14:30:22 <phyrephox> thank you though
14:30:37 <dmwit> (Likewise first, secnd, third, forth for quadruples, but it fails at quintuples. =)
14:31:07 <oklopol> hmm, how about 3-tuples? (trituples?)
14:31:22 <Syzygy-> oklopol: triples? :)
14:31:37 <oklopol> errrrr perhaps!
14:31:50 <dmwit> oklopol: let frst (a, _, _) = a; scnd (_, b, _) = b; thrd (_, _, c) = c in ...
14:32:28 <dmwit> oklopol: Or, you could define a record type.
14:33:18 <oklopol> i wanna print a (GLint, GLint)... what's the nicest way :|
14:33:52 <oklopol> (\(a,b) -> show a ++ " " ++ show b) ...
14:33:53 <oklopol> ?
14:33:54 <dmwit> Is GLInt a show?
14:34:00 <oklopol> hmm
14:34:01 <oklopol> prolly not...
14:34:03 <dmwit> No, just show (a, b) is fine.
14:34:07 <oklopol> can i convert that to integer?
14:34:35 <dmwit> You should "instance Show GLint where ..." then.
14:34:39 <dmwit> That will be the easiest in the long-run.
14:34:44 <oerjan> oklopol: it probably is because Num implies Show
14:35:12 <oklopol> it won't just show the tuple just like that
14:35:21 <dmwit> What's the error?
14:35:24 <oerjan> > show (1,2)
14:35:25 <lambdabot>  "(1,2)"
14:35:34 <Syzygy-> GLint is declared by a type GLint = Int32
14:35:42 <Syzygy-> Does type mean that it inherits instances?
14:35:52 <mrd> it means its a straight up alias
14:35:52 <dmwit> Yeah.
14:35:58 <EvilTerran> it means they're exactly equivalent
14:36:01 <Syzygy-> Because Int32 definitely has Show.
14:36:07 <dmwit> Syzygy-: Not a newtype?
14:36:11 <oklopol> whooops it was still on the IORef monad
14:36:20 <mrd> substitute Int32 for GLint whenever you see it
14:36:34 <Syzygy-> dmwit: Not according to the docs, no.
14:36:39 <Syzygy-> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-BasicTypes.html#t%3AGLint
14:36:40 <dmwit> ok
14:36:41 <lambdabot> http://tinyurl.com/329a3e
14:37:00 <Syzygy-> Also GLdouble is an alias for Double.
14:38:08 <oklopol> drawing is done in a scaled fashion so that the screen is (-1...1, -1...1) in opengl, and mouse position is given in pixels, how should i handle this? do i check the windows size and do some divisionizing or what?
14:38:15 <oklopol> i mean
14:38:27 <oklopol> if i wanna, say, draw something as a "cursor"
14:39:21 <mrd> you need to unproject
14:39:45 <mrd> and read about projections in general
14:39:48 <oklopol> is there a nice funxxion for that or should i just do it manualle?
14:39:48 <mrd> @go opengl red book
14:39:51 <lambdabot> http://fly.cc.fer.hr/~unreal/theredbook/
14:39:51 <lambdabot> Title: OpenGL Programming Guide (Addison-Wesley Publishing Company): Table of Contents
14:39:52 <oklopol> *manually
14:39:59 <oklopol> :O
14:40:01 <mrd> glu has a function for that but oyu need to read some chapters in that
14:40:15 <oklopol> but... i'd have to read!
14:46:32 <oklopol> mrd: what exactly should i read there? i just need to draw a few lines on the screen, so i don't really feel like going into opengl's magic quite yet :P
14:46:38 <phyrephox> if i have a class Unpackable a, and instances Unpackable String and (Unpackable a) => Unpackable [a], how do i get the compiler to choose the more specific version?
14:49:50 <dmwit> If you want H98, you could newtype PackedString or so.
14:50:22 <EvilTerran> otherwise, overlapping-instances and voodoo
14:50:26 <dmwit> But, do you have instance Unpackable Char?
14:50:30 <phyrephox> no
14:50:33 <dmwit> If you don't, there's no conflict, right?
14:50:55 <EvilTerran> dmwit, you get overlapping instances complaints anyway, iirc
14:50:56 <oerjan> you could use the same trick as in Show
14:51:02 <phyrephox> i dunno, when i try to use Unpackable String, GHC bugs out about "no instance for Unpackable Char"
14:51:16 <phyrephox> oerjan, what trick is that?
14:51:31 <twanvl> class Unpackable a where unpak :: a -> Something, unpackList :: [a] -> Something
14:51:36 <dmwit> phyrephox: Even when you have added "instance Unpackable String"?
14:51:39 <oerjan> phyrephox: there is a showList method, which is defined specially for Char
14:51:52 * dmwit tests
14:52:17 <oerjan> and the instance for [a] uses the showList method for a
14:52:25 <phyrephox> dmwit, yes
14:52:40 <phyrephox> oerjan, hmm, i don't think that would work for me though
14:53:13 <phyrephox> is the only option to create a new type?
14:53:22 <oerjan> i guess if you _cannot_ make Char unpackable
14:53:33 <opqdonut> ocaml isn't lazy, right?
14:53:49 <oerjan> opqdonut: no but there are promises iirc
14:54:15 <opqdonut> oerjan: ok :)
14:54:21 <phyrephox> yeah ok i'll make a new type
14:54:22 <phyrephox> thanks alot!
14:54:25 <opqdonut> (how will they handle side-effects?)
14:54:33 <dmwit> phyrephox: I don't see the same problem you do.
14:54:53 <oerjan> opqdonut: ocaml isn't pure either
14:54:53 <twanvl> You could make a different class, but then you would need an instance for each type of which a list is unpackable
14:54:59 <dmwit> phyrephox: Never mind, yes I do. =P
14:55:03 <opqdonut> oerjan: indeed
14:55:13 <opqdonut> i can't see how impure laziness would work
14:55:14 <phyrephox> hehe :D
14:55:25 <oerjan> i think promises are evaluated the first time they are forced
14:55:51 <oerjan> which is done explicitly
14:56:01 <oerjan> as i think they are just a wrapper around a Ref
14:58:14 <paczesiowa> does anyone have haskell code to upload image to imageshack or some other images hostinh website?
15:00:04 <oklopol> i don't get why i should read that... i just need to get mouse position :|
15:00:23 <oklopol> hmm... why don't i just find out what the window size is? what a clever idea
15:00:52 <EvilTerran> you don't have to read all of it; it should be fairly easy to locate the information you need
15:01:06 <dons> paczesiowa: just over http? grab the http library off hackage.haskell.org
15:03:43 <dons> ?users
15:03:44 <lambdabot> Maximum users seen in #haskell: 423, currently: 406 (96.0%), active: 12 (3.0%)
15:05:32 <paczesiowa> dons: curl is much better than that http package, but it's still a lot of boring work to do, and I thought that someone already did that
15:06:05 <dons> paczesiowa: the libcurl package is on code.haskell.org/curl
15:06:10 <dons> so you could use that if you know the curl api
15:06:26 <dons> or perhaps now is the time to wrap the curl binding to do easy upload and downloads!
15:08:44 <ADEpt> Hey, need a quick help with lambdabot: Got it form darcs, compiled, did "Setup install" and now when I do "echo 1+1 | runplugs" it complains that it cant found the ShowQ.hs anywhere. From what I see, I shoudl probably do a cabal package out of ShowQ and ShowFun modules, or something, but if it's not described in lambdabot.cabal, then i'm doing something wrong ... Please help me out
15:09:44 <oerjan> shouldn't that be echo "> 1+1" or something like that? (just a guess)
15:10:33 <paczesiowa> dons: have you seen this? http://varsztat.com/projects/curl/ I think it looks better, there are wrappers for easy download, just no uploads. besides uploading to imageshack still requires to parse output to get links
15:10:33 <lambdabot> Title: Haskell bindings for libcurl
15:10:37 <ADEpt> oerjan: well, "> 1+1" runs runplugs behind the scenes, so I'm testing by running runplugs by hand
15:10:48 <oerjan> aha
15:11:16 <phyrephox> okay, actually, going back to my question before about overlapping instances, is there an extension that would make GHC choose the most specific instance declaration?
15:11:26 <phyrephox> or could anyone point me to some documentation on the extensions?
15:11:36 <oerjan> maybe it's something from hsplugins
15:13:53 <dons> paczesiowa: haven't seen that.
15:13:56 <dons> looks good
15:14:06 <conal> ?index Extension
15:14:06 <lambdabot> Distribution.Extension, Distribution.Simple
15:14:12 <conal> ?doc
15:14:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:14:51 <ADEpt> oerjan: would it :) shoud've used "build.sh" from lambdabot sources.
15:14:59 <conal> phyrephox: http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html
15:15:01 <lambdabot> http://tinyurl.com/2b93uq
15:15:23 <oerjan> good :)
15:15:29 <paczesiowa> dons: it's desp's gsoc, but he's lazy so documentation still isn't finished
15:15:36 <phyrephox> is there a page that describes what each extension does?
15:15:58 <conal> phyrephox: i think i've seen one, perhaps on the ghc wiki
15:16:40 <twanvl> the GHC user guide is a good place to look, but it doesn't give the official extension names
15:16:50 <conal> maybe that's what i saw
15:17:00 <phyrephox> ok thanks
15:20:05 <desp> gah
15:20:22 <paczesiowa> :>
15:20:31 <desp> paczesiowa: you!
15:20:42 <paczesiowa> desp: bite me!
15:22:09 <oklopol> > fromInt 8
15:22:10 <lambdabot>   Not in scope: `fromInt'
15:22:19 <oklopol> blah i'm being lied to!
15:22:58 <oklopol> or then i'm just failing
15:23:02 <omnId> > fromIntegral 8 :: Complex Double
15:23:03 <lambdabot>  8.0 :+ 0.0
15:23:06 <twanvl> There is no fromInt, only fromInteger and fromIntegral
15:23:11 <oklopol> oh.
15:23:30 <oklopol> > (fromInteger 8)::Double
15:23:31 <lambdabot>  8.0
15:24:42 <oklopol> but... what if i have a GLint?
15:24:47 <oklopol> or Int32
15:24:50 <oerjan> fromIntegral
15:25:07 <omnId> @type fromIntegral
15:25:09 <lambdabot> forall a b. (Num b, Integral a) => a -> b
15:25:16 <oklopol> Integral? :|
15:25:22 <oklopol> i assumed that has to do with integration
15:25:23 <oklopol> :P
15:26:00 <oerjan> @slap oklopol
15:26:00 * lambdabot activates her slap-o-matic...
15:26:06 <omnId> @instances-importing Graphics.Rendering.OpenGL.GL.BasicTypes Integral
15:26:07 <lambdabot> Int, Integer
15:26:37 <oklopol> oerjan: it could've!
15:26:43 <omnId> type GLint = Int32
15:26:50 <omnId> @instances-importing Data.Int Integral
15:26:51 <lambdabot> Int, Int16, Int32, Int64, Int8, Integer
15:27:02 <oklopol> > Int32 4
15:27:03 <lambdabot>   Not in scope: data constructor `Int32'
15:27:06 <oklopol> errrr
15:27:10 <omnId> > 4 :: Int32
15:27:11 <oklopol> > 4 ::Int32
15:27:11 <lambdabot>  4
15:27:12 <lambdabot>  4
15:27:23 <oklopol> darn, i'm never quick enough to fix my code before you do ;)
15:27:36 <oklopol> well, i guess i won by half a second
15:27:55 <oerjan> not on my screen
15:27:57 <omnId> I won on my end.
15:28:09 <oklopol> :<
15:28:11 <omnId> let's just say we both won.
15:28:23 <oklopol> yeah, candy all around!
15:28:44 <oklopol> anyways, how long till i start not making type errors every 0.5 minutes? ;)
15:29:10 <omnId> you long have you done Haskell?
15:29:19 <oklopol> doing my second program
15:29:29 <omnId> at least your fourth or fifth :)
15:29:34 <oklopol> did a thue interpreter about 4 months ago (oerjan helped :P)
15:30:16 <conal> yo seafood_
15:30:20 * EvilTerran had a random thought earlier; whether perhaps such things as Prelude.(2 + 3) might be nicer than (2 Prelude.+ 3) for qualified infix ops
15:30:41 <oerjan> http://esolangs.org/wiki/Thue
15:30:43 <lambdabot> Title: Thue - Esolang
15:31:02 <omnId> EvilTerran: so Module.(expression) you qualify all ambiguous names to Module?
15:31:13 <EvilTerran> well, that'd work
15:31:15 <conal> oklopol: what's your current haskell project?
15:31:29 <EvilTerran> i was thinking it would just qualify the outermost operator of (expression) with Module.
15:31:49 <omnId> hmm, maybe
15:31:55 <oerjan> EvilTerran: it may actually be ambiguous which operator that is
15:32:02 <EvilTerran> it shouldn't be
15:32:06 <omnId> Data.Array.(table ! i)
15:32:21 <EvilTerran> once fixities're resolved, at least
15:32:25 <oerjan> since different modules can declare different fixities for the same name
15:32:35 <EvilTerran> ah. didn't think of that.
15:32:51 <omnId> tricksy fixities
15:32:54 <EvilTerran> omnId's idea might work better, then
15:33:07 <oerjan> don't worry.  the people who wrote the haskell report didn't think about such matters either.
15:33:50 <EvilTerran> although ambiguous names anywhere seem to be against the style of the current module system
15:35:21 <EvilTerran> but i do get the impression that the consensus is that the current system is pretty broken, so that's not really a problem ;)
15:36:17 <oklopol> conal: making a program for drawing electrical circuits
15:36:26 <oklopol> i think that's a nice second program
15:37:16 <conal> oklopol: oh, nifty.  is it 2D or 3D?
15:37:25 <oklopol> 2d, at least first
15:37:35 <oklopol> snapping wires might be ugly in 3d.
15:37:45 <conal> oklopol: so why opengl?
15:37:56 <oklopol> sdl was hard to install :P
15:38:01 <conal> oh!
15:38:11 <oklopol> and... those two were the only one i was hinted to use
15:38:12 <oklopol> *ones
15:38:48 <conal> oklopol: there's also cairo (currently bundled with gtk2hs)
15:38:56 <conal> no personal experience.
15:39:01 <oklopol> luckily i'm almost at the point where i can actually start making the functionality, currently it just draws the grid... :P
15:39:16 <conal> oklopol: cool.
15:39:28 <conal> does opengl have 2D primitives?
15:39:55 <oklopol> i don't feel like changing anymore, i think i may get this working, and that's enough for me, i don't care if i'm using a train to kill a fly
15:40:05 <oklopol> yeah
15:40:42 * oklopol wonders if he should've used a real saying, and not invent a new one...
15:41:09 * conal is glad for opengl expertise on this channel.
15:41:40 <EvilTerran> "using a sledgehammer to crack nuts"?
15:42:09 <olsner> "using XML to store data"?
15:42:11 <conal> "using a phaser to highlight a bullet point"
15:42:28 <kaol> why does using "reverse" in my function make me feel like a real FP coder?
15:42:29 <EvilTerran> yeah, but mine's an actual idiom, so nyah. :P
15:42:55 <EvilTerran> kaol, no idea. even perl's got reverse!
15:42:57 <oklopol> glah okay, i just can't fix this, it seems; trying to get a (Double,Double) out of two (GLint,Glint)'s, doing a projection (== division) on them
15:43:29 <oklopol> basically i need to get Int32/Int32 -> Double
15:43:37 <oklopol> somehow that's too hard for me :D
15:43:41 <conal> oklopol: apply fromIntegral to each
15:43:44 <conal> then divide
15:43:55 <oklopol> mousePos $= (((fromIntegral x)::Double)/sx,((fromIntegral y)::Double)/sy)
15:44:00 <oklopol> this is what i have :P
15:44:03 <EvilTerran> so you want :: (GLint,Glint) -> (GLint,Glint) -> (Double,Double)
15:44:04 <EvilTerran> ?
15:44:14 <oklopol> well, yeah
15:44:42 <EvilTerran> ?pl \x y -> fromIntegral x / fromIntegral y
15:44:43 <lambdabot> (. fromIntegral) . (/) . fromIntegral
15:45:17 <oerjan> (/) `on` fromIntegral
15:45:23 <omnId> oklopol: what type are sx and sy?
15:45:26 <conal> oerjan: nice one
15:45:32 <oklopol> mousePos $= (((fromIntegral x)::Double)/((fromIntegral sx)::Double),((fromIntegral y)::Double)/((fromIntegral sy)::Double)) works now
15:45:41 <oklopol> but... that's not as pretty as i'd like :\
15:45:41 <EvilTerran> ?type on
15:45:41 <conal> ?type on
15:45:42 <lambdabot> Not in scope: `on'
15:45:43 <lambdabot> Not in scope: `on'
15:45:47 <conal> :)
15:45:51 <oerjan> @src on
15:45:51 <lambdabot> (*) `on` f = \x y -> f x * f y
15:45:58 <EvilTerran> > on
15:45:58 <lambdabot>   Not in scope: `on'
15:46:01 <omnId> oklopol: the inner parens aren't necessary.  Type annotations extend all the way left and right.
15:46:05 <EvilTerran> ?let (*) `on` f = \x y -> f x * f y
15:46:08 <lambdabot> Defined.
15:46:40 <omnId> oklopol: you could also define a shorthand fromIntegral: let i2n x = fromIntegral x
15:47:10 <EvilTerran> > uncurry $ (***) `on` ((/) `on` fromIntegral)
15:47:11 <conal> oklopol you can type-annotate after dividing rather than before.  saves you a bit.
15:47:12 <lambdabot>  <(Integer,Integer) -> (Integer,Integer) -> (Double,Double)>
15:47:16 <oklopol> hmm, i'll do that, haskell is so pretty i don't need a long line cluttering it
15:47:32 <omnId> (i2n x / i2n sx, i2n y / i2n sy) :: (Double, Double)
15:47:36 <conal> EvilTerran: yow!
15:47:41 <EvilTerran> :D
15:48:01 <oklopol> hmm, i take it doing the type annotation after division wont crappify the result like it would in C?
15:48:18 <conal> oklopol: right, it won't.
15:48:22 <omnId> oklopol: it's still Doubles throughout.
15:48:23 <oerjan> oklopol: won't make a difference
15:48:35 <EvilTerran> ?type (/) -- returns the same type as its parameters; type inference can go backwards, too
15:48:37 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:48:37 <conal> Doubles all the way up
15:48:40 <omnId> oklopol: the annotation doesn't do any converting, just the i2n.
15:48:55 <oklopol> oh, i get it now
15:49:00 <oklopol> i think ;)
15:49:03 <omnId> the annotation just tells the compiler which fromIntegral to use.
15:49:26 <oerjan> > on id
15:49:27 <lambdabot>      Occurs check: cannot construct the infinite type: t1 = t1 -> t2
15:49:27 <lambdabot>     Prob...
15:49:39 <EvilTerran> what
15:49:55 <oerjan> oh right
15:50:00 <EvilTerran> oh, i see
15:50:04 <EvilTerran> > (`on` id)
15:50:05 <lambdabot>  Add a type signature
15:50:09 <omnId> oklopol: what type is sx and sy?  Maybe you should define those as Doubles so you don't need to fromIntegral them.
15:50:24 <dcoutts> dons: no, go ahead, upload list-0.1
15:50:44 <oklopol> mousePos $= (i2n x/i2n sx,i2n y/i2n sy) it got pretty!
15:50:46 <oerjan> oklopol: surely there is some builtin function to do this already.
15:50:48 <oklopol> ..er
15:50:50 <conal> EvilTerran: I saved your double `on` example in my journal.  a gem!
15:51:04 <oklopol> omnId: i don't wanna, since they're always integers
15:51:05 <EvilTerran> wow, thanks :D
15:51:58 <omnId> oklopol: they're made into Doubles anyway in that expression, so unless they're used elsewhere that needs integers...
15:52:01 <dons> sjanssen: i'll dump a local Control.Monad and Enum in there too, I think
15:52:09 <dons> so you can import all the required primitives
15:52:36 <oklopol> omnId: i know that, i just like my integers to be integers :)
15:52:42 <omnId> pah
15:52:44 <dons> dcoutts: remember you wrote a fusible filterM
15:53:03 <dcoutts> dons: I don't remember :-)
15:53:12 <oklopol> omnId: it doesn't save *that* many characters...
15:54:15 <sjanssen> dons: huh, what are we talking about?
15:54:55 <dons> sjanssen: oh, sorry. braino
15:55:02 <dons> s/sjanssen/dcoutts/
15:55:14 <dons> i forget who i worked with on each project :)
15:55:18 <dcoutts> :-)
15:55:27 <sjanssen> I wrote a foldr/build fusible filterM at one point
15:55:51 <sjanssen> it wasn't incorporated due to semantic differences
15:57:02 <dons> oh, yes, i remember that
15:57:14 <sjanssen> dcoutts, dons: you have to be careful with filterM, the efficient method isn't compatible :(
15:57:41 <dcoutts> sjanssen: tell me more
15:57:49 <sjanssen> @src filterM
15:57:49 <lambdabot> Source not found. Just try something else.
15:58:19 <sjanssen> filterM p (x:xs) =  do
15:58:19 <sjanssen>    flg <- p x
15:58:19 <sjanssen>    ys  <- filterM p xs
15:58:19 <sjanssen>    return (if flg then x:ys else ys)
15:59:19 <dcoutts> right
15:59:21 <dcoutts> that's a foldr
15:59:34 <dons> http://programming.reddit.com/info/5zbb3/comments/
15:59:36 <lambdabot> Title: programming: hswm: a window manager in Haskell with a plugin architecture, and a ...
15:59:38 <sjanssen> mine was something like: filterM p (x:xs) = do flg <- p x; if flg then filterM p xs else fmap (x:) (filterM p xs)
15:59:53 <sjanssen> dcoutts: those have slightly different behavior when f returns _|_
16:00:16 <dcoutts> sjanssen: and you think one is fusible and the other is not?
16:00:37 <sjanssen> dcoutts: however, the second uses less stack space: linear wrt. the result rather than linear wrt. the input
16:00:46 <sjanssen> dcoutts: nah, they're both fusible
16:01:07 <dcoutts> sjanssen: ok. I don't see the difference when p returns _|_
16:01:07 <sjanssen> s/when f/when p
16:01:21 <dcoutts> oh, hmm, maybe I do
16:01:46 <dcoutts> we look at the result before/after doing xs
16:02:19 <sjanssen> right
16:02:31 <sjanssen> I guess it isn't _|_, but return _|_
16:02:41 <dcoutts> sjanssen: it's not clear to me that it's got linear stack space
16:02:52 <dcoutts> sjanssen: the >>= is still in the tail call position
16:02:59 <dcoutts> in both version
16:03:17 <dcoutts> so it depends on the >>= and if we inline it if we can get a tail recursive version
16:03:28 <sjanssen> dcoutts: the problem is (if flg then x:ys else ys)
16:03:47 <sjanssen> I don't think ghc can rearrange that?
16:03:48 <dcoutts> oh because that's not strictly evaluated
16:03:49 <huamn_> is there ANY way to do non-blockable UDP-sockets with haskell? Network.Socket.sIsReadable does not seem to work and setting socket option RecvTimeOut results in an error?
16:04:11 <huamn_> even though i receive data to the socket, the sIsReadable always returns false
16:04:47 <huamn_> I wouldn't like to block forever in the reading function if there is no data available (because I have to do retransmission after a certain timeout)
16:04:57 <dcoutts> sjanssen: it could evaluate it strictly I suppose
16:05:07 <sjanssen> dcoutts: I made some tests that show this behavior occurs in practice
16:05:34 <dcoutts> sjanssen: ok
16:05:58 <sjanssen> dcoutts: http://www.haskell.org/pipermail/libraries/2006-August/005630.html is the beginning of the thread
16:06:00 <lambdabot> Title: darcs patch: Improve Control.Monad.filterM:, http://tinyurl.com/2yz2wz
16:06:41 <schemelab> there was a paper that showed all the things you could do with fold... I'm assuming it showed how to implement scan with it... could someone point me to that paper please?
16:07:50 <sjanssen> I'm trying to remember the title
16:08:07 <sjanssen> "On the something something of fold", IIRC
16:08:44 <oerjan> @go on-the of-fold
16:08:47 <lambdabot> http://www.cs.nott.ac.uk/~gmh/fold.pdf
16:08:55 <EvilTerran> clever
16:09:03 <sjanssen> oerjan++
16:09:13 <schemelab> oerjan: thanks :)
16:14:23 <oklopol> > toInt 0.5
16:14:24 <lambdabot>   Not in scope: `toInt'
16:14:27 <oklopol> > toInteger 0.5
16:14:28 <lambdabot>  Add a type signature
16:14:37 <oklopol> > (toInteger 0.5) ::Int
16:14:38 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
16:14:41 <oerjan> @src RealFrac
16:14:41 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
16:14:41 <oklopol> > (toInteger 0.5) ::Integer
16:14:41 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
16:14:41 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
16:14:42 <lambdabot>  Add a type signature
16:14:46 <oklopol> :)
16:15:05 <oklopol> > properFraction 0.5
16:15:06 <lambdabot>  (0,0.5)
16:15:15 <oklopol> > properFraction 34.5123
16:15:17 <lambdabot>  (34,0.5123000000000033)
16:15:22 <EvilTerran> ?src properFraction
16:15:22 <lambdabot> Source not found.
16:15:24 <oklopol> thx
16:15:28 <EvilTerran> ?src Float properFraction
16:15:28 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:15:43 <EvilTerran> > properFraction (-1.5)
16:15:44 <lambdabot>  (-1,-0.5)
16:15:57 <oklopol> > properFraction -34.5123
16:15:58 <lambdabot>        add an instance declaration for (Fractional (a -> (b, a)))
16:16:02 <oklopol> > properFraction (-34.5123
16:16:03 <lambdabot> Unbalanced parentheses
16:16:03 <oklopol> )
16:16:07 <oklopol> > properFraction (-34.5123) -- lol
16:16:08 <lambdabot>  (-34,-0.5123000000000033)
16:16:12 <EvilTerran> so it truncates for the fst, and subtracts that from the original for the snd, i guess
16:16:18 <oerjan> oklopol: you might want one of the other methods
16:16:27 <oklopol> oh EvilTerran already tested
16:16:44 <oklopol> oerjan: that works, though
16:16:52 <exDM69> @src reverse
16:16:52 <lambdabot> reverse = foldl (flip (:)) []
16:17:14 <EvilTerran> @check (\f -> properFraction (f :: Float) == (truncate f, f - fromIntegral (truncate f)))
16:17:15 <lambdabot>  OK, passed 500 tests.
16:19:44 <oerjan> oklopol: i mean truncate, round, ceiling, floor listed above
16:19:56 <oklopol> oh
16:20:00 <oklopol> right.
16:20:08 <schemelab> @src scan
16:20:08 <lambdabot> Source not found. That's something I cannot allow to happen.
16:20:17 <oklopol> i'm not good at noticing thing i see.
16:20:17 <schemelab> @src scanl
16:20:18 <lambdabot> scanl f q ls = q : case ls of
16:20:18 <lambdabot>     []   -> []
16:20:18 <lambdabot>     x:xs -> scanl f (f q x) xs
16:20:32 <oklopol> *things
16:20:49 <EvilTerran> truncate's towards zero, floor's towards -infinity, ceiling's towards +infinity, and round's towards the nearest integer, rounding to even for .5s
16:21:24 <oerjan> > map round [1.5,2.5 ..]
16:21:26 <lambdabot>  [2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28,28...
16:21:44 <EvilTerran> @go banker's rounding
16:21:46 <lambdabot> http://en.wikipedia.org/wiki/Rounding
16:21:46 <lambdabot> Title: Rounding - Wikipedia, the free encyclopedia
16:22:24 <omnId> to even?!  bah.  Kids these days.  x.5 should round up.
16:23:10 <EvilTerran> blame the stats people
16:23:28 <EvilTerran> they're just being vengeful 'cos everyone knows it's not real maths ;)
16:24:22 <Olathe> Eww.
16:24:22 <schemelab> f is a binary function i nthe definition of scanl right?
16:24:25 <schemelab> @src scanl
16:24:25 <lambdabot> scanl f q ls = q : case ls of
16:24:25 <lambdabot>     []   -> []
16:24:25 <lambdabot>     x:xs -> scanl f (f q x) xs
16:24:45 <Olathe> Banker's rounding is the work of BEELZEBUB !
16:24:46 <oerjan> schemelab: at least two arguments
16:24:55 <schemelab> right.
16:24:57 <schemelab> thanks
16:25:16 <Saizan> ?type scanl
16:25:17 <omnId> round x = if fr >= 0.5 then y+1 else y where (_,fr)=properFraction x; y = floor x
16:25:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:25:38 <oerjan> well, i guess there are functions that only take a second argument for _some_ types of the first.  Like id.
16:25:48 <omnId> import Prelude hiding (round)
16:26:16 <oerjan> omnId: what about negatives?
16:26:20 <omnId> oerjan: what about for a = (c -> d) in that case?
16:26:34 <omnId> oerjan: don't they round up?
16:26:58 <oklopol> snappedMousePos <- snap divs mp gives type erros, i don't get why, also, please do a bit of a reality check, i may be doing everything wrong, being new to haskell... http://www.vjn.fi/pb/p612314341.txt
16:26:59 <oerjan> "up" is ambiguous with negatives
16:27:17 <omnId> that way all x is rounded to from the interval [x-0.5, x+0.5)
16:27:42 <omnId> oerjan: up as in toward +inf
16:28:13 <oerjan> omnId: exactly (a = (c -> d))
16:29:11 <omnId> oklopol: does snap :: Monad m => a -> b -> m c?  divs :: a, and mp :: b?
16:29:36 <oklopol> i don't understand the question
16:29:46 <omnId> what are their types?
16:29:51 <oerjan> oklopol: snap is not monadic.  use let instead of <-
16:30:01 <omnId> if you get a type error then something's not fitting.
16:30:18 <oklopol> whoooops, indeed
16:30:26 * oklopol is dumb
16:32:29 <Beelsebob> must Ptrs be well typed with the FFI... that is... can I have a type in the C code that all I want Haskell to know about is that it's a pointer to ... something
16:32:36 <oerjan> @index get
16:32:36 <lambdabot> Control.Monad.State, Control.Monad.RWS, Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Text.ParserCombinators.ReadP, Distribution.
16:32:36 <lambdabot> Compat.ReadP, Text.ParserCombinators.ReadPrec, Text.Read
16:32:58 <Beelsebob> (because I don't want to have to write marshaling routines for said something)
16:33:07 <Beelsebob> because the Haskell code will never look at it
16:33:34 <Saizan> Beelsebob: yes you can, c2hs uses thinks like newtype Foo = F (Ptr Foo)
16:34:14 <omnId> newtype PtrVoid = Ptr (forall a. a)
16:34:19 <omnId> :)
16:34:21 <Beelsebob> ah, cool
16:34:29 <Beelsebob> thanks guys :)
16:34:30 <Saizan> omnId: the constructor!
16:34:48 <omnId> newtype PtrVoid = PV (Ptr (forall a. a))
16:35:00 <Saizan> ok :)
16:36:22 <oerjan> @index modify
16:36:22 <lambdabot> Control.Monad.State, Control.Monad.RWS
16:39:39 <mae> is there a good example usage page for HTTP module?
16:40:40 <oklopol> yayee it snaps correctly now
16:41:30 <oklopol> hehe, it seems switching to haskell has reset my coding skills, takes 15 minutes on average to fix a bug :P
16:41:50 <oklopol> they are just type bugs though, i think i'm slowly getting the hang of it...
16:42:01 <oklopol> verrry slowly..
16:42:32 <oklopol> btw, was there any total crap in my code?
16:42:36 <oerjan> @quote type
16:42:36 <lambdabot> NormanRamsey says: Type annotations in OCaml are completely broken and always have been.
16:42:40 <oklopol> if anyone happened to look
16:42:41 <oerjan> @quote type
16:42:42 <lambdabot> dons says: the type system is *great* for coding while sleepy.. you just hack any garbage together, and let the type checker deal with it
16:42:55 <oklopol> heh
16:42:56 <dmwit> oklopol: Is it on an hpaste?
16:43:13 <oklopol> hmm no, perhaps i should use that for haskell pastes
16:43:27 <omnId> http://www.vjn.fi/pb/p612314341.txt
16:43:56 <omnId> at a glance, it looks stylistically alright
16:44:01 <dmwit> Oop, I don't know OpenGL.
16:44:36 <oerjan> oklopol: well, there's that fst $ properFraction ;)
16:45:08 <omnId> which equals truncate
16:45:11 <oklopol> wait, i'll show the correct one...
16:45:42 <oklopol> http://www.vjn.fi/pb/p456124615.txt sorry for no hpaste, i'm too lazy to check the topic :P
16:45:47 <oklopol> errr
16:45:54 <oklopol> i just repasted the non working one xD
16:46:08 <oerjan> !paste
16:46:08 <hpaste> Haskell paste bin: http://hpaste.org/
16:46:20 <omnId> it does give nice syntax coloring
16:46:21 <oklopol> http://www.vjn.fi/pb/p416426463.txt
16:46:23 <oklopol> too slow
16:46:32 <oklopol> i'll use it next time
16:46:56 <oklopol> or, i'll implement haskell syntax highlighting on that pastebin!
16:47:01 <dmwit> The ounly egregious thing I see is inline type annotations.  They bug me, but are sometimes unavoidable.
16:47:03 <oklopol> much more fun :)
16:47:30 <oklopol> hmm, like in red = Color3 (1.0::GLdouble) 0.0 0.0
16:47:41 <oklopol> ?
16:47:53 <dmwit> Yeah, or newIORef ((0,0)::(GLdouble,GLdouble))
16:48:07 <oerjan> btw it might be better to use GLdouble rather than Double uniformly?
16:48:34 <omnId> I see a mapM_ (... giant lambda ...) list, you can change that to forM_ list $ ... giant lambda ...
16:48:45 <omnId> it's in Control.Monad
16:49:44 <dmwit> Actually, that block looks like it could get transformed in other fun ways.
16:50:00 <LoganCapaldo> transformers! more than meets the eye!
16:51:27 <oerjan> yeah, a mapM_ (vertex . pt)
16:51:38 <lola> can anyone give an example of the data type Property
16:51:40 <ddarius> @quote goat's.blood
16:51:41 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
16:51:41 <lola> ?
16:51:55 <omnId> > property True
16:51:56 <lambdabot>   Not in scope: `property'
16:52:02 <oerjan> @instances-importing Test.QuickCheck Property
16:52:03 <lambdabot> Couldn't find class `Property'. Try @instances-importing
16:52:04 <Saizan> LoganCapaldo: :D
16:52:05 <hpaste>  dmwit pasted "transformations" at http://hpaste.org/3509
16:52:07 <omnId> > Test.QuickCheck.property True
16:52:08 <lambdabot>   Not in scope: `Test.QuickCheck.property'
16:52:39 <omnId> @type \x -> x > 0 ==> x /= (-3)
16:52:40 <lambdabot>     precedence parsing error
16:52:40 <lambdabot>         cannot mix `(>)' [infix 4] and `(/=)' [infix 4] in the same infix expression
16:52:40 <lambdabot> Not in scope: `==>'
16:52:49 <omnId> @type \x -> (x > 0) ==> (x /= (-3))
16:52:50 <lambdabot> Not in scope: `==>'
16:52:53 <omnId> rawr
16:53:08 <omnId> @type \x -> (x > 0) Test.QuickCheck.==> (x /= (-3))
16:53:10 <lambdabot> forall a. (Num a, Ord a) => a -> Test.QuickCheck.Property
16:53:52 <omnId> @source Test.QuickCheck
16:53:53 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
16:54:03 <lola> ok.. thanx :)
16:54:04 <omnId> (actually a lot clearer than you might expect!)
16:54:58 <dmwit> Can the last do block (in the list monad) in that paste be done via a list comprehension, somehow?
16:55:08 <omnId> I don't think QC exports the Property constructors, you have to use the Testable class's property method to make 'em.
16:55:46 <lola> yep.. ok!
16:56:21 <mauke> [ (f x, g y, 0.0) | x <- divPoints, y <- divPoints, f <- [id, negate], g <- [id, negate] ]
16:56:25 <mauke> well, not quite
16:56:35 <dmwit> Yes, that's nice.
16:56:41 <mauke> the order is wrong
16:56:45 <dmwit> For my question, order doesn't matter.
16:56:54 <dmwit> (I should have said that.)
16:56:59 <omnId> [p | x <- divPoints, y <- divPoints, p <- [...]]
16:57:10 <dmwit> YES
16:57:45 <omnId> do { x <- divPoints ; y <- divPoints ;p <- [...] ; return p } is another way to say what you have there.
16:58:04 <dmwit> Right, that's very clever.
16:58:27 <dmwit> One of the monad laws. =)
17:06:18 <omnId> [(x,y,z) | x <- divPoints, y <- divPoints, z <- replicate 4 0.0]
17:06:38 <omnId> er, no
17:06:42 <dmwit> Yes, but then you have to do
17:06:51 <dmwit> divPoints = divPoints ++ map negate divPoints
17:06:51 <dmwit> or so
17:07:09 <dmwit> urgh, that's like destructive update right there.
17:07:15 * dmwit needs to stop coding Java
17:07:57 <Saizan> nah, that's just _|_
17:08:14 <oerjan> ap [id,negate] divPoints
17:08:16 <Saizan> > let divPoints = divPoints ++ map negate divPoints in divPoints
17:08:18 <lambdabot>  Exception: <<loop>>
17:08:45 <oerjan> > ap [id,negate] [1..5]
17:08:46 <lambdabot>  [1,2,3,4,5,-1,-2,-3,-4,-5]
17:09:04 <dmwit> > liftM2 (*) [1,-1] [1..5]
17:09:05 <lambdabot>  [1,2,3,4,5,-1,-2,-3,-4,-5]
17:09:10 <conal> > [id,negate] <*> [1..5]
17:09:11 <lambdabot>  [1,2,3,4,5,-1,-2,-3,-4,-5]
17:09:13 <dmwit> Yours is shorter. =)
17:09:16 <kpreid> > let (+++) = ++ in let a ++ b = 0 : map (1+) (a +++ b); divPoints = divPoints ++ map negate divPoints in divPoints
17:09:16 <lambdabot>  Parse error at "++" (column 13)
17:09:17 <omnId> I was reading thedailywtf from a reddit link the other day, some simpleton wrote a perversion of factorial that updated things in a morally wrong way and always returned 12.  I found myself unable to understand it because it'd been so long since I had to run a for loop in my head.
17:09:30 <kpreid> > let (+++) = (++) in let a ++ b = 0 : map (1+) (a +++ b); divPoints = divPoints ++ map negate divPoints in divPoints
17:09:31 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:09:50 <kpreid> hm, boring
17:10:09 <LoganCapaldo> > let a = a in a
17:10:10 <lambdabot>  Exception: <<loop>>
17:10:20 <omnId> try to express this in Haskell: http://worsethanfailure.com/Articles/Fd-Factorial.aspx
17:10:22 <lambdabot> Title: F'd Factorial - Worse Than Failure
17:10:44 <kpreid> > let a ++ b = 0 : concat (zipWith (\x y -> [x,y]) a b); divPoints = divPoints ++ map negate divPoints in divPoints
17:10:45 <omnId> keeping to it's style and not just factorial n = 12 :)
17:10:45 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
17:10:59 * kpreid quits
17:11:02 <LoganCapaldo> I swear i've seen a haskell version of that
17:11:09 <LoganCapaldo> I think Cale did it
17:11:53 <LoganCapaldo> http://programming.reddit.com/info/21nue/comments/c21o40
17:11:55 <lambdabot> Title: programming: How do you write the factorial function totally wrong? (daily WTF)
17:11:55 <LoganCapaldo> yep
17:12:07 <oerjan> > (flip . join . liftM3 $ (,,)) 0.0 (ap [id,negate]) [1.0 .. 3.0] -- snapping completely :D
17:12:08 <lambdabot>        add an instance declaration for (Fractional ([a] -> a3))
17:12:15 <omnId> :O
17:12:22 <dmwit> Ratis, I was going to try using unfoldr.
17:13:03 <dmwit> -i
17:13:14 <oerjan> > (flip . join . liftM3 $ (,,)) [0.0] (ap [id,negate]) [1.0 .. 3.0] -- snapping completely :D
17:13:15 <lambdabot>  Couldn't match expected type `t -> a3' against inferred type `[a]'
17:15:10 <oerjan> > (flip . join . liftM3) (,,) [0.0] . ap [id,negate] $ [1.0 .. 3.0] -- always something wrong
17:15:12 <lambdabot>  [(1.0,1.0,0.0),(1.0,2.0,0.0),(1.0,3.0,0.0),(1.0,-1.0,0.0),(1.0,-2.0,0.0),(1....
17:15:55 <dmwit> We need to declare a deadline for Haskell', so that we can begin work on Haskel''.
17:16:16 * dmwit rereads and feels pompous
17:27:11 <Cale> Screw standardisation, let's just work on base 2.0 now so that by the time Haskell' comes out, it'll be completely out of date.
17:28:07 <wli> Backward compat.
17:28:10 <oerjan> @remember Cale Screw standardisation, let's just work on base 2.0 now so that by the time Haskell' comes out, it'll be completely out of date.
17:28:11 <lambdabot> It is stored.
17:28:37 <dmwit> Whoa, did \bot get some new phrases?
17:28:45 <mrd> we need to somehow get Cale to say "stereo" again so we can @quote him on it
17:29:09 <oerjan> @quote stereo
17:29:09 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
17:29:31 <dmwit> ?quote
17:29:31 <lambdabot> jmelesky says: I've figured out the problem. qwe1234 has different definitions of "functional programming", "compiler", "complexity theory", "math", and "optimization" than everybody else who deals
17:29:31 <lambdabot> with computers or computer science.
17:29:46 <dmwit> ?quote qwe1234
17:29:47 <lambdabot> qwe1234 says: stfu, troll.
17:29:51 <dmwit> ?quote qwe1234
17:29:51 <lambdabot> qwe1234 says: i think the tone *should* be lowered.
17:29:55 <mrd> ?qwe1234
17:29:55 <lambdabot> Unknown command, try @list
17:30:08 <mrd> doesn't quite yet rate a command
17:30:19 <wli> Cale: I'd do something if I had enough mental energy or presence of mind left to hack on the desugarer.
17:30:19 <dmwit> ?protontorpedo
17:30:19 <lambdabot> is there a decent scheduler in haskell? how about a netwrok monitor?
17:30:51 <ninjawarrior1982> hi everyone
17:30:57 <Cale> hello
17:31:07 <ninjawarrior1982> i was wondering if someone would be able to give me some help with a problem i'm having
17:31:11 <Cale> sure
17:31:13 <wli> (It may be the case that I no longer have enough of either to do any kind of programming whatsoever.)
17:31:51 <ninjawarrior1982> i need to convert a list of data (of indefinite length or type) eg like this ["A","A","A","B","B"]
17:32:13 <omnId> > map (+1) [3..7]
17:32:15 <lambdabot>  [4,5,6,7,8]
17:32:20 <Cale> into...
17:32:29 <ninjawarrior1982> into sets like this [(3,"A"),(2,"B")]
17:32:33 <Cale> okay
17:32:38 <mrd> hehe
17:32:41 <dmwit> ?go dons run length encoding
17:32:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/blog/2007/07
17:32:43 <lambdabot> Title: Haskell hacking
17:32:53 <omnId> homework?
17:32:54 <Cale> sort and group will be helpful, along with map
17:33:18 <mrd> > (length &&& head) $ group ["A","A","A","B","B"]
17:33:19 <Cale> > group ["A","A","A","B","B"]
17:33:19 <dmwit> ninjawarrior1982: As in a bag, or as in run-length encoding?
17:33:21 <lambdabot>  (2,["A","A","A"])
17:33:21 <lambdabot>  [["A","A","A"],["B","B"]]
17:33:25 <mrd> loops
17:33:27 <mrd> oops
17:33:29 <ninjawarrior1982> as in a bag
17:33:31 <ninjawarrior1982> cheers
17:33:41 <Cale> > (length *** head) . group . sort $ ["A","A","A","B","B"]
17:33:42 <mauke> > map (length &&& head) . group . sort $  ["A","A","A","B","B"]
17:33:42 <lambdabot>  Couldn't match expected type `([a], [a1])'
17:33:43 <lambdabot>  [(3,"A"),(2,"B")]
17:33:46 <mrd> fix my error :)
17:33:57 <Cale> er, right :)
17:34:08 <Cale> (duh)
17:34:27 <ninjawarrior1982> ok cheers
17:34:37 <ninjawarrior1982> so group and sort are built in commands?
17:34:44 <mrd> @index Data.List
17:34:44 <Cale> They're in the Data.List library
17:34:44 <lambdabot> bzzt
17:34:48 <mrd> @doc Data.List
17:34:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
17:34:48 <dmwit> ?index group
17:34:48 <lambdabot> Data.List
17:34:49 <ninjawarrior1982> sorry i am very new to haskell, used to object orientated!
17:34:53 <oerjan> &&& requires Control.Arrow
17:34:55 <mrd> ninjawarrior1982: sorry to hear
17:35:16 <Cale> Yeah, and (f &&& g) is the same as (\x -> (f x, g x))
17:35:25 <mrd> you should probably not use &&& in your homework
17:35:41 <mauke> > map (liftM2 (,) length head) . group . sort $  ["A","A","A","B","B"]  -- without &&&
17:35:42 <lambdabot>  [(3,"A"),(2,"B")]
17:35:55 <ninjawarrior1982> ok cheers
17:35:56 <Cale> If this is homework in fact, you might be better off writing the thing recursively, or at least defining group and sort yourself.
17:36:08 <wli> LaTeX your homework with lhs2TeX; your graders will love you.
17:36:34 <Cale> mauke: hehehe
17:37:27 <Cale> As a grader for a course using Haskell, I think I'd find it quite easy to pick out which solutions were obtained from #haskell (and not just because I'm here all the time :)
17:37:36 <ddarius> Hmm, what are the built in "commands" of Haskell?  seq, some IO actions, and ?
17:37:54 <ninjawarrior1982> ah no i'm not looking for code, just some pointers in what i need to do!
17:37:55 <dmwit> (+) and friends?
17:38:03 <ninjawarrior1982> as far as i could work out to use recursion i would need to firstly use it on the entered list, and then again on the new list of bags to find out which one it needs to be added it?
17:38:13 <wli> One might also consider that one's graders are not entirely likely to be Haskell specialists; maybe they're studying other aspects of functional programming under the local functional programming professor. Too many obscure constructs might actually lose them.
17:38:16 <Cale> ninjawarrior1982: It's easiest if you start out by sorting the list, assuming that's possible.
17:38:29 <Cale> ninjawarrior1982: then all the equal elements are right next to one another.
17:38:37 <dons> (+) isn't built in.
17:38:51 <Cale> (+) for floats at least is
17:38:51 <dmwit> Surely (+) on Ints resolves to a builtin.
17:38:54 <dons> ddarius: the set of primops the runtime understands, unsafeCoerce# and seq, pretty much
17:38:57 <dons> right.
17:39:04 <dons> the instances of (+) for primtives types
17:39:05 <wli> The functions used for instances are declared elsewhere.
17:39:35 <Cale> ninjawarrior1982: group is a function which takes runs of equal elements and forms lists from them like this:
17:39:40 <Cale> > group "mississippi"
17:39:42 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
17:39:45 <wli> primAddInt32 or something analogous, hidden away as an FFI affair unexported in some module.
17:39:51 <ninjawarrior1982> ah yeah i saw that cheers
17:39:53 <Cale> > group . sort $ "mississippi"
17:39:54 <lambdabot>  ["iiii","m","pp","ssss"]
17:40:05 <Cale> once you have that, it's easy, using map
17:40:08 <dmwit> iiiimppssss!
17:40:13 <dmwit> They keep stealing my cookies.
17:40:21 <Cale> haha
17:40:57 <omnId> dmwit: you should stay away from mississippi, then.
17:40:58 * Cale suddenly remembers the Imp call you could get for Rydia in Final Fantasy IV.
17:41:14 <ninjawarrior1982> ok thanks a lot
17:41:20 <ninjawarrior1982> i'll give it another go
17:42:44 <vBergmann> "Advantage of uncurried form: Permits function composition involving several values." Any idea what that might mean?
17:43:19 <mrd> returning a tuple to another function accepting a tuple
17:43:19 <dmwit> It's nicer to compose an uncurried function than to do, i.e. ((f .) . g).
17:43:55 <omnId> @type concat . uncurry map
17:43:56 <dmwit> Oops, no, I don't think I'm talking about the same thing as your quote.
17:43:57 <lambdabot> forall a a1. (a1 -> [a], [a1]) -> [a]
17:43:59 <mauke> only if "involving" means "passing all values to the first function"
17:44:22 <Cale> actually, I think mrd might have nailed it
17:44:46 <dmwit> yeah
17:45:03 <vBergmann> that makes sense
17:45:03 <mrd> sometimes I get lucky
17:45:06 <Cale> If you use uncurried functions (taking a tuple as a parameter), then you can compose such a function with a function that produces a tuple.
17:45:12 <vBergmann> doesn't seem like much of an advantage though
17:45:29 <Cale> It's occasionally nice to have, which is why there's uncurry :)
17:45:35 <omnId> just curry the tuply function :)
17:45:46 <Cale> uncurry
17:46:24 * mrd applies curry and uncurry to his dinner, with sticky results
17:46:28 <Cale> Currying everything is *really* nice in general though.
17:47:07 <Cale> In a functional language, you're regularly constructing functions to pass to higher order functions, and it's very nice to be able to do that by just partially applying other functions.
17:47:34 <wli> > let { mySort [] = [] ; mySort (x:xs) = let { ys = mySort xs ; myInsert [] = [x] ; myInsert (z:zs) | x <= z = x : z : zs | otherwise = z : myInsert zs } in myInsert $ mySort xs ; myGroup [] = [] ; myGroup (x:xs) = let (h, t) = (takeWhile (== x) xs, dropWhile (== x) xs) in (x : h) : myGroup t } in [(head x, length x) | x <- myGroup $ mySort "mississippi"]
17:47:34 <omnId> not many functions return pairs.
17:47:38 <Cale> (and currying makes partial application easy)
17:47:39 <lambdabot>  [('i',4),('m',1),('p',2),('s',4)]
17:50:01 * wli guesses that might reimplement enough of the base to be turned in as homework.
17:50:11 <oerjan> > uncurry(***)(join(***) (+) (1,2)) (5,10)
17:50:13 <lambdabot>  (6,12)
17:50:28 <wli> dropWhile and takeWhile may not be admissible, ugh.
17:50:47 <ddarius> "Exercise: Implement the Prelude"
17:51:12 <Saizan> ?type Map.fromListWith
17:51:13 <lambdabot> Couldn't find qualified module.
17:51:20 <Saizan> ?type Data.Map.fromListWith
17:51:20 <mrd> @src span
17:51:21 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> Data.Map.Map k a
17:51:21 <lambdabot> Source not found. It can only be attributed to human error.
17:51:21 <dmwit> Most of them wouldn't be too bad... for an experienced Haskell user.
17:53:12 <tehgeekmeister> in this example in all about monads, couldn't the same thing be accomplished using guards?
17:53:13 <tehgeekmeister> http://www.haskell.org/all_about_monads/html/contmonad.html#example
17:53:15 <lambdabot> Title: The Continuation monad, http://tinyurl.com/22j5jr
17:54:06 <tehgeekmeister> i mean, i've never used continuations before at all, and this example doesn't really make them look all that special.
17:54:53 <mrd> it justs uses them to return a value
17:56:27 <wli> > let { mySort [] = [] ; mySort (x:xs) = let { myInsert [] = [x] ; myInsert (y:ys) | x <= y = x : y : ys | otherwise = y : myInsert ys } in myInsert $ mySort xs ; myGroup [] = [] ; myGroup (x:xs) = let { grabPrefix [] = ([], []) ; grabPrefix (y:ys) | y == x = let (us, vs) = grabPrefix ys in (y : us, vs) | otherwise = ([], y:ys) ; (h, t) = grabPrefix xs } in (x : h) : myGroup t } in [(head x, length x) | x <- myGroup $ mySort "mississippi"]
17:56:29 <lambdabot>  [('i',4),('m',1),('p',2),('s',4)]
17:56:35 <wli> No more takeWhile/dropWhile
17:57:02 <tehgeekmeister> i guess what i'm trying to get at, is if there's really much use in continuations, because i can't think of any instance where they'd be that useful.
17:57:22 <mrd> you use continuations all the time
17:57:38 <tehgeekmeister> i do?
17:57:40 <mrd> every function implicitly "continues" by returning a value
17:58:31 <mrd> continuations generalize that concept
17:59:28 <oerjan> the second argument of >>= is essentially a continuation
18:00:45 <oerjan> and unless you really need the completely general case, chances are there is some more limited, easier to understand monad which implements that part of continuation use you need
18:01:59 <tehgeekmeister> okay
18:02:50 <tehgeekmeister> it seems to be similar in purpose to the state monad
18:03:08 <tehgeekmeister> mind you, i hardly understand continuations.
18:03:17 <mrd> do you understand higher order functions
18:03:55 <tehgeekmeister> to some degree, yes.
18:04:12 <ddarius> tehgeekmeister: The significant thing is that exit1 and exit2 are first class.
18:04:51 <mrd> suppose that every function took an extra parameter, another function, which told the first function what to do after it was done with its computation
18:04:58 <allbery_b> I managed to work my way through what was going on in continuations once, but they still leave me crosseyed in the general case
18:04:59 <tehgeekmeister> ddarius: when those two lambdas are finally evaluated, what are they passed as their arguments?  themselves?
18:05:13 <tehgeekmeister> mrd: right
18:05:22 <ddarius> tehgeekmeister: To give you some idea of the significance of continuations, they can be used to implement concurrency systems.
18:05:52 <mrd> tehgeekmeister: that extra parameter is the continuation
18:06:19 <ddarius> allbery_b: There are high-level ways of thinking about what is gonig on, though oftentimes what they are used to implement somewhat complicated things so it isn't surprising that it can be hard to follow.
18:06:50 <mrd> you have to free your mind from the call-stack
18:07:07 <tehgeekmeister> mrd: okay, that's simple enough.  so x >>= y would essentially represent evaluating x, and then y on x's result?
18:07:10 <allbery_b> (I get *what*, just not *how* (at least in haskell)
18:07:12 <ddarius> tehgeekmeister: exit1 and exit2 are bound to a HOF that represents the rest of the program (everything after the callCC that their passed to) and that when executed will "jump" to it.
18:07:33 <ddarius> allbery_b: In Haskell it's even clearer.  Haskell just uses CPS and packages it up in a monad.
18:07:48 <mrd> @src Cont >>=
18:07:49 <lambdabot> Source not found. Are you on drugs?
18:07:50 <ddarius> allbery_b: In Scheme, say, it's built into the language itself and there is nothing to see.
18:07:54 <ddarius> @src Cont (>>=)
18:07:54 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
18:07:55 <allbery_b> I also get that it's hard to put together practical examples that aren't completely cntrived (similar to co-expressions, which fittingly capture much of the same thing)
18:08:27 <mrd> tehgeekmeister: basically, but it packages it up in such a way that the result is a function which accepts the next continuation
18:08:32 <ddarius> allbery_b: Implementing a cooperative threading system is a good example and doesn't take too much time for a simple verson.
18:08:39 <mrd> (because it has to transform haskell code into continuation-passing style)
18:09:10 <tehgeekmeister> mrd: so to get the final value out what would one do?  use return?
18:09:20 <mrd> writing your own code in CPS is a good way to understand it too, I think
18:09:39 <mrd> tehgeekmeister: you would use runCont on the whole deal
18:09:39 <ddarius> Incidentally, another benefit of continuations/CPS was discussed yesterday and summarized in section 2 of http://www.haskell.org/haskellwiki/Performance/Monads
18:09:40 <lambdabot> Title: Performance/Monads - HaskellWiki
18:09:44 <oerjan> :t runCont
18:09:46 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
18:10:04 <mrd> tehgeekmeister: yea, the "last" continuation is "return the value" in that it puts it back into the normal haskell call-stack system
18:10:42 <ddarius> tehgeekmeister: Do you know assembly?
18:10:49 <newsham> whats a good package for generating image files in some popularly supported format?
18:11:09 <dons> gtk2hs ?
18:11:09 <tehgeekmeister> ddarius: i've toyed with it, but i can't claim to know it.
18:11:12 <ddarius> Generating ppm and converting is often the easiest approach.
18:11:16 <mrd> backtracking search is often better written in CPS
18:11:27 <ddarius> tehgeekmeister: Do you know how a (C) call is implemented in assembly?
18:11:29 <Cale> > let foldb b l z [] = z; foldb b l z [x] = l x; foldb b l z xs = foldb b l z [case xs of (x:y:_) -> b x y; [x] -> l x | xs <- takeWhile (not . null) . iterate (drop 2) $ xs]; merge [] ys = ys; merge xs [] = xs; merge (x:xs) (y:ys) = if x <= y then x : merge xs (y:ys) else y : merge (x:xs) ys in foldb merge id [] . map return $ "mississippi"
18:11:31 <lambdabot>  "iiiimppssss"
18:11:32 <dcoutts> newsham: cairo and gtk2hs can produce png and ps/pdf
18:11:36 <newsham> i'm already generating pbm's.  I just dont want to call an external program to convert
18:11:42 <tehgeekmeister> ddarius: i once did.
18:11:59 <dcoutts> newsham: gtk2hs can also generate jpeg and can read various other things like tiff and ico
18:12:20 <newsham> hrm.. quite a large C package just to do a simple task :\
18:12:45 <ddarius> tehgeekmeister: Okay, then you should be able to follow this.  In assembly, oftentimes you call a function by pushing arguments onto the stack and using the call opcode.
18:12:48 <newsham> (nothing against gtk2hs, just seems a littl eheavy handed here)
18:12:49 <wli> I installed gtk2hs and am clueless as to what to do with it.
18:12:54 <dcoutts> newsham: true, just to convert pnm to png you could probably go with something lighter
18:13:04 <dcoutts> wli: check out the demos and tutorials
18:13:11 <Cale> I once wrote a Haskell binding to imlib2
18:13:19 <Cale> I should really package it.
18:13:20 <ddarius> tehgeekmeister: All the call opcode does is push the instruction pointer and jump to the specified function.
18:13:28 <dons> Cale! yes, please do
18:13:28 <ddarius> tehgeekmeister: That sounds familiar and understandable?
18:13:43 <newsham> maybe i should just write some code to make pngs
18:14:03 <tehgeekmeister> ddarius: yes, perfectly understandable.
18:15:13 <ddarius> tehgeekmeister: Okay.  So we can view the pushed instruction pointer (which is the return address) as just another argument.  When we execute the code, to return we use the ret opcode which just pops the return address off the stack and jumps to it.
18:15:16 <Cale> newsham: Hang on while I grab dons' tool to make cabal packages... where was that again?
18:15:31 <Cale> http://www.cse.unsw.edu.au/~dons/code/mkcabal/
18:15:31 <lambdabot> Title: Index of /~dons/code/mkcabal
18:15:54 * wli would be interested in basic plotting dumbed down enough to take ranges and (Double -> Double) functions with maybe some descriptions like colors and legend labels.
18:16:20 <wli> (You can't really pass continued fractions to gnuplot in non-irritating fashions.)
18:16:54 <newsham> i have ascii and pbm plotters for Double -> Double ->  Bool
18:17:09 <newsham> (ie. mandelbrots, julias and moire patterns)
18:17:24 <ddarius> tehgeekmeister: In functional languages, instead of "jumping" or "gotoing" we use tail calls.  We can do the same kind of change of perspective at the FP level, we can turn f x = x * x into f x k = k (x * x), i.e. we make the "return address" explicit and we "jump" to it (with a result).
18:17:33 <tehgeekmeister> ddarius: if i remember right, the instruction pointer, as you're calling it, points to the point to resume execution after the function is evaluated, right?
18:17:45 <ddarius> tehgeekmeister: A return address in assembly, is like a very cut down continuation.
18:17:50 <ddarius> tehgeekmeister: Yes.
18:18:32 <tehgeekmeister> okay, i get it, then.
18:19:35 <ddarius> tehgeekmeister: The second version of f is in continuation passing style (CPS).  In assembly we can create interesting control structures (like iterators) by doing explicitly manipulating the return stack.  In FP languages, we can do the same thing by explicitly manipulating continuations in CPS.
18:20:13 <newsham> ... or using multiple stacks... (coroutines)
18:21:04 <ddarius> Here is an example of doing this sort of thing in assembly: http://webster.cs.ucr.edu/AoA/DOS/ch12/CH12-6.html#HEADING6-1 (not that it's easily understandable)
18:21:06 <lambdabot> Title: Art of Assembly Language: Chapter Twelve-6
18:22:16 <ddarius> tehgeekmeister: By using CPS we can do all kinds of interesting control effects that you can do in assembly but not in C, such as iterators or vectored returns.
18:22:37 <tehgeekmeister> the Cont type is essentially just, if this makes sense, a retyping of a lambda, right?  Cont $ \x -> ..., essentially, only makes the lambda of type Cont, it doesn't do anything else, does it?
18:23:07 <wli> Not sure what you mean by iterators. Lacking vectored returns is mostly a language defect.
18:23:19 <oerjan> :t Cont
18:23:27 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
18:23:30 <ddarius> tehgeekmeister: It's a constructor.  All it does is package the lambda up.  It's not a "lambda of type Cont".  However, it's the other operations that are important.
18:24:30 <tehgeekmeister> right, i was just making sure that there wasn't more to the Cont $ lambda bits i'm seeing in the tutorial
18:26:39 <newsham> wli: familiar with python generators?
18:28:35 <wli> newsham: I don't touch those "scripting languages" like perl, python, ruby, et al.
18:29:23 <newsham> wli:   think of a C thread that has one element of shared memory and every time you let it run, it writes a new value into that shared memory
18:29:23 <wli> newsham: I've never even heard of them.
18:29:46 <ddarius> In CPS an application like f (g x) gets translated to, \k -> g x (\y -> f y k).  Using a C notation we might write that as y = g(x); return f(y).  Using assembly terms, we are being passed a return address k, we call g(x) with a return address that points to the rest of the computation, namely return f(y) and f(y) is given the address to return to for the whole call.
18:29:57 <newsham> so it would look like:   mythread() { int shared = 1; for(i = 0; i < 100; i++) { shared += i; yield; } }
18:29:58 <wli> newsham: I program C for a living. It sounds like there's a translation into C here.
18:30:29 <newsham> and every time I call  mythread.next, it longjumps back to the "yield", and every time the thread hits a yield it longjumps back to me with a value
18:31:09 <newsham> thats roughly what python and icon generators are.  the more general concept is a coroutine (cooperative threading), but python doesnt support too much more generality
18:31:11 <wli> Sounds like nonlocal gotos.
18:31:17 <pjd> think delimited coroutines, or resumable stack frames
18:31:28 <newsham> its very controled time of non-local gotos.  its "coroutines"
18:31:39 <ddarius> tehgeekmeister: By itself, all that isn't too interesting. (Though it is notable that by using CPS you free yourself from the evaluation order of the defining language.)
18:31:43 <newsham> people sometimes use em in C :)
18:31:58 <wli> They're a fundamental part of kernel programming in C.
18:32:13 <newsham> *nod*
18:32:21 <wli> Both for task model and interrupt model programming.
18:32:23 <newsham> but not really used as "generators" in that scenerio
18:32:39 <wli> It sounds like these are less general than coroutines but anyhow.
18:32:45 <ddarius> tehgeekmeister: The first interesting thing comes in when we realize that there is no reason g ever needs to call it's passed continuation.  If g doesn't use the contination given to it, f(y) will never be executed.
18:32:55 <allbery_b> icon coexps are a better match
18:33:20 <newsham> in python it would be roughly:   def func() { val = 0; for n in range(1000) { val += n; yield n; }}
18:33:23 <allbery_b> (than generators that is)
18:33:33 <newsham> and you would call it as:   for myval in func { ... }
18:33:46 <newsham> wli: yah, generators are one special case of coroutines.
18:34:39 <tehgeekmeister> ddarius: i get it now, even if this is a really contrived example, i can see how continuations could be very powerful.
18:34:39 <newsham> of course you get it for free with non-strict evaluation :)
18:35:20 * tehgeekmeister moves onto monad transformers
18:35:30 <ddarius> tehgeekmeister: The translation of f (g x) wasn't contrived and the potential for g to ignore it's continuation is also not contrived.  It's how you might implement exceptions for example.
18:35:46 <tehgeekmeister> ddarius: no, i meant in the example in all about monads
18:35:56 <ddarius> Ah.
18:36:16 <tehgeekmeister> that code would be much simpler and easier to read with a few conditionals, i think.
18:36:24 <ddarius> tehgeekmeister: The part where it gets really interesting (and the assembly analogy breaks down) is that g could, for example, save it's argument into a data structure.  Then it could be executed repeatedly (perhaps from totally different parts of the code).  That leads to the rest of the computation, f(y) and then whatever it returns to, being executed multiple times with different values of y.
18:38:14 <ddarius> tehgeekmeister: The examples in the All About Monads case are similar to using break in C or such.
18:38:38 <ddarius> (Though you'd really need named loops to do it.)
18:39:05 <tehgeekmeister> i admit, while this isn't necessarily the simplest way to do it, it is really elegant.
18:39:06 <ddarius> To translate that example into C "directly" would require goto.
18:40:27 <spamyboy> Off-topic: I have just created on map and there was article writen about it, could anyone DIGG it pleas ? http://digg.com/gaming_news/http_www_allnevv_com_article_gaming_84/blog THANKS !
18:40:59 <allbery_b> urgh
19:08:51 * Cale finishes updating the Imlib2 binding to work with modern Imlib2.
19:09:50 <Cale> dons: hehe, perhaps mkcabal ought to be in Hackage too ;)
19:19:29 <Cale> Hmm, apologies for not knowing anything about Cabal, but what's the phrase I add to my .cabal to indicate that programs built with the library need to be linked against certain things?
19:20:40 <sjanssen> Cale: eg. extra-libraries:    "X11"
19:20:58 <Cale> ah, okay
19:26:48 * Cale grumbles about more Imlib interface changes...
19:42:33 <omnId> @quote
19:42:33 <lambdabot> math says: 2^20 ~= 10^6
19:47:14 <todizz> i have a data declaration for Weight
19:47:31 <todizz> i have a constructor Gram
19:47:53 <todizz> is there a way of using all the metric prefixs without writing them all out
19:48:17 <todizz> eq kilo- or milli-
19:49:21 <todizz> ill ask another time and ill word the ques better   i need to go
19:49:44 <omnId> data Weight = Gram Multiplier Double; data ... shoot, he left
19:50:23 <allbery_b> aren't there already a couple of libraries for this?
19:50:52 <omnId> I recall a dimensional analysis thingy on HWN
19:51:18 <dons> ?users
19:51:18 <lambdabot> Maximum users seen in #haskell: 423, currently: 384 (90.8%), active: 11 (2.9%)
19:51:33 <newsham> dcoutts: is crc32 accessible from zlib package?
19:51:46 <ddarius> @google dimensional Haskell
19:51:48 <lambdabot> http://code.google.com/p/dimensional/
19:51:48 <lambdabot> Title: dimensional - Google Code
20:10:18 <mae> hello, can someone suggest a higher level library for an http server than Network.HTTP ?
20:11:03 <ddarius> mae: What do you want to do exactly?
20:11:58 <mae> my needs are somewhere inbetween HaPPs and super low-level..
20:12:09 <mae> I want to create my own app server that hooks into a database
20:13:44 <mae> i was playing around with Network.HTTP but it seems that i have to do the housekeeping on Keep-alives and everything if i go this route..
20:13:54 <mae> it almost seems like if there is a decent library out there its hidden from google :)
20:15:09 <ddarius> http://www.haskell.org/haskellwiki/Applications_and_libraries/Web_programming#HTTP this and Hackage are the first places to look.  If it isn't at either of them, then it's probably not there and/or not maintained.
20:15:11 <lambdabot> Title: Applications and libraries/Web programming - HaskellWiki, http://tinyurl.com/yrdc54
20:15:50 <mae> thank you darius :)
20:16:10 <mae> it would be nice if there was a haskell http server that supported operating system level io
20:16:12 <mae> err aio
20:16:29 <ddarius> Look at the network section of this http://hackage.haskell.org/packages/archive/pkg-list.html
20:16:33 <ddarius> as well
20:16:40 <mae> ok
20:17:14 <ddarius> The web section of that is probably also potentially useful
20:32:03 <bran__> i started hacking on a small webserver...yeah i couldn't find any aio stuff either
20:35:21 <ddarius> Someone has done it, but I'm not sure if they have any publically available code.
20:40:02 <dons> there's simon marlow's web server
20:40:04 <dons> and the one in happs
20:46:21 <Cale> http://cale.yi.org/autoshare/Imlib-0.1.tar.bz2
20:47:25 <dons> cool
20:47:29 <dons> do you need a hackage account?
20:47:45 <Cale> If I'm going to upload it :)
20:48:05 <dons> shall i create one for you then?
20:48:09 <Cale> sure :)
20:49:30 <sjanssen> Cale: the tarball containts "Imlib-0.1/Graphics/.Imlib.hs.swp"
20:49:37 <Cale> oh, oops
20:50:11 <sjanssen> Cale: you might try 'Setup sdist'
20:50:23 <sjanssen> which makes a proper tarball in dist/
20:51:24 <sjanssen> Cale: you'll need to make some changes to the .cabal for that to work correctly though
20:52:59 <Cale> rebuilt the tar
20:56:02 <sjanssen> Cale: also, the library name/directory name in the tarball are case sensitive
20:56:45 <Cale> Yeah, I had to change that.
20:56:46 <sjanssen> Extra-Source-Files:  Graphics/Imlib_stub.h Graphics/Imlib_stub.c
20:56:46 <sjanssen>                      examples/value2alpha.hs examples/circle-inversion.hs
20:57:02 <sjanssen> you can add that to the .cabal to make 'Setup sdist' work
20:57:08 <Cale> the stubs aren't necessary (removed them)
20:57:21 <Cale> all right
20:58:19 <sjanssen> Cale: the examples work well here
20:58:32 <Cale> okay, cool
21:00:04 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Imlib-0.1
21:00:07 <lambdabot> http://tinyurl.com/2gugjm
21:02:26 <Cale> So we finally have a good way to load and save lots image formats.
21:02:28 <Cale> of*
21:02:36 <wli> Cale: Which is that?
21:02:39 <Zao> No more PPM, yay.
21:02:48 <Cale> I just uploaded a binding to Imlib 2
21:03:19 <Cale> Unfortunately, the documentation could be much better (there's no Haddock yet)
21:03:35 <Cale> But it follows the C interface fairly closely, with a few extras thrown in.
21:03:36 <wli> Is there some sort of simple way to deal with an image represented by an array of pixels?
21:04:08 <Cale> yeah, depending on how simple you want it.
21:04:22 <Cale> I should probably add some more with* wrappers and such.
21:04:32 <dataangel> Why does haskell use monads to sequence actions instead of CPS? I'm familiar with the latter from a denotational semantics book I'm reading, but don't know much about the former yet.
21:04:42 <wli> Cale: Array (Int, Int) Int for a grayscale image maybe.
21:04:51 <wli> Cale: Array (Int, Int) (Int, Int, Int) for a color image.
21:05:08 <dons> dataangel: monads are more general?
21:05:16 <dons> and cps is more confusing to program in :)
21:05:44 <dataangel> dons: Well, you'd add some syntactic sugar to ease it. Make a function that transforms non-cps to CPS is not too hard.
21:05:58 <dons> right, and you'd have the Cont monad :)
21:05:59 <allbery_b> I think you can use a monad to hide CPS
21:06:16 <Cale> dataangel: Basically "monads" are just a specific case of "combinator libraries"
21:06:21 <allbery_b> or to hide partial application +hidden state (e.g. GHC's IO) etc.
21:06:30 <newsham> yay, simplistic png working
21:07:33 <Cale> btw, I wrote most (almost all) of that code back in 2004 when I was just learning Haskell
21:07:44 <Cale> So there may be some stupid bits :)
21:08:10 <omnId> wow, so you didn't just *always* know Haskell, Cale?
21:08:17 * omnId boggles
21:08:25 <dons> some are born into it, others must learn
21:08:31 <Spark> haskell isn't that old a language
21:08:36 <dons> well...
21:08:50 <Spark> are there any haskell programmers that are younger than the language? :)
21:08:51 <dons> we have a few hackers younger than the language
21:09:01 <dons> sorear is, for a start.
21:09:11 <omnId> @faq Hackers younger than language?
21:09:11 <lambdabot> The answer is: Yes! Haskell can do that.
21:09:17 <dons> there must be lots now, in undergrad classes
21:09:17 <dataangel> how old is it?
21:09:27 <dons> 20 years, last april.
21:09:29 <omnId> at *least* since '90
21:09:35 <Spark> i thought it was more like 10 years
21:09:48 <dataangel> I'm only 1 year older ;p
21:09:50 <Spark> these things always brew for ages before hitting mainstream though, so i should have known better :)
21:09:51 <Cale> Depends on when you count from
21:10:00 <dons> in its `serious' form, its about 10 years old, yeah
21:10:08 * wli originally learned Haskell as part of an effort to learn oodles of languages ca. 1998.
21:10:11 <dons> maybe we'd even count the FFI report as the true birth
21:10:13 <Cale> In its 'useful' form, it's more like 5 years :)
21:10:27 <dons> yeah
21:10:40 <Spark> useful meaning efficiently-implemented?
21:10:42 <dons> the ffi report was the moment.
21:10:51 <dons> Spark: oh, no. its been efficient since very early on
21:10:52 <ddarius> Spark: Haskell is mainstream?
21:11:09 <dataangel> where is the "<-" thingy (is it technically an operator or ... ?) defined that's used inside do blocks? Is it part of the monad or something else?
21:11:12 <Cale> dons: I don't know about that
21:11:20 * wli can't say he really follows it all that closely as his primary programming is in other language(s).
21:11:23 <dons> hbc still outperforms ghc for some programs
21:11:30 <dons> and its not been touched since the early 90s
21:11:34 <omnId> dataangel: do notation is syntactic sugar that gets translated into monad operators.
21:11:41 <Cale> dons: It has a somewhat justified reputation for being slow for quite a while. You've personally helped with that situation quite a bit.
21:11:43 <dons> anyway, compiled graph reduction beats python :)
21:11:45 <Cale> had*
21:11:48 <ddarius> dataangel: As others have said, you can wrap CPS in a monad.  Furthermore, usually you use other *-passing styles, e.g. state passing style and error propagation in denotational semantics.  Those too can be wrapped up into your monad.
21:11:49 <dons> so i'd say its always been efficient :)
21:12:08 <omnId> dataangel: do { pat <- exp1 ; ... } ==> exp1 >>= \pat -> do { ... }
21:12:17 <dons> Cale: one thing was that hugs was the main impl. users had for a whlie
21:12:22 <ddarius> @undo do pat <- exp; return pat
21:12:22 <lambdabot> exp >>= \ pat -> return pat
21:12:23 <dataangel> ddarius: Yeah I saw the maybe monad :)
21:12:24 <Cale> What's with my muscle-memory and not choosing the right verb-tenses? I sound like a non-native English speaker who isn't quite fluent. :)
21:12:49 <Spark> i get that in east london all the time
21:12:59 <omnId> dataangel: so no, '<-' isn't an operator defined anywhere, it's lower-level syntax that's part of do notation.
21:13:11 <ddarius> dataangel: Also, once everything is put into the monad, if you later want to add some other effect, e.g. dynamic scoping, it can be added without changing anything but the parts that need changing and the definition of the monad.
21:13:51 <dataangel> omnId: Maybe I should look at monads again now that I understand continuations, because what you just wrote looks like bind is doing that.
21:13:55 <Cale> dynamic scoping is kind of a strange example though, isn't it?
21:13:56 <ddarius> Cale: That's okay.  You're Canadian.
21:14:10 <dons> exceptions or concurrency are my favourite :)
21:14:10 <Cale> ddarius: heh
21:14:20 <ddarius> Cale: I'd run out of stuff.  I guess non-determinism is another I could have used.
21:14:35 <dataangel> omnId: Well, except it also strips the M off the type before it applies
21:14:50 <omnId> @type (>>=)
21:14:51 <ddarius> Also, with continuations and state you don't even need to change anything...
21:14:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:15:09 <omnId> there's no magic to (>>=), as you can see, the lambda on the right takes a bare 'a'.
21:15:39 <omnId> (a -> m b)
21:16:15 <Cale> dataangel: http://www.haskell.org/haskellwiki/Monads_as_computation -- If you're still a bit hazy on the point of using monads, this will (hopefully) clear things up a bit.
21:16:17 <lambdabot> Title: Monads as computation - HaskellWiki
21:16:32 <omnId> the 'stripping' of the 'a' is in the definition of (>>=) for whichever monad type constructor you're using, not any magic in do notation.
21:16:37 <omnId> of the 'm', rather
21:17:39 * ddarius is soo happy that Monads_as_containers has been obsoleted.
21:18:01 <omnId> return/fmap/join is a nice way to look at it, I think
21:18:06 * wli has been trying to muster enough mental energy or coherent thought to write anything.
21:18:13 <dataangel> omnId: sorry, sloppy with my speech, I meant that >>= is doing it
21:18:20 <wli> omnId: bind just didn't work for me.
21:19:31 <dataangel> how do I use Parsec functions in the interpreter? I loaded ghci with "ghci -package parsec" and it says it loaded it, but "let x = oneOf "abc"" fails
21:19:34 <Cale> ddarius: It's not obsoleted :)
21:19:44 <ddarius> Cale: Don't burst my bubble.
21:19:49 <Cale> ddarius: haha
21:19:52 <omnId> dataangel: :m +Text.ParserComblahblah
21:20:10 <omnId> you must import the names first.
21:20:21 <dataangel> omnId: What was the point of the -package param?
21:20:41 <omnId> not sure, I've never used it (:
21:21:09 <dataangel> maybe it's just for compiling
21:22:42 <omnId> if you like, you can fully qualify your names and ghci'll auto-import.  (Hooray for Text.ParserCombinators.Parsec.oneOf)
21:22:47 <dylan> anyone have a parsec-parser for dos .ini-style files laying around?
21:23:16 <dataangel> Why does "parse" return an Either ParseError a instead of a Maybe a? :P
21:23:23 <ddarius> dylan: Probably, but you could probably write one quicker than you could find it.
21:23:31 <omnId> dataangel: so you can find out what went wrong :P
21:23:38 <ddarius> But check the usual places, hackage and the applications and libraries page.
21:23:45 <dataangel> omnId: Oh, so ParseError isn't empty :D
21:24:00 <omnId> you can show it.
21:25:03 <dataangel> hrm... could you build all union types if you just had Either available? I guess you'd have some ugly nesting but it seems like all you need
21:25:14 <omnId> dataangel: Either and (,)
21:25:26 <dataangel> omnId: (,) ?
21:25:34 <omnId> for product types.
21:25:44 <omnId> oh, you just said unions.  Yes.
21:25:51 <dataangel> oic
21:25:54 <dataangel> nifty
21:26:06 <dataangel> I like this whole making correct guesses thing
21:26:43 <omnId> in fact, all you really need is (), (,), and Either.
21:26:47 <omnId> maybe Void too
21:27:17 <Cale> The Prelude used to have Void
21:27:22 * omnId makes peano numbers with () and Maybe
21:27:38 <laziest> Cale: how is () different from Void?
21:27:44 <ddarius> data Void
21:27:45 <omnId> Void has *no* values
21:27:47 <ddarius> data () = ()
21:27:53 <Cale> no non-bottom values
21:27:57 <omnId> unit has *one* value.
21:28:00 <omnId> non-bottom
21:28:36 <dataangel> () = non-bottom ?
21:28:39 <laziest> does Haskell98 have data declarations without constructors?
21:28:45 <dataangel> err you mean it has one value besides undefined
21:28:51 <omnId> the () type has two values: _|_ and ()
21:28:51 <Cale> dataangel: right
21:29:03 <TSC> dataangel: undefined = bottom
21:29:05 <dataangel> _|_ = undefined
21:29:08 <dataangel> right
21:29:13 <ddarius> undefined = undefined
21:29:29 * sorear is back
21:29:31 <omnId> laziest: not sure what you mean.
21:29:32 <dataangel> does anybody else think that _|_ being called bottom is a terrible joke? was it intentional? :P
21:29:40 <laziest> I mean is it not an extension?
21:29:40 <ddarius> The world rejoices.
21:29:44 <sorear> dataangel: it's intentional
21:29:47 <soduko> does any one use ghc on linux?
21:29:51 <sorear> yues
21:29:51 <allbery_b> it's an extension
21:29:58 <Cale> _|_ is the usual notation given to the bottom of a lattice in order theory
21:29:59 <allbery_b> and yes
21:30:08 <dmwit> dataangel: There's also top, but it's harder to draw with ASCII. =)
21:30:08 <sorear> soduko: I don't think very many people use it on anything but
21:30:11 <dataangel> sorear: I'm from C++ where all jokes are unintentional.
21:30:12 <Cale> It's a stylised upside-down T
21:30:25 <sorear> dataangel: but it has nothing to do with human posteriors
21:30:25 <ddarius> Crap \bot makes \top in SCIM
21:30:29 <omnId> laziest: oh, I thought you mean fields, but no constructors, thus confusion.
21:30:30 <dataangel> dmwit: defined in haskell?
21:30:32 <allbery_b> ...or where C++ *is* the joke...
21:30:32 <Cale> (T being for top)
21:30:42 <dataangel> sorear: that was the joke
21:30:48 <ddarius> 
21:30:49 <sorear> meh, just use the unicde mathematical suppliment. 
21:30:55 <soduko> Can you help me with the module search path please?  im trying to get Haskore examples to play, and keep getting errors
21:31:17 <dmwit> soduko: What errors?
21:31:25 <allbery_b> if th modules are registered properly with ghc, ghc --make should do it for you
21:31:29 <ddarius> laziest: If you want you can define newtype Void = Void Void in H98
21:31:40 <allbery_b> if they aren't,m gettingthings to work will be painful anyway
21:32:16 <omnId> ddarius: too bad that type has so many values.
21:32:19 <dataangel> Does haskell have any solution to the problem of their being so many algorithms that need O(1) random access mutable data structures besides unsafeIORef?
21:32:24 <Cale> omnId: ?
21:32:29 <TSC> dataangel: arrays
21:32:35 <omnId> _|_, Void _|_, Void (Void _|_), etc.
21:32:46 <omnId> oh, newtype, nvmm
21:32:49 <ddarius> dataangel: ST and STArrays and IO and IOArrays
21:32:54 <ddarius> And IOUArrays etc.
21:33:03 <ddarius> dataangel: So we have a whole kill of them.
21:33:09 <hpaste>  soduko pasted "module path errors" at http://hpaste.org/3512
21:33:09 <sorear> dataangel: what's an unsafeIORef?
21:33:18 <Cale> dataangel: if you *really* need mutable, then the ST monad lets you wrap up a bunch of operations on mutable structures and turn it into a pure function
21:33:27 <ddarius> omnId: I know my pointedness.
21:33:42 <dataangel> ddarius: I thought you had to be unsafe to get true O(1)?
21:33:42 <soduko> this is where i got the source file from http://www.csse.monash.edu.au/hons/projects/2003/Amanda.Crawford/downloads.html#source_code
21:33:43 <Cale> dataangel: (and it proves that the code is really pure via some type system hackery)
21:33:44 <lambdabot> Title: Amanda Crawford's Honours website = Downloads, http://tinyurl.com/223hrm
21:33:47 <omnId> ddarius: :)
21:34:00 <laziest> apart from the library documentation that comes bundled with ghc, where else can I find doc about ST monad?
21:34:07 <sorear> dataangel: Haskell is such a powerful declarative language that you can write descriptions of imperative programs, which then run at full speed
21:34:09 <ddarius> dataangel: No.
21:34:22 <dataangel> @_@
21:34:24 <soduko> and this to install Haskore http://plucky.cs.yale.edu/cs431/software_resources.htm
21:34:25 <lambdabot> Title: Software Resources
21:34:27 <sorear> laziest: locate GHC/ST.lhs
21:34:31 <Cale> dataangel: However, immutable structures, if well-designed, are typically only a logarithmic factor worse, which can essentially be considered part of the constant term in all practical cases
21:35:29 <soduko> if i copy paste step5 it works, but i cant get other examples to work
21:35:34 <dataangel> Cale: interesting. I guess I thought otherwise because the classic Haskell "quicksort" example misses the essential feature of quicksort, that it's in place. Why hasn't someone updated it? :P
21:36:10 <sorear> dataangel: that's not the essential feature of quicksort in my book
21:36:35 <sorear> dataangel: indeed there are other algorithms that do *vastly* better jobs at in-placenss
21:36:38 <dataangel> sorear: your book doesn't cover space complexity? :P
21:36:50 <Cale> Yeah, it's because that's not an essential feature of quicksort, and while you *can* write an in-place quicksort, it will be about as ugly as the C version.
21:37:02 <wli> sorear is writing a book?
21:37:14 <dmwit> wli: Figure of speech.
21:37:17 <Cale> You need linear space to generate the input to the quicksort anyway.
21:37:21 <sorear> dataangel: my book does cover space complexity, and they're both O(n)
21:37:34 <Cale> (since the quicksort will observe every one of the list nodes)
21:37:46 <ddarius> Cale: I rewrote the C version on the Haskell Intro into Haskell.
21:37:52 <dataangel> sorear: I guess I'll have to review. I'm going off my sole undergrad algorithms class knowledge, so maybe also my prof was off his rocker, but I thought that one of the key differences between mergesort and quicksort was that the latter was in place.
21:38:07 <ddarius> I was aiming for a "direct" translation though.
21:38:17 <ddarius> http://www.haskell.org/haskellwiki/Introduction/Direct_Translation
21:38:19 <lambdabot> Title: Introduction/Direct Translation - HaskellWiki, http://tinyurl.com/ytokyh
21:38:39 <Cale> dataangel: Also, the in-place quicksort is usually an array sort, not a list sort.
21:39:28 <dataangel> Cale: point
21:40:31 <ddarius> I think it took me longer to get the types right in processArray than it did to write the quickSort
21:40:42 <laziest> sorear: I found GHC/ST.hs, which does not have any documentation
21:41:13 <laziest> sorear: you mean http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html, am I right?
21:41:15 <lambdabot> http://tinyurl.com/z6wqn
21:41:29 <sorear> I think I mean GHC/ST.hs.
21:41:29 <laziest> I mean the source code link from it
21:41:35 <Cale> dataangel: You'll find that Haskell programmers are *very* hesitant to use mutable data structures and algorithms when immutable ones are available
21:41:45 <hpaste>  soduko annotated "module path errors" with "module path errors" at http://hpaste.org/3512#a1
21:41:48 <laziest> Ya, got the same, but it has only code.
21:41:58 <sorear> You asked for information that's not in the documentation, I pointed you to the source.
21:42:01 <ddarius> We are?  I mean, yes, we are.
21:42:03 <Cale> dataangel: The reason is that code which does mutation is *way* harder to think about. (This is independent of programming language)
21:42:08 <soduko> dmwit: any help ?
21:42:25 <dmwit> soduko: Dunno, does ghc-pkg list show any haskore-related packages?
21:42:48 <soduko> is that a function at the prelude or at the linux prompt?
21:42:55 * wli tries to figure out how to make lhs2TeX output suitable for inclusion as chapters.
21:42:58 <dmwit> linux prompt
21:43:44 <dataangel> Cale: Has anyone endeavored to prove whether or not there is always an equally performant pure functional algorithm for every mutating one? I guess you'd have to think of some way to constrain it so that the answer was, "yes, transliterated C"
21:43:51 <dataangel> *wasn't
21:44:14 <hpaste>  soduko annotated "module path errors" with "module path errors" at http://hpaste.org/3512#a2
21:44:24 <dmwit> dataangel: There is a proof that some mutating algorithms have no immutable equivalents.
21:44:34 <soduko> dmwit: please read the latest paste
21:44:55 <dataangel> dmwit: do you know author / name / ref ?
21:45:06 <dataangel> could be very interesting to read
21:45:07 <ddarius> dataangel: It has been proven that strict pure programs sometimes can't be as fast as strict impure ones.
21:45:32 <ddarius> dataangel: It's also been proven that under some mild restrictions, strict pure programs can't be as fast as lazy pure ones.
21:45:34 <laziest> sorear: any other source?
21:45:39 <Cale> I'm not sure, but given that the language is pure, there are certain functions for which there is a lazy algorithm which will be strictly faster than any strict algorithm.
21:45:48 <Cale> yeah
21:45:52 <Cale> ddarius beat me to it :)
21:45:56 <ddarius> Cale: Any pure strict algorithm...
21:46:07 <Cale> yes, I stated that at the beginning
21:46:15 <dataangel> ddarius: author / name of proof / refs? :)
21:46:15 <wli> Apparently this idiot thing is trying to \usepackage outside the preamble.
21:46:20 <dataangel> not challenging, just curious
21:46:24 <ddarius> @google Pure vs impure lisp
21:46:27 <lambdabot> http://citeseer.ist.psu.edu/320766.html
21:46:27 <lambdabot> Title: Pure versus Impure Lisp - Pippenger (ResearchIndex)
21:46:28 <ddarius> dataangel: I under stand
21:46:35 <ddarius> @google More Speed Less Haste
21:46:38 <lambdabot> http://www.usingenglish.com/reference/idioms/more+haste,+less+speed.html
21:46:38 <lambdabot> Title: More haste, less speed - UsingEnglish.com
21:46:54 <ddarius> @google "More speed, less haste"
21:46:58 <lambdabot> http://www.heritage.org/Press/Commentary/ed012204a.cfm
21:46:58 <lambdabot> Title: More Speed, Less Haste: Don&#39;t Rush Elections In Iraq
21:47:04 <ddarius> @google "less haste, more speed"
21:47:08 <dmwit> soduko: I've never used Haskore, but your invocation call doesn't look right from a Haskell perspective.
21:47:17 * ddarius can never get this one right.
21:47:18 <soduko> dmwit: why
21:47:19 <lambdabot> Plugin `search' failed with: thread killed
21:47:21 <dmwit> Maybe you meant to pass "ChildSong6.lhs" rather than ChildSong6.lhs?
21:47:23 <ddarius> Cripes.
21:47:28 <dmwit> Or maybe a million other things.
21:47:43 <Cale> http://web.comlab.ox.ac.uk/oucl/research/pdt/ap/papers/jfphaste.ps.gz
21:47:46 <lambdabot> http://tinyurl.com/ynkdyf
21:47:54 <wli> :
21:47:54 <Cale> (there it is)
21:47:56 <ddarius> Ah, I mixed it up.
21:48:03 <omnId> soduko: ChildSong6.lhs is parsed as the function 'lhs' in the module 'ChildSong6'
21:48:16 <soduko> if the file ChildSong6.lhs is in the current directory :load ChildSong6.lhs  should work right?
21:48:27 <ddarius> It's "More Haste, Less Speed: Lazy vs Eager Evaluation"
21:48:27 <omnId> soduko: what's playMidi's type?
21:48:40 <soduko> i dont know i can ask haskell
21:48:55 <omnId>  :t <function>
21:49:01 <ddarius> Haskell is a little dead to be asking him.
21:49:26 <marceau> good evening haskellers
21:49:44 <marceau> i'd like ghc not to load the prelude automatically
21:49:52 <marceau> how can i do that?
21:50:05 <dmwit> import Prelude () -- maybe?
21:50:07 <ddarius> There's a flag.  Check the reference.
21:50:11 <omnId> soduko: type ':t Haskore.<omitted>.playMidi' at the ghci prompt
21:50:13 * wli continues trying to get lhs2TeX output usable within a chapter of a LaTeX document.
21:50:26 <soduko> :t Haskore.Interface.MIDI.Render.playMidi
21:50:27 <lambdabot> Couldn't find qualified module.
21:50:28 <soduko> Haskore.Interface.MIDI.Render.playMidi :: Haskore.Music.GeneralMIDI.T -> GHC.IOBase.IO ()
21:50:31 <ddarius> You can also do what dmwit said if that's more what you mean.
21:50:48 <dmwit> marceau: Just be warned that you will still get instances defined in the Prelude.
21:50:49 <ddarius> (and that is portable)
21:51:06 <marceau> found it: -fno-implicit-prelude
21:51:07 <omnId> soduko: you need to find a way to get a GeneralMIDI.T value.
21:51:31 <dmwit> soduko: Did you try typing in exactly the command shown on the installation page you link to?
21:51:40 <soduko> dmwit: that works
21:51:53 <soduko> loading a .hs file that is in my current directory does not work
21:51:53 <dmwit> So, try this then:
21:52:06 <dmwit> Wait, what?
21:52:08 <dmwit> What do you mean?
21:52:27 <dataangel> ah, thanks for the papers :D
21:53:33 <dmwit> Try one of:
21:53:37 <dmwit> :m + ChildSong
21:53:41 <dmwit> :l ChildSong.lhs
21:53:56 <dmwit> (@soduko)
21:54:03 <ddarius> hmm, this should be a good paper
21:54:43 <soduko> quit, restarted the shell terminal and started witha fresh ghci, and it works now :)
21:54:55 <dmwit> great
21:55:30 <soduko> i did not have to do any other model adding/ :m+ fu. just loaded the file like before and it worked!!
21:55:40 <soduko> wonder what i had done wrong last time though!
21:55:53 <omnId> soduko: what did you type in that worked?
21:56:04 <soduko> :load ChildSong6.lhs
21:56:59 <omnId> yeah, :commands talk directly to ghci to work with files.  If it doesn't start with a colon, it's interpreted as a Haskell expression to be evaluated.
21:57:17 <hpaste>  soduko pasted "ghci terminal contents" at http://hpaste.org/3513
21:58:23 <soduko> is it compulsory to name the module same as the file name?
21:58:40 <ddarius> Except for Main, yes.
21:58:45 <dmwit> No, but you'll need to tell ghci/ghc where to find it if you don't.
21:59:03 <dmwit> Well, when in doubt, trust ddarius over me.
21:59:05 <omnId> soduko: try :cd'ing into the Haskore root.
21:59:19 <omnId> then :load'ing the whole qualified module name.
21:59:30 <ddarius> dmwit, soduko: Why trust either of us, just try it.
22:00:34 <soduko> but that does not seem right.  if i compose my own music, i just want to use Haskore, not have to be in that directory every time.
22:00:45 <soduko> once loaded the module should be available irght?
22:01:53 <omnId> hm?  If the Haskore libs are in ghc's search path, it should find them regardless of where you put your modules with your music.
22:02:09 <dpiponi> I get "configure: error: GHC is required unless bootstrapping from .hc files." when trying to install the ghc (darwin) port. on my macboo Is the ghc port broken?
22:02:37 <soduko> they should be . because one example works
22:02:39 <newsham> http://www.thenewsh.com:8000/png/moire/-19/-19/19/19
22:02:52 <soduko> without having to cd into that directory
22:07:42 <omnId> the problem is that the module 'Haskore.Example.ChildSong6' is known globally in ghc's module space by that full name.  cd'ing into the Haskore tree and trying to load the module directly is cheating.
22:09:40 <soduko> i copied all the examples in Haskore/Example to my current directory
22:09:51 <soduko> and am trying to load the copies.
22:09:57 <omnId> Oh, then just change the module declaration at the top of the files.
22:10:23 <soduko> one mistake was the old module name was still there so i removed that and put the correct name[ smae as File name]
22:11:04 <soduko> but sitll get out of scope errors etc.. may be a hpaste will make it easier to understand and help.. one sec
22:11:46 <hpaste>  soduko pasted "FlipTest.hs" at http://hpaste.org/3514
22:12:27 <soduko> the out of scope message is in http://hpaste.org/3513 towards the end
22:13:09 <omnId> hrm...
22:13:50 <omnId> try :browse Haskore.Interface.MIDI.Save, do you see an 'openMidiFileToString'?
22:17:24 <soduko> *Flip> :browse Haskore.Interface.MIDI.Save
22:17:25 <soduko> toFile :: FilePath -> Haskore.Interface.MIDI.File.T -> IO ()
22:17:27 <soduko> toStream :: Haskore.Interface.MIDI.File.T -> String
22:17:29 <soduko> toOpenStream :: Haskore.Interface.MIDI.File.T -> String
22:17:30 <soduko> *Flip>
22:18:10 <omnId> it would seem this example program is using old API.
22:18:42 <soduko> i assume :browse lists all available functions ina module?
22:18:54 <omnId> exported ones, yes
22:19:02 <soduko> then yeah the example seems to be not uptodate.. back to work on gettign some music
22:19:38 <omnId> replace it with either toStream or toOpenStream, and see if there's anything like testMixedMidi in Haskore.Interface.MIDI.Render
22:20:19 <bparkis> what concepts relate to the appropriateness of a data structure to the data it contains?
22:20:46 <bparkis> i mean things that discuss why you shouldn't encode extra data in a list type, for example
22:21:15 <bparkis> but instead create a separate structure for that data and have a list of those structures
22:21:16 <Cale> bparkis: Well, the way in which those data are intended to be accessed.
22:21:25 <bparkis> yes that's what i mean
22:21:40 <Cale> The reason for that one there is mostly one of abstraction
22:21:56 <Cale> There are lots of functions which already operate nicely on lists.
22:22:06 <bparkis> but let's say you have a list of strings such that the n%3 elements are names, the n%3+1 elements are addresses, and the n%3+2 elements are phone numbers
22:22:10 <omnId> not sure what you mean besides picking a structure with the best complexity for the tasks that you perform on it most.
22:22:16 <bparkis> this is obviously a bad way to represent this data
22:22:20 <Cale> right
22:22:27 <bparkis> basically, it's unparsed
22:22:41 <Cale> Because it's easy to construct values which are invalid.
22:23:30 <ddarius> You want your data structure to be sound.
22:23:31 <bparkis> well, i see your point but i don't think it's the whole story
22:23:48 <ddarius> bparkis: That's a good enough story.
22:24:18 <ddarius> Ideally, you want your data structures to be able to represent only what you want them to represent.
22:24:40 <ddarius> Oftentimes that's inconvenient or impractical (or even impossible)
22:25:01 <ddarius> But usually you can do pretty well.
22:25:10 <bparkis> let's say you have a list of bits such that the n%2 elements are 1 iff the person is married, and the n%2+1 elements are 1 iff the person is male
22:25:20 <soduko> omnId:  thanks for the help.. looks like chose the wrong examples to start with..
22:25:25 <bparkis> that's also a bad representation even though all possible such lists are meaningful
22:25:36 <soduko> there seem to be a lot of other changes required.
22:25:41 <bparkis> assuming a bit can only be 1 or 0
22:25:53 <ddarius> bparkis: How is an odd list treated.
22:26:00 <ddarius> odd list = list of odd length
22:26:13 <bparkis> yes i guess it does not work there, but you could amend it slightly
22:26:28 <bparkis> simply specify that if someone's gender is not specified they are assumed male for example
22:26:47 <bparkis> so an odd list means the last element is the marital status of someone male
22:26:52 <ddarius> I'd just specify "list of even length"
22:27:00 <ddarius> But I get your point.
22:27:14 <bparkis> well Cale's point applies to a list of even length because then you could construct invalid lists (those of odd length)
22:27:17 <ddarius> More or less, the usual software engineering tools.
22:27:31 <ddarius> bparkis: You could construct a type of lists of even length.
22:27:40 <bparkis> ok
22:28:06 <ddarius> So you could consider modifiability, readability, abstraction and naming.
22:28:11 <bparkis> but it is definitely worse than just a list of structures containing a value for marital status and a value for gender
22:28:33 <bparkis> or maybe i shouldn't say "definitely"
22:28:35 <ddarius> bparkis: What are the reasons it's worse? (I do agree.)
22:29:07 <bparkis> well, speaking informally, it is unparsed--the representation is not the same as the meaning
22:29:18 <omnId> data EvenList = Nil | Cons a a (EvenList a)
22:29:24 <ddarius> I'm looking for something more concrete/specific.
22:30:23 <omnId> (forgot the type param in the lhs)
22:30:36 <bparkis> I don't know what you have in mind ddarius
22:31:29 <Cale> data EvenList = Nil | ECons a (OddList a); data OddList = OCons a (EvenList a)
22:31:37 <Cale> data EvenList a = Nil | ECons a (OddList a); data OddList = OCons a (EvenList a)
22:31:43 <ddarius> bparkis: Well, one issue is that it is easy to mix-up which is which. (understandability)  Another issue is that if you want to record more information you have to change everything. (modifiability)
22:31:55 <ddarius> One more try Cale.
22:32:16 <Cale> whoops :)
22:32:19 <Cale> data EvenList a = Nil | ECons a (OddList a); data OddList a = OCons a (EvenList a)
22:32:21 <Cale> heh
22:32:21 <dataangel> Why is lazy evaluation necessary for purity?
22:32:26 <Cale> dataangel: It's not
22:32:27 <ddarius> dataangel: It isn't.
22:32:32 <dataangel> oh
22:32:44 <Cale> dataangel: However, purity is necessary to make lazy evaluation sane to use.
22:32:56 <ddarius> It's just not very practical to have lazy-by-default in an impure language.
22:33:30 <bparkis> understandability and modifiability though are hard to quantify
22:33:36 <ddarius> bparkis: Agreed.
22:33:38 <dataangel> hrm, pretty sure I read somewhere that laziness enabled haskell to "stay pure".
22:33:41 * dataangel checks wikibook
22:33:47 <ddarius> dataangel: The Haskell Retrospective
22:33:50 <wli> Wearing the hair shirt.
22:34:03 <dataangel> ddarius: that was probably it :)
22:34:04 <ddarius> dataangel: That was meant in terms of avoiding "temptation"
22:34:09 <dataangel> oic
22:34:19 <ddarius> There are almost no pure strict languages.
22:34:34 <ddarius> (Not "practical" general purpose ones anyway)
22:34:35 <bparkis> I actually think that if you store them in an even list like the way omnId defined it, it wouldn't necessarily be worse
22:34:35 <dataangel> I'll get to work on that
22:34:54 <bparkis> because you can attach a meaning to that definition that stores the structure
22:35:16 <ddarius> bparkis: It's still not as robust to change as a list of records would be.
22:35:17 <Cale> dataangel: In strict languages, it's been too tempting to just introduce effects directly rather than try to maintain things like referential transparency.
22:35:29 <dataangel> right
22:35:41 * dataangel should be filling out grad school apps
22:35:45 <omnId> dataangel: it takes a lot of effort to figure out when side-effects happen in a lazy impure language.  Lazyness makes impurity hard.
22:35:49 * ddarius should be sleeping.
22:35:52 <bparkis> data MaritalList = Nil | MaritalStatus Bool Bool (MaritalList a)
22:36:09 <omnId> type MaritalList = EvenList Bool
22:36:10 <bparkis> er, data MaritalList = Nil | MaritalStatus Bool Bool MaritalList
22:36:28 <Cale> bparkis: yeah, that's still kind of bad because it mixes concerns
22:36:35 <dataangel> omnId: couldn't a strict language adopt monads?
22:36:38 <bparkis> yes it's the same i just mean that you can attach a meaning to those 2 fields
22:36:45 <bparkis> and then it can be interpreted as already "parsed"
22:37:04 <ddarius> data MaritalStatusList = Nil | MaritalStatusList { status :: Bool, gender :: Gender, rest :: MaritalStatusList }; data Gender = Male | Female
22:37:04 <Cale> dataangel: yes it could
22:37:12 <dataangel> interesante
22:37:20 <ddarius> bparkis: It still ambiguous.
22:37:34 <Cale> dataangel: The biggest problem is that very few languages have typeclasses, which are almost required to make monads a sensible abstraction to define.
22:37:37 <ddarius> You could quantify ambiguity.
22:37:45 <bparkis> how?
22:37:55 <ac> How hard would it be to use CUDA (or some other software like it) to compile Haskell to run on GPUs?
22:38:07 <dataangel> Cale: What aspect of type classes? Java has interfaces and C++ has ABCs
22:38:08 <ivanm> with (//), am I guaranteed that the last element in the list has preference?
22:38:10 <Cale> dataangel: There's no point in talking about monads unless you can write code which is polymorphic over monads.
22:38:24 <dataangel> Cale: C++ has templates and interfaces :)
22:38:24 <Cale> For example:
22:38:30 <Cale> :t sequence
22:38:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
22:38:39 <Cale> right, but it also has to be lightweight
22:38:55 <Cale> Templates *can* be used, but they're annoying as hell.
22:38:58 <dataangel> true
22:39:06 <ddarius> Perhaps not completely precisely/automatically, but you could count how many different ways there are to encode the data into your data structure.  E.g. which Bool is status and which is gender.  Is gender = True mean Male or Female?  That gives 4 different encodings right there.
22:39:09 <dataangel> although with some serious operator overloading magic it could be less hell
22:39:23 <dataangel> phoenix is fricking amazing with the overloading magic
22:39:28 <marceau> there is a functional library for C++ that implements some higher order functions and monads called FC++
22:39:33 <Cale> http://www.cc.gatech.edu/~yannis/fc++/FC++.1.5/monad.h
22:39:55 <Cale> I mean, just look at that, it's ridiculous :)
22:40:00 <dataangel> phoenix allows lazy computation ;p
22:40:16 <Cale> otoh, it does implement comprehensions
22:40:18 <omnId> Cale: Could one express a Java interface Monad<...>?  I'm not sure what to put in the type parameter, could you put a parameterized type itself there?
22:40:31 <Cale> omnId: I don't know.
22:40:40 <ddarius> omnId: I doubt it.
22:40:47 <dataangel> Cale: to its credit, some minor C++ extensions like templated typedefs would make that a lot less ugly
22:40:55 <dataangel> Cale: which I think is in the next standard
22:41:09 <Cale> concepts are effectively typeclasses
22:41:10 <marceau> well and concepts
22:41:23 <ddarius> omnId: interfaces aren't -too- far from type classes (warning precise language) but I don't think they have a chance for constructor classes (which include Monad)
22:41:26 <dataangel> interesante
22:41:45 <dataangel> I suspect they're not making the syntax any less burdensome though
22:41:51 * omnId pokes ddarius
22:42:29 <Cale> One problem which is really hard is that in most OO languages, you have dynamic dispatch which is tied to the data.
22:42:37 <Cale> Whereas, look at the type of return
22:42:49 <omnId> that's true.
22:42:54 <Cale> It's polymorphic if the type of result, not the input data.
22:42:57 <Cale> in*
22:43:10 <dataangel> In the context of haskell, what does 'sharing' mean? fix f = f (fix f) is supposed to be less efficient than fix f = let x = f x in x for reasons of 'sharing'
22:43:34 <ddarius> dataangel: The standard doesn't specify, but probably.  The context of haskell is still pretty wide.
22:43:41 <ac> Does Haskell use llvm or gcc, or both in the backend?
22:44:03 <Cale> dataangel: sharing means that if you have a pattern binding (like that one) or a lambda-bound variable, it will only be evaluated once, and then the result reused for the other occurrences
22:44:03 <ddarius> Haskell is a language.  GHC can be told to use GCC, but uses it's own code generator by default.
22:44:34 <ac> ddarius: please excuse my s/ghc/haskell/
22:45:13 <Cale> dataangel: In the fix f = f (fix f) definition, the (fix f) gets re-evaluated at each step
22:45:34 <ddarius> Cale: Not necessarily, but in practice, yes.
22:45:41 <ac> so I assume ghc's gcc backend is generally less optimal than its own code generator
22:45:42 <Cale> Well, yeah
22:45:54 <ac> is there a great difference between them?
22:46:03 <ddarius> ac: It depends.  For floating point, I think GCC is still preferred.
22:46:21 <dataangel> Cale: Ah, but in "fix f = let f x in x" when it tries to evaluate the x in "f x" it realizes that x was defined before and reuses the def?
22:46:40 <ddarius> ac: Otherwise, I don't think there is a big difference between them except using the native code generator leads to significantly faster compile times.
22:46:41 <Cale> yeah, those occurrences of x are shared
22:46:44 <ac> hmm. so it shouldn't be too hard to use ghc to target graphics cards
22:46:51 <Cale> That is, they're a pointer to the same piece of data.
22:46:56 <dataangel> Cale: by "lambda-bound" I assume you mean is a function parameter? ;p
22:46:59 <Cale> yeah
22:47:05 <Cale> For instance...
22:47:16 * omnId 's double double sense is tingling
22:47:18 * dataangel works on his language lingo
22:47:24 <Cale> omnId: good guess :)
22:47:26 <sjanssen> ac: the C code that ghc generates is seriously twisted
22:47:40 <Cale> let's compare the evaluation of some expressions under strict evaluation, normal order evaluation, and lazy evaluation
22:47:41 <ddarius> sjanssen: Shhh!
22:47:53 <glguy>  xmonad
22:47:53 <ddarius> sjanssen: Just let him go off and make a code generator for graphics cards.
22:47:56 <Cale> double x = x + x
22:48:09 <Cale> Under strict evaluation, we have:
22:48:16 <Cale> double (double 5)
22:48:18 <ac> ddarius: yeah right. I was just curious. It's not like I write compilers in my spare time
22:48:20 <Cale> = double (5 + 5)
22:48:23 <Cale> = double 10
22:48:26 <Cale> = 10 + 10
22:48:28 <Cale> = 20
22:48:30 <omnId> hasn't dataangel been given the double double treatment already?
22:48:32 <ddarius> ac: Wait until you've done Haskell long enough...
22:48:35 <Cale> I don't know :)
22:48:46 <Cale> Have I shown you this before?
22:48:46 <bparkis> so a while ago i was asking about views and was referenced to a paper about it
22:48:47 <dataangel> I don't think so
22:48:47 <omnId> Cale: you need to write down names.
22:48:49 <Cale> okay
22:48:54 <dataangel> lol
22:49:00 <ddarius> @google Wadler Views
22:49:01 <dataangel> not in this context anyway
22:49:03 <lambdabot> http://citeseer.ist.psu.edu/wadler86views.html
22:49:03 <lambdabot> Title: Views: A way for pattern matching to cohabit with data abstraction - Wadler (Res ...
22:49:05 <Cale> Strict evaluation is innermost-first
22:49:12 <bparkis> whereby, for example, complex numbers can be viewed as either polar or cartesian form
22:49:21 <Cale> (usually leftmost first as well)
22:49:32 <Cale> Normal-order evaluation is outermost first
22:49:39 <Cale> So under normal-order evaluation:
22:49:41 <ac> ddarius: I would like to experiment with such things eventually, but I'm probably a year from that
22:49:43 <Cale> double (double 5)
22:49:50 <Cale> = double 5 + double 5
22:49:56 <Cale> = (5 + 5) + double 5
22:50:05 <Cale> = 10 + double 5
22:50:09 <Cale> = 10 + (5 + 5)
22:50:09 <ddarius> ac: Getting -some- compiler written isn't hard, though some parts can be tedious.
22:50:12 <Cale> = 10 + 10
22:50:14 <Cale> = 20
22:50:28 <bparkis> but that's not exactly what i had in mind by views
22:50:30 <ddarius> ac: What's your programming background?
22:50:30 <Cale> That took longer, because we recomputed double 5
22:51:07 <Cale> So lazy evaluation modifies this. It's outermost first, but when a function parameter is duplicated in the body, it shares the results of its eventual evaluation.
22:51:13 <Cale> So:
22:51:16 <Cale> double (double 5)
22:51:23 <Cale> = let x = double 5 in x + x
22:51:27 <omnId> (note: this let just illustrates that the underlying pointer points to the same thing)
22:51:29 <Cale> = let x = 5 + 5 in x + x
22:51:33 <Cale> = let x = 10 in x + x
22:51:36 <Cale> = 20
22:51:41 * omnId had that ready
22:51:41 <ac> ddarius: started with QBASIC when I was a teenager, and have ended up working programming jobs for the last 5 years, become interested in Haskell in the last few weeks
22:51:49 <Cale> and we're back down to the same number of steps as strict evaluation here.
22:51:55 <ddarius> ac: I'm looking for languages.
22:51:57 <bparkis> by a view i didn't just mean an alternative representation of the same data
22:52:08 <ac> ddarius: what sort of language?
22:52:17 <bparkis> i meant a representation of something _derived_ from starting data
22:52:28 <ddarius> ac: What languages have you programmed in?  What is the one you are most comfortable with?
22:52:37 <newsham> whats the most efficient way from Char -> Word8
22:52:52 <dataangel> Cale: Err, does let using lazy pattern matching have any affect that?
22:52:55 <Zao> Ord?
22:52:56 <bparkis> so that, let's say you have a list of people, and one part of a "person" structure is their SSN, for instance
22:53:10 <Cale> In this case, it doesn't matter.
22:53:19 <dataangel> err, "affect that" or "any effect on that" take your pick :)
22:53:26 <bparkis> so then if you wanted to "view" the list by SSN, you would get something similar to a list of SSN's, almost like using a map function
22:53:39 <Cale> well, you certainly don't want let to start off by forcing the evaluation of everything, I suppose
22:53:42 <omnId> duplicating a head: (\(x:xs) -> (x:x:xs)) (0:[]) -> (0:0:[])
22:53:43 <bparkis> but you want operations on that list to be mappable back to the original form
22:53:46 <omnId> but (\xs@(x:_) -> x:xs) (0:[]) -> let xs = 0:[] in 0:xs
22:54:01 <Cale> But here, that wouldn't even happen if it were a strict pattern match: no work is needed to check if something matches x
22:54:05 <ac> ddarius: well, probably most comfortable in Perl, JavaScript, and increasingly with Scheme. I've fooled with a good 5 or 6 languages in the last year or so and have sort of settled on Haskell
22:54:05 <bparkis> so that you could then sort the list of SSNs and convert back to the full "person" view, and the people would be sorted by SSN
22:54:10 <dataangel> hrm...
22:54:46 <newsham> ?hoogle Char -> Word8
22:54:46 <lambdabot> No matches, try a more general search
22:55:04 <bparkis> so that the inverse conversion is not something that you explicitly specify in terms of functions, it's something that's remembered automatically
22:55:04 <omnId> newsham: fromIntegral . fromEnum could work
22:55:06 <Cale> However, the 'let' I used there is really just a representation of what's going on underneath with pointer manipulation.
22:55:07 <ddarius> ac: Okay.  Then starting a compiler would not be a bad idea.  As long as you didn't have C/C++/assembly and maybe some others in there you won't be paralyzed by finding even the thought of a code generator that doesn't do register allocation filthy.
22:55:34 <Cale> Each occurrence of x in the body ends up being a pointer to the same expression.
22:55:45 <dataangel> ddarius: ghc does no register allocation? @_@
22:55:50 <Cale> So when one of them evaluates, that expression is updated with the result
22:56:04 <ddarius> dataangel: How did you come to that conclusion from what I said?
22:56:05 <Cale> and then the others don't have to recompute it
22:56:08 <ac> ddarius: yeah I'm not frightened at the prospect, I just don't have a good enough reason to yet. What did you mean by "I'm looking for languages"
22:56:11 <newsham> is that better than "toEnum.fromEnum' ?
22:56:35 <ddarius> ac: I meant that by "programming background", I was specifically wanting to know what languages you had programmed in.
22:56:40 <dataangel> ddarius: assumed that you were implying that haskell did not
22:56:47 <omnId> @instances-importing Data.Word Enum
22:56:48 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering, Word, Word16, Word32, Word64, Word8
22:56:52 <dataangel> ddarius: have not read whole convo w/ ac :P
22:56:56 <omnId> newsham: don't know
22:57:06 <ac> ddarius: oh, I thought you were yourself looking for a language
22:57:21 <Cale> dataangel: They're talking about writing a new implementation, I think.
22:57:21 * dataangel watches the confusion
22:57:26 <ddarius> I need to poke at my (re)implementation of lollimon.
22:58:12 <ac> should I ask what that is?
22:58:27 <ddarius> My point was that if you've never been in the micro-optimization mindset that C/C++/assembly gives rise to, not having a register allocator won't upset you.  And so you might actually finish your code generator.
22:58:46 <ac> I've written C and a tiny bit of assembly
22:59:06 <Cale> I should write bindings to the rest of the EFL.
22:59:26 <Cale> But if I was going to do that, I think I'd want to get more familiar with c2hs. :)
22:59:30 <dataangel> Cale: enlightenment EFL? @_@
22:59:34 <Cale> yeah
22:59:39 <dataangel> sweet
22:59:49 <Cale> I did Imlib 2
22:59:56 <Cale> (well, most of it)
23:00:00 <dataangel> although enlightenment lost all of its fanciness when aiglx came
23:00:44 <Cale> Well, the composite extension is broken for me, so I don't know :)
23:00:56 <ac> ddarius: what is a register allocator? Would that be logic to attach variables in the code to be compiled to registers?
23:01:40 <ddarius> ac: Yes.
23:02:20 <ddarius> (Well, technically what you described is register assignment but that's usually part of register allocation.)
23:05:39 <ac> ddarius: I think it would take an especially fanatical type of person to write a general purpose code generator without some library or sets of libraries these days. Unless you have a lot of help from something like LLVM, it will most likely be useless, as it would take an enormous amount of work just to get something that's reasonable on X86 and PPC, and whatever else is out there by the time you're close to finishing the project.
23:06:14 <Cale> I haven't run enlightenment in a long time, but the EFL is still a really beautifully designed set of libraries. Could be a little less stateful, but they're certainly convenient.
23:06:15 <dataangel> Cale: not on an intel card, an nvidia card, or an older ati radeon?
23:06:33 <Cale> dataangel: I'm on a Radeon 9800.
23:06:59 <dataangel> Cale: interesting, thought composite with aiglx was well supported under recent xorg, but my radeon box is dead so I haven't tested
23:07:21 <dataangel> Cale: err, I mean well supported on radeon 9800, which is an r300 chipset card
23:07:59 <Cale> Well, I'm using the official ATi driver, and it doesn't appear to be, though maybe I should try it again.
23:09:36 * Cale restarts X to see.
23:09:41 <ddarius> ac: Sometimes you have to.  And it's annoying even with what's available.
23:10:48 <ddarius> ac: That said, it isn't -that- hard to get something reasonable.  It's just a heck of a lot more complicated and error prone.
23:11:18 <ac> ddarius: you mean you have to if existing libraries don't match up with what you want? Does GHC actually have its own or does it use LLVM?
23:11:43 <ddarius> ac: GHC does it itself I'm pretty sure.  I know it doesn't use LLVM.
23:11:56 <ac> don't know why I thought that.
23:12:03 <ddarius> ac: But, for example, dynamic code generation makes most available tools not very useful.
23:12:23 <bparkis> is there any framework where it would make sense so that if you had an integer sorting function, and a list of structures containing integers, you could sort that list of structures using the integer sorting function?
23:12:38 <bparkis> and just a little bit of glue between the integer sorting function and the list of structures
23:13:29 <bparkis> i.e. the integer sorting function is not explicitly parameterized with a comparator, it works for integers only (such as counting sort)
23:13:30 <ac> ddarius: that is something I'm interested in :-P. Because most available tools are optimized for runtime rather than compile time?
23:13:38 <ddarius> bparkis: You could make such a function (if my ideas make sense)
23:13:52 <ddarius> bparkis: But I'm going to sleep.
23:14:12 <bparkis> night
23:14:13 <ac> ddarius: what exactly do you mean by dynamic code generation? Do you mean eval?
23:14:29 <ddarius> ac: Most available tools don't give you the right access or integrate nicely enough, or if they do the allocation for you they aren't using the right algorithms.
23:14:40 <ddarius> ac: eval would be one thing.  Look at Self.
23:15:49 <ac> ddarius: that is a language I know nothing about. What is its interesting features concerning dynamic code generation?
23:18:49 <ac> (I'm hoping I can get away with not looking at it, by getting comparsions with languages like Scheme or JavaScript (which I thought it was somewhat similar too)
23:18:53 <ac> )
23:19:57 <mkehrt> while I've never actually coded in Self, you can get most of the basic ideas in about fifteen minutes, I think
23:20:18 <mkehrt> ac: see above comment
23:20:39 <Cale> aha, xorg doesn't support them, but xgl does.
23:20:56 <ac> mkehrt: by reading the language spec?
23:21:04 <Cale> However, fullscreen GL applications don't seem to be fullscreen
23:21:55 <bparkis> i was thinking you could sort of implicitly 'thread' the full structures together with the integers
23:22:02 <mkehrt> ac: try looking at the paper "Self: the power of simplicity"  by Unger and Smith.  It's an easy read for an academic paper
23:22:21 <bparkis> so that functions on the integers worked on the integers, but whenever a variable appears again, the whole structure is brought along for the ride
23:22:29 <mkehrt> of course, the actual language may be much extended beyond that paper; I really don't know
23:22:41 <mkehrt> ac: http://research.sun.com/techrep/1994/smli_tr-94-30.pdf
23:23:04 <dataangel> Cale: The very newest official ati driver supports AIGLX, only out for a couple of days. But if you're on a radeon 9800 you can just use the open source Xorg one nowadays. You left too fast for me to tell you :P
23:23:06 <mkehrt> (now I will stop talking about things I really know nothing about and go back to doing networks homeworl)
23:23:34 <Cale> dataangel: ah, cool
23:23:39 <dataangel> Cale: Ah, Xorg might be bugged for your specific card or something
23:25:41 <bparkis> but that has problems if pattern matching ever bottoms out and stops using variables, you have a problem
23:26:15 <bparkis> like if you have data Day = Monday | Tuesday | ... | Sunday and you have a nextday function that outputs the next day
23:26:49 <bparkis> and you want to make it work also on something else that has a Day field
23:28:06 <bparkis> you might have nextday Monday = Tuesday and you want to extend that to nextday (Monday, 5) = (Tuesday, 5) but i don't know if that's possible to do automatically
23:28:28 <scook0_> bparkis: (first nextday)
23:28:36 <scook0_> from Control.Arrow :)
23:29:06 <scook0_> or, (nextday *** id), which is equivalent
23:30:59 <newsham> too bad (a,b,c) isnt equiv to (a,(b,c))
23:31:07 <newsham> so you could do (f *** g *** h)
23:31:40 <scook0_> yeah
23:32:05 <scook0_> though you could do something like flatten . (f *** g *** h) . unflatten
23:32:13 <newsham> isabelle treats n-tuples that way
23:44:13 <bparkis> ok, but would that work for sorting?
23:45:35 <bparkis> let's say you have a function--countingsort :: [Int]->[Int] that sorts its input, and you want to turn it into a function that sorts values (Int, Bool) by the Int
23:46:00 <bparkis> that sorts a list, [(Int, Bool)], by the Int of each pair
23:46:19 <LeCamarade> Is TAPL laden with Greek? I need to know, before I spend money on it.
23:47:17 <ac> mkehrt: hmm. Self looks like an ellegant non-broken JavaScript (yes I know ECMAScript was influenced by Self). I didn't see anything in that paper concerning the dynamic code generation ddarius referred to though :P
23:47:25 <bparkis> is there any way to write a function f such that (f countingsort) has the desired behavior?
23:47:30 <aleator> dcoutts: Still no a go: ./gnomevfs/gnomevfs.h:2:40: error: libgnomevfs/gnome-vfs-mime.h: No such file or directory
23:47:46 <bparkis> assuming f doesn't do any sorting of its own
23:48:05 <bparkis> and just somehow acts as glue between countingsort and the list of pairs
23:48:35 <mkehrt> LeCamarade: essentially, yes.  It's full of inference rules and proofs.  In actuallity, I don't think it actually uses greek characters, though ;-)
23:49:10 <mkehrt> ac: Ah, my apologies.  I just looked at the screen and saw someone asking about where to find quick information on self
23:49:20 <ac> mkehrt: it was interesting though
23:49:48 <mkehrt> ac: yeah, self is pretty cool.  Maybe someday I will actually write some code in it ;-)
23:50:50 <dataangel> This is semi-OT but seems appropriate given stereotypes about haskellers ;) If anyone has any grad school ideas for someone looking to do PL research: http://tinyurl.com/37hfs3
23:50:52 <lambdabot> Title: PL research & grad schools? | Lambda the Ultimate
23:50:57 <ac> makes you wonder why JavaScript had to be created. It's definitely better than some languages, but it's kind of a bastard child
23:52:26 <Botje> it was that or java.
23:52:29 <mkehrt> my uninformed guess is that they needed something quick to play with what is now the DOM, and they decided they like prototype languages
23:53:09 <omnId> ac: my last language of play was Io, a very young language that admits heavy influence from the likes of Self and Smalltalk
23:54:01 <araujo> omnId, Io is nice
23:54:05 <araujo> omnId, very simple
23:54:24 <omnId> the sample code page is an excellent advertisement for the language :)
23:55:15 <ac> I almost experimented with Io a while back, but I fooled with Factor instead
