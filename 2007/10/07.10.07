00:00:14 <ramza3> > let x = 2; y = 3 in x + y
00:00:16 <lambdabot>  5
00:00:35 <oerjan> (let is always followed by in, except in do expressions)
00:00:41 <dons> ?yow
00:00:41 <lambdabot> Hold the MAYO & pass the COSMIC AWARENESS ...
00:00:54 <ramza3> oh, I should have known that one
00:00:57 <dons> divip_: which ghc are you using?
00:00:57 <jbauman> @pl \x -> zipWith (*) (scanl1 (*) (1:x)) $ scanr1 (*)  $ drop 1 (x ++ [1])
00:00:57 <lambdabot> ap (zipWith (*) . scanl1 (*) . (1 :)) (scanr1 (*) . drop 1 . (++ [1]))
00:01:11 <dons> divip_: you can use binary 0.3, with ghc 6.6.x
00:01:26 <jbauman> > ap (zipWith (*) . scanl1 (*) . (1 :)) (scanr1 (*) . drop 1 . (++ [1])) [1..5]
00:01:27 <lambdabot>  [120,60,40,30,24]
00:01:38 <ramza3> > let f x = 3
00:01:39 <lambdabot>  Parse error
00:01:46 <divip_> dons: ghc 6.6
00:02:05 <ramza3> > let f x = 3  * x
00:02:05 <lambdabot>  Parse error
00:02:09 <dons> right, so you need binary 6.6
00:02:13 <dons> binary 0.3
00:02:17 <dons> (i mean)
00:02:53 <sarehu> ramza3: let <something> = <replacement for something> in <expression>
00:02:54 <oerjan> ramza3: lambdabot > is just expressions
00:03:05 <oerjan> but there is @let
00:03:08 <jbauman> > ap (zipWith (*) . scanl1 (*) . (1 :)) (scanr1 (*) . drop 1 . (++ [1])) [1,2,5,4,3]
00:03:09 <lambdabot>  [120,60,24,30,40]
00:03:31 <sarehu> > let f x = 3 * x in f 8
00:03:33 <lambdabot>  24
00:03:46 <mudge> say I do: line <- hGetLine,   how would I then manipulate the string line with haskell functions like say reverse?
00:03:51 <ramza3> it will take me a year to learn haskell
00:04:05 <mudge> line becomes IO String,   how do I reverse it?
00:04:13 <oerjan> mudge: no, line is String
00:04:16 <sarehu> mudge: you mean hGetLine h?
00:04:34 <mudge> yea,  hGetLine h
00:04:36 <oerjan> the <- "removes" the monad
00:05:28 <mudge> oh yea, thanks
00:11:30 <divip_> Lambdabot from darcs was compiled successfully with binary-0.3. Remark: had to run: chmod a+x configure
00:12:01 <newsham> do { line <- hGetLine; let rline = reverse line; print rline }
00:13:16 <oerjan> > runWriterT $ runReader (do line <- ask; let rline = reverse line; tell rline) "testing"
00:13:16 <lambdabot>  Parse error
00:14:56 <oerjan> oh right
00:15:10 <oerjan> > runWriterT $ runReader (do line <- ask; let {rline = reverse line}; tell rline) "testing"
00:15:18 <lambdabot>  Couldn't match expected type `WriterT w m a'
00:15:56 <oerjan> :t runWriterT
00:15:58 <lambdabot> forall w (m :: * -> *) a. WriterT w m a -> m (a, w)
00:16:37 <newsham> > runState (do {l <- get; let rl = reverse line; return rl}) "testing"
00:16:37 <lambdabot>  Parse error
00:16:49 <oerjan> > runReader (runWriter $ do line <- ask; let {rline = reverse line}; tell rline) "testing"
00:16:49 <lambdabot>  Couldn't match expected type `Reader r a'
00:17:04 <oerjan> > runReader (runWriterT $ do line <- ask; let {rline = reverse line}; tell rline) "testing"
00:17:06 <lambdabot>  ((),"gnitset")
00:17:42 <mudge> if i'm reading a file with hGetLine h,   how do I handle it when end of file is reached?
00:17:55 <oerjan> :t hIsEOF
00:17:57 <lambdabot> Not in scope: `hIsEOF'
00:18:04 <oerjan> :t System.IO.hIsEOF
00:18:06 <lambdabot> GHC.IOBase.Handle -> IO Bool
00:18:18 <mudge> yea, what do I do with isEOF?
00:18:38 <sarehu> use it to see if you're at the end of the file
00:19:21 <mudge> how?
00:19:52 <oerjan> loop = do e <- hIsEof h; unless e $ do line <- hGetLine h; ... ; loop
00:20:04 <oerjan> for example
00:21:10 <mudge> oerjan: thanks a bunch
00:35:45 <mgsloan> where might I find the source code for the corelibs? stuff like Control.Monad.State
00:37:34 <dibblego> ghc6-libsrc (debian)
00:41:36 <mgsloan> ah, I suppose that works
00:41:40 <mgsloan> thansk
00:49:20 <mlh> I'm trying to compile hs-plugins.  configure fails with gcc, claiming it can't create executables.
00:49:50 <mlh> checking the config.log, TOP is defined as the current dir + newline + some ansi escape; no wonder it can't compile
00:49:55 <mlh> anyone seen this before?
01:03:30 <mudge> alright, can some please tell me if you get any errors of any kind: http://24.7.167.34:1250/
01:03:44 <mudge> testing my new web server: http://24.7.167.34:1250/
01:04:25 <mlh> mudge: WFM!
01:04:34 <mudge> WFM?
01:05:14 <divip> mudge: can see: This is my first attempt at a web server!
01:05:24 <mudge> whoop!   it works!
01:05:26 <mudge> it is alive!
01:05:31 <mudge> no errors?
01:05:36 <divip> no
01:05:41 <mudge> no connection reset errors?
01:05:47 <divip> congratulation :)
01:05:54 <mudge> thanks
01:06:16 <divip> no errors at all
01:06:56 <mudge> cool,  wow,  everyone uses firefox
01:07:07 <mudge> anyone got internet explorer?
01:08:02 <oerjan> looking fine
01:08:24 <mudge> ah, there's safari
01:08:24 * johnnowak has safari
01:09:26 <sorear> mudge: http://members.cox.net/stefanor/1191744523.png
01:09:30 <sorear> NOT firefox
01:09:47 <sorear> and still works fine!
01:10:49 <mudge> whoop!
01:11:06 <mudge> I fixed it so that it actually reads the request from the client before sending the response
01:11:08 <hpaste>  dibblego pasted "mudge, not firefox!" at http://hpaste.org/3127
01:12:09 <mudge> rad, thanks dibblego
01:12:42 <sorear> uh
01:12:51 <sorear> mudge: dibblego's session is an error
01:13:08 <dibblego> why?
01:13:22 <dibblego> it's standard HTTP 1.0
01:13:44 <sorear> servers are supposed to respond to HTTP 0.9 compatible requests (no version number) by (a) not waiting for more fields, respond on the first CRLF rather than the second (b) not sending headers
01:14:19 <dibblego> ah yes
01:14:32 <geocalc> mudge-> put the haskell logo !
01:15:13 <mudge> geocalc:  okay!
01:17:31 <geocalc> btw epiphany here and working
01:18:06 <mudge> gecalc:  cool,   the logo is up now: http://24.7.167.34:1250/
01:18:28 <geocalc> i just saw
01:18:55 <geocalc> i love this logo !
01:20:07 <kaol> that's cheating, linking to haskell.org. Can your server serve images by itself?
01:21:25 <mudge> :)  I did that to be really fast
01:21:42 <geocalc> for your server name how will you do mudge ?
01:21:54 <mudge> sure,  I can put it somewhere
01:22:22 <mudge> not sure,  I was thinking Hiva,   but then I was thinking Hero (because I like the Heroes TV show)  but i'm not sure
01:51:11 <jbauman> @pl \x y z a -> x (y a) (z . y . z a)
01:51:11 <lambdabot> (`ap` (liftM2 (.) (.) . (.) . (.))) . (((.) . ap) .) . (.)
01:51:35 <jbauman> @pl \x z y a -> x (y a) (z . y . z a)
01:51:36 <lambdabot> (. ap ((.) . (.) . (.)) (flip ((.) . (.)))) . ap . liftM2
01:52:06 <jbauman> @pl \a -> x (y a) (z . y . z a)
01:52:06 <lambdabot> liftM2 x y (((z . y) .) . z)
02:22:47 <dons> haskell workshop videos, http://web.mac.com/malcolm.wallace/HaskellWorkshop.html
02:22:48 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
02:23:11 <dons> tibbe++
02:23:16 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/network-bytestring-0.1.1
02:23:19 <lambdabot> http://tinyurl.com/24uos9
02:34:31 <gour> hi, i was absent few days, so i'm interested who won the 1st icfp prize?
02:39:06 <dibblego> why are MonadPlus functions not just declared in Monad?
02:48:39 <roconnor> Igloo: where?
02:49:17 <roconnor> http://en.wikipedia.org/wiki/Lady_Day
02:49:18 <lambdabot> Title: Lady Day - Wikipedia, the free encyclopedia
02:49:19 <roconnor> thx
02:53:44 <vincenz> what is that?
03:05:31 <EvilTerran> dibblego, as in Control.Monad, or class Monad?
03:18:56 <dibblego> EvilTerran, class Monad, or is there a good reason?
03:19:36 <EvilTerran> well, it'd be difficult to define mzero and mplus for some monads
03:19:51 <EvilTerran> @instances Monad
03:19:53 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:19:54 <EvilTerran> @instances MonadPlus
03:19:55 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
03:20:06 <dibblego> yeah I guess
03:20:15 <EvilTerran> how'd you do mzero and mplus for (r->), say?
03:20:20 <dibblego> yes, good point
03:21:08 <EvilTerran> some people are upset enough about the inclusion of fail (being very similar to mzero) in Monad
03:22:13 <axm> \msg lambdabot @hoogle ->
03:22:28 <dibblego> because it disallows a higher abstraction?
03:22:33 <axm> i will never remember which slash to take
03:22:59 <EvilTerran> irc doesn't like your dirty communist slash. try one that leans to the right. ;)
03:23:17 <vincenz> EvilTerran: you're calling lambdas evil communist propagation?
03:23:23 <axm> ok, one way to remember..
03:23:27 <EvilTerran> well, it leans to the left...
03:23:41 <EvilTerran> dibblego, because it's not a property of monads in the categorical sense, for one. and, for a lot of monads, it's impossible to define as anything sensible other than _|_
03:24:10 <dibblego> then, for what reason *does* it exist?
03:24:23 <EvilTerran> you could argue that, for something with a name like "fail", _|_ is a sensible value, OTOH
03:24:47 <EvilTerran> @undo \y -> do (x:xs) <- y
03:24:47 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
03:24:53 <EvilTerran> @undo do (x:xs) <- y
03:24:57 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
03:25:02 <EvilTerran> @undo do (x:xs) <- y; return x
03:25:05 <lambdabot> (y >>= \ a -> case a of { (x : xs) -> return x; _ -> fail ""})
03:25:19 <EvilTerran> @type \y -> (y >>= \ a -> case a of { (x : xs) -> return x; _ -> fail ""})
03:25:25 <lambdabot> forall (m :: * -> *) t. (Monad m) => m [t] -> m t
03:25:46 <EvilTerran> it's so you don't get a MonadPlus class constraint on do{} blocks with patterns that can fail
03:26:33 <EvilTerran> i'd personally be happy if they brought back MonadZero, and put *that* as a constraint on such do blocks, but not on ones that *don't* use fail/mzero
03:29:11 <axm> as i understand, the <- and -< arrow operators are not real operators but replaced by a preprocessor, is that still true in ghc?
03:29:32 <EvilTerran> yes
03:29:40 <axm> is there a -<< as well?
03:29:48 <EvilTerran> what would that do?
03:29:56 <Igloo> They aren't preprocessed in GHC, they're handled y the lexer/parser
03:30:11 <axm> thats what i want to find out, it is in code i do not understand yet
03:30:27 <EvilTerran> well, yes, but they're transformed into stuff from Control.Arrow
03:31:37 <axm> so i had to look for a place, where somebody had defined such a replacement? is that possible for user modules?
03:32:48 <axm> nevermind for now, found something to chew on in the ghc manual
03:33:06 <EvilTerran> @where arrows
03:33:06 <lambdabot> http://www.haskell.org/arrows/
03:34:08 <sioraiocht> one day, I will understand arrows
03:34:11 <sioraiocht> but that day is not today
03:34:24 <axm> no, thats where i looked first, nothing there. might be ghc specific
03:34:38 <axm> http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
03:34:40 <lambdabot> Title: 7.7. Arrow notation, http://tinyurl.com/tts6c
03:54:10 <ciphergoth> I'm just starting out learning Haskell, and since I'm an Eclipse person I've got EclipseFP.  I've written "hello world", and it looks like it builds fine, but when I try and run it it just complains it can't find the executable.  What am I doing wrong?
03:55:43 <axm> tried to find that executable in the output dir manually?
03:55:47 <ciphergoth> from the look of the .hsproject file it looks like there should be an executable called "theResult" in the bin directory, but there is none
03:57:05 <axm> tried another way to compile to see if it really works?
03:57:43 <ciphergoth> yes
03:58:11 <ciphergoth> if I compile with ghc --make -o helloworld HelloWorld.hs
03:58:14 <ciphergoth> it works fine
03:58:45 <ciphergoth> oops
03:58:48 <ciphergoth> no, I'm wrong
03:59:28 <DRMacIver> Hm. Is there a standard type for representing a single bit?
03:59:37 <DRMacIver> (I know I can use Boolean)
04:03:13 <ciphergoth> axm: thanks for prompting me to test it again - the problem was that my Main module was no longer called Main.  Sadly, it's now building the executable but I still can't run it
04:03:41 <ciphergoth> it still complains it can't find it
04:03:53 <axm> and from commandline?
04:04:33 <ciphergoth> builds and runs fine
04:05:01 <ciphergoth> there's a theResult that does what I want, and even updates correctly whenever I change the sources
04:05:23 <ciphergoth> I know this is an EclipseFP question not a Haskell question - hope that's OK.
04:05:27 <axm> and the built from eclipse runs fine manually?
04:05:55 <axm> i havent had a look at that plugin, is there good indentation support?
04:06:16 <axm> and preferably a deb available?
04:06:28 <ciphergoth> don't know
04:06:40 <ciphergoth> the one built from Eclipse runs fine manually
04:06:52 <ciphergoth> I don't know if there's a deb - I used Eclipse's package format
04:07:15 <ciphergoth> though Eclipse itself is fetched via aptitude (I'm running Ubuntu Gutsy Gibbon beta)
04:07:18 <sioraiocht> hrm, I've neer used eclipse, what does it have to offer for FP over emacS?
04:07:24 <ciphergoth> I've sworn off Emacs
04:07:42 <axm> ah, yes, forgot how to plugin eclipse
04:07:46 <sioraiocht> ciphergoth: why?
04:07:57 <MyCatVerbs> sioraiocht: near as I can tell, it's basically emacs.
04:08:10 <sioraiocht> MyCatVerbs: okay, I don't feel so bad for not caring about it, then =p
04:08:18 <ciphergoth> It was my first editor over a decade ago, but it's just so out of place in a modern desktop environment
04:08:28 <MyCatVerbs> sioraiocht: written in Java instead of elisp, and with a pretty-ish GUI, but it's basically IBM's unwitting recreation of emacs from scratch, except much less powerful.
04:08:31 <ciphergoth> I got tired of the eclectic keybindings and cut buffer stuff
04:08:38 <LoganCapaldo> it was starting to interfere with his life, the late nights, missing work, spending more time with emacs than his family...
04:08:41 <ciphergoth> it is basically the next emacs
04:08:49 <MyCatVerbs> sioraiocht: it's hilarious, actually.
04:08:53 <sioraiocht> hahahah
04:08:58 <ciphergoth> and it's not at all clear which is the more powerful
04:09:05 <sioraiocht> I actually hate GUI editors
04:09:05 <MyCatVerbs> sioraiocht: IBM sent a couple of people down here last year to pimp emacs at people in our university.
04:09:24 <sioraiocht> which uni?
04:09:30 <MyCatVerbs> sioraiocht: bris.ac.uk
04:09:42 <LoganCapaldo> Thank you IBM,for pimping my emacs
04:09:48 <sioraiocht> LOL
04:10:09 <sioraiocht> ah! i had consideredapplying to bristol
04:10:18 <MyCatVerbs> sioraiocht: and they spent a lot of the time making fun of emacs. Which, uh, well, anyone with two operating hemispheres instantly noticed that, hey, this is just a GUIfied recreation of emacs with a shittier programming language at the centre.
04:10:25 <ciphergoth> Certainly, no'one's going to complain about Emacs being a memory hog any more :-)
04:10:48 <sioraiocht> MyCatVerbs: yeah, eff writing plugins in java
04:10:51 <MyCatVerbs> sioraiocht: so at least some of us spent the whole time deliberately suppressing the urge to laugh out loud in the poor IBMers' faces.
04:11:01 <MyCatVerbs> ciphergoth: heh.
04:11:04 <ciphergoth> but I used to live in Emacs and learned to write Emacs-Lisp, and I'm very glad to have put it behind me
04:11:12 <MyCatVerbs> ciphergoth: well, y'know...
04:11:16 * MyCatVerbs waves at yi. ;)
04:11:17 <ciphergoth> I think you all underestimate eclipse enormously
04:11:27 <sioraiocht> I can't imagine doing large latex documents without AuCTeX anymore
04:11:32 <ciphergoth> heh
04:11:39 <ciphergoth> I use LyX for that now!
04:11:45 <sioraiocht> GROSS
04:11:47 <ciphergoth> and again, I used to program in TeX
04:11:56 <ciphergoth> heh, thought you'd love that
04:12:09 <pjd> MyCatVerbs: did you mean to say that IBM went to pimp Eclipse?
04:12:11 <ciphergoth> but being able to see your formulae is just such a huge boon
04:12:22 <sioraiocht> ciphergoth: that's what compiling is for
04:12:23 <sioraiocht> =p
04:12:40 <sioraiocht> anyone know of some good guides to academic CVs? I'm thinking mine needs a bit of an overhaul
04:12:42 <axm> at least eclipse has a big usability flaw by hiding the update/plugin menu within the help menu.
04:12:43 <ciphergoth> and you're just used to kissing off the time that costs you
04:12:49 <MyCatVerbs> pjd: uh, yes.
04:12:52 <ciphergoth> yes, that's a big usability flaw.
04:13:07 <ciphergoth> well, don't know about "big" as such but certainly "howling
04:13:12 <sioraiocht> ciphergoth: I used LyX for two days, it took me sooo much longer do typeset anything
04:13:18 <pjd> MyCatVerbs: ok :)
04:13:19 <MyCatVerbs> pjd: they sent something like eight people around some sizeable fraction of the universities in the country to try to encourage people to use it.
04:13:39 <ciphergoth> sioraiocht: yes, it took me some adjustment time
04:13:44 <ciphergoth> but I was glad of it in the end
04:14:59 <ciphergoth> I did do one gross hack for one paper once though - I wrote a post-processor for its TeX output to get it just the way i wanted...
04:15:13 <sioraiocht> this example is crap, who would put their A-levels on their CV after getting their doctorate?
04:15:21 <ciphergoth> thankfully it got better after that and the hack stopped being necessary.
04:15:34 <sioraiocht> ciphergoth: to each their own, I guess ;)
04:15:41 <ciphergoth> indeed
04:16:11 <ciphergoth> anyway, I get the impression I'm not surrounded by Eclipse enthusiasts and I should come back when I have a real Haskell problem :-)
04:17:23 <axm> oh, i am. for java at least
04:18:27 <ciphergoth> axm: cool :-) I don't know yet whether EclipseFP is any good - I shall report back when I know.
04:19:09 <axm> too, late, after i figured out, that the next button will stay marked inactive (grey), but works fine, it is installing now ;)
04:21:30 <ciphergoth> axm: the other problem I'm having is that F11 doesn't work - it seems to do something different than selecting the corresponding menu option.
04:23:24 <ciphergoth> axm: ah, no, Ctrl-F11 works.  No integrated debugger you see.  Argh.
04:24:10 <axm> if you get hat or something running with it, i am interested
04:25:43 <axm> ok, hello world here works fine
04:26:12 <axm> apart from eclipse errors popping up all the time, seemingly without reason
04:26:38 <axm> (whenever i change to the haskell editor and when i save it saves but tells me it couldn't)
04:26:57 <axm> what file exactly are you trying to run?
04:29:02 <axm> indentation support is crappy by the way, if i do not have to activate it first for some reason
04:36:27 <legrande> why is the syntax of haskell, clean and erlang all so similar?
04:36:43 <wilx> Are they?
04:36:57 <wilx> Erlang seems pretty disimillar.
04:37:23 <legrande> well, similar in the way that php, perl and c are similar
04:39:36 <legrande> is it just the generally best way to write functional programs or do they share a common ancestor?
04:39:53 <EliasAmaral> maybe ml?
04:41:21 <EliasAmaral> i found ml syntax very similar to haskell. and ml is older
04:45:15 <Lycurgus> the general lineages is ML - Miranda - haskell
04:45:25 <Lycurgus> s/s//
04:45:28 <opqdonut> yeah i think it's more of a hereditary thing
04:45:39 <opqdonut> just like c-like syntax is everywhere because of C :)
04:45:58 <opqdonut> and php is perl-like because of perl
04:47:01 <EvilTerran> miranda looks kinda like ML and haskell to me
04:47:19 <Lycurgus> and both (php and perl) are C-like which is in turn Algol-like and that's the end of the (conventional/actually used) programming line
04:47:54 <platypus> scheme and common list are like that because of lisp.  The wirth languaged are algol like in a diffrent direction.
04:48:00 <platypus> languages.
04:48:42 <platypus> Python is haskell like
04:49:20 <EliasAmaral> i don't know why ml isn't lisp-like. it would make sense for me
04:50:48 <dons> ?join #haskell-hac07
04:51:40 <ac> EliasAmaral: I find that S-expressions are more verbose than Haskell's syntax
04:52:43 <EliasAmaral> hmmmm.. yes they are
04:52:49 <EliasAmaral> they are also simpler
04:52:57 <ac> yes, which I agree is nice
05:05:26 <EliasAmaral> this whole subject remember me the quote "It is possible that software is not like anything else, that it is meant to be discarded: that the whole point is to always see it as soap bubble?", from Alan Perlis, I don't know why:)
05:10:07 <DRMacIver> Hm. What's the current state of play on being able to use "data family" declarations in GHC?
05:10:22 <DRMacIver> Only in head?
05:13:06 <dons> yep
05:13:36 <dons> live from the hackathon, http://cgi.cse.unsw.edu.au/~dons/blog/2007/10/07#hac07-2-day3
05:13:37 <lambdabot> Title: Haskell hacking
05:14:05 <waern> DRMacIver: if you want to play with it you can download a GHC release candidate
05:14:28 <DRMacIver> It's not so much that I want to play with it (though I do) as that I was doing something and thought "Hm. I really want a data family here."
05:15:15 <DRMacIver> Never mind. I'll take the opposite approach and remove rather than add abstraction.
05:15:26 <DRMacIver> It's only internal code anyway.
05:16:32 <DRMacIver> Thanks
05:17:45 <ac> @seen quicksilver
05:17:45 <lambdabot> quicksilver is in #haskell and #ghc. I don't know when quicksilver last spoke.
05:17:52 <merus> Do you know if xmonad plays nice with Apple's X11?
05:18:45 <ac> speaking of xmonad, has anybody here used the sawfish window manager?
05:19:06 <LoganCapaldo> once upon a time
05:19:14 <ac> Is xmonad comparable or better?
05:19:25 <bos> it's not comparable
05:19:46 <dons> merus: it does play well, yes
05:19:49 <LoganCapaldo> yeah i wouldn't really know how to make that comparision
05:19:55 <dons> merus: not sure there are serious users, but it definitely works
05:19:57 <merus> dons: coolness. I'll have to try it out sometim.
05:19:59 <merus> *sometime.
05:19:59 <LoganCapaldo> yes there both window managers...
05:20:07 <LoganCapaldo> s/there/they're/
05:20:15 <LoganCapaldo> and that's like it :)
05:20:42 <dons> bos, http://cgi.cse.unsw.edu.au/~dons/blog/2007/10/07#hac07-2-day3 :)
05:20:42 <lambdabot> Title: Haskell hacking
05:24:20 <DRMacIver> Hm.
05:24:34 <MyCatVerbs> dons: ! Nice. :)
05:24:53 <MyCatVerbs> "cabal install" sounds like six different flavours of awesome.
05:25:28 * LoganCapaldo can't hackathon
05:25:30 <ac> Is there a "split list" function, like splitList :: [a] -> ([a], [a]), where the tupple of lists returned are identical?
05:25:43 <ac> @hoogle [a] -> ([a], [a])
05:25:44 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
05:25:44 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
05:25:44 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
05:26:05 <MyCatVerbs> Though I sure hope it'll have ridiculous configurability, since I need things like funny settings for --with-hc-pkg and --prefix when working on certain machines.
05:26:07 <ac> nevermind, that question doesn't make sense-
05:26:30 <LoganCapaldo> I can't concentrate with all the other people around so i get no coding done
05:27:07 <MyCatVerbs> LoganCapaldo: hee. One guy in uni here, I can't get -any- work done around, nor vice versa.
05:27:23 <bos> dons: nice!
05:27:43 <MyCatVerbs> LoganCapaldo: we waste so much time distracting each other (and ourselves) with "hey c'mere lookit this fucking awesome shiny thing I just installed in my ~" that we just never get anything done.
05:30:16 <LoganCapaldo> heh
05:30:51 <LoganCapaldo> It's not evne like that, it's just the noise of the keyboards and stuff and when people ask other people questions, I can't get going at all
05:31:16 <LoganCapaldo> or like someone will walk in or out of the room
05:33:28 <LoganCapaldo> I'm just a lousy hackthoner
05:38:18 <DRMacIver> Ow.
05:38:31 <DRMacIver> Trying to reason about infinite data structures still makes my head hurt.
05:39:46 <DRMacIver> (Although I guess it's not just the infinitude that's making this code make my head hurt right now)
06:01:40 <therp> how do I get a CInt from an Int?
06:02:01 <therp> hoogle doesn't know any function that gives a CInt
06:02:21 <EvilTerran> "These types are are represented as newtypes of types in Data.Int and Data.Word, and are instances of Eq, Ord, Num, Read, Show, Enum, Typeable, Storable, Bounded, Real, Integral and Bits."
06:03:05 <EvilTerran> so fromIntegral or toEnum should work
06:03:46 <fasta> It would be nice if I could express take either tail or init(depending on what's faster) to the compiler.
06:03:46 * EvilTerran generally uses toEnum
06:04:04 <therp> evilterran: CInt isn't a newtype http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Types.html -- and also I don't want to go to Int, but rather "Int -> CInt"
06:04:06 <lambdabot> http://tinyurl.com/2x9kwh
06:04:37 <therp> at least here it's "data CInt" -- with no constructor
06:04:38 <EvilTerran> i refer you to http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Types.html#2
06:04:39 <lambdabot> http://tinyurl.com/2x9kwh
06:04:47 <fasta> @src tail
06:04:48 <lambdabot> tail (_:xs) = xs
06:04:48 <lambdabot> tail []     = undefined
06:04:50 <fasta> @src init
06:04:50 <lambdabot> init [x]    = []
06:04:51 <lambdabot> init (x:xs) = x : init xs
06:04:51 <lambdabot> init []     = undefined
06:05:14 <olsner> so, init = butlast?
06:05:22 <fasta> Oh, that's rather obvious
06:05:23 <fasta> Never mind
06:05:45 <EvilTerran> it says there they're newtypes, anyway. regardless, the relevant part of the bit i was quoting was "are instances of ... Num, ... Enum, ... Integral..."
06:05:46 <fasta> Still, I guess there are other cases where it might be nice.
06:06:02 <therp> evilterran: how does this give me CInt instances?
06:06:19 <EvilTerran> you want a function Int -> CInt, right?
06:06:28 <therp> evilterran: I would prefer a concrete example. I've read the docs and I can't make any sense of it. Yes Int -> CInt.
06:06:36 <olsner> @type fromIntegral
06:06:38 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:06:57 <EvilTerran> ?instances-importing Foreign.C Enum
06:06:57 <olsner> @type fromIntegral :: (Integral a) => a -> CInt
06:06:58 <lambdabot> (), Bool, CChar, CClock, CDouble, CFloat, CInt, CIntMax, CIntPtr, CLDouble, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CTime, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong,
06:06:58 <lambdabot> CUShort, CWchar, Char, Double, Float, Int, Integer, Ordering
06:06:59 <therp> ah ok
06:07:00 <lambdabot> Not in scope: type constructor or class `CInt'
06:07:03 <EvilTerran> CInt is an instance of Enum
06:07:06 <EvilTerran> ?type toEnum
06:07:08 <lambdabot> forall a. (Enum a) => Int -> a
06:07:17 <therp> olsner thanks
06:07:25 <EvilTerran> so Int -> CInt is a specialisation of the type of toEnum
06:07:26 <therp> evilterran: sorry had a different idea of what's in the instance class
06:07:30 <therp> thanks
06:07:34 <EvilTerran> likewise, fromIntegral
06:13:09 <ac> anybody have any ideas why gtk2hs breaks from within ghci? My gtk programs work fine when compiled with ghc, but when loaded from ghci I get the following:
06:13:13 <ac> HSgtk.o: unknown symbol `containerszm0zi1_DataziSequence_index_info'
06:13:15 <ac> ghc-6.8.0.20071003: unable to load package `gtk-0.9.12'
06:13:50 <ac> Makes interactive development troublesome
06:16:50 <idnar> @src sum
06:16:51 <lambdabot> sum = foldl (+) 0
06:17:35 <ac> this place is too quiet on a Sunday :P
06:20:30 <DRMacIver> Hm.
06:20:33 <MyCatVerbs> ac: indeed.
06:20:37 <DRMacIver> I really don't understand GHC's error messages. :-/
06:20:46 <ac> I want to make an array that's indexable with lists
06:21:03 <ac> Would it be easy to implement an Ix instance for lists? Why isn't it already there?
06:21:11 <EvilTerran> @src Ix
06:21:11 <lambdabot> class (Ord a) => Ix a where
06:21:11 <lambdabot>     range           :: (a,a) -> [a]
06:21:11 <lambdabot>     index           :: (a,a) -> a -> Int
06:21:11 <lambdabot>     inRange         :: (a,a) -> a -> Bool
06:21:11 <lambdabot>     rangeSize       :: (a,a) -> Int
06:21:14 <xerox> ac: you want an infinite-dimensional array?
06:21:19 <ac> xerox: exactly
06:21:29 <EvilTerran> looks a bit fiddly
06:21:32 <ac> xerox: or at least i want to specify the dimension when I construct it
06:21:40 <dons> win 5
06:21:42 <xerox> ac: I guess you're better off using lists that way
06:21:53 <EvilTerran> i'd suggest a trie rather than an array for that ,ac
06:22:01 <ac> EvilTerran: what's a trie?
06:22:06 <EvilTerran> ?wiki Trie
06:22:07 <lambdabot> http://www.haskell.org/haskellwiki/Trie
06:22:18 <EvilTerran> hm. http://en.wikipedia.org/wiki/Trie
06:22:19 <xerox> ac: what about using n-tuples.
06:22:19 <lambdabot> Title: Trie - Wikipedia, the free encyclopedia
06:22:36 <ac> That page is emptey :P
06:22:49 <xerox> ac: plain n-tuples will not scale too well, but if you compose them as (_,(_,(_, ... ))) you can get as many as you want.
06:23:00 <EvilTerran> if you want something there's already a library for, i think you can index a Data.Map with lists
06:23:38 <hpaste>  DRMacIver pasted "Error message help" at http://hpaste.org/3132
06:23:56 <ac> xerox: interesting. Can you construct an n-tupple at runtime?
06:23:58 <DRMacIver> I'm sure it's something trivial and stupid, but I don't understand the above error message. :)
06:24:21 <EvilTerran> do you have scoped type variables on?
06:24:23 <xerox> ac: yes
06:24:27 <DRMacIver> No
06:24:33 <DRMacIver> Do I need to?
06:24:38 <ac> xerox: I mean obviously you can, but you're saying you can specify "n" at runtime
06:24:53 <EvilTerran> try it. i'm not sure. ;)
06:25:11 <DRMacIver> And if so, why? I assumed the type variables of the function definition would be visible in the 'where' clause.
06:25:12 <EvilTerran> {-# LANGUAGE ScopedTypeVariables #-}
06:25:13 <olsner> DRMacIver: could it be that the where-defined functions aren't as polymorphic as you claim? i.e. that the type terminal :: FSM a should refer to the same 'a' as compile's 'a'?
06:25:14 <DRMacIver> Ok.
06:25:32 <EvilTerran> they aren't visible that way without scoped type variables, iirc
06:25:41 <DRMacIver> ok. That's the problem then.
06:25:55 <DRMacIver> olsner: Yes, it's certainly my intent that they be the same.
06:26:03 <olsner> I've seen similar error messages that popped up when trying to give types to functions in the where clause
06:26:35 <DRMacIver> The error doesn't disappear if I remove the type declaration for compiler
06:26:37 <xerox> ac: it can be done either way, but things can get hairy with typeclass hackery
06:26:50 <ac> xerox: I guess you can do the same thing in C, can't you?
06:27:56 <xerox> ac: the most straightforward map from C's malloced n-dim arrays to a corresponding Haskell data structure goes to lists of lists I guess.
06:28:25 <twanvl_> ac: you could also try using [a] as the index type
06:28:57 <DRMacIver> EvilTerran: Do I need to turn on any command line flags to get ghci to notice those? It doesn't seem to have any effect.
06:29:34 <DRMacIver> (Or for ghc)
06:29:42 <ac> twanvl_: doesn't work
06:30:07 <ac> just out of curiosity, can you key a Data.Map with any type?
06:30:25 <DRMacIver> Yes, but most of the functions require an Ord constraint on that type.
06:30:35 <DRMacIver> Or at the very least an Eq constraint.
06:31:30 <ac> DRMacIver: neat, and of course lists comply with both
06:31:54 <fasta> DRMacIver: Eq on a Data.Map?
06:31:58 <fasta> DRMacIver: since when?
06:32:07 <twanvl_> range ([],[]) = [[]] ; range (x:xs,y:ys) = (:) <$> range (x,y) <*> range (xs,ys) -- this could work
06:32:48 <xerox> ac - I think you could also ponder some more specialized datatypes for your problems. It makes much sense in Haskell to use carefully crafted datatypes for very specific problems.
06:33:25 <EvilTerran> DRMacIver, as i said, i'm not entirely sure how that particular setting works. apparently not like that, eh =/
06:33:45 <DRMacIver> fasta: Since always as far as I know? Some of the methods like 'fromAscList', etc. give you Maps while only requiring an Eq constraint.
06:34:01 <ac> xerox: yeah, in this case I'm indexing with lists of Ints always, so I could make my own ND array by constructing a big 1-dimensional array and doing my own indexing math
06:34:31 <ac> xerox: that's what I was planning on at first, but Data.Map is a nice quick and dirty solution
06:34:43 <DRMacIver> fasta: The constraints are on the functions rather than the datatype, and a few of the functions have weaker constraints than one would expect.
06:34:47 <xerox> ac: you might also consider using parallel arrays! That's exactly what they do.
06:34:59 <xerox> ...at least internally.
06:35:05 <EvilTerran> xerox, to an arbitrary depth, though?
06:35:11 <ac> xerox: parallel arrays? where do I read about those?
06:35:13 <DRMacIver> EvilTerran: Oh well. Thanks anyway. I'll sit here and stare at this code forlornly until it works. :)
06:35:22 <xerox> ac: there's some very recent news/docs on the wiki.
06:35:23 <EvilTerran> hm
06:35:28 <xerox> EvilTerran: yup I think so.
06:36:00 <EvilTerran> http://www.haskell.org/ghc/dist/current/docs/users_guide/type-extensions.html#scoped-type-variables <- DRMacIver, here's the docs on 'em
06:36:02 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/25mnwa
06:36:40 <DRMacIver> EvilTerran: Thanks
06:37:52 <DRMacIver> EvilTerran: It doesn't look like these solve the problem, as I'm turning on fglasgow-exts and the type error remains.
06:38:50 <axm> i had similar error messages when i had general code that was not used. went away when i actually used that function. just my 2 pence, that type system gives me headaches
06:39:22 <EvilTerran> try changing the type signature to :: forall a. (Regexp -> a) -> Regexp -> FSM a ?
06:39:29 <fasta> DRMacIver: yes, I suppose I always use the Ord functions. Never mind
06:39:50 <EvilTerran> "A declaration type signature that has explicit quantification (using forall) brings into scope the explicitly-quantified type variables, in the definition of the named function(s)... This only happens if the quantification in f's type signature is explicit."
06:40:02 <axm> per definition, a forall a should be added automatically?
06:40:23 <EvilTerran> yes, but it only does scoping if you add one explicitly, according to the docs
06:40:57 <DRMacIver> EvilTerran: Hurrah! That fixed it. Thanks.
06:41:17 <EvilTerran> DRMacIver, alternatively, "compile (f :: Regexp -> a) re = lookupRE re compiled where" should work
06:41:28 <EvilTerran> :D
06:43:51 <DRMacIver> Well, that's all the bits which are direct ports done. Now to try something which is actually new.
06:46:45 <DRMacIver> Actually, change of plan. Time to actually see some sunlight today.
06:46:47 <DRMacIver> Back later. :)
06:46:52 <DRMacIver> EvilTerran: Thanks again for your help.
06:47:53 <EvilTerran> :D
06:51:24 <EvilTerran> hm... how do i judge whether or not it's safe to foreign import a function as unsafe?
06:52:44 <ac> In the docs it says that only compare is necessary for a complete definition of the Ord class, but then you automatically get <, >, min, max, etc. How do you define such functions that operate on type classes?
06:52:49 <fasta> EvilTerran: ?
06:52:50 <EvilTerran> for instance, if i've got a function that registers its parameter as a callback, but doesn't actually *call* it yet, is that okay?
06:53:06 <fasta> EvilTerran: the way you said it, it's vacuously true
06:53:30 <fasta> EvilTerran: the way you meant it however, is that it needs to be referentially transparant.
06:53:43 <dons> http://programming.reddit.com/info/2xhkt/comments
06:53:44 <lambdabot> Title: Live from HW: A Lightweight Interactive Debugger for Haskell! :: Video (reddit.c ...
06:53:47 <EvilTerran> "A safe call is less efficient, but guarantees to leave the Haskell system in a state that allows callbacks from the external code. In contrast, an unsafe call, while carrying less overhead, must not trigger a callback into the Haskell system. If it does, the system behaviour is undefined."
06:54:17 <dons> mostly you don't want to make callbacks
06:54:17 <fasta> EvilTerran: oh, I thought you meant a different kind of safe/unsafe
06:54:19 <EvilTerran> referrentially, er, transparent?
06:54:38 <LoganCapaldo> but I likes callsbacks I do
06:54:45 <EvilTerran> i don't, dons?
06:55:54 <EvilTerran> what do i want to do with int set_close_button_callback(void (*proc)(void));, then?
06:56:35 <desegnis> ac, “operate on type classes”? But you can use lambdabot's @src command to find out how <, min et al. are defined
06:56:56 <EvilTerran> ?type (<)
06:56:58 <lambdabot> forall a. (Ord a) => a -> a -> Bool
06:57:28 <ac> @src (<)
06:57:29 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
06:58:00 <LoganCapaldo> why not x < y = compare x y == LT ?
06:58:02 <mux> EvilTerran: you need a "wrapper" foreign import for that
06:58:08 <EvilTerran> mux, i've got one
06:58:36 <EvilTerran> foreign import ccall "wrapper" mkCallback_ :: IO () -> IO (FunPtr (IO ())); mkCallback c f = mkCallback_ c >>= f; {# fun set_close_button_callback  as ^ {mkCallback* `IO ()'} -> `Bool' isZero #}
06:58:42 <EvilTerran> is my current arrangement
06:58:48 <mux> ok :)
06:59:04 <ac> LoganCapaldo: I think because compare retuns an Ordering, and < should return Bool
06:59:07 <EvilTerran> but now dons is saying i don't want to make callbacks, and i'm confusd.
06:59:23 <EvilTerran> ?type \x y -> compare x y == LT
06:59:25 <lambdabot> forall a. (Ord a) => a -> a -> Bool
06:59:32 <LoganCapaldo> ^^
06:59:58 <EvilTerran> i guess doing the pattern-match directly might perform better
07:00:06 <EvilTerran> ?src Ordering (==)
07:00:06 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:00:18 <ac> LoganCapaldo: oh, I missed the "== LT" doh
07:00:59 <EvilTerran> LT == LT = True; EQ == EQ = True; GT == GT = True; _ == _ = False; -- i imagine
07:01:03 <Eelis> i have a simple application whose configuration system is implemented simply by read-ing (in the sense of the Read type class) a data type containing all kinds of fields, from a file named "config". this works pretty well except for one thing: if the user makes a typo in the config file, i am unable to give a more specific error message than "parse failed".
07:01:08 <Eelis> what would be the easiest way to get more specific error messages that say _where_ in the file the syntax error was?
07:01:15 <LoganCapaldo> EvilTerran: I imagine deriving Eq ;)
07:01:32 <EvilTerran> LoganCapaldo, ah, that probably expands to that anyway. but true.
07:01:53 <EvilTerran> Eelis, i think "give up on Read and use a real parser", i'm afraid
07:02:07 <mux> Eelis: I would personally use Parsec, or another monadic parser combinator library
07:02:26 <Eelis> EvilTerran: so then i basically have to re-implement read for all custom data types involved?
07:02:40 <mux> it's quite easy to have nice error messages using the <?> operator in parsec
07:02:48 <olsner> @type liftM4
07:02:50 <lambdabot> forall a1 a2 a3 a4 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
07:03:20 <EvilTerran> i guess so, yeah
07:03:48 <Eelis> ugh.. can't DrIFT derive something similar to Read but with more descriptive errors for me?
07:04:01 <mux> you'll love Parsec :-)
07:04:03 <EvilTerran> there's default parsers available in, say, Parsec, for a lot of things, so it's not as much work as you might expect
07:04:32 <Eelis> mux: i use and like Parsec a lot, but i really don't want to re-implement Read for all types involved
07:04:42 <EvilTerran> ... it might be possible to do something with Parsec and SYB, so you only have to do it once
07:04:46 <mux> Eelis: you won't have to
07:04:47 <EvilTerran> but i don't think it's been done before
07:05:10 <mux> Eelis: you can parse using parsec, giving descriptive error messages, and still use some read* functions in there if you want to
07:05:24 <mux> but parsec will already provide you with tons of combinators to parse many usual things
07:05:42 <Eelis> EvilTerran: hm, i guess i'll look into the SYB approach. thanks
07:05:45 <EvilTerran> go on, i can tell you're itching to shave this yak ;)
07:05:57 <fasta> mux: how?
07:06:35 <fasta> mux: hmm, maybe one could run something in ErrorT.
07:06:36 <Eelis> hm, or maybe i could use Template Haskell
07:06:48 <fasta> Eelis: then you have two problems  ;)
07:08:07 <mux> fasta: I suppose parsing lines and then feeding them into reads; fail with some error message of things go wrong
07:08:15 <idnar> is there a function that returns every element of a list but the last?
07:08:20 <mux> there's no problem lifting pure functions into the Parsec monad, of course
07:08:31 <EvilTerran> init
07:08:44 <fasta> mux: that assumes there's only one thing on a line to read.
07:08:49 <fasta> mux: (that might be true)
07:08:54 <fasta> (or not) :)
07:08:57 <idnar> oh, of course
07:09:01 <mux> fasta: that's an example; it can be arranged to other setups
07:09:04 <idnar> thanks
07:09:21 <mux> fasta: parse the structure with Parsec, and then use some read* functions
07:09:31 <mux> I don't think that would be very convenient though
07:09:36 <mux> I'd write the whole thing in parsec
07:10:08 <fasta> AFAIK, Read is intended for applications were you know by construction the input file is OK.
07:10:39 <fasta> Eelis: the easiest thing might be to to what xmonad does.
07:10:59 <Eelis> fasta: what does it do?
07:11:06 <EvilTerran> Read isn't necessarily meant to be that human-digestible. it may in fact be better to use a fairly drastically different syntax that's easier on the eyes (and possibly easier to do in parsec, too)
07:11:30 <ac> in Haskell, let has the semantics of letrec in Scheme. Is there a construct like Scheme's let in Haskell?
07:11:30 <Eelis> there's also that hs-plugins thing, which can also be used for config stuff, no?
07:11:42 <olsner> I think that's what xmonad does
07:11:54 <EvilTerran> ac, no. we just don't re-use variable names.
07:11:59 <ac> EvilTerran: darn :P
07:12:12 <hpaste>  ramza3 pasted "Why getting stack overflow" at http://hpaste.org/3133
07:12:24 <ac> EvilTerran: I suppose that makes things more clear. I kind of like it (maybe)
07:12:44 <EvilTerran> ac, <- bindings in a do {} are non-recursive, if you *really must* re-use a nam
07:12:44 <EvilTerran> e
07:12:52 <ramza3> anybody see why I am getting a stack overflow on the line I mentioned. or any other issues, about 100 lines of code
07:13:01 <EvilTerran> do foo <- return $ f foo; -- non-recursive
07:13:20 <EvilTerran> do let foo = f foo; ... -- but this is still recursive
07:15:46 <EvilTerran> ac, or you can say (case (f foo) of foo -> ...), or (\foo -> ...) (f foo), or there's a few other ways of doing it
07:16:07 <EvilTerran> but they're all hopelessly ugly. better to just tack a ' on the end of the name.
07:16:09 <ac> EvilTerran: that's ok, I don't NEED to reuse variable names
07:16:24 <ac> EvilTerran: yeah, that's more readable
07:16:58 <ac> I've always thought the whole set of let, letrec, and let* in Scheme is a little silly
07:17:13 <EvilTerran> what's let*?
07:17:20 <ac> I was pleased to discover that Haskell, let* is unecessary
07:17:37 <ac> let* means you can refer to the previously defined names in the definition of the later ones
07:17:48 <ac> but in Haskell, you can even refer to the ones defined afterwords
07:17:56 <dons> cute, huh :)
07:17:59 <dons> letrec forever!
07:18:04 <ac> yeah :)
07:18:06 <EvilTerran> ... so let*'s somewhere between let and letrec, then
07:18:18 <ac> EvilTerran: yeah, it's messed up
07:18:27 <EvilTerran> yyyeah. crappy name, too.
07:18:29 <fasta> Some people argue that the difference between let and letrec makes code easier to read.
07:18:36 <fasta> (I won't) :)
07:18:55 <ac> if a definition refers to itself, it should be recursive, end of story
07:19:02 <ac> let/letrec break that
07:19:23 <fasta> You can easily define let to be letrec, though
07:19:32 <EvilTerran> aaah, obfu
07:19:36 <fasta> So, it's kind of a m00t point.
07:20:15 <fasta> The only advantage Haskell has, is that the type inference algorithms are implemented.
07:20:42 <EvilTerran> well, and that the syntax is nicer
07:20:54 <EvilTerran> (by some people's yardsticks, anyway)
07:21:07 <fasta> EvilTerran: some people e.g. therp disagree, I guess ;)
07:21:23 * DRMacIver returns
07:21:29 <therp> fasta ;)
07:21:44 <fasta> aptitude remove apache2 :)
07:21:53 <fasta> Configuration mess...
07:22:08 <ac> yay for Debian
07:22:09 <fasta> I would install HApps, if it would work.
07:22:14 <axm> then why not purge?
07:22:26 <Zao> fasta: At least it's not sendmail you're configuring :)
07:22:29 <ramza3> stack overflow, anyone, lalal
07:22:31 <fasta> axm: maybe lighttpd also sucks
07:23:07 <DRMacIver> Hm. I wonder why irregular types are so uncommon.
07:23:50 <EvilTerran> what be an irregular type?
07:24:33 <DRMacIver> Things like data Foo a = Bar a | Baz (Foo [a])
07:24:50 <DRMacIver> Recursive types where the recursion doesn't use the same type parameter.
07:24:51 <LoganCapaldo> yarrr
07:25:20 <DRMacIver> They're used e.g. in finger trees, and one of the comments you often get about finger trees is that they're unusual in that they're an actually useful instance of an irregular type. :)
07:25:25 <therp> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html#4 <- how do I know whether I get UTF-16 or UTF-32 from withCWString?
07:25:26 <lambdabot> http://tinyurl.com/3454mw
07:25:34 <EvilTerran> hehe
07:25:36 <fasta> DRMacIver: isn't that only useful to encode invariants?
07:25:44 <_achilles_> how do I find out if an existing Haskell function exists in the library? especially if I don't know it's name? Is the most efficient way to google it?
07:25:49 <fasta> DRMacIver: AFAIK, it's not needed for a finger tree.
07:26:08 <EvilTerran> _achilles_, if you can guess its type, hoogle might help
07:26:08 <LoganCapaldo> @hoogle a -> [a] -> Maybe a -- search by type
07:26:08 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- search '
07:26:16 <LoganCapaldo> @hoogle a -> [a] -> Maybe a
07:26:16 <EvilTerran> @where hoogle
07:26:16 <lambdabot> No matches, try a more general search
07:26:17 <lambdabot> http://haskell.org/hoogle
07:26:17 <fasta> DRMacIver: oh, never mind.
07:26:26 <DRMacIver> fasta: I don't know what a finger tree would look like without an irregular type...
07:26:34 <DRMacIver> It's pretty much baked into the essential construction.
07:26:42 <LoganCapaldo> @hoogle (Eq a) => a -> [a] -> Maybe Int
07:26:42 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
07:26:42 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
07:26:46 <DRMacIver> And my usage earlier wasn't really about encoding invariants either.
07:26:53 <_achilles_> ha
07:26:56 <_achilles_> hoogle?
07:26:59 <_achilles_> that's awesome
07:27:00 <LoganCapaldo> hoogle
07:27:23 <LoganCapaldo> it is
07:27:45 <LoganCapaldo> it makes me wish more programming languages had such useful types so i could search by type in all of them effectively
07:28:05 <fasta> LoganCapaldo: you should try Squeak
07:28:26 * EvilTerran decides to stop working on his Allegro binding for a bit
07:28:31 <fasta> LoganCapaldo: you can give a number of inputs and an answer and then find all the methods that return that.
07:28:37 <LoganCapaldo> yes I know
07:28:53 <LoganCapaldo> MethodFInder
07:28:58 <fasta> Yes
07:29:50 <LoganCapaldo> It's great when pretty much the only thing you don't know is the name
07:30:39 <LoganCapaldo> I dnon't remmeber does it try reordering the arguments, or even changing which object is the receiver?
07:30:58 <ricky_clarkson> fasta: In Squeak, is that finder based on value rather than types?
07:31:22 <fasta> ricky_clarkson: value
07:31:43 <ricky_clarkson> So does it run lots of methods to determine which matches?
07:32:09 <fasta> ricky_clarkson: looking for types should also work, I guess
07:32:16 <fasta> ricky_clarkson: AFAIK, yes
07:32:53 <ricky_clarkson> Sounds interesting, but dodgy in the case of side effects.
07:33:02 <fasta> ricky_clarkson: they probably considered that
07:33:50 <LoganCapaldo> well Squeak is in its own little world, the worst thing you do is nuke your image and have to go back to an earlier revision
07:34:05 <LoganCapaldo> well that's probably not _really_ the worst thing you could do
07:34:10 <fasta> ricky_clarkson: I doubt that when you make a method foo taking 1 and 2 that does rm -rf / and then doing 1,2 3 will result in a mess.
07:34:46 <fasta> LoganCapaldo: Yes, I found that a disadvantage too(but probably it's based on misconceptions)
07:35:10 <LoganCapaldo> I'd call that an advantage
07:35:20 <ricky_clarkson> fasta: Call that a side effect?  I've seen bigger side effects on mobile phones.
07:35:36 <fasta> ricky_clarkson: you mean like exploding
07:35:45 <fasta> ricky_clarkson: yes, I have seen that on my PSU.
07:35:58 <fasta> ricky_clarkson: quite interesting phenomena.
07:36:31 <ricky_clarkson> No, but someone I used to teach was apparently cheating on an online game and got sent some executable code by the admins that fried his graphics card.
07:36:55 <ricky_clarkson> ..not sure I believe that, mind.
07:36:58 <fasta> ricky_clarkson: I doubt that is possible
07:37:19 <ciphergoth> fasta: why?
07:37:47 <ciphergoth> I had a friend at Uni who was doing some mad stuff on one of the supercomputers - the Cray T3D IIRC
07:38:14 <fasta> ciphergoth: well, a graphics processor processes graphics commands. It should be able to execute all permutations of commands.
07:38:14 <ricky_clarkson> I once ejected the floppy drive on a remote Solaris box, for no particular reason, and it crashed.  There was no floppy drive, and there was a Solaris kernel bug.
07:38:18 <ciphergoth> in search of the greatest optimization he found ways of using the memory protection hardware so insane that it fried the hardware
07:38:27 <LoganCapaldo> the whole graphics card / monitor frying thing is a really old mem afaict. Don't know if that makes it more likely to be true or false
07:38:29 <fasta> ciphergoth: if it can't it's broken hardware.
07:38:35 <ciphergoth> they had to send out an engineer to replace the broken boards
07:38:44 <LoganCapaldo> s/mem/meme
07:38:57 <ciphergoth> of course, he only realized that it was his software that had caused the crash and hardware destruction when he ran it the second time...
07:39:34 <fasta> If I can crash any component in my machine within a second I would return it.
07:39:44 <ciphergoth> sure
07:39:56 <ac> How do I add types to a let expression?
07:40:02 <ciphergoth> but it wouldn't surprise me if graphics cards aren't built to that level of robustness
07:40:08 <fasta> > let a = 5 :: Int in a
07:40:14 <lambdabot>  5
07:40:22 <ciphergoth> that unless you're using their driver they don't care
07:40:25 <ac> fasta: how about if I have "let foo a b = ..."?
07:40:56 <fasta> ac: let a b c = const id:: a -> a -> a in 3
07:40:59 <fasta> > let a b c = const id:: a -> a -> a in 3
07:40:59 <LoganCapaldo> > let { foo :: Int -> Int -> Int ; foo a b = a + b } in foo 1 2
07:41:02 <lambdabot>  3
07:41:02 <lambdabot>  3
07:41:20 <fasta> ac: but you don't want to add types
07:41:26 <LoganCapaldo> funny how we picked the same result
07:41:41 <fasta> LoganCapaldo: that's called faith ;)
07:42:12 <ac> fasta: why not? I just imported Data.Map, and now I have ambiguous occurences of ! after I create an array in a let
07:42:40 <fasta> ac: 1) yes you have a problem 2) that's not a solution
07:42:53 <fasta> ac: you can try and enjoy the learning experience
07:43:13 <ac> fasta: I don't have to try, I'm already enjoying :)
07:43:29 <fasta> ac: the solution is that you import (!) two times. Although, the type inference could decide which one to call, that's not how Haskell works
07:43:50 <fasta> ac: so, you just need to use qualified imports for example
07:43:54 <LoganCapaldo> Could it?
07:44:03 <fasta> LoganCapaldo: in lots of cases, yes.
07:44:03 <LoganCapaldo> I suspect that would be really hard in general
07:44:14 <Zao> One can hide things when importing too, can't one?
07:44:21 <LoganCapaldo> One can indeed
07:44:30 <fasta> LoganCapaldo: by "could" I mean that I believe it's decidable.
07:44:48 <DRMacIver> Repeat of earlier question: Is there some sort of canonical type in Haskell for representing a single Bit?
07:44:55 <DRMacIver> @instances Bits
07:44:56 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
07:44:56 <desegnis> LoganCapaldo: In general it either can or cannot :)
07:45:09 <DRMacIver> @instances-importing Data.Bits Bits
07:45:10 <lambdabot> Int, Integer
07:45:17 <DRMacIver> Hm
07:45:21 <EvilTerran> a single bit? why not Bool?
07:45:24 <LoganCapaldo> Bool?
07:45:48 <DRMacIver> EvilTerran: I'm not sure it's really appropriate. It feels like an abuse of its purpose. :)
07:45:54 <DRMacIver> And I'd like to have the Bits instance.
07:46:41 <fasta> LoganCapaldo: proof: assign all possible types to all possible ambiguous expressions and run type-inference on all combinations.
07:46:43 <EvilTerran> nah, that's pretty close to its purpose. might be a bit (no pun intended) of a pain writing the instances for it, i guess
07:46:47 <ciphergoth> Can you create types representing arbitrary subranges of integers?
07:47:15 <DRMacIver> ciphergoth: No, but you could create a newtype and give it some 'smart' constructors which do bounds checking.
07:47:18 <ac> fasta: so a reasonable solution would be not to import (!) from Data.Map, and say something like: "(!!!) = (Data.Map.!)"?
07:47:41 <EvilTerran> import qualified Data.Map as M
07:47:43 <DRMacIver> EvilTerran: I guess.
07:47:55 <fasta> ac: EvilTerran's is what most do
07:47:57 <EvilTerran> and then use M.! where you'd otherwise use !
07:48:21 <EvilTerran> you can also import Data.Map (...) for any functions that don't clash
07:48:43 <ac> EvilTerran: ok, thanks. I didn't realized "qualified" was a keyword
07:48:53 <EvilTerran> > let qualified = 1 in qualified
07:48:58 <lambdabot>  1
07:49:01 <EvilTerran> it isn't ;)
07:49:10 <ac> thought it meant "specifying things in parenthesis after a module name"
07:49:25 <EvilTerran> *but*, it does have special meaning when immediately after "import" :)
07:49:26 <DRMacIver> I guess I'll just use Bool and write a Bits instance if I really need one.
07:49:27 <DRMacIver> Thanks.
07:50:24 <EvilTerran> the bits instance would actually be rather easy, i guess. (.&.) = (&&) etc...
07:50:27 <EvilTerran> @src Bits
07:50:27 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
07:51:13 <EvilTerran> xor = (/=), shift = const False...
07:51:46 <EvilTerran> const (const False), even
07:52:06 <mikael> what about shift by 0? :-)
07:52:28 <EvilTerran> ah, yes, quite. don't mind me.
07:53:05 <DRMacIver> EvilTerran: Yes, I know. I'm not complaining that it's difficult. But my code is lazily evaluated - nothing gets written until it's needed. ;-)
07:53:13 <EvilTerran> heh
07:54:58 <DRMacIver> "code by need" evaluation, so to speak.
07:55:51 <mikael> wouldn't it be cool if you could instantiante, say, Cast Bool Int and Cast Int Bool, and have Bits Bool be derived like xor a b = cast (cast a `xor` cast b)
07:56:12 <mikael> instantiate, rather
07:57:16 <EvilTerran> you could instance Enum a => Bits a, with fromEnum and toEnum, i guess
07:58:46 <DRMacIver> That would require incoherent instances wouldn't it?
07:59:00 <DRMacIver> Because there are already a lot of Enums which are Bits instances.
07:59:04 <LoganCapaldo> I think it would require gibbering mad instances ;)
07:59:07 <EvilTerran> yeah, true.
07:59:22 <LoganCapaldo> non-euclidean isntances
07:59:39 <EvilTerran> overlapping, only, i think
07:59:43 <DRMacIver> @remember LoganCapaldo I think it would require gibbering mad instances ;)
07:59:43 <lambdabot> Done.
07:59:51 <EvilTerran> 'cos all the others will have more specific instance heads
08:03:05 <DRMacIver> EvilTerran: Ah. Fair point. I can't really keep what all the different language extensions do and don't do in my head. :)
08:03:29 <EvilTerran> i may be mistaken, but i think that shouldn't require incoherence
08:03:55 <DRMacIver> You're more likely to be right than I am anyway.
08:07:56 <olsner> why do so many IRC clients seem to come with a macro to slap people around a bit with a large trout?
08:08:11 <olsner> it has long ago ceased to be entertaining
08:08:36 <LoganCapaldo> IRC client authors have a lot of pent up agression
08:08:53 <axm> could be the hello world equivalent
08:09:03 <axm> when you write one i mean
08:13:34 <EvilTerran> it's yet another feature introduced by mIRC that all the other clients then felt pressured to implemen
08:13:34 <EvilTerran> t
08:14:24 <DRMacIver> Hm
08:15:33 <EvilTerran> i still think the only reason mIRC is so popular is because xchat sabotaged themselves in the search results by not having "irc" in their name
08:15:59 <LoganCapaldo> I thought the only reason mIRC is so popular is because windows is so popular?
08:16:38 <LoganCapaldo> I especially enjoy when people refer to IRC as mIRC
08:16:43 <Liskni_si> xchat sabotaged itself by not being a good client in the first place
08:17:12 <EvilTerran> Liskni_si, it's better than mIRC, imo
08:17:27 <Liskni_si> EvilTerran: you got a point :)
08:17:30 <EvilTerran> but seriously, they're on page 8 of the google results for "irc" >.<
08:17:45 <LoganCapaldo> we clearly need  an IRCMonad
08:17:51 <LoganCapaldo> ChatMonad?
08:17:56 <EvilTerran> and mirc is the first result
08:18:19 <LoganCapaldo> I mean the protocol has clearly already been haskellified (witness lambdabot)
08:18:29 <LoganCapaldo> just got to slap a clever interface on it
08:18:43 <Eelis> there is now an irc package in haskell
08:18:48 <Eelis> *hackage
08:18:51 <EvilTerran> does that particularly need its own monad? surely it'd be primarily functions in IO?
08:19:04 <LoganCapaldo> I was just going for naming consistency
08:19:10 <DRMacIver> EvilTerran: I assume the name was motivated by XMonad...
08:19:17 <LoganCapaldo> The _Monad suite of applications
08:19:22 <DRMacIver> I'd definitely be interested in such a thing, although I'm pretty happy with irssi.
08:19:29 <EvilTerran> oh, i see
08:20:41 <LoganCapaldo> Maybe just CMonad?
08:20:51 <LoganCapaldo> Whose with me?
08:23:16 <DRMacIver> *crickets*
08:26:02 <DRMacIver> I'm confused by the fact that both Data.ByteString and Data.ByteString.Lazy both define a 'ByteString' type.
08:26:17 <DRMacIver> Am I to take it that one should never use both modules at the same time?
08:27:19 <desegnis> depends on what you mean by “at the same time” ;-). The first is for strict, the second for lazy ByteStrings, which work differently
08:28:02 <desegnis> so if you need strict ByteStrings here, lazy ByteStrings there, then you may import both qualified
08:28:22 <DRMacIver> Yeah. I just realised they were meant to be imported qualified. Oops. :)
08:29:17 <DRMacIver> Wouldn't it make sense to have some sort of common type class for the two?
08:30:11 <EvilTerran> it'd be nice to have a common typeclass between Data.Map and Data.IntMap, too
08:30:23 <DRMacIver> Yes.
08:30:27 <dons> i'd like to have Data.Map specialise to Data.IntMap
08:31:17 <EvilTerran> i'd like a nice class heirarchy for container types, actually
08:31:38 <desegnis> btw, on a completely different note... am I the only one who sometimes wonders why Haskell uses = instead of := for definitions? This is puzzling when a book lists properties of a function using =
08:31:57 <DRMacIver> While we're in "I want a pony" mode I want type classes properly unified with a higher order module system. :)
08:32:13 <DRMacIver> But the ByteString one could easily have something done about it...
08:32:26 <DRMacIver> dons: Care to comment?
08:32:31 <EvilTerran> although there are some difficulties involving containers that aren't parameterised by what they contain
08:33:02 <EvilTerran> i've thought about typeclassing Data.(Int)Map - it's not pretty
08:33:28 <DRMacIver> Hm
08:33:46 <DRMacIver> I guess the problem with type classes for Data.ByteString is that the *entire module* would have to be one one great big type class.
08:34:01 <EvilTerran> i ended up with, yes, class IMap k a m | m -> k a, but also class (IMap k a m, IMap k b n) => IMapVs k a b m n and class (IMap k a m, IMap l a n) => IMapKs k l a m n
08:34:07 <EvilTerran> (both with massive fundep lists)
08:34:24 <dons> typeclass for bytestrings is too big
08:34:41 <DRMacIver> Ok. I return to my "I want a pony" request. :)
08:34:53 <EvilTerran> so you could have functions between maps of different typed keys or values
08:35:01 <EvilTerran> it'd be much nicer with type families, actually
08:35:06 <DRMacIver> But that will have to wait for something else to replace Haskell, as I doubt it will ever make it in to any successor of Haskell.
08:35:12 <DRMacIver> err. any close successor.
08:50:43 <dons> ?. pl undo  do (globalArgs, pkgs) <- parsePackageArgs action args ; f config globalArgs pkgs
08:50:44 <lambdabot> uncurry (f config) =<< parsePackageArgs action args
08:50:49 <dons> ?. pl undo \f ->  do (globalArgs, pkgs) <- parsePackageArgs action args ; f config globalArgs pkgs
08:50:49 <lambdabot> (parsePackageArgs action args >>=) . (`ap` snd) . (. fst) . ($ config)
08:50:52 <dons> hah
08:59:54 <DRMacIver> Hm. Why doesn't Data.Bits have a method for checking if something is 0?
09:00:10 <DRMacIver> Given the presence of non-fixed length instances there doesn't seem to be a valid way to write one.
09:00:19 <DRMacIver> (one which works for any instance I mean)
09:00:38 <mrd> (==0)?
09:00:55 <DRMacIver> Oh, duh. I totally missed that Bits had a Num constraint.
09:01:00 <DRMacIver> That makes my life rather easier. :)
09:01:08 <joelr1> g'day
09:01:10 <MyCatVerbs> fromInteger and == are always defined on Bits?
09:01:12 <DRMacIver> Thanks mrd
09:01:25 <mrd> @src Bits
09:01:26 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
09:01:28 <MyCatVerbs> Num a implies Eq a, right?
09:01:29 <mrd> @src Num
09:01:30 <lambdabot> class  (Eq a, Show a) => Num a  where
09:01:30 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:01:30 <lambdabot>     negate, abs, signum     :: a -> a
09:01:30 <lambdabot>     fromInteger             :: Integer -> a
09:01:32 <mrd> indeed
09:01:38 <MyCatVerbs> mrd: danke.
09:01:47 <mrd> wonder why Bits failed
09:02:05 <MyCatVerbs> Wait, how come Num a doesn't imply Ord a? Are there any instances where that comes out useful in practice?
09:02:18 <DRMacIver> Complex numbers for example.
09:02:38 <mrd> it's bad enough that it implies Show
09:02:41 <MyCatVerbs> DRMacIver: ah, thanks.
09:02:57 <mrd> Eq is pretty bad too, I suppose
09:03:16 <MyCatVerbs> mrd: in practice, I don't see the issue. It's not like "deriving Show" is much work. :/
09:03:43 <DRMacIver> It is when you want to have things like infinite precision reals, instances for functions, etc.
09:03:44 <MyCatVerbs> Non-comparable numbers would be insane, mrd. :/
09:04:05 <mrd> real numbers
09:04:07 <MyCatVerbs> k
09:04:30 <MyCatVerbs> instance Show Thingy where show thingy = const "Fuck off!"
09:04:54 <DRMacIver> That's often what you have to do. Or even show thingy = undefined. :-/
09:07:19 <DRMacIver> I'm not convinced it's ever valid to require a Show constraint on any type classes which aren't explicitly about showing.
09:07:42 <DRMacIver> Show has a very specialised purpose after all.
09:09:13 <dons> ?pl showDep d = show (showDependency (fulfilling d))
09:09:13 <lambdabot> showDep = show . showDependency . fulfilling
09:10:36 * joelr1 hi-fives dons
09:11:26 <joelr1> @localtime dons
09:11:27 <lambdabot> Local time for dons is Sun Oct  7 09:11:01 2007
09:12:08 <joelr1> dons: did you have any change to look at my parser?
09:13:33 <joelr1> i'm curious, has anyone evaluated the cache locality of haskell apps?
09:14:14 <pejo> joelr, that must be fairly data dependent, no?
09:14:31 <joelr1> pejo: right but it's affected by code also
09:14:53 <pejo> joelr, yeah, some fields have publications along the line "Look, we turned things around and got a massive speed up".
09:15:16 <joelr1> there was a comparison of something vs ocaml someplace and they evaluated the cache locality of ocaml and found it to be excellent
09:15:23 <pejo> joelr, if you find any, please let me know. :-)
09:15:36 <joelr1> pejo: i doubt it but i'll be on the lookout
09:16:38 <DRMacIver> Hm. The list of language extensions this code is using is starting to pile on.
09:16:56 <DRMacIver> I think I'm trying to be too clever with type classes.
09:17:18 <DRMacIver> Oh well. Not abusing the language horrifically would be out of character. :)
09:18:59 <DRMacIver> Hm. If I want to show a number's binary representation, is there a built in function for that?
09:19:33 <matthew-_> DRMacIver: not that I know of
09:19:47 <EvilTerran> showIntAtBase?
09:20:02 <DRMacIver> EvilTerran: Thanks
09:20:11 <xerox> > showIntAtBase 2 intToDigit 31337 ""
09:20:12 <lambdabot>  "111101001101001"
09:23:03 <EvilTerran> > (\x -> [if testBit x i then '1' else '0' | i <- [0..bitSize x - 1]]) (31337 :: Int)
09:23:04 <lambdabot>  "10010110010111100000000000000000"
09:23:42 <gris> Can I define data types in GHCi?
09:24:38 <EvilTerran> no; you can only do things you can do in a do{} block
09:24:40 <joelr1> i think the answer is no but i don't remember why
09:24:47 <joelr1> ah, yes, do block
09:24:55 <dons> hackathon over
09:24:58 * dons -> beer
09:24:59 <dons> yay!
09:25:04 <dons> code, blogs, photos on wiki
09:25:07 <dons> have fun
09:25:08 <joelr1> what hackathon?!
09:25:12 <joelr1> dons: link?
09:25:54 <joelr1> i seem to have missed a lot. what were the goals of the hackathon this time? which ones were accomplished?
09:26:20 <joelr1> http://haskell.org/haskellwiki/Hac_2007_II
09:26:21 <lambdabot> Title: Hac 2007 II - HaskellWiki
09:26:22 <joelr1> must be it
09:27:21 <DRMacIver> Hm. How do I convert from a String to a ByteString?
09:27:54 <EvilTerran> pack?
09:28:07 <oklopol> that's one cool beard
09:28:12 <EvilTerran> for Data.ByteString(.Lazy).Char8
09:28:26 <DRMacIver> Oh, right. I missed that I should be looking in .Char8
09:28:27 <EvilTerran> otherwise, pack . map (toEnum.fromEnum)
09:28:49 <DRMacIver> (hm. Actually I shouldn't. I need the Word8 version.)
09:28:51 <DRMacIver> ok. Thanks.
09:29:26 * EvilTerran would quite like a standard function for toEnum.fromEnum - toFromEnum? betweenEnum?
09:29:42 <EvilTerran> enumCast, maybe? enumToEnum?
09:29:47 <Botje> toOtherEnum? :)
09:29:51 <birkenfeld> transEnum?
09:30:20 <EvilTerran> i like transEnum... or interEnum?
09:30:24 <desegnis> enum?
09:30:49 <birkenfeld> but I fear you'll have to come up with something as obscure as "intercalate" :)
09:31:10 <EvilTerran> i think "enum" would be a catamorphism
09:31:38 <sfultong> ok... who won the ICFP contest?
09:31:39 <pjd> betweenum
09:31:45 <EvilTerran> like "maybe" and "either"
09:31:50 <EvilTerran> pjd, :D
09:32:09 * joelr1 is digging through the results of the hackathon
09:32:34 <pjd> viaEnum, more seriously
09:34:19 <birkenfeld> convertEnum?
09:35:02 <joelr1> dons: did hs-plugins on top of ghc api get done?
09:37:29 * EvilTerran notes that he can (possibly) refine the granularity of the types used by this library as he binds it to haskell
09:49:37 <olsner> or castEnum
09:53:36 <therp> #type foobar gives Word32/Int32 as substitution in .hsc files. can I use this #type directive in foreign declarations somehow? as in http://hpaste.org/3134 ? Bool gets translated to Int32 but actually I would need CInt here
09:58:22 <oscz> i'm trying to get hold of IO.. putStrLn in particular.. i'm trying to print out the value of a recursive function for each evaluation
09:58:54 <oscz> is it that i need to somehow construct a list of IO actions that's produced by putStrLn
09:58:57 <bartw> for debugging ?
09:58:57 <oscz> ?
09:59:18 <oscz> yes and to understand how Actions work
09:59:49 <desegnis> you could build a list of successive values, and print that list. but then, you'd learn little about actions
10:00:10 <oscz> what do you suggest?
10:00:11 <mauke> foo :: Int -> IO (); foo n = putStrLn (show n) >> if n > 0 then foo (n - 1) else return ()
10:01:26 <oscz> i need to read about >> operator again..
10:02:06 <mauke> >> takes two IO actions and returns an IO action that when executed runs both
10:02:25 <mauke> (from left to right)
10:02:37 <oscz> oh right.. hmm
10:02:44 <mauke> putStr "foo" >> putStr "bar"  -- prints "foobar"
10:02:44 <chessguy> and discards any result of the first
10:03:19 <EvilTerran> @src print
10:03:19 <lambdabot> print x = putStrLn (show x)
10:03:27 <EvilTerran> btw
10:03:40 <desegnis> > let f1 n | n >= 0 = n : case n of 0 -> []; _ -> f1 (pred n) in print (f1 10)
10:03:42 <lambdabot>  <IO ()>
10:04:00 <EvilTerran> lambdabot doesn't do io, for security reasons
10:04:18 <desegnis> I know... I've put that > only out of the habit
10:04:29 <oscz> what does () stand for ?
10:04:42 <mauke> dummy value
10:04:49 <desegnis> () is also called unit and stands for “never mind”
10:04:52 <Zao> () is the only value of the type (), pronounced "unit"
10:05:07 <mauke> you can think of it as data Void = Void except it's data () = () except that would be a syntax error
10:05:15 <oscz> it is IO type though ?
10:05:15 <Cale> You can also think of it as the empty tuple.
10:05:31 <mauke> no, () has nothing to do with IO
10:05:32 <Cale> IO () is an IO action whose result is a value of type ()
10:05:45 <EvilTerran> like IO Int, or IO Char. only ()
10:05:46 <mikael> by all means, do construct a list of IO actions.  you can evaluate them with sequence_.  then implement sequence_ in terms of (>>), and you will be enlightened!
10:05:49 <Cale> (namely, either () or undefined, probably just ())
10:06:11 <Cale> :t sequence_
10:06:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:06:14 <Cale> :t sequence
10:06:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:06:30 <mauke> you can think of IO values as syntax trees of imperative programs that can do I/O
10:06:40 <mauke> (>>) concats two of those
10:07:41 <oscz> mauke: in that example of yours.. when are those actions run ?
10:08:09 <mauke> after the end of the program
10:08:37 <mauke> the haskell runtime system runs your program, looks at the value of "main" (an IO action), then runs that
10:08:48 <desegnis> a >> b means (when we're talking IO) that you first run a, then b
10:09:04 <mauke> so to run any IO action you have to somehow make it part of/reachable from "main"
10:09:48 <oscz> mauke: so it concatenates all those actions in a list of actions?
10:10:00 <oscz> and >> will fix the order too
10:10:09 <mauke> hmm? there's only one big action
10:10:13 <mikael> of course due to lazy evaluation, the value of "main" is found successively; it can be an infinite recursion like (print "hey" >> print "hey" >> ...)
10:10:15 <Cale> Not quite a proper list, but basically, yeah.
10:10:21 <mauke> but it's usually composed from smaller actions
10:10:35 <oscz> and in the end there's just one action containing them all and then it's run ?
10:10:48 <Cale> You have certain primitive actions, like putChar and getChar, and then larger actions are built up from those.
10:10:49 <axm> and if you have actions with types other than (), you can chain the result to the next action with >>=
10:10:56 <mauke> oscz: yes
10:11:02 <EvilTerran> oscz, not exactly "then", because of laziness, but effectively, yes
10:11:08 <joelr1> is there a list of what got accomplished at the hackathon?
10:11:17 <pejo> mikael, what did that have to do with lazy evaluation? non-termination is non-termination even if it's strict.
10:11:33 <Cale> If x and y are actions, then (x >> y) is the action which when run, will run x, throwing away its result, and then run y, returning its result.
10:12:17 <Cale> That's nice, but without some way to use the result of one action to determine the next one, it would be impossible to write interactive programs
10:12:34 <mikael> pejo: but in a strict language, computing the value (print "hey" >> print "hey" >> ...) would never yield anything, like computing (1:2:3:...)
10:12:44 <mauke> oscz: here's an example: putStr [] = return (); putStr (c : cs) = putChar c >> putStr cs
10:12:53 <Cale> So you have (>>=), instead of an action, on its right, it takes a function from results of the first action to following actions
10:13:10 <mikael> pejo: or am I misusing "lazy" and "strict"?
10:13:20 <Cale> That is, if x is an action, and f is a function from possible results of x to further actions
10:13:32 <joelr1> pepe
10:13:43 <joelr1> hmm
10:13:47 <Cale> then (x >>= f) is the action which runs x, capturing its result and applying f to it to get another action, then running that new action
10:13:56 <Cale> That is, it's like:
10:14:10 <Cale> do { v <- x; w <- f v; return w }
10:14:24 <Cale> (In fact, those are equivalent)
10:14:36 <desegnis> mikael, I don't think so. Of course, non-pure languages can express non-termination without being lazy
10:14:42 <Cale> oscz: does that make sense?
10:14:42 <mauke> >>= just bakes a callback into the big syntax tree we're constructing
10:14:45 <Cale> So for example
10:14:50 <pejo> mikael, I'm just not following you. You need a consumer of the infinite list that won't take 'all' of it.
10:14:51 <Cale> getLine >>= putStrLn
10:15:02 <Cale> is the program which gets a line of text from the user, then prints it back out
10:15:37 <Cale> putStrLn is a function which takes a String, and produces an action for printing that string on the screen
10:16:31 <oscz> Cale: i think so.. you were writing about this earlier but at that time this was too advanced.. now i feel i might have a chance of getting what's going on ;)
10:16:40 <Cale> :)
10:17:18 <mauke> I'd rather explain do notation in terms of >> and >>= than the other way around
10:17:30 <oscz> when you have a program involving actions.. is it always going to be just one big combined action in the end ?
10:17:43 <Cale> mauke: sure, but the imperative feel of do-notation can help explain the IO monad as well.
10:17:51 <Cale> oscz: yeah
10:17:54 <mauke> yes
10:18:00 <mauke> Cale: that didn't quite work for me
10:18:24 <Cale> mauke: I think it's okay so long as you really do have the underlying (>>) and (>>=) as well
10:18:40 <oscz> ok..
10:18:48 <Cale> In fact, I intended that do-block as a kind of pseudocode :)
10:18:58 <Cale> (even though it really is valid Haskell :)
10:19:35 <oscz> it's a good demonstration of what happens.. easier to understand for me
10:19:38 <Cale> oscz: In the end, you define an action value called main, and the RTS executes main, evaluating the actions as needed.
10:19:38 <DRMacIver> I think Haskell often matches or exceeds Python's reputation of being "executable pseudocode".
10:20:11 <DRMacIver> It's just that they're different flavours of pseudocode. Haskell is a mathematician's pseudocode, Python is pseudocode produced by someone who spent too long in close proximity to a C compiler...
10:20:25 <Cale> oscz: Just evaluating an IO action won't cause any execution though -- only the RTS will really execute things.
10:21:06 <mikael> pejo: sorry, I was probably wrong...  IO values don't need laziness to be lazy, since the right-hand-side of (>>=) is always a thunk anyway
10:21:13 <oscz> Cale: ok.. how does monads in general relate to all this ?
10:21:36 <mauke> oscz: you can generalize >>, >>= and return to other things than IO
10:21:46 <Cale> oscz: Well, in a monad in general, you have something like return and something like (>>=)
10:21:57 <oscz> oh..
10:22:00 <Cale> oscz: But that's basically where the similarity ends.
10:22:22 <Cale> You could be putting together another kind of computation entirely, or even something which initially doesn't seem much like a computation, like a list.
10:22:38 <Cale> > [1,2,3] >>= \x -> [x,x]
10:22:43 <lambdabot>  [1,1,2,2,3,3]
10:23:18 <desegnis> > [1..5] >>= \x -> return (x^2)   -- return is like a singleton list here
10:23:19 <lambdabot>  [1,4,9,16,25]
10:23:30 <Cale> In the list monad
10:23:33 <Cale> return x = [x]
10:23:39 <Cale> x >>= f = concat (map f x)
10:23:53 <mauke> "return" is a virtual constructor
10:23:56 <Cale> and that's basically all there is to it
10:24:11 <Cale> Of course, the general monad functions have lots of consequences for the list monad
10:24:19 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
10:24:21 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
10:25:05 <mauke> > filterM (return [True,False]) "abc"  -- more confusion
10:25:05 <Cale> "running" a list is effectively picking an element out of it in all possible ways
10:25:06 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
10:26:02 <Cale> So that filterM for example, will pick an element from the list [True,False] in all possible ways in order to determine whether to keep the each list element.
10:26:12 <Cale> That use of return in the ((->) e) monad was a bit cruel though.
10:26:12 <xerox> hehe, the return is not in the same monad.
10:26:22 <Cale> > filterM (\x -> [True,False]) "abc"
10:26:23 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
10:26:33 <Cale> Let's stick to one monad at a time :)
10:26:42 <mauke> aww :-)
10:27:22 <Cale> But yeah, functions from a fixed "environment" type also form a monad
10:27:34 <hpaste>  fluctus pasted "eval type signature" at http://hpaste.org/3135
10:27:38 <oscz> ok ok.. i take it back.. i dont get it ;)
10:27:44 <fluctus> why am i asked to "add (Fractional a) to the type signature(s) for `eval'"?
10:27:45 <Cale> Where "running" such a function amounts to applying it to a value
10:27:59 <mauke> fluctus: because of /
10:28:11 <Cale> > (do { x <- id; y <- reverse; z <- map toUpper; return (x,y,z) }) "hello"
10:28:12 <lambdabot>  ("hello","olleh","HELLO")
10:28:14 <fluctus> does the Fractional a => ... in the Term declaration ensure that a is always an instance of fractional?
10:28:19 <fluctus> doesn't*
10:28:27 <mauke> fluctus: no
10:28:38 <mauke> > liftM filterM (return [minBound .. maxBound]) "argh"
10:28:39 <lambdabot>  Couldn't match expected type `a -> m Bool'
10:28:49 <Cale> fluctus: Everyone would like it to mean that, but it doesn't.
10:28:54 <fluctus> oh
10:29:01 <Cale> fluctus: In newer versions of GHC, you can get that effect.
10:29:18 <Cale> (that is, as-yet-unreleased versions)
10:29:22 <fluctus> hmm
10:29:24 <mauke> > liftM filterM return [minBound .. maxBound] "argh"
10:29:26 <fluctus> ok, thanks
10:29:26 <lambdabot>  ["","h","g","gh","r","rh","rg","rgh","a","ah","ag","agh","ar","arh","arg","a...
10:29:35 <xerox> mauke++
10:29:39 <Cale> ahahaha
10:29:49 <oscz> what is this "list monad" entity ? is it some object or something?
10:29:59 <mauke> oscz: no, it's just lists
10:30:07 <mauke> lists happen to support the Monad interface
10:30:13 <oscz> oh.. ok
10:30:18 <ari> @src [] (>>=)
10:30:18 <lambdabot> m >>= k     = foldr ((++) . k) [] m
10:30:24 <Cale> oscz: return :: a -> [a]; (>>=) :: [a] -> (a -> [b]) -> [b]
10:30:25 <desegnis> oscz, it means that someone wrote "instance Monad [a] where ..."
10:30:31 <ari> @src [] return
10:30:31 <lambdabot> return x    = [x]
10:31:17 <hpaste>  LoganCapaldo annotated "eval type signature" with "Does doing it like this help?" at http://hpaste.org/3135#a1
10:32:08 <LoganCapaldo>  I guess you still have the same problem
10:32:13 <oscz> >> and >>= are operations for monads?
10:32:16 <Cale> oscz: yeah
10:32:19 <mauke> yes
10:32:23 <mauke> :t (>>=)
10:32:25 <oscz> ok
10:32:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:32:44 <mauke> that last part means it can work with any monad
10:32:48 <Cale> oscz: In general, a monad is a type constructor M together with definitions for return :: a -> M a, and (>>=) :: M a -> (a -> M b) -> M b
10:33:10 <oscz> i somehow thought monads were implemented to make IO possible but i guess they're much more
10:33:14 <Cale> yeah
10:33:24 <Cale> They're a general way to structure certain kinds of libraries.
10:33:33 <LoganCapaldo> Monads, not just for IO anymore! ;)
10:33:46 <mauke> oscz: monads have nothing to do with IO, really
10:33:55 <mauke> it's just that haskell's IO system fits into the monadic framework
10:34:24 <oscz> ok
10:34:50 <Cale> There are monads for parsing, monads for nondeterministic computation, monads for simulating parallelism, monads for IO, monads for managing first-class continuations, and all sorts of other things.
10:36:10 <Cale> In general, if you have a sort of value which represents a "computation" of some kind, and these computations have "results", and can be put together "sequentially" (though that might not be the whole story of how it's executed), then you might have a monad.
10:36:25 <LoganCapaldo> I love that definition
10:36:31 <fasta> Is there also a monad web server that does aliases, cgi and works out of the box with only one line to configure in its default config on Debian?
10:36:44 <LoganCapaldo> its so vague it sounds like the definition of a computer program
10:37:11 <Cale> hehe
10:37:24 <oscz> yes.. i was just thinking that there's some sort of notion of order in there as >> and >>= both define order
10:37:33 <oscz> are there more operators like this?
10:37:36 <stepcut> fasta: well, one very long point-free line...
10:37:39 <oscz> for monads
10:37:40 <mauke> arrows! :-)
10:37:45 <Cale> well, there are ones which are built from those
10:37:48 <birkenfeld> oscz: that's one of the reasons why it works for IO
10:37:50 * stepcut goes out for tea
10:37:59 <LoganCapaldo> >> is actually built from >>=
10:38:01 <DRMacIver> LoganCapaldo: Well, to a first approximation it is... :)
10:38:04 <Cale> like forM and sequence and ap
10:38:06 <mauke> Control.Monad has a few helper functions defined in terms of return/>>=
10:38:07 <LoganCapaldo> @src (>>)
10:38:07 <lambdabot> m >> k      = m >>= \_ -> k
10:38:08 <DRMacIver> (The definition of a computation I mean)
10:38:37 <desegnis> oscz: note that only return and >>= are necessary for something to be a monad. You get things like (>>), sequence, ... for free once you have return and (>>=).
10:38:39 <Cale> The real reason why we bother defining monads is so that we can share code between all monads.
10:38:58 <fasta> I thought web servers were commodity software by now.
10:39:02 <Cale> The stuff which works in all monads tends to have a decidedly "control structure" feel to it.
10:39:15 <oscz> "action" relates to monads too ?
10:39:33 <Cale> oscz: yeah, it's just that what constitutes an "action" varies per the monad.
10:39:48 <Cale> In the list monad, an "action" is just a list of values.
10:40:02 <mauke> "action" is another name for "a value that has the type (exists m a. (Monad m) => m a)"
10:40:11 <LoganCapaldo> IM(addmittedly small)E people tned to use "action" mor eoften when talking about IO
10:40:24 <Cale> yeah
10:40:30 <Cale> "computation" is a bit more general
10:40:53 <Cale> and "monadically typed value" is perhaps even more general feeling
10:40:55 <mauke> and IO's friends, like ST or STM
10:41:06 <oscz> what is action's return value?
10:41:28 <LoganCapaldo> it doesn't have a return value it is a valu
10:41:30 <LoganCapaldo> *value
10:41:32 <Cale> oscz: oh, 'action' isn't an action, it's a word we use to describe values which are monadically typed.
10:41:33 <mauke> the a in m a
10:41:53 <LoganCapaldo> putStrLn "Hello, world!"
10:41:59 <LoganCapaldo> that'[s an action
10:42:00 <Cale> But yeah, if we have a value of type (m a), then the a is the return type
10:42:18 <LoganCapaldo> it's a value of type IO () in that cae
10:42:20 <Cale> LoganCapaldo: Its return value is ()
10:42:33 <Cale> (In our current description)
10:42:49 <mux> no, that would be the return value of unsafePerformIO $ putStrLn "Hello world"
10:42:49 <mux> :)
10:43:09 <mauke> no, that would be the value
10:43:17 <oscz> ok.. so in the end, main would be evaluated to that IO action and then run ?
10:43:50 <desegnis> Also note that, if x :: T, then return x :: Monad m => m T
10:43:55 <monochrom> English is confusing.
10:44:00 <mux> I guess it depends on what you call a "return value"
10:44:11 <Cale> oscz: yeah
10:44:20 <ac> Is it possible to get a more enlightening error message than "Error in array index"?
10:44:34 <Cale> oscz: (well, really the steps of evaluation and execution are interleaved, but essentially you can imagine it happening that way)
10:45:09 <monochrom> "Error in array index. You need dependent typing." may be more enlightening IMO. :)
10:45:46 <LoganCapaldo> I think there's gotta be a better way to say "return value" if you are talking about Haskell's return and not imperative language foo's return
10:45:59 <Cale> ac: I wonder how good the new debugger in GHCi 6.8.1 is
10:46:10 <ac> Cale: how do I use it?
10:46:44 <Cale> ac: well, do you have the development GHC?
10:46:58 <ac> I just have 6.8.0
10:47:20 <oscz> thanks again guys.. i'll go back experimenting now :)
10:47:21 <Cale> you might be able to :set -fbreak-on-error
10:47:57 <ac> Cale: but that's within ghci. I still can't run my program within ghci
10:48:03 <Cale> er, hmm
10:48:14 <Cale> why is that?
10:48:16 <ac> I get a gtk2hs related error
10:48:32 <Cale> hmm
10:48:42 <Cale> Have you talked to dcoutts about it?
10:48:52 <ac> Cale: nope
10:49:03 <allbery_b> in ghci you need to use a different initGUI
10:49:11 <allbery_b> otherwise you get a complaint about threading
10:50:10 <allbery_b> unsafeInitGUIForThreadedRTS
10:50:13 <ac> HSgtk.o: unknown symbol `containerszm0zi1_DataziSequence_index_info'
10:50:24 <allbery_b> huh
10:51:00 <paczesiowa> can I use gtk2hs code inside StateT monad? I would like to have some kind of state and e.g. when binding action to buttonpressed event, I would like to pass to that action state and modify it there, is it possible?
10:51:20 <allbery_b> with a hack, yes
10:51:21 <Cale> paczesiowa: Gtk2Hs is already in the IO monad.
10:51:36 <Cale> paczesiowa: Which has basically as much state as you should ever need.
10:51:43 <LoganCapaldo> IORefs to the "rescue"
10:51:46 <Cale> (You can create things like IORefs)
10:52:13 <paczesiowa> I thought State is much nicer and IORefs are hacks?
10:52:33 <Cale> Nah, if you're in the IO monad already, IORefs are perfectly okay
10:52:47 <Zao> Does people use STM?
10:52:52 <Cale> Zao: yeah
10:53:01 <Cale> Zao: it's really cool :)
10:53:08 <Zao> I found it quite handy for communicating with my threaded off network code.
10:53:16 <LoganCapaldo> And I think State being "nicer" depends on in what sense of nice you are talking about too
10:53:39 <allbery_b> @go monadic tunneling haskell-cafe
10:53:42 <lambdabot> http://swik.net/cafe
10:53:43 <lambdabot> Title: cafe - SWiK
10:54:02 <Cale> paczesiowa: Normally, I define all my event handlers in a let-block inside my main do-block. That way, initially constructed state IORefs can be shared throughout.
10:54:03 <Zao> Cale: SPJ's STM intro in Beautiful Code made me want to learn Haskell.
10:54:09 <Zao> It's all his fault :P
10:54:15 <Cale> Zao: hehe :)
10:54:49 <paczesiowa> Cale: could you share some code?
10:55:04 <Cale> paczesiowa: sure, I think I have some code lying around...
10:55:14 <allbery_b> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
10:55:16 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ..., http://tinyurl.com/3xmhco
10:55:25 <mux> Cale: quicksilver wrote an interesting mail about this on -cafe@
10:55:31 <mux> heh, there it is
10:55:50 * allbery_b is using a variant of that to thread private state through gtk2hs callbacks (in fact that was what triggered the above message)
10:55:52 <mux> he's got an InterleavableIO type-class
10:56:26 <hpaste>  Cale pasted "hopefully this doesn't get truncated..." at http://hpaste.org/3136
10:57:03 <allbery_b> it did :(
10:57:31 <hpaste>  Cale annotated "hopefully this doesn't get truncated..." with "sorry about all the commented out stuff -- this was apparently in the middle of some editing." at http://hpaste.org/3136#a1
10:57:42 <birkenfeld> mux: what does it do?
10:58:10 <paczesiowa> Cale: tx, I'll read it
10:58:24 <mux> birkenfeld: in essence, it snapshots a monad, and makes it available later
10:58:40 <mux> there were instances for State, Reader and a few other I think
10:58:44 <hpaste>  allbery_b pasted "snippet of what I use to wrap gtk2hs callbacks" at http://hpaste.org/3137
10:58:47 <birkenfeld> nice
10:59:03 <allbery_b> I'm sure someone has better ways to do it, I'm still somewhat new to all this stuff
10:59:08 <Cale> paczesiowa: it's the main for a program for drawing L-Systems. There's lots of code in there for a custom widget which is drawn in the drawing area when the user clicks and drags, used to set the initial angle.
10:59:54 <SamB_XP> InterleaveableIO ?
10:59:57 <SamB_XP> why IO?
11:00:11 <oscz> Kind error: 'Float' is applied to too many type arguments... I believe i have my function correctly defined.. is this some typical beginner mistake?
11:00:19 <allbery_b> because gtk2hs is in IO
11:00:24 <mux> looks like you write 'Float Something'
11:00:29 <mux> s/write/wrote/
11:00:32 <allbery_b> but some of us want to interweave gtk2hs calls with private state
11:00:35 <Cale> oscz: did you provide a type signature?
11:00:45 <SamB_XP> hmm.
11:00:48 <allbery_b> oscz: paste your code?
11:00:48 <Cale> oscz: That error seems to indicate something wrong with a type signature.
11:00:54 <oscz> Cale: im trying to .. that's when i got the error
11:01:21 <Cale> In particular, Float is being applied to a type parameter which it shouldn't be
11:01:55 <LoganCapaldo> Is there a Floating class?
11:01:59 <Cale> yes
11:02:03 <Cale> :t (**)
11:02:08 <LoganCapaldo> Maybe he's just brainoing that
11:02:09 <lambdabot> forall a. (Floating a) => a -> a -> a
11:02:14 <oscz> it's a simple recursive function returning how much debt you have left after some time given interest etc
11:02:30 <LoganCapaldo> (Float a) => a -> ...
11:02:38 <Cale> yeah, that would be a mistake :)
11:02:48 <Cale> oscz: if you want a correct type signature for it, you can delete the type sig and load it in GHCi
11:02:59 <Cale> oscz: then just type  :t myFunction
11:03:03 <Cale> and it'll tell you the type
11:03:16 <oscz> yes im experimenting in ghci ..
11:03:20 <oscz> oh hehe :P thanks
11:05:50 <oscz> uh huh.. it's a bit more complicated than i thought... ;)
11:05:52 * allbery_b should finish debugging the program that snippet he posted came from, and then see about cleaning it up a bit
11:06:05 <mauke> oscz: can you paste the type here?
11:06:08 <allbery_b> (since it's really just the first cut at rewriting it to use threaded state)
11:07:51 <oscz> debt :: (Num a, Fractional (t t1), Ord a) => t t1 -> t t1 -> t t1 -> t t1 -> a -> t t1
11:08:20 <LoganCapaldo> that looks suspicious
11:08:26 <LoganCapaldo> th Fractional (t t1)
11:08:27 <mauke> whoa
11:08:33 <mauke> how did you do that?
11:08:46 <oscz> the way i see it, it takes in 4 Floats and Int .. and returns Float
11:08:54 * twifkak is away: bbiaf
11:09:04 <Cale> oscz: Okay, there's a problem with your code :)
11:09:10 <LoganCapaldo> @type fmap id g / fmap id f
11:09:15 <lambdabot> Not in scope: `g'
11:09:16 <lambdabot>  
11:09:16 <lambdabot> <interactive>:1:20: Not in scope: `f'
11:09:16 <Cale> (not just the type signature)
11:09:30 <LoganCapaldo> @type fmap id ?g / fmap id ?f
11:09:31 <mauke> oscz: no, Float can't be (t t1)
11:09:32 <lambdabot> forall a (f :: * -> *). (?g::f a, ?f::f a, Functor f, Fractional (f a)) => f a
11:09:35 <oscz> Cale: heh ok... it returns correct results though i think
11:09:51 <Cale> oscz: You can't possibly run it
11:10:13 <LoganCapaldo> your type, it makesa no sense
11:10:19 <Cale> Unless maybe with Complex Float ?
11:10:26 <LoganCapaldo> Oh true that
11:10:43 <Cale> I honestly would like to see how you managed to get that type signature :)
11:11:03 <LoganCapaldo> (magic!
11:11:17 <oscz> hmm maybe there'
11:11:23 <oscz> s some typo in there
11:11:56 * LoganCapaldo wants to see the function
11:12:15 <LoganCapaldo> Pleeeeeease?
11:12:20 <mauke> ELP++
11:12:36 <LoganCapaldo> @vera ELP
11:12:39 <lambdabot> *** "elp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
11:12:39 <lambdabot> ELP
11:12:39 <lambdabot>      Equational Logic Programming [language]
11:12:39 <lambdabot>  
11:12:59 <birkenfeld> some time ago, I saw some definitions that made using IORefs much easier on the eyes, but I can't remember where
11:13:02 <mauke> Emerson, Lake & Palmer
11:13:24 <LoganCapaldo> Ah
11:13:28 <LoganCapaldo> I knew it sounded familar
11:13:35 <LoganCapaldo> and not from a programming context
11:13:59 * LoganCapaldo 's mother listens to them
11:15:06 <oscz> i forgot "do" in front of a recursive call to the debt function.. that's what caused it
11:15:58 <SamB_XP> hmm. I want a gmail phone.
11:16:01 <allbery_b> birkenfeld: I recall seeing that too, meanwhile since all mine are hidden inside a ReaderT I have "askr" and "setr"
11:17:14 <LoganCapaldo> a gmail phone?
11:17:23 <LoganCapaldo> Not a google phone?
11:17:27 <allbery_b> hm
11:17:33 <allbery_b> @wiki Library/ArrayRef
11:17:33 <lambdabot> http://www.haskell.org/haskellwiki/Library/ArrayRef
11:18:25 <SamB_XP> LoganCapaldo: I want my text messages to be grouped into conversations
11:18:53 <LoganCapaldo> unsafePerformIO isn't general enough. There should be an unsafePerformM :: (monad m) => m a -> a
11:19:01 <LoganCapaldo> SamB_XP: My phone does that
11:19:14 <oscz> debt :: (Num a, Fractional a1, Ord a) => a1 -> a1 -> a1 -> a1 -> a -> a1
11:19:20 <oscz> that's the real signature
11:19:23 <SamB_XP> LoganCapaldo: so it can be done?
11:19:26 <SamB_XP> that's nice to know
11:19:29 <LoganCapaldo> but doesn't really do the multiple conversants thing
11:19:47 <LoganCapaldo> but I'm not sure that happens with text messaging?
11:19:54 * LoganCapaldo doesn't text message a hell of a lot
11:20:01 <SamB_XP> I did send a text message to two people today
11:20:11 <reilly> can any body point me at a good paper on structural pattern matching algorithms?  I'm looking to compile n patterns over an ADT into a single pattern matching (& binding) machine
11:20:19 <SamB_XP> I think my phone actually sent messages with the same content to each, though
11:20:24 <SamB_XP> since I got charged for two messages
11:21:03 <fnord123> on page 91 of yaht, it says that a data decl w/ named variables like data X = X { a :: String, b :: Int} will automatically define variables to access a and b. How are these exported? "module Xyz( X(X)) where" doesn't seem to export them.
11:21:16 <oscz> if you have a function taking in 4 Floats, 1 Int and returning a Float.. how is the signature defined ? my approach clearly doesnt work ;)
11:21:30 <SamB_XP> (though possibly the charge is for sending the messages on to the recipients, and not for sending them to your provider...)
11:21:46 <LoganCapaldo> fnord123: the lazy way is module Xyz ( X(..) )
11:21:47 <Zao> f :: Float -> Float -> Float -> Float -> Int -> Float
11:22:11 <LoganCapaldo> But if you wnat to be explicit I think you do module Xyz( X(X, a, b) )
11:22:12 <oscz> oh yeah.. this part i dont get in the function signatures..
11:22:23 <fnord123> Thanks LoganCapaldo
11:22:45 <oscz> imo they should be grouped like.. f :: (Float Float Float Float Int) -> Float
11:23:07 <LoganCapaldo> fnord123: thinking about it it might even just be module Xyz ( X(X), a, b )
11:23:25 <LoganCapaldo> since the accessors aren't namespaced to the type
11:23:40 <Zao> oscz: The closest to what you're trying to do would be a five member tuple parameter, like (Float,Float,Float,Float,Int)
11:23:45 <LoganCapaldo> (in which case .. probably won't work)
11:23:55 <LoganCapaldo> Someone who actually knows feel free to chime in anytime ;)
11:24:38 <fnord123> .. worked for now. and I'm loathe to repeat my enumerable type in the module decl :)
11:24:44 <mauke> oscz: in haskell every function takes exactly one argument
11:24:49 <Zao> oscz: :: A -> B -> C is the same as A -> (B -> C)
11:24:51 <mauke> oscz: there's no "argument list" or anything like that
11:25:04 <oscz> mauke: but the function needs them all at once to make some sense
11:25:22 <Zao> oscz: You can pass in less than all arguments to get a function taking the remaining ones.
11:25:55 <mauke> oscz: so it takes one argument and returns another function
11:26:12 <mauke> which then takes another argument and returns another function
11:27:21 <oscz> but for the function to make any sense they need to be passed as a group from same evaluation
11:27:36 <SamB_XP> oscz: nope
11:27:37 <LoganCapaldo> oscz nope
11:28:23 <LoganCapaldo> > let mul a b = a *  b ; times2 = mul 2 in times2 4
11:28:25 <lambdabot>  8
11:28:26 <oscz> that's weird :)
11:28:30 <SamB_XP> Haskell's semantics say otherwise...
11:28:52 <oscz> this has to do with "no side-effects" ?
11:28:55 <mauke> weird? THIS IS SPARTA^WCURRYING
11:28:57 <oscz> that you can do that?
11:28:59 <mauke> no
11:29:01 <LoganCapaldo> nope
11:29:04 <mauke> I can do the same thing in Perl
11:29:35 <oscz> i guess it's the imperative function calls in my head playing tricks on me :(
11:29:37 <LoganCapaldo> heck you can do the same thing in C++ if you're willing to put in the effort
11:29:40 <SamB_XP> > let f "" y = y; f "hi!" `seq` "bye!"
11:29:40 <lambdabot>  Parse error
11:29:47 <SamB_XP> > let f "" y = y in f "hi!" `seq` "bye!"
11:29:49 <lambdabot>  "bye!"
11:29:51 <SamB_XP> what.
11:30:22 <SamB_XP> > let f "" = id in f "hi!" `seq` "bye!"
11:30:23 <lambdabot>   Non-exhaustive patterns in function f
11:30:30 <MyCatVerbs> SamB_XP: can't have the colon without the "in" except in do-notation.
11:30:37 <mauke> desugaring kicking your ass?
11:30:52 <SamB_XP> MyCatVerbs: no, it was just that that program was supposed to fail!
11:31:01 <MyCatVerbs> SamB_XP: oh. Heh.
11:31:45 <oscz> LoganCapaldo: how is that done in c++ ?
11:31:53 <mauke> perl -wle 'sub mult { my $x = shift; sub { my $y = shift; $x * $y } }  my $f = mult 3;  print for $f->(2), $f->(5)'
11:32:03 <MyCatVerbs> SamB_XP: umm, I think lambda-floating optimization is noted to occasionally break the termination semantics of `seq`, usually with the result that things that strictly ought not to terminate sometimes do.
11:33:03 <SamB_XP> MyCatVerbs: I thought this just meant that the compiler had to prove that it wasn't going to mess up the semantics?
11:33:25 <SamB_XP> I think it was what mauke said ;-)
11:34:48 <LoganCapaldo> oscz: something like: struct { operator(int x){ struct { int x; operator(int y) { return x + y; } } f1; f1.x = x; return f1; } f; f( 2)( 3 ); I've probbaly messed up the sytax or something somewhere
11:35:30 * twifkak is back (gone 00:26:35)
11:36:13 <LoganCapaldo> You have to lift your own lambdas :)
11:36:21 <oscz> if you have foo :: Int -> Int -> Int -> Int
11:36:29 <ericlavigne> @src readFile
11:36:30 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
11:36:47 <oscz> and want to call it and leave the FIRST param undefined but define the last two, how is it done?
11:37:05 <mauke> oscz: by creating more functions
11:37:06 <LoganCapaldo> @type flip
11:37:08 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:37:22 <mauke> \x -> foo x 2 3
11:37:30 <SamB_XP> @pl (\x -> foo x y z)
11:37:30 <lambdabot> flip (flip foo y) z
11:37:45 <SamB_XP> @pl (\foo y z x -> foo x y z)
11:37:46 <lambdabot> (flip .) . flip
11:38:03 <mauke> oscz: http://rafb.net/p/cDv2P064.html
11:38:04 <lambdabot> Title: Nopaste - No description
11:38:14 <mauke> warning: template abuse
11:38:17 <SamB_XP> @pl (\y z x -> foo x y z)
11:38:17 <lambdabot> flip . flip foo
11:38:26 <SamB_XP> oh, interesting...
11:39:23 <oscz> heh i see
11:39:27 <LoganCapaldo> mauke: you are less lazy than I sir
11:39:37 <SamB_XP> @pl (\x -> foo x y z)
11:39:38 <lambdabot> flip (flip foo y) z
11:41:02 <mauke> (the only reason body() is a separate function is that I didn't want to explicitly write the type of mult(3))
11:42:23 <gopik> q
11:43:29 <oscz> i'd want to print some output for each evaluation of my simple recursive debt function
11:43:34 <olsner> C++ needs type inference ;-)
11:43:42 <oscz> should i try to construct a list of actions or something ?
11:44:02 <LoganCapaldo> it's getting some :)
11:45:00 <olsner> well, it does have "some" "type inference" already, such as the body() function in the pasted code
11:45:14 <LoganCapaldo> ok, it's getting some more :)
11:45:56 <LoganCapaldo> auto f = multi(3);
11:46:07 <LoganCapaldo> s/multii/mult/
11:46:13 <LoganCapaldo> gah
11:46:16 <LoganCapaldo> I can't type
11:46:27 <gopik> I'm trying to control a cmd line based program through GUI. I want to launch the cmd through runInteractiveCommand and control the input/output/error handles (pipe them to the GUI)
11:46:48 <gopik> Right now I would like to pipe them to stdin/stdout/stderr
11:47:14 <gopik> Is there an API to pipe the process' handles to other handles?
11:47:28 <LoganCapaldo> @hoogle reopen
11:47:32 <lambdabot> No matches found
11:47:50 <gopik> cool, thanks, i'll try
11:47:58 * LoganCapaldo if its there it prbbaly has a name as different from reopen as runInteractiveProcess is from popen
11:48:37 <LoganCapaldo> @hoogle dup2
11:48:37 <lambdabot> No matches found
11:49:10 <gopik> dupChan i guess
11:49:15 <LoganCapaldo> One thing to be said for haskell, it doesn't let its names be influenced by existing apis :)
11:50:29 <SamB_XP> hmm, my cellphone is making my speakers make wierd noises, I think...
11:50:53 <olsner> "2007: Haskell becomes the first language to include 'intercalate' as a library function."
11:52:22 <LoganCapaldo> SamB_XP: is your phone gsm?
11:52:45 <LoganCapaldo> I recently heard from various people that gsm phones do that to speakers
11:54:23 <LoganCapaldo> they shoulda taken a page from concatMap and called it concatIntersperse
11:55:49 <allbery_b> <LoganCapaldo> I recently heard from various people that gsm phones do that to speakers
11:55:52 <allbery_b> yes, yes they do
11:58:18 <Toba> yeah, my phone does that to my speakers as well
11:58:21 <Toba> 'bip bip bip biiiip
11:58:22 <Toba> '
12:05:11 <SamB_XP> > concat . intersperse == intercalate
12:05:12 <lambdabot>   Not in scope: `intercalate'
12:06:32 <dmwit> intercalate means "to insert a day into the calendar"...
12:07:47 <dmwit> (according to dict.die.net)
12:08:19 <SamB_XP> @devil intercalate
12:08:20 <lambdabot> No match for "intercalate".
12:08:42 <dibblego> intercollate?
12:09:41 <_achilles_> @pl (\(a,b) -> (length . show) b == 1000))
12:09:41 <lambdabot> (line 1, column 38):
12:09:41 <lambdabot> unexpected ")"
12:09:41 <lambdabot> expecting variable, "(", operator or end of input
12:09:54 <allbery_b> woo, a refactoring that actually shrinks the code :)
12:10:15 <dmwit> @pl (\(a,b) -> (length . show) b == 1000)
12:10:15 <lambdabot> (1000 ==) . length . show . snd
12:10:45 <_achilles_> thank you
12:10:50 <_achilles_> :)
12:11:33 <_achilles_> make a lot of sense now that I see it
12:13:41 <_achilles_> is that the best way to find the length of a number (in digits) = (length . show) number?
12:14:34 <dmwit> > floor . logBase 10 $ 1000
12:14:39 <lambdabot>  2
12:14:55 <dmwit> err...
12:15:03 <dmwit> > logBase 10 1000
12:15:04 <MyCatVerbs> dmwit: you want ceiling rather than floor, surely?
12:15:04 <lambdabot>  2.9999999999999996
12:15:07 <allbery_b> heh
12:15:17 <dmwit> Rounding error. =P
12:15:18 <allbery_b> mmm, floating point
12:15:32 <dmwit> MyCatVerbs: I'm pretty sure I want floor, but better floats. =)
12:15:36 <newsham> irony: this costs $29 to read:  http://doi.ieeecomputersociety.org/10.1109/MC.1996.10041
12:15:49 <lambdabot> Title: Education
12:15:50 <LoganCapaldo> > 1 + ceil $ logBase 10 934
12:15:51 <lambdabot>   Not in scope: `ceil'
12:15:57 <LoganCapaldo> > 1 + ceiling $ logBase 10 934
12:15:58 <lambdabot>   add an instance declaration for (Num (a -> b))
12:16:10 <LoganCapaldo> > 1 + ceiling (logBase 10 934)
12:16:12 <lambdabot>  4
12:16:19 <LoganCapaldo> > ceiling (logBase 10 934)
12:16:21 <lambdabot>  3
12:16:24 <MyCatVerbs> > (+) 1 $ ceiling $ logBase 10 934
12:16:25 <lambdabot>  4
12:16:27 <LoganCapaldo> > ceiling (logBase 10 1000)
12:16:28 <lambdabot>  3
12:16:29 <newsham> "the need for education in useful formal logic"
12:16:32 <LoganCapaldo> mmm
12:16:57 <oscz> what Haskell book would you recommend for a beginner?
12:17:01 <LoganCapaldo> it's not quite right :)
12:17:09 <newsham> oscz: graham hutton's book
12:17:19 <MyCatVerbs> oscz: I would reccommend "The Art of Prolog", personally.
12:17:22 <newsham> I would also recommend "two dozen short lessons" which is free online
12:17:47 <newsham> ?google two dozen short lessons haskell
12:17:50 <lambdabot> http://www.cs.ou.edu/cs1323h/textbook/haskell.shtml
12:17:50 <lambdabot> Title: Two Dozen Short Lessons in Haskell
12:17:58 <MyCatVerbs> oscz: not that it's any good for learning Haskell from, but once you've already had your brain fried into boiling carbon by Prolog, Haskell will come as a relative relief. =)
12:18:06 <LoganCapaldo> > (\x -> ceiling (logBase 10 x) + (if x `mod` 10 == 0 then 1 else 0)) 934
12:18:07 <lambdabot>  Add a type signature
12:18:14 <oscz> hehe
12:18:15 <newsham> http://www.cs.nott.ac.uk/~gmh/book.html
12:18:15 <LoganCapaldo> > (\x -> ceiling (logBase 10 x) + (if x `mod` 10 == 0 then 1 else 0)) 934 :: Int
12:18:16 <oscz> thanks
12:18:16 <lambdabot>  Add a type signature
12:18:16 <lambdabot> Title: Programming in Haskell
12:19:21 <ericlavigne> I suggest Real World Haskell. It is a work in progress, and the author's writing is still a bit weak, but comments from readers do a good job of filling in the blanks.
12:19:40 <newsham> anyone use graham/knuth/patanshnik's "Concrete mathematics: a foundation for computer science"?
12:19:59 <newsham> eric: yah but also not out yet.
12:20:03 <LoganCapaldo> > let digitCount n | n `mod` 10 == 0 = 1 + logBase 10 n ; digitCount n = ceiling (logBase 10 n) in digitCount 1000
12:20:04 <lambdabot>  Add a type signature
12:20:12 <LoganCapaldo> Alright I surrender
12:20:18 <LoganCapaldo> wtf am I doing wrong?
12:20:38 <LoganCapaldo> oh
12:20:54 <ericlavigne> newsham: available as alpha release. that just means that you have to register to see it
12:21:07 <byorgey> newsham: I've read almost all of it, why? (sorry if I missed the context, I just entered)
12:21:24 <LoganCapaldo> > let digitCount :: Int -> Int ; digitCount n | n `mod` 10 == 0 = 1 + logBase 10 n ; digitCount n = ceiling (logBase 10 n) in digitCount 1000
12:21:25 <lambdabot>   add an instance declaration for (RealFrac Int)
12:21:25 <lambdabot>     In the expression: ceili...
12:21:31 <newsham> byorgey: came across it in a biblio, and i'm looking for a good math book.
12:21:37 <newsham> whats your impression?  whats the level?
12:21:47 <LoganCapaldo> > let digitCount :: Int -> Int ; digitCount n | n `mod` 10 == 0 = 1 + logBase 10 n ; digitCount n = ceiling (logBase 10 (fromIntegral n)) in digitCount 1000
12:21:48 <lambdabot>   add an instance declaration for (Floating Int)
12:21:51 <byorgey> newsham: it is excellent, probably one of the best math books I've ever read.
12:22:07 <LoganCapaldo> > let digitCount :: Int -> Int ; digitCount n | n `mod` 10 == 0 = 1 + logBase 10 (fromIntegral n) ; digitCount n = ceiling (logBase 10 (fromIntegral n)) in digitCount 1000
12:22:08 <lambdabot>   add an instance declaration for (Floating Int)
12:22:10 <byorgey> newsham: level is motivated undergraduate/introductory graduate.
12:22:17 <LoganCapaldo> ?me kilsl self
12:22:17 <lambdabot> Maybe you meant: messages messages? . bf ft id let map more msg pl rc time v wn
12:22:24 <newsham> byorgey: thanks.
12:22:31 * LoganCapaldo faisl at virtual suicide
12:22:35 <dibblego> byorgey, are you referring to Programming in Haskell?
12:22:47 <byorgey> dibblego: no, "Concrete Mathematics"
12:22:50 <ericlavigne>  "Concrete mathematics: a foundation for computer science"?
12:23:00 <byorgey> ericlavigne: that's it.
12:23:12 <quicksilver> I found it rather dry, I must admit :P
12:23:17 <quicksilver> but it's well written
12:24:36 <newsham> "SPECIAL NOTE TO THE SPEAKERS OF FRENCH AND OTHER EXOTIC LANGUAGES: Numerous quotations and bibliographic citations found in this book have been copied verbatim from the original sources. If you believe you have found a typographic error, you must prove it by showing that the original was incorrectly transcribed; believe it or not, your language has changed over the years, just as English has."
12:24:42 <newsham> heh!
12:24:45 <newsham> the french
12:25:01 * earthy laughs
12:25:58 <ericlavigne> MyCatVerbs recommended learning Prolog (The Art of Prolog) for frying one's brain into boiling carbon. Is Prolog so much more mind bending than Haskell?
12:27:09 <puusorsa> no
12:27:20 <Zao> ericlavigne: Form a pile of axioms, throw into prolog and observe output.
12:27:56 <MyCatVerbs> ericlavigne: depends what depth you learn either to. Prolog is harder to get started in than Haskell, being more alien, Haskell has much more advanced interesting stuff to be encountered and comprehended earlier on.
12:28:20 <ericlavigne> TK Solver is roughly the same idea, but its derivation capabilities are a bit weak.
12:28:31 <MyCatVerbs> ericlavigne: Prolog has a natural difficulty to it because unification+backtracking is completely alien at first.
12:29:16 <MyCatVerbs> ericlavigne: Haskell, though, when you get into it through books like YAHT, exposes you to monads, CPS, points-free style...
12:29:20 <Philippa_> I remember thinking of Prolog as "haskell, backwards" when I first encountered it having done a single module on haskell at uni
12:29:31 <Philippa_> and unification and backtracking as well
12:29:44 <Philippa_> though you'll first meet unification in the type system
12:31:28 <ericlavigne> I think that most of the difficulty I've had with Haskell comes from the way things are explained, rather than complexity in the language itself. I haven't really found a great intro yet.
12:31:47 <MyCatVerbs> Philippa_: hrmn, I never got that impression. A few other things did occur to me about the relation between the two languages, thoguh.
12:31:51 <MyCatVerbs> *though
12:32:07 <ericlavigne> Fortunately, when I get really frustrated, a quick visit to this channel clears things up.
12:32:12 <raxas> ericlavigne: in Prolog, all you need to understand is logic unification. But in Haskell, there are Ten Thousands Things to understand.
12:32:31 <MyCatVerbs> Philippa_: like, there's absolutely no reason whatsoever why Haskell code couldn't be freely embedded into Prolog, on account of referential transparency. Just treat all pieces of Haskell code as "is" clauses.
12:33:12 <MyCatVerbs> raxas: ah, thank you! A perfect summary, yes. With the caveat that logic unification is slightly more difficult than any one of the topics one encounters in Haskell.
12:33:39 <xerox> ?bot
12:33:39 <lambdabot> :)
12:33:44 <xerox> ?join #haskell.it
12:33:45 <lambdabot> Not enough privileges
12:33:52 <SamB_XP> MyCatVerbs: except maybe implementing the type inference ;-)
12:34:11 <Philippa_> MyCatVerbs: it was based on a rather limited set of intuitions. But I was using prolog in a way that 'branched outwards' instead of narrowing down a tree to a single path of execution
12:34:23 <olsner> but logic unification is really simple as a concept
12:34:28 <MyCatVerbs> SamB_XP: not a problem for users of Haskell. Just pretend that the type inferrer is voodoo magic and nothing you need to worry about and it's no problem.
12:34:51 <MyCatVerbs> raxas: but then, every language has aleph-null things in it to be understand. Prolog has things like difference lists, incomplete data structures...
12:35:02 <SamB_XP> MyCatVerbs: you mean not all Haskell users aspire to write Haskell compilers?
12:35:12 <MyCatVerbs> SamB_XP: not at first, no.
12:35:19 <Philippa_> I think most Haskell users want to be able to follow the inference process at least
12:35:26 <Philippa_> it's awful useful if you're having trouble understanding an error
12:35:46 <ericlavigne> Voodoo magic is fine by me. I would like to see hClose added to that voodoo magic as well (so I don't have to write hClose statements) because it interacts in weird ways with lazy evaluation.
12:35:47 <MyCatVerbs> SamB_XP: myself, when I used Haskell first of all, my attitude to type inference was, "No need to worry about this, someone much cleverer than I am has already solved this problem and their implementation works."
12:38:04 <Philippa_> ericlavigne: it's not hClose that's weird there, it's lazy IO
12:38:13 <MyCatVerbs> Philippa_: hmmm, this is true. But it's not neccessarily such a great problem in practice, at least at first. Building programs bottom-up, throwing everything through :t in ghci more or less precludes getting type errors in the first place, provided you don't try anything *too* interesting.
12:38:31 <Philippa_> like mutually recursive definitions
12:39:02 <MyCatVerbs> ericlavigne: er, that's unsafeInterleaveIO (a close relation of unsafePerformIO) that's screwing with your head, not hClose itself (assuming that your source of headaches is related to hGetContents).
12:39:33 <Philippa_> if you've got mutually recursive definitions and you also do something that'll yield a weird error you'd better have decent discipline in tracking the error down or it'll take forever
12:39:50 <MyCatVerbs> Philippa_: like *complicated* mutually-recursive definitions. Anything that doesn't require you to use '.' more than, say, twice in the same expression, is usually fine. ;)
12:39:56 <ericlavigne> Philippa_: I consider lazy IO to be a nice thing most of the time. Throw in garbage collection that is triggered by a shortage of file descriptors, as well as by any file open statement, and I would never need to touch hClose again.
12:40:38 <Philippa_> MyCatVerbs: I've run into it more than once, and while there was a comparatively high level of complexity per line in my code I wasn't doing anything /that/ involved
12:41:00 <Philippa_> you could narrow the error down to 20-odd lines easily in each case, after that it's time to cut the loop with an annotation
12:41:05 <MyCatVerbs> ericlavigne: you want unsafeUponGarbageCollectionIO
12:41:07 <MyCatVerbs> ?
12:41:52 <ericlavigne> @hoogle unsafeUponGarbageCollectionIO
12:41:53 <lambdabot> No matches found
12:42:01 <mauke> no
12:42:20 <MyCatVerbs> ericlavigne: I mean, you want somebody to go implement something along those lines.
12:42:25 <MyCatVerbs> Philippa_: the only time I've had great problems getting things through the H-M inferrer were when I either a) didn't understand either the problem or the APIs correctly, and was trying to write nonsensical code anyway...
12:42:33 <ericlavigne> Handles are automatically closed if they are no longer needed, but only during garbage collection events.
12:42:46 <ericlavigne> Garbage collection is triggered by a shortage of memory.
12:43:01 <ericlavigne> but garbage collection is also needed when short on file descriptors.
12:43:03 <MyCatVerbs> Philippa_: ...and when using lots of little functions inside "while" clauses, where it's awkward to break them out so that I can :t each one individually to see what it's really doing.
12:43:14 <MyCatVerbs> ericlavigne: oh, I see.
12:43:23 <mauke> heh
12:43:28 <mauke> #define while where
12:43:38 <ericlavigne> If garbage collection occurred whenever it was needed, it would simplify some IO issues.
12:43:46 <MyCatVerbs> ericlavigne: but a more general mechanism might be handy anyway, so that it could be done with other arbitrary things, like, I dunno. Database connections, whatever.
12:43:46 <Philippa_> MyCatVerbs: then you're either a genius, lucky or not writing the same kind of code as me
12:43:57 <MyCatVerbs> mauke: oops, sorry.
12:44:18 <Philippa_> if you've got a group of four functions that form a mutually-recursive loop, you can't :t them individually
12:44:38 <MyCatVerbs> Philippa_: number three, I think. I'm too stupid to write code that's interesting from a type-theoretic point of view, so I don't.
12:44:42 <ericlavigne> MyCatVerbs: Yes, basically, memory isn't the only thing that garbage collection should be used for. Haskell has already moved in that direction by letting garbage collection act on other things, but it is still triggered only by memory shortage.
12:44:59 <Philippa_> all it takes to make your life hell then is for the actual error to be close enough to making sense that the type checker finds error elsewhere
12:45:06 <MyCatVerbs> Philippa_: also I have yet to write a more than two-way mutual recursion. _
12:45:27 <Philippa_> it was largely a plain cycle, but still
12:45:42 <Philippa_> last one I had was actually in a type inference algorithm, go figure :-)
12:46:04 <ericlavigne> @src readFile
12:46:04 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
12:46:20 <MyCatVerbs> ericlavigne: presumably the solution w.r.t. file descriptors would be to have Haskell's wrapper for open(2) trigger garbage collection whenever it gets given EMFILE in errno.
12:46:24 <ericlavigne> Here is an example of a library function that relies on a Handle getting GCed.
12:46:29 <joelr1> my macports ghc has been building for almost 6 hours now. this is on a 2.16Ghz Core Duo MBP with 2Gb of memory.
12:46:42 <ericlavigne> MyCatVerbs: Yes, exactly.
12:46:47 <joelr1> granted, i've been downloading stuff and watching a movie for part of that time but it's still very surprising
12:46:52 <mauke> ericlavigne: actually, doesn't hGetContents close the file if it reaches the end?
12:47:03 <Philippa_> ericlavigne: it doesn't actually. It relies on either that /or/ the consumer demanding the entire file
12:47:10 <ericlavigne> mauke: I don't think it can, due to laziness.
12:47:22 <byorgey> joelr1: ghc takes A Very Long Time to build.
12:47:24 <mauke> if it can read, then it can close
12:47:31 <MyCatVerbs> joelr1: indeed that is. I've seen 6.6-vanilla build itself (using ghc-5.0.something as the compiler) within about 24 hours on a 1.3GHz Duron w/256 megs.
12:47:56 <ericlavigne> @src hGetContents
12:47:56 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
12:47:57 <joelr1> byorgey: i know, i have done it a number of times. leaving it overnight on my powerbook even. still, didn't expect 6 hours.
12:48:03 <MyCatVerbs> mauke: yes it does, but you might not actually read the whole file in practice. Lazy evaluation FTW.
12:48:04 <SamB_XP> ericlavigne: the laziness is finished with when it reaches the end
12:48:07 <ericlavigne> @src System.IO.hGetContents
12:48:07 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
12:48:15 <Zao> ghc 6.6.1 built in five hours or so on an 400MHz sparcv9 here.
12:48:45 <ericlavigne> hGetContents returns a string that might not actually exist yet (and probably doesn't)
12:48:48 <Philippa_> ericlavigne: you can assume it's more or less a builtin. It doesn't really matter if there's a further layer of implementation you can see or not
12:49:12 <joelr1> i know it's the libraries and everything but still... ocaml builds in just a few minutes.
12:49:38 <ericlavigne> Philippa_: Yes, I will do so. In fact, I'll also not use hClose in my own libraries/programs until it causes a problem :-D
12:49:39 <joelr1> it's staging now so pretty much 6 hours
12:50:00 <ericlavigne> Philippa_: at which point I'll look into how to fix it at the source. It's fun to poke around in compilers.
12:50:35 <Philippa_> ericlavigne: the obvious thing is to either demand the lot straight up or use strict IO
12:51:12 <ericlavigne> Philippa_: Laziness has a significant performance advantage for large files. No need to give that up.
12:51:23 <newsham> funmath has this cool thing where they define   f +^ g = \x -> f x + g x    (where +^ is plus with a hat on it)
12:52:03 <newsham> for any binary operator +.  also they have things where you can do    f +(leftarrow) 3 to be \x -> f x + 3
12:52:06 <newsham> or right arrow for the other way
12:52:17 <byorgey> newsham: in haskell +^ is liftM2 (+)  =)
12:52:20 <newsham> it would be cool if we could use notation like that to lift functions in haskell
12:52:31 <newsham> imagine how much smaller monadic code would look
12:52:32 <mauke> my (+) is autolifted
12:52:44 <byorgey> mauke: how does that work?
12:53:02 <newsham> basically the equiv of   f `liftM (+)` g
12:53:04 <mauke> instance (Num a, Applicative f, Eq (f a), Show (f a)) => Num (f a) where ...
12:53:08 <newsham> which isnt legal :(
12:53:13 <Philippa_> ericlavigne: sure. But it's awfully hard to make it completely safe
12:53:14 <newsham> er liftM2 :)
12:53:25 <mauke>     (+) = liftA2 (+)
12:53:36 <mauke>     fromInteger = pure . fromInteger
12:53:39 <byorgey> mauke: ah, I see. neat.
12:53:47 <mauke> so f + 3 does indeed work
12:53:49 <Philippa_> for example, you can try branding the string with a type parameter in the same way as STRefs - but then you can't cast it to String or ByteString or similar without either copying the whole thing (thus forcing it all) or breaking the intended safe semantics
12:53:52 <newsham> mauke: but you cant put a hat over an arbitrary function
12:54:04 <mauke> hats don't scale
12:54:20 <newsham> not sure I understand the f + 3 with liftA2.
12:54:26 <newsham> ?type liftA2
12:54:32 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:54:55 <ericlavigne> Philippa_: GHC already garbage collects handles, closing them as necessary. That means that the safety side has already been addressed. I only want to trigger additional garbage collection events.
12:55:13 <mauke> :t \f -> liftA2 (+) f (pure 3)
12:55:14 <newsham> mauke: one thing i like about the hats is that its explicit.  your trick seems pretty neat, but could also be confusing at times
12:55:15 <lambdabot>     Ambiguous occurrence `pure'
12:55:15 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
12:55:25 <Philippa_> ericlavigne: I think there's an IO action somewhere does that
12:55:30 <newsham> oh, fromInteger = pure . fromInteger.   hrmmm
12:55:32 <newsham> interesting
12:55:40 <newsham> indeed quite a neat trick
12:55:54 <newsham> mauke: so does that let you use + in monadic computations?
12:56:01 <mauke> yes
12:56:05 <newsham> nifty
12:56:07 <Philippa_> wasn't aware that it definitely GCs handles adequately if the file's not finished though - clearing everything when the process ends doesn't count
12:56:23 <ericlavigne> Philippa_: Excellent. Then the next step is to change the source of hOpen to invoke that action.
12:56:39 <SamB_XP> Philippa_: I don't think there are any guarentees about when the process ends anyway
12:56:52 <Philippa_> SamB_XP: often the OS gives you them
12:56:54 <ericlavigne> Philippa_: See the manual entry for Handle.
12:57:07 <SamB_XP> well, I meant, I don't think you get any guarentees from the GC
12:57:15 <SamB_XP> about that
12:57:18 <ericlavigne> GHC note: a Handle will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable. If possible, use explicit an explicit hClose to close Handles when they are no longer required. GHC does not currently attempt to free up file descriptors when they have run out, it is your responsibilit
12:57:18 <ericlavigne> y to ensure that this doesn't happen.
12:57:58 <ericlavigne> This is an excerpt from the GHC docs on Debian.
12:58:05 <ericlavigne> System.IO.Handle
12:58:23 <Philippa_> yeah, read it. I wouldn't want to rely on it, and I definitely wouldn't rely on it porting to other implementations
12:58:43 <Philippa_> also, it's worth remembering that the GC isn't always as safe as you might expect: memory leaks do happen
12:59:09 <mgsloan> is it possible to have a monad, similar to state perhaps, with a command like 'break', which exits execution?  it would be similar to a 'yield' in other languages, in that execution would later be continued.  It may be related to continuations.
12:59:24 <sorear> yes, it's Cont
12:59:29 <ericlavigne> Philippa_: memory leaks due to errors in GHC runtime, or due to user error?
12:59:40 <mgsloan> sorear - excellent
12:59:40 <chessguy> @src Cont
12:59:41 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
13:00:07 <sorear> > let yield = Cont . (:) in runCont (do { mapM yield [1..10] }) id
13:00:07 <lambdabot>  Couldn't match expected type `a -> r' against inferred type `[a1]'
13:00:58 <mgsloan> > let yield = Cont . (: ) in runCont (do { mapM_ yield [1..10] }) id
13:00:59 <lambdabot>  Couldn't match expected type `a -> r' against inferred type `[a1]'
13:01:05 <sorear> > let yield = Cont . (.) . (:) in runCont (do { mapM yield [1..10] }) id
13:01:06 <lambdabot>  Couldn't match expected type `[a]'
13:01:22 <sorear> > let yield x = Cont (\c -> x : c ()) in runCont (do { mapM yield [1..10] }) id
13:01:23 <lambdabot>   add an instance declaration for (Num ())
13:01:23 <lambdabot>     In the expression: 10
13:02:02 <sorear> @ty \x -> Cont (\c -> x : c())
13:02:04 <lambdabot> forall a. a -> Cont [a] ()
13:02:05 <mgsloan> well, I actually don't need to yield values (except, I guess, the state), so that makes it easier
13:02:15 <Philippa_> <ericlavigne> Philippa_: memory leaks due to errors in GHC runtime, or due to user error? <- user error
13:02:30 <sorear> :t runCont
13:02:31 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
13:02:47 <sorear> > let yield x = Cont (\c -> x : c ()) in runCont (do { mapM_ yield [1..10] }) (\_ -> [])
13:02:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:02:50 <Philippa_> I've encountered a leak in the RTS before, but it was a fair while ago and it got fixed
13:02:52 <sorear> there
13:02:54 <sorear> finally
13:03:15 <mgsloan> cool
13:03:26 <ericlavigne> Philippa_: If my errors lead to a quick crash, rather than gradual degredation, that means they get fixed faster. Just like I prefer to get type errors at compile time rather than run time.
13:04:03 <Philippa_> hah. Who said it's quick? You don't know how many FDs you've got to burn through
13:05:13 <MyCatVerbs> Thirty-two thousand, depending on your OS. :)
13:05:44 <MyCatVerbs> Alternatively, change the user resource limits on a subshell so that only a few dozen FDs are available to the program.
13:05:48 <pejo> MyCatVerbs, it's usually lower than that, per process.
13:06:07 <pejo> Think you usually end up with trouble with merely 10k fd's.
13:06:57 <MyCatVerbs> pejo: ah. Well, safer to test with ulimit set down to fourty or so anyway.
13:07:32 <ericlavigne> Those are still quite high numbers. I'm more concerned about the earlier statement that FDs might not get closed when the program ends.
13:08:05 <pejo> http://www.kegel.com/c10k.html
13:08:05 <ericlavigne> I recall hearing that Windows doesn't take care of that, and I would want to check whether the GHC runtime does.
13:08:06 <lambdabot> Title: The C10K problem
13:08:45 <pejo> ericlavigne, the OS cleans it up when the process dies normally.
13:09:03 <sorear> on foonices, ALL process resources are cleaned up on do_exit
13:09:30 <MyCatVerbs> ericlavigne: if the OS doesn't clean up after you on exit(2), then it's not your fault. (Excluding temp files, of course.)
13:09:33 <ericlavigne> pejo: so it's the OS's job... doe all of *nix, mac, and windows do this job?
13:09:40 <allbery_b> just remember that some things aren't process resources.  (ipc foo, mostly)
13:09:49 <Philippa_> MyCatVerbs: haskell is portable beyond POSIX systems, it's worth remembering that
13:09:52 <allbery_b> unix and osx do
13:10:10 <ericlavigne> I suppose I can test this easily enough on my windows box.
13:10:13 <Philippa_> allbery_b: redundant mention of OS X there
13:10:15 <allbery_b> windows has been known to have issues in this area although I'd think the NT-based line would be smarter abbout it
13:10:20 <Philippa_> ericlavigne: *which* windows?
13:10:26 <Philippa_> yeah, the 9x line didn't even clean memory up
13:11:00 * mgsloan thinks he needs to learn monad transformers
13:11:08 <allbery_b> Philippa_: I'd say the question was redundant; I mean, who runs MacOS<10 any more?
13:11:12 <ericlavigne> Philippa_: So 95,98 don't but 2k, xp, Me, Vista do?
13:11:24 * sorear thinks ericlavigne shouldn't waste his life working around windows bugs
13:11:29 <allbery_b> ME was somewhere in between (and bufggy on top of it)
13:11:36 <Philippa_> ME was a 9x
13:11:43 <allbery_b> 9x with win2k-beta drivers
13:11:45 <Philippa_> ericlavigne: I'll have to suggest you RTFM there
13:12:04 * Philippa_ thinks sorear should be careful about what he labels a bug
13:12:39 <ericlavigne> Philippa_: I'll just run a quick test and stop on XP and let the issue go.
13:12:43 <Philippa_> there are an awful lot of crap things about windows systems past and present that aren't actually bugs per se
13:13:11 <EvilTerran> if it's defined to work that way, it can be crap and yet not a bug
13:13:36 <Philippa_> exactly. See 9x and resource management (and it took macs longer to sort out)
13:15:16 <EvilTerran> it's not a bug, it's an un^H^Hdocumented feature!
13:17:08 <allbery_b> resouece management is hard when programs all run in a single resource pool
13:17:33 <mauke> everybody out of the resource pool!!
13:17:40 <mgsloan> I should probably figure it out myself... but which would make more sense, ContT and State or StateT and Cont?
13:17:48 * Philippa_ has a thought
13:17:53 <EvilTerran> needs to be properly chlorinated ;)
13:18:13 <Philippa_> where should I send feature requests for things like ByteString?
13:18:19 <EvilTerran> mgsloan, depends if you want the state to be stored as a component of the continuation, as it were
13:18:32 <mgsloan> ah, yes, I think I do
13:18:44 <mgsloan> so ContT and State it is
13:18:48 <EvilTerran> not sure which way round each is, though
13:18:52 <mgsloan> oh
13:19:05 <EvilTerran> should be pretty easy to test
13:19:08 <allbery_b> Philippa_: ghc folks as a libraries "bug"?
13:19:20 <byorgey> Philippa_: too bad you had your idea just when the Hackathon is over, if you'd had it a couple days ago you might have gotten instant turnaround =)
13:20:32 <olsner> apparently, you'll do best in sending them two days back in time ;-)
13:20:52 <xerox> mgsloan: just unmtl the combined types and see which makes sense.
13:21:01 <EvilTerran> ah, you want the MonadFix instance of IO for that, then, olsner ;)
13:21:26 <EvilTerran> @unmtl StateT s (Cont a)
13:21:26 <lambdabot> err: Unknown MTL(1)
13:21:50 <EvilTerran> @unmtl StateT s Cont a
13:21:51 <lambdabot> s -> Cont (a, s)
13:21:57 <EvilTerran> @unmtl ContT (State s) a
13:21:58 <lambdabot> err: Unknown MTL(1)
13:22:23 <EvilTerran> @unmtl ContT r (State s) a
13:22:23 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
13:22:52 <mgsloan> hmm
13:23:59 <mgsloan> I think that may be the one that makes sense (the last one)
13:27:33 <madnificent> hmmm, is anybody on gentoo here with the haskell-overlay... it's being a real pita for the moment
13:30:49 <gour> madnificent: #gentoo-haskell ?
13:33:01 <therp> is there a trick to get "CUInt" from "Word32" when using the #type macro in ghc's hsc2cs?
13:34:08 <therp> or am I supposed to use Word32 in the type signature of foreign bindings, I don't think so, no?
13:46:06 <therp> it looks like this just don't work. I wonder whether this #type directive makes sense at all then
13:47:31 <EvilTerran> have you seen c2hs? it's rather more featureful
13:47:43 <therp> haven't tried that no
13:48:25 <EvilTerran> if you want to coerce between those types, i think fromIntegral would work, but i think you have to do it manually with hsc2hs
13:48:30 <EvilTerran> @type fromIntegral
13:48:32 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:48:47 <EvilTerran> @instances-importing Foreign.C CUInt
13:48:48 <lambdabot> Couldn't find class `CUInt'. Try @instances-importing
13:48:59 <EvilTerran> ...
13:49:09 <EvilTerran> @instances-importing Foreign.C Num
13:49:10 <lambdabot> CChar, CClock, CDouble, CFloat, CInt, CIntMax, CIntPtr, CLDouble, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CTime, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort,
13:49:10 <lambdabot> CWchar, Double, Float, Int, Integer
13:49:14 <EvilTerran> @instances-importing Foreign.C Integral
13:49:15 <lambdabot> CChar, CInt, CIntMax, CIntPtr, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort, CWchar, Int, Integer
13:49:26 <EvilTerran> @instances-importing Data.Word Integral
13:49:27 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
13:49:36 <EvilTerran> ah, there we go. so fromIntegral would work.
13:50:12 <mauke> toEnum . fromEnum  -- ULTIMATE
13:50:50 <EvilTerran> betweenum!
14:22:35 <vincenz> bringert: ping
14:22:44 <bringert> hi
14:22:53 <vincenz> hey, I cleaned up that system :)
14:23:00 <vincenz> that two-continuation system is now a clean monoid
14:23:08 <vincenz> let me fetch some example code
14:23:23 <vincenz> @paste
14:23:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:23:41 <hpaste>  vincenz pasted "Bimonad" at http://hpaste.org/3139
14:23:44 <vincenz> there you go
14:23:49 <vincenz> check out foo''
14:23:52 <vincenz> it's in order, no double traversal
14:24:06 <vincenz> so you'd do
14:24:22 <vincenz> runBimonad (checkDeps t) Left Right
14:24:23 <vincenz> and then
14:24:34 <vincenz> checkDeps deps = foldr (mappend . handle1) mempty deps
14:24:46 <vincenz> where handle1 handles 1 case
14:25:24 <vincenz> anyone know why you can not use (->) as toplevel tyconst on instance definitions?
14:29:01 <twanvl_> what do you mean? there are instances that use (->), like the environment monad
14:29:27 <vincenz> I received an error message
14:29:39 <vincenz> and needed FlexibleContexts
14:29:52 <vincenz> (until I wrapped it in a newtype
14:30:02 <vincenz> monoids are spiffy, monoids should have more functions that depend on monoids
14:30:03 <vincenz> I mean
14:30:13 <vincenz> forall Monad m => instance Monoid (m ()
14:30:21 <vincenz> forall Monad m => instance Monoid (a -> m a)
14:30:26 <vincenz> forall Monad m => instance Monoid (a -> a)
14:30:38 <Japsu> betweenum
14:30:39 <Japsu> lol
14:30:40 <vincenz> erm, scratch the context on the last one
14:30:49 <vincenz> betweenum?
14:32:24 <twanvl_> For the last two you need FlexibleInstances
14:33:15 <vincenz> you mean contexts?
14:33:18 <allbery_b> <mauke> toEnum . fromEnum  -- ULTIMATE
14:33:18 <allbery_b> <EvilTerran> betweenum!
14:33:42 <dons> ?yow!
14:33:42 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
14:33:50 <twanvl_> no, I mean instances
14:33:52 <dons> ?quit bots are dumbos
14:35:22 <twanvl_> the contexts are all simple, (Monad m), but the instance head is not of the form (C a b)
14:35:52 <EvilTerran> instance Monoid ((->) a (m a)), say, might work
14:35:52 <vincenz> the name for it is flexiblecontexts tho
14:36:11 <LoganCapaldo> My instance of a different form
14:37:06 <twanvl_> compare http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleInstances with http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleContexts
14:37:09 <lambdabot> Title: FlexibleInstances - Haskell Prime - Trac, http://tinyurl.com/yrzrj5
14:38:39 <ramza3> anybody see why I am getting a stack overflow in this code; http://hpaste.org/3133
14:39:39 <dons> gee that was a great hackathon
14:39:42 <dons> we got so much done.
14:39:48 <dons> you guys should get to any hackathon you can!
14:40:04 * vincenz hardly got anything done
14:40:25 <dons> vincenz: you're not back home are you?
14:40:28 <dons> oh, i guess you might well be!
14:40:37 <vincenz> I am
14:40:47 <dons> crazy europe
14:40:49 <vincenz> :)
14:41:06 <dons> i should move here so i can go to more hackathons
14:41:36 <kosmikus> :)
14:42:25 <dons> heya kosmikus
14:42:35 <dons> blog posts about the hackathon, here http://cgi.cse.unsw.edu.au/~dons/blog/2007/10/07#hac07-2-day3
14:42:36 <lambdabot> Title: Haskell hacking
14:42:48 <vincenz> dons: still there?
14:42:52 <thoughtpolice> woot. data.binary is awesome. :)
14:42:58 <dons> more here, http://www.haskell.org/haskellwiki/Hac_2007_II#Photos_and_blogs
14:43:00 <lambdabot> Title: Hac 2007 II - HaskellWiki
14:43:04 <dons> vincenz: in frankfurt overnight
14:43:11 <vincenz> me nods
14:43:26 <dons> thoughtpolice: oh? you'd not seen it before?
14:43:31 <dons> it is awesome, i grant you.
14:44:22 <kosmikus> dons: you're so modest ;)
14:44:41 <dons> hey, the binary strike force is the awesomest team of hackers!
14:44:41 <thoughtpolice> dons: seen it, but never used it. i'm using it so plugins in the new version of my bot can save values to disk. :)
14:44:50 <dons> thoughtpolice: oh, sweet. perfect for that
14:44:53 <thoughtpolice> also saw the ann on binary 0.4, sweet stuff. :)
14:44:58 <dons> and stick a zlib call on the end, its very cute
14:45:18 <dons> wrteiFile "foo" . compress . encode
14:46:02 <waern> I love the title of one of this blog post: http://www.xaprb.com/blog/2006/10/05/five-great-perl-programming-techniques-to-make-your-life-fun-again/
14:46:04 <lambdabot> Title: Five great Perl programming techniques to make your life fun again at Xaprb, http://tinyurl.com/33ufex
14:46:07 <waern> -one
14:46:09 <thoughtpolice> while i'm at it i'm also having fun using monad transformers for plugins so you can expose 'non-harmful' functions and not expose the stack of monads you're using.
14:46:20 <thoughtpolice> it seems to be working out really nicely.
14:46:31 <dons> kosmikus: the hackathon was lots of fun. i'm quite buzzed now -- icfp and cufp too: there's a real optimism around
14:47:07 <kosmikus> dons: yes, I felt that too. it's nice to be optimistic once in a while ...
14:47:59 <fnord123> even though C++ and Perl came out on top? :P
14:48:25 <dons> kosmikus: yeah, i think we finally decided we can try to succeed, rather than avoiding it :)
14:54:33 <Koenix> can someone explain me why truncate . sqrt 99 doesn't work ?
14:55:02 <oerjan> :t truncate
14:55:05 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:55:08 <kosmikus> fnord123: I feel guilty.
14:55:19 <oerjan> Koenix: $, not .
14:55:53 <oerjan> > (truncate . sqrt) 99 -- or this
14:55:54 <lambdabot>  9
14:56:12 <Koenix> what's the difference between . and $ :( ?
14:56:16 <EvilTerran> ?type ($)
14:56:17 <EvilTerran> ?type (.)
14:56:18 <lambdabot> forall a b. (a -> b) -> a -> b
14:56:19 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:56:23 <Koenix> oh cool
14:56:27 <Koenix> thank you :)
14:57:23 <EvilTerran> f $ g x = (f . g) x = f (g x) /= f . g x
14:58:30 <ramza3> I am having trouble importing modules into Prelude (ghc), eg, :add Data.IORef  is a package module error?
14:58:32 <chessguy> @type ?f $ ?g ?x
14:58:34 <lambdabot> forall a b t. (?f::a -> b, ?g::t -> a, ?x::t) => b
14:58:38 <chessguy> @type ?f . ?g ?x
14:58:39 <lambdabot> forall b c t a. (?f::b -> c, ?g::t -> a -> b, ?x::t) => a -> c
14:59:34 <sjanssen> ramza3: :m + Data.IORef
15:00:28 <ramza3> oh
15:01:06 <ramza3> set the context for expression evaluation ... in the help didnt ring a bell for me
15:01:10 <sjanssen> use :m + for package modules, :add for your own code
15:03:05 * twifkak is away: burrito! burrito! tamale burrito! (pondering testing in the X monad)
15:03:40 <oerjan> the X monad supports burritos?
15:04:10 <twifkak> soon, my little one, soon....
15:09:32 <fnord123> I can imagine qwe1234 on proggit will love the C++ ammunition.
15:13:04 <MyCatVerbs> proggit?
15:13:22 <shachaf> MyCatVerbs: programming.reddit.com, I'd guess.
15:14:13 <Koenix> Can someone explain me what's wrong with let n = 19 in [x | x <- [2..truncate $ sqrt n], mod n x == 2] ?
15:14:45 <Koenix> I've got an "ERROR - Unresolved overloading", but I don't what is is
15:14:49 <Koenix> it is*
15:14:57 <Saizan_> ?type  let n = 19 in [x | x <- [2..truncate $ sqrt n], mod n x == 2]
15:14:59 <lambdabot> forall b. (Floating b, Integral b, RealFrac b) => [b]
15:15:39 <mauke> Koenix: mod requires an integral, sqrt a fractional number
15:15:57 <Saizan_> ?type  let n = 19 in [x | x <- [2..truncate . sqrt . fromIntegral $ n], mod n x == 2]
15:15:58 <lambdabot> forall b. (Integral b) => [b]
15:16:06 <hpaste>  ramza3 pasted "why stack space overflow at writeIORef?" at http://hpaste.org/3140
15:16:09 <Saizan_> > let n = 19 in [x | x <- [2..truncate . sqrt . fromIntegral $ n], mod n x == 2]
15:16:10 <lambdabot>  []
15:16:40 <DRMacIver> Hm. If I unpack a LazyByteString and do a foldl' over the result, is that likely to get fused?
15:17:10 <DRMacIver> (Err, or I suppose I could just fold over the ByteString)
15:18:17 <oerjan> indeed, although it would be nice if it fused such things when you want to use a function already defined on lists
15:19:04 <Koenix> mauke, I don't undestand, when I try sqrt 19 in hugs it works perfectly, and 19 is an Int isn't it ? 19 `mod` 2 works as well. So why shouldn't it work in the list comprehension ? Am I totally wrong ?
15:19:11 <Saizan_> ramza3: is rotateMech tail recursive?
15:19:18 <mauke> Koenix: no, 19 is not an int
15:19:19 <shachaf> Koenix: 19 isn't Int.
15:19:20 <shachaf> @ty 19
15:19:22 <lambdabot> forall t. (Num t) => t
15:19:43 <shachaf> @wiki Monomorphism restriction
15:19:44 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:19:48 <shachaf> That may also be helpful.
15:19:50 <idnar> :t let n = 19 in sqrt n
15:19:52 <lambdabot> forall t. (Floating t) => t
15:19:53 <Saizan_> Koenix: numeric literals are polymorphic, so they get instantiated to different types depending on the context
15:19:54 <Koenix> Oh a I have to learn all these, so far I just know Int, Float, Char, String ... :(
15:20:01 <idnar> :t let n = 19 in n `mod` 2
15:20:02 <lambdabot> forall t. (Integral t) => t
15:20:07 <shachaf> > let n :: (Num a) => a; n = 19 in [x | x <- [2..truncate $ sqrt n], n `mod` x == 2]
15:20:09 <lambdabot>  []
15:20:09 <mauke> Koenix: forget Float, learn Double instead
15:20:19 <ramza3> Saizan_, I will show the code,
15:20:26 <Philippa> mauke: not quite a universally good idea
15:20:40 <shachaf> Koenix: When you say "x = 19", x default to being an Integer.
15:20:40 <Philippa> and really? Use a type synonym
15:21:02 <hpaste>  ramza3 pasted "rotate mech code" at http://hpaste.org/3141
15:21:10 <shachaf> s/default/defaults/
15:21:11 <LoganCapaldo>     rotate mech code?
15:21:12 <ramza3> Saizan_, http://hpaste.org/3141
15:21:26 <LoganCapaldo> is ramza3 building a mecha powered by Haskell?
15:21:36 <abell> Hi, everybody. Probably someone will be able to help me with a little doubt I have.
15:21:47 <shachaf> Koenix: Unless you give it an explicit type signature, and then it's polymorphic.
15:21:57 <ramza3> LoganCapaldo, trying to rewrite this game in haskell http://glants.sourceforge.net/
15:21:58 <lambdabot> Title: glAnts - an open source mech game and souce
15:22:04 <shachaf> Koenix: (Or use something like -fno-monomorphism-restriction.)
15:22:11 <abell> Say I have an operator .|. which does the obvious thing in
15:22:12 <abell> (.|.) :: ( a -> b1 ) -> ( a -> b2 ) -> ( a -> ( b1, b2 ) )
15:22:23 <shachaf> @ty (.|.)
15:22:25 <lambdabot> forall a. (Bits a) => a -> a -> a
15:22:30 <abell> So that f1 .|. f2 .|. f3 .|. ... .|. f10 is
15:22:31 <abell> a -> ( b1, ( b2, ( ... ( b9, b10 ) ) ... ) )
15:22:39 <oerjan> abell: that's &&& from Control.Arrow
15:22:45 <oerjan> :t (&&&)
15:22:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:22:58 <oerjan> (when a = (->)
15:23:10 <Koenix> shachaf, I've never heard about these, I have to read tutorials on polymorphism
15:23:14 <abell> Nice. Thanks.
15:23:23 <abell> How would you change things so that the result is
15:23:24 <abell> a -> ( b1, b2, b3, ..., b10 )
15:23:34 <shachaf> Koenix: It just means that when you use "x = 19", x has to be a specific type.
15:23:38 <LoganCapaldo> abell you can't in general.
15:23:41 <abell> So that all the couples are "flattened"?
15:23:52 <LoganCapaldo> I take that back
15:23:55 <shachaf> Koenix: Unless you say otherwise explicitly.
15:24:07 <Koenix> shachaf, well I have a function an the argument n is an Int
15:24:10 <LoganCapaldo> maybe you can with somekind of super lax type class hackery
15:24:12 <Japsu> a :: forall a. a?
15:24:22 <Koenix> shachaf, but is seems that sqrt wants a Float
15:24:23 <oerjan> abell: in that case you can use the -> monad
15:24:26 <shachaf> abell: (a,b,c) is a different type.
15:24:34 <Japsu> @type undefined
15:24:36 <lambdabot> forall a. a
15:24:38 <shachaf> Koenix: For one, you should probably be using Integer, not Int.
15:24:39 <oerjan> :t liftM3 (,,)
15:24:41 <lambdabot> forall a1 a2 a3 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a3 -> m (a1, a2, a3)
15:24:54 <shachaf> Koenix: And Double, not Float, as Philippa said.
15:25:02 <oerjan> although it's not defined all the way to liftM10
15:25:08 <shachaf> Koenix: You can use fromIntegral to convert from an Int/Integer to any Num.
15:25:09 <abell> Could you define some two-parameter class?
15:25:52 <Philippa> shachaf: for games it's often the case that you really do want to use floats
15:26:17 <LoganCapaldo> Besides, whatever Doubles your boat doesn't work
15:26:25 <Philippa> you will for much of the rendering pipeline, for example
15:26:44 <Koenix> shachaf, Integers aren't they numbers of any size ? I must restrict these on a bound
15:26:48 <shachaf> Philippa: Yes, but as long as you're learning about Haskell types, you might as well use Double. :-)
15:29:52 <shachaf> Koenix: What do you mean?
15:30:09 <oerjan> abell: i think it's been done several times, but it's not considered useful enough to go into the standard libraries i think
15:30:45 <oerjan> since usually if you want much more than a pair, you want to define your own data type
15:30:52 <abell> oerjan: would the liftMx f1 f2 ... fx be the solution I am looking for?
15:31:13 <oerjan> abell: note that you need to include (,,,,,) first
15:31:35 <oerjan> also, if you need more than the predefined liftM*'s you can use ap instead:
15:32:12 <shachaf> abell: liftMn f x1 x2 ... xn, I think.
15:32:34 <shachaf> oerjan: You might as well use (<$>) and (<*>).
15:32:38 <oerjan> :t (,,,) `liftM` ?f1 `ap` ?f2 `ap` ?f3 `ap` ?f4
15:32:46 <lambdabot> forall a1 a a11 a2 (m :: * -> *). (?f1::m a1, ?f2::m a, ?f3::m a11, ?f4::m a2, Monad m) => m (a1, a, a11, a2)
15:32:55 <oerjan> shachaf: right
15:32:56 <shachaf> Oh, never mind.
15:33:25 <shachaf> @ty (,,,) <$> ?f1 <*> ?f2 <*> ?f3 <*> ?f4
15:33:26 <abell> Thank you, guys. I have enough to keep me thinking for the next two weeks :-)
15:33:27 <lambdabot> forall a a1 a2 a3 (f :: * -> *). (?f1::f a, ?f2::f a1, ?f3::f a2, ?f4::f a3, Applicative f) => f (a, a1, a2, a3)
15:33:37 <Koenix> shachaf, It's ok. I can use Integer and so use fromInteger but I can also with Int, use fromInt. (I know with Integer it's better)
15:33:48 <oerjan> shachaf: Applicative (->) may not be predefined?
15:33:51 <shachaf> Koenix: Use fromIntegral.
15:34:05 <shachaf> oerjan: It is for me.
15:34:49 <oerjan> :t (+) <*> succ
15:34:51 <lambdabot> forall a. (Num a, Enum a) => a -> a
15:34:59 <Koenix> shachaf, ah nice fromIntegral works on both Int and Integer ?
15:34:59 <oerjan> hm, seems to be
15:35:09 <mauke> yes
15:35:17 <shachaf> Koenix: It works on any Integral. :-)
15:35:20 <shachaf> @instances Integral
15:35:21 <lambdabot> Int, Integer
15:35:30 <Koenix> nice :)
15:36:29 <Koenix> is there "a paper" on the types in Haskell, besides prelude.hs ?
15:36:30 <oerjan> @instances-importing Data.Word Data.Bits Integral
15:36:31 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
15:37:03 <oerjan> @instances-importing Data.Word Data.Bits Data.Int Integral
15:37:04 <lambdabot> Int, Int16, Int32, Int64, Int8, Integer, Word, Word16, Word32, Word64, Word8
15:37:16 <abell> One last question: where are <*> and <$> defined? Can't find them on hoogle...
15:37:25 <Japsu> @index (<*>)
15:37:25 <lambdabot> bzzt
15:37:26 <sjanssen> abell: Control.Applicative
15:37:35 <oerjan> abell: hoogle is buggy on some characters
15:38:14 <hpaste>  nuncanada pasted "Why doesnt type check?" at http://hpaste.org/3142
15:38:23 <oerjan> seems to mix in some wildchar characters
15:38:30 <oerjan> *wildcard
15:38:36 <TSC> nuncanada: Your numbers need "Just"
15:38:44 <nuncanada> ahhh
15:38:45 <nuncanada> thanks
15:38:47 <TSC> [Just 2, Just 8, etc]
15:38:55 <nuncanada> 2 years since i delved into Haskell
15:39:01 <nuncanada> forgot everything
15:39:26 <abell> Thanks again. Quite a productive first visit. I will hang around in the future :-)
15:40:06 <Zao> map Just [2,8,3]
15:40:10 <Zao> To save typing :)
15:40:33 <Zao> Although the Nothing trips that up.
15:40:43 <shachaf> nuncanada: Also, do you mean "type" instead of "data"?
15:41:05 <nuncanada> yep yep
15:41:08 <nuncanada> that made it
15:41:15 <shachaf> nuncanada: Also, since it's just a single value (or Nothing), you could call it "Value", maybe.
15:41:32 <ramza3> nuncanada, I guess programming isn't like riding a bike
15:41:44 <nuncanada> thanks a lot both of you.
15:42:37 <nuncanada> ramza3, seems like not... I guess how well i am doing in TCL nowadays, it has been more than 10 years :)
16:03:19 <jaj> man, the learning curve for haskell is tough
16:04:01 <Philippa> it is early on, yeah
16:04:17 <Philippa> once it starts to click, it might look tough - until you realise how much power you're gaining as you go
16:05:14 <ramza3> jaj: how long have you been developing with it
16:05:50 <Spark> part of the reason it's tough is that people insist on explaining things in terms of abstract mathematical concepts instead of programming concepts
16:05:55 <jaj> ramza3, not at all, I'm just beginning to learn it
16:06:05 <jaj> I've been playing around with it for 2 weeks
16:07:22 <jaj> I've been able to make it generate an infinite list of lines of pascal's triangle, that was a real success :)
16:08:14 <jaj> I think the wikibook is a very good beginner guide
16:09:07 <omnId> @where yaht
16:09:08 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
16:09:12 <omnId> ^^ that's also recommended if you've not read it.
16:09:56 <shachaf> omnId: Is "oI" next?
16:10:06 <Botje> > iterate (\x -> 1:(zipWith (+) x (tail x))) [1]
16:10:08 <lambdabot>  [[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1]...
16:10:15 <Botje> > iterate (\x -> 1:(zipWith (+) x (tail x))) [1,1]
16:10:16 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[1,11],[1,12],...
16:10:21 <omnId> shachaf: you know it :)
16:10:23 <Botje> pah.
16:10:45 <jaj> omnId, thanks!
16:11:28 <shachaf> > iterate (\x -> 1 : (zipWith (+) x (tail x)) ++ [1]) []
16:11:39 <shachaf> Botje: You forgot the 1 at the end.
16:11:41 <lambdabot>  [[],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[...
16:11:51 <Botje> foiled again!
16:11:56 <oerjan> > iterate (\x -> (zipWith (+) (0:x) (tail x))) [1]
16:11:57 <lambdabot>  Exception: Prelude.tail: empty list
16:11:57 <omnId> shachaf: pretty soon my nick'll collapse into nothing, then start going backwards!
16:12:04 <oerjan> bah
16:12:30 <oerjan> > iterate (\x -> (zipWith (+) (0:x) (x++[0]))) [1]
16:12:32 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
16:13:24 <jaj> http://hpaste.org/3143
16:13:34 <jaj> that's my primitive version :)
16:13:48 <oerjan> > iterate (liftM2 (zipWith (+)) (0:) (++[0]))) [1]
16:13:49 <lambdabot>  Unbalanced parenthesis
16:13:58 <oerjan> > iterate (liftM2 (zipWith (+)) (0:) (++[0])) [1]
16:14:00 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
16:14:11 <shachaf> > iterate ((1:) . (++[1]) . ap (zipWith (+)) tail) [1]
16:14:12 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
16:14:33 * oerjan _was_ trying to hold off but once someone else started it...
16:15:04 <shachaf> jaj: [f a b | (a,b) <- zip x] = zipWith f x
16:15:28 <omnId> shachaf: bah.  I was writing that exact comment.
16:15:57 <omnId> s/zip x/zip xs ys/ s/zipWith f x/zipWith f xs ys/
16:16:19 <shachaf> Of course.
16:16:27 <jaj> shachaf, thanks, that's useful
16:16:28 <shachaf> omnId: I meant to arguments by "x". :-)
16:16:35 <shachaf> jaj: Also, look at iterate:
16:16:36 <shachaf> @ty iterate
16:16:39 <lambdabot> forall a. (a -> a) -> a -> [a]
16:16:54 <omnId> > iterate (*2) 1
16:16:55 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:17:19 <jaj> the universe must be written in haskell
16:17:28 <omnId> = [1, (*2) 1, (*2) ((*2) 1), (*2) ((*2) ((*2) 1)), ...]
16:17:38 <shachaf> @let tpasline prevline = [1] ++ zipWith (+) prevline (tail prevline) ++ [1]
16:17:39 <omnId> @src iterate
16:17:45 <lambdabot> Defined.
16:17:45 <lambdabot> iterate f x =  x : iterate f (f x)
16:18:08 <shachaf> > let tpas = [1] : map tpasline tpas in tpas -- You can also use map.
16:18:09 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
16:18:50 <shachaf> Another way of writing iterate: iterate f x = let l = x : f l in l
16:18:51 <omnId> > fix (([1] :) . map tpasline)
16:18:53 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
16:19:06 <omnId> I thought it looked like a fix :)
16:19:25 <shachaf> omnId: That's the same thing. :-)
16:19:33 <mauke> :t let iterate f x = let l = x : f l in l in iterate
16:19:34 <lambdabot> forall a. ([a] -> [a]) -> a -> [a]
16:19:53 <omnId> not quite iterate
16:19:55 <shachaf> Hmm.
16:20:01 <shachaf> Oops.
16:20:04 <mauke> you can't datafix iterate
16:20:17 <shachaf> I meant map.
16:20:17 <jaj> it took me about an hour to figure out how to do that with a working function of the fibonacci sequence as an example and you give me 20 different versions in half a minute
16:20:23 <jaj> it's rather frustrating :)
16:20:29 <shachaf> @ty let iterate f x = let l = x : map f l in iterate
16:20:31 <lambdabot> <command line>:
16:20:31 <lambdabot>     Could not find module `L':
16:20:35 <omnId> @quote fluxbox
16:20:35 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
16:20:36 <lambdabot> for your entire program.")
16:20:43 <oerjan> jaj: oh, it's not the first time the problem has come up in the channel :)
16:20:52 <shachaf> @ty let iterate f x = let l = x : map f l in iterate
16:20:52 <lambdabot> <command line>:
16:20:52 <lambdabot>     Could not find module `L':
16:20:56 <shachaf> @undefine
16:20:58 <lambdabot> Undefined.
16:20:59 <shachaf> @ty let iterate f x = let l = x : map f l in iterate
16:21:01 <lambdabot> <command line>:
16:21:01 <lambdabot>     Could not find module `L':
16:21:12 <shachaf> Hmm.
16:21:14 <shachaf> > 1
16:21:15 <lambdabot>  1
16:21:17 <Pseudonym> :t let iterate f x = let l = x : map f l in iterate
16:21:19 <omnId> @ty let x = x in x
16:21:21 <lambdabot> forall t. t
16:21:21 <lambdabot> <command line>:
16:21:21 <lambdabot>     Could not find module `L':
16:21:46 <Pseudonym> @let myId = id
16:21:48 <lambdabot> Defined.
16:21:50 <Pseudonym> :t let iterate f x = let l = x : map f l in iterate
16:21:52 <lambdabot> <command line>:
16:21:52 <lambdabot>     Could not find module `L':
16:21:53 <shachaf> @ty let iterate f x = let l = x : map f l in l in iterate
16:21:55 <lambdabot> forall a. (a -> a) -> a -> [a]
16:22:03 <Pseudonym> OK.
16:22:07 <Pseudonym> Just needed a definition in L.
16:22:39 <oerjan> Pseudonym: um, no
16:22:46 <oerjan> there was an "in" to few
16:22:52 <omnId>  let { iterate f x = let { l = x : map f l in l } } in iterate
16:22:54 <oerjan> :t let iterate f x = let l = x : map f l in iterate
16:22:56 <lambdabot> <command line>:
16:22:56 <lambdabot>     Could not find module `L':
16:23:06 <omnId> er, oops
16:23:09 <shachaf> There are "in"s to be fewed, people!
16:23:14 <oerjan> though that is a strange error message for it
16:23:59 <jaj> just wondering: do you all have a PhD in math?
16:24:19 * omnId is a hobby coder
16:24:26 <Pseudonym> No, some of us are postdocs!
16:24:29 <Pseudonym> Just kidding.
16:24:33 <Pseudonym> Most don't have PhDs.
16:24:39 * Japsu is an undergraduate computer science student
16:24:51 <oerjan> sorear is just 16
16:25:05 <Pseudonym> I'm old enough to have a PhD, but I don't.
16:25:22 <Philippa> I'm old enough to have a PhD but never finished my Bachelor's
16:25:45 * platypus has a Bachelors in Comp.Sci.
16:25:49 <Pseudonym> We have a few of those, actually.
16:25:50 <jaj> :) I was just joking
16:25:54 <Pseudonym> Comp sci dropouts.
16:26:08 <Japsu> I know of one that had his PhD when he was 22 or 23, so "old enough to have a PhD" doesn't say much ;)
16:26:13 <Pseudonym> :-)
16:26:13 * Japsu is 20
16:26:15 <mux> > nubBy (\x y -> gcd x y > 1) [2..]
16:26:16 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:26:20 <sorear> Not only am I 16, but I'm in the normal school placement for my age (senior in high school)
16:26:21 <Pseudonym> Yeah, I know someone like that, too.
16:26:27 <jaj> but you have to think in so many levels of abstraction in Haskell
16:26:34 <jaj> it gives me headaches from time to time
16:26:41 <Philippa> you don't really
16:26:45 * sorear LOVES abstraction and hat games
16:26:54 <oerjan> hat games?
16:27:00 <Philippa> I mean, you have to be able to think at three levels at once to be really good with any language
16:27:03 <Pseudonym> jaj: While few have PhDs, pretty much everyone here (I can't think of any exceptions) is smart.
16:27:16 <Philippa> there's what you want to do, there's how the language makes you do it, and there's the effect it has on the system the language is implemented on top of
16:27:22 <Philippa> but that's /it/
16:27:40 <Pseudonym> The best languages insulate you from having to think too much.
16:28:06 <Pseudonym> Or, rather, allow you to be able to concentrate on something without having to be distracted by extraneous cruft.
16:28:25 <dibblego> ?check \f x -> fmap (f :: Int -> Int) (Left (x :: Int)) == Left x
16:28:26 <lambdabot>  OK, passed 500 tests.
16:28:27 <SamB_XP> yeah. I was just going to say, Haskell doesn't do a good job of what you said at all
16:28:49 <Philippa> I dunno, haskell does a real good job of insulating you from hardware concerns if that's what you want
16:28:57 <SamB_XP> in fact I'd say that haskell programmers do heavier thinking than any other kind of programmer I know...
16:29:30 <Nafai> SamB_XP: Maybe that's why I've yet to write a Haskell program :(
16:29:34 <olsner> some claim that while haskell makes you think harder, it makes you think less in total, or more concentrated on the actual problem
16:29:36 <platypus> Its not quite that due to the law of leaky abstractions.  Normally you have to have a pritty good idea about what is going on underneath to make good use of the higher leval abstractions.
16:29:43 <SamB_XP> Nafai: it's not that they have to
16:29:53 <xelxebar> how do you pattern match against the last character in a stright?
16:29:57 <SamB_XP> it's that you don't have to do so much other stuff
16:30:03 <mauke> xelxebar: you don't
16:30:04 <jaj> I somehow can't imagine writing low-level stuff in haskell. ghc must be running through black magic
16:30:18 <kpreid> xelxebar: you could match against the reverse of the string
16:30:20 <Pseudonym> Haskell does a good job of insulating you from almost everything.
16:30:21 <xelxebar> stright?.... uhhh, that should be 'string'
16:30:25 <SamB_XP> olsner: we certainly hope it's more concentrated on the problem
16:30:26 <Pseudonym> Including the existence of mutable state.
16:30:32 <mux> the Foreign modules show you how you can actually write very low-level stuff in Haskell very easily
16:30:46 <lament> by... not writing it in Haskell? :)
16:30:46 <mux> calling malloc, dealing with pointers
16:30:51 <Pseudonym> It depends what you mean by low-level", though.
16:30:52 <SamB_XP> jaj: you haven't read the right blog
16:30:56 <olsner> but then again, I think most haskell programmers like doing things that require more thinking, and like to do them in ways that require more thinking ;-)
16:30:56 <mux> except it's neater :-)
16:31:02 <Pseudonym> What's "low-level"?
16:31:09 <SamB_XP> @google things that amuse me haskell
16:31:11 <lambdabot> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
16:31:12 <lambdabot> Title: Things that amuse me
16:31:15 <mauke> jaj: http://mauke.ath.cx/tmp/inotify/System/Linux/INotify.hsc
16:31:29 <Pseudonym> I'd call the garbage collector low-level, but Unix system programming medium-level.
16:31:35 <lament> olsner: yes, like not stepping on any dividing lines in the pavement as you walk down the sidewalk :)
16:31:35 <Pseudonym> But perhaps that's just me.
16:31:41 <xelxebar> how would you match against the reverse of a string? foo (reverse s) doesn't work of course
16:31:57 <dibblego> xelxebar, case (reverse s) of ...
16:31:57 <SamB_XP> Pseudonym: how about kernel hacking? depends which part of the kernel?
16:32:02 <Pseudonym> Right.
16:32:09 * jaj imagines a memset monad...
16:32:14 <Pseudonym> I can certainly imagine writing part of the QNX executive in Haskell.
16:32:23 <mux> the terms low-level and high-level are more useful when used relative to something else
16:32:24 <xelxebar> ah, thanks, dibblego
16:32:27 <Pseudonym> Exactly.
16:32:39 <xelxebar> :) that should have been obvious
16:32:43 <SamB_XP> mux: well, we already mentioned several things
16:32:44 <olsner> yeah, I'd like to see functional programming applied to kernel programming
16:32:45 <oerjan> xelxebar: last may be better than reverse for you
16:32:46 <Pseudonym> Dave Parnas wrote a whole paper trying to deconstruct what "high-level" and "low-leve" mean.
16:32:55 <mux> olsner: I'm not sure it's ready yet
16:33:38 <mux> at least for haskell, it's hard to predict memory usage of some code, and that can be quite a showstopper for many parts of the kernel
16:33:39 <mauke> jaj: hmm. I can't find memset in the libs, but we have memcpy and memmove
16:33:41 <twifkak> olsner: http://programatica.cs.pdx.edu/House/
16:33:41 <lambdabot> Title: House
16:34:29 <mux> foreign import ccall "string.h memset" memset :: Ptr () -> CInt -> CSize -> Ptr ()
16:34:36 <mux> and here you are ;-)
16:34:41 <SamB_XP> @hoogle memcpy
16:34:41 <lambdabot> No matches found
16:34:42 <mux> oops, missing an "unsafe"
16:34:45 <SamB_XP> @hoogle memmove
16:34:45 <lambdabot> No matches found
16:34:48 <mauke> why not Ptr a?
16:34:55 <olsner> (but not just in the "look, i can put an interpreter in the boot loader!" sense, but rather applying powerful abstractions on kernel code that would otherwise be written in assembly or C)
16:35:09 <mux> Ptr a is fine, but the memset() functions wants void *
16:35:14 <mux> it can be castPtr
16:35:41 <mauke> does void * have a standard corresponding haskell type?
16:35:43 <SamB_XP> can you put an interpreter in the bootloader?
16:35:49 <SamB_XP> maybe for bf you could
16:36:25 <mux> mauke: I'm not sure if the FFI would accept 'Ptr a' here, I think not; and Ptr () is the most direct translation for a void *
16:36:35 <mux> at least it seems quite natural to me, and I've seen used a lot in bindings
16:36:46 <mauke> Ptr a seems more natural to me
16:36:47 <Pseudonym> I wish there was a copy of this online, but here's the citation:
16:36:49 <Pseudonym> http://www.citidel.org/?op=getobj&identifier=oai:DBLP:inproceedings.conf/ifip/Parnas74
16:36:53 <lambdabot> Title: CITIDEL: Viewing 'On a 'Buzzword': Hierarchical Structure.', http://tinyurl.com/ywl37y
16:37:13 <jaj> that lambdabot is great
16:37:16 <SamB_XP> I don't think the FFI likes polymorphic types for imports/exports
16:37:41 <SamB_XP> jaj: isn't it?
16:37:44 <mux> mauke: Ptr a is clearly what you would export, you would have a small wrapper around the C memset() call
16:37:57 <mux> mauke: but I think you would need Ptr () for the FFI
16:38:03 <SamB_XP> I would probably export three things
16:38:03 <olsner> oh, House actually seems to be what I was looking for; I got the impression that it only could run haskell code
16:38:09 <allbery_b> no, it's kinda hard to pass a class dictionary to an FFI call
16:38:10 <mauke>  Int8, Int16, Int32, Int64, Word8, Word16, Word32, Word64, Ptr a, FunPtr a, and StablePtr a, for any type a
16:38:46 <SamB_XP> @hoogle mallocBytes
16:38:46 <lambdabot> Foreign.Marshal.Alloc.mallocBytes :: Int -> IO (Ptr a)
16:38:46 <lambdabot> Foreign.Marshal.Pool.pooledMallocBytes :: Pool -> Int -> IO (Ptr a)
16:39:48 <SamB_XP> I would export memsetBytes :: Ptr () -> CInt -> CSize -> ()
16:39:58 <SamB_XP> er.
16:39:59 <mauke> what, no IO?
16:40:01 <SamB_XP> s/()/a/
16:40:03 <SamB_XP> oh, yes, IO
16:40:14 <SamB_XP> I blame mux
16:40:27 <mux> heh yeah, missed it
16:40:32 * mux punishes self
16:41:16 <SamB_XP> memset :: Storable a => Ptr a -> CInt -> IO ()
16:41:24 <mux> type inference gets fun when you use malloc/alloca :-) I like not specifying the size of what I alloc, because type inference constraints to the correct type and finds it out
16:41:30 <SamB_XP> memsetArray :: Storable a => Ptr a -> CInt -> CSize -> IO ()
16:42:02 <SamB_XP> mux: yeah, it's one of those things you wish you could do in C
16:42:04 <mauke> mux: you can do that in C++
16:42:15 <SamB_XP> mauke: I don't think so...
16:42:22 <mauke> http://mauke.ath.cx/stuff/c++/awesome/malloc.hh
16:42:22 <SamB_XP> well, there is new
16:42:27 <mux> even if it can, it has so many other drawbacks :-)
16:42:29 <SamB_XP> but that's cheating
16:42:38 <mauke> (I hope that link works)
16:42:48 <SamB_XP> it works
16:43:09 <SamB_XP> how do you use it?
16:43:29 <mauke> #include <awesome/malloc.hh>
16:43:40 <mauke> double *ptr = awesome::malloc(10);  // 10 doubles
16:43:57 <mauke> no sizeof, no casts
16:44:00 <mux> mauke: it's ugly though =)
16:44:08 <SamB_XP> I... thought you weren't able to dispatch based on return types ever in C++?
16:44:10 <mux> I mean, this malloc.hh thing
16:44:10 <mauke> s/ugly/C++/
16:44:13 <mux> not the usage
16:44:14 <mux> heh.
16:44:32 <mauke> SamB_XP: yes, but you can define a templated conversion operator
16:44:35 <SamB_XP> you need to add comments
16:44:47 <mauke> it is INTUITIVELY OBVIOUS
16:44:59 <SamB_XP> detailing how it tricks C++ into return-based overloading
16:46:07 <mauke>  template<typename T> operator T *() const {  // <- tells everything
16:46:56 * mux goes to have some rest, nite gentlemen &
16:48:07 <sorear> mauke: brilliant
16:48:20 <sorear> It doesn't dispatch on return types.
16:48:47 <sorear> It creates an object which lazily dispatches by overriding cast operations, for every type of interest.
16:48:54 <sorear> Brilliant hack.
16:49:01 <sorear> Emphasis on the second part :)
16:49:07 <SamB_XP> hmm.
16:49:17 <SamB_XP> how does it lazily generate cast operations then?
16:49:32 <mauke> I let the context do it
16:49:44 <mauke> my malloc doesn't return a pointer; it returns a proxy object
16:49:46 <SamB_XP> also those look like call operations
16:49:53 <mauke> this proxy object has implicit conversions to all pointer types
16:50:13 <SamB_XP> wait, nevermind
16:50:17 <mauke> my conversions have the side effect of allocating memory
16:50:21 <SamB_XP> I wish C++ didn't have such complicated syntax :-(
16:52:15 <SamB_XP> anyway, I'd like it if C++ was clean enough to be able to handle it WITHOUT such evil hacks
16:52:16 <dibblego> how do I say ?src instance Functor (Either e) to lambdabot?
16:52:25 <SamB_XP> but than we wouldn't call it C++ would we?
16:52:27 <hpaste>  ramza3 pasted "Code" at http://hpaste.org/3144
16:52:28 <ramza3> I want to post some code to my blog, anybody want to critique it.
16:52:32 <omnId> @src Either fmap
16:52:32 <lambdabot> fmap _ (Left x) = Left x
16:52:32 <lambdabot> fmap f (Right y) = Right (f y)
16:52:38 <dibblego> thanks
16:52:40 <ramza3> I dont know what to say really, I dont know what I am doing, hehe
16:53:56 <ramza3> ok, hpaste doenst like a lot of code
17:15:23 <ericlavigne> @src Bool
17:15:23 <lambdabot> data Bool = False | True deriving (Eq, Ord)
17:16:03 <oerjan> not Enum?
17:16:13 <sarehu> implemented separately
17:17:17 <oerjan> the report says: data  Bool  =  False | True     deriving (Eq, Ord, Enum, Read, Show, Bounded)
17:19:05 <renkin> haskell is beautiful :)
17:19:11 <renkin> just had to say it
17:21:02 <sarehu> oerjan: instance Enum Bool is implemented in GHC.Enum
17:21:38 <renkin> is haskell used for anything commercially?
17:21:47 <renkin> I know it's a quite big in research
17:22:17 <thoughtpolice> renkin: http://galois.com/
17:22:18 <lambdabot> Title: Galois, Inc.
17:22:59 <ericlavigne> @src Enum
17:22:59 <lambdabot> class  Enum a   where
17:22:59 <lambdabot>     succ                     :: a -> a
17:22:59 <lambdabot>     pred                     :: a -> a
17:22:59 <lambdabot>     toEnum                   :: Int -> a
17:22:59 <lambdabot>     fromEnum                 :: a -> Int
17:23:01 <lambdabot> [3 @more lines]
17:23:05 <davidL> galois...hm, sounds fimiliar...company that's sponsoring Haskell somehow?
17:23:21 <renkin> nice
17:23:31 <thoughtpolice> davidL: yeah, they run sequence.complete.org now I believe
17:23:34 <thoughtpolice> as well as host some other stuff
17:23:49 <oerjan> @more
17:23:49 <lambdabot>     enumFrom                 :: a -> [a]
17:23:49 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
17:23:49 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
17:24:22 <olsner> > enumFromThen False False
17:24:24 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,False,False,Fal...
17:24:29 <olsner> > enumFromThen False True
17:24:31 <lambdabot>  [False,True]
17:24:39 <olsner> > enumFromTo False False
17:24:40 <lambdabot>  [False]
17:24:57 <olsner> so what's enumfromthen supposed to do?
17:25:07 <sarehu> > enumFromThen 1 5
17:25:08 <omnId> > enumFromThen 1 3
17:25:09 <lambdabot>  [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,101...
17:25:10 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
17:25:25 <omnId> Bool isn't a very large type :)
17:25:29 <smack__> > [1,3..5]
17:25:31 <lambdabot>  [1,3,5]
17:25:32 <oerjan> it's the desugaring of [a,b..] notation
17:25:36 <smack__> er
17:25:53 <omnId> @pl (\x y -> [x, y .. ])
17:25:53 <lambdabot> enumFromThen
17:26:04 <oerjan> [a,b..c] is enumFromThenTo
17:26:04 <davidL> > enumFromThen 1 5 == [1,5..]
17:26:08 <lambdabot> Terminated
17:26:21 <olsner> > (\x y -> iterate (+ (y-x)) x) 1 5
17:26:23 <lambdabot>  [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,101...
17:26:48 <omnId> @pl (\x y -> iterate (+ (y-x)) x)
17:26:48 <lambdabot> flip =<< ((iterate . (+)) .) . subtract
17:27:17 <olsner> but that's longer!
17:27:21 <sarehu> pl is sometimes pointless
17:27:24 <oerjan> omnId: they're the same on Integers, but the general type is different
17:27:43 <omnId> @type (\x y -> iterate (+ (y-x)) x)
17:27:44 <oerjan> (one with Num, the other with Enum)
17:27:45 <lambdabot> forall a. (Num a) => a -> a -> [a]
17:27:59 <oerjan> @type fromEnumThen
17:28:01 <lambdabot> Not in scope: `fromEnumThen'
17:28:10 <oerjan> @type enumFromThen
17:28:11 <lambdabot> forall a. (Enum a) => a -> a -> [a]
17:28:19 <olsner> no (-) and (+) on enums
17:28:43 <sarehu> > 1 :: Word8
17:28:45 <lambdabot>  1
17:29:04 <sarehu> > enumFromThen 1 5 == [1 :: Word8, 5..]
17:29:05 <lambdabot>  True
17:29:47 <omnId> @type (\x y -> iterate (+ (fromEnum y - fromEnum x)) fromEnum x)
17:29:49 <lambdabot>     Couldn't match expected type `Int' against inferred type `a -> Int'
17:29:49 <lambdabot>     In the second argument of `iterate', namely `fromEnum'
17:30:10 <oerjan> omnId: also, on bounded types fromEnumThen stops
17:30:16 <omnId> @type (\x y -> iterate (+ (fromEnum y - fromEnum x)) (fromEnum x))
17:30:18 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a -> [Int]
17:30:27 <oerjan> er, enumFromThen
17:30:38 <omnId> @type (\x y -> iterate (+ (fromEnum y - fromEnum (x `asTypeOf` y))) (fromEnum x))
17:30:40 <lambdabot> forall a. (Enum a) => a -> a -> [Int]
17:30:46 <omnId> success.
17:30:53 <omnId> or not
17:30:57 <omnId> -> [Int]
17:31:06 <olsner> @type (\x y -> map toEnum $ iterate (+ (fromEnum y - fromEnum (x `asTypeOf` y))) (fromEnum x))
17:31:07 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a1 -> [a]
17:31:25 <omnId> needs another asTypeOf :)
17:31:26 <olsner> @type (\x y -> map (toEnum `asTypeOf` x) $ iterate (+ (fromEnum y - fromEnum (x `asTypeOf` y))) (fromEnum x))
17:31:28 <lambdabot> forall a. (Enum a, Enum (Int -> a)) => (Int -> a) -> (Int -> a) -> [a]
17:31:37 <olsner> fail!
17:31:51 <omnId> @type (\x y -> map ((`asTypeOf` x) . toEnum) $ iterate (+ (fromEnum y - fromEnum (x `asTypeOf` y))) (fromEnum x))
17:31:52 <lambdabot> forall a. (Enum a) => a -> a -> [a]
17:31:56 <omnId> win!
17:32:23 <olsner> @src enumFromThen
17:32:23 <lambdabot> Source not found. stty: unknown mode: doofus
17:32:48 <oerjan> olsner: see above (Enum class)
17:32:58 <olsner> yeah, I realized that
17:33:07 <omnId> oerjan: probably checking for a default
17:33:14 <omnId> @src (/=)
17:33:14 <lambdabot> x /= y = not (x == y)
17:33:25 <olsner> but we've just proven that it doesn't have to be in the class ;-)
17:33:38 <oerjan> not really
17:33:44 <omnId> olsner: well, the above only works for types that fit into Int
17:33:56 <oerjan> and doesn't stop at the end
17:34:07 <oerjan> > [LT,EQ ..]
17:34:09 <lambdabot>  [LT,EQ,GT]
17:34:21 <oerjan> > [LT,GT ..]
17:34:22 <lambdabot>  [LT,GT]
17:34:23 <omnId> (\x y -> map ((`asTypeOf` x) . toEnum) $ iterate (+ (fromEnum y - fromEnum (x `asTypeOf` y))) (fromEnum x)) LT EQ
17:34:28 <omnId> > (\x y -> map ((`asTypeOf` x) . toEnum) $ iterate (+ (fromEnum y - fromEnum (x `asTypeOf` y))) (fromEnum x)) LT EQ
17:34:29 <lambdabot>  Exception: Prelude.Enum.Ordering.toEnum: bad argument
17:34:37 <omnId> :)
17:34:47 <omnId> > take 3 $ (\x y -> map ((`asTypeOf` x) . toEnum) $ iterate (+ (fromEnum y - fromEnum (x `asTypeOf` y))) (fromEnum x)) LT EQ
17:34:48 <lambdabot>  [LT,EQ,GT]
17:35:02 <omnId> it works until (toEnum 3)
17:37:30 <omnId> is there a (pred . succ = id) law?
17:37:54 <oerjan> apart from at the end of the range
17:38:17 <oerjan> > (pred . succ) True
17:38:19 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
17:38:43 <omnId> > (pred . succ) '\1114111' -- :D
17:38:44 <lambdabot>  Character constant out of range
17:39:08 <omnId> oops
17:39:14 <omnId> > 0x10FFFF
17:39:16 <lambdabot>  1114111
17:39:25 <omnId> > maxBound :: char
17:39:25 <lambdabot>        add (Bounded char) to the expected type of an expression
17:39:26 <lambdabot>     In the ex...
17:39:27 <omnId> > maxBound :: Char
17:39:28 <lambdabot>  '\1114111'
17:39:58 <omnId> > '\1114111' -- strange
17:39:58 <lambdabot>  Character constant out of range
17:40:12 <mrd> ah
17:40:31 <mrd> there's a character to help with that
17:40:31 <oerjan> o_O
17:40:34 <mrd> one sec
17:41:11 <mrd> > '\111\&4111'
17:41:11 <lambdabot>  Improperly terminated character constant
17:41:24 <mrd> > "\111\&4111"
17:41:25 <lambdabot>  "o4111"
17:41:28 <oerjan> that might be the Language.Haskell module's fault?
17:41:53 <oerjan> > "\1114111"
17:41:53 <lambdabot>  Character constant out of range
17:41:59 <oerjan> > "\1114111\&"
17:41:59 <lambdabot>  Character constant out of range
17:42:03 <oerjan> > "\111411\&"
17:42:05 <lambdabot>  "\111411"
17:42:09 <oerjan> > "\1114110\&"
17:42:09 <lambdabot>  Character constant out of range
17:42:13 <omnId> @ty '\1114111' -- see if @type's parser likes it
17:42:15 <lambdabot> Char
17:42:29 <oerjan> @ty '\1114112'
17:42:31 <lambdabot> lexical error in string/character literal at character '1'
17:42:46 <oerjan> seems like a bug in Language.Haskell
17:43:32 <omnId> > (chr 1114111) -- a workaround
17:43:34 <lambdabot>  '\1114111'
17:43:46 <oerjan> > "\1000000\&"
17:43:46 <lambdabot>  Character constant out of range
17:43:57 <oerjan> > "\999999\&"
17:43:57 <lambdabot>  Character constant out of range
17:44:03 <omnId> > '\x10FFFF'
17:44:03 <lambdabot>  Character constant out of range
17:44:06 <oerjan> > "\499999\&"
17:44:06 <lambdabot>  Character constant out of range
17:44:10 <oerjan> > "\299999\&"
17:44:11 <lambdabot>  Character constant out of range
17:44:15 <oerjan> > "\199999\&"
17:44:16 <lambdabot>  Character constant out of range
17:44:22 <oerjan> > "\109999\&"
17:44:23 <lambdabot>  "\109999"
17:44:29 <oerjan> > "\159999\&"
17:44:29 <lambdabot>  Character constant out of range
17:44:36 <omnId> perhaps this'd be better /msg'd?
17:47:14 <omnId> the upper bound is somewhere in (130625, 131250)
17:48:02 <oerjan> > "\131071\&"
17:48:03 <lambdabot>  "\131071"
17:48:05 <oerjan> > "\131072\&"
17:48:05 <lambdabot>  Character constant out of range
17:48:11 <olsner> 128k
17:48:20 <olsner> nice, even, number
17:48:54 <omnId> I was converging there :)  I'd have got it.
17:49:02 <oerjan> > 2^17
17:49:04 <lambdabot>  131072
17:49:33 <oerjan> my binary search was quicker :)
17:49:36 <omnId> too high a power of two for me to have memorized :)
17:50:09 <omnId> I'd gotten to (131000, 131125)
17:50:30 <olsner> > 2^20
17:50:31 <lambdabot>  1048576
17:50:43 <oerjan> except that one
17:50:45 * omnId realizes that he participated in a competitive binary search.  He's not sure what to make of this.
17:51:10 <olsner> knew that one too ;-) but I don't think I know 256k or 512k by heart
17:51:32 <olsner> probably know them when I see them though
17:51:35 <oerjan> > map (2^) [17..19]
17:51:36 <lambdabot>  [131072,262144,524288]
17:52:39 <omnId> odd that Language.Haskell uses a seventeen-bit Char.
17:53:16 <olsner> how many unicode codepoints are actually defined?
17:53:59 <omnId> I think maybe the first three or four groups of 2^16.
17:54:21 <omnId> (sparsely)
17:58:00 <olsner> apparently, only planes 0..2 and 14..16 are assigned
17:59:40 <oerjan> perhaps they did it that way to ensure software would support the whole range that eventually does get filled in
18:00:32 <oerjan> assuming they never will need to go beyond 16
18:02:02 <mikael> did you know they call the planes above 0 astral planes?
18:02:28 * SamB_XP wonders what would happen if he connected a modem to his cellphone by the headset jack...
18:03:04 <allbery_b> won't work, unless it's an old 300 baud modem
18:03:31 <allbery_b> modern modems require a lot more bandwidth than cellular provides, and cellular generally makes no attempt to preserve phase
18:04:34 <mikael> you could connect it to your line-in and write a 300 baud modem in software
18:04:52 <platypus> allbery_b: However don't most modern modems speed step down to low speeds on poor lines?
18:05:21 * allbery_b remembers his first computer whose cassette tape interface / 300baud modem was impelmented in software
18:05:41 <allbery_b> platypus: only down to 1200 baud though, which still requires the line to preserve 4 phase states
18:06:06 <allbery_b> and the most recent ones only downgrade to 9600
18:06:24 <allbery_b> (1200 baud was actually 600 baud + parallel transmission of bits in the phase state)
18:07:18 <SamB_XP> are you telling me they do a fourier transform and throw out the imaginary part?
18:07:47 <allbery_b> anything over 600 baud requires phase preservation, 9600 baud and up require enough bandwidth for multiple independent carrier tones
18:07:56 <SamB_XP> phones, I meant
18:08:30 <platypus> SamB_XP: Its within most telephony software's ability to do that.
18:08:53 <allbery_b> they digitize a relatively small band.  as for phase, often it's lost at the switch (tower in the case of cellular)
18:09:01 <allbery_b> if it's cheaper to invert phase, they do
18:09:15 <allbery_b> which kills data transmission that uses phase to transmit bts in parallel
18:09:22 <SamB_XP> wait a minute, how is it a problem if they just invert it?
18:09:46 * allbery_b is actually not sure of the details
18:09:51 <allbery_b> it might actually be phase jitter
18:10:35 <allbery_b> what I recall was that starting with 2400 baud modems, the local phone switch had to reproduce phase exactly or it wouldn't do 2400 baud
18:11:24 <allbery_b> 1200 baud had few enough phase transitions that it wasn't an issue, which is why I think it's inversion (2400 baud required 8 phase states, IIRC, but it's been a long time)
18:11:42 <allbery_b> wikipedia or something probably knows the truth
18:12:07 * allbery_b just knows phase mismatches at the switch caused lots of grief for people in the early days of high speed modems
18:12:15 <allbery_b> s/mismatches/loss/
18:14:51 <sorear> You could still do the 300baud modem in software thing... computers today are quite fast enough
18:15:09 <allbery_b> hey, if an old 1MHz 6502 could do it...
18:15:32 <allbery_b> of course, it's more complex than that.  anyone here remember winmodems?
18:16:06 <dibblego> me!
18:17:11 <mgsloan> hmm, is there a modulus for non-integerals?
18:17:39 <allbery_b> hasn't that been asked a couple times recently?  best suggestion I saw was to use FFI to get at fmod()
18:17:55 <mgsloan> :/
18:18:15 <mgsloan> well, I think I'll just go with doing a division, rounding, and subtracting
18:19:43 <SamB_XP> allbery_b: well, these days you could just use an ordinarly, compatible sound card
18:19:55 <SamB_XP> or something...
18:19:59 <oerjan> :t properFraction
18:20:01 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
18:20:03 <SamB_XP> right?
18:20:19 <allbery_b> not sure.  I've heard most soundcards are actually pretty lousy
18:20:19 <mgsloan> I thought there are modems that are basically just crappy sound cards
18:20:24 <oerjan> mgsloan: snd . properFraction does modulo 1
18:20:39 <mgsloan> I think my old 28K modem was mostly software, anyway
18:20:51 <allbery_b> there's apparently a lot of wideband electronic noise
18:21:04 <mgsloan> oerjan - ah, cool
18:21:39 <cognominal_> @pl  liftM (take 20) $ liftM fromJust
18:21:39 <lambdabot> fmap (take 20) (fmap fromJust)
18:22:06 <cognominal_> :t fmap
18:22:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:22:16 <sorear> allbery_b: aiui, the big problem with winmodems was the real-time requirement, but processors are fast enough now you only need to wake up a few times a second to keep the soundcard buffer full
18:22:29 <omnId> doesn't fmap f . fmap g = fmap (f . g)?
18:22:33 <mgsloan> yeah, twas a winmodem
18:22:38 <allbery_b> they're all software these days.  most early 9600 baud modems neded only a firmware update to become V.32 compliant
18:22:41 <oerjan> although only for positive numbers
18:22:47 <mgsloan> omnid - yeah
18:22:56 <allbery_b> (I think it wa V.32, again, long time)
18:22:59 <cognominal_> :t liftM
18:23:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:23:02 <oerjan> > (-10) `rem` 7
18:23:04 <lambdabot>  -3
18:23:10 <omnId> cognominal_: liftM (take 20 . fromJust)
18:23:11 <dibblego> ?check \f g -> fmap f . fmap g == fmap ((f :: Int -> Int) . (g :: Int -> Int))
18:23:12 <lambdabot>   add an instance declaration for (Eq (f Int -> f Int))     In the expression...
18:23:17 <oerjan> so it's more like rem than mod
18:23:19 <mgsloan> argh, yeah, the dreaded postive vs negative modulus issues
18:23:20 <dibblego> dang :)
18:24:12 <cognominal_> omnId, ho yes, i can factorize. thx
18:24:23 <omnId> cognominal_: and fmap = liftM, to explain @pl
18:24:31 <SamB_XP> allbery_b: the principle difference between a winmodem and an actual modem being what the software runs on?
18:24:40 <allbery_b> sorry, I'm thnking of early 56k modems
18:24:47 <mgsloan> ?check \f g (x:xs) -> fmap f . fmap g $ xs == fmap ((f :: Int -> Int) . (g :: Int -> Int)) $ xs
18:24:47 <lambdabot>  Couldn't match expected type `[t]'
18:24:53 <allbery_b> when k56 and USR's spec were duking it out
18:25:07 <allbery_b> SamB_XP: yeh, actual modems used dedicated hardware
18:25:09 <jql> bah, winmodems
18:25:25 <allbery_b> winmodems often dropped bits because the main CPU had to do the work, and this was back in the win95 days
18:25:38 <allbery_b> so they did a really poor job of near-real-time
18:26:08 <SamB_XP> I actually possess an external 56k modem
18:26:23 <oerjan> > properFraction (-1.3)
18:26:26 <lambdabot>  (-1,-0.30000000000000004)
18:26:30 <jql> winmodems work by the cpu actually calculating the screeching sound to play over the telephone line, and sending it to the "player" on the card. real modems take the bits to be sent and generate the screeching themselves
18:26:31 <SamB_XP> so I'm fairly certain it's not a winmodem ;-)
18:26:51 <SamB_XP> jql: yeah, I know
18:26:53 <allbery_b> there were extenal 56k winmodems
18:26:58 <jql> vastly inferior tech
18:27:01 <allbery_b> they didn't last very long
18:27:17 <SamB_XP> did I mention it worked with the usual protocol?
18:27:48 <allbery_b> the ones I saw on sale all had big warning sitckers on them saying they were only compatible with certain windows configurations
18:27:49 <mgsloan> > properFraction (-.5)
18:27:49 <lambdabot>   Not in scope: `-.'
18:27:56 <allbery_b> so if you had one you would almost certaily know it
18:28:02 <mgsloan> > properFraction (-0.5)
18:28:03 <lambdabot>  (0,-0.5)
18:28:17 * mgsloan was hoping for a -0, ahwell
18:28:46 <allbery_b> the 0 is Integral
18:28:56 <mgsloan> yep
18:29:03 <allbery_b> so unless you have a 1s complement machine...
18:29:09 <lament> > properFraction (-1.5)
18:29:11 <lambdabot>  (-1,-0.5)
18:37:59 <twifkak> hey! sega dreamcast had a winmodem, and the dreamcast lives on...
18:40:05 * allbery_b discards a comment about the longevity of ex-parrots and merely notes that game consoles tend to be better at NRT than general purpose computers running win95
18:41:39 <dibblego> ?hoogle Char -> Char
18:41:40 <lambdabot> Char.toLower :: Char -> Char
18:41:40 <lambdabot> Char.toUpper :: Char -> Char
18:41:41 <oerjan> besides, it is just sleeping.
18:43:08 <LoganCapaldo> > toLower 'A'
18:43:09 <lambdabot>  'a'
18:43:47 <shapr> @yow!
18:43:47 <lambdabot> Hmmm ... a CRIPPLED ACCOUNTANT with a FALAFEL sandwich is HIT by a
18:43:47 <lambdabot> TROLLEY-CAR ...
18:44:01 <dibblego> ?hoogle Char -> Bool
18:44:02 <lambdabot> Char.isAlpha :: Char -> Bool
18:44:02 <lambdabot> Char.isAlphaNum :: Char -> Bool
18:44:02 <lambdabot> Char.isAscii :: Char -> Bool
18:44:39 <omnId> @hoogle+
18:44:40 <lambdabot> Char.isControl :: Char -> Bool
18:44:40 <lambdabot> Char.isDigit :: Char -> Bool
18:44:40 <lambdabot> Char.isHexDigit :: Char -> Bool
18:44:57 <oerjan> there are far too many to list here, see Data.Char
18:51:16 <Syzygy-> > sum [1..100]
18:51:31 <mgsloan> > wrapIntoInterval (Interval 5 10) 13.2
18:51:31 <mgsloan> 8.2
18:51:32 <lambdabot>   Not in scope: data constructor `Interval'
18:51:32 <mgsloan> :)
18:51:47 <Syzygy-> > foldr1 (+) [1..100]
18:52:09 <jcreigh> Syzygy-: your first one should have worked, I think LB is freaking out for some reason
18:52:14 <Syzygy-> Right.
18:52:14 <oerjan> > foldr1 (+) [1..100]
18:52:19 <lambdabot>  5050
18:52:19 <omnId> @vixen Are you mad at Syzygy-?
18:52:20 <lambdabot> let's don't talk about that
18:52:30 <Syzygy-> Obviously.
18:59:12 <oerjan> @localtime Syzygy-
18:59:13 <lambdabot> Local time for Syzygy- is Mon Oct  8 03:58:46 2007
18:59:33 <oerjan> hm, there is contact
19:00:32 <omnId> Syzygy-: /nick something else, I'll impersonate you.
19:10:31 <Syzygy-> omnId: No.
19:10:59 <omnId> okay, just thought I'd test if lb didn't like your nick for some reason.
19:11:23 <Syzygy-> It used to like it. It will come back again. And I have a GOA in a side session of the same screen...
19:11:32 <Syzygy-> And I did get hold of the results I needed anyway.
19:11:45 <Syzygy-> @weather
19:11:45 <lambdabot> Unknown command, try @list
19:11:51 <Syzygy-> She recognizes me at all.
19:18:27 <_achilles_> @pl [[a]]->[a]
19:18:27 <lambdabot> (line 1, column 6):
19:18:27 <lambdabot> unexpected ">" or "-"
19:18:27 <lambdabot> expecting variable, "(", operator or end of input
19:18:55 <oerjan>  @pl takes an expression
19:19:08 <Syzygy-> @djinn  [[a]]->[a]
19:19:09 <lambdabot> -- f cannot be realized.
19:19:12 <Syzygy-> o.O
19:19:17 <omnId> @ty concat
19:19:19 <lambdabot> forall a. [[a]] -> [a]
19:19:22 <_achilles_> ah
19:19:24 <_achilles_> ;)
19:19:29 <_achilles_> I think I wanted Hoogle
19:19:30 <Syzygy-> @djinn [a] -> a
19:19:30 <lambdabot> -- f cannot be realized.
19:19:45 <Syzygy-> Ooooooh.
19:19:50 <Syzygy-> Now I think I know why that later cannot be.
19:19:58 <Syzygy-> It needs to handle [] gracefully
19:20:21 <omnId> does @djinn even understand [] (the type)?
19:20:35 <Syzygy-> Dunno
19:20:42 <omnId> @djinn a -> [a] -> [a]
19:20:43 <lambdabot> f _ a = a
19:20:52 <omnId> heh
19:20:58 <oerjan> (and only some kinds at that)
19:20:58 <oerjan> @djinn  [[a]]->[a]
19:20:58 <lambdabot> -- f cannot be realized.
19:23:59 <_achilles_> so...the concat in concatMap only applies to the results of the passed function, not the list
19:24:26 <oerjan> @src concatMap
19:24:27 <lambdabot> concatMap f = foldr ((++) . f) []
19:25:04 <_achilles_> gasp
19:25:07 <omnId> concatMap f xs = concat (map f xs)
19:25:21 <_achilles_> is there a way to list all of lambdabots little functions
19:25:22 <omnId> _achilles_: pay no mind to the man behind the curtain.
19:25:33 <omnId> _achilles_: /msg lambdabot @list
19:25:37 <pastorn> what's the easiest way to go from "sin (2*x + 3.2) + 3*x + 5.7" to
19:25:38 <_achilles_> ty!
19:25:51 <pastorn> > let x = pi in sin (2*x + 3.2) + 3*x + 5.7
19:25:53 <lambdabot>  15.066403817341799
19:26:32 <pastorn> read :: String -> (a -> b) -- would've been nice :D
19:26:41 <oerjan> seemed pretty easy to me
19:27:08 <oerjan> hsplugins is what lambdabot uses
19:27:25 <pastorn> okay
19:27:27 <oerjan> that's definitely not easy
19:27:30 <pastorn> .where hsplugins
19:27:34 <pastorn> @where hsplugins
19:27:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
19:29:58 <_achilles_> hmm
19:30:06 <_achilles_> monads are tricky
19:30:39 <shachaf> @djinn a -> [a]
19:30:39 <lambdabot> -- f cannot be realized.
19:31:04 <_achilles_> ?
19:31:16 <_achilles_> :t (:)
19:31:18 <lambdabot> forall a. a -> [a] -> [a]
19:31:22 <oerjan> djinn definitely does not understand []
19:31:26 <shachaf> @ty (:[])
19:31:28 <lambdabot> forall a. a -> [a]
19:31:31 <_achilles_> haha
19:31:41 <omnId> @quote \:\[\]
19:31:41 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
19:31:46 <omnId> @quote \:\[
19:31:46 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
19:31:59 <_achilles_> yum yum yum
19:32:48 <mrd> > (:[()])
19:32:49 <lambdabot>  <() -> [()]>
19:33:16 <omnId> > (:[()])()
19:33:18 <lambdabot>  [(),()]
19:33:27 <_achilles_> I know that return x = [x] for lists, assuming I didn't how might I ask lambdabot or ghci/hugs?
19:33:34 <mrd> > (:[(||)])  -- chomping a hamburger
19:33:35 <lambdabot>  <(Bool -> Bool -> Bool) -> [Bool -> Bool -> Bool]>
19:33:39 <shachaf> > (:[(:[])])
19:33:39 <oerjan> @src [] return
19:33:40 <lambdabot> return x    = [x]
19:33:40 <lambdabot>  Add a type signature
19:33:47 <shachaf> @ty (:[(:[])])
19:33:47 <SamB_XP> @src IO return
19:33:49 <lambdabot> forall a. (a -> [a]) -> [a -> [a]]
19:33:49 <lambdabot> return x    = returnIO x
19:33:55 <SamB_XP> @src returnIO
19:33:56 <lambdabot> Source not found. My mind is going. I can feel it.
19:34:00 <_achilles_> makes sense..
19:34:12 <SamB_XP> dons: what did you include IO return for?
19:34:17 <SamB_XP> it has no informational content...
19:34:17 <mrd> shachaf: cannibalism!
19:34:36 <shachaf> mrd: No; they're different species.
19:35:01 <shachaf> One is :: (a -> [a]) -> [a -> [a]], the other :: a -> [a].
19:35:13 <oerjan> (:[]) is a monster which always keeps returning...
19:35:30 <shachaf> @ty fix (\x -> (:[x]))
19:35:32 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> t
19:35:32 <lambdabot>     Probable cause: `x' is applied to too few arguments
19:35:36 <SamB_XP> are we sure it isn't a robot?
19:35:44 <shachaf> Haskell won't allow cannibals.
19:35:51 <shachaf> See?
19:35:54 <omnId> but for (second) a = (first) (a -> [a]), they're the same!  It's eating it's children!
19:36:41 <chessguy> @quote missile
19:36:41 <lambdabot> lennart says: Should Haskell also provide unrestricted side effects, setjmp/longjmp, missile launching functions, etc?  After all, people who don't want to use them can just avoid them. :)
19:37:08 <newsham> as long as it still works with stm retry
19:37:11 * SamB_XP wonders what the context was for that
19:37:28 <Adamant> I definitely want missile launching functions
19:37:36 <mrd> just because everyone else is unsafeJumpingOffBridges doesn't mean you should
19:37:39 <SamB_XP> as long as they return Military ()
19:37:43 <chessguy> unsafeMissileLaunchIO
19:38:13 <byorgey> unsafeLemmingIO
19:38:39 <Olathe> unsafeLateForWorkIO
19:38:43 <Tac-Tics> hehe
19:39:00 <Adamant> unsafeHeyYallWatchThisIO
19:39:02 <Tac-Tics> unsafeForWorkIO
19:39:09 <newsham> ffi, for when you positively absolutely undeniably need to launch your missiles
19:39:32 <mrd> _|_ with consequences
19:39:38 <omnId> newsham: whenever the thunk is forced, that is :)
19:39:43 <SamB_XP> don't they usually have some kind of countdown with potential abort?
19:39:43 <newsham> _|_'s up
19:39:57 <SamB_XP> (_|_)s up
19:41:01 <shachaf> SamB_XP: Where did it get that comment, by the way?
19:41:05 <qazwsx> what's the closest I can get to eval ?
19:41:25 <oerjan> qazwsx: hsplugins
19:41:30 <newsham> Survival Kit contents check. In them you will find: one 45 caliber automatic, two boxes of ammunition, four days concentrated emergency rations, one drug issue containing antibiotics, morphine, vitamin pills, pep pills, sleeping pills, tranquilizer pills, one miniature combination Rooshan phrase book and Bible, one hundred dollars in rubles, one hundred dollars in gold, nine packs of chewing gum, one issue of prophylactics, three lipsticks, three pair of nylo
19:41:31 <oerjan> @where hsplugins
19:41:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
19:41:37 <SamB_XP> shachaf: hmm, I actually invented the whole situation on the spot
19:43:01 <qazwsx> oerjan: cool, thanks!
19:43:45 <shachaf> SamB_XP: I understood; I just wondered where such a comment could come from. :-)
19:44:02 <SamB_XP> well it said something else before
19:44:20 <SamB_XP> but since it was in the grip of the monster/robot, it was screaming Help!
20:00:42 <mgsloan> speaking of robots, I started working on Raskell today
20:00:47 <mgsloan> http://mgsloan.nfshost.com/darcs/raskell/
20:00:48 <lambdabot> Title: Index of /darcs/raskell
20:01:01 <mgsloan> (robot simulator)
20:01:27 <sarehu> ok, as long as it's not "Rascal" (because I called that one)
20:02:39 <mgsloan> well, technically the rascal scooter company called that one
20:02:41 <mgsloan> but ok
20:12:01 <mgsloan> it's pretty rough... most of the main code will be rewritten.  I was messing with more advanced physics and monadicness, but got fed up and just punched out this rough one
20:12:27 <mgsloan> it's probably better this way w.r.t monadicness, as actually I think it could be done as a layer on top
20:13:51 * jaredj almost done with http://www.pcthiker.com/pages/gear/pepsiGstoveinstruct.shtml
20:13:52 <lambdabot> Title: PCTHiker.com: Pepsi-G Stove Assembly Instructions
20:14:10 <jaredj> [ot]
20:17:14 <jaredj> ur? where's Data.Geom2
20:17:21 <jaredj> @seen Data.Geom2
20:17:22 <lambdabot> I haven't seen Data.Geom2.
20:18:38 <jaredj> oh. *slaps forehead*
20:20:50 <hpaste>  ramza3 pasted "(no title)" at http://hpaste.org/3145
20:25:37 <bucky> in the factorial example in the docs the first line in Main.hs is main = print (fac 20)  what is the 20 for ?
20:26:04 <jaredj> i reckon you want the factorial of 20
20:27:05 <mgsloan> jaredj - yeah, Data.Geom2 makes up the majority of the code in that repo
20:27:24 <jaredj> i had to do a little change to make it compile
20:27:29 <bucky> after you :load Main  you do a fac 17 to get the factorial of 17
20:27:32 <mgsloan> build it with (ghc --make -fglasgow-exts Main.hs Classes.hs D2.hs Interval.hs -o raskell)
20:27:36 <mgsloan> oh?
20:27:42 <KatieHuber> is there any way to make ghc spit out the path to its headers?
20:28:01 <jaredj> mgsloan: well i wanted to not have to -fglasgow-exts
20:28:01 <KatieHuber> C headers that is, for building ffi code
20:28:24 <mgsloan> oh
20:28:28 <bucky> http://www.haskell.org/ghc/docs/latest/html/users_guide/ch03s02.html  it's run in ghci  I just wondered what the 20 does
20:28:29 <lambdabot> Title: 3.2. Loading source files, http://tinyurl.com/27x9pm
20:28:32 <jaredj> mgsloan: D2.hs:1
20:28:39 <mgsloan> that seems like it would be a rather large shift over
20:28:54 <oerjan> bucky: it's if you run the file as an independent program.
20:28:56 <jaredj> mgsloan:  -{-#! fglasgow-exts !#-}
20:29:04 <jaredj> mgsloan:  +{-# OPTIONS_GHC -fglasgow-exts #-}
20:29:12 <oerjan> then only main gets run
20:29:18 <mgsloan> ahh, that'd be why that pragma didn't work..
20:29:29 <jaredj> :)
20:29:38 <mgsloan> thanks
20:29:42 <jaredj> np
20:30:45 <omnId> bucky: try 'main' in ghci.
20:30:55 <omnId> just the word main
20:31:04 <mgsloan> it's not much atm... just two robots following waypoints
20:31:15 <jaredj> and colliding
20:31:19 <mgsloan> right
20:31:19 <oerjan> mgsloan: also, i would have imagined you only need Main.hs on the command line when you use --make
20:31:53 <jaredj> garh
20:31:57 <mgsloan> one would think :) the other files are modules of Data.Geom2
20:31:59 * jaredj has superglue on fingers
20:32:05 <omnId> bucky: main is defined as a program that prints 20!, but in ghci you can evaluate arbitrary expressions besides the one defined as main.
20:32:17 <bucky> ic
20:32:28 <oerjan> omnId: there's also :main which allows you to give arguments as if on the command line, to be got with getArgs
20:33:02 <omnId> bucky: is that what you were confused over?
20:33:37 <bucky> i just thought 20 would be something like $1
20:34:18 <omnId> bucky: when the program is compiled and run, it'll print 2432902008176640000 and exit, there's no parameterization in the main program.
20:34:25 <bucky> apparently it falls back to 20 if nothing follows fac, you explained it to me
20:34:51 <bucky> how do you exit *Main> and get back to Prelude> ?
20:34:56 <omnId> bucky: but when you load a module into ghci, you can evaluate any expression you want based on the given definitions.
20:35:02 <omnId> bucky:  :quit
20:35:07 <bucky> tnx
20:35:08 <sarehu> bucky: :l
20:35:10 <omnId> :? for a list of commands
20:35:37 <omnId> oops, I misread, I thought you were asking how to quit :)
20:36:04 <bucky> :l got me there.. thanks sarehu
20:36:37 <oerjan> mgsloan: you need to put the other files in the Data/Geom2/ subdirectory
20:36:48 <mgsloan> hmm, good idea
20:37:11 <oerjan> that's where they're looked for by default
20:37:50 <omnId> bucky: you're reading the GHC manual?  If you're new to Haskell you might read YAHT.
20:39:08 <omnId> @where yaht
20:39:08 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
20:51:43 <qazwsx> is there a good C/C++ parser written in haskell?
20:51:54 <lucca> c2hs has part of one
20:51:57 <mgsloan> there's no good C/C++ parser written in any language :P
20:52:11 <lucca> qazwsx: whatcha gonna do with it?
20:52:57 <qazwsx> use it to automatically generate haskell bindings
20:53:30 <qazwsx> oh wiat
20:53:33 <qazwsx> this is what c2hs does isn't it?
20:53:40 <lucca> ...yes
20:53:50 <qazwsx> hmm
20:53:57 <qazwsx> maybre I can just use c2hs instead, is this okay with everyone?
20:54:06 <qazwsx> that the world will be one c->haskell generateor less
20:54:14 <stepcut> qazwsx: no, you must write a C++ parser in Haskell !!!
20:54:24 <qazwsx> this is what c2hs does isn't it?
20:54:43 <lucca> qazwsx: a more complete parser would be useful for other purposes
20:54:50 <lucca> e.g. static code analyzers, etc
20:54:53 <qazwsx> hmm, does c2hs have c++ support too?
20:55:13 <qazwsx> eh, I'm selfish that is somenoe else's problem
20:55:28 <bucky> http://darcs.haskell.org/c2hs/README
20:55:35 <bucky> there's always swig
20:55:47 <stepcut> c2hs C parser information -> http://www.nabble.com/anyone-interested-in-developing-a-Language.C-library--t3611590.html
20:55:49 <lambdabot> Title: Nabble - anyone interested in developing a Language.C library?, http://tinyurl.com/2ehp9u
20:56:32 <stepcut> dcoutts rewrote the parser recently, and it should do full C99 + many GNU C extensions
20:58:12 <asl> hey, does anyone know how to use the lambdabot free theorem prover?
20:58:19 <mgsloan> yeah, C is quite doable.  I'm not sure if anyone has really ever made an adequate C++ parser though
20:58:34 <mgsloan> probably best is just to do analysis on the C++ -> C
20:58:47 <oerjan> @free f :: [a]->[a]
20:58:47 <lambdabot> $map g . f = f . $map g
20:59:00 <asl> ah
20:59:07 <asl> so it needs an expression, not a type
20:59:21 <oerjan> @free [a]->[a]
20:59:21 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
20:59:22 <omnId> @help free
20:59:22 <lambdabot> free <ident>. Generate theorems for free
20:59:25 <oerjan> apparently
20:59:32 <oerjan> @free map
20:59:41 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
20:59:58 <oerjan> right, it can look up the type
21:00:27 <mgsloan> @free fmap
21:00:29 <lambdabot> Expected variable or '.'
21:01:03 <oerjan> @free foldr
21:01:04 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
21:01:30 <oerjan> perhaps it breaks because of fmap's type class
21:01:36 <mgsloan> probably
21:01:48 <mgsloan> @free >>
21:01:48 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
21:01:58 <ddarius> @free fmap :: Functor f => (a -> b) -> f a -> f b
21:01:58 <lambdabot> Extra stuff at end of line
21:02:01 <mgsloan> someone should get it to do the monad laws, heh
21:02:16 <ddarius> mgsloan: What do you mean?
21:02:30 <mgsloan> well, I suppose the monad laws aren't exactly free theorems
21:13:17 <gwern> it's gone completely out of my head - how does one concatenate a String and an IO String?
21:13:33 <glguy> \ x m -> fmap (x ++) m
21:14:11 <omnId> or do { s <- anIOString; return (aString ++ s) }
21:14:16 <mgsloan> couldn't you also lift, maybe?
21:14:18 <omnId> (which is the same)
21:14:24 <glguy> fmap = liftM
21:14:45 <omnId> and the above that I wrote is the definition of liftM, expanded out.
21:14:48 <omnId> @src liftM
21:14:48 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:14:51 <mgsloan> right, right, I knew that
21:15:17 <omnId> (mgsloan: that was for gwern)
21:15:56 <gwern> glguy: thanks. I thought I had it right, and it turns out to have been a function earlier in the line that wanted a pure argument
21:16:06 <gwern> (those error messages can be awfully opaque)
21:16:46 <asl> @type liftM . flip (++)
21:16:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m [a] -> m [a]
21:19:04 <oerjan> :t liftM (++) . return
21:19:06 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> m ([a] -> [a])
21:19:25 <oerjan> :t liftM2 (++) . return
21:19:27 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> m [a] -> m [a]
21:23:51 <newsham> liftM2b f ma b = liftM (`f` b) ma; liftM2a f a mb = liftM (f a) mb
21:24:48 <|Fo|Ns> hi all
21:25:00 <asl> hi!
21:25:05 <newsham> a/s/l?
21:25:21 <asl> ah, my initials, really
21:25:23 <fons> it's been quite some time since I was last here
21:25:28 <fons> anyway
21:25:39 <Randroid> Can someone give me a pointer on where I can find information about this forall a ( m :: * -> * ) syntax? What is m :: * -> *?
21:25:49 <sorear> Randroid: A kind.
21:26:02 <sorear> Randroid: Turn off -fglasgow-exts if you don't want to see it.
21:26:03 <fons> can anyone tell me what module has the instantiation of Monad ((->) r) ?
21:26:11 <sorear> Control.Monad.Instances
21:26:14 <asl> Control.Moand.Instances
21:26:23 <newsham> randroid:  m applies to a type argument.
21:26:24 <fons> that was fast ... thanks
21:26:27 <newsham> ie: "m a"
21:26:37 <oerjan> Control&Moan.Instances
21:26:56 <asl> Randroid:  for example, `Maybe' has kind * -> *, because it isn't a "full type" until it has a type argument
21:27:02 <newsham> so you write "* -> *"   it applies to a type and makes a new type
21:27:09 <newsham> Maybe applied to Int.
21:27:25 <oerjan> :k RWST
21:27:27 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
21:27:35 <newsham> whats rwst?
21:27:41 <omnId> Either :: * -> * -> *,  Either Int :: * -> *,  Either Int String :: *,  i.e. it's a concrete type.
21:27:43 <asl> oerjan: yeah, that's what I meant.  typo.
21:27:48 <oerjan> @index RWST
21:27:48 <lambdabot> Control.Monad.RWS, Control.Monad.RWS
21:27:59 <oerjan> RWS transformer monad
21:28:04 <omnId> newsham: Reader, Writer, State, transformer
21:28:04 <newsham> ahh
21:28:26 <oerjan> the swiss army knife of mtl
21:29:52 <oerjan> :t runRWST
21:29:54 <lambdabot> forall r w s (m :: * -> *) a. RWST r w s m a -> r -> s -> m (a, s, w)
21:30:32 <Randroid> Interesting. Where can I read more about this?
21:31:47 * omnId grumbles
21:33:00 <omnId> m here is a Monad, which has kind (* -> *), like IO, [], Maybe, etc.
21:34:19 <newsham> http://www.haskell.org/tutorial/classes.html talks briefly about kinds
21:34:20 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
21:36:10 <newsham> surely somebody knows a better ref :)
21:36:56 <Randroid> sweet
21:37:20 <omnId> the report doesn't say much: http://www.haskell.org/onlinereport/decls.html#sect4.1.1
21:37:21 <lambdabot> Title: The Haskell 98 Report: Declarations
21:38:29 <omnId> "unlike types, kinds are entirely implicit and are not a visible part of the language", so the actual kind-declaration syntax is an extension.
21:38:46 <sorear> Randroid: It's just to give you more information.  If you don't know what it is, pretend you can't see it.
21:39:26 <omnId> Or if you do know what it means, ignore it anyway, since it's usually not anything you didn't know already :)
21:40:07 <newsham> just fold your legs, close your eyes and chant "meta" while thinking on "* -> *"
21:40:10 <Randroid> Nah, I understand it reasonably well from the description given in that link. It's not rocket science. But it seems like part of the plumbing to me, so I'm not going to worry about it.
21:41:08 <omnId> it's mostly to ensure that bad types like (Either Int String OtherThing) are caught.
21:41:22 <omnId> Either only takes two types.
21:44:08 <omnId> @kind (->) a b c
21:44:13 <lambdabot> Not in scope: type variable `a'
21:44:13 <lambdabot>  
21:44:13 <lambdabot> <interactive>:1:7: Not in scope: type variable `b'
21:44:24 <omnId> @kind (->) () () ()
21:44:26 <lambdabot>     Kind error: `(->)' is applied to too many type arguments
21:48:16 <Syzygy-> @kind (->) () ()
21:48:18 <lambdabot> *
21:50:37 <oerjan> :k WrappedArrow
21:50:39 <lambdabot> (* -> * -> *) -> * -> * -> *
21:50:55 <Syzygy-> o.O
21:51:47 <omnId> :k WrappedArrow (->)
21:51:49 <lambdabot> * -> * -> *
21:53:05 <Shurique> ikkkkkk
21:53:20 <Shurique> argh, sorry. Cat + keyboard = bad
21:53:27 <dataangel> What's the simplest way in Haskell to do something for all elements of a list? I would use a list comprehension except that I don't need to know all the results -- I just need to know whether the function run on any of the elements returned false.
21:53:47 <omnId> dataangel: any
21:53:59 <omnId> > any even [1,7,3,8,9]
21:54:00 <lambdabot>  <Plugins.Eval>:1:10: parse error on input `='
21:54:06 <omnId> o.O
21:54:09 <jql> umm
21:54:13 <jql> hmm
21:54:26 <oerjan> > any even [1,7,3,8,9]
21:54:28 <lambdabot>  True
21:54:34 <omnId> > ()
21:54:36 <lambdabot>  ()
21:54:39 <omnId> > any even [1,7,3,8,9]
21:54:40 <lambdabot>  True
21:55:31 <dataangel> > any (\x -> x == False) [False, True, False, True]
21:55:32 <lambdabot>  True
21:55:42 <dataangel> is there something like isFalse?
21:55:46 <dataangel> seems verbose to use a lambda for that
21:55:47 <omnId> not
21:55:47 <oerjan> > all [False, True, False, True]
21:55:48 <lambdabot>  Couldn't match expected type `a -> Bool'
21:55:53 <omnId> @pl (\x -> x == False)
21:55:53 <lambdabot> (False ==)
21:55:58 <dataangel> > any True [False, True, False, True]
21:55:58 <lambdabot>  Couldn't match expected type `a -> Bool'
21:56:01 <oerjan> > and [False, True, False, True]
21:56:02 <lambdabot>  False
21:56:20 <dataangel> any (False ==) [True, False, True]
21:56:23 <omnId> > any not [False, True, False, True]
21:56:23 <dataangel> > any (False ==) [True, False, True]
21:56:24 <lambdabot>  True
21:56:25 <lambdabot>  True
21:56:31 <dataangel> sweet currying :)
21:56:33 <omnId> not False = True :)
21:56:38 <oerjan> dataangel: and seems like what you want
21:56:47 <dataangel> so I would still use a list comprehension
21:56:52 <omnId> dataangel: you've already map'd your function over the list?
21:57:04 <newsham> > not False
21:57:04 <omnId> dataangel: just pass the function directly into any
21:57:05 <lambdabot>  True
21:57:10 <oerjan> omnId: all
21:57:36 <oerjan> to check whether any are False is to check if all are True
21:57:43 <newsham> > any not [True, True, False]
21:57:45 <lambdabot>  True
21:57:49 <newsham> > any not [True, True, True]
21:57:51 <lambdabot>  False
21:58:18 <oerjan> @check \l -> any not l == not (all l)
21:58:19 <lambdabot>  Couldn't match expected type `a -> Bool'
21:58:30 <oerjan> @check \l -> any not l == not (and l)
21:58:32 <lambdabot>  OK, passed 500 tests.
21:58:34 <omnId> @check liftM2 (liftM2 (==)) (all id) (any not) :: [Int] -> [Int] -> Bool
21:58:34 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Int'
21:58:51 <newsham> that clever demorgan fella
21:58:58 <oerjan> @src all
21:58:58 <lambdabot> all p =  and . map p
21:59:02 <oerjan> @src any
21:59:02 <lambdabot> any p =  or . map p
22:04:09 <davidL> 23:53 < lambdabot>  <Plugins.Eval>:1:10: parse error on input `='  --why did that happen?
22:05:36 <geocalc> why do you ask ?
22:06:35 <davidL> > any even [1,7,3,8,9] --this was the expression that caused the error
22:06:36 <lambdabot>  True
22:07:04 <allbery_b> LB has been doing odd stuff the past few days
22:07:21 <allbery_b> that one actually makes me wonder if there's a memory problem, as opposed to an LB bug
22:07:46 <davidL> I see
22:08:08 <omnId> LB just didn't feel like it right then.  She can sometimes be a little cranky.
22:08:22 <omnId> @botsnack
22:08:22 <lambdabot> :)
22:08:35 <omnId> Treats fix everything.
22:08:52 <Syzygy-> @b
22:08:52 <lambdabot> Maybe you meant: b52s babel bf botsnack brain bug . v
22:08:55 <Syzygy-> @bo
22:08:55 <lambdabot> :)
22:09:05 <omnId> @b52s
22:09:06 <lambdabot> Watch out for that piranha. There goes a narwhale. HERE COMES A BIKINI WHALE!
22:09:27 <Syzygy-> pirahã!
22:10:36 <omnId> @bf ++++++++>++++++++[<+>-]+.
22:10:36 <lambdabot>  fd:17: hClose: resource vanished (Broken pipe)
22:10:59 <newsham> @bother the bot
22:10:59 <lambdabot> Unknown command, try @list
22:12:24 <omnId> @brain
22:12:24 <lambdabot> Well, I think so, Brain, but 'apply North Pole' to what?
22:12:46 <geocalc> @lol
22:12:47 <lambdabot> Maybe you meant: let pl url yow
22:12:51 <omnId> @. elite brain
22:12:51 <lambdabot> i +hiNk zO, brAin! Ho\/\/ much d3Eper wouLd t|-|e OCE4n Be iF theRe wER3n'+ SpON93s D0Wn 7heR3?
22:14:27 <newsham> ?b52s
22:14:27 <lambdabot> She drove a Plymouth Satellite faster than the speed of light!
22:14:52 <davidL> @. elite run map chr [65..90]
22:14:53 <lambdabot> "4Bcd3FghIJkLMnoPQrS7uv\/\/xys"
22:14:58 <ac> aah that's what's going on. You can't define arrays with infinite lists :P
22:15:17 <TSC> You can if you have infinite time and memory!
22:15:35 <ac> no you can't, You get a "*** Exception: Error in array index" as soon as you index it
22:15:56 <TSC> Oh
22:15:59 <ac> but NOT when you define it, so that confused me
22:16:05 <ac> though it shouldn't, because I knew they're lazily constructed
22:16:44 <geocalc> but indexed
22:32:25 <mgsloan> @. elite vixen how's it going?
22:32:25 <lambdabot> I7's goIng fAnt457IC
22:44:39 <dataangel> I have a function with a certain constant integer x inside it. f takes one argument, n. if n <= x, the function returns the 2-tuple (n, 0), otherwise it returns (n, n - x). So it's like n fills up the first entry in the tuple to x, and then spills over into the second entry. Is there a name for this sort of function? Presumably generalizable to two constants and three tuple return values
22:44:54 <dataangel> err, f = the function
22:45:02 * dataangel forgot to be consistent :P
22:45:47 <sarehu> dataangel: you mean (x, n - x)?
22:46:04 <dataangel> sarehu: yes, sorry :)
22:46:06 <Pseudonym> dataangel: No, but in computer graphics, there's a related function called "clamp".
22:46:14 <Pseudonym> clamp :: (Num a) => a -> a -> a -> a
22:46:24 <dataangel> Pseudodynm: Isn't clamp just a ceil and floor value?
22:46:31 <Pseudonym> Yes.
22:46:42 <dataangel> Pseudonym: how is it related?
22:46:45 <Pseudonym> But it's actually related, in the sense that you can construct this function out of the ceil operation.
22:47:03 <Pseudonym> What's it for, if I may ask?
22:47:23 <dataangel> Pseudonym: how so?
22:47:56 <dataangel> Pseudonym: I'm playing with a way of iterating over the diagonals on a chess board
22:48:08 <Pseudonym> f x n = let lo = min x n in (lo, x-lo)
22:48:16 <Pseudonym> Something like that.
22:48:51 <Pseudonym> ?pl \x n -> (min x n, x - min x n)
22:48:51 <lambdabot> ap (ap . ((,) .) . min) (liftM2 (.) (-) min)
22:49:10 <dataangel> Looks like perl to me ;p
22:53:45 <platypus> So long as wel have @pl we will never need an ofusacated haskel comp.
22:54:54 <omnId> now we need an automatic "rename everything to (?????) and change lets and wheres to lambdas" tool.
22:55:36 <dataangel> Pseudonym: I thought ceil rounded floats up to the next whole number? If anything that looks like it's using floor.
22:55:50 <dataangel> with the 'min'
22:57:32 <sarehu> dataangel: the return value of  min x y  can't be greater than y.
22:58:11 <sarehu> dataangel: well, whatever, it's late
22:58:21 <sarehu> I don't think min has anything to do with ceil or floor
22:59:44 <ac> is there a short version of (\x -> Just (foo x))? Because "Just foo" is of type "Maybe (a -> b)" which is not what I want
23:00:09 <olsner> @unpl Just . foo
23:00:09 <lambdabot> (\ c -> (Just) (foo c))
23:00:31 <ac> olsner: oh thanks
23:00:32 <olsner> @pl (\x -> f (g x))
23:00:32 <lambdabot> f . g
23:00:54 <olsner> that's composition for you
23:01:05 <sjanssen> @type ap (Just foo)
23:01:07 <lambdabot> Not in scope: `foo'
23:01:11 <sjanssen> @type ap (Just ?foo)
23:01:13 <lambdabot> forall a b. (?foo::a -> b) => Maybe a -> Maybe b
23:01:25 <dataangel> Since haskell doesn't have mutable state, is there any difference between an array and a list? Assuming we're not using unsafeIORef.
23:01:53 <ac> dataangel: faster random indexing, AFAIU
23:02:05 <sarehu> dataangel: you mean an Array?
23:02:06 <ac> dataangel: and arrays are necessarily finite
23:02:12 <sarehu> what ac said
23:02:19 <dataangel> True, but are arrays expressible in haskell?
23:02:45 <sarehu> dataangel: with import Data.Array.IO they are ;-)
23:02:50 <ac> dataangel: array (0,20) [(x,x) | x <- [0..20]]
23:03:36 <dataangel> sarehu: But doesn't that basically reduce into hardcoding somewhere in GHC to make an array?
23:03:53 <dataangel> I was trying to think of how I would make an array type
23:03:57 <omnId> > (listArray (0,9) "foobarbazy") ! 3
23:03:58 <lambdabot>  'b'
23:04:05 <dataangel> constant length and fast random access
23:04:13 <ac> I'm curious about that too. Somebody told me that in the process of compilation, everything is compiled down to "core". But arrays are a promise of an efficient underlying implementation, so how does that work?
23:04:17 <dataangel> and I realized I would just like, use a list :P
23:04:45 <dataangel> the closest I could come would be to use a record... with somehow variable number of members, all the same type
23:04:54 <dataangel> could probably do it that way in template haskell, if it's anything like template C++
23:05:04 <sarehu> dataangel: you can implement Map... array and map both have O(n^(1/3)) access in a relativistic universe anyway...
23:05:22 <dataangel> sarehu: Where'd you get that number?
23:05:29 <sarehu> 3 dimensions, speed of light
23:05:40 <dataangel> sarehu: and isn't the point of array's the wonder of O(1)? ;p
23:06:35 <sarehu> all terminating programs with bounded memory are O(1) :P
23:06:53 <Pseudonym> And with no input.
23:07:18 <sarehu> actually big O notation doesn't make sense then
23:07:45 <Pseudonym> It doesn't make sense without it.  O(1) in _what_?
23:07:48 <ac> dataangel: I'm not understanding what you want
23:10:11 <sjanssen> dataangel: arrays with O(1) access pretty much have to be compiler primitives
23:10:25 <sjanssen> in Haskell
23:10:43 <sarehu> dataangel: you can't really make an 'array' with O(1) access in a pure, no-magic Haskell setting because the indices themselves require O(log n) time to scan through.
23:10:49 <mgsloan> could be done with external stuff
23:11:07 <ac> sarehu: is ghc a "no-magic Haskell"?
23:11:17 <sjanssen> mgsloan: we can do something like unboxed arrays with the FFI
23:11:33 <mgsloan> yeah.  probably a mess for the GC though
23:12:11 <sjanssen> of course the FFI is yet another set of compiler primitives -- it doesn't really reduce the problem
23:12:25 <sarehu> ac: I mean "implementing Int from data Int = Int Bool Bool Bool Bool ... Bool" no-magic.
23:12:53 <mgsloan> hmm
23:13:16 <mgsloan> with some macroish stuff known-size arrays could be done with tuples
23:13:34 <ac> sarehu: I don't get what you're saying
23:13:45 <sarehu> ac: Int is magic, is it not?
23:14:07 <sjanssen> @src Int
23:14:08 <lambdabot> data Int = I# Int#
23:14:28 <sarehu> ac: it's not implemented in Haskell... in GHC
23:14:30 <ac> sarehu: but don't you need additional magic beyond ints to get O(1) arrays?
23:15:08 <olsner> (if I knew how, I'd bring up some pointer arithmetic in haskell)
23:15:25 <sorear> it can't be done, the best you're getting is O(log n) by a trivial counting argument
23:15:38 <sorear> seriously, it's a compiler primitive
23:17:01 <Pseudonym> Well, a library primitive.
23:17:33 <sjanssen> Pseudonym: they need some sort of special compiler support beyond H '98
23:17:48 <Pseudonym> Isn't FFI now part of H98?
23:17:52 <sjanssen> @src Array
23:17:52 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:17:53 <mgsloan> compilers and interpreters don't seem all that different.  The main difference is that interpreters also use the implementation language as the 'output language'
23:18:17 <mgsloan> anyway, it seems like converting an interpreter to a compiler in this manner wouldn't be too hard
23:18:17 <sjanssen> Pseudonym: addendum, and IIRC, you can only get unboxed arrays with it
23:18:23 <sjw> Does anyone know why Henk wasn't adopted?
23:18:59 <mgsloan> wasn't it mostly a toy language? that's what I gathered from the stuff in parsec anyway
23:20:02 <ac> what does boxed vs unboxed mean in Haskell? I thought I understand the concept of boxing, but I also thought Haskell's type system eliminated the need for boxing
23:20:10 <ac> s/understand/understood
23:20:20 <sjanssen> is an interpreter a deforested compiler?
23:20:23 <mgsloan> hmm, or perhaps it was hank that's in the parsec sources
23:20:45 <sjw> well, Henk is somewhat toylike, in that it osm
23:20:45 <sjanssen> ac: Haskell '98 doesn't have the concept of unboxed
23:20:48 <sjw> isn't core
23:20:49 <Pseudonym> sjanssen: A compiler is a partially evaluated interpreter.
23:21:40 <dataangel> sarehu: What do you mean by 'scan through' for the indices?
23:21:46 <ac> sjanssen: that doesn't answer my question. I thought boxing was storing a type along with a value, but because Haskell is statically typed, why is that necessary?
23:22:06 <sjanssen> ac: boxing isn't storing a type with a value
23:22:07 <dataangel> sarehu: you mean to iterate through the indices themselves if they're in a list?
23:22:19 <mgsloan> I thought boxing had to do with storing a reference to it
23:22:33 <olsner> ac: the box contains a value or unevaluated value; i.e. the thing that enables lazy evaluation
23:22:57 <sjanssen> ac: boxes are basically pointers.  When I have an Int in Haskell, it isn't actually a machine int, it's a pointer to a box holding a machine int
23:23:18 <sjanssen> (or a pointer to a routine that will yield a box holding a machine int when executed)
23:23:39 <sarehu> dataangel: I mean to look at all the information in the indices
23:23:44 <ac> sjanssen: ah. So "boxing" in haskell means something else than it typically does in other languages
23:23:45 <dataangel> sjanssen: I can see the reason in some languages for having boxing, like for an identity comparison, but since Haskell is stateless I don't get it
23:24:04 <sjanssen> dataangel: we need boxing for laziness
23:24:10 <dataangel> sarehu: Why log n? Isn't list access O(n)?
23:24:32 <mgsloan> ac - as far as I know, no.  Most times I hear about boxing, it's the same.  the difference is that we use boxing for laziness and others usually don't
23:24:40 <ac> So if I understood what was said earlier, O(1) arrays are only possible in GHC with unboxed values?
23:24:43 <olsner> is a "box" at all different from "thunks"?
23:25:20 <mgsloan> no, only possible with a compiler primitive or external libs which provide a non-ideal implementation
23:25:29 <olsner> (*are "boxes"), or (*a "thunk")
23:25:30 <sjanssen> ac: no, I was saying that arrays implemented via the FFI can only contain unboxed values
23:25:37 <geocalc> dataangel-> read yaht
23:25:51 <sjanssen> ac: GHC provides a compiler primitive for boxed arrays with O(1) access
23:26:07 <ac> sjanssen: ok, that's what I was wondering
23:26:19 <mgsloan> olsner - my guess is that thunks are the breed of boxes that represent an unevaluated computation
23:26:35 <dataangel> geocalc: yaht?
23:26:35 <sjanssen> olsner: a thunk is a potential value of a box
23:26:38 * dataangel googles
23:27:05 <geocalc> @where yaht
23:27:05 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
23:27:36 <mgsloan> data Box = Thunk Pointer | Value Pointer
23:27:45 <twifkak> @users
23:27:45 <lambdabot> Maximum users seen in #haskell: 420, currently: 347 (82.6%), active: 13 (3.7%)
23:27:51 <sjanssen> mgsloan: I don't think that is right
23:27:59 <mgsloan> yeah, it probably isn't
23:28:05 <mgsloan> good way of expressing it though
23:28:18 <dataangel> err, I've looked at that before, I don't recall it explaining anything about array speed in Haskell or why values need boxing, but I didn't read it thoroughly...
23:28:27 <sjanssen> mgsloan: given a box, you need to dereference it before determining whether it's thunk or value
23:28:40 <mgsloan> oh, hmm
23:29:03 <mgsloan> I suppose if you include a header byte/int that could work
23:29:08 <sjanssen> actually, we might be getting sloppy with terminology
23:29:42 <mgsloan> seems like you could use a flag to store value/thunk
23:29:52 <sjanssen> not in the pointer
23:29:53 <mgsloan> don't you have the bottom 2 bits free, or something
23:30:39 <mgsloan> if things are 4-byte aligned
23:30:49 <sjanssen> yes
23:31:13 <sjanssen> you can't encode this stuff in pointers because thunks can turn into values at any time
23:31:41 <mgsloan> oh
23:31:59 <mgsloan> so thunks may have multiple boxes?
23:32:12 <sjanssen> I don't think so
23:32:23 <sjanssen> a thunk is just a particular class of box
23:32:52 <mgsloan> yeah, that's what I attempted to express with my data Box =
23:33:04 <sjanssen> my issue is with the Pointer part
23:33:10 <mgsloan> oh
23:33:50 <sjanssen> IIRC, here's how boxes look in GHC: struct { bool evaluated; byte[] hunk_of_data; }
23:34:06 <mgsloan> aha
23:34:34 <sjanssen> when evaluated = false, hunk_of_data represents a function application structure (argument list and function pointer)
23:34:37 <mgsloan> so is that the box, or is there a box somewhere pointing to this?
23:35:02 <mgsloan> or both?!
23:35:09 <sjanssen> when evaluated = true, hunk_of_data is the actual values of the data
23:35:20 <sjanssen> mgsloan: I'd call that struct the box
23:35:29 <mgsloan> alright
23:35:37 <sjanssen> and the values we usually pass around are pointers to boxes
23:35:44 <mgsloan> right
23:35:49 <mgsloan> ok, I think I got it. thanks
23:38:22 <mgsloan> so, partial application would be represented as a thunk pointing to a function returning a thunk?  or would it add to the param list of the thunk?
23:38:34 <mgsloan> perhaps this is an implementation detail..
23:38:43 <mgsloan> to me, for the most part GHC == haskell, though
23:39:25 <ac> @hoogle a -> [(a -> b)] -> [b]
23:39:26 <lambdabot> No matches, try a more general search
23:39:41 <dmwit> :t map . ($)
23:39:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:39:55 <dmwit> :t ap
23:39:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:40:06 <dmwit> :t map . flip ($)
23:40:08 <lambdabot> forall a b. a -> [a -> b] -> [b]
23:40:17 <dmwit> There we go.
23:40:34 <ac> dmwit: nice
23:41:05 <omnId> @ty flip sequence
23:41:07 <lambdabot> forall a b. b -> [b -> a] -> [a]
23:41:18 <sarehu> mgsloan: I'd like to think it depends on the circumstances and would usually be neither
23:41:35 <dmwit> Wait, what?
23:41:39 <dmwit> :t sequence
23:41:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:41:48 <omnId> where m = (b ->)
23:41:53 <TSC> flip forces it into the Reader monad
23:42:01 <dmwit> Wow, that's magical.
23:42:17 <TSC> It's just type inference (:
23:42:34 <mgsloan> 0_o
23:42:38 <mgsloan> :t flip
23:42:40 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:42:45 <dmwit> > flip sequence 1 [(+1), (*2)]
23:42:46 <lambdabot>  [2,2]
23:43:05 <mgsloan> I don't see why flip would force sequence into the reader monad
23:43:16 <mgsloan> ohh
23:43:20 * mgsloan sees the light
23:43:21 <dmwit> Because sequence only has one argument... =)
23:43:22 <omnId> sequence hooks together actions with (>>=).  Reader actions share a common argument.
23:43:27 <mgsloan> indeed
23:43:45 <dmwit> omnId++
23:43:55 <mgsloan> that's pretty intense
23:43:59 <omnId> :D
23:44:17 <omnId> just hookin' up types!
23:44:20 <sjanssen> mgsloan: IIRC, GHC has special representations for functions that aren't fully saturated
23:44:30 <mgsloan> oh, interesting
23:44:49 <sjanssen> but I can never keep track of this stuff, there should be information on the wiki or one of the papers
23:45:25 <sjanssen> the recent pointer tagging paper has lots of gritty details on the heap representation and execution model used in GHC
23:46:03 <mgsloan> oh, cool
23:48:05 * ac does not attempt to understand "flip sequence"
23:48:20 <olsner> :t sequence
23:48:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:48:23 <olsner> :t flip sequence
23:48:24 <lambdabot> forall a b. b -> [b -> a] -> [a]
23:48:32 <omnId> [m a] is unified with [b -> a]
23:49:00 <omnId> [b -> a] is also written [((->) b) a]
23:49:11 <omnId> thus the ((->) b) monad instance is picked
23:49:11 <dmwit> :t sequence :: [b -> a] -> b -> [a]
23:49:13 <lambdabot> [b -> a] -> b -> [a] :: forall b a. [b -> a] -> b -> [a]
23:49:25 <omnId> @src (->) (>>=)
23:49:25 <lambdabot> f >>= k = \ r -> k (f r) r
23:49:41 <omnId> ugly, but it just passes the common argument r to both actions.
23:49:46 <dmwit> omnId: That last (>>=) definition is a bit dense... =/
23:51:15 <omnId> (+2) >>= (\x -> (*3)) = \ r -> (\x -> (*3)) ((+2) r) r
23:51:50 <dmwit> :t \x -> (*3)
23:51:52 <lambdabot> forall t a. (Num a) => t -> a -> a
23:51:57 <omnId> = \ r -> (*3) r = (*3), in this case
23:52:16 <omnId> I didn't do anything useful with (+2)'s result
23:52:29 <dmwit> ok
23:52:51 <omnId> @src sequence
23:52:51 <lambdabot> sequence ms = foldr k (return []) ms
23:52:51 <lambdabot>     where
23:52:51 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
23:53:09 <omnId> @undo  do { x <- m; xs <- m'; return (x:xs) }
23:53:10 <lambdabot> (m >>= \ x -> m' >>= \ xs -> return (x : xs))
23:53:21 <omnId> here the results are consed up.
23:53:36 <omnId> @src (->) return
23:53:37 <lambdabot> return = const
23:53:43 <omnId> that just ignores the final r
23:57:56 <ac> @seen quicksilver
23:57:57 <lambdabot> quicksilver is in #haskell and #ghc. I don't know when quicksilver last spoke.
23:59:22 <sjw> sjanssen: don't forget about garbage collection ...
23:59:30 <sjanssen> sjw: hmm?
