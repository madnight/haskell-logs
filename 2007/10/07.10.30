00:00:43 <ivanm> :( spoilsport! :p
00:06:40 <newsham> hi goalieca
00:07:18 <goalieca> newsham, hello
00:08:11 <newsham> this might be useful: http://trac.browsershots.org/browser/trunk/pypng/lib/png.py
00:08:15 <lambdabot> Title: /trunk/pypng/lib/png.py - Browsershots - Trac
00:08:51 <newsham> for color you just have to adjust the bytes per sample and write out rgb values
00:09:11 <newsham> and change the color-type value
00:57:48 <ivanm> @type array
00:57:50 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
00:58:15 <ivanm> is there list version of (!) ? or would I just use it with a fold?
00:58:38 <glguy> !!
00:58:51 <profmakx> hm isnt !! evil?
00:59:03 <nornagon> > [] !! 3
00:59:03 <glguy> as evil and head and tail
00:59:05 <lambdabot>  Exception: Prelude.(!!): index too large
00:59:15 <profmakx> hm
00:59:25 <profmakx> > head []
00:59:26 <lambdabot>  Exception: Prelude.head: empty list
00:59:29 <profmakx> right
00:59:34 <glguy> and runs in time proportional to the index
00:59:34 <ivanm> I mean, instead of (!) :: (Ix i) => Array i e -> i -> e, I want something like: (Ix i) => Array i e -> [i] -> [e]
00:59:50 <nornagon> :t map
00:59:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:59:53 <profmakx> @src (!!)
00:59:53 <lambdabot> xs     !! n | n < 0 = undefined
00:59:53 <lambdabot> []     !! _         = undefined
00:59:53 <lambdabot> (x:_)  !! 0         = x
00:59:53 <lambdabot> (_:xs) !! n         = xs !! (n-1)
00:59:54 <ivanm> duh!
00:59:59 <nornagon> ivanm: :)
00:59:59 <sjanssen> ivanm: just use map (array!)
00:59:59 <profmakx> although i suspect it :)
01:00:02 <ivanm> didn't think about that :s
01:00:16 <nornagon> haskell is so cool :)
01:00:34 <ivanm> though it would be nice to have one that is a single pass through the array and list of indices (if you can guarantee that they are sorted)
01:00:54 <profmakx> and as of this moment i think i finally have a bootstrapped version of ghc 6.6.1 on freebsd7/amd664
01:01:21 <nornagon> ivanm: you don't 'pass' through arrays
01:01:26 <nornagon> ! is O(1)
01:01:44 <ivanm> is it? I keep thinking arrays are wrappers around lists with indices :s
01:01:57 <nornagon> no, that's (!!)
01:02:01 <glguy> yeah, its constant time lookup, linear time update
01:02:03 <ivanm> yeah
01:02:12 <ivanm> why is update linear?
01:02:14 <nornagon> arrays are like arrays in C, only typesafe and static
01:02:22 <nornagon> because you can't change stuff outside of IO
01:02:28 <nornagon> referential transparency must be preserved!
01:02:30 <glguy> ivanm: immutable arrays have to be copied to be "changed"
01:02:35 <nornagon> although
01:02:36 <ivanm> ahhh, true
01:02:40 <nornagon> you can have IOArrays
01:02:48 <nornagon> which are constant lookup, constant update
01:02:57 <ivanm> but that's a guaranteed time taken, rather than worst-case?
01:03:06 <nornagon> yep
01:03:10 <ivanm> *nod*
01:03:16 <nornagon> that's why it's called RAM, baby :)
01:03:32 * ivanm tries to remember what the symbol for that is... capital Omega = best case, O = worst case... what's average case?
01:03:32 <nornagon> i guess you could say it's worst-case when stuff needs to be paged in
01:03:36 <ivanm> heh
01:04:13 <asmanur> How can i divide two ints and get an int ?
01:04:18 <profmakx> div
01:04:29 <ivanm> > 4 `div` 2
01:04:30 <profmakx> > 4 `div` 2
01:04:31 <lambdabot>  2
01:04:31 <lambdabot>  2
01:04:32 <ivanm> heh
01:04:32 <profmakx> hm
01:04:34 <asmanur> doh
01:04:42 <profmakx> @type 4 `div` 2
01:04:43 <lambdabot> forall t. (Integral t) => t
01:04:49 <ivanm> @type div
01:04:50 <asmanur> thanks ^^
01:04:50 <lambdabot> forall a. (Integral a) => a -> a -> a
01:04:59 <sjanssen> ivanm: Omega/O/Theta are not about best/worst/average case
01:05:14 <ivanm> they aren't?
01:05:18 <profmakx> no
01:05:31 <sjanssen> Omega is a lower bound, O is an upper bound, Theta is both Omega and O (a tight bound)
01:05:31 <profmakx> they are about asymptotics
01:05:32 <ivanm> so does that mean 1) my lecturer was wrong, or 2) I misremembered all that stuff?
01:05:35 <ivanm> ahh, yes
01:05:57 <ivanm> well, I just remember O = worst case, etc.
01:06:02 <quicksilver> nornagon: RAM doesn't have constant time access, on modern architectures
01:06:09 <ivanm> as in it can't be worse than O
01:06:10 <sjanssen> ivanm: don't remember that, it's wrong :)
01:06:12 <profmakx> so, something O(2^n) can well be better than O(n^k)
01:06:15 <profmakx> for small n
01:06:21 <profmakx> and appropriate k :)
01:06:23 <ivanm> yeah
01:06:27 <nornagon> quicksilver: oh?
01:06:50 <quicksilver> nornagon: modern architectures all have MMUs, so memory access is virtualised
01:06:56 <nornagon> ah, good point
01:06:59 <sjanssen> O(n^k) is a subset of O(2^n)
01:07:02 <quicksilver> very roughly you might say it's O(log n)
01:07:12 <nornagon> i've been doing a lot of coding for the DS these days
01:07:16 <quicksilver> although is' quite discontinuous
01:07:16 <nornagon> which has no MMU
01:07:31 <profmakx> sjanssen, i did not doubt that
01:07:35 <quicksilver> ah yes :) True. For that kind of arch it really is linear.
01:07:37 <quicksilver> erm relaly constant, I mean.
01:08:31 <quicksilver> but as I'm prone to say at least once a day on this channel, worry about the difference between O(n) and O(log n) probably isn't woth it
01:08:34 <quicksilver> argh!
01:08:41 <quicksilver> O(n) and O(n log n) I mean :)
01:10:06 <profmakx> hm, does anyone know if the linker/ghci for freebsd amd64 is fixed in 6.8?
01:11:51 <osfameron> good morning
01:12:02 * osfameron was playing with points free stuff last night
01:12:18 <osfameron> and I really dislike the ugliness of making a binary function pointless
01:12:28 <osfameron> like ((>2).) .
01:12:48 <osfameron> is there already a converter defined like:  f .-- g = (f.) . g
01:13:15 <Saizan> not in the standard library
01:13:18 <osfameron> so you can do:  (>2) .-- (+)   (which seems more natural to me, well, the operator symbol itself is rubbish)
01:13:29 <osfameron> do people tend to define it themselves?
01:13:39 <osfameron> or just learn to live with the weird .). thing ?
01:13:40 <Saizan> it's usually called .: here
01:13:53 <osfameron> ah ok, I guessed there'd be some convention or other :-)
01:15:28 <roconnor> @type (.).(.)
01:15:34 <osfameron> (.:) is certainly a nicer name for it
01:15:37 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:16:11 <roconnor> the 3 dots in .: represent the three dots in (.).(.) ?
01:16:21 <nornagon> :t (.).(.)$ (>2) (+)
01:16:22 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
01:16:23 <lambdabot>     In the second argument of `($)', namely `(> 2) (+)'
01:16:28 <osfameron> the boobies combinator!
01:16:36 <profmakx> :]
01:17:06 <glguy> I don't think that (f .) . g   occurs much outside of IRC code
01:17:06 <nornagon> :t (.).(.) (>2) (+)
01:17:07 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
01:17:07 <lambdabot>     In the second argument of `(.)', namely `(.) ((> 2)) (+)'
01:17:17 <nornagon> oh well
01:17:24 <roconnor> :t ((.).(.)) (>2) (+)
01:17:25 <lambdabot> forall a. (Ord a, Num a) => a -> a -> Bool
01:18:05 <Saizan> roconnor: or the arity of the functions
01:18:26 <roconnor> Saizan: oh
01:18:43 <roconnor> although that means compose ought to be ..
01:18:50 <roconnor> bah, we should justise liftM2
01:18:54 <roconnor> just use
01:19:02 <osfameron> @type let (.:) = (.).(.) in (>2) .: (+)
01:19:04 <lambdabot> forall a. (Ord a, Num a) => a -> a -> Bool
01:19:18 <roconnor> (>2) `liftM2` (+)
01:19:23 <roconnor> :T (>2) `liftM2` (+)
01:19:32 <roconnor> @type (>2) `liftM2` (+)
01:19:33 <lambdabot>     Couldn't match expected type `a2 -> r' against inferred type `Bool'
01:19:33 <lambdabot>     In the first argument of `liftM2', namely `(> 2)'
01:19:38 <roconnor> oh
01:19:39 <roconnor> :(
01:19:52 <roconnor> never mind
01:19:56 <olsner> @pl (.).(.)
01:19:57 <lambdabot> (.) . (.)
01:20:02 <doserj> the 2 in liftM2 has a meaning...
01:20:06 <nornagon> @unpl (.).(.)
01:20:06 <lambdabot> (\ i b c f -> i (b c f))
01:20:21 <nornagon> @unpl (.).(.)
01:20:21 <lambdabot> (\ i b c f -> i (b c f))
01:20:22 <olsner> @ty liftM2 (> 2)
01:20:23 <lambdabot>     Couldn't match expected type `a2 -> r' against inferred type `Bool'
01:20:23 <lambdabot>     In the first argument of `liftM2', namely `(> 2)'
01:20:26 <nornagon> why those letters, i wonder
01:20:47 <ivanm> nornagon: why don't you ask whoever wrote the plugin?
01:21:01 <nornagon> ivanm: i cbf
01:21:05 <doserj> a1 is the 2 in (>2), i suppose.
01:21:19 <roconnor> it's supposed to be \i c f p -> i (c f p)
01:22:38 <olsner> @pl \x y -> f (g x y)
01:22:39 <lambdabot> (f .) . g
01:23:02 <dibblego> can runhaskell in GHC 6.6.1 run files without the .hs extension (I know that 6.6 can't)?
02:10:48 <tiglionabbit> if you have a list of numbers, how can you write a function that takes that list and calls itself with the same list sans one number in it, for every number in the list?  That is, the opposite of map.
02:11:19 <roconnor> tiglionabbit: I wrote a function like that once
02:11:33 <tiglionabbit> rather than calling a function for each number in the list, it calls the function for each subset of the list that is missing that number
02:11:38 <tiglionabbit> oh, do tell
02:11:58 <osfameron> map  on iterate tails ?
02:12:08 <dmwit> tiglionabbit: First step is to write a function :: [a] -> [[a]] that makes all the sub-lists.
02:12:10 <dmwit> Then just call map.
02:12:14 <roconnor> tiglionabbit: let's just make a list of lists missing each element.
02:12:19 <dmwit> osfameron: It has to have the head, too.
02:12:21 <roconnor> like dmwit says
02:12:31 <roconnor> and reason about such a function
02:12:37 <roconnor> recursively
02:12:41 <tiglionabbit> okay
02:12:46 <roconnor> what does [] create
02:12:53 <tiglionabbit> an empty list
02:13:04 <roconnor> what does x:xs create assuming you have access to the answer for xs.
02:13:24 <tiglionabbit> x = first, xs = the rest
02:13:31 <tiglionabbit> of an argument
02:13:40 <dmwit> tiglionabbit: He means, what should our function give?
02:13:57 <tiglionabbit> or wait, that's when pattern matching.  : is cons
02:14:00 <roconnor> soo your recursive call on xs gives you a list of all lists missing each element of xs.
02:14:16 <roconnor> but now you are dealing with x:xs
02:14:37 <roconnor> so the result of the recursive call (foo xs) needs to have x tacked on the front of each of them
02:15:01 <roconnor> now you have almost everything
02:15:07 <roconnor> but you need the list that is missing x
02:15:11 <roconnor> that is just xs
02:15:17 <tiglionabbit> huh...
02:15:25 * roconnor isn't a very good teacher
02:15:32 <tiglionabbit> I am a little confused, but I am new to haskell so that is to be expected
02:15:37 * osfameron isn't sure how this is different to tails though
02:15:41 <osfameron> > tails [1,2,3]
02:15:43 <lambdabot>  [[1,2,3],[2,3],[3],[]]
02:15:51 <tiglionabbit> it's not tails
02:15:56 <roconnor> osfameron: we want [[2,3],[1,3],[1,2]]
02:16:01 <tiglionabbit> yeah
02:16:06 <osfameron> ah, ok!
02:16:28 <quicksilver> roconnor is describing a rather elegant recursive algorithm
02:16:29 <osfameron> yeah, I think I've written that too once (maybe for one of the euler questions)
02:16:31 <roconnor> tiglionabbit: okay, we have foo [] = [] like you noted to begin with.
02:16:31 <dmwit> > (\xs -> zip (tails xs) (inits xs)) [1,2,3] -- hmmm, this might be interesting
02:16:32 <lambdabot>  [([1,2,3],[]),([2,3],[1]),([3],[1,2]),([],[1,2,3])]
02:16:41 <quicksilver> however you don't necessarily need to do it with hand-recursion
02:16:44 <matthew-_> > do { let l = [1,2,3]; x <- l; y <- l; return . nub $ [x,y] }
02:16:44 <lambdabot>  Parse error at "<-" (column 25)
02:16:50 <quicksilver> you can use list comprehension rather simply
02:17:00 <matthew-_> > do let l = [1,2,3]; x <- l; y <- l; return . nub $ [x,y]
02:17:00 <lambdabot>  Parse error at "<-" (column 23)
02:17:00 <roconnor> tiglionabbit: now need need to figure out what foo (x:xs) is
02:17:03 <matthew-_> eh?
02:17:11 <dmwit> matthew-_: Needs braces.
02:17:26 <roconnor> we can recursively call (foo xs)
02:17:30 <quicksilver> > let l = [1,2,3,4] in [ l \\ [a] | a <- l ]
02:17:31 <dmwit> oh wait
02:17:31 <lambdabot>  [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
02:17:34 <tiglionabbit> what is foo(x:xs)? is that really what we want?
02:17:39 <quicksilver> as long as the items are unique
02:18:03 <tiglionabbit> hm.  That is a solution, quicksilver.  However, I don't understand it...
02:18:17 <tiglionabbit> \\ ?
02:18:21 <roconnor> (foo xs) is all the list of all xs with one element missing
02:18:33 <roconnor> but we want a list of (x:xs) with one element missing
02:18:42 <tiglionabbit> true
02:18:45 <roconnor> x doesn't occur in any of (foo xs)
02:18:46 <dmwit> > (\xs -> zipWith (\x y -> x ++ tail y) (inits xs) (tails xs)) [1,2,3]
02:18:48 <lambdabot>  Exception: Prelude.tail: empty list
02:18:52 <roconnor> so that is one problem we need to fix up
02:19:01 <roconnor> we can do with with map (x:) (foo xs)
02:19:12 <roconnor> that puts x onto the head of each element of (foo xs)
02:19:57 <roconnor> so now we have a list of sublist of (x:xs) missing all the elements of xs
02:20:08 <tiglionabbit> okay.  But that just makes the same list again, doesn't it...?
02:20:18 <roconnor> but we need one more list the list that is missing x
02:20:24 <roconnor> so we tack that on the front
02:20:38 <roconnor> foo (x:xs) = xs:(map (x:) (foo xs))
02:20:43 <roconnor> foo [] = []
02:20:47 <roconnor> and we are done
02:20:53 <roconnor> tiny
02:21:21 <matthew-_> > zipWith id (map (\x -> filter (/= x)) [1..]) (replicate 4 [1,2,3,4])
02:21:22 <roconnor> and as quicksilver noted, elegent.
02:21:24 <lambdabot>  [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
02:21:29 <matthew-_> lol, a horrid solution by me!
02:22:00 <roconnor> tiglionabbit: with a bit of practice you can learn to reason out these programs yourself :)
02:22:11 <tiglionabbit> I hope so
02:22:17 <tiglionabbit> but I am still a bit boggled by it...
02:22:28 <roconnor> tiglionabbit: being boggled is a natural.
02:22:30 <tiglionabbit> and I feel like I'll break it as soon as I try to change it
02:22:41 <tiglionabbit> if it works...
02:23:09 <roconnor> let foo [] = []; foo (x:xs) = xs:(map (x:) (foo xs)) in foo [1,2,3,2,4]
02:23:13 <roconnor> > let foo [] = []; foo (x:xs) = xs:(map (x:) (foo xs)) in foo [1,2,3,2,4]
02:23:13 <tiglionabbit> erk, maybe I shouldn't use this language.  It is so hard for me to think about.
02:23:15 <lambdabot>  [[2,3,2,4],[1,3,2,4],[1,2,2,4],[1,2,3,4],[1,2,3,2]]
02:23:27 <geocalc> well i don't think roconnor will solve subset problems in P time for now
02:23:46 <geocalc> hehe
02:24:09 <roconnor> tiglionabbit: relax, it will take a while for this style to sink in
02:24:36 <roconnor> tiglionabbit: It feels a bit like cheating that we assume that (foo xs) magically properly even though we are in the middle of defining it.
02:25:03 <roconnor> ... (foo xs) works magically ...
02:25:25 <tiglionabbit> so wait a sec.  What is x: ?
02:25:31 <tiglionabbit> like (x:)
02:25:34 <roconnor> tiglionabbit: good question
02:25:41 <geocalc> head
02:25:42 <roconnor> > 1:[2,3]
02:25:45 <lambdabot>  [1,2,3]
02:25:58 <tiglionabbit> oh.  So that's the same as x:_ ?
02:26:10 <roconnor> tiglionabbit: (x:) is \y -> x:y
02:26:26 <roconnor> this work for binary operators in haskell
02:26:35 <roconnor> > (10+)  5
02:26:36 <lambdabot>  15
02:26:41 <roconnor> > (10*)  5
02:26:43 <lambdabot>  50
02:26:48 <roconnor> > map (10*)  [1,2,3]
02:26:49 <lambdabot>  [10,20,30]
02:26:58 <roconnor> > map (\y -> 10*y)  [1,2,3]
02:27:00 <lambdabot>  [10,20,30]
02:27:15 <tiglionabbit> okay I think I need to take this slowly
02:27:25 <tiglionabbit> and figure out that thing first...
02:27:25 <roconnor> tiglionabbit: if it makes you feel more comforable then write...
02:27:36 <roconnor> foo (x:xs) = xs:(map f (foo xs))
02:27:36 <roconnor>  where
02:27:45 <roconnor>    f y = x:y
02:29:49 <tiglionabbit> 'where' is another feature I haven't used yet.  hm.  Back to the tutorials...
02:31:44 <tiglionabbit> er, where should I look for the definition of where?
02:33:30 <asmanur> tiglionabbit: it's a keyword, xs:(map f (foo xs)) where f y = x:y is equivalent to let f y = x:y in xs:...
02:33:42 <tiglionabbit> hm.  This operation I want seems to be pretty awkward to do with singly linked lists
02:34:06 <tiglionabbit> no wait
02:34:18 <dmwit> No, it's perfect for them! =)
02:34:20 <tiglionabbit> immutable singly linked lists.  If I could just change a link it would be very easy...
02:34:38 <tiglionabbit> but this solution seems so roundabout to me
02:34:45 <tiglionabbit> am I wrong?
02:34:56 <quicksilver> it takes a while to appreciate immutability
02:35:02 <quicksilver> but it really is rather cool
02:35:15 <quicksilver> note that your lists have some data-sharing; they share their ends
02:35:57 <nornagon> there is only one []
02:36:35 <tiglionabbit> oh neat
02:37:02 <roconnor> quicksilver: ah, so the resulting list of list occupy n^2/2 space?
02:37:38 <dmwit> tiglionabbit: Watch this!
02:37:50 <dmwit> > liftM2 (zipWith (++)) (init . inits) (tail . tails) [1,2,3]
02:37:52 <lambdabot>  [[2,3],[1,3],[1,2]]
02:38:06 <quicksilver> roconnor: roughly, yes
02:39:35 <tiglionabbit> init and inits?
02:39:44 <dmwit> > init [1,2,3]
02:39:45 <lambdabot>  [1,2]
02:39:49 <dmwit> > inits [1,2,3]
02:39:50 <lambdabot>  [[],[1],[1,2],[1,2,3]]
02:40:54 <dmwit> tiglionabbit: It might be (slightly) easier to decrypt this version, which is what I started with:
02:41:16 <dmwit> > (\xs -> (zipWith(++)) (init $ inits xs) (tail $ tails xs)) [1,2,3]
02:41:18 <lambdabot>  [[2,3],[1,3],[1,2]]
02:41:52 <tiglionabbit> hehe.  hm.  How can I get used to using haskell?  I am still having trouble with these...
02:41:53 <dmwit> So (init . inits) builds the partial beginning lists, and (tail . tails) builds the partial ending lists.
02:42:46 <dmwit> tiglionabbit: Don't worry!  It's really easy to get used to Haskell.  All you have to do is use it. =)
02:43:01 <tiglionabbit> yeah but..   what can I do that's simple enough...
02:43:13 <dmwit> Hanging around here helps a lot, too.
02:43:20 <tiglionabbit> =]
02:43:20 <dmwit> tiglionabbit: Have you had a crack at Project Euler?
02:43:26 <tiglionabbit> no
02:43:38 <tiglionabbit> *googles*
02:43:40 <dmwit> Those are some fun puzzles, and they're pretty language-agnostic.
02:44:55 <TSC> I agree; Project Euler helped me to learn Haskell
02:45:34 <osfameron> dmwit: that's cute
02:45:48 <dmwit> thx =)
02:46:11 <mr_tenor> i thought the traditional way was writing a monad tutorial
02:46:11 <tiglionabbit> hehe.  Guess I wont be using haskell for this assignment then.  What got me playing with this was an assignment in tech writing to clean up and document some extremely minimal C code.  After looking at the C code and spending some time figuring out what it did, I realized it really was an incomplete solution to the problem it was supposed to solve, and I wanted to solve it properly.  Though, the right way took far more recursion.
02:46:28 <tiglionabbit> but uh, solving it in haskell but not being able to explain or document it would be bad form for a writing assignment
02:46:36 <dmwit> haha
02:46:48 <roconnor> tiglionabbit: dmwit's solution is pretty clear and easy to write; I sort of recommend it.
02:47:14 <dmwit> tiglionabbit: Do you want to run through my thought process while I was building that solution?
02:47:33 <roconnor> tiglionabbit: But I was answering your question which was something like, how did I do it. :)
02:48:10 <tiglionabbit> thank you guys for showing me this stuff.  I really want to learn haskell better so I can do this...
02:51:28 <tiglionabbit> or, thinking in functional programming languages in general.  First programming I ever learned was by teaching myself C, but I later got hooked on ruby because it's so easy, and used JavaScript (which is really a decent language despite popular opinion) for my internship last summer.  Now learning functional languages is hard, but I need to get better
02:52:09 <roconnor> the typical style of programming in functional languages can be difficult to pick up
02:52:16 <roconnor> ... stupid continuations.
02:52:43 <roconnor> ``Still, I have no intuition about the run time effects of using CPS. What good is my degree in computer science?
02:53:41 <matthew-_> degrees in compsci cover less than you are taught in maths between the ages of 4 and 18
02:53:50 <matthew-_> unsurprisingly so
02:54:17 <dmwit> My degree covers much more than that.
02:54:31 <matthew-_> you reckon?
02:54:35 <dmwit> Maybe I wasn't taught enough in high school maths. =P
02:54:47 <dmwit> Oh, wait.
02:55:14 <dmwit> You mean, you cover less new material in a degree than in the first 18 years of life?
02:55:23 <dmwit> That I might believe.
02:55:26 <matthew-_> indeed
02:55:42 <tiglionabbit> ugh.  I am really questioning mine.  They start us off on braindead programming in Java, but I skipped that class to get to the next one, which is about writing C in 1970.  After that is a class about memorizing induction proofs about graph theory, and more C.  Then it's open ended, but no class teaches you anything but C or Java except "comparative programming languages", which got me interested in this stuff.
02:55:49 <roconnor> matthew-_: I also have a degree in pure mathematics :P
02:56:15 <matthew-_> like, if you went into a "maths job" after leaving school, I think you'd be better prepared than if you went into a "computer sci" job after an undergrad degree
02:56:23 <dmwit> tiglionabbit: Yeah, Java and C/C++ seem to be the staple languages here, too. =/
02:56:24 <matthew-_> roconnor: show off ;)
02:56:48 <roconnor> matthew-_: my point is that I still don't understand the run time effect of continuation passing style. :)
02:57:07 * wli also got a degree in pure mathematics.
02:57:35 <roconnor> so either I'm stupid and degrees are worthless, or understanding some of these programing styles is difficult.
02:57:36 * wli didn't learn anywhere near as much as he should have for that.
02:57:59 <wli> Nor for the CS degree.
02:58:23 <roconnor> wli: you have the same degrees I have?
02:58:33 <osfameron> roconnor: is understanding CPS useful?  (genuine question: it's not on my current list of "things to learn")
02:58:41 * wli has only done undergrad study.
02:58:53 <roconnor> osfameron: did you see http://r6.ca/blog/20071028T162529Z.html ?
02:58:54 <lambdabot> Title: Continuation Passing Style for Monads
02:59:16 <roconnor> osfameron: I was about to dismess CPS as not useful in a lazy langauge.
02:59:35 <matthew-_> presumeably the "run time effects" are that there may be lots of longjmps
02:59:44 <roconnor> osfameron: but this recent experience indicates otherwise.
02:59:54 <matthew-_> but otherwise you're just passing around a lot of pointers to code. no?
03:00:07 <roconnor> matthew-_: I don't use callCC at all.
03:00:12 <osfameron> roconnor: ah, yes, I did see that, but didn't understand it :-)
03:00:40 <roconnor> osfameron: all that I really understand is ``CPS made my program 4 times faster''.
03:00:51 <osfameron> like go-faster stripes
03:00:57 <roconnor> osfameron: and thereofer understanding CPS may be useful.
03:01:12 <roconnor> osfameron: speed holes.  they make your car go faster.
03:01:20 <osfameron> roconnor: yeah, fair enough.  Maybe I'll pick up the Little Schemer, in this mythical copious free time that I'm goign to actually get to study...
03:01:41 <tiglionabbit> what's odd though is uh
03:01:44 <roconnor> osfameron: bear in mind I don't fully undertand CPS.
03:03:03 <tiglionabbit> I interned at AOL last summer, and the other javascript programmer on my team acted impressed with my "computer science knowledge" when I suggested we actually use some object oriented techniques here because javascript does indeed support closures, despite popular belief (and his belief =\).
03:03:03 * araujo wonders if terminateProcess is a good option to kill a process
03:03:28 <araujo> so far .. i can't find another function to kill a process using its ProcessHandle ...
03:03:31 <roconnor> @hoogle terminateProcess
03:03:31 <lambdabot> System.Process.terminateProcess :: ProcessHandle -> IO ()
03:03:48 <roconnor> @hoogle ProcessHandle
03:03:48 <lambdabot> System.Process.ProcessHandle :: data ProcessHandle
03:03:52 <roconnor> @hoogle ProcessHandle -> a
03:03:52 <lambdabot> No matches, try a more general search
03:03:56 <roconnor> :(
03:04:02 <quicksilver> roconnor: CPS making your program go faster is a specific property of your implementation
03:04:02 <roconnor> @hoogle ProcessHandle -> *
03:04:02 <lambdabot> Hoogle Error: Parse Error: Unexpected character '*'
03:04:06 <araujo> @hoogle ProcessHandle -> IO ()
03:04:07 <lambdabot> System.Process.terminateProcess :: ProcessHandle -> IO ()
03:04:11 <quicksilver> roconnor: rather than anything fundamental about CPS
03:04:13 <araujo> @hoogle ProcessHandle -> IO a
03:04:13 <lambdabot> No matches, try a more general search
03:04:23 <roconnor> quicksilver: it also made the Soduku sovler twice as fast.
03:04:32 <quicksilver> roconnor: I also am intrigued by the observation that CPS transforms often make GHC-compiled programs faser
03:04:40 <quicksilver> roconnor: ndm mentions it in one of his papers and I asked him why
03:04:44 <quicksilver> roconnor: he didn't know why :)
03:04:53 <roconnor> quicksilver: right, that is a more precise way of putting it.
03:04:53 <wli> Might as well shove a CPS transform into ghc at that point.
03:05:02 <quicksilver> roconnor: by the way when I said "your implementation" I meant ghc.
03:05:10 <roconnor> quicksilver: right
03:05:17 <quicksilver> I.e. it is a property of the ghc compilation technique that CPS transforms appear to make programs faster in many cases
03:05:21 <quicksilver> I don't know why :)
03:05:22 <roconnor> quicksilver: it seems GHC ought to be doing thing for us.
03:05:25 <quicksilver> I suspect it saves some boxing
03:05:49 <roconnor> quicksilver: well, the bind operation is notably different between the CPS and non CPS monads.
03:06:06 <quicksilver> I would like to have this discussion with someone who might know why :) Like JaffaCake or Igloo perhaps.
03:06:23 <roconnor> quicksilver: I was thinking of asking on the GHC mailing list
03:06:43 <roconnor> maybe someone who is already subscribed can ask.
03:06:57 * quicksilver nods
03:07:36 <dcoutts> quicksilver: the Soduku solver was using a state monad right?
03:07:48 <dcoutts> and it was changed for a Cont monad
03:07:52 <dcoutts> right?
03:08:03 <dcoutts> if so it makes quite a bit of sense why it'd be faster
03:08:11 <wli> Why?
03:08:25 <dcoutts> type State s a = s -> (s, a)
03:08:38 <dcoutts> so every result is a pair
03:08:54 <dcoutts> which has to be taken apart and passed on to the next bit
03:09:55 <quicksilver> that's what I meant by unboxing
03:09:55 <dcoutts> in contrast, in the cont version it'll be something like:
03:10:00 <dcoutts> (s -> a -> r) -> s -> r
03:10:06 <quicksilver> although perhaps I was using a poor choice of words
03:10:11 <quicksilver> 'tuple deforestation'
03:10:11 <quicksilver> ?
03:10:21 <dcoutts> ok, yes, structure unpacking
03:10:23 <roconnor> dcoutts: by that reasoning shouldn't we use chuch encoding for everything?
03:10:27 <quicksilver> GHC doesn't managed to optimise away tuples, in most cases
03:10:31 <dcoutts> roconnor: no :-)
03:10:32 <quicksilver> roconnor: ndm thinks so
03:10:38 <quicksilver> roconnor: that is his phd thesis :)
03:10:45 <dcoutts> quicksilver: only when it is allowed to do so
03:10:58 <quicksilver> dcoutts: of course those two aren't isomorphic
03:11:03 <dcoutts> quicksilver: in many places the data representation is fixed
03:11:05 <quicksilver> due to stupid bottoms
03:11:12 <roconnor> dcoutts: in what way does your argument not apply to everything?  Sharing?
03:11:18 <dcoutts> and it's the data representation (as a function) that could be improved
03:11:29 <roconnor> oh god, again with the bottoms
03:12:02 <dcoutts> roconnor: sometimes data structures rather than representation as lambdas makes a lot of sense
03:12:23 <roconnor> dcoutts: I believe you ... but do you have an example?
03:12:31 <dcoutts> roconnor: particularly when used as data stores, rather than as control flow mechanisms
03:12:36 <dcoutts> roconnor: Strings
03:12:50 <dcoutts> finite maps
03:13:00 <quicksilver> bytestrings :)
03:13:06 <roconnor> dcoutts: but what do you do with data other than to ultimate use it for control flow?
03:13:31 <dcoutts> roconnor: no, sometimes you work with data and never use it for control flow
03:13:41 <roconnor> dcoutts: strings are eventually printed
03:13:44 <dcoutts> you deal with the data obliviously
03:14:08 <dcoutts> roconnor: that's not control flow, that's just shovelling data from one place to another and doing transforms on it
03:14:08 <roconnor> dcoutts: I don't get your control flow / data distinction.
03:14:32 <wli> At some point I'd like to hear more about the precision-on-demand affair.
03:14:46 <dcoutts> roconnor: fold (+) 0 [0..100]  doesn't make any control flow decisions based on the data in the list
03:15:02 <roconnor> dcoutts but what you do with the result does.
03:15:26 <wli> Well, only a skeleton of the structure.
03:15:27 <dcoutts> print (fold (+) 0 [0..100])
03:15:48 <roconnor> printing uses the data to brach to which glyph to print
03:16:14 <Cale> dcoutts: It repeatedly distinguishes between (:) and []
03:16:28 <dcoutts> Cale: yes, and not the content of the list cells
03:16:46 <Cale> right
03:16:54 <wli> True of many containers.
03:17:04 <wli> Also a sort of catamorphism affair.
03:17:08 <roconnor> the data in the sums deterimine whether to execute carries or not.
03:17:19 <sjanssen> why should function application be any more expensive than case scrutinization?
03:17:28 <sjanssen> erm, other way around
03:18:06 <wli> Data cache/TLB resources vs. similar for instructions.
03:18:09 <dcoutts> sjanssen: tuples are heap allocated
03:18:23 <dcoutts> sjanssen: passing parameters to functions is cheap
03:18:54 <wli> Which of those resources is under the most pressure likely determines it.
03:18:59 <sjanssen> presumably the lambda representing the tuple is on the heap too?
03:19:02 <dcoutts> sjanssen: type State a s = s -> (# a, s #)  would be better
03:19:49 <dcoutts> sjanssen: but I admit it's not all that clear cut
03:20:09 <quicksilver> sjanssen: I'd also like to understand better
03:20:23 <quicksilver> sjanssen: but parameter passing is 'just' lining up pointers correctly
03:20:30 <wli> Well, the chain of cause and effect is what's not so clear cut.
03:20:38 <quicksilver> sjanssen: whereas a tuple is a real, fully-fledged heap object
03:20:45 <dcoutts> I think it'd help to try various representations and look at the optimised core code
03:20:45 <wli> It's obvious what the ultimate determinants are.
03:20:49 <quicksilver> sjanssen: with a constructor, and two thunks, and ....
03:21:06 <quicksilver> I think if ghc could 'optimise away' tuples better
03:21:13 <quicksilver> then this problem might go away of its own accord?
03:23:45 <wli> quicksilver: Definitely worth trying. I wish more people would/could be brought up to speed on the compiler issues.
03:23:47 <quicksilver> for example. Suppose foo :: Int -> (Int,Int,Int). If I do let (x,y,z) = foo 42, then presumably it ought to be possible to optimise out that tuple
03:24:06 <quicksilver> in practice I believe that tuple is in fact created on the heap and then GCed
03:24:37 <wli> I believe the same.
03:24:54 <sjanssen> 'case foo 42' may be a different story
03:25:01 * quicksilver nods
03:25:02 <quicksilver> it might
03:25:05 <quicksilver> but that's ugly :)
03:25:17 <roconnor> doesn't that let expression turn in to a case expression?
03:25:19 <quicksilver> I'm unsure if there is a semantic problem here with the various places bottom can occur
03:25:23 <roconnor> (lazy case)
03:25:27 <quicksilver> and let bindings being lazy
03:25:47 <dcoutts> quicksilver: that depends on if x,y,z are used strictly, the CPR analysis and inlining
03:25:59 * roconnor still thinks that optimizations should be allowed to move functions up the CPO.
03:26:07 <quicksilver> dcoutts: so there *are* circumstances in which the tuple can be entirely removed?
03:26:12 <dcoutts> quicksilver: sure
03:26:19 <quicksilver> ah ok, it's not as bad as I feared
03:26:44 <sjanssen> roconnor: most optimizations in the lazy let case will have the opposite effect
03:26:51 <quicksilver> as wli observes, the set of people who understand this stuff is too small :(
03:26:59 <ivanm> is there a library that I can use to create animations from data? atm, I'm importing my data into matlab and creating a "movie" out of it, but it's slow, memory intensive and visually unappealing...
03:27:52 <roconnor> quicksilver: yeah, again it is hard to reason about performace given a denotational specification ;)
03:28:25 <roconnor> I guess we need a GHC report
03:29:57 <quicksilver> there is a reasonable amount of stuff in the GHC wiki
03:30:21 <quicksilver> but perhaps not enough signposts and not enough guides to show people the way
03:30:41 <quicksilver> various of SPJ's papers explain various particlular parts of the system in quite a lot of detail
03:31:17 <sjanssen> various parts of the system at some point in the past 15 years :\
03:31:37 <quicksilver> right
03:32:43 <quicksilver> GHC is a big thing, and I have no idea how feasible it is to understand it piecemeal
03:33:47 <quicksilver> dcoutts: Oh, I found a paper on CPR analysis
03:33:54 <quicksilver> dcoutts: seems that is precisely this issue :)
03:34:06 <dcoutts> quicksilver: yes, tuples
03:34:09 <quicksilver> "Compilers for ML and Haskell typically go to a good deal of trouble to arrange that multiple arguments can be passed efficiently to a procedure. For some reason, less effort seems to be invested in ensuring that multiple results can also be returned efficiently."
03:35:36 * quicksilver pushes that on the papers-to-read stack
03:35:43 <quicksilver> (the stack wobbles and falls over)
03:36:05 <osfameron> so many papers!  so much wobbling!
03:37:03 <quicksilver> dcoutts: can it also be related to SpecConstr? since tupples only have one constructor, SpecConstr would seem to apply automatically?
03:37:37 <dcoutts> quicksilver: I think spec constr only deals with function arguments
03:38:02 <dcoutts> quicksilver: similarly the worker/wrapper transfrom
03:38:09 <quicksilver> so it would kick in, perhaps, if the tuple is passed to a function
03:38:14 <quicksilver> and the function then unpacks it inside?
03:38:29 <wli> roconnor: I'm thinking of continued fractions vs. the whole bit about passing on tolerances.
03:38:32 <quicksilver> but not if we unpack before passing, as in this case
03:39:34 <wli> roconnor: Though in truth there's nothing particularly unique about continued fractions; it's just that the error bounds come directly out of the convergence process where they're side computations in many other forms of approximation (though alternating series have a similar property).
03:42:27 <wli> roconnor: The nasty bit about alternating series is cancellation when done in floating point, but if you're doing things in arbitrary-precision rationals it doesn't matter. Continued fractions lose when you're trying to deal with dyadic rationals because their denominators are rarely of such a form, so they've got their own downsides.
03:42:30 <roconnor> wli: you need to compute an upper bound on how many terms you need to get within a certain tollerance.
03:42:45 <roconnor> (at least if you want to do it in a terminating system like Coq)
03:43:20 <wli> roconnor: Okay, that's not going to come out of continued fractions.
03:44:24 <roconnor> wli: of course if you are using russian style constructiveism, then you can just run until the error is small enough if You know that it will eventually be small enough.
03:44:50 <wli> roconnor: Where's constructivism enter the picture?
03:44:53 <roconnor> although I don't see how you can know it will terminate classically without knowing it will terminate constructively.
03:45:14 <roconnor> wli: if you are talking about an actually computable implemeantion, then we are taking about constructive mathematics.
03:46:11 <wli> roconnor: Oh, the reason why I'm edging into this at all is that there is an issue with cancellation in continued fraction arithmetic your idea sounded like it could act as a sort of way to resolve vs. actually trying to do something geared toward developing the tolerance-based idea itself.
03:46:38 <wli> roconnor: Basically if things cancel to the point you get zero the continued fraction arithmetic ops never terminate.
03:48:19 <wli> roconnor: I'm not trying to push continued fractions per se; it's just that the "goal" is to do something about a massive flaw in the framework.
03:50:11 <wli> s/framework/continued fraction arithmetic library/
03:51:16 <Sizur> question: why is (^) not polymorphed for Num instead of having separate power functions?
03:51:16 <wli> roconnor: I actually do have some odd questions about the idea you're working on in general, though.
03:52:03 <wli> roconnor: Let's take a power series expansion of an incomplete gamma function intended for use where the limit of integration is near zero.
03:52:05 <quicksilver> Sizur: (^) works even for integral-only types
03:52:13 <quicksilver> Sizur: that's the point
03:52:35 * roconnor isn't familiar with the incomplete gamma function.
03:52:50 <Sizur> quicksilver: integral is inheriting numeric. why not have (^) do the right thing for any Num?
03:52:53 <wli> roconnor: How do we cope with not being able to readily find what precision we need in the exponent to compute the incomplete gamma function to some precision?
03:53:17 <quicksilver> Sizur: what should 3^(-2) give, for Int?
03:53:32 <quicksilver> (well, even 3^(-1) for that matter)
03:53:33 <wli> roconnor: http://en.wikipedia.org/wiki/Incomplete_gamma_function
03:53:34 <lambdabot> Title: Incomplete gamma function - Wikipedia, the free encyclopedia
03:53:52 <Sizur> it should give error
03:53:54 <wli> roconnor: The lower incomplete gamma function is the one I'm referring to.
03:53:57 <Sizur> jsut like it's giving now
03:54:05 <dmwit> quicksilver: Well, heck, I can continue that pattern, what should 3^(0) be? ;-)
03:54:06 <sjanssen> also, consider 3^0.5
03:54:27 <roconnor> wli: is a an integer?
03:54:30 <Sizur> sjanssen: that's the beauty of polymorphism then it'd do what (**) is doing now
03:54:35 <wli> roconnor: Typically not.
03:54:50 <sjanssen> Sizur: Haskell doesn't have this type of ad-hoc polymorphism
03:55:01 <quicksilver> sjanssen: yes it does, that's exactly what typeclasses are
03:55:03 <dmwit> Sizur: They're implemented differently; don't you want to get to choose your implementation?
03:55:12 <sjanssen> (discounting extensions with MPTCs and FDs)
03:55:20 <dmwit> The three implementations have different run-time characteristics for speed/size/accuracy.
03:55:24 <roconnor> wli:  is a such that t^(a-1) is 0?
03:55:35 <Sizur> dmwit: they are implemented depending on the class, then why not make class work
03:55:57 <sjanssen> quicksilver: I think Sizur wants ^ to occupy significantly more types than possible with Haskell '98
03:56:14 <wli> roconnor: Typically not. It's allowed to vary arbitrarily save for not being a negative integer.
03:56:15 <Sizur> sjanssen: it's only 3 classes
03:56:36 <wli> MPTC + FD are required for meaningful monad transformers.
03:56:57 <dmwit> Sizur: What I mean is, even with the same type, you sometimes want iterated multiplication and you sometimes want something faster (but messier).
03:57:03 <roconnor> wli:  so we need to take the limit of (Int, foo(t), t=e..x) as e -> 0?
03:57:15 <dmwit> Sizur: How would you propose choosing between those so that (^) would always just "do the right thing"?
03:57:19 <hpaste>  ddvlad pasted "having trouble with simple string rotation attempt" at http://hpaste.org/3530
03:57:36 <Sizur> dmwit: you cannot choose now too... try doing (^) on Floats
03:57:40 <wli> I think H98 - MR + MPTC + FD is basically the minimal good type system.
03:58:00 <sjanssen> > (2 :: Float)^4
03:58:00 <quicksilver> FD do not occur in anything good
03:58:01 <roconnor> (other than the suckyness of FD)
03:58:04 <lambdabot>  16.0
03:58:07 <wli> roconnor: I'm not sure where you're getting that; the definition is basically just the integral.
03:58:13 <sjanssen> Sizur: ^^^
03:58:23 <osfameron> vox-- # doesn't handle code in comments gracefully
03:58:24 <dmwit> Sizur:
03:58:31 <dmwit> > (3.0 ^^ 4, 3.0 ** 4)
03:58:33 <lambdabot>  (81.0,81.0)
03:58:41 <dmwit> Two different algorithms on floats.
03:58:43 <wli> quicksilver//roconnor: Okay, if not FD, how else does one accomplish similar?
03:58:46 <roconnor> wli:  if the function being integrated is not defined at 0, then it isn't obvious to me that the function is integerable.
03:58:55 <osfameron> viklund: ta for comment, dunno if you meant to paste any code in the comment, but if so, Vox ate it
03:59:00 <quicksilver> wli: that's why the 'minimal good type system' has not yet been unanimously decided :)
03:59:22 <roconnor> wli: doing it without FD is an open research problem.  Associated Types is the current attempt.
03:59:25 <quicksilver> wli: I'm thinking the answer might be associated type families but I haven't yet used them enough to be sure.
03:59:33 <wli> roconnor: It's just an algebraic singularity. For a < 0 analytic continuation is involved but you can ignore that and assume a > 0 momentarily.
03:59:38 <Sizur> dmwit: well one is on Reals, you can specify an expr to be Real then the right polymorphic function will execute
04:00:00 <dmwit> ddvlad: That seems okay, what are you having trouble with?
04:00:03 <wli> roconnor: Yeah, so I say FD to stick to cases that are not research problems (not necessarily the right approach for everyone).
04:00:15 <roconnor> wli: okay, so what is the problem, you can just integrate the function?
04:00:20 <Cale> ddvlad: what seems to be the problem?
04:00:50 <wli> roconnor: Black box integration is a poor method of evaluation for it. There are power series and continued fractions and so on that do far better.
04:00:52 <dmwit> (Not the most elegant solution, but it should do the trick.)
04:01:04 <roconnor> wli: Sounds true
04:01:43 <ddvlad> dmwit: rotL' runs fine, but rotL just hangs, even for nr = 0
04:01:54 <wli> roconnor: Moving on, deciding to what tolerance one needs to know a (and/or x) to evaluate the thing to a specified precision is not entirely obvious.
04:02:02 <ddvlad> it prints a quotation mark, then dies out
04:02:11 <Cale> oh, heh
04:02:16 <Sizur> dmwit:
04:02:17 <Cale> you misspelled the base case
04:02:17 <quicksilver> ddvlad: 'rolL != rotL'
04:02:20 <Sizur> @type (3.0 ^^ 4, 3.0 ** 4)
04:02:21 <dmwit> heh
04:02:22 <lambdabot> forall t t1. (Fractional t, Floating t1) => (t, t1)
04:02:26 <roconnor> wli: the integral is a (uniformly) continuous function.
04:02:30 <wli> roconnor: In the continued fraction neither parameter is obvious. In power series, a is not obvious.
04:02:42 <roconnor> so there is at least a bad way of determining how precise x needs to be.
04:02:50 <dmwit> Sizur: Yes, but what if there are types that are instances of both Fractional and Floating?
04:03:05 <wli> roconnor: Which leaves large questions about a.
04:03:16 <Saizan> ?src Floating
04:03:16 <lambdabot> class  (Fractional a) => Floating a  where
04:03:17 <lambdabot>     pi                                                      :: a
04:03:17 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
04:03:17 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
04:03:17 <lambdabot>     (**), logBase                                           :: a -> a -> a
04:03:19 <ddvlad> quicksilver: I understand that, but it's beyond me why rotL fails
04:03:38 <roconnor> wli: is it continuous in a?
04:03:50 <sjanssen> Sizur: what is your actual proposal?
04:03:52 <dmwit> ddvlad: Because it never hits the base case, it just keeps decrementing k.
04:04:07 <wli> roconnor: No, there are poles at all the negative integers and 0.
04:04:20 <Sizur> sjanssen: define (^) to be polymorphic over NumS
04:04:21 <ddvlad> dmwit: isn't the base case for k=0?
04:04:32 <roconnor> wli: then a needs to be bounded away from these poles.
04:04:35 <dmwit> ddvlad: To be more clear: there is no base case, because the "base case" you specified is actually the base case for a *different function*.  You spelled it wrong! =)
04:04:38 <Cale> ddvlad: it's because you misspelled it
04:04:48 <sjanssen> Sizur: how?  Make it a member of the Num class?
04:04:53 <roconnor> and we need to use how far away a is from these poles in our computation.
04:04:58 <Cale> So there really is no base case, it just recurses forever
04:05:12 <Sizur> sjanssen: yes, and implement in Integral, Fractional, an dFloating
04:05:22 <wli> roconnor: Literally just using the integral for estimates?
04:05:32 <ddvlad> oh good god...
04:05:36 <wli> roconnor: Doesn't the computational method matter at all?
04:05:44 <sjanssen> Sizur: you can't implement a class method in another class
04:05:46 <Cale> (one could argue that there should be a warning when the definitions related to a given function weren't all together in a module)
04:06:00 <ddvlad> dmwit, Cale: thanks for your help, i'll be off baging my head against the wall
04:06:06 <dmwit> heehee
04:06:30 <roconnor> wli: well, maybe there are better methods.  but the distance away from the poles will occur in all methods
04:06:54 <Sizur> sjanssen: in subclass, why not? i think i'm missing something
04:07:02 <quicksilver> Cale: it's not a warning, it's an error
04:07:05 <quicksilver> Cale: (in GHC)
04:07:16 <quicksilver> Cale: but apparently it doesn't trigger when only the signature is separate
04:07:16 <dmwit> Subclass isn't really a meaningful term in Haskell.
04:07:17 <sjanssen> Sizur: probably :P.  Are you new to Haskell?
04:07:24 <Sizur> dmwit: derived class
04:07:28 <roconnor> wli:  I need to head for lunch
04:07:35 <Sizur> inherited
04:07:42 <dmwit> There's no inheritance.
04:07:49 <wli> roconnor: No problem.
04:08:03 <dmwit> A type is either a member of a class or not.
04:08:10 <Cale> There's subclasses and superclasses, just they're something different from what they are in OO ;)
04:08:10 <dmwit> Just like God intended. =)
04:08:14 <quicksilver> "subclass isn't a meaningful term in haskell" ?
04:08:19 <Sizur> what is this? class (C1 a) => C2 a where?
04:08:24 <Cale> For example Eq is a superclass of Ord
04:08:43 <Cale> In order to declare an instance of Ord, there must be an instance of Eq
04:08:43 <quicksilver> dmwit: that would be news to the authors of the haskell report, then
04:08:56 <dmwit> quicksilver: I'm playing fast and loose with reality.
04:09:14 <quicksilver> the really messy thing is the different between
04:09:21 <quicksilver> class (Foo a ) => Bar a where
04:09:22 <quicksilver> and
04:09:28 <quicksilver> instance Bar a => Foo a where
04:09:48 <quicksilver> which intuitively model a similar connection, but have tragically different consequences
04:09:51 <Cale> I think the arrows pretty much go the right way :)
04:10:04 <dmwit> Oh, right, that could be called subclassing.
04:10:04 <Sizur> Cale lol
04:10:15 * dmwit goes to bed before he says something even more wrong.
04:10:23 <wli> I'd like to hear more about why FD are bad.
04:10:39 <quicksilver> wli: they're only two letters long. And I've never like 'F' as a letter.
04:10:51 <sjanssen> wli: poorly specified, and the conditions to guarantee termination are quite complicated
04:10:54 <wli> quicksilver: fundeps then
04:11:05 <quicksilver> ;)
04:11:24 <quicksilver> the simple conditions to guarantee termination turn out to be insufficient for obvious use cases
04:11:36 <quicksilver> and the conditions which are sufficient for those use cases turn out to be fiendishly complex
04:11:53 <wli> sjanssen: How much of that is innate to the problem of getting MPTC to fly in a useful fashion vs. being a flaw in FD?
04:12:20 <sjanssen> wli: AIUI the flaws are specific to FDs
04:12:33 <Philippa_> a significant amount is, anyway. Take a look at the work with ATs
04:12:47 <Sizur> sjanssen: so i cannot implement a class method in a subclass? what's polymorphism is about then?
04:13:19 <sjanssen> Sizur: first, forget everything you know about OO calls "class" :)
04:13:19 <wli> Is this http://citeseer.ist.psu.edu/chakravarty05associated.html ?
04:13:20 <lambdabot> Title: Associated Types with Class - Chakravarty, Keller, Jones, Marlow (ResearchIndex)
04:13:27 <Sizur> sjanssen: already did
04:13:45 <quicksilver> actually I think it is very reasonable to want to implement class methods in subclasses
04:13:50 <quicksilver> but you can't
04:13:55 <quicksilver> people do ask about it from time to time
04:14:06 <quicksilver> and I'm not aware of a strong reason not to allow it
04:14:22 <quicksilver> if we made Monad a subclass of Functor, for example
04:14:25 <quicksilver> which it 'obviously' should be
04:14:25 <Sizur> quicksilver: but you do provide defaults. sounds the same to me
04:14:29 <Cale> Sizur: Well, here's how I'd explain typeclasses. First of all, are you comfortable with ordinary parametric polymorphism?
04:14:41 <Cale> Sizur: For example length :: [a] -> Integer
04:14:42 <quicksilver> then Monad could have an implementation of 'fmap' using return + bind
04:14:53 <quicksilver> but we can't do that, as it happens
04:15:00 <Sizur> Cale: i wrote typeclasses before
04:15:06 <quicksilver> that is, in fact, one reason cited for why we *don't* have a fine-grained class hierarchy.
04:15:17 <wli> I don't quite see from a quick skimming of the paper what unresolved issues there may or may not be with AT's.
04:15:25 <Cale> Sizur: oh, heh, all right
04:15:43 <MyCatSchemes> quicksilver: bwuh, why can't we do that?
04:15:55 <quicksilver> MyCatSchemes: I'm not aware of a technical reason.
04:15:59 <quicksilver> MyCatSchemes: You just can't, because you can't.
04:16:00 <sjanssen> wli: there's a more recent paper.  Check simonpj's home page
04:16:05 <Philippa_> wli: they're still technically WIP, but grab slides from some of SPJ's recent talks - really what they're solving now is type-level functions
04:16:18 <Cale> Sizur: I'm not sure what you're asking about then. Typeclasses serve to restrict polymorphism in order to provide additional operations.
04:16:22 <Sizur> ok i did not try to polymorph over a subclass, thanks for letting me know quicksilver :)
04:16:40 <sjanssen> wli: also http://haskell.org/haskellwiki/GHC/Type_families
04:16:40 <MyCatSchemes> quicksilver: what, the idea that maybe you could doesn't follow from the axioms that the monad class gives you?
04:16:41 <lambdabot> Title: GHC/Type families - HaskellWiki
04:17:00 <quicksilver> MyCatSchemes: No. the fact that I can't is a syntactic restriction of the haskell langauge.
04:17:13 <quicksilver> MyCatSchemes: There is no language feature to allow me to define fmap in terms of return and bind
04:17:21 <quicksilver> MyCatSchemes: (if I make Monad a subclass of Functor)
04:17:33 <sjanssen> quicksilver: you can do that
04:17:34 <MyCatSchemes> quicksilver: ohhh, I see.
04:17:41 <sjanssen> it's providing that by default that is difficult
04:17:49 <quicksilver> yes
04:17:51 <quicksilver> that's what I meant
04:17:56 <quicksilver> define it once, for all instances
04:18:02 <wli> sjanssen: That looks more like a use case affair.
04:18:05 <sjanssen> and that goes beyond syntax, I think
04:18:13 <MyCatSchemes> Hrmn. But, are there any interesting classes which are Functors but not Monads? Non-composable containers?
04:18:13 <Cale> Sizur: Basically all that the subclass relationship does in Haskell is saves you a little typing when writing functions that use the class, and enforce the constraint for you. So for example, if I'm writing a function of type (Ord a) => [a] -> [a], I'm allowed to use (==) on values of type a as well, even though that's in Eq and not Ord.
04:18:31 <Cale> (Because Ord is a subclass of Eq)
04:18:32 <quicksilver> MyCatSchemes: Even if there aren't, there are interesting functions which work over functors
04:18:39 <Sizur> Cale: i want to redefine a function for a subclass
04:18:39 <wli> sjanssen: System F with Type Equality Coercions?
04:18:41 <quicksilver> MyCatSchemes: (which don't need monad funcitonality)
04:18:50 <quicksilver> MyCatSchemes: so it's nice to give such things the correct type
04:19:05 <Cale> Sizur: You mean, change its type?
04:19:23 <quicksilver> Cale: I strongly suspect the main reasons for subclasses is to make contexts smaller :)
04:19:24 <wli> sjanssen: That is, the wiki bits looked mostly like use case affairs.
04:19:29 <Sizur> Cale: redefine, it will still have the same class
04:19:38 <sjanssen> wli: "Towards open type functions for Haskell"
04:19:52 <Cale> Sizur: classes only contain type specifications. It's in the instances which you specify the code.
04:19:52 <MyCatSchemes> quicksilver: I'm just wondering if monad and functor aren't identical, and can't thus be merged, because I can't think of any data structures which satisfy one constraint but not the other.
04:19:57 <quicksilver> MyCatSchemes: there are certainly functors which admit more than one different monad definition
04:20:03 <Sizur> Cale: right...
04:20:05 <MyCatSchemes> quicksilver: ahhh, I see.
04:20:14 <Cale> Sizur: So you'd just write the instances for your given type differently, if you want different code there.
04:20:28 <quicksilver> MyCatSchemes: there are choices even in the monad instance for lists. There are *lots* of choices in the monad instance for trees.
04:20:38 <Sizur> Cale: you do define default functino on classes, so there would be nothing wrong to redefine them for subclasses
04:20:55 <MyCatSchemes> quicksilver: this is true. How on Earth would you ever present them in a usable way, though?
04:21:02 <Cale> hmm
04:21:07 <sjanssen> Sizur: Haskell doesn't allow this, because instances are open
04:21:07 <Cale> Could you give an example?
04:21:10 <quicksilver> MyCatSchemes: I'm saying, you may not want the monad instance at all.
04:21:13 <wli> sjanssen: These are starting to look hard to do type inference/checking on vs. H98 - MR + MPTC + FD.
04:21:21 <quicksilver> MyCatSchemes: I've used lots of tree and tree-like structures
04:21:34 <quicksilver> MyCatSchemes: although they are ways of making them into monads, that's not something I've ever wanted to do
04:21:40 <quicksilver> MyCatSchemes: but they are definitely functors :)
04:21:50 <sjanssen> Sizur: I could define "instance Num Foo" in one module, and "instance Integral Foo" in another.  The modules in between won't know which default implementation to use
04:22:09 <MyCatSchemes> quicksilver: so, they're functors and they're possibly monads, but you don't want to do the extra work to make them monad instances because you're not going to use it anyway?
04:22:41 <wli> sjanssen: I just sort of wanted a beefy-enough type system for a toy language to have realistic programs to "refactor" once a module system is slapped on top.
04:22:55 <quicksilver> MyCatSchemes: right.
04:23:26 <MyCatSchemes> quicksilver: ...you can implement >>= in terms of fmap and a few others though, right? :D
04:23:41 <Sizur> sjanssen: i dont understand what you mean by modules in between
04:23:47 <Saizan> MyCatSchemes: join
04:24:02 <wli> sjanssen: This looks far too much like virgin soil for that.
04:24:04 <sjanssen> Sizur: other modules that import the modules containing the instances
04:24:23 <Sizur> sjanssen: they have to deal with namespaces, so types are inferrable
04:24:38 <sjanssen> wli: FDs aren't exactly "solved" either
04:24:46 <Sizur> sjanssen: when you import you make sure the fames dont collide
04:24:54 <Sizur> *names
04:25:07 <wli> sjanssen: Uh-oh, I may have gotten the wrong impression from some of the FD papers, then.
04:25:58 <sjanssen> wli: this is my impression, at least.  GHC's termination conditions have changed in each of the past major releases
04:26:34 <sjanssen> technical discussion (which is mostly above my head) about GHC's implementation pops up frequently on the mailing lists too
04:26:34 <wli> sjanssen: The basic thing to support is the MTL-style monad transformer libraries. What I'd ultimately like is to avoid unresolved questions, research problems, etc. with enough of a type system to support them.
04:26:58 <sjanssen> ChilliX might have comments on this subject ;)
04:27:18 <sjanssen> Sizur: my point is that it will cause issues with separate compilation of modules
04:27:32 <wli> sjanssen: I'm not trying to do type system research, but rather get an idea of how module systemd work.
04:27:59 <wli> I'm not trying to make anything novel, useful, or publicable.
04:28:36 <sjanssen> Sizur: it is useful for the compiler to know the implementation of a function at the call site
04:28:38 <Sizur> well, then this is my first issue with haskell unfortunately :/ i had the perfect picture already :P
04:29:00 <wli> I have a bad feeling that any useful method of resolving the ambiguity issues with MPTC is probably a research problem.
04:29:46 <SamB_XP> an [HM50] problem?
04:30:02 <sjanssen> Sizur: your suggestion about overriding default implementations of subclasses would mean that the real definition of a function isn't known until all the modules in the program have been linked
04:30:10 <wli> I'm getting -ENOGROK on "[HM50]"
04:30:25 <Sizur> sjanssen: i still see no reason for ambiguity ... because subclassing is doen always in one direction
04:30:50 <Sizur> sjanssen: izznt this the core issue of polymorphism?
04:31:11 <MyCatSchemes> Saizan: handy.
04:31:11 <sjanssen> Sizur: The problem is that instances can appear in any module
04:31:43 <sjanssen> Sizur: you can have a case where 'instance Num Foo' is visible in a module, but 'instance Integral Foo' isn't
04:31:50 <MyCatSchemes> Hang on. If somebody creates a cycle in the subclassing graph, you just tell them not to do that and beat them up.
04:31:56 <MyCatSchemes> How's that a problem?
04:32:25 <SamB_XP> why is it a problem if they do that anyway?
04:32:56 <MyCatSchemes> SamB_XP: because they deserve to be shot.
04:33:09 <Sizur> MyCatSchemes: it creates a host of problems. most fundamental are in logic and philosophy
04:33:24 <SamB_XP> I suppose it would make it tricky to find the principal type
04:33:30 <Sizur> s/logic/set theory/
04:33:36 <quicksilver> classes are not types
04:33:48 <sjanssen> Sizur: did anyone explain to you why we have ^, ^^ and **?
04:33:49 <quicksilver> the type of Foo is Foo
04:33:57 <Sizur> sjanssen: yes
04:33:58 <quicksilver> doesn't matter how many classes it is or isn't in
04:33:59 <wli> They're predicates on types AIUI.
04:34:03 <Sizur> sjanssen: mathematics
04:34:15 <SamB_XP> quicksilver: well, hmm, I dunno
04:34:18 <sjanssen> "mathematics" is a vague explanation :)
04:34:24 <laziest> quicksilver: am I right if I say classes are sets of types?
04:34:33 <dozer> they are type types
04:34:35 <Sizur> sjanssen: Integral, Rational, and Real powers
04:34:45 <quicksilver> dozer: no, kinds are type types
04:34:51 <Sizur> sjanssen: it's not haskell issue
04:34:52 <quicksilver> laziest: yes
04:34:53 <SamB_XP> it would probably cause some problem when trying to figure out what to do when you used one method from one class in an SCC and another from another class in the same SCC
04:35:02 <quicksilver> laziest: (MPTCs are predicates on types)
04:35:14 <sjanssen> Sizur: we have ^/^^ because there's a really fast algorithm for exponentiation where the exponent is an integer
04:35:17 <dozer> lol, aren't kinds type-level functions?
04:35:22 <SamB_XP> they are funky sets though
04:35:23 <quicksilver> no
04:35:27 <quicksilver> kinds are types for types
04:35:28 <SamB_XP> because you don't know what's in them
04:35:29 <laziest> in that case it's obvious that subclassing cannot have cycles..
04:35:34 <quicksilver> yes
04:35:39 <quicksilver> I don't understand sjanssen's point
04:35:49 <SamB_XP> and you can never say for sure that something is not in them unless you are compiling the Main module...
04:35:52 <quicksilver> I don't think there is a reason you shuldn't override methods in subclasses
04:35:58 <Sizur> sjanssen: it is simply different definitions of powers
04:36:01 <quicksilver> it's just "We don't do that, cos we don't"
04:36:11 <SamB_XP> quicksilver: 'cause we can't
04:36:19 <quicksilver> right, but that's a choice that has been made
04:36:33 <quicksilver> not because System Fc doesn't support it, or because compilation techniques don't support it
04:36:34 <sjanssen> quicksilver: are you sure there's no problem with separate compilation?
04:36:45 <quicksilver> no worse than existing problems with subclasses
04:36:49 <quicksilver> subclasses exist. they are here.
04:36:55 <quicksilver> Num is a subclass of Eq
04:37:05 <quicksilver> all we don't have is the ability to over-ride default methods
04:37:16 <Sizur> right
04:37:17 <sjanssen> subclasses have no problem with separate compilation as defined
04:37:19 <SamB_XP> well, because we haven't figured out what to do if you have class A, and class B and class C override the defaults, and then you have class D that subclasses both B and C
04:37:28 <MyCatSchemes> Sizur: doesn't "they deserve to be shot" adequately describe the issue, though? :D
04:37:52 <quicksilver> SamB_XP: a conservative answer would just be to disallow that
04:38:05 <quicksilver> SamB_XP: 'cannot subclass B and C because they are incompatible subclasses of A'
04:38:10 <SamB_XP> quicksilver: or force class D to define a resolution?
04:38:15 <dozer> c++ gets into all kinds of mess trying to handle that multiple-inheritance case
04:38:23 <Sizur> MyCatSchemes: heh, well, i believe it was a choice, so there must be a reason, i'd like to know why i cannot do what i should be able to do
04:38:23 <quicksilver> yes, it does :)
04:38:42 <SamB_XP> dozer: I still don't understand how MI can even work in C++
04:39:15 <dozer> SamB_XP: nore do I, but the language allows it and the compilers rout the calls
04:39:31 <quicksilver> C++ gives you the choice!
04:39:34 <SamB_XP> the other issue is, how does the compiler know what classes you are going to make type T an instance of?
04:39:35 <quicksilver> C++ always gives you the choice
04:39:42 <quicksilver> especially if it's incomprehensible
04:39:52 <quicksilver> in the case of MI, C++ allows you to choose between 'two copies' and 'one copy'
04:40:05 <SamB_XP> dozer: I just don't understand how such a seemingly low-level language can pull it off
04:40:08 <quicksilver> diamond-inheritance vs. tree inheritance
04:40:25 <quicksilver> the other nice thing C++ does is reuse existing keywords
04:40:28 <quicksilver> just because they can
04:40:34 <quicksilver> even if the conncetion isn't obvious :)
04:40:41 <quicksilver> this one is called virtual base class, is it?
04:40:41 <dozer> SamB_XP: I believe it waits untill you use it in a context where it must be an instance of some class, and then searches for a suitable instantiation, rather than compiling all instantiations up-front
04:40:42 <quicksilver> I forget
04:40:43 <SamB_XP> quicksilver: it's not really that odd to do so
04:40:47 <pejo> SamB, the problem with MI isn't on a type system level though
04:40:52 <hpaste>  aleator pasted "dcoutts: Is this dangerous? I get it with listStorePrepend on an empty liststore" at http://hpaste.org/3532
04:40:53 <SamB_XP> well, I mean, even in Haskell we reuse keywords
04:41:04 <SamB_XP> and sometimes we use not-quite-keywords
04:41:18 <dcoutts> aleator: it's a bug in our code I expect
04:41:38 <aleator> dcoutts: ok where to file?
04:41:51 <aleator> Does not seem to hurt in practise yet.
04:41:54 <quicksilver> there are probelsm with subtypes in a haskell-like type system
04:41:58 <vali> does haskell support threads?
04:42:01 <SamB_XP> hmm. why doesn't windows let you move print jobs between printers...
04:42:04 <quicksilver> subclasses side-step that rather neatly
04:42:16 <quicksilver> SamB_XP: because printing is a device-specific operation
04:42:20 <roconnor> @hoogle fork
04:42:21 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
04:42:21 <lambdabot> Control.Concurrent.forkOS :: IO () -> IO ThreadId
04:42:26 <quicksilver> cos classes aren't types
04:42:28 <quicksilver> vali: yes
04:42:43 <hpaste>  sjanssen pasted "separate compilation and overriding defaults in subclasses" at http://hpaste.org/3533
04:42:48 <pejo> quicksilver, is subtyping a bigger problem than any other extension?
04:42:50 <sjanssen> quicksilver: ^^^
04:43:25 <SamB_XP> we don't exactly have a *standard* for haskell threads
04:43:37 <nominolo> pejo: it hurts type inference
04:43:57 <SamB_XP> what exactly is subtyping?
04:44:15 <quicksilver> sjanssen: how is that different from doing instance Foo X where f = g in the first file, and instance Foo X where f = h in the second?
04:44:21 <pejo> nominolo, so does rank-n polymorphism.
04:44:30 <quicksilver> sjanssen: i.e. how is that worse than the current situation where I can define different instances in different files?
04:44:35 <SamB_XP> and, um, impredictive polymorphism
04:44:46 <quicksilver> pejo: yes, it's a nasty one
04:44:56 <nominolo> pejo: well, in 2013 we will get intersection types in haskell
04:45:03 <quicksilver> SamB_XP: subtyping is where all As are Bs
04:45:11 <Sizur> good, good, i always wanted these
04:45:12 <quicksilver> SamB_XP: so given f :: B -> Int
04:45:14 <sjanssen> quicksilver: it's different because GHC will refuse to compile that sort of overlapping instance
04:45:14 <pejo> nominolo, sure, right at the time where Oleg is the only one who understands our type system.
04:45:16 <quicksilver> SamB_XP: it's permitted to pass an 'A'
04:45:28 <nominolo> yup
04:45:37 <SamB_XP> quicksilver: could you give a more concrete example?
04:45:46 <pejo> quicksilver, could you elaborate on that a bit more?
04:45:58 <SamB_XP> something involving values as well as types
04:46:03 <vali> i've been reading some haskell tutorials, but i read and forget, so i think it's time to start banging my head against the wall. any suggestions for a first "program"?
04:46:07 <quicksilver> well, logically Nat is a subclass of Int
04:46:17 <quicksilver> so I should be able to pass a 'Nat' wherever an Int is expected
04:46:20 <SamB_XP> vali: write an interpreter
04:46:30 <quicksilver> addOne :: Int -> Int
04:46:32 <Sizur> vali: hello world
04:46:34 <vali> SamB_XP: hmm, isn't that a little difficult?
04:46:37 <quicksilver> I should be allowed to pass a 'Nat' as well
04:46:44 <quicksilver> because 'Nat' is a "subtype" of Int
04:46:45 <vali> Sizur: i've done that a few times
04:46:48 <quicksilver> is that betteR?
04:46:49 <wli> Actually I wonder if H98 has garbage besides the MR that could (or should) logically be cut out for a minimalistic toy language supporting MTL-like libraries.
04:46:51 <SamB_XP> vali: depends on what language you write it for
04:46:55 <nominolo> vali: or a compiler (to, say, java bytecode)
04:47:09 <vali> nominolo: i haven't read that many tutorials
04:47:30 <nominolo> vali: :)
04:47:32 <wli> nominolo: Are there better VM's than the JVM to compile to?
04:47:33 <dcoutts> aleator: I would say the gtk2hs trac, but I can't get that working atm, email gtk2hs-devel
04:47:34 <SamB_XP> vali: write an interpreter for a simple purely functional language
04:47:35 <dozer> quicksilver: it is important to split the representational stuff from the operational though - while the operations may form a hierachy, the representations in memory may be radically different
04:47:36 <viklund> @seen masak
04:47:37 <lambdabot> I saw masak leaving #haskell and #perl6 4d 2h 4m 24s ago, and .
04:47:37 <Sizur> vali: datamine some webpage
04:47:46 <nominolo> wli: jvm is easy to compile to
04:47:47 <SamB_XP> almost like scheme without the exclamation points
04:47:48 <quicksilver> sjanssen: right, well this should be handled by the same mechanism, then
04:47:59 <vali> Sizur: hmm, good idea
04:48:04 <SamB_XP> vali: you don't even need to write a parser
04:48:07 <nominolo> wli: but llvm is nice for further optimizations
04:48:10 <wli> nominolo: Maybe it would make sense, then.
04:48:15 <wli> nominolo: Noted.
04:48:25 <quicksilver> sjanssen: i.e. that Bar instance should be considered to overlap with the earlier Foo one
04:48:25 <pejo> quicksilver, I didn't understnad your answer. Could you explain to a moron why subtyping is an especially nasty extension compared to the dozen other ones we already have?
04:48:31 <quicksilver> pejo: no, not really
04:48:34 <SamB_XP> is there an LLVM generation library for Haskell?
04:48:37 <quicksilver> pejo: it's a bit subtle
04:48:47 <sjanssen> quicksilver: such a mechanism will make this feature proposal practically useless
04:49:05 <quicksilver> sjanssen: I don't understand why?
04:49:09 <nominolo> SamB_XP: no, it was my SoC proposal
04:49:23 <nominolo> SamB_XP: but i got cabal configurations instead
04:49:28 <pejo> quicksilver, is your subtle point about the internals of the type system, or various ways that people might use subtyping in the wrong way?
04:49:36 <wli> SoC for some reason makes me think "silicon compiler" instead of "Summer of Code."
04:49:38 <quicksilver> pejo: no, it's not internal, really
04:49:45 <SamB_XP> quicksilver: what happens if I have a function of type Int -> Int, and I try passing a Nat to it?
04:49:45 <quicksilver> pejo: do you know what a principle type is?
04:49:50 <Cale> pejo: I'm just jumping into the middle of the conversation, so I might be missing important context, but subtyping doesn't tend to mix very well with Hindley-Milner type inference.
04:50:03 <SamB_XP> nominolo: aww
04:50:05 <quicksilver> SamB_XP: in a system where subtyping works, you'd get an Int out
04:50:08 <wli> pejo: There are apparently also different flavors of subtyping; structural subtyping is another beast entirely from the usual OO affairs, for example.
04:50:18 <nominolo> wli: SoC also means System on a Chip :)
04:50:27 <pejo> Cale, oh, agreed. But we have other extensions where we are perfectly happy with type annotations.
04:50:32 <SamB_XP> quicksilver: well, that sounds impossible to pull off without radically altering the type system
04:50:34 <wli> nominolo: I've seen that, too.
04:50:40 <quicksilver> SamB_XP: I agree
04:50:46 <Sizur> quicksilver: very good point, i never thought abotu that
04:50:53 <dozer> mm - I've had a haskell app that builds very big strings crashing my linux amd64 box - taking out the whole OS
04:50:56 <wli> Cale: Dilip Siquiera's thesis seemed promising.
04:51:02 <quicksilver> Sizur: which one?
04:51:23 <SamB_XP> I mean, say I had buried a function in a newtype
04:51:26 <pejo> quicksilver, I know what a principal type is.
04:51:31 <wli> Cale: I think there's been more work on the structural subtyping since.
04:51:31 <Sizur> passing Nat to Int -> Int and getting Int back
04:51:36 <quicksilver> pejo: with subtyping, you don't have them any more
04:51:36 <Cale> O'Haskell had subtyping. I wonder how well that worked.
04:51:55 <quicksilver> pejo: instead you have <= or >= constraints on types
04:52:02 <wli> Cale: It was non-structural, and so a different form of subtyping for any I've considered.
04:52:03 <quicksilver> depending on co/contra variance
04:52:13 <quicksilver> ocaml has a certain kind of subtyping
04:52:18 <nominolo> Cale: that's record subtyping IIRC
04:52:20 <quicksilver> it has subtyping for its "polymorphic records"
04:52:21 <wli> quicksilver seems to be describing some of the issues pertinent to structural subtyping.
04:53:02 <wli> Subtyping on variants is what seems the most promising aspect of structural subtyping and is very sadly underemphasized.
04:53:08 <sjanssen> quicksilver: this sort of overlap will almost always happen in practice, AFAICT
04:53:14 <Cale> I suppose if we added proper record types, for example via Daan's proposal, we'd have a kind of subtyping.
04:53:23 <SamB_XP> never mind the difficulty of explaining to the compiler exactly which Int values are also in Nat
04:53:39 <pejo> Cale, quite well for any practical programs written apparently. Since the type inference was incomplete, you could of course write a program that didn't type check if you removed the type annotations.
04:53:59 <wli> SamB_XP: AIUI one doesn't even try; rather, injections from Nat -> Int (coercions) are provided.
04:54:27 <wli> SamB_XP: And going the other way is typically avoided.
04:54:47 * wli points to Dilip Siquiera's thesis.
04:55:03 <SamB_XP> hmm.
04:55:10 <quicksilver> sjanssen: hmm. I think there are a large class of uses where it doesn't
04:55:21 <quicksilver> sjanssen: such as those in the so called 'fine-grained class hierarchy'
04:55:42 <quicksilver> sjanssen: where, admittedly the instances for a type are mostly defined with that type, not elsewhere
04:56:00 <quicksilver> sjanssen: you may be right that adding such a feature is just going to annoy people when they try to apply it elsewhere
04:56:05 <sjanssen> quicksilver: do you propose special handling when the instances exist in the same module?
04:56:09 <wli> In Siquiera's thesis principal types are done away with in favor of minimal types or some such.
04:56:12 <quicksilver> sjanssen: no
04:56:19 <quicksilver> sjanssen: I'm just saying, you wouldn't get overlap then
04:56:26 <quicksilver> sjanssen: because, you'd know you planned to define Bar
04:56:35 <quicksilver> sjanssen: (and thus get an instance for Foo automatically)
04:56:40 <sjanssen> quicksilver: can you think of a single example that doesn't overlap?
04:56:45 <quicksilver> sjanssen: instance of first instancing Foo, and then instancing Bar
04:56:57 <Sizur> sjanssen: this is handled by importing with namespaces, doesnt it?
04:57:02 <quicksilver> sjanssen: yes. Making functor a proper superclass of Monad.
04:57:13 <quicksilver> sjanssen: then when I define a new type, I have two choices
04:57:14 <vali> write h "NICK" nick ... what "write" is being used here? i can't find it on hoogle
04:57:31 <quicksilver> sjanssen: (a) define ONLY Functor (b) define Monad, and get Functor for free
04:58:09 <quicksilver> sjanssen: true, if I define Functor and then later define Monad, I get the overlap issue
04:58:11 <sjanssen> quicksilver: so, "instance Functor F; instance Monad F", where the Monad class has a default for fmap
04:58:19 <wli> I just want to design a type system for this toy language powerful enough to carry out meaningful futzing around with module systems atop it.
04:58:26 <quicksilver> sjanssen: yeah, you have to not instance Functor explicitly
04:58:31 <sjanssen> quicksilver: the empty Functor instance will create fmap = error "not implemented"
04:58:45 <quicksilver> sjanssen: right. YOu have to instance only the 'most specific' class
04:58:52 <quicksilver> sjanssen: you only instance monad, and get functor for free
04:58:59 <sjanssen> quicksilver: what you want to achieve is a useful feature.  This is not the right way to approach it IMO
04:59:02 <Cale> wli: Will modules be values in the language, or would plain HM do?
04:59:03 <quicksilver> ;)
04:59:11 <pejo> quicksilver, in what way do you mean that the principal type 'goes away' - that it is not unique?
04:59:34 <SamB_XP> quicksilver: have you seen the class aliases proposal?
04:59:38 <wli> Cale: I'd like to stay away from the modules-as-values things.
04:59:50 <SamB_XP> wli: aww
04:59:52 <quicksilver> SamB_XP: absolutely. That's what I'm thinking of.
05:00:04 <quicksilver> pejo: you no longer get 'principal' types
05:00:11 <quicksilver> pejo: instead you et possible constraints on types
05:00:23 <wli> Cale: The meaningful futzing around basically means enough to carry over the MTL.
05:00:27 <quicksilver> pejo: this function accepts things which are subtype of Foo, supertypes of Bar, subtypes of Baz, etc
05:00:51 <quicksilver> sjanssen: are you familiar with john meacham's class alias proposal?
05:01:01 <SamB_XP> quicksilver: under class aliases, isn't the choice of how you instance something indicated by the name in the instance head?
05:01:26 <quicksilver> SamB_XP: under class aliases some classes are "only aliases" and other classes are "real classes". I think.
05:01:28 <wli> Cale: Not necessarily unmodified but with enough of a type system to have MonadState, MonadReader, etc. classes all stackable, liftIO, etc.
05:01:54 <Cale> wli: So modules in place of typeclasses?
05:02:11 <pejo> quicksilver, sure, twice gets the type (a -> b) -> a -> b | b < a.
05:02:11 <sjanssen> quicksilver: I've read it long ago
05:02:25 <wli> Cale: I'm shooting for in addition to, so I can do minor software engineering experiments for how they interact.
05:02:45 <Cale> I mean for your implementation of the MTL
05:03:02 <dylan> haskell people are everywhere.
05:03:28 <wli> Cale: I'd still want them done with type classes, though maybe using modules might be something to try.
05:03:50 <Cale> dylan: hehe
05:03:51 <wli> Cale: Do both, then compare, for instance.
05:04:25 <sjanssen> quicksilver: it does look better, "class alias FunctorMonad m = (Functor m, Monad m) where fmap = ..." seems actually implementable
05:04:25 <quicksilver> wli: I think you're a bit optimistic to think you can come up with something 'minimal' which supports the MTL
05:04:28 <Cale> dylan: There are a few of us using google blog search to look for new mentions of Haskell.
05:04:36 <quicksilver> the MTL is not really minimal at all
05:04:40 <sjanssen> it's just a simple source transformation
05:04:49 <wli> quicksilver: "Your goal is unrealistic" is a possible answer.
05:05:19 <SamB_XP> are type families easier or harder than MPTCs + fundeps?
05:05:43 <pejo> quicksilver, I think we're talking past eachother. I agree that if you design your type system badly you will destroy many properties that we've grown fond of.
05:06:07 <allbery_b> supposed to be easier, I think
05:06:26 <sjanssen> SamB_XP: from an implementation perspective?  There might be one person on the planet that really knows ;)
05:06:38 <SamB_XP> sjanssen: ChilliX?
05:06:53 <Cale> SamB_XP: I'm not sure, but they're supposed to look more like functional programming.
05:06:54 <dcoutts> aleator: ah hah, I've got the gtk2hs bug tracker working:
05:06:54 <dcoutts> http://hackage.haskell.org/trac/gtk2hs
05:06:56 <lambdabot> Title: Gtk2Hs - Trac
05:07:47 <Cale> SamB_XP: A lot of the type hackery involving fundeps is logic programming, which seems a little stylistically odd in a functional language.
05:08:15 <sjanssen> SamB_XP: I was going to say simonpj, because he's the original author of the fundeps stuff
05:08:23 <wli> quicksilver: Well, the idea is a *type system* sufficient to suppoort them.
05:08:40 <sjanssen> SamB_XP: 1 was probably too conservative, let's say less than half a dozen to be safe
05:08:56 <wli> quicksilver: So the bare minimum type system required for that, or some such.
05:09:08 <wli> brb kitchen fire
05:09:25 <sjanssen> @remember wli brb kitchen fire
05:09:25 <lambdabot> Nice!
05:10:28 <sjanssen> SamB_XP: from a user's perspective, type families seem to be the clear winner
05:10:34 <sjanssen> in my experience, at least
05:10:51 <quicksilver> SamB_XP: they seem nicer to me. As in, easier to read/comprehend.
05:11:14 <quicksilver> they *feel* more powerful although I'm not sure that's the case
05:11:29 <quicksilver> it might just be that the tricks to acheive more powerful things with ATFs are more intuitive to me
05:11:33 <quicksilver> than the equivalent FD tricks
05:12:56 <ketil> Anybody know what this means: ghc-6.8.0.20071017: unable to load package `old-locale-1.0'
05:13:22 <ketil> (Happens when I try to load a module in GHCi, it works fine when compiled)
05:13:59 <ketil>  % ghc-pkg list | grep locale
05:13:59 <ketil>     old-locale-1.0, old-time-1.0, packedstring-0.1, parallel-1.0
05:14:35 <SamB_XP> ketil: it could mean that that package doesn't have a .o file for GHCi...
05:23:07 <ketil> Hmm... this is the latest binary snapshot.
05:23:11 <ketil> Perhaps I should just compile it again.
05:23:34 <ketil> No, wait, it is the other way around - this is my self-compiled version.
05:30:20 <wli> quicksilver: Back. What's the verdict on the minimum required to support MTL's typeclass structure in a useful way?
05:30:56 <quicksilver> I suspect the minimum is GHC :)
05:31:04 <quicksilver> seriously, no further conclusion was reached.
05:31:13 <quicksilver> MTL uses FDs in some pretty hairy ways
05:31:22 <quicksilver> I think it needs undecidable instances?
05:31:48 <ricky_clarkson> Why does Eq define /= in terms of == but not also == in terms of /=?
05:32:19 <dcoutts_> quicksilver: according to mtl.cabal: extensions: MultiParamTypeClasses, FunctionalDependencies, FlexibleInstances, TypeSynonymInstances
05:32:25 <dcoutts_> so no undecidable instances
05:33:21 <wli> quicksilver: They don't need to be taken verbatim. Is it clear that I mean the general structure with the MonadState, MonadReader, MonadIO classes, lifting, and so on?
05:33:38 <quicksilver> yes that's clear
05:33:45 <quicksilver> but the answer isn't clear, to me at least :)
05:34:40 <wli> I also wonder which parts of H98's typesystem are disposable for my purposes. The first thing I can think of is defaulting.
05:34:40 <quicksilver> dcoutts_: I'm not sure exactly what FlexibleInstances means
05:34:53 <wli> I've never heard of it.
05:38:16 <wli> The Jacobian isn't even a square matrix.
05:39:02 <Saizan> -- Needs -fallow-undecidable-instances
05:39:02 <Saizan> instance (MonadReader r' m) => MonadReader r' (ContT r m) where
05:39:17 <Saizan> because of FD coverage condition
05:39:18 <wli> I looked at http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleInstances and was not enlightened.
05:39:20 <lambdabot> Title: FlexibleInstances - Haskell Prime - Trac, http://tinyurl.com/yrzrj5
05:39:56 <Saizan> (the flag is added with an OPTIONS pragma)
05:40:11 <dcoutts_> quicksilver: I think it means this:
05:40:11 <dcoutts_> http://haskell.org/ghc/dist/stable/docs/users_guide/type-class-extensions.html#instance-rules
05:40:13 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/2tezvb
05:40:47 <quicksilver> Saizan: that's what I thought I remembered
05:40:51 <quicksilver> Sizur: (undecidable)
05:41:50 <Saizan> yeah, so the undecidable part is about the auto-lifting
05:43:29 <Sizur> quicksilver: was that for me?
05:44:37 <quicksilver> Sizur: no, not really :) sorry
05:44:51 <Sizur> sok
05:46:53 <quicksilver> autocomplete is a menace! :)
05:50:51 <MyCatSchemes> Did someone poke me?
05:51:38 <MyCatSchemes> xchat shows #haskell highlighted, but the backscroll doesn't contain whatever message that must've been from.
05:52:23 <ari> The last reference to you that I see is < Sizur> MyCatSchemes: heh, well, i believe it was a choice, so there must be a reason, i'd like to know why i cannot do what i should be able to do
05:57:27 <wli> So it's sounding like that there is not even a readily-available answer as to what the type system I'm wanting has as its requirements.
05:59:42 <hpaste>  gg annotated "having trouble with simple string rotation attempt" with "(no title)" at http://hpaste.org/3530#a1
06:00:55 <quicksilver> wli: It certainly seems that none of us know :)
06:01:04 <quicksilver> wli: I certainly agree it would be interesting to know
06:02:01 <wli> If extensions can be done away with while retaining the structure, even at the cost of efficiency, I'd regard it as the way to go for the toy language.
06:02:32 <wli> I also don't really understand AT's and/or TF's.
06:05:13 <MyCatSchemes> ari: thank you.
06:05:16 <wli> I've a vague idea that type equality constraints are floating around somewhere in all this.
06:15:22 <hpaste>  Donn pasted "Is this form of a server loop OK?" at http://hpaste.org/3534
06:15:49 <shapr> Good morning #haskell!
06:15:58 <Donn> if someone could take a look at the code I posted
06:15:59 <arcatan> Good morning
06:16:43 <Donn> and tell me if recursive "runServer" call is an acceptable form of a long-running server?
06:17:49 <oerjan> Donn: should be perfectly fine
06:18:02 <quicksilver> Donn: that's what I always do :)
06:18:27 <oerjan> tail call optimization is expected in haskell
06:19:13 <opqdonut> tail calls and laziness result in some interesting problems, though
06:19:25 <Donn> thanks for encouragement! by tail call optimization you mean that I won't get a ever-growing stack of "runServer" function calls?
06:19:26 <quicksilver> it's only an 'optimization' relative to a particular expectation of how you might compile it
06:19:32 <oerjan> right
06:19:36 <quicksilver> and that's actually not a tail-call anyway
06:19:46 <quicksilver> the 'top function' there is (>>)
06:19:50 <quicksilver> not runServer
06:20:07 <opqdonut> yeah that's sequencing rather than calling
06:20:09 <oerjan> i think it will end up in the tail eventually, won't it?
06:20:12 <opqdonut> depends on how you look at it
06:20:16 <quicksilver> it is, in some sense, an indirect tail cail
06:20:24 <quicksilver> mutally via (>>)'s own implementation
06:20:29 <quicksilver> (in the IO monad in particular)
06:20:41 <oerjan> because of laziness, indirect tail calls are sometimes the best
06:21:59 <quicksilver> the main concerns about lazines + tail alls don't apply to IO sequences
06:22:07 <quicksilver> because IO sequences are strict "in the action"
06:22:08 <oerjan> right, it wouldn't work in every monad
06:22:29 <quicksilver> yeah, in certain monads that would accumulate huge thunks
06:22:34 <quicksilver> depending what "run" means in that monad
06:22:50 <quicksilver> Donn: short answer is "yes, that's fine, dont' worry about it" though :)
06:22:55 <raxas> perhaps such an universal "design pattern" belongs to the wiki together with quicksilvers's explanation :)
06:23:02 <Donn> ok, thanks :-)
06:23:22 <quicksilver> the case where it would matter is something like StateT Int IO
06:23:31 <quicksilver> if you acummulate something increasing complex in the state
06:23:33 <oerjan> some people might use sequence_ . repeat instead
06:23:34 <quicksilver> but never actually force it
06:24:04 <quicksilver> oerjan: some people define forever a = a >> forever a
06:24:07 <quicksilver> (which is the same thing)
06:24:24 <roconnor> @type forever
06:24:28 <quicksilver> except it works
06:24:29 <lambdabot> Not in scope: `forever'
06:24:35 <quicksilver> sequence_ . repeat doesn't work
06:24:37 <quicksilver> I was being stupid :)
06:24:45 <roconnor> @type let forever a = a >> forever a in forever
06:24:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
06:24:51 <oerjan> quicksilver: that's why there is State.Strict, i assume
06:24:57 <quicksilver> sequence_ never terminates on infinite lists
06:24:58 <roconnor> @type sequence_ . repeat
06:24:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
06:25:00 <quicksilver> in most monads, at least
06:25:05 <quicksilver> certainly it won't in IO
06:25:32 <oerjan> @src sequence_
06:25:33 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
06:26:12 <roconnor> what, and forever does terminate?
06:27:54 <Sizur> it does governate!
06:28:17 <oerjan> although forever has the advantage (possibly) that it's m b -> m a rather than m b -> m ()
06:28:27 <Sizur> but only in California monad
06:28:29 <roconnor> > let forever a = a >> forever a in forever (fail "I'll be back!")
06:28:31 <lambdabot>   add an instance declaration for (Show (m b))
06:28:50 <roconnor> > let forever a = a >> forever a in forever (fail "I'll be back!") :: Error String ()
06:28:51 <lambdabot>      Class `Error' used as a type
06:28:51 <lambdabot>     In the type `Error String ()'
06:28:51 <lambdabot>     In an...
06:28:57 <roconnor> > let forever a = a >> forever a in forever (fail "I'll be back!") :: Eitehr String ()
06:28:58 <lambdabot>   Not in scope: type constructor or class `Eitehr'
06:29:03 <roconnor> > let forever a = a >> forever a in forever (fail "I'll be back!") :: Either String ()
06:29:05 <lambdabot>  Left "I'll be back!"
06:29:23 <roconnor> > sequence_ . repeat $ (fail "I'll be back!") :: Either String ()
06:29:24 <lambdabot>  Left "I'll be back!"
06:29:25 <shapr> How long till 6.8?
06:29:40 <Sizur> it's already available
06:30:02 <shapr> It's been released?
06:30:02 <dozer> oh? any chance it will it be packaged for ubuntu any time soon?
06:30:17 <Sizur> it's in portage already
06:30:28 <roconnor> and do we get a better cabal?  one with optimizations?
06:30:36 <quicksilver> roconnor: forever is at least productive
06:30:38 <roconnor> ... and all the libraries
06:30:42 <quicksilver> roconnor: that is, it carries out effects
06:30:46 <Saizan> quicksilver: sequence_ . repeat is productive in the effects
06:30:52 <quicksilver> Saizan: really?
06:30:56 <quicksilver> hmm
06:31:04 <roconnor> @src sequence_
06:31:04 <Saizan> well, at least for IO
06:31:04 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
06:31:26 <quicksilver> ah ok
06:31:27 <roconnor> what part of foldr (>>) don't you understand? :P
06:31:32 <quicksilver> the problem is only with sequence
06:31:35 <quicksilver> not sequence_
06:31:38 <roconnor> @src sequence
06:31:39 <lambdabot> sequence ms = foldr k (return []) ms
06:31:39 <lambdabot>     where
06:31:39 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
06:31:39 <oerjan> > fst $ runWriter $ sequence_ . repeat $ tell "yes "
06:31:41 <lambdabot>  Exception: <<loop>>
06:31:48 <oerjan> > snd $ runWriter $ sequence_ . repeat $ tell "yes "
06:31:50 <lambdabot>  "yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes...
06:32:02 <quicksilver> if you demand the result of sequence (infinite list)
06:32:06 <roconnor> oerjan: interesting
06:32:07 <quicksilver> then you stop it being productive
06:32:20 <quicksilver> but sequence_ is OK because that doesn't demnad the result
06:32:27 <oerjan> > snd $ runWriter $ sequence . repeat $ tell "yes "
06:32:28 <lambdabot>  "yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes...
06:32:59 <ricky_clarkson> > ["yes"..]
06:33:00 <lambdabot>   add an instance declaration for (Enum [Char])
06:33:00 <lambdabot>     In the expression: ["yes"...
06:33:03 <oerjan> quicksilver: actually you cannot demand the result in either case (as my <<loop>> above showed)
06:33:14 <oerjan> but you can take the effects
06:33:24 <shapr> > let yesman = "yes":yesman in yesman
06:33:25 <lambdabot>  ["yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","ye...
06:33:34 <roconnor> I had this problem with my DNA monad.  When I checked the reults was done, it pulled everything into memory.  But not checking the result type, I could lazilly get my writer output.
06:33:38 <oerjan> or wait...
06:33:47 <quicksilver> oerjan: interesting
06:33:53 <profmakx> hm
06:33:54 <profmakx> > repeat "yes"
06:33:55 <lambdabot>  ["yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","ye...
06:33:57 <Japsu> > unwords $ fix ("yes:"]
06:33:57 <lambdabot> Unbalanced parentheses
06:33:58 <oerjan> > fst $ runWriter $ sequence . repeat $ tell "yes "
06:33:59 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
06:34:01 <Japsu> > unwords $ fix ("yes:")
06:34:01 <lambdabot>  Couldn't match expected type `a -> a'
06:34:07 <Japsu> > unwords $ fix ("yes":)
06:34:08 <shapr> oerjan: Sounds like it needs a wiki page or -cafe post.
06:34:08 <lambdabot>  "yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes...
06:34:12 <Japsu> fail.
06:34:27 <Sizur> @type repeat
06:34:28 <lambdabot> forall a. a -> [a]
06:34:32 <Japsu> @cycle "yes "
06:34:33 <lambdabot> Unknown command, try @list
06:34:37 <Japsu> > cycle "yes "
06:34:39 <lambdabot>  "yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes...
06:34:42 <shapr> oerjan: Cannot demand the result but can take the effect sounds really nifty.
06:34:50 <Sizur> @type cycle
06:34:51 <lambdabot> forall a. [a] -> [a]
06:35:21 <quicksilver> as long as the effects are somehow lazily productive
06:35:28 <quicksilver> which the writer monad is
06:35:30 <quicksilver> and so is IO
06:35:32 <quicksilver> intriguing...
06:35:46 <quicksilver> at least, GHC's implementation of IO is
06:35:51 <quicksilver> I wonder if that's part of the specification of IO or not
06:36:39 <oerjan> shapr, quicksilver: actually sometimes you can demand results too, as my [(),(),... above showed
06:36:58 <ivanm> what does "openFile: resource busy (file is locked)" mean?
06:37:21 <Sizur> lol
06:37:28 <ivanm> only the single thread should be using that file... in each stage of the loop, it appends something
06:37:39 <ivanm> doesn't that thread "pause" whilst it's writing to the file?
06:37:57 <ivanm> this works when using ghci, but not when compiling and running it
06:38:13 <quicksilver> ghci still has it open, I imagine
06:38:18 <quicksilver> (and you're using windows :P)
06:38:37 <ivanm> nope, not windows
06:38:45 <ivanm> and I doubt ghci is using it, but I'll close ghci and check
06:38:54 <ivanm> (seeing as how the file shouldn't exist yet...)
06:39:19 <ivanm> and it works for the first 86 of 101 timesteps...
06:40:04 <shapr> oerjan: Ok, can you explain when you can demand the result and when you cannot demand the result but you can take the effects?
06:40:18 <oerjan> > (runState . sequence . repeat $ modify (+1) >> get) 0
06:40:20 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:40:58 <ivanm> well, closing ghci worked :s
06:41:02 <ivanm> which was rather weird
06:41:10 <oerjan> shapr: first, sequence_ . repeat can never demand the result, because it's a loop that never produces anything
06:41:32 <quicksilver> the result of sequence_ . repeat is a single ()
06:41:39 <quicksilver> but that single () is only produced 'at the end' of the list
06:41:41 <shapr> right
06:41:41 <quicksilver> which never happens
06:42:05 <Sizur> i have a philosophical question: why template-haskell?
06:42:24 <dcoutts_> Sizur: meta programming is cool
06:42:30 <Sizur> seems to be just a hackery
06:42:51 <Sizur> dcoutts_: i thought being static is haskell's strength
06:42:53 <quicksilver> so you can write your own derivings, for example?
06:42:53 <oerjan> sequence . repeat may produce a result if the monad is lazy in effects
06:42:56 <shapr> Sizur: You could see it that way, but AST rebuilding is popular in the lisp world.
06:43:11 <dcoutts_> Sizur: have you never generated a program? eg used a parser/lexer generator?
06:43:40 <Sizur> shapr: but you are not a lisper ;)
06:43:46 <dcoutts_> Sizur: generative programming is a pretty powerful technique, it need not be hackery
06:43:49 <Sizur> dcoutts_: i'm perler, so i do that regularly
06:43:57 <dcoutts_> Sizur: and note that template haskell is static
06:44:09 <shapr> I don't think any one programming language is part of my identity, but I could be wrong.
06:44:37 <shapr> Haskell is currently my favorite, but I will be disappointed if nothing better comes along during my lifetime.
06:44:38 <Sizur> dcoutts_: but cannot you abstract enough without the help of templating?
06:45:02 <dcoutts_> Sizur: I not sure I know what you're asking
06:45:03 <Sizur> math is that powerful
06:45:15 <roconnor> shapr: Epigram 2!
06:45:22 <shapr> roconnor: Is it usable yet?
06:45:28 <roconnor> it doesn't exist yet
06:45:29 * shapr checks e-pig
06:45:37 <shapr> aww
06:45:44 <roconnor> ... agda 2?
06:45:46 <matthew-_> I thought I heart the epi ppl were moving to something els?
06:45:50 <matthew-_> yeah, that.
06:45:50 <Cale> Sizur: Well, there are some places where it's not so easy to abstract. For example, let's say you want to take some external data at compile time, and use it to generate some type declarations.
06:46:04 <Cale> Er, data declarations, sorry.
06:46:22 <dcoutts_> Sizur: generative programming is not necessarily about expressiveness, it can be about performance, generating efficient programs from specifications
06:46:25 <Cale> For example, defining a datatype based on the structure of a database.
06:46:44 <Cale> (Without hand-coding it)
06:48:03 <Sizur> can you reason about or even better, prove a templated code? (note i've never done template-haskell)
06:48:30 <shapr> TH is statically typed.
06:48:50 <Cale> kinda :)
06:48:59 <Sizur> doesn't it simply inject a piece of text in a specific place?
06:49:05 <Cale> not text
06:49:10 <shapr> Not as much as MetaML, but lots more than common lisp.
06:49:16 <opqdonut> fail forever
06:49:18 <Cale> You're working with syntax trees as data structures directly.
06:49:26 <opqdonut> woops, i was scrolled up
06:50:08 <Cale> You can't say a-priori what type an expression will have, but the typechecker is used to maintain some syntactical correctness, and then will be run on the resulting code afterward.
06:50:38 <Cale> So it's not *quite* as powerful as you might hope for, but it's not bad.
06:51:35 <Sizur> Cale: thanks
06:51:41 <hpaste>  gg annotated "Kind error: `AbstractInteger' is not applied to enough type arguments???" with "(no title)" at http://hpaste.org/3518#a1
06:53:19 * Cale thinks about improving his Imlib binding.
06:57:40 * Sizur impressed by Epigram
06:58:53 <ToRA>           power series and continued fractions and so on that do far better.
06:58:53 <ToRA> <dmwit> (Not the most elegant solution, but it should do the trick.)
06:58:53 <ToRA> <roconnor> wli: Sounds true
06:58:53 <ToRA> -:- njbartlett_ [n=njbartle@64.241.49.98] has joined #haskell
06:59:39 <matthew-_> err, ToRA says he's sorry
06:59:46 <tora> sorry guys
06:59:50 * tora slipped with middle mouse button
07:00:09 <matthew-_> ...said the bishop to the actress...
07:01:57 <ivanm> if I have a list of elements representing a path, how can I remove loops from it?
07:02:09 <matthew-_> depth first search
07:02:15 <matthew-_> just record where you've been
07:02:26 <matthew-_> you'll find cycles very easily
07:02:29 <ivanm> well, I am recording where I've been...
07:02:33 <ivanm> that's what this list is
07:02:58 <Sizur> so you have a graph originaly?
07:03:08 <ivanm> no.... this is 2D co-ords of an array
07:03:14 <ivanm> from a random walk
07:05:06 <[chr0n0s]> when i type this, area :: Int -> Float (next line) area r = 3.14 * r * r
07:05:13 <[chr0n0s]> i get error in hugs
07:05:34 <ivanm> [chr0n0s]: you need to do (fromIntegral r)
07:05:53 <[chr0n0s]> ivanm, in the type definition ?
07:05:58 <ivanm> so: area r = let r' = fromIntegral r in 3.14 * r' * r'
07:06:14 <[chr0n0s]> oh..
07:06:16 <[chr0n0s]> let me try
07:06:21 <ivanm> in Haskell, there's no automatic conversions to/from floats
07:06:49 <[chr0n0s]> hmm.. thanks, i'll be back with few more problems later, just started on haskell :)
07:07:24 <ivanm> matthew-_, Sizur: so, I'd want something like: removeLoops [1,2,3,9,8,0,3,4,5] = [1,2,3,4,5]
07:07:31 <ivanm> any ideas?
07:08:21 <oerjan> there is some ambiguity there.  what if two loops overlap?
07:09:03 <ivanm> hmmm....
07:09:36 <oerjan> [1,2,6,3,2,3,5] -> [1,2,6,3,5] or [1,2,3,5]
07:10:04 <ivanm> didn't think about that...
07:11:09 <oerjan> hm it might be easiest to remove the last ones first, could use a foldr
07:11:35 <profmakx> as of this moment, there is a bootstrapped version of ghc-6.6.1 for freebsd7/amd64
07:12:30 <ivanm> oerjan: yeah...
07:12:38 <oerjan> > let prep x l = if x `elem` l then dropWhile (/=x) l else x:l in foldr prep [] [1,2,6,3,2,3,5]
07:12:40 <lambdabot>  [1,2,6,3,5]
07:12:58 <oerjan> voila
07:13:02 <ivanm> I was thinking of doing a recursive break, to save traversing the list twice
07:21:40 <Cale> c2hs: Error in C header file.
07:21:40 <Cale> /usr/include/bits/pthreadtypes.h:69: (column 6) [FATAL]
07:21:40 <Cale>   >>> Syntax error!
07:21:40 <Cale>   The symbol `;' does not fit here.
07:22:05 <Cale> anyone familiar with c2hs have any ideas about what I might do about something like that?
07:24:08 <Cale> ah, okay, apparently I need a newer version
07:27:02 <Cale> (Annoying that Ubuntu always has such old versions of all the Haskell stuff.)
07:28:21 <araujo> Cale, use the best distro for Haskell
07:28:23 <araujo> :-)
07:31:50 <Cale> araujo: building things yourself? Yeah, that's what I'm doing ;)
07:32:05 <ricky_clarkson> Does Gentoo do better?
07:32:12 * raxas agrees with araujo that gentoo is the best and patiently waits until ghc-6.8.0.20071028 bootstraps
07:32:37 <araujo> :-)
07:32:50 <dylan> gentoo is best for ghc, especially on ppc.
07:33:06 <Cale> Does Gentoo really default to a pre-release version of GHC?
07:33:22 <araujo> Cale, no default on gentoo
07:33:45 <araujo> Cale, it's up to you, we have an experimental overlay that makes easy to get these alpha versions tested
07:33:51 <dylan> I think every version of ghc is "unstable"-tagged on gentoo, because it's a non-C compiler.
07:34:08 <Cale> So you're saying that you choose the version of every package on your system?
07:34:36 <dylan> err, no.
07:35:10 <dylan> I think by default ghc (at least 6.6) is listed as "unstable", and won't be installed unless you edit a file.
07:35:35 <dylan> most compilers for languages other than C are also listed "unstable"
07:35:42 <araujo> Cale, we have different branch for packages in portage, stable, testing, masked
07:36:04 <dylan> ocaml is really, really abused in gentoo, for instance.
07:36:26 <dylan> You get QA notices because it compiles things with an executable stack.
07:36:47 <araujo> Cale, your default will depend upon what branch you want to use; though you also can mix branches of packages
07:36:54 <Cale> Does gentoo still have up-to-date binary packages for GHC?
07:37:15 <araujo> Cale, we have binaries for ghc6.6
07:37:21 <Cale> That's good.
07:37:45 <araujo> yeah
07:38:08 <dylan> I'm glad people like araujo are around, so ghc doesn't get treated so much like a second-class citizen in gentoo. :)
07:38:29 <Cale> I remember bugging dcoutts to add some so that my friend using gentoo wouldn't have to waste her time waiting for it to build ;)
07:39:09 <dylan> ghc compiles pretty fast on 2-core 3ghz machine with 4G of ram.
07:39:54 <araujo> dylan, hah
07:40:03 <araujo> dylan, i am not the only one ;-)
07:40:10 <profmakx> dylan try unregisterised
07:40:11 <dylan> araujo: I said "people like"
07:40:14 <profmakx> :]
07:40:16 <araujo> we have a good Haskell user base
07:40:27 <araujo> dylan, yeah get it , thanks :-)
07:46:25 <smtms> win 7
07:46:30 <smtms> sorry
07:47:23 <fasta> Can I make a graph/plot of the time usage for various functions with some existing tool?
07:47:31 <profmakx> gnuplot?
07:47:55 <fasta> I mean that the output of a profile contains that function X uses Y% time etc.
07:48:09 <fasta> And I mean that somebody else already did the mapping.
07:59:15 <dons> ?users
07:59:15 <lambdabot> Maximum users seen in #haskell: 424, currently: 388 (91.5%), active: 14 (3.6%)
07:59:23 <dons> another high score
07:59:43 <daniel_larsson> I thought high scores where the norm? )
07:59:51 <dons> seems to be
07:59:52 <daniel_larsson> *were
08:00:18 <ricky_clarkson> Perhaps the summer dabbling period is over.
08:00:33 <quicksilver> fundamental thm of some kind of statistics
08:00:47 <quicksilver> like the famous question "why do we keep breaking world records? Are runners getting faster?"
08:01:00 <wli> Fundamental theorem of demographics?
08:02:01 <daniel_larsson> Because we keep inventing better steroids?
08:02:16 <wli> I'm not sure what theorem quicksilver has in mind.
08:02:17 <dozer> because we are sampling an extreme value distribution?
08:03:13 <wli> I think there is actually some sort of physical fitness effect going on.
08:03:28 <wli> I don't really know for sure.
08:04:51 <adaptable> People are more able to dedicate themselves fully to their sport.
08:07:11 <quicksilver> I actually meant the sampling point
08:07:28 <quicksilver> the physical fitness point is interesting but even without that
08:07:48 <quicksilver> however, it doesn't apply to lambdabot's user count :) I was being facetious.
08:08:32 <dons> so why do we keep breaking the user count high score?
08:08:50 <dons> http://programming.reddit.com/info/5zfut/details
08:08:51 <lambdabot> Title: programming: For loops for Haskell
08:09:40 <dons> so what's going on with this  stuff, http://darcs.haskell.org/packages/base/Control/Category.hs
08:10:14 <profmakx> ghc 6.8 build is broken if the include and libdir is given to configure *grml*
08:11:19 <hpaste>  replicahermes pasted "replica hermes" at http://hpaste.org/3535
08:11:46 <quicksilver> dons: what do you mean 'what's going on with this stuff' in that context?
08:11:46 <dons> ah ha.
08:12:09 <oerjan> > cycle "SPAM "
08:12:11 <lambdabot>  "SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM ...
08:12:13 <dons> quicksilver: it seemed to appear suddenly. is there a paper/is it sound?
08:12:25 <dons> is the name ok?
08:12:31 <quicksilver> dons: :)
08:12:37 <quicksilver> dons: it was discussed for some time on libraries@
08:12:39 <hpaste>  replicarings pasted "replica rings" at http://hpaste.org/3536
08:12:49 <dons> yes, i thought there was some contention
08:13:00 <quicksilver> dons: the proposer avoided the contentions parts
08:13:06 <quicksilver> or that's his feeling, anyway
08:13:14 <dons> ah ok
08:13:17 <quicksilver> and put in the simple superclass
08:13:23 <dons> why is it in base?
08:13:54 <Saizan> is it a superclass of Arrow?
08:14:03 <ivanm> I'm getting that "openFIle: resource busy (file is locked)" error again... :s
08:14:07 <ivanm> and ghci isn't running
08:14:41 <quicksilver> it's a superclass of Arrow, I believe
08:14:48 <quicksilver> (and Arrow is in base?)
08:14:56 <ivanm> anyone got any ideas why that error keeps coming up?
08:15:01 <oerjan> ivanm: are you closing it properly after use?
08:15:35 <ivanm> oerjan: I have an IO () loop, where I append to it in each loop... it works for a while, then suddenly freezes...
08:15:36 <Saizan> (yes)
08:15:54 <oerjan> !paste
08:15:54 <hpaste> Haskell paste bin: http://hpaste.org/
08:16:07 <quicksilver> osfameron: did you in fact, work out the answer to your problem ?
08:16:33 <osfameron> quicksilver: hi.  Which problem specifically?
08:16:42 <oerjan> ivanm: paste ^^
08:16:46 <osfameron> <-- very confused this afternoon
08:16:51 <quicksilver> osfameron: the blog post :)
08:16:54 <hpaste>  ivanm pasted "file access issues" at http://hpaste.org/3537
08:17:00 <ivanm> oerjan: ^^
08:17:05 <ivanm> that's the relevant bit of code
08:18:09 <osfameron> quicksilver: ah!  Well, I got 2 pointers, but haven't yet edited/retested the code
08:18:54 <quicksilver> osfameron: your idea to insert a recursive call to 'for' in the 'then' part looked fine
08:19:10 <ivanm> oerjan: I fail to see any function with a name like "closeFile" where writeFile and appendFile are in the haddock docs for the prelude...
08:19:15 <quicksilver> osfameron: I imagine the problem you had was not making the 'then' part into a 'do' expression
08:19:24 <osfameron> quicksilver: that's what I thought until I got crazy errors :-)
08:19:47 <quicksilver> osfameron: you can't say if foo then a b else ...  where 'a' and 'b' are both IO () actions
08:19:49 <osfameron> quicksilver: my problem is that I still don't deeply understand what the do's are doing
08:19:59 <quicksilver> osfameron: you want to say if foo then a >> b else ...
08:20:11 <quicksilver> osfameron: which means "the action composed from doing a and then doing b"
08:20:21 <quicksilver> osfameron: "shorthand" for a >> b is do a ; b
08:20:22 <oerjan> ivanm: yeah you'd think they would do it automatically
08:20:48 <ivanm> the only thing I can think of, is that the thread is trying to write to the file whilst the last iteration of the thread is still writing to it...
08:20:50 <osfameron> quicksilver: ok, that makes sense
08:20:55 <quicksilver> ivanm: I think that's it
08:21:00 <ivanm> oh well
08:21:08 <ivanm> I was using that just for debugging anyway...
08:21:12 <quicksilver> ivanm: nothing in the semantics of threads guarantees you won't get a context-switch partway through an 'appendFiel'
08:21:12 * ivanm disables it
08:21:17 <osfameron> quicksilver: I'm surprised that wasn't one of the combinations that I randomly tried last night :-)
08:21:22 <quicksilver> ivanm: except it's fairly unlikely :)
08:21:34 <ivanm> heh
08:21:55 <quicksilver> if you're writing to a file from multiple threads, you need to serialise it yourself
08:21:59 <quicksilver> a 'Chan' is ideal
08:22:32 <ivanm> quicksilver: no, it's the same thread each time
08:22:38 <ivanm> 1 file/thread
08:22:54 <quicksilver> hmm
08:23:06 <ivanm> well, I'm going to let this run without those debugging files to see if it does what I want it to :p
08:23:14 <oerjan> ivanm: if you are really using just one thread as it seems, then perhaps it's a bug in ghc
08:23:15 <quicksilver> then I think it might be a bug in appendFiel
08:23:34 <quicksilver> or, you somehow have a biug which gives two ants the same ID?
08:23:59 <ivanm> quicksilver: I create the ants by doing a mapM over [1..last_ant]
08:24:11 <quicksilver> doesn't seem very likely then...
08:24:58 <oerjan> quicksilver: even then it should not happen should it?  two successive appendFile to the same file should work
08:25:25 <quicksilver> oerjan: they won't necessarily be successive
08:25:26 <mrd> mm lazy IO
08:25:29 <quicksilver> oerjan: if they're in different threads
08:25:40 <oerjan> quicksilver: he says there is just one thread!
08:25:40 <quicksilver> oerjan: so, if he has two different ants with the same ant id
08:25:49 <quicksilver> oerjan: no, he said one thread per file
08:25:52 <quicksilver> oerjan: not one thread :)
08:25:55 <oerjan> oh...
08:26:05 <quicksilver> mrd: appendFile isn't lazy output, is it?
08:26:09 <quicksilver> (surely not!)
08:26:29 <oerjan> ah
08:28:38 <Saizan> maybe he needs something like inBoundThread?
08:28:51 <oerjan> id is a bit dangerous variable name...
08:31:31 <hpaste>  watchreplicas pasted "watch replicas" at http://hpaste.org/3538
08:32:11 <quicksilver> Saizan: bound threads are not relevant to file IO, as far as I know
08:32:30 <quicksilver> Saizan: bound threads are just relevant to specific library bindings which use (OS-)thread-local state
08:32:39 <quicksilver> e.g. openGL, gtk2hs
08:33:29 <chessguy> hm, no hpaste ops around?
08:34:26 <chessguy> @tell glguy looks like spam:  http://hpaste.org/3538
08:34:26 <lambdabot> Consider it noted.
08:34:55 <chessguy> @seen glguy
08:34:55 <lambdabot> I saw glguy leaving #xmonad and #haskell 6h 41m 4s ago, and .
08:35:21 <chessguy> @seen shapr
08:35:21 <lambdabot> shapr is in #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 53m 4s ago.
08:39:53 <profmakx> hm
08:40:15 <profmakx> is this dotted-quad-version-numbering the latest and greatest for ghc?
08:41:12 <profmakx> (packages that is)
08:43:25 <bos> @seen conal
08:43:25 <lambdabot> conal is in #haskell, #ghc and #xmonad. I last heard conal speak 6m 41s ago.
08:43:47 <laz0r> hi #haskell, i'm wondering if I can use hs-plugins with ghc6.6?
08:44:06 <laz0r> it seems that it doesnt recognize the .hi format
08:44:12 <conal> bos: howdy.
08:44:31 * osfameron notices up and downvotes to his post in reddit, decides it's probably best not to care :-)
08:44:38 <bos> conal: did you get my mail?
08:44:50 <laz0r> if I can't use it with 6.6, which version of ghc would work? do i need to downgrade to 6.4?
08:44:51 <conal> bos: yep and just replied.  thanks much.
08:45:00 <bos> ok, great. hope something works out.
08:45:05 <conal> :)
08:48:06 <quicksilver> laz0r: there are versions of hs-plugins which work with 6.6
08:48:12 <quicksilver> laz0r: I can't tell you which
08:48:14 <quicksilver> @version
08:48:14 <lambdabot> lambdabot 4p571, GHC 6.6 (Linux i686 2.66GHz)
08:48:14 <lambdabot> darcs get http://code.haskell.org/lambdabot
08:48:18 <quicksilver> ^^ proof!
08:48:25 <oerjan> laz0r: iirc each version of hs-plugins only works with one version of ghc, more or less
08:48:37 <oerjan> because the .hi format changes
08:49:07 <laz0r> yes, i kind of found out that myself
08:49:22 <laz0r> i have been using the ubuntu packages of ghc6 and hs-plugins
08:49:51 <geocalc> ubuntu :(
08:49:53 <laz0r> would it help if i just did my own build of ghc6 and hs-plugins?
08:49:57 <profmakx> well. 6.8 builds on freebsd7/amd64 :)
08:50:00 <laz0r> from the darcs repository?
08:50:01 <profmakx> \o/
08:50:24 <geocalc> 6.9 so
08:51:00 <laz0r> geocalc, i know, but i am kind of stuck with my distribution choice... maybe someday i go back to gentoo or something completely different
08:51:19 <laz0r> but a t the moment, i just need to get hs-plugins to work...
08:52:55 <Saizan> laz0r: you need to compile hs-plugins from the darcs repo
08:54:38 <laz0r> Saizan, ok, right now im downloading the current stable source tarball of ghc and i am going to build that, then i try to build hs-plugins
08:54:46 <laz0r> should that work?
08:54:56 <laz0r> or do i need to use the darcs version of ghc too?
08:55:06 <Saizan> you don't need to build ghc yourself
08:55:28 <Saizan> and i think hs-plugins won't work with ghc > 6.6.1
08:56:09 <laz0r> i tried the hs-plugins darcs version with 6.6 and 6.6.1, both didn't work
08:56:28 <laz0r> i always get that .hi format error
08:56:33 <geocalc> mmh
08:57:06 <Saizan> weird
08:57:21 <shapr> Comcast is by far the worst ISP I've ever used.
09:02:35 <laz0r> would it be a very hard task to adapt hs-plugins to whatever .hi format i am using?
09:04:41 <Lemmih> laz0r: What .hi format are you using?
09:05:24 <laz0r> that of ghc6.6 or ghc6.6.1, at least those are the ghc version i tried hs-plugins with
09:05:48 <Lemmih> hs-plugins should "work" with ghc-6.6
09:06:32 <laz0r> mmh
09:10:14 <laz0r> could there be another reason than the .hi format for errors like this: '*** Exception: Ix{Int}.index: Index (3145728) out of range ((0,8))' ?
09:10:22 <shapr> hei esap, long time no see
09:10:29 <esap> Hei
09:10:34 <shapr> What's up?
09:10:36 <Lemmih> laz0r: Probably not.
09:10:49 <esap> learning to use XChat :-)
09:10:57 <shapr> cool
09:11:40 <esap> bought a new machine some time ago and been installing sw on it, decided to try xchat...
09:11:46 <ricky_clarkson> I sent one patch to xchat, then they started charging Windows users for the privelege of having a .exe.  irssi these days.
09:16:25 <chris2> (and then people ended up using unofficial exes, which work just as well)
09:18:19 <esap> My compiler still doesn't compile with GHC :-)
09:18:42 <laz0r> uh, hs-plugins works! i just can't use it with ghci...
09:19:11 <laz0r> although i enable the --enable-library-for-ghci option
09:19:20 <laz0r> but still, it works!
09:20:34 <chessguy> shapr, i don't remember, do you have hpaste privileges?
09:25:53 <fasta> Offering xchat is a wonderful way to expand your botnet.
09:26:22 <shapr> chessguy: Yes, I do. It's running on my server last I checked.
09:28:48 <chessguy> shapr, ah, you may want to check out the recent span then
09:28:52 <chessguy> uh
09:28:53 <chessguy> spam
09:29:39 <chessguy> hey osfameron, interesting blog about for loops today
09:30:42 <osfameron> chessguy: heh, thanks :-)
09:31:05 <chessguy> unfortunately, my comments didn't work correctly
09:32:27 <chessguy> also, i assume you know this:
09:32:29 <chessguy> @pl \x -> putStr $ show x
09:32:29 <lambdabot> putStr . show
09:32:40 <osfameron> chessguy: yeah, vox's comments are rubbish.  I've just sent them feedback
09:32:56 <osfameron> chessguy: I worked that out this morning just after posting :-)  thanks though!
09:33:19 <chessguy> cool. did you get the do-notation version working yet?
09:34:30 <opqdonut> link to post?
09:34:34 <osfameron> ah, I haven't had time (my stupidly complex SQL transaction code decided to bite me in the arse today)
09:34:45 <osfameron> pesky work
09:35:04 <osfameron> opqdonut: http://osfameron.vox.com/library/post/for-loops-in-haskell.html
09:35:04 <chessguy> oh sorry, opqdonut: http://osfameron.vox.com/
09:35:52 <opqdonut> osfameron: is your nick "os fame ron" or "osfameron"
09:35:58 <opqdonut> if you catch my drift
09:36:42 <osfameron> opqdonut: I think it's pronounced os-fa-meh-ron (character in Diane Wynne Jones novels)
09:36:57 <arcatan> meh
09:37:15 <opqdonut> ah, okay
09:37:18 <chessguy> @type \i p pp f -> when (p i) $ do {f i; for (pp i) p pp f}
09:37:20 <lambdabot> Not in scope: `for'
09:37:42 <chessguy> @type let for i p pp f -> when (p i) $ do {f i; for (pp i) p pp f} in for
09:37:43 <lambdabot> parse error on input `->'
09:37:53 <chessguy> @type let for i p pp f = when (p i) $ do {f i; for (pp i) p pp f} in for
09:37:55 <lambdabot> forall t (m :: * -> *) t1. (Monad m) => t -> (t -> Bool) -> (t -> t) -> (t -> m t1) -> m ()
09:38:47 <chessguy> @undo do {f i; for (pp i) p pp f}
09:38:48 <lambdabot> f i >> for (pp i) p pp f
09:39:25 <chessguy> @pl \f i -> for (pp i) p pp f
09:39:26 <lambdabot> flip (flip (flip for p . pp) pp)
09:39:30 <chessguy> bah
09:39:55 <esap> nice use of flip :-)
09:40:13 <chessguy> s/nice/exceedingly excessive/ :)
09:41:15 <chessguy> @pl \i p pp f -> when (p i) $ f i >> for (pp i) p pp f
09:41:16 <lambdabot> ap (ap . (((.) . (.) . when) .) . flip id) (ap ((.) . (.) . ap . ((>>) .) . flip id) (flip flip id . (ap .) . flip . (for .) . flip id))
09:41:20 <chessguy> woohoo
09:41:23 <idnar> yeesh
09:41:52 <chessguy> osfameron, anyway, that's the best version i can come up with at the moment, though it can probably be improved
09:42:17 * osfameron swoons
09:42:25 <osfameron> I hope you meant the pre-pointless version :-)
09:42:31 <quicksilver> another refinement you might want in practice is to collect the list of results
09:42:31 <roconnor> @pl \for i p pp f -> when (p i) $ f i >> for (pp i) p pp f
09:42:32 <chessguy> lol, yes
09:42:33 <lambdabot> ap (ap . (((.) . (.) . when) .) . flip id) . ap ((.) . (.) . ap . ((>>) .) . flip id) . flip flip id . ((flip . (ap .) . flip) .) . (. flip id) . (.)
09:42:45 <quicksilver> or perhaps the last result
09:42:58 <quicksilver> depends on your use case, obviously
09:43:11 <chessguy> sure
09:43:48 <esap> @pl let for i p pp f -> when (p i) $ do { f i ; for (pp i) p pp f } in for
09:43:49 <lambdabot> (line 1, column 18):
09:43:49 <lambdabot> unexpected "-"
09:43:49 <lambdabot> expecting pattern or "="
09:44:02 <esap> @pl let for i p pp f = when (p i) $ do { f i ; for (pp i) p pp f } in for
09:44:02 <lambdabot> (line 1, column 36):
09:44:02 <lambdabot> unexpected "{"
09:44:02 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`", ";" or "in"
09:44:38 <esap> @pl let { for i p pp f = when (p i) $ do { f i ; for (pp i) p pp f }} in for
09:44:39 <lambdabot> (line 1, column 5):
09:44:39 <lambdabot> unexpected "{"
09:44:39 <lambdabot> expecting natural, identifier or "in"
09:44:49 <chessguy> @pl let for i p pp f = when (p i) $ f i >> for (pp i) p  pp f in for
09:44:52 <lambdabot> fix (ap (ap . (((.) . (.) . when) .) . flip id) . ap ((.) . (.) . ap . ((>>) .) . flip id) . flip flip id . ((flip . (ap .) . flip) .) . (. flip id) . (.))
09:45:09 <roconnor> chessguy: that's the fix of my result.
09:45:12 <chessguy> i'm sure there's a great fix-based solution that i wouldn't come up with in a million years
09:46:00 <kpreid> osfameron: note that a true emulation of the C-style for loop allows monadic actions for the test and increment operations
09:46:02 <chessguy> anyway, fun stuff :)
09:47:24 <chessguy> for :: forall t (m :: * -> *) t1. (Monad m, Monad m1, Monad m2) => t -> (t -> m1 Bool) -> (t -> m2 t) -> (t -> m t1) -> m ()
09:47:24 <roconnor> @hoogle iterateM
09:47:27 <chessguy> wheee :)
09:47:28 <lambdabot> No matches found
09:47:35 <roconnor> @hoogle takeWhileM
09:47:36 <lambdabot> No matches found
09:47:39 <roconnor> :(
09:48:09 <roconnor> I guess that wouldn't interleave the test and iterations properly
09:48:33 <osfameron> kpreid: well, I wasn't sure that that would be explicitly forbidden by my version?  (The iterator variable could be a State for example, rather than an integer)
09:49:33 <chessguy> oh yeah, you might just want for :: forall t (m :: * -> *) t1. (Monad m) => t -> (t -> m Bool) -> (t -> m t) -> (t -> m t1) -> m ()
09:52:31 <kpreid> osfameron: no, it really doesn't work that way
09:53:25 <osfameron> ah well
09:53:26 <kpreid> osfameron: because the type of yours contains no "m Bool" or "m i", there's no way the monadic component can communicate to the looping component
09:53:50 <ddarius> for init test step body = do init; for' where for' = do b <- test; when b (body >> step >> for')
09:53:57 <ddarius> :t let for init test step body = do init; for' where for' = do b <- test; when b (body >> step >> for') in for
09:53:59 <lambdabot> forall (t :: * -> *) t1 a a1. (Monad t) => t t1 -> t Bool -> t a -> t a1 -> t ()
09:55:44 <chessguy> @undo do { b <- test; when b (body >> step >> for') }
09:55:45 <lambdabot> test >>= \ b -> when b (body >> step >> for')
09:56:15 <chessguy> how about flip when (body >> step >> for') test :)
09:56:42 <chessguy> err
09:56:57 <chessguy> test >>= flip $ when (body >> step >> for')
09:57:13 <chessguy> grr
09:57:17 <chessguy> that's still nog right
09:57:24 <ddarius> do iref <- newIORef 0; for (writeIORef iref 1) (do i <- readIORef iref; return (i < 10)) (modifyIORef iref (1+)) $ do i <- readIORef iref; print i
09:57:43 <chessguy> :t let for init test step body = do init; for' where for' = test >>= flip when b (body >> step >> for') in for
09:57:44 <lambdabot> Not in scope: `b'
09:57:57 <chessguy> :t let for init test step body = do init; for' where for' = test >>= flip when (body >> step >> for') in for
09:57:58 <lambdabot> forall (m :: * -> *) t a a1. (Monad m) => m t -> m Bool -> m a -> m a1 -> m ()
09:58:07 <ddarius> chessguy: Now replace for' with a use of fix.
09:58:28 <chessguy> ddarius, i have no clue how to do that
09:58:56 <ddarius> @pl \for' -> test >>= flip when (body >> step >> for')
09:58:57 <lambdabot> (test >>=) . flip when . ((body >> step) >>)
09:59:05 <chessguy> heh
09:59:30 <ddarius> :t let for init test step body = init >> fix ((test >>=) . flip when . ((body >> step) >>))
09:59:31 <lambdabot> <command line>:
09:59:31 <lambdabot>     Could not find module `L':
09:59:31 <lambdabot>       Use -v to see a list of the files searched for.
09:59:34 <ddarius> :t let for init test step body = init >> fix ((test >>=) . flip when . ((body >> step) >>)) in for
09:59:36 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => m a -> m Bool -> m a1 -> m a2 -> m ()
09:59:55 <chessguy> sweet :)
10:01:03 <ddarius> That 'for' closely models the C for-loop and as such is pretty ugly to use relatively speaking.
10:01:50 <chessguy> yeah, i still like the flip mapM_ idiom for the example osfameron originally cited
10:01:59 <quicksilver> that even has a name
10:02:04 <quicksilver> forM_
10:02:12 <dons> yes, he missed forM_
10:02:13 <dons> ah well
10:02:25 <ddarius> chessguy: I agree.  In general, Haskellers don't write (even monadic) loops at all like C programmers.
10:02:28 <chessguy> oh, forM_ is defined now?
10:02:35 <ddarius> @src forM_
10:02:35 <lambdabot> forM_ = flip mapM_
10:02:38 <quicksilver> :)
10:02:53 <osfameron> dammit, I wish I could stay and learn from this stuff rather than being at work :-(
10:02:54 <quicksilver> also the non-_ version
10:03:05 <quicksilver> but not, sadly, the non-M analogues
10:03:06 <chessguy> osfameron, likewise
10:03:20 <chessguy> oh well, back to work
10:03:35 * osfameron notes that he didn't write the for loop because he wasnted to write for-loops in haskell, but 'cos he thought it might be fun and instructive :-)
10:03:49 <quicksilver> right
10:03:55 <quicksilver> that's the spirit I thought you were writing it in
10:04:02 <quicksilver> and, I trust it was instructive :)
10:04:34 <yrlnry> This channel wins because it assumes that you are trying to do something fun and instructive, rather than that you are an ignoramus.
10:04:44 <dons> :)
10:04:57 <yrlnry> I've lost count of the number of times I've been told "well, that is a stupid thing to do, so don't" in other channels.
10:05:30 <osfameron> quicksilver: yeah, definitely instructive (except for that pesky being at work thing I mentioned)
10:05:39 <quicksilver> actually I am guilty of sometimes telling people "I don't think you want to do that"
10:05:48 <quicksilver> it's a very fine line as to when that's appropriate
10:06:09 <quicksilver> you don't want people walking up a long garden path when there more haskelly-ways to do things...
10:06:45 <quicksilver> most often, recently, the question has been "can I write a function which takes a variable number of arguments?"
10:07:50 <esap> that's easy. Just define the polymorphic stack type and then use that for argument passing :-)
10:09:06 <ddarius> Haven't seen you in a while esap.
10:11:10 <esap> ddarius: I've not had time to sit in IRC :-)
10:12:05 <yrlnry> quicksilver: I had to explain to someone a while back why mathematicians don't care about functions with multiple arguments.
10:12:05 <quicksilver> how can this be possible?
10:12:44 <quicksilver> yrlnry: I've never been to a mathematical function at which there weren't multiple arguments. Normally several of them conducted on the back of napkins or tablecloths.
10:12:45 <yrlnry> quicksilver: He thought it was one of those things they have in the social sciences where your theory doesn't account for the pink elephant in the room, so you pretend it's not there and don't talk about it.   I explained that the situation was not like that.
10:12:57 <yrlnry> Heh.
10:13:00 <EvilTerran> quicksilver, hehehe
10:13:48 <quicksilver> wow. I thought that was a poor joke, unworthy of two laughs :) Thank you.
10:14:24 <quicksilver> the happiness of mathematicians to accept injections makes them unusual w.r.t many other disciplines
10:14:54 <esap> what's wrong with injections?
10:14:55 <quicksilver> mathematicians are pretty instinctive about saying "all these other cases obviously reduce to the single argument case for the following reason: ... and then forgetting about them afterwards
10:15:17 <osfameron> binary functions seem fairly basic to the layman though..
10:15:43 <yrlnry> I was only laughing to be polite.
10:19:18 <quicksilver> osfameron: yes, that's fair
10:19:39 <quicksilver> yrlnry: :)
10:22:17 <mrsolo> http://www.haskell.org/haskellwiki/Learning_Haskell list few textbooks.. which one is good for a person who are familar wit few programm languages already?
10:22:18 <lambdabot> Title: Learning Haskell - HaskellWiki
10:24:50 <ricky_clarkson> Cale: I saw your comments on reddit on The Continuous Tax of Static Typing..
10:25:38 <ricky_clarkson> Cale: What would it take to emulate typeclasses in Java, I mean, the minimum change, with as much AST processing as you like?
10:26:51 <quicksilver> mrsolo: there is an upcoming book which will focus on practical programming and may be appropriate for people who alrady use other languages
10:26:59 <quicksilver> mrsolo: don't know how long it will be though
10:27:59 <desegnis> mrsolo: Of these books I only read the H. School of Expression, and it's definitely a good read. I would even claim that experience with imperative languages is not so important when choosing a book about FP
10:28:10 <mrsolo> quicksilver: ah what do you recommend for the current batch?
10:28:29 <mrsolo> s/for/from/
10:30:59 <quicksilver> mrsolo: personally I recommend Graham Hutton
10:31:05 <quicksilver> mrsolo: but I haven't read any ofthem in depth
10:32:37 <wli> I wonder if they've got Hutton's book at Powell's Technical yet.
10:32:51 <mrsolo> ok... *click* :-)
10:32:57 <wli> I wonder if there's some way to spur bookstores into carrying Haskell books.
10:33:05 <fasta> mrsolo: I read Algorithms: A functional programming approach and I do not recommend it.
10:33:06 <quicksilver> wli: cattle-prod? spurs?
10:33:33 <fasta> mrsolo: HSOE should be all you need to become a beginner.
10:33:57 <mrsolo> hsoe?
10:34:03 <fasta> mrsolo: I read that book to, but I wasn't a newbie when I read it.
10:34:08 <fasta> too*
10:34:21 <mrsolo> well that is the thing..i am not really a beginner in fp..
10:34:28 <fasta> @where+ HSOE Haskell School of Expression.
10:34:28 <lambdabot> It is stored.
10:34:59 <mrsolo> so it is hard to judge the level of those text books from that wiki site
10:35:05 <fasta> mrsolo: what experience do you have?
10:35:18 <mrsolo> my programming language background is ruby, python perl
10:35:26 <mrsolo> and little of ocaml and scheme
10:35:46 <fasta> mrsolo: none of those is about pure functional programming.
10:35:50 <mrsolo> no
10:35:57 <mrsolo> of course
10:36:00 <fasta> mrsolo: did you use set! in Scheme a lot?
10:36:07 <mrsolo> no
10:36:19 <bakert> I really need some kind of "how to structure data when writing a haskell program stop reinventing OO badly" book or tutorial
10:36:48 <quicksilver> you can program "purely except for IO" in ocaml
10:36:54 <quicksilver> which is what I did, when I used ocaml
10:37:09 <quicksilver> bakert: I think that would make a really good tutorial
10:37:24 <quicksilver> bakert: I don't know the answer, though :(
10:37:30 <dons> quicksilver: is it easy to ensure you stick to pure functions?
10:37:33 <quicksilver> bakert: well, I've picked up some of the answers, in some cases
10:37:44 <quicksilver> dons: "ensure": no. The type system can't tell.
10:37:47 <dons> or is it possible to accidentally slip side effects in
10:37:50 <dons> no, i know that.
10:37:56 <quicksilver> yes, very possible :)
10:38:03 <dons> but just as a convention, is it easy to stay pure if you're trying
10:38:10 <quicksilver> I found it so
10:38:12 <bakert> quicksilver: i haven't.  all i know is nobody who knows what they are doing uses record types as much as i do.  so i must be doing something wrong :(
10:38:16 <dons> ok. that's interesting.
10:38:23 <quicksilver> as long you know the purity of the libraries you are using
10:38:27 <quicksilver> I didn't use any libraries
10:38:29 <quicksilver> so that was ok :)
10:38:30 <dons> heh
10:38:39 <quicksilver> I also did some SML
10:38:41 <dons> it would be interesting to translate haskell to pure ocaml
10:38:45 <quicksilver> because there was a java interface for it
10:38:54 <fasta> mrsolo: If you have written more than 10K of non-trivial code in Scheme and OCaml, reading a Haskell book won't get you further, imho.
10:39:01 <quicksilver> then of course the java interface stuff is totally impure
10:39:03 <mrsolo> hmm
10:39:04 <jfredet1> bakert: sometimes, though, its worth reinventing some OO in Haskell, because it's a better way to think about a problem
10:39:07 <mrsolo> oh well
10:39:12 <quicksilver> mrsolo: FWIW, I disagree with what fasta just said :)
10:39:22 <jfredet1> so maybe you've just been working on problems which require a functional OO-esque solution
10:39:27 <bakert> jfredet1: i need to get to the point where i can choose between OO and "the haskell way" though
10:39:28 <dons> yeah, reading some haskell papers will be fruitful
10:39:31 <quicksilver> bakert: I've been using record types much more in my most recent code.
10:39:34 <mrsolo> quicksilver: look like your background is somewhat simliar.. i going to get that book first
10:39:36 <bakert> at the moment i have no idea what the haskell way is
10:39:54 <bakert> i just build modules that contain one type and even a function called new
10:40:03 <bakert> that gives you an initialized version of that record type
10:40:11 <mrsolo> i guess some code receipt book will be helpful too
10:40:12 <bakert> it is so OO it hurts
10:40:15 <fasta> bakert: the Scheme way is make_foobar, you can use the same in Haskell too.
10:40:26 <jfredet1> yeh-
10:40:27 <fasta> bakert: er make-foobar
10:40:46 <fasta> bakert: in Haskell makeFooBar or make_foo_bar
10:41:11 <fasta> bakert: for data structures it's standard to have empty and singleton functions
10:41:18 <bakert> i think i have a problem grokking haskell (fp?) representation
10:41:39 <bakert> i seem to build these very complicated amalgams of types
10:41:48 <bakert> which no one else seems to be doing
10:41:50 <quicksilver> I don't normally call it 'make'
10:42:03 <quicksilver> I just make it a sensible name for what it is
10:42:05 <esap> It's well possible to write OO code in Haskell. In extreme it causes you to write a dummy instance declaration for each one of your datatypes, and access the components of the type via the typeclass.
10:42:07 <bakert> a Person has a Background which has a Homeland and a Father and a Mother and ..
10:42:11 <quicksilver> e.g., particle library, particle record
10:42:12 <bakert> eek!
10:42:25 <quicksilver> call one value 'ballistic'
10:42:32 <quicksilver> which is "default" values for a ballistic particle
10:42:46 <bakert> Somehow I feel like I should be doing something completely different.  But I don't know what :(
10:42:55 <quicksilver> with immutability the 'make' paradigm isn't always intuitive
10:42:58 <bakert> Perhaps I'm not so far off as I think.
10:42:59 <quicksilver> since you can't "make it and change it"
10:43:10 <quicksilver> I do sometimes have 'defaultParticle' though
10:43:18 <quicksilver> intended for use with record update syntax
10:43:28 <quicksilver> defaultParticle { x = 10 }  -- default except x is 10
10:43:37 <bakert> don't get me started on record update syntax.
10:43:39 <fasta> quicksilver: I use that too.
10:43:46 <fasta> quicksilver: default<foobar>
10:44:19 <fasta> I also use convert_<foobar> sometimes.
10:44:28 <fasta> I am rather explicit.
10:44:45 <quicksilver> Parent Advisory : Contains Explicit Fastas.
10:44:53 <fasta> (because I need to read my code later)
10:45:29 <quicksilver> bakert: I think these are interesting things to discuss
10:45:40 <quicksilver> bakert: people who write big haskell programs do seem to use different style
10:45:50 <quicksilver> bakert: it's not clear to me yet which styles are recommendable
10:45:53 <fasta> I also use a deconstructor for most data types
10:45:56 <bakert> no.  me either.
10:46:04 <fasta> Like the maybe and either functions
10:46:13 <bos> @seen CosmicRay
10:46:14 <lambdabot> CosmicRay is in #haskell-blah, #darcs and #haskell. I don't know when CosmicRay last spoke.
10:46:17 <bakert> i can write the answers to the 99 problems on haskell.org
10:46:27 <bakert> but when i try to write a "real" program i get a bit lost
10:46:36 <bakert> i spent a lot of time last week working on functional references
10:46:42 <bakert> because the record update syntax upset me
10:46:50 <quicksilver> it's trendier to call them lenses !
10:46:51 <quicksilver> :)
10:46:53 <esap> The most difficult part in simulating OO style is how to handle storage of objects. You'll get easily bound within the IO monad.
10:47:05 <quicksilver> FPRefs are cool. I don't use them yet in my code though.
10:47:12 <bakert> but i think i am building crutches for myself to carry on programming in a style i am accustomed to
10:47:32 <bakert> that is, i started with the premise that i had a kind of "object" that is a scale that has two ends (say up and down)
10:47:40 <bakert> and that i needed to be able to say
10:47:44 <bakert> up object
10:47:47 <bakert> and get the up value
10:47:55 <bakert> and also "down object" to get the down value
10:47:56 * CosmicRay looks in
10:47:57 <bakert> which is 20 - up
10:48:05 <bakert> PLUS i also felt i needed to be able to update
10:48:06 <bakert> like this:
10:48:10 <bakert> update up 7
10:48:13 <bakert> update down 13
10:48:15 <bakert> whatever
10:48:23 * quicksilver nods
10:48:23 <bakert> hence, functional references
10:48:28 <quicksilver> well I thnk that's sensible style
10:48:28 <bakert> and that was all well and good
10:48:35 <quicksilver> the best thing about lenses is they are composable
10:48:37 <bakert> but perhaps i was looking at it all wrong
10:48:39 <quicksilver> that makes them very cool
10:48:53 <bakert> maybe there is a magical functional programming way of doing it that just isn't in my head like OO wasn't in my head in 1997
10:49:03 <bakert> and seemed really strange and not-understandable
10:49:19 <bakert> because all that messing about with functional references was quite painful!
10:49:25 <bakert> and it still doesn't 100% work now
10:49:30 <esap> learning new paradigms is always hard
10:49:58 <_bt2> hello
10:49:58 <bakert> esap: yes.  i don't mind hard.  but i am lost in a maze of twisty passages all alike!  not sure where to turn for the answers ....
10:50:15 <bos> bakert: what are you trying to do with your program?
10:50:18 <bakert> i need something like Effective Java by Joshua Bloch which finally got OO into my brain properly
10:50:37 <bakert> bos: embarrassingly enough it is a character generator for the Pendragon RPG (paper and pencils version)
10:50:55 <bakert> the two ended scales are these traits that characters have
10:51:07 <bakert> engergetic-lazy, proud-modest, etc.
10:51:14 <newsham> you see an opening to the north.  The light shining through reveals a small booklet near the base of the door.  There is a small compiler here.
10:51:19 <bakert> :)
10:51:20 <bos> nothing embarrassing about that. it's a nicely scoped problem.
10:51:38 <bakert> well, i would have rather said it was a web based app framework or something useful :)
10:51:53 <bakert> that would be a bit ambitious at this stage :)
10:51:53 <quicksilver> bos: have you considered a chapter about "How to do stuff in haskell that you'd use OO for in other languages?" or is that too non-specific?
10:52:13 <bos> quicksilver: it's very much a concern.
10:52:17 <CosmicRay> quicksilver: that's the whole book ;-)
10:52:25 <P_D> languages where you'd consider using OO tend to push you to use OO for everything, so...
10:52:45 <newsham> when you have a hammer, everything looks like a nail.
10:52:49 <bos> in fact, i'm embarking on just such a chapter at the moment, only i'm not yet happy with my example.
10:52:52 <bakert> exactly my problem!
10:52:55 <CosmicRay> heh
10:53:04 <bos> so let me draw on the collected wisdom of #haskell.
10:53:19 <wli> bos: Something akin to virtual filesystem layers.
10:54:10 <jonafan> i really like the haskell rants on reddit
10:54:23 <jonafan> by revence
10:54:27 <dons> oh?
10:54:33 <bakert> that one today is why i am here tonight :)
10:54:35 <bos> the alleged current topic of this chapter is barcode recognition.  it's not a very difficult problem, which is good. but it's also a little dull, as all it does is make use of function composition.
10:54:41 <wli> bos: Systems of side effect -driven objects like multiplayer online RPG's.
10:54:51 <jonafan> if it isn't simple, it's wrong?
10:54:58 <quicksilver> bos, CosmicRay: good :)
10:55:28 <_bt2> isSubstring :: Eq a => [a] -> [a] -> Bool
10:55:28 <_bt2> isSubstring x (y:ys) = (isPrefix x y:ys) || (isSubstring x ys)
10:55:28 <_bt2> Hugs complains that "unification would give infinite type". Where is the problem?
10:55:45 <P_D> (y:ys)
10:55:47 <jonafan> people in the comments are retarded though
10:55:49 <bos> so although barcode recognition makes a nice springboard for, say, parsing image file formats, it's too boring and doesn't illustrate enough interesting material.
10:55:55 <wli> bos: Utilities featuring multiple input and output drivers like format conversion.
10:56:01 <jonafan> why do i always get into reading comments on those social bookmarking sites
10:56:03 <esap> bakert: one hard thing that I needed to unlearn when learning functional programming was interfaces. You don't use API style interfaces much in functional programming.
10:56:10 <quicksilver> bos: games are not a bad thought
10:56:18 <quicksilver> bos: modern games are a stronghold of OO
10:56:22 <bos> woohoo! conal is giving a google tech talk next week.
10:56:23 <quicksilver> bos: big, mutable state
10:56:36 <quicksilver> "objects" for in-game entities
10:56:36 <esap> bakert: Instead, think of datatypes as interfaces.
10:56:37 <bakert> esap: that is interesting.  i hadn't even thought to try and unlearn that.  what do you replace it with?  or why is it unnecessary?
10:56:49 <bakert> oops too quick!
10:56:50 <bakert> :)
10:57:02 <newsham> here is an excellent ppt on modern games, advocating lots of haskell-like features: http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt
10:57:02 <bakert> esap: my datatypes seem to get awfully big
10:57:04 <wli> bos: Are any of my thoughts sounding vaguely useful?
10:57:06 <P_D> A place where objects are very appropriate is in simulators
10:57:07 <bos> well, this chapter comes before the chapters on monads, so presenting state becomes painful.
10:57:15 <quicksilver> hmm
10:57:18 <_bt2> P_D: thanks
10:57:18 <quicksilver> you can do state by hand
10:57:24 <quicksilver> I do quite often
10:57:34 <quicksilver> rather than explicitly using StateT and ReaderT
10:57:37 <quicksilver> which are clumsy at the best of times
10:57:37 <bakert> esap: they end up being composed of lots of other datatypes.  but maybe that is a good thing.
10:57:45 <EvilTerran> _bt2, function application binds tighter than any infix operator
10:57:45 <P_D> write a simulator that uses iterate
10:58:02 <bos> yeah, you can do state by hand, and in fact it's useful to do state by hand once to give yourself a motivating example for State and Reader.
10:58:07 <newsham> hmm.. bouncy ball simulator with iterate.
10:58:09 <quicksilver> I variously have actions with types "FooState -> IO()" and "FooState -> IO FooState"
10:58:33 <quicksilver> so the type system declares in an obvious way if the action can actually modify the state or merely uses it
10:58:36 <esap> bakert: In functional style, datatypes will become very big. Think it that when you are defining datatypes, you are really specifying a (programming)*language*.
10:58:44 <bos> wli: hmm.
10:58:44 <quicksilver> I very rarely pass around IORefs
10:58:50 <wli> bos: No problem. Sometimes the best way to help is backing off. Cheers.
10:59:05 <bos> no, don't back off. i'm just thinking.
10:59:39 <esap> bakert: and a datatype is really an interface to a function. f :: Input -> Output. Input there is an interface. Output is another interface.
11:00:01 <wli> Okay, though I can elaborate, too.
11:00:19 <nburlett> quick question... is there any way to specify a pattern-matchable name for a constant
11:00:29 <quicksilver> nburlett: no
11:00:35 <nburlett> sadness
11:00:35 <quicksilver> nburlett: only constructors are pattern matchable
11:00:47 <phlpp> :t readFile
11:00:48 <lambdabot> FilePath -> IO String
11:00:56 <phlpp> :t putStrLn
11:00:57 <newsham> > let f 0 = 5 in f 0
11:00:58 <lambdabot> String -> IO ()
11:00:59 <lambdabot>  5
11:00:59 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3539
11:01:02 <nburlett> quicksilver: it would be nice if I could match against names for magic numbers
11:01:18 <phlpp> hmm..
11:01:20 <quicksilver> sometimes it would, yes
11:01:28 <nburlett> no extensions for this?
11:01:34 <EvilTerran> nburlett, what sort of constant? you can have something akin to a C enum with data Enum = Foo | Bar | Baz | Eek | ..., and pattern-match on that...
11:01:37 <quicksilver> not that I know of
11:01:45 <P_D> use n | n == x ?
11:01:48 <EvilTerran> if you mean numeric constants, i think you're a bit stuck
11:01:51 <quicksilver> :t readFile >>= putStrLn
11:01:52 <lambdabot>     Couldn't match expected type `IO String'
11:01:52 <lambdabot>            against inferred type `String'
11:01:52 <lambdabot>     Probable cause: `putStrLn' is applied to too many arguments
11:01:53 <nburlett> EvilTerran: yes, numeric
11:01:54 <r2d4> Perhaps a bit offtopic but I am hoping to find academically inclined here. I am looking for a discussion on programming primitives. By that I mean Objects in OOP, functions in functional programming, lists in lisp etc. Can anyone point me to a paper?
11:02:05 <quicksilver> :t \f -> readFile f >>= putStrLn
11:02:06 <lambdabot> FilePath -> IO ()
11:02:11 <quicksilver> phlpp: is that what you're after?
11:02:14 <phlpp> if you got my two type queries, then i'd like to know, if readFile "/etc/passwd" >>= putStrLn is just a pointfree  version of readFile "/etc/passwd" >>= \s -> putStrLn s
11:02:15 <quicksilver> phlpp: "monadic composition" ?
11:02:19 <esap> bakert: In OO style, the instinctive thing to do is to minimize the size of your datatypes. Not so in functional style. I have code with datatype that (indirectly) contains hundreds of other datatypes.
11:02:22 <nburlett> something like decode (x:ESCAPE:0:xs) = x : ESCAPE : decode xs
11:02:25 <quicksilver> phlpp: yes, it is
11:02:28 <phlpp> ah, ok
11:02:33 <bakert> esap: that's interesting.  so perhaps i am nearer to The Right Way than i think.  do you /nest/ your types and awful lot?  that is, a lots
11:02:34 <nburlett> where ESCAPE ix 0xf0000000
11:02:34 <quicksilver> phlpp: putStrLn is the same thing as \s -> putStrLn s
11:02:42 <phlpp> ok
11:02:57 <bakert> esap: ^^^ taht's what i was writing but you answerd it!
11:02:58 <quicksilver> bakert: I nest my types quite a lot, and I get annoyed at the duplication in names
11:03:24 <quicksilver> bakert: e.g. the name of an 'alternative' in a higher level structure is the actual lower level structure
11:04:10 <esap> bakert: well I do have datatypes which have very recursive nature. But nesting in general can cause the interface to become hard to understand.
11:04:27 <phlpp> :t randomRIO
11:04:28 <lambdabot> forall a. (Random a) => (a, a) -> IO a
11:04:36 <nburlett> oh well, back to work
11:04:40 <phlpp> > randomRIO 1 6
11:04:41 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `IO a'
11:04:49 <phlpp> right.
11:04:54 <nburlett> thanks for confirming my suspicions
11:05:21 <esap> bakert: so if many levels can be avoided, it's better to avoid deep nesting. But it's not always possible.
11:05:45 <desegnis> phlpp: randomRIO (1,6) -- but lambdabot forbids IO
11:05:48 <bos> hmm, perhaps for an example this early in the book i can use collaborative filtering instead of barcode recognition.
11:05:54 <bakert> esap: so you would favour a record type with 50 fields over a record type with 5 fields each of which was a sprialling down of nested types?
11:05:59 <phlpp> desegnis: i see, it's a pair
11:06:04 <bos> that has the advantage of "here's what we use instead of hashtables".
11:06:44 <newsham> > randomR (1,6) (mkStdGen 5)
11:06:46 <lambdabot>  (6,240084 40692)
11:07:02 <phlpp> what does mkStdGen5 stand vor?
11:07:06 <bakert> quicksilver: (or anyone) do you favour flatter "bigger" types?
11:07:07 <phlpp> -5
11:07:07 <bos> it's still a distance away from, say, updating a set of actors representing state in a game.
11:07:09 <wli> bos: I think the "driver" idiom in C/C++ is very easy to find good examples for.
11:07:19 <newsham> if you used randomRIO you would be using the implicit RNG
11:07:20 <esap> bakert: It depends on the situation. Sometimes some fields are optional or require arbitrary length datatypes. Then some kind of recursive structure is unavoidable. You might set maximum size limits on the datatypes, then nesting can often be avoided.
11:07:29 <newsham> but if you want to do it functionally, you need to make a RNG
11:07:32 <bakert> my Character only has about 5 fields but each of those is a record type with 5 fields and each of THOSE is a record type with approx 5 fields
11:07:33 <newsham> and pass it to randomR
11:07:36 <newsham> 5 is the seed
11:07:36 <phlpp> ok
11:07:43 <phlpp> so i get always the same value?
11:07:48 <bos> wli: "driver" idiom? as in a big table of virtual function pointers with some opaque state?
11:08:01 <newsham> if you use mkStdGen with the same seed you will get the same sequence of values out of the generator
11:08:04 <phlpp> > randomR (1,6) (mkStdGen 5)
11:08:06 <lambdabot>  (6,240084 40692)
11:08:12 <phlpp> yeah, that's like algorithms work.
11:08:14 <phlpp> :P
11:08:32 <esap> bakert: The important thing is to see whether the types make sense. If not, something is wrong with the design.
11:08:38 <bakert> esap: but there's no reason to have Character > Background > Homeland > Culture ... Culture could just live in Character.  i only separated them out like that to keep it nice and small.
11:08:40 <wli> bos: Yeah, basically.
11:08:45 <bakert> they are all properties of Character
11:08:50 <newsham> > let g = mkStdGen 5; (v,g') = randomR (1,6) g; (v',g'') = randomR (1,6) g' in (v, v')
11:08:50 <lambdabot> Unbalanced parentheses
11:08:56 <phlpp> hm, but how to get a number between 1 and 6 and store it to an Int?
11:09:08 <phlpp> let's say we are simulating a dice
11:09:21 <Corun> Hello. Is there some way of using haskell functions by a string containing their name? Something like: (functionWithName "*") 4 5
11:09:27 <esap> bakert: and often the *instances* of the datatype are what are important. So if writing instances is easy, then the design is likely to be correct.
11:09:27 <phlpp> ah
11:09:28 <ricky_clarkson> Storing is a misnomer.
11:09:30 <phlpp> i see :>
11:09:31 <Corun> (Gives 20). I assume not, but I thought I'd check :-)
11:09:47 <phlpp> > fst $ randomR (1,6) (mkStdGen 5)
11:09:48 <lambdabot>  6
11:09:52 <phlpp> > snd $ randomR (1,6) (mkStdGen 5)
11:09:53 <newsham> or in IO:
11:09:54 <lambdabot>  240084 40692
11:10:11 <newsham> > do { v <- randomRIO (1,6); v2 <- randomRIO (1,6); return (v,v2) }
11:10:13 <lambdabot>  <IO (Integer,Integer)>
11:10:22 <phlpp> > takeWhile (/=' ') $ snd $ randomR (1,6) (mkStdGen 5)
11:10:23 <lambdabot>  Couldn't match expected type `[Char]'
11:10:24 <ibid> osfameron: i would have sent your blog a comment but cannot be bothered to register :)
11:10:34 <bakert> esap: i see.  writing instances of my Character type is nigh-on-impossible :)  but i'm not sure it would be much easier if i flattened it.  it looks to my untutored eye that i am trying to cram "too much" in.
11:10:39 <esap> bakert: On the other hand, it's easy to have too many types, then to write instances, you are repeating constructors that just seem like burden to write.
11:10:44 <phlpp> :t mkStdGen
11:10:46 <lambdabot> Int -> StdGen
11:10:50 <phlpp> doh!
11:10:59 <desegnis> Corun: You're right to assume not. (Although, maybe there's some extension, TH or what, which I don't know of)
11:11:13 <Corun> Ok. Ta.
11:11:14 <phlpp> > randomR (1,6) (mkStdGen 5)
11:11:16 <lambdabot>  (6,240084 40692)
11:11:20 <phlpp> > randomR (1,6) (mkStdGen 240084)
11:11:21 <lambdabot>  (2,1016826938 40692)
11:11:29 <phlpp> > randomR (1,6) (mkStdGen 1016826938)
11:11:29 <newsham> randomR returns a value and an updated stdgen
11:11:30 <lambdabot>  (2,1089552548 40692)
11:11:30 <yrlnry> What would functionWithName be good for anyway?
11:11:41 <esap> bakert: when the type gets complex, you start to wonder whether writing parser to generate the instance would be the correct thing to do.
11:11:45 <desegnis> Corun: In general this would even be impossible, because functionWithName could not have a Haskell type
11:12:00 <Corun> Mmm, good point.
11:12:09 <kscaldef> yrlnry: I think he wants to clone raganwalds Ruby lib
11:12:22 <esap> bakert: and often it is. But that may also be an indication that the structure is too complex.
11:12:24 <bakert> esap: taking my rpg character example.  where would you start defining types for that?  you've got a whole character sheet worth of information to store.  from name to background to eye color to list of equipment.  where woudl you start?
11:12:32 <phlpp> > (\x -> randomR (1,6) (mkStdGen x)) 5
11:12:34 <lambdabot>  (6,240084 40692)
11:12:35 <Corun> Well, my haskell assignment is too do with algebra 'n' stuff. We have a datatype: data Expr = Num Float | Id String | App String [ Expr ]
11:12:36 <yrlnry> Couldn't it have type String -> 'a -> 'b?
11:12:47 <esap> bakert: generally you start with the use cases.
11:12:57 <bakert> esap: it feels to me like haskell isn't "designed" to deal with so much info.  but i know that's just my ignorance :)
11:12:59 <wli> bos: It need not be a virtual function table, though. FILE * from C's stdio, for instance, uses a different tactic, namely having the methods just be a collection of "API functions" floating around near each other.
11:13:00 <esap> bakert: what the system must do to function correctly.
11:13:19 <bos> wli: right
11:13:19 <Corun> We have to write a function eval that evaluates it, basically. So: eval (App "*" [Num 5,Id "x"]) ("x", 5) gives 25
11:13:49 <phlpp> newsham: i thought about taking \x -> randomR (1,6) (mkStdGen x) and always use the second number produced by this function as the new seed
11:14:04 <Corun> I was hoping there might be some cool haskell way of getting (*) function from "*".
11:14:11 <wli> bos: MUA's will have drivers for various spool formats and remote spool access protocols, too.
11:14:12 <newsham> phlpp: no, the second value is not a number
11:14:16 <phlpp> is that possible? more over, does that make any sense? i don't know what the second number stands for
11:14:16 <newsham> the second value is a StdGen
11:14:19 <phlpp> ah ok
11:14:23 <bakert> esap: that's kind of what i did and why i ended up spending all that time on the functional references.  i knew i was going to want to calculate if the character was "religious" which meant calculating the sum of a variety of attributes (dependent upon the religion).
11:14:26 <phlpp> i just took the first part of it :P
11:14:30 <esap> bakert: each use case requires some data as input. Write one constructor in the "top-level" datatype per use case. And include all the information that the implementation of the use case needs as input to be able to do its job.
11:14:32 <bakert> esap: maybe my design is not so bad.
11:14:33 <kscaldef> Corun: it sounds like your assignment is to write a parser, really
11:14:35 <bos> wli: yeah
11:14:38 <newsham> let  (v,g') = randomR (1,6) g;    now you can do  randomR (1,6) g'
11:14:47 <desegnis> Corun: Best to have a constructor for functions within Expr, then you get rid of String. But you have to do the parsing by hand (translate "*" to (*) and so on, for any operator)
11:15:03 <bakert> esap: but i see what you are saying.  think about the functions and their types.  don't start with objects, start with the operations.
11:15:04 <newsham> phlpp: do you know State yet?
11:15:18 <phlpp> you mean the a state monad?
11:15:20 <bos> wli: that's a cute example, in fact.
11:15:21 <newsham> yes
11:15:48 <phlpp> no, i didn't understand the explination in YAHT. i think i've to look for it in some other monad tutorial
11:16:00 <conal> bos: i'm scheduled at google for a tech talk next wednesday at noon.
11:16:01 <Lemmih> @seen JohnMeacham
11:16:01 <lambdabot> JohnMeacham is in #haskell and #haskell-blah. I last heard JohnMeacham speak 2d 14h 18m 22s ago.
11:16:01 <esap> bakert: and don't think about OO style methods. The operations that are needed shouldn't be divided as much as what happens in OO design. YOu have large functions.
11:16:22 <bakert> ok.  thanks esap that's some food for thought.
11:16:23 <bos> conal: excellent. i gather it will be taped and the footage will be available on the intertubes, too.
11:16:28 <newsham> phlpp: you might find using randomRIO a lot easier for now, then.
11:16:29 <phlpp> but if you think, that would help me (what i want to do: simulate N rolls of a dice, and put the values as Int or sth. into a list)
11:16:36 <phlpp> i'll get behind this
11:16:41 <conal> bos: yep.  thanks again for the connection.
11:16:44 <bos> sure!
11:16:55 <newsham> or if you want, you could just use randomRs to generate an infinite sequence
11:17:05 <newsham> > randomRs (1,6) (mkStdGen 1)
11:17:07 <lambdabot>  [6,5,2,6,5,2,3,2,5,5,4,2,1,2,5,6,3,3,5,5,1,4,3,3,2,4,2,3,6,1,3,4,3,2,5,1,1,2...
11:17:13 <newsham> and consume that sequence in your code
11:17:16 <phlpp> ah, cool.
11:17:29 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3540
11:17:36 <Corun> I can't change the data type, it gets autotested. Anyway, yeh, I've more or less got it parsing by hand now. Actually I'm doing: http://hpaste.org/3540
11:17:49 <phlpp> :t randomRs
11:17:50 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
11:18:22 <esap> bakert: for example, the type checker of my compiler could be just one function. In fact the datatype that's input for the type checker of my compiler is just one module containing only data type definitions.
11:18:33 <phlpp> > randomRs (1,6) (mkStdGen 1)
11:18:34 <lambdabot>  [6,5,2,6,5,2,3,2,5,5,4,2,1,2,5,6,3,3,5,5,1,4,3,3,2,4,2,3,6,1,3,4,3,2,5,1,1,2...
11:18:40 <phlpp> > randomRs (1,6) (mkStdGen 31203)
11:18:42 <lambdabot>  [6,3,4,3,4,3,4,3,3,6,3,6,6,6,2,5,6,2,4,2,6,2,6,5,1,4,6,5,4,3,4,4,3,3,1,5,2,5...
11:18:47 <conal> bos: i think i can make it to the bayfp meeting as well.  i see wed eve 7:30pm.  do you know where it will be held?
11:18:50 <hpaste>  wholesalereplic pasted "wholesale replica handbags" at http://hpaste.org/3541
11:18:51 <Lemmih> phlpp: Note that '1' isn't a very good seed. '32' is much more random.
11:19:00 <phlpp> 17! :D
11:19:11 <pejo> Corun, "always" is probably known as "fromJust" as well.
11:19:12 <newsham> there's a lot of entropy in one!
11:19:15 <bos> conal: i don't know yet, sorry.
11:19:21 <mrd> hpaste spam :(
11:19:28 <conal> bos: no prob.  i'm on the mailing list.
11:19:31 <bos> cool.
11:19:40 <Corun> pejo, eh?
11:19:50 <mrd> @hoogle fromJust
11:19:50 <lambdabot> Maybe.fromJust :: Maybe a -> a
11:19:54 <phlpp> i think my problem still is, or it was all the time my problem, to get a random seed, like in C passing the time to srand
11:20:02 <wli> bos: An instance of OO actually sucking where it gets used is CAS's where it's used for various sorts of type dispatch, with all sorts of dynamic type errors lurking.
11:20:02 <mrd> Corun: but it does defeat the point of "Maybe" to do what you're doing
11:20:30 <Corun> Spec of the problem says that they will never give input that will give Nothing with lookuped
11:20:32 <bos> wli: CAS?
11:20:36 <mrd> ok
11:20:39 <Corun> It even suggests using a function like "always"
11:20:42 <wli> bos: Computer Algebra System
11:20:46 <pejo> Corun, your implementation of "always" is the same as the function "fromJust".
11:21:01 <bos> ah. there are way too many expansions of CAS for me to have guessed correctly.
11:21:17 <EvilTerran> @index fromJust
11:21:17 <lambdabot> Data.Maybe
11:21:33 <EvilTerran> pejo, if this is being done as an exercise, non-prelude library functions may be inappropriate
11:21:46 <desegnis> Corun: The very verbose (but rather common) way would be to have sum types, BinaryOp and UnaryOp. That makes the lookups superfluid (they're unsafe anyway, because you need fromJust, i.e. your data might be inconsistent if it incorporates String)
11:22:42 <wli> bos: It falls down on relatively fundamental tasks. One of the more notable ones is simplifying or otherwise manipulating expressions involving radicals (IOW representing field extensions in adequate and/or meaningful ways).
11:22:47 <desegnis> Corun: This would simply mean to transfer work from eval to parse
11:22:53 <mrd> you could make it work with n-ary ops by giving some associativity and using a fold
11:23:19 <mrd> but it is better for the parser to work out associativity
11:23:21 <wli> bos: Then again, this is hard for much of anything lacking dependent types.
11:23:38 <desegnis> mrd, you have a point, but for a calculator language n-ary ops should be overkill
11:24:01 <mrd> well, does he have a guarantee the [Expr] will always be length<=2?
11:24:57 <Corun> Well, I'm told what functions to implement, and none of them use 3 ops, so, yeah :-).
11:25:06 <Corun> But, I don't fully understand what you're suggesting desegnis
11:26:37 <hpaste>  desegnis annotated "(no title)" with "What I am suggesting" at http://hpaste.org/3540#a1
11:27:01 <desegnis> er, there is an obvious typo
11:27:23 <desegnis> Binary operators should be applied to two expressions, not one, obviously
11:28:15 <Corun> Ah. Well, the main problem with that is that I can't change the type of Expr, because when I submit it, it's gonna be autotested, and all the tests will fail :-)
11:29:00 * locomalo is away: Ausente
11:29:41 <desegnis> ah, I missed that
11:40:46 <hpaste>  desegnis annotated "(no title)" with "Just to show off that there are numerous ways to structure you data. Lesson: Never stick to some spe" at http://hpaste.org/3540#a2
11:41:08 <desegnis> ...cific design choice too early ;-)
11:41:28 <newsham> you prob want two exprs for binops
11:41:38 <wli> dons was telling me about a Haskell idiom I'd like to explore more.
11:42:13 <wli> Something about existential types and typeclasses used for encapsulation and representation independence.
11:42:48 <mrd> existential types used for encapsulation is discussed in most type theory books
11:42:49 <wli> Basically totally opaque types in Haskell.
11:42:58 <mrd> you can check out Pierce, or Harper
11:43:34 <wli> mrd: I'm used to doing it in C all the time; the particular Haskell idiom eluded me.
11:43:38 <desegnis> Btw, hpaste shoud limit the title text field to its actual limit.
11:44:47 <wli> mrd: I'm more used to merely refraining from exporting constructors.
11:45:24 <mrd> it doesn't involve a module system
11:45:58 <mrd> you have two primitive syntactic constructs for working with existentially typed terms, pack and unpack
11:46:03 <wli> You need the module system to provide a scope boundar beyond which the representation is not visible.
11:46:13 <mrd> no
11:46:37 <mrd> the basic idea doesn't involve any module system at all
11:47:45 <wli> Well, you can do it without the scope boundary, but at that point you're back to discipline and hope to prevent things from examining the internals.
11:48:14 <mrd> again, no.  existential types allow you to create what is essentially a module system.
11:50:43 <mrd> do you have a copy of Pierce handy?
11:51:12 <wli> Something has to cut off the methods whatever code actually packs things into the existential uses otherwise arbitrary code can examine the internals just as those things do (essentially adding to the API acting on the existential at will).
11:51:32 <wli> Only TAPL, not ATTaPL
11:51:32 <mrd> the type system prevents that
11:51:38 <mrd> TAPL is fine -- chapter 24
11:52:04 <esap> Pattern matching with existentials is pretty hard (but possible)
11:52:35 <wli> mrd: I'm there.
11:53:01 <mrd> that chapter will introduce existential types, and how to use them for data abstraction
11:53:59 <mrd> it also discusses how to encode existential types as universal types, as Haskell does
11:54:21 <wli> I'm not seeing anything contradicting what I said.
11:54:49 <mrd> nothing else can examine the internals
11:55:00 <mrd> only the code which is "packed" with the existential type witness
11:56:00 <esap> if you can prove that the encapsulated value has a specific concrete type, you can pattern match against that and open the encapsulation.
11:56:21 <esap> But it requires proof :-)
11:56:58 <mrd> the bottom of page 366, top of 367, has an example
11:58:37 <wli> Okay, that one hides a natural number.
11:59:08 <mrd> and you can only use x.f on it, not succ.
12:01:11 <profmakx> @seen Igloo
12:01:12 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 18h 23m 49s ago.
12:02:28 <Igloo> Hello
12:02:49 <wli> I guess you're saying that the only information you can extract from a packed existential is from its methods, where I was going for something a little stronger, namely completely isolating anything dealing with any particular representation.
12:03:05 <profmakx> hey Igloo. Just in case youre interested: I succeeded bootstrapping ghc 6.6.1 on freebsd7/amd64
12:03:20 <profmakx> and also compiled a 6.8 snapshot with it.
12:03:28 <wli> Igloo: Any idea why CPS would consistently speed things up? roconnor seems to be finding a lot of cases where that happens.
12:03:35 <profmakx> next ill try to fix up the port for ghc on freebsd7
12:03:57 <Igloo> profmakx: OK, great; someone else did it a while ago, but is yet to put patches together and send them to us
12:04:10 <Igloo> profmakx: So if you have any fixes you could send, that would be great!
12:04:26 <Igloo> wli: No idea
12:11:37 <profmakx> in fact i used the binary from the ghc page under 6.2. from there it was a small patch. though ghci does not work yet
12:15:49 <hpaste>  mensshoes pasted "mens shoes" at http://hpaste.org/3542
12:16:19 <hpaste>  shoestore pasted "shoe store" at http://hpaste.org/3543
12:16:50 <newsham> wli: there are other ways ot hide scope.  for example mkObj = (meth1, meth2, meth3) where state = 5; meth1 x = x+5; ...
12:18:22 <newsham> pretty easy to build mutable objects with some iorefs that way
12:19:52 <wli> Well, I'm thinking from the POV of a library writer.
12:20:28 <wli> Someone's going to call this stuff and I want to prevent a lot of things from happening.
12:20:33 <newsham> *nod* me too.  lets say you want an abstract stack type and dont want to have people peeking into them.
12:21:38 <newsham> mkStack = Stack push pop where push = ... pop = ...
12:21:49 <newsham> (more complicated cause you need to build an ioref in there, so doing some IO)
12:22:18 <newsham> when you get your result back you have a handle on a push and a pop method, but not on the stacks internal representation which is wrapped up in the closure
12:22:50 <newsham> I could put together a more complete example if thats unclear
12:23:58 <wli> I think I'm in a situation where I think I need to clarify what I want out of things to be able to tell whether the methods do what I want.
12:24:02 <esap> data Stack a where { Frame :: f (Stack a) -> Stack (f a) } ; empty :: Stack (Stack a -> a) ; empty = Frame id ; push :: a -> Stack b -> Stack (a,b) ; push = curry Frame ; pop :: Stack (f a) -> f (Stack a) ; pop (Frame x) = x
12:25:07 <newsham> esap: we're talking about ADT's and data hiding.
12:25:17 <mrd> @get-sorear
12:25:17 <lambdabot> Unknown command, try @list
12:25:45 <roconnor> @get sorear
12:25:46 <lambdabot> shapr!!
12:25:50 <shapr> what??
12:25:51 <roconnor> hmmm
12:26:07 <mrd> perhaps its like betelgeuse
12:27:04 <newsham> ?get shapr
12:27:04 <lambdabot> shapr!!
12:27:40 <roconnor> @help get
12:27:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:27:50 <roconnor> @help get-shapr
12:27:50 <lambdabot> get-shapr. Summon shapr instantly
12:28:36 <esap> newsham: hmm.. I'm wondering if I have a version of the stack that actually hides the element type :-)
12:28:46 * shapr is here!
12:29:27 <roconnor> shapr: @get sorear  :-)
12:29:29 <newsham> esap: in particular wli was interested in some technique using the type system that doesnt rely on module system
12:29:32 <newsham> which i'm not familiar with
12:29:46 <esap> newsham: GADTs are really a form of existential quantification
12:30:05 <shapr> @seen sorear
12:30:05 <lambdabot> I saw sorear leaving ##logic, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 13h 3m 36s ago, and .
12:30:07 <shapr> hmm
12:35:21 <esap> newsham: Regarding encapsulation, even the Stack example uses encapsulation, although it uses in such way that the encapsulation can be opened, since the full type is recoverable from the produced type (assuming it has the form 'f a').
12:37:01 <esap> newsham: The restriction in this case is that type of form 'Stack a' for any a not of form 'f b' cannot be opened [nor constructed :-)]
12:42:41 <wli> That's the thing; letting people pack arbitrary garbage in their throws invariants not representible via types out the window.
12:43:09 <Saparok> Anyone have a recommendation for what development environment to use starting out learning Haskell on an intel-based Mac?
12:43:32 <wli> +packages
12:43:33 <dons> ghc
12:44:07 <P_D> vmware -> windows -> VisualHaskell
12:44:08 <dons> Saparok: so yeah, ghc is the compiler you want, and then pick whatever editor you're comfortable with
12:44:52 <Saparok> dons: thanks.  I won't bother you all again until I've waded through a few books.  :)
12:46:52 <newsham> wli: sounds like you want a stronger type system
12:47:23 <newsham> like push only taking odd numbers between one and nine?
12:48:21 <esap> data OddNumberBetweenOneAndNine = One | Three | Five | Seven | Nine
12:48:34 <esap> :-)
12:48:37 <newsham> ok, "taking odd numbers"
12:48:48 <dons> instance Num OddNumberBetweenOneAndNine where
12:49:03 <Igloo> I'd like to see the (+) definition  :-)
12:49:11 <dons> heh
12:49:14 <dons> stupid maths
12:49:24 <dons> not agile enough
12:49:53 <dons> Igloo: did you see this runtime bug that atomb sent a patch for?
12:49:56 <newsham> Igloo:  _ + _ = error "wrong type"
12:50:00 <dons> in Adjustor.c
12:50:26 <newsham> (*) is more complicated ;-)
12:51:22 <newsham> Nine / Three = Three;  x / One = x; ...
12:51:35 <newsham> err `div`
12:52:43 <esap> Well I suppose the problem is generalizing this example to arbitrary subsets of naturals
12:54:31 <newsham> agda's type system lets you construct such types, no?
12:54:46 <newsham> ie. a stack that only accepts integers that are odd.
12:54:47 <esap> agda?
12:55:15 <newsham> ?where agda
12:55:15 <lambdabot> http://www.cs.chalmers.se/~catarina/agda/
12:55:56 <newsham> proof-system slash programming-language
12:55:57 <roconnor> >where agda2
12:56:00 <roconnor> ?where agda2
12:56:00 <lambdabot> I know nothing about agda2.
12:56:31 <newsham> http://unit.aist.go.jp/cvs/Agda/
12:56:32 <lambdabot> Title: Agda Official Web Site
12:58:12 <newsham> http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Main.HomePage
12:58:14 <lambdabot> Title: The Agda Wiki - Main, http://tinyurl.com/yp6zsr
12:59:17 <newsham> how do I set a ?where?
12:59:37 <dons> ?where+ agda http://tinyurl.com/yp6zsr
12:59:37 <lambdabot> Done.
13:00:16 <esap> hmm.. This Agda seems like something to look into.
13:01:22 <fox86> does anyone know if i can make Graphviz create a graph and display/update it while my program is running? i want to plot how a neural net changes for every epoch
13:01:53 <newsham> fox: you can use graphviz as a library to give you layout information, and display the results in your own interactive graphical environment
13:02:17 <newsham> although adding nodes to the graph can cause the layout ot change in radical ways
13:02:37 <flux> but certain graphviz layout algorithms support pinning?
13:02:40 <fox86> newsham: oh. are there any other libraries that i can use? i need to plot some simple dots in a coordinate system
13:02:46 <flux> it's not the best solution, though..
13:03:34 <esap> What's the agda 'Set'? Does it refer to the category?
13:04:00 <newsham> fox: to do layout?  some graphics programs come with layout functions.
13:04:01 <bakert> Say you have a type defined as "data Mammal = Primate | Echidna" can you define "data Animal = Reptile | Mammal" and have it do the right thing?
13:04:06 <newsham> and you can always implement your own.
13:04:26 <dons> Echidnas are monotremes
13:04:30 <kowey> fox86: are you talking about charts, like with gnuplot and spreadsheet programs, by any chance?
13:04:33 <dons> along with platypoids
13:04:33 <bakert> dons: oh yea
13:04:34 <newsham> for example, VTK comes with a force-based auto-layout function
13:04:38 <kowey> if so, I remember seeing http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Chart-2007.8.8 on the mailing lists
13:04:40 <lambdabot> http://tinyurl.com/2ufegs
13:04:45 <bakert> i was thinking of monotremes not echidnas specifically
13:04:59 <bakert> but my brain forgot that
13:05:01 <bakert> :)
13:05:05 <dons> we had a platypus and lots of echidnas on the farm i grew up on :)
13:05:13 <dons> the platypus was very shy
13:05:16 <bakert> coool.  and southern hemispherey
13:05:20 <fox86> kowey: yes
13:05:22 <newsham> esap: sorry, dont know agda well yet :(
13:05:25 <dons> heh. antipodean!
13:05:43 <newsham> esap: there are example files on the wiki that have some tutorial type documentary in them
13:05:54 <bakert> dons: when i was in primary school i did a page on monotremes and i wrote each of the letters of the heading on a drawing of an egg.  in bubble writing.  wicked.
13:06:02 <kowey> fox86: oh, well, I call gnuplot, personally, but that's just because i never got around to playing with the Haskell charts library
13:06:07 <fox86> dons: i haven't even seen a real platypus
13:06:10 <newsham> dons: i would be shy too if I didnt quite know if i was a mammal or not
13:06:12 <bakert> but clearly my schooling has since deserted me
13:06:21 <bakert> can I do my thing?
13:06:27 <fox86> kowey: hmm, okay. i have never used it. can i use that with haskell?
13:06:32 <dons> they're very cute, platypus
13:06:37 <bakert> data Mammal = Primate | Monotreme
13:06:44 <bakert> data Animal = Mammal | Reptile
13:06:53 <bakert> and then be able to use Monotreme as an Animal?
13:07:12 <roconnor> data Animal = MkMammal Mammal | Reptile
13:07:12 <bakert> or does it not work like that
13:07:19 <kowey> fox86: well, I use it in the dumbest way possible; by calling it with runCommand (or something like that)
13:07:33 <bakert> roconnor: but i like the non-constructorness of the other way.  not possible?
13:07:57 <roconnor> bakert: object need to have unique types
13:08:00 <roconnor> objects
13:08:06 <fox86> kowey: ah, okay. i would like to do it in the easiest possible way. i can't find out much about graph-libs in haskell
13:08:15 <omnId> you need a constructor to construct an Animal
13:08:41 <bakert> the only reason is that i want to use a subset of my Animals for an isMammal type check
13:08:49 <bakert> and i thought i could get away with only typing them once
13:08:56 <bakert> by joining together
13:09:07 <bakert> but if i have to lose the nice non-constructoriness it's probably not worth it
13:09:13 <bakert> i can just define
13:09:33 <bakert> isMammal a = or $ map (a ==) [Primate, Monotreme]
13:09:39 <bakert> and list them all again
13:10:11 <bakert> isMammal = or . flip map [Primate, Monotreme] . (==)
13:10:14 <bakert> :)
13:10:19 <bakert> i've discovered the pl command!
13:10:29 <bakert> (again)
13:11:00 <bakert> Let me ask in a more general way what you guys would do faced with this problem.
13:11:04 <roconnor> isMammal a = some (a==) [Primate, Monotreme]
13:11:14 <bakert> some?
13:11:16 <bakert> :t some
13:11:16 <fox86> kowey: all i need is to put some red dots on a white background using x/y coordinates
13:11:18 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
13:11:24 <bakert> Alternative?
13:11:26 <roconnor> er
13:11:30 <roconnor> isMammal a = exists (a==) [Primate, Monotreme]
13:11:35 <bakert> :t exists
13:11:37 <lambdabot> Not in scope: `exists'
13:11:44 <roconnor> @hoogle exist
13:11:44 <lambdabot> Distribution.Extension.ExistentialQuantification :: Extension
13:11:45 <lambdabot> Directory.doesDirectoryExist :: FilePath -> IO Bool
13:11:45 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
13:11:55 <roconnor> what is the opposite of forall?
13:12:05 <bakert> @pl not forAll
13:12:05 <lambdabot> not forAll
13:12:07 <bakert> :)
13:12:17 <dmwit> roconnor: Are you talking about type annotations?
13:12:33 <bakert> dmwit: we're just trying to express
13:12:34 <bakert> sMammal a = or $ map (a ==) [Primate, Monotreme]
13:12:38 <doserj> @type any
13:12:38 <bakert> is a slightly nicer way
13:12:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:12:47 <roconnor> doserj: any!
13:12:52 <roconnor> isMammal a = any (a==) [Primate, Monotreme]
13:12:57 <bakert> cool
13:12:57 <kowey> fox86: I just remembered that my call-gnuplot-interactively code was written in Python... oops!
13:12:58 <bakert> like it
13:13:07 <kowey> fox86: I'd give the Haskell Charts library a try
13:13:07 <bakert> @src any
13:13:08 <lambdabot> any p =  or . map p
13:13:11 <fox86> kowey: aah
13:13:14 <fox86> kowey: okay, thanks
13:13:14 <bakert> funky
13:13:20 <roconnor> isMammal a = a `elem` [Primate, Monotreme]
13:13:26 <roconnor> @type elem
13:13:27 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
13:13:33 <roconnor> perfect
13:13:33 <esap> newsham: Adga 'Set' seems to refer to the kind of types. I wonder why they named it like that, 'type' would have been a better choice :-) Instead 'Set :: Type', so Type is used for the next kind after Set :-(
13:13:41 <bakert> roconnor: possibly even nicer
13:14:06 <newsham> types are sets?
13:14:21 <bakert> roconnor: now i just need to get rid of the big long list of redundantness on the end of my `elem`!
13:14:31 <newsham> ie. Word8 is the set [0..255].  and x :: Word8 means x \elem [0..255]
13:14:53 <dmwit> bakert: Maybe you could derive Enum and use (..) somehow to do that.
13:15:00 <bakert> dmwit: nice thinking
13:15:13 <bakert> dmwit: keep all the Mammals at the front of the list type thing
13:15:21 <bakert> it's not exactly beautiful but it is fairly neat
13:15:26 <roconnor> dmwit: animals have order?
13:15:33 <dmwit> Sure, why not?
13:15:38 <bakert> "not exactly beautiful" :)
13:15:52 <roconnor> :( and the instance will leak
13:16:00 <bakert> is there some other way to only have a list of mammals once
13:16:01 <dmwit> Do some appropriate walk of the taxonomy tree, and you have an order.
13:16:22 <fox86> is there any truth to this? http://mail.python.org/pipermail/python-list/2000-February/022278.html
13:16:24 <lambdabot> Title: Haskell or Python!, http://tinyurl.com/2gyuj5
13:16:28 <newsham> esap: err.. the examples I mentioned earlier dont seem to be on the wiki.  they're in the tarball though
13:16:39 <bakert> yet be able to use them both in the isMammal function (or some other equivalent) and as types
13:16:45 <bakert> without a constructor!
13:16:48 <bakert> ???
13:16:48 <esap> newsham: http://unit.aist.go.jp/cvs/Agda/tutorial/node82.html describes Set.
13:16:50 <lambdabot> Title: Small types
13:16:57 <roconnor> isMammal a = fromEnum Alligator <= fromEnum a /\ fromEnum a <= fromEnum Zebra
13:16:59 <allbery_b> fox86: it may have been in February 2000
13:17:14 <allbery_b> 7 years is a *long* time
13:17:16 <newsham> ahh
13:17:54 <dmwit> roconnor: I don't understand your notation.  What are you trying to say?
13:18:43 <bakert> perhaps it's better to include more info in the datatype somehow
13:18:44 <roconnor> isMammal a = fromEnum Alligator <= fromEnum a && fromEnum a <= fromEnum Zebra
13:18:54 <roconnor> sorry /\ is Coq.
13:19:03 <bakert> data Animal = (Subsection, Name)
13:19:15 <bakert> data Subsection = Reptile | Mammal
13:19:18 <bakert> ack no
13:19:21 <roconnor> wait, Alligators aren't Mammals
13:19:21 <bakert> this is wrong
13:19:22 <bakert> ignore me
13:19:28 <fox86> allbery_b: i see, thanks
13:19:31 <dmwit> fox86: Most of those answers seem fairly reasonable.  Which one in particular are you curious about?
13:19:36 <roconnor> isMammal a = fromEnum Bear <= fromEnum a && fromEnum a <= fromEnum Zebra
13:20:11 <bakert> roconnor: i prefer isMammal a = a `elem` [Bear .. Zebra]
13:20:18 <bakert> would that not work?
13:20:22 <roconnor> bakert: but mine is faster :)
13:20:27 <fox86> dmwit: well, "very limited socket and GUI library" and being "especially weak on IO". that doesn't sound very good
13:20:31 <dmwit> roconnor: Oh, I see what you're saying.
13:20:35 <roconnor> unless GHC can optimize yours to mine.
13:20:41 <bakert> my ghc can
13:20:44 <bakert> :)
13:20:52 <bakert> speed is not of the essence here
13:20:53 <roconnor> really?
13:20:54 <roconnor> cool
13:21:01 <bakert> not really i was just being silly :)
13:21:10 <dmwit> bakert: I'd be surprised... Enum doesn't imply Ord, I think.
13:21:14 <roconnor> actually, the optimization requires a compatab
13:21:19 <roconnor> dmwit: good point.
13:21:34 <roconnor> wait
13:21:41 <roconnor> I'm not using Ord of animals
13:21:46 <roconnor> just Ord of Int
13:21:47 <Igloo> dons: I'll look later
13:21:48 <dmwit> Oh, right.
13:22:16 <bakert> hmm.
13:22:20 <dmwit> Still, I don't think it's doable in general, since the fromEnum and enumFromTo might not match up the way you want them to.
13:22:33 <roconnor> bah
13:22:37 <bakert> so how would you do it folks?  you need the isMammal function (or some equivalent)
13:22:46 <roconnor> GHC should assume the functions follow the laws of the class.
13:22:46 <bakert> but you'd like to list the Mammals only once if possible
13:22:56 <bakert> what's the best way?
13:22:56 <dmwit> roconnor: Okay, yeah. =)
13:23:09 <dmwit> bakert: `elem` plus (..) is what I would do.
13:23:16 <roconnor> dmwit: ... unless breaking the laws are unsafe
13:23:23 <roconnor> dmwit: like with Ix
13:23:25 <bakert> dmwit: and that means deriving Enum, right?
13:23:29 <dmwit> yeah
13:23:34 <bakert> ok i will do that
13:23:46 <dmwit> roconnor: uh?
13:23:52 <bakert> it's a bit fragile in a way because if i add a mammal on the end of a list it will break.
13:23:54 <bakert> in the future
13:24:04 <nominolo> > arbitrary :: Gen String
13:24:06 <bakert> so perhaps i should just suck it up and list the mammals twice?
13:24:12 <lambdabot>   Not in scope: type constructor or class `Gen'
13:24:12 <dmwit> bakert: Maybe.
13:24:13 <raxas> fox86: that "weak on IO" part is not true. doing i/o in haskell is just different, not weak
13:24:17 <roconnor> dmwit: You can get a segfault with an incorrectly made Ix class.
13:24:38 <fox86> raxas: ah, okay. what about the GUI/socket libraries?
13:24:57 <dmwit> roconnor: So... why shouldn't GHC assume the laws in that case?
13:25:13 <raxas> fox86: there are gtk and wxwidgets bindings
13:25:20 <roconnor> dmwit: because programs shouldn't segfault if you never call unsafeFoo.
13:25:47 <dmwit> Oh, you're saying there are laws involving unsafe* functions?
13:26:05 <fox86> raxas: ah, okay. i suppose the socket libraries have everything you need. darcs is written in haskell, isn't it?
13:26:14 <roconnor> dmwit: well the Ix thing I guess is a bit unrelated to optimizations
13:26:26 <dmwit> (I'm floundering a little here.  It sounds like you're suggesting GHC should pander to incorrect implementations, when your claim is that it should assume correct implementations.)
13:26:37 <roconnor> dmwit: but my point is the ghc current assumes the Ix class impelementions are well behaved
13:26:50 <raxas> fox86: darcs and lambdabot are good exaples of network stuff in haskell
13:26:51 <roconnor> dmwit: and if they are not well behaved, then it can delete your hard disk.
13:26:58 <dmwit> ouch
13:27:06 <fox86> raxas: okay, nice
13:27:43 <bakert> dmwit: i've made it kind of semi obvious by the way I've laid out the code.  it is actually quite a cool solution even if it isn't totally foolproof.  thanks!
13:27:45 <roconnor> dmwit: so trust that things follow the rules of the class, but not so much that you could delete the hard disk.
13:31:19 <hpaste>  thammers pasted "nix expression for eclipse 3.3.1.1" at http://hpaste.org/3544
13:34:56 <sorear> at least the 'deletes source code on syntax error' bug is long fixed
13:36:39 <fox86> does ghc come with wxhaskell?
13:37:50 <bakert> Is there an equivalent to optional function arguments in haskell?  Or some other way of thinking that makes them irrelevant?
13:38:22 <kowey> fox86: no, but you could do darcs get http://darcs.haskell.org/wxhaskell
13:38:23 <wli> Implicit parameters?
13:38:24 <lambdabot> Title: Index of /wxhaskell
13:38:36 <kowey> watch out, it doesn't yet compile with wxWidgets 2.8 (use 2.6 instead)
13:38:38 <dcoutts_> wli: they're pretty evil
13:38:51 <fox86> kowey: all right. thank you
13:38:53 <bakert> wli: not implicit, just missing.
13:38:56 * wli doesn't like them.
13:38:59 <bakert> that is, i want to do:
13:39:08 <bakert> value Loyalty "Boris"
13:39:12 <bakert> and
13:39:13 <bakert> value Honor
13:39:29 <bakert> (there being no particular subject of Honor unlike Loyalty)
13:39:39 <bakert> what would be a haskelly way to do that?
13:39:42 <dcoutts_> bakert: records are one approach: defaultValues { something = overrideDefault }
13:41:14 <bakert> i think i'll use an empty string for now and revisit it later.
13:44:33 <fox86> looks like i have to downgrade my GHC in order to use wxHaskell
13:44:56 <roconnor> bakert: what does value do?
13:45:34 <dcoutts_> fox86: or you could use gtk2hs which works with all recent ghc
13:45:50 <bakert> roconnor: checks in a list of values for one where the type and the string both match and returns the value
13:46:12 <bakert> or returns 0 if it's not in the list
13:46:20 <fox86> dcoutts: ah, thanks. that one looks more recent
13:46:46 <dcoutts_> fox86: it's actually actively maintained (by me, and several other people)
13:46:51 <bakert> roconnor: so it's more like
13:46:58 <bakert> value Honor "" listOfThings
13:47:09 <fox86> dcoutts: ah, cool.
13:48:13 <fox86> dcoutts: can i easily plot dots on some background and update the position of the dots, say, every 5 seconds using gtk2hs?
13:48:17 <roconnor> bakert: the types here don't smell right
13:48:39 <bakert> data PassionType = Loyalty | Hate | Honor deriving (Eq, Show)
13:48:44 <bakert> data Passion = Passion PassionType String Int deriving (Show)
13:48:52 <dcoutts_> fox86: sure, use cairo with gtk2hs
13:49:00 <bakert> passion passionType subject listOfThings = ...
13:49:01 <fox86> dcoutts: okay, thanks
13:49:13 <roconnor> bakert: can I ever have Honor for something?
13:49:17 <bakert> roconnor: no
13:49:38 <bakert> but the game classes it as a "passion" with all the directed passions
13:49:41 <roconnor> bakert: how about Passion = Loyalty String | Hate String | Honor ?
13:49:47 <bakert> ah
13:49:48 <bakert> yes!
13:49:52 <bakert> clever
13:49:57 <bakert> i should think of things like that :)
13:50:05 <roconnor> bakert: you will
13:50:10 <bakert> one day!
13:50:13 <bakert> thanks :)
13:50:25 <roconnor> bakert: Your lucky I didn't break out the GADTs
13:50:30 <profmakx> anyone seen this error before? ghci: ghc-6.8.0.20071029: internal error: R_X86_64_32S relocation out of range: (noname) = 0x802c8eae8
13:50:34 <bakert> roconnor: eek!
13:50:37 <dcoutts_> fox86: check out the demos/cairo/
13:50:55 <fox86> dcoutts: okay. i am downloading it now
13:51:02 <bakert> roconnor: ok slight complication :)
13:51:13 <bakert> i can't do this any more:
13:51:19 <bakert> passion passionType subject (Passion pt subj v:passions)
13:51:19 <bakert>     | passionType == pt && subject == subj = v
13:51:43 <bakert> becuase i can't break subject away from PassionType without knowing the PassionType.  Can I?
13:52:10 <bakert> man that is ugly :)
13:52:20 <roconnor> bakert: you can write a partial function form Passion to subject
13:52:30 <bakert> ?!
13:52:30 <lambdabot> Maybe you meant: . ? @ v
13:52:31 <bakert> :)
13:52:32 <roconnor> bakert: it will be unsafe in the sameway that head is unsafe
13:52:52 <bakert> that sounds bad
13:52:54 <bakert> :)
13:52:55 <roconnor> bakert: but I'm not sure why you aren't using pattern matching
13:53:08 <bakert> there's loads of pattern matching in there!
13:53:10 <bakert> isn't there?
13:53:26 <bakert> you mean i can somehow do the == in pattern matching?
13:53:34 <bakert> by giving both parts the same name or something?
13:53:36 <bakert> that would be cool!
13:53:39 <bakert> is that possible?
13:53:46 <roconnor> bakert:I think I don't understand what you wrote
13:53:50 <bakert> :)
13:53:52 <roconnor> try me again
13:54:00 <bakert> can i say something like:
13:54:12 <bakert> f x (x:blah) = 10
13:54:17 <bakert> f _ _ = 0
13:54:22 <bakert> and it will do the right thing?
13:54:24 <roconnor> ah I see.
13:54:28 <roconnor> no you cant :(
13:54:35 <bakert> oh.  that would be super cool :)
13:54:41 <roconnor> it would be
13:54:54 <bakert> roconnor: so what did you mean when you said you weren't sure why i wasn't using pattern matching?
13:54:58 <bakert> i have a list of these things:
13:55:08 <roconnor> bakert: I was confused as to what you wrote
13:55:11 <bakert> [Hate "Saxons" 10, Hate "Romans" 3, Honor 2]
13:55:28 <bakert> and I want so say: "what is the value of your Honor"? and similar questions
13:55:38 <bakert> (although of course nothing is forcing me to make it a list)
13:55:54 <roconnor> bakert: what if you have more than one Honor
13:55:55 <roconnor> or none?
13:55:58 <bakert> you can't
13:56:02 <bakert> well you can have none
13:56:04 <bakert> i suppose
13:56:08 <roconnor> I would do
13:56:08 <roconnor> ...
13:56:09 <bakert> which is the same as having 0
13:56:24 <roconnor> Passion = Loyalty String | Hate String | Honor
13:56:27 <roconnor> data Passion = Loyalty String | Hate String | Honor
13:56:29 <roconnor> and then
13:56:56 <roconnor> type PassionMeasure = Passion -> Integer
13:57:04 <roconnor> or perhaps
13:57:11 <roconnor> type PassionMeasure = Passion -> Maybe Integer
13:57:15 <roconnor> but probably not
13:57:26 <bakert> woah.
13:57:35 <bakert> so what does the "type" thing do?
13:57:42 <TSC> Makes a type alias
13:57:46 <roconnor> bakert: makes a type synonym.
13:57:54 <bakert> ok
13:57:57 <roconnor> @src FileName
13:57:57 <lambdabot> Source not found. It can only be attributed to human error.
13:57:58 <bakert> i knew that :)
13:58:02 <roconnor> @src Filename
13:58:02 <lambdabot> Source not found. I am sorry.
13:58:05 <roconnor> bah
13:58:11 <roconnor> @src FilePath
13:58:11 <lambdabot> type FilePath = String
13:58:16 <roconnor> there it is
13:58:23 <omnId> @src String
13:58:23 <lambdabot> type String = [Char]
13:58:38 <bakert> so what's good about that?  just makes everything a bit more wieldy and less incomprehensible like my current gibberish?
13:58:56 <roconnor> bakert: there can only be one score for Honor
13:59:05 <bakert> that's good
13:59:25 <roconnor> There is also Data.Map Passion Integer
13:59:28 <bakert> aside: why Integer and not Int?
13:59:30 <roconnor> for finite maps
13:59:48 <roconnor> bakert: Ints have funny arithmetic
13:59:49 <bakert> i had Int before although i couldn't tell you why :)
14:00:02 <bakert> so Integer should be my default in general?
14:00:20 <roconnor> bakert: I always default to Integer unless I have a good reason not to
14:00:27 <bakert> cool. ok back to my code :)
14:00:41 <bakert> what do i do with this stuff?
14:00:46 <bakert> i have a PassionMeasure tpe
14:00:49 <bakert> type
14:00:58 <bakert> but no function
14:01:11 <bakert> how do i actually get the value of Honor?
14:01:28 <roconnor> passion = id
14:01:42 <bakert> ok you are freaking me out now.  do what???
14:01:43 <bakert> :)
14:02:23 <roconnor> let pm Honour = 5; pm _ = 0 in pm Honour
14:02:42 <roconnor> let pm :: PassionMeasure; pm Honour = 5; pm _ = 0 in pm Honour
14:03:22 <roconnor> do you even need to enumerate (loop over) all the non-zero items in your PassionMeasure?
14:03:39 <bakert> roconnor: sorry just dialling in to weekly all-hands call for work ... back shortly!
14:03:46 <bakert> thanks so much for your help so far!
14:04:14 <roconnor> mmm functions as data
14:18:17 <dcoutts_> first results from the Cabal make project...
14:18:32 <dcoutts_> a random build graph: http://haskell.org/~duncan/cabal/foo.svg
14:19:20 <Jaak> dcoutts_: has repo changed from 'dep-experiment'?
14:19:23 <Orphi> ...well, that's pretty random!
14:19:24 <Steve|Office> I have a list of n+1 numbers (a_0,a_1,...,a_n) and I want to rotate them to get (a_n,a_0,...,a_{n-1}). What would be the best data structure to use in Haskell for that? An array?
14:19:38 <dcoutts_> Jaak: no, still there, though there is a lot of new code we've not pushed
14:19:49 <dcoutts_> Jaak: we're working in a collaborative editor
14:20:06 <dcoutts_> Orphi: aye :-)
14:20:17 <Orphi> what *is* it tho? heh
14:20:22 <dcoutts_> note how easily we get cycles
14:20:38 <dcoutts_> Orphi: imagine they are files, like foo.hs etc
14:20:44 <dcoutts_> and the links are module imports
14:20:47 <lament> Steve|Office: the best data structure would presumably be a circular linked list :)
14:20:53 <dcoutts_> so they're dependencies between targets
14:20:56 <kpreid> Steve|Office: are you going to rotate them repeatedly?
14:21:15 <Orphi> dcoutts_: ok, but what's with the random filenames then?
14:21:22 <Steve|Office> I'm going to be rotating them and then subtracting the original to get a new list.
14:21:40 <kpreid> > take 3 $ map take 3 $ iterate tail $ cycle [1..3]
14:21:42 <lambdabot>  Couldn't match expected type `a -> b'
14:21:44 <Steve|Office> Basically, a_i' = a_{i+1 mod n+1} - a_i.
14:21:46 <dcoutts_> Orphi: it's a randomly generated dependency graph, how else are we to generate names but randomly? :-)
14:21:52 <kpreid> > take 3 $ map (take 3) $ iterate tail $ cycle [1..3]
14:21:55 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2]]
14:22:01 <kpreid> Steve|Office: how's that?
14:22:13 <Orphi> dcoutts_: oh... I thought you meant it was a random subset of a *real* dependency graph ;-)
14:22:16 <kpreid> (it's what lament said)
14:22:28 <dcoutts_> Orphi: the idea is we use QuickCheck to generate 1000's of these random dep graphs and we use it to test our make algorithm
14:22:43 <Steve|Office> What does cycle do?
14:22:47 <omnId> @src cycle
14:22:47 <lambdabot> cycle [] = undefined
14:22:47 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:22:53 <TSC> > cycle [1..4]
14:22:54 <lambdabot>  [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2...
14:23:01 <Steve|Office> Ah.
14:23:08 <TSC> It turns a list into a circular list
14:23:13 <kpreid> Steve|Office: Or if you want to rotate only once, then \xs -> last xs : init xs is probably better
14:23:16 <sieni> > cycle "bi"
14:23:18 <lambdabot>  "bibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibibib...
14:23:19 <Orphi> dcoutts_: what's the algorithm for?
14:23:22 <omnId> > cycle "lo"
14:23:24 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
14:23:43 <Steve|Office> kpreid: I was thinking of doing it without having to go through the list twice.
14:23:46 <dcoutts_> Orphi: for Cabal to build your Haskell projects, it's like make
14:23:47 <lament> "ba" ++ (cycle "na")
14:23:49 <lament> > "ba" ++ (cycle "na")
14:23:50 <lambdabot>  "bananananananananananananananananananananananananananananananananananananan...
14:24:08 <Orphi> dcoutts_: out of curiosity, what's this "cabal" thing everybody keeps talking about?
14:24:11 <kpreid> Steve|Office: It's a constant factor; don't worry about it.
14:24:11 <matthew-_> that's a lot of potassium...
14:24:33 <dcoutts_> Orphi: it's something like automake/autoconf/rpm but for Haskell projects
14:24:34 <shachaf> matthew-_: Not sodium? :-)
14:24:50 <kpreid> Steve|Office: Twice = not bad. Traversing the list as many times as there are elements = O(n^2), bad.
14:24:56 <dcoutts_> Orphi: it's the standard Haskell packaging and distribution system
14:24:58 <Steve|Office> kpreid: I'm not doing an asymptotic analysis.
14:25:00 <matthew-_> shachaf: I was going for potassium, because that's K and then I could be really geeky and go, on no wait, that's const !
14:25:12 <kpreid> Steve|Office: I didn't think you were. This is practical advice.
14:25:28 <Orphi> dcoutts_: and here I was thinking you just give somebody the source code and they compile it... heh
14:26:09 <shachaf> Sure, but you don't get any potassium after the first "banana", do you? You need the "ba".
14:26:19 <Steve|Office> kpreid: This is something that I'm going to do many times and it seems like it should be doable with one pass, but I'll do it as you suggest and if I need to optimize later, I will. Thanks.
14:27:01 <Orphi> dcoutts_: mind you... after that time I had to compile gtk2hs from source once... man, that took forever! o_O
14:27:39 <dcoutts_> Orphi: indeed, and note how it does not do any parallel build. That's one of our tasks, getting Cabal to build things in parallel.
14:27:59 <Orphi> dcoutts_: how would that help?
14:28:10 <dcoutts_> Orphi: if you've got a dual-core cpu
14:28:38 <Orphi> dcoutts_: ah, ok. well this was on an AMD Athlon 1700+ laptop. I doubt anything would make it faster...
14:28:38 <dcoutts_> it'll be able to compile two things at any one time, so at best halving your compile time
14:28:56 <Orphi> dcoutts_: well, I mean, other than Debian providing a pre-built binary package anyway.
14:29:15 <roconnor> bakert: time for bed for me
14:29:23 <bakert> oh no!
14:29:36 <bakert> i will have to make sense of your notes above!
14:29:36 <roconnor> hey you're back
14:29:43 <bakert> i am in an all-hands meeting :)
14:29:44 <roconnor> let's do it now then
14:29:47 <roconnor> on
14:29:48 <bakert> ok
14:29:49 <roconnor> oh
14:29:50 <Orphi> dcoutts_: I'm still looking at that 8-core server machine that's going cheep on Insight.com ;-)
14:29:51 <roconnor> damn
14:30:00 <dcoutts_> Orphi: heh heh
14:30:02 <bakert> no it's ok i can multitask. you are the one with the brain!
14:30:11 <bakert> so how does passion work now then?
14:30:19 <bakert> i am making little lambdas to hold the values?
14:30:24 <bakert> like in SICP
14:30:24 <bakert> ?
14:30:31 <bakert> lispy
14:30:33 <roconnor> well instead of having a list of passion integer pairs
14:30:40 <roconnor> we are going to use a function
14:30:45 <Orphi> hey, by the way... the GHC page claims that GHC works on Windoze NT, but it doesn't. who should I complain at to get the page information changed?
14:30:47 <bakert> not a list of functions?
14:30:53 <roconnor> because it ensure that we assocate one integer to each passion
14:31:04 <roconnor> and we will look up a passion by evaluating the function
14:31:22 <roconnor> pm :: PassionMeasure; pm Honour = 5; pm _ = 0
14:31:29 <roconnor> then pm Honour  yeilds 5
14:31:47 <roconnor> pm (Loyality "roconnor") yeilds 0
14:32:04 <opqdonut> krhm, yields is it not?
14:32:20 <roconnor> only problem is, we cannot make a list of non-zero passions.
14:32:31 <roconnor> if that is important we will have to use Data.Map
14:32:36 <bakert> ok
14:32:46 <roconnor> (or an assocaition list if we are feeling lame
14:33:14 <bakert> so all passions just kind of float free?
14:33:23 <bakert> and are not all bundled together?
14:33:32 <roconnor> PassionMeasure is a function that gives a measure to all passions
14:33:50 <bakert> so can i still "set" the value of a passion?
14:34:03 <roconnor> bakert: you can still modify the value of a passion
14:34:30 <roconnor> increaseHonor :: PassionMeasure -> PassionMeasure
14:34:55 <roconnor> increaseHonor pm Honor = 1 + pm Honor
14:35:01 <roconnor> increaseHonor pm x = pm x
14:35:11 <bakert> so (excuse my cluelessness) where do the "current" values  actually live?  (Can you tell i am not thinking functionally yet?)
14:35:27 <bakert> Currently my Character record type has a passions :: [Passion] field
14:35:33 <bakert> what does that get replaced with?
14:35:42 <Orphi> hmm, I wonder if there's a GHC-specific channel around here...
14:35:43 <roconnor> I guess they live inside a lambda expression.
14:35:49 <opqdonut> btw, i'm doing a regex->dfa/nfa compiler and a [dn]fa matcher as a project in my data structures class
14:35:57 <roconnor> bakert: what is field?
14:35:59 <opqdonut> this will be fun ^_^
14:36:03 <sebell> Orphi: Aptly #ghc
14:36:03 <roconnor> oh wait
14:36:04 <roconnor> sorry
14:36:17 <roconnor> passions :: passionMeasure
14:36:18 <bakert> So Character { passions :: (PassionMeasure -> PassionMeasure) } ?
14:36:20 <bakert> oh
14:36:22 <Orphi> woah - I should have thought of that...
14:36:47 <roconnor> passions :: PassionMeasure
14:36:56 <Orphi> is that for ghc users or ghc developers tho?
14:37:30 <roconnor> bakert: one nice thing about they type synonym is that we can replace it with Data.Map when we later decide we need it.
14:37:34 <sorear> Orphi: nominally devs, but it's the best place to ask really arcane usage questions
14:38:00 <Orphi> sorear: heh. ok. I'm only asking for a minor documentation alteration... ;-)
14:38:13 <roconnor> increaseHonor :: PassionMeasure -> PassionMeasure  is a function that increases the Honor of a Passion measure.
14:38:45 <roconnor> or rather takes a PassionMeasure and returns a new PassionMeasure with one more Honor.
14:39:01 <roconnor> we have to do that because everything is immutable.
14:39:04 <bakert> ok i think i get it
14:39:07 <bakert> :S
14:39:10 <bakert> :s
14:39:15 <bakert> :|
14:39:27 <bakert> i will try and put it in and see what breaks :)
14:40:25 <matthew-_> err, why with -Wall -fno-warn-orphans do I get warnings about orphans?
14:40:39 <roconnor> bakert: we can write noPassion :: PassionMeasure
14:40:42 <bakert> roconnor: thanks so much for all your help
14:40:45 <roconnor> noPassion _ = 0
14:40:50 <bakert> ah ... cool
14:40:52 <roconnor> good starting value.
14:40:53 <bakert> that will be useful
14:41:18 <roconnor> or noPassion = const 0 -- if you like pointfree defintions.
14:41:47 <roconnor> increaseHonor noPassion Honor evaluates to 1.
14:42:08 <roconnor> (increaseHonor noPassion) Honor evaluates to 1.  -- (brackets are only for emphasis)
14:43:09 <roconnor> such is the magic of higher-order functions
14:53:36 <hpaste>  thammers pasted "nix expression for rxvt-unicode" at http://hpaste.org/3546
14:54:28 <bakert> roconnor: is there any way to generalize increaseHonor into an increasePassion ?
14:54:49 <roconnor> yes
14:54:55 <bakert> increasePassion :: PassionType -> PassionMeasure -> PassionMeasure ???
14:55:12 <roconnor> increasePassion x pm y | x == y = 1 + pm x
14:55:18 <roconnor>            |otherwise = pm x
14:55:21 <roconnor> er
14:55:23 <roconnor>            |otherwise = pm y
14:55:28 <hpaste>  thammers pasted "updated jdk6-linux.nix" at http://hpaste.org/3547
14:55:36 <bakert> cool tks
14:55:40 <roconnor> maybe 1 + pm y would look more symmetric
14:55:48 <bakert> well i am going to have it set any value
14:55:54 <bakert> no not set any value
14:56:01 <bakert> accept a modifying function
14:56:05 <bakert> like (+ 4)
14:56:08 <roconnor> nice
14:56:11 <bakert> :)
14:56:20 <roconnor> bakert: sounds like you are on your way
14:56:23 <bakert> :)
14:56:25 <roconnor> I'm going to bed now
14:56:32 <bakert> good night!  thanks so much!
14:57:01 <fasta> bakert: found the answer to the ultimate question already? ;)
14:57:16 <kimitsu_desu> question plz
14:57:43 <bakert> fasta: you know the score.  i have a problem.  i come on #haskell.  it turns out everything i'm doing is wrong and can be replaced by one line of code written in the right way.  then i go away and come up with a new problem :)
14:58:03 <bakert> one day this will stop happening and i will start answering other people's questions!
14:58:55 <kimitsu_desu> wow.. it's lika having a mirror of a #haskel in your mind, right?
14:59:01 <fasta> The annoying thing with assessing the quality of code is that it's dependent on how much experience someone has.
14:59:36 <fasta> The code I write now would be considered by myself as "complicated" years ago, I guess.
15:00:55 <bakert> all i know is other languages frustrate me because of things they can't do.  with haskell there's so much i don't know that i can't tell if i am coming up against language limitations or my own.  i like that so i want to keep going until i am sure i am coming up against language limitations.
15:01:22 <bakert> this may be because haskell is an over-complex mess or because i am inexperienced in the greatest programming language in the world so far.  i shall find out!
15:01:47 <fasta> bakert: Scheme is arguably "simpler".
15:02:09 <bakert> yes.  i quite liked scheme in the little dalliances i have had with it.
15:02:11 <ddarius> Scheme is arguably "more complex".
15:02:20 <bakert> but haskell makes it hardest of all to retreat back to ways i know
15:02:30 <bakert> so haskell is best for learning functional programming for that reason
15:02:35 <fasta> ddarius: why?
15:02:39 <Cale> Usually when I look at the code I wrote a while back, I think it's more complicated than the code I write now. I can usually simplify it quite a bit :)
15:02:52 <ddarius> fasta: call/cc (for one)
15:02:52 <bakert> i actually found it fairly easy to write quite bad programs in lisp/scheme :)
15:03:07 <Cale> bakert: yeah
15:03:08 <fasta> ddarius: Haskell has callCC too.
15:03:20 <fasta> ddarius: it's just that it works in a different way.
15:03:27 <fasta> ddarius: in Scheme it's just there.
15:03:45 <Cale> bakert: In fact, common lisp almost forces you to be imperative. I used it after knowing Haskell, and found it incredibly frustrating as a functional language.
15:03:46 <ddarius> fasta: But it's nicely contained (and not used that often).  Similarly for mutable state, exceptions, dynamic scoping etc.
15:04:06 <Cale> (Scheme is a bit better in that regard though)
15:05:05 <fasta> ddarius: yes, I know it's nicely contained, but to be able to use those things you need to understand monad transformers in most non-trivial cases.
15:05:54 <ddarius> fasta: So?  And the upshot is that you don't pollute the rest of the language.  Haskell supports equational reasoning.  Scheme does not.
15:06:03 <fasta> OTOH, if you want to do functional programming at all costs it's probably easier in Haskell.
15:06:11 <bakert> \o/
15:06:23 <Cale> I almost have a hard time now considering a language to be functional unless it has a combination of two things: a highly concise notation for function composition, and a highly concise way to partially apply functions (esp. currying)
15:06:34 <fasta> ddarius: I find equational reason in code that uses the State monad or mutable references rather pointless.
15:06:55 <ddarius> fasta: Me too.  That's why I want it clearly demarcated and controlled.
15:07:05 <fasta> I do use the "replacing equals with equals" though.
15:07:08 <Cale> If it's not easy to write code in points-free style, it's just not a functional language ;)
15:07:24 <ddarius> call/cc is an uncontrollable and uncontainable effect.
15:07:39 <fasta> I made a global change in a program by just undefining what it previously did and then fixing it up in the right way.
15:07:52 <fasta> ddarius: you have towers of control in PLT Scheme
15:07:56 <Steve|Office> Is there some function like \n xs -> (take n xs, drop n xs)?
15:08:06 <ddarius> splitAt
15:08:08 <fasta> ddarius: so, that's not really true.
15:08:20 <fasta> @src splitAt
15:08:20 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
15:08:23 <Steve|Office> ddarius: Thanks.
15:08:23 <mauke> @pl \n xs -> (take n xs, drop n xs)
15:08:23 <lambdabot> ap (ap . ((,) .) . take) drop
15:08:32 <shachaf> Is it actually implemented like that?
15:09:16 <ddarius> fasta: If I accept a higher-order function from a third-party, it massively compromises my ability to reason about my code.
15:09:22 <Steve|Office> I think I could come up with a better implementation than that.
15:09:23 <ddarius> shachaf: No.
15:09:52 <fasta> ddarius: if you don't have source you cannot say anything about it. Period.
15:10:17 <ddarius> fasta: To a reasonable extent, you can in Haskell.
15:10:39 <fasta> ddarius: you can modify the interface files as a third party.
15:10:55 <ddarius> fasta: What are you talking about?
15:11:40 <fasta> ddarius: an implementation at some point needs to know what the interface of a binary blob is.
15:11:55 <ddarius> fasta: What you are saying has nothing to do with my point.
15:12:24 <fasta> ddarius: oh, you mean the other way around.
15:13:11 <fasta> ddarius: ok, that's true to a reasonable extent.
15:15:03 <fasta> shachaf: no, in GHC it's implemented differently.
15:15:29 <fasta> shachaf: in one loop with implementation defined Ints
15:15:53 <fasta> (Int#)
15:18:30 <mrd> Cale: re. CL, I elucidated exactly that feeling before and no one believed me
15:18:44 <Cale> mrd: where?
15:18:54 <Steve|Office> I'm clearly failing at something simple here. I have main.hs that contains module Main which imports Foo. Module Foo is in foo.hs. ghc is failing to find Foo.
15:18:56 <Cale> (amongst which group of people)
15:18:57 <dibblego> why is there IntMap when there is Map?
15:19:08 <mauke> Steve|Office: Foo.hs
15:19:11 <Cale> dibblego: efficiency, lack of associated types
15:19:22 <Steve|Office> mauke: So the case needs to match?
15:19:22 <dibblego> thought so, thanks
15:19:23 <mrd> here
15:19:28 <mauke> Steve|Office: AFAIK yes
15:19:36 <Cale> mrd: That's interesting. I'll agree with you then. :)
15:19:39 <mrd> woohoo
15:19:59 <Steve|Office> mauke: No difference.
15:20:16 <mauke> are you using --make?
15:20:36 <Steve|Office> mauke: Ah, that did it, thanks.
15:20:49 <Cale> Common Lisp is an awful language if you're trying to program in a strictly functional style. Both constructing and applying higher order functions is awkward, which was a major annoyance for me.
15:21:27 <mrd> even if you get around the syntax, you pay in performance
15:21:45 <mauke> Cale: yeah, it's at least as annoying as in Perl
15:22:17 <Cale> mrd: yeah
15:22:24 <mauke> I actually prefer Perl's syntax; it seems more light-weight to me (I may be biased)
15:23:16 <fasta> Don't you have argument arrays in Perl?
15:23:18 <Cale> I ended up writing macros to simulate the reader monad.
15:23:22 <mauke> (remove-if-not #'(lambda (x) (funcall f x y)) ...)
15:23:39 <mauke> fasta: yes?
15:24:06 <mrd> filter (`f` y)
15:24:44 <mauke> grep $f->($_, $y), ...
15:25:06 <fasta> mauke: don't you think doing function foo(a,b,c) is nicer than function(@foobar){a=foobar[1];b=foobar[2] }etc? Note, I have only programmed trivial things in Perl and that was quite some time ago.
15:26:05 <mauke> sub foo { my ($a, $b, $c) = @_;
15:26:14 <mauke> yeah, I'd prefer sub foo ($a, $b, $c) {
15:26:26 <mauke> but the current state of things I can live with
15:26:46 * LoganCapaldo resists mentioning sub foo($$$) { 
15:26:50 <kscaldef_> mauke: you can have that with a source filter
15:27:02 <mauke> kscaldef_: not in a sane way
15:27:19 <kscaldef_> mauke: what you said can be done pretty sanely
15:27:22 <mauke> LoganCapaldo: that's a parser hint :-)
15:27:37 <LoganCapaldo> Thta's why I resisted mentioning it :)
15:27:41 <mauke> kscaldef_: I think you just used "source filter" and "sanely" in the same thought
15:27:42 <LoganCapaldo> except I didn't
15:27:49 <LoganCapaldo> oh no
15:28:35 <LoganCapaldo> Data.Set.intersect saneThings sourceFilters == Data.Set.empty -- :)
15:28:44 <kscaldef_> mauke: I generally agree, but I've seen this case used in pretty substantial applications
15:29:28 <fasta> What does $$$ do?
15:29:40 * LoganCapaldo feels terrible
15:29:51 * LoganCapaldo tries to put the worms back in the can
15:29:52 <fasta> Or is that the $1 $2 $3 thing?
15:30:05 <mauke> fasta: tells the parser that calls to foo should provide scalar context for three arguments
15:30:24 <mauke> and calls that don't supply exactly three arguments are an error
15:30:25 <kscaldef_> fasta: $1, etc are regex capture variables
15:30:39 <mauke> (note: parser. no runtime checks.)
15:31:06 <fasta> mauke: ok, so you blowup Perl when you do call it the wrong way?
15:31:28 <LoganCapaldo> not really
15:31:37 <mauke> $ perl -e 'sub foo ($$$) {} foo 1, 2;'
15:31:37 <mauke> Not enough arguments for main::foo at -e line 1, near "2;"
15:31:39 <kscaldef_> fasta: it won't compile if you have the wrong num / types of arguments
15:31:47 <mauke> kscaldef_: type?!
15:32:00 <kscaldef_> yes, perl has static types
15:32:06 <mauke> no, it doesn't
15:32:08 <kscaldef_> just a very small number of them
15:32:27 <mauke> I'd like to see how you pass a wrong type to foo
15:32:29 <fasta> kscaldef_: are you saying you cannot dynamically construct a list of arguments to a function?
15:32:54 <kscaldef_> mauke: pass it three arrays
15:33:12 <mauke> $ perl -e 'sub foo ($$$) {} foo @x, @y, @z;'
15:33:16 <mauke>  
15:33:28 <kscaldef_> fasta: that is precisely one ofthe major deficiencies of prototypes in perl
15:33:36 <mauke> fasta: you always can.
15:34:01 <fasta> So, what happens then?
15:34:01 <dibblego> is there a function to remove consecutive duplicates in a list?
15:34:02 <hpaste>  cowboyboots pasted "cowboy boots" at http://hpaste.org/3548
15:34:10 <mauke> dibblego: map head . group
15:34:20 <dibblego> ah yes, thanks
15:34:22 <hpaste>  men'sshoes pasted "men's shoes" at http://hpaste.org/3549
15:34:29 <sjanssen> sorear, glguy: spam alert http://hpaste.org/3548
15:34:34 <mauke> kscaldef_: (still waiting for my type error)
15:35:03 <LoganCapaldo> mauke: man that was way less elaborate than the example I was coming up with ( perl -e 'sub foo($$$) { } @a = (1, 2); $bar = \&foo; $bar->( @a );' )
15:35:09 <kscaldef_> mauke: sorry, it looks like you're right that prototypes don't check types in that way
15:35:14 <glguy> sjanssen: sorear decided we'd rather have spam than the occasional ignored paste :-/
15:35:15 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
15:35:27 <mauke> kscaldef_: there are no types (well, there are syntactic types... kind of)
15:35:29 <kscaldef_> however, perl does have static types
15:35:30 <pjd> dibblego: nub / nubBy
15:35:38 <kscaldef_> that's what the sigils are all about
15:35:39 <sorear> sjanssen, glguy: a bit of a special case that one
15:35:43 <Pseudonym> To be fair, hpaste spam tends to get killed very quickly.
15:35:50 <Pseudonym> But perhaps a mild captcha might help.
15:35:52 <dibblego> pjd, that removes all duplicates afaic
15:35:59 <Pseudonym> That's a bit more Haskell-specific.
15:36:08 <quicksilver> dibblego: shouldn't do
15:36:08 <Pseudonym> Though I don't want to chase off newbies, either.
15:36:12 <glguy> Pseudonym: it gets killed quickly largely because I was monitoring it so closely
15:36:16 <pjd> dibblego: sorry, missed the consecutive
15:36:17 <Pseudonym> Yeah.
15:36:19 <kscaldef_> but, the type system is also very weak, in the sense that in most cases there are implicit conversions
15:36:23 <quicksilver> > map head . group $ [1,2,2,3,3,2,2]
15:36:25 <lambdabot>  [1,2,3,2]
15:36:30 <glguy> Pseudonym: I got used to not having to monitor it though
15:36:32 <quicksilver> dibblego: that didn't remove all dups..
15:36:35 <dibblego> quicksilver, I was referring to nub/nubBy
15:36:38 <quicksilver> oh
15:36:38 <quicksilver> :)
15:36:50 <mauke> kscaldef_: there are no implicit conversions between scalar/array/hash/etc
15:36:53 <Pseudonym> glguy: Just a suggestion, but perhaps you could give admin privs to some people in #haskell.
15:36:58 <Pseudonym> Perhaps via the hpaste bot.
15:37:06 <sorear> Pseudonym: don't forget that lisppaste's captch is the original motivation for hpaste
15:37:12 * Pseudonym nods
15:37:19 <sorear> Pseudonym: dons, shapr, and sorear have hpaste delete privs
15:37:23 <Pseudonym> Cool.
15:37:28 <kscaldef_> mauke: my %foo = @bar
15:37:39 * Pseudonym isn't asking for it, BTW; I'm too unreliable
15:37:40 <kscaldef_> do you not consider that a implicit conversion?
15:37:44 <mauke> kscaldef_: no
15:37:56 <LoganCapaldo> Pseudonym: LoganCapaldo doesn't. (I can talk abotu myself in the third person too! <g>)
15:38:07 <mauke> kscaldef_: that evaluates @bar (in list context (yielding a list)), then assigns the list to %foo
15:38:12 <Pseudonym> But choosing people in a good stratified sampling of time zones might be a good thing.
15:38:12 <kscaldef_> mauke: in that case, I think we have an conflict of semantics and there's not much point to this arguement
15:38:48 <mauke> you could argue that the list->hash thing is an implicit conversion
15:38:51 <hpaste>  westernboots pasted "western boots" at http://hpaste.org/3550
15:38:58 <mauke> but it only happens in =, not in other contexts
15:39:06 <kscaldef_> and that the array to list is an implicit conversion, for that matter
15:39:11 <fasta> Where is that example that blows up Perl?
15:39:22 <sjanssen> sorear, glguy: perhaps you want to rethink your decision on the spam protection?
15:39:22 <mauke> kscaldef_: no, that's just evaluation
15:39:26 <kscaldef_> fasta: define "blows up"
15:39:35 <mauke> fasta: perl -e 'CORE::dump'
15:40:12 <fasta> kscaldef_: what happens when you call a $$$$ function with a dynamically generated list of arguments with a different size?
15:40:27 <P_D> demons fly out of your nose
15:40:51 <kscaldef_> fasta: if you call a $$$$ function with an array of arguments (i.e., something with a @ sigil), it won't compile
15:41:00 <mauke> fasta: the same thing as if the $$$$ wasn't there
15:41:08 <magnusth> how can I make sure that my QuickCheck/UnitTest is run using the local version of the library and not the installed one?
15:41:12 <Pseudonym> Fight to the death!
15:41:26 <Pseudonym> Or ask #perl, I guess.
15:41:33 <Pseudonym> Or even... shock horror... try it and see
15:41:34 <mauke> I am in #perl.
15:41:37 <kscaldef_> ]% perl -e 'sub foo ($$$) {}; my @args = (1,2,3); foo @args'
15:41:37 <kscaldef_> Not enough arguments for main::foo at -e line 1, at EOF
15:41:37 <dons> magnusth: hide the externalversion
15:41:49 <magnusth> dons, how?
15:41:49 <mauke> kscaldef_: that's not a dynamically generated list of arguments
15:41:59 <dons> magnusth: -hide-package QuickCheck
15:42:00 <P_D> do your part to keep the world demon-free
15:42:00 <mauke> kscaldef_: that's a single static argument: @args
15:42:03 <dons> or something similar
15:42:11 <kscaldef_> fasta: what do you mean by a dynamically generated list of arguments?
15:42:14 <magnusth> dons, ok
15:42:21 <fasta> kscaldef_: #perl
15:43:04 * sorear plonks the 66.232.96.0/18 netmask
15:43:30 <glguy> how much of the recent spam is from that range?
15:44:43 <sorear> all three of them, and googling the netmask seems to indicate a spam operation
15:44:57 <glguy> good catch then
15:45:22 <sorear> oh, it's a hosting company
15:45:28 <hpaste>  magnusth pasted "failure to hide package" at http://hpaste.org/3551
15:45:51 <magnusth> dons, I'm failing in my attempts :( http://hpaste.org/3551
15:45:59 <dons> magnusth: try using ghc
15:46:04 <dons> before you try runhaskell
15:46:13 <dons> since runhaskell doesn't respect flags, iirc
15:46:22 <Steve|Office> Is there a simple way to enumerate all lists of size n where the elements of the list are in {-1,0,1}?
15:46:53 <dons> yes, i suspect so.
15:46:56 <P_D> enumerate all lists of size n - 1, then stack on that list
15:46:56 <mauke> > replicateM 4 [-1,0,1]
15:47:03 <magnusth> dons, s/runhaskell/ghc/ gives the same result :(
15:47:08 <lambdabot>  [[-1,-1,-1,-1],[-1,-1,-1,0],[-1,-1,-1,1],[-1,-1,0,-1],[-1,-1,0,0],[-1,-1,0,1...
15:47:19 <Steve|Office> mauke: Thanks.
15:47:30 <magnusth> I was hoping I wouldn't have to uninstall dataenc-0.9 while I'm hacking on the next version
15:47:35 <sorear> glguy: it's apparently a public hosting company (noc4hosts.com)
15:48:12 <dibblego> ?hoogle [Maybe a] -> [a]
15:48:13 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
15:48:42 <hpaste>  gwern pasted "build info" at http://hpaste.org/3552
15:49:07 <glguy> sorear: better to exclude a hosting company than html pasting newbies I suppose
15:49:44 <hpaste>  Trystan pasted "instance Num b => Num (a -> b) where" at http://hpaste.org/3553
15:49:50 <hpaste>  magnusth annotated "failure to hide package" with "ghc instead of runhaskell" at http://hpaste.org/3551#a1
15:50:13 <magnusth> dons, slight difference when using ghc actually... didn't notice at first
15:51:08 <sorear> glguy: they were pasting html to diagnose a Text.XHtml usage problem.  I have to be a little bit partial to people who might be writing pastebins :)
15:51:23 <sorear> actually, I see another filtering opportunity
15:51:50 <sjanssen> sorear: do detected spams get a nice error message describing the problem?
15:51:54 <LoganCapaldo> Trystan isn't that basically Reader?
15:52:10 <LoganCapaldo> with use = liftM2?
15:52:33 <glguy> sorear: if we can filter these people out, then that is definitely a better solution
15:54:51 <sorear> sjanssen: no, and I don't see a nice way to handle the problem
15:55:17 <dons> Igloo: any suggestions on whether X11 should stay in the extra libs bundle?
15:55:32 <dons> if so, when is it safe to merge into packages/X11?
15:56:10 <sjanssen> sorear: a simple message like "Due to the ongoing War On Spam, your paste failed because it contains the string 'http://...', remove those strings and try again."
15:56:36 <LoganCapaldo> I suddenly feel as though my comment was made in vain...
15:56:45 <sjanssen> sorear: that is much better than silently ignoring the posts
15:57:15 <glguy> I'd rather we explained it to new people in channel
15:57:22 <glguy> than to tell the spammer how to get around the filter
15:57:36 <sjanssen> sorear: (if we need such a draconian requirement, I'm all for better suggestions)
15:57:57 <sjanssen> glguy: a human spammer will stop trying when he finds links are not allowed
15:58:31 <dons> yeah, i see no reason for links
15:58:42 <glguy> they have been spamming us since the href block went up
15:58:48 <glguy> and kept on spamming afterwards
15:58:55 <dons> they're silly
15:59:07 <sjanssen> glguy: that's pretty solid evidence that it isn't a human doing it
15:59:29 <hpaste>  dibblego pasted "is there a library function for this?" at http://hpaste.org/3554
15:59:47 <Steve|Office> Where is replicateM located?
15:59:54 <sorear> Control.Monad
16:00:17 <dons> ?hoogle replicateM
16:00:17 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
16:00:18 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
16:00:19 <dons> :)
16:00:24 <Steve|Office> Thank you.
16:00:43 <Steve|Office> Hmm, what does replicateM_ do?
16:00:53 <mauke> @src replicateM_
16:00:54 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
16:01:12 <sjanssen> Steve|Office: replicateM_ n x executes the action 'x' 'n' times
16:01:35 <mauke> if you use it on lists, the return type is [()]
16:01:40 <mauke> which is mostly useless
16:01:49 <Steve|Office> That makes sense.
16:01:56 <Steve|Office> But what is replicateM doing on lists?
16:02:08 <hpaste>  LoganCapaldo annotated "is there a library function for this?" with "shoterer?" at http://hpaste.org/3554#a1
16:02:13 <mauke> sequence (replicate n x)
16:02:21 <P_D> http://www.haskell.org/all_about_monads/html/listmonad.html
16:02:22 <lambdabot> Title: The List monad
16:02:33 <Steve|Office> > replicate 3 [1..3]
16:02:38 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
16:02:46 <dmwit> > let pathSeparator = '/'; dropLast xs = if last xs == pathSeparator then init xs else xs in map dropLast ["hey/a/path", "/hey/a/path/"]
16:02:47 <lambdabot>  ["hey/a/path","/hey/a/path"]
16:02:52 <Steve|Office> > sequence $ replicate 3 [1..3]
16:02:53 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
16:03:11 <mauke> > sequence ["abc", "de"]
16:03:12 <lambdabot>  ["ad","ae","bd","be","cd","ce"]
16:03:29 <P_D> @src sequence
16:03:30 <lambdabot> sequence ms = foldr k (return []) ms
16:03:30 <lambdabot>     where
16:03:30 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
16:03:30 <Steve|Office> Oh, I see what it's doing.
16:03:47 <Igloo> dons: Please don't merge before 6.8.1 is released
16:03:53 <mauke> sequence [xs1, xs2, xs3, ...] == do { x1 <- xs1; x2 <- xs2; x3 <- xs3; ... return [x1, x2, x3, ...]
16:03:53 <Botje> > sequence $ words "I like haskell"
16:03:55 <lambdabot>  ["Ilh","Ila","Ils","Ilk","Ile","Ill","Ill","Iih","Iia","Iis","Iik","Iie","Ii...
16:04:02 <dons> Igloo: right, I wasn't planning on merging at all :)
16:04:06 <dons> hackage is easier/simpler
16:04:31 <dons> the X11 stuff shouldn't be in extralibs anyway -- things like binary are more important, and aren't there.
16:04:37 <dons> so its only hysterical raisns
16:05:14 <dmwit> Heh.
16:05:23 <dmwit> "Hysterical Raisins" would be a great name for a rock band.
16:06:15 <dons> Igloo: what was the motivation for the 1.2.3.0 tag you pushed?
16:06:19 <LoganCapaldo> Could you be sued by the california raisins?
16:06:25 <dons> i didn't read 4 digit version numbers as being compulsory
16:06:35 <dmwit> LoganCapaldo: Only if California is hysterical. =)
16:07:01 <Igloo> dons: Do you mean a version bump? If so, to fit in with the proposed version policy
16:07:20 <dons> Igloo: yes, but the versioning policy doesn't require 4 digits, does it?
16:07:42 <fasta> Igloo: why does the computation I look at about 2minutes, but the heap-profile only shows 18 seconds?
16:07:59 <sorear> glguy: now going in, no 'a href' with friendly error message
16:08:05 <Igloo> dons: It is a.b.c.d where a.b is the major API, c is minor API and d is wibbling
16:08:09 <dons> http://haskell.org/haskellwiki/Package_versioning_policy
16:08:10 <lambdabot> Title: Package versioning policy - HaskellWiki
16:08:16 <dons> is that up to date then?
16:08:22 <Igloo> dons: And you need to padd with zeroes or cabal --snapshot breaks
16:08:24 <dons> A package version number should have the form A.B.C, and may optionally have any number of additional components
16:08:49 <Steve|Office> Is there something like filter but that returns a list of the indices that match, sort of like findIndex?
16:09:07 <oerjan> Steve|Office: findIndices
16:09:25 <glguy> sorear: its easy to get around to, just put in additional space
16:09:26 <Steve|Office> Heh. I don't know why I didn't think to look for that.
16:09:28 <glguy> too*
16:09:29 <P_D> you can always zip it with [1..] beforehand
16:09:39 <dons> Igloo: so you added 4 digits to help the cabal tool? or we're all supposed to use 4 digits for any library now?
16:09:49 <Igloo> dons: Well, that page means you have to have at least 4 components if you want to do any wibbling
16:10:21 <dons> it does?
16:10:32 <Igloo> dons: Yeah, hugs has some library versions like 2.1.20060910 when (under the old version scheme) we would have wanted it to be 2.1.0.20060910
16:10:42 <dons> oh, for snapshots, yes.
16:10:43 <dons> I see.
16:10:51 <dons> wibbling = snapshots, in Igloo speak
16:10:55 <Betovsky> hi ppl
16:10:58 <Betovsky> one question
16:11:01 <Igloo> No, snapshots are below wibbling
16:11:05 <Betovsky> is it possible to do something like
16:11:07 <Igloo> It would now be 2.1.0.0.20060910
16:11:08 <Betovsky> instance (Num a, Monad m) => Num (m a) where
16:11:10 <Betovsky> ?
16:11:29 <Igloo> wibbling is when you tweak the description or something and want to upload a new version, but don't want to bump the minor API version
16:11:43 <Botje> Betovsky: if you can define whichever operations Num needs for monads, sure.
16:11:44 <Igloo> And the first 3 components are the API version, so you need to change the 4th (or higher)
16:11:48 <Botje> but why do you want to do this?
16:11:50 <dons> ah yes. but its not required that you use a wibble
16:11:51 <sorear> Betovsky: YES, with extensions, but it's not usually a good idea since it goes deep into incoherent instances
16:11:56 <dons> you can be more conservatibe
16:12:05 <dons> and change minor versions
16:12:05 <Igloo> more conservative IWW?
16:12:19 <dons> so a non-api breaking change could still be safely called, say, 2.0
16:12:26 <sorear> Betovsky: e.g. (m a) matches Complex Double, so by adding that instance you can't use complex numbers anymore
16:12:35 <dons> even if the minimal change would have been to name it 1.9.9.9
16:12:37 <Igloo> Yes, it's safe, but might mean more work for your users
16:12:46 <oerjan> sorear: there isn't actually anything that is both a Num and an action presently, is there?
16:12:51 <dons> yeah, so I'm fine bumping your 1.2.3.0 to 1.3
16:13:00 <dons> which is where X11 is now
16:13:03 <oerjan> oh right
16:13:20 <sorear> oerjan: doesn't matter, every rule has an implicit cut
16:13:27 <dons> though since it only added types and functions, it actualy could have been 1.2.4
16:13:28 <oerjan> contexts are not looked up until after matching
16:13:42 <Betovsky> Complex is a monad?
16:13:48 <Igloo> dons: OK, but it would be nicer to have 1.3.0.0
16:13:58 <Trystan> LoganCapaldo: Your comment was not in vain, I'm new to IRC ... and Haskell
16:13:59 <oerjan> Betovsky: no, but it doesn't check until _after_ deciding which instance to use
16:14:11 <Igloo> dons: Or do you mean in the X11 HEAD?
16:14:13 <oerjan> for Num
16:14:21 <dons> Igloo: X11 head branch is 1.3
16:14:29 <dons> the version that is on hackage now
16:14:35 <LoganCapaldo> Trystan: it said you joined after I said that, so i have no idea how you read it :)
16:14:38 <Igloo> Ah, OK, I think I see  :-)
16:14:47 <dons> sorry, 1.3.0
16:14:54 <dons> so i did give you a minor versio
16:15:14 <Betovsky> sorry
16:15:16 <Betovsky> e dont get
16:15:19 <Trystan> Magic. And irc logs....
16:15:20 <Betovsky> I dont get
16:15:21 <dons> but the 1.2.3.0 version in ghc extralibs. hmm
16:15:23 <hpaste>  omnId annotated "instance Num b => Num (a -> b) where" with "some improvements" at http://hpaste.org/3553#a1
16:15:29 <dons> are you going to upload that to hackage too?
16:15:38 <Igloo> There's no reason not to, is there?
16:15:40 <Betovsky> if Complex is not a Monad how can it check to Num (m a) ?
16:15:47 <oerjan> Betovsky: it's a technical limitation to instance lookup - contexts are not used except for checking afterwards
16:15:59 <dons> not as far as I know. people will get 1.3.0 by default,
16:16:02 <oerjan> m = Complex, a = Double
16:16:05 <Igloo> Right
16:16:08 <dons> but 1.2.3.0 should be available if needed
16:16:25 <dons> i'd like to have it taken out of extralibs though
16:16:34 <Igloo> Yeah, I'll be uploading all the extralibs, to there is matching source for everything
16:16:43 * Igloo would like to have everything taken out of extralibs  :-)
16:16:52 <Betovsky> oerjan yeah, but m has to be a Monad, or it will only check that later?
16:16:56 <dons> well, if we do that, i'd like mtl moved in :)
16:17:06 <hpaste>  omnId annotated "instance Num b => Num (a -> b) where" with "fixed 'main'" at http://hpaste.org/3553#a2
16:17:07 <dons> since otherwise haskell out of the box doesn't work
16:17:07 <oerjan> Betovsky: only later
16:17:19 <dons> there's some things in extralibs that should sttay
16:17:24 <Betovsky> hmm i see
16:17:25 <Betovsky> thx
16:17:56 <oerjan> Betovsky: i am not sure that it wouldn't work with the overlapping instances though
16:18:05 <Betovsky> I was looking at liftM2 in the docs
16:18:16 <Igloo> dons: I think for Windows we should make separate installers for what is now extralibs, and they aren't really important anywhere else
16:18:17 <Betovsky> and it does examples to the list and maybe monad
16:18:29 <Betovsky> and i thought it would be cool to be available to all monads
16:18:34 <oerjan> sorear: wouldn't Complex a be preferred to m a where m is a variable (given overlapping instances)?
16:18:34 <dons> Igloo: yep
16:18:50 <oerjan> since m is a variable and Complex not
16:19:03 <ac> How would you achieve...
16:19:06 <ac> > concatMap (\(x,y) -> [x,y]) $ zip [1,3,5,7,9] [2,4,6,8,10]
16:19:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:19:31 <omnId> too bad '(f == g) x = f x == g x' won't work, since (==) is too constrained.
16:19:41 <sorear> oerjan: as soon as you start to say 'preferred', you are in waters far too deep for you to fathom... even Oleg seems to regard the interaction between unification and context reduction as black magic
16:19:49 <Trystan> omnId: Why the change to main?
16:20:08 <omnId> Trystan: length give Int, (/) needs something Fractional
16:20:17 <sorear> bah.  fixing hpaste would be a lot easier if I understood happs
16:20:32 <oerjan> sorear: i mean overlapping instances are supposed to choose the smallest matching one, right?
16:21:00 <oerjan> given that it can find some way of deciding which is smaller, and less variables seems the obvious thing?
16:21:00 <omnId> Trystan: the :: Double is not neccessary, it's defaulted anyway.  I added it while trying to fix it.
16:21:06 <sorear> oerjan: that's the motivation, but don't forget that sometimes you don't know the type
16:21:44 <sorear> oerjan: like I said... this is all quite fine in a language where types are known (C++), but seriously breaks down when the typechecker has to introduce variables
16:21:58 <omnId> Trystan: use fromIntegral to convert something in the Integral class into any other numeric type.
16:22:08 <omnId> @instances Integral
16:22:10 <lambdabot> Int, Integer
16:22:12 <Cale> ac: Is that a question? Didn't you just answer it?
16:22:34 <ac> Cale: I was wondering if there's a better way. Usually my first approach is much more verbose than what people here would do
16:22:43 <sorear> ac: transpose?
16:22:56 <kpreid> concat . transpose
16:22:57 <sorear> oh.
16:23:15 <Cale> > concat $ zipWith (\x y -> [x,y]) [1,3..9] [2,4..10]
16:23:15 <omnId> > concat (transpose [[1..5],[6..10]])
16:23:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:23:19 <lambdabot>  [1,6,2,7,3,8,4,9,5,10]
16:23:22 <P_D> flatten . zip ?
16:23:49 <Cale> > concat . transpose $ [[1,3..9], [2,4..10]]
16:23:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:23:53 <sioraiocht> > transpose [1..5] [1..5]
16:23:54 <lambdabot>  Couldn't match expected type `[t1] -> t'
16:23:58 <sioraiocht> > transpose [1..5] [1..5]
16:23:59 <lambdabot>  Couldn't match expected type `[t1] -> t'
16:24:06 <sioraiocht> > transpose [[1..5],[1..5]]
16:24:06 <omnId> sioraiocht: [[a]]
16:24:07 <lambdabot>  [[1,1],[2,2],[3,3],[4,4],[5,5]]
16:24:10 <sioraiocht> ahh
16:24:11 <Trystan> @instances Fractional
16:24:12 <lambdabot> Double, Float
16:24:25 <Cale> > transpose [[1,2,3],[4,5,6],[7,8,9]]
16:24:26 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
16:24:30 <ac> @hoogle flatten
16:24:31 <lambdabot> Data.Tree.flatten :: Tree a -> [a]
16:24:31 <lambdabot> Data.Graph.flattenSCC :: SCC vertex -> [vertex]
16:24:31 <lambdabot> Data.Graph.flattenSCCs :: [SCC a] -> [a]
16:24:37 <omnId> @instances-importing Data.Ratio Fractional
16:24:38 <lambdabot> Double, Float, Ratio a
16:24:47 <omnId> @type 5 % 4
16:24:49 <lambdabot> forall t. (Integral t) => Ratio t
16:25:09 <mauke> > 5.2 / 4.3 :: Rational
16:25:11 <lambdabot>  52%43
16:25:27 <omnId> type Rational = Ratio Integer
16:26:32 <goalieca> > inserve $ transpose $ [[1,0],[0,1]]
16:26:33 <lambdabot>   Not in scope: `inserve'
16:26:39 <goalieca> > insverse $ transpose $ [[1,0],[0,1]]
16:26:40 <LoganCapaldo> @type concat -- looking for this ac?
16:26:40 <lambdabot>   Not in scope: `insverse'
16:26:41 <lambdabot> forall a. [[a]] -> [a]
16:26:42 <goalieca> > inverse $ transpose $ [[1,0],[0,1]]
16:26:43 <lambdabot>   Not in scope: `inverse'
16:26:46 <goalieca> aww
16:26:51 <goalieca> > invert $ transpose $ [[1,0],[0,1]]
16:26:51 <lambdabot>   Not in scope: `invert'
16:26:53 <Saizan> reverse?
16:27:05 <mauke> [[a]] /= Matrix a
16:27:10 <omnId> map recip maybe?  :)
16:27:19 <goalieca>  /= ?
16:27:25 <omnId> not equal
16:27:29 <goalieca> aw
16:27:36 <goalieca> i thought it was div -eq
16:27:56 <goalieca> inverse is probably in the math lib..
16:28:35 <P_D> inverting matrices is serious business, and almost never what you really want to do
16:29:00 <glguy> that sounds like a lolcats caption
16:29:09 <mauke> no, it doesn't
16:29:09 <dons> more haskell jobs... http://cs.hubfs.net/blogs/f_team/archive/2007/10/30/3900.aspx
16:29:11 <omnId> Trystan: you can define a (===) = use (==), but it won't fit into the Eq class.
16:29:12 <lambdabot> Title: Heart of Sharpness (The MSR F# Team's blog at The Hub) : Software Development En ...
16:29:17 <mauke> "serious business" predates lolcats
16:29:19 <LoganCapaldo> I can hhaz linear algebra?
16:29:38 <glguy> yikes, internet meme police!
16:29:43 * glguy flees
16:29:52 <oerjan> @let on f (*) x y = f x * f y
16:29:53 <lambdabot> <local>:1:0:     Equations for `on' have different numbers of arguments      ...
16:29:59 <oerjan> ah
16:30:06 <omnId> @undef
16:30:09 <lambdabot> Undefined.
16:30:13 <oerjan> omnId: good grief
16:30:22 <oerjan> it was obviously already there
16:30:36 <oerjan> @let on f (*) x y = f x * f y
16:30:37 <omnId> @let on (*) f x y = f x * f y -- oh, sorry :)
16:30:37 <lambdabot> Defined.
16:30:38 <lambdabot> <local>:2:15:     Occurs check: cannot construct the infinite type: t = t -> ...
16:30:44 <omnId> oerjan: you've flipped it.
16:30:49 <nominolo> hm, is there a well-known data structure that is like Map but allows fast lookup in both directions?
16:30:55 <oerjan> bah
16:30:56 <oerjan> > on
16:30:57 <lambdabot>  Add a type signature
16:31:02 <LoganCapaldo> In both directions?
16:31:04 <P_D> Two maps?
16:31:08 <LoganCapaldo> Madness!
16:31:10 <fasta> What does BLACKHOLE 64 mean in a heap profile?
16:31:19 <omnId> @undef
16:31:21 <lambdabot> Undefined.
16:31:22 <oerjan> > on (==) toUpper 'a' 'A'
16:31:23 <lambdabot>   Not in scope: `on'
16:31:25 <omnId> @let on (*) f x y = f x * f y -- oh, sorry :)
16:31:27 <LoganCapaldo> A 64bit collapsed star?
16:31:28 <lambdabot> Defined.
16:31:30 <sorear> fasta: probably that your heap is full of black holes
16:31:48 <omnId> > ((==) `on` toUpper) 'a' 'A'
16:31:49 <lambdabot>  True
16:32:13 <fasta> sorear: a black hole is something the implementation discovered evaluates to bottom, right?
16:32:15 <nominolo> LoganCapaldo: if i have a bijective mapping ...
16:32:37 <fasta> Why doesn't the implementation emit a line number in that case?
16:32:50 <LoganCapaldo> nominolo: I'm generally not meant to be taken seriously :)
16:33:04 <omnId> Trystan: (==) f g = undefined  would probably be better
16:33:13 <nominolo> LoganCapaldo: ok.  noted :)
16:33:17 <omnId> Trystan: for the Eq instance
16:33:18 <sorear> fasta: no, it's something that is currently being evaluated
16:33:41 <sorear> fasta: do you have lots of threads and/or make heavy use of exceptions?
16:33:41 <Trystan> omnId: Thanks. I'm leaning a lot. C# -> Haskell is fun but not easy....
16:33:55 <fasta> sorear: I make no use of exceptions/threads.
16:34:08 <Trystan> ... learning a lot ...
16:34:10 <fasta> sorear: I make use of exceptions, but that's in the "real code".
16:34:33 <sorear> fasta: got a stack overflow somewhere?
16:34:36 <omnId> Trystan: it also happens the 'use' is already defined, as liftM2 in the ((->) r) monad.
16:34:37 <fasta> sorear: no
16:34:44 <omnId> @pl \f g h x -> f (g x) (h x)
16:34:44 <lambdabot> liftM2
16:35:14 <fasta> sorear: something does make ghci segfault, when I call a binary with a very big input, though.
16:35:31 <fasta> sorear: but that's unrelated, I think, since I don't call that binary now.
16:35:34 <Trystan> omnId: I figured it would be somewhere
16:35:37 <LoganCapaldo> omnId: I so said that already!
16:35:40 <fasta> sorear: in short: I have no idea.
16:35:43 <sorear> fasta: I'm rather suprised that you are seeing that many blackholes.  I *thought* the number of them at any given time was at most proportional to the stack depth, and ~8M of data for a default 2M stack limit wouldn't be very visible on a heap profiles
16:35:45 <LoganCapaldo> I demand credit!
16:35:47 <omnId> LoganCapaldo: right :)
16:35:48 <LoganCapaldo> :)
16:35:50 <sorear> fasta: iow, what you just said
16:35:52 <sorear> :)
16:35:57 <omnId> Trystan: LoganCapaldo said that already
16:36:20 <fasta> sorear: I have a 15MB stack, though
16:36:34 <fasta> sorear: the heap is in the hundreds of MB's.
16:36:35 <Trystan> omnId: Yeah. Credit to LoganCapaldo
16:36:41 <fasta> MBs*
16:36:49 * LoganCapaldo hides credit in his pocket
16:37:08 <fasta> Anyway, this violates one of fasta's rules.
16:37:33 <fasta> The rule being that whenever an application claims something about my code, it should provide proof.
16:38:32 <omnId> (unbeknownst to LoganCapaldo, I have previously sliced holes in his pants pocket for just such an occasion.  /me scoops up the dropped credit.)
16:38:50 <fasta> sorear: did you see my question on the heap-profile?
16:39:15 <Trystan> @instances Reader
16:39:23 <omnId> @instance Monad
16:39:23 <lambdabot> Maybe you meant: instances instances-importing
16:39:23 <lambdabot> Couldn't find class `Reader'. Try @instances-importing
16:39:27 <omnId> @instances Monad
16:39:28 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:40:38 <sorear> fasta: ? 16:31 < fasta> What does BLACKHOLE 64 mean in a heap profile?
16:40:39 <LoganCapaldo> @src (->) return
16:40:39 <lambdabot> return = const
16:40:41 <omnId> liftM2 f x y = x >>= (\a -> y >>= (\b -> return (f a b)) -- this is complicated, but the definitions of (>>=) and return for the reader type are such that this reduces to 'use'.
16:40:48 <LoganCapaldo> @src (->) (>>=)
16:40:48 <lambdabot> f >>= k = \ r -> k (f r) r
16:41:04 <fasta> sorear: no, why the heap profile only shows about 18 seconds and the computation time is 2 minutes.
16:41:12 <LoganCapaldo> @unmtl Reader
16:41:12 <lambdabot> err: No applications
16:41:14 <nominolo> @pl \m r k -> maybe r k m
16:41:14 <lambdabot> flip (flip . maybe)
16:41:23 <fasta> sorear: I believe I have solved that problem, though, but I would like to know your opinion on it.
16:41:56 <LoganCapaldo> @help unmtl
16:41:56 <lambdabot> unroll mtl monads
16:42:09 <LoganCapaldo> @unmtl Reader a
16:42:09 <lambdabot> Reader a
16:42:21 <LoganCapaldo> I clearly don't know what that command does :)
16:42:31 <omnId> LoganCapaldo: that un-newtypes the types.
16:42:34 <nominolo> @unmtl (ReaderT IO () a)
16:42:35 <lambdabot> IO -> () a
16:42:56 <Pseudonym> @unmtl (ReaderT () IO a)
16:42:56 <lambdabot> () -> IO a
16:42:59 <nominolo> @unmtl (ReaderT r IO a)
16:42:59 <lambdabot> r -> IO a
16:43:00 <omnId> nominolo: switched the read type with the monad :)
16:43:10 <nominolo> who cares!!
16:43:11 <Pseudonym> Unfortunately, unmtl is not necessarily kind-correct.
16:43:18 <omnId> @unmtl RWST r w s m a
16:43:19 <lambdabot> r -> s -> m (a, s, w)
16:43:20 * LoganCapaldo presumed newtype Reader r a = Reader (r -> a) and thereforce thugh unmtl would do something
16:43:40 <Trystan> Very enlightening
16:43:44 <nominolo> @unmtl ContT () IO a
16:43:45 <lambdabot> (a -> IO ()) -> IO ()
16:44:03 <LoganCapaldo> thugh is the new improved way of spelling "thought" fyi
16:44:16 <Pseudonym> @unmtl Reader r a
16:44:16 <lambdabot> r -> a
16:44:18 <nominolo> *thug*
16:44:20 <omnId> Trystan: *really*? How long have you been learning? At that stage this stuff looked like greek to me :)
16:45:04 <sorear> fasta: my guess is that most of the time went to garbage collection (which the profiler tries to hide, since it's not connected to any specific function)
16:45:10 <nominolo> @unmtl State a
16:45:10 <lambdabot> State a
16:45:12 <fasta> sorear: good guess
16:45:21 <nominolo> @unmtl StateT s Identity a
16:45:21 <fasta> sorear: It only seems to be showing MUT time.
16:45:21 <lambdabot> s -> Identity (a, s)
16:45:55 <nominolo> @unmtl StateT s  (StateT t IO) a
16:45:55 <lambdabot> s -> t -> IO (a, s, t)
16:45:59 <omnId> Trystan: this: http://hpaste.org/3146#a3 has a derivation of liftM2.  It looks intimidating, but it's simple enough if you follow it through one step at a time.
16:46:10 <Trystan> omnId: about a year of mostly tutorial Haskell. Monads are still 50% greek to me
16:46:30 <fasta> sorear: Can I somehow say that GHC should only garbage collect when it has reached the maximum heap space available?
16:46:37 <nominolo> aren't they greek, really?
16:46:40 <nominolo> or latin?
16:46:45 <Pseudonym> "Monad" is Greek.
16:46:48 <Pseudonym> And so are eta and mu.
16:46:56 <nominolo> lamdba!
16:47:07 <fasta> sorear: I know there's an option to do so, but when I read some source code for the allocator, it seems they just ignore it "after extensive benchmarking".
16:47:08 <LoganCapaldo> it's all greek to me
16:47:28 <fasta> sorear: I don't know for a fact that they do ignore it, but they seem to imply it in that comment.
16:47:35 <oerjan> @babel en gr It's all Greek to me
16:47:36 <lambdabot> Plugin `babel' failed with: Error: Language gr not supported
16:47:46 <sorear> fasta: ask #ghc, I'm not a guru on any specific part of the RTS
16:47:47 <oerjan> @help babel
16:47:47 <lambdabot> babel <lang1> <lang2> <phrase>.
16:47:47 <lambdabot> Translate a phrase in lang1 to lang2.
16:47:47 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
16:47:55 <oerjan> @babel en el It's all Greek to me
16:47:57 <lambdabot>   can't parse this language
16:48:11 <nominolo>  @babel en de It's all Greek to me
16:48:17 <nominolo> @babel en de It's all Greek to me
16:48:18 <lambdabot>   Es ist aller Grieche zu mir
16:48:23 <nominolo> lol
16:48:25 <LoganCapaldo> @babel en greek It's all Greek to me
16:48:26 <lambdabot>   can't parse this language
16:48:50 <nominolo> "Ich versteh nur 'Bahnhof'" is the correct translation
16:49:12 <LoganCapaldo> @. babel de en . babel en de It's all Greek to me
16:49:13 <lambdabot> Plugin `compose' failed with: Unknown command: "de"
16:49:21 <LoganCapaldo> damn
16:49:30 <LoganCapaldo> @. babel de en babel en de It's all Greek to me
16:49:31 <lambdabot> Plugin `compose' failed with: Unknown command: "de"
16:49:52 <omnId> LoganCapaldo: unfortunately, you cannot partially-apply lb commands :(
16:51:07 <omnId> @babel de en Es ist aller Grieche zu mir
16:51:08 <lambdabot>   It is all Greek to me
16:51:18 <omnId> not much distortion there
16:51:37 <LoganCapaldo> @babel de en Ich versteh nur 'Bahnhof'
16:51:38 <lambdabot>   I understand only ' station '
16:52:15 * LoganCapaldo is proud cause he got it (almost) right
16:52:35 <LoganCapaldo> for some reason I thought Bahnhof was train station only
16:52:36 <omnId> @babel de en saurkraut
16:52:37 <lambdabot>   saurkraut
16:52:46 * omnId knows German.
16:52:57 <mauke> @babel de en sauerkraut
16:52:58 <lambdabot>   sauerkraut
16:53:14 <mauke> @babel de en zerlegungsgleichheit
16:53:15 <lambdabot>   equivalence by dissection
16:53:28 <mauke> nice!
16:53:51 <LoganCapaldo> by dissection?
16:54:27 <LoganCapaldo> When I chop you into tiny bits you're equivalent to the pile of tiny bits i chopped the other guy into?
16:54:36 <oerjan> LoganCapaldo: i think it is, Eisenbahn is railway iirc
16:54:37 <gabor> decomposition
16:54:53 <Pseudonym> That's right.
16:55:00 <Pseudonym> Or "railroad" if you're from North Maerica.
16:55:18 <Heffalump> But bahn is any kind of road, isn't it?
16:55:19 <bakert_> What is it that I am supposed to use instead of "head" for safety's sake?
16:55:31 <P_D> yes, any kind of raod
16:55:32 <LoganCapaldo> @type listToMaybe
16:55:33 <mauke> bakert_: case
16:55:34 <lambdabot> forall a. [a] -> Maybe a
16:55:46 <mauke> Heffalump: depends on the context
16:55:46 <Pseudonym> Heffalump: "iron road"
16:55:52 <Pseudonym> Literally./
16:55:52 <oerjan> Heffalump: well there's Autobahn too
16:55:56 <LoganCapaldo> @type fromJust . listToMaybe
16:55:57 <lambdabot> forall a. [a] -> a
16:55:59 <P_D> dict.leo.org
16:56:06 <omnId> bakert_: depends what you want to do in the case of a nil.
16:56:12 <twanvl> @@ @babel de en @babel en de It's all Greek to me
16:56:15 <bakert_> omnId: i have a default value
16:56:25 <bakert_> actually, my function will already return that value
16:56:30 <bakert_> so i dont' really need to avoid head
16:56:34 <bakert_> but i would like to
16:56:36 <omnId> bakert_: fromMaybe defaultValue . listToMaybe
16:56:40 <bakert_> in the spirti of doing the right thing
16:57:11 <omnId> > map (fromMaybe defaultValue . listToMaybe) ["blah", "foo", "", "zap", ""]
16:57:12 <lambdabot>   Not in scope: `defaultValue'
16:57:15 <oerjan> @help @
16:57:15 <lambdabot>  @ [args].
16:57:15 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
16:57:15 <lambdabot>  The commands are right associative.
16:57:15 <lambdabot>  For example:    @ @pl @undo code
16:57:15 <lambdabot>  is the same as: @ (@pl (@undo code))
16:57:19 <omnId> > map (fromMaybe '!' . listToMaybe) ["blah", "foo", "", "zap", ""]
16:57:21 <lambdabot>  "bf!z!"
16:57:27 <LoganCapaldo> @type \default -> foldr const default
16:57:28 <lambdabot> parse error on input `default'
16:57:40 <LoganCapaldo> @type \def -> foldr const def
16:57:41 <lambdabot> forall a. a -> [a] -> a
16:57:44 <mauke> huhu
16:57:49 <bakert_> was: f c =  head $ filter (\x -> qualifiesAs x c) [Monkey, Primate, Animal]
16:57:54 <Pseudonym> ?babel de en Bahn
16:57:55 <lambdabot>   Course
16:57:58 <Pseudonym> There you go.
16:58:25 <oerjan> cool
16:58:32 <bakert_> omnId: perhaps i will just use the fact that qualifiesAs Animal = True
16:58:39 <omnId> > map (fromMaybe '!' . listToMaybe) ["flip", "under", "carefully", "killing", ""]
16:58:40 <lambdabot>  "fuck!"
16:58:40 <LoganCapaldo> > (\def -> foldr const def) 0 []
16:58:40 <bakert_> and not listToMaybe it
16:58:41 <lambdabot>  0
16:58:46 <LoganCapaldo> > (\def -> foldr const def) 0 [1,2,3]
16:58:47 <lambdabot>  1
16:58:54 <Pseudonym> Yay, meeting!
16:59:08 <LoganCapaldo> I like mine :)
16:59:37 <bakert_> :t case
16:59:38 <lambdabot> parse error (possibly incorrect indentation)
16:59:45 <bakert_> @src case
16:59:45 <lambdabot> Source not found.
16:59:46 <LoganCapaldo> case is syntax not a function
16:59:49 <bakert_> oh
17:00:11 <LoganCapaldo> case xs of { (x:_) -> x ; [] -> defaultValue }
17:00:17 <fasta> sorear: #ghc is dead, but I already understand the reason I think. I allocate and deallocate large overlapping pieces of the same structure over and over and GHC does not know that. I did this to simplify implementation at the cost of a constant factor.
17:00:24 <oerjan> @free f :: a -> a
17:00:24 <lambdabot> g . f = f . g
17:00:37 <oerjan> @djinn f :: a -> a
17:00:38 <lambdabot> Cannot parse command
17:00:40 <fasta> sorear: I only had no idea it would be this much.
17:00:43 <oerjan> @djinn a -> a
17:00:43 <lambdabot> f a = a
17:01:13 <LoganCapaldo> wow I'm silly
17:01:23 <LoganCapaldo> > (foldr const) 0 [1,2,3]
17:01:25 <lambdabot>  1
17:01:30 <sorear> ghc is not mlton
17:01:32 <LoganCapaldo> > (foldr const) 0 []
17:01:33 <lambdabot>  0
17:01:46 <oerjan> @@ @type let (@djinn a -> a) in f
17:01:47 <LoganCapaldo> me and my unecessary naming of things
17:01:48 <bakert_> thanks folks and good night
17:01:54 <fasta> sorear: are you saying mlton can spot those kinds of things? o_O
17:02:15 <oerjan> @@ @id @run 1+1
17:02:26 <oerjan>  @@ is not working? :(
17:02:34 <twanvl> ?? ?id ?run 1+1
17:03:08 <fasta> sorear: that would make it a sufficiently smart compiler
17:03:14 <twanvl> it works if you /msg lambdabot
17:03:15 <oerjan> @list @
17:03:15 <lambdabot> compose provides: . compose @ ?
17:03:16 <omnId> @ @babel de en (@babel en de I would like to purchase a chicken sandwitch)
17:03:29 <oerjan> @help compose
17:03:29 <lambdabot> . <cmd1> <cmd2> [args].
17:03:29 <lambdabot> . [or compose] is the composition of two plugins
17:03:29 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
17:03:40 <oerjan> @help ?
17:03:41 <lambdabot>  @ [args].
17:03:41 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
17:03:41 <lambdabot>  The commands are right associative.
17:03:41 <lambdabot>  For example:    @ @pl @undo code
17:03:41 <lambdabot>  is the same as: @ (@pl (@undo code))
17:04:01 <omnId> @@ (@babel de en (@babel en de I would like to purchase a chicken sandwitch))
17:04:26 <omnId> hrm, worked in /msg
17:04:45 <oerjan> indeed it did, my type/djinn example too
17:06:32 <sorear> fasta: most efficient way to handle large mutable records in Haskell is IOArray Any
17:07:22 * ac is starting to like Haskell's type system
17:07:24 <fasta> sorear: ah, the Any type that caused so much horror has an actual use?
17:07:46 <fasta> sorear: so, the idea would be to remove the "indirections" in the record system, heh.
17:07:46 <ac> I've switched from Bools, to Doubles, to Complex with very little pain
17:08:18 <fasta> From what I understand "Any" is some internal GHC type variable place holder.
17:08:19 <sorear> yes.  it tells GHC that there are no valid assumptions to make about a value; Any is the only type that can be safely unsafeCoerced# to and from any type.
17:08:35 <sorear> In particular, data Dynamic = Dynamic TypeRep Any
17:08:53 <ac> in Scheme I think it would've taken a little more fiddling
17:09:12 <fasta> sorear: aren't STArray and IOArray about the same?
17:09:20 <sorear> Used to be (forall a. a), and before that (), but they got tired of finding new hacks to confuse the optimizer with, and added a supported loophole
17:09:32 <sorear> Yes, STArray and IOArray are basically the same.
17:09:54 <fasta> sorear: is Any documented?
17:10:04 <sorear> If I don't have a larger pure algorithm I usually take IO because those phantom types get irritating
17:11:19 <sorear> fasta: yes, in the documentation for GHC.Prim
17:11:28 <fasta> sorear: the phantom type is the "s" parameter in ST s m?
17:11:31 <sorear> yes
17:11:35 <LoganCapaldo> So is IO Any like as evil as you can get in ghc? :)
17:11:35 <fasta> sorear: yes, I found it.
17:12:07 <fasta> LoganCapaldo: no, ask mauke for evil.
17:13:11 <mauke> http://mauke.ath.cx/stuff/haskell/hell.hs
17:14:12 * omnId quickly murders mauke
17:14:26 <LoganCapaldo> That looks liek it's probably platform dependent
17:14:26 <mauke> aieee
17:14:39 <mauke> o rly?
17:14:52 <LoganCapaldo> I dunno
17:15:12 <omnId> though it's always great to mkFun of CStrings :)
17:15:29 <fasta> omnId: cute
17:16:02 <omnId> I thought so, anyway =)
17:16:49 <LoganCapaldo> % ./hell
17:16:50 <LoganCapaldo> zsh: illegal hardware instruction  ./hell
17:17:03 <LoganCapaldo> My look is seemingly confirmed
17:17:33 <fasta> LoganCapaldo: what platform are you on?
17:17:41 <LoganCapaldo> Mac OS X / PPC
17:18:07 <fasta> LoganCapaldo: you could add a CPP macro to it and extend it ;)
17:18:13 <LoganCapaldo> heh
17:19:02 <P_D> shell code in haskell?
17:19:15 <mauke> no
17:19:15 <mauke> it doesn't run a shell
17:19:25 <P_D> you know what I mean
17:19:28 <P_D> cheating with the zeroes...
17:20:23 <omnId> It's machine code! _
17:20:33 <LoganCapaldo> not for my machine :)
17:20:37 <omnId> /4chanmeme
17:20:52 <mauke> get an intel x86
17:21:11 <LoganCapaldo> I have an AMD64
17:21:15 <LoganCapaldo> does that count?
17:21:25 <omnId> no, intel was specified.
17:21:28 <mauke> no idea
17:21:35 <omnId> you're out of luck.
17:22:07 <LoganCapaldo> I presume it prints Hello, world! ?
17:22:18 <fasta> You could just try it
17:22:22 <mauke> yes
17:22:26 <LoganCapaldo> And doesn't for instance, make demons fly out of nose?
17:22:38 <fasta> LoganCapaldo: it could do that too on different hardware
17:23:12 <omnId> LoganCapaldo: did you read the same blog article I did or had you known that expression already? :)
17:23:33 <LoganCapaldo> Someone said it in channel earlier
17:30:23 <dataangel> What's the difference between normal order evaluation and lazy evaluation? from the descriptions on the web they look the same
17:31:00 <oerjan> lazy is weak head normal evaluation with sharing of results, i think
17:33:08 <oerjan> i.e. you don't evaluate inside functions, and expressions which become substituted into several places are still only evaluated once
17:33:17 <dcoutts> dataangel: the difference is only in the sharing
17:33:47 <dataangel> oerjan: wikipedia also mentioned "don't evaluate inside functions" but I'm not sure what it means
17:34:35 <kosmikus> whether you evaluate \x -> 2 + 2 to \x -> 4 or not
17:34:39 <dataangel> dcoutts: is that still true if mutation is allowed?
17:34:48 <sorear> dataangel: no
17:34:59 <sorear> dataangel: which is why we don't allow mutation
17:36:01 <dataangel> hrm, wikipedia says call-by-name is different from normal order in that call-by-name doesn't evaluate inside the body of an unapplied function
17:36:35 <dataangel> so \x -> 2 + 2 to \x -> 4 would happen in normal order but not in call by name?
17:36:38 <dcoutts> dataangel: mutation is evil remember? :-)
17:36:59 <dataangel> dcoutts: just trying to keep classifications straight ;p
17:36:59 <LoganCapaldo> mutation isn't evil, it's just misunderstood
17:37:28 <dcoutts> in fact I went to a lecture today all about the problems imperative programmers have with polymorphic references and mutability
17:38:08 <dcoutts> they don't call them polymorphic references, they call it OOP and inheritance/polymorphism
17:40:42 <mrd> dataangel: yea
17:44:31 <dataangel> dcoutts: My boss codes C++ exclusively with classes that have all fields public. Mutability becomes a problem ;p
17:45:51 <dataangel> dcoutts: to be fair 'polymorphic references' by themselves don't convey access privileges
17:47:32 <dcoutts> dataangel: so this problem was all about examples where you use inheritance to make more specific instances of a concept, combined with methods that mutate
17:47:49 <dcoutts> so eg a polygon class that has a method to add another edge
17:48:03 <dcoutts> and a square class that subclasses polygon
17:48:19 <dcoutts> so a square is a special kind of polygon right?
17:48:38 <mauke> no, a polygon is a special square that can gain edges
17:48:46 <dcoutts> well exactly
17:48:50 <dataangel> inheritance is supposed to be about substitutability, so in the context of inheritance, no
17:49:29 <dcoutts> so you get these examples where you put a square into a collection of polygons and then apply some mutating method of the superclass
17:49:40 <Excedrin> what's the point of access privileges?
17:49:42 * fasta notes that signal/noise(lwn.net)/signal/noise(reddit.com) approaches 0.
17:49:55 <dataangel> Excedrin: encapsulation
17:50:09 <fasta> er infinity
17:50:10 <dataangel> Excedrin: hiding the specific format/structure of state
17:50:35 <Excedrin> you can't have encapsulation without "private" ?
17:51:14 <dataangel> Excedrin: In the OOP way of thinking, no I think not
17:51:24 <dataangel> Excedrin: but feel free to enlighten me otherwise :)
17:52:08 <dataangel> something with a constant number of edges and something that has an interface for adding edges are different beasts :) They should have a polygon class with non-mutable methods like NumEdges(), etc. from which square inherits. For a polygon with mutable edges, make that a separate class all together or a subclass of Polygon, EditablePolygon or something ;p
17:52:44 <dcoutts> right, so the problem is mutability
17:53:05 <KatieHuber> the problem is always mutability :/
17:53:09 <dataangel> dcoutts: I'd say the problem is false generalization.
17:53:46 <dcoutts> dataangel: if we distinguished immutable vs mutable objects then you could pass a square as a polygon
17:53:51 <dataangel> dcoutts: You could make the same mistake in haskell. You could have an AddEdge function in your polygon type class that is supposed to return a new polygon with an additional edge, and it'd still be wrong to try and make a Square type deriving that class
17:54:13 <dcoutts> dataangel: but for us the type system prevents it
17:54:33 <ddarius> Indeed, the subtyping rule for a reference cell is invariant.
17:54:37 <dcoutts> dataangel: in Java or Eiffel that error is not caught by the type system
17:54:39 <mauke> > succ ()
17:54:41 <lambdabot>  Exception: Prelude.Enum.().succ: bad argument
17:55:06 <dcoutts> ddarius: or it could be contravariant
17:55:08 <dataangel> dcoutts: Assuming that AddEdge in Polygon is pure virtual, the compiler will stop them when they forget to define it for Square. Upon realizing they need to define it for square, they promptly klonk themselves over the head and realize they have a bad abstraction
17:55:37 <dataangel> dcoutts: Java would if AddEdge was part of an interface rather than a class.
17:56:11 <dcoutts> dataangel: Eiffel allows one to restrict the types of method parameters in subclasses, and thus has this bug.
17:56:42 <dcoutts> dataangel: and java has similar issues with subtyping of collections
17:56:51 <mauke> ArrayStoreException
17:56:56 <dataangel> dcoutts: I think C++ does as well, but you could argue that that's a misfeature. That mutability might compound it is a separate issue I think though.
17:57:05 <ddarius> dcoutts: Reading it makes it need to be contravariant at least and writing requires covariance at least.
17:57:10 <dataangel> dcoutts: Java has generics now ;p
17:57:39 <oerjan> > [()..]
17:57:40 <dcoutts> ddarius: mm, ok
17:57:41 <lambdabot>  [()]
17:57:55 <dataangel> If the point of inheritance is substitutability, and you write a subclass so that a method takes a more restrictive type of parameter, you've screwed up
17:58:42 <dataangel> there's no reason the compiler couldn't recognize that
17:58:52 <dataangel> just for eiffel and C++ it doesn't :P
17:58:53 <ddarius> dataangel: That's exactly the point.
17:59:01 <dcoutts> dataangel: I think the point is there are many real world examples where you'd like to say something subclasses, but actually it'd only be correct for immutable objects
17:59:13 <ddarius> dataangel: Few (mainstream) languages that do handle subtyping do it properly.
17:59:39 <dcoutts> dataangel: at least that what the speaker was arguing
18:00:28 <ddarius> Mutability significantly restricts subtyping.
18:01:51 <dataangel> hrm
18:01:52 <ddarius> And I need to do my laundry.
18:01:55 <dataangel> that's interesting
18:02:49 <dataangel> but it still seems to me that you can make the mistake as I described it in Haskell
18:07:22 <dataangel> you just end up with a class function that returns a new bugged item rather than editing an ok item to make it bugged
18:11:00 <ddarius> dataangel: Haskell doesn't have subtyping at all.
18:11:29 <ac> is it possible to downcast a value in Haskell?
18:11:30 <dataangel> ddarius: I was thinking of deriving, but as a haskell newb I might be mentally bastardizing its semantics
18:11:49 <ddarius> ac: Again.  Haskell doesn't have subtyping at all.
18:11:56 <jfredett> dataangel: deriving /= subtyping, it has to do with typeclasses
18:11:56 <lament> subtyping <3
18:12:09 <dataangel> ddarius/ac: you could sort of look at pattern matching against union types as a form of downcasting
18:12:53 <ddarius> dataangel: You can view it as the coercions that subtyping introduces, but the whole point of subtyping is that those coercions are implicit.
18:12:56 <jfredett> ... if you squint hard enough, and tilt your head to the left...
18:12:56 <Excedrin> I was trying to construct some contrived example of something like that, but it really doesn't make sense
18:13:28 <dataangel> ddarius: true
18:13:37 <dataangel> jfredett: I understand that no state is handed down, just a guarantee about functions being defined, but that doesn't prevent defining an AddEdge function in a Polygon type class that would be inappropriate in a Square data type.
18:14:07 <mauke> you don't need typeclasses for that
18:14:22 <mauke> add x y = x - y
18:14:27 <shachaf> "pi and len2 are both Ints" -- that confused me for a moment. :-)
18:14:31 <jfredett> but you cant have a polygon type
18:14:45 <jfredett> that has square as an "instance" not in the oo sense of the word
18:14:56 <jfredett> you can have a class of types called Polygon
18:15:05 <jfredett> and a relation within those types called "addedge"
18:15:23 <jfredett> which takes a "Square" and adds an edge to produce a "Pentagon"
18:15:35 <jfredett> Polygon would be a multi paramater deal..
18:16:53 <jfredett> A square is a square, when you change a square, you get something that isn't a square- so there would be a type error for anything looking for a square. and it would break at compile time, -- I think.
18:17:18 <jfredett> bah, all this thinking makes my head hurt
18:18:25 <jfredett> mauke, add x y = x - y? methinks there is a _tiny_ problem there...
18:18:36 <jfredett> or are you leaving it for a surprise
18:18:53 <mauke> it's an inappropriate definition for an add function
18:19:12 <mauke> and the type system doesn't prevent it!
18:19:17 <jfredett> ah, helps when you read the context... :)
18:19:20 <dataangel> I began typing a response but think I should make sure I understand type classes first ;p
18:19:26 <ac> ddarius: should I ask what type families are?
18:19:30 <mauke> same for addEdge in instance Polygon Square
18:19:32 <Excedrin> should have used "add = (-)" did I spot the bug?!
18:19:50 <jfredett> ac type familys <=> type classes of power +2?
18:20:31 <ac> but type families are not a mechanism for subtyping?
18:20:32 <jfredett> mauke: doesn't that depend on the def's of polygon and square?
18:21:28 <mauke> yes
18:21:34 <jfredett> class Num numSides => Polygon (a numSides)  where ...
18:21:41 <dataangel> mauke: I was more thinking of a Polygon type class parameterized around the type of points, and a square type class also parameterized around the type of points deriving it.
18:21:45 <dataangel> b
18:21:58 <dataangel> (the points might be int/float/complex pairs, etc.)
18:22:31 <jfredett> then addEdge would return a polygon with a larger numsides bit- that might be a bad way to do it
18:23:21 <dataangel> I was just arguing that it's the same mistake conceptually, and you could make it in haskell ;p That it might be a bad way is the idea :)
18:24:25 <jfredett> dataangel: You're right, because a bad programmer can write ASM in any language, therefore, he could write a compiler for a language in ASM in which that error is possible in Haskell, and then make that error
18:24:33 <jfredett> but most of us prefer to make easier mistakes
18:24:51 <jfredett> like add = (-) and such
18:25:28 * Cale reworks his Imlib 2 binding using c2hs :)
18:25:48 <dataangel> jfredett: the point was that the same conceptual error that could be made in an OOP language could also be made in Haskell. We seem to be in agreement that Haskell is not special in this regard ;p
18:26:08 <LoganCapaldo> Haskell's type system should prevent PEBKAC errors :)
18:26:10 <dataangel> Cale: sweet :D
18:26:18 <jfredett> LoganCapaldo: that would be cool
18:26:39 <mauke> hah
18:26:48 <jfredett> It could reach out an slap you, and hten print "PEBKAC" to the REPL.
18:26:52 <Cale> Yeah, I'm also doing all the X stuff which I left out of the first one.
18:26:54 <jfredett> then*
18:27:03 <mauke> by dynamically translating programmer bugs to implementation bugs, shifting the blame
18:27:16 <mauke> see? IT'S THE MACHINE'S FAULT
18:27:21 <jfredett> mauke, brilliant!
18:27:25 <dataangel> PEBLDAH -- problem exists between language designer and humans -- I think is more common ;p
18:27:28 <Cale> dataangel: I also found a bug in Imlib 2 ;)
18:27:41 <dataangel> Cale: rasterman will have your head ;0
18:29:01 <Cale> Well, it might not be considered a bug, but it's still dumb. It turns out that merely doing create/push/pop/free on a context at the start of a program can change its behaviour.
18:29:17 <dataangel> "P
18:29:41 <Cale> If you fail to do that, then the first context created and pushed will leak all the changes made when popped back out to the original context.
18:30:00 <P_D> what's the library of choice for reading binary format files?
18:30:13 <Cale> (I noticed this when testing my withContext function ;)
18:30:20 <Cale> P_D: Binary
18:30:27 <P_D> Data.?
18:30:28 <LoganCapaldo> One with comfortable chairs?
18:30:42 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.4.1
18:30:44 <lambdabot> http://tinyurl.com/28wqy4
18:31:07 <P_D> Ok thanks.  I thought that was intended just for pickling.
18:32:03 <Cale> It contains lots of stuff which should be useful if you have to match a particular protocol.
18:34:04 * edwardk waves hello.
18:34:15 * LoganCapaldo eats edwardk's arm
18:34:26 * edwardk eeps
18:34:53 <mrd> on IRC, no one can see LoganCapaldo eat your arm
18:35:12 <edwardk> on the contrary, I think everyone here saw it
18:35:17 <LoganCapaldo> metaphorically of course
18:37:05 <P_D> odd, seems to want bytestring >= 0.9, but darcs get fps is 0.8
18:37:08 <omnId> Corun didn't see it.
18:37:23 <dcoutts> P_D: bytestring-0.9 is on hackage
18:37:34 <dcoutts> P_D: ignore the old fps package
18:38:01 <FastPackedString> Iiiignore me!
18:38:38 <P_D> ok thanks
18:38:41 <mrd> that was a weird one
18:38:47 <P_D> what's a fast way to get the current version of an installed package?
18:39:08 <mrd> ghc-pkg list
18:39:24 <mrd> if you shoot from the hip
18:39:24 <P_D> thanks
18:41:37 <LoganCapaldo> Cowboy haskell hackery
18:41:49 <edwardk> I just realized the other day that LINQ has a few more things going for it than just being a sugary comprehension syntax. C# lambdas get reified as Expression data, so you can inspect them in your LINQ provider. There is no equivalent reification mechanism in Haskell for builtin lambdas. =/
18:43:11 <edwardk> ok, well that is still just sugary comprehension syntax stuff, but still. =-)
18:43:44 <LoganCapaldo> TH?
18:43:51 <LoganCapaldo> Language.Haskell?
18:43:53 <edwardk> it just led to the first project in a long time where c# was a better language for the job than haskell
18:44:58 <edwardk> well, that and there is no good notion of grouping, etc in list comprehensions, you have to break out of the comprehension to re-sort or group, etc. (wadler and peyton-jones' paper notwithstanding)
18:48:22 <P_D> Binary is looking for two more libraries which I can't identify on hackage:  containers and array.  Pointers please?
18:49:00 <LoganCapaldo> array isn't part of ghc?
18:50:27 <P_D> Looks like the tar from hackage for binary works, just the darcs which was screwball
18:51:19 <P_D> I think it has something to do with using the stock 6.6.1 GHC release
18:52:28 <enzo> > foldr (+) 0 (zipWith (*) p q)
18:52:29 <lambdabot>   Not in scope: `q'
18:53:35 <oerjan> foldl' is probably better than foldr there
18:53:59 <kpreid> @let q = map (1 /) [1..]
18:54:01 <oerjan> (and foldl (+) 0 = sum)
18:54:04 <lambdabot> Defined.
18:54:19 <kpreid> @let p = map (^ 2) [1..]
18:54:20 <lambdabot> Defined.
18:54:24 <oerjan> @src recip
18:54:24 <lambdabot> Source not found. I am sorry.
18:54:31 <kpreid> there, now it'll work :-)
18:54:56 <oerjan> um, depends on your definition of "work"
18:54:58 <ddarius> @src Ratio recip
18:54:58 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:55:34 <omnId> one would presume recip (n :% d) = d :% n
18:57:26 <LoganCapaldo> I would presume recip (n :% d) = d % n
18:58:03 <LoganCapaldo> but I  would presume wrong likely
18:58:27 <oerjan>     recip (x:%y)        = y % x
18:58:39 <omnId> reading http://darcs.haskell.org/packages/base/GHC/, it seems your presumption is correct.
18:58:40 <lambdabot> Title: Index of /packages/base/GHC
18:59:06 <dcoutts> P_D: you're using binary 0.4.1 right?
18:59:34 <dcoutts> P_D: did you get that working with ghc-6.6.1 or still having problems?
19:00:27 <P_D> dcoutts:  Using the tar from hackage compiled and installed.
19:00:34 <omnId> LoganCapaldo: oh, right, since the denominator is nonnegative
19:00:40 <dcoutts> P_D: ok great
19:00:41 <P_D> yes, the 0.4.1 package.
19:01:18 <dcoutts> P_D: btw, we're working on a package cabal-install which does the job of downloading & installing things from hackage, including all their deps
19:01:41 <P_D> dcoutts: is it at a ready to try state?
19:01:47 <dcoutts> P_D: you might find that useful in cases like this, though note it's still got some rough edges
19:02:02 <dcoutts> P_D: it's available on hackage now
19:02:36 <P_D> that would be very valued, fumbling around in windows shells is tedious
19:02:39 <dcoutts> P_D: and we'd appreciate any feedback you have, especially bug reports
19:03:05 <dcoutts> P_D: ah, windows eh? don't bother just yet, wait for the next cabal-install release.
19:03:24 <dcoutts> P_D: the released version doesn't work on windows, the fixes are in the darcs version
19:03:41 <P_D> dcoutts:  Oh, ok.
19:05:27 <enzo> Does anyone have a link that explains how to compute definite integrals?
19:05:38 <P_D> that's a huge topic!
19:05:50 <P_D> can you narrow down what you want to do?
19:05:59 <enzo> Can I not do that or something?
19:06:43 <P_D> are you trying to do it symbolically?  numerically? deterministically?  randomly?  one dimension?  thousands?
19:07:15 <P_D> Singularities?  Rapidly oscillating functions?  Improper?
19:07:27 <enzo> I want to write a program to compute the energy needed to separate 2 charged particles
19:07:54 <enzo> so just 2 dimensions
19:08:23 <P_D> By integrating the force?
19:09:15 <P_D> so, one dimensional, improper integration.
19:09:39 <ddarius> @google Runge-Kutta
19:09:40 <lambdabot> http://en.wikipedia.org/wiki/Runge-Kutta_method
19:09:40 <lambdabot> Title: RungeKutta methods - Wikipedia, the free encyclopedia
19:09:48 <P_D> that's for differential equations
19:09:49 <enzo> int^a_b (heat capacity) (coulomb's law) wrt to r
19:10:57 <P_D> well you should start here:  http://en.wikipedia.org/wiki/Trapezoidal_rule
19:10:57 <lambdabot> Title: Trapezium rule - Wikipedia, the free encyclopedia
19:11:07 <enzo> a & b are distances between the particles, r is the magnitude
19:11:17 <ddarius> P_D: Integrating is solving a simple differential equation.
19:11:35 <ddarius> P_D: More pointedly, Runge-Kutta is for ordinary differential equations.
19:12:22 <P_D> ddarius: I agree, but you can understand why I might protest?
19:15:33 <ddarius> Oh thank God.  More Eugenia.
19:16:43 <P_D> d'oh, binary internal errors
19:16:43 <oerjan> is the heat capacity constant?  if this is simply k/r^2 then numeric integration seems a bit excessive
19:17:04 <P_D> any binary maintainers around?
19:17:24 <oerjan> enzo: ^^
19:17:51 <oerjan> the antiderivative of that is simply -k/r
19:18:38 <P_D> only broken in GHCi, works through GHC
19:18:59 <sorear> enzo: assuming you aren't doing this academically, the best solution is to google seperation energy
19:19:21 <sorear> enzo: it's kc[1]c[2] / r, btw
19:19:34 <oerjan> separation
19:19:48 <P_D> analytic solutions are for nerds
19:20:12 <oerjan> @slap P_D
19:20:12 * lambdabot secretly deletes P_D's source code
19:20:22 <Steve|Office> heh
19:20:34 <P_D> all you need to know is that the function exists!
19:20:50 <enzo> no I'm not. I'm just trying to experiment with the language
19:20:53 <sorear> P_D: and numerical solutions do not prove that!
19:20:56 <enzo> thanks though
19:21:15 <enzo> I'm going to try it using the approximation method
19:21:17 <P_D> nope, and neither does computing an integral.  you need to compute every possible integral.
19:21:21 <P_D> or, take the curl.
19:21:28 <P_D> or generalized whatever.
19:22:01 <SamB_XP> wait a minute
19:22:10 <SamB_XP> know that what function exists?
19:22:11 <P_D> enzo: There's GSL bindings to haskell, check them out.
19:22:47 <P_D> samb:  the energy, hamiltonian, invariant quantity.*
19:22:56 <sorear> P_D: well, when you apply the FTC to integral(x, x, 0, 10) you automatically know that there is an answer; if you just use a numerical quadrature procedure you have no such guarantee
19:23:40 <sorear> try numerically solving integral(1/x, x, 0, 1)
19:23:44 <sorear> you'll get nonsense
19:24:36 <SamB_XP> heh. I googled "online calender"...
19:24:42 <sorear> there are a lot of functions out there that aren't integrable (in either common sense) - and this property is not something a mere quadrature algotithm can decide
19:25:02 <SamB_XP> ... and yahoo's calendar thing came up before google's
19:25:34 <P_D> Every function is integrable where it is defined
19:25:53 <P_D> The issue is whether it matters how you compute the integral
19:26:13 <P_D> and just doing one integral doesn't tell you that
19:26:17 <P_D> is all that I am trying to say.
19:26:31 <P_D> So lay off the numerics!
19:27:13 <sorear> what about the characteristic function of a vitali set?  that's not even Lebesgue integrable, yet's it's defined on the entire real line
19:27:34 * sorear gives numerics a break and ridicules P_D's pure math
19:28:01 <P_D> Ok, you can define all sorts of extra structure if you want.
19:28:14 <enzo> I'm looking at it right now thanks :)
19:29:46 <lament> even pure math is applied :)
19:29:57 <lament> and stuff which is completely useless, is completely useless
19:46:47 <newsham> [16:25] < P_D> Every function is integrable where it is defined
19:46:55 <newsham> really?
19:47:06 <P_D> sorear gave a counterexample
19:47:36 <newsham> his example was on 1/x on 0,1.  1/x isn't defined at 0.
19:47:55 <newsham> abs x is define everywhere but not continuous at zero
19:48:11 <P_D> Abs is continuous at zero
19:48:13 <sorear> newsham: when he added the qualifier, I went to the characteristic function of a Vitali set
19:48:15 <P_D> He had a pathological example
19:48:51 <newsham> err.. blah
19:49:01 <sorear> which is defined everywhere, and discontinuous at uncountably many places
19:49:25 <newsham> yah, much better
19:50:04 <sorear> (there is no *specific* vitali set because it's an inherently nonconstructive object)
19:56:04 <brad____> is there a way to dump the default HFLAGS?
19:56:14 <brad____> as in FFI HFLAGS?
19:57:20 <brad____> and is there a way to set the HFLAGS in a cabal Setup file?
19:59:22 * wli usually uses something like f(x) = \sum_{n=0}^\infty 2^{-n} g(x-r_n) where g(x) = |csch(x)|^(1/2) and r_n is the n-th rational in some enumeration of the rationals, but that's only got countably many singularities 
20:03:16 <newsham> f(x) = 1 if x is rational 0 otherwise
20:03:35 <sorear> newsham: that's perfectly integrable
20:04:07 <sorear> newsham: infact it's the canonical example of a function that is Lebesgue integrable but not Riemann integrable
20:04:24 <newsham> what is the function where f(x) = 0 for irrational, and p if x is rational for n/p the reduced rational?
20:04:42 <sorear> popcorn function
20:05:01 <P_D> @src replicateM
20:05:01 <lambdabot> replicateM n x = sequence (replicate n x)
20:05:08 <P_D> @src replicate
20:05:08 <lambdabot> replicate n x = take n (repeat x)
20:05:13 <P_D> @src take
20:05:13 <lambdabot> take n _      | n <= 0 =  []
20:05:13 <lambdabot> take _ []              =  []
20:05:13 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
20:05:14 <sorear> http://en.wikipedia.org/wiki/Popcorn_function
20:05:15 <lambdabot> Title: Thomae's function - Wikipedia, the free encyclopedia
20:05:19 <newsham> danke
20:05:19 <P_D> earthquake, brb
20:05:52 <wli> f(x) = (1/(4*K(2^{-1/2))) \sum_{n=0}^\infty 2^{-n} |csch(x-r_n)|^(1/2) and r_n is the n-th rational has the fun property of being singular/infinite/etc. on a dense set.
20:08:16 <brad____> FEEL THAT?
20:08:29 <P_D> Yep =)
20:08:52 <Korollary> Go San Andreas
20:08:57 <newsham> location?
20:09:10 <P_D> Hasn't appeared on usgs yet
20:09:11 <Korollary> I'm guessing Bay area
20:09:11 <wli> What are our favorite methods for enumerating the rationals again?
20:09:25 <newsham> this one?  http://earthquake.usgs.gov/eqcenter/recenteqsus/Quakes/nc40204628.php
20:09:27 <lambdabot> Title: Magnitude ? (uncertain or not yet determined) - SAN FRANCISCO BAY AREA, CALIFORN ..., http://tinyurl.com/32l5vb
20:09:58 <newsham> wli: enumerate pairs of naturals?
20:10:19 <wli> There was some Stern-Brocot -based thing roconnor had.
20:10:25 <sorear> About how quickly do seismic waves travel?  1000mi/h?
20:11:00 <oerjan> wli: was that the (p1+p2)/(q1+q2) tree thing?
20:11:02 * sorear is ~500mi south of SF
20:11:06 <newsham> "Typical speeds are 330 m/s in air, 1450 m/s in water and about 5000 m/s in granite."
20:11:27 * sorear embarrasedly converts that
20:11:32 <wli> oerjan: Yeah, but it looked like some monadic thing or at least involved cycle applied to two functions.
20:11:34 <newsham> 5km/sec = ?
20:11:35 <P_D> (*2 for mph)
20:11:39 <sorear> @go 5000 meters per second in miles per hour
20:11:40 <lambdabot> 5,000 (meters per second) = 11,184.6815 miles per hour
20:12:07 <wli> That's kind of fast.
20:12:08 <sorear> oh, that's fast.
20:12:17 <P_D> granite is extremely hard
20:12:19 * sorear braces
20:12:21 <P_D> it's much slower through dirt.
20:12:31 <sorear> should be here any moment now
20:12:32 <wli> Near escape velocity or something.
20:12:39 <P_D> not quite
20:12:44 <P_D> but yeah.
20:12:52 <Korollary> You may not be able to notice it from that far
20:12:53 <sorear> good thing phonons can't radiate from the planet then
20:13:36 <P_D> what does escape velocity have to do with phonons radiating?
20:14:21 <newsham> sorear: you're in san diego?
20:14:22 <sorear> well what else would  speed of sound / escape velocity  have to do with?
20:14:26 <sorear> newsham: yup.
20:14:35 <newsham> did you evacuate for the fires?
20:15:04 <sorear> No.  San Diego is a very big place, and in the tiny bit of it I live the moon was orange.
20:15:21 <sorear> Oh, and the air smelled like burning power supplies.
20:15:35 <Korollary> amazing analogy
20:15:38 <newsham> better the air than your power supply
20:16:06 <newsham> EQ = 5.6
20:16:30 <P_D> wow.
20:17:46 <newsham> right out side of san jose near the patterson pass and mt hamilton
20:18:37 * sorear has not felt it (yet).
20:18:52 <P_D> you probably won't
20:19:00 <brad____> i live 3 miles from where the quake hit
20:19:08 <brad____> we had pictures coming off the wall
20:19:20 <brad____> we are in san jose hills, quake come from alum rock park
20:19:32 <newsham> sorear: you wouldnt feel a 5.6 50 miles away
20:19:42 <newsham> or maybe 75
20:20:00 <brad____> our whole house felt like it was riding in the back of a truck
20:20:05 <newsham> neat
20:20:22 <P_D> I'd say about 100, it was pretty mild at 45 miles.
20:20:25 <newsham> no significant damage i hope
20:20:35 <brad____> not here, except my nerves!
20:20:47 <P_D> were you here for loma prieta?
20:20:47 <brad____> but we lost some pictures on the wall
20:20:55 <brad____> no
20:20:56 <sorear> no
20:21:01 <sorear> all the monads seem dead, though.
20:21:44 <newsham> biggest i felt was the gilroy one about 4 years ago, i was in sf city.
20:21:47 <wli> Does 0 : 1 : concat [let qs = [n % d | n <- [1 .. d - 1], n `gcd` d == 1] in qs ++ map negate qs ++ map recip qs ++ map (negate . recip) qs | d :: Integer <- [1..]] seem reasonable?
20:21:54 <newsham> that was about 50 miles.
20:22:05 <newsham> i think it was in the mid 6's?
20:22:11 <wli> And/or correct?
20:22:12 <newsham> i could be wrong
20:22:16 <Korollary> newsham: I think so
20:22:26 <brad____> i recall that one newsham
20:23:04 <newsham> new construction building, swayed so much.. cat was freaking out :)
20:23:22 <sorear> wli: there's a better way, search the planet haskell archives for "enumerating the rationals"
20:23:35 <newsham> at first I didnt know what was happening, it sounded like hail was hitting the windows and I didnt notice we were moving at first
20:24:28 <wli> Jeremy Gibbons?
20:24:36 <brad____> yes in the bay area you WANT a wood framed house :)
20:24:45 <P_D> Phonons definitely don't couple to gravity
20:26:06 <brad____> okay back to boring reality
20:26:19 <newsham> this was metal + wood frame loft.  build in 2000.  it definitely knew how to move w/ the earth
20:30:55 <P_D> Binary question:  My data is little endian.  Is there a natural way to use that instead of big?
20:32:32 <newsham> Data.Binary docs say values are always encoded in network order.
20:33:01 <P_D> I was afraid that it would be intended for pickling.
20:33:31 <newsham> you could always define a newtype for little endian values and define your own Binary instances for them
20:33:47 <newsham> if you really needed to
20:34:11 * oerjan recalls from previous discussion that Data.Binary (?) has one set of functions for pickling and one set for detailed control of format, including endianness
20:34:44 <P_D> Yes, it seems there's Data.Binary.Put / Get for the latter
20:34:52 <newsham> http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html says "Values are always encoded in network order (big endian) form, and encoded data should be portable across machine endianess, word size, or compiler version"
20:34:55 <lambdabot> http://tinyurl.com/yqlto4
20:35:12 <wli> sorear: How does http://holomorphy.com/~wli/NastyFunction.lhs look?
20:36:37 <sorear> wli: that.
20:36:59 <newsham> but sure enough I see some le primitives in there.. hrmm.
20:37:10 <wli> sorear: Small translation/etc. of Jeremy Gibbons' paper but otherwise largely verbatim.
20:37:21 <P_D> newsham:  it's effectively two libraries
20:37:52 <sorear> newsham: don't confuse class Binary with data Get/data Builder
20:45:55 <wli> sorear: Okay, I've pretty much got the function series nailed down.
20:46:33 <wli> Black box integrators are useless because of all the singularities, but anyway.
20:47:33 <wli> It basically needs term-by-term analytic integration in terms of elliptic integrals.
20:51:51 <encryptio> :t mapM
20:51:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
21:00:57 <wli> I suppose it is a vaguely interesting question. How does one evaluate a function on a computer that's singular at all rationals when machine arithmetic can only represent rationals?
21:01:57 <P_D> Where do you want to evaluate it, if not at a rational?
21:02:46 <Giraph> estimate!
21:03:11 <wli> P_D: Well, if evaluated at a rational, the true answer is "Infinity" or "NaN"; so at some irrational argument is required.
21:03:44 <Giraph> blargh
21:03:45 <Giraph> i hate math
21:04:11 <wli> P_D: According to many I specialize in irrational argument, so I should at least be able to supply such even if I never come up with any method for evaluation.
21:04:15 <P_D> wli:  there are an infinite number of rationals with in any given eps of any given irrational, if each contributes finitely to the integral it seems that your'e out of luck?
21:05:35 <wli> P_D: It may very well be the case that I need to come up with some other representation to come up with an evaluation method, or maybe it's just uncomputable.
21:05:45 <P_D> why do you suspect it's finite?
21:05:52 <P_D> (anywhere)
21:08:56 <wli> P_D: I got a similar example from a book that used it as some sort of counterexample.
21:09:38 <P_D> ah, proof-by-from-a-book =)
21:10:10 <wli> Frank Jones, "Lebesgue Integration on Euclidean Space" or similar.
21:11:53 <wli> P_D: Well, the counterexample stuck. The proof I barely remember the details of. If I remember right he went backward to prove that the series converged from the fact its integral did or something highly unusual like that.
21:12:31 <P_D> I know nothing about real analysis
21:12:35 <wli> P_D: With the usual "almost everywhere" caveats.
21:13:31 <P_D> not useful for the rea- complex world.
21:13:59 <wli> P_D: Beg pardon?
21:14:09 <P_D> well, please educate me.
21:14:30 <wli> P_D: I don't mean to be dense, but about what?
21:14:47 <P_D> Real analysis in physics
21:16:44 <wli> I don't believe it comes up until physics gets sufficiently advanced to be beyond me.
21:22:24 <wli> AIUI it's partly because the assumptions on many of the functions being dealt with required for them to represent physically meaningful trajectories/etc. are so strong that very strong results typically hold until nonclassical affairs enter the picture.
21:24:35 <P_D> classical is your only hope for real analysis
21:24:38 <wli> My own knowledge of the subject is very limited, essentially to a rather superficial subset of classical mechanics.
21:25:03 <P_D> classical mechanics is pretty much your only hope.  anything field -> complex / meromorphic.
21:26:17 <wli> P_D: What little I understand of where real analysis enters the picture suggests that the nontrivial applications are in statistical mechanics, where both the math and physics are far beyond me.
21:26:50 <P_D> Mm I don't think so
21:27:19 <P_D> statistical mechanics is built on the partition function, which is meromorphic
21:27:45 <P_D> e.g. people have studied riemann zeta in terms of stat mech
21:28:31 <wli> P_D: I'm totally limited to bonehead affairs that can be knocked down with the calculus of variations and assuming everything is far beyond smooth. About all I know is "Malliavin calculus blows me away, and so do physical things phrased in terms of probability distributions."
21:29:23 <sorear> wli: You can handle it symbolically
21:29:38 <P_D> ah, for stochastic diff eqs
21:29:44 <nburlett> hey all, anyone install ghc on Leopard?
21:30:24 <P_D> Cool, thanks.
21:30:58 <wli> sorear: Yeah, it call boils down to F((t+1)/sqrt(2),1/sqrt(2)) and K(1/sqrt(2))
21:35:33 <wli> sorear: Or do you mean analytic summation?
21:36:29 <sorear> Actually I was thinking in terms of a proof-verification approach.  You don't say "F(1) = ?" and get 2, you say "F(1) = 2" and get "Yes".
21:43:29 <wli> sorear: My current plot was to use some limit extrapolation process on the partial sums.
21:52:31 <araujo> http://dev.gentoo.org/~araujo/himerge.png
21:54:53 <wli> sorear: I don't see obvious stopping criteria for inclusion of partial sum terms.
21:56:52 <wli> sorear: Nor obvious parameters to extrapolate on apart from the number of terms included.
22:00:59 <hpaste>  dataangel pasted "I must be missing something obvious here" at http://hpaste.org/3556
22:01:50 <TSC> Do you want a type alias or a new type?
22:02:39 <Korollary> newsham: http://www.cnn.com/2007/US/10/30/california.quake/index.html
22:02:40 <lambdabot> Title: Quake with 5.6 preliminary magnitude hits Northern California - CNN.com
22:02:42 <TSC> If alias, "data" => "type"; if new type, it needs a data constructor
22:03:06 * dataangel reminds himself to actually connect to IRC before using hpaste
22:03:14 <TSC> Oh
22:03:16 <TSC> Do you want a type alias or a new type?
22:03:18 <TSC> If alias, "data" => "type"; if new type, it needs a data constructor
22:03:29 <TSC> (I didn't notice you were absent (: )
22:03:45 <araujo> dataangel, uff, everyone already explained your problem, you got late
22:03:47 <araujo> :-)
22:03:52 <dataangel> sorry :P
22:03:59 <shapr> @users
22:03:59 <lambdabot> Maximum users seen in #haskell: 424, currently: 372 (87.7%), active: 10 (2.7%)
22:04:19 <dataangel> Is an alias still a distinct type or is it a synonym?
22:04:25 <TSC> synonym
22:04:32 <dataangel> Guess I need a constructor then :)
22:04:53 <dataangel> ah that worked :)
22:05:34 <araujo> it is a synonym
22:06:40 <dataangel> upon further reflection, DFA start states and end states can have transitions too
22:06:59 <dataangel> so I can either be massively redundant
22:07:07 <shachaf> dataangel: You don't need to use a tuple if you have your own constructor, by the way.
22:07:12 <dataangel> data Dfa a = StartState [Transition a] | EndState [Transition a] | State [Transition a]
22:07:28 <dataangel> shachaf: good point :)
22:07:41 <dataangel> or I guess I could tag each state
22:09:52 <dataangel> data State a = State | StartState | EndState
22:09:53 <dataangel> data Dfa a = Dfa State [Transition a]
22:10:29 <dataangel> err, data Dfa a = Dfa State a [Transition a]
22:11:08 <wli> I'm still trying to figure out what type system to use for my toy language.
22:11:19 <Pseudonym> Hindley-Milner, duh.
22:11:24 <Pseudonym> What else is there?
22:11:31 <Pseudonym> Apart from HM with extensions.
22:11:38 <encryptio> dynamic (none)
22:11:47 <Pseudonym> That's not a type system, it's a joke.
22:11:48 <encryptio> and crappy restrictive type systems.
22:12:13 <wli> Pseudonym: Basically I'm blithering on about which extensions to use. I've got things phrased relative to H98.
22:12:28 <wli> Pseudonym: Like H98 - MR + MPTC + FD
22:14:44 <wli> Pseudonym: The general thrust is to try to get enough to support the code structure of the MTL (Monad Transformer Library) with the least machinery possible, esp. avoiding research problems or things not so fully specified as to require ingenuity to implement.
22:15:50 <dons> a typical galois workspace, http://haskell.org/haskellwiki/Image:Screen-triplehead-galois.jpg :)
22:15:55 <lambdabot> Title: Image:Screen-triplehead-galois.jpg - HaskellWiki
22:16:47 <wli> dons: Very slick.
22:18:22 <wli> Pseudonym: The motive here is to have enough of a language to do software engineering experiments in the interpreted language while leaving the term language minimalistic enough to focus on the module system vs. the term language itself.
22:18:28 <Pseudonym> Right.
22:18:37 <Pseudonym> Sounds fun.
22:20:33 <wli> Pseudonym: I think it may be too much to take on because the MTL-like library structure (or monad transformer stacks in general) may require features too advanced or insufficiently well-understood to meet the requirements. It's also looking like getting module systems (at least ones of any utility) to mix with typeclasses is over my head, too.
22:20:56 <Pseudonym> Module systems are harder than they look.
22:21:00 <Pseudonym> This is true.
22:21:08 <wli> The fact I have to go hunting like this suggests it's over my head period.
22:21:14 <Pseudonym> Just look at how wrong Haskell's is!
22:23:32 * dataangel keeps having trouble reading haskell type signatures because of the single letter names >_<
22:25:50 <merus> dons: That keyboard is sexy, I want.
22:26:43 <sorear> oh man my vision isn't working right today, I was about to ask if that stuffed penguin was Don
22:26:53 <sorear> ... stuffed penguin!?
22:27:06 * sorear does a double take
22:29:40 <dons> that's glguy's desk actually :)
22:30:26 <wli> I've been underachieving a bit too badly lately to ask for things like decent monitors/etc.
22:31:17 <sorear> dons: so glguy is one of those evil penguin people?
22:31:38 <dons> heh i hear he has openbsd disks somewhere, but there's a lot of penguins around galois
22:32:15 * glguy_ tried installing OpenBSD first
22:32:16 <wli> Soon to be House?
22:32:20 <glguy_> it failed the boot process
22:33:18 * Pseudonym is curious why the penguin is considered evil when the alternative is a red imp with a pitchfork
22:33:39 <dataangel> How do I put typeclass constraints on types in a data declaration? data Foo (Eq a) = ... -- doesn't seem to work
22:33:42 <glguy_> Pseudonym: the alternative is a friendly yellow puffer fish
22:33:57 <Pseudonym> Poisonous.
22:34:47 <Pseudonym> We have a bunch of fairy penguins down in our part of the world, and trust me, they're not evil.
22:35:01 <Pseudonym> You could probably step on them accidentally, if their habitat wasn't fenced off.
22:35:39 * wli might go for something like a Haast's eagle even though they're extinct.
22:35:52 <wli> (That is, if I were picking logos.)
22:38:46 <dataangel> > data Test (Eq a) => a = Test a
22:38:46 <lambdabot>  Parse error at "data" (column 1)
22:39:04 <dataangel> >data Test (Eq a) = Test a
22:39:08 <dataangel> > data Test (Eq a) = Test a
22:39:08 <lambdabot>  Parse error at "data" (column 1)
22:39:53 <shachaf> dataangel: Never mind that it's a syntax error, lambdabot only evaluates expressions.
22:40:22 <dataangel> ah
22:40:28 <dataangel> ghci still gives "Type found where type variable expected"
22:41:57 <sorear> you want data Eq a => Test a = Test a
22:42:04 <dfranke_> I think I need to commit seppuku for writing this line.
22:42:06 <dfranke_>  do s <- (sequence [identifierStart >>= (return . (:[])), many identifierPart]) >>= (return . concatMap id)
22:42:12 <sorear> but rethink
22:42:37 <dataangel> wtf, deriving only works for a few builtin type classes? @_@
22:42:43 <sorear> of course
22:42:54 <shachaf> concatMap id is just concat, no?
22:42:55 <dmwit> dfranke_: There are only two elements in your sequenced list?
22:43:07 <dmwit> Why not just sequence them with (>>=)?
22:43:26 <dfranke_> shachaf: ah, right.
22:43:28 <sorear> dfranke_: liftM2 (:) identifierStart (many ident)
22:43:31 <wli> You'd have to define new derivable classes by induction on the structure of types.
22:43:54 <sorear> but that was a fun de-obfuscation task, thanks
22:44:09 <wli> I've seen things that accomplish that in ways that seem utterly bizarre to me.
22:44:46 <goalieca> @src concat
22:44:46 <lambdabot> concat = foldr (++) []
22:45:07 <goalieca> @src maximum
22:45:08 <lambdabot> maximum [] = undefined
22:45:08 <lambdabot> maximum xs = foldl1 max xs
22:45:10 <dfranke_> sorear: thank you.
22:45:42 <wli> Stuff like gmapQ etc.
22:59:26 <wli> Actually it took a combination of 5 large ones, only one of which was unexpected.
23:00:21 <wli> I'm not actually sure. I'm on direct deposit and there is typically a day or two worth of skew between different banks for unknown reasons.
23:01:11 <wli> Sorry.
23:18:48 <adaptable> Hutton's book is a common reference at Galois?
23:20:27 <Pseudonym> Don't be silly.  They don't read books at Galois.
23:20:38 <Pseudonym> Not paper ones, anyway.
23:20:44 <Pseudonym> At best, they write them.
23:30:21 <shachaf> adaptable: Are you referring to the xmonad screenshot?
23:30:38 <shachaf> adaptable: I was wondering about that one.
23:35:04 <glguy> adaptable: I put that on my desk as a prop
23:35:17 <glguy> adaptable: the penguin doesn't type on the keyboard either
23:45:15 <omnId> @quote
23:45:16 <lambdabot> erg0t says: <erg0t> sebazzz, me plagias mi vida
