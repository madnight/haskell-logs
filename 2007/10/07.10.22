00:39:12 <ketil> Morning!
00:39:29 <oerjan> morn morn
00:39:53 <ketil> I have a problem.
00:40:11 <ketil> I'm unable to B.readFile a file that is 200Mbytes.
00:40:35 <oerjan> strict or lazy ByteString?
00:40:39 <ketil> Heap usage grows to thrash on my 2Gb computer, and limiting the heap via RTS options to 500Mb makes it fail.
00:40:43 <ketil> strict.
00:41:04 <oerjan> for a start try lazy instead
00:41:23 <ketil> So there is a bug in Strict, then?
00:41:32 <Jonathan`> q
00:41:40 <Jonathan`> bye
00:41:45 <oerjan> not that i know, but lazy will try to keep less in memory at one time
00:42:32 <ttfh> is there somewhere I can read up on the motivation behind ByteString?
00:42:51 <ketil> oerjan, well - my real problem is that I can't parse large files with HXT, it leaks (:)s - which I presume come from Strings.  I tried to use a strict bs to at least avoid the 24-byte overhead pr char.
00:42:59 <ketil> ..but perhaps lazy will work as well.
00:43:31 <ketil> ttfh, Strings-as-lists are ridiculously expensive in terms of memory, BS implements strings as arrays of Char.
00:43:38 <ketil> A bit less flexible, a lot more efficient.
00:43:47 <ketil> Faster, too.
00:44:16 <ttfh> ketil: Yes, I'm with you so far
00:45:16 <ttfh> but is there a paper or something on the design of ByteString?
00:45:27 <oerjan> yes
00:46:12 <ketil> ttfh, a couple, I think?  Google?  Search for Don Stewart and ByteString.
00:47:12 <ttfh> found it
00:47:20 <ttfh> Don Stewart = dons?
00:47:43 <oerjan> hm, the ByteString library page actually does _not_ link to a paper, afai can tell
00:48:37 <ttfh> One thing on my mind is: how is the lazy butestring lazy?
00:48:46 <ttfh> bytestring...
00:48:56 <oerjan> it is implemented as a list of strict ones
00:49:06 <oerjan> in chunks
00:49:23 <ttfh> and what determines the size of the chunks?
00:50:16 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString-Lazy.html
00:50:18 <lambdabot> http://tinyurl.com/244l36
00:50:29 <oerjan> "The default chunk size is 64k, which should be good in most circumstances. For people with large L2 caches, you may want to increase this to fit your cache."
00:51:31 <ttfh> so you get to keep the cake and eat it
01:03:48 <raxas> is frag dead? it is broken on 64bit and nothing has changed in code for 3 month at least
01:04:18 <ketil> oerjan, funny - it works if I set +M800M.  Guess I need to investigate a bit more before complaining too loudly.
01:06:38 <oerjan> i guess laziness doesn't help if HXT needs to parse the whole (xml?) at once
01:06:52 <sjanssen> ketil: you might need roughly 2 times as much heap as the file you're reading
01:21:25 <dcoutts> g'morning bringert
01:21:26 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
01:21:35 <bringert> morning dcoutts
01:22:05 <dcoutts> bringert: so as you probably noticed I released http, unix-compat and tar
01:22:17 <dcoutts> and cabal-install
01:22:35 <bringert> dcoutts: excellent
01:23:20 <dcoutts> ttfh: the size of the chunks is hard coded into the producers
01:23:42 <bringert> dcoutts: oh, could you release htar while you're at it?
01:23:53 <dcoutts> bringert: oh, does it need it?
01:24:11 <bringert> dcoutts: no, nothing needs it. it just seems nice to relase that along with tar
01:24:29 <aleator> Hey, dcoutts, How should you convert CDouble to Double? realToFrac?
01:24:35 <bringert> dcoutts: oh, you mean that it should just work as it is?
01:24:41 <dcoutts> bringert: ah, it might need it, looks like it specifies exactly tar ==0.1
01:24:56 <bringert> dcoutts: yeah, and it seems to use Distribution.Setup
01:25:10 <bringert> eh
01:25:11 <dcoutts> bringert: where does it's repo live?
01:25:12 <bringert> no
01:25:18 <bringert> dcoutts: inside the tar reapo
01:25:20 <bringert> repo
01:25:22 <dcoutts> aleator: right
01:25:27 <dcoutts> bringert: oh ok :-)
01:25:28 <aleator> dcoutts: Thanks!
01:26:19 <bringert> dcoutts: it probably needs configurations to build on 6.8
01:26:24 <dcoutts> bringert: and could I change it to depend on either zlib || compression  :-)
01:26:27 <dcoutts> bringert: right ok
01:26:32 <bringert> that would be great
01:27:20 <bringert> dcoutts: maybe cabal-install should do that too?
01:27:28 <dcoutts> bringert: aye
01:27:45 <dcoutts> bringert: and I need to test cabal-install with zlib on windows
01:28:05 * bringert does "cabal --global install cabal-install"
01:28:19 * bringert forgets sudo
01:28:21 <profmakx> hmpf. anyone here familiar with happs?
01:28:34 <dcoutts> bringert: heh, I was just about to say that :-)
01:28:56 <dcoutts> profmakx: ask Lemmih, shapr and Igloo
01:29:00 <bringert> dcoutts: it would be so nice if we could do something about that
01:29:24 <bringert> cabal-install can upgrade itself. this is so cool
01:29:28 <profmakx> hm, I posted my question in #happs. So I`ll just wait :)
01:29:29 <dcoutts> bringert: what, error out immediately when we don't have enough permissions?
01:29:39 <bringert> dcoutts: or call sudo
01:29:48 <dcoutts> bringert: mm
01:30:15 <dcoutts> bringert: I think we should ask people on one mailing list or other what behaviour they expect
01:30:16 <bringert> dcoutts: it could be a config flag. I think some linux tools have a "use this command as a root wrapper" option
01:30:27 <dcoutts> bringert: they do, yes
01:30:32 <bringert> dcoutts: apt-get fails if you are not root
01:30:45 <dcoutts> bringert: gentoo's emerge similarly
01:30:56 <bringert> dcoutts: it would be nice to fail straight away, instead of after building for minutes
01:31:02 <dcoutts> bringert: yes
01:31:05 <bringert> dcoutts: especially since the build dir is not saved
01:31:24 <dcoutts> bringert: which we might want to think about too
01:31:28 <bringert> yeah
01:31:47 <bringert> dcoutts: there should be a --tmpdir flag btw
01:31:50 <dcoutts> bringert: eg testing the writeabilty of the package.conf file and/or writability of the selected install directories
01:32:07 <bringert> dcoutts: we cannot know where the package.conf file lives
01:32:25 <dcoutts> bringert: well, we do really, it's just that perhaps we should not
01:32:33 <allbery_b> cpan keeps build dirs in a .cpan directory, you can specify a save size beyond which trees are pruned oldest-first on startup
01:32:34 <allbery_b> works well
01:32:36 <dcoutts> bringert: aye, I think the building should also be done under .cabal/somewhere
01:32:46 <allbery_b> (as does symlinking .cpan into /tmp)
01:32:59 <bringert> dcoutts: we could register a dummy package and then remove it. but it's not very nice
01:33:22 <dcoutts> bringert: we could modify ghc-pkg to be able to ask the question
01:33:44 <bringert> dcoutts: but that would only work for 6.8+, if we are very quick
01:33:55 <dcoutts> bringert: I'm not thinking of 6.8 I guess
01:34:00 <bringert> but it seems like the right thing to do
01:34:11 <dcoutts> bringert: in the mean time we can parse ghc-pkg list output
01:34:20 <dcoutts> which gives the package file paths
01:34:23 <bringert> heh
01:34:25 <bringert> yeah
01:34:34 <bringert> anyway, we can hide all of that in Cabal
01:34:38 <dcoutts> right
01:35:00 <bringert> what if package.conf is writable, but $prefix is not?
01:35:08 <dcoutts> they all need to be writable
01:35:18 <dcoutts> if any is not, it's an error
01:35:23 <dcoutts> not just $prefix
01:35:29 <dcoutts> but also libdir, etc etc
01:35:37 <bringert> we could also check just $prefix, to avoid messing with ghc-pkg. that would catch most cases I think
01:35:51 <dcoutts> in fact, not prefix, that's not necessary. only dirs where we create things
01:35:53 <bringert> right, I mean just check the dirs, not ghc-pkg
01:36:14 <dcoutts> bringert: people forget, they use --prefix=$HOME but forget --user
01:36:20 <bringert> true
01:36:53 <bringert> though you really mostly just need --user now that we set the prefix automatically
01:37:03 <dcoutts> yes, which is good
01:37:20 <dcoutts> --user should mean "do a user install", not "use the user package registration"
01:37:25 <dcoutts> that's a silly detail
01:37:58 <dcoutts> --user / --global is a simple thing to want to do and it should determine the default paths and package db
01:38:19 <dcoutts> in the Cabal lib itself I think, as well as in cabal-install prog
01:38:28 <bringert> one remaining problem is with --user installs of executables, now the go in .cabal/bin, which won't be in the user's path, and they don't know where to find it
01:40:58 <dcoutts> bringert: ah yes, so we need to symlink into $HOME/bin
01:41:15 <bringert> hmm
01:41:16 <dcoutts> bringert: but if we symlink and where we symlink to need to be configurable
01:41:33 <allbery_b> or at minimum tell the user to add $HOME/.cabal/bin to $PATH (or symlink .cabal/bin to ther preferred bin directory
01:41:48 <dcoutts> bringert: and by default we'd do that, but people could configure it to not do so and people could add .cabal/bin to their path
01:41:53 <dcoutts> if they prefer that
01:41:55 <allbery_b> (I'd kinda prefer that, or at least a way to tell cabal where to put user binaries)
01:42:00 <bringert> dcoutts: maybe we could set --bindir to $HOME/bin, and keep everything else in .cabal?
01:42:15 <allbery_b> because my $HOME is in AFS and is cross-platform, so per-arch bins go in ~/.bin/@SYS
01:42:42 <allbery_b> (~/bin is scripts and such and intended for quasipublic stuff)
01:43:05 <dcoutts> allbery_b: it's only a default, and it's a default that would work for most people
01:43:27 <allbery_b> yeh
01:43:28 <dcoutts> allbery_b: and it needs to be clear that's what it'll do so people who do not want that can change it
01:43:32 <dcoutts> bringert: aye, perhaps
01:43:43 <allbery_b> as long as I can tell cabal that's not what I need
01:43:58 <dcoutts> bringert: it worries me a bit
01:44:26 <dcoutts> bringert: if we symlink ourselves we can not overwrite existing things in ~/bin
01:44:59 <bringert> dcoutts: true
01:45:00 <dcoutts> bringert: it'd also enable us to do something about having multiple versions of the same binary installed
01:45:09 <bringert> dcoutts: bu we can't symlink on windows
01:45:21 <dcoutts> bringert: yes, we'd have to use a different default config there
01:45:33 <dcoutts> bringert: they've got no ~/bin anyway
01:45:56 <dcoutts> bringert: so we might as well let people just change their paths to put ~/.cabal/bin on their path
01:46:19 <dcoutts> for windows I mean
01:47:35 <bringert> dcoutts: any time we install an executable, we should print a message telling them that
01:48:11 <dcoutts> bringert: telling them if it's not on their path and we made no symlink to somewhere that is on the path
01:48:42 <dcoutts> bringert: if we did install it somewhere on the path I don't think any message is necessary
01:49:02 <bringert> dcoutts: true. that should be easy to check
01:52:01 <dcoutts> bringert: the most pressing concern imho is unifying the cabal-setup/cabal-install command line UI
01:52:34 <dcoutts> it looks like it ought to be nicely composable
01:52:57 <dcoutts> we just want to extend the cabal-setup command line ui with a couple extra bits...
01:57:01 <bringert> dcoutts: I agree
02:14:37 <ketil> Anybody parse sizeable data in XML format with Haskell?
02:15:05 <ketil> Or - is one of the available libraries (HaXml, HXT, ...) better than others?
02:19:04 <ketil> I've done manual chunking of XML-files, but even so, HXT chokes on a single 25000-line XML element.
02:19:35 <ketil> I can break it up further, but perhaps I should just drop the whole XML thing, and just parse it manually?
02:21:55 <quicksilver> I would submit a bit report on HXT?
02:26:40 * EvilTerran wishes {< n} were acceptable syntax in maths (naive set theory, in particular)
02:27:10 <EvilTerran> { i | i < n } is just so verbose in comparison...
02:27:26 <osfameron> curried sets!
02:27:37 <osfameron> er, sectioned sets
02:28:40 <EvilTerran> seeing as a subset of S could be considered a :: S -> Bool, and from that view { x | ... } would be rather similar to (\x -> ...), it would kinda make sense
02:28:54 <EvilTerran> *considered a function :: S -> Bool
02:31:35 <EvilTerran> although i guess i'm muddying the difference between a set S and (\in S)
02:32:16 <quicksilver> EvilTerran: the great thing about maths is people can choose their own syntax :P
02:32:28 <quicksilver> EvilTerran: I have seen syntax much like you describe
02:32:50 <quicksilver> usually S^{<n}  (^ denoting superscript)
02:33:02 <quicksilver> or even with the superscript on the left of the S
02:33:04 <EvilTerran> i frequently generalise {x \in S | ...} to another infix op in place of \in, when the base superset is obvious
02:33:20 <EvilTerran> in which case that one would be {x < n}
02:33:38 <EvilTerran> but that feels sloppier to me
02:34:22 <EvilTerran> quicksilver, hm, i guess that's kinda like Z^{+}
02:35:08 <EvilTerran> are your curlies in S^{<n} literal, or just tex-y grouping?
02:35:18 <EvilTerran> (mine were tex-y)
02:37:12 <quicksilver> grouping
02:37:42 <quicksilver> and I'm pretty sure I've seen S^f, where f :: S -> Bool
02:37:49 <quicksilver> exactly as you suggested
02:37:55 <EvilTerran> hooray
02:56:46 <phlpp> hi
02:57:20 <roconnor> hi
02:57:46 <oerjan> if you identify relations with multiple valued functions, then {x | x < n} = (<)^(-1){n}
02:58:30 <roconnor> (<)^(1) == (>) ?
02:58:33 <roconnor> er
02:58:34 <roconnor> (<)^(-1) == (>) ?
02:58:36 <oerjan> no
02:59:17 <oerjan> R^(-1)(M) = {x | \exists y \in M, x R y}
02:59:44 <oerjan> um...
02:59:53 <oerjan> i guess you are right
03:00:00 <roconnor> :)
03:00:33 <oerjan> given R(M) = {y | \exists x \in M, x R y}
03:11:39 <geocalc> > getEnvironment
03:11:41 <lambdabot>   Not in scope: `getEnvironment'
03:11:49 <mux> :t getEnv
03:11:51 <lambdabot> Not in scope: `getEnv'
03:11:58 <mux> @index getEnv
03:11:58 <lambdabot> System.Environment, System.Posix.Env, System.Posix
03:12:09 <oerjan> :t System.Environment.getEnv
03:12:11 <lambdabot> String -> IO String
03:12:57 <geocalc> :t getEnvironment
03:12:59 <lambdabot> Not in scope: `getEnvironment'
03:13:20 <geocalc> hoho
03:13:35 <oerjan> @index getEnvironment
03:13:36 <lambdabot> System.Environment, System.Posix.Env, System.Posix
03:13:44 <oerjan> :t System.Environment.getEnvironment
03:13:45 <lambdabot> IO [(String, String)]
03:14:00 <geocalc> mmh
03:15:38 <oerjan> getEnvironment seems to be a new addition
03:16:42 <oerjan> presumably it gives a list of key -> value pairs
03:16:51 <geocalc> i'm new too ;)
03:17:31 <geocalc> long list yeah
03:17:42 <oerjan> :t \k -> fromJust . lookup k =<< System.Environment.getEnvironment
03:17:44 <lambdabot>     Couldn't match expected type `IO' against inferred type `[]'
03:17:44 <lambdabot>       Expected type: IO [(String, IO b)]
03:18:17 <oerjan> :t \k -> return . fromJust . lookup k =<< System.Environment.getEnvironment
03:18:19 <lambdabot> String -> IO String
03:18:36 <oerjan> and getEnv would be essentially that
03:19:05 <oerjan> :t \k -> liftM (fromJust . lookup k) System.Environment.getEnvironment -- bit shorter
03:19:07 <lambdabot> String -> IO String
03:20:07 <geocalc> i look at ghc sources now
03:21:52 <geocalc> missing cplusplus in foreign
03:24:49 <bparkis> what is a good data structure for a dictionary for a program that plays hangman?  given a word ___a___b__ i want to find all words that match that pattern
03:25:41 <geocalc> take a db
03:26:13 <ricky_clarkson> List[String] will usually be fast enough.
03:26:13 <kjdf> is there a standard function to a split string by given character (or string or regexp), like this: foo "a,,bc" = ["a", "", "bc"] ?
03:26:28 <bparkis> i'm looking for something quick and dirty that nonetheless will give a second or two for a full sized english dictionary
03:27:01 <bparkis> a full sized dictionary has like 2 million words, i want an appreciable portion of that
03:27:37 <geocalc> a db : sql or what ever
03:27:49 <bparkis> one obvious thing is to store them in a hash map from word length to possible words, then iterate through that
03:28:10 <quicksilver> you can't do any better than a List if you plan to iterate through the whole thing
03:28:19 <bparkis> i don't plan to iterate through the whole thing
03:28:24 <bparkis> i want to go through as little as possible
03:28:34 <quicksilver> 'as little as possible' would involve an index
03:28:41 <quicksilver> (substring index)
03:28:48 <quicksilver> but of course substring indices are massive
03:29:20 <quicksilver> if you just want to trim by word length then just a list of lists would suffice
03:30:03 <bparkis> i want to trim by as much as i can
03:30:19 <quicksilver> kjdf: no
03:30:36 <bparkis> i'm not just looking for a contiguous substring either
03:30:41 <bparkis> the characters can be far apart
03:31:09 <quicksilver> I know
03:31:26 <quicksilver> you form an index lookup by all suffixes
03:31:42 <quicksilver> but, the index is O(number of words * average word length)
03:31:55 <quicksilver> and it's not normally worth the hassle it takes to build it :)
03:32:00 <bparkis> that's ok, i mean i have to store the dictionary in the first place
03:32:05 <bparkis> which is that length
03:32:15 <geocalc> a db
03:32:18 <quicksilver> no, this is another word length factor longer
03:32:27 <quicksilver> geocalc: SQL is not well suited to this either
03:32:38 <bparkis> number of words * average word length = total # of characters in the dictionary
03:32:41 <quicksilver> geocalc: of course, a few DBS have 'full text index' extensions
03:32:49 <quicksilver> bparkis: right, it's another 'average world length' factor bigger
03:33:01 <quicksilver> bparkis: because you store each word as all its suffixes
03:33:04 <geocalc> plenty of db in hackage ;)
03:33:11 <bparkis> and what does that get me?
03:33:20 <quicksilver> bparkis: fast substring matching
03:33:30 <quicksilver> but I very much doubt it's worth it
03:33:43 <bparkis> well 2 million words is only a few megs and i have 2gb memory on this laptop
03:33:49 <quicksilver> e.g. elephant appears as 'elephant', 'lephant', 'ephant', 'phant', 'hant', etc
03:33:54 <quicksilver> right
03:34:10 <quicksilver> but because 2 million words is only a few megs, it's perfectly sensible just to scan through them
03:34:13 <quicksilver> :P
03:34:22 <bparkis> how long would you estimate that might take?
03:34:37 <bparkis> i really want just a few seconds response time
03:34:52 <quicksilver> should be under 10 ms
03:35:01 <bparkis> hm ok i'll give it a shot
03:40:07 <jedbrown>  time grep '^...a...b..' /usr/share/dict/words > /dev/null
03:40:07 <jedbrown>  
03:40:07 <jedbrown> real    0m0.136s
03:40:07 <jedbrown> user    0m0.120s
03:40:07 <oerjan> quicksilver: but storing elephant, lephant etc. would only help with _consecutive_ substrings, right?
03:40:10 <jedbrown> sys     0m0.004s
03:40:13 <jedbrown>  
03:40:21 <jedbrown> And my machine isn't fast
03:41:14 <osfameron> you'd only need to go through words of the appropriate length wouldn't you?
03:42:02 <bparkis> a tenth of a second or thereabouts is fine for my purposes
03:42:09 <bparkis> i only have to beat a human :)
03:42:22 <bparkis> although this is just one part of doing that
03:42:49 <bparkis> i'm trying to make a trivia answer bot and spoil everyone's fun
03:42:57 <ricky_clarkson> bparkis: Then you'll need some kind of bias towards common words to win.
04:23:31 <matveev_> @src init
04:23:31 <lambdabot> init [x]    = []
04:23:32 <lambdabot> init (x:xs) = x : init xs
04:23:32 <lambdabot> init []     = undefined
04:24:18 <ketil> @seen ndm
04:24:18 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 11h 51m 40s ago, and .
04:24:52 <profmakx>  who is the maintainer of Network?
04:29:56 <mux> poor hpaste is having a lot of problems saving my paste
04:32:02 <EvilTerran> have you given it your name and a title? i think there's some anti-spam measures that you might be tripping or something
04:32:14 <mux> yeah, I've given my name and a title as usual
04:32:23 <EvilTerran> meh.
04:32:24 <mux> it's just freezing after I click on save
04:32:29 <allbery_b> over 4k?
04:32:48 <mux> no, far from it
04:33:23 <mux> it's 1073 bytes
04:36:00 <mux> http://paste.lisp.org/display/49612
04:36:18 <mux> finite lists as functions, fun :)
04:36:25 <mux> and with O(1) append, even!
04:37:36 <mux> I used to implement it using another representation; each list was representing by a Natural -> Maybe a function, with Nothing meaning we're past the end of the list, but that made append hard to implement efficiently
04:37:47 <mux> s/representing/represented/ damnit
04:38:45 <mux> I doubt this has any real usefulness though
04:42:02 <byorgey> mux: neat =)
04:42:09 <vincenz> the problem is the space bloat
04:42:51 <mux> right, at some point I guess the list will be represented by a huge function
04:43:10 <vincenz> right and tailing doesn't GC any part of it
04:43:13 <mux> but mathematical sequences can be quite compact
04:43:57 <mux> ohoh, hpaste.org finally answered with a proxy error
04:48:23 <mux> anyways, this was a lot of fun to implement
04:51:28 <roconnor> How did the haskell.org wiki get to be organized?
04:51:37 <phlpp> > digitToInt "512"
04:51:38 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
04:51:45 <phlpp> > map digitToInt "512"
04:51:46 <lambdabot>  [5,1,2]
04:52:01 <phlpp> > filter odd $ map digitToInt "512"
04:52:02 <lambdabot>  [5,1]
04:52:30 <phlpp> ah.
04:54:43 <phlpp> is it possible, when given: \x -> x + (read $ reverse $ show x) that only numbers whose reverse has no leading zeroes are 'calculated'?
04:55:30 <phlpp> so (\x -> x + (read $ reverse $ show x) 500 should not returna value (or at least a "even"  value because all evens are dropped in the end) because 500 reversed == 005
04:55:50 <mux> \x -> x + (read . dropWhile (== '0') . reverse . show $ x) ?
04:56:15 <mux> > let foo x = x + (read . dropWhile (== '0') . reverse . show $ x) in foo 500
04:56:17 <lambdabot>  505
04:56:27 <TSC> Which Project Euler problem are you doing?
04:56:40 <phlpp> TSC: i don't want a solution
04:56:47 <phlpp> http://projecteuler.net/index.php?section=problems&id=145
04:56:49 <mux> is this doing what you were asking for?
04:56:49 <lambdabot> Title: Project Euler
04:56:57 <phlpp> mux: hm, but i think that's not what i want
04:57:08 <phlpp> because my version also puts 505 for 500 without dropping zeroes
04:57:11 <mux> I'm not sure I understood your correctly, so I wouldn't be surprised :)
04:57:18 <phlpp> but as i understood the task numbers like 500 produce 005 reversed
04:57:29 <phlpp> and so this numbers musn't be calculated
04:57:34 <TSC> Could you simply exclude numbers ending in zero?
04:57:34 <mux> but in any case 500 + 005 == 500 + 5
04:57:56 <phlpp> yeah, but for me the task reads like "drop such numbers like 500"
04:58:09 <TSC> Yeah, that's right
04:58:09 <mux> so in the end I should just return 500?
04:58:24 <phlpp> hm, wait. my code reads like:
04:58:46 <phlpp> filter odd$ map (\x -> x + (read $ reverse $ show x)) [1..10]
04:58:52 <TSC> If you have a function "reversible :: Integer -> Bool", start it off with "reversible n = doesNotEndinZero n && ..."
04:59:09 <phlpp> but in the numbers from 1..10 there is NO odd number produced by x + reverse x
04:59:16 <phlpp> because numbers like 10 should be excluded
04:59:25 <phlpp> because when reversing 10 i get 01 -> leading zero -> not allowed
04:59:45 <mux> so in that case we don't sum anything?
04:59:49 <phlpp> yup
04:59:49 <phlpp> !
04:59:50 <TSC> Yes, you should check that x does not end in zero
05:00:00 <phlpp> hm, ok
05:00:14 <TSC> And then you can skip the reversing and adding
05:03:00 <phlpp> so
05:03:29 <phlpp> what will be faster? (\x -> (last $ show x) /= '0') or (\x -> x `mod` 10 /= 0)
05:04:20 <TSC> I think the latter
05:04:22 <dolio> I'd go with the latter.
05:04:23 <vegai> it'd be weird if the one with `mod` wouldn't be faster
05:04:50 <phlpp> ok, maybe the anwser was kind of obvious
05:04:52 <phlpp> ;)
05:05:05 <TSC> If show gave the digits in reverse order, they might be the same
05:08:36 <phlpp> hm
05:09:06 <phlpp> > length $ filter odd $ map (\x -> x + (read $ reverse $ show x)) $ filter (\x -> x `mod` 10 /= 0) [1..10^3]
05:09:08 <lambdabot>  440
05:09:20 <phlpp> > 440 / 120
05:09:22 <lambdabot>  3.6666666666666665
05:09:29 <phlpp> oh
05:10:04 <phlpp> > length $ filter odd $ map (\x -> x + (read $ reverse $ show x)) [1..10^3]
05:10:06 <lambdabot>  496
05:10:27 <phlpp> ok, somehow i don't match the task requirments
05:10:29 <jedbrown> phlpp: filter allOdd
05:10:40 <phlpp> > length $ filter allOdd $ map (\x -> x + (read $ reverse $ show x)) [1..10^3]
05:10:41 <lambdabot>   Not in scope: `allOdd'
05:10:45 <phlpp> @index allOdd
05:10:45 <lambdabot> bzzt
05:10:51 <roconnor> @type (all odd)
05:10:51 <jedbrown> phlpp: You have to write that.
05:10:52 <TSC> @type all odd
05:10:53 <lambdabot> forall a. (Integral a) => [a] -> Bool
05:10:54 <lambdabot> forall a. (Integral a) => [a] -> Bool
05:11:14 <phlpp> eh, but why?
05:11:45 <TSC> You're checking if the result of the addition is an odd number
05:11:46 <phlpp> when given x, and x + reverse x is an odd number, than it's called reversible number
05:11:55 <TSC> You have to check if ALL the digits are odd
05:11:58 <phlpp> ah
05:12:00 <phlpp> !
05:12:04 <phlpp> yeah, true
05:12:04 <phlpp> sorry
05:12:25 <TSC> It pays to read the problem statement carefully (:
05:29:02 <phlpp> > length $ filter (\x -> all (==True) $ map odd $ map Char.digitToInt $ show x) $ map (\x -> x + (read $ reverse $ show x)) $ filter (\x -> x `mod` 10 /= 0) [1..10^3]
05:29:07 <lambdabot>  120
05:29:09 <phlpp> \o/
05:29:32 <roconnor> @type all (==True)
05:29:34 <lambdabot> [Bool] -> Bool
05:29:40 <roconnor> @type amd
05:29:41 <lambdabot> Not in scope: `amd'
05:29:41 <roconnor> @type and
05:29:43 <lambdabot> [Bool] -> Bool
05:30:10 <roconnor> @check \x -> all (==True) x == and (x::[Int])
05:30:11 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
05:30:19 <roconnor> @check \x -> all (==True) x == and (x::[Bool])
05:30:21 <lambdabot>  OK, passed 500 tests.
05:30:32 <phlpp> ok
05:31:04 <roconnor> @scheck \x -> all (==True) x == and (x::[Bool])
05:31:05 <lambdabot>   Completed 127 test(s) without failure.
05:32:45 <roconnor> > length $ filter (\x -> all odd $ map Char.digitToInt $ show x) $ map (\x -> x + (read $ reverse $ show x)) $ filter (\x -> x `mod` 10 /= 0) [1..10^3]
05:32:47 <lambdabot>  120
05:32:53 <roconnor> phlpp: all odd
05:33:19 <phlpp> ah ok
05:33:21 <phlpp> cool
05:33:55 <phlpp> > length $ filter (\x -> all odd $ map Char.digitToInt $ show x) $ map (\x -> x + (read $ reverse $ show x)) $ filter (\x -> x `mod` 10 /= 0) [1..10^3]
05:33:57 <lambdabot>  120
05:38:47 <phlpp> ok, compiled this with -O2. let's see how long it'll take :>
05:38:59 <Itkovian> anybody any experience with Scala, and if so, why should I learn more about it?
05:39:45 <roconnor> phlpp: one line?
05:39:48 <roconnor> :)
05:39:54 <nornagon> â˜­
05:40:08 <roconnor> â˜­
05:40:21 <vegai> Itkovian: you should learn more about it so you can tell us whether we should learn more about it
05:40:32 <nornagon> i guess that was meant for #xmonad, but oh well
05:40:47 <Itkovian> vegai: yeah, I had the same idea, but then opposite :-)
05:40:49 <roconnor> nornagon: is it supposed to be a square?
05:40:57 <roconnor> or at least a rectangle.
05:41:00 <nornagon> roconnor: no, it's a hammer and sickle.
05:41:07 <roconnor> :(
05:41:10 <roconnor> stupid fonts here.
05:41:25 <Itkovian> roconnor: I can see it if I look very closely
05:41:36 <Itkovian> _very_ closely
05:41:37 <vincenz> yeah, it's really tiny
05:41:41 <vincenz> it's the symbol from the USSR flag
05:41:41 <roconnor> I can see it when I cut and paste it.
05:41:55 <roconnor> paste it to another window with different fonts
05:42:00 * vincenz pastes in vim and boosts his font up to 100
05:42:07 <roconnor> maybe I should adjust my fonts in Konversation
05:42:23 <vincenz> or use irssi like most sane people :)
05:42:40 <vegai> terminus-font doesn't have that.
05:42:45 <haraldk> *** Exception: user error (initGUI: Gtk2Hs does not currently support the threaded RTS
05:42:45 <haraldk> see http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/2/
05:42:45 <haraldk> Please relink your program without using the '-threaded' flag.)
05:42:47 <allbery_b> I can see it
05:42:48 <lambdabot> Title: Gtk2Hs » Blog Archive » Writing multi-threaded GUIs, http://tinyurl.com/j7dxw
05:42:52 <haraldk> :-(
05:43:16 <roconnor> odd, I'm using FreeSerif 11. ... You'd think that would work.
05:43:18 <allbery_b> ghci?
05:43:19 <dcoutts> haraldk: if you upgrade your gtk2hs then it does support -threaded
05:43:27 <dcoutts> haraldk: and ghci
05:43:46 <allbery_b> if you are very careful then in older gtk2hs you can use unsafeInitGUIForThreadedRTS
05:44:06 * allbery_b has done so
05:44:15 <haraldk> dcoutts: ah, I have an old version!
05:44:39 <dcoutts> allbery_b: same is true in the new version
05:44:50 <ketil> Anybody know TagSoup?
05:45:32 <mux> > let divisors = [1..20] in [ x | x <- [product divisors..], and (map ((==0) . (x `mod`)) [1..20]) ]
05:45:34 <roconnor> ketil: I've made some use of TagSoup
05:45:41 <ketil> I'm just unable to get XML parsing to work in a reasonable manner... tried to put an example at hpaste, but it doesn't seem to be in a good mood at the moment.
05:45:47 <lambdabot> Terminated
05:46:00 <mux> ah, silly me.
05:46:06 <roconnor> ketil: TagSoup isn't really an XML parser.
05:46:21 <haraldk> the challenge then is to stay on the friendly side of my package manager
05:46:33 * haraldk switched to Ubuntu a while back
05:46:51 <ketil> roconnor, well, the reason I'm experimenting with it is that the "real" XML parsers don't work for large data.
05:47:11 <ketil> Or I am just doing something exceedingly silly.  Always an option.
05:47:12 <phlpp> lol
05:47:15 <phlpp> still running.. :D
05:47:18 <roconnor> ketil: really? that's sad :(
05:47:41 <phlpp> but maybe too much map / filter calls, don't know.
05:47:46 <phlpp> there has to be a more clever way
05:47:46 <ketil> Is there example code anywhere on how to parse a non-toy XML document?  Just counting occurrence of some particular tag, or whatever?
05:48:48 <roconnor> phlpp: hopefully all your map/filters are unified into one.
05:48:52 <roconnor> by the -O2
05:48:55 <ketil> roconnor, I've only used HXT so far, but I think they all use [Char] and do strict processing - i.e. require the full document in memory + the parse tree.
05:49:07 <phlpp> roconnor: yeah
05:49:24 <roconnor> Strict processing?
05:49:32 <ketil> Even so, I think using ~200 bytes per character in the document is rather excessive.
05:50:01 <ketil> roconnor, in the sense of requiring the full document parsed/validated before returning any result.
05:50:02 * roconnor wonders if XML can be parsed lazily
05:50:33 <ketil> Sure it can, if you ignore the requirement(?) of not returning anything before you know there are no invalidities in the future.
05:50:37 <roconnor> ketil: I suppose if it checkes for valid documents first, that makes it strictish.
05:51:31 <ketil> I can't believe I am the sole, single person in the world who actually *uses* an XML parser in Haskell - after all, people have written a bunch of them.
05:51:44 <ketil> I probably just have some kind of memory leak.
05:51:50 <ketil> *sigh*
05:51:56 <roconnor> :(
05:52:21 <roconnor> I guess people are just parsing smaller documents.
05:52:32 <ketil> readXML fp = do
05:52:32 <ketil>     ts <- return . parseTags =<< readFile fp
05:52:32 <ketil>     let iters = sections (isTagOpenName "Iteration") ts
05:52:32 <ketil>     putStrLn (unlines $ map show $ zip [1..] (map length iters))
05:52:48 <roconnor> ketil: I'm often inclined to use nsgmls to do my parsing
05:53:05 <roconnor> and read that into Haskell.
05:53:11 <ketil> This code outputs "(1," and grows infinitely.  Free beer to anybody pointing out the bug.
05:53:16 <roconnor> but now that I think about it, I don't think I've ever done that.
05:53:35 <roconnor> is readFile lazy?
05:53:52 <ketil> Should be.
05:53:56 <roconnor> probably
05:55:12 <phlpp> roconnor:
05:55:13 <phlpp>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
05:55:16 <phlpp> 11163 philipp   25   0  4500 2856  684 R  100  0.3  17:03.35 reversible
05:55:19 <phlpp> hehe
05:55:45 <kfish> ketil, try partitions instead of sections
05:55:54 <roconnor> phlpp: at least it isn't leaking memory
05:56:03 <phlpp> yup
05:56:05 <ketil> kfish, what's the difference?
05:56:16 <ketil> Will try, brb.
05:56:27 <phlpp> i'm really interested how long it takes :>
05:56:40 <ketil> I do hope they'll fix ghci before releasing GHC-6.8.1
05:58:09 <Igloo> ketil: Fix what?
05:59:27 <liffey>  /title
06:00:29 <ketil> Igloo, it seems to hang indefinitely(?) after ^C, and the completion is messed up.
06:01:00 <Igloo> ketil: Works for me
06:01:30 <JaffaCake> is this on Windows?
06:01:42 <ketil> kfish, partitions looks good - thanks!
06:02:06 <ketil> JaffaCake, who, me?  Linux, Ubuntu 7.10, 64bit version.
06:02:43 <JaffaCake> how do I repro the ^C issue?
06:04:22 <ketil> JaffaCake, well - I evaluate a function that uses a lot or memory (i.e. the pasted readXML above), and ^C it.
06:04:50 <ketil> JaffaCake, execution stops after a short while (GC'ing?) (according to top), but I don't get the prompt back.
06:05:06 <ketil> JaffaCake, so I end up ^Z, kill %% and restart.
06:05:09 <JaffaCake> hmm, do you know of an easier way to reproduce it?
06:05:16 <JaffaCake> I don't have whatever libs that needs
06:05:34 <ketil> JaffaCake, sorry, no.  You only need Neil's TagSoup, btw.
06:06:03 <JaffaCake> and this didn't happen with 6.6.1?
06:06:31 <Beelsebob> JaffaCake: has anyone made an attempt to port ghc (including debugger) to the mac?
06:06:41 <ketil> JaffaCake, haven't tried it, as I don't have it installed.  It does not happen when I replace 'sections' with 'partitions' either.
06:06:46 <JaffaCake> Beelsebob: sure, GHC runs fine on Macs
06:07:01 <Beelsebob> JaffaCake: including the version with debugger?
06:07:10 <JaffaCake> yep
06:07:18 <Beelsebob> ohh, where should I grab it?
06:07:29 <Beelsebob> or am I being a noob not seeing it?
06:07:45 <JaffaCake> Beelsebob: there aren't any snapshots of 6.8.1 that I know of, you have to build it yourself
06:07:51 <Beelsebob> okay
06:07:54 <Beelsebob> I'll give it a go
06:08:01 <JaffaCake> great, good luck
06:08:23 * Beelsebob has never had much luck at compiling other people's source
06:09:07 <profmakx> ghc builds very well
06:09:09 <JaffaCake> ketil: and the issue with completion, is that the same as http://hackage.haskell.org/trac/ghc/ticket/998?
06:09:10 <lambdabot> Title: #998 (Tab-completion of filenames does not work in GHCi 6.6) - GHC - Trac
06:09:13 <profmakx> as long as the platform is supported
06:09:57 <profmakx> however, I did not have much luck with FreeBSD7/amd64
06:10:22 <profmakx> (which might be, at least partly due to FreeBSD7 coming with binutils 2.15....)
06:12:02 <dv^^> There's a GHC 6.8? Where?
06:12:20 <Beelsebob> darcs get --partial http://darcs.haskell.org/ghc <-- there
06:12:21 <lambdabot> Title: Index of /ghc
06:12:37 <dv^^> Thanks
06:13:06 <profmakx> 6.8 works nicely on FreeBSD-7-current in i386
06:13:27 * Beelsebob had been considering attempting to compile for darwin9.0.0-arm7
06:13:33 <Beelsebob> ghci on iPhone would win so mch
06:14:08 <ketil> JaffaCake, completion is that bug, yes.  (Sorry about my rather content-free addition to that page, btw)
06:14:38 <JaffaCake> ketil: has it got worse than 6.6(.1)?
06:15:09 <ketil> JaffaCake, IIRC, it's different.
06:15:44 <JaffaCake> urk, I wonder what changed
06:16:04 <ketil> I'd like it to complete file names after a " and functions/modules else, but perhaps readline isn't so cooperative as to make that easy?
06:16:46 <ketil> I think I saw a workaround somewhere, configuring / to (not?) be a word separator, or something.  Haven't tested it, so I can't be *that* annoyed :-)
06:17:35 <ketil> Anyway, I stuck ghci again: <interactive>: exception :: GhcException
06:17:35 <ketil>  -- anything in particular I should try?
06:18:26 <phlpp> roconnor:
06:18:27 <phlpp>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
06:18:31 <phlpp> 11163 philipp   25   0 13716  10m  716 R  100  1.0  39:58.02 reversible
06:18:32 <phlpp> 40 minutes \o/
06:19:28 <roconnor> ketil: BTW, how did you install HXT?
06:20:47 <ketil> JaffaCake, 6.6.1 is available in Ubuntu, so I just tried it.  Looks like the completion is the same (was it different in 6.6.0, perhaps?)
06:21:04 <ketil> roconnor, I got HXT from darcs
06:21:45 <centrinia> Use the source, Luke!
06:22:00 <centrinia> It just takes a few hours to compile ghc-6.6.1 :p
06:25:34 * Beelsebob wonders if 'darcs unpull --patch "Fix Array imports"' is still necessary to get ghc to build on the mac
06:36:59 <ketil> I tried to compile tagsoup for 6.6.1 after compiling it for 6.8.0 - apparently the process overwrote the 6.8.0 install.  This is a known Cabal bug, right?
06:37:25 <shapr> @seen sorear
06:37:25 <lambdabot> I saw sorear leaving ##logic, #xmonad, #haskell-overflow, #haskell-blah, #haskell and #ghc 7h 9m 20s ago, and .
06:37:59 <shapr> I found the problem with hpaste, my server is full!
06:38:10 <shapr> hpaste state is at 3.5 gb
06:39:15 <cjay> omg, 3.5gb pastes?
06:39:31 <shapr> Yeah, 3.5GB worth of hpastes.
06:42:41 <shapr> @tell sorear hpaste state is at 3.5gb and ScannedInAvian.com is out of space.
06:42:42 <lambdabot> Consider it noted.
06:47:02 <phlpp> roconnor: i hope he's still running and not catched in a infinte loop
06:47:13 <roconnor> @go 1 CAD in USD
06:47:14 <lambdabot> 1 Canadian dollar = 1.029654 U.S. dollars
06:47:17 <Saizan> shapr: counting archive or just the last checkpoint?
06:47:57 <phlpp> err, catch cought cought or sth. like that..
06:49:57 <Igloo> shapr: With 5k truncation? Blimey
06:52:29 <shapr> Saizan: counting archive
06:53:06 <Saizan> ah, well, that should be the big part and could be deleted
06:54:34 <shapr> @tell sorear could you shut down hpaste, delete hpaste_state/archive and restart hpaste?
06:54:34 <lambdabot> Consider it noted.
06:57:10 <profmakx> .oO(tell sorear: put up a support hotline so that shapr can call you when hpaste is overrun!)
06:57:22 <shapr> @get-sorear
06:57:22 <lambdabot> Unknown command, try @list
06:57:23 <shapr> aww
06:57:40 <profmakx> @get-shapr
06:57:41 <lambdabot> shapr!!
06:57:45 <profmakx> yay
07:00:31 <profmakx> @get-me-a-bootstrapped-ghc-for-freebsd-7-current-amd64
07:00:32 <lambdabot> Unknown command, try @list
07:25:11 <LeCamarade> Where do I get a set of strings meant to test a hash? Anybody know of that kind of service? :-\
07:29:35 <fasta> LeCamarade: projectgutenberg
07:30:36 <phlpp> roconnor: hm, maybe i could do some optimazation..
07:30:57 <phlpp> roconnor: e.g. 34+43=77 -> all digits of 77 are odd, so 34 and 43 are revisible numbers
07:31:52 <phlpp> and at the moment i'm calculating _all_ numbers between 1..10^9.., but if i know that 34+reverse is 77, i shouldn't calculate it for reverse 34 again
07:31:56 <shapr> From a shell script, is there some way to tell if a darcs repository has conflicts?
07:37:21 <vincenz> @go 1 EUR in USD
07:37:22 <lambdabot> 1 Euro = 1.4286 U.S. dollars
07:39:07 <chessguy> shapr, can't you do a status and grep the results?
07:39:57 <chessguy> that's what you would do with SVN anyway :)
07:40:27 <vincenz> @go 1099 USD in EUR
07:40:28 <lambdabot> 1,099 U.S. dollars = 769.284614 Euros
07:41:05 <chessguy> > (1/1.4286) * 1099
07:41:17 <lambdabot>  769.2846143077138
07:41:26 <vincenz> google's faster :)
07:41:27 <mrd> @go 1099 USD in Pesos
07:41:28 <lambdabot> 1,099 U.S. dollars = 11,859.1577 Mexican pesos
07:41:34 <chessguy> but LB is more accurate :)
07:41:52 <vincenz> Right, cause those digits are significant :)
07:41:57 <chessguy> of course
07:42:05 <vincenz> Uhuh
07:42:08 <LeCamarade> fasta: Yeah. I figured Project Gutenberg, or Wikipedia, or something. Big text. Okay.
07:42:12 <vincenz> Well when I'm starving, I'll think about it :)
07:42:38 <vincenz> Maybe I might get a micro-mole of hamburger for the change
07:43:32 <chessguy> @go 1 micro-mole in pounds
07:43:34 <lambdabot> http://www.unc.edu/~rowlett/units/dictE.html
07:43:35 <lambdabot> Title: Units: E
07:44:08 <chessguy> @go 1 micromole in pounds
07:44:10 <vincenz> chessguy: sorta depends on what material
07:44:10 <lambdabot> http://www.unc.edu/~rowlett/units/dictE.html
07:44:10 <lambdabot> Title: Units: E
07:44:17 <chessguy> true
07:44:23 <chessguy> i didn't do very well in chemistry
07:44:42 <vincenz> I think it's 22.4kg of air
07:44:45 <vincenz> or was it helium
07:44:56 <mrd> @go avogadro's number
07:44:58 <lambdabot> http://en.wikipedia.org/wiki/Avogadro's_number
07:44:59 <lambdabot> Title: Avogadro constant - Wikipedia, the free encyclopedia
07:45:08 <vincenz> We'd need to know the weight a single molecule
07:45:10 <allbery_b> gram-molecular weight
07:45:10 * vincenz doesn't know those units
07:45:15 <chessguy> 6.02 * 10^23
07:45:56 <vincenz> The kilogram is the mass of exactly (6.0221415Ã—1023/0.012) unbound carbon-12 atoms at rest and in their ground state
07:46:07 <vincenz> erm that ought be 10^23
07:46:09 <vincenz> not 1023
07:46:24 <vincenz> so 0.012 kg = 1 mole
07:46:39 <chessguy> ok, i gotta stop getting distracted now
07:46:56 <vincenz> so 12 micrograms of food :)
07:47:06 <allbery_b> 12 grams
07:47:09 <vincenz> no
07:47:11 <vincenz> I said micromole
07:47:15 <allbery_b> a
07:47:17 <allbery_b> h
07:47:20 <vincenz> !
07:47:30 <dons> http://programming.reddit.com/info/5yujd/comments/ cute
07:47:31 <lambdabot> Title: programming: A Quickstart to Haskell
07:49:46 <SamB> vincenz: since when is a kilogram defined exactly?
07:50:19 <earthy> define exactly. :)
07:50:36 <vincenz> That's from wikipedia
07:50:39 <vincenz> go question their sources
07:51:36 <vincenz> Anywho, it's a proposal
07:51:47 <SamB> oh
07:51:48 <vincenz> But since we're talking ballpark figures, the number was good enough for the back of the irc calculation
07:52:30 <vincenz> Another proposed definition of NA
07:52:33 <vincenz>     NA = 602214141070409084099072 = 844468883
07:52:38 <vincenz> erm
07:52:40 <vincenz>     NA = 602214141070409084099072 = 84446888^3
07:52:42 <vincenz> stupid copy past
07:52:51 <earthy> 'By definition, the error in the measured value of the IPKâ€™s mass is exactly zero; the IPK is the kilogram. '
07:53:44 <vincenz> Heh, there's 1 mole human cells in the world
07:54:27 <vincenz> "# If you had a mole of pennies, you could give out enough money to everyone in the world so that they could spend a million dollars every hour, day and night, for the rest of their lives.
07:55:12 <vincenz> Hmm, the meter is stdized though, and no longer by that length.
07:55:16 <vegai> and bubblegum would cost 50 billion dollars :)
07:55:20 <vincenz> It's based on a cesium-laser
07:57:35 <vincenz> It's so funny how they have copies of metal cylinders all around the world just to preserve what a kg means :)
07:57:57 <vincenz> Imagine dropping one :)
07:58:19 <byorgey> > 10e6 * 6.6e9 * 24 * 365 * 60
07:58:21 <lambdabot>  3.4689599999999998e22
07:58:40 <byorgey> hmm, pretty close I guess
07:58:45 <vincenz> pennies
07:58:47 <byorgey> right
07:59:07 <byorgey> so multiply that by 100, and 60 is probably too high
07:59:32 <vincenz> what's the 60?
08:00:39 <byorgey> life expectancy
08:01:18 <byorgey> current average for the world is 67, but that's measured from when people are *born*, and this is talking about giving money to people *now* to spend until they die
08:01:48 <byorgey> so I guess I should have used something like 30 instead
08:05:27 <mux> does someone have a link to an efficint integer factorization algorithm for haskell?
08:06:45 <byorgey> @go "haskell for maths"
08:06:48 <lambdabot> http://www.polyomino.f2s.com/
08:06:48 <lambdabot> Title: Polyomino
08:06:55 <byorgey> mux: ^^ maybe try there?
08:07:15 <mux> yay :)
08:07:16 <mux> http://www.polyomino.f2s.com/david/haskell/hs/Factoring.hs.txt
08:07:17 <mux> thanks.
08:07:45 <mux> hm, but that depends on lots of custom liibs, apparently
08:14:03 <phlpp> roconnor: i think my app is still computing
08:14:19 <phlpp> roconnor: it's now running for 155 minutes and is using 2.1% of memory
08:14:25 <phlpp> so memory usement has increased :D
08:14:39 <dons> ?yow
08:14:39 <lambdabot> Why are these athletic shoe salesmen following me??
08:15:24 <phlpp> @src merge
08:15:24 <lambdabot> Source not found. My pet ferret can type better than you!
08:15:27 <phlpp> @index merge
08:15:28 <lambdabot> Data.Graph.Inductive.Internal.Heap
08:18:48 * SamB wonders why the meter is not *defined* in terms of the wavelength of a certain, readily identified frequency of light...
08:20:49 <Olathe> It's defined in terms of the speed of light.
08:20:58 <Olathe> Which is a bit cleaner, I think.
08:21:48 <vincenz> SamB: it is
08:21:49 <vincenz> SamB: cesium
08:22:02 <Olathe> It was, but not anymore.
08:22:10 <vincenz> o.O
08:22:14 <vincenz> since when?
08:22:27 <Olathe> http://en.wikipedia.org/wiki/Metre#History
08:22:40 <Olathe> Not sure, exactly.
08:22:57 <SamB> damn, no I have to go buy all new paper!
08:23:01 <Olathe> Looks like 1983.
08:23:06 <SamB> oh
08:23:26 <SamB> I don't think I have any paper from before 1983...
08:23:33 <vincenz> Olathe: right 1983 ... cesium light in vacuum
08:24:00 <Olathe> http://en.wikipedia.org/wiki/Metre#Timeline_of_definition
08:24:02 <vincenz> oh wiait, helium neon
08:24:20 <vincenz> Olathe: right, check the last entry, defined in terms of light
08:24:31 <vincenz>     * 1983 October 21 â€” The seventeenth CGPM defines the length as equal to the distance travelled by light in vacuum during a time interval of 1/299 792 458 of a second.
08:24:50 <Olathe> I know. That's the way it's found.
08:25:15 <vincenz> then why "not anymore"?
08:25:22 <Olathe> If a better way is found, you don't have to change the definition, which is nice.
08:25:42 <Olathe> Oh, I meant the definition instead of the technique.
08:25:47 <vincenz> well you know what any man would do :)
08:28:08 * SamB was making an obscure joke about inches having changed length as a result of redefinition of the meter
08:28:31 <Olathe> O-o
08:30:17 <thetallguy> shapr
08:31:13 <thetallguy> ?seen shapr
08:31:14 <lambdabot> shapr is in #xmonad, #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 54m 56s ago.
08:48:06 <phlpp> roconnor:
08:48:06 <phlpp> ROFL
08:48:16 <phlpp> philipp@spitfire:~/code/haskell$ time ./reversible
08:48:16 <phlpp> Stack space overflow: current size 8388608 bytes.
08:48:17 <phlpp> Use `+RTS -Ksize' to increase it.
08:48:18 <phlpp> ._.
08:56:12 <phlpp> roconnor: oh, following is interesting:
08:57:04 <phlpp> reversibles in [1..10^3] = 120, [1..10^4] 720, [1..10^5] 720, [1..10^6] 18720, [1..10^7] 68720
08:57:11 <phlpp> _720_
09:01:02 <Olathe> What is a reversible ?
09:01:40 <araujo> morning
09:01:46 <phlpp> Olathe:
09:02:08 <phlpp> when you add a number and its reverse, and the number you get consists only of odd digits
09:02:18 <phlpp> then the number and the reversed version of it are reversible numbers
09:02:53 <phlpp> you have to look for all reversible number in 1..10^9.. my program got a stack overflow after 3 hours.. (maybe because of missing type signature?)
09:03:13 <Olathe> Ahh.
09:03:19 <phlpp> but it's quite interesting about this 720 pattern, occuring in 10^4, 5, 6 and 7
09:03:53 <byorgey> > 18720 / 720
09:03:56 <lambdabot>  26.0
09:04:10 <phlpp> 86720 / 18720
09:04:15 <phlpp> > 68720 / 18720
09:04:16 <lambdabot>  3.6709401709401708
09:04:20 <phlpp> > 68720 / 720
09:04:21 <lambdabot>  95.44444444444444
09:04:41 <xerox> They are phi(n). Where phi(a*b) = phi(a)*phi(b); phi(p^k)=p^(k-1)*phi(p) and phi(p)=p-1 for p prime.
09:05:25 <byorgey> ...and phi(a*b) = phi(a) * phi(b) only for a,b relatively prime
09:05:27 <Olathe> > 18720 - 720
09:05:29 <lambdabot>  18000
09:05:44 <Olathe> > 68720 - 18720
09:05:45 <lambdabot>  50000
09:05:50 <phlpp> > 6800 / 1800
09:05:52 <xerox> oops. I guess you're talking about something else, nevermind phi.
09:05:52 <lambdabot>  3.7777777777777777
09:05:54 <phlpp> > 68000 / 18000
09:05:55 <lambdabot>  3.7777777777777777
09:06:11 <phlpp> > 1800 / 720
09:06:12 <lambdabot>  2.5
09:06:13 <phlpp> > 18000 / 720
09:06:15 <lambdabot>  25.0
09:06:17 <phlpp> hm
09:06:23 <nominolo> > gcd 18720 720
09:06:24 <lambdabot>  720
09:06:28 <phlpp> lol
09:06:36 <nominolo> > gcd 18720 720 /= 1
09:06:36 <phlpp> for 10^7 its again 68720
09:06:38 <lambdabot>  True
09:07:03 <phlpp> > gcd 68720 720
09:07:04 <lambdabot>  80
09:07:10 <phlpp> > gcd 68720 18720
09:07:12 <lambdabot>  80
09:08:36 <phlpp> hmm, unfortunately, 68720 isn't the correct awnser
09:08:37 <phlpp> answer
09:10:40 <phlpp> :t length
09:10:43 <lambdabot> forall a. [a] -> Int
09:12:27 <Olathe> @let digits = digits' []; digits' [] 0 = [0]; digits' ds 0 = ds; digits' ds n = let (n', d) = divMod n 10 in digits' (d:ds) n'; number = number' 0; number' n [] = n; number' n (d:ds) = number' (10*n + d) ds
09:12:33 <lambdabot> Defined.
09:12:38 <Olathe> > number [1, 2, 3, 4]
09:12:40 <lambdabot>  1234
09:13:14 <Olathe> @let reverseNumber = (number . reverse . digits)
09:13:18 <lambdabot> Defined.
09:13:22 <Olathe> > reverseNumber 1234
09:13:23 <lambdabot>  4321
09:13:24 <phlpp> > reverseNumber 1234
09:13:25 <lambdabot>  4321
09:13:26 <phlpp> hehe
09:13:38 <lament> > reverse number 100
09:13:39 <lambdabot>  Couldn't match expected type `[a]'
09:13:45 <lament> > reverseNumber 100
09:13:46 <phlpp> > reverseNumber 13407128312803123
09:13:46 <lambdabot>  1
09:13:47 <lambdabot>  32130821382170431
09:14:13 <lament> > reverseNumber 44
09:14:14 <lambdabot>  44
09:14:16 <lament> hm
09:14:24 <lament> that didn't do anything!
09:14:26 <Olathe> @let oddDigits n = all (\x -> (mod x 2) == 1) (digits n)
09:14:29 <lambdabot> Defined.
09:14:38 <vegai> lambdabot: therefore, reverseNumber = id
09:14:47 <Olathe> > oddDigits 1234
09:14:48 <lambdabot>  False
09:14:48 <vegai> oops.
09:14:51 <Olathe> > oddDigits 1357
09:14:53 <lambdabot>  True
09:15:14 <glen_quagmire> > oddDigits 1337
09:15:16 <lambdabot>  True
09:15:32 <kaol> erlang coders seem to praise the binary pattern matching that it has often. Should haskell have something like that too?
09:15:44 <Olathe> > filter oddDigits (map (\x -> (reverseNumber x) + x) [1..10^4])
09:15:46 <lambdabot>  [11,33,55,77,99,33,55,77,99,33,55,77,99,55,77,99,55,77,99,77,99,77,99,99,99,...
09:15:56 <Olathe> > length (filter oddDigits (map (\x -> (reverseNumber x) + x) [1..10^4]))
09:15:58 <lambdabot>  875
09:16:00 <phlpp> wrong!
09:16:03 <glen_quagmire> what's binary pattern matching?
09:16:10 <glen_quagmire> matching 0100010010111011 ?
09:16:22 <phlpp> Olathe: you have to drop all numbers which have 0 at the end
09:16:28 <phlpp> because when reversed, they have leading zeroes
09:16:35 <vegai> for instance, you could match the first two and last 6 bits of a byte, glen_quagmire
09:16:40 <phlpp> we don't want such numbers
09:17:05 <glen_quagmire> oh binary data processing
09:17:20 <Olathe> > filter oddDigits (map (\x -> (reverseNumber x) + x) (filter (\x -> x mod 10 \= 0) [1..10^4]))
09:17:20 <lambdabot>   Not in scope: `\='
09:17:22 <glen_quagmire> too bad, (>>) (<<) aren't bitwise shift maybe
09:17:25 <Olathe> > filter oddDigits (map (\x -> (reverseNumber x) + x) (filter (\x -> x mod 10 /= 0) [1..10^4]))
09:17:26 <lambdabot>  Couldn't match expected type `(a1 -> a1 -> a1) -> t -> a'
09:17:28 <vegai> probably a significant feature with Erlang's main target problems
09:17:28 <glen_quagmire> :t (>>)
09:17:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:17:44 <Olathe> > filter (\x -> (x mod 10) /= 0) [1..10^4]
09:17:45 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
09:17:45 <lambdabot>     I...
09:17:51 <Olathe> Quiet, you !
09:18:16 <Olathe> > filter (\x -> x /= 0) [1..10^4]
09:18:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:18:28 <Olathe> > filter (\x -> mod x 10 /= 0) [1..10^4]
09:18:29 <lambdabot>  [1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,...
09:18:43 <Olathe> > length (filter oddDigits (map (\x -> (reverseNumber x) + x) (filter (\x -> mod x 10 /= 0) [1..10^4])))
09:18:45 <lambdabot>  720
09:19:07 <Olathe> @let reversibles n = filter oddDigits (map (\x -> (reverseNumber x) + x) (filter (\x -> mod x 10 /= 0) [1..10^n]))
09:19:12 <lambdabot> Defined.
09:19:18 <Olathe> > length $ reversibles 4
09:19:20 <lambdabot>  720
09:19:29 <phlpp> yup
09:19:31 <Olathe> > map (length . reversibles) [1..10]
09:19:36 <lambdabot> Terminated
09:19:58 <Olathe> > map (length . reversibles) [4..7]
09:20:02 <lambdabot> Terminated
09:20:05 <Olathe> Bah.
09:20:08 <phlpp> :D
09:20:16 <Olathe> > (length . reversibles) 5
09:20:18 <lambdabot>  720
09:20:20 <Olathe> > (length . reversibles) 6
09:20:23 <lambdabot>  18720
09:20:25 <Olathe> > (length . reversibles) 7
09:20:28 <lambdabot> Terminated
09:20:34 <Shurique> is it possible to check if a string is read:able?
09:21:05 <dankna> > read "4"
09:21:06 <lambdabot>  4
09:21:18 <dankna> yes.
09:21:24 <byorgey> Shurique: not very easily.  I suppose it would involve trying to read it, and catching any exceptions that are thrown.  sort of ugly.
09:21:57 <kpreid> no
09:21:59 <kpreid> use reads
09:22:13 <byorgey> @type reads
09:22:15 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:22:24 <kpreid> list-monad result
09:22:29 <byorgey> ah, right, I always forget about reads =)
09:23:01 <byorgey> > reads "432" :: [(Int, String)]
09:23:02 <lambdabot>  [(432,"")]
09:23:17 <byorgey> > reads "blargh" :: [(Int, String)]
09:23:18 <lambdabot>  []
09:23:24 <Shurique> ah, thanks
09:24:15 <byorgey> kpreid++
09:27:09 <phlpp> Olathe: hm, ok, it's not a good fact, but because of the same mem usement and cpu usement, seems like ghc compiled it to the same
09:27:12 <phlpp> binary
09:27:33 <phlpp> but i hope your version does terminate with a stack overflow as mine :D
09:28:27 <Olathe> Here's mine: http://hpaste.org/3425
09:28:36 <Olathe> It's slow, though...hasn't finished yet.
09:29:03 <Olathe> It shouldn't do a stack overflow, since, if it's intelligent, it can just convert it to a loop.
09:29:11 <phlpp> hm
09:29:17 <phlpp> wait, i'll post my solution
09:29:28 <phlpp> which terminated in a stack overflow after almost 3 hours of computing
09:29:43 <ddarius> Tail calls aren't quite the same in a lazy language.  You can have a tail recursive function stack overflow.
09:29:50 <Olathe> Ahh, mine might too.
09:29:55 <Olathe> @src length
09:29:56 <lambdabot> Source not found.
09:29:59 <Olathe> O-o
09:30:25 <Olathe> ddarius: How do you get it to be more strict ?
09:30:32 <Olathe> Or whatever gets rid of that.
09:30:50 <phlpp> http://hpaste.org/3426#a1
09:31:00 <EvilTerran> ddarius, isn't it an out-of-heap-space rather than a stack overflow?
09:31:39 <EvilTerran> or "garbage collector failed to reclaim" or whatever it is
09:31:44 <scriptdevil> i have a very basic question.. i tried to use putStr("Enter your name:") name<-getLine putStrLn(name) with proper indentations and line breaks.. but it looks like putStr is delayed until after readLine.. why??
09:31:45 <ddarius> Conversely non-tail-recursive code can be correct, e.g. any appropriate use of foldr.
09:31:47 <twanvl> > let rev n = rev' 0 n; rev' r 0 = r; rev' r n = rev' (10 * r + n `mod` 10) (n `div` 10) in  rev 1234
09:31:48 <lambdabot>  4321
09:31:48 <lambdabot> twanvl: You have 1 new message. '/msg lambdabot @messages' to read it.
09:31:54 <ddarius> EvilTerran: No, you get a stack overflow.
09:32:04 <Olathe> Hmm, mine is pretty much the same as yours.
09:32:10 <EvilTerran> weird
09:32:35 <EvilTerran> i'll have to look into that
09:32:43 <phlpp> Olathe: you can interupt the programm. i'll let it run for ~3 hours
09:32:51 <phlpp> i bet it also terminats with stack overflow
09:33:14 <phlpp> i can't imagine that my code is optimized to a completly other version than yours
09:34:28 <ddarius> Olathe: There is a problem in your numbers' function, but it shouldn't be a problem in practice since it should only go 9 iterations.
09:34:46 <Olathe> How can it be fixed ?
09:38:50 <ddarius> The most convenient way would be to use a relatively new extension, bang patterns, and change numbers' n 0 to numbers' !n 0
09:40:18 <scriptdevil> putStr
09:40:22 <scriptdevil> !putStr
09:40:31 <scriptdevil> lambdabot: putStr
09:40:50 <scriptdevil> well.. how do you ask for documentation?
09:41:07 <EvilTerran> @docs
09:41:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:41:18 <vincenz> @hoogle putStr
09:41:21 <vincenz> @type putStr
09:41:22 <lambdabot> Prelude.putStr :: String -> IO ()
09:41:22 <lambdabot> Prelude.putStrLn :: String -> IO ()
09:41:22 <lambdabot> IO.hPutStr :: Handle -> String -> IO ()
09:41:27 <lambdabot> String -> IO ()
09:41:28 <EvilTerran> @index putStr
09:41:28 <lambdabot> System.IO, Prelude
09:41:28 <vincenz> @docs Prelude
09:41:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
09:41:35 <vincenz> @docs System.IO
09:41:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
09:41:57 <vincenz> @. @docs @index putStr
09:41:57 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "@docs"
09:42:03 <EvilTerran> @where yaht
09:42:03 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
09:42:09 <vincenz> @who EvilTerran
09:42:09 <lambdabot> Maybe you meant: echo ghc show thx what wn
09:42:49 <EvilTerran> @faq is there any documentation?
09:42:49 <lambdabot> The answer is: Yes! Haskell can do that.
09:43:11 <mrd> scriptdevil: buffering perhaps
09:43:36 <mrd> scriptdevil: does it work if it's "Enter your name:\n" ?
09:44:15 <mrd> @ho hFlush
09:44:15 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
09:44:19 <mrd> @hoogle hFlush
09:44:20 <lambdabot> IO.hFlush :: Handle -> IO ()
09:44:24 <mrd> @hoogle stdout
09:44:25 <lambdabot> IO.stdout :: Handle
09:46:21 <vincenz> @hoogle fo
09:46:21 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
09:46:21 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
09:46:21 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
09:46:24 <vincenz> @hoogle fooob
09:46:24 <lambdabot> No matches found
09:46:29 <vincenz> @hoogle mrd's'intelligence
09:46:30 <lambdabot> No matches found
09:47:20 <byorgey> @src zip3
09:47:20 <lambdabot> zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs
09:47:20 <lambdabot> zip3 _      _      _      = []
09:47:29 <byorgey> @src zipWith3
09:47:29 <lambdabot> Source not found. You type like i drive.
09:47:36 <vincenz> byorgey: neat module, though, kinda cheating with the unsafePerformIO :)
09:48:02 <byorgey> vincenz: hehe, thanks =)
09:49:11 <byorgey> vincenz: yeah, I know the unsafePerformIO is kinda cheating, but I don't want to have to deal with the IO monad when using it... and the output shouldn't really change... I mean, not very often... ;)
09:49:35 <byorgey> it's the "Great Glass Elevator" design pattern
09:49:40 <vincenz> Yeah I was curious about that, had to dig in the sources and then "yep, yep, unsafeLaunchNuclearMissile"
09:50:11 <byorgey> hehe
09:56:59 <visq> hi, could anyone give me a hint on how to implement a function ( (a->a->Ordering) -> ... ) s.t. it uses  the order given by the first argument for internal Data.Map / Data.Set  operations ?
09:57:56 <visq> I just know about newtype wrappers, but I'm sure there must be an easier way ...
09:58:14 <twanvl> Why do you want to do that?
09:58:26 <vincenz> "the ordering of the first argument?"
09:58:41 <vincenz> how can a single element be ordered
09:58:46 <vincenz> > compare 1 2
09:58:47 <visq> I want to parametrize the order used by Data.Map
09:58:47 <lambdabot>  LT
09:58:51 <vincenz> ?t compare
09:58:52 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:58:55 <vincenz> ?type compare
09:58:57 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
09:59:04 <twanvl> vincenz: The first argument of his function is a replacement for compare
09:59:09 <visq> right
09:59:23 <visq> depending on the order the algorithm uses different search strategies
09:59:24 <vincenz> oh
09:59:26 <vincenz> simple enough :)
09:59:53 <vincenz> data Foo a = Foo { value :: a, ordering :: a -> a -> Ordering}
09:59:54 <visq> By selecting the next element to branch on via Set.findMin
10:00:05 <vincenz> instance Ord (Foo a) where
10:00:11 <visq> Yep, i know about newtype wrappers
10:00:15 <vincenz>   compare (Foo a f) (Foo b _) = f a b
10:00:43 <vincenz> of course, that's somewhat nasty
10:00:48 <vincenz> if they contain different f's
10:00:54 <visq> But this somehow requires the caller to create a type and write instances for Ord
10:01:02 <vincenz> visq: that is what I just did
10:01:04 <vincenz> instance Ord (Foo a) where
10:01:06 <vincenz>   compare (Foo a f) (Foo b _) = f a b
10:01:20 <visq> I already implemented this solution
10:01:26 <visq> But it seems to be cumbersome
10:01:41 <vincenz> how so?
10:02:20 <vincenz> visq: ?
10:02:21 <visq> Well, for each strategy I'd have to create a new type and write Ord instances
10:02:25 <vincenz> no
10:02:27 <vincenz> you missed the point
10:02:33 <vincenz> I made the comparing function 'f' a runtime value
10:02:35 <vincenz> it's not a newtype
10:02:39 <visq> ok sorry
10:02:45 <vincenz> data Foo a = Foo { value :: a, ordering :: a -> a -> Ordering}
10:02:51 <vincenz> I make a data type that stores the ordering function
10:02:52 <visq> sorry
10:03:04 <visq> the problem now is that i have a lot of small atoms
10:03:04 <vincenz> and then you'd do something like
10:03:13 <vincenz> map (flip Foo mycomp) values
10:03:40 <vincenz> Data.Set.fromList $ map (flip Foo mycomp) values
10:03:49 <vincenz> where mycomp is your comparator
10:04:00 <visq> and I didn't wanted to avoid the space overhead; but you're right, that would be a possibility
10:04:11 <visq> did want to avoid
10:04:14 <vincenz> another option is a compile time one
10:04:33 <vincenz> simply define your ordering functions
10:04:40 <vincenz> at some point you'll have to do that anywho
10:04:57 <vincenz> but yes, that might require newtyping if you want different comparators for different sets of values in your code
10:05:05 <vincenz> hmm
10:05:11 <vincenz> a safe version is probably
10:05:43 <Pastorn> @src nub
10:05:43 <lambdabot> nub = nubBy (==)
10:05:49 <Pastorn> @src nubBy
10:05:49 <lambdabot> nubBy eq []             =  []
10:05:49 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:05:55 <visq> Ok, so I have the choice between writing newtypes or carrying the compare function around with each element, right ?
10:06:00 <vincenz> yep
10:06:05 <vincenz> pretty much
10:06:16 <vincenz> and it's just a ptr
10:06:45 <visq> You're right, that ptr isn't to bad propably; I knew that two solutions, but hoped there would be another one...
10:07:05 <glen_quagmire> :t ruby
10:07:07 <lambdabot> Not in scope: `ruby'
10:07:28 <visq> do you know of some haskell-cafe discussion on that issue (i.e. parametrizing Data.Map) ?
10:07:31 <vincenz> visq: the problem is that at some point you need to encode the dispatch
10:07:48 <visq> Because I could simply rewrite Data.Map
10:08:18 <visq> i.e. data Map a = Map { cmp :: a -> a -> a, elems :: ... }
10:08:21 * vincenz nods
10:08:27 <visq> cmp:: a -> a -> Bool, sorry
10:08:31 <vincenz> no
10:08:34 <visq> a -> a -> Ordering
10:08:36 <vincenz> righth
10:08:37 <visq> sorry again
10:08:51 <Beelsebob> how does one actually build alex?
10:08:56 <visq> I think that might be of interest to some applications ? well
10:09:09 <vincenz> visq: basically you want ocaml and functors :)
10:09:30 <visq> well, not ocaml, but something like functors maybe ;)
10:09:54 <visq> But you do not need functors really
10:10:15 <vincenz> hmm
10:10:22 <visq> The ctor of the datatype can take the order as an argument
10:10:28 <vincenz> I wonder whether using phantom types and a simple wrapper around DAta.Map would work
10:10:44 <visq> Well, union ?
10:10:52 <vincenz> good point
10:11:02 <vincenz> but how would you solve union in your system?
10:11:17 <vincenz> your solution is just less typesafe but doesn't solve that problme
10:11:42 <visq> Yes, I pointed that out above; union is a problem
10:11:50 <visq> And you loose typesafety
10:11:56 <vincenz> if you could make a newtype
10:12:00 <vincenz> that was phantomtyped over the comparator..
10:12:08 <vincenz> you'd fix union issues
10:12:15 <vincenz> they'd be different types :)
10:12:25 <Beelsebob> anyone know why this is happening? http://hpaste.org/3427
10:13:03 <visq> Yeah, but that still that means I need to declare a new type for every different order
10:13:11 <visq> but thanks for clarifiying
10:13:21 <visq> not so easy to solve this one, it seems
10:13:59 <vincenz> in fairness
10:14:04 <vincenz> a newtype is lightweight
10:14:05 <visq> btw, the Foo type you described above also breaks type safety in this respect
10:14:13 <vincenz> 3 lines, 2 lines if you put 'instance .. where' and the method on the same line
10:14:16 <vincenz> true
10:14:41 <vincenz> but it gives you runtime flexibility (to play in ghci e.g.)
10:14:41 <visq> maybe one could employ Template Haskell for generating such newtypes ? (just to make it one line)
10:14:55 <vincenz> what is there to generate?
10:14:57 <visq> true, it's a tradeoff
10:14:59 <vincenz> I mean you have to give it a meaningfulname
10:15:02 <vincenz> and you have to give it a function
10:15:06 <vincenz> there's not much left after that
10:15:17 <visq> ok, that would just be a C-style macro then, you're right
10:15:19 <vincenz> instance Ord (Bar a) where  compare = barcompare
10:15:44 <visq> would functors give you runtime flexibility ?
10:15:48 <visq> just curious
10:16:00 <vincenz> not sure, that probalby depends on the compiler possibilities
10:16:08 <vincenz> I mean you're basically creating moodules at runtime
10:16:28 <visq> Like TH, it can invoke the compiler from GHCi IIRC
10:16:38 <vincenz> That I was not aware of
10:16:48 <vincenz> can you define types in GHCi tho..
10:18:01 <mrd> no
10:18:06 <visq> Ok, thanks vincenz, I'll use the newtype approach for now
10:22:34 <Beelsebob> no one knows why alex won't build with current ghc and cabal then?
10:23:12 <vincenz> mrd: exactly
10:25:49 <visq> still, dropping union and intersect (and use foldr addElement etc. instead), Set/Map with order as an field would be a nice thing to have; maybe there is something like that floating around ?
10:25:51 <vincenz> visq: http://hpaste.org/3428
10:25:56 <vincenz> visq: check out that one
10:25:58 <vincenz> it's a 'fair' one
10:28:46 <vincenz> :i Ord
10:28:53 <visq> @vincenz: thank you, though I'd rather stick my current newtype+ 'class Wrapper a b | a->b' solution I guess. hpaste is nice.
10:28:54 <lambdabot> Unknown command, try @list
10:29:05 <mrd> Beelsebob: some ghc 6.8 upgrade pains
10:29:10 <vincenz> Alright
10:29:22 <Beelsebob> mrd: hmm? As in, these libraries will appear in 6.8?
10:29:38 <Beelsebob> mrd: that's bloody useless... I'm trying to get a copy of alex so I can build ghc 6.8!!!!!
10:29:41 <mrd> yea. perhaps get an older Alex
10:29:56 <mrd> well it's really the new Cabal at fault there
10:30:13 <Beelsebob> the alex page claims that Cabal 1.1.6 should be suitable
10:30:33 <mrd> what do you have installed
10:30:41 <Beelsebob> apparently 1.1.6.2
10:30:59 <dcoutts_> Beelsebob: current darcs version of alex builds with Cabal-1.2.x and all versions of ghc
10:31:26 <Beelsebob> okay, well the page needs a note reflecting that
10:31:28 <dcoutts_> Beelsebob: released versions of alex build with Cabal-1.1.6.x and all versions of ghc
10:32:27 <Beelsebob> cool, it's compiling now
10:32:29 <Beelsebob> thanks dcoutts_
10:32:53 * Beelsebob sends an email to JaffaCake saying to note on the website that you need a newer version of cabal
10:34:26 <Beelsebob> yay, ghc configure goes through now :)
10:35:53 <dcoutts_> Beelsebob: and tell JaffaCake that there should be a new release
10:36:15 <Beelsebob> okay, well, that guide to building ghc fails then
10:37:56 <sorear> hah.  (just got shapr's message that hpaste is full) bash: /bin/rm: Argument list too long
10:38:55 <vincenz> @join #lua
10:41:04 <olsner> xargs ;-)
10:41:32 <sorear> olsner: yeah.  I can only imagine what shapr's box sounds like right now...
10:42:26 <vincenz> > let foof b = reverse . map (`mod` b) . takeWhile (/= 0) . iterate (`div` b) in map foof 2 $ map foof 10 $ 941
10:42:27 <lambdabot>  Couldn't match expected type `a -> b'
10:42:36 <vincenz> > let foof b = reverse . map (`mod` b) . takeWhile (/= 0) . iterate (`div` b) in map (foof 2) $ map foof 10 $ 941
10:42:37 <lambdabot>  Couldn't match expected type `a -> b'
10:42:48 <vincenz> > let foof b = reverse . map (`mod` b) . takeWhile (/= 0) . iterate (`div` b) in map (foof 2) $ foof 10 $ 941
10:42:50 <lambdabot>  [[1,0,0,1],[1,0,0],[1]]
10:49:27 <sorear> and now with 3.5GB of archives deleted... hpaste is back in service
10:49:33 <sorear> shapr++ for catching this
10:50:10 <dmwit> > 3.5 * (2^30) / (5 * (2^10))
10:50:22 <lambdabot>  734003.2
10:50:34 <sorear> > sqrt 734003
10:50:35 <lambdabot>  856.7397504493415
10:50:42 <dmwit> Why sqrt?
10:50:59 <sorear> because each time you paste, the entire state is saved anew
10:51:12 <sorear> so space usage is quadratic in the paste count
10:51:12 <dmwit> ...o
10:51:53 <dmwit> That seems sub-optimal; it's okay on the heap because we have garbage collection, but on the hard-drive...
10:51:54 <sorear> it's a happs (mis)feature
10:52:44 <vincenz> dmwit: we just need good garbage collectors for harddrives, like windows
10:54:24 * dmwit thinks he missed a joke
10:54:52 <ben> my file system is reference-counted
10:56:07 <opqdonut> :)
10:56:17 <hpaste>  visq pasted "wrapping Ord" at http://hpaste.org/3429
10:56:41 <visq> doesn't seem to be 'that' simple, though ...
11:09:46 <sorear> dmwit: I think it involves windows being buggy enough to randomly delete files
11:09:56 <sorear> not that I've seen that happen back when I used windows
11:10:02 <hpaste>  beelsebob pasted "Anyone got any ideas?" at http://hpaste.org/3430
11:10:03 <sorear> or is it a new feature in XP?
11:10:16 <Beelsebob> anyone got any experience compiling ghc?
11:10:37 <sorear> Beelsebob: it's on the tracker already
11:11:10 <Beelsebob> where's the tracker?
11:12:58 <Beelsebob> sorear: it doesn't appear to be... there's a ticket for "unknown symbol" for hs_hpc_module
11:13:10 <Beelsebob> wheras mine is complaining about two occurances of it
11:13:11 <Beelsebob> rather than 0
11:32:21 <Beelsebob> how does one actually succeed in submitting a ticket for ghc?
11:32:49 <shapr> thetallguy: You called?
11:32:53 <dons> you log in, and go nuts with wiki syntax
11:33:17 <Beelsebob> where does one get a log in from?
11:33:22 <dons> hmm.
11:33:31 <dons> guest/guest ?
11:33:38 <shapr> @seen thetallguy
11:33:38 <lambdabot> thetallguy is in #haskell. I last heard thetallguy speak 3h 2m 25s ago.
11:33:49 <Beelsebob> that works :)
11:34:12 <dmwit> Shucks, I was waiting for dons to broadcast his account information via IRC. =)
11:35:11 <Beelsebob> lol
11:35:18 <dons> heh
11:35:27 <Beelsebob> now there's a ticket about that one
11:35:37 <Beelsebob> strange that OS X reports that the symbol is declared too often
11:35:43 <Beelsebob> while other OSes think it's not declared at all
11:47:02 <thetallguy> hi shapr
11:47:47 <thetallguy> You were looking for sorear and I was just going to say it's possible various people in San Diego would not be responding today due to big wildfires
11:47:53 <thetallguy> but he has since showed up.
11:52:11 <dmwit> Okay, the lecturer just introduced a grammar that looks like this:
11:52:17 <dmwit> S -> (S)S
11:52:25 <dmwit> S -> S[S]
11:52:40 <dmwit> (Where "()[]" are terminals.)
11:53:03 <dmwit> I'm trying to decide if we get an equivalent grammar by replacing the second production with
11:53:09 <dmwit> S -> [S]
11:53:24 <dmwit> (Oh yeah, there's also S -> \epsilon, that's important. =)
11:53:26 <byorgey> dmwit: there are no rules that don't involve recursion?
11:53:29 <byorgey> oh, ok =)
11:53:38 <shapr> Yeah, where are the base cases?
11:53:55 * ehird` notes that he has already tried to learn haskell one (and a kind of half-assed second attempt), maybe third time lucky? ;)
11:53:56 <Igloo> No, e.g. [][]
11:53:57 <mrd> [][]
11:54:12 <dmwit> ah
11:54:19 <dmwit> Yes, okay.  Thanks!
11:54:21 <byorgey> ehird`: sure, why not? =)
11:54:35 <ehird`> byorgey: i have more time to alott to it, so hopefully
11:55:06 <ehird`> i don't run xmonad, doesn't that impede me -51 HSK stats though? that might not help ;)
11:55:10 <byorgey> ehird`: yup, sounds good.  just make sure you stick with it, it can be a long learning curve.
11:55:32 <byorgey> hehe
11:56:31 <byorgey> ehird`: I think running xmonad only increases your stats, it doesn't incur a penalty if you don't =)
11:57:57 <ehird`> ;)
12:00:01 <ehird`> really, i want to use haskell for everything, i kind of get the basics but not much more
12:00:07 <ehird`> i love the syntax unlike som
12:00:08 <ehird`> e
12:00:36 <dmwit> ehird`: Start with something small, like a compiler. =)
12:00:41 <ehird`> dmwit: hehehe
12:01:02 <olsner> hehe
12:01:32 <ehird`> dmwit: i'm wondering which tutorial i should use this time, actually. Build Yourself a Scheme is an interpreter, not a compiler -- i think that involves stat penalties ;)
12:01:53 <dmwit> Which reminds me, does Haskell have a convenient lexing library?  (Or do people just go straight to parsing, somehow?)
12:02:21 <ehird`> dmwit: isn't Parsec the standard?
12:02:25 <ehird`> iirc it combines lexing and parsing
12:02:39 <olsner> there are no stat penalties in #haskell: being here, being social, and learning Haskell for the good of allkind is enough ;-)
12:03:35 <dmwit> ehird`: Maybe it is.  I should look at it again, but I seem to recall having trouble with parsing keywords that shared prefixes, for example.
12:03:47 <Lemmih> ehird`: It's possible to Char as the token type with Parsec but writing a proper lexer is usually a good idea.
12:03:54 <dmwit> (i.e. the kind of problem that lexing was designed for)
12:04:59 <olsner> parsec requires you to left-factor your grammar iirc
12:07:19 <mrd> ya there's a lexing library integrated with parsec.  you specify a language def and then supply it as a parameter to functions work in the Parser monad.  (really it's a record with accessors)
12:07:47 <hpaste>  visq annotated "wrapping Ord" with "Ord Wrappers + GADT" at http://hpaste.org/3429#a1
12:07:55 <visq> If anyone has time to read it: Is this an acceptable solution to the problem I described before, or is there an obvious way to simplify this ? thx
12:10:17 <monochrom> http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements  has an example of Parsec lexing. In particular sections 2.1 and 2.2.  (Shameless plug: I wrote it. :) )
12:10:20 <lambdabot> Title: Parsing expressions and statements - HaskellWiki, http://tinyurl.com/2g23lg
12:13:33 <sorear> thetallguy, shapr: Actually it was a more mundane problem: lunch.
12:13:54 <sorear> thetallguy, shapr: I'm back now.  Incidentally, I dealt with hpaste.
12:14:01 <shapr> Food should not distract you from code! HARETIC! (but only if eating rabbits)
12:14:06 <shapr> sorear: Yes, thank you.
12:14:23 <shapr> sorear: Now my mail has stopped bouncing.
12:14:40 <sorear> Ouch!
12:14:44 <Saizan> visq: Strategy is there essentially to reduce class contexts in types?
12:15:00 * sorear wonders if 'sorear' should have a more reasonable quote
12:15:03 <sorear> *quota
12:15:07 * shapr shrugs
12:15:17 <shapr> sorear: I only bounced 24 hours worth of mail, it's no big deal.
12:15:22 <sorear> shapr: can deleting the archive files while hpast is running break things?
12:15:32 <shapr> sorear: I dunno, I'd have to look at the code.
12:16:24 <visq> Saizan: yes; and 'Strategy' has more than just one field in the full application; it captures various parameters for the algorithm
12:19:28 <dmwit> :src Ord
12:19:31 <dmwit> ?src Ord
12:19:32 <lambdabot> class  (Eq a) => Ord a  where
12:19:32 <lambdabot>     compare      :: a -> a -> Ordering
12:19:32 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:19:32 <lambdabot>     max, min         :: a -> a -> a
12:21:06 <hpaste>  dmwit annotated "wrapping Ord" with "phantom types make this easier, maybe" at http://hpaste.org/3429#a2
12:21:11 <dmwit> visq: ^^^
12:22:33 <visq> dmwit: looks good
12:25:02 <dmwit> visq: I admit I don't know the original question.  Is doing something like
12:25:16 <dmwit> newtype Reversed a = Reversed a deriving Eq
12:25:25 <dmwit> not within the bounds of a fitting solution?
12:29:47 <visq> my solution works fine, but it is a little complicated; I think using a datatype Wrapper (your paste) instead of a typeclass Wrapper (mine) would really simplifies things; I'm trying to rewrite the nubPrint function using this approach now.
12:34:47 <ivant> oh, my program consumed all available memory
12:35:28 <ivant> and it even started to consume swap space, but it is so slow that it only got 600Mb of it
12:36:28 <byorgey> kill it quick, before it starts to eat the video card!
12:36:30 <ivant> are there any really good docs on memory profiling of haskell programs? I just can't figure out where the program is leaking
12:37:09 <byorgey> ivant: check the wiki
12:37:46 <byorgey> there's this, might be useful: http://haskell.org/haskellwiki/How_to_profile_a_Haskell_program
12:37:47 <lambdabot> Title: How to profile a Haskell program - HaskellWiki
12:38:16 <byorgey> there's also: http://haskell.org/haskellwiki/Performance
12:38:17 <lambdabot> Title: Performance - HaskellWiki
12:39:38 <chessguy> someone needs to write a more abstract article, "How to f a Haskell program" so that we can pass in "write", "profile", whatever
12:39:46 <ivant> I tried generating the profile data, but it is useless
12:39:55 <byorgey> hehe, an HOA
12:39:59 <sorear> define useless
12:40:19 <ivant> sorear, I can't really find out where the space leaks because of inlining
12:40:50 <sorear> ivant: -O0 maybe?
12:41:00 <hpaste>  visq annotated "wrapping Ord" with "adopted 'Wrapper as datatype'" at http://hpaste.org/3429#a3
12:41:26 <visq> dmwit: thanks for the suggestion
12:41:32 <ivant> sorear, yeah, but the problem is that without the optimization I may try to attack the points which get optimized with -O2
12:42:13 <monochrom> @remember chessguy someone needs to write a more abstract article, "How to f a Haskell program" so that we can pass in "write", "profile", whatever
12:42:13 <lambdabot> Done.
12:42:41 <monochrom> But I know how to do that!
12:43:03 <chessguy> whoah, lambdabot wrote the HOA!
12:43:08 <chessguy> at least, it says it did
12:43:35 <chessguy> forgot to give us the URL though, silly bot
12:45:38 <byorgey> @wiki How to f a Haskell program
12:45:38 <lambdabot> http://www.haskell.org/haskellwiki/How_to_f_a_Haskell_program
12:45:43 <byorgey> there it is!
12:45:48 <chessguy> lol
12:46:44 <ivant> > 2**32
12:46:45 <lambdabot>  4.294967296e9
12:47:30 <ivant> hmm, I guess I don't have that much memory (enough for 2**32 objects)
12:48:53 <sorear> ivant: that's a good thing (re -Ofoo), since asymptotic changes produced by -O2 are *always* flukes.  you want to optimize them now so that you aren't suprised when GHC fails next time
12:50:14 <ivant> sorear, doesn't inlining sometimes change the asymptotics?
12:50:24 <ivant> (after the simplification)
12:52:19 <sorear> not by itself
12:57:11 <byorgey> @index until
12:57:12 <lambdabot> Prelude
13:02:46 <augustss> ivant: yes, inlining and simplification can change asymtotics
13:02:58 <augustss> inlining and cse
13:05:43 <ivant> okay, thanks for the ideas
13:06:26 <ivant> I'll try to profile without optimizations this time (I remember it didn't quite work for me on some other program)
13:22:47 <shapr> hyvÃ¤Ã¤ huomenta Jiten, mitaa kuulu?
13:23:51 <shapr> Jiten: Which Haskell book are you reading?
13:24:22 <kaol> s/mitaa/mitä/
13:24:30 <kaol> s/kuulu/kuuluu/
13:24:35 <shapr> I should just stop doing that.
13:24:43 <ibid> hyvÃ¤Ã¤ iltaa
13:24:45 <kaol> sorry, couldn't resist. Don't mind me.
13:24:57 <Jiten> iltaa vaan.
13:25:03 <Jiten> shapr: this one http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
13:25:17 <shapr> It's okay, I'd rather not spout random broken Finnish, I might get it right if I'm corrected often enough!
13:25:22 <shapr> Jiten: Oh, I like that one.
13:26:26 <Jiten> it's been a couple of weeks since I last did anything about haskell though. I'm doing too many things at once.
13:26:48 <Jiten> hard to find time learning haskell, japanese, math all at once.
13:27:00 <sorear> but it's soo much FUN!
13:27:23 <dataangel> So I'm reading the wikibooks explanation of how lazy evaluation works, and it mentions that any function that if you pass undefined gives you undefined back out is strict. So I was curious and typed, ":t undefined" into ghci and it says, "undefined :: a". So is undefined a special value that belongs to all types or ... ?
13:27:33 <SamB> write a CAS in Haskell with japanese comments?
13:27:44 <olsner> SamB: CAS?
13:27:51 <shapr> Computer Algebra System?
13:28:05 <olsner> Compare-And-Swap?
13:28:08 <SamB> yeah. that.
13:28:13 <olsner> ;-)
13:28:18 <mrd> memory latency?
13:28:21 <sorear> dataangel: do you know about polymorphism yet?
13:28:23 <SamB> algebra system, I mean...
13:29:01 * sorear suspects this will be long, and due to the channel competition offers #haskell-overflow to dataangel
13:29:07 <Jiten> well, haskell and japanese are what I do for hobby. math is mostly because it's easy enough and keeps Kela (student support) happy when I do courses in my university.
13:29:32 <mauke> dataangel: undefined = undefined  -- any type
13:29:46 <dataangel> sorear: Yes, in the context of say, writing a function that takes an A and returns a B. Or in a union type where the value might "really be" any one of several types. Or with type classes where functions can be generic with constraints. But the idea of a polymorphic _value_ is a little strange to me.
13:29:50 <Jiten> though, I'm starting to find some interest for math too and it sort of intermingles with my interest for haskell so :)
13:30:03 <sorear> dataangel: What is the type of []?
13:30:12 <shapr> Jiten: Yeah, me too. I hated math my first time in school, but Haskell has shown me the beauty.
13:30:14 <sorear> dataangel: It's an empty list... but a list of whats?
13:31:00 <shapr> Jiten: Have you seen "The Haskell road to logic, maths, and programming" ?
13:31:14 <Jiten> shapr: no, can't recall
13:31:42 <dataangel> > :t []
13:31:42 <lambdabot>   parse error on input `:'
13:32:02 <shapr> http://www.amazon.com/Haskell-Logic-Maths-Programming-Computing/dp/0954300696
13:32:03 <dataangel> sorear: Point, but that seems just as odd :)
13:32:05 <lambdabot> http://tinyurl.com/3y6oxo
13:32:19 <mauke> dataangel: what's the type of Nothing?
13:32:20 <shapr> lambdabot is slow today.
13:32:36 <dons> unsw is a long ways away
13:33:26 <dataangel> coming from a C++ background, the idea of a value not having a type is a bit mind exploding, because then it seems to open the possibility of a value's type changing at runtime
13:33:58 <dons> :t Nothing
13:34:00 <lambdabot> forall a. Maybe a
13:34:05 <mauke> it has a type
13:34:10 <mauke> it's just that the type contains a variable
13:34:11 <Japsu> "I HAS A TYPE"
13:34:19 <Japsu> is there already a lambacat with that caption
13:34:26 <dataangel> hrm
13:34:27 <dons> everything has a type :)
13:34:32 <mauke> the C++ equivalent would be a template variable
13:34:35 <dataangel> in C++ that wouldn't be a complete type, it would just be a template of a type
13:35:16 <dataangel> but in C++ everything has a well defined non-template type after compiling is over -- so concrete values never end up having a template type
13:35:29 <mauke> yeah, that sucks
13:35:38 <dataangel> but makes conceptual sense in my head :)
13:35:45 <sieni> dataangel: well, a value can have multiple types
13:35:50 <sieni> :t 7
13:35:52 <lambdabot> forall t. (Num t) => t
13:35:58 <olsner> there should be an en_LOL locale, so that I could run my entire system in lolcat
13:36:15 <dataangel> sieni: actually I've asked about that before, and numeric terminals in haskell are a bit of an exceptional hack
13:36:22 <dataangel> sieni: so I wouldn't consider them here
13:36:29 <sieni> ok, another example
13:36:35 <sieni> :t head []
13:36:37 <lambdabot> forall a. a
13:36:57 <dons> overloaded literals are  cool, I think
13:37:11 <dataangel> dons: they weaken inference
13:37:31 <dons> hmm, not really. they're just polymorphic
13:37:52 <dons> which is way more useful than not being polymorphic
13:38:00 <Jiten> I like the polymorphic strict typing in haskell :)
13:38:00 <dons> and appending the type to the literal's syntax
13:38:05 <Cale> Hehe, Math.OEIS is awesome :)
13:38:15 <dons> heh
13:38:15 <dataangel> dons: Before they had "defaults" for what the literals would mean, "show 4" would result in a type error :P
13:38:27 <Cale> http://programming.reddit.com/info/5yuhf/comments  -- sad that it's doing so poorly on reddit
13:38:28 <lambdabot> Title: programming: Math.OEIS - a Haskell interface to the Online Encyclopedia of Integ ...
13:38:29 <dons> oh, you don't like the defaulting, eh?
13:38:38 <dons> you can disable defaulting if its a problem.
13:38:39 <dataangel> dons: it's a hack on a hack :)
13:38:54 <sieni> and anyway it's hard to see how empty list can't be anything except polymorphic
13:39:46 <dataangel> sieni: True, but trying to peer through the compilers smoke and mirrors that disturbs me, because it seems like its ambiguous how [] should be represented at runtime
13:39:47 <omnId> sieni: it could be a list of some Top type, like Java's Object, not that that would be a good thing :)
13:39:49 <pejo> dataangel, what would you do instead, specify the type of everything?
13:39:52 <dons> there are worse hacks, dataangel :) defaulting is i guess a bit ugly, but user-programmable literals are just too powerful to ignore
13:40:08 <mauke> dataangel: heh. what's the type of 0 in C++?
13:40:11 <dons> the type is decided at compile time though.
13:40:14 <dataangel> dons: what do you mean by user-programmable?
13:40:28 <dons> you can add new types to the Num class
13:40:31 <dataangel> mauke: I didn't claim C++ was better. casting/rounding crap makes it much worse ;p
13:40:35 <dons> that then use the numeric literal syntax
13:40:37 <omnId> instance Num MyNumType where fromInteger x = ...
13:41:00 <mauke> dataangel: so 0 doesn't disturb you?
13:41:09 <dataangel> pejo: You just make 7 integer, 7.0 float, and make the others explicit
13:41:11 <dons> i'm not aware of any other language that lets you add new types to the numeric literal class
13:41:26 <sieni> dataangel: well, I mean that stuff like folding or mapping are polymorphic, mut if you use them in a program, then everything can be resolved during compilation
13:41:32 <dons> dataangel: so boring though. what about a custom Natural or Rational type?
13:41:37 <mauke> dons: Perl!
13:41:39 <dataangel> mauke: 0 doesn't disturb me where? In C++? I already said C++ is worse
13:42:27 <dataangel> dons: hrm... I think I'm missing something. I don't see how that has to do with overloaded literals.
13:43:00 <dons> > 7 :: Rational
13:43:00 <Cale> :t 5
13:43:02 <lambdabot>  7%1
13:43:03 <lambdabot> forall t. (Num t) => t
13:43:07 <dons> > 7 :: Integer
13:43:08 <lambdabot>  7
13:43:12 <dons> > 7 :: Word64
13:43:14 <lambdabot>  7
13:43:14 <dataangel> sieni: Is there a way to (this sounds ridiculous) define undefined, in Haskell? :P
13:43:20 <Cale> dataangel: yes
13:43:31 <omnId> instance Num Natural where fromInteger 0 = Zero; fromInteger x = Succ (fromInteger (x-1))
13:43:32 <sorear> easily
13:43:35 <Cale> dataangel:  undefined = undefined  will work
13:43:39 <dons> its quite fun defining it
13:43:39 <sorear> 13:29 < mauke> dataangel: undefined = undefined  -- any type
13:43:44 <Cale> or even   undefined | False = undefined
13:43:47 <omnId> (3 :: Natural) == Succ (Succ (Succ Zero))
13:43:48 <dons> undefined | False = undefined
13:43:55 <mauke> undefined = error "where is your god now?"
13:43:56 <sieni> > undefined
13:43:58 <lambdabot>  Undefined
13:44:01 <ben> If I define fib as 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ], what is the computational complexity of fib n?
13:44:17 <Cale> > let undef | False = undef in undef
13:44:18 <ben> err, I mean getting the n'th number.
13:44:18 <mauke> O(n)
13:44:18 <sieni> :t undefined
13:44:19 <lambdabot>   Non-exhaustive patterns in function undef
13:44:20 <lambdabot> forall a. a
13:44:29 <Cale> :t let undef | False = undef in undef
13:44:31 <lambdabot> forall t. t
13:44:41 <dataangel> I'm not sure what undefined = undefined means
13:44:50 <mauke> dataangel: recursive value
13:44:51 <Cale> dataangel: It's an infinite loop
13:44:58 <dataangel> that doesn't define it though
13:45:02 <mauke> yes, it does
13:45:03 <dons> sure it does
13:45:10 <dons> > let f = f in f
13:45:11 <Cale> ben: Roughly linear, ignoring the exponential size of the numbers involved.
13:45:11 <lambdabot>  Exception: <<loop>>
13:45:27 <sieni> dataangel: in haskell, being undefined and being an infinte loop are the same thing
13:45:27 <dataangel> if I type "let x = x" into ghci followed by "x" it just hangs. It doesn't bail out.
13:45:37 <dataangel> hrm...
13:45:43 <dons> that's undefined :)
13:45:58 <mauke> dataangel: infinite loop.
13:46:07 <omnId> undefined is sort of a "not-quite-a-value"
13:46:08 <dons> > let x | False = x in x
13:46:10 <lambdabot>   Non-exhaustive patterns in function x
13:46:16 <dons> is another
13:46:20 <Cale> That one will bail out.
13:46:24 <SamB> dataangel: it needs more optimizer-foo to notice that it's a loop...
13:46:31 <SamB> or something
13:46:54 <omnId> bottom, infinite loop, error, undefined, these are all pretty much the same thing
13:46:56 <Cale> I think GHC's blackhole detection was damaged by concurrency or something.
13:47:04 <Cale> I haven't quite worked out when it'll work.
13:47:05 <SamB> ah.
13:47:20 <SamB> greyholing could indeed be part of the problem
13:47:35 <dataangel> undefined is weird, because my experience would lead me to just be like, "Oh, that's haskell's NULL",  but that's a bad comparison because any evaluation of undefined results in error
13:47:47 <mauke> dataangel: it's a lazy exception
13:47:54 <Heffalump> in a sense evaluation corresponds to dereferencing, though
13:47:59 <Heffalump> (only in a very vague sense)
13:48:01 <Cale> dataangel: It's best if you imagine it as an infinite loop which just finishes quickly.
13:48:02 <dons> NULL is more like Nothing/Just a though
13:48:04 <SamB> it's like Haskells *NULL
13:48:26 <Cale> (along with other calls to error)
13:48:29 <omnId> dataangel: the difference is that haskell lives in the world of expressions, not statements, if there's a NULL in the middle of an expression, the whole expression has no meaning.
13:48:44 <dons> good point, omnId
13:48:45 <Cale> They don't return a value to the caller, they just result in nontermination.
13:48:48 <dataangel> Cale: bring mop and bucket, clean cerebral fluid
13:49:01 <sieni> dataangel: well, if you want to do something like NULL, you might want to use Maybe. If you want to have something like a function "returning" void, then you might want something returning IO ().
13:49:22 <omnId> dataangel: does that make sense?
13:49:42 <mauke> hmm, undefined is a bit like uninitialized pointers in C++ :-)
13:49:43 <Cale> The values of type Bool are  False, True, and undefined
13:49:51 <Olathe> @type const ()
13:49:53 <mauke> except your typical C++ implementation doesn't die when you evaluate those
13:49:53 <lambdabot> forall b. b -> ()
13:49:54 <ddvlad> hi, i've been reading the haskell book on wikibooks, but the more advanced things (monads, monad transformers, arrows) are still in construction. can you recommend a source for these (advanced?) topics?
13:50:04 <dataangel> sieni: I know Maybe :) I appreciate it for not letting you get into the scope of getting to use foo if the pointer to foo is NULL.
13:50:07 <Cale> Because any computation which might produce a Bool could get itself into an infinite loop.
13:50:14 <mauke> @where all-about-monads
13:50:15 <lambdabot> I know nothing about all-about-monads.
13:50:20 <Cale> So undefined is just another way of saying that, it just kills the program.
13:50:38 <dataangel> omnId: sorta, I'm not sure how a statement with undefined it it would have any meaning either though
13:50:53 <Cale> Well, you can still use them...
13:51:05 <Cale> > take 2 (1:2:undefined)
13:51:07 <lambdabot>  [1,2]
13:51:09 <pejo> dataangel, non-termination seems meaningfull though. No return value.
13:51:17 <Cale> It's handy for testing.
13:51:26 <shachaf> @wiki Monads as containers
13:51:27 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_containers
13:51:34 <Cale> You can tell if a function really needed a particular piece of data.
13:51:41 <omnId> > take 0 undefined -- Cale: oh! was this fixed?  take was too strict when I tested earlier.
13:51:42 <lambdabot>  Undefined
13:51:51 <shachaf> @wiki Monads as computation
13:51:51 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
13:52:03 <omnId> hrm...
13:52:05 <Olathe> > take 0 [undefined]
13:52:06 <lambdabot>  []
13:52:07 <shachaf> Those two are nice, I think.
13:52:12 <Cale> omnId: I think that's just a decision about the order in which it evaluates its parameters.
13:52:19 <Cale> > take undefined []
13:52:19 <ddvlad> shachaf: thanks, i'll look into them
13:52:21 <lambdabot>  Undefined
13:52:24 <Cale> oh, nope
13:52:31 <Cale> You're right, it is too strict :)
13:52:47 <shachaf> @where aam
13:52:47 <lambdabot> http://www.haskell.org/all_about_monads/
13:52:56 <omnId> according to the reference source, take 0 ignores its argument
13:52:58 <shachaf> Was what mauke tried to get to.
13:52:59 <omnId> @src take
13:52:59 <lambdabot> take n _      | n <= 0 =  []
13:52:59 <lambdabot> take _ []              =  []
13:52:59 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:53:03 <Heffalump> > take 0 undefined
13:53:05 <lambdabot>  Undefined
13:53:14 <sieni> dataangel: well, in Haskell basically "undefined" means that the computation does not terminate and give a value, when the value is requested. There can be multiple reasons for this: you hit infinite loop, you hit `error' or you hit `undefined'. To know which one of these you have hit or if you have hit any of them are impossible by the unsolvability of the halting problem, unless you hit `error' or `undefined'.
13:53:17 <Cale> yeah, never trust @src though
13:53:26 <Olathe> Bad @src !
13:53:39 <Cale> @src foldl
13:53:39 <lambdabot> foldl f z xs = lgo z xs
13:53:39 <lambdabot>     where lgo z []     =  z
13:53:39 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:53:46 <Cale> I really wish that gave saner code.
13:53:46 <omnId> I trust @src as a specification of how the function should behave.
13:54:02 <dataangel> pejo: ah, non-termination not having a return value makes sense :)
13:54:09 <Cale> omnId: You should use the standard's prelude perhaps, or the GHC source.
13:54:34 <shachaf> undefined, fix id, last [1..], and other friends are all known as _|_ (bottom).
13:54:41 <Cale> Though there's a bug or two in the standard with regard to strictness.
13:54:46 <ketil> @seen ndm
13:54:47 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 21h 22m 8s ago, and .
13:54:49 <therp> cale: what's not sane about this?
13:54:55 <omnId> I believe that *is* the standard prelude's, but GHC.List's uses some optimization that makes it too strict in this case.
13:55:04 <Cale> therp: It's just not the code which you'd like to see as a specification of foldl
13:55:14 <Cale> What I'd like it to give is:
13:55:19 <therp> cale: no where clause?
13:55:21 <Cale> foldl f z [] = z
13:55:30 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
13:55:36 <dataangel> sieni: sorry, scrolled down. your version makes sense as well :)
13:55:44 <therp> cale: ok :) I was just wondering..
13:55:49 <Cale> @src foldr
13:55:50 <lambdabot> foldr k z xs = go xs
13:55:50 <lambdabot>     where go []     = z
13:55:50 <lambdabot>           go (y:ys) = y `k` go ys
13:55:55 <Cale> that's also evil
13:56:03 <Cale> foldr f z [] = z
13:56:17 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
13:56:52 <Cale> There's no need to obfuscate it. The form given by @src is a hack to get GHC to compile the code better.
13:56:54 <ivant> @index foldl'
13:56:54 <lambdabot> Data.List
13:56:58 <ivant> @ty foldl'
13:57:00 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:57:33 <Cale> foldl' has the same type as foldl but it ensures that the accumulating parameter is evaluated before recursing.
13:57:42 <Cale> foldl' f z [] = z
13:58:02 <Cale> foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
13:58:57 <Cale> @src foldl'
13:58:57 <lambdabot> foldl' f a []     = a
13:58:57 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:59:19 <Cale> Hey, at least that one's nice.
13:59:34 <omnId> coulda use $!
13:59:45 <sorear> Cale: dons is trying to change it though
14:00:09 <Cale> yeah, but it's needlessly awkward to use $! because it has the wrong associativity
14:00:16 <Cale> sorear: hm?
14:00:26 <Cale> Change it where?
14:00:33 <sorear> In the Prelude.
14:00:36 <Cale> In @src, or in the GHC source code?
14:00:48 <sorear> into foldl' f a = go where go a [] = a ; go a (x:xs) = a `seq` go (f a x) xs
14:00:50 <sorear> both
14:01:24 <Cale> I don't understand why you'd want to have the uglified version in @src.
14:01:33 <sorear> he's petitioning haskell-prime since the new one is slightly stricter
14:02:06 <Cale> hmm
14:02:19 <dataangel> What does (***) preceding a function definition mean?
14:02:27 <mauke> no
14:02:36 <Cale> dataangel: Perhaps it's a definition of (***)?
14:03:11 <omnId> (?) x y = ... -- defines the (?) function
14:03:18 <Cale> Putting an operator symbol in parens makes it treated as an ordinary function name.
14:03:35 <dataangel> @src (***)
14:03:35 <lambdabot> f *** g = first f >>> second g
14:03:39 <Cale> > let (***) x y = x ** (x * y) in 2 *** 3
14:03:40 <dataangel> hrm
14:03:42 <dataangel> wikibooks has
14:03:44 <lambdabot>  64.0
14:03:53 <dataangel> (***) f g ~(x, y) = (f x, g y) --from Control.Arrow
14:03:54 <reffie> 1/win 14
14:03:54 <omnId> @src (->) (***)
14:03:55 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
14:03:58 <Cale> yeah
14:04:10 <omnId> dataangel: that's the method for the (->) type.
14:04:12 <perspectivet> does anybody know where Glasgow Distributed Haskell stands these days?
14:04:20 <omnId> (***) belongs to the Arrow class.
14:04:24 <sorear> perspectivet: dead, afaik
14:04:50 <Cale> That defines (***) as a function which takes two functions and a pair and returns the pair which has had the functions applied to the respective components.
14:05:01 <perspectivet> Any promising distributed computing work happening in the open in Haskell?
14:05:23 <dataangel> Cale: I just got thrown off by the first argument being f and assumed it was defining it
14:05:28 <Cale> Which is the same thing as a function which takes two functions and returns a function which takes a pair and applies the functions to the components.
14:05:40 <omnId> dataangel: the first definition is the default definition in terms of first, (>>>), and second, which also belong to Arrow.  A type can choose to provide those three and it gets (***) for free.
14:05:41 <perspectivet> Everything recent I'm seeing these days seems primarily for harnessing SMP parallelism
14:06:06 <Cale> dons: Something funny seems to be happening with those Haskell posts on reddit.
14:06:23 <omnId> Like in Eq, if you provide just (==), you get (/=) for free:
14:06:24 <omnId> @src (/=)
14:06:24 <lambdabot> x /= y = not (x == y)
14:06:40 <pejo> perspectivet, GdH?
14:06:47 <shachaf> @src (==)
14:06:47 <lambdabot> x == y = not (x /= y)
14:06:48 <perspectivet> pejo: yeah
14:06:51 <Cale> dons: It's unusual to see that many downmods. I wonder if someone has a bunch of sock puppets.
14:07:05 <omnId> or the other way around, like shachaf shows :)
14:07:47 <Cale> perspectivet: Well, once they get data parallelism working on SMP machines, it at least makes some sense to try to distribute it.
14:08:42 <pejo> perspectivet, since everything is going multicore it makes sense to fix things for SMP though.
14:08:54 <perspectivet> pejo: agreed
14:08:55 <pejo> Yeah, Cale beat me to it. :-)
14:09:29 <perspectivet> Cale: Seems the recent data parallel stuff has a ways to go before it's targeting distributed computation
14:09:56 <Cale> Well, given that it's not quite ready for SMP, which is significantly easier, sure :)
14:10:57 <perspectivet> Cale: for my purposes I'd be happy with something along the lines of a distributed Erlang style concurrency lib for haskell
14:11:13 <perspectivet> just haven't seen anything like that anywhere
14:11:35 <dataangel> > let f ~(x, y) = 1 in f undefined -- What is the type of undefined in this expression?
14:11:47 <lambdabot>  1
14:11:49 <Heffalump> (a, b)
14:12:06 <Cale> It seems likely that the data parallelism stuff will extend gracefully to distributed computation though.
14:12:13 <Heffalump> the ~ makes no difference to the types, it just affects the behaviour
14:12:45 <dataangel> Heffalump: So GHC sees that f takes a two-tuple, and since undefined is polymorphic, it is given type (a, b), regardless of laziness of pattern matching
14:12:53 <dataangel> hrm..
14:13:05 * dataangel thought maybe he'd found some runtime type changing loophole
14:13:33 <Cale> Nope, the types are stripped away by compilation, so they don't even really exist at runtime.
14:13:45 <Heffalump> if you're particularly keen to find one, try playing with unsafePerformIO :-)
14:13:56 <mauke> dataangel: you can think of every instance of undefined in the source code getting its own copy of a type schema
14:14:06 <Cale> Well, yeah, that finds a compile-time loophole too though :)
14:14:17 <mauke> and type checking can only make types more specialized, not less
14:14:33 <mauke> so a can become (b, c) but not the other way around
14:15:25 <perspectivet> Cale: I agree with the likely graceful extension, but I don't know if I can hurry up and wait.
14:15:26 <ehird`> so what's the generally accepted "i can program alright, i have very limited experience in functional languages but i kind of grok the idea, and i hate the normal type of programming language tutorials that are out there because they drag on and teach very little" haskell tutorial? ;)
14:15:32 <Cale> perspectivet: hehe
14:15:54 <Cale> perspectivet: Do you have some particularly large distributed computation you're working on?
14:16:22 <perspectivet> In the kickoff stages of the distributed part
14:16:25 <pejo> perspectivet, if Erlang fits your problem, why not use it?
14:16:53 <Cale> ehird`: um, you could try the "Gentle Introduction" -- it's not too gentle unless you're already familiar with ML, but at least it shouldn't drag on.
14:17:00 <perspectivet> pejo: well, it's also a question of community support for various pieces of the puzzle.
14:17:06 <ehird`> Cale: i'm not familiar with ML at all =)
14:17:13 <Cale> http://www.haskell.org/tutorial/
14:17:14 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
14:17:16 <perspectivet> there are some pretty rocking Haskell libs for some of the stuff I need.
14:17:17 <ehird`> Cale: i know a bit of lisp, that's basically my functional experience right there
14:17:30 <ehird`> oh, and i played with Joy a while back
14:17:45 <Cale> Have you tried the Wikibook and/or "Yet Another Haskell Tutorial"?
14:18:05 <Cale> Another thing I'd recommend is to use a different tutorial for monads than any of the general ones.
14:18:40 <Cale> If you get to the section on monads in the wikibook, just skip it and read, say, one of my tutorials, or "You Could Have Invented Monads", or something. :)
14:18:45 <pejo> ehird, or the "Haskell for C programmers" perhaps?
14:18:53 <Cale> "All about monads" is good too
14:18:56 <ehird`> i tried the wikibook version of YAHT the first time i tried to learn :-)
14:19:16 <ehird`> pejo: problem 1. i'm not a c programmer :P (well, i know c but i don't use C)
14:19:16 <Cale> Also, I highly recommend asking lots of questions here :)
14:19:26 <byorgey> ehird`: the more general lesson is that you're not going to find a single tutorial which makes everything perfectly clear to you.
14:19:29 <Cale> I found that tutorial a bit confusing :)
14:19:35 <byorgey> ehird`: you'll probably have to mix and match some =)
14:19:36 <Cale> (knowing both Haskell and C)
14:19:44 <ehird`> byorgey: didn't expect that, of course :)
14:19:45 <kowey> ehird`: what about write yourself a scheme in 48 hours?
14:19:45 <omnId> ehird`: you might look for a tut that actually has you building something, like that Scheme one.
14:19:56 <ehird`> kowey: i've heard about that and i like scheme so that's definately one i'll consider
14:20:02 <ehird`> kowey: plus interpreter+compiler design interests me
14:20:10 <kowey> also available in a handy wikibook form, and as a PDF
14:20:14 <ehird`> omnId: one second delay. great minds think alike?
14:20:24 <omnId> :D
14:20:27 <pejo> Cale, well, not saying anything about the quality of the tutorial but you are probably not the main audience for it.
14:20:38 <Cale> :)
14:20:58 <Cale> That's true
14:21:15 <ehird`> the thing i thought about wys48h (that really abbreviates badly), was: does it teach enough of the theoretical stuff? or does it just skim over the stuff not related to writing a scheme?
14:21:17 <dataangel> what is the point of the const function? I think I asked this before :P
14:21:26 <dataangel> but I can't remember the answer :P
14:21:59 <mauke> dataangel: to replace \_ ->
14:22:10 <omnId> (\x -> 1) is the constant function that always returns 1, (const 1) is another way to write that function.
14:22:29 <dataangel> interesting
14:22:39 <Jiten> Cale: ah, so it was your tutorial, that "you could have invented monads" I finally understood what they are when I read that.
14:22:49 <Cale> Jiten: no, not mine
14:22:49 <byorgey> ehird`: I think the 'teach yourself scheme' one is nice for giving you a taste of some things, but it really leaves out a lot.
14:22:59 <omnId> Jiten: I think that one was sigfpe's.
14:23:10 <Cale> Jiten: I wrote Monads as Containers, Monads as Computation, and Introduction to IO on the wiki.
14:23:15 <ehird`> actually i kind of get monads... i think
14:23:31 <ehird`> they're like little carriers of computations, right?
14:23:32 <ehird`> kind of
14:23:42 <omnId> A monad is a parameterized type that supports the return and bind functions such that the monad laws hold.
14:23:45 <ehird`> like, the IO monad carries the info related to the IO action, which bubbles up to the core interpreter
14:23:46 <byorgey> ehird`: that's one way to think of them
14:23:57 <byorgey> ehird`: but that's really not what they "are"
14:24:21 <byorgey> ehird`: that said, it is usually a useful way to think about them =)
14:25:00 <ehird`> byorgey: yeah i did worry the build yourself a scheme one would leave a lot out
14:25:28 <byorgey> ehird`: just don't try to use that one as your 'main' way of learning Haskell.  but you'll probably get a lot out of it.
14:25:41 <omnId> the bind function is somewhat complicated, so it can be easier to get an understanding if you instead use fmap and join, which can be used to build bind.
14:26:09 <ehird`> you'd think that with the relative amount of haskell hype going around right now (well, at least if you read reddit ;)) there'd be a definitive tutorial :P
14:26:14 <ehird`> well, i guess YAHT kind of is
14:27:30 <Cale> I should really work more on my big tutorial/book project.
14:27:53 <kowey> the Haskell wikibook tries to be that, but still needs lots of work
14:28:03 <kowey> plus different tutorials for different audiences
14:28:10 <pejo> ehird, there are textbooks aviailable for Haskell though, and more are coming.
14:29:04 <matthew-_> anyone used any good object stores recently?
14:29:28 <monochrom> What is an object store?
14:29:40 <matthew-_> well, RDBMS is table and row oriented
14:29:47 <matthew-_> object DBs actually store objects.
14:29:54 <karmazilla> there's a Haskell tutorial where you build a scheme implementation?
14:30:02 <matthew-_> they seem much more useful for storing, eg, graphs
14:30:56 <kowey> karmazilla: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
14:31:42 <karmazilla> kowey: ty, google only wanted to build my self-esteem o_O
14:32:17 <tech> hello, i'm a friend of airy
14:32:52 <dmwit> Hi tech!
14:33:00 * dmwit chuckles
14:33:13 <tech> dmwit: why are you chuckling?
14:33:15 <ehird`> karmazilla: self-escheme would be a good name for something related to scheme
14:33:18 * kowey groans
14:33:36 <dmwit> tech: hi-tech is a term for computers and stuff =)
14:33:39 <dataangel> > sortBy (const LT) [3, 2, 1, 9, 5]
14:33:40 <lambdabot>  Couldn't match expected type `a -> Ordering'
14:33:45 <dataangel> @_@
14:33:54 <omnId> @type sortBy
14:33:56 <ehird`> tech: <dmwit> Hi tech! -> hi-tech
14:33:56 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:33:58 <dmwit> > sortBy (\x y -> LT) [3,2,1,9,5]
14:33:59 <lambdabot>  [3,2,1,9,5]
14:34:02 <tech> dmwit: oh i didn't notice :) nice pun indeed.
14:34:07 <omnId> const LT doesn't match a -> a -> Ordering
14:34:12 <omnId> @type const LT
14:34:13 <lambdabot> forall b. b -> Ordering
14:34:15 <dmwit> dataangel: You need (const (const LT)) or so.
14:34:22 <tech> @remember dmwit Hi tech!
14:34:23 <lambdabot> It is stored.
14:34:58 <kowey> computer programmers are like the French: they both seem to like puns a lot
14:35:06 <ehird`> so what's the haskell compiler world like these days? last time i tried to learn haskell yhc was gaining ground
14:35:10 <ehird`> that was pretty recent
14:36:29 <SamB> well Yhc and Nhc98 seem to have been merged where applicable...
14:36:46 * ddarius only likes good puns which are rare.
14:37:04 <tech> do you guys know airy?
14:37:04 <SamB> I like good puns and very very bad ones
14:37:28 <dmwit> ?seen airy
14:37:29 <lambdabot> Last time I saw airy was when I left ##logic, #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #parrot, #perl6, #scala, #scannedinavian, #unicycling
14:37:29 <lambdabot> and #xmonad 3d 5h 23m 39s ago, and .
14:37:37 <ehird`> i like very very good puns and terrible ones
14:37:39 <SamB> I'm not sure if good puns and very very bad puns are the same or not though
14:37:51 <ehird`> SamB: possibly it's a C integer
14:37:54 <Cale> The name rings a bell...
14:38:08 <ehird`> SamB: good puns overflow into bad puns
14:38:13 <ehird`> thus bad puns are actually the good puns
14:38:16 <tech> Cale: he is a finn
14:38:21 <dmwit> Bad puns underflow into good ones. =)
14:38:35 <SamB> that sounds backwards?
14:38:58 <ehird`> dmwit: that's a more elegant way of saying it
14:39:01 <ehird`> see, haskell brains ;)
14:40:43 <tech> where's airy
14:40:55 <alexj> @seen lemmih
14:40:55 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 2h 37m 8s ago.
14:41:33 <tech> airy runs his own lambdabot that is superiour to lambdabot
14:41:48 <ehird`> tech: in what way?
14:41:54 <sorear> duh
14:42:08 <tech> ehird`: it is improved
14:42:27 <dmwit> ...
14:42:30 <sorear> and why hasn't he contributed the patches? WHY?
14:42:30 <omnId> how so?  I'm intrigued!
14:42:31 <dmwit> with what improvements?
14:42:32 <ehird`> tech: has he submitted his changes to the lambdabot repository?
14:42:36 <ehird`> sorear: haha
14:42:41 <ehird`> sorear: 2 seconds
14:42:49 <ari> Uh, tech, the only improvement I ever considered for it was removing the cheeky comments, and I never even implemented that :p
14:42:57 <ehird`> pff
14:42:58 <tech> ehird`: i don't know, but i assume airy wouldn't want everyone to leech from his superiourity
14:42:59 <ehird`> that's a downgrade
14:43:05 <ehird`> you need the cheeky comments
14:43:13 <ehird`> tech: heh
14:43:31 <dmwit> ari === airy?
14:43:36 <omnId> @quote blargh
14:43:36 <lambdabot> No quotes match. I've seen penguins that can type better than that.
14:43:43 <omnId> See?  Golden.
14:43:46 <ehird`> dmwit: apparently
14:43:48 <ehird`> @seen ari
14:43:48 <lambdabot> ari is in #haskell-blah and #haskell. I last heard ari speak 58s ago.
14:43:53 <ehird`> @seen airy
14:43:53 <lambdabot> Last time I saw airy was when I left ##logic, #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #parrot, #perl6, #scala, #scannedinavian, #unicycling
14:43:53 <lambdabot> and #xmonad 3d 5h 30m 4s ago, and .
14:44:07 <Cale> % DSolve[y''[x] - x y[x] == 0, y[x], x]
14:44:09 <mbot> Cale: {{y[x] -> AiryAi[x]*C[1] + AiryBi[x]*C[2]}}
14:44:09 <ehird`> well, whatever, i think it's pretty obvious now :P
14:44:16 <Cale> mbot: @part #haskell
14:44:22 <ari> dmwit: I used that nick for a very little while a couple of days ago because of a deal I made on another channel
14:44:27 <ehird`> Cale: that does not look like haskell :P
14:44:31 <dmwit> heh
14:44:31 <ehird`> Cale: mathematica?
14:44:34 <Cale> ehird`: Yeah
14:44:35 <byorgey> ehird`: it isn't =)
14:44:51 <sorear> it's *M*bot
14:45:02 <dmwit> Cale: Does mbot have command conflicts with \bot, or why don't you keep it on #haskell?
14:45:12 <ehird`> Cale: <lame>i can tell from the brackets and having seen lots of mathematica code in my time</lame>
14:45:12 <Cale> It also interprets >
14:45:22 <dmwit> aha
14:45:26 <Cale> ehird`: Do you happen to know where that meme comes from?
14:45:26 <tech> dmwit: yeah airy is airy, but he doesn't want to admit it
14:45:46 <dmwit> 4chan?
14:45:48 <ehird`> Cale: that would be an interesting oppertunity for haskell/mathematica quines ;)
14:45:49 <omnId> Cale: 4chonz.
14:46:06 <ddarius> It doesn't do @src or @seen though among no doubt many other things.
14:46:07 <ehird`> Cale: probably 4chan? i just pick the lameness up from reddit. :P
14:46:08 <dmwit> i.e. That looks like a shop, I can tell by the pixels and having seen quite a few shops in my time.
14:46:38 <tech> dmwit: do you and airy know eachother?
14:46:44 <dmwit> nope
14:47:00 <dmwit> I don't think I know any of the people here IRL, really.
14:47:11 <tech> dmwit: i didn't mean irl
14:47:15 <omnId> 4chan is the butthole of the internet.  I still love it, though :)
14:47:23 <tech> omnId: kinky
14:47:30 <omnId> :D
14:47:43 <dmwit> omnId: Every once in a while, you get the "This thread is now about quantum physics" kind of thing. =)
14:48:07 <tech> i say we make airy the president of haskell
14:48:31 <ehird`> tech: obsessive much? :P
14:48:32 <omnId> actually, is it down for anyone else?  I haven't been able to browse /v/ in days :(
14:48:46 <jmob> How do I do this and get a floating point number? (1 :: Int) / (2 :: Int) ?
14:48:56 <omnId> jmob: fromIntegral
14:49:04 <ari> ... as I recall, the last time tech visited #haskell he eventually started spamming the channel and got kicked... at least I think he did. I don't actually have it in my logs, but I have little from this summer in them anyway.
14:49:05 <dmwit> :t on
14:49:07 <lambdabot> Not in scope: `on'
14:49:16 <omnId> > fromIntegral (1::Int) / fromIntegral (2::Int)
14:49:18 <lambdabot>  0.5
14:49:50 <ehird`> ari: oh dear
14:49:58 <tech> airy what are these harsh lies about? i thought we were friends
14:50:07 <Mr_Awesome> > 1 / 2
14:50:08 <lambdabot>  0.5
14:50:13 <dmwit> > let on f g x y = f x `g` f y in on fromIntegral (/) 1 2
14:50:14 <lambdabot>  0.5
14:50:15 <Cale> tech: So are you learning Haskell?
14:50:28 <tech> yes airy was going to learn me he said
14:50:38 <omnId> dmwit: on is usually the other way 'round.
14:50:44 <dmwit> oh, ok
14:50:45 <omnId> (/) `on` fromIntegral
14:50:59 <dmwit> Yeah, that makes more sense.
14:51:26 <omnId> @let on f g x y = f (g x) (g y)
14:51:26 <lambdabot> <local>:14:0:     Multiple declarations of `L.on'     Declared at: <local>:5:...
14:51:50 <dmwit> ?unlet
14:51:52 <omnId> > let i2d = fromIntegral :: Int -> Double in ((/) `on` i2d) (1::Int) (2::Int)
14:51:55 <lambdabot>  0.5
14:51:57 <lambdabot> Defined.
14:52:00 <dmwit> ?let on f g x y = f (g x) (g y)
14:52:01 <lambdabot> <local>:15:0:     Multiple declarations of `L.on'     Declared at: <local>:5:...
14:52:11 <omnId>  it's @undefine, and the on seems to be correct.
14:53:05 <dmwit> Yes, 4chan seems down. =/
14:54:12 <olsner> oh, do we have such depraved souls even in #haskell?
14:54:33 * omnId admits it proudly
14:55:01 <tech> airy's life depends on 4chan
14:56:16 <dmwit> So, can I add state to the CGI monad by doing StateT S CGI, or would I need a CGIT?
14:56:51 * dmwit doesn't quite understand monad transformers yet
14:57:11 <omnId> @kind CGI
14:57:14 <lambdabot> Not in scope: type constructor or class `CGI'
14:57:23 <ehird`> CGI monad? that scares me. is that what I think it is?
14:57:33 <omnId> probably some IO wrapper.
14:57:37 <tech> airy says i will have to leave this channel for him to teach me haskell, that's not fair
14:57:39 <ehird`> yes, but CGI oh dear.
14:57:56 <dmwit> ehird`: Yep. =)
14:58:01 <ehird`> tech: have you said one sentence without 'airy' in since you came in? ;)
14:58:09 <ehird`> dmwit: i think i legally have to stab you now?...right?
14:58:21 <dmwit> Why, what's wrong with CGI?
14:58:29 <ehird`> slow, unscalable, outdated :p
14:58:37 <dmwit> And the replacement is...
14:58:40 <omnId> type CGI a = CGIT IO a
14:58:46 <bg> FastCGI
14:58:47 <tech> ehird`: i think i have, but you know, airy is an interesting subject
14:58:50 <kpreid> dmwit: StateT S CGI should be fine
14:58:52 <Olathe> Who's airy ?
14:58:58 <ehird`> dmwit: fastcgi
14:58:59 <dmwit> Olathe: ari
14:59:02 <kpreid> dmwit: much more likely to be what you want than the other way around
14:59:03 <Olathe> Oh.
14:59:40 <omnId> newtype CGIT m a = CGIT {
14:59:40 <omnId> unCGIT :: (ReaderT CGIRequest (WriterT Headers m) a)
14:59:40 <omnId> }
15:00:06 <dmwit> kpreid: Okay, thanks, I'll go play with it now. =)
15:00:35 <omnId> @unmtl StateT s (ReaderT CGIRequest (WriterT Headers m)) a
15:00:36 <lambdabot> s -> CGIRequest -> m (a, s, Headers)
15:02:43 <tech> airy airy airy airy airy
15:02:51 <omnId> @unmtl (ReaderT CGIRequest (WriterT Headers (StateT s IO))) a
15:02:51 <lambdabot> CGIRequest -> s -> IO (a, Headers, s)
15:03:05 <ehird`> tech: so that's the spam ari talked about
15:03:15 <tech> ehird`: no
15:03:48 <tech> ehird`: and his name is airy, don't degenerate him by making up names
15:04:05 <ehird`> tech: nickname completion on tab, suck it
15:04:28 <tech> ehird`: that is only because someone stole airy's name
15:04:30 <dmwit> You use tab-completion on a three-letter nick?
15:04:35 <ehird`> dmwit: yes :)
15:05:00 <jmob> omnId: thanks
15:09:22 <omnId>  @unmtl collapses tuples?
15:09:24 <omnId> @unmtl WriterT a (WriterT b (Writer c)) d
15:09:25 <lambdabot> (d, a, b, c)
15:09:44 <omnId> does this actually happen in practice?
15:10:33 <ehird`> random list question - is there a way to say "the middle element of the list"? (for finite lists, of course)
15:10:47 <omnId> xs !! (length xs `div` 2)
15:11:28 <omnId> > let xs = [1,2,3,4,5] in xs !! (length xs `div` 2)
15:11:33 <lambdabot>  3
15:11:39 <ehird`> ah, so just the regular way
15:12:17 <dmwit> If you're doing something like that, consider switching to Array's.
15:12:19 <omnId> not sure if there's a simpler way.
15:12:21 <Cale> ehird`: yeah, and it takes O(n) time to get it.
15:12:27 <ehird`> Cale: ;)
15:12:32 <ehird`> dmwit: just wondering
15:12:47 <huamn_> are the sending and receiving socket operations in Network.Socket (sendTo, recvFrom, send, recv) thread-safe so that I can safely to reading in one thread and writing in another without running into trouble?
15:13:07 <kpreid> @let middle xs = middle' xs xs where middle' (_:ss) (_:_:fs) = middle' ss fs; middle' (x:_) _ = x
15:13:10 <lambdabot> Defined.
15:13:11 <Olathe> > let mid xs = mid' xs xs; mid' [] (m:ms) = m; mid [x] (m:ms) = m; mid' (x:y:xs) (m:ms) = mid' xs ms in mid [1, 2, 3, 4, 5]
15:13:12 <lambdabot>      Conflicting definitions for `mid''
15:13:12 <lambdabot>     In the binding group for: mid, mi...
15:13:16 <kpreid> > middle [1,2,3,4,5]
15:13:17 <lambdabot>  3
15:13:21 <Olathe> > let mid xs = mid' xs xs; mid' [] (m:ms) = m; mid' [x] (m:ms) = m; mid' (x:y:xs) (m:ms) = mid' xs ms in mid [1, 2, 3, 4, 5]
15:13:22 <alexj> dmwit: happs is basically a state monad and there is fastcgi code in there that needs some updating....
15:13:22 <lambdabot>  3
15:13:32 <Olathe> > let mid xs = mid' xs xs; mid' [] (m:ms) = m; mid' [x] (m:ms) = m; mid' (x:y:xs) (m:ms) = mid' xs ms in mid [1, 2, 3, 4, 5, 6]
15:13:34 <lambdabot>  4
15:13:40 <kpreid> Olathe: I see we had the same idea
15:13:40 <Olathe> Hmm.
15:13:41 <twanvl> > let xs = [1,2,3,4,5] in last $ zipWith const (concatMap (\x -> [x,x]) xs) xs
15:13:43 <lambdabot>  3
15:13:52 <dmwit> alexj: I'm using WASH.
15:14:03 <dmwit> alexj: Even more in need of updating... =P
15:14:16 <Olathe> Hmm, yours is a bit nicer.
15:14:17 <omnId> twanvl: :D
15:14:26 <Olathe> > middle [1,2,3,4,5,6]
15:14:28 <lambdabot>  4
15:14:31 <ehird`> > middle [1,2,3,4]
15:14:32 <lambdabot>  3
15:14:33 <alexj> dmwit: ok why not switch to happs?
15:14:40 <ehird`> > middle [1,2,3,4,5]
15:14:41 <lambdabot>  3
15:14:46 <Olathe> I wonder how to push it to the left.
15:14:50 <ehird`> > middle [1,2,3,4,5,6]
15:14:51 <lambdabot>  4
15:14:53 <dmwit> alexj: ...because I'm nearly done with my project?
15:15:00 <kpreid> hmm
15:15:18 <alexj> dmwit: ok.  out of curiosity, when did you start?  why did you pick wash?
15:15:41 <olsner> To understand recursion, you first have to understand recursion.
15:15:56 <Olathe> @let middleL xs = middleL' xs xs where middleL' (_:ss) (_:_:f:fs) = middleL' ss (f:fs); middleL' (x:_) _ = x
15:16:01 <lambdabot> Defined.
15:16:12 <Olathe> > middleL [1..4]
15:16:12 <dmwit> alexj: I started over the summer, and chose WASH because I was interested in the abstractions it had.  I was also a little bit intimidated by the complexity of the happs "Hello World" -- I explicitly did not want to learn about how CGI/HTTP/mail/etc all works just to write this.
15:16:13 <lambdabot>  2
15:16:15 <omnId> olsner: that's diversion. :P
15:16:15 <Olathe> > middleL [1..5]
15:16:17 <lambdabot>  3
15:16:21 <Olathe> There we go.
15:16:35 <omnId> divergence, rather
15:16:37 <ehird`> > middleL [1..]
15:16:37 <ehird`> ;)
15:16:40 <lambdabot> Terminated
15:16:42 <Olathe> Heh
15:16:53 <kpreid> Olathe: interesting; i was going to add a third case for middleL' (_:xs) [_]; not sure if that's actually right
15:16:58 <ehird`> it would have made my day if that came back with "84" or something
15:17:17 <sorear> alexj: do you know a nice way to get incrememental storage out of happs?
15:17:18 <alexj> dmwit: fair enough.  there has been massive simplification since this summer.
15:17:29 <alexj> dmwit: can I ask what the app is?
15:17:49 <sorear> alexj: hpaste is leaking space massively, I had to clear out 3.5GB of old checkpoints this morning
15:17:53 <dmwit> alexj: It's a web front-end for the game Assassins; have you heard of or played it before?
15:18:23 <sorear> 'had to', as in shapr's mail was bouncing due to disk full errors
15:19:20 <ehird`> speaking of web things, if my first haskell project is a simple compiler/interpreter (which i think is a good idea -- although i forget who suggested it to me earlier), i might make the second some kind of web app
15:19:37 <ddarius> ehird`: Why not do both at the same time?
15:19:50 <ehird`> ddarius: because my brain would explode
15:20:00 <ehird`> ddarius: it's running on a limited platform ;)
15:20:13 <ehird`> i could write a compiler for a language to specify web apps!
15:20:15 <ehird`> heh
15:20:22 <SamB> ehird`: uh, yeah
15:20:23 <ddarius> That would work too.
15:20:31 <nominolo> @pl get >>= \p -> munge p () >> return p
15:20:31 <lambdabot> liftM2 (>>) munge return =<< get
15:20:37 <SamB> isn't that what "both at the same time" means?
15:20:52 <nominolo> :t liftM2 (>>)
15:20:54 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
15:20:55 <alexj> dmwit: I thnk assasin is like werewolf?
15:21:06 <ehird`> SamB: i assumed he meant, do both projects simultaneously, not combine them
15:21:17 <alexj> sorear: yeah the archive files need a cleanup function.
15:21:18 <ehird`> <ddarius> That would work too. seems to confirm that
15:21:19 <ddarius> I meant combine them.
15:21:23 <ehird`> haha, ok
15:21:25 <ehird`> that would be crazy
15:21:26 <ehird`> :)
15:21:27 <ddarius> But in a different way.
15:21:33 <dmwit> alexj: Maybe.  It's on Wikipedia, as "Assassin_(game)".
15:21:34 <ddarius> But SamB's idea is good as wel.
15:21:39 <alexj> most of those files are obsolete after each echkpoint.
15:21:57 <alexj> you want them to get deleted?
15:22:01 <SamB> I suppose one could write a compiler like Inform7
15:22:02 <sorear> alexj: simple cleanup would be at best a partial fix, it would fix the quadratic space but not the quadratic time
15:22:06 <dmwit> Incidentally, WASH has garbage-collecting of its old state. =)
15:22:08 <alexj> ?
15:22:15 <olsner> you could make a compiler for a small language that generates javascript, and an interpreter that prints results, then bundle it up in a small webapp
15:22:17 <SamB> which outputs all kinds of info in HTML
15:22:19 <conal> how does one get a list of darcs repos on community.haskell.org?
15:22:24 <alexj> dmwit: so should happs.
15:22:24 <alexj> sorear: what behavior are you seeing?
15:22:25 <SamB> after compiling
15:22:49 <sorear> alexj: 3000 pastes needs 6,000,000 units of space and time
15:23:04 <sorear> alexj: because each time it pastes, ALL of the old pastes are written anew
15:23:05 <alexj> sorear: is this using the new API or the old?
15:23:19 <sorear> alexj: I don't know, I just run it
15:23:33 <SamB> (in the interest of avoiding the need to write all the code to prettily display that info for more than one GUI toolkit)
15:23:51 <sorear> it identifies as HApps/0.8.4
15:23:53 <alexj> sorear: why are all the old pastes written anew?  not sure I understand what is happening.
15:23:55 <sorear> is that old or new?
15:23:59 <alexj> that is old.
15:24:08 <ehird`> i think i'll probably do a compiler/interpreter first, then write some kind of web app
15:24:24 <dmwit> ehird`: Don't use WASH. =P
15:24:25 <alexj> saizan has updated hpaste for the new api.  not sure its status.  did a skim of his code today and it looked good.
15:24:26 <sorear> alexj: HPaste has ~10 MB of state.  each time you paste, it writes 10MB of data into a new checkpoint file
15:24:27 <ehird`> maybe rip out its core and use it to write my website; i really need to get on that... it's been lying there for, uhh, far too long
15:24:32 <ehird`> dmwit: i meant from scratch :-)
15:25:06 <sorear> alexj: if we get lisppaste-style popularity we'll have 100's of MB of data, and even with cleanup that is Far Too Slow
15:25:09 <conal> oh -- code.haskell.org
15:25:14 <sorear> alexj: I want linear performance
15:25:34 <alexj> sorear: yeah it shouldn't be doing that.  don't knwo the hpaste code.
15:25:46 <alexj> why is it checkpointing on each paste?
15:26:13 <sorear> alexj: how can it be avoided?  happs is a state monad; as such it is monolithic
15:26:30 <sorear> alexj: parametricity means no incremental checkpoints
15:26:39 <sorear> even though the old data is the same
15:26:52 <alexj> sorear: the idea behind happs is that it writes to a log and checkpoints only periodically.  on reboot, it loads the last checkpoint and then replays the log.
15:27:01 <alexj> the log is intended to be incremental.
15:27:32 <alexj> it should checkpoint when there have been enough log entries since the last checkpoint to be worth it.
15:28:09 <Notrix> hey, i've got a matrix in the form [[1,2],[3,4],[5,6]] (the rows) i'd like to have it in terms of the columns : [[1,3,5],[2,4,6]] is there a haskell_cool_high_order way to do it ?
15:28:19 <sorear> but still... each checkpoint writes 10MB of data... as the state grows checkpoiting  becomes more and more expensive...
15:28:26 <ddarius> Notrix: There's a first order function to do it, transpose.
15:28:32 <sjanssen> > transpose [[1,2],[3,4],[5,6]]
15:28:40 <lambdabot>  [[1,3,5],[2,4,6]]
15:28:42 <sorear> @src transpose
15:28:43 <lambdabot> transpose []             = []
15:28:43 <lambdabot> transpose ([]   : xss)   = transpose xss
15:28:43 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
15:28:45 <ehird`> perhaps i should learn haskell *AFTER* i finish this silly little minimal-compiler-that-can-compile-itself-in-tiny-subset-of-C :-) it might corrupt my brain
15:29:19 <Notrix> oh so there's a module that works on matrices :o
15:29:24 <sorear> @seen Saizan
15:29:24 <lambdabot> Saizan is in #haskell-overflow, #haskell-blah and #haskell. I last heard Saizan speak 3h 14m 40s ago.
15:29:29 <ddarius> No, there's a module that works on list.
15:29:32 <ddarius> lists.
15:29:38 <ddarius> (Stupid keyboard.)
15:30:12 <Notrix> okay cool, thank you the help :]
15:30:30 <alexj> sorear: don't know how bad that is.  seems like you don't need to checkpoint that often and you don't need to accumulate storage for each checkpoint.
15:30:52 <sorear> "accumulate storage"?
15:31:12 <alexj> sorear: how much history is being kept?
15:31:27 <sorear> infinite
15:31:30 <alexj> how big a state do you want to care about...
15:32:00 <sorear> the state is only 10MB.  small by disk capacity standards, large by disk bandwidth standards.
15:32:05 <alexj> sorear: ok...  how often is state updated and are those updates random access?
15:32:14 <ehird`> =)
15:32:28 <sorear> no, the updates are effectively linear
15:32:43 <olsner> basically append-only, right?
15:32:53 <kpreid> except for annotations, no?
15:34:11 <sorear> append only
15:34:25 <sorear> annotations can be handled using a tiny permutation table
15:34:47 <dons> Igloo: what was the fix relating to EM_AMD64?
15:34:57 <dons> (which is needed for openbsd/amd64)
15:35:01 <chessguy> > iterate (+75) =
15:35:01 <lambdabot>  Parse error
15:35:04 <chessguy> > iterate (+75) 0
15:35:06 <lambdabot>  [0,75,150,225,300,375,450,525,600,675,750,825,900,975,1050,1125,1200,1275,13...
15:35:07 <Beelsebob_> supposing I have an object code file from compiling some C, and a piece of Haskell that imports functions from it using FFI... how would I tell ghci to load objects from the object file?
15:35:10 <dons> just some cpp? openbsds not going to break i hope?
15:35:21 <sorear> Beelsebob_: ghci foo.o Bar.hs
15:35:25 <dons> Beelsebob_: add the .o file to the command line, or use cabal
15:35:27 <Igloo> dons:
15:35:28 <Igloo> -#endif
15:35:28 <Igloo> -#ifdef EM_AMD64
15:35:28 <Igloo> +#elif defined(EM_AMD64)
15:35:38 <sorear> dons: cabal doesn't support ghci
15:35:38 <dons> ah
15:35:48 <dons> it supports packages, sorear
15:35:50 <Beelsebob_> dons: hmm, that's what I thought... it's still complaining that it can't find the symbol
15:35:51 <alexj> sorear: would  writing 10MB or even 100MB an hour be bad?
15:35:53 <Beelsebob_> :/
15:35:53 <Igloo> so no, shouldn't break anything
15:36:03 <dons> and ghci can then use the package.conf to find the .o file
15:36:22 <sorear> alexj: an hour, no.  the problem is.... a braino, I was still thinking this had to be synchronous
15:36:37 <alexj> sorear: are we ok now?
15:36:45 <sorear> yes
15:36:51 <twanvl> omnId: I made a patch that fixes lambdabot's gender issues
15:36:56 <alexj> sorear: glad to be of service :-)
15:36:59 <SamB> twanvl: what?
15:36:59 * ddarius wants constant time...
15:37:03 <chessguy> @quote gender
15:37:04 <lambdabot> vincenz says: why do you want to be dynamicalyll gendered? lexically gendered is cleaner
15:37:05 <SamB> she has gender issues?
15:37:13 <sorear> @slap SamB
15:37:13 * lambdabot would never hurt SamB!
15:37:14 <sorear> @slap SamB
15:37:14 * lambdabot activates his slap-o-matic...
15:37:19 <SamB> ah
15:37:28 <omnId> twanvl: :)
15:37:28 <SamB> those gender issues
15:37:48 <SamB> twanvl: did you make it configurable?
15:37:50 <UUStudent> hello all, would anyone be kind enough to help me with a little haskell problem?
15:38:01 <dmwit> Just ask.
15:38:59 <UUStudent> I'm trying to make a hex calculator
15:39:00 <chessguy> @pl \w x y z -> w y x z
15:39:00 <lambdabot> flip
15:39:04 <chessguy> cute
15:39:16 <UUStudent> so input as a string and output int
15:39:23 <ehird`> UUStudent: "I'm trying to make a hex calculator"
15:39:30 <chessguy> @pl \f l i p -> f i l p
15:39:30 <lambdabot> flip
15:39:34 <UUStudent> am I right in thinking I need to define A-F characters first?
15:39:40 <ehird`> chessguy: hehe
15:39:40 <UUStudent> I'm very newbie :)
15:39:42 <Olathe> @pl \w a b c d e f -> w e b a f c
15:39:42 <lambdabot> ((((const .) . flip . (flip .)) .) .) . flip . (flip .) . flip
15:39:49 <ehird`> UUStudent: you have some unicodeness there
15:39:51 <sorear> :t readIntAtBase
15:39:53 <lambdabot> Not in scope: `readIntAtBase'
15:39:56 <ddarius> UUStudent: Are you new to programming in general?
15:39:57 <sorear> ehird`: no, not unicode
15:39:59 <omnId> UUStudent: the 'A' to 'F' characters are already in the Char type :)
15:40:02 <ddarius> :t readHex
15:40:02 <ehird`> sorear: well, some garbage
15:40:04 <UUStudent> yes in general
15:40:04 <lambdabot> forall a. (Num a) => String -> [(a, String)]
15:40:05 <ehird`> @pl \o r d e r -> c h a o s
15:40:06 <twanvl> SamB: No, that would probably require a full rewrite of vixen :) It is just back to 'her'
15:40:06 <lambdabot> const . const . const . const . flip (c h a) s
15:40:06 <Olathe> Representing permutations with flip, ., and const.
15:40:07 <UUStudent> I have done a little java
15:40:22 <omnId> > readHex "DEADBEEF"
15:40:23 <lambdabot>  [(3735928559,"")]
15:40:23 <UUStudent> I mean A = 10, B = 11 etc
15:40:31 <dons> twanvl: do you have a code.haskell.org account?
15:40:44 <dons> i've moved lambdabot over to code.haskell.org
15:40:47 <dons> and encourage
15:40:48 <sorear> I am appalled that people that people consider "unicode" and "garbage" synonymous.
15:40:50 <dons> people to get accounts
15:40:51 <Olathe> > (fst. head . readHex) "DEADBEEF"
15:40:51 <monochrom> Yeah, just use readHex.
15:40:52 <lambdabot>  3735928559
15:40:53 <sorear> APOLOGIZE TO THE LAMBDA!
15:40:55 <sorear> :)
15:40:55 <dmwit> UUStudent: It might make sense to have a function (f :: Char -> Int) that understands the value of a single digit.
15:41:12 <UUStudent> ok
15:41:15 <UUStudent> that sounds useful
15:41:20 <monochrom> This sentence is in Unicode.
15:41:22 <Beelsebob_> dons, sorear, thanks for your help... I was merely being a moron, but you confirmed I was being a moron in the right way
15:41:23 <SamB> http://code.haskell.org/ is kinda boring for a front page
15:41:24 <lambdabot> Title: Index of /
15:41:26 <Olathe> > (oh. my. god) rotfl
15:41:26 <UUStudent> I cant use readhex, I need to code the function lol
15:41:27 <lambdabot>   Not in scope: `rotfl'
15:41:34 <ehird`> sorear: hah
15:41:37 <monochrom> "need"? Pardon me?
15:41:42 <ehird`> sorear: i just meant, stray characters
15:41:53 <twanvl> dons: not yet, I'll get one now
15:42:00 <dmwit> monochrom: It's probably a university exercise, see his nick. =)
15:42:09 <UUStudent> need? sorry english is not my best language
15:42:14 <sorear> SamB: I like it.  It's far better than the old homepage which had no links at all, much less a list of projects.
15:42:33 <dons> twanvl: once you've got an account , let me know, and you can just commit straight to the bot
15:42:35 <ehird`> dmwit: people seem to actively dislike actually learning things, don't they?
15:42:36 <dons> sorear: you to.
15:42:38 <chessguy> @src readhex
15:42:38 <lambdabot> Source not found. That's something I cannot allow to happen.
15:42:41 <chessguy> pity
15:42:50 <sorear> @src readHex
15:42:50 <lambdabot> Source not found. You untyped fool!
15:42:50 <monochrom> you spelt wrong
15:42:56 <chessguy> oops
15:43:01 <UUStudent> I don't want the answer obviously, just a little direction would be helpful
15:43:04 <chessguy> hey, is that a new insult?
15:43:12 <monochrom> may need to say Numeric.readHex or something.
15:43:24 * dmwit wonders how to untype something.  Backspace, maybe?
15:43:34 <ehird`> dmwit: you can't unsee^W^W^Wtype things
15:43:35 <Beelsebob_> dons, sorear: is it possible to specify a directory to look for object code in?
15:43:38 <ehird`> err
15:43:39 <dmwit> ?src readHex fool^H^H^H^H
15:43:39 <ehird`> s/W/H/
15:43:39 <lambdabot> Source not found.
15:43:45 <UUStudent> ah ok
15:43:47 <dmwit> I untyped fool!
15:44:02 <sorear> Beelsebob_: cd?
15:44:21 <Beelsebob_> sorear: yeh, but I'm loading source code from the directory I'm currently in
15:44:22 <sorear> chessguy: yes, twanvl's patch
15:44:52 <monochrom> Recall that  is the backspace untype character!
15:45:23 <omnId> monochrom: "backspace untype"?  Ooooh, what's the codepoint?
15:45:33 <monochrom> 8
15:45:34 <UUStudent> where can I read the source for readHex, that might be useful to view?
15:46:06 <omnId> monochrom: I thought you meant a character that undoes U+8
15:46:09 <allbery_b> @source Numeric
15:46:09 <lambdabot> http://darcs.haskell.org/packages/base/Numeric.hs
15:46:17 <dmwit> I doubt it will be helpful, though.
15:46:24 <lamode> oh :(
15:46:49 <dmwit> ?source Text.Read.Lex
15:46:49 <lambdabot> http://darcs.haskell.org/packages/base/Text/Read/Lex.hs
15:47:08 <sorear> isn't it U+0008?
15:47:19 <lamode> ty
15:47:43 <omnId> sorear: probably
15:49:09 <lamode> ah
15:49:15 <lamode> this seems very complicated for me :)
15:49:23 <dmwit> Yeah, just try to write it yourself.
15:49:27 <ddarius> Yeah, that definition is overkill.
15:49:30 <dmwit> You don't need something so general as what readHex does.
15:49:33 <lamode> ok
15:49:35 * ddarius hasn't even looked at the definition.
15:49:41 <lamode> hehe
15:50:02 <monochrom> I wonder if you know how to turn "2385" into 2385, even for decimals.
15:50:18 <lamode> yes that would be a good start
15:50:23 <lamode> I guess a string into an integer
15:50:53 <lamode> so changetoInt :: String -> Int
15:51:58 <ddarius> (Actually, I have looked at the definition, just not for a long long time.)
15:51:58 <ehird`> monochrom: parsing integers isn't hard
15:52:05 <ehird`> floats are where it gets complicated ;)
15:52:07 <ddarius> ehird`: Indeed
15:52:10 <ddarius> > read "132"
15:52:13 <ehird`> well, just marginally so
15:52:15 <monochrom> No float necessary today.
15:52:22 <lambdabot>  132
15:52:29 <ehird`> i mean, for each digit it's just (* 10) + digit
15:52:34 <ehird`> or rather, * bas
15:52:34 <ehird`> e
15:52:52 <monochrom> My point is if you know how to do it for decimals you know how to do it for any base.
15:52:57 <LoganCapaldo> you may want to support 1.23e-3 type stuff
15:53:00 <lamode> ahh this seems much harder than java!
15:53:11 <ehird`> lamode: that's because you're used to java i suspect
15:53:13 <lamode> right mono
15:53:22 <lamode> yes, I suppose
15:53:23 <monochrom> How do you do it in Java?
15:53:27 <ehird`> LoganCapaldo: yeah but that's just a lot of work
15:53:31 <ehird`> monochrom: java has a parseInt function
15:53:35 <ehird`> monochrom: it basically does it for you ;)
15:53:43 <monochrom> Well we have readDec.
15:54:11 <LoganCapaldo> > let { parseInt :: String -> Int ; parseInt = read } in parseInt "23" -- am I missing something?
15:54:12 <lambdabot>  23
15:54:30 <lamode> in java, I could use a library
15:54:30 <ehird`> LoganCapaldo: umm so basically read "23"? :P
15:54:34 <lamode> parseInt or something
15:54:41 <ehird`> lamode: same with haskell: read
15:54:46 <ehird`> > readDec "564654"
15:54:47 <lambdabot>  [(564654,"")]
15:54:48 <monochrom> in haskell, you could use readHex and readDec.
15:54:53 <idnar> in java, I could use a librarHHHHHHHHHHHy
15:54:55 <idnar> oops
15:55:05 <lamode> yeah, but the point is I cannot use that here
15:55:14 <sorear> that doesn't make haskell harder
15:55:14 <ehird`> lamode: then you'd have to do this in java too
15:55:15 <lamode> sorry for being very stupid
15:55:25 <ehird`> if you can't use a library then "in java i could use a library" is dumb :)
15:55:26 <sorear> try writing it in java without parseInt
15:55:26 <monochrom> So it is unfair to say "harder than java", no?
15:55:33 <Beelsebob_> awesome :)
15:55:35 <lamode> no harder lol
15:55:44 <Beelsebob_> got bits of hat working in ghci
15:55:45 <lamode> I just suck at programming in genereal perhaps
15:55:55 <sorear> even without a library, this is a oneliner in haskell
15:56:18 <idnar> oneliners are the hardest ;)
15:56:23 <lamode> that helps
15:56:27 <LoganCapaldo> is the Prelude a library? :)
15:56:34 <lamode> at least there wont be too much to write
15:56:38 <monochrom> You know how to deal with "2", "3", "0", etc.
15:56:39 <ehird`> LoganCapaldo: writing something without the prelude will be tricky ;)
15:56:44 <lamode> when I eventually get get my head round it
15:56:53 <LoganCapaldo> but isn't read in the prelude? ;)
15:56:56 <lamode> yes mono
15:57:38 <monochrom> If you have "2385", break it into "2" and "385". "2" you can deal with. "385" just use recursion. Then there is some obvious extra work to do to "combine" them.
15:57:52 <ehird`> monochrom: mainly, (* base) + rest
15:57:53 <ehird`> ;)
15:58:05 <monochrom> Don't tell it to me. Tell it to those who ask.
15:58:22 <ehird`> hehe
15:58:28 <lamode> so it would be bad to define A-F as ints then use the hex *16^2 sum etc
15:59:14 <monochrom> A is not an int. No way you can "define" it to be an int either. But you can say, when I see "A" I return 10.
15:59:25 <lamode> yes this is what I mean, sorry
15:59:56 <ehird`> monochrom: ascii stuff is probably the simplest although not portable (pff who uses non-ascii platforms?) ;)
16:00:06 <ehird`> there's a block for 0-9, a block for A-F
16:00:18 <ehird`> two little bits of code and you've got your "hexDigit"
16:00:19 <monochrom> Haskell is emphatically defined to stick to Unicode, don't worry.
16:00:29 * ddarius breaks out the 2-level van Wijngaarden grammars
16:00:35 <ehird`> monochrom: is it?
16:00:37 <lamode> how can I say this? define A as 10? or rather alias A to 10
16:00:37 <ehird`> i never knew that
16:00:39 <monochrom> Any EBCDIC implementation of Haskell is simply wrong, for example.
16:00:44 <ehird`> lamode: you don't
16:00:47 <ehird`> hexDigit "A" = 10
16:00:51 <ehird`> <etc>
16:00:56 <lamode> and so forth
16:01:01 <lamode> ok
16:01:10 <lamode> I understand this much!
16:01:11 <ehird`> just go from hexDigit "0" to hexDigit "F"
16:01:20 <ehird`> it's obviously not the shortest way to do it, but it's the simplest ;)
16:01:22 <omnId> hexDigit is a function that when given the string "A", returns 10
16:01:25 <lamode> yeah, I figure this
16:01:29 <monochrom> Yeah, KISS.
16:01:34 <lamode> KISS?
16:01:38 <ehird`> keep it simple stupid
16:01:44 <lamode> ah ty
16:01:49 <monochrom> keep it simple and stupid.
16:01:55 <ehird`> monochrom: keep it simply stupid
16:01:59 <lamode> It doesnt need to be fast, just to work I guess :)
16:01:59 <ehird`> keep it stupidly simple
16:02:08 <ehird`> lamode: actually, that's probably the fastest way
16:02:08 <ehird`> =)
16:02:18 <ehird`> (oh, you should probably do hexDigit 'A' instead of "A")
16:02:18 <lamode> thanks for your help
16:02:22 <ehird`> (since, they'll always be one character)
16:02:25 <lamode> right
16:02:46 <monochrom> K, I, S are the combinators...
16:03:02 <idnar> keep it stupid, simple!
16:03:05 <ehird`> @pl K I S S
16:03:05 <lambdabot> K I S S
16:03:11 <ehird`> @pl KISS = K I S S
16:03:11 <lambdabot> KISS = K I S S
16:03:14 <ddarius> KISS would just be S
16:03:19 <ehird`> :)
16:03:23 <ehird`> "Stupid!"
16:03:30 <LoganCapaldo> Simple!
16:03:47 <monochrom> @remember ddarius KISS would just be S
16:03:48 <lambdabot> Done.
16:04:54 <lamode> are there any large scale programs built on haskell out of interest
16:05:02 <ehird`> lamode: lots
16:05:06 <lamode> I mean, commercially, like java
16:05:09 <ehird`> (err, someone else name them)
16:05:14 <lamode> hehe
16:05:38 <ehird`> (quick! the "i see this is just an academic language" time bomb is ticking!)
16:05:42 <monochrom> You won't see commercial ones because they are trade secrets, NDA etc.
16:05:52 <ehird`> monochrom: sneaky
16:05:53 <ehird`> ;)
16:06:09 <lamode> hmm
16:06:15 <lamode> ehird is correct
16:06:22 <lamode> this is exactly what I am thinking :)
16:06:22 <ehird`> oh dear
16:06:27 <ehird`> quick! purge your brain!
16:06:29 <monochrom> You can see FOSS ones such as darcs and xmonad.
16:06:41 <ehird`> someone is bound to name lots and lots of commercial haskell projects and prove to you haskell is not just academic!
16:06:48 <ehird`> (that was a subtle hint to whoever just joined the channel)
16:06:53 <lamode> :)
16:07:09 <LoganCapaldo> can't we just point a finger at galois?
16:07:37 <lamode> well, it just doesnt seem to have much real world application from my very limited exposure (2 weeks)
16:08:03 <ehird`> lamode: it certainly does, in my opinion (although having tried to learn haskell 2 times already and not completely succeeding yet but trying my opinion may be biased)
16:08:09 <ehird`> (and/or flawed)
16:08:11 <pejo> lamode, Linspire had an experience report at ICFP this year.
16:08:17 <LoganCapaldo> http://www.galois.com/methods.php
16:08:18 <lambdabot> Title: Methods
16:08:26 <lamode> Linspire? really
16:08:44 <sorear> lamode: Most of the reason haskell is interesting is intrinsic.  It's the canonical language with pervasive lazy evaluation and qualified type inference.  Anyone who seriously intends to study programming languages is an idiot if the disregard Haskell's family (of which Haskell is the only living member now)
16:08:45 <ehird`> it is not good to have your language used by linspire!!!!!
16:08:46 <ehird`> :(
16:09:09 <sorear> @seen stepcut
16:09:10 <lambdabot> I saw stepcut leaving #haskell 8h 9m 58s ago, and .
16:09:30 <monochrom> I forgot pugs.
16:09:38 <lamode> linspire was awful last time I tried it
16:09:46 <ehird`> lamode: hint: it still is
16:09:52 <ehird`> linspire is awful and terrible and aaauuuergh
16:10:06 <pejo> lamode, ABN AMRO had a talk about tehir use of Haskell at CUFP. http://cufp.galois.com/2007Schedule.html
16:10:07 <lambdabot> Title: Commercial Users of Functional Programming 2007 Program
16:10:18 <lamode> well, I study c and java, and now we're being forced into haskell and at the moment its just too different hehe
16:10:24 <lamode> ty pejo
16:10:32 <sorear> C *and* Java?
16:10:35 <ehird`> c is alright for low-level stuff, but java should be outlawed ;)
16:10:38 <sorear> that's not an academic course
16:10:40 <lamode> yeah, a little c, mainly java
16:10:48 <Nico_Reed> can someone explain to me what lambda calculus adds to the programming mix?
16:10:55 <TSC> Greek
16:11:04 <Notrix> can someone give me a hint how can I build a unit matrix with the parameter the size of the row
16:11:05 <ehird`> TSC wins this question, you can all go home now
16:11:08 <sorear> there isn't enough difference between C and Java to warrant teaching both in a CS program.
16:11:24 <sorear> I think you entered a vocational school by mistake.
16:11:31 <lamode> hehe, no
16:11:46 <lamode> just the basics of c and how it in fluenced java
16:11:52 <dibblego> Nico_Reed, can you explain what, besides the foundation of lambda calculus, adds to programming?
16:12:10 <ehird`> dibblego: fortran!
16:12:34 <lamode> pejo: there are lots of real world applications, I take it back!
16:12:40 <Nico_Reed> well lambda calculus (from what I understand) looks like just functions. Is that true? and if so, what does it really do?
16:12:54 <ehird`> Nico_Reed: you misunderstand
16:13:01 <ehird`> lambda calculus is theory, it's a theory of functions
16:13:04 <ehird`> it defines what functions ARE
16:13:06 <ehird`> and what application is
16:13:13 <monochrom> Few programmers understand functions.
16:13:13 <ehird`> it is the founding for just about every functional programming language
16:13:20 <ehird`> (well... not Joy ;))
16:13:45 <dibblego> few programmers understand programming
16:13:56 <mrd> java should never be taught in computer science programs
16:13:57 <LoganCapaldo> few programers understand programs
16:14:05 <lamode> mrd: why not?
16:14:07 <dibblego> mrd, agreed
16:14:09 <Nico_Reed> alright.. so if its the theory of functions.. what does it exact DO?
16:14:10 <monochrom> lambda calculus : programming :: highschool algebra : engineering
16:14:17 * mrd also has trouble believing there are people who graduate from CS and don't know what the lambda calculus is
16:14:18 <dibblego> lament, because it is a perversion of computer science
16:14:31 <sorear> Naktibalda:
16:14:33 <dibblego> http://java.sun.com/docs/books/tutorial/getStarted/intro/changemylife.html -- enjoy
16:14:35 <sorear> blech
16:14:35 <lambdabot> Title: How Will Java Technology Change My Life? (The Java&trade; Tutorials > Getting St ..., http://tinyurl.com/2utgva
16:14:44 <sorear> mrd: I don't beleive you.
16:14:46 <sorear> :)
16:15:03 <ehird`> mrd: yeah
16:15:05 <ehird`> Nico_Reed: ???
16:15:09 <lamode> CS is only half my course, thank the lord :)
16:15:10 <ehird`> Nico_Reed: it's not a programming language
16:15:14 <ehird`> Nico_Reed: it was about before programming languages
16:15:18 <dmwit> Notrix: Try writing a function (singleRow width i = ....) which would have a 1 in the i'th entry, and enough 0's to make it width wide.
16:15:23 <ehird`> Nico_Reed: it defines what applying functions to arguments is, and what functions are.
16:15:26 <Nico_Reed> no no.. i mean how is it related to programming?
16:15:31 <mrd> lamode: because it's a horrible language which brings absolutely nothing of educational value
16:15:38 <ehird`> Nico_Reed: haskell, at the core, is lambda calculus. its function model and application model are identical, pretty much
16:15:44 <ehird`> Nico_Reed: same with lisp although less so
16:15:50 <lamode> mrd: nothing? everyone keeps telling me its the future of OO progrmaming
16:15:59 <mrd> and i'm ashamed to say that the java people came from here, and they promote it here, even while admitting that it sucks
16:16:01 <LoganCapaldo> It's a model of computation. you could "compile" a program to lambda calculus
16:16:02 <ehird`> Nico_Reed: in a sense, LC was the "first" functional language -- but before languages existed
16:16:14 <dibblego> lament, they are victims of hyperbole; though, "nothing" is incorrect; it causes *damage* - it has an adverse effect, less than nothing
16:16:23 <Nico_Reed> alright.. so LC is a functional language?
16:16:28 <mrd> lamode: more like the past. and OO programming is pure hype, i think we've learned in the past 10 years.
16:16:31 <sorear> lamode: it's the future of programming, just like 100-foot flooding is the future of climate
16:16:34 <lament> dibblego: second warning!
16:16:42 <dibblego> lament, sorry
16:16:42 <lamode> hehe
16:16:48 <lamode> so, the future of OO programming is?
16:16:58 <ehird`> lamode: hopefully? death.
16:16:59 <sorear> lamode: besides, CS has almost nothing to do with programming
16:17:01 <mrd> into the trash bin of history
16:17:01 <dibblego> lamode, non-existent?
16:17:02 <ehird`> ;)
16:17:11 <ehird`> (lamode now dismisses haskell forever)
16:17:18 <lamode> and what is this alternative future you invisiage?!
16:17:19 <mrd> only to be replaced by the next shiny buzzword oh well
16:17:23 <lament> i'm a big fan of OO
16:17:26 <ehird`> lamode: programs that work solidly
16:17:38 <sorear> lamode: what was that Dijkstra quote?  Computer science is as much about computers as astronomy is about telescopes.
16:17:45 <Excedrin> Nico_Reed: http://en.wikipedia.org/wiki/Lambda_calculus
16:17:46 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
16:17:49 <lamode> right
16:18:01 <Nico_Reed> actually a better question.. what is the difference between "square x = x*x" and "square = \x-> x*x"?
16:18:04 <lament> OO is a great thing, it's just still in early stages of development, the concepts are not quite right
16:18:16 <ehird`> Nico_Reed: the first is sugar for the second
16:18:17 <sorear> and if you can graduate any CS program without learning to worship Dijkstra .... the world is BOOMED
16:18:17 <dibblego> Nico_Reed, very little (little enough to be nothing for now)
16:18:18 <LoganCapaldo> Nico_Reed: nothing?
16:18:23 <Cale> sorear: Am I the only one who thinks that programming is something which should be done by computer scientists?
16:18:35 <dibblego> Cale, there is at least one more person
16:18:35 <lamode> when I've done this hex thing, haskell will be at the top fo my favourite languages :)
16:18:56 <monochrom> Cale: I think you should omit "scientists" and that will be my vision. :)
16:19:01 <LoganCapaldo> who else is gonna do the programming? Novelists?
16:19:04 <Cale> heh
16:19:06 <Nico_Reed> alright.. so the whole "\x -> ..." thing is really needed? Is there a time you really do not need it?
16:19:10 <mrd> Cale: shush, get back to your blackboard and prove a theorem
16:19:13 <Cale> Programming should be thought of as a branch of applied mathematics.
16:19:15 <LoganCapaldo> it's backwards
16:19:17 <Nico_Reed> do need it*
16:19:19 <ehird`> Nico_Reed: i don't think you quite understand -- haskell is LC + other stuff
16:19:23 <LoganCapaldo> the square = thing is not really needed
16:19:30 <ehird`> Nico_Reed: at the core of haskell, almost everything involves lambdas
16:19:30 <sorear> Cale: Yes, you need to know CS to be a good programmer.  But they don't teach you about safety factors and magic numbers in Physics.
16:19:34 <ehird`> you just don't always see them in practice
16:19:53 <Nico_Reed> alright thanks you guys.. i think i get it
16:20:01 <dibblego> > (\x -> x * x) 7
16:20:07 <dcoutts> dons: do you want the project repo to be code.h.o/quickcheck or code.h.o/QuickCheck
16:20:08 <sorear> Cale: In physics you learn the elegant principles.  The garbage known as "practice" is contained within Engineering.
16:20:13 <Excedrin> does programming involve the scientific method? why is it called "computer science"?
16:20:13 <lambdabot>  49
16:20:16 <Notrix> dmwit, I could write something recursive, but do you think there's a simpler way using high order functions ?
16:20:20 <sorear> Cale: That's how I think it should be with CS and CE...
16:20:43 <ehird`> Excedrin: computer science is not about computers, really
16:20:48 <ehird`> it should be "COMPUTATIONAL science"
16:20:49 <Cale> Excedrin: not really, no. It's a historical mistake of a name.
16:20:52 <mattam> computing
16:20:53 <Excedrin> but is it about science?
16:20:53 <ehird`> that would be much more accurate
16:21:00 <dcoutts> @seen dons
16:21:00 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 5m 26s ago.
16:21:03 <Cale> It's not really about computers, and it's not really a science.
16:21:04 <ehird`> Excedrin: what do you call science?
16:21:07 <Nico_Reed> Excedrin I would think so.. you guess that you function works.. you compile and experiment.. and then you gather results
16:21:09 <dmwit> Notrix: You shouldn't need higher-order functions; have a look at replicate.
16:21:14 <Excedrin> Nico_Reed: hahaha
16:21:16 <ehird`> computational science is pretty accurate IMO
16:21:18 <dibblego> how about "logic"?
16:21:25 <TomMD> A wise man once said: "All scientific subjects is rather little science and lots of math."
16:21:30 <monochrom> Is your program invented or discovered?
16:21:34 <Cale> ehird`: Except for that 'science' bit :)
16:21:47 <dibblego> computational logic
16:21:52 <Excedrin> what's the procedure for adding quotes to lambdabot
16:21:58 <ehird`> monochrom: proprietary software companies are getting a hitman for you right now
16:21:59 <dibblego> Excedrin, ?where+
16:22:03 <sorear> no!
16:22:03 <Excedrin> because that was worthy
16:22:04 <dibblego> Excedrin, oops
16:22:04 <TomMD> monochrom: I guess that depends what country you ask...
16:22:04 <Korollary> remember for quotes
16:22:14 <dibblego> Excedrin, @remember
16:22:15 <sorear> Excedrin: @seen twanvl, I think
16:22:36 <Cale> Discovery is really the same thing as invention anyway. At the very least, you're inventing a name for something.
16:22:37 <Excedrin> @remember Nico_Reed Excedrin I would think so.. you guess that you function works.. you compile and experiment.. and then you gather results
16:22:37 <lambdabot> I will remember.
16:22:37 <monochrom> Programming is a religion because I write my program by Intelligent Design not Natural Selection.
16:22:48 <ehird`> monochrom: haha
16:22:52 <ehird`> monochrom: genetic algorithms!
16:22:54 <idnar> monochrom: you don't use genetic algorithms?!
16:22:58 <monochrom> If you write your programs by Natural Selection, you can call it a science.
16:23:02 <twanvl> sorear: ?
16:23:04 <ehird`> idnar: ;)
16:23:05 <dibblego> monochrom, http://jatheism.net
16:23:06 <lambdabot> Title: JAtheism
16:23:11 <Korollary> He intelligently designs the fitness function, too
16:23:30 <idnar> haha
16:23:30 <ehird`> Korollary: no, that designs itself
16:23:31 <ehird`> :D
16:23:39 <ehird`> it evolves itself from god's prototype!
16:23:44 <ehird`> it is the adam/eve of fitness functions
16:23:44 <ehird`> :P
16:24:05 <ehird`> haha, imagine if the one time we achive strong AI is in a game like the sims
16:24:15 <ehird`> you'd be able to literally burn the nonbelievers
16:24:19 <Notrix> dmwit, I see how I can use it, but I can't find a "nice/beautiful" way to do it :(
16:24:27 <ehird`> and they'd protest for rights and tolerance
16:24:32 <ehird`> and you'd get AI holy wars
16:24:42 <monochrom> I don't use genetic algorithms yet. I don't rule out the possibility that you can get it to work nicely.
16:24:42 <ehird`> and they'd deny that they could be emulated by any computational process
16:25:12 <TomMD> ehird': No matter how you punish, the AI will still evolve non-believers.  It is in the computers nature to question if it is a computer.
16:25:25 <fnord123> anyone know of any papers on how to store funargs so they can be passed generically? I'm interested in serializing a function call but want to stay within the typesystem.
16:25:27 <ehird`> TomMD: you should be a philosopher
16:25:28 <ehird`> :P
16:26:00 <fnord123> erlang and scheme, for example, use heterogenous lists.
16:26:11 <mrd> no, they're homogenous
16:26:17 <mrd> everything is of one type
16:26:27 <ddarius> ehird`: They would be right in the existence of GOd.
16:26:30 <dmwit> Notrix: You could also consider generating the top row and left column, then recursing.
16:26:39 * LoganCapaldo agrees with mrd's interpretation
16:26:47 <dibblego> same
16:26:47 <dmwit> Notrix: But I'd recommend the "dirty" map/replicate version for efficiency.
16:27:10 <fnord123> mrd, (+ 1 "pie") ;can
16:27:13 <alexj> @seen lemmih
16:27:13 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 4h 23m 26s ago.
16:27:15 <mrd> fnord123: functions have one argument, what do you mean by funarg*s*
16:27:19 <fnord123> ;can't be added due to different types
16:27:36 <mrd> fnord123: but it can compile
16:27:40 <Korollary> oh holy debate of nomenclature
16:27:54 <dmwit> > let row width n = replicate n 0 ++ 1 : replicate (width - n) 0 in row 3 0
16:27:55 <mrd> (I agree with you, sorta, just being picky)
16:27:56 <Korollary> I am glad that somebody (e.g. Bob Harper) finally wrote something about it
16:28:06 <lambdabot>  [1,0,0,0]
16:28:08 <mrd> funny that's who I was thinking of too
16:28:35 <dmwit> > let row width n = replicate n 0 ++ 1 : replicate (width - n - 1) 0; identity size = map (row size) [0..size - 1] in identity 3
16:28:36 <lambdabot>  [[1,0,0],[0,1,0],[0,0,1]]
16:28:40 <fnord123> sure enough. alright, well in haskell, we have each function curried; so I would like the full uncurried function serialized with the arguments.
16:28:53 <mrd> serialized?
16:28:54 <LoganCapaldo> fnord123: that's a lost cause
16:29:07 <sorear> mrd: funarg is lisp jargon for a higher order function argument, like the callback to map
16:29:09 <mrd> as in the code? decompiled?
16:29:11 <sorear> *mapcar
16:29:12 <fnord123> im guessing i need something like an s-expression parser and printer. :)
16:29:16 <LoganCapaldo> how do you know when it's the "full" function?
16:29:27 <dmwit> > let row width n = replicate n 0 ++ 1 : replicate (width - n - 1) 0; identity size = map (row size) [0..size - 1] in identity 0
16:29:28 <lambdabot>  []
16:29:43 <ehird`> fnord123: the problem is f x y z = BLAH is just f = \x -> \y -> \z -> BLAH
16:29:47 <ehird`> there's literally no way
16:29:58 <fnord123> *deep sigh*
16:30:13 <ehird`> why do you want it
16:30:40 <fnord123> toying w/ haskell impl of termite
16:31:29 <lament> the full uncurried function is your program :)
16:31:33 <dmwit> :t intersperse
16:31:34 <Notrix> dmwit, thank you I'll have a deep look on this
16:31:35 <lambdabot> forall a. a -> [a] -> [a]
16:31:45 <dmwit> Notrix: Hold on one second, I just had another thought. =)
16:31:50 <Notrix> :)
16:32:19 <dmwit> > let flattened n = intersperse [1] . replicate n . replicate n $ 0 in flattened 3
16:32:21 <lambdabot>  [[0,0,0],[1],[0,0,0],[1],[0,0,0]]
16:32:46 <ddarius> impressive
16:32:59 <Olathe> @pl \n -> intersperse [1] . replicate n . replicate n $ 0
16:33:00 <lambdabot> flip (intersperse [1] .) 0 . liftM2 (.) replicate replicate
16:33:02 <dmwit> > let flattened n = intersperse (replicate n 0) (replicate (n+1) [1])
16:33:02 <lambdabot>  Parse error
16:33:37 <dmwit> > let flattened n = intersperse (replicate n 0) (replicate (n+1) [1]) in flattened 3
16:33:38 <lambdabot>  [[1],[0,0,0],[1],[0,0,0],[1],[0,0,0],[1]]
16:34:03 <dmwit> > let flattened n = concat $ intersperse (replicate n 0) (replicate n [1]) in flattened 3
16:34:04 <lambdabot>  [1,0,0,0,1,0,0,0,1]
16:34:05 <Cale> fnord123: If you want a function to work with a union of various types, you can create an explicit union type
16:34:16 <dmwit> Then the "chunk" function that everybody writes would get you the identity matrix. =)
16:34:37 <Cale> fnord123: data Something = I Integer | S String | C Char | ...
16:34:53 <Notrix> dmwit, nice :o
16:35:01 <ddarius> Not really...
16:35:04 <Cale> Er, sorry, you were talking about something else...
16:35:12 <Notrix> ddarius, explain
16:35:16 <dmwit> Notrix: I don't think it's better or more readable, just another way. =)
16:35:44 <fnord123> Cale, I was considering that, but it seems like a cheeky way to get around the type system. I was hoping there was a way to do this using the type system.
16:35:46 <Cale> But yeah, if you want a heterogeneous list, you can create a type for the elements of the list which handles the separate cases. Usually you have something more domain-specific in mind.
16:35:49 <Olathe> Wait, this is that fractal ?
16:35:55 <Nico_Reed> alright i have another question. How would you interate through each element of a list? "foreach" in other languages
16:36:06 <dmwit> map
16:36:08 <dibblego> Nico_Reed, map
16:36:09 <Olathe> Nico_Reed: map, usually.
16:36:11 <ddarius> Nico_Reed: It depends on what you want to do.
16:36:14 <twanvl> > let ident 1 = [[1]] ; ident n = (1:replicate (n-1) 0) : map (0:) (ident (n-1)) in ident 3
16:36:15 <lambdabot>  [[1,0,0],[0,1,0],[0,0,1]]
16:36:16 <Cale> The type system is a compile time thing. If you want runtime stuff, you should just use data.
16:36:30 <dibblego> Nico_Reed, or, some of those languages produce side-effects, so liftM or fmaop
16:36:32 <dibblego> *fmap
16:36:32 <Nico_Reed> would you use map even if the function has no return type?
16:36:41 <dibblego> Nico_Reed, functions *never* have no return type
16:36:53 <Cale> You *can* have heterogeneous lists in Haskell which are checked at compile time, but it's somewhat insanely complicated to do :)
16:36:59 <dmwit> twanvl: That's the "generate the top row and left column, then recurse" approach?
16:37:06 <Nico_Reed> you cant have a function that calculates the factorial and prints it out (as an example)
16:37:06 <dibblego> Nico_Reed, I think you mean, if they have side-effects, in which case, liftM/fmap
16:37:07 <Cale> (and involves at least a couple extensions)
16:37:22 <ddarius> mapM_
16:37:23 <dibblego> Nico_Reed, why not? (it would be side-effecting)
16:37:25 <LoganCapaldo> or forM
16:37:26 <dmwit> Nico_Reed: Then you want mapM
16:37:27 <dmwit> .
16:37:33 <Nico_Reed> alright
16:37:48 <Cale> Try this in ghci: forM_ [1..10] print
16:37:48 <ddarius> Haskell has more ways of processing lists than you can shake a stick at.
16:37:57 <Cale> (er, after :m + Control.Monad)
16:38:05 <twanvl> dmwit: yes
16:38:05 <dibblego> Nico_Reed, in Scala, the foreach function has a return type Unit, since it is side-effecting; Haskell calls it IO instead and it's a little more controlled
16:38:13 <Olathe> > let fact n = foldr (*) [1..n] in fact 5
16:38:14 <lambdabot>   add an instance declaration for (Num [t])
16:38:14 <lambdabot>     In the expression: let fact n...
16:38:17 <Olathe> No !
16:38:23 <LoganCapaldo> foldr1
16:38:26 <Olathe> > let fact n = foldr1 (*) [1..n] in fact 5
16:38:28 <lambdabot>  120
16:38:32 <LoganCapaldo> or foldr (*) 1
16:38:35 <LoganCapaldo> or
16:38:36 <Olathe> Oh.
16:38:38 <LoganCapaldo> product ;)
16:38:38 <ddarius> foldl1'
16:38:42 <dmwit> > let fact n = foldr1 (*) [1..n] in fact 0
16:38:42 <Olathe> > let fact n = foldr (*) 1 [1..n] in fact 5
16:38:45 <lambdabot>  Exception: Prelude.foldr1: empty list
16:38:45 <lambdabot>  120
16:38:53 <Olathe> > let fact n = foldr (*) 1 [1..n] in fact 0
16:38:55 <lambdabot>  1
16:39:02 <Cale> > let fac n = product . enumFromTo 1 in fac 5
16:39:04 <Olathe> @src foldr1
16:39:04 <lambdabot>  <Integer -> Integer>
16:39:04 <lambdabot> foldr1 _ [x]    = x
16:39:04 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
16:39:04 <lambdabot> foldr1 _ []     = undefined
16:39:09 <Cale> > let fac = product . enumFromTo 1 in fac 5
16:39:10 <lambdabot>  120
16:39:40 <Olathe> @pl \n -> foldr (*) 1 [2..n]
16:39:40 <lambdabot> foldr (*) 1 . enumFromTo 2
16:39:55 <Olathe> > let fact = foldr (*) 1 . enumFromTo 2 in fact 5
16:39:57 <lambdabot>  120
16:40:07 <LoganCapaldo> if product uses foldr and enumFromTo uses unfoldr, does fusion kick in and turn it into a loop?
16:40:08 <Olathe> > let fact = foldr (*) 1 . enumFromTo 2 in fact 0
16:40:10 <lambdabot>  1
16:40:23 <hpaste>  dibblego pasted "for Nico_Reed" at http://hpaste.org/3432
16:40:23 <Olathe> LoganCapaldo: I hope so.
16:40:27 <dmwit> > let fact n = fact' 1 n; fact' x 0 = x; fact' x n = fact' (x - 1) (n*x) in fact 5
16:40:28 <lambdabot>  -1
16:40:52 <Nico_Reed> ya i understand now. thanks dibblego
16:40:53 <dmwit> > let fact n = fact' 1 n; fact' x 0 = x; fact' x n = fact' (x*n) (n-1) in fact 5
16:40:55 <lambdabot>  120
16:41:07 <hpaste>  (anonymous) annotated "for Nico_Reed" with "(no title)" at http://hpaste.org/3432#a1
16:41:14 <Cale> Nico_Reed: do you understand the basics of monads?
16:41:39 <Cale> Nico_Reed: If you want, I can explain how things like foreach loops can just be library functions :)
16:41:41 <Olathe> > map print [1..10]
16:41:41 <Nico_Reed> uh.. im trying to grab the idea of functional languages..
16:41:43 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO...
16:41:58 <Nico_Reed> i mean i know how to program.. but the functional thing is new
16:42:02 <LoganCapaldo> sequins
16:42:17 <Cale> Nico_Reed: All right.
16:42:26 <dmwit> :t (foldl1' (>>) .) . map
16:42:28 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m a
16:42:35 <Nico_Reed> but monads are IO things right?
16:42:43 <Nico_Reed> like a way to do side-effects
16:42:46 <dibblego> Nico_Reed, no, IO things are monads
16:42:49 <LoganCapaldo> No, IO is a monad thing
16:42:49 <Cale> Nico_Reed: Well, one thing about functional programmers is that we like to create small programming languages to solve problems, rather than attacking the problem directly.
16:42:53 <Olathe> Monads are containers.
16:42:55 <dibblego> Nico_Reed, there are *many* other uses for monads
16:42:55 <dmwit> :t (foldl' (>>) (return ()) .) . map
16:42:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> [a] -> m ()
16:43:24 <dmwit> Hmmm, neither of those are quite right.
16:43:26 <LoganCapaldo> Olathe: are they? what about Like Cont, or Readeer? Are thos econtainers?
16:43:27 <dmwit> :t mapM
16:43:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:43:30 <Nico_Reed> alright i remember monads also for state..
16:43:38 <dmwit> :t mapM_
16:43:38 <LoganCapaldo> man i can't type at all
16:43:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:43:40 <Cale> Nico_Reed: Functional programmers like to write these things called combinator libraries.
16:43:41 <dibblego> Nico_Reed, there is a "state monad", sure
16:43:42 <Nico_Reed> but Cale what do you mean by that?
16:44:11 <Cale> Nico_Reed: A combinator library is a library with a rich enough API that using it is like using a small programming language embedded within the one you're using.
16:44:18 <conal> Anyone know where the Show instance for (a->b) lives?
16:44:39 <Cale> It defines some primitive computations, and some way to join those computations together into more complex and interesting ones.
16:44:42 <dmwit> I think that's a Typeable thing.
16:44:47 <dmwit> (@conal)
16:44:59 <Nico_Reed> alright.. so basically libraries type of thing in C/C++?
16:45:16 <Cale> Well, yeah, but only the richest sort of library.
16:45:34 <conal> Hm.  I remember seeing a module that just defines Show for functions, displaying as "<Function>" or some such.
16:45:35 <Nico_Reed> actually what attracted me about haskell was how short everything was :P
16:46:07 <Cale> For example, a combinator library for drawing might define some primitive drawing computations, and then some ways to compose existing drawings into more complicated ones programmatically.
16:46:25 <twanvl> conal: Text.Show.Functions
16:46:27 <fnord123> I think I wouldn't mind doing what unzip does and have a numerical arg for a tuple.
16:46:31 <Cale> For example, putting one drawing beside or on top of another, or replacing each line segment with another drawing.
16:46:34 <conal> twanvl: thanks!
16:46:37 <Nico_Reed> alright.. i understand now
16:46:55 <Cale> So that drawing library becomes like a small programming language unto itself.
16:47:09 <Cale> Another library might construct parsers
16:47:22 <Cale> You'd have small parsers which parsed single characters and stuff like that
16:47:30 <Cale> and then ways to combine those parsers together
16:47:44 <Nico_Reed> one last question before going back to the tutorials.. This is about the foldr/foldl. So "foldr (*) 0 [1..3]" what does that 0 really do? and how would a function that takes the place of (*) look like?
16:47:44 <Cale> for example, their concatenation, or choice between multiple parser
16:47:45 <Cale> s
16:48:07 <Cale> foldr f z xs replaces each (:) in xs with f, and the [] at the end with z
16:48:22 <Cale> Remember that a list is really made up of conses and nil.
16:48:37 <Nico_Reed> ya.. i got that. but whats the 0 suppose to mean?
16:48:50 <fnord123> it's the initial value.
16:48:57 <Cale> The 0 is what the [] at the end of the list is replaced with
16:49:08 <Nico_Reed> hm. i see
16:49:18 <Cale> I don't know if it's right to call it initial, as it's really only used at the end of the computation :)
16:49:23 <idnar> > foldr (*) 0 [1..3]
16:49:24 <lambdabot>  0
16:49:52 <Cale> > foldr (*) 1 [1..3]
16:49:53 <lambdabot>  6
16:49:59 <LoganCapaldo> it's the tailial value :)
16:49:59 <Cale> Nico_Reed: anyway, monads...
16:50:01 <Nico_Reed> well i guess that was a bad example i ment add :P.. but can someone write a function that could replace the (*)?
16:50:02 <dmwit> > foldr (*) 1 [1..0] -- also works as expected
16:50:04 <lambdabot>  1
16:50:23 <dmwit> > let a * b = a + b in 3 * 7
16:50:25 <lambdabot>  10
16:50:37 <Cale> > foldr (\x xs -> concat ["(f ",x," ",xs,")"]) "z" ["1","2","3"]
16:50:38 <lambdabot>  "(f 1 (f 2 (f 3 z)))"
16:50:44 <Olathe> > foldr (\a b -> a + 3*b - b^2) 0 [1..3]
16:50:45 <lambdabot>  3
16:51:16 <Nico_Reed> what is the x? what place its in?
16:51:21 <Nico_Reed> oh nvm
16:51:21 <Cale> > foldr (\x xs -> 1 + xs) 0 "Hello, there"
16:51:22 <lambdabot>  12
16:51:33 <Cale> (that's length)
16:51:38 <Olathe> O-o
16:51:39 <vincenz> @source length
16:51:39 <lambdabot> length not available
16:51:42 <idnar> > foldr (:) [] [1..3]
16:51:43 <lambdabot>  [1,2,3]
16:51:58 <augustss> @src length
16:51:58 <lambdabot> Source not found. :(
16:52:02 <Cale> > let map f = foldr ((:) . f) [] in map (*10) [1..3]
16:52:03 <lambdabot>  [10,20,30]
16:52:04 <vincenz> Cale: or simply
16:52:11 <Nico_Reed> wow this conversation really did help.. thanks
16:52:12 <vincenz> > foldr (const (+1)) 0 "Hello there"
16:52:12 <Olathe> Cale: How does that length lambda work ?
16:52:13 <lambdabot>  11
16:52:17 <fnord123> > mapM (const [1..5]) [True, False]
16:52:18 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[2,1],[2,2],[2,3],[2,4],[2,5],[3,1],[3,2],[3,...
16:52:25 <vincenz> Olathe: he gave it odd names
16:52:27 <Olathe> Oh, I see.
16:52:29 <vincenz> Olathe: the 'xs' is the current length
16:52:36 <Olathe> The initial value comes at the end.
16:52:52 <Cale> Olathe: It replaces each cons with the function which ignores the list element and adds 1 to the "tail"
16:53:02 <Cale> and replaces the nil at the end with a 0
16:53:16 <Olathe> Right. xs is a bit confusing name, though.
16:53:20 <Cale> Nico_Reed: I wanted to say something about monads in general...
16:53:24 <vincenz> xs tends to imply a list
16:53:43 <Cale> Nico_Reed: Monads are a way to structure particular kinds of combinator libraries so that they can share code.
16:53:54 <Olathe> > foldr (\_ len -> 1 + len) 0 "Hi"
16:53:56 <lambdabot>  2
16:54:09 <idnar> @pl \_ len -> 1 + len
16:54:09 <lambdabot> const (1 +)
16:54:56 <Olathe> Cute
16:55:05 <Cale> Nico_Reed: In particular, a monadic combinator library is one whose "computations" have results, there's a way to produce the "computation" which just "does nothing" and returns a particular result, and there's a way to chain computations together, so that what follows can depend on the result of what came before.
16:55:09 <Olathe> const is quite nice.
16:55:20 <vincenz> > map chr . reverse . map ord $ "æš«é›¢"
16:55:21 <lambdabot>  "\38626\26283"
16:55:26 <Olathe> O-o
16:55:26 <Cale> Nico_Reed: Basically any such library is a monad.
16:55:34 <Nico_Reed> so.. sorta like globals in other languages?
16:55:40 <Cale> no...
16:55:41 <Nico_Reed> or mutable varibable
16:55:42 <vincenz> > length . map ord $ "æš«é›¢"
16:55:43 <lambdabot>  2
16:55:45 <vincenz> hmm
16:55:48 <Nico_Reed> variables*
16:55:53 <vincenz> plt handles that better
16:55:57 <idnar> > "æš«é›¢"
16:55:57 <vincenz> > "æš«é›¢"
16:55:58 <lambdabot>  "\26283\38626"
16:55:58 <Cale> Nico_Reed: You could have *a* monad which allowed for a global variable throughout the computation.
16:55:59 <lambdabot>  "\26283\38626"
16:56:00 <idnar> heh
16:56:02 <vincenz> :|
16:56:13 <Olathe> Nico_Reed: One nice feature of monads is that you can do things between each function application.
16:56:16 <Cale> Nico_Reed: In general, a monad is a kind of library though.
16:56:18 <Nico_Reed> are monads mutable?
16:56:20 <idnar> > show "æš«é›¢"
16:56:21 <lambdabot>  "\"\\26283\\38626\""
16:56:27 <idnar> oh, duh, that's not going to help
16:56:40 <Cale> Nico_Reed: Really "monad" refers to the type constructor.
16:56:45 <Nico_Reed> wait.. monads are library.. i thought there were closer to variables
16:56:51 <Cale> Nico_Reed: Yeah
16:57:07 <augustss> > show $ show $ show $ show 1
16:57:09 <lambdabot>  "\"\\\"\\\\\\\"1\\\\\\\"\\\"\""
16:57:18 <idnar> whe\\e\e\eee\e\\\e\\\\eee
16:57:20 <chessguy> @v
16:57:20 <vincenz> heh
16:57:20 <lambdabot> "\"#$%&'()*+,\""
16:57:22 <vincenz> > fix show
16:57:23 <LoganCapaldo> A monad is a data type that must implement a given set of functions :)
16:57:23 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:57:31 <Olathe> My eyes !
16:57:33 <Nico_Reed> actually.. honestly i havent gotten to monads yet in the tutorials so let me finish this first :S
16:57:45 <ddarius> LoganCapaldo: It's a type constructor and some polymorphic functions.
16:57:49 <Cale> Nico_Reed: The right way to think of a monad is as a kind of library which defines a particular kind of "computation", and by using the functions in the library you can manipulate those "computations", and possibly (though not necessarily), run them, to produce a result at the end.
16:57:51 <augustss> Nico_Reed: don't worry about them
16:58:12 <chessguy> Cale, for some definition of the word 'kind' :)
16:58:13 <augustss> Nico_Reed: just use them
16:58:18 <Cale> chessguy: right.
16:58:37 <chessguy> @kind Monad
16:58:38 <lambdabot> Class `Monad' used as a type
16:58:40 <Cale> If you want a better explanation, I've written a far more detailed one which you can read.
16:59:05 <Jiten> would it be incorrect to think a program in a traditional language like C to be one huge monad?
16:59:10 <Nico_Reed> augustuss i have been doing that a lot lately when it comes to haskell
16:59:12 <Cale> Jiten: You could do that.
16:59:30 <Cale> Jiten: though the monadic interface usually isn't made too explicit.
16:59:40 <ddarius> Not only could you do that, a similar thing was done for Java a while back.
16:59:58 <Cale> (like, C doesn't include operations for gluing other C programs together, but from outside the language, you can imagine defining operations like that)
17:00:00 <augustss> Nico_Reed: other things in Haskell I think you should understand, but you can leave monads to last.
17:00:08 <Nico_Reed> which reminds me does haskell doesnt have any OO "things" right?
17:00:29 <chessguy> last?
17:00:29 <augustss> Nico_Reed: you can do very OOy things
17:00:31 <Cale> Nico_Reed: It has lots of things which give you similar features...
17:00:32 <Jiten> Cale: ah good, I just wanted to make sure I wasn't misunderstanding something.
17:00:34 <chessguy> surely they should be before arrows
17:00:50 <LoganCapaldo> Haskell is arguably  more OO than OO with appropiate abuse of typeclasses ;)
17:00:50 <Nico_Reed> are these built in features or library functions?
17:00:53 <Cale> Jiten: Of course, there are very different kinds of monads :)
17:00:56 <SamB> augustss: after associated types?
17:01:03 <Cale> Nico_Reed: A little of both.
17:01:12 <augustss> chessguy: arrows, associated types, etc are not in H98
17:01:18 <ddarius> LoganCapaldo: Lacking subtyping is a significant hole in any putative "OOness" of Haskell.
17:01:31 <Olathe> Bah.
17:01:32 <Nico_Reed> do compiler/interperter errors show "type names"?
17:01:32 <LoganCapaldo> I think subtyping is broken :)
17:01:36 <chessguy> ah, i see your point
17:01:37 <LoganCapaldo> so I'm fine with it
17:01:46 <Cale> Nico_Reed: There are things like existential types, which are a language feature implemented in GHC which effectively let you do an "upcast" to any interface of functionality you'd like.
17:01:57 <ddarius> LoganCapaldo: Conflating subtyping and subclassing is certainly broken, but I would not say subtyping is broken.
17:02:02 <Jiten> would it be correct to say that haskell is a language that is it's own metalanguage (and meta meta language)
17:02:11 <Cale> Nico_Reed: But with that method, there's no way to do a "downcast" (which may be a feature, since those are generally really unsafe anyway)
17:02:31 <ddarius> Jiten: Not in any particularly useful way.
17:02:41 <augustss> Jiten: depends on what you mean by metalanguage
17:03:03 <Nico_Reed> btw.. GHCi is telling me that the expected type: IO t. What does that really mean?
17:03:20 <Cale> Nico_Reed: It means that it expected an IO action.
17:03:34 <Cale> Nico_Reed: IO actions are "computations" for the IO monad.
17:03:35 <Nico_Reed> here let me put it in the paste thing
17:03:51 <Jiten> augustss: well, the concept is a bit unclear to me I guess :)
17:04:13 <Cale> Nico_Reed: You might want to read this, as it's pretty short http://www.haskell.org/haskellwiki/Introduction_to_IO
17:04:14 <lambdabot> Title: Introduction to IO - HaskellWiki
17:04:18 <hpaste>  Nico_Reed pasted "(no title)" at http://hpaste.org/3433
17:04:26 <augustss> Jiten: but I'd probably say no :)
17:04:32 <Korollary> Nico_Reed: Do you understand typeclasses yet?
17:04:44 <Cale> Nico_Reed: It's the map
17:04:46 <Nico_Reed> well.. not in haskell
17:04:52 <Nico_Reed> whats wrong with the map?
17:04:59 <Cale> Nico_Reed: You want to do something with that list it's producing
17:05:04 <Cale> A list isn't an IO action.
17:05:05 <Korollary> Where else are typeclasses?
17:05:14 <Cale> You probably want to do something like print the list
17:05:18 <chessguy> Nico_Reed, you want to do num:[temp]
17:05:22 <Cale> print (map fac listofnum)
17:05:34 <Cale> chessguy: wha?
17:05:43 <chessguy> oh, sorry
17:05:50 <chessguy> mis-read
17:06:07 <Cale> Nico_Reed: Or perhaps you'd like to print each of them separately.
17:06:13 <Nico_Reed> thanks
17:06:29 <Cale> Nico_Reed: You can do something like  mapM (print . fac) listofnum
17:06:52 <Nico_Reed> actually you got me far enough
17:06:53 <Saizan> sorear: yes?
17:07:02 <augustss> Nico_Reed: every line in main has to be an IO something, 'map fac listofnum' is a list of numbers.  It's not an IO thing
17:07:03 <Nico_Reed> so you get an error messenger if you dont use a list?
17:07:06 <sorear> something about hpase
17:07:11 <Cale> Nico_Reed: hm?
17:07:21 <Nico_Reed> nvm augustss has me covered
17:07:31 <Cale> ah, okay
17:07:51 <Cale> Yeah, every line in a do-block has to be in the same monad, in this case, the monad you're using is IO.
17:08:12 <Cale> (there is a list monad, but it's *really* different)
17:08:26 <Saizan> sorear: ah, thought so, if you still need it let me know
17:08:40 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
17:08:41 <Nico_Reed> i think im sorta getting this
17:08:45 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
17:08:51 <Cale> (that's the list monad in action)
17:09:11 <Nico_Reed> thats actually kinda useful'
17:09:19 <ddarius> Of course it is.
17:09:25 <augustss> It's very useful
17:09:26 <Cale> yeah, it's quite handy for searching
17:09:33 <chessguy> everything in haskell is useful :)
17:09:51 <Nico_Reed> there is many times i could use that... wow. i wish i had that in c :P
17:09:59 <Korollary> Didn't SPJ call almost most of Haskell useless recently? ;)
17:10:12 <augustss> Nico_Reed: you have for loops :)
17:10:19 <Nico_Reed> true i love loops
17:10:20 <ddarius> Korollary: He called most of pre-monadic Haskell useless.  We were talking about the list monad.
17:10:22 <chessguy> Korollary, he said pre-monad haskell was useless, not current haskell
17:10:25 <Cale> Korollary: I think he was referring to some mythical Haskell-without-IO
17:10:27 <Nico_Reed> recursion is strange to me
17:10:37 <Korollary> Why are people jumping on me for a ;)
17:10:41 * chessguy declares a flame war on Korollary 
17:10:48 <ddarius> Korollary: Why are you interpreting it as jumping on you?
17:10:53 <augustss> Nico_Reed: you don't need recursion very often
17:10:55 <Cale> Nico_Reed: People don't really think in loops or recursion though. They think in higher order functions :)
17:11:14 <Jiten> Nico_Reed: haskell has folds, maps and such. they do similar things
17:11:16 <Nico_Reed> isnt recursion.. a "substitute" for loops?
17:11:20 <Cale> No
17:11:30 <monochrom> Korollary: SPJ can't be wrong! Heresy! ...
17:11:34 <Cale> Loops are a substitute for a particular kind of recursion.
17:11:39 <chessguy> a witch!
17:12:01 <Cale> If you want to implement your own stack, then I suppose you could replace recursion with a loop too, but that's much less natural.
17:12:14 <Nico_Reed> i found loops fairly useful.. but the foreach construct is really really useful i think
17:12:38 <Cale> Yeah, once you know a little more about monads, you'll be able to write any kind of loop you want.
17:12:41 <Nico_Reed> i have always wanted foreach in C
17:12:45 <augustss> Nico_Reed: for instance, getNumb and fac can both be written without (explicit) recursion
17:12:52 <Jiten> isn't map quite close to foreach (at least for some purposes?
17:13:02 <augustss> Jiten: yes
17:13:03 <monochrom> When I reason about loops, I end up treating them as recursions.
17:13:03 <Nico_Reed> well ya jiten
17:13:04 <Cale> In fact, if you can make a list of the actions you want to perform, then sequence will put them together into a single action
17:13:23 <Cale> sequence :: [IO a] -> IO [a]
17:13:23 * dmwit senses a :t sequence coming up
17:13:44 <Cale> (it's actually more general, but I'll not scare you any more than that for now :)
17:13:48 <ddarius> When I reason about recursions, I end up treating them as higher order functions.
17:13:55 <Nico_Reed> hehe thanks cale
17:14:05 <Cale> That is, it takes a list of IO actions, each of which will return a value of type 'a' when it gets run
17:14:23 <monochrom> One day I'll actually go all the way over to continuations. :)
17:14:25 <Cale> and produces a single IO action which when run will produce a list of values of type 'a'
17:14:28 <Korollary> monochrom: Not a lot of people 'reason' about loops anyway
17:14:43 <augustss> they should
17:14:57 <monochrom> Not a lot of people believe in Intelligent Design of programs. They believe in Natural Selection.
17:15:01 <Korollary> It's a logistics problem
17:15:11 <Cale> When I'm washing dishes, I don't number each of them and increment a counter, let's just say. :)
17:15:25 <ddarius> monochrom will go so far over into continuations that he'll end up back at monads
17:15:37 <Cale> What's going on in my head is a whole lot closer to 'map wash dishes'
17:15:41 <monochrom> Not a lot of people study Haskell. But we are here for a reason.
17:15:44 <Nico_Reed> monochrom you think that all the bad programs die off at the end?
17:15:49 <ddarius> monochrom: We are?
17:15:58 <Nico_Reed> actually do you think all the C programs die in the end
17:16:03 <monochrom> Or we are here out of Natural Selection.
17:16:05 <LoganCapaldo> my dish washing is non deterministic
17:16:10 <Korollary> When the OS shuts down at least
17:16:15 <LoganCapaldo> it may or may not terminate early ;)
17:16:21 <Cale> hehe
17:16:31 <Nico_Reed> alright im leaving before my head explodes :P
17:16:36 <Cale> hehe
17:16:44 <ddarius> You need to spawn children to wash your dishes in parallel.
17:16:50 * LoganCapaldo lazily evaluates the washing of his dishes
17:17:03 <Nico_Reed> thanks everyone. i think i learned a lot of things here.
17:17:12 <LoganCapaldo> it's a terrible habit I'm trying to break myself of
17:17:12 <dmwit> So, you wash dishes as you need them?  =)
17:17:20 <Cale> If there's only one dish, I wash it. Otherwise I wash the dishes by washing the first half of the dishes and then washing the second half.
17:17:35 <Korollary> monochrom: There are temporal logics to reason about imperative programs iirc.
17:17:37 <nopcode> hey
17:17:39 <chessguy> @remember ddarius You need to spawn children to wash your dishes in parallel.
17:17:39 <lambdabot> Done.
17:17:59 <nopcode> why cant i write "concat (map func src)" as "(concat . map) func src"?
17:18:19 <ddarius> nopcode: Because that means concat (map func) src
17:18:25 <dmwit> (concat . map .) func src
17:18:26 <Cale> nopcode: (concat . map) func src = concat (map func) src
17:18:28 <LoganCapaldo> nopcode: check out the typeage
17:18:32 <Tac-Tics2> :t concat
17:18:34 <Tac-Tics2> :t map
17:18:36 <ddarius> :t concatMap
17:18:41 <lambdabot> forall a. [[a]] -> [a]
17:18:41 <monochrom> Loop counters are overrated. I think that's Cale's point, and I think we have a consensus on that.
17:18:42 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
17:18:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:18:58 <Cale> monochrom: Yeah, and so is direct recursion, actually.
17:19:04 <ddarius> monochrom: Indeed, we should switch to self-modifying code.
17:19:17 <nopcode> so... '.' expects functions of one argument?
17:19:22 <ddarius> :t (.)
17:19:24 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:19:26 <monochrom> I understand delimited continuation by thinking of it as self-modifying code.
17:19:28 <Tac-Tics2> Lisp is probably really easy to write self-modifying code in, I would imagine
17:19:39 <dmwit> nopcode: That's an okay way to think of it.
17:19:41 <Cale> nopcode: yeah, in some sense, every function is a function of one parameter
17:19:42 <LoganCapaldo> I still remain un-understanding of delimited continuations
17:19:50 <nopcode> :)
17:19:51 <Tac-Tics2> Lisp's very nature is to read and write itself
17:19:59 <nopcode> so should i just keep the original syntax?
17:20:07 <Cale> nopcode: you can use concatMap
17:20:08 <ddarius> nopcode: Use concatMap.
17:20:16 <LoganCapaldo> @type concatMap
17:20:18 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
17:20:23 <nopcode> allright, thx :)
17:20:26 <LoganCapaldo> damn, I'm the slowest of them all
17:20:27 <Cale> hehe, or >>=
17:20:31 <idnar> @type concat . map
17:20:33 <lambdabot>     Couldn't match expected type `[[a]]'
17:20:33 <lambdabot>            against inferred type `[a1] -> [b]'
17:20:36 <Cale> > [1,2,3] >>= \x -> [x, x+10]
17:20:39 <ddarius> If you really wanted to be persnickety,
17:20:41 <lambdabot>  [1,11,2,12,3,13]
17:20:43 <ddarius> :t (concat .) . map
17:20:44 <idnar> oh duh
17:20:45 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
17:21:02 <Cale> Or a list comprehension:
17:21:16 <augustss> So many choices!
17:21:18 <Cale> > [y | x <- [1,2,3], y <- [x,x+10]]
17:21:20 <lambdabot>  [1,11,2,12,3,13]
17:21:55 <dmwit> > do { x <- [1,2,3]; [x, x+10] }
17:21:57 <lambdabot>  [1,11,2,12,3,13]
17:22:02 <LoganCapaldo> My god, it's full of choices!
17:22:35 <dmwit> > ap [id, (+10)] [1,2,3]
17:22:36 <lambdabot>  [1,2,3,11,12,13]
17:22:47 <dmwit> Ooops, that has different semantics. =P
17:22:53 <LoganCapaldo> now you're just being silly
17:24:54 <nopcode> i've got a recursive function which has 3 parameteres that dont change during recursion
17:25:01 <nopcode> is there a way to write the recursive call more compact?
17:25:29 <dmwit> Maybe you could use the State monad.
17:25:34 <nopcode> mhm
17:25:37 <nopcode> i mean something easy :)
17:25:52 <nopcode> bestFirstSearch expand value isGoal nodes
17:25:59 <nopcode> the first 3 arguments dont change
17:26:00 <monochrom> f x y z t = g t where g t = g (t-1) + x + y + z  ?
17:26:05 <sjanssen> nopcode: a simple 'where' binding?
17:26:29 <monochrom> @src foldr
17:26:29 <lambdabot> foldr k z xs = go xs
17:26:29 <lambdabot>     where go []     = z
17:26:29 <lambdabot>           go (y:ys) = y `k` go ys
17:26:31 <alexj> anyone know how to do http requests using multipart mime?
17:26:41 <monochrom> That foldr code is another example.
17:27:02 <nopcode> sjanssen: well but i'm only recursively calling the function once
17:27:12 <nopcode> hm so i guess it wont matter that much anyways
17:27:24 <dmwit> monochrom: I like the foldr example a lot.
17:31:23 <nopcode> hm
17:31:36 <nopcode> beam search is just a best-first search which only keeps the first N nodes in each recursion, right?
17:31:52 * ddarius has no idea what "beam search" is.
17:32:11 * dmwit has no idea what best-first search is
17:32:25 <ddarius> I know what best-first search is.
17:32:32 * LoganCapaldo is omnipotent
17:32:41 <dmwit> We should pool our ignorance, together we probably know almost nothing.
17:32:41 <nopcode> i thought you'd be dealing with searching problems all day *G*
17:32:41 <ddarius> (rather "best first searches are")
17:32:59 <dmwit> LoganCapaldo: I suppose you meant omniscient, maybe?
17:33:13 <LoganCapaldo> dmwit: you wish
17:33:17 <LoganCapaldo> bwahahahahahahahaahhaha
17:33:21 <dmwit> Augh, don't hurt me!
17:33:33 <monochrom> LoganCapaldo can do anything without knowing it.
17:34:04 <dmwit> haaaahahaha
17:34:50 <Korollary> best-search is indeed an ambitious name
17:41:55 <monochrom> back for more?  teeheheehehehehe
17:42:22 <Nico_Reed> alright i guess i cant go very far without explanations :P
17:42:53 <Nico_Reed> so i have a question on the "Maybe" keyword.. doesnt this break the static typing?
17:43:07 <monochrom> No.
17:43:42 <Nico_Reed> couldnt you (theoritically) make a maybe type of all possible types and then use it as a dynamic type?
17:43:49 <Korollary> Nico_Reed: I don't think you understand typeclasses yet (it's not the same as classes in other languages)
17:44:09 <Nico_Reed> alright.. well i understand types in the "C way"
17:44:13 <monochrom> No either.
17:44:15 <Nico_Reed> how is haskells different?
17:44:48 <Cale> Haskell's type system is very different, I don't even know where to begin :)
17:45:02 <Cale> Maybe isn't a keyword though
17:45:10 <Cale> It's just a particular datatype
17:45:11 <Korollary> Like C++'s type system is different from C's
17:45:25 <Nico_Reed> actually i guess i ment C++'s type system :S
17:45:33 <Cale> A value of type Maybe t is either the value Nothing, or it's a value of the form Just x, where x is of type t
17:45:50 <Cale> Nico_Reed: Yeah, "class" doesn't mean anything like what it means in C++
17:46:32 <Cale> Nico_Reed: A typeclass can be thought of as something which a type might satisfy, and if it does, there's some corresponding functionality implemented.
17:46:44 <Cale> For example, the typeclass Eq looks something like:
17:46:46 <Nico_Reed> alright..
17:46:49 <Cale> class Eq t where
17:46:51 <monochrom> typedef union { int x; char y; } xxx;  This is an unsafe approximation to Haskell's data XXX = X Int | Y Char.
17:46:53 <Cale>    (==) :: t -> t -> Bool
17:47:24 <Cale> and individual types have instances of Eq which define the operation of (==)
17:47:32 <Nico_Reed> hm..
17:47:58 <monochrom> typedef enum { A, B, C } zzz;  This is an unsafe approximation to Haskell's data ZZZ = A | B | C
17:47:59 <Cale> Similarly, there's Ord, which has things like (>), (<), (>=), (<=), compare
17:48:03 <araujo> hello
17:48:39 <Nico_Reed> alright.. this is confusing
17:48:41 <Cale> Then there's Num, which defines basic numeric operations (and a few extras which probably it shouldn't ;)
17:48:46 <Cale> @src Num
17:48:46 <lambdabot> class  (Eq a, Show a) => Num a  where
17:48:46 <lambdabot>     (+), (-), (*)           :: a -> a -> a
17:48:46 <lambdabot>     negate, abs, signum     :: a -> a
17:48:46 <lambdabot>     fromInteger             :: Integer -> a
17:48:48 <LoganCapaldo> typedef enum { X, Y } xxxtag; typedef struct { xxxtag tag; union { int x; char y } value } xxx; is probably closer
17:48:59 <LoganCapaldo> still unsafe
17:49:17 <monochrom> Haskell unifies union and enum (afterall both are about case analysis) and make them safe, i.e., more checks at compile time and run time.
17:49:21 <Cale> I don't think attempting to translate from C is particularly useful. :)
17:49:28 <LoganCapaldo> s/value/value;/
17:49:41 <Cale> It's easier to understand Haskell's datatypes on their own.
17:50:07 <Cale> Nico_Reed: Did you follow that little bit about typeclasses?
17:50:09 <Nico_Reed> well.. im sorta lost
17:50:15 <Cale> Nico_Reed: Typeclasses say things about types
17:50:23 <Nico_Reed> so typeclasses are types with functions?
17:50:35 <Cale> Nico_Reed: Normally, if you write a polymorphic function, let's say, length:
17:50:37 <monochrom> Not sure if you should talk about typeclasses now.
17:50:40 <Cale> length :: [a] -> Integer
17:50:44 <newsham> type classes are kind of like java interfaces
17:50:48 <Nico_Reed> sure
17:50:53 <Cale> The 'a' there can be any type at all.
17:51:03 <monochrom> I mean when even Maybe is unclear.
17:51:03 <Cale> But what about sort?
17:51:15 <newsham> the class specifies what functions the interface supports, and the instance declarations say concretely how the interface maps on to concrete instances
17:51:22 <Cale> We can't give sort the type:  sort :: [a] -> [a]
17:51:32 <Cale> because some types can't be compared for ordering
17:51:42 <Cale> (like functions, for example)
17:51:44 <Nico_Reed> @newsham.. i dont really know java so i dont have a grasp on the whole interface concept
17:51:45 <lambdabot> Unknown command, try @list
17:52:06 <Nico_Reed> woops.. i didnt realize @ set it off :P
17:52:17 <Cale> So we need a way to restrict the type variable, and say that it can only range over types where (<) is implemented, that is, types in the Ord class.
17:52:29 <Cale> So,  sort :: (Ord a) => [a] -> [a]
17:52:31 <Nico_Reed> k
17:52:44 <LoganCapaldo> you could just give sort the type :: (a -> a -> Ordering) -> [a] -> [a]. Pah I say to classes ;)
17:52:46 <Nico_Reed> but isnt the types inferred? is there a way to declare that?
17:52:58 <newsham> nico: here's a simple example.  the Num type class says (amoung other things) that thngs that are "Num" support the   n+n   interface.
17:52:59 <Cale> The type will be inferred.
17:53:18 <LoganCapaldo> I'll pass my dictionaries around manually thinak you very much. type classes are just fluff :)
17:53:21 <newsham> so if you make a type like Int you can make Int an instance of Num by defining how   n+n  works when n is an Int
17:53:29 <Cale> However, if we didn't have typeclasses, we'd probably need some hack to allow < to mean different things at different times.
17:53:43 <Nico_Reed> i think i understand newsham
17:53:54 <Cale> n + m :)
17:53:56 <Nico_Reed> and cale i think i see something
17:54:08 <Nico_Reed> but you cant make your own types right?
17:54:15 <Cale> Yep, you can.
17:54:20 <Cale> data does that
17:54:27 <Nico_Reed> hm.. alright no details though hehe
17:54:45 <Cale> Remember that Maybe type?
17:54:50 <Nico_Reed> yes
17:54:52 <Cale> It's defined in the library like this:
17:54:59 <newsham> nico: so for example, you could define a data type  "data Complex = Comp Double Double" (has two floating point parts)
17:55:01 <Cale> data Maybe t = Nothing | Just t
17:55:12 <newsham> and you can make Complex an instance of Num.  and now you can use "+" to add two Complex's
17:55:34 <Nico_Reed> oh.. i see what both you guys are saying
17:55:47 <Nico_Reed> hold on.. so maybe isnt built in?
17:55:50 <Cale> right
17:55:56 <Cale> Nor is Bool, even.
17:56:02 <Cale> data Bool = False | True
17:56:03 <Nico_Reed> alrigght.. i think i am getting this
17:57:03 <Cale> (though Bool is a little special because it's supported by if-then-else syntax)
17:57:25 <Cale> However, if-then-else is just syntax sugar too.
17:57:48 <Cale> if b then t else e
17:57:52 <Cale> gets rewritten as
17:58:00 <Nico_Reed> k.. im grasping this finally
17:58:00 <Cale> case b of True -> t; False -> e
17:59:08 <Nico_Reed> however.. this datatype thing, the instant can be of one type right? As an example: "data example = Int | String" It might be either a Int or a string but only one of them right?
17:59:24 <Cale> Well, you have the syntax a little off there
17:59:32 <Nico_Reed> well i guessed
18:00:02 <Cale> data Example = Int | String will define a type called Example whose values are the literal symbols Int and String
18:00:20 <Cale> Not an integer or string like you probably expected
18:00:39 <Cale> However, you can give those data constructors parameters which are actual Ints or Strings
18:00:57 <Nico_Reed> oh.. i see so you can use data as an enumation (as C/C++'s definition)
18:01:04 <Cale> data Example = Int Int | String String -- a little confusing because the first thing is a data constructor and the second is the type of its paramete
18:01:05 <Cale> r
18:01:09 <Cale> yeah
18:01:18 <newsham> data Example = ExInt Int | ExString string
18:01:25 <Cale> yeah, that's clearer :)
18:01:33 <ddarius> Actually, LoganCapaldo, implementing typeclasses (or constructor classes specifically) requires types beyond H98.
18:01:36 <Cale> data Example = ExInt Int | ExString String -- watch the capitals :)
18:01:50 <Cale> Then  ExInt 5 :: Example
18:01:51 <Nico_Reed> and what does this ExInt actually mean?
18:02:03 <Cale> It builds a value of type Example from an Int
18:02:16 <Excedrin> is the "ExInt" there the "constructor" ?
18:02:17 <Cale> and lets you deconstruct the value again, by pattern matching
18:02:29 <Cale> It's a data constructor, yes.
18:02:40 <Nico_Reed> alright and can you give me an example of a function/expression use this data thing
18:02:44 <Cale> Sure
18:02:56 <Cale> f (ExInt n) = n
18:03:06 <Cale> f (ExString str) = length str
18:03:20 <Cale> f :: Example -> Int
18:03:33 <Nico_Reed> OH!! i got it now
18:03:33 <newsham> add (ExInt a) (ExInt b) = a+b;  add _ _ = error "doh, this is bad style"
18:03:53 <Nico_Reed> thanks i got it.. that example made it click
18:04:26 <Cale> Maybe is used when you want to allow a function to sometimes fail to return something.
18:04:40 <Cale> Then you pattern match to see if it found anything or if it failed.
18:04:59 <Nico_Reed> so now.. is there a way you explicitly declare that it returns an example?
18:05:02 <Cale> You can either pattern match like I did above, or with case-expressions
18:05:06 <Cale> yeah
18:05:21 <Cale> If you want, you could write a type signature like:
18:05:31 <Cale> g :: [String] -> Example
18:05:44 <Nico_Reed> like "f x y = if(y) then return x else return length x" (other than bad syntax) would the type be inferred correctly?
18:05:48 <Cale> Then g is a function which takes a list of strings, and produces a value of type Example.
18:06:14 <newsham> nico: be careful with "return"
18:06:19 <Cale> Nico_Reed: um, no, because x and length x can't have the same type
18:06:21 <newsham> it prob means something other than what you're thinking in haskell
18:06:25 <Cale> (and you don't need the returns)
18:06:39 <Nico_Reed> but x and length x are both "examples"
18:06:47 <Cale> Nico_Reed: To have a value of type Example, you have to explicitly use ExString or ExInt
18:06:47 <Nico_Reed> like the type Example..
18:06:56 <Cale> So you could write:
18:07:12 <Cale> f x y = if y then ExString x else ExInt (length x)
18:07:17 <Nico_Reed> btw after this clears up explain the return thing to me
18:07:32 <Cale> Then  f :: String -> Bool -> Example
18:07:37 <Nico_Reed> and the cale f is assumed to be an Example
18:07:38 <Cale> (and that'll be inferred)
18:07:39 <Nico_Reed> nvm
18:07:51 <newsham> nico: closer to your analogy:   f ex = case ex of ExInt i -> i; ExString s -> length s
18:07:54 <Cale> It knows because you used the constructors.
18:08:09 <Nico_Reed> alright now explain what returns means..
18:08:25 <newsham> you dont wanna know yet :)
18:08:29 <newsham> > return 5 :: [Int]
18:08:29 <Nico_Reed> i had susicions that im not using it right because i always get errors..
18:08:30 <Cale> Return is used in monads to construct a "computation" which does nothing but return a particular value.
18:08:31 <lambdabot>  [5]
18:08:34 <newsham> > return 5 :: Maybe Int
18:08:36 <lambdabot>  Just 5
18:08:48 <newsham> > return 5 :: Either String Int
18:08:50 <lambdabot>  Right 5
18:09:02 <Nico_Reed> Right 5? where is the right from?
18:09:04 <Cale> For example, you can use it in the IO monad:  (return 5) is the IO action which doesn't do anything, but returns 5.
18:09:05 <newsham> > return 5 :: IO Int
18:09:06 <lambdabot>  <IO Int>
18:09:19 <Cale> Nico_Reed: These are examples of monads we haven't shown you yet. :)
18:09:23 <newsham> Nico:   data Either a b = Left a | Right b
18:09:29 <Nico_Reed> *sigh* new things are always bad
18:09:37 <newsham> you dont wanna play with return yet :)
18:09:37 <Nico_Reed> ah.. alright
18:09:37 <Cale> hehe
18:09:53 <Nico_Reed> so.. how do i know what gets "returned" from a function?
18:10:02 <newsham> nico: its the value of the function :)
18:10:04 <Cale> It's just the RHS of the equation.
18:10:12 <newsham> > let f x = 5 in f 23
18:10:12 <Cale> If you write
18:10:13 <Nico_Reed> RHS?
18:10:13 <lambdabot>  5
18:10:16 <ddarius> square x = x * x
18:10:17 <newsham> right-hand-side
18:10:18 <Cale> Right hand side
18:10:24 <Nico_Reed> ah
18:10:45 <newsham> nico: so in C you might   if(x>5) return x else return 0
18:10:47 <ddarius> Nico_Reed: Haskell declarations are equations not lists of commands.
18:10:49 <Cale> This is necessarily an expression, and so it must have a value.
18:10:56 <newsham> in haskell if/then/else works differently:    if x>5 then x else 0
18:11:05 <newsham> the then and else clauses just have the value
18:11:20 <Cale> Yeah, C has if-statements, Haskell has if-expressions
18:11:20 <newsham> sort of like   (x>5)?x:0
18:11:21 <Spark> x>5 ? x : 0
18:11:46 <Nico_Reed> http://www.hpaste.org/3433
18:11:48 <phlpp> :t ?
18:11:49 <lambdabot> parse error on input `?'
18:11:53 <Nico_Reed> so why does the return work right?
18:11:53 <phlpp> :t (?)
18:11:55 <lambdabot> Not in scope: `?'
18:12:04 <newsham> phlpp: in C.
18:12:05 <Cale> Nico_Reed: In that case, you are in the IO monad
18:12:11 <phlpp> newsham: ah ok
18:12:17 <phlpp> newsham: ternary operator, eh?
18:12:19 <Nico_Reed> uh really? How so?
18:12:27 <newsham> phlpp: yah.
18:12:34 <Cale> Nico_Reed: (return x) there builds an IO action which just returns the result x
18:12:41 <newsham> ?pl \b t e -> if b then t else e
18:12:41 <lambdabot> if'
18:12:46 <Cale> Nico_Reed: the result of a do-block is the result of the last action listed in it.
18:12:51 <newsham> is if' defined anywhere other than lambdabot?
18:13:00 <Cale> newsham: folklore
18:13:04 <phlpp> Cale: sorry for asking but could you short explain where the difference is between statement and expression?
18:13:15 <Nico_Reed> so in a do-block you have to use return?
18:13:18 <newsham> import Strange.Historic.Folklore?
18:13:35 <Cale> phlpp: Statements have just effects. Expressions have values.
18:13:37 <TSC> Roughly, a statement does something; an expression returns a value
18:13:38 <newsham> phlpp: statements have effect.  expressions just result in a value
18:13:42 <Cale> Nico_Reed: yeah
18:13:42 <nopcode> how do i extract the fifth element of a tuple=?
18:13:53 <newsham> C kinda mixes the notion of statements and expressions.
18:13:54 <monochrom> watch the movie :)
18:13:56 <Cale> Nico_Reed: Moreover, it's not like the return you're used to in C
18:13:56 <ddarius> \(_,_,_,_,x) -> x
18:14:01 <newsham> some other languages like python keep them separated
18:14:03 <phlpp> thanks to Cale, TSC, newsham :)
18:14:26 <nopcode> ddarius: ok i thought so, kinda
18:14:29 <Cale> Nico_Reed: It won't jump out of the middle of a do-block if you put a return there. A return in the middle of a do-block is just a no-op.
18:14:35 <Nico_Reed> Why can't haskell just be C :(.. alright so how is that return working right there?
18:14:45 <newsham> nico: you could program in C.
18:14:58 <phlpp> it's pretty good that haskell is not c
18:15:02 <Nico_Reed> why is getNumb an IO action i guess
18:15:13 <Cale> indeed it is.
18:15:16 <newsham> nico: because it reads a line
18:15:47 <newsham> getNumb is built up by combining together smaller IO actions (thats what the "do-block" does).  and hence it is an IO action
18:15:54 <Cale> btw, configure your editor to convert tabs to spaces
18:16:07 <Cale> or else you will run into horrible indenting problems
18:16:16 <Nico_Reed> alright.. i guess i should use an IDE
18:16:20 <Nico_Reed> im still in notepad
18:16:26 <Nico_Reed> whats a good haskell IDE?
18:16:27 <Cale> Oh, you're on windows :)
18:16:33 <Nico_Reed> well right now i am
18:16:40 <Cale> Something like textpad will do nicely.
18:16:40 <newsham> nico: have you used VI or EMACS before?
18:16:46 <Nico_Reed> VI ya
18:16:48 <Cale> vim and emacs are good
18:16:53 <newsham> you can get vim and emacs for windows
18:17:05 <newsham> in vim   :set et
18:17:09 <newsham> to make it expand tabs
18:17:10 <Nico_Reed> hm.. neverr knew.. altough i guessed
18:17:14 <Cale> (expandtab)
18:17:17 <SamB> though lots of the good is gone in windows :-(
18:17:31 <newsham> http://www.vim.org/download.php#pc
18:17:32 <lambdabot> Title: download : vim online
18:17:39 <Nico_Reed> thanks newsham
18:17:54 <Cale> I'm sure there are other decent editors for windows though. I don't really use windows, so I can't say.
18:18:11 <Cale> TextPad was one which was decent back when I did.
18:18:27 <Nico_Reed> are you on linux? cause a decent IDE would be nice over there too
18:18:44 <Cale> Well, on linux, I typically use vim
18:18:50 <Nico_Reed> i honestly only boot into windows right now because all my haskell stuff is here
18:18:51 <Cale> Or occasionally emacs
18:19:05 <newsham> i use vim as well (on windows and various unixen)
18:19:06 * LoganCapaldo uses vim on windows
18:19:19 <LoganCapaldo> heck I use vim everywhere
18:19:21 * ddarius uses vim on both.
18:19:24 <Cale> Ah, that's odd, it's actually usually significantly more irritating to get Haskell stuff working on windows than on linux, since we're mostly linux users :)
18:19:32 * phlpp uses emacs on both
18:19:36 <Nico_Reed> really?
18:19:39 <LoganCapaldo> I use vim on VMS ;)
18:19:40 <Nico_Reed> i was scared to try on linux
18:19:45 <SamB> hahaha
18:19:48 <Nico_Reed> linux installs are normally brutal
18:19:49 <newsham> cale: its pretty well set up on windows.  i only have a few minor complaints
18:19:58 <SamB> just because the lead developers work for MSR?
18:20:07 <Nico_Reed> i clicked install.. rarely does it get easier than that
18:20:11 <Cale> I remember having problems with the windows console sucking on my friend's machine.
18:20:18 <newsham> samb: its not terribly microsofty.. uses mingw for example.
18:20:18 <Nico_Reed> cause if its much easier.. i think it would be a virus
18:20:28 <Cale> heh
18:20:36 <phlpp> linux install isn't that hard
18:20:36 <SamB> newsham: I know
18:20:38 <Cale> That's possibly a good idea.
18:20:44 <newsham> cale: ahh.. i dont use cmd, I use cygwin (but non-cygwin ghc)
18:20:55 <Philippa> Nico_Reed: it's when you start building external libs that things can get tricky
18:20:55 <Cale> We have GHC-as-a-Library, why not GHC-as-a-Virus
18:21:06 <phlpp> get a (k|x|u)buntu, set up in not more than 15 minutes
18:21:08 <SamB> that would be a HUGE virus
18:21:24 <phlpp> (i don't like ubuntu that much, but it's perhaps best solution to convert to gnu/linux)
18:21:26 <Nico_Reed> alright ill brb in 15-30 mins
18:21:37 <Cale> Hi, check out these sexy pictures I took!
18:21:38 <SamB> don't you think people would notice that the programs they compiled were suddenly rather huge?
18:21:42 <newsham> you could always do net/free/openbsd
18:21:45 <Cale> And then *WHAM* GHC is installed.
18:21:47 <phlpp> just get the latest live cd of Gutsy Foobar
18:21:47 <Nico_Reed> i like ubuntu because of its huge repo.. and im lazy
18:22:23 <phlpp> freebsd 7.0 release will replace my debian/stable
18:22:25 <phlpp> \o/
18:22:28 <phlpp> and zfs as filesystem \o/
18:23:23 <phlpp> i hope it will be bootable then..
18:23:30 <sorear> phlpp: ZFS is going to be your main filesystem!?
18:23:38 <monochrom> @remember Cale We have GHC-as-a-Library, why not GHC-as-a-Virus
18:23:38 <lambdabot> Done.
18:23:42 <phlpp> where's the problem, sorear?
18:24:04 <Nico_Reed> one question.. does haskell require forward declaring?
18:24:06 <phlpp> zfs IS, when running stable, the best filesystem.
18:24:13 <Nico_Reed> one last question*
18:24:23 <newsham> is that religeon or science, phlpp?
18:24:27 <monochrom> Haskell doesn't require forward declaring.
18:24:29 <sorear> phlpp: last I checked it didn't support things like filemodes or symlinks or device nodes or sparse files or...
18:24:32 <phlpp> newsham: science, acutally
18:24:39 <Cale> Nico_Reed: No, the order of overall declarations doesn't matter
18:24:47 <phlpp> actually..
18:24:51 <Nico_Reed> that is for everything though right?
18:24:52 <Cale> Nico_Reed: You can even define things as mutually recursive.
18:24:58 <monochrom> "f x = g (x+1)"  then 5000 lines later "g x = f (x+1)" is perfectly alright.
18:25:05 <Cale> evens = 0 : map (+1) odds
18:25:09 <sorear> Or are we not talking about the same ZFS?
18:25:10 <Cale> odds = map (+1) evens
18:25:12 <phlpp> newsham: it's a really really awesome FS. but it's currently not stable in freebsd CURRENT
18:25:15 <phlpp> and not bootable
18:25:24 <phlpp> you have to use ufs for some minor stuff :<
18:25:29 <monochrom> Moreover, "data X = Ctor Y" then 5000 lines later "data Y = YYY" is also OK. :)
18:25:35 <Nico_Reed> Cale how would that work?
18:25:43 <phlpp> sorear: ZFS from sun
18:25:52 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
18:25:54 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:25:57 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in odds
18:26:01 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
18:26:04 <Nico_Reed> nice..
18:26:09 <phlpp> sorear: supporting cloning, snapshotting, raid-z, every file gets a checksum etc.
18:26:13 <Cale> The evaluation bounces back and forth between the two definitions
18:26:15 <phlpp> that zfs i'm talking about
18:26:15 <Nico_Reed> lazy evaluation is why it works im guessing
18:26:16 <newsham> nico: it gathers all the definitions together
18:26:18 <Cale> yeah
18:26:28 <Nico_Reed> i need to get use to that :S
18:26:29 <Cale> (well, the infinite list part)
18:26:44 <newsham> sorear: you talking about zipperfs?
18:26:53 <sorear> ah.  I was thinking of http://okmij.org/ftp/papers/zfs-talk.pdf
18:27:22 <Nico_Reed> alright later.. im going to go un-explode my brain with a break
18:27:23 <Cale> I wonder what the next Ubuntu will be called. Horny Hippopotamus?
18:27:29 <phlpp> seems like zfs will be also included in osx 10.5
18:27:31 <monochrom> haha
18:27:39 <Nico_Reed> there should be some kind of health waring with GHC *sigh*
18:27:41 <phlpp> question is, as optional filesystem or replacement for hfs+
18:27:42 <Nico_Reed> warning*
18:28:56 <Cale> Ah, "Hardy Heron". I think I like my idea better.
18:29:03 <phlpp> :D
18:29:12 <monochrom> "Warning: GHC can make you smarter"?
18:29:18 <phlpp> hm, i have to buy more eric clapton music
18:29:35 <phlpp> seems like it gives a good atmosphere to a beer :>
18:29:43 <monochrom> "Warning: GHC can make you understand programming, double-plus-ungood"?
18:30:18 <Nico_Reed> no something closer to how everything you know will be warped into something else making you feel completely retarded.. again
18:30:51 <monochrom> That is a normal symptom of becoming smarter.
18:31:08 <nopcode> yay, i've solved escape from zurg
18:31:20 <ddarius> Um... congratulations.
18:31:23 <nopcode> ;)
18:31:38 <monochrom> and beginning to understand programming. Notice how you felt smart when you knew nothing.
18:31:39 * Cale puts on some Eric Clapton in response to phlpp's remark.
18:32:07 <Nico_Reed> hehe.. is that a sign of a genuis? someone who doesnt know anything?
18:32:23 <Nico_Reed> because if that were true this is a genuis planet ;)
18:32:35 <monochrom> "When you think you know nothing, you can get a Bachelor's. When you find out you know nothing, you can get a Master's."
18:32:41 <phlpp> Cale: hehe :)
18:32:46 <monochrom> err
18:32:49 <newsham> warning: learning Haskell could take up 1.5 man years of your time and leave you unsatisfied with your current development environment.
18:32:54 <monochrom> "When you think you know everything, you can get a Bachelor's. When you find out you know nothing, you can get a Master's."
18:33:04 <newsham> consider the blue pill.
18:33:54 <nopcode> when do you chose list comprehension over map with lambda?
18:34:04 <TSC> When it looks nicer
18:34:05 <monochrom> phase of moon
18:34:07 <newsham> when you feel like it :)
18:34:09 <Nico_Reed> actually.. i hate haskell.. for the sole reason that now i cant stand programming in any other language as it feels clumsy.. but when i program in haskell, i feel clumsy
18:34:12 <Cale> nopcode: TSC is right :)
18:34:15 <SamB> monochrom: how do you get a PhD?
18:34:30 <nopcode> ic :)
18:34:36 <newsham> nico: you can get better.  the other languages cant :(
18:34:40 <Cale> Nico_Reed: That's an awkward place to be, but it doesn't last *too* long.
18:34:41 <Nico_Reed> hehe true
18:34:45 <omnId> nopcode: I almost never use list comps.  They come in handy, though, for their pattern match failure semantics.
18:34:47 <monochrom> Haha, glad you ask, since it's the punch line. "When you find out your supervisor knows nothing either, you can get a PhD."
18:34:50 <chessguy> SamB, when you can prove you know nothing
18:34:55 <SamB> chessguy: ah!
18:34:58 <SamB> that makes sense
18:35:09 <omnId> i.e., failures just exclude those values from the results.
18:35:13 <TSC> A comprehension is often nicer when you're filtering too, or doing many choices
18:35:18 <nopcode> omnId: oh, ic
18:35:22 <SamB> monochrom: heh
18:35:39 * ddarius uses do-notation instead of list comprehensions oftentimes.
18:35:54 <newsham> consumers benefit when there are choices
18:36:01 <newsham> programming is no different
18:36:10 <newsham> use a comprehension, use a higher-order function, use monads
18:36:26 <nopcode> i thought monads where mainly for IO?
18:36:33 <monochrom> function call sites benefit when the functions are non-deterministic.
18:36:45 <newsham> nopcode: nope.  list comprehensions are fairly similar to list-monadic code
18:36:48 <Nico_Reed> btw this reminds me of ANOTHER question ( i gotta walk away from this computer.. i asking too many ) is there an elegant way of "changing" the x'th element of a list?
18:36:49 <SamB> nopcode: that is not much of what they can be used for
18:37:06 <newsham> a monad is just an abstraction of a common interface
18:37:25 <newsham> IO happens to be one thing that uses that interface
18:37:30 <monochrom> Most often you should re-design your algorithm to eliminate the need to change the x'th element of a list.
18:37:47 <SamB> for instance, use a Data.Map
18:37:53 <omnId> > do { x <- [1,2,3] ; y <- [4,5] ; return (x + y) }
18:37:56 <TSC> Nico_Reed: Not really; change n xs x = take n xs ++ [x] ++ drop (n+1) xs  -- not pretty
18:38:01 <lambdabot>  [5,6,6,7,7,8]
18:38:07 <newsham> there are other data structures you can use
18:38:08 <omnId> > [x + y | x <- [1,2,3], y <- [4,5]]
18:38:09 <lambdabot>  [5,6,6,7,7,8]
18:38:29 <monochrom> For example if you whole scheme is "change the x'th element, then change the x+1'th element, then change the x+2'th element, then ..." then you should consider using "map".
18:38:29 <chessguy> @pl \n xs x -> take n xs ++ [x] ++ drop (n+1) xs
18:38:29 <lambdabot> ap (ap . (((.) . (++)) .) . take) ((flip (:) .) . drop . (1 +))
18:38:56 <newsham> change f n v = \n' -> if n == n' then v else f n'
18:39:33 <omnId> I defined an: onElt i f xs = take n xs ++ [f (xs!!i)] ++ drop (n+1) xs, then your function is onElt i (const x) xs
18:39:39 * phlpp lauscht: â™« Eric Clapton - Change The World [Clapton Chronicles - The Best Of Eric Clapton (Korea Tour 2007 Limited Edition)-CD.1] â™«
18:39:43 <phlpp> \o/
18:40:31 <newsham> > let dat n = "testing"!!n; change f n v = \n' -> if n == n' then v else f n'; dat2 = change (change dat 3 'x') 2 'y' in dat2 3
18:40:32 <lambdabot>  'x'
18:40:35 <newsham> > let dat n = "testing"!!n; change f n v = \n' -> if n == n' then v else f n'; dat2 = change (change dat 3 'x') 2 'y' in dat2 1
18:40:36 <lambdabot>  'e'
18:40:42 <newsham> > let dat n = "testing"!!n; change f n v = \n' -> if n == n' then v else f n'; dat2 = change (change dat 3 'x') 2 'y' in dat2 0
18:40:43 <lambdabot>  't'
18:41:01 <newsham> for example
18:41:17 <phlpp> ok, i'll go to bed..
18:41:23 <phlpp> it's almost 4 am ;)
18:41:32 <newsham> 3:41p here
18:41:46 <phlpp> p?
18:41:56 <monochrom> I have never seen a real need to change the x'th element, and only the x'th element, of a list.
18:42:32 <sorear> sounds like array thinking
18:43:24 <omnId> I once got a list via 'words', but one of the elements was supposed to be two words with a space, so I used onElt.
18:43:43 <monochrom> Yes. All cases boil down to, upon further confession, "I'm looping x through 0 to n". So just use map.
18:44:33 <Nico_Reed> sry i stop paying attention.. at sorear.. it is array thinking
18:44:59 <Nico_Reed> but i have no idea oh any other way to think.. although i realized monochrom is kinda right...
18:45:08 <Nico_Reed> of*
18:45:31 <monochrom> One very brain-damaging side effect of imperative programming I have observed is that programmers fit --- no, encode and obfuscate --- every intent into arrays. You want a list? They put it into an array. You want a set? They put it into an array.
18:45:53 <ddarius> heaps!
18:46:03 <newsham> never trust someone who says "never" :)
18:46:05 <phlpp> :D
18:46:09 <Nico_Reed> well that comes from the fact that data is naturally in the form of array
18:46:12 <SamB> at least C++ programmers sometimes try to make it clear what's going on...
18:46:14 <monochrom> So one day when they have to move to another language --- even Java --- they have a hard time groking all those nice abstract data types in the library.
18:46:19 <SamB> instead of just using a raw array
18:46:29 <omnId> Nico_Reed: you get used to thinking in terms of operations on aggregates, but it comes slowly, and you usually need to do the recursion yourself to get used to what's going on.
18:46:38 <newsham> monochrome: when you have a hammer everything looks like a nail.  functional programmers have their own hammers and nails they overuse :)
18:46:43 <omnId> at the start, anyway.
18:47:23 <newsham> when you use lisp everything's a cons
18:48:08 <sorear> Nico_Reed: can you give a concrete example of something that is 'naturally' an indexed array?
18:48:09 <Nico_Reed> alright later
18:48:12 <phlpp> ok, i'm leaving
18:48:15 <phlpp> good night everyone
18:48:20 <monochrom> Haskell is guilty too of encouraging you to obfuscate every intent into lists. But at least lists in Haskell are isomorphic to the control structure that is loops. It is stream programming, and it has deep theory and elegance.  Arrays are dumb.
18:48:35 <Nico_Reed> uh.. a matrix is perfect for an array
18:48:40 <Nico_Reed> but i g2g
18:49:05 <sorear> bye
18:49:30 <newsham> mono: perhaps someday the list operations will be abstracted into a data class
18:49:40 <newsham> and you'll be able to "take 5" from your iterable
18:49:45 <dmwit> sorear: How about the memoization of a function?  That seems to fit into array-land nicely.
18:50:13 <dmwit> Well, at least for functions with Int domain.
18:50:17 <newsham> bytestrings come to mind
18:50:21 <ddarius> monochrom: Haskellers aren't nearly as bad about that as Lispers.  You don't see assoc lists too often.
18:50:48 <sorear> And yet, why should matrices be indexed by natural numbers?  It seems to me that they should be indexed by pairs drawn from the index sets used to construct the domain and codomain vector spaces; which may initially be numbers, but this fact is abstract.
18:51:05 <Philippa> ddarius: I use them too often, bad habit :-(
18:51:36 <newsham> sorear: have you read any of the funmath stuff?
18:51:38 <sorear> dmwit: I would call that a finite map.  That it can be implemented using an array does not mean it Is an array
18:51:43 <sorear> newsham: no.
18:51:58 <newsham> they do things like generalize summation to be over any set (not just integer indices)
18:52:15 <newsham> the funmath stuff is very interesting.  i hope it sees widespread use
18:52:31 <newsham> http://www.funmath.be/
18:52:33 <lambdabot> Title: Funmath Home Page
18:52:36 <ddarius> It's common to use sigma notation with sets.
18:53:02 <omnId> newsham: Foldable has a toList method, re: the "take 5" thing
18:53:02 <ddarius> Bags would be most appropriate I guess.
18:53:16 <newsham> ddarius: yes, but the notation often has ambiguities or symbols that change meanings when replaced with equals.
18:53:21 <dmwit> sorear: To be quite honest, I don't see a compelling reason *not* to index matrices with the integers for any given programming application.
18:53:47 <dmwit> I'm with you in spirit, but in practice I don't think I can agree with you.
18:54:01 <monochrom> array is fine for matrices. the catch is, how many programmers work on matrices?
18:54:10 <ddarius> Down with matrices!
18:54:22 <Axioplase> monochrom: many fortran addicts
18:54:25 <newsham> ddarius: please define your coordinate space
18:54:39 <ddarius> Down with coordinates!
18:54:42 <dmwit> Down with gravity!
18:54:44 <Pseudonym> newsham: Here, have a Grassman algebra.
18:54:53 <gravity> :-(
18:54:56 <Pseudonym> dmwit: But only in an appropriate reference frame!
18:55:00 <Axioplase> Down with your underpants !
18:55:02 * ddarius consoles gravity.
18:55:10 <gravity> Thanks ddarius :-)
18:55:10 <Pseudonym> gravity sucks
18:55:13 <newsham> ?karma- gravity
18:55:13 <lambdabot> gravity's karma lowered to -1.
18:55:45 <vBergmann> ?help karma
18:55:45 <lambdabot> karma <polynick>. Return a person's karma value
18:56:01 <omnId> "polynick"?
18:56:10 <omnId> ?karma this that other
18:56:10 <lambdabot> this has a karma of 0
18:56:11 <dmwit> ?karma omnId dmwit lambdabot
18:56:11 <lambdabot> omnId has a karma of 6
18:56:17 <Axioplase> Gravity's karma should be around 9.8, shouldn't it ?
18:56:29 <dmwit> That doesn't seem to work, huh?
18:56:30 <newsham> karma is not an acceleration
18:56:30 <Olathe> No.
18:56:34 <Olathe> Gravity can suck.
18:56:38 <Axioplase> damnit !
18:56:41 <Olathe> It can suck a lot.
18:57:04 <dmwit> Yeah, but if it didn't suck, we'd all fall off the earth.
18:57:05 <monochrom> Some programmers say, "why do I need math? [they mean calculus, but anyway] I'm just a Web programmer."  I'm now turning their own rhetoric around and say, why do you need arrays, is it like you have to do linear algebra? You're just a Web programmer.
18:57:24 <Olathe> The earth sucks !
18:57:37 <Olathe> Why would I want to be stranded on it ?
18:57:47 <monochrom> You can go to the moon.
18:57:59 <Olathe> The moon doesn't suck quite so massively.
18:58:00 <Axioplase> hoovers suck !
18:58:02 <omnId> Olathe: Breathable atmosphere and resources aplenty?
18:58:12 <monochrom> In a few days China is launching something to the moon. Maybe you can hitchhike.
18:58:32 <newsham> i hear their inflation is already astronomical
18:58:53 <monochrom> You'll also inflate greatly when you arrive at the moon. XD
18:59:16 <Olathe> Space sucks in a completely different way.
18:59:20 <ddarius> Explosive decompression
18:59:21 <Philippa> Axioplase: not into hardcore, huh?
18:59:47 <Axioplase> Philippa: I'm to pure to think hardcore.
19:00:01 <Axioplase> s/to/too
19:00:14 <monochrom> China will be a good market for Haskell. Forget the US, they like OO too much.
19:00:20 <Philippa> too much banging for you, huh?
19:00:53 <newsham> you'd think the russians with their focus on theory and long time lack of access to technology
19:00:55 <Axioplase> I beg you pardon ?
19:00:56 <newsham> would make good haskell fans
19:01:40 <monochrom> They do.
19:01:51 <newsham> btw, is agda big in japan?  their website moved to some .jp website
19:02:15 <newsham> the tutorial is almost unreadable english :(
19:02:18 <Philippa> Axioplase: I think you missed a pun or two
19:02:30 <Olathe> Things are easy when you're big in Japan.
19:02:36 <monochrom> We don't see many Russians in this channel or in the mailing lists because they're too smart to need help! :)
19:02:45 <newsham> mono: heh
19:02:59 <Axioplase> Philippa: I got it. But I'm looking for a cartoon on the internet I can't find anymore to express my purity.
19:03:12 <newsham> mono: maybe they dont have email or computers and just code haskell on paper.
19:03:14 <dmwit> "Features planned for future versions include returning a lazy infinite list for infinite sequences via an embedded general AI and Mathematica interpreter."
19:03:16 <dmwit> =D
19:03:16 <monochrom> Many Japanese may understand unreadable English. :)
19:03:16 <Axioplase> (without any lambda)
19:03:35 <newsham> mono: that doesnt help me learn agda :(
19:03:53 <ddarius> newsham: Learn Japanese and maybe you'll understand unreadable English.
19:04:12 <monochrom> Yes, seriously, the other factor is we are so keen on "putting tutorials and blogs on the net" when they need cheap photocopies of books most.
19:04:25 <dibblego> why does type theory matter?
19:04:26 <newsham> arigato
19:04:39 <jfredett> mr roboto
19:04:56 * jfredett starts doing the robot
19:06:03 <ddarius> newsham: I find it readable enough, but then I know a small bit of Japanese and have probably forgotten more.
19:07:49 <Axioplase> ddarius: the fact is that when you speak japanese, you understand how some build grammatically bad english.
19:08:26 <newsham> grammar structure japanese knows yoda does.
19:08:43 <monochrom> indeed XD
19:09:03 <monochrom> five times two three plus
19:09:45 <monochrom> oops, that's wrong. nevermind.
19:10:03 <ddarius> monochrom is a bad forth generator
19:10:10 <SamB> 5 2 * 3 +
19:10:30 <newsham> http://www.thenewsh.com/%7Enewsham/x/postfix.hs
19:10:51 <monochrom> I want to become a computer.
19:11:03 <LoganCapaldo> *poof* you're a computer!
19:11:12 <SamB> that trick never works!
19:11:13 <newsham> ?vixen are you a computer?
19:11:13 <lambdabot> i truely am
19:11:16 <ddarius> But only until midnight.
19:11:17 <newsham> ?vixen are you a bot?
19:11:18 <lambdabot> no, how dare you ask if i'm a bot!
19:11:33 * Axioplase you night good apply wishes apply apply 
19:11:35 <SamB> @localtime monochrom
19:11:36 <lambdabot> Local time for monochrom is Mon Oct 22 22:11:35
19:11:39 <Olathe> @vixen keyword
19:11:39 <lambdabot> Im going to be a movie star.  I just applied online for this new movie with chris farley.  It only cost me $50!
19:11:56 <Olathe> @vixen 2 + 2
19:11:57 <lambdabot> tell me a joke.. I like men that makes me laugh
19:12:05 <SamB> @vixen foo
19:12:05 <lambdabot> do you trust the government?
19:12:09 <SamB> @vixen bar
19:12:09 <lambdabot> you sound like an awesome guy... are you single?
19:12:13 <SamB> @vixen baz
19:12:13 <lambdabot> there is nothing going on in your pants that the dictatorship of the proletariat will not solve
19:12:23 <SamB> what?
19:12:27 <Olathe> O-o
19:12:33 <newsham> ?vixen blah blah blah blah california blah blah
19:12:33 <lambdabot> So, tell me your biggest and darkest secret. Something that no one knows of you.
19:12:45 <newsham> ?vixen blah blah blah sex blah
19:12:45 <lambdabot> Shouldn't we get to know each other before we talk about sex?
19:12:59 <SamB> ?vixen sex
19:13:00 <lambdabot> It's all about sex isn't it? :)
19:13:07 <Pseudonym> Biggest, darkest secrets are for #haskell-blah, please.
19:13:16 <Pseudonym> Unless your secret is something to do with Haskell!
19:13:19 <monochrom> @remember Axioplase Axioplase you night good apply wishes apply apply
19:13:19 <lambdabot> I will never forget.
19:13:29 <monochrom> Nice.
19:13:34 <ddarius> Yes she will.
19:13:40 <SamB> that's, what, postscript?
19:13:45 <omnId> unless you crash before someone @flushes
19:13:53 <SamB> @flush
19:13:54 <lambdabot> Not enough privileges
19:14:00 <SamB> @flush harder
19:14:01 <lambdabot> Not enough privileges
19:14:10 <Olathe> @flush with dynamite
19:14:10 <lambdabot> Not enough privileges
19:14:11 <ddarius> @jiggle-the-lever
19:14:12 <lambdabot> Unknown command, try @list
19:14:13 <Olathe> :(
19:14:26 <sjanssen> @flush
19:14:31 <Olathe> !
19:14:42 <SamB> @open-the-lid-and-do-it-manually
19:14:42 <lambdabot> Unknown command, try @list
19:15:19 <Olathe> @help vixen
19:15:19 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
19:15:26 * omnId runs from Olathe and hides in a cardboard box.
19:15:36 <Olathe> O-o
19:15:45 <omnId> You said "!"
19:15:52 <Olathe> ?
19:15:55 <omnId> It seemed the logical thing to do.
19:16:08 <omnId> Metal Gear Solid
19:16:12 <Olathe> Ahh :)
19:16:43 <omnId> Good, a question mark, I guess I can come out now :D
19:16:51 <ddarius> ã‹
19:17:06 <omnId> ãˆï¼Ÿ
19:17:28 <Spark> Î»
19:17:42 <SamB> a fake question mark?
19:17:44 <ddarius> ã‚ã®ãŠãŠã€‚ã€‚ã€‚
19:17:54 <Olathe> ï¼¹ï½…ï½“ ï¼
19:18:05 <LoganCapaldo> Î»ãˆ.ã‹
19:18:09 <omnId> ä½•ï¼Ÿåˆ†ã‹ã‚‰ã‚“ã€‚
19:18:33 <SamB> fake letters now!
19:18:38 <LoganCapaldo> == const ã‹
19:18:55 <SamB> > ä½•ï¼Ÿåˆ†ã‹ã‚‰ã‚“
19:18:55 <lambdabot>  Illegal character ''\189''
19:18:58 <Olathe> > ï½†ï½ï½Œï½„ï½’ ï¼ˆï¼Šï¼‰ ï¼‘ ï¼»ï¼‘ï¼Žï¼Žï¼‘ï¼ï¼½
19:18:58 <lambdabot>  Illegal character ''\189''
19:19:26 <SamB> lambdabot doesn't seem to understand utf-8 very well
19:19:37 <LoganCapaldo> you guys are making my client use non monospace fonts I think, and it;s throwing it off it's game :)
19:19:45 <omnId> > 'â—‹'
19:19:45 <lambdabot>  Improperly terminated character constant
19:20:07 <SamB> LoganCapaldo: you at least need a biwidth font for JISy stuff
19:20:30 <LoganCapaldo> I mena its's doing it but it looks out of place :)
19:21:04 <SamB> LoganCapaldo: switch to a bidwidth font with all the characters you'd find in Japanese texts
19:21:11 <SamB> er.
19:21:12 <SamB> biwidth
19:21:40 <Olathe> > ??
19:21:41 <lambdabot>   parse error on input `??'
19:21:46 <Olathe> :(
19:21:46 <omnId> X-Chat doesn't show they characters correctly in Dejavu Sans Mono, but I'm sure the font supports them.
19:22:00 <ddarius> > let (??) = id in (??)
19:22:01 <lambdabot>  Add a type signature
19:22:10 <Olathe> > (ord '?', ord '?')
19:22:12 <lambdabot>  (63,63)
19:22:19 <Olathe> Stupid IRC client.
19:22:54 <ddarius> > let Î± = 3 in Î±
19:22:54 <lambdabot>  Illegal character ''\177''
19:23:11 <centrinia> > let alpha=3 in alpha
19:23:13 <lambdabot>  3
19:23:19 <omnId> @type (:3)
19:23:21 <lambdabot> forall a. (Num [a]) => a -> [a]
19:23:41 <centrinia> What the fsck?
19:23:49 <centrinia>  :: (Num [a]) =>
19:23:50 <ddarius> centrinia: What?
19:24:08 <omnId> centrinia: just define instance Num [a] and that expression is perfectly valid.
19:24:08 <ddarius> You can make lists into an instance of Num and then (:3) would be perfectly valid.
19:24:17 <omnId> O_o
19:24:19 <omnId> whoa
19:25:45 <SamB> omnId: I'm fairly certain dejavu sans mono is not a biwidth font
19:25:54 <centrinia> Something is weird about :: (Class (DataType a)) => a -> DataType a
19:26:00 <omnId> "biwidth"?
19:26:14 <SamB> well, you know, with double-width and single-width characters?
19:27:17 <omnId> they don't show up correctly as in not at all.  The japanese is just the generic "character not supported" glyphs.
19:28:56 <omnId> is it just that other programs switch the font in the middle of the flow?  /me checks the dejavu character support list.
19:29:35 <SamB> I'm pretty sure in my x-chat a font other than the usual font is used for japanese
19:29:49 <SamB> for one thing, it isn't anti-aliased like the usual one is
19:30:07 <SamB> even the wide latin characters
19:30:42 <Shimei> I'm reading O'Neil's "The Genuine Sieve of Erastosthenes" and tried the naive prime sieve it shows on the first page. Apparently it's supposed to take a few seconds for primes !! 19 but it's darn near instantaneous on ghci here. ;)
19:32:13 <Shimei> (not to say that that algorithm is sufficient, it just doesn't give me the shock it probably was supposed to)
19:32:52 <mgsloan> does portland state uni have a nice amount of haskell/etc ?  (Since galois is there)
19:33:12 <SamB> omnId: I am not seeing any japanese characters in this font when looking at it in fontforge..
19:33:13 <omnId> U+4e00 CJK Unified Ideographs (0/0) (0/0) (0/0)
19:33:27 <omnId> apparently not :)
19:33:40 <SamB> what tool told you that?
19:34:18 <omnId> http://dejavu.sourceforge.net/wiki/index.php/Current_status
19:34:20 <lambdabot> Title: Current status - DejaVuWiki
19:34:34 <omnId> internet
19:34:40 <omnId> it's a pretty useful tool :)
19:34:50 <SamB> aww
19:34:55 <SamB> not a program?
19:36:48 <omnId> Strange that my xchat doesn't switch fonts to display the characters.  Maybe it's something to do with being the unofficial Windows build?
19:38:56 <SamB> possibly
19:39:13 <SamB> probably related to WHICH unofficial build it is
19:41:02 <omnId> silverex, I believe
19:43:38 <saz> trac and darcs, has anyone done it?
19:44:37 <SamB> saz: it doesn't seem to be set up properly for GHC afaict...
19:44:53 <saz> hrm
19:45:01 <saz> that's a worry
19:45:13 <SamB> not sure exactly
19:45:20 <SamB> what does the integration do anyway?
19:45:23 <saz> I installed the plugin
19:45:29 <saz> but I get a strange error
19:45:58 <saz> http://trac.edgewall.org/ticket/5939 <- namely this one
19:46:00 <lambdabot> Title: #5939 (float conversion bug in util/datefmt.py) - The Trac Project - Trac
19:46:16 <saz> thank you lambdabot
19:46:36 <saz> samB: lets me browse my darcs repo
19:46:49 <saz> get timeline info, link tickets and wiki pages to it
19:47:33 <SamB> for all I know it does do all those things
19:48:10 <saz> it claims to
19:48:10 <SamB> hmm, I'm having trouble connecting to hackage.haskell.org though
19:48:17 <saz> i just can't get it to run properly
19:48:22 <saz> me too
19:48:41 <SamB> so a little hard to see if all those things work for ghc
19:49:47 <SamB> they seem to have pointed out that you are using a 0.11 plugin on a 0.10 trac
19:50:29 <saz> hrm, right http://osdir.com/ml/lang.haskell.libraries/2006-01/msg00054.html
19:50:30 <lambdabot> Title: Re: New bug tracker: Trac
19:50:48 <saz> samB: yeah, I realise that, but I'm not sure how to get the older version of the plugin
19:51:41 <saz> if i follow the instructions for patching trac, and build it, it builds version 0.10 itself
19:51:50 <saz> which is what I have installed on my box anyway
19:53:04 <SamB> apparantly the newer versions don't require you to patch trac
19:53:10 <saz> yeah
19:53:18 <saz> so, i followed the installing an egg instructions
19:53:22 <saz> and got that error
19:53:53 <dibblego> $ cat .xchat2/xchatlogs/FreeNode-#haskell.log | grep "<SamB>" | grep "apparantly" | wc -l
19:53:54 <dibblego> 36
19:54:00 <dibblego> apparently! :)
19:54:04 <shapr> @seen sara
19:54:04 <lambdabot> sara has changed nick to saz.
19:54:04 <lambdabot> saz is in #haskell. I last heard saz speak 42s ago.
19:54:11 <shapr> hey saz, haven't seen you here in years.
19:54:14 <saz> g'day shapr
19:54:17 <saz> yeah
19:54:20 <saz> been busy :)
19:54:27 <shapr> Good to be busy.
19:54:36 <Pseudonym> It depends on the kind of busy, I suspect.
19:54:46 <Pseudonym> Busy writing TPS reports == not so good.
19:55:00 * saz has been all sorts of busy
19:55:00 <SamB> dibblego: so I can't spell
19:55:09 <saz> so, has anyone tried darcs web?
19:55:13 <dibblego> SamB, spelling errors just glare at me is all :)
19:55:28 <SamB> you glare at them
19:55:35 <dibblego> no, they glare at me
19:55:46 * saz is quite amazed that this channel has 373 users now!
19:55:52 <ddarius> @users
19:55:52 <lambdabot> Maximum users seen in #haskell: 420, currently: 373 (88.8%), active: 14 (3.8%)
19:56:03 <saz> it used to be quite a quiet little channel, way back
19:56:32 <ddarius> Since I don't recall you, that has to be way way back
19:56:50 <saz> probably around 04 or 05
19:56:54 <saz> last time i was here
19:57:15 <Shimei> I don't about other new folks, but I hang around here because it's one of the friendliest channels I know of.
19:57:19 <SamB> how long were you here for?
19:57:26 <Shimei> Especially for a channel full of programmers.
19:57:32 <dibblego> it has good signal:noise
19:57:33 <Shimei> s/about/know about/
19:58:09 <SamB> maybe because we aren't tormented by the language, and because we've had such good examples ;-)
19:58:53 <saz> samB: a coupla years
19:59:08 * saz used to tutor haskell, and hung around here for a while
19:59:52 <Pseudonym> Where did you tutor?
20:00:01 <saz> unsw
20:00:09 <Pseudonym> Right.
20:00:24 * SamB expands that in a strange way
20:01:38 <saz> samB: how?
20:01:46 <saz> university of new south wales, sydney, australia
20:02:10 <SamB> I expanded it as "university that's not safe for work"
20:02:21 <saz> heh, okay..
20:02:51 <SamB> I'm familiar with the acronym as it's in dons' website's address and was in his dns names for the longest time, too
20:02:54 <Shimei> Speaking of language torment, I answered a class discussion question wrong today because of Haskell. I figured the size() method in a loop would cause n^2-ness, but then I thought "Oh wait, Java doesn't do infinite lists..."
20:03:09 <LoganCapaldo> hehhe
20:03:12 <saz> yeah, i know dons :)
20:03:25 <dibblego> Shimei, sure it does; they call them iterators instead
20:04:03 <SamB> so apparantly dons is trying to escape his fate as lambdabot's maintainer
20:04:10 <dibblego> 37
20:04:55 <Shimei> dibblego: Hmm. How are iterators like infinite lists? I mean, it's still backed by a finite list right?
20:05:04 <mgsloan> well, if the object is a linked list, the size would cauze n^2-ness
20:05:07 <dibblego> Shimei, not necessarily
20:05:18 <mgsloan> I think java might support generators via iterators
20:05:29 <dibblego> Shimei, new Iterator<Integer>{public boolean hasNext() { return true; } public Integer next() { return 7; }}
20:05:32 <dibblego> > repeat 7
20:05:34 <lambdabot>  [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7...
20:05:55 <dibblego> Shimei, there is a difference in that Iterator.next is side-effecting
20:06:00 <mrd> ack! accursed java! begone
20:06:02 <dibblego> Shimei, but that can be fixed (I have done such a thing)
20:06:07 <centrinia> > sum (repeat 7)
20:06:11 <lambdabot> Terminated
20:06:16 <Soliah> This channel is quite active :O
20:06:23 <omnId> @. elite run last [1..]
20:06:27 <lambdabot> TErmina7ed
20:06:34 <Spark> > average (repeat 7)
20:06:35 <lambdabot>   Not in scope: `average'
20:06:37 <Spark> :(
20:06:38 <dibblego> Shimei, immutable lazy list in Java: http://projects.tmorris.net/public/jatheism/artifacts/0.1-alpha2/javadoc/net/jatheism/data/Stream.html
20:06:41 <lambdabot> Title: Stream, http://tinyurl.com/23jebx
20:06:50 <sjanssen> haskell-logs % grep "SamB.*apparantly"  * | wc -l
20:06:50 <sjanssen> 401
20:07:00 <sjanssen> dibblego: it's way higher than that :)
20:07:02 <centrinia> average a = (sum a) `div` (length a)
20:07:08 <dibblego> sjanssen, heh nice :)
20:07:12 <Shimei> mgsloan: I thought so too, but I think the LinkedList class may store the size as an additional field.
20:07:24 <Shimei> mgsloan: My prof. claimed that is the case anyhow.
20:07:28 <mgsloan> ah
20:07:34 <mgsloan> well, you never know either way
20:07:51 <mgsloan> depends on the efficiency guarantees of the lib
20:08:03 <ddarius> saz: Ah, I just missed you then.
20:08:11 <Shimei> dibblego: Oh, that is neat. That might make Java programming a bit more tolerable. :o
20:09:07 <omnId> <X> F<F<X,D>,F<X,C>>  |  compose()  -- oh god :O
20:09:21 <Shimei> dibblego: Oh, and you have a function class. Neat.
20:09:22 <saz> ddarius: your name sounds familiar I think
20:09:47 <ddarius> We were both probably on for a while, but not enough to remember the other.  I went by Darius then.
20:09:50 <LoganCapaldo> Wasn't Darius a persian emperor or soemthing?
20:10:27 <saz> yeah
20:10:31 <monochrom> I watched the movie Alexander yesterday. Darius was a defeated Persian emperor. :)
20:10:59 <monochrom> There were probably several consecutive Darius'es before that one.
20:11:03 <LoganCapaldo> That's why we got ddarius. He aint never been defeated by alexander the great
20:11:19 <Shimei> Darius was the one defeated by the Spartans after Thermopylae right?
20:11:33 <centrinia> No, that's Xerces I think.
20:11:41 <centrinia> Or is it?
20:12:08 <LoganCapaldo> This is madness! This is blasphemy! This is an XML Paaaarser!
20:12:10 <dibblego> Shimei, it's not really tolerable; it's also to make a point
20:12:17 <omnId> @slap LoganCapaldo
20:12:17 <lambdabot> *SMACK*, *SLAM*, take that LoganCapaldo!
20:12:21 <idnar> haha
20:12:42 <idnar> anyhow yeah, it was Xerxes at Thermopylae
20:12:57 <centrinia> Is there a Persian emperor named Xalan?
20:13:07 <LoganCapaldo> I hope so
20:13:17 <idnar> Xerxes I, son of Darius I
20:13:24 <saz> oh, Koroush
20:13:26 <Shimei> Ah, I think Darius I was succee... idnar beat me to it.
20:13:31 <saz> all those weird roman names for those people
20:13:40 * saz knows the persian ones :)
20:14:05 * Shimei only vaguely knows of these bits of history because he read about Persians after watching 300
20:14:42 <monochrom> what is the persian name of darius?
20:15:25 <idnar> it transliterates as "DÃ£rayavahush", apparently
20:15:55 <dibblego> @karma+ idnar (apparently)
20:15:55 <lambdabot> idnar's karma raised to 1.
20:15:59 <saz> monochrom: dariyush
20:16:04 <saz> or daryush
20:16:18 <monochrom> interesting
20:16:34 * saz been to persepolis where he's buried 
20:16:37 <saz> it's really cool
20:16:40 <idnar> I think "Darius" is Greek, not Roman
20:16:50 <allbery_b> yes, as is "Xerxes"
20:17:28 <Pseudonym> That would ho Darios, then.
20:17:48 <allbery_b> hm?  Greek sometimes uses -us
20:18:02 <Pseudonym> Not for masculine nominative.
20:18:11 <Pseudonym> It's sometimes transliterated into Latin as -us.
20:18:35 <idnar> hmm, maybe it's a corrupted Latin form
20:18:39 <drtomc> Pseudonym: geek!
20:18:43 <idnar> well, "corrupted" isn't what I mean, but whatever
20:18:51 <idnar> I did Latin in high school, but I'm only vaguely familiar with Greek
20:18:56 <Pseudonym> drtomc: Me and everyone else here, duh.
20:19:06 <Pseudonym> :-)
20:19:23 <drtomc> Pseudonym: exactly. :-)
20:19:25 <monochrom> Geeks would say U+0044 U+0061 etc.
20:19:33 <idnar> haha
20:19:44 <Pseudonym> % cat - > name.txt.gz
20:20:00 <allbery_b> only unicode geeks.  fake ones; the real ones would use the Arabic/Persian chgaracters for his real name :)
20:20:03 <omnId> @wn geek
20:20:05 <lambdabot> *** "geek" wn "WordNet (r) 2.0"
20:20:05 <lambdabot> geek
20:20:05 <lambdabot>      n 1: a carnival performer who does disgusting acts
20:20:05 <lambdabot>      2: a person with an unusual or odd personality [syn: {eccentric},
20:20:05 <lambdabot>          {eccentric person}, {flake}, {oddball}]
20:20:33 <drtomc> Mmmm, I like sense 1. :-)
20:20:37 <Pseudonym> ?jargon geek
20:20:39 <lambdabot> *** "geek" jargon "Jargon File (4.3.1, 29 Jun 2001)"
20:20:40 <LoganCapaldo> so would a unicode geek multibite the head off a chicken?
20:20:40 <lambdabot> geek n. A person who has chosen concentration rather than conformity;
20:20:43 <lambdabot>    one who pursues skill (especially technical skill) and imagination, not
20:20:45 <lambdabot>    mainstream social acceptance. Geeks usually have a strong case of
20:20:46 <lambdabot>    {neophilia}. Most geeks are adept with computers and treat {hacker} as a
20:20:48 <lambdabot> [25 @more lines]
20:21:45 <ddarius> Nails still not long enough.
20:22:44 <saz> hrm
20:22:49 <saz> so has anyone tried darcsweb?
20:23:35 <idnar> @wn neophilia
20:23:36 <lambdabot> No match for "neophilia".
20:23:40 <ddarius> Lover of new things
20:23:42 <idnar> @jargon neophilia
20:23:43 <lambdabot> *** "neophilia" jargon "Jargon File (4.3.1, 29 Jun 2001)"
20:23:43 <lambdabot> neophilia /nee`oh-fil'-ee-*/ n. The trait of being excited and pleased
20:23:43 <lambdabot>    by novelty. Common among most hackers, SF fans, and members of several
20:23:43 <lambdabot>    other connected leading-edge subcultures, including the pro-technology
20:23:43 <lambdabot>    `Whole Earth' wing of the ecology movement, space activists, many
20:23:45 <lambdabot> [5 @more lines]
20:23:49 <idnar> heh
20:25:31 <monochrom> Neophilia means they really love Neo. :)
20:30:35 <omnId> ?brain Are you pondering what I'm pondering?
20:30:35 <lambdabot> Well, I think so, but Kevin Costner with an English accent?
20:31:03 <mgsloan> ?pinky Narrf!
20:31:04 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}: Parse error
20:31:42 <omnId> hmm!  I wonder what that spellchecked into?
20:32:29 <omnId> @pointy Narrf!
20:32:29 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}: Parse error
20:53:35 <dibblego> ?hoogle (a -> Maybe a) -> a -> [a]
20:53:36 <lambdabot> No matches, try a more general search
20:54:48 <dibblego> is there an iterate that produces a finite list?
20:55:00 <ddarius> unfoldr
20:55:05 <dibblego> of course, cheers
20:55:10 <ddarius> Or just takeWhile of iterate
20:56:48 <dons> oh, that means hackage is down too
20:58:19 <dibblego> msg lambdabot ?src unfoldr
20:58:28 <omnId> @type \f x -> unfoldr (fmap (\z->(z,z)) . f) x
20:58:30 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
21:03:41 <omnId> @type flip (.) (fmap (\x->(x,x) .) unfoldr
21:03:43 <lambdabot> parse error on input `)'
21:04:01 <omnId> @type flip (.) (fmap (\x->(x,x)) .) unfoldr
21:04:03 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
21:04:07 <omnId> :D
21:05:17 <bbrown> (off-topic) I have a general one-off question on a subject I dont know about.  If I have a map-reduce utility, say; A url (dog.com) has two words, dog and cat; dog=432 instances, cat=300 ... how is that utility used in tools like web search?
21:05:56 <sorear> bbrown: I'm pretty sure it's a trade secret.
21:06:27 <bbrown> sorear: nutch/lucene uses similar methods
21:07:12 * wli wishes there were more anamorphism variations besides unfoldr.
21:09:20 <wli> @src unfoldr
21:09:21 <lambdabot> unfoldr f b  = case f b of
21:09:21 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
21:09:21 <lambdabot>    Nothing        -> []
21:10:19 <blackdog_> hey, i'm looking for a data structure and am not sure if there's something in the libraries - I want to be able to give the structure an integer and get back all the values with keys as big as or larger than that. it should be no worse than logarithmic for the original lookup, and i don't want to have to pay more than linear time even if i end up getting all the keys. any ideas? i'm currently thinking of some kind of balanced tree...
21:11:09 <sorear> blackdog_: you can do it with Data.FingerTree
21:11:17 <blackdog_> (it's probably too sparse for just an array with links to a list of results)
21:11:24 <blackdog_> ok, i'll look that up. thanks.
21:11:53 <blackdog_> argh. is hackage.haskell.org down today?
21:13:00 <sorear> so is planet
21:13:28 <Nico_Reed> what does hackage.haskell have on it?
21:13:45 <TSC> Haskell packages
21:13:47 <shachaf> Nico_Reed: Hackages?
21:13:55 <sorear> dons: any major failures up there?  (galois hosts hackage. and planet., right?)
21:14:02 <Nico_Reed> alright
21:14:39 <shachaf> Hmm -- galois.com is also down?
21:17:18 <bparkis> fans of OO make a big deal out of data hiding
21:17:52 <bparkis> but haskell's algebraic data types get along fine without having any data hiding
21:17:53 <dons> sorear: yes :( power failure in the suburb, traffic lights out, building out, UPS run out of power
21:18:08 <bparkis> how can these two things be reconciled?
21:18:15 <bparkis> why is data hiding not valuable in an algebraic data type?
21:18:24 <omnId> Haskell has data hiding
21:18:32 <bparkis> but not in ADTs
21:18:35 <omnId> just don't export your constructor names.
21:18:37 <dons> bparkis: haskell has type level data hiding
21:18:52 <dons> with existential types you get a proof from the type checker that your data is hidden
21:18:55 <sorear> bparkis: you can still use the ADTness inside the definiting module
21:19:09 <Nico_Reed> BTW OO is just one way to approach the problem
21:19:52 <wli> I've never used existential types. How would one use them where one otherwise merely hides constructor names?
21:19:57 <bparkis> well then would it be accurate to say that data hiding is _less_ necessary for ADTs?
21:21:00 <dons> wli: if you want to ensure the representation of some type is entirely, absolutely guaranteed to be hidden, typically with a typeclass to provide the api
21:21:15 <dons> so you can be polymorphic over several representation types
21:21:26 <bparkis> the purpose of data hiding is to prevent other blocks of code from taking advantage of structure in your code that you don't consider to be essential and might change
21:21:54 <wli> dons: So the API that manipulates the type with hidden constructors becomes the typeclass bounding the existential?
21:21:56 <dons> you need algebraic data types first and formost , imo :)
21:22:13 <dons> wli, yep. and you provide an instance for each concrete type
21:22:24 <wli> dons: Sounds easy enough.
21:22:49 <dons> then, from the outside, you can be guaranteed code cannot depend on the representation in some way, just by looking at the type
21:23:53 <bparkis> just being pure functional does something similar to data hiding--if you call a pure function then the only way to interact with it is through its defined interface, its parameters
21:24:17 <bparkis> but if you are in an imperative language there may be other ways to influence the action of a procedure, by setting data structures to some value before calling
21:24:18 <dons> yes, purity (and strong typing) really go hand in hand in making code safe
21:24:26 <dons> you want the type to fully specify the behaviour, ultimately
21:24:31 <dons> and purity sure helps there
21:24:40 <dons> polymorphism is also very useful, in that respect
21:24:56 <dons> since that's yet another way of getting a proof from the compiler that code can't secretly depend on some representation detail
21:25:16 <dons> its kind of sad how little this is understood by the wider programming community
21:28:26 <bparkis> you define certain 'interface'-level properties about your code and guaranteeing that external code won't depend on any property of your code that isn't specified in the interface
21:28:40 <dons> exactly
21:28:50 <dons> reliability, reliability, reliability!
21:28:58 <dons> also, it helps not to trust anyone :)
21:29:12 <mgsloan> developers, developers, developers!
21:29:25 <dons> purity, purity, purity!
21:29:47 <saz> hello dons!
21:29:56 * jleedev thinks asp.net is the antithesis of purity
21:30:09 <bparkis> in top down design you would specify the abstract properties of your code first, then write it
21:30:27 <allbery_b> pretty much anythuing for web development is the antithesis of purity :/
21:30:37 <bparkis> in bottom up design  you would write code in the right general direction, then derive properties from that and defined those properties as your interface
21:31:08 * wli looks at his bloglessness, then at the time, and despairs.
21:31:28 <dons> hi saz
21:31:33 <vininim> talking about top-down/bottom-up, are there any writings about software enginering techniques for functional languages?
21:31:33 <dons> !
21:31:38 <dons> saz: how's Sydney :)
21:31:46 <saz> dons: hot!
21:31:48 <saz> you've gone away?
21:31:50 <dons> ?temp
21:31:51 <lambdabot>   now 19.7°, min 17.6°, max 20.7°, rain 0.0mm, wind 18km/h SSE
21:31:55 <dons> saz: I live in the US now
21:32:01 <saz> cool! where?
21:32:16 <dons> in Portland, Oregon (/me practices his american 'orrrrr' sounds)
21:32:21 <saz> ah
21:32:33 <saz> finished your phd?
21:32:44 * saz doesn't think she's seen you for at least 2-3 years
21:33:32 <bparkis> if every function were a pure function from numbers to numbers, without 'cheating' and encoding other types within numbers, then i don't think it would be ever necessary to hide any implementation
21:34:09 <omnId> bparkis: but why limit yourself to numbers :)
21:34:18 <bparkis> data hiding is only important when you add imperative state or more complex types
21:34:30 * wli works out of an office downtown these days.
21:34:39 <dons> saz: almost finished, just writing up the parts now.
21:35:11 <mgsloan> hmm, how is portland? is the uni there pretty functional-oriented? (perhaps causing galois to spring up there)
21:35:28 <bparkis> i think if you had a big bag of functions from numbers to numbers, you could just copy use any of them and use it in your program and doing so wouldn't constrain anything else
21:35:51 <saz> dons: yay!
21:36:14 <sclv> back to an earlier topic: are there any other handy anamorphism idioms besides unfoldr and (takeWhile . iterate) and family that folks find themselves using?
21:37:45 <bparkis> if all functions were pure and had the same type signature they would be completely 'uncoupled' in OO terms
21:39:22 <omnId> not sure what having the same signature has to do with that.
21:40:09 <bparkis> well let's say you have a special type T only used by 2 functions, T is the output type of 1 function and the input type of the other function
21:40:18 <bparkis> then those two functions would be very closely coupled because of T
21:40:40 <bparkis> since they can't be used independently of each other
21:40:48 <andyjgill_> Hi glguy
21:40:57 <glguy> andyjgill_: Hello
21:41:05 <glguy> andyjgill_: is something wrong with the office network?
21:41:19 <andyjgill_> I was going to ask you the same question
21:41:24 <andyjgill_> :-)
21:41:29 <glguy> then... yes, I think there is
21:41:42 <bparkis> a type couples together all of the functions that use that type
21:41:45 <andyjgill_> *.haskell.org is also having problems, so the link is down I expect
21:41:50 <glguy> kk
21:42:08 <sclv> bparkis: but if you required all functions to have the same type, then they'd be coupled to the types, which is just as bad!
21:43:10 <bparkis> well they'd be very limited, and maybe not very useful, but if every function is coupled to the same type then they are all loosely coupled
21:43:25 <bparkis> since you could sensibly use any function with any other function
21:44:49 <bparkis> i'm not saying it would be good i'm just holding it up as an example of loose coupling
21:44:52 <sclv> bparkis: who says it would be sensible?
21:45:27 <bparkis> well if you have a function, square, from the reals to the reals, and a function plus 1, from the reals to the reals,  you can compose them to get a function that squares and adds one
21:45:47 <bparkis> if all functions have an identical input and output type then you can compose any two functions
21:46:00 <bparkis> can you think of where that might not be sensible?
21:46:45 <omnId> if you want something more useful than a single real?
21:47:03 <bparkis> yeah, that's the flaw in the ideal
21:48:26 <sclv> but if you have a function getSpeed from reals and reals to reals that takes an acceleration and a time and returns a speed, and another function from reals to reals that returns the seconds from a timestamp, you could call getSeconds . getSpeed and it would make no sense at all!
21:48:38 <sclv> that's what types protect you from.
21:48:51 <dons> andyjgill_, glguy : big power failure at the round.
21:48:51 <bparkis> well i'd call that cheating, since you really need more complex types than you're using
21:49:14 <andyjgill_> dons: we're on #ghc
21:49:17 <bparkis> if functions are all from reals to reals you shouldn't be doing things like encoding times in them, or strings
21:49:51 <bparkis> so you could have insensible compositions of functions, but only if you cheat and try to encode more data into the type than it was designed for
21:50:35 <bparkis> which is admittedly subjective afaik
21:52:41 <sclv> ok so instead of getSeconds you just have getSpeed twice -- but getSpeed's inputs aren't a speed, but are a span of seconds and an acceleration, right? except all three are reals. you could say that getSpeed has the wrong name then, and should just describe what it does, but then you lose all abtraction. what would you call your square and add one method? the only possible name is squarePlusOne.
21:52:43 <bbrown> http://darcs.haskell.org/
21:52:58 <sorear> @bot
21:52:58 <lambdabot> :)
21:53:02 <sorear> *phew*
21:53:09 <sorear> why do people use lambdabot for this
21:53:18 <bbrown> sorear, I am new here
21:53:24 <bparkis> well trying to encode a speed into a real is just a lesser degree of trying to encode a string into a real
21:53:44 <sorear> It seems to have magically fixed itself, but pasting an unresponsive URL used to crash lambdabot
21:53:53 <bbrown> sorear: I guess you noticed what I noticed
21:54:09 <bparkis> if you think about the type as something other than a real number then the function needs a more complex type that reflects how it should be used
21:54:45 <sclv> bparkis: sorry, i'm just being a bit prickly here.
21:54:51 * allbery_b is still running tha version of lambdabot
21:55:04 <bparkis> you might say that part of the purpose of having complex types is to couple together functions that should only be used together
21:55:05 <allbery_b> in preference to the one that loses its marbles multipl times da day...
21:55:08 <bparkis> sometimes close coupling can be good
21:57:22 <omnId> @type (++)
21:57:24 <lambdabot> forall a. [a] -> [a] -> [a]
21:57:34 <dons> sorear: lambdabot's a bit scary / magic
21:57:42 <omnId> ^ this works whatever type of list it uses
21:57:55 <nburlett> hello!
21:57:56 <omnId> it constrains just the listy part of it.
21:58:08 <nburlett> what library am I missing? Setup.lhs: cannot satisfy dependency text-any
21:58:08 <omnId> so that it can perform listy operations on it.
21:58:30 <nburlett> (hackage is down :-<)
21:58:41 <dons> hackage is down, yes.
21:59:24 <nburlett> what do I need to satisfy "text-any" ?
21:59:42 <dons> the 'text' package, which is normally on darcs.haskell.org and hackage
21:59:50 <dons> however, that server is down due to power failure
21:59:55 <nburlett> oops
21:59:58 <dons> we live in interesting times
22:00:05 <nburlett> so-cal?
22:00:39 <dons> nope, not sure how widespread the power failure is though
22:01:03 <bparkis> sclv: i think that the flaw in your argument is in trying to create any abstraction at all without reflecting it in the type
22:01:05 <wli> It hasn't affected Tanasbourne near 185th & Evergreen.
22:01:33 * nburlett is thwarted at every turn
22:02:02 <bparkis> so if your function getSpeed takes an acceleration and a time and returns acceleration * time, it should be called multiply
22:02:43 <wli> Shouldn't it be integration?
22:02:56 <bparkis> abstracting the function name to say 'getSpeed' says that it produces something called a 'speed' when it's actually a real
22:03:11 <bparkis> so it could be considered slightly misnamed
22:04:11 <bparkis> wli: no integration, it's a function of real numbers only
22:05:10 <newsham> does irssi support unicode/utf8?  if so, how do you enter weird chars in it?
22:05:11 <wli> dv/dt = a(t), so v(t) = int a(t) dt
22:05:32 <bparkis> if your function only deals in real numbers it can't integrate, integration takes a function as an argument
22:05:56 <wli> It's a functional language. Just pass in a function.
22:05:58 <bparkis> so if you're given an acceleration as a real number you'd probably assume it's constant acceleration
22:06:41 <wli> Use adaptive Kronrod-Patterson integration or something.
22:06:44 <bparkis> i'm talking about a hypothetical useless language of functions from reals to reals only
22:06:50 <bparkis> you can't pass in a function
22:07:27 <bparkis> even having 2 arguments is a little bit of a stretch
22:08:03 <sorear> newsham: Type them.
22:08:39 <sorear> newsham: Irssi supports wierd characters transparently.  Inputting a vs A vs C-A is not it's concern; likewise inputting Î» is not.
22:09:04 <newsham> âˆ€
22:09:06 <sorear> newsham: In all the Unicode-capable terminals I know of, Control-Shift-HEX
22:09:18 <sorear> 2200 âˆ€, 3BB Î», etc
22:09:34 <newsham> [19:09] < sorear> 2200 \u2200, 3BB \u03bb, etc
22:09:37 <newsham> is that what you see?
22:09:48 <bbrown> what a great time to test distributed version control, anybody another url mirror of darcs.haskell.org
22:10:07 <nburlett> oh well, good night
22:10:10 <omnId> I see a turn-A and a lambda
22:10:39 <sorear> newsham: http://members.cox.net/stefanor/1193116226.png
22:11:11 <sorear> bbrown: I'd put it up if I didn't have a 10MB hard quota
22:11:25 <newsham> ahh, so my paste worked for you too
22:12:01 <sorear> "my paste"?
22:12:01 <bbrown> sorear: 10MB hard quota, is that on a college host
22:12:10 <sorear> bbrown: no, it's an ISP thing :/
22:12:12 <newsham> [19:08] < newsham> \u2200
22:12:21 <newsham> i just saw u2200
22:16:28 <bparkis> i wonder if there is such a thing as an alternate 'view' of a data structure
22:16:36 <sorear> yes there is
22:16:39 <sorear> @go Views
22:16:41 <bparkis> so it can be looked at as being of one type with one set of constructors by one function
22:16:41 <lambdabot> http://en.wikipedia.org/wiki/View_(database)
22:16:41 <lambdabot> Title: View (database) - Wikipedia, the free encyclopedia
22:16:44 <wli> Try views.
22:16:52 <sorear> @go Views wadler
22:16:54 <lambdabot> http://citeseer.ist.psu.edu/wadler86views.html
22:16:54 <lambdabot> Title: Views: A way for pattern matching to cohabit with data abstraction - Wadler (Res ...
22:16:56 <bparkis> and being looked at as of another similar type but with different constructors by another function
22:17:04 <sorear> bparkis: there's the paper
22:18:08 <omnId> bparkis: just export a function that transforms your type A into a view type B, export B's constructors but not A's.
22:18:58 <omnId> @type Data.Sequence.viewr
22:19:00 <lambdabot> forall a. Data.Sequence.Seq a -> Data.Sequence.ViewR a
22:19:52 <omnId> ghc has now added syntax to support application of these view functions in the middle of a pattern.
22:21:01 <omnId> data ViewR a
22:21:01 <omnId> = EmptyR
22:21:01 <omnId> | (:>) (Seq a) a
22:22:35 <bparkis> you could separate the concept of a type from the constructors it is represented by
22:23:08 <wli> GADT's are pretty close to that already.
22:23:20 <bparkis> what is a GADT?
22:23:28 <bparkis> generalized ADT?
22:24:24 <bparkis> lucky guess
22:24:28 <wli> Generalized Algebraic Data Type
22:24:40 <omnId> yes, they allow you to (as far as I understand) restrict the result types of each constructor.
22:24:44 <wli> The 'A' is for "Algebraic" not "Abstract."
22:25:12 <arcatan> give me an example of a GADT
22:27:33 <omnId> http://haskell.org/haskellwiki/Generalised_algebraic_datatype
22:27:34 <lambdabot> Title: Generalised algebraic datatype - HaskellWiki
22:28:34 <sorear> wli: I don't think gadts have anything to do with views?
22:28:58 <wli> Separating the concept of a type from the constructors it's represented by.
22:29:58 <sorear> ... that's just syntax, has nothing to do with the G-ness
22:41:28 <wli> Usually they're mini-interpreters or something.
22:45:06 <saz> yay
22:45:11 <saz> i have darcsweb installed :-)
22:57:18 <blackdog_> i may have hallucinated this, but does quickcheck have support for automatically shrinking failing cases?
22:57:57 <dmwit> shrinking?
22:58:04 <dmwit> Are you talking about the (==>) function?
22:58:05 <blackdog_> or is that just the erlang version?
22:58:34 <blackdog_> um, i could be. i saw a talk with john hughes demo-ing the erlang one, and it seemed to be able to find smaller cases automatically
22:58:36 <dmwit> Oh, you mean finding a smallest failing case?
22:58:38 <blackdog_> yeah
22:58:50 <blackdog_> not that QC isn't sex on legs already
22:58:57 <dmwit> I don't think QC has that, though I have never even used it, so don't take my word for it. =)
22:59:17 <blackdog_> fair enough.
22:59:20 <shapr> blackdog_: QC2 supports that.
22:59:27 <shapr> Look at the shrink function.
23:00:04 <andyjgill_> QC2 has shrink, and new release will be pending in the next month or so.
23:00:36 <blackdog_> shapr: oh, nice.
23:01:04 <blackdog_> man, i wish you bastards would stop making haskell nicer to use. it makes my RoR ghetto feel more and more restrictive.
23:01:42 <ddarius> blackdog_: Make ruby nicer.
23:02:13 <olsner> ... or come and join the pure side :P
23:02:26 <glguy> fixing the syntax and semantics of the language? you might as well just give it a new name
23:03:23 <allbery_b> not if you think like the perl6 folks }:>
23:07:46 <blackdog_> ddarius: there's a limited way you can go there - you can already do most of what you'd like in ruby, it's more the huge number of ways things can go wrong :)
23:19:45 <newsham> âˆ€x.xâ‰¤5
23:19:46 <newsham> yay
23:21:06 <newsham> had to turn on utf-8 in putty, change the font, run screen with the -U option, and change the irssi term_charset setting to utf-8
23:21:27 <newsham> (and encoding to utf-8 in vim, and term_charset to utf-8 in silc)
23:34:59 <viklund> go, xmonad!
23:38:24 <allbery_b> that, secretly, is one of the reasons I actually prefer to go GUI instead of CUI these days:  the GUI stuff tends to Just Work with UTF8
23:38:38 <allbery_b> and I rely on UTF8 support often enough that having it Just Work is a big win
23:38:51 * allbery_b does wish xemacs did utf8 right, though...
23:40:57 <ulfdoz> utf8 is not the big hit yet.
23:41:48 <ben> If I set my locale to utf8, my terminal emulator and screen pick it up, not sure about irssi
23:43:10 <allbery_b> it is when you do a lot of stuff involving characters not in the latin-N space (in my case, Hebrew)
23:43:22 <allbery_b> ...and some IPA
23:44:25 <allbery_b> I was rather pleasantly surprised when I discovered it was actually easier to get GNOME and KDE to deal with hebrew than it was for Windows
23:44:47 <ben> Huh, is Windows not using some sort of butchered UTF-16 all over the place already?
23:45:02 <allbery_b> (friendly hint:  NEVER try to edit Hebrew in MS Word unless you can get your hands on an an actual Israel-localized version)
23:45:06 <allbery_b> it does
23:45:24 <ben> I guess it just does not properly deal with it, then <:)
23:45:31 <allbery_b> but its RTL suppoirt is fundamentally broken except in the versions specifically targeting RTL languages
23:45:35 <caff> you need to purchase a license of microsoft multilingual ui
23:45:42 <caff> :(
23:45:52 <ben> yay gnome/kde <:)
23:46:13 <shapr> yay
23:46:21 <shapr> yay Haskell!
23:46:28 <omnId> @yarr
23:46:29 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
23:46:49 <newsham> think of all the cool utf8 smileys you could make
23:47:07 <newsham> ;-â‰¥
23:47:20 <allbery_b> same goes for Arabic, Thai, and other languages that require good support for non-LTR
23:47:47 <allbery_b> (proper Thai can be LTR I think, but requires "stacking" which is even more poorly supported than RTL)
23:47:51 <omnId> ï¼ˆï¿£Ï‰ï¿£ãƒ»ï¼‰
23:47:52 <shapr> â¤
23:48:00 <omnId> à² _à² 
23:48:06 <omnId> â—• â—¡ â—•
23:48:28 <Cale> ahaha
23:48:30 <shapr> â°¢
23:48:36 <allbery_b> and Arabic is actually worse because Windows also doesn't handle thevariant letterforms quite correctly (another thing gnome and kde tend to get right)
23:48:49 <omnId> (ã¥ï¿£ Â³ï¿£)ã¥
23:49:00 <shapr> â˜ƒ â‚« à¹› â˜  @yarr!
23:49:20 * shapr plagiarizes from http://www.inference.phy.cam.ac.uk/cjb/codepoints.html
23:49:21 <lambdabot> Title: Chris Ball: : Favourite Unicode Codepoints
23:50:32 <omnId> ï¼lã€
23:50:32 <omnId> (ï¾Ÿï½¤ ï½¡ ï¼— -WHAT
23:50:32 <omnId>  lã€ ~ãƒ½
23:50:32 <omnId>  ã˜ã—f_, )ãƒŽ
23:50:38 <shapr> whoa, utf art
23:52:52 <newsham> ?vixen âˆ€x: x â‰¥ âˆ‘ âˆšn â‹ x âˆˆ âˆ… â‹ âŠ¥ ?
23:52:53 <lambdabot> no
23:54:02 <newsham> http://www.alanwood.net/unicode/mathematical_operators.html
