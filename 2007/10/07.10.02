00:00:02 <LeCamarade> Next SML will use Monads? :: Maybe Yes
00:00:06 <LeCamarade> Just No
00:00:06 <LeCamarade> ?
00:00:31 <misterbeebee> for the pcre thing, the "fix" was to force HAVE_PCRE_H to be defined, which works for me since I installed libpcre, but I don't think is the right solution... needs more investigation to see why the proper value isn't being auto-set.
00:00:44 <misterbeebee> I'll try to look into it later this week. for now, it's midnight, and I'm turning into a pumpkin
00:01:09 <bos> misterbeebee: there's no autoconf script, afaik
00:02:40 <misterbeebee> bos:well, there's a cabal file that claims to set  CC-options: DHAVE_PCRE_H ....
00:02:43 <bos> wow, 1600 comments on the book's first 4 chapters so far.
00:02:56 <sjanssen> does regex-pcre actually work if libpcre isn't installed?
00:03:01 <misterbeebee> anyway, when I have fresh eyes I'll poke what looks like the right fix
00:03:21 <misterbeebee> sjanssen: I think package is designed to install the interface properly even if pcre is absent
00:03:41 <sjanssen> sure, the interface is installed, but does anything actually work?
00:03:50 <bos> no, it bombs out with runtime errors.
00:03:56 <misterbeebee> From PCRE.hs:
00:03:57 <misterbeebee> You will need to have libpcre, from www.pcre.org, to use
00:03:57 <misterbeebee> this module.  The haskell must be compiled with -DHAVE_PCRE_H and
00:03:57 <misterbeebee> linked with pcre.  This is the default in the cabal file.
00:03:57 <misterbeebee> If you do not compile with HAVE_PCRE_H then the functions will still
00:03:58 <misterbeebee> exist, but using them will create a run time error.  You can test for
00:03:59 <misterbeebee> the existance of PCRE by checking 'getVersion' which is 'Nothing' if
00:04:01 <misterbeebee> not compiled with PCRE or 'Just' 'String' if PCRE is present.
00:04:13 <misterbeebee> I'm not sure what the value of that mode is.
00:04:52 <sjanssen> huh, wonder why it does that?
00:04:55 <misterbeebee> Anyway, Thanks all for helping me debug my installation.
00:04:58 <misterbeebee> sjanssen++
00:05:02 <misterbeebee> bos++
00:05:04 <misterbeebee> sorear++
00:05:12 <misterbeebee> (does that work? the wiki says to give people ++'s)
00:05:22 <omniscientIdiot> @karma misterbeebee
00:05:22 <lambdabot> misterbeebee has a karma of 0
00:05:25 <omniscientIdiot> misterbeebee++
00:05:26 <omniscientIdiot> @karma misterbeebee
00:05:27 <lambdabot> misterbeebee has a karma of 1
00:05:32 <omniscientIdiot> misterbeebee--
00:05:54 <bos> andyjgill: how's freiburg?
00:06:14 <andyjgill>  Pretty busy!
00:06:15 <misterbeebee> thanks. ok, g'night all.
00:06:31 <andyjgill> Over 300 unique registrations
00:09:21 <LeCamarade> Comrades, please explain how Text.Regex (and Text.Printf) happen to know whether I am assigning or merely calling (the former ends in an object, the latter in a printing).
00:10:12 <ddarius> LeCamarade: Type inference.
00:10:23 <olsner> @type printf
00:10:25 <lambdabot> forall r. (PrintfType r) => String -> r
00:10:57 <olsner> when printed (passed to a function that takes String), the result type r is forced to String
00:11:29 <olsner> when applied to values, it's forced to (a -> r2), where a is the type of your value, and r2 is most probably another PrintfType
00:11:56 <LeCamarade> Oh. I need to read more on the forall thing, alright. :o)
00:12:05 <LeCamarade> Evil type hackery, eh?
00:12:05 <LeCamarade> Oleg!
00:12:08 <LeCamarade> X^(
00:12:24 <olsner> and iiuc, forall isn't even type hackery, just what haskell always does
00:12:43 <[LeCamarade]> Stepping off for a sec.
00:13:06 <ttfh> while on the subject, what's the difference between "forall r. (PrintfType r) => String -> r" and "(PrintfType r) => String -> r"?
00:14:05 <ddarius> ttfh: Nothing.
00:14:06 <ttfh> in the later case, the function would get "decided" on on type, instance of PrintfType, and then return only that type?
00:14:59 <ttfh> ah, so this is the implicit forall
00:15:37 <ttfh> I've read about f.ex heterogenous list using explicit forall
00:21:18 <ddarius> ttfh: In Haskell 98, all type variables are implicitly universally quantified.  The reason is that the only place you would be allowed to put foralls (if they were valid H98 syntax) would be places where they could be pulled all the way out (giving you what is called prenex form).  This is rank-1 polymorphism.
00:26:30 <ttfh> ddarius: so you can't put them anywhere else?
00:27:32 <ddarius> ttfh: In Haskell 98, you can't write them at all.  If you could write them, anywhere you would be allowed to would be equivalent to writing them at the outside.
00:27:48 <ddarius> When you go to higher-rank polymorphism, this is no longer true.
00:28:37 <ttfh> so "forall" corresponds to the upside-down "A" in predicate logic...
00:28:43 <ddarius> Yes.
00:29:00 <ttfh> is there anythin that corresponds to "there is an x such that..."?
00:29:09 <ttfh> backwards "E"
00:29:23 <opqdonut> "exists"
00:29:36 <opqdonut> :t f :: exists a. a -> a
00:29:38 <lambdabot> parse error on input `.'
00:29:40 <ddarius> Lanugages can support existential quantification (usually written 'exists'), but I believe hbc is the only implementation that had any support for "free" existentials.
00:29:44 <opqdonut> :t (f :: exists a. a -> a)
00:29:46 <lambdabot> parse error on input `.'
00:30:09 <opqdonut> hmm guess lambdabot doesn't handle ghc extns
00:30:19 <ddarius> opqdonut: That's not a GHC extension.
00:30:20 <ttfh> hmmm, so that would mean that there is a type for which the function works?
00:30:25 <shachaf> GHC doesn't handle exists, does it?
00:30:50 <ddarius> shachaf: GHC has what are called "local existentials" which are attached to data declarations.
00:31:24 <shachaf> Yes, but not "exists".
00:33:22 <ddarius> ttfh: Yes.  For example if you had a value, x :: exists a. (a,a -> String), then you'd have for some type a pair containing that value which all you know about is that you can apply the second component to it.
00:33:35 <ttfh> if I remember correctly, you can express "exists" in terms of "forall"
00:33:43 <ddarius> ttfh: Indeed.
00:34:15 <ttfh> forall x (Px or -Px)
00:34:35 <ttfh> where P is some property and -P is not that property
00:35:25 <ttfh> would "or" correspond to a union type?
00:35:37 <opqdonut> well yeah predicate logic says "not forall x: not p" <=> "exists x: p"
00:35:53 <opqdonut> and yes, or corresponds to union
00:36:00 <opqdonut> don't know about nots tho
00:36:05 <ddarius> ttfh: However, to write a "rank-1" existential requires rank-2 universals.
00:36:22 <ddarius> or usually gets mapped to Either
00:37:42 <ttfh> opqdonut: oh, I see my error
00:38:22 <opqdonut> yeah, the type system isn't as rich as predicate logic i guess?
00:38:32 <ddarius> ttfh: For example, to write x above in Haskell with (existing) extensions, would be x :: forall r.(forall a.(a, a -> String) -> r) -> r
00:40:13 <ddarius> opqdonut, ttfh: You may both find the Curry-Howard isomorphism interesting.
00:40:25 <opqdonut> yes i'm aware of curry-howard
00:40:45 <opqdonut> guess i should read more :)
00:40:45 <ttfh> I've heard of it
00:41:13 <ttfh> types are propositions? programs are proofs?
00:41:28 <ddarius> ttfh: That's the general idea, yes.
00:41:32 <ttfh> but I have no understanding of it
00:42:02 <ddarius> There are quite a few good resources online from a variety of perspectives.
00:42:43 <ttfh> I studied philosophy, including predicate logic, before CS, so It's very interesting, bringing the two together
00:44:56 <ttfh> In a similar way, the logic "below" predicate logic, was useful in digital circuits class
00:46:03 <platypus> ttfh: Thats just boolean logic?
00:46:29 <ttfh> platypus: It sounds right, it's "satslogik" in swedish...
00:46:48 <ddarius> Usually, as a logic, you can call it just propositional logic (though some do use that to mean predicate logic)
00:46:53 <opqdonut> propositional logic it's usually called
00:46:55 <opqdonut> yes :)
00:49:30 * ddarius should look at the Sheffer stroke in a substructural logic.
00:52:25 <ddarius> @google "ordered linear logic" "circuit design"
00:52:28 <lambdabot> http://www.cs.kuleuven.ac.be/~dtai/projects/ALP/newsletter/may01/nav/all.html
00:52:28 <lambdabot> Title: Print the Newsletter
00:55:07 <hpaste>  DRMacIver pasted "Higher order enumeration" at http://hpaste.org/3031
00:55:29 <aleator_> What is coarbitrary in quickcheck?
00:55:59 <DRMacIver> oops. Didn't need to announce that.
00:56:33 <DRMacIver> (Although free to comment on why it's good/bad/awful)
00:59:09 <Heffalump> DRMacIver: not sure I see the point
00:59:48 <DRMacIver> Oh, me neither, but it's in response to http://byorgey.wordpress.com/2007/10/01/higher-dimensional-enumeration/
00:59:52 <lambdabot> Title: Higher-dimensional enumeration « blog :: Brent -> [String], http://tinyurl.com/yrn7v8
01:01:04 <DRMacIver> (Essentially I wanted to show that it didn't require insane amounts of type hackery to make it work with normal lists. Although maybe multi-parameter type classes + incoherent instances counts as at least mildly deranged type hackery)
01:03:14 <dolio> aleator_: It allows quickcheck to generate random functions, instead of just random data.
01:04:03 <dolio> Or, random, non-constant functions.
01:04:06 <aleator_> dolio: Hmm. So, if I want to define StdGen as Arbitrary, what would be the coarbitrary for that?
01:04:45 * DRMacIver -> work
01:05:33 <dolio> Hmm... What are you using for arbitrary? mkStdGen or so?
01:06:33 <aleator_> rand actually
01:07:38 <omniscientIdiot> http://www.cs.chalmers.se/~rjmh/QuickCheck/manual_body.html#18 might be useful
01:10:59 <dolio> Well, using something like '\g -> variant (fst $ random g)' would probably work.
01:13:04 <hpaste>  axm pasted "help with type system" at http://hpaste.org/3032
01:13:21 <axm> i think i got something fundamentally wrong with my understanding of the type system
01:14:19 <axm> but i cannot quite grasp where
01:14:38 <ari> axm: You're promising that apply can return a value of any type, which means the only value it can return is bottom
01:14:40 <omniscientIdiot> the Function class asserts that the apply function must be able to transform the instance's 'a' into *any* 'b' whatsoever.
01:14:55 <axm> ah.
01:17:04 <nornagon> @djinn forall a. b -> a
01:17:08 <lambdabot> -- f cannot be realized.
01:17:24 <Syzygy-> @djinn forall a,b. b -> a
01:17:24 <lambdabot> Cannot parse command
01:17:27 <Syzygy-> Doh.
01:17:34 <Syzygy-> @djinn forall a. forall b. b -> a
01:17:34 <lambdabot> -- f cannot be realized.
01:18:07 <axm> so you cannot practically specify types that allow each type to be inserted? or could i try in the example sth. like apply :: (a -> b) -> a -> b?
01:18:49 <nornagon> @djinn a -> b
01:18:49 <lambdabot> -- f cannot be realized.
01:19:17 <quicksilver> axm: you can make your type class parametric in b as well as a
01:19:18 <nornagon> i think that is djinn's way of saying f = undefined
01:19:27 <quicksilver> axm: class Function a b
01:19:39 <quicksilver> nornagon: djinn inhabits a nice (although imaginary) total world
01:19:44 <quicksilver> nornagon: it doesn't have undefined
01:20:18 <nornagon> it wouldn't really be much use anyway.
01:20:24 <quicksilver> exactly :)
01:20:31 <quicksilver> djinn is constructive
01:20:36 <quicksilver> with a bit of a relevant twist
01:21:13 <nornagon> @djinn a -> (a -> [b]) -> [b]
01:21:14 <lambdabot> f a b = b a
01:21:48 <axm> ok, reminds me of the lisp clos system. but that would probably cause an instance explosion, let me see.
01:21:50 <nornagon> @type (>>=)
01:21:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:21:57 <nornagon> oh er.
01:22:10 <nornagon> @djinn [a] -> (a -> [b]) -> [b]
01:22:10 <lambdabot> -- f cannot be realized.
01:22:21 <nornagon> @src [] (>>=)
01:22:21 <lambdabot> m >>= k     = foldr ((++) . k) [] m
01:22:23 <quicksilver> it can't do that, because it doesn't know anything about []
01:22:33 <quicksilver> your first example was solvable without understanding what [] means
01:22:42 <nornagon> *nod*
01:22:48 <quicksilver> but the second one requires some knowledge of the structure, which it doesn't have
01:22:50 <nornagon> thanks for explaining :)
01:22:59 * nornagon runs away to walk his dogs now
01:23:02 <quicksilver> ;)
01:41:33 <quicksilver> interesting. I've found an application for uncurried functions
01:44:14 * omniscientIdiot is amused at that comment.  In other places you'd tend to find a amazement at the usefulness of currying :)
01:44:21 <quicksilver> ;)
01:44:43 <omniscientIdiot> so what application?
01:45:08 <quicksilver> being able to map the result type, uniformly of how many arguments you have
01:45:20 <quicksilver> if you have Double -> a, and a -> b, that's just composition
01:45:39 <quicksilver> but if you have Double -> Double -> a, and a -> b, that's a slightly fiddly kind of composition
01:45:52 <quicksilver> easier if you uncurry it to (Double,Double) -> a
01:45:57 <quicksilver> then it's "just composition" again
01:46:22 <omniscientIdiot> that's just map f (zip doubles1 doubles2), which is zipWith f
01:46:38 <quicksilver> I didn't mean map like that
01:46:44 <quicksilver> I just meant, map the result type
01:46:56 <omniscientIdiot> ah
01:46:56 <quicksilver> (Double -> a) -> (a -> b) -> (Double -> b)
01:47:10 <quicksilver> a.k.a. composition, although conventionally the args are the other way around
01:47:31 <quicksilver> a. k. a. fmap in the reader monad
01:47:48 <quicksilver> but (Double -> Double -> a) isn't in the reader monad in the 'way that I want it to be'
01:47:57 <quicksilver> it has a result type of "Double -> a" itself
01:48:20 <quicksilver> really what I'm interested in is being able to treat functions of 1D, 2D or 3D spatial coordinates 'uniformly'
01:48:28 <quicksilver> which is easier if they all have 'the same number' of parameters
02:51:13 <cognominal_> configure: error: failed to detect version date: check that darcs is in your path  -- does this ring a bell?
02:52:12 <cognominal_> I have moved stuff around. So this probably get a cached path that is not valid anaymore
02:52:57 <sieni> fts
03:21:49 <qubit> hi room, I asked the question about how to write a recursive version of the id function from prelude,  idrec x = let _ = idrec x in x, was suggested, although the recursion does not appear in the body of the definition and that is what I need..
03:22:25 <DRMacIver> A recursive version of id? What?
03:23:11 <qubit> yes , for a challenge
03:23:27 <qubit> same type and result id :: a -> a
03:23:33 <ttfh> that one has been bothering me since :-)
03:23:49 <qubit> umm.. same :(
03:24:24 <therp> the only other implementation of a -> a is non-termination (as in a->b)
03:24:35 <therp> is that correct?
03:25:04 <quicksilver> well you can write stupid beta or eta equivalent things, of course
03:25:15 <quicksilver> pointless lambdas and so on
03:25:33 <dolio> That'd be another function. You could have, theoretically, multiple implementations of the same function.
03:25:44 <qubit> with recursion in the body?
03:25:48 <iguana_> does anyone know how to use the Text.Regex.PCRE module?
03:26:16 <iguana_> I always get "No instance for (RegexMaker regex compOpt execOpt [Char])"
03:26:20 <qubit> i only started Haskells last week
03:26:49 <dolio> Like, there are many implementations of 'sort', though they're the same function.
03:27:32 <dolio> Using recursion in id doesn't make much sense.
03:28:29 <dolio> Unless you're going to build a duplicate of a particular value, with type classes and such.
03:28:42 <dolio> Which would use polymorphic recursion.
03:29:03 <therp> that would make sense yes
03:29:07 <therp> but that it wouldn't be a->a
03:29:15 <therp> s/that/then/
03:29:20 <iguana_> but in Text.Regex.PCRE.String there is an instance for RegexMaker Regex . . String
03:29:21 <dolio> Yeah.
03:41:59 <iguana_> nobody?
03:42:06 <qubit> a->b is not permitted, it would have to be for a -> a, the same as the id in prelude..
03:42:17 <qubit> btw it is just a challenge from my l.ecturer
03:42:42 <qubit> for a book voucher at the uni book store, I need to get the haskell book tomorrow
03:42:46 <Cale> a -> b is a valid type, but it has only one element and that's undefined
03:43:02 <Cale> a -> a has two elements: undefined and id
03:43:27 <qubit> b is undefined?, how can i cast it the same type as a recursive?
03:43:32 <dolio> 2 and 3 if you're evil. :)
03:43:49 <Cale> dolio: hm?
03:44:07 <Cale> qubit: er
03:44:08 <qubit> 3?
03:44:08 <xs> qubit: what course is this? does he want you to use y?
03:44:14 <dolio> If you have seq, then undefined /= const undefined.
03:44:20 <Cale> qubit: undefined :: a
03:44:29 <qubit> algorithmic problem solving
03:44:33 <Cale> dolio: ah, right
03:44:47 <dolio> Or, for certain seqs.
03:44:56 <gkr> What do you mean by seq?
03:45:24 <Cale> gkr: seq is a function such that seq undefined y = undefined but seq x y = y otherwise
03:45:56 <Cale> gkr: Essentially, it just evaluates x into WHNF before resulting in y.
03:46:10 <iguana_> WHNF?
03:46:20 <lokadin_> is random number generation a CPU intensive process?
03:46:29 <Cale> Weak Head Normal Form -- essentially, up to determining the top-level constructor
03:46:30 <gkr> Cale how do I know if "I have" seq?
03:46:46 <platypus> lokadin_: It can be
03:46:50 <Cale> gkr: Well, in Haskell, there's seq, but he means whether or not we're considering it.
03:47:06 <gkr> Ahh, oka. Thank you Cale.
03:47:12 <Cale> With seq, you can tell the difference between  undefined and const undefined
03:47:30 <Cale> seq (const undefined) y == y
03:47:38 <Cale> but seq undefined y = undefined
03:47:56 <Cale> > seq (const undefined) 5
03:47:58 <lambdabot>  5
03:48:12 <Cale> > seq (undefined :: a -> b) 5
03:48:14 <lambdabot>  Undefined
03:49:55 <Cale> lokadin: It generally depends on how many pseudorandom numbers you need and how convincing they need to be.
03:50:15 <qubit> could i use seq recursively as an id hybrid?
03:50:28 <qubit> resursion in the body
03:50:41 <Cale> qubit: Like, to strictify a complete datastructure?
03:50:56 <Cale> qubit: yeah, you can do that
03:52:14 <lokadin_> well i need to get numbers between 1 - 1205299 ,  only 29 of them, but for some reason is consuming all my resources, though i guess my data set is 95mb, i don't think haskell copies it for every recursive instance
03:52:16 <qubit> to the same type as the arguement as in id
03:52:21 <lokadin_> does it?
03:52:49 <Cale> lokadin: It shouldn't...
03:53:27 <Cale> qubit: You can't *quite* get the same type as id, because in order to know how to recurse, you need to know something about the datatype.
03:54:22 <LFH> In the library is there a function with the type: [a] -> [b] -> (a->b->Bool) -> Bool ?
03:54:37 <Cale> qubit: What you could do is have a class Strict a where strict :: a -> a
03:55:03 <hpaste>  loki pasted "symbol randomizer (further optimization)" at http://hpaste.org/3033
03:55:13 <qubit> so, make my own class?
03:55:19 <Cale> qubit: yeah
03:55:23 <qubit> tnx
03:55:32 <lokadin_> i was wondering if it could be optimized any further
03:55:36 <qubit> ill give it a shot --------->
03:55:37 <Cale> LFH: you can use zipWith along with and or or
03:55:39 <matthew-_> LFH: you almost certainly want zipWith
03:56:18 <Cale> What's with the insane identifier names?
03:56:27 <matthew-_> or foldr with zipWith
03:56:30 <lokadin_> they are lojban and they are descriptive
03:56:50 <lokadin_> more so than single letter identifier names
03:56:56 <lokadin_>  at the very least
03:57:39 <LFH> matthew-_ , Cale : thanx. yes I know zipWith but I was looking for a standard name for that function.
03:57:50 <matthew-_> there isn't one
03:58:50 <lokadin_> hmmm i can't run the program as it runs out of memory
03:59:19 <hpaste>  Cale annotated "symbol randomizer (further optimization)" with "search and replace" at http://hpaste.org/3033#a1
04:00:22 <Cale> (sorry, I just couldn't read it like that :)
04:00:30 <lokadin_> lol np
04:01:55 <Cale> !! is really expensive if you're doing it a lot
04:02:08 <Cale> You might consider using an array.
04:02:27 <lokadin_> instead of a list?
04:02:46 <Cale> Well, just build an array from the list before starting the recursion.
04:03:02 <lokadin_> @hoogle Array
04:03:03 <lambdabot> Array :: module
04:03:03 <lambdabot> Data.Array :: module
04:03:03 <lambdabot> Foreign.Marshal.Array :: module
04:03:37 <lokadin_> kk i'll try it out
04:04:05 <Cale> xs !! n takes O(n) time
04:04:34 <Cale> So if you're generating a random number between 0 and 95 million, that could take a long time.
04:05:07 <matthew-_> you could also try data.seq
04:05:14 <matthew-_> err, seq*uence*
04:05:47 <matthew-_> though that's still not the O(1) that arrays gets you
04:06:06 <lokadin_> so how do i convert list into array?
04:06:13 <axm_> are you stuck to using that data set at all (for what reason)?
04:06:40 <Cale> listArray (0,length xs) xs
04:06:42 <Cale> er
04:06:45 <Cale> listArray (0,length xs - 1) xs
04:06:51 <lokadin_> well no, it's just i wanted to use an even larger data set
04:07:14 <axm_> i mean, a stream generator would not do the job?
04:07:29 <lokadin_> stream generator?
04:07:30 <matthew-_> are your elements ints?
04:07:39 <lokadin_> no they are strings
04:07:50 <lokadin_> sentances from books
04:07:53 <matthew-_> ahh, and are you modifying the list or just reading from it?
04:08:11 <Cale> He's producing a new list by selecting elements from the original one at random.
04:08:21 <lokadin_> well i'm taking random lines from the file and outputing them to screen, pretty basic
04:08:23 <axm_> take a seed, say a number, apply some function on it to get the next number and for the next "random" result apply that function on the last result
04:08:25 <matthew-_> Cale: thanks, I guess I should read up.
04:08:32 <axm_> ah
04:10:38 <matthew-_> If that's all you're doing, I'd do random stuff on the input side so that you only load into your list the selected strings
04:10:43 <matthew-_> then randomly shuffle them
04:10:45 <matthew-_> then output them
04:10:54 <matthew-_> that way, you avoid loading the whole thing into memory
04:11:02 <lokadin_> shuffleing might be more intensive no?
04:11:17 <matthew-_> you can shuffle in n log n
04:11:20 <axm_> but requires you do not want doubles
04:11:34 <axm_> actually it wouldnt
04:11:39 <matthew-_> quite. ;)
04:11:41 <lokadin_> so how would i shuffle the file?
04:11:53 <matthew-_> you wouldn't
04:11:59 <lokadin_> ?
04:12:18 <lokadin_> the dataset? what is being shuffled?
04:12:19 <matthew-_> you parse the input looking for sentences. On each sentence, you ask your rng "do I want to keep this sentence"
04:12:46 <matthew-_> if you do want to keep it, chuck it in a list or something - what's the ratio between sentences discarded and sentences kept?
04:12:57 <matthew-_> and how many do you envisage keeping altogether?
04:13:01 <lokadin_> but i only need to output like between 0 - 29 sentances
04:13:13 <matthew-_> right, a list should be fine for that then
04:13:39 <matthew-_> so then you've built your list with < 30 sentences in it. but all the sentences are in order. So you just want to shuffle that list
04:14:12 <hpaste>  matthew-_ pasted "shuffling stuff with great funk" at http://hpaste.org/3034
04:14:19 <lokadin_> well the list building would be difficult considering the data set size,  i'll try out the arrays
04:14:53 <matthew-_> but... you're not putting every sentence into the list... you're only putting < 30 sentences in... why is that difficult?
04:15:06 <lokadin_> well that's what i'm doing now anyways...
04:15:36 <lokadin_> there is no difference
04:15:51 <lokadin_> except with your method i would also have to shuffle
04:16:23 <matthew-_> ok, in which case I must have totally misunderstood - I thought that you were trying to put all your sentences into the list and then randomly select from that list
04:17:54 <lokadin_> well they are in a list when read from file,  it's kinda hard to know where lines start without having read the file at least once, and i make list at the same time so as to save time later
04:19:27 <matthew-_> the contents of the file are just sentences? it's not in any markup or anything - it's just plain text right?
04:20:06 <SamB> a teapot is a strange graphics primitive...
04:20:48 <axm_> but you have to know the total count in oder to make possibilities for each sentence being selected equal
04:21:00 <luqui> is it possible to write the type f such that f a b c = a -> b -> c without it being a synonym?
04:21:10 <matthew-_> axm_: oh bother. that's a pretty good point.
04:21:21 <luqui> i.e. a two-arg generalization of (->) a
04:22:46 <lokadin_> matthew-_: yep they are plain text
04:24:02 <quicksilver> SamB: It's a well-known result that any complex 3D shape with n faces can be build exactly with (sqrt n) teapots!
04:24:09 <matthew-_> lokadin_: I suggest ignoring everything I've said, going back to using arrays as Cale suggested, as a) I have to go now, and b) axm_ has pointed out that my method is flawed
04:24:18 <quicksilver> (asymptotically for large n)
04:24:36 <axm_> it is not, you just have to preprocess, it would halve the time on average then
04:25:19 <matthew-_> axm_: I was thinking about some laziness, but that would force all sentences to be held in memory until you've finished processing the file
04:25:29 <quicksilver> luqui: I'm not quite sure what you mean
04:25:37 <quicksilver> luqui: but function application is a built-in notion
04:25:56 <luqui> quicksilver, so (->) a is a type right?
04:25:56 <quicksilver> luqui: so it only applies directly to things which actually have type of the form X -> Y
04:26:04 <luqui> with kind * -> *
04:26:10 <quicksilver> yes
04:26:19 <quicksilver> some people call that a type family or a type constructor
04:26:26 <quicksilver> but yes, it's a type in the general sense
04:26:38 <luqui> I want a type with kind * -> *, such that f a b c = a -> (b -> c)
04:26:49 <luqui> in the same way as (->) a b = a -> b
04:27:05 <luqui> but i'm using it in an instance, so it can't be a synonym
04:27:16 <quicksilver> use a newtype then
04:27:32 <luqui> i believe that defeats my purpose...
04:27:50 <quicksilver> that's hard for me to say, since I don't know what your purpose is
04:27:51 <luqui> i'm just experimenting with the type system...
04:27:52 <SamB> quicksilver: I'm fairly certain that there are some 3d shapes with n faces that can't be built out of any number of teapots
04:28:07 <luqui> trying to make generically n-ary compose operations
04:28:17 <quicksilver> luqui: ghc with extensions allows you to make instances of synonyms by the way
04:28:28 <SamB> luqui: I don't think you can
04:28:32 <quicksilver> luqui: that sounds like a good thing to use newtypes for...
04:28:32 <lokadin_> Kind error: `Array' is not applied to enough type arguments
04:28:32 <lokadin_>     In the type signature:
04:28:32 <lokadin_>       daicUnsopa :: (Array, StdGen) -> Int -> Int -> ([a], StdGen)
04:28:36 <luqui> make compose_1 = (.), compose_2 f g x y = f (g x y), etc. all in one go
04:28:37 <lokadin_> what's that mean?
04:28:42 <SamB> luqui: something about the difficulty of figuring out what n is...
04:28:48 <quicksilver> luqui: Array isn't a type, it's a type constructor
04:28:49 <axm_> matthew-_, isn't it possible to make file reading lazy as well? as long as you know the total count beforehand, it would work
04:29:03 <luqui> quicksilver means lokadin_
04:29:15 <lokadin_> so what should i put instead of Array ?
04:29:15 <quicksilver> luqui: It's (Array ind elem) where 'ind' is the type of indices and elem is the type of elements
04:29:21 <quicksilver> lokadin_: bah yes
04:29:23 <quicksilver> luqui: sorry :)
04:29:29 <luqui> np
04:29:35 <quicksilver> lokadin_: Array something something
04:29:40 <lokadin_> kk
04:29:43 <quicksilver> lokadin_: Array Int a, perhaps?
04:29:53 <luqui> quicksilver, but not partially applied synonyms...
04:30:21 <quicksilver> luqui: no, you need newtypes for that
04:30:43 <quicksilver> luqui: I think that's an essential restriction of the typeclass inference algorithm but I'm not quite confident that that is the case
04:30:44 <lokadin_> seems to work
04:31:00 <luqui> probably is..
04:31:03 <matthew-_> axm_: oh sure, if you knew the total in advance it would be fine. I'd suggest using lazy bytestring and then, just span (/= '.') would get you prefixes that are sentences (sorta)
04:31:05 <lokadin_> but dono if it works with the large data set yet, the small ones worked though
04:31:19 <matthew-_> axm_: input is lazy by default, from what I can tell
04:31:32 <luqui> quicksilver, otherwise there would be an isomorphism between lambda calculus and the type system
04:31:43 <luqui> by using type synonyms as functions
04:32:08 <quicksilver> however, you can do it all with newtypes
04:32:23 <quicksilver> essentially, then, the explicit constructor gives the type inference engine the hint it needs
04:32:30 <quicksilver> to see where one type finishes and the next begins
04:32:40 <quicksilver> it forces you to 'name' the isomorphisms you are declaring
04:32:57 <quicksilver> matthew-_: input in lazy bytestrings is lazy by default, yes
04:33:16 <quicksilver> matthew-_: in the unsafe (i.e. will fire nuclear missiles at you) sense
04:33:24 <matthew-_> quicksilver: input with hGetContents is also lazy
04:33:31 <matthew-_> quicksilver: I believe...
04:33:35 <quicksilver> matthew-_: indeed
04:33:47 <quicksilver> matthew-_: depends which one though
04:33:57 <quicksilver> matthew-_: hGetContents inside the strict bytestring types is not lazy
04:34:03 <matthew-_> quicksilver: hence the "never use hClose until you've actually read everything you want. and REALLY read it"
04:34:10 <matthew-_> quicksilver: I was meaning system.io
04:34:12 <quicksilver> matthew-_: but the one in System.IO, and the one in the lazy BS types, is
04:34:40 <quicksilver> for a fast solution to the random lines problem I would be inclined to use strict bytestrings, which will read the file only once and be fast
04:34:50 <quicksilver> assuming you expect you rfile to fit in memory
04:36:14 <matthew-_> quicksilver: I think that might be the problem that it doesn't fit in ram
04:36:28 <quicksilver> matthew-_: right, I wasn't sure what the constraints were
04:36:37 <quicksilver> matthew-_: in that case, it does have to be two-pass
04:36:49 <matthew-_> yup
04:36:52 <quicksilver> matthew-_: and you have to understand the notion of 'reachable' well enough to make sure that the first pass can get GC'ed :)
04:37:21 <matthew-_> I'd suggest the first pass is cat $file | sed -e 's/[^.]//g' | wc -c
04:37:42 <quicksilver> ;)
04:38:19 <quicksilver> something like length . findIndices (=='\n')
04:38:20 <quicksilver> should do it
04:38:34 <quicksilver> although I forget the 'find' API in bytestrings and am too lazy to look it up
04:40:55 <axm_> if you take each element with a given chance, you would have to fill up to the wanted amount in case, using the previous elements. would there be a non-ugly way to do that?
04:45:35 <axm_> asked with different words, is there an efficient immutable fifo-queue implementation?
04:48:10 <quicksilver> axm_: Data.Sequence
04:48:59 <axm_> thx
04:52:21 <quicksilver> axm_: lifo, of course, is just lists :)
04:53:02 <quicksilver> axm_: but Data.Sequence is really very efficient. lots of O(1) and O(log log) operations
04:53:16 <roconnor> amoritzed O(1)
04:53:29 * quicksilver nods
04:53:53 <roconnor> although in a lazy language, amortized costs are often the true costs
04:54:36 <doserj> and there are no O(loglog) operations, as far as I know?
04:55:06 <roconnor> stick something inside a sequence, worry about shuffling the leaves around later.
04:56:23 <quicksilver> doserj: I thought append was loglog?
04:57:27 <doserj> quicksilver, that is O(log (min(length l1, length l2)))
04:57:48 <quicksilver> hmm, yes
04:58:04 <quicksilver> must have been some other data structure )
05:06:18 <roconnor> @ask-SPJ how do I give a talk?
05:06:18 <lambdabot> Unknown command, try @list
05:09:50 <roconnor> http://research.microsoft.com/~simonpj/papers/giving-a-talk/giving-a-talk-html.html
05:09:52 <lambdabot> Title: How to give a good research talk, http://tinyurl.com/yr754l
05:10:58 <cjay> . o O ( there is probably "use comic sans ms 3d" in it )
05:14:59 * mux hearts Foreign.C
05:20:41 <mux> ok, I have a very specific question about FFI, foreign pointers, etc
05:21:01 <mux> I'm creating a binding to a C function which unfortunately should be passed a FILE *
05:21:37 <mux> a direct translation to Haskell would give a function taking a Handle, but I can't get a Ptr CFile out of an Handle (or at least I think so)
05:21:58 <mux> so, the Haskell function takes a pathname, and calls fopen() itself, to pass the resulting Ptr CFile to the said function
05:22:38 <mux> my only problem is that I don't know how to properly GC this FILE *
05:23:27 <mux> I would need another finalizer, and this finalizer should be a plain Haskell action
05:23:31 <mux> is that possible?
05:25:50 <cognominal_> how can I see the registered packages?
05:26:17 <mux> ghc-pkg list
05:27:01 <quicksilver> mux: doesn't anwer your question, but did you consider fdopen()
05:27:44 <mux> quicksilver: well yeah, but I didn't anything getting me a fd out of an Handle
05:27:48 <mux> +find
05:28:16 <mux> I just found something: Foreign.Concurrent allows finalizers that are plain IO actions
05:28:26 <roconnor> Serif or SanSerif for Slides?
05:28:30 <mux> I'm not entirely convinced I should use this yet, but it sounds nice
05:28:42 <mux> quicksilver: anything portable, at least :)
05:28:56 <twanvl> don't ForeignPtrs have finalizers?
05:29:08 <cognominal_> thx mux
05:29:15 <mux> Concurrency-based ForeignPtr operations
05:29:17 <mux> These functions generalize their namesakes in the portable Foreign.ForeignPtr module by allowing arbitrary IO actions as finalizers. These finalizers necessarily run in a separate thread
05:29:35 <mux> twanvl: they do, my problem was that my finalizer needs to be haskell code
05:29:42 <quicksilver> mux: ah, fds aren't portable, no
05:29:57 <mux> wait a minute
05:30:05 <mux> I could maybe use newForeignEnvPtr
05:30:14 <mux> have the Ptr CFile be the environment
05:30:22 <mux> and add an extra finalizer on "fclose()"
05:30:35 <cognominal_> when there is multiple registered versions of a package. What is the criteria to pick one?
05:30:37 * mux checks this out
05:30:58 <mux> cognominal_: not sure, but you can hint at the one you want by using the "hide" and "unhide" commands
05:31:21 <cognominal_> mux ok
05:33:11 <cognominal_> that seems to explain a message of Happy unhappy of an hidden cabal
05:33:41 <mux> cabal hides everything that you haven't listed in the Build-Depends field
05:34:16 <cognominal_> hum, how to compile Happy then
05:34:47 <cognominal_> the error message seems to depend on the version of the registered cabal
05:35:10 <mux> mmm, newForeignPtrEnv won't help
05:35:17 <mux> I guess I'll need to use Foreign.Concurrent
05:38:56 <hpaste>  ventonegro pasted "parsing lists" at http://hpaste.org/3035
05:39:25 <ventonegro> hi, as an exercise i'm writing a parser for R5RS scheme (surprise!)
05:40:22 <twanvl> mux: you could also try converting your haskell code to a FunPtr using a wrapper
05:40:23 <ventonegro> i've written the pasted code for parsing lists with parsec, the problem is that "..." is a valid identifier, when parseLeftList fails, a dot has already been consumed
05:40:48 <ventonegro> can anyone give me a piece of advice?
05:41:03 <oerjan> ventonegro: use try?
05:41:19 <oerjan> that's the usual way to undo consumption
05:42:07 <quicksilver> or just make parseLeftList a "higher-priority" choice than the identifiers
05:42:12 <ventonegro> oerjan: but I do not want to backtrack parseLeftList
05:42:36 <mux> twanvl: I've thought about that indeed, I'm not sure which way is the easiest
05:42:43 <ventonegro> oerjan: it's the factored-out left common sub-expression
05:43:00 <mux> for now I just used Foreign.Concurrent and added a second finalizer to fclose() the FILE *
05:43:07 <mux> this seems to work nicely
05:44:11 <ventonegro> quicksilver: but identifiers are parsed inside the parseLeftList parser
05:45:38 <oerjan> ventonegro: well you need to make sure parseDatum doesn't parse a single dot
05:46:21 <ventonegro> yeah... gonna work out some way
05:46:27 <ventonegro> thanks people
06:08:41 <ventonegro> :t fix
06:08:43 <lambdabot> forall a. (a -> a) -> a
06:08:52 <ventonegro> @src fix
06:08:52 <lambdabot> fix f = let x = f x in x
06:24:30 * mux wonders why he suddenly doens't need to import Data.Bits to use shiftR
06:24:58 <Cale> hehe, that's odd :)
06:25:07 <Cale> maybe another module reexports it?
06:46:26 <Beelsebob> @seen JaffaCake
06:46:26 <lambdabot> I saw JaffaCake leaving #ghc and #haskell 4d 18h 41m 25s ago, and .
06:46:30 <Beelsebob> arse
06:48:24 <oerjan> @index shiftR
06:48:24 <lambdabot> Data.Bits, Foreign
06:48:41 <quicksilver> Foreign is a bit gunky
06:48:46 <quicksilver> it exports some weird stuff :)
06:49:01 <quicksilver> 'withArray' feels odd to me
07:03:27 <shapr> @yow !
07:03:27 <lambdabot> When I met th'POPE back in '58, I scrubbed him with a MILD SOAP or
07:03:27 <lambdabot> DETERGENT for 15 minutes.  He seemed to enjoy it ...
07:03:34 <shapr> Good morning #haskell!
07:05:56 <shapr> What's going on?
07:06:12 <TSC> Not much, obviously
07:07:11 <shapr> It's a quiet morning...
07:07:15 <ramza3_> data MyData = MyData { pos :: !(Float, Float) } deriving (Show)   ... instance Show MyData where show a = ""    ...I am getting an error with this code; if I have deriving (Show), I am getting duplicate instance references of Show, how would I rememdy that
07:07:21 <mux> quicksilver: oooh, ok :-)
07:08:14 <TSC> ramza3_: You shouldn't derive Show if you provide an instance for it yourself
07:08:32 <TSC> Otherwise you have two instances
07:09:09 <ramza3_> ops
07:09:10 <ramza3_> oops
07:09:11 <mux> quicksilver: a bit weird indeed, although undoubtedly convenient :)
07:10:13 <quicksilver> :t withArray
07:10:15 <lambdabot> Not in scope: `withArray'
07:10:16 <ramza3_> kind of like what Spock said; when you eliminate the impossible, whatever remains, however improbable, must be the truth
07:10:33 <merus> You mean Holmes.
07:10:38 <quicksilver> ramza3_: that was sherlock holmes that spock was quoting :P
07:11:11 <ramza3_> well, Spock said it too
07:11:18 <quicksilver> ramza3_: by the way, !(Float,Float) looks a bit odd
07:11:41 <ramza3_> quicksilver; my usage of strict annotations?
07:11:59 <quicksilver> ramza3_: yes
07:12:13 <quicksilver> ramza3_: it's a strange choice to strictify a tuple, given that the components aren't strict...
07:12:41 <Rebooted> @djinn Eq a => (b -> a) -> a -> [b] -> [b]
07:12:41 <lambdabot> Cannot parse command
07:12:57 <araujo> morning
07:13:39 <Rebooted> @djinn (Eq a) => (t -> a) -> a -> [t] -> [t]
07:13:40 <lambdabot> f _ _ a = a
07:15:02 <Tac-Tics> @djinn a -> a -> a
07:15:02 <lambdabot> f _ a = a
07:15:14 <Tac-Tics> djinn isn't very creative
07:15:38 <Tac-Tics> @djinn (a, b) -> (b, c) -> (a, c)
07:15:39 <lambdabot> f (a, _) (_, b) = (a, b)
07:20:18 <betty> good morning
07:21:03 <Tac-Tics> good morning
07:21:05 <betty> I'm a haskell newbie still trying to get a handle on haskell basics
07:21:16 <Tac-Tics> you are a very brave soul ^^
07:21:57 <betty> I had some ML experience from grad school years ago, and that has been somewhat helpful
07:22:15 <Tac-Tics> yeah
07:22:33 <Tac-Tics> I haven't done much ML, but I imagine it helps a lot
07:23:07 <quicksilver> Tac-Tics: it does try to be relevant
07:23:19 <betty> I noticed an article yseterday posted by Cedric Beust
07:23:21 <quicksilver> @djinn (a,b) -> (b,c) -> (a,b,b)
07:23:24 <lambdabot> f (a, b) (c, _) = (a, c, b)
07:23:47 <betty> has anyone read this: http://beust.com/weblog/archives/000464.html
07:23:49 <lambdabot> Title: Otaku, Cedric's weblog: Erlang: the verdict
07:24:28 <betty> Cedric writes about Erlang, but I think he is missing some important points
07:25:47 <betty> Cedric writes "Maybe if some OO had been thrown in Erlang from the start, we would indeed be facing a language that has the potential to become meaningful." but he doesn't articulate what features of OOP he wishes Erlang had.
07:26:30 <betty> I know even less about Erlang than I do about Haskell, so I am no way qualified to comment on his article.
07:27:47 <betty> He makes a a lot of criticisms regarding FP in general, and I was wondering what other people think of this article
07:28:50 <Tac-Tics> clearly, anyone who doubts the power of FP is stuck in a for(;;) {} loop
07:28:58 <Tac-Tics> (and probably quite literally)
07:29:53 <quicksilver> betty: I have just read that article very quickly
07:30:10 <quicksilver> betty: it appears to me to be heavy of prejudice and guesswork and light on knowledge and substance :)
07:30:39 <Tac-Tics> Haskell is too hard. MLs are a bit obscure. And lisp cannot be checked for syntactical correctness by a human.... but FP still has a lot going for it
07:30:47 <shapr> I agree with quicksilver from what I've read so far.
07:30:48 <Tac-Tics> Ruby and Python are both quite lispy
07:30:58 <betty> quicksilver:  I was particuarly interested in comments regarding "myth of lock-free programming"
07:31:06 <shapr> "Message passing might end up being more expensive than Erlang, which has been optimized to make this as lightweight as possible, but without any credible figures, I am skeptical that an Erlang program will come ahead in the long run."
07:31:10 <Tac-Tics> even Javascript has closures and lambdas
07:31:27 <shapr> That means "I don't actually know, but I won't bother finding out either."
07:31:59 <quicksilver> betty: that was one particular example of something which looked badly informed :)
07:32:33 <betty> quicksilver: that was the impression I had
07:32:33 <shapr> In my opinion, if he really wanted to know, he'd write up a few simple implementations that used Erlang and Java messaging, and at least give a rough comparison.
07:32:39 <quicksilver> betty: locking and message passing are subtle, but they have been well explored. There are plenty of articles explaining the pros and cons of locking
07:33:00 * araujo thought Erlang had side-effects
07:33:24 <quicksilver> It does
07:33:30 <quicksilver> it's quite impure
07:33:32 <quicksilver> AFAIK
07:34:19 <quicksilver> I think one can be generally pretty superstitious of any article about OO which appears to think that OO is unconditionally good.
07:34:25 <Tac-Tics> In the purest sense, an impure language
07:34:32 <shapr> The "Tim Bray says it's slow" reference is irrelevant in my opinion, since Tim Bray ended up measuring *regex speed*.
07:34:48 <quicksilver> I'm not sure where this attitude comes from, but I *suspect* that for many programmers OO is the first time they mean any kind of useful encapsulation
07:35:04 <quicksilver> So when people say "OO is good" what they actually mean is "encapsulation/modularisation are good"
07:35:10 <quicksilver> which I would certainly agree with
07:35:13 * mux nods at quicksilver 
07:35:18 <shapr> Yeah, abstraction is nice.
07:35:29 <quicksilver> but what they don't appreciate is that OO is not the only way to achieve abstraction (thanks for the word, shapr)
07:35:35 <Tac-Tics> hehe, that reminds me of people who see python for the first time..... "If it's OO, then were are the private/public modifiers?"
07:35:41 <mux> it took me years of coding with C to finally *understand* why an OO-model is good, asbtraction-wise
07:35:50 <quicksilver> Of course, in Java specifically, OO is just about your *only* abstraction tool
07:35:52 <fox86> is it common to name your source files with capital first-letters in haskell?
07:35:58 <quicksilver> which leads to a rather unusual setup
07:36:00 <quicksilver> fox86: yes
07:36:06 <quicksilver> fox86: Modules should have Captial Letters
07:36:13 <quicksilver> fox86: and, normally Files are Modules
07:36:21 <fox86> quicksilver: aah, i see
07:36:24 <shapr> "I'm having a hard time imagining that this approach scales as miraculously as Erlang advocates claim." <-- So try it!
07:36:26 <quicksilver> fox86: I sometimes use a lower-case one for a 'main program' file
07:37:16 <quicksilver> fox86: quite often that's like this: "foo.hs" contains the lines : "import qualified Bar.Project.Foo; main = Bar.Project.Foo.main"
07:37:26 <quicksilver> fox86: so 'foo.hs' is just a little wrapper to make an executable from
07:37:38 <quicksilver> (because then ghc --make foo.hs will make an executable called 'foo')
07:38:12 <fox86> quicksilver: ah, that sounds good.
07:38:22 <shapr> betty: In my opinion, this guy is stuck in a familiar mindset, and has not actually tried to compare Erlang and Java.
07:39:10 <shapr> For example, the five nines section completely ignores Erlang's ability to do hot code reloading and run multiple versions of code where necessary.
07:40:44 <SaMBuCa_> hi
07:40:45 <betty> shapr: many people seem to react very strongly to FP ... as if out of fear
07:41:12 <shapr> betty: Many people fear change.
07:41:27 <shapr> For most people, it's hard to do new and unfamiliar stuff.
07:41:50 <betty> it is definitely a big paradigm shift
07:42:32 <quicksilver> also, people become instinctively defensive of the skillset/style they have spent time and hard work learning
07:42:33 <betty> I just don't understand why so many people feel that the evolution of programming ends at OOP
07:42:36 <Tac-Tics> Many people are just very dumb programmers
07:42:44 <Tac-Tics> It takes so very little to achieve turing completeness....
07:43:00 <quicksilver> the amusing thing to me is that OOP is *very* hard to understand. IMO.
07:43:10 <Tac-Tics> quicksilver: I agree
07:43:18 <Tac-Tics> Polymorphism isn't even all that useful
07:43:20 <quicksilver> It took me much longer to learn OOP (having been a pascal/C programmer)
07:43:22 <shapr> betty: Probably for the same reason people think personal transport ends with cars. It's been done that way for years, nothing much has changed, so that must be the way it should be.
07:43:27 <quicksilver> that it did to learn FP
07:43:37 <quicksilver> it's not a fair comparison, I was different ages and had different experience, etc
07:43:52 <Tac-Tics> At my school, they would teach students about polymorphism and function overloading before boolean logic or loops
07:44:05 <quicksilver> but I remember being utterly baffled by the first OO class library I tried to grok
07:44:21 <quicksilver> which was the venerable 'Think Object C' library
07:44:28 <quicksilver> or 'Object Think C' or whatever they called it
07:44:33 <Tac-Tics> I was strictly OO until about a year ago when I had a religious experience with LISP
07:44:46 <Tac-Tics> Seeing how LISP eval works is really an eye opener
07:44:53 <shapr> Truly, OO was harder for me than FP.
07:44:54 <betty> quicksilver: it seems to me that a lot of the comp sci programs today are providing thin vocational training
07:45:04 * shapr agrees with betty 
07:45:06 <Tac-Tics> though I never actually wrote any useful program in lisp
07:45:08 <shapr> Java school
07:45:30 <quicksilver> 'THINK Class Library' apparently.
07:45:37 <Tac-Tics> Java schools suck~
07:46:25 <quicksilver> I don't have enough experience of comp sci programs
07:46:35 <quicksilver> the only two I'm remotely familiar with were not very vocational
07:46:42 <quicksilver> but I daresay they weren't typical
07:46:44 <betty> it's strange, I work with a lot of C++ programmers that are just discovering Java
07:46:51 <shapr> I just moved to a university-centric town two days ago, I wonder what the CS department is like!
07:47:10 * blarz learned Java in first semester
07:47:29 <shapr> blarz: And did it help you learn other languages and ways of approaching programming?
07:47:30 <blarz> and Scheme in the second
07:47:46 <blarz> shapr: I don't think so... but I learned C before that
07:47:53 <blarz> so I didn't like Java from the start ;)
07:48:03 <shapr> Do you think Scheme helped you with other approaches?
07:48:41 <blarz> scheme was nice, as it was different :)
07:49:05 <quicksilver> different is good
07:49:13 <quicksilver> they should teach some erlang for that very reason
07:49:15 <betty> In my academic days, they were teaching lisp prolog, and ml as well as C, C++, Fortran, etc
07:49:17 <blarz> but I don't know if I'd approach problems some other way after learning it
07:49:23 <blarz> as it didn't go very deep
07:49:25 <thanith> hi everybody
07:49:51 <shapr> hiya thanith
07:50:40 <shapr> blarz: Did you go through SICP?
07:50:50 <thanith> i'm haskell newbie from germany just working through the gentle introduction which is a very good point to start
07:50:58 <shapr> betty: You must be around my age, though I also saw COBOL in my academic days.
07:51:15 <blarz> shapr: it was on the books list the prof suggested to read
07:51:47 <blarz> shapr: but I didn't read very much of it
07:51:50 <blarz> but I plan to
07:51:53 <betty> shapr: they were still offering COBOL, but most people stayed away from it
07:52:21 <shapr> I never did finish my CS degree, I'm seriously considering doing that now.
07:52:30 <betty> shapr: I think COBOL was some kind of requirement then for students of the business school
07:52:40 <byorgey> thanith: welcome =)
07:53:01 <shapr> thanith: Yes, welcome to #haskell ! Got any questions?
07:53:15 <byorgey> and hi, SaMBuCa_
07:53:23 <shapr> betty: You must have gone to a better school than me, we had Pascal, BASIC and COBOL.
07:53:31 <thanith> all: while working through the gentle introduction to haskell i notice a few glitches and errors how can i help to discuss them and correct?
07:53:32 <ramza3_> kind of a general question; Could something like the Erlang based CouchDB be developed in Haskell and have similar focus on concurrent programming http://programming.reddit.com/info/2vo7p/comments/c2voo5
07:53:33 <lambdabot> Title: Cedric Beust on Erlang: the verdict (reddit.com)
07:53:40 <shapr> I was at uab.edu in 1992 or so.
07:54:01 <shapr> Though I graduated high school in 1989.
07:54:16 * blarz is at Uni Erlangen
07:54:33 <shapr> blarz: I used to work for their neus lernen department.
07:54:36 <betty> shapr: me too ('89)
07:54:59 <shapr> betty: If you don't mind me asking, where did you go to college?
07:55:02 <xerox> shapr: hiya, can you have lambot joining #haskell.it
07:55:04 <byorgey> thanith: I would say, check them here first to make sure they are really errors and not just misunderstandings on your part
07:55:05 <blarz> shapr: what is that?
07:55:11 <blarz> shapr: I didn't hear of that
07:55:16 <betty> shapr:  learend Basic and Pascal in high school
07:55:20 <shapr> blarz: learning psychology
07:55:22 <byorgey> thanith: if they are errors, then you can download the sources and make the corrections yourself
07:55:44 <betty> shapr: state university of new york at albany
07:55:44 <xerox> thanks much
07:55:48 <byorgey> thanith: then perhaps send an updated version to Paul Hudak
07:56:00 <betty> shapr: suprisingly a decent eductaion for the $$
07:56:14 <byorgey> and the others, but I don't know if their contact info there is still up-to-date
07:56:23 <byorgey> I know John Peterson is no longer at Yale
07:56:24 <blarz> shapr: ah, I see.
07:56:29 <shapr> UAB wasn't that great. I learned more from hanging out with the guys who ran the network.
07:56:58 <shapr> That's part of the reason I didn't finish my degree. At the time learning was more important to me than credentials.
07:57:31 <thanith> byorgey: good idea :) - i found one or two mistakes - i think :) - in the very interresting monad chapter : the ||| operator doesnt take care of the initial resource count
07:57:33 <ramza3_> shapr: I thought about UAB bioinformatics program
07:57:41 <betty> shapr: learning IS more important than credentials
07:57:52 <shapr> betty: Until you want a job...
07:58:03 <byorgey> shapr: why are you thinking about finishing your degree now?  (just curious)
07:58:43 <shapr> byorgey: There are several places that would have hired me immediately based on my experience, but (will/can) not hire people who do not have any degree.
07:59:04 <byorgey> shapr: hm, that's a good reason =)
07:59:21 <betty> shapr: that seems to be happening more today than it did 10 years ago
07:59:28 <byorgey> thanith: I'm taking a look...
07:59:46 <byorgey> shapr: although seems kind of silly of them to insist on that
07:59:53 <Philippa> betty: misdirected "professionalism" - credentials let HR types play CYA
08:00:06 <shapr> betty: Do you have more than a BS?
08:00:52 <betty> shpar: my undergrad was BA in music with minor in csi. I did a MS in CSI
08:01:07 <shapr> U of A in Tuscaloosa has an interesting "New College" where you design your own degree. I've been considering doing a degree on the engineering of languages.
08:01:08 <vincenz> CSI?
08:01:18 <vincenz> betty: Crime Scene Investigation?
08:01:22 <shapr> betty: Whoa cool, what instruments do you play?
08:02:48 <betty> shapr: flute and piano
08:02:51 <shapr> Nifty
08:03:32 <shapr> I used to play some saxophone, but my ex decided she wouldn't return my sax. *sigh*
08:03:35 <Nafai> shapr: All settled in?
08:03:54 <shapr> Nafai: more like piled in a corner until I buy some furniture.
08:04:06 <shapr> But it's good to be someplace new.
08:04:14 <thanith> byorgey: run 0 (fact (-1) ||| (fact 3)) returns Just 3 but instead of this i think it should return an error because resources are exhausted
08:04:17 <shapr> betty: So what got you interested in Haskell?
08:04:49 <shapr> blarz: Nice pubs around Erlangen, I like the weiswurst there too!
08:05:27 <byorgey> thanith: hm, interesting
08:05:33 <thanith> byorgey: i changed this with an additional check wchich only gives next(r+r'-1) if r >0 and call error "resources exhausted" otherwise
08:05:38 <blarz> shapr: you can have weiswurst all over in bavaria *g* yes, there are quite many pubs :)
08:05:59 <byorgey> thanith: well, I don't think it should call error
08:06:44 <byorgey> thanith: isn't there a built-in way in the monad to indicate resource exhaustion?
08:07:23 <byorgey> ultimately it should return Nothing
08:07:44 <blarz> shapr: have you been to the Bergkirchweih?
08:07:59 <Philippa> SexStick: change nick or get kicked
08:08:15 <Philippa> and change it to one appropriate for this chan
08:08:22 <shapr> blarz: I haven't been to Erlangen in years, I don't remember what we visited. We went to a truly huge pub and had lots of fun.
08:08:24 <thanith> byorgey: yes but in the definition of ||| step ist always called with a resource count of 1 and next (r+r'-1) ist given regardÃ¶less if the initial resource count
08:08:33 * quicksilver suggests LambdaStick
08:08:41 --- mode: ChanServ set +o shapr
08:08:43 <thanith> byorgey: is 0 or even less :)
08:08:51 <Philippa> shapr: oi, I can do my own kicks!
08:08:54 <shapr> SexStick: Excuse me, that sort of nickname is not allowed here.
08:08:56 --- mode: ChanServ set +o Philippa
08:08:58 <shapr> Philippa: bah, ok :-)
08:09:00 --- mode: shapr set -o shapr
08:09:24 * shapr votes for the boot
08:09:27 --- kick: SexStick was kicked by Philippa (you know why you're being kicked. Don't come back with that nick again)
08:09:34 <byorgey> thanith: I agree there might be a problem (I'll have to look at it more carefully) but I'm just saying that the solution shouldn't be to call "error",
08:09:37 <shapr> yay boot!
08:09:45 <Philippa> any objection to a three strikes policy on that one, btw?
08:09:47 <blarz> "The #haskell channel appeared in the late 90s, and really got going in early 2001, with the help of Shae Erisson (aka shapr)." Who that?
08:09:52 <blarz> err
08:09:55 <shapr> blarz: Who that what?
08:09:55 <blarz> how that
08:10:15 <Spark> what's wrong with "sexstick"
08:10:15 --- mode: Philippa set -o Philippa
08:10:22 <byorgey> if they come back we could have lambdabot smack them around with a trout
08:10:28 <shapr> blarz: Um, I decided to learn Haskell, I got SOE and Craft of Functional Programming, I learn best in a community, so I started the irc channel and advertised furiously for years.
08:10:49 <shapr> blarz: Now I have a Haskell job! w00!
08:10:59 <blarz> shapr: nice :)
08:11:01 <Philippa> Spark: the same thing that'd be wrong with "BigDick69"
08:11:10 <shapr> blarz: You too can realize your dreams!
08:11:14 <kscaldef> shapr: where?
08:11:19 <shapr> kscaldef: HAppS LLC
08:11:21 <thanith> byorgey: yes, probably its just more of an ommision than an error because its counter intuitive that the given argument isnt honored
08:11:26 <kscaldef> cool, congrats
08:11:28 <quicksilver> shapr: even the one about flying above the city on a carpet?
08:11:35 <Spark> if someone is immature then they are likely to soon demonstrate their immaturity in more tangible ways
08:11:53 <shapr> quicksilver: Sure, I've been reading about inductrack lately, and we'll just mount some halbach arrays on the carpet..
08:12:34 <Spark> i bet there's at least one person in the world who's birth name was "sex"
08:12:34 <thanith> byorgey: btw, i just called error to check if my thoughts were at least a little valid as im a haskell newbie :)
08:12:39 <Spark> there's someone called "loser"
08:12:46 <kscaldef> yeah! darcs.net is back
08:12:47 <byorgey> thanith: fair enough =)
08:15:02 <byorgey> thanith: at any rate, having made it to the monads chapter in the Gentle Introduction, you seem to be doing very well for a Haskell newbie =)
08:15:24 <Tac-Tics> oh monads
08:15:30 <thanith> byorgey: oh thanks *smiles*
08:15:47 <byorgey> monads / oh monads / how do I love thee?
08:16:02 <shapr> Shall I compare thee to a summer's redex?
08:16:23 <Tac-Tics> m >>= f   <----- monad bondage
08:16:43 <betty> shapr: how long have you been working on HApps.  I was just checking out the 0.9 tutorial last night
08:16:56 <blarz> I think I might get a book about Haskell
08:16:59 <shapr> betty: Hm, nearing a year I think.
08:17:10 <betty> shapr: wow!
08:17:14 <blarz> I like books more then learning from my laptop screen *g*
08:17:30 <byorgey> books = <3
08:17:30 <shapr> blarz: I like the screen! I have a Nokia 770 and I like to read papers that way.
08:17:49 <shapr> Think about it, hundreds of megabytes of research in your pocket!
08:17:51 <quicksilver> shapr: does hAppS write state to disk on every transaction 'commit' ?
08:17:51 * byorgey still likes reading papers on dead trees
08:18:23 <shapr> quicksilver: Yup, and using Read/Show wasn't so fast, I think Lemmih's new code uses Data.Binary though.
08:18:52 <blarz> so, which one can you recommend?
08:18:54 <hpaste>  ramza3 pasted "error at the last line" at http://hpaste.org/3036
08:19:04 <thanith> byorgey: if paul hudak can check a few what i think mare addtional typos, then the gentle intro' ist best point to get started
08:19:12 <quicksilver> shapr: *nod* I knew about binary, I just wanted to check about the 'every commit' behaviour
08:19:23 <shapr> blarz: I've heard Hutton's new book is good, but why not join the Real World Haskell reviewer mailing list and suggest improvements?
08:19:27 <quicksilver> shapr: someone was asking yesterday and I wasn't entirely confident in my answers
08:19:33 <ramza3_> ramza3_: anybody see what I missing here, http://hpaste.org/3036  I thought it was a "tabulation" issue but I removed all tabs
08:19:47 <shapr> quicksilver: The code changes quickly enough that I'm not totally confident without checking :-)
08:20:07 <thanith> byorgey: i find lerning haskell very thought provoking and refreshing
08:20:13 <quicksilver> ramza3_: you can't just stick a random where clause in wherever you fancy :P
08:20:59 <byorgey> thanith: glad to hear it!  so do most people in here, me included =)
08:21:03 <quicksilver> ramza3_: where clauses follow definitions, so that where clause has the effect of ending your 'main' definition
08:21:22 <ramza3_> quicksilver: oh, ok; thanks
08:21:41 <quicksilver> ramza3_: if you just move listenHttp up a few liines (before the where) it should work
08:21:43 <blarz> shapr: how can I suggest improvements without knowing the language?
08:21:50 <byorgey> ramza3_: just move the definition of handler into a let
08:22:02 <quicksilver> shapr: well I think (hope) that the writing to disk after transaction commit is axiomatic
08:22:05 <byorgey> blarz: quite easily.
08:22:09 <shapr> blarz: Learning is not specific to any one language.
08:22:10 <quicksilver> shapr: that's the basis of integrity, after all
08:22:15 <byorgey> blarz: you could say, 'this part confused me.'
08:22:21 <quicksilver> I had thought that the RWH list was closed?
08:22:29 <quicksilver> I thought they only wanted a certain number of reviewers?
08:22:46 <shapr> quicksilver: I agree.
08:22:47 <kcitSkcuF> mean
08:22:57 <kcitSkcuF> Why can't I be in here with SexStick?
08:23:36 <byorgey> kcitSkcuF: wow, you're so incredibly clever
08:23:42 <kcitSkcuF> how's that?
08:24:09 <blarz> omg ;)
08:24:47 <quicksilver> kcitSkcuF: because the name is inappropriate
08:25:00 <kcitSkcuF> quicksilver ok
08:25:02 <thanith> byorgey: aaaaarrgghhhh -> good colleage wants to meet me to check his nasty C programm what an ugly language :)
08:25:04 <kawfee> fine
08:25:08 <kawfee> I'll use this one then
08:25:23 <kawfee> dam dictators
08:25:29 <byorgey> thanith: hehe
08:25:32 <kawfee> always ruin a good language
08:25:33 <quicksilver> thanith: it's like doing a crossword puzzle. Enjoy the challenge :)
08:27:29 <thanith> all: have to leave now - thanks for the friendly welcome and byorgey: for quickchecking my thoughts
08:27:48 <shapr> thanith: Come back soon
08:28:02 <byorgey> thanith: you're welcome =)
08:28:17 <Tac-Tics> Every good language has a benevolent dictator
08:28:32 <byorgey> blarz: dcoutts wrote a review of Hutton's book in Issue 7 of the Monad.Reader
08:28:34 <byorgey> http://www.haskell.org/haskellwiki/The_Monad.Reader
08:28:35 <lambdabot> Title: The Monad.Reader - HaskellWiki
08:28:53 <blarz> byorgey: ah, thanks :)
08:29:03 <thanith> quit
08:36:28 <fasta> Where did the debugger documentation move to? http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html
08:36:29 <lambdabot> Title: Chapter 3. Using GHCi
09:00:13 <shapr> ramza3_: I think couchdb would be pretty easy to do with IxSet in HAppS, except for the incremental replication.
09:02:31 <puusorsa> is installing ghc 6.8 a really bad idea_
09:02:54 <sjanssen> puusorsa: probably not a great idea yet
09:02:55 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
09:02:57 <puusorsa> did layman -a haskell on gentoo to get it to emerge happs nicely, emerge -vau world wants to install ghc 6.8
09:03:24 <sjanssen> puusorsa: lots of packages still don't build with 6.8
09:03:32 <sjanssen> watch out for Cabal 1.2.0 too
09:03:38 <puusorsa> wants to install it too
09:03:47 <puusorsa> oh well i'll jsut mask those two then
09:03:58 <puusorsa> and/or do quickpg cabal ghc
09:04:11 <puusorsa> so i can get back to older  versions if they break too many things
09:04:56 <sjanssen> silly lambdabot lost my message :(
09:05:37 <puusorsa> how about darcs 1.1.0 or dev-haskell/hdbc-1.1.2.0 _
09:05:38 <puusorsa> ?
09:05:42 <puusorsa> bad ideas too?
09:06:24 <blarz> Programming in Haskell sounds quite good
09:07:14 <puusorsa> hooray!
09:14:48 <quicksilver> shapr: I wrote a 2D perlin noise generator in haskell
09:14:57 <quicksilver> shapr: now I can make clouds and marble-like patterns :)
09:15:12 <roconnor> @go perlin noise
09:15:13 <lambdabot> http://freespace.virgin.net/hugo.elias/models/m_perlin.htm
09:15:14 <lambdabot> Title: Perlin Noise
09:15:43 <puusorsa> noise <3
09:15:48 <puusorsa> (like merzbow)
09:16:35 <vincenz> @go pink noise
09:16:37 <lambdabot> http://en.wikipedia.org/wiki/Pink_noise
09:16:37 <lambdabot> Title: Pink noise - Wikipedia, the free encyclopedia
09:17:38 <Tac-Tics> neatness @ the perlin article
09:17:40 <quicksilver> nope, neither pink nor merzbow
09:17:41 <Tac-Tics> that's why I hang out here
09:17:55 <roconnor> looks like brownian motion
09:17:56 <Tac-Tics> people post cool things all the time
09:18:08 <quicksilver> it's a nice article but it's not the one I got my algorithm from
09:18:37 <quicksilver> those pictures "some noise functions in 2d" are not perlin at al
09:18:42 <quicksilver> they're just a blur
09:18:54 <quicksilver> perlin matches up the derivatives everywhere
09:18:58 <quicksilver> so you don't get cusps
09:19:31 <quicksilver> depending what you're trying to do, the quality of the noise may not matter much
09:21:44 <puusorsa> http://en.wikipedia.org/wiki/Merzbow .. noise <3
09:21:45 <lambdabot> Title: Merzbow - Wikipedia, the free encyclopedia
09:22:13 <puusorsa> sorry for offtopic, i'll go back to breaking ghc etc on my linuxbox now..
09:23:06 <shapr> quicksilver: Cool, pix?
09:24:49 <puusorsa> btw, any ideas for a small project to do in haskell to learn things?
09:24:50 <quicksilver> shapr: http://roobarb.jellybean.co.uk/~jules/Picture%2030.png
09:26:23 <Tac-Tics> image processing seems like a fun thing to experiment with
09:26:26 <Tac-Tics> I wish I knew more about it
09:26:55 <phobes> What kind of image processing?
09:27:04 <quicksilver> Tac-Tics: I'm actually wrote that just so I can generate some textures to map onto my openGL surfaces :)
09:27:10 <quicksilver> Tac-Tics: make things look a bit more interesting
09:27:15 <puusorsa> i did a som-thingy to organise por..some images i mean, in c++
09:27:31 <phobes> quicksilver:   (x^2 + y^2) mod 256
09:27:32 <puusorsa> maybe redoing that in haskell wouldnt be completely stupid
09:27:33 <Tac-Tics> any function from Image -> Image really
09:27:39 <Tac-Tics> filters, etc
09:27:44 <quicksilver> phobes: ?
09:27:51 <puusorsa> http://www.mperfect.net/aiSomPic/
09:27:52 <lambdabot> Title: /aiSomPic : Self Organizing Map AI for Pictures
09:27:54 <Tac-Tics> even raster functions
09:27:57 <phobes> That's the texture I always start with :)
09:28:03 <quicksilver> phobes: oh :)
09:28:18 <quicksilver> phobes: turned out my problem with perlin was using linear interp instead of cubic
09:28:20 <puusorsa> except i'd prefer something that wouldn't involve gui
09:28:21 <phobes> where x, y are integer tex coordinates
09:28:26 <phobes> ah
09:28:29 <quicksilver> phobes: so lots of cusps everywhere :)
09:28:34 <phobes> ya
09:28:38 <quicksilver> phobes: fixed that and it looked much nicer
09:29:34 <hpaste>  quicksilver pasted "ADT for procedural textures" at http://hpaste.org/3037
09:29:56 <quicksilver> phobes: made myself a nice little adt to specify textures somewhat POVray-style
09:30:05 <phobes> ya I just saw that
09:30:54 <quicksilver> passing the StdGens around in the ADT feels a little weird
09:30:56 <phobes> You should add x^2 + y^2 mod 256 as another case
09:30:57 <phobes>  :)
09:31:00 <quicksilver> but I think it's probably the right thing to do
09:31:26 <quicksilver> otherwise you generate something complete different each time :)
09:31:37 <quicksilver> which is annoying if you're trying to test the parameters
09:31:41 <phobes> ya
09:31:50 <quicksilver> also, it makes my texture-generation into a pure function
09:31:53 <quicksilver> which is a bonus
09:31:56 <puusorsa> hooray!
09:32:06 <quicksilver> ptEval :: ProceduralTexture -> (GLdouble -> GLdouble -> Color4 GLubyte)
09:32:51 <phobes> What does the Color4 type constructor do?
09:32:57 <phobes> make 4 channels for something?
09:32:58 <quicksilver> nothing at all, really
09:33:00 <quicksilver> yes
09:33:07 <quicksilver> Color4 a is just (a,a,a,a)
09:33:10 <quicksilver> except its strict
09:33:14 <phobes> ok
09:33:22 <quicksilver> it's a haskell/GL thing
09:33:31 <phobes> Right - I haven't looked at haskell GL yet
09:33:36 <quicksilver> it's allowed to be all the various types that openGL permits in colors
09:33:41 <quicksilver> (byte, int and float I think?)
09:33:43 <puusorsa> is there any not-outdated haskell gl tutorial?
09:33:51 <quicksilver> not that I've seen
09:33:56 <puusorsa> sadness
09:33:56 <quicksilver> there are example files
09:34:19 <puusorsa> i know i should just read them, just hoping..
09:34:25 <quicksilver> and you can always ask around here :)
09:40:56 <geocalc> quicksilver-> did you look at frag ?
09:46:23 <geocalc> quicksilver-> also can you do glsl with ghc ?
09:47:53 <shapr> quicksilver: Nice pic!
09:49:16 <ketil> Hi!  Is there a way to run a single QC test at a time (I'd like to measure the time of each one).
09:49:29 <MADnificent> Cale: I found something that may make the monad as Actions clearer.  It may be essential to note readers when the action is actually performed (that is one thing that was hard for me to grasp)
09:49:42 <geocalc> shapr-> is glsl working with ghc ?
09:50:17 <Cale> MADnificent: yeah, I try to be clear about that in my Monads as Computation and Introduction to IO tutorials.
09:50:36 <shapr> geocalc: I don't know.
09:51:47 <byorgey> ketil: sure, just load up GHCi, do :set +s, and run each one with the 'test' function
09:52:28 <byorgey> ketil: oh, wait, by a 'single QC test', do you mean, a single instantiation of the parameters?
09:52:40 <MADnificent> Cale: Your guide about monads as Actions was very good (the IO one was fine too (but that's a lesser way of letting people to know monads, IMHO)) though I believe the sentence 'this is when the action is actually performed' may be good.
09:52:55 <MADnificent> Cale: again, your guide was _very_ good, it clears up my mind (slowly)
09:53:50 <byorgey> ketil: keep in mind that a QC test is just a normal function, so nothing prevents you from evaluating it directly.
09:54:39 <Cale> MADnificent: great :)
09:54:55 <puusorsa> url to cale's guide?
09:55:09 <ketil> byorgey: I think I want 'test', yes.  Let me check, brb.
09:55:28 <MADnificent> puusorsa: http://haskell.org/haskellwiki/Monads_as_computation is the one I'm currently talking about
09:55:29 <lambdabot> Title: Monads as computation - HaskellWiki
09:55:33 <puusorsa> thansk
09:55:49 <MADnificent> puusorsa: having trouble with monads too?
09:55:50 <ketil> byorgey: no, I tried that - 'test' still runs the test 100 times.
09:56:16 <puusorsa> not really. haven't done enough stuff in haskell to really have problems :)
09:56:26 <byorgey> ketil: ok, now I understand what you're asking.  just evaluate the property function directly.
09:56:26 <MADnificent> puusorsa: lucky you :-D
09:56:51 <ketil> byorgey: I need to generate arbitrary values?
09:57:06 <Cale> MADnificent: The idea of monads is really very simple. It's all the examples where the complication is.
09:57:19 <geocalc> is someone know about glsl and ghc ?
09:57:50 <puusorsa> geocalc, i know nothing, but i glimpsed the documentation and i think it is possible
09:57:50 <byorgey> ketil: what exactly are you trying to do, and why?  I guess I'm still not sure what you want.
09:57:50 <shapr> geocalc: Google implies that HOpenGL has partial GLSL support.
09:58:10 <shapr> geocalc: That appears to have been added at the end of 2006, so the support may be more complete now.
09:58:15 <MADnificent> Cale: yeah, the idea of a monad is pretty easy... however what you can do with them is so immense that it is just too much for a n00b to functional programming, to take... but that is what makes it so nice to learn about them...
09:58:33 <ketil> byorgey: I want to write a benchmark suite - so instead of just chekcing for correctness, I want to time each test, and output the times (and stdev, perhaps)
09:58:36 <geocalc> mmh good thanks all
09:58:52 <ketil> I guess I could look at QC's source code for 'test'/'quickCheck' et al.
09:59:09 <shapr> ketil: QC1 is extremely simple, something like 300 lines of code.
09:59:24 <byorgey> ketil: ok, I see.  yeah, I would just hack the QC code.  shouldn't be hard.
10:00:48 <ketil> byorgey: Easy-peasy - I'll use 'check' with a custom config, specifying the number of tests.
10:00:51 <ketil> thanks!
10:01:35 <byorgey> ketil: well, the only problem with that is you may not get the same distribution of arbitrary values
10:02:04 <byorgey> I think when picking the values to use for testing, QC starts 'small' (e.g. small integers, empty/short lists, etc.) and then builds up from there
10:02:23 <byorgey> so running 'check' with only one test a hundred times might get you 100 small/trivial cases
10:02:40 <byorgey> whereas running check with 100 tests will get you some bigger ones as well.
10:02:47 <byorgey> ...I think.
10:03:10 <kscaldef> MADnificent: I think you have to treat learning each monad like learning any new module.  Just understanding the meaning and syntax of "monad" isn't going to give you magic insight into the semantics of any individual example
10:03:37 <ketil> byorgey: I think that's SmallCheck.  But I want fixed size data anyway :-)
10:03:54 <byorgey> no, I'm talking about QuickCheck
10:04:12 <byorgey> but if that's fine with you then go for it, I was just pointing it out =)
10:04:29 <shapr> But you can write your own test case generators for QC
10:04:29 <MADnificent> kscaldef: I am currently learning haskell... I had a really hard time moving on from `what is a monad' to what can monads do (and I think I'm still in the phase of denial ;D )
10:04:38 <byorgey> shapr: that's true.
10:05:25 <shapr> I hacked up a test-driven-development version of QC with that, I saved the seed and the size whenever a test case failed, and reran the test with that same input next time around.
10:05:32 <byorgey> Monad Denial is a relatively common ailment around here =)
10:06:00 <byorgey> shapr, neat.
10:06:02 <MADnificent> byorgey: sure, ook at how bloody cool it is!
10:06:05 <kscaldef> MADnificent: the thing is, monad are too general to try to grasp "what monads can do" all at once.  So, you learn the syntax and the general rules, then learn about particular monads as you need them.
10:06:07 <ketil> byorgey: right, I guess that's what the 'size' thing is in the Config struct.
10:07:06 <kscaldef> MADnificent: maybe after a while you get some revelation and start thinking of monads independent of the particular instance you need for a task, but I haven't reached that point (after 6 months of on and off use of haskell)
10:07:16 <MADnificent> kscaldef: an alternative approach could be to guide the user to what _they_ can build with monads... that's in general more easy to grasp, _then_ show what exists allready.  At least, I find that the easiest to understand myself
10:08:06 <MADnificent> kscaldef: I'm hoping to reach that point very quick (but due to the classes I have to follow, I think it'll be hard)
10:09:03 <kscaldef> MADnificent: well, presumably you have a decent understanding of how to use the IO monad, right?  If not, write some simple programs to interact with the file system until it makes sense
10:09:38 <kscaldef> also, play around with the Maybe and List monads, using the do-notation
10:10:01 <MADnificent> kscaldef: ahm, yes I do understand it... but I'd like to have an api of some sort somewhere... can you link me to one?
10:10:15 <MADnificent> kscaldef: and my Network lib crashes on me (gentoo) :-(
10:10:22 <kscaldef> personally, I liked http://www.haskell.org/all_about_monads/html/index.html
10:10:23 <lambdabot> Title: All About Monads
10:11:01 <kscaldef> MADnificent: API?  well, some is in the prelude: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
10:11:03 <lambdabot> http://tinyurl.com/ovjef
10:11:33 <MADnificent> kscaldef: ah, perfect :-D TY!
10:11:58 <kscaldef> and the System.* modules have a lot of useful functions too
10:12:22 <kscaldef> System.IO, System.Environment, etc
10:12:45 <MADnificent> kscaldef: yes, I'll need those to build actual apps in haskell (which speeds up the learning process)
10:14:59 <kscaldef> MADnificent: from that page for the Prelude, click the "Contents" link on the upper right, and enjoy!
10:16:21 <MADnificent> kscaldef: sublime
10:21:05 <puusorsa> nice, cant get happs examples to compile
10:21:25 <puusorsa> Could not find module `HAppS.Protocols.SimpleHTTP2'
10:22:11 <Saizan> puusorsa: which version of happs?
10:22:35 <puusorsa> 0.8.4
10:22:42 <puusorsa> 'the one emerge installed'
10:22:59 <Saizan> ah the one from hackage
10:23:14 <puusorsa> i should be using at least 0.8.8, right_
10:23:29 <Saizan> yes, if not 0.9.x
10:23:30 <puusorsa> or any ideas what else could be the problem
10:23:34 <puusorsa> thanks
10:23:40 <Saizan> ah
10:23:55 <Saizan> those example won't compile with 0.9
10:24:06 <Saizan> there's no SimpleHTTP2 anymore..
10:24:07 <puusorsa> ok i'll try 0.8.8 then
10:24:22 <puusorsa> really nioce that the gentoo haskell overlay seems to be useless
10:24:51 <puusorsa> wants to install cabal 1.2 and ghc 6.8.1, which would break a lot of stuff.. and then it has too old version of happs
10:25:19 <Saizan> well, the gentoo overlay has what's on hackage
10:25:42 <puusorsa> damn
10:25:42 <Saizan> the point is that there hasn't been a really stable version of happs lately
10:26:05 <puusorsa> well, having the version that the tutorials/examples needs wouldnt be too bad idea, imho
10:26:17 <puusorsa> but then what do i understand
10:26:53 <Saizan> there's also #happs btw
10:30:27 <puusorsa> thanks but i already have more than 20 open windows in irssi.. i'll just install 0.8.8 then and try again, maybe i'll try #happs if it still doesnt work
10:35:02 <puusorsa> ..oh and while i'm complaining, why doesn't cabal include somekind of shellscript wrapper so it's not 'runhaskell Setup.hs configure' etc
10:35:13 <puusorsa> make && make install is a lot nicer
10:35:25 <puusorsa> or just make install and it does make all first or whatever
10:35:35 <roconnor> Setup.hs should be Setup.lhs
10:35:49 <roconnor> so that you can do 'Setup.lhs configure'
10:36:14 <puusorsa> well for example in HList it's not
10:36:17 <roconnor> and #!/usr/bin/runhaskell should at the beginning of Setup.lhs
10:36:26 <roconnor> ... or is that not portable enough?
10:36:32 <puusorsa> and i have runhaskell in /opt/ghc/bin
10:36:37 <roconnor> well, people can always fall back to runhaskell.
10:36:56 <puusorsa> ..so i guess i'll just write the script myself
10:37:44 <puusorsa> hmake or something... just plain hmake does runhaskell Setup.hs confiure and thesame build (or .lhs, depending on which one exists)
10:40:05 <puusorsa> ..oh, and having a system that 'darcs get's the dependecies and compiles them too ..
10:40:12 <puusorsa> should i just stop dreaming
10:40:25 <psnively> Or write it.
10:40:52 <puusorsa> can't do it yet, i'm a haskell newbie
10:41:09 <psnively> Me too.
10:41:31 <puusorsa> so, no one is doing anything like that yet?
10:42:18 <arcatan> just use bash
10:42:29 <puusorsa> i prefer zsh
10:46:01 <Cale> puusorsa: The smarter Setup.hs files start with #! /usr/bin/env runhaskell
10:46:22 <Cale> puusorsa: and yeah, there's work on cabal-get
10:46:59 <puusorsa> <3
10:47:39 <iguana_> can I have a type class of which both Int and (Int,Int) are instances?
10:48:02 <Cale> iguana_: yes
10:48:07 <roconnor> That would require haskell extensions
10:48:27 <iguana_> how would I declare the tuple instance?
10:48:28 <Cale> Extensions which practically every Haskell implementation implements :)
10:48:30 <roconnor> but Int and newtype IntPair = (Int,Int) can be done in haskel 98
10:48:39 <Cale> instance C (Int,Int) where
10:48:40 <Cale>  ...
10:48:55 <iguana_> I guess that needs -fglasgow-exts then?
10:48:57 <Cale> roconnor: forgot the newtype constructor
10:49:06 <roconnor> oops.
10:49:30 <byorgey> why does that require extensions?
10:49:34 <oerjan> roconnor: actually it is quite possible to do (Int,Int) in H98, but you need to make some intermediate classes
10:49:57 <Cale> byorgey: Haskell 98 was *very* conservative about what it allowed you to define instances for
10:50:14 <Cale> byorgey: Basically, they were only allowed to depend on the top-level type constructor
10:50:17 <oerjan> i.e. you need an instance for (a,b) which delegates to something else for a and b
10:50:24 <byorgey> I see.
10:51:00 <roconnor> byorgey: I think there is some question about if the polymorphic type (a,b) is an instance of your class.
10:51:51 <Cale> After all, at the time "constructor classes" were still fairly new
10:52:19 <oerjan> surely they go back to haskell 1.4 at least
10:52:27 <Cale> well, yes
10:53:04 <oerjan> but i guess h98 was not an inventive stage, rather the opposite?
10:53:07 <Cale> Not ten years old though
10:53:26 <Cale> Yeah, in fact, H98 went backwards on many things
10:53:34 <oerjan> @quote scare.of
10:53:34 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
10:54:10 <Cale> I think the goals were to find something less experimental which wouldn't change too much for a while -- long enough to write some books anyway
10:54:58 <puusorsa> nice. happs 0.8.8 doesnt compile
10:54:59 <puusorsa> src/HAppS/Protocols/HList.hs:24:96: Not in scope: type constructor or class `F'
10:55:01 <Cale> I'm annoyed though that we're still stuck with the same prelude.
10:55:42 <roconnor> you don't have to use the Prelude :)
10:55:57 <Cale> roconnor: I have to use its conventions though
10:56:05 <Cale> roconnor: Tried changing the Monad class? :)
10:56:29 <roconnor> oh right, the sugar
10:56:38 <puusorsa> maybe i should just give up on happs.. what would you recommend instead, preferably something that uses postgres for db?
10:56:45 <wli> compiler/deSugar/ needs fixups.
10:56:55 <Cale> puusorsa: what are you writing?
10:57:15 <puusorsa> nothing as happs doesn't work obviously :)
10:57:31 <Cale> puusorsa: You know what I'm asking :)
10:57:36 <puusorsa> something to do webapps in haskell
10:57:48 <dons> so C++ won the ICFP contest
10:57:53 <dons> the google team
10:57:59 <Cale> Unless your webapp is very large, I'd recommend just keeping your data in memory and serialising it yourself.
10:58:01 <dons> perl came second, ocaml 3rd
10:58:13 * wli cries
10:58:14 <dons> 2 brute force entries in the top 3, interestingly
10:58:32 <dons> 66 haskell entries though, making it the 3rd largest after C and C++
10:58:38 <puusorsa> Cale, so the haskell-db things are no good?
10:58:53 <lament> wow, haskell just totally failed it
10:58:55 <oerjan> wow, perl
10:59:06 <Cale> puusorsa: They're okay, you can try them, but I don't think they're usually worth the trouble.
10:59:06 <vincenz> dons: where's the results?
10:59:09 <vincenz> dons: you're @ icfp?
10:59:11 <dons> lament: i think there's 5 or so haskell guys in the top 15, so i wouldn't say that :)
10:59:16 <puusorsa> probably using rails would make more sense but i'd like using haskell
10:59:29 <Cale> puusorsa: People use external databases far too often.
10:59:31 <dons> it seems to be a fairly random mix -- maybe there wasn't a lot of programming involved?
10:59:39 <lament> dons: that would be impressive if we were to forget the past results :)
10:59:39 <vincenz> dons: where are you gettng this info?
10:59:50 <dons> vincenz: i was sitting in the room :)
10:59:50 <puusorsa> Cale, they work, why reinvent the wheel
10:59:54 <vincenz> dons: ooh
11:00:01 <vincenz> dons: poke em to put the slides online :P
11:00:03 <wli> Cale: No, nowhere near often enough.
11:00:04 <dons> video will be up tonight probably
11:00:15 <wli> dons: You're in Freiburg?
11:00:18 <dons> lament: yeah, though with 1000 submissoins, its getting harder
11:00:20 <dons> wli, yep
11:00:24 <xerox> Be sure of topic-izing the video url :)
11:00:28 <puusorsa> + it's easier to do stuff wit the same data in another language or whatever if it's in some standard container like sql db
11:00:50 <dons> haskell and C++ seemed to have the best ropes / finger tree support, interestingly, the judges noted
11:01:23 <vincenz> \o
11:01:57 * roconnor needs to pack
11:02:01 <Cale> The ICFP problems are getting kind of strange.
11:02:08 <vincenz> yeah
11:02:14 <vincenz> it's more puzzle solving than programming competition
11:02:22 <dino-> Cale: "...serializing it yourself..." or there's HAppS
11:02:23 <vincenz> it was a bit dismaying :|
11:02:31 <puusorsa> dino-, which doesnt compile
11:02:34 <vincenz> let's go back to the post-script based 3d renderers!
11:02:38 <Cale> dino-: well, yeah, that's what HAppS does.
11:02:46 <hpaste>  ramza3_ pasted "Simple check for end of file with sockets" at http://hpaste.org/3038
11:02:47 <dino-> puusorsa: Huh, 0.9.1 ?
11:02:49 <puusorsa> src/HAppS/Protocols/HList.hs:24:96: Not in scope: type constructor or class `F'
11:02:53 <puusorsa> 0.8.8
11:03:04 <dons> yes, there's a lot of talk that icfp is too big now, and too little about programming. so maybe next year things will change
11:03:05 <puusorsa> 0.8.4 did, emerging it worked
11:03:18 <puusorsa> but the tutorials wont compile with it
11:03:31 <dons> the cmu guys changed the direction, and the utrecht team did something truly amazing
11:03:31 <glguy> emerging isn't a verb for installing software outside of #gentoo :)
11:03:44 <puusorsa> glguy, still it worked
11:03:46 <Cale> dons: maybe if they made the contest much longer. This year's was odd in that it doesn't appear that you could actually get through all of that in a weekend.
11:03:51 <roconnor> dons: truly amazing?
11:04:05 <vincenz> roconnor: you have to admit, that what they made is quite a technical feat
11:04:15 <vincenz> that being said, I still prefer the older style contests
11:04:16 <ramza3_> http://hpaste.org/3038  ... simple newbie stuff, should I just catch the exception for end of file and close the socket or is there something cleanerr
11:04:19 <Cale> dons: Or limit the contest creators' time to be equal to the length of time that people will actually have to solve the problem.
11:04:24 * wli doesn't really understand why the utrecht stuff is so amazing.
11:04:39 <puusorsa> oh well i probably should do something else with haskell
11:04:41 <arcatan> why the lucky stiff, why the utrecht stuff
11:04:45 <roconnor> vincenz: oh, in that respect yes: but as Cale says, the problem's scope didn't seems appropriate, so in that sense it is a failure
11:04:49 <vincenz> wli: the way they encoded stuff in that file is quite impressive, especially as you could look at the raw text, look at it as if it were bits, and you'd see wave files
11:04:52 <roconnor> either that or we are all failures.
11:04:54 <vincenz> roconnor: I agree
11:04:55 <dons> the depth of the problem was quite stunning -- the number of things you could hunt down
11:05:13 <ramza3_> hIsEOF hmm
11:05:13 <Cale> sure, it would make a better month-long contest
11:05:29 <dons> the best solution took 2 weeks to produce
11:05:45 <roconnor> 2 weeks?
11:05:47 <dons> it was a tiny prefix, that solved the puzzle (99.999% )
11:05:52 <roconnor> oh
11:05:53 <dons> yeah, but 2 weeks after the contest
11:06:06 <roconnor> how tiny?
11:06:21 <dons> 1800 chars or some such (small enough to fit on a single slide)
11:06:26 <lament> so was there any actual programming in the ICFP?
11:06:38 <roconnor> lament: I wrote code.
11:06:47 <dons> lament: you had to build a fast vm, and get good at string matching
11:06:57 <Cale> puusorsa: I'll try compiling it and see if I have the same problem
11:07:06 <lament> dons: hence perl in the top 3? :)
11:07:33 <puusorsa>  darcs get --partial --tag=HAppS-0.8.8  http://happs.org/HAppS
11:07:34 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8.8 )
11:07:36 <puusorsa> Cale, thanks
11:07:36 <dons> lament: right. though that was a team of 10 or something
11:07:50 <dons> good for perl though, we thought it was dead
11:07:58 <Cale> puusorsa: What are you compiling it with, btw?
11:08:03 <puusorsa> ghc 6.6.1
11:08:12 <Cale> okay
11:08:22 <Cale> I just have 6.6 at the moment.
11:08:44 <roconnor> so where is the google video of the ICFP contest debreifing?
11:09:25 <Cale> dons: What happened to those videos near the ones you linked on google video? It looks like they start off, but the sound desynchs and they're only two minutes long?
11:09:39 <dons> Cale: apparently the wifi dropped out during upload
11:09:45 <Cale> ah
11:09:45 <dons> since the conference wifi isn't good
11:09:47 <dino-> puusorsa: I don't know if you've done a lot of work that relies on the 0.8.8 API, but as I understand the (very different) 0.9.x stuff is where it's all going.
11:09:58 <puusorsa> haven't done anything
11:10:02 <dons> malcolm will upload them again, and the acm recorded other copies
11:10:12 <puusorsa> would've installed 0.9.x but someone said that the tutorials won't work with it
11:10:24 <dino-> puusorsa: That's right. There really aren't any yet.
11:10:58 <puusorsa> ok let's forget this, thanks for the effort, i'd think of something else to do with haskell
11:11:03 <Cale> dino-: Would you say HAppS is getting simpler or more complicated?
11:11:26 <Cale> puusorsa: which file was that error in again?
11:11:51 <puusorsa> src/HAppS/Protocols/HList.hs:24:96:
11:11:55 <dino-> Cale: I have almost no experience yet with 0.9, I'm not sure yet.
11:12:17 <dino-> I've been learning how to use STM to work on something else ATM.
11:12:26 <dino-> But I really want to get back on top of happs and soon.
11:12:36 <Cale> puusorsa: My build finished compiling
11:13:38 <puusorsa> what version of hlist_
11:13:39 <puusorsa> ?
11:13:59 <Cale> 0.1
11:14:23 <Cale> at least, that's what package.conf reports
11:14:28 <puusorsa> same here.. wierd
11:14:50 <puusorsa> anyway, screw webapps, i'll think of something else :)
11:15:02 <hpaste>  Cale pasted "build log" at http://hpaste.org/3039
11:15:16 <Cale> er, damn, truncated
11:15:23 <Cale> oh well
11:15:26 <Cale> it went fine :)
11:15:41 <puusorsa> nevermind. thanks for the effort, but i don't really have to do webapps in haskell, just forget it
11:16:15 <Cale> okay
11:16:27 <Cale> If you really do need a database at some point, you might try HDBC
11:16:38 <Cale> But I've heard mixed things about it
11:16:40 <shapr> Have you tried IxSet?
11:16:50 <Cale> nope, I haven't even heard of IxSet
11:16:57 <puusorsa> gtkhs seemed a lot more mature when i tried some examples
11:17:01 <shapr> It's in HAppS, it's nifty.
11:17:13 <Cale> ah, okay
11:17:24 <byorgey> shapr, what's IxSet?
11:17:25 <shapr> It's a separate lib, worth investigating.
11:18:20 <Cale> In the development version?
11:18:27 <shapr> It's in 0.9.x,  yeah.
11:18:50 <dons> shapr: you saw the various happs articles this week?
11:18:59 <shapr> Nah, where at?
11:19:02 <dons> oh
11:19:09 <shapr> I've been sunk in despondence since my woman left me, trying to dig my way out.
11:19:29 <dons> http://bluebones.net/2007/09/simple-haskell-web-programming-with-happs/
11:19:32 <lambdabot> Title: Simple Haskell Web Programming with HAppS - bluebones.net, http://tinyurl.com/3crnhf
11:19:36 <dons> this guy is writing a series of articles
11:19:41 <shapr> Thanks, I'll check it out.
11:19:51 <puusorsa> i think i'll do SOM organising of images in haskell instead, i've done it in c++ once. and a friend did a more complete thing in java more recently.. i hope i can do a better/faster thing in haskell :)
11:20:19 <dons> and the reddit comments are sobering, http://programming.reddit.com/info/2v1n4/comments
11:20:21 <lambdabot> Title: Simple Haskell Web Programming with HAppS (reddit.com)
11:20:36 <dons> you could distill that into a list of things the project needs to do to better manage its brand
11:21:12 <shapr> Yow, I see what you mean.
11:21:33 <vincenz> http://www.tedp.net/insanity.html
11:22:25 <shapr> vincenz: Gah, I hate that frog.
11:22:32 <vincenz> shapr: frog?
11:22:41 <shapr> That's the frog sound, yeah?
11:23:10 <shapr> vincenz: http://www.youtube.com/watch?v=XkHm8uUuT0o
11:23:55 <shapr> vincenz: From what I heard, the creator of that frog made a stupendous amount of money, and hates the frog more than anyone else.
11:24:01 <puusorsa> hell i'll do stupid win-gui stuff in c# instead
11:28:03 <bos> dons: have there been other happs articles?
11:28:44 <phobes> Why does Haskell documentation find it acceptable to just give a type signature?
11:29:12 <phobes> superZip :: [a] -> [a] -> [a] -> [a->b] -> [b] -> [b] -> [b] -> [(a,b,a,a,b,a)]
11:29:36 <dino-> phobes: Do you mean Haddock-generated documentation?
11:29:43 <phobes> ya
11:29:47 <dons> phobes: it isn't generally acceptable.
11:30:00 <dino-> Like anywhere, if the programmer doesn't fill in more details, the doc-gen tool can't make it up.
11:30:03 <lament> in surprisingly many cases, the type signature and the name is enough to understand what a function does
11:30:13 <dons> http://bluebones.net/2007/09/how-to-install-happs/
11:30:15 <lambdabot> Title: How to Install HAppS - bluebones.net
11:30:20 <dino-> This would happen the same way in Java with javadoc if detail wasn't added by the developer.
11:30:22 <puusorsa> imho haskell documentation needs more examples
11:30:25 <dons> and some haxml things, http://kevin.scaldeferri.com/blog/2007/09/29/UrlSpider1HaXML.html
11:30:26 <oerjan> phobes: sometimes there _is_ more documentation in the source, but haddock hasn't been called with the right options
11:30:29 <lambdabot> Title: Kevin's Weblog 2007-09-29
11:30:29 <dons> puusorsa: yeah, i agree
11:30:34 <phobes> dino:  No, in java parameters have names too
11:30:54 <dons> bos, not a great week for web programming in haskell stories
11:31:07 <phobes> I agree examples are great
11:31:14 <dino-> phobes: I see what you're saying. You don't get the definition of the function in haddock. Where meaninful names are used if at all.
11:31:28 <dons> phobes: here's what i would consider ok, http://hackage.haskell.org/packages/archive/binary/0.3/doc/html/Data-Binary.html
11:31:31 <lambdabot> http://tinyurl.com/3cx6qr
11:31:35 <dino-> I have seen occasional use of more descriptive type var names used in type signatures.
11:31:39 <lament> :t zip
11:31:41 <bos> dons: yeah, haskell is way behind the curve for web stuff.
11:31:41 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
11:31:55 <lament> what would be meaningful parameter names for zip?
11:32:01 <lament> firstList, secondList, zippedList?
11:32:09 * wli has occasionally used more descriptive type variable names in type signatures.
11:32:34 <Cale> bos: I suppose that depends on what you compare it with :)
11:32:40 <dino-> lament: Ya, seems like it's not always necessary.
11:32:52 <Cale> bos: But yeah, I agree things could be a lot better.
11:33:15 <bos> Cale: well, compared to say python, ruby, c#, java, or perl.
11:33:30 <Cale> I have the sense that Haskell programmers stayed away from attempting web-stuff for a long time just because there are so many issues that getting the solution really right is a pain in the ass.
11:33:34 <dons> i.e. the languages we're competing for mindshare with
11:33:44 <Cale> (and Haskell programmers tend to be perfectionists)
11:33:45 <puusorsa> php?
11:33:55 <dons> and doing high assurance is a lot more fun -- but there you're competing with C
11:33:58 <glguy> bos: is it really behind Perl in web support? is Perl used as more than a cgi?
11:34:03 <puusorsa> (i think it's evil, but seems to be popular for web stuff)
11:34:29 <bos> glguy: you bet it's behind.
11:34:34 <puusorsa> wasn't perl more popular a few years ago
11:34:42 <puusorsa> like before java
11:34:54 <bos> perl has vast quantities of code for web tasks, both on the client and the server side.
11:34:55 <glguy> bos: so a more appropriate answer would be to ellaborate rather than restate :-p obviously I'm not clear on the topic
11:35:12 <glguy> so more web related library support?
11:35:21 <bos> yes.
11:35:42 <dons> glguy: we need to release some libs
11:35:55 <glguy> oh?
11:35:56 <dons> since there's not many other groups doing web stuff that are likely to do it
11:35:59 <wli> Weren't there CGI combinators 5+ years ago?
11:36:08 <dons> wash, yeah.
11:36:24 <bos> the problem is that there's a bunch of half-baked underdocumented code already out there.
11:36:26 <puusorsa> this shit is making my head explode..
11:36:50 <glguy> dons: what libs around here would be relevant to making Haskell more acceptable for web devel?
11:36:58 <Cale> puusorsa: what is?
11:36:59 <dons> glguy: libcurl for starters, and the xml libs
11:37:04 <bos> HaXML looks fairly complete, but the documentation is weak, the API is huge, and it falls down on relatively simple tasks.
11:37:12 <dons> on the client side. i know we don't have a secret rails project :)
11:37:15 <bos> dons: galois's libcurl binding is already out somewhere.
11:37:29 <dons> yeah, seems to be missing some quality control, haxml
11:37:36 <puusorsa> trying to think of something sensible to do in haskell
11:37:37 <glguy> I haven't really been pushing it nearly as hard as I should be (libcurl for haskell)
11:37:43 <dons> lack of interaction between clients/users and lib authors
11:38:05 <puusorsa> fighting with happs for a few hours was kinda discouraging
11:38:12 <dons> seems to be the main disconnect in the web stuff in haskell -- research ideas, not built up over time with user feedback and improvement
11:38:20 <bos> dons: right
11:38:25 <puusorsa> is there some lib for loading images in haskell_
11:38:26 <puusorsa> ?
11:38:28 <glguy> I just haven't seen a big demand for it and I've already distributed one little library no one uses :)
11:38:40 <puusorsa> loading and manipulation and analysing
11:38:50 <Cale> puusorsa: I once wrote a binding to Imlib2
11:38:52 <bos> there's no demand because there are no libraries, so people use other languages.
11:39:00 <Cale> puusorsa: but I'm not sure if I still have it
11:39:01 <dons> we're not really the community to build a web framework either -- not enough web devs
11:39:14 <dons> someone would have to come in
11:39:17 <bos> i wrote the haskell book comment system using django because i wasn't willing to devote a month to wrestling with happs.
11:39:34 <puusorsa> nice, then i don't think i'm doing the som thingy in haskell, either
11:39:47 <dons> so its a purely social issue though
11:39:50 <bos> hi CosmicRay
11:39:59 <CosmicRay> hi bos
11:40:02 <dons> there's no technical reasons, just the community emphasis is elsewhere
11:40:32 <CosmicRay> bos: I'm actually looking for you... the comment site seems to be pretty slow and I don't think it's net-related
11:40:38 <bos> CosmicRay: oh?
11:40:47 <dons> given a bit of time, and some inside knowledge, a concurrent, fast, combinator-based framework for web stuff in haskell could be very very good
11:41:07 <dons> since domain specific languages, and fast concurrency, are strong pionts of the language
11:41:12 <CosmicRay> bos: yeah, it'll connect but take forever to get a http response back
11:41:22 <bos> CosmicRay: hmm.
11:41:28 <dons> stupid python eh bos
11:41:31 <CosmicRay> heh
11:41:38 <bos> actually, yes. django sucks.
11:42:10 <bos> CosmicRay: could you do me the favour of mailing me with a reminder of this problem, please?
11:42:16 <CosmicRay> bos: certainly
11:42:47 <CosmicRay> that is, as soon as I SIGTERM kmail and restart it anyhow.  stupid mail reader.
11:43:31 <CosmicRay> bos: suddenly it seems better.
11:45:05 <CosmicRay> well, I'll harass you if it gets worse again, I guess ;-)
11:46:01 <bos> heh
11:48:16 <puusorsa> ..nice, no imagemagick binding for haskell, or anything similar
11:48:49 <dons> there's some image manipulation stuff in gtk for a wide range of formats, but imagemagick is one binding proposed for the hackathon
11:49:08 <dons> puusorsa: we write code constantly, but unless people jump in to write their favourite bindings, its hard to keep everyone happy
11:49:44 <elliottt> imagemagick bindings would be cool
11:50:06 <puusorsa> i really need to think of something that i can do in haskell now and not sometime in the future when some package is more mature, some bindings exist, or whatever
11:50:34 <puusorsa> to learn stuff so maybe someday i'll feel like i could do some useful package/bindings/something myself
11:50:59 <dons> puusorsa: well, look at the current libs on hackage -- there's a good range of things, maybe look at existing apps, and ponder something similar?
11:52:15 <puusorsa> yeah well i have some 75% complete annoying ircbot, i could just finish it
11:53:17 <dons> irc bots you should be able to do -- we have huge tutorials and bots themselves for you to study, and an irc lib
11:53:29 <puusorsa> yeah found them
11:53:38 <glguy> hpaste is a simple irc bot inspired by dons' tutorial
11:53:42 <glguy> whose source is available
11:53:57 <dons> and the hpaste bot too, yes
11:53:58 <glguy> hpaste has a bit of a one track mind
11:54:01 <sieni> fyi, puusorsa == wooden duck in finnish
11:54:05 <glguy> so that could make it easier to follow
11:54:12 <puusorsa> sieni == mushroom
11:54:22 <glguy> glguy == awesome
11:54:26 <dons> glguy: hpaste, trevor's irc lib, and the lambdabot maintainers sitting next to each other ... we really should be able to produce lambdabot7 :)
11:54:31 <puusorsa> WE AM THE AVERAGEST!
11:54:58 <glguy> dons: one meteor could wipe out the Haskell IRC bot community!
11:54:58 <dons> glguy is awesomo 3000
11:55:07 <dons> oh noes!
11:55:23 <oerjan> @remember glguy dons: one meteor could wipe out the Haskell IRC bot community!
11:55:23 <lambdabot> Done.
11:55:25 <glguy> we need to distribute better, I'll move to Hawaii
11:59:38 <vincenz> glguy: seriously, if you don't go MPTC (multi-planetary technical committee) then a big enough meteor could still wipe you all out
12:00:30 <vincenz> glguy: move to mars :)
12:02:13 <glguy> vincenz: they don't have any ISPs though
12:02:16 <glguy> so Mars is right out
12:06:17 <infrared> i see dons is here, so i have a question about lambdabot :)
12:06:54 <infrared> I compiled it, and when i try to run an expression in it (like "> 1 + 1") i get an error:
12:06:58 <infrared> "Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString"
12:07:06 <infrared> dons: any ideas?
12:07:15 <dons> update to the latest regex library, iirc
12:07:24 <dons> there was a bug in one of the regex modules
12:07:37 <infrared> ok, i'll try that now
12:07:44 <dons> oh, also check you have runplugs installed
12:08:06 <dons> $ cd lambdabot
12:08:06 <dons> $ echo '1 + 2' | ./runplugs
12:08:09 <dons> should work
12:08:24 <infrared> dons: it doesn't work
12:08:34 <infrared> "runplugs: /tmp/MdZxuC7702.o: unknown symbol `base_GHCziBase_ZMZN_closure'"
12:08:48 <dons> ah ha
12:08:59 <dons> so your hs-plugins install doesn't look very happy
12:09:11 <infrared> ok... what does it mean?
12:09:15 <infrared> :)
12:09:36 <dons> you might be on a platform whos linker details aren't well supported, or you might have some other issue with hs-plugins
12:09:58 <infrared> is the hs-plugins the same as plugins?
12:10:12 <dons> yeah
12:10:18 <dons> be sure you're using the darcs versoin
12:10:28 <infrared> i got a hackage version
12:10:39 <infrared> 1.0
12:11:04 <dons> ok, you need the one from darcs
12:11:11 <dons> unfortunatly
12:11:17 <dons> i should update lambdabot to be more specific
12:11:47 <infrared> btw, linking packages on hackage to their homepages would be very helpful
12:12:03 <gour> will more-automated c2hs-like tool help to have more haskell-bindings?
12:12:04 <dons> yeah, i agree.
12:12:10 <dons> most have a webapge link
12:12:20 <dons> but hs-plugins was one of the very first uploaded, so missed out
12:12:31 <dons> gour: yeah
12:13:25 <infrared> is it just me, or it's a rule that "darcs get" is quite slow?
12:13:58 <dons> on the hs-plugins repo, to australia, yes. in general, probably yes
12:14:50 <infrared> ok
12:15:32 <tibbe> how can I load .hsc files in ghci?
12:15:52 <oerjan> short for darc syrup *ducks*
12:16:38 <dons> tibbe: hsc2hs first
12:16:47 <dons> bos, http://programming.reddit.com/info/2vuaa/comments
12:16:48 <lambdabot> Title: Intel Research: Parallelism Drives Computing :: PDF (reddit.com)
12:16:51 <dons> nice talk
12:17:05 <tibbe> dons: so basically write a script that does that and launches ghci? there's a -cpp flag but it doesn't seem to work
12:17:26 <tibbe> dons: maybe because the file depends on other files which are also .hsc
12:17:41 <tibbe> dons: I really want fast repl turnaround development for hackathon if possible
12:17:53 <dons> yeah, a script, if you're using a lot of hsc2hs
12:17:58 <dons> fast repl is a good idea
12:18:03 <dons> you in town yet?
12:18:29 <gour> dons: do you enjoy Germany/EU ?
12:18:57 <tibbe> dons: no, I arrive 8am on friday
12:19:18 <tibbe> dons: the network package doesn't build for me either
12:19:31 <tibbe> Network/Socket.hsc:325:15: parse error on input `CALLCONV'
12:19:49 <dons> gour: yes, its lovely here in freiburg
12:20:25 * gour is glad dons enjoys the other continent 
12:21:00 * tibbe wonders if there are any hasklers in Zurich
12:21:41 * Nafai is watching the HPC talk
12:24:22 <goalieca> @src Data.ByteString.loopAcc
12:24:22 <lambdabot> Source not found. My mind is going. I can feel it.
12:24:41 <goalieca> @src Data.ByteString.Char8.loopAcc
12:24:41 <lambdabot> Source not found. You speak an infinite deal of nothing
12:24:57 <oerjan> goalieca: i don't think it has any qualified names
12:24:57 <dons> http://programming.reddit.com/info/2vuf5/comments cute
12:24:58 <lambdabot> Title: House: the Haskell OS: a systems guy&#39;s perspective (reddit.com)
12:25:21 <oerjan> @src Data.List.map
12:25:21 <lambdabot> Source not found. That's something I cannot allow to happen.
12:25:26 <tibbe> anyone have a few minutes to help me get the network package to compile?
12:25:36 <dons> you using ghc head?
12:25:36 <goalieca> @src loopAcc
12:25:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:25:48 <dons> gour: oh, loopAcc isn't a user-visible function
12:25:53 <dons> goalieca: ^
12:26:13 <goalieca> :(
12:26:36 <oerjan> @source Data.ByteString.Char8
12:26:37 <lambdabot> Data.ByteString.Char8 not available
12:26:41 <tibbe> dons: no, 6.6.1
12:26:51 <oerjan> @docs Data.ByteString.Char8
12:26:51 <lambdabot> Data.ByteString.Char8 not available
12:27:08 <dons> tibbe: hmm, just  the normal network package available on hackage?
12:27:16 <goalieca> is there a way to "map function getLine"
12:27:17 <tibbe> dons: no from darcs
12:27:24 <tibbe> dons: but yes that package
12:27:28 <infrared> dons: I installed plugins from darcs, recompiled runplugs and it all works now. thanks! :)
12:27:54 <tibbe> dons: do I need cpphs or is hsc2hs enough?
12:28:01 <dons> tibbe: oh, perhaps the darcs repo is for 6.8?
12:28:09 <dons> not cpphs, but hsc2hs yes.
12:28:12 <dons> infrared: great
12:28:17 <dons> tibbe: i'd get network from hackage
12:28:43 <tibbe> dons: I was thinking of using it as base for bytestring socket hacking so I want the latest
12:29:50 <tibbe> dons: if I can get the whole building thing to work smothly before friday
12:30:09 <dons> ok. but then you might need ghc head
12:30:16 <dons> or a newer cabal.
12:30:29 <tibbe> ok
12:30:34 <dons> i'm not sure what the latest changes to network are, so perhaps check the comimt log
12:30:47 <tibbe> I'll try that but OS X has been giving me troubles when I try to checkout ghc
12:30:47 <oerjan> goalieca: is function :: Char8 -> Char8, or Char8 -> something else?
12:30:50 <tibbe> but I'll try again
12:31:03 <tibbe> dons: checked it, nothing that screams 6.8
12:31:12 <oerjan> if the latter, you will need to turn into a list anyway
12:31:16 <goalieca> oerjan, Char8 -> Int
12:31:48 <roconnor> Hmm, it is more important to think about how data is consumed/eliminated rather than how it is produced/created.
12:32:11 <roconnor> how it is consumed should drive it's implementation.
12:32:29 <oerjan> goalieca: map function . unpack, i think
12:32:56 <dons> try to avoid unpack...
12:33:21 <oerjan> dons: but if the result is Int, he cannot can he?
12:33:22 <dons> map f . lines =<< getContents?
12:35:11 <goalieca> does getContents read the entire buffer at once?
12:35:22 <goalieca> as in, could it balloon too big
12:35:25 <dobblego> no
12:35:30 <Zao> It's lazy.
12:35:53 <dobblego> note that it returns a IO [Char] (?) and [] is laz
12:35:55 <dobblego> y
12:36:17 <goalieca> well what about ByteString.Char8
12:36:35 <goalieca> ByteString is not lazy?
12:36:38 <sjanssen> goalieca: that's strict
12:36:54 <sjanssen> Data.ByteString.Lazy is the lazy version
12:43:14 <goalieca> hmm. there's absolutely no processing time difference between lazy and strict versions of bytestring
12:43:19 <goalieca> for 111 MB file
12:43:35 <sjanssen> goalieca: I bet there's a huge memory use difference
12:43:50 <bos> goalieca: there's no hard and fast rule for when to use which
12:44:13 <dons> it really depends on the particular use case
12:44:46 <bos> the only one that's guaranteed to always be a win is the little-known my little pony bytestring.
12:44:57 <dons> that's true
12:45:34 <goalieca> actually cat and my program are both using < 1MB :S well that's as reported by top and system monitor
12:45:53 <goalieca> i think cat is buffering for my app
12:46:31 <bos> is your app using hGetContents, or hGet?
12:50:51 <goalieca> whoops lol. i was running my c-version which did line reading
12:51:02 <vincenz> glguy: you worry about minor technical issues when the continuance of haskell ircbots is at stake?
12:51:04 <goalieca> the bytestrings are stack overflowing both
12:51:38 <goalieca> it's what i figured...
12:53:37 <dons> paste your code please
12:53:48 <dons> likely you've got a straight forward overly-lazy accumulator
12:54:15 <dons> you just catting a file by reading lines at a time?
12:56:56 <oerjan> @users
12:56:56 <lambdabot> Maximum users seen in #haskell: 420, currently: 384 (91.4%), active: 17 (4.4%)
12:57:23 * tibbe thinks that the people on #macosx is the most unfriendly he ever met.
12:58:42 <MyCatVerbs> tibbe: ahahahhahahahah.
12:58:55 <MyCatVerbs> tibbe: nntp://comp.lang.lisp :)
12:59:21 <tibbe> MyCatVerbs: :p
13:00:52 <vincenz> MyCatVerbs: ##c
13:02:47 <goalieca> dons: nm i got it working using getContents, lazy char 8. Lazy is as fast as non-lazy but non-lazy uses 100+MB while lazy uses 2+MB
13:03:14 <vincenz> in ##c anything is off-topic except the std, and as you know the, the c-std contains no useful functionality at all
13:03:29 <vincenz> "How do I make a thread" "That's not in the c-standard"
13:03:34 <newsham> There are no prime numbers, just numbers Bruce Schneier hasn't bothered to factor yet.
13:03:49 <sioraiocht> ROFL
13:03:52 <Excedrin> "How do I make an int" "That's not in the c-standard"
13:04:00 <dons> goalieca: indeed
13:04:05 <dons> that's strictness for you
13:04:27 <dons> be sure to compile with -O2. bytestrings love you when you do that
13:04:34 <goalieca> yup. that's what i did
13:04:49 <sioraiocht> dons: they do?
13:05:04 <goalieca> i find anything in Data gets a big boost from -O2
13:05:12 <newsham> do bytestrings not do the fusion dance without -O2?
13:05:48 <newsham> also, is there a reason its taken a while for people to add bytestrings to parsec?  making the lib use bytestrings doesnt seem particularly hard, do they not benefit from perf?
13:05:53 <sjanssen> anything should get a nice boost from -O, ghc doesn't even try to optimize without it
13:06:39 <dons> noone maintains parsec?
13:06:45 <newsham> ahh, makes sense.
13:06:51 <dons> and there's something non trivial in avoiding appends directly in parsec
13:06:59 <newsham> so if one were to make a tiny parsec lib of their own using bytestrings would it get a big speedup?
13:07:06 <dons> quite possibly
13:07:16 <dons> i'd expect so
13:08:44 <vincenz> New word
13:08:46 <vincenz> "syntactic foam"
13:08:58 <vincenz> from the IEEE magazine "specturm"
13:09:01 <vincenz> spectrum even
13:09:07 <Philippa> definition?
13:09:15 <olsner> making syntax warmer and fuzzier?
13:09:24 <vincenz> it's not CS oriented
13:09:30 <vincenz> it's some padding on top of a robot
13:09:38 <vincenz> but still, we should find a CS definition of syntactic foam
13:10:04 <newsham> http://www.thenewsh.com/%7Enewsham/formal/parse/MyParsecBS.hs
13:10:06 <Philippa> highly verbose syntax that's mostly just air?
13:10:20 <dmwit> XML is syntactic foam.
13:10:21 <dmwit> =)
13:10:29 <oerjan> Philippa++
13:10:47 <Japsu> @remember dmwit XML is syntactic foam.
13:10:48 <lambdabot> Done.
13:10:55 <Philippa> newsham: don't use the name parsec unless you're at least implementing a subset of it
13:10:57 <vincenz> Philippa: I was thinking of python for some reason :)
13:11:19 <Philippa> oh, wait, it's the LL(1) subset
13:11:20 <Philippa> still
13:11:43 <Philippa> I really ought to grab the final version of xerox's code and get it into at least a pre-release ready state
13:12:32 <newsham> phila:  not something I really intend to release.. more for myself and for some friends
13:13:39 <Philippa> newsham: yeah, not really the point as such though. It's a bad idea if "parsec" becomes a general term for monadic parsing combinator libs
13:14:00 <Philippa> also, you just effectively released it - this chan gets logged to the web
13:14:29 <newsham> yah, but if anyone reads the log and uses my lib they'll get what they deserve.
13:15:07 <vincenz> o.O
13:16:18 <newsham> anyway, I'm not sure I understand your concerns, but I will refrain from naming anything else parsec.
13:16:38 <vincenz> parmin?
13:16:51 <newsham> *grabs a kleenex and heads off to make a xerox*
13:17:45 <goalieca> @src su
13:17:45 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:17:46 <goalieca> @src sum
13:17:47 <lambdabot> sum = foldl (+) 0
13:18:03 <goalieca> figures.
13:18:17 <tibbe> newsham: I would really like a nicely documented LL(1) subset of parsec with BS
13:18:46 <tibbe> hint hint, package and hackage ;)
13:19:27 <newsham> my code is written to be educational, not for production use.  I think throwing it into hackage would give the wrong impression.
13:19:57 <vincenz> call it "version 0.1"
13:20:02 <wli> pArrowsÂ¿
13:20:05 <wli> pArrowsÂ?
13:20:11 <wli> One more time.
13:20:21 <wli> How about pArrows?
13:22:02 <araujo> hello
13:23:33 <matthew-_> sup?
13:24:25 <vincenz> no, it's ruby-based
13:24:28 <wli> The combinators build up a tree structure interpreted at runtime.
13:24:53 <wli> No LL(1) or left recursion restrictions that way.
13:25:47 <quicksilver> geocalc: I'm aware of frag but I haven't looked at its code. Not very interested in FPSes.
13:26:04 <quicksilver> geocalc: You can do GLSL but there's no special magic, you still have to code in that god-awful C like language
13:26:11 <quicksilver> shapr: thanks :)
13:27:10 <KatieHuber> quicksilver: so how's your purely functional shading language coming along?
13:27:36 <quicksilver> KatieHuber: I haven't compelled myself to need it yet :)
13:27:45 <quicksilver> KatieHuber: I've written CPU-side procedural textures instead
13:27:52 <geocalc> quicksilver-> thanks
13:27:58 <quicksilver> KatieHuber: which I then render to a Tex2D and map as usual
13:28:34 <Philippa> hmm
13:29:00 * Philippa wonders how much she could get paid to write a compiler from a combinator shading library (or even a full-blown FPL) to something like GLSL
13:29:06 <Philippa> unfortunately I suspect the answer's measured in pints
13:29:54 <quicksilver> Philippa: yes, that's the idea we were tossing around
13:30:06 <quicksilver> Philippa: although we were thinking more of embedded DSL than standalone language
13:30:11 <KatieHuber> I'm not personally convinced that current GLSL implementations are good enough to admit it
13:30:27 <quicksilver> I gather they all contain bugs
13:30:33 <Philippa> oh joy
13:30:36 <quicksilver> such that certain programs crash the pipeline :)
13:30:49 <quicksilver> 'all' may be an exagerration
13:30:55 <Philippa> the standalone bit wouldn't be much harder than the EDSL anyway, given that it'd have to be a so-called 'deep embedding' anyway
13:31:05 <quicksilver> but I found many web pages about GLSL bugs on particular cards/drivers
13:31:07 <Philippa> standalone'd just mean writing a parser and perhaps a specialised typechecker and so forth
13:31:27 <Philippa> how many for the last generation or two of cards?
13:31:48 <quicksilver> wasn't clear to me, I must admit
13:32:04 <quicksilver> Philippa: what does 'deep embedding' mean?
13:32:11 <KatieHuber> not a matter of card generation
13:32:15 <KatieHuber> just that the compilers are poor
13:32:20 <Philippa> that terms in the language get represented explicitly
13:32:35 <Philippa> *thinks*
13:32:40 <quicksilver> rather than coopting the host language's terms?
13:32:50 <Philippa> yeah, I heard a certain amount via one of the guys who works on OOlite that wasn't at all impressive
13:33:12 <Philippa> quicksilver: right. The traditional state monad implementation is a 'shallow embedding'
13:33:24 * quicksilver nods
13:33:42 <quicksilver> I believe I know one of the OOlite guys
13:35:08 <Philippa> Jens Ayton in my case
13:39:21 <bparkis> is it possible, even with infinite computing power, to crack a _randomly generated_ bit string that has been encrypted using PGP?
13:39:55 <shapr> Sure
13:40:02 <shapr> But that's not really on-topic here...
13:40:36 <newsham> you just need a way to enumerate all possible keys, and a way to test if a key is the right one.
13:40:53 <bparkis> but how do you test if a key is the right one given that the original message was random noise?
13:41:15 <pizza_> if you don't know what you're looking for, you can never find it
13:41:21 <pizza_> so your question isn't really sane
13:41:24 <bparkis> using the "right" key on the encrypted block doesn't give output that looks different from using any other key
13:41:45 <wli> I'd have said no.
13:41:58 <shapr> bparkis: With infinite computing power, you can decrypt the bitstring with every possible key, and so you will 'crack' it. Dunno how you'll know when you've got the 'plaintext' though.
13:42:09 <newsham> not certain, but isnt there a MAC you can check?  also some padding rules
13:43:35 <newsham> i bet theres a crypto channel you could ask on :)
13:43:52 <bparkis> this is in relation to the recent UK law about private citizens having to give up their keys to a court
13:44:07 <vincenz> You guys are talking nonsense!
13:44:11 <vincenz> PGP is assymetric
13:44:13 <bparkis> i.e. what if you had a group of people whose hobby it was to send encrypted randomly generated bits to each other
13:44:15 <vincenz> if it's "encrypted"
13:44:20 <vincenz> it's encryped with one guy's public key
13:44:25 <Philippa> "recent" as in 2000 or so
13:44:30 <vincenz> as such, when you find his private key, it's easy to check whether it matchs his public key
13:44:34 <bparkis> then the courts couldn't tell when a key was good or not
13:44:41 <newsham> vincenz: the data is encrypted with a symetric key, and then the symetric key is encrypted with a public key
13:45:01 <vincenz> newsham: that's another option if oyu're concerned of efficiency
13:45:14 <vincenz> newsham: still, what you need to find is the private key, not the symmetrical one
13:45:15 <pizza_> bparkis: just use some sort of deniable encryption scheme
13:45:21 <newsham> also he didnt say you had access to the public key
13:45:39 <Philippa> pizza_: nothing's deniable if they find the software that implements it
13:45:43 <vincenz> newsham: normally you do :)
13:46:03 <quicksilver> Is there a name for the translation when you replace a recursive datatype with a type variable
13:46:19 <quicksilver> so instead of List a = Nil | Cons a (List a)
13:46:29 <pizza_> Philippa: in a deniable scheme the data is in the key, not the software
13:46:32 <quicksilver> you have ProtoList b a = Nil | Cons a b
13:46:34 <wli> In the US, if the algorithm doesn't let the key owner/user/etc. know or remember the key, you just get held for contempt of court until the judge gets bored (assuming he ever remembers you're there) at which point you get hit for obstruction of justice.
13:46:51 <Philippa> pizza_: you misunderstand - there's no plausible deniability if you've just been caught with the software
13:46:56 <quicksilver> such that List a is ProtoList (ProtoList a) a
13:47:05 <wli> In addition to whatever they were going to charge you with anyway.
13:47:31 <wli> You can be held indefinitely for contempt of court anyway so it doesn't really matter.
13:47:46 <pizza_> Philippa: there is also no way to prove that a certain key is *the* key, so at best all you can prove is that they were using deniable encryption
13:48:09 <pizza_> unless i am missing something
13:48:35 <pjd> quicksilver: sort of like closure conversion?
13:48:56 <quicksilver> pjd: maybe
13:49:06 <wli> pizza_: At that point, in the US, you get hit for obstruction of justice from day 1.
13:49:08 <Philippa> depends how much crap you're willing to shuffle with your encrypted data. If they get any key that /could/ be it and get something that looks like something they can do you for, you're going to get done
13:49:09 <quicksilver> pjd: the idea is that you can use other things instead
13:49:26 <quicksilver> pjd: So RefList a = ProtoList (RefList a) a
13:49:36 <quicksilver> pjd: is a list with 'refs at every level')
13:49:39 <wli> pizza_: IOW they'll put you away just for using the cryptosystem/stegosystem you mentioned.
13:49:43 <Philippa> especially as it almost certainly has to hold up against references to the real world
13:49:44 <quicksilver> pjd: So RefList a = ProtoList (IORef (RefList a)) a
13:49:47 <quicksilver> pjd: rather :)
13:49:57 <pjd> eek
13:50:02 <quicksilver> pjd: a trick like this with MVar is used in Chan
13:50:11 <quicksilver> but I thought it might also be used to auto-construct Zippers
13:50:13 <quicksilver> with a little care
13:50:29 <pjd> quicksilver: it's not *exactly* analogous to closure conversion, but close, i think
13:51:14 <pjd> i think it would be analogous to turning named recursion into anynomous recursion
13:51:20 <pjd> with functions
13:51:31 <pizza_> wli: well then you'd have to make sure whatever crime you were committing was worse than the punishment for using it, before you used it
13:51:33 <pjd> so whatever that is called
13:52:08 <wli> pizza: That's in addition to whatever they're going after you for in the first place, not instead of.
13:53:14 <wli> pizza: Odds are they'll just force you to disprove that you committed the crime, constitutionality or whatever be damned.
13:53:15 <pizza_> wli: assuming the system worked as planned and they did not decrypt your messages, how would interecepting those unitelligible messages provide evidence for the original claim?
13:53:45 <pizza_> wli: well if you're guilty until proven innocent then you're screwed no matter what you do
13:53:50 <wli> pizza: See the above, traffic analysis, etc.
13:54:23 <wli> pizza: Criminal justice in the US is a bigger joke than any dictator's show trials.
13:54:45 <wli> pizza: No idea about the UK but I get the impression it's not far behind.
13:54:52 <pizza_> yes indeed, now that they don't even pretend to care about the Constitution
13:55:23 <tibbe> developing on os x makes me *so* frustrated
13:55:25 <wli> pizza: So if you're arrested you're as good as dead anyway.
13:56:06 <wli> pizza: Invest in steganography. If they can't tell you sent a message at all you're in better shape.
13:56:22 <Philippa> if you're arrested you're doing well. You really worry if you're only "detained"
13:56:42 <Philippa> yeah, only it'd better be doable by hand
13:56:50 <Philippa> see earlier comment about being caught with the software
13:57:46 <wli> Once the police are on your doorstep you're as good as dead; cf. rubber hose bits. Steganography.
13:59:06 <ramza3_> is there any reason I would get a permission denined error when opening a file to write (it is windows?) hOut <- openFile "page.html" WriteMode
13:59:13 <bos> rubberhose `ap` pizza_
13:59:25 <bos> ramza3: if someone else has it open
13:59:37 <Philippa> wli: don't forget to obtain it by means they can't track...
13:59:39 <bos> also, ghc causes this to happen on unix too
13:59:40 <ramza3_> bos: nope, it doesnt exist
13:59:52 <bos> ramza3: are you sure the entire path exists, then?
14:00:32 <ramza3_> bos: it should be current directory, right? hOut <- openFile "page.html" WriteMode
14:01:07 <bos> ramza3: hmm, yes
14:01:50 <ramza3_> bos: only other thing, I have another socket connection open at the same time (handle);
14:03:23 <hpaste>  ramza3_ pasted "Error when writing file" at http://hpaste.org/3041
14:04:18 <Botje> ramza3_: you are opening the file over and over again
14:04:23 <Botje> are you sure that's what you meant?
14:04:50 <ramza3_> Botje: oops, a little programming 101 mistake
14:41:10 <puusorsa> i'm about 30min late but ..
14:41:27 <sorear> puusorsa: Nothing has happened in the last 30min.
14:41:38 <puusorsa> 40-50 then
14:41:47 <puusorsa> concerning the crypto stuff
14:42:31 <puusorsa> easiest way to crack open ANY crypto..
14:42:37 <puusorsa> get the person who knows the password
14:42:42 <puusorsa> apply electrodes to balls
14:42:53 <puusorsa> that's what "brute force" really means
14:45:12 <dmwit> > 1.9/3
14:45:13 <lambdabot>  0.6333333333333333
14:45:22 <dmwit> puusorsa: Social attacks for the win. =)
14:45:25 <puusorsa> 234245  bparkis> this is in relation to the recent UK law about private citizens having to give up their keys to a court
14:45:29 <puusorsa> .. nice
14:46:00 <dolio> @seen qubit
14:46:00 <lambdabot> I saw qubit leaving #haskell 10h 21m 55s ago, and .
14:53:24 <shapr> @arr
14:53:24 <lambdabot> Ahoy mateys
14:56:22 <iguana_> are there any more great videos like the two part series from SPJ?
14:57:43 <infrared> iguana_: I'm watching right now a Guy Steele talk on Dan Friedman's great ideas from Dan's 60th birthday, and it's quite nice: http://video.google.com/videoplay?docid=-4633168320660258097&hl=en
14:57:45 <lambdabot> Title: Guy Steele: Dan Friedman--Cool Ideas (Dan Friedman&#39;s 60th Birthday), http://tinyurl.com/22z8kf
14:58:41 <infrared> more related to scheme than haskell, but still very interesting
14:58:46 <puusorsa> k is for knowledge
15:03:45 <TuringTest>  @seen misterbeebee
15:03:57 <dmwit> ?seen misterbeebee
15:03:57 <lambdabot> misterbeebee is in #haskell. I don't know when misterbeebee last spoke.
15:04:05 <sorear> 15:01 -!- misterbeebee-1 [i=cfabb465@gateway/web/cgi-irc/ircatwork.com/x-410274e5e6199193] has joined #haskell
15:04:13 <dmwit> TuringTest: You had an extra space.
15:04:18 <TuringTest> ah
15:04:38 <sorear> twanvl++ for sanity
15:05:01 <twanvl> :)
15:11:32 <quicksilver> yay, my zipper works!
15:11:41 <quicksilver> now I can interactively edit terms!
15:12:20 <glguy> In #archlinux, when you want to have someone added to the quotes database, you say: !grab users_nick right after they say it
15:12:31 <glguy> no paraphrasing by the ?remember er
15:12:44 <quicksilver> I like to paraphrase sometimes
15:12:55 <quicksilver> it helps to add context, or correct irrelevant typoes
15:14:10 <oerjan> besides, what if they say something else before you can hit return?
15:14:19 <Philippa> quicksilver: you've got it rigger to an editor already?
15:14:19 <quicksilver> race condition!
15:14:35 <glguy> oerjan: no sitting around pondering if it was memorable or not
15:14:37 <quicksilver> Philippa: well not a proper editor. but it highlights the part that is 'selected'
15:14:50 <quicksilver> Philippa: which is clearly quite close to editing ;)
15:40:45 <brad_> has anyone been able to build hscurses?
15:40:53 <brad_> i get a million of these from the build stage:
15:40:56 <brad_> invalid preprocessing directive #def
15:44:40 <thoughtpolice> i built it a while ago on 6.6.1 and it worked fine, iirc.
15:46:02 <brad_> hmmm, i am on 6.6.1 too. well i will send a note to -cafe and see if any of the authors perk up....
15:46:36 <brad_> hmm, maybe i need ncurses-devel installed as well...
16:07:13 <thoughtpolice> i just compiled a 6.8 snapshot; if I do a make install will it overwrite my existing /usr/local/bin/ghc or will it put it under some name like ghc-6.8.2007...?
16:08:35 <bparkis> how much of thedailywtf is made up by the editors?
16:08:38 <bparkis> 95%?
16:08:59 <EvilTerran> editor, but probabl.y
16:15:03 <ddarius> That wouldn't matter if you can't tell which 5% isn't.
16:15:51 <Vulpyne> It's still amusing even if it's fictional.
16:16:19 <EvilTerran> indeed
16:24:26 <bos> thoughtpolice: it will overwrite your ghc by default
16:25:09 <sorear> thoughtpolice: Both.
16:25:31 <LoganCapaldo> @yow
16:25:32 <lambdabot> Now I'm concentrating on a specific tank battle toward the end of World War II!
16:25:43 <sorear> thoughtpolice: It won't overwrite /usr/local/bin/ghc-6.6.1, but 'ghc' almost always refers to the most recently installed version
16:41:44 <geocalc> thoughtpolice-> use --prefix=/else/where in configure
16:45:19 <Mr_Awesome> is there an efficient way to get the difference between two clock times in seconds or milliseconds without constructing and then deconstructing the TimeDiff monstrosity?
16:47:17 <dolio> '\t1 t2 -> tdSec (diffClockTimes t1 t2)' is bad?
16:48:56 <LoganCapaldo> terrifying
16:49:14 <dolio> Is System.Time or Data.Time the preferred one? I can't remember.
16:50:40 <dolio> It looks like in Data.Time you can use getCurrentTime to get a UTCTime...
16:51:19 <dolio> And then the 'utctDayTime' field of that record is a time of day that's, among other things, a Num, so you could just subtract.
16:51:26 <MADnificent> dolio: I really don't know, I'm a Haskell n00b...  but I'd say you'd better use Data.Time  They wouldn't have built that, if System.time was perfect
16:52:05 <dolio> Well, it's whichever's newer. I guess that's Data.Time.
16:52:49 <dolio> Data.Time seems really complex.
16:53:06 <dolio> But I guess dealing with all sorts of time zone conversion and stuff might be a complex task.
16:53:15 <sorear> dolio: it doesn't even work
16:53:26 <LoganCapaldo> This is why there should only be one timezone
16:53:32 <LoganCapaldo> one imezone to rule them all
16:53:32 <sorear> Mr_Awesome: just deconstruct TOD
16:53:39 <LoganCapaldo> and in darkness bind them
16:53:47 <dolio> LoganCapaldo: No, 4 timezones in one day!
16:53:50 <Mr_Awesome> sorear: i thought it was abstract
16:54:37 <Mr_Awesome> apparently its not
16:54:42 <Mr_Awesome> but shouldnt it be?
16:55:35 <dolio> Well, Data.Time doesn't even seem to exist in my 6.7 install, so I guess that's not a good choice.
16:58:34 <dolio> Wow, there is quite a range of scores in the top 15 of the ICFP contest.
17:02:51 <dmwit> Mr_Awesome: (round .) . diffUTCTime
17:03:54 <dmwit> Mr_Awesome: NominalDiffTime is an instance of many classes; this makes working with it a little bit nicer than you might expect at first.
17:22:48 * SamB_XP is about ready to take an xchat screenshot and pass it off as a photo on facebook...
17:23:12 <LoganCapaldo> That sounds like a perfectly reasonable idea
17:23:32 <dolio> You don't have any actual photos of yourself?
17:23:48 <SamB_XP> well, I only know where to find maybe one
17:24:03 <SamB_XP> and I took that one with a palm pilot...
17:26:38 <dolio> So, did anyone ever complete a rope library so we won't be embarassed by C++ in the future? :)
17:27:15 <SamB_XP> ddarius: how's yours?
17:27:17 <Philippa> Data.Sequence
17:27:48 <Philippa> Seq Char apparently performed pretty well
17:28:06 <dolio> Oh, I guess someone at Hac II is working on Data.ByteString.Rope.
17:28:13 <dolio> And Data.ByteString.Sequence.
17:28:19 <SamB_XP> Philippa: some of us don't have that much RAM to throw at it?
17:28:59 <SamB_XP> why is intel always inviting me to webinars?
17:31:34 <sorear> SamB_XP: so they can surreptitiously get photos
17:33:12 <dbueno> SamB_XP: Data.Sequence is a memory hog?
17:35:28 <phobes> Doesn't the F in ICFP stand for functional?   What steps will be taken to ensure that C++ never wins in the future?
17:36:01 <dolio> The conference is about functional programming. You can use whatever you want in the contest.
17:36:52 <dolio> Apparently the #2 team used perl.
17:42:58 <SamB_XP> dbueno: doesn't it have at least a node per item?
17:43:10 <SamB_XP> phobes: none
17:43:34 <SamB_XP> phobes: it's not bad if C++ wins sometimes
17:43:40 <SamB_XP> it keeps the game competetive
17:43:52 <dbueno> Hmm, why won't hoogle find Data.Sequence?
17:44:04 <dbueno> SamB_XP: I believe so.
17:44:09 <oerjan> @hoogle Seq
17:44:09 <SamB_XP> that is, not bad for the contest
17:44:09 <lambdabot> Prelude.seq :: a -> b -> b
17:44:10 <lambdabot> Network.Socket.SeqPacket :: SocketType
17:44:10 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
17:44:27 <phobes> Having looked at the problem set, I just hope they make future problem sets less... retarded
17:44:34 <dbueno> @hoogle Foldable
17:44:34 <lambdabot> No matches found
17:44:57 <oerjan> @hoogle viewL
17:44:57 <lambdabot> No matches found
17:45:03 <dolio> Data.Sequence is too new for hoogle.
17:45:19 <dbueno> dolio: As is Foldable?
17:45:23 <dolio> Yeah.
17:45:23 <oerjan> @hoogle viewl
17:45:24 <lambdabot> No matches found
17:45:38 <dolio> Hoogle has GHC 6.4-era libraries, I believe.
17:45:41 <phobes> I don't think it's too much to ask for the problem to be solved to be specified precisely
17:46:07 <phobes> It's a programming contest, not a treasure hunt
17:46:28 <dbueno> Hoogle is a *really* cool tool; is there some difficulty to getting it to search 6.6 stuff, or has it simply not been done?
17:46:44 <dolio> The database hasn't been rebuilt in a long time.
17:47:01 <dolio> And ndm is working on a new version of hoogle with an ill-defined ETA.
17:47:24 <SamB_XP> sorear: how are they going to get photos from a webinar?
17:47:24 <dbueno> dolio: "New" meaning I assume more than just rebuilding the database?
17:47:39 <dolio> No, new meaning it uses different search algorithms.
17:47:41 <dolio> A big rewrite.
17:47:43 <sorear> SamB_XP: By misunderstanding the concept? :P
17:48:16 <sorear> upgrading the database wouldn't change the hoogle version *at all*
17:48:16 <SamB_XP> well, I don't know if video feed is involved
17:48:37 <sorear> you could use current hoogle with 6.8 libs
17:48:40 <SamB_XP> but haven't I made it clear that I don't have a decent camera?
17:48:44 <sorear> don just hasn't, that's all
17:49:08 <oerjan> the current hoogle does not handle type constructor classes properly, and has other bugs
17:53:12 <chessguy> i don't think the new hoogle has an ETA at all
18:02:09 <Saizan> maybe a soc next year?;)
18:16:32 <misterbeebee> ?seen TuringTest
18:16:32 <lambdabot> TuringTest is in #haskell. I last heard TuringTest speak 1h 23m 56s ago.
18:18:22 <chessguy> there's an abbot and costello skit going on in #math. very entertaining :)
18:22:34 <misterbeebee> phobes: writing more haskell libraries will ensure C++ never wins in the future.
18:23:09 <misterbeebee> phobes: the icfp contest certainly has taken a turn toward "scavenger hunt" in recent years.
18:23:55 <misterbeebee> that style is fun for a lot of people (especially the non-superprogrammers who want to be involved somehow), but it makes for more of a "Festival" than a well-metriced competition
18:24:49 <platypus> More Libraries is Good, Easy to find Libraries is better, Good Easy to find Libraries is a big win.
18:33:31 <SamB_XP> misterbeebee: well, the last one wasn't too good for the non-superprogrammers I don't think...
18:34:45 <misterbeebee> You mean, 2007? I was thinking of non-superprogs on a team with more super-progs. there were lots of little bits to look into, like scanning endo for literal rna, hacking around with dna prefixes, cracking the encrpytion codes.
18:34:53 <ddarius> When was the ICFP contest ever supposed to be a "well-metriced" competition?
18:35:12 <misterbeebee> you needed some firepower to make sense of it all, but if you got the "backbone" of it, there were lots of little things to play with
18:35:45 <SamB_XP> ddarius: the markup minimization and raytracer years?"
18:35:50 <misterbeebee> the older ICFP's, whether by design or by lack of creativity, we "optimize this specific function"
18:35:52 <ddarius> SamB_XP: And to answer your question: languishing.
18:36:13 <ddarius> SamB_XP: That doesn't mean it's supposed to be.
18:36:31 <SamB_XP> I was under the impression those years were ;-)
18:50:19 <misterbeebee> hmm, i just ran quick test, using the various Regex packages to search for a 10-char substring in a 7MB string. TRE and PCRE where fast (<<1sec), DFA and TDFA were slow (several seconds before I killed the process)
18:50:52 <misterbeebee> http://haskell.org/haskellwiki/Regular_expressions  wiki page says that all 4 are "fast".  I guess there's a distinction between "fast" and "very fast" at the MB scale...
18:50:53 <lambdabot> Title: Regular expressions - HaskellWiki
19:03:50 <sorear> misterbeebee: there are *large* tradeoffs in regexing, if you're willing to accept a major one-time cost I can grep a 7MB string in about a millisecond
19:04:01 <pjd> wooh, za++
19:04:10 <pjd> (ICFP results)
19:06:17 <SamB_XP> sorear: grep it for what?
19:06:43 <sorear> SamB_XP: Anything, as long as it's fairly short and regular.
19:06:57 <sorear> SamB_XP: In particular, any 10 character substring
19:07:04 <SamB_XP> oh
19:07:25 <SamB_XP> can you use it to accelerate other searches?
19:10:15 <misterbeebee> sorear: I understand.... I just don't have any intuition about which of the several Regex package strategies  would be faster for my query.
19:10:32 <misterbeebee> pjd: are icfp results online somewhere?
19:10:49 <pjd> misterbeebee: dunno;  i'm reading http://marco-za.blogspot.com/2007/10/icfp-results.html
19:10:53 <lambdabot> Title: Marco's Blog: ICFP Results
19:11:27 <pjd> which includes a top-15 ranking
19:11:56 <dolio> The results are pretty surprising.
19:12:34 <dolio> I was expecting everyone to have a pretty low survival%, since below the top 15, it was all like 5% or 6%.
19:12:44 <misterbeebee> awesome. given those results (and the posted top-500 from the contest website), it looks like the organizers were right on the mark with their difficulty level.
19:13:28 <misterbeebee> dolio: http://www.icfpcontest.org/submits/scoreboard
19:13:30 <lambdabot> Title: Scoreboard
19:13:44 <misterbeebee> 32nd place was  2.5%
19:14:02 <dolio> Ah, yeah, I guess it's even lower than I remembered.
19:14:49 <misterbeebee> (of course, the % scale was some magical monotonic function... so the curve doesn't really matter)
19:15:35 <dolio> Yeah, I didn't actually look at the problem much at all.
19:15:45 <dolio> So maybe the results aren't that surprising.
19:17:05 <dolio> If getting from 85% to 90% is easier than 0% to 5%.
19:18:13 <SamB_XP> % scale was % of pixels correct, right?
19:18:36 <misterbeebee> no. "risk" was a linear function of correct pixels and dna prefix size
19:18:47 <misterbeebee> % scale was never publicly announced during the contest
19:19:02 <misterbeebee> ("risk" is called "score" on marco's blog: http://marco-za.blogspot.com/2007/10/icfp-results.html)
19:19:02 <SamB_XP> oh, that
19:19:03 <lambdabot> Title: Marco's Blog: ICFP Results
19:19:04 <SamB_XP> right...
19:19:23 <SamB_XP> yeah, magical monotonic function all right...
19:25:43 <misterbeebee> I just plotted the top 50 scores and %s. I don't know how to do regression in excel, but the chart looks liek a gaussian with the peak at (risk, %) = (0,100)
19:26:18 <misterbeebee> pretty close to linear from risk = 55000 and better (smaller)
19:26:27 <misterbeebee> er, 550000
19:26:46 * FMota has an ... interesting question
19:27:05 <FMota> as in, he's interested in the answer, ofc
19:27:07 <FMota> so
19:27:30 <FMota> suppose, in lambda calculus, that I have a function F
19:27:45 <FMota> F f x y = x,  when x is a fixed-point of f
19:27:56 <FMota> F f x y = y, when x isn't a fixed-point of f
19:28:18 <FMota> ofc, it seems like F itself would have to be an extension of lambda calculus
19:28:31 <FMota> would that make it uncomputable?
19:28:49 <dolio> You need equality, no?
19:29:07 <FMota> good point.
19:29:36 <FMota> Yeah, I think you do.
19:29:53 <FMota> And equality isn't computable, so answer is no.
19:30:32 <FMota> lol.
19:30:38 <Cale> But can you prove that you need equality? Can you show that the existence of such an F allows you to construct an equality operator?
19:30:52 <FMota> well
19:30:54 <FMota> we can try
19:31:09 <FMota> \ x -> F x x false
19:31:12 <FMota> is close.
19:31:44 <FMota> er
19:31:45 <FMota> wait
19:31:48 <FMota> that's stupid :/
19:32:16 <FMota> eq a b = F a b false    is close
19:32:29 <FMota> but obviously not the same as equality.
19:33:09 <brad_> anyone know why i see lots of failure lines like this when i try to build hscurses:
19:33:12 <brad_> HSCurses/Curses.hs:1618:0:  invalid preprocessing directive #def
19:33:20 <Cale> hmm, given a term, can you construct a function whose fixed point must be that term?
19:33:22 <Korollary> FMota: (f x) may not terminate, but then F should return y.
19:33:26 <Cale> (yes :)
19:34:03 <Cale> er, actually hmm
19:34:04 <FMota> Korollary: yes. But can you prove that that causes a contradiction?
19:34:19 <Cale> yeah
19:34:34 <FMota> okay :) Go ahead.
19:35:31 <Korollary> If (f x) doesn't terminate, then F needs to discover this without running (f x), which is the halting problem.
19:36:14 <FMota> But we can't construct a Halting function from F, as far as I can tell.
19:36:40 <FMota> so, as long as F is an other-worldly function, it doesn't cause a contradiction
19:36:50 <FMota> ...maybe?
19:36:55 <Korollary> What is an other worldly function?
19:37:12 <FMota> Um. Probably a non-computable function.
19:37:26 <FMota> (Answer my own question, why don't I?)
19:38:16 <Korollary> If F isn't a decider, it doesn't satisfy your requirements.
19:38:31 <FMota> Really, though, we don't know if F needs the halting function.
19:38:37 <brad_> if anyone cares, extracting hscurses from haskell with --set-scripts-executable seemed to work
19:38:39 <FMota> a decider?
19:39:09 <geocalc> non computable function is a non sense
19:39:12 <Korollary> A decider terminates with the results you described
19:39:24 <Korollary> geocalc: there are such functions
19:39:43 <dolio> What would F yield if (f x) doesn't terminate?
19:39:54 <FMota> it would yield a fixed-point
19:39:58 <FMota> i.e.
19:40:05 <dolio> F f _|_ y = _|_ ?
19:40:16 <dolio> F f x y = y for x /= _|_?
19:40:20 <FMota> F (Y I _) x y = x
19:40:28 <Korollary> dolio: F (_|_) y = y
19:41:13 <dolio> Are we talking about a different F since my IRC client died from 10:29 to 10:33?
19:41:22 <FMota> lol, no
19:41:26 <mrd> A f x = F (\y. if f x halts and accepts, then y, else _|_) true false
19:42:04 <FMota> hmm mrd
19:42:12 <mrd> A is semi-decidable, therefore, so is F
19:42:58 <FMota> wait
19:43:54 <FMota> that only returns true if f x is true
19:44:03 <FMota> (or could be true)
19:44:14 <FMota> oh, wait
19:44:16 <FMota> no, nvm
19:44:33 <Cale> geocalc: Consider the function which takes an integer n and produces the largest number of steps an n-state turing machine can take before halting.
19:44:46 <mrd> A f x is the "acceptance" problem
19:44:50 <Cale> (starting with a blank tape)
19:44:54 <FMota> mrd: I may have explained F wrong, then
19:45:00 <mrd> for some encoding of "boolean" and "acceptance" in lambda calculus
19:45:38 <FMota> I x = F x x _
19:45:45 <FMota> ( = x)
19:45:54 <geocalc> Cale-> cause our pc are shit
19:46:02 <Cale> geocalc: hm?
19:46:10 <Cale> geocalc: No, it's not even computable in theory
19:46:28 <geocalc> lol
19:47:07 <Cale> It can be shown that this function actually grows faster than any computable function.
19:48:05 <Cale> If we call that function B, then for any computable function f, there is some n for which f(n) < B(n) (where that inequality is strict)
19:48:17 <Korollary> Cale: That sounds like the busy beaver function, but that actually works on a blank tape without doing anything.
19:48:36 <FMota> mrd:    A f x = F (\y. if f x halts and accepts, then y, else _|_) true false    isn't true
19:49:03 <FMota> (\ y . .... )   can never be the same as   true
19:49:15 <mrd> (\y.y) true can be
19:49:26 <FMota> yes
19:49:30 <Cale> Oh, right, a busy beaver should leave 1's on the tape :)
19:49:38 <FMota> but that's not what F does
19:49:45 <mrd> well then you explained it poorly
19:49:53 <geocalc> the fact that you have a function proove that it is computable, even if we don't know how
19:49:59 <FMota> mrd: Yes. :)
19:50:02 <Cale> geocalc: No, it doesn't.
19:50:19 <Cale> geocalc: Consider that the number of functions from the naturals to {0,1} is uncountable
19:50:27 <Cale> geocalc: But there are only countably many programs.
19:50:29 <SamB_XP> Cale: how do you know what the values are if it's not computable?
19:50:56 <Cale> SamB_XP: In some sense you don't have to know what the values are in order to have a function.
19:51:14 <Cale> That is, you don't have to be able to write them all down.
19:51:20 <geocalc> with numbers Cale
19:51:27 <SamB_XP> well, it seems like you ought to have some way of at least discovering some of them...?
19:51:29 <Tac-Tics2> Things exist that you can't point at.
19:51:39 <kaol> can Handles be closed for reading or writing separately? Like with C's shutdown function.
19:51:44 <Cale> There are more real numbers than there are definitions of real numbers.
19:52:05 <dolio> Thanks, axiom of choice!
19:52:12 <Cale> That's not the axiom of choice
19:52:13 <Tac-Tics2> Because a definition is a program and programs are countable
19:52:14 * mrd screams "real numbers aren't real!"
19:52:19 <Cale> You don't need the axiom of choice to show that
19:52:25 <Cale> Just infinity and powerset
19:52:26 <dolio> Ah. :)
19:52:29 <Tac-Tics2> Cale: I think he was talking about my pointing comment
19:52:34 <SamB_XP> I don't understand how you can have a particular non-computable function
19:52:41 <FMota> so, we don't really know much about F.
19:52:55 <kaol> looks like I'd better stick to using just Sockets
19:53:07 <Cale> SamB_XP: There are more definable functions than there are computable functions.
19:53:17 <sorear> real numbers are real, just extremely evil
19:53:24 <FMota> sorear: LOL
19:53:26 <SamB_XP> so what do you need to have in order to define a function?
19:53:29 <Cale> SamB_XP: That is, you can show that the function associates *some* number to each natural
19:53:36 <Cale> But it's impossible to say which.
19:53:42 <Cale> (at least for some naturals)
19:53:45 <sorear> FMota: stop trying to attach meaning to math, it's just a game played with symbols according to a dozen rules of inference
19:53:49 * mrd asks sorear to produce Omega
19:53:55 <Cale> SamB_XP: Given sets A and B
19:54:18 <Cale> A function f: A -> B is a subset of the Cartesian product A x B = {(a,b) : a in A, b in B} such that
19:54:22 <FMota> sorear: Is that directed at me? :o
19:54:32 <Cale> for each a in A, there is exactly one b in B for which (a,b) is in the function
19:54:39 <sorear> FMota: yes, hence 'FMota; '
19:54:49 <Cale> When (a,b) is in f, we write f(a) = b
19:54:50 <FMota> I fail to see how it applies.
19:54:57 <FMota> Incompatible types, I'd say.
19:55:27 <SamB_XP> so, would you need a decision procedure that would tell you whether or not (a, b) was in the function?
19:55:28 <Cale> FMota: are you talking to me?
19:55:39 <sorear> 19:51 < FMota> so, we don't really know much about F.
19:55:39 <FMota> Cale: no, to sorear
19:55:41 <Cale> SamB_XP: No, you just have to show that condition holds.
19:55:53 <SamB_XP> okay...
19:56:00 <sorear> 'know' is epistemology, I'm talking logic
19:56:13 <sorear> it's best for your sanity if you don't mingle the fields
19:56:15 <FMota> sorear: But it's true. Who says I'm trying to attach any "meaning" to it?
19:56:36 <FMota> (um, besides you)
19:56:48 <SamB_XP> Cale: so what are some strange ways to show that?
19:57:01 <Cale> Well, you can start talking about the cardinalities of sets.
19:57:22 <Cale> So for example, the set of all functions N -> {0,1}
19:57:33 <Cale> this is in bijection with the powerset of N
19:57:51 <Cale> and there's a theorem that says that the powerset of a set always has a larger cardinality
19:58:20 <SamB_XP> hmm?
19:58:30 <SamB_XP> what about the powerset of {}?
19:58:35 <Cale> That's {{}}
19:58:38 <Cale> which has one element
19:58:39 <SamB_XP> oh, true...
19:58:56 <Cale> This even holds for infinite cardnalities though
19:59:08 <SamB_XP> I don't doubt that ;-P
19:59:25 <Cale> But N is in bijection with the set of definitions of functions N -> {0,1}, since we have a finite alphabet and definitions must be finitely long
20:00:16 <Cale> Hence, no matter how those definitions end up being assigned to functions in N -> {0,1}, they will miss some
20:00:40 <FMota> :/
20:01:00 <FMota> Cale: I'm usually not comfortable with that idea.
20:01:08 <sorear> Welcome to the wonderful world of infinity!
20:01:19 <geocalc> lol
20:01:25 <FMota> You can apply the diagonalization argument to that, though, right?
20:01:45 <Cale> Yeah, that's how you prove the theorem that the powerset is larger than the set
20:01:46 <sorear> FMota: not only can you, but it's the standard proof of it
20:01:48 <FMota> I find it much more intuitive.
20:01:57 <Cale> (In general)
20:02:13 <Tac-Tics2> hmm
20:02:18 <Cale> Or yeah, diagonalisation directly can be applied
20:02:33 <Tac-Tics2> Cale: you say that card{definable functions} > card{computables}
20:02:45 <Tac-Tics2> so that would imply that definitions are not denumerable?
20:02:45 <Cale> Tac-Tics2: no, I just say they're a superset
20:02:49 <Tac-Tics2> ah
20:02:50 <Tac-Tics2> ok
20:02:58 <Cale> The cardinalities are the same
20:03:25 <FMota> But the ordinalities aren't? :o
20:03:37 <Cale> Well, they're not ordinals...
20:03:50 <Cale> One is a strict subset of the other.
20:04:06 <sorear> FMota: there are more functions than definable functions, and more of those than computable functions
20:04:28 <hpaste>  Tac-Tics pasted "Proof that some definable function g is not in the set of computable functions" at http://hpaste.org/3042
20:04:37 <FMota> okie dokie
20:04:45 <Tac-Tics2> Let me know if I messed up anywhere with that
20:04:59 <sorear> FMota: card(all) = bet-1, card(definable) = bet-0, card(computable) = bet-0
20:05:36 <FMota> ok
20:05:45 <FMota> I love #haskell :)
20:05:49 <sorear> Tac-Tics2: all functions in math are total
20:05:56 <sorear> so no need to say "if defined"
20:05:58 <Tac-Tics2> sorear, not partial functions
20:06:02 * SamB_XP tries to find x such that card(x) = ace-of-spades
20:06:15 <Tac-Tics2> sorear: it depends on your definition. In CS, partial functions are king
20:06:16 <Cale> Tac-Tics2: hmm, I don't think you should assume that thing about equality at the top
20:06:28 <Cale> Tac-Tics2: let it be redundant so that equality is computable
20:06:39 <sorear> also, "let" is a very scary word
20:06:45 <Cale> (that is, you just check if they're the same definition)
20:06:47 <Tac-Tics2> sorear: and if you're looking at the most general definition, a total function is a special case of a partial function
20:06:54 <SamB_XP> sorear: brings on BASIC flashbacks?
20:07:01 <sorear> nah.
20:07:10 <Tac-Tics2> sorear: yeah, that part is probably redundant
20:07:13 <sorear> just, I've seen "proofs" starting with "Let x_i be an enumeration of the reals"
20:07:24 <Tac-Tics2> yeah
20:07:25 <Cale> Tac-Tics2: Oh, also usually my functions are all total :)
20:07:33 <Tac-Tics2> hehe
20:07:56 <Tac-Tics2> @let hd (x:_) = x; h _ = undefined
20:07:58 <Cale> If I don't want a total function, I'll just restrict the domain :)
20:08:00 <Tac-Tics2> there, hd is not total
20:08:00 <SamB_XP> sorear: proofs by contradiction?
20:08:02 <lambdabot> Defined.
20:08:18 <sorear> no :(
20:08:23 <Cale> Tac-Tics2: Sure it is, if you include _|_ in its codomain :)
20:08:27 <Tac-Tics2> yeah
20:08:31 <SamB_XP> proofs by incorrectness?
20:08:39 <Tac-Tics2> functions are very precise, but at the same time, very vague
20:08:44 <Cale> (or you say more clearly what its domain should be)
20:08:46 <Tac-Tics2> everyone knows what a function is and what it does
20:08:56 <Tac-Tics2> but the details can vary more than most people realize, I think
20:09:11 <Cale> The parameter type of a function need not be its domain when you go to mathematically model the programming language
20:09:36 <Cale> Well, mathematicians usually take the definition I gave earlier, more or less.
20:10:02 <Tac-Tics2> Partial functions are nice sometimes, because you can't always answer important questions quickly
20:10:03 <Cale> There are some weirdos doing functional analysis that end up defining operators a little differently.
20:10:12 <Cale> (so that they might be partial)
20:10:12 <Tac-Tics2> and it's nicer to work with sets with simpler definitions
20:10:24 <Cale> But that's because the physicists paid them off ;)
20:10:28 <Tac-Tics2> heh
20:12:38 <Cale> It's really nice to have things like that the number of functions from A to B is the |B|^|A|
20:12:40 <Tac-Tics2> If you deal with functions of ratios of polynomials, for example, it's easier to say "partial functions from R->R" than to say "partial functions from R->R\{roots of whatever's in the demoninator of the function we're talking about}"
20:12:50 <Cale> hehe :)
20:13:02 <Tac-Tics2> (and if you're teaching math for nonCS majors, usually you leave off the partial part)
20:13:17 <geocalc> math restrict logic to numbers
20:13:24 <Cale> geocalc: not true
20:13:41 <Cale> geocalc: In fact, numbers are a tiny portion of what mathematics deals with.
20:13:41 <geocalc> ?
20:13:42 <Tac-Tics2> numbers restrict logic to faith
20:13:57 <ddarius> (formal) logic is a branch of math
20:14:00 <Cale> geocalc: There are all sorts of other nice structures to learn about.
20:14:06 <Tac-Tics2> I forgot how to multiply pairs of numbers over 6 a long long time ago
20:14:16 <SamB_XP> geocalc: mathematicians aren't known for their number-wrangling skills
20:14:33 <SamB_XP> Tac-Tics2: it's easy
20:14:44 <sorear> > 123 * 456
20:14:45 <Cale> groups, topological spaces, graphs, varieties, Banach spaces, rings (though that's *kind* of numbery)
20:14:46 <SamB_XP> you, uh, multiply each pair of digits
20:14:47 <lambdabot>  56088
20:14:48 <Tac-Tics2> Math is all about being clever with a very tight fixed set of rules
20:14:51 <SamB_XP> and stuff
20:15:04 <Tac-Tics2> Math is more like working with an abstract puzzle than working with numbers
20:15:21 <sorear> Math is a game played with symbols on a piece of paper.
20:15:21 <Cale> Metric spaces, monoids, sets
20:15:26 <Cale> all kinds of things
20:15:34 <sorear> categories!
20:15:41 <Cale> categories indeed!
20:15:44 <SamB_XP> now you're approaching nonsense!
20:15:59 <Tac-Tics2> I still don't get categories
20:16:01 <SamB_XP> and it's not even concrete nonsense!
20:16:06 <FMota> category theory isn't easy! :)
20:16:14 <Tac-Tics2> Categories are like talking about math without talking about anything
20:16:15 <Cale> Categories are the game you play with the games you've already playd.
20:16:29 <SamB_XP> I guess I need to learn more games
20:16:40 <SamB_XP> what games form categories?
20:16:52 <Tac-Tics2> A category of games to games?
20:16:52 <SamB_XP> Tic-Tac-Toe?
20:17:09 <Cale> Groups, Rings, Fields, Vector spaces (Linear algebra), Topological spaces, Metric spaces
20:17:15 <Cale> lots of others :)
20:17:18 <puusorsa> nonsense makes sense
20:17:27 <ddarius> Category theory is easy.
20:17:35 <Tac-Tics2> A rubick's cube is just a group... the goal is to find the values to multiply to get to the identity element!
20:17:42 <Cale> Tac-Tics2: yep :)
20:17:46 <puusorsa> WE AM THE AVERAGEST
20:17:51 <Cale> a monoid is like a puzzle which you can break
20:17:51 * SamB_XP foes to bed... he's already turned off the screen
20:18:08 <Tac-Tics2> that's all I ever think about when I play my rubicks cube when I'm at work
20:18:17 <Tac-Tics2> sadly, I've never solved the damn thing X-D
20:18:37 <ddarius> Tac-Tics2: Draw a Cayley graph.
20:18:42 <Cale> ddarius: hahahaha
20:18:49 <Tac-Tics2> I would, but that term isn't defined in scope
20:18:53 <Cale> ddarius: That would be magnificent :)
20:18:58 <Tac-Tics2> also, Cale laughed, and I don't think that's a good sign
20:19:12 <Cale> Tac-Tics2: the Cayley graph has a vertex for every element of the group
20:19:42 <Tac-Tics2> I'm sure I could figure out how to solve my rubick's cube in a snap
20:20:03 <Tac-Tics2> but I just don't know what state it's in, in terms of it's group
20:20:10 <Cale> Tac-Tics2: you fix a set of generators, and put an arc (g,h) when hk = g for some generator k
20:20:20 <Cale> er, gk = h, rather
20:20:40 <Cale> (doesn't really matter of course, but might as well have the arcs going in the right direction)
20:21:24 <Tac-Tics2> I have my book on group theory, but I've never opened it
20:21:29 <Cale> Given that the cube has 43252003274489856000 states, that would mean quite a lot of vertices and arcs to draw :)
20:21:37 <Tac-Tics2> I'll have haskell draw it
20:21:41 <Tac-Tics2> it will do it lazily
20:21:47 <Tac-Tics2> it will be reasonably fast
20:21:48 <Tac-Tics2> X-D
20:21:58 <Cale> Ideal Toy Company stated on the package of the original Rubik cube that there were more than three billion possible states the cube could attain. It's analogous to McDonald's proudly announcing that they've sold more than 120 hamburgers.
20:22:20 <Tac-Tics2> hehe, I read that
20:22:35 <Tac-Tics2> it's hard to imagine
20:22:39 <geocalc> lol
20:22:42 <Tac-Tics2> exponents really know how to catch you off guard
20:22:49 <Tac-Tics2> one sec there's 10 of them
20:22:58 <Tac-Tics2> the next second, there's so many you're dead
20:23:33 <Cale> > 2^27 * 3^14 * 5^3 * 7^2 * 11
20:23:41 <Tac-Tics2> it reminds me of movie where there's an alien or virus growing "exponentially".... yet each scene, there's only a handful more than the scene before it
20:23:45 <lambdabot>  43252003274489856000
20:23:45 <mrd> hmm, ever seen GroupExplorer?
20:24:42 <Tac-Tics2> negative
20:24:43 <platypus> Tac-Tics2: Thats not neccery inconistant with an Exponential growth patten.
20:24:52 <ddarius> It's all about the time constant
20:24:55 <mrd> @go group explorer
20:24:56 <sorear> Cale: Are all those permutations contained within the subgroup generated by non-hammer-involving moves?
20:24:58 <lambdabot> http://groupexplorer.sourceforge.net/
20:24:58 <lambdabot> Title: Group Explorer 2.1
20:25:01 <Tac-Tics2> I guess
20:25:29 <Cale> sorear: yes
20:25:52 <Cale> mrd: wow, no I hadn't
20:26:00 <Tac-Tics2> Really, I am fearful for our civilization. An attack on human kind by exponential functions could spell doom for us all.
20:26:05 <Cale> mrd: But it looks like exactly the sort of thing I'd be interested in :)
20:26:10 <mrd> indeed
20:26:18 <Tac-Tics2> Now like logarithms
20:26:36 <Tac-Tics2> Logarithms are the things you know no matter how slowly you walk, you'll always win.... they are the tortoises of math
20:28:34 <omniscientIdiot> sorear: if you break apart a rubik's cube and put it back together, there are six different classes of configurations you could put it in, each with 43 billion billion states, only one class of which contains the solved state :)
20:28:37 <ddarius> They beat a constant function.
20:29:06 <omniscientIdiot> Though I usually just try popping out the pieces, without a hammer :)
20:29:26 <Tac-Tics2> ddarius: I guess you could make the point that constant functions run.... they just don't have any rise X-D
20:29:27 <glguy> usually when people break them apart it is to put them back together solved
20:29:37 <Cale> > sum [1/n | n <- [1..100000]]
20:29:39 <lambdabot>  12.090146129863282
20:29:46 <omniscientIdiot> I did it to figure out how the mechanism worked.
20:29:58 <geocalc> Cale-> so group explorer in ghc soon ?
20:30:13 <Tac-Tics2> glguy: my roommate from college was the Rubick's cube master of our graduating class..... so I heard from all his dumb friends how "I had one of those once, I used to peel off the stickers to solve it"
20:30:21 <sorear> My rubik's cube spontaneously exploded, and I haven't been able to put it back together
20:30:23 <Tac-Tics2> they don't even make the effort to take it appart
20:30:35 <omniscientIdiot> glguy: but this means you can beset an unwary person with an unsolvable cube, if you hated him enough.
20:30:52 <Tac-Tics2> I've tried to pull apart mine at work
20:30:55 <sorear> it absorbed twisting energy and re-emitted it as stretching
20:30:58 <Tac-Tics2> but they make them tougher now
20:30:59 <sorear> grr jam :(
20:31:35 * omniscientIdiot has a cube, completely devoid of stickers from sheer overuse, sitting on his desk.
20:32:24 <ddarius> omniscientIdiot: Must be satisfying.
20:32:29 <omniscientIdiot> I twist it around randomly out of habit.
20:32:56 <omniscientIdiot> ddarius: It means I can't solve it anymore :(
20:33:08 <omniscientIdiot> ddarius: it's been months since I've solved one.
20:34:12 <ddarius> omniscientIdiot: Every state is an the identity!  Everytime you twist it you've solved it!
20:34:40 <omniscientIdiot> it's been months since I've had a *challenge* solving it :P
20:35:13 <Tac-Tics2> hehe, ddarius: it is!
20:35:36 <Tac-Tics2> each state can be thought of a basis state for it's own "cubespace"
20:35:40 * omniscientIdiot solves it, and again, and again, and again...
20:36:20 <Tac-Tics2> actually, it's probably much harder to solve a cube for a nonstandard basis
20:36:27 <Tac-Tics2> I wonder if they have contests for that'
20:38:17 <omniscientIdiot> Every single person you meet, when you mention the cube, mentions something about / jokes that they've peeled off the stickers.  You shouldn't do that!  You ruin the poor thing!
20:38:31 <omniscientIdiot> Pop the pieces
20:38:31 <FMota> lol
20:38:36 <FMota> I actually did that once.
20:38:41 <omniscientIdiot> stickers?
20:38:42 <FMota> (peel off the stickers.)
20:38:52 <FMota> was a long time ago, though
20:39:01 * omniscientIdiot chases FMota around with a wooden stake.
20:39:07 <FMota> lol
20:39:25 <omniscientIdiot> begone from this world, heathen!
20:39:51 <omniscientIdiot> *stab*
20:39:51 <Cale> geocalc: hehe
20:40:03 <Cale> mrd: Where do I get the Resources directory?
20:40:05 <Tac-Tics2> So does anyone know any dirty Monad jokes?
20:40:26 * FMota dies. :o
20:40:59 <FMota> Tac-Tics2: Sounds like it should be trivial to make some.
20:41:29 <FMota> There's the "side-effect free" one.
20:41:37 <omniscientMurder> dropped the '-er'
20:42:01 <FMota> not for me
20:42:26 <FMota> Are you talking about your name?
20:42:39 <omniscientMurder> yerp, was supposed to be "murderer"
20:42:55 <FMota> oh, right.
20:43:11 <FMota> confusing.
20:43:24 <omniMurderer> there
20:43:46 <Tac-Tics> So a PriestMonad and a RabiMonad walk into #haskell
20:44:14 * omniMurderer stabs the dead, yet still talking (undead?) FMota some more
20:46:20 <Cale> mrd: n/m found it :)
20:46:49 * bos curses darcs, yet again
20:50:01 * FMotaDEAD loves git.
20:50:11 <FMotaDEAD> (even though he is dead)
20:52:07 <Tac-Tics> so about them functions
20:52:13 * FMota is revived.
20:52:26 <omniMurderer> :O
20:53:08 * FMota repents for his past sins. Yada yada yada.
20:53:51 * omniMurderer forgives
20:54:03 * FMota thanks.
20:54:05 <omniMurderer> *stab*
20:54:11 <omniMurderer> (just for fun :)
20:54:33 <omniMurderer> so how *about* them functions, eh?
20:55:06 <Tac-Tics> What's your favorite haskell function?
20:55:18 * FMota dies again, goes to lambda heaven (for repenting the sin of relabeling the cube), but comes back since there are no side effects.
20:55:33 <Cale> I call foldr
20:56:04 <Tac-Tics> I think I call the eval function from String -> String
20:56:06 <omnIdiot> hmm, good question.  I'm partial to the no-nonsense 'nub'
20:56:27 <Tac-Tics> though I don't know of any implementations
20:56:28 <shachaf> \a -> a (\x y z -> x z (y z)) (\x _ -> x)
20:56:33 <ddarius> Either the best answer or the worst answer is fix depending on your views.
20:56:47 <shachaf> Or fix, indeed, maybe.
20:56:57 <omnIdiot> or indeed maybe
20:57:10 <ddarius> indeed :: x -> Maybe x
20:57:40 <shachaf> @ty or ?indeed
20:57:42 <lambdabot> (?indeed::[Bool]) => Bool
20:57:50 <shachaf> Doesn't work.
20:58:10 <omnIdiot> @vixen What's your favorite function, LB?
20:58:10 <lambdabot> i am just a fun girl!
20:59:03 <omnIdiot> 'Just', then
20:59:18 <Tac-Tics> @vixen do you know any dirty monad jokes?
20:59:18 <lambdabot> i think i know
20:59:19 <omnIdiot> and Just indeed :: x -> Maybe x
20:59:40 <Cale> fmap is pretty nice
20:59:45 <ramza3_> what are the requirements for the icfp contest, eg college student?
20:59:52 <ddarius> There are none.
21:00:04 <ramza3_> sweet
21:00:19 <Cale> Wolfram research should participate
21:00:34 <Cale> (or do they? :)
21:00:38 <ddarius> With Mathematica?
21:00:41 <Cale> yeah
21:01:20 <Tac-Tics> Actually, I like modifySTRef the best
21:01:24 <Tac-Tics> I change my vote
21:02:05 <ddarius> Clearly Tac-Tics loves mutation.
21:02:06 <Cale> atomically
21:02:31 <Tac-Tics> I'm sort of a mutant
21:02:51 <omnIdiot> tacTics = sort (mutant)
21:06:49 <Cale_> actually all the STM primitives are pretty cool
21:08:18 <Tac-Tics> STM is the monad that let's me feel safe at night
21:08:42 <Tac-Tics> err
21:08:43 <Tac-Tics> ST
21:08:46 <Tac-Tics> not STM
21:09:13 <Cale> http://research.microsoft.com/Users/simonpj/papers/stm/index.htm
21:09:14 <lambdabot> Title: Papers on transactional memory
21:09:19 <FMota> ap is amazing.
21:09:27 <FMota> (just because of the type(
21:09:29 <FMota> *)
21:09:36 <Cale> :t ap
21:09:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:09:51 <FMota> ap :: (a -> b -> c) -> (a -> b) -> a -> c
21:10:00 <Tac-Tics> @src ap
21:10:00 <lambdabot> ap = liftM2 id
21:10:51 <FMota> I think it's amazingness borders on obscurity, though.
21:10:51 <Tac-Tics> @src liftM2
21:10:51 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:12:17 <omnIdiot> the definition of (>>=) and return for ((->) r) are such that ap f g x reduces to f x (g x)
21:12:25 <omnIdiot> http://hpaste.org/2884
21:12:31 <FMota> ap (\ a b -> a ++ b ++ 'c') (a -> a ++ 'b') 'a'
21:12:36 <Cale> ap m1 m2 = liftM2 id m1 m2 = do { x1 <- m1; x2 <- m2; return (id x1 x2) } = do { x1 <- m1; x2 <- m2; return (x1 x2) }
21:12:41 <FMota> > ap (\ a b -> a ++ b ++ 'c') (a -> a ++ 'b') 'a'
21:12:42 <lambdabot>  Parse error
21:12:51 <FMota> > p (\ a b -> a ++ b ++ 'c') (\ a -> a ++ 'b') 'a'
21:12:52 <lambdabot>   Not in scope: `p'
21:12:56 <FMota> oops
21:12:57 <FMota> :/
21:13:05 <FMota> > ap (\ a b -> a ++ b ++ 'c') (\ a -> a ++ 'b') 'a'
21:13:05 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
21:13:12 <FMota> oops
21:13:26 <Cale> ap f g x = f x (g x)
21:13:31 <FMota> > ap (\ a b -> a ++ b ++ "c") (\ a -> a ++ "b") "a"
21:13:33 <lambdabot>  "aabc"
21:13:57 <FMota> that's weird..
21:14:06 <FMota> shouldn't it be  "aababc" ?
21:14:21 <FMota> er
21:14:24 <FMota> no, nvm
21:14:29 <FMota> "aabc" is right.
21:14:40 <FMota> it's postfix notation! :o
21:14:41 <Cale> > ap (\a b -> concat ["(f ",a," ",b,")"]) (\a -> concat ["(g ",a,")"]) "x"
21:14:42 <lambdabot>  "(f x (g x))"
21:14:44 <omnIdiot> (\ a b -> a ++ b ++ "c") "a" ((\ a -> a ++ "b") "a")
21:14:59 <FMota> But yeah, ap is amazing.
21:15:03 <FMota> CS depends on it.
21:15:13 <Cale> join!
21:15:25 <FMota> join?
21:15:33 <omnIdiot> > join (*) 3
21:15:35 <lambdabot>  9
21:15:39 <Cale> :t join
21:15:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:16:17 <FMota> all I need is ap and const
21:16:29 <Cale> ap and return
21:16:48 <FMota> > let id = ap const const in id "BLA"
21:16:49 <lambdabot>  "BLA"
21:16:59 <FMota> return = ap const const
21:17:05 <FMota> (...maybe)
21:17:13 <omnIdiot> return = const
21:17:20 <FMota> no, probabyl not.
21:17:22 <omnIdiot> @src (->) return
21:17:22 <lambdabot> return = const
21:17:26 <FMota> lol
21:17:27 <FMota> .
21:19:52 <omnIdiot> since id = ap const const, you're saying return = id.  I don't think there's an 'm' such that (return :: a -> m a) = (return a -> a), in Haskell, without newtype wrapping or something.
21:20:18 <FMota> > ap (++) show "> ap (++) show "
21:20:20 <lambdabot>  "> ap (++) show \"> ap (++) show \""
21:20:23 <FMota> :)
21:20:28 <FMota> shortest quine evar!
21:20:55 <FMota> omnIdiot: I was wrong, return != id.
21:21:17 <Tac-Tics> FMota, I think the shortest quine ever if the number of quines in languages for which the empty string compiles
21:21:19 <Tac-Tics> X-D
21:21:56 <FMota> well, I liked it.
21:22:34 <Tac-Tics> @which ap
21:22:34 <lambdabot> Unknown command, try @list
21:22:36 <Tac-Tics> @info ap
21:22:37 <lambdabot> (ap)
21:22:40 <Tac-Tics> @where ap
21:22:40 <lambdabot> I know nothing about ap.
21:22:50 <Tac-Tics> which module is App in? Monad?
21:22:50 <FMota> okay
21:22:56 <FMota> short quine in haskell
21:22:57 <omnIdiot> @index ap
21:22:57 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
21:22:57 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
21:23:26 <FMota> main = putStrLn $ ap (++) show "main = putStrLn $ ap (++) show "
21:24:10 <omnIdiot> too many spaces.  Not a one is needed :D
21:24:14 <Tac-Tics> Where is the Monad (->) defined?
21:24:20 <FMota> well, spaces don't count.
21:24:29 <FMota> but you're right :)
21:24:37 <omnIdiot> Tac-Tics: Control.Monad.Instances or Control.Monad.Reader
21:24:50 <Cale> "is a sentence fragment" is a sentence fragment
21:25:50 <Tac-Tics> "This sentence does not mention the sentence which contains it" is a self referential sentence.
21:26:19 <omnIdiot> "is silly" is silly
21:27:16 <Tac-Tics> "Quines are confusing as all hell" is a sentence who's truthfulness is undoubtable.
21:27:38 <omnIdiot> use/mention++
21:29:26 <omnIdiot> @bot?
21:29:26 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
21:29:42 <omnIdiot> why aren't you listening to my privmsgs!
21:29:49 <Tac-Tics> This sentence is the same length as the sentence, "This sentence is the same length as the sentence, "This sentence is the same length as the sentence, "..."""
21:30:03 <Tac-Tics> why is LB always so broken?
21:30:36 <sarehu> wait... why would a sentence end with a comma and a space?
21:30:49 <omnIdiot> Tac-Tics: cause she changes quickly and dons is busy?
21:30:58 <Tac-Tics> does dons maintain her?
21:31:05 <Syzygy-> sarehu: s/sentence/clause/g
21:31:07 <omnIdiot> last I knew
21:31:32 <omnIdiot> "This sentence" refers to the complete sentence in quotes.
21:31:46 <omnIdiot> It happens to be infinite in length, though. :)
21:31:51 <Syzygy-> omnIdiot: Heh.
21:31:55 <sarehu> Syzygy-: i'm just choosing the second doublequote to be a closing quote :)
21:32:02 <Korollary> LB is open source
21:32:08 <Tac-Tics> yeah, omni ^^
21:32:08 <Syzygy-> Right.
21:32:33 <Syzygy-> This sentence is the same length as the sentence ``This sentence is the same length as the sentence, ``This sentence is the same length as the sentence, ``
21:32:37 <Syzygy-> There we are.
21:32:55 <Syzygy-> Disambiguated for the people who will rather trigger a parse error than do an infinite parse. :)
21:33:21 * omnIdiot thinks their parsers should use better heuristics :)
21:33:24 <Syzygy-> @botsnack
21:33:24 <lambdabot> :)
21:33:31 <Tac-Tics> @botsnack
21:33:31 <lambdabot> :)
21:33:45 <omnIdiot> does she listen to your /msgs?
21:33:58 <Syzygy-> Occasionally, yeah.
21:34:11 <omnIdiot> er, right now?
21:34:23 <Syzygy-> She .. erm .. used to.
21:34:34 <Tac-Tics> i've never had a problem with her ignoring me
21:34:42 <Syzygy-> > 2+2
21:34:43 <lambdabot>  4
21:34:50 <omnIdiot> @visen Don't you love me anymore?
21:34:51 <lambdabot> who's to say?
21:34:56 <omnIdiot> :'(
21:35:21 <Syzygy-> @vixen Did you ever love omnIdiot?
21:35:21 <lambdabot> nevermind about that
21:35:38 <Tac-Tics> @vixen
21:35:38 <lambdabot> :)
21:35:41 <Tac-Tics> @vixen
21:35:41 <lambdabot> i hate it when i get stuck with chatting with a bot!
21:37:02 <omnIdiot> @vixen I know, it's the most embarrasing thing.
21:37:02 <lambdabot> what type of car do you drive?
21:37:19 <omnIdiot> (lol)
21:37:34 <omnIdiot> (she wants to chat)
21:37:51 <omnIdiot> @vixen A dodge shadow, you?
21:37:52 <lambdabot> what about me?
21:38:37 <Tac-Tics>  @vixen reminds me of the infamous barbie doll that said "Math is hard"
21:38:45 <Tac-Tics> @vixen
21:38:45 <lambdabot> )
21:38:55 <Tac-Tics> close paren?
21:38:57 <omnIdiot> Aagh! No eyeballs!
21:39:15 <Tac-Tics> @vixen
21:39:16 <lambdabot> you seem upset...
21:39:56 <Tac-Tics> Code!
21:40:04 <Tac-Tics> I want to code
21:40:07 <Tac-Tics> but I should be sleeping
21:41:25 <omnIdiot> I probably won't be coding for a while.  Right now I'm taking a break from my newly-purchased Metroid Prime 2.  :D
21:41:42 <Tac-Tics> heh
21:41:47 <Tac-Tics> playing with your wii eh?
21:41:52 <omnIdiot> 2
21:42:01 <Korollary> Get a programming job and your interest in coding shall vanish.
21:42:08 <omnIdiot> don't make me get the stake
21:42:31 <sorear> omnIdiot: pick up nethack and you'll never want to be productive again!
21:43:12 <omnIdiot> Productivity? What's that?
21:43:18 <allbery_b> nethack.  bleagh
21:43:33 <allbery_b> originally it was playable.  these days?  I've switched to dungeon crawl
21:43:42 <Tac-Tics> instance Monad Wii where
21:43:42 <Tac-Tics>     return x = waveWiimote x
21:43:42 <Tac-Tics>     (Wii p) >>= f = whackInTheFace f p
21:44:26 <FMota> fun!
21:44:28 <allbery_b> Wii needs a MonadWii typeclass, though, for those of us who use e.g. DarwiinRemote :)
21:44:28 <sjanssen> Tac-Tics: fail = const whackInTheFace
21:44:41 <Tac-Tics> heh
21:45:01 <sorear> blech, monads
21:45:02 <omnIdiot> mention not the heretic 'fail', for it be not of God.
21:45:23 <Korollary> What the heck? Functional Jamba Juice? http://www.jambafunctionals.com/
21:45:25 <lambdabot> Title: Jamba Juice
21:45:41 <sjanssen> sorear: wha?  heresy!
21:45:51 <allbery_b> what, is it point-free?
21:45:56 <Tac-Tics> omnidiot: ahaha, where'd you here that?
21:47:04 <omnIdiot> #haskell, haskell.org, THE ENTIRE INTERNETS, probably
21:47:27 <Tac-Tics> The Internets? I love those!
21:47:38 <FMota> ogm, does the lambda juice contain lambdas?
21:47:48 <Tac-Tics> someone needs to add more to the haskell.org humor page
21:49:25 <Tac-Tics> My favorite from that page was the one about Dr. Seus and Parsers
21:49:30 <Tac-Tics> I will never forget what a parser is now
21:49:38 <Tac-Tics> http://www.willamette.edu/~fruehr/haskell/seuss.html
21:49:41 <lambdabot> Title: Dr. Seuss on Parser Monads
21:50:05 * omnIdiot tries from memory: "A parser for things is a function from strings to lists of pair of things and strings"
21:50:34 <Tac-Tics> hehe, yeah
21:51:10 <Tac-Tics> If only such childish whimsicality could be found for explaining monads
21:51:35 <omnIdiot> I redditted that link, actually, and the only comment I got was links to some WWII racist propoganda by (what at least looks like) Dr. Seuss.  :(
21:51:58 <FMota> :/
21:52:10 <OceanSpray> :|
21:52:58 * omnIdiot checks, hehe, "comment deleted" http://programming.reddit.com/info/t6pd/comments
21:52:59 <lambdabot> Title: Dr. Seuss on Parser Monads (reddit.com)
21:53:09 <Tac-Tics> sadly, monads are so general, the Monad saying would be "A monad can do; what the f**k it wants to;  when it satisfies the identities; and associativity too"
21:53:41 <omnIdiot> I have a hard time believing Seuss would use the word fuck so freely.
21:54:03 <Tac-Tics> might I remind you of Google's notion that he may have been a nazi?
21:54:33 <Tac-Tics> (at least by the Google search results X-D
21:59:10 <Tac-Tics> so does anyone understand all the variations of factorial on this page?
21:59:10 <Tac-Tics> http://www.willamette.edu/~fruehr/haskell/code/evolution.hs
22:02:23 <Tac-Tics> LB __is__ ignoring people
22:04:12 <sjanssen> hmm, the factorial page needs an associated types version now :)
22:04:23 <omnIdiot> Strange that type-level peanos precede term-level peanos.
22:05:10 <Korollary> @quote
22:05:10 <lambdabot> <erg0t> says: @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
22:05:38 <gour> huh, just read that "Perl is a fine tool for many applications" :-/
22:05:53 <omnIdiot> isn't it?
22:06:12 <Tac-Tics> it is?
22:06:18 <gour> welll, i didn't expect it winning icfp contests
22:06:36 <Tac-Tics> Am I a heathen for thinking earlier today that Haskell looks like a cousin of Perl?
22:06:57 <gour> from whihc side?
22:07:19 <Tac-Tics> Semantically, they must be astranged or not get along well, but syntactically, it's all just swearing and obfuscation when done right ;-)
22:07:22 * omnIdiot hasn't used Perl pretty much at all.  From my superficial understanding, it seems as good as any language of its kind.
22:07:25 <araujo> gour, hi there
22:07:33 <araujo> gour, did it win the icfp contest?
22:07:34 <gour> araujo: hi
22:07:36 <Tac-Tics> In fact, @pl is a LB command that turns good Haskell INTO perl
22:07:39 <platypus> Tac-Tics: There is a lot of cross pollination between the communities nature.
22:07:40 * allbery_b is still a heavy perl user
22:07:40 <Tac-Tics> thus, the name @pl
22:07:46 <gour> araujo: see http://marco-za.blogspot.com/2007/10/icfp-results.html
22:07:47 <lambdabot> Title: Marco's Blog: ICFP Results
22:07:54 <platypus> s/nature/recently/
22:07:54 <araujo> thanks
22:08:04 <allbery_b> @remember Tac-Tics In fact, @pl is a LB command that turns good Haskell INTO perl
22:08:04 <lambdabot> Done.
22:08:15 <Tac-Tics> @pl f x y z = f (map x y >> z)
22:08:15 <lambdabot> f = fix ((. (((>>) .) . map)) . (.) . (.))
22:08:22 <omnIdiot> my eyes!
22:08:27 <Tac-Tics> hehe
22:08:50 <allbery_b> looks more like EvilLisp to me
22:08:52 <Tac-Tics> platypus: what did you mean by that comment? The cross pollination?
22:09:39 <platypus> Tac-Tics: Quite alot of perl people have gotten interested in haskell via the pugs project and to some extent visa versa.
22:09:59 <Tac-Tics> ah, indeed
22:10:13 <Tac-Tics> I've not touch a line of perl in my life, and that's for a reason
22:10:24 <shapr> Yarr!
22:10:30 <omnIdiot> @Yarr!
22:10:31 <lambdabot> Maybe you meant: arr yarr
22:10:41 <omnIdiot> à² _à² 
22:10:49 <platypus> For what reson?
22:11:42 <Tac-Tics> Perl is just ugly to look at, and it is syntax is more complex than what it needs to be
22:11:45 <Tac-Tics> well
22:11:53 <Tac-Tics> "needs to be" should be "than I require"
22:12:12 <hpaste>  sjanssen pasted "factorial with type families.  Pretty :)" at http://hpaste.org/3044
22:12:48 <Tac-Tics> what's a type family?
22:13:43 <Tac-Tics> I probably shouldn't ask that
22:13:49 <Tac-Tics> I should probably go to bed instead >___>
22:14:15 <omnIdiot> who needs sleep when there's knowledge to acquire?
22:14:21 <Tac-Tics> good point
22:14:25 <Tac-Tics> Haskell > PHP
22:14:30 <Tac-Tics> and sleep just brings PHP to me faster
22:14:55 <Tac-Tics> It probably isn't helping that I'm reading Paul Graham either. My job is such a joke
22:15:24 <sjanssen> Tac-Tics: type families let us write functions on types
22:15:36 <Tac-Tics> on?
22:15:54 <sjanssen> take a few types as input, yield a few types as output
22:16:07 <Tac-Tics> sounds like a template in C++
22:16:08 <sjanssen> yield a *single* type as output
22:16:17 <sjanssen> Tac-Tics: yeah, quite similar
22:16:34 <sjanssen> Tac-Tics: our syntax is way better, though
22:16:38 <Tac-Tics> but then again, Parametric types sounded a lot like templates too
22:16:49 <Tac-Tics> what's the difference?
22:17:10 <omnIdiot> like Either takes Int and String and produces Either Int String, but can produce something more interesting?
22:17:57 <sjanssen> yeah, kinda
22:18:09 <sjanssen> Either applied to Int and String is just 'Either Int String'
22:18:24 <Tac-Tics> Can you use it to generalize tuples?
22:18:39 <Tac-Tics> so, for instance, you can write a zipTuples function or something like that?
22:18:41 <omnIdiot> whereas (:+:) applied to Zero and n is Zero
22:18:44 <sjanssen> but Factorial Zero results in (Succ Zero)
22:18:47 <omnIdiot> er, n
22:18:53 <Tac-Tics> which works just like zip, zip2, zip3, ...
22:19:44 <sjanssen> Tac-Tics: Haskell tuples can't really be generalized
22:19:53 <omnIdiot> I think I could understand it on the type level, just functions transforming atoms.  I wouldn't know how, or if, this would look on the term level.
22:20:04 <sjanssen> without TH or something
22:20:59 <Tac-Tics> So Factorial would take a Peano type and return a *different* Peano type?
22:21:29 <Tac-Tics> so Factorial Zero and Factorial (Suc Zero) are distinct types?
22:21:30 <sjanssen> yep
22:21:31 <omnIdiot> it takes a type and produces a different type.
22:21:45 <Tac-Tics> what does that let you do more concisely that the current type system can't do?
22:21:52 <sjanssen> Tac-Tics: same type, because 0! = 1! = 1
22:22:04 <Tac-Tics> sjanssen: details aside, of course =-P
22:22:05 <sjanssen> Tac-Tics: Haskell '98 can't do this at all
22:22:42 <omnIdiot> it's interesting so far.  This is the first I've been exposed.
22:22:53 <omnIdiot> How long have type families been around?
22:22:59 <sjanssen> not long
22:23:00 <Tac-Tics> I don't quite get the point, but still neat
22:23:24 <Syzygy-> But Factorial (Suc Zero) and Factorial (Suc (Suc Zero) ) are different types?
22:23:42 <Tac-Tics> With bottom only members, it would seem
22:23:45 <sjanssen> the implementation in GHC has only been around for a couple monts or so, and it's still preliminary
22:23:48 * omnIdiot wonders if reading the Monad.Reader's "Instant insanity" article could help tac-Tics.
22:24:24 <shachaf> And the equivalent on hpaste?
22:24:35 <sjanssen> Syzygy-: yes, they're different types
22:25:01 <sjanssen> they normalize to (Succ Zero) and (Succ (Succ Zero)), which are clearly different
22:25:34 <Tac-Tics> I wish there was a way to search pdf by the document's page
22:25:40 <Tac-Tics> not the page offset
22:26:16 <omnIdiot> hmm, I think we need more sophisticated kinds to group and help manage these types
22:26:22 * omnIdiot mumbles something about kind-classes.
22:27:13 <omnIdiot> who wants kind families? :)
22:27:40 <allbery_b> kind lambdas?
22:28:15 <sjanssen> Tac-Tics: yeah, Succ a and Zero are only occupied by _|_ -- the point is the *type*, not the value
22:28:23 * omnIdiot proposes unkind lambdas
22:30:19 <sjanssen> omnIdiot: I agree, programming with type families is like programming in a dynamically typed language
22:30:56 * omnIdiot was definitely not being serious
22:30:57 <Tac-Tics> Can you really call it a program though if it doesn't compile to something used at runtime?
22:31:02 <Tac-Tics> It's more like a preprogram
22:31:22 <omnIdiot> who cares when the code runs?  It still produces a result.
22:31:29 <omnIdiot> compile-time or runtime.
22:31:37 <sjanssen> Tac-Tics: are Perl programs not programs?
22:31:41 <sorear> Tac-Tics: C++ templates are dependant abstraction, which generalizes both parametric types AND type functions, but is too general for nice implementation (type inference is impossible without the <> garbage)
22:32:03 <sjanssen> GHC is both a compiler and an interpreter :)
22:32:10 <Tac-Tics> Perl programs are executable eye-sores =-P
22:32:34 <Tac-Tics> I never really understood C++ template programming either
22:33:13 <Tac-Tics> Is there any way for a Type Family to interface in an interesting way with the runtime?
22:34:13 <sjanssen> well, they're gone by runtime
22:34:28 <omnIdiot> I think I heard someone mention that they subsume MPTC w/ fundeps.
22:34:40 <sjanssen> but they can certainly be useful for more conventional programs
22:34:44 <Tac-Tics> yeah
22:35:30 <sorear> MPTC/FD interacts in very interesting ways with type groundness and overlapping
22:35:35 <sjanssen> Tac-Tics: imagine an array type that's parametric on the size
22:35:40 <sorear> TF flat-out rejects overlapping
22:35:47 <ttfh> what are Type Families?
22:35:56 <sjanssen> Tac-Tics: we could use the
22:35:59 <sorear> pure, distilled insanity
22:36:24 <Tac-Tics> sjanssen, so a homogeneous tuple?
22:36:26 <sjanssen> Tac-Tics: ... :+: machinery to express the length of the concatenation of two arrays
22:36:37 <Tac-Tics> If it would do a range of widths, it would be interesting I think
22:36:43 <hpaste>  setuid_w00t pasted "(no title)" at http://hpaste.org/3045
22:36:43 <sjanssen> Tac-Tics: yeah, pretty much
22:36:45 <Tac-Tics> ah
22:36:47 <setuid_w00t> I'm trying to define a simple recursive data type and make it an instance of the Show class.  Can someone explain what is wrong with my show function?  I realize it's not very useful.  I'm just trying to figure out where the error is coming from.
22:36:47 <Tac-Tics> actually
22:36:55 <Tac-Tics> I think I saw a video on something like that once a long time ago
22:37:00 <Tac-Tics> before I learned the Ways of HS
22:37:29 <Tac-Tics> they were talking about trying to create more powerful types to prevent errors at runtime
22:37:49 <Tac-Tics> like the Type of nonempty lists, I think was their introductory example
22:38:32 <sorear> setuid_w00t: you need a context on that instance
22:39:39 <setuid_w00t> sorear: Can you explain what that means
22:39:40 <allbery_b> a needs to be an instance of Show
22:39:46 <setuid_w00t> ahh
22:39:50 <allbery_b> because you invoke show on it
22:39:54 <setuid_w00t> right
22:39:57 <omnIdiot> setuid_w00t: the "show vf" implies "Show a =>"
22:40:04 <setuid_w00t> I sort of figure that
22:40:21 <setuid_w00t> How do I declare that a is showable?
22:40:28 <shachaf> instance Show a => ...
22:41:03 <allbery_b> you cannot (usefully) do it as part of the BiMap type, btw
22:41:07 <sjanssen> Tac-Tics: yeah, type families are machinery we can use to build these better types
22:41:15 <setuid_w00t> allbery_b: Tjat
22:41:21 <setuid_w00t> That's what I was trying to do
22:41:27 <Tac-Tics> I'm still skeptical, but this article is interesting
22:41:35 <setuid_w00t> data BiMap a b = Nil | (Show a) => Pair (a, b) (BiMap a b)
22:41:38 <setuid_w00t> something like that
22:42:42 <allbery_b> the syntax would be data Show a => BiMap a b = ... -- but this does not do anything useful
22:42:53 <hpaste>  (anonymous) annotated "(no title)" with "the context goes on the instance" at http://hpaste.org/3045#a1
22:43:51 <setuid_w00t> thanks anonymous
22:44:53 <omnIdiot> a response to that would necessarily remove anonymity
22:45:00 <omnIdiot> but you're welcome :)
22:46:15 <Tac-Tics> Would type families also be able to create situations where your correctly written program doesn't compile?
22:46:38 <sjanssen> the program isn't correctly written if it doesn't compile
22:46:58 <omnIdiot> though aparently the implementation is still pretty buggy :)
22:47:13 <sjanssen> omnIdiot: yes, quite
22:47:23 <Tac-Tics> sjansslen, I mean the evaluation of your compilation is _|_
22:47:34 <Tac-Tics> that your types do some calculations and get stuck in a loop
22:47:37 <Tac-Tics> and you never get error messages
22:47:52 <omnIdiot> divergent compilation is fun!
22:47:52 <allbery_b> hello halting problem?
22:48:02 <dolio> Not without -fallow-undecidable-instances.
22:48:08 <dolio> Hopefully.
22:48:19 <sjanssen> Tac-Tics: they're guaranteed to terminate, unless you turn on undecidable instances
22:48:57 <Tac-Tics> they should call -fallow-undecidable-instances -fallow-turing-completeness ;-)
22:49:50 <Tac-Tics> I think this article lost me at the functional dependencies part
22:50:04 <omnIdiot> type level instant insanity?
22:50:17 <setuid_w00t> Ok, so I had "instance Show a => Show (BiMap a b) where" previously.  How can I change this to allow me to call show on the "b" type as well?
22:50:28 <Tac-Tics> omnidiot: yes
22:50:31 <omnIdiot> (Show a, Show b) =>
22:50:42 <Tac-Tics> I don't understand FDs at all
22:50:55 <Tac-Tics> all I know is people don't like them for some reason
22:51:22 <Tac-Tics> and they allow you to say that one parameter of a typeclass determines another or something? I dunno what that means though
22:51:23 <sjanssen> Tac-Tics: nobody understands FDs, that is the problem :)
22:51:30 <Tac-Tics> oh good
22:51:39 <omnIdiot> I've only a vague intuition, but instance MonadState s m | m -> s made something click.
22:51:43 <setuid_w00t> omnIdiot: that's the one.  Thanks again
22:52:05 <omnIdiot> s/instance/class/
22:52:07 <Tac-Tics> why are they hard to understand?
22:52:49 <omnIdiot> they have to do with the behavior of typeclass resolution during type inference (I hope I didn't munge that too much :)
22:54:14 <sorear> 'context reduction' is the technical term
22:54:57 <Tac-Tics> so do they just resolve ambiguities or something?
22:55:49 <quicksilver> yes
22:56:11 <quicksilver> from a practical perspective, they enable some types to be inferred automatically that would otherwise need an annotation
22:56:49 <quicksilver> so speaking loosely they don't change the semantics
22:56:52 <Tac-Tics> so they reduce the number of instances required for the program?
22:56:58 <quicksilver> they just enable you to get by with fewer annotations
22:57:07 <Tac-Tics> "instances" as in instantiating classes?
22:57:14 <quicksilver> actualy they reduce the number of instances 'permitted' not 'required'
22:57:18 <Tac-Tics> ah
22:57:21 <sjanssen> Tac-Tics: they resolve ambiguities sooner
22:57:25 <quicksilver> an 'instance' is a type which is a member a class
22:57:27 <omnIdiot> 'MonadState Foo m => m Bar' could be either 'State Foo Bar' or 'Monad m2 => StateT Foo m2 Bar', the point being that the whole monad ('State Foo' or 'StateT Foo m2') determine exactly ONE s type, Foo.
22:57:44 <quicksilver> Tac-Tics: the classic example is Container a b | a -> b
22:57:56 <quicksilver> Tac-Tics: means that the container type 'determines' the element type
22:57:57 <omnIdiot> instance Container [a] a
22:58:04 <quicksilver> Tac-Tics: suppose a is [c]
22:58:12 <quicksilver> Tac-Tics: then b is "obviously" c
22:58:20 <Tac-Tics> ah
22:58:30 <Tac-Tics> can typeclasses only work for types of kind *?
22:58:35 <quicksilver> no
22:58:41 <quicksilver> there are higher-kinded classes
22:58:43 <quicksilver> like Monad
22:58:44 <omnIdiot> Arrows are (* -> * -> *)
22:58:49 <Tac-Tics> ah yeah
22:59:02 <omnIdiot> @src MonadTrans
22:59:02 <lambdabot> Source not found. It can only be attributed to human error.
22:59:59 <Tac-Tics> Why can't you use something like Container []? because it doesn't expose the inner type?
23:00:38 <sorear> Tac-Tics: ByteString.
23:00:49 <sorear> I think I understand FDs... took me half a year, though
23:00:57 <Tac-Tics> ByteString?
23:01:17 <omnIdiot> is there an MPTC/FD in the ByteString libs?
23:01:38 <quicksilver> omnIdiot: there are no TCs at all in bytestring, AFAICR
23:01:56 <quicksilver> omnIdiot: but it *could* be an instance of 'ListLike' or 'Container' or some such
23:02:32 <quicksilver> sorear: do FDs also allow you to have methods which don't visibly depend on b?
23:03:01 <Tac-Tics> sorear's keeping me in suspense
23:03:29 <aleator_> Hey, I need a really fast algorithm for dealing a deck of 40 cards to two players? Any pointers?
23:03:51 <quicksilver> Tac-Tics: ByteString is a 'container' for Word8 or Char
23:04:03 <sorear> aleator_: You don't need an algorithm, you need a dealing machine
23:04:04 <Tac-Tics> aleator_: IORefs, STRefs, and TVar... there some pointers
23:04:06 <quicksilver> Tac-Tics: but it's not like [], the contained type isn't trivially visible
23:04:23 <Tac-Tics> ah, I see
23:04:32 <aleator_> sorear: Virtual players :P
23:04:53 <sorear> aleator_: define "dealing" and "deck"
23:05:02 <sorear> aleator_: 1 shoe, non-replacement?
23:05:27 <sorear> aleator_: i'd shuffle the deck, then use splitAt to pull off the initial hands
23:05:35 <Tac-Tics> CS gets so used to the word type
23:05:45 <Tac-Tics> Mathematically, what is a good definition for a "type"
23:05:58 <Tac-Tics> clearly, instance Container type ;-)
23:06:03 <sorear> aleator_: but unless you're doing 10,000,000 simultaneous games on a TI-83, this isn't perf critical.  do whatever uses the least LOC
23:06:12 <quicksilver> Tac-Tics: a type is a set of values
23:06:34 <quicksilver> Tac-Tics: traditionally types are disjoint, so all values are in precisely one type
23:06:35 <aleator_> sorear: Actually, it is. I'm currently using shuffling, and it is 35% of total execution time :)
23:06:54 <Tac-Tics> is it anything more fancy? Like how our little debate with "functions" vs "partial functions" let us to discover earlier
23:07:11 <sorear> aleator_: yikes!
23:07:16 <quicksilver> Tac-Tics: the basic mathematical definition is just set
23:07:21 <Tac-Tics> yeah
23:07:27 <sorear> aleator_: are you using !!?
23:07:46 <Tac-Tics> With type families, yeah, just a set. but without them, they'd be disjoint
23:08:05 <platypus> Is the real 0 diffrent to the integer 0?
23:08:25 <Tac-Tics> depends which = you ask
23:08:32 <Tac-Tics> is = different from ==?
23:09:06 <Syzygy-> :t (=)
23:09:08 <aleator_> sorear: Nope. I'm using a tree to shuffle it. Ie. google for perfect shuffle in haskell and you get the exact algorithm
23:09:08 <lambdabot> parse error on input `='
23:09:09 <quicksilver> = is declarative
23:09:10 <Syzygy-> :t (==)
23:09:12 <lambdabot> forall a. (Eq a) => a -> a -> Bool
23:09:15 <Tac-Tics> in haskell it is
23:09:16 <quicksilver> it declares equations
23:09:18 <Syzygy-> So yes, they are different.
23:09:29 <quicksilver> in haskell the real 0 is different from the integer 0
23:09:37 <quicksilver> you could imagine a semantics where they weren't
23:09:43 <aleator_> sorear: The point is that I'm doing this for about 40 million times.
23:09:49 <Tac-Tics> hmm
23:09:56 <sorear> aleator_: uck
23:09:58 <quicksilver> there is more then one way to handle subtyping
23:10:06 <quicksilver> you can imagine overlapping types
23:10:12 <quicksilver> you can also imagine disjoint types with injections
23:10:17 <aleator_> sorear: Indeed.
23:10:18 <Tac-Tics> Would it be possible to create a Monad for probablistic sequencing?
23:10:57 <quicksilver> probably. depends what that means
23:11:07 <Tac-Tics> where m >>= n >>= f has an x% chance of evaluating as m >>= f?
23:11:13 <aleator_> In the beginning I can use array of used cards and pick random numbers until I hit unused one.. After half the cards that starts to slow down..
23:11:36 <Tac-Tics> or rather, m >>= f has an x% chance of evaluating as m?
23:16:05 <quicksilver> Tac-Tics: and what does it do with a (100-x)% chance?
23:16:12 <quicksilver> Tac-Tics: just skip m and move on?
23:16:46 <Tac-Tics> yeah, it would just randomly drop functions from the chain
23:16:58 <quicksilver> Tac-Tics: sounds plausible, ye
23:17:03 <Tac-Tics> I'm trying it out
23:17:09 <Tac-Tics> I always wanted to figure out a monad on my own
23:17:30 <quicksilver> you have to think about 'internal structure'
23:17:36 <setuid_w00t> Is a .hi file a compiled haskell module?  I was trying to locate the source for Data.Map and I found imports/Data/Map.hi and it is a binary file.
23:17:39 <quicksilver> if m is "really" of the form (l >> p)
23:17:49 <quicksilver> then what are the chances for l and p
23:17:53 <quicksilver> or both, or neither
23:18:00 <quicksilver> setuid_w00t: it's just an interface
23:18:09 <quicksilver> setuid_w00t: standard binary installs don't install the source, sadly
23:18:12 * omnIdiot feels something wiggly inside when he arrives at the "Mu" type in that "Evolution of a Haskell Programmer" file
23:18:23 <omnIdiot> It's type-level fix!
23:18:43 <Tac-Tics> something tells me that my Probablistic monad wouldn't obey the right identity
23:18:53 <quicksilver> a type level fix and a type level lambda all rolled into one..
23:19:06 <Tac-Tics> maybe
23:19:08 <Tac-Tics> no
23:19:09 <Tac-Tics> wait
23:19:22 <Tac-Tics> m >>= return has an x% chance of becoming m anyway
23:19:42 <Tac-Tics> so even if it isn't a monad all the time, there's a certain probability that it will uphold the laws?
23:19:43 <Tac-Tics> heh
23:21:13 <misterbeebee> Tac-Tics: which direction are you investigating? do you have a behavior in mind that you want to model, or are you "exploring" what happens with some hypothetical definitons?
23:21:22 <omnIdiot> ref'tial. trans'cy. demands that (m >>= return) is the same *always*, so I imagine you'd do something like a list of possible results and their probabilities.  (>>=) would combine another with the results in a repeatable way.
23:21:25 <misterbeebee> you might or might not want to read through this blog: http://www.randomhacks.net/articles/2007/02/21/randomly-sampled-distributions
23:21:27 <lambdabot> Title: Refactoring probability distributions, part 2: Random sampling, http://tinyurl.com/2ytmlt
23:21:44 <Tac-Tics> misterbeebee: I want to model a probablistic machine which "drops" functions from a chain
23:22:35 <misterbeebee> so every function you bind gets either applied or skipped?
23:22:47 <omnIdiot> you might incorporate StateT StdGen into it somehow
23:22:56 <Tac-Tics> so return =<< (/5) =<< (*5) << return would sometimes multiply by 5, sometimes divide by 5, and sometimes return the identity
23:23:05 <Tac-Tics> omnidiot, I was going to
23:23:08 <misterbeebee> unless your functions are a->a, you might have some type problems...."skipping" would need the same type as any function you bind in
23:23:29 <Tac-Tics> ah yeah
23:23:39 <Tac-Tics> also, I don't think the identity would hold on the one side....
23:24:05 <Tac-Tics> maybe
23:24:06 <Tac-Tics> I dunno
23:24:11 <Tac-Tics> I'll see if I can get it to compile
23:24:14 <Tac-Tics> and then do the math
23:24:28 <misterbeebee> the compilation is the math :) the compiler does it for you :)
23:24:39 <Tac-Tics> not the monad laws ;-)
23:24:46 <misterbeebee> ah yes.
23:25:39 <misterbeebee> speaking of "maybe"... If you started with Maybe, you could merge in the probability computations to say that a function has an x% chance of resulting in Nothing instead of a result....
23:25:57 <misterbeebee> then you could replace the nothing result wth id...
23:26:01 <misterbeebee> (just speculating)
23:26:04 <Tac-Tics> yeah
23:26:38 <Tac-Tics> I'm wondering where the probability function fits in
23:26:45 <Tac-Tics> really, only one monad needs to have it
23:26:54 <Tac-Tics> they should all share the same random function
23:27:09 <Tac-Tics> so that probably isn't necessary in the structure?
23:27:32 <quicksilver> I think you can do what you want, but your combining operation isn't >>=
23:27:46 <quicksilver> you have a higher level combiner (possibly parametric in % chance)
23:27:57 <quicksilver> which "compiles down" to >>= in a suitable monad
23:28:05 <quicksilver> which collects the probabilities for you
23:28:06 <Tac-Tics> sadness
23:28:18 <quicksilver> and a 'run' primitive which actually evaluates
23:30:32 <misterbeebee> your new proposed monad doesn't really have a dependence on randomness... it has a dependency on a stream of values [True, False, False....] whether that stream comes form rand or input or a constant shouldn't matter within your functons...
23:30:54 <Tac-Tics> yeah
23:30:57 <misterbeebee> ...but you'll need to write in monad transformer style to merge your monad with a random number generator monad
23:31:05 <misterbeebee> (i think)
23:31:28 <Tac-Tics> the problem is that >>= works for ma and mb
23:31:45 <Tac-Tics> and I can't really "cross the gap" when an instruction gets dropped
23:31:48 <Tac-Tics> unless I model a state monad
23:33:30 <Tac-Tics> type families would be really nice for modeling quantum circuits
23:33:36 <Tac-Tics> now that I think about it
23:33:45 <misterbeebee> when you say ma and mb, you mean this?:   bind:: m a -> ( a -> m b ) -> m b      .... but each application of bind might result in either mb, or be dropped and result in ma
23:34:17 <Tac-Tics> yeah
23:34:19 <Tac-Tics> exactly
23:34:26 <misterbeebee> so you'd need a larger type to handle both:   data :: AorD a b = Applied b | Dropped a
23:34:36 <misterbeebee> but if you want to allow all functions, that type gets crazy
23:34:41 <Tac-Tics> yeah
23:34:43 <Tac-Tics> it's not a monad
23:34:45 <Tac-Tics> it's just a dream
23:35:14 <misterbeebee> it's perl.
23:37:09 <misterbeebee> if you constrain yourself to one type, though, it can work fine. It's not obvious to me what the application is, but it would work if you only ever tried to push a->a functions into your slacker monad.
23:37:38 <Tac-Tics> it could always pass undefined for slacked values
23:37:46 <Tac-Tics> or I could do the maybe thing as you suggested
23:38:57 <misterbeebee> if you want to randomly abort the computation, and never be able recover after a failure, you can push stuff to _|_, but if you want the dropped to be id, not undefined, then I don't know what would work.
23:42:03 <ketil> Morning!
23:42:38 <ketil> Anybody use getCPUTime?  It counts ...something, but it doesn't seem to be (pico)seconds.
23:43:01 <omnIdiot> @index
23:43:01 <ketil> At least, I get weird but consistent numbers when I subtract and divide by the provided resolution.
23:43:01 <lambdabot> bzzt
23:43:06 <omnIdiot> @index getCPUTime
23:43:07 <lambdabot> System.CPUTime
23:43:17 <omnIdiot> @docs System.CPUTime
23:43:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-CPUTime.html
23:43:18 <nornagon> could be clock cycles maybe?
23:43:44 <ketil> Precision is a bit low, too - I get either zero or four million units - 4Âµs, if you believe the ads.
23:44:11 <ketil> I'm running it against wall clock now, so I'll see what the factor is.
23:44:56 <omnIdiot> > let n = flip replicate () in length $ (\xs ys -> [() | _<-xs, _<-ys]) (n 3) (n 5)
23:44:58 <lambdabot>  15
23:45:21 <ketil> The unit seems to be 1/100s
23:45:44 * omnIdiot multiplies numbers
23:46:21 <omnIdiot> > let n = flip replicate (); x * y = length $ (\xs ys -> [() | _<-xs, _<-ys]) (n x) (n y) in 7 * 3
23:46:23 <lambdabot>  21
23:46:32 <ketil> Ah, I misinterpreted the 'precision' variable.
23:46:42 * ketil iz zt00p1D
23:47:55 <geocalc> > ((256^3)^4)^64
23:47:57 <lambdabot>  3375152182143856118491117448868264047748245269061354378998711510846650037846...
23:50:28 <ketil> Anyway: I'm doing automatic benchmarking with quickcheck - perhaps I should wrap it up as a 'quicktime' library? :-)
23:50:38 <omnIdiot> oh gawd
23:50:48 <ketil> Next will be prizes for anybody who improves the running time of my programs...
23:51:50 <Tac-Tics> @hoogle IO StdGen
23:51:51 <lambdabot> Random.getStdGen :: IO StdGen
23:51:51 <lambdabot> Random.newStdGen :: IO StdGen
23:53:21 <Tac-Tics> Stack Overflow?
23:53:22 <Tac-Tics> uh oh
23:53:32 <omnIdiot> newStdGen = do { g <- getStdGen ; let (g1, g2) = split g ; setStdGen g1 ; return g2 }
23:54:39 <omnIdiot> @let x * y = length ((\xs ys -> [()|_<-xs,_<-ys]) (replicate x ()) (replicate y ()))
23:54:40 <lambdabot> <local>:7:13:     Ambiguous occurrence `*'     It could refer to either `*', ...
23:54:47 <omnIdiot> darn :)
23:55:32 <Tac-Tics> ah
23:55:37 <Tac-Tics> darned letrecs
23:59:59 <hpaste>  Tac-Tics pasted "Lame Prob Monad" at http://hpaste.org/3046
