00:00:02 <pjd> lekro: the paper is great
00:00:20 <badkins> Korollary: speechless? :)
00:00:44 <Korollary> badkins: if you know of Autrijus and Audrey, asking about Jonathan is again weird.
00:00:46 <pjd> unfortunately, the "Write an applicative functor tutorial" craze hasn't quite taken off yet
00:01:12 <badkins> Korollary: I didn't recall the guy's name since Audrey was the famous one
00:01:14 <lekro> pjd: the paper seems to be gone
00:01:20 <Pseudonym> badkins: "Community" is not the same as "job adverts on monster.com".
00:01:29 <Pseudonym> I've never gotten a job from monster.com, even in C++.
00:01:38 <lekro> I'm asking google right now if there's another place to find it
00:01:42 <roconnor> applicative functors are obvious?
00:01:53 <Pseudonym> People who post job adverts there don't want people who are smart enough to use Haskell. :-)
00:02:04 <roconnor> ap :: A (a -> b) -> A a -> A b
00:02:19 <pjd> lekro: oh dear!
00:02:41 <pjd> well, Googling for the name turns up many other versions
00:03:22 <sjanssen> > (\xs -> zip3 (inits xs) xs (drop 1 $ tails xs)) [1 .. 4]
00:03:24 <lambdabot>  [([],1,[2,3,4]),([1],2,[3,4]),([1,2],3,[4]),([1,2,3],4,[])]
00:07:02 <pjd> > zip3 <$> inits <*> id <*> tail.tails $ [1..4]
00:07:04 <lambdabot>  [([],1,[2,3,4]),([1],2,[3,4]),([1,2],3,[4]),([1,2,3],4,[])]
00:07:08 <lekro> pjd: I just remembered that I have online access to the Journal of Functional Programming. that's even easier :)
00:07:42 <newsham> what's a "free monad"?
00:09:23 <opqdonut> ?src nubBy
00:09:23 <lambdabot> nubBy eq []             =  []
00:09:23 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:10:25 <pjd> newsham: http://en.wikipedia.org/wiki/Free_object might or might not be relevant or helpful
00:10:36 <lekro> what branch of mathematics do I have to learn more about to understand things like "Technically, a strong lax monoidal functor." Is it all category theory?
00:11:24 <pjd> that sounds like category theory, yes
00:12:49 <hpaste>  sjanssen pasted "lekro's function" at http://hpaste.org/3197
00:14:17 <hpaste>  sjanssen annotated "lekro's function" with "oops" at http://hpaste.org/3197#a1
00:17:11 <lekro> sjanssen: cool
00:17:35 <sjanssen> @pl (\x xs ys -> (f x : xs) : map (x:) ys)
00:17:35 <lambdabot> ap (flip . (((.) . (:)) .) . (:) . f) (map . (:))
00:17:56 <lekro> now I know by testing what it does, I'm still trying to grasp the why
00:18:18 <lekro> that's a weird point-free form
00:20:09 <lekro> I don't think I can use this for the assignment. Actually, the assignment was supposed to be written in Java but I want to demonstrate that Haskell is as good or better suited for this task (searching, A* etc).
00:22:12 <lekro> I mean the point-free form would be useless. the paramorphism version could be just the thing I need, provided I fully understand it.
00:22:35 <sjanssen> do you understand foldr?
00:23:02 <lekro> I think so
00:23:48 <lekro> it basically switches the : constructor with a given function and the [] at the end with the init argument
00:24:03 <lekro> and it works with infinite lists
00:24:26 <sjanssen> in 'foldr f', f gets the head and the accumulator (the transformed tail).  In 'para f', f gets the head, the tail, and the accumulator
00:25:26 <lekro> I see
00:27:02 <lekro> I think I got it
00:28:41 <lekro> is "paramorphism" a term from functional programming or is it from category theory, too?
00:29:14 <sjanssen> lekro: category theory, apparently
00:29:33 <sior|sleep> yeah, that's what wikipedia told me
00:30:59 <lekro> well, the references in wikipedia to paramorphism are all computer science related
00:31:31 <sjanssen> lekro: paramorphism is related to catamorphism, the list variant of which we call foldr
00:32:54 <ac> foldr must iterate to the end of the list, so if possible foldl is better to use, right?
00:33:11 <oerjan> ac: opposite
00:33:13 <sjanssen> false
00:33:30 <sjanssen> ac: foldr is the one with 'early exit'
00:34:02 <sjanssen> > foldr (||) False $ repeat True
00:34:04 <lambdabot>  True
00:34:11 <sjanssen> > foldl (||) False $ repeat True
00:34:15 <lambdabot> Terminated
00:34:25 <pjd> ac: the l and r in foldr/foldr are about their computational structure, not their order of evaluation
00:35:35 <sior|sleep> ac: right and left refer to their associativity
00:35:50 <sjanssen> lekro: http://citeseer.ist.psu.edu/meijer91functional.html has lots to say about the application of cata and para to FP
00:35:53 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
00:39:14 <ac> does "foldl foo bar xs" == "foldl foo bar (reverse xs)"?
00:39:28 <ac> (as long as the lists are finite)
00:39:47 <pjd> nah
00:39:58 <oerjan> with a flip foo perhaps
00:40:16 <oerjan> no, wait
00:40:23 <sarehu> foldr foo bar xs = foldl (flip foo) bar (reverse xs)
00:40:31 <newsham> ac: did you mean one is foldl and the other foldr?
00:40:31 <roconnor> 4^3903
00:40:35 <roconnor> > 4^3903
00:40:37 <lambdabot>  6920638318406398496710519232041580406680328127633078870148717405507236860495...
00:40:53 <ac> newsham: no, I meant to type "foldl" twice
00:40:58 <roconnor> > 3903*(logBase 10 4)
00:40:59 <lambdabot>  2349.8401461530366
00:41:06 <roconnor> big number
00:41:23 <oerjan> foldl1 foo xs = foldl1 (flip foo) (reverse xs) i think
00:41:57 <oerjan> but the initial value would be at the wrong end
00:42:03 <ac> that brings up another question for me: what's the difference between foldl and foldl1?
00:42:29 <wolverian> the type
00:42:46 <oerjan> @check \foo xs -> foldl1 (foo::Bool->Bool->Bool) xs == foldl1 (flip foo) (reverse xs)
00:42:48 <lambdabot>  Exception: Prelude.foldl1: empty list
00:43:02 <oerjan> @check \foo xs -> not (null xs) ==> foldl1 (foo::Bool->Bool->Bool) xs == foldl1 (flip foo) (reverse xs)
00:43:03 <lambdabot>  Falsifiable, after 14 tests: <Bool -> Bool -> Bool>, [False,False,False,True...
00:43:05 <pjd> by the way, you can visualize the grouping foldl and foldr as ((((0 1) 2) 3) ...) and (1 (2 (3 (...))))
00:43:20 <oerjan> darn
00:43:33 <ac> > foldl (/) 1 (reverse [1,2,3,4])
00:43:34 <lambdabot>  4.1666666666666664e-2
00:43:38 <ac> > foldl (/) 1 ([1,2,3,4])
00:43:39 <lambdabot>  4.1666666666666664e-2
00:43:52 <ac> > foldl (flip (/)) 1 ([1,2,3,4])
00:43:53 <lambdabot>  2.6666666666666665
00:44:01 <lekro> > foldl (flip (:)) [] ([1,2,3])
00:44:03 <lambdabot>  [3,2,1]
00:44:05 <lekro> > foldl (flip (:)) [] (reverse [1,2,3])
00:44:07 <lambdabot>  [1,2,3]
00:44:44 <ac> > foldl (flip (:)) [] [1,2,3]
00:44:45 <lambdabot>  [3,2,1]
00:44:48 <newsham> > foldl (\x y -> x*x+y) 3 [1,2,3]
00:44:49 <lambdabot>  10407
00:44:51 <newsham> > foldl (\x y -> x*x+y) 3 [3,2,1]
00:44:52 <lambdabot>  21317
00:44:59 <ac> I don't think you need to flip it
00:45:07 <lekro> try it without flip
00:45:07 <pjd> so, evaluating from the outside inwards, foldl "starts" at the end of the list, and foldr starts at the beginning
00:45:08 <newsham> > foldl (\y x -> x*x+y) 3 [3,2,1]
00:45:09 <lambdabot>  17
00:45:41 <newsham> qed.
00:46:36 <ac> they're all three different
00:47:12 <newsham> yes.  therefore they're not the same.
00:47:23 <matthew-_> yep, that last one doesn't square the accumulator
00:48:18 <newsham> ?type foldl
00:48:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:48:30 <newsham> also note you cant always flip the funcand get the same type
00:48:47 <newsham> (so far funcs shown are all a->a->a)
00:51:02 <newsham> > foldl (\x y -> ord y + x*x) 3 "test"
00:51:03 <lambdabot>  1324162373
00:51:12 <newsham> > foldl (flip (\x y -> ord y + x*x)) 3 "test"
00:51:13 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
00:51:25 <newsham> > foldl (\x y -> ord y + x*x) 3 "tset"
00:51:26 <lambdabot>  990182893
00:52:29 <lekro> cu and thank you all for your help
00:54:33 <EvilTerran> @src foldl1
00:54:33 <lambdabot> foldl1 f (x:xs) = foldl f x xs
00:54:33 <lambdabot> foldl1 _ []     = undefined
00:54:58 <newsham> > foldl1 (+) [1,2,3]
00:55:00 <lambdabot>  6
00:55:31 <newsham> no need to supply the operator's identity value
00:55:46 <EvilTerran> although, in that case, it's better to use foldl' (+) 0, because that's the same for everything newsham's one does, and has the added bonus of being total
00:55:48 <ac> yep. foldl1 is similar to reduce in Scheme
00:55:56 <newsham> partial functions evil
00:56:21 <EvilTerran> > foldl1 (+) []
00:56:24 <lambdabot>  Exception: Prelude.foldl1: empty list
00:56:25 <chris00_297247> see my naked ex on www.nackte-ex.de.gg   <my revange!
00:56:26 <ac> what's "partial"?
00:56:26 <EvilTerran> > foldl (+) 0 []
00:56:28 <lambdabot>  0
00:57:48 <pjd> ac: "not defined for all parameters"
00:57:58 <newsham> does "catch" catch those cases?  (http://www.cs.york.ac.uk/fp/darcs/catch/catch.htm)
00:57:59 <lambdabot> Title: Catch: A User Manual
00:58:16 <pjd> ac: the empty list, in foldl1's case
00:58:43 <newsham> ac: a partial function doesnt work for all possible inputs (given the allowable type)
00:58:56 <newsham> a total function does.
00:59:44 <newsham> you can use "Maybe" or other types of error reporting to make a total function that models a partial one
01:00:44 <newsham> (ie. safeHead :: [a] -> Maybe a)
01:04:31 <roconnor> at least when the domain of the function is decidable
01:24:19 <EvilTerran> mandelbrotPointConvergesTo :: Complex Double -> Complex Double -- (kinda) undecidable domain
01:33:47 <quicksilver> am I the only person who finds mod's behaviour with negative numbers stupid
01:34:03 <matthew-_> try rem then
01:34:12 <quicksilver> > (-4) `mod` 16
01:34:16 <lambdabot>  12
01:34:16 <quicksilver> > (-4) `rem` 16
01:34:18 <lambdabot>  -4
01:34:19 <sarehu> > ((-2) `mod` 3, 2 `mod` (-3), (-2) `mod` (-3))
01:34:21 <lambdabot>  (1,-1,-2)
01:34:37 <quicksilver> that's odd, that's not what my ghci did
01:34:53 <quicksilver> doh
01:34:59 <quicksilver> bracketing error :P
01:35:03 * quicksilver slaps himself
01:35:06 <dmwit> heh
01:35:11 * matthew-_ helps out
01:35:11 <quicksilver> mod does do what I expect, if I put the negative number in bracets
01:35:43 <quicksilver> I wouldn't expect 'unary minus' to have lower precedence that `mod` though
01:35:46 <sieni> > -4 `rem` 16
01:35:47 <lambdabot>  -4
01:35:51 <sieni> oops
01:35:54 <sieni> > -4 `mod` 16
01:35:55 <lambdabot>  -4
01:35:59 <quicksilver> sieni: yeah, that's what I did
01:36:07 <sieni> quicksilver: yeah I know, that has bitten me too :-)
01:36:09 <quicksilver> I always expect unary minus to bind tight
01:36:18 <matthew-_> you should have used the other minus - the unicode negative symbol
01:37:03 <osfameron> yeah, haskell's unary minus is surprisingly loose
01:37:29 <sieni> <insert a goatse related comment here>
01:37:42 <quicksilver> <no please don't?>
01:38:06 <matthew-_> <that's not a question>
01:38:35 <gvdm> <let the conversational asides continue>
01:38:45 <hpaste>  nornagon pasted "Are these numbers really Gaussian?" at http://hpaste.org/3200
01:39:52 <EvilTerran> <insert the usual grumbles about unary minus>
01:40:12 <sieni> http://yro.slashdot.org/comments.pl?sid=161505&threshold=1&commentsort=0&mode=thread&cid=13506813
01:40:15 <lambdabot> Title: Secretaries Sacked After Flamewar at Work, http://tinyurl.com/ysd8wf
01:40:17 <matthew-_> <read the irc conversation>
01:40:28 <nornagon> any statisticians care to comment on the above hpaste? :)
01:40:36 <yitz> @go haskellwiki safe head
01:40:39 <lambdabot> http://www.haskell.org/haskellwiki/Non-empty_list
01:40:39 <lambdabot> Title: Non-empty list - HaskellWiki
01:42:23 <dmwit> nornagon: Do you have a reason to suspect they are not Gaussian?
01:42:40 <opqdonut> how do i drop every other element from a list?
01:43:10 <opqdonut> (idiomatically=
01:43:29 <dmwit> I don't think there's a good idiom.
01:43:38 <nornagon> dmwit: well, my present ideas about whether or not they are is "They Kinda Look Like It"
01:43:43 <dmwit> You could use the "chunks" thing that everybody is constantly writing.
01:43:45 * dmwit hunts for chunks
01:43:52 <opqdonut> well, i'll go for mutually recursive i guess
01:44:13 <nornagon> s/ideas/idea/
01:44:16 <EvilTerran> i've written evens and odds for such a purpose before
01:44:19 <opqdonut> ehmm, even one recursive func works, of course
01:44:44 <EvilTerran> evens [] = []; evens (x:xs) = x : odds xs; odds [] = []; odds (_:xs) = evens xs
01:44:50 <dmwit> > filter (even . fst) . zipWith [1..] $ ["a","b","c"]
01:44:58 <quicksilver> > map head . iterate (drop 2) $ [1..]
01:44:58 <lambdabot>  Couldn't match expected type `a -> b -> c'
01:45:00 <dmwit> > filter (even . fst) . zip [1..] $ ["a","b","c"]
01:45:03 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
01:45:04 <lambdabot>  [(2,"b")]
01:45:31 <dmwit> > map snd . filter (even . fst) . zip [1..] $ ['a'..'m']
01:45:34 <lambdabot>  "bdfhjl"
01:46:30 <quicksilver> erm
01:46:34 <quicksilver> what is wrong with mine?
01:46:43 <quicksilver> > map head . iterate (drop 2) $ [1..]
01:46:49 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
01:46:57 <quicksilver> ah, the errors weren't lining up :)
01:46:58 <glguy> quicksilver: only for streams?
01:47:07 <opqdonut> nice one
01:47:12 <quicksilver> well takeWhile (not null) then
01:47:27 <quicksilver> using indices is horrible (no offence dmwit :P)
01:47:33 <yitz> nornagon: IANAS, but I don't think so. But here is a quote from the source code of the random module in Python:
01:47:50 <dmwit> quicksilver: I know.
01:49:37 <quicksilver> by "what is wrong with mine" I didn't mean "why do the denizens of #haskell not like it", FWIW. I meant "why did lambdabot give an error?" :)
01:49:43 <quicksilver> since it worked in my ghci
01:49:48 <quicksilver> but I see they just didn't line up right
01:49:57 <yitz> When x and y are two variables from [0, 1), uniformly
01:49:57 <yitz> distributed, then
01:49:58 <yitz>   
01:49:58 <yitz> cos(2*pi*x)*sqrt(-2*log(1-y))
01:49:58 <yitz> sin(2*pi*x)*sqrt(-2*log(1-y))
01:49:58 <yitz>   
01:50:00 <yitz> are two *independent* variables with normal distribution
01:50:02 <yitz> (Lambert Meertens)
01:50:12 <nornagon> yitz: i need it fast, with as few math calls as possible
01:50:27 <nornagon> i'm thinking about an algorithm that will be running on the nintendo ds
01:50:39 <nornagon> which is a handheld gaming system with no floating point
01:50:49 <nornagon> it has fixed point maths functions, but they are sloooow
01:51:50 <yitz> Again from random.py: "This is slightly faster than the normalvariate() function." (where they define a gaussian distr. in the usual way)
01:52:16 <yitz> If you really want it to be Gaussian, I doubt you'll find anything better.
01:52:36 <dmwit> You can do better if you're willing to lose a bit of Gaussian-ness.
01:53:06 <nornagon> dmwit: yeah, i'm not too interested in statistical accuracy
01:53:12 <nornagon> i just want something fast and Close Enough
01:53:18 <dmwit> For example, if you have a random-int generator, just averaging a few such rands will give you something close-to-Gaussian.
01:53:25 <dmwit> (where a few = 5 or 6)
01:53:48 <nornagon> well, the pasted code was that for few = 2
01:54:08 <dmwit> nornagon: Aha.  For a few = 2, what you will get is the "triangle" distribution.
01:54:23 <dmwit> Not particularly Gaussian, but not a terrible approximation, either.
01:55:03 <opqdonut> ygh, what was the syntax for cost-centre annotations again?
01:55:12 <nornagon> dmwit: ah, so it is a triangle distribution
01:55:24 <nornagon> it looks much better for few = 4
01:55:26 <dmwit> nornagon: Yes, it is the convolution of the uniform distribution with itself.
01:55:27 <nornagon> thanks :)
01:55:39 <dmwit> Each time you increase "a few", you convolve it with the uniform distribution again.
01:57:40 <nornagon> two is really the maximum i can do due to the fact that my random numbers are in [0,MAX_INT32]
01:58:07 <dmwit> nornagon: So divide *before* you add. ;-)
01:58:16 <nornagon> that's a good point >.>
01:59:45 <nornagon> thanks :)
01:59:50 <dmwit> g'luck
02:03:17 <hpaste>  blarz pasted "xmonad build error" at http://hpaste.org/3201
02:03:35 <blarz> oh... wrong channel announce :)
02:06:05 <roconnor> we could upload the haskell workshop videos to this new geektorrent thingy
02:08:16 <exDM69> roconnor: what are the haskell workshop videos?
02:08:33 <exDM69> something other than the Simon Peyton-Jones videos?
02:08:49 <exDM69> is there any newbie-friendly material there?
02:09:47 <roconnor> http://www.ludd.ltu.se/~pj/hw2007/HaskellWorkshop.html
02:09:49 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
02:10:53 <roconnor> not sure if that is newbie oriented
02:11:04 * roconnor needs to restart X
02:12:38 <exDM69> the modular synthesizer sounds intresting
02:20:40 <dmwit> ?keal+ a planck curve is simply a logarithmic curve multiplied by a bell curve
02:20:40 <lambdabot> my proof show math is broken right now
02:20:47 <dmwit> shucks
02:21:19 <yitz> @let evens = concatMap (drop 1) . takeWhile (not.null) . evalState (sequence $ repeat $ State (splitAt 2))
02:21:20 <lambdabot> <local>:4:0:     Multiple declarations of `L.evens'     Declared at: <local>:...
02:21:31 <yitz> @undefine
02:21:33 <lambdabot> Undefined.
02:21:41 <yitz> @let evens = concatMap (drop 1) . takeWhile (not.null) . evalState (sequence $ repeat $ State (splitAt 2))
02:21:43 <lambdabot> Defined.
02:21:52 <yitz> > evens [1..40]
02:21:54 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]
02:24:06 <roconnor> @keal
02:24:07 <lambdabot> Keal was so happy with T, coded in basic so run on anything, and does lot
02:25:00 <pjd> yitz: nice
02:25:13 <dmwit> I wish I felt comfortable pasting the whispers I've been getting.
02:25:17 <dmwit> They're comedic gold.
02:25:38 <roconnor> dmwit: you hear voices?
02:25:55 <dmwit> That's one way of putting it. =)
02:29:57 <roconnor> swiert: I heard your paper on the theory of patches wasn't accepted anywhere :(
02:38:24 <swiert> roconnor: Yep.
02:38:40 <swiert> In hind sight, this may have been a good thing.
02:38:46 <pjd> philistines!
02:38:47 <swiert> I'm not entirely pleased with it as it stands.
02:39:38 <swiert> We do want to resubmit somewhere, but we're not entirely sure what to do with it.
02:40:01 <roconnor> swiert: It looked nice to me.
02:40:05 <gour> swiert: for darcs?
02:40:17 <roconnor> I figured it would make a good reference for a smart editor
02:40:19 <swiert> gour: for version control in general.
02:40:34 <roconnor> I pointed vincenz to it for their collabrative editor project
02:40:39 <gour> swiert: ahh, what do you think about darcs-2 ?
02:41:37 <swiert> roconnor: I think we need to tone down the intro and discuss more related work. I'm also not entirely happy with formulating everything in terms of set manipulations.
02:41:53 <swiert> It'd be nicer if there was some more abstract, logical characterization of what's going on.
02:42:07 <swiert> gour: I haven't looked into darcs-2 too much to be honest.
02:42:37 <swiert> gour: But I'm not terribly fond of their notion of commuting patches.
02:43:00 <ttfh> exDM69: modular synths are fun, I have played with spiralsynth, usually you end up with a sound completely different from what you intended
02:43:17 <gour> swiert: hmm, droundy is pushing some conflictor's code into unstable...let's see
02:43:30 <swiert> gour: Oh - I'm definitely interested.
02:43:33 <ttfh> exDM69: modular synths are fun, I have played with spiralsynth, usually you end up with a sound completely different from what you intended
02:44:05 <swiert> jdagit is writing something up for the next TMR about darcs - that's certainly interesting.
02:44:08 <exDM69> ttfh: I have written a modular synth with x86 assembly
02:44:17 <gour> swiert: Heffalump is doing some testing...i hope something will come out so i don't need to move to hg for next project
02:45:21 <gour> swiert: i read few days ago a hg book, but think darcs (by fixing exponential growth) is still very cool rcs
02:45:34 <exDM69> ttfh: it was about 1.5 kilobytes in size. it had 2 tone generators, fm/am/ring modulation, ADSR, IIR hi/lo/bandpass/etc filter, a mixer and a delay loop echo
02:45:51 <swiert> gour: hg?
02:45:52 <exDM69> it was a very fun project, I wish I find the time to finish the project
02:45:58 <gour> swiert: mercurial
02:46:32 <swiert> ah. yes.
02:46:36 <gour> swiert: are you aware of some newer talk about patch algebra than fosdem2006 listed at http://wiki.darcs.net/DarcsWiki/Talks ?
02:46:37 <lambdabot> Title: Talks - DarcsWiki
02:48:36 <swiert> gour: No thanks for the link.
02:49:16 <swiert> gour: There's some punctuation missing in that sentence.
02:50:00 <gour> which one?
02:51:30 <swiert> I meant "No. Thanks for the link" instead of not thanking you.
02:52:11 <gour> ok,i got it
03:15:36 <quicksilver> swiert: I'm pleased to hear you don't trust commuting patches
03:15:43 <quicksilver> swiert: I think it's a totally flawed idea :)
03:16:06 <quicksilver> swiert: you can't tell if two patches commute unless you have a complete, decidable, operational semantics for the language...
03:16:28 <quicksilver> s/operational/denotational/ I mean
03:18:15 <doserj> but you can tell when they do not commute
03:18:17 <pjd> amen to that
03:19:05 <pjd> (...to swiert/quicksilver)
03:25:49 <SamB_XP> quicksilver: sometimes you don't care THAT much
03:26:22 <SamB_XP> what does it mean for two patches to commute anyway?
03:39:10 <swiert> quicksilver: I'm not opposed to the idea of two patches commuting - that's not too strange.
03:39:45 <swiert> quicksilver: I just don't like the way darcs proposes that commuting patches p . q results in q' . p' somehow.
03:40:17 <swiert> i.e. forcing patches to commute, even if this may change their behaviour.
03:42:04 <roconnor> swiert: the patches form a groupoid right?
03:42:15 <swiert> roconnor: Yes - I think so.
03:42:30 <roconnor> that is the reason for the primes?
03:42:42 <swiert> Oh - no this is darcs patches I'm talking about.
03:43:07 <swiert> IIRC, in darcs you can always commute a patch through other patches.
03:43:21 <roconnor> what does commuting mean in a groupoid?
03:44:15 <swiert> That's my objection to how darcs does things.
03:45:06 <swiert> If you have patches p : A -> B and q : B -> C, it tries to find patches p' : A -> B' and q' : B' -> C.
03:45:46 <swiert> But it underspecifies what p' and q' should actually do, besides the obvious condition that q . p = q' . p'
03:46:28 <roconnor> right, there could be lots of q' and p' that work.
03:46:37 <swiert> Exactly - but which one do you choose?
03:46:52 <swiert> It's a bit like factoring numbers.
03:46:55 <roconnor> we should just throw away the context and make a group
03:47:04 <roconnor> then we can have commuting elementes :)
03:47:39 <roconnor> Is the theory of groupoids well studies.  I've only encountered it once in homotopy
03:48:04 <roconnor> s/studies/studied/
03:48:18 <roconnor> s/./?/
03:48:31 <swiert> If you have the product of p * q, how do you factor out a q' and p'? It only works if p and q are relatively prime themselves. This (very roughly) corresponds to the condition we have on commuting patches: two patches only commute if they are entirely independent.
03:48:49 <swiert> I only know Martin Hofmann's groupoid model of type theory.
03:49:06 <swiert> And I've seen the term pop up in some category theory books...
03:49:17 <roconnor> swiert: curves in a manifold form a groupoid, with the endpoints being the context
03:49:32 <roconnor> and multiplication being concatination
03:50:11 <swiert> Right. I think I can see how that works.
03:50:47 <roconnor> (actually the elements are curves moduldo continuous deformation)
03:51:46 <quicksilver> yes, and surfaces have a fundamental groupoid, don't though?
03:52:13 <quicksilver> which is that under some sensible equivalence relation, or something
03:52:23 * quicksilver should probably check some reference works in case he's talking rubbish
03:52:27 <osfameron> patches are curves?
03:52:29 * osfameron faints
03:57:16 <roconnor> osfameron: better to say that patches can be represented as curves :P
03:58:10 <roconnor> swiert: do you undersand what the endpoints of the groupoid types (the phantom types) are supposed to represent?
03:58:31 <roconnor> I always think of them as contexts, but I don't know exactly what is included in the context
03:58:58 <roconnor> are two contexts equal if they generate the same project?
03:59:11 <swiert> roconnor: I'd say repository states.
03:59:26 <roconnor> ok, I guess that is most natural
04:01:00 <swiert> lunch. Bbl.
04:03:41 <ivanm> @ask LoganCapaldo is that your meta-meta blog? If so, just found your church-code post... very nice!
04:03:42 <lambdabot> Consider it noted.
04:05:03 <ADEpt> Hi all. I have a question about combining two State monads in a single monadic code block. I read http://www.haskell.org/haskellwiki/Merging_ST_threads and I wonder if there are any other options?
04:05:04 <lambdabot> Title: Merging ST threads - HaskellWiki
04:05:23 <int-e> do you mean State or ST?
04:05:46 <ADEpt> int-e: State
04:07:34 <int-e> the embedState1 / embedState2 approach seems to be the right one to me.
04:08:32 <quicksilver> that wiki page is poorly named
04:08:47 <quicksilver> since it's not mostly about that :P
04:09:14 <quicksilver> ADEpt: if it's something you do rather often, you can write a typeclass to make it all magically work
04:09:22 <ADEpt> int-e: thing is, i have a statefull "processor" and a statefull "output generator", and I want to use them both simultaneously. So there is no nice decoupling into start/intermediate/end computations for me ... ANd lots of lift's still look ugly :(
04:09:45 <ADEpt> quicksilver: I might be a little dense :( How do you propose to use a typeclass?
04:10:36 <quicksilver> class MonadContainsState m s where { mcs_get :: m s; mcs_put :: s -> m () }
04:11:05 <ADEpt> quicksilver: wouldnt that be a roll-your-own StateT?
04:11:18 <quicksilver> no, it's a typeclass not a type :)
04:11:37 <quicksilver> it's syntactically identical to MonadState m s though *except* it doesn't contain the fundep
04:11:37 <int-e> or almost equivalently, class ParserState s where <methods to access and modify the parser's state which is part of s>
04:11:43 <quicksilver> which is the whole point
04:11:57 <quicksilver> because one Monad m might contain two different states , s and s'
04:12:02 <quicksilver> as in your case it does
04:12:48 <ADEpt> quicksilver: ah. and then I define both my State's to be and instance of this typeclass and ... I guess I see it now :)
04:12:54 <ADEpt> s/and/an
04:13:02 <quicksilver> ADEpt: I will spend five minutes trying to write a simple example for you. Let's see if that's long enough :)
04:13:17 <ADEpt> quicksilver: thanks a lot!
04:18:39 <ttfh> There's probably something I'm missing here, why use two state monads? couldn't you just put the two states in one?
04:19:26 <quicksilver> encapsulation
04:19:33 <quicksilver> giving the right type to the right code
04:19:52 <quicksilver> ADEpt: ok it's taking more than five minutes, I'm more rsuty on this than I hoped. I'll get there though
04:20:21 <roconnor> Shouldn't you make your own monad classes?
04:20:36 <quicksilver> yes
04:20:38 <roconnor> then build a state monad with both states
04:20:46 <roconnor> and implement yout two monad classes
04:20:48 <quicksilver> your own monad classes is the way to do it
04:20:53 <roconnor> so you get the abstraction you want
04:21:04 <int-e> I like quicksilver's class.
04:21:54 <ADEpt> roconnor: point is, i dont need any "fancy" abstraction. I just want to be able to "get"/"modify" two different states, that's all.
04:23:25 <ttfh> but isn't the simplest way to just put your states in a pair, and then you just look at one of them at a time and leave the other alone?
04:23:50 <quicksilver> ttfh: yes, but that gives the wrong type to your smaller actions
04:24:02 <quicksilver> you want to declare in the type 'this action only uses the processor state'
04:24:12 <quicksilver> that's a more accurate type definition and makes the code more modular and more resuable
04:24:13 <int-e> and it'll be horrible to modify your code if you need a triple at some later time.
04:24:46 <ttfh> quicksilver: so you make two typeclasses, and then make your state monad an instance of both?
04:25:11 <ADEpt> ttfh: no, 1 typeclass, as fara s I understand
04:27:59 <roconnor> ADEpt: Two state monads distribute over each other.  DistributeState :: StateMonad s1 (StateMonad s2 a) -> (StateMonad s2 (StateMonad s1)) or something like that
04:28:18 <roconnor> Perhaps you could use that.  not sure if that is a good idea or not.
04:29:15 <ADEpt> roconnor: hmmmm.... how would "do modify (\state1 -> ...); modify (\state2 -> ...);" look like?
04:30:50 <roconnor> something like do (distributeState (modify (\state1 ->...))); modify (\state2 -> ...) I thnk
04:31:17 <roconnor> or distributeState would go on the other command
04:31:27 <roconnor> depening on which type you want the whole thing to have.
04:32:16 <ttfh> so something like: getState1 :: HasState1 m => m a ?
04:32:35 <ADEpt> roconnor: that would be a "lift" in disguise, right? :)
04:32:56 <roconnor> ADEpt: I'm not sure.  It doesn't immediately strike me as the same thing.
04:33:25 <roconnor> ADEpt: I was introduced to distributive monads recently, so now I just look for places to apply them :P
04:34:03 <roconnor> lift gives you access to the inner monad
04:34:10 <roconnor> while distrib exchanges the monads.
04:35:13 <roconnor> so inside your distributeState call you can use distributeState again to get back to the original state.
04:35:17 <roconnor> I think.
04:35:46 <int-e> :t \f -> get >>= \s -> lift (runStateT f s) >>= \(a, s') -> put s' >> return a
04:35:48 <lambdabot> forall a (m :: * -> *) a1 (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m, MonadState a (t m)) => StateT a m a1 -> t m a1
04:44:10 <hpaste>  quicksilver pasted "combining two state monads" at http://hpaste.org/3202
04:44:24 <dcoutts_> @seen bringert
04:44:24 <lambdabot> I saw bringert leaving #haskell 24m 42s ago, and .
04:44:25 <quicksilver> ttfh: well, that was lousy. 30 mins instead of 5
04:44:39 <quicksilver> ttfh: this seemed so easy last time I did it but I kept getting bitten by syntax this time :)
04:44:57 * ADEpt loads the page
04:45:12 <quicksilver> ADEpt: :)
04:45:27 <dcoutts_> @tell bringert I've made the zlib package bundle the zlib C code on windows, so we could actually use the zlib package in cabal-install (either as a dep or bundled)
04:45:27 <lambdabot> Consider it noted.
04:45:30 <ttfh> I am interested too :-)
04:45:30 <quicksilver> ADEpt: anyhow the "point" is that I didn't have to lift 'count' or 'getname'
04:45:44 <dcoutts_> dons: you might be interested in that same point
04:45:45 <quicksilver> ADEpt: count, getname, and setname all auto-lifted themselves
04:46:14 <quicksilver> ADEpt: the fact I had to explicitly lift putStrLn is a wart in the standard library, in my opinion
04:46:30 <roconnor> quicksilver: that is moderately pleasent
04:46:45 <dcoutts_> dons: I did basically the same as you did for that simple compression lib, just list all the C code in c-sources and let cabal build it
04:47:00 <quicksilver> roconnor: it would be a lot nicer if you did import Prelude hiding(putStrLn); putStrLn = liftIO Prelude.putStrLn, too
04:47:08 <dcoutts_> so that means we have a solution to the cabal tar gz issue on windows
04:48:03 <quicksilver> ADEpt: what's nice is you end up with types which reflect the real constraints
04:48:18 <ttfh> quicksilver: that looks a bit like Control.Monad.State.Class
04:48:29 <quicksilver> ADEpt: so the type for 'combined' says "this action does IO, and it accesses the Int State and the String State"
04:48:44 <quicksilver> ADEpt: but you can have other actions whose type indications they only do a subset of those things
04:48:52 <quicksilver> ttfh: yes, it's the same class with the fundep removed :)
04:49:09 <quicksilver> ttfh: and I didn't bother to write modify or whatever it's called
04:49:43 * ADEpt tries to apply this to his code
04:49:47 <ttfh> quicksilver: Mmm, I don't understand fundeps yet :-( but I think I understand your example
04:49:49 <int-e> mc_modify f = mc_put . f =<< mc_get
04:49:57 <quicksilver> right, it's not hard :)
04:50:06 <quicksilver> ttfh: the fundep restricts you to at most one 's' per 'm'
04:50:13 <quicksilver> ttfh: which is exactly the constraint we're trying to escape here
04:50:36 <quicksilver> incidentally if you had the situation where 'both' states were Ints, you'd have to newtype one or both
04:50:36 * roconnor doesn't see any fundeps
04:50:41 <quicksilver> but that's not a bad idea
04:50:49 <quicksilver> roconnor: the fundep in Control.Monad.State.Class
04:50:53 <int-e> roconnor: the MonadState class has one
04:51:08 <roconnor> yes
04:51:15 <quicksilver> that's the one I'm talking about :)
04:51:26 <roconnor> ah
04:51:36 <quicksilver> MonadContains is MonadState without the fundep
04:51:37 <ttfh> quicksilver: I don't quite understand, my state monad can only be an instance of one MonadState?
04:51:42 <quicksilver> ttfh: yes
04:51:48 <quicksilver> ttfh: that's precisely what the fundep says
04:52:00 <quicksilver> ttfh: but yoru state monad can be as many instances of MonadContains as you want
04:52:06 <quicksilver> well one per type
04:52:06 <roconnor> will haskell prime allow all IO commands to run in an arbitrary MonadIO?
04:52:12 <quicksilver> but with newtypes, you can do as many as you want
04:52:16 <quicksilver> roconnor: I believe not. Shame.
04:52:23 <ttfh> when would it be usefull with that extra restriction?
04:52:27 <roconnor> oh well.
04:52:35 <roconnor> not the biggest problem with Haskell 98
04:52:39 <quicksilver> ttfh: stops you needing type annotations in the simple case
04:52:48 <int-e> ttfh: it helps the type checker. say if you write  get >>= put
04:52:59 <ttfh> I see
04:53:15 <quicksilver> int-e: can you (or anyone else) explain why I needed the explicit signature on (v::Int) ?
04:53:16 <int-e> ttfh: then the type checker can infer the type of the extracted state from the monad alone.
04:53:44 <quicksilver> ah, I know the answer
04:53:49 <quicksilver> damn
04:53:56 <int-e> it's what I just said.
04:53:57 <quicksilver> it might be mc_put from a different MonadContains instance
04:53:59 <quicksilver> yes
04:54:00 <quicksilver> :)
04:54:08 <quicksilver> asking the question made me see the answer
04:54:12 <int-e> @type 1
04:54:15 <lambdabot> forall t. (Num t) => t
04:55:50 <oerjan> @kind 1
04:55:52 <lambdabot> *
04:56:13 <int-e> @kind ""
04:56:15 <lambdabot> parse error on input `"'
04:56:21 <int-e> oerjan: how does that work?
04:56:47 <int-e> @type undefined :: 12
04:56:49 <lambdabot> Only unit numeric type pattern is valid
04:56:58 <int-e> @type undefined :: 1
04:56:59 <lambdabot> 1 :: GHC.Base.Unit
04:57:10 <int-e> hack!
04:57:19 <ADEpt> quicksilver: Am I right that your idea could not be done with State, only with StateT?
04:57:28 <balodja> @type []
04:57:30 <lambdabot> forall a. [a]
04:57:52 <quicksilver> ADEpt: no, it works for State
04:58:07 <quicksilver> ADEpt: the general recipe is that your 'smaller' actions become polymorphic
04:58:11 <yaw> hello
04:58:31 <quicksilver> ADEpt: so where, currently, you have "foo :: State ProcessorState a"
04:58:42 <balodja> @kind []
04:58:44 <lambdabot> * -> *
04:58:51 <quicksilver> ADEpt: that becomes "foo :: (MonadContains m ProcessorState) => m a"
04:58:59 <int-e> ADEpt: you can provide instances  instance MonadContains (State (Int, String)) Int where  and the same for String.
04:59:19 <quicksilver> ADEpt: so instead of restricting foo to run in State ProcessorState precisely, you permit foo to run in 'Any monad m which has a processor state"
04:59:27 <quicksilver> ADEpt: similarly with your other state
05:00:23 <yaw> Hi there, I'm having trouble building yhc, is this an appropriate place to ask for help?
05:01:02 <swiert> yaw: ndm (Neil Mitchell) hangs out here. He should be able to give you advice.
05:01:11 <int-e> @seen ndm
05:01:11 <lambdabot> I saw ndm leaving #haskell 16h 20m 12s ago, and .
05:01:50 <swiert> yaw: but feel free to ask away. There might be people who can help.
05:02:01 <quicksilver> ADEpt: then, in the end you provide the MonadContains instances for whatever combined monad you decide to use
05:02:07 <yaw> thanks :)
05:02:16 <quicksilver> ADEpt: but later you can provide instances for some other monad if you want and it still works :) Magic!
05:02:38 <quicksilver> int-e, roconnor: did you happen to read my post on tunelling monads in the -cafe a few months back? that's related.
05:02:52 * ADEpt is completely lost already :)
05:03:08 <ADEpt> and typechecker doesn't help any in this refactoring :)
05:03:30 <yaw> basically, i've installed the dependencies, (it appears), but when i go "scons build" i get "Not in scope: 'strip'" in Front.hs
05:03:39 <yaw> for building yhc
05:03:53 <yaw> going off http://haskell.org/haskellwiki/Yhc/Building
05:03:54 <lambdabot> Title: Yhc/Building - HaskellWiki
05:04:42 <quicksilver> ADEpt: if you paste a small fragment with a couple of simple examples of your code, then I may be able to guide you in the right direction
05:10:02 <int-e> quicksilver: I don't remember. But type classes and a newtype or two should help with that.
05:10:28 <quicksilver> int-e: it does, yes, and I showed a possible solution
05:10:47 <quicksilver> int-e: I'm surprised that more people aren't hitting these problems and there aren't more solutions out there
05:10:59 <quicksilver> Either people have a larger tolerance to manual lfting than I do
05:11:06 <hpaste>  ADEpt pasted "trying to merge two State's" at http://hpaste.org/3203
05:11:10 <quicksilver> or people just aren't writing much disciplined monadic code
05:11:34 <ADEpt> quicksilver: here. I trimmed as much as possible :)
05:13:07 <roconnor> quicksilver: I don't read -cafe
05:13:08 <quicksilver> ADEpt: best thing to do is to make correctly typed versions of modify, gets and whatever else you use frequently
05:13:40 <mux> hi there
05:13:56 <ADEpt> quicksilver: as in "make them methods of MonadContains"?
05:14:13 <quicksilver> ADEpt: no, I'll give an example
05:14:31 <roconnor> quicksilver: I was refered to http://www.mail-archive.com/haskell-cafe@haskell.org/msg04654.html
05:14:32 <lambdabot> Title: Re: [Haskell-cafe] Switching monadic encapsulations, http://tinyurl.com/2283e4
05:15:25 <int-e> quicksilver: I'm aware of the problems but they didn't seem very hard. One level of lifting is usually okay, and for more levels you make a helper or a type class. Those helpers come in various shapes but they aren't really difficult, IMHO.
05:16:00 <quicksilver> int-e: no, they're not very hard. I agree. But not much is written about them...
05:16:16 <quicksilver> ADEpt: you probably do want to write mc_modify, as int-e suggested
05:16:25 <quicksilver> ah
05:16:41 <hpaste>  ADEpt annotated "trying to merge two State's" with "well, for starters I got types of mc_get and mc_put wrong" at http://hpaste.org/3203#a1
05:16:48 <quicksilver> yeah
05:16:51 <quicksilver> I just noticed that :)
05:18:03 <quicksilver> you could write mc_modify f = do { v <- mc_get; mc_put (f v) }
05:18:09 <quicksilver> just for convenience
05:18:32 <quicksilver> but give it the right type (MonadContains m s) => (s -> s) -> m ()
05:18:40 <mux> what's this MonadContains stuff?
05:18:48 <quicksilver> then you write specialisations of that where you fix the state type
05:19:06 <quicksilver> so, you write diagramS_modify = mc_modify
05:19:26 <quicksilver> but give it the type (MonadContains m DiagramS) => (DiagramS -> DiagramS) -> m ()
05:19:58 <quicksilver> then, you can just change 'setStep' to use diagramS_modify instead of modify, and it will have the right type
05:19:59 <int-e> and you can write  mc_gets f = liftM f mc_get  (or mc_gets f = do s <- mc_get; return (f s))
05:20:47 <quicksilver> mux: http://hpaste.org/3202
05:20:58 <quicksilver> mux: ADEpt was asking how to combine two state monads into one big one
05:21:08 <mux> I see
05:21:17 <mux> interesting :-)
05:21:18 <quicksilver> int-e, roconnor: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html if you're interested
05:21:21 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ..., http://tinyurl.com/3xmhco
05:21:41 <mux> so when are you releasing mtl-quicksilver? :-) with MonadContains, InterleavableIO, etc
05:22:06 <quicksilver> I'm not sure I have the abstractions right, yet
05:22:52 <quicksilver> that's very odd. that mailing list post used to be top google hit for 'Monadic Tunnelling" and now it doesn't appear at all. *shrug*
05:23:21 <quicksilver> ADEpt: quite often you can manage better named primitives than diagramS_modify, but that's the general pattern :)
05:24:29 <ttfh> so if MonadContains is a less restricted version of Control.Monad.State.Class, could you build the latter from the former? (I'm no good at functional dependencies)
05:25:21 <swiert> I may have missed parts of this discussion, but why don't you pair together the two states and write your own getFst, getSnd, putFst, and putSnd?
05:25:45 <ADEpt> quicksilver: I wonder ... If i put setStep and setSwimline into one module and setGraph and setSection into another, and they would use ordinary get/put/modify, how hard would be to use this typeclass trick to combine states in that case?
05:26:08 <quicksilver> swiert: because he wants his actions on the one state to be ignorant of the existence of the other
05:26:22 <ttfh> swiert: if a part of the code uses only one of the states, this should be reflected in the type
05:26:37 <quicksilver> swiert: so he wants to write code (as if) in State a on the one hand, and State b in the other hand, and then combined the two in State (a,b)
05:27:02 <quicksilver> ADEpt: you could do it, but you'd need a different kind of embedding
05:27:10 <swiert> Ok. Fair enough.
05:27:32 <quicksilver> ADEpt: you'd need an embedding which pulled the particular state out of the global state, called 'runState' and pushed the result back in
05:27:52 * ADEpt seriously considers "darcs revert" and starting all over again
05:28:11 <quicksilver> ADEpt: however, the basic point remains the same. You still need your types to be polymoprhic.
05:28:38 <quicksilver> If you have an action 'A' in one monad and an action 'B' in a nother monad, you will *never* be able to write do { A; B }
05:28:50 <int-e> ADEpt: you'd probably end up with lifting operations, something like the  embedState1/embedState2  functions.
05:29:03 <quicksilver> you need both A and B to be type-class polymorphic
05:29:18 <quicksilver> if they're different monads, then do { A ; B } is a type error
05:29:31 <quicksilver> if they're polymoprhic then do { A; B } just piles up the constraints
05:29:47 <quicksilver> and then if you provide a 'solution' to the constraints that piled up, all is well
05:31:23 <quicksilver> that's the basic trick behind all the "auto-lifting" effects you can acheive
05:31:35 <quicksilver> (and that's why it's so annoying that putStrLn is not polymoprhic)
05:32:12 <ADEpt> uh-oh
05:32:16 <vincenz> ADEpt: what are you working on?
05:32:20 <vincenz> dcoutts_: ping
05:32:40 <ADEpt> i guess i'll need another go at that
05:32:48 <quicksilver> ADEpt: however, if you choose your primitives to be polymorphic in the right way, everything else follows by type infrence
05:32:53 <ADEpt> vincenz: sequence diagram generator, using graphviz
05:33:07 <quicksilver> ADEpt: case in point. "setStep"
05:33:25 <ADEpt> quicksilver: lemme paste another example of code, where I start from, ok?
05:33:32 <quicksilver> ADEpt: as long as setStep uses modify, it has type which is rigidin the state
05:33:47 <quicksilver> ADEpt: if you change setStep to use an new version of modify, then it becomes polymorphic
05:34:09 <quicksilver> ADEpt: for example, if you got it to use mc_modify, instead of modify, that would be good enough
05:34:20 <quicksilver> (the compiler would deudce the right type from \f -> f{step=x})
05:34:44 <quicksilver> of course, with a little namespace care you could use the name 'modify' for mc_modify
05:34:51 <quicksilver> and there would be no conflict :)
05:34:57 <quicksilver> might not even have to change that code
05:35:57 <hpaste>  ADEpt annotated "trying to merge two State's" with "that's where I start" at http://hpaste.org/3203#a2
05:36:52 <quicksilver> ADEpt: yeah, well you can try not changing any of those definitions
05:37:02 <quicksilver> ADEpt: just stop importing gets/modify from C.M.S
05:37:07 <ADEpt> quicksilver: now, see, I have one single huge state. Which I want to split in two, and move both halves of the state and appropriate state access helpers into separate modules
05:37:13 <quicksilver> (or, rather, import them qualified)
05:37:23 <quicksilver> ah right, sorry
05:37:25 <quicksilver> Yes, I see
05:37:46 <ADEpt> quicksilver: ... because those modules might be usefull by their own right.
05:37:50 <quicksilver> yes
05:37:53 <quicksilver> it's a good plan
05:37:57 <quicksilver> I approve of your motivation :)
05:38:19 <ADEpt> quicksilver: at minimum, I want at least half of state in separate module :) Other could reside along with "main" in the "Main" module
05:38:24 * quicksilver nods
05:38:47 <quicksilver> well, from the point of view of incremental testing I wouldn't break what you already have
05:38:57 <quicksilver> I'd start building the new version in a new file by copy-pasting stuff out and modifying it
05:39:02 <quicksilver> and testing it in ghci
05:39:12 <quicksilver> then when it looks good, port your other code over to using it :)
05:39:59 <ADEpt> quicksilver: like, rip the half out, move to separate module, test it in ghci solo, then go back and plow over existing code?
05:49:07 <quicksilver> ADEpt: yes
05:49:23 <angelkat> Hey
05:49:45 <angelkat> is there someon else on this network with angelkat as there nick? NIckserv wont allow me to identify
05:50:27 <ADEpt> quicksilver: I guess I'll try splitting your example into modules first. (when my head stops aching :)
05:50:36 <quicksilver> :)
05:50:51 <quicksilver> ADEpt: it's a bit painful until you get your head around it, yes
05:50:53 <angelkat> so thats a I dont know so?
05:51:04 <Zao> angelkat: You may want to head over to #freenode or whatnot.
05:51:38 <Zao> angelkat: Registered and last seen two years ago.
05:51:45 <Zao> angelkat: You should be able to get a staffer to drop it.
05:51:50 <angelkat> Zao: interesting.
05:51:53 <angelkat> thanks you =)
05:51:58 <Zao> /msg nickserv help  :P
05:52:08 <angelkat> I know how to use nickserv lol!
05:52:33 <angelkat> also it forced mick when I joined. How strange.
05:52:35 <angelkat> anyway
05:52:36 <angelkat> byes
05:52:57 <kloeri> angelkat: I can drop the angelkat registration if you like
05:53:14 <angelkat> \o/ please
05:53:27 <angelkat> nick AngelKat
05:53:29 <angelkat> >.>
05:53:37 <angelkat> (im not that much of a newb honest)
05:53:38 <kloeri> done
05:53:44 <Angelkat> thanks
05:54:03 <kloeri> np
05:57:44 <pharm> OK, so who's responsible for http://arcanux.org/lambdacats.html then?
05:57:45 <lambdabot> Title: Lambdacats
05:59:14 <osfameron> ooo, I hadn't seen all of those
05:59:58 <pharm> (via as comment on  lambda-the-ultimate btw)
06:00:50 <Angelkat> lols at links
06:00:52 <osfameron> they've been in the New SLogan thread
06:00:59 <ddarius> pharm: See the mailing list
06:01:29 <pharm> Ah, I'd skipped over most of that thread.
06:01:34 <quicksilver> bos: harsh! "proliferation of half-bakery"
06:02:48 <raxas> pharm: there are more kittens, lambdacats2..3
06:03:27 * EvilTerran winces at flip concatMap
06:03:35 * Angelkat pounces on bincheol
06:03:41 <kaol> :t flip concatMap
06:03:44 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
06:03:56 <binncheol> Angelkat: wow
06:04:54 <roconnor> flip concatmap :)
06:05:02 <matthew_-> @type flip concatmap
06:05:04 <lambdabot> Not in scope: `concatmap'
06:05:08 <Angelkat> lunch time!
06:05:12 <Angelkat> binncheol: come on!
06:05:16 <roconnor> sorry, flip concatMap
06:05:21 <matthew_-> @type flip concatMap
06:05:21 * binncheol runs
06:05:23 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
06:05:33 <bringert> dcoutts_: great! re: zlib on windows
06:05:48 <EvilTerran> :t (>>=)
06:05:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:06:47 <mrd> ugh. for some reason, my link to the outside world is incredibly slow today.
06:08:03 <quicksilver> mrd: kittens in the tubes
06:09:42 <vincenz> well there's a solution to that, watch porn
06:09:47 <vincenz> "every time you ...., god kills a kitten"
06:10:07 <Spark> interpret a proprietory movie format?
06:10:16 <roconnor> vincenz: performUnsafeIO?
06:10:24 <vincenz> erm..
06:10:33 <vincenz> yes, performUnsafeIO
06:10:33 * mrd watches lambdacats
06:10:56 <EvilTerran> it's like thundercats... only, er, lambda
06:10:56 <mrd> help desk says its campus wide.. woohoo
06:11:10 <Spark> performUnsafeIOIOIOIO
06:11:19 * pharm is all in favour of performUnsafeIO leading to nasal daemons
06:16:09 <oerjan> import Magick(unsafeSummonDaemon)
06:17:10 <EvilTerran> unsafeSummonDaemon >>= nose
06:17:11 <osfameron> safe summonDemon would lead to the invocation of the demon outside the protective pentagram being untypable ?
06:17:45 <vincenz> EvilTerran: erm...unsafe is not monadic so no >>=
06:17:53 <oerjan> instance Monad Pentagram
06:17:53 <_ry> is there a HTTP parser out there I could peek at?
06:17:56 <vincenz> and demon summoning uses phantom types
06:18:11 <vincenz> hence, unsafe summoning would be summoning outside a region of the proper phantom type, aka outside the pentagram
06:18:12 <EvilTerran> it could be in a non-IO monad
06:18:27 <vincenz> EvilTerran: unsafe typically implies "m a -> a"
06:18:54 <oerjan> :t unsafeSTtoIO
06:18:56 <lambdabot> Not in scope: `unsafeSTtoIO'
06:19:15 <oerjan> :t Control.Monad.ST.unsafeSTtoIO
06:19:17 <lambdabot> Not in scope: `Control.Monad.ST.unsafeSTtoIO'
06:19:21 <EvilTerran> ?type unsafeSTtoIO
06:19:23 <lambdabot> Not in scope: `unsafeSTtoIO'
06:19:32 <EvilTerran> ah, oerjan got there first, and it didn't work anyway.
06:20:00 <oerjan> :t Control.Monad.ST.unsafeSTToIO
06:20:01 <lambdabot> forall s a. GHC.ST.ST s a -> IO a
06:30:55 <bos> i've always thought that "SCC" in GHC-speak meant "strongly connected component", but someone claims it doesn't. can anyone shed any light?
06:32:27 <roconnor> CC is call centre
06:32:34 <matthew_-> it means "Sodding-well Count the Calls here"
06:32:47 <roconnor> not to be confused with call center
06:33:03 <matthew_-> hello, how can I help you?
06:33:40 <roconnor> matthew_-: I'm having trouble with my map
06:34:35 <EvilTerran> have you tried switching it off and on again?
06:35:30 <matthew_-> can you tell me the serial number of your map please?
06:36:28 <ToRA> is there a cat on your map?
06:36:44 <matthew_-> @slap ToRA
06:36:45 * lambdabot beats up ToRA
06:39:23 <ToRA> @type flip map undefined cat
06:39:24 <lambdabot> [Doc]
06:39:50 <EvilTerran> what?
06:39:54 <EvilTerran> ?type cat
06:39:57 <lambdabot> [Doc] -> Doc
06:44:28 <birkenfeld> @index cat
06:44:28 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
06:44:49 <quicksilver> I thought it was cost center
06:44:52 * quicksilver shrugs
06:45:25 <_ry> is there a haskell http protocol parser out there?
06:45:54 <quicksilver> I've not seen one
06:46:00 <quicksilver> mind you HTTP is a pretty simple protocol :P
06:46:10 <quicksilver> header fields newline body....
06:46:24 <osfameron> roll your own, what could possibly go wrong!
06:46:25 <quicksilver> there is Network.HTTP which must internally sort it out, I guess
06:54:04 <_ry> is there a rubygems like tool for cabal packages?
06:55:46 <EvilTerran> there's cabal-install, but i don't think that's been released yet
06:56:11 <vincenz> they're working on that
06:58:52 <_ry> quicksilver: i think Network.HTTP is only an http client
06:59:08 <quicksilver> _ry: well, you didn't specify which part of http you wanted to parse
06:59:21 <quicksilver> _ry: but, parsing-wise, both "ends" of HTTP are very similar
06:59:31 <_ry> oh yeah, of course.
06:59:34 <quicksilver> a request is "VERB url\nHeaders\ncontent"
06:59:42 <quicksilver> a response is "Headers\ncontent"
07:04:50 <EvilTerran> or VERB url HTTP/version\n...
07:06:26 <yaw> hey, is anyone here familiar with catch? (http://www-users.cs.york.ac.uk/~ndm/catch/)
07:06:26 <lambdabot> Title: Neil Mitchell - Catch: Case Totality Checker for Haskell
07:08:54 <pharm> I suspect Neil is (ndm on irc if he's around) :)
07:09:36 <quicksilver> yaw: I'm familiar with the design and the general idea
07:09:46 <quicksilver> yaw: I've read the paper and chatted to Neil but not actually used it :P
07:10:41 <yaw> mmm
07:10:48 <yaw> i'm just trying to get it to work
07:11:06 <yaw> i keep getting "user error (invalid binary data found)"
07:11:34 <yaw> there's a chance it's due to a small change i made in yhc to get the thing to compile
07:12:06 <yaw> i guess i'll have to wait for neil for this
07:12:06 <quicksilver> I'm not sure what that means
07:12:10 <quicksilver> I think it reads yhc core
07:12:16 <quicksilver> maybe wrong version of YHC, wrong core format?
07:12:18 <quicksilver> (perhaps?)
07:12:21 <quicksilver> malcolmw: ping
07:12:24 <yaw> hmm
07:12:33 <malcolmw> quicksilver: pong
07:12:47 <quicksilver> malcolmw: yaw getting weird errors trying to get Catch (and thus yhc) working
07:12:55 <quicksilver> malcolmw: are you aware of some tight version dependency there?
07:13:09 <yaw> yhc appears to be working on its own
07:13:17 <yaw> i can compile simple programs and run them with yhi
07:13:31 <yaw> i had to edit a line of code to get yhc to compile though
07:13:43 <malcolmw> quicksilver: I have a vague feeling that recent changes in yhc.core broke catch temporarily, but you would need to ask ndm for the details
07:13:59 <quicksilver> I thought it might be something along those lines
07:14:14 <malcolmw> and ndm is away this week (although he has appeared on IRC at times nonetheless...)
07:14:19 <quicksilver> didn't yhc implement pattern guards (partly so that) catch could handle those?
07:14:59 <malcolmw> yup, I implemented pattern guards in nhc98, then merged the compiler with yhc so that it could have the benefit too
07:17:28 <yaw> Would anyone know which versions are compatible, if i can grab older versions of the software?
07:24:42 <madnificent> vincenz: what do you study?
07:24:50 <vincenz> madnificent: hmm?
07:25:10 <madnificent> vincenz: you're on kuleuven... I saw you join...
07:25:17 <madnificent> vincenz: I study there too... so I wondered
07:25:23 <vincenz> oh
07:25:28 <vincenz> that was random :)
07:25:30 <vincenz> electronics
07:25:40 <vincenz> woo, tunneling
07:25:50 <madnificent> vincenz: LoL
07:26:11 <roconnor> > 10000/600
07:26:12 <vincenz> irssi-proxy ftw
07:26:15 <lambdabot>  16.666666666666668
07:26:23 <vincenz> madnificent: what do you study?
07:26:33 <madnificent> 2 bach inf
07:26:38 <roconnor> > 10000 `quotRem` 600
07:26:39 <lambdabot>  (16,400)
07:26:45 * vincenz tried to follow a last year course in inf but was disaspointed
07:26:59 <madnificent> vincenz: what was wrong?
07:27:01 <vincenz> madnificent: why do you get 'set-theory' only in the last year
07:27:03 <vincenz> and why is it so basic
07:27:15 <blarz> > 2/3
07:27:16 <lambdabot>  0.6666666666666666
07:27:48 <madnificent> vincenz: perhaps you could send a mail to steegmans... dunno if he takes care of the master...
07:29:40 <dons> ?users
07:29:40 <lambdabot> Maximum users seen in #haskell: 420, currently: 377 (89.8%), active: 15 (4.0%)
07:29:41 <vincenz> madnificent: do you peeps get haskell?
07:32:15 <madnificent> vincenz: yup... but that's something for next year...
07:32:30 <madnificent> and i assume it'll be some introduction to functional-programming
07:32:37 <vincenz> spiffy
07:32:45 <madnificent> the courses aren't too hard, you are encouraged to learn more on yourself...
07:32:48 <madnificent> at least that is what I think
07:32:54 * vincenz remembers how he got scheme in his first year of uni, 9 years ago (damn, now I feel old)
07:33:19 <madnificent> scheme sounds interesting too
07:33:47 <vincenz> nowadays they use java in the first year, however.
07:34:20 <madnificent> vincenz: which is utterly dull
07:35:09 <vincenz> madnificent: not to mention, not a very good way to teach concepts
07:35:57 <madnificent> vincenz: it is one of the languages I actually dislike... it has little or no beauty in itself
07:44:06 * roconnor wonders if ITA-software is a publicly traded company
08:19:13 <dons> ?yow
08:19:13 <lambdabot> When I met th'POPE back in '58, I scrubbed him with a MILD SOAP or
08:19:13 <lambdabot> DETERGENT for 15 minutes.  He seemed to enjoy it ...
08:21:45 <dons> ah interresting, icfp top 15 had 8 FP teams (5 OCaml, 3 Haskell).
08:22:05 <osfameron> and no FP teams in top 3 :-)
08:22:26 <roconnor> Are the ICFP videos online?
08:22:32 <dons> yeah, #3 was an ocaml/c++ guy
08:24:13 <exDM69> what's icfp?
08:24:23 <dons> a huge programming contest held each year
08:24:33 <dons> haskell won it for the last 3 years, but C++ came in first this year
08:24:43 <dons> ?go icfp contest
08:24:46 <lambdabot> http://www.icfpcontest.org/
08:24:46 <lambdabot> Title: ICFP Programming Contest 2007
08:26:08 <osfameron> and Perl made a surprise 2nd place
08:27:54 <dcoutts_> vincenz: pong
08:27:59 <dons> morning dcoutts_
08:28:01 <dons> hey joe_hurd
08:28:11 <dcoutts_> g'afternoon dons
08:28:24 <dons> dcoutts_: ^^ more galois people taking over :)
08:28:25 <vincenz> dcoutts_: hey, mind forwarding that email, or pinging them with my email
08:28:36 <dcoutts_> vincenz: what email?
08:29:24 <quicksilver> dcoutts_: gtk2hs. threading. You you just compile with -threaded and forkIO at will, as long as subthread's don't use gtk calls?
08:29:52 <quicksilver> s/You you/Can you/;
08:29:58 <dcoutts_> quicksilver: right, and use the alternative initGUI call
08:30:02 <vincenz> quicksilver: yes
08:30:13 <kosmikus> dons: how many new people has galois hired already since ICFP? ;)
08:30:21 <vincenz> quicksilver: let me get you the code
08:30:37 <quicksilver> dcoutts_: why do you need an alternative initGUI?
08:30:39 <dcoutts_> dons: looks like I'll be able to make zlib, bzlib and perhaps even the iconv bindings build on windows just by bundling the C sources
08:30:39 <dons> kosmikus: since icfp? hmm :) 0.5? (some applicatoins have come in)
08:30:56 <dcoutts_> quicksilver: to promise that you take full responsibility for threading bugs
08:30:57 <quicksilver> (compared to, say, openGL where you can mainLoop)
08:31:00 <vincenz> quicksilver:   launchGUI nodes edges = do
08:31:00 <vincenz>     initGUI
08:31:00 <vincenz>     timeoutAddFull (yield >> return True) priorityDefaultIdle 50
08:31:18 <dcoutts_> quicksilver: so people don't accidentally link with -threaded and get totally borked behaviour
08:31:22 <vincenz> dcoutts_: or did that change?
08:31:34 <dcoutts_> vincenz: that's for the single threaded rts
08:31:44 * vincenz used that for a multithreaded app
08:31:45 <dcoutts_> and that works fine and is quite safe
08:32:15 <dcoutts_> with the -threaded rts you have to be really careful with calling gui stuff from different threads
08:32:23 * vincenz nods
08:34:14 <kosmikus> dons: there must have been a huge number of interested candidates at the dinner?
08:34:40 <dons> kosmikus: i believe so. i think it was very successful, though we've not had a briefing yet about it.
08:34:46 <dons> my impression was that there was lots of interest
08:34:57 <joe_hurd> dcoutts: hi duncan, do you know if haddock-ghc is available?
08:35:22 <dcoutts_> joe_hurd: there's a darcs repo for it somewhere
08:35:34 <dcoutts_> @seen waern
08:35:34 <lambdabot> I saw waern leaving #ghc and #haskell 4h 8m 19s ago, and .
08:35:40 <dons> ah yes, dave waern
08:35:43 <dcoutts_> joe_hurd: waern's the author
08:35:52 <dcoutts_> @where haddock-ghc
08:35:52 <lambdabot> I know nothing about haddock-ghc.
08:36:17 <joe_hurd> do you know if its a stable thing to be unleased on innocent newbie users like myself?
08:36:36 <joe_hurd> i wonder what unleased could mean?
08:37:00 <dcoutts_> joe_hurd: it's kind of waiting for ghc-6.8 to be released
08:37:13 <quicksilver> dcoutts_: Ah, ok
08:37:14 <dcoutts_> and then the support for it in cabal needs to be updated I think
08:37:19 <quicksilver> dcoutts_: so really it's the 'same' as openGL
08:37:24 <joe_hurd> dcoutts_: ok, i
08:37:35 <quicksilver> dcoutts_: just you took a decision to force people to make a visible decision by choosing the right version of initGUI
08:37:37 <dcoutts_> quicksilver: right, but a change relative to normal gtk2hs behaviour
08:37:38 <joe_hurd> sorry, mistype (new keyboard)
08:37:54 <joe_hurd> dcoutts_: ok, i'm using 6.6.1 atm, so i'll wait.
08:38:13 <dcoutts_> joe_hurd: we really need to bug waern about what needs to be done
08:38:20 <dcoutts_> eg the support in cabal should go in now
08:38:27 <joe_hurd> dcoutts_: am i allowed to ask when 6.8 will be unleashed?
08:38:50 <dcoutts_> joe_hurd: it's not entirely clear yet, ask Igloo and JaffaCake
08:39:36 <JaffaCake> asap, but not before it's ready
08:39:46 <joe_hurd> dcoutts_: i completely agree: the existing haddock cannot cope with the result of alex or some 'deriving' extensions. v. annoying.
08:40:29 <dons> JaffaCake: will base be tagged 3.0 or similar soon, so we can start updating hackage packages for it?
08:40:42 <joe_hurd> JaffaCake: good answer, but not so useful for planning purposes. closer to a week or a decade from now?
08:40:47 <JaffaCake> dons: I believe Igloo has it in hand
08:40:58 <dons> ok.
08:41:11 <dons> a list of broken packages to libraries@ might also be a good motivation
08:41:16 <JaffaCake> joe_hurd: roughly 2-3 weeks, I guess
08:41:27 <dons> dcoutts_: we need to get bytestring 0.9 tagged too
08:41:32 <joe_hurd> JaffaCake: excellent news
08:42:03 <dons> joe_hurd: do you know dcoutts and Igloo, btw? (also at oxford)
08:42:18 <dons> if not, let me introduce dcoutts and Igloo (and JaffaCake!)
08:42:35 <quicksilver> JaffaCake is in cambridge! ;)
08:42:50 <dons> certainly, but worth introducing :)
08:43:02 <dons> joe's a new theorem proving hacker at galois
08:43:15 <joe_hurd> dons: i know dcoutts, but the aliases Igloo and JaffaCake baffle me.
08:43:27 * JaffaCake waves to joe_hurd
08:43:31 <dons> Igloo is Ian Lynagh, and JaffaCake is Simon Marlow :)
08:43:37 <dons> but don't tell anyone!
08:43:46 <joe_hurd> hi guys, your secret is safe with me.
08:44:01 <dons> quicksilver is also an interesting fellow
08:44:13 <dons> another englishman, iirc.
08:44:19 <dons> they're everywhere!
08:44:29 * JaffaCake goes home, bye folks
08:44:32 <joe_hurd> and does quicksilver have another alias?
08:44:34 <dons> ciao JaffaCake
08:44:36 <sjanssen> mostly in England, though
08:45:19 <dons> sjanssen: ah yes, good point
08:46:48 <joe_hurd> i'm an irc newbie as well as a haskell newbie
08:47:03 <joe_hurd> previously i was an email and sml junkie :-)
08:48:19 <joe_hurd> quicksilver: just discovered whois, so hi to you too
08:48:30 <quicksilver> :)
08:48:32 <quicksilver> hi
08:48:54 <quicksilver> I was at QM but I couldn't take the pace of academia, so I've retired to a quiet life in the City.
08:49:22 <joe_hurd> quicksilver: you got sucked into the banking FP crowd?
08:49:29 <geocalc> what is this pfe ???
08:49:36 <chessguy> so this looks interesting: http://developer.mozilla.org/en/docs/New_in_JavaScript_1.8
08:49:37 <lambdabot> Title: New in JavaScript 1.8 - MDC
08:49:48 <quicksilver> joe_hurd: nah, not even an FP job. At least, not yet.
08:49:53 <quicksilver> joe_hurd: just a programming job.
08:50:08 <vincenz> quicksilver: and here I thought you were doing a phd
08:50:21 <quicksilver> vincenz: I did once :)
08:50:27 <joe_hurd> quicksilver: thought about that for a while, but decided to change continent instead of moving away from FP!
08:51:05 <vincenz> @age quicksilver
08:51:05 <lambdabot> Maybe you meant: arr ask
08:51:36 <quicksilver> old enough to remember NCSA mosaic, but not old enough to have prorammed with punch cards.
08:51:42 <chessguy> looks like javascript is getting  lazy expressions, folds, and special notation for lambda functions. good stuff
08:53:15 <vincenz>  yeah, if now they just would fix scoping rules
08:53:25 <quicksilver> not likely
08:53:28 <geocalc>   pfe           Generate Programatica Project. <-- is it important for haskell ???
08:57:30 <chessguy> the scoping is a little annoying, but it's not too bad
08:59:14 <phlpp> hi
08:59:15 <phlpp> o instance for (Fractional Integer) arising from the literal `0.5' at Test.hs:156:16-18
08:59:28 <phlpp> i have a function like collatzNum :: Integer -> Integer
08:59:45 <phlpp> and if x is even, i want to return x/2, if it's odd then 3x+1
09:00:22 <quicksilver> x `div` 2
09:00:32 <phlpp> thank you :)
09:00:38 <quicksilver> is for numbers which support fractions :)
09:00:47 <quicksilver>  / is, I should say
09:00:58 <phlpp> `div` means prefix op is used in infix mode?
09:01:02 <quicksilver> right
09:01:07 <phlpp> cool stuff
09:01:08 <phlpp> :)
09:01:09 <quicksilver> you could say div x 2
09:01:14 <quicksilver> if you preferred
09:02:09 <phlpp> yeah, depending on how much lisp freak you are
09:02:09 <phlpp> :D
09:02:22 <osfameron> or (+) 1 2    instead of 1 + 2  :-)
09:04:08 <quicksilver> or (let a/b = a`div`b in x/2)
09:04:13 <quicksilver> if you like the / syntax
09:04:29 <MyCatSchemes> Why do people here seem to consider Data.Graph to be evil, anyway?
09:04:39 <ski> let (/) = div in x/2
09:04:58 <quicksilver> true, but I prefer a/b to (/) , syntax-wise :)
09:05:10 <quicksilver> and I like showing off that you can do infix definitions
09:05:29 <osfameron> yeah, infix definitions are cute
09:06:04 <phlpp> wtf
09:06:18 <phlpp> can i really redefine this / operator for my use?
09:06:22 <phlpp> thats cooool.
09:06:31 <EvilTerran> don't, though, you'll confuse everyone
09:06:35 <Saizan> hiding the prelude one
09:06:38 <phlpp> :>
09:06:47 <ski> Hugs> let (+) ((+)+1) = (+) in (+) `id` 2
09:06:47 <ski> 1 :: Integer
09:07:32 <quicksilver> phlpp: you can redefine almost anything
09:07:33 <ski> (don't do that, either)
09:07:49 <quicksilver> phlpp: there are some subtleties in monad notation and list comprehension
09:07:57 <quicksilver> but -fno-implicit-prelude catches most of those
09:08:19 <phlpp> hehe, ok.
09:08:28 <phlpp> i really getting more in love with haskell
09:08:43 <phlpp> (cause of reading and writing stuff here and because of advancing in my tutorial)
09:10:48 <chessguy> @quote addict
09:10:48 <lambdabot> chessguy says: heh. i think i'm officially addicted. i'm chatting in #haskell, helping hack on a haskellwiki page, browing a reddit thread about haskell, while playing a haskell video lecture in the
09:10:49 <lambdabot> background
09:11:08 <MyCatSchemes> phlpp: heh, I'm familiar with that feeling.
09:12:43 <madnificent> I am having that feeling :-)
09:17:22 <byorgey> yay Haskell! =)
09:18:33 <ddarius> @user
09:18:33 <lambdabot> Maximum users seen in #haskell: 420, currently: 377 (89.8%), active: 17 (4.5%)
09:19:20 <geocalc> @active
09:19:20 <lambdabot> Unknown command, try @list
09:19:34 <badkins> Just out of curiosity, is lambdabot running Haskell code?
09:19:46 <geocalc> yes
09:19:51 <Vulpyne> It's written in Haskell, yeah.
09:19:57 <badkins> cool. Is the source available to examine?
09:20:05 <olsner> @where lambdabot
09:20:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
09:20:27 <badkins> thx
09:21:37 <MyCatSchemes> @src Fd
09:21:37 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:21:52 <MyCatSchemes> @src System.Posix.Types.Fd
09:21:52 <lambdabot> Source not found. You speak an infinite deal of nothing
09:25:43 <ski> @version
09:25:44 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
09:25:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:36:18 <roconnor> the audio is cut off in don's talk :'(
09:36:34 <roconnor> @where HPC
09:36:34 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Program_Coverage
09:36:51 <ddarius> roconnor: It wasn't for me.
09:37:47 <roconnor> ddarius: thx, vlc / linux audio needs some quickcheck I think.
09:38:14 <roconnor> replaying works
09:39:04 <roconnor> audio dies in vlc at 12:48, but if you slide the slider around, it works again.
09:39:51 <sjanssen> roconnor: worked perfectly in mplayer
09:40:50 <ddarius> roconnor: Are you talking about another talk by the way?  The Haskell Workshop one is presented by Andy Gill
09:41:18 <roconnor> dons xmonad demo at the HW2007
09:42:33 <phlpp> is there a way to determine if in a list there's a certain cycle/pattern? so if in a list of Integers is a pattern like 4, 2, 1?
09:43:00 <ricky_clarkson> Sort it, look for pairs.
09:43:07 <pizza_> phlpp: there is indeed
09:43:34 <roconnor> phlpp: a finite list?
09:44:37 <phlpp> it SHOULD be a finite list. the problem is, if once this 4, 2, 1 pattern occured, it repeats infinitely.. so another option would be to test the 'input' list on sth. like [x, 4, 2, 1] = x
09:44:53 <MyCatSchemes> Hrmn, how do you define infix operators, please?
09:44:54 <phlpp> oh, hm, forget about the last one, it's nonsense i thikn
09:45:09 <ddarius> MyCatSchemes: Exactly as you'd expect.
09:45:20 <EvilTerran> > let x ? y = (y,x) in 1 ? 2
09:45:22 <lambdabot>  (2,1)
09:45:31 <ddarius> > let (?) x y = (y,x) in 1 ? 2
09:45:32 <lambdabot>  (2,1)
09:45:33 <EvilTerran> > let (?) = const in 1 ? 2
09:45:34 * MyCatSchemes hugs everybody. ^_^
09:45:34 <lambdabot>  1
09:45:40 <MyCatSchemes> Thaaaaankooo.
09:46:15 <Saizan> phlpp: do you know the pattern to look for in advance or not?
09:46:20 <MyCatSchemes> Is there any need (or way?) to specify their fixity and precendence?
09:46:51 <ddarius> For infinite lists there is nothing you can do.
09:47:14 <oerjan> > let x ? y = x+y; infixr 5 ? in 2 ? 3
09:47:16 <lambdabot>  5
09:47:47 <roconnor> phlpp: are you doing something with the 3n+1 problem?
09:47:56 <phlpp> Saizan: i know that the list one time will get to 4 (list values are calculated by a function), and as it gets to four, it will get to 4, 2, 1, 4, 2, 1, ...
09:48:04 <geocalc> if i enable compile for ghci do this mean less good with ghc ?
09:48:07 <phlpp> roconnor: exactly ;)
09:48:29 <roconnor> isn't it traditional to just check for 1?
09:48:39 <phlpp> im just trying to create a list with calculated values, just as exercies to get in this recursive way of thinking
09:49:00 <phlpp> yeah, ok, you are right then
09:49:15 <phlpp> if it reaches one, it should abort, stop calculating the list
09:49:32 * geocalc should ask again 
09:49:39 <geocalc> if i enable compile for ghci do this mean less good with ghc ?
09:49:46 <Saizan> geocalc: what do you mean?
09:49:48 <sjanssen> geocalc: huh?
09:51:04 <byorgey> phlpp: just use takeWhile (/=1)
09:51:28 <Saizan> takeUntil (==1) would be better,
09:51:45 <byorgey> phlpp: note that because of lazy evaluation, you don't need to think in terms of "stopping" or "aborting" when 1 is reached.
09:52:05 <byorgey> instead, think of it as two steps: 1) calculate the infinite, repeating list.
09:52:05 <geocalc>            --enable-library-for-ghci       compile library for use with GHCi i have this with the setup Saizan sjanssen
09:52:15 <roconnor> > cylce [4,2,1]
09:52:16 <lambdabot>   Not in scope: `cylce'
09:52:17 <byorgey> 2) only take the beginning of the list up to the first occurrence of 1.
09:52:20 <roconnor> > cycle [4,2,1]
09:52:22 <lambdabot>  [4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2...
09:52:36 <roconnor> > takeUntil (==1) (cycle [4,2,1])
09:52:37 <lambdabot>   Not in scope: `takeUntil'
09:53:02 <roconnor> !!!
09:53:27 <byorgey> takeUntil = takeWhile . not ?
09:53:49 <roconnor> > takeWhile (/=1) (cycle [4,2,1])
09:53:50 <lambdabot>  [4,2]
09:53:54 <Saizan> takeUntil will give you the 1 at the end
09:54:01 <byorgey> ah, I see
09:54:03 <Saizan> but it's no more in the prelude
09:54:08 <byorgey> that's not intuitive though
09:54:23 <byorgey> (not to me at least)
09:54:27 <phlpp> thanks byorgey
09:54:28 <phlpp> :)
09:54:30 <phlpp> and the others
09:54:31 <hpaste>  huamn pasted "Datagram socket ports?" at http://hpaste.org/3205
09:54:48 <roconnor> time to go home and make dinner
09:54:50 <byorgey> phlpp: sure, have fun =)
09:54:54 <huamn_> can anyone help me with this? port number seems to get multiplied by 256
09:54:57 <byorgey> roconnor: enjoy!
09:55:04 <geocalc> @hoogle takeUntil
09:55:04 <lambdabot> No matches found
09:55:22 <ski> @hoogle (a -> Bool) -> [a] -> [a]
09:55:23 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
09:55:23 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
09:55:23 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
09:56:25 <phlpp> takeWhile (/=1) (collatzList [5]) ++ [1]
09:56:25 <byorgey> huamn_: what happens if you use port number 101 instead of 100?
09:56:27 <phlpp> so that works fine for me
09:56:28 <phlpp> ;))
09:56:32 <phlpp> great stuff
09:56:45 <huamn_> byorgey, 19:56:39.312241 IP localhost > localhost: ICMP localhost udp port 25856 unreachable, length 48
09:56:56 <byorgey> > 256 * 101
09:56:58 <lambdabot>  25856
09:57:00 <byorgey> weird
09:57:04 <huamn_> yes, it is.
09:57:34 <oerjan> huamn_: wrong endianness perhaps?
09:57:38 <byorgey> for a minute I thought maybe the 100 was getting interpreted as hexadecimal =)
09:57:40 <huamn_> could be
09:57:52 <huamn_> I'm just very new to haskell and don't know what I could do about it
09:58:05 * geocalc help =<< Saizan sjanssen 
09:58:07 <huamn_> endianness would quite much explain it
09:58:11 <huamn_> I think
09:58:17 <sjanssen> geocalc: where do you see this flag?
09:58:57 <geocalc> in Setup.hs run
09:59:22 <sjanssen> geocalc: oh, I think you can ignore that flag
09:59:32 <geocalc> ok
09:59:37 <huamn_> oerjan, any suggestions related to changing the endianness?
10:00:25 <huamn_> actually print (show (PortNum 101)) also prints out "25586"
10:00:46 <huamn_> so the conversion to Word16 is not quite what I'd like it to be, but I have no idea how to make it right :)
10:00:57 <byorgey> huamn_: I just tried it on my machine and typing (PortNum 100) into ghci also produces 25600.
10:01:58 <huamn_> should I invert the endianness myself? doesn't seem like an elegant solution
10:02:05 <oerjan> hm... PortNum is a Num
10:02:13 <mrd> yea
10:02:15 <mrd> and it's an Enum
10:02:21 <mrd> so use fromInteger, or toEnum
10:02:35 <mrd> don't use PortNum directly
10:02:36 <oerjan> try using just port instead of PortNum port
10:03:07 <mrd> try this: print (101 :: PortNumber)
10:03:13 <mrd> (is that the name of the type?)
10:03:23 <byorgey> mrd: I tried that
10:03:32 <byorgey> it gives the multiplied by 256 value.
10:03:40 <oerjan> oh
10:03:42 <mrd> even (toEnum 101 :: PortNumber) ?
10:03:47 <byorgey> wait, no it doesn't
10:04:02 <byorgey> hm, print (101 :: PortNumber) works fine
10:04:16 <mrd> i've gleaned from the source code that the fromInteger method of Num PortNumber will do the endian conversion for you, and the Show instance does it back
10:04:18 <byorgey> but print (PortNum 101) doesn't
10:04:21 <mrd> right
10:04:31 <byorgey> ah, interesting
10:04:31 <mrd> because PortNum :: Int -> PortNumber
10:04:36 <byorgey> right
10:04:37 <mrd> and is a constructor
10:04:42 <oerjan> right, so the contained Word16 value is not meant to be used directly
10:04:49 <mrd> whereas fromInteger method is defined to do the endian conversion for you.
10:04:57 <mrd> basically -- the export of PortNum is a flaw in the API
10:05:03 <mrd> it is supposed to be abstract
10:05:15 <byorgey> huamn_: you got all that? =)
10:05:23 <huamn_> pretty much
10:05:29 <huamn_> i removed the PortNum now it works
10:05:31 <huamn_> :p
10:05:31 <mrd> the comments indicate that it is a workaround to allow Network.BSD access to it
10:05:39 <huamn_> tried to hassle around too much with the types
10:05:48 <huamn_> thanks
10:05:53 <mrd> huamn_: in general, if you have a var :: Int, and want a portnumber, do fromInteger var
10:05:56 <mrd> er
10:05:57 <mrd> fromIntegral var
10:06:15 <huamn_> seems to be okay to just give the port directly to the sendTo
10:06:23 <mrd> literal numbers are defined to be (fromInteger ...) already
10:06:28 <huamn_> without constructing PortNum or applying fromInteger
10:06:32 <huamn_> okay
10:06:40 <huamn_> so it's just implicit (fromInteger 100)
10:06:42 <mrd> right
10:07:12 <mrd> and the context says "we want a PortNumber" and it also says "PortNumber is a Num" therefore "there is a fromInteger defined appropriately"
10:07:31 <huamn_> ok
10:07:47 <mrd> and yes, it would be wonderful if this was noted somewhere in the API
10:07:52 <huamn_> :)
10:07:55 <huamn_> indeed
10:08:06 <mrd> there's a lot of broken things about Network.Socket, sadly
10:11:08 <huamn_> I also didn't find any host-resolving stuff except the Network-package functions which do not seem to support UDP... where's the resolving-related functions which I could use with Network.Socket? Or am I just blind? :)
10:12:22 <mrd> Network.BSD
10:12:33 <mrd> I believe getHostByName type things live there
10:12:49 <huamn_> ah yes
10:12:55 <huamn_> thanks
10:14:38 <pizza_> what does the $ do in haskell?
10:14:53 <birkenfeld> pizza_: it's function application
10:15:00 <birkenfeld> but with a very low priority
10:15:05 <oerjan> @src $
10:15:05 <lambdabot> f $ x = f x
10:15:25 <mauke> ($) = fmap fix return
10:15:59 <geocalc> huamn_-> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsdns-1.0 ?
10:16:01 <lambdabot> http://tinyurl.com/2bfgps
10:16:59 <huamn_> the BSD-stuff is actually fine, I was just unable to locate it from there... :)
10:18:16 <ADEpt> quicksilver: here?
10:18:28 <byorgey> mauke, that's mean =)
10:18:39 <dcoutts_> joe_hurd: btw: http://darcs.haskell.org/SoC/haddock.ghc/
10:18:40 <lambdabot> Title: Index of /SoC/haddock.ghc
10:19:25 <dcoutts_> though I'm not absolutely sure that's the location of the latest haddock 2.0 code
10:19:43 <joe_hurd> dcoutts_: thanks for the pointer, but i'll still wait for the release of ghc 6.8
10:19:52 <dcoutts_> good plan
10:20:02 <joe_hurd> dcoutts_: too much of a newbie to enter those waters
10:20:08 <dcoutts_> :-)
10:23:09 <pizza_> is there a canonical "timer" function so that i could do something like "> time foo" and get the run time of foo?
10:23:18 <Cale> pizza_: :set +s
10:23:29 <fasta> pizza_: no
10:23:56 <pizza_> Cale: ah, excllent, thank you
10:24:39 <fasta> Was there any reason for the data structure in the ICFP contest to be purely functional?
10:26:59 <waern> dcoutts: that's the right location
10:27:12 <dcoutts_> waern: ok, btw, what's left to do?
10:27:21 <dcoutts_> waern: we need some cabal changes right?
10:27:24 <waern> dcoutts: support more extensions + fix bugs
10:27:28 <waern> dcoutts: yes
10:27:48 <dcoutts_> waern: and we need to reinstate the --read-iface thing in haddock right?
10:28:03 <waern> dcoutts_: yes. since haddock shouldn't do the $topdir resolving itself
10:28:13 <dcoutts_> waern: rather than having haddock relying exclusively on ghc-pkg
10:28:30 <waern> dcoutts: yes that's another good reason
10:28:32 <MyCatSchemes> Arsefeck! *tries to construct an infinite type*
10:28:56 <dcoutts_> waern: cabal currently does not use the haddock -package stuff at all, cabal calls ghc-pkg itself, checks the files really exist and then calls haddock with --read-blah
10:29:45 <waern> dcoutts_: yes, I know...
10:29:48 <dcoutts_> waern: so what changes were needed in cabal for haddock-2.0 ?
10:30:10 <dcoutts_> and would we need any changes at all if haddock-2.0 continues to support --read-interface ?
10:30:30 <waern> dcoutts_: well.. support for detecting haddock-2.0 and sending it the GHC build params
10:30:46 <dcoutts_> waern: ah yes, hmm.
10:30:50 <dcoutts_> detecting is easy
10:30:57 <waern> but me and nominolo was working on that
10:31:05 <waern> I don't know how far the patch got though...
10:31:12 <MyCatSchemes> I need a function which returns functions of the same type as itself. :/
10:31:34 <waern> dcoutts_: for the build params we wanted to introduce a new datatype instead of using lists of strings as it is now
10:31:44 <dcoutts_> waern: it'd be nice if we could get those changes into cabal-1.2 so that people will be able to start using haddock-2.0 with ghc-6.8 without needing to upgrade their cabal
10:32:08 <waern> dcoutts_: yes! you mean something like cabal-1.2.1?
10:32:15 <dcoutts_> right
10:32:54 <dcoutts_> waern: yeah, I already released cabal-1.2.0, but I'll bump it again to 1.2.1 by the time ghc-6.8.1 comes out
10:33:19 <dcoutts_> so now is the time to get any cabal changes in, if you want haddock-2.0 to work 'out of the box' with ghc-6.8.1
10:33:42 <byorgey> MyCatSchemes: if you introduce a newtype it should be possible.
10:34:04 <waern> dcoutts_: yeah. I'll talk to nominolo
10:34:12 <dcoutts_> ok
10:34:18 <waern> see if I can get his patch
10:34:23 <waern> and take it from there
10:34:27 <byorgey> newtype WeirdFunction a = WF (a -> WeirdFunction a)
10:35:10 <byorgey> perfectly legitimate =)
10:35:32 <takamura> hi
10:35:43 <byorgey> hi takamura
10:36:04 <vincenz> > maxBound :: Int
10:36:05 <lambdabot>  2147483647
10:36:59 <kaol> > maxBound :: Char
10:37:00 <lambdabot>  '\1114111'
10:37:44 <byorgey> MyCatSchemes: does that help?
10:40:25 <geocalc> @hoogle Distribution.Simple.Program
10:40:25 <lambdabot> No matches, try a more general search
10:40:55 <geocalc> @hoogle Distribution
10:40:56 <lambdabot> No matches found
10:41:03 <pgavin> ping
10:41:28 <pgavin> dcoutts_: hia
10:41:39 <dcoutts_> pgavin: hi
10:41:56 <pgavin> how was the hackathon?
10:41:57 <dcoutts_> pgavin: we looked at your code during the hackathon, specifically kolmodin did
10:42:03 <dcoutts_> pgavin: it was great fun
10:42:09 <pgavin> great
10:42:16 <pgavin> I wish I could've been there
10:42:21 <pgavin> but there's an ocean in the way :)
10:42:25 <shapr> @yow !
10:42:25 <lambdabot> Where's th' DAFFY DUCK EXHIBIT??
10:42:26 <dcoutts_> and nominolo amd kolmodin and I discussed deps at great length
10:42:33 <dcoutts_> pgavin: heh, right
10:42:47 <dcoutts_> pgavin: you missed out on nice German wheat beer too :-)
10:43:01 <pgavin> dcoutts: aww, darn :)
10:43:15 <pgavin> well, if I was there I would've brought some of my homebrew :)
10:43:15 <takamura> I have a question: I'm calling LaTeX from a Haskell program on Windows using the "system" function, but latext shows a window with logging messages. This confuses the modal windows of my program and causes errors. I dissabled latex messages with --quiet option, but still, the window pops up (showing "entering extended mode"). Somebody knows how to disable this behaviour?
10:44:05 <pgavin> takamura: I would suppose that's because windows doesn't really have the concept of a proper stdout/stdin
10:44:24 <dcoutts_> takamura: on windows calling a command line prog always opens a terminal unless it was already called from a terminal
10:44:29 <pgavin> takamura: perhaps you can create a pif or something for the latex execcutable
10:44:40 <allbery_b> more that cmd.exe likes to open windows ==dcoutts_
10:44:43 <dcoutts_> takamura: to override that behaviour requires using win32 functions directly
10:45:13 <dcoutts_> allbery_b: I bet if you use rawSystem you'd see the same behaviour
10:45:26 <dcoutts_> rawSystem bypasses the command interpreter, ie cmd.exe
10:45:29 <geocalc> ./Setup.lhs:9:7:
10:45:29 <geocalc>     Could not find module `Distribution.Simple.Program':
10:45:29 <geocalc>       where is this module ???
10:45:35 <takamura> win32 functions can be called from haskell?
10:45:37 <Zao> Cabal, isn't it?
10:45:44 <allbery_b> that's part of cabal, yes
10:45:45 <pgavin> dcoutts_: is it a good time for me to get write access on the gtk2hs repo?
10:45:46 <dcoutts_> geocalc: Cabal-1.2.x
10:45:47 <pgavin> takamura: yes
10:45:54 <pgavin> takamura: see the ffi
10:46:03 <pgavin> takamura: it's really easy, actually :)
10:46:04 <geocalc> ok thanks
10:46:11 <allbery_b> takamura: also look at System.Win32 (IIRC)
10:46:12 <takamura> thanks, i will take a look
10:46:14 <dcoutts_> pgavin: ah, your last patch, I didn't apply it because it touched some core build files
10:46:29 <dcoutts_> pgavin: perhaps you could look at that and tell me what changes were necessary
10:46:34 <pgavin> dcoutts_: hmm, ok
10:46:38 <allbery_b> ...and I thought that was cmd.exe but I admit to not knowing windows guts very well
10:46:39 <pgavin> dcoutts_: lemme check
10:46:47 <dcoutts_> pgavin: I'm perfectly happy to blindly apply patches that only modify gnomevfs or gstreamer
10:47:20 <pgavin> dcoutts_:
10:47:20 <dcoutts_> pgavin: if you want core changes too, please separate those out into self-contained patches with a description
10:47:36 <pgavin> dcoutts_: I generally do try to separate them out like that
10:47:41 <pgavin> dcoutts_: I may have missed one
10:48:19 <dcoutts_> pgavin: aye, it sounded like in your patch description that you were not really intending to modify build files in non-trivial ways
10:48:21 <pgavin> dcoutts_: there's one patch that touches Makefile.am, but I just made the heirarchyGen not be compiled with splitobs
10:48:30 <kaol> how would I unescape URIs? (ie. turn %## into a character) I can't recall how an Int was turned into a Char, and I'd need to parse a hexadecimal digit too.
10:48:46 <dcoutts_> pgavin: could you point me at the patch you want applied and I can look at it right now
10:48:53 <pgavin> dcoutts_:  err, heirarchyGenGst, rather
10:50:23 <pgavin> dcoutts_: there's a big patch tagged "ou are no longer marked as being away
10:50:23 <pgavin> *** You are no longer marked as being away
10:50:23 <pgavin> *** You are no longer marked as being away
10:50:23 <pgavin> *** You are no longer marked as being away
10:50:28 <pgavin> ER
10:50:31 <pgavin> hrrm
10:50:55 <dcoutts_> pgavin: ? :-)
10:51:00 <pgavin> tagged "gstreamer: lots of new code"
10:51:05 <pgavin> sorry, paste error :)
10:51:28 <pgavin> that patch touches makefile.am and configure,ac, but only gstreamer stuff
10:51:38 <pgavin> that patch is pretty important
10:52:32 <dmwit> Damn, people in here talk about their wives and girlfriends?
10:52:36 <dmwit> I miss all the juicy stuff.
10:52:38 <pgavin> that one and the "make heirarchyGenGst not use splitobjs" patch are the only ones that touch the build system
10:52:45 <kaol> > readHex "ab" -- found that one at least
10:52:47 <lambdabot>  [(171,"")]
10:53:02 <kaol> @hoogle Int -> Char
10:53:03 <lambdabot> Char.chr :: Int -> Char
10:53:03 <lambdabot> Char.intToDigit :: Int -> Char
10:53:03 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
10:54:52 <allbery_b> ...and toEnum :: Int -> Char
10:55:35 <MyCatSchemes> @pl (\x y->takeWhile isJust $ (\a b->[Nothing]))
10:55:35 <lambdabot> const (const (takeWhile isJust (const (const [Nothing]))))
10:55:58 <MyCatSchemes> @pl (\x y->takeWhile isJust $ (\a b->[(Just a),(Just b),Nothing]))
10:55:58 <lambdabot> const (const (takeWhile isJust ((. ((: [Nothing]) . Just)) . (:) . Just)))
10:56:02 <pgavin> dcoutts_: one thing that might make this stuff easier is to split the top level makefile into parts that are included
10:56:23 <dcoutts_> pgavin: aye perhaps
10:56:26 <pgavin> dcoutts_: that way if e.g. I need to add modules for gstreamer, it only touches the included part
10:56:56 <dcoutts_> pgavin: though I like to keep an eye on the build system changes generally since it's a tad fragile
10:56:58 <dcoutts_> :-)
10:57:08 <pgavin> dcoutts_: of course :)
10:57:20 <dcoutts_> pgavin: until we get it all building with cabal of course :-)
10:57:28 <pgavin> dcoutts_: I generally build at least once all the way through before sending a patch
10:57:30 * MyCatSchemes frowns at \bot.
10:57:35 <pgavin> dcoutts_: right :)
10:58:38 <dcoutts_> pgavin: oh I'm sure it actually builds for you, that's not a problem, experience has taught me that building on random different platforms is more trouble
10:58:54 <pgavin> dcoutts_: oh, right, of course :)
10:59:34 <vincenz> > let foo'bar x = x + 2 in foo'bar 4
10:59:34 <pgavin> maybe I should set up virtualbox VMs for 3 or 4 distros for testing
10:59:35 <lambdabot>  6
10:59:41 <vincenz> spiffy, you can have ' in names
10:59:44 <dcoutts_> pgavin: no need really
10:59:58 <dcoutts_> pgavin: so I'm around for the next hour, so if you can point me at what you want reviewed and applied I can do that now
11:00:00 <pgavin> dcoutts_: yeah, I wasn't completely serious
11:00:11 <pgavin> dcoutts_: oh, ok..
11:00:21 <pgavin> well, pretty much everything :)
11:00:24 <dmwit> :t par
11:00:26 <lambdabot> forall a b. a -> b -> b
11:00:41 <pgavin> but the patches labelled gtk can wait
11:00:47 <dcoutts_> pgavin: so is the patch in an existing email?
11:01:01 <pgavin> yeah, I think its waiting in the moderator queue
11:01:17 <dcoutts_> oh, ok, can you post it somewhere so we can bypass that?
11:01:22 <pgavin> oh, sure
11:01:27 <dcoutts_> I'm not actually moderator
11:05:09 <saccade> is there a superordinate category that contains both arithmetic and geometric progressions?
11:05:49 <saccade> one that captures the property that you can choose every n'th element and get a similar kind of uniform progression
11:06:50 <pgavin> dcoutts_: http://www.eng.fsu.edu/~pgavin/gtk2hs.gstreamer-20071008.dpatch.bz2
11:06:53 <lambdabot> http://tinyurl.com/28prjx
11:07:16 <dcoutts_> pgavin: ok
11:09:59 <ADEpt> does anyone have a good example of this: "an alternative way to deal with multiple transformers of the same type (i.e. many states, environments, or output) is to parameterize the transformer operations by an inedx specifying *which* state (environemnt, etc) you want to access, or update. the indexes are basically just used for their types, and one hopes that can be optimized away," (taken from: http://www.mail-archive.com/haskell-cafe@haskell.org/msg02534.h
11:11:52 <shapr> So whenever I use monad transformers, I start to sing the "transformers, more than meets the eye" theme song in my head...
11:12:02 <shapr> Does that happen to anyone else?
11:12:46 <mrd> she's not just a spaceship ... she's a transformer
11:13:48 <dcoutts_> pgavin: ah this is the one I didn't apply last time:
11:13:48 <dcoutts_> Thu Sep  6 22:21:29 BST 2007  Peter Gavin <pgavin@gmail.com>
11:13:48 <dcoutts_>   * gstreamer: lots of new code
11:14:03 <mrd> spaceball 1 has now become .. megamaid
11:14:09 <dcoutts_> as it touches Makefile.am configure and ./tools/hierarchyGenGst/TypeGen.hs quite a lot
11:14:19 <bos> the gstreamer stuff in gtk2hs doesn't currently build.
11:14:43 <dcoutts_> bos: we'll see if it builds with this big set of patches from pgavin
11:14:51 <dcoutts_> I'm currently reviewing them
11:14:52 <bos> ok, cool
11:17:35 <pgavin> dcoutts_: right, it does touch a lot of stuff, sorry about that
11:17:50 <dcoutts_> pgavin: what's the TypeGen stuff for?
11:17:57 * dcoutts_ is currently reading that code
11:17:59 <pgavin> bos: could you send me the error messages?
11:18:22 <pgavin> dcoutts_: umm, well, gstreamer has a hierarchy that isn't rooted on GObject
11:18:35 <bos> pgavin: not easily. i was doing the build while rpm packaging, and don't have logs.
11:18:38 <pgavin> they actually created a new root object GstMiniObject
11:18:43 <dcoutts_> pgavin: ok
11:19:00 <pgavin> bos: hmm, can you send me the spec file?
11:19:25 <bos> pgavin: where to?
11:19:29 <pgavin> pgavin@gmail.com
11:19:34 <bos> kk
11:19:45 * vincenz winces
11:19:54 <pgavin> bos: which distro are you using?
11:20:05 <bos> fedora, with a ghc 6.8.0 snapshot
11:20:20 <pgavin> ah
11:20:23 <pgavin> that might be why
11:20:33 <pgavin> I haven't built against 6.8 yet
11:20:36 <pgavin> just 6.6
11:20:38 <bos> i don't think so. the error looked quite straightforward and not compiler-related.
11:20:39 <glen_quagmire> isn't 6.6.1 latest?
11:20:53 <bos> pgavin: sent
11:20:57 <pgavin> bos: ok, well, I'll check it out
11:21:20 <bos> pgavin: in the spec file i sent you, i'm not configuring with --enable-gstreamer because of the build problem
11:21:39 <pgavin> right
11:22:34 <pgavin> bos: so are you using a home-rolled rpm for ghc 6.8?
11:23:38 <bos> pgavin: i comaintain the fedora package of ghc
11:24:03 <bos> so it's not homebuilt, it's the official fedora ghc 6.8.0 snapshot
11:24:47 <pgavin> bos: ah, ok :)
11:24:51 <pgavin> didn't realize :)
11:25:02 <geocalc> Preprocessing executables for alex-2.1.0...
11:25:02 <geocalc> Setup.lhs: alex command not found ??? howto solve this ???
11:25:38 <pgavin> geocalc: install alex :)
11:25:49 <geocalc> i try
11:26:02 <pgavin> geocalc: what OS/distro?
11:26:25 <geocalc> linux paldo
11:26:26 <bos> geocalc: just because it complains about no alex doesn't mean it needs alex
11:27:03 <pgavin> yeah, those messages are confusing :)
11:27:06 <bos> "Setup configure" has this unfortunate habit of checking for, and complaining about, things it doesn't need :-(
11:27:40 <pgavin> bos: oh, just to let you know, the gstreamer code is 99% untested :)
11:27:49 <geocalc> confusing yes
11:28:06 <pgavin> and the gnomevfs code is 95% untested :)
11:29:46 <geocalc> mmh the problem is the build aborted
11:31:50 <geocalc> bad alex need alex to build
11:33:27 <pgavin> geocalc: your distro doesn't include an alex package?
11:35:14 <geocalc> my distro include only things building shared libs pgavin
11:38:10 <pgavin> geocalc: did you just try doing ./setup build after the ./setup configure?
11:38:26 <pgavin> geocalc: because I don't think alex really needs itself to build
11:39:03 <djfroofy> has anyone used haskell to write a distributed application? thoughts about using haskell vs. erlang for this?
11:39:19 <geocalc> the message is from build pgavin
11:39:53 <bos> djfroofy: i don't know of anybody doing anything significant yet, so there's little to no library support. erlang has substantial library support right now.
11:40:04 <pizza_> djfroofy: an excellent question
11:40:34 <bos> haskell doesn't have any equivalents of mnesia or OTP yet, although HAppS could be argued to provide some of what mnesia gives you.
11:41:29 <shapr> but it's not distributed
11:42:18 <bos> well, it has that multi-master MACID monad doodad, right?
11:42:34 <shapr> yeah
11:43:25 <djfroofy> bos: thanks, that's what i thought.  well i'm using erlang for the application my inquiry concerns.  it isn't as elegant, but the shared nothing message passing semantics seems ideal for a distributed app.
11:43:57 <geocalc>     Could not find module `Distribution.Setup':
11:43:58 <geocalc>       it is a member of package Cabal-1.1.6.2, which is hidden now i have this message from the cabal alex at configure how i unhidd ???
11:44:13 <bos> djfroofy: you can do message passing locally in haskell, just not over the network.
11:44:51 <djfroofy> bos: yeah. i like how erlang makes this `mostly' transparent.
11:46:17 <pgavin> geocalc: ghc -package Cabal-1.1.6.2 --make Setup.lhs -o setup
11:46:17 <bos> we can do mostly transparent in haskell, too. just nobody has. actually, that's not true. there have been a few initiatives, but they happened long before anybody really cared, and have bitrotted.
11:46:49 <geocalc> thanks pgavin
11:47:16 <bos> i know of glasgow distributed haskell (fairly silly idea, only a vehicle for publication and funding), port-based distributed haskell (dates to 2000, overly complex, dead), and something ChilliX did around 2000 too, also dead.
11:48:54 <djfroofy> bob: does any haskell lib have mostly cross-platform asynchronous network io support using kernel polling (epoll, select ...)?
11:49:09 <djfroofy> bos: sorry, bos, not bob
11:49:26 <shapr> I wonder if the recently release network-bytestring could be used for that?
11:49:30 <bos> yeah, the standard network package does that.
11:50:12 <djfroofy> the standard network package uses select if available? where can i go to read about this?
11:50:15 <bos> djfroofy: see also http://www.seas.upenn.edu/~lipeng/homepage/unify.html
11:50:17 <lambdabot> Title: Unifying events and threads
11:50:22 <bos> djfroofy: it always uses select.
11:50:39 <etnt`> so where is put in the state Monad described ? been trying to find it via hoogle...
11:50:58 <bos> the haskell networking model is that you fire off a thread per connection, and they're very lightweight. much like erlang, in fact.
11:51:08 <oerjan> @src MonadState
11:51:08 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:51:14 <djfroofy> bos: user level threads ... yeah i know this
11:51:17 <oerjan> @hoogle MonadState
11:51:18 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
11:51:41 <dcoutts_> bos: we need to form a consortium of hackers with good taste to define a quality collection of packages, ie core libs plus others of high standard
11:51:57 <bos> djfroofy: so down in the bowels of the implementation, GHC's runtime uses select to see which threads have IO pending
11:51:57 <byorgey> etnt`: note that put is a function in the MonadState class, so its definition is different for each monad that is an instance of MonadState.
11:52:04 <bos> dcoutts_: yeah
11:52:14 <dcoutts_> bos: now that the 'standard' bundled libs are ever smaller we need some other mechanism for defining what's definately ok to use and ship
11:52:23 <byorgey> etnt`: but you might want to look at, e.g. Control.Monad.State.Lazy
11:52:32 <djfroofy> bos: nice.  but you can't compile GHC to use kqueue for BSD or epoll?
11:52:42 <bos> djfroofy: i'm working on layering the low-level select code on top of a portable wrapper that will use more scalable mechanisms like epoll or kqueue
11:52:54 <byorgey> etnt`: are you looking for some code, or for a text description/tutorial type thing?
11:53:11 <bos> dcoutts_: cpan solves this quite well by allowing people to write reviews of, and vote on, packages
11:53:18 <bos> dcoutts_: it's a nicely decentralised approach
11:53:20 <djfroofy> bos: very intriguing.  i'd like to know when this is done.
11:53:26 <dcoutts_> bos: so hackage allows lots of experiments but we need some mechanism for identifying and maintaining quality packages
11:53:32 <bos> djfroofy: given my workload, it's not rushing along
11:53:46 <dcoutts_> bos: right, just some more info and stats on hackage would help
11:54:14 <djfroofy> bos: i definitely understand. i'd help if i could only wrap my brain more around the language ;)
11:54:24 <etnt`> byorgey: well I'm using the State monad and wanted to know how put operates on it
11:54:50 <dcoutts_> bos: but I can't help thinking we need something additional that's a bit more organised for stamping some collection of packages as working together and being of a high standard, documented etc
11:55:08 <dcoutts_> bos: and that does not need to be tied to release schedules of ghc etc
11:55:12 <byorgey> etnt`: ah, ok.  well, let's start here:
11:55:14 <byorgey> @type put
11:55:17 <bos> dcoutts_: yes, that would make some sense. essentially a distribution of haskell modules.
11:55:20 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
11:55:27 <bos> actually, not some sense, lots of sense.
11:55:30 <dcoutts_> bos: exactly, a distribution
11:55:31 <EvilTerran> @src State
11:55:31 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:55:33 <byorgey> the important part is s -> m ()
11:55:47 <byorgey> put takes one argument of whatever type the state is
11:56:02 <byorgey> and it results in a monadic action which updates the state.
11:56:05 <bos> dcoutts_: in the editing world, that's why i stick with xemacs over emacs. it has a "sumo" package that bundles loads of useful stuff in one place.
11:56:45 <dcoutts_> bos: which partly helps with distribution, but more importantly with letting other people decide what is a consistent collection of high quality code
11:56:53 <waern> dcoutts_: has pkg-config-depends been implemented in cabal yet?
11:57:01 <dcoutts_> waern: yes
11:57:11 <waern> dcoutts_: in 1.2.0?
11:57:14 <dcoutts_> yes
11:57:31 <bos> dcoutts_: the other thing that a distribution might do is encourage people to maintain their packages more actively.
11:57:40 <etnt`> byorgey: hm...ok
11:57:59 <bos> which would be valuable. there's quite a bit of half-finished stuff on hackage, at least some of which i'm responsible for :-)
11:58:09 <dcoutts_> bos: aye, eg it could set goals and publish info on testing, coverage, documentation, etc etc
11:58:26 <byorgey> etnt`: is there some specific code you're having trouble with?  or just trying to understand it in general?
11:58:48 <dcoutts_> bos: though all that infrastructure could be used on hackage for all packages, but we'd require packages in the distro to achieve certain levels
11:59:10 <byorgey> etnt`: I could also try showing you a few examples if you want
11:59:23 <dcoutts_> bos: eg, packages with QC/HUnit tests, hackage should display info about the tests, and use hpc to show test coverage
11:59:41 <dcoutts_> bos: once you measure it an publish the info it encourages improvements by maintainers
12:00:12 <etnt`> byorgey: well I had a session the other evening with dmwit and yitz where I tried to transform a simple program into using the State monad
12:00:40 <etnt`> byorgey: it almost was finished, I can paste to hpaste.org how far I got
12:00:46 <byorgey> etnt`: ok, sure
12:00:58 <bos> dcoutts_: exactly
12:02:54 <hpaste>  etnt' pasted "using monads" at http://hpaste.org/3207
12:03:30 <waern> dcoutts_: ah, it's called pkgconfig-depends.
12:03:41 <etnt`> byorgey: there you have it
12:03:48 <dcoutts_> waern: yep
12:03:58 <hpaste>  sclv pasted "A pass at a difflike utility" at http://hpaste.org/3208
12:04:07 <dcoutts_> waern: @tell me if it works for you, but right now I'm off!
12:04:17 <waern> dcoutts_: ok!
12:04:36 <sclv> i just put a toy i'm working on for a char-by-char diff with handy output formats (eventually) on hpaste.
12:04:55 <sclv> style/efficiency comments more than welcome
12:05:42 <sclv> i'm working with sequences so i don't see any way around that ugly where clause at the end of the lcs section
12:05:59 <sclv> (except maybe that for what i'm doing, a list is just as efficient)
12:07:04 <Saizan> sclv: a :> ar = viewl as -- ?
12:07:57 <sclv> Saizan: ooh, the :> can be used as a deconstructor? of course. how dim of me.
12:08:58 <Saizan> being a constructor you can pattern match on it
12:09:10 <etnt`> byorgey: if I run: sc2 [1,2,3,4,5] ghci complains about: No instance for (Show (State S ()))
12:09:50 <etnt`> byorgey: so I was thinking I should make a function: State S () -> S
12:10:18 <etnt`> byorgey: but I'm probably not thinking straight...
12:12:02 <Saizan> ?type runState
12:12:04 <lambdabot> forall s a. State s a -> s -> (a, s)
12:12:15 <Saizan> ?type evalState
12:12:17 <lambdabot> forall s a. State s a -> s -> a
12:12:22 <Saizan> ?type execState
12:12:23 <lambdabot> forall s a. State s a -> s -> s
12:14:11 <byorgey> etnt`: sorry, I got a phone call
12:14:20 <etnt`> byorgey: np
12:14:21 <byorgey> etnt`: give me a minute to read what you posted
12:16:42 <paczesiowa> can I use classes as types as in data A = A Integral Integral ?
12:16:57 <byorgey> etnt`: ok, I see. you want a function like runState.
12:17:00 <byorgey> @type runState
12:17:02 <lambdabot> forall s a. State s a -> s -> (a, s)
12:17:13 <byorgey> @type execState
12:17:15 <lambdabot> forall s a. State s a -> s -> s
12:17:23 <byorgey> there, execState is probably what you want actually.
12:17:36 <oerjan> paczesiowa: no
12:17:40 <byorgey> it encompasses both your 'initialize' and getting the state out at the end.
12:18:03 <paczesiowa> oerjan: even with some exts? and why?
12:18:28 <etnt`> byorgey: hm, so what should the second argument be ?
12:18:34 <ski> paczesiowa : mayhap you want `data Integral a => A a = A a a' ?
12:19:13 <hpaste>  byorgey annotated "using monads" with "using execState" at http://hpaste.org/3207#a1
12:19:33 <byorgey> etnt`: the initial state.
12:20:17 <etnt`> byorgey: aha, let me see...
12:20:33 <oerjan> paczesiowa: not without wrapping it in an existential data type
12:20:51 <oerjan> ski's suggestion is not quite the same either
12:21:33 <byorgey> etnt`: also, instead of 'do { s <- get; put s }' you could just say 'return ()'
12:21:46 <ski> (elaboration on intended usage could be handy)
12:21:52 <paczesiowa> ski: but that requires both a to be the same type
12:22:08 <sclv> @src putStrLn
12:22:08 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
12:22:11 <EvilTerran> that's something i don't quite get; data Foo a => Bar a = Bar a; data Bar a = Foo a => Bar a; and data Bar a = Bar (Foo a => a) seem to all be subtly different, but i'm not sure how they differ
12:22:22 <ski> paczesiowa : indeed .. it wasn't clear (to me) whether that was intended or not
12:22:43 <etnt`> byorgey: aah..that's wonderful, it works :-)
12:22:53 <byorgey> excellent =)
12:22:53 <paczesiowa> ski: can you turn that definition to e.g. Show a,b = A a b
12:23:06 <etnt`> byorgey: many thanks!
12:23:13 <byorgey> etnt`: you're welcome!
12:23:14 <paczesiowa> ski: so I can have A 1 "foo"
12:23:17 <ski> data (Show a,Show b) => A a b = ..a..b..
12:23:17 <oerjan> EvilTerran: i am not sure any but the first is legal
12:23:27 <byorgey> etnt`: are you aware that the function "isOdd" already exists?
12:23:28 <EvilTerran> I seem to recall that they all parse
12:23:30 <byorgey> @type odd
12:23:32 <lambdabot> forall a. (Integral a) => a -> Bool
12:23:36 * roconnor continues to work on porting Phooey to gtk2hs
12:23:36 <paczesiowa> ski: thx, I tried with two (=>)
12:23:44 <EvilTerran> i may be missing forall.s
12:23:51 <etnt`> byorgey: I do now... :-)
12:24:46 <etnt`> byorgey: I've read so many Monad papers, where the best one probably is Monads in Func.Prog by Wadler, it all seem so obvious..
12:25:15 <byorgey> etnt`: yes, but actually using them is a different matter... it just takes some practice =)
12:25:29 <etnt`> byorgey: exactly!
12:25:53 <byorgey> etnt`: also -- not to burst your bubble, you've learned a lot about the State monad etc. and that's worthwhile -- but sumCount could also be implemented much more simply
12:26:07 <ski> EvilTerran : i think the last one isn't allowed in this case (at least one class arg must be univ. quantified over the argument type)
12:26:24 <EvilTerran> that might be what i was thinking of
12:26:40 <etnt`> byorgey: well yitz showed me an example that I'm still trying to decipher :-)
12:27:02 <byorgey> > let sumCount xs = (sum odds, length odds) where odds = filter odd xs   in sumCount [1..9]
12:27:04 <lambdabot>  (25,5)
12:27:23 <byorgey> etnt`: did yitz's example involve things like ***?
12:27:57 <roconnor> @hoogle ConnectedId
12:27:57 <lambdabot> No matches found
12:28:03 <roconnor> @hoogle ConnectId
12:28:03 <lambdabot> No matches found
12:28:17 <hpaste>  etnt' annotated "using monads" with "yitz using monads example" at http://hpaste.org/3207#a2
12:28:41 <etnt`> byorgey: look at the bottom
12:28:48 <foo-nix> I am using hugs at my university and at home. At the university I have the feature that I can use arrow keys to navigate through commands and stuff, if I do this at home I will get [[A^[[B^[[D^[[C stuff. Is there some option is hugs to set this, or is it the terminal I use (konsole and xterm both have it, whilst they dont have it at my uni).
12:29:54 <foo-nix> For example I could press the up arrow to get the last command I (tried) to execute, at home this will give ^[[B
12:30:16 <conal> roconnor: glad to hear it :)
12:30:24 <fasta> I have a file containing #define FOO 1 and at the ghc commandline I say -DFOO 0, and I have macros that expand when FOO == 1, but still the macros expand. Why?
12:30:43 <Zao> fasta: Because the source file redefines it.
12:30:44 <etnt`> byorgey: you see, I've written a little Haskell to Erlang compiler, but my Haskell code sucks big time, so I'm trying to improve my Haskell technique...
12:30:55 <fasta> Zao: I thought the compiler had precedence.
12:31:01 <fasta> Zao: so, that believe is wrong?
12:31:08 <paczesiowa> foo-nix: what system do you use? looks like readline problem
12:31:12 <Zao> fasta: They just predefine things.
12:31:18 <fasta> Zao: ok, thanks
12:31:34 <byorgey> etnt`: I see.
12:31:45 <roconnor> conal: Is the only way to safely make an event is to use mkEvent?
12:31:48 <foo-nix> paczesiowa: I have a 32bit sempron (1600+) and I use opensuse 10.2 with both kde and fluxbox (both have this).
12:32:06 <conal> roconnor: looking ...
12:32:15 <paczesiowa> foo-nix: maybe try using ghci instead of hugs?
12:32:18 <fasta> Zao: what's the value of an unset variable?
12:32:21 <foo-nix> paczesiowa: The arrow do work when I am just in konsole or xterm
12:32:31 <foo-nix> paczesiowa: Ok, let met try...
12:32:54 <roconnor> conal: I suspect just using Cont is dangerous?
12:32:59 <foo-nix> paczesiowa: Ah, that works.
12:33:18 <byorgey> > let sumCount = arr filter >>> (sum &&& length) in sumCount [1..9]
12:33:19 <lambdabot>  Couldn't match expected type `[a] -> [a]'
12:33:20 <foo-nix> paczesiowa: Thanks, but would you know a way to fix my hugs, or should I just go ask my system admin?
12:33:21 <Cale> foo-nix: Maybe hugs wasn't built with readline?
12:33:37 <byorgey> > let sumCount = arr (filter odd) >>> (sum &&& length) in sumCount [1..9]
12:33:38 <lambdabot>  (25,5)
12:33:49 <Cale> You can run  ldd `which hugs`  to find out.
12:33:50 <foo-nix> Cale: I didn't compile it, it was packaged, but I'll see if I can compile it myself...
12:33:56 <conal> roconnor: hm.  it's more about efficiency than safety, and only if you expect to have disappearing "clients" of an event.
12:34:03 <paczesiowa> foo-nix: ghci is better than hugs anyway, and if you plan to stay with haskell for a while (we hope you will:) you'll end up using ghc anyway
12:34:08 <etnt`> byorgey: nice :-)
12:34:14 <hpaste>  byorgey annotated "using monads" with "two alternate implementations of sumCount" at http://hpaste.org/3207#a3
12:34:37 <byorgey> etnt`: two nice, simple implementations for you =)
12:34:45 <conal> roconnor: ... assuming memory is managed safely, which doesn't appear to be entirely true right now for wxHaskell.
12:34:53 <foo-nix> paczesiowa: My fp teacher asked us to use hugs, but I dont think He has something against gchi, I will see if I can set it up in eclipse.
12:35:00 <roconnor> conal: okay, maybe I will use Cont for my first attempt.
12:35:09 <foo-nix> Cale, paczesiowa: Thanks a lot guys. You saved my day.
12:35:12 <conal> roconnor: but in that case, the "ephemeral" stuff is not a solution, since it runs the finalizer too late.
12:35:16 <roconnor> once I know what I'm doing, things may become more clear.
12:35:23 <conal> roconnor: sure.
12:35:27 <etnt`> byorgey: wow arrows...cool :-)
12:35:30 <ski> roconnor : what are you doing ?
12:35:49 <roconnor> conal: I'm attempting to port Phooey to gtk2hs
12:35:53 <roconnor> ski: I'm attempting to port Phooey to gtk2hs
12:35:58 <paczesiowa> foo-nix: lucky you:D I started today my fp classes but they use ocaml, and ocaml doesn't work with readline so I'm doomed to using files and loading/reloading
12:36:03 <foo-nix> Cale, which hugs gave the /usr/bin/hugs executable.
12:36:12 <roconnor> ski: ... not that I know DataDriven, wxHaskell, or gtk2hs
12:36:18 <foo-nix> paczesiowa: ouch.
12:36:22 <roconnor> it's a bit of a learning experience
12:36:34 <foo-nix> paczesiowa: Might consider installing some stuff in your homedir.
12:36:38 <Cale> foo-nix: yeah, now run ldd on that
12:36:45 <byorgey> etnt`: also, did you see my comment about 'do { s <- get; put s }'?
12:36:50 <conal> roconnor: i'll be glad to help if you run into difficulties.
12:37:00 <Cale> foo-nix: that backquoted thing is supposed to run which hugs to get the location of the executable to pass to ldd
12:37:01 <roconnor> conal: :)
12:37:11 <ski> paczesiowa : ledit ?
12:37:16 <etnt`> byorgey: yes, thx, I changed it in my code
12:37:19 <Cale> foo-nix: which will tell you which libraries it's linked against
12:37:39 <byorgey> etnt`: ok.  also, 'do { put (0,0} }' is the same as just 'put (0,0)'.
12:38:01 <foo-nix> Cale: I see some libs....
12:38:05 <foo-nix> What should I look for?
12:38:10 <Cale> foo-nix: libreadlin
12:38:10 <paczesiowa> ski: no idea what's that ledit, some kind of editor/ide? on ocaml classes they "force" us to use xemacs
12:38:13 <Cale> foo-nix: libreadline
12:38:14 <etnt`> byorgey: ok, I see
12:38:16 <foo-nix> I see libncurses, is that the one?
12:38:19 <Cale> nope
12:38:28 <foo-nix> no libreadline
12:38:30 <hpaste>  birkenfeld annotated "using monads" with "little fix in the arrow example" at http://hpaste.org/3207#a4
12:38:37 <Cale> yeah, so that's why it doesn't work
12:38:44 <foo-nix> I will need to get libreadline from somewhere and install it?
12:38:55 <paczesiowa> foo-nix: you have libreadline
12:39:13 <Cale> You clearly have libreadline, because it's working in ghci and bash
12:39:14 <paczesiowa> foo-nix: just your version of hugs isn't compiled iwth support for it
12:39:25 <foo-nix> paczesiowa: So I need to recompile it?
12:39:35 <byorgey> ah, thanks birkenfeld++
12:39:42 <Cale> foo-nix: Unless there's another package you could use, yeah.
12:39:42 <ski> paczesiowa : http://cristal.inria.fr/~ddr/ledit/  .. i happen to use that with ocaml
12:39:43 <lambdabot> Title: ledit
12:40:09 <paczesiowa> foo-nix: I wouldn't bother unless your teacher doesn't force you to, just stick with ghci
12:40:09 <ski> paczesiowa : it is a readline-clone wrapper
12:40:39 <byorgey> etnt`: one other thing: instead of having updateSte i | isOdd... and then updateStep i  = ...,
12:40:41 <birkenfeld> byorgey: why does it also work without "arr"?
12:40:55 <etnt`> the span between beginner code and expert code in Haskell is much bigger than in, lets say, Erlang I think
12:40:59 <byorgey> etnt`: it would be more idiomatic to say updateStep i | isOdd i = ...   | otherwise = ...
12:41:09 <foo-nix> paczesiowa: I weill, but trying to fix hugs is a nice uh, the dutch say 'uitdaging', uh, it's like.... uh competition like, sorry cant find the word.
12:41:15 <byorgey> birkenfeld: oh, right
12:41:21 <Cale> etnt: Well, that's sort of because Haskell is a research language :)
12:41:27 <paczesiowa> foo-nix: challenge?
12:41:31 <byorgey> birkenfeld: arr lifts pure functions to arrows
12:41:34 <foo-nix> paczesiowa: That's the word ;)
12:41:43 <birkenfeld> byorgey: is it because (->) is already an Arrow instance?
12:41:45 <byorgey> birkenfeld: but in this case I'm using the pure function instance of arrows
12:41:51 <byorgey> birkenfeld: right, so in this case arr = id
12:41:52 <foo-nix> paczesiowa: Well, compiling isn't that much of a chalange, and I rather stick with my distro packages.
12:41:59 <birkenfeld> ok, thanks :)
12:42:13 <roconnor> conal: in iwidget' you call attrSource before you set the initial value, but attrSource calls get to set the inital value of the source; which means the inital values source won't be the inital value passed in. ... Is this a problem?
12:42:15 <foo-nix> Well, paczesiowa and Cale, Thanks for your help. I will go funcitonal now.
12:42:20 <foo-nix> *functional.
12:42:23 <Cale> foo-nix: :)
12:42:29 <Cale> foo-nix: Ask lots of questions here :)
12:42:36 <etnt`> byorgey: ok, so otherwise is the same as True
12:42:42 <foo-nix> Cale: Oh, dont say that to a geek like me ;)
12:42:49 <foo-nix> Cale: Thanks man.
12:42:59 <byorgey> etnt`: yup
12:43:00 <ski> @src otherwise
12:43:00 <lambdabot> otherwise = True
12:43:06 <Cale> foo-nix: No problem
12:43:09 <foo-nix> I will now see if I can close some xterms, to clean up my fluxbox dock
12:43:27 <sclv> ok quick question: i have a function as such: iopen x = case x of {F -> "<B>"; S -> "<I>"; B -> "";}
12:43:37 <sclv> is there an even more compact way to do this?
12:44:12 <byorgey> sclv: well, you could define iopen by cases directly
12:44:12 <Cale> sclv: Well, it's not more compact, but the slightly more idiomatic way I think is to write your cases separately.
12:44:26 <byorgey> iopen F = "<B>"
12:44:27 <Cale> iopen F = "<B>"
12:44:30 <Cale> and so on
12:44:35 <paczesiowa> iopen F = "<B>" newline open S = "<|>" ...
12:44:49 <Cale> That was an I, not a |
12:45:18 <paczesiowa> typo:>
12:46:08 <sclv> right -- i had it that way originally and i'm trying to sacrifice idiomatic for concise. i was thinking maybe something with pattern matching on guards, but...
12:46:51 <roconnor> conal: actually, from the commented out code, it seems you delibrately moved the setting of the inital value after the attrSource call
12:46:53 <byorgey> sclv: well, otherwise I don't know of any way to make it shorter.
12:47:35 <foo-nix> sweet, I managed to set gci up such that I can code in eclipse, and press the run button to check stuff.
12:48:39 <byorgey> foo-nix: awesome =)
12:48:52 <shapr> lambdacats must show up in the next HWN!
12:49:29 <conal> roconnor: i tweaked that bit around in freiburg.  looking at attrSource (in WinEvents), it does look pretty fishy, given the "get".
12:49:48 <Cale> sclv: That's already pretty concise :)
12:50:20 <paczesiowa> shapr: yeah tail recursion kicks ass:>
12:50:24 <Cale> sclv: I suppose you could write a helper which would take the cases as parameters (essentially a fold for the type whose constructors are F,S,B)
12:51:13 <byorgey> Cale: wouldn't that end up being longer overall?
12:51:27 <Cale> byorgey: Yeah, but you might collapse some other stuff along with it.
12:51:31 <byorgey> true.
12:52:39 <hpaste>  ADEpt pasted "Trying to interleave State's" at http://hpaste.org/3209
12:52:43 <byorgey> sclv: I recommend renaming 'iopen' to 'i'.  That's four extraneous characters you can get rid of!
12:53:01 <birkenfeld> hah
12:53:08 <foo-nix> byorgey: No, eclipse catches the key event for <-, -> etc...
12:53:13 <foo-nix> ;(
12:53:29 <sclv> heh. its more the irritation of having to use braces and semis in haskell in order to fit it all on a line that irritates me
12:53:30 <byorgey> foo-nix: I bet you can turn it off though.
12:53:39 <shapr> @seen atomb
12:53:39 <lambdabot> I saw atomb leaving #haskell 6d 17h 42m ago, and .
12:53:41 <shapr> foo
12:54:05 <omnId> sclv: you can omit the braces I believe
12:54:09 <foo-nix> byorgey: Searching for it now, you should know how much my eclipse has in the preference menu.
12:54:24 <ADEpt> @seen quicksilver
12:54:24 <lambdabot> quicksilver is in #haskell and #ghc. I last heard quicksilver speak 3h 46m 27s ago.
12:54:25 <omnId> > case 1 of 1 -> "yes"; 2 -> "no"
12:54:27 <lambdabot>  "yes"
12:54:35 <birkenfeld> hmmm... iopen = flip lookup [(F, "<B>"), (S, "<I>"), (B, "")] ?
12:54:37 <ADEpt> @seen int-e
12:54:37 <lambdabot> I saw int-e leaving ##logic, #ghc, #haskell-overflow and #haskell 4h 51m 33s ago, and .
12:54:37 <byorgey> foo-nix: oh, I know, I use eclipse at work =)
12:54:49 <omnId> @type lookup
12:54:51 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
12:54:55 <omnId> you'd need fromJust too
12:54:59 <birkenfeld> right
12:55:22 <sclv> for a bigger dictionary that sort of thing might make sense
12:56:43 <sclv> the other tiny irritation (and this is all because i've just fallen so in love with haskell's sugar that i even care) is the need for "foo x = case x of" when it seems there'd be some handy way to reduce this. i seemed to recall a pattern matching in guards proposal/ghc extension that could knock some of it down
12:57:16 <omnId> It wouldn't help in this case
12:57:22 <birkenfeld> when do you need "foo x = case x of"?
12:57:25 <omnId> foo x | S <- x = ...
12:58:07 <birkenfeld> isn't that just multiple "foo <pattern here> = "?
12:58:15 <omnId> cases and lambdas are the meat and potatoes of haskell expressions :)
12:58:46 <paczesiowa> why can't I use smth like this instance Num a => Expresable a where...?
12:58:53 <Cale> birkenfeld: yeah
12:59:01 <omnId> birkenfeld: The guard match lets you omit the function/parameter in subsequent cases.
12:59:05 <mauke> because that might not terminate
12:59:15 <omnId> birkenfeld: so it's not much different than "case x of ..."
12:59:30 <paczesiowa> mauke: what could not terminate?
12:59:36 <roconnor> @seen dcoutts_
12:59:36 <lambdabot> dcoutts_ is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts_ speak 55m 29s ago.
12:59:48 <mauke> paczesiowa: type checking
13:00:06 <omnId> instance Eq a => Eq a where (==) = (==)
13:00:14 <foo-nix> hehe, who called him lambdabot?
13:00:15 <birkenfeld> must be an individual flavor thing
13:00:28 <Heffalump> foo-nix: shapr, I think.
13:00:37 <foo-nix> :)
13:00:39 <foo-nix> rofl
13:00:53 <paczesiowa> but I can use instance Foo a => Foo [a] where...
13:00:54 <mauke> I see instance G x => F x as a function definition: f x = g x
13:00:54 <nominolo> lambdabot is a she
13:01:04 <omnId> @quote female
13:01:05 <lambdabot> lambdabot says: Of course i'm female
13:01:09 <shapr> Heffalump: Pseudonym
13:01:14 <mauke> paczesiowa: yes, because that corresponds to f (C x) = g x
13:01:29 <mauke> paczesiowa: i.e. the function argument gets smaller, so you know it'll terminate somewhere
13:02:07 <paczesiowa> and what if I know that it terminates?
13:02:22 <dmwit> -fundecidable-instances?
13:02:36 * dmwit doesn't actually know
13:02:38 <omnId> -fallow-..., I think
13:02:40 <mauke> yes
13:02:45 <EvilTerran> yeah, or {-# LANGUAGE UndecidableInstances #}
13:02:52 <EvilTerran> er, #-}
13:03:22 <EvilTerran> the coverage condition's a slightly crude way of ensuring termination
13:03:51 <omnId> paczesiowa: I guess the problem is that some client of your module might define instance Expressable a => Num a where ..., and bam, infinite loop.
13:03:53 <EvilTerran> but it does mean you stop and think about your code before you disable it
13:04:11 <paczesiowa> -fallow-undecidable-instances and -fglasgow-exts helped
13:04:46 <paczesiowa> I'm not going to sell that code, just having some fun (isn't it the way it should be?)
13:05:18 <omnId> so -fallow-undecidable-instances and being careful is fine :)
13:05:33 <roconnor> my new iwidget' type-checks.  That's enough for tonight.  Time for bed.
13:05:51 <conal> roconnor: :)  sleep well.
13:07:23 <vincenz> night roconnor
13:12:56 <Mitar> are haskell character literal escape codes in octa or decimal
13:12:57 <Mitar> ?
13:13:03 <Mitar> for example '\026'
13:13:30 <dmwit> > ord 'a'
13:13:31 <lambdabot>  97
13:13:36 <dmwit> > '\97'
13:13:37 <lambdabot>  'a'
13:13:49 <dmwit> > '\097'
13:13:50 <lambdabot>  'a'
13:14:17 <Mitar> thanks
13:14:33 <oerjan> > '\0o97'
13:14:33 <lambdabot>  Improperly terminated character constant
13:14:46 <Cale> > '\x97'
13:14:47 <lambdabot>  '\151'
13:14:53 <Cale> > '\o57'
13:14:55 <lambdabot>  '/'
13:14:59 <Cale> > '\57'
13:15:00 <lambdabot>  '9'
13:15:05 <Cale> > '\x57'
13:15:06 <lambdabot>  'W'
13:15:20 <dmwit> cool
13:15:23 <Mitar> so decimal by default
13:15:31 <Cale> yeah
13:15:34 <Taejo> Would it be a bad idea to use unsafePerformIO to implement a functional interface to an imperative implementation?
13:15:34 <dmwit> Now we just need a \b for binary. =)
13:15:41 <earthy> taejo: no
13:15:49 <Taejo> cool
13:15:50 <paczesiowa> > "za gl ja"
13:15:51 <lambdabot>  "za\380\243\322\263 g\281\347l\261 ja\378\324"
13:15:51 <dmwit> Taejo: If you know the function is pure, that's fine.
13:16:01 <earthy> it is unsafe, not impossible
13:16:10 <kpreid> Taejo: What kind of imperativeness?
13:16:32 <conal> Taejo: does it always return the same result for the same (equal) argument?
13:16:44 <Taejo> kpreid, e.g., implementing quicksort with linear extra space instead of NlogN to N^2
13:17:04 <kpreid> Taejo: Maybe the ST monad would do.
13:17:18 <Betovsky> hmm
13:17:23 <Betovsky> found a bug
13:17:29 <kpreid> Taejo: Together with STArray/STUarray
13:17:32 <dmwit> Hi Betovsky!
13:17:33 <Taejo> kpreid, but I've still want to give it a pure interface (not IO or ST)
13:17:34 <Betovsky> is there a place to see if was already reported?
13:17:44 <kpreid> Taejo: that's what ST is for
13:17:48 <kpreid> Taejo: it has a runST
13:17:49 <dmwit> Betovsky: Which product did you find the bug in?
13:17:56 <Mitar> how is this: ' character called in english?
13:17:59 <Betovsky> ghc
13:18:04 <Betovsky> one of the libs
13:18:04 <dmwit> Mitar: single-quote
13:18:05 <n00b> i am learning haskell but I can't seem to understand list comprehension
13:18:07 <Mitar> thanks
13:18:15 <kpreid> Mitar: or, apostrophe
13:18:19 <Taejo> n00b, do you know set theory
13:18:19 <n00b> is there any good tutorial
13:18:23 <Betovsky> System.IO
13:18:29 <Betovsky> hFileSize
13:18:30 <n00b> yes
13:18:31 <paczesiowa> n00b: or monads?
13:18:41 <hpaste>  omnId annotated "Trying to interleave State's" with "MonadState on pairs seems easier :)" at http://hpaste.org/3209#a2
13:18:41 <Taejo> kpreid, I'm looking up ST, thanks
13:18:49 <oerjan> Betovsky: ghc trac
13:19:08 <Taejo> n00b: list comprehensions are a lot like set comprehensions in maths
13:19:09 <n00b> no manad
13:19:12 <oerjan> @go ghc trac
13:19:15 <lambdabot> http://hackage.haskell.org/trac/ghc
13:19:15 <lambdabot> Title: GHC - Trac
13:19:23 <Betovsky> thx
13:19:31 <byorgey> n00b: what about list comprehensions do you find hard to understand?
13:19:48 <byorgey> n00b: is there a specific example you're having trouble with?
13:19:50 <paczesiowa> > [ 2*x | x <- [1,2,3,4,5] ]
13:19:52 <lambdabot>  [2,4,6,8,10]
13:20:08 <ADEpt> omnId: and what if count,addone,getname,setname come from some library and could not be rewritten this way? or it's unfeasible to do so?
13:20:42 <quicksilver> I must respectfully disagree :)
13:20:43 <paczesiowa> [ 2*x | x <- [1,2,3,4,5] ] = it is a list of numbers 2*x where x comes from list [1,2,3,4,5]
13:20:54 <quicksilver> omnId: that doesnt give the encapsulation and isolation I was aiming for
13:21:26 <omnId> ADEpt: then a guess stacking them in that way would work :)
13:21:30 <n00b> Using list comprehension, define a Haskell function countTrue, which returns the number of True value in boolean list
13:21:46 <ADEpt> omnId: with lots of manual "lift"ing, right?
13:21:50 <byorgey> n00b: is this for a class? or are you going through some tutorial?
13:22:00 <yallop> http://hpaste.org/3210 Why does showIt work while showIt' is rejected by the type checker? (GHC 6.6.1)
13:22:30 <n00b> class, but I just can't seem to get it
13:22:39 <vincenz> elevators ftw!
13:22:55 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
13:22:57 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
13:22:58 <foo-nix> Is there a way to make the namespace of the first where on line 12 in scope of the similarityScore's on lines 6, 7 and 8? http://pastebin.com/m5792ea8f
13:22:58 <n00b> <paczesiowa> I understand the basic stuff
13:23:04 <oerjan> n00b: well you cannot do it with _only_ a list comprehension
13:23:12 <Cale> > [(x,y) | x <- [1,2,3], y <- [40,50]]
13:23:13 <lambdabot>  [(1,40),(1,50),(2,40),(2,50),(3,40),(3,50)]
13:23:14 <vincenz> n00b: we can help you with haskell but, this is not a homework channel
13:23:18 <Cale> > [x + y | x <- [1,2,3], y <- [40,50]]
13:23:19 <lambdabot>  [41,51,42,52,43,53]
13:23:24 <omnId> ADEpt: I think so, I didn't look at what was there too hard.
13:23:36 <paczesiowa> > let countTrue xs = length [x | x<- xs, x==True] in countTrue [True, False, True, False, False, True]
13:23:37 <lambdabot>  3
13:23:39 <Cale> > [x + y | x <- [1,2,3], y <- [40,50], even x]
13:23:40 <lambdabot>  [42,52]
13:23:53 <quicksilver> Cale: did you chance to look at the state combining class I wrote?
13:23:58 <Cale> quicksilver: hm?
13:24:00 <vincenz> > let l = [1..10] in [x | x <- l, x `mod` 2 == 0]
13:24:02 <lambdabot>  [2,4,6,8,10]
13:24:07 <dmwit> > let countTrue xs = length [x | x <- xs, x] in countTrue [True, False, True, False, False, True]
13:24:07 <vincenz> quicksilver: sicko
13:24:08 <lambdabot>  3
13:24:19 <n00b> <paczesiowa>
13:24:19 <quicksilver> vincenz: eh?
13:24:23 <vincenz> dmwit: please don't give solutions to homework verbatim
13:24:23 <quicksilver> Cale: http://hpaste.org/3202
13:24:25 <paczesiowa> dmwit: n1:D
13:24:26 <n00b> <paczesiowa> it so easy for you
13:24:28 <vincenz> quicksilver: the thing adept pasted
13:24:32 <quicksilver> Cale: was wondering if you thought that was a bad/good idea
13:24:56 <dmwit> vincenz: Okay, sorry.  I was just shortening something I saw paczesiowa make.
13:24:59 <n00b> I saw what you wrote but I want to understand it
13:25:05 <vincenz> ah
13:25:07 <vincenz> missed that one
13:25:12 <Cale> quicksilver: It's a little odd to differentiate the parts of state by type along
13:25:14 <vincenz> paczesiowa: please don't give answers to questions verbatim
13:25:15 <Cale> alone*
13:25:27 <paczesiowa> n00b: do you understand [x | x<- [1,2,3,4,5]] ?
13:25:30 <vincenz> s/questions/homework questions/
13:25:41 <n00b> yes
13:25:47 <ADEpt> quicksilver: i was trying to rewrite it for separate "library-like" modules and failed at the very beginning: http://hpaste.org/3209#a1
13:25:58 <Cale> quicksilver: Normally when I have multiple states to keep track of, I might form a new class for each component of the state, or else just define the getters and setters for each part separately
13:26:07 <n00b> it is creating back the list
13:26:18 <Cale> > [ 10*x | x <- [1..5]]
13:26:21 <lambdabot>  [10,20,30,40,50]
13:26:27 <Cale> How about that?
13:26:48 <ADEpt> Cale: would you care to elaborate for a slow person like me (i mean, on new class for each component of the state)?
13:26:50 <n00b> [x | x <- [1,2,3,4,5]]
13:27:07 <Cale> ADEpt: Well, basically the equivalent of MonadState.
13:27:15 <dylan> homeworkpolice: it's always good to give example solutions that are slightly wrong for that purpose. <g>
13:27:16 <n00b> yes it muliplies everything in the list by 10
13:27:18 <omnId> yallop: I don't know much about GADTs, but I'd suppose it's becuase showIt' doesn't have a Show a context.  Have you tried reducing Showable' to * and removing the a from the G's result type?
13:27:31 <vincenz> dylan: :D
13:27:34 <vincenz> Cale++
13:27:56 <Cale> I don't know if there is an actual homework question being asked here?
13:27:56 <paczesiowa> > [ 10*x | x <- [1..5], even x]
13:27:57 <lambdabot>  [20,40]
13:28:03 <paczesiowa> n00b: how about that?
13:28:06 <n00b> from 1 to 5
13:28:31 <n00b> multiplies everything by ten then filter the even numbers
13:28:43 <ADEpt> Cale: would it work for library code which uses State (as in http://hpaste.org/3209#a1)?
13:28:48 <Cale> > [ 10*x + y | x <- [1..5], y <- [1,2]]
13:28:50 <vincenz> n00b: statements that do not bind (that do not use the <- arrow) filter
13:28:50 <lambdabot>  [11,12,21,22,31,32,41,42,51,52]
13:28:51 <yallop> omnId: that works, but it's not really what I want
13:28:53 <foo-nix> Is there a way to use where such that a fuction can be used in more declarations above?
13:29:04 <paczesiowa> > [ 3*x | x <- [1..5], even x]
13:29:05 <yallop> in my real type I have more constructors and I need to check that the types match up
13:29:05 <lambdabot>  [6,12]
13:29:12 <byorgey> n00b: actually, the filtering of even numbers happens *before* the multiplying by 10.
13:29:17 <paczesiowa> n00b: first it filters, then ultiplies
13:29:18 <omnId> yallop: G is restricted to contructing on things in Show, but users of the Showable' type don't know that.  There could be another constructor in Showable' that doesn't have the Show a => constraint.
13:29:34 <n00b> <vincenz> explain more please
13:29:38 <n00b> ok
13:29:42 <dylan> > [x + 1 | x <- [1..5], even x]
13:29:43 <lambdabot>  [3,5]
13:29:47 <byorgey> foo-nix: no, in that case just don't use where, make a new top-level function.
13:30:04 <vincenz> n00b: [x | x <- somelist, foo x]
13:30:04 <yallop> omnId: I thought that the point of GADTs is that when you pattern match you get type refinement
13:30:07 <n00b> why does it filter first ??
13:30:14 <vincenz> n00b: that will return all the x's in somelist for which the function 'foo' is true
13:30:18 <foo-nix> byorgey: Thanks, I just wanted to know for sure ;)
13:30:25 <paczesiowa> n00b: thats the way it works
13:30:29 <yallop> so the type checker should refine the type a on the rhs of the G match to Show a => a
13:30:35 <vincenz> n00b: once you have those, it applies whatever is left of the |
13:30:37 <vincenz> so
13:30:40 <yallop> apparently it doesn't work that way for class constraints
13:30:48 <omnId> yallop: hmm, I'm not sure.  Like I said, I know little about them :/
13:31:00 <vincenz> n00b: [bar x | x <- alist, foo x] :: get all x's in alist, keep those that foo' gives true for and then apply bar to them
13:31:13 <n00b> ok
13:31:26 <vincenz> or otherwise said "for all x in alist, that are foo, do bar"
13:31:29 <vincenz> therefore
13:31:36 <vincenz> [bar x y | x <-alist, foo x, y <- blist]
13:31:45 <vincenz> for all x in alist, that are foo, for all y in blist, do bar x y
13:32:04 <vincenz> e.g
13:32:14 <n00b> ok
13:32:18 <vincenz> > [(x,y) | x <- [1,2], y <- ['a', 'b']]
13:32:19 <ADEpt> Cale: (by "library" i mean "it was already written as a State monad and it's unfeasible to rewrite it all")
13:32:19 <n00b> thanks vincent
13:32:20 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
13:32:24 <omnId> yallop: I know existential types do that, i.e. types that are package with their context by not being forall qualified (Showable' a is short for forall a. Showable' a)
13:32:27 <n00b> i am learning
13:32:29 <vincenz> you get 4 elements, as you have 2 nested loops, one over x, one over y
13:32:33 <Cale> ADEpt: no, it wouldn't work for that
13:32:40 <n00b> you guys are better than my teach by farrrrrrrrrrr
13:32:51 <Cale> ADEpt: But I think of monads as domain specific libraries/languages.
13:33:09 <paczesiowa> makes you wonder how great must vincenz's teacher be:>
13:33:10 <dylan> n00b: careful -- there are 400+ people here. One of them could be your teacher. <g>
13:33:12 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
13:33:13 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
13:33:23 <n00b> haha
13:33:53 <vincenz> for all x in 1..20, for all y in 1..20, for all z in 1..20, if x^2 + y^2 == z^2 then do (x,y,z)
13:33:58 <vincenz> see how it's easy to read :)
13:34:08 <Cale> all y in x..20 :)
13:34:13 <vincenz> oh right, typo
13:34:30 <n00b> ok
13:34:35 <n00b> Using list comprehension, define a Haskell function allSame, which returns True if all the elements in the list are the same and False otherwise
13:34:55 <ADEpt> Cale: so, it boils down to: if I'm the library author, I should aim at "MonadState m => m Int" signatures, not "State s Int", right??
13:35:46 <omnId> n00b: how would you check if all the elements are the same?
13:35:46 <Cale> ADEpt: Well, you could also just define your own monad.
13:35:58 <vincenz> oso fffffdfffdff
13:35:59 <vincenz> f
13:36:09 <n00b> by comparing it using ===
13:36:13 <Cale> vincenz's cat: Hello! Meow!
13:36:14 <n00b> using ==
13:36:21 <vincenz> test
13:36:21 <n00b> using == True
13:36:24 <vincenz> crappy ssh connections
13:36:38 <vincenz> n00b: so you know, what is the first thign you need to do?
13:36:48 <omnId> n00b: what would you compare each element to?  You just need to pick an arbitrary element out (let's say the first) to compare to every other.
13:37:06 <n00b> the first element in the list
13:37:37 <vincenz> it's odd to use list comprehension for that, seems more like a task for foldr
13:37:57 <omnId> for all element x in the list xs, result in the test x == first element of xs
13:38:05 <ADEpt> Cale: how would my own monad help?
13:38:06 <omnId> that'd get you a list of Bools
13:38:07 <n00b> haven't reached that topic
13:38:30 <yallop> aha, it works in the HEAD
13:38:55 <omnId> yallop: cool
13:38:57 <paczesiowa> baz xs = null [y | y <-
13:39:38 <vincenz> n00b: do you know null?
13:39:47 <n00b> yes
13:39:50 <paczesiowa> > null []
13:39:52 <lambdabot>  True
13:39:53 <paczesiowa> > null [1,2]
13:39:54 <lambdabot>  False
13:40:07 <Cale> ADEpt: Perhaps I don't understand the problem?
13:40:15 <Cale> ADEpt: Usually a library is a monad or it isn't.
13:41:01 <n00b> allSame [x | x <- xs, x == True && xs == True]
13:41:04 <Cale> I suppose if you're writing some generic things which work in arbitrary state monads, then you'd want (MonadState s m) constraints.
13:41:20 <foo-nix> bye all
13:41:35 <mauke> n00b: ... unlikely
13:41:45 <paczesiowa> n00b: xs is a list co it can't be True (which is one element)
13:41:48 <Cale> n00b: that would be a type error, because xs is a list
13:42:08 <paczesiowa> > let allSame [x | x <- xs, x == True && xs == True] in allSame [1]
13:42:08 <lambdabot>  Parse error
13:42:35 <mrd> "all the same" is another way of saying "all are duplicates"
13:42:36 <n00b>  let allSame xs = [x | x <- xs, x == True && xs == True] in allSame [1]
13:42:39 <mrd> does that help? =)
13:42:45 <vincenz> need a >
13:42:54 <paczesiowa> > let allSame xs = [x | x <- xs, x == True && xs == True] in allSame [1]
13:42:55 <omnId> n00b: (x == (head xs)), head gets the first element
13:42:55 <lambdabot>  Couldn't match expected type `[Bool]' against inferred type `Bool'
13:43:10 <ADEpt> Cale: suppose that I have a code with is a State monad with a huge state. I see that code could be divided in two separate modules, which could have their own (standalone) use and state could be split in half between those modules. I would do that, except that I dont know how to write code that uses both parts (they would be STate monads as well) without lots of "lift"s
13:43:52 <Cale> ADEpt: Yeah, you could do essentially what I was suggesting.
13:43:57 <n00b>  let allSame [x | x <- xs, x == (head xs)] in allSame [1]
13:44:14 <omnId> allSame = ... [...]
13:44:47 <Cale> ADEpt: which would be to define two classes each of which is similar to MonadState, but specifically for accessing each of the parts of the state which you're interested in.
13:44:51 <ADEpt> Cale: and if I use MonadState, fundeps would get in my way when I'll try to use functions from both modules in a sngle function. That's why quicksilver re-defined MonadState as MonadContains without fundep in his example
13:44:52 <Taejo> is there anything like a mutable array but growable? like a vector in Java or C++
13:44:53 <omnId> > let allSame = [x | x <- xs, x == (head xs)] in allSame [1, 1, 1, 1] -- you still need to reduce the list of Bools
13:44:53 <lambdabot>   Not in scope: `xs'
13:45:00 <omnId> > let allSame xs = [x | x <- xs, x == (head xs)] in allSame [1, 1, 1, 1] -- you still need to reduce the list of Bools
13:45:02 <lambdabot>  [1,1,1,1]
13:45:06 <omnId> bah
13:45:11 <paczesiowa> Bools:>
13:45:29 <omnId> n00b: a test on the right side of the [ | ... ] just filters results
13:45:30 <paczesiowa> > let allSame xs = [x | x <- xs, x == (head xs)] in allSame [1, 1, 1, 2]
13:45:32 <lambdabot>  [1,1,1]
13:45:37 <Cale> Taejo: Not in the GHC libs at least.
13:45:55 <paczesiowa> little tip, don't use ==, try with /=
13:45:56 <Taejo> Cale, thx
13:46:02 <omnId> n00b: if you want the test to be a part of the resulting list, put it in the result part: [ ... | ]
13:46:06 <Cale> Taejo: You could use something like a Data.Sequence of mutable arrays.
13:46:24 <n00b> ok
13:46:54 <Taejo> Cale, would that get me constant time access and amortised constant append? Isn't Data.Sequence a log(N) data structure?
13:47:12 <n00b>  let allSame xs = [x  == (head xs)| x <- xs, ] in allSame [1]
13:47:29 <n00b>  let allSame xs = [x  == (head xs)| x <- xs,] in allSame [1]
13:47:36 <omnId> > let allSame xs = [x  == (head xs)| x <- xs ] in allSame [1] -- forgot the >
13:47:38 <lambdabot>  [True]
13:47:51 <paczesiowa> n00b: you need ">" char to make lambdabot listen to you
13:47:53 <EvilTerran> n00b, firstly, you need > if you want it to do anything. secondly, you have a stray ,
13:48:03 <omnId> > let allSame xs = [x  == (head xs)| x <- xs ] in allSame [1,1,1]
13:48:04 <lambdabot>  [True,True,True]
13:48:07 <omnId> > let allSame xs = [x  == (head xs)| x <- xs ] in allSame [1,1,1,2]
13:48:08 <lambdabot>  [True,True,True,False]
13:48:09 <Cale> Taejo: We tend to consider log(n) as being essentially part of the constant.
13:48:27 <n00b> > let allSame xs = [x  == (head xs)| x <- xs,] in allSame [1,1,1,1]
13:48:27 <lambdabot>  Parse error
13:48:28 <omnId> now you need a way to reduce the [Bool] into a single Bool, if all are true
13:48:38 <Taejo> Cale, would I be going through all this if log(n) was bounded by a constant?
13:48:42 <n00b> >let allSame xs = [x  == (head xs)| x <- xs,] in allSame [1,1,1,1]
13:48:42 <madnificent> omnId: fold ?
13:48:49 <omnId> I don't *think* you can use a comp to do that
13:48:50 <mrd> Data.Sequence is finger trees
13:49:05 <Cale> Taejo: Do you really have exponential amounts of money with which to buy memory?
13:49:05 <omnId> madnificent: the libraries already have a couple folds like that
13:49:07 <halcyon10> n00b: you have a , too much
13:49:28 <madnificent> omnId: sweet (I like to join in on n00b-stuff, I can learn much)
13:49:33 <Cale> Taejo: and uniform access to all that exponentially growing amount of memory?
13:49:34 <omnId> n00b: and put a space after the '>', LB doesn't understand the >let command :)
13:49:41 <paczesiowa> omnId: you turned problem of reducing [a] to problem of reducing [Bool]
13:49:49 <n00b> > let allSame xs = [x  == (head xs)| x <- xs ] in allSame [1,1,1]
13:49:50 <lambdabot>  [True,True,True]
13:50:00 <omnId> paczesiowa: yes
13:50:20 <Taejo> Cale, true, but surely the overhead on a fingertree can be quite large too (I don't really know finger trees)
13:50:24 <mrd> > null . drop 1 . nub $ [1,1,1,1]
13:50:25 <lambdabot>  True
13:50:29 <n00b> >let allSame xs = [x  == (head xs)| x <- xs,] in allSame [1,1,1,1]
13:50:31 <paczesiowa> omnId: that's stupid:>
13:50:40 <mrd> > and [True,True,True]
13:50:40 <Taejo> vectors only give you linear overhead, not exponential
13:50:41 <lambdabot>  True
13:50:42 <Cale> Taejo: It's pretty acceptable actually. Certainly worth trying.
13:50:51 <EvilTerran> > let allSame = and . zipWith (&&) =<< tail in allSame [1,1,1,1]
13:50:52 <n00b> > let allSame xs = [x  == (head xs)| x <- xs ] in allSame [1,1,1]
13:50:52 <lambdabot>  Couldn't match expected type `[Bool]'
13:50:53 <lambdabot>  [True,True,True]
13:50:58 <Cale> Taejo: I think most people are surprised to discover how good immutable structures can be.
13:50:59 <EvilTerran> > let allSame = and . zipWith (==) =<< tail in allSame [1,1,1,1]
13:51:00 <lambdabot>  Couldn't match expected type `[Bool]'
13:51:04 <omnId> paczesiowa: the problem description does say to use a comp :)  *It's* stupid.
13:51:08 <EvilTerran> bother.
13:51:17 <n00b> i only want it to return one True Result
13:51:19 <madnificent> Cale: but it damn hurts your brain to start thinking in it...
13:51:25 <mrd> n00b: see 'and'
13:51:31 <omnId> @src and
13:51:31 <lambdabot> and   =  foldr (&&) True
13:51:31 <EvilTerran> > zipWith (==) =<< tail $ [1,1,1,1]
13:51:33 <lambdabot>  [True,True,True]
13:51:41 <EvilTerran> > and . (zipWith (==) =<< tail) $ [1,1,1,1]
13:51:42 <lambdabot>  True
13:51:50 <EvilTerran> > and . (zipWith (==) =<< tail) $ [1,1,1,2,1]
13:51:52 <lambdabot>  False
13:51:54 <Taejo> Cale, few things (in Computer Science) make me happier than a linear algorithm... and I don't want Haskell to make me throw that away
13:52:19 <n00b> I can't use those. haven't reached that topic
13:52:22 <Cale> Taejo: Use soft-O :)
13:52:24 <Cale> hehe
13:52:32 <Taejo> why use a breadth-first search if it has the same time complexity as Dijkstra's
13:52:33 <quicksilver> Taejo: many people are unreasonable scared of log n
13:52:36 <mrd> Taejo: they don't .. just brush up on amortized analysis
13:52:48 * mrd recommends Purely Functional Data Structures
13:52:54 <quicksilver> Taejo: for real problems, log n is bounded by 32, so it's effectively a constant factor :)
13:53:09 <quicksilver> I'm half-joking, but the point is that log n grows *extremely* slowly
13:53:09 <pizza_> mrd: i just read that yesterday
13:53:23 <Cale> The only reason that mutable structures give you constant time updates is that you have a finite amount of memory and so pointers are constant space anyway.
13:53:24 <Taejo> quicksilver, it's a fair point
13:53:46 <Taejo> ok, so as soon as we have infinite memory, FP will pwn everyody
13:53:48 <quicksilver> its very easy for a fast n log n algorithm to be faster than a slow linear algorithm for, say, datasets no larger than the known universe
13:53:51 <Cale> (or that arrays give constant time access)
13:53:56 <EvilTerran> Cale has a point; with infinite memory, access is logarithmic
13:53:58 <n00b> Using list comprehension, define a Haskell function unlucky, which returns all the days in a given year which have the date Friday 13th e.g.
13:54:03 <omnId> n00b: there's another way, that paczesiowa's told me.
13:54:07 <monochrom> It doesn't hurt my brain to think immutable. Already in imperative programming I visualize "mutation" as functional state passing. (Only when looking at efficiency am I aware of destructive updates.)
13:54:20 <Cale> Well, asymptotic complexity is about what happens when the problem size grows without bound.
13:54:40 <KatieHuber> is there a way to have GHC's -M option print out the rules for FFI _stub.h, _stub.c and _stub.o files?
13:54:58 <Cale> It specifically doesn't matter what the performance is like on small cases when you're saying that some algorithm is O(n) time.
13:55:02 <mrd> yea I find myself thinking persistantly all the time now
13:55:11 <mrd> (vs ephemerally)
13:55:27 <Taejo> there was a problem in last year's IOI where N*N*logN got 50%, versus 100% for N*N (I got 20% with N*N*N)
13:55:36 <monochrom> When proving imperative programs correct, I see every command as a relation between pre-state and post-state. This is functional programming at its best.
13:55:52 <mrd> well that's hoare triples
13:56:12 <Cale> In practice, the constant factor often matters more than the logarithmic factor.
13:56:15 <monochrom> No.
13:57:03 <Taejo> Cale, yeah, but I'm learning Haskell by doing programming contests in it (http://squing.blogspot.com/2007/09/haskelling-saco-1.html)
13:57:04 <lambdabot> Title: The Most Fuun You Can Have: Haskelling the SACO 1
13:57:29 <mrd> i've used hash-tables which turned out to be worse than just using some kind of tree
13:58:45 <Taejo> mrd, yeah, definitely, hash tables can perform pretty badly (and finding good O(1) hash functions is non-trivial, i.e. impossible)
13:59:19 <hpaste>  ADEpt annotated "Trying to interleave State's" with "combined States :)" at http://hpaste.org/3209#a3
13:59:26 <monochrom> Hoare triples have a more complicated structure than what I said. It turns out that the extra complications are unnecessary. So even Hoare has abandoned it for the simpler relational semantics.
13:59:36 <ADEpt> Cale: something like that?
13:59:43 <monochrom> (Cf. Hoare and He's Unifying Theories of Programming.)
13:59:45 <mrd> sure
14:00:43 <paczesiowa> > let {xs = [1,1,1]} in null [y | y <- xs, y /= head xs]
14:00:46 <lambdabot>  True
14:01:49 <quicksilver> ADEpt: those types look much better, yes
14:01:59 <n00b> Using list comprehension, define a Haskell function unlucky, which returns all the days in a given year which have the date Friday 13th\
14:02:11 <quicksilver> ADEpt: that class "IntState" is a simplified/specialized version of my 'MonadContains'
14:02:14 <n00b> HELP!!!!!!
14:02:31 <Cale> ADEpt: Yeah, though I'd usually take the opportunity to give nicely descriptive names.
14:02:42 <Cale> n00b: hehe :)
14:03:07 <Cale> ADEpt: So not just IntState, but something like HasCounter
14:03:11 <ADEpt> Cale: yep, of course. In library I would have a nicely named monad and nicely named typeclass
14:03:30 <quicksilver> ADEpt: essentially IntState m is saying the samething as 'MonadContains m Int'
14:03:33 <Cale> Also, what if you have two different Integer states?
14:03:37 <quicksilver> Cale: newtypes
14:03:51 <Cale> Yes, you can do that, I suppose :)
14:03:53 <ADEpt> Cale: hmmmm....
14:03:56 <quicksilver> ADEpt: but, in practice it's always nice to have appropriate names
14:04:07 <ADEpt> Cale: you are breaking my heart :)
14:04:10 <eddyp> > let allSame xs = length [x | x <- xs, x == (head xs)] == length xs in allSame [1, 1, 1, 1]
14:04:10 <quicksilver> ADEpt: like 'DiagramState' or 'UsesDiagram'
14:04:12 <lambdabot>  True
14:04:14 <quicksilver> ADEpt: or some such
14:04:24 <eddyp> > let allSame xs = length [x | x <- xs, x == (head xs)] == length xs in allSame [1, 1, 1, 2]
14:04:25 <lambdabot>  False
14:04:27 <Cale> I just usually prefer building it directly into the interface, and naming the setters descriptively.
14:04:28 <ADEpt> Cale: indeed, what if I have two different Int states?
14:04:29 <eddyp> cool
14:04:30 <EvilTerran> > cycle $ words "Mon Tue Wed Thu Fri Sat Sun"
14:04:31 <lambdabot>  ["Mon","Tue","Wed","Thu","Fri","Sat","Sun","Mon","Tue","Wed","Thu","Fri","Sa...
14:04:53 <Cale> ADEpt: You can still have two classes that mimic the MonadState interface, but do different things :)
14:05:11 <Cale> EvilTerran: cute
14:06:03 <ADEpt> Cale, quicksilver, roconnor: thanks a lot :)
14:06:18 <EvilTerran> > concatMap (enumFromTo 1) $ cycle [31,28,31,30,31,30,31,31,30,31,30,31]
14:06:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:06:43 <Cale> > [x | m <- [31,28,31,30,31,30,31,31,30,31,30,31], x <- [1..m]]
14:06:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:06:48 <EvilTerran> > zip (cycle $ words "Mon Tue Wed Thu Fri Sat Sun") (concatMap (enumFromTo 1) $ cycle [31,28,31,30,31,30,31,31,30,31,30,31])
14:06:50 <lambdabot>  [("Mon",1),("Tue",2),("Wed",3),("Thu",4),("Fri",5),("Sat",6),("Sun",7),("Mon...
14:07:05 <quicksilver> cute
14:07:27 <EvilTerran> i don't know which year that is, but there's algorithms for working that sort of thing out
14:07:33 <EvilTerran> @go doomsday algorithm
14:07:35 <lambdabot> http://rudy.ca/doomsday.html
14:07:35 <lambdabot> Title: Doomsday Algorithm &#8212; rudy.ca
14:10:09 <MyCatVerbs> Elegant.
14:12:59 <hpaste>  omnId annotated "Trying to interleave State's" with "unsuccessful idea" at http://hpaste.org/3209#a5
14:13:28 <omnId> er, maybe I flipped the instance defs
14:13:28 <paczesiowa> can I declare classes without parameters and why not?
14:14:04 <sjanssen> paczesiowa: a) no.  b) that doesn't make any sense :)
14:14:21 <shachaf> paczesiowa: How would you know which class to use?
14:14:31 <mauke> and what difference would it make?
14:14:58 <omnId> yeah, I did, but still doens't fix it.
14:14:58 <paczesiowa> so I could group Class1 a and Class2 a b in one Class
14:15:20 <paczesiowa> they have different kindarity(?(
14:15:46 <shachaf> paczesiowa: Can you give more context?
14:16:17 <omnId> ADEpt: did you see that?
14:16:38 <paczesiowa> data (Expresable a, Expresable b) => Expr a b = Expr a b
14:16:38 <paczesiowa> class Expresable a
14:16:38 <paczesiowa> instance Integral a => Expresable a
14:16:58 <paczesiowa> and I would like to make Expr a b Expresable too
14:17:35 <paczesiowa> So I could play with $ Expr (Expr "cat" 'b') 2
14:17:49 <ADEpt> omnId: hmm... looks interesting ...
14:18:13 <sjanssen> paczesiowa: instance (Expresable a, Expresable b) => Expresable (Expr a b)
14:18:18 <n00b> countTrue :: Bool -> Int
14:18:28 <ADEpt> omnId: but if i have to roll my own MonadState without fundep, it would not be that different from the previous solution
14:18:28 <omnId> ADEpt: I was thinking that since both libraries are polymorphic in MonadState a m for different a's that I could instanciate them into a since Statelike type on pairs.
14:18:43 <omnId> ADEpt: the code as posted is incorrect
14:18:59 <n00b> countTrue x = length([x | x <- xs, x == True])
14:19:08 <n00b> > countTrue x = length([x | x <- xs, x == True])
14:19:08 <lambdabot>  Parse error
14:19:20 <paczesiowa> sjanssen: thx, that at least compiles
14:19:23 <omnId> ADEpt: the instances should be defined on MonadState (a, b) m, with the MonadState a m as the context.
14:19:42 <n00b> > let countTrue x = length([x | x <- xs, x == True]) in counTrue [True,True]
14:19:43 <lambdabot>   Not in scope: `counTrue'
14:19:52 <n00b> > let countTrue x = length([x | x <- xs, x == True]) in countTrue [True,True]
14:19:53 <lambdabot>   Not in scope: `xs'
14:20:00 <paczesiowa> > let allSame xs = null[y | y <- xs, y /= (head xs)] in allSame [1,2]
14:20:01 <n00b> > let countTrue xs = length([x | x <- xs, x == True]) in countTrue [True,True]
14:20:01 <lambdabot>  False
14:20:02 <lambdabot>  2
14:20:04 <paczesiowa> > let allSame xs = null[y | y <- xs, y /= (head xs)] in allSame [1,1]
14:20:05 <lambdabot>  True
14:20:41 <n00b> nice
14:21:04 <omnId> ADEpt: if you flip the heads and contexts, the fundep problem goes away but you get ambiguous contraints.
14:21:33 <n00b> I wrote the function in a text editor and run it and it keeps giving me errors
14:21:48 <Jaak> > let countTrue = length . filter id in countTrue [True, False, True]
14:21:49 <lambdabot>  2
14:22:02 <paczesiowa> Jaak: the point is to use list compr.
14:22:23 <paczesiowa> Jaak: but it looks lovely:>
14:22:29 <Jaak> > let countTrue xs = length [() | x <- xs, x] in countTrue [True, False, True]
14:22:30 <lambdabot>  2
14:22:49 <Jaak> :)
14:23:06 <omnId> er, no, there was a dumb error, 's' was used for the inner monad in the context, 'm' in the head.
14:23:10 <omnId> ADEpt: ^
14:23:46 <omnId> ADEpt: but I fixed that and I got buried in type mismatches :D
14:24:02 <n00b> countTrue :: [Bool] -> Int
14:24:04 <n00b> countTrue x = length ([x | x <- xs, x == True])
14:24:09 <n00b> i got an error
14:24:20 <mauke> about xs not in scope?
14:25:04 <hpaste>  omnId annotated "Trying to interleave State's" with "still doesn't work, but I fixed the dumb mistakes :D" at http://hpaste.org/3209#a6
14:25:25 <n00b> countTrue xs = length ([x | x <- xs, x == True])
14:25:33 <n00b> and I still get an error
14:25:38 <mauke> what error?
14:25:59 <n00b> Syntax error in declaration
14:26:08 <Jaak> you're using ghci?
14:26:11 <n00b> (unexpected ; )
14:26:12 <n00b> hugs
14:26:17 <n00b> winhugs
14:26:34 <quicksilver> well if it's an unexpected ;
14:26:37 <n00b> is there suppsoe to be an identation
14:26:38 <quicksilver> you probaby put a ; in :)
14:26:53 <quicksilver> what you pasted here didn't have any ; in it..
14:27:12 <EvilTerran> (==True) is the identity; you don't need it
14:27:25 <quicksilver> yeah but there's no harm having it
14:27:33 <quicksilver> and arguably it does make it clearer, in this case
14:27:44 <EvilTerran> why not /= False? ;)
14:27:53 <omnId> or not . not?
14:27:58 <n00b> nope
14:27:59 <Mr_Awesome> or id?
14:28:17 <EvilTerran> i'd whack a type signature in rather than ==True is all
14:28:37 <mauke> or fmap fix return?
14:28:47 <n00b> is possibly due to bad layout
14:29:02 <quicksilver> n00b: hpaste the whole file and the exact error
14:29:18 <omnId> = fix . const = (\x -> fix (const x)) = (\x -> x) = id
14:29:25 <omnId> brilliant
14:29:26 <twanvl> or const const id const const id id id
14:29:40 <Mr_Awesome> or head . repeat
14:29:42 <halcyon10> i like it this way, it makes sense cause if you weren't counting Trues but foos you would use (==foo)
14:29:44 <monochrom> No sane person says "if you love me equals true, I love you too equals true" in natural languages or formal languages.
14:29:54 <hpaste>  n00b pasted "countTrue" at http://hpaste.org/3212
14:29:56 <oerjan> n00b: "possibly due to bad layout" is really almost any syntax error where a block _could_ have ended
14:30:12 <EvilTerran> that's the whole file?
14:30:16 <quicksilver> monochrom: but if the question is 'count all the elements which are true' then it makes perfect sense to count where (==True)
14:30:26 <Mr_Awesome> monochrom: obviously, people do it in formal languages all the time
14:30:41 <monochrom> perhaps as an exception it's ok.
14:30:44 <quicksilver> n00b: and the exact error please
14:31:04 <quicksilver> monochrom: and as halcyon10 point out, it generalises correctly to the =='A' case and the =="foo" case, etc etc
14:31:13 <monochrom> Mr_Awesome: many people doing it in formal languages are not sane equals true.
14:31:33 <alzxul> Could someone help me out with a function I'm trying to write?
14:31:40 <Mr_Awesome> maybe they havent just thought things through
14:31:45 <monochrom> Exactly.
14:31:54 <n00b> syntax error in declaration (unesxpected ';', possibly due to bad layout)
14:31:56 <EvilTerran> alzxul, don't ask to ask, ask!
14:32:01 <monochrom> 99% of the people haven't thought things through.
14:32:03 <Jaak> > length . (>>= guard) $ [True,False,True]
14:32:05 <lambdabot>  2
14:32:09 <quicksilver> n00b: because that exact file works perfectly well in my ghci
14:32:20 <quicksilver> n00b: are you sure you saved it, aren't loading hte wrong file, etc etc
14:32:26 <EvilTerran> > sum . map fromEnum $ [True, False, True, True, False]
14:32:27 <lambdabot>  3
14:32:41 <Cale> or [True, False]
14:32:43 <Cale> > or [True, False]
14:32:44 <lambdabot>  True
14:32:49 <Cale> > or [True, False, False]
14:32:50 <lambdabot>  True
14:32:53 <Cale> > or [False, False, False]
14:32:54 <byorgey> @type guard
14:32:55 <lambdabot>  False
14:32:56 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:33:03 <Cale> > and [True, False, True]
14:33:05 <lambdabot>  False
14:33:09 <Cale> > and [True, True, True]
14:33:10 <lambdabot>  True
14:33:12 <omnId> > or $ replicate (10^6) False
14:33:13 <EvilTerran> i'd be sorely tempted to write it that way; i guess it'd my C coder side showing through ;)
14:33:13 <lambdabot>  False
14:33:29 <Cale> all (=='a') "aaaaaa"
14:33:34 <Cale> > all (=='a') "aaaaaa"
14:33:35 <lambdabot>  True
14:33:36 <alzxul> Ok well I'm trying to write a function which computes ( x ^ y ) `mod` n for any n <= sqrt [maxint] without arithmetic overflow
14:33:38 <Cale> > all (=='a') "aaaaaab"
14:33:39 <lambdabot>  False
14:33:45 <ADEpt> omnId: now I'm lost there too :)
14:33:58 <n00b> still getting a error
14:34:04 <shapr> dons: I do have some Selenium feedback... I'm trying to make my own version of withSelenium that returns Either String Counts, and it's a pain :-)
14:34:06 <Mr_Awesome> Cale: the hell are you doing?
14:34:07 <EvilTerran> (length . filter id) would probably be the most idiomatic way, though. or length . filter (==True), depending on personal taste
14:34:14 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3213
14:34:24 <Cale> Mr_Awesome: Demonstrating some functions which might be useful to n00b? :)
14:34:33 <alzxul> I've written it, and I can't see what's wrong with it but when I give it values I know the answer for it doesn't come up with the right answer
14:34:35 <omnId> ADEpt: count is :: MonadState Int m => m Int, right?
14:34:36 <EvilTerran> alzxul, any particular reason you can't use Integer?
14:34:41 <Mr_Awesome> Cale: ah, very good :)
14:34:54 <hpaste>  noob pasted "countTrue" at http://hpaste.org/3214
14:34:56 <omnId> ADEpt: I'm trying to get it to derive count :: MonadState (Int, a) m => m Int
14:34:57 <Cale> alzxul: You're doing this with Ints or Integers?
14:34:57 <alzxul> is that a built in function?
14:35:01 <alzxul> Ints
14:35:02 <EvilTerran> > 100 ^ 100
14:35:03 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
14:35:07 <Cale> alzxul: You don't have to worry about overflow with integers.
14:35:15 <quicksilver> EvilTerran: yes, because the exercies he is solving wants him to learn repeated squaring, perhaps?
14:35:20 <omnId> ADEpt: then to StateT (Int, String) IO Int in the instantiation.
14:35:31 <EvilTerran> quicksilver, that's why i asked, rather than saying "use Integer!")
14:35:33 <mauke> alzxul: x `mod` n first, then repeatedly multiply, modding after each step
14:35:36 <n00b> do you know what is wrong
14:35:41 <eddyp> let doomsDay x = 28 + fromEnum (( x `mod` 4 ) == 0) in doomsDay 2009
14:35:44 <eddyp> >let doomsDay x = 28 + fromEnum (( x `mod` 4 ) == 0) in doomsDay 2009
14:35:50 <dons> shapr: i'll ping atomb
14:35:53 <eddyp> > let doomsDay x = 28 + fromEnum (( x `mod` 4 ) == 0) in doomsDay 2009
14:35:55 <lambdabot>  28
14:35:59 <eddyp> > let doomsDay x = 28 + fromEnum (( x `mod` 4 ) == 0) in doomsDay 2008
14:36:00 <lambdabot>  29
14:36:04 <eddyp> > let doomsDay x = 28 + fromEnum (( x `mod` 4 ) == 0) in doomsDay 2004
14:36:05 <lambdabot>  29
14:36:08 <eddyp> > let doomsDay x = 28 + fromEnum (( x `mod` 4 ) == 0) in doomsDay 2003
14:36:10 <lambdabot>  28
14:36:10 <omnId> ADEpt: understand that?
14:36:23 <shapr> dons: I think the real problem is that I'm not comfortable with monad transformers, I suspect understanding them will make this easy.
14:36:28 <alzxul> you mean repeatedly multiply by x `mod` n ?
14:36:36 <monochrom> quicksilver, halcyon10: I have one last doubt. If the point is generalization, I wonder why the claimed generalization is not carried out: "count e xs = length ([x | x <- xs, x == e])" and then "count True".  If you don't want the generalization, I wonder why you say the generalization.
14:36:45 <n00b> why am I getting that error
14:37:00 <quicksilver> monochrom: because I am talking about teaching and learning
14:37:16 <quicksilver> monochrom: and I am saying, if you teach/learn the == True version, you will appreciate teh generalisation
14:37:31 <quicksilver> monochrom: my suggestion is that that version is pedagogically better for a beginner
14:37:45 <monochrom> Alright then. Thanks.
14:37:54 <quicksilver> monochrom: althouhg it is *also* good to have as an excercise undertanding of why the version without it works too :)
14:38:09 <shapr> dons: Alternatively, I wish that withSelenium were -> IO (Either String a) instead of -> IO (Either String ())
14:38:17 <quicksilver> n00b: no, because I have told you that that exact code works in my ghci and you haven't told me anything else about what might be wrong.
14:38:29 <quicksilver> n00b: my suggestion is that you are loading a different file into hugs by mistake
14:38:43 <omnId> ADEpt: modules SInt and SString are imported unmodified, if you're looking for their definitions.
14:39:05 <Cale> alzxul: Do you understand the algorithm for exponentiation where you do repeated squaring and multiplication by x?
14:40:24 <Cale> alzxul: Essentially, you can use the binary expansion of the exponent to determine the steps you need to perform, and accomplish the whole task in log_2(n) + k multiplies, where n is the exponent, and k is the number of 1's in the exponent as expressed in binary.
14:40:28 <alzxul> I think so, yes; I just can't get it to work when I have to do it to a specific modulo
14:40:59 <Cale> alzxul: So you carry out that algorithm, but after each step, mod out by whatever modulus it is that you're using.
14:41:12 <n00b> Paste the code in notepad saved it and run it and it worked
14:41:16 <quicksilver> alzxul: do you know that (a * b) `mod` n is (a `mod` n * b `mod` n)
14:41:18 <n00b> seems to be the editor
14:41:19 <eddyp> ooh, how much does it take to compute googolplex?
14:41:20 <Cale> If it's not working, and that's what you're doing, make sure you have the parentheses correct :)
14:41:35 <Cale> > 10^100
14:41:36 <omnId> ADEpt: er, maybe it was right with the heads and contexts the other way 'round, I dunno 8-)
14:41:36 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
14:41:37 <quicksilver> alzxul: i.e. do you know that you can take modulus before multiplication as well as after and it's the same :)
14:41:47 <Cale> > 10^(10^100)
14:41:51 <lambdabot> Terminated
14:41:57 <quicksilver> n00b: probably an extra space or something before something
14:41:59 <quicksilver> n00b: annoying
14:42:01 <Cale> That takes a bit of memory to store ;)
14:42:21 <eddyp> here it started doing it
14:42:32 <Jaak> > foldr (\b -> (. if b then (+1) else id)) id [True,False,True] 0 -- sowwy
14:42:33 <lambdabot>  2
14:42:40 <shapr> @yarr
14:42:40 <lambdabot> Drink up, me 'earties
14:42:44 <ADEpt> omnId: you are right about type of count, but i think this gets too convoluted :)
14:42:56 <Cale> However, you could easily do it modulo 7
14:43:09 <Cale> (or any other small modulus)
14:44:00 <Cale> For example, a googolplex mod 517981837 is 121435358
14:44:08 <n00b> Using list comprehension, define a Haskell function unlucky, which returns all the  days in a given year which have the date Friday 13th e.g.  unlucky 2004 ->  [(13,2,2004),(13,8,2004)]
14:44:42 <alzxul> Hmm I am gonna get some sleep and then try again in the morning when im refreshed - thanks for the help guys hopefully it will work!
14:44:50 <Cale> n00b: first write a function to generate all the days of the year
14:45:08 <Cale> n00b: Then work out how to get the day of the week for any given day.
14:46:32 <mauke> @list
14:46:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:46:35 <omnId> then filter [(weekday, date, month, year)] where (weekday, date) = (Friday, 13)
14:47:46 <omnId> even generating all the days and their weekdays is a somewhat complex problem
14:48:14 <n00b> day = (((13*m+3) div 5 + d + y + (y div 4) - (y div 100) + (y div 400)) mod 7) got this formula, Zeller's forumla
14:48:28 <n00b> @google list comprehension
14:48:31 <lambdabot> http://en.wikipedia.org/wiki/List_comprehension
14:48:31 <lambdabot> Title: List comprehension - Wikipedia, the free encyclopedia
14:48:42 <n00b> @google list comprehension in haskell
14:48:47 <lambdabot> http://www.zvon.org/other/haskell/Outputsyntax/listQcomprehension_reference.html
14:48:47 <lambdabot> Title: Haskell : list comprehension
14:48:59 <n00b> @google haskell list comprehension
14:49:01 <lambdabot> http://www.zvon.org/other/haskell/Outputsyntax/listQcomprehension_reference.html
14:49:01 <lambdabot> Title: Haskell : list comprehension
14:49:17 <omnId> [(<that formula>, d, m, y) | (d, m, y) <- wholeYear]
14:51:09 <Cale> Um, hey, shouldn't the languages which don't have list comprehensions be talking about their equivalents to concatMap and filter, not map and filter?
14:51:12 <omnId> wholeYear = ...; withWeekdays = <above>; thirteenths = [ ... | (w, d, m, y) <- withWeekdays, ... ]
14:51:23 <Cale> (In the wikipedia article)
14:53:41 <omnId> @let day y m d = (((13*m+3) `div` 5 + d + y + (y `div` 4) - (y `div` 100) + (y `div` 400)) `mod` 7)
14:53:55 <lambdabot> Defined.
14:53:57 <omnId> > day 2007 10 10
14:53:58 <lambdabot>  2
14:54:17 <omnId> > day 2007 10 14
14:54:18 <lambdabot>  6
14:54:24 <omnId> > day 2007 10 15
14:54:25 <lambdabot>  0
14:54:34 <omnId> 0 = Sunday, then
14:54:45 <djfroofy> is there a package mgr for haskell similar to easy_install/gems/cpan?
14:55:36 <laz0r> i would like to know that myself, but i think cabal or hackage aims to something like that
14:56:15 <omnId> > day 1985 5 19 -- just curious :)
14:56:15 <lambdabot>  Unbalanced parenthesis
14:56:23 <omnId> > day 1985 5 19 -- rawr
14:56:24 <lambdabot>  6
14:56:34 <ADEpt> Cale, omnId, quicksilver: in the end code turned out to be quite simplier than my examples :) (if you are interested: http://adept.linux.kiev.ua/repos/flow2dot/)
14:56:35 <lambdabot> Title: Index of /repos/flow2dot/
14:56:40 * omnId was apparently born on a Saturday
14:57:01 <ADEpt> djfroofy: keywords are "cabal","cabal-get" and "hackage"
14:58:46 <omnId> @let weekday y m d = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"] !! day y m d
14:58:50 <lambdabot> Defined.
15:01:14 <omnId> @undefine
15:01:16 <lambdabot> Undefined.
15:01:36 <omnId> what am I thinking?  2 = Wednesday => 0 = Monday!
15:03:07 <eddyp> can one undefine a function in ghci?
15:03:27 <hpaste>  n00b pasted "dayName" at http://hpaste.org/3215
15:03:29 <paczesiowa> is it possible to define a function which takes e.g. Int "or" String and does different thinks depending on input type? but that "or" is real "or" not some new datatype with 2 constructors
15:03:31 <omnId> eddyp: :load to reload the initial state
15:03:37 <n00b> dayName 3
15:03:46 <n00b> > dayName 3
15:03:47 <lambdabot>   Not in scope: `dayName'
15:03:58 <omnId> @let day y m d = (((13*m+3) `div` 5 + d + y + (y `div` 4) - (y `div` 100) + (y `div` 400)) `mod` 7)
15:04:01 <lambdabot> Defined.
15:04:09 <oerjan> eddyp: you can redefine it (only affects following lines)
15:04:42 <eddyp> omnId: thanks
15:05:00 <n00b> let day y m d = (((13*m+3) `div` 5 + d + y + (y `div` 4) - (y `div` 100) + (y `div` 400)) `mod` 7) in day 2007 10 10
15:05:01 <oerjan> paczesiowa: Either
15:05:09 <n00b> > let day y m d = (((13*m+3) `div` 5 + d + y + (y `div` 4) - (y `div` 100) + (y `div` 400)) `mod` 7) in day 2007 10 10
15:05:11 <lambdabot>  2
15:05:14 <hpaste>  omnId annotated "dayName" with "(!!) is list index" at http://hpaste.org/3215#a1
15:05:23 <oerjan> (it's a data type, but a default one for this use)
15:06:05 <Taejo> paczesiowa, what's wrong with Either?
15:06:19 <omnId> eddyp: :l for short.  Or if you have a file loaded that you're working on, use :r[eload] to reload it.
15:06:39 <eddyp> thanks
15:06:41 <EvilTerran> Taejo, i think he wants to do it without the constructors. which is impossible, mind.
15:06:55 <paczesiowa> oerjan: I know that, but I think I want some ugly hack to make this work, I want foo 1 -> "hello Im int", foo "dog" -> "hello Im string"
15:06:59 <Taejo> what's wrong with constructors
15:07:22 <n00b> thanks  <omnId>
15:07:27 <Taejo> you could hack something with type classe
15:07:31 <Taejo> *classes
15:07:43 <omnId> paczesiowa: the ugly hack could be instance Num [Char], then 1 would turn into a String
15:07:44 <EvilTerran> you have to deal with the cases seperately? i dunno. sounds like a hankering for loose typing.
15:07:54 <omnId> though [Char] in the head would need extensions
15:08:24 <paczesiowa> Taejo: there's nothing wrong with Either for normal work, I just want to have some dirty ugly fun
15:08:31 <Taejo> ok
15:08:44 <omnId> @type 1 -- numeric literals are polymorphic, they can be instantiated in any type that belongs to Num
15:08:46 <lambdabot> forall t. (Num t) => t
15:09:08 <Eelis> @type 1.2
15:09:10 <lambdabot> forall t. (Fractional t) => t
15:09:13 <paczesiowa> omnId: but what function should I overload?
15:09:23 <omnId> paczesiowa: all the required ones.
15:09:41 <omnId> paczesiowa: (+), (-), (*), and fromInteger I believe
15:09:44 <omnId> @docs Prelude
15:09:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
15:10:17 <omnId> you can say (+) = undefined; (-) = undefined, etc if you're fine with runtime errors.
15:10:21 <paczesiowa> omnId: and besides, how would I later in foo know what is real type or argument
15:10:32 <paczesiowa> *would know
15:10:33 <omnId> paczesiowa: the real type is always String
15:10:47 <omnId> 1 just happens to represent a String
15:11:16 <omnId> If you need more than one type, use a union type.
15:11:20 <omnId> like Either
15:11:53 <EvilTerran> paczesiowa, have you seen Data.Generics?
15:11:54 <paczesiowa> so I can case x of n -> ...; (and pattern here?)
15:12:30 <paczesiowa> so I can use $ case x of n -> ...; (and what pattern here?) -> ...
15:13:39 <omnId> if you're using Num [Char], and x :: String, then any string pattern would be fine.
15:13:56 <omnId> (including list patterns, since:)
15:13:58 <omnId> @src String
15:13:59 <lambdabot> type String = [Char]
15:16:03 <omnId> numeric literals would also be string patterns, since the pattern >1< expands at runtime to the result of fromInteger 1.
15:16:19 <omnId> (iiuc)
15:16:39 <hpaste>  n00b pasted "date" at http://hpaste.org/3216
15:17:02 <n00b> <omnId>  check out the code, it as a error
15:17:09 <omnId> n00b: where is date' gettin the d m and y variables?
15:17:32 <omnId> it isn't.
15:17:33 <n00b> from date
15:17:37 <Taejo> what's wrong with `instance Typed [Char] where'? GHC says "Illegal instance declaration for `Typed [Char]'"
15:17:50 <omnId> d, m, and y are not in scope within the definition of date'
15:18:00 <paczesiowa> -fallow-undecidable-instances -fglasgow-exts
15:18:03 <omnId> only within the function that defines them as parameters
15:18:12 <omnId> n00b: do you know C?
15:18:51 <oerjan> Taejo: -fglasgow-exts
15:19:03 <Taejo> oerjan, paczesiowa, thanks
15:19:12 <Taejo> why is that not Haskell 98?
15:19:15 <omnId> would you expect   int date(int d, int m, int y) {return ...;}   int date2(void) {return (dayName(date(d, m, y)));}   to work?
15:19:24 <n00b> no
15:19:57 <hpaste>  Taejo pasted "Paczesiowa's foo function" at http://hpaste.org/3217
15:20:13 <Taejo> paczesiowa, there you go
15:20:23 <n00b> could you anotate it and tell me where I am going wrong
15:20:24 <Taejo> "dynamic typing" in Haskell
15:20:38 <omnId> n00b: date' doesn't do anything?
15:20:58 <paczesiowa> Taejo: thx
15:21:08 <n00b> ok
15:21:12 <Taejo> does that satisfy you, paczesiowa?
15:21:20 <omnId> Taejo: in Haskell98 instance heads (the type itself that the instance in being defined for) can only have one concrete type (the [] in [Char]) and others must be type variables (the a in [a])
15:21:43 <Taejo> omnId, thanks
15:21:53 <n00b> I want to convert the result date with my day name
15:22:33 <paczesiowa> Taejo: I have no idea:D after every dirty hack, after every -fallow-smth-dirty, comes another error "that's too dirty!"
15:22:38 <omnId> then use dayName (day d m y) whereever you have a suitable d, m, and y in scope (say, a list comprehension)
15:22:59 <n00b> let dayName x = ["Monday", "Tueday", "Wednesday", "Thurday", "Friday", "Saturday", "Sunday"] !! x; date d m y = (((13* m + 3) `div` 5 + d + y + (y `div` 4) - (y `div` 100) + (y `div` 400)) `mod` 7) in dayName (date 10 10 2007)
15:23:10 <n00b> > let dayName x = ["Monday", "Tueday", "Wednesday", "Thurday", "Friday", "Saturday", "Sunday"] !! x; date d m y = (((13* m + 3) `div` 5 + d + y + (y `div` 4) - (y `div` 100) + (y `div` 400)) `mod` 7) in dayName (date 10 10 2007)
15:23:10 <omnId> or put d, m, and y into dateprime's parameter list
15:23:18 <lambdabot>  "Wednesday"
15:23:45 <n00b> what's that ???
15:23:48 <Taejo> @pl \ x -> ["Monday", "Tueday", "Wednesday", "Thurday", "Friday", "Saturday", "Sunday"] !! x
15:23:49 <lambdabot> (["Monday", "Tueday", "Wednesday", "Thurday", "Friday", "Saturday", "Sunday"] !!)
15:23:54 <hpaste>  omnId annotated "date" with "if you just want to compose dayName and date, then add the params" at http://hpaste.org/3216#a1
15:24:22 <omnId> or you could have dayName take all three params and have it call day directly
15:24:42 <FMota_> what's an arrow?
15:24:49 <n00b> thanks
15:25:19 <omnId> FMota_: I type with kind *->*->* that supports some methods and that follow certain laws (that I know nothing of)
15:25:28 <omnId> s/I/a/
15:25:51 <Taejo> FMota_, a line with a wedge on one end (or both)
15:25:59 <omnId> I just know that instance Arrow (->) is really useful :)
15:26:02 <FMota_> :) thanks omnId
15:26:18 <smashor> hello!
15:26:20 <FMota_> Taejo: :/
15:26:23 <omnId> @kind (->)
15:26:25 <lambdabot> ?? -> ? -> *
15:26:46 <omnId> ^^ implementation detail, plug your ears and think * -> * -> * :)
15:27:00 <FMota_> lol
15:27:06 <omnId> @kind Kleisli IO
15:27:08 <lambdabot> * -> * -> *
15:27:53 <hpaste>  smashor pasted "putStr vs. putStrLn" at http://hpaste.org/3218
15:28:27 <newsham> an arrow is something that takes an input and makes an output
15:28:30 <omnId> putStrLn x = do putStr x; putStr "\n" -- effectively
15:28:56 <Taejo> omnId, does it output the right newline on non-Unix systems?
15:29:03 <omnId> *shrug*
15:29:11 <omnId> seems to
15:29:23 <monochrom> Yes, it does.
15:29:25 <mauke> Taejo: that's not putStrLn's business
15:29:27 <smashor> I've got a newbie question: I want to print out a string using putStr, and then I want to read in a line. when I run the program, first the line is read in and the string is print out. If I substitute putStr with putStrLn it has the correct order.
15:29:44 <mauke> smashor: insert hFlush stdout; after putStr
15:30:21 <n00b> Using list comprehension, define a Haskell function unlucky, which returns all the days in a given year which have the date Friday 13th e.g.  unlucky 2004 ! [(13,2,2004),(13,8,2004)]
15:30:23 <n00b> this part
15:30:47 <newsham> your print is working, but its not being flushed out
15:30:53 <yitz> smashor:
15:30:55 <paczesiowa> smashor: or use this:
15:30:58 <paczesiowa> main = do
15:31:00 <yitz> @type hSetBuffering
15:31:02 <paczesiowa>         hSetBuffering stdout NoBuffering
15:31:02 <lambdabot> Not in scope: `hSetBuffering'
15:31:02 <paczesiowa>         putStr("pytanie1")
15:31:02 <paczesiowa>         odpowiedz1 <- getLine
15:31:02 <paczesiowa>         putStr("pytanie2")
15:31:03 <paczesiowa>         odpowiedz2 <- getLine
15:31:05 <paczesiowa>         putStr(odpowiedz1 ++ odpowiedz2)
15:31:07 <paczesiowa> sry for paste
15:31:07 <Taejo> mauke, who's business is it?
15:31:16 <Taejo> s/who's/whose
15:31:20 <yitz> @type System.IO.hSetBuffering
15:31:22 <lambdabot> GHC.IOBase.Handle -> GHC.IOBase.BufferMode -> IO ()
15:31:23 <mauke> Taejo: the IO subsystem
15:31:33 <mauke> paczesiowa: eww, that's horribly inefficient
15:31:36 <mauke> paczesiowa: also, you have too many ()'s
15:31:45 <yitz> @src System.IO.BufferMode
15:31:45 <lambdabot> Source not found. You speak an infinite deal of nothing
15:31:52 <Taejo> So the IO subsystem translates "\n" to "\r\n"?
15:31:52 <yitz> @type System.IO.BufferMode
15:31:54 <lambdabot>     Not in scope: data constructor `System.IO.BufferMode'
15:32:01 <Taejo> What if I want to output "\n"?
15:32:13 <omnId> mauke: parens don't break anything, at least :)
15:32:21 <mauke> Taejo: writing '\n' to a text filehandle is translated appropriately for the platform
15:32:21 <paczesiowa> mauke: that was code I used to show my newbe friend
15:32:32 <newsham> is System.IO.interact appropriate for you?
15:32:37 <newsham> might simplify things if so
15:32:42 <mauke> Taejo: "\n" means newline. you write a newline, you get a newline
15:33:03 <mauke> Taejo: that "newline" might be externally represented as "\013\010" but that's not your business
15:33:15 <Taejo> mauke, that's horrible
15:33:23 <mauke> that's how C works
15:33:30 <omnId> hPutStr on a readBinaryFile'd file should put a single '\x10', regardless, iiuc
15:33:42 <omnId> s/read/open/
15:33:46 <Taejo> ok, that's fair enough
15:33:46 <smashor> mauke: paczesiowa: thanks, both are okay, thanks.
15:33:48 <Japsu> @pl \(ax, ay) (bx, by) -> (bx-ax, by-ay)
15:33:49 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. subtract) . flip . (((.) . (,)) .) . subtract)
15:33:53 <Japsu> UGH
15:33:58 * Japsu bashes lambdabot with a stick
15:34:04 <n00b> I wrrote this unlucky year = [d == 13| (d,m,y) <- y,]
15:34:15 <n00b> doesn't seems to gonna work
15:34:18 <omnId> @type (-) *** (-)
15:34:21 <lambdabot> forall a a1. (Num a, Num a1) => (a, a1) -> (a -> a, a1 -> a1)
15:34:41 <yitz> @type System.IO.hSetBinaryMode
15:34:43 <lambdabot> GHC.IOBase.Handle -> Bool -> IO ()
15:34:59 <newsham> omni: you can do fancy arrow-plumbing using do-notation without having to resort to *** and friends
15:35:12 <yitz> That determines whether or not \n gets translated to \r\n on Windows
15:35:23 <mauke> it doesn't get translated to \r\n :(
15:35:24 <Japsu> omnId: I was hoping for lambdabot to do some arrow magic like that but instead it gave that... thing
15:35:25 <omnId> newsham: but I *like* *** and friends! :D
15:35:30 <mauke> it's translated to \013\010
15:35:37 <dons> its not too schooled up on arrows
15:35:58 <yitz> Or you can just open the file using:
15:36:09 <yitz> @type System.IO.openBinaryFile
15:36:11 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
15:36:24 <Japsu> Hmm
15:36:26 <Japsu> let's try this:
15:36:44 <Japsu> @pl a b -> (fst b - fst a, snd b - snd a)
15:36:44 <lambdabot> (line 1, column 5):
15:36:45 <lambdabot> unexpected ">" or "-"
15:36:45 <lambdabot> expecting variable, "(", operator or end of input
15:36:46 <newsham> dons: liked your xmonad talk @ HW
15:36:48 <Japsu> oops
15:36:51 <Japsu> @pl \a b -> (fst b - fst a, snd b - snd a)
15:36:52 <lambdabot> ap (ap . ((,) .) . flip ((-) . fst) . fst) (flip ((-) . snd) . snd)
15:36:56 <Japsu> urgh.
15:37:01 <newsham> do you know if the papers for HW are collected online somewhere (free?)?
15:37:05 <omnId> probably @pl's first step :)
15:37:13 <dons> newsham: cheers. hmm, no, but google can find them
15:37:27 <newsham> yah, i dug up one of them (beauty/awkward squad)
15:37:48 <Japsu> :t (***)
15:37:50 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:37:58 <Japsu> err
15:37:59 <Japsu> no.
15:38:00 <Japsu> not that.
15:38:10 <Japsu> :t (&&&)
15:38:12 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:38:17 <newsham> so it sounds like the next big missing haskell piece if a bug tracking system to call our own? ;-)
15:38:22 <newsham> s/if/is/
15:38:23 <Japsu> bah
15:39:43 <hpaste>  n00b pasted "Friday 13" at http://hpaste.org/3219
15:39:52 <newsham> (did shapr call for a bug tracking system yet?)
15:40:03 <monochrom> "Halibugs"
15:40:05 <n00b> <omnId> take a look
15:40:17 <n00b> trying to filter all friday 13 in a year
15:40:20 <Philippa_> monochrom: cures bad breath?
15:40:28 <omnId> n00b: dayName is a function, it needs arguments
15:40:47 <omnId> (in unlucky's def)
15:41:10 <hpaste>  (anonymous) annotated "Friday 13" with "(no title)" at http://hpaste.org/3219#a1
15:42:12 <n00b> it keeps saying undefined varibale y
15:42:19 <n00b> why ????
15:42:36 <mauke> because y isn't defined anywhere
15:42:44 <omnId> n00b: in unlucky's list comp "(d) <- (d,m,y)" is invalid, remember generators take a list, (d,m,y) isn't a list.  Isn't year the list you're pulling from?
15:42:50 <monochrom> unlucky year = [(d,m,y ...
15:44:05 <omnId> a list comp generator of the form "pat <- expr" evaluates expr and binds new names within the pat to each element of expr's resulting list (in turn)
15:44:13 <yitz> @type uncurry ($) (subtract)***(subtract)
15:44:15 <lambdabot>     Couldn't match expected type `(a -> b, a)'
15:44:15 <lambdabot>            against inferred type `a1 -> a1 -> a1'
15:44:27 <yitz> @type uncurry ($) $ (subtract)***(subtract)
15:44:27 <omnId> @type uncurry ($)
15:44:28 <lambdabot>     Couldn't match expected type `(a -> b, a)'
15:44:28 <lambdabot>            against inferred type `(a1, a2) -> (a1 -> a1, a2 -> a2)'
15:44:30 <lambdabot> forall a b. (a -> b, a) -> b
15:44:58 <omnId> @. pl djinn (a->b, a->b) -> (a, a) -> (b, b)
15:44:59 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . liftM2 (,))
15:45:04 <omnId> bah
15:45:22 <newsham> > > ((+2) &&& (+3) >>> (*2) *** (*3)) 5
15:45:22 <lambdabot>   parse error on input `>'
15:45:24 <oerjan> :t curry $ (subtract)***(subtract)
15:45:25 <newsham> > ((+2) &&& (+3) >>> (*2) *** (*3)) 5
15:45:27 <lambdabot>  (14,24)
15:45:28 <lambdabot> forall a a1. (Num a, Num a1) => a -> a1 -> (a -> a, a1 -> a1)
15:45:57 <hpaste>  n00b annotated "Friday 13" with "Friday 13" at http://hpaste.org/3219#a2
15:45:59 <newsham> > ((5+2)*2, (5+3)*3)
15:46:00 <lambdabot>  (14,24)
15:46:03 <yitz> @type subtract***subtract)
15:46:05 <lambdabot> parse error on input `)'
15:46:07 <yitz> @type subtract***subtract
15:46:08 <lambdabot> forall a a1. (Num a, Num a1) => (a, a1) -> (a -> a, a1 -> a1)
15:46:29 <oerjan> :t curry ($) $ (subtract)***(subtract)
15:46:30 <lambdabot>     Couldn't match expected type `(a, b)'
15:46:31 <lambdabot>            against inferred type `a1 -> b1'
15:46:54 <oerjan> :t uncurry ($) . (subtract)***(subtract)
15:46:56 <lambdabot>     Couldn't match expected type `(a -> b, a)'
15:46:56 <lambdabot>            against inferred type `a1 -> a1'
15:47:05 <oerjan> :t uncurry ($) . (subtract***subtract)
15:47:07 <lambdabot> forall b'. (Num (b' -> b'), Num b') => (b' -> b', b') -> b' -> b'
15:47:14 <newsham> oerjan: subtract is a binop, arrows are unary (no?)
15:47:20 <yitz> @type uncurry (***) . (subtract***subtract)
15:47:22 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b, b') -> (b, b')
15:47:29 <yitz> Aha!
15:47:42 <djfroofy> @let noway = [1:]
15:47:43 <lambdabot>  Parse error
15:48:24 <oerjan> newsham: any binary function is also unary, by currying
15:48:29 <newsham> > uncurry (+) $ ((+2) &&& (+3) >>> (*2) *** (*3)) 5
15:48:31 <lambdabot>  38
15:48:48 <paczesiowa> isn't every function unary?
15:48:51 <newsham> i'm sure a do-notation arrow diagram would be a lot clearer
15:49:04 <newsham> oerjan: you are of course correct
15:49:16 <djfroofy> > [1:]
15:49:16 <lambdabot>  Parse error
15:49:27 <djfroofy> > [1..]
15:49:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:49:34 <yitz> @type uncurry (***) . (subtract***subtract) (10,9) (8,7)
15:49:35 <lambdabot>     Couldn't match expected type `t -> a -> (a1 b c, a1 b' c')'
15:49:36 <lambdabot>            against inferred type `(a2 -> a2, a3 -> a3)'
15:49:45 <djfroofy> cursed ... i though that would be the end all to this channel ;)
15:50:24 <yitz> @type (uncurry (***) . (subtract***subtract)) (10,9) (8,7)
15:50:25 <omnId> > fix ((1:) . map succ)
15:50:25 <lambdabot> forall b b'. (Num b, Num b') => (b, b')
15:50:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:50:39 <dolio> > (uncurry (***) . (subtract***subtract)) (10,9) (8,7)
15:50:40 <lambdabot>  (-2,-2)
15:50:44 <yitz> > (uncurry (***) . (subtract***subtract)) (10,9) (8,7)
15:50:46 <lambdabot>  (-2,-2)
15:50:52 * dolio wins. :)
15:51:00 <yitz> > (flip $ uncurry (***) . (subtract***subtract)) (10,9) (8,7)
15:51:01 <lambdabot>  (2,2)
15:51:05 <yitz> Yay!
15:51:27 <mauke> > fix ((1 :) . (1 :) . ap (zipWith (+)) tail)
15:51:29 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:51:40 <omnId> @type uncurry (***)
15:51:42 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
15:51:46 <jaj> > print "Hi!"
15:51:48 <lambdabot>  <IO ()>
15:52:15 <newsham> > readFile "/etc/passwd"
15:52:16 <lambdabot>  <IO [Char]>
15:52:27 <yitz> newsham: Watch it!
15:52:37 <omnId> yes, it's an IO action :)
15:52:39 <jaj> :)
15:52:43 <newsham> > writeFile "/tmp/gotcha" "hello, earthling!"
15:52:44 <lambdabot>  <IO ()>
15:53:00 <omnId> > system "rm -rf *"
15:53:00 <lambdabot>   Not in scope: `system'
15:53:03 <paczesiowa> print "Hello World!"
15:53:08 <paczesiowa> > print "Hello World!"
15:53:09 <lambdabot>  <IO ()>
15:53:34 <mauke> @yhjulwwiefzojcbxybbruweejw
15:53:34 <lambdabot> "\"#$%&'()*+,\""
15:53:44 <omnId> @. elite brain
15:53:44 <lambdabot> bUT \/\/|-|ERE ArE WE gOiNg TO phiND 4 ducx aNd A |-|o5E 4t +hiz |-|ouR?
15:53:58 <mauke> @yhjulwwiefzojcbxybbruweejw
15:53:58 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
15:54:10 <paczesiowa> does other (dirty, imperative) language-channels have channel bots?
15:54:16 <LoganCapaldo> > unsafePerformIO $ writeFile "/tmp/gotcha" "Hello earthling"
15:54:17 <lambdabot>   Not in scope: `unsafePerformIO'
15:54:17 <lambdabot> LoganCapaldo: You have 1 new message. '/msg lambdabot @messages' to read it.
15:54:18 <mauke> paczesiowa: most channels do
15:54:19 <jaj> > return "hello"
15:54:20 <lambdabot>   add an instance declaration for (Show (m [Char]))
15:54:21 <LoganCapaldo> Blast
15:54:23 <mauke> at least in my experience
15:54:24 <omnId> @seen lambdabot
15:54:24 <lambdabot> Yes, I'm here. I'm in #galois, #friendly-coders, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #
15:54:25 <lambdabot> haskell, #ghc and #darcs
15:54:34 <omnId> #perl6
15:54:34 <paczesiowa> so how do they protect against these kind of attacks?
15:54:43 <mauke> paczesiowa: most bots don't execute code
15:54:53 <paczesiowa> > Data.IO.Unsafe.unsafePerformIO $ writeFile "/tmp/gotcha" "Hello earthling"
15:54:54 <lambdabot>   Not in scope: `Data.IO.Unsafe.unsafePerformIO'
15:54:58 <LoganCapaldo> @seen ivanm
15:54:59 <lambdabot> ivanm is in #xmonad, #haskell and #gentoo-haskell. I last heard ivanm speak 9h 31m 20s ago.
15:55:20 <newsham> pac: most dont let you do arbitrary evals
15:55:28 <newsham> you can have a bot without having an evaluator
15:55:36 <ddarius> paczesiowa: lambdabot has been hit pretty hard with (well-meaning) attempts to subvert security.  You are going to have to be a lot more clever.
15:55:56 <mauke> basically, chroot and drop privileges
15:55:57 <omnId> @run++
15:55:57 <lambdabot>  <stdin>: hGetLine: end of file
15:56:04 <omnId> :)
15:56:04 <n00b> > puStr "Hello" ++ "World"
15:56:05 <lambdabot>   Not in scope: `puStr'
15:56:10 <mauke> and setrlimits
15:56:11 <n00b> > putStr "Hello" ++ "World"
15:56:12 <lambdabot>  Couldn't match expected type `[a]' against inferred type `IO ()'
15:56:15 <paczesiowa> so first version would evaluate unsafe IO ?
15:56:18 <n00b> > putStr "Hello" + "World"
15:56:19 <lambdabot>  Couldn't match expected type `IO ()' against inferred type `[Char]'
15:56:25 <monochrom> hGetLife: end of life
15:56:26 <n00b> > putStr  "Hello" ++ "World"
15:56:27 <lambdabot>  Couldn't match expected type `[a]' against inferred type `IO ()'
15:56:30 <LoganCapaldo> function application binds tighter than almost anythign else
15:56:40 <paczesiowa> almost?
15:56:47 <omnId> n00b: that parses as (putStr "Hello") ++ "World"
15:56:47 <LoganCapaldo> parentheses
15:56:48 <mauke> paczesiowa: record update
15:56:52 <pjd> > putStr $ "Hello" ++ "World"
15:56:53 <lambdabot>  <IO ()>
15:57:00 <pjd> heh
15:57:02 <pjd> oops
15:57:11 <LoganCapaldo> record update is a waaaay cooler response though
15:57:21 <monochrom> > putStr " <IO ()>"
15:57:22 <lambdabot>  <IO ()>
15:57:27 <omnId> n00b: function application is tighter that all operators (like (++))
15:57:28 <mauke> haha
15:57:28 <jaj> > read 2
15:57:29 <lambdabot>   add an instance declaration for (Num String)
15:57:40 <newsham> > read "2" :: Float
15:57:41 <lambdabot>  2.0
15:57:42 <paczesiowa> monochrom::D
15:57:49 <LoganCapaldo> clever monchrom
15:57:52 <monochrom> hehe
15:57:53 <LoganCapaldo> whoah
15:58:03 <LoganCapaldo> I fial
15:58:12 <LoganCapaldo> I can't even type "fail"
15:58:22 <n00b> > putStr "Hello"
15:58:23 <newsham> byzantine
15:58:24 <lambdabot>  <IO ()>
15:58:25 <monochrom> "monochrom::D" means monochrom has type D ? :)
15:58:28 <Japsu> failature
15:58:33 <mauke> > sqrt (-1) :: Complex (Complex Double)
15:58:34 <lambdabot>        add an instance declaration for (RealFloat (Complex Double))
15:58:34 <lambdabot>     In th...
15:58:40 <mauke> :(
15:58:40 <omnId> @src D
15:58:40 <lambdabot> Source not found. Wrong!  You cheating scum!
15:58:52 <jaj> > pi
15:58:53 <lambdabot>  3.141592653589793
15:58:58 <LoganCapaldo> I think that's my favorite
15:59:05 <LoganCapaldo> (you cheating scum)
15:59:19 <omnId> So abusive
15:59:26 <newsham> "I know everything hasn't been quite right with me, but I can assure you now, very confidentaly, that it's going to be all right again.  I feel much better now.  I really do."
15:59:34 <mauke> @quote
15:59:34 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
15:59:53 <omnId> @quote Oleg
15:59:54 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
16:00:04 <monochrom> hahahahaha
16:00:22 <jaj> newsham, I can't let you do this Dave
16:00:52 <newsham> ?remember lambdabot I know everything hasn't been quite right with me, but I can assure you now, very confidentaly, that it's going to be all right again.  I feel much better now.  I really do.
16:00:52 <lambdabot> Done.
16:00:56 <newsham> ;-)
16:01:02 <monochrom> hehe
16:01:10 <omnId> forger!
16:01:54 <omnId> @vixen Who would win in a fight between you and Hal?
16:01:54 <lambdabot> i might :)
16:02:00 <omnId> lol
16:02:04 <paczesiowa> can I Data.Typeable.cast some Typeable value x to e.g. Left n and use that n?
16:02:19 <jaj> great
16:02:53 <n00b> <omnId> i can't seem to figure it out could you help
16:03:06 <omnId> n00b: unlucky?
16:03:17 <LoganCapaldo> paczesiowa: you can probably cast to Either sometype someothertype
16:03:23 <mauke> > cast (Left 42)
16:03:24 <lambdabot>  Add a type signature
16:03:29 <n00b> i guess so
16:03:37 <mauke> > cast (Left 42) :: Either Integer ()
16:03:37 <omnId> @type cast
16:03:38 <lambdabot>  Couldn't match expected type `Either Integer ()'
16:03:39 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
16:03:40 <mauke> > cast (Left 42) :: Maybe (Either Integer ())
16:03:41 <lambdabot>  Add a type signature
16:04:05 <mauke> > cast (Left 'x') :: Maybe (Either Char ())
16:04:05 <lambdabot>  Add a type signature
16:04:08 <omnId> Left 42 :: Either Integer a, a isn't specified
16:04:10 <paczesiowa> > fromJust ( cast (Left 42)) :: Either Integer ()
16:04:10 <mauke> I give up
16:04:11 <lambdabot>  Add a type signature
16:04:21 <omnId> mauke: ^
16:04:26 <LoganCapaldo> mauke: it needed the type of Left 42
16:04:58 <mauke> > cast (Left 42 :: Either Integer ()) :: Maybe (Either Integer ())
16:04:59 <omnId> n00b: year is a [(Int,Int,Int)]?
16:05:00 <lambdabot>  Just (Left 42)
16:05:21 <paczesiowa> mauke: thx
16:05:53 <omnId> n00b: in the list comp, you'll want to extract the (d,m,y)'s from the year, [ ... | (d,m,y) <- year, ... ]
16:06:26 <paczesiowa> > let f x = cast (x :: Either Integer ()) :: Maybe (Either Integer ()) in f (Left 1)
16:06:28 <lambdabot>  Just (Left 1)
16:06:38 <omnId> > cast 'a' :: Maybe Int
16:06:39 <lambdabot>  Nothing
16:07:11 <hpaste>  (anonymous) annotated "Friday 13" with "(no title)" at http://hpaste.org/3219#a3
16:08:12 <omnId> n00b: well you'll need another function wholeYear :: Int -> [(Int, Int, Int)] that gives you the list of days in 2004, given the Int 2004.
16:08:30 <n00b> ok
16:10:34 <omnId> n00b: ignore dayName for now, just check that date d m y == 5 (for Friday).  (And I'd rename that function to weekday)
16:10:56 <mightybyte> Does haskell have any truly mutable data structures?
16:10:57 <omnId> date has an invalid signature
16:11:14 <paczesiowa> mightybyte: yes, inside IO monad
16:11:39 <yitz> mightybyte: Yes, but they are in the IO or ST monad
16:12:09 <omnId> n00b: with that wholeYear function, unlucky should look like [ ... | (d,m,y) <- wholeYear y, ... ]
16:12:17 <dons> mightybyte: sure. lots of monadic mutable structures.
16:12:22 <mightybyte> The reason I ask is that I'm working on generating chess endgame tables and if I'm going to generate big ones, I have to be able to modify the table in place.
16:12:29 <dons> sure.
16:12:34 <omnId> wholeYear gets you the list of dates, and the list comp generator extracts them.
16:12:37 <dons> you can use whatever structure you'd like.
16:12:44 <smashor> is there a predefined function for counting the elements of a list ?
16:12:51 <omnId> length
16:12:57 <mightybyte> I've been working on it in C++, and the more I do, the more I wish I was doing it in Haskell.
16:12:57 <mauke> @hoogle [a] -> Int
16:12:58 <lambdabot> Prelude.length :: [a] -> Int
16:13:08 <smashor> ouch, thanks
16:13:35 <mightybyte> Do these mutable structures impose much overhead on a per-element basis?
16:13:54 <dons> they're compiled to the same code as in C, pretty much
16:14:08 <hpaste>  (anonymous) annotated "Friday 13" with "(no title)" at http://hpaste.org/3219#a4
16:14:18 <paczesiowa> mauke: is that cast idea possible with polimorphic types (like Either a b instead Either Integer ()), perhaps another -fallow-smth-dirty ?
16:14:19 <mightybyte> Ok.  I'm essentially looking for a huge random access array.
16:14:26 <dons> sure. use a IOUArray then
16:14:27 <pjd> mightybyte: they come in boxed and unboxed varieties
16:14:31 <n00b> <omnId>take a look
16:14:33 <dons> its just raw heap values
16:14:35 <n00b> not perfect
16:14:36 <omnId> n00b: you have to *write* the wholeYear function :)
16:14:38 <mightybyte> Huge being > 32 bit index.
16:14:41 <mauke> paczesiowa: I don't think so
16:14:49 <n00b> ok
16:14:50 <dons> mightybyte: do you have enough ram for that?
16:14:53 <dons> or you want it lazy?
16:14:55 <mightybyte> dons: Yes.
16:15:00 <dons> ok, should be fun.
16:15:04 <mightybyte> I have a machine with 8 gigs of RAM
16:15:27 <dons> ghc's unboxed arrays are rather good
16:15:37 <dons> be sure to use -O2 for maximum efficiency
16:15:52 <mightybyte> Ok.  This sounds great.
16:16:00 <dons> here's an example,
16:16:01 <dons>   http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=all
16:16:03 <hpaste>  omnId annotated "Friday 13" with "to start with" at http://hpaste.org/3219#a5
16:16:06 <lambdabot> Title: nsieve-bits benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langu ..., http://tinyurl.com/sxpth
16:16:12 <dons> outperforms C++ for the bit array benchmark
16:16:21 <dons> well, one C++ program
16:16:26 <bos> dons: you know your k-nucleotide code isn't compiling?
16:16:26 <paczesiowa> mauke: even with smth so funky looking like this? case (cast x :: (forall a b . (Expresable a, Expresable b) => Maybe (Expr a b))) of
16:16:27 <dons> and its with 10% of C.
16:16:37 <dons> bos, so i heard. it probably uses lazy bytestring internals?
16:16:52 <bos> no, it's just missing something trivial like -fglasgow-exts
16:17:07 <mightybyte> dons: Ok, this is encouraging.
16:17:08 <dons> oh? so someone should submit a bug ticket for that to the alioth tracker
16:17:12 <bos> dons: are you back from germany yet?
16:17:16 <dons> bos, looks ok here, http://shootout.alioth.debian.org/gp4/benchmark.php?test=knucleotide&lang=all
16:17:18 <lambdabot> Title: k-nucleotide benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/mnnkb
16:17:19 <dons> bos, yeah, got back yesterday
16:17:30 <hpaste>  omnId annotated "Friday 13" with "er, and unlucky is supposed to *use* wholeYear, not get it as an argument :X" at http://hpaste.org/3219#a6
16:17:37 <bos> dons: have fun?
16:17:46 <omnId> n00b: my last change: http://hpaste.org/3219/diff?old=5&new=6
16:17:53 <mightybyte> I keep encountering complex looping infrastructure code that I want to abstract.  It would be so much easier in Haskell.
16:17:59 <dons> bos, it was probably the best ICFP i've been to
16:18:07 <bos> cool
16:18:09 <dons> and along with the hackathon, and CUFP, was a very high energy event
16:18:17 <Beelsebob> hmm... people who know maths, is there any way to simplify cos(tan^{-1}(n_x / n_y))?
16:18:18 <bos> what made the difference?
16:18:38 <dons> there was some real optimism in the air, and the beer was good?
16:18:48 <dons> mightybyte: here's some kick butt Double arrays, http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=all
16:18:50 <lambdabot> Title: spectral-norm benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/bruf8
16:18:53 <dons> we do beat C on that one
16:19:04 <EvilTerran> n_x is the opposite, and n_y is the adjacent (in terms of the arctan)...
16:19:14 <mightybyte> dons: Hmmm, I don't need double arrays.  I try to stick to integer math.
16:19:29 <n00b> <omnId> what would wholeYear be ???
16:19:46 <EvilTerran> cos is adjacent/hypotenuse, so n_y / sqrt(n_x^2 + n_y^2), Beelsebob
16:20:14 <Beelsebob> EvilTerran: of course
16:20:19 <Beelsebob> I know I was missing something obvious
16:20:25 <EvilTerran> i've still got it :D
16:20:46 <EvilTerran> ...man, i haven't done any non-negligable amount of trig for aaages.
16:21:23 <mightybyte> dons: Thanks for the info.  I'll have to see what I can do.
16:21:26 <omnId> hmm, at a first approximation, [(d,m,y) | d <- [30], m <- [1..12]] -- hmm... I'm not so good at list comps.  I need my hofs!!
16:21:29 <EvilTerran> but yeah, in general, if you've got a trig function around an inverse trig function, i think it can always be reduced to fractions and square roots
16:22:25 <omnId> [(<daysForMonthM>,m,y) | m <- [1..12]] -- better, now you'll need the days part
16:22:34 <omnId> wait, no
16:23:45 <omnId> that only gives 12 results, we'll need 365
16:24:16 <omnId> so [ (d,m,y) | m <- [1..12], d <- ... ] -- can you think of what to put in the ..., n00b?
16:24:51 <omnId> the days range from 1 to something dependant on the month.
16:24:57 <omnId> (and year)
16:25:05 <omnId> darned February
16:25:05 <dons> bos, I'll write up an ICFP summary, with video links. anything particular people would be interested in?
16:25:22 <dons> besides how great the beer is in Freiburg? :)
16:25:30 <n00b> feb as 29 plus leap years
16:25:30 <dons> 'cause its rather good
16:25:45 <byorgey> mmm... can you include free beer samples with your writeup?
16:25:51 <omnId> n00b: do you know how to make a list from one to something?
16:25:52 <mrd> mm beer
16:26:02 <omnId> n00b: that's what you put in the ..., can you see why?
16:26:03 <n00b> yes
16:26:09 <n00b> 1..n
16:26:12 <bos> dons: CUFP in particular, i'd guess
16:26:13 <dons> byorgey: i'm not sure the interwebs can handle that. but google must have a new system in beta for that, no?
16:26:22 <omnId> where n = <something based on the month and year>
16:26:30 <dons> bos, ah yes.
16:26:33 <n00b> yes
16:26:38 <byorgey> dons: probably.  Google Beer Search!
16:26:48 <bos> the latest advances in typesetting big piles of type equations are not likely to grab teh redditors
16:26:50 <omnId> so wholeYear y = [ (d,m,y) | m <- [1..12], d <- [1.. <blah>] ] so far
16:27:04 <n00b> yes
16:27:22 <mrd> bos: what advances?
16:27:34 <dons> bos, though icfp was rather practically oriented this year
16:27:37 <omnId> you might even make this another function, daysInMonthAndYear m y = ...
16:27:40 <dons> with the linspire guys, for example, giving a report.
16:27:51 <omnId> then wholeYear y = [ (d,m,y) | m <- [1..12], d <- [1..daysInMonthAndYear m y] ]
16:28:01 <bos> dons: nice
16:28:18 <omnId> n00b: follow?
16:28:19 <dons> and a big haskell session on the last day
16:28:59 <n00b> yes
16:29:19 <omnId> n00b: you think you can manage this last function?
16:30:06 <n00b> i'll try
16:30:24 <omnId> it's mostly a simple case month of 1 -> 31; 2 -> <darned feb>; 3 -> 31; 4 -> 30; ...
16:30:56 <byorgey> February Complicates Everything.
16:32:06 * omnId . o O (I wonder if everyone else always needs that "Thirty days have September..." rhyme, too)
16:32:06 <n00b> yes
16:32:28 * byorgey does the counting on knuckles thing
16:32:36 <omnId> explain
16:33:16 <byorgey> make a fist with one hand.  now point to each of your knuckles and the spaces in between them in turn, counting months as you go.
16:33:42 <byorgey> so January is on your first knuckle, February is the space in between your first and second knuckles, March is the second knuckle, and so on
16:33:48 <omnId> right
16:33:57 <byorgey> when you get to the last knuckle, repeat it and start backwards.
16:34:14 <byorgey> knuckles correspond to 31 days, spaces to 30, except February which you remember anyway.
16:34:23 <omnId> cool
16:34:26 <n00b> yes
16:35:02 <byorgey> more generally, 31 day/30 day months alternate, except for July/August which are both 31.
16:35:09 <omnId> I see
16:36:11 <n00b> m == 7 && m == 8
16:36:34 <byorgey> supposedly because it wouldn't do for Augustus Caesar's month to be shorter than Julius's!
16:36:44 <hpaste>  dataangel pasted "Compile error contradicts itself?" at http://hpaste.org/3220
16:37:00 <n00b> what about year
16:37:09 <omnId> bah.  They can have their months sept, oct, nov, and dec should be 7, 8, 9, and 10!
16:37:31 <omnId> s/months sept/months.  Sept/
16:38:14 <hpaste>  n00b pasted "LeapYear" at http://hpaste.org/3221
16:38:19 <byorgey> dataangel: if it expected [[Int]], but it found [Int], that's the same as trying to match the elements of [[Int]] (which have type [Int]) against the elements of [Int] (i.e., Int)
16:38:25 <byorgey> so it's really saying the same thing
16:38:53 <n00b> ok
16:38:56 <omnId> it sees two lists [a] where a = [Int] and Int, respectively
16:39:07 <dataangel> byorgey: ah
16:39:51 <byorgey> dataangel: in general, it tries to match types [a] and [b] by trying to match a and b.
16:40:13 <n00b> yeah
16:40:21 <EvilTerran> indeed, types Foo...a... and Foo...b... by a and b
16:40:33 <omnId> even generallier, T a to T b with a = b (and in this case T = [])
16:40:38 <EvilTerran> regardless of what type constructor Foo may be
16:40:48 <ivanm> hey LoganCapaldo... you were looking for me?
16:40:56 <n00b> so basically we are limiting the inputs
16:41:10 <omnId> n00b: hm?
16:41:35 <LoganCapaldo> ivanm: yes and thanks
16:41:46 <n00b> m for certain months can's be greater than say 30 or feb 28 all the rest 31
16:41:50 <byorgey> omnId: nice word =)
16:42:06 <omnId> byorgey: I was proud of it myself =D
16:42:12 <EvilTerran> > map (enumFromTo 1) [3,4,5]
16:42:14 <lambdabot>  [[1,2,3],[1,2,3,4],[1,2,3,4,5]]
16:42:39 <EvilTerran> ([a..b] = enumFromTo a b)
16:42:43 <n00b> @google hpaste
16:42:44 <ivanm> LoganCapaldo: no probs.... was googling for church encoding when I found that article
16:42:46 <lambdabot> http://hpaste.org/
16:42:46 <lambdabot> Title: recent - hpaste
16:42:59 <EvilTerran> @hpaste <- this works too
16:42:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:43:05 <omnId> hpaste: url
16:43:05 <hpaste> Haskell paste bin: http://hpaste.org/
16:43:13 <omnId> @wehre paste
16:43:13 <lambdabot> http://hpaste.org/new
16:43:32 <EvilTerran> hpaste: botsnack
16:43:38 <EvilTerran> hm
16:43:41 <EvilTerran> @botsnack
16:43:41 <lambdabot> :)
16:43:47 <omnId> hpaste /= \bot
16:44:00 <EvilTerran> so i see. thought it might reply to that anyway.
16:44:35 <n00b> <omnId> are you gonna finsih explaining
16:44:37 <n00b> ???
16:45:03 <_achilles_> question
16:45:17 <omnId> n00b: which part?  daysForMonthAndYear?
16:46:08 <jaj> http://www.weirdasianews.com/2006/10/13/world-record-in-japan-largest-orgy/
16:46:10 <lambdabot> Title: World Record in Japan: Largest Orgy | Weird Asia News, http://tinyurl.com/yee9w2
16:46:28 <omnId> n00b: oh, I didn't see the new paste.  /me looks
16:46:33 <mauke> jaj: old news is old
16:46:46 <omnId> _achilles_: fire away, silly
16:46:46 <EvilTerran> also, offtopic is #haskell-blah
16:46:52 <_achilles_> does there exist a function which turns strings into an array of one char strings?
16:47:05 <jaj> mauke, I didn't say it was new
16:47:06 <_achilles_> "abc" -> ["a", "b", "c"]
16:47:07 <koala_man> is it an orgy when the people are paired up and don't shuffle?
16:47:08 <mauke> _achilles_: map (: [])
16:47:22 <omnId> > map (\x -> [x]) "abc"
16:47:23 <jaj> mauke, but it's new to me :)
16:47:23 <lambdabot>  ["a","b","c"]
16:47:32 <_achilles_> hmm
16:47:33 <EvilTerran> > map return "foo" :: [[Char]]
16:47:35 <lambdabot>  ["f","o","o"]
16:47:52 <omnId> (\x -> [x]) = (\x -> x : []) = (\x -> (: []) x) = (: [])
16:48:02 <_achilles_> wow...
16:48:04 <EvilTerran> @pl (\x -> [x]
16:48:05 <lambdabot> (line 1, column 11):
16:48:05 <lambdabot> unexpected end of input
16:48:05 <lambdabot> expecting variable, "(", operator or ")"
16:48:08 <EvilTerran> @pl \x -> [x]
16:48:08 <lambdabot> return
16:48:11 <EvilTerran> also
16:48:53 <omnId> n00b: isLeapYear looks correct.
16:48:58 <EvilTerran> @src [] return
16:48:58 <lambdabot> return x    = [x]
16:49:11 <omnId> n00b: except I think you should indent the guards
16:49:53 <omnId> n00b: if the parser sees something at the level of a declaration, it starts a new declaration.
16:51:02 <yitz> @type takeWhile (not.null) . evalState (sequence $ repeat $ State $ splitAt 1)
16:51:04 <lambdabot> forall a. [a] -> [[a]]
16:51:23 <omnId> @slap yitz
16:51:23 <lambdabot> why on earth would I slap yitz
16:51:29 <omnId> because he's silly!
16:51:32 <yitz> > takeWhile (not.null) . evalState (sequence $ repeat $ State $ splitAt 1) $ [1,2,3,4]
16:51:34 <lambdabot>  [[1],[2],[3],[4]]
16:51:46 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3222
16:51:56 <dons> shapr: :) http://arcanux.org/lambdacats/lift-concat.jpg
16:52:05 <yitz> thanks, that felt good.
16:53:51 <omnId> what in the world is that, (anonymous)?
16:53:54 <EvilTerran> > map (take 1) . init . tails $ [1..10]
16:53:56 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
16:54:05 --- mode: ChanServ set +o dons
16:54:09 --- topic: set to '["The Haskell programming language: homeground of the lambdacats!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ", "http://arcanux.org/lambdacats.html" ]' by dons
16:54:16 --- mode: ChanServ set -o dons
16:55:29 <hpaste>  noob pasted "lengths" at http://hpaste.org/3223
16:55:35 <shapr> dons: :-)
16:55:44 <n00b> <omnId> check that out
16:56:17 <omnId> n00b: awesome, but you might want to indent some parts
16:56:23 <dons> shapr: we've a culture all our own now.
16:56:25 <hpaste>  Paczesiowa pasted "(no title)" at http://hpaste.org/3224
16:56:27 <shapr>  heh, yes!
16:56:42 <Paczesiowa> can anyone fix that?
16:56:55 <n00b> ok
16:56:57 <omnId> n00b: now daysForMonthAndYear m y = mLengths y !! m
16:57:05 <EvilTerran> Paczesiowa, er, you know you've misspelt "Expressible"?
16:57:30 <omnId> n00b: er, s/m/(m - 1)/ since (!!) is 0-based
16:57:32 <Paczesiowa> yeah, now I know. thx
16:57:45 <omnId> n00b: daysForMonthAndYear m y = mLengths y !! (m - 1)
16:57:53 <hpaste>  noob annotated "lengths" with "lengths" at http://hpaste.org/3223#a1
16:58:13 <EvilTerran> i wouldn't expect you to need that many explicit foralls; that seems to be what's causing the problem
16:58:30 <Paczesiowa> should get some sleep,  6 hours took me writing 2 lines of code. and they are ugly and dont work
16:58:31 <EvilTerran> {-Couldn't match expected type `Maybe (Expr a b)' <- here, a & b are fixed elsewhere
16:58:50 <EvilTerran> against inferred type `forall a1 b1. (Expresable a1, Expresable b1) => Maybe (Expr a1 b1)' <- here, they aren't
16:59:04 <EvilTerran> so the types are different; the first is a subset (or element) of the second
16:59:53 <EvilTerran> but it can't just make the second type more specific, because you've told it that it's got to be that general
17:00:21 <monochrom> (Just (Expr x y)).  That (Expr x y) does not have a forall type.
17:00:47 <hpaste>  omnId annotated "Friday 13" with "this should work, then" at http://hpaste.org/3219#a7
17:00:53 <omnId> n00b: ^
17:01:03 <monochrom> data (Expresable a, Expresable b) => Expr a b = Expr a b deriving (Show, Typeable)  -- this means (Expr x y) does not have a forall type.
17:01:12 <Paczesiowa> monochrom: how do I add that? those forall keywords are complete magic to me
17:01:32 <omnId> *Main> unlucky 2004
17:01:33 <omnId> [(13,3,2004),(13,11,2004)]
17:01:59 <monochrom> I am not convinced you should pursue that. It comes down to: what's your real question, and what's a right way to do it, rather than keep patching.
17:03:56 <omnId> n00b: do you understand everything there?
17:04:03 <Paczesiowa> I want a function like foo (n::Integer) = show n, and foo (n::SomeOtherType) = doSmthWeirdWith n
17:04:45 <Paczesiowa> I don't want Either and matching based on constructors
17:04:45 <LoganCapaldo> So you want a type class?
17:04:53 <yitz> GADT
17:05:12 <n00b> yeah
17:05:40 <omnId> foo n = maybe (show n) doSomeThingingWeird (cast n)
17:06:31 <Paczesiowa> maybe I want typeclass, but what function should it export? I don't know result type
17:06:37 <omnId> that will doSomethingWierd to Just (something :: SomeOtherType) {- which doSomethingWierd expects)
17:06:53 <EvilTerran> the thing is, the way you're supposed to do that in haskell is with constructors
17:07:08 <EvilTerran> you're trying to write something loosely typed in a strictly typed language
17:07:09 <Paczesiowa> I know that
17:07:11 <n00b> <omnId> that wa good thanks
17:07:45 <omnId> np
17:07:48 <EvilTerran> so of course it's going to be time-consuming and ugly
17:08:09 <omnId> Paczesiowa: did you see the cast I gave?
17:08:27 <n00b> <omnId> Using list comprehension, define a Haskell function mostUnlucky, which lists all the years between 0..2004 which have 3 unlucky days. How many are there ? Are there any years with 4 or more unlucky days in this range ?
17:11:18 <n00b> <omnId> daysIn m y = mLengths y !! (m - 1) why did put m - 1
17:11:58 <omnId> > [31, 28, 31, 30 {- rest omitted -}] !! 1
17:11:59 <lambdabot>  28
17:12:01 <omnId> > [31, 28, 31, 30 {- rest omitted -}] !! 0
17:12:02 <lambdabot>  31
17:12:40 <omnId> m = 1 means January, but January is at index 0
17:13:34 <n00b> ok
17:14:55 <n00b> omnId> Using list comprehension, define a Haskell function mostUnlucky, which lists all the years between 0..2004 which have 3 unlucky days. How many are there ? Are there any years with 4 or more unlucky days in this range ?
17:15:21 <Paczesiowa> omnId: I think it's not problem with finding the function doing the right thing, but assigning correct types
17:15:22 <omnId> how would you start?
17:16:37 <n00b> mostUnlucky y [y | y <- 0...2004]
17:16:52 <omnId> (forget the =?)
17:18:15 <n00b> mostUnlucky y [y | y <- [0.. 2004], unlucky y > 3]
17:18:34 <mauke> s/ y / = /
17:19:25 * omnId yearns for his concatMaps and filters :'O
17:19:26 <n00b> mostUnlucky y [y | y <- [0.. 2004], (length (unlucky y)) > 3]
17:19:40 <omnId> good!
17:19:43 <mauke> s/ y / = /, s/>/>=/
17:19:45 <n00b> somehting like taht
17:19:46 <Paczesiowa> > mostUnlucky = [y | y <- [0.. 2004], (length (unlucky y)) > 3]
17:19:46 <lambdabot>  Parse error
17:19:58 <Paczesiowa> >  [y | y <- [0.. 2004], (length (unlucky y)) > 3]
17:20:06 <lambdabot>   Not in scope: `unlucky'
17:20:31 <Paczesiowa> there should be smth like
17:20:42 <Paczesiowa> (hpaste !! 2785).foo
17:20:49 <omnId> :)
17:20:53 <Cale> hehe
17:21:21 <omnId> oh, if hpaste were only a [Module]
17:21:25 <Cale> That's almost as bad as my OEIS syntax :)
17:21:30 <mauke> foo (hpaste 2785) plz
17:21:32 <byorgey> Paczesiowa: that would be awesome =)
17:21:45 <mauke> or hpaste 2785 "foo"
17:22:07 <halcyon10> @pl (\n x->f (head$x!!n))
17:22:07 <lambdabot> ((f . head) .) . flip (!!)
17:22:13 <byorgey> seriously... how feasible would it be to write some kind of plugin for LB that would import functions from hpaste?
17:22:16 <omnId> maybe 2785.2 for annote #2
17:22:19 <Paczesiowa> or maybe modules should be first class
17:22:41 <Cale> Where typing [1,2,3,6,11,23..] would give the list of the number of trees on n unlabelled nodes by looking up the definition in Sloane's encyclopedia of integer sequences :)
17:23:09 <byorgey> hehe =)
17:23:10 <Cale> (and take the first result)
17:23:54 <hpaste>  n00b pasted "mostUnlucky" at http://hpaste.org/3225
17:23:57 <byorgey> hm, an OEIS module isn't a bad idea though
17:24:06 <Cale> Actually, yeah maybe we could have something like Sloane.a000055
17:24:07 <omnId> would it be IO [a] since were looking up internet, Cale? :)
17:24:12 <n00b> <omnId> It returns nothing
17:24:22 <Cale> omnId: at compile time
17:24:22 <n00b> [] empty list
17:24:27 <dmwit> omnId: No need, they're pure sequences. =)
17:24:28 <omnId> n00b: s/>/>=/
17:24:44 <omnId> dmwit: so GHC comes packed with the list?
17:25:01 <dmwit> ...ore at least a function to compute the list at run-time.
17:25:08 <byorgey> Cale: seriously, though, you could have a function oeis :: (Integral a) => [a] -> IO [a]
17:25:09 <Cale> We'd also probably need to get Haskell code for the sequences into the encyclopedia :)
17:25:11 <dmwit> (Since most of them are infinite lists.)
17:25:18 <monochrom> Template Haskell is the perfect tool for looking up the Internet at compile time. :)
17:25:53 <hpaste>  n00b annotated "mostUnlucky" with "mostUnlucky" at http://hpaste.org/3225#a1
17:25:54 <omnId> dmwit: I think in haskell too much.  Inifinite lists are nothing but ordinary to me.
17:26:20 <omnId> n00b: that's a bunch!
17:26:20 <n00b> <omnId> look at my result for > 2
17:26:28 <monochrom> Functional programming and lazy evaluation are also nothing but obvious to me.
17:26:34 <omnId> (> 2) = (>= 3), btw
17:26:35 <n00b> cool  ain't it
17:26:58 <omnId> n00b: you've already determined that there aren't any with 4.
17:27:23 <Paczesiowa> does anybody have link to that famous a -> b function using unsafePerformIO
17:27:30 <n00b> ok
17:27:32 <Cale> Paczesiowa: I can write it
17:27:48 <n00b> is there a perdefined function for between
17:27:58 <Paczesiowa> uri or function?
17:27:59 <n00b> or do I just use &&
17:28:04 <omnId> n00b: to find how many there are, do 'length (mostUnlucky [0..2004])' in ghci
17:28:18 <omnId> n00b: inRange
17:28:21 <omnId> @index inRange
17:28:21 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
17:28:29 <omnId> import Data.Ix(inRange)
17:28:42 <omnId> @type inRange
17:28:45 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
17:28:49 <omnId> > inRange (0, 10) 5
17:28:50 <lambdabot>  True
17:29:13 <omnId> > map (inRange (0, 10)) [-1,0,1,9,10,11]
17:29:15 <lambdabot>  [False,True,True,True,True,False]
17:29:20 <omnId> inclusive
17:29:37 * omnId hugs map
17:29:39 <Olathe> @src inRange
17:29:39 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:29:40 <halcyon10> n00b: your definition should rather be mostUnlucky ys = [y | y <- ys, (length (unlucky y)) > 2]  if you use it as mostUnlucky [0..2004]
17:29:47 <omnId> @src Int inRange
17:29:47 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:29:56 <Olathe> @hoogle inRange
17:29:56 <lambdabot> Ix.inRange :: Ix a => (a, a) -> a -> Bool
17:30:06 <Olathe> @src Ix.inRange
17:30:06 <lambdabot> Source not found. stty: unknown mode: doofus
17:30:16 <omnId> @src Ix
17:30:16 <lambdabot> class (Ord a) => Ix a where
17:30:16 <lambdabot>     range           :: (a,a) -> [a]
17:30:16 <lambdabot>     index           :: (a,a) -> a -> Int
17:30:16 <lambdabot>     inRange         :: (a,a) -> a -> Bool
17:30:16 <lambdabot>     rangeSize       :: (a,a) -> Int
17:30:25 <omnId> class method
17:30:27 <hpaste>  noob annotated "mostUnlucky" with "mostUnlucky" at http://hpaste.org/3225#a2
17:30:32 <Olathe> Ix is a strange name.
17:30:51 <n00b> <omnId>  check that
17:31:15 <Cale> !hpaste
17:31:17 <omnId> n00b: and since you're using [0..2004] directly, the mostUnlucky function ignores its y argument, so you should probably omit it
17:31:18 <Cale> !paste
17:31:18 <hpaste> Haskell paste bin: http://hpaste.org/
17:31:39 <hpaste>  Cale pasted "coercion using polymorphic reference" at http://hpaste.org/3226
17:31:42 <n00b> ok
17:32:06 <omnId> Cale: *gag*
17:32:21 <hpaste>  noob annotated "mostUnlucky" with "mostUnlucky" at http://hpaste.org/3225#a3
17:33:07 <Cale> Ahaha:  *Main> unsafeCoerce [1,2,3] :: Integer
17:33:22 <Cale> It prints "-", then hangs
17:33:54 <omnId> what's unsafeCoerce () :: Integer?
17:34:03 <Cale> *Main> unsafeCoerce () :: Integer
17:34:03 <Cale> -1238411708
17:34:18 <omnId> a box pointer or something?
17:34:27 <Cale> probably something like that.
17:34:49 <Cale> *Main> unsafeCoerce 'A' :: Integer
17:34:50 <Cale> 65
17:34:56 <omnId> :O
17:35:02 <Paczesiowa> it stays the same between ghci restarts
17:35:05 <Cale> That's actually kind of surprising :)
17:35:21 <Paczesiowa> or extremely lucky:>
17:35:23 <sjanssen> Cale: not surprising if you know a bit about GHC's heap layout
17:35:51 <omnId> sjanssen: the salient point is that we *don't* :)
17:36:18 <Cale> sjanssen: What about the constructor for Integer though?
17:36:20 <sjanssen> basically, struct { int tag; byte[] payload; }
17:36:25 <sjanssen> @src Integer
17:36:25 <lambdabot> data Integer = S# Int#
17:36:25 <lambdabot>              | J# Int# ByteArray#
17:36:37 <sjanssen> @src Char
17:36:37 <lambdabot> data Char = C# Char#
17:36:43 <Cale> @src Int
17:36:43 <lambdabot> data Int = I# Int#
17:36:46 <Cale> I would be less surprised with Int being okay
17:36:51 <Cale> er, a little
17:36:54 <omnId> X# are low-level tags?
17:36:56 <sjanssen> C# and S# have the same tag, and their payloads are both one word-sized
17:37:01 <Cale> ah, okay
17:37:04 <Cale> yeah, I see
17:37:11 <Cale> That's nice :)
17:37:25 <Cale> Lucky that S# Int# is first ;)
17:37:30 <sjanssen> ooh, I bet you could write a nice approximate logBase 2 function with unsafeCoerce :)
17:38:29 <Cale> Can you explain the memory allocation done by  unsafeCoerce "hello" :: Integer ?
17:38:32 <Pseudonym> You don't actually need unsafeCoerce for that, if you've got access to the definition of Integer.
17:38:37 <Pseudonym> Which you do.
17:38:59 <sjanssen> sure
17:40:04 <omnId> > case 65 of S# x -> C# (fromIntegral x)
17:40:04 <lambdabot>  Parse error in pattern
17:40:47 <dufflebunk> Is there a standard btree library?
17:40:57 <yitz> @type ((.).(.)) (uncurry (&&)) $ join $ \x y->(<x)***(>y)
17:40:58 <lambdabot> forall b. (Ord b) => b -> (b, b) -> Bool
17:41:27 <yitz> > (((.).(.)) (uncurry (&&)) $ join $ \x y->(<x)***(>y)) 5 (4, 6)
17:41:29 <lambdabot>  True
17:41:35 <yitz> > (((.).(.)) (uncurry (&&)) $ join $ \x y->(<x)***(>y)) 3 (4, 6)
17:41:36 <lambdabot>  False
17:41:40 <yitz> > (((.).(.)) (uncurry (&&)) $ join $ \x y->(<x)***(>y)) 7 (4, 6)
17:41:41 <lambdabot>  False
17:42:06 <omnId> > (x (l,u) -> l < x && x < u) 5 (4, 6)
17:42:06 <lambdabot>  Parse error
17:42:10 <omnId> > (\x (l,u) -> l < x && x < u) 5 (4, 6)
17:42:12 <lambdabot>  True
17:42:30 * omnId pokes yitz with some lambdas
17:42:53 <Cale> dufflebunk: No, but there's Data.Set/Data.Map
17:43:18 <yitz> @pl \x y -> (<x)***(>y)
17:43:18 <lambdabot> (. flip (>)) . (***) . flip (<)
17:43:27 <sjanssen> omnId: be careful, lambdas are pointy
17:43:31 <byorgey> dufflebunk: there's also Data.Tree, which is a simple implementation of n-way branching trees
17:43:32 <Cale> dufflebunk: Which are implemented using balanced trees.
17:43:54 <yitz> @pl \x (l,u) -> l < x && x < u
17:43:55 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (&&)) .) . flip (<)) (<)
17:44:04 <yitz> yuck, mine's nicer
17:44:29 <halcyon10> what does *** do?
17:44:34 <yitz> @pl \x l u -> l < x && x < u
17:44:34 <lambdabot> ap (flip . (((.) . (&&)) .) . flip (<)) (<)
17:44:58 <omnId> > ((+1) *** (+(-1))) (5, 5)
17:45:00 <lambdabot>  (6,4)
17:45:03 <yitz> @type (***)
17:45:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:45:07 <byorgey> halcyon10: for normal functions,  (f *** g) (x,y) = (f x, g y)
17:45:08 <dufflebunk> Cale: In this case I need a tree.
17:45:16 <dufflebunk> byorgey: I'll take a look, thanks.
17:45:17 <hpaste>  Paczesiowa annotated "(no title)" with "loops writing Expr over and over" at http://hpaste.org/3224#a1
17:45:22 <byorgey> halcyon10: but it's actually a more general operation on Arrows.
17:45:31 <Paczesiowa> Cale:  could you look at that?
17:46:00 <Cale> dufflebunk: It's easy enough to implement your own datatype for whatever sort of trees you want, but the operations and balancing would be the tricky part.
17:46:08 <byorgey> halcyon10: so in other words, f *** g is a function which performs f on the fst element of a tuple, and g on the snd.
17:46:10 <halcyon10> ah, i see, i could have used this function a dozen times i think...
17:46:26 <byorgey> there's also (f &&& g) x = (f x, g x)
17:46:44 <byorgey> defined in Control.Arrow
17:46:51 <dufflebunk> Cale: Yeah. Balancing don't be too important though since I have a fixed range.
17:46:56 <omnId> which = (f *** g) . (\x -> (x, x)) -- i.e. splits x into a pair before applying (***)
17:47:16 <yitz> @pl \x y -> (x>)***(y<)
17:47:17 <lambdabot> (. (<)) . (***) . (>)
17:47:26 <Paczesiowa> looks like a fish
17:47:31 <Cale> dufflebunk: what is it that you're implementing?
17:47:43 <yitz> OK, let's swallow the fish:
17:47:52 <halcyon10> so (&&&) = which ?
17:48:11 <omnId> halcyon10: er, I was saying "which equals the following:"
17:48:18 <yitz> @type ((.).(.)) (uncurry (&&)) $ join $ (. (<)) . (***) . (>)
17:48:19 <lambdabot> forall b'. (Ord b') => b' -> (b', b') -> Bool
17:48:30 <dufflebunk> Cale: I need to have fast lookup on line segments and points
17:48:36 <halcyon10> oh, lol, sorry, didn't get it ;)
17:48:46 <yitz> > (((.).(.)) (uncurry (&&)) $ join $ (. (<)) . (***) . (>)) 5 (4,6)
17:48:47 <lambdabot>  True
17:48:50 <Cale> dufflebunk: Oh, so maybe something like a quadtree?
17:48:53 <omnId> (f &&& g) x = (f x, g x) {- which equals: -} = (f *** g) . (\x -> (x,x))
17:49:03 <dufflebunk> Cale: yeah, I guess that name fits
17:49:06 * dufflebunk googles
17:49:18 <Cale> http://en.wikipedia.org/wiki/Quadtree
17:49:19 <lambdabot> Title: Quadtree - Wikipedia, the free encyclopedia
17:49:27 <omnId> halcyon10: I was just using the = sign instead of the word 'equals', not defining something named 'which' :)
17:49:50 <dufflebunk> Cale: Yes, a quad tree.
17:50:01 <halcyon10> i mean, now i get it
17:50:31 <omnId> right, now I get that you got it after you didn't get it.  Get it?
17:50:35 <yitz> @type (<) &&& (>)
17:50:36 <lambdabot> forall a. (Ord a) => a -> (a -> Bool, a -> Bool)
17:51:04 <halcyon10> hehe, got it
17:51:06 <omnId> good.
17:51:27 <omnId> @vixen do you get it?
17:51:27 <lambdabot> maybe. do you?
17:51:35 <omnId> who knows anymore
17:52:02 * omnId runs in circles waving his arms wildly
17:52:07 <Botje> @vixen should I go sleep?
17:52:07 <lambdabot> isn't it obvious?
17:52:23 <Botje> nothing ever is :[
17:52:26 <omnId> @bot
17:52:26 <lambdabot> :)
17:52:34 <Cale> You could perhaps represent a quadtree using the type  data QuadTree = QTLeaf [Point] | QTBranch QuadTree QuadTree QuadTree QuadTree
17:52:57 <yitz> @type uncurry (***) . (<) &&& (>)
17:52:58 <Botje> and risk havind quadtrees of different levels?!
17:52:59 <lambdabot>     Couldn't match expected type `(a b c, a b' c')'
17:52:59 <lambdabot>            against inferred type `a1 -> Bool'
17:53:09 <Botje> (I believe there was a paper about guaranteeing that in the type system)
17:53:20 <Cale> Botje: What's wrong with having different levels?
17:53:40 <yitz> @type uncurry (***) . ((<) &&& (>))
17:53:42 <lambdabot> forall a. (Ord a) => a -> (a, a) -> (Bool, Bool)
17:53:46 <Cale> Botje: Quadtrees usually do have different levels, that's actually part of what makes them an efficient representation.
17:53:58 <Botje> i see
17:54:25 <Botje> i'll go to sleep now (3am)
17:55:09 <yitz> @type ((.).(.)) (uncurry (&&)) $ uncurry (***) . ((<) &&& (>))
17:55:11 <lambdabot> forall a. (Ord a) => a -> (a, a) -> Bool
17:55:44 <yitz> > (((.).(.)) (uncurry (&&)) $ uncurry (***) . ((<) &&& (>))) 5 (4, 6)
17:55:46 <lambdabot>  False
17:55:52 <yitz> Wrong!
17:55:59 <Cale> wtf?
17:56:25 <Cale> hehe
17:56:33 <Cale> > (((.).(.)) (uncurry (&&)) $ uncurry (***) . ((>) &&& (<))) 5 (4, 6)
17:56:35 <lambdabot>  True
17:56:39 <omnId> > 5 < 4 && 5 > 6
17:56:41 <lambdabot>  False
17:56:52 <lambdabot> You really expect me to parse all that?!
17:56:52 <omnId> seems sensible :)
17:57:05 <omnId> lambdabot: yes.  Now do your work.
17:57:10 <LoganCapaldo> laaaaaaaaaaambdabot
17:57:25 <LoganCapaldo> @botsnack
17:57:25 <lambdabot> :)
17:57:26 <yitz> Sorry Cale, middle of the night here, going to sleep :)
17:58:11 <omnId> ((>) &&& (<)) is the double-blackeyed angry dude with braces operator
17:59:47 <byorgey> hehe
17:59:56 <Cale> Yay, new Catsters videos!
18:00:12 <sorear> There are too many over-opinionated people on -cafe@.
18:00:31 <pastorn-rr> @type ((>) &&& (<))
18:00:32 <ddarius> They should all melt into the status-quo.
18:00:34 <lambdabot> forall a. (Ord a) => a -> (a -> Bool, a -> Bool)
18:00:40 <omnId> programmers are opinionated animals
18:00:42 <Pseudonym> I disagree, and everyone who thinks so is an idiot!
18:01:11 <pastorn-rr> @type ((>) &&& (<)) 5
18:01:13 <lambdabot> forall a. (Ord a, Num a) => (a -> Bool, a -> Bool)
18:01:22 <Cale> boo, the volume level is too quiet to hear
18:01:25 <omnId> so ((5>), (5<))
18:01:41 <ddarius> Cale: Not -too- quiet, but annoying quiet.
18:01:42 <omnId> uncurry (***) ((5>), (5<)) = (5<) *** (5>)
18:01:46 <pastorn-rr> @type ((0>) &&& (<0))
18:01:48 <lambdabot> forall t. (Num t, Ord t) => t -> (Bool, Bool)
18:01:55 <pastorn-rr> @type ((0>) &&& (<0)) 5
18:01:56 <Cale> I can barely hear it at all.
18:01:56 <lambdabot> (Bool, Bool)
18:02:00 <pastorn-rr> awsum
18:02:33 <Cale> oh, on speakers I can make it okay by turning them up all the way. I can't hear it at all on headphones.
18:02:34 <omnId> I do believe (0>) = (<0)
18:03:22 <ddarius> omnId: That's because you live in your world where instances of Num and Ord should be partially ordered rings.
18:03:54 <sjanssen> I ought to join that haskell-cafe thread: PI IS EXACTLY THREE
18:04:14 <ddarius> and should be moved to the Num class with that definition as default
18:04:19 <sorear> sjanssen: good idea, it needs a nice injection of satire
18:04:20 * omnId starts the PI IS EXACTLY PI thread
18:04:59 <sjanssen> hmm, where to attach my reply
18:05:01 <Pseudonym> Pi _is_ exactly three, for large values of three.
18:05:04 * dmwit doesn't see a "PI IS EXACTLY THREE" thread in the Haskell-cafe archives
18:05:14 <sjanssen> dmwit: the thread is named 'pi'
18:05:55 <sjanssen> it is getting quite long and pointless
18:06:24 * omnId isn't surprised.  Those threads are destined to be not much but.
18:08:22 <dmwit> wow
18:08:25 <dmwit> it is boring
18:08:30 <dmwit> I'm going to eat dinner.
18:09:18 <LoganCapaldo> pi tastes like delcious
18:09:28 <LoganCapaldo> my high school used to have pie day
18:09:41 <omnId> Pseudonym: you need only specify a numeral system such that the numeral "three" represents the number "pi".
18:09:47 <LoganCapaldo> March 14th
18:09:51 <LoganCapaldo> people brung in pies
18:09:55 <dufflebunk> Cale: Yeah, it'll look something like that, but it has to store points and segments without breaking up segments.
18:10:00 <ddarius> "brung"?
18:10:04 <LoganCapaldo> So you got free pie that day
18:10:26 <LoganCapaldo> It's the vasty superior spelling of brought
18:10:53 <omnId> ddarius: you gotsa porblem wit bad spelling?
18:11:56 <sjanssen> brung seems the appropriate word for pie
18:13:50 <omnId> > it's / 9000
18:13:54 <chessguy> hehe, i just stumbled across this today: http://arcanux.org/lambdacats.html
18:13:55 <lambdabot> Title: Lambdacats
18:13:58 <lambdabot>   Not in scope: `it's'
18:14:12 <omnId> @topic-tell #haskell
18:14:12 <lambdabot> ["The Haskell programming language: homeground of the lambdacats!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ", "http://arcanux.org/lambdacats.
18:14:12 <Pseudonym> I was disappointed that it wasn't spelled "CATERMORFIZM".
18:14:12 <lambdabot> html" ]
18:14:29 <Pseudonym> Or, at any rate, something starting with "CATER".
18:14:45 <byorgey> Pseudonym: I'll try harder next time =)
18:14:52 <Pseudonym> :-)
18:14:56 <omnId> oh gawd.  /me visits the site for the first time
18:14:58 <omnId> >.>
18:15:13 <Pseudonym> Do you take submissions, BTW?
18:15:32 * omnId wonders how quickly 4chan'll invade
18:15:32 <chessguy> i don't know whose site it is
18:15:44 <chessguy> there's a contact email at the bottom of the page
18:15:56 <chessguy> or ask shapr, he just submitted one today
18:16:51 * omnId laughs at "tail recursion"
18:16:59 <omnId> TAIL RECURSION I should say
18:17:09 <sorear> it's all shillelagh's fault
18:17:22 <sorear> @slap shillelagh
18:17:22 * lambdabot beats up shillelagh
18:17:27 <LoganCapaldo> No!
18:17:34 <LoganCapaldo> Violence is not the way
18:17:41 <chessguy> i love the fillBelly = foldr (++) [] fridgeContents
18:17:47 * omnId beats up LoganCapaldo 
18:18:17 <omnId> s/(++) []/put belly/, I'd think
18:18:39 <mauke> forgetting a "do" can lead to very weird type errors
18:19:22 <chessguy> @ghc
18:19:23 <lambdabot> ghc says: Multiple default declarations
18:24:03 <Pseudonym> BTW, I'm serious about that.  I've got a submission.  Should I just send it to lambdacats@gmail.com?
18:24:49 <chessguy> Pseudonym, who are you asking?
18:24:58 <Pseudonym> byorgey, presumably.
18:25:09 <chessguy> @seen byorgey
18:25:09 <lambdabot> I saw byorgey leaving #haskell-blah and #haskell 6m 8s ago, and .
18:25:13 <Pseudonym> Ah.
18:25:15 <Pseudonym> D'oh!
18:25:47 <dons> yes, byorgey is responsible.
18:26:01 <Pseudonym> Or irresponsible, arguably.
18:26:30 <dons> :)
18:26:33 <dons> i think its great.
18:26:43 <Pseudonym> Oh, it's amusing.
18:26:43 <dons> we've our own culture, our own internet memes
18:26:59 * Pseudonym sends it anyway
18:29:02 <Pseudonym> If someone wants a go, there's got to be an Arrow joke in this:
18:29:04 <Pseudonym> http://www.flickr.com/photos/v3ga/1124959542/
18:29:05 <lambdabot> Title: Eyes and arrows on Flickr - Photo Sharing!
18:30:27 <Cale> I iz codomain?
18:31:25 <ddarius> Or a coequalizer
18:31:39 <monochrom> hehe
18:36:13 <Cale> Yeah, "I can has coequalizer?" would be great :)
18:36:28 <dons> I is Kleisli Kat!
18:36:46 <dons> we need an automated lambdacat annotator
18:36:59 <dons> which submits it to a daily lambdabcat feed
18:37:19 <dons> Your search - comonad cocats - did not match any documents.
18:37:28 <dons> what's wrong with the interwebs?
18:37:34 <Philippa_> cocat = dog, surely?
18:37:48 <dons> hmm, we need to see the Catsters!
18:38:16 <dons> i have to ponder that some more Philippa_
18:38:29 <Philippa_> only then someone's going to do something really horrific with the initial algebra / final coalgebra overlap in CPO...
18:39:19 <LoganCapaldo> cocat!! Madness!
18:40:47 <halcyon10> i compiled a program with the -threaded option with ghc and though it runs in two threads when started with +RTS -N2 it still uses just one thread. Is this normal behaviour?
18:41:18 <Cale> http://cale.yi.org/autoshare/coequaliser.jpg
18:41:34 <merus> hahahahah
18:41:37 <dons> :)
18:42:22 <sorear> halcyon10: GHC isn't magic, you need to explicitly annotate the parallelism
18:42:38 <dons> unless you use Satnam Singh's ghc branch
18:42:40 <sorear> with Control.Concurrent or Control.Parallel
18:42:50 <dons> which uses runtime profiling to annotate `par` points in code, implicitly
18:42:55 <dons> forking those speculative thunks
18:43:20 <dons> if you've nothing else to do with 15/16 of your cores, may as well fork some pure thunks
18:43:26 <Pseudonym> http://andrew.bromage.org/bitestring.jpeg
18:43:36 <dons> :D
18:44:20 <LoganCapaldo> oh dear god
18:44:29 <LoganCapaldo> that is...
18:44:31 <dons> the 'lazy evaluation' cat cluster should really be a forkIO or cycle cat
18:44:33 <LoganCapaldo> unsurpassable
18:44:38 <Pseudonym> What is?
18:44:55 <Pseudonym> http://andrew.bromage.org/dilimitd.jpeg
18:45:00 <Pseudonym> This is much more fun than working.
18:45:09 <omnId> Pseudonym: needs bigger and in IMPACT font
18:45:28 <halcyon10> but shouldn't things like map get parallelised automatically, i thought that this is one of the benefits of functional programming languages, that the compiler has the chance to parallelise the code because there are no sideeffects
18:45:34 * Pseudonym will use IMPACT in future, okay
18:45:47 <dons> halcyon10: the trick is to parallelise work in big enough chunks
18:45:51 <dons> which is pretty non-trivial
18:46:09 <dons> since the overhead of forking even a haskell thread is enough that you don't want  to do it one per cons node
18:46:12 <dons> but note,
18:46:15 <Pseudonym> And for the hell of it:
18:46:17 <Pseudonym> http://andrew.bromage.org/manyell.jpeg
18:46:17 <dons> :t Control.Parallel.parMAp
18:46:19 <dons> :t Control.Parallel.parMap
18:46:19 <lambdabot> Not in scope: `Control.Parallel.parMAp'
18:46:20 <omnId> Pseudonym: and also crop it.  LOLCATS is srs bznss.
18:46:21 <lambdabot> Not in scope: `Control.Parallel.parMap'
18:46:26 <dons> :t Control.Parallel.Strategies.parMap
18:46:28 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
18:46:35 <dons> if you know your elements are expensive enough
18:47:00 <dons> halcyon10: so yeah, purity makes it a whole lot easier: you can always speculate your pure code
18:47:07 <dons> its just a matter of doing so in a worthwhile way
18:47:17 <dons> which depends on costs and other heuristics
18:47:36 <dons> hence profile guided implicit paralellism which is in a ghc branch
18:48:00 <dons> use profiling to guesstimate the costs fairly accurately, and that let's the compiler work out what is worthwhile forking
18:48:05 <dons> make sense?
18:48:26 <halcyon10> i'll have a look at Control.Parallels. Oh nice, does that mean it builds a heuristic at runtime and decides to fork threads based on that?
18:48:50 <Pseudonym> OK, so what's the right Gimp-fu to do the white-on-black border?
18:48:55 <halcyon10> yep, nice
18:48:57 <dons> no, you run it once, generating profiling info, which you feed back in, to get implcit parallelism on future runs
18:49:26 <dons> so this is a whole lot further ahead than your average language, since purity removes the main barrier
18:49:35 <dons> but still, you have to work out what is worthwhile to run in parallel somehow
18:49:40 <dons> once you've identified all the possible points
18:50:16 <dons> :t Control.Parallel.Strategies.par -- is the cheapest way to currently annotate your code for parallelism
18:50:18 <lambdabot> Not in scope: `Control.Parallel.Strategies.par'
18:50:24 <dons> :t Control.Parallel.par -- is the cheapest way to currently annotate your code for parallelism
18:50:25 <lambdabot> forall a b. a -> b -> b
18:50:27 <dons> that one.
18:50:41 <dons> the implicit parallelism branch just inserts those `par`s for you
18:51:09 <dons> i think its a really interesting area
18:51:38 <dons> since we don't have the gunky set up of indentifying pure functions first, you can instead concentrate on actually working out which jobs are worthwhile to spark
18:55:19 <jaredj> Pseudonym: select things, Edit -> Stroke Selection...
18:55:40 <jaredj> Pseudonym: i think that's what you mean
18:56:29 <Pseudonym> I did it by hand in the end.
18:56:32 <jaredj> dons: so you use your profiling information to come in under `par`
18:56:32 <Pseudonym> http://andrew.bromage.org/streem.jpeg
18:56:40 <Pseudonym> Error on the left, but not too bad.
18:56:55 <jaredj> lol, cats!
18:57:17 <jaredj> dons: i expect that's a meaningless statement, i just wanted to say `par`
18:57:22 <dons> :)
18:57:36 * LoganCapaldo wants a stream fusion one
18:57:41 <jaredj> mwahaha
18:57:46 <LoganCapaldo> cat in a river delta? :)
18:57:53 <jaredj> oh
18:57:58 <dons> concatMap is the hard thing to fuse as a stream, interestingly
18:57:59 <Pseudonym> http://www.flickr.com/photos/7818698@N08/492050854/ <- par
18:58:00 <lambdabot> Title: Cat & Golf Ball on Flickr - Photo Sharing!
18:58:00 <dons> nested concatMaps
18:58:35 <Pseudonym> Actually, I like this one even better:
18:58:36 <halcyon10> that sounds really interesting, i'll play around with Control.Parallel now and see if i can speed up my Poker program along the way :)
18:58:37 <Pseudonym> http://www.flickr.com/photos/pianomom/492000735/
18:58:38 <lambdabot> Title: Golf Cat on Flickr - Photo Sharing!
18:59:02 <jaredj> > talkOnIrc `par` hackOnDarcs
18:59:03 <lambdabot>   Not in scope: `hackOnDarcs'
18:59:10 <jaredj> Pseudonym: that's a lengthy cat
19:01:38 <LoganCapaldo> I'm on your courses, golfing your code?
19:01:44 <dons> halcyon10: should be fun. do you have a couple of cores handy?
19:02:00 <chessguy> s/your/yer/
19:02:40 <halcyon10> dons: just 2 (core duo) but it'll be fun nonetheless i think :)
19:03:39 <dons> yeah, you can get good speedups parallelising over 2 cores
19:03:45 <dons> no scalability worries at  that point
19:04:37 <Pseudonym> Oh, I get it now.
19:05:27 <Pseudonym> http://andrew.bromage.org/catt.jpeg
19:05:28 <Pseudonym> Like that.
19:05:54 <Cale> ahaha
19:06:45 <jaredj> lol you're pumping them out
19:06:52 <Pseudonym> Compiling!
19:07:19 <dons> heh
19:11:03 <jaredj> @hoogle Int -> CLong
19:11:07 <lambdabot> No matches, try a more general search
19:12:39 <jaredj> any wise way to use #defined C constants in haskell?
19:13:26 <jaredj> oh - no wait
19:13:33 <jaredj> any wise way to use C enums in haskell?
19:13:55 <dons> using hsc2hs
19:14:03 <dons> the interface generator, or perhaps c2hs
19:14:16 <dons> have a look at the FFI spec, or an FFI binding
19:14:41 <thoughtpolice> wee! my ghc api wrapper I wrote a while back should be sufficient for my irc bot once 6.8 comes out since I need hs-plugins right now for the hot code swapping.
19:15:25 <thoughtpolice> so at least I won't have to worry about hs-plugins getting dropped and not having something to fall back on.
19:20:18 <jaredj> oh yeah. you swap that hott code. swap it good
19:20:32 <jaredj> (...?!)
19:21:45 <thoughtpolice> oh, i will. i will...
19:24:04 <jaredj> any nice way to say this:
19:24:11 <iank> nah
19:24:27 <jaredj> (SSLv2 `elem` o) ? 2 : (SSLv3 `elem` o) ? 3 : ...
19:24:30 <jaredj> oo can i say
19:24:42 <jaredj> foo o | SSLv2 `elem` o = 2
19:24:44 <jaredj> [...] ?
19:25:34 <thoughtpolice> yeah, a guard would probably be a nicer way to solve that
19:27:21 <jaredj> so i would go
19:27:26 <jaredj> foo o | blabla = ...
19:27:31 <jaredj>        | otherbla = ...
19:27:45 <thoughtpolice> yes, and in the case it doesn't match anything
19:27:49 <thoughtpolice>     | otherwise = ...
19:29:34 <jaredj> right
19:31:59 <jaredj> :t fromIntegral
19:32:01 <lambdabot> forall a b. (Num b, Integral a) => a -> b
19:32:16 <jaredj> > fromIntegral 3 :: CLong
19:32:16 <lambdabot>   Not in scope: type constructor or class `CLong'
19:32:27 <jaredj> > fromIntegral 3 :: Foreign.C.Types.CLong
19:32:28 <lambdabot>      Not in scope: type constructor or class `Foreign.C.Types.CLong'
19:34:42 <xelxebar> Hail, friends in Haskell.
19:35:02 <Pseudonym> We who are about to be evaluated, salute you!
19:35:52 <jaredj> oh noes!
19:36:10 <jaredj> lol that's the longest error i've gotten yet from ghc
19:36:21 <jaredj> er how do i resolve import cycles
19:36:33 <mauke> AVE! EVALVATVRI TE SALVTANT!
19:36:34 <LoganCapaldo> break the cycle?
19:36:41 <jaredj> :P
19:37:10 <jaredj> import Darcs.Arguments ( DarcsOption )
19:37:27 <jaredj> i need that
19:37:32 <LoganCapaldo> its a cycle in not your code?
19:37:45 <jaredj> well, i added that import, thus creating the cycle...
19:37:57 <xelxebar> Haha, :)  I've been trying to construct a data type which allows arbitrarily deep sets (recursive sets?) and I ended up with something like: data RecSet a = RNull (Set a) | RSet (RecSet a)
19:38:43 <mauke> RecSet* (Set a)
19:39:49 <jaredj> challenge: add eight options that impact how darcs fetches things using libcurl
19:39:53 <xelxebar> what's the asterisk?
19:40:00 <LoganCapaldo> magic
19:40:02 <jaredj> problem: argh, adding eight params to functions everywhere?
19:40:07 <mauke> pseudo regex syntax
19:40:10 <jaredj> hack: ah, just pass the list of DarcsOptions
19:40:17 <mauke> 0 or more RecSet, followed by a Set
19:40:18 <jaredj> problem: import cycle
19:40:46 <ddarius> xelxebar: Perhaps you wanted data RecSet a = RNull (Set a) | RSet (RecSet (Set a))
19:41:35 <jaredj> ddarius: isn't that data RecSet a = RNull (Set a ) | RSet (RecSet a) ?
19:41:51 <xelxebar> whoops, typo:  data RecSet a = RNull (Set a) | RSet (Set (RecSet a))
19:41:56 <ddarius> jaredj: No, that's what xelxebar had at the beginning.
19:42:05 <jaredj> oh right.
19:42:58 <xelxebar> anyway, the ultimate "type" i was going after was something like (Set .. Set a)
19:43:23 <LoganCapaldo> you're not allowed to do that though right?
19:43:42 <jaredj> Bruce Schneier can rec any set.
19:43:52 <jaredj> Backwards!
19:44:09 <LoganCapaldo> Some kind checking would occur I would think
19:44:11 <ddarius> xelxebar: Both of our versions should work with different capabilities.
19:45:43 <ddarius> xelxebar: Yours is more like sets whose elements are each arbitrarily deep sets whereas mine is like a set that is arbitrarily deeply nested.
19:47:08 <LoganCapaldo> ddarius: I find your ideas interesting and wish to subscribe to your newsletter
19:47:09 <xelxebar> ah, okay.  i actually implemented essentially what you recommened and it works as expected; though, I was just curious if the type was what I was thinking
19:47:30 <LoganCapaldo> I think I would pay money for a well written summary of this channels conversation on a daily basiss...
19:48:07 <ddarius> There's an unbelievable amount of good information publically avaible but effectively lost in the logs of this channel.
19:49:06 <LoganCapaldo> lambdabot: get on that. Write some summaries
19:49:16 <LoganCapaldo> strong ai++
19:49:25 <ddarius> We could resurrect MegaMonad
19:49:35 <xelxebar> however, isn't that constructor essentially just arbitrarily deep RecSets and not Set Set Set .. Set a?
19:50:40 <ddarius> xelxebar: Well you definitely can't make a type that corresponds to Set (Set (Set ...)) nested to a dynamically determined level any other way.
19:50:45 <LoganCapaldo> xelxebar: I don't think Set Set Set .. Set a is supported by Haskell's type system
19:51:26 <ddarius> You could likely get a type (Set (Set ... )) that's nested an arbitrarily by statically specified amount of times with enough creativity.
19:52:21 <ddarius> Of course, you could just write Set (Set (Set ... )) in that case.
19:52:29 <xelxebar> yeah, but i'm playing around with implementing an abstract idea of numbers, namely 0={}, 1={{}} ...
19:52:48 <xelxebar> so it needs to be arbitrarily deep
19:53:29 <Syzygy-> There are ways to get peano integers as types. This isn't it.
19:53:35 <mauke> data Set = Empty | Full Set
19:53:42 <ddarius> xelxebar: Your type is the one you'd want then except there is no reason to use Data.Set.
19:54:07 <ddarius> (Well, actually, your type is probably the one you'd want in general, your specific cases don't need it.)
19:54:37 <xelxebar> okay, though that specific type isn't, precisely speaking, a true set
19:55:13 <ddarius> If you have 2 = { {}, {{}} } then you do (and this is the "usual" way) if you have 2 = {{{}}} then you don't but you'd still need it later if you wanted {1,2}.
19:57:23 <ddarius> (Well, I guess there is a reason to use Data.Set)
19:58:07 <xelxebar> is there a Set class which RecSet could inherit the methods of?
19:58:50 <xelxebar> then RecSet could be a proper set as well as arbitrarily deep?  By the way, 2={{{}}}, 3={{{{}}}} ...
19:59:54 <ddarius> xelxebar: What makes Data.Set a "proper set"?
20:00:53 <xelxebar> well, the type Set a just has set-like properties, such as those discussed in an intro discreet mathematics course or set theory course
20:01:25 <ddarius> xelxebar: "just has"?  and RecSet doesn't?
20:01:32 <hpaste>  glguy annotated "mostUnlucky" with "fixed leap" at http://hpaste.org/3225#a4
20:04:36 <ddarius> xelxebar: What you want is a set whose elements are (these) sets, i.e. Fix Set essentially.
20:05:37 <ddarius> The hardest thing about that would be writing the Eq and Ord instances (and by hardest I mean potentially impossible)
20:06:19 <mauke> newtype Fix c = Fixed (c (Fix c)) -- does that compile?
20:06:27 <ddarius> mauke: Yes.
20:07:01 <mauke> ... deriving (Eq, Ord)
20:08:03 <ddarius> I know that you can write Eq and Ord instances for such things (in some cases).  I doubt you can derive them.  It's a little finnicky.
20:08:34 <kalmar> hi all
20:08:40 <thoughtpolice> hah. i just had the wiki page on the just over hackathon up on my computer and my dad saw it and told me "you missed the hackathon. you should go; if that's what you do, I want you to be the best hacker you can be." so perhaps going to the next hackathon (whenever that is...) isn't out of the question for me.
20:08:42 <xelxebar> speaking of that, is there a way to see the code for the derived instances are?
20:09:10 <thoughtpolice> :) i imagine they're quite fun. hell, I've never even met another programmer face to face.
20:09:14 <kalmar> any decent links on how to organise a compiler in haskell?
20:09:30 <sorear> @where commentary
20:09:30 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
20:09:35 <SamB_XP> kalmar: what sort of compiler?
20:09:43 <kalmar> I have an idea of the tools available
20:09:48 <Pseudonym> GHC isn't a great example of how to organise a compiler if you're starting from scratch.
20:09:56 <Pseudonym> kalmar: Happy, alex, parsec.
20:10:09 <kalmar> SamB_XP: I'm doing a compilers course so it's for an annoying fake dsl
20:10:12 <SamB_XP> a good start is to write a parser
20:10:18 <kalmar> I am familiar with parsec
20:10:24 <Pseudonym> A better start is to write an abstract syntax tree.
20:10:27 <Pseudonym> Then write a parser.
20:10:35 <SamB_XP> (along with some AST datatypes, of course)
20:10:39 <kalmar> more I'm wondering how to go from there... I see people writing typechecking monads and all sorts of magic
20:10:46 <ddarius> Then profit!
20:10:56 <Pseudonym> kalmar: How complex is the type system?
20:10:56 <ddarius> (Just make sure the source language is C++.)
20:11:07 <kalmar> very uncomplex
20:11:17 <Pseudonym> You jest, but there are companies which just write C++ parsers for a living.
20:11:23 <Philippa_> typechecking monads're pretty common - what exactly they do depends on the type system in question though
20:11:25 <kalmar> some primitives, and a single non-primitive "tuple" which are really more like records
20:11:34 <ddarius> Pseudonym: I'm not jesting at all.  I know that there are.
20:11:58 <ddarius> (Okay, there was some humor involved.)
20:12:06 <kalmar> I am also thinking of using this as a way to experiemnt with nifty stuff I never used before
20:12:10 <kalmar> eg Data.Generics
20:12:39 <kalmar> for doing stuff to the ast
20:12:55 <kalmar> ugh I'm rambling
20:12:56 <Lemmih> thoughtpolice: The next hackathon will probably be in six month at Chalmers/Goteborg.
20:13:40 <kalmar> so question is: are there any toy-ish compilers that come to mind whose source is freely available and decently clear
20:14:39 <halcyon10> scheme in 48 hours perhaps?
20:14:43 <kalmar> halcyon10: done
20:14:47 <kalmar> lots of fun
20:15:16 <kalmar> but it's an interpreter, so I (incorrectly?) assume organisation of a compiler would be somewhat different
20:15:50 <ddarius> kalmar: The backend.  The front and much of the middle could well be the same.
20:15:58 <ddarius> Certainly there is no reason for type checking to be any different.
20:16:28 <sorear> kalmar: I heartily recomment "Let's Build a Compiler" by Jack Crenshaw; the internet has plenty of copies.  (Granted, it uses Pascal, but very little is truly language dependant)
20:16:35 <sorear> It'
20:16:43 <sorear> s good for enlightenment, anyhow.
20:16:54 <ddarius> sorear: My recollection was that it was mostly parsing.
20:17:12 <sorear> oh, could be, been a while
20:17:14 * ddarius hasn't read it in possibly a decade.
20:17:15 <monochrom> Let's Build A Monad
20:17:42 <LoganCapaldo> Our Monad is a very very fine monad
20:17:45 <kalmar> well I'll take a look again at the scheme in 48h and the code I wrote for it
20:18:01 * kalmar wonders if EHC is worth perusing
20:18:54 * wli suspects back-end first would be more enlightening than most of what goes around.
20:19:14 * ddarius mostly agrees with wli
20:19:23 <kalmar> yeah parsing is a very solved problem
20:19:38 <kalmar> an mostly boring
20:19:51 <kalmar> *and
20:20:07 <ddarius> It's not the most boring part.
20:20:19 <sorear> kalmar: How complicated is your language?
20:20:23 <kalmar> what gets worse?
20:20:44 <kalmar> sorear: it's some pseudo c like crap without lots of really handy features
20:20:44 <ddarius> kalmar: Parts of the code generator can be very very tedious.
20:20:49 <kalmar> no arrays
20:20:54 <kalmar> no pointers
20:21:03 <ddarius> kalmar: I could suggest a completely different approach...
20:21:16 <kalmar> but it's a dsl for "web services"
20:21:26 <sorear> web services?!
20:21:42 <kalmar> compiles to some form of cgi
20:21:49 <kalmar> -implementing thing
20:21:56 <sorear> C without pointers or arrays isn't even Turing complete!
20:21:57 <kalmar> the course is fairly crufty
20:21:58 <ddarius> kalmar: Read this paper for a start... http://www.brics.dk/RS/03/Abs/BRICS-RS-03-Abs/BRICS-RS-03-Abs.html#BRICS-RS-03-14
20:22:01 <lambdabot> Title: BRICS Research Series, Abstracts, 2003, http://tinyurl.com/2bora7
20:22:28 <kalmar> sorear: it has something "pointer-like"
20:22:30 <kalmar> well
20:22:35 <kalmar> rather it has something struct-like
20:22:43 <kalmar> which can be used (I am fairly confident) to build cons-cells
20:22:49 <kalmar> which sorts you out
20:23:13 <sorear> but still.. they expect this to be usable for real code?
20:23:20 <kalmar> no it's disgusting
20:23:22 <sorear> why can't they just call it a toy language?
20:23:25 <kalmar> I complain daily
20:23:26 <kalmar> they do
20:23:37 <SamB_XP> get a funner toy
20:23:43 <kalmar> *sigh*
20:23:45 <kalmar> yeah
20:23:47 <SamB_XP> central americans had wheeled toys!
20:24:05 <kalmar> the worst part is having to write code in the toy language as benchmarks
20:24:15 <kalmar> it's so crippled it's beyond humourous
20:24:20 <SamB_XP> they hadn't though to use wheels anywhere else, but at least they used them in toys
20:24:45 * sorear suggests kalmar write a Haskell or SML compiler
20:24:51 <thoughtpolice> Lemmih: cool! that should be around the time I graduate high school I believe, so hopefully I can be there if at all possible. :)
20:25:01 <sorear> Parsing Haskell is actually interesting!
20:25:02 <ddarius> SamB_XP: I would be very unsurprised if many significant modern day things didn't start out in "toys".
20:25:10 <kalmar> sorear: my brain would fry, at least for haskell
20:25:22 <SamB_XP> ddarius: wait a minute
20:25:24 <sorear> SamB_XP: The central americans have wheels on everything now
20:25:29 <SamB_XP> could you take out some of those negations?
20:25:50 * wli suspects most technologies start as weapons.
20:25:54 <Cale> kalmar: heh, if you're bored, implement a raytracer in your toy language, then add optimisations to the compiler until it runs tolerably fast.
20:26:02 <SamB_XP> sorear: I mean back before they ran into the europeans
20:26:25 <halcyon10> i like the bootstrapping aspect when you write a compiler for a new language in the laguage itself
20:26:28 <kalmar> Cale: jesus christ do you have an idea how hard taht would be
20:26:30 <kalmar> !
20:26:33 <SamB_XP> kalmar: and run screaming if the spec is like that for the one in the ICFP 2006 contest
20:26:43 <sorear> Cale: but then you'll be flamed to death by Jon Harrop
20:26:44 <Cale> kalmar: I know people who did it in my baby compilers course :)
20:26:51 <ddarius> SamB_XP: I'd say the Europeans ran into them, but Galilean relativity and all that.
20:26:55 <kalmar> yeah but the langauge there had arrays?
20:27:03 <SamB_XP> ddarius: the thought did occur to me
20:27:13 <SamB_XP> that the europeans did more of the moving
20:27:17 <SamB_XP> after I said that
20:27:21 <Cale> kalmar: It had pointers, at least.
20:27:38 <sorear> the whole planet is moving at 200+ km/s, what's a few more m/s?
20:28:00 <Cale> kalmar: You could use linked lists, no? :)
20:28:03 <SamB_XP> sorear: the planet is our frame of reference
20:28:04 <kalmar> Cale: well I'll very very very quickly consider it
20:28:08 <Cale> heheh
20:28:28 <Cale> Heh, or add first-class functions
20:28:36 <sorear> First optimization: Replace linked lists with arrays.
20:28:46 <kalmar> Cale: could probably code up some sort of balanced tree structure which would at least get non-abysmal access time
20:28:49 <SamB_XP> sorear: how is that an optimization?
20:28:57 <Cale> kalmar: yeah :)
20:29:02 <dmwit> Dunno, one of my Euler project solutions ran slower when converted to arrays.
20:29:11 <dmwit> (Though it probably took a bit less memory; I didn't check.)
20:29:31 <Cale> Lists are very efficient for approximately one access pattern
20:29:52 <dmwit> heh
20:30:09 <Cale> (But it happens to be the most common access pattern)
20:30:39 <kalmar> it's been a while since I wrote any haskell :/
20:31:04 <kalmar> watched slpj's tutorial thingy the last couple of days gave me a bit of an itch
20:31:08 * wli ponders ICFP '06 -like langs for animations.
20:31:18 <kalmar> oh god
20:31:26 <kalmar> wait
20:31:27 <kalmar> '07?
20:31:52 <wli> Sans obfuscation of course.
20:32:08 <kalmar> I implemented a really really shitty drawing part of that in haskell... my friend wrote the DNA->RNA part in lisp.. .they were both farrrr too slow
20:32:15 <kalmar> but his was more offensively slow
20:32:33 <kalmar> well actually I only tested my part on a few commands
20:32:37 <wli> No, '06
20:32:44 <kalmar> ah, which was that
20:32:46 <kalmar> ohhh
20:32:46 <kalmar> UM
20:33:35 <wli> Raytracing scene description lang.
20:34:17 * kalmar did not take part and so is only vaguely aware of the other languages
20:34:33 <Pseudonym> wli: http://accad.osu.edu/~smay/AL/
20:34:34 <lambdabot> Title: AL: the animation language
20:34:44 <Pseudonym> That's pretty closely related to Pixar's internal animation system.
20:35:37 <wli> Sounds good.
20:35:48 <Pseudonym> Well, as it was about ten years ago, anyway.
20:36:00 <wli> License/ Hmm.
20:36:07 <wli> License?
20:36:07 <Pseudonym> Just read the docs.
20:36:14 <Pseudonym> Oh, there's no source.
20:36:22 <Pseudonym> Sadly.
20:36:26 <Pseudonym> Even though it's mostly in Scheme.
20:36:41 <wli> Ugh.
20:36:55 <Pseudonym> But I think you'll find the documentation useful.
20:37:47 <wli> Yeah.
20:38:07 <wli> Mesh editors?
20:38:12 <Pseudonym> And if you can find this paper, it's a good read:
20:38:14 <Pseudonym> William T. Reeves, Eben F. Ostby, Samuel J. Leffler, "The Menv Modelling and Animation Environment," Journal of Visualization and Computer Animation, 1990.
20:38:42 <Pseudonym> wli: Generally speaking, animation shops with their own animation systems use off-the-shelf editors, and export to the custom system.
20:39:12 <Pseudonym> Of course, not all graphics primitives are "meshes", but you know that.
20:40:30 <wli> Which off-the-shelf bits/
20:40:36 <wli> Which off-the-shelf bits?
20:40:54 <Pseudonym> Oh, they use off-the-shelf modellers to create geometric models.
20:41:18 <wli> 3DSMax? Others?
20:41:25 <Pseudonym> Pixar uses Maya.
20:41:47 <Pseudonym> PDI does too, IIRC.
20:41:56 <Pseudonym> Not sure about Blue Sky.
20:42:18 <Pseudonym> Everyone else, as far as I know, don't do the NIH thing.
20:42:18 <wli> Is Maya FOSS?
20:42:23 <Pseudonym> Not even close!
20:42:31 <StaticVector> far from it
20:42:46 <Pseudonym> Something like Blender or K3D wouldn't be a problem for a project, though.
20:42:54 <wli> So no FOSS 3D modellers?
20:42:55 <StaticVector> blender ftw
20:43:00 <StaticVector> blender is
20:43:04 <StaticVector> and it is decent
20:43:08 <wli> Blender, then.
20:43:11 <Pseudonym> Well...
20:43:14 <StaticVector> k3d i've never used
20:43:27 <Pseudonym> I dispute the "decent" part.  Blender works, but the code itself...
20:43:35 <Pseudonym> I wouldn't want to maintain it, let's put it that way.
20:43:43 <Pseudonym> It looks pretty clunky.
20:44:18 <wli> Where's Poser fit in?
20:44:30 <Pseudonym> Poser isn't a modeller.
20:44:40 <Pseudonym> And it's not free.
20:44:51 <wli> I don't understand what it does.
20:45:01 <Pseudonym> It's essentially an artist's mannequin.
20:45:06 <StaticVector> the basic architecture of blender is decent, but its just been torn apart in the past 7 yeras
20:45:28 <Pseudonym> It was designed for posing figures, which you then draw over.
20:45:35 <wli> I don't understand that description well.
20:45:44 <Pseudonym> Do you know what an artist's mannequin is?
20:46:12 <wli> In vague terms only.
20:46:21 <Pseudonym> http://www1.istockphoto.com/file_thumbview_approve/809660/2/istockphoto_809660_artists_mannequin.jpg
20:46:24 <lambdabot> http://tinyurl.com/2u47zk
20:46:34 <Pseudonym> Wooden figure which you put into a pose.
20:46:44 <Pseudonym> It's so that you've got some visual reference when you're drawing or painting.
20:46:47 <dibblego> should mzero and msum in MonadPlus have been split into separate type-classes?
20:46:53 <hpaste>  xelxebar pasted "Mysterious deviant behaviour" at http://hpaste.org/3227
20:47:04 <wli> It manipulates meshes?
20:47:06 <Pseudonym> wli: Let's take this ti haskell-blah
20:47:13 <dmwit> dibblego: What motivates the question?
20:47:18 <Cale> dibblego: They shouldn't have been merged into the same typeclass in the first place.
20:47:36 <dibblego> Cale, do you mean, there should be a type class with mzero and another with msum?
20:47:43 <Cale> mplus, yeah
20:47:48 <dibblego> er yeah that
20:47:51 <sorear> dibblego: no, he means that haskell used to be good
20:48:02 <Cale> dibblego: Note that in Haskell 1.4 they were separate, there was a MonadZero class, and then MonadPlus
20:48:21 <sorear> but, as usual, the Haskell 98 committee broke it
20:48:22 <dibblego> ah right; but MonadZero was slightly different wasn't it?
20:48:26 <Cale> There should also be a MonadOrElse, to capture the different semantics of things like the Maybe monad.
20:48:30 <dibblego> ?type mplus
20:48:32 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
20:48:34 <Cale> No, it was exactly that.
20:48:42 <dibblego> what would MonadOrElse look like?
20:49:03 <dibblego> ?src MonadZero
20:49:03 <lambdabot> Source not found. You type like i drive.
20:49:07 <Cale> orElse :: (MonadOrElse m) => m a -> m a -> m a
20:49:09 <dibblego> ?type msum
20:49:11 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
20:49:14 <Cale> Same type signature, different laws.
20:49:26 <dibblego> ah right, and zero on its own type class as well?
20:49:28 <Cale> And for lists, different behaviour.
20:49:35 <Cale> yes
20:49:44 <dibblego> ok I agree, thanks (just checking it's not just me)
20:49:57 <Cale> http://haskell.org/haskellwiki/MonadPlus_reform_proposal
20:49:58 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
20:50:04 <Cale> That's been around for a while
20:50:36 * dibblego clicks the up arrow
20:50:43 <dibblego> that's exactly how I'd have done it
20:50:58 <Cale> Apart from MonadOr, that's exactly how Haskell 1.4 did it.
20:51:18 <dibblego> why did the H98 committee make such a mistake?
20:51:58 <Cale> I think it was an oversight after removing monad comprehensions
20:52:12 <Cale> Monad comprehensions used MonadZero specifically.
20:52:34 <Cale> also, a lot of the prelude functions which used to use MonadZero were made less general
20:52:47 <Cale> (that is, they now only apply to lists)
20:52:59 <sorear> you mean H98 wasn't actively malicious?
20:53:10 <Cale> And then someone noticed that all the existing instances of MonadZero were also MonadPlus instances
20:53:21 <Cale> and so proposed that they be joined together
20:53:32 <dibblego> ah
20:53:35 <Cale> (which was really stupid, but I don't think it was malicious)
20:53:37 <dibblego> well that's a bummer
20:53:45 <omnId> did Monad ever subclass Functor in some version of Haskell?
20:53:49 <Cale> Yep
20:53:50 <Cale> 1.4
20:53:56 <dibblego> CAL
20:54:04 <omnId> I checked the 1.4 report, it didn't look like it did.
20:54:08 <Cale> er
20:54:09 <Cale> hmm
20:54:12 <sjanssen> in the year 2037, Haskell 1.3 is regarded as the only good version
20:54:16 <Cale> Maybe not then
20:54:32 <Cale> I'm sure I've seen Gofer preludes and such which had it right
20:54:34 <dibblego> is there any proposal to fix Haskell warts?
20:54:51 <dibblego> in a whole new standard
20:54:57 <Cale> Not really.
20:55:24 <Cale> It's a lot of work. We'd have to fork base, and recompile everything against it, and add some stuff to GHC.
20:55:45 <dibblego> at least it's sturdier ground though?
20:56:11 <Cale> I think the general take has been not to standardise things first.
20:56:23 <Cale> Implement, then standardise.
20:56:40 <dibblego> good idea I guess
20:57:02 <Cale> But yeah, I think it would be great if we could do that.
20:58:23 <Cale> Other warts include the associativity of ($), the translation of do-notation (fail), and lack of generality of prelude functions. (map)
20:58:48 <omnId> Where do you find the old reports?  A google for "haskell 1.3 report" took some scanning.
20:58:55 <ddarius> omnId: haskell.org
20:58:56 <Cale> Go to the main Haskell page
20:59:03 <wli> map needs to go back under Functor
20:59:15 <Cale> Click on "language definition"
20:59:21 <Cale> Scroll down :)
20:59:28 <Cale> wli: I agree.
21:00:04 <Cale> I'd also be willing to consider making (.) notationally equivalent to map as well.
21:00:23 <omnId> Hmm.  Postscript files.  /me is spoiled on HTML.
21:00:41 <ddarius> HTML is spoiling?
21:00:45 <Cale> That is, giving it the type  (.) :: (Functor f) => (a -> b) -> f a -> f b, which is a generalisation of its usual type.
21:00:55 <Cale> Postscript is nice :)
21:01:21 <Cale> I'd take postscript over HTML any day, especially when it was generated by LaTeX :)
21:01:33 <jcreigh> Postscript is nice for laying out text on pieces of paper. Postscript is not nice for reading on screens. (IMO)
21:02:10 <Cale> You get to read things in the pretty CMR font :)
21:02:33 <jcreigh> I think map should but general, but I don't know if I could get used to using (.) as map...
21:02:36 <omnId> Cale: I think, though, that in that case the usual "but newbs will get confused by typeclass errors when they just want to compose functions" has some merit.  (.) = fmap doesn't seem to me to be a big enough gain.
21:02:57 <Cale> Perhaps, yeah.
21:03:18 <wli> There needs to be a "to heck with newbies and typeclass errors" language variant.
21:03:19 <jcreigh> OTOH, it would provide a very cool "OMG! Everything is the same underneath!" moment.
21:03:33 <Cale> However, map :: (Functor f) => (a -> b) -> (f a -> f b)
21:03:35 <chessguy> is postscript capable of describing purely semantic data, without presentational information?
21:03:46 <bos> yes
21:03:47 <geocalc> always white background pdf postscript (kill eyes)
21:03:56 <jcreigh> bos: really? how?
21:04:00 <omnId> jcreigh: I've had quite a few of those short of realizing ((->) r) fmap = (.) :)
21:04:22 <ddarius> jcreigh: postscript is a Turing complete programming language.
21:04:34 <bos> jcreigh: entire window systems have been written in postscript
21:04:47 <Cale> Also, the ((->) e) Functor/Monad instance *definitely* should be in the Prelude.
21:04:48 <sorear> chessguy: it doesn't need to, there are Other Systems for that
21:05:04 <Cale> And a nice clean instance for Either e
21:05:11 <sorear> chessguy: postscript is merely an excellent format for pre-typeset pages
21:05:17 * ddarius heartily agrees about the Either e thing.
21:05:22 <jcreigh> bos: sure, but where does "purely sematic data" come into it? Isn't it always presentational data? (ie, "12 pt black Times New Roman 1/4 of an inch from the origin...")
21:05:23 <ddarius> Stupid fail.
21:05:25 <Cale> Maybe put fail into MonadZero
21:05:43 <chessguy> sorear, i'm well aware of that. my question was in response to the statement of preference of postscript over HTML.
21:05:45 <omnId> with fail _ = zero as default?
21:05:51 <Cale> With a default implementation as that, yes
21:06:05 <Cale> (++) :: (Monad m) => m a -> m a -> m a!
21:06:27 <bos> jcreigh: it can represent numbers and text and arrays and the like, independent of anything to do with displaying numbers.
21:07:31 <Cale> I don't think this stuff will ever get done unless some group of us decides to just go ahead and do it.
21:08:28 <jcreigh> is there a way to do "alternate preludes" in a way that can be used in real programs? (ie, just import SuperCoolNewPrelude and then map = fmap?)
21:08:35 <Cale> Proposing this stuff on the mailing list just turns into a quagmire of arguments and additional crazy proposals.
21:08:38 <omnId> 1.3 Monad doesn't seem to inherit Functor either: http://www.ki.informatik.uni-frankfurt.de/doc/html/Haskell1.3/basic.html#6.2.5
21:08:39 * byorgey would help =)
21:08:40 <sorear> yeah, it won't happen now that we have The Compatibility Enforcement Gang
21:08:41 <lambdabot> Title: The Haskell 1.3 Report: Basic Types and Classes, http://tinyurl.com/278n36
21:08:44 * sorear glares at dons
21:08:49 <chessguy> bos, i suspect it would be far less natural than standard markup though
21:08:55 <omnId> HTML is easily linkable :)
21:09:08 * wli tried and failed to decipher the list comprehension desugaring for some time.
21:09:14 <Cale> jcreigh: You can do that, but then things don't work so well with everything compiled against the usual prelude.
21:09:30 <Cale> jcreigh: Also, we want to change some of the meaning of syntax.
21:09:54 <chessguy> i thought there already was another prelude
21:09:55 <jcreigh> Cale: the syntax stuff is related to do-notation, I assume?
21:09:59 <Cale> wli: You'll be happy to note that I added that very desugaring to Wikipedia today :)
21:10:01 <chessguy> are you suggesting another other prelude?
21:10:02 <sorear> Cale: so what do we do?  change the behavior of GHC 6.10 and declare a flag day?
21:10:04 <Cale> jcreigh: yeah
21:10:15 <Cale> sorear: I think so, yeah :)
21:10:20 <Cale> sorear: base2
21:11:02 <Cale> Or nuperfectbase or some such ;)
21:11:16 <wli> Cale: You fixed the desugaring?
21:11:19 <byorgey> mm, better call it numoreperfecterbase or something like that
21:11:44 <Cale> wli: No, I copied (a variant of) the H98 desugaring into the Wikipedia article on list comprehensions
21:12:07 <omnId> doubleplusgoodbase
21:12:24 <Cale> http://en.wikipedia.org/wiki/List_comprehensions
21:12:44 <chessguy> allyourbase
21:12:50 <Cale> Ahaha!
21:12:55 <chessguy> sorry, i couldn't resist
21:13:16 <Cale> Just enough time has elapsed for that to be funny again :)
21:13:43 <omnId> The trouble is that "hey, there's a movement to fix the flaws! Might as well get *all* of them!"
21:14:06 <chessguy> what, haskell has flaws?
21:14:15 <omnId> I said nothing.
21:14:27 * omnId whistles
21:14:42 <chessguy> nice try. your statement has been recorded for all of posterity
21:15:06 <Cale> omnId: That won't happen until the class aliases proposal becomes more than a proposal.
21:15:26 <chessguy> not to mention first-class records
21:15:35 <Cale> Well, sure :)
21:15:50 <omnId> I'd like the functional references thing.
21:16:05 <Cale> Making the class hierarchies perfect also makes them really annoying.
21:16:10 <omnId> @google functional references
21:16:11 <lambdabot> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
21:16:12 <lambdabot> Title: Overloading functional references - 21 thoughts
21:16:36 <chessguy> yes, functional references seem nice. has that been fleshed out into a full proposal for first class records?
21:16:38 <omnId> Cale: and what if someone discovers a new useful class between Applicative and Monad?
21:16:46 <Cale> omnId: Right.
21:17:25 <omnId> should Monad inherit Applicative or should that be a fancy library and Monad inherit Functor directly?
21:17:46 <Cale> I'd really like to see something semantically equivalent (but not syntactically) to Daan's proposal get in.
21:18:37 <Cale> omnId: I say the latter, simply because there aren't yet enough Applicative libraries.
21:18:44 <chessguy> you realize, of course, that you're moving a language whose primary criticism is that it's too theoretical in a more theoretical direction
21:18:53 <Cale> chessguy: Of course :)
21:19:05 <Cale> Avoid success at all costs!
21:19:07 <omnId> Cale: but Monads strictly subclass Applicative Functors!
21:19:10 <dibblego> what is the name of the isomorphism between the curried and uncurried form?
21:19:19 <Cale> omnId: Yeah, we'll change it later :)
21:19:20 <omnId> (...etc.)
21:19:21 <ddarius> curry/uncurry
21:19:33 <Cale> hehe
21:19:38 <chessguy> mmmm, you has curry
21:19:57 <Cale> Let's have a look at what the hierarchy would look like with class aliases?
21:20:07 <omnId> why u not curry yore funkshuns?
21:20:26 <chessguy> i saw ur monad! (tee hee)
21:20:43 <Cale> Did everyone see http://cale.yi.org/autoshare/coequaliser.jpg ?
21:21:01 <Pseudonym> :-)
21:21:11 <cizra> \o/ Lambdacats!
21:21:13 <cizra> er.. hi
21:21:17 <Pseudonym> http://andrew.bromage.org/imposibel.jpeg
21:21:33 <Cale> haha
21:21:38 <ddarius> Holy shite!
21:21:47 <Cale> cizra: Did you catch my image there? It looked like you joined after
21:21:49 <omnId> bahahaha
21:21:52 * ddarius personally foresaw something, but didn't think it was actually going to happen.
21:22:01 <Pseudonym> Oh, and also: http://andrew.bromage.org/explodid.jpeg
21:22:03 <Cale> ddarius: What would that be?
21:22:38 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/wrong/you're-doing-it-wrong-22.jpg
21:22:41 <lambdabot> http://tinyurl.com/yvqfy7
21:23:11 <ddarius> In response to chessguy saying "your statement has been recorded for all of posterity" I was considering saying "Soon to be washed away under a wave of links to cat pictures."
21:23:29 <omnId> =D
21:23:37 <Pseudonym> And one more: http://andrew.bromage.org/offseid.jpeg
21:24:37 <cizra> Cale: How should I know
21:24:52 <cizra> Anyway, I'm going to school. Bye.
21:25:10 <chessguy> @go coequaliser
21:25:13 <lambdabot> http://arxiv.org/pdf/math.AT/0410398.pdf
21:25:20 <ddarius> Hmm.
21:25:31 <omnId> chessguy: is bran nu
21:25:37 <Cale> cizra: http://cale.yi.org/autoshare/coequaliser.jpg
21:25:49 <chessguy> wow
21:26:13 <chessguy> Oct 2004, according to that paper
21:26:17 <omnId> @foldoc coequaliser
21:26:18 <lambdabot> No match for "coequaliser".
21:26:33 <Pseudonym> ?go coequalizer
21:26:35 <lambdabot> http://en.wikipedia.org/wiki/Coequalizer
21:26:40 <chessguy> i don't know why i forgot that a coequalizer is just a homotopy double groupoid of a Hausdorff space II
21:26:42 <Cale> http://en.wikipedia.org/wiki/Coequaliser
21:26:55 <chessguy> silly me
21:27:18 <Cale> It's just the limit of a parallel pair of arrows.
21:27:20 <omnId> chessguy: I know! It's just so easy to forget the details.
21:27:25 <Cale> er, colimit :)
21:27:38 * chessguy tries to pick up the splinters of his brain
21:28:00 <Syzygy-> Ooooh. Coequalizers!
21:28:10 <sorear> I have no idea what coequalizers are.
21:28:10 <Syzygy-> Almost like equalizers, only the other way around!
21:28:14 <Cale> The diagram on the wikipedia page should help you to understand the joke, if not the mathematics.
21:28:26 <sorear> Before a minute ago, I thought they were a kind of lolcat.
21:28:30 <Syzygy-> sorear: They are either a generalization of Kernel or of Cokernel.
21:29:05 <omnId> Haskellers are wierd
21:29:11 <omnId> weird, too
21:29:30 <Cale> Coequalisers in Set are quotients of the equivalence classes of Y generated by the equations {f(x) = g(x) : x in X}
21:29:54 <Cale> Well, I should say f(x) ~ g(x)
21:30:24 <Pseudonym> Yeah, you can think of an equalizer of f and g to be the "solution" to the equation f(x) = g(x).
21:30:34 <Cale> yeah
21:30:38 <Pseudonym> (Well, _the_ equalizer; up to isomorphism.)
21:31:01 <Cale> and the coequaliser as modding out of Y by the smallest equivalence relation which would force that to be true
21:31:06 <Pseudonym> Right.
21:31:13 <Pseudonym> I was about to write that more verbosely and less clearly.
21:31:51 <ddarius> You use coequalizers to glue something to itself and to collapse parts of it.
21:32:05 <Pseudonym> That sounds kinky.
21:33:08 <chessguy> on that note...
21:34:03 <ddarius> There are two graph homomorphisms from the graph with two vertices and an arrow joining them to the graph with one vertex. The coequalizer of them is the first graph with it's ends glued together into a loop.
21:34:03 <omnId> You see what you guys did?  You should be ashamed of yourselves.
21:34:59 <Cale> omnId: Don't worry, I don't think he'll be gone too long
21:35:16 <ddarius> There's an excellent exercise in Toposes, Triples and Theories that asks for the identical thing only using categories and functors instead.
21:35:21 <ddarius> The answer is interesting.
21:36:28 <ddarius> And my arrows were backwards.
21:37:03 <ddarius> I meant two homomorphisms from the one vertex graph to the graph with two vertices and an arrow joining them.
21:37:38 <bos> i wonder how people write haskell code effectively if they don't have a ghc source tree and recursive grep.
21:37:55 <Heffalump> why do you need that?
21:38:08 <Pseudonym> I think you write more effective Haskell code by NOT looking at the GHC souce.
21:38:17 <Pseudonym> All due respect to any GHC developers present.
21:38:21 <bos> now now.
21:38:31 <Pseudonym> But a lot of the code in there is from an earlier era.
21:38:35 <jcreigh> bos: oh, wait, you're right, grep *does* have a -R option. I have been doing find | xargs grep forever...
21:38:37 <wli> ghc isn't exactly the most modern Haskell
21:38:41 <Pseudonym> Right.
21:38:59 <Pseudonym> All hail the Evil Mangler.
21:39:02 <wli> Not very monad transformer -ized like things are now.
21:39:27 <bos> actually, i wasn't thinking about the ghc source itself, but the RTS source and the libraries.
21:39:35 <Pseudonym> We've got haddock for that.
21:39:44 <Pseudonym> And yeah, I do keep a copy of the Haddock docs handy.
21:39:51 <bos> meh, haddock leaves me going clicky clicky a lot.
21:40:11 <sorear> @remember Pseudonym All hail the Evil Mangler!
21:40:11 <lambdabot> Done.
21:40:38 <bos> it's pretty funny that will partain's fingerprints are still so much in there.
21:42:00 <bos> will was a big perl fan. and imake. ghc's build is a thing of beauty now, compared to what it once was.
21:42:07 <Cale> ddarius: oh, nice :)
21:43:21 <omnId> @quote mangler
21:43:21 <lambdabot> Pseudonym says: All hail the Evil Mangler!
21:43:25 <omnId> @quote mangler
21:43:25 <lambdabot> Pseudonym says: All hail the Evil Mangler!
21:43:30 <Cale> I won't give it away, but that is a bit surprising :)
21:44:17 <ddarius> Cale: The "title" of the exercise was "Coequalizers can be large".
21:44:32 <Cale> right :)
21:45:47 <Cale> That example should definitely be added to the Wikipedia page.
21:45:50 <Pseudonym> http://andrew.bromage.org/haddock.jpeg
21:46:26 <Pseudonym> Sorry.
21:46:46 <omnId> @punch Pseudonym
21:46:46 <lambdabot> Unknown command, try @list
21:46:49 <ddarius> Pseudonym: At least there is a fish in that picture, otherwise I would have been highly upset.
21:46:52 <Pseudonym> Yeah.
21:47:04 <Pseudonym> Even though it looks nothing like a haddock.
21:48:29 <dmwit> ?slap Pseudonym
21:48:29 * lambdabot beats up Pseudonym
21:51:14 * Cale adds the nice example to Wikipedia :)
21:55:24 <Cale> That's a beautiful way to formalise the philosophical view that natural numbers originate from the splitting up of time into "before" and "after"
21:58:26 <mutjida> :users
21:58:37 <mutjida> #users
21:59:07 <lambdabot> Keep trying punctuation characters, you'll get it eventually.
21:59:15 <Cale> @users
21:59:15 <lambdabot> Maximum users seen in #haskell: 420, currently: 356 (84.8%), active: 13 (3.7%)
21:59:15 <omnId> @users?
21:59:16 <lambdabot> Maximum users seen in #haskell: 420, currently: 356 (84.8%), active: 13 (3.7%)
21:59:23 <ddarius> ?users
21:59:23 <lambdabot> Maximum users seen in #haskell: 420, currently: 356 (84.8%), active: 13 (3.7%)
21:59:30 <Cale> ?users@
21:59:31 <lambdabot> Maximum users seen in #haskell: 420, currently: 356 (84.8%), active: 13 (3.7%)
21:59:41 <omnId> ?sresu@
21:59:42 <lambdabot> Unknown command, try @list
21:59:50 <mutjida> is there a page somewhere with the syntax for this irc?
21:59:57 <Cale> ?sures
21:59:57 <lambdabot> Unknown command, try @list
22:00:00 <Cale> ?suers
22:00:00 <lambdabot> Maximum users seen in #haskell: 420, currently: 356 (84.8%), active: 13 (3.7%)
22:00:10 <Cale> ?listcommands
22:00:10 <lambdabot> Unknown command, try @list
22:00:14 <Cale> ?list
22:00:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:00:14 <omnId> @go lambdabot
22:00:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:00:16 <lambdabot> Title: lambdabot
22:00:36 <Pseudonym> ?lusers
22:00:36 <lambdabot> Maximum users seen in #haskell: 420, currently: 356 (84.8%), active: 13 (3.7%)
22:00:57 <Cale> ?losers
22:00:57 <lambdabot> Maximum users seen in #haskell: 420, currently: 356 (84.8%), active: 13 (3.7%)
22:00:59 <Cale> heh
22:01:09 <omnId> @winners
22:01:09 <lambdabot> Unknown command, try @list
22:01:16 <Cale> The spelling correction is not quite that good :)
22:01:38 <Pseudonym> ?brusers
22:01:38 <lambdabot> Maximum users seen in #haskell: 420, currently: 355 (84.5%), active: 13 (3.7%)
22:01:41 <byorgey_> jcreigh: sorry, my laptop died
22:01:54 <Cale> ?bruisers
22:01:54 <lambdabot> Unknown command, try @list
22:02:06 <Pseudonym> ?ruses
22:02:06 <lambdabot> Maximum users seen in #haskell: 420, currently: 355 (84.5%), active: 14 (3.9%)
22:02:17 <omnId> ?yoozers
22:02:17 <lambdabot> Unknown command, try @list
22:02:38 <Pseudonym> ?sars
22:02:38 <lambdabot> Maybe you meant: arr part src users yarr
22:02:54 <Pseudonym> ?husars
22:02:55 <lambdabot> Maximum users seen in #haskell: 420, currently: 357 (85.0%), active: 14 (3.9%)
22:03:03 <omnId> @quasars
22:03:03 <lambdabot> Unknown command, try @list
22:03:13 <Pseudonym> ?lasers
22:03:14 <lambdabot> Maximum users seen in #haskell: 420, currently: 357 (85.0%), active: 14 (3.9%)
22:03:23 <omnId> Pseudonym wins
22:03:36 <Pseudonym> ?tasers
22:03:36 <lambdabot> Maximum users seen in #haskell: 420, currently: 357 (85.0%), active: 14 (3.9%)
22:03:45 <mutjida> has anyone here installed the latest version of hdbc and hdbc-odbc?
22:03:48 <omnId> @?phasors
22:03:55 <omnId> oops :)
22:03:58 <bos> @seen dons
22:03:58 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 18m 21s ago.
22:04:03 <Pseudonym> ?phases
22:04:03 <lambdabot> Unknown command, try @list
22:04:35 <sorear> ?part #haskell
22:05:42 <Cale> errr...
22:05:43 <Cale> heh
22:07:18 <byorgey_> jcreigh: can you see what I'm msging to you?
22:07:56 <jcreigh> byorgey_: no. You probably can't /msg without being identified to services.
22:08:11 <mutjida> in anycase, i'm getting strange interface file errors with the latest hdbc-odbc
22:08:21 <byorgey_> jcreigh: yeah.  I forget my password, though, and it's on my laptop which is dead =P
22:08:24 <geocalc> Setup.hs: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly i have this error both witj darcs and cabal package what do i do ?
22:08:28 <jcreigh> byorgey_: can you see mine, though?
22:08:32 <byorgey_> yes
22:09:04 <geocalc> s/tj/th
22:09:04 <byorgey_> Pseudonym: oh, that means you couldn't see mine either!
22:09:11 <Pseudonym> Right.
22:09:16 <byorgey_> Pseudonym: the lambdacats site isn't mine, I just contributed a couple
22:09:34 <byorgey_> Pseudonym: search in -cafe to find who it is, I don't remember his email off the top of my head.
22:09:41 <Pseudonym> Ah, OK.
22:09:46 <Pseudonym> Anway, I sent mail.
22:09:50 * Pseudonym thought it was you
22:12:01 * geocalc again =<< help
22:16:58 <geocalc> bos can you give me a fix ?
22:17:07 <bos> ?
22:17:23 <Pseudonym> Hey, take it to #haskell-drugs.
22:17:36 <geocalc> Setup.hs: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly i have this error both with darcs and cabal package what do i do ?
22:17:41 <bos> geocalc: what are you trying to build?
22:17:59 <geocalc> c2hs
22:18:06 <bos> is this something you're writing? oh, huh.
22:18:58 <nick_> who wrote this: http://freeshells.ch/~revence/par.txt
22:19:08 <mudge> i'm mudge actually
22:19:14 <sjanssen> LeCamarade
22:19:22 <sjanssen> @seen LeCamarade
22:19:22 <lambdabot> I saw LeCamarade leaving #haskell 1d 21h 37m 9s ago, and .
22:19:39 <mudge> ah thanks,  don't think I've met him on IRC
22:19:42 <bos> geocalc: i've never used c2hs, sorry
22:20:16 <geocalc> ugh
22:24:05 <geocalc> is someone can paste the list of exposed modules of c2hs and say me where i put it ?
22:25:35 <geocalc> ?user
22:25:35 <lambdabot> Maximum users seen in #haskell: 420, currently: 350 (83.3%), active: 12 (3.4%)
22:26:33 <geocalc> flux
22:27:02 <geocalc> flux ?
22:28:42 <flux> geocalc, ?
22:28:56 <geocalc> is someone can paste the list of exposed modules of c2hs and say me where i put it ?
22:29:26 <geocalc> flux ?
22:30:19 <sjanssen> geocalc: you're trying to build c2hs, but it you're getting an error message?
22:30:40 <geocalc> Setup.hs: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly i have this error both with darcs and cabal package what do i do ?
22:31:31 <geocalc> the build abort
22:32:28 <sjanssen> geocalc: is this the 0.15.0 version from hackage?
22:32:42 <geocalc> yes
22:33:10 <sjanssen> hmm
22:33:15 <sjanssen> it builds okay here
22:33:24 <sjanssen> geocalc: what version of Cabal do you have?
22:33:59 <geocalc> cabal head
22:35:38 <sjanssen> I'm using 1.1.6.2
22:35:47 <sjanssen> any specific reason you're using head?
22:36:27 <geocalc> no i also have 1.1.6.9
22:37:39 <geocalc> err 1.1.6.2
22:37:56 <sjanssen> try 'ghc-pkg hide' the head version, and 'ghc-pkg expose' 1.1.6.2
22:38:04 <sjanssen> then try building c2hs
22:39:18 <geocalc> how i know head version ? sorry sjanssen
22:39:30 <sjanssen> ghc-pkg list
22:39:59 <geocalc> thanks sjanssen
22:46:29 <geocalc> Setup.hs: Warning: Unknown field 'build-tools' i had this you too sjanssen ?
22:46:30 <Mr_Awesome> is there any simple way to modify a field of a record?
22:46:52 <sjanssen> geocalc: yep, I think you can ignore it
22:47:05 <bos> Mr_Awesome: myValue {fieldName = newFieldValue}
22:47:45 <Pseudonym> http://andrew.bromage.org/simon.jpeg
22:47:56 <Mr_Awesome> bos: really. i cant believe i didnt know about that. thanks
22:48:26 <bos> Mr_Awesome: haskell is big. takes a while to learn all the nooks and crannies. i don't think anyone *does* know them all.
22:49:10 <Pseudonym> I bet simon cat does.
22:49:49 <Pseudonym> OK, maybe not.
22:49:56 <Pseudonym> Even Oleg doesn't know them all.
22:50:13 <bos> haskell is like pokemon in that way.
22:50:23 <Cale> Is it even theoretically possible to know them all?
22:50:33 <omnId> they can both be addictive
22:50:57 <roconnor> Haskell 98 isn't that big
22:51:05 <Cale> I suspect the answer depends on what you call a nook or cranny.
22:51:05 <Mr_Awesome> if you have a data type with multiple record constructors, some having the same records, is there a way to match a value of that type binding variables to the common records?
22:51:31 <bos> Cale: precisely :)
22:51:53 <Mr_Awesome> like Constructor { f = x, g = y }, but have it work for any Constructor?
22:51:54 <bos> Mr_Awesome: no, you can't even create such a type
22:52:08 <Cale> Mr_Awesome: well, you can call the field extractors as functions
22:52:21 <Cale> bos: huh?
22:52:26 <Mr_Awesome> Cale: right, and thats not too difficult. just wondering if this sort of thing existed
22:52:49 <Cale> Mr_Awesome: Nope, you can't match against multiple constructors at the same time, unless you want to match all of them
22:52:58 <Mr_Awesome> bos: i mean like data D = A { f :: T } | B { f :: T }
22:52:59 <bos> Cale: you can't have two constructors with the same field names
22:53:07 <Cale> bos: Yes you can.
22:53:09 <bos> Mr_Awesome: precisely. can't do that.
22:53:13 <Mr_Awesome> ...
22:53:15 <Cale> bos: Try it.
22:53:34 <omnId> not the same exact *set*, but sharing some names iirc
22:53:35 <Mr_Awesome> it creates a polymorphic function f
22:53:43 <Cale> not even polymorphic
22:53:51 <omnId> f :: D -> T, no polymorphism
22:54:17 <Mr_Awesome> well, D comes in different forms, so i consider that polymorphic in a way, even though thats not the right term exactly
22:54:27 <omnId> like just defining   f (A x) = x; f (B x) = x   it's fine.
22:54:45 <bos> Cale: huh, i didnae realise
22:55:00 <Mr_Awesome> bos: looks like we both learned something today :)
22:55:32 <Cale> Of course, fields having the same name also must have the same type.
22:55:34 <bos> Mr_Awesome: it's not wise to have your own private definitions of words like "polymorphic"
22:55:45 <Pseudonym> http://andrew.bromage.org/oleg.jpeg
22:55:48 * Pseudonym should REALLY stop
22:56:00 <Cale> ahahaha
22:56:10 <Cale> You should send that one to the mailing list :)
22:56:20 <Cale> In reply to an oleg post :)
22:56:31 <Pseudonym> I shall lie in wait.
22:59:10 <ac> Pseudonym: I assume you saw the concatMap cat?
22:59:14 <Pseudonym> Yeah.
22:59:19 <Pseudonym> I liked that one.
22:59:23 <ac> that's my favorite
22:59:36 <Pseudonym> I liked the catamorphism one.
22:59:48 <Cale> where's that one?
22:59:59 <Cale> (the catamorphism one)
23:00:19 <Pseudonym> http://arcanux.org/lambdacats/catamorphism.png
23:00:40 <Cale> hahaha
23:01:04 <quicksilver> Pseudonym++
23:01:22 <Pseudonym> Obviously byorgey did that one.
23:02:17 <quicksilver> the ++ was for oleg cat though :)
23:02:21 <quicksilver> I only just read up
23:02:24 <Pseudonym> Ah, right. :-)
23:02:28 <Pseudonym> Did you see the simon cat one?
23:03:15 <quicksilver> no, but I have now :)
23:03:52 <quicksilver> there something about in-jokes in that they become even more alluring the smaller the set of people who could possibly understand them is
23:04:07 <quicksilver> incidentally, (and much less 'in'), yesterdays xkcd was pretty damn good
23:04:21 <blackdog_> so in the limit, a joke that nobody understands is the funniest thing possible?
23:04:26 <quicksilver> http://xkcd.com/
23:04:27 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
23:04:37 <quicksilver> blackdog_: joke that 'only you' understand, I think, is the correct limit
23:05:03 <blackdog_> i don't see why... c'mon, man, think outside the box
23:05:11 <blackdog_> it could be like that monty python ww2 joke
23:05:20 <blackdog_> that no-one could hear without dying of fits of laughter
23:05:23 <vBergmann> my thoughts exactly
23:06:39 <bos> http://www.serpentine.com/avoid.jpg
23:06:51 <quicksilver> I think you may be extending my flippant comment more deeply than I intended, but I wasn't saying this was the *only* criteria for funniness
23:07:02 <quicksilver> just that it applies to "in-jokes"
23:07:31 <sjanssen> Pseudonym++ Oleg cat is great
23:07:33 <blackdog_> *grin* humour can also be derived from taking flippancy literally....
23:08:41 <Pseudonym> LOL!
23:09:13 * omnId dies at xkcd
23:12:19 <takamura> hello
23:20:08 <Cale> hello
23:20:11 <Pseudonym> Try as I might, I can't think of a lambdacat joke involving the word "moggi".
23:20:16 <Pseudonym> It HAS to be possible.
23:22:22 <Syzygy-> lambdacat??
23:22:28 <Pseudonym> ?go lambdacats
23:22:30 <lambdabot> http://arcanux.org/lambdacats_2.html
23:22:30 <lambdabot> Title: Lambdacats
23:22:40 <omnId> "_2"?
23:22:53 <omnId> oh, page 2
23:27:16 <Cale> http://cale.yi.org/autoshare/hasmonad.jpg
23:28:55 <geocalc> is greencard needed to build ghc ?
23:28:58 <Pseudonym> i wearz teh hair shurt!
23:29:40 <bos> geocalc: no
23:29:55 <geocalc> ok
23:30:28 <bos> greencard is obsolete
23:31:11 <quicksilver> Pseudonym: "I iz 'moggi'. Mebbe u red mi 'noshuns of komputayshun'?"
23:32:20 <Pseudonym> Maybe.  But there's a pun there between Moggi and "moggie".
23:34:19 <geocalc> is ghc auto optimising or do i put some flags (where ?)
23:34:29 <Cale> -O2
23:34:37 <Cale> on the commandline
23:35:22 <geocalc> CFLAGS ?
23:35:44 <Cale> Huh?
23:35:52 <Cale> It's just a commandline option to GHC.
23:36:20 <takamura> geocalc, http://www.haskell.org/ghc/docs/latest/html/users_guide/sooner-faster-quicker.html
23:36:21 <lambdabot> Title: Chapter 6. Advice on: sooner, faster, smaller, thriftier, http://tinyurl.com/2hz2fc
23:36:33 <geocalc> to build ghc ?
23:36:53 <takamura> to compile programs using ghc
23:37:29 <geocalc> i'm gone build ghc ;)
23:37:33 <quicksilver> Pseudonym: yes, maybe it's funnier without the quotation marks
23:37:34 <takamura> ah
23:37:54 <sclv> @src tails
23:37:54 <lambdabot> tails []         = [[]]
23:37:55 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
23:38:15 <Cale> geocalc: A particular reason why you'd be doing that?
23:38:33 <geocalc> to try
23:38:46 <Cale> okay, it takes a long time
23:38:50 <quicksilver> geocalc: ghc's build process knows which build flags to apply to make sure it builds an optimal build... you don't need to worry about optimization
23:39:07 <geocalc> ;)
23:39:13 <takamura> http://hackage.haskell.org/trac/ghc/wiki/Building
23:39:18 <lambdabot> Title: Building - GHC - Trac
23:39:35 <sclv> @t fromList
23:39:36 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
23:39:42 <sclv> :ty fromList
23:40:08 <omnId>  @ty or :t
23:40:17 <sclv> @ty fromList
23:40:19 <lambdabot> Not in scope: `fromList'
23:40:23 <omnId> though there are a few fromLists
23:40:26 <omnId> @index fromList
23:40:26 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.Map, Data.Set
23:40:39 <omnId> @type Data.Map.fromList
23:40:41 <lambdabot> forall k a. (Ord k) => [(k, a)] -> Data.Map.Map k a
23:44:51 <dataangel> How do I debug haskell code? Since I can't insert print statements everywhere... :P
23:45:10 <Pseudonym> This should be an FAQ.
23:45:20 <omnId> if you *need* print debugging, you can use Debug.Trace.trace
23:45:26 <Pseudonym> But you might not.
23:45:36 <Pseudonym> Use small functions and QuickCheck them is the first thing to do.
23:45:39 <omnId> though that uses unsafePerformIO, so remove it when everything's fixed.
23:47:40 <omnId> @wiki Debugging
23:47:40 <lambdabot> http://www.haskell.org/haskellwiki/Debugging
23:48:24 <hpaste>  sclv annotated "A pass at a difflike utility" with "Memotables make things much better" at http://hpaste.org/3208#a2
23:48:56 <dataangel> hrm
23:49:40 <sclv> still not quite there -- i could use some advice on where to go next for efficiency
23:49:46 <Pseudonym> sclv: http://andrew.bromage.org/darcs/diff/
23:49:46 <lambdabot> Title: Index of /darcs/diff
23:49:47 <Pseudonym> FWIW
23:49:52 <quicksilver> use small functions and quickcheck them is excellent
23:50:03 <quicksilver> but use small functions and play with them in ghci/hugs is simpler
23:50:09 <quicksilver> adn normally my first stop
23:50:26 <Pseudonym> sclv: Really, though, if you're having efficiency issues, chances are it's the O(N^2) algorithm.
23:51:18 <dataangel> myfun a b | trace ("myfun " ++ show a ++ " " ++ show b) False = undefined -- Can someone explain how this works? what is False doing there, and why would this ever get executed?
23:51:32 <dataangel> it looks like some guard that doesn't happen
23:52:19 <sclv> the algorithm has to be roughly that though, i think? i don't think it'll get scads better, but i suspect that some "cutpoints", so to speak, can be inserted?
23:52:55 <omnId> dataangel: guards are tried in turn, that one will be tried, print the thing, fail, and go to the next
23:53:09 <opqdonut> ah
23:53:22 <Cale> data: trace isn't pure :)
23:53:54 <omnId> "a lovely desert"?
23:54:07 <omnId> refreshing, rather
23:54:11 * dataangel forgot about side effects @_@
23:54:27 <Cale> Heh, a refreshing desert in the oasis of referential transparency :)
23:54:41 <dataangel> rofl
23:55:09 <omnId> dataangel: you've been doing Haskell how long and you forgot side-effects?
23:55:15 <omnId> This is a good thing.
23:55:18 <dataangel> lol
23:55:43 <sclv> @src Debug.Trace.trace
23:55:43 <lambdabot> Source not found. stty: unknown mode: doofus
23:56:39 <omnId> {- I'd guess -} trace msg x = unsafePerformIO (print msg) `seq` x
23:56:47 <omnId> putStr, rather
23:56:59 <roconnor> @quote Cale a refreshing desert in the oasis of referential transparency
23:56:59 <lambdabot> No quotes match. Take a stress pill and think things over.
23:57:06 <Pseudonym> sclv: There are some pretty efficient diff algorithms./
23:57:07 <roconnor> @remember Cale a refreshing desert in the oasis of referential transparency
23:57:07 <lambdabot> Done.
23:57:13 <Cale> roconnor: that's not actually my quote
23:57:15 <omnId> @quote oasis
23:57:15 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
23:57:36 <Pseudonym> sclv: http://citeseer.ist.psu.edu/myers86ond.html
23:57:37 <lambdabot> Title: An O(ND) Difference Algorithm and Its Variations - Myers (ResearchIndex)
23:57:42 <roconnor> oh
23:57:47 <omnId> @help forget
23:57:48 <lambdabot> forget nick quote.  Delete a quote
23:57:53 <roconnor> @forget Cale a refreshing desert in the oasis of referential transparency
23:57:54 <lambdabot> Done.
23:58:15 <omnId> @remember omnId testing
23:58:15 <lambdabot> Done.
23:58:24 <omnId> @forget omnId NOT ACTUALLY A QUOTE
23:58:24 <roconnor> @quote testing
23:58:24 <lambdabot> No match.
23:58:24 <lambdabot> omnId says: testing
23:58:35 <omnId> @forget omnId testing
23:58:35 <lambdabot> Done.
23:58:39 <roconnor> @quote testing
23:58:39 <lambdabot> No quotes match. My mind is going. I can feel it.
23:59:04 <omnId> @remember omnId partial match test
23:59:05 <lambdabot> Done.
23:59:09 <omnId> @forget omnId par
23:59:09 <lambdabot> No match.
23:59:14 <omnId> @forget omnId partial match test
23:59:15 <lambdabot> Done.
