00:00:12 <omnId> > let dropLast n xs = foldr ($) ($ xs) (replicate n init) in dropLast 6 [1..10]
00:00:13 <lambdabot>  Couldn't match expected type `(a -> b) -> b'
00:00:23 <omnId> > let dropLast n xs = foldr ($) xs (replicate n init) in dropLast 6 [1..10]
00:00:24 <lambdabot>  [1,2,3,4]
00:00:56 <olsner> oh, that's clever
00:01:52 <omnId> basically I wonder the difference in time/space behavior between: (init . (init . init)) and ((init . init) . init)
00:02:02 <Pseudonym> @let dropLast n xs = foldr ($) xs (replicate n init)
00:02:04 <lambdabot> Defined.
00:02:06 <Pseudonym> :t dropLast
00:02:08 <lambdabot> Not in scope: `dropLast'
00:02:16 <Pseudonym> :t L.dropLast
00:02:17 <lambdabot> Couldn't find qualified module.
00:02:19 <Pseudonym> Grrr.
00:02:33 <omnId> @type let dropLast n xs = foldr ($) xs (replicate n init) in dropLast
00:02:35 <lambdabot> forall a. Int -> [a] -> [a]
00:02:37 <omnId> :)
00:03:45 <omnId> dropLast 3 xs = foldr ($) xs [init, init, init] = (init $ init $ init $ xs)
00:04:34 <omnId> folding functions is fun!
00:09:13 <LeCamarade>  /msg nickserve identify 1h4ckh45k311
00:09:18 <LeCamarade> Merde.
00:09:31 * LeCamarade cours a changer son mot de passe!
00:09:55 <LeCamarade> Merde! X^(
00:10:22 <omnId> you should always identify in a server window or nickserv /query
00:10:42 * lambdabot prepares to imitate LeCamarade
00:10:49 <LeCamarade> :-o
00:10:59 <omnId> change it quick!
00:11:04 <LeCamarade> Changed.
00:11:07 <LeCamarade> Phew.
00:11:22 <omnId> lambdabot is foiled.
00:11:30 <lambdabot> Darn.
00:11:58 <LeCamarade> lambdabot: You've been handing out with the BadBots. Who taught you such ... evil manners!
00:12:08 <LeCamarade> Did anybody @join her to #java?
00:12:39 * lambdabot whistles innocently
00:12:45 <LeCamarade> :-o
00:13:12 <omnId>  /who #java ; * #java :End of /WHO list.
00:13:14 <LeCamarade> @bot
00:13:15 <lambdabot> :)
00:13:46 <LeCamarade> ?where lambdabot
00:13:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
00:14:24 <bparkis> so i am thinking about user defined variable or function names
00:14:49 <omnId> user as in the user of your application?
00:14:58 <bparkis> as in the programmer in a programming language
00:15:13 <bparkis> in one sense, a "name" of a function or variable can be given as the code that defines that variable
00:15:21 <bparkis> assuming that it's referentially transparent
00:15:43 <bparkis> so if i say x = y*4+2 then i can use (y*4+2) interchangeably with x as an alternative name for x
00:16:14 <Pseudonym> Modulo full laziness, that's right.
00:16:30 <Pseudonym> let x = y*4 + 2 in x+x  -- Here, x is only evaluated once.
00:16:30 <bparkis> but for some reason, the names given to functions or variables tend to be shorter than the 'names' produced by simply writing out their definitions again
00:16:47 <Pseudonym> Not always.
00:16:51 <Pseudonym> cardInDeck = 52
00:17:06 <bparkis> why are user defined names usually shorter than "inherent" names (definitions in the base language)?
00:17:36 <bparkis> i mean practically speaking you can see they obviously would be in most cases, but fundamentally why?
00:18:13 <omnId> isn't that the purpose of modularizing in the first place?  See some common stuff, give it a name, use it multiple times.
00:18:17 <takamura> hi
00:18:25 <omnId> hello, tak
00:18:34 <Pseudonym> The more important thing is that the name should have more meaning than what it expands to.
00:18:43 <Pseudonym> Not its size.
00:18:49 <bparkis> yes but why is using the name multiple times shorter than using the common stuff literally multiple times
00:18:51 <bparkis> it usually is
00:19:15 <Pseudonym> Presumably because the cost of abstraction should be smaller than the cost of duplication.
00:19:41 <omnId> just don't go to thedailywtf.com :)
00:19:58 <bparkis> that's just restating the question
00:20:05 <bparkis> why is the cost of abstraction smaller than the cost of duplication
00:20:37 <bparkis> i think it has something to do with the 'literal' names for your functions or variables being in the global namespace of the entire language
00:20:38 <omnId> A fundamental question indeed, but I don't see any more gain from it than from staring at my navel :)
00:20:51 <bparkis> but your 'abstracted' names for your functions or variables being in just the namespace of your own program
00:20:56 <QtPlatypus> let theshortestpostiveintegerthatcannotbedescribedinenglishbyfewerthen100letters = ...
00:21:22 <Pseudonym> I do think that your problem is that you're lookig at it from the wrong direction.
00:21:26 <bparkis> so they require fewer bits, since the program namespace is implicit
00:21:27 <omnId> bparkis: In haskell, however, the "base" names, i.e. values in a datatype, are user-defined as well.
00:21:31 <Pseudonym> It's not important that the name be shorter.
00:21:38 <Pseudonym> It's more important that the name be more meaningful.
00:21:39 <omnId> constructors
00:22:04 <bparkis> well i'm interested in shorter
00:22:13 <Philippa> QtPlatypus: you just created a paradox - that identifier's fewer than 100 letters
00:22:16 <bparkis> there are other benefits to using abstractions besides length and meaning, besides
00:22:31 <bparkis> namely the principle "don't repeat yourself"
00:22:42 <QtPlatypus> Well re-iterated a one.
00:22:51 <bparkis> but i'm just interested in program length
00:23:05 <Pseudonym> Or, perhaps, "if it keeps showing up, give it a name so you can talk about it independently of its context".
00:23:12 <ricky_clarkson> bparkis: You can say *that* again.
00:24:26 <bparkis> but "so you can talk about it independently of its context" is only an advantage for three reasons--it's a mnemonic (just a human constraint), it's shorter, or it's more modifiable
00:24:55 <Pseudonym> No!  There are moer advantages than that.
00:25:09 <Pseudonym> It also allows for you to _reason_ about it independently.
00:25:13 <Pseudonym> e.g. test it independently
00:25:14 <bparkis> such as?
00:25:18 <Pseudonym> Or prove theorems about it independently.
00:25:37 <bparkis> what do you mean? you can test it easily enough if you use the entire expression literally
00:25:46 <bparkis> and you can prove theorems about it using the entire expression literally too
00:25:58 <bparkis> just use the expression in your proof everywhere that you would have used the name
00:26:02 <Philippa> but then you have to keep showing it's the same expression again
00:26:03 <bparkis> and it works out the same way
00:26:15 <Pseudonym> Right, so you've got the multiple maintenance problem.
00:26:39 <Philippa> that would be "more modifiable", mind
00:26:41 <Pseudonym> Philippa's point is actually quite important, when you take into account name substitution.
00:26:42 <ricky_clarkson> I think he covered that in "more modifi..."
00:26:44 <bparkis> well then it's an issue of pattern matching, what i'd also say is a human mnemonic device
00:27:03 <Philippa> we can only pattern-match so far
00:27:06 <bparkis> i mean once you're used to calling the thing (y*4-3) then you can recognize that in your expression as easily as you would recognize x
00:27:19 <Philippa> there's such a thing as too big a pattern
00:27:27 <bparkis> because you simply get used to treating (y*4-3) as the actual name of what you would otherwise name x
00:27:35 <bparkis> well then we get back down to which is longer
00:27:48 <Philippa> and y*4-3 is probably "conceptually longer"
00:27:51 <bparkis> the name or the exact expression, and that is what my original question is about
00:28:00 <Philippa> more 'syllables', and definitely more 'words'
00:28:09 <bparkis> y*4-3 is a string of characters, just as x is
00:28:14 <bparkis> that's a mnemonic issue
00:28:21 <Philippa> newsflash: humans don't parse by the character
00:28:29 <bparkis> it's harder to remember
00:28:31 <bparkis> right
00:29:58 <bparkis> at the moment, i'm stating that there are 3 reasons to name expressions instead of simply repeat them wherever they are used:  shorter length, as a mnemonic, and for better maintainability (alter in one place change everywhere)
00:30:34 <omnId> more confidence from proving properties about the abstracted part in isolation.
00:30:45 <bparkis> so the "smaller number of concepts" i would say falls into the mnemonic category
00:31:11 <Philippa> efficiency of evaluation: naming provides a sharing mechanism that doesn't need an optimiser
00:31:44 <bparkis> ok i'll buy that
00:31:50 <Philippa> it's not just mnemonic though, it's ease of recognition which isn't ease of rememberance
00:32:29 <sclv> recursion
00:32:43 <Philippa> sclv: doable with fixpoints instead, just painful
00:32:47 <bparkis> how would you distinguish the two?
00:33:22 <Philippa> distinguishing the symbol vs recalling the meaning associated with it
00:33:53 <bparkis> define the meaning of a symbol in a way that is not identical with the expression defining the symbol
00:33:53 <Philippa> oh, further reason: naming can convey (to a human reader) domain meaning
00:34:00 <bparkis> mnemonic
00:34:24 <Philippa> we do that all the time, it's the interface/implementation separation
00:34:49 <bparkis> here is how i would make that definition
00:35:11 <bparkis> 'a' meaning of a symbol (not 'the' meaning) is an invariant always true about the symbol
00:36:09 <bparkis> the invariant may only address one aspect of the symbol's behavior so it can be shorter than the full definition of the symbol
00:37:49 <bparkis> a property of the symbol, in other words--and then your argument would become that it is easier for humans to associate properties with symbols, than it is for them to associate properties with blocks of code
00:42:06 <Pseudonym> Gotta go.  Nytol!
00:42:25 <Japsu>   
00:42:26 <desegnis> bparkis, sounds good. We people wouldn't know how to define all of the words they use. But we associate properties with them, and that's how words are useful to us.
00:42:30 <opqdonut>  
00:42:37 <desegnis> *we use
00:42:40 <Japsu> Mui. opqdonut
00:42:54 <opqdonut> Mui. Japsu
00:43:39 <bparkis> and there are some situations where abstractions can make things more difficult to understand
00:44:31 <bparkis> if you have a very concise system for denoting things, like matrix algebra, then it may reduce comprehensibility to name the parts of an expression
00:45:04 <bparkis> because to understand the expression people are just going to have to substitute back in
00:45:42 <omnId> doesn't matrix algebra consist of symbols that have specific meaning that must be learned first?
00:46:16 <bparkis> true but i mean if you have (X'X)^(-1) then it is probably better just to leave it that way in your final expression
00:46:21 <bparkis> instead of calling it Z or something
00:46:39 <bparkis> even if you use it several times
00:46:50 <opqdonut> yeah but if you have E_0 E_1 ... E_n I it's usually nice to call it A :)
00:47:02 <bparkis> better to stay in the 'base' language of matrix algebra without extending it too much
00:47:27 <opqdonut> and you have all sorts of predicates for matrices like indempotent, nilpotent, positively definite etc
00:47:29 <bparkis> well opqdonut ok, there are cases where you do want to abstract even in matrix algebra
00:47:35 <bparkis> but there are cases where you don't
00:47:40 <omnId> that's just a product of familiarity and widespread notational convention.
00:47:47 <bparkis> where it's clearer not to
00:48:22 <omnId> the second causing the first
00:49:13 <omnId> familiarity with an abstraction is important.
00:51:23 <bparkis> that's true
00:51:48 <bparkis> but also people are familiar with stuff like (X'X)^(-1)
00:52:36 <bparkis> so it becomes a recognizable abstraction itself--an accepted 'name' for a certain thing, even though it's in the base language of matrix algebra
00:54:37 <omnId> I don't know what that is :)  I don't happen to have that base so, even though I'm confident there's a very specific meaning to those symbols, I've no way of divining it without becoming familiar with the base language and it's common idioms and abstractions.
00:54:56 <bparkis> here's something funny i just read a minute ago (about the k programming language)
00:55:08 <bparkis> 'minimize product of vocabulary and program size'
00:55:23 <ac> is there a concise way to write a lambda expression with guards or a way to combine multiple lambda expressions with pattern matches?
00:56:05 <omnId> (\x -> case x of ...) or (let f ... in f)
00:56:26 <ac> specifically, I want to write a lambda that turns 0 to Falso and 1 to True
00:56:40 <omnId> > fromEnum False
00:56:42 <lambdabot>  0
00:56:55 <ac> omnId: ah :)
00:57:23 <omnId> @type fromEnum
00:57:25 <oerjan> > toEnum 1
00:57:25 <lambdabot> forall a. (Enum a) => a -> Int
00:57:26 <lambdabot>  1
00:57:32 <oerjan> > toEnum 1 :: Bool
00:57:33 <lambdabot>  True
00:57:56 <omnId> (\x -> if x then 1 else 0) would work
00:59:19 <omnId> bool 0 1 where bool x y True = x; bool x y False = y -- :)
00:59:38 <omnId> erm, I flipped it
01:01:59 <omnId> oh, you wanted Int -> Bool?  (/=0) works :)
01:02:18 <omnId> as does toEnum
01:03:31 <quicksilver> Depending on the exact values of from/toEnum feels ugly though
01:04:08 <omnId> why?
01:04:17 <quicksilver> since that amounts to depending on the order of alternatives in a data declaration
01:04:43 <omnId> Enum Bool is specifically defined that way for this reason.
01:04:47 <quicksilver> what if some other haskell compiler had data Bool = True | False
01:04:57 <quicksilver> omnId: are you sure? what makes you sure?
01:05:05 <omnId> the report, silly :)
01:05:38 <quicksilver> I don't see that spelt out in the report
01:05:41 <allbery_b> this has been discussed on the list, there are both mathematical and convenience reasons for specifying that
01:05:50 <doserj> the prelude is part of the report
01:05:51 <quicksilver> yes, there are indeed
01:06:42 <allbery_b> and yes, the Standard Prelude which is part of the H98 report does specify this
01:06:53 <quicksilver> well you need to read the deriving appendix
01:06:57 <quicksilver> if I'm not mistaken
01:07:17 <quicksilver> you need to read data Bool = False | True in conjunction with 10.2 "Derived instances of Enum"
01:07:57 <quicksilver> to me that feels quite an uncomfortable thing to be relying on
01:09:46 <ac> :t (/=)
01:09:48 <lambdabot> forall a. (Eq a) => a -> a -> Bool
01:09:57 <ac> I see
01:10:27 <doserj> data Bool is also defined in chapter 6 of the report, not only in the prelude
01:10:35 <omnId> > (0 /= 0, 1 /= 0)
01:10:36 <lambdabot>  (False,True)
01:11:36 <ac> "(/=0)" is shorter than "toEnum", and more readable in my opinion
01:12:02 <quicksilver> doserj: right. but you need to read the deriving appendix
01:12:08 <quicksilver> doserj: if you want to know what that enum index is
01:12:27 <doserj> chapter 10 is not an appendix, is it?
01:12:27 <quicksilver> I think (/=0) is much better than toEnum
01:12:54 <quicksilver> doserj: well the URL I have is http://www.haskell.org/onlinereport/derived.html#derived-appendix
01:12:55 <lambdabot> Title: The Haskell 98 Report: Derived Instances
01:12:58 <quicksilver> :)
01:13:02 <quicksilver> so I assumed it was an appendix
01:13:56 <doserj> where did you get this link?
01:14:05 <quicksilver> I clicked on the reference in chapter 6
01:14:18 <quicksilver> which says "Enumeration types: (), Bool, and Ordering. The semantics of these instances is given by Chapter 10"
01:14:30 <quicksilver> the '10' is a hyperlink and contains that text :)
01:14:40 <quicksilver> anyhow, I don't think it matters if it's an appendix or not
01:14:50 <oerjan> @where report
01:14:50 <lambdabot> http://www.haskell.org/onlinereport/
01:14:52 <quicksilver> I think that it's bad style to depend on exact implementations of to/fromEnum
01:14:52 <ac> each line in your code has an implicit () around it, right?
01:15:02 <goalieca> the "show" in ghci is amazing.. any data type and it will show
01:15:02 <quicksilver> ac: no
01:15:23 <quicksilver> 1 + (2 +
01:15:24 <goalieca> how come i have to manually write my own damn "show" for anything complicated.. cuz ghci does it so nicely for free
01:15:26 <quicksilver>       3)
01:15:38 <oerjan> ac: an implicit ; before it, in some cases
01:15:50 <quicksilver> ac: ^^ the above wouldn't make sense if it had () round each line
01:15:52 <omnId> goalieca: deriving (Show)
01:15:55 <quicksilver> ac: the 2+ would be stuck
01:16:00 <ac> quicksilver: I thought that maybe a new line would change precedence
01:16:15 <quicksilver> new lines are completely ignored in 'non-layout' contexts
01:16:21 <ac> ok
01:16:25 <quicksilver> in layout contexts, new lines may insert some implicit }}}s
01:16:31 <quicksilver> depending how far 'back' you 'tab'
01:16:32 <goalieca> omnId, d'oh
01:17:38 <omnId> @src show
01:17:39 <lambdabot> show x = shows x ""
01:17:46 <omnId> @src shows
01:17:46 <lambdabot> Source not found. You type like i drive.
01:18:01 <oerjan> @src Show
01:18:01 <lambdabot> class  Show a  where
01:18:02 <lambdabot>     showsPrec :: Int -> a -> ShowS
01:18:02 <lambdabot>     show      :: a   -> String
01:18:02 <lambdabot>     showList  :: [a] -> ShowS
01:18:25 <omnId> shows = showsPrec 0 -- I think, strange it's not in the @src db
01:19:55 <oerjan> @src reads
01:19:55 <lambdabot> reads = readsPrec minPrec
01:20:29 <ac> here's another "please write code for me" question: what's a good way to turn the 3 least significant bits of an integer in to a tupple of bools?
01:20:37 <oerjan> human error presumably
01:21:28 <oerjan> > map (flip bit) [0,1,2] 14
01:21:29 <lambdabot>  Couldn't match expected type `t1 -> t'
01:21:36 <omnId> > zipWith testBit (replicate 3 5) [0,1,2]
01:21:37 <lambdabot>  Add a type signature
01:21:55 <omnId> > zipWith testBit (replicate 3 (5::Int)) [0,1,2]
01:22:00 <lambdabot>  [True,False,True]
01:22:05 <ac> omnId: nice
01:22:07 <omnId> > zipWith testBit (replicate 3 (6::Int)) [0,1,2]
01:22:08 <lambdabot>  [False,True,True]
01:22:21 <quicksilver> zipWith + replicate is just map
01:22:25 <oerjan> > map (flip testBit) [0,1,2] 14
01:22:26 <lambdabot>  Couldn't match expected type `t1 -> t'
01:22:44 <quicksilver> > map (6 `testBit`) [0,1,2]
01:22:45 <lambdabot>  Add a type signature
01:22:46 <omnId> oh, duh
01:22:51 <ac> how would you turn a list in to a tupple?
01:22:54 <quicksilver> > map ((6::Int) `testBit`) [0,1,2]
01:22:55 <lambdabot>  [False,True,True]
01:23:06 <quicksilver> ac: pattern matching, probably
01:23:13 <quicksilver> > let [a,b,c] = map ((6::Int) `testBit`) [0,1,2]  in (a,b,c)
01:23:15 <lambdabot>  (False,True,True)
01:23:29 <omnId> \[a,b,c] -> (a,b,c)
01:23:30 <goalieca> pattern matching probably isn't too bad. cuz you only have 2^3 cases
01:23:31 <oerjan> ac: triples are not very well supported
01:23:37 <ac> > (,,) 1 2 3
01:23:39 <lambdabot>  (1,2,3)
01:24:01 <omnId> > foldl ($) (,,) [1,2,3]
01:24:02 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b
01:24:02 <lambdabot>     Probabl...
01:24:13 <quicksilver> I was talking just yesterday about wanting a version of 'map' which works on homogenous tuples, but it's fiddly
01:25:32 <oerjan> > (\[x,y,z] -> (x,y,z)) [1,2,3]
01:25:33 <lambdabot>  (1,2,3)
01:26:35 <omnId> quicksilver: I guess I used zipWith since I once before zipWith'd some bits thing on an iterate shiftR'd thing :)
01:27:17 <quicksilver> :)
01:27:23 <quicksilver> not criticising
01:27:26 <quicksilver> just pointing out :)
01:27:35 <omnId> you should criticise, that was terrible :)
01:28:37 <ac> @hoogle testBit
01:28:37 <lambdabot> Data.Bits.testBit :: Bits a => a -> Int -> Bool
01:28:54 <omnId> split3 = map (.&. 255) . zipWith (flip shiftR) [16,8,0] . repeat
01:28:59 <omnId> I was doing base64
01:31:06 <quicksilver> functions which are often flipped should come with pre-flipped versions
01:31:18 <foo-nix> A *** Exception: String.hs:(184,2)-(185,60): Non-exhaustive patterns in function optEntry at runtime means that optEntry doesn't handlle a patern needed at runtime, right?
01:31:18 <quicksilver> for example, rTfihs = flip shiftR
01:31:22 <omnId> the Bits argument orders are all wrong
01:31:35 <omnId> foo-nix: yes
01:31:43 <foo-nix> omnId: Thanks.
01:32:10 <quicksilver> omnId: there is a reason they're like that. I can't remember what it is :)
01:32:41 <omnId> quicksilver: it can't be a very good reason (:
01:32:45 <quicksilver> no, it's not
01:32:52 <quicksilver> I htink it's so they 'look nice' infix?
01:32:59 <desegnis> @let shiftr = flip shiftR -- easier to read
01:33:03 <lambdabot> <local>:2:14:     Ambiguous type variable `a' in the constraint:       `Bits ...
01:33:09 <quicksilver> > (8::Int) `shiftR` 1
01:33:13 <lambdabot>  4
01:33:31 <quicksilver> desegnis: I wasn't entirely serious. But I do think rTfihs has a certain charm.
01:33:48 <omnId> > map (.&. 255) . zipWith (flip shiftR) [16,8,0] . repeat $ 0x102030
01:33:49 <lambdabot>  Add a type signature
01:33:55 <desegnis> quicksilver: ;)
01:33:59 <omnId> > map (.&. 255) . zipWith (flip shiftR) [16,8,0] . repeat $ 0x102030 :: [Int]
01:34:00 <lambdabot>  [16,32,48]
01:34:02 <quicksilver> if I was doing a lot of bit shifting, I'd probably locally bind .>. and .<.
01:34:18 <quicksilver> which match up with .&. and .|.
01:35:10 <quicksilver> > map (.&. 255) . map (0x102030 `shiftR`) $ [16,8,0]
01:35:11 <lambdabot>  Add a type signature
01:35:19 <quicksilver> > map (.&. 255) . map (0x102030 :: Int`shiftR`) $ [16,8,0]
01:35:20 <lambdabot>  Parse error
01:35:28 <quicksilver> > map (.&. 255) . map ((0x102030 :: Int) `shiftR`) $ [16,8,0]
01:35:29 <lambdabot>  [16,32,48]
01:36:19 <omnId> doesn't fit my delicious right-to-left flow I have going on in the rest of the functions :)
01:36:50 <quicksilver> > let for = flip map in  map (.&. 255) . for [16,8,0] $ ((0x102030 :: Int) `shiftR`)
01:36:51 <lambdabot>  [16,32,48]
01:37:12 <quicksilver> > let for = flip map in  map (.&. 255) . for [16,8,0] $ shiftR (0x102030 :: Int)
01:37:14 <lambdabot>  [16,32,48]
01:37:18 <quicksilver> \o/
01:37:32 <quicksilver> > let for = flip map in  map (.&. 255) . for [16,8,0] . shiftR $ (0x102030 :: Int)
01:37:34 <lambdabot>  [16,32,48]
01:37:44 <omnId> quiet, you
01:37:52 <omnId> :P
01:38:35 <omnId> combine4 = sum . zipWith (flip shiftL) [18,12,6,0] . map (table Data.Array.!) -- alright, smartass, change this to a map :)
01:40:38 <omnId> it takes four characters, (!)'s them into Ints in [0..63], zip shifts them into place, and sums 'em
01:41:13 <quicksilver> can move the map into the zipWith, but that would look ugly
01:43:59 <omnId> I like the symmetry of split3/combine4 anyway
01:49:41 <quicksilver> as in, zipWith (\a b -> b shiftL (table!a))
01:49:58 <quicksilver> omnId: I sometimes prefer an explicit lambda to a split
01:50:15 <quicksilver> omnId: and Data.Array.! hurts my eyes :) I try to import that unqualified
01:52:58 <omnId> ah, well.  I need sleep.  'night
01:53:46 <roconnor> @go 1 AUD in USD
01:53:48 <lambdabot> 1 Australian dollar = 0.8887 U.S. dollars
02:01:38 <ac> :t fmap Array
02:01:40 <lambdabot> Not in scope: data constructor `Array'
02:01:46 <ac> :t Array fmap
02:01:48 <lambdabot> Not in scope: data constructor `Array'
02:02:06 <ac> :t fmap
02:02:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:02:27 <quicksilver> you can't persuade :t to show you particular instantiations of types very straightforwardly
02:04:40 <oerjan> :t \f a -> fmap f (a `asTypeOf` Data.Array.fromList undefined)
02:04:42 <lambdabot> Not in scope: `Data.Array.fromList'
02:05:21 <oerjan> :t \f a -> fmap f (a `asTypeOf` Data.Array.array undefined undefined)
02:05:23 <lambdabot> forall b i e. (Ix i, Functor (Array i)) => (e -> b) -> Array i e -> Array i b
02:05:39 <oerjan> darn
02:05:51 <oerjan> ghc is lazy in reducing contexts
02:07:10 <oerjan> > fmap (+1) $ Data.Array.array (0,1) [5,10]
02:07:11 <lambdabot>   add an instance declaration for (Num (t, e))
02:07:11 <lambdabot>     In the expression: 10
02:07:32 <oerjan> > fmap (+1) $ Data.Array.array (0,1) [(0,5),(1,10)]
02:07:34 <lambdabot>  array (0,1) [(0,6),(1,11)]
02:07:49 <ac> I'm not sure what fmap does. I want a map like function for arrays :: (a -> b -> c) -> Array a b -> Array a c
02:08:02 <oerjan> oh.
02:08:12 <ac> would I have to use ixmap/
02:08:13 <ac> ?
02:08:17 <oerjan> you mean zipWith-like
02:08:17 <quicksilver> ac: that doesn't even make sense?
02:08:42 <quicksilver> you want a calculation which uses both index and contents?
02:08:42 <oerjan> it would have to check they have the same bounds, or possibly intersect
02:08:47 <quicksilver> and produces a new contents?
02:08:54 <quicksilver> (but the new contents go at the old index?)
02:08:55 <oerjan> oh wait, misread
02:09:22 <ac> quicksilver: yeah
02:09:30 <quicksilver> ok
02:09:36 <quicksilver> yeah, there isn't a built-in map quite like that
02:09:49 <quicksilver> you want to use assocs
02:10:24 <oerjan> that's not lazy though
02:10:30 <ac> I could toList -> map -> fromList...
02:10:44 <quicksilver> yeah, that's equivalent to assocs
02:10:51 <quicksilver> oerjan: depends on the array instance, I think
02:11:04 <quicksilver> oerjan: it can be somewhat lazy
02:11:15 <quicksilver> all arrays are index-strict though, I believe
02:11:42 <oerjan> hm i guess
02:12:17 <quicksilver> ac: I don't see toList and fromList? where are you looking?
02:12:28 <oerjan> confusing with Map i guess
02:12:53 <oerjan> they're assocs and array
02:12:57 <quicksilver> ah, the foldable instance gives you toList
02:13:01 <quicksilver> but it's not the right one :)
02:13:06 <quicksilver> it's the "values-only" toList
02:13:45 <oerjan> you need bounds too, to give back to array
02:13:49 * ac just discovered listArray, and removes lots of zipWiths
02:14:17 <ac> zipWith (,) [0..] ....
02:14:52 <desegnis> ac, anyway, zipWith (,) = zip
02:15:30 <ac> oh. silly me
02:23:23 <dibblego> data NEList a = Single a | Cons a (NEList a) -- does this data type appear in GHC somewhere? if not, is it useful?
02:24:19 <desegnis> ac, I must admit I use zip so rarely that I'd prefer zipWith to be called just zip
02:28:33 <oerjan> dibblego: lambdabot could have used it, what with its frequent Error: empty list bug :)
02:29:17 <dibblego> oerjan, :) I'm just thinking of things like, filter will then be (a -> Bool) -> NEList a -> [a]
02:29:45 <dibblego> fold won't need a start value
02:29:51 <quicksilver> dibblego: No. It's isomorphic to (a,[a]) of course
02:29:55 <dibblego> I'm just wondering if someone has already written it
02:30:00 <quicksilver> give or take the occasionally missing bottom
02:30:04 <sjanssen> dibblego: most folds want a starting value anyway
02:30:32 <sjanssen> dibblego: also, filter works perfectly well on empty lists too
02:31:12 <dibblego> well, foldr1 will be total then
02:31:15 <quicksilver> the isomorphism to (a,[a]) makes it essentially a 'pre-matched on :' list
02:31:33 <dibblego> the fact that this isomorphism exists, makes it useless?
02:31:37 <quicksilver> I do sometimes find I want to give a type to 'pre-matched' stuff
02:31:40 <quicksilver> not at all, no
02:31:46 <dibblego> ok, didn't think so
02:31:54 <quicksilver> just pointing out the type is already there, in a sense
02:31:58 <dibblego> ok :)
02:32:11 <quicksilver> consider Tree a = Leaf a | Bin (Tree a) (Tree a)
02:32:19 <quicksilver> sometimes you want 'pre-matched-on-Bin'
02:32:34 <quicksilver> which is isomorphic t (Tree a,Tree a)
02:32:45 <quicksilver> but sometimes I wish that had a better name
02:32:55 <quicksilver> it's hard to think of a really convenient scheme
02:34:04 <dibblego> ok thanks
02:34:48 <quicksilver> dibblego: I'm saying "yes, it's a good idea, but in general you want that for *everything* and it's not clear which ones are more important"
02:34:59 <dibblego> ah right, I understand
02:35:01 <quicksilver> dibblego: ndm's "catch" gives another approach in some cases
02:35:54 <dibblego> I have a function, that is going to guarantee to return a non-empty list and I want to use a type to denote that fact somehow
02:36:13 <dibblego> of course, I could just return the pair
02:36:28 <quicksilver> yes, I return the pair in that case
02:36:33 <quicksilver> if the calling code "really needs to know"
02:36:43 <Inis> Hello, can someone help me with a question about size's in wxHaskell?
02:37:04 <quicksilver> Inis: you can certainly ask. I'm not a wxHaskell user myself but maybe there are some around...
02:37:05 <dibblego> quicksilver, thanks again for the tips
02:37:27 * mux giving 6.8.0.20071017 a try
02:38:20 <Inis> thanks quicksilver. Well does anyone know how to extract the present size from a resizable panel?(wxHaskell)
02:40:47 <quicksilver> Inis: Like I say, I've never used wxHaskell. But wouldn't such a thing be a member of the 'Dimensions' class?
02:41:09 <quicksilver> and that whould give it a bunch of methods like 'outerSize', 'area', 'virtualSize' etc
02:41:23 <quicksilver> http://wxhaskell.sourceforge.net/doc/Graphics.UI.WX.Classes.html#t%3ADimensions
02:41:25 <lambdabot> http://tinyurl.com/2ysx2g
02:43:08 <Inis> sounds good... I'll check it out. Thanks.
02:43:20 <therp> excuse me can someone point me to/give me a good description of  http://haskell.org/ghc/docs/latest/html/libraries/haskell98/IO.html#v%3Abracket
02:43:21 <lambdabot> http://tinyurl.com/33z83e
02:43:37 <therp> @src bracket
02:43:37 <lambdabot> bracket before after thing = block $ do
02:43:37 <lambdabot>     a <- before
02:43:37 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
02:43:37 <lambdabot>     after a
02:43:37 <lambdabot>     return r
02:43:46 <therp> ah that makes more sense
02:46:08 <oerjan> @index bracket
02:46:09 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
02:48:37 <oerjan> therp: that version is the Control.Exception one
02:49:17 <quicksilver> therp: the block/unblock part is the subtle bit
02:49:25 <therp> oerjan: thanks, I just needed the source to understand that (and didn't think of lambdabot's @src before typing the question)
02:49:47 <therp> quicksilver: I got that already, the textual description of block/unblock is better than that of bracket
02:49:52 <quicksilver> the 'setup' and 'teardown' actions are proteced from async exceptions
02:49:59 <quicksilver> yes
02:50:09 <quicksilver> I meant, the *use* of block + unblock in bracket
02:50:17 <quicksilver> if you wrote bracket naively you'd probably miss them out
02:50:31 <therp> maybe yes
02:50:45 <quicksilver> well you probably wouldn't :)
02:50:46 <quicksilver> I would though
02:51:04 <Inis> Quicksilver... I might be wrong, but I think outerSize is used to set the size... I want to get the current size from an object... (In this case a panel with the attribute fill)
02:51:27 <therp> quicksilver: thanks for the unfounded overestimation :)
02:51:48 <quicksilver> Inis: attrs are gettable as well as settable
02:52:30 <quicksilver> Inis: you set them with set [ foo := ..], but you get them with 'get'
02:52:39 <quicksilver> Inis: get myPanel outerSize
02:52:41 <quicksilver> e.g.
02:53:49 <Inis> cool
02:55:41 <Hattes> quick question: can you have a "case .. of" expression in a "do" block? =/
02:56:00 <oerjan> yes
02:56:08 <Hattes> thx
02:56:19 <quicksilver> Hattes: you can have anything in a do block
02:56:32 <quicksilver> Hattes: do blocks are a specil way of joining expressions, but the expressions are not restricted by that
02:56:46 <oerjan> :t do data NotSo = NotSo; return "ha!"
02:56:49 <lambdabot> Empty 'do' construct
02:56:51 <desegnis> quicksilver: anything, but no where clauses
02:56:59 <quicksilver> anything which is an expression
02:57:04 <desegnis> right
02:57:09 <quicksilver> neitehr data nor where clauses are expressions, per se
02:57:17 <Hattes> quicksilver: ok, but what about "if .. then .. else"? when do you use these?
02:57:19 <quicksilver> of course, you can have where clauses inside do block in the right places
02:57:36 <quicksilver> Hattes: if then else is really just a special 'case
02:57:49 <quicksilver> Hattes: if you prefer you can always use case .. of True -> ... False -> ...
02:57:54 <quicksilver> Hattes: same difference :)
02:57:57 <EvilTerran> > 2 + if False then 1 else 3
02:57:57 <Hattes> aha
02:57:59 <lambdabot>  5
02:58:02 <oerjan> Hattes: there are some subtle layout traps with case of and if then else inside do blocks though
02:58:12 <quicksilver> not with case particularly?
02:58:16 <quicksilver> but yes, with if
02:58:19 <osfameron> quicksilver: except that the if then else requires you to specify both True and False cases, whereas the case doesn't :-)
02:58:37 <quicksilver> make sure the 'then' clause is at least one space further in than the 'if'
02:58:43 <quicksilver> but dont' recent GHCs permit it anyway?
02:59:01 <Hattes> my teacher reminded us of doing that, anyway.
02:59:04 <oerjan> Hattes: every subpart must be indented more than the "case" and "if"
02:59:23 <quicksilver> oerjan: I've never seen anyone try to write case any other way
02:59:29 <oerjan> (and of course "of" introduces its own block)
02:59:49 <quicksilver> it's only 'if' where you might logically put the 'then' on the same column
02:59:51 <oerjan> quicksilver: you might imagine putting the "of" directly below case
03:00:07 <quicksilver> ah, fair enough
03:00:09 <quicksilver> that's a good point
03:00:15 <quicksilver> I always put the of on the same line as the case
03:00:21 <quicksilver> but I see your point
03:00:46 <osfameron> just use a ternary operator!
03:02:08 <Hattes> is that oerjan as in örjan?
03:03:18 * MyCatSchemes pokes Lemmih.
03:04:04 <quicksilver> osfameron: you can actually do that if you're inclined
03:04:11 <quicksilver> osfameron: although you can't use ':' of course
03:04:43 <osfameron> quicksilver: I know, I've implemented it as ? and !
03:04:57 <oerjan> Hattes: Ørjan, actually
03:05:10 <osfameron> quicksilver: using Maybe's
03:05:54 <MyCatSchemes> Hrmn. Anyone around who might be able to help me work out why hssdl-image won't build, please?
03:06:53 <MyCatSchemes> The configure script says it can't find IMG_Load in -lSDL_image, but libSDL_image.so is in LD_LIBRARY_PATH and running nm on it shows that IMG_Load is definately in there.
03:11:53 <quicksilver> MyCatSchemes: look at config.log, see what actual commands it ran
03:12:05 <quicksilver> MyCatSchemes: it tries to compile a small C program, most likely
03:12:12 <quicksilver> MyCatSchemes: try that yourself and see why it doesn't work :)
03:12:24 <quicksilver> MyCatSchemes: off hand it could be using the wrong C compiler or looking in the wrong places
03:18:27 <MyCatSchemes> quicksilver: dankeschon.
03:19:54 <Hattes> i'm trying to make a text entry field in a GUI and i want something to happen when i press return. right now it says "func <- entry [on command := .. ]"
03:20:18 <Hattes> should this work? i've probably done something else wrong too =P
03:25:53 <titusg> Hi -- haskell-mode question - what variable I need to set to change the path to ghci so that C-l will load the buffer using a ghci from somewhere not in $PATH?
03:26:39 <quicksilver> titusg: I think it shuld use your default PATH
03:26:53 <quicksilver> titusg: so the easiest thing whould be to launch emacs with the right PATH?
03:28:32 <titusg> quicksilver, but I don't want this ghci (from HEAD) at the top of the path the whole time, I was guessing I could just tweak haskell-mode when I needed to...
03:28:45 <titusg> If I have to tweak PATH instead, that's OK
03:32:02 <titusg> I was betting there would be an option to go M-x set-variable haskell-mode-ghci-to-use "/home/blah/ghci"
03:32:14 <titusg> or something...
03:34:37 <quicksilver> there probably is
03:34:56 <quicksilver> titusg: I don't know what it is but use the soure, luke :)
03:35:52 <titusg> quicksilver, will do :-)
03:39:26 <titusg> quicksilver, it seems to be haskell-ghci-program-name. Cheers.
03:40:38 <MyCatSchemes> Hrmn, interesting. hssdl-* stop breaking when I compile my own copy of libSDL-*, instead of using DeadRat/CentOS's broken-ass ones.
03:41:13 <phlpp> >Char.chr 102
03:41:19 <phlpp> > Char.chr 102
03:41:20 <lambdabot>  'f'
03:41:40 <phlpp> > map Char.chr [104, 105, 33]
03:41:42 <lambdabot>  "hi!"
03:44:09 <quicksilver> MyCatSchemes: I have had such problems with SDL stuff before
03:44:34 <quicksilver> MyCatSchemes: I can't remember if I ever understood the reasons, I think it's something to do with the internal dynamic links between the 'sublibraries' ?
03:44:47 <quicksilver> dynamic linking is all very well except when it doesn't work :)
03:44:49 <osfameron> >  map toEnum [104, 105, 33] :: String
03:44:51 <lambdabot>  "hi!"
03:44:59 <MyCatSchemes> quicksilver: computers are getting sexily fast these days.
03:45:26 <quicksilver> I remember the first time I saw a linux kernel compile in under 30 minutes
03:45:30 <MyCatSchemes> quicksilver: for x in SDL*;do cd $x;./configure --prefix=$HOME/stuff && make -j3 && make install; cd ..; done; eject
03:45:33 <quicksilver> that was a dual Pentium 50 Mhz
03:45:49 <quicksilver> IIRC, they take about 30 minutes on today's moderate machines, too :)
03:45:55 <MyCatSchemes> quicksilver: I could not believe how little time it took the CD drive to poke out. :)
03:46:44 <MyCatSchemes> Also, I reiterate: Cabal is teh sex.
03:47:53 <quicksilver> I've not used it yet
03:48:49 <quicksilver> I've not used any haskell libraries which don't come bundled with my ghc :)
03:48:50 * quicksilver ducks
03:49:09 <osfameron> does cabal recursively get dependencies?
03:49:27 <osfameron> when I tried to install yi it didn't seem to, by default
03:49:49 <doserj> cabal doesn#t "get" dependencies at all
03:50:01 <doserj> it just complains if dependencies are not met
03:50:31 <doserj> cabal-install is supposed to to this instead
04:17:45 <therp> is haskell-mode in emacs automatically UTF8 encoded?
04:20:59 <quicksilver> therp: haskell-mode is, as far as I know, totally orthogonal to emacs encodings
04:21:22 <quicksilver> therp: you ought to be able to use haskell-mode on ascii buffers, utf8 buffers, kanji buffers, whatever you want
04:21:37 * vvv testing connection via www.ircatwork.com
04:22:01 <vvv> @ take 7 [0..]
04:22:20 <vvv> > take 3 [0..]
04:22:22 <lambdabot>  [0,1,2]
04:39:09 <allbery_b> @bot
04:39:18 <allbery_b> here we go again...
04:43:21 * LeCamarade &
04:46:54 <ukl> hello. I'm in trouble. I started messing with problem 92 of project euler and now I cannot return to my real work until I've got the following case clear. (Going to paste first, explain _my_ problem afterwards...) thanks for your time.
04:50:19 <hpaste>  ukl pasted "filter vs. (my) classify " at http://hpaste.org/3382
04:52:19 <ukl> As my first try with the problem went into heavy computation trouble (too much, too brute force), I thought by a kind of "saving" the numbers I already checked it might get better, but...it doesn't or at least doesn't do better than "filter". Can anybody explain this? Is "classify" wrong or misdirected? Is filter some built-in-always-faster-function (does this exist?)?
04:52:19 <byorgey> ukl: hm, since classify checks whether x is a member of (fst lists) or (snd lists), it's O(n^2)
04:52:30 <byorgey> as opposed to the version using filter which is just O(n)
04:53:18 <byorgey> ukl: saving the numbers is ok, the problem is that in order to check whether you've already seen a particular number requires scanning through the whole list of saved numbers every time.
04:53:21 <ukl> I thought the two list checks might be better than running through all numbers in the sumSq-sequence for every number. Or does filter internally save the results of earlier runs?
04:54:00 <byorgey> ukl: hm, I don't know.
04:54:05 <ukl> forget that, filter cannot know what reach89 does.
04:54:06 <byorgey> it depends on a lot of things.
04:55:28 <ukl> hm...ok. Thank you helping make things clearer.
04:59:35 <zeloran> hi
05:00:17 <oerjan> ukl: you might want to use a Map instead of a list, faster lookup
05:00:34 <oerjan> (assuming you are just using an elem check)
05:00:50 <zeloran> i need some help with a simple problem in haskell: i have a list and want to add all pairs that are neightbours like this:
05:01:08 <zeloran> (1,2,3) should become (3,5)
05:01:26 <oerjan> you mean [] not ()?
05:01:34 <ukl> oerjan: thank you, will have a look into maps
05:01:34 <zeloran> oh yes []
05:01:52 <zeloran> i know map, but it can only access one element per time
05:01:59 <oerjan> > zipWith (+) . drop 1 $ [1,2,3]
05:02:01 <mauke_> zeloran: zipWith (+)
05:02:09 <oerjan> oh wait
05:02:10 <mauke_> and ap and tail
05:02:22 <quicksilver> > (\l -> zipWIth (+) l (tail l) ) $ [1,2,3]
05:02:32 <quicksilver> > (\l -> zipWith (+) l (tail l) ) $ [1,2,3]
05:02:32 <mauke_> ENOBOT
05:02:35 <oerjan> > ap (zipWith (+)) (drop 1) $ [1,2,3]
05:02:50 <oerjan> @bot
05:03:08 <oerjan> wow, completely gone
05:03:13 <zeloran> ok thx i will have a look at this code/functions - regards
05:05:41 <allbery_b> <-- lambdabot has quit (Read error: 113 (No route to host))
05:05:58 <airy> @bot
05:05:59 <rahaskella> :)
05:06:05 * allbery_b hopes this was scheduled network maintenance...
05:06:13 <mauke_> > ap (zipWith (+)) tail [1,2,3]
05:06:16 <rahaskella>  [3,5]
05:06:24 <airy> :t ap`zip`tail
05:06:27 <rahaskella>     Couldn't match expected type `[a]'
05:06:27 <rahaskella>            against inferred type `m (a1 -> b) -> m a1 -> m b'
05:06:37 <mauke_> :t zip`ap`tail
05:06:40 <rahaskella> forall a. [a] -> [(a, a)]
05:06:42 <airy> Ahh
05:07:03 <airy> What was that called again, the Aztec God Function?
05:07:35 <scook0> @unpl zip`ap`tail
05:07:36 <rahaskella> (zip >>= \ b -> tail >>= \ a -> return (b a))
05:19:56 <Bourbaki5485> just fyi this seems a rather good link http://www.freetechbooks.com/forum-34.html
05:20:21 <mauke_> is this spam?
05:20:35 <Bourbaki5485> no its a link to a site that links to free books
05:20:48 <Bourbaki5485> and thats the page with books on functional programming
05:26:30 * ukl <3 Data.Map
05:27:47 <thepointer> if i have data Something = ONE | TWO | THREE | FOUR | FIVE, is it possible for me to use some function that will return 0 for ONE, 1 for TWO, 2 for THREE etc?
05:28:00 <mauke> yes, just derive Enum
05:28:12 <thepointer> ahh ofcourse.
05:28:20 <thepointer> it will start at 0 and not 1 correct?
05:28:24 <mauke> and Bounded, while you're at it
05:28:26 <mauke> yes
05:28:35 <thepointer> what's Bounded for?
05:28:41 <mauke> @src Bounded
05:28:42 <rahaskella> class  Bounded a  where
05:28:42 <rahaskella>     minBound, maxBound :: a
05:29:07 <mauke> > [minBound .. maxBound] :: [Bool]
05:29:08 <rahaskella>  [False,True]
05:29:18 <mauke> > [minBound .. maxBound] :: [Char]
05:29:20 <rahaskella>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
05:29:41 <thepointer> hrm
05:30:22 <thepointer> i'll investigate, thanks :)
05:31:42 <thepointer> Can't make a derived instance of `Enum Data' (`Data' has non-nullary constructors)
05:31:58 <thepointer> i don't fully understand how deriving classes works
05:32:14 <thepointer> especially in the case of Bounded where it appears you can specify a min and max value?
05:32:52 <mauke> huh? minBound and maxBound are members of the Bounded class
05:33:02 <mauke> deriving Bounded defines them for you
05:33:27 <thepointer> it seems so magical
05:33:52 <mauke> deriving is magical
05:34:01 <mauke> (it's hardwired into the compiler)
05:34:24 <doserj> unfortunately :)
05:34:34 <takamura> it's also explained in the report
05:34:49 <thepointer> the report seems daunting
05:34:51 <takamura> how deriving works
05:34:55 <takamura> yep
05:35:20 <wli> You need to be able to define functions by induction on the structure of types to do custom derivations.
05:35:27 <LeCamarade> The report _is_ daunting. :o)
05:36:13 <ddarius> LeCamarade: Read the C++ standard.
05:37:31 <thepointer> what expression would i write to get the value 0 from ONE ?
05:37:32 <LeCamarade> :o) That is illegal.
05:37:43 <mauke> fromEnum ONE
05:37:43 <quicksilver> fromEnum ONE
05:37:55 <quicksilver> the report is a model of clarity, compared to most language reports
05:37:59 <quicksilver> however, it is still daunting :)
05:38:09 <thepointer> it seems so obvious once i know what the answer is :/
05:38:34 <thepointer> thank-you :)
05:40:42 <phlpp> hm first chapters of All About Monads are really cool
05:41:10 <phlpp> they indeed show, as somebody in here mentioned yesterday, that monads are not a "arcane thing"/"magic", hehe
05:42:26 <thepointer> i still dont understand monads
05:42:44 <mauke> thepointer: understanding monads is optional
05:42:56 <phlpp> hehe
05:42:57 <thepointer> i wrote an assembler without understanding them
05:43:40 <phlpp> i just want to understand them (also the theoretical/maths aspect) because i really want to understand everything i have to work with
05:44:04 <thepointer> why do you have to work with it?
05:44:14 <phlpp> so it's maybe an obsession, but, we all have obsessions, haven't we?
05:44:48 <ukl> Knowing the possibilites makes you able to use them... maybe this is quite a reason enough... (well, actually this might be a bit idealistic, but..)
05:44:49 <thepointer> im not sure if i do, but i can definately understand it
05:44:56 <Saizan_> ave you seen the youtube lecturers by the catsters?
05:45:03 <Saizan_> *lessons
05:45:11 <thepointer> lessons on haskell?
05:45:46 <ukl> on category theory - maths - but not too far from haskell theoretical foundings, if I remember correctly.
05:46:47 <phlpp> ah
05:46:48 <phlpp> yeah
05:46:57 <phlpp> i have bookmarked this one
05:47:22 <ukl> (Does ghc ever think "This algorithm is so bad, I'll just stop calculating and wait for the idiot to write something better."? I doubt ghc does think, but I just feel like itt does sometimes. Let's see who's more stubborn...)
05:51:12 <raxas> ukl: ever seen an error message from ancient 8bit basic interpreter: "Redo from start"?
05:52:25 <raxas> on TRS-80 and its clone Video Genie 6006
05:52:26 <ukl> hehe no, never heard of this before. But I will give up now. 1:0 for ghc.
05:59:53 <ukl> f a b | y = "whatever" where y = g(..)
05:59:53 <ukl>         | otherwise = ....
05:59:53 <ukl> is not possible, is it?
06:00:01 <Vq^> is there a way to use the Maybe-monad style  'val <- maybeval'  with MaybeT?
06:00:25 <quicksilver> ukl: the 'where' comes after all the guards
06:00:41 <quicksilver> f a b | y = "whatever"
06:00:44 <ddarius> Just use it that way.
06:00:47 <quicksilver>      | otherwise = blah
06:00:53 <quicksilver>  where y = g (..)
06:01:17 <ukl> quicksilver: thank you. I'm not sure about whether this is evaluated in any case (in any guard) this way?
06:01:48 <quicksilver> nothing is evaluated until needed
06:01:51 <scook0> well, you have to evaluate y to determine whether the guard succeeds or not
06:02:01 <quicksilver> true, in this case
06:02:09 <quicksilver> but if 'y' was not the first guard
06:02:13 <ukl> there're other guards, yes
06:02:19 <scook0> but yeah, in the general case, if you don't inspect it
06:02:19 <quicksilver> than 'y' would never be evaluated if the first guard succeeded
06:02:29 <scook0> then it doesn't happen
06:02:42 <ukl> ok, nice. I wasn't sure about if this laziness-rule is the 1st one of all that I cannot stupidly override in any way ;) (surely somehow one can?)
06:03:28 <quicksilver> the general rule is that everything is lazy until inspected
06:03:39 <quicksilver> where inspection happens by 'case' or someting equivalent to case
06:03:51 <quicksilver> but "if" and guards are both like case, in this sense
06:03:54 <Vq^> a (MaybeT . return) function would solve my problem, maybe that should be in MaybeT?
06:04:05 <quicksilver> (they could both be translated to case)
06:04:37 <quicksilver> the really confusing bit is that it "feels like" IO prevents laziness, but really that's because of IO's definition of >>=, that's all.
06:06:02 <quicksilver> the other thingt hat some people find surprising is that 'let' doesn't 'inspect'
06:06:08 <quicksilver> even if you think it does :)
06:06:35 <ukl> I'm not sure if i missed something (just disconnected after my last lines)
06:06:51 <quicksilver> yes, a bit :)
06:07:09 <hpaste>  quicksilver pasted "scrollback" at http://hpaste.org/3383
06:07:15 <ukl> :) thank you
06:07:17 <quicksilver> ukl: there you go :)
06:10:54 <phlpp> hm
06:11:12 <wli> let xs = 1 : xs in take 10 xs
06:11:37 <phlpp> i bet there was some guy who subconsciously wrote something like a monad
06:11:46 <phlpp> and then said "ok, this is a monad"
06:11:55 <quicksilver> phlpp: loads of people wrote things like monads
06:12:00 <quicksilver> it was a common coding style
06:12:01 <phlpp> so a new term, "monad", was introduced and everybody thought, WOAH MAGIC!11
06:12:07 <quicksilver> yes, it was much like that
06:12:10 <phlpp> hehe
06:12:11 <phlpp> :)
06:12:50 <quicksilver> it's not online but in Paulson's "ML for the working programmer" he builds a combinator library for parsing
06:12:55 <quicksilver> which is monadic, but he doesn't say that
06:13:19 <quicksilver> some of the so-called "continuaton-passing-style code" is monadic, too
06:13:37 <phlpp> ah ok
06:13:44 <quicksilver> of course monadicity is actually a restriction, so some code people used to write with combinators is not monadic, although it looks 'nearly so'
06:13:50 <phlpp> cps is an unclear thing to me
06:14:09 <phlpp> ..yet
06:14:17 <quicksilver> well it's easy to explain a simple case
06:14:19 <roconnor> @bot
06:14:19 <rahaskella> :)
06:14:31 <quicksilver> suppose you want to call f on x, and then add one to the result
06:14:37 <quicksilver> the natural thing to write is "f x + 1"
06:14:43 <phlpp> yep
06:14:56 <quicksilver> the CPS style is to have a version of f, which takes a function, "what shall I do with my result"
06:15:04 <quicksilver> so you write "f (+1) x"
06:15:21 <quicksilver> and f does its job
06:15:38 <mux> does someone know if it's possible to ask the haskellmode plugins for vim to change the height of the window down the screen?
06:16:04 <quicksilver> and then applies the function to the result
06:16:06 <phlpp> so f is like: f :: (a->a) a
06:16:07 <phlpp> ?
06:16:08 <mux> like it's taking 3 lines by default, which is a bit too much
06:16:14 <ddarius> R5RS has some almost monad like combinators
06:17:01 <mux> nevermind
06:18:25 <quicksilver> and then applies the function to the result
06:18:29 <quicksilver> phlpp: yeah, that's right
06:18:33 <quicksilver> phlpp: sorry I was on the phone :P
06:19:12 <quicksilver> phlpp: CPS style functions look in general like f :: (b -> r) -> a -> r
06:19:28 <vincenz> What is value semantics?
06:19:28 <wli> cpsGetC :: (Char -> a) -> a
06:19:29 <quicksilver> phlpp: (in general they might be three different types, but in our case they were all the same)
06:19:47 <quicksilver> vincenz: out of context, Im' not sure
06:19:55 <flux> wouldn't most cps frameworks rather use f :: a -> (b -> r) -> r? so you can write f x $ \x -> ..
06:19:59 <quicksilver> vincenz: in context, I guess it might be in apposition to reference semantics
06:20:16 <quicksilver> vincenz: so suggesting immutability of the passed value?
06:20:19 <vincenz> ah
06:20:25 <vincenz> nah, just that values are copied when assigned
06:20:29 <quicksilver> or that, yes :)
06:20:37 <quicksilver> copying is just the poor-mans immutability
06:20:42 <phlpp> ah ok
06:20:55 <quicksilver> phlpp: there can alos be more than one continuation
06:21:08 <quicksilver> phlpp: as is "this is what you do if you get an error" " this is what you do with normal results"
06:21:33 <quicksilver> phlpp: have you seen the library function 'either' which is in Data.Either ?
06:21:33 <wli> Or true/false or case branching.
06:21:44 <phlpp> quicksilver: not yet
06:22:08 <quicksilver> > either (+1) (++"foo") $ Left (5::Int)
06:22:09 <rahaskella>  Couldn't match expected type `[Char]' against inferred type `Int'
06:22:22 * quicksilver sulks
06:22:42 <allbery_b> how would thjat work?
06:22:55 <quicksilver> I thought I was going to add 1 and get Left 6
06:22:55 <allbery_b> since either doesn't return an Either :)
06:23:00 <quicksilver> oh
06:23:01 <quicksilver> bah
06:23:03 <quicksilver> thanks :)
06:23:24 <quicksilver> > either (show) (++"foo") $ Left (5::Int)
06:23:25 <rahaskella>  "5"
06:23:28 <allbery_b> it's all gotta end up the same type somehow
06:23:31 <quicksilver> > either (show) (++"foo") $ Right "bar"
06:23:33 <rahaskella>  "barfoo"
06:23:42 <quicksilver> yes, I was thinking of 'mapEither' :)
06:23:56 <mux> > either id realToFrac $ Right (5::Int)
06:23:57 <rahaskella>  5.0
06:24:08 <quicksilver> phlpp: so, values of type 'Either' can hold one of two tpes
06:24:21 <quicksilver> phlpp: the 'either' combinator takes two functions and applies one depending if it's left or right
06:24:28 <quicksilver> :t either
06:24:31 <rahaskella> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
06:24:39 <quicksilver> phlpp: and it's type is a kind of CPS type
06:24:43 <kpreid> quicksilver: (+++) is mapEither
06:24:50 <quicksilver> kpreid: *nod*
06:25:11 <quicksilver> phlpp: in general you can do this for any data structure at all
06:25:21 <quicksilver> phlpp:  you just need one parameter per 'alternative' in the data structure'
06:25:38 <wli> > map (left (+1) . right (++" foo")) [Left (5::Int), Right "bar"]
06:25:40 <rahaskella>  [Left 6,Right "bar foo"]
06:26:05 <quicksilver> logicians have a name for this two. Something like 'Generalised Elimination Rule'.
06:26:10 <quicksilver> s/two/too/
06:26:12 * quicksilver blushes
06:26:24 <wli> I guess that's (+++)
06:29:31 <phlpp> :t (++)
06:29:34 <rahaskella> forall a. [a] -> [a] -> [a]
06:29:41 <phlpp> @src (++)
06:29:41 <rahaskella> (++) []     ys = ys
06:29:41 <rahaskella> (++) (x:xs) ys = x : xs ++ ys
06:30:05 <phlpp> isn't ++ something like >>?
06:30:25 <mauke> no
06:30:28 <allbery_b> er?
06:30:31 <wli> data Either3 t1 t2 t3 = Case1 t1 | Case2 t2 | Case3 t3 deriving (...) ; mapEither3 :: (t1 -> t1') -> (t2 -> t2') -> (t3 -> t3') -> Either3 t1 t2 t3 -> Either3 t1' t2' t3'
06:30:45 <allbery_b> you may be thinking of >>= in the list monad
06:30:52 <allbery_b> @src [] (>>=)
06:30:52 <phlpp> ok, then nevermind
06:30:52 <rahaskella> m >>= k     = foldr ((++) . k) [] m
06:31:10 <mauke> > "foo" `mplus` "bar"
06:31:11 <allbery_b> thing is, (>>) discards the left result
06:31:12 <rahaskella>  "foobar"
06:31:18 <zeloran> re
06:31:28 <wli> mapEither3 f1 f2 f3 e = case e of Case1 e1 -> f1 e1 ; Case2 e2 -> f2 e2 ; Case3 e3 -> f3 e3
06:31:48 <wli> Modulo bungling.
06:33:18 <zeloran> when loading this script from a file i get an error message
06:33:24 <zeloran> error:
06:33:25 <zeloran> Hugs> :load "D:\\1.3.hs"
06:33:25 <zeloran> ERROR file:.1.3.hs:1 - Cannot infer instance
06:33:25 <zeloran> *** Instance   : Num [a]
06:33:25 <zeloran> *** Expression : pas
06:33:29 <zeloran> file:
06:33:35 <zeloran> pas 1 = [1]
06:33:35 <zeloran> pas n = [1]++(zipWith (+) (pas n-1) ((tail (pas n-1))++[0]))
06:34:20 <mauke> (pas n) - 1 doesn't typecheck
06:34:35 <zeloran> you mean (pas n-1)
06:34:42 <zeloran> not (pas n) -1
06:34:49 <mauke> same thing
06:34:57 <zeloran> okay how todo type checking?
06:35:01 <mauke> what?
06:35:25 <zeloran> how to change my function(s) to get them work
06:35:41 <mauke> use pas (n - 1), not pas n - 1
06:36:31 <zeloran> wtf this worxx
06:36:37 <zeloran> i tired this before -.-
06:36:42 <zeloran> tried
06:36:55 <Axioplase> zeloran: "pas n" returns a list.   "(pas n) - 1"   substracts 1 to a list... type error.
06:38:25 <doserj> there should be a prominent notice on www.haskell.org: "Remember, function application binds tightest. And btw., read about the monomorphism restriction."
06:39:40 <Olathe> Don't recurse in polite company.
06:40:15 <mauke> core curse
06:40:21 <phlpp> @karma+ [quicksilver, mauke]
06:40:22 <rahaskella> [quicksilver,'s karma raised to 1.
06:40:26 <phlpp> eh
06:40:33 <zeloran> thx for the help
06:40:37 <phlpp> buggy thing :>
06:40:43 <phlpp> @karma+ quicksilver
06:40:43 <rahaskella> quicksilver's karma raised to 1.
06:40:45 <zeloran> i'm glad this worxx now :)
06:40:51 <phlpp> @karma+ mauke
06:40:52 <rahaskella> mauke's karma raised to 6.
06:41:04 <Olathe> @karma- [quicksilver,
06:41:04 <rahaskella> [quicksilver,'s karma lowered to 0.
06:41:10 <phlpp> yeah
06:41:54 <ukl> is it possible to define something like "Map k Maybe Bool"? So the values at the keys may be Nothing or Just True or Just False? (Maybe I misunderstood something)
06:42:00 <quicksilver> ukl: yes
06:42:06 <quicksilver> ukl: you lack only parentheses
06:42:11 <quicksilver> Map k (Maybe Bool)
06:42:18 <ukl> :) thank you
06:42:25 * osfameron looks at the monomorphism page, decides to come back to it later when he actually a) understands it and b) has that problem
06:43:15 <mrd> osfameron: the restriction? it's really easy
06:43:20 <ukl> It's nice to actually recognize you now _need_ something like Maybe. (This experience might generalize to all monads.)
06:43:30 <quicksilver> :)
06:43:35 <quicksilver> ukl: Maybe is great
06:43:44 <mrd> Maybe True!
06:43:48 <quicksilver> ukl: it's like using NULL pointers in C to signifiy 'not there', but it's safe!
06:43:59 <quicksilver> ukl: and you can choose whether or not to use that ability on a case by case basis
06:45:13 <osfameron> mrd: may well be.  But I think I would apply the mental resources to understand it if I get bitten by it first :-)
06:45:27 <allbery_b> <quicksilver> ukl: it's like using NULL pointers in C to signifiy 'not there', but it's safe!
06:45:35 <allbery_b> ...assuming nobody uses fromJust
06:45:50 <mrd> osfameron: you will get bitten if you write a definition like "foo = ..." and it has a polymorphic, type-class restricted type
06:46:10 <mrd> like: foo :: (Ord a) => a; foo = ...
06:46:28 <mrd> well, (Ord a) => ...
06:46:34 <mrd> that's it
06:46:51 <osfameron> mrd: as per spj's comment at end of http://www.haskell.org/haskellwiki/Monomorphism_restriction I think I (might) understand a more concrete example better
06:47:46 <doserj> foo = (>) -- doesn't typecheck
06:47:47 <quicksilver> allbery_b: I consider a runtime exception which terminates the program 'safe'
06:48:03 <quicksilver> allbery_b: compared to the nondeterministic shit NULL pointers can do :)
06:48:31 <allbery_b> nondetermiinistic?  modern OSes should have *0 unmapped
06:48:49 <allbery_b> the difference between a runtime exception and SIGSEGV isn't that significant
06:48:58 <mauke> mmap to the rescue!
06:49:35 <allbery_b> yes, well, if you deliberately shoot yourself in the foot, it's hard to stop you
06:49:37 <MyCatSchemes> quicksilver has bad memories of MesSDOS.
06:49:48 <MyCatSchemes> Or Lose95.
06:49:51 <allbery_b> that or 4.2BSD
06:50:00 <quicksilver> allbery_b: it is certainly not guaranteed by the C standard that dereferencing NULL is a definite SEGV, and I have over the years programmed on many OSes where it didn't segfault
06:50:21 <allbery_b> no, it's not guranteed byt he C standard.  I think SUS requires it
06:50:36 <quicksilver> I totally agree that it's true on most modern OSes
06:50:37 <allbery_b> not sure about POSIX
06:50:42 <quicksilver> but my memory goes back much further
06:50:47 <allbery_b> so odoes mine
06:50:52 <quicksilver> and most of my C programming was on OSes which didn't guarantee it
06:50:55 <allbery_b> (possibly much further...)
06:51:01 <SamB_XP_> I don't think I've ever used a hosted C implementation where it didn't segfault
06:51:03 <quicksilver> early versions of macos, mostly
06:51:47 <quicksilver> allbery_b: of course the nondeterminism is caused more often by dangling pointers than NULL ones, that's true
06:51:48 <allbery_b> 4.2BSD; RE7; Xenix; AT&T System III and early System V
06:51:52 <quicksilver> Maybe is still cool.
06:51:53 <phlpp> > "Foobar" ++ []
06:51:54 <rahaskella>  "Foobar"
06:52:06 <quicksilver> > "Foob" ++ "ar"
06:52:06 <allbery_b> and the many RE7 derivatives such as Unisoft
06:52:08 <rahaskella>  "Foobar"
06:52:26 <allbery_b> and of course most C implementations for microcomputers
06:52:27 <phlpp> quicksilver: seems like ++ in my case was like mplus
06:52:37 <allbery_b> (and, later, PCs)
06:52:41 <phlpp> where mzero == []
06:52:47 <quicksilver> phlpp: yes that's true
06:52:52 <quicksilver> phlpp: mplus for lists is defined to be ++
06:53:12 <phlpp> > "Foobar" `mplus` []
06:53:13 <rahaskella>  "Foobar"
06:53:16 <phlpp> hehe
06:53:30 <SamB_XP_> lambdabot looks funny this morning
06:53:40 <allbery_b> lb fell off the net
06:53:51 <allbery_b> <-- lambdabot has quit (Read error: 113 (No route to host))
06:54:00 <phlpp> :D
06:54:15 <SamB_XP_> where does she live now?
06:55:00 <quicksilver> I thought dons took her with him
06:55:03 <quicksilver> I'm not sure
06:55:10 <allbery_b> no, she;s still at UNSW
06:55:41 <phlpp> university of southern wales?
06:55:42 <phlpp> ;)
06:55:57 <quicksilver> new south wales
06:55:59 <quicksilver> (australia)
06:56:00 <phlpp> ah
06:56:00 <phlpp> ok
06:56:10 <phlpp> thats like far far away
06:56:17 <phlpp> for me, actually
06:57:40 <mauke> so, http://projecteuler.net/index.php?section=problems&id=23
06:58:07 <mauke> wait, they have a forum ...
06:58:21 <mauke> (my question was going to be about how you're supposed to solve this; my program doesn't seem very elegant)
07:01:49 <desegnis> Oh yeah, problem 23. I have an algorithm, but it turns out to be O(exp) complexity, so I don't have a solution yet :-(
07:03:26 <mauke> my program runs in 36s
07:05:32 <desegnis> I suppose I should think about the problem mathematically and see something clever
07:06:31 <mauke> how does your algorithm work?
07:08:08 <ddvlad> hi, just curious, is there any sort of protection against lambdabot flooding itself? i mean, you've probably had wiseguys trying to show [1..]
07:08:17 <mauke> > [1..]
07:08:19 <rahaskella>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:08:51 <ddvlad> i see. i suspected so,but really didn't want to experiment :-)
07:08:54 <quicksilver> ddvlad: lambdabot is limited to 80 (79?) characters and also has time limits
07:09:11 <quicksilver> > sum [1..]
07:09:15 <rahaskella> Terminated
07:09:23 <allbery_b> also, most dangerous stuff (e.g. IO) is not available
07:09:40 <ddvlad> quicksilver, allbery_b: thanks for the info. it was honestly an innocent enquiry
07:09:48 <quicksilver> ;)
07:09:56 <quicksilver> and those were honestly innocent answers!
07:10:08 <allbery_b> well, if you're thinking of running one, it's stuff that's nice to know
07:10:13 <desegnis> mauke, it does not work at all :). I tried to construct the list of all a+b up to a limit (a and b being abundant numbers) and then use this to find the numbers that are not a+b
07:10:35 <mauke> I'm doing the same, more or less
07:10:39 * allbery_b runs a lambdabot instance... but all the actual haskell-related stuff is removed because the channels she lives in are not interested in haskell, or for the most part programming
07:10:46 <doserj> desegnis: so am i
07:10:49 <mauke> except I only find the sum of the remaining numbers, not the numbers themselves
07:11:52 <LeCamarade> > readFile "/etc/passwd" -- No work
07:11:53 <rahaskella>  <IO [Char]>
07:12:00 <LeCamarade> :-o
07:12:10 <LeCamarade> > readFile "/etc/passwd" >>= putStrLn -- Worketh!
07:12:11 <EvilTerran> no IO for you!
07:12:12 <rahaskella>  <IO ()>
07:12:20 <LeCamarade> X^(
07:12:27 <EvilTerran> @help run
07:12:27 <rahaskella> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
07:12:45 <LeCamarade> > readFile "/etc/passwd" >>= (System.IO.Unsafe.unsafePerformIO $ putStrLn) -- :o)
07:12:46 <rahaskella>  Unbalanced parenthesis
07:12:46 <desegnis> mauke, then you do do something differently? I would have no idea how to find the sum of the numbers without knowing the numbers
07:12:54 <LeCamarade> > readFile "/etc/passwd" >>= (System.IO.Unsafe.unsafePerformIO $ putStrLn) -- :o|
07:12:54 <rahaskella>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
07:13:09 <allbery_b> the IO stuff is not in scope and not loadable
07:13:15 <mauke> desegnis: by finding the sum of all numbers, then subtracting the sum of abundant numbers. but that's probably a bad idea.
07:13:18 <LeCamarade> > readFile "/etc/passwd" >>= putStrLn
07:13:20 <rahaskella>  <IO ()>
07:13:52 <allbery_b> and LB actually compiles a program instead of using ghci (or ghc-lib) so the no-import can be rigidly enforced
07:15:02 <desegnis> mauke, ah. if there are less abundant numbers than non-abundant, then it's a good idea
07:16:43 <byorgey> which there are.
07:17:07 * desegnis is discovering more bugs in his code
07:17:26 * ukl is still looking for them...
07:18:52 <LeCamarade> > @djinn (a -> b -> b)
07:18:52 <rahaskella>  Parse error
07:19:02 <Beelsebob> so what does System.IO.unsafeDoggeh do?
07:19:16 <LeCamarade> > @djinn ((a, b) -> b)
07:19:16 <rahaskella>  Parse error
07:19:18 <puusorsa> unsafeDoggeh?
07:19:20 <LeCamarade> ?
07:19:32 <puusorsa> had do hoogle that one
07:19:32 <mauke> @djinn a -> b -> b
07:19:33 <rahaskella> f _ a = a
07:19:37 <Beelsebob> you all need to look at the lambdacats page more recently :P
07:19:48 <LeCamarade> :o)
07:20:01 <LeCamarade> @djinn a -> b -> b
07:20:01 <rahaskella> f _ a = a
07:20:17 <quicksilver> Beelsebob: I am subsrcibed to the RSS :P
07:20:19 <ari> It's evidently a very primitive doggeh
07:20:26 <Beelsebob> quicksilver: you're not the only one :P
07:20:38 <LeCamarade> ?where lambdacats
07:20:38 <rahaskella> I know nothing about lambdacats.
07:20:45 <LeCamarade> Blasphemy.
07:20:53 <Beelsebob> ?where+ lambdacats feed://arcanux.org/lambdacats-feed.xml
07:20:53 <rahaskella> Done.
07:21:14 <LeCamarade> No. Web page.
07:21:25 <Beelsebob> click the RSS button in the toolbar again then
07:21:40 <LeCamarade> I'm on w3m.
07:21:41 <ukl> oh my, lambdacats is great. =)
07:22:08 <LeCamarade> ?where+ \cats http://arcanux.org/lambdacats.html
07:22:08 <rahaskella> Done.
07:22:21 <LeCamarade> ?where \cats
07:22:21 <rahaskella> http://arcanux.org/lambdacats.html
07:22:27 <LeCamarade> :o)
07:23:36 <allbery_b> youd o realize that's kinda pointless since rahaskella will go away shortly after the real lambdabot comes back?
07:23:42 <LeCamarade> unsafeDoggeh. :o)
07:23:45 <allbery_b> along with her @where+s
07:24:01 <LeCamarade> Saves in different db?
07:24:12 <LeCamarade> Aucun backup?
07:24:16 <allbery_b> independent bots,so yes
07:24:29 <hpaste>  ukl annotated "filter vs. (my) classify " with "It's getting worse..." at http://hpaste.org/3382#a1
07:24:39 <ukl> has anybody got any idea what fundamentally wrong here?
07:25:10 <ukl> I think the "Map k 0"-like thing is kind of crude but might still be better than lists?
07:26:15 <ukl> (Instead of using the "Map k (Maybe Bool)"-type I asked for some time ago, I now use a useless Map whose values have no meaning but get flipped to True/False when creating the union of known values)
07:27:04 <LeCamarade> Woah. I just broke a rib on the latest lambdacats.
07:27:42 <LeCamarade> ?uptime
07:27:43 <rahaskella> uptime: 2h 22m 30s, longest uptime: 13d 8h 38m 20s
07:31:44 <mux> dcoutts_: ping?
07:32:46 <LeCamarade> ?bot
07:32:47 <rahaskella> :)
07:34:08 <koffein> hi
07:34:15 <dcoutts_> mux: hia
07:34:26 <koffein> I tried using gtk2hs recently..
07:34:41 <koffein> it say that it didn't support threads
07:34:56 <koffein> is there a haskell gui library that supports threads?
07:35:25 <mux> dcoutts_: hi :) I can't seem to get the #{const_str ...} hook to work with c2hs; any idea what I'm doing wrong?
07:35:42 <dcoutts_> koffein: in fact gtk2hs is almost the only gui library that does support threads
07:35:47 <allbery_b> no, becuase most of them are bindings to C libraries which don't support threads (largely because if they support x11, they have to use xcb to get thread support)
07:35:53 <dcoutts_> koffein: but you need to be a little careful
07:36:05 <allbery_b> and xcb is still a bit new for anything to be using it
07:36:23 <dcoutts_> mux: are you getting confused with hsc2hs? #{const_str ..} is hsc2hs syntax.
07:36:45 <mrd> i've used gtk2hs with the threaded RTS
07:36:52 <mux> dcoutts_: ah, I thought gtk2hs was using c2hs (I ssaw #{const_str } hooks in gtk2hs)?
07:37:07 <dcoutts_> mux: it does use c2hs, and also hsc2hs
07:37:12 <koffein> mrd, RTS?
07:37:13 <mrd> you just need to invoke a different main loop function.  and not do anything stupid.
07:37:18 <quicksilver> openGL works fine with threads
07:37:20 <mux> dcoutts_: arg! :)
07:37:20 <mrd> koffein: run time system
07:37:29 <dcoutts_> koffein: you can use Haskell threads safely with the single-thread rts, or you can use haskell threads with the threaded RTS but that requires more care.
07:37:32 <quicksilver> but you do need to not make GL calls from non-bound threads
07:37:55 <mrd> koffein: you have to ensure that all GTK-calling code comes from the main thread
07:37:57 <quicksilver> or, as I do, just not make GL calls at all from any but the GUI thread
07:37:57 <mux> dcoutts_: the only things I need for this binding code is a few macros and straight FFI hooks :-P
07:38:01 <quicksilver> wich is much easier
07:38:14 <quicksilver> don't need to remember which threads are bound and which not :)
07:38:25 <puusorsa> opengl in haskell isn't slow, right?
07:38:29 <quicksilver> not at all
07:38:37 <quicksilver> the FFI overhead is low
07:38:40 <quicksilver> (not zero, but low)
07:38:50 <puusorsa> great, thought so
07:38:57 <quicksilver> and good openGL practice has always been not to make loads of little APi calls
07:39:04 <quicksilver> but to use the clever big calls
07:39:17 <quicksilver> because that makes it more feasible for the GPU to run asynchronously of the CPU
07:39:18 <puusorsa> yeah, no Vertex3f() calls
07:39:32 <quicksilver> doesn't matter at all if your code is simple, though :P
07:39:37 <puusorsa> feed big buffers at a time to gpu, i know
07:39:44 <quicksilver> in fact I make lots of vertex calls and its fine
07:39:52 <quicksilver> btu I'll switch to buffers if my app starts to slow down
07:40:08 <ukl> (Laziness is greeat. I  know you know that already but there's noone else here to tell.)
07:40:24 <puusorsa> you don't render 100ktri meshes with: map Vertex3f listOfVertices
07:41:34 <quicksilver> puusorsa: no, indeed not :)
07:41:49 <quicksilver> puusorsa: although with a few ks of tris it works fine
07:41:51 <mux> dcoutts_: is there no c2hs equivalent?
07:42:13 <dcoutts_> mux: what does const_str do?
07:42:30 <mux> dcoutts_: it just replace the macro value in the source code
07:42:49 <mux> I have some FOO_MAX define I want to get hold on
07:42:50 <dcoutts_> mux: that relies a great deal on the C compiler I guess
07:43:24 <mux> well on cpp at least
07:43:31 <mux> which doesn't strike me as problematic :)
07:43:48 <mux> so, no way to do this with c2hs?
07:44:26 <puusorsa> right. anyway what i meant was: ffi call from haskell to render a VBO is not so much slower than doing the same from c as to make any difference, right?
07:44:35 * LeCamarade &
07:46:05 <puusorsa> "so i'll make this great mmorpg while learning haskell, wanna join the team? i have made hello world in haskell so it's almost finished already"
07:46:21 * Olathe waves >> threateningly.
07:47:24 <puusorsa> seen that with c(++) & opengl a lot .. "could you help me i'm making this game, but i ran into some weird problem.. pointers or something??"
07:49:55 <quicksilver> puusorsa: yes, I agree with your assessment
07:50:16 <quicksilver> puusorsa: the only time when haskell might feel slower than C is if you're doing massive complex calculations in haskell
07:50:25 <quicksilver> puusorsa: the openGL 'driving' part shouldn't be a bottleneck
07:50:52 <puusorsa> so i though, just wanted to make sure
07:51:11 <puusorsa> then there's gsl for haskell
07:51:19 <quicksilver> glsl?
07:51:33 <quicksilver> yes, you can use the glsl calls. But the glsl itself is still that nasty C-like language :)
07:51:37 <puusorsa> haven't really looked into the details but i got the impression it does the calculations
07:51:41 <puusorsa> not glsl
07:51:48 <puusorsa> gnu scientific library or something
07:51:50 <puusorsa> just a moment
07:52:06 <puusorsa> http://dis.um.es/~alberto/GSLHaskell/
07:52:26 <quicksilver> oh
07:52:38 <quicksilver> interesting
07:52:59 <puusorsa> probably better than the c++ i'd write in reasonable time
07:53:10 <puusorsa> http://alberrto.googlepages.com/easyvision
07:53:37 <puusorsa> that too
07:54:12 <ricky_clarkson> @pl \x y -> sqrt y
07:54:12 <rahaskella> const sqrt
07:54:14 * quicksilver nods
07:54:46 <ricky_clarkson> let cout=""; (>>)=const putStrLn in cout >> "AAAGGH"
07:54:50 <ricky_clarkson> :)
07:56:01 <Saizan_> are there binary windows packages for things on hackage?
07:56:04 <allbery_b> AAAGGH is right.,..
07:56:26 <Arnar> hey guys..
07:56:51 <Arnar> isn't here some prettier way of doing   inputfilename <- fmap (!! 0) $ getArgs
07:57:59 <conal> Arnar: slightly prettier: inputfilename <- fmap head getArgs
07:58:00 <allbery_b> fmap head?
07:58:02 <allbery_b> heh
07:58:14 <conal> :)
07:58:26 <Arnar> "nsfw haskell"
07:58:47 <shapr> @yow !
07:58:47 <rahaskella> Couldn't find fortune file
07:58:50 <shapr> hmm
07:58:53 <shapr> @seen dons
07:58:53 <rahaskella> dons is in #haskell. I don't know when dons last spoke.
07:59:11 <puusorsa> i know!
07:59:17 <byorgey> @localtime dons
07:59:19 <rahaskella> Local time for dons is Fri Oct 19 07:59:18 2007
07:59:20 <puusorsa> 8 hours ago
07:59:23 <thetallguy> Amar: why is there only one filename?
07:59:34 <thetallguy> couldn't you do
08:00:14 <thetallguy> getArgs >>= filterM validFile >>= mapM application
08:00:16 <thetallguy> ?
08:00:18 <allbery_b> shapr:  unsw fell off the net severl hours back.  the machine is pingable now but LB probably died when it lost its IRC server connections
08:00:30 <thetallguy> actually
08:00:39 <Arnar> thetallguy: hmm.. my app only accepts one file
08:00:45 <thetallguy> Why?
08:00:47 <allbery_b> poor design :)
08:01:00 <ricky_clarkson> Then make it accept it on stdin. ;)
08:01:06 <phlpp> where do i get the module Network from?
08:01:10 <Arnar> uhh.. because - it doesn't make sense for it to accept more
08:01:16 <Arnar> ricky_clarkson: I use stdin for user interaction
08:01:17 <thetallguy> why?
08:01:41 <Arnar> thetallguy: what do you mean why? you don't even know what the program does..
08:01:52 <thetallguy> That's what I'm asking you
08:01:56 <Arnar> oh..
08:02:05 <thetallguy> as albery said, it seems like bad design
08:02:08 <Arnar> well, it's a simulator for SOS for a mini-language
08:02:11 <mrd> phlpp: should come with GHC
08:02:16 <byorgey> phlpp: what platform are you on
08:02:17 <mrd> might be in "extras"
08:02:20 <thetallguy> every time I've used a program that took only one file, I had to work around it.
08:02:21 <Arnar> a school project
08:02:27 <byorgey> mrd: it didn't on Ubuntu.
08:02:33 <phlpp> byorgey: gnu/linux
08:02:36 <mrd> oh debian package splits it up
08:02:37 <phlpp> debian
08:02:44 <phlpp> ya..
08:02:45 <thetallguy> So it's effectively 'run this program'?
08:02:49 <byorgey> phlpp: ok, just apt-get install libghc6-network-dev
08:02:53 <mrd> search for the network-related ghc package
08:03:04 <Arnar> thetallguy: yes.. "step-by-step" at rate controlled by the user
08:03:18 <dhpeterson_> hey guys -- we're bitching out over on #erlang .. what's the current state of support for distributed programming in haskell?
08:03:21 <phlpp> wtf, 8mbytes
08:03:22 <dhpeterson_> :)
08:03:25 <phlpp> :>
08:03:30 <thetallguy> In that case I'd do something like
08:03:38 <dhpeterson_> i'm interested to know
08:04:10 <mrd> 8MB for the network library?
08:04:28 <Arnar> thetallguy: in any case, how many files are accepted is hugely irrelevant for the problem the program is solving
08:04:57 <thetallguy> Well, you were asking about code beauty
08:05:08 <thetallguy> so here's what I always see
08:05:14 <Arnar> :
08:05:15 <Arnar> :)
08:05:35 <Arnar> I was rather asking if there is an index (!!) operator that works on IO [a]
08:05:40 <thetallguy> people wrok to get some beautiful code, that doesn't actually handle all the cases correctly
08:05:42 <thetallguy> Ah
08:05:58 <thetallguy> I see that as the wrong question
08:06:03 <Arnar> like IO [a] -> IO a
08:06:12 <Arnar> well.. yes
08:06:19 <thetallguy> because if they put in no arguments, you're going to give them an error like   head not found
08:06:31 <thetallguy> which is absolutely the most aggravating thing you can see.
08:06:32 <Arnar> thetallguy: that's fine..
08:06:32 <phlpp> mrd: seems like libghc6-network-dev is included in ghc-prof
08:06:47 <phlpp> at least he tells me that's downloading ghc-prof and new packages installed will be ghc-prof and network stuff
08:06:52 <Arnar> thetallguy: not for code that is only meant as a demo accompanying a paper..
08:07:09 <dhpeterson_> seems there is chak's distributed haskell (old) and gdh and that's it/
08:07:43 <thetallguy> Arnar: well, I disagree, but it's my soapbox so I'll leave it until I have a solution.
08:09:19 <Arnar> thetallguy: :) -- to me it's a matter of allocating the finite time one has to the important tasks
08:09:45 <conal> thetallguy: hi.  how are things going?
08:09:46 <Arnar> but I get your viewpoint
08:09:54 <thetallguy> conal: pretty good
08:10:07 <thetallguy> working on a teeny library to release
08:10:14 <conal> yeah?
08:10:21 <conal> about what
08:10:23 <conal> ?
08:10:59 <thetallguy> Arnar: yes.  My goal is to create a style that is concise, correct, and easier to use than doing it wrong, so that you don't have to make that choice
08:11:17 <Arnar> thetallguy: I'm all for that :)
08:11:25 <thetallguy> Arnar:  See my Experience Report, ICFP, Linspire.
08:11:34 <thetallguy> Hence my soapbox.
08:11:43 <thetallguy> conal:  timing expression evaluation
08:12:43 <conal> thetallguy: sounds useful.
08:12:53 <quicksilver> Arnar: FWIW, I normally write fmap infix
08:12:58 <thetallguy> that reminds me, I should get the PDF of the slides public somewhere.
08:13:02 <quicksilver> Arnar: (!!0) `fmap` getArguments
08:13:18 <thetallguy> conal: serves two purposes, lets me time things, which I always like to do
08:13:32 <Arnar> quicksilver: yes.. I like that, but depends on the context..
08:13:32 <quicksilver> Arnar: but it still looks a bit nasty when the thing you are fmapping "!!0" is infx
08:13:39 <roconnor> > (+3) `fmap` (*2) $ 5
08:13:39 <thetallguy> conal: Runs me through the paces on library creation, which I've never done fully for cabal/hackage
08:13:42 <rahaskella>  13
08:13:48 <Arnar> quicksilver: what I was looking for was a function IO [a] -> IO a
08:14:08 <quicksilver> Arnar: fmap head, fmap (!!0) is that function :P
08:14:12 <mux> you have a [a] -> a function, which is good enough :-) you just have to lift it into the IO monad
08:14:20 <mux> :t fmap head
08:14:24 <rahaskella> forall a (f :: * -> *). (Functor f) => f [a] -> f a
08:14:25 <ricky_clarkson> Is Maybe likely to become just a direct pointer in binary?
08:14:28 <thetallguy> conal: we had a meeting of seereason and one thing we agreed was that all low level libraries we produce should go straight to open source
08:14:30 <Arnar> quicksilver: yes :)
08:14:38 <quicksilver> ricky_clarkson: everything is just pointers, in the binary :)
08:14:44 <conal> Arnar: fmap gives something more general than you were looking for.  that's the beauty of haskell.
08:14:45 <SamB_XP_> quicksilver: he said direct
08:14:45 <ricky_clarkson> quicksilver: Direct.  As in, elided.
08:14:51 <quicksilver> ricky_clarkson: no
08:14:55 <ricky_clarkson> Why?
08:15:01 <quicksilver> because that's not how it works
08:15:02 <Arnar> conal: good point
08:15:06 <conal> thetallguy: i'm glad to hear that.
08:15:06 <quicksilver> :P
08:15:14 <SamB_XP_> ricky_clarkson: only if the case analysis gets fused with the construction...
08:15:30 <quicksilver> ricky_clarkson: if the compiler can prove statically it's definitely "Just"
08:15:40 <ricky_clarkson> It doesn't have to do that, quicksilver.
08:15:41 <quicksilver> ricky_clarkson: then there are compiler optimisations which can fire
08:15:49 <ricky_clarkson> Pointers can be null (Nothing) too.
08:15:53 <SamB_XP_> heh
08:15:54 <quicksilver> no, you can imagine systems which do it that way
08:15:58 <quicksilver> but GHC doesn't
08:16:16 <ricky_clarkson> Why not?
08:16:37 <SamB_XP_> well, what would you do with Just Nothing?
08:16:52 <thetallguy> conal: larger technology we will probably advertise as existing, put under BSD, but only release to people who ask, with a future release scheduled for when it doesn't matter anymore.
08:17:00 <quicksilver> or Just Just Just Just Just Nothing
08:17:07 <ricky_clarkson> SamB_XP_: Make it a pointer to a memory address that contained null.
08:17:08 <quicksilver> (with appropriate bracketing which I'm too lazy to do)
08:17:38 <ricky_clarkson> SamB_XP_: I suppose the answer depends what you do with it.
08:17:41 <SamB_XP_> quicksilver: um, I think he is smart enough to realize that that comes soon after
08:17:44 <MyCatSchemes> quicksilver: Just $ Just $ Just $ Just $ Nothing :)
08:17:56 <thetallguy> conal: ever used QuickCheckM?
08:18:14 <conal> thetallguy: never
08:18:19 <quicksilver> SamB_XP_: Yes, I'm sure he is. I was just choosing to spell it out.
08:18:27 <thetallguy> conal: you and the rest of the world.
08:18:37 <thetallguy> For something so small, it takes a while to absorb.
08:18:42 <thetallguy> all the details.
08:18:57 <quicksilver> ricky_clarkson: basically, ghc has a system which is uniform over different data types, rather than making maybe into something special
08:19:20 <quicksilver> ricky_clarkson: I'm fairly sure a special case optimisation for maybe like you describe would be a small win.
08:19:30 <SamB_XP_> or maybe a lose
08:19:46 <quicksilver> I'm not even sure what you say is parametric
08:19:55 <quicksilver> in the sense that the repr. of (Just a) is independent of a
08:20:02 <quicksilver> (of the type of a, I mean)
08:20:08 <SamB_XP_> yeah, it also might be impossible
08:20:20 <conal> does anyone know how to generate & run low-level OpenGL shader code from Haskell?
08:20:23 <quicksilver> the parametricity of ghc's data representation means that parametric functions really are parametric
08:20:30 <quicksilver> (ignoring unboxed types)
08:20:49 <SamB_XP_> you don't have to ignore thme
08:20:53 <quicksilver> of course since they already special case unboxed types, they could have a special "unboxed maybe"
08:20:58 <thetallguy> conal: Mesa supports something
08:21:08 <quicksilver> conal: I am not aware of a clever trick
08:21:08 <conal> thetallguy: "Mesa"?
08:21:17 <fasta> Does treadDelay wait in CPU time? E.g. suppose the machine is very occupied, does it wait longer in actual time?
08:21:20 <SamB_XP_> since they aren't allowed as parameters anyway
08:21:20 <quicksilver> conal: that is you can just generate the C-like code as a text string
08:21:43 <quicksilver> conal: and then you pass it to the routine and the OS-level GPU driver compiles it
08:21:48 <SamB_XP_> conal: libGL
08:21:50 <ricky_clarkson> quicksilver: The case of Just Nothing persuades me, thanks.
08:21:53 <thetallguy> http://www.mesa3d.org/shading.html
08:21:58 <conal> quicksilver: what about the older assembly style, rather than C-like code?
08:22:07 <quicksilver> conal: it would be lovely to have a "combinator libary" for GLSLS
08:22:17 <quicksilver> conal: so you could write your shaders in something more sane :)
08:22:27 <quicksilver> it is a project which has been discussed on this channel before
08:22:31 <SamB_XP_> quicksilver: glxinfo + google for the win
08:22:36 <SamB_XP_> er
08:22:38 <SamB_XP_> conal:
08:22:47 <SamB_XP_> how did I type quicksilver when I meant to type conal?
08:22:56 <conal> quicksilver: that's the idea.  i want to update Vertigo (http://conal.net/Vertigo/), which was Windows-only.
08:23:18 <quicksilver> nice
08:23:51 <MyCatSchemes> Gah. How the heck does one actually *use* haddock? oO
08:23:52 <quicksilver> conal: I know nothing about openGL assembly code. If the underlying openGL libs support it, then either the haskell binding already does or it would be easy to add.
08:23:55 <conal> Vertigo generated C# and DirectX-style GPU assembler.
08:24:02 <SamB_XP_> conal: so why do you want to ASM-style code?
08:24:29 <conal> SamB_XP_: only because I'm guessing it would be easier to adapt the old Vertigo implementation.
08:24:45 <conal> quicksilver: thanks.  i'll poke around.
08:25:00 <SamB_XP_> conal: well, look through the extensions your card supports...
08:25:28 <conal> or i could start over and target a more modern C-style language.
08:26:29 <SamB_XP_> I couldn't say, having a vertex-shader-only card...
08:27:05 <centrinia> You can program shaders with functional languages.
08:27:11 <quicksilver> centrinia: how?
08:27:21 <centrinia> I remember some paper.
08:28:56 <conal> centrinia: maybe Vertigo? http://conal.net/papers/Vertigo
08:28:57 <MyCatSchemes> Aaaaaah. Is there a guide For Stupid People (tm) on how to take Haddock to a downloaded library that builds with Cabal and just have it magically run off and work?
08:29:19 * MyCatSchemes is sorely confused. Some things do work, some things don't work and he has no clue which fall under which category.
08:29:36 <centrinia> Let me look for the original link from LtU.
08:30:06 <quicksilver> conal: hopefully the intermediate language doesn't make too much difference for the user, only the implementor :)
08:30:13 <centrinia> It is Accelerator from Microsoft: http://research.microsoft.com/research/pubs/view.aspx?type=technical%20report&id=1040
08:30:32 <quicksilver> conal: so the correct question, maybe, is 'which language is most well supported by the graphics cards people have in practice' ?
08:30:35 <quicksilver> conal: or something :)
08:30:37 <conal> quicksilver: yep: invisible.
08:31:44 <thetallguy> conal: does that mesa3d link look like what you need?
08:31:55 <MyCatSchemes> Like, when I type "runghc Setup haddock" in an unpacked Cabal package, where do the generated HTML files (if any?) get actually placed?
08:32:25 <conal> quicksilver: i hadn't considered that these two intermediate languages might have different implementation coverages.
08:32:26 <MyCatSchemes> Ahhh. dist/doc
08:32:33 <conal> thetallguy: thanks.  i'd dropped that stitch.
08:32:53 <thetallguy> conal: must be the season of the witch
08:33:01 <quicksilver> thetallguy: however, the existence of shader languages isn't in question. It's whether or not haskell has bindings to them :)
08:33:11 <conal> oh -- mesa is an open source openGL implementation.
08:33:24 <quicksilver> I think mesa plays a rather small part in modern openGL implementations
08:33:26 <thetallguy> quicksilver: one step at a time
08:33:33 <quicksilver> it is sometimes used as a fallback
08:33:37 <quicksilver> when hardware support is limited
08:33:40 <quicksilver> but other than that
08:33:47 <quicksilver> it's really bindings to the GPU
08:34:32 <thetallguy> quicksilver: yes, still trying to nail down exactly what it is that Conal is looking for.
08:34:55 <thetallguy> conal: is the OpenGL stuff sufficient?
08:35:06 <quicksilver> thetallguy: he wanted to know if the haskell bindings to openGL supported any shader languages
08:35:15 <quicksilver> thetallguy: the answer I gave was 'yes, they support GLSL'
08:35:24 <quicksilver> then he wanted to know if they supported the older assembly-style one
08:35:29 <quicksilver> which I didn't know.
08:35:43 <thetallguy> quicksilver: I'm continuing a previous conversation with conal
08:35:51 <conal> quicksilver: where can i get started with a Haskell GL binding?
08:36:06 <quicksilver> conal: cargo-cult!
08:36:06 <conal> thetallguy: i don't know.  i've never worked with GL.
08:36:07 <phlpp> hm, is there some function in IO library or in any library, that does something like sleep?
08:36:26 <thetallguy> threadDelay
08:36:30 <dv^^> threadDelay
08:36:31 <phlpp> i'm working through this irc bot tutorial, but the bot sends JOIN #channel command before server accepted him as user
08:36:33 <quicksilver> conal: http://www.haskell.org/haskellwiki/Opengl
08:36:41 <thetallguy> phlpp:  Control.Concurrent.threadDelay
08:36:46 <phlpp> :t threadDelay
08:36:49 <rahaskella> Not in scope: `threadDelay'
08:36:58 <quicksilver> conal: the examples directory there gives a starting point
08:36:59 <phlpp> :t Control.Concurrent.threadDelay
08:37:02 <rahaskella> Int -> IO ()
08:37:05 <quicksilver> conal: I'm happy to help with specific questions :)
08:37:05 <phlpp> fine
08:37:09 <conal> quicksilver: thanks!
08:37:18 <quicksilver> conal: I've been writing openGL code on the train most days for a few weeks :)
08:37:29 <quicksilver> conal: but not, I hasten to add, GLSL.
08:37:59 <conal> quicksilver: great.  and you've seen some glsl support?
08:38:03 <quicksilver> yes
08:38:06 <quicksilver> I know it exists
08:38:09 <quicksilver> I just haven't used it
08:38:20 <thetallguy> Stand-alone Compiler   A unique stand-alone GLSL compiler driver has been added to Mesa.    The stand-alone compiler (like a conventional command-line compiler) is a tool that accepts Shading Language programs and emits low-level GPU programs.
08:38:40 <quicksilver> conal: http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-Shaders.html
08:38:44 <quicksilver> (ouch long URL)
08:39:16 <phlpp> do i have to do some other stuff, e.g. create a thread, to use threadDelay?
08:39:20 <quicksilver> phlpp: no
08:39:22 <chessguy> @tiny http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-Shaders.html
08:39:22 <rahaskella> http://tinyurl.com/2ypp8k
08:39:24 <phlpp> hm, that's odd
08:39:27 <quicksilver> phlpp: it's measured in microseconds, though
08:39:32 <quicksilver> phlpp: so you need quite a lot of them :)
08:39:34 <conal> quicksilver: super.  thanks.  now i wonder about GUI options with HopenGL.  what are you using?
08:39:36 <phlpp> micro, really
08:39:41 <quicksilver> conal: GLUT
08:39:44 <phlpp> 2 * 10^6
08:39:49 <phlpp> would be 2 seconds?
08:39:53 <quicksilver> conal: which is pretty simplistic and lightweight but fine for me
08:39:55 <quicksilver> phlpp: right
08:39:57 <thetallguy> conal: gtk has them, I believe
08:40:02 <quicksilver> conal: the other option is gtk2hs
08:40:04 <smitti12> a newbie question: what is the best approach to evaluate if a list of e.g. data Shape = Rectangle a a | Ellipse a a ... etc. contains a particular shape. elem does not work.
08:40:25 <quicksilver> :t find
08:40:28 <rahaskella> forall a. (a -> Bool) -> [a] -> Maybe a
08:40:41 <quicksilver> smitti12: find; it will actually return the element if it's there but you can ignore that :)
08:40:50 <quicksilver> smitti12: and just concentrate on whether it's Nothing or Just
08:41:04 <conal> i've heard wxHaskell can also.  i'll probably try that first.  good to know about alternatives.  i want to generate the UIs as phooey or TV.  and to tie into Eros (which uses phooey &  TV).
08:41:19 <allbery_b> @tell dons pill01.orchestra lost inet connectivity at around 1130Z; LB appears to have subsequently exited
08:41:19 <rahaskella> Consider it noted.
08:41:21 <quicksilver> I haven't used wxHaskell. You may well be right :)
08:41:36 <thetallguy> conal: llooks like enough pieces are ther to get you a good start
08:41:38 <smitti12> thx, I will try.
08:41:48 <quicksilver> most modern GUI libraries have opengl widgets, but the question is if the haskell bindings join together in teh right way
08:41:53 <quicksilver> although I don't think that's all that hard to arrange
08:42:57 <conal> thanks.  i'll give it a try.  i'm going to give talks and chat with folks at apple & intel in three weeks.  they're into data-parallel graphics programming, and i'd enjoy showing off functional GPU programming.
08:43:10 <quicksilver> yes
08:43:14 <quicksilver> that would be really nice
08:43:15 <conal> with lovely types & all.
08:43:19 <quicksilver> I'd love it if you did that too :)
08:44:33 <ukl> What's  a efficiient way to insert a list into a Map? (With the list items as keys and all keys having the same value?)
08:44:41 <ukl> (an efficient)
08:44:48 <ricky_clarkson> How does QuickCheck know what types functions take?
08:44:58 <conal> quicksilver: thanks for the encouragement & the getting started pointers.
08:45:09 <conal> thetallguy: and for the mesa3d pointer.
08:45:09 <quicksilver> ricky_clarkson: by the magic of type inference?
08:45:22 <quicksilver> ukl: I think foldl' with Map.insert is fine
08:45:33 <quicksilver> ukl: the other option would be Map.union and fromList
08:45:44 <ukl> :) thank you.
08:45:44 <quicksilver> ukl: I have no reason to believe that's faster, I'd expect it to be slower
08:46:13 <quicksilver> conal: please keep us posted if you achieve anything to look at :)
08:46:26 <conal> quicksilver: will do. :)
08:46:41 <conal> i enjoy my projects more when i know someone else is interested.
08:47:16 <thetallguy> conal: yes, I'd love to play with it, but have enough other stuff that I need to get woking first.
08:47:23 <thetallguy> working, even
08:47:40 <ricky_clarkson> quicksilver: I know what type inference is, but I still don't get that.
08:48:30 <ricky_clarkson> quicksilver: I could imagine adding type signatures everywhere, but I don't see how that helps in grabbing data to test with.
08:48:35 <phlpp> > init [1..] == [1..]
08:48:37 <SamB_XP_> ricky_clarkson: well, you have to fix the types of properties before checking them...
08:48:40 <ricky_clarkson> s/that/type inference/
08:48:41 <rahaskella> Terminated
08:48:43 <phlpp> hehe
08:49:16 <ricky_clarkson> SamB_XP_: So they cannot be polymorphic types, ok.  A step closer, but the light's not yet on.
08:49:36 <iank> lambdabot -> rahaskella ?
08:49:49 <SamB_XP_> iank: apparantly lambdabot's host is down or something
08:49:55 <iank> Ah
08:50:41 <SamB_XP_> @hoogle quickCheck
08:50:42 <rahaskella> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
08:50:43 <rahaskella> Test.QuickCheck :: module
08:50:55 <SamB_XP_> @doc Test.QuickCheck
08:50:56 <rahaskella> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
08:51:04 <allbery_b> host is back up but lambdabot exits when it loses all its server connctions
08:51:17 <ricky_clarkson> Testable, ahh.
08:51:26 <SamB_XP_> allbery_b: oh, it wasn't the computer that went down?
08:51:54 <allbery_b> not absolutely certain but "No route to host" suggests otherwise
08:52:50 <SamB_XP_> oh, what happens when the host itself goes down?
08:53:06 <SamB_XP_> ricky_clarkson: and Arbitrary generates the test data
08:53:07 <allbery_b> [07:47] <-- lambdabot has quit (Read error: 113 (No route to host))
08:53:12 <allbery_b> usually a ping timeout
08:54:18 <ricky_clarkson> SamB_XP_: I noticed that it doesn't really seem to pick boundary values.
08:54:28 <allbery_b> "No roue to host" usually means an intermediate hop which should have had a route didn't, suggesting that some or all of UNSW's network was disconnected for a bit
08:54:29 <ricky_clarkson> ..e.g., the max for an Int, etc.
08:54:29 <SamB_XP_> boundary values?
08:54:41 <SamB_XP_> oh, that
08:55:03 <ricky_clarkson> 16777215 and ..216 for a Float are interesting too.
08:56:04 <ricky_clarkson> @src Arbitrary
08:56:04 <rahaskella> Source not found. Where did you learn to type?
08:56:17 <ricky_clarkson> On a Spectrum 48k.
08:57:03 <SamB_XP_> someday I should submit a patch to turn off the smart-ass comments on @src...
08:59:31 <Saizan_> ?docs System.Posix
08:59:31 <rahaskella> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix.html
09:00:37 <osfameron> SamB_XP_: yes!
09:01:04 <SamB_XP_> unless someone else does it first
09:02:09 <dcoutts_> conal: re Gtk2hS and OpenGL, I have a program using both which I use in a first year FP practical. It's pretty bling :-)
09:02:18 <fasta> SamB_XP_: bug #1450 appears to be working, btw.
09:02:58 <TomMD> in an instance of Binary, how does one express an error in a pure manner (avoiding 'error' and 'throw')?
09:03:15 <SamB> TomMD: error?
09:03:26 <SamB> you aren't supposed to have an error :-(
09:04:15 <dcoutts_> conal: http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
09:04:17 <Saizan_> ?hoogle exitWith
09:04:18 <rahaskella> System.exitWith :: ExitCode -> IO a
09:04:20 <TomMD> So, there is no way to exit the "get" or "decode" call without calling "error" and thus requiring the IO Monad to catch?
09:04:29 <bos> TomMD: correct
09:04:53 <TomMD> Is there any way I could lift Binary into Maybe, allowing me to return 'Nothing'?
09:05:16 <SamB> fasta: nice
09:05:36 <TomMD> And secondly, does anyone else see this as a large issue with using Binary / ByteStrings for network coding?
09:06:27 <dcoutts_> TomMD: hmm, it is something that's been raised as an issue before
09:06:51 <dcoutts_> TomMD: we should investigate how much it impacts on performance
09:07:20 <dons> there's been a few libs that wrap up the lower layers
09:07:20 <rahaskella> dons: You have 2 new messages. '/msg rahaskella @messages' to read them.
09:07:21 <TomMD> Indeed, but sometimes the performance is secondary to completeness.
09:07:42 <SamB> dcoutts: at least investigate whether you can come up with a clever strategy to allow the choice of lazy or safe ;-)
09:07:42 <shapr> allbery_b: ah, I see
09:07:44 <dons> TomMD: the idea is that its a base layer, on top of which you'd run ErrorT or something, iirc
09:08:18 <dcoutts_> dons: right, though we've not ever fleshed out that design
09:08:26 <dons> right
09:08:34 <bos> TomMD: you could possibly use MaybeT on top (not GetT on top of Maybe)
09:08:48 <dcoutts_> dons: btw, you saw the call for ICFP workshops?
09:08:53 <bos> but as neither MaybeT nor GetT exists, you'd have a bit of plumbing to do
09:08:59 <dons> oh, haven't read my mail yet.
09:09:02 <SamB> @google MaybeT
09:09:02 <dcoutts_> dons: we need to get that application in for the hackathon
09:09:02 <dons> sounds interesting..
09:09:04 <rahaskella> http://www.haskell.org/haskellwiki/New_monads/MaybeT
09:09:04 <rahaskella> Title: New monads/MaybeT - HaskellWiki
09:09:06 <dons> yup
09:09:23 <bos> hackathon++
09:09:36 <dcoutts_> @karma hackathon
09:09:36 <rahaskella> hackathon has a karma of 2
09:09:38 <TomMD> Hummm... worth a look I suppose.  It just strikes me that Haskell is well suited for network applications - it is safe and the network will still be the bottle neck.
09:09:47 <dons> yep
09:09:56 <ari> Hi dons, is lambdabot coming back?
09:10:04 <dons> and we hope people will use Get and Put for this task -- there's been a few success stories with it so far anyway
09:10:07 <SamB> bos: it's not hard to write MaybeT anyway...
09:10:08 <dons> ari: yep, once i get to work
09:10:16 <bos> yes, it is well suited to network applications.
09:10:24 <smitti12> find/forall brings me back to the original question, what function can I use it identify that a shape is a Rectangle. s == Rectangle does not work because the constructor has two parameters.
09:10:27 <ari> rahaskella: @admin + freenode:dons
09:11:47 <TomMD> dons: is anyone in your office updating HALFS for GHC 6.8 or is this left to the community?
09:12:13 <dons> probably isaac is too busy
09:13:08 <dons> though internally we're using something not the same as halfs, i think
09:14:12 <dons> lambdabot: ?version
09:14:17 <lambdabot> lambdabot 4p555, GHC 6.6 (Linux i686 2.66GHz)
09:14:23 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:14:28 <phlpp> Multiple declarations of `Main.eval'
09:14:28 <phlpp>     Declared at: Bot.hs:54:0
09:14:28 <phlpp> 		 Bot.hs:56:0
09:14:35 <phlpp> eval h	  "!hau	ab"   	      	 = write h "QUIT" quitmsg >> exitWith ExitSuccess
09:14:35 <phlpp> evil h x | "!id " `isPrefixOf` x = privmsg h (drop (length cmdprefix+3) x)
09:14:41 <phlpp> do i have to obey indentation?
09:14:43 <dons> evil
09:14:45 <dons> `evil'
09:14:59 <phlpp> sry for some maybe mistyped chars, it's emacs fault
09:15:01 <dons> :)
09:15:16 <dons> your second line binds a function called 'evil'
09:15:21 <pejo> smitti12, use pattern matching. f Rectangle _ = something; f Triangle _ = somethingelse.
09:15:33 <phlpp> lol
09:15:34 <phlpp> evil
09:15:35 <phlpp> :>
09:15:39 <dons> so on line 54 and 56 there's eval, i guess.
09:15:39 <phlpp> thanks
09:15:46 <phlpp> ahaha, evil
09:15:47 <phlpp> :)
09:16:07 <dons> freudian typo eh?
09:16:13 <ari> @bot
09:16:14 <lambdabot> :)
09:16:14 <rahaskella> :)
09:16:19 <ari> rahaskella: @part #haskell
09:17:06 <fox86> what is the most common way to set constants in the top of my haskell-program?
09:17:35 <ari> fox86: constant = value?
09:17:36 <dons> fox86: foo = 1
09:17:37 <desegnis> name = value?
09:17:45 <dons> cool question though.
09:17:57 <desegnis> heh
09:18:09 <fox86> oh. how does haskell tell the difference between a function, variable and constant?
09:18:24 <dons> everything's a function
09:18:28 <doserj> there is no difference...
09:18:36 <dons> well, the type
09:18:37 <fox86> ah. nice
09:18:46 <dons> :t 1
09:18:52 <lambdabot> forall t. (Num t) => t
09:18:53 <dons> :t \_ -> 1
09:18:55 <lambdabot> forall t t1. (Num t1) => t -> t1
09:18:57 <dons> :t \_ _ _ _ -> 1
09:19:00 <lambdabot> forall t t1 t2 t3 t4. (Num t4) => t -> t1 -> t2 -> t3 -> t4
09:19:08 <fox86> i guess i should set a type for my constant then.
09:19:15 <dons> but they're all treated uniformly by the syntax
09:19:23 <dons> well, it can be inferred
09:19:32 <dons> it is good practice to declare types for top level things
09:19:53 <fox86> dons: what do you mean by top level?
09:21:47 <dons> values defined at the outermost scope of your program
09:22:13 <fox86> dons: aah
09:22:15 <byorgey> i.e. values which aren't inside a 'let' or 'where'
09:22:30 <fox86> oh, cool. that makes sense
09:22:41 <dons> fox86: do you have a good tutorial handy?
09:22:45 <dons> like 'yaht'?
09:22:55 <dons> or graham hutton's book, "programming in haskell"?
09:23:00 <dons> ?where yaht
09:23:00 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
09:23:11 <fox86> dons: i have read yaht up until the datatype section... then i found the wikibook which is great. i like learning by example.
09:23:31 <dons> cool
09:23:50 <fox86> i'm going something horribly stupid though. i have to write a feedforward ANN with backpropagation in 10 days and i'm doing it in haskell. and i don't know haskell
09:24:08 <fox86> but it's the only way i will have time to learn it
09:24:15 <dons> neural net?
09:24:25 <fox86> yes
09:24:26 <fasta> When I press C-c C-t and am on an identifier it shows the type; that's ok. But it also does it when I don't press C-c C-t.
09:24:35 <dons> you should be able to translate from standard algorithms
09:24:54 <dons> and maybe check the neural networks subsection of the wiki under 'applications and tools'
09:24:58 <dons> for related work
09:25:08 <fox86> dons: yep. i am trying. i hope i will be able to do it despite the fact that i know nothing about monads
09:25:09 <dons> do you have ghc installed?
09:25:14 <fox86> dons: yes
09:25:17 <fasta> fox86: unless you have significant experience in Haskell, indeed, that sounds like a recipe for disaster.
09:25:23 <ac> is there an efficient way to turn a list of "Array Int a"s to an "Array (Int,Int) a"?
09:25:42 <dons> well, a good coder might thrive in that environment.
09:25:57 <fasta> ac: you need to map over it. (that would be "no", I guess)
09:26:12 <fasta> Or rather fold
09:26:19 <pa-ching> Mmm, how can I write out some tree in my code with a minimum of clutter?
09:26:31 <dons> use the Data.Tree printing function?
09:26:38 <pa-ching> Er I mean
09:26:41 <dons> ah,
09:26:46 <pa-ching> I want to define a tree in my code
09:26:51 <TomMD> ajgill++
09:26:53 <pa-ching> Node = Value | Branch or something
09:27:03 <dons> right. binary tree or something else?
09:27:25 <pa-ching> N-ary I guess
09:27:34 <pa-ching> it's for config values
09:27:37 <dons> and where are the elements stored?
09:27:58 <pa-ching> I wrote something I hoped might work but I got a lot of complaints about types and things...
09:28:04 <glguy> dons: your addiction is interfering with your job ;)
09:28:05 <pa-ching> values stored in Value
09:28:13 <pa-ching> String | Int for now
09:28:14 <dons> glguy: my sore legs are too!
09:28:44 <glguy> dons: my leg just stopped hurting from when you tried to kick me into the goal
09:28:52 <doserj> fast: C-C C-t asks ghci for the type (so the module has to compile). without C-C C-t, it only works for a hardcoded list of functions
09:28:52 <dons> cool
09:28:54 <dons> glad that's better
09:29:01 <dons> i had to kick something
09:29:03 <doserj> *fasta: ^^
09:29:15 <pa-ching> sampleTree = [("a root node", [("some sub-node", "value"), ("another sub-node", 42)])]
09:29:22 <pa-ching> is the kind of thing I'd like to write
09:29:23 <fasta> doserj: it also shows the type _when_I_do_not_ask_for_it.
09:29:33 <pa-ching> if I can do it even less cluttered that'd be great
09:29:36 <dons> pa-ching: have a look at the definition in Data.Tree
09:29:45 <pa-ching> dons: Ok, thanks
09:29:47 <dons> ?docs Data.Tree
09:29:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
09:30:54 <doserj> fasta: then turn-off-haskell-doc-mode?
09:32:00 <fasta> doserj: but then C-c C-t doesn't work anymore.
09:33:18 <doserj> fasta: you can customize haskell-doc-show-*
09:33:37 <fasta> doserj: are you saying that this is default behaviour?
09:33:45 <doserj> yes
09:34:01 <fasta> doserj: ok, maybe I normally don't stay on an identifier that long.
09:34:05 <fasta> doserj: thanks
09:38:49 <quicksilver> lol @ SPJ
09:38:58 <quicksilver> "Good Idea : We already do that"
09:39:21 <quicksilver> someone should write up 'cool tricks used in the implementation of GHC'
09:40:46 * quicksilver suggests as much to the big man.
09:49:52 <pgavin> @seen dcoutts_
09:49:52 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts_ last spoke.
09:51:00 <phlpp> @src const
09:51:00 <lambdabot> const x _ = x
09:51:33 <fox86> hmm, in Perceptron.hs i have "data Node = ..." and in Main.hs, i try to use that type after doing "import qualified Perceptron" like this "bar :: Perceptron.Node". what's wrong with that?
09:52:21 <ddarius> What does it say is wrong?
09:52:52 <fox86>     No instance for (Num (t -> t1 -> Perceptron.Node))
09:53:11 <fox86> sorry, i should have pasted that right away
09:53:20 <quicksilver> well there is nothing wrong with your import :)
09:53:22 <ddarius> Then your problem is not namespace management.
09:53:33 <quicksilver> you are bracketing a numeric expresson wron
09:53:48 <andyjgill> Has anyone here experience with using QC2?
09:53:53 <quicksilver> f x*2 or something
09:53:58 <quicksilver> when you meant f (x*2)
09:54:51 <fox86> quicksilver: ouch. i know why. the type is Int -> Int -> Int.. i forgot that the last one is the return value
09:58:03 <nominolo> andyjgill, superficially
09:59:28 <thetallguy> is QC2 quickcheck2 == QuickCheckM?
09:59:32 <andyjgill> I'm trying to find out who is using it, to get help with a possible refactoring or enhancement
10:00:05 <nominolo> maybe bringert, i think he knows the code
10:00:15 <jedbrown> Setup.hs: zlib.cabal:13: 'Executable' stanza starting with field 'flag bytestring-in-base
10:00:15 <jedbrown> description'
10:00:18 <andyjgill> I've emailed him.
10:00:40 <jedbrown> I don't understand, but I don't know Cabal yet either.
10:00:51 <nominolo> jedbrown, your cabal is too old, i think
10:01:04 <nominolo> zlib needs Cabal >= 1.2 i think
10:01:16 <jedbrown> How do I check?
10:01:29 <nominolo> ghc-pkg list Cabal
10:01:30 <jedbrown> wait, 1.1.3
10:01:41 <jedbrown> thanks
10:01:58 <hpaste>  fox86 pasted "Not in scope?" at http://hpaste.org/3385
10:03:13 <ddarius> fox86: You didn't export the constructors.
10:03:57 <phlpp> @hoogle ReaderT
10:03:58 <lambdabot> Control.Monad.Reader.ReaderT :: r -> m a -> ReaderT r m a
10:03:58 <lambdabot> Control.Monad.Reader.ReaderT :: newtype ReaderT r m a
10:03:58 <lambdabot> Control.Monad.Reader.mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
10:04:15 <phlpp> err, odd
10:04:21 <fox86> ddarius: the constructor for Node?
10:05:57 <ddarius> fox86: Correct.
10:06:18 <byorgey> phlpp: what's odd?
10:06:26 <ddarius> fox86: You exported the type but not the constructors.  This is how Haskell supports abstract data types.
10:06:44 <fox86> ddarius: hmm, okay
10:07:05 <ddarius> fox86: If you want to export the data constructors as well you use the notation TypeConstructor(DataConstructor1,DataConstructor2) or usually TypeConstructor(..) to export all of them.
10:09:10 <fox86> ddarius: aha. it still says that it couldn't match expected type `Perceptron.Node'
10:09:11 <fox86>  though
10:09:38 <ac> is this valid: sequence_ $ map putStrLn listOfStrings -- ?
10:09:45 <byorgey> fox86: paste the code, maybe?
10:10:23 <byorgey> ac: should be.
10:10:25 <byorgey> @type sequence_ $ map putStrLn ["foo", "bar"]
10:10:28 <lambdabot> IO ()
10:10:49 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3386
10:11:02 <fox86> i put the error message as a comment behind the line it fails on
10:12:09 <byorgey> fox86: it says the paste has been deleted?
10:12:34 <fox86> byorgey: hmm? weird
10:12:55 <byorgey> try pasting it again?
10:12:58 <allbery_b> I think we currently don't like anonymous pastes
10:13:01 <allbery_b> or something
10:13:10 <allbery_b> ("we" = those who run hpaste)
10:13:13 <byorgey> ah, yes, anonymous pastes with no title
10:13:16 <byorgey> are usually spam
10:13:28 <hpaste>  fox86 pasted "(no title)" at http://hpaste.org/3387
10:14:07 <byorgey> fox86: you don't have enough 3's
10:14:14 <ddarius> It takes 4 Ints
10:14:16 <ddarius> Not 3
10:14:26 <abell> I have a web application codified as   MyState -> CgiRequest -> MyIOMonad ( Html, MyState ). Any hint on how to run it with FastCGI? It only seems to work with CGI (synonim for CGIT IO).
10:14:48 <allbery_b> so the actual type is Int -> Perceptron.Node
10:14:52 <fox86> ack. i keep mixing functions with datatypes where the functions specify what to return on the last type specifier
10:15:13 <allbery_b> it does take some getting used to
10:15:35 <allbery_b> but it's no worse than C's attempt at type-by-example :)
10:15:36 <ddarius> In my opinion, you are thinking about it wrong.
10:17:02 <fox86> me? what part of it
10:18:46 <ptolomy> I've been (mostly for my own amusement) trying to figure out how to write a library for a proprietary financial protocol in Haskell, and so far I'm not doing well compared to the existing C++ implementation. The C++ one is basically a class that you inherit with overloaded 'processMessage' methods, and each message is a subclass of 'Message' and contains a number of fields. The tricky part...
10:18:47 <ptolomy> ...for me is that there are many different messages in many versions, and the OO code represents them all in a "typesafe" convenient way that I'm not sure is easily expressible in haskell.
10:19:09 <ptolomy> I'd like to write a simplified version of what I'm trying to do, post it to the cafe, and see what the well-washed masses have to suggest, I think.
10:19:21 <bakert> frequency, from QuickCheck, lives inside the Gen monad.
10:19:36 <bakert> it takes a list of (probability, value) pairs
10:19:46 <bakert> but for some reason i have ended up with
10:20:14 <bakert> frequency [(1, return "value1"), (2, return "value2"), (90, return "value3")]
10:20:23 <bakert> how can i get those returns out of there?
10:20:41 <ddarius> fox86: In my opinion, you shouldn't be thinking "this is the return part and these are the argument parts of the type declaration", you should simply think the arrow points from inputs to outputs (emminently sensible) and combine that with right associativity and you're set.
10:20:42 <bakert> i have some weird inkling it might be to do with mapM but i don't know why, or what that is really
10:21:03 <byorgey> bakert: ...just delete them?  what do you mean, how do you get them out of there?
10:21:16 <bakert> byorgey: well they seem to be fundamental to my code working :)
10:21:22 <dylan> frequency $ map (second return) [(1, "value1")...]
10:21:31 <dylan> (second is from Control.Arrow)
10:21:32 <byorgey> bakert: oh, I see what you are asking.
10:22:38 <fox86> ddarius: arrow points from inputs to outputs? you mean that i should think about the last arrow in that fashion?
10:23:06 <allbery_b> remember, everything is a function.
10:23:06 <byorgey> fox86: no, all of them. =)
10:23:07 <ddarius> fox86: No.  Exactly the opposite.  I want you to think about it uniformly (they are all the same arrow).
10:23:14 <bakert> dylan: magic!  what did i actually do there? :)
10:23:23 <dylan> :t second
10:23:29 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
10:23:36 <byorgey> > second (+1) (1,1)
10:23:38 <lambdabot>  (1,2)
10:23:39 <allbery_b> a -> b -> c means a -> (b -> c), that is a function which takes an argument andreturns a function which takes an argument and produces a something
10:23:45 <ddarius> In Int -> Int -> Int, both of the ->s are treated exactly the same.
10:23:52 <fox86> ddarius, byorgey: i was afraid you would say something like that
10:23:54 <ddarius> There isn't some special handling for the "last arrow"
10:23:54 <dylan> > second tail ("foo", "bar")
10:23:56 <lambdabot>  ("foo","ar")
10:23:56 <byorgey> > map (second (+1)) [(1,1), (2,2), (3,3)]
10:23:58 <lambdabot>  [(1,2),(2,3),(3,4)]
10:23:58 <allbery_b> everything acts the same way
10:24:16 <allbery_b> once you get used to it, it's quite simple (and allows you to easily do some things you'
10:24:21 <bakert> dylan: i see.  handy.  are Arrows to do with pairs then?
10:24:26 <allbery_b> d never imagine in other languages)
10:24:55 <byorgey> bakert: not really. but some Arrow functions are useful for dealing with pairs.
10:25:26 <fox86> ddarius: i need some time to grok that
10:25:29 <byorgey> fox86: Int -> Int -> Int is a function which takes an Int and returns another function; the returned function has type Int -> Int.
10:25:36 <ddarius> The pair related stuff should be taken out of the Arrow type class and put into another class.
10:25:42 <conal> first & second are composable editors of nested pair structures.
10:26:33 <fox86> byorgey: that makes me think that a function only accepts one parameter at a time(?) and then sequentially(?) iterate through the parameters before it returns something?
10:27:00 <ddarius> fox86: All Haskell functions only take one parameter.
10:27:01 <byorgey> fox86: you're right that functions only accept one parameter at a time.  In fact, all functions in Haskell only take one parameter!
10:27:16 <ddarius> fox86: That said, how it's implemented is not your concern.
10:28:08 <fox86> haskell is really something else
10:28:19 <bakert> amen
10:28:21 <koxinga> hi
10:28:22 <byorgey> ?type  let foo x + y in foo
10:28:24 <Saizan_> > mapM (\(x,my) -> do y <- my; return (x,y)) [(1,return "1"),(2,return "2")] :: Maybe [(Int,String)] --backert
10:28:25 <lambdabot> parse error on input `in'
10:28:26 <lambdabot>  Just [(1,"1"),(2,"2")]
10:28:31 <byorgey> ?type  let foo = x + y in foo
10:28:33 <lambdabot> Not in scope: `x'
10:28:33 <lambdabot>  
10:28:33 <lambdabot> <interactive>:1:14: Not in scope: `y'
10:28:40 <byorgey> bah
10:28:48 <byorgey> must be time for lunch ={
10:29:03 <ricky_clarkson> :type (+)
10:29:23 <ricky_clarkson> ?type (+)
10:29:25 <lambdabot> forall a. (Num a) => a -> a -> a
10:29:41 <allbery_b> :t let foo = ?x + ?y in foo
10:29:43 <lambdabot> forall a. (Num a, ?y::a, ?x::a) => a
10:29:47 <allbery_b> mmm, hacks
10:29:57 <ricky_clarkson> What's ?x?
10:30:06 <allbery_b> implicit arguments
10:30:10 <koxinga> when I use something like  "list = [x+y|x<-[1..],y<-[1..]]", how can I add only elements not already on the list ?
10:30:22 <allbery_b> check the ghc manual
10:30:28 <ricky_clarkson> Hokay.
10:30:31 <byorgey> fox86: if I have a function called foo for which foo x y = x + y, I can just write "foo 6", which gives me a function which takes a single argument and adds 6 to it.
10:31:14 <byorgey> > let foo x y = x + y; add6 = foo 6 in add6 5
10:31:16 <lambdabot>  11
10:31:19 <allbery_b> basically it's a trick which allows you to declare a variable on the fly and have it passed to other functions in the same scope automatically
10:31:20 <ddarius> koxinga: I.e. produce no duplicates?  You could just nub the result (if that's what you meant)
10:31:40 <allbery_b> I think the ghc folks decided it was evil and confusing enough that it will be going away, but for now it's a convenient way to hack @type :)
10:31:58 <fox86> byorgey: oooh, nice. so "foo 5" becomes "5 + y"?
10:31:59 <hpaste>  ddvlad pasted "basic IO not working (exercise from Haskell wikibook)" at http://hpaste.org/3389
10:31:59 <koxinga> yes, but I have a lot of duplicates so the list is too big. I would like to avoid a nub at the end and do it before
10:32:23 <byorgey> fox86: actually, it becomes \y -> 5 + y, but essentially yes
10:32:30 <koxinga> even if it is more time consuming
10:32:46 <ddarius> koxinga: filtering them earlier would be better.
10:33:14 <ddarius> That said, in this particular case, the output would just be [1..] then.
10:33:27 <fox86> byorgey: very nice. now it makes more sense
10:33:36 <allbery_b> ddvlad: compare (>>) and (>>=)
10:34:21 <koxinga> ddarius:  the lists I use are not [1..], it is just a silly example because I don't know how to name this way to create a list
10:34:31 <ddvlad> allbery_b: thank you, I will look into it
10:34:34 <allbery_b> list comprehensions
10:34:47 <byorgey> fox86: and what ddarius mentioned about right associativity has to do with the way function types are parenthesized
10:35:00 <byorgey> fox86: in particular, Int -> Int -> Int is the same as Int -> (Int -> Int)
10:35:02 <ddarius> koxinga: Probably the most efficient thing is to not use list comprehensions and to carry around a set or some such type.
10:35:18 <byorgey> fox86: which makes it more clear what is going on: a function which takes an Int and returns a function.
10:35:32 <byorgey> ...which takes an Int and returns an Int.
10:35:35 <allbery_b> (since you're working wikibook examples, I'm tryng to guide you rather than just feed you the answer)
10:36:35 <koxinga> ddarius: oh, sets, that's a good idea, I always forget the standard libs are so rich ;)
10:36:54 <fox86> byorgey: i see. thanks a lot for explaining this
10:37:03 <byorgey> fox86: anytime. =)
10:47:11 <ac> @hoogle String -> Int
10:47:11 <lambdabot> No matches, try a more general search
10:48:42 <dcoutts> jedbrown: you're using too old a cabal, you need Cabal-1.2.x
10:48:52 <ac> is read typically used for parsing Ints?
10:48:56 <dcoutts> pgavin-away: pong
10:49:17 <dcoutts> ac: yes
10:49:26 <dcoutts> ac: or reads
10:49:34 <dcoutts> > reads "12"
10:49:36 <lambdabot>  [(12,"")]
10:49:45 <dcoutts> > reads "foo" :: Int
10:49:46 <lambdabot>  Couldn't match expected type `Int'
10:49:50 <dcoutts> erm
10:49:59 <dcoutts> > reads "foo" :: [(Int, String)]
10:50:00 <lambdabot>  []
10:50:10 <dcoutts> > reads "12foo" :: [(Int, String)]
10:50:11 <lambdabot>  [(12,"foo")]
10:50:16 <ac> what's the string in the snd of reads?
10:50:29 <ac> oh I see
10:50:34 <dcoutts> ac: the remainder of the input
10:51:25 <ac> > read "1,200" :: Int
10:51:27 <lambdabot>  Exception: Prelude.read: no parse
10:52:04 <ac> Just out of curiosity, is there a function that takes a localized human readable string?
10:54:33 <ac> also, is there a way to call main with command line arguments using ghci?
10:55:03 <dcoutts> ac: :set args -foo -bar
10:55:04 <mrd> :main
10:58:14 <bos> dons, dcoutts - i find myself having to carry my bit packing/unpacking code all over the place. any interest in centralising it in Binary?
10:58:42 <bos> the idea is to turn a bitfield into a list of constructors identifying each bit, and vice versa.
10:58:54 <dcoutts> bos: a bit layer over binary would be nice
10:58:55 <dons> possibly. or in a bit lib of its own?
10:59:17 <dcoutts> bos: or are you thinking of a more limited thing where you can only access small chunks of bits that align to byte boundaries?
10:59:33 <bos> i'm not thinking of something like bitlevel parsing.
10:59:34 <ac> @hoogle getArgs
10:59:38 <lambdabot> System.getArgs :: IO [String]
10:59:44 <dcoutts> bos: ie not the kind of thing where you can easily take 3 then 7 bits over and over
10:59:54 <bos> dcoutts: definitely not that.
11:00:14 <dcoutts> ok, so just reading bitfields that fit into standard word types
11:01:09 <bos> let me paste
11:01:27 <roconnor> anyone know how many bits each Bool takes in a UArray of Bools?
11:01:34 <oerjan> roconnor: 1
11:01:39 <roconnor> oooh
11:02:08 <allbery_b> yeh, that;s one of the ponts of specialized UArray instances
11:02:24 <hpaste>  bos pasted "simple bit twiddling" at http://hpaste.org/3390
11:02:36 <bos> dcoutts: the sort of thing i pasted above
11:02:51 <pgavin> dcoutts: I got your message about the compile error, I just been too busy to fix it yet
11:03:01 <pgavin> dcoutts: probably will this weekend though
11:04:03 <dcoutts> bos: I see
11:04:12 <dcoutts> pgavin: ok, cool
11:04:41 <pgavin> I'll email you a patch once I do :)
11:04:41 <bos> dcoutts: the idea being that it's somewhat nice to have a discriminated union instead of a pile of bits
11:05:05 <bos> it's not urgent, i just find myself having to replicate this code in different libraries, over and over.
11:08:31 <bakert> if i newtype Int can i use a value of that type as an Int later?
11:08:52 <birkenfeld> bakert: only if you "unpack" it again
11:08:54 <bos> bakert: you have to strip off the value constructor first
11:09:02 <bakert> hmm.
11:09:14 <bakert> thanks
11:09:22 <bos> the whole purpose behind newtype is to make it impossible to do what you want to do :)
11:09:26 <bakert> :)
11:09:36 <bakert> well i cleverly made it so that no value can go above 19.
11:09:42 <bakert> but now i want to add some values together
11:09:48 <birkenfeld> is it possible to say "I have two Data.Dynamics that are possibly instances of Num here, now perform (+) on them?"
11:09:53 <bakert> each individual value should not go above 19
11:10:00 <bakert> but when added they should
11:11:26 <bakert> perhaps capping them at 19 through "instance Num" was a bit tooo clever
11:18:18 <bakert> :t foldr
11:18:20 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:18:57 <bos> does Cabal irretrievably barf if i want multiple cabal files in one directory?
11:19:04 <bos> it sure seems to.
11:20:10 <ac> is it possible to have two functions with the same name but with different type signatures?
11:20:34 <mrd> in different modules
11:20:56 <dons> or with type classes
11:21:08 <ac> well, what I want are two functions that do essentially the same thing, but one takes a completely different type
11:21:31 <ac> and it would be nice if they had the same name
11:21:39 <mrd> typeclasses
11:22:06 <eyeris> Are the standard libraries browsable online?
11:22:14 <mrd> eyeris: haskell.org
11:22:28 <ac> Is that a reasonable thing to do even though the two types don't have any common operations other than this one function?
11:22:39 <mrd> ac: yes
11:23:18 <eyeris> mrd: I mean the implementations
11:23:20 <mrd> class Fooable a where foo :: ... general type sig using 'a' in place of the specific type ...
11:23:31 <mrd> eyeris: darcs repo of ghc?
11:23:38 <mrd> eyeris: the Prelude is in the Report
11:23:47 <Saizan_> ?docs
11:23:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:24:06 <Saizan_> modules have a source link in general ^^^^^
11:27:55 <nominolo> > (toDyn (+)) `dynApp` (toDyn (4 :: Int)) `dynApp` (toDyn (5 :: Int))
11:28:00 <lambdabot>  Exception: Type error in dynamic application.
11:28:00 <lambdabot> Can't apply function <<Integer...
11:28:32 <nominolo> > (toDyn ( (+) :: Int -> Int -> Int)) `dynApp` (toDyn (4 :: Int)) `dynApp` (toDyn (5 :: Int))
11:28:34 <lambdabot>  <<Int>>
11:28:47 <nominolo> > fromDyn 0 $ (toDyn ( (+) :: Int -> Int -> Int)) `dynApp` (toDyn (4 :: Int)) `dynApp` (toDyn (5 :: Int))
11:28:48 <lambdabot>   add an instance declaration for (Num Dynamic)
11:28:57 <nominolo> > fromDyn undefined $ (toDyn ( (+) :: Int -> Int -> Int)) `dynApp` (toDyn (4 :: Int)) `dynApp` (toDyn (5 :: Int))
11:28:59 <lambdabot>  Undefined
11:30:27 <Saizan_> ?type fromDyn
11:30:30 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
11:30:58 <Saizan_> > flip fromDyn undefined $ (toDyn ( (+) :: Int -> Int -> Int)) `dynApp` (toDyn (4 :: Int)) `dynApp` (toDyn (5 :: Int))
11:31:00 <lambdabot>  Undefined
11:31:03 <ac> mrd: how do I specify that a is either an Int or a String?
11:31:18 <mrd> ac: you write instances for Int and String
11:31:30 <mrd> instance Fooable Int where foo ... = ...
11:31:31 <ac> mrd: I see
11:32:40 <nominolo> > fromDynamic $ (toDyn ( (+) :: Int -> Int -> Int)) `dynApp` (toDyn (4 :: Int)) `dynApp` (toDyn (5 :: Int))
11:32:41 <lambdabot>  Nothing
11:33:09 <oerjan> ac: might want to check that there isn't already a typeclass containing the functions you need, or something you can build them from.  What are they?
11:33:12 <nominolo> > fromDynamic $ ((toDyn ( (+) :: Int -> Int -> Int)) `dynApp` (toDyn (4 :: Int)) )`dynApp` (toDyn (5 :: Int))
11:33:14 <lambdabot>  Nothing
11:36:31 <oerjan> :t dynApp
11:36:33 <lambdabot> Dynamic -> Dynamic -> Dynamic
11:36:47 <ac> oerjan: they're pretty specific. One type is a Int -> Int -> Colour, and the other type is Array (Int,Int) Colour (the function is pixbufDrawPixels for gtk2hs)
11:36:59 <Lemmih> > fromDynamic $ ((toDyn ( (+) :: Int -> Int -> Int)) `dynApp` (toDyn (4 :: Int)) )`dynApp` (toDyn (5 :: Int)) :: Maybe Int
11:37:01 <lambdabot>  Just 9
11:37:10 <phlpp> @hoogle documentation
11:37:11 <lambdabot> No matches found
11:37:19 <oerjan> oh
11:37:50 <phlpp> hmm, ok, seems like this was common lisp
11:37:51 <phlpp> :>
11:38:37 <oerjan> @where haddock
11:38:37 <lambdabot> http://www.haskell.org/haddock/
11:38:48 <mrd> @hoogle a -> a -> a
11:38:49 <lambdabot> Prelude.asTypeOf :: a -> a -> a
11:38:49 <lambdabot> Prelude.const :: a -> b -> a
11:38:49 <lambdabot> Prelude.seq :: a -> b -> b
11:40:58 <oerjan> phlpp: i suspect haddock is the closest haskell equivalent
11:41:32 <phlpp> oerjan: it's ok, i just thought there's something like documentation for lisp that i can use in repl
11:41:40 <phlpp> i mean it's not necessary
11:41:52 <phlpp> neccessary or sth. like that
11:42:05 <oerjan> that would have been nice
11:42:11 <phlpp> :>
11:42:39 <oerjan> in hugs, :f may sometimes work -- opens an editor at the source of a function
11:43:20 <phlpp> ok, i'm using ghc(i) :>
11:43:22 <oerjan> i guess in ghc it might depend on whether you actually _have_ the source
11:43:56 <mrd> :info will tell you where it is, if interpreted source.  haskell-mode uses that to find the source.
11:47:36 <dons> dcoutts: might be interesting to port one of these onto Data.Binary for the paper, http://lambda-the-ultimate.org/node/2496
11:47:37 <lambdabot> Title: binpac: A yacc for Writing Application Protocol Parsers | Lambda the Ultimate
11:51:06 <ac> what's the difference between "data" and "type"?
11:51:17 <ac> type makes aliases, and data makes constructors, right?
11:51:56 <phlpp> :t main
11:51:59 <lambdabot> Not in scope: `main'
11:52:02 <phlpp> hehe
11:52:03 <twanvl_> ac: yes
11:53:35 <pmatos> Hello all, I've been trying the very simple function of writing a list of elements to the screen. I wonder there is no foreach so that I can execute print on every element of the list... What's the best way to do this?
11:53:57 <ac> twanvl_: when can "data" be used when "type" can not?
11:54:19 <oerjan> :t forM_
11:54:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
11:54:32 <oerjan> pmatos: there is
11:54:38 <ac> twanvl_: I suppose type is useful if you're only using it in signatures, but data must be used if you want to store values
11:54:45 <twanvl_> When you have more than one constructor, or a constructor with more than one field.
11:55:23 <pmatos> oerjan: oh... ok, thanks! :-) that's a complicated type... heh
11:55:24 <twanvl_> Yes, 'type' is not used very much, it is just to make your code more readable
11:56:40 <pmatos> oerjan: what's the function name? it seems it is not forall or for or foreach... :-\ I'm trying forall print [1,2,3,4]
11:56:56 <oerjan> pmatos: forM_ as above
11:57:26 <oerjan> (you probably need to import Control.Monad)
11:57:38 <Shurique> hmm, forM_ looks like a flipped mapM_ to me
11:57:44 <oerjan> yes it is
11:57:46 <Shurique> oh :)
11:58:17 <pmatos> orbitz: I'm getting that forM_ is not in scope.
11:58:23 <oerjan> forM <-> mapM likewise
11:58:53 <oerjan> pmatos: you might want to read what i say, hmph
11:58:57 <pmatos> oerjan: Ah... :-)
11:58:59 <pmatos> sorry!
12:01:17 <oerjan> pmatos: also if you prefer print before the list there is mapM_ as Shurique noted
12:01:21 <bakert> :t (\x -> x t)
12:01:23 <lambdabot> Not in scope: `t'
12:02:10 <oerjan> :t (\x -> x ?t)
12:02:12 <lambdabot> forall t t1. (?t::t) => (t -> t1) -> t1
12:02:30 <pmatos> oerjan: What do you mean by "print before the list" ?
12:02:38 <bakert> oerjan: clever
12:02:55 <oerjan> pmatos: it's forM_ [1,2,3,4] print, but mapM_ print [1,2,3,4]
12:03:26 <pmatos> oerjan: oh, so it's just an exchange on arguments?
12:03:26 <bakert> What I'm after is a way of shortening (sum (map (\x -> x t) [a, b, c])) >= 50
12:03:45 <oerjan> yep
12:03:49 <bakert> i thought maybe (\x -> x t) had a name of some sort
12:04:03 <oerjan> bakert: ($ t)
12:04:10 <bakert> woah
12:04:21 <bakert> cunning
12:07:37 <bakert> do you use records?  a lot?
12:07:39 <pmatos> I'm trying to write a function that returns a list with numbers input by a user. The code is in:
12:07:40 <hpaste>  pmatos pasted "ask for list of numbers" at http://hpaste.org/3392
12:08:57 <oerjan> pmatos: need do after else
12:09:17 <oerjan> also $ after the last return
12:09:53 <pmatos> you mean return$
12:09:54 <pmatos> ?
12:09:59 <oerjan> right
12:10:08 <pmatos> is this another function?
12:10:14 <pmatos> why do I need return$?
12:10:19 <oerjan> no, return $
12:10:29 <fasta> Ok, I switched from IntMap to STArray... guess how much faster it goes...
12:10:30 <oerjan> because function application binds tighter than :
12:10:39 <phlpp> @type liftM
12:10:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:10:55 <fasta> (20 times)
12:11:46 <pmatos> oerjan: but what does $ do?
12:12:36 <oerjan> pmatos: it's just function application but with lower precedence so you can leave out parentheses
12:12:38 <pmatos> oerjan: would it be the same if I do return ((read number) : lstNumbers)
12:12:42 <oerjan> right
12:12:57 <pmatos> oerjan: ok
12:13:09 <oerjan> in fact you could leave out the parentheses around read number
12:13:57 <pmatos> great! :-)
12:14:17 <phlpp> :t rand
12:14:19 <lambdabot> Gen StdGen
12:14:39 <oerjan> @index rand
12:14:39 <lambdabot> Test.QuickCheck, Debug.QuickCheck
12:15:41 <fasta> Does anyone of you have tab completion of symbols in Emacs mode?
12:15:48 <fasta> (i.e. like ghci does)
12:16:00 <fasta> And if so, how?
12:16:22 <fasta> Er in Haskell Mode for emacs
12:16:56 <phlpp> at first, haskell-mode should learn how to indent do blocks right :D
12:18:29 <mrd> i just use M-/
12:18:44 <bakert> ?seen omnid
12:18:45 <lambdabot> I saw omnid leaving #haskell 10h 25m 26s ago, and .
12:18:53 <oerjan> @users
12:18:53 <lambdabot> Maximum users seen in #haskell: 420, currently: 403 (96.0%), active: 16 (4.0%)
12:18:54 <mrd> if you don't like the "smart" indentation's style, just use simple-indent mode
12:19:06 * mrd does that
12:19:06 <arcatan> huh...
12:19:41 <phlpp> mrd: do you meant me?
12:20:26 <mrd> anyone, really
12:20:29 <phlpp> why should this identation syle be smart? it fails indenting correctly when i'm writing do blocks
12:20:40 <mrd> are you hitting tab multiple times?
12:20:44 <phlpp> one time.
12:20:48 <mrd> try multiple
12:20:57 <phlpp> ah
12:20:57 <phlpp> :>
12:21:02 <phlpp> thanks
12:21:16 <mrd> indentation is ambiguous, obviously, because it carries meaning
12:21:17 <phlpp> and what's the difference to simple-indent mode?
12:21:33 <mrd> the haskell "smart" indent figures out all the "possible" places a line could go and cycles through them
12:21:51 <phlpp> yeah, that's "smart" actually
12:21:55 <mrd> "simple" indent doesn't do anything fancy, it just uses the default indent-line-function
12:22:23 <phlpp> ah ok
12:22:31 <quicksilver> I feel the intelligent intent could do slightly better actually
12:22:43 <quicksilver> get the order of possibilities with the more likely choices nearer the top
12:22:52 <quicksilver> but I'm not brave enough to dive into that code :)
12:23:23 <pmatos> How can I print a number without changing line?
12:23:42 <mrd> putStr (show n)
12:23:45 <quicksilver> putStr
12:23:49 <quicksilver> (no Ln for line)
12:24:11 <ac> what's this mean: "`pixbufDrawRegion' is not a (visible) method of class `PixbufDrawer'"?
12:24:14 <pmatos> (show n) is the inverse of read?
12:24:54 <bos> @seen dons
12:24:55 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 17m 50s ago.
12:25:19 <mrd> > show (read "1" :: Int)
12:25:27 <lambdabot>  "1"
12:25:42 <pmatos> mrd: ok, thanks! :-)
12:25:42 <oerjan> ac: are you trying to define it in an instance declaration?
12:25:47 <ac> oerjan: yeah
12:26:02 <oerjan> you need to declare its type in the corresponding class declaration
12:26:18 <ac> hm. thought I did
12:26:23 <bakert> When the pain of not being able to update a field of a record without referring to it twice literally gets to you, what kind of data structure do you use instead?
12:26:47 <oerjan> ac: on a hunch, check the capitalization :)
12:27:26 <phlpp> is there a tutorial providing some explanations how to work on files?
12:27:34 <ac> oerjan: indeed. pixbuf vs pixBuf
12:27:43 <phlpp> or do i have to figure out this for my self (which wouldn't be that difficult, i think)
12:28:17 <oerjan> bakert: you write a modifyField function, i think
12:28:37 <bakert> i was trying that yesterday with functional references
12:28:54 <bakert> but i seem to have got a long way off the beaten track in order to be able to say
12:29:00 <bakert> update fieldName record
12:29:01 <mrd> phlpp: most of the tuts should cover that
12:29:07 <mrd> phlpp: any one in particular you are using?
12:29:07 <bakert> or even
12:29:12 <bakert> update fieldName (+3) record
12:29:20 <ac> now I see a much more interesting error: "Illegal instance declaration for `PixbufDrawer (Int -> Int -> Colour) (The instance type must be of form (T a b c)"
12:29:46 <bakert> oerjan: any idea what modifyField looks like without using template haskell, or is that not possible?
12:29:59 <oerjan> ac: you need to enable extensions, e.g. with -fglasgow-exts
12:30:16 <mrd> phlpp: it is easy though, you could prob figure it otu from the docs of System.IO
12:30:23 <oerjan> haskell 98 is rather limited these days
12:30:38 <oerjan> bakert: i meant Field to be replaced by the field name
12:30:46 <bakert> oh :(
12:30:47 <ac> oerjan: thanks. that would've taken me forever to narrow down
12:32:06 * bos misses erlang's bit syntax
12:32:06 <phlpp> @where haddock
12:32:07 <lambdabot> http://www.haskell.org/haddock/
12:32:14 <oerjan> bakert: i guess some kind of functional references is the best you can get.  there really should have been some syntax to "reify" a field name
12:32:55 <bakert> oerjan: what do you use in your programs if you have fifteen related bits of data but you can't bear writing lots of boilerplate nonsense?  or do you just suck it up and write updateField fifteen times?
12:33:08 <ac> oerjan: is there any reason not to alias ghci to ghci -fglasgow-exts?
12:33:22 <fox86> if i have "foo :: Int" and "foo = 3".. i suppose i can't ever change the value of foo? so if i have made a data structure, say a linked list, how can i update the values in it?
12:33:38 <mrd> you mean a [1,2,3] linked list?
12:33:38 <ac> fox86: you make a new linked list
12:33:51 <ac> fox86: and lists == linked lists in Haskell AFAIU
12:33:58 <oerjan> ac: i don't know :)
12:34:00 <fox86> ah, okay
12:34:09 <puusorsa> stupid question time .. if i have: data Tree a = Empty | Node a (Tree a) (Tree a) .. what's the right way to build that kinda tree from a list?
12:34:12 <oerjan> aliases don't affect scripts do they?
12:34:25 <ac> fox86: it might seem inefficient, but don't worry about it. Haskell is obviously designed to work like that
12:34:43 <oerjan> bakert: i don't know to you either :(
12:34:50 <bakert> drat.
12:34:51 <fox86> ac: oh. do i have to "free" the old list to clear the memory?
12:35:00 <ac> fox86: nope
12:35:15 <byorgey> fox86: that gets done automatically by the garbage collector.
12:35:33 <puusorsa> + so that the resulting tree is balanced
12:35:40 <fox86> ah, okay. how does it know when to free it?
12:35:51 <ac> fox86: there are certain cases where you have to worry about constructing new data structures repeatedly, like for example when you frequently want to modify single elements of an array. In this case, you would use the DifArray class
12:35:52 <byorgey> fox86: in fact, if you're lucky, the "new" list might end up sharing some of the contents of the "old" list.
12:36:02 <byorgey> fox86: magic!
12:36:14 <bakert> i think ruby has spoiled me with metaprogramming.  if i want the same function with 15 different names i expect to be able to do it with one or two lines of code.
12:36:14 <byorgey> fox86: just kidding, of course =)
12:36:20 <phlpp> mrd: oh, thats really great
12:36:22 <fox86> byorgey: heheheh
12:36:32 <phlpp> like the implementation stuff (e.g. IO.hs) is documented
12:36:36 <byorgey> fox86: it can tell if a value is no longer referenced by anything currently in memory
12:36:45 <byorgey> (essentially)
12:36:51 <fox86> byorgey: aah
12:37:33 <ac> er, DiffArray
12:38:03 <fox86> byorgey: i have to make a data structure like this, only it might have several layers of the blue between the green and purple, http://en.wikipedia.org/wiki/Image:Neural_network_example.png .. can i find some examples of such structures anywhere? i need to update nodes in that list, so that's why i was wondering how it works
12:38:04 <lambdabot> Title: Image:Neural network example.png - Wikipedia, the free encyclopedia
12:38:45 <ac> fox86: check out Data.Graph
12:38:56 <fox86> ac: okay, thank you
12:39:15 <byorgey> fox86: will every node in each layer always connect to all the nodes in the next?
12:39:29 <ac> fox86: or you could use a DiffArray that holds an adjacency matrix, though that may be how Data.Graph works anyway (I'm not sure)
12:39:31 <phlpp> :t file <- readFile "foobar.foo"
12:39:34 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
12:39:34 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
12:39:34 <lambdabot>  
12:39:34 <byorgey> fox86: because if that's the case, you don't need to explicitly encode that fact in your data structure.
12:39:39 <fox86> byorgey: yes. and i think i must be able to go both ways
12:39:55 <phlpp> eh
12:39:58 <phlpp> :>
12:40:14 <byorgey> phlpp: try again, now that it's loaded those...
12:40:22 <phlpp> :t file <- readFile "foobar.foo"
12:40:24 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
12:40:24 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
12:40:24 <lambdabot>  
12:40:29 <phlpp> hm? :>
12:40:35 <byorgey> hm, that's weird... LB bug, I guess
12:40:42 <phlpp> maybe i just ask which type file has when appling readFile to it
12:40:50 <phlpp> ah
12:40:52 <phlpp> IO String perhaps
12:41:11 <byorgey> fox86: then I think you just need a list of Nodes for each layer
12:41:26 <ac> fox86: I guess if you have the constraint that each layer only connects to the adjacent layers, an adjacency matrix would be far from efficient
12:41:31 <desegnis> phlpp, readFile "foo" :: IO String; file :: String
12:41:41 <byorgey> each Node takes a list of Signals (or whatever) as input, and you'll know where they're coming from because they'll always be in the same order.
12:42:43 <fox86> byorgey: hmm, yes
12:42:44 <phlpp> desegnis: hmm, what would file <- readFile "foo" be converted to syntax using bind?
12:42:55 <phlpp> s/be/look like
12:43:07 <byorgey> fox86: and yes, updating the nodes is as simple as producing a new list of updated notes for each layer.
12:43:12 <fox86> byorgey: so you suggest a list of nodes for each layer (color in the pic)
12:43:32 <desegnis> phlpp, readFile "foo" >>= \file -> rest_of_the_do_block
12:43:33 <byorgey> fox86: right.
12:44:10 <fox86> byorgey: okay, thanks. btw, where do i go if i want to read about e.g. Data.Graph? i think i used zvon.org or something in the past?
12:44:14 <byorgey> fox86: and then the whole thing can be represented by a list of layers.
12:44:33 <byorgey> @hoogle Data.Graph
12:44:34 <lambdabot> No matches, try a more general search
12:44:39 <byorgey> @hoogle Graph
12:44:39 <lambdabot> Data.Graph :: module
12:44:39 <lambdabot> Data.Graph.Inductive.Graph :: module
12:44:39 <lambdabot> Data.Graph.Graph :: type Graph
12:44:48 <phlpp> :t (>>=)
12:44:49 <byorgey> oh, that doesn't help
12:44:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:45:01 <mrd> @where docs
12:45:01 <lambdabot> I know nothing about docs.
12:45:04 <mrd> @where doc
12:45:04 <lambdabot> I know nothing about doc.
12:45:06 <phlpp> ah, so string is m Char
12:45:10 <phlpp> and thats [Char]
12:45:13 <fox86> ah, hoogle. great
12:45:13 * mrd kicks lambdabot 
12:45:21 <mrd> fox86: haskell.org
12:45:29 <fox86> mrd: thanks, i found hoogle now
12:46:00 <byorgey> fox86: in general, find the library documentation online.
12:46:11 <desegnis> phlpp, in the readFile "foo" case, it's (>>=) :: IO String -> (String -> IO bla) -> IO bla
12:46:19 <byorgey> fox86: and yes, I think Data.Graph is overkill for your application =)
12:46:50 <fox86> byorgey: okay. i will try your approach with lists. i bet i will learn a lot about lists and datatypes doing it
12:47:21 <phlpp> desegnis: but you said file is of type String?
12:47:33 <byorgey> fox86: yup.  Have fun. =)
12:47:51 <phlpp> i mean, there is no "rest of the do block", that's why i asked how to convert this
12:48:13 <bakert> Is there a good intro to template haskell?
12:48:23 <desegnis> phlpp, what do you mean, there is no rest of the do block? The do expression would be illegal then
12:48:47 <phlpp> ah ok, the rest is return () probably
12:48:49 <phlpp> :>
12:49:03 <phlpp> you're right, sorry
12:49:26 <desegnis> phlpp: So I can refine the type to: IO String -> (String -> IO ()) -> IO ()
12:49:44 <bakert> ?google template haskell tutorial
12:49:46 <lambdabot> http://haskell.org/haskellwiki/Template_Haskell
12:49:46 <lambdabot> Title: Template Haskell - HaskellWiki
12:49:47 <desegnis> phlpp: but of course that's weird, because we throw the string away
12:50:43 <phlpp> desegnis: yeah, it is. but from the more general/more precise definition i can't "tell" what type file has?
12:50:55 <fox86> byorgey: thanks a lot, again!
12:50:56 <byorgey> bakert: I was just going to suggest looking on the wiki =)
12:50:59 <phlpp> err, i mean general definition of >>=
12:51:03 <byorgey> fox86: you're welcome =)
12:51:20 <bakert> byorgey: there's a link to a tutorial on there but the link is broken
12:51:26 <byorgey> hrm
12:51:37 <bakert> http://www.haskell.org/hawiki/TemplateHaskellTutorial
12:52:04 <byorgey> ah, yes, it was on the old wiki
12:52:09 <byorgey> which Is No More
12:52:10 <bakert> i will try "Bulat's tutorials" ...
12:52:28 <phlpp> so (>>=) :: m a -> (a -> m b) -> m b and the snippet readFile "foo" >>= \file -> return () can't tell me anything about the type of file, can it?
12:53:19 <byorgey> bakert: yes, that's the other thing I was going to suggest but couldn't find it.  Also, believe it or not, the original paper on TH is quite readable and features a tutorial of sorts.
12:53:32 <byorgey> http://research.microsoft.com/~simonpj/papers/meta-haskell/
12:53:33 <lambdabot> Title: Template metaprogramming for Haskell
12:53:35 <bakert> hmm Bulat knows a lot more about haskell than i do :)
12:53:38 <bakert> i will try the paper
12:53:43 <desegnis> phlpp: if you know that readFile "foo" :: IO String, then you know that file :: String. I just substituted âaâ (in the general type of (>>=) with âStringâ. But maybe you're a little confused because of the lambda abstraction that I threw in deliberately.
12:53:49 <bakert> spj has served me well in the past in the readability stakes
12:53:53 <byorgey> bakert: just skip the first couple sections
12:54:35 <desegnis> phlpp: I can put parentheses, like this:
12:54:51 <phlpp> desegnis: i think although i learned much stuff (actually much for me) about monads, i didn't know the type of file at file <- readFile "foo"
12:55:01 <desegnis> phlpp: (readFile "foo") >>= (\file -> return ())
12:55:03 <phlpp> it seems like i'm confused about IO String
12:55:27 <byorgey> IO String represents a computation which, when run, results in a String.
12:55:40 <byorgey> at least that's usually a helpful way to think about it.
12:55:47 <desegnis> phlpp: Let's try to go through this mechanically. (>>=) takes 2 arguments, the first being (readFile "foo"), the second being (\file -> return ())
12:55:59 <byorgey> >>= takes the result of the computation on the left, and sends it into the function on the right.
12:56:10 <bakert> maybe template haskell is not what i want.  i just want to generate some identical functions by supplying the names.
12:56:36 <byorgey> bakert: sounds like a perfect use for TH.
12:56:43 <bakert> oh.  ok!
12:56:53 <desegnis> phlpp: The first argument is of type m a, more specifically: IO String. Thus we know, if we compare the general type of (>>=) and the type of (readFile "foo"), that m is IO and that a is String
12:57:16 <desegnis> phlpp: catching up?
12:57:22 <phlpp> ah
12:57:24 <phlpp> got it!
12:58:07 <desegnis> phlpp: So, the second argument is a function that takes a String. That's why file :: String, because it is the argument to this function.
12:58:11 <desegnis> Fine
12:58:22 <phlpp> yup, ok, got it
12:58:28 <phlpp> thanks
12:58:50 <phlpp> so i have got the whole file in a single String
12:59:14 <byorgey> phlpp: yup, which is less crazy than it sounds due to laziness. =)
12:59:16 <desegnis> right
12:59:48 <shapr> @arr
12:59:48 <lambdabot> Smartly me lass
13:01:19 <phlpp> hm, ok, i'll describe my aim/"task" for this evening/night: i want to write a function, which reads in a file and one argument passed to this function is a string. now i want to lookup that string in the file (by using isInfixOf) and return a specific line containing the string passed to the function
13:01:30 <Saizan_> byorgey: and more crazy for the same reason :)
13:01:46 <phlpp> but, as i see, it would be easier to just collect all the lines which contain the String and put them into a list
13:02:10 <byorgey> Saizan_: shh!  That's next week's lesson.
13:02:24 <phlpp> and then i thought of something like generate a random value between 0 and length of this list
13:02:32 <phlpp> and then access a string by !! with this random value
13:03:09 <phlpp> so it would be perhaps better to read the file line by line
13:03:17 <phlpp> and each line is stored as a String in a list
13:03:27 <phlpp> then i just map isInfixOf on that list
13:03:29 <byorgey> @type lines
13:03:31 <lambdabot> String -> [String]
13:03:35 <byorgey> phlpp: ^^
13:03:40 <byorgey> =)
13:03:49 <phlpp> am i thinking wrong?
13:04:02 <byorgey> phlpp: go look up what that function does.
13:04:08 <phlpp> i just thought reading the whole file in one string is a bit messy
13:04:12 <phlpp> ok
13:04:15 <desegnis> phlpp: I propose that you first write the function that looks for the interesting lines, and then another function that chooses an element randomly off a list
13:04:41 <phlpp> sounds good
13:04:47 <byorgey> right, the beauty of lazy evaluation is that it lets you break something like this up into separate concerns.
13:05:12 <byorgey> phlpp: the reason reading the entire file into a single String isn't as crazy as it sounds is that the file is actually read lazily, bit-by-bit, as it is needed.
13:05:28 <byorgey> it doesn't just scarf the whole file into memory all at once (as you would expect with a strict language).
13:05:37 <phlpp> hm
13:05:39 <oerjan> there is even a way to select a random line lazily, without keeping all the matching lines in memory
13:05:49 <desegnis> byorgey: readFile may actually do some buffering, if it is sane
13:06:12 <oerjan> (simultaneously)
13:06:21 <byorgey> desegnis: oh, oops, I was using "bit" to mean "some", not in the technical sense of "a one or zero" =)
13:06:33 <desegnis> byorgey: oh, right :)
13:06:45 <phlpp> byorgey: hm, okay, that lazy evaluation on the string confused me a bit. so you mean by using lines on my file, all lines are splitted, each into a string in a [String]?
13:07:07 <phlpp> ah
13:07:08 <byorgey> phlpp: right.
13:07:17 <phlpp> > lines "Foobar\nFoobar"
13:07:19 <lambdabot>  ["Foobar","Foobar"]
13:07:21 <phlpp> \o/
13:08:46 <byorgey> > filter (isPrefixOf "foo") . lines $ "foobar\nfooquux\nbarfoo\nfoofoo\nbarbar"
13:08:47 <lambdabot>  ["foobar","fooquux","foofoo"]
13:09:01 <byorgey> I'm sure you can see where this is going =)
13:09:11 <ac> what's a concise way to turn a list foo in to a list of every nth element of foo?
13:09:17 <phlpp> yup
13:09:22 <phlpp> really cool :>
13:10:21 <oerjan> ac: example?
13:10:34 <desegnis> :t \n -> map head . takeWhile (not.null) . iterate (drop n)
13:10:36 <lambdabot> forall a. Int -> [a] -> [a]
13:11:13 <desegnis> hm, although this will always include the first element of the list...
13:11:27 <oerjan> desegnis: you could add a drop on the end
13:11:42 <ac> first element is fine
13:11:56 <ac> ah map head, clever
13:11:57 <byorgey> > map snd . filter ((==0) . (`mod` 6) . fst) . zipWith [1..] $ cycle ["how", "about", "this", "way", "?"]
13:11:58 <lambdabot>  Couldn't match expected type `a -> b -> c'
13:12:00 <ac> I should have thought of that
13:12:06 <byorgey> hmm
13:12:35 <phlpp> aww
13:12:38 <byorgey> > map snd . filter ((==0) . (`mod` 6) . fst) . zipWith [1..] $ [5..]
13:12:39 <lambdabot>  Couldn't match expected type `a -> b -> c'
13:12:43 <phlpp> seems like my implementation in haskell has to wait
13:12:55 <byorgey> > map snd . filter ((==0) . (`mod` 6) . fst) . zip [1..] $ [5..]
13:12:56 <lambdabot>  [10,16,22,28,34,40,46,52,58,64,70,76,82,88,94,100,106,112,118,124,130,136,14...
13:13:10 <byorgey> phlpp: ?
13:13:42 <desegnis> :t \n -> map head . takeWhile (not.null) . iterate (drop n) . drop (n-1) -- This should start with the nth element
13:13:44 <lambdabot> forall a. Int -> [a] -> [a]
13:13:45 <phlpp> byorgey: i'm preparing the input file for my function
13:13:52 <ac> hmmm, I don't think that's an intelligent way to solve my problem... it works but it's not efficient in combination with list comprehension
13:13:54 <phlpp> i just thought it would be a task which takes 2 minutes
13:14:28 <ac> I will simply constrain my list comprehension intelligently
13:14:31 <phlpp> but actually it's more editing, because the formatting type changes in the file
13:14:36 <phlpp> and that really sucks
13:14:42 <byorgey> phlpp: oh, that's too bad =(
13:16:19 <phlpp> i mean
13:16:25 <phlpp> that's 4 megabytes full of plain text
13:16:26 <phlpp> ._.
13:16:59 <phlpp> ok, seems like formatting didn't changed to much
13:17:02 <phlpp> +o
13:17:31 <frest> Hi, Im having problems with IO, can someone help me, please? I have two functions, getFile reads a file and returns String, getPre manipulates a String
13:17:50 <frest> I can use getFile and then use "getPre it"
13:18:04 <frest> but I cant use getPre (getFile "filepath")
13:18:27 <desegnis> frest, wild guess: getPre `fmap` getFile "filepath"
13:18:28 <quicksilver> getPre =<< (getFile "filepath")
13:18:29 <quicksilver> perhaps
13:18:37 <quicksilver> it depends on the types involved
13:18:42 <frest> I get this error, Couldn't match expected type `String' against inferred type `IO String'
13:18:44 <quicksilver> culd be `fmap` instead of =<<
13:18:45 <ac> is there a quicker way of saying [foo x1 x2 x3 x4 ... | x1 <- [0..n], x2 <- [0..n], x3 <- [0..n] ....]?
13:18:59 <olsner> liftM4?
13:19:05 <oerjan> ac: replicateM
13:19:19 <oerjan> er, maybe not
13:19:46 <olsner> > liftM3 (,,) [1..3] [4..6] [7..9]
13:19:48 <lambdabot>  [(1,4,7),(1,4,8),(1,4,9),(1,5,7),(1,5,8),(1,5,9),(1,6,7),(1,6,8),(1,6,9),(2,...
13:20:12 <oerjan> > (join.join.join) (,,) [0..2]
13:20:12 <lambdabot>  Couldn't match expected type `(->) a'
13:20:19 <oerjan> > (join.join) (,,) [0..2]
13:20:20 <lambdabot>  ([0,1,2],[0,1,2],[0,1,2])
13:20:27 <ac> oerjan: ah that works
13:20:59 <oerjan> hm, not quite
13:21:01 <ac> I think...
13:21:07 <ac> yeah, it should be [(...), (...)}
13:21:33 <Saizan_>  > (join.join) (liftM3 (,,)) [0..2]
13:21:43 <Saizan_> > (join.join) (liftM3 (,,)) [0..2]
13:21:45 <lambdabot>  [(0,0,0),(0,0,1),(0,0,2),(0,1,0),(0,1,1),(0,1,2),(0,2,0),(0,2,1),(0,2,2),(1,...
13:21:55 <oerjan> ah
13:21:55 <ac> where's the monad?
13:22:13 <olsner> that involves both -> and [], right?
13:22:15 <oerjan> half -> and half []
13:22:21 <ac> I assume that using liftM3 implies a monad is involved
13:22:22 <Saizan_> list monad for liftM3 and -> for join.join
13:22:29 <balodja> ac: '(->) r' is a monad
13:22:39 <olsner> :t join.join.liftM3
13:22:41 <lambdabot> forall a3 r (m :: * -> *). (Monad m) => (a3 -> a3 -> a3 -> r) -> m a3 -> m r
13:22:56 <olsner> :t join.join
13:22:58 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
13:23:07 <ac> > (join.join.liftM3) (,,) [0..3]
13:23:09 <lambdabot>  [(0,0,0),(0,0,1),(0,0,2),(0,0,3),(0,1,0),(0,1,1),(0,1,2),(0,1,3),(0,2,0),(0,...
13:23:16 <ac> neat
13:24:28 <ac> @hoogle join
13:24:29 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
13:24:29 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
13:24:29 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
13:24:35 <olsner> @src (->) join
13:24:35 <lambdabot> Source not found. My pet ferret can type better than you!
13:24:42 <olsner> @src join
13:24:42 <lambdabot> join x =  x >>= id
13:24:58 <olsner> :t liftM3 >>= id >>= id
13:25:01 <lambdabot>     Occurs check: cannot construct the infinite type:
13:25:01 <lambdabot>       a2 = a2 -> a3 -> r
13:25:10 <olsner> :t (liftM3 >>= id) >>= id
13:25:12 <lambdabot>     Occurs check: cannot construct the infinite type:
13:25:13 <lambdabot>       a2 = a2 -> a3 -> r
13:25:59 <byorgey> :t liftM3 (,,) >>= id >>= id
13:26:01 <lambdabot> forall a3 (m :: * -> *). (Monad m) => m a3 -> m (a3, a3, a3)
13:26:22 <olsner> "obviously"
13:26:36 <sioraiocht> GAH
13:26:47 <Saizan_> ?pl \f -> liftM3 f >>= id >>= id
13:26:47 <lambdabot> join . join . liftM3
13:26:47 <sioraiocht> how do I install ghc on os x? i forgot! i compiled and installed readline
13:26:54 <sioraiocht> and the binaries STILL won't work
13:29:13 <olsner> sudo port install ghc & (sleep 7200; echo done)
13:29:16 <sioraiocht> anyone? :(
13:29:30 <olsner> :P
13:31:02 <sioraiocht> yeah, mac ports and I had that fight a while ago
13:31:13 <sioraiocht> i installed the staic readline library
13:31:16 <sioraiocht> is that not good enough?
13:32:00 <olsner> if the ghc is binary, you'll need the dynamic library
13:32:20 <sioraiocht> gah
13:32:23 <sioraiocht> where can i get that?
13:32:32 <olsner> static libraries can only be used when compiling from source
13:32:49 <olsner> (but are you sure that you only have the static readline library?)
13:32:51 <sioraiocht> any idea where i can get said library?
13:36:08 <ac> yay, my first use of type classes...
13:36:11 <hpaste>  ac pasted "Gdk support with type classes!" at http://hpaste.org/3393
13:36:12 <hpaste>  ac pasted "Gdk support with type classes!" at http://hpaste.org/3394
13:36:24 <ac> (how did I do that twice?)
13:37:08 <ac> those were adapted from FastDraw.hs from gtk2h's example programs
13:37:31 <alexj> @seen lemmih
13:37:31 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 2h 32s ago.
13:39:37 <oerjan> @users
13:39:37 <lambdabot> Maximum users seen in #haskell: 420, currently: 404 (96.2%), active: 19 (4.7%)
13:41:58 <sioraiocht> do i have to restart to use a dll?
13:42:04 <sioraiocht> err
13:42:16 <sioraiocht> dynamically linked library..in osx, not windows ;)
13:45:30 <sioraiocht> *sigh*
13:45:33 <sioraiocht> the library is loaded
13:45:35 <sioraiocht> honest
13:45:56 <pejo> sioraiocht, you shouldn't need to restart to use dynamic libraries.
13:46:02 <sioraiocht> kk
13:46:18 <sioraiocht> dynamic == shared?
13:46:33 * sioraiocht is revealing is unix naÃ¯vetÃ©
13:47:46 <pejo> sioraiocht, if you have macports to get readline - why not install ghc from there too?
13:47:58 <sioraiocht> pejo: I don't I compiled it myself
13:48:04 <sioraiocht> from the GNUreadline website
13:48:50 <frest> Hi, Im having a problem with my pattern matching
13:49:04 <frest> seems I try to grep a Char when I want a String
13:49:06 <frest> like this
13:49:09 <frest> getPre ('<':'p':'r':'e':'>':s:'<':'/':'p':'r':'e':'>':s1) = lines s
13:49:28 <frest> s and s1 are Strings, or at least thatÂ´s what I want
13:51:52 <oerjan> right, ordinary pattern matching cannot do that
13:54:07 <oerjan> regexes might be better for this, or Parsec
13:54:42 <frest> oh
13:57:16 <oerjan> in Parsec, using something like string "<pre>" >> manyTill anyChar (try $ string "</pre>")
14:04:59 <alexstr> who
14:05:43 <oerjan> i deny everything!
14:06:18 <balodja> even that you deny anything?
14:06:27 <oerjan> especially that!
14:10:35 <oerjan> @users
14:10:35 <lambdabot> Maximum users seen in #haskell: 420, currently: 398 (94.8%), active: 14 (3.5%)
14:10:45 <oerjan> aww
14:11:13 <phlpp> hm
14:11:17 <phlpp> byorgey: hi ;-)
14:11:22 <byorgey> hi phlpp =)
14:11:23 <phlpp> finished hacking on that textfile
14:11:28 <phlpp> it even compressed to 1.7mb :>
14:11:28 <byorgey> excellent
14:12:10 <phlpp> ok, now i want to write at first function lookUp. i think lookUp should have type :: [String], because anytime it's the same file so i don't need to supply any arguments which determine the filename or sth. like that
14:12:42 <dibblego> phlpp, a function with type [String] is constant
14:12:58 <phlpp> ah
14:12:58 <phlpp> ok
14:12:59 <phlpp> i see
14:13:03 <phlpp> IO [String] then
14:13:06 <byorgey> phlpp: if I understand what you mean, I think it would have type IO [String].
14:13:08 <byorgey> right.
14:13:33 <phlpp> err, type must be lookUp :: String -> IO [String]
14:13:36 <byorgey> phlpp: but you might as well make it String -> IO [String] (i.e. give it a filename as an argument).  it wouldn't be any harder and it might come in useful later. =)
14:13:37 <phlpp> because i want to lookUp a string
14:13:41 <phlpp> :D
14:13:50 <byorgey> oh, then String -> String -> IO [String]
14:15:42 <Modius> Haskelleers - is there a term for what you're doing with [a, b, c : rest] ?  (Doing up a lazy CL library and don't have a good function name for this)
14:16:30 <dmwit> Modius: take 3?
14:16:31 <balodja> do you mean cons and nil? :)
14:16:31 <phlpp> byorgey: ok, now i do something like: lookUp filename s = do file <- readFile filename
14:16:35 <alexstr> @help
14:16:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:16:39 <dmwit> > take 3 [5,6,10,12]
14:16:41 <lambdabot>  [5,6,10]
14:16:42 <phlpp> but what next? let db = lines file?
14:16:57 <byorgey> phlpp: sure.
14:17:00 <Modius> Sorry. . . .  I mean a good name for a function that allows a person to specify/construct a list in terms of a bunch of elements + the tail of it
14:17:32 <Modius> Actually, the haskell for it would be (I think)  a : b : c : rest  - imagine a cl function (funcname a b c rest) that returns a list.
14:17:50 <oerjan> Modius: concat (haskell ++)
14:18:04 <dmwit> Modius: I'm confused.  Why would you need a function for that?
14:18:05 <oerjan> hm, not exactly
14:18:42 <byorgey> phlpp: have fun, I'm off to call my grandmother (it's her birthday =)
14:18:45 <quicksilver> Modius: that's normaly called cons? :)
14:18:47 <Modius> I'm writing (really, have written) a lazy-list library for lisp.  I have a function called chained/    (chained/ a b c rest-of-list) builds list a : b : c : rest-of-list - I want a better name
14:19:07 <Modius> I was wondering if you had a good name for it.
14:19:17 <dmwit> Maybe prepend.
14:19:26 <dmwit> Though I find it a bit odd that you do three at a time.
14:19:27 <balodja> That's very specific :)
14:19:28 <mrd> lisp calls it list*
14:19:28 <Modius> (Cons or something based on cons, or extending a cons function to use all its inputs may be a good choice, as quicksilver mentioned)
14:19:34 <phlpp> hm
14:19:34 <byorgey> prepend3?
14:19:44 <Modius> dmwit:  Variable arg count so it doesn't have to be 3, it can be N
14:19:58 <dmwit> Ah.  prepend or cons, then.
14:20:01 <phlpp> > filter (`isInfixOf` "Foobar") ["Foobar", "Foobar barfoo", "Fubar"]
14:20:03 <lambdabot>  ["Foobar"]
14:20:05 <phlpp> oh
14:20:16 <Modius> mrd:  Thanks, I didn't know that there was a list*
14:20:20 <phlpp> not what i expected
14:20:23 <dmwit> :t isInfixOf
14:20:25 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
14:20:29 <oerjan> phlpp: wrong order, i think
14:20:34 <phlpp> yup
14:20:34 <phlpp> :D
14:20:43 <phlpp> > filter ("Foobar" `isInfixOf`) ["Foobar", "Foobar barfoo", "Fubar"]
14:20:45 <lambdabot>  ["Foobar","Foobar barfoo"]
14:20:48 <phlpp> ah, great
14:21:07 <phlpp> > filter ("Foobar" `isInfixOf`) ["Foobar", "foobar barfoo", "Fubar"]
14:21:09 <lambdabot>  ["Foobar"]
14:21:37 <dmwit> > isInfixOf "Foobar" "a Foobar b"
14:21:39 <lambdabot>  True
14:22:31 <dmwit> isInfixOf x = not . null . filter (isPrefixOf x) . inits -- ?
14:22:45 <Heffalump> tails surely?
14:22:49 <dmwit> tals
14:22:49 <Heffalump> or isSuffixOf
14:22:55 <dmwit> yeah
14:23:08 <Heffalump> not . null . filter f = any f
14:23:09 <phlpp> where do this isInfixOf function comes from?
14:23:21 <oerjan> Data.List
14:23:24 <dmwit> Heffalump: Ooo, nice, I always forget those.
14:23:29 <phlpp> > [5] `isInfixOf` [1..10]
14:23:30 <lambdabot>  True
14:24:22 <dmwit> > let x `syntaxTest` xs = any (isPrefixOf x) (tails xs) in syntaxTest [5] [1..10]
14:24:23 <lambdabot>  True
14:24:27 <dmwit> huh
14:24:37 <phlpp> ok
14:25:01 <phlpp> next question: where do i get a random number in the space of 0..n?
14:25:04 <phlpp> from
14:25:06 <dmwit> > let (x `syntaxTest`) = any (isPrefixOf x) . tails in syntaxTest [5] [1..10]
14:25:07 <lambdabot>  Parse error in pattern
14:25:15 <dmwit> phlpp: :b Random
14:25:19 <dmwit> (In ghci)
14:25:27 <dmwit> :t randomRIO
14:25:30 <lambdabot> forall a. (Random a) => (a, a) -> IO a
14:30:11 <hpaste>  dibblego pasted "is there an existing function to encapsulate this?" at http://hpaste.org/3395
14:31:20 <phlpp> @hoogle Random
14:31:21 <lambdabot> Random :: module
14:31:21 <lambdabot> System.Random :: module
14:31:21 <lambdabot> System.Random.Random :: class Random a
14:31:46 <conal> dibblego: have you tried using 'either', to see how it simplifies from there?
14:32:06 <dibblego> conal, I haven't, but I can imagine how it would look
14:32:07 <phlpp> eh
14:32:34 <dibblego> conal, I thought there might be a more specific function than either even
14:32:59 <phlpp> @hoogle randomRIO
14:32:59 <lambdabot> Random.randomRIO :: Random a => (a, a) -> IO a
14:33:28 <quicksilver> I don't really recommend randomRIO unless you happen to be in IO anyway
14:33:36 <quicksilver> I recommend that plain randomR
14:33:44 <omnId> dibblego: so two Rights give the pair, otherwise it collects the Lefts into a list?
14:33:52 <dibblego> omnId, right
14:33:58 <quicksilver> dibblego: I would do the cases simultaneously
14:34:19 <quicksilver> dibblego: case (fa a, fb b) of (Left ta, Left tb) -> ......
14:34:33 <quicksilver> dibblego: then the four cases are at the same level, looks nicer IMO
14:34:35 <dibblego> quicksilver, yeah I did that already, just trying to get the essence of the function
14:34:39 <dibblego> quicksilver, agreed
14:35:08 <phlpp> quicksilver: hm, i want to write a function which takes an IO [String] and returns an IO STtring
14:35:14 <dmwit> :instances MonadPlus
14:35:22 <dmwit> ?instances MonadPlus
14:35:24 <conal> the list collection part reminds me of the writer applicative functor.
14:35:27 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:35:40 <dmwit> > Left 3 `mplus` Left 4
14:35:40 <lambdabot>  Add a type signature
14:35:43 <omnId> phlpp: you want to concat the inner string?
14:35:44 <phlpp> do you mean this by "happen to be in IO anyway"?
14:35:51 <dmwit> > (Left 3) `mplus` (Left 4)
14:35:51 <quicksilver> phlpp: yes, I do
14:35:51 <lambdabot>  Add a type signature
14:35:59 <dmwit> > (Left 3) `mplus` (Left 4) :: Either Int String
14:36:00 <lambdabot>   add an instance declaration for (Error Int)
14:36:00 <lambdabot>     In the expression: (Left 3)...
14:36:10 <quicksilver> phlpp: if you're in IO anyway then you could use randomR
14:36:19 <quicksilver> dibblego: it looks a bit like collecting errors
14:36:20 <dmwit> > (Right 3) `mplus` (Right 4) :: Either String Int
14:36:25 <lambdabot>  Right 3
14:36:26 <dibblego> ?type errors
14:36:28 <lambdabot> Not in scope: `errors'
14:36:37 <dmwit> ?instances Error
14:36:38 <lambdabot> IOError, [Char]
14:36:44 <quicksilver> dibblego: that's not available in any standard either combinator I've seen
14:36:54 <quicksilver> dibblego: (I agree it makes sense, but I haven't see it before)
14:37:05 <quicksilver> maybe it's most like 'try'
14:37:07 <quicksilver> :t try
14:37:10 <lambdabot> Not in scope: `try'
14:37:12 <quicksilver> bah
14:37:16 <conal> I wonder if this alternative return type would lead to something: Either [e] (Maybe (a1, b1)).
14:37:20 <quicksilver> :t Control.Exception.try
14:37:22 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
14:37:26 <quicksilver> hmm
14:37:35 <quicksilver> I thought there was a listy version of try
14:37:37 <phlpp> quicksilver: selectQuotes s = do { let quotes <- s; n <- randomRIO(0, length quotes - 1); return (quotes!!n) }
14:37:40 <phlpp> something like that
14:37:41 <dmwit> dibblego: Maybe you want to instance Error [String] or so.
14:37:43 <quicksilver> maybe I'm imagining it
14:37:43 <conal> in any case, i imagine you'd want the source & result types to match, so validate is a combinator.
14:37:59 <dibblego> I haven't look at Error, I will thanks
14:38:00 <dmwit> Then instance MonadZero (Either [String] a)
14:38:39 <conal> also, maybe simplify so that fa & fb are applied to a & b before the call.
14:38:46 <omnId> @src Either mplus
14:38:46 <lambdabot> Left _ `mplus` n = n
14:38:46 <lambdabot> m      `mplus` _ = m
14:39:04 <quicksilver> omnId: the mplus instance for either is a so-called "orElse" instance
14:39:10 <dmwit> omnId: Ah, yeah, that wouldn't do what he wanted.
14:39:13 <phlpp> :t randomR
14:39:15 <quicksilver> omnId: otherwise known as 'catch and try this instead'
14:39:15 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:40:09 <quicksilver> phlpp: your example looked fine, btw
14:40:19 <quicksilver> phlpp: except you had a superfluous 'let' :)
14:40:47 <quicksilver> phlpp: but I question why you're doing it in IO :) it doesn't seem to do any IO except the randomness
14:41:25 <phlpp> quicksilver:  do you mean cause of my type signature?
14:41:27 <byorgey> well, originally he got the [String] from a file.
14:42:03 <byorgey> which is where the IO came from.
14:42:08 <quicksilver> right
14:42:16 <quicksilver> but that's no reason to have 'selectQuotes' in IO
14:42:24 <quicksilver> since 'selectQuotes' doesn't do any IO of its own
14:42:37 <byorgey> right.  that could be factored out into a pure function.
14:42:39 <quicksilver> (except the random numbers, of course, but I was advocating not using that...)
14:42:50 <byorgey> quicksilver: what would you use instead?
14:42:58 <quicksilver> the RandomGen version
14:43:04 <quicksilver> :t randomR
14:43:06 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:43:08 <omnId> IO random is easier to get working before learning about the manual gen threading and upgrading to State StdGen
14:43:17 <quicksilver> perhas
14:43:22 <dmwit> :t randomRs
14:43:24 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
14:43:35 <byorgey> I would tend to agree with omnId.
14:43:50 <dmwit> Just pass your pure function an infinite list of randoms in the right range. =)
14:43:58 <dmwit> (Unless the range changes...)
14:45:00 <conal> dibblego: are you gathering error messages?  It's looking like an error monad to me, though not exactly.  something like validate = liftM2 (,)
14:45:23 <quicksilver> conal: it looks like an error monad which tries to keep running even after failure
14:45:29 <quicksilver> conal: to collect more errors
14:45:41 <quicksilver> conal: I'm not sure that would actually be monadic though :)
14:45:45 <conal> quicksilver: ooh!
14:46:03 <quicksilver> since in general you can't keep running after failure (you might need that intermediate value)
14:46:37 <conal> quicksilver: i see!  maybe a non-monadic applicative functor then.
14:47:06 <dibblego> that's what I thought it would come to
14:48:01 <oerjan> > Either 1 (+) <*> Either 2 1 <*> Either 3 1
14:48:02 <lambdabot>   Not in scope: data constructor `Either'
14:48:10 <oerjan> sheesh
14:48:32 <dmwit> :t (<*>)
14:48:33 <oerjan> > Right (+) <*> Right 1 <*> Right 1 :: Either Int Int
14:48:34 <lambdabot>        add an instance declaration for (Applicative (Either Int))
14:48:34 <lambdabot>     In the ...
14:48:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:48:43 <omnId> @instances-importing Control.Applicative Applicative
14:48:44 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
14:48:49 <phlpp> :t f=f
14:48:51 <lambdabot> parse error on input `='
14:48:51 <oerjan> > Right (+) <*> Right 1 <*> Right 1 :: Either String Int
14:48:52 <lambdabot>        add an instance declaration for (Applicative (Either String))
14:48:52 <lambdabot>     In t...
14:48:59 <phlpp> > let f=f
14:48:59 <lambdabot>  Parse error
14:49:02 <phlpp> hehe
14:49:03 <omnId> no Applicative (Either e)
14:49:07 <oerjan> seems to be missing the instance altogether
14:49:30 <conal> perhaps a combination of ((,) [e]) and Maybe.
14:49:36 <dmwit> > (Right (+)) <*> (Right 1)
14:49:36 <omnId> @type let f = f in f
14:49:39 <lambdabot> forall t. t
14:49:39 <lambdabot>        add an instance declaration for (Applicative (Either a))
14:49:39 <lambdabot>     In the ex...
14:49:51 <conal> use (mempty, Just a) in place of Right a
14:50:11 <conal> and i bet you'll want type composition as well.  See TypeCompose.
14:50:14 <conal> @wiki TypeCompose
14:50:15 <lambdabot> http://www.haskell.org/haskellwiki/TypeCompose
14:51:02 <conal> type Validate w = ((,) w) `O` Maybe
14:51:09 <conal> where w is any Monoid
14:52:55 <omnId> Validate w a = (((,) w) `O` Maybe) a = ((,) w) (Maybe a) = (w, Maybe a)
14:53:07 <omnId> (just for my benefit :)
14:53:27 <conal> modulo the newtype
14:53:27 <phlpp> @hoogle fix
14:53:28 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
14:53:28 <lambdabot> Control.Monad.Fix :: module
14:53:28 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
14:53:28 <dibblego> thanks for the help :)
14:54:01 <hpaste>  conal annotated "is there an existing function to encapsulate this?" with "Try this" at http://hpaste.org/3395#a1
14:54:07 <omnId> newtype O f g a = O f (g a) -- ?
14:54:34 <byorgey> uhoh, phlpp found fix =)
14:54:45 <conal> omnId: newtype O f g a = O (f (g a))
14:54:53 <omnId> oh, right
14:55:02 <sioraiocht> okay, I can see libreadline
14:55:08 <sioraiocht> why can't ghc?
14:55:28 <fasta> quicksilver: the limited benefit of partial type applications is that often you want to have completely new types (and are not just reusing something general).
14:55:47 <byorgey> > fix ((1:) . scanl 0 (+))
14:55:48 <lambdabot>        add an instance declaration for
14:55:48 <lambdabot>       (Num ((a -> a -> a) -> (a -> a -...
14:56:07 <byorgey> > fix ((1:) . scanl (+) 0)
14:56:08 <lambdabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
14:56:21 <quicksilver> fasta: yeah, in the end I find you need newtypes
14:56:44 <fasta> quicksilver: I meant also data and not just newtypes.
14:56:58 <conal> quicksilver: until GHC supports type lambda and does (at least limited) higher-order unification.
14:57:00 <sioraiocht> fix
14:57:02 <fasta> quicksilver: regarding newtypes, yes, it seems that way.
14:57:02 <sioraiocht> @src fix
14:57:02 <lambdabot> fix f = let x = f x in x
14:57:12 <Saul_> Is there a vector library for haskell?
14:57:31 <fasta> Saul_: if by vector you mean growable array, then yes.
14:57:44 <conal> btw, here's type composition: http://darcs.haskell.org/packages/TypeCompose/doc/html/Control-Compose.html#2
14:57:45 <Saul_> I didn't
14:57:46 <lambdabot> http://tinyurl.com/22438u
14:58:02 <phlpp> :t threadDelay
14:58:04 <lambdabot> Not in scope: `threadDelay'
14:58:10 <Saul_> I mean more like a library with functions on 2d and 3d vectors
14:58:20 <phlpp> @hoogle threadDelay
14:58:20 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
14:58:27 <phlpp> :t Control.Concurrent.threadDelay
14:58:28 <conal> oh, yurk.  the functor/cofunctor instance formatting is messed up.
14:58:29 <lambdabot> Int -> IO ()
14:58:34 <Saul_> stuff like scaling, translating, inner product and such
14:59:01 <shapr> @yow !
14:59:01 <lambdabot> HAIR TONICS, please!!
14:59:08 <shapr> It's exciting!
15:00:15 <omnId> what's exciting?!
15:00:22 <quicksilver> Saul_: I think sme people have put some stuff together, yes
15:00:41 <quicksilver> Saul_: some of that stuff is in GLU but that's a bit perverse :)
15:00:54 <fasta> quicksilver: did you see my remark regarding IntMap vs STArray?
15:00:56 <Saul_> Well I do actually need it for graphics
15:01:05 <quicksilver> fasta: no
15:01:27 <fasta> quicksilver: My algorithms run about 20 times faster with STArray.
15:01:38 <shapr> omnId: I'm reading about monad transformers.
15:02:05 <quicksilver> fasta: interesting. What kind of thing do your algorithms do?
15:02:12 <fasta> quicksilver: Actually I am using Bulat's DynamicSTArray
15:02:26 <fasta> quicksilver: they compute matchings
15:03:21 <Saul_> quicksilver: I'll just put one together as I go, my vector stuff is incredibly rusty so it's good practice. Thanks
15:03:26 <conal> shapr: try applicative functors.  you can use type composition instead of transformers.
15:04:00 <ihope> Is GHCi an interpreter?
15:04:05 <dmwit> yes
15:04:07 <quicksilver> yes
15:04:10 <quicksilver> hence the 'i' :)
15:04:13 <dmwit> (That's what the 'i' is for. =)
15:04:35 <shapr> conal: Er, how so?
15:05:14 <ihope> So is the "Interactive" in "GHC Interactive, version 6.6, for Haskell 98" just a typo? :-)
15:05:27 <byorgey> touche!
15:05:46 <conal> shapr: the composition of AFs is an AF, while the corresponding property is not true for monads.  Thus you can simply use type composition to compose AFs out of AFs, without introducing a new kind of "transformer" thing with largely redundant definitions (as with monads).
15:05:48 <quicksilver> ;)
15:05:57 <shapr> conal: Sounds like arrows, sort of.
15:05:58 <omnId> enh, it starts with the same 5 letters, it's practically the same word!  ;)
15:06:16 <conal> shapr: sort of, but simpler than arrows & simpler than monads.
15:06:21 <byorgey> I was under the impression that GHCi is NOT an interpreter, in the sense that everything you type into it gets compiled.
15:06:24 <shapr> Cool, I'll check it out.
15:06:52 <conal> shapr: :)  i'd like to see all newbies play with AFs before monads.  they're simpler & more functional in style.
15:07:12 <ihope> What are AFs?
15:07:13 <quicksilver> byorgey: nope
15:07:14 <conal> shapr: that was an aside.  not that i think of you as a newbie.
15:07:14 <omnId> shapr: the usefulness of monads in general hit me like a brick when I wrote an interpreter in StateT s IO :)
15:07:18 <fasta> conal: how does the ST monad functionality work in AFs?
15:07:21 <conal> ihope: applicative functors
15:07:22 <quicksilver> byorgey: although I think that might once have been true?
15:07:29 <byorgey> quicksilver: hm, ok
15:07:31 <shapr> conal: Until I publish some papers...
15:07:36 <quicksilver> byorgey: unless by 'compiled' you mean into bytecode..
15:07:52 <byorgey> quicksilver: I guess I'm not sure what I mean =)
15:07:57 <quicksilver> byorgey: but most interpreters do some kind of transformation
15:08:10 <conal> fasta: i don't know if there is an AF corresponding to StateT
15:08:12 <quicksilver> byorgey: I have a memory of reading that in early versions there wasnt an interpreted
15:08:25 <byorgey> ihope: Applicative Functors.
15:08:28 <fasta> conal: I meant ST, not StateT
15:08:30 <conal> fasta: oh.  State itself is an AF.
15:08:35 <conal> fasta: oh.
15:08:36 <quicksilver> conal: well state is an applicative functor. All monads are!
15:08:39 <fasta> conal: that's why I said ST ;)
15:08:45 <conal> quicksilver: exactly.
15:08:53 <shapr> conal: The wikibook says that you can get an AF out of every monad. If that's true, and AFs are simpler, why use monads?
15:09:03 <quicksilver> monads let you do more
15:09:14 <conal> shapr: because monads are more expressive, and therefore less general.
15:09:18 <shapr> ah
15:09:20 <fasta> quicksilver: so there's a catch ;)
15:09:27 <fasta> What's the catch?
15:09:29 <quicksilver> there's always a catch :)
15:09:41 <fasta> In the end the machine is still stupid ;)
15:09:52 <fasta> (well, for the next 10 years at least ;) )
15:10:03 <dmwit> fasta: Here's the tradeoff.  It's true of almost everything:
15:10:20 <dmwit> AFs are easy to find, but not very powerful.  Monads are harder to find but more powerful.
15:10:40 <dmwit> You can go farther in either direction, I'm sure; arrows are an example of something that's even harder to find than monads, but even more powerful.
15:10:42 <omnId> general/little specific usefulness <-------------> specific/not very wide use
15:10:45 <conal> shapr: my entry to AFs was that i prefer to use return & liftM, liftM2, ... & ap when doing monadic programming.  for the functional ("applicative") style.  when those operators suffice, the code is really using the AF interface and is therefore more general.
15:10:57 <shapr> Interesting!
15:11:23 <ddarius> dmwit: Every monad and comonad gives rise to an arrow.
15:11:26 <conal> though you can make an arrow from every monad.
15:11:50 <dmwit> Oh, right, Kleisli.
15:11:51 <dmwit> hum
15:12:07 <dmwit> fasta: Don't listen to me. =P
15:12:23 <fasta> dmwit: I have you on ignore already ;)
15:12:28 <phlpp> byorgey: still there?
15:12:41 <conal> one important property of Applicative & Arrow is that they let the implementation do static optimization, unlike Monad.
15:12:50 <quicksilver> well "gives rise to" is quite different from "is"
15:13:18 <quicksilver> every monoid gives rise to a group, after all
15:13:24 <quicksilver> that doesn't mean all monoids are groups...
15:14:18 <fasta> Running code is so much more interesting than crawling code!
15:14:26 <quicksilver> you can't retrieve the monad from the kleisli arrow
15:14:30 <quicksilver> you've lost join
15:14:34 <quicksilver> (if I'm not mistaken)
15:14:37 <newsham> my code runs scared
15:15:11 <ddarius> quicksilver: Same for Applicate Functors so it makes no sense for you to say that.
15:15:20 <quicksilver> eh?
15:15:24 <quicksilver> it makes perfect sense
15:15:32 <quicksilver> I'm drawing a distinction...
15:15:37 <conal> dibblego: still there?
15:15:42 <dibblego> yeah
15:16:10 <conal> dibblego: See "Accumulating exceptions" on p 9 of "Applicative programming with effects".
15:16:25 <dibblego> ah right; I have that paper next to my bed, cheers :)
15:16:41 <quicksilver> cool!
15:16:45 <quicksilver> @karma+ conal
15:16:45 <lambdabot> conal's karma raised to 2.
15:16:47 <conal> dibblego: though the type composition version is more elegant.
15:16:53 <conal> :) !
15:17:04 <conal> doubled my karma :)
15:17:42 <hpaste>  phlpp pasted "modifying irc bot" at http://hpaste.org/3396
15:17:52 <phlpp> could anybody fly over this piece of code?
15:17:52 <ddarius> quicksilver: Monads give rise to arrows in close enough to the same way that they give rise to Applicative Functors.
15:18:12 <ddarius> phlpp: What's its lat/long?
15:18:15 <phlpp> especially the emphasized definition of eval throws that error:
15:18:16 <phlpp> Couldn't match expected type `IO' against inferred type `ReaderT Bot IO'
15:18:34 <phlpp> i'm a bit clueless how to fix this.
15:18:37 <quicksilver> ddarius: oh yes, agreed
15:18:45 <omnId> @type liftIO
15:18:46 <fasta> phlpp: you need a lift
15:18:48 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
15:18:58 <omnId> IO a -> ReaderT Bot IO a
15:19:22 <omnId> liftIO (anIOAction :: IO a) :: ReaderT Bot IO a
15:19:54 <conal> we all need a lift sometimes
15:20:11 <shapr> hah
15:20:26 <phlpp> ah
15:20:27 <phlpp> ok
15:20:29 <phlpp> so its like
15:20:37 <phlpp> (io $ selectQuote $ lookUp "brain.db" s) >>\
15:20:38 <phlpp> = (\quote -> privmsg quote)
15:20:42 <phlpp> argh, stupid emacs
15:21:06 <omnId> phlpp: if (selectQuote $ ...) is an IO action, yes
15:21:26 <phlpp> ah, i see that all makes no sense :D
15:21:35 <omnId> no sense?
15:21:36 <conal> phlpp: but eta-reduced: (io $ selectQuote $ lookUp "brain.db" s) >>= privmsg
15:21:49 <fasta> quicksilver: Bulat's library is (when you patched it) very nice, btw.
15:21:55 <phlpp> cause eval takes a _cleaned_ string, so every server message runs through my quoteSelector :D
15:22:17 <fasta> quicksilver: it's arguably a lot better than what's now in the libraries.
15:22:29 <omnId> phlpp: what's selectQuote's type?
15:22:38 <conal> quicksilver, fasta: what do you recommend for fast arrays with an applicative interface?
15:22:57 <conal> i.e., a functional interface.
15:23:07 <fasta> conal: what do you mean?
15:23:23 <fasta> conal: you want to make your own DiffArray?
15:23:53 <conal> fasta: i want to do a bunch of array calculations, using a functional interface (ideally), for graphics and have it go fast.
15:24:08 <conal> i won't be doing incremental updates
15:24:56 <conal> it'll be to compute (a) a discrete sampling of an image, and (b) vertices on a 3d mesh.
15:24:58 <fasta> conal: is this for an API you want to make or just your own algorithms?
15:25:18 <conal> fasta: API
15:25:35 <ac> @hoogle transpose
15:25:36 <lambdabot> List.transpose :: [[a]] -> [[a]]
15:25:36 <lambdabot> Data.Graph.transposeG :: Graph -> Graph
15:26:03 <fasta> conal: I think I would use STArray and then freeze it.
15:26:21 <fasta> conal: if there are no incremental updates, Array is fine too.
15:26:38 <conal> fasta: thanks.  and can you tell me how STArray & UArray relate?
15:26:49 <fasta> conal: STArray relates to Array
15:26:56 * ddarius is getting horribly behind on Haskell-Cafe.
15:26:56 <fasta> conal: STUArray relates to UArray
15:27:09 <conal> and then there's GHC.PArr
15:27:11 <mrd> @hoogle runSTUArray
15:27:12 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
15:27:28 <conal> fasta: and the U is "unboxed"?
15:27:41 <fasta> conal: I wasn't aware of that one, but that's for the nested data para. probably?
15:27:45 <fasta> conal: yes
15:27:48 <mrd> > runSTArray (do a <- newArray (1,10) 1; return a)
15:27:49 <lambdabot>   Not in scope: `newArray'
15:28:02 <conal> fasta: thanks.  and yes. PArr is for ndp.
15:28:28 <fasta> conal: is GHC.Arr documented already?
15:28:30 <mrd> > runSTArray (do a <- Data.Array.MArray.newArray (1,10) 1; return a)
15:28:30 <lambdabot>   Not in scope: `Data.Array.MArray.newArray'
15:29:03 <conal> fasta: i found a bit on the wiki (i forget whether the haskell wiki or ghc wiki)
15:30:30 <conal> i like the look of runSTArray & runSTUArray.
15:31:27 <fasta> conal: They are just wrappers around runST, I think
15:31:30 <mrd> yes
15:31:33 <mrd> and unsafeFreeze
15:31:43 <mrd> but they do let you omit a type annotation here or there
15:34:40 <mrd> @wiki SPOJ
15:34:40 <lambdabot> http://www.haskell.org/haskellwiki/SPOJ
15:34:50 <mrd> I have a little intro to mutable Arrays in there
15:36:12 <conal> mrd: thanks for the pointer
15:47:22 <phlpp> oh
15:47:23 <phlpp> erm
15:47:35 <phlpp> omnId: thats odd
15:47:53 <phlpp> when: (io $ selectQuote $ lookUp "brain.db" s) >>= privmsg
15:47:55 <phlpp> is called twice
15:48:00 <phlpp> the programm terminates/the bot quits
15:48:13 <phlpp> is there any reason for?
15:48:30 * SimonRC goes to bed
15:50:35 <bparkis> you know what might be pretty interesting, for a GUI:  suppose your GUI is made up of components each of which has a strongly typed input stream and output stream
15:50:48 <bparkis> and you can hook up each component to any other component any way you like so that the types match
15:50:59 <bparkis> the user can, i mean, not just the program creator
15:51:39 <bparkis> and the user can add new components of his own and hook them up to the program creator's components
15:51:47 <conal> bparkis: have you seen Eros?
15:51:52 <conal> @where Eros
15:51:52 <lambdabot> http://conal.net/papers/Eros
15:51:55 <Zao> There was some kind of declarative haskell GUI a while ago.
15:51:58 <bparkis> no i haven't seen that
15:52:22 <conal> bparkis: maybe it's sgl like what you're imagining.
15:52:44 <conal> "something like"
15:52:47 <omnId> phlpp: when does it terminate?
15:53:00 <phlpp> omnId: wait, i past some session
15:53:16 <phlpp> eval s | " " `isPrefixOf` s    = (io $ selectQuote $ lookUp "brain.db" s) >>= privmsg
15:53:24 <phlpp> i changed it into this one
15:53:32 <phlpp> because no normal ircserver sends messages with leading whitespace
15:53:44 <phlpp> so i can test this evaluation part on my one
15:53:46 <phlpp> own
15:53:56 <phlpp> still with me?
15:54:02 <omnId> yeah
15:54:09 <phlpp> so, following happend:
15:54:26 <conal> bparkis: though Eros fuses GUIs, eliminating matching input/output streams
15:54:36 <bparkis> what do you mean fuses?
15:54:39 <phlpp> muddis^sohn is btw. the bot name, so:
15:54:40 <phlpp> 00:44 -!- muddis^sohn [~muddis^so@pD9F5C6B8.dip.t-dialin.net] has joined #konsolen
15:54:43 <phlpp> 00:44 < Richelieu>  hallo
15:54:57 <phlpp> and we get following: 00:44 < muddis^sohn> hallo ryz, hallo ago
15:55:09 <phlpp> so he looked up hallo in db and printed this. thats fine, but on the next call
15:55:24 <conal> bparkis: given two GUIs, fusion makes another GUI that contains all of the inputs & outputs of the source GUIs *except* for the matching pair, which vanish.
15:55:26 <phlpp> 00:45 < Richelieu>  muddi is grad weg :\
15:55:27 <phlpp> 00:45 -!- muddis^sohn [~muddis^so@pD9F5C6B8.dip.t-dialin.net] has quit [Read error: EOF from client]
15:55:32 <phlpp> you see, he terminates
15:55:40 <conal> bparkis: like what happens at the type level when you do function composition.
15:55:43 <conal> @type (.)
15:55:46 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:55:48 <phlpp> ah, wait a sec
15:55:49 <bparkis> oh yes
15:55:51 <phlpp> maybe i know why :>
15:55:54 <omnId> phlpp: it says it got an EOF
15:55:58 <bparkis> that might be a disadvantage
15:56:02 <bparkis> reduces what you can do with the program
15:56:13 <conal> bparkis: for instance?
15:56:34 <conal> bparkis: (btw, i agree.)
15:56:41 <bparkis> well i mean in the limit case you end up with a single lump of a GUI that you can't alter yourself
15:56:46 <phlpp> omnId: yeah, but always on the second call
15:56:51 <phlpp> of this part of my eval function
15:57:08 <bparkis> like let's say you have a paint program and you want to write a script to make the paintbrush take input from a file instead of from the mouse
15:57:10 <phlpp> :t "foo  bar foobar"
15:57:11 <conal> bparkis: right.  it's semantic composition, not syntactic.
15:57:12 <lambdabot> [Char]
15:57:17 <bparkis> you wouldn't be able to do that if the paintbrush is fused with the rest of the program
15:57:33 <phlpp> omnId: i can imagine why
15:57:40 <omnId> phlpp: do tell :)
15:57:46 <conal> bparkis: like function composition (as opposed to expression nesting).
15:57:53 <phlpp> actually "foo bar foobar" is also a string
15:58:03 <omnId> @src String
15:58:03 <lambdabot> type String = [Char]
15:58:08 <conal> bparkis: paintbrush?
15:58:13 <phlpp> and i every second call was a string with somelike very similar to "foobar foo bar"
15:58:23 <phlpp> and he looks up EXACTLY that string
15:58:28 <bparkis> you know, the thing you use to make marks on the canvas in a paint program
15:58:36 <bparkis> the drawing tool
15:58:40 <phlpp> but he will not find this in the file
15:59:01 <bparkis> that could be a component with an input and output stream that the user can redirect
15:59:14 <phlpp> thats why lookUp "brain.db" "foobar foo bar" fails
15:59:17 <omnId> phlpp: what do selectQuote and lookup look like?
15:59:26 <phlpp> wait, i just paste them
15:59:28 <conal> bparkis: i see.  sure.  inputs remain composable.
15:59:42 <omnId> annotate your other paste
16:00:02 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3397
16:00:11 <phlpp> yeah, thats my paste
16:00:18 <bparkis> so a single GUI "program" is a collection of components with their own I/O stream, together with _one particular_ way of hooking them up together
16:00:40 <conal> bparkis: brb.  on the phone with my brother.
16:00:43 <bparkis> and the user can change the program's behavior by changing how the components are hooked together, or adding and removing components of his own (maybe those he has created)
16:01:20 <phlpp> so problem is lookUp will return a []
16:01:30 <omnId> phlpp: lookup filters, selectQuote picks a random match.
16:01:34 <phlpp> yup
16:01:44 <phlpp> > return []
16:01:45 <lambdabot>   add an instance declaration for (Show (m [a]))
16:02:22 <omnId> > randomR (0,-1) (mkStdGen 42)
16:02:23 <lambdabot>  (0,1720602 40692)
16:02:25 <phlpp> seems like i have to completly rewrite this functions
16:02:56 <omnId> selectQuote tries ([] !! 0) which causes a runtime error.
16:03:17 <phlpp> ah, i see
16:03:47 <phlpp> i think i got a workaround
16:03:49 <phlpp> just a moment
16:03:54 <hpaste>  omnId annotated "(no title)" with "a start" at http://hpaste.org/3397#a1
16:04:59 <TSC> Lemmih: Are you the maintainer of hsSDL?
16:06:44 <bparkis> conal: i'm thinking of this as a finished program that does something fine without the user changing it, but that also comes with a toolkit for examining the types and values of components and the way components are hooked up
16:07:02 <hpaste>  (anonymous) annotated "(no title)" with "what about?" at http://hpaste.org/3397#a2
16:07:06 <bparkis> you don't have to use the toolkit but you can if you want to make your program do more than it already does
16:07:12 <phlpp> omnId: what about this?
16:07:37 <phlpp> eh, last line should be like else return l
16:07:57 <omnId> phlpp: I added a simple change to selectQuotes that should fix without any other changes.
16:08:11 <phlpp> yeah, that's true
16:08:23 <phlpp> i just added a fix, too
16:08:52 <phlpp> it's more the way the "final" FileOps module, at least this two functions, will look like
16:09:19 <hpaste>  omnId annotated "(no title)" with "'pick' is generally useful, and some simplifications." at http://hpaste.org/3397#a3
16:09:53 <phlpp> ah, great stuff
16:09:54 <phlpp> thanks
16:10:10 <omnId> add 'import Control.Monad(liftM)' and delete an extraneous right paren.
16:13:16 <omnId> notice I removed the ability to specify the quotes filename, it doesn't *seem* like something that benefits too much from parameterization.
16:14:18 <omnId> notice 'liftM (f :: a -> b) (action :: m a) :: m b'
16:15:21 <omnId> liftM ((xs !!) :: Int -> a) (randomRIO (0, length xs - 1) :: IO Int) :: IO a, where xs :: [a]
16:16:54 <phlpp> hm
16:16:59 <phlpp> i get something like
16:17:07 <phlpp> he last statement in a 'do' construct must be an expression
16:17:10 <phlpp> at randomQuote
16:17:28 <omnId> the line starting 'let matches = ...' has an extra right paren.
16:17:36 <omnId> a syntax error on my part.
16:18:04 <phlpp> ah ok
16:23:36 <conal> bparkis: i like that vision.  a useful app, plus being able to peer inside and extend it without programming.
16:25:06 <omnId> if null matches then return Nothing else liftM Just (pick matches) -- would also work, the caller would be like: do q <-liftM (fromMaybe "No matches.") (selectQuote pat)
16:25:58 <LoganCapaldo> extension with rogramming?
16:25:59 <bparkis> it could also have the ability to make new components by programming
16:26:02 <LoganCapaldo> blasphemy!
16:26:07 <LoganCapaldo> um
16:26:11 <LoganCapaldo> without programming
16:26:17 <LoganCapaldo> why can't I type?
16:26:23 <bparkis> so you could write your own widget and then hook that up into the program
16:26:25 <omnId> what happened to the "out p"?
16:26:37 <LoganCapaldo> I don't know!
16:27:24 <conal> bparkis: yep.  i'm doing a similar thing with Eros.  One incarnation will be an image synthesis/manipulation app, with an optimizing compiler hidden inside.
16:27:46 <conal> also 3d, sound, etc.
16:30:45 <omnId> (*whisper* *whisper*, you know, phlpp, if you're confident quotes.db won't change during the course of your program, you don't care *when* exactly it's read or its entire contents staying resident in memory, and you can rely on it being there, you *might* have course to put an unsafePerformIO around quotes.)
16:32:23 * LoganCapaldo stabs omnId
16:32:32 <omnId> what?
16:32:38 <omnId> I said nothing.
16:32:38 <LoganCapaldo> ou stop whispering that!
16:32:40 <LoganCapaldo> evil!
16:33:11 <phlpp> hm
16:33:12 <conal> i'm with omnId.  haskell is missing a way to take values without a convenient lexical syntax and use them as constants.
16:33:44 <phlpp> is it possible to check if the first char of a character is a lower char?
16:33:49 <phlpp> such that a-z
16:33:52 <conal> i'd like to see first class constant media.  allow constant folding, etc.
16:34:01 <omnId> really, for some constant value you could have put as a pure toplevel constant and you just happened to put into a seperate file for convenience, unsafePerformIO isn't exactly *totally* wrong.
16:34:02 <mauke> @hoogle Char -> Bool
16:34:02 <lambdabot> Char.isAlpha :: Char -> Bool
16:34:02 <lambdabot> Char.isAlphaNum :: Char -> Bool
16:34:02 <lambdabot> Char.isAscii :: Char -> Bool
16:34:04 <conal> :type isLower
16:34:10 <phlpp> ah
16:34:10 <phlpp> :>
16:34:16 <phlpp> :t isLower
16:34:19 <lambdabot> Char -> Bool
16:34:23 <phlpp> kk
16:34:24 <LoganCapaldo> @type (flip elem ['a'..'z'] . head)
16:34:26 <lambdabot> [Char] -> Bool
16:34:35 <LoganCapaldo> gah
16:34:41 <LoganCapaldo> I've reinvented the wheel
16:35:02 <LoganCapaldo> but Haskell's wheel construction facilities are so much fun to use
16:35:07 <omnId> phlpp: remember that isLower :: Char -> Bool, so you'll have to take the String's head to get a compatible Char type.
16:35:30 <phlpp> @hoogle isLower
16:35:30 <lambdabot> Char.isLower :: Char -> Bool
16:35:35 <phlpp> omnId: yup
16:35:41 <phlpp> i know :>
16:36:03 <ddarius> :t map isLower
16:36:05 <lambdabot> [Char] -> [Bool]
16:36:11 <ddarius> Oops.
16:36:14 <ddarius> :t all isLower
16:36:16 <lambdabot> [Char] -> Bool
16:36:27 <conal> :type isLower . head
16:36:41 <omnId> if only there were an onHead in the spirit of (->)'s first
16:36:52 <LoganCapaldo> that's a neat idea
16:36:55 * ddarius has no idea what the conversation is about.
16:36:58 <omnId> onHead f (x:xs) = f x : xs
16:37:11 <conal> and similarly for onTail
16:37:41 <conal> now we're playing with "composable editors" again!
16:37:48 <omnId> startsWithLower = onHead isLower
16:37:55 <omnId> erm, no
16:37:59 <phlpp> eval s | (isLower.head)	s      = (io $ randomQuote s) >>= privmsg
16:38:04 <phlpp> looks this correct?
16:38:20 <omnId> I guess onHead isLower wouldn't type :)
16:38:26 <omnId> phlpp: it does
16:38:29 <phlpp> hm
16:38:40 <conal> onHead is for replacing (editing) the head, not testing it
16:38:48 <phlpp> i do this because i think that there are even no server messages
16:38:49 <mauke> eval s@(c : _) | isLower c = ...
16:38:56 <phlpp> which begin with lower letter
16:39:09 <phlpp> but after a few messages from the server, the bot terminates :D
16:39:13 <conal> btw, onTail.onHead edits the second element.
16:39:16 <phlpp> dunno why
16:39:33 * omnId wrote an onElt f i xs = take i xs ++ [f (xs !! i)] ++ drop (i-1) xs
16:39:39 <phlpp> he doesn't even send a quote -> eval s | (isLower) .... isn't called
16:40:15 <phlpp> hmmh, that's strange
16:41:04 <phlpp> > head []
16:41:04 <LoganCapaldo> @type let { onHead f (x:xs) = f x : xs ; onTail g (x:xs) = x : g xs } in onTail . onHead
16:41:06 <lambdabot> forall a. (a -> a) -> [a] -> [a]
16:41:07 <lambdabot>  Exception: Prelude.head: empty list
16:41:09 <phlpp> > isLower []
16:41:10 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
16:41:13 <phlpp> hmhm
16:41:16 <phlpp> maybe thats the reason?
16:41:17 <omnId> s/onElt f i/onElt i f/, that made it easy to replace the contents of one value in a doubly-nested list.
16:41:19 <newsham> ?hoogle compose
16:41:20 <lambdabot> No matches found
16:41:29 <newsham> ?hoogle [a->a] -> a -> a
16:41:29 <lambdabot> No matches, try a more general search
16:41:31 <LoganCapaldo> I should'v believed conal
16:41:43 <conal> omnId: yes.  i before f, for composability.
16:41:51 <omnId> newsham: I don't think foldr (.) id is named anywhere.
16:42:02 <ddarius> omnId: It's mconcat.
16:42:08 <omnId> oh?
16:42:13 <ddarius> Or was before this whole "Endo" thing.
16:42:19 <conal> :)
16:42:28 <omnId> @src Endo mconcat
16:42:28 <lambdabot> Source not found. :(
16:42:37 <phlpp> omnId: cool, that was the reason
16:42:41 <phlpp> why he terminated
16:42:41 <LoganCapaldo> Endo was the little kid from reboot
16:42:47 <conal> @src Control.Applicative.Endo mconcat
16:42:48 <lambdabot> Source not found. Do you think like you type?
16:42:48 <LoganCapaldo> no wait
16:42:50 <phlpp> it's good to handle [] ;_
16:42:53 <LoganCapaldo> he was Enzo
16:42:55 <conal> :p
16:43:03 <omnId> Enzo Matrix
16:43:19 <LoganCapaldo> and Dot Matrix :)
16:43:43 <omnId> Mike the TV :D
16:43:58 <newsham> omnId: how about foldr (.) id (replicate n f)   ?
16:44:14 <conal> btw, these "composable editors" (first, second, onHead, onElt, fmap, etc) is what DeepArrow is about.
16:44:23 <conal> Some examples: http://darcs.haskell.org/packages/DeepArrow/doc/html/Control-Arrow-DeepArrow-Examples.html
16:44:26 <lambdabot> http://tinyurl.com/24aunc
16:44:43 <omnId> what's the Endo deconstructor?
16:45:01 <conal> appEndo, i think
16:45:05 <omnId> @type appEndo . mconcat . map Endo
16:45:07 <lambdabot> forall a. [a -> a] -> a -> a
16:45:15 <newsham> ?let nth n f = foldr (.) id (replicate n f)
16:45:19 <lambdabot> Defined.
16:45:56 <newsham> > (nth 6 (\x -> [1] ++ zipWith (+) x (drop 1 x) ++ [1])) [1]
16:45:58 <lambdabot>  [1,6,15,20,15,6,1]
16:46:04 <omnId> conal: since newtypes vanish at runtime and map Endo becomes map id, does the compiler remove it, do you know?
16:47:08 <conal> omnId: i'm pretty sure the constructor and deconstructor vanish during compilation.
16:47:34 <omnId> does it reduce (f . map id) -> f?
16:47:45 <conal> btw, Endo can be interpreted as partial info about values.
16:48:07 <conal> omnId: i don't know.  probably depends on whether there's a RULE somewhere saying so.
16:48:20 <conal> omnId: if not, you could add one.
16:49:46 <conal> omnId: something like {-# RULES  "mapId" map id = id #-}
16:51:37 <omnId> the DeepArrow haddock has source links for each function!
16:52:21 <conal> yep.  i always do that.  via a helper makefile .inc called "cabal-make".
16:52:33 <conal> @wiki Cabal-make
16:52:33 <lambdabot> http://www.haskell.org/haskellwiki/Cabal-make
16:53:32 <conal> it also makes a "user comments" links per module.
16:53:50 <conal> and automatically subscribes me to all of the comment pages.
17:05:39 <phlpp> @hoogle split
17:05:39 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
17:05:39 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
17:05:39 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
17:05:43 <phlpp> hm
17:06:10 <phlpp> how to split a string into [String] by using 'whitespace' as a 'delimiter'
17:06:14 <omnId> words
17:06:18 <phlpp> k
17:06:22 <omnId> > words "quick brown fox"
17:06:23 <lambdabot>  ["quick","brown","fox"]
17:06:26 <phlpp> > words "foo bar foobar"
17:06:27 <lambdabot>  ["foo","bar","foobar"]
17:06:27 <phlpp> cool
17:06:36 <phlpp> so i'll optimize my randomQuote thing
17:06:47 <phlpp> that just one word from the whole string is looked up
17:07:31 <phlpp> otherwise i have to many failed calls and it's possible to get two times the same string
17:07:45 <phlpp> but actually i got one real problem
17:08:07 <phlpp> that is, there should be a pause, like 3 seconds, between the calls.
17:09:12 <newsham> anyone know if there is online footage of O'Sullivan's Haskell talk at dna lounge?
17:09:27 <omnId> phlpp: flood protection
17:09:28 <omnId> ?
17:10:14 <phlpp> omnId: something like this. at the moment, he's reacting on EVERY message.
17:10:28 <phlpp> so he should just react every 3-5 seconds on one message
17:10:34 <omnId> phlpp: just make the quotes only recognize things that start with !quote
17:10:58 <phlpp> hehe, that's too simple ;)
17:11:06 <omnId> KISS
17:11:07 <phlpp> in fact the point IS that he reacts on _everything_
17:11:23 <phlpp> and he quotes a random string out of old logs
17:11:37 <phlpp> that leads to many funny situations, but as i stated before, he spams like hell
17:11:42 <omnId> phlpp: you could make him not say anything if there are no matches.
17:12:02 <phlpp> hm, yeah
17:12:04 <phlpp> i'll try
17:13:04 <hpaste>  omnId annotated "(no title)" with "phlpp" at http://hpaste.org/3397#a4
17:13:13 <timthelion> >:t Rectangle
17:13:33 <omnId> >:t is a very annoyed-looking face.
17:13:38 <allbery_b> <phlpp> in fact the point IS that he reacts on _everything_
17:13:46 <timthelion> how do I get the type?
17:13:52 <omnId> :t take
17:13:53 * allbery_b knows *people* who do that.  on mailing lists.
17:13:56 <omnId> @type drop
17:13:59 <newsham> > (nth 52 (\x -> [1] ++ zipWith (+) x (drop 1 x) ++ [1])) [1]
17:14:01 <lambdabot> forall a. Int -> [a] -> [a]
17:14:03 <lambdabot> forall a. Int -> [a] -> [a]
17:14:04 <timthelion> I tried :t in ghci and it didn't know
17:14:06 <lambdabot>  [1,52,1326,22100,270725,2598960,20358520,133784560,752538150,3679075400,1582...
17:14:10 <timthelion> @type Rectangle
17:14:11 <lambdabot> Not in scope: data constructor `Rectangle'
17:14:16 <timthelion> it told me that
17:14:19 <omnId> @index Rectangle
17:14:20 <lambdabot> Graphics.X11.Xlib.Types, Graphics.X11.Xlib
17:14:30 <omnId> do you have the right modules in scope?
17:14:45 <timthelion> so :load Graphics.X11?
17:15:04 <omnId> that'd unload whatever module you're working on, if any
17:15:18 <omnId> :m +Module will add it the your scope
17:15:25 <phlpp> hm
17:15:33 <phlpp> where to put that liftIO thing then, omnId ?
17:15:45 <phlpp> right before maybe?
17:15:49 <phlpp> applied with $ ?
17:16:13 <omnId> phlpp: oh, right.  randomQuote :: String -> IO (Maybe String), so put it on randomQuote
17:17:11 <omnId> privmsg :: String -> Net (), so you need liftIO (randomQuote pat) :: Net (Maybe String)
17:18:04 <conal> omnId: btw, what's this "Net" monad?
17:18:14 <omnId> type Net = ReaderT Bot IO
17:18:22 <omnId> in phlpp's code
17:18:34 <omnId> data Bot = Bot { ... }
17:18:41 <conal> omnId: thanks.
17:21:36 <fax> good evening
17:23:11 <fax> I started to write a Prolog in haskell but I lost all my code ;[
17:23:27 <opqdonut> use version control :)
17:23:44 <conal> fax: ouch! :(
17:24:57 <fax> I might try again, I've discoverd LogicT since then
17:25:39 <fax> it is super cool :D
17:25:42 <ddarius> It takes like an hour to write Prolog in Haskell.
17:26:00 <fax> ddarius: Took me over an hour to write the lexer..
17:26:01 <conal> ddarius: takes whom an hour?
17:26:12 <fax> I was working from the ISO standard though
17:26:48 <ddarius> Okay.  I'll give you that.  I was talking about "a" Prolog.
17:27:21 <fax> anyway I am just a beginner at haskell, I couldn't write a lot of code fast
17:27:57 <conal> fax: welcome & have fun!
17:28:15 <fax> :D
17:28:23 <geocalc> fax=<< why write a prolog clone ?
17:28:46 <fax> geocalc: What else would I spend my spare time doing? :p
17:28:55 <lament> you could write music!
17:29:00 <opqdonut> sounds like a nice project
17:29:19 <omnId> liftM geocalc (why the bind syntax?) -- :)
17:29:21 <fax> lament: I think that would be so cruel to others if I tried to write music :P
17:29:28 <fax> (I'm really bad at that)
17:29:33 <ddarius> You could paint.
17:29:39 <lament> then write a haskell program to write music for you.
17:29:42 <conal> fax: a possibly fun direction at some point: lambda-Prolog in Haskell.
17:29:43 <fax> yeah I like to paint..
17:29:47 <geocalc> a game as you know ogl fax
17:30:02 <ddarius> Yeah, Prolog sucks.
17:30:07 <fax> conal: hmm yeah, I will check out lambda prolog again
17:30:18 <ddarius> fax: Implement LolliMon.
17:30:27 <fax> conal: I was just thinking about making numbers unify easily and having not-unification
17:30:45 <fax> geocalc: I run out of ideas for a game :|
17:31:47 <fax> ddarius: interesting
17:32:23 <conal> fax: there's a relevant article: http://citeseer.ist.psu.edu/elliott90semifunctional.html.  but you could do it purely functionally.
17:32:24 <lambdabot> Title: A Semi-Functional Implementation of a Higher-Order Logic Programming Language -  ...
17:32:50 <geocalc> omnId=<< this is haskell mark ;)
17:33:12 <conal> i'd like to see Haskell's type class/instance system based on lambda-prolog
17:33:31 <conal> it already has many of the pieces.  Lambda-Prolog would round it out.
17:34:00 <ddarius> It doesn't even have all of Prolog yet.
17:34:26 <conal> ddarius: and yet it has bits beyond prolog
17:34:35 <conal> (first-order Prolog)
17:34:42 <ddarius> That doesn't take much effort.
17:34:54 <conal> ddarius: what doesn't?
17:35:06 <ddarius> Going beyond Prolog, especially only in parts.
17:35:40 <conal> ddarius: since it has, i suggest rounding up to Lambda-Prolog rather than rounding down to Prolog.
17:40:51 <omnId> @brain Are you pondering what I'm pondering?
17:40:51 <lambdabot> Well, I think so, Brain, but I can't memorize a whole opera in Yiddish.
17:42:57 <dons> :)
17:43:13 <opqdonut> :D
17:43:17 <opqdonut> @brain
17:43:17 <lambdabot> But where will we find an open tattoo parlor at this time of night?
17:43:30 <opqdonut> @protontorpedo
17:43:31 <lambdabot> why haskell over say smalltalk
17:43:37 <opqdonut> @protontorpedo
17:43:38 <lambdabot> scheme, lisp, php, python, perl, tcl, al banned
17:43:54 <fax> @protontorpedo
17:43:54 <lambdabot> I hear from an essay by E raymod that perl is shitty for large projects
17:44:04 <fax> who is protontorpedo?
17:44:12 <mauke> a troll
17:44:24 <Cale> heh, GHC's devel cycle is pretty much perfectly misaligned with Ubuntu's.
17:44:38 <ddarius> Cale: I thought that this was well known.
17:45:01 <mauke> nicks: ramserver, shemale_magic, big-ego-guy, star-trekio, merlyns_undersdy, dreamgirl_pakin, evilgod99, magic_user, hardeharrHArr, If_it_isnt_scots, battle_rodent, gavino, gavino1
17:45:07 <Cale> It's as if they've set it up to guarantee that the version in Ubuntu will be out of date as soon as possible after release.
17:45:10 <mauke> ids: n=gschuett, n=bo, n=g, n=gavin, n=anonym, n=Administ
17:45:15 <Adamant> @b52s
17:45:15 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
17:45:24 <Adamant> I'm a one trick pony
17:45:26 <fax> mauke: How do you know that's all the same guy ? :o
17:45:52 <mauke> most of them use "gavin schuett" somewhere
17:46:14 <mauke> and his behavioral range is limited
17:46:57 <dons> and he used only 4 ip addresses over several years
17:47:08 <dons> often with the same id , so you could link it together
17:47:11 <dons> haven't seen him this year, afaik
17:47:16 <Cale> runplugs: /tmp/MPtoGY7800.o: unknown symbol `base_GHCziBase_ZMZN_closure'
17:47:17 <ddarius> dons: Yes you have.
17:47:17 <Cale> hmm
17:47:18 <mauke> hosts: pool-71-10?-1??-??.lsanca.dsl-w.verizon.net, 208.201.11.51, 4.38.41.141, cpe-76-167-158-25.socal.res.rr.com, 147.21.16.3
17:47:29 <fax> mauke: Why are you stalking him?
17:47:34 <mauke> (most of those are from #perl)
17:47:44 <dons> fax, good to know your enemies
17:47:50 <opqdonut> "i'm not stalking, i'm merely observing"
17:47:52 <mauke> fax: I just keep notes of when I happen to see him (in #perl or #haskell)
17:47:54 <dons> mauke, do you have my list of his nicks/ids/ips in lambdabot?
17:47:59 <fax> hehe
17:48:02 <fax> how interesting
17:48:08 <Cale> Who is that?
17:48:09 <dons> i built up a pretty good list of this identities.
17:48:19 <fax> @protontorpedo
17:48:19 <lambdabot> look at smalltalk. they invented oo proramming
17:48:25 <mauke> dons: no, this is all from personal experience :-)
17:48:53 <dons> mauke: wow!
17:48:59 <dons> scroll down to 'troll' in this file, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
17:49:01 <lambdabot> http://tinyurl.com/mkqad
17:49:05 * sorear wonders how long it will be before someone writes a compiler for Haskell type programs
17:49:07 <Cale> dons: Do you happen to know what would cause runplugs to give that error?
17:49:25 <dons> Cale. hmm.
17:49:36 <dons> broken hs-plugins ?
17:49:41 <dons> grab the darcs repo?
17:49:48 <Cale> Probably. I'll try reinstalling everything :)
17:49:55 <sorear> Cale: you're missing the () datacon, version mismatch?
17:50:46 <Cale> gschuett is protontorpedo?
17:50:49 <dons> yep
17:50:56 <Cale> ah, okay
17:50:56 <dons> that seems to be his `real' name
17:51:09 <Cale> 18:16:57 <slava> gavino is werty's retarded cousin
17:51:09 <Cale> 18:17:21 <Quartus> That's a fact.  That's Gavin Schuett.  He's been here a couple of times.  Banned in #lisp.
17:51:09 <Cale> 18:17:44 <slava> my favorite post of his is in comp.lang.apl, asking if APL can be used for enterprise web applications.
17:51:26 <dons> that's the guy
17:51:35 <dons> on slava's list too
17:51:46 <Cale> 18:18:11 <slava> "Where are the free software APL intperpreters, manuals, webapps, appservers, databases? I mean you can do all kinda killer stuff with APL now SHOW ME tHe APPS!! "
17:51:47 <Adamant> isn't J used for some realtime stock ticker app that's connected to the web?
17:51:57 <fax> hahaha
17:52:25 <timthelion> could combo be made to work with layouts that have Eq a in their type definitions?
17:52:30 <dons> ?proton
17:52:31 <lambdabot> lazy makes macro not needed?
17:52:34 <dons> ?proton
17:52:34 <lambdabot> does huge or ghc have more stuff?
17:52:37 <dons> so many memories
17:52:38 <dons> ?proton
17:52:39 <lambdabot> as u scale and complexity grows?
17:52:56 <opqdonut> ?pronto
17:52:57 <lambdabot> Unknown command, try @list
17:53:02 <opqdonut> bah :)
17:53:02 <timthelion> oops, wrong chan
17:53:26 * Cale feels lazy. Is cabal-get ready yet?
17:53:50 * opqdonut feels sleepy. Is 4am reason enough to go to sleep?
17:54:07 <fax> hehe
17:54:35 <dons> cabal-install, yes, sort of
17:54:41 <dons> Cale, we've a few people using it.
17:54:49 <dons> cabal-setup is also nice (avoids using setup.hs, heaps faster)
17:56:11 <Saizan_> ?where cabal-install
17:56:12 <lambdabot> I know nothing about cabal-install.
17:57:05 <dons> darcs.haskell.org somewhere
17:57:16 <dons> it would be worth using by more than just bringert, dcoutts and me :)
17:58:27 <Saizan_> uhm i need the new Cabal
17:58:55 <dons> yep, you'll need 1.2 or 1.3
17:59:18 <dons> so don't jump unless you're prepared to live with bleeding code
18:00:49 <Saizan_> i just hope it builds with 6.6.1
18:04:15 <newsham> speaking of bleedinge edge, is 6.8 due soon?
18:05:39 <LoganCapaldo> And the rivers shall run red with blood
18:06:37 <Saizan_> yeah, i've some code that doesn't compile in 6.6.1!
18:06:41 <Cale> umm, where do I get the "pretty" library?
18:06:53 <Cale> It doesn't appear to be on hackage?
18:07:02 <LoganCapaldo> wow
18:07:07 <LoganCapaldo> Cale asked a question
18:07:14 <conal> does cabal-setup have a description somewhere?
18:07:17 <LoganCapaldo> this is an historic occasion
18:07:24 <Saizan_> http://darcs.haskell.org/libraries/pretty maybe?
18:07:26 <lambdabot> Title: Index of /libraries/pretty
18:07:27 <dons> in darcs, Cale. darcs.haskell.org/packages/pretty iirc
18:07:36 <geocalc> newsham=<< darcs is 6.9
18:07:38 <dons> conal, not that i know of. it has a --help menu
18:07:51 <newsham> err, i meant ghc6.8
18:07:52 <Cale> aha, good
18:07:58 <Cale> Someone should add that to Hackage
18:07:58 <conal> dons: good enough to get started.  do you know where to get it?
18:08:32 <Saizan_> http://darcs.haskell.org/cabal-setup
18:08:34 <lambdabot> Title: Index of /cabal-setup
18:08:43 <conal> Saizan_: thanks.
18:09:07 <Saizan_>   ?where+ everything d.h.o
18:10:29 <dibblego> ?hoogle ((a, b), c) -> (a, b, c)
18:10:30 <lambdabot> No matches, try a more general search
18:10:39 <dibblego> ?djinn ((a, b), c) -> (a, b, c)
18:10:39 <lambdabot> f ((a, b), c) = (a, b, c)
18:11:45 <dons> some things are on code.haskell.org too, Saizan_ :)
18:12:26 <geocalc> even in sf.net
18:13:02 <fax> geocalc: hey
18:13:20 <geocalc> yes
18:13:59 <fax> geocalc: have you written anything in haskell yet?
18:14:12 <geocalc> no
18:15:01 <reffie> what are you waiting for? :)
18:15:13 <Cale> @pl f ((a, b), c) = (a, b, c)
18:15:14 <lambdabot> f = uncurry (uncurry (,,))
18:15:32 <Cale> @pl f (a, b, c) = ((a, b), c)
18:15:32 <lambdabot> (line 1, column 13):
18:15:32 <lambdabot> unexpected "="
18:15:32 <lambdabot> expecting variable, "(", operator or end of input
18:15:38 <Cale> heh
18:15:41 <geocalc> i"m figthing with ghc errors now fax
18:15:43 <fax> :t uncurry
18:15:45 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:16:08 <Cale> :t uncurry (,,)
18:16:10 <lambdabot> forall a b c. (a, b) -> c -> (a, b, c)
18:16:28 <fax> :t uncurry id
18:16:29 <lambdabot> forall b c. (b -> c, b) -> c
18:16:35 <fax> :|
18:16:48 <Cale> uncurry is to (,) what foldr is to []
18:17:09 <Cale> :t foldr
18:17:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:17:15 <Cale> :t uncurry
18:17:16 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:17:19 <Cale> :t maybe
18:17:21 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:17:57 <Cale> They all take replacements for the constructors of the type, and apply those replacements throughout the structure.
18:18:19 <fax> ah
18:19:45 <geocalc> what do you use fax ?
18:19:57 <fax> What do you mean?
18:20:21 <geocalc> ghc huggs ... ?
18:20:26 <fax> ghc
18:20:33 * MyCatVerbs hugs ghc.
18:24:19 <Saizan_> compiling cabal 1.3 ==> fork bomb, installing 6.8 snapshots has corrupted my system, it seems
18:26:16 <Cale> heh, that's awesome
18:26:26 <Cale> 1.3?
18:27:20 <Saizan_> that's the version you get pulling from the repo
18:27:44 <Cale> I must have pulled from a different repo a few mins ago.
18:28:00 <geocalc> ghc jave a lot of fix todo before return to a usable state
18:28:27 <geocalc> s/j/h
18:28:54 <Saizan_> Cale: not d.h.o/cabal ?
18:29:23 <geocalc> cabal 1.3 here too
18:29:40 <Cale> darcs get --partial http://darcs.haskell.org/cabal
18:29:41 <lambdabot> Title: Index of /cabal
18:30:14 <Cale> But for some reason I ended up with 1.1.7, so I got the 1.2 branch.
18:30:37 <geocalc> how ?
18:31:03 <Cale> I have no idea
18:31:11 <geocalc> unpatch ?
18:33:16 <Cale> Doesn't really matter, 1.2 is fine with me :)
18:37:02 <timthelion> @src =
18:37:02 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:38:16 <timthelion> @src +
18:38:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:38:25 <fax> @src (=)
18:38:25 <lambdabot> Source not found. It can only be attributed to human error.
18:38:26 <Cale> @src (+)
18:38:27 <lambdabot> Source not found. I am sorry.
18:38:31 <Cale> @src Num
18:38:32 <lambdabot> class  (Eq a, Show a) => Num a  where
18:38:32 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:38:32 <lambdabot>     negate, abs, signum     :: a -> a
18:38:32 <lambdabot>     fromInteger             :: Integer -> a
18:38:37 <Cale> @src Eq
18:38:37 <lambdabot> class  Eq a  where
18:38:37 <lambdabot>     (==), (/=)   :: a -> a -> Bool
18:39:30 <timthelion> @src (==)
18:39:31 <lambdabot> x == y = not (x /= y)
18:39:40 <timthelion> @src (/=)
18:39:40 <lambdabot> x /= y = not (x == y)
18:39:46 <timthelion> wtf?
18:39:59 <fax> timthelion: an instance must implement one of them
18:40:00 <Cale> Those are default declarations
18:40:07 <timthelion> oh
18:40:37 <timthelion> so a Type implaments a class for itself?
18:40:41 <Cale> yeah
18:40:49 <Cale> instance Eq Bool where
18:41:01 <timthelion> hmm intersetting
18:41:02 <Cale>   True == True = True
18:41:09 <Cale>   True == False = False
18:41:11 <Cale> etc.
18:41:16 <timthelion> lol
18:41:23 <Olathe> True = False == False, too.
18:41:43 <timthelion> is there a way for a function deffinition to say that order doesn't matter?
18:41:48 <Cale> But that's not a meaningful declaration
18:41:58 <Cale> um
18:41:58 <timthelion> so that you wouldn't have to define False == True = False
18:42:12 <Cale> No.
18:42:32 <Cale> However, you could define the two True cases and then everything else would be False
18:42:35 <Cale>   True == True = True
18:42:40 <Cale>   False == False = True
18:42:46 <Cale>   _ == _ = False
18:42:55 <timthelion> hehe
18:43:29 <Cale> However, the instance for Bool is most likely derived.
18:43:35 <dibblego> would you write that code? instead of the non-overlapping pattern version?
18:43:50 <Cale> dibblego: hm?
18:44:00 <Cale> @src Bool
18:44:00 <lambdabot> data Bool = False | True deriving (Eq, Ord)
18:44:11 <dibblego> well, those patterns overlap; which would you prefer to write for real?
18:44:49 <Cale> In general it depends how many cases, I suppose.
18:44:50 <timthelion> how does deriving work?
18:45:06 <scook0> timthelion: special magic :)
18:45:12 <LoganCapaldo>  I think @src is lying
18:45:15 <Cale> timthelion: There are some magical classes which Haskell knows how to write instances for based on the structure of your type.
18:45:22 <LoganCapaldo> bool deries enum too no?
18:45:29 <Cale> Yeah, it does.
18:45:30 <dibblego> LoganCapaldo, yes
18:45:37 <Cale> The @src plugin is often wrong.
18:45:46 <dibblego> @src is annoying
18:45:46 <lambdabot> Source not found. :(
18:45:57 <LoganCapaldo> a lying @src is better than no @src at all :)
18:45:58 <scook0> that said, you don't *have* to implement Enum using deriving
18:46:11 <LoganCapaldo> trueche
18:46:22 <Cale> trueche?
18:46:26 <scook0> though in this case it wouldn't buy you anything
18:46:28 <LoganCapaldo> rhymes with touche
18:46:33 <Cale> I suppose.
18:46:38 <LoganCapaldo> only it's true shay
18:46:42 <scook0> I thought it was a kind of quiche...
18:46:46 <LoganCapaldo> I just made it up
18:46:49 <scook0> :)
18:46:52 <LoganCapaldo> cause I'm cool like that
18:47:32 <Cale> cale@zaphod:~$ sudo cabal install containers
18:47:32 <Cale> cabal: user error (Unresolved dependencies: containers -any)
18:47:33 <Cale> heh
18:48:38 <Cale> oh, it's really not there...
18:49:15 <Cale> What's with all these packages which are in the darcs.haskell.org repository, but not hackage?
18:49:36 <LoganCapaldo> lazy developers?
18:49:45 <geocalc> base ?
18:50:03 <LoganCapaldo> the script that traverses darcs.haskell.org and adds packages to hackage hasn't been written yet?
18:52:38 <Saizan_> it's the split of base!
18:53:14 <LoganCapaldo> I don't know what 'base' is
18:53:18 <Cale> grumble. The array package doesn't build
18:54:06 <geocalc> use -v
18:54:48 <Cale> Data/Array/Base.hs:389:23: Not in scope: `Arr.numElements'
18:55:25 <geocalc> so hack
18:55:48 <Cale> yeah, I'm not sure what that's actually supposed to do, and it's apparently imported from GHC.Arr
18:56:33 <geocalc> mmh i can't help
18:56:38 <Cale> Oh well.
18:57:36 <LoganCapaldo>  GHC.Pirate.Arr
19:08:18 <Olathe> There's a Haskell pirate library ?
19:08:41 <shachaf> @quote pirate
19:08:41 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
19:09:21 <Olathe> I don't think any other language has a pirate library, so if Haskell had one, it would be the premier language for pirate-related tasks.
19:09:54 <fax> deomposeIntoEight
19:10:28 <shachaf> Olathe: Would http://mail.python.org/pipermail/python-dev/2003-August/037407.html count?
19:10:30 <lambdabot> Title: [Python-Dev] pirate (python+parrot), http://tinyurl.com/2ezbt7
19:11:52 <Olathe> No.
19:12:00 <Olathe> It can't even swab the decks.
19:15:52 <LoganCapaldo> import Deck.Swab
19:22:54 <olsner> well, you don't swab the deck, you replace your boat with a copy of your boat with the deck replaced
19:23:19 <Olathe> Of course.
19:23:44 <fax> what if no one has a reference to your previous boat?
19:23:45 <olsner> or, har har, you let the Garbage Collector take care of it
19:24:35 <olsner> unfortunately, Java has used up all funny garbage collector jokes
19:33:19 <LoganCapaldo> > (*) 3 4
19:33:21 <lambdabot>  12
19:33:42 <sorear> there's anything funny about java gc?
19:35:36 <LoganCapaldo> In soviet java, garbage collects you
19:37:42 <LoganCapaldo> @src succ
19:37:42 <lambdabot> Source not found. stty: unknown mode: doofus
19:37:44 <Olathe> Java has a huge collection of garbage.
19:37:48 <LoganCapaldo> ooo
19:37:52 <LoganCapaldo> that's cold lb
19:37:55 <LoganCapaldo> cold
19:38:30 <Olathe> It's been collecting garbage for years now.
19:38:34 <LoganCapaldo> lambdabot's cold as ice
19:45:28 <mrd> the best java gc is 'rm'
19:45:29 <shapr> @yow !
19:45:29 <lambdabot> Hello, GORRY-O!!  I'm a GENIUS from HARVARD!!
19:45:34 <mrd> @get-shapr
19:45:34 <lambdabot> shapr!!
19:45:51 <shapr> You called?
19:45:53 <LoganCapaldo> he's already here
19:46:13 <mrd> it worked
19:47:04 <Olathe> O-o
19:47:07 <Olathe> @get-pizza
19:47:07 <lambdabot> Unknown command, try @list
19:47:25 <Olathe> @get-Olathe
19:47:26 <lambdabot> Unknown command, try @list
19:48:33 <LoganCapaldo> good design would provide a @get command to which the person would be  aparameter ;)
19:56:04 <Cale> hmm, I take it it's just impossible to build binary-0.4 with 6.6.1?
19:56:26 <wli> Why is 6.6.1 needed?
19:56:30 <dons> yep. please use 0.3
19:56:34 <LoganCapaldo> Impossible? ha! Nothing is impossible, merely improbable!
19:56:41 <dons> or use the darcs repo
19:56:53 <dons> which has some patches and is backwards compatible to 6.2 iirc..
19:57:26 <Cale> Okay, I'll stick with 0.3
19:57:39 <dons> there's no need to depend on 0.4 really
19:57:46 <dons> since the functionality is identical
19:58:00 <Cale> cool
19:58:15 <Cale> wli: Because that's what I have installed.
19:58:18 <geocalc> what app ?
19:58:36 <wli> Non-answer. What breaks with more recent, why, etc.
19:58:39 <Cale> geocalc: I'm just rebuilding my stack of Haskell libraries.
20:00:10 <geocalc> Cale=<< about c2hs how you do ?
20:00:22 <Cale> geocalc: hm?
20:01:19 <geocalc> ity sau no list of modules here and abort
20:01:48 <geocalc> s/y/'s
20:02:14 <geocalc> no
20:03:02 <geocalc> it say no list of modules here and abort the build Cale
20:04:41 <Cale> $ sudo cabal install plugins
20:04:41 <Cale> All requested packages already installed. Nothing to do.
20:04:47 <Cale> $ sudo cabal-setup configure
20:04:48 <Cale> Configuring lambdabot-4.0...
20:04:48 <Cale> setup: At least the following dependencies are missing:
20:04:48 <Cale>     plugins -any
20:04:53 <Cale> nice
20:05:10 <Cale> geocalc: I have no idea
20:05:17 <geocalc> oops
20:06:08 <geocalc> i'll try this cabal install
20:09:28 <Cale> heh, cabal-setup appears not to consider locally installed packages, removing plugins and reinstalling it globally worked.
20:10:25 <geocalc> Cale=<< where is it ?
20:10:41 <Cale> http://darcs.haskell.org/packages/cabal-setup/
20:10:42 <lambdabot> Title: Index of /packages/cabal-setup
20:10:51 <Cale> http://darcs.haskell.org/packages/cabal-install/
20:10:52 <lambdabot> Title: Index of /packages/cabal-install
20:11:02 <Cale> http://darcs.haskell.org/packages/Cabal/
20:11:03 <lambdabot> Title: Index of /packages/Cabal
20:11:12 <geocalc> thanks
20:18:40 <Cale> grumble, all that and it still doesn't work
20:18:53 <Cale> I have plugins-1.0 installed.
20:21:23 * Cale tries the darcs version.
20:35:35 <wli> Heh, I should only hope it'll do anything of that sort for my beauty rest.
20:41:56 <wli> Ugarte: I'm not so concerned about generalized violent crime as hate crime -related attacks.
20:51:09 <dons> you have to use the darcs version, yep, Cale
20:55:43 <geocalc> dons=<<  about c2hs how you do to build it ?
21:00:00 <geocalc> if even dons don't answer who will ?
21:14:47 <qeny> Hey, I'm having this problem building xmonad, and I was wondering if it was something stupidly obvious that I'm missing:
21:15:22 <qeny> When I type "runhaskell Setup.lhs configure --prefix=$HOME", it stops at "configure: No greencard found";
21:15:52 <qeny> but at that part of the X11-extras configuration, it then goes on to "checking for gcc... gcc"
21:16:11 <qeny> So does anyone know what gives?
21:16:28 <thetallguy> sounds normal
21:16:58 <thetallguy> did you try the next step?
21:17:05 <qeny> omg. *hits head*
21:17:07 <qeny> you're right.
21:17:12 <thetallguy> i.e., build
21:17:24 <qeny> I was hoping it was something obvious and I was just being stupid.
21:17:28 <thetallguy> bads messages
21:17:58 <sorear> qeny: it checks for a whole bunch of things and warns about the ones you don't have because it can't know the actual dependancies
21:18:17 <sorear> qeny: the idea is that if the build falls over later you know what the problem could be
21:18:56 <geocalc> sorear=<<  about c2hs how you do to build it ?
21:19:27 <sorear> geocalc: you don't need c2hs for x11-extras
21:19:44 <geocalc> yes
21:19:50 <sorear> geocalc: also, you're asking the wrong person about c2hs issues
21:19:54 <sorear> @seen dcoutts
21:19:54 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 10h 15m 41s ago.
21:20:05 <sorear> I've never even used it
21:20:15 <qeny> anyway, now building xmonad-0.4 is giving me an error, but maybe it's because I don't currently have X11-1.2.3 installed, which is required, right?
21:20:35 <sorear> right, you need the X11 package
21:21:11 <qeny> well, I have it; X11-1.2.1
21:22:00 <sorear> qeny: can you @paste the error message?
21:22:01 <sorear> @paste
21:22:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:22:43 <geocalc> it's needed for some packages sorear anyway i'll talk to dcoutts so
21:22:52 <qeny> XMonad.hs:67:5:
21:22:52 <qeny>     No instance for (Read Rectangle)
21:22:52 <qeny>       arising from the 'deriving' clause of a data type declaration
21:22:52 <qeny>       at XMonad.hs:67:5
21:22:52 <qeny>     Possible fix: add an instance declaration for (Read Rectangle)
21:22:53 <qeny>     When deriving the instance for `Read ScreenDetail'
21:23:10 <sorear> ah yes, you need 1.2.3
21:23:54 <qeny> Indeed.. But there are added complications!
21:24:09 <qeny> ghc-pkg list
21:24:09 <qeny> /usr/lib/ghc-6.6.1/package.conf:
21:24:09 <qeny>     Cabal-1.1.6.2, X11-1.2.1, base-2.1.1, filepath-1.0, (ghc-6.6.1),
21:24:09 <qeny>     haskell98-1.0, mtl-1.0.1, parsec-2.0, readline-1.0,
21:24:09 <qeny>     regex-base-0.72, regex-compat-0.71, regex-posix-0.71, rts-1.0,
21:24:10 <qeny>     stm-2.0, template-haskell-2.1, unix-2.1
21:24:12 <qeny> /home/qeny/.ghc/x86_64-linux-6.6.1/package.conf:
21:24:13 <sorear> also, the @ on @paste is VERY important - irc has a number of serious flaws for dealing with large quantities of data, so you *really* want to use an out-of-band mechanism like hpaste
21:24:14 <qeny>     X11-1.2.3, X11-extras-0.4
21:24:22 <Olathe> Is there a way to sort a list if it's Ord, but not sort if it's not ?
21:24:34 <sorear> Olathe: No.
21:24:39 <Olathe> Bah.
21:24:53 <sorear> qeny: what about that list?
21:25:09 <sorear> qeny: clean maybe?
21:25:19 <qeny> the added complication is that I have X11-1.2,3 in one place, but X11-1.2.1 in another.
21:26:15 <sorear> qeny: I think with recent cabals you need to pass --user to configure as well (don't forget to clean first)
21:26:57 <qeny> okay, will do that; what command do I use to clean? and incidentally, what does clean do?
21:27:32 <sorear> runhaskell Setup clean, and delete all the cache files (I know, it's a bit of a sad situation)
21:27:47 <geocalc> why --user sorear
21:28:10 <geocalc> ?
21:28:52 <sorear> geocalc: to avoid nasty dep problems, cabal refuses to use user-installed packages if it thinks the package is going to be globally installed
21:29:18 <geocalc> mmh ok
21:30:14 <qeny> So I just did "runhaskell Setup.lhs clean; runhaskell Setup.lhs configure --user --prefix=$HOME; runhaskell Setup.lhs build", but I get the same error; would it help to clean and rebuild the X11 or X11-extras with --user passed to configure?
21:30:50 <geocalc> build -v qeny
21:33:12 <qeny> with build -v I get the same error message as before, no new information..
21:33:56 <qeny> hrm.. actually..
21:33:58 <geocalc> so hack xmonad
21:34:14 <qeny> It says that it's using X11-1.2.3..
21:35:03 <qeny> Ah, I'm not sure that messing around with xmonad will help, because if there was a real problem, other people would be having it.
21:35:19 <geocalc> hide it and retry just in case
21:36:46 <qeny> hide what? you mean try building with "-v"?
21:37:23 <dons> qeny: what error?
21:37:33 <dons> and maybe ask in #xmonad :) --> next door
21:37:35 <sorear> qeny: what are you building?
21:37:53 <geocalc> sorry hide X11 1.2.3 and expose the old
21:37:55 <sorear> qeny: focus on getting x11-extras working with x11 1.2.3 FIRST
21:38:03 <sorear> qeny: THEN touch xmonad
21:38:06 <qeny> xmonad-0.4; the error is "No instance for (Read Rectangle)" in XMonad.hs
21:38:21 <dons> right, so that's when you're compiling against an old X11-extras
21:38:30 <qeny> probably!
21:38:31 <dons> usually because you've not cleaned xmonad before rebuilding
21:38:33 <geocalc> dons=<<  about c2hs how you do to build it ?
21:38:43 <dons> geocalc: ask dcoutts, he's the maintainer
21:38:57 <dons> qeny: the other option is that you didn't get X11-extras 0.4 built and installed?
21:39:19 <sorear> geocalc: It's bad form to ask a question of a specific person unless a) the information is fairly esoteric b) you KNOW that person knows
21:39:29 <sorear> s/KNOW/know/
21:39:37 <dons> sorear is #haskell police today, it seems :)
21:39:52 <geocalc> hehe dons you are a big boss here you should know
21:40:08 <dons> i don't use c2hs very much though. i remember building it from a makefile
21:40:23 <qeny> I had X11-extras 0.4 built and installed..
21:40:34 <dons> ok. good. and then you cleaned the xmonad build dir?
21:40:35 <qeny> what was wrong with uppercase KNOW, sorear?
21:40:43 <sorear> qeny: wrong emphasis
21:40:45 <geocalc> mmh nice dons
21:40:45 <qeny> heh
21:40:46 <dons> before configure/build/install ?
21:41:01 <sorear> qeny: gotta remember to take lots of deep breaths as #haskell police :P
21:41:08 <dons> sorear: :)
21:41:11 <dons> ?yow!
21:41:12 <lambdabot> If a person is FAMOUS in this country, they have to go on the ROAD for
21:41:12 <lambdabot> MONTHS at a time and have their name misspelled on the SIDE of a
21:41:12 <lambdabot> GREYHOUND SCENICRUISER!!
21:41:14 <dons> zippy knows all
21:41:33 <qeny> I don't understand the lambdabot.
21:41:43 <sorear> Nobody does.
21:42:01 <geocalc> hehe
21:42:08 <dons> qeny: so your error then, if you've X11-extras 0.4, is almost certainly due to not running `clean' in the xmonad dir, in my experience.
21:42:17 <sorear> She practically has sentient cruft.
21:42:21 <dons> its a really annoying ghc buglet, where it doesn't trigger recompilation when a package changes
21:43:14 <qeny> Hmm. I think I did run clean and rebuild after installing X11-extras 0.4. but I might have installed X11-extras 0.4 before X11-1.2.3, which might have been a problem?
21:44:14 <qeny> !! It's working now.
21:44:22 <qeny> The problem has been solved:
21:44:24 <sorear> yay!
21:44:52 <qeny> I recompiled everything in the right order, X11, then X11-extras, then xmonad. Doing it in any other order doesn't work, right?
21:46:00 <dons> right.
21:46:04 <geocalc> @hoggle Data.ByteString.Base
21:46:05 <lambdabot> No matches, try a more general search
21:46:09 <dons> they depend on each other
21:46:18 <dons> glad that worked, qeny
21:46:22 <geocalc> @hoggle Data.ByteString
21:46:23 <lambdabot> No matches, try a more general search
21:46:28 <dons> any suggestions on how we could make sure people get the order right?
21:47:05 <qeny> me too. *now proceeds to edit Config.hs*
21:47:07 <geocalc> @src Data.ByteString.Base
21:47:07 <lambdabot> Source not found. That's something I cannot allow to happen.
21:47:40 <qeny> hrm.. I think that doing it in that order might be obvious.
21:48:31 <qeny> But, I think there's an error on the hackage site.
21:48:52 <geocalc> ?
21:49:09 <qeny> It says that xmonad-0.4 only requires X11-1.2.1, but doesn't it require X11.1.2.3?
21:49:26 <dons> not that i know of
21:49:39 <dons> it says in the .cabal file the minimum version it needs
21:50:28 <qeny> hrm, okay.
21:50:56 <geocalc> where is Data.ByteString.Base ?
21:51:06 <dons> ?source Data.ByteString.Base
21:51:06 <lambdabot> Data.ByteString.Base not available
21:51:09 <dons> ?source Data.ByteString
21:51:09 <lambdabot> Data.ByteString not available
21:51:14 <dons> ?source Data.List
21:51:14 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
21:51:18 <dons> next to that :)
21:51:37 <geocalc> thanks dons
21:53:05 <sorear> qeny: so, how do you like xmonad?
21:53:57 <mgsloan> no cyclic modules seems like a rather bad restriction..
21:53:59 <qeny> I really like xmonad.. I like it better than any other window manager.
21:54:03 * mgsloan too
21:54:43 <ddarius> mgsloan: Cyclic modules are allowed.  Mandated by the standard even, but neither GHC nor Hugs (nor NHC if I remember correctly) supports them well.
21:54:54 <ddarius> It's possible in GHC at the very least, if annoying.
21:54:59 <wli> .hi-boot etc.
21:55:10 <sorear> mgsloan: it's not as big a deal as it seems, because cyclic modules gum up the human brain almost as well as they gum up ghc
21:55:37 <qeny> What *are* cyclic modules?
21:55:44 <sorear> jhc supports cyclic modules transparently, but you'd use less time just writing the .hs-boot files yourself and invoking ghc
21:55:55 <sorear> qeny: module A { import B}  module B { import A }
21:56:32 <mgsloan> hrmm
21:56:51 <qeny> so that if either are used, both are necessary?
21:56:53 <mgsloan> that's interesting that it's an implementation issue and nto a design thing
21:57:47 <mgsloan> the main issue is that it's quite possible to have quite separate sets of code, that are codependent
22:07:28 <geocalc> mgsloan=<< alex of hackage need alex a funny cyclic design ;)
22:09:37 <mgsloan> ahh, huh
22:12:40 <TSC> The new Project Euler problem is pretty simple
22:20:16 <geocalc> ?go haskell Data.ByteString.Base
22:20:18 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString-Base.html
22:26:12 <wli> I'm still stuck on #152 or something.
22:26:33 <wli> The sum of reciprocals of squares of integers problem.
22:26:40 <TSC> That one is too hard for me too
22:26:48 <TSC> So I stick to the easy problems (:
22:28:34 <geocalc> ok one easy problem is how install the file linkedup in my ghc ?
22:38:02 <qeny> What is the file linkedup?
22:38:20 <geocalc> ?go haskell Data.ByteString.Base
22:38:21 <TSC> Bytestring?
22:38:22 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString-Base.html
22:38:52 <geocalc> neede for zlib
22:38:58 <geocalc> d*
22:39:37 <sorear> geocalc: downgrade ghc or fix zlib yourself
22:39:54 <sorear> bytestring internals have changed
22:39:55 <geocalc> ho no
22:44:32 <geocalc> dcoutts again
22:49:56 <wli> Isn't there a native Haskell zlib floating around somewhere?
22:50:16 <sorear> yes, andrew coppin wrote one
22:50:19 <sorear> but why?
22:50:56 <wli> I thought it was igloos; the predecessors IIRC were all FFI bindings.
22:51:41 <sorear> igloo may have written one too
22:51:51 <sorear> in any case, libz.so exists
22:52:12 <sorear> rewriting it would produce something significantly buggier and slower at much higher cost
22:52:13 <wli> This is native, 100% Haskell, not an FFI binding?
22:52:20 <sorear> doesn't seem like much of a win to me
22:52:41 <newsham> anyone have recommendations in this list?  http://homepages.cwi.nl/~atanasso/ref#books
22:52:42 <lambdabot> Title: PLT Online
22:53:02 <wli> sorear: Depends on if you're experimenting with modifications to the compression algorithm or not. ;)
22:53:03 <newsham> (other than the obvious spj implementing functional languages recommend)
22:54:11 <wli> sorear: Then having native Haskell reimplementations make a huge huge difference.
22:54:52 <sorear> wli: it also kinda breaks compatibility with all the existing .gz files...
22:55:28 <geocalc> ?
22:55:31 <wli> sorear: Hm? Choice of dictionaries shouldn't do that.
22:55:39 <mgsloan> compatibility shmamadability
22:55:40 <Eelis> why is   let { c | foo = 3; c | bar = 5 }  not allowed?
22:57:07 <geocalc> Eelis=<< think
22:57:13 <dmwit> Eelis: Are you talking about that literal syntax, or did you de-indentation it for IRC?
22:57:33 <Eelis> dmwit: i'm talking about that literal syntax
22:57:33 <dmwit> Eelis: Because it would be "let { c | foo = 3 | bar = 5 }".
22:57:41 <dmwit> or so
22:58:24 <Eelis> but  let { c x | foo = 3; c x | bar = 5 }  /is/ allowed (if you add a type annotation)
22:58:38 <newsham> > let { f x |x<5 = 4; f x|otherwise = 8} in f 2
22:58:40 <dmwit> > let c | False = error "bad" | True = error "good" in c
22:58:40 <lambdabot>  4
22:58:41 <lambdabot>  Exception: good
22:58:55 <Eelis> what newsham said.
22:59:09 <dmwit> oh, um, hm
22:59:17 <Eelis> so why does it not work for non-functions?
22:59:36 <dmwit> > let c | False = error "bad"; c | True = error "doubly bad" in c
22:59:36 <lambdabot>      Conflicting definitions for `c'
22:59:36 <lambdabot>     In the binding group for: c, c
23:01:18 <mgsloan> I guess one way for me to get around the cyclic modules would be to stick all the data types in one module, or something along those lines
23:04:06 <geocalc> mgsloan=<< cyclic is bad
23:05:33 <mgsloan> yeah.. I guess having all the data types in a module isn't so horrible either
23:07:22 <geocalc> ;)
23:08:33 <omg911> is there any way to define variables dynamically in haskell?
23:09:21 <dmwit> What do you mean?
23:09:53 <omg911> ok i'm creating a genetic programming app
23:10:06 <goalieca> omg911, haskell does not have states
23:10:07 <omg911> in the program tree there are undeclared variables
23:10:23 <omg911> i want to set them some how so no error is reported
23:10:39 <omg911> it's like making a mini evulator
23:10:56 <omg911> but there are undecleared variables i want to set to some specified value
23:11:20 <dmwit> Maybe you want the Reader monad, with some appropriate environment mapping?
23:11:29 <dmwit> i.e. maybe a Data.Map String Value or so.
23:12:53 <omg911> hmm i'll give that a try
23:23:35 <wli> yitz posted an update to his derangement code but it's still not working that I can tell.
23:24:13 <wli> He produces 265 elements for derangements "quagga" of which 126 are distinct when there should be only 29.
23:24:46 <wli> (All of which should be distinct.)
23:25:34 <dmwit> He may assume that his input xs has (nub xs == xs) or so?
23:26:06 <wli> Then it's not useful, since the output is only interesting when that's not the case.
23:29:38 <wli> His code has derangements "abca" == ["bcaa","baac","caab","caba","acab","aabc","acba"]
23:29:50 <wli> There's an obvious problem there.
23:31:56 <wli> It seems to work for "abc" and "abcd"
23:32:28 <dmwit> Does (length (derange "abcd") == length (derange "abca"))?
23:32:33 <dmwit> If so, I'd consider this case closed.
23:33:35 <wli> Yeah. It's pretty much ignoring equality between the list elements.
23:54:31 <sjanssen> @remember qwe1234 haskell type classes smell like c++ concepts.
23:54:32 <lambdabot> Done.
23:54:44 <ddarius> He's quick.
23:56:11 <wli> I've not followed C++ and am not sure I want to .
