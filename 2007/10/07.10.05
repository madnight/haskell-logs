00:03:07 <misterbeebee> @let evens l = case l of [] -> []; (x:xs) -> x:( odds xs) where odds l = case l of [] -> []; (_:xs) ->  evens xs
00:03:08 <lambdabot> <local>:9:0:     Warning: Pattern match(es) are overlapped              In th...
00:03:16 <misterbeebee> (from a tutorial)
00:03:16 <misterbeebee> > liftM2 (,) evens (evens . tail) "abcdef"
00:03:17 <lambdabot>  ("ace","bdf")
00:04:09 <omnIdiot> cool, ((->) r) saves the day once again!
00:04:17 <takamura> hi
00:04:44 <omnIdiot> hello
00:04:52 <ac> @hoogle liftM2
00:04:53 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
00:04:53 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:05:13 <misterbeebee> Am I obligated to understand the output of @pl, or is it acceptable etiquette to privately run my messes through @pl before I share the result? :)
00:05:34 <ac> misterbeebee: that's the most concise yet!
00:05:48 <omnIdiot> ac: it requires 'evens', though
00:05:52 <misterbeebee> ac: if you take the definition of evens
00:05:54 <misterbeebee> yeah
00:06:32 <ac> :)
00:06:36 <omnIdiot> > takeWhile (not . null) . map (take 1) . iterate (drop 2) $ "abcdef"
00:06:37 <lambdabot>  ["a","c","e"]
00:07:55 <omnIdiot> >  map head . takeWhile (not . null) . iterate (drop 2) $ "abcdef"
00:07:56 <lambdabot>  "ace"
00:08:12 <omnIdiot> evens = map head . takeWhile (not . null) . iterate (drop 2)
00:11:44 <nornagon> > iterate (drop 2) "abcdef"
00:11:46 <lambdabot>  ["abcdef","cdef","ef","","","","","","","","","","","","","","","","","","",...
00:11:47 <ac> ahg, are you kidding me? After all that I realized I don't need split stream if I just simplify my program
00:11:51 * dons -> hackathon. haskell ftw!
00:12:51 <ac> nevermind, I'll still need it later. Just not in this case
00:13:18 <ac> but later I'll want to replace "even" with "(%n)"
00:13:29 <ac> er "flip mod n"
00:13:57 <ac> can I just say: "% = `mod`"?
00:14:05 <omnIdiot> yep
00:14:22 <omnIdiot> > (`mod` 5) 17
00:14:24 <lambdabot>  2
00:14:41 <ac> I mean I want to define (%)...
00:14:45 <ac> > let (%) = `mod`
00:14:45 <lambdabot>  Parse error
00:14:51 <omnIdiot> (%) = mod
00:15:11 <ac> oh duh
00:15:15 <omnIdiot> though (%) is already taken as the Rational constructor.
00:15:18 <omnIdiot> > 3 % 2
00:15:19 <lambdabot>  3%2
00:15:30 <omnIdiot> @type 3 % 2
00:15:30 <ac> I figured it was already in use, otherwise it would already be that way
00:15:32 <lambdabot> forall t. (Integral t) => Ratio t
00:15:36 <DRMacIver> > let (%) = mod
00:15:36 <lambdabot>  Parse error
00:15:45 <DRMacIver> % is a capital letter.
00:15:49 <omnIdiot> > let (%) = mod in 17 % 5
00:15:50 <lambdabot>  2
00:15:58 <DRMacIver> Hm
00:16:01 <omnIdiot> DRMacIver: eh?
00:16:18 <omnIdiot> DRMacIver: operator constructors start with :
00:16:28 <DRMacIver> Or maybe it isn't? I thought it was a constructor for rationals. My mistake.
00:16:29 <araujo> dons, lambdabot left #haskell.es !
00:16:30 <araujo> :-(
00:17:22 <omnIdiot> @src Ratio
00:17:22 <lambdabot> data (Integral a) => Ratio a = !a :% !a
00:17:28 <omnIdiot> @src (%)
00:17:28 <lambdabot> x % y = reduce (x * signum y) (abs y)
00:17:42 <DRMacIver> Ah, of course it's not. It's part of the type class.
00:18:31 <DRMacIver> I claim immunity on grounds of not enough sleep (which admittedly grants me perpetual immunity if it's valid :) )
00:19:10 <omnIdiot> it's a "constructor" in the sense that it's a function that produces rationals, but it's not a Constructor; it can't be pattern-matched.
00:20:48 <DRMacIver> Right.
00:21:22 <ac> @hoogle ***
00:21:23 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
00:22:40 <omnIdiot> (Module.(??) is wrong, btw.  To prefixize qualified operators, use (Module.??))
00:22:56 <omnIdiot> > (Prelude.+) 1 2
00:23:04 <lambdabot>  3
00:23:21 <hpaste>  mlesniak pasted "small Currying problem" at http://hpaste.org/3096
00:23:41 <omnIdiot> (not .) . f1
00:24:01 <nornagon> @unpl
00:24:02 <lambdabot> Plugin `pointful' failed with: IRCRaised Lib/Pointful.hs:39:24-51: Non-exhaustive patterns in lambda
00:24:03 <nornagon> er.
00:24:08 <mlesniak> omnIdiot: Thanks, this is totally unintuitive ;-)
00:24:09 <nornagon> @unpl (not .) . f1
00:24:09 <lambdabot> (\ d g -> not (f1 d g))
00:24:42 <nornagon> @pl \f1 -> (not .) . f1
00:24:42 <lambdabot> ((not .) .)
00:25:27 <omnIdiot> mlesniak: ((not .) . f1) x y = ((not .) (f1 x) y {- by the def of (.) -}  = (not . f1 x) y {- by applying the section -}  = not (f1 x y) {- by the def of (.) -}
00:25:39 <omnIdiot> oops, dropped a paren
00:25:52 <mlesniak> omnIdiot: Thanks for the help, now it's moire clear
00:28:02 <omnIdiot> you might also define (f .: g) x y = f (g x y)
00:28:36 * mlesniak nods
00:46:33 <misterbeebee> ?seen fax
00:46:33 <lambdabot> fax is in #haskell and #perl6. I last heard fax speak 1h 14m 51s ago.
00:46:57 <misterbeebee> fax, is your screenshot from emacs or from h2ps output? http://img120.imageshack.us/img120/3581/picture1ms8.png
00:48:13 <ttfh> that screenshot looks nice
00:48:34 <ttfh> can ghc/hugs understand lambdas and arrows in unicode?
00:49:48 <omnIdiot> I know at least a couple compilers understand those characters.  GHC might, and I think JHC does.
00:52:13 <misterbeebee> hmmm. looks like haskell-mode tries to compose mathy text into symbols: http://malsyned.net/repos/dotemacs/haskell-mode-2.3/haskell-font-lock.el
00:52:15 <lambdabot> http://tinyurl.com/yrqmmv
01:02:47 <ttfh> is there some easy way to insert unicode characters in emacs, like Ctr-V u {hexadecimal number} in vim?
01:03:49 <ac> let's say....
01:03:54 <ac> > let randomIntRs g range = map (flip mod range) (randoms g)
01:03:54 <lambdabot>  Parse error
01:04:03 <ac> aarhg!
01:04:44 <ac> @let randomIntRs g range = map (flip mod range) (randoms g)
01:04:49 <lambdabot> Defined.
01:04:52 <ttfh> aha, there's "ucs-insert"
01:05:16 <ac> > replicate 4 (take 4 (randomIntRs g 10))
01:05:16 <lambdabot>   Not in scope: `g'
01:05:46 <ac> @let g = mkStdGen 10
01:05:51 <lambdabot> Defined.
01:05:53 <ac> > replicate 4 (take 4 (randomIntRs g 10))
01:05:55 <lambdabot>  [[7,2,5,6],[7,2,5,6],[7,2,5,6],[7,2,5,6]]
01:06:04 <ac> how do I make each of those lists have different numbers?
01:06:26 <MyCatVerbs> ac: by not using replicate.
01:06:28 <ac> I want to split the stream from (randomIntRs g 10) in to N streams
01:07:14 <andun> ttfh: check quoted-insert (C-q). (use read-quoted-char-radix to get hexadecimal numbers)
01:07:30 <MyCatVerbs> What, you want to split the random number generator? Standard functionality in System.Random - check the haddock docs. Or something else?
01:11:31 <ac> MyCatVerbs: this is what I wanted: "randtest strm n = take n strm : randtest (drop n strm) n
01:11:35 <ac> "
01:11:59 <ac> no RandGen splitting necessary
01:12:42 <omnIdiot> @let chunk n = map (take n) . takeWhile (not.null) . iterate (drop n)
01:12:47 <lambdabot> Defined.
01:12:54 <omnIdiot> > chunk 4 (randomIntRs g 10)
01:12:56 <lambdabot>  [[7,2,5,6],[1,9,6,7],[0,5,2,6],[9,6,1,4],[2,0,1,6],[9,1,1,5],[5,7,6,9],[8,5,...
01:13:15 <quicksilver> ttfh: really inserting random unicode characters is up to your OS, not up to emacs
01:13:30 <ac> omnIdiot: thanks for generalizing that
01:13:35 <quicksilver> ttfh: true, emacs has some support for it. But the 'right' way is to use whatever input methods you OS/window system provides. emacs will support that.
01:16:10 <ttfh> hmm, I must have my encodings set up weird, emacs, vim and cat all have different takes on how to display the unicode character i just entered :-)
01:16:36 <quicksilver> well in the case of cat, and terminal vim, that's actually your terminal programs fault/responsibility
01:16:47 <quicksilver> terminal programs have a simple byte-stream interface to stdin
01:17:03 <quicksilver> the expected encoded is typically set by the locale
01:17:24 <quicksilver> in the case of a graphical program, there is normally a more sophisticated keyboard layer
01:17:31 <quicksilver> provided by X11, or whatever window system you use
01:17:49 <ttfh> right now I'm running putty to my home machine :-(
01:18:02 <quicksilver> ok, well now putty is in the loop too :)
01:18:12 <ttfh> and screen i guess?
01:18:17 <quicksilver> yup
01:18:22 <quicksilver> you need to run screen in UTF8 mode
01:18:32 <quicksilver> if you want to have a hope of unicode working through screen
01:18:51 <quicksilver> the interaction between charset, encoding, and input method is rather fiddly :P
01:19:39 <idnar> you need to configure PuTTY to use / expect the right charset, too
01:19:56 <idnar> I can't remember where in the options that is, but it shouldn't be too hard to find ;)
01:20:20 <ttfh> yes, I found that one
01:20:46 <quicksilver> and you need to bear in mind that screens 'TERM' is essentially 'trapped' to the TERM type in action when you launched screen
01:20:50 <quicksilver> well it's not quite that simple
01:21:03 <quicksilver> but you may well need to launch a new screen, from a terminal with the right option, with the right screen option
01:21:06 <ttfh> under Window->Translations
01:21:28 <ttfh> TERM is screen
01:21:33 <idnar> quicksilver: putting screen in utf8 mode doesn't affect TERM, does it?
01:22:05 <quicksilver> I'm actually not quite sure
01:22:08 <idnar> or did you mean LANG?
01:22:08 <ttfh> shouldn't it be enough to detach and attach again with -U?
01:22:11 <quicksilver> http://www.smop.co.uk/blog/index.php/2007/09/17/unicode-terminals-and-screen/
01:22:15 <lambdabot> Title: A simple matter of&#8230; ª unicode terminals and screen, http://tinyurl.com/2384e2
01:22:20 <quicksilver> ttfh: I didn't think that worked, but I'm not sure
01:22:41 <quicksilver> http://anti.teamidiot.de/nei/2007/02/irssi_putty_screen_unicode_utf/
01:22:43 <lambdabot> Title: Irssi, PuTTY, Screen & Unicode UTF-8 (anti), http://tinyurl.com/2cfdc2
01:22:56 <quicksilver> people find this confusing enough that there are plenty of blog posts about it :)
01:23:52 <DRMacIver> That looked like an ill-typed renaming to me...
01:24:07 <augustss> @seen heffalump
01:24:07 <lambdabot> heffalump is in #xmonad, #haskell and #darcs. I last heard heffalump speak 1h 52m 24s ago.
01:24:19 <Heffalump> 'lo
01:24:27 <augustss> hi
01:24:36 * Heffalump is at the hackathon
01:24:37 <augustss> Amex works at the hotel :)
01:24:41 <Heffalump> cool, thanks.
01:24:43 <ttfh> aha, so detaching/attaching doesn't work
01:24:56 <EvilTerran> not necessarily, DRMacIver. if he's in a typeclass that has a (Foo a => Foo ([]->a)) instance, it should be okay
01:25:05 <EvilTerran> *[b] -> a, rather
01:25:10 <quicksilver> ttfh: not according to that article, at least :)
01:28:22 <ttfh> finally, a lambda appears in emacs!
01:29:28 <Cale> Wow, Conway proved that there's a generalisation of the Collatz conjecture which is equivalent to the halting problem.
01:30:21 <DRMacIver> In what sense? Link?
01:30:58 <Cale> Given d in N, and a_i, b_i positive rationals, for 0 <= i < d, define g(n) = a_i n + b_i when n is congruent to i (mod d)
01:31:37 <Cale> There's a clever way to encode any Minsky machine as such a function, such that halting is equivalent to reaching a power of two.
01:32:02 <Cale> (under iteration)
01:32:29 <DRMacIver> Interesting.
01:35:05 <luqui> seconded: link?
01:37:27 <Cale> http://people.cs.uchicago.edu/~simon/RES/collatz.pdf -- this appears to contain information about it
01:37:46 <Cale> er, oh, it also appears to be incomplete
01:37:55 <Cale> hmm
01:39:25 <Cale> http://www.mcs.vuw.ac.nz/~downey/auckland_2005_collatz.ps seems to go over it, but it's in slide form
01:42:01 <EvilTerran> woo! it works!
01:42:16 * EvilTerran has a rudimentary allegro binding working now :D
01:42:20 <quicksilver> nice!
01:42:38 <quicksilver> I have a working 'zipper' for interactively editing my custom terms
01:42:39 <quicksilver> with a GUI
01:43:02 <quicksilver> once you get the hang of it zippers are really convenient
01:43:10 <EvilTerran> as in, i've successfully bound the library initialisation functions, the one to bring up a window, and the one to wait for a keypress ;)
01:43:30 <quicksilver> and you get a nice undo-list behaviour where your undo-list (of terms) is using sharing really nicely
01:44:05 <EvilTerran> now i've got the proof of concept out of the way, i can think about binding it properly :D
01:44:13 <quicksilver> :)
01:44:19 <EvilTerran> that sounds cool. i've been meaning to look at zippers at some point.
01:44:21 <quicksilver> out of interest, why would I use allegro?
01:44:29 <quicksilver> I don't know much about it, what are it's strong points?
01:44:39 <EvilTerran> (i think i've got the zippers paper sitting on my HD somewhere...)
01:45:15 <EvilTerran> eh, it was the graphics library i started on when i was programming in C
01:45:33 <EvilTerran> covers much the same ground as SDL
01:46:21 * quicksilver nods
01:46:48 <EvilTerran> it doesn't have an OpenGL dependency (which i vaguely recall SDL does)
01:47:55 <quicksilver> SDL doesn't have an openGL dependency afaik
01:48:04 <quicksilver> it might be able to use openGL as an accelerator in certain cases
01:48:09 <koala_man> it can be compiled without it
01:48:33 <EvilTerran> okay, never mind that then
01:49:19 <EvilTerran> looking at the SDL site (the code examples, even), they're really rather similar
01:49:24 * quicksilver nods
01:49:37 <quicksilver> SDL is 'mostly' just about input and blitting
01:49:43 <quicksilver> is allegro perhaps a bit higher level?
01:50:12 <lemmih_> It is.
01:52:14 <EvilTerran> seems likely. allegro's got things like blended drawing modes, rudimentary software 3d, quite a lot of clever audio stuff
01:52:51 <EvilTerran> unicode support, too
01:54:17 <nornagon> the clincher for SDL is the input stuff, i gather
01:54:36 <nornagon> I usually #include <SDL/SDL_gfxPrimitives.h> for doing stuff in SDL
01:54:46 <nornagon> it says something that line drawing routines are in a seperate library
01:54:57 <nornagon> it's simple directmedia layer, not simple doodling layer
01:55:08 <EvilTerran> yeah, allegro's line drawing and whatnot's all built in
01:56:40 <nornagon> allegro has quite a different mission to SDL
01:57:06 <EvilTerran> hmm
01:58:26 <nornagon> allegro is a game library, really
01:58:53 <EvilTerran> it's all in the name ;)
01:59:23 <EvilTerran> actually, i can't remember if the g is "game" or "graphics". the tagline's "A game programming library.
01:59:23 <EvilTerran> ", though
02:00:00 <EvilTerran> hrm... "int atexit (void (* function) (void));" <- how would you express this type as a foreign import type?
02:00:07 <luqui> OpenGL and SDL are essentially in a marriage as far as my uses
02:00:14 <nornagon> luqui: not really
02:00:16 <luqui> SDL can work without OpenGL though, of course
02:00:16 <nornagon> at all
02:00:23 <quicksilver> and vice versa..
02:00:23 <luqui> *as far as my uses*
02:00:29 <nornagon> SDL has very little to do with OpenGL...
02:00:40 <bringert> hello?
02:00:43 <MyCatVerbs> But everything to do with lemons.
02:00:48 <nornagon> yes
02:00:49 <EvilTerran> OpenGL's a bit of a pain without a higher-level library to handle all the platform-dependent stuff, though
02:00:54 <quicksilver> bringert: hello
02:01:00 <nornagon> it stands for Open Graphics Lemons, don'tcha know
02:01:04 <luqui> nevermind.  I was just saying the probability that if my program says #include <SDL.h> it will say #include <GL/gl.h> is very near 1
02:01:10 * EvilTerran currently has FunPtr (FunPtr (IO ()) -> IO CInt) for that type, but i'm not sure if that's right
02:01:16 <quicksilver> EvilTerran: GLUT seems good enough for me so far
02:01:22 <bringert> ah, there we go
02:01:27 <vincenz> k
02:01:28 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
02:01:29 * luqui really dislikes GLUT
02:01:37 <quicksilver> why?
02:01:39 <nornagon> luqui: you should be #including <SDL/opengl.h> or whatever
02:01:40 <MyCatVerbs> Graphical Lemon Utility Toolkit.
02:01:41 <luqui> no "on close" hook is one big reason
02:01:41 <lemmih_> quicksilver: GLUT doesn't play well with GHCI.
02:01:45 <EvilTerran> i'm slightly uncomfortable relying on a dead project, too
02:01:46 <quicksilver> that's true
02:01:50 <nornagon> because GL/gl.h isn't always in the default include path :)
02:02:04 <luqui> nornagon, I really should be using autoconf if you want to go that far
02:02:08 <nornagon> GLFW is the new GLUT
02:02:14 <nornagon> luqui: ew, autocrap
02:02:24 <MyCatVerbs> EvilTerran: dead project?
02:02:37 <nornagon> MyCatVerbs: GLUT is pretty much dead
02:02:43 <nornagon> last i checked
02:02:47 <EvilTerran> none of the GLUT derivatives have been updated recently
02:02:50 <quicksilver> I'm sure there reaches a point when GLUT isn't sufficient, but it has met all my needs to far
02:03:02 <quicksilver> it opens a window, it can do full screen, it gives me keypresses :)
02:03:06 <quicksilver> what else do I need?
02:03:14 <quicksilver> and it does all those things in pleasingly little code
02:03:18 <nornagon> I've hit GLUT's limitations before, which forced me to find GLFW
02:03:27 <nornagon> but i can't remember what it was exactly that I came up against :P
02:03:40 * luqui really likes SDL, even though it is low level
02:03:44 <luqui> for input that is
02:03:55 <EvilTerran> OpenGLUT was 2005, iirc, but is officially declared dead; FreeGLUT just hasn't been updated since 2003, and original GLUT since 2001
02:04:01 <luqui> the low-levelness is a virtue, because I don't need to architect my program in any particular way to use it
02:04:10 <nornagon> SDL isn't really low level as input goes
02:04:41 <luqui> nornagon, there are nits to pick in every one of my utterances, it seems
02:04:43 <nornagon> i think SDL can even give you unicode-encoded characters for keyboard input
02:04:54 <nornagon> I'm a pedant at heart :)
02:04:59 <luqui> :-)
02:05:06 <nornagon> sorry if you took offence; none was meant
02:05:11 <luqui> 'sok.
02:05:23 <luqui> to clarify what I meant, the interface has no associated architecture
02:05:28 <misterbeebee> in case anyone was following the saga... I couldn't get mathematical operator unicode symbols for haskell operators to show up properly in emacs, xemacs, or Emacs.app, but they work perfectly in Aquamacs Emacs.  http://img513.imageshack.us/my.php?image=haskellopsxb2.png
02:05:29 <lambdabot> Title: ImageShack - Hosting :: haskellopsxb2.png
02:05:42 <luqui> you loop and get every event, in one single place, and you are in charge of sending them to where they're wanted
02:06:04 <misterbeebee> (on Mac, obviously)
02:06:09 <nornagon> misterbeebee: does ghc even accept unicode characters in operators?
02:06:29 <quicksilver> yes, it does
02:06:34 <nornagon> neat.
02:06:40 * nornagon runs off to ghci to play
02:06:41 <quicksilver> it uses unicode classes
02:06:49 <quicksilver> if you're a member of the MATHOP class or whatever it's called
02:06:55 <quicksilver> you're a valid operator char
02:07:11 <misterbeebee> nornagon: note, in my picture, those aren't unicode in the program source, it's an emacs trick that displays  ">=" etc as a unicode character.
02:07:34 <nornagon> oh ah.
02:07:46 <MyCatVerbs> Hmmm. What about joystick interfaces and sound?
02:08:25 <nornagon> heh, that's pretty neat
02:09:01 <quicksilver> well the == sign looks to much like = for my taste
02:09:11 <quicksilver> I wonder why it isn't the same 'size' as /=
02:09:17 <quicksilver>  /= looks nice
02:09:37 <nornagon> Prelude> let (‚â•) = (>=) in 2 ‚â• 1
02:09:37 <nornagon> <interactive>:1:6: lexical error at character '\137'
02:09:40 <nornagon> ^- :<
02:09:59 <quicksilver> nornagon: that's odd. I'm sure people have said that works
02:10:05 <quicksilver> nornagon: try in a compiled file?
02:10:42 <luqui> is there any instance in Haskell where there is an ambiguity between = and == ?
02:10:49 <misterbeebee> yeah, that triple-bar is ugly and tiny... the pic is monaco font.  other fonts offer other options. Arial has a stupidly-tall triple-equal sign.
02:10:58 <EvilTerran> foo | bar == baz = ...
02:11:06 <EvilTerran> foo | bar = baz == ...
02:11:07 <luqui> righto
02:11:16 <luqui> also x == y = ...
02:11:19 <luqui> :-)
02:11:23 <luqui> nevermind
02:11:33 <quicksilver> misterbeebee: it was the constrast between == and /= in particular that surprised me
02:11:46 <quicksilver> misterbeebee: if only monaco's == was modelled on its /=
02:11:48 <EvilTerran> is that /= there the three-stroke one?
02:11:56 <Cale> x Ôºù y
02:12:01 <Zevv> Japsu awake ?
02:12:36 <misterbeebee> In the picture I posted? /= is 3 horizontal bars with a strike thru
02:12:55 <EvilTerran> i don't recall how they're all defined... does the unicode consortium prescribe how many strokes all the =-esque operators have?
02:13:26 <quicksilver> EvilTerran: I'm sure it does
02:13:42 <nornagon> quicksilver: ah, seems to work in a compiled file
02:13:47 <quicksilver> EvilTerran: the unicode description is more 'graphical' than 'semantic' if you see what I mean
02:13:48 <nornagon> sad that it doesn't work in ghci :(
02:14:13 <EvilTerran> it seems to vary a bit in that regard, quicksilver
02:14:26 <quicksilver> EvilTerran: it doesn't say 'this symbol means not equivalent' it says 'this symbol is composed of three horizontal lines with a bar across'
02:14:35 <quicksilver> EvilTerran: yes, it does vary a bit. But that's the main pattern.
02:15:11 <quicksilver> it does distinguish greek-lambda from math-lambda, say
02:15:20 <quicksilver> which is a semantic difference
02:15:28 <misterbeebee> correction: the pic is  not monaco. i can't find the font that I used for the snapshot. anyway, way past my bedtime. maybe later in the month my contribution to the Haskell community will be a survey of source-code fonts :)
02:16:24 <visof> what is the simple mean of morphism?
02:17:02 <DRMacIver> A function which preserves some sort of structure.
02:17:03 <quicksilver> visof: it is a category theory concept
02:17:18 <quicksilver> visof: curiously, it hardly has a meaning at all. it's very abstract.
02:17:29 <DRMacIver> Yes, there's also the category theory version. Which you consider simpler is up for debate. :)
02:17:31 <quicksilver> visof: categories are a collection of objects and morphisms
02:17:53 <quicksilver> visof: but what 'object' and 'morphism' mean is left largely to your imagination :)
02:17:59 <EvilTerran> it's like "calculus" in that regard - it *kinda* means something, and has a specific meaning in some fields, but it's all a bit wooly
02:18:06 <quicksilver> (or rather, they mean different things in different categories)
02:18:24 <quicksilver> visof: you might say 'a morphism is someting which links two objects'
02:18:38 <EvilTerran> (sometimes means "calculus of differences", sometimes just means "subject vaguely related to maths". sometimes means "little round stone", too...)
02:19:02 <visof> quicksilver what is the meaning of object?
02:19:13 <EvilTerran> it's a thingy! :D
02:19:21 <quicksilver> visof: that has no meaning at all. It's just the things you're talking about.
02:19:35 <quicksilver> visof: A category is a bunch of objects, connecting by morphisms
02:19:47 <quicksilver> visof: the only thing you know about morphisms is that you can join the together
02:20:41 * EvilTerran has gotten the impression from very brief research that a category is approximately a set with a transitive relation on it
02:21:10 <EvilTerran> (except it might not be a set -- class, maybe? i'm not sure how these things work exactly)
02:21:21 <DRMacIver> It's a lot easier if you start by thinking of a category as "some sets with a structure associated with them" and morphisms as "functions between those sets which preserve that structure"
02:21:45 <DRMacIver> So you could have the category of ordered sets, which consists of sets with an order relation on each of them, say <.
02:21:57 <DRMacIver> Then morphisms between those sets are functions f such that x < y implies that f x < f y
02:21:58 <EvilTerran> that reminds me, i was going to get http://www.amazon.com/dp/0262660717 out of the library
02:22:15 <DRMacIver> This is really what motivates all the more abstract definitions.
02:30:21 <ac> is there a shorter version of "concatMap (\x -> x) list"?
02:30:32 <dons> hackathon is underway!
02:30:37 <Heffalump> concat list
02:30:46 <kosmikus> happy hacking :)
02:30:52 <ac> man I'm stupid
02:31:01 <Heffalump> (\x -> x) = id, concatMap f list = concat (map f list), map id list = list
02:32:02 <EvilTerran> anyone familiar with c2hs about?
02:33:46 <EvilTerran> i've noticed that {# call ... #} acts as an expression, putting the foreign import decleration elsewhere, but {# fun ... #} requires an explicit type signature
02:34:33 <EvilTerran> and i was wondering what the normal approach is if you don't need any of {#fun#}'s functionality; putting in the type sig explicitly as a {#fun#}, or writing _ = {#call...#}
02:35:10 <Heffalump> dcoutts is just getting coffee, he might able to help when he's back
02:35:14 <EvilTerran> (i'm thinking the former's probably good practice, as explicit type sigs are a Good Thing for functions exported by your module)
02:35:26 <EvilTerran> righto
02:39:55 <dons> ?join #haskell-hac07
02:41:17 <quicksilver> DRMacIver: it is a lot easier, but then it really holds you back when you try to generalise
02:41:37 <quicksilver> DRMacIver: since you can't break out of believe that objects are always 'sets-with-structure'
02:42:33 <quicksilver> EvilTerran: it's a bit more than a transitive relation, since there might be more than one morphism between a pair of objects
02:42:59 <EvilTerran> um
02:43:25 <EvilTerran> okay. tell you what, i'll go get that book, and i'll get back to you when it makes a little more sense
02:43:25 <DRMacIver> quicksilver: I don't buy that. An inability to go from concrete motivations to abstractions is a sign of overly credulous learning.
02:43:33 <quicksilver> EvilTerran: certainly transitive relations are an example tjpigj
02:43:46 <DRMacIver> Everything you are told is a lie. Therefore if you are inable to discard old beliefs when they are no longer useful, you're doomed anyway.
02:43:59 <quicksilver> DRMacIver: what you say is true
02:43:59 <EvilTerran> an example rough?
02:44:07 <EvilTerran> though?
02:44:10 <quicksilver> EvilTerran: ...an example though :)
02:44:18 <quicksilver> fingers one key to the right, or something
02:44:38 <EvilTerran> i figured you'd drifted sideways by one, yeah. except for the first letter, apparently ;)
02:45:06 <quicksilver> EvilTerran: in fact a reflexive, transitive relation is a category with an most one morphism between any pair of objects
02:45:22 <quicksilver> DRMacIver: but I think you play the card too strongly
02:45:24 <EvilTerran> gotta be reflexive too? okay
02:45:41 <quicksilver> DRMacIver: when teaching I prefer to try to set the right kind of world-picture to start with
02:45:42 <EvilTerran> hm... college library doesn't have that book. i'll have to see if i can borrow it from the dept library
02:46:02 <quicksilver> and, speaking personally, the view of 'objects must be sets with structure' really held me back quite badly :)
02:47:18 <DRMacIver> quicksilver: I'm not advocating teaching an entire category theory course this way. :) My preferred mode of teaching is to start with concrete examples and then swiftly move up to the abstractions.
02:48:00 <DRMacIver> quicksilver: And the most useful way to do this is to start with examples, generalise these slightly (at which point you're at "Sets with structure"), give some more examples, oops our previous generalisation doesn't cover this, let's generalise some more.
02:48:36 <EvilTerran> hm. can't borrow as an undergrad. bother.
02:48:56 <DRMacIver> The abstractions need to be fed by concrete instances, and need to feed back into them in turn.
02:49:00 <quicksilver> DRMacIver: but I'd also have some early examples which aren't. Like partial orders.
02:49:08 <quicksilver> DRMacIver: and groups
02:49:16 <quicksilver> assuming your audience knows what groups are
02:49:27 <DRMacIver> Could do. I'd rather save that for 'lecture 3' as it were.
02:49:49 <DRMacIver> (or part 3, if we're doing a more condensed intro)
02:50:16 <DRMacIver> It should be noted that I don't understand more than basic category theory. So possibly my opinions on the subject should be taken with a pinch of salt. ;)
02:54:53 <Heffalump> hi seafood
03:08:57 <ac> is there a way to do non-inclusive float ranges?
03:10:59 <oklopol> > 0.0
03:11:01 <lambdabot>  0.0
03:11:08 <oklopol> > [0.0,0.1]
03:11:09 <lambdabot>  [0.0,0.1]
03:11:12 <oklopol> > [0.0...0.1]
03:11:13 <lambdabot>   Not in scope: `...'
03:11:17 <oklopol> > [0.0.. 0.1]
03:11:18 <lambdabot>  [0.0]
03:11:26 <oklopol> > [0.0.. 3.1]
03:11:27 <lambdabot>  [0.0,1.0,2.0,3.0]
03:11:31 <oklopol> ah
03:11:45 <exDM69> > [0.0, 0.1 ... 1.0]
03:11:45 <lambdabot>   Not in scope: `...'
03:11:49 <exDM69> > [0.0, 0.1 .. 1.0]
03:11:50 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
03:11:51 <ac> I just did "let f = 1 / blah in [0,f .. 1 - f]"
03:12:21 <ac> but that's a little combersome
03:12:25 <oklopol> hmm
03:12:31 <oklopol> 0, f.. 1-f?
03:12:36 <oklopol> i don't get it
03:12:53 <ac> I don't want to include 1
03:12:58 <EvilTerran> gets you 0,0.1..0.9, or 0,0.05,0.1..0.95
03:13:01 <EvilTerran> or whatever
03:13:14 <oklopol> like
03:13:19 <EvilTerran> what about takeWhile (<1) [0,f..] ?
03:13:24 <oklopol> > [0, 10.. -9]
03:13:25 <lambdabot>  []
03:13:31 <ac> EvilTerran: ah nice
03:13:33 <oklopol> will that *ever* work? :|
03:13:42 <exDM69> ac: what's wrong with [0.0, 0.1 .. 0.99]
03:13:56 <ac> exDM69: because the fraction is dependant on an argument
03:13:56 <EvilTerran> oklopol, 0 < f < 1, i think
03:14:01 <quicksilver> > init [0.0, 0.1 .. 1.0]
03:14:02 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
03:14:07 <oklopol> ah
03:14:14 <ac> EvilTerran gave a got answer
03:14:19 <exDM69> ac: [0.0, x .. 0.99] ?
03:14:24 <quicksilver> ac: init is also an answer
03:14:29 <quicksilver> ac: if you just want to skip the last entry
03:14:38 <quicksilver> ac: however, one should never trust float ranges deeply
03:14:43 <EvilTerran> quicksilver's'll miss one if the fraction doesn't divide equally into 1, i think
03:14:45 <quicksilver> ac: rounding errors have a habit of building up
03:14:52 <quicksilver> right, as EvilTerran says
03:14:55 <EvilTerran> > init [0, 2/3 .. 1]
03:14:57 <lambdabot>  [0.0,0.6666666666666666]
03:14:59 <quicksilver> it does depend exactly what you want :)
03:15:08 <EvilTerran> ...or not
03:15:11 <EvilTerran> > [0, 2/3 .. 1]
03:15:13 <lambdabot>  [0.0,0.6666666666666666,1.3333333333333333]
03:15:17 <EvilTerran> O.o
03:15:31 <ac> hmm. in this case it would actually mess things up. I need to have an exact number of elements. Problem is, making a range of integers and mapping (/f) on to that is just as cumbersome
03:15:47 <EvilTerran> are you using floats or rationals?
03:16:00 <SamB_XP> > last [0.0, 0.1 .. 1.0]
03:16:02 <lambdabot>  0.9999999999999999
03:16:09 <ac> I'm not sure
03:16:16 <ac> whatever is default
03:16:39 <ac> when you call (fromIntegral int)
03:16:47 <EvilTerran> if you're not doing anything that produces an irrational result (sqrt or trig fns or whatever), and you're not desperate for speed, it's almost certainly better to use rationals
03:16:50 <ari> > [0, 1/3 .. 1]
03:16:52 <EvilTerran> it uses floats by default
03:16:52 <lambdabot>  [0.0,0.3333333333333333,0.6666666666666666,1.0]
03:17:00 <ari> > [0, 1%3 .. 1]
03:17:01 <lambdabot>  [0%1,1%3,2%3,1%1]
03:17:04 <EvilTerran> > [0 :: Rational, 2/3 .. 1]
03:17:05 <lambdabot>  [0%1,2%3,4%3]
03:17:16 <EvilTerran> :t (%)
03:17:17 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
03:17:26 <EvilTerran> @src Rational
03:17:26 <lambdabot> type Rational = Ratio Integer
03:17:29 <quicksilver> > [0,1/3 ..1] :: [Rational]
03:17:30 <lambdabot>  [0%1,1%3,2%3,1%1]
03:17:36 <quicksilver> that's where I would put the type annotation
03:17:36 <ac> so if I used rationals it would be safe to count on the number of elements?
03:17:46 <quicksilver> but I agree with EvilTerran, this sounds like a case for rationals
03:18:01 <ac> ok
03:18:15 <ac> wow I've never used rationals for a real program before
03:18:21 <SamB_XP> > last [0.0, 0.1 .. 100.0]
03:18:22 <lambdabot>  99.9999999999986
03:18:24 <EvilTerran> yeah. rationals aren't suceptible to the same problems that floating point has, as they're done with integer math under the hood
03:18:35 <ac> yep
03:18:49 <SamB_XP> EvilTerran: floating point was too, once ;-P
03:19:03 <quicksilver> it still is, in a "sense"
03:19:10 <quicksilver> however, not a useful sense for this discussion
03:19:18 <EvilTerran> okay, integer math without silent rounding and overflowing as par for the course
03:19:27 <quicksilver> right ;)
03:19:35 <SamB_XP> ah, yeah, that ;-P
03:19:36 <EvilTerran> *underflowing, even
03:19:47 <EvilTerran> whatever. all that jazz.
03:20:07 <EvilTerran> (jazz is par for the course? ah, the hazards of mixing your metaphors.)
03:20:27 <SamB_XP> without loss of precision, Rational is
03:21:18 <ac> @hoogle (%)
03:21:19 <lambdabot> Did you mean: (%)
03:21:19 <lambdabot> Prelude.undefined :: a
03:21:19 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
03:21:35 <ac> how is % not in scope?
03:21:40 <EvilTerran> it's in Data.Rational
03:21:45 <EvilTerran> *Ratio
03:21:47 <EvilTerran> @index (%)
03:21:48 <lambdabot> Data.Ratio
03:23:07 <ac> how do I collapse a rational to a float?
03:23:22 <ac> fromRational I would assume
03:23:58 <EvilTerran> ?type fromRational
03:24:00 <lambdabot> forall a. (Fractional a) => Rational -> a
03:24:04 <EvilTerran> seems likely, yes
03:24:40 <opqdonut> luckily the from* functions aren't required to be injections :)
03:24:49 <quicksilver> > realToFrac ((1/5)::Rational) :: Double
03:24:50 <lambdabot>  0.2
03:25:02 <quicksilver> you can also use realToFrac, which is my preference
03:25:07 <EvilTerran> ?type realToFrac
03:25:09 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
03:25:10 <quicksilver> I find that fromIntegral and realToFrace are all you need
03:25:15 <quicksilver> 90% of the time, at least
03:25:22 <SamB_XP> ac: hoogle doesn't seem to work too well with infix ops
03:25:22 <EvilTerran> ?type fromIntegral
03:25:24 <lambdabot> forall a b. (Num b, Integral a) => a -> b
03:25:30 <quicksilver> ac: incidentlly, of course, you should use Double not FLoat
03:25:31 <EvilTerran> both very general
03:25:58 <SamB_XP> ac: generally suggesting that you search for exactly what you searched for
03:26:05 <fxr> @hoogle gFind
03:26:06 <lambdabot> Data.Generics.Schemes.gfindtype :: (Data x, Typeable y) => x -> Maybe y
03:26:42 <opqdonut> ?instances Fractional
03:26:43 <lambdabot> Double, Float
03:26:57 <opqdonut> ?instances-importing Data.Ratio Fractional
03:26:57 <lambdabot> Double, Float, Ratio a
03:27:00 <opqdonut> :)
03:34:39 <crab> hi.
03:36:17 <crab> can anyone suggest a non-trivial haskell program i could study, which implements some network protocol, e.g. POP3?
03:38:01 <EvilTerran> if your haskell program isn't trivial, you're doing something wrong ;)
03:38:24 <EvilTerran> seriously, though, maybe have a look at http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Network
03:38:26 <lambdabot> http://tinyurl.com/yqov7f
03:39:45 <tibbe> @seen bos
03:39:46 <lambdabot> bos is in #haskell and #ghc. I don't know when bos last spoke.
03:39:50 <tibbe> bos: ping
03:40:03 <crab> evilterran: thank you. i'll look through those.
03:40:14 <ac> interesting. I have a function that takes a list, and returns a list of finite lists. When I pass the function an infinite list and take X, it crashes, but when I pass it a finite but HUGE list, and take X, it does what's expected
03:40:22 <crab> i just want to get an idea of how such things are done in haskell.
03:40:31 <ac> so Haskell seems to care weather a list is infinite or not
03:40:37 <crab> (hi audreyt)
03:40:39 <EvilTerran> @paste, ac?
03:40:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:40:53 <EvilTerran> i'm intrigued
03:41:06 <ac> ok... hold on a second
03:41:37 <ac> let me add the two cases to the file
03:44:48 <hpaste>  ac pasted "funny list behavior" at http://hpaste.org/3097
03:45:04 <ac> the funny behavior is commented out at the very end
03:45:10 <ac> (that's the part I ran in ghci)
03:46:29 <Japsu> Zevv: ping
03:46:51 <EvilTerran> what's strm/
03:46:52 <EvilTerran> ?
03:47:19 <EvilTerran> oh, i see, ignore me
03:47:59 <hpaste>  vincenz pasted "ComposOpX" at http://hpaste.org/3098
03:49:34 <EvilTerran> ac, noiseChunk 30 100 (take 1000000 strm) acts similar to noiseChunk 30 100 strm to me
03:49:50 <ac> EvilTerran: which version of ghc? For me it just dies completely
03:49:52 <EvilTerran> in that they both produce a couple dozen numbers then freeze
03:50:08 <ricky_clarkson> > let f=(\x y -> if (y==1000) then 0 else 1/x*y+(f x*2 y+1)) in f 4 1
03:50:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> t
03:50:09 <lambdabot>     Probabl...
03:50:18 <ricky_clarkson> What gives?
03:50:23 <ac> oh. I just tried it with take 2000. maybe it's a performance issue
03:50:24 <EvilTerran> 6.6.1
03:50:42 <EvilTerran> however, the 1000000 version starts again after a few seconds
03:51:10 <DRMacIver> ricky_clarkson: I'm pretty sure f x * 2 y + 1 doesn't mean what you think it means, for a start. :)
03:51:16 <ac> EvilTerran: yeah, as the number grows larger, it gets much much slower
03:51:20 <EvilTerran> i think you might have an asymptotic complexity problem there
03:51:28 <ac> How do I fix it?
03:51:43 <xelxebar> yay for XMonad
03:52:03 <DRMacIver> XMonad is great, but it interacts *really* badly with some of the programs I use.
03:52:09 <DRMacIver> I've had to sandbox my IDE in another xserver.
03:52:15 <ricky_clarkson> > let f=(\x y -> if (y==1000) then 0 else 1/x*y+(f (x*2) (y+1))) in f 4 1
03:52:17 <lambdabot>  1.0
03:52:29 <ac> EvilTerran: clearly what's being produced does not depend on elements deep in to the list...
03:52:30 <ricky_clarkson> Yay, thanks.
03:52:31 <EvilTerran> rethink your algorithm?
03:52:44 <matthew_-> DRMacIver: tabwindowmanagers in general interact badly with java
03:52:56 <xelxebar> whoa, what was happening when you didn't?
03:52:59 <matthew_-> DRMacIver: java apps tend to do The Wrong Thing
03:53:01 <DRMacIver> ricky_clarkson: Function application always binds more tightly than operators, so that was parsing as x * (2 y) + 1
03:53:15 <ricky_clarkson> DRMacIver: Gotcha.
03:53:19 <DRMacIver> matthew_-: Yes, I know. I'm aware that it's Java's fault rather than XMonad's. But it's still a pain in the ass. :)
03:53:28 <quicksilver> DRMacIver: (f x) * (2 y) + 1, indeed :)
03:53:39 <DRMacIver> quicksilver: Oops, yes.
03:53:44 <ac> EvilTerran: my algorithm is simple, it's just the way I'm calculating it lazily
03:53:46 <DRMacIver> matthew_-: It doesn't work *too* badly on one monitor, but it goes insane on two.
03:54:14 <ricky_clarkson> That is the number of heads you'll get on average in a row when you toss a coin.
03:54:18 <DRMacIver> Hence, sandboxing the IDE in an X-server running xfwm4 instead. :)
03:55:00 <EvilTerran> i don't think the laziness is an issue here
03:55:02 <ac> I think the problem is that I'm doing transpose on a list of streams. Would that make sense?
03:56:06 <nornagon> quicksilver: hm, instance (Num a) => a -> a? :)
03:56:28 <Botje> > transpose $ map (\x -> [x,x+1]) [1..]
03:56:29 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:56:42 <Botje> > transpose $ transpose $ map (\x -> [x,x+1]) [1..]
03:56:45 <lambdabot> Terminated
03:57:00 <EvilTerran> huh. i thought transpose was fine with infinite structures
03:57:17 <Botje> > transpose $ map (\x -> [x,x+1]) [1..] !! 1
03:57:18 <lambdabot>   add an instance declaration for (Num [a])
03:57:18 <lambdabot>     In the expression: 1
03:57:19 <EvilTerran> @src transpose
03:57:20 <lambdabot> transpose []             = []
03:57:20 <lambdabot> transpose ([]   : xss)   = transpose xss
03:57:20 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
03:57:23 <Botje> > (transpose $ map (\x -> [x,x+1]) [1..]) !! 1
03:57:24 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
03:57:55 <EvilTerran> O.o... wow, that's an ugly definition
03:58:09 <ac> mine?
03:58:15 <EvilTerran> no, transpose there
03:58:29 <Cale> It's not so bad.
03:58:59 <Cale> It turns out to be slightly tricky to handle all the corner cases just so.
03:59:20 <Heffalump> foldr1 (zipWith (:)), isn't it?
03:59:22 <Heffalump> or something like that
03:59:26 <EvilTerran> seems that you'd end up with rather funny behaviour with that version if your lists aren't all the same length
03:59:44 <EvilTerran> > transpose [[1],[2,3]]
03:59:45 <lambdabot>  [[1,2],[3]]
03:59:58 <Heffalump> you shouldn't transpose things where that's not true :-)
04:00:00 <luqui> > map (take 4) $ transpose $ map (\x -> [x,x+1]) [1..]
04:00:01 <EvilTerran> hmm. never mind, i'll think about that some more
04:00:03 <lambdabot> Terminated
04:00:06 <EvilTerran> Heffalump, i agree totally
04:00:13 <Cale> Heffalump: It can be very useful to do so.
04:00:23 <EvilTerran> but i'm sure others will have need to do so
04:00:30 <Heffalump> it's not invertible
04:00:32 <luqui> > transpose $ map (\x -> [x,x+1]) [1..]
04:00:34 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:00:39 <EvilTerran> but i'd be surprised if the same behaviour were always the "right" one in those cases
04:00:40 <luqui> > map (take 4) $ transpose $ map (\x -> [x,x+1]) [1..]
04:00:44 <lambdabot> Terminated
04:00:46 <luqui> gah
04:00:48 <Cale> Heffalump: it is if your list of lists is weakly decreasing in length.
04:01:04 <Cale> Heffalump: which is the case when it represents a labelled Ferrers diagram
04:01:05 <Cale> :)
04:01:17 <Cale> (Young tableau)
04:01:25 <Heffalump> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6],[7,8,9]]
04:01:26 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
04:02:10 <luqui> wow, I am nowhere near understanding Heffalump's definition
04:02:14 <ac> transpose can deal with infinite lists... the issue must be more complicated than that. I wonder what's going on
04:03:40 <Cale> [27, 52527, 77031] are the only numbers less than 100000 for which the proportion of ups to downs in the Collatz iteration is larger than 14/10
04:05:11 <sieni> luqui: it's almost as clear as the scheme version (define (transpose x) (apply map list x))
04:06:05 <ricky_clarkson> > let f=(\y -> if (y==1000) then 0 else 1/2^y*y+f (y+1)) in f 1
04:06:05 <lambdabot>  Add a type signature
04:06:16 <quicksilver> > transpose [[10,20..],[7,14..]]
04:06:18 <lambdabot>  [[10,7],[20,14],[30,21],[40,28],[50,35],[60,42],[70,49],[80,56],[90,63],[100...
04:06:28 <quicksilver> yup transpose is just fine with infinite
04:06:30 <EvilTerran> hm... when ghc compiles a module, it makes a .hi and a .o, right?
04:06:33 <ricky_clarkson> Without the 2^y it doesn't need a type signature.  Why?
04:06:33 <quicksilver> either way around, too
04:07:08 <quicksilver> ricky_clarkson: / and ^ have incompatible types
04:07:12 <Cale> > let f=(\y -> if (y==1000) then 0 else 1/1*y+f (y+1)) in f 1
04:07:14 <lambdabot>  499500.0
04:07:22 <Cale> oh
04:07:24 <luqui> > transpose (map (\n -> [n..]) [1..])
04:07:26 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:07:31 <Cale> It's the division
04:07:32 <luqui> > map (take 4) $ transpose (map (\n -> [n..]) [1..])
04:07:34 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9...
04:07:37 <Cale> You probably want 2**y
04:07:46 <Cale> > let f=(\y -> if (y==1000) then 0 else 1/2**y*y+f (y+1)) in f 1
04:07:48 <lambdabot>  2.0
04:08:04 <Cale> :t (^)
04:08:05 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
04:08:09 <Cale> :t (^^)
04:08:11 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
04:08:13 <ricky_clarkson> I see.
04:08:13 <Cale> :t (**)
04:08:15 <lambdabot> forall a. (Floating a) => a -> a -> a
04:08:56 <ac> hmm. If I just used an array I'm sure it would work just fine... I just thought it would be cool to purely use lists
04:09:24 <Cale> ac: what is it that you're doing?
04:09:52 <ac> heh... I bet there's a MUCH easier way
04:10:19 <ac> ... but I'm trying to write a smooth 2d noise function
04:10:20 <ricky_clarkson> Is there a simplification of y/2**(y+1)?
04:10:21 <Cale> Lists are an excellent data structure so long as you're interested in the elements in the order in which they occur.
04:10:39 <ac> Cale: I'm for the most part
04:10:59 <ac> Cale: that's why I thought it would be neat to use lists, because ultimately I'll be calculating a bunch of these at the same time and adding them together
04:11:20 <quicksilver> ac: funnily enough I wrote a 2D perlin-style noise-generator in haskell last week :)
04:11:30 <quicksilver> ac: I didn't opt for generating a list at all, though
04:11:35 <ac> quicksilver: aaah. that's exactly what I'm doing
04:11:39 <quicksilver> ac: rather, I generate a function Double -> Double -> Double
04:11:59 <quicksilver> ac: then I evaluate that function at as many or as few points in 2-space as I'm in interested in
04:12:00 <Cale> ricky_clarkson: no, not really. I suppose you could make it 2**(-y-1)*y.
04:12:31 <Cale> quicksilver: That's a really nice approach to image generation :)
04:12:42 <quicksilver> ac: I then have an auxiliary function 'sample width height'
04:12:54 <Cale> Treat images how they were always meant to be treated. :)
04:12:57 <nornagon> hrm, i think i used a library that did that
04:13:09 <ac> I figured my approach was foolish
04:13:09 <nornagon> to generate a mandelbrot set
04:13:09 <quicksilver> Cale: http://roobarb.jellybean.co.uk/~jules/Picture%2035.png
04:13:20 <nornagon> i can't remember what it was called, though...
04:13:22 <Cale> nice :)
04:13:42 <quicksilver> Cale: there is an ADT 'Procedural Texture'. What you see in the top right is, more-or-less, a term of that.
04:13:44 <Cale> Which graphics library is that?
04:13:57 <nornagon> ah, pancito
04:14:05 <quicksilver> Cale: openGL
04:14:30 <quicksilver> ptEval :: ProceduralTexture -> (GLdouble -> GLdouble -> Color4 GLdouble)
04:14:40 <quicksilver> interprets those terms into continously-valued functions
04:14:49 <quicksilver> then I just sample them at a grid of points when I want to actually draw something
04:15:00 <ricky_clarkson> > sum $ map (\y -> y/2**(y+1)) [1..10000]
04:15:02 <lambdabot>  0.9999999999999999
04:16:20 <ricky_clarkson> Is there a short way of writing that that doesn't give a rounding error?
04:16:23 <Cale> quicksilver: That also works really well for raytracing
04:16:36 <quicksilver> Cale: *nod*
04:16:41 <ac> quicksilver: with the other approach you need consistent random numbers for each part of the image. The easiest is just to start out with big array of random numbers, but that didn't seem elegant to me
04:17:05 <Cale> quicksilver: It's also nice how you get things like supersampling almost for free.
04:17:05 <quicksilver> ac: my 'noise-function-generating-function' takes a RandomGen as a parameter
04:17:09 <ac> I wanted to write it in such a way that the random numbers were coming from a stream
04:17:31 <quicksilver> ac: then it uses that RandomGen to generate a random grid, interpolate between that grid, and return the pure sampling function
04:17:43 <quicksilver> actually it uses a StdGen for laziness
04:17:45 <quicksilver> but that would be easy to change
04:18:08 <quicksilver> Cale: yes; one of the amusing things about continuous textures though is that supersampling often doesn't help
04:18:08 <ac> quicksilver: can I see the code?
04:18:18 <quicksilver> Cale: they're locally linear :) so they look smooth anyway
04:18:26 <Cale> quicksilver: yeah
04:18:35 <quicksilver> of course, it does depend on what resolution you view them at
04:18:42 <quicksilver> zoom out far enough and supersampling would help
04:18:43 <Cale> quicksilver: Of course, with things like fractals that have sharp edges, it's rather nice.
04:18:47 <quicksilver> right
04:18:54 <quicksilver> ac: yes, sure
04:19:48 <hpaste>  quicksilver pasted "perlin-like 2D noise" at http://hpaste.org/3099
04:20:08 <Cale> > sum $ map (\y -> 1/2**y) [1..10000]
04:20:10 <lambdabot>  1.0
04:20:10 <quicksilver> Cale: yeah. I should add more primitives :)
04:20:18 <Cale> not quite the same thing though :)
04:20:52 <quicksilver> I'm mainly playing with stuff
04:21:00 <quicksilver> this mornign I'm really chuffed with the zipper-style editing
04:21:02 <Cale> quicksilver: you're also repeatedly doing your numeric conversions ;)
04:21:10 <quicksilver> can move up and down the tree
04:21:16 <ricky_clarkson> Do hoovers interfere with wifi?
04:21:28 <quicksilver> can insert new 'modifiers' like scale, and so on
04:21:44 <EvilTerran> probably, ricky_clarkson. most electric motors'll cause a little trouble, iirc
04:21:44 <quicksilver> Cale: yes, there was a bit of trial an error
04:21:53 <quicksilver> Cale: and I haven't removed all the cruft from the errors :)
04:22:35 <EvilTerran> hm... what does one put as the prerequisites of the .depends file in a makefile?
04:22:50 <quicksilver> ac: the whole thing is parametric in 'erp' which is the choice of interpolation function to use
04:23:11 <ac> erp?
04:23:19 <EvilTerran> i've got .depend: ...; ghc -M -f-optdep-f -optdep.depend ...
04:23:28 <quicksilver> it's just a name, you'll see it's the paratmer to all three functions
04:23:40 <ac> ah yes
04:23:42 <nornagon> :t id :: (Fractional blah) => blah -> blah
04:23:43 <quicksilver> ac: you can pass in any interpolation you like; I've used linear and cubic in practice
04:23:45 <lambdabot> (Fractional blah) => blah -> blah :: forall blah. (Fractional blah) => blah -> blah
04:24:00 <nornagon> oh, so you can actually have multi-character type variables :P
04:24:09 <quicksilver> :t mapAccumL
04:24:10 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
04:24:11 <nornagon> i guess 'variables' is the wrong word
04:24:15 <quicksilver> nornagon: there's one :)
04:24:19 <EvilTerran> no, it's a fine word
04:24:22 <quicksilver> nornagon: variables is the conventional word
04:24:27 <nornagon> oh.
04:24:33 <nornagon> nifty, i just made it up <.<
04:26:32 <ac> quicksilver: could you explain turbulence to me? All I've been able to make is cloud like perlin noise
04:26:43 <quicksilver> ac: sure
04:26:54 <quicksilver> ac: look at that screen shot
04:27:00 <quicksilver> ac: see the horizontal lines in the bottom right?
04:27:10 <ac> quicksilver: I assume that was your pallette
04:27:13 <quicksilver> ac: no
04:27:28 <quicksilver> ac: that's the effect of "Scale 5.0 (Gradient purple)"
04:27:38 <quicksilver> ac: 'gradient' is just a sine-wave like gradient in one coordinate
04:27:52 <quicksilver> ac: then you zoom out a bit so you get a bunch of smooth straight lines
04:28:05 <quicksilver> ac: which you see, bottom-right
04:28:37 <quicksilver> ac: now the trick to turbulence is that, to fetch the colour at "x,y" you don't look at x,y but at "x+n,y+n"
04:28:43 <quicksilver> ac: where 'n' is your perlin noise function
04:29:00 <quicksilver> ac: so you use perlin noise as a *displacement* vector to warp the striaght lines
04:29:06 <ac> oh
04:29:07 <ac> cool
04:29:14 <ac> that makes sense. I thought it was simpler than that
04:29:24 <quicksilver> that's what POVray calls 'turbulence'
04:29:30 <quicksilver> I'm copying its terminology
04:29:33 <ac> now I can make my own turbulence ;)
04:29:54 <ac> I'm sure that's the common name, I just didn't understand the process behind it, which is very difficult to distill from looking at code
04:30:35 * quicksilver nods
04:30:52 <quicksilver> people also like to use perlin noise to slightly displace a surface
04:30:56 <ac> the last thing I read made it sound like turbulence was just a parameter of the perlin noise function, which is not the case
04:31:10 <quicksilver> that gets you something which looks like water with an uneven wind
04:31:29 <quicksilver> or just to displace the normal vector (for the lighting calculation) which makes the surface look mottled
04:31:51 <quicksilver> it's also good for displacing a particle system
04:31:56 <Cale> you could probably use it as a cooling map for fire
04:31:57 <quicksilver> to make it look less 'perfect curves'
04:32:22 <quicksilver> Cale: I've seen 1-D perlin noise used as a 'start map' for fire
04:32:37 <quicksilver> Cale: to indicate how many particles start at each point along a 1D line
04:32:48 <quicksilver> Cale: (well actually 2D, using time for the second dimension)
04:32:48 <Cale> ah
04:33:34 <Cale> I wonder if that's actually sort of equivalent
04:34:03 <ac> quicksilver: on the topic of nifty procedural graphics, do you know much about reaction diffusion systems?
04:34:16 <quicksilver> I know they make leopard spots :)
04:34:33 <quicksilver> I've not tried to code one and play with it myself though
04:34:40 <ac> I wrote a little hack that did something somewhat interesting, but it was far from making spots and the more interesting things I've seen online
04:34:49 <LoganCapaldo> bah I say to procedural graphics! Where are the functional graphics?
04:35:03 <ac> LoganCapaldo: that's what I meant... computational graphics
04:35:09 <LoganCapaldo> Monadic graphics!
04:35:12 <quicksilver> LoganCapaldo: my poorly named datatype ProceduralTexture is actually purely functional :)
04:35:15 <ac> I am writing this in Haskell...
04:35:34 <quicksilver> I shall rename it FunctionalTexture before I upload it!
04:35:37 <quicksilver> good point, LoganCapaldo
04:35:38 <desp> $seen jacobolus
04:35:45 <desp> oops. wrong window.
04:36:00 <quicksilver> ac: you can do pretty good leopard spots just with a 'nearest point' generator
04:36:31 <quicksilver> ac: dump a bunch of random points into 2-space, and colour each x,y position by "distance to nearest point"
04:36:46 <quicksilver> ac: that gives you a kind of random-crystal effect
04:36:56 <quicksilver> but using a very flat gradient, you can get leopard spots
04:37:11 <luqui> @djinn ((a -> c) -> (b -> c) -> c) -> ((b -> c) -> (a -> c) -> c)
04:37:11 <lambdabot> f a b c = a c b
04:37:26 <quicksilver> and then use a very low level of perlin noise to make it look less even :)
04:37:50 <ac> I will experiment... as soon as I get the perlin noise working. Since I am stubbern, I must write my own version
04:38:00 <quicksilver> I thought you woudl want to
04:38:01 <quicksilver> :)
04:38:03 <quicksilver> I did
04:38:13 <quicksilver> I will probably put my code up for download at some point
04:38:26 <quicksilver> at the moment it's one big ugly .hs file though, it needs modularising
04:42:27 <quicksilver> I'll probably make it N-dimensional first though
04:42:46 <ac> so you can do animations?
04:43:08 <quicksilver> actually, no
04:43:13 <quicksilver> so I can reverse-UV-map
04:43:23 <quicksilver> and apply a 3D marble to the faces of a 2D shape
04:43:31 <quicksilver> and store that as a texture which openGL can map back on
04:44:00 <crab> mm, perl line noise.
04:44:13 <quicksilver> crab: that joke is made every time I mention it :P
04:44:17 <ac> so that angled cuts in an object look good?
04:44:33 <quicksilver> ac: exactly
04:44:46 <ac> interesting. If you make it 4 dimensional, those objects could be animated ;)
04:44:49 * crab hangs his head in shame.
04:44:52 <quicksilver> ac: quite
04:45:00 <quicksilver> ac: so N-dimensionl is the way to go
04:45:15 <ac> another thing to think about in my refactoring
04:46:57 <raxas> functional texture graphics is cool, boys; but I am experimenting with functional geometry - 3d mesh generators with komposition
04:47:13 <quicksilver> raxas: that's pretty cool :)
04:47:23 <quicksilver> raxas: you should perturb the mesh with perlin noise!
04:47:25 <quicksilver> :)
04:47:36 <raxas> buildings, vehicles, all robotics look n' feel
04:48:13 <ac> a friend of mine wanted to create a 3D engine that rendered functions rather than triangle meshes
04:48:27 <crab> queryPTR :: Resolver -> HostAddress -> IO (Maybe [HostName])
04:48:32 <ac> I guess that's what ray tracers often do
04:48:32 <crab> how do you read that?
04:48:59 <quicksilver> crab: takes two parameters, a resolver and an address
04:49:10 <Zao> And may have IO side effects.
04:49:14 <quicksilver> crab: it is an IO action, which when run, maybe returns a list of hostnames
04:49:50 <crab> ah. so if it said -> IO ([Hostname]) it would always do that? what sort of thing is "Maybe"?
04:49:50 <quicksilver> Maybe [HostName] is a curious type, I wonder what the intended difference is between Nothing and Just []
04:50:06 <quicksilver> crab: Maybe is either one of those thigns, or Nothing.
04:50:13 <quicksilver> crab: so Maybe Int is either an Int, or it's "Nothing"
04:50:28 <quicksilver> crab: it's used for optional paramters, computations which can fail, that sort of thing
04:50:54 <crab> ok, makes sense.
04:51:02 <axm> i was trying to represent functions with unknown parameter count. as i understand, i would need a Dynamic working on my own "Typeable", i would like to solve it with a data structure like Curry = Curry Value Curry | Value. is that even possible or am i making my own life harder than it has to be?
04:51:35 <Heffalump> hello
04:52:51 <quicksilver> axm: it sounds like you're making life harder than it needs to be
04:53:02 <quicksilver> axm: why is taking a list as a parameter not a good answer?
04:53:02 <malcolmw> Hi heffalump
04:53:16 <malcolmw> what is the name of the hackathon channel?
04:53:29 <quicksilver> erm haskell-hac07? somethign like that
04:53:42 <malcolmw> ta
04:55:01 <joelr1> good afternoon
04:55:12 <joelr1> does anyone use HOC (haskell objective-c bindings)?
04:56:07 <axm> because i cannot change the type of that example function. i can connect it with a wrapper that applies all arguments of a list, but then again, haskell needs to have a type for that thing i pass around
04:56:10 <quicksilver> joelr1: it would appear to be a bit stagnated? At least, it's webpage was last updated in 2004..
04:56:25 <axm> and secondly, cause i want to see if it is possible :)
04:56:26 <joelr1> quicksilver: there are updates in the cvs
04:56:29 <quicksilver> axm: right. I'm trying to get you to explain more details of your problem :)
04:56:43 <quicksilver> axm: often there is 'a type' for the thing, that you can then put in a list
04:57:08 <quicksilver> axm: if you're obsessed with the syntax, and you *really* must have "f a b c d" and not "f [a,b,c,d]"...
04:57:21 <quicksilver> axm: then yes, it's possible, with typeclass hackery. See 'printf'
04:57:21 <ac> quicksilver: how would you deal with n-dimensional arrays using static types?
04:57:31 <quicksilver> ac: I'd use tuples
04:57:58 <quicksilver> ac: where I currently have Array (Int,Int), I'd change that to Coord c => Array c...
04:58:00 <axm> i saw printf, but as i understood, it involved only dynamic arg count processing
04:58:13 <quicksilver> axm: it is dynamic in count and also type
04:58:18 <axm> i might not have gotten that relevant piece though
04:58:40 <quicksilver> > printf "%s%d" "foo" (3::Int) :: String
04:58:40 <lambdabot>  "foo3"
04:58:57 <quicksilver> axm: tis' not an implementation technique I recommend for most purposes, though
04:58:59 <axm> yes, as you say, i see it has to have a type i could use
04:59:51 <quicksilver> ac: then I'd make (Int), (Int,Int) and so on all members of the class 'Coord'
04:59:52 <axm> i will have a glance again first
05:00:44 <quicksilver> joelr1: that's encouraging. I've not used it myself.
05:01:10 <joelr1> ok
05:10:10 <MADnificent> I've defined a class << class (Show a, Eq a) => Node a where ... >> now I would like a type that does something like: Path = [Node]   how would I define that?
05:10:54 <quicksilver> MADnificent: you need an auxiliary type and you need -fglasgow-exts
05:11:15 <quicksilver> MADnificent: something like this:
05:11:42 <quicksilver> MADnificent: data AnyNode = forall n . (Node n) => n
05:11:54 <quicksilver> MADnificent: and then you have [AnyNode] for lists of them, and so on
05:12:06 <quicksilver> MADnificent: data AnyNode = forall n . (Node n) => mkAnyNode n
05:12:12 <quicksilver> (mistake in first version)
05:12:34 <MADnificent> quicksilver: hmmm, can you give me a link or a search-string?  I don't fully understand it...
05:12:48 <quicksilver> MADnificent: they're called "Existential types"
05:12:55 <quicksilver> MADnificent: they aren't in haskel 98, but GHC supports them
05:12:59 <MADnificent> quicksilver: ty
05:13:02 <MADnificent> quicksilver: hmmm, evil
05:13:03 <quicksilver> MADnificent: 'Node' is a class, but not a type
05:13:19 <quicksilver> MADnificent: you are saying 'I want a type which represent *any* instance of class Node'
05:13:29 <quicksilver> MADnificent: that is a perfectly sensible thing to want, by the way
05:13:37 <quicksilver> but the syntax for it is a bit odd
05:13:55 <quicksilver> you have to have a 'wrapper' type which 'wraps up' any old Node into a generic 'AnyNode'
05:13:58 <MADnificent> quicksilver: yes, it somewhat surprises me that it's not in Haskell 98
05:14:12 <quicksilver> I'm not sure what the history for that is
05:14:24 <quicksilver> I agree they're very useful
05:15:12 <joelr1> darn, i just failed to build ghc from macports for the 1st time.
05:15:13 <joelr1> configure: error: C compiler cannot create executables
05:15:13 <joelr1> See `config.log' for more details.
05:15:15 <joelr1> wtf?
05:16:04 <MADnificent> joelr1: broken C compiler...
05:16:17 <joelr1> MADnificent: sure. been working fine for ages now.
05:16:22 <quicksilver> odd
05:17:14 <MADnificent> joelr1: it'd be my first guess... hasn't anything changed on your system since the last compile?
05:18:43 <joelr1> still the same old mac osx 10.4.1. i haven't build ghc in ages, though
05:19:04 <quicksilver> check config.log see what happened exactly :)
05:19:13 <quicksilver> maybe paths messed up and it can't find gcc
05:54:31 <MADnificent> quicksilver: I'm having type errors trying to make this: I've changed the definition to: class << (Show a, Eq a) => Node_ a where { nodes :: a -> Maybe [a], ... } >> when I try to declare the instance Node, I do << instance Node_ Node where { nodes (Node a) = nodes a, ... } >> and get the error Couldn't match expected type `Node' against inferred type `a' (do you see an obvious mistake here?)
05:55:05 <MADnificent> s/class << (Show a/<< class (Show a
05:56:24 <quicksilver> MADnificent: well, yes. "nodes (Node a) = nodes a" looks odd
05:56:35 <quicksilver> MADnificent: but then, I don't know what your datatype 'Node' is
05:56:45 <quicksilver> MADnificent: can you hpaste?
05:56:53 <MADnificent> http://www.haskell.org/haskellwiki/Existential_type  I got it from 2.3 over here...
05:56:55 <lambdabot> Title: Existential type - HaskellWiki
05:57:34 <MADnificent> quicksilver: pasting evil code :-(  but I will do so
05:58:17 <quicksilver> MADnificent: ah yes, I understand. Maybe you put your datype together wrong, let's see
05:58:52 <hpaste>  mad pasted "Existential type" at http://hpaste.org/3100
05:59:32 <MADnificent> quicksilver: it's a nice pastie...
06:03:34 <ski> MADnificent : i think you want `nodes (Node ns) = fmap (map Node) (nodes ns)'
06:04:32 <quicksilver> MADnificent: sorry, had a phone call
06:04:47 <quicksilver> MADnificent: the probelm is that 'nodes a' returns the nodes at the underlying type
06:04:58 <quicksilver> MADnificent: suppose the node is really a NodeC
06:05:13 <quicksilver> MADnificent: then nodes (Node a) = nodes a will return a [NodeC]
06:05:17 <quicksilver> a list of NodeCs
06:05:22 <quicksilver> so you need to 'wrap them back up'
06:05:22 <MADnificent> quicksilver: yes, then the solution of ski is right...
06:05:25 <quicksilver> to make them existential
06:05:30 <quicksilver> and yes, ski has the answer :)
06:05:59 <quicksilver> MADnificent: doesn't happen in the 2.3 example on the wiki, because none of the return types mentions 'a'
06:06:06 <MADnificent> quicksilver: Still trying to understand it all... I get the issue, now I'm trying to understand the solution (as in: the haskell that defines the solution)
06:06:09 * ski wants O(0) wrapping there :(
06:06:35 <quicksilver> MADnificent: their functions have fixed concrete return types after all
06:07:03 <quicksilver> ski: not sure how you can hope for that. polymoprhic dispatch involves a dispatch table or RTTI, one way or another
06:07:33 <quicksilver> ski: ghc's using a dictionary but I can't think og a solution with zero overhead
06:07:51 <ski> hm, you are right of course .. forgot a while that pesky existential :)
06:08:14 <ski> (but consider the case when we have a pure `newtype')
06:08:26 <quicksilver> newtype wrapping is O(0)
06:08:34 <quicksilver> it compiles down to nothing at all
06:08:40 <ski> newtype B = MkB A
06:08:45 <quicksilver> yup
06:08:54 <quicksilver> MkB has no compile-time effect at all
06:08:59 <ski> how to do O(0) `[A] -> [B]' ?
06:09:13 <quicksilver> depends how smart the compiler is
06:09:16 <ski> yes
06:09:23 <quicksilver> it's like asking for O(0) map id
06:09:36 <ski> i had an idea a while back for making it obvious to the compiler
06:09:50 <ski> (but slightly more cumbersome for the programmer, of course)
06:10:02 <quicksilver> ski: I note that map id is already O(0) in some circumstances
06:10:11 <quicksilver> ski: if it occurs in the middle of a fusible pipeline
06:10:17 <quicksilver> ski: then it vanishes entirely
06:10:27 <quicksilver> ski: same should be true of map MkB
06:10:31 <MADnificent> ahm, ski can you explain your solution? I don't really grasp it...
06:10:39 <ski> m .. here i were aiming for guarranteed O(0), easy to see for the programmer
06:10:56 <ski> MADnificent : `nodes (Node ns) = fmap (map Node) (nodes ns)' ?
06:11:22 <ski> you mean that one ?
06:11:25 <quicksilver> MADnificent: would you be happy with map Node (nodes ns) ?
06:11:31 <MADnificent> ski: yes, I've tried to understand it by looking at the types in ghci, but it didn't really make complete sense
06:11:37 <quicksilver> MADnificent: the 'fmap' part just "preserves the Maybe"
06:11:50 <ski> MADnificent : ok .. following :
06:12:01 <MADnificent> oh yeah, it's a maybe type... ge me a sec then... I might understand it...
06:12:04 <quicksilver> MADnificent: map Node (nodes ns) :: [NodeC] -> [Node]
06:12:13 <EvilTerran> hm... is there a way to make ghc -M produce a.out: foo.o bar.o baz.o ... as well as the other stuff it produceS?
06:12:27 <quicksilver> so fmap (map Node) (nodes ns) :: Maybe [Node C] -> Maybe [Node]
06:12:37 <quicksilver> fmap just 'lifts' the map into the Maybe type-constructor
06:12:49 <MADnificent> quicksilver: that map Node (nodes ns) surprised me... but it's correct, I think
06:13:02 * ski couldn't @hoogle a more specific 'Maybe' map, so settled for 'fmap'
06:13:14 <ddarius> What's wrong with fmap?
06:13:20 <ski> nothing wrong
06:13:22 <MADnificent> quicksilver: well, it obviously is correct... but it surprised me
06:13:42 <ski> ddarius : just it could be easier to see what is going on, by being a little more concrete
06:13:42 <MADnificent> quicksilver, ski: thanks, I get it now
06:13:57 <quicksilver> MADnificent: map Node :: Node_ a => [a] -> [Node]
06:14:10 <quicksilver> MADnificent: that 'existential boxes' a whole list of as
06:14:16 <quicksilver> e.g. a == NodeC
06:14:23 <ski> (all of the same type 'a')
06:14:38 <MADnificent> ypu
06:14:39 <MADnificent> yup
06:15:26 <ski> quicksilver : had you seen my O(0) "nested wrapping/dewrapping" idea before ?
06:15:48 <quicksilver> ski: yes
06:15:52 <quicksilver> ski: deepFmap
06:15:57 <quicksilver> or ?
06:15:59 <ski> no
06:16:04 <quicksilver> ah, maybe not then
06:16:24 <ski> ok
06:16:39 <ski> newtype B = MkB {unB :: A}
06:17:04 <ski> defines a new type with a trivial (O(0)) isomorphism to an old type
06:17:20 <ski> newtype B a = MkB {unB :: A a}
06:17:41 <ski> defines a new type family, each `B a' with a trivial (O(0)) isomorphism to an old type `A a'
06:17:45 <ski> ok ?
06:17:55 <quicksilver> right
06:18:11 <ski> so
06:18:43 <ski> what we want above is to be able to convert `..A..' into `..B..' (and vice versa) by O(0) conversions
06:19:25 <ski> what would be almost as good would be to convert `k A' into `k B' (and vice versa) by O(0) conversions, for any type `k'
06:19:29 <ski> ok ?
06:20:04 * quicksilver nods
06:20:53 <ski> so, we can define newtypes by abstracting on type arguments (`a' above) .. why couldn't we define something by abstracting on type continuations ?
06:20:56 <ski> i.e.
06:21:05 <ski> newtype k B = MkB {unB :: k A}
06:21:09 <ski> so we get
06:21:23 <ac> quicksilver: well, I came up with something that works but is still grossly inneficient...
06:21:24 <ski> MkB :: forall k :: * -> *. k A -> k B
06:21:26 <hpaste>  ac pasted "working smooth noise function" at http://hpaste.org/3101
06:21:29 <quicksilver> isn't that perilously close to type-level-lambdas?
06:21:29 <ski> unB :: forall k :: * -> *. k B -> k A
06:21:37 <quicksilver> and thus impredicative? or some such disaster?
06:22:12 <ac> quicksilver: I dealt with the randomness by picking the nth element from the random stream based on the x and y coordinate :P
06:22:24 <ski> quicksilver : 'k' here must be a type expression .. no type-lambdas involved
06:22:28 <ac> quicksilver: problem is, I'm recalculating the interpolation function many many more times then necessary
06:22:58 <ski> quicksilver : an example of using this would be
06:23:01 <ac> this it takes around 2 seconds just for one layer
06:23:05 <ac> s/this/thus
06:23:21 <quicksilver> ac: at what resolution?
06:23:27 <ac> 512x512
06:23:35 <quicksilver> that's not too bad
06:23:41 <quicksilver> mine is slower than that :P
06:23:51 <quicksilver> I take about 2 seconds to do 256x256
06:24:05 <ac> I know I can do way better. I'm just generating one layer of smooth noise so far, not perlin noise
06:24:08 <ski> foo :: [A] -> Maybe [B]
06:24:14 <ski> foo [] = Just []
06:24:25 <quicksilver> ac: yeah; you're interpolating values, I'm interpolating gradients
06:24:27 <ski> er
06:24:27 <ac> quicksilver: check out the smoothNoise2d function that I just pasted
06:24:31 <ski> foo :: [B] -> Maybe [A]
06:24:33 <ski> foo [] = Just []
06:24:40 <ski> foo (MkB as) = Just as
06:24:47 <quicksilver> ac: I did
06:24:54 <bos> tibbe: pong
06:24:56 <quicksilver> ac: that's why I said you were interpolating values not gradients :)
06:24:59 <ac> quicksilver: little silly how I'm fetching the random number, eh?
06:25:01 <ski> actually i had in mind
06:25:02 <ski> foo :: [B] -> Maybe [A]
06:25:06 <ski> foo [] = Just []
06:25:16 <ski> foo [_] = Nothing
06:25:17 <quicksilver> ski: this is a bit like deep-fmap, actually
06:25:18 <ski> foo (MkB as) = Just as
06:25:36 <ski> quicksilver : that may be .. could you explain deep-fmap ?
06:25:45 <tibbe> bos: nevermind :)
06:25:51 <quicksilver> ski: well the idea is to be able to "see" that Maybe [] is a functor
06:25:57 <quicksilver> ski: since it's a composition of two functors
06:26:12 <quicksilver> ski: effectively deep fmap is fmap.fmap.fmap ...
06:26:14 <bos> kk
06:26:15 <ski> you mean like
06:26:19 <quicksilver> ski: but the compiler works out how deep it needs to go
06:26:39 <ski> deepFmap :: (a -> b) -> Maybe [a] -> Maybe [b]  -- in a specific case
06:26:41 <ski> ?
06:26:51 <visof_> can any one help me to find a very simple introduction to Category theory
06:26:52 <visof_> ?
06:27:02 <ddarius> visof_: What do you know?
06:27:16 <quicksilver> ski: yes
06:27:26 <visof_> ddarius what do you mean?
06:27:28 <quicksilver> ski: but you can't define it comfortably in haskell
06:27:38 <ddarius> visof_: What other math do you know?
06:27:39 <quicksilver> ski: you need overlapping instances, and it doesn't *really* make sense
06:27:44 <quicksilver> ski: you don't know where to stop :)
06:27:48 <ski> quicksilver : well as far as i've thought, i don't *need* that for my idea (though something like it could be useful)
06:28:00 <quicksilver> ski: it's not the same. I just meant it's related.
06:28:11 <visof_> ddarius calculus PDE
06:28:25 <visof_> ddarius linear algebra
06:28:28 <quicksilver> ski: what you drew out was a kind of "deepFmap MkB"
06:28:33 <ac> quicksilver: my question is, how much are values from the rands stream memoized?
06:29:03 <quicksilver> ac: you mean p1..p4 ?
06:29:09 <ac> yeah
06:29:19 <ski> quicksilver : ? .. `deepFmap MkB' is not a type
06:29:20 <ac> because they're mostly the same throughout the range of x and y
06:29:38 <ac> how can
06:29:41 <quicksilver> ski: no, it's your function from Maybe [A] -> Maybe [B]
06:29:52 <ac> ... I tell haskell that they're the same explicitly?
06:29:53 <ski> [B] -> Maybe [A]
06:29:56 <quicksilver> ac: but "mostly" the same isn't very precise :)
06:30:11 <quicksilver> ac: you have to rearrange the code a bit so it's explicit when they're the same
06:30:16 <quicksilver> ac: and then you can share them
06:30:24 <ac> quicksilver: yeah, I'm just puzzling on how to do that
06:30:36 <ski> quicksilver : the 'Maybe' was just to get slightly more interesting result .. nothing essential here .. only interaction between '[]' and 'B','A'
06:30:41 * quicksilver nods
06:30:44 <ac> quicksilver: perhaps an intermmediate array
06:30:54 <ddarius> visof_: http://www.cs.le.ac.uk/people/akurz/books.html is a good resource, you just need to be able to select from what's available.
06:30:55 <lambdabot> Title: Electronically Available Books and Other Sources (mainly Category Theory)
06:31:19 <quicksilver> ac: if you look at my paste, in the function noise2Dd
06:31:26 <quicksilver> ac: do you see it calculates 'grad' only once
06:31:38 <quicksilver> ac: and then it returns a function
06:31:39 <ddarius> visof_: I like Barr and Wells' ESSLLI lecture notes.
06:31:59 <quicksilver> ac: the various different times that function is invoked, they're all sharing the same copy of grads
06:32:09 <visof_> ddarius thanks i ll check them
06:32:14 <quicksilver> ac: the trick to enable sharing is often to use a 'let' and then return a function
06:32:29 <ski> quicksilver : a specific case of the newtype definition defines _`[B]'_ as having a new constructor `MkB', with argument of type `[A]'
06:33:17 <ski> quicksilver : so in a sense, we are simultaneously adding `MkB' as a constructor to a lot of "existing types"
06:33:20 <ac> quicksilver: hmm. I'm looking at it. I'm not very good at reading Haskell :P. I'll come up with something eventually
06:33:46 <ski> quicksilver : however, since this is supposed to be O(0), this shouldn't matter (and the matching can of course never fail)
06:34:33 <ski> quicksilver : however, there are some pitfalls to look out for .. specifically in what is an allowed definition of the new kind of newtype type definitions
06:36:00 <ski> quicksilver : any comment ? (otherwise i'll tend the laundry now)
06:40:13 <quicksilver> ski: sorry, had to go talk to my boss
06:40:23 <quicksilver> ski: I do know what you mean
06:40:40 <quicksilver> ski: I'm not sure if there are reasons why taht would be hard to do
06:41:51 <ski> "that" being ?
06:42:02 <ski> quicksilver
06:42:50 <quicksilver> using higher-kinded newtypes like this, I uess
06:43:06 <ski> how is it higher-kinded ?
06:43:17 <ski> B :: *
06:44:29 <quicksilver> mkB
06:44:53 <quicksilver> well mkB was polymorphic in a higher-kinded type var
06:44:57 <quicksilver> which is what I meant :)
06:46:56 <ski> ok
06:47:07 <ski> how about this definition
06:47:30 <ski> newtype k B = MkB (Maybe (k Int))
06:48:25 <ski> this claims that `[B]' and `Maybe [Int]' should have the same representaion, using the usual implementation of newtypes (which gives us O(0) conversion)
06:48:37 <ski> quicksilver : do you see the problem now ?
06:48:51 <quicksilver> yes :)
06:49:18 <ski> i think a solution to this could be to have
06:49:25 <ski> k :: * -> k0
06:49:53 <ski> where `k0' is a kind variable that must be universally quantified over that definition
06:50:46 <ski> that roughly says that `k' must be applied "outermost" in the definiens
06:51:47 <quicksilver> yes, this is a bit like the deepfmap problem actual
06:51:48 <ski> or more specifically, that `k' must at least be tail-called in the defininens (other uses are allowed, as long as their result is ignored)
06:51:52 <quicksilver> it's like the dual of it
06:52:05 <quicksilver> since k is a 'type continuation'
06:52:10 <ski> yes
06:52:18 <quicksilver> in deepfmap the problem is that you want the 'innermost match'
06:52:26 <ski> (though i'm not familiar with the deepfmap problem)
06:52:26 <quicksilver> here you want something outermost..
06:52:39 <ski> i do ?
06:53:00 <ski> i want it to not matter how far out we include into `k'
06:53:41 <ski> (i.e., in a sense, no shift/reset effects with the type continuation .. just eventual type tail-call)
06:53:55 <ski> an example of a non-trivial tail-call could be
06:54:24 <ski> newtype Flip f a b = MkF {unF :: f b a}
06:55:29 <ski> newtype k B = MkB {unB :: Flip (Const k)}
06:55:31 <ski> i think
06:55:50 <ski> newtype Const c a = MkC {unC :: c}
06:56:52 <ski> of course, here we probably want kind-polymorphism for `Const', and possibly `Flip', too ..
06:57:18 <ski> .. though i think one could make this useful for specific kinds even without kind-polymorphism
06:57:46 <ski> let's say
06:58:07 <ski> Flip :: (* -> * -> *) -> * -> * -> *
06:58:17 <ski> Const :: (* -> *) -> * -> * -> *
06:58:32 <ski> anyway
06:58:46 <ski> if we allow some kind of kind-polymorphism, like
06:59:19 <ski> newtype Flip (f :: k0 -> k1 -> *) (a :: k0) (b :: k1) = MkF {unF :: f b a}
06:59:28 <ski> then we still only get
07:00:16 <ski> er, actually
07:00:27 <ski> newtype Flip (f :: k1 -> k0 -> *) (a :: k0) (b :: k1) = MkF {unF :: f b a}
07:00:29 <ski> then we still only get
07:00:48 <roconnor> ekidd: http://web.archive.org/web/20070615071737/http://haskell.org/hawiki/MonadRandom
07:00:50 <lambdabot> Title: MonadRandom - The Haskell Wiki, http://tinyurl.com/29tfxa
07:01:06 <ski> Flip :: forall (k0 :: **) (k1 :: **). (k1 -> k0 -> *) -> k0 -> k1 -> *
07:01:15 <roconnor> @seen Cale
07:01:15 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 2h 27m 41s ago.
07:01:35 <ski> i.e. it is hard to see what we would write to get kind-polymorphism in the *result* type
07:02:26 <ski> (btw, '**' is meant to be the "metakind" of ordinary kinds)
07:02:43 * quicksilver nods
07:02:54 <ski> this is because 'MkF' is a value, i.e. its type has kind '*' .. specifically, 'MkF' is a function, so the argument and result types must have kind '*'
07:03:12 <quicksilver> roconnor: what's the significant of the wayback-cached version of an old version of the MonadRandom page?
07:03:38 <ski> .. but .. i think one can overcome this restriction by using my above 'newtype k (...) = ..k..' trick, as well :)
07:03:45 <ski> i.e. we write
07:04:12 <ski> newtype k (Flip (f :: k1 -> k0 -> k2) (a :: k0) (b :: k1) :: k2) = MkF {unF :: k (f b a)}
07:04:32 <roconnor> quicksilver: we are wondering what the licence is
07:04:53 <ski> so the result type now is an argument of the type continuation `k', as thus we can make it polymorphic
07:05:41 <ski> Flip :: forall (k0 :: **) (k1 :: **) (k2 :: **). (k1 -> k0 -> k2) -> k0 -> k1 -> k2
07:06:16 <ski> MkFlip :: forall (k0 :: **) (k1 :: **) (k2 :: **). forall (k :: k2 -> *) (a :: k0) (b :: k1). k (f b a) -> k (Flip f a b)
07:06:27 <quicksilver> roconnor: well cale is listed on http://www.haskell.org/haskellwiki/HaWiki_migration
07:06:28 <lambdabot> Title: HaWiki migration - HaskellWiki
07:06:35 <quicksilver> roconnor: as willing to have his work relicensed
07:06:38 <quicksilver> roconnor: so I guess, it's fine
07:08:37 <ski> there's still something unclear going on here .. since we want to rely on `k :: k2 -> k3' for a universal `k3' for the sake of well definedness .. but then in the actual type of the constructor and deconstructor, we have `k :: k2 -> *' again
07:09:00 <ski> quicksilver : anyway .. that's the gist of it .. hope you've been able to follow the idea mostly
07:09:50 <roconnor> quicksilver: ekidd wants to package it up and (presumably) stick it in Hackage so his probability package can depend on it.
07:10:45 <quicksilver> ski: I follow the idea, certainly. I'm slightly queasy about metakinds :)
07:10:51 <quicksilver> roconnor: that would be permitted by http://www.haskell.org/haskellwiki/HaskellWiki:Copyrights
07:10:52 <lambdabot> Title: HaskellWiki:Copyrights - HaskellWiki
07:11:24 <ekidd> I'm trying to avoid reinventing the wheel, especially since reinvented wheels often turn out square.
07:11:41 <Tac-Tics> Why are some legal documents written in all caps? I never understood that
07:11:50 <Tac-Tics> parts of them at least
07:12:24 <quicksilver> ekidd: yes, you have implicit permission to do whatever you want with that code
07:12:32 <quicksilver> ekidd: cale gave you that permission by putting it on the wiki
07:12:37 <Olathe> Tac-Tics: To ensure you won't read them.
07:13:08 <Zao> Tac-Tics: Some laws require that some passages in legal texts to be larger than other parts.
07:13:09 <Tac-Tics> it does make it more difficult
07:13:24 <Zao> Tac-Tics: That is hard to do in plain text, so CAPS are used as emphasis.
07:14:01 <Zao> http://ask.metafilter.com/51519/What-do-all-capital-letters-in-legal-documents-signify
07:14:04 <lambdabot> Title: What do all capital letters in legal documents signify? | Ask MetaFilter, http://tinyurl.com/yroz5m
07:14:47 <ski> quicksilver : the only meta-kind i need here is '**' .. so one could just have that one (and make it implicit, so doesn't need to be told)
07:14:54 <Tac-Tics> hehe "designed to protect customers"
07:15:21 <quicksilver> Zao: D'oh I was about to paste that same link :)
07:16:03 <Zao> quicksilver: Praised be Google.
07:16:29 <Tac-Tics> I wonder what an internets without search engines would be like
07:16:41 <quicksilver> I don't wonder, I remember
07:16:44 <Tac-Tics> heh
07:16:51 <Tac-Tics> I remember when I used Yahoo long long ago
07:16:52 <quicksilver> I spent very little time on the web and much more on usenet
07:16:53 <Zao> It was smaller back then.
07:16:58 <Tac-Tics> that's as far back as I go though
07:17:13 <quicksilver> usenet was where all the cool kids hung out!
07:18:29 <Tac-Tics> I have read the ancient tomes on the subject of MUDs, the ancient nets were fascinating
07:20:22 <ac> what does "{-# INLINE foo #-}" do?
07:20:49 <quicksilver> it asks the compiler to inline it when compiling
07:21:06 <ac> inline each call to foo, or inline calls made inside foo?
07:21:33 <Tac-Tics> would inlining in this context be the same as the C++ inline functions?
07:21:54 <Tac-Tics> Where it throws the function text into each instance it's called instead of making it its own dedicated function?
07:22:03 <quicksilver> yes
07:22:07 <Tac-Tics> oh neat
07:22:08 <quicksilver> ac: each call to foo
07:22:17 <quicksilver> it's only a request, not a guarantee
07:22:29 <quicksilver> to be honest, ghc inlines very agressively anyway
07:22:34 <quicksilver> it's not often necessary :)
07:22:36 <Tac-Tics> does that prevent it from being recursive then? I remember C++ didn't care so much for recursive inline functions
07:22:47 <quicksilver> yeah, GHC won't inline recursive functions either
07:22:55 <quicksilver> but there is a trick
07:22:58 <quicksilver> @src foldr
07:22:58 <lambdabot> foldr k z xs = go xs
07:22:58 <lambdabot>     where go []     = z
07:22:58 <lambdabot>           go (y:ys) = y `k` go ys
07:23:06 <quicksilver> hide the recursion in a local name
07:23:10 <quicksilver> and then it can get inlined :)
07:23:51 <dons> ?seen beschmi
07:23:51 <lambdabot> I saw beschmi leaving #haskell, #haskell-hac07, #darcs and #xmonad 5d 19h 20m 16s ago, and .
07:24:03 <dons> anyone seen beschmi?
07:25:00 <hpaste>  Zao pasted "Is this simplifiable?" at http://hpaste.org/3102
07:25:50 <Zao> The expression on line 3 feels a bit awkward. Is there any better way to filter out elements at certain indices in a list?
07:25:52 <Tac-Tics> @src unzip
07:25:53 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
07:25:59 <Tac-Tics> @type unzip
07:26:01 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
07:26:10 <Tac-Tics> @type zip
07:26:12 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
07:26:32 <quicksilver> Zao: that's a fairly common idiom
07:26:40 <Tac-Tics> @type uncurry zip
07:26:42 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
07:26:46 <quicksilver> Zao: you see 'map fst' more often than snd . unzip
07:26:59 <Tac-Tics> @type uncurry zip . unzip
07:27:01 <lambdabot> forall a b. [(a, b)] -> [(a, b)]
07:27:04 <Tac-Tics> yay!
07:27:36 <quicksilver> Zao: and you could write your filter as filter ( not . (`elem` fs) . fst )
07:27:42 <quicksilver> Zao: if you're so inclined :)
07:27:54 <twanvl> ?src notElem
07:27:55 <lambdabot> notElem x =  all (/= x)
07:28:28 <quicksilver> Zao: erm
07:28:31 <quicksilver> Zao: thinking a bit more
07:28:59 <quicksilver> Zao: you want all elements except a given set of indexes?
07:29:05 <Zao> Yes.
07:29:26 <quicksilver> zipwith (!!) xs ([0..length xs-1] \\ fs)
07:29:34 <quicksilver> is more "obvious" to me
07:29:39 <quicksilver> but much slower :)
07:29:43 <quicksilver> depends if that matters
07:30:13 <quicksilver> quadratic instead of linear
07:30:28 <Zao> n is low, and it's called rarely, so it probably doesn't matter.
07:30:44 <Zao> (It's for removing cleared lines from a tetris board :)
07:31:40 <pjd> Zao: why do it by index?
07:32:04 <pjd> instead of something like  filter (not . full) rows
07:32:22 <Zao> pjd: It's in response to a network packet from another client.
07:33:32 <Zao> Since it already has the indices to clear out, I figured I might as well use it somehow.
07:33:41 <quicksilver> yes, that's another point
07:33:48 <quicksilver> indices are somehow 'unidiomatic'
07:33:52 <quicksilver> but *shrug* if it works :)
07:34:38 <Olathe> How do you get consecutive deltas in a list ?
07:35:00 <quicksilver> zipWith (-) l (tails l) ?
07:35:03 <quicksilver> perhaps
07:35:09 <quicksilver> s/tails/tail/
07:35:09 <ekidd> @seen Cale
07:35:10 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 3h 1m 36s ago.
07:35:14 <ekidd> @seen Cale_
07:35:14 <lambdabot> Cale_ is in #haskell. I don't know when Cale_ last spoke.
07:35:31 <quicksilver> Olathe: that was for you :)
07:35:58 <Olathe> You could use that to recursively do what Zao wanted.
07:36:46 <quicksilver> keep 'drop'ing the differents?
07:36:50 <quicksilver> yes, that's quite cute
07:37:12 <quicksilver> map head . zipWith drop differences $
07:37:21 <quicksilver> no, not zipWith
07:37:23 <birkenfeld> hi
07:37:26 <quicksilver> but something like that
07:41:31 <MyCatSchemes> Building yi seems like an adventure already.
07:41:54 <MyCatSchemes> Which is to say, there's quite a bit of dependancy chasing here. Heh.
07:43:04 <Tac-Tics> MyCatSchemes: very much so. I set Yi up a few weeks ago. One of the biggest pains ever ^^;;
07:43:58 <MyCatSchemes> Tac-Tics: bet you didn't have to contend with a partially-broken installation of ghc-6.6 at the same time, though. =D
07:44:11 * pjd must still port yi to FreeBSD
07:44:13 <MyCatSchemes> Yaaaay, yi-vty just booted up! ^_^
07:45:17 <Tac-Tics> MyCatSchemes, it was close.... I was dealing with the newest nonstable ghc for a while
07:45:23 <Tac-Tics> finally I gave up and went back to 6.6
07:45:55 <Tac-Tics> I figured I'd try to isolate the problem by not working with 2 experimental software installations at once
07:47:23 <MyCatSchemes> Tac-Tics: heh.
07:47:29 <MyCatSchemes> Tac-Tics: it's three that's the real killer.
07:48:11 <MyCatSchemes> Tac-Tics: that was Seymour Cray's old rule - never, ever bet a project on your being able to solve more than two currently open research problems in order to actually implement it.
07:48:32 <Tac-Tics> heh
07:48:44 <quicksilver> wise words
07:49:07 * MyCatSchemes ponders.
07:49:45 <MyCatSchemes> It might be only because I'm so used to lexical scoping, but is there any real justification in practice for dynamic scoping feeling evil to me?
07:50:11 <quicksilver> MyCatSchemes: it feels evil because it is E..V..I..L
07:50:35 <quicksilver> MyCatSchemes: Imagine getting all the evilness from all the world, and bundling it up and making it look like a scoping paradigm.
07:50:45 <quicksilver> MyCatSchemes: that's dynamic scoping...
07:50:46 <MyCatSchemes> What, like, QBASIC evil?
07:50:59 <Olathe> QBASIC didn't do that, I don't think.
07:51:04 <Tac-Tics> dynamic scoping *hissss*
07:51:14 <quicksilver> well for one thing, dynamic scoping is closely tied to mutability in my experience
07:51:14 <pjd> MyCatSchemes: QBASIC is honest about its evil, at least
07:51:23 <quicksilver> it's often used to give a shared environment to some chunks of code
07:51:32 <quicksilver> but allow you to 'run in a different environment'
07:51:41 <quicksilver> by dynamically rebinding
07:51:49 <pjd> dynamic scoping is the bad brother of dynamic typing, that no one mentions in polite conversation
07:51:59 <quicksilver> I think there are better ways of doing that..
07:52:01 <MyCatSchemes> quicksilver: so, something that you *should* have done with honest, explicit indirection, then?
07:52:06 <quicksilver> MyCatSchemes: right
07:52:19 <quicksilver> some uses of dynamic scoping are just implicit parameters, really
07:52:22 <Tac-Tics> pjd: dynamic typing as in coercive typing?
07:52:28 <quicksilver> I'd rather they were explicit, personally
07:52:42 <ski> i think in temporal logic, one can think of time as dynamically scoped
07:52:57 <pjd> Tac-Tics: as in runtime typing
07:53:08 <MyCatSchemes> Reading descriptions of dynamically scoped languages, it seems to me that the choices of when which scope applies to what under which operators and what macros are entirely arbitrary and random for each and every case.
07:53:32 <quicksilver> state machines a bit like dynamic scope
07:53:38 <quicksilver> in open GL we say:
07:53:42 <quicksilver> lighting $= Enabled
07:53:50 <quicksilver> (... call other actions ...)
07:53:57 <ski> quicksilver : what is the difference between `dynamic scoping' and `implicit parameters' ?
07:54:00 <quicksilver> that's quite a lot like lighting being dynamically bound
07:54:18 <MyCatSchemes> ski: dynamic scoping is a form of implicit parameterisation.
07:54:34 <pjd> ski: probably that dynamic scoping implies more nesting
07:54:45 <ski> MyCatSchemes : what would be an example of another form ?
07:54:52 <quicksilver> dynamic scoping says something very precise about names
07:54:59 <quicksilver> it says when I use the name 'ski'
07:55:10 <quicksilver> it can refer to a 'ski' declared in any calling scope
07:55:12 <MyCatSchemes> ski: to be honest, I'm not actually sure if there are forms of implicit parameterisation that aren't dynamic scoping.
07:55:46 <MyCatSchemes> I'm sure in theory you -could- make one, but I can't in practice think of anywhere where someone actually -has-. :/
07:55:58 <quicksilver> ski: I think they are semantically the same
07:56:06 <ski> ok
07:56:09 <quicksilver> ski: but there is a syntactic preciseness about what dynamic scoping
07:56:13 <ski> *nod*
07:56:22 <quicksilver> ski: it means "the symbol 'ski' refers to the same symbol in enclosing scopes"
07:56:26 <ski> (also, there can be interactions with implicit state)
07:56:37 <quicksilver> this is profoundly disquieting for people used to lexical scope
07:56:45 <quicksilver> I find it so :)
07:57:13 <quicksilver> dynamic scoping also means that if you shadow a global
07:57:22 <quicksilver> then the code that you call, sees your shadowed global
07:57:22 <ski> i don't see what the quote above means
07:57:40 * MyCatSchemes wonders.
07:57:50 <quicksilver> in the psuedo code "print (ski + 1)"
07:57:53 <quicksilver> ski is a symbol
07:58:00 <quicksilver> it's resolved somehow
07:58:10 <MyCatSchemes> Would it be better to just reimplement cowsay from scratch in Haskell or spend the time to work out how to install it into my home directory?
07:58:16 <quicksilver> in a purely lexical scope system, how that symbol is resolved is totaly static
07:58:22 <ski> i thought symbols/identifiers referred to values (in some environment) .. you're claiming in this case the value is a symbol ?
07:58:23 <quicksilver> you can look at the code and see where 'ski' is defined
07:58:43 <quicksilver> in a dynamic scoping system, 'ski' might end up referring to a value somewhere else competely
07:58:46 <quicksilver> (in a different file)
07:58:50 <ski> *nod*
07:58:50 <quicksilver> which just happens to call that code
07:59:11 <byorgey> MyCatSchemes: maybe implement "lambdasay"?
07:59:12 <quicksilver> the implication, most of the time, is that lexical scopes are always resolved at compile time
07:59:20 <quicksilver> but dynamic scopes can only be resolved at run time
07:59:22 <byorgey> MyCatSchemes: it could feature a cute talking lambda
07:59:23 <quicksilver> but that does vary a bit
07:59:39 <ski> just as function arguments can only be resolved in general
07:59:46 <ski> hence implicit parameters
07:59:51 <quicksilver> right
07:59:59 <ski> s/resolved/resolved at run-time/
08:00:04 <quicksilver> well
08:00:06 <quicksilver> hmph
08:00:07 <quicksilver> not quite
08:00:17 <quicksilver> 'symbolically' they're perfectly resolved at compile-time
08:00:21 <MyCatSchemes> byorgey: fun idea. In that case, I think I will. This weekend sounds good.
08:00:28 <quicksilver> in practice they take different values at runtime
08:00:30 <quicksilver> but that's not the same thing
08:00:39 <byorgey> MyCatSchemes: =D
08:00:48 <quicksilver> the haskell extension which was called implicit parameters was a particular 'well-behaved' kind of dynamic scoping
08:00:52 <quicksilver> which showed up in the types
08:00:56 <quicksilver> it was still nasty though :)
08:00:58 <quicksilver> although clever
08:01:20 <ski> quicksilver : sorry .. i should have been more clear .. by 'arguments' there i meant the actual values (up to enclosing abstractions)
08:01:29 <quicksilver> right
08:01:33 <quicksilver> values wait until runtime
08:01:39 <quicksilver> but the symbol is resolved at compile-time
08:01:41 * byorgey : apt-get install cowsay
08:01:55 * ski -> laundry
08:06:00 <MyCatSchemes> Arrrrgh.
08:07:19 <MyCatSchemes> Dammit. The cabal build for X11 1.2 keeps getting hung up trying to find /usr/local/bin/ghc-6.0.1
08:07:30 <MyCatSchemes> I have no clue why it is even *trying*. :/
08:09:58 <dons> gets hung?
08:10:07 <MyCatSchemes> Can't find it.
08:10:40 <MyCatSchemes> The preprocessing stage is generating Graphics/X11/Types_hsc_make.c with an #include "/usr/local/foo/bar" for a file which doesn't exist.
08:11:53 <MyCatSchemes> Also the build fails because it can't find /usr/local/bin/ghc-6.0.1. Damnation.
08:16:51 <phlpp> :>
08:20:10 <MyCatSchemes> Something that doesn't make sense to me. cpphs's configure script checks for the availability of cpphs. Huh.
08:22:24 <lemmih_> All configure scripts check for the availability of cpphs.
08:22:43 <kscaldef> I want to add a SCC annotation to a function definition that includes guards.  I can't seem to figure out where to put it to make it work, without having to insert it for each guarded expression.  Can someone help?
08:23:13 <MyCatSchemes> lemmih_: it still seems funny.
08:23:49 <hpaste>  kscaldef pasted "Where to put this SCC annotation?" at http://hpaste.org/3103
08:31:37 <quicksilver> MyCatSchemes: configure scripts aren't supposed to make sense.
08:31:56 <quicksilver> MyCatSchemes: they're supposed to drive you mad and discourage you from writing software
08:32:17 <Olathe> They work !
08:32:36 <quicksilver> except, of course, when they don't :)
08:32:39 <Tac-Tics> hhehe
08:33:40 <Olathe> "work" = "does what it's supposed to do"
08:34:20 <Olathe> I remember having to edit configure scripts to get things to work on weird machines. It was pretty weird.
08:38:46 <benny> did the weirdness come from editing, or was the weirdness always present?
08:39:00 <geocalc> haskell configure tool is needed
08:40:27 <MyCatSchemes> Dammmmmmmiiiiiit
08:40:40 <MyCatSchemes> Is there any way to make Setup.hs more verbose? Like, a *LOT* more verbose?
08:41:31 <lemmih_> MyCatSchemes: What seems to be the problem?
08:41:57 <MyCatSchemes> lemmih_: everything gets pear-shaped during the preprocessing stage while compiling X11 1.2.2
08:42:39 <MyCatSchemes> lemmih_: references to ghc-6.0.1 (and ghc-6.0.1-specific paths and locations) keep cropping up, even though no such version of ghc exists on the machine.
08:45:04 <MyCatSchemes> "sh: /usr/local/bin/ghc-6.0.1: No such file or directory" <-- during the preprocessing stage, while running Setup.hs. Other Cabal packages (yi, haddock, happy, etc) didn't have anything even *resembling* this problem, just configure-build-install with practically no output.
08:45:34 <MyCatSchemes> AHA!
08:45:53 <MyCatSchemes> No wonder. Not a problem with X11 itself at all. My university's fucked-up installation of ghc. :/
08:46:33 <puusorsa> what's ! ?
08:46:44 <Tac-Tics> at least your university had an installation of ghc
08:46:51 <puusorsa> Prelude.! .. hoogle finds a dead link
08:46:54 <Tac-Tics> My university didn't even have python installed on their linux boxes!
08:47:17 <mauke> @type (!)
08:47:19 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
08:47:26 <mauke> array indexing
08:47:47 <geocalc> so change the path MyCatSchemes
08:48:02 <roconnor> when did GHC chars become unicode?
08:48:02 <MyCatSchemes> geocalc: just hacked that up now.
08:48:03 <puusorsa> mauke, isn‰t that Data.Array.(!)
08:48:06 <MyCatSchemes> Ahhhh, it compiles! <3
08:48:17 <mauke> @index (!)
08:48:18 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
08:48:23 <puusorsa> Data.Array.(!):: Ix i => Array i e -> i -> e
08:48:29 <mauke> puusorsa: yes. there is no (!) in Prelude
08:48:31 <puusorsa> i'm looking for this: Prelude.!:: keyword
08:48:40 <puusorsa> mauke, well, hoogle finds one
08:48:54 <mauke> well, that's syntax, not a function
08:48:55 <puusorsa> used in a type, like foo :: !string
08:49:01 <mauke> strictness annotation
08:49:11 <puusorsa> googling that, thanks
08:49:12 <MyCatSchemes> w00, I can has xmonad! <3
08:51:34 <quicksilver> MyCatSchemes: /nick LolCatSchemes ?
08:51:41 <MyCatSchemes> Oh wow, xmonad and metacity don't like running simultaneously, hahahha.
08:54:17 <MyCatSchemes> quicksilver: :P
08:54:28 <MyCatSchemes> kthxbai
09:26:28 <vincenz> @seen psykotic
09:26:28 <lambdabot> I saw psykotic leaving #haskell and #haskell-blah 9d 11h 32m 3s ago, and .
09:42:01 <puusorsa> data Foo = Foo { aa :: !String, bb :: !String } .. exactly what does that mean?
09:42:13 <puusorsa> googled strictness annotation but still not 101% clear
09:42:52 <puusorsa> when constructiong a Foo, aa and bb get evaluated at that point?
09:43:39 <Arnar> hey there..
09:44:42 <Arnar> I'm looking for an operator on monads.. sure it exists but I don't know how to search for it.. best described by it's type   (???) :: Monad m => m a -> (a -> b) -> b
09:45:05 <fax> @hoogle Monad m => m a -> (a -> b) -> b
09:45:06 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
09:45:06 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
09:45:06 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
09:45:09 <allbery_b> if you make that m b, it exists\
09:45:21 <allbery_b> and is known as fmap or liftM
09:45:29 <allbery_b> if you leave the type as is, well, no.
09:45:42 <allbery_b> unwrapping monads in an uncontrolled way is bad
09:45:42 <Arnar> m a -> (a -> m b) -> m b ?
09:45:52 <Arnar> i.c.
09:45:55 <allbery_b> m a -> (a -> b) -> m b
09:46:00 <Arnar> ah..
09:46:10 <Arnar> basically I have a function Cfg -> Bool
09:46:14 <Arnar> and a monad IO Cfg
09:46:32 <Arnar> and I need to use that function in a case preicate ( | )
09:46:41 <Arnar> predicate*
09:47:35 <allbery_b> hm.  you may be looking for lambdacase, which is a proposed extension not yet implemented yet
09:47:36 <Arnar> cant use "m Bool" as a predicate, can I?
09:47:50 <Arnar> allbery_b: figures.. :)
09:47:51 <byorgey> Arnar: if your function is f :: Cfg -> Bool, and you have m :: IO Cfg, then you can write liftM f m  to get a value of type IO Bool.  Then you will have to extract a Bool value from that and use that in the predicate.
09:48:29 <Arnar> byorgey: ok.. the "extract" part is what I don't know how to do (sorry, my first Haskell venture)
09:48:31 <allbery_b> otherwise, f `fmap` a >>= \b -> case b of ...
09:48:57 <allbery_b> or in do syntax, do b <- f `fmap` a; case b of ...
09:49:11 <byorgey> Arnar: note the `fmap` there is the same as liftM
09:49:18 <Arnar> ok..
09:49:36 <Arnar> sorry, not completely following.. can I paste some stuff so you can show me in a context I'm familiar with?
09:49:43 <twanvl> or  a >>= \b -> case f b of ...
09:49:44 <byorgey> Arnar: sure.
09:49:58 <Arnar> ok, one moment
09:50:13 <byorgey> twanvl: hm, true, that's probably clearer
09:51:20 <hpaste>  arnar pasted "(no title)" at http://hpaste.org/3104
09:51:55 <Arnar> forgot to add that " sos_C :: Config -> IO Config "
09:52:35 <Arnar> Compose is a type constr. of the adt C
09:52:48 <twanvl> It looks like you don't need the IO type at all there
09:53:05 <Arnar> twanvl: other instances of sos_C are doing non-determinism
09:53:17 <Cale> Hello?
09:53:17 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
09:53:22 <Cale> People have been looking for me?
09:53:24 <fax> Hi Cale
09:54:19 <Cale> @tell ekidd It would be just fine with me.
09:54:20 <lambdabot> Consider it noted.
09:54:23 <hpaste>  arnar pasted "non-determinstic instance of sos_C" at http://hpaste.org/3105
09:55:22 <kscaldef> did anyone have any suggestion on: http://hpaste.org/3103
09:55:28 <Cale> Honestly, all the code which I put online, I'd be okay with putting it in the public domain if it weren't for the possibility of damages ;)
09:55:48 <geocalc> fax-> will you make a hopengl app ?
09:55:53 <Cale> I thought I'd explicitly licensed that code too...
09:56:03 <Cale> Maybe not.
09:56:10 <fax> geocalc: I did already
09:56:22 <geocalc> ?*
09:56:22 <lambdabot> Maybe you meant: . v
09:56:32 <kscaldef> If I put the SCC annotations after the two equals, my profile doesn't seem to make sense
09:56:37 <fax> geocalc: I wrote a really simple Logo in haskell using HOpenGL and GLUT
09:56:45 <fax> geocalc: It was my first program though so it's not very good
09:57:02 <byorgey> Arnar: so, what is the problem exactly?
09:57:32 <Arnar> byorgey: in my first paste.. where I use "isFinal (sos_C ...)" as the predicate..
09:57:35 <geocalc> fax-> haskell logo ?
09:58:01 <Arnar> byorgey: type mismatch since sos_C :: Config -> IO Config   but   isFinal :: Config -> Bool
09:58:29 <fax> geocalc: something like this http://www.atarimagazines.com/compute/issue46/60-1.jpg
09:58:33 <byorgey> Arnar: I think you'll have to rewrite it without using guards.
09:59:02 <Arnar> byorgey: ok..
09:59:20 <Arnar> any pointers (to relevant docs :o) ?
09:59:30 <hpaste>  twanvl annotated "(no title)" with "Using if and do notation / using a function" at http://hpaste.org/3104#a1
09:59:32 <kscaldef> can I get the effect of -prof -auto-all in a single module without enabling all that verbosity for every module in the package?
09:59:35 <Cale> fax: cool :)
09:59:44 <Cale> fax: That would make a good Haskell project really.
09:59:55 <Cale> fax: L-Systems are another cool one
09:59:58 <lnxmomo> hi, i cant use the up key in haskell (HUGS) to recal previously typed stuff, any help?
10:00:05 <hpaste>  byorgey annotated "(no title)" with "something like this" at http://hpaste.org/3104#a2
10:00:19 <Cale> lnxmomo: hmm, did it maybe not get compiled against readline?
10:00:26 <byorgey> Arnar: ^^^ untested but that's the general idea.
10:00:28 <Arnar> a co-student of mine is using unsafe IO or sth. like that - which is a concept I haven't read about yet..
10:00:35 <fax> Cale: I found l-systems in haskell type system
10:00:36 <Arnar> byorgey: thanks
10:00:37 <byorgey> Arnar: that's rarely necessary.
10:00:40 <fax> :t (fix . fix . fix)
10:00:42 <lambdabot> forall a. (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> a
10:00:45 <birkenfeld> @pl \l a -> l*(1+a)
10:00:45 <lambdabot> (. (1 +)) . (*)
10:00:49 <fax> :D
10:00:52 <Cale> lnxmomo: try:  ldd `which hugs`
10:01:08 <Cale> lnxmomo: and make sure that libreadline.so.5 shows up
10:01:35 <Cale> (I'm assuming from your nick that you're a linux user :)
10:01:41 <byorgey> Arnar: this also fixes the problem that you had sos_C (Inter c' s) listed twice
10:01:47 <RyanT5000> anyone know how to add header fields to HTTP responses in HAppS?
10:01:49 <lnxmomo> ok, one sec Cale
10:01:54 <RyanT5000> i need to use Cache-Control: no-cache
10:02:03 <byorgey> Arnar: since it has type IO Cfg it might do something different each time!
10:02:11 <Arnar> byorgey: thanks.. it compiles, so I expect it works correctly :)
10:02:15 <byorgey> hehe
10:02:18 <Arnar> byorgey: right..
10:02:30 <Cale> lnxmomo: Unfortunately, if that doesn't reveal the problem, I really don't know what's wrong. I don't really use hugs all that much.
10:02:36 <Arnar> it's even more readable this way too..
10:02:45 <Arnar> so I'm a happy customer, thanks again :)
10:02:58 <lnxmomo> Cale: libreadline did not show up
10:03:31 <byorgey> Arnar: you're welcome =)
10:03:37 <Cale> lnxmomo: Okay, then the package you're using didn't have it compiled against readline for some reason.
10:03:48 <lnxmomo> hmm
10:03:59 <lnxmomo> so what should i do, recompile hugs?
10:04:13 <byorgey> Arnar: be sure to look at twanvl's solution too, it's basically the same thing but some additional ideas for you
10:04:21 <Arnar> btw. what are the indenting convetions of haskell.. my editor seems to indent stuff w. 4 spaces for me sometimes but most code I read online looks different
10:04:33 <Zao> Arnar: The distance doesn't matter.
10:04:38 <Cale> lnxmomo: I suppose, or obtain a different package... Where'd you get your package from?
10:04:39 <Arnar> byorgey: sure.. thanks to twanvl also
10:04:49 <Arnar> Zao: no, but are there any conventions documented?
10:04:53 <Arnar> like PEP8 for python
10:05:15 <lnxmomo> the official hugs website
10:05:20 <Cale> huh
10:05:21 <Zao> "avoid tabs" :)
10:05:26 <Cale> lnxmomo: Which distribution?
10:05:27 <dylan> is it possible to read read environmental variables in TeX?
10:05:32 <byorgey> Arnar: in general Haskellers seem militantly agnostic about indentation conventions =)
10:05:40 <Arnar> :)
10:05:46 <byorgey> Arnar: in the absence of other considerations, 4 spaces seems common
10:05:59 <Cale> As long as things are *lined up the right way*
10:06:00 <byorgey> Arnar: but usually people just indent things in a way that "seems right"
10:06:01 <Cale> hehe
10:06:08 <dylan> err, wrong channel.
10:06:29 <Arnar> I'll try to use my limited aesthetic sense then :)
10:06:34 <byorgey> Arnar: but as Cale is referring to, the indentation can matter to the compiler
10:06:40 <Cale> Not just that
10:06:48 <Cale> if foo
10:06:51 <Cale>    then bar
10:06:55 <Cale>    else quuux
10:07:08 <Cale> That's how you indent an if-then-else :)
10:07:31 <Cale> You can also put the "then bar" on the same line as the "if" but if you do, the "else" should still line up with it.
10:08:27 <Cale> As a general rule, if some part of syntax is "inside" another, then it's indented farther.
10:08:43 <Arnar> ok.. I'm used to that from Py
10:09:09 <Arnar> man, is fp fun or what though.. :)
10:09:13 <Cale> The exact indentation level of the 'then' and 'else' doesn't matter so long as it's deeper than the 'if' and the same.
10:09:25 <twanvl> Cale: the 'then' and 'else' don't have to line up
10:09:29 <byorgey> Arnar: welcome to the club =)
10:09:33 <Cale> twanvl: They're not *required* to
10:09:39 <Cale> twanvl: But you still *should*
10:09:44 <twanvl> true
10:09:55 <Arnar> byorgey: ta.. I've long liked FP, just haven't had proper oppurtunity to use it
10:10:03 * mrd prefers case () of () | ... over if-then-else-if
10:10:28 <Cale> and if you decide to format an if-then-else like C users do, be prepared to be bitten when you try to put one inside a do-block :)
10:11:08 <Cale> Hehe, last night's reddit comment is up to 64 points :)
10:11:23 <mrd> it's just opinion i suppose, but i think if-then-else and let-in are ugly
10:11:37 <Cale> mrd: Isn't let-in kind of necessary?
10:11:44 <mrd> where
10:11:50 <Cale> where is different though
10:12:03 <Cale> It scopes over guards, and isn't part of an expression.
10:12:09 <mrd> yea..
10:13:02 <Cale> Which one I use usually depends on what I want the reader to think about first.
10:13:13 <mrd> the way let-in forces you to indent is just .. annoying
10:13:21 <Cale> hm?
10:13:26 <mrd> with the 'in' dangling in the middle somewhere
10:13:38 <Cale> You can line the 'in' up with the 'let'
10:13:43 <mrd> it breaks the flow of declared functions/patterns
10:13:46 <Cale> Which is how most people do it.
10:14:00 <mrd> yea but that wastes lines
10:14:07 <Cale> wastes lines?
10:14:21 <Cale> Presumably on the previous line, you have a declaration...
10:14:23 <geocalc> so use {}
10:14:39 <mrd> a whole line devoted to 'in'
10:14:41 <Cale> Or else you have only a small declaration, and the 'in' is the last thing on the line.
10:14:49 <Cale> huh?
10:14:56 <Cale> let x = 5
10:14:59 <Cale>     y = 6
10:15:02 <Cale> in x + y
10:15:09 <Cale> like that
10:16:01 <mrd> compare that to a 'where' .. like so .. i'll hpaste
10:16:14 <byorgey> "wastes" lines?  I didn't realize there was a shortage of lines
10:16:29 <Cale> Yeah, I'm not so sure I understand that.
10:16:42 <Cale> As if you're going to put the 'in' on the y = 6 line?
10:16:53 <Cale> let x = 5
10:16:57 <Cale>     y = 6 in x + y
10:17:03 <Cale> That's kind of nuts.
10:17:07 <sjanssen> usually, I'm worried about running out of horizontal space, not vertical space
10:17:25 <hpaste>  arnar annotated "(no title)" with "(no title)" at http://hpaste.org/3104#a3
10:17:27 <hpaste>  mrd pasted "let/where" at http://hpaste.org/3106
10:17:28 <Arnar> byorgey: hey, seems the if-then-else went away when I put in the other case:
10:17:37 <Arnar> see paste..
10:17:38 <mrd> sjanssen: right, and that's my complain about cale's style
10:17:42 <Cale> mrd: they're both 3 lines
10:17:50 <Arnar> but I have a feeling it could be written more cleanly..
10:18:45 <kscaldef> anyone here who can assist me with profiling / SCC annotations?
10:18:58 <Arnar> perhaps like this:
10:19:00 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/3104#a4
10:19:06 <Cale> kscaldef: ask away
10:19:09 <hpaste>  sjanssen annotated "(no title)" with "whitespace nits" at http://hpaste.org/3104#a5
10:19:11 <Arnar> sorry.. that (anonymous) was me
10:19:12 <hpaste>  byorgey annotated "(no title)" with "you can pull out the return" at http://hpaste.org/3104#a6
10:19:46 <mrd> in any case, i normally use 'where' .. etc.  but today i'm using SML so i'm forced to use let-in.  so ugly =)
10:19:47 <sjanssen> Arnar: try for fewer ', perhaps?
10:19:56 <Arnar> sjanssen: thanks..
10:19:57 <mrd> let-in-end, actually /ew
10:20:09 <kscaldef> Cale: well, one question (asked earlier) was: is there any way to get the effect of -auto-all on a whole module, but not on the whole package I working on?
10:20:21 <Arnar> sjanssen: yeah.. their just to match my latex doc of the formalism :)
10:20:32 <Cale> kscaldef: uh, just compile the module with -auto-all?
10:20:35 <Arnar> sjanssen: mean to rename them to c1 c2 or sth. handier
10:20:57 <sjanssen> Arnar: this is a matter of some contention, but Haskell code usually uses camelCase instead of under_scores
10:21:09 <Cale> kscaldef: perhaps it's more of a Cabal question?
10:21:15 <hpaste>  byorgey annotated "(no title)" with "use >>= and pull out return" at http://hpaste.org/3104#a7
10:21:17 <Arnar> sjanssen: ok.. thanks. The under_scores are a habit from py
10:21:18 <sjanssen> Arnar: perhaps even c, d
10:21:20 <kscaldef> Cale: so... hand compile the one file, then hope cabal does the right thing with recompiling the rest?
10:21:40 <Cale> kscaldef: Cabal might have a good way to specify options for one file, I don't know.
10:21:41 <Arnar> byorgey: still keep the "do" ?
10:21:54 <Cale> To be honest, I haven't used Cabal directly all that much.
10:22:10 <byorgey> Arnar: ah, good point, I guess you don't need that anymore.
10:22:14 <kscaldef> Cale: also I'm trying to understand the best way to handle this sort of function declaration: http://hpaste.org/3103
10:22:20 <Cale> there's a hanging ) in that code you guys are working on
10:22:36 <Arnar> Cale: yeah.. saw that one
10:22:53 <sjanssen> kscaldef: can you put -auto-all in a GHC_OPTIONS pragma?
10:22:54 <kscaldef> if I put the SCC annotation after each of the = signs, it doesn't seem like everything gets accounted for
10:22:56 <Cale> kscaldef: you could put the SCC before the expression
10:22:56 <byorgey> right, I uh.... was leaving that as an exercise for Arnar... yeah...
10:23:08 <Cale> kscaldef: oh?
10:23:22 <sjanssen> no, I guess you can't
10:23:24 <kscaldef> Cale: I tried before the function name, and that didn't compile either
10:23:52 <Arnar> thanks guys..
10:24:41 <Cale> kscaldef: when you say that not everything gets accounted for, what do you mean?
10:24:46 <kscaldef> Cale: yeah, it claims no signficant time is spent in delta, and I actually know that like 99% of the time is spent there (or, at least, inherited by it) from previously recompiling everything with -auto-all
10:25:19 <kscaldef> but, I'm trying to avoid -auto-all at this point, because it's just too damn much output to wade through
10:27:46 <kscaldef> sjanssen: was "no, I guess you can't" in reference to your last message to me?
10:28:03 <sjanssen> kscaldef: yes
10:28:07 <kscaldef> hmm... I guess so, since I just confirmed that doesn't sompile
10:28:11 <kscaldef> compile, even
10:28:33 <sjanssen> kscaldef: Cabal probably can't do it, but you can do it manually
10:28:55 <sjanssen> kscaldef: ghc --make ModuleToProfile -prof -auto-all; ghc --make Main.hs -prof
10:29:21 <misterbeebee> > runWriter $  fmap  (1+) Writer { runWriter = (2, "a")}
10:29:23 <lambdabot>  (3,"a")
10:29:23 <misterbeebee> > fmap (1+) ("a", 2)
10:29:25 <lambdabot>  ("a",3)
10:29:42 <misterbeebee> why is this a good idea? Writer and tuple switch the placement of distinguished tuple-member
10:30:01 <misterbeebee> what is the tuple version good for, besides a poor-man's Writer?
10:30:30 <sjanssen> hmm, I wonder why they switch the order
10:30:30 <Cale> misterbeebee: the mtl is backwards in some ways
10:30:39 <Cale> They do the same stupid thing with State
10:30:55 <Cale> s -> (a,s) rather than s -> (s,a)
10:31:20 <RyanT5000> position is a poor way of naming members
10:31:32 <RyanT5000> if we had decent records...
10:31:38 <Cale> RyanT5000: they don't really have better names here
10:32:29 <RyanT5000> Cale: what do you mean? you could just name them "state" and "retval" or something
10:32:38 <RyanT5000> Cale: that is, if the record system wasn't such a pain
10:32:45 <Cale> Yeah, but those are no more informative than (s,a)
10:32:57 <allbery_b> what's wrong with the record system in this context?
10:33:14 <RyanT5000> allbery_b: not much, surprisingly, but it's still way easier to update tuples than records
10:33:26 <RyanT5000> allbery_b: e.g.: there's no Control.Arrow.second equivalent
10:33:26 <Cale> allbery_b: Nothing, it's just syntactically heavy.
10:33:46 <RyanT5000> Cale: the point of using records instead of tuples is that it erases ordering
10:33:56 <Cale> But it doesn't.
10:33:57 * allbery_b thinks the syntactic heaviness here has more to do with *names* than with records
10:34:10 <RyanT5000> Cale: that's another complaint i have about the record system :P
10:34:17 <allbery_b> which, if you think about it, kinda shoots the whole notion down
10:34:22 <Cale> Well, we don't really have a record system
10:34:29 <Cale> We have a record-like syntax for ADTs
10:34:56 <Cale> Haskell really does need a proper record system, and of course it needs someone to implement it :)
10:35:08 <misterbeebee> RyanT5000, you want positional functions to work on all records, not just tuples?
10:35:18 <Cale> If you're feeling up to it, I recommend Daan's system.
10:35:27 <Cale> (though please pick better syntax)
10:35:45 <Cale> Steal all the semantics from Daan's system though.
10:36:05 <RyanT5000> misterbeebee: i'd like something that avoids (\r -> r { thing = new_value })
10:36:27 <Cale> We need records with proper row types.
10:36:32 <RyanT5000> misterbeebee: also, i somehow want member names to be first-class, rather than just desugaring them into a bunch of access functions
10:36:53 <Cale> http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf
10:36:55 <lambdabot> http://tinyurl.com/392r4k
10:37:01 <Cale> Check out that paper :)
10:38:58 <misterbeebee> Cale: did Daan create a reference implementation, or are your syntax complaints about the notation of the paper?
10:39:04 <birkenfeld> @pl \a b -> b
10:39:04 <lambdabot> const id
10:39:24 <Cale> misterbeebee: the paper -- in particular, I really hate the idea of using r.y for lookup.
10:39:39 <RyanT5000> Cale: yeah, . is already overused
10:39:52 <RyanT5000> Cale: also, haskell really really needs namespace nesting
10:39:57 <Cale> The field name should go before anyway.
10:40:30 <RyanT5000> Cale: records would already be a million times better if you could surround their definition in a namespace Something { data Something = { getThing :: Thing } }
10:41:11 <misterbeebee> RyanT5000: can you get the equivalent by giving each record its own module?
10:41:13 <Cale> I actually rather like the way the current system makes the extractor a function.
10:41:26 <Cale> Yeah, you can put them into their own module.
10:41:27 <RyanT5000> misterbeebee: yeah, you can
10:41:37 <misterbeebee> smells like Java...
10:41:39 <RyanT5000> misterbeebee: that's exactly what i'm suggesting: submodules
10:41:42 <Cale> I actually abuse that feature more than I actually use proper records.
10:41:54 <Cale> (the deconstructor function)
10:42:19 <sjanssen> yeah, newtype X a = X { runX :: a } is a really useful idiom
10:42:44 <RyanT5000> sjanssen: it makes me sad
10:42:45 <misterbeebee> RyanT5000: submodules, yes. is there a mathematical difficulty, or just no one cared enough to make a ghc extension yet?
10:42:52 <Cale> RyanT5000: why?
10:43:08 <RyanT5000> it abuses encapsulation
10:43:09 <Cale> misterbeebee: no, there's no real difficulty I don't think.
10:43:16 <sjanssen> RyanT5000: I don't follow
10:43:21 <RyanT5000> i mean, i guess it's invisible outside of the module
10:43:23 <Cale> encapsulation?
10:43:35 <Cale> Yeah, encapsulation is provided at the module level.
10:43:41 <Cale> and not before
10:43:41 <RyanT5000> yeah, so it's not so bad
10:43:58 <RyanT5000> but i don't like the idea that within the module it works as an updater
10:43:59 <Cale> It would be nice to have multiple modules per file.
10:44:02 <RyanT5000> it doesn't make sense
10:44:07 <RyanT5000> anyway, it's only a small complaint :P
10:44:14 <Cale> updater?
10:44:22 <RyanT5000> { runX = blah }
10:44:24 <Cale> You mean r { foo = x } ?
10:44:25 <sjanssen> X { runX = a }
10:44:28 <Cale> yeah
10:44:34 <RyanT5000> that's kind of bizarre
10:44:52 <Cale> Well, in that particular case it's a little odd.
10:45:12 <misterbeebee> aside, I see some people use runX, some people use unX.. I thought runX is convention for IO actions, but writer doesn't have side-effect... /confused
10:45:22 <Cale> I've never seen anyone do that with a one-field type though.
10:45:26 <sjanssen> misterbeebee: runX is usually for monads
10:45:32 <RyanT5000> yeah
10:45:37 <sjanssen> getX is for everything else
10:45:52 <Cale> unX is pretty common actually
10:46:03 <Cale> When you're newtyping things just for the type system benefit.
10:46:42 <sjanssen> I can't think of any unFoo in the standard libraries
10:46:49 <sjanssen> Data.Monoid has getSum, etc.
10:47:14 <Cale> Yeah, I don't think there is one, but there are lots of them in code that's lying around all over the place.
10:47:25 <Cale> I've seen it on the mailing lists a lot
10:47:53 <kscaldef> grrr... this profiling call graph just doesn't make sense... I would really like to know how to add SCC annotations that are identical to what -auto-all does, because what I'm doing clearly isn't
11:01:44 <Arnar> hey guys.. couldn't this be rewritten in some nice way using $ and .    f input = sos_C ( Inter (parser $ lexer input) emptyState )
11:02:13 <Beelsebob> what do you not like about that?
11:02:21 <Beelsebob> it's pretty clear to me
11:02:39 <Arnar> Beelsebob: nothing actually.. but seeing different versions helps me learn and understand
11:02:45 <Beelsebob> okay
11:03:04 <Beelsebob> well, I wouldn't say it would improve it, but you certainly could make it point free...
11:03:23 <Cale> f input = sos_C $ Inter (parser $ lexer input) emptyState
11:03:42 <Beelsebob> and you could of course take the brackets out from the Inter
11:03:46 <Beelsebob> but again... not clearer
11:03:57 <Cale> Only with some fiddling
11:04:01 <Beelsebob> indeed
11:04:02 <Arnar> Cale: thanks.. actually I *do* find that clearer
11:04:11 <Beelsebob> hmm?
11:04:17 <Beelsebob> why is that?
11:04:27 <Beelsebob> at the moment you've got a nice seperation of your intermediate data structure
11:04:35 <Arnar> dunno really..
11:04:38 <Arnar> Beelsebob: true..
11:04:43 <Beelsebob> it's clearly seperated off and passed into a processing function (whatever sos_C does)
11:05:00 <Cale> @pl f input = sos_C ( Inter (parser $ lexer input) emptyState )
11:05:00 <lambdabot> f = sos_C . flip Inter emptyState . parser . lexer
11:05:12 <Beelsebob> hmm
11:05:16 <Beelsebob> now that's actually quite nice
11:05:16 <Cale> That's actually pretty nice
11:05:28 <Cale> f = sos_C . (`Inter` emptyState) . parser . lexer
11:05:33 <Beelsebob> much better
11:05:40 <Beelsebob> Cale wins
11:05:44 <Arnar> hehe
11:06:13 <Arnar> so x `f`†y  is  f x y  ?
11:06:18 <Cale> yep
11:06:29 <Arnar> nice
11:07:02 <Beelsebob> this is especially nice for making nice readable code when you have functions that should really be infix... like x `elem` ys
11:07:03 <Arnar> so you're kinda using it there to "curry" the second argument.. if I'm getting it correctly?
11:07:13 <Arnar> aha..
11:07:33 <Cale> I'm using it to partially apply Inter to its second argument.
11:07:55 <Cale> Inter is already curried, but not in the way which would make that partial application convenient.
11:07:58 <Arnar> Cale: yeah. then I got it correctly
11:08:05 <Arnar> Cale: right..
11:09:18 <Arnar> that rewriting just saved me a "where"
11:09:33 <Beelsebob> hehe
11:09:42 <EvilTerran> it's a nice idiom, i find, (`f` x) for (flip f x). even if you wouldn't normally use f infix.
11:09:57 <EvilTerran> and sometimes it gets me using `f` elsewhere when i hadn't thought to previously
11:09:59 <Beelsebob> yeh, tis much nicer
11:10:16 <centrinia> Is it a Very Bad(tm) thing for the type inference of a type system to be undecidable?
11:10:26 <Arnar> yes.. in practice I often find myself wanting to partially apply a function (of arity 2) to it's second argument
11:10:37 <Beelsebob> centrinia: yes, extremely bad
11:10:48 <Beelsebob> it means your compiler could run off and never terminate
11:10:51 <centrinia> Why is it extremely bad?
11:10:53 <pjd> could
11:10:57 * EvilTerran writes a makefile
11:11:01 <centrinia> Ah.
11:11:08 <EvilTerran> .PHONY: parent
11:11:08 <EvilTerran> parent:; $(MAKE) -C ..
11:11:12 <EvilTerran> <finis>
11:11:33 <RyanT5000> Beelsebob: i disagree that that's an "extremely bad" thing
11:11:33 <Beelsebob> pjd: I'd consider the possibility that (a) you can't compile something (b) when you can't, you won't be sure if you can't, or if it's simply taking a long time, an exteremly bad thing
11:11:53 <newsham> ?quote pedantic
11:11:53 <lambdabot> No quotes match. The more you drive -- the dumber you get.
11:11:58 <newsham> ?quote pedant
11:11:58 <RyanT5000> Beelsebob: if a program is going to have an infinite loop, it's best to do it while a programmer is sitting right there
11:11:58 <lambdabot> lament says: I never close <pedant> tags. I just nest them.
11:12:15 <centrinia> Ryan, that's not the topic.
11:12:18 <Beelsebob> no
11:12:26 <Beelsebob> although he does have a point
11:12:32 <pjd> Beelsebob: what's the practical difference between a non-terminating computation, and a terminating computation that would take a thousand years? :)
11:12:34 <RyanT5000> centrinia: sorry, i didn't read the beginning
11:12:45 <Beelsebob> if you could invent  a type system that finds non-termination, then it would possibly be a good thing
11:12:53 <EvilTerran> better to have compilation be undecidable than runtime be such, i guess
11:12:59 <RyanT5000> that wasn't my point
11:13:02 <pejo> Beelsebob, does undecidable type inference imply  non-termination by default? Could just approximate divergece and have the user annotate terms that can't be inferred.
11:13:07 <Beelsebob> pjd: does it matter if the computation takes 20 minutes and you press ctrl-c at 19.99 minutes?
11:13:28 <pjd> Beelsebob: can the type system guarantee the time use?
11:13:37 <RyanT5000> i don't mind the idea of compilation being undecidable
11:13:38 <centrinia> I doubt it, pjd.
11:13:45 <RyanT5000> there's a programmer *right there* to fix it
11:13:55 <jmob> How does the liftIO function work?
11:14:00 <Beelsebob> except that the programmer can not fix it
11:14:03 <Beelsebob> because he will get no error
11:14:03 <RyanT5000> no one would ever propose a decidable language for runtime (for most applications, anyway)
11:14:04 <EvilTerran> RyanT5000, except in the case of build-it-yourself OSS
11:14:15 <jmob> is liftM a generalization of liftIO?
11:14:23 <Beelsebob> he will have no idea which part of his 1000000 line program is causing the compiler to take a possibly infinite amount of time
11:14:27 <RyanT5000> EvilTerran: ok, so then it still just has to be as debugged as the runtime would normally have to
11:14:32 <pjd> in practice, the question isn't whether the type system *could* go off in a loop, but whether it actually does
11:14:33 <centrinia> There is a decidable runtime language (that is inconsistent). :-)
11:14:37 <EvilTerran> true
11:14:47 <RyanT5000> Beelsebob: why can't we make the same kind of tracing systems for compilation that we do for runtime?
11:15:05 <pjd> Turing-complete type systems are plenty useful in practice
11:15:09 <Beelsebob> well we could... it would be called debugging the compiler
11:15:18 <RyanT5000> Beelsebob: yep :)
11:15:19 <Beelsebob> which is not a fun game at any time of the month ;)
11:15:28 <RyanT5000> Beelsebob: however, you don't actually have to debug the compiler
11:15:43 <RyanT5000> Beelsebob: e.g.: the compiler could produce a "movie" of the reductions taking place in the type system
11:15:55 <Beelsebob> hmm?
11:15:58 <RyanT5000> Beelsebob: as long as the production of each "frame" is decidable (which is really easy to do)
11:15:59 <Beelsebob> and what would said movie look like?
11:16:15 <RyanT5000> Beelsebob: i dunno, something like debugging printf's, with a nice viewer
11:16:19 <pejo> Ryan, is the user expected to watch the movie?
11:16:20 <Beelsebob> and suppose the first frame is undecidable?
11:16:30 <RyanT5000> Beelsebob: i just said that each frame needs to be decidable
11:16:31 <Beelsebob> then which part of the program must be fixed?
11:16:44 <RyanT5000> Beelsebob: the point is just that you don't have to actually debug the code of the compiler
11:16:55 <Beelsebob> no, but you have to get damn close
11:17:07 <Beelsebob> you have to know how the compiler is doing it's type inference
11:17:10 <RyanT5000> Beelsebob: it would be more like debugging a program that generates another program
11:17:24 <Beelsebob> which is an extremely hard task
11:17:31 <Beelsebob> believe me... I've tried debugging hat-trans
11:17:38 <EvilTerran> it's no more debugging a compiler than debugging a script in an interpreted langauge is debugging the interpreter
11:18:02 <RyanT5000> Beelsebob: i've done plenty of that kind of stuff too, but in practice it will rarely come up
11:18:05 <Beelsebob> EvilTerran: no, the point is that you're not trying to find where the execution of the script is going wrong
11:18:06 <centrinia> This is bad, there is no way that GADTs can be general and infered. :(
11:18:16 <Beelsebob> you're trying to find where the execution of the compiler is diverging
11:18:23 <Beelsebob> even if that means fixing the script
11:18:29 <RyanT5000> Beelsebob: not to mention, in practice, most type systems seem to eventually evolve into undecidable ones
11:18:36 <RyanT5000> Beelsebob: e.g.: C++, Haskell
11:18:47 <Beelsebob> RyanT5000: I wouldn't necessarily call this a good thing ;)
11:18:49 <RyanT5000> everyone always wants undecidable features
11:18:57 <EvilTerran> Beelsebob, if your type system is undecidable by its very nature, then it's not the compiler that's at fault if the typing of your program diverges
11:18:59 <centrinia> Isn't ADT inference decidable?
11:19:01 <Beelsebob> incidentally, which feature of Haskell is undecidable?
11:19:04 <EvilTerran> it means you're using the type system wrong
11:19:15 <RyanT5000> Beelsebob: -fallow-undecidable-instances
11:19:20 <Beelsebob> EvilTerran: no, it may not be at fault -- but that doesn't mean you're not trying to find where the compiler diverges
11:19:22 <MyCatVerbs> Beelsebob: whether or not the program will terminate? ;)
11:19:26 <RyanT5000> (unless my understanding is wrong)
11:19:28 <Beelsebob> RyanT5000: that's not part of Haskell ;)
11:19:38 <RyanT5000> Beelsebob: yeah, but it is effectively
11:19:44 <Beelsebob> no
11:19:49 <RyanT5000> Beelsebob: as i said, it's always a feature added by popular demand
11:19:50 <EvilTerran> s/compiler/interpreter/, and see my last comment
11:20:01 <Beelsebob> it's part of an experimental compiler's un-standardised language
11:20:04 <RyanT5000> Beelsebob: and what's the point of a language/compiler/etc. other than to do what the users want it to?
11:20:05 <Beelsebob> it is not part of Haskell
11:20:13 <Tac-Tics> A nonstandard haskell is a haskell none the less
11:20:17 <RyanT5000> Beelsebob: that's an irrelevant distinction in practice
11:20:24 <EvilTerran> any sufficiently powerful type system is indistinguishable from an interpreted language ;)
11:20:25 <centrinia> Yeah, decide if (f 0) will terminate: f::Integer -> Integer; f x = f (x+1) - 1
11:20:25 <RyanT5000> Beelsebob: although i do recognize that you're correct
11:20:35 <Beelsebob> RyanT5000: on the contrary, I see it as the biggest problem with Haskell just now
11:21:07 <RyanT5000> Beelsebob: so how do you propose haskell become haskell' or whatever?
11:21:18 <RyanT5000> Beelsebob: just magically throw in a bunch of untested features all at once?
11:21:31 <EvilTerran> keep experimental language extensions in the HEAD?
11:21:48 <Beelsebob> RyanT5000: well, no -- first we have a load of experimental bits which we call "some other experimental language" (stage we're at now)
11:21:59 <Beelsebob> then we decide which experimental bits are (a) stable (b) useful
11:22:08 <Beelsebob> then we put them into the stable language and call it a standard
11:22:11 <RyanT5000> Beelsebob: it's irrelevant what people *call* it; it only matters what people are actually using
11:22:16 <EvilTerran> if people want to stick to haskell 98, there's flags to enforce that. turns out people quite like some of those experimental features, even if they are experimental
11:22:22 <RyanT5000> Beelsebob: also, why would we exclude an "unstable" feature that everyone finds amazingly useful?
11:22:24 <centrinia> Beelsebob, you forgot (c) implementable.
11:22:27 <Beelsebob> note that the Haskell' committie are doing their best to avoid things that make the type system undecidable
11:22:39 <Beelsebob> centrinia: that's counted within stable ;)
11:22:43 <Tac-Tics> A compiler that can freeze is no friend of mine
11:22:51 <Beelsebob> ditto
11:23:07 <RyanT5000> Beelsebob: the point of a language is not to be an object of crystaline perfection, but to be useful (i suppose that's a matter of opinion)
11:23:09 <EvilTerran> hence the recursion limit on undecidable instances
11:23:25 <Beelsebob> RyanT5000: indeed it is a matter of opinion ;)
11:23:30 <centrinia> Beelsebob, the entire language is universal, ergo it is undecidable. :(
11:23:47 <Tac-Tics> running a program in the language does not guarantee halt
11:23:48 <EvilTerran> if you can't work within such a limit, i'd say you're abusing the feature
11:23:50 <Tac-Tics> compiling a program does
11:23:52 <RyanT5000> centrinia: but the type system isn't the language
11:23:55 <EvilTerran> although, again, a matter of opinion
11:24:27 <RyanT5000> anyway, i can't keep talking about this since i have stuff to get done, lol
11:24:29 <RyanT5000> i wish i could
11:24:30 <centrinia> We can use Zero'th Order Haskell as a type system for First Order Haskell.  :)
11:24:54 <EvilTerran> in haskell'', :: will be an operator defined in the prelude!
11:25:45 <centrinia> That's like defining what the meaning of is is.
11:26:11 <Tac-Tics> "is" is defined as ==
11:26:19 <centrinia> No, that's is?
11:26:40 <Tac-Tics> "is?"
11:26:47 <centrinia> Yes, as a question.
11:26:50 <centrinia> Is ... ?
11:26:58 <Tac-Tics> then in other languages, with ===, === is defined as "is?????"
11:27:09 <EvilTerran> "is-p"
11:27:16 <centrinia>  :p
11:27:32 <Tac-Tics> (eval (is-p is-p is-p))
11:27:32 <EvilTerran> (:p) = not.null -- ;)
11:28:07 <EvilTerran> (pronounced "cons-p")
11:28:26 <centrinia> The definition of the comment operator will also appear in haskell''
11:28:45 <EvilTerran> you'll also be able to have sections of (->)
11:29:27 <centrinia> returnsInt = (->Int)
11:30:33 <EvilTerran> i was thinking such things as (\x ->) and (-> 2*x) as expressions
11:31:08 <EvilTerran> or maybe something like (f x =) and (= 2*x), likewise
11:31:14 <EvilTerran> >:)
11:32:33 * EvilTerran wanders off to meditate on the viability of that sort of thing
11:32:47 <Tac-Tics> I think Haskell needs a cleaner record syntax
11:33:10 <Tac-Tics> Having it throw the record names into the global scope as functions is kinda annoying sometimes
11:33:21 <centrinia> The Haskell type system needs to be able to express type Even =2*Int
11:34:01 <Tac-Tics> Why not just declare it as
11:34:01 <Tac-Tics> data Even = Int
11:34:01 <Tac-Tics> toInt (Even i) = 2 * i
11:34:49 <mrd> data Even = Even Int
11:35:04 <Tac-Tics> yes yes
11:35:14 <Tac-Tics> syntax errors and lost generality aside
11:35:18 <centrinia> Hmm, Haskell needs subtypes.
11:35:29 <mrd> @src Integral
11:35:30 <lambdabot> class  (Real a, Enum a) => Integral a  where
11:35:30 <lambdabot>     quot, rem, div, mod :: a -> a -> a
11:35:30 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
11:35:30 <lambdabot>     toInteger           :: a -> Integer
11:35:37 <mrd> ^ implement that for Even
11:35:43 <Tac-Tics> indeed mrd, that's what I meant by lost generality
11:36:00 <mrd> what's lost?
11:36:30 <centrinia> The fact that Integral Even loses half of the Integers.
11:36:47 <mrd> it still has the same cardinality as the Integers
11:36:56 <centrinia> Yeah, who's counting?
11:37:01 <mrd> Cantor
11:37:07 <Tac-Tics> It should probably be data Even = forall i. Integral i => Even i or something like that
11:37:16 <Tac-Tics> Cantor could only count integers
11:37:29 <Tac-Tics> He kinda let us down with the bigger things
11:37:35 <misterbeebee> jmob:
11:37:40 <misterbeebee> @type liftM
11:37:41 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:37:46 <misterbeebee> @type liftIO
11:37:47 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:39:20 <misterbeebee> http://www.haskell.org/all_about_monads/html/transformers.html
11:39:21 <lambdabot> Title: Monad transformers
11:39:39 <Tac-Tics> The Transformers! More than meets the eye!
11:39:51 <misterbeebee> "Recall the liftM family of functions which are used to lift non-monadic functions into a monad...Many monad transformers also provide a liftIO function, which is a version of lift that is optimized for lifting computations in the IO monad. "
11:40:17 <Tac-Tics> interesting
11:40:30 <Tac-Tics> @type liftIO
11:40:32 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:40:49 <mrd> guess everyone's busy hacing
11:41:06 <Tac-Tics> wait, it takes an IO action and pipes it into another monad?
11:41:17 <lokadin_> a lil OT but what are those tests called that have semi scrambled letters that one must type to prove they are not a computer?
11:41:19 <Tac-Tics> @index liftIO
11:41:19 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:41:44 <pjd> lokadin_: "captchas"
11:41:50 <lokadin_> thanks :)
11:43:52 <Cale> Huh, I was going to say to count higher, you'd need Zermelo, but it turns out that Cantor himself took the well-ordering theorem to be a "fundamental principle of thought"
11:44:55 <Cale> Zermelo was the first to prove it, using the axiom of choice, which he considered an "unobjectionable logical principle". :)
11:45:04 <misterbeebee> Tac-Tics:  I don't quite understand it either... liftIO looks pretty similar to unsafePerformIO. My only guess is that when liftIO is defined, it's a safe implementation that strips off the IO and replaces it with another monad's implementation of the "side-effect protection" instead
11:45:24 <Botje> liftIO requires the monad to be an instance of MonadIO.
11:45:29 <Botje> ?instance MonadIO
11:45:29 <lambdabot> Maybe you meant: instances instances-importing
11:45:33 <Botje> ?instances MonadIO
11:45:34 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
11:45:42 <Tac-Tics> Having more options available makes making a decision harder
11:45:50 <Botje> so all of those can use  liftIO
11:45:54 <Tac-Tics> clearly, with an infinite number of things, you can't pick the "best" one
11:45:55 <fasta> How do I express that in class A a b where f:: a->[b] a completely determines b without fundeps?
11:46:02 <Tac-Tics> because there's too many alternatives
11:46:37 <misterbeebee> "being an instance of MonadIO" === "defined liftIO"
11:46:39 <Tac-Tics> (heh, that's not quite it, is it?)
11:47:01 <EvilTerran> fasta, with type families
11:47:18 <fasta> EvilTerran: well, the implicit question was: how with type families?
11:47:26 <fasta> EvilTerran: (as that's the only alternative)
11:47:36 <fasta> EvilTerran: I can also check for myself first :)
11:47:37 <EvilTerran> ah, okay. just checking
11:47:56 <EvilTerran> class A a where type b; f :: a -> [b]; -- i think
11:48:08 <EvilTerran> then instance A Foo where b = Bar; f = ...; -- or something
11:48:32 <EvilTerran> wait, that's associated type synonyms, isn't it?
11:48:37 <fasta> EvilTerran: are type families documented in some user guide already?
11:48:45 <EvilTerran> um
11:48:51 <EvilTerran> @where families
11:48:51 <lambdabot> I know nothing about families.
11:49:26 <EvilTerran> @wiki type families
11:49:26 <lambdabot> http://www.haskell.org/haskellwiki/type_families
11:49:40 <EvilTerran> http://haskell.org/haskellwiki/GHC/Type_families
11:49:41 <lambdabot> Title: GHC/Type families - HaskellWiki
11:50:01 <fasta> And where is the the current docs? I thought they included them too.
11:50:14 <fasta> *documentation
11:51:26 <misterbeebee> Tac-Tics, jmob: given that every implemenation of liftIO is trivial, http://www.google.com/search?q=%22instance+monadIO+*+where+liftIO%
11:51:26 <lambdabot> http://www.google.com/search?q=%22instance+monadIO+*+where+liftIO%
11:52:05 <misterbeebee> I'm strengthening my earlier belief, that liftIO is a "tag-swapper" that says that the new monad is now responsible for containing the side-effects of the contained computations
11:53:11 <misterbeebee> (confirmation or correction from someone who knows would be helpful, though)
11:54:06 <iank> I've been fiddling with haskell for a while now, and I'd like to start seriously learning it.  Can anyone reccomend a book or two (online or print)?
11:54:43 <iank> (Something that's geared toward someone who's already a programmer would be a plus)
11:56:46 <dino-> iank: You can go through Yet Another Haskell Tutorial if you haven't seen it yet. It's a wikibook, lemme get a url..
11:57:03 <pejo> @where yaht
11:57:03 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
11:57:13 <dino-> yeah, I was thinking bot probably had it
11:57:13 <Atalanta> heya
11:57:19 <Atalanta> whats the main purpose of haskell?
11:57:24 <Atalanta> whats its primary use?
11:57:25 <iank> programmin' :)
11:57:27 <xerox> Programming
11:57:28 <Atalanta> =P
11:57:31 <iank> dino-: pejo: thanks.
11:57:35 <dino-> Atalanta: It's actually general-purpose.
11:57:41 <Atalanta> hey xerox, your products suck btw
11:57:46 <Atalanta> dino-: like c++?
11:57:50 <xerox> Atalanta: too bad.
11:57:58 <dino-> Atalanta: Some may say better than C++ :D
11:58:01 <Atalanta> xerox: you shoulda stuck with software.. not hardware
11:58:10 <Atalanta> dino-: yeah, like mauke
11:58:10 <Tac-Tics> Atalanta: Primarily, being cooler than every other language.... programming in Haskell is secondary
11:58:29 <Atalanta> ive heard that a lot of c++ guys switch to this
11:58:40 <dino-> YAHT is also a wikibook: http://en.wikibooks.org/w/index.php?title=Haskell/YAHT
11:58:46 <Atalanta> but i thought c++ was an end-result, like where people go when they realize qbasic etc all suck
11:59:02 <arcatan> haskell is getting overly popular, which is usually a sign for me to switch to a new language
11:59:09 <dino-> @where "Why Haskell Matters"
11:59:09 <lambdabot> I know nothing about "why.
11:59:10 <arcatan> but I don't know where to go
11:59:21 <iank> arcatan: switch to a dying one!
11:59:26 <Tac-Tics> http://www.haskell.org/haskellwiki/Why_Haskell_matters
11:59:27 <lambdabot> Title: Why Haskell matters - HaskellWiki
11:59:33 <Tac-Tics> google <3
11:59:58 <ari> arcatan: I suggest Epigram or Agda, that way you get to complain at the lack of ability to encode static guarantees in Haskell
12:00:04 <Atalanta> arcatan: switch to qbasic
12:00:15 <puusorsa> switch to threaded intercal
12:00:21 <iank> puusorsa: <3
12:00:22 <dino-> Atalanta: Read that document, Why Haskell Matters. Try to read it all, the end is particularly important.
12:00:28 <pejo> Atalanta, can't really hurt to learn another language, can it?
12:00:43 <iank> pejo: depends on the language ;)
12:01:21 <iank> Last time I played with {C++,Java}, I habitually killed hobos to relieve stress.
12:01:28 <Atalanta> pejo: lol i just started out in c++ about 2 months ago
12:01:33 <arcatan> Atalanta: I want something at least as advanced as Haskell
12:01:43 <Atalanta> pejo: and this compiler im writing in c++ is coming along nicely
12:01:45 <dino-> I'm serious about reading that document. It's the one thing I ask people to do, special, for me, even if they're sure they don't give a shit about Haskell and never will.
12:03:18 <segher> dino-: so what is at the end of that doc that is so important?  yes i'm lazy :-)
12:04:32 <pejo> Atalanta, stay with the language you are happy with. People usually switch when they are unhappy.
12:04:50 <Atalanta> ah
12:04:55 <Atalanta> just curious what this was
12:12:40 <fasta> EvilTerran: I just crashed GHC, so type families clearly aren't working yet.
12:12:48 <pejo> Atalanta, ah. If you're curious it's probably worth your time.
12:14:12 <fasta> dino-: that document presents a fantasy world.
12:15:34 <dino-> fasta: I see it as a very short description of the things that make FP in general very powerful. And a good way to show people that some of the things they expect to only get from OO are not exclusive to OO languages.
12:15:51 <dino-> Not sure what you mean.
12:15:56 <Yokisho> hi
12:16:31 <fasta> dino-: some things you can do in OO languages are a pain to do in Haskell.
12:16:55 <blakkino> fasta, example?
12:16:55 <fasta> dino-: lazy evaluation often results in problems.
12:18:08 <fasta> blakkino: try to make the standard drawShape with GTK2HS with existential types and Swing in Java and you will learn.
12:19:07 <fasta> And the amount of jargon required to be a good Haskell programmer is pretty large.
12:19:18 * earthy nods
12:20:02 <fasta> Another thing is that everyone who shows "code" only shows functional code, no references or anything like that.
12:20:39 <fasta> And although there is a possibility to get rid of references, in practical Haskell programming this is not the case, yet.
12:21:25 <fasta> An implementation of a binary tree in Java and one in Haskell are not extensible in the same way.
12:21:43 <fasta> (assuming the Haskell one is implemented in a pure way)
12:21:52 <sjanssen> I think mutable references really are the exception and not the rule
12:22:22 <fasta> sjanssen: I agree, doesn't mean my point doesn't hold.
12:22:39 <earthy> it's very hard to write completly without mutable references
12:22:39 <fasta> There should be a compiler that converts functional code into ST code.
12:23:00 <fasta> earthy: I have done so, btw.
12:23:23 <fasta> earthy: I had to do manual memory management, though.
12:23:42 <fasta> earthy: the "memory" being a DiffArray
12:23:42 <dino-> Isn't the point that you explicitly design your code to be stateful in certain places.
12:24:05 <fasta> dino-: uhm, like you know that before you program something?
12:24:14 <fasta> dino-: sometimes you _learn_ something during implementation
12:24:31 <fasta> If you don't then you are probably doing something completely trivial
12:24:36 <pejo> Prototyping is an excellent vehicle for verifying understanding of the problem.
12:24:43 <dino-> And then you rewrite that part. I'm not hearing an argument for statefulness everywhere just in case someday we need it.
12:25:01 <fasta> statefulness is also a bit overrated, imho.
12:25:28 <fasta> About every old language has some kind of module system.
12:25:54 <fasta> If you can hide the use of a "global variable" there's little difference with using a state monad.
12:26:23 <sjanssen> I don't know about that
12:26:39 <sjanssen> it is important that you can *prove* that 'f x' always means the same thing
12:26:58 <sjanssen> static guarantees are the best ones
12:27:11 <shachaf> Hmm, the darcs GHC is 6.9 now. Has 6.8 been released yet?
12:27:21 <shachaf> Or is it still a release candidate?
12:27:25 <fasta> shachaf: no, but it branched.
12:27:29 <sjanssen> shachaf: still in an RC state
12:27:37 <shachaf> OK.
12:27:42 <pejo> sjanssen, that's the same argument they use for dependent typing. Companies are writing software in C still though.
12:28:39 <earthy> process can alleviate many failings
12:28:44 <earthy> it's just more work...
12:28:45 <fasta> sjanssen: you can do the same in e.g. Scheme code which uses global variables local to a module.
12:29:26 <sjanssen> fasta: the computer will prove to me that the code is referentially transparent?
12:29:37 <sjanssen> I bet I can come up with an example the computer can't prove
12:30:11 <fasta> Dijkstra even said that functions were too complicated to use for proof ;)
12:30:24 <fasta> (that was in an imperative language, though)
12:30:52 <stoic_> > let allEqual xs = (isPrefixOf xs . repeat . head) xs in allEqual [1,1,1,1] -- is there a better, more idiomatic way to write allEqual?
12:30:54 <lambdabot>  True
12:31:04 <sjanssen> fasta: I agree that reducing the scope of state is great, I don't think that it approaches referential transparency
12:31:56 <fasta> Another practical problem with Haskell is that the time to load a module is rather high.
12:32:15 <dino-> I want to say that any impure code period is stateful. If there's any dependency on order at all. Does that sound right?
12:32:15 <sjanssen> that's purely an implementation problem
12:32:31 <fasta> sjanssen: ok, a problem with GHC then.
12:32:47 <shachaf> > let allEqual [] = True; allEqual (x:xs) = all (==x) xs in map allEqual [[],[1,1,1,1],[1,2,1,1]] -- Maybe?
12:32:48 <lambdabot>  [True,True,False]
12:32:55 <sjanssen> IME, ghci is acceptably fast
12:33:03 <sjanssen> could certainly be better, of course
12:33:10 <xerox> shachaf: null . tail . group
12:33:21 <pejo> dino, 'impure code period'?
12:33:28 <shachaf> That's even nicer. :-)
12:33:33 <xerox> :-)
12:33:39 <shachaf> > group []
12:33:40 <fasta> sjanssen: what machine do you have?
12:33:40 <lambdabot>  []
12:33:52 <sjanssen> fasta: core duo
12:33:52 <shachaf> It doesn't work on [] by itself, though.
12:34:00 <shachaf> null . drop 1 . group?
12:34:08 <xerox> > drop 1 []
12:34:10 <lambdabot>  []
12:34:13 <xerox> yes!
12:34:24 <stoic_> > (null . drop 1 . group) [1,1,1,1]
12:34:25 <lambdabot>  True
12:34:39 <fasta> sjanssen: I still have an athlon xp, and I need to wait. A reload should be near instant.
12:34:45 <stoic_> why don't I ever come up with these things :-\
12:35:15 <dino-> impure code, period, --as in-- not specifically a container to allow mutable state, but anything at all allowing side effects.
12:35:22 <idnar> @src null
12:35:22 <lambdabot> null []     = True
12:35:22 <lambdabot> null (_:_)  = False
12:35:34 <idnar> @src group
12:35:34 <lambdabot> group = groupBy (==)
12:36:04 <idnar> heh, nice
12:36:25 <shachaf> @karma in
12:36:25 <lambdabot> in has a karma of -1
12:36:27 <shachaf> in++
12:36:43 <sjanssen> dino-: there are referentially transparent functions that use state internally.  ST is a trivial proof of that
12:36:49 <sjanssen> dino-: even GHC's evaluation mechanism is stateful
12:39:23 <misterbeebee> >   map  ( null . tail . nub)  [  [1,1,1], [1,1,2,1]]
12:39:25 <lambdabot>  [True,False]
12:39:47 <MyCatVerbs> Thinking of that, surely result memoization never affects referential transparency, right? The first, second, third time you call a memoized function, you'll always get the same result - just faster the latter two times.
12:40:10 <MyCatVerbs> So why not use unsafePerformIO with Data.HashTable for function memoization?
12:40:28 <shachaf> @src nubBy
12:40:28 <lambdabot> nubBy eq []             =  []
12:40:28 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:40:46 <shachaf> @src groupBy
12:40:46 <lambdabot> groupBy _  []       =  []
12:40:46 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
12:40:46 <lambdabot>     where (ys,zs) = span (eq x) xs
12:41:38 <misterbeebee> nub is slow but pretty.
12:42:24 <sjanssen> MyCatVerbs: you certainly could
12:42:48 <stoic_> > null . drop 1 . group $ repeat 1
12:42:53 <lambdabot> Terminated
12:43:40 <oerjan> > take 0 undefined
12:43:41 <lambdabot>  Undefined
12:46:22 <oerjan> > take undefined []
12:46:24 <lambdabot>  Undefined
12:46:34 <oerjan> what, _neither_?
12:46:39 <oerjan> @src take
12:46:40 <lambdabot> take n _      | n <= 0 =  []
12:46:40 <lambdabot> take _ []              =  []
12:46:40 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:46:54 <sarehu> take 0 undefined works in GHCi
12:46:54 <oerjan> whoops
12:47:11 <oerjan> indeed it should
12:48:01 <oerjan> but lambdabot uses ghc
12:49:06 <sjanssen> "take"     [~1] forall n xs . take n xs = takeFoldr n xs
12:49:13 <sjanssen> a rewrite rule from GHC.List
12:49:25 <sjanssen> takeFoldr is too strict
12:54:04 <oerjan> @src takeFoldr
12:54:04 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:05:26 <fasta> AFAIK, unsafeperformIO is still so unspecified that in theory it is equivalent to _|_.
13:06:20 <fasta> I asked multiple times what it is specified to do, but never got a good answer.
13:07:01 <sjanssen> fasta: it isn't very well specified because it can't be defined in Haskell
13:07:27 <sjanssen> hmm, let's check what the FFI addendum says
13:08:48 <sjanssen> fasta: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-240005.1
13:08:49 <lambdabot> Title: 5 Marshalling, http://tinyurl.com/yfoy96
13:09:12 <fasta> "This value should be independent of the environment"
13:09:22 <fasta> What environment?
13:09:42 <sjanssen> they mean referentially transparent, I think
13:10:10 <fasta> Moreover, the side effects may be performed several times or not at all, depending on lazy evaluation and whether the compiler unfolds an enclosing definition.
13:10:15 <fasta> This is also very vague
13:10:22 <sjanssen> intentionally vague
13:10:27 <fasta> It's written with one implementation in mind, so it seems.
13:10:50 <sjanssen> I think the vagueness explicitly allows many implementations
13:12:39 <sjanssen> fasta: the reason the definition of unsafePerformIO is so vague is because Haskell doesn't really have operational semantics
13:13:47 <thoughtpolice> i liked this page for an explanation:
13:13:48 <thoughtpolice> http://haskell.org/haskellwiki/IO_inside
13:13:49 <lambdabot> Title: IO inside - HaskellWiki
13:14:00 <fasta> I find it _very_ annoying that there are uses of unsafePerformIO presented by people, while according to the spec there is no reason for those things to continue working.
13:14:59 <sjanssen> fasta: can you provide an example which is ambiguous according to the FFI addendum?
13:15:26 <fasta> sjanssen: it's not really ambiguous, it's more that there's no reason to expect that it works.
13:16:50 <thoughtpolice> if the operational semantics are lazy, you really -can't- be sure if an unsafePerformIO will be evaluated once and used again, done multiple times and at that, in what order, can you? that part is pretty much left to the compiler i imagine.
13:17:55 <sjanssen> fasta: the FFI addendum is pretty clear: return the result of the IO action if it is demanded, it may be executed 0 to n times.  If the action isn't referentially transparent, nasal demons
13:18:17 <fasta> a = unsafePerformIO(newIORef "") => nasal daemons?
13:18:38 <sjanssen> yes
13:19:03 <fasta> sjanssen: what's a use of unsafePerformIO that /=> nasal daemons?
13:19:10 <fasta> sjanssen: calling getEnvironment?
13:19:15 <sjanssen> consider Data.ByteString
13:19:23 <fasta> sjanssen: (assuming that it doesn't change)
13:19:36 <sjanssen> it uses, roughly, data BS = (ForeignPtr Word8, Int)
13:20:09 <sjanssen> and the library as a whole maintians the invariant that the ForeignPtr is never modified after returning a BS
13:20:48 <sjanssen> we have: head (ptr, n) | n /= 0 = unsafePerformIO (peek ptr)
13:24:10 <sjanssen> fasta: does that make sense
13:24:12 <sjanssen> ?
13:24:21 <fasta> sjanssen: I was looking at Base.hs
13:24:45 <sjanssen> Base should be renamed to InvariantBreakers.hs
13:24:46 <fasta> sjanssen: well, peek is a read only operation, so should be safe assuming ptr doesn't change.
13:25:03 <fasta> sjanssen: but why wouldn't ptr change?
13:25:38 <sjanssen> fasta: guaranteed by library invariant (assuming you don't use internal functions in Base)
13:26:01 <fasta> sjanssen: so, it must control one large piece of memory somewhere?
13:26:35 <sjanssen> fasta: it could theoretically be defeated by writing to random parts of memory
13:26:46 <sjanssen> but this isn't really a problem in practice
13:27:12 <sjanssen> pointer arithmetic can break even the pure stuff, anyway
13:27:28 <sjanssen> assume for the moment that .Base isn't exported to client programs
13:27:30 <fasta> sjanssen: does the byte string article explain why it is safe? (at a level of my questions?)
13:27:48 <fasta> sjanssen: or does it just gloss over it?
13:28:01 <sjanssen> fasta: I don't think it addresses this very much
13:28:06 <sjanssen> it is pretty simple, actually
13:28:38 <sjanssen> there are two classes of functions: producers and consumers
13:28:57 <fasta> constructors and destructors in FP-speak
13:29:07 <sjanssen> consumers should never write to a ForeignPtr
13:29:34 <sjanssen> producers can allocate a new ForeignPtr, return it, and promise never to write to it again
13:30:01 <fasta> Ok, and how does concatenation work then?
13:30:13 <sjanssen> it's both a consumer and a producer
13:30:22 <sjanssen> it allocates a new block equal to the sum of the lengths
13:30:34 <fasta> And then it copies?
13:30:35 <sjanssen> then memcpys both strings into the new block
13:30:39 <sjanssen> then returns the block
13:30:44 <fasta> Oh, then it is indeed trivial
13:31:01 <sjanssen> yeah
13:31:13 <sjanssen> of course the programmer can always make mistakes ...
13:31:28 <fasta> Yes, it's not "trivial" to implement.
13:31:50 <sjanssen> ByteString actually uses unsafePerformIO more than it needs to, I think
13:32:16 <sjanssen> a simpler system with unsafeFreeze could work too
13:32:30 <sjanssen> then the invariant is only on the producers
13:33:33 <fasta> :t unsafeFreeze
13:33:35 <lambdabot> Not in scope: `unsafeFreeze'
13:33:46 <fasta> @hoogle unsafeFreeze
13:33:46 <lambdabot> Data.Array.MArray.unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
13:34:04 <sjanssen> changes a mutable array to an immutable one
13:34:05 <fasta> When it uses DiffArray it doesn't need IO at all ;)
13:34:18 <sjanssen> of course DiffArray cheats too
13:34:24 <fasta> Yes, I know.
13:34:35 <fasta> I think DiffArray is a wonderful idea.
13:36:44 <fasta> It should be implemented so efficiently that one could implement ByteString on top of it with the same efficiency.
13:37:28 <sjanssen> ByteString is actually closer to UArray i Word8 than DiffArray, I think
13:38:40 <sjanssen> ByteString doesn't even try to tackle efficient mutability
14:13:11 <tuxplorer> how to find which module a function is in, using ghci?
14:13:21 <fasta> tuxplorer: :i
14:15:56 <dons> hackathon photos!
14:15:57 <dons>  http://stockwits.com/Hackathon.jpg
14:17:18 <C-Otto> http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
14:17:21 <C-Otto> this is a computer science lecture i recorded
14:17:21 <lambdabot> Title: S-INF.de - Vorlesungsvideos, http://tinyurl.com/y4m979
14:17:24 <C-Otto> functional programming, haskell (english)
14:17:26 <C-Otto> in HD :>
14:17:31 <C-Otto> have fun, bye
14:17:57 <dons> strange :)
14:18:18 <fasta> bot
14:18:28 <dons> nah, he's in #xmonad too :) talking.
14:18:43 <dons> its a 2005 haskell video, apparently
14:19:12 <dons> Carsten Otto
14:19:57 <fasta> Ok, so I tried Biplate...
14:20:06 <fasta> So, I decided I don't like it :)
14:20:57 <marcotmarcot> Is foldr f x xs and foldr1 f (x:xs) the same?
14:21:19 <oerjan> no
14:21:29 <oerjan> x goes at the other end
14:21:49 <marcotmarcot> hum...
14:22:10 <oerjan> but it's true for foldl vs. foldl1, i guess
14:22:24 <marcotmarcot> ok.
14:22:25 <marcotmarcot> Thanks.
14:22:44 <xerox> ?check \f x xs -> foldr (f :: Int -> Int -> Int) x xs == foldr1 f (xs ++ [x])
14:22:48 <lambdabot>  OK, passed 500 tests.
14:22:58 <oerjan> beat me to it :)
14:23:00 <xerox> ?check \f x xs -> foldl (f :: Int -> Int -> Int) x xs == foldl1 f (x:xs))
14:23:00 <lambdabot>  Unbalanced parenthesis
14:23:06 <xerox> oh well.
14:23:22 <tuxplorer> fasta: Prelude> :i withData
14:23:23 <tuxplorer> Top level: Not in scope: `withData'
14:23:37 <oerjan> ?check \f x xs -> foldl (f :: Int -> Int -> Int) x xs == foldl1 f (x:xs)
14:23:42 <lambdabot> Terminated
14:23:42 <fasta> tuxplorer: your point being?
14:24:06 <fasta> tuxplorer: (well, I understand your point, of course)
14:24:11 <oerjan> ?check \f x xs -> foldl (f :: Bool -> Bool -> Bool) x xs == foldl1 f (x:xs)
14:24:12 <lambdabot>  OK, passed 500 tests.
14:24:23 <fasta> tuxplorer: I am just trying to let you figure out why it says that
14:24:38 <tuxplorer> fasta: should I have to define the scope of search for :I to get that function? its part of HAppS. If so, how to do it?
14:25:34 <fasta> tuxplorer: imagine what this :i according to you should do: it should make a complete index of every installed library and have it accessible and up to date at any time.
14:25:59 <fasta> tuxplorer: it's not impossible to do so, but it hasn't been done.
14:26:13 <fasta> tuxplorer: most people use grep, I guess.
14:26:16 <oerjan> fasta: well it was you who claimed :i was the answer in the first place ;/
14:26:29 <fasta> oerjan: if the symbol is in scope, yes
14:26:40 <fasta> oerjan: everyone would answer that
14:27:15 <fasta> oerjan: what's ;/?
14:27:23 <oerjan> a smiley
14:27:33 <fasta> oerjan: duh
14:28:00 <oerjan> i couldn't quite decide which one to use so i think i mixed it up
14:28:14 <stoic_> ?src (!!)
14:28:14 <lambdabot> xs     !! n | n < 0 = undefined
14:28:14 <lambdabot> []     !! _         = undefined
14:28:14 <lambdabot> (x:_)  !! 0         = x
14:28:14 <lambdabot> (_:xs) !! n         = xs !! (n-1)
14:29:03 <stoic_> I don't suppose there exists a kind of (!!) that takes [Int] as a parameter?
14:29:27 <xerox> :t findIndices
14:29:29 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
14:29:41 <alexj> tuxplorer: I have the same issue with :i not necessarily finding the function.  I happen to know that withData is in HAppS.Server.SimpleHTTP so I would do a :m HAppS.Server.SimpleHTTP
14:29:43 <oerjan> you could use map, but it would be a bit inefficient
14:29:45 <alexj> and then do the :i
14:29:46 <tuxplorer> fasta: oh! ok..
14:29:52 <xerox> :t (findIndices .) . flip elem -- stoic_ maybe?
14:29:53 <lambdabot>     Couldn't match expected type `a -> Bool'
14:29:53 <lambdabot>            against inferred type `Bool'
14:29:58 <xerox> Aw.
14:30:10 <xerox> :t findIndices . flip elem
14:30:12 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [Int]
14:30:16 <xerox> alright
14:30:21 <tuxplorer> alexj: if I had loaded that module once, it gets indexed?
14:30:22 <fasta> tuxplorer: another thing is that HApps uses TH, which makes the problem impossible to solve outside GHC
14:30:45 <oerjan> hm...
14:30:47 <alexj> tuxplorer: dunno
14:30:58 <tuxplorer> okie
14:31:23 <xerox> ahum, stoic_ sorry, that's all wrong.
14:31:48 <stoic_> :t findIndices
14:31:50 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
14:31:58 <xerox> stoic_: better to roll it up by recursion. I'm not sure about the preconditions you have on the indices list.
14:31:59 <hpaste>  nomeata pasted "xmonad vs. workspace switcher" at http://hpaste.org/3107
14:32:13 <nomeata> sorry, that should have gone to #xmonad
14:32:33 <nomeata> Can I tell hpaste where to announce something?
14:32:34 <xerox> stoic_: if it's sorted it's easy to do an unfoldr.
14:32:57 <oerjan> nomeata: hpaste is only in this channel i think
14:33:08 <nomeata> oerjan: hmm. good point :-)
14:33:31 <oerjan> might be a future feature :)
14:34:27 <thoughtpolice> does anybody know any good ways to leverage and embed a problem in a type system, if there is any general approach to it? i saw that last monad.reader about embedding problems more into the type system but I haven't read it yet
14:34:48 <stoic_> xerox: you understand what I need right? if the function was given parameter [1,3,6] it should return [xs !! 1, xs !! 3, xs !! 6]
14:35:06 <dons> hey nomeata
14:35:18 <oerjan> stoic_: map (xs !!) would work, although be a bit inefficient
14:35:29 <xerox> stoic_: sure, is the list of indices ordered?
14:35:33 <oerjan> if the list is sorted you might do better
14:35:34 <stoic_> that's what I'm using atm
14:35:51 <nomeata> dons: hi
14:36:03 <stoic_> xerox: yeah it is actually
14:36:15 <oerjan> thoughtpolice: i recall a post in haskell or haskell-cafe that showed how to do it much simpler with the new type families
14:36:21 <xerox> stoic_: cool, just a sec.
14:36:28 <EvilTerran> yeah, type families would make it infinitely easier
14:36:40 <oerjan> with an example
14:38:09 <thoughtpolice> oerjan: ah yeah, that looked quite interesting. link if there is one? i can search the mailbox if you can just remember a name
14:38:54 <dons> lots of fun at the hackathon today everyone. its very exciting getting such a critical mass of hackers in one place
14:39:02 <dons> you can really get a lot done
14:39:08 <oerjan> sorry, it was a while ago, last month i think
14:39:28 <oerjan> but you could search for type family i think
14:40:03 <fasta> The wiki page on type families and implementation are both low-quality, imho.
14:40:31 <sjanssen> type families aren't ready for prime time, anyway
14:40:32 <oerjan> well they're just a month old...
14:40:39 <oerjan> or so
14:41:22 <xerox> ?type \xs is -> unfoldr (\(xs,is) -> case is of (i:is) -> let (y:ys) = drop (i-1) xs in Just (y,(ys,is)); [] -> Nothing) (xs, scanl1 subtract is)
14:41:23 <fasta> The need for all the extra syntax is also questionable.
14:41:23 <lambdabot> forall t. [t] -> [Int] -> [t]
14:41:31 <gene9> dons, I'm just curious and it's absolute offtopic, but could you estimate how make peoples there at hackathon using mac versus pc?
14:41:39 <xerox> stoic_: modulo extreme cases it works I think
14:42:16 <fasta> dons: were you on that photo? (I guess not)
14:42:28 <dons> gene9: about half and half
14:42:30 <dons> fasta: yes i am
14:42:38 <gene9> dons, I see, thanks
14:42:38 <dons> gene9: the other half is thinkpads mostly
14:42:47 <dons> maybe a bit more than half
14:43:06 <dons> fasta: i'm the one who looks tired
14:43:08 <gene9> so pcs are dominating a little bit
14:43:29 <dons> hmm, not really. the macs are, but they don't all run mac osx, i think
14:43:37 <dons> maybe they do
14:43:39 <fasta> dons: can you be more specific? ;)
14:43:40 <gene9> ok, thanks
14:43:47 <dons> i don't have a beard
14:43:47 <sjanssen> gene9: in this day and age, does it really matter if they're PCs or not?
14:44:02 <sjanssen> dons: Hackathon Guess Who?
14:44:06 <dons> :)
14:44:08 <gene9> sjanssen, like a said it's just to feed mu curiosity
14:44:11 <EvilTerran> > map head . tail . scanl (flip drop) ['a'..] . (zipWith subtract =<< (0:)) $ [1,3,6,7]
14:44:13 <lambdabot>  "bdgh"
14:44:25 <xerox> well done
14:44:26 <gene9> s/mu/sy
14:44:33 <fasta> dons: The only one who really looks tired is someone with glasses.
14:44:34 <sjanssen> gene9: I'm more curious how many run windows :)
14:44:36 <sjanssen> 4?
14:44:56 <stoic_> thanks xerox and EvilTerran ;)
14:45:14 <EvilTerran> be sure not to use that 'til you know how it works ;)
14:45:24 <sjanssen> "Does this Haskell hacker wear glasses?"
14:46:08 <dons> tibbe, theTallguy, conal, vincenz, benl, nomeata, ivant, nominolo, kolmodin, mnislaih, igloo, Binkley, Lemmih, roconnor, dons, bringert, thorkil, dcoutts and Heffalump are in that photo :)
14:47:30 <fasta> dons: if you just tag them, we don't need to guess :)
14:47:44 <dons> yeah, might do that tomorrow
14:47:48 <dons> i'm bottom left
14:48:51 <fasta> Which one is Heffalump?
14:48:59 <gene9> sjanssen, have no idea, it's nice to know, but irrelevant
14:49:05 * oerjan guesses bottom right
14:49:12 <oerjan> by his name
14:49:12 <dons> yep
14:50:16 <marcotmarcot> Where can I get doc about regexps in haskell?
14:50:22 <dons> from hackage.haskell.org
14:50:27 <dons> click on the regex package
14:50:38 <marcotmarcot> I'm looking at GHCs Text-Regex-Posix-Wrap.htm
14:50:40 <dons> or got to haskell.org, click on blog articles, and on 'regex'
14:50:44 <marcotmarcot> But it's very sintatic.
14:50:56 <dons> they're just wrappers over regex.h
14:51:03 <dons> so man regex will tell you the format of the regexes
14:51:24 <marcotmarcot> hum..
14:51:33 <gene9> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
14:51:35 <lambdabot> Title: teideal glic deisbh√©alach ª Blog Archive ª A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
14:51:38 <marcotmarcot> > subRegex (mkRegex "te") "go" "tempo teto telhado"
14:51:46 <lambdabot>   Not in scope: `mkRegex'
14:51:59 <marcotmarcot> dons: thanks.
14:52:01 <marcotmarcot> gene9: thanks.
14:52:11 <marcotmarcot> Is there a way to do a import in lambdabot.
14:52:30 <oerjan> marcotmarcot: explicitly forbidden
14:52:34 <oerjan> for safety
14:52:44 <marcotmarcot> oerjan: I've imagined.
14:53:12 <oerjan> dons doesn't want you to get anywhere near anything matching unsafe*
14:53:29 <EvilTerran> hm... there's a C function i'm binding that wants a int (*)(), this translating most directly into haskell as a FunPtr (IO CInt). how would i get this acting more haskelly?
14:53:35 <fasta> dons: for your next Python blog entry try to do something for which Python uses dictionaries and runs as fast with less code :)
14:53:54 <dons> oh, interesting idea
14:54:05 <dons> you think Map isn't up to it?
14:54:13 <marcotmarcot> gene9: this tutorial doesn't cover substitution.
14:54:24 <marcotmarcot> Prelude Text.Regex> subRegex (mkRegex "te") "go" "tempo teto telhado"
14:54:24 <marcotmarcot> "go"
14:54:31 <dons> native code always  wins in the end though
14:54:36 <marcotmarcot> I'd like to have "gompo goto golhado"
14:54:38 <gene9> marcotmarcot, I know, this just an intro
14:54:41 <oerjan> :t System.IO.Unsafe.unsafePerformIO -- perhaps :t allows this?
14:54:43 <lambdabot> forall a. IO a -> a
14:54:53 <marcotmarcot> gene9: But it made things much clearer to me.
14:54:55 <fasta> dons: since when I ported something real world(but did make the code much and much clearer in the process) I had a blowup of about a factor 5(including comments).
14:55:05 <bos> Map is very much up to it.
14:55:14 <gene9> marcotmarcot, thisi is great
14:55:14 <dons> seems strange, fasta
14:55:19 <dons> choose the wrong abstractoin?
14:55:25 <EvilTerran> marcotmarcot, by the by, in haskell, it's common to use parser combinators rather than regexes. it's more, eh, haskelly.
14:55:33 <fasta> dons: no, I wrote it very general.
14:55:41 <bos> cf. my logfile glomming script, which uses Map and runs much faster than python.
14:55:42 <dons> so you wrote a different program
14:55:45 <EvilTerran> makes more compile-time checking and optimisation possible
14:55:49 <dons> cool, good point bos
14:55:50 <fasta> dons: so, it's a bit comparing apples and oranges ;)
14:55:57 <dons> yeah
14:56:01 <Excedrin> which version of cabal supports the "extensions" field?
14:56:04 <dons> and your code is slow anyway, fasta
14:56:05 <fasta> dons: still, even if I didn't it would be longer, I think.
14:56:05 <marcotmarcot> EvilTerran: but what I want to do is very regexpable..
14:56:20 <marcotmarcot> Is just change some variable names in the source code..
14:56:24 <marcotmarcot> hum, maybe I could use darcs.
14:56:25 <EvilTerran> marcotmarcot, what exactly do you want to do? express it as a perl s/// or something...
14:56:25 <fasta> dons: my code is slow anyway?
14:56:38 <dons> oh, i meant verbose. :)
14:56:46 <marcotmarcot> EvilTerran: yes, just that.
14:56:51 <fasta> dons: my code is verbose?
14:56:52 <EvilTerran> um?
14:56:59 <dons> bos, hah, check the hackathon wiki edits, http://www.haskell.org/haskellwiki/Special:Recentchanges
14:57:00 <lambdabot> Title: Recent changes - HaskellWiki
14:57:03 <dons> you can kinda tell something is going on
14:57:05 <milyin> I've installed ghc6.6.1 to Fedora6 and don't see 'runhaskell' command. Anybody kons how to get it?
14:57:10 <EvilTerran> i mean, can you give an example of what kind of s/// you want to do?
14:57:12 <dons> fasta, i'm just teasing
14:57:22 <EvilTerran> runghc, milyin?
14:57:32 <fasta> dons: I thought so. Obviously my code is godlike :)
14:57:34 <milyin> also not found
14:57:43 <bos> dons: heh
14:57:48 <dons> fasta, though losing out to python, well, that leaves a bit to be desired
14:57:55 <byorgey> milyin: you can't find it anywhere, or it's just not in your path?
14:58:06 <fasta> dons: it's quite simple: they have syntax for doing the updates.
14:58:11 <marcotmarcot> s/te/go/g
14:58:15 <dons> roll some update syntax then
14:58:16 <milyin> anywhere. I see only ghc-6.6.1 executable
14:58:19 <marcotmarcot> EvilTerran: as simples as this.
14:58:24 <EvilTerran> hm. righto
14:58:29 <bos> fasta: M.insertWith' foo m usually does the trick
14:59:11 <fasta> dons: update syntax? You mean that I should write a compiler for Haskell + update syntax?
14:59:28 <bos> fasta: you don't need update syntax, it hardly makes any difference
14:59:41 <byorgey> milyin: what's in your /usr/lib/ghc-6.6.1/bin directory?
14:59:50 <dons> fasta, no.
14:59:52 <fasta> I liked what augustss did in some of his posts.
14:59:59 <fasta> (C in Haskell)
15:00:10 <dons> he does good edsls
15:00:12 * bos gives the hairy eyeball to tibbe's Hac plans
15:00:27 <dons> bos, did you know tibbe works for google?
15:00:34 <bos> dons: no
15:00:38 <dons> in zurich.
15:00:42 <dons> ex-chalmers
15:00:46 <marcotmarcot> EvilTerran: any idea?
15:00:54 <EvilTerran> i'm thinking
15:00:56 <dons> i suspect they're spying on what galois is up to
15:00:57 <dons> ;)
15:00:58 <milyin> there is no such directory: only  /usr/lib/ghc-6.6.1
15:01:17 <bos> heh, i'm sure galois is an imminent threat to google's global hegemony :-)
15:01:26 <dons> that's right.
15:01:36 <dons> we use more lambdas
15:01:40 <fasta> dons: how can you have "syntax" without implementing a parser?
15:01:40 <bos> better living through reconfigurable crypto FPGAs
15:01:50 <milyin> compiler itself is  /usr/lib/ghc-6.6.1/ghc-6.6.1
15:02:06 <marcotmarcot> But anyway, why does subRegex behaves like this?
15:02:22 <dons> fasta, let (:=) = insertWith'm  in m := x
15:02:25 <milyin> I've installed through yum as described at http://haskell.org/fedora/
15:02:26 <lambdabot> Title: Fedora Haskell
15:02:31 <marcotmarcot> hum..
15:02:36 <marcotmarcot> I'm missing the parameter order.
15:02:49 <byorgey> milyin: hm, strange.  it seems to be missing.
15:02:52 <marcotmarcot> =D
15:03:04 <dons> interrresting, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HsHyperEstraier-0.1
15:03:07 <lambdabot> http://tinyurl.com/2htpqu
15:03:07 <fasta> dons: that returns a value, so one would get nested applications of :=
15:03:08 <marcotmarcot> EvilTerran: subRegex does this.
15:03:13 <marcotmarcot> Prelude Text.Regex> subRegex (mkRegex "te") "tempo teto telhado" "go"
15:03:13 <marcotmarcot> "gompo goto golhado"
15:03:17 <dons> `HsHyperEstraier is a HyperEstraier binding for Haskell. HyperEstraier is an embeddable full text search engine which is
15:03:20 <dons> supposed to be independent to any particular natural languages.'
15:03:20 <fasta> dons: unless one implements a monad.
15:03:23 <bos> milyin: have you installed both ghc and ghc661?
15:03:52 <milyin> 'ghc661.i381' package only
15:03:55 <fasta> And that requires a runIdentity at the very least.
15:04:17 <EvilTerran> oh, okay. i was thinking about how to do it in parsec, actually. not as easy as i first expected.
15:04:23 <bos> milyin: you need ghc too
15:04:27 <dons> you can fold
15:04:34 <milyin> trying 'yum install ghc'....
15:04:55 <bos> milyin: i'm one of the ghc maintainers for fedora :-)
15:05:16 <milyin> great :-)
15:05:31 <bos> with any luck, fedora 8 will ship with ghc 6.8.1
15:05:44 <dons> http://wwv07.dimi.uniud.it/
15:05:46 <lambdabot> Title: WWV 2007
15:05:47 <bos> there's already a 6.8.0 snapshot in the rawhide tree
15:06:05 <dons> what's happening to the worl,d 3rd International Workshop on Automated Specification and Verification of Web Systems :)
15:06:51 <fasta> dons: probably nothing related to the web, that's for sure.
15:07:00 <bos> academics must have forums to publish in and go to nice places, or they wither and dry up
15:07:22 <milyin> 'yum install ghc' helped. bos, thank you!
15:07:22 <dons> that's true.
15:07:23 <tuxplorer> in HAppS-begin's blog code, in the Types.hs, there is a definition $( deriveAll [''Show,''Default,''Read] ..........  What does that $ at the start mean?
15:07:29 <fasta> They have an automated system for that: International Workshop on Automated Specification and Verification of <popular subject>
15:07:30 <bos> milyin: no problem
15:07:39 <dons> tuxplorer: that's a template haskell splice
15:07:41 <fasta> tuxplorer: TH
15:07:42 <xelxebar> where could I go to find information on interfacing with standard libraries, such as, for example, the GNU networking libraries?
15:07:44 <dons> like a macro call
15:07:52 <bos> gnu networking libraries?
15:08:04 <dons> xelxebar: you want to read an FFI tutorial?
15:08:04 <bos> xelxebar: look for info on the FFI, foreign function interface
15:08:04 <fasta> GPL infecting the Internetz!
15:08:12 <marcotmarcot> EvilTerran: yes, it's quite easy.
15:08:17 <dons> ?users
15:08:17 <lambdabot> Maximum users seen in #haskell: 420, currently: 363 (86.4%), active: 18 (5.0%)
15:08:41 <oerjan> @where ffi
15:08:42 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
15:08:44 <EvilTerran> what i've currently got as a parsec version is fmap concat $ parse (many (try (string "te" >> return "go") <|> fmap return anyChar)) "" "tempo teto telhado"
15:08:51 <marcotmarcot> EvilTerran: I was wondering about doing it in Perl, but I thought: why not in haskell.
15:08:57 <xelxebar> one of my friends was asking me about how to interface with libraries
15:08:57 <tuxplorer> dons: Thanks
15:08:58 <EvilTerran> which is Not Pretty
15:09:06 <marcotmarcot> EvilTerran: wow.
15:09:13 <marcotmarcot> EvilTerran: I don't know parsec..
15:09:18 <EvilTerran> but there's almost certainly a better way of doing that
15:09:20 <fasta> EvilTerran: are you happy with the FFI (as you used it for some time now)?
15:09:25 <EvilTerran> don't let my floundering put you off
15:09:27 <bos> the FFI is very nice
15:09:43 <xelxebar> wow!  it looks great
15:09:47 <marcotmarcot> Parsec seems to be nice.
15:09:51 <fasta> By very nice, I would expect that any C library was automatically available.
15:09:57 <marcotmarcot> But anyway, darcs is a good tool to do this.
15:10:21 <EvilTerran> fasta, yeah, mostly. i haven't explored all of it, but i haven't hit any insurmountable obstacles or anything yet
15:10:48 <EvilTerran> the only slightly irritating things i've found are not-yet-implemented bits in c2hs, but that's not really a FFI problem per se
15:10:59 <dons> you can ping dcoutts about that too
15:11:09 <dons> you might be able to convince him to sneak some features in during the hackathon
15:11:10 <fasta> AFAIK, the FFI is a basic set of primitives.
15:11:21 <dons> i guess you don't use the ffi much, fasta?
15:12:02 <dons> i mean, come on, dynamic adjustor thunks!
15:12:11 <EvilTerran> "hey dcoutts, i want {#enum define#}, especially so it works with bitwise operators in the C #defines!" "okay, here's the source code. on you go, then!"
15:12:18 <fasta> dons: not much, true, but had several attempts, and everytime I found some bugs.
15:12:33 <dons> bugs in the ffi? or in your buggy code?
15:12:41 <fasta> dons: bugs in I think c2hs
15:12:55 <dons> did you report them to duncan?
15:12:58 <fasta> dons: e.g. that an include statement had to be at the top and not one line below it
15:13:01 <fasta> dons: yes
15:13:11 <fasta> dons: and he acknowledged them
15:13:11 <dons> sounds like a feature :)
15:13:20 <waern> fasta, I've been hit by that one too
15:13:32 <waern> took me quite a while to figure out what was wrong
15:13:46 <fasta> Very nice by my standards mean that one also doesn't need the -ffi flag.
15:13:59 <dons> i guess you can have your own standards
15:14:03 <EvilTerran> i've been hit by some funny treatments of indentation inside #c...#endc blocks causing my layout to break
15:14:12 <sjanssen> fasta: -ffi is consistent with all other extensions
15:14:19 <EvilTerran> -fffi!
15:14:22 <fasta> Since it's completely redundant information.
15:14:26 <fasta> EvilTerran: right, sorry
15:14:33 <EvilTerran> ah, both work, anyway
15:14:36 <fasta> The same goes for all the other features.
15:14:45 <dons> no other extensions are enabled by just writing the code (well, i can think of 1)
15:14:56 <dons> since that kind of sucks for security, for starters
15:15:07 * sjanssen can think of 2
15:15:13 <dons> hmm.
15:15:15 * dons ponders
15:15:31 <dons> you got  me. what's the second?
15:15:42 <fasta> Sucks for security (you mean compile time IO)?
15:15:47 <sjanssen> pattern guards and hierarchical modules
15:15:51 <dons> hier modules!
15:15:58 <fasta> Well, that would be an excuse.
15:16:04 <sjanssen> we always forget those aren't officially accepted :)
15:16:08 <fasta> But most of them don't have that excuse.
15:16:08 <dons> yeah :)
15:16:24 <dons> also, for portability
15:16:33 <dons> you don't want to accidentally depend on something
15:16:43 <dons> anymore than you want to accidentally import some package just by using an identifier
15:16:48 <dons> its just wacky
15:17:04 <dons> esp. in a language about precision and control
15:17:05 <mauke> hey, ocaml does that, right?
15:17:07 <fasta> An identifier can come from different places.
15:17:31 <fasta> I am talking about redundant information only.
15:18:20 <fasta> The portability part could be a warning.
15:18:53 <garrym> @help
15:18:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:19:00 <garrym> @list
15:19:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:25:53 <Saizan> any pointer on type level lists?
15:26:09 <fasta> Why do instance Foo a a and instance Foo (a,a) a conflict? (fundep on first parameter to second parameter)
15:27:20 <mauke> because a includes (b,b)
15:27:27 <oerjan> because (a,a) = a' for some type a'
15:27:28 <EvilTerran> what about Foo (a,a) (a,a), fasta?
15:28:09 <EvilTerran> however, the latter's more specific, so you should be safe with overlapping instances
15:28:31 <fasta> mauke: then one would get Foo (b,b) (b,b)
15:28:40 <mauke> exactly
15:28:56 <oerjan> can you combine overlapping instances and fundeps? sounds dangerous...
15:28:57 <mauke> so now Foo (b,b) = (b,b) and Foo (b,b) = b
15:29:10 <mauke> that's a redefinition of the function
15:29:11 <EvilTerran> yeah, it's no more dangerous than overlapping without fundeps
15:29:34 <EvilTerran> overlapping and undecidable is rather more dangerous, though
15:30:28 <Cale> With -fallow-incoherent-instances Dynamic and ST, you can break the whole type system :)
15:30:36 <oerjan> i mean wouldn't overlapping tend to ruin checking that the dependency is satisfied?
15:31:05 <oerjan> not that they couldn't have found a way to do it
15:32:08 <fasta> mauke: so the problem is that Foo (b,b) b and Foo (b,b) (b,b) cannot both exist?
15:32:27 <mauke> well, you said you have a fundep from 1st to 2nd param
15:32:27 <fasta> (which makes sense)
15:32:36 <fasta> mauke: right, I see.
15:32:41 <EvilTerran> actually, this particular case might not work with overlapping, because of the fundep
15:32:53 <EvilTerran> but it'd work with overlapping and no fundep, i think. i'm not entirely sure.
15:34:00 <Cale> It's a little unexpected, because the occurs check excludes (a,a) = a
15:35:18 <Cale> So they can't really overlap.
15:44:37 <oerjan> @users
15:44:37 <lambdabot> Maximum users seen in #haskell: 420, currently: 357 (85.0%), active: 10 (2.8%)
15:45:49 <LoganCapaldo> Am I active?
15:45:52 <LoganCapaldo> @users
15:45:52 <lambdabot> Maximum users seen in #haskell: 420, currently: 357 (85.0%), active: 11 (3.1%)
15:46:01 <LoganCapaldo> guess I wasn't
15:46:06 * LoganCapaldo activates
15:46:28 <stoic_> what would the base case for this pattern be? (x:xs) !!! (n:ns) = x !! n : xs !!! ns
15:47:19 <LoganCapaldo> _ !!! _ = [] ?
15:47:24 <oerjan> [] !!! _ and _ !!! [] ?
15:47:32 <mauke> is that a zipWith?
15:47:38 <Saizan> (!!!) = zipWith (flip (!!))
15:47:40 <LoganCapaldo> I think so
15:47:41 <omnIdiot> stoic_: you handle the cons cases for each parameter, so you have to handle the nil cases.
15:47:51 <Saizan> ah, no flip
15:49:14 <LoganCapaldo> an oddish function
15:49:14 <omnIdiot> > zipWith (!!) [[7,9,12], [0, 20, 6], [3, 8, 1]] [1, 2, 0]
15:49:16 <lambdabot>  [9,6,3]
15:49:39 <omnIdiot> Oddish!  Oddish!  *fires solar beam*
15:49:51 <LoganCapaldo> ?
15:49:56 <omnIdiot> teh pokemans
15:50:34 <omnIdiot> there's one called "Oddish".
15:50:53 <LoganCapaldo> http://en.wikipedia.org/wiki/Golbat#Oddish
15:50:56 <stoic_> thanks, I guess I'll just use the zipWith way
15:51:46 <LoganCapaldo> although based on the description there it seems like solar beam is an odd choice
15:52:00 <LoganCapaldo> I would now expect "lunar beam"
15:52:16 <LoganCapaldo> @src zipWith
15:52:16 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
15:52:16 <lambdabot> zipWith _ _      _      = []
15:52:18 <omnIdiot> twas the only grass type attack I could summon off the top of my head.
15:52:50 <LoganCapaldo> It scares me you can "summon grass type attacks" off the top of your head at all ;)
15:52:57 <oerjan> apparently it was ill-typed
15:54:06 <stoic_> does oddish evolve into gloom?
15:54:50 <omnIdiot> hey, I was 15, pokemans were the thing.
15:56:03 <LoganCapaldo> I keep forgetting how many ages there are in here
15:56:38 <LoganCapaldo> most people in this channel I envision as as 40ish professors
15:56:49 * omnIdiot is a 22-year-old hobby coder.
15:56:51 <LoganCapaldo> even though those guys are probably in the minority
15:57:02 <LoganCapaldo> it;'s because everyone is gosh dang smart
15:57:13 * EvilTerran suspects he's the youngest here
15:57:22 <LoganCapaldo> Younger than sorear?
15:57:24 <Saizan> sorear is 16
15:57:29 <EvilTerran> ...he is?
15:57:48 <Saizan> well, maybe 17 not
15:57:56 <Saizan> *now
15:57:56 <EvilTerran> i'm 18. second-year undergrad.
15:57:59 * stoic_ is 17
15:58:23 <EvilTerran> so much for that. you guys're making me feel old, now :P
15:58:23 * LoganCapaldo starting to feel slightly old
15:58:27 <Saizan> sigh, i didn't even know haskell existed at that time
15:58:28 * bos is 6 months old, and can lift small buildings (after a bottle of milk)
15:58:37 <LoganCapaldo> mmmm milk
15:58:55 <omnIdiot> with Hershey's syrup!
15:59:17 <EvilTerran> we were taught it in first year
15:59:22 <Botje> bos: .. into what monad?
15:59:23 * LoganCapaldo is closer to 24 than 23 at this point
15:59:25 <stoic_> how did sorear get so smart?
15:59:28 <_achilles_> any here use vim to oedit haskell/
15:59:33 * LoganCapaldo hobbles off into the sunset
15:59:51 <EvilTerran> well, approximately. i got the feeling not many of the other students really knew what was going on
15:59:59 <EvilTerran> (you'd agree if you saw some of their code...)
16:00:14 <LoganCapaldo> _achilles_: at least one person
16:00:48 <_achilles_> how'd you set up indenting? I keep getting syntax errors on an example probem in Haskell in 10 minutes
16:00:58 <LoganCapaldo> I didn't
16:00:59 <oerjan> @remember bos * bos is 6 months old, and can lift small buildings (after a bottle of milk) // Botje> bos: .. into what monad?
16:00:59 <lambdabot> Done.
16:01:10 <LoganCapaldo> (other than my usually set expandtab set sw=2)
16:01:45 <mauke> _achilles_: just remember to start a new line after every "do", "where" and "of"
16:02:02 <EvilTerran> _achilles_, best not to use tab characters; that might be the trouble
16:02:05 <mauke> that should work with any indentation method
16:02:19 <_achilles_> well, I should be expanding tabs to spaces
16:02:22 <mauke> (including tabs and mixed formats)
16:02:50 <LoganCapaldo> _achilles_: if it's really driving you up the wall you can use explicit makrers
16:02:56 <LoganCapaldo> do { foo ; bar }
16:03:24 <bos> liftM2 boobies
16:03:56 * omnIdiot furrows his brow in a puzzled manner at bos.
16:04:14 <LoganCapaldo> lift mouth to boobies
16:04:25 <Japsu> @t liftM2 $ (.) . (.)
16:04:25 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
16:04:34 <Japsu> @type liftM2 $ (.) . (.)
16:04:36 <lambdabot> forall (m :: * -> *) a b c a1. (Monad m) => m (b -> c) -> m (a -> a1 -> b) -> m (a -> a1 -> c)
16:05:02 <nornagon> @help thank
16:05:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:05:09 <nornagon> @thank
16:05:10 <lambdabot> Maybe you meant: thank you thanks
16:05:13 <nornagon> @thanks
16:05:13 <lambdabot> you are welcome
16:05:28 <LoganCapaldo> @tobsnak
16:05:28 <lambdabot> Unknown command, try @list
16:06:00 <omnIdiot> @bootsneak
16:06:00 <lambdabot> Unknown command, try @list
16:06:06 <oerjan> @hotsmack
16:06:06 <lambdabot> :)
16:06:15 <Japsu> @thank you
16:06:15 <lambdabot> Maybe you meant: thank you thanks
16:06:16 <LoganCapaldo> nice one
16:06:31 <Japsu> @botslap
16:06:31 <lambdabot> Unknown command, try @list
16:06:32 <oerjan> max 2 changes, afaict
16:06:42 <LoganCapaldo> @remember oerjan hotsmack
16:06:43 <lambdabot> Done.
16:06:49 <allbery_b> 3 but it miscategorizes some changes, IIRC
16:06:54 <mauke> @quotd
16:06:54 <lambdabot> chessguy says: [mdmkolbe just wrote gunzip in Haskell] mdmkolbe, what was it, about 8 lines of code? :)
16:07:33 <fasta> Is it possible to use a type class to express the concept of reversing? I.e. one that also works to reverse e.g. a tree represented in the ST monad and is compatible in use with the current reverse function?
16:07:59 <oerjan> hm, i had figured 2, among change a character, insert, or delete
16:08:30 <fasta> I am pretty sure the answer is no.
16:09:01 <fasta> (and implies that one needs a reverse function, a reverseM function, a reverseA function and so on.
16:09:09 <fasta> )
16:09:24 <_achilles_> thanks, I think i've got the syntax all figured now
16:09:29 <EvilTerran> would Dual work?
16:09:39 <_achilles_> any recommended haskell docs?
16:09:41 <LoganCapaldo> instance (Reverseable r) => ST r where reverse = liftM reverse ?
16:10:06 <EvilTerran> i'm not sure what you mean by reverseM, reverseA, etc
16:10:14 <LoganCapaldo> Um I forgot a bit
16:10:18 <LoganCapaldo> but you get the idea
16:10:22 <oerjan> @docs
16:10:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:10:32 <oerjan> @where report
16:10:32 <lambdabot> http://www.haskell.org/onlinereport/
16:10:37 <fasta> LoganCapaldo: no, I don't and I interpret what you said as non-sense.
16:10:52 <EvilTerran> @where #haskell
16:10:52 <lambdabot> I know nothing about #haskell.
16:10:55 <EvilTerran> ;)
16:11:13 <EvilTerran> @where+ #haskell Right here, silly!
16:11:13 <lambdabot> Done.
16:11:16 <fasta> EvilTerran: reverseM would be the name of the method for e.g. the ST monad.
16:11:25 <fasta> EvilTerran: actually any monad.
16:11:34 <fasta> EvilTerran: reverseA for the arrow counter part.
16:11:47 <fasta> EvilTerran: (not that I use arrows)
16:12:23 <EvilTerran> er... i still don't know what you mean. i guessed they were for monads and arrows respectively, but what would they *do*? what would their type signatures be, even?
16:12:48 * LoganCapaldo doesn't see how you'd write a monadic reverse (other than fmap reverse) and by extension what utility you'd get out of having a monadic reverse
16:13:08 <EvilTerran> ?type foldM
16:13:13 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:13:15 <fasta> EvilTerran: ok, assume there are two functions: reverse::[a] -> [a] and a function reverseSTList:: (List s a) -> ST s (List s a)
16:13:27 <fasta> EvilTerran: make those functions into one.
16:13:29 <EvilTerran> ?type foldM ((return.).(:)) ]
16:13:31 <lambdabot> parse error on input `]'
16:13:32 <EvilTerran> ?type foldM ((return.).(:)) []
16:13:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
16:13:34 <lambdabot>       Expected type: a -> [a] -> m a
16:13:38 <fasta> EvilTerran: well, rather one name. (one concept)
16:13:42 <EvilTerran> ah, never mind
16:14:09 <fasta> EvilTerran: the point is that you cannot do that.
16:14:11 <EvilTerran> "List"?
16:14:27 <fasta> EvilTerran: List is a list implemented in the ST monad.
16:14:51 <LoganCapaldo> reverse' :: List s a -> List s a , reverseSTlist x = x >>= (return . reverse')
16:15:38 <fasta> LoganCapaldo: ?
16:16:05 <fasta> LoganCapaldo: I cannot even count the number of errors in that.
16:16:16 <oerjan> fasta: the pure list case seems hard since you have nowhere to put the monad variable, you would need to use [a] -> Id [a] or something.
16:16:31 <fasta> oerjan: right, the identity monad
16:16:50 <fasta> oerjan: (I already knew that before I asked this question, since I thought about it for some time)
16:16:56 <Saizan> it would be nice to have Id as a type synonym
16:17:02 <oerjan> otherwise, it could be class Reverse m l where reverse :: l a -> m (l a)
16:17:38 <Saizan> yeah, like MArray
16:18:07 <fasta> But as long as people are going to invent new ways to make computational objects like Arrow (I guess there's a way to make something reverseable in Arrow), then you have yet another problem.
16:18:10 <Saizan> since your List s a needs the ST monad and not any monad
16:18:38 <oerjan> right, arrows don't fit since you need the -> to be a part of it
16:19:38 <oerjan> you might simply add a variable for that too
16:19:50 <_achilles_> why can't you do "main = <blah blah>" in hugs or ghci?
16:20:14 <fasta> _achilles_: because nobody implemented it and the semantics are unclear.
16:20:15 <mauke> _achilles_: because that's a declaration, not an expression
16:20:19 <oerjan> but of course you have no guarantee that no one invents something which doesn't fit the pattern
16:20:23 <sarehu>  do let main = <blah blah>?
16:20:41 <fasta> oerjan: how would that variable look like?
16:20:51 <_achilles_> hmmm
16:21:09 <_achilles_> so hugs/ghci don't evaluate declarations? only expressions?
16:21:19 <oerjan> class Reverse (~>) m l where reverse :: l a ~> m (l a)
16:21:20 <_achilles_> please excuse my naive questions
16:21:41 <fasta> oerjan: what's ~>?
16:21:46 <oerjan> and now the m is redundant for the -> case
16:21:46 <sarehu> 'evaluate'?  _achilles_: type in at the prompt,    let main = putStrLn "Hey"
16:21:50 <sjanssen> _achilles_: that is correct
16:21:52 <mauke> _achilles_: yes, with some excepttions
16:21:52 <oerjan> fasta: an arrow
16:21:55 <oerjan> possibly
16:22:00 <mauke> ghci also does "let" and "<-"
16:22:16 <fasta> oerjan: do you mean -> or something else?
16:22:38 <LoganCapaldo> @instances Arrow
16:22:39 <lambdabot> (->), Kleisli m
16:22:41 <oerjan> fasta: -> is one Arrow you could use
16:23:02 <fasta> oerjan: since ~> is a rather odd typo...
16:23:15 <EvilTerran> fasta, ~> is a type variable like any other
16:23:16 <idnar> hmm
16:23:18 <EvilTerran> just with a funny name
16:23:28 <idnar> is there an easier way of writing head (filter fn list)?
16:23:30 <fasta> EvilTerran: oh, right
16:23:35 <oerjan> fasta: i am using the ghc infix type extension
16:23:44 <LoganCapaldo> @type find
16:23:45 <fasta> oerjan: yes, I noticed a second before you said that
16:23:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:24:15 <fasta> Still, this idea of super-generalization at front seems like a bad idea.
16:24:16 <idnar> hmm
16:24:18 <shachaf> @ty (fromJust .) . find
16:24:20 <lambdabot> forall a. (a -> Bool) -> [a] -> a
16:24:27 <fasta> It would be better to have something that's extensible.
16:24:32 <shachaf> If you want the same type.
16:24:41 <oerjan> idnar: seems pretty minimal to me
16:24:48 <idnar> find is good
16:24:48 <oerjan> oh wait
16:24:54 <idnar> ;)
16:24:57 <mauke> @src find
16:24:58 <lambdabot> find p          = listToMaybe . filter p
16:25:00 <oerjan> @src find
16:25:00 <lambdabot> find p          = listToMaybe . filter p
16:25:05 <mauke> huhu
16:25:06 <LoganCapaldo> I want to do it!
16:25:11 <LoganCapaldo> @src find
16:25:11 <lambdabot> find p          = listToMaybe . filter p
16:25:14 <idnar> @src find
16:25:14 <lambdabot> find p          = listToMaybe . filter p
16:25:17 <idnar> I did it!
16:25:23 <shachaf> @src find
16:25:23 <lambdabot> find p          = listToMaybe . filter p
16:26:04 <oerjan> o_O
16:26:51 <EvilTerran> what's going on here?
16:26:53 <omnIdiot> find p          = listToMaybe . filter p
16:26:53 <EvilTerran> @src find
16:26:53 <lambdabot> find p          = listToMaybe . filter p
16:26:57 <omnIdiot> oops, wrong part.
16:27:21 <oerjan> fasta: i guess you really would want class Reversible x l -> reverse :: x l and allow x to be any type synonym
16:27:34 <omnIdiot> FIND PEE EQUALS LIST TO MAYBE DOT FILTER PEE.
16:27:41 <oerjan> but that would wreak havoc with all that is nice and decidable, i guess
16:27:46 <EvilTerran> O.o
16:28:26 <shachaf> @src lookup
16:28:26 <lambdabot> lookup _key []          =  Nothing
16:28:26 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
16:28:26 <lambdabot>                         | otherwise = lookup key xys
16:28:31 * oerjan waits for omnIdiot to settle back into the omniscient half
16:29:02 <omnIdiot> I like the nick, but it's a bit long
16:29:25 <oerjan> i wasn't speaking about your nick, but your behavior
16:29:35 <omnIdiot> oh, 8)
16:29:45 * LoganCapaldo suggests truncatedIdiot
16:31:17 <oerjan> but of course if you are feeling particularly smart one day you could change it to omniscientId?
16:31:37 <fasta> oerjan: what I really want would be class Reversible x where reverse:: x -> possible list of type variables(x)
16:32:01 <fasta> oerjan: and this cannot be expressed currently
16:32:04 <oerjan> fasta: that doesn't fit into an Arrow framework
16:32:13 <fasta> oerjan: I don't care about the Arrows
16:32:49 <fasta> oerjan: well, maybe I do, but I am not aware of it.
16:32:56 <omnIdiot> oerjan: or if I'm feeling neither: omnId
16:33:24 <LoganCapaldo> class (ListMember m) => Reverseable m l where reverse :: l -> m l; instance ListMember Quux where membership = undefined
16:33:34 <fasta> oerjan: why wouldn't it?
16:35:34 <oerjan> because you would expect a x x, where x is the arrow
16:35:50 <oerjan> er, a
16:35:58 <oerjan> it generalizes ->
16:38:10 <oerjan> have you looked at the Traversable class? it's what i recall that seems closest
16:40:17 <fasta> Ok, so one would get class Reverseable l where p(l) y q(l) where y is infix application and p and q are type variable functions.
16:42:11 <oerjan> p, q and y would need to be additional parameters, probably with fundep
16:42:14 <fasta> oerjan: yes, I have, and it uses the Identity monad.
16:42:59 <oerjan> well it's parametrized over any Applicative...
16:43:24 <fasta> (oh, I am not saying Applicative is "stupid" or anything)
16:43:27 <_achilles_> can anyone recommend a decent haskell introduction?
16:43:28 <oerjan> but of course not tied to the structure
16:43:36 <oerjan> @where yaht
16:43:37 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:44:07 <oerjan> _achilles_: see that for example
16:44:35 <_achilles_> mk, thanks
16:45:40 <oerjan> it seems like you want something that is to Traversable approximately as UArray is to Array...
16:45:49 <fasta> oerjan: and then we still need the type synonym business.
16:45:50 <oerjan> although not as general
16:46:32 <fasta> I guess it wouldn't be that hard to add that to the inferencer.
16:47:18 <oerjan> i had the impression it was left out because it would be undecidable
16:47:47 <oerjan> requiring higher order unification
16:48:50 <fasta> Well, it's already undecidable with some flags, so...
17:07:36 <idnar> hmm
17:07:47 <idnar> is there a (**) for integrals?
17:07:55 <shachaf> @ty (^)
17:07:57 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
17:07:59 <shachaf> @ty (^^)
17:08:01 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
17:08:09 <idnar> ah
17:08:34 <LoganCapaldo> is there an bitwise xor? ;)
17:08:42 <idnar> heh
17:08:45 <omnIdiot> > True /= False
17:08:48 <lambdabot>  True
17:08:51 <LoganCapaldo> @hoogle Word -> Word -> Word
17:08:51 <lambdabot> No matches, try a more general search
17:08:59 <mauke> > 3 `xor` 5 :: Int
17:09:00 <lambdabot>  6
17:09:03 <LoganCapaldo> @hoogle Word32 -> Word32 -> Word32
17:09:03 <lambdabot> No matches, try a more general search
17:09:13 <LoganCapaldo> bitwise ops work on Ints? :(
17:09:28 <shachaf> @ty xor
17:09:30 <lambdabot> forall a. (Bits a) => a -> a -> a
17:09:33 <omnIdiot> @instances-importing Data.Bits Bits
17:09:34 <LoganCapaldo> I worda thought they'd only work on Wordish things
17:09:34 <shachaf> @instances Bits
17:09:34 <lambdabot> Int, Integer
17:09:35 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
17:09:42 <omnIdiot> @instances-importing Data.Bits Data.Word Bits
17:09:43 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
17:09:47 <LoganCapaldo> ok a Bits class
17:10:05 <LoganCapaldo> I still don't think Int shoudl be a member, and Integer _definitely_ shouldn't :)
17:10:17 <sarehu> why?
17:10:22 <sarehu> oh...
17:10:24 <omnIdiot> > completment (0 :: Integer)
17:10:25 <lambdabot>   Not in scope: `completment'
17:10:30 <omnIdiot> > complement (0 :: Integer)
17:10:31 <lambdabot>  -1
17:10:37 <omnIdiot> hehe
17:10:50 <LoganCapaldo> Cause I don't want to know that my arbitrary precision integer has bits
17:11:02 <mauke> you don't need to
17:11:08 <sarehu> you can't handle the truth?
17:11:09 <oerjan> LoganCapaldo: Integers are a perfectly valid subset of the 2-adic integers
17:11:14 <omnIdiot> LoganCapaldo: negative Integers just have ones all the way left.
17:11:22 <LoganCapaldo> no no
17:11:25 <mauke> you can define xor in terms of arithmetic operations
17:11:27 <LoganCapaldo> that's not what I mean
17:12:07 <omnIdiot> > bitSize (0 :: Integer)
17:12:08 <lambdabot>  Exception: Data.Bits.bitSize(Integer)
17:12:14 <omnIdiot> lovely
17:12:24 <oerjan> and Integers need xor so you can calculate with nimbers
17:12:34 <LoganCapaldo> nimbers?
17:12:50 <oerjan> @go nimber
17:12:53 <lambdabot> http://en.wikipedia.org/wiki/Nimber
17:12:53 <lambdabot> Title: Nimber - Wikipedia, the free encyclopedia
17:12:55 <LoganCapaldo> well fine then take xor out of the Bits class
17:13:17 <LoganCapaldo> if you can do it with arithmetic stick it in Num or Integral or wahtever
17:13:32 <shachaf> Does anyone know how usernames are being handed out for http://book.realworldhaskell.org/alpha ?
17:17:59 <misterbeebee_> you mean, how login credentials are handed out?
17:18:18 <shachaf> Yes.
17:18:47 <misterbeebee_> They were emailed to the reviewers
17:18:57 <misterbeebee_> who signed up
17:19:15 <shachaf> Oh, OK. They're for reviewers.
17:19:18 <shachaf> I suspected that.
17:19:25 <misterbeebee_> http://www.realworldhaskell.org/blog/2007/09/11/yes-membership-has-its-privileges/
17:19:27 <lambdabot> Title: Real World Haskell ª Blog Archive ª Yes, membership has its privileges, http://tinyurl.com/27t4e9
17:20:06 <misterbeebee_> I think anyone who offered was invited to review, but bos and dons know for sure
17:20:31 <shachaf> It's annoying that you can read (some of) their comments, but not the text they're commenting about. :-)
17:21:44 <misterbeebee_> you're looking at the feed? feed://book.realworldhaskell.org/feeds/comments/hs.starting/ nice
17:31:47 <jr_> I'm currently searching for a Haskell database interface library. As of now, I have downloaded HSQL and coded a few examples. But before I dive in further I wanted to ask if there is  some sort of standard module, like DBI for Perl? For example, HSQL  wasn't recently updated, but HDBC was a few months ago. Is it better to use HDBC?
17:33:01 <SamB_XP> LoganCapaldo: seriously, ALL integers have bits
17:33:05 <misterbeebee_> functional programming is infecting my work... I just replaced a package of data files (which we update from time to time) with a script to generate the data and build the package.   data vs fully-applied function, what's the difference?
17:33:08 <allbery_b> none of them have really taken over as the standard one yet.  the three I know of are HSQL, HDBC, and Takusen
17:34:18 <jr_> allbery_b: do you know if HSQL is actively developed? Do you use any of them?
17:34:32 <allbery_b> I don't use them and have no idea
17:34:56 <jr_> hm...
17:35:20 <LoganCapaldo> SamB_XP: Yeah so? I jsut don't want Integer's implementation to be informed by needed to support the Bits class
17:35:27 <LoganCapaldo> s/needed/needing/
17:35:27 <allbery_b> database stuff might find its way into what I'm doing eventually but currently our stuff is in flux and the best (==most reliable) interface is to invoke a perl script which has fairly consistent behavior
17:35:32 <misterbeebee_> I think LoganCapaldo's complaint is that if there is more than one way to express an integer in bits, then Integer shouldn't favor one of them it in its implemenation of bits. Why is   (complement 0) === -1, and not (-maxBound) ?
17:36:11 <LoganCapaldo> misterbeebee_: yeah
17:36:18 <mauke> because Integer isn't Bounded
17:36:28 <omnIdiot> or -0, in one's complement.
17:36:47 <misterbeebee_> sorry, why isn't it -infinity
17:36:56 <jr_> allbery_b, how do you interface the Perl script with the Haskell program
17:37:06 <LoganCapaldo> it's not the bounding its the brining the the questions of "is the sign a part of the bitstring rep?" type questions in
17:37:08 <mauke> because there is no infinity
17:37:14 <allbery_b> you really do not want to know :)
17:37:20 <jr_> heh
17:37:39 * allbery_b is using this in a gtk2hs program, and currently using the gtk event loop stuff to read pipes requires playing very ugly games...
17:38:01 <jr_> I see
17:38:01 <allbery_b> (I need to discuss this with dcoutts at some point)
17:39:04 <thoughtpolice> why can't I use Data.ByteString.hPutStrLn on a ByteString returned to me from Data.Binary.encode?
17:39:42 <allbery_b> hm?  what happens when you do?
17:40:05 <sarehu> it imports Data.ByteString.Lazy?
17:40:07 <misterbeebee_> why is Integer's implementation of Bits fixed? Is it because there is only one feasible implementation of unBounded values?  http://en.wikipedia.org/wiki/Signed_number_representations#Comparison_table
17:40:09 <lambdabot> http://tinyurl.com/2xpvv8
17:40:51 <misterbeebee_> Base -2  seems like it could work just as well as 2's complement
17:40:52 <sjanssen> thoughtpolice: use Data.ByteString.Lazy.Char8.hPutStrLn
17:40:59 <thoughtpolice> sjanssen: thanks.
17:41:02 <SamB_XP> misterbeebee_: Integer doesn't HAVE a maxbound...
17:41:23 <misterbeebee_> SamB_XP, I know, mauke already corrected my earlier error
17:41:25 <SamB_XP> and there is no infinity for it
17:41:49 <SamB_XP> and that would not keep complement . complement == id
17:42:20 <misterbeebee_> what wouldn't? Base -2 ? Why not?
17:42:32 <dmwit> > maxBound :: Integer
17:42:33 <lambdabot>   add an instance declaration for (Bounded Integer)
17:42:33 <lambdabot>     In the expression: ma...
17:43:19 <SamB_XP> isn't the Bits class totally based on twos complement (insert apostrophe as appropriate)
17:44:09 <LoganCapaldo> @type xor
17:44:11 <lambdabot> forall a. (Bits a) => a -> a -> a
17:44:32 <LoganCapaldo> but what about unsigned values?
17:44:40 <LoganCapaldo> its just as valid to xor them...
17:44:53 <LoganCapaldo> why is Bits based on two's complement?
17:45:06 <misterbeebee_> SamB_XP: Dunno. But if so, it's a seemingly arbitrary feature to declare, to conflate bitmasks with integeres just to squeeze them into one class. Why not have Bits which only for bitfields, and have functions to converrt from numbers to Bits that make the representation explicit, since it matters?
17:46:49 <allbery_b> because nobody's yet assembled a nice bitfield class with nice operations?
17:47:05 <misterbeebee_> e.g.    instance Bits TwosComplementInteger where ...;   toTwosComplement :: Integer ->  TwosComplementInteger   ;
17:47:05 <allbery_b> (iignoring Data.Binary for the moment)
17:48:27 <misterbeebee_> The implementation of Integer Bits in Data.Bits.hs fine, it just makes an arbitrary assumption about the conversion of Integers to bitfields.
17:48:30 <oerjan> misterbeebee_: there is a completely common mathematical notion of a bitmask of infinite length, the 2-adic integers.  These form a ring, into which the Integers embed in only one possible way.
17:49:30 <oerjan> each finite bitwidth 2^n then forms a quotient of that ring.
17:51:09 <oerjan> defining the bitwise operations to make them commute properly with the quotients forces two's complement
17:51:40 <oerjan> i.e. the Integer definition is the most mathematical one
17:54:38 <LoganCapaldo> that's great until I port Haskell to some weird 1s-complement machine and need to flip some flags in a bitmask ;)
17:55:05 <LoganCapaldo> s/Haskell/a haskell implementation/
17:56:37 <dmwit> I'll be porting GHC to a Turing machine with only the symbol '*', and I need an Integer complement function that makes sense on that system!
17:56:56 <Mr_Awesome> if i have a list of Maybe's, what is a good way to get the first Just or if there are no Just's then Nothing
17:57:08 <LoganCapaldo> @type mconcat
17:57:10 <lambdabot> forall a. (Monoid a) => [a] -> a
17:57:18 <misterbeebee_> oerjan: you've snowed me with the algebra. I'll need to do some reading to fully understand.
17:57:18 <dmwit> :t msum
17:57:20 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
17:57:25 <mauke> @type catMaybes
17:57:26 <lambdabot> forall a. [Maybe a] -> [a]
17:57:45 <dmwit> > msum [Nothing, Nothing, Just 3, Nothing]
17:57:46 <lambdabot>  Just 3
17:57:50 <Mr_Awesome> mauke: i dont think that one is right
17:58:03 <oerjan> misterbeebee_: great :)
17:58:10 <dmwit> > mconcat [Nothing, Nothing, Just 3, Just 4, Nothing]
17:58:11 <lambdabot>   add an instance declaration for (Monoid (Maybe a))
17:58:11 <lambdabot>     In the expression:
17:58:11 <lambdabot>  ...
17:58:33 <dmwit> ?instances Monoid
17:58:34 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
17:58:54 <Mr_Awesome> thanks dmwit :)
17:59:01 <LoganCapaldo> Yeah I came up with a lousy one
17:59:02 <Mr_Awesome> ive got to remember that MonadPlus class
17:59:03 <glen_quagmire> i find haskell difficult to read
17:59:24 <misterbeebee_> oerjan: I want to conclude that what you just wrote a mathematical way of saying that  that two's complement is the only way to implement integers in a way that is consistent across all finite sizes as well as the unbounded case.  IOW, a base -2 approach wouldn't be compatible with a finite bounded Int. -- but my intuition doesn't yet agree, and I'm not sure whether they should.
17:59:25 <Mr_Awesome> youll get used to it
18:00:56 <omnIdiot> glen_quagmire: anything specifically?
18:01:16 <glen_quagmire> omnIdiot: i think Mr_Awesome is right. just inexperience-ness
18:06:26 <newsham> huh, neat, epigram lets you type check incomplete code
18:06:32 <newsham> ghc should do that
18:07:02 <oerjan> misterbeebee_: well it is the most "natural" way, in a sense which could be made precise with category theory and diagrams of quotients.  of course if you are willing to break commutativity of the quotient operations, you can do it differently.
18:08:24 <ramza3> I love you all
18:08:25 <omnIdiot> newsham: I've not used epigram so I'm not sure what you mean, but you can use 'undefined' for unfinished parts of an expression and it'll infer to the correct type.
18:08:35 <oerjan> i.e. if you don't demand that cutting away bits should commute with the other operations
18:09:52 <newsham> omn: that might be in essense what is going on.. not too sure (havent used epigram either, reading a paper about it)
18:09:57 <oerjan> anyway, good night
18:15:55 <kassa> http://www.freerapidaccount.com/free/?r=43844
18:15:56 <kassa> http://www.freerapidaccount.com/free/?r=43844
18:15:57 <kassa> http://www.freerapidaccount.com/free/?r=43844
18:15:58 <lambdabot> Title: Free Rapidshare Premium Account - 2.0
18:15:58 <lambdabot> Title: Free Rapidshare Premium Account - 2.0
18:15:58 <lambdabot> Title: Free Rapidshare Premium Account - 2.0
18:15:59 <kassa> http://www.freerapidaccount.com/free/?r=43844
18:16:00 <lambdabot> Title: Free Rapidshare Premium Account - 2.0
18:16:22 <dmwit> banhammer time
18:16:33 <joed> Indeed.
18:17:03 <platypus> They just spammed #perl as well.
18:19:16 <MADnificent> too bad a counter dos is illegal
18:19:36 <joed> But easy?
18:19:48 <dmwit> What boggles me is that they post the exact same message more than once.
18:19:58 <MADnificent> joed: dunno, if it was legal, then I assume that there would form some communities...
18:20:28 <dmwit> They must have heard in some class that TCP is an unreliable connection, and then failed out.
18:20:39 <joed> dmwit: It is usually pretty dumb code. And yes what you said.
18:21:34 <joed> dmwit: Been a while, I now don't deal with stupid security but it is rather sad / destructive 10: KILL 20: goto 10 type code
18:25:30 <misterbeebee_> oerjan: so in 2-adic metric, the closest approximation to (-1) is 11111.... for as many bits as you have available. so (with hand wave) two's complement notation expresses negative integers 2-adically, and for finite-width integers, two-complement gives is closest 2-adic approximation of negative values.
18:27:31 <misterbeebee_> so the open question (for me) is, why is 2-adic metric desirable? And the answer would be.... because that's one in which adding more bits makes your finite set converge to the infinite precision ideal situation.
18:28:44 <Korollary> This is why I hate being taught one's complement and two's complement without reason.
18:29:21 <SamB_XP> misterbeebee_: ...111
18:29:32 <misterbeebee_> SamB_XPl right.
18:29:49 <misterbeebee_> er, left :-) that would be the point of 2-adic :-)
18:32:51 <misterbeebee_> In my college analysis class, they gave us two problem sets at the beginning of semester, metric spaces and p-adic numbers, and then they split us up into advanced and not-so-advanced based on our answers. I bombed the p-adic set, so I was placed in not-so-advanced :-/ I'm finally starting to understand them
18:41:28 <ClaudiusMaximus> am i correct in thinking that an infinite list has countably-many elements whereas an infinite binary tree has uncountably-elements? (i'm thinking the first is "obvious", whereas the second is by correspondence of left-branch and right-branch to digits in a binary expansion of a number between 0 and 1)
18:42:15 <Spark> nah they're both countable i think
18:42:29 <Spark> consider the breadth-first search of a binary tree
18:44:21 <Spark> although i grok your correspondance
18:45:32 <mauke> are you confusing number-of-elements-in-x with number-of-values-of-type-X?
18:45:35 <dmwit> ClaudiusMaximus: No, a binary tree also has countably many elements.
18:45:42 <sarehu> ClaudiusMaximus: your binary tree intuition is wrong because each node corresponds to a -finite- binary expansion
18:46:04 <Spark> yeah i think if you're trying to equate it with reals, it's not enough just to find one number between each pair of numbers?
18:46:08 <Spark> don't you need infinitely many?
18:46:58 <sarehu> there are infinitely many rats between each pair of rats
18:47:15 <mauke> I hate rats
18:47:27 <dmwit> star et ahi
18:48:05 <Spark> there are no rats
18:48:10 <Spark> so eys
18:48:12 <Spark> *yes
18:50:59 <misterbeebee_> Spark: you described density, not uncountability.
18:51:26 <misterbeebee_> The rationals have an infinite number of values between any x and y
18:53:09 <ClaudiusMaximus> dmwit, sarehu, Spark: thanks, i think i get it
18:53:20 <misterbeebee_> uncountable set is a power set of a countable infinite set.  The set of all infinite binary tries is uncountable. since each binary tree is be identified with an infinite binary sequence.
18:54:16 <sarehu> well.... uncountable is just 'not countable'... it could be the powerset of a countable infinite, or worse..
18:58:31 <SamB_XP> so isn't an infinite binary tree just like the powerset of an infinite list?
18:59:25 <sarehu> SamB_XP: consider how a heap is encoded into an array
18:59:45 <misterbeebee_> sarehu: yes, I had a loose usage of "is". I should have written "at least"
18:59:47 <sarehu> and what's a powerset of a list?
19:02:24 <misterbeebee_> sarehu: I retract "since each binary tree is be identified with an infinite binary sequence."
19:03:19 <SamB_XP> you might be able to manage it if you interleaved the branches
19:03:59 <sarehu> no...
19:05:04 <sarehu> an infinite binary tree's elements could correspond to the set of finite subsets of a list nicely.
19:05:18 <misterbeebee_> Each infinite path is an infinite binary sequence.  The number of *paths* is uncountable. The number of *leaves* in an infinite binary tree is uncountable. The number non-leaf nodes is countable
19:05:48 <misterbeebee_> but what is a leaf in an infinite tree ??? So, ClaudiusMaximus, what kind of tree are you talking about
19:07:28 <Spark> heh
19:07:28 <SamB_XP> misterbeebee_: the number of leaves in an infinite-in-all-paths binary tree is zero ;-)
19:07:37 <Spark> infinite balanced?
19:07:41 <ClaudiusMaximus> misterbeebee_: fractals generated by graph-directed iterated functions systems where the graph has more than one strongly-connected component.  but this is kinda off-topic as my implementation is in Javascript and not Haskell...
19:08:06 <ClaudiusMaximus> misterbeebee_: i'm trying to calculate an upper bound on the fractal's Hausdorff dimension
19:08:36 <Spark> that only makes sense if they tend towards some limit
19:08:43 <Spark> just like infinite sums, right?
19:09:03 <SamB_XP> Spark: I think it means each branch is infinitely deep
19:09:13 <SamB_XP> I can't see how else it could be balanced ;-)
19:09:32 <misterbeebee_> (I was assuming balanced tree in all my comments)
19:11:24 <misterbeebee_> Any sort of binary tree is countable, and has countable # of nodes and "existing" leaves, but the number of of infinite paths is generally uncountable, so the "closure" of the tree is uncountable.
19:11:27 <michael__> Hello. I'm having trouble understanding why the ghci prompt accepts a kind of different language than the Haskell we can write in a file. I figure it is because ghci is really using hackery to simulate an interpreter. For instance, why must destructive assignments at the prompt use let statements and why can't I import? The documentation isn't really helpful for understanding; it just says do such and such, which scares me. I'm not sure I want to invol
19:11:52 <misterbeebee_> instead of import, use ":m + Data.List"
19:11:56 <michael__> You see
19:11:57 <sarehu> michael_: GHCi is like you're writing inside do notation
19:12:07 <michael__> ok
19:12:14 <michael__> So why don't the docs say that?
19:12:20 <michael__> They hide it like misterbeebee_
19:12:32 <michael__> I don't care WHAT to do. I want to UNDERSTAND
19:12:51 <SamB_XP> you want the docs to be explicit?
19:12:59 <michael__> Is that too much to ask?
19:13:00 <michael__> :)
19:13:12 <SamB_XP> you could fix the docs to say what you want and "darcs send" the patch
19:13:37 <Mr_Awesome> which is a better/more common practice in haskell: append a prefix/suffix to names or have users import the module qualified?
19:13:46 <michael__> Good God Man. I'm just trying to learn the language. This is a highly theoretical language that has been around a long time. Why should I have to do this?
19:13:47 <SamB_XP> Mr_Awesome: how many names?
19:13:57 <Spark> but first he needs to understand it so he can write the patch :)
19:14:00 <SamB_XP> michael__: well, I might have been kidding
19:14:05 <dmwit> michael__: I think the reason they hide it is because many people use ghci to learn Haskell, and don't want to "discover" monads as their very first inroad to functional programming.
19:14:13 <LoganCapaldo> I'd much rther be forced to use qualified than have to use a prefix
19:14:13 <Mr_Awesome> SamB_XP: maybe 10 or so
19:14:14 <michael__> I do!
19:14:24 <michael__> It's too confusing
19:14:27 <SamB_XP> Mr_Awesome: which names?
19:14:30 <kpreid> with qualified, the user gets to pick the prefix!
19:14:41 <michael__> Python is EASY. Why? The interpreter at the prompt is the same as from a file
19:14:51 <SamB_XP> not really
19:14:51 <LoganCapaldo> witha  prefix I have to type it all the time, if theres no prefix I';ll probably be ablke to get away with not typing it most of the time
19:14:53 <michael__> ghci makes the language SEEM context dependent
19:14:56 <Mr_Awesome> names like empty, insert, delete, etc
19:15:02 <SamB_XP> you notice how at the prompt you have to type extra newlines?
19:15:25 <michael__> SamB_XP, in Python?
19:15:30 <SamB_XP> yeah
19:15:38 <michael__> no, I don't notice
19:15:41 <dmwit> michael__: The difference is that Haskell has both forward and backward "links" in its type-inferencer.
19:16:04 <dmwit> You might have to define two functions before either of them has a sensible type (because they are mutually recursive, or whatever).
19:16:12 <SamB_XP> another thing is that at the prompt you want to type expressions usually
19:16:21 <dmwit> Python does the resolution at run-time, but Haskell does it at compile-time, so they are fundamentally different.
19:16:31 <michael__> dmwit, The difference between what?
19:16:50 <dmwit> michael__: The difference between the Python and Haskell interpreters.
19:17:17 <kpreid> s/interpreter/REPL/
19:17:46 <michael__> kpreid, I'm sure if I knew REPL I would find that helpful
19:18:00 <dmwit> read-eval-print loop
19:18:01 <michael__> (at least for the first occurence)
19:18:07 <kpreid> michael__: I'm nitpicking dmwit, not you :)
19:18:11 <SamB_XP> have I mentioned how lame Python's layout is?
19:18:11 <michael__> ok
19:18:24 <michael__> hahah
19:18:40 <michael__> Well, I've become much more proficient with python faster than with Haskell....
19:18:50 <mrd> "Lisp is EASY. Why? The interpreter at the prompt is the same as from a file."  Just as true, and just as irrelevant.  Neither Lisp nor Python have (real) static type systems.
19:18:53 <michael__> I am quite proficient with Scheme, and the DrScheme prompt is nice
19:18:57 <SamB_XP> interpreter is essentially identical to [VM +] compiler...
19:19:07 <michael__> ok
19:19:12 <kpreid> michael__: basically, ghci *can't* behave exactly like a file because of recursive definitions.
19:19:21 <michael__> So the problem is typing, which requires the inference thingy to look backward and forward
19:19:31 <kpreid> michael__: changing the syntax to make it like a file would lead to subtle semantic differences causing confusion
19:19:31 <dmwit> michael__: Don't give up!  The initial effort might pay off in the end. =)
19:19:42 <kpreid> whereas do-like syntax does *not* have the semantic problems
19:19:44 <michael__> *might*
19:19:45 <michael__> :)
19:19:47 <kpreid> because it is not recursive
19:20:01 * kpreid doesn't mention mdo
19:20:09 <dmwit> heh
19:20:32 <michael__> So I can't define mutually recursive functions at the prompt?
19:20:42 <mrd> you can, in the same let block
19:20:43 <shachaf> michael__: You can.
19:21:17 <michael__> Basically, I will be happy if someone points me to docs that are complete. This reminds me of college classes, where they hide the details and just causes a semesters worth of confusion
19:21:33 <ClaudiusMaximus> misterbeebee_: ok, the closure has an uncountable number of nodes (if i understand you correctly) so i can't calculate the bound on dimension as the maximum over all nodes, as Hausdorff dimension seems to be only countably additive.  time for me to think harder...
19:21:36 <mrd> any one of the million tutorials, the haskell report?
19:21:44 <dmwit> > let f 0 = 0; f x = g (x - 1); g 0 = 1; g x = f (x - 1) in f 32
19:21:45 <michael__> the tutorials hide thigns
19:21:46 <lambdabot>  0
19:21:47 <michael__> That's why I'm here
19:21:54 <mrd> @where report
19:21:54 <lambdabot> http://www.haskell.org/onlinereport/
19:22:12 <dmwit> michael__: There's an example of recursive definitions in a (single) let block.
19:22:13 <kpreid> michael__: have you read http://www.haskell.org/ghc/docs/latest/html/users_guide/ch03s04.html ?
19:22:15 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/2c2oeu
19:22:25 <kpreid> mrd: he's asking about ghci, which is not in the report
19:22:26 <michael__> dmwit, the thing is, the let statement is not required in a file. Now do I only understand that better. Most tutorials get around the issue by putting stuff in files
19:22:36 <dmwit> right
19:22:37 <sorear> mrd: SML has the same niceness at the prompt
19:22:44 <mrd> sorear: no, it has generativity
19:23:10 * sorear fails to see how generativity has anything to do with a toplevel
19:23:17 <mrd> SML/NJ has a slightly "nicer" REPL but there's no monadic system either
19:23:29 <mrd> sorear: because redefining types fucks your old functions?
19:23:30 <SamB_XP> michael__: do you want the documentation for GHCi to have some BNF detailing what you can type?
19:23:32 <kpreid> michael__: besides that, http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html is complete documentation of ghci's specific behaviors
19:23:32 <lambdabot> Title: Chapter 3. Using GHCi
19:23:45 <sorear> mrd: that's not the toplevel's fault
19:23:55 <sorear> mrd: it's generativity's fault
19:24:00 <mrd> sorear: nonetheless it can't be as "nice" as lisp
19:24:09 <mrd> it's a tradeoff
19:24:25 <michael__> I read that, and I didn't see anything that was helpful to people who don't know anything.
19:24:47 <michael__> kpreid, SamB_XP, The docs, and the FAQ just say "do this"
19:24:52 <mrd> what you can get from the Report is the syntax of do-blocks, which is what GHCi uses
19:25:08 <kpreid> michael__: section 3.4.2
19:25:10 <michael__> mrd: My point is that I would have had no idea that it is a do-blocki!
19:25:17 <kpreid> "The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell do expression. However, there's no monad overloading here: statements typed at the prompt must be in the IO monad."
19:26:15 <michael__> That is certainly not clear to someone who doesn't know different kinds of statements
19:26:33 <michael__> kpreid, that information is meant for people coming from Hugs or something
19:26:43 <SamB_XP> hmm, they actually document all this behaviour?
19:26:47 <kpreid> michael__: I think you're being a bit picky
19:26:48 <michael__> no
19:26:49 <michael__> They mention
19:26:52 <michael__> They don't document
19:26:55 <dmwit> Hugs also accepts "do block" notation.
19:26:56 <sorear> michael__: it's quite well documentd
19:27:01 <dmwit> (I thought.)
19:27:19 <michael__> kpreid, I am being picky. The reason anything is hard to learn is because it isn't explicitly explained
19:27:22 <SamB_XP> to think I'd reverse-engineered it from debugging output (which I had enabled for other reasons, thankfully ;-)
19:27:28 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/interactive-evaluation.html#ghci-stmts
19:27:29 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/2op2pj
19:27:41 <michael__> See!
19:27:48 <michael__> SamB_XP had to reverse engineer it
19:27:50 <michael__> That's ridiculous
19:28:05 <dmwit> No, he did not have to reverse engineer it.
19:28:07 <SamB_XP> michael__: I had to because it was unavoidable, not because I wanted to know
19:28:11 <kpreid> michael__: you're insisting on learning in a particular order. given that, you have to be prepared to do your own digging.
19:28:21 <michael__> SamB_XP, I'm not sure if you just insulted yourself or not
19:28:40 <kpreid> michael__: if you followed a tutorial, say, you'd learn what do-notation is, and then the ghci docs's remark that it is do notation is obvious
19:28:47 <SamB_XP> well, I mean, it would have been avoidable if I'd thought to read about it in the documentation before accidentally noticing it from typechecker output
19:29:00 <SamB_XP> or was that desugarer output?
19:29:15 <michael__> kpreid: How ridiculous! That's actually the mentality of many institutions of higher education. That's not the way it should be. You guys are the experts. Provide me with the knowledge so that i can think like yoU!
19:29:40 <dmwit> We have done so, at least thrice now.  Stop complaining.
19:29:50 <michael__> kpreid: read the tutorials provided, like the 5-min and 10-min ones. You'll find that there is code that seems like it should work in ghci, but doesn't
19:29:56 <mrd> we don't owe you anything
19:30:04 <SamB_XP> I meant this specific bit, actually:
19:30:09 <SamB_XP> Furthermore, GHCi will print the result of the I/O action if (and only if):
19:30:09 <SamB_XP>     *
19:30:09 <SamB_XP>       The result type is an instance of Show.
19:30:09 <SamB_XP>     *
19:30:09 <SamB_XP>       The result type is not ().
19:30:12 <michael__> dmwit, I'm not complaining about you guys. I'm complaining about the documentation and about learning in general
19:30:21 <kpreid> michael__: you clearly have an idea about how the documentation should be. SO WRITE IT.
19:30:32 <kpreid> make a note, learn, then fix it with your knowledge
19:30:35 <michael__> kpreid, don't you see the strangeness of your remark?
19:30:38 <michael__> Hold on
19:30:41 <sorear> no.
19:30:42 <michael__> Let me get something
19:31:35 <kpreid> or don't write it, but point at exactly what needs to be improved.
19:31:54 <kpreid> it's very hard to figure out how to fix documentation that you already know the content of.
19:32:57 <kpreid> that said, you're half-right. telling you to write the documentation *is* unreasonable, now that I think about it.
19:33:14 <kpreid> unfortunately, I don't know the right way to get documentation written.
19:33:34 <Korollary> ambiguities should be pointed by beginners and fixed by whoever that can fix it.
19:33:37 <SamB_XP> I was thinking we could tell him what he needed to know to finish writing what he wanted written
19:33:42 <SamB_XP> or something
19:33:58 <SamB_XP> I don't always have good ideas though
19:34:59 <michael__> http://www.haskell.org/haskellwiki/Haskell_in_5_steps says nothing about what's special in the interpreter. Then, http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes starts writing stuff in files without any explanation that there is some kind of difference. http://www.haskell.org/haskellwiki/List_comprehension starts with:
19:35:00 <michael__> import Data.Char (toUpper)
19:35:00 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
19:35:28 <michael__> That import statement is what started my confusion
19:35:30 <michael__> it didn't work
19:35:35 <michael__> There is even a bug report
19:36:14 <SamB_XP> quick, someone add links to the hugs/ghci documentation at the end of the wikipages
19:36:51 <michael__> Someone trying to learn actually wrote a bug report saying that import didn't work at the prompt. So, I'm not the only one confused.
19:37:06 <kpreid> SamB_XP: I don't think that's a good fix.
19:37:42 <michael__> http://hackage.haskell.org/trac/ghc/ticket/1672
19:37:43 <lambdabot> Title: #1672 (allow the use of import in the interpreter to load new modules) - GHC - T ...
19:37:47 <SamB_XP> or we could make GHCi respond to attempts to use "import", "type", "data", or binding forms with no let with links to documentation...
19:37:58 <kpreid> SamB_XP: YES YES YES!
19:37:58 <michael__> no
19:38:05 <michael__> That's terrible
19:38:09 <michael__> More sugar and hiding
19:38:12 <kpreid> well, a short explanation.
19:38:17 <michael__> Just tell people what the hell is going on
19:38:18 <kpreid> not "Go read this"
19:38:29 <SamB_XP> kpreid: hmm.
19:38:39 <SamB_XP> how about a short explanation with a link to a longer one?
19:38:44 <kpreid> SamB_XP: yes...
19:38:47 <michael__> kpreid, I would rather advice people to use just files. The interpreter really just ruins the whole experience of learning.
19:38:55 <SamB_XP> that would keep everyone happy except the determinedly crabby ones
19:38:59 <LoganCapaldo> could do let import ="Press ^D or ^C to quite"
19:39:05 * LoganCapaldo ducks
19:39:17 <kpreid> SamB_XP: SBCL, for example, produces some errors with an annotation about "See also: CLHS, section 1.9.2.4"
19:39:19 <SamB_XP> LoganCapaldo: reminds me of Python's help object
19:39:29 <LoganCapaldo> ;)
19:39:31 <SamB_XP> or quit object
19:39:33 <SamB_XP> or something
19:39:59 <SamB> well, both
19:40:06 <SamB> also exit
19:40:17 <allbery_b> do like the apocryphal claim for old gcc vs. #pragma
19:40:29 * kpreid should be asleep, therefore leaves
19:41:06 <SamB_XP> what, they IMPLEMENTED this?
19:41:30 <mrd> michael__: "advising people to use files" is pretty much what I read everywhere I can recall
19:41:52 <SamB_XP> michael__: heck, I'd advise PYTHON learners to use files
19:41:52 <michael__> mrd: They don't advise it. They just put things in files
19:42:02 <mrd> who?
19:42:08 <michael__> SamB_XP: I disagree. I learned a lot at the prompt in python.
19:42:41 <SamB_XP> a lot of the time it gets pretty repetetive if you don't put your code in a file...
19:42:44 <michael__> SamB_XP: People start using files in Python not because the prompt is different, but because of formatting
19:43:12 <SamB_XP> I'd say it's because it saves having to type in your program each time you want to use it
19:43:18 <michael__> yes
19:43:34 <michael__> But that reason is a lot more innocuous than hiding what's going on behind the scenes causing confusion
19:43:38 <LoganCapaldo> clearly ghci needs to become image based
19:43:45 <LoganCapaldo> so that you don't have to use files
19:44:06 <Korollary> ghc needs a lot more devs for the usability stuff
19:44:57 <SamB_XP> heck, why did I bother with Haskell when it doesn't have interactive help?
19:45:10 <Korollary> it's not everything to everybody
19:45:13 <LoganCapaldo> mmm interactive help
19:45:19 <SamB_XP> I suppose because it was so crazy
19:45:26 <geocalc> lol
19:45:28 <SamB_XP> that's the only reason I can think of why I would have bothered
19:47:30 <sorear> Why do we try to attract easily-confused users, no, users period?  What's wrong with more academics?
19:47:45 <michael__> sorear: I'm a student at MIT
19:47:56 <SamB_XP> this has been noticed
19:48:01 <sorear> michael__: CS or CE?
19:48:08 <SamB_XP> they are wondering how an MIT student can have so much trouble
19:48:08 <michael__> CS
19:48:12 <michael__> and CE
19:48:23 <Korollary> they have the depts merged at MIT
19:48:35 <SamB_XP> that makes sense
19:49:09 <michael__> SamB_XP: The difference is that I don't care WHAT needs to be done. I care WHY.
19:49:20 <michael__> That's why I'm confused. You're not confused, because you don't know to be.
19:49:38 <SamB_XP> michael__: I do care why
19:50:58 <SamB_XP> http://www.haskell.org/ghc/docs/latest/html/users_guide/ch03s04.html seems to say what's different
19:50:59 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/2c2oeu
19:51:10 <Korollary> michael__: the language definition is actually quite readable. Of course it's not meant as an intro, but you may prefer it for its coverage and detail.
19:51:31 <michael__> Korrolary, I think I'll take a look at that.
19:51:48 <SamB_XP> @google Haskell report
19:51:50 <lambdabot> http://www.haskell.org/onlinereport/
19:51:50 <lambdabot> Title: The Haskell 98 Language Report
19:52:00 <michael__> thanks
19:52:15 <michael__> No offense was meant to you personally, SamB_XP.
19:52:27 <SamB_XP> ;-)
19:53:29 * SamB_XP wonders how GHCi preserves the environment
19:53:45 <chessguy_> IORefs?
19:54:03 <LoganCapaldo> elves.
19:54:06 <Spark> garbage collection
19:54:16 <Korollary> energy efficient lightbulbs
19:54:30 <Spark> burning ethnic minorities for fuel
19:54:33 <SamB_XP> chessguy's answer was the best
19:54:42 <chessguy> yay, i win!
19:54:53 <Korollary> No, chessguy_ won.
19:54:55 <allbery_b> hidden inside a private RealWorld#? :)
19:55:03 <chessguy_> i win!
19:55:06 <SamB_XP> since, you know, it was plausibly close to what I meant
19:55:08 <Spark> his answer made me wonder if it was a serious question :)
19:55:34 <SamB_XP> allbery_b: I bet GHCi has a better monad
19:55:42 <SamB_XP> which has an environment somehow
19:55:44 <Daveman> hey chessguy :)
19:55:47 <SamB_XP> but I don't know how
19:55:48 <chessguy> hiya!
20:01:03 <dylan> Ugh!
20:01:20 <dylan> someone using "light-years" as a unit of time on haskell-cafe. :(
20:01:55 <Korollary> it could be a unit of time
20:02:02 <Korollary> albeit redundant
20:02:11 <Korollary> like a dog year
20:02:22 <dylan> "light-years above the crowd." -> "We're 12 trillion miles head of the crowd"
20:02:54 <dylan> s/head/ahead/, s/ahead/above/..
20:03:58 <michael__> hahaha
20:04:07 <michael__> The first text of the report:
20:04:09 <michael__> ‚ÄúSome half dozen persons have written technically on combinatory logic, and most of
20:04:09 <michael__> these, including ourselves, have published something erroneous. Since some of our fel-
20:04:09 <michael__> low sinners are among the most careful and competent logicians on the contemporary
20:04:10 <michael__> scene, we regard this as evidence that the subject is refractory. Thus fullness of expo-
20:04:10 <michael__> sition is necessary for accuracy; and excessive condensation would be false economy
20:04:10 <michael__> here, even more than it is ordinarily.‚Äù
20:04:20 <michael__> Quote from Haskell himself.
20:08:24 <_achilles_> I assume this is either sacreligous or offensive, but please consider it ignorance:
20:08:37 <_achilles_> why not Lisp? what makes Haskell better?
20:08:46 <SamB_XP> typeses!
20:08:55 <chessguy> strong typing, purity
20:08:58 <chessguy> laziness
20:09:00 <dylan> types, and laziness.
20:09:06 <SamB_XP> we do have something called syntax, too
20:09:15 <SamB_XP> but we may possibly have a bit much of that
20:09:34 <_achilles_> so, Lisp only has "s-expressions" where haskell has lists and tuples...etc?
20:09:52 <Korollary> Well, the designers never say why X is better than Y.
20:10:15 <SamB_XP> sometimes, though, you may not WANT types
20:10:36 <Korollary> But, Haskell is a new direction that appeals to some people and perhaps not to some other people. For instance, there are schemers who know haskell and are not fond of it.
20:10:38 <SamB_XP> or syntax
20:10:56 <SamB_XP> there are schemers who know haskell and ARE fond of it, too
20:11:37 <_achilles_> so I just decided today would be the day where I'd poke at Haskell; I've used scheme before, infact I had to write and interpreter for it, and ifind Haskell a lot more intuitive to use
20:11:57 <_achilles_> I'm just curious what other's opinion is of the riff between Lisp/Scheme...etc and Haskell
20:12:07 <chessguy> @go haskell write yourself scheme 48 hours
20:12:13 <_achilles_> rift*
20:12:23 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
20:12:30 <chessguy> ...
20:12:32 <SamB_XP> @go haskell scheme in 48 hours
20:12:41 <Korollary> There's not really much rift between lisps and haskell. In fact, the communities (user and academic) tend to be pretty disjoint.
20:12:42 <sorear> _achilles_: we have static types and laziness
20:12:47 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
20:12:56 <sorear> bad google!
20:13:02 <geocalc> don't use shame !!!
20:13:19 <SamB_XP> I didn't do it
20:13:27 <SamB_XP> I haven't touched @google in years
20:13:37 <chessguy> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours'
20:13:41 <chessguy> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
20:14:01 <chessguy> _achilles_, ^^
20:14:27 <_achilles_> appreciated
20:14:46 <_achilles_> I'm walking through "yaht" as we speak
20:14:59 <SamB_XP> have you got your sea legs yet?
20:15:12 <_achilles_> slow and steady
20:15:24 * SamB_XP shamelessly puns the title
20:15:34 <_achilles_> it's been a while since i've "schemed" and it was never really "hard core"
20:15:40 <chessguy> *rimshot*
20:16:09 <_achilles_> but like I mentioned above, I already feel a lot more comfortable in Haskell land
20:16:16 <SamB_XP> chessguy: remind me if that means that I missed or not
20:16:27 <chessguy> missed?
20:16:48 <SamB_XP> or who had a rimshot?
20:17:17 <_achilles_> hahah
20:17:20 <_achilles_> wrong rimshot
20:17:29 <_achilles_> not basketball, think drums
20:17:45 <_achilles_> bah-dump ching! == rimshot
20:17:55 <chessguy> ohh
20:17:55 <SamB_XP> oh.
20:18:06 <SamB_XP> I thought that was something you did with drums
20:18:09 <chessguy> i was wondering what he was talking about
20:18:36 <Spark> i hereby pronounce this conversation to be a write-off
20:18:43 * _achilles_ brings people together
20:18:45 <SamB_XP> well, write it off then
20:18:54 <chessguy> or type it off
20:19:00 * _achilles_ crumples it up and throws it out the window
20:19:16 <_achilles_> lame lame lame
20:19:18 <Korollary> we gotta destroy the channel logs as well
20:19:27 * chessguy takes a bow
20:20:41 <SamB_XP> a raid!
20:20:43 <_achilles_> bow? need some arrows
20:20:45 <_achilles_> ?
20:21:03 <Korollary> @kind (->)
20:21:05 <lambdabot> ?? -> ? -> *
20:21:08 * _achilles_ shamelessly repeat the above conversation that was written/typed off
20:21:11 <SamB_XP> a raid on tunes.org as well as whatever the heck they call the site that cmeme logs for now
20:21:54 <michael__> Thanks, and bubbye.
20:22:33 <dylan> I think this conversation has been witten off.
20:22:33 <SamB_XP> also does dons have some logs posted? we may need to raid them too before another darcs record
20:23:04 <Spark> - - - - - - - - - please tear along the dotted line - - - - - - - - - - - - -
20:23:31 <SamB_XP> that's so yo can throw out the rest of the logs and just keep the above conversation, right?
20:23:43 <Spark> and frame it
20:24:19 <Spark> didn't a bunch of things used to print such things, when printing to printers with continuous spools?
20:24:24 <Spark> </ambiguous>
20:24:36 <Korollary> yes, Miss South Carolina
20:24:45 <_achilles_> and such as
20:24:51 <_achilles_> like
20:24:53 <Korollary> South Africa and Iraq
20:25:11 <_achilles_> and the US Americans
20:28:07 <araujo> hello
20:28:24 <_achilles_> hAllo
20:28:41 <allbery_b> shalom
20:35:56 <chessguy> SamB_XP, "so....we go with you, and 'e stays here?"
20:36:23 <SamB_XP> ?
20:36:36 <chessguy> monte python
20:39:44 <Olathe> No, you stay here and guard him !
20:40:26 <chessguy> "oh, get a drink"
21:03:18 <geocalc> anyone have an high res logo of haskell that i'll put as wall paper ?
21:10:20 * araujo been thinking to make some wallpapers of himerge logo
21:11:44 <DJ-DrIP[AR]> hello all!
21:11:52 <DJ-DrIP[AR]> what is the latest GHC build
21:13:28 <DJ-DrIP[AR]> ha ha ha lol
21:14:42 <dmwit> 6.6.1 stable, 6.8.0 unstable
21:14:57 <DJ-DrIP[AR]> ok
21:24:06 <Tac-Tics> http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism
21:24:29 <Tac-Tics> In that wikibook tutorial, it says Haskell's type system is inconsistent because bottom inhabits all types.....
21:25:03 <dmwit> Do you think that's wrong?
21:25:17 <Tac-Tics> but can't you just modify the statement to say that a nontheorem is any type with bottom only members?
21:25:38 <dmwit> Bottom is a value, not a type.
21:26:03 <ac> let's say I have a function called "foo" with a signature of "a -> (b -> c) -> d -> e" and function bar with a signature "b -> c". How do I pass bar to foo as well as variables of type d and e? With the syntax I know the d variable will be consumed by bar instead of being passed to foo
21:26:04 <Tac-Tics> yeah, but it is polymorphic across all types in Haskell
21:26:25 <dmwit> ac: foo a bar d
21:26:54 <Tac-Tics> so any type with bottom as its only member in haskell corresponds to a nontheorem
21:26:56 <ac> dmwit: oh. I guess to get the behavior I'm thinking about you'd say foo a (bar b) d
21:26:59 <Lycurgus> actually all it says is that proper programming is necessary to obtain logically consistent application models
21:27:10 <Tac-Tics> in this page, it makes it sound like Haskell is inconsistent with itself
21:27:15 <Lycurgus> which is true in all langs with varying degrees
21:27:31 <Lycurgus> in prolog it's sort of automatic and carried by the model
21:27:52 <Lycurgus> of computation unlike Haskell which is I think what that person is saying.
21:29:20 <ac> dmwit: I'm still getting used to the fact that ' ' is an operator
21:30:12 <dmwit> ac: Just remember that function application is left-associative and you'll be fine.
21:48:43 <ac> hmm. let's say you have a function that takes a stream, but the more it processes, the more values it must maintain from earlier in the stream. How would you store this? An array isn't ideal because it's not growable.
21:51:50 <dmwit> ac: How about a list?
21:51:54 <sarehu>  it depends on why you need/what you're doing with the values you're saving
21:51:58 <dmwit> yeah
21:56:37 <arcatan> you could use a big array and then double its size every time it's filled, or something like that
21:57:22 <sjanssen> Data.Sequence?
21:57:53 <sjanssen> fast appends on either side and logarithmic index
22:26:54 <Tac-Tics> is there a standard function for \(x, y) -> (y, x)?
22:27:06 <Tac-Tics> @hoogle (a, b) -> (b, a)
22:27:06 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
22:27:56 <mauke> :t (fst &&& snd)
22:27:57 <jleedev> @pl \(x,y) -> (y,x)
22:27:57 <lambdabot> uncurry (flip (,))
22:27:58 <lambdabot> forall a b. (a, b) -> (a, b)
22:28:06 <mauke> :t (snd &&& fst)
22:28:08 <lambdabot> forall a b. (a, b) -> (b, a)
22:28:40 <jleedev> signs point to yes
22:30:48 <Tac-Tics> :t (&&&)
22:30:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:32:23 <mauke> :t liftM2 (flip (,)) snd fst
22:32:25 <lambdabot> forall a b. (a, b) -> (a, b)
22:33:11 <mauke> d'oh
22:33:18 <mauke> :t liftM2 (,) snd fst
22:33:20 <lambdabot> forall a b. (a, b) -> (b, a)
22:33:24 <Tac-Tics> hehe
22:34:12 <Tac-Tics> :t id :: (a, b) -> (a, b)
22:34:14 <lambdabot> (a, b) -> (a, b) :: forall a b. (a, b) -> (a, b)
22:34:44 <mauke> :t curry id
22:34:46 <lambdabot> forall a b. a -> b -> (a, b)
22:35:00 <mauke> :t uncurry (flip (curry id))
22:35:01 <lambdabot> forall b a. (a, b) -> (b, a)
22:35:26 <Tac-Tics> I can never remember which does which, between curry and uncurry
22:35:28 <Tac-Tics> :t curry
22:35:30 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
22:35:35 <Tac-Tics> :t uncurry
22:35:36 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
22:36:06 <Tac-Tics> > (uncurry map) ((+1), [1,2,3])
22:36:08 <lambdabot>  [2,3,4]
22:37:50 <ac> sjanssen: thanks, I'll check out Data.Sequence
22:38:32 <Tac-Tics> does Haskell's getLine and standard IO functions read and write Unicode or binary?
22:38:50 <mauke> binary
22:38:54 <mauke> :(
22:38:54 <Tac-Tics> cool
22:39:06 <Tac-Tics> well, binary is what I'm neeting
22:39:21 <Tac-Tics> and makes more sense probably to be the standard IO
22:39:30 <ac> Tac-Tics: isn't unicode binary? The only thing that unicode support means is being able to do unicode string operations on binary arrays
22:39:33 <mauke> no, it doesn't
22:39:43 <mauke> ac: argh, please no
22:39:50 <ac> mauke: what?
22:40:16 <Tac-Tics> ac: reading a Unicode character could mean reading in 1 or two bytes whereas by "binary" I meant single byte reads and writes
22:40:24 <mauke> my strings should be sequences of unicodepoints
22:41:05 <ac> mauke: right, like lists of Word32
22:41:13 <mauke> ac: or [Char]
22:41:28 <ac> right.
22:41:28 <mauke> as for binary IO, the types are not right
22:41:49 <mauke> binary input functions should give you something like Array Word8
22:42:20 <mauke> and then an encoding layer on top of that could decode into unicode
22:42:36 <ac> mauke: is this how things are or how they should be?
22:42:58 <Tac-Tics> yeah
22:43:10 <mauke> well, this is how things are in perl and how they should be in haskell :-)
22:43:15 <sorear> mauke, Tac-Tics: we HAVE binary i/o, see h{Get,Put}Buf and the friendlier Data.ByteString
22:44:25 <mauke> hGetBuf still takes a Handle
22:44:55 <sjanssen> we have the implementation of a binary IO system with the interface of a character based system
22:51:49 <Tac-Tics> are there signed implementations of Data.Word types?
22:52:24 <sarehu> see Data.Int
22:52:35 <Tac-Tics> oh neat
22:52:37 <Tac-Tics> thanks
23:09:07 <dataangel> What's the simplest way in haskell to express that a function should be an N*N list? (or list of lists?) Basically looking for the constraint that both dims are the same
23:11:34 <Tac-Tics> @hoogle Int -> [a] -> ([a], [a])
23:11:35 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
23:12:11 <dataangel> TacTics: That doesn't enforce the constraint
23:12:32 <dataangel> err, sorry, should _take_ an N*N list
23:15:00 <Tac-Tics> dataangel: I wasn't solving your issue, I was looking up something for myself
23:16:18 <dons> ?users
23:16:18 <lambdabot> Maximum users seen in #haskell: 420, currently: 330 (78.6%), active: 6 (1.8%)
23:16:44 <misterbeebee_>  dataangel: compile-time or run-time?  I don't think it's possible at compile-time
23:17:16 <dons> it is possible, of course, to set the numeric bounds, but you need your own data type
23:17:17 <Tac-Tics> How does one construct values of Int8, 16, 32, Word16, 32?
23:17:26 <dons> > 1 :: Word32
23:17:27 <lambdabot>  1
23:17:34 <dons> use numeric literal overloading
23:17:40 <dons> (neat, huh?)
23:17:54 <Tac-Tics> that works for literals
23:18:00 <Tac-Tics> but what about converting from Chars?
23:18:05 <dons> fromIntegral . ord
23:18:06 <mauke> read
23:18:10 <dons> :t ord
23:18:11 <lambdabot> Char -> Int
23:18:15 <dons> Char*s* --> read
23:18:18 <Tac-Tics> ah
23:18:25 <dons> > read "1" :: Word32
23:18:26 <lambdabot>  1
23:18:32 <dons> (neat, huh?)
23:18:39 <Tac-Tics> (yes, now it's neat ^^)
23:18:54 <dons> heh
23:19:49 <dons> day 2 of the hackathon coming up!
23:19:58 <Nafai> dons: Cool!  Anything cool being done?
23:19:59 <dons> these things are great, we need to do more of them
23:20:03 <misterbeebee_> dataangel: > (\x -> length x - length (transpose x) == 0) [ [1,2,3], [4,5,6], [7,8,9]]
23:20:05 <arcatan> what are you hacking?
23:20:13 <misterbeebee_> > (\x -> length x - length (transpose x) == 0) [ [1,2,3], [4,5,6], [7,8,9]]
23:20:15 <lambdabot>  True
23:20:17 <dons> yeah, *heaps* of stuff. cabal, binary, xmonad, editors, http, math, ..
23:20:37 <Tac-Tics> how can you keep up with so much @___@
23:20:50 <dons> see here http://www.haskell.org/haskellwiki/Hac_2007_II
23:20:52 <lambdabot> Title: Hac 2007 II - HaskellWiki
23:20:56 <Tac-Tics> There's so many cool things to learn about and program, but where does the time come from to do it all?
23:21:00 <dons> there's photos, blogs, and a section on what people are working on
23:21:01 <hpaste>  dataangel pasted "newb compile problem, help?" at http://hpaste.org/3109
23:21:12 <dons> Tac-Tics: you do have to try to be efficient, to make good progress, that's true
23:21:21 <dons> and know when to prune
23:21:38 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2007/10/06#hac07-2-day1
23:21:38 <lambdabot> Title: Haskell hacking
23:22:05 <dons> we have a bit of an army, http://stockwits.com/Hackathon.jpg
23:22:05 <Tac-Tics> All I do at work all day is slack off from my job to do Haskell and related cooler things
23:22:15 <dons> you need to get a haskell job then
23:22:18 * dataangel doesn't understand why adding the obvious type signature breaks things :P
23:22:34 <hpaste>  (anonymous) annotated "newb compile problem, help?" with "(no title)" at http://hpaste.org/3109#a1
23:22:55 <dons> :t \n -> replicate n (replicate n 0)
23:22:57 <lambdabot> forall t. (Num t) => Int -> [[t]]
23:23:10 <dons> looks fine.
23:23:17 <dons> :t \n -> replicate n (replicate n 0) :: Int -> [[Int]]
23:23:18 <lambdabot>     Couldn't match expected type `Int -> [[Int]]'
23:23:19 <lambdabot>            against inferred type `[[t]]'
23:23:20 <misterbeebee_> I annoted it
23:23:50 <misterbeebee_> dataangel: you had extra [] around 0
23:23:50 <dons> :t (\n -> replicate n (replicate n 0)) :: Int -> [[Int]]
23:23:52 <lambdabot> Int -> [[Int]] :: Int -> [[Int]]
23:24:03 <dons> yes, originally
23:24:30 <dataangel> oic I didn't spot the triple nestedness in the output when I didn't have the sig
23:24:35 <ac> what does '|' (pipe) do in Haskell?
23:25:07 <misterbeebee_> "adding the obvious type signature" *fixed* your code, it didn't break it :)
23:25:26 <adu> i just learned what a real monad is
23:25:48 <axm> what's an unreal one?
23:25:56 <adu> a haskell monad
23:26:13 <adu> uh
23:26:22 <adu> i mean there are no unreal monads :P
23:26:36 <arcatan> Unreal Monad 2004
23:26:41 <adu> lol
23:26:48 <ac> adu: aren't Haskell monads pretty far from the category theory version?
23:27:00 <adu> the mathematical monad is what i was talking about
23:27:16 <ac> or are they a subset?
23:27:43 <adu> well Haskell monads fit the description of a mathematical monad i suppose
23:27:48 <misterbeebee_> ac: pipe like this> http://en.wikipedia.org/wiki/Guard_%28computing%29
23:27:49 <lambdabot> Title: Guard (computing) - Wikipedia, the free encyclopedia
23:27:50 <misterbeebee_> ?
23:28:22 <Tac-Tics> bah, stupid random haskell keywords... "data" "type"
23:28:32 <Tac-Tics> I want those for my identifiers!!
23:28:34 <merus> lol
23:28:45 <ac> misterbeebee_: It's used in the docs for array construction, but I don't understand it
23:28:49 <Tac-Tics> it was giving me a weird error in a let expression
23:29:11 <Tac-Tics> because for some reason gedit doesn't hilight "type" like all the other keywords
23:29:14 <misterbeebee_> oh, it's inspired by set-theory
23:29:40 * Nafai sighs
23:29:50 <misterbeebee_> > [(x,y) | x <- [2,3], y <- [4,5]]
23:29:51 <lambdabot>  [(2,4),(2,5),(3,4),(3,5)]
23:29:53 <misterbeebee_> like that?
23:29:54 <Nafai> I guess it is time to quite being lazy and just hunker down and learn Haskell
23:30:03 <misterbeebee_> "|" means  "such that"
23:30:18 <ac> misterbeebee_: ok thanks
23:30:18 <misterbeebee_> all (x,y) such that x is taken from 2,3, y taken from 4,5
23:30:38 <ac> misterbeebee_: that's what it looked like from the single example, but I wasn't sure about it
23:30:39 <dataangel> If I represent a grid with a 5x5 list of lists, I know I can sum row wise by doing sum (grid !! row), but what's the easiest way to sum column wise?
23:30:43 <adu> a mathematical monad needs a functor and two natural transformations: (T, Mu, Eta) such that Mu : T^2 -> T and Eta : 1 -> T
23:31:01 <adu> which could be satisfied by (>=) and 'return'
23:31:02 <misterbeebee_> it's a "list comprehension"
23:31:10 <misterbeebee_> if you don't see haskell doc on it, look for python doc )
23:31:19 <mauke> :t transpose
23:31:20 <lambdabot> forall a. [[a]] -> [[a]]
23:31:28 <dataangel> misterbeebee: that occurred to me as I wrote it, but thought there might be something more elegant :)
23:31:31 <ac> dataangel: transpose
23:31:40 <Tac-Tics> I didn't comprehend list comprehensions at first
23:31:49 <Tac-Tics> but after I learned about them, they are like a drug
23:31:50 <mauke> adu: mu looks like join
23:32:13 <dataangel> this is probably an abused c programmer question, but is there a way to do the column wise sum without altering the data? (yes I know haskell's pure, but I mean so that the compiler won't generate a superfluous grid...)
23:32:17 <adu> mauke: maybe, I'm not a Haskell monad expert
23:32:24 <mauke> :t join
23:32:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:32:44 <Nafai> Okay, to write a simple parser...
23:32:55 <Tac-Tics> @hoogle [a] -> Int -> Int -> [a]
23:32:55 <lambdabot> No matches, try a more general search
23:32:56 <mauke> dataangel: how do you know the compiler will generate an intermediate grid?
23:33:01 <ac> dataangel: map (foldl (+) 0) (transpose list)
23:33:05 <Tac-Tics> @hoogle Int -> Int -> [a] -> [a]
23:33:06 <lambdabot> No matches, try a more general search
23:33:21 <ac> dataangel: that will give you alist of sums of the columns
23:33:42 <dataangel> mauke: I don't. But if I were to write a naive compiler I would guess that the transpose solution would.
23:34:05 <mauke> ghc isn't entirely naive
23:34:17 <mauke> ac: foldl (+) 0 == sum
23:34:25 <ac> dataangel: don't worry about it, unless the simplest sollution is actually too slow
23:34:47 <ac> oh. I guess it could be map sum $ transpose list
23:35:11 <Tac-Tics> bah, I need to figure out a better way to do this
23:35:23 <Tac-Tics> I need to convert [Char] or [Word8] to Word16 or Word32
23:35:29 <dataangel> ac: I'm not too worried about it, I'm just curious
23:35:37 <Tac-Tics> the ord trick would work, but I'd have to handle all the math myself
23:35:40 <ac> dataangel: :)
23:35:45 <Tac-Tics> and it seems like it should be built into some library already
23:35:48 <mauke> math?
23:35:58 <Tac-Tics> mostly multiplying each byte
23:36:02 <dataangel> ac: For all of it's faults one of the nice things about C is that you can often reason about how it will translate to assembly, if that's you're thing. It's predictable in that sense (though unpredictable in many others ;p)
23:36:10 <Tac-Tics> so for [Char] -> Word16
23:36:30 <mauke> dataangel: only if your compiler sucks
23:36:36 <Tac-Tics> it would be [x, y] = fromIntegral . ord $ x * 256 + y or something
23:37:00 <Tac-Tics> and for 32, it would involve figuring out each multiple of 2
23:37:07 <Tac-Tics> and it wouldn't be too difficult
23:37:12 <Tac-Tics> but I'm sure there's something to do it already
23:37:54 <Tac-Tics> I don't want to be responsible for the Endian fate of my users
23:37:55 <dataangel> mauke: err.. you're right
23:38:16 <mauke> many C compilers suck :(
23:40:02 <dataangel> mauke: what I guess I was trying to say is that on a non-algorithmic level, you can reason about what's slow (passing a large struct by value), and you can reason about when copies are made and when they're not
23:40:14 <dataangel> mauke: there's some sort of transparency to that that deserves a name
23:40:51 <mauke> dataangel: gcc can turn a non-tail recursive function into a simple loop with a custom calling convention that doesn't touch the stack
23:41:09 <dataangel> mauke: @_@
23:41:31 <mauke> :t zipWith (*) . iterate (256 *) 1
23:41:32 <lambdabot>     Couldn't match expected type `a -> [a1]'
23:41:33 <lambdabot>            against inferred type `[t]'
23:41:38 <merus> Who was it that said premature optimization was the root of all evil?
23:41:45 <mauke> :t zipWith (*) (iterate (256 *) 1)
23:41:47 <lambdabot> forall a. (Num a) => [a] -> [a]
23:41:49 <dataangel> mauke: that's an example though where it's possible the compiler is better than you pessimistically reason though, not worse
23:41:52 <Tac-Tics> Speed isn't an issue until it becomes an issue.
23:42:12 <dataangel> mauke: useful predictability is still preserved if you can say this big/fast "or better"
23:48:18 <misterbeebee_> dataangel: how big is your array?
23:48:28 <dataangel> does haskell have some sort of python'esq list slicing?
23:48:29 <misterbeebee_> > let n = 1000 in let myArray = replicate n (take n $ iterate (1+) 1)  in  let collapsed = map sum $ transpose myArray in  let middle = (n `div` 2) in collapsed !! middle
23:48:30 <lambdabot>  501000
23:48:45 <dataangel> misterbeebee_: 5x5. I'm asking out of curiosity ;p
23:49:45 <mauke> dataangel: well, there's take/drop
23:50:23 <dataangel> mauke: drop is perfect :)
23:51:16 <misterbeebee_> sometimes you can get into trouble with list operations. a lot of optimizations are built into ghc (they are called "rewrite rules" in general and "fusions" for lists), and you can write special rules if you know that a complicated expression has an efficient algorithm
23:51:18 <misterbeebee_>  (e.g., (transpose . transpose) ==== id, if ghc didn't already know that, you could tell it)
23:52:07 <mauke> @check \x -> (transpose . transpose) x == (x :: [[Int]])
23:52:08 <lambdabot>  Falsifiable, after 5 tests: [[2,3,3],[-1,4,4],[]]
23:52:28 <misterbeebee_> well, its true on dataangel's square arrays :-p
23:53:21 <dataangel> lol
23:54:41 <dataangel> @check \x -> drop 0 x == x
23:54:42 <lambdabot>  Add a type signature
23:55:14 <dataangel> @check \x -> drop 0 x == (x :: [a])
23:55:15 <lambdabot>   x
23:55:24 <mauke> what
23:55:35 * dataangel tries to figure out the lambdabot syntax
23:55:37 <mauke> @check \x -> drop 0 x == (x :: [Int])
23:55:39 <lambdabot>  OK, passed 500 tests.
23:55:49 <dataangel> oic it has to be more specific then? ;p
23:55:55 <dataangel> won't throw in random types for you? :D
23:56:28 <mauke> yeah, it has to know what types it is in order to generate random values for them
23:59:27 <misterbeebee_> @check  \x -> length x < 5 ||  (foldl min 6) (map length x) < 5  ||  let list5x5 = take 5 $ map (take 5) (x :: [[Int]])  in  (transpose . transpose) list5x5 == list5x5
23:59:29 <lambdabot>  OK, passed 500 tests.
23:59:50 <misterbeebee_> (probably need to seed the generator for that to be  a fair test)
