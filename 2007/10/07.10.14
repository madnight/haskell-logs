00:35:09 <agnokapathetic> so the fibonacci sequence is defined as fib = 1 : 1 : zipWith ( + ) f (tail f)
00:35:35 <agnokapathetic> how does one f x = x:func x:func (last x)
00:36:06 <agnokapathetic> so that each number in the sequence is simply the result of func(previous item)
00:36:13 <shachaf> @ty iterate
00:36:16 <lambdabot> forall a. (a -> a) -> a -> [a]
00:36:19 <shachaf> > iterate (*2) 1
00:36:20 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
00:36:43 <shachaf> @src iterate
00:36:44 <lambdabot> iterate f x =  x : iterate f (f x)
00:38:36 <shachaf> > let { iter f x = let l = x : map f l in l } in iter (*2) 1 -- Another way of defining it.
00:38:38 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
00:42:41 <agnokapathetic> > let isq x | even x  = x `div` 2 | odd x   = 3*x+1 in isq 13
00:42:43 <lambdabot>  40
00:42:53 <agnokapathetic> with that function
00:43:01 <P_D> Arg, ghci is crashing on big bignums
00:43:22 <agnokapathetic> how do i create a list of isq x: isq (isq x) ...
00:43:45 <agnokapathetic> my imperative loop oriented mind is at a lost
00:44:31 <shachaf> agnokapathetic: Look at iterate's type and @src.
00:44:51 <agnokapathetic> i did and can't seem to wrap my mind as to how to apply it
00:45:13 <agnokapathetic> when the function isn't defined by the sequence
00:45:19 <shachaf> > iterate (+1) 8 -- Do examples help?
00:45:20 <lambdabot>  [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33...
00:46:05 <agnokapathetic> ahh, i got it
00:46:07 <agnokapathetic> thank you :-)
00:46:11 <dmwit> =)
00:46:24 <dmwit> Be careful, we might lure you in.
00:46:34 <shachaf> takeWhile may also be useful, by the way.
00:46:37 <shachaf> @ty takeWhile
00:46:39 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:47:00 <shachaf> > takeWhile (<100000) (iterate (*2) 1)
00:47:01 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536]
00:52:45 <magnus_> Saizan, hi!
00:54:09 <dmwit> Welcome back, magnus_.
00:54:41 <thepointer> hrm, i have type Label = String, then i want to have Label as an possibility for another data type.. such as data Cardinal = Integer | Label
00:54:57 <thepointer> except it says i'm declaring it twice.. is my logic wrong? or is my syntax wrong
00:55:01 <hpaste>  magnus_ pasted "typeclass for phantom" at http://hpaste.org/3277
00:55:15 <magnus_> dmwit, thanks
00:55:23 <dmwit> thepointer: Cardinal needs constructor names.
00:55:25 <dmwit> like
00:55:39 <dmwit> data Cardinal = SomeNumber Integer | SomeVariable Label
00:56:05 <thepointer> and i guess i can't say Cardinal Integer and Cardinal Label
00:56:40 <dmwit> thepointer: Well, Cardinal is an okay constructor name, but you can't use it for both constructors.
00:57:19 <thepointer> okay awesome. i shall investigate this.
00:57:21 <thepointer> thank-you dmwit
00:57:51 <magnus_> phantom type / type class problem: I declare a type class (which phantom types will implement) in http://hpaste.org/3277#a1
00:58:29 <magnus_> can I get liberate to have the type d a -> a so that I can liberate both strings and list of strings?
00:58:35 <mcp> when i define a funktion with some alternatives using '|'.  1) Are alternatieves tried from top to bottom? 2) Do I make the default option by adding   '| True = ...' ?
00:59:06 <magnus_> mcp, yes! use 'otherwise'
00:59:06 <dmwit> mcp: Yes, to both questions.
00:59:10 <ddarius> Technically, it should still be fine, you would be declaring the Cardinal data type with two nullary constructors Integer and Label.
00:59:23 <ddarius> @src otherwise
00:59:24 <lambdabot> otherwise = True
01:00:30 <dmwit> magnus_: I assume you've already tried just doing s/String/a/, but have you tried "class DataEncoding d a where ..."?
01:02:30 <hpaste>  magnus_ annotated "typeclass for phantom" with "error" at http://hpaste.org/3277#a2
01:02:48 <magnus_> dmwit, yes I tried (d s -> s), that gave me an error
01:03:43 <magnus_> dmwit, (DataEncoding d a) forces me to use glasgow-exts, which isn't a big problem
01:03:55 <mcp> Does haskell have a nice linux ide?  (but something with mouse, no emax thing). I'd like intellisense, and underlined errors in the editor.
01:04:00 <magnus_> I just wanted to know if there was some obvious solution to it
01:04:58 <dmwit> mcp: I guess hIDE gets mentioned, although I still think vim/emacs are pretty good.  They have mouse and an intellisense-alike when properly configured.
01:05:51 <dmwit> Vim can also jump you to errors, and I wouldn't be surprised if emacs has that possibility, too.
01:07:46 <hpaste>  agnokapathetic pasted "is there a way i should be doing this that I don't know of?" at http://hpaste.org/3278
01:08:38 <dmwit> agnokapathetic: Well, a slight optimization is to keep track of the length for things you already computed.
01:08:43 <dmwit> So, for example:
01:09:06 <dmwit> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1
01:09:14 <swix> I did that yesterday...
01:09:16 * swix looks
01:09:48 <dmwit> Now, when you are later calculating the length of something, and it gets to 3, you already know it will go 7 more steps.
01:09:49 <swix> http://hpaste.org/3260
01:09:52 <dmwit> So you don't have to do all 7 steps.
01:10:25 <agnokapathetic> yeh
01:10:31 <swix> dmwit, well, I was doing the project euler problem and mine bailed due to the overhead of haskell's bookkeeping, it was much easier to do it the naive way
01:10:32 <agnokapathetic> *yeah
01:10:42 <dmwit> swix: Ah, that's too bad.
01:10:51 <swix> it was
01:10:53 <dmwit> swix: When I solved it, I used Data.Array, and it worked out okay.
01:11:04 <swix> ahh
01:11:27 <swix> probably fix the O(n) of !!
01:11:36 <dmwit> *nods*
01:11:40 <swix> Array is probably O(log n) no?
01:11:49 <dmwit> I think O(1).
01:12:10 <swix> even better :P
01:12:35 <swix> well, I got to head to bed
01:12:38 <swix> happy haskelling
01:12:44 <agnokapathetic> goodnight :-)
01:12:44 <dmwit> g'night
01:13:31 <magnus_> dmwit, I can't seem to get DataEncoding d a to work either :(
01:13:38 <dmwit> magnus_: =(
01:13:40 <roconnor> in http://therning.org/magnus/archives/321 I make a comment that the Haskell '98 report doesn't make any space/time guarentees.
01:13:44 <dmwit> I don't know enough type-hackery to help you.
01:13:46 <roconnor> Is this true, or am I lying
01:14:05 <roconnor> oh, and hi magnus_
01:14:47 <roconnor> Specifically I'm wondering if the memoization we all expect is specified in the report.
01:14:53 <magnus_> hi, roconnor
01:15:18 <magnus_> roconnor, good question... I'd like the answer to that as well :)
01:15:50 <magnus_> dmwit, no worries... I'll have to fall back on haskell-cafe or the lazyweb I guess
01:16:37 <roconnor> magnus_: the denotational semantics requires an implementation to effectively do normal-order evaluation of expressions.
01:16:45 <roconnor> but that is only half of laziness
01:16:58 <roconnor> the other half is to not repeat computations
01:17:12 <roconnor> Which can be seen as an obvious optimization.
01:17:18 <magnus_> roconnor, ah, yes, that makes sense
01:18:08 <magnus_> roconnor, I was trying to convey that the "leakiness" I see in Haskell is on a completely different level than in e.g. C
01:18:25 <roconnor> yep, It does seem that way.
01:18:47 <roconnor> My concern is that I'm lying when I say haskell doesn't make any space/time guarentees
01:18:55 <magnus_> roconnor, so then I'm not completely daft after all
01:19:12 <agnokapathetic> well i'm off to bed, thanks all for the help. today i've discovered a powerful language, and a wonderful community to make it ever more so.
01:19:18 <agnokapathetic> goodnight
01:19:22 <dmwit> agnokapathetic: See you! =)
01:19:24 <roconnor> If haskell '98 says that haskell needs to not repeat computations, then it is saying something about space/time guarentees
01:19:43 <dmwit> roconnor: Well, at the very least, the docs for some of the libraries give time constraints.
01:19:46 <magnus_> roconnor, yes, but it wouldn't say _much_ about it
01:20:03 <dmwit> Can they really give these restraints if the standard does not give implementation details about constraints?
01:20:14 <mcp> can a function have more than 1 return value? I need a Bool, and if that is True, i need 3 lists. Should I return a (Bool, [], [], []) or is there a better way?
01:20:26 <roconnor> Maybe Haskell isn't a Lazy language afterall.
01:20:35 <roconnor> maybe Haskell is just a normal order language
01:20:35 <dmwit> ?info Maybe
01:20:36 <lambdabot> (Maybe)
01:20:41 <dmwit> ?src Maybe
01:20:41 <lambdabot> data Maybe a = Nothing | Just a
01:20:45 <magnus_> mcp, use Either or Maybe
01:21:10 * magnus_ sometimes feels that Haskell is a no-order language
01:21:17 <dmwit> haha
01:21:33 <dmwit> mcp: And don't bother with the Bool. ;-)
01:22:58 <oerjan> Maybe is almost like a Bool where the True case has additional data.  Either is like a Bool where both cases may have different additional data.
01:23:09 <ddarius> Haskell is a non-strict language.
01:26:18 <mcp> is there a extensive documentation for all the prelude functions somewhere?
01:27:01 <oerjan> @where prelude
01:27:02 <lambdabot> I know nothing about prelude.
01:27:08 <dmwit> ?src Prelude
01:27:08 <lambdabot> Source not found. I feel much better now.
01:27:10 <oerjan> @where standard-prelude
01:27:10 <lambdabot> I know nothing about standard-prelude.
01:27:15 <dmwit> ?go haskell prelude
01:27:17 <oerjan> @source Prelude
01:27:17 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
01:27:17 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
01:27:18 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
01:27:45 <oerjan> @where+ prelude http://www.haskell.org/onlinereport/standard-prelude.html
01:27:46 <lambdabot> Done.
01:27:57 <oerjan> @where+ standard-prelude http://www.haskell.org/onlinereport/standard-prelude.html
01:27:57 <lambdabot> Done.
01:28:18 <oerjan> @docs Prelude
01:28:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
01:28:40 <dmwit> Whoa, the Prelude is pretty long.
01:29:15 <oerjan> for the instances, you may also need to read the chapter on builtin classes
01:29:24 <dmwit> mcp: You probably want the Haddock docs there, I find those the nicest.
01:32:07 <oerjan> @instances-importing Control.Monad.Error MonadError
01:32:09 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
01:40:01 <mcp> I still dont get it. I want a Function, that finds the first occurence of a substring. If found, splits my string into 3 parts, return False otherwise.  Example: find "sub" in "presubpost" should return "pre" "sub" and "post".  What should the function type-declaration look like?
01:40:39 <dmwit> find :: String -> String -> Maybe (String, String, String)
01:40:47 <sjanssen> mcp: you don't want it to return False, you want it to return Nothing
01:41:15 <mcp> thanks
01:41:40 <sjanssen> 'Maybe' is for operations that might fail to yield a result sometimes
01:42:09 <sjanssen> 'Just x' indicates success, 'x' being the result
01:42:19 <sjanssen> 'Nothin' indicates failure and no result
01:42:35 <sjanssen> Nothing
01:42:58 <dmwit> mcp: When you succeed, we'll start propogandizing you into using more general monads than Maybe. ;-)
01:44:38 <oerjan> lists instead of Maybe might be nice in some cases, since you could then list splits for _all_ substrings
01:45:01 <oerjan> *all occurences
01:45:03 <dmwit> Bam!
01:45:08 <dmwit> Here comes the propoganda.
01:45:10 <dmwit> =D
01:45:32 <oerjan> you mean i should have waited until he got Maybe working? >:)
01:45:51 <mcp> hey, i understand lists (a bit at least)
01:46:36 <dmwit> Well, then think of Maybe as being a zero- or one-element list.
01:46:43 <mcp> but i plan a recursive function, so i dont need everything split up at once
01:46:46 <dmwit> Nothing is the zero-element list, (Just x) is the one-element list.
01:48:50 <dmwit> mcp: In the end, it will probably be more idiomatic to generate the list of all splits, then map or fold over them.
01:49:26 <oerjan> although, then you get the question of what to do with overlapping occurences...
01:49:36 <dmwit> mmm
01:50:00 <oerjan> in fact there are really two different ways of using lists floating around here
01:51:09 <oerjan> one is the ReadS way, where each list element handles just splitting the _whole_ string by one occurence
01:51:17 <oerjan> the other is the words/lines way
01:51:51 <oerjan> now if you defined a suitable tree data structure you might combine them >:)
01:53:48 <oerjan> i suspect the real use case doesn't need anything so hairy, though
01:53:57 <dmwit> yeah
02:17:54 <hpaste>  mcp_ pasted "strsplit" at http://hpaste.org/3279
02:18:58 <mcp> I have trouble using my Maybe result now (of course). Can someone look at my paste and tell me haskell code that could replace my comment?
02:21:11 <oerjan> fmap (str:) $ split_by strs substr
02:21:33 <oerjan> this will work for the Nothing case too
02:21:52 <oerjan> er, wait
02:21:56 <mcp> oerjan, hmm. thats somewhat different from what i expected :o
02:22:05 <oerjan> forgot it's a triple
02:22:41 <oerjan> fmap (\(b,s,a) -> (str:b,s,a)) $ split_by strs substr
02:23:34 <oerjan> also, you need a Just in the first case
02:24:47 * quicksilver fires off some sunday morning anti-lazy-IO invective to the cafe
02:24:52 <mcp> oerjan, looks interesting, thanks, I'll try to find out how this code works.
02:37:10 <_ry> http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html haskell class at caltech
02:37:13 <lambdabot> Title: CS 11: Haskell track, http://tinyurl.com/3y5tud
02:38:14 <dmwit> heh
02:38:24 <dmwit> "Despite this, people have written real applications in Haskell."
02:38:30 <dmwit> We have overcome the language!
02:39:49 <Tac-Tics> They should take the cover of the defacto Compiler text,  "the Dragon Book", and use it for Haskell.
02:40:00 <Tac-Tics> Haskell is much more trecherous
02:40:35 <kaol> don't they count ghc as a real application?
02:40:56 <Tac-Tics> An application is real only when it's usage is real
02:41:07 <Tac-Tics> So the "realness" of GHC is bottom
02:41:36 <Tac-Tics> real(ghc) = real(haskell) = real(ghc) = ...
02:42:12 <dmwit> Wow, they use the Gentle Intro as their reader.
02:42:21 <dmwit> caltech++
02:43:16 <_ry> it seems like a nice class
02:43:23 <_ry> i'm going to follow the exercises :)
02:43:31 <olsner> "Despite the name, it's not that gentle (except perhaps in the sense that Ex-Lax is gentle) ..."
02:43:51 <dmwit> Where's that from?
02:43:57 <dmwit> It's a nice quote. =)(
02:44:02 <dmwit> s/(//
02:44:13 <_ry> this week the exercise was "Define an infinite list of factorials called factorials using the zipWith function" in a one-liner
02:45:07 <dmwit> zipWith
02:45:07 <dmwit> ?
02:45:20 <Tac-Tics> :t zipWith
02:45:22 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
02:45:27 <olsner> dmwit: right where it says that gentle introduction is the primary reference
02:45:30 <kaol> @src zipWith
02:45:30 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
02:45:30 <lambdabot> zipWith _ _      _      = []
02:45:42 <olsner> @src zipWith factorial
02:45:42 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:45:58 <Tac-Tics> @src zipWith
02:45:58 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
02:45:59 <lambdabot> zipWith _ _      _      = []
02:46:08 <olsner> aww, no library of one-liners in lambdabot?
02:47:18 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3280
02:47:18 <olsner> > let fac = zipWith (*) [1..] (1:fac) in take 7 fac
02:47:20 <lambdabot>  [1,2,6,24,120,720,5040]
02:47:28 <_ry> solituon http://hpaste.org/3280
02:47:32 <_ry> solution
02:47:37 <Tac-Tics> @let facts = zipWith (*) [1..] (1 : tail facts)
02:47:41 <lambdabot> Defined.
02:47:52 <olsner> > show facts
02:47:53 <lambdabot>  Exception: stack overflow
02:48:00 <Tac-Tics> sadness
02:48:02 <olsner> lambdabot knows too much!
02:48:20 <dmwit> > take 5 facts
02:48:22 <lambdabot>  Exception: stack overflow
02:48:33 <dmwit> > take 1 facts -- ?
02:48:35 <lambdabot>  [1]
02:48:51 <olsner> (1 : tail facts)
02:48:57 <dmwit> quite
02:49:15 <Tac-Tics> it was a close attempt
02:49:16 <dmwit> It just took me a few seconds longer than usual. =/
02:49:17 <olsner> @let facts = zipWith (*) [1..] (1 : facts)
02:49:17 <lambdabot> <local>:11:0:     Multiple declarations of `L.facts'     Declared at: <local>...
02:49:55 <_ry> olsner: it should include the 0th factorial
02:49:55 <dmwit> > fix (\x -> zipWith (*) [1..] (1 : x))
02:49:57 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
02:50:10 <_ry> i.e. it should be 1, 1, 2, 6..
02:50:35 <Tac-Tics> @let facts = 1 : (zipWith (*) [1..] (1 : tail facts))
02:50:36 <lambdabot> <local>:11:0:     Multiple declarations of `L.facts'     Declared at: <local>...
02:50:47 <dmwit> You'd have to ?unlet first.
02:50:53 <Tac-Tics> @let tacFacts = zipWith (*) [1..] (1 : tail tacFacts)
02:50:56 <lambdabot> Defined.
02:51:01 <Tac-Tics> > take 10 tacFacts
02:51:02 <lambdabot>  Exception: stack overflow
02:51:06 <Tac-Tics> bah
02:51:07 <Tac-Tics> heh
02:51:10 <olsner> Tac-Tics: same error! :P
02:51:36 <_ry> @let ryFacts = 1:zipWith (*) [1..] ryFacts
02:51:37 <Tac-Tics> Haskell can handle infinite lists, but not infinite stacks =-(
02:51:41 <lambdabot> Defined.
02:51:58 <_ry> wow, lambdabot is cool :)
02:52:04 <olsner> > take 5 ryFacts
02:52:05 <lambdabot>  [1,1,2,6,24]
02:52:38 <dmwit> > take 5 $ scanl' (*) 1 [1..]
02:52:39 <lambdabot>   Not in scope: `scanl''
02:52:45 <dmwit> > take 5 $ scanl (*) 1 [1..]
02:52:47 <lambdabot>  [1,1,2,6,24]
02:54:14 <dmwit> > let factorial n = product [1..n]; double_factorial = product . map factorial in double_factorial 3
02:54:16 <lambdabot>   add an instance declaration for (Num [a])
02:54:41 <dmwit> > let factorial n = product [1..n]; double_factorial = product . map factorial . enumFromTo 1 in double_factorial 3
02:54:42 <lambdabot>  12
02:55:25 <dmwit> > take 5 . scanl (*) 1 . scanl (*) 1 $ [1..]
02:55:27 <lambdabot>  [1,1,1,2,12]
02:56:07 <Tac-Tics> Find inf{x | x is a Haskell function for Factorial} using the ordering x <= y iff x is less or equally obfuscated than y
02:56:37 <dmwit> fact n = product [1..n] -- winner!
02:56:43 <Tac-Tics> hurray
02:56:53 <thepointer> can i do something like type Cardinal = Integer | String
02:56:54 <thepointer> ?
02:56:59 <dmwit> newp
02:57:10 <thepointer> :(
02:57:11 <dmwit> How about type Cardinal = Either Integer String ?
02:57:18 <Tac-Tics> I was going to say sup{...}, but I think the reality is that obfuscation knows no upper bounds
02:57:43 <dmwit> thepointer: What are you trying to achieve?
02:57:51 <thepointer> hrm, either looks like it could be good
02:57:57 <dmwit> ok
02:58:20 <thepointer> im writing an assembler.. using an ebnf as a guide
02:58:53 <dmwit> Oh, cool!
03:02:25 <kolmodin_> saying :b Module in ghc 6.9 says: module 'Module' is not interpreted. why?
03:02:38 <kolmodin_> in 6.6 you could browse compiled modules
03:03:05 <dmwit> kolmodin_: I don't... I've seen that error before, and I've never used anything newer than 6.6.
03:03:11 <Baughn> Tac-Tics: Indeed. You could do it in trinary at compile time using the type system, for exampe
03:03:33 <dmwit> in trinary
03:03:36 * dmwit whimpers
03:03:49 <Baughn> Would you prefer 1.5-ary?
03:03:54 <kolmodin_> dmwit: it works for me in ghc 6.6, always have. but not in ghc 6.9
03:04:07 <dmwit> pi-ary
03:04:57 <Igloo> kolmodin_: Use :browse
03:05:04 <Igloo> :b is :break now
03:05:40 <kolmodin_> Igloo: ah, thanks :D
03:05:48 * dmwit wonders if pi-ary arithmetic is even doable (by humans, with no aid, and only their own determination to keep them going) in the type system.
03:07:14 * Baughn would like to point out that 1 is an infinite nonrepeating decimal in pi-ary representation
03:08:00 <dmwit> Right.
03:08:02 <dmwit> Tricky.
03:08:09 <Baughn> ..hmm. Actually, not 1. Every whole number /but/ 1, 0 or -1, but not those.
03:09:39 <Tac-Tics> 1 is 1 in every radix
03:09:44 * roconnor looked in to phi-ary arithmetic once
03:09:57 <roconnor> phi^2-ary arithmetic has some nice properties
03:09:59 <Tac-Tics> 0 radix is cool
03:10:15 <Baughn> ...that makes no sense
03:10:31 <roconnor> phi^2-ary arithmetic plays like a game of atoms if I recall correctly
03:10:38 <Tac-Tics> yeah it does, it just requires an infinite number of distinct digits
03:11:15 <dmwit> Uh, surely that's "infinity radix"?
03:11:30 <Baughn> Should be
03:11:48 <Tac-Tics> hmm, I did this a long long time ago, so yeah
03:11:55 <Baughn> With radix 0, any /finite/ number is 0
03:12:15 <Tac-Tics> I wrote a program in my TI83+ in high school to print out numbers in different radixes
03:12:32 <Tac-Tics> it was the second coolest thing I ever did with it
03:13:07 <Tac-Tics> TI83 basic is hard stuff
03:13:20 <dmwit> ugh
03:13:21 <dmwit> yes
03:13:31 <Baughn> Though mostly due to the "keyboard
03:13:45 <dmwit> Z80 is pretty nice, though. =)
03:14:33 <Tac-Tics> I wrote a clone of a game called Lights Out (a kind of tetris)... but since there were no subroutines in BASIC, each "subroutine" had to occupy a different file (there are primitives for call and return on other files for some reason?)
03:14:57 <Tac-Tics> the game took something like 20 files, it was kinda rediculous
03:15:06 <Baughn> Tac-Tics: Actually, basic does have gosub
03:15:15 <dmwit> *and* it ran slow as balls, and the screen flashed while it was updating.  amirite? =P
03:15:19 <Baughn> OTOH, it /only/ has global variables... the insanity
03:15:28 <Tac-Tics> Baughn, I mean on the TI83+
03:15:40 <Baughn> Tac-Tics: That wasn't basic, then. There /are/ standards.
03:15:56 <dmwit> Baughn: Oh, no, the TI83+ language is *far* below BASIC.
03:15:59 <Tac-Tics> BASIC is a generic word for a shitty toy programming language =-P
03:16:08 <Baughn> dmwit: So I gather
03:16:08 <Tac-Tics> Don't let microsoft fool you
03:16:27 <Tac-Tics> I can write a Basic language in Haskell and still call it BASIC, because I'm stubborn like that
03:16:48 <Baughn> Well, just because you ignore standards...
03:17:00 <Baughn> Oh. By the way, if you do that, I'll have to hurt you.
03:17:08 <Tac-Tics> call the standards police on me, why don't you?
03:17:18 <Tac-Tics> The original programmers of basic are probably getting ready to die anyway
03:17:33 <Baughn> You cannot be allowed to pollute our precious bodily fluids with /any/ variant of basic
03:18:10 <Tac-Tics> Fine then, I'm going to write My OWN standard for basic. With blackjack. And strippers.... in fact, forget the standard!
03:18:43 <dmwit> hq9+sb -- hq9+, now with strippers and blackjack!
03:19:09 <Tac-Tics> http://tatay.kenosha.wi.us/TiBasic/
03:22:27 <roderyk> I'm trying to learn haskell and I need to do some html scraping. Using tagsoup, I get the following: > liftM parseTags ( readFile "1.html" ) => .... some output ... * Exception: Maybe.fromJust: Nothing
03:23:32 <roderyk> Any ideas? is it due to bad html or some memory limit on output?
03:24:25 <Lemmih> bad html.
03:24:32 <thepointer> dmwit, i'm stuck :(. i don't know how i should store {operand ::= "(" value ")" | "#" value | value.} (ebnf)
03:24:49 <thepointer> if i used data, i'd need seperate constructors for each case which would seem ugly
03:25:22 <thepointer> and type doesnt like having | in it
03:25:47 <thepointer> something like either could be good, except either only takes 2 things.
03:25:55 <dmwit> thepointer: I really don't understand what you have against data.
03:26:17 <dmwit> thepointer: Anyway, there's only one constructor here, no?  Just three different ways to evaluate "value"?
03:26:49 <Tela> I want to try running simulated annealing in Haskell. Anyone think this might be crazy? I'm worried about space problems and huge amounts of state.
03:28:07 <mcp> 30 minutes ago, i asked how to use the Maybe values. oerjan suggested a solution with fmap, which seemed to be elegant, but i was not able to get it compiled. http://hpaste.org/3281 is what i got compiled. It is very ugly, of course. Im asking for suggestions to make it less ugly (especially I'd like to remote the /= Nothing parts).
03:28:53 <Baughn> Tela: Haskell is perfectly capable of handling state, even mutable state. Data.Map is almost as fast as the mutable variant would be, and there's always STArray
03:29:00 <dibblego> > fmap (+1) (Just 7)
03:29:05 <lambdabot>  Just 8
03:29:09 <dibblego> > fmap (+1) Nothing
03:29:10 <lambdabot>  Nothing
03:29:18 <dibblego> ?type fmap
03:29:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:29:40 <dibblego> ?check \f -> fmap f Nothing == Nothing
03:29:41 <lambdabot>  Add a type signature
03:29:49 <dibblego> ?check \f -> fmap (f :: Int -> Int) Nothing == Nothing
03:29:50 <lambdabot>  OK, passed 500 tests.
03:30:12 <Baughn> dibblego: Just think of it as "generic" map, with Functor being "things that can be mapped on"
03:30:29 <dibblego> Baughn, I'm demonstrating for mcp
03:30:32 <Baughn> Ah.
03:31:16 <mcp> dibblego,  that was supposed to enligten me? did not
03:31:18 <Baughn> > do { a <- Just 2; b <- Nothing; return (a+b)}
03:31:20 <lambdabot>  Nothing
03:31:20 <dibblego> I explained fmap in a Scala course I ran a couple of weeks ago; it seemed to work
03:31:30 <dibblego> mcp, do you understand what fmap does?
03:31:43 <thepointer> dmwit, what do you think about something like data Operand = (Maybe (Either "(" "#")), Value, Maybe ")")
03:31:50 <dmwit> thepointer: NO
03:31:56 <mcp> dibblego, no, is this the only way to improve my code?
03:32:16 <thepointer> im sure im really thinking about all this in the wrong way
03:32:18 <Tela> Baughn: STArray is good. I'm really not that familiar with how to make Haskell run quickly, in general, and I have a feeling that this problem is going to really push it.
03:32:21 <thepointer> its frustrating :(
03:32:21 <dibblego> mcp, I haven't really looked at your code, but I'd rather help you understand fmap; do you understand map?
03:32:29 <dmwit> thepointer: First of all, "(" and "#" aren't types, so Either "(" "#" doesn't make sense at all.
03:32:36 <mcp> dibblego, no, my 2nd day on haskell
03:32:36 <dibblego> mcp, that way, you can decide if it is suitable for your problem
03:32:47 <dibblego> mcp, ok, so you've not yet seen map for lists?
03:32:56 <dibblego> like this:
03:33:00 <dibblego> > map (+1) [1..5]
03:33:01 <dmwit> thepointer: "data" declares a new data *type*, not a new data *value*.
03:33:02 <lambdabot>  [2,3,4,5,6]
03:33:26 <dibblego> map applies a function to each element of a list
03:33:29 <dibblego> ?type map
03:33:31 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:33:42 <Baughn> Tela: It almost certainly won't be *quite* as fast as in some other languages. It will, however, be a lot shorter.
03:33:54 <thepointer> hrm, so i'd perhaps want something like data Operand = (Maybe Symbol, Value, Maybe Symbol)
03:33:58 <dmwit> thepointer: I'm going to bed soon, but if you hpaste some of your code, I'm sure other people here will be able to point you in good directions.
03:33:59 <Tac-Tics> @let square x = x * x
03:34:00 <dmwit> ?hpaste
03:34:03 <dibblego> apply the function (of type a -> b) to the list (of type [a]) and produce a list (of type [b])
03:34:04 <lambdabot> Defined.
03:34:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:34:05 <Tac-Tics> > map square [1..5]
03:34:06 <lambdabot>  [1,4,9,16,25]
03:34:11 <Baughn> Tela: If that means being able to use algorithms you couldn't use in other languages, such as parallelism, then it'll be faster
03:34:24 <dibblego> ?type square
03:34:26 <lambdabot> Not in scope: `square'
03:34:29 <dibblego> ?type L.square
03:34:31 <lambdabot> Couldn't find qualified module.
03:34:34 <dibblego> bleh
03:34:42 <thepointer> okay, well helps for your help anyway, have a good evening dmwit
03:34:52 <Tela> Baughn: I'm considering that, though I'm not yet sure if I can work a parallel algorithm for SA
03:34:54 <Tac-Tics> square :: Num a => a -> a
03:35:09 <dibblego> \?type map square :)
03:35:20 <Tac-Tics> :t map square
03:35:22 <lambdabot> Not in scope: `square'
03:35:25 <Tac-Tics> bah
03:35:29 <dibblego> map square :: (Num a) => [a] -> [a]
03:35:41 <Baughn> Tela: I've yet to run into a problem that can't be parallelised, but you may need to write an entirely new algorithm to do it
03:35:52 <dibblego> mcp disappeared anywho
03:35:59 <mcp> na
03:36:02 * Baughn would, at this point, like to point out that the human brain runs at 200Hz
03:36:02 <mcp> still there
03:36:05 <mcp> just confused
03:36:19 <dibblego> mcp, do you understand the list map function at all or have you covered it?
03:36:41 <Tela> Baughn: I may just. The difficulty comes in that you need to calculate values based on the state of the entire system at each iteration, which makes the problem very... interesting :)
03:36:47 <mcp> dibblego, i think i got what map does, i just dont see how that will help me
03:37:04 <Baughn> mcp: Repeating what I for some reason told dibblego earlier, you can think of fmap as "generic" map, with Functor being "things that can be mapped on". Maybe is one such thing.
03:37:37 <Baughn> mcp: It will take all items in a container, run a function on them, and put them back. Maybe is a container with 0 or 1 elements.
03:37:43 <Tac-Tics> mcp: fmap turns a function from stuff to things into a function from boxes of stuff to boxes of things
03:38:04 <Baughn> Tela: No doubt, but that just means you need a lot of communication. SMP should work
03:38:11 <xerox> without changing the shape of the box
03:38:13 <dibblego> someone should think of a new word for "box" that starts with 'm'
03:38:23 <Baughn> Tela: And the immutability of haskell values makes a lot of things easier. :)
03:38:24 <EvilTerran> milk crate!
03:38:26 <dmwit> mbox
03:38:29 <xerox> dibblego: what about monad? (:
03:38:37 <dibblego> xerox, nooooo!! :)
03:38:51 <dibblego> a fuzzy word :)
03:39:02 <Tac-Tics> monads are the kind of box you can fall into but can't always get back out of
03:39:11 <Tela> Baughn: I'm sure I'll be playing with it for a while... :D
03:39:16 <Baughn> mo..o..ney? Yes, a mooney.
03:40:25 <dibblego> money box
03:40:54 <xerox> mob
03:40:54 <Tac-Tics> mcp: The problem with map in Haskell is it only works on lists. But the idea behind map (running a function over several inputs and collecting the outputs) works for Sets and Multisets, and Maybes (which can be thought of as lists of length 0 or 1), etc.
03:41:19 <Tac-Tics> and Trees
03:41:46 * Baughn once thought the name "mob" meant that they were actually, well, mobs. As opposed to mobiles.
03:41:55 <Tac-Tics> What other cool functors are there?
03:42:00 <dibblego> ?instances Functor
03:42:02 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:42:13 <Tac-Tics> that list is frightening
03:42:23 <Baughn> Especially the second element
03:42:49 <Tac-Tics> "Functions from r"?
03:42:57 <EvilTerran> ah, a function a->b's just a container of bs indexed by as!
03:43:12 <Baughn> ...
03:43:16 <dibblego> mcp, certainly, code like you have can  be written using a foldr and map is one specific implementation of foldr
03:43:22 <Baughn> And where do the as come from, with fmap?
03:43:26 <Tac-Tics> could ((->)R).fmap just be (.)?
03:43:34 <EvilTerran> @src (->) fmap
03:43:34 <lambdabot> fmap = (.)
03:43:39 <EvilTerran> You win! :D
03:43:39 <Tac-Tics> sweet!
03:43:52 <Baughn> ...my aching head
03:43:56 <xerox> Tac-Tics: some suggest to have that definition the other way around :)
03:44:21 <Tac-Tics> that the definition of (.) be fmap?
03:45:27 <Tac-Tics> Vectors, Matricies, and Tensors are all functors too
03:45:39 <Tac-Tics> those are kinda neat ones
03:47:48 <Tac-Tics> Functors are neat, because if you know how to, for example, conquer a country... call it function conquer, given any arbitrary list of countries, you can conquer them all!
03:48:20 <Baughn> No.. it'll just make new, conquered countries
03:48:29 <Baughn> The old ones will still be there
03:48:54 <Tac-Tics> if you had an in-place version of map... damn you haskell! Your purity is both your making and un-
03:49:20 <Baughn> Also, considering laziness, chances are the countries will get conquered in a just-in-time manner when you visit them
03:50:07 <Tac-Tics> @src State.fmap
03:50:07 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:50:13 <hpaste>  dmwit pasted "HQ9+" at http://hpaste.org/3282
03:50:26 <Tac-Tics> @src Control.Monad.State.fmap
03:50:26 <lambdabot> Source not found. Take a stress pill and think things over.
03:50:31 <Tac-Tics> damn lambdabot
03:50:42 * Baughn notes that time travel becomes perfectly reasonable if you assume that physics works via lazy evaluation. Though you get <<LOOP>> a lot.
03:51:44 * dmwit wonders if the accumulator is ever *actually* incremented in this implementation.
03:51:48 <Tac-Tics> does time traveling have a least fixpoint?
03:52:10 <Baughn> Tac-Tics: fmap is an instance function. It doesn't exactly /have/ source code.
03:52:37 <Tac-Tics> is the source magical or something?
03:52:50 <Tac-Tics> or does it resolve to another name in State?
03:52:53 <Baughn> No, just distributed. The instances have source.
03:52:57 <dmwit> ?src State fmap
03:52:57 <lambdabot> Source not found. My mind is going. I can feel it.
03:53:08 <dmwit> ?src [] fmap
03:53:09 <lambdabot> fmap = map
03:53:18 <Baughn> ?src Maybe fmap
03:53:19 <lambdabot> fmap _ Nothing       = Nothing
03:53:19 <lambdabot> fmap f (Just a)      = Just (f a)
03:53:28 <Baughn> Tac-Tics: See?
03:54:36 <Tac-Tics> @let cool = do x <- get; put $ x + 4; return $ x + 2
03:54:37 <lambdabot> <local>:14:20:     Ambiguous type variables `a', `m' in the constraint:      ...
03:54:49 <Tac-Tics> @let cool = do x <- get; put $ x + 4; return $ x + 2 :: State Int Int
03:54:54 <lambdabot> Defined.
03:55:35 <Tac-Tics> @let awesome = fmap (\x -> x * 10) cool
03:55:40 <dmwit> fmap f x = x >>= return . f = liftM f x
03:55:41 <lambdabot> Defined.
03:55:53 <Tac-Tics> > runState cool 5
03:55:54 <lambdabot>  (7,9)
03:55:57 <Tac-Tics> > runState awesome 5
03:56:00 <lambdabot>  (70,9)
03:56:00 <Baughn> @let awesome = fmap (* 10) cool
03:56:01 <lambdabot> <local>:16:0:     Multiple declarations of `L.awesome'     Declared at: <loca...
03:56:15 <Baughn> ..what, no redefinitions?
03:56:18 <dmwit> nope
03:56:26 <Baughn> Seriously?
03:56:30 <dmwit> You have to ?unlet first, which destroyes *all* previous ?lets.
03:56:44 <Baughn> Oh, that's not nice
03:56:49 <dmwit> =)
03:56:56 <Tac-Tics> I once did that on accident when lots of people were using @let
03:57:06 <Tac-Tics> I wish ?unlet would just unlet your personal definitions...
03:57:30 <Tac-Tics> does fmap on State just apply the function to the final state then?
03:58:29 <ndm> Vimal?
03:59:39 <dmwit> Tac-Tics: yes
03:59:56 <dmwit> err... no
04:00:06 <Tac-Tics> the docs don't really say what a lot of things do
04:00:09 <dmwit> fmap doesn't affect the state.
04:00:17 <dmwit> It affects the "return" value.
04:00:24 <Tac-Tics> ah, whoops
04:00:32 <Tac-Tics> > evalState awesome 5
04:00:34 <lambdabot>  70
04:00:36 <Tac-Tics> ok
04:01:12 <Tac-Tics> I'm not even going to bothering asking what fmap would do with Cont
04:04:50 <dmwit> Tac-Tics: fmap generally doesn't do much other than affect the return value.
04:05:00 <stef_> anyone here read Hughes article on "Why functional programming matters?" ?
04:05:44 <dmwit> stef_: No, but do you have a specific question?
04:05:58 <stef_> dmwit: Yes I have specific questions regarding the article
04:06:08 <Tela> Besides where they reside, is there any difference between IO(U)Array and ST(U)Array?
04:06:39 <ndm> stef_: yes
04:06:47 <ndm> but not for a couple of years
04:07:00 <dmwit> Tela: (U) is unboxed.
04:07:17 <dmwit> (It's the first sentence in the docs for them, respectively...)
04:07:22 <stef_> ndm: what years ?
04:07:24 <dmwit> stef_: Ask away.
04:07:34 <ndm> stef_: i read it a few years ago
04:07:55 <ndm> btw, everyone _should_ read that article
04:08:22 <Tela> dmwit the IO versus ST distinction is insignificant, though?
04:08:35 <ndm> it would be nice if someone translated the examples into Haskell and spun a new PDF of it
04:09:11 <dmwit> Tela: No, I think the ST monad is somehow pure.
04:09:17 <stef_> ndm: nice :)
04:09:22 <dmwit> I've never used it myself, but that's the idea.
04:10:07 <ndm> ST monad is pure
04:10:22 <ndm> you can make side effects, but they can't escape the runST function
04:11:22 <Tela> I see
04:13:13 <Baughn> Tela: The ST monad doesn't really optimize anything, nor is it fundamentally different from just threading the values on your own. STArray is a different matter..
04:13:17 <Tac-Tics> Impurity: There is no escape...
04:13:46 <stef_> I'm really pretty much surprised of haskell
04:13:47 <stef_> ?
04:13:57 <stef_> I think that one needs to figgure out the programs on paper
04:14:02 <Baughn> ?src State (>>=)
04:14:03 <lambdabot> Source not found. Are you on drugs?
04:14:12 <stef_> I don't think that I could write haskell dirrectly on my editor
04:14:19 <stef_> I would really need to first think them on paper
04:14:25 <stef_> I mean it's not really simple
04:14:37 <stef_> and I wonder what really happens behind haskell ...
04:14:37 <Tac-Tics> there's nothing like ghci for working out Haskell problems
04:14:50 <stef_> Tac-Tics: what's ghci ?
04:14:59 <ndm> stef_: its not too hard once you are more experienced
04:15:00 <Tac-Tics> ghci is GHC's command line evaluator
04:15:01 <Tela> Baughn, STArray uses continuous blocks of memory?
04:15:05 <ndm> stef_: do you use Hugs or GHC?
04:15:16 <Baughn> Tela: Probably
04:15:18 <Tac-Tics> it's really really cool
04:15:39 <Tac-Tics> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html#id3103922
04:15:41 <lambdabot> Title: Chapter 3. Using GHCi, http://tinyurl.com/y6xlby
04:15:55 <stef_> ndm: at the moment I'm just reading about haskell and am amazed by it
04:16:12 <stef_> ndm: I have hugs installed but am afraid to use any haskell compiler yet ...
04:16:21 <Tac-Tics> Haskell is by far the most amazing programming language ever
04:16:42 <stef_> Tac-Tics: I'm pretty sure if you'd be in #lisp you would say something else ...
04:16:53 <Tac-Tics> stef_: most of the ghci functionality is also available from our friend lambdabot
04:16:58 <ndm> stef_: Windows or Linux?
04:17:02 <stef_> ndm: debian
04:17:36 <ndm> stef_: Hugs is not a compiler, its an interpretter - so just type in hugs, then do something like "1+2" and you can see Haskell in action
04:18:01 <Tac-Tics> Lisp is great too. But only because of macros and the eval function
04:18:17 <Tac-Tics> Haskell is pure, and purity gives you so many new ideas to play with
04:18:53 <stef_> Tac-Tics: I don't get the difference between lisp and haskell,altough I have asked several times this question in the channel
04:19:00 <Tac-Tics> ah
04:19:06 <Tac-Tics> They are very very different
04:19:19 <stef_> ndm: ok , I think programming in haskell is a bit like dijkstra built his programs,carefully analaysing them on paper etc
04:19:50 <Tac-Tics> Lisp is dynamically typed and all type checking is done at runtime. Haskell is strongly typed and 99% of checking is done at compile time
04:20:13 <ndm> stef_: you can do it that way, but once you have more experience, you can start doing it directly like you can with C - a little bit of high-level design then hacking
04:20:13 <Tac-Tics> Lisp is strict. All arguments to a functions are evaluated in order. Haskell is lazy, nothing is evaluated unless needed
04:21:09 <Tac-Tics> Lisp is pure. You can do IO at the same time as anything else. In Haskell, there is a clear division of IO and pure functions
04:21:25 <ndm> lazy evaluation gives you a lot of what you might want from macros
04:21:31 <stef_> ndm: what article should I next read on haskell ?
04:21:47 <stef_> ndm: I don't really know what macros are
04:21:56 <ndm> stef_: an introductory tutorial, Yet Another Haskell Tutorial is meant to be quite good
04:22:06 <ndm> if you have Graham Hutton's book thats also good
04:22:21 <ndm> stef_: then forget we mentioned macros,its not important
04:24:11 <stef_> I read about the first 4 chapters from "Practical LISP" and now I'm a bit confused if I want to learn haskell or lisp
04:24:17 <Tac-Tics> > do x <- [1..3]; y <- ['a'..'c']; return (x, y)
04:24:19 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
04:24:42 <Tac-Tics> Haskell has a much steeper learning curve
04:24:57 <Tac-Tics> But imo it is more interesting
04:25:03 <Tac-Tics> but it's best to know at least a bit of both
04:25:30 <Tac-Tics> Lisp is also a pain in the butt to read
04:25:46 <sieni> no it's not
04:26:01 <ndm> to me, the type system means Haskell wins by a long way
04:26:01 <Tac-Tics> sieni, it's a pain in my butt to read lisp
04:26:11 <ndm> and the clarity of syntax is also a big help
04:26:31 <sieni> Tac-Tics: you just haven't reached the lisp enlightenment :-)'
04:26:40 <Tac-Tics> Lisp is very hard to verify by hand
04:26:42 <stef_> Tac-Tics: I'd do that in perl by doing    any(1..3).all('a'..'c')
04:26:43 <Tac-Tics> matching those parens
04:27:20 <sieni> naturally you need a lisp friendly editor
04:28:23 <Tac-Tics> Not all of us have those sieni ;-)
04:28:31 <ndm> lisp always felt to me that it was optimised for a computer, while Haskell is optimised for a human - in terms of syntax
04:29:44 <Tac-Tics> > do x <- [1..3]; y <- [1..3]; guard (x /= y); return (x, y)
04:29:46 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
04:30:03 <Tac-Tics> all pairs of [1..3] not along a diagonal
04:30:36 <yitz> > [(x,y) | x <- [1..3], y <- [1..3], x /= y]
04:30:38 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
04:31:18 <Tac-Tics> > filterM (const [False, True]) [1..3]
04:31:19 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
04:31:23 <Tac-Tics> the powerset
04:31:58 <Tac-Tics> @let power = filterM (const [False, True])
04:32:03 <Tac-Tics> > power "abc"
04:32:04 <lambdabot> Defined.
04:32:05 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
04:32:12 <profmakx> has anyone implemented generating strict partitions of natural numbers with haskell?
04:36:52 <Tac-Tics> Of course, one could always write a lazy lisp that did many of the cool things haskell does
04:37:22 <Tac-Tics> just not the typing
04:40:18 <Baughn> Or even /with/ the typing
04:44:51 <byorgey> profmakx: what do you mean by "strict" partitions?
04:45:23 <gour> seeing redmine tracker (http://redmine.org) with darcs sšš
04:45:25 <lambdabot> Title: Redmine - Overview - Redmine
04:45:42 <gour> *support, it methinks it would be nice to have such thing in haskell
04:46:14 <gour> ahh, fingers and keyboard out of sync :-(
04:46:50 <profmakx> byorgey: a strict partition of a natural number n ist a sum a_1...a_k such that sum a_1...a_k equals n and a_1 > a_2 ... > a_k
04:48:06 <desegnis> profmakx: is k constant?
04:48:23 <profmakx> well for one partition it is ;)
04:48:31 <profmakx> if you generate all strict partitions its not
04:48:40 <desegnis> right
04:49:02 <byorgey> profmakx: so, e.g. strict partitions of 6 would be 5 + 1, 4 + 2, and 3 + 2 + 1?
04:49:05 <profmakx> i just wondered if it has been done because those list games are played here quite often ;)
04:49:10 <profmakx> right byorgey
04:52:28 <kosmikus> can the still relatively new behaviour in ghc since 6.6, to automatically print the result of IO actions, be turned off?
04:53:03 <desegnis> kosmikus, :set -fno-print-bind-result
04:55:13 <hpaste>  byorgey pasted "strict integer partitions" at http://hpaste.org/3283
04:55:25 <kosmikus> desegnis: thanks
04:55:27 <kosmikus> desegnis++
04:55:29 <byorgey> profmakx: ^^ how's that? =)
04:58:37 <profmakx> byorgey  seems nice ;) at least for small values of n ;)
05:00:38 <profmakx> easier than i thought... i had a recursive algorithm in mind, but thought i asked before i started fiddling
05:01:38 * desegnis tried that, too, and wrote nearly exactly the same, but didn't come up with (n-s) (s-1) :-(
05:03:47 <byorgey> profmakx: what's wrong with it for large values of n?
05:04:06 <byorgey> I mean, other than the fact that there's a combinatorial explosion in the number of partitions
05:04:34 <profmakx> no there is nothing wrong
05:04:42 <profmakx> i checked manually for a few n
05:04:54 <byorgey> hm, I guess it does seem kind of slow
05:05:30 <byorgey> actually, hm, I suspect it spends too much time searching for impossible partitions
05:08:58 <profmakx> well perhaps one could do some kind of memoizing
05:09:14 <profmakx> because one calculates partitions of smaller numbers quite often
05:09:16 <fox86> what editor do you guys use for haskell?
05:09:20 <byorgey> profmakx: yes, that would probably help
05:09:55 <byorgey> you'd need an nxn table where the (j,k) entry stores the number of strict partitions of j using numbers less than or equal to k
05:10:21 <byorgey> you can also stop if j > k*(k+1) `div` 2
05:10:29 <byorgey> since in that case sum [1..k] < j
05:16:35 <mrd> fox86: typically emacs, sometimes vim
05:17:05 <fox86> mrd: do you use haskell-mode or do you customize it yourself?
05:17:44 <mrd> both
05:17:49 <mrd> hehe
05:18:07 <mrd> i tinkered with haskell-mode but i think most of my stuff is in upstream now
05:19:56 <fox86> mrd: ah okay. i can't stand the indentation in haskell-mode
05:21:48 <mrd> yea i turn on simple indent
05:22:44 <stef_> fox86: what editor are you using ?
05:22:54 <fox86> stef_: emacs
05:23:37 <stef_> fox86: so is it good for haskell ? have you ever used vim with haskell ?
05:23:53 <fox86> stef_: it's a great editor, but i don't like how it behaves with haskell
05:23:57 <Tac-Tics> I use vim and gedit for my haskell
05:24:05 <Tac-Tics> I've never had any problems
05:24:27 <hpaste>  mrd pasted "my emacs haskell config" at http://hpaste.org/3284
05:25:00 <mrd> claus reinke has some nice plugins for vim/haskell
05:25:57 <stef_> Tac-Tics: do you use some plugin for vim ? for example for perl there is perl-support,is there something similar for haskell ?
05:26:17 <Tac-Tics> not really, I'm not really one for plugins
05:26:43 <Tac-Tics> but haskell lends itself to the coolest plugins imaginable
05:26:46 <mrd> also i turn off indent-tabs-mode (set expandtab in vim)
05:27:49 <mrd> fox86: hm, my haskell config may answer your #emacs question
05:28:14 <fox86> mrd: i will give it a try
05:30:50 <fox86> mrd: aah, i think this is perfect. i think it's the tabs-stop-list i needed
05:34:27 <visof> is the monoid in category theory is monad in haskell?
05:34:40 <EvilTerran> nah, that'd be a Monoid in haskell
05:34:50 <EvilTerran> a haskell Monad is a category theory monad, too ;)
05:35:25 <EvilTerran> iirc, a monad is a monoidal applicative functor, which might explain the similarity of names slightly
05:36:34 <visof> how can the category theory help us in programming in general?
05:37:14 <EvilTerran> by providing a rigorous basis, which we can leverage to prove cool and interesting things about our programs
05:37:23 <fox86> mrd: thanks a lot!
05:38:05 <visof> EvilTerran please can you give me Example?
05:38:43 <EvilTerran> er...
05:40:12 <visof> what this mean?
05:41:24 <EvilTerran> someone help, my brain's not working right today
05:42:11 <visof> ok ,thanks
05:43:01 <EvilTerran> visof, i guess a better example of the use of these things is that it makes it possible to write functions that're very general
05:44:07 <EvilTerran> because we use the categorical idea of a monad, for instance, to do IO, state, continuations, nondeterminism, etcetc, we can have functions that can be used in any of these cases
05:44:15 <EvilTerran> because they have a Monad m => ... m a ... type
05:48:30 <hpaste>  desegnis annotated "strict integer partitions" with "Faster. Better?" at http://hpaste.org/3283#a1
05:49:08 <Orphi> does anybody know what the difference between a rank-2 type and an existential type is?
05:49:15 <Orphi> (I know I'll probably regret asking...)
05:50:01 <desegnis> (By the way, does [6] count as a strict integer partition of 6?)
05:54:13 <Saizan> Orphi: a rank2 type is almost like a CPS transform of an existential, e.g. data Showable = forall a. Show a => S a  ~~> (forall a. Show a -> r) -> r
05:54:58 <Orphi> Saizan: um... ouch.
05:55:12 <Orphi> Saizan: ok, what's CPS?
05:55:23 <Saizan> Continuation Passing Style
05:55:30 <Orphi> ...right
05:55:41 <Saizan> however a rank2 type is simply one that has an inner forall
05:56:39 <Orphi> hmm... maybe I should leave it alone.
05:56:52 <Saizan> so it forces the callback to accept anything (possibily in a class)
05:56:53 <Orphi> all I want to do is to be able to put values of different types into a list. :-S
05:57:17 <Saizan> do they share a common class?
05:57:21 <Orphi> yes
05:57:43 <Saizan> and you won't need to know the exact type afterwards?
05:57:56 <Orphi> I don't think so...
05:57:59 <Saizan> if yes an existential is fine
05:58:18 <Orphi> right. so... what's the syntax for that?
05:58:42 <Saizan> data Foo = forall a. C a => F a
05:58:46 <Saizan> where C is the class
05:59:08 <Orphi> right. so data Draw = forall x. Drawable => Draw x
05:59:24 <Saizan> yes, then you've to pack your values with Draw before you can put them in the list
05:59:40 <Orphi> ok. but then I can map drawing methods over them?
05:59:52 <Saizan> yes, you can only do that
06:00:08 <Orphi> cool.
06:01:05 <Orphi> oh - although I'll have to unpack them from Draw first, presumably
06:01:23 <EvilTerran> indeed.
06:01:28 <Orphi> ok
06:01:52 <EvilTerran> you can't just have [1 :: Int, 2::Float, 3/2::Rational] :: [forall a. Num a => a]
06:02:00 <Saizan> yes, by pattern matching, however depending on Drawable it can be handy to make an instance Drawable Draw
06:02:04 <EvilTerran> it uses the layer of constructors to work out where everything is
06:02:47 <Orphi> well, the other alternative is data Draw = Line ... | Circle ... | Square ... | ...
06:02:59 <Orphi> but not terribly extensible
06:03:12 <EvilTerran> this way you only have to pattern-match one constructor :D
06:03:39 <Orphi> Saizan: good point
06:03:59 <bringert> dons: you mentioned that you have small http implementation that we could use in cabal-install. where can I find that?
06:04:44 <Orphi> another random question: in Haskell, is it possible to determine whether an object graph contains cycles?
06:05:01 <EvilTerran> @docs Data.Graph
06:05:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
06:05:33 <Orphi> in OOP, an object has both "state" and "identity". you can tell two identical objects apart.
06:05:37 <bringert> dons: is it this: http://www.cse.unsw.edu.au/~dons/code/urlcheck/TinyHTTP.hs
06:05:47 <Orphi> in the relational model, the data *is* the identity, and you cannot tell them apart.
06:05:49 <Orphi> in Haskell...?
06:05:50 <EvilTerran> everything's immutable in haskell anyway, so we don't care about identity
06:06:02 <Saizan> in Haskell you can't
06:06:08 <Orphi> ...so, much like the relational way then?
06:06:24 <EvilTerran> > repeat 1 -- usually be one list cell
06:06:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:06:35 <EvilTerran> > [1,1..] -- usually be n list cells
06:06:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:06:42 <Saizan> yeah, you've to use data to simulate identity like in the relational model
06:06:52 <EvilTerran> (although it is, of course, implementation dependent)
06:07:14 <Orphi> I was just thinking about if you wanted to serialise a large data structure that might be cyclic... ooo, that would be amusing! :S
06:07:45 <EvilTerran> yeah. ideally, there'd be RTS support for freezing thunks without forcing them
06:08:10 <ricky_clarkson> DRMacIver: Can you make roman mcmxcviii work, as in, a compile-time generated value, in Haskell?
06:08:12 <EvilTerran> but i imagine that'd be Very Difficult to do right
06:08:16 <Orphi> um, well... I would think in order to save data you would have to actually compute it first.
06:08:33 <Orphi> but it would be nice to have some way to serialise cyclic data.
06:08:37 <EvilTerran> you could save the bytecode of the thunk, say
06:08:51 <Orphi> (actually, saving stuff is the method I usually use to force it to be evaluated... heh)
06:09:26 <EvilTerran> but dealing with all the references would be a nightmare
06:09:30 <Orphi> I gather it's supposed to be possible to do the same with strategies, but I don't really understand.
06:10:15 <DRMacIver> ricky_clarkson: Me personally? Probably not. I'm not very good at Haskell. :) I'm not claiming Haskell has fullblown lispy macros (does liskell yet?). Just that there are a number of compile time metaprogramming solutions for it.
06:10:39 <DRMacIver> ricky_clarkson: It's possible that template Haskell will let you do something like that. I don't know.
06:12:16 <ricky_clarkson> DRMacIver: Ok, I'll reserve judgement until I've seen what those are/used them.
06:14:49 <desp> does anyone here have access to an ingentaconnect account?
06:16:00 <DRMacIver> ricky_clarkson: Wouldn't that require you to actually write more than one-liners? ;)
06:16:34 <ricky_clarkson> I hope not. ;)
06:17:19 <ricky_clarkson> It's true, I mainly use Haskell as a posh calculator.
06:17:29 <bringert_> dons: hmm, TinyHTTP.hs doesn't seem to get the response body
06:17:32 <visof> > let square x = x* x
06:17:33 <lambdabot>  Parse error
06:17:53 <ricky_clarkson> > let square x=x*x in square -2
06:17:54 <lambdabot>   add an instance declaration for (Num (a -> a))
06:17:55 <lambdabot>     In the expression: let s...
06:18:00 <ricky_clarkson> > let square x=x*x in square (-2)
06:18:02 <lambdabot>  4
06:18:03 <kpreid> Orphi: the way I like to think about it is: Haskell doesn't have cyclic structures, only infinite ones (but some are implemented efficiently)
06:18:38 <Orphi> hmm. that's quite deep...
06:18:50 <ricky_clarkson> @hoogle a f -> f a a
06:18:51 <lambdabot> Prelude.id :: a -> a
06:18:51 <lambdabot> Prelude.asTypeOf :: a -> a -> a
06:18:51 <lambdabot> Prelude.const :: a -> b -> a
06:19:50 <kpreid> ricky_clarkson: I think you mean a -> f ->
06:20:12 <EvilTerran> as you wrote it, i'm thinking kind mismatch :)
06:20:22 <ricky_clarkson> > let square=join (*) in square 4
06:20:22 <kpreid> actually, no
06:20:23 <lambdabot>  16
06:20:31 <visof> > let square x =x*x  in square [1, 2]
06:20:32 <lambdabot>   add an instance declaration for (Num [t])
06:20:32 <lambdabot>     In the expression: let square...
06:20:47 <ricky_clarkson> visof: map square [1,2]
06:20:47 <kpreid> EvilTerran: if a has kind * -> * and f has kind * -> * -> * then it's OK
06:20:48 <visof> > let square x =x*x  in square ([1, 2])
06:20:49 <lambdabot>   add an instance declaration for (Num [t])
06:20:49 <lambdabot>     In the expression: let square...
06:21:24 <EvilTerran> if f has kind *->*->*, the presence of "a f" as a type would indicate a::(*->*->*)->*
06:21:29 <ricky_clarkson> > let square=join (*) in map square [1..10]
06:21:30 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
06:21:35 <visof> ricky_clarkson how?
06:21:43 <visof> ok
06:21:43 <EvilTerran> but then f a a::*, so f::((*->*->*)->*)->((*->*->*)->*)->*
06:21:44 <kpreid> hrm...
06:21:46 <EvilTerran> etc, BOOM
06:21:54 <kpreid> > undefined :: a f -> f a a
06:21:55 <lambdabot>      `a' is not applied to enough type arguments
06:21:55 <lambdabot>     Expected kind `k', but `...
06:22:01 <kpreid> conceded
06:22:41 <cognominal> I am running lambdabot (on another IRC server) and he does not answer when in a channel called #lambdabot!
06:24:17 <cognominal> changing the name of the bot does not change anything
06:24:34 <cognominal> and he runs fine in any other channel
06:24:42 <nominolo> s/he/she/
06:24:58 <cognominal> why a bot must be a she?
06:25:09 <nominolo> http://www.cse.unsw.edu.au/~dons/lambdabot.html
06:25:09 <lambdabot> Title: lambdabot
06:25:33 <cognominal> 'it operates'
06:25:46 <nominolo> look at the picture
06:25:47 <cognominal> so it is a it.
06:26:05 <cognominal> like purl!
06:26:15 <cognominal> ...the perl bot.
06:27:21 <nominolo> @quote female
06:27:21 <lambdabot> lambdabot says: Of course i'm female
06:29:13 <desp> never mind :)
06:29:38 <nominolo> @eliza
06:29:38 <lambdabot> Say again?
06:29:46 <nominolo> @vixen
06:29:46 <lambdabot> ouch! I just spilt hot coffee on myself!
06:34:41 <kaol> is there anything unusual I should take into account when making daemons with haskell?
06:37:37 <puusorsa> excorsists
06:39:19 <puusorsa> and catholic church in general
06:42:26 <tibbe> how does the {-# UNPACK #-} macro work? does it really work on recursive data types?
06:42:48 <kaol> forkProcess's description mentions an "I/O manager thread", which won't be running on the child. That sounds like a problem if I'm planning to do the usual two forks that a daemon's initialization involves.
06:43:06 <tibbe> i.e. data Tree a = Node (Tree a) (Tree a) | Leaf a
06:43:28 <tibbe> unpacking the Nodes would yield one big blob of data no? instead of "pointers" to other Nodes?
06:43:40 <tibbe> or maybe I got the semantics of UNPACK wrong
06:44:18 <kaol> perhaps it would be best if I made a C wrapper for this, after all
06:46:04 <Orphi> tibbe: I think UNPACK only works on single-constructor types (I could be wrong tho...)
06:46:27 <Orphi> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#unpack-pragma
06:46:30 <lambdabot> Title: 7.10. Pragmas, http://tinyurl.com/y9jo69
06:46:39 <tibbe> Orphi: I think I could see it work on multi constructor types to if they're not recursive
06:46:42 <tibbe> I read that :)
06:47:09 <tibbe> I'm thinking about a low level translation, in my mind it is the difference between
06:47:33 <Orphi> to know for sure, you've have to play with The Core... :-o
06:48:00 <tibbe> struct { int constr_tag; some_type* val; }; and struct { int constr_tag; some_type val; };
06:48:06 <tibbe> in its actual representation
06:48:19 <tibbe> but I could be totally wrong
06:48:23 <tibbe> but I need to know :)
06:48:32 <Orphi> no, I think that's more or less the idea.
06:48:49 <Orphi> for something like a number or a boolean, it's probably a fairly big win.
06:48:57 <Orphi> I'm not sure exactly what it does for nontrivial types though...
06:49:15 <Orphi> as I say, you'd have to look at The Core.
06:49:30 <Orphi> and then you've have to ask somebody named Simon to interpret The Core and tell you what it means... ;)
06:51:06 <tibbe> "The Core" (especially capitalized like that) scares me...
06:51:43 <tibbe> but I'm going to pretend that my interpretation is correct :)
06:51:58 <Orphi> The Core scares us all... except the Simons. lol
06:52:59 <tibbe> I think clones of the Simons sit inside GHC and interpret The Core by hand.
06:53:23 <Orphi> that would explain why GHC takes so long... ;)
06:53:48 <tibbe> haha
06:54:29 <Orphi> hmm... actually, that's a bit harsh. just because I'm using an AMD K6-II 500 MHz CPU with 128 MB RAM...
06:55:18 <balodja> Too much memory...
06:55:49 <Orphi> actually, more like nowhere near enough - it's running Windoze. :(
06:56:27 <Orphi> linking takes forever...
06:58:08 <Orphi> S(S(KS)K)(S(S(KS)K)I)
06:59:56 <visof> > :type 'H'
06:59:56 <lambdabot>  Parse error
07:00:27 <visof> how can i use lambdabot?
07:01:02 <visof> > :t 'H'
07:01:03 <lambdabot>   parse error on input `:'
07:01:33 <tibbe> @type 'H'
07:01:35 <lambdabot> Char
07:01:51 <tibbe> visof: > is for evaluating expressions
07:01:58 <tibbe> > map (+ 1) [1,2,3]
07:02:00 <lambdabot>  [2,3,4]
07:02:13 <tibbe> :t 'H'
07:02:15 <lambdabot> Char
07:02:32 <visof> :t 4
07:02:34 <lambdabot> forall t. (Num t) => t
07:02:55 <visof> :t []
07:02:57 <lambdabot> forall a. [a]
07:03:27 <visof> is a.[a]  algebra expression?
07:03:39 <visof> like compostion of functions?
07:04:31 <nominolo> yes, if you apply it to a type a spontaneously combusts
07:04:51 <nominolo> no, forall a.  is like \x -> but for types
07:05:23 <visof> >putStrLn ("visof", "v")
07:05:33 <balodja> @help run
07:05:34 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
07:05:50 <tibbe> @src putStrLn
07:05:51 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
07:06:08 <tibbe> :t putStrLn
07:06:10 <lambdabot> String -> IO ()
07:07:24 <visof> > fst (1,3)
07:07:26 <lambdabot>  1
07:08:27 <nominolo> visof, [a] just means a list of "a", where "a" may be any type.  the "forall a." part just re-states this
07:09:49 <nominolo> visof, also, lambdabot does not perform I/O, for security reasons
07:11:03 <visof> can i add commands for lambdabot?
07:11:25 <balodja> @help let
07:11:25 <lambdabot> let <x> = <e>. Add a binding
07:12:25 <Saizan> visof: you can write a plugin and send a patch with it
07:13:35 <fasta> 100% coverage means that the test suite runs through every line at least once, right? I.e. not that it runs all code paths.
07:13:58 <nominolo> right
07:14:30 <visof> is all known functions computable?
07:14:37 <nominolo> visof, no
07:14:39 <fasta> visof: no
07:15:04 <visof> how can i know  which one isn t computale?
07:15:09 <fasta> visof: actually, it's a bit more complicated.
07:15:18 <puusorsa> visof, sure
07:15:24 <puusorsa> get the source and add your stuff
07:15:48 <puusorsa> darcs get --partial http://www.cse.unsw.edu.au/~dons/lambdabot
07:15:48 <lambdabot> Title: Index of /~dons/lambdabot
07:16:07 <fasta> But it's pretty safe to say that there are functions that are not computable on a Turing machine.
07:16:54 <fasta> visof: you reduce it to a problem which has been shown to be incomputable on a Turing machine.
07:16:54 <visof> example for function that isn t computable?
07:17:04 <fasta> visof: is this home work?
07:17:11 <puusorsa> the functon that computes all functions?
07:17:19 <visof> i don t study cs
07:17:37 <fasta> visof: anyway, lookup halting problem on wikipedia.
07:17:52 <visof> ok fasta
07:17:54 <visof> thanks
07:18:30 <fasta> Is it easy to setup HPC?
07:19:51 <visof> what is HPC?
07:20:36 <fasta> http://projects.unsafeperformio.com/hpc/#faq
07:20:38 <lambdabot> Title: Haskell Program Coverage
07:20:43 <fasta> It seems fairly easy.
07:21:09 <fasta> Anyone who tried it on something >10KLOC?
07:22:33 <Lemmih> The author tested it on GHC, I think.
07:24:38 <fasta> Oh, I now see who the author is. :)
07:29:53 * tibbe is doing type error directed development
07:30:19 <LoganCapaldo> I was trying to do that last night
07:30:28 <LoganCapaldo> I'm not very good at it
07:30:44 <tibbe> step 1. Take type who's interface you want to mimic. step 2. Change the type name to your type 3. forever $ compile >> fix
07:30:59 <tibbe> which interface*
07:33:56 <ekidd> Morning.
07:48:39 <nominolo> hi there, ekidd
07:49:08 <ekidd> I think I've mostly recovered from the hackathon...
07:49:10 <fasta> tibbe: you can also use that approach when refactoring.
07:49:20 <tibbe> fasta: yup :)
07:49:36 <tibbe> it's really helpful when you don't know the code you're refactoring that well
07:49:47 <fasta> tibbe: I replaced an optimization with Data.Sequence by just changing the type.
07:49:47 <tibbe> @seen dons
07:49:48 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 12h 17m 31s ago.
07:49:57 <tibbe> fasta: :)
07:50:02 <fasta> tibbe: well, I know the code intimately, still I use it.
07:50:08 <tibbe> right
07:50:13 <nominolo> it's 7a.m. in OR
07:50:18 <tibbe> just saying it helps even more if you don't
07:50:27 <tibbe> feel much more confident changing the code
07:50:39 <tibbe> nominolo: I need him, he should wake up ;)
07:50:50 <fasta> tibbe: right, but working in a code base of which you have no idea what does what...
07:51:09 <fasta> Code should be documented.
07:51:16 <tibbe> it should!
07:51:21 <tibbe> but it's not always ;)
07:51:52 <tibbe> I'm trying to reuse the bytestring bench, any of the authors here?
07:51:53 <fasta> Even when you use identifiers like find_two_last_elements
07:51:55 * allbery_b is clearly not awake yet
07:52:03 <allbery_b> I read "Cale should be documented"
07:52:12 <fasta> allbery_b: that too!
07:52:32 <fasta> Imagine if Cale came with a manual, we could engineer Cale..
07:52:46 <fasta> And then build new Cale's.
07:52:56 <fasta> It does come with binaries, though.
07:53:08 <fasta> Billions of copies of it.
07:53:46 <fasta> Hmm, I could use a THz machine and a faster Emacs like now...
07:54:06 <fasta> Or... I could disable the debugging code.
08:00:53 <nornagon> @users
08:00:54 <lambdabot> Maximum users seen in #haskell: 420, currently: 376 (89.5%), active: 6 (1.6%)
08:01:08 <puusorsa> 4:20 <3
08:07:23 <fasta> If I call foo _ = return (), will this be optimized away?
08:08:14 <fasta> I can either use macros to make sure the call to the debugging code never gets made or I can put it at the definition of the debugging code.
08:08:47 <dons> ?yow
08:08:47 <lambdabot> I'm a fuschia bowling ball somewhere in Brittany
08:09:13 <fasta> dons: do you know that?
08:12:30 <dons> should disappear. check the core
08:14:09 <fasta> I would need to build a test program then, I guess, since inspecting core on a real program is next to impossible.
08:23:46 <tibbe> dons: is the current bytestring bench broken?
08:25:10 <ekidd> dons: Thanks for organizing the hackathon!
08:35:09 <ndm> eek, cafe is hitting the flamewars
08:35:26 <ndm> you know something has gone wrong when an email starts with "I will be impolite."
08:35:44 <LoganCapaldo> I always get really confused when people talk about diagrams commuting
08:35:58 <LoganCapaldo> Does someone want to try and explain that to me?
08:36:29 <ndm> LoganCapaldo: its easy, i'll take that one!
08:36:48 <ndm> Imagine a rectangle
08:36:53 <ndm> A ----------------- B
08:36:57 <ndm> |                                |
08:37:02 <ndm> C ----------------- D
08:37:36 <ndm> the diagram "commutes" if you can show that you can go right around the rectangle
08:37:39 <roconnor> ndm: flame-wars in haskell land?
08:38:05 <ndm> i.e. if you can show that A/C and B/D are isomorphisms, then you can prove that A-B and C-D are equivalent under this isomorphism
08:38:45 <LoganCapaldo> So if you can visit all the letters it commutes?
08:38:57 <roconnor> ndm: that doesn't sound right.
08:38:57 <ndm> yes
08:39:08 <astrolabe> That's not the meaning of a commutative diagram that I'm familiar with.
08:39:29 <fasta> ndm: that means it's getting popular and we will get even worse libraries ;)
08:39:51 <astrolabe> I'd expect those lines to be arrows, from A to B, B to D, A to C and C to D.
08:39:57 <ndm> roconnor, astrolabe: i may have either got it wrong, or explained it badly - either way I'd appreciate clarification :)
08:40:09 <roconnor> A ---> B
08:40:12 <roconnor> |     |
08:40:15 <fasta> ndm: url?
08:40:17 <roconnor> v    v
08:40:24 <roconnor> C ---> D
08:40:25 <LoganCapaldo> well i actually kind of assumed he just forgot the heads of the arrows
08:40:26 <astrolabe> The arrows represent functions
08:40:26 <araujo> morning
08:40:29 <ndm> [Haskell-cafe] On the verge of ... giving up!
08:40:37 <ekidd> LoganCapaldo: In category theory, saying a "diagram commutes" is sort of like setting up an equality relationship. So for example, each of the monad laws set ups an equality between two different expressions, and each monad law becomes a commutative diagram.
08:40:40 <LoganCapaldo> since all tehe other ones I've seen had arrows
08:40:57 <astrolabe> The diagram is commutative, if either route going from A to D leads to the same result.
08:41:00 <cognominal> is it possible to play with gtk2hs from ghci?
08:41:10 <roconnor> this commtes when the composition bd . ab  is equal to cd . ac.
08:41:37 <LoganCapaldo> got it
08:41:40 <ekidd> Exactly.
08:41:46 <roconnor> and more generally a diagram computes with the paths of all composition leading from point X to point Y are equal.
08:41:47 <LoganCapaldo> at least in the specifc diagram I'm looking at now :)
08:41:55 <ndm> cognominal: yes, just about, but not massively easy - i think you need to call unsafeInitGUI instead of initGUI
08:42:05 <LoganCapaldo> Thanks
08:42:21 <cognominal> ndm: ok
08:42:24 <LoganCapaldo> was not as complicated as I was expecting
08:43:13 <ekidd> LoganCapaldo: Category theory is usually not too bad, once you have a good intuitive example for a given concept.
08:43:35 <sorear> That's true of all abstract maths.
08:44:19 <balodja> Then maths become less abstract...
08:56:07 <roconnor> ndm: what a painful thread.
08:56:38 <ndm> roconnor: yep...
08:56:46 <roconnor> on all sides
08:57:27 <LoganCapaldo> q: does thsi really make sense? data Count = Infinity | Natural Integer deriving (Show)
08:57:53 <LoganCapaldo> my poor math intuition is tingling :)
08:58:06 <roconnor> that is isomorphic to Maybe Integer
08:58:30 <integral> But with names that make for nicer code, perhaps...
08:58:58 <roconnor> LoganCapaldo: do you intend Natural to only take on non-negative values?
08:59:13 <LoganCapaldo> I don't know its not my code, but I believe so
08:59:25 <roconnor> Oh, it isn't your code
08:59:27 <sorear> ndm: yeah, ouch.  and I had so much optimism for coppin
08:59:34 <LoganCapaldo> http://homepage.mac.com/sigfpe/Computing/fold.html
08:59:34 <lambdabot> Title: Differentiation of Datastructures for Non-Functional Programmers
09:00:10 <sorear> LoganCapaldo: Infinity should come 2nd, so deriving(Ord) DTRT
09:00:33 <roconnor> the ``natural'' way of doing this is Data Nat = Zero | Succ Nat
09:00:40 <roconnor> and then Infinity = fix Succ
09:00:45 <roconnor> but it depends on your application
09:01:06 <roconnor> obviously the above isn't every efficent.
09:01:19 <fasta> Can I do start (#if FOO 1 #else 2, 3)?
09:01:45 <integral> roconnor: does that allow you to distinguish Infinity and _|_?
09:02:28 <fasta> I.e. can I start a CPP macro anywhere in Haskell code?
09:02:34 <roconnor> integral: oh interesting point.  I was thinking of coinductive data types.  I keep forgetting about the CPO
09:02:48 <Heffalump> CPP macros only work for whole lines, AFAIK
09:03:05 <roconnor> integral: I think it is different from _|_
09:03:22 <roconnor> isSucc Infinity  = True
09:03:33 <integral> oh, yes, ofc ourse.  Sorry, being silly.
09:03:36 <roconnor> while isSucc _|_ = _|_
09:03:40 <integral> Succ is not strict
09:04:21 <roconnor> Anyhow the ``topology'' of Nat is different form Maybe Integer
09:04:53 <roconnor> which makes them suited to different applications
09:05:20 <roconnor> there is the obvious injection Maybe Integer -> Nat (forgetting about the negative integers)
09:05:33 <roconnor> but you cannot go back the otherway
09:07:05 <roconnor> In Maybe Integer, all the points are both open and closed.
09:07:29 <roconnor> But with Nat, Infinity is closed, but not open ... if I understand my topology correctly.
09:08:01 * roconnor thinks about that
09:08:53 <fasta> Hmm, layout and CPP are not good friends.
09:09:13 * fasta wants to return a tuple in one case and not bind a variable in the other case.
09:09:32 <fasta> I fixed it already, but it's not beautiful in any remote way.
09:09:54 <Taejo> is it true that Haskell used to have interact as its only way of doing IO?
09:10:14 <ndm> Taejo: no, but it always used to be in a similar style to interact
09:10:42 <Taejo> ndm, could you explain? or point me to a description?
09:11:05 <ndm> Taejo: have you read the history of haskell paper?
09:11:10 <Taejo> no
09:11:11 <fasta> Taejo: The Gentle introduction contains some information too
09:11:25 <Taejo> where is the history of haskell?
09:11:36 <fasta> @google history of haskell
09:11:38 <lambdabot> http://haskell.org/haskellwiki/History_of_Haskell
09:11:38 <lambdabot> Title: History of Haskell - HaskellWiki
09:11:42 <Taejo> thanks
09:11:49 <fasta> I hope that contains a link to the pds
09:11:53 <fasta> pdf*
09:22:16 <ndm> "as EVERYBODY knows, Haskell is not a rewriting system"
09:22:29 <ndm> from the haskell-cafe - how is haskell not like a term rewriting system?
09:22:38 <ndm> are term rewriting systems non-deterministic?
09:22:46 <ndm> and other than that, are there any other differences?
09:22:56 <wli> They can be. They need not be.
09:23:58 <ndm> that was what i thought - any other differences from haskell?
09:25:31 <fasta> If you use the English word for rewriting, then in some sense every computing system is a rewriting system.
09:25:52 <wli> Like Kolmogorov's linking machine model.
09:25:54 <Heffalump> a term rewriting system is more general than the usual evaluation strategies used for Haskell
09:26:20 <Heffalump> also beta-reduction isn't exactly a term rewrite
09:26:21 <ndm> i.e. the non deterministic bit in the evaluation strategy
09:26:23 <fasta> Heffalump: who defined what a term rewriting system is?
09:26:36 <ndm> Heffalump: how is beta reduction not a rewrite?
09:27:01 <Heffalump> because it involves substitution
09:27:29 <wli> The non-determinism I think enters with parallel rewrites.
09:27:58 <Heffalump> you get non-determinism if you have a non-confluent rewrite system in which you pick rewrites non-deterministically
09:28:44 <fasta> f x = x +1 seems to rewrite x to x + 1
09:28:54 <Heffalump> if your system is confluent it doesn't matter what order you pick them in (apart from needing to avoid infinite chains, but I think "strongly confluent" systems avoid that problem too, though I might just have made up that name)
09:29:43 <fasta> And at the machine level bit patterns are rewritten to other bit patterns for any language compiling to it.
09:29:49 <Heffalump> fasta: that's not rewriting
09:29:53 <Heffalump> that's applying a function
09:30:22 <Heffalump> but that definition can be used to rewrite "f x" to "x+1"
09:30:49 <fasta> Heffalump: I used a "rewriting system", and I don't see the difference with functions in Haskell.
09:31:10 <fasta> Heffalump: so who has defined what rewriting systems are?
09:31:43 <Korollary> academics in the early 80s, 90s I think
09:31:46 <fasta> All computing is by turning one value(the environment) into another.
09:32:25 <fasta> Putting arbitrary name tags on things that are the same doesn't seem like a good thing.
09:32:26 <Korollary> @go citeseer a taste of rewrite systems
09:32:29 <lambdabot> http://citeseer.ist.psu.edu/dershowitz93taste.html
09:32:29 <lambdabot> Title: A Taste of Rewrite Systems - Dershowitz (ResearchIndex)
09:33:41 * ekidd is not feeling good about RDF right now
09:34:15 <fasta> Heffalump: or are they two way systems?
09:34:37 <fasta> Heffalump: that is the rule x = x+1 also means x+1 = x?
09:36:57 <roconnor> isn't the graph re-write engine of GHC a rewrite system?
09:37:07 <allbery_b> I think you could say that Haskell can be characterized as  a kind of rewriting system with certain specific rules
09:37:37 <quicksilver> I'm not sure why, but cycle is so much cooler than mod
09:37:53 <quicksilver> (cycle l) !! (n+1)  is much neater than l !! ((n+1) `mod` length l)
09:38:39 <fasta> No, it seems most rewriting systems also have unification of terms built-in. Otherwise, there's nothing of interest.
09:39:07 <EvilTerran> quicksilver, however, that first one may be O(n), while the second only O(log(length l))
09:39:47 <Taejo> EvilTerran, how is the second not O(length l) ?
09:39:59 <EvilTerran> wait, yes, of course it is
09:40:21 <EvilTerran> so it depends which one you'd expect to be longer most of the time, i guess
09:40:34 <Taejo> but if the former is more elegant, it looks like a job for rewrite rules
09:40:42 <EvilTerran> of course, this is all premature optimisation. and that cycle thing *is* pretty.
09:41:40 <quicksilver> EvilTerran: n+1 is at most (length l) + 1
09:42:29 <quicksilver> hmm actually it's at most length l
09:42:36 <quicksilver> n is, itself, an index into the same list
09:43:37 <Beelsebob> they may have differring complexities, but if length l is not gonna be too large I think I prefer the first one
09:43:43 <Beelsebob> makes it clearer what it's doing
09:44:22 <Taejo> I agree the cycle form is more elegant
09:45:34 <Beelsebob> so... in considering my "why monads are bad" article, I'm so far going to cover two things... (a) thinking of them as tools for sequencing (b) thinking of them as descriptions of different kinds of boxes to put things in
09:45:41 <Beelsebob> what other ways can you think of monads?
09:46:57 <quicksilver> tools for encapsulation notions of computation
09:47:04 <quicksilver> such as failure, and nondeterminism
09:47:29 <Heffalump> fasta: depends on the system
09:47:31 <Beelsebob> ah yes, that's a good one to go through
09:47:36 <tibbe> it looks like everyone will have to upgrade cabal once 6.8 is released
09:47:51 <quicksilver> Beelsebob: I recommend reading moggi's original paper
09:48:00 <tibbe> I've downloaded a bunch of packages today and they all need conditional compilation to work on both 6.6 and 6.8
09:48:00 <Beelsebob> quicksilver: you got a URL for it?
09:48:09 <quicksilver> Beelsebob: althoguh, if you don't want to bias your artice, maybe write your article first and then read it :)
09:48:31 <quicksilver> http://scholar.google.com/scholar?hl=en&lr=&client=firefox-a&cluster=8828873263716674332
09:48:33 <lambdabot> Title: - Google Scholar, http://tinyurl.com/38hvvn
09:48:53 <Beelsebob> quicksilver: surely the least bias occurs if I read them all first, then think about the conclusions
09:49:08 <Beelsebob> otherwise you're inherantly biased by not knowing the story
09:49:09 <quicksilver> sometimes one has interesting insights of ones own
09:49:15 <Beelsebob> true
09:49:28 <quicksilver> which get distorted when you read something which a supposedly 'greater' mind has written :)
09:49:29 <kolmodin> Igloo: there?
09:49:44 <kolmodin> Igloo: did you get my code.haskell.org account request?
09:49:57 <quicksilver> if you think you have a story to tell, it can be worth at least jotting down what *you* think the story is
09:50:04 <quicksilver> before other people's ideas muddy the water
09:50:07 <Igloo> kolmodin: Yup, just backlogged
09:50:52 <kolmodin> Igloo: ok, whenever you feel like it then :)
09:52:31 * Igloo is working at things that have to be done by me first, in the hope that another community admin will handle some of the requests in the mean time  :-)
09:52:46 <fasta> Is there something like hp2ps, but doesn't have a complexity during run-time that depends on the size of the .hp file?
09:53:20 <fasta> It plots every data point every time, instead of only the new points and summarizing data like a sane application would do.
09:53:40 <fasta> summarizing old data*
09:53:57 <fasta> Or caching it in some smart way.
09:54:03 <kolmodin> Igloo: ok, no problem
09:56:04 <Beelsebob> quicksilver: with Philippa's permission, the article's gonna be called "Monads: Functional Programming's Nuclear Turd"
09:56:06 <hpaste>  Taejo pasted "cycle/index rule not firing" at http://hpaste.org/3285
09:56:42 <Taejo> I'm experimenting with rewrite rules but I can't get them to fire, please explain (see paste)
09:57:24 <quicksilver> Beelsebob: ;)
09:58:18 <Beelsebob> (incredably powerful, but boy do they stink :D)
10:01:00 <Taejo> if I'm using -ddump-rules, and my rule isn't showing up, does that mean it doesn't typecheck? or it doesn't have the right syntax? or something else?
10:02:09 <fasta> Hmm, my whole profile is full of zeros.
10:02:26 <fasta> Is there a tool to only see relevant information?
10:04:46 <fasta> What are "OTHER" costs?
10:05:17 <fasta> >95% of the total costs are "OTHER".
10:06:23 <roconnor> I thought it was only IO which was haskell's nuclear turd.
10:07:12 <roconnor> @type replicateM
10:07:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:07:51 <roconnor> If I do replicateM 3 ..., will GHC do ``loop-unrolling'' for me?
10:08:45 <Taejo> roconnor, do you think the loop overhead is significant compared to the list-construction overhead?
10:09:00 <Heffalump> I think it's unlikely, because replicateM is obviously recursive, so won't be inlined.
10:09:03 <roconnor> how about replicateM_ 3 then?
10:09:17 <roconnor> Heffalump: that is my fear :(
10:09:33 <Igloo> You could write a TH function if you care a lot
10:09:35 <roconnor> abstract or optimized, but not both.
10:09:43 <roconnor> Igloo: it seems that way.
10:11:07 <fasta> Igloo: what are "OTHER" costs in a profile? It's 95% in my case.
10:11:23 <fasta> The actual problem being that this code should be ultra-fast, but is slow.
10:11:24 <sorear> fasta: Anything beyond the first 20
10:11:34 <sorear> fasta: Sorted by cost
10:11:56 <sorear> fasta: which means that your code has no hot spots.  congrats, profiling is useless for you.  (in any language)
10:12:16 <Taejo> fasta, why do you think it should be fast?
10:12:44 <fasta> Taejo: I use advanced data structures and my code runs linear in the size of the input.
10:12:49 <fasta> Taejo: at least it should
10:13:03 <fasta> Taejo: the advanced data structures have low constant factors
10:13:18 <fasta> I must have forgotten to remove some debugging code _somewhere_.
10:13:22 <Taejo> well, you could test to see that it is linear: if not, you have made a mistake
10:16:33 <Taejo> if it was a piece of debugging code, surely that would be a hotspot?
10:17:24 <fasta> Taejo: one would expect that, yes.
10:18:03 <fasta> It could be that this ultra-complicated algorithm really is only of theoretical interest, but I doubt that.
10:18:59 <eyeris> With the function type `a -> b -> c`, what is the syntax for specifying that both a and b are in the Ord classs?
10:20:00 <mauke> (Ord a, Ord b) => a -> b -> c
10:20:32 <eyeris> Ok. Now I want to also specify that they are both of the Num class
10:20:37 <eyeris> in addition to the Ord class
10:20:50 <mauke> (Ord a, Ord b, Num a, Num b) => a -> b -> c
10:21:12 <eyeris> ahh
10:21:29 <eyeris> ok, that's what I though, but an unrelated error had me confused
10:21:31 <eyeris> Thanks
10:21:56 <eyeris> WOOHOO!!!
10:22:06 <eyeris> My first real algorithm in haskell
10:22:11 <eyeris> and it worked the "first" time
10:22:12 <eyeris> :)
10:23:27 <wli> Try Newton's method.
10:26:37 <eyeris> What is Newton's method?
10:26:53 <fasta> sorear: the normal profile is still filled with $f1 etc. I assume nobody fixed that in the mean time?
10:27:07 <wli> The root-solving method.
10:29:01 <newsham> http://en.wikipedia.org/wiki/Newton's_method
10:29:02 <lambdabot> Title: Newton's method - Wikipedia, the free encyclopedia
10:29:17 <fasta> What type is * in the type break down?
10:29:39 <wli> http://holomorphy.com/~wli/Newton.hs
10:30:13 <newsham> the star is a "kind" that describes how to construct a type
10:30:40 <eyeris> btw, wli == wli from lkml?
10:30:46 <fasta> newsham: I am talking about profiling.
10:30:48 <wli> Yes.
10:30:52 <fasta> newsham: are you too?
10:31:02 <eyeris> Good work wli, keep it up.
10:31:11 <newsham> fasta: i dunno.. i havent used the profiling stuff much. sorry
10:31:15 <wli> Thanks.
10:31:24 <fasta> newsham: yes, I know what kinds are.
10:31:33 <fasta> newsham: this is something else probably
10:31:40 <Saizan> newsham: re classical logic as CPS: have you been able to write excludedMiddle or ~~p -> p ?
10:31:41 <newsham> ok, sorry
10:31:52 <newsham> saizan: nope. not yet.
10:32:10 <newsham> saizan: i rewrote all of my props with CPS in anticipation
10:32:16 <newsham> but havent figured out how to do the callcc step
10:32:42 <newsham> saiz: here's what I ended up with: http://www.thenewsh.com/%7Enewsham/formal/curryhoward/Classic2.hs
10:32:54 <Saizan> well, i'm not sure if i've used callcc but with the help of djinn i've been able to write them
10:33:37 <newsham> i thought djinn couldnt do pierce's law
10:34:12 <Saizan> ah, one thing that you got wrong is the definition of Or and And, i've had to CPS transform them too
10:34:27 <Saizan> newsham: it can if you state it in CPS
10:34:53 <newsham> saizan: I made them all CPS (see decl of Prop)
10:34:56 <newsham> did I get the CPS wrong?
10:35:00 <Saizan> type Or r a b = (a -> r) -> (b -> r) -> r
10:35:15 <newsham> data Prop r p = Prop ((p -> r) -> r)
10:35:48 <newsham> data Or r p q = OrL (Prop r p) | OrR (Prop r q)
10:35:50 <Saizan> uhm
10:37:07 <geocalc> wli=<< This is wli's new homepage. Less crap, more content. lol
10:38:11 <newsham> Prop == Cont, just rewritten w/ a diff name, basically
10:38:18 <Saizan> yeah
10:38:41 <Saizan> however http://zzodici.yi.org/s/Classical.hs <-- this is what i got, i hope it can help
10:38:52 <newsham> ty.
10:40:52 <newsham> why is there exclMiddle and exclMiddle' ?
10:41:22 <Saizan> just to check that the unrolled signature was the same as the one with type synonym
10:41:58 <newsham> wElim is  ~~P -> P ?
10:42:21 <Saizan> yes
10:43:52 <newsham> I was hoping I would be able to hide the "r"'s from the Cont, then And would only take two types and I would be able to use :/\, for example.
10:44:04 <newsham> but it looks like for the exclMiddle stuff r needs to be explicit
10:44:40 <newsham> (In my Intuit.hs I was able to use bin ops for my relations)
10:44:59 <Saizan> i'm not sure, maybe there's a nicer definition for Or
10:45:34 <ddarius> @djinn ((a -> r) -> (b -> r) -> r) -> (Either a -> r) -> r
10:45:42 <ddarius> @djinn ((a -> r) -> (b -> r) -> r) -> (Either a b -> r) -> r
10:45:42 <lambdabot> f a b = a (\ c -> b (Left c)) (\ d -> b (Right d))
10:45:45 <twanvl> Maybe you could use  type Not p = forall r. type-goes-here
10:45:55 <newsham> when I tried to define callCC without the Prop definition using "forall r." it complained because there were two r's which werent necessarily matched up
10:46:11 <ddarius> @djinn ((Either a b -> r) -> r) -> (a -> r) -> (b -> r) -> r
10:46:11 <lambdabot> f a b c =
10:46:11 <lambdabot>     a (\ d ->
10:46:11 <lambdabot>        case d of
10:46:11 <lambdabot>        Left e -> b e
10:46:11 <lambdabot>        Right f -> c f)
10:46:19 <Taejo> Is it possible to get GHC (or another compiler) to generate platform-generic C?
10:46:21 <ddarius> Saizan: You can just use Either.
10:46:35 <newsham> ddarius: you keep djinning a bunch of stuff thats going right over my head.
10:46:40 <Igloo> Taejo: I think jhc does
10:47:07 <Saizan> ddarius: right.
10:47:37 <Saizan> newsham: he's showed you how to go from Or r a b to Cont r (Either a b) and vice versa
10:47:55 <Saizan> (where Or is how i've defined it)
10:48:45 <fasta> Why doesn't this simple generalization of the heap profile visualization work with biographical profiling? http://paste.debian.net/39719
10:48:51 <newsham> for what purpose.  ie to prove that either one is a sufficient repr of Or?
10:48:58 <ddarius> newsham: There are some "issues" with your code, though not necessarily problems.  First, And and Or and such don't need to take "whole" Props, they can just take the values.  What you have is kind of like a lazy translation.
10:49:57 <roconnor> Igloo: have you ever used template haskell?
10:50:02 <ddarius> newsham: Also the 'abort' control operator is very useful, but awkward to write using 'call/cc'.  A variant of 'call/cc' usually called 'control' is probably more convenient.
10:50:07 * ddarius chuckles at roconnor 
10:50:10 <newsham> ddarius: I dont want people to make And's of things that arent props.
10:50:15 <newsham> (that was my reasoning at least)
10:50:24 <roconnor> ddarius: have you ever used Template Haskell?
10:51:11 <ddarius> roconnor: A long time ago.  Not so much recently.  But Igloo was one of the people hacking on TH when it was about to be released.
10:51:21 <roconnor> oh
10:51:57 <ddarius> The only code of mine that was in GHC was for early TH and I sent it in through Igloo.
10:52:03 <newsham> ddarius: am I trying to write abort (is that the equivalent of exclmiddle?)  what is control, and what is it equiv to?
10:54:41 <newsham> (I am not seeing much in the way of 'abort' and 'control' when googling around with 'haskell' and 'callcc')
10:55:04 <ddarius> These are both common control operators.  abort does what it says and aborts the current computation immediately returning a result.  control is a variant of call/cc that aborts if the passed in function returns.
10:55:20 <ddarius> Saizan's wElim is essentially control.
10:56:00 * Saizan likes doing things without noticing it
10:56:10 <newsham> so abort is basically like "return" in an imperative prog?
10:56:24 <ddarius> The issue is that with call/cc to write abort you need to have some "top-level" continuation, i.e. if you had a call to abort and all you had to implement this stuff was call/cc you'd have to translate your program into one that is wrapped with a call/cc at the very outside.
10:56:44 <ddarius> newsham: abort is vaguely like abort or exit in imperative languages.
10:58:34 <Saizan> ddarius: a little question: so pv~p is Cont r (Either p (Not r p)) or Cont r (Either (Cont r p) (Not r p))? i'm a bit confused by the "levels" of Cont r
10:59:04 <roconnor> ddarius: the geometric algrbra book says they get 10 - 100 times faster code by using a code-generator to make their functions
10:59:14 <roconnor> the generated functions have no loops and no branching
10:59:26 <ddarius> roconnor: Indeed.
10:59:34 <roconnor> but can be generated for any (constant) dimension
10:59:44 <dons> ?yow
10:59:44 <ddarius> roconnor: E.g. Jaap Suter's clifford library in C++ that used template metaprogramming
10:59:44 <lambdabot> I'm wet!  I'm wild!
10:59:46 <dons> ?seen glguy
10:59:46 <lambdabot> glguy is in #xmonad and #haskell. I last heard glguy speak 7h 22m 24s ago.
10:59:55 <cjay> can lhs2TeX be combined with latex-beamer?
11:00:00 <roconnor> sounds like template haskell is the way to go
11:00:29 <ddarius> roconnor: That would be appropriate.
11:00:31 <dons> cjay: i believe so
11:01:02 <Heffalump> roconnor: have you read Igloo's work on the subject?
11:02:48 <ddarius> Saizan: Let us see.  The way excluded middle works is we immediately return Left notp and if notp is ever used we jump back and return Right p instead.
11:05:39 <ddarius> Saizan: So em = control (\k -> k (Left (\p -> k (Right p))))
11:06:01 <newsham> excmid = callcc (\k. Right (\a.k (Left a)))
11:06:22 <ddarius> Yeah, I switched Left and Right.
11:07:12 <ddarius> newsham: But (modulo my typo) that is indeed the same thing.  callcc f = control (k (f k))
11:07:54 <newsham> trying to relate this to what you said.  so this is returnning Right that contains a cont immediately.
11:08:05 <newsham> and if that cont is used, it jumps back and returns a Left instead
11:08:16 <oerjan> ddarius: where is k defined? or is there a \k -> missing?
11:08:51 <ddarius> missing \k
11:09:12 <oerjan> ok
11:09:14 <ddarius> newsham: Exactly.  In this case, call/cc is slightly more handy.
11:09:45 <ddarius> I tend to prefer control because then abort can be written simply as abort x = control (\_ -> x)
11:10:44 <ddarius> control also makes it clearer when you are duplicating continuations and thus likely doing some more complicated control effect.
11:10:55 <newsham> the (Left a) is the "not" because it can generate any "a"?
11:11:56 <foo-nix> twanvl: You again :)
11:12:02 <newsham> whats the def of excmiddle with control?
11:12:36 <ddarius> newsham: The one I gave above which is a slight variant of the one you gave (i.e. I just wrote call/cc in terms of control)
11:12:53 <ddarius> (Modulo the fact that I switched Left and Right accidentally)
11:13:08 <newsham> ah, nearly missed it "em = ..."
11:13:50 <newsham> whats the def of control wrt Cont/callCC?
11:15:19 <ddarius> newsham: Since abort x = control (const x) and abort is inconvenient to write with call/cc, control is inconvenient to write with call/cc.  control would be control f = callcc (\k -> escape (f k)) where escape is a continuation bound outside the entire expression.
11:15:52 <ddarius> Or to put another way, control f = callcc (\k -> abort (f k))
11:16:18 <ddarius> abort is simply apply the "escape" continuation.
11:17:20 <ddarius> So if you have some term T with abort in it somewhere it gets translated to callcc (\escape -> T[escape/abort]) (or I guess more simply callcc (\abort -> T)
11:17:22 <ddarius> )
11:17:27 <newsham> hrmm.. so to do this in haskell I'd have to define all my equations in a closer where an outter continuation was bound?
11:17:36 <newsham> closure
11:17:42 <ddarius> newsham: You can just define control directly.
11:18:14 <newsham> whats the def?
11:18:28 <ddarius> @src Cont callCC
11:18:28 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
11:18:42 <newsham> yah, I already have callCC
11:18:48 <ddarius> replace the second (last) c with id roughly
11:18:53 <ddarius> or return probably
11:19:15 <ddarius> No, id
11:20:13 <ddarius> :t Cont
11:20:15 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
11:20:39 <ddarius> :t \f -> Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) id
11:20:41 <lambdabot> forall a a1 a2. ((a -> Cont a2 a1) -> Cont a2 a2) -> Cont a2 a
11:21:32 <newsham> any reason Control.Monad.Cont doesnt define it?
11:22:03 <ddarius> > let control f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) id in runCont (control (\_ -> return 3) >>= \x -> return x+5) id
11:22:04 <lambdabot>   add an instance declaration for (Num (Cont a a))
11:22:04 <lambdabot>     In the expression: (re...
11:22:14 <ddarius> > let control f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) id in runCont (control (\_ -> return 3) >>= \x -> return $ x+5) id
11:22:15 <lambdabot>  3
11:22:31 <ddarius> > runCont (callCC (\_ -> return 3) >>= \x -> return $ x+5) id
11:22:33 <lambdabot>  8
11:23:13 <ddarius> > runCont (callCC (\escape -> callCC (\_ -> escape 3) >>= \x -> return $ x+5)) id
11:23:14 <lambdabot>  3
11:25:07 <newsham> thanks.  I need to digest this all.
11:25:19 <Tac-Tics> Conts in Haskell are confusing
11:25:47 <dmwit> ...whereas in other languages they are perfectly straightforward?
11:25:53 <ddarius> Tac-Tics: We haven't even broken out delimited continuations.
11:25:54 <balodja> They have nice typing :)
11:26:01 <newsham> in other languages they're hidden under the covers :)
11:26:08 <Tac-Tics> Isn't an object of type "Cont r a" really an "escapable function" and not the continuation itself?
11:26:41 <ddarius> Tac-Tics: Yes.  The thing callCC binds k to is the continuation.
11:26:42 <Tac-Tics> yeah, in other languages, you can plant continuations into macros and have them grow into beautiful data structures
11:26:58 <newsham> an object of type "Cont r a" is an program-let that you can run and feed the result into something else
11:27:03 <Tac-Tics> ddarius: realizing that took about a month for me to understand
11:27:15 <ddarius> Tac-Tics: Start with CPS then go to call/cc
11:27:26 <Tac-Tics> and I still don't know when you'd actually use a Continuation in Haskell
11:28:04 <Tac-Tics> or rather, when does using a Continuation make anyone's life easier?
11:28:06 <ddarius> Tac-Tics: Most effects can be modelled in some other manner, but there reasons to use continuations e.g. efficiency.
11:28:18 <Tac-Tics> can you explain this "efficiency"
11:28:32 <Tac-Tics> I have long since abandoned considering efficiency in my programs =-)
11:29:00 <Tac-Tics> I used to feel so guilty when I searched an array in a linear fashion in Java or C++
11:29:06 <Tac-Tics> but now I just don't care, because it works
11:29:07 <lament> something about big omega notation :)
11:29:15 <Tac-Tics> and I can always make it faster later
11:29:22 <ddarius> Tac-Tics: Most of the time code isn't doing anything effectful, but e.g. using the Either e monad you still constantly are doing a case analysis checking whether something returned correctly or not.
11:29:29 <newsham> later is always faster.  thank you moore!
11:29:45 <ddarius> Tac-Tics: Using continuations you can avoid checking and only "do" some effect when you actually are "doing" something.
11:29:58 <ddarius> Tac-Tics: This can be done for every monad.
11:30:48 <Tac-Tics> ddarius: I'm sorry but that above statement made about as much sense as a continuation
11:30:51 <Tac-Tics> =-P
11:32:32 <Tac-Tics> oh, I think I get it maybe
11:33:10 <Tac-Tics> continuations: the rich man's exception
11:33:22 <Saizan> ddarius: very interesting, i've exaclty this "problem", where/what  should i should i look for to know more about this?
11:33:24 <ddarius> Tac-Tics: That case is particularly clear, yes.
11:33:27 <newsham> your program runs exp(8.8e-7 * t)  faster each minute
11:33:51 <ddarius> Saizan: Filinski's work Representing Monads and Representing Layered Monads and other papers of his in that vein.
11:34:14 <ddarius> Also, from what I hear, GHC does handle continuation passing well.
11:34:28 <Saizan> thanks
11:36:17 <newsham> this one? http://portal.acm.org/citation.cfm?id=292557
11:36:19 <lambdabot> Title: Representing layered monads
11:36:22 <Tac-Tics> is there a page that describes the major differences between hugs, ghc, and other flavors of haskell?
11:37:53 <TomMD> Tac-tics: I don't know of any single page, (various pages on haskell.org), but in general if you are learning then GHC and Hugs are both good.  If you are in industry then stick with GHC.  If you are a compiler developer then take a look at yhc as well.
11:38:02 <Korollary> ghc's user manual lists its extensions to h98
11:38:19 <Tac-Tics> yeah, I know hugs doe the same Korollary
11:38:32 <Tac-Tics> I have hugs, but I've never actually used it
11:38:35 <monochrom> Saizan: Also Filinski's talk on how to do it in Haskell: http://cs.ioc.ee/mpc-amast06/msfp/filinski-slides.pdf  Dan Doel provided that url on haskell-cafe.
11:38:39 <Tac-Tics> and I've never really looked into yhc
11:39:26 <TomMD> ndm and others are doing neat things with yhc.
11:39:36 <TomMD> I wish he were here, I want to bug him about supero.
11:40:30 <Saizan> monochrom: thanks, examples that i can compile are going to be useful :)
11:46:20 <newsham> hrm.. rainbow colored names in these slides
11:53:23 <ddarius> Don't bother with Hugs.
11:53:24 <newsham> hmm, moore's law says your program is 1% faster every 8 days.
11:53:55 <newsham> next time you need to optimize something, go on vacation
11:54:15 <Cale> Assuming that you can parallelise things enough
11:54:28 <Korollary> provided that you keep upgrading your hardware
11:54:36 <newsham> kor: that's IT's job.
11:54:46 <Korollary> actually the moore's law is about chip density; not performance per se.
11:54:47 <Cale> and that the extra transistors are actually used to build parts of the chip which you can use
11:55:33 <newsham> hopefully IT can upgrade while you're on vacation
11:57:13 <ico> Hello - is ghc able to detect non-exhaustive patterns at compile time ?
11:57:26 <dmwit> newsham: Obviously, you should plan your vacation around the IT upgrade. =)
11:57:29 <Tac-Tics> who would I go to for help with a yhc compiler error?
11:57:38 <dmwit> ico: Yep, it will warn you if you tell it to.
11:57:59 <ico> Ah, ok
11:58:08 <ico> typical case of rtfm, I see
11:58:11 <ico> -W
11:58:17 <newsham> dmwit: thats street smarts.
11:58:36 <ico> dmwit: thanks
12:00:42 <Tac-Tics> any one? who do I bug if yhc compile fails randomly?
12:00:53 <ddarius> Probably ndm would be the best.
12:00:57 <_roconnor> Heffalump: I haven't read Igloo's work.
12:01:51 <Tac-Tics> thanks
12:01:53 <newsham> anyone know the rate at which windows eats up more cpu resources?
12:02:40 <newsham> ie. when cpu power quadruples in 3 years, how much slower has windows become?
12:02:48 <dmwit> heh
12:03:02 <newsham> gates' law?
12:04:57 <newsham> wow, wikipedia actually has such a thing
12:05:58 <monochrom> Gates's Law is a corollary of Nash equilibrium or something.
12:06:31 <monochrom> Gates's Law states that Windows speed is invariant.
12:07:14 <ico> invariant ?
12:07:37 <balodja> That's like theory of relativity.
12:07:52 <newsham> the speed of windows is a universal constant
12:07:53 <monochrom> From this you can derive Einstein-Gates relativity equations and find singularities, aka black holes or resource sinks. :)
12:08:14 <swix> If it were relativity, it would be the speed of windows is the same for all observers
12:08:47 <newsham> thats not true, we know that windows appears slower to linux and BSD users.
12:09:01 <swix> well, then relativity cannot apply to windows :P
12:09:04 <balodja> And also given the application's size you can derive the curvature of windows.
12:09:15 <wli> Is hardware speed really going to quadruple in 3 years?
12:09:15 <Beelsebob> newsham: yes, but appearances can be decieving
12:09:23 <newsham> at what point does windows curve back upon itself and implode?
12:09:27 <swix> wli, no, but we'll have 16 cores :P
12:09:44 <newsham> wli: you get a rough doubling every 18mos.
12:09:50 <Beelsebob> e.g. when apple designed the mac, they did tests to see if mousing or using the keyboard was faster -- they found that in 80% of cases mousing was faster, but in 80% of cases, the user thought the keyboard was faster
12:09:54 <wli> 4 sockets x 4 cores is out now.
12:10:27 <swix> well, yeah, but I meant upper range desktop
12:10:34 <swix> no I'm a freak with $13,000 to burn
12:10:36 <swix> not*
12:10:38 <Beelsebob> (not that I'm saying windows is fast)
12:10:39 <newsham> beelsebob: yah, plan9 users like to point that out often.
12:10:57 <wli> $13K is below the price ceiling of upper range desktop.
12:11:33 <Beelsebob> I usually like to point it out to people who swear I'll be faster with silly tools like quicksilver, and editors like TextMate (where there's a key combo for each of the 160000000 operations, and most of them are something like cmnd-ctrl-alt-fn-b)
12:11:56 <swix> well, regardless, I was making a point about core quadrupling
12:11:59 <swix> Beelsebob, emacs?
12:12:12 <Beelsebob> swix: that too has silly key combos much like TextMate, yes
12:12:24 <newsham> swix: you can buy dual-core machines in the $500 range right now.  you can prob expect to buy 8-cores in around 3 years.
12:12:26 <Beelsebob> in fact, I seem to remember reading that the TextMate authors modeled a lot of TM on emacs
12:12:34 <twifkak> Beelsebob: if you're on #haskell, chances are you're in the other 20%
12:12:42 <newsham> you'll be able to get 4 cores in the $500 range in the not too distant future
12:12:57 <Beelsebob> twifkak: it wasn't 80% of users were faster with the mouse, it was 80% of tasks were
12:13:03 <swix> I use vim and everytime I write something off :E instead of :w and bizarre stuff happens
12:13:15 <Beelsebob> even to people with massive amounts of experience with keyboard input and console input
12:13:18 <newsham> if you go by introduction rates of dual-core and quad core, they're roughly on the same 18mos curve
12:13:23 <twifkak> ah
12:13:25 <newsham> (two whole data points! :)
12:13:48 <Beelsebob> newsham: I built a dual core system for my GF for £160 a couple of months back
12:13:56 <Beelsebob> and it's a mid range one too, not a nasty bottom end one
12:14:16 <newsham> *nod*
12:14:23 <pierre-> hello all
12:14:47 <Beelsebob> tbh, In a couple of years time, intel will be releasing their cell-like architecture
12:14:56 <newsham> I just bought a brand-name (HP) amd64 x2 for about $500 2 mos ago.
12:15:04 <Beelsebob> so we'll probably be all using 30 core machines
12:15:12 <newsham> checked the specs and its about 1.5x the power (roughly, in disk, memory and flops) of the cray ymp
12:15:25 <newsham> which was the #1 computer in 1984.
12:15:27 <newsham> very amusing.
12:15:43 <Beelsebob> is that all?
12:15:46 <opqdonut> Beelsebob: have you got a reference for that?
12:15:47 <Beelsebob> surely it's faster than that
12:15:48 <opqdonut> (mouse thing=
12:15:53 <Beelsebob> opqdonut: two secs
12:16:23 <Beelsebob> opqdonut: not my original one, but it's pretty much the same thing... http://www.asktog.com/TOI/toi06KeyboardVMouse1.html
12:16:24 <newsham> the cray was pretty impressive :)
12:16:24 <lambdabot> Title: AskTog:
12:16:37 <Beelsebob> that even gives a nice explanation of why it happens
12:16:41 <newsham> http://www.netlib.org/benchmark/top500/reports/report94/Architec/node10.html
12:16:44 <lambdabot> Title: The Cray Y-MP C90, http://tinyurl.com/3bp98p
12:16:47 <wli> FLOPS is different from a lot of things esp. for numerical linear algebra.
12:17:00 <ddarius> Beelsebob: If that article re mousing is that one I think it is, it's not saying exactly what it says it's saying (at least superficially)
12:17:01 <Beelsebob> basically because your brain has fun trying to decide which keyboard combo to use
12:17:24 <monochrom> time flies when you're happy
12:17:26 <newsham> wli: yah, its kinda hard to compare two systems so distant in time and purpose
12:17:33 <Beelsebob> newsham: 15 gigaflops? that's nothing compared to modern desktops
12:17:36 <newsham> which is why I said "roughly"
12:18:02 <Beelsebob> monochrom: exactly
12:18:20 <lament> what's that Linux measure of processor speed?
12:18:28 <monochrom> bogoflops
12:18:41 <Beelsebob> bogyflops?
12:18:49 <Botje> cookies.
12:18:52 * Beelsebob didn't realise CPU's picked their nose that much
12:18:54 <Botje> also, bogomips
12:18:58 <fox86> can i find a good haskell styleguide somewhere?
12:19:04 <wli> Repetitions of the idle loop.
12:19:08 <lament> aha, bogomips
12:19:10 <newsham> core2duo is like 8gflops, beelse
12:19:13 <fox86> the indentation system is confusing
12:19:22 <Beelsebob> newsham: the 1.83Ghz one is 24Gflops
12:19:42 <newsham>  wouldnt say "thats nothing compared to modern desktop"
12:19:53 <newsham> like I said "roughly 1.5x faster"
12:19:57 <integral> bogomips tend to just measure how well the silicon optimises 1: jmp 1b
12:19:58 <Beelsebob> well, that's half the speed of a bottom of the line one
12:20:07 <monochrom> no styleguide I know of
12:20:25 <newsham> numbers I pulled up for my system were roughly 1.5x the crays
12:20:26 <ddarius> Beelsebob: Without a description of the experimental method, it's pretty hard to judge the results.
12:20:31 <Beelsebob> a top of the line one (8 core xeon 3Ghz) is ludicrously fast
12:20:34 <Beelsebob> ddarius: true
12:21:11 <newsham> My experimental methods were google and calculator.  nothing terribly rigorous.
12:21:18 <newsham> its a silly experiment anyway, but amusing.
12:21:20 <fox86> monochrom: any long sourcecode example somewhere?
12:21:32 <newsham> "how many cray YMPs did I just buy for $500"
12:21:36 <fox86> monochrom: one that uses a good style
12:21:37 <Beelsebob> apparently a 3Ghz Xeon gives you roughly 20Gflops per core
12:21:40 <ddarius> newsham: I was referring to Beelsebob's keyboard v. mouse thing.
12:21:54 <Beelsebob> so in theory about 160Gflops, or 10 times faster than that cray
12:21:57 <Beelsebob> in theory...
12:22:09 <newsham> dd: oh.  well, same could be said about mine too :)
12:22:22 <Beelsebob> ddarius: I had a different ref somewhere that described the experimental method
12:22:35 <Beelsebob> basically it was a case of, pull in a load of people off the street/engineers/cross section
12:22:50 <Beelsebob> randomly assign each one to using the mouse or the keyboard
12:22:52 <ddarius> Beelsebob: Yeah, I thought I had seen something with a bit more detail too.
12:23:03 <Beelsebob> time them
12:23:15 <newsham> beelse: also similar comparisons for the bandwidth, disk size, memory size, etc.
12:23:15 <Beelsebob> ask them to fill in a survey asking how fast they thought they were being
12:23:23 <newsham> the cray did have a bit more memory than I have
12:23:27 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html  then pick a module, then pick "Source Code"
12:23:48 <ddarius> Because I remember coming to the conclusion that I could easily see someone being slower at learning&using the keyboard than at learning&using the mouse, but that says nothing about once you have learned one or the other.
12:23:54 <Beelsebob> newsham: true, 16GB is a lot even for something like a mac pro
12:24:14 <Beelsebob> ddarius: well, except that they were pulling in egineers, who knew how to work a keyboard
12:24:24 <newsham> ddarius: yah, but the conclusions were that people who are more occupied feel like they are taking longer, even though they may not be.
12:24:29 <Beelsebob> so even when using a mouse and being new to it, they were *still* faster
12:24:37 <ddarius> Beelsebob: I'm not talknig about touch typing, I'm talking about knowing the key combinations.
12:24:41 <newsham> and so people often think that reaching and grabbing a mouse slows them down when reality differs from perception
12:24:44 <Beelsebob> ddarius: fair point
12:24:49 <fox86> monochrom: thank you!
12:25:37 <newsham> the experiment isnt to determine if a mouse is faster than a keyboard
12:25:43 <newsham> it is to determine how people perceived the speeds
12:25:58 <newsham> (well, a little of both, I guess, but not *just* to measure speed)
12:25:58 <ddarius> newsham: Making it even less relevant.
12:26:54 <monochrom> Employees don't really care about speed and productivity.
12:26:56 <ddarius> There's also the issue of how well the interface was designed for mousing v. keyboarding etc.
12:27:07 <Beelsebob> ddarius: oh? less relevant?
12:27:14 <ddarius> monochrom: They don't.  They care about being paid.
12:27:20 <Beelsebob> the point I was making was that perception often differs from reality
12:27:25 <Beelsebob> not that mousing or keyboarding is faster
12:27:48 <newsham> you can definitely design a good keyboard system that is faster than a bad mouse system or vice versa
12:27:53 <newsham> what are we arguing about again?
12:28:06 <ddarius> Beelsebob: Less relevant in the context of the paper.  I wasn't hear when you brought it up and didn't really take the time to understand the context.
12:28:11 <Korollary> if perception "often" differs from reality, the majority of my perceptions would be unreal. I am quitting drugs.
12:28:18 <ddarius> And by paper, I guess I mean article.
12:28:42 <monochrom> For example you can argue that Linux is more productive than Windows because of different crashing rates. You can even do a very careful study to prove it. At the end of the day, you ask employees why they succumb it. They tell you, "is that a bad thing? If it crashes, more time for a coffee break!"
12:29:06 <Beelsebob> hehe
12:29:07 <monochrom> Similarly for programmers and days-long compile times.
12:29:18 <Korollary> monochrom: long compile times hurt
12:29:20 <ddarius> Korollary: If perception often differs from reality, why would we have any reason to take the perception of the person with the stopwatch as more authoritative.
12:29:20 * Beelsebob feels the need to xkcd that comment
12:29:35 <Beelsebob> monochrom: http://xkcd.com/303/
12:29:36 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
12:30:08 <monochrom> Yes, I have exactly 303 in mind :)
12:30:17 <ddarius> monochrom: Again.  It's the employer's job to increase productivity or motivate it's increase, not the employee's.
12:30:40 <newsham> ddarius: http://plan9.bell-labs.com/wiki/plan9/mouse_vs._keyboard/index.html
12:30:43 <lambdabot> Title: Mouse vs. Keyboard (Plan 9 wiki), http://tinyurl.com/2ll2v4
12:30:44 <Korollary> The employee is also motivated if he cares about his performance review (is this a government job?)
12:30:57 <monochrom> So, what do you think employees will say when you tell them keyboard is slower? I think they'll say "great, then I'll use the keyboard more! get less done, but more bragging rights about being busy!"
12:31:34 <ddarius> Korollary: Why does he care about his performance review?
12:31:59 <Korollary> ddarius: money via continued employment?
12:33:21 <Tac-Tics> I think Haskell would be the greatest boon to blue collar programmers in the software engineering business
12:33:31 <Tac-Tics> there'd be so much time to spend trying to resolve compiler errors
12:33:47 <Korollary> are you implying ghc is buggy?
12:33:56 <Beelsebob> eh?
12:33:58 <swix> it'd weed out all those math-light compsci majors :P
12:34:05 <Beelsebob> I spend very little time taking out compile errors
12:34:05 <Tac-Tics> A bad programmer could easily take a whole day trying to figure out why a line of haskell couldn't compile
12:34:14 <Beelsebob> certainly much less time than I spend debugging C
12:34:20 <ddarius> Korollary: Exactly.  The motivation is pay.
12:34:47 <Beelsebob> Tac-Tics: yes, but they could spend a week debugging the seg fault
12:34:49 <newsham> tactics: g++ template error messages dont already fill that requirement?
12:35:04 <Tac-Tics> heh
12:35:15 <Tac-Tics> well template errors and segfaults beat out anything
12:35:20 <newsham> i know programmers who have written post processors for c++ template error messages
12:35:22 <Tac-Tics> I was thinking compared to java or python
12:35:30 <LoganCapaldo> template error messages period. I've not seen a good template error message yet (doesn't mean they don't exist I suppose, but I doubt it)
12:37:03 <LoganCapaldo> the most time wasting thing would probably be debuggign a seg fault in a haskell program ;)
12:37:12 <newsham> not alot of segfaults to chase down with python/java/perl/ruby/etc.
12:37:28 <newsham> (not endorsing them, just giving counterexample)
12:37:37 <Jaak> concepts should make template error messages lot more clear
12:37:37 <LoganCapaldo> ruby segfaults :)
12:37:51 <newsham> thats true, but not in the way thats the programmers fault :)
12:38:16 <audreyt> ...instead of segfaults, ghc has existential brain-explosions
12:38:43 <newsham> also currently not the easiest to chase down "Prelude.head: empty list"
12:38:58 <newsham> 6.8 should fix that though
12:38:59 <monochrom> Monochrom's Law is a corollary of Nash equilibrium. Monochrom's Law states that productivity is invariant. If employers deploy means to increase productivity, e.g., mouse vs keyboard, linux vs windows, fast compile vs slow compile, haskell vs c, ... employees will somehow defy it.
12:39:07 <Tac-Tics> a faulty foreign function in haskell is probably likely to start executing in the future.... you get the error message and THEN the code executes
12:40:07 <newsham> mono: corrolary: productivity growth increases the leisure time of employees
12:40:42 <monochrom> hopefully
12:40:56 <newsham> application: program in haskell, spend more time re-re-re-re-writing your code to make it pretty
12:41:09 <monochrom> that one works
12:41:19 <LoganCapaldo> ha. the amount fo tie spent at work is a constant. Any productivevy increases only make you get more work done in that same time, your leisure tiem remans the same :)
12:41:25 <monochrom> the trick is to look like busy.
12:41:54 <newsham> LC: I meant "internal" leisure time.  ie. irc + youtube
12:42:03 <newsham> not external go home and drink beer time
12:42:20 <monochrom> yeah, you have to sit at your cubicle and appear to be busy.
12:42:46 <geocalc> shame on you
12:42:51 <fasta> What is a Bin in a profile?
12:42:52 <LoganCapaldo> internal leisure time I generally find to be boring
12:42:59 <LoganCapaldo> theres only so many times I can hit refresh on reddit
12:43:15 <newsham> LC finds us boring :(
12:43:22 <ddarius> Indeed.
12:43:22 <monochrom> But you can hit <return> as many times as you like on IRC. :)
12:43:46 <geocalc>  
12:43:47 <geocalc>  
12:43:48 <geocalc>  
12:43:50 <LoganCapaldo> heh
12:43:56 <geocalc> lol
12:43:59 <LoganCapaldo> you guys aren't boring
12:44:10 <ddarius> LoganCapaldo: We usually are.
12:44:31 <newsham> perhaps thats why #haskell is such a great channel?
12:44:35 <fasta> In #test you can do that.
12:44:40 <newsham> high productivity of its members?
12:44:50 <LoganCapaldo> there's really a #test?
12:45:02 <newsham> you can /join any channel you want
12:45:03 <LoganCapaldo> It must be a wretched hive of scum and villainery
12:45:24 <fasta> LoganCapaldo: there are always people in it
12:45:30 <newsham> #test is full of french nuclear scientists
12:45:42 <geocalc> ??????????????
12:46:07 <newsham> the rest of the civilized world has joined the #test-ban treaty
12:46:14 <monochrom> haha
12:46:25 * LoganCapaldo groans
12:47:59 <roconnor> :(
12:48:04 <roconnor> [474] #test-ban You're banned from that channel
12:48:14 <monochrom> hahahahahahha
12:48:21 <dmwit> amazing
12:48:28 <roconnor> what did I do?
12:48:34 <monochrom> Perhaps it tests that everyone is banned.
12:48:37 <dmwit> Sounds like you tested the ban!
12:48:39 <LoganCapaldo> tested nuclear weapons?
12:48:48 <monochrom> Like "error 'you are banned'" in haskell. :)
12:49:10 <roconnor> :)
12:49:11 <newsham> propBan = ?
12:49:18 <LoganCapaldo> I'm in #test-ban...
12:49:27 <tibbe> would LL(1) be enough to parse the HTTP protocol?
12:49:38 <monochrom> Hrm!
12:50:01 <tibbe> if so I'm going to write my own @#$@#$%#W$ ByteString parser :)
12:50:02 <newsham> tibbe: should be.  its pretty simple.  I believe its LL(1)
12:50:39 <LoganCapaldo> the only thing that might trip you up would be if you want to trust ontent-Lenght: ?
12:50:40 <monochrom> Well, I guess a test is expected to fail, that's the point of testing.
12:51:09 <LoganCapaldo> I think HTTP might even be regular...
12:51:12 <newsham> tibbe:I have the RFC, the extracted grammer, a stripped down grammar, and a parser for the stripped down grammar online: http://www.thenewsh.com/%7Enewsham/formal/server/
12:51:14 <lambdabot> Title: Directory /~newsham/formal/server/
12:51:21 <newsham> lc: yah, it might be.  the urls are.
12:51:54 <tibbe> newsham: thanks, I'll have a look
12:52:08 <newsham> unfort in HTTP they didnt make an appendix with just the grammar
12:52:14 <newsham> the URL rfc did that, though
12:52:17 <SamB> nice. emacs can open debian packages ;-)
12:52:35 <tibbe> newsham: I need to parse lazy ByteStrings efficiently though, but I will have a look :)
12:52:51 <newsham> tibbe: my parser is just plain Parsec.
12:52:59 <newsham> but I did goof around with a bytestring parsec-variant
12:53:03 <SamB> though I'd rather hoped it would not actually know anything about them being debian packages
12:53:11 <tibbe> newsham: saw that but thanks, I can definitely use the grammar :)
12:53:13 <newsham> http://www.thenewsh.com/%7Enewsham/formal/parse/MyParsecBS.hs
12:54:44 <tibbe> cool
12:54:55 <newsham> i didnt test it for perf or anything, was just goofing around
12:55:02 <hpaste>  BoudewijnE pasted "Haskell class, how in function?" at http://hpaste.org/3286
12:55:13 <BoudewijnE> can someone tell me why the code in my paste isn't working?
12:55:40 <dmwit> (RGB r g b)
12:55:47 <dmwit> i.e.
12:55:57 <dmwit> validRGB (RGB r g b) = validColor r && ...
12:56:01 <BoudewijnE> ahhh gosh
12:56:03 <BoudewijnE> thanks :)
12:56:12 <dmwit> =)
12:56:13 <newsham> "Color" is prob not the best name for a component of RGB.
12:56:19 <newsham> (nitpick)
12:56:25 <LoganCapaldo> red is a color
12:56:28 <LoganCapaldo> green is a color
12:56:32 <BoudewijnE> @newsham: I didn't make that up ;)
12:56:32 <lambdabot> Unknown command, try @list
12:56:35 <BoudewijnE>  @newsham: I didn't make that up ;)
12:56:36 <LoganCapaldo> (counter nitpick)
12:56:44 <fasta> BoudewijnE: all validColor [r,g,b]
12:56:56 <newsham> logan: right, but not  (RGB red red orange)
12:56:57 <fasta> BoudewijnE: that's better, imho.
12:57:13 <dmwit> I like "all".
12:57:24 <BoudewijnE> sure, but this is a univ. assignment
12:57:35 <newsham> boud: carry on :)
12:57:35 <BoudewijnE> and I'm not allowed to change that part
12:57:46 <BoudewijnE> newsham, ok I will
12:57:50 <newsham> you can tell your prof/ta that they picked bad names ;-)
12:57:56 <fasta> BoudewijnE: What university?
12:58:08 <BoudewijnE> Utrecht, netherlands
12:58:14 <newsham> data RGB = RGB Level Level Level
12:58:22 <newsham> type Level = Char
12:58:25 <newsham> err.. Byte8
12:58:27 <newsham> for example
12:58:49 <geocalc> Int
12:58:56 <fasta> newsham: there isn't that much wrong with that name.
12:59:11 <fasta> newsham: a Color is e.g. Red or Color <number>
12:59:17 <newsham> purple :: Color
12:59:26 <newsham> RGB purple purple purple ?
12:59:46 <fasta> newsham: oh, right, I wasn't thinking.
12:59:54 <fasta> newsham: you have a point ;)
13:00:09 <dmwit> RGB Intensity Intensity Intensity
13:01:08 <monochrom> words are deceiving
13:01:26 <shapr> But code is informing!
13:02:58 <fasta> Ok, I have no idea what ./rts/StgStdThunks.cmm should do.
13:03:18 <LoganCapaldo> newtype RedIntensity = RediIntensity Integer, newtype GreenIntensity = ..., data RGB = RedIntensity GreenIntensity BlueIntensity
13:03:36 <newsham> code is most informative when its semantics are reinforced by the names used
13:03:46 <LoganCapaldo> err RGB Redintensity ...
13:03:55 <kosmikus> cjay: [lhs2tex + beamer] yes
13:04:44 <newsham> <font color=red>blue!</font>
13:05:06 <dmwit> And then, in css... .font { color=green; }
13:05:07 <dmwit> =)
13:05:31 <EvilTerran> or *[color="red"] { color=green }
13:05:31 <dmwit> s/=/:/
13:05:44 <EvilTerran> yes, quite, : of course.
13:05:50 <dmwit> Get those unportable extensions out of my CSS!
13:05:56 <dmwit> ;-)
13:06:10 <EvilTerran> it's only CSS2, isn't it?
13:06:25 <dmwit> ...maybe
13:06:42 <dmwit> We weren't allowed to use that in our webapp development this summer.
13:07:02 <dmwit> Some version of IE/Firefox/Netscape/lynx doesn't do it right. =P
13:07:17 <elliottt> lynx i can believe :)
13:07:27 <dmwit> =)
13:08:21 <dmwit> Hah, we have more users than #reddit!
13:09:04 <LoganCapaldo> what about #programming.reddit? :)
13:09:24 <elliottt> @users
13:09:25 <lambdabot> Maximum users seen in #haskell: 420, currently: 395 (94.0%), active: 20 (5.1%)
13:09:55 <shachaf> LoganCapaldo: I thought #haskell *was* #programming.reddit. :-)
13:10:25 <LoganCapaldo> the good bits anyway :)
13:10:36 <Korollary> We lack qwe1234 sorely
13:11:40 <LoganCapaldo> he occasionally says sane things
13:11:57 <dmwit> We have
13:11:58 <dmwit> ?keal
13:11:59 <lambdabot> Keal angry @ dons
13:12:05 <dmwit> ?keal
13:12:05 <lambdabot> better be atleast 16x16 color with extended ascii set
13:12:17 <LoganCapaldo> hehhe
13:12:28 <LoganCapaldo> @keal haul
13:12:28 <lambdabot> proofs are no longer sound
13:12:35 <dmwit> nice
13:12:51 <shachaf> ?protontorpedo
13:12:51 <lambdabot> is haskell going to rewite linux and make it better?
13:13:20 <LoganCapaldo> I like the proofs are no longer sound one
13:13:33 <Korollary> yeah that's very deep
13:13:46 <Korollary> it's not the system that's unsound. It's the proof, man!
13:14:02 <LoganCapaldo> @faq Can haskell rewrite linux and make it better?
13:14:02 <lambdabot> The answer is: Yes! Haskell can do that.
13:14:13 <LoganCapaldo> @. faq keal
13:14:13 <lambdabot> The answer is: Yes! Haskell can do that.
13:14:22 <LoganCapaldo> @. faq keal
13:14:22 <lambdabot> The answer is: Yes! Haskell can do that.
13:14:26 <LoganCapaldo> heh
13:14:41 <dmwit> ?keal
13:14:41 <lambdabot> i try make program called Glyph to do it but my script lang called T too slow. i invent T
13:14:52 <dmwit> hahaha
13:14:57 <Beelsebob> @. . leet faq keal
13:14:58 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "leet"
13:15:01 <dmwit> The lack of trailing (.) just makes it that much better.
13:15:02 <Beelsebob> bah
13:15:09 <dmwit> ?. leet . faq keal
13:15:09 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "leet"
13:15:20 <dmwit> ?leet nothing
13:15:20 <lambdabot>  Parse error
13:15:24 <dmwit> ?elite nothing
13:15:24 <Beelsebob> o.O
13:15:24 <lambdabot> N0thInG
13:15:25 <Beelsebob> sploe
13:15:30 <dmwit> ?. elite . faq keal
13:15:30 <lambdabot> The aNS\/\/3r I$: Yez! H4sk3L1 cAN Do tHa+.
13:15:34 <Beelsebob> that's better
13:15:47 <Korollary> Can lambdabot has @lolcat ?
13:15:53 <LoganCapaldo> zomg
13:15:59 <Beelsebob> @lambdacat surely
13:16:00 <lambdabot> Unknown command, try @list
13:16:09 <dmwit> ?where lambdacats
13:16:09 <lambdabot> http://arcanux.org/lambdacats.html
13:16:15 <dmwit> Already has it. =)
13:16:32 <LoganCapaldo> i think we wanted a @lambdacat version of @elite
13:16:55 <Japsu> yay, then we can do @. elite lambdacat
13:17:16 <dmwit> o
13:18:01 <LoganCapaldo> simon cat sez: is fixed in the head k thx bye
13:18:05 <LoganCapaldo> LOL
13:22:18 <Tac-Tics> these are adorable
13:24:26 <nominolo> awsomest
13:24:56 <nominolo> :t lift concat
13:24:58 <lambdabot> forall a (t :: (* -> *) -> * -> *). (MonadTrans t) => t ((->) [[a]]) [a]
13:25:17 <newsham> ?. vixen keal
13:25:18 <lambdabot> I'm not good at staying on topic
13:25:26 <newsham> ?. vixen keal
13:25:26 <lambdabot> bots should be destroyed. they are so annoying
13:25:45 <Beelsebob> @vixen should newsham stop doing that?
13:25:45 <lambdabot> stop what?
13:25:47 <dmwit> ?protontorpedo
13:25:48 <lambdabot> does huge or ghc have more stuff?
13:25:57 <dmwit> Definitly huge.
13:26:04 <newsham> ?vixen how old are you?
13:26:04 <lambdabot> 19, you?
13:26:09 <newsham> ?vixen a/s/l
13:26:09 <lambdabot> 19/f/California
13:26:10 <Beelsebob> @viken does huge or ghc have more stuff?
13:26:11 <lambdabot> is that really what you want to know?
13:26:13 <shachaf> @brain
13:26:13 <lambdabot> The game does not conclude until the woman with the eating disorder ululates.
13:26:26 <Beelsebob> haha
13:26:26 <dmwit> ?yow!
13:26:27 <lambdabot> Are we on STRIKE yet?
13:26:44 <nominolo> @yarr!
13:26:44 <lambdabot> Shiver me timbers!
13:26:45 <dmwit> ?botslap NO, two balls.
13:26:46 <lambdabot> Unknown command, try @list
13:26:54 <Beelsebob> @botsnack
13:26:59 <lambdabot> :)
13:27:00 <dmwit> ?botslap
13:27:01 <lambdabot> Unknown command, try @list
13:27:07 <dmwit> ?botsmack
13:27:07 <lambdabot> :)
13:27:13 <nominolo> @slap dmwit
13:27:13 <lambdabot> why on earth would I slap dmwit
13:27:17 <nominolo> meh
13:27:27 <dmwit> ha
13:28:01 <yitz> @slap lambdabot
13:28:02 * lambdabot smacks lambdabot about with a large trout
13:28:21 <dmwit> ?slap me
13:28:22 * lambdabot beats up dmwit
13:28:43 <ukl> Hello. What do I need to play around a bit with CoHaToE? eclipse-cdt or eclipse-pde or eclipse-platform-sdk (Oh, I bet this one!) or eclispe-rcp? Or would it make me happier (given I'd like to mess around with Haskell and GUIs) to use one of the other Haskell-GUI frameworks? (I know, Eclipse isn't a real kind of graphics framework...)
13:28:55 <ukl> (Well, maybe I just joined to talk.)
13:29:47 <conal> augustss: hi!  any report on using Eros?
13:30:53 <newsham> ?farber
13:30:53 <lambdabot> Unknown command, try @list
13:30:55 <augustss> It seems to work fine, but I've only played with it for half an hour.
13:31:36 <augustss> It's very neat, but not everything is totally obvious. :)
13:31:38 <nominolo> "Don't know what to do with yourself while reddit is read-only?" .. heh
13:31:56 <conal> augustss: i agree, it's not.  please pass on any feedback from your use & others' reactions.
13:32:05 <dmwit> I know what to do with myself: actually accomplish some code.
13:32:12 <dmwit> ...or not, talk on #haskell. =)
13:34:12 <jedbrown> I'm implementing an adaptive wavelet collocation method and I'm looking for a data structure that will parellilize.  In general, there are 2^(nj) possible wavelets at level j in n dimensions.  However, there are much fewer `active' wavelets at any iteration of the adaptive method so we shouldn't store them all.
13:34:17 <jedbrown> Very simple is [[(Index, Double)]] where index is an n-tuple.  While I think it is still possible to get O(N) wavelet transforms, not having fast random access complicates tha algorithm.  Also, changing the active points (which happens at each iteration) seems expensive.  Suggestions?
13:35:31 <swix> I think Data.Array mimics what one would expect
13:35:50 <swix> A hash table, perhaps?
13:35:54 <swix> Data.Map I think...
13:36:14 <dmwit> jedbrown: You may also want a zipper, if "random access" means moving left and right in the list.
13:36:28 <swix> zipper?
13:36:32 <dmwit> jedbrown: But for parallelization, have you looked at SPJ's Data Parallel stuff?
13:36:56 <dmwit> swix: For lists, basically a list telling what's to the "left" (in reverse order) and "right" of your finger.
13:37:07 <dmwit> swix: Moving left and right is O(1), as is accessing the current element.
13:37:17 <jedbrown> With Data.Array, I need to know the size before-hand.
13:37:49 <jedbrown> dmwit: that, at least is necessary and may be sufficient.
13:37:53 <shachaf> jjjjjj
13:38:01 <shachaf> Oops.
13:38:03 <dmwit> IRC /= vim ?
13:38:24 <jedbrown> I was looking at Data.Map and it also seems like a possibility.
13:38:33 <Cale> six consecutive j's
13:39:34 <jedbrown> dmwit: I have read the slides from SPJ's talk on Nested Data Parallelism.  This work certainly fits within that paradigm.
13:39:48 <shachaf> Many of my programs use hjkl.
13:40:16 <shachaf> Browser, WM, games, etc.
13:40:16 <yitz> ^b^b^b^b^b^b
13:40:18 <yitz> oops
13:40:44 <shachaf> yitz: Don't you mean "^n"?
13:40:53 <jedbrown> The [: :] parallel array syntax is certainly nice.
13:41:02 <dmwit> yeah
13:41:36 <yitz> shachaf: j@vi == ^b@emacs
13:41:46 <geocalc> oops oops oops oops oops oops
13:42:12 <shachaf> yitz: But j moves 1 down.
13:42:27 <shachaf> yitz: Doesn't ^b move one left ("backwards")?
13:42:33 <yitz> shows you how much I know about vi
13:43:39 <shachaf> \e[B\e[B\e[B\e[B\e[B\e[B
13:44:34 <yitz> when i need to move the cursor in vi, i bang randomly on hjkl until it starts to drift in the right direction
13:45:39 <BoudewijnE> how can I construct (and use) an object of a certain class (Which is called RGB) in GHCi? I'd like to test some functions which take such an object as parameter
13:46:19 <yitz> import the module that defines RGB, and use its contructors
13:46:30 <yitz> import in ghci using :load
13:46:35 <BoudewijnE> I already did :)
13:46:46 <BoudewijnE> but do I have to use let too?
13:46:54 <oerjan> BoudewijnE: this the RGB previously mentioned? (which was a type, not a class)
13:47:06 <BoudewijnE> ok it's a type
13:47:10 <BoudewijnE>  @oerjan: indeed
13:47:22 <oerjan> if you want to name the object for later, use let
13:47:40 <yitz> a data declaration?
13:47:53 <tibbe> um, I think I've implemented a LL(0) parser for ByteStrings now :)
13:47:59 <oerjan> let red = RGB 255 0 0
13:48:06 <BoudewijnE> LOL
13:48:09 <BoudewijnE> I'm stupid :X
13:48:13 <BoudewijnE> I was using the :: stuff
13:49:52 <dmwit> BoudewijnE: When you're talking to a specific person, you can leave off the @ (if that's easier).
13:50:19 <Botje> BoudewijnE: are you aware of #haskell.dut?
13:50:26 <BoudewijnE> nop
13:50:30 <BoudewijnE> is it a dutch channel?
13:50:35 <Botje> yes :)
13:50:47 <Botje> might be easier to ask/answer questions in your native language
13:50:52 <BoudewijnE> No I'm not, but does it have advantages
13:50:56 <BoudewijnE> to be honest, not at all
13:51:05 <BoudewijnE> all my courses are in EN, including literature
13:51:11 <BoudewijnE> wouldn't know any dutch names
13:51:19 <Botje> we use the english names, of course
13:51:34 <Botje> "patroon-overeenstemming" is just plain silly :)
13:51:52 <LaLynn> Hans is a Dutch name.
13:51:56 <BoudewijnE> well I'll come over
13:52:04 <Botje> you don't have to if you want to :P
13:52:09 <yitz> patroon-overeenstemming?
13:52:24 <Botje> straight dutch translation of "pattern matching" :)
13:52:56 <yitz> I don't think it sounds silly.
13:53:04 <yitz> Is there a localized lambdabot?
13:53:26 <geocalc> make it
13:53:29 <shachaf> yitz: What do you mean by localized?
13:53:39 <shachaf> yitz: You can run it locally.
13:53:42 <shachaf> @where goa
13:53:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
13:53:44 <shachaf> Maybe?
13:53:55 <yitz> dutch speaking
13:54:03 <shachaf> Oh.
13:54:09 * shachaf feels silly.
13:54:17 <shachaf> I should've read more of the context.
13:54:27 <geocalc> lol
13:54:35 <shachaf> @list dict
13:54:35 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
13:55:04 <yitz> lojban, but no dutch???
13:55:18 <ddarius> There's @babel
13:56:25 <shachaf> What language does @babel know?
13:56:36 <shachaf> Languages, I mean.
13:57:37 <littledan> @babel hello
13:57:37 <lambdabot>   bzzt.
13:57:41 <oerjan> @help babel
13:57:41 <lambdabot> babel <lang1> <lang2> <phrase>.
13:57:41 <lambdabot> Translate a phrase in lang1 to lang2.
13:57:41 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
13:58:09 <littledan> @babel en nl hello
13:58:09 <lambdabot>   hello
13:58:15 <ddarius> @babel dutch en patroon-overeenstemming
13:58:15 <lambdabot>   pattern agreement
13:58:20 <oerjan> @babel nl en patroon-overeenstemming
13:58:22 <lambdabot>   pattern agreement
13:58:29 <yitz> close, but no cigar
13:58:46 <geocalc> ^
13:58:47 <littledan> "agreement" is a pretty accurate description of pattern matching
13:59:09 <oerjan> @babel en nl pattern matching
13:59:11 <lambdabot>   patroon aanpassing
13:59:41 <shachaf> You can't partially apply commands with @., can you?
14:00:10 <dmwit> ?. elite pl
14:00:11 <lambdabot> (|inE 1, C0|uMN 1): uNexPE(73d END 0ph iNpU+ EXpEC+iNG W|-|itE SP4ce, NATUral, id3N7iphiER, L4MbdA aBsTRA(tioN 0r 3xpreSsION
14:00:24 <dmwit> shachaf: Seems like you get an error if you try. =)
14:00:59 <yitz> reminds me of the WinNT blue screen
14:01:01 <oerjan> @list .
14:01:02 <lambdabot> compose provides: . compose
14:01:21 <shachaf> @help compose
14:01:21 <lambdabot> . <cmd1> <cmd2> [args].
14:01:21 <lambdabot> . [or compose] is the composition of two plugins
14:01:21 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
14:02:24 <dmwit> ?pl \x -> x { field = "blah" } -- does ?pl know about records?
14:02:25 <lambdabot> (line 1, column 9):
14:02:25 <lambdabot> unexpected "{"
14:02:25 <lambdabot> expecting variable, "(", operator or end of input
14:02:31 <shachaf> I meant something like @. (babel nl en) (babel en nl) text, though.
14:02:40 <shachaf> dmwit: How could it?
14:02:48 <dmwit> indeed
14:03:01 <dmwit> Unlike if', there isn't really a good translation, is there?
14:03:04 <dmwit> =/
14:03:12 <shachaf> @pl \(x,y,z) -> x
14:03:12 <lambdabot> (line 1, column 6):
14:03:12 <lambdabot> unexpected ","
14:03:12 <lambdabot> expecting letter or digit, operator or ")"
14:03:12 <lambdabot> ambiguous use of a non associative operator
14:03:17 <shachaf> @pl f ()
14:03:17 <lambdabot> f
14:03:30 <dmwit> uh?
14:03:44 <LoganCapaldo> . How wouldn't you pl ify a record update?
14:03:51 <LoganCapaldo> *would
14:04:17 <dmwit> LoganCapaldo: You'd need some extra classes and definitions, I think.
14:04:19 <LoganCapaldo> you'd have to use the constructor and "copy" all the values except for the updated one wouldn't you?
14:04:37 <dmwit> i.e. something like http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
14:04:41 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
14:04:42 <shachaf> LoganCapaldo: That behaves differently, actually.
14:04:49 <shachaf> LoganCapaldo: Because of laziness.
14:04:56 <LoganCapaldo> gah
14:05:11 <LoganCapaldo> I was afraid that sentence was going to end with "because of laziness" :)
14:05:14 <ukl> Is there any page with...something like "lessons" or toy problems for beginners to try to cope with?
14:05:16 <monochrom> hand-write a function whee f x = f{gee=x}. Then whee f can be used pl.
14:05:26 <dmwit> ukl: How about Project Euler?
14:05:29 <dmwit> ?where project euler
14:05:30 <lambdabot> I know nothing about project.
14:05:33 <dmwit> ?go project euler
14:05:36 <lambdabot> http://projecteuler.net/
14:05:36 <lambdabot> Title: Project Euler
14:05:59 <hpaste>  newsham pasted "excluded middle -- almost!" at http://hpaste.org/3288
14:06:13 <ukl> dmwit: never heard about this, thanks for the hint.
14:06:15 <newsham> I think I finally got the structure of it all right
14:06:22 <newsham> I dont quite understand the error I'm getting now
14:08:13 <ukl> dmwit: that's great and exactly what i was looking for. :)
14:08:26 <ukl>  ftgrdsfgvhfdsa
14:08:37 <ukl> (sorry, missed the backspace-key)
14:08:50 <yitz> There are some sample solution to euler project problems on the haskell wiki, but try them yourself first. (do ten at a time, then you can peek at those on the wiki)
14:10:16 <yitz> @go haskellwiki euler
14:10:18 <lambdabot> http://www.haskell.org/haskellwiki/Euler_problems
14:10:18 <lambdabot> Title: Euler problems - HaskellWiki
14:10:26 <ukl> :) thanks
14:22:23 <Taejo> why isn't `main = print <$> (insertionSort . lines) <$> getContents' producing any output? It doesn
14:22:34 <Taejo> * doesn't even read the input
14:22:59 <sjanssen> Taejo: check the type
14:23:08 <sjanssen> you've got something like IO (IO String) there
14:23:09 <shachaf> Taejo: You should use (=<<).
14:23:17 <shachaf> (Or join, equivalently.)
14:23:28 <sjanssen> what's up with the insane popularity of <$> lately?
14:23:47 <Taejo> thanks, sjanssen and shachaf
14:23:55 <shachaf> sjanssen: <$> is nice, as an alternative to `fmap` and friends.
14:23:58 <Taejo> sjanssen, I'm a noob
14:24:19 <sjanssen> Taejo: and I'm surprised a noob knows about <$> :)
14:24:43 <LoganCapaldo> less than dollar greater than
14:24:56 <oerjan> Taejo: btw that is almost interact you've got in there
14:25:01 <oerjan> @src interact
14:25:01 <Tac-Tics> @t <$>
14:25:01 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
14:25:02 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:25:07 <asiagasiewska> hello :)
14:25:21 <byorgey> hi asiagasiewska =)
14:25:28 <asiagasiewska> could some Haskell expert give me a siple example of Data.Map usage
14:25:29 <asiagasiewska> ?
14:25:30 <asiagasiewska> :]
14:25:33 <shachaf> interact $ (++"\n") . show . insertionSort . lines -- ?
14:25:40 <shachaf> > M.empty
14:25:45 <Taejo> sjanssen, not such a noob that I wasn't here yesterday
14:25:46 <Taejo> I'm not too noobish to know what's fashionable, but I'm too much of a noob that I follow the fashions when I shouldn't
14:25:51 <lambdabot>  fromList []
14:25:55 <mauke> > M.fromList []
14:25:57 <lambdabot>  fromList []
14:26:06 <shachaf> mauke: Mine was shorter! :-)
14:26:09 <asiagasiewska> yeah what is this fromList
14:26:22 <mauke> it makes a Map from a list
14:26:30 <asiagasiewska> it is so hard to find enything about that
14:26:37 <mauke> @docs Data.Map
14:26:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
14:26:45 <asiagasiewska> yeah i ve seen that
14:26:50 <asiagasiewska> but no exapmels :(
14:26:55 <byorgey> > M.fromList [("cat", 4), ("duck", 2"), ("stool", 3)] -- create a simple map that lets us look up number of legs for various things
14:26:55 <lambdabot>  Improperly terminated string
14:26:56 <asiagasiewska> examples
14:27:03 <blazzy> what's the solution to the "silly" GADT problem here: http://en.wikibooks.org/wiki/Haskell/GADT
14:27:05 <lambdabot> Title: Haskell/GADT - Wikibooks, collection of open-content textbooks
14:27:06 <byorgey> erm, well, without the extra "
14:27:07 <mauke> fromList :: Ord k => [(k, a)] -> Map k a
14:27:14 <Taejo> oerjan, how can I do sorting with interact? Doesn't it work line by line
14:27:15 <asiagasiewska> ok i will compile the last one in my mind
14:27:16 <asiagasiewska> :]
14:27:17 <mauke> Build a map from a list of key/value pairs. See also fromAscList.
14:27:27 <shachaf> 07.10.12:05:20:53 <Taejo> so (<$>) is like liftM?
14:27:41 <Taejo> shachaf, that's me
14:27:42 <oerjan> Taejo: no, whole stdin to stdout
14:27:44 <shachaf> Taejo: Look at interact's type.
14:27:54 <shachaf> @ty interact
14:27:56 <lambdabot> (String -> String) -> IO ()
14:28:02 <byorgey> yes, <$> === fmap === liftM (for monads).
14:28:05 <shachaf> Just work on a string.
14:28:05 <Taejo> ok
14:29:23 <Taejo> I felt so cool with my =<< and my <$> and now you tell me I don't want either
14:30:07 <Taejo> anyways, it works
14:30:09 <byorgey> hehe
14:30:10 <Taejo> thanks for the help
14:30:11 <oerjan> Taejo: oh they're ok, interact wasn't a perfect fit anyhow
14:30:38 <oerjan> since print does a bit more than putStr
14:31:15 <Taejo> well, I changed from putStr to print because it wasn't working
14:31:22 <shachaf> @src print
14:31:23 <lambdabot> print x = putStrLn (show x)
14:31:25 <Taejo> now I've got main = interact (unlines . insertionSort . lines)
14:31:39 <yitz> @type = M.toList . foldl' (\m c -> M.insertWith (const (+1)) c 1 m) M.empty
14:31:41 <lambdabot> parse error on input `='
14:31:49 <shachaf> Even better. :-)
14:31:50 <yitz> @type M.toList . foldl' (\m c -> M.insertWith (const (+1)) c 1 m) M.empty
14:31:52 <lambdabot> Couldn't find qualified module.
14:32:07 <oerjan> ok that's hard to beat :)
14:32:25 <yitz> @type Data.Map.toList . foldl' (\m c -> Data.Map.insertWith (const (+1)) c 1 m) Data.Map.empty
14:32:27 <lambdabot> forall b a. (Num a, Ord b) => [b] -> [(b, a)]
14:32:49 <yitz> @let histogram = Data.Map.toList . foldl' (\m c -> Data.Map.insertWith (const (+1)) c 1 m) Data.Map.empty
14:32:50 <lambdabot> <local>:17:12: Not in scope: `Data.Map.toList'  <local>:17:46: Not in scope: ...
14:33:06 <yitz> um?
14:33:22 <oerjan> yitz: for some silly reason @run imports Data.Map only as M
14:33:30 <oerjan> (and @type doesn't)
14:34:01 <yitz> @let histogram = M.toList . foldl' (\m c -> M.insertWith (const (+1)) c 1 m) M.empty
14:34:02 <lambdabot> <local>:17:39:     Ambiguous type variable `b' in the constraint:       `Ord ...
14:34:37 <yitz> @let histogram x = M.toList $ foldl' (\m c -> M.insertWith (const (+1)) c 1 m) M.empty x
14:34:46 <lambdabot> Defined.
14:34:57 <yitz> It's about time, bot.
14:35:01 <asiagasiewska> compiled successfully :D
14:35:04 <asiagasiewska> thnx guys
14:35:07 <asiagasiewska> :)
14:35:28 <yitz> > histogram asiagasiewska
14:35:29 <lambdabot>   Not in scope: `asiagasiewska'
14:35:38 <yitz> > histogram "asiagasiewska"
14:35:39 <lambdabot>  [('a',4),('e',1),('g',1),('i',2),('k',1),('s',3),('w',1)]
14:36:12 <asiagasiewska> i just cannot see the difference between the ordinary list
14:36:27 <asiagasiewska> and Map thing
14:36:35 <mauke> Map isn't a list
14:36:43 <shachaf> > map (head &&& length) . group . sort $ "asiagasiewska"
14:36:44 <lambdabot>  [('a',4),('e',1),('g',1),('i',2),('k',1),('s',3),('w',1)]
14:36:44 <Tac-Tics> Map is a finite function
14:36:50 <Tac-Tics> it's a dictionary, or a hash table
14:36:52 <mauke> Map is a lookup table
14:37:03 <LoganCapaldo> It's the finite function
14:37:05 <Taejo> > let textHistogram = (map $ uncurry (+)) . histogram
14:37:05 <lambdabot>  Parse error
14:37:05 <Tac-Tics> it's very fast lookup on key-value pairs
14:37:15 <asiagasiewska> ok
14:37:18 <Cale> > let histogram' xs = M.toList . M.fromListWith (+) . zip xs [1,1..] in histogram' "asiagasiewska"
14:37:19 <lambdabot>  Couldn't match expected type `a -> [(k, a1)]'
14:37:21 <yitz> shachaf: but that needs O(n*log n) space
14:37:44 <shachaf> yitz: Sure.
14:37:45 <Tac-Tics> @src historam
14:37:45 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:37:51 <shachaf> yitz: But it's shorter. :-)
14:37:52 <yitz> c'mon, lambdabot
14:38:17 <Cale> > let histogram' xs = M.toList . M.fromListWith (+) $ zip xs [1,1..] in histogram' "asiagasiewska"
14:38:19 <lambdabot>  [('a',4),('e',1),('g',1),('i',2),('k',1),('s',3),('w',1)]
14:38:57 <yitz> Cale: but is there fromListWith' ?
14:38:59 <LoganCapaldo> what Cale said plus sortBy nd
14:39:07 <LoganCapaldo> arg I can't type
14:39:13 <Taejo> @let textHistogram = (map $ uncurry $ flip replicate) . histogram
14:39:14 <lambdabot> <local>:18:51:     Ambiguous type variable `b' in the constraint:       `Ord ...
14:39:29 <LoganCapaldo> cause I think it should be ordered by the numbe rof cocurences :)
14:42:50 <Taejo> > ((map $ uncurry $ flip replicate) . histogram) "Haskell is cool"
14:42:52 <lambdabot>  ["  ","H","a","c","e","i","k","lll","oo","ss"]
14:43:04 <Taejo> > (unlines .(map $ uncurry $ flip replicate) . histogram) "Haskell is cool"
14:43:05 <lambdabot>  "  \nH\na\nc\ne\ni\nk\nlll\noo\nss\n"
14:46:31 <mauke> @go coverage condition
14:46:34 <lambdabot> http://www.bullseye.com/coverage.html
14:46:34 <lambdabot> Title: Code Coverage Analysis
14:49:38 <ddarius> @free take
14:49:40 <lambdabot> $map f . take x = take x . $map f
14:50:15 <newsham> yay!  excluded middle compiles!
14:50:46 <roconnor> newsham: oh wait, you figured out this callCC thing?
14:50:54 <roconnor> explain it to me!
14:51:13 <ddarius> What does the final code look like?
14:52:02 <newsham> http://www.thenewsh.com/%7Enewsham/formal/curryhoward/Classic2.hs
14:52:20 <Taejo> is it possible to check code out of a darcs repo without getting all the old versions?
14:52:24 <ddarius> :t callCC (\k -> return (Right (\p -> k (Left p))))
14:52:26 <lambdabot> forall (m :: * -> *) b a. (MonadCont m) => m (Either a (a -> m b))
14:52:49 <newsham> [08:00] < ddarius> Saizan: Let us see.  The way excluded middle works is we immediately return Left notp and if notp is ever used we jump back and return Right p instead.
14:52:54 <newsham> best description i've heard
14:53:25 <roconnor> oh
14:53:38 <roconnor> that's totally cheating :P
14:53:41 <yitz> Taejo: darcs get --partial <url>
14:53:52 <Taejo> yitz, thanks
14:53:54 <yitz> Only works if there is a tag.
14:54:15 <Taejo> I just want to download jhc and I don't want it to take all night
14:54:23 <monochrom> Excluded middle is cheating. :)
14:54:35 <yitz> OK, then --partial is what you want.
14:54:38 <ddarius> newsham: Now use exclMiddle to write a version of double negation elimination.
14:54:50 <Taejo> thanks, yitz
14:54:51 <newsham> ddarius: *nod* doing that soon.. also false elimination
14:55:02 <newsham> (~P |- False) |- False
14:55:07 <roconnor> newsham: ah, but you must always work inside a continuation
14:55:22 <newsham> roconnor: yah.
14:55:29 <roconnor> makes sense
14:55:37 <monochrom> You mean "always work inside the monad"?
14:55:49 <roconnor> monochrom: maybe thats what I mean
14:56:00 <newsham> nah, you can have continuations without monads :)
14:56:11 <fasta> YUR IN MY MONAAAD!
14:56:18 <roconnor> newsham: It reminds me of the proof of EM in the sequent calculus
14:56:31 <ddarius> roconnor: It should ...
14:56:35 <roconnor> goal p \/ ~p
14:56:40 <roconnor> let's prove ~p
14:56:43 <roconnor> first assume p
14:56:51 <monochrom> Then it is inside a mathematical monad, though not explicitly declared a Haskell Monad.
14:56:51 <roconnor> oh, I've changed my mind
14:56:55 <roconnor> let's prove p instead
14:57:01 <roconnor> by assumption we are done.
14:57:14 <ddarius> roconnor: That is more or less how it works.
14:57:42 <roconnor> ddarius: you make EM sound almost reasonable.
14:57:55 <monochrom> Hehe.
14:58:09 <newsham> everything is reasonable when you cheat!
14:58:19 <ddarius> It doesn't know what p to return so it starts with not p, then if you can actually apply that to some p (not p = p -> false) then (obviously) you have p so it instead goes back and returns p.
14:58:19 <fasta> Don't most people think EM is reasonable?
14:59:00 <monochrom> EM is cheating. I cannot prove that you're male. I cannot disprove that you're male. But surely one of them is true!
14:59:01 <MyCatVerbs> EM? *scroll up*
14:59:10 <newsham> fast: seems reasonable to me when True or False.
14:59:16 <MyCatVerbs> Excluded middle?
14:59:17 <newsham> only so many pidgeon holes
14:59:25 <ddarius> Excluded middle only works in boolean algebras.
14:59:49 <monochrom> le Law de les Middleau Excludaire
14:59:57 <monochrom> (pardon my french hehe)
15:00:02 <idnar> heehee
15:00:59 <kencausey> Does anyone happen to know of an errata for _Implementing Functional Languages_?
15:01:00 <fasta> Has there ever been a proof that uses excluded middle that was shown to be false (not just an existential statement)?
15:01:31 <ddarius> fasta: By definition, no.
15:02:00 <fasta> Then what's the problem of putting it in a proof?
15:02:10 <newsham> bottom?
15:02:53 <fasta> newsham: in the proofs I have seen that used excluded middle, there was no notion of bottom to find.
15:03:08 <newsham> fasta: i imagine in those cases classical logic is just fine?
15:03:42 <monochrom> It comes down to your definition of "true" and "false".
15:03:42 <ddarius> fasta: Sometimes classical logic is inappropriate.  And using excluded middle is non-constructive.
15:04:15 <fasta> ddarius: what logic are you talking about? Modal logic?
15:04:26 <ddarius> fasta: Excluded middle isn't "true or false", you either assume it or you don't.  If you do, you restrict what potential models there are for your logic, but you get more power.
15:05:07 <mr_tenor> fasta: modal logic can be layered on top of a number of propositional logics
15:05:19 <fasta> By more "power" you mean that you can apply more rules to your proof?
15:05:32 <mr_tenor> non-constructivism is down at the level of propositional logic
15:05:44 <monochrom> Note that Excluded Middle is independent of the other axioms and rules of logic. You should now recall what happened to the parallel postulate, the axiom of choice, the continuum hypothesis, ...
15:05:51 <ddarius> fasta: You can prove more results, they are just less general.
15:06:20 <Taejo> how do I install stuff with ghc-pkg (on ubuntu)?
15:06:25 <fasta> ddarius: ok, I never looked at it like that. Your statement regarding models was nice. Thanks
15:06:37 <allbery_b> ...5th axiom, if we look beyond logic...
15:06:46 <Taejo> is it like apt, or is it just a database?
15:06:54 <allbery_b> (b)
15:06:58 <monochrom> It is just a database.
15:08:08 <ddarius> fasta: The thing with intuitionistic logic is that proofs correspond to programs.  For propositional logic, we're still good with classical logic because it's embeddable into intuitionistic logic, but classical predicate logic is not and it's proofs do not correspond to programs.
15:08:11 <allbery_b> it just tells ghc where to look to find the components of a GHC "package" (which is really a library or framework, not a "package" in the apt / rpm / etc. sense)
15:09:19 <allbery_b> in fact, sometimes I wish they'd called it a library instead of a package
15:10:27 <monochrom> "library" was the catchy word in the 70s.
15:10:41 <monochrom> "package" is the catchy word in the 00s.
15:10:54 <monochrom> Recall that "object" was the catchy word in the 90s.
15:11:04 <fasta> monochrom is catchy in 2007
15:11:23 <monochrom> I'm serious.
15:11:53 <newsham> monochrome r vry srs busns
15:12:10 <geocalc> monochrom is binary color
15:12:17 <fasta> newsham: are you on wireless? ;)
15:12:29 <newsham> i am
15:12:58 <ddarius> fasta: Someone had a good example the other day: Assume l :: [A] is a finite list and f :: Integer -> A satisfies forall n. f n `elem` l, then classically we know that there exists at least one element in l that is occurs an infinite number of times, but there is no constructive way of proving that (unless A is a type consisting of only one value)
15:13:08 <yitz> @elite monochrom
15:13:08 <lambdabot> MOn0chroM
15:14:44 <hpaste>  (anonymous) pasted "Collecting like terms in a list" at http://hpaste.org/3291
15:14:51 <ddarius> or l is one element long
15:15:08 <vonBergmann> does anybody have any idea how i can "collect" terms in a list?
15:15:27 <mr_tenor> vonBergmann: more details
15:15:30 <Saizan> ?type group
15:15:39 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
15:15:49 <ddarius> > group [1,2,2,4,6,1,3]
15:15:51 <lambdabot>  [[1],[2,2],[4],[6],[1],[3]]
15:15:53 <yitz> > histogram [(1,1,36.0),(1,1,36.0),(2,3,5.0)]
15:15:55 <lambdabot>  [((1,1,36.0),2),((2,3,5.0),1)]
15:16:02 <monochrom> mr_tenor: presumably some code has been pasted under "anonymous".
15:16:12 <vonBergmann> ah yes someting like group is what i'm looking for
15:16:18 <mr_tenor> monochrom: ah, missed that ;)
15:16:22 <vonBergmann> thanks
15:16:24 <fasta> ddarius: what do you mean by the part in parentheses (I understood the rest)
15:16:27 <ddarius> > group $ sort [1,2,2,4,6,1,3]
15:16:28 <fasta> ddarius: ?
15:16:28 <lambdabot>  [[1,1],[2,2],[3],[4],[6]]
15:16:31 <chessguy> @type histogram
15:16:33 <lambdabot> Not in scope: `histogram'
15:16:57 <yitz> "histogram" was given a few definitions a little while ago on this channel. were you here yet?
15:17:03 <chessguy> no
15:17:05 <monochrom> histogram = sort >>> group >>> map length ?
15:17:06 <mr_tenor> i need a second monitor so i can keep a full irc window visible...
15:17:19 <ddarius> fasta: If A is () (and we assume no bottoms), then () is clearly the element that is returned an infinite number of times (this is a variation on the one element list case)
15:17:23 <shachaf> monochrom: map (head &&& length).
15:17:24 <Olathe> > map (\a -> (head a, length a)) (group (sort [1,2,2,4,6,1,3]))
15:17:26 <lambdabot>  [(1,2),(2,2),(3,1),(4,1),(6,1)]
15:17:33 <fasta> ddarius: did you get my ping message?
15:17:43 <yitz> "@let histogram x = M.toList $ foldl' (\m c -> M.insertWith (const (+1)) c 1 m) M.empty x"
15:17:44 <Olathe> @pl \x -> map (\a -> (head a, length a)) (group (sort x))
15:17:45 <lambdabot> map (liftM2 (,) head length) . group . sort
15:17:53 <ddarius> fasta: I did, but I'm not registered so you didn't get my response.
15:18:10 <Olathe> > (map (liftM2 (,) head length) . group . sort) [1,2,2,4,6,1,3]
15:18:11 <lambdabot>  [(1,2),(2,2),(3,1),(4,1),(6,1)]
15:18:12 <shachaf> (&&&) in (->) = liftM2 (,)
15:18:43 <chessguy> hm, that's cute
15:18:47 <yitz> Cale said: let histogram' xs = M.toList . M.fromListWith (+) . zip xs [1..]
15:18:59 <yitz> "M" means Data.Map
15:19:03 <chessguy> yeah
15:19:09 <fasta> ddarius: ok, clear.
15:19:31 <chessguy> @pl \xs -> toList . fromListWith (+) . zip xs [1..]
15:19:31 <lambdabot> ((toList . fromListWith (+)) .) . flip zip [1..]
15:19:53 <Saizan> the last . is $
15:20:16 <chessguy> @pl \xs -> toList . fromListWith (+) $ zip xs [1..]
15:20:16 <lambdabot> toList . fromListWith (+) . flip zip [1..]
15:20:19 <fasta> ddarius: however, if the list is finite, there cannot be an element occuring an infinite number of times.
15:20:41 <twanvl> That doesn't sound right, I would expect a histogram to use (zip xs (repeat 1))
15:20:48 <ddarius> fasta: An infinite number of ns such that f n = a
15:20:53 <ddarius> where a `elem` l
15:21:14 <yitz> Cale's defn. does that.
15:22:00 <dynamix> has any one used haskore?
15:22:00 <geocalc> peano fasta
15:22:30 <geocalc> haskore ?
15:22:53 <dynamix> yeah music through haskell
15:23:03 <dynamix> http://en.wikipedia.org/wiki/Haskore
15:23:22 <dynamix> http://www.haskell.org/haskore/onlinetutorial/index.html
15:23:22 <lambdabot> Title: The Haskore Tutorial
15:23:46 <roconnor> ddarius: in what way is classical predicate logic not embeddable in constructive logic?
15:24:14 <ddarius> roconnor: The quantifiers break things.
15:24:31 <roconnor> constructive logic has a classical existential quantifier
15:24:33 <conal> roconnor: hi.  how are things going?
15:24:43 <roconnor> conal: haven't worked on it more yet
15:24:53 <roconnor> I was reading about geometric algebra
15:24:58 <Taejo> where can I find the containers package? I expected it to be at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/containers-0.1 but I didn't
15:25:00 <lambdabot> http://tinyurl.com/2wjzoz
15:25:18 * ddarius loves geometric algebra.
15:25:33 <roconnor> ddarius: classical exists = not forall not
15:25:46 <ddarius> True.
15:26:15 <monochrom> Apparently Hackage doesn't have containers.
15:27:12 <Saizan> containers derives from the splitting of base in 6.8, so i think it will be there when it's released
15:27:41 <monochrom> The future is always brighter. :)
15:27:57 <Taejo> well binary-0.4 depends on it, and I don't have it
15:28:14 <roconnor> soo quantifiers don't really break things
15:28:19 <Taejo> does this mean I need 6.8?
15:28:59 <roconnor> If you want to reason classically, just remember use use the classical exists and the classical disjuction everywhere
15:29:35 <roconnor> If you want to use the classical axiom of choice, then things start getting a little dicy
15:29:50 <roconnor> but even that should somehow be okay
15:30:16 <roconnor> because no one really needs the axiom of choice for anything important.
15:31:26 <Saizan> Taejo: or remove the dependence on containers keeping only base
15:32:15 <ddarius> The rules for classical quantifiers don't hold in constructive logic and there's no trick to get them back.
15:33:02 <roconnor> ddarius: what rules?
15:33:49 <ddarius> roconnor: Pulling them out of implications and such.  Pushing and pulling not through them (effectively the same thing).
15:34:18 <roconnor> all the classical logic rules hold in consturctive logic when the statements only use classical exists and classical disjuction instead of their constructive counterparts
15:34:58 <dcoutts_> @seen dons
15:34:59 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 4h 34m 27s ago.
15:35:37 <roconnor> ddarius: the only trick is that some rules (such as ~~P => P) must be proved by induction the the structure of P, rather than outright.
15:35:43 <dcoutts_> dons: you know xmonad probably infringes on the US patents that some company is suing Red Hat and Novell over
15:36:53 <allbery_b> copy doctorow claims the company in question is Microsoft trying again after the spectacular implosion of SCO.
15:37:19 <idnar> I think PJ also implicated Microsoft
15:37:51 <idnar> (as in Groklaw)
15:39:00 <mux> is there a strict hGetContents somewhere?
15:39:46 <mauke> hGetContents' h = do { x <- hGetContents h; evaluate (length x); return x }
15:39:51 <fasta> mux: apply rnf?
15:40:00 <dcoutts_> mauke: bah, you beat me to it :-)
15:40:06 <fasta> mauke already showed the hacky way.
15:40:08 <mux> booh, I only seq'd it
15:40:09 <mux> stupid me
15:40:18 <mux> hGetContents is evil nonetheless!
15:40:42 * ddarius agrees
15:41:09 <yrlnry_> What's hGetContents?
15:41:09 <fasta> Everything starting with a h shows I/O is in the stone age of computing in Haskell.
15:41:18 <mauke> yrlnry_: slurp
15:41:21 <mauke> only lazy
15:41:22 <yrlnry_> Thanks.
15:41:36 <mux> mauke: thank you btw :)
15:41:37 <yrlnry_> @type evaluate
15:41:39 <lambdabot> forall a. (Testable a) => a -> Gen Result
15:41:42 <mauke> er
15:41:44 <yrlnry_> Urgh.
15:41:47 <mauke> @type Control.Exception.evaluate
15:41:50 <lambdabot> forall a. a -> IO a
15:41:56 <yrlnry_> Ah.
15:41:59 <mux> I often forget that seq isn't enough for lists
15:42:02 <allbery_b> unsafeInterleaveIO is aptly named
15:42:19 <mux> ok ok, now I can use hPipeFrom, at least
15:42:19 <LoganCapaldo> evaluate == stricter return?
15:42:30 <sjanssen> @src evaluate
15:42:30 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
15:42:34 <mux> it's x `seq` return x
15:42:36 <mux> I think
15:42:40 <sjanssen> almost
15:42:40 <mux> ah, well
15:42:41 <mauke> not quite
15:42:44 <ddarius> Not quite.
15:42:46 <Japsu> Errrrrr
15:42:52 <mux> @quote stereo
15:42:53 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
15:42:57 <mux> heh
15:43:03 <Japsu> that's... evil. An IO constructor?
15:43:04 <Japsu> :E
15:43:09 <Japsu> iä iä, cthulhu fhtagn
15:43:28 <LoganCapaldo> yeah normally you only see that sort of thing when sorear is talking :)
15:43:45 <TSC> How is (evaluate x) different from (return $! x) ?
15:44:00 <mauke> Japsu: http://lolthulhu.com/
15:44:02 <lambdabot> Title: LOLTHULHU
15:44:02 <Japsu> @src ($!)
15:44:02 <lambdabot> Source not found. Are you on drugs?
15:44:06 <Japsu> bah
15:44:12 <fasta> The documentation tells you
15:44:13 <Japsu> @type ($!)
15:44:15 <lambdabot> forall a b. (a -> b) -> a -> b
15:44:21 <Japsu> @type evaluate
15:44:23 <sorear> > Control.Exception.evaluate undefined `seq` 2
15:44:24 <lambdabot> forall a. (Testable a) => a -> Gen Result
15:44:24 <lambdabot>   Not in scope: `Control.Exception.evaluate'
15:44:37 <sorear> bad lambdabot!
15:44:43 <TSC> The documentation says they're different, but I don't think I understand how
15:44:51 <sorear> anyways, ($!) return evaluates it at-some-time
15:45:05 <sorear> evaluate does it only when the action is executed
15:45:05 <Lemmih> TSC: (return $! undefined :: ()) `seq` ()  ==>  undefined
15:45:14 <Lemmih> TSC: (evaluate undefined :: IO ()) `seq` ()  ==>  ()
15:45:35 <sjanssen> @src IO
15:45:35 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:45:42 <Lemmih> *fix types, of course.
15:46:00 <TSC> Thanks, guys
15:46:05 <Japsu> mauke: yay, there's been new lolthulhies since I last checked them \o/
15:50:25 <Tchakkazulu> > let map2 = fix (\map' f l -> case l of { [] -> []; (x:xs) -> f x : map' f xs}) in map2 (+1) [1..10]
15:50:27 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
15:50:41 <Tchakkazulu> Woo, I think I just got how fixpoints work :)
15:51:26 <ddarius> Tchakkazulu: It's kind of underwhelming.
15:51:50 <LoganCapaldo> what are lolthulies?
15:53:33 <Tchakkazulu> Yes, but still :)
15:53:36 <fasta> It seems IntMaps are pretty slow. Is there anything better?
15:54:03 <Tchakkazulu> The whole thing of "fix f = f (fix f)" is difficult to just understand.
15:54:11 <sorear> No.  Datatypes are not totally ordered.
15:54:37 <mauke> fix f = x where x = f x
15:54:54 <mauke> it is INTUITIVELY OBVIOUS
15:55:18 <geocalc> > sum [1..sum[1..8]]
15:55:19 <Tchakkazulu> That's the same, really :P
15:55:20 <lambdabot>  666
15:55:51 <fasta> sorear: IntMap provides a specific interface, and I am sure there is a structure with the same features, that even dominates it.
15:56:24 <LoganCapaldo> zomng
15:56:37 <LoganCapaldo> geoocalc just proved haskell is evil
15:56:54 <Tchakkazulu> > let fib = fix (\fib' x -> fib' (x - 1) + fib' (x - 2)) in fib 5
15:56:58 <lambdabot> Terminated
15:57:07 <Tchakkazulu> Heh -_-
15:57:22 <Tchakkazulu> Forgot the 0 and 1 cases.
15:57:52 <sorear> haskell should just insert an arbitrary pair of constants for the summation!
15:58:11 <LoganCapaldo> @faq Can Haskell insert an arbitrary pair of constants for the summation?
15:58:11 <lambdabot> The answer is: Yes! Haskell can do that.
15:58:38 <nominolo> @faq foo
15:58:38 <lambdabot> The answer is: Yes! Haskell can do that.
15:58:45 <sorear> fasta: it's all about use cases.  IntMap was designed to support a very efficient `union`; are you using it as much as the original user (GHC) does?
15:59:23 <fasta> sorear: I only care about putting stuff there and retrieving it. I don't need the fancy operations.
15:59:42 <fasta> sorear: I am thinking of replacing it with an STUArray, which will also work.
16:00:39 <Tela> How do STUArrays compare with STArray? What do you lose in the unboxing? Just laziness?
16:00:55 <fasta> Still, it seems the "oh, it's only a log n factor" is a stupid statement.
16:00:56 <_achilles_> how can I convert (round . sqrt) n  to an integer?
16:00:58 <sorear> Laziness and sharing.
16:01:14 <LoganCapaldo> floor?
16:01:16 <LoganCapaldo> ceiling?
16:01:19 <LoganCapaldo> @type floor
16:01:22 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:01:22 <Tchakkazulu> _achilles_: fromIntegral?
16:01:28 <Tchakkazulu> @type round
16:01:30 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:01:38 <_achilles_> oops, sorry I mean sqrt -> RealFrac
16:01:43 <fasta> It's rather odd that this doesn't come up in the profile, though.
16:01:50 <sorear> If you have a million CLDoubles in a UArray, that's 16MB.  If you have them in a Array, that's 4MB if they all happen to be the same.
16:01:56 <_achilles_> @t sqrt
16:01:56 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
16:02:03 <_achilles_> @ty sqrt
16:02:05 <lambdabot> forall a. (Floating a) => a -> a
16:02:08 <_achilles_> @ty round
16:02:10 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:02:27 <LoganCapaldo> @type (round . sqrt)
16:02:28 <mauke> > (round . sqrt) 10
16:02:30 <lambdabot> forall b a. (RealFrac a, Integral b, Floating a) => a -> b
16:02:31 <sorear> If they *aren't* the same, Array is more like 20MB.
16:02:31 <lambdabot>  3
16:02:36 <Tchakkazulu> So...
16:02:48 <fasta> I do basically a gazillion operations on IntMap now, so, I guess that's where the slow down is.
16:02:50 <Tchakkazulu> That should already be an Int (or Integer) if you want it to be one.
16:03:07 <mux> bah, both pOpen and hPipeFrom from MissingH will not allow me to redirect stderr to /dev/null. am I forced to do this in a non-portable way?
16:03:26 <LoganCapaldo> @type toInteger . (round . sqrt)
16:03:28 <lambdabot> forall a. (RealFrac a, Floating a) => a -> Integer
16:04:18 <LoganCapaldo> @type fromIntegeral . (round . sqrt)
16:04:20 <lambdabot> Not in scope: `fromIntegeral'
16:04:20 * Pseudonym suspects we need a standard integer square root 
16:04:31 <LoganCapaldo> I fail at typing
16:04:38 <monochrom> /dev/null is not portable. on windows it is called nul:
16:04:46 <_achilles_> Logan: I'm looking for Floating -> RealFrac
16:05:00 <vonBergmann> mr_tenor, alright finished my functions to simplify and expand expressions so the snarkiness was not necessary :p
16:05:03 <LoganCapaldo> that doesn't make sense
16:05:03 <Tchakkazulu> I think Floating a => RealFrac a
16:05:09 <yitz> @type realToFrac
16:05:09 <mux> monochrom: I'm specifically asking for doing this in a portable way
16:05:11 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
16:05:15 <LoganCapaldo> you can't convert from a class to class AFAIK
16:05:55 <monochrom> I haven't seen a portable way.
16:06:07 <_achilles_> so there is no why I can do 'divisors n [1..sqrt n]'?
16:06:40 <mauke> 1 .. round (sqrt n)
16:06:57 <_achilles_> doesn't work
16:07:01 <mauke> how?
16:07:05 <ddarius> :t round
16:07:05 <monochrom> 1 .. round (sqrt (fromIntegral n))
16:07:07 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:07:17 <mauke> oh, right
16:07:19 <monochrom> @quote fromIntegral
16:07:20 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:07:31 <Tchakkazulu> >_<
16:07:35 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/ -- Look at Math.Util
16:07:37 <lambdabot> Title: Index of /darcs/numbertheory
16:07:43 <Pseudonym> In particular, isqrt.
16:08:02 <LoganCapaldo> isqrt, usqrt we all sqrt for isqrt
16:08:12 <ukl> I cannot pattern-match this way, can I?   f n n = []  -- which should mean "if both arguments are equal"?
16:08:15 <monochrom> hehehe
16:08:19 <mauke> ukl: no
16:08:25 <LoganCapaldo> ukl: nope
16:08:27 <mauke> f a b | a == b = []
16:08:32 <LoganCapaldo> f  ab | a == b
16:08:37 <ukl> thank you both :))
16:08:40 * LoganCapaldo slooooow
16:08:48 <monochrom> binary search FTW
16:09:18 <twb> What do you do when a library you want to use isn't apt-gettable?
16:09:22 <fasta> Pseudonym: nice factorial ;)
16:09:38 <twb> Especially since it has no cabal file :-(
16:09:51 <fasta> twb: you just wget it and put it in your project directory
16:09:55 <monochrom> I think apt-get and cabal are orthogonal.
16:09:59 <ddarius> Usually you type make or ghc --make
16:10:00 <Pseudonym> fasta: Thanks, but I've written one that's faster.
16:10:14 <twb> fasta: that sounds like a good idea
16:11:06 <fasta> Pseudonym: oh, no comments on algorithmic beauty, it was just that you dispatched on size, which shows that it seems so be built for actual use.
16:11:13 <Pseudonym> Right.
16:11:20 <Pseudonym> Yeah, that's what I was going for.
16:11:40 <Pseudonym> My faster one, BTW, is even more obviously practical.
16:11:42 * ToxicFrog goes insane trying to figure out random number generation.
16:11:46 <Pseudonym> But less generic.
16:12:15 <Pseudonym> Here, let me find it.
16:13:20 <ddarius> > randoms
16:13:21 <lambdabot>  Add a type signature
16:13:25 <ddarius> > randoms :: [Int]
16:13:26 <lambdabot>  Couldn't match expected type `[Int]'
16:13:29 <ddarius> :t randoms
16:13:31 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
16:13:37 <fasta> Ok, this is ridiculous: my complicated algorithm runs in about 2.5 minutes. The simple one in 1.2 seconds.
16:13:54 <idnar> heh
16:13:58 <Pseudonym> fasta: That's not ridiculous.  That's obvious.
16:14:04 <fasta> The complicated algorithm is faster when n goes to infinity, though.
16:14:04 <mauke> write a totally stupid algorithm, it should be blindingly fast!
16:14:14 <Pseudonym> fasta: Switch on size, then!
16:14:23 <fasta> Pseudonym: I don't know what the size is!
16:14:33 * ToxicFrog blinks at that type signature.
16:15:00 <ToxicFrog> ddarius: I'm a near-total newbie, and I need to select between true/false with a given probability and generate random integers within a finite range.
16:15:02 <mauke> run both versions in parallel, abort when one finishes
16:15:25 <mauke> ToxicFrog: I'd use randomIO
16:15:26 <ddarius> :t randomRs
16:15:28 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
16:15:59 <ToxicFrog> I think I've figured out how to generate an infinite list of random numbers, but I can't figure out how to non-statefully traverse it.
16:16:01 <fasta> I doubt my machine is big enough for the "faster" algorithm to ever be faster.
16:16:30 <fasta> In fact, I wonder whether any man-made machine is...
16:18:10 <MyCatVerbs> Oh, hey, wow.
16:18:23 <MyCatVerbs> ToxicFrog: you're on networks other than Nightstar now? :)
16:18:49 <monochrom> You can traverse any list non-statefully.
16:18:56 <ToxicFrog> MyCatVerbs: I have been for a long time.
16:19:13 <monochrom> More details depends on more information.
16:19:46 <dons> dcoutts_: patents?
16:20:09 <fasta> dons: he means the concept of workspaces, I think
16:20:18 <dons> hah
16:20:27 <monochrom> Example 0. "I now have an infinite list of random numbers. They're now all in the right range and the right probability etc. I want five of them."  take 5 (your list here)
16:20:35 <ToxicFrog> monochrom: wrong phrasing. I need to turn this infinite list (or some other construct) into a function that returns a random number n | 0.0 <= n < 1.0 each time it's called.
16:20:45 <ToxicFrog> I can't just use 'take' or 'head' because then I get the same numbers each time.
16:21:03 <MyCatVerbs> ToxicFrog: you want, I think, runST.
16:21:04 <mauke> ... different number each time it's called? yep. state.
16:21:13 <monochrom> That requires state. Also it is not a "function" function.
16:21:17 <ToxicFrog> mauke: yes, that's the problem.
16:21:28 <hpaste>  Pseudonym pasted "fast factorial" at http://hpaste.org/3292
16:21:33 <monochrom> But why do you need such a "function"? Knowing that, I can suggest something.
16:21:46 <ToxicFrog> I know that Haskell has an interface to the kernel random number generator, I'm just having a bastard of a time figuring out how to use it...
16:21:48 <geocalc> !! random
16:21:57 <dons> i think the cat is out of the bag wrt. workspaces
16:22:11 <Pseudonym> i can has bag?
16:22:12 <monochrom> oh well, have to go.
16:22:19 <dons> ToxicFrog: hmm? you just want some randoms?
16:22:22 <dons> :t randomRs
16:22:24 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
16:22:27 <ToxicFrog> monochrom: ok. I have a list, I have a function. I need to map a random selection of list elements.
16:22:35 <Pseudonym> dons: You're talking about the patent?
16:22:39 <dons> > randomRs (1,6) (mkStdGen 42) :: [Int]
16:22:41 <lambdabot>  [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,3...
16:22:54 <dons> Pseudonym: oh, dcoutts suggested xmonad infringes
16:22:57 <mauke> > replicateM 10 randomIO :: IO [Double]
16:22:59 <lambdabot>  <IO [Double]>
16:23:06 <Pseudonym> Oh.
16:23:16 <Pseudonym> Not having read the patent, and having no intention to...
16:23:19 <ToxicFrog> That is to say, something like pmap 0.5 func list, which would behave like map, but each element in list only has an 0.5 probability of having func applied to it.
16:23:25 <Pseudonym> dons: Should have stayed in Australia.  Perfectly legal here.
16:23:39 <dons> mmm
16:23:47 <fasta> dons: they will shoot you for that in the USA ;)
16:24:01 <Pseudonym> No, they don't shoot you for patent infringement.
16:24:01 <ToxicFrog> So that pmap 0.5 (+1) [ 0, 0, 0, 0 ] might return, say, [ 1, 0, 0, 1 ]
16:24:25 <Pseudonym> They only shoot you if they're stupid enough to think that the harmless thing you have might be a bomb.
16:24:45 <fasta> ToxicFrog: you cannot write such a function in H98
16:24:52 <Tela> ToxicFrog You can't do that quite like that. pmap wouldn't be referentially transparent
16:25:06 <lekro> oh, the hoogle docs for Writer and Reader seem to be broken, too :(
16:25:24 <ToxicFrog> Tela: is there some way I can get a similar effect, then?
16:25:26 <fasta> lekro: tell us when hoogle does work ;)
16:25:32 <mauke> pmap d f = mapM (\x -> do r <- randomIO; if r < d then f x else x)
16:25:43 <mauke> I mean return $ if ...
16:25:47 <ToxicFrog> Because without the ability to apply a function to a random selection of a list, I'm fucked, and must choose a different language for this project.
16:25:48 <geocalc> >[2,8.
16:25:48 <dons> or zip it with the list of randoms
16:26:03 <fasta> ToxicFrog: highly unlikely.
16:26:26 <dons> ToxicFrog: this is a one liner :)
16:26:43 <geocalc> > [2,8..] !! random
16:26:44 <lambdabot>  Couldn't match expected type `Int'
16:27:08 <mauke> Random> pmap 0.5 (+1) [ 0, 0, 0, 0 ]
16:27:10 <mauke> [1,1,1,0]
16:27:33 <lekro> fasta: sorry if I've repeated something obvious, I don't read #haskell all day
16:27:45 <dons> > let probs = randomRs (1,2) (mkStdGen 42) :: [Int] in [ if p < 2 then (^2) x else x | (x,p) <- zip probs [1..] ]
16:27:47 <lambdabot>  [4,2,2,1,1,2,1,2,1,2,2,2,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,2,1,1...
16:27:59 <dons> > let probs = randomRs (1,2) (mkStdGen 42) :: [Int] in [ if p < 2 then (^2) x else x | (p,x) <- zip probs [1..] ]
16:28:00 <lambdabot>  [1,2,3,16,25,6,49,8,81,10,11,12,169,196,225,16,17,18,19,400,441,484,529,576,...
16:28:06 <fasta> lekro: don't assume Haskell tools are all great and powerful; they are not. Some are. Most are not.
16:28:07 <dons> randomly squares a list
16:28:15 <fasta> lekro: otherwise, np.
16:28:16 <dons> also, don't assume fasta is right :)
16:28:20 <fasta> dons: :)
16:28:21 <lekro> fasta: hoogle used to be better, though
16:28:26 <dons> he's a bit on the glass 3/4 empty side
16:28:38 <dons> ToxicFrog: how's that ^^
16:28:42 <MyCatVerbs> dons: the glass was overspecified.
16:29:10 <dons> ?faq btw :)
16:29:10 <lambdabot> The answer is: Yes! Haskell can do that.
16:29:13 <ToxicFrog> dons: ok, that is fairly awesome
16:29:17 <dons> fasta didn't write that plugin
16:29:24 <dons> cool, i'm happy with "fairly awesome" :)
16:29:44 <fasta> dons: most optimists think realists are pessimists ;)
16:29:48 <agnokapathetic> hello all, where might one find a good arbitrary precision math library>
16:29:50 <agnokapathetic> *?
16:29:54 * ToxicFrog goes over to figure out what, exactly, it's doing
16:29:55 <dons> touche
16:30:01 <omnId> instead of randomRs (1,2) g, why not randoms g :: [Bool]
16:30:09 <mauke> agnokapathetic: like, bigints?
16:30:13 <dons> so, part one is to get a list of random probabilties
16:30:17 <dons> yeah, bool would be better
16:30:29 <dons> > randoms (mkStdGen 1) :: [Bool]
16:30:30 <agnokapathetic> mauke: no, for Reals
16:30:31 <lambdabot>  [True,False,True,True,False,True,False,True,False,False,True,True,False,True...
16:30:38 <dons> o you've got some random booleans going on
16:30:51 <dons> then, you zip up that list with your values
16:30:53 <fasta> agnokapathetic: you might bind the GNUMP library?
16:30:56 <dons> and apply if True
16:30:58 <fasta> (this is a joke)
16:31:00 <omnId> > zipWith (\b x -> if b then x else x^2) (randoms (mkStdGen 42)) [1..]
16:31:01 <lambdabot>  [1,2,3,16,25,6,49,8,81,10,11,12,169,196,225,16,17,18,19,400,441,484,529,576,...
16:31:21 <ToxicFrog> Ok, that's almost what I need. I'd forgotten about let.
16:31:37 <ToxicFrog> Now...(mkStdGen 42) creates a random number generator with seed 42, yes?
16:31:41 <dons> right
16:31:45 <ricky_clarkson> @pl \b x -> if b then x else x^2
16:31:45 <lambdabot> (`ap` (^ 2)) . if'
16:31:51 <dons> so stick in some randomised seed
16:32:06 <ToxicFrog> Can I seed from the system clock or the kernel random number generator or somesuch?
16:32:13 <omnId> ToxicFrog: if you want a more arbitrary random source, then have your pmap function recieve a StdGen as a param
16:32:19 <dons> you sure can, ToxicFrog
16:32:27 <omnId> ToxicFrog: then the user of pmap can get one from newStdGen
16:32:30 <dons> check the System.Random docs for newStdGen
16:32:36 <dons> ?docs System.Random
16:32:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
16:32:49 <agnokapathetic> mauke: GHC uses gmp for integers, but how might one go about using arbitrary precision decimals
16:32:52 <omnId> do g <- newStdGen ; let x2 = pmap f x1 g
16:33:04 <dons> agnokapathetic: use a Rational type perhaps?
16:33:27 <dons> > 22 / 7 :: Rational
16:33:28 <lambdabot>  22%7
16:33:36 <ToxicFrog> Excellent, thank you.
16:33:38 <dons> > 1.1 + 2.2 :: Rational
16:33:39 <lambdabot>  33%10
16:33:39 * ToxicFrog fiddles with it
16:33:42 <dons> > 1.1 + 2.2 :: Double
16:33:43 <lambdabot>  3.3000000000000003
16:33:49 <dons> math broke fpu
16:34:02 <dons> ?keal joke, for those new people :)
16:34:02 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
16:34:24 <agnokapathetic> > let phi = (1+sqrt 5)/2 in phi**2::Rational
16:34:24 <lambdabot>   add an instance declaration for (Floating Rational)
16:34:25 <lambdabot>     In the expression: ...
16:34:25 <omnId> @. elite keal
16:34:25 <lambdabot> i JU$7 90T baNN3d phrO/\/\ Ma+|-| bE(auzE i N07 |-|4ve 9ood aBi1I7y TO CONVeY 7H0Ug|-|+$
16:34:36 <dons> :t (**)
16:34:38 <lambdabot> forall a. (Floating a) => a -> a -> a
16:34:40 <lekro> > zipWith ([id,(^2)]!!) (randomRs (0,1) (mkStdGen 42)) [1..]
16:34:41 <lambdabot>  [1,4,9,4,5,36,7,64,9,100,121,144,13,14,15,256,289,324,361,20,21,22,23,24,25,...
16:34:43 <dons> :t (^^)
16:34:45 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
16:34:46 <dons> :t (^)
16:34:49 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
16:34:58 <agnokapathetic> > let phi = (1+sqrt 5)/2 in phi^^2::Rational
16:34:59 <lambdabot>   add an instance declaration for (Floating Rational)
16:34:59 <dons> > 2 ^ 4 :: Rational
16:35:00 <lambdabot>  16%1
16:35:11 <agnokapathetic> > let phi = (1+sqrt 5)/2 in phi^2::Rational
16:35:11 <lambdabot>   add an instance declaration for (Floating Rational)
16:35:13 <mauke> you can't sqrt Rationals
16:35:18 <dons> :t sqrt
16:35:21 <lambdabot> forall a. (Floating a) => a -> a
16:35:36 <dons> ?src Floating
16:35:36 <lambdabot> class  (Fractional a) => Floating a  where
16:35:36 <lambdabot>     pi                                                      :: a
16:35:37 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
16:35:37 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
16:35:37 <lambdabot>     (**), logBase                                           :: a -> a -> a
16:35:40 <Botje> sqrt :: Watersports a
16:35:43 <omnId> @type realToFrac
16:35:45 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
16:36:06 <dons> agnokapathetic: you require arbitrary precision -- Double won't do?
16:36:25 <agnokapathetic> dons: nope. need more precision than Double
16:36:54 <ricky_clarkson> @hoogle Rational -> Int
16:36:55 <lambdabot> No matches, try a more general search
16:37:03 <dons> > 1 +  (5 ^ 1/2) :: Rational
16:37:05 <lambdabot>  7%2
16:37:20 <agnokapathetic> > let fib n = round((phi**(x+1)-(1-phi)**(x+1))/(sqrt 5))	  where phi = (1+sqrt 5)/2     x = (fromInteger (n-1))::Double
16:37:20 <lambdabot>  Parse error
16:37:37 <dons> > let phi = (1 + (5 ^ 1/2)) / 2 in phi ^ 2 ::Rational
16:37:38 <lambdabot>  49%16
16:37:40 <omnId> ricky_clarkson: round, ceiling, floor, truncate
16:37:52 <dons> > let phi = (1 + (sqrt 5 )) / 2 in phi ^ 2 :: Double
16:37:53 <lambdabot>  2.618033988749895
16:38:04 <dons> > realToFrac (49%16)
16:38:05 <lambdabot>  3.0625
16:38:26 <dons> > let phi = (1 + (sqrt 5 )) / 2 in phi ^ 2 :: Float
16:38:28 <lambdabot>  2.6180341
16:38:28 <yitz> http://haskell.org/haskellwiki/Applications_and_libraries/Mathematics#Real_and_rational_numbers
16:38:31 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/2rt3uv
16:38:40 <dons> ah, good reference yitz
16:38:48 * dons realises who yitz is :)
16:39:12 <lekro> 5 ^ 1/2 is 2.5
16:39:44 <agnokapathetic> Ah just what i was looking for, thanks Yitz
16:39:51 <omnId> lekro: (5 ^ 1)/2
16:39:59 <lekro> yes
16:40:05 <ToxicFrog> ...hmm.
16:40:15 <ToxicFrog> newStdGen returns an IO StdGen.
16:40:26 <ToxicFrog> This looks like it's taking me into monad territory.
16:40:36 <omnId> ToxicFrog: so extract it in a do block in the function that uses pmap
16:40:48 <dons> ToxicFrog: right at the start, yes. you grab a seed in main
16:40:52 <omnId> do g <- newStdGen ; ... pmap g ...
16:40:54 <dons> then zip it up purely from then on
16:41:20 <dons> unless you want a referentially transparent random seed :)
16:44:25 <Pseudonym> referentiallyTransparentSeed :: Integer
16:44:29 <Pseudonym> ?
16:44:52 <omnId> referentiallyTransparentSeed = 42
16:45:12 <Pseudonym> {-# NOINLINE referentiallyTransparentSeed #-}
16:45:28 <Pseudonym> referentiallyTransparentSeed = unsafePerformIO ioSeed
16:45:37 <omnId> :O
16:45:40 <Pseudonym> There's a philosophical question as to whether or not that's okay.
16:45:43 <ToxicFrog> Perhaps I'll just wrap it in a bash script that yanks a seed out of /dev/random and passes it in on the command line...
16:45:58 <mauke> ToxicFrog: you need IO to read command line args anyway
16:46:13 <ToxicFrog> ...but, no, shit, that won't work either, because then I end up with the same list each time I call pmap
16:46:22 <ToxicFrog> mauke: ...why?
16:46:28 <omnId> @type getArgs
16:46:30 <lambdabot> Not in scope: `getArgs'
16:46:38 <omnId> @hoogle arg
16:46:38 <lambdabot> Test.QuickCheck.arguments :: Result -> [String]
16:46:38 <lambdabot> Distribution.GetOpt.ArgDescr :: data ArgDescr a
16:46:38 <lambdabot> Distribution.GetOpt.ArgOrder :: data ArgOrder a
16:46:43 <mauke> ToxicFrog: try it and see
16:46:46 <dons> ToxicFrog: what's the problem you're having? afaik, you have everything you need to solve it at this point?
16:47:01 <omnId> @type System.Environment.getArgs
16:47:03 <lambdabot> IO [String]
16:47:32 <ToxicFrog> mauke: well, yes, that's the immediate reason, but I wouldn't have thought that reading argv implied any sort of side effect
16:47:39 <dons> ToxicFrog: since 'main' is in IO no matter what, that's where you grab your changing random seed, and toss it to the pure part of your program
16:47:49 <lekro> what was the correct way to use the Writer monad for building a string? I remember that Writer String might not be optimal because appending to a long string is expensive.
16:47:53 <dons> yeah, its an interesting question. there is a small faction calling for getArgs to be pure
16:48:09 <Pseudonym> lekro: You could use Data.Sequence.
16:48:14 <dons> lekro: right, using  DList type might be more efficient
16:48:21 <mudge> does anyone recommend a book on writing compilers, or learning about them?
16:48:21 <mauke> main :: [String] -> IO Int  -- C style, baby
16:48:25 <ToxicFrog> I mean, have a function that returns a list of String which is the argument list and you're done...where's the IO?
16:48:29 <Pseudonym> Yeah, DList.
16:48:34 <dons> though, if the Writer is building string big enough for performance to be an issue, bytestrings in Data.Binary would be way better
16:49:21 <mauke> @type System.Environment.setArgs
16:49:22 <omnId> ToxicFrog: IO is perhaps a bad name.  It's more like InteractsWithGlobalVariablesOutsideSourcesAndMaybeInputOutput
16:49:24 <lambdabot> Not in scope: `System.Environment.setArgs'
16:49:30 <lekro> thanks
16:49:38 <omnId> mauke: withArgs
16:49:39 <dons> yes, non-haskelly data that we don't trust
16:49:52 <mauke> @type System.Environment.withArgs
16:49:54 <lambdabot> forall a. [String] -> IO a -> IO a
16:50:20 <omnId> withArgs xs getArgs = return xs
16:51:15 <ToxicFrog> dons: well, sort of...I now have it for any one call to pmap, but with a hardcoded seed - or a seed that is only retrieved once by main, etc - pmap ends up with the same random list each time. So it needs a new generator each time it's called, and no matter how I turn it I end up with the implication that somewhere, I have a function in IO that's successively grabbing new random number generators (or seeds, o
16:51:15 <ToxicFrog> r whatnot) and passing them down to pmap
16:51:31 <dons> you can split randoms
16:51:35 <dons> to avoid needing a new seed
16:51:41 <ToxicFrog> And this feels wrong, but I can't figure out how it's meant to work right
16:52:10 <dons> you've got some every-changing list of randoms: there's no getting out of that -- it has be to threaded somehow
16:52:45 <omnId> it turns out that using the State StdGen monad would make it easier, but only after you've presumably already learned what's going on with the State monad's (>>=).
16:52:55 <dons> so you can thread the world state needed to find seeds (i.e. do it all in IO), or use a State monad (thread the tail of the list around), or just thread the list around manually
16:52:56 <ToxicFrog> What I'm actually doing is I have a function like:
16:53:08 <ToxicFrog> iter :: [Int] -> [Int]
16:53:45 <ToxicFrog> iter foo = if (completed foo) then foo else (iter (transform foo))
16:53:48 <omnId> ToxicFrog: it is perhaps easiest when you're learning just to use the IO variants of the random functions, so pmap would also be in IO
16:54:59 <ToxicFrog> Where transform is also of type [Int] -> [Int], and is probably pmap mutate_prob mutate_func foo
16:55:29 <ToxicFrog> And as I understand it, if pmap is in IO, this implies that all that is in IO, too
16:55:36 <omnId> yep.
16:55:42 <ToxicFrog> At which point I might as well be using an imperative language like Lua.
16:55:59 <omnId> or thread the StdGens all the way through
16:56:08 <omnId> or use State to thread for you.
16:56:13 <ToxicFrog> State?
16:56:22 <omnId> @src State
16:56:23 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:56:47 <dons> i usually just thread the tail of the randoms around
16:56:54 <dons> :t runState
16:56:56 <lambdabot> forall s a. State s a -> s -> (a, s)
16:57:00 <omnId> newtype State s a = State (s -> (a, s)) -- it's a type that represents functions that transform a state variable (s) and result in some a.
16:58:03 <dons> > runState (do randomSupply <- get ; return (take 10 randomSupply)  ) (randoms (mkStdGen 42)) -- seed in here.
16:58:04 <lambdabot>  ([-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-128485284...
16:58:12 <dons> > runState (do randomSupply <- get ; return (take 10 randomSupply)  ) (randoms (mkStdGen 42) :: [Word8]) -- seed in here.
16:58:13 <lambdabot>  ([207,79,133,250,236,55,126,31,18,179],[207,79,133,250,236,55,126,31,18,179,...
16:58:52 <dons> its a basic design thing: a global random generator means state threading, either implicit or explicit
16:59:33 <omnId> and, yes, state threading is a basic assumption of imperative languages.
16:59:36 <dons> the simplest way is to pass the remainder of the infinite randoms list around
16:59:46 <ToxicFrog> Yes. That I understand.
16:59:54 <dons> the next level of sophistication is to stick it in a nice pure State monad
17:00:03 <dons> to abstract out the parameter passing
17:00:14 <dons> ?go Random Supply site:haskell.org
17:00:17 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
17:00:28 <dons> hmm, there's a wiki page showing a few of the possible designs
17:00:31 <ToxicFrog> I would just rather not have to hand around the list and/or generator, as it makes my signatures way nastier and, in the end, probably removes any clarity of ease-of-dev benefit from using Haskell in the first place.
17:00:49 <dons> would you like example code? its really rather clean
17:00:59 <ToxicFrog> I would greatly appreciate that, yes.
17:01:05 <dons> i'm not quite sure what you're envisaging the code as
17:01:14 <yitz> No, it's not all that bad. But yes, using a State monad makes this nice in my opinion.
17:01:15 <dons> so perhaps an example, using explicit parameters, and then State
17:01:21 <dons> yeah
17:01:57 <dibblego> ?src Either return
17:01:58 <lambdabot> return        = Right
17:04:12 <dmwit> ?src Either fail
17:04:13 <lambdabot> fail msg      = Left (strMsg msg)
17:04:22 <dmwit> :t strMsg
17:04:25 <lambdabot> forall a. (Error a) => String -> a
17:06:53 <omnId> @instances Error
17:06:55 <lambdabot> IOError, [Char]
17:09:38 <hpaste>  dons pasted "a State threading a list of randoms" at http://hpaste.org/3293
17:09:45 <dibblego> ?check \f x -> Left (x :: Int) >>= (f :: Int -> Either Int Int) == Left x
17:09:46 <lambdabot>  Couldn't match expected type `Int -> Either Int Int'
17:10:22 <dons> ToxicFrog: so if you look at that hpaste, you see the 'main', in io, getting a new seed. then mapMaybe applies a function to a list, depending on a random Bool value threaded in the State
17:10:31 <dons> we run it a few times to see the randoms change
17:11:05 <dons> so all your code for manipulating stuff based on randoms is pure, everything past the zipWith
17:11:30 <omnId> more n = State (splitAt n)
17:12:01 <dons> yeah, refactor as you wish. you can compress it a fair bit more if needed
17:12:14 <ricky_clarkson> Would the digits of PI be an adequate random number generator?
17:12:32 <omnId> ricky_clarkson: they're always the same :)
17:12:41 <dons> so you'd need a random offset into the digits
17:12:50 <ricky_clarkson> omnId: What isn't?
17:12:53 <monochrom> I think it's an open question.
17:13:24 <ricky_clarkson> Well, if you find that they're not adequate, you're probably about to become famous.
17:13:47 <dons> ToxicFrog: so, any questions?
17:13:57 <monochrom> The actual open question is: lim n->oo (# of occurences of d in the first n digits)/n = 1/10?
17:14:32 <ToxicFrog> dons: lots, starting with what evalState and zipWith do, but I think I can hit the docs for those
17:14:41 <nornagon> dons: you couldn't really do that in a nice way, because finding the nth digit of pi is not an O(1) operation
17:14:45 <ToxicFrog> and mapMaybe can be called from pure code?
17:15:02 <nornagon> :t mapMaybe
17:15:04 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
17:15:07 <dons> its not that one. sorry
17:15:16 <dons> but we could use it
17:15:37 <dons> ToxicFrog: so evalState threads the randoms through your code
17:16:39 <omnId> *Main> :t mapMaybe
17:16:39 <omnId> mapMaybe :: (MonadState [Bool] t) => (a -> a) -> [a] -> t [a]
17:17:58 <_achilles_> is it possible to add two items in a list comprehension, without doing tuples?
17:18:26 <ddarius> > [x + y | x <- [1..10], y <- [10..14]]
17:18:26 <mauke> huh?
17:18:28 <lambdabot>  [11,12,13,14,15,12,13,14,15,16,13,14,15,16,17,14,15,16,17,18,15,16,17,18,19,...
17:18:56 <dons> > zipWith (+) [1..10] [10..20] -- zipwith strikes again
17:18:58 <lambdabot>  [11,13,15,17,19,21,23,25,27,29]
17:19:24 <dons> you can use parallel list comprehensions too, though they're newish
17:19:33 <_achilles_> [x : y | x <- [1..5], y <- [1..10]]
17:19:33 <omnId> the first does all combinations
17:19:46 <omnId> y would have to have type [Int]
17:19:46 <mauke> _achilles_: type error
17:19:51 <_achilles_> right
17:19:52 <chessguy> what are parallel list comprehensions?
17:19:57 <_achilles_> I'm asking if it's possible
17:19:58 <mauke> No instance for Num [Integer]
17:20:04 <Tac-Tics> > [[x, y] | x <- [1..5], y <- [1..10]]
17:20:07 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[2,1],[2,2],[2...
17:20:16 <_achilles_> hmmm
17:20:25 <omnId> > [x+y | x <- [1..3] | y <- [4..6]] -- chessguy
17:20:25 <lambdabot>  Parse error
17:20:39 <omnId> not the right syntax?  Never used 'em.
17:21:05 <chessguy> maybe they're in HEAD
17:21:09 <mauke> lambdabot doesn't parse the syntax
17:21:21 <_achilles_> I'm looking for a more...consise way to do it
17:21:23 <dons> that's the syntax, but its not h98
17:21:33 <dons> _achilles_: zipwith is the best i can think of
17:21:33 <omnId> parallel would give: [5,7,9] vs ordinary: [5,6,7,6,7,8,7,8,9]
17:21:34 <_achilles_> I want the lists concated
17:21:44 <mauke> > [1..5] ++ [1..10]
17:21:46 <lambdabot>  [1,2,3,4,5,1,2,3,4,5,6,7,8,9,10]
17:22:00 <dons> `add two items in a list comprehension' ?
17:22:04 <_achilles_> yeah, granted my example is more complicated than that
17:22:11 <_achilles_> hah
17:22:17 <_achilles_> now I get why you're confused
17:22:26 <_achilles_> apped two items in a list comprehension
17:22:30 <ricky_clarkson> Example input, example output.
17:22:31 <_achilles_> append***
17:22:41 <nornagon> :t (***)
17:22:43 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:22:49 <omnId> [ x : xs | x <- heads, xs <- tails] ?
17:22:49 <nornagon> :t append
17:22:52 <lambdabot> Not in scope: `append'
17:23:03 <nornagon> rats.
17:23:13 <chessguy> @type heads
17:23:15 <lambdabot> Not in scope: `heads'
17:23:21 <_achilles_> [x : x ^ 2 | x <- [1..4]]
17:23:24 <_achilles_> output
17:23:24 <nornagon> heads is equal to 'the list'
17:23:43 <_achilles_> [1,1,2,4,3,8,4,16]
17:23:49 <nornagon> @let heads l = l :: forall a. [a] -> [a]
17:23:50 <lambdabot>  Parse error
17:23:50 <omnId> > concatMap (\x -> [x, x^2]) [1..4]
17:23:52 <lambdabot>  [1,1,2,4,3,9,4,16]
17:24:01 <mauke> _achilles_: stop misusing :
17:24:02 <_achilles_> ahhhhh
17:24:04 <_achilles_> damnit!
17:24:13 <_achilles_> I knew I could do it with concatMap
17:24:20 <_achilles_> my brain's dead tonight
17:24:22 <_achilles_> thanks!
17:24:22 <omnId> > concat [[x, x^2] | x <- [1..4]]
17:24:23 <lambdabot>  [1,1,2,4,3,9,4,16]
17:24:36 <mauke> > [ y | x <- [1 .. 4], y <- [x, x ^ 2] ]
17:24:38 <_achilles_> ooo...beuty omnld
17:24:38 <lambdabot>  [1,1,2,4,3,9,4,16]
17:24:41 <mauke> surprise!
17:24:46 <omnId> oh, silly me
17:24:53 <_achilles_> beauty*
17:24:53 <Pseudonym> > foldr (.) [] [ (x:) . (x^2:) | x <- [1..4] ]
17:24:54 <lambdabot>  Couldn't match expected type `a -> c' against inferred type `[a1]'
17:25:17 <ricky_clarkson> > foldl (++) [] $ map (\x -> x : x^2) [1..4]
17:25:18 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
17:25:18 <lambdabot>       Expected...
17:25:34 <omnId> Pseudonym: s/[]/id/  then add [] to the end?
17:25:49 <Pseudonym> Yeah, that's what I just did.
17:25:49 <_achilles_> slick. thanks!
17:25:55 <Pseudonym> But I don't like it.
17:26:24 <mauke> > do x <- [1 .. 4]; y <- [x, x ^ 2]; return y
17:26:26 <lambdabot>  [1,1,2,4,3,9,4,16]
17:26:28 <ricky_clarkson> > foldl (++) [] $ map (\x -> [x,x^2]) [1..4]
17:26:30 <lambdabot>  [1,1,2,4,3,9,4,16]
17:26:34 <shachaf> ricky_clarkson: You mean (x : [x^2]) (or just [x,x^2]).
17:26:39 <Pseudonym> > [1..4] >>= \x -> [x,x^2]
17:26:41 <lambdabot>  [1,1,2,4,3,9,4,16]
17:26:53 <shachaf> Why foldl (++) []?
17:27:03 <omnId> foldr'd be much better
17:27:07 <Pseudonym> > concatMap (\x _> [x,x^2]) [1..4]
17:27:07 <lambdabot>  Parse error
17:27:13 <Pseudonym> > concatMap (\x -> [x,x^2]) [1..4]
17:27:13 <omnId> and anyway concat is already defined :)
17:27:14 <lambdabot>  [1,1,2,4,3,9,4,16]
17:27:22 <mauke> > [1 .. 4] >>= id &&& (^2)
17:27:23 <mauke> wait, no
17:27:23 <lambdabot>  Couldn't match expected type `[]' against inferred type `(,) t'
17:27:27 <ricky_clarkson> shachaf: What else?
17:27:37 <shachaf> ricky_clarkson: foldr (or concat).
17:27:40 <omnId> ricky_clarkson: foldr!
17:27:50 <mauke> > [1 .. 4] >>= sequence [id, (^2)]
17:27:52 <lambdabot>  [1,1,2,4,3,9,4,16]
17:28:02 <omnId> (xs ++ ys) ++ zs walks over xs twice vs. xs ++ (ys ++ zs)
17:28:24 <ricky_clarkson> shachaf: Same line, but s/foldl/foldr/ ?
17:28:29 <shachaf> @src concat
17:28:29 <lambdabot> concat = foldr (++) []
17:28:35 <shachaf> ricky_clarkson: But yes, otherwise.
17:28:45 <shachaf> ricky_clarkson: Since lists are lazy enough, foldr is better.
17:29:11 <shachaf> ricky_clarkson: http://haskell.org/haskellwiki/Stack_overflow
17:29:13 <lambdabot> Title: Stack overflow - HaskellWiki
17:29:24 <ricky_clarkson> Gotcha.
17:30:21 <shachaf> ricky_clarkson: If you were using foldl, you'd probably want foldl', anyway. Not that it really matters with lambdabot.
17:31:36 <monochrom> Yeah, lambdabot cuts your job short anyway. :)
17:32:38 <ricky_clarkson> I'm guessing concatMap is the same as concat map, but I'm struggling to actually see that.
17:32:53 <lambdabot> Don't tell them that. I'm gonna be asked so many homework questions. Sign.
17:33:00 <lambdabot> Sigh.
17:33:04 <shachaf> Wouldn't -O2 optimize it in this case?
17:33:18 <ddarius> @src concatMap
17:33:18 <lambdabot> concatMap f = foldr ((++) . f) []
17:33:22 <shachaf> ricky_clarkson: concatMap f xs = concat (map f xs)
17:33:27 <Pseudonym> >/msg lambdabot ?help check
17:33:36 <Pseudonym> D'oh.
17:33:55 <Pseudonym> ?check \f xs -> concatMap f xs == concat (map f xs)
17:33:56 <lambdabot>  Add a type signature
17:33:59 <ddarius> concatMap f = concat . map f
17:34:14 <Pseudonym> ?check \f xs -> concatMap (f::Integer->Integer) xs == concat (map f xs)
17:34:15 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Integer'
17:34:26 <Pseudonym> ?check \f xs -> concatMap (f::Integer->Integer) (xs::Integer) == concat (map f xs)
17:34:27 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Integer'
17:34:31 <shachaf> concatMap = (concat .) . map
17:34:35 <Pseudonym> ?check \f xs -> concatMap (f::Integer->Integer) (xs::[Integer]) == concat (map f xs)
17:34:36 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Integer'
17:34:40 <Pseudonym> Grrr.
17:34:42 <ddarius> :t concatMap
17:34:44 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
17:34:52 <yitz> @pl concatMap
17:34:53 <lambdabot> (=<<)
17:35:04 <ddarius> shachaf: Indeed, but I think the concat . map f is perhaps the clearest form
17:35:04 <wolverian> heh
17:35:13 <shachaf> ddarius: Yes.
17:35:16 <Pseudonym> ?check (\f xs -> concatMap f xs == concat (map f xs)) :: (Int -> Int) -> [Int] -> Bool
17:35:16 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Int'
17:35:25 <shachaf> ddarius: Or the concatMap f xs = ... version.
17:35:32 <Pseudonym> Oh.
17:35:42 <Pseudonym> ?check (\f xs -> concatMap f xs == concat (map f xs)) :: (Int -> [Int]) -> [Int] -> Bool
17:35:47 <lambdabot> Terminated
17:35:50 <ddarius> If we expand concat into foldr (++) [], we get foldr (++) [] . map f which by foldr/map is foldr ((++) . f) []
17:35:51 <Pseudonym> Hrm.
17:35:54 <ddarius> @src concatMap
17:35:54 <lambdabot> concatMap f = foldr ((++) . f) []
17:37:58 <ddarius> That is what "point-free" style is supposed to look like.
17:38:19 <Pseudonym> ?pl \f -> foldr ((++).f) []
17:38:19 <lambdabot> flip foldr [] . ((++) .)
17:40:15 <LoganCapaldo> this is madness
17:40:22 <LoganCapaldo> this is blaspemy
17:40:31 <LoganCapaldo> this is POINTFREE!
17:40:50 <mauke> SPARTA CALCULUS
17:40:53 <ricky_clarkson> I love it.
17:41:12 <LoganCapaldo> I have yet to wear that out for myself
17:41:27 <LoganCapaldo> which is pretty impressive I think, since its so very formulaic
17:42:26 <monochrom> Sparta?
17:46:39 <Beelsebob> gyah
17:46:47 <Beelsebob> need a good example of patern matching, without recursion
17:47:15 <LoganCapaldo> @src isJust
17:47:15 <lambdabot> isJust Nothing = False
17:47:15 <lambdabot> isJust _       = True
17:47:28 <LoganCapaldo> that's not recursive
17:47:43 <Beelsebob> hmm, could work
17:47:47 <LoganCapaldo> @src head
17:47:47 <lambdabot> head (x:_) = x
17:47:47 <lambdabot> head []    = undefined
17:47:53 <LoganCapaldo> @src tail
17:47:54 <lambdabot> tail (_:xs) = xs
17:47:54 <lambdabot> tail []     = undefined
17:48:05 <LoganCapaldo> @src maybe
17:48:05 <lambdabot> maybe n _ Nothing  = n
17:48:05 <lambdabot> maybe _ f (Just x) = f x
17:48:58 <LoganCapaldo> @src either
17:48:58 <lambdabot> either f _ (Left x)     =  f x
17:48:58 <lambdabot> either _ g (Right y)    =  g y
17:49:09 <Beelsebob> yeh, that works
17:49:14 <Beelsebob> thanks
17:49:14 <LoganCapaldo> etc. etc.
17:49:22 <Beelsebob> don't know why my brain couldn't come up with any of them
17:49:34 <Beelsebob> I was coming up with contrived examples involving witches and ducks
17:49:41 <LoganCapaldo> LOL
17:49:48 <LoganCapaldo> I want to see those examples!
17:49:53 <Beelsebob> hehe
17:50:07 <Beelsebob> I couldn't express it in a purely pattern matching way :(
17:50:08 <monochrom> witches I understand. ducks?
17:50:24 <Beelsebob> monochrom: watch monty python and the holy grail
17:50:25 <LoganCapaldo> if she weighs the same as a duck...
17:50:32 <LoganCapaldo> then
17:50:36 <LoganCapaldo> She's a witch!
17:50:41 <LoganCapaldo> burn her burn her!
17:50:53 <Pseudonym> That's the flaw with duck typing.
17:50:55 <monochrom> OK, I haven't watched monty python anyway. BTW, I haven't watched python anything either.
17:51:03 <Beelsebob> it follows the best piece of un-logic in existance
17:51:12 <Pseudonym> If it weighs the same as a duck, it may be a witch.
17:51:17 <Beelsebob> how to identify a witch...
17:51:18 <yitz> ni
17:51:25 <Beelsebob> what do you do with witches? Burn them
17:51:35 <Beelsebob> why do witches burn? Because they're made of wood
17:51:37 <Pseudonym> Build a bridge out of them?
17:51:38 <monochrom> data She = Witch | Duck; f Witch = True; f Duck = false
17:51:59 <LoganCapaldo> small stones!
17:52:27 <Beelsebob> what else does wood do? Float
17:52:34 <Beelsebob> what else floats? Ducks
17:52:46 <Beelsebob> so if something weighs the same as a duck, it must be a witch
17:52:47 <Beelsebob> :)
17:52:55 <yitz> favoriteColor = const Red
17:53:19 <monochrom> If something has the same density as a Duck, then it's a Float?
17:53:52 <monochrom> @type isIEEE
17:53:54 <lambdabot> forall a. (RealFloat a) => a -> Bool
17:54:03 <monochrom> And so it's also a RealFloat?
17:54:06 <Sgeo> const? Sorry, it's been a while since I've worked with Haskell
17:54:17 <Sgeo> @type const
17:54:19 <lambdabot> forall a b. a -> b -> a
17:54:27 <mrd> @djinn a -> b -> a
17:54:27 <lambdabot> f a _ = a
17:54:31 <Sgeo> oh
17:54:31 <ddarius> @. djinn type const
17:54:33 <lambdabot> f a _ = a
17:56:28 <LoganCapaldo> I like constantly
17:56:37 <LoganCapaldo> constantly True
17:56:45 <LoganCapaldo> but that's a lot of typing
17:56:47 <mauke> forevermore
17:56:52 <LoganCapaldo> oooo
17:56:55 <LoganCapaldo> pretty
17:57:04 <ddarius> @quote λ
17:57:05 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:57:19 <LoganCapaldo> and that's impressive
17:57:23 <LoganCapaldo> because penguins lack fingers
17:57:33 <LoganCapaldo> not to mention opposable thumbs
17:57:34 <Beelsebob> @quote+ λx x
17:57:34 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
17:57:38 <ToxicFrog> Argh.
17:57:47 <Beelsebob> bah
17:57:50 <mauke> @quote
17:57:51 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
17:57:52 <Beelsebob> how do you add a quote
17:58:07 <shachaf>  @remember
17:58:08 <Beelsebob> and can we make the quote system into a complete term rewriter :D
17:58:10 <Sgeo> @quote Sgeo
17:58:10 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:58:12 <ToxicFrog> I keep getting "cannot construct the infinite type a -> [a]"
17:58:12 <LoganCapaldo> @remember Beelsebob how do you add a quote
17:58:12 <lambdabot> Done.
17:58:14 <Sgeo> @quote goldilocks
17:58:15 <lambdabot> No quotes match. Are you on drugs?
17:58:23 <ddarius> There's no consistency in lambdabot's user interface
17:58:32 <Beelsebob> indeed
17:58:33 <LoganCapaldo> @ is pretty consistent
17:58:42 <ddarius> ?bot
17:58:43 <lambdabot> :)
17:58:44 <mauke> ?vixen is it?
17:58:44 <Beelsebob> > no "it's not"
17:58:44 <lambdabot> yeah, it is
17:58:45 <lambdabot>   Not in scope: `no'
17:58:45 <LoganCapaldo> except you can use ? instead
17:58:56 <Pseudonym> Oooh, another Monty Python reference.
17:58:56 <LoganCapaldo> and theres > which is short for @run
17:59:10 <Pseudonym> "What's that on the IRC channel?"  "Looks like a penguin!"
17:59:34 <mauke> @eval (\x -> x x) (\x -> x x)
17:59:45 <Pseudonym> :t \x -> x x
17:59:47 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
17:59:47 <lambdabot>     Probable cause: `x' is applied to too many arguments
18:00:03 <ddarius> :t \(x :: forall a.a -> a) -> x x
18:00:05 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
18:00:12 <ToxicFrog> dons: still around?
18:00:34 <Pseudonym> :t let f = \(x :: forall a. a -> a) -> x x in f f
18:00:36 <lambdabot>     Couldn't match expected type `a' (a rigid variable)
18:00:37 <lambdabot>            against inferred type `forall a1. a1 -> a1'
18:01:50 <ToxicFrog> Hrm. At first I thought the problem was recursion, but even with a non-recursive function it blows up
18:08:06 <ToxicFrog> ...and if I give it an explicit signature, I get "cannot match expected type State s t against inferred type [Integer]" in the caller, and "cannot match expected type Integer against inferred type [Integer]" in the definition.
18:08:18 <mauke> you're doing it wrong
18:08:44 <vonBergmann> i'd like to fold the min function over every second element of a list of tuples and return that tuple
18:08:47 <vonBergmann> foldr1 min [(8,2),(3,4),(5,6)]
18:09:00 <ToxicFrog> mauke: I noticed.
18:09:01 <vonBergmann> is pretty close but it's folding min over the first element and not the second
18:09:09 <mauke> > minimumBy snd [(8,2),(3,4),(5,6)]
18:09:10 <lambdabot>      Occurs check: cannot construct the infinite type:
18:09:10 <lambdabot>       b = (a, b) -> Or...
18:09:15 <mauke> argh, right
18:09:27 <mauke> > minimumBy (comparing snd) [(8,2),(3,4),(5,6)]
18:09:29 <lambdabot>  (8,2)
18:09:44 <vonBergmann> actually i lied, i'd actually like to fold over triples
18:09:47 <vonBergmann> over the third element
18:10:16 <vonBergmann> can i access that third element without pattern matching?
18:10:19 <mauke> > minimumBy (comparing (\(_,_,x) -> x)) [(8,2,"foo"),(3,4,"bar"),(5,6,"baz")]
18:10:21 <lambdabot>  (3,4,"bar")
18:10:57 <ToxicFrog> It works fine as long as monads aren't involved, but that breaks the randomness. Aaaaaaaagh
18:11:30 <vonBergmann> ok not quite sure i understand the example but i study and work through it for a bit, thanks mauke
18:12:01 <mauke> :t minimumBy
18:12:04 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
18:12:14 <vonBergmann> :t comparing
18:12:16 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
18:14:32 <ToxicFrog> ...ok, what the fuck?
18:14:45 <ToxicFrog> If I take the code that works without a signature...
18:15:01 <ToxicFrog> Ask ghci for the type (which is 'mutate :: (Ord t, MonadState [t] t1, Num a, Fractional t) => [a] -> t1 [a]')...
18:15:05 <ToxicFrog> ...and add that to the source...
18:15:07 <newsham> ddarius:  falseElim np2false = orElim exclMiddle (\p -> p) (\np -> absurd (np2false np))
18:15:16 <ToxicFrog> It says it's an illegal type declaration.
18:15:16 <vonBergmann> i've never used minimumBy before and looking it up at sites like: http://www.zvon.org/other/haskell/Outputglobal/index.html isn't very helpful because the documentation is incomplete.... what are some better sources?
18:15:18 <lambdabot> Title: Haskell
18:15:22 <conal> does anyone have a pretty printer for haskell code that handles precedence (paren insertion)?
18:17:05 <mauke> @source Data.List
18:17:06 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
18:17:11 <mauke> @docs Data.List
18:17:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
18:20:47 <vonBergmann> sorry another dumb question, so is the best source for all the documentation at haskell.org? how does looking up haskell documentation compare to something like the java api?
18:21:18 <vonBergmann> is minimumby not available at zvon because it is relatively new?
18:21:23 <mauke> I don't know about java but I usually start at http://www.haskell.org/ghc/docs/latest/html/libraries/
18:30:18 <newsham> http://www.thenewsh.com/%7Enewsham/formal/curryhoward/Theorems3.hs
18:30:21 <lambdabot> http://tinyurl.com/2zhgbh
18:32:11 <ToxicFrog> Maybe I should just give up on this and return to Haskell later, for a project that doesn't need random numbers.
18:32:17 <monochrom> I have never heard of zvon.
18:32:20 * Philippa wishes she could get away with writing lhs `infix' p` rhs as a parser :-(
18:32:49 <Philippa> (where p would be dropped, lhs and rhs are arbitrary parsers - the problem is that you can only do `<identifier>`)
18:32:57 <Philippa> and it'd be cute
18:33:11 <shachaf> Philippa: There was that trick with... -: and :-, I think?
18:33:32 <Philippa> yeah, that's getting obscure enough not to be worth it in terms of readability though
18:36:33 <newsham> i wish you could put bars/superscripts/hats over operators to do something like that.
18:36:45 <newsham> ie.  +^ = liftM 2 (+)
18:37:21 <shachaf> newsham: That's a slippery slope that leads to J-land.
18:37:52 <newsham> I dont know J, but I've been looking at funmath (notation, not computer language) and i like it
18:38:23 <newsham> they have symbols above binops for lifting into (->) in various ways
18:38:38 <newsham> (lift binary, lift just left section, lift right section)
18:40:00 <FMota> hey guys / gals
18:40:26 <FMota> is there a way to cut off from a list when a certain condition is met?
18:40:42 <newsham> takeWhile / dropWhile?
18:40:44 <mauke> takeWhile
18:40:46 <FMota> I mean, a way to extract the first x values of the list, that depends on the values
18:40:48 <FMota> ah, ty
18:41:09 <mauke> > takeWhile even [ 2 .. 20 ]
18:41:11 <lambdabot>  [2]
18:41:16 <newsham> > dropWhile (<10) [1..30]
18:41:17 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]
18:41:53 * FMota is doing the euler project :)
18:47:03 * SamB wonders how he came to be a latex user
18:47:07 <FMota> ...and what about a function to see if an item is in a list?
18:47:34 <LoganCapaldo> @type find
18:47:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
18:47:40 <LoganCapaldo> @type filter
18:47:43 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
18:47:44 <idnar> :t elem
18:47:47 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
18:47:49 <FMota> aha
18:47:50 <LoganCapaldo> @type any
18:47:52 <FMota> thank you!
18:47:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:47:54 <FMota> elem :)
18:48:36 <idnar> > let l = [1..10] in (elem 5 l, elem 15 l)
18:48:41 <newsham> ?docs Data.List
18:48:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
18:48:42 <lambdabot>  (True,False)
18:49:09 <LoganCapaldo> I wonder if elem is written with any or elemIndex?
18:49:14 <LoganCapaldo> @src elem
18:49:14 <lambdabot> elem x    =  any (== x)
18:50:15 <chessguy> @type elemIndex
18:50:17 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
18:50:30 <chessguy> @src elemIndex
18:50:30 <lambdabot> elemIndex x     = findIndex (x==)
18:50:41 <chessguy> @src findIndex
18:50:42 <lambdabot> findIndex p     = listToMaybe . findIndices p
18:51:04 <chessguy> quite a few levels of abstraction
18:51:12 <chessguy> @src findIndices
18:51:12 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
18:51:50 <chessguy> @src listToMaybe
18:51:50 <lambdabot> listToMaybe []        =  Nothing
18:51:51 <lambdabot> listToMaybe (a:_)     =  Just a
18:53:50 <mudge> hey chessguy,  hey LoganCapaldo
18:54:09 <chessguy> 'evening, sir
18:54:31 <LoganCapaldo> hola
18:56:41 <ToxicFrog> Argh. Bollocks to this, I don't have time to sort it out, I'll come back to Haskell for the next project.
18:57:09 <chessguy> what sort of project are you working on, ToxicFrog ?
18:57:41 <LoganCapaldo> a frog antitoxin?
18:57:46 <ToxicFrog> Genetic algorithms.
18:57:52 <ToxicFrog> For which I need random numbers.
18:57:54 <ToxicFrog> Which are made of pain.
18:58:00 <chessguy> lol
18:58:15 <chessguy> i've done some working on genetic programming in haskell
18:58:22 <Pseudonym> Oh, we have a mechanism for pain in Haskell.
18:58:23 <chessguy> never did find a way to do it that satisfied me
18:58:26 <ToxicFrog> The whole thing is pretty clean and elegant in Haskell until I get to the random numbers.
18:58:29 <Pseudonym> http://andrew.bromage.org/unsafe.jpeg
18:58:31 <chessguy> @quote pain
18:58:31 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
18:58:32 <LoganCapaldo> unsafePerformTorture
18:59:12 <LoganCapaldo> the # is the perfect touch
18:59:17 <Pseudonym> Yeah.
18:59:20 <ToxicFrog> Then I feel sorrow.
18:59:23 <ToxicFrog> So much sorrow./
18:59:49 <Pseudonym> I did some genetic programming, but my mutation/breeding/whatever stuff was pretty simple.
18:59:57 <Pseudonym> I thought it was pretty elegant.
19:00:04 <Pseudonym> Probably because of the simplicity.
19:00:08 <ToxicFrog> So's mine, but it needs randoms.
19:00:12 <chessguy> Pseudonym, i'd like to see that sometime
19:00:14 <LoganCapaldo> What about the Random monad? does thtat ease the pain?
19:00:28 <ToxicFrog> The Random monad is the source of the pain
19:01:01 <ToxicFrog> If I use non-monadic mkStdGen it works fine, but it's also not usefully random.
19:01:22 <LoganCapaldo> you could use newStdGen
19:01:33 <LoganCapaldo> but then you're stuck in IO instead of Random
19:01:36 <Pseudonym> IIRC, I just put everything in the IO monad.
19:01:43 <Pseudonym> Or some transformer on top of IO.
19:01:51 <ToxicFrog> If I use newStdGen, it works great until I try actually writing non-trivial code that uses it.
19:02:02 <ToxicFrog> At which point the type-inference engine develops a hunger for human flesh.
19:02:19 <Pseudonym> unsafeTypeChecker
19:02:23 <chessguy> oh, that's what unsafeWoodenStake is for
19:02:42 <Pseudonym> ?type Braanes!
19:02:44 <lambdabot> parse error (possibly incorrect indentation)
19:03:26 <dibblego> why is there no instance for Maybe?
19:03:26 <chessguy> braanes?
19:03:29 <dibblego> of Arbitrary
19:03:35 <ToxicFrog> I mean, ok, I have a function pmap :: Float -> (a -> b) -> [a] -> [b], which is a probabilistic version of map
19:03:41 <mrd> oh no, the monad has tasted human blood!
19:04:02 <ToxicFrog> I have a function mutate, called from main as ( do a <- mutate [0,0,0,0,0,0,0,0]; return a )
19:04:14 <monochrom> I advocate infinite lists. I don't just mean use an infinite list of random numbers. Much much more than that. Your whole algorithm your whole program, is structured around infinite lists. The fact that random numbers are found in an infinite list is just a small corollary of that. It will be beauitful and stateless. It is also a total paradigm shift.
19:04:16 <ToxicFrog> mutate li = pmap 0.5 (+1) li -- this works
19:04:34 <FMota> :t take
19:04:36 <lambdabot> forall a. Int -> [a] -> [a]
19:04:37 <FMota> :t drop
19:04:39 <lambdabot> forall a. Int -> [a] -> [a]
19:05:05 <ToxicFrog> mutate li = if (head li) == 1 then li else pmap 0.5 (+1) li -- this causes a "cannot construct the infinite type a -> [a]" error
19:05:16 <monochrom> IOW use infinite lists for everything else in your program. That's what I advocate.
19:05:27 <ToxicFrog> Note that as long as random isn't involved, the above declaration of mutate works fine
19:06:27 <chessguy> out of curiosity, what's the 0.5 there?
19:07:13 <ToxicFrog> Probability of application to each list element.
19:07:27 <shachaf> ToxicFrog: What is mutate's type supposed to be?
19:07:34 <ToxicFrog> pmap prob func list is the same as map func list, except that func only has a prob chance of being applied.
19:07:55 <ToxicFrog> ...which I suppose means that the signature is actually Float -> (a -> a) -> [a] -> [a], but that's fine
19:08:03 <shachaf> ToxicFrog: That looks like it should work, can you give more context?
19:08:09 <chessguy> @type mutate li@(1:xs) = li; mutate li = ?pmap 0.5 (+1) li
19:08:11 <lambdabot> parse error on input `='
19:08:29 <ToxicFrog> Hang on, I'll pastebin it.
19:08:38 <mauke> @type \li -> if head li == 1 then li else ?pmap 0.5 (+1) li
19:08:40 <lambdabot> forall a t a1. (Num a, ?pmap::t -> (a1 -> a1) -> [a] -> [a], Fractional t, Num a1) => [a] -> [a]
19:08:45 <monochrom> Gosh! ContT r m a ≅ Cont (m r) a. I never noticed it, but it's now staring at me.
19:08:49 <LoganCapaldo>  I was gonna say shouldn't the type be like Float -> (a -> b) -> [a] -> [Either a b]
19:09:44 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3294
19:10:12 <ToxicFrog> The first three functions are based on http://hpaste.org/3293 , kindly provided by dons
19:11:06 <shachaf> ToxicFrog: pmap's type is the problem.
19:11:22 <shachaf> ToxicFrog: What you have is pmap :: (Ord a1, MonadState [a1] t) => a1 -> (a -> a) -> [a] -> t [a]
19:11:35 <shachaf> You aren't runState-ing it.
19:11:44 <chessguy> ToxicFrog, type annotations are your friends
19:11:53 <shachaf> ToxicFrog: And what chessguy said.
19:12:30 <chessguy> stop fighting the type system
19:12:37 <hpaste>  omnId annotated "(no title)" with "typechecks." at http://hpaste.org/3294#a1
19:12:45 <shachaf> @wiki New monads/MonadSupply
19:12:45 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadSupply
19:12:50 <shachaf> Maybe that's relevant?
19:12:50 <omnId> diff: http://hpaste.org/3294/diff?old=0&new=1
19:13:54 <shachaf> Yes, return li is better, of course.
19:14:04 <shachaf> Since mutate is also in State.
19:14:20 <chessguy> glguy!
19:14:26 <omnId> pmap results in a State action, but mutate resulted in either a list, or a list in a State action, you have to return the first case into State.
19:14:43 <glguy> \o/
19:15:11 <chessguy> how's things in galois-land?
19:15:19 <glguy> green
19:15:29 <chessguy> umm
19:15:33 <glguy> Why do you ask? looking for interviews? ;)
19:15:34 <ToxicFrog> ...it would probably help here if I understood (1) monads in general (2) State in specific
19:15:35 <chessguy> i guess that's a good thing..
19:15:40 <chessguy> .lol
19:15:48 <chessguy> i wouldn't waste their time or mine :)
19:15:53 <chessguy> not yet anyway. maybe someday
19:15:57 <omnId> ToxicFrog: the thing to understand is that [a] /= State [Bool] [a]
19:16:05 <glguy> well, at least you're considerate then!
19:16:24 <omnId> s/Bool/Double/
19:16:32 <chessguy> besides, i think my fiancee would kill me if i told her i was moving again :)
19:16:35 <omnId> return puts your [a] into the State [Double] monad
19:17:28 <omnId> in the expression: (if (head li) == 1 then li else pmap 0.5 (+1) li), the 'then' case, "li" has type [a], but the 'else' case "pmap 0.5 (+1) li" has type State [Double] [a]
19:17:32 <omnId> they don't match
19:17:34 <glguy> Yeah, I'm definitely not an Oregonian :)
19:17:36 <ToxicFrog> Ok. And State [Double] [a] is a monad representing something with a persistent state of type [Double], and a return value from some state-specific computation of type [a]?
19:17:44 <shachaf> ToxicFrog: Try reimplementing State yourself -- it's helpful in understanding it.
19:18:14 <chessguy> ToxicFrog, no, State is a monad. State [Double] [a] is not
19:18:24 <omnId> ToxicFrog: yep, though the word "monad" specifically refers the the unapplied type State [Double], the State [Double] [a] is called an action.
19:18:28 <shachaf> chessguy: State [Double] is a monad.
19:18:30 <chessguy> err, right
19:18:38 * chessguy goes back to feeling dumb
19:18:43 <omnId> :)
19:18:54 <LoganCapaldo> State is walking down the road towards being a monad :)
19:19:06 <LoganCapaldo> it hasn't met it's body s yet :)
19:19:12 <LoganCapaldo> s/body/buddy/
19:19:14 <chessguy> a curried monad? :)
19:19:25 <shachaf> Yum.
19:19:56 <ToxicFrog> Aah. Ok.
19:20:19 <ToxicFrog> So State [Double] [a] is an action that, when...executed? updates its internal [Double] and returns an [a]?
19:20:28 <omnId> exactly!
19:20:55 <chessguy> well, of course, it may or may not have an effect on its state
19:21:00 <LoganCapaldo> (might update the [Double])
19:21:09 <omnId> the do block hooks together the actions and they are executed when the top level does a runState and passes in the initial state value.
19:21:45 <omnId> @src State (>>=)
19:21:45 <lambdabot> Source not found. My pet ferret can type better than you!
19:21:58 <mauke> @src State >>=
19:21:59 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:21:59 <shachaf> ToxicFrog: State [Double] [a] is a function :: [Double] -> ([a],[Double]), wrapped up in a State type.
19:22:18 <ToxicFrog> Ok.
19:22:29 <omnId> m >>= k = State (\s -> let (a, s') = runState m in runState (k a) s')
19:22:32 <shachaf> newtype State s a = State (s -> (a,s))
19:22:38 <dons> ?unmtl State [Double] [a]
19:22:38 <lambdabot> [Double] -> ([a], [Double])
19:22:38 <omnId> (I hope I didn't make any errors.
19:22:53 <ToxicFrog> And pmap has this type? So when pmap is evaluated, it generates not an [a], but an action which must be executed to produce an [a]?
19:22:55 <shachaf> runState (State x) = x
19:23:03 <omnId> ToxicFrog: yes
19:23:04 <shachaf> ToxicFrog: Yes.
19:23:06 <shachaf> ToxicFrog: Just like IO.
19:23:21 <ToxicFrog> I haven't used IO, I've never needed it.
19:23:22 <shachaf> ToxicFrog: (Or any monad.)
19:23:27 <ToxicFrog> But ok, this is starting to make sense.
19:23:42 <shachaf> ToxicFrog: Your main is :: IO ().
19:23:42 <LoganCapaldo> heh never needed IO. Impressive :)
19:23:51 <ToxicFrog> Ok, never explicitly used IO.
19:23:56 <ToxicFrog> Apart from that print.
19:23:57 <omnId> ToxicFrog: though in actuality, the return type is even more general: MonadState [Double] m => m [a], meaning that the monad type itself can be State [Double], or something else that behaves the same.
19:23:58 <Tela> ToxicFrog: You implicitly use IO in every program. Your main function is IO () and it's "executed" when the program runs.
19:24:07 <shachaf> And newStdgen, and print.
19:24:25 <ToxicFrog> So...could I, in theory, wrap pmap in a function that executes the action returned by pmap, and returns the result of that action?
19:24:38 <shachaf> ToxicFrog: Yes.
19:24:53 <shachaf> ToxicFrog: But that wouldn't have much point, possibly.
19:24:58 <ToxicFrog> ...why not
19:24:58 <ToxicFrog> ?
19:25:03 <omnId> pmap' p f xs ds = runState (pmap p f xs) ds
19:25:06 <Tela> ToxicFrog, but then realize that you'll have to give it a random seed in order to execute your state
19:25:06 <shachaf> ToxicFrog: Since there's no point in returning the [Double] if you don't use that.
19:25:12 <FMota> question: how can I se large integers in Haskell?
19:25:16 <FMota> *I use
19:25:19 <shachaf> FMota: Integer.
19:25:21 <FMota> do I need some import?
19:25:26 <mauke> just do it
19:25:26 <mauke> no
19:25:26 <ToxicFrog> shachaf: I would return the result, not the updated state
19:25:28 <LoganCapaldo> > 348345884537573857387575843758347857385782378123787258578345 :: Integer
19:25:30 <lambdabot>  348345884537573857387575843758347857385782378123787258578345
19:25:39 <FMota> mk
19:25:43 <mauke> ToxicFrog: if you drop the updated state, why use State at all?
19:25:45 <chessguy> > maxBound :: Int
19:25:46 <omnId> pmap' p f xs ds = evalState (pmap p f xs) ds -- evalState ignores the final state value
19:25:47 <lambdabot>  2147483647
19:25:50 <LoganCapaldo> > 348345884537573857387575843758347857385782378123787258578345588846 -- no type annotation necessary
19:25:51 <lambdabot>  348345884537573857387575843758347857385782378123787258578345588846
19:25:54 <ToxicFrog> mauke: I thought State updated it!
19:26:00 <FMota> > succ (12123412312414324234 :: Integer)
19:26:01 <shachaf> ToxicFrog: So there's no point in writing pmap in terms of State.
19:26:01 <lambdabot>  12123412312414324235
19:26:08 <mauke> ToxicFrog: yes, and when you use runState, it gives you the result
19:26:12 <mauke> there is no magic here
19:26:13 <ToxicFrog> ...but...that doesn't make any sense, from what you said earlier...
19:26:16 <shachaf> LoganCapaldo: That's just because of defaulting.
19:26:24 <SamB> heh. now that's overkill - TeX uses units smaller than the wavelengths of visible light
19:26:27 <LoganCapaldo> But that's the default default though right?
19:26:43 <Pseudonym> SamB: But I want to use TeX for nanolithography!
19:26:45 <omnId> ToxicFrog: I think he's saying that you *don't* want to drop the state value, since then it would be incorrect.
19:26:48 <shachaf> ToxicFrog: It doesn't *really* update it.
19:26:49 <chessguy> @quote magic
19:26:49 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
19:27:05 <omnId> ToxicFrog: the State monads take care of the passing around for you.
19:27:12 <SamB> Pseudonym: well, there's always magnification anyway
19:27:18 <Pseudonym> I guess.
19:27:23 * Pseudonym grumbles... not the same...
19:27:44 <LoganCapaldo> State is sort of like composing all your functions together instead of executing them and at the very end you run the giant function with some intial state
19:28:00 <chessguy> @index modify
19:28:00 <lambdabot> Control.Monad.State, Control.Monad.RWS
19:28:04 <omnId> s/sort of like/like/
19:28:05 <shachaf> LoganCapaldo: Again, just like IO.
19:28:33 <chessguy> err, why isn't modify listed on http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Lazy.html ?
19:28:35 <lambdabot> http://tinyurl.com/2dn8t6
19:28:37 <LoganCapaldo> yeah but maybe if it gets said enough different ways one of them will click for ToxicFrog :)
19:29:00 <omnId> @index modify
19:29:00 <lambdabot> Control.Monad.State, Control.Monad.RWS
19:29:07 <omnId> chessguy: 'twould seem not to be there
19:29:11 <chessguy> hm, i actually rather like LoganCapaldo's way of saying it
19:29:32 <shachaf> chessguy: Maybe it's in Control.Monad.State.Class?
19:29:32 <chessguy> omnId, but it's not at http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
19:29:34 <chessguy> either
19:29:34 <lambdabot> http://tinyurl.com/yx2t8w
19:29:38 <shachaf> If such a thing exists?
19:29:45 <ToxicFrog> ...all I want is a probabilistic map function that I can call from pure code...
19:29:47 * ToxicFrog weeps
19:29:55 <mauke> ToxicFrog: no such thing
19:29:55 <chessguy> oh, there it is
19:29:58 <chessguy> weird
19:30:11 <omnId> chessguy: -Class?
19:30:15 <mauke> rand() isn't pure
19:30:18 <Tela> ToxicFrog: That's just the point. Code purity ensures that such a thing can't exist.
19:30:22 <chessguy> ToxicFrog, random numbers are inherently impure
19:30:47 <chessguy> omnId, it's at http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Class.html
19:30:48 <lambdabot> http://tinyurl.com/37tgec
19:31:00 <Pseudonym> I wonder if this would be better expressed as an Arrow.
19:31:13 <Pseudonym> Which is close enough to a "function".
19:31:14 <ToxicFrog> ...so, wait.
19:31:17 <Tela> ToxicFrog: the neat part is that once you /do/ refactor this problem into something that works with Haskell, you'll very clearly be able to see exactly what parts of your problem are pure.
19:31:32 <mauke> reading existentials is hard. let's go shopping!
19:31:41 <ToxicFrog> If I need random numbers at a low level, everything above that becomes impure?
19:31:52 <chessguy> @remember mauke reading existentials is hard. let's go shopping!
19:31:53 <lambdabot> Done.
19:32:04 <mauke> depends
19:32:16 <Tela> ToxicFrog: As long as your random parts don't preserve referential transparency
19:32:26 <mauke> "random" numbers need state. you can do explicit state passing.
19:32:31 <omnId> ToxicFrog: usually people do the impure stuff once on top and generate what they need, then they pass it all to pure code that works on pure values.
19:32:31 <chessguy> couldn't ToxicFrog just get a random list of numbers in main and pass it into the rest of the program?
19:32:43 <omnId> chessguy: yes
19:32:54 <FMota> :t take
19:32:56 <lambdabot> forall a. Int -> [a] -> [a]
19:32:58 <omnId> chessguy: though State makes the passing part less tedious.
19:33:02 <FMota> :/
19:33:02 <ToxicFrog> I mean, I have an iteration function, which is defined in terms of a transition function, which is defined in terms of a mutation function, which is defined in terms of pmap, which needs random numbers.
19:33:14 <FMota> is there a way to do take with Integers instead of with Ints ?
19:33:18 <ToxicFrog> And it needs different random numbers each time, as otherwise the mutation function is not useful.
19:33:19 <FMota> or do I have to make my own? :/
19:33:20 <omnId> FMota: genericTake
19:33:21 <sorear> :t genericTake
19:33:21 <mauke> ToxicFrog: you'll have to pass some sort of state through all of that
19:33:23 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
19:33:25 <FMota> ty
19:34:10 <ToxicFrog> mauke: so, basically, I'm in function signature hell, as I have to pass and return the remainder of the list of random numbers through way too many layers of evaluation for comfort.
19:34:30 <FMota> ugh
19:34:31 <mauke> ToxicFrog: yes
19:34:35 <Tela> You're thinking that just one part of your program requires inpurity, but really the entire algorithm you just described is impure. In some sense, the core of your program is impure, but you'll likely be able to extract a lot of pure pieces.
19:34:36 <FMota> genericTake not in scope
19:34:37 <mauke> or you could hide it behind State
19:34:57 <mauke> you'll still have to tag your State-using functions with State
19:35:05 <mauke> @index genericTake
19:35:06 <lambdabot> Data.List
19:35:12 <FMota> ty
19:35:23 <omnId> ToxicFrog: if your algorithm needs a source of random numbers, they have to come from somewhere.  You can think of most imperative languages as always recieving the state of the real world as an argument, so they can interact with it, then always returning an updated real world.
19:35:28 <ToxicFrog> Tela: well, yes, in that only two operations in the entire program (breed and mutate) need randomness, but the entire program is defined in terms of those operations.
19:35:50 <FMota> well, now the program doesn't stop, but at least it runs ;)
19:36:21 <Tela> ToxicFrog Yeah, so your entire program needs to maintain state else it'll repeat itself.
19:36:22 <ToxicFrog> mauke: see, that's what dons was trying to help me with earlier. However, while I now have a better understanding of what State is thanks to your-plural efforts, I don't fully grasp how to use it.
19:36:32 <ToxicFrog> Nor how passing State around is better than passing [Double] around.
19:36:47 <mauke> ToxicFrog: less typing
19:37:07 <mauke> instead of a -> b -> c -> [Double] -> ([Double], z) you can write a -> b -> c -> State [Double] z
19:37:09 <omnId> ToxicFrog: try passing the [Double]s around yourself and making sure you thread everything right first.  It's tedious, but possible.
19:37:46 <ToxicFrog> omnId: see, this is the point where, as mentioned earlier, I switch to an imperative language and come back to Haskell when I have a project that doesn't require state.
19:38:04 <omnId> ToxicFrog: if your functions make State actions instead, then those actions can be hooked together with the standard bind that passes for you.
19:38:21 <ToxicFrog> "the standard bind"?
19:38:35 <omnId> Monad's (>>=), which is inserted with do notation.
19:38:49 <dons> huh, andrew coppin really did unsubscribe from -cafe@
19:39:05 <Pseudonym> I say we Cc him on everything.
19:39:12 <dons> heh
19:39:21 <omnId> > runState (get >>= \x -> return (x + 1)) 3
19:39:23 <lambdabot>  (4,3)
19:39:35 <omnId> > runState (do x <- get ; return (x + 1)) 3
19:39:36 <lambdabot>  (4,3)
19:39:45 <mauke> ToxicFrog: er. then what are you going to use Haskell for?
19:40:07 <mauke> state is pretty common
19:40:23 <chessguy> ToxicFrog, what are you breeding, anyway?
19:40:49 <ToxicFrog> mauke: I don't know! Genetic algorithms and ant colony optimization both need an entropy pool. Something will present itself eventually. Perhaps.
19:40:53 <omnId> > runState (State (\s -> (s,s)) >>= \x -> State (\s -> (x + 1, s))) 3
19:40:55 <ToxicFrog> chessguy: solutions to a function.
19:40:55 <lambdabot>  (4,3)
19:41:14 <FMota> wha, it's complaining about fractional integers now
19:41:26 <omnId> FMota: fromIntegral might help
19:41:26 <mauke> FMota: are you using / somewhere?
19:41:32 <FMota> is there anyway to just do simple integer division?
19:41:35 <iank> div
19:41:35 <omnId> div
19:41:37 <mauke> `div`
19:41:39 <shachaf> > runState (State (\s -> (s + 1, s))) 3 -- As long as you're expanding it, there's no need to use get
19:41:40 <FMota> oh, ok
19:41:40 <lambdabot>  (4,3)
19:41:40 <Tac-Tics> > 5 `div` 2
19:41:41 <FMota> ty
19:41:42 <lambdabot>  2
19:41:58 <omnId> shachaf: one step at a time :)
19:42:13 <omnId> > (\s -> (s + 1, s)) 3
19:42:14 <lambdabot>  (4,3)
19:42:21 <Pseudonym> BTW, is it a rite of passage for a community to get its first "I'm leaving in a huff"?
19:42:38 <shachaf> > runState (State ((+1) &&& id)) 3
19:42:39 <ToxicFrog> Ok. runState takes an action and an initial state? And the action can use get and put to manipulate said state?
19:42:39 <lambdabot>  (4,3)
19:42:49 <omnId> yep
19:42:54 <mauke> ToxicFrog: yes
19:42:54 <omnId> @src State get
19:42:54 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:43:01 <ToxicFrog> And returns a tuple containing the return value, followed by the state?
19:43:02 <shachaf> ToxicFrog: Now try to reimplement State.
19:43:07 <omnId> get = State (\s -> (s, s))
19:43:17 <omnId> put x = State (\s -> ((), x))
19:43:19 <mauke> > runState (do modify (+1); modify (*2); modify (+1); return "Thursday") 42
19:43:21 <lambdabot>  ("Thursday",87)
19:43:21 <shachaf> newtype State s a = State (s -> (a,s)); runstate (State x) = x -- Start with that.
19:43:22 <omnId> @type get
19:43:24 <omnId> @type put
19:43:24 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
19:43:26 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
19:44:11 <omnId> runState (State f) x = f x -- if the eta reduced version is too hard to read.
19:44:45 <omnId> the key is (>>=) which threads the state around rather smartly
19:45:04 <chessguy> smartly?
19:45:10 <dons> jerzy's got some interesting reminiscenes, re. Gofer: " At that time we knew that
19:45:11 <ToxicFrog> ...but f only returns an r, whereas runState returns (r,s)
19:45:13 <dons> Haskell was for the brave, not for people making money... Almost everybody
19:45:15 <dons> was a newbie"
19:45:31 <omnId> ToxicFrog: "f"?
19:45:55 <omnId> @type State -- the State constructor requires that it's argument function returns a pair.
19:45:57 <lambdabot> forall s a. (s -> (a, s)) -> State s a
19:46:08 <ToxicFrog> runState (State f) x = f x -- I read that as "runState (State f) x is equivalent to applying the function the State is wrapped around to x"
19:46:21 <omnId> yes
19:46:23 <ToxicFrog> But in that case you'd only get one return, rather than the (return,state) tuple
19:46:28 <mauke> ToxicFrog: no, f returns (r,s)
19:46:30 <omnId> and f :: s -> (a, s)
19:46:44 <ToxicFrog> But f says it returns r!
19:46:53 <ToxicFrog> It returns (r,s) only implicitly!
19:47:04 <omnId> if it's wrapped in the State constructor, it must have type s -> (a, s)
19:47:20 <mauke> f :: State r where State x = s -> (x, s)
19:47:57 <ToxicFrog> (do x <- get ; return (x + 1)) -- this looks like it returns x+1, not (x+1,x), even though the latter is what actually falls out when you run it
19:47:59 <omnId> @type State -- look at the constructor's type again
19:48:01 <lambdabot> forall s a. (s -> (a, s)) -> State s a
19:48:33 <omnId> ToxicFrog: maybe you're confused about the "return" function?
19:48:43 <omnId> return x = State (\s -> (x, s))
19:48:52 <ToxicFrog> ...oh.
19:48:54 <ToxicFrog> Oops.
19:48:56 <ToxicFrog> Ok, now it makes sense.
19:49:31 <omnId> you think you're ready for (>>=) now?
19:49:39 <mauke> > runState (do return 1; return 2; return "butter"; return "Thursday") 42
19:49:40 <ToxicFrog> Probably not!
19:49:41 <lambdabot>  ("Thursday",42)
19:50:19 <omnId> action >>= k = State (\s -> let (result, new_s) = runState action s in runState (k result) new_s)
19:50:29 <omnId> read through that slowly
19:51:36 <omnId> it makes a new function that hooks together 'action' and 'k' and passes each value to the correct place.
19:51:41 <JohnnyL> How can one write a compose function for a list of functions with varied arguments (in amount)?
19:51:57 <mauke> @where oleg
19:51:58 <lambdabot> http://okmij.org/ftp/
19:51:59 <FMota> yay, euler #3 finally down... :o
19:52:15 <dons> JohnnyL: well, hmm. how would you use this thing?
19:52:33 <JohnnyL> dons, combing mathematical functions.
19:52:36 <mauke> http://okmij.org/ftp/Haskell/types.html#polyvar-comp
19:52:37 <lambdabot> Title: Haskell Programming: Types
19:52:53 <dons> and (.) doesn't work?
19:53:00 <dons> with appropirate lambdas/
19:53:12 <FMota> > rev "abc"
19:53:13 <lambdabot>   Not in scope: `rev'
19:53:18 <JohnnyL> i am new. it's a dynamtic list of functions.
19:53:18 <FMota> > reverse "abc"
19:53:20 <lambdabot>  "cba"
19:53:24 <ToxicFrog> augh, my brain
19:53:47 <sclv> JohnnyL: maybe you could make up and operator that in imaginaryland did what you wanted, then write some pseudocode with the operator, so you could then show us what you wanted to do .
19:53:58 <omnId> it hooks together: (action >>= \result_from_action -> new_action)
19:54:56 <JohnnyL> sclv a list of sins and coses or printing sins and cos.
19:55:09 <omnId> it gets the (result, new_s) pair by running action, then passes result to k to get a new_action.
19:55:44 <omnId> new_s is passed to the new_action, and the whole thing results in new_action's return value.
19:56:08 <ToxicFrog> So, hang on
19:56:32 <sclv> JohnnyL so you want to have [Sin 12, Cos 22, Sin 17], for example, and then pass it to a function that either evals it or prints it?
19:56:32 <ToxicFrog> Where does it get the old s from?
19:56:41 <ToxicFrog> I mean, I see it's the argument to that lambda, but what's the lambda called with?
19:56:45 <omnId> ToxicFrog: action >>= k = State (\s -> ...)
19:56:50 <omnId> runState!
19:56:55 <ToxicFrog> Ok.
19:57:05 <omnId> (>>=) just hooks together actions into a bigger actions!
19:57:17 <omnId> The whole thing is subsequently run with runState!
19:57:21 <ToxicFrog> So if I did runState theAction theInitialState, then s in that scope is initialState?
19:57:22 <JohnnyL> svlv, yeah but the list size is not definite.
19:57:26 <omnId> excalmation point!
19:57:30 <ToxicFrog> Er, theInitialState?
19:57:34 <omnId> yes!!!
19:57:59 <omnId> (though most actions are built up from raw lambdas and the State constructor)
19:58:10 <sclv> JohnnyL, define, e.g., Data Expr = Sin Float | Cos Float and the rest follows...
19:58:13 <omnId> (usually you use get, put, return, modify to do it for you)
19:58:47 <omnId> s/are/aren't/
19:59:08 <omnId> most actions *aren't* built up from raw lambdas the the constructor
19:59:19 * omnId types types quickly
19:59:25 <ToxicFrog> Ok. And then, having done that, it takes the new state and return value it got from (action s), and stuffs that through k as runState (k retval) newstate?
19:59:37 <omnId> yep
19:59:52 <sclv> JohnnyL: like, then you can have eval :: Expr -> Float where eval x = case x of Sin a -> sin a; Sin b -> sin b; and then you can just map eval over yr. list
20:00:18 <omnId> (>>=), effectively, is fancy function composition in the State monads.
20:00:23 <ToxicFrog> So in effect, action >>= k (is an action that?) runs action, updates state based on that, and feeds the result and new state to k, and returns the result of k and the new new state?
20:00:36 <omnId> yes, yes, yes!
20:00:44 <dfranke_> is there any way to match case-insensitive patterns in Alex?
20:00:52 <omnId> :D
20:01:11 <Tela> Although, this is done lazily, so that computation wont actually occur until you demand it with run/eval/execState
20:01:19 <ToxicFrog> Alright. And get and put are actions that manipulate the state, which is how the given implementation of more works?
20:01:44 <ToxicFrog> Ie, it gets the state, yanks a bunch of stuff off the front, puts what's left back into the state, and returns the stuff it pulled off?
20:01:48 <sclv> anyway, my silly question for the community is this: is there a standard function like succ but that "wraps around" on bounded values?
20:02:08 <omnId> ToxicFrog: I can't stop saying yes!
20:02:45 <omnId> (incidentally, more can also be written: more n = State (splitAt n), can you see why?)
20:02:59 <monochrom> I can say no. Unfortunately that's for sclv's question. :)
20:03:08 * ToxicFrog examines that
20:03:54 <omnId> State (\s -> let (result, new_s) = splitAt n s in (result, new_s)) -- maybe with more explicitness :)
20:04:29 <omnId> splitAt just happens to return the correct type of pair :)
20:04:59 <ToxicFrog> Aaah. So there's no magic going on there, it's a fortuitious interaction of signatures.
20:05:10 <omnId> nicely said!
20:05:31 <ToxicFrog> So the partial application of splitAt is turned into an action, which is given the state, and returns two lists that happen to be the correct values for the return value and the new state.
20:06:02 * chessguy hasn't been paying attention. what does splitAt have to do with State?
20:06:04 <omnId> @vixen will you say "Yes" for me?  My "yes" box is getting worn out.
20:06:05 <lambdabot> i'll hafta plead the fifth on that one.
20:06:17 <omnId> :)
20:06:48 <Tac-Tics> :t splitAt 5
20:06:51 <lambdabot> forall a. [a] -> ([a], [a])
20:06:56 <Tac-Tics> :t State
20:06:58 <lambdabot> forall s a. (s -> (a, s)) -> State s a
20:07:18 <Tac-Tics> splitAt sounds very lending to State
20:07:29 <omnId> as do many of the random functions
20:07:31 <omnId> @type random
20:07:33 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
20:07:39 <Tac-Tics> :t \n -> State (splitAt n)
20:07:41 <lambdabot> forall a. Int -> State [a] [a]
20:07:41 <chessguy> well, assuming the state is a list, sure
20:07:59 <Tac-Tics> a list is a nice kind of state
20:08:19 <Tac-Tics> it allows you to pretend you're working with many states at once
20:09:04 <omnId> ToxicFrog: so you see, in the end, the list is passed around everywhere, but you don't have to much about with it yourself.
20:09:15 <omnId> muck*
20:09:25 <ToxicFrog> Right.
20:10:26 <omnId> also incidentally, the real definition of runState is as a record selector on the State type:  newtype State s a = State { runState :: s -> (a, s) }
20:10:42 <omnId> if you don't know much about record selectors, you can happily ignore this :)
20:11:01 <FMota> > [1,2,3,4] !! 3
20:11:02 <shachaf> You people are still going on about State?
20:11:03 <lambdabot>  4
20:11:34 <omnId> shachaf: there's learning happening!
20:11:48 <shachaf> Learning is good.
20:12:47 <omnId> ToxicFrog: things still falling in place?  Anything you're fuzzy on?
20:13:13 <omnId> You know the translation of do notation into (>>=), yes?
20:13:46 * FMota 's computer is taking ages to compute the 10001st prime number.
20:13:54 <dons> i love these epic weekend learners.
20:14:01 <shachaf> FMota: s/computer/algorithm/ ?
20:14:10 <dons> ToxicFrog: its great you've stuck with it. you must be in a completely different place to earlier in the day?
20:14:12 <FMota> eh
20:14:19 <FMota> I'm using a sieve, as per usual
20:14:28 <FMota> although I could optimize it.
20:14:30 <ToxicFrog> dons: no, not as such. I know much more about State and >>= than I did, though.
20:14:34 <FMota> s/could/should
20:14:36 <mauke> FMota: dude, just use sockets and download the list
20:14:40 <mauke> faster than computing it yourself
20:14:44 <FMota> lol.
20:14:58 <FMota> that's cheating :/
20:15:09 <mauke> OPTIMIZED
20:15:22 <sorear> FMota: my system can do it in 0.01s
20:15:53 <sorear> although it segfaults in the process
20:16:02 * FMota is jealous :o
20:16:40 <ToxicFrog> omnId: I don't, and I'm trying to look it up, but the index has defeated me
20:16:52 <stoic_> heh, that's a projecteuler problem
20:17:17 <FMota> yep
20:17:27 <mauke> what's the problem id?
20:17:30 <ToxicFrog> I'd guess, though, that it's something like a >>= b = do tmp <- a; b tmp;
20:17:36 <omnId> do { pat <- expr ; ... } = expr >>= \pat -> do { ... }
20:17:37 <FMota> promple # 7
20:17:39 <ToxicFrog> Add more tmps as necessary.
20:17:48 <ToxicFrog> Aah.
20:18:04 <ToxicFrog> That's rather more elegant.
20:18:08 <omnId> do { let decls ; ... } = let decls in do { ... }
20:18:32 <mauke> FMota: my solution takes 10 seconds
20:18:39 <omnId> do { stmt ; ... } = stmt >> do { ... }, which is equivalent to stmt >>= \_ -> do { ... }
20:18:50 <omnId> do { stmt } = stmt
20:19:06 <stoic_> haha, one of the J solutions to problem 7 in the forums is great: p: 10000 ...0.000953769 seconds
20:19:07 <FMota> yay!
20:19:11 <Cale> "reddit is currently in read only mode due to a database upgrade. we should be back in a few weeks."
20:19:12 <FMota> I got it. Really fast.
20:19:16 <FMota> ... and it makes no sense~
20:19:32 <omnId> Cale: *jawdrop*!  *WEEKS?*
20:19:39 <FMota> 10002 is not a prime number! :/
20:19:40 <Cale> I'm kidding :)
20:19:49 <omnId> you bastard!
20:19:51 <Cale> It's just that it's been a little more than a "few" hours now
20:20:10 <FMota> yes Cale, thati s infuritain
20:20:14 <FMota> *infuriating
20:20:22 <FMota> which is why I'm doing project euler. :/
20:20:23 <mauke> primes = 2 : sieve [3, 5 ..]; sieve (p : ns) = p : sieve (filter ((0 /=) . (`mod` p)) ns)
20:20:29 <FMota> and failing miserably, I might add.
20:21:39 <stoic_> > (nubBy(((>1).).gcd)[2..]) !! 10001
20:21:53 <lambdabot> Terminated
20:22:43 <ddarius> Take this a a good chance to leave reddit behind.
20:23:30 <FMota> mauke: I hate and love you. :)
20:23:52 <mauke> what
20:24:06 <idnar> primes = 2 : filter isPrime [3, 5..] where isPrime n = all (not . (`divides` n)) (takeWhile (\p -> p * p <= n) primes)
20:24:34 <mauke> pfft, you kids and your fancy algorithms
20:25:11 <idnar> mauke: my initial implementation was something like yours, but it took too long to find all the primes below 1 million :P
20:25:36 <idnar> I'm not sure if a Sieve of Eratosthenes or Atkins is faster than that, though
20:25:59 <mauke> is that problem 10?
20:26:02 <Tela> The type system is Haskell's parentheses. Hate, then hate, then hate, then divinity.
20:26:22 <Tac-Tics> @let divisors n = [x | x <- [1..n], n `mod` x == 0]
20:26:23 <FMota> heh, @remember-bait
20:26:28 <lambdabot> Defined.
20:26:35 <mauke> main = print $ sum $ takeWhile (< 1000000) primes
20:26:40 <Tac-Tics> @let prime n = length (divisors n) == 2
20:26:40 <lambdabot> <local>:19:0:     Multiple declarations of `L.prime'     Declared at: <local>...
20:26:48 <newsham> tela: then agda?
20:26:49 <mauke> > prime 42
20:26:51 <lambdabot>  False
20:26:52 <Tela> Not denying it. I like the parallel though. Reminds me way too much of macros
20:27:04 <ToxicFrog> 'agda'?
20:27:09 <idnar> mauke: yeah
20:27:14 <shachaf> @where agda
20:27:14 <lambdabot> http://www.cs.chalmers.se/~catarina/agda/
20:27:15 <newsham> agda has a more powerful type system than haskell
20:27:15 <Tac-Tics> > filter prime [1..101]
20:27:17 <lambdabot>  [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]
20:27:28 <mauke> > (filter prime [2 ..]) !! 1000
20:27:30 <lambdabot>  7927
20:27:30 <ToxicFrog> Aah.
20:27:33 <mauke> > (filter prime [2 ..]) !! 10000
20:27:35 <lambdabot>  104743
20:27:41 <shachaf> > prime 1 -- !
20:27:43 <lambdabot>  True
20:27:45 <mauke> wow, this is fast
20:27:49 <ToxicFrog> Ok. So I now know how to implicitly pass state along. Now I need to pass it down.
20:28:00 <shachaf> ToxicFrog: "down"?
20:28:09 <shachaf> ToxicFrog: Did you reimplement State yet, by the way?
20:28:20 <newsham> I think http://unit.aist.go.jp/cvs/Agda/ is a newer url than the chalmers one
20:28:21 <lambdabot> Title: Agda Official Web Site
20:28:25 <idnar> @src prime
20:28:25 <lambdabot> Source not found. Are you on drugs?
20:28:44 <shachaf> < Tac-Tics> @let prime n = length (divisors n) == 2
20:28:49 <ToxicFrog> shachaf: no, I haven't. And by down, I mean I have an action that doesn't directly use the state, but is defined in terms of something else that does.
20:28:59 <idnar> shachaf: but < lambdabot> <local>:19:0:     Multiple declarations of `L.prime'     Declared at: <local>...
20:29:00 <shachaf> ToxicFrog: runState?
20:29:03 <idnar> shachaf: I thought that meant the @let failed
20:29:08 <ToxicFrog> Or rather, is defined in terms of something else which is defined in terms of something else which does.
20:29:13 <stoic_> > 2 : (filter prime [3,5..]) !! 20000
20:29:14 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Integer'
20:29:18 <shachaf> Oh.
20:29:20 <shachaf> Hmm.
20:29:34 <mauke> > (2 : filter prime [3,5..]) !! 20000
20:29:36 <lambdabot>  224743
20:30:14 <idnar> > sum $ takeWhile (<1000000) (2: filter prime [3, 5...])
20:30:15 <lambdabot>  Parse error
20:30:22 <idnar> > sum $ takeWhile (<1000000) (2 : filter prime [3, 5...])
20:30:23 <lambdabot>  Parse error
20:30:41 <stoic_> extra dot?
20:30:46 <idnar> oh, oops
20:30:47 <idnar> > sum $ takeWhile (<1000000) (2 : filter prime [3, 5..])
20:30:52 <lambdabot> Terminated
20:30:54 <idnar> heh
20:31:19 <mauke> @let primes = 2 : filter prime [3, 5 ..]
20:31:20 <lambdabot> <local>:19:0:     Multiple declarations of `L.primes'     Declared at: <local...
20:31:32 <ToxicFrog> shachaf: that is to say, main calls a lambda action (is that the right term? it's a (do ...) block passed directly to runState), which calls mutate, which calls pmap, which calls more, which uses the state.
20:31:33 <mauke> > takeWhile (<1000000) primes
20:31:35 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:32:27 <shachaf> ToxicFrog: It's a bit like IO.
20:32:29 <idnar> > length $ takeWhile (<1000000) primes
20:32:33 <lambdabot> Terminated
20:32:33 <shachaf> ToxicFrog: Except you can run it.
20:32:46 <shachaf> ToxicFrog: If something uses the state, it has to be in State.
20:32:59 <stoic_> > last primes
20:33:00 <Tac-Tics> @let foo n = head $ let primes = filter prime [2..] in do x <- primes; y <- primes; guard (x + y == n)
20:33:03 <shachaf> ToxicFrog: Or have an initial state to runState with (which is equivalent).
20:33:09 <lambdabot> Defined.
20:33:11 <lambdabot> Terminated
20:33:19 <Tac-Tics> @let foo2 n = head $ let primes = filter prime [2..] in do x <- primes; y <- primes; guard (x + y == n); return [x, y]
20:33:24 <omnId> @. elite run last [1..]
20:33:25 <lambdabot> Defined.
20:33:29 <lambdabot> tER/\/\iNA73d
20:33:30 <Tac-Tics> > foo2 12
20:33:34 <lambdabot> Terminated
20:33:52 <Tac-Tics> sadness
20:34:03 <Tac-Tics> > foo2 4
20:34:04 <lambdabot>  [2,2]
20:34:23 <mauke> > foo2 6
20:34:27 <ToxicFrog> shachaf: I do have an initial state.
20:34:27 <lambdabot> Terminated
20:34:32 <mauke> huhu
20:34:35 <Tac-Tics> so much for the naive approach
20:34:45 <sclv> it never stops taking from the first primes to take from the 2nd
20:34:58 <shachaf> ToxicFrog: So what's the point?
20:35:04 <Tac-Tics> yeah
20:35:08 <ToxicFrog> main = do { rs <- (...generate initial state...); evalState (do mutate ...);
20:35:13 <Tac-Tics> it's looking for 2 + p = 6
20:35:15 <Tac-Tics> and there is none
20:35:16 <ToxicFrog> Er.
20:35:21 <ToxicFrog> evalState (do mutate ...) rs
20:35:23 <shachaf> ToxicFrog: You have a state, you call a function that isn't in State, and then you call a function that is in state from that?
20:35:35 <shachaf> ToxicFrog: You might as well keep everything in State.
20:35:45 <ToxicFrog> That's what I'm trying to do.
20:35:47 <idnar> @let foo3 n = head $ let primes = filter prime [2..] in do x <- takeWhile (<n) primes; y <- takeWhile (<n) primes; guard (x + y == n); return [x, y]
20:35:55 <lambdabot> Defined.
20:35:59 <shachaf> ToxicFrog: Can you @paste, maybe?
20:36:05 <mauke> > foo3 6
20:36:07 <sclv> I wrote a way to take a useful cartesian product of infinite lists once. then i realized that cartesian products were overkill. hmm.. i might have the code somewhere
20:36:07 <lambdabot>  [3,3]
20:36:07 <idnar> > foo3 6
20:36:08 <lambdabot>  [3,3]
20:36:14 <idnar> > foo3 27
20:36:15 <lambdabot>  Exception: Prelude.head: empty list
20:36:20 <Tac-Tics> @let bar n = head $ let primes = filter prime [2..] in do x <- primes; guard (x <= n); y <- primes; guard (x + y == n); return [x, y]
20:36:28 <lambdabot> Defined.
20:36:29 <Tac-Tics> > bar 6
20:36:33 <lambdabot> Terminated
20:36:33 <idnar> > foo3 20
20:36:34 <lambdabot>  [3,17]
20:36:51 <sclv> or yep, that'll do.
20:37:18 <mauke> > foo3 100
20:37:18 <idnar> the guard isn't enough
20:37:20 <lambdabot>  [3,97]
20:37:24 <mauke> Tac-Tics: guard is filter, not takeWhile
20:37:38 <idnar> what he said ;)
20:37:48 <ToxicFrog> Hmm. That worked.
20:37:51 <ToxicFrog> mutate li = State (\n -> runState (do pmap 0.5 (+1) li) n)
20:38:10 <mauke> State/runState? o_O
20:38:21 <idnar> if anyone cares, my Project Euler solutions are at http://slipgate.za.net/~mithrandi/darcs/projecteuler/
20:38:23 <lambdabot> Title: Index of /~mithrandi/darcs/projecteuler
20:38:25 <Tac-Tics> > foo3 23456
20:38:27 <lambdabot>  [163,23293]
20:38:29 <mauke> mutate li = pmap 0.5 (+1) li
20:38:31 <shachaf> ToxicFrog: You shouldn't use State yourself.
20:38:44 <stoic_> Tac-Tics: are you trying to do prime factors?
20:38:48 <idnar> (in most cases I just tried to solve it as quickly as possible, rather than striving for elegant / optimal solutions)
20:38:49 <Tac-Tics> no
20:38:54 <idnar> (and, obviously, don't look there if you don't want any spoilers :P)
20:39:03 <Tac-Tics> It's the goldbach conjecture, I think, right?
20:39:04 <sclv> > let bar2 n = head $ let primes = filter prime [2..] in do x <- primes; y <- takeWhile (<x) primes; guard (x + y == n); return [x, y] in bar2 23456
20:39:06 <lambdabot>  [11779,11677]
20:39:08 <omnId> mutate xs = pmap 0.5 (+1) xs
20:39:25 <ToxicFrog> omnId: that works too.
20:39:30 <ToxicFrog> However...oh, wait, I think I see
20:39:47 <omnId> pmap results in your action, mutate just gives defaults to pmap
20:39:59 <ToxicFrog> mutate li = if (head li) == 1 then return li else pmap 0.5 (+1) li
20:40:17 <omnId> if the first == 1 then don't pmap?
20:40:20 <stoic_> idnar: have you done problem 160?
20:40:21 <idnar> Tac-Tics: for even n, yes
20:40:22 <ToxicFrog> Yep.
20:40:31 <omnId> that should work fine
20:40:36 <idnar> stoic_: I've only done 1 through 20
20:40:44 <kaol> why does "return Nothing >>= return >> return $ Just ()" fail but "return Nothing >>= return >> return (Just ())" doesn't?
20:40:44 <ToxicFrog> Not what the final logic looks like (which calls a seperate function to determine whether to pmap or not) but that's the idea.
20:40:45 <stoic_> oh :-(
20:40:50 <luqui> I installed ghc from a binary tarball; how do I get the runhaskell program?
20:41:02 <dons> should be in your path
20:41:02 <ToxicFrog> The problem I kept running into earlier was that 'mutate li = if (head li) == 1 then li else pmap 0.5 (+1) li' wouldn't work.
20:41:08 <omnId> since the else clause results in an action, the then clause must too, (via return)
20:41:10 <sclv> > let primes = filter prime [2..]; bar2 n= head $ do{ x <- primes; y <- takeWhile (<x) primes; guard (x + y == n); return [x, y]} in bar2 23456
20:41:11 <mauke> :t (>>= return)
20:41:12 <lambdabot>  [11779,11677]
20:41:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
20:41:20 <ToxicFrog> Because I didn't fully realize that 'pmap 0.5 (+1) li' returns an action, but
20:41:23 <ToxicFrog> 'li' returns a list.
20:41:34 <luqui> kaol, operator precedence
20:41:38 <dons> now you're learning to think in types, ToxicFrog :)
20:41:41 <dons> be careful: its addicative
20:41:41 <omnId> li is a list, but return li is a list in the State [Double] Monad.
20:41:43 <kaol> thought it would be something like that
20:41:48 <shachaf> ToxicFrog: Do keep in mind that that won't work for the empty list.
20:41:50 <luqui> kaol, (return Nothing >>= return >> return) (Just ())  should work fine
20:41:51 <dons> you'll be inferring types for everything soon enough
20:41:54 <ToxicFrog> shachaf: yes, I know.
20:42:01 <ToxicFrog> I'm still putting stuff together.
20:42:17 <luqui> kaol, actually... uh, no it shouldn't
20:42:20 <Tac-Tics> dons: it's like you don't even need documentation on a function any more... you just see the type and assume you know what it should do
20:42:22 <omnId> it takes time, you'll get there :)
20:42:22 <luqui> but that's what it means at least
20:42:36 <ToxicFrog> dons: well, the issue was that I expected both of them to return lists.
20:42:42 <FMota> yay.
20:42:52 <omnId> Tac-Tics: /me did exactly that when I futzed around with template haskell :)
20:42:52 <shachaf> ToxicFrog: Somebody else had the solution "mutate li@(1:xs) = ...; mutate li = li" or so.
20:42:55 <FMota> I used pfactors and it got me the answer in ~10 seconds
20:43:04 <omnId> Tac-Tics: which was good since I couldn't find any good docs :D
20:43:09 <Tac-Tics> yeah
20:43:10 <dons> Tac-Tics: exactly. given purity and an expressive type , the type does in fact tell you everything
20:43:14 <dons> ?djinn a -> a
20:43:14 <lambdabot> f a = a
20:43:18 <kaol> > return Nothing >>= return >> return (Just ())
20:43:19 <lambdabot>   add an instance declaration for (Show (m (Maybe ())))
20:43:27 <Tac-Tics> type(f) = type(g) => f = g
20:43:29 <dons> only one non-trivial function with that type: the type really is a good, machine checked spec
20:43:29 <shachaf> @ty take
20:43:31 <lambdabot> forall a. Int -> [a] -> [a]
20:43:32 <shachaf> @ty drop
20:43:34 <lambdabot> forall a. Int -> [a] -> [a]
20:43:51 <ToxicFrog> shachaf: which is cool, but since the final logic will be something like 'if completed li then return get-best li else mutate (pmap 0.5 breed li)'
20:43:54 <kaol> > return Nothing >>= return >> return (Just "")
20:43:55 <lambdabot>        add an instance declaration for (Show (m (Maybe [Char])))
20:44:22 <omnId> ToxicFrog: and get-best doesn't rely on any incoming stream of randoms or anything?
20:44:27 <ToxicFrog> Nope.
20:44:34 <luqui> > return Nothing >>= return >>= return (Just "")   -- is this what you meant?
20:44:36 <lambdabot>  Just ""
20:44:38 <chessguy> ToxicFrog, you're searching for a fitness of 1?
20:44:45 <ToxicFrog> chessguy: in effect.
20:44:48 <shachaf> Hmm... @djinn is implementation inference. :-)
20:45:01 <ToxicFrog> While I can't guarantee that's the range fitness is in, get-best just returns the element of the list with the highest fitness value.
20:45:09 <luqui> > Nothing >>= return >>= Just ""      -- or maybe this?
20:45:10 <lambdabot>  Couldn't match expected type `a -> Maybe b'
20:45:12 <ToxicFrog> The fitness function itself is, of course, pure.
20:45:12 <luqui> oops
20:45:16 <luqui> > Nothing >>= return >> Just ""      -- or maybe this?
20:45:16 <FMota> pfactors = pf 2; pf x 1 = []; pf x n | x * x > n = [n]; pf x n | mod n x == 0 = x : pf x (div n x); pf x n = pf (succ x) n
20:45:17 <lambdabot>  Nothing
20:45:24 <omnId> > return Nothing >>= return (Just "")
20:45:26 <lambdabot>  Just ""
20:45:44 <omnId> (>>= return) = id
20:45:55 <ToxicFrog> And completed li = fitness (get-best li) >= fitness-requirement
20:46:04 <FMota> > let pfactors = pf 2; pf x 1 = []; pf x n | x * x > n = [n]; pf x n | mod n x == 0 = x : pf x (div n x); pf x n = pf (succ x) n in pfactors 1001
20:46:05 <lambdabot>  [7,11,13]
20:46:10 <kaol> the example was a bit trivial, but that was the basic scenario I had
20:46:16 <FMota> > product [7, 11, 13]
20:46:17 <lambdabot>  1001
20:46:20 <FMota> :)
20:46:23 <stoic_> FMota: does projecteuler work?  I'm getting a mysql error :(
20:46:30 <FMota> heh
20:46:35 <FMota> I must've broke it! :o
20:46:48 <ToxicFrog> And now that I actually have some form of handle on this, I'm going to have dinner.
20:46:48 <FMota> Maybe I divided by zero?
20:46:50 <ToxicFrog> At midnight.
20:46:54 <ToxicFrog> Thank you, all.
20:47:02 <omnId> hehe, you're most welcome
20:47:18 <Tac-Tics> ah
20:47:20 <Tac-Tics> I found it
20:47:25 <Tac-Tics> nub (mersennes >>= primeDivisors) == tail primes?
20:47:50 <Tac-Tics> that's a neat question I came up with last year in my shitty math research class
20:48:12 <omnId> Tac-Tics: maybe a sort there too?
20:48:32 <Tac-Tics> it's hard to sort that kind of list
20:48:37 * omnId doesn't know what a mersenne prime is
20:48:50 <Tac-Tics> mersenne n = 2 ^ (n+2) - 1
20:48:50 <Tac-Tics> mersennes = map mersenne [1..]
20:48:51 <omnId> (>>=) is in []?
20:48:51 <shachaf> omnId: 2^n-1
20:48:57 <Tac-Tics> they are not necessarily mersenne primes
20:49:00 <jql> they're the cool primes
20:49:02 <Tac-Tics> they are just mersenne numbers
20:49:14 <Tac-Tics> in my question, that is
20:49:21 <omnId> oh, duh, or they wouldn't have many primeDivisors :)
20:50:48 <Tac-Tics> they'd have themselves as divisors
20:53:13 <Tac-Tics> I can get about 23 primes and then sadness
20:55:56 <FMota> :[] is still my favorite haskell expression :)
20:56:41 <mauke> @quote fmap
20:56:41 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
20:56:46 <FMota> > product . map read . map (:[]) . take 5 $ "1234567"
20:56:57 <lambdabot>  120
20:57:00 <FMota> lol
20:57:04 <FMota> that took awhile.
20:57:10 <newsham> ?type fmap fix return
20:57:12 <lambdabot> forall a. a -> a
20:57:16 <omnId> = id
20:57:30 <omnId> fmap = (.), return = const
20:57:33 <mauke> > product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
20:57:34 <lambdabot>  120
20:57:44 <omnId> fix . const = \x -> fix (const x) = \x -> x
20:58:11 <FMota> mauke... maybe you should be in jail?
20:58:15 <FMota> :o ;p
20:58:33 <FMota> @index ap
20:58:33 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
20:58:34 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
20:58:50 <shachaf> ap = liftM2 id
20:58:53 <shachaf> @src ap
20:58:53 <lambdabot> ap = liftM2 id
20:59:02 <ddarius> @remember mauke product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
20:59:02 <lambdabot> Done.
20:59:18 <omnId> yuck
20:59:55 <mauke> > liftM product (liftM (liftM (liftM read return)) (take 5)) $ "1234567"
20:59:57 <lambdabot>  120
21:00:17 <mauke> @unpl liftM product (liftM (liftM (liftM read return)) (take 5)) $ "1234567"
21:00:17 <lambdabot> (liftM product (liftM (liftM (liftM read return)) (take 5)) "1234567")
21:00:26 <mauke> hah
21:00:27 <omnId> > let (.) = fmap in product . (read .) . (return .) . take 5 $ "1234567"
21:00:28 <lambdabot>      Occurs check: cannot construct the infinite type:
21:00:28 <lambdabot>       f = (->) (f Stri...
21:00:38 <shachaf> > product `liftM` (read `liftM` return `liftM`) `liftM` take 5 $ "1234567"
21:00:39 <lambdabot>  120
21:01:27 <omnId> > let (.) = fmap ; (.)::Functor f=>(a->b)->f a->f b in product . (read .) . (return .) . take 5 $ "1234567" -- mmr?
21:01:29 <lambdabot>  120
21:03:06 <shachaf> > let (.) x = fmap x in product . (read .) . (return .) . take 5 $ "1234567" -- Simpler?
21:03:07 <lambdabot>  120
21:03:40 <shachaf> > let (.) x = fmap x in product . (read . return .) . take 5 $ "1234567"
21:03:42 <lambdabot>  120
21:04:36 <shachaf> @ty liftM(.)fmap
21:04:37 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a1 -> b) -> (a -> f a1) -> a -> f b
21:04:49 <shachaf> @ty (liftM(.)fmap<$>)
21:04:51 <lambdabot> forall a a1 b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a1 -> b) -> f1 ((a -> f a1) -> a -> f b)
21:04:59 <omnId> oh gawd
21:05:00 <shachaf> @ty (liftM(.)fmap<$>map)
21:05:02 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> f [a1]) -> a -> f [b]
21:05:08 <omnId> make it stop!
21:05:16 <omnId> that's *five* names
21:05:41 <omnId> @ty (liftA(liftM(.)fmap<$>map))
21:05:43 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a1 -> b) -> f1 ((a -> f [a1]) -> a -> f [b])
21:06:31 <mauke> :t [fmap,liftA,liftM,(.)]
21:06:33 <lambdabot> forall a b a1. [(a -> b) -> (a1 -> a) -> a1 -> b]
21:06:59 <omnId> forgot (<$>)
21:07:10 <mauke> :t [fmap,liftA,liftM,(.),(<$>)]
21:07:12 <lambdabot> forall a b a1. [(a -> b) -> (a1 -> a) -> a1 -> b]
21:07:27 <omnId> that's a lot of names for function compose.
21:07:36 <shachaf> @ty liftA(liftM.fmap<$>map)
21:07:38 <lambdabot> forall (m :: * -> *) (f :: * -> *) a b (f1 :: * -> *). (Monad m, Functor f, Applicative f1) => f1 (a -> b) -> f1 (m (f [a]) -> m (f [b]))
21:07:51 <omnId> @src liftA
21:07:51 <lambdabot> liftA f a = pure f <*> a
21:08:04 <omnId> odd, you'd think liftA = fmap, since it does have the Functor context
21:08:17 <shachaf> No.
21:08:18 <omnId> @src liftA2 -- this, however, would need the <*>
21:08:18 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:08:19 <shachaf> @ty liftA
21:08:21 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
21:08:26 <omnId> liftA = fmap
21:08:35 <ddarius> @src Applicative
21:08:36 <lambdabot> class Functor f => Applicative f where
21:08:36 <lambdabot>     pure  :: a -> f a
21:08:36 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
21:08:59 <shachaf> (<$>) is Applicative's rename of fmap.
21:09:01 <omnId> @src liftA2
21:09:02 <lambdabot> liftA2 f a b = f <$> a <*> b
21:09:08 <omnId> liftA as well
21:09:47 <shachaf> omnId: Yes, but that has an Applicative constraint.
21:09:57 <omnId> shachaf: which implies Functor
21:10:00 <shachaf> Maybe it's there to test Applicative laws.
21:10:31 <omnId> Oh, I see what you mean.
21:10:51 <omnId> liftA is a more specific (<$>)
21:10:57 <shachaf> Yes.
21:11:37 <newsham> is there a good ref on the Applicative module?  seems the paper doesnt use the same notation/defs as the module.
21:11:53 <omnId> could still define it liftA = fmap, since it has the more specific type
21:13:42 <shachaf> @ty second(liftA liftM.fmap<$>map)
21:13:43 <lambdabot> forall a1 (m :: * -> *) a b d. (Monad m) => (d, a -> b) -> (d, (a1 -> [a]) -> m a1 -> m [b])
21:13:50 <shachaf> > fmap (+1) (2,3)
21:13:55 <lambdabot>  (2,4)
21:13:56 <shachaf> > second (+1) (2,3)
21:13:57 <lambdabot>  (2,4)
21:13:58 <shachaf> :-)
21:14:02 <omnId> oh gawd
21:14:14 <omnId> @slap shachaf
21:14:14 <lambdabot> why on earth would I slap shachaf
21:14:40 <omnId> (,) a Functor vs. (->) Arrow
21:14:41 <pastorn-rr> @src randomR
21:14:41 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:14:47 <pastorn-rr> @src System.RandomrandomR
21:14:48 <lambdabot> Source not found. My pet ferret can type better than you!
21:14:53 <pastorn-rr> @src System.Random.randomR
21:14:53 <lambdabot> Source not found. Are you on drugs?
21:15:07 <omnId> @source System.Random
21:15:07 <lambdabot> http://darcs.haskell.org/packages/base/System/Random.hs
21:15:17 <omnId> 404!
21:15:57 <omnId> http://darcs.haskell.org/packages/random/System/Random.hs
21:15:58 <Mr_Awesome> i think someones trying to tell you to give up ;)
21:16:16 <pastorn-rr> omnId: thanks :D
21:16:25 <Mr_Awesome> bah, you found it
21:16:35 * omnId does not quit so easily
21:16:55 <omnId> seems a random package was split from base
21:16:57 <Mr_Awesome> you and your optimism
21:17:23 * omnId attacks Mr_Awesome with a refreshing beam of happy.
21:17:43 * Mr_Awesome curls into the fetal position
21:17:49 <omnId> not to be confused with Happy
21:18:16 <shachaf> @ty \f a -> a >>> arr f -- Hmm...
21:18:18 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => (c -> d) -> a b c -> a b d
21:18:50 <omnId> @type WrappedArrow
21:18:52 <lambdabot> Not in scope: data constructor `WrappedArrow'
21:19:02 <omnId> @type WrapArrow
21:19:04 <lambdabot> forall (a :: * -> * -> *) b c. a b c -> WrappedArrow a b c
21:19:10 <omnId> that'll give you a monad
21:19:21 <Mr_Awesome> @src (->) (>>>)
21:19:21 <lambdabot> f >>> g = g . f
21:19:26 <Mr_Awesome> @src (->) loop
21:19:27 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:19:29 <omnId> @src WrappedArrow (>>=)
21:19:29 <lambdabot> Source not found. My mind is going. I can feel it.
21:19:34 <Mr_Awesome> why not?!
21:19:46 * Mr_Awesome quits
21:19:49 <shachaf> Oh, right, (>>>).
21:19:52 * shachaf feels silly.
21:20:05 <shachaf> @ty second(liftA liftM.fmap<$>map>>>)
21:20:07 <lambdabot> forall a1 (m :: * -> *) a b d d1. (Monad m) => (d1, ((a1 -> [a]) -> m a1 -> m [b]) -> d) -> (d1, (a -> b) -> d)
21:20:13 * omnId cries
21:20:28 <omnId> so many names!
21:20:30 <shachaf> @ty second(liftA>>>liftM.fmap<$>map)
21:20:32 <lambdabot> forall a b (f :: * -> *) (m :: * -> *) (f1 :: * -> *) d. (Applicative f, Monad m, Functor f1) => (d, a -> b) -> (d, m (f1 [f a]) -> m (f1 [f b]))
21:21:14 <omnId> (.), map, and second all are different specifications of the others
21:21:50 <shachaf> omnId: True enough.
21:22:02 <shachaf> omnId: But you *could* set them all to fmap.
21:22:43 <shachaf> @ty Data.Traversable.fmapDefault
21:22:44 <lambdabot> forall a b (t :: * -> *). (Data.Traversable.Traversable t) => (a -> b) -> t a -> t b
21:23:24 <omnId> *sigh*  this should be a sport or something, find as many names for fmap as you can!
21:24:15 <nornagon> > zip [1..] $ fix (fmap:)
21:24:16 <lambdabot>  Add a type signature
21:24:26 <shachaf> @ty let fmapDefault = Data.Traversable.fmapDefault in second(fmapDefault(liftA>>>liftM).fmap<$>map)
21:24:28 <lambdabot> forall a (f :: * -> *) (m :: * -> *) a1 b d. (Data.Traversable.Traversable ((->) (a -> [a1])), Applicative f, Monad m) => (d, a1 -> b) -> (d, (a -> [a1]) -> m (f a) -> m (f [b]))
21:24:40 <nornagon> O_o
21:25:14 * omnId wonders what would happen if you provide the correct arguments.
21:25:28 <omnId> The world would end abruptly
21:26:31 <shachaf> @ty let fmapDefault = Data.Traversable.fmapDefault; amap = Data.Array.IArray.amap in second(fmapDefault(liftA>>>liftM).amap(fmap<$>map))
21:26:33 <lambdabot> forall (a :: * -> * -> *) i (f :: * -> *) (m :: * -> *) (f1 :: * -> *) a1 b d. (Ix i, Data.Array.Base.IArray a (f1 [a1] -> f1 [b]), Data.Array.Base.IArray a (a1 -> b), Data.Traversable.Traversable (
21:26:33 <lambdabot> a i), Applicative f, Monad m, Functor f1) => (d, a i (a1 -> b)) -> (d, a i (m (f (f1 [a1])) -> m (f (f1 [b]))))
21:26:35 <omnId> > (let fmapDefault = Data.Traversable.fmapDefault in second(fmapDefault(liftA>>>liftM).fmap<$>map)) ((), id) ((), (:[])) [[()]] [[[()]]]
21:26:36 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t3 -> t'
21:27:12 <omnId> did the type get truncated?
21:27:20 <shachaf> No.
21:27:26 <shachaf> I don't think so, it got split.
21:27:32 <FMota> problem #10 :/
21:28:01 <omnId> erm, I guess I gave the wrong type
21:28:29 <omnId> > (let fmapDefault = Data.Traversable.fmapDefault in second(fmapDefault(liftA>>>liftM).fmap<$>map)) ((), id) ((), (\_ _ -> [[()]]))
21:28:30 <lambdabot>  Couldn't match expected type `t1 -> t'
21:28:35 <omnId> closer :)
21:29:12 * omnId attempts to end the world
21:29:27 <FMota> hey, how do you force strict evaluation?
21:29:57 <shachaf> @ty let fmapDefault = Data.Traversable.fmapDefault; amap = Data.Array.IArray.amap; mapP = GHC.PArr.mapP in second`fmap`(fmapDefault(liftA>>>liftM).amap(mapP<$>map))
21:29:59 <lambdabot> forall (a :: * -> * -> *) i d (f :: * -> *) (m :: * -> *) a1 b. (Ix i, Data.Array.Base.IArray a ([:[a1]:] -> [:[b]:]), Data.Array.Base.IArray a (a1 -> b), Data.Traversable.Traversable (a i), Arrow a,
21:29:59 <lambdabot>  Applicative f, Monad m) => a i (a1 -> b) -> a (d, i) (d, m (f [:[a1]:]) -> m (f [:[b]:]))
21:30:06 <ddarius> omnId: Probably too late for you now, but this may help http://qntm.org/destroy
21:30:24 <FMota> how do you force strict evaluation? :/
21:30:54 <omnId> ddarius: "How to destroy the Earth"?  I've read it, good read :)
21:31:28 <shachaf> @ty let fmapDefault = Data.Traversable.fmapDefault; amap = Data.Array.IArray.amap; mapP = GHC.PArr.mapP in second`fmap`(fmapDefault(liftA>>>liftM).amap(mapP<$>map)) -- Any ideas from here on?
21:31:31 <lambdabot> forall (a :: * -> * -> *) i d (f :: * -> *) (m :: * -> *) a1 b. (Ix i, Data.Array.Base.IArray a ([:[a1]:] -> [:[b]:]), Data.Array.Base.IArray a (a1 -> b), Data.Traversable.Traversable (a i), Arrow a,
21:31:31 <lambdabot>  Applicative f, Monad m) => a i (a1 -> b) -> a (d, i) (d, m (f [:[a1]:]) -> m (f [:[b]:]))
21:31:44 <FMota> > !(1 + 1)
21:31:45 <lambdabot>   parse error on input `!'
21:31:50 <FMota> > (1 + 1)!
21:31:50 <lambdabot>   parse error on input `}'
21:31:54 <FMota> :/
21:32:07 <shachaf> FMota: That's only for function arguments/data declarations.
21:32:07 <omnId> > length [1..10^10] `seq` "blah!"
21:32:12 <lambdabot> Terminated
21:32:13 <shachaf> FMota: Try seq.
21:32:20 <omnId> > length [1..10^4] `seq` "blah!"
21:32:21 <lambdabot>  "blah!"
21:32:24 <shachaf> FMota: seq a b = force a, return b
21:32:32 <shachaf> FMota: (Force only to WHNF.)
21:32:58 <FMota> hm
21:33:09 <FMota> how does one use seq?
21:33:09 <omnId> > let x = 1 + 1 in x `seq` x * x
21:33:11 <lambdabot>  4
21:33:20 <omnId> @src ($!)
21:33:20 <lambdabot> Source not found. Do you think like you type?
21:33:22 <FMota> oh
21:33:23 <FMota> I see
21:33:37 <omnId> f $! x = x `seq` f x
21:34:03 <FMota> that works for me :)
21:34:27 <FMota> thank yous
21:34:31 <omnId> remember, it only forces the outermost constructor, you'll have to depend on more if you want to eval more
21:34:51 <omnId> (length xs `seq` ...) forces the spine of xs
21:35:27 <FMota> so essentially it tells haskell what order to eval things.
21:35:37 <omnId> which is somewhat evil
21:35:56 <FMota> :o XD
21:36:22 <ddarius> seq is evil.  Or at least it is at it's type.
21:36:35 <omnId> class Eval?
21:36:43 <shachaf> ddarius: At its type?
21:36:45 <FMota> class Evil !
21:36:49 <geocalc> > sum [1..sum[1..8]]
21:36:49 <shachaf> ddarius: What do you
21:36:51 <lambdabot>  666
21:36:54 <shachaf> mean?
21:36:58 <FMota> lol
21:37:04 <ddarius> shachaf: It should not be fully polymorphic.
21:37:18 <shachaf> Oh.
21:37:22 <ddarius> It should be in a class like in the good 'ole days.
21:38:07 <luqui> how come?
21:39:54 <ddarius> Because it complicates the equational properties of the language.  It complicates parametricity.
21:40:23 <luqui> hm
21:40:46 <ddarius> @free seq
21:40:48 <lambdabot> g . seq x = seq (f x) . g
21:41:00 <luqui> @help free
21:41:00 <lambdabot> free <ident>. Generate theorems for free
21:41:26 <ddarius> This theorem is false.
21:41:44 <luqui> oh I remember that paper.  I read it when I was first learning haskell.  I didn't understand it at all (maybe I should go back now)
21:42:06 <Pseudonym> ddarius: seq is not realisable in Haskell.
21:42:58 <FMota> hmm
21:43:13 <FMota> it only took about 10 minutes to calculate the sum of 1 million primes.
21:43:23 <luqui> that is quite a long time
21:43:27 <Pseudonym> Yes, it is.
21:43:28 <ddarius> Pseudonym: Indeed it is not.
21:43:28 <kaol> was the result a prime?
21:43:31 <Pseudonym> Which million was it?
21:43:37 <FMota> I wonder if using seq speeded it up or slowed it down
21:43:40 <Pseudonym> :type seq
21:43:45 <Pseudonym> :t seq
21:43:47 <lambdabot> forall a t. a -> t -> t
21:43:51 <Pseudonym> ?djinn a -> t -> t
21:43:51 <ddarius> sped
21:43:51 <lambdabot> f _ a = a
21:44:03 <Pseudonym> That function satisfies the free theorem.
21:44:05 <FMota> ONE MILLION DOLLARS *snickers, pinkie in mouth*
21:44:19 <ddarius> Pseudonym: Indeed it does.
21:44:20 <FMota> er, first million primes
21:44:42 <shachaf> > let f !a b = b in f undefined 5
21:44:42 <lambdabot>  Parse error in pattern
21:45:28 <kaol> > let f (!a) b = b in f undefined 5
21:45:28 <lambdabot>  Parse error in pattern
21:46:18 <lament> one time, I counted to a billion.
21:47:19 <shachaf> @set -XBangPatterns
21:47:19 <lambdabot>  Parse error
21:47:31 <shachaf> Hmm, what does that get corrected to?
21:47:36 <omnId> > 10^9 / 86400
21:47:37 <shachaf> Oh, @let.
21:47:41 <lambdabot>  11574.074074074075
21:47:51 <omnId> > 11574 / 365
21:47:53 <lambdabot>  31.70958904109589
21:48:02 <omnId> if you counted once per second, it'd take 32 years
21:48:51 <omnId> @google 1 billion seconds in years
21:48:53 <lambdabot> http://en.wikipedia.org/wiki/1_E17_s
21:48:53 <lambdabot> Title: 1 E17 s - Wikipedia, the free encyclopedia
21:49:07 <omnId> @google 1000000000 seconds in years
21:49:08 <lambdabot> 1,000,000,000 seconds = 31.6887646 years
21:49:16 <Pseudonym> ?google pi seconds in nanocenturies
21:49:19 <lambdabot> http://ircarchive.info/haskell/2007/2/28/4.html
21:49:19 <lambdabot> Title: haskell heh Why get the processor to do it when there's a perfectly good bot in  ...
21:49:28 <Pseudonym> ?google 3.14159 seconds in nanocenturies
21:49:30 <lambdabot> No Result Found.
21:49:36 <allbery_b> *snerk*
21:49:37 <Pseudonym> ?google pi seconds in centuries
21:49:38 <omnId>  ?frink
21:49:39 <lambdabot> pi seconds = 9.95531902 x 10^-10 centuries
21:49:45 <luqui> counting to a billion as long as you don't specify where to count from...
21:50:10 <luqui> > [0,500000000,1000000000]
21:50:12 <lambdabot>  [0,500000000,1000000000]
21:50:14 <luqui> > [0,500000000,..1000000000]
21:50:15 <lambdabot>  Parse error
21:50:17 <shachaf> @go pi furlongs per fortnight in metric inches per century
21:50:17 <luqui> > [0,500000000..1000000000]
21:50:18 <lambdabot> http://en.wikipedia.org/wiki/List_of_unusual_units_of_measurement
21:50:19 <lambdabot> Title: List of unusual units of measurement - Wikipedia, the free encyclopedia
21:50:19 <lambdabot>  [0,500000000,1000000000]
21:50:20 <luqui> there
21:50:22 <luqui> finally
21:51:52 <omnId> "metric inches"?
21:52:09 <shachaf> 2.5 centimeters, I think.
21:52:30 <omnId> hasn't the ordinary inch been redefined as 2.54 centimeters?
21:52:36 <FMota> :t elem
21:52:38 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
21:52:50 <shachaf> omnId: Yes, I think so.
21:53:17 <lament> inches are so cool
21:53:22 <lament> i used to be against the imperial system
21:53:40 <lament> but it's really cool that it's still around, it's a living relic of the past!
21:54:06 <platypus> Like the appendix.
21:54:22 <omnId> we should switch to planck units.
21:54:35 <omnId> it's the most logical decision
21:54:42 <shachaf> lament: And now you're against the imperative system?
21:54:59 <lament> shachaf: badum-ts?
21:55:22 <shachaf> lament: ?
21:55:26 <FMota> wtf? I got a stack overflow!
21:55:27 <FMota> wow.
21:55:53 <shachaf> > foldr (+) 0 [1..10000000] -- Not hard
21:55:55 <lambdabot>  Exception: stack overflow
21:56:12 <omnId> "I used to be against the imperial system"  "And now you're against the imperial system?"  There's been a misunderstanding here.
21:56:21 <omnId> imperative!
21:56:30 * omnId misunderstood
21:56:41 <lament> omnId: yes, just as you said :)
21:56:42 <ddarius> FMota: You're doing something wrong
21:56:46 <FMota> :/
21:57:02 <FMota> either that or I'm using too much memory
21:57:18 <FMota> but since haskell is lazy, that shouldn't be happening
21:57:23 <shachaf> #vim (see? I'm not the only one!): < lumgwada> 5j
21:57:42 <platypus> FMota: Do you have a space leak?
21:57:50 <FMota> idk
21:57:53 <shachaf> FMota: What are you doing that's causing it?
21:58:47 <FMota> I'm counting the total number of letters in the english words for 1 to 1000 inclusive
21:58:51 <FMota> problem # 17
21:59:32 <FMota> oh
21:59:34 <FMota> hm
21:59:39 <FMota> :/
21:59:41 <lament> that should neither run out of memory nor produce stack overflows.
21:59:43 <FMota> humbug
22:00:24 <FMota> word x | x < 100  = word (x - mod x 10) ++ "-" ++ word (mod x 10)
22:00:31 * FMota wonders if that is causing it.
22:00:40 <FMota> and doubts it, somehow
22:01:05 <shachaf> FMota: "NOTE: Do not count spaces or hyphens."
22:01:11 <FMota> I know
22:01:17 <shachaf> OK.
22:01:25 <FMota> but I'm doing the masochistic way of filtering those out afterwards
22:02:42 <ddarius> FMota: Actually, it's sadistic.  You aren't doing the symbol munging.
22:03:01 <FMota> but I am forcing myself to wait, so perhaps it's both
22:04:10 <luqui> it doesn't seem like the curry-howard isomorphism works for (a -> a) -> a
22:04:34 <shachaf> luqui: Y doesn't type-check.
22:04:43 <shachaf> luqui: It has to be provided as primitive, somehow.
22:04:48 <luqui> ahh
22:04:52 <ddarius> luqui: Y isn't something you want in your logic.
22:04:56 <ddarius> :t fix id
22:04:58 <lambdabot> forall a. a
22:05:15 <ddarius> There's a prood of falsity straight from the most basic axiom and Y.
22:05:23 <FMota> you think maybe it was my british spelling of forty? :o
22:05:59 <luqui> interesting.  that has something to do with the fact that representation of Y is equivalent to undecidability....
22:06:01 <luqui> ?
22:06:05 <luqui> well, more like !
22:06:43 <FMota>  /lol/
22:06:49 <FMota> I found out what it was
22:06:59 <ddarius> Recursive let?
22:07:01 <FMota> I hadn't specified a "word 8"
22:07:38 <FMota> obv, the number is wrong now
22:07:45 <FMota> but at least it finishes
22:09:35 <FMota> yay, got it right after 3 tries!
22:11:00 <FMota> > let fact 0 = 1; fact n = fact $ n - 1 in fact 100
22:11:01 <lambdabot>  1
22:11:04 <FMota> :o
22:11:11 <FMota> oops.
22:11:25 <allbery_b> that's not going to work too well :)
22:11:28 <ddarius> Count Down To Unity!
22:11:35 <FMota> > let fact 0 = 1; fact n = n * (fact (n - 1)) in fact 100
22:11:36 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
22:11:39 <FMota> xd
22:13:00 <luqui> > product [1..100] + 1
22:13:02 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
22:13:10 <luqui> My dad is richer than your dad!
22:13:34 <shachaf> > fix (+1)
22:13:35 <lambdabot>  Exception: <<loop>>
22:13:51 <shachaf> <<loop>>? Clever of it.
22:13:58 <FMota> yummy, I get to use map (:[]) again :)
22:14:20 <omnId> @quote \:\[
22:14:20 <lambdabot> psykotic says:  (:[]) is the happy monkey operator
22:14:29 <FMota> XD
22:14:32 <luqui> :[]... never thought of that, I always used return
22:14:46 <FMota> :[] is a lot nicer :)
22:15:02 <omnId> @quote \:\[\{
22:15:03 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
22:15:12 <shachaf> > fix (:[])
22:15:13 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
22:15:13 <lambdabot>       Expected...
22:15:29 <giles_bowkett> @google haskell regex
22:15:32 <lambdabot> http://www.dcs.gla.ac.uk/~meurig/regexp/
22:15:32 <lambdabot> Title: Regular Expressions in Haskell
22:16:02 <dfranke_> I'm trying to write a case-insensitive version of the Parsec combinator 'string'.  Here's what I have; is there any better way?
22:16:04 <FMota> I love expressions like this:
22:16:05 <dfranke_> ciString :: String -> CharParser st String
22:16:07 <dfranke_> ciString s = foldr (\a b -> do { a' <- a; b' <- b; return (a' : b')}) (return "") [ oneOf [toLower c, toUpper c] | c <- s ]
22:16:15 <FMota> sum . map read . map (:[]) . show $ num
22:16:48 <omnId> (\a b -> ...) = (liftM2 (:))
22:16:55 <ddarius> dfranke_: What the bloody hell?!
22:17:34 <omnId> @src sequence
22:17:34 <lambdabot> sequence ms = foldr k (return []) ms
22:17:34 <lambdabot>     where
22:17:34 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
22:17:39 <luqui> ddarius, thank you, he was making me feel stupid
22:17:54 <omnId> sequence [ ... ]
22:18:13 <luqui> thinking to myself, "I hope that's not the best way, because i don't understand that at all..."
22:18:16 <ddarius> mapM (\c -> satisfy ((toUpper c ==) . toUpper))
22:18:39 <shachaf> ddarius: Not toLower?
22:19:14 <luqui> :t satisfy
22:19:16 <lambdabot> Not in scope: `satisfy'
22:19:17 <dfranke_> ah, right.  sequence.
22:19:19 <luqui> oh it's a combinator
22:19:32 <ddarius> Let's interpret ci as case-invariant, mapM (\c -> satisfy ((toUpper c ==) . toLower))
22:20:48 <omnId> @src mapM
22:20:48 <lambdabot> mapM f as = sequence (map f as)
22:21:11 <omnId> turns a [Char] into a [Parser Char], then sequence into Parser [Char]
22:22:54 <luqui> @hoogle Either (a -> b) (c -> d) -> Either a c -> Either b d
22:22:55 <lambdabot> No matches, try a more general search
22:24:14 <shachaf> luqui: How would you write that?
22:24:52 <shachaf> luqui: What if you got an (a -> b) and a c?
22:25:45 <luqui> oh right
22:26:04 <omnId> @type either
22:26:06 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
22:26:28 <luqui> I meant
22:26:31 <omnId> @hoogle (a->c) -> (b->d) -> Either a b -> Either c d
22:26:31 <lambdabot> No matches, try a more general search
22:26:42 <luqui> yes, that omnId
22:27:07 <mauke> :t \f g -> either (Left . f) (Right . g)
22:27:09 <lambdabot> forall a b a1 b1. (a -> a1) -> (b1 -> b) -> Either a b1 -> Either a1 b
22:27:23 <omnId> --@type \f g -> either (Left . f) (Righ... bah
22:27:47 <shachaf> @djinn (a->c) -> (b->d) -> Either a b -> Either c d
22:27:47 <lambdabot> f a b c =
22:27:48 <lambdabot>     case c of
22:27:48 <lambdabot>     Left d -> Left (a d)
22:27:48 <lambdabot>     Right e -> Right (b e)
22:28:02 <omnId> @. pl djinn (a->c) -> (b->d) -> Either a b -> Either c d
22:28:02 <lambdabot> (line 3, column 12):
22:28:02 <lambdabot> unexpected ">" or "-"
22:28:02 <lambdabot> expecting variable, "(", operator or end of input
22:28:04 <shachaf> @. pl djinn (a->c) -> (b->d) -> Either a b -> Either c d
22:28:04 <lambdabot> (line 3, column 12):
22:28:04 <lambdabot> unexpected ">" or "-"
22:28:04 <lambdabot> expecting variable, "(", operator or end of input
22:28:16 <omnId> @pl \f g -> either (Left . f) (Right . g)
22:28:17 <lambdabot> (. (Right .)) . either . (Left .)
22:28:25 <luqui> I'll use that one
22:28:29 <luqui> it seems to be the clearest ;-)
22:28:37 <omnId> riiiiiiiiight
22:29:22 <omnId> @type liftM2 either (Left .) (Right .)
22:29:24 <lambdabot> forall a a1. (a -> a1) -> Either a a -> Either a1 a1
22:29:31 <omnId> nope
22:30:27 <FMota> :) I like TextMate. It makes Haskell easy
22:30:50 <ddarius> Apparently not easy enough.
22:31:11 <shachaf> I like vim. It makes Haskell fun. :-)
22:31:41 <FMota> lol
22:31:57 <FMota> *easier
22:44:53 <Tac-Tics2> what does it mean for something to be "boxed" or "unboxed" in functional programming?
22:45:03 <Tac-Tics2> I have a vague idea, but I can't find a good concrete definition
22:46:10 <shachaf> ?wiki Unboxed type
22:46:10 <lambdabot> http://www.haskell.org/haskellwiki/Unboxed_type
22:46:32 <Tac-Tics2> kind #?
22:47:44 <Tac-Tics2> that's not very explanative of what the term means =-(
22:48:59 <Tac-Tics2> it has something to do with strictness, doesn't it?
22:49:10 <LeCamarade> Yeah. That wiki page needs some work, it appears.
22:50:20 <lokimaf> what's the reverse of read that converts Int to String ?
22:50:33 <Tac-Tics2> show
22:50:37 <lokimaf> thanks
22:50:37 <Tac-Tics2> > show 55
22:50:39 <lambdabot>  "55"
22:50:44 <Tac-Tics2> > read $ show 55 :: Int
22:50:45 <lambdabot>  55
22:59:44 * FMota likes certain points-free definitions
22:59:48 <FMota> like this one:
22:59:54 <FMota> circular - all prime . rots
23:00:02 <FMota> * circular = all prime . rots
23:02:06 <lekro> does anyone know the binary extended gcd algorithm by Knuth? I'm struggling with finding the right formula for computing the s, t such that s*a + t*b = gcd(a,b). And unfortunately I don't have a copy of TAOCP here.
23:02:37 <sorear> don't need TAOCP
23:02:47 <sorear> any book on number theory will suffice
23:03:21 <lekro> it's the extended *binary* gcd algorithm
23:04:07 <sorear> oh, I thought you meant dyadic
23:04:15 <sorear> as opposed to N-adic
23:04:33 <lekro> what is dyadic in this context?
23:05:27 <lekro> I mean this algorithm: http://en.wikipedia.org/wiki/Binary_GCD_algorithm
23:05:27 <lambdabot> Title: Binary GCD algorithm - Wikipedia, the free encyclopedia
23:06:33 <lekro> just a hint in the right direction would be enough.
23:09:14 <Pseudonym> lekro: Have you seen the slides for Stepanov's talk about this?
23:09:21 <lekro> no.
23:09:43 <Pseudonym> http://www.stepanovpapers.com/gcd.pdf
23:13:04 <lekro> Pseudonym: as far as I can see it only describes the "basic" binary gcd algorithm and not the extended.
23:13:18 <Pseudonym> Oh, right.
23:13:28 <Pseudonym> It's still a fascinating read. :-)
23:14:11 <lekro> sure, I saved it
23:17:08 <lekro> it shouldn't be so complicated I guess. I just can't see the right way
23:17:40 <Pseudonym> Which case can't you do?
23:17:56 <lekro> I don't have an idea how to construct the s and t values
23:18:06 <lekro> such that s*a + t*b = gcd(a, b)
23:18:23 <lekro> all ideas I tried involved dividing by 2.
23:18:39 <Pseudonym> You know how to do it using the Euclidean algorithm?
23:18:45 <lekro> yes
23:19:25 <lekro> I'm beginning to think that dividing by 2 may be necessary. Then the only problem is to make sure the integer that is divided by 2 is even.
23:19:30 <Pseudonym> OK, let's work this out.
23:19:59 <Pseudonym> gcd n 0 = n,  s = 1, t = 0
23:20:11 <Pseudonym> gcd 0 n = n,  s = 0, t = 1
23:20:28 <Pseudonym> gcd 2n 2m = 2 * gcd m n
23:20:43 <Pseudonym> So if s*m + t*n = gcd m n
23:20:49 <Pseudonym> Then 2*s*m + 2*t*n = 2*gcd m n
23:21:02 <Pseudonym> Following so far?
23:21:02 <lekro> this case doesn't affect s and t
23:21:13 <Pseudonym> Sure it does.  It multiplies them by 2.
23:21:23 <lekro> but it multiplies gcd by 2 as well
23:21:30 <Pseudonym> Right.
23:21:36 <Pseudonym> Let's get more concrete.
23:21:52 <Pseudonym> @let steinGcd n 0 = (n, 1, 0)
23:21:58 <Pseudonym> @let steinGcd 0 n = (n, 0, 1)
23:22:00 <lambdabot> Defined.
23:22:07 <lambdabot> Defined.
23:22:43 <Pseudonym> @let steinGcd (2*n) (2*m) = let (g,s,t) = gcd n m in (2*g,2*s,2*t)
23:22:43 <lambdabot>  Parse error in pattern
23:22:57 <Pseudonym> Crap, this isn't gofer.
23:23:26 <Pseudonym> @let steinGcd n m | even n && even m = let (g,s,t) = gcd (n`div`2) (m `div`2) in (2*g,2*s,2*t)
23:23:27 <lambdabot> <local>:25:77:     Occurs check: cannot construct the infinite type: t = (t, ...
23:23:40 <Pseudonym> @let steinGcd n m | even n && even m = let (g,s,t) = gcd (n `div` 2) (m `div` 2) in (2*g,2*s,2*t)
23:23:41 <lambdabot> <local>:25:80:     Occurs check: cannot construct the infinite type: t = (t, ...
23:23:48 <Pseudonym> @let steinGcd n m | even n && even m = let (g,s,t) = steinGcd (n `div` 2) (m `div` 2) in (2*g,2*s,2*t)
23:23:56 <lambdabot> Defined.
23:23:58 <Pseudonym> That's it.
23:24:03 <Pseudonym> OK, those are the easy cases.
23:24:31 <Pseudonym> Now.  gcd 2n (2m+1) = gcd n (2m+1)
23:24:41 <lekro> I don't get why s and t are multiplied by 2
23:24:52 <Pseudonym> Suppose s*n + t*m = g
23:25:05 <Pseudonym> That's what the recursive call gives you.
23:25:07 <Pseudonym> Right?
23:25:15 <lekro> gcd 2 2 calls gcd 1 1 which should give us something like (1, 1, 0).
23:25:20 <Pseudonym> Right.
23:25:27 <Pseudonym> Hang on, think abstractly.
23:25:29 <lekro> gcd 2 2 should give us (2, 1, 0)
23:25:34 <lekro> no change in s.
23:25:36 <Pseudonym> The Stein algorithm gives:
23:25:45 <Pseudonym> gcd (2n) (2m) = 2 gcd n m
23:25:47 <Pseudonym> Right?
23:25:51 <lekro> right
23:25:58 <Pseudonym> Consider the recursive call.
23:26:17 <Pseudonym> That should give us s and t such that s*n + t*m = gcd n m
23:26:19 <lekro> this gives me s and t such that s*n + t*m = gcd n m
23:26:22 <Pseudonym> Right.
23:26:28 <Pseudonym> Oh, right.
23:26:31 <Pseudonym> Yeah.
23:26:45 <Pseudonym> We want s and t such that s*(2n) + t*(2m) = 2 gcd n m
23:26:51 <Pseudonym> ?forget
23:26:52 <lambdabot> Incorrect arguments to quote
23:27:17 <Pseudonym> ?undefine
23:27:19 <lambdabot> Undefined.
23:27:31 <Pseudonym> @let steinGcd n 0 = (n, 1, 0)
23:27:32 <lambdabot> Defined.
23:27:48 <Pseudonym> @let steinGcd 0 n = (n, 0, 1)
23:27:50 <lambdabot> Defined.
23:28:01 <Pseudonym> @let steinGcd n m | even n && even m = let (g,s,t) = steinGcd (n `div` 2) (m `div` 2) in (2*g,s,t)
23:28:04 <Pseudonym> That's right.
23:28:04 <lambdabot> Defined.
23:28:19 <Pseudonym> OK, do you follow that?
23:28:26 <lekro> yes.
23:28:31 <Pseudonym> Now.
23:28:42 <Pseudonym> gcd 2n (2m+1) = gcd n (2m+1)
23:28:56 <Pseudonym> Suppose you have s and t such that s*n + t*(2m+1) = gcd n (2m+1)
23:29:23 <Pseudonym> Then you want s' and t' such that s'*(2n) + t'*(2m+1) = gcd 2n (2m+1)
23:29:45 <lekro> and gcd 2n (2m+1) equals gcd n (2m+1)
23:29:51 <Pseudonym> Right.
23:30:28 <lekro> and this case is where I'm stuck.
23:31:00 <lekro> of course I cannot say s' = s `div` 2 because s might be odd
23:32:05 * Pseudonym does some arithmetic on paper
23:32:09 <lekro> either I'm missing something obvious or you need more information at that point.
23:32:22 <Pseudonym> If s is even, you're okay.
23:33:26 <Pseudonym> If s is odd, then s = 2p+1 for some p.
23:34:00 * Pseudonym thinks
23:34:10 <Pseudonym> You should be able to transfer the extra n over to t'.
23:37:32 <FMota> Programming in Haskell is a transformational experience. Who said Haskell was side-effect free?
23:40:20 <Pseudonym> Nope, sorry.
23:40:30 <Pseudonym> There's some obvious trick here that I'm not getting.
23:40:36 <Pseudonym> I _suspect_ you have to deal with mod 4.
23:45:20 <lekro> thanks anyway, I'll try to do something with mod 4
23:46:53 <lekro> n is a multiple of gcd n (2m+1)
23:47:33 <lekro> no, doesn't really help
23:48:00 <earthy> FMota: nobody. Haskell *does* make explicit what the side-effects can be and where they can occur though.
23:48:49 <FMota> really? then what is the type of haskell?
23:49:03 <FMota> Haskell :: Programmer -> Better Programmer    ?
23:49:37 <FMota> heh, Haskell is the constructor for the Better monad.
23:50:34 <FMota> if only "Better" were a monad... the world would be a Better place...
23:51:00 <nornagon> someone built a better type system, so haskell built a Better monad.
23:51:06 <FMota> lol
23:51:27 <Pseudonym> You could make the RealWorld a better place with BetterT IO.
23:52:08 <nornagon> heh
23:52:55 <nornagon> a >>= b = (Better a) b
23:54:04 <FMota> (>>=) :: Better a -> (a -> Better b) -> Better b -- a suddenly becomes altruistic and lets b do his thing
23:54:51 <FMota> hmm, I'm equating selfishness with Betterness... probably a cue that I should go to sleep.
23:58:00 <swix> I'm trying to convert (sqrt n) for use in [1..x]
23:58:06 <swix> I get all sorts of ambigous type issues
23:58:31 <Pseudonym> Sorry, could you explain what you're trying to do?
23:58:34 <FMota> implement your own sqrt
23:58:35 <FMota> ;)
23:59:16 <swix> I want [1..(sqrt n)]
23:59:20 <swix> but that's a float
23:59:26 <swix> so I want [1..(truncate (sqrt n))]
23:59:36 <Pseudonym> Right.
23:59:38 <swix> but I get all sorts of RealFrac, Floating not defined...
23:59:53 <Pseudonym> [1 .. truncate (sqrt (fromIntegral n))]
