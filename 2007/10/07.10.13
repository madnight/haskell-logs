00:00:15 <kilimanjaro> Does anybody know of work on a quickcheck for C?
00:07:53 <dibblego> could be written pretty easily
00:10:32 <Cale> Not nearly as beautifully
00:29:28 <luqui> what's the deal with Monoid (Maybe a) instances
00:29:38 <luqui> it seems like in the latest docs, there are none
00:29:58 <luqui> but in 6.8.0 there's a Monoid a => Monoid (Maybe a)
00:30:35 <luqui> and to get to my _real_ question, is there any way I can "override" that instance, make it go away, since I am compiling legacy code
00:37:34 <Cale> luqui: you need a different, incompatible instance?
00:37:48 <luqui> Cale, yes
00:38:08 <luqui> I need Monoid (Maybe a) without the Monoid a context
00:38:10 <luqui> you know the one...
00:38:45 <Cale> Oh, the one which is essentially the one coming from the monad?
00:38:54 <luqui> yeah
00:39:10 <Cale> mplus should work, if it's not really important that it be an instance of Monoid
00:39:35 <luqui> hmm, I'll see if the code likes that...
00:40:34 <Cale> mempty -> mzero, mappend -> mplus, mconcat -> msum
00:41:05 <luqui> damn
00:41:40 <Cale> Unless you have something which is generalised over monoids and needs to work with other monoids too
00:41:56 <luqui> apparently that is the case :-)
00:42:07 <Cale> Newtype?
00:42:15 <luqui> I'm trying that next
00:42:21 <luqui> I don't know how far-reaching the consequences are
00:42:28 <luqui> since I have no idea how this library works...
00:42:31 <Cale> It's really annoying how you can't decide not to import an instance.
00:44:37 <Cale> People have been changing the Monoid instances to be the ones which compose the best, which is reasonable, but it makes some of the really commonly-wanted monoids hard to access.
00:46:31 <luqui> What would be the automatically derived Monoid instance for Monoid a => X (b -> a)
00:46:40 <luqui> if my pseudohaskell makes sense...
00:47:46 <EvilTerran> instance Monoid a => Monoid (b -> a) where mzero = const mzero; (f `mplus` g) x = f x `mplus` g x --?
00:48:43 * luqui assumes EvilTerran meant mappend
00:48:57 <EvilTerran> ah, hes, quite. and mempte.
00:48:59 <Cale> Monoid b => Monoid (a -> b)
00:49:00 <EvilTerran> *mempty
00:49:19 <Cale> er, oh, you want the implementation?
00:49:41 <luqui> yeah; EvilTerran looks right
00:49:44 <Cale> it's just pointwise
00:51:11 <luqui> yeah, my brain is a bit fried
00:56:39 * EvilTerran meditates on localisable instances
00:59:33 <wnoise> @pl \n f -> foldl (.) id (replicate n f)
00:59:34 <lambdabot> (foldl (.) id .) . replicate
01:00:05 <EvilTerran> (!!n) . iterate f
01:00:44 <EvilTerran> @src iterate
01:00:45 <lambdabot> iterate f x =  x : iterate f (f x)
01:02:39 <wnoise> Ah, true.
01:04:28 <wnoise> @pl \n f -> (!!n) . iterate f
01:04:29 <lambdabot> (. iterate) . (.) . flip (!!)
01:05:11 <luqui> holy crap, it worked.  All i needed to do was to define MaybeMonoid and like 5 trivial instances
01:05:27 <luqui> (there are probably proposals to make such wrapping easier)
01:13:35 <luqui> aw crap.  any ideas how to resolve this:  /usr/local/lib/ghc-6.8.0.20071006/lib/readline-1.0/libHSreadline-1.0.a(Readline__211.o): In function `s6lg_info':
01:13:35 <luqui> ghc2421_0.hc:(.text+0x93): undefined reference to `readline'
01:13:47 <luqui> looks like an out of date library
01:13:55 <luqui> but I think it's shipped with ghc...
01:21:48 <luqui> resolved
02:00:16 <hpaste>  Mitar pasted "Correct indentation?" at http://hpaste.org/3264
02:00:55 <Mitar> hi, is this paste correctly indented if I would like that <?> covers the whole combinator?
02:02:22 <EvilTerran> i'd indent the body of the do{} again for clarity, even if that works
02:20:33 <fox86> what does the --make argument to ghc do?
02:22:32 <puusorsa> makes
02:22:43 <puusorsa> builds dependencies and is smart
02:24:03 <EvilTerran> the following of dependencies is the important bit
02:24:26 <EvilTerran> well, and checking timestamps to decide whether to build things or not
02:25:15 <Angel_Pri> http://st-pitch.miniville.fr/
02:25:17 <lambdabot> Title: Miniville
02:25:17 -Angel_Pri(i=eqnen@modemcable209.43-201-24.mc.videotron.ca)- http://st-pitch.miniville.fr/
02:25:20 <lambdabot> Title: Miniville
02:28:39 <fox86> okay, thanks
02:28:44 <EvilTerran> ...
02:38:54 <EvilTerran> btw, that ISP lets you report IRC spam (amoungst a slew of other things) from their IPs here: https://www.videotron.com/services/secur/Forward.do?to=/secur/en/service_clientele/abuse.jsp&lang=ENGLISH
02:38:55 <lambdabot> http://tinyurl.com/2ruo9l
02:46:08 <vwx> hello
02:51:16 <vwx> i'm getting warning: implicit declaration of function 'x'
02:55:50 <EvilTerran> vwx, are you exporting it or giving it a type annotation, but not actually defining it?
02:56:16 <vwx> i am using foreign import ccall, in order to call it
02:56:46 <EvilTerran> @paste?
02:56:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:56:47 <int-e> So it's a C compiler warning.
02:56:55 <vwx> int-e: yes
02:57:23 <int-e> foreign import allows you to specify a .h file with a prototype of the function.
02:58:13 <int-e> say,  foreign import ccall "x.h x" x :: type
02:58:25 <dibblego> is there a List.elem but for a sorted list?
02:58:32 <vwx> apart from the warning, the code works fine. what is the advantage of specifying a header file?
02:59:29 <int-e> you get a place to put a prototype of x() and get rid of the warning.
02:59:43 <dibblego> ?hoogle (Ord a) => a -> [a] -> Bool
02:59:43 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
02:59:44 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
02:59:44 <EvilTerran> dibblego, afraid not. maybe False (==x).head.takeWhile(<x) works, i think
02:59:49 <int-e> vwx: you can also ignore the warning, of course.
03:00:07 <dibblego> EvilTerran, I'm wondering where to start parsing your answer :)
03:00:27 <EvilTerran> ?type \x -> maybe False (==x).listToMaybe.takeWhile(<x)
03:00:29 <lambdabot> forall a. (Ord a) => a -> [a] -> Bool
03:00:39 <dibblego> ?type not. maybe False (==x).head.takeWhile(<x) works, i think
03:00:41 <lambdabot> parse error on input `,'
03:00:44 <int-e> vwx: in general, it assures that the C compiler generates correct code for calling x().
03:00:47 <dibblego> ?type not. maybe False (==x).head.takeWhile(<x)
03:00:49 <lambdabot> Not in scope: `x'
03:00:49 <lambdabot>  
03:00:49 <lambdabot> <interactive>:1:39: Not in scope: `x'
03:01:03 <dibblego> EvilTerran, thanks :)
03:01:16 <vwx> int-e: ok. i don't have a header file. it's just a small c file that i quickly wrote. is it worth it to make a header file for it?
03:01:28 <EvilTerran> hehe. no, the "not." wasn't meant to be part of it. the "maybe" was, though. but the "head" was wrong anyway.
03:01:47 <int-e> vwx: I'd make one.
03:05:54 <jedbrown> Any Data Parallel Haskellers here?
03:25:01 <pBot-> Morning folks!
03:41:58 <pBot-> Wzaa! =P
03:42:07 <vwx> hey
03:51:56 <pBot-> vwx, what up j0!? :D
03:53:45 <arcatan> uh
04:44:06 <LeCamarade> Does Wikipedia treat everyone the way it does me? I can't let go once I start!
04:44:23 <vwx> reading or writing?
04:44:25 <LeCamarade> It's pathetic. Wikiholics Anonymous, anyone?
04:44:29 <LeCamarade> Reading.
04:44:39 <LeCamarade> It
04:44:55 <LeCamarade> It's recursive and very long. _|_, one could say.
04:45:11 <jeffz> I don't find it that addictive... I've just started reading the prolog wikibook.
04:45:12 <huamn_> LeCamarade, I think we've all been there... just be strong!
04:46:07 <fox86> jeffz: why prolog?
04:47:21 <jeffz> fox86: I'd like to have familiarity with various programming languages - once I gain an understanding and appreciation for its weaknesses and strengths - then I might be able to answer your question.
04:48:12 <fox86> jeffz: i see. i never understood prolog until i found this: http://www.coli.uni-saarland.de/~kris/learn-prolog-now/lpnpage.php?pageid=online
04:48:14 <lambdabot> Title: Learn Prolog Now!, http://tinyurl.com/3boub2
04:49:29 <jeffz> fox86: thanks I'll check it out
05:16:15 <mcp> Hi, i just started to learn haskell. Now i need to annoy you with some syntax questions.
05:16:38 <Botje> ask away :)
05:16:59 <mcp> Why does   [y| y<- xs, y y>5] && length y == 3   not work?
05:17:12 <Botje> because y is not bound outside the []
05:17:14 <mcp> can i use the y list somehow later on?
05:17:25 <ibid> y is not a list
05:17:29 <Botje> oh
05:17:35 <ibid> y is an arbitrary element
05:17:36 <Botje> like that.
05:17:38 <mcp> Can i bind  [y] ?
05:17:46 <Botje> you need to give the name a list, yes
05:17:46 <ibid> length [ y | ... ] == 3 is what you want
05:17:59 <Heffalump> let ys = [y | y <- xs, y > 5] in length ts == 3
05:18:02 <Heffalump> s/ts/ys/
05:18:12 <Heffalump> or what ibid said if you don't also want to use ys in a more complicated expression
05:18:37 <mcp> ok, that simple. should have been able to figure out myself, thanks
05:21:27 <takamura> somebody here uses gtk2hs?
05:22:13 <vwx> takamura: yeah
05:22:30 <takamura> what is the difference between onKeyPress and afterKeyPress?
05:23:12 <Choko_> the moment of the event
05:24:12 <takamura> can you be more explicit?
05:24:40 <vwx> most events have an "on" version and an "after" version
05:25:18 <vwx> it's for ordering. first all of the registered "on" events will be fired, then all of the registered "after" events
05:26:06 <takamura> so, if I only have 1 event handler, the result is the same?
05:26:36 <takamura> for example, onKeyPress $ \e -> putStrLn "hello"
05:26:47 <takamura> and afterKeyPress $ \e -> putStrLn "hello"
05:26:51 <vwx> pretty much, except for the ordering with respect to internal gtk events
05:26:55 <takamura> have the same effect?
05:27:05 <vwx> yeah, those two have pretty much the same effect
05:27:27 <mcp> Ok, now i have the        let ys = [y | y <- xs, y > 5] in length ys == 3         part working. What i really want, is not to compare y >5, but to figure out which value of y will yield a list with lenght ys == 3. Is that possible or does haskell work different?
05:28:00 <hpaste>  dmhouse pasted "Memoisation" at http://hpaste.org/3266
05:28:15 <dmhouse> Hey all. I'm trying to implement a function that behaves as follows:
05:28:31 <dmhouse> 1 & n = n + 1
05:28:31 <dmhouse> m & 1 = (m - 1) & 2
05:28:31 <dmhouse> m & n = (m - 1) & (m & (n - 1))
05:29:14 <dmhouse> However, it's taking ages to compute even small values like 4 & 4, so I'm trying to speed it up by caching known results. The above paste is what I have so far. However this doesn't seem to be working.
05:29:32 <Japsu> err ;D
05:29:39 <Japsu> 4 & 4 is by no means a "small value" ;D
05:29:56 <dmhouse> Japsu: fine, well, my task is to compute 5 & 5, so relatively speaking :)
05:30:05 <Japsu> that seems to me like the ackermann function on steroids
05:30:17 <Japsu> ack would have "m & 1 = (m - 1) & 1" afaik
05:30:36 <Japsu> hmm no wait
05:30:45 <dmhouse> Anyway, the state modifications done by the lower branches don't seem to be 'seen' by the upper ones.
05:31:00 <Japsu> the definition I'm reading has zero instead of one on the LHS, so nvm
05:31:07 <Japsu> err, "state modifications"?
05:31:51 <dmhouse> Yeah, when a branch computes a value, it 'put's it into the memo table.
05:32:00 <Japsu> anyway, A(5,5) is a HUGE number
05:32:03 <dmhouse> But then when it bubbles up again those state modifications don't seem to be there.
05:32:38 <Japsu> http://en.wikipedia.org/wiki/Ackermann_function#Table_of_values
05:33:00 <dmhouse> Yeah, I just saw that.
05:34:46 <shapr> @quote
05:34:47 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
05:34:48 <shapr> aww
05:34:53 <dmhouse> Still, any help with the programming side? :)
05:38:10 <desegnis> mcp, I don't quite understand your question. Hm, do you fully understand how list comprehensions work? Because the length of ys will always be equal to the length of xs, and y is not an input to your program.
05:38:28 <desegnis> err, wait, nonsense
05:39:08 <desegnis> I mean, please ignore the part about the length of the lists
05:43:57 <shapr> @quote shapr
05:43:57 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
05:44:01 * shapr cries
05:44:12 <shapr> I want quotes!
05:46:03 <olsner> @quote
05:46:03 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
05:46:13 <olsner> shapr: I blame you for breaking it!
05:48:11 <Baughn> @quote .
05:48:12 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
05:48:18 <Baughn> @quote monad
05:48:18 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
05:48:36 <Baughn> Broken, yep.
05:49:13 <LeCamarade> Oh, God. The soul is gone. @quote is broken.
05:49:32 * LeCamarade settles down to watch dons' video on Xmonad. :-D
05:50:04 <LeCamarade> Someone get them Haskell vids on torrent! I saw GeekTorrent.com or something. Vee vant zem on tor!
05:50:49 <shapr> olsner: It's not my fault!
05:51:01 <shapr> olsner: Too bad I'm driving off to another city now, or I'd try to fix it.
05:51:23 <olsner> shapr: so you claim, but why should I believe the one who broke @quote? :P
05:51:33 <shapr> I'm trustworthy, really!
05:51:45 <Saizan_> dmhouse: the problem is that you put the  modified old memo so you lose every modification that happens in the recursive call, because you get memo before it
05:52:45 <Saizan_> dmhouse: so instead of put (M.insert (m, 1) val memo) you need modify (M.insert (m, 1) val), an hard to spot oversight!
05:52:53 * shapr drives away &
06:00:11 <Baughn> dmhouse: Plus, M.insert is an O(n) operation. You might take advantage of laziness to build an infinite, self-referring "memoizer"..
06:01:13 <Baughn> ..on checking, it's actually O(lg n). Apparently there's lots of sharing going on. Never mind, carry one.
06:03:17 <Saizan_> Baughn: yeah, you need to modify only a path in the tree
06:04:32 <Baughn> Saizan_: Thus producing more garbage than the imperative version, but not asymptotically more
06:06:57 <LeCamarade> @tell dons I'm watching your xmonad.mov ... why do you Australians say IPI when you mean API? :o)
06:06:57 <lambdabot> Consider it noted.
06:07:15 <LeCamarade> @tell lambdabot Hi
06:07:15 <lambdabot> Nice try ;)
06:07:19 <LeCamarade> :o)
06:07:33 <opqdonut> :o)
06:07:50 <LeCamarade> > id ":o)"
06:07:50 <lambdabot>  Unbalanced parenthesis
06:07:56 <LeCamarade> >id ":o)"
06:08:13 <Baughn> ..what?
06:08:15 <LeCamarade> > id ":o)" -- Langauge.Haskell bug!
06:08:15 <lambdabot>  Unbalanced parenthesis
06:08:15 <Baughn> > id
06:08:16 <matt__r> aiy pee iay
06:08:18 <matt__r> a;0
06:08:19 <lambdabot>  Add a type signature
06:08:26 <int-e> > is "(o:" -- :o)
06:08:26 <lambdabot>   Not in scope: `is'
06:08:28 <Baughn> :t id
06:08:28 <int-e> > id "(o:" -- :o)
06:08:30 <lambdabot> forall a. a -> a
06:08:32 <lambdabot>  "(o:"
06:08:50 <int-e> there's a sanity check too much in the eval plugin.
06:08:54 <Baughn> > ["(","o:"]
06:08:54 <lambdabot>  Unbalanced parenthesis
06:08:57 <Baughn> Indeed
06:09:21 <int-e> > map pred ";p*"
06:09:23 <Baughn> "#haskell - When good sanity checks go bad"
06:09:23 <lambdabot>  ":o)"
06:09:32 <paczesiowa> > ':' : 'o' : ')' : []
06:09:32 <lambdabot>  Unbalanced parenthesis
06:09:53 <paczesiowa> > {-(-} ':' : 'o' : ')' : []
06:09:54 <lambdabot>  ":o)"
06:10:04 <paczesiowa> I won!
06:10:32 <int-e> > {-(-} ) . ( {-)-}
06:10:32 <lambdabot>   parse error on input `)'
06:10:52 <LeCamarade> > map ord [58, 111, 41]
06:10:53 <lambdabot>   add an instance declaration for (Num Char)
06:10:53 <lambdabot>     In the expression: 41
06:11:14 <LeCamarade> > map ord [58, 111, 41] :: [Char]
06:11:15 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
06:11:21 <xerox> 'chr'
06:11:22 <LeCamarade> > map chr [58, 111, 41] :: [Char]
06:11:24 <lambdabot>  ":o)"
06:11:27 <LeCamarade> :o)
06:11:43 <Baughn> :t chr
06:11:45 <lambdabot> Int -> Char
06:11:49 <Baughn> That type signature was irrelevant
06:11:57 <xerox> :t toEnum
06:11:59 <lambdabot> forall a. (Enum a) => Int -> a
06:12:04 <LeCamarade> Yeah. I was bulldozing my way through a dumb bug.
06:19:43 <LeCamarade> Ah. dons campaigns against the use of error! :o)
06:19:59 <LeCamarade> I hate error. I hedge myself into Maybe a, but never undefined.
06:20:49 <LeCamarade> Even my factorial, these days, returns Maybe Integer. ;o)
06:21:32 <olsner> yeah, a function that can fail should have that explicit in its type
06:22:11 <LeCamarade> olsner: Problem is that the Maths guys say `undefined'. Bottom is the Maths' guys' baby.
06:22:39 <LeCamarade> And teh syntactic overhead of Maybe ... But that's minor.
06:22:44 <LeCamarade> s/teh/the/
06:23:06 <EvilTerran> LeCamarade, surely you should use a generic monadplus and give back mzero? ;)
06:23:24 <olsner> yeah, error/undefined is more convenient than explicit Maybe
06:23:30 <EvilTerran> (or a MonadError, i guess)
06:23:32 <LeCamarade> Oh, Haskellers. :o)
06:23:53 <LeCamarade> Monads, monads, monads ... `I had a baby. Little Monad, we call her.'
06:23:59 <LeCamarade> :o)
06:25:00 <Saizan_> for factorial the best solution would be a Natural type
06:32:35 <thepointer> howdie. i'm writing custom data types.. i basically am triyng to do data MemValue = Instruction | Integer | Label deriving (Show). ive previously defined Label as just type Label = String, however it's saying im trying to redeclare it.
06:33:06 <thepointer> am i right in saying.. 'type' is just used to alias things?
06:33:14 <olsner> data A = Constructor Type | Constructor2 Type2
06:33:25 <olsner> so you'd have to have e.g. InstructionValue Instruction
06:33:41 <thepointer> and 'data' gives a specific name a bunch of possible values, like what enum does in other languages
06:33:55 <thepointer> ahh ok
06:34:36 <thepointer> how does it work when i just have a single word there? such as data MemValue = Singleword | Anothersingleword
06:35:00 <thepointer> that's not in the form contructor Type | Constructor2 Type2
06:35:05 <olsner> then it's like an enum
06:35:40 <olsner> data is somewhat like a Variant data type
06:36:07 <jgrimes> how can you exclude a file from having haddock run on it with cabal?
06:36:10 <thepointer> so if i had typeLabel = String, then have later data MemValue = Instruction | Integer | Label Name
06:36:57 <olsner> no, it'd be LabelValue Label... and later on you could have f x = LabelValue x, if x is a Label
06:37:37 <Saizan_> jgrimes: there's a hide directive in the haddock syntax, but i've never used it, just seen in some modules
06:37:53 <jgrimes> Saizan_, thanks, I'll look into it
06:39:15 <olsner> thepointer: http://en.wikibooks.org/wiki/Haskell/Type_declarations
06:39:37 <thepointer> ill read up on it
06:39:38 <thepointer> thanks mate.
06:41:56 <jgrimes> better yet, anyone have any problems with haddock running on alex generated .hs files? haddock is saying it can't parse it
06:42:38 <Japsu> > let poly x = -61.5 * x^2 + 114.5 * x + 58 in map (toEnum . floor . poly) [0..2] :: String
06:42:40 <lambdabot>  ":o)"
06:42:44 * Japsu claims victory
06:43:18 * benny applauds Japsu 
06:44:09 <opqdonut> bah, he uses floor
06:44:11 <opqdonut> that's cheating
06:44:19 <opqdonut> :))
06:44:51 <Japsu> opqdonut: what you say !!
06:45:21 <olsner> using rational it should be possible to get real integer values
06:45:39 <Japsu> > let poly x = (-123 * x^2 + 229 * x + 116) `div` 2 in map (toEnum . poly) [0..2] :: String
06:45:41 <lambdabot>  ":o)"
06:45:55 <Japsu> opqdonut: better?
06:45:59 <opqdonut> much :)
06:46:15 <olsner> > let poly x = (-123 % 2) * x^2 + (229 % 2) * x + (116 % 2) in map (toEnum . poly) [0..2] :: String
06:46:16 <lambdabot>  Couldn't match expected type `Int' against inferred type `Ratio t'
06:46:31 <Japsu> I think you can't toEnum with a ratio
06:46:46 <olsner> @src Ratio
06:46:46 <lambdabot> data (Integral a) => Ratio a = !a :% !a
06:47:30 <olsner> @instances-importing RAtio
06:47:31 <lambdabot> Couldn't find class `RAtio'. Try @instances-importing
06:47:35 <olsner> @instances-importing Ratio
06:47:36 <lambdabot> Couldn't find class `Ratio'. Try @instances-importing
06:48:03 <olsner> oh, perhaps I want the inverse of instances-importing
06:49:26 <opqdonut> > let trig x = 107.117*(sin x) + 80.784*(cos x) + -22.784*x in map (toEnum . floor . poly) [0..2] :: String
06:49:28 <lambdabot>   Not in scope: `poly'
06:49:33 <opqdonut> > let trig x = 107.117*(sin x) + 80.784*(cos x) + -22.784*x in map (toEnum . floor . trig) [0..2] :: String
06:49:34 <lambdabot>      precedence parsing error
06:49:34 <lambdabot>         cannot mix `(+)' [infixl 6] and prefix ...
06:49:52 <opqdonut> > let trig x = 107.117*(sin x) + 80.784*(cos x) -22.784*x in map (toEnum . floor . trig) [0..2] :: String
06:49:54 <lambdabot>  "Pn\DC2"
06:50:01 <opqdonut> some days just don't work out right...
06:51:52 <opqdonut> > let trig x = 107.117*(sin x) + 80.784*(cos x) -22.783 in map (toEnum.floor.trig) [0..2] :: String
06:51:54 <lambdabot>  ":o)"
06:51:55 <opqdonut> there
06:52:14 <scook0> \o/
06:52:19 <Japsu> hehe
06:52:54 <cjay> :)
06:53:12 <Japsu> oh, that's neat
06:53:39 <Japsu> started to wonder how to craft a function like that, but in the end that's no different to mine
06:53:44 <Japsu> just rref'ing a matrix
06:55:32 <Japsu> rref([ 0 0 1 58; (1 1 1 111; (2*2) 2 1 41 ]) vs. rref([ sin(0) cos(0) 1 58; sin(1) cos(1) 1 111; sin(2) cos(2) 1 41])
06:55:36 <Japsu> oops
06:55:43 <Japsu> rref([ (0*) 0 1 58; (1*1) 1 1 111; (2*2) 2 1 41 ]) vs. rref([ sin(0) cos(0) 1 58; sin(1) cos(1) 1 111; sin(2) cos(2) 1 41])
06:55:46 <Japsu> grr
06:55:53 <Japsu> rref([ (0*0) 0 1 58; (1*1) 1 1 111; (2*2) 2 1 41 ]) vs. rref([ sin(0) cos(0) 1 58; sin(1) cos(1) 1 111; sin(2) cos(2) 1 41])
06:56:07 <xerox> what's rref?
06:56:16 <Japsu> reduced row echelon form of a matrix
06:56:27 <xerox> alright
06:56:36 <Japsu> http://en.wikipedia.org/wiki/RREF
06:57:05 <Japsu> basically a solution to a group of linear equations
06:57:32 <olsner> obfuscate :: (Math -> AsciiArt) -> (AsciiArt -> AsciiArt)
06:57:43 <Japsu> ;D
06:58:58 <byorgey> @pl \x y -> x + 1
06:58:58 <lambdabot> const . (1 +)
07:00:01 <opqdonut> yeah of course
07:00:13 <opqdonut> neat would be doing an underdetermined fit
07:00:19 <opqdonut> but couldn't think of any
07:00:29 <Japsu> heh, yeah
07:00:52 <opqdonut> or a non-linear one
07:01:07 <opqdonut> ae^x+b^e(cx)
07:01:29 <olsner> or in terms of the ackermann function
07:01:36 <opqdonut> or that
07:01:49 <opqdonut> or in terms of roots of the riemann function
07:03:05 <olsner> is there an algorithm for calculating digits from ackermann function values? then just take A(4,4) and choose your offset(s)
07:03:41 <olsner> take 100 (show infinitePrecisionPi)
07:06:09 <oerjan> digits of what?
07:07:20 <oerjan> there might be a quick way of calculating the last few digits of A(x,y)
07:07:21 <bakert> i have happs0.8.8 and happs0.9.1 installed and ghc doesn't like it.  is there an easy way to tell it to forget about 0.8.8?
07:07:57 <olsner> yeah, instead of calculating the whole of A(4,4), enumerating the digits of it, from any direction
07:08:19 <oerjan> i think the _first_ digits may be impossible, though
07:08:37 <oerjan> well, for something a bit larger than 4, anyway
07:09:23 <daniel_larsson> bakert: Use ghc-pkg (--help)
07:09:28 <bakert> daniel_larsson: thanks
07:09:33 <olsner> yeah, sounds like you'd need to evaluate the value completely to know the first digit
07:10:07 <oerjan> but for the last ones there might be some modulus simplificaction
07:10:18 <oerjan> *ation
07:13:43 <olsner> > (2^(2^65536))-3 `mod` 10
07:13:48 <lambdabot> Terminated
07:15:27 * SamB finds the volume knob on his monitor
07:15:29 <oerjan> > 2^100
07:15:31 <lambdabot>  1267650600228229401496703205376
07:16:15 <xerox> > length (show (2^65536))
07:16:17 <oerjan> > 36*36
07:16:17 <lambdabot>  19729
07:16:18 <lambdabot>  1296
07:16:20 <SamB> unfortunately when I turn it down it gets harder to see stuff on the screen
07:16:33 <oerjan> > 76*76
07:16:35 <lambdabot>  5776
07:17:00 <oerjan> > 2^200
07:17:02 <lambdabot>  1606938044258990275541962092341162602522202993782792835301376
07:17:41 <oerjan> seems like 2^(100*n+m) = 2^m*376 (mod 100)
07:19:19 <xerox>  ?check it :)
07:20:59 <oerjan> @check \m n -> m >= 0 && n >= 1 ==> (2^(100*n+m)-2^m*376) `div` 100 == 0
07:21:01 <lambdabot>  Add a type signature
07:21:26 <madduck> someone around to help a haskel pre-newbie with a linker error?
07:21:27 <madduck> ghc -package Cabal Setup.hs -o ./setup
07:21:27 <madduck> :collect2: ld returned 1 exit status
07:21:34 <oerjan> @check \m n -> (m::Integer) >= 0 && (n::Integer) >= 1 ==> (2^(100*n+m)-2^m*376) `div` 100 == 0
07:21:36 <lambdabot>  Falsifiable, after 0 tests: 1, 1
07:21:44 <madduck> i am just trying to make a debian package for someone else and i have no idea what the cause of the above is...
07:22:06 <oerjan> @check \m n -> (m::Integer) >= 0 && (n::Integer) >= 1 ==> (2^(100*n+m)-2^m*376) `mod` 100 == 0
07:22:08 <lambdabot>  Arguments exhausted after 286 tests.
07:22:17 <sieni> madduck: pre-newbie :-D, that's a new one ,-)
07:22:29 <xerox> oerjan: so now time to prove it!
07:22:36 <oerjan> xerox: already did
07:22:42 <oerjan> > 2^100
07:22:44 <lambdabot>  1267650600228229401496703205376
07:22:46 <oerjan> > 2^200
07:22:48 <lambdabot>  1606938044258990275541962092341162602522202993782792835301376
07:22:51 <madduck> sieni: i am trying to get some pity. :)
07:22:57 <Baughn> madduck: Typically, that error means ld is failing to find some library it wants
07:23:06 <oerjan> you will note that both end in 376. the rest is simple modulus calculation
07:23:09 <Baughn> madduck: Or failing to read
07:23:30 <madduck> Baughn: right, but how do i find out which one it is?
07:24:01 <int-e> > 376^2 `mod` 1000 == 376
07:24:02 <lambdabot>  True
07:24:31 <Baughn> madduck: An excellent question. You could try strace, I suppose.
07:24:59 <madduck> Baughn: hm, even *C* gives more information. :)
07:25:29 <Baughn> madduck: Normally, my next step after seeing that error is to check configure.log..
07:25:35 <oerjan> > 2^36*376
07:25:37 <lambdabot>  25838523252736
07:25:42 <Baughn> madduck: ld *does* print an error to stderr, but ghc is apparently discarding it
07:25:52 <Baughn> madduck: Maybe with -v or -d?
07:25:52 <madduck> ok, lemme try to reproduce.
07:26:06 <oerjan> this shows that 2^(100*n+36) `mod` 100 == 36
07:27:42 <oerjan> apply to 2^2^2^2 == 65536
07:29:10 <sieni> oerjan: what are you doing?
07:30:12 <oerjan> sieni: seeing how to calculate the last digits of results of the ackermann function
07:30:20 <sieni> ah
07:30:50 <oerjan> > 2^736 `mod` 1000
07:30:52 <sieni> I just spotted that 376 is related to that thingie: http://www.research.att.com/~njas/sequences/A016090
07:30:53 <lambdabot>  736
07:30:53 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
07:30:55 <sieni> e,g.
07:31:04 <sieni> > 743740081787109376 ^ 2
07:31:06 <lambdabot>  553149309256696143743740081787109376
07:31:20 <sieni> you see that it ends with the same digits
07:31:43 <oerjan> yep
07:32:00 <sieni> The other sequence is the one ending in 5: http://www.research.att.com/~njas/sequences/A007185
07:32:02 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
07:32:42 <oerjan> you might expect 2^2^2^... to eventually end in that sequence
07:32:55 <oerjan> er...
07:33:05 <oerjan> 2^10000000...
07:33:42 <oerjan> and if it does, then you can calculate the last digits of ackermann numbers
07:33:58 <Beelsebob_> > 2^1000000000
07:34:03 <lambdabot> Terminated
07:34:06 <Beelsebob_> aww :(
07:35:23 <shachaf> Why does zlib's .cabal talk about base 2.1.1/2.2? Isn't base still at 2.1?
07:35:25 <sioraiocht> thank you ssh tunnelling
07:35:53 <oerjan> Beelsebob_: you need to do the calculation (mod 10^n) for some n
07:37:22 <oerjan> a quick Num instance would do - but not in lambdabot
07:37:41 <shachaf> (I mean the darcs zlib, with GHC 6.9.20071002)
07:37:54 <fasta> What's wrong with this? import Data.Sequence((:>),(:<))
07:38:14 <fasta> I get: Module `Data.Sequence' does not export `:<'
07:38:17 <oerjan> fasta: they're constructors, import them as part of the type
07:38:36 <oklopol> hihi smileys
07:38:55 * oklopol giggles
07:38:57 * oklopol kills a puppy
07:39:10 <fasta> oerjan: odd error message then
07:39:13 <fasta> oerjan: thanks
07:43:26 <oerjan> @let powBy (*) a 0 = 1; powBy (*) a n | even n = p2 | otherwise = a*p2 where p2 = powBy (*) (a*a) (n`div`2)
07:43:40 <lambdabot> Defined.
07:44:30 <madduck> Baughn: the problem was actually, *cough*, out of disk space in my chroot.
07:44:33 <oerjan> > powBy (\m n -> m*n `mod` 10^30) 2 (10^30)
07:44:35 <lambdabot>  893380022607743740081787109376
07:44:54 <madduck> thanks anyway!
07:45:10 <olsner> > powBy (\m n -> m*n `mod` 10^30) 2 (2^65536)
07:45:14 <lambdabot> Terminated
07:45:29 <oerjan> that indeed includes the entire sequence on that page
07:46:14 <oerjan> (as far as written)
07:46:56 <oerjan> > powBy (\m n -> m*n `mod` 10^30) 2 (10^30) -- repetition for Beelsebob
07:46:58 <lambdabot>  893380022607743740081787109376
07:47:48 <phlpp> what the hell are you trying to proof? :D
07:48:32 <oerjan> for a start, that you can calculate the last digits of 2^n without calculating the whole number
07:48:49 <oerjan> er...
07:49:05 <oerjan> actually, without knowing more than the final digits of n
07:49:40 <oerjan> > powBy (\m n -> m*n `mod` 10^30) 2 (10^10)
07:49:42 <lambdabot>  46163501446374549681787109376
07:50:36 <oerjan> hm, seems like you need to know at least the same number of digits
07:50:43 <oerjan> which is not so surprising
07:51:51 <oerjan> oh... there's a formula on that page which implies this
07:52:04 <oerjan> a(n) = 16^(5^n) mod 10^n
07:52:22 <olsner> so, the n last digits of 2^2^65536 is the nth number of that sequence?
07:53:14 <oerjan> not quite, you need to consider that 2^65536 does not end in zeros.
07:53:49 <oerjan> but from the next number on, they all end in 736 for example
07:54:20 <oerjan> > 2^736
07:54:23 <lambdabot>  3614737867146518396094859318021923665089733007170019231594754471504248102862...
07:54:26 <oerjan> er...
07:54:42 <oerjan> > 2^736 `mod` 1000
07:54:43 <lambdabot>  736
07:54:59 <fasta> How is the generalization of mapM called?
07:55:16 <fasta> (for different list like types)
07:55:32 <oerjan> @hoogle mapM
07:55:33 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:55:33 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
07:55:33 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
07:55:42 <oerjan> @hoogle+
07:55:43 <lambdabot> Data.Set.mapMonotonic :: (a -> b) -> Set a -> Set b
07:55:43 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
07:55:43 <lambdabot> Data.Generics.Basics.gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
07:55:51 <Olathe> @hoogle-
07:55:51 <lambdabot> Maybe you meant: hoogle hoogle+
07:56:29 <oerjan> :t Data.Traversable.mapM
07:56:31 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
07:58:22 <oerjan> fasta: the last one
07:58:33 <fasta> oerjan: yes, I already have it. Thanks
08:04:58 <fasta> If a module reexports a module, can I hide that module too?
08:05:20 <fasta> E.g. import Control.Monad.Identity hiding (Control.Monad)
08:05:30 <oerjan> i don't think so
08:05:56 <oerjan> you can hide every identifier in it the usual way
08:06:17 <fasta> That would go against ADT, I guess.
08:06:44 <oerjan> also, there would be no way to distinguish it from a class or type
08:10:45 <fasta> There are no generic ways to test for an "empty traversable" thing, so it seems.
08:11:55 <oerjan> fasta: you can do it with the Maybe monad, i think
08:12:22 <oerjan> mapM (const Nothing)
08:12:49 <oerjan> if it's not empty, you get Nothing, if it's empty you get Just something
08:13:15 <oerjan> otoh that's probably inefficient, hm
08:13:29 <fasta> oerjan: heh, I don't immediately see how your code works, but I have an idea too.
08:14:32 <oerjan> oh wait it's not, should work perfectly
08:14:42 <fasta> Hmm, but those instances don't exist (for my idea)
08:14:44 <chessguy> @type mapM (const Nothing)
08:14:46 <lambdabot> forall a a1. [a1] -> Maybe [a]
08:14:54 <oerjan> chessguy: Traversable.mapM
08:15:09 <chessguy> @index mapM
08:15:09 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:15:17 <oerjan> although the usual one is a special case
08:15:32 <oerjan> :t Data.Traversable.mapM
08:15:35 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
08:16:10 <oerjan> > Data.Traversable.mapM (const Nothing) M.empty
08:16:39 <oerjan> @bot
08:16:44 <oerjan> eek
08:16:51 <chessguy> you killedit!
08:17:01 <lambdabot>  Just (fromList [])
08:17:01 <lambdabot> :)
08:17:06 <chessguy> @type Data.Traversable.mapM (const Nothing)
08:17:08 <lambdabot> forall a a1 (t :: * -> *). (Data.Traversable.Traversable t) => t a1 -> Maybe (t a)
08:17:23 <oerjan> > Data.Traversable.mapM (const Nothing) M.fromList [(1,1),(1,2)]
08:17:25 <lambdabot>  Couldn't match expected type `[(t1, t2)] -> t'
08:17:31 <oerjan> > Data.Traversable.mapM (const Nothing) $ M.fromList [(1,1),(1,2)]
08:17:33 <lambdabot>  Nothing
08:19:13 <oerjan> it works :)
08:19:26 <oerjan> @botsnack
08:19:27 <lambdabot> :)
08:20:31 <chessguy> M is a Map?
08:20:52 <oerjan>  @run imports Data.Map as M
08:21:03 <chessguy> > Data.Traversable.mapM (const Nothing) M.empty
08:21:05 <lambdabot>  Just (fromList [])
08:21:24 <oerjan>  :t does not so it's a bit confusing
08:21:41 <chessguy> err, don't you want the other way around? Nothing if it's M.empty, and Just something if it's not?
08:22:23 <chessguy> well, i don't know what you're soing
08:22:25 <oerjan> chessguy: you can always fix it up afterwards
08:22:25 <chessguy> *doing
08:22:48 <fasta> oerjan: hmm, that's pretty clever.
08:22:49 <oerjan> chessguy: fasta asked for a way to test if a Traversable is empty
08:23:09 <chessguy> ah, fair enough
08:23:20 * chessguy shuts up
08:27:10 <fasta> oerjan: for pure structures that's O(1), right?
08:27:35 <fasta> (assuming getting the first element takes O(1))
08:27:58 <chessguy> a map is usually O(n)
08:28:01 <oerjan> fasta: however long mapM takes to find the first element i guess
08:28:20 <oerjan> chessguy: this is monadic so it should shortcut
08:28:49 <oerjan> > Data.Traversable.mapM (const Nothing) [1..]
08:29:01 <lambdabot>  Nothing
08:29:06 <chessguy> nice
08:29:50 <chessguy> so that's specialized support in GHC for monads?
08:29:56 <oerjan> implementing mapM to be O(1) to start should be possible for maps, if you can access the structure
08:30:17 <oerjan> chessguy: Traversable is portable afaik
08:31:03 <oerjan> in fact i am testing it from WinHugs
08:34:01 <Saizan> ?type Data.Traversable.mapM
08:34:03 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
08:34:50 <oerjan> actually i think this is O(log n) for map - it descends down the tree
08:36:19 <oerjan> but this is still dwarfed by building the map in the first place
08:37:21 <oerjan> (especially since map is "strict in the spine", so you cannot avoid some of the overhead even with laziness)
09:00:00 <mcp> The haskel tutorial says:  [ f x | x <- xs ]    is "the list of all f x such that x is drawn from xs.".  Whats the meaning of the 'f' there?
09:00:14 <oerjan> any function
09:00:16 <integral> f is a function
09:00:42 <int-e> > [ a+1 | a <- [3..5]] -- any expression works there actually
09:00:44 <lambdabot>  [4,5,6]
09:00:56 <LoganCapaldo> do { x <- xs; return (f x) }
09:00:57 <mcp> ok, understood
09:01:23 <LoganCapaldo> xs >>= \x -> return (f x)
09:01:37 <xerox> fmap f xs
09:01:39 <LoganCapaldo> all I want for christmas ismonad comprehensions
09:02:27 <oerjan> is fmap how you pronounce map without two front teeth?
09:02:28 <LoganCapaldo> it's only fmap f if you don't start throwing in guards and such
09:03:00 <kpreid> @remember LoganCapaldo all I want for christmas is monad comprehensions
09:03:00 <lambdabot> Done.
09:03:06 <monochrom> <3 the lambdacats comics
09:03:25 <int-e> liftM, map, fmap. *hmm*
09:03:31 <int-e> @type liftA
09:03:34 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
09:04:05 <int-e> > liftA succ [1..3]
09:04:07 <lambdabot>  [2,3,4]
09:04:27 <oerjan> :t [liftM,map,fmap,liftA,(<$>)]
09:04:30 <lambdabot> forall a1 r. [(a1 -> r) -> [a1] -> [r]]
09:04:55 <int-e> > pure succ [1..3]
09:04:56 <lambdabot> Terminated
09:05:05 <kpreid> oerjan: cute
09:05:16 <oerjan> > pure
09:05:17 <lambdabot> Terminated
09:05:38 <oerjan> it's ambiguous i think
09:05:41 <oerjan> :t pure
09:05:41 <LoganCapaldo> man could we please have more ways to spell map? :)
09:05:43 <lambdabot>     Ambiguous occurrence `pure'
09:05:43 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
09:05:52 <int-e> it was wrong anyway.
09:05:59 <LoganCapaldo> I don't think there are enough
09:06:49 <int-e> I really think 5 and 3 different type classes are enough :P
09:07:52 * kpreid contemplates the notion that liftM should only be used in Functor instances
09:08:20 <int-e> > foldr ((:) . succ) [] [1..2]
09:08:22 <lambdabot>  [2,3]
09:08:32 <int-e> @pl \f -> foldr ((:) . f) []
09:08:32 <lambdabot> flip foldr [] . ((:) .)
09:08:40 <oerjan> kpreid: monad you mean
09:08:52 <kpreid> oerjan: no
09:08:53 <sorear> 'map'
09:09:00 <oerjan> :t liftM
09:09:02 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:09:46 <oerjan> :t Data.Traversable.fmapDefault
09:09:48 <lambdabot> forall a b (t :: * -> *). (Data.Traversable.Traversable t) => (a -> b) -> t a -> t b
09:10:10 <kpreid> I mean as in "instance Functor Foo where fmap = liftM"
09:10:12 <oerjan> found another one :)
09:10:34 <int-e> hmm. class Functor m => Monad m where ...
09:11:06 <oerjan> kpreid: like that fmapDefault above...
09:11:25 <kpreid> I would imagine so
09:12:07 <Cheery> I'm trying to generate 'artificial script' for bit strings (the old topic), I'd need ideas and math
09:12:21 <wsdo_okadr> what ide's can be used for writing haskell code under linux ?
09:12:54 <thoughtpolice> conal: thanks for the email. i'm working on getting the lib to work with 6.8 but i'm getting an issue with hot code loading, since apparently even though a reboot and whatnot works, it doesn't actually reload new code even though it's told to force recompilation... i'm thinking maybe if people need this plugin-esque feature preserved, it needs to be finally merged into the ghc api or something...
09:13:14 <Cheery> http://en.wikipedia.org/wiki/Artificial_script
09:13:15 <lambdabot> Title: Constructed script - Wikipedia, the free encyclopedia
09:13:23 <oerjan> @seen conal
09:13:24 <lambdabot> conal is in #ghc and #haskell. I don't know when conal last spoke.
09:13:34 <conal> oerjan: yo
09:14:00 <oerjan> conal: just wondering if thoughtpolice was talking to the wall there :)
09:14:08 <fasta> wsdo_okadr: short answer, none, long answer: google Haskell IDE
09:14:22 <thoughtpolice> tab complete saves lives. :)
09:14:42 <conal> oerjan: thanks.  i missed thoughtpolice's comment.
09:15:25 <Cheery> I wonder what sort of question has short answer in fasta's scale
09:15:33 <conal> thoughtpolice: this behavior changed between 6.6 & 6.8?
09:16:15 <fasta> oerjan: getting the tail of a traversable in a lazy way is not going to work, I guess?
09:16:25 <thoughtpolice> conal: not sure yet.
09:16:45 <oerjan> fasta: for one thing, a list is a traversable and you cannot do it for those
09:17:04 <oerjan> oh wait
09:17:10 <fasta> oerjan: tail (_:xs) = xs ?
09:17:16 <oerjan> thought you said last element
09:17:28 <oerjan> a traversable might not even _have_ a tail
09:17:39 <oerjan> a map doesn't
09:18:02 <oerjan> unless you restructure it
09:18:03 <fasta> Ok, so I should have a tailable, then.
09:18:31 <oerjan> and traversable operations never restructure afaiu
09:19:26 <thoughtpolice> conal: if it is though, then I think some work to stick something like this into the api might be needed since apparently hs-plugins is fragile, and the api can't provide what I need..
09:19:38 <int-e> @type deleteFindMin
09:19:40 <lambdabot> Not in scope: `deleteFindMin'
09:19:47 <int-e> @type Data.Map.deleteFindMin
09:19:49 <lambdabot> forall k a. Data.Map.Map k a -> ((k, a), Data.Map.Map k a)
09:20:46 <conal> thoughtpolice: Simon PJ said just last week that he's very interested in suggestions for improving ghc-api.  He described it as "exposed" rather than "designed".
09:21:26 <conal> For instance, I want to submit code in a data-type form rather than concrete syntax.
09:21:36 <conal> (submit for compilation & evaluation)
09:23:25 <fasta> conal: there's only a string interface now?
09:23:42 <conal> fasta: afaik
09:24:40 <fasta> They should just expose everything and have other people build on that for some time.
09:25:08 <conal> fasta: i could be way off.  i haven't gotten ghc-api going yet.  the docs seem to be for 6.6 and i'm running 6.8.
09:25:15 <fasta> It will probably break very fast, but well, you need some experimentation.
09:25:28 <fasta> I doubt there's only a string interface, though.
09:26:42 <Cheery> hmm... maybe not 'artificial script' but a shorthand system for bit strings
09:28:13 <thoughtpolice> conal: how did your hackathon project go on a hs-plugins replacement?
09:28:32 <conal> thoughtpolice: no action
09:31:00 <thoughtpolice> conal: hm from the looks of the updates of the api it might take care of this problem i'm having with the lib
09:31:16 <conal> thoughtpolice: oh -- good news :)
09:31:20 <thoughtpolice> quite. :)
09:32:14 <conal> thoughtpolice: i want to generate & compile code dynamically in Eros, especially for image synthesis.  i'm at a bit of a loss in how to get started.  i thought i'd start working from the wiki docs, but they're out of date.
09:33:13 <marcotmarcot> Hello, is there a catch for pure functions?
09:33:26 <marcotmarcot> I just want to catch errors thrown by error
09:33:34 <matthew-_> yes
09:33:37 <thoughtpolice> conal: hm yes somewhat. if this provides the ability to reload object code, i hope it's of some use to you. :)
09:33:48 <matthew-_> oh, well error and fail may be slightly different
09:33:50 <matthew-_> @type fail
09:33:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
09:33:53 <matthew-_> @type error
09:33:55 <lambdabot> forall a. [Char] -> a
09:34:01 <matthew-_> @type catch
09:34:03 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
09:34:07 <oerjan> :t Control.Exception.catch
09:34:10 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
09:34:28 <matthew-_> oh, that's not what I was expecting
09:34:50 <marcotmarcot> matthew-_: that was not what I expected also.
09:35:13 <oerjan> marcotmarcot: only the Control.Exception one can catch errors thrown from pure functions.  Neither can catch _as_ a pure function
09:35:36 <marcotmarcot> hum..
09:35:38 <matthew-_> so fail is the solution then
09:35:47 <matthew-_> as you'll be able to deal with that in the monad
09:35:48 <marcotmarcot> I think I will use Either instead of error.
09:35:53 <marcotmarcot> Either String a
09:36:19 <matthew-_> > (fail "foobar") :: Either String String
09:36:21 <lambdabot>  Left "foobar"
09:36:30 <matthew-_> > (return "foobar") :: Either String String
09:36:31 <lambdabot>  Right "foobar"
09:36:49 <oerjan> :t Control.Monad.Error.catch
09:36:51 <lambdabot> Not in scope: `Control.Monad.Error.catch'
09:37:13 <oerjan> :t catchError
09:37:15 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
09:37:28 <matthew-_> @instances MonadError
09:37:29 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
09:37:53 <marcotmarcot> hum..
09:37:57 <marcotmarcot> This is a good solution.
09:39:23 <marcotmarcot> catchError?
09:39:27 <marcotmarcot> Where is this from?
09:39:36 <oerjan> @index catchError
09:39:36 <lambdabot> Control.Monad.Error
09:39:54 <marcotmarcot> I don't got this here.
09:40:01 <marcotmarcot> Is it in a package?
09:40:07 <oerjan> mtl
09:40:10 <oerjan> i think
09:41:23 <marcotmarcot> oerjan: thanks.
10:09:47 <dons> http://programming.reddit.com/info/2zrw0/comments
10:09:48 <lambdabot> Title: Functional Pearl: Composing Fractals :: PDF (reddit.com)
10:25:16 <cognominal_> @src print
10:25:16 <lambdabot> print x = putStrLn (show x)
10:26:02 <Beelsebob> hmm
10:26:10 * Beelsebob wonders why there's not print and printLn
10:26:21 <Beelsebob> for the sake of consistancy
10:27:10 <nominolo> print already prints a newline
10:27:33 <jcreigh> nominolo: right, be he's saying print = putStr . show and printLn = putStrLn . show
10:27:34 <nominolo> and it's more meant for debugging
10:27:34 <byorgey> Beelsebob: there's putStr and putStrLn.  print is just for convenience.
10:28:00 <byorgey> Beelsebob: feel free to redefine =)
10:28:05 <nominolo> jcreigh, well. but i'd never use print then ;)
10:28:16 <byorgey> import Prelude hiding (print)
10:28:22 <byorgey> print = .... printLn = ...  and so on
10:28:33 <Beelsebob> nominolo: it's not meant for debugging at all
10:28:45 <Beelsebob> that's what the trace calls are for
10:29:07 <nominolo> i only use it in my tests
10:29:15 <monochrom> Moreover, trace has the right type :)
10:29:45 <Beelsebob> I have to admit, I do only tend to use putStrLn and putStr, but meh
10:30:23 <nominolo> for printing output to the user you rarely ever want to use print
10:30:43 <Beelsebob> I tend to end up with things like putStrLn $ concat ["here's a something:", show something, "\n and a nother thing:", show otherThing]
10:30:45 <nominolo> i usually have a PPrint class anyways
10:31:47 <nominolo> that's worth a shortcut then
10:32:00 <nominolo> or we use template haskell and add quoting
10:33:02 <nominolo> ie, out "foo ${bar} baz " === putStrLn $ "foo " ++ show bar ++ " baz"
10:33:59 <nominolo> it might even be better to use a pretty printer library everywhere, so that you never have to care about wrapping text,
10:34:48 <Beelsebob> true
10:34:52 <Beelsebob> would be nice
10:35:05 <Beelsebob> wow... I do believe you've found a use for template Haskell I actually like :P
10:36:24 <Beelsebob> nominolo: tbh, I think one thing that would solve it would be (a) give the Show class another function (pretty for example) (b) allow overlapping instances
10:36:50 <nominolo> Beelsebob, not my idea: http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem
10:36:52 <lambdabot> Title: A type-based solution to the "strings problem": a fitting end to XSS and SQL-inj ..., http://tinyurl.com/uv94m
10:37:00 <Beelsebob> so that pretty :: [String] -> String could be defined as being concatination
10:38:17 <nominolo> Beelsebob, there is shows and similar less-known combinators
10:38:37 <jleedev> Can someone help me get lhs2TeX to align my code properly (in guards, patterns, etc.)?
10:40:14 <nominolo> Beelsebob, i'd prefer a separate class in any case.  we should always have: read . show = id
10:40:21 <Beelsebob> true
10:40:40 <Beelsebob> a Pretty class would be nice acutally
10:40:52 <Beelsebob> that did pretty printing of anything
10:40:54 <byorgey> jleedev: sure, put the part you're having trouble with on hpaste
10:41:13 <byorgey> @hpaste
10:41:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:41:20 <byorgey> erm
10:41:26 <byorgey> there we go =)
10:41:47 <hpaste>  jleedev pasted "lhs2TeX example" at http://hpaste.org/3268
10:42:24 <jleedev> it's not lining up, for example, the = signs
10:43:04 <byorgey> jleedev: to get lhs2TeX to line stuff up for you, it has to be lined up in the code
10:43:17 <byorgey> and things that line up also sometimes need at least two spaces in front of them.
10:43:35 <jleedev> aha
10:43:38 <jleedev> i was using just one space
10:43:55 <jleedev> ok, it's working
10:44:08 <hpaste>  byorgey annotated "lhs2TeX example" with "(no title)" at http://hpaste.org/3268#a1
10:44:20 <byorgey> ok, great =)
10:44:33 <jleedev> @karma+ byorgey
10:44:33 <lambdabot> byorgey's karma raised to 4.
10:44:46 <byorgey> yeah, the two spaces is necessary since otherwise it doesn't know whether you want to line something up or just have a space.
10:44:54 <byorgey> but two (or more) spaces is unambiguous.
10:45:03 * jleedev nods
10:45:32 <dons> xmoand 0.4 release candidate, http://code.haskell.org/~sjanssen/xmonad-0.3.20071012.tar.gz
10:45:36 <dons> for you xmohad haskell fans
10:45:47 <dons> grr.
10:45:51 <dons> caffeines !
10:46:34 <dons> so are we going to take over the world today, guys?
10:46:48 <nominolo> nah, i'm too tired
10:46:57 <dons> oh, nominolo :)
10:47:25 <nominolo> no, what does pinky usually say?
10:47:36 <TomMD> @quote pinky
10:47:37 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
10:48:17 <dons> ?brain
10:48:17 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
10:48:21 <dons> ?quit weirdo
10:48:25 <nominolo> http://en.wikiquote.org/wiki/Pinky_and_the_Brain
10:48:36 <sieni> nominolo: wanha
10:48:43 <dons> ?brain
10:48:47 <lambdabot> Well, I think so, Brain, but 'apply North Pole' to what?
10:49:58 <dons> heh, cute, http://intralimina.livejournal.com/684758.html ;)
10:53:10 <dons> ?users
10:53:10 <lambdabot> Maximum users seen in #haskell: 420, currently: 376 (89.5%), active: 3 (0.8%)
10:54:20 <Igloo> It's    takeWhile (> 0) $ drop 1 $ scanl (-) n [i..]    isn't it?
10:54:44 <nominolo> heh, dons, haskell/FP really *is* different
10:55:21 <nominolo> i liked the num2digits example in Andy Gill's thesis intro
10:56:16 <nominolo> > map (`mod`10) . takeWhile (>0) . iterate (`div` 10) $ 543
10:56:22 <lambdabot>  [3,4,5]
10:56:40 <nominolo> > reverse . map (`mod`10) . takeWhile (>0) . iterate (`div` 10) $ 543489
10:56:42 <lambdabot>  [5,4,3,4,8,9]
10:57:20 <dons> Igloo: i always see anything that ends in [a] as an unfoldr these days :}
10:58:22 <dons> > (\n -> takeWhile (> 0) . drop 1 . scanl (-) n $ [i..]) 100
10:58:23 <lambdabot>   Not in scope: `i'
10:58:23 <nominolo> :t unfoldr
10:58:25 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:58:29 <dons> > (\n -> takeWhile (> 0) . drop 1 . scanl (-) n $ [0..]) 100
10:58:31 <lambdabot>  [100,99,97,94,90,85,79,72,64,55,45,34,22,9]
10:58:35 <dons> looks like it :)
10:59:01 <Igloo> unfoldr often doesn't seem to quite fit, e.g. if you want to give a last element when your seed is empty
10:59:30 <dons> yeah, that's true
10:59:44 <dino-_> dons: heh, that reminds me of some time not long ago where you said to me 'everything is a funny kind of fold, eh?' or similar.
10:59:51 <Igloo> I don't think that problem would be pretty as a unfoldr either, but I'm willing to be proven wrong
11:02:55 <byorgey> > takeWhile (>0) . tail . flip (scanl (-)) [0..] $ 100
11:02:57 <lambdabot>  [100,99,97,94,90,85,79,72,64,55,45,34,22,9]
11:07:16 <dons> byorgey: you should add that to the guys blog
11:07:20 <dons> so he gets a sense of what's possible
11:07:24 <byorgey> ok, I will
11:07:50 <TomMD> Why does 'qC = quickCheck' and then s/quickCheck/qC/g  break things  - shouldn't this be a trivial identity?
11:08:22 <dmwit> monomorphism restriction?
11:08:27 <nominolo> let a = a in a
11:08:34 <nominolo> :)
11:08:48 <dmwit> Try it with -fno-monomorphism-restriction
11:08:59 <nominolo> TomMD, or paste
11:09:19 <doserj> > unfoldr (\(n,i) -> if n >= 0 then Just (n,(n-i,i+1)) else Nothing) (100,0)
11:09:20 <lambdabot>  [100,100,99,97,94,90,85,79,72,64,55,45,34,22,9]
11:09:42 <doserj> > unfoldr (\(n,i) -> if n >= 0 then Just (n,(n-i,i+1)) else Nothing) (100,1)
11:09:44 <lambdabot>  [100,99,97,94,90,85,79,72,64,55,45,34,22,9]
11:14:10 <LoganCapaldo> magic where clause?
11:15:04 <LoganCapaldo> would he have had the same reaction if the guy had just written (n - i) : f (i + 1) (n - i) ?
11:24:19 <fox86> yaht makes a Test.hs and says "module Test" on the first line of the file. is it common to name the "main"  file with a capital first letter?
11:24:36 <fox86> by "main", i mean the file you run
11:25:55 <TomMD> Not just common, but a necessity.
11:26:11 <byorgey> fox86: module names must be uppercase.
11:26:19 <LoganCapaldo> but filenames?
11:26:24 <LoganCapaldo> surely not?
11:26:25 <byorgey> but not filenames =)
11:26:41 <byorgey> it's common (but not necessary) to name the file the same as the module it provides.
11:27:18 <byorgey> although I think it *is* necessary in certain circumstances.
11:27:24 <dons> oh, we need to get mjd's posts on planet haskell
11:27:32 <dons> Cale: seen http://blog.plover.com/2007/10/12/#catalan-squared ?
11:27:33 <lambdabot> Title: The Universe of Discourse : The square of the Catalan sequence
11:27:52 <byorgey> I know!  I was like, "oh good, he DOES know some Haskell". =)
11:27:57 <oerjan> it is necessary if you want to import the file from another module
11:28:07 <dons> heh
11:28:19 <dons> byorgey: we need to tempt him into the dark side
11:28:27 <byorgey> dons: for sure.
11:28:27 <mauke> he's been here before
11:28:34 <dons> ?seen mjd
11:28:35 <lambdabot> I haven't seen mjd.
11:28:37 <dons> yeah, he has.
11:28:39 <LoganCapaldo> for it to be uppercase, or for it to have the same name as the module?
11:28:41 <mauke> ?seen yrnlry
11:28:42 <lambdabot> I haven't seen yrnlry.
11:28:49 <LoganCapaldo> s/uppercase/capitalized/
11:28:57 <byorgey> LoganCapaldo: same name as the module; hence, capitalized.
11:29:08 <oerjan> to have the name that the compiler searches for when importing
11:29:17 <LoganCapaldo> See but I'm pretty sure ghc works on systems with case insensitive filesystems...
11:29:38 <byorgey> oh, well, those don't count. =P
11:30:09 <allbery_b> pah :>
11:30:15 <LoganCapaldo> I'm just wondering if the logic in ghc is case sensitive or not
11:31:02 <LoganCapaldo> or if it just does bother checking but goess from module name to "what the file name should be" and opens
11:31:11 <LoganCapaldo> s/does/doesn't/
11:31:30 <allbery_b> (b) I think
11:31:50 <dons> ok, i've asked mjd to join p.h.o
11:32:40 <mauke> Physicians Health Organization?
11:33:04 <dons> pho, vietnamese noodle soup thing
11:35:04 * ddarius loves pho
11:35:22 <mauke> Pyrococcus horikoshii
11:35:32 <nominolo> nono, perl is the dark side
11:40:13 <Cale> dons: cute
11:40:49 <nominolo> of course the darcs side is more seductive
11:40:58 <Cale> dons: Of course, this is why databases should support more varied types in their columns :)
11:42:04 <magnus_> feedback sought on: http://haskell.org/haskellwiki/Library/Data_encoding
11:42:05 <lambdabot> Title: Library/Data encoding - HaskellWiki
11:42:35 <dons> hey magnus_ .
11:42:47 <magnus_> hey dons
11:45:04 <magnus_> dons, are you taking a look at the page?
11:45:17 <magnus_> only if you have time, of course
11:45:21 <Cale> you're missing a k from a close tag
11:45:34 <magnus_> thanks Cale
11:46:57 <magnus_> Cale, fixed
11:47:11 <dons> dcoutts_: should --user imply --prefix=$HOME ?
11:47:16 <dons> one user was confused
11:47:19 <magnus_> Cale, anything relating to the contents?
11:48:08 <Cale> Is this a proposal for a library or a description of an existing library?
11:48:47 <Cale> In any event, it looks fine to me :)
11:48:48 <magnus_> Cale, it's written already, I'm about to release it on the world
11:49:24 <magnus_> Cale, I'm especially interested in hearing thoughts on the location (Codec.Binary.*)
11:52:07 <Saizan> magnus_: what about using phatom types to annotate the encoding and use a typeclass to unify the interfaces?
11:53:11 <magnus_> Saizan, what would that buy?
11:54:04 * magnus_ has never quite understood what phantom types are good for
11:54:18 <LoganCapaldo> I wish there was an interactive type session :)
11:54:35 <LoganCapaldo> have the time when I open ghci its because I want to fiddle with types (not values)
11:54:39 <LoganCapaldo> and then I'm like wait
11:54:42 <Saizan> well using something in an encoding where another is expected will result in a type error
11:54:43 <LoganCapaldo> can't do that :)
11:54:44 <newsham> I have a type question -- I want to add type annotations to my "where" definitions, but when I do so, its giving me type errors which I think has to do with the polymorphism: http://www.thenewsh.com/%7Enewsham/formal/curryhoward/Work.hs
11:54:55 <newsham> is there a way to add type annotations that work there?
11:55:32 <fox86> anyone using emacs with haskell-mode? the indentation is acting very strange...http://rafb.net/p/Ppr1mq15.html
11:55:34 <lambdabot> Title: Nopaste - No description
11:55:44 <magnus_> Saizan, you mean to tie together encode and decode?
11:56:12 <monochrom> Right, the local "p" type variable is not the same as the global "p" type variable.
11:56:26 <oerjan> newsham: iirc you need to add foralls to the top level type declarations
11:56:36 <Saizan> newsham: you want to use lexically scoped type variables, to bring one in scope you've to explicitly use forall in the enclosing type annotation
11:56:39 <newsham> the current code type checks.
11:56:42 <oerjan> this turns on ghc's scoped type variables
11:57:09 <newsham> so if I add a "forall p" to the outer type decl, then when I use "p" in the inner scope it will mean the same one?
11:57:17 <Saizan> yes
11:57:23 <newsham> sweet.. thank you
11:57:28 <monochrom> If you really want to do it, enable scoped type variables. Then write "subsume :: forall p q. p :=> q -> (p :/\ q) := p". Then you can use p locally.
11:57:49 <oerjan> iirc, i think you need to forall every variable in a declaration if you forall one
11:58:05 <Saizan> oerjan: no
11:58:06 <newsham> yup, that worked.  thanks guys!
11:58:24 <oerjan> i mean every one which really is polymorphic
11:58:41 <newsham> not having type checking in the intermediate states makes doing these a lot harder
11:58:49 <oerjan> that was my impression from a previous discussion anyhow
12:00:13 <newsham> now only if there was a way for me to ask what the types of these intenral decls are (would be nice having an IDE where you could highlight something and get the type info)
12:00:44 <oerjan> newsham: maybe you could force them to mistype
12:00:44 <ddarius> newsham: See the Chameleon type debugger perhaps?
12:00:59 <oerjan> (and read the type from the error message)
12:02:51 <newsham> ok, one more, in updated version, exclMiddle has double-nesting and I cant get it tow ork properly
12:03:15 <newsham> wait, I prob got the types wrong
12:03:23 <magnus_> Saizan, I added your suggestion on the discussion page (http://haskell.org/haskellwiki/Talk:Library/Data_encoding), just so I don't lose it :)
12:03:24 <lambdabot> Title: Talk:Library/Data encoding) - HaskellWiki
12:05:58 <jgrimes> where are haddock bugs tracked?
12:06:20 <newsham> yup, everything is honkey dorey.  thanks again.
12:06:42 <dons> jgrimes: you could record them on the ghc bug tracker
12:08:06 <jgrimes> dons, ok.
12:13:01 <magnus_> Saizan, thanks for your help and suggestion
12:13:21 <magnus_> see you around, dons
12:13:38 * magnus_ needs to have some dinner...
12:16:30 <newsham> how does one do false-elimination in haskell type system?   (~P |- False) |- P
12:17:11 <nominolo> you can't
12:17:15 <fox86>     putStrLn "Hello world " ++ show((i . j) 5)
12:17:15 <fox86>  ... hmm, this doesn't compile
12:17:34 <mauke> fox86: you can't ++ IO
12:17:35 <mauke> needs more parens
12:17:38 <nominolo> fox86, put parens around ( ... ++ ... )
12:17:54 <TomMD> fox86:  Or use $.  putStrLn $ "Hi" ++ "Junk"
12:18:03 <newsham> nominolo: is that the classic logic != curry-howard diff?
12:18:03 <byorgey> fox86: function application has highest precedence, so it parses as (putStrLn "...") ++ ...
12:18:07 <oerjan> newsham: that is actually not true in constructive logic
12:18:08 <Yokisho> how can hugs compile a .hl file?
12:18:15 <nominolo> newsham, yep
12:18:21 <fox86> aaah. thank you
12:18:25 <nominolo> newsham, you need LEM
12:18:37 <newsham> so excluded middle becomes an axiom?
12:18:43 <nominolo> right
12:18:45 <newsham> (I have it as a theorem based on not-elim)
12:18:49 <nominolo> or some equivalent
12:19:04 <newsham> is it possible ot prove demorgans without not-elim/excl-middle?
12:19:28 <fox86> putStrLn ("Hello world " ++ show((i . j) 5)) worked. what does the alternative with the $ mean? that everything that follows $ is passed to the function?
12:19:49 <byorgey> @src ($)
12:19:49 <lambdabot> f $ x = f x
12:19:50 <mauke> $ is an operator that does nothing
12:19:55 <thoughtpolice> function application
12:20:01 <byorgey> $ is just function application, but with low precedence.
12:20:09 <byorgey> it's useful for avoiding too many parens.
12:20:11 <oerjan> newsham: demorgan isn't true in constructive logic either
12:20:26 <fox86> okay, thank you
12:20:40 <newsham> so how can I define excluded middle as an axiom?  just give its type and set exclMiddle = undefined ?
12:20:55 <newsham> (thats sort of what I have for falseElim right now)
12:21:20 <nominolo> newsham, actually, i think a continuation has that type
12:21:36 <newsham> ahh, i remember reading about that somewhere.. thats in a monad reader article somewhere right?
12:21:41 <oerjan> newsham: if you have one you can derive the other
12:21:44 <nominolo> ((a -> b) -> a) -> b
12:21:46 <nominolo> or so
12:22:21 <nominolo> newsham, might be.  you can also give negation a meaningful semantics
12:22:42 <newsham> nomi: i already have (http://www.thenewsh.com/%7Enewsham/formal/curryhoward/Natural.hs)
12:22:52 <newsham> Not p means given a p anything is true
12:22:55 <nominolo> http://research.microsoft.com/~simonpj/papers/not-not-ml/index.htm
12:22:57 <lambdabot> Title: Haskell is not not ML, http://tinyurl.com/ffv6s
12:23:02 <oerjan> nominolo: that's callCC isn't it.
12:23:29 <oerjan> a continuation accepting a is not a
12:23:30 <nominolo> oerjan, yep, except that callCC is monadic in haskell
12:23:40 <nominolo> :t callCC
12:23:42 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
12:23:56 <nominolo> so, i was wrong :)
12:24:09 <TomMD> Is ByteString API calming down?  I noticed the change from LPS to Chunk and from .Base to .Internal.
12:25:20 <newsham> ahh, found it.. monad reader 6 "adventures in classical-land"
12:26:27 <sorear> TomMD: that's... not the API
12:26:50 <nominolo> oerjan, i'm not sure. they should be equivalent since Peirce's Law is essentially LEM
12:26:59 <sorear> TomMD: that's the quasi-undocumented interal interface that you shouldn't be using anyway
12:28:03 <oerjan> nominolo: i meant ~~a -> a vs. LEM
12:28:21 <sorear> nominolo: curry-howard maps the simply typed lambda calculus to *intutionistic* quantifier-free propositional calculus
12:28:40 <sorear> ~~a -> a isn't even true, intuitionistically speaking
12:28:40 <oerjan> i don't quite remember if peirce's law is enough
12:28:53 <oerjan> sorear: er, that's what we are discussing, essentially
12:28:54 <nominolo> sorear, so?  you can still give classical constructs a useful semantics
12:29:09 <newsham> i'm trying to play with classical logic
12:29:31 <newsham> (my goal is to work through "haskell road to logic/math/prog" exercises using haskell types
12:30:20 <nominolo> oerjan, in that paper i linked above ~T is called a continuation
12:30:38 <newsham> data Not p = Not (forall q . p -> q)
12:30:57 <ddarius> newsham: You can embed the classical -propositional- logic into intuitionistic propositional logic.
12:31:01 <newsham> is what I'm using.  if something is not true, then it can be used to construct a proof of anything
12:31:26 <newsham> ddarius: i'm doing prop. logic I guess.
12:32:18 <sorear> I
12:32:29 <sorear> I'd recommend using a real proof system.
12:32:32 <ddarius> The embedding, as nominolo suggested, is to CPS transform the classical logic into intuitionistic logic (using monads if you like)
12:33:01 <newsham> sorear: trying to practice this curry-howard stuff.  (I know I could do these in isabelle a lot easier)
12:33:45 <newsham> i kinda like how these proofs read.. they work well in a programming language style.  much more compact than the 2-dimensional logic diagrams
12:33:59 <newsham> where as isabelle proofs are kinda blah to read
12:34:03 <newsham> (but easier to construct)
12:34:27 <newsham> also with type decls I can kinda show what the intermediate steps result in (which is hidden in isabelle)
12:34:53 <nominolo> in Coq you can directly specify a lambda expression as a prove
12:35:16 <nominolo> nothing else is what the tactics do - construct a proof expression
12:35:19 <newsham> perhaps I should play with coq when i'm done with this
12:35:50 <nominolo> i've never used isabelle, so i can't say if it can do the same
12:36:09 <dons> Cale: you should weight in ,
12:36:10 <dons>   class Category cat where
12:36:10 <dons>     id  :: cat a a
12:36:10 <dons>     (.) :: cat b c -> cat a b -> cat a c
12:36:11 <dons> I'm not against this, but it would mean moving Category to the Prelude.
12:36:19 <dons> Cale, "To: libraries@haskell.org
12:36:20 <dons> Subject: Re: Proposal: Add Compositor class as superclass of Arrow"
12:36:24 <newsham> isabelle/hol lets you specify which rules to use, and it shows you the results of transforming your target goals and assumptions at each step
12:36:47 <ddarius> dons: I'm against it.
12:36:48 <newsham> but the end proof looks something like "and elimination, or injection, ..."
12:37:04 <Cale> hmm
12:37:06 <dons> ddarius: say so then please.
12:37:11 <newsham> i think isabelle/isar (or some such) is supposed to be more readable proofs.
12:37:23 <nominolo> newsham, that's the usual style in Coq, too.
12:37:23 <newsham> where isabelle shines is it has a lot of commands for auto-finding your proof for you
12:37:25 <dons> it seemed to come out of the blue, and i'd at least like some of the mathier guys to state their position
12:37:36 <ddarius> Oh, it's on the lists already
12:37:39 <nominolo> dons, ack
12:37:43 <ddarius> ?
12:37:54 <newsham> you can say "apply induction on xs and simplify" and it says "done"
12:37:59 <nominolo> it's on libraries@
12:38:04 <ddarius> Ah.
12:38:09 <newsham> which doesnt make for a very readable proof, but at least is easy to use
12:38:58 <ddarius> I'm not subscribed to libraries.  But a category is not a binary thing, it's not an operator at all.
12:39:18 <nominolo> that'd be "induction on xs; auto" in Coq ;)
12:39:43 <nominolo> i find the original name suggestion less scary
12:39:44 <newsham> nomi: ahh, sounds like similar features
12:40:27 <ddarius> Most of the theorem provers out there are based on Curry-Howard-esque correspondences.
12:43:45 <Cale> hmm, there are less baroque changes which I would propose first
12:49:13 <newsham> I dont understand how I can construct an excluded-middle axiom
12:49:31 <newsham> other than to just leave it undefined
12:49:42 <EvilTerran> in what, haskell's type system?
12:49:49 <newsham> yah
12:49:59 <EvilTerran> because in that case, i don't think you can, 'cos it's only intuitionistic logic
12:50:26 <EvilTerran> and the point of intuitionistic logic is the absence of a doesn't imply a and vice-versa
12:50:47 <LoganCapaldo> that doesn't seem very intuitive...
12:50:53 <LoganCapaldo> :P
12:51:42 <LoganCapaldo> some math guy musta made that joke before "Intuitionistic logic isn't."
12:51:57 <sorear> I have
12:52:30 <newsham> so is the best I can do then to say "excludedMiddle = undefined :: (p :\/ (Not p))" ?
12:53:55 <newsham> axiom = undefined :: forall a. a
12:57:55 <ddarius> newsham: Using undefined defeats the whole point of the exercise (though using a Turing-complete language pretty much does as well)
12:58:31 <newsham> is the haskell type system turing complete?  i thought it was total-functional or something like that
12:59:01 <ddarius> newsham: The Haskell type system corresponds to an inconsistent logic because falsity is provable.
12:59:31 <ddarius> To make use of the Curry-Howard correspondence in Haskell, you need to show that your programs terminate on all inputs.
12:59:38 <newsham> if I use undefined for just that one axiom introduction, shouldnt the rest be consistent?
13:00:44 <sorear> newsham: paradox = paradox
13:00:44 <newsham> obviously if you add axioms ("undefined") all over the place you can easily make inconsistencies
13:01:12 <newsham> is there a way to construct a paradox using excluded middle?
13:01:13 <ddarius> newsham: You're missing the point of the Curry-Howard correspondence.
13:01:30 <newsham> alternately, what are my options for doing classical logic?
13:01:47 <ddarius> As nominolo and I have said, you can embed it into Haskell using CPS.
13:02:28 <newsham> *sigh* you said that, and then later I said "I cant construct excl-middle" and then I got contradictory answer
13:02:47 <newsham> can anyone explain how I can do it with cps?
13:02:56 <newsham> (sorry for being dense)
13:03:50 <ddarius> You CPS transform the types and the terms and then e.g. double negation elimination is call/cc.
13:04:09 * roconnor never understood double negation and call/cc
13:04:17 <Saizan> ?src Cont
13:04:17 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
13:04:29 <newsham> so all theorems take an argument then?
13:04:59 <ddarius> Yes.  The continuation.  You can use the continuation monad instead of continuation passing style if you like (they're the same thing.)
13:05:54 <dataangel> I want a function that does "mapM print arg". Simple enough, but when I run it in the interpreter it's always printing out the return value from mapM at the end. How do I say, "ignore the inferred return type and always return ()"?
13:06:02 <ddarius> :t mapM_
13:06:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:06:06 <newsham> ?type callCC
13:06:08 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
13:06:40 <ddarius> though in general, you could just do '... >> return ()', but it's better not to produce a list you aren't going to use in the first place
13:07:10 <dataangel> ah, thx
13:07:18 <ddarius> Sorry, Pierce's law is call/cc, but that's equipotent.
13:08:10 <newsham> i roughly know the idea of callcc but not very familiar with it in haskell, and not familiar with pierces law
13:08:29 <newsham> time to do some homework onthis.  thanks guys
13:20:30 <ddarius> :t \f -> callCC (\k -> f k >>= k)
13:20:35 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => ((b -> m b) -> m b) -> m b
13:23:10 <ddarius> :t \f -> callCC (\k -> callCC (\k' -> f k >>= k'))
13:23:13 <lambdabot> forall (m :: * -> *) b b1. (MonadCont m) => ((b1 -> m b) -> m b1) -> m b1
13:23:46 <ddarius> :t \f -> callCC (\k -> callCC (\k' -> f k))
13:23:48 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
13:24:09 <ddarius> :t \f -> callCC (\k -> callCC (\k' -> f k >>= k))
13:24:11 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => ((b -> m b) -> m b) -> m b
13:25:45 <dataangel> > zipWith (++) [3, 4, 5, 6] [9, 2]
13:25:46 <lambdabot>   add an instance declaration for (Num [a])
13:25:47 <lambdabot>     In the expression: 2
13:25:51 <dataangel> @_@
13:25:51 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
13:26:13 <oerjan> dataangel: (+) not (++)
13:26:27 <dataangel> ah whoops
13:27:00 <dataangel> I was making sure I understood how zipWith worked because I have a bug with some code that uses it on lists of lists, forgot that that means when I test I need lists of lists too ;p
13:31:06 <nominolo> @djinn ((a->b)->b)->b
13:31:06 <lambdabot> -- f cannot be realized.
13:31:17 <nominolo> @djinn ((a->b)->a)->b
13:31:17 <lambdabot> -- f cannot be realized.
13:31:24 <nominolo> @djinn ((a->b)->a)->a
13:31:24 <lambdabot> -- f cannot be realized.
13:32:00 <opqdonut> @djinn ((a->a)->a)->a
13:32:01 <lambdabot> f a = a (\ b -> b)
13:32:04 <opqdonut> :))
13:32:37 <opqdonut> @djinn b->((a->b)->a)->a
13:32:38 <lambdabot> f a b = b (\ _ -> a)
13:33:38 <nominolo> @djinn ((((a->b)->a)->a)->b)->b
13:33:39 <lambdabot> f a = a (\ b -> b (\ c -> a (\ _ -> c)))
13:34:23 <oerjan> @djinn ((((a->b)->a)->a)->c)->c
13:34:24 <lambdabot> -- f cannot be realized.
13:35:30 <nominolo> @pl \a -> a (\ b -> b (\ c -> a (\ _ -> c)))
13:35:30 <lambdabot> ap id (flip id . (. const))
13:36:05 <nominolo> :t (->) ap
13:36:10 <lambdabot> parse error on input `->'
13:36:29 <nominolo> :t ((->)a) ap
13:36:31 <lambdabot> parse error on input `->'
13:36:40 <nominolo> @src ((->)a) ap
13:36:41 <lambdabot> Source not found. Are you on drugs?
13:37:01 <oerjan> @src ap
13:37:02 <lambdabot> ap = liftM2 id
13:37:04 <nominolo> :t ap id 34
13:37:06 <lambdabot> forall a b. (Num ((a -> b) -> a)) => (a -> b) -> b
13:39:45 <nominolo> :t ap id undefined
13:39:47 <lambdabot> forall a b. (a -> b) -> b
13:40:35 <newsham> I used to have "data Not p = Not (forall q . p -> q)"  Now I want to make p and q belong to a type class.  data Not p = (Prop p, Prop q) => Not (forall q. p -> q)" which doesnt quite work right
13:40:41 <newsham> whats the right syntax for saying what I want to say?
13:41:11 <nominolo> data D a = Foo a => D a
13:41:17 <nominolo> oh
13:41:24 <nominolo> no
13:41:24 <stoic_> what is the equivalent section for this lambda? (\n -> n*(3*n-2))
13:41:37 <nominolo> Foo (forall a. Foo a => ...)
13:41:40 <newsham> ?pl \n -> n*(3*n-2)
13:41:40 <lambdabot> ap (*) (subtract 2 . (3 *))
13:42:24 <stoic_> hmm thanks
13:42:49 <newsham> like so?  data Not p = Prop p => Not (forall q . Prop q => p -> q)   also no work
13:42:49 <nominolo> pointfree style can be rather pointless
13:43:09 <nominolo> tried -fglasgow-exts?
13:43:18 <newsham> oops, in a file without that deifned :)
13:43:24 <nominolo> oh, right, you need theme already
13:43:27 <nominolo> *them
13:44:34 <stoic_> nominolo: pointfree would only be used for simple operations?
13:44:42 <newsham> this is a good type-workout for me :)
13:46:29 <nominolo> stoic_, it's a matter of taste in many cases
13:46:47 <nominolo> it's nice for stream-like operations
13:52:32 <stoic_> so is there a better way to do this: let ops = [(\n -> n*(n+1) `div` 2), (^2), (\n -> n*(3*n-1) `div` 2), (\n -> n*(2*n-1)), (\n -> n*(5*n-3) `div` 2), (\n -> n*(3*n-2))] in zipWith map ops bounds where bounds = [[Int]]
13:55:51 <nominolo> looks ok to me
13:56:05 <stoic_> it works but maybe I'm missing something really obvious which would allow me to get rid of all the lambdas
13:56:17 <dibblego> ?where djinn
13:56:18 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
13:58:16 <nominolo> stoic_, other than naming them, i don't think so.  you could have one function f a b c n = n*(a*n+b) `div` c  and then use zipWith3
13:58:25 <nominolo> but i doubt that would increase readability
13:59:42 <stoic_> alright, I'll leave it be, thanks
14:17:09 <dataangel> Is there any type of newbie mistake that makes it so your algorithm always appears to mysteriously swap the last two elements of your list?
14:17:35 <chessguy> @bot
14:17:36 <lambdabot> :)
14:17:48 <mauke> confusing variables?
14:18:29 * dataangel keeps searching
14:18:51 <chessguy> dataangel, why not paste your code?
14:18:52 <chessguy> @paste
14:18:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:19:47 <dataangel> Is : usually faster than ++ ?
14:20:35 <chessguy> : is O(1)
14:20:41 <mauke> is 'if' faster than 'while'?
14:20:44 <chessguy> @src (++)
14:20:45 <lambdabot> (++) []     ys = ys
14:20:45 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
14:20:56 <dataangel> I would guess so since : works with the head, but ++ with lazy evaluation shouldn't be O(n) like in imperative langs
14:21:01 <chessguy> (++) is O(n) in the length of the first list
14:21:39 <chessguy> well, whether it's immediate or when the data is needed, you still run the same operations
14:22:06 <dataangel> But is it really O(n)? Since whenever the appending really takes place is when you've already iterated that far out into the list, I'd think not
14:22:30 <sjanssen> it is really O(n)
14:23:06 <dataangel> sjannsen: But don't you never pay the cost, isn't it amortized by having to iterate out that far for something else already?
14:23:46 <sjanssen> or, more specifically, it add an O(1) cost to the first n cells of the result
14:24:23 <dataangel> I guess what I mean is is it PracticalO(n)? ;p
14:24:28 <sjanssen> yes
14:24:47 <dataangel> sjannsen: what about my reasoning is wrong? :P
14:25:01 <Beelsebob> nothing
14:25:30 <sjanssen> dataangel: ponder why foldl (++) is quadratic, but foldr (++) is linear
14:25:46 <Beelsebob> but at each recursion step in the other function, you're gonna have to do a constant time reduction to get the next item
14:26:20 <sjanssen> Beelsebob: the additional costs accumulate
14:26:24 <Beelsebob> exactly
14:26:44 <Beelsebob> my point is that that may be insignificant in comparison to the other part of the algorithm, but it's still O(n)
14:28:36 <dataangel> My understanding would be haskell would lazily append list A and list B to form list C, so only when you ask for the value of the length A element does the append actually happen, at which point we have already paid the cost of traversing out to the length A element, which is the O(n) part of ++.
14:28:36 <sjanssen> dataangel: this fuzzy thinking is dangerous
14:28:36 <Beelsebob> yes, the append actually happens when you ask for the length
14:28:36 <Beelsebob> because length demands the list
14:28:36 <dataangel> sjanssen: lol. Which part is fuzzy? :)
14:28:52 <dankna> So, I'm looking for an idiom.
14:28:59 <dataangel> Beelsebob: I wasn't asking for the length, just saying, whenever you hit what the length A element happens to be
14:28:59 <sjanssen> dataangel: that ++ is free because you have to pay O(n) to force it to happen
14:29:22 <dankna> I'm aware that what I want to do is kind of a C-ism, and I'm willing to reword the code, it just feels like there has to be a way with less internal redundancy than what I've come up with.
14:29:32 <Beelsebob> oh, I see, yes, if you index into it at element a, it will evaulate the spine of the list
14:29:38 <dankna> er, perhaps I should paste, one sec
14:30:15 <Beelsebob> do the evaulation step by step
14:30:21 <dataangel> sjanssen: Exactly. My point though is that the ++ will only happen if your algorithm is O(n) already.
14:30:40 <Beelsebob> the evaulation will only happen if you demand the list, yes
14:30:56 <Beelsebob> but what's the point of doing the append if you never demand it
14:30:59 <dataangel> I may still be thinking fuzzily though :P
14:31:01 <sjanssen> dataangel: it adds an *additional* linear cost
14:31:19 <sjanssen> dataangel: seriously, think about foldl (++) and foldr (++)
14:31:36 <dataangel> sjanssen: yeah I don't see how, I'll have to add that to my todo ;p
14:31:43 <dataangel> I'm not that familiar with foldl/foldr yet
14:32:02 <sjanssen> okay, I'll demonstrate more literally
14:32:06 <Beelsebob> sjanssen: I believe he's trying to say that "take 1 (replicate n 'a') (replicate n 'b')" is still O(1)
14:32:11 <alexei> @src foldl
14:32:11 <lambdabot> foldl f z xs = lgo z xs
14:32:11 <lambdabot>     where lgo z []     =  z
14:32:11 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
14:32:25 <Beelsebob> but that's merely the way demand works
14:32:28 <hpaste>  dankna pasted "Terser or more idiomatic way to do this?" at http://hpaste.org/3270
14:32:40 <sjanssen> dataangel: which is faster?  ((xs ++ ys) ++ zs) or (xs ++ (ys ++ zs))
14:32:42 <dankna> There.  If anybody has a moment to look at that. :)
14:33:01 <dataangel> sjanssen: niether?
14:33:26 <sjanssen> dataangel: remember that ++ is O(n) where n is the length of the first argument
14:33:38 <Beelsebob> dataangel: think about the evaluation
14:33:40 <hpaste>  vvv pasted "what is `when' for?" at http://hpaste.org/3271
14:33:44 <dataangel> sjannsen: oh... subtle :)
14:33:47 <Beelsebob> remember that in order to do the append it has to traverse the first list
14:33:49 <dataangel> sjannsen: The latter then
14:34:03 <sjanssen> dankna: that is actually a common idiom.  You can remove the repeated ()'s to improve it a bit
14:34:30 <mauke> vvv: that looks like a silly way of forcing output
14:34:32 <dankna> I can?  Do I need to be careful with indentation or something to make that work?  I remember in my past attempts I got syntax errors that didn't make sense to me, although that was a while ago.
14:34:41 <hpaste>  sjanssen annotated "Terser or more idiomatic way to do this?" with "a little better" at http://hpaste.org/3270#a1
14:34:51 <dankna> ah!  gotcha
14:34:58 <sjanssen> dankna: I notice you're mixing tabs and spaces.  Don't do that
14:35:11 <dankna> hah.  you recommend all spaces?  hmm, all right...
14:35:18 <mauke> or all tabs
14:35:21 <Beelsebob> all spaces is good
14:35:26 <vvv> mauke: perhaps, because I can see no output without this `when'
14:35:32 <Beelsebob> all tabs gets annoying because you can't do fine layout
14:35:45 <lekro> I've probably missed something but why doesn't http://www.haskell.org/hoogle/?q=Seq show a link to Data.Seq?
14:35:46 <lambdabot> Title: Seq - Hoogle
14:35:48 <dankna> my indentation habits have gotten a lot sloppier since I switched away from Emacs and discovered, to my displeasure, that basically nothing other than Emacs does language-aware autoindent
14:35:52 <Beelsebob> personally I have my editor enter the appropriate number of spaces when I press tab
14:35:57 <dankna> that isn't just regexp-based
14:35:58 <mauke> fine layout is fragile
14:36:10 <mauke> Beelsebob: why not when you press enter?
14:36:29 <Beelsebob> mauke: because the editor does not know what I'm about to write
14:36:41 <Beelsebob> my editor does actually put spaces up to the current indent level if I press enter
14:36:46 <mauke> maybe not in haskell :-)
14:36:51 <Beelsebob> but it doesn't try to guess any more than that
14:37:00 <dataangel> Is ++ right associative?
14:37:10 <Beelsebob> mauke: even in say C, it doesn't know if I'm about to press }
14:37:22 <mauke> Beelsebob: yeah, but it can reindent when it sees a }
14:37:37 <sjanssen> dataangel: yes
14:37:38 <Beelsebob> mauke: true, but I find that annoying
14:37:41 <mauke> I never manually indent code when writing C
14:37:53 <Beelsebob> I don't like my editor second guessing me
14:37:59 <dataangel> sjanssen: that makes sense now given your example ;)
14:38:25 <lekro> hm, Data.Sequence doesn't appear to be indexed by hoogle at all
14:38:30 <dankna> the slightly irritating thing is that indentation is really the only feature that I miss about Emacs, and I'm going on three or four months without it, heh
14:38:38 <dankna> but I suspect it's gonna be enough to make me switch back
14:38:40 <dankna> oh well!
14:38:43 <Beelsebob> mauke: tbf, that problem doesn't actually come up too often, because if I press {, my editor automatically adds a } on the line after the cursor anyway
14:38:48 <sjanssen> lekro: I think the index it uses is out of date
14:38:58 <vvv> mauke: and what would be "not-silly" way to get output from, say, "echo 123"? [http://hpaste.org/3271]
14:39:13 <lekro> sjanssen: any plans for when it will get updated?
14:39:26 <sjanssen> lekro: I have no idea
14:39:41 <mauke> vvv: length output `seq` return () or something like that
14:39:48 <mauke> at least it looks more obvious to me
14:40:07 <birkenfeld> is there a nice and small piece of code that uses ghc's STM features so that you can get a bit of insight how to use them?
14:40:52 <vvv> mauke: thnx
14:41:42 <sjanssen> mauke: even better is to use Control.Exception.evaluate
14:43:06 <dankna> actually, I might as well ask, what editors do people in here use for Haskell?  I doubt I'm gonna switch to anything you recommend, cause obviously I have strong feelings on the subject anyway, but it might still be useful to hear.
14:43:26 * birkenfeld is using emacs
14:43:30 <astrolabe> I think most people use emacs
14:43:49 <Japsu> I've heard lots of praise about the Haskell mode for EMACS... I'm still clinging to Vim though
14:44:18 <mauke> sjanssen: doesn't work
14:44:18 <sjanssen> dankna: vim is a popular choice
14:44:27 <sjanssen> mauke: why?
14:44:30 <mauke> sjanssen: it's not recursive so it doesn't force the list
14:44:37 <mauke> oh wait
14:44:40 <dibblego> ?djinn [a] -> [a]
14:44:41 <lambdabot> f a = a
14:44:47 <sjanssen> mauke: yes, you need "evaluate (length list)"
14:44:48 <mauke> evaluate (length output)
14:44:58 <mauke> yeah. duh.
14:45:42 <vvv> evaluate (null output)
14:45:54 <mauke> no
14:46:01 <TomMD> Why is *.haskell.org so disorganized?  Should we be forcing any non darcs.haskell.org repos to move to darcs.haskell.org?
14:46:11 <vvv> since I don't need to calculate the length, actually...
14:46:31 <mauke> vvv: yes, you do
14:47:09 <dankna> Oh, does vim do nice stuff with regard to Haskell in particular?
14:49:13 <dons> TomMD: hmm?
14:49:26 <dons> TomMD: things are moving the other way, to code.haskell.org
14:49:31 <dons> which is tightly regulated
14:50:50 <vvv> mauke: no, I don't. :) See http://hpaste.org/3271#a1
14:51:37 <mauke> vvv: that code is broken
14:51:44 <mauke> hClose pout is wrong in any case
14:52:10 <mauke> and waitForProcess ph can block indefinitely if the output is too big. I think.
14:52:38 <omnId> @src null
14:52:38 <lambdabot> null []     = True
14:52:39 <lambdabot> null (_:_)  = False
14:52:46 <omnId> null will only force the first cons cell
14:52:50 <vvv> hmm... it works... what's wrong with `hClose'?
14:53:10 <mauke> vvv: hGetContents closes the filehandle
14:54:02 <dankna> heh, well, anyhow, thanks for answering the editor question and the idiom thing
14:54:16 <vvv> mauke: ah, I see. Thank you!
14:57:19 <vvv> mauke: by the way, what if I *don't* waitForProcess?
14:57:54 <mauke> then it will hang around and (after you've consumed output) turn into a zombie
14:58:33 <vvv> oh
14:59:54 <vvv> mauke: I'll keep this "zombie" trick for FPS game. Resident Evil'18 or something.
15:01:00 <mauke> makeZombie :: IO (); makeZombie = fork (exitImmediately 0) >> return ()
15:02:48 <idnar> haha
15:08:26 <LoganCapaldo> ina  cabal file, what do I add after Extensions: to do the equivalent of -fallow-undecidable-instances?
15:08:51 <LoganCapaldo> assuming all my assumptions are correct that that's the right way to do it :)
15:11:00 <LoganCapaldo> http://darcs.haskell.org/ghc-6.6/packages/Cabal/Distribution/Compiler.hs -- UndecidableInstances looks like
15:11:02 <lambdabot> http://tinyurl.com/3bktoq
15:11:07 <LoganCapaldo> thanks guys :)
15:11:16 <ddarius> Glad to help
15:18:18 <LoganCapaldo> oh incidentaly
15:18:31 <LoganCapaldo> eh nvm its probably fixed in head
15:22:00 <dons> real world thought for the day,
15:22:01 <dons>   fmap (fmap (fmap Layout)) $ doLayout l r s
15:22:49 <mrd> fun
15:22:54 <sorear> red flag!
15:22:54 <mrd> (ctor)
15:23:02 <dons> yeah
15:23:07 <dons> consider:
15:23:07 <dons>     doLayout (Layout l) r s  = fmap (fmap Layout) `fmap` doLayout l r s
15:23:07 <dons>     handleMessage (Layout l) = fmap (fmap Layout) . handleMessage l
15:23:16 <dons> that last (.) can be replaced, sneakily, with `fmap`
15:23:25 <dons> too much type inference for one person
15:23:51 <omnId> the first is ((->) r), what are the inner two?
15:23:57 <LoganCapaldo> that's a lot of nested functors...
15:24:15 <dons> there's a Maybe in there
15:24:22 <dons> and something implementing Functor, iirc
15:24:34 <dons> oh, X
15:24:40 <dons> (newtype'd IO/StateT)
15:25:08 <dons> replacing some with liftM or (.) is helpful
15:28:00 <omnId> wait, doLayout (Layout l) r s = ... doLayout l r s ... -- isn't l's type infinite?
15:28:22 <dons> its dispatching to a different instance
15:28:27 <LoganCapaldo> doLayout could be a function from a class?
15:28:31 <ddarius> The magic of overloading.
15:28:31 <dons> (that context was missing, sorry )
15:28:37 <omnId> ah, yes
15:28:51 <LoganCapaldo> what are class functions called? Do they have a name?
15:28:57 <ddarius> methods
15:29:40 <LoganCapaldo> I almost said method...
15:29:42 <dons> i prefer `rock lobsters', but its not catching on
15:29:49 <LoganCapaldo> heh
15:30:20 <LoganCapaldo> "In this function, doLayout is a rock lobster from the Layoutable class...)
15:30:29 <dons> ?b52s!
15:30:29 <lambdabot> His ear lobe fell in the deep. Someone reached in and grabbed it. It was a rock lobster!
15:30:40 <dons> sweet. i love it when that works
15:30:53 <omnId> I was reading something lately that seemed to suggest that 'method' specifically refers to instantiations of class functions.
15:31:15 <omnId> I think the Gentle Introduction
15:31:48 <ddarius> http://www.haskell.org/onlinereport/decls.html section 4.3.1
15:31:49 <lambdabot> Title: The Haskell 98 Report: Declarations
15:33:10 <omnId> "An instance declaration declares ... the definitions of the overloaded operations---called class methods---instantiated on the named type."
15:33:46 <Carneus> has anyone used happy parser generator? any idea how i get rid of "parE" error message and get something more meaningfull out of it
15:34:07 <dons> check the mailing list. i believe you are to update to the darcs snapshot of happy
15:34:27 <omnId> I think the function signatures in the class itself are just called 'operations' (with an optional default method).
15:35:11 <LoganCapaldo> omnId: the report isn't reading like that, IMO
15:35:21 <omnId> (==) is an operation in Eq, boolEq is Bool's (==) method, is how I read.
15:35:30 <ddarius> omnId: The very first sentence of the section I referenced: "A class declaration introduces a new class and the operations (class methods) on it."
15:36:37 <Carneus> is this bug fixed in the latest version of happy?
15:37:02 <dons> yes
15:37:40 <Carneus> ok, then i'll try that
15:38:36 <omnId> right, I concede the point.
15:38:44 <Carneus> i have version 1.16 which is the latest one
15:39:04 <Carneus> should i try the snapshots?
15:44:54 <LoganCapaldo> is there a way to see what flags are being passed to ld with a cabal based build?
15:45:01 <dons> c -v9
15:48:02 <LoganCapaldo> woah
15:48:10 <LoganCapaldo> now that is verbose :)
15:50:16 <LoganCapaldo> next exciting question...
15:50:24 <LoganCapaldo> is there a way to add to that list?
15:50:40 <LoganCapaldo> LDFLAGS=?
15:51:08 <dons> ghc-options: -optl-*
15:51:12 <dons> should work
15:53:33 <LoganCapaldo> looks like it did
15:53:36 <LoganCapaldo> thanks
15:59:26 <LoganCapaldo> lambdabot: I will build you. I'm almost there
16:01:30 <LoganCapaldo> hmm  if $ was just sugar, it would actually have different semantics wouldn
16:01:32 <LoganCapaldo> 'tit?
16:01:50 <LoganCapaldo> Since it introduces another layer to be lazy about
16:04:38 <twanvl> No it doesn't
16:05:00 <LoganCapaldo> no?
16:05:13 <LoganCapaldo> f $ x isn't more thunks than f x ?
16:05:29 <twanvl> The language says nothing about thunks and lazyness
16:05:35 <LoganCapaldo> ok...
16:05:46 <dons> ?src ($)
16:05:46 <lambdabot> f $ x = f x
16:06:00 <LoganCapaldo> fine I can be wrong :)
16:06:59 <LoganCapaldo> hooray
16:07:05 <LoganCapaldo> I build lambdabot
16:07:12 <LoganCapaldo> but I don;'t think she works
16:07:47 <LoganCapaldo> ah
16:07:54 <LoganCapaldo> it's only eval that doesn't work
16:09:11 <LoganCapaldo> hoogle works and djinn works and @quote works
16:09:44 <cognominal> @src returnA
16:09:45 <lambdabot> returnA = arr id
16:10:08 <LoganCapaldo> @type seems to be having parsing issues too
16:10:10 <lambdabot> Not in scope: `seems'
16:10:10 <lambdabot>  
16:10:10 <lambdabot> <interactive>:1:6: Not in scope: `to'
16:10:50 <newsham> < oerjan> newsham: demorgan isn't true in constructive logic either
16:10:53 <newsham> hrmm.. sure about that?
16:12:45 <newsham> ?seen oerjan
16:12:45 <lambdabot> I saw oerjan leaving #haskell 2h 26m 45s ago, and .
16:13:28 <LoganCapaldo> dons: something obvious I missed? "Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString"
16:13:53 <dons> update your version of the regex libraries
16:14:00 <dons> there was a bug in regex-compat iirc, that produces this error
16:16:26 <ddarius> @djinn (Not a,Not b) -> Not (Either a b)
16:16:26 <lambdabot> f (a, b) c =
16:16:27 <lambdabot>     case c of
16:16:27 <lambdabot>     Left d -> a d
16:16:27 <lambdabot>     Right e -> b e
16:16:39 <ddarius> @djinn Not (Either a b) -> (Not a,Not b)
16:16:40 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
16:17:05 <LoganCapaldo> crud muffins
16:17:31 <LoganCapaldo> regex-compat's Setup.lhs from darcs has a type error..
16:17:56 <ddarius> @djinn Not (a,b) -> Either (Not a) (Not b)
16:17:56 <lambdabot> -- f cannot be realized.
16:18:11 <ddarius> @djinn Either (Not a) (Not b) -> Not (a,b)
16:18:12 <lambdabot> f a =
16:18:12 <lambdabot>     case a of
16:18:12 <lambdabot>     Left b -> \ (c, _) -> b c
16:18:12 <lambdabot>     Right d -> \ (_, e) -> d e
16:18:28 <ddarius> newsham: There you go.  That last line is an implication not an equivalence.
16:19:57 <LoganCapaldo> actually cabal has probably just changed since I installed it last
16:25:13 <ddarius> ooo psychedelic colors
16:30:44 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3273
16:35:04 <newsham> anyone want to help me with either excluded-middle or false-elimination?  I rewrote everything in terms of CPS, but still not quite getting the last step of it.
16:42:58 <ddarius> @djinn ((a -> ((b -> r) -> r)) -> ((b -> r) -> r)) -> (a -> r) -> r
16:43:02 <lambdabot> -- f cannot be realized.
16:44:09 <ddarius> @djinn Not (Not (Not (Not a))) -> Not (Not a)
16:44:10 <lambdabot> f a b = void (a (\ c -> void (c b)))
16:48:14 <ddarius> :t \nna k -> nna (\a _ -> k a)
16:48:16 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2) -> t3) -> (t -> t2) -> t3
16:50:22 <cognominal> @src (***)
16:50:22 <lambdabot> f *** g = first f >>> second g
16:50:29 <cognominal> @src (&&&)
16:50:29 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
16:50:38 <cognominal> @src (|||)
16:50:38 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:51:08 <LoganCapaldo> do not
16:51:25 <byorgey> @source Control.Arrow
16:51:25 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
16:51:34 <byorgey> (|||) should be in there ^^
16:51:46 <byorgey> it's part of the ArrowChoice class, if I remember correctly.
16:52:03 <byorgey> @src ArrowChoice
16:52:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:52:06 <omnId> @src (->) (|||)
16:52:06 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:52:17 <omnId> @type (|||)
16:52:19 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
16:52:47 <omnId> @type either
16:52:49 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:52:51 <LoganCapaldo> /_(|||)_\ <-- arrow plane
16:53:00 * omnId groans
16:53:31 * byorgey chuckles
16:54:07 <omnId> though we 'merkins say "airplane"
16:54:09 <lekro> is there a small function of type "(Ord b) => (a -> b) -> a -> a -> Ordering" in some standard module? of course, it's only one line but I don't want to duplicate an existing function.
16:54:35 <LoganCapaldo> I'm confused
16:54:44 <stoic_> ?ty unfoldTree
16:54:46 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
16:54:56 <LoganCapaldo> Do you mean (a -> b) -> b -> b -> ordering ?
16:55:01 <mux> :t ordering
16:55:03 <lambdabot> Not in scope: `ordering'
16:55:03 <mux> err
16:55:05 <mux> :t comparing
16:55:07 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
16:55:07 <omnId> LoganCapaldo: nope
16:55:22 <omnId> LoganCapaldo: the result b's get compare'd
16:55:24 <ddarius> :t \f k -> f (\a _ -> k a)
16:55:26 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2) -> t3) -> (t -> t2) -> t3
16:55:30 <omnId> from both a's
16:55:32 <LoganCapaldo> oh de
16:56:09 <ddarius> :t \f k -> f (\a _ -> k a) k
16:56:10 <mux> > sortBy (comparing fst) [(3,1),(1,4),(2,2)]
16:56:12 <lambdabot>  [(1,4),(2,2),(3,1)]
16:56:12 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2) -> (t -> t2) -> t3) -> (t -> t2) -> t3
16:56:23 <omnId> @index comparing
16:56:23 <ddarius> :t \f k -> f (\a _ -> k a) id
16:56:23 <lambdabot> bzzt
16:56:25 <lambdabot> forall t t1 t2 a t3. ((t -> t1 -> t2) -> (a -> a) -> t3) -> (t -> t2) -> t3
16:56:30 <mux> Data.Ord
16:56:47 <mux> this is the same as compare `on`
16:56:53 <lekro> mux: I knew there was such a function, thanks. hoogle doesn't seem to know comparing, though. In which module is it?
16:56:59 <lekro> ok
16:57:03 <mux> > sortBy (comparing `on` fst) [(3,1),(1,4),(2,2)]
16:57:04 <lambdabot>   Not in scope: `on'
16:57:07 <mux> err
16:57:26 <mux> @let on f g x y = f (g x) (g y)
16:57:30 <lambdabot> Defined.
16:57:32 <mux> > sortBy (compare `on` fst) [(3,1),(1,4),(2,2)]
16:57:34 <lambdabot>  [(1,4),(2,2),(3,1)]
16:57:41 * mux hearts LB
16:57:58 <mux> on is in GHC 6.8, IIRC
16:58:04 <omnId> comparing f = compare `on` f;  mux defined on above
16:58:12 <LoganCapaldo> @djinn (a -> a -> b) -> (c -> a) -> c -> c -> b
16:58:13 <lambdabot> f a b c _ = a (b c) (b c)
16:58:22 <LoganCapaldo> hmm
16:58:31 <LoganCapaldo> djinn,
16:58:31 <omnId>  @. pl djinn?
16:58:38 <LoganCapaldo> that's not quite what I wnated
16:58:40 <mux> djinn ain't smart enough for this one
16:58:47 <lekro> hm, now that I think of it I looked up comparing before, many months ago. I may have used hoogle. Did hoogle get less reliable in the recent time?
16:59:11 <lekro> e.g., it doesn't know comparing
16:59:19 <mux> bad hoogle
16:59:59 <Olathe> hoogle--
17:00:11 <mux> @src Ord mplus
17:00:11 <lambdabot> Source not found. I feel much better now.
17:00:20 <mux> @instances Monoid
17:00:21 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
17:00:28 <mux> @src Ordering mplus
17:00:29 <lambdabot> Source not found. It can only be attributed to human error.
17:00:35 <LoganCapaldo> @src Ordering mappend
17:00:35 <lambdabot> Source not found. Wrong!  You cheating scum!
17:00:37 <mux> well that often comes in handy
17:00:44 <LoganCapaldo> @type mappend
17:00:46 <lambdabot> forall a. (Monoid a) => a -> a -> a
17:00:51 <LoganCapaldo> @type mplus
17:00:53 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
17:00:56 <Olathe> @type a letter
17:00:58 <lambdabot> Not in scope: `a'
17:00:58 <lambdabot>  
17:00:58 <lambdabot> <interactive>:1:2: Not in scope: `letter'
17:00:59 <ddarius> @src Cont callCC
17:01:00 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
17:01:04 <mux> oops I always confuse those
17:01:12 <LoganCapaldo> a mistake I always make
17:01:16 <yitz> Where does one import comparing from
17:01:16 <mux> > sortBy (compare `on` fst) [(3,2),(3,1),(1,4),(2,2)]
17:01:18 <lambdabot>  [(1,4),(2,2),(3,2),(3,1)]
17:01:23 <LoganCapaldo> hence the only reason I noticed you were making it :)
17:01:31 <Olathe> @src on
17:01:31 <lambdabot> (*) `on` f = \x y -> f x * f y
17:01:32 <lekro> yitz: Data.Ord
17:01:39 <LoganCapaldo> @flame on
17:01:39 <lambdabot> Unknown command, try @list
17:01:41 <mux> > sortBy (compare `on` fst `mappend` compare `on` snd) [(3,2),(3,1),(1,4),(2,2)]
17:01:41 <lambdabot>   add an instance declaration for (Num (a, b))
17:01:41 <lambdabot>     In the expression: 2
17:01:41 <lambdabot>     I...
17:01:47 <Olathe> What the heck ?
17:02:03 <mux> > sortBy ((compare `on` fst) `mappend` (compare `on` snd)) [(3,2),(3,1),(1,4),(2,2)]
17:02:03 <Olathe> (*) `on` f ?
17:02:04 <lambdabot>  [(1,4),(2,2),(3,1),(3,2)]
17:02:09 <mux> yay
17:02:41 <lekro> mux: cool
17:02:49 <LoganCapaldo> did you just sort by the fst element followed by the second element?
17:02:55 <mux> yes
17:02:58 <omnId> Olathe: (*) is a new name that gets bound to the argument
17:03:00 <LoganCapaldo> SICK!
17:03:02 <mux> that's why the Monoid instance for Ordering is so useful
17:03:03 <lekro> but where is "on" from?
17:03:11 <LoganCapaldo> mux++
17:03:17 <mux> I just defined it with @let
17:03:24 <dons> :t comparing
17:03:25 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
17:03:26 <Olathe> > let g x = x + 2; f x = x * 2 in on f g 11 37
17:03:27 <lambdabot>      Occurs check: cannot construct the infinite type: t1 = t1 -> t2
17:03:27 <lambdabot>     Prob...
17:03:46 <yitz> There was a lot of talk about the more general "as": f `as` g x y = (g x) `f`` (g y).  Whatever happened to that?
17:03:55 <omnId> f requires two args
17:04:01 <dons> > sortBy ((comparing fst) `mappend` (comparing snd)) [(3,2),(3,1),(1,4),(2,2)]
17:04:02 <lambdabot>  [(1,4),(2,2),(3,1),(3,2)]
17:04:07 <Olathe> > let g x = x + 2; f x y = x * y in on f g 11 37
17:04:08 <lambdabot>  507
17:04:15 <Olathe> > 13*39
17:04:16 <dons> yitz: that's `on`
17:04:17 <lambdabot>  507
17:04:17 <dons> ?src on
17:04:18 <lambdabot> (*) `on` f = \x y -> f x * f y
17:04:31 <omnId> > ((*) `on` (+2)) 11 37
17:04:32 <lambdabot>  507
17:04:42 <omnId> > 13 * 39
17:04:43 <lambdabot>  507
17:04:45 <dons> every functional language should have it
17:04:51 <yitz> Changed to "on"? OK. Has it made some standard module?
17:05:18 <Olathe> @pl \x y -> f (g x) (g y)
17:05:18 <lambdabot> (. g) . f . g
17:05:32 <Olathe> pl--
17:05:47 <omnId> pl++ you silly person
17:05:47 <ddarius> @djinn ((a -> (b -> r) -> r) -> (b -> r) -> r) -> (a -> r) -> r
17:05:48 <lambdabot> -- f cannot be realized.
17:06:04 <LoganCapaldo> take `on` me
17:06:08 <Olathe> Heheh
17:06:09 <omnId> (g gets the first arg, f gets hooked to g's result, g gets the second arg)
17:06:29 <Olathe> @pl \f g -> (. g) . f . g
17:06:29 <lambdabot> ap ((.) . flip (.)) . (.)
17:06:48 <omnId> that one would take a little more thought :)
17:08:31 <yitz> Ah, mux just defined it with @let here. Oh well. (I like "as" better)
17:08:50 <omnId> "as"?
17:09:00 <yitz> instead of "on"
17:09:02 <chessguy> yitz, last i heard, it's in GHC head
17:09:23 <omnId> (binop `on` unop) performs binop on the results of unop.
17:09:57 <yitz> IOW, binop with arguments represented "as" unops.
17:10:20 <LoganCapaldo> (+) `on` age
17:10:25 <omnId> I guess I see what what you're saying.
17:10:28 <Olathe> > (*) `ap ((.) . flip (.)) . (.)` (+2) 14 5
17:10:29 <lambdabot>  Parse error
17:10:32 <Olathe> Bah.
17:10:37 <LoganCapaldo> (+) `as` age
17:10:42 <Olathe> > (*) `(ap ((.) . flip (.)) . (.))` (+2) 14 5
17:10:43 <lambdabot>  Parse error
17:10:47 <Olathe> Lies.
17:10:50 <LoganCapaldo> I duno I'm down with on
17:10:56 <yitz> Anyway, glad to here it is in head. Also Data.Ord?
17:11:16 <ddarius> Olathe: It's not lying.
17:11:24 <LoganCapaldo> what about of?
17:11:33 <LoganCapaldo> (+) `of` age
17:11:58 <ski> @karma pl
17:11:58 <lambdabot> pl has a karma of 1
17:12:01 <lekro> > (ap ((.) . flip (.)) . (.)) (*) (+2) 14 5
17:12:06 <lambdabot>  112
17:12:08 <yitz> @karma lambdabot
17:12:09 <lambdabot> lambdabot has a karma of 45
17:12:16 <LoganCapaldo> comparision `of` first
17:12:26 <Olathe> @src as
17:12:27 <lambdabot> Source not found. I feel much better now.
17:12:31 <LoganCapaldo> (I know I can't changing the name of comparing)
17:12:41 <yitz> How about "von" from German?
17:12:56 <lekro> @unpl ap ((.) . flip (.)) . (.)
17:12:57 <lambdabot> (\ o -> (\ x b c i -> b c (x i)) >>= \ q -> (\ k l -> o (k l)) >>= \ p -> return (q p))
17:13:55 <yitz> lekro: wow
17:14:41 <Olathe> Eww
17:14:45 <yitz> @. pl unpl ap ((.) . flip (.)) . (.)
17:14:45 <lambdabot> (flip (flip . ((.) .)) >>=) . (. (return .)) . (>>=) . (.)
17:15:19 <Olathe> What we need to do is find the maximal (unpl length)/(original length) expression.
17:15:50 <yitz> Better set a limit on original length...
17:17:24 <yitz> How about log $ (unpl length) / (original length)
17:25:40 <sorear> @users
17:25:40 <lambdabot> Maximum users seen in #haskell: 420, currently: 359 (85.5%), active: 16 (4.5%)
17:26:13 <sorear> Olathe: the algorithm @pl uses is exponential space, it's just that sometimes the optimizations make up...
17:26:33 <sorear> Olathe: @pl uses the standard abstraction-elimination algorithm
18:25:15 <mgsloan> One interesting way to do step-based state for a function to return the 'next version' of itself to call
18:25:29 <mgsloan> *is
18:27:21 <LoganCapaldo> In most languages you move through a room, in Haskell you move the room around you?
18:27:35 * LoganCapaldo feels zen
18:27:39 <LoganCapaldo> oom
18:33:50 <mgsloan> heh
18:36:01 <TomMD> why was GHC.Handle.openFd depricated and what is the replacement?
18:36:38 <LoganCapaldo> @hoogle Fd -> IO Handle
18:36:38 <lambdabot> No matches, try a more general search
18:37:49 <allbery_b> check System.POSIX.IO
18:38:08 <allbery_b> er .Posix
18:38:27 <LoganCapaldo> System.Posix.fdToHandle
18:38:42 <allbery_b> unles sotherwise specified, the GHC hierarchy is internal stuff and should be avoided
18:38:57 <allbery_b> (and it is certainly nonportable...)
18:39:53 <LoganCapaldo> according to some random post I found by Simon Marlow fdToHandle is the function you should be using and openFd is some internal doohicky
18:44:48 <TomMD> Am I duplicating work by fixing up halfs for GHC 6.8?
18:52:02 <LoganCapaldo> @hoogle withOpenFd
18:52:02 <lambdabot> No matches found
18:52:44 <LoganCapaldo> @hoogle withOpenFile
18:52:45 <lambdabot> No matches found
18:57:09 <newsham> *sigh* I give up.  http://www.thenewsh.com/%7Enewsham/formal/curryhoward/Classic2.hs
18:59:01 <dibblego> how can I easily demonstrate to someone that _|_ and a non-terminating function are the same?
19:01:09 <shachaf> dibblego: "Demonstrate"?
19:01:25 <dibblego> yes
19:01:30 <dibblego> "explain"
19:01:34 <shachaf> dibblego: Neither of them ever returns, when evaluated.
19:02:03 <Cale> It's almost by definition
19:02:09 <shachaf> dibblego: What type of demonstration are you thinking of?
19:02:22 <dibblego> someone on the Scala mailing list is arguing with me
19:02:23 <Cale> _|_ is the value assigned to nonterminating computations
19:02:37 <Cale> by the semantics
19:02:41 <dibblego> it started when someone said "we should make pattern matching fail for non-exhaustive cases"
19:02:56 <dibblego> and I said, "no we shouldn't, since Scala is not total"
19:04:32 <dibblego> > missing a case -> exception (or early failure) -> non-terminating function
19:04:32 <lambdabot>  Parse error
19:04:33 <dibblego> Unless you are thinking of some unusual denotational model of programs, an exception in *no way* implies non-termination.  I do not have time to explain this in detail.  I recommend you read an introductory text like Pierce's TAPL to see how syntactic type safety is described in detail.
19:04:38 <ddarius> newsham: One way to do it would be to use excluded middle
19:04:42 <dibblego> I don't know how to respond to that
19:04:55 <dibblego> other than, "that is the very definition", like Cale said
19:06:15 <Cale> data Bool = False | True | FileNotFound
19:06:51 <dibblego> heh
19:08:01 <ddarius> newsham: Essentially, do a case analysis on the result of exclMiddle, if it OrR you're done, if it's OrL use the returned values to apply to np2false and then use absurd.
19:08:16 <olsner> Cale: oh, copycat you
19:08:59 <Cale> I first saw something of that sort on thedailywtf
19:09:26 <ddarius> I.e. falseElim np2false = do em <- exclMiddle; case em of OrR p -> p; OrL np -> absurd (np2false np)
19:09:33 <olsner> likewise ;-) thus copycat
19:10:08 <ddarius> However, that is actually equivalent to Either FileNotFound Bool
19:10:39 <Cale> It seemed appropriate what with dibblego's "an exception in *no way* implies non-termination"
19:11:03 <dibblego> I said an exception does imply non-termination
19:11:09 <Cale> (I think he was perhaps quoting someone else there)
19:11:11 <Cale> yeah
19:11:24 <dibblego> and I have just received a response saying no it doesn't
19:11:32 <dibblego> I don't know what to say anymore
19:11:53 <tehgeekmeister> ?src liftM
19:11:53 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:11:54 <newsham> ddarius: I dont get where I get the values to do case analysis on
19:12:00 <newsham> because there are no arguments to exclMiddle
19:12:23 <ddarius> newsham: exclMiddle doesn't take any arguments and I didn't provide it any.
19:12:28 <olsner> an exception makes the environment terminate with what's essentially a "no" answer, so I think exception is another way to terminate
19:12:45 <newsham> ddarius: I've been trying to define excluded middle for the last 3 hrs
19:12:48 <newsham> and getting nowhere
19:12:57 <ddarius> newsham: Does the version you have there work?
19:13:19 <newsham> everything works excepd excluded middle
19:13:36 <ddarius> newsham: I assumed the problem you were having was falseElim since it's incomplete.
19:14:36 <newsham> i can see that being misleading.. oops. sorry
19:15:47 <newsham> another thing -- do I need the cont-passing style?  magnus carlsson's slides show a callcc going straight to Either a (a -> b)
19:16:08 <newsham> (but I guess I'd need a Cont to use it in the first place, right?)
19:16:47 <ddarius> The slides are presumably not in Haskell.  The fact that there is \k. instead of \k -> further suggests this.
19:17:23 <newsham> the slides are haskell but some of the items he gives as lambda expressions without the monadic wrappers
19:17:49 <newsham> ie "the non-monadic type for calcc:   calcc:: ((a->x)->a) -> a
19:18:07 <ddarius> It's probably easier to work with a variant of call/cc usually called control.  The difference is that it aborts if it's argument does not use the provided continuation (in other words, it effectively requires it to)
19:18:47 <newsham> not sure I understand that.
19:19:19 <newsham> perhaps i should drink beer instead
19:19:29 <newsham> thanks for your help..  maybe it will make more sense tomorow.
19:19:30 <ddarius> The way double negation elimination works is you pass in a continuation that accepts p which will be applied and jump out giving p.
19:20:56 <ddarius> E.g. with just exceptions, doubleNegationElim :: (Not (Not p)) -> p; doubleNegationElim nnp = catch (nnp throw) (\p -> p)
19:23:36 <tehgeekmeister> is this an example of point free style: parseNumber = liftM (Number . read) $ many1 digit
19:23:56 <ddarius> tehgeekmeister: yes
19:25:12 <tehgeekmeister> so a version written with do notation or explicit binding would have to be written non point free, correct?
19:26:03 <dons> nope :)
19:26:08 <ddarius> Not necessarily.
19:26:17 <dons> ?pl undo do x <- getChar ; putChar (toUpper x)
19:26:18 <lambdabot> (line 1, column 22):
19:26:18 <lambdabot> unexpected ";"
19:26:18 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
19:26:21 <dons> ?. pl undo do x <- getChar ; putChar (toUpper x)
19:26:21 <lambdabot> putChar . toUpper =<< getChar
19:26:34 <ddarius> parseNumber = many1 digit >>= return . Number . read
19:27:15 <shachaf> tehgeekmeister: Number . read <$> many1 digit -- Also works.
19:28:00 <tehgeekmeister> shachaf: what does <$> do?  it's not introduced in the tutorial i'm using yet
19:28:41 <shachaf> tehgeekmeister: (<$>) = fmap
19:28:41 <ddarius> tehgeekmeister: It's unlikely to be.  But <$> = fmap
19:29:02 <shachaf> tehgeekmeister: It's in Control.Applicative; fmap is (should be) another name for liftM.
19:29:28 <ddarius> All monads are functors and liftM is the proof of that.
19:29:32 <tehgeekmeister> shachaf: ah, it looked like other parsec operators.
19:30:42 <dibblego> why is liftM proof?
19:31:17 <dibblego> I guess it is actually
19:31:36 <shachaf> dibblego: It shows that you can write a function :: (a -> b) -> m a -> m b?
19:31:51 <dibblego> shachaf, yeah I guess
19:32:18 <ddarius> Technically, you'd have to further show that it satisfies the functor laws, but that follows from the monad laws.
19:32:39 <dibblego> right
19:35:50 <shapr> @yow !
19:35:50 <lambdabot> While my BRAINPAN is being refused service in BURGER KING, Jesuit
19:35:50 <lambdabot> priests are DATING CAREER DIPLOMATS!!
19:36:36 <tehgeekmeister> ?
19:38:17 <Zao> Sounds like some quality fnord.
19:41:02 <shapr> Zao: Faktist, jag heter Erisson.
19:46:39 <olsner> shapr: eriksson, ericsson eller Erisson? "Eri" lter inte srskilt nordiskt :P
19:49:44 <Zao> olsner: Eri seems to be more popular in Norway than in Sweden.
19:50:22 <olsner> ah, perhaps it is so
19:51:28 <olsner> anyways, I'm getting up in about 6h to resume the party... if you're going to sjslaget, I'll see you there, if not then not :P
20:02:56 <shapr> olsner: Jag kommer frn USA, och heter Erisson, "son of Eris".
20:05:16 <shapr> Det r inte riktigt nordiskt. Jag utbytde namnet innan jag flyttade till Sverige.
20:05:44 <Olathe> ahmuhgawd it's Svedish !
20:27:39 <omnId> @brain Are you pondering what I'm pondering?
20:27:39 <lambdabot> I think so, Doctor. But are these really the legs of a show girl?
20:28:41 <LoganCapaldo> @source Cont
20:28:41 <lambdabot> Cont not available
20:28:57 <LoganCapaldo> @source Control.Monad.Cont
20:28:58 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Cont.hs
20:29:28 <mgsloan> :O sweet
20:41:19 * LoganCapaldo is sad cause he couldn't quite figure out >>= without peeking
20:42:09 * Beelsebob is poking at understanding monads better
20:42:15 <ddarius> @src Cont (>>=)
20:42:15 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
20:42:17 <Beelsebob> if I were to attempt to write the tree monad
20:42:27 <Beelsebob> would it be sensible for bind, to take all items in the tree
20:42:30 <Beelsebob> apply the function to them all
20:42:38 <ddarius> Beelsebob: The Tree monad is a free monad.
20:42:41 <Beelsebob> and then arbitrarily put the resulting trees together
20:42:56 <Beelsebob> or is one way of putting them together better than another?
20:43:02 <dmwit> One way is better.
20:43:11 <Beelsebob> which, and why?
20:43:22 <dmwit> You need (join :: m (m a) -> m a) to work correctly.
20:43:36 <dmwit> When you have that, bind comes for free.
20:44:04 <dibblego> that and a Functor don't you mean?
20:44:05 <Beelsebob> well, yes, but surely join can take my trees and combine them in any way it likes
20:44:31 <bos> @seen dons
20:44:31 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 12m 15s ago.
20:44:53 <dmwit> Beelsebob: Oh.  Well, I suppose so.
20:45:00 <Beelsebob> okay
20:45:11 <stoic_> which sorting algorithm does Data.List.sort use?
20:45:11 <Beelsebob> so back to the original question, is one way for join to work better than another?
20:45:43 <Beelsebob> I guess it would be possible to add the ordered constraint and have the "binary search tree" monad, that always preserves trees as search trees
20:45:58 <Beelsebob> @src sort
20:45:58 <lambdabot> sort = sortBy compare
20:46:04 <Beelsebob> @src sortBy
20:46:05 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:46:10 <LoganCapaldo> it would be hard to write a binary search tree monad
20:46:10 <Beelsebob> insert sort
20:46:14 <omnId> @source Data.List
20:46:14 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
20:46:21 <sarehu> stoic: according to the source, a mergesort
20:46:29 <Beelsebob> LoganCapaldo: why, join would just have to merge the trees in a sensible way
20:46:49 <LoganCapaldo> Because you need Ord to write a binary search tree
20:46:56 <Beelsebob> certainly
20:47:05 <LoganCapaldo> @type join
20:47:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:47:11 <dmwit> (But monads don't get to place restrictions on their contents.)
20:47:11 <allbery_b> but join can't take any additional constraints
20:47:19 <Beelsebob> dmwit: oh, okay
20:47:25 <Beelsebob> fair point
20:47:34 <Beelsebob> that's a bit disapointing
20:48:06 <Beelsebob> so I would have to create an OrderedMonad class to do such a thing
20:48:14 <stoic_> thanks
20:48:29 <Beelsebob> which could for example have the sorted list ordered monad, and the search tree monad in it
20:48:43 <wli> No.
20:49:02 <Beelsebob> no?
20:49:19 <wli> Monads only apply to the type constructor.
20:49:41 <Beelsebob> oh, duh
20:49:42 <Beelsebob> damn
20:49:59 <ddarius> Also, monads need to satisfy some laws.
20:49:59 <wli> The types fed as arguments to the tycon have no way to be constrained.
20:50:20 <ddarius> However, in the appropriate category, perhaps what you want would work.
20:50:30 <wli> Not in Haskell's type system anyway.
21:03:29 <OceanSpray> I came for engaging discussion
21:04:17 <bos> why do all of lou reed's songs sound the same? discuss engagingly.
21:04:45 <dmwit> @vixen I came for engaging discussion
21:04:46 <lambdabot> If I was looking for anonymous casual sex, I wouldn't be sitting here behind my computer talking to you!
21:04:54 <LoganCapaldo> and the colored girls sing, do do do do do do do do
21:05:14 <concave> bos, this isn't true >:(
21:19:38 <Mr_Awesome> maybe a little offtopic, but is there a 'redo' operation in emacs?
21:19:38 <bos> no.
21:19:38 <dmwit> What?  Really?
21:19:38 <bos> what you do instead is hit something like control-space, then undo.
21:19:38 <bos> i.e. you can reverse the direction of undo.
21:19:38 <dmwit> oh
21:19:38 <dmwit> Okay, that's mildly sane.
21:19:38 <Mr_Awesome> you dont remember what it is?
21:19:38 <bos> http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Undo
21:19:38 <lambdabot> Title: Info Node: (emacs)Undo
21:19:38 <bos> no, i told you what it is. there are several ways to trigger the switch in direction.
21:20:24 <allbery_b> any editing operation and a few others
21:20:29 <Mr_Awesome> ah ok
21:21:16 <LoganCapaldo> I had thought I had typed M-x redo once
21:21:49 <LoganCapaldo> But I use emacs every other fifth summer solstice
21:21:59 <LoganCapaldo> so my memory is likely faulty
21:22:04 <bos> indeed.
21:22:09 <allbery_b> the undos are considered editing operations and themselves go into the undo list, but you have to do something to break out of the "undo loop"
21:22:27 <allbery_b> actually  think just about any command will do that, it';s just consecutive undos that proceed through the undo stack
21:23:59 <bos> yeah. it's very logically thought out and quite often very confusing.  you have to keep the behaviour model fresh in your head.
21:24:24 <bos> but don't pay any attention to me. i've only been living in emacs for 15 years; i still have a lot to learn.
21:24:47 <dmwit> It needs branching undo and a visualizer, like in SGF viewers. ;-)
21:25:55 <bos> the functional programming group at glasgow used to be a hotbed of go.
21:26:32 <bos> go, rock climbing, indian food, pizza, and ghc. in no particular order.
21:26:44 <bos> oh, and beer
21:26:56 <LoganCapaldo> and then the go stones came alive in the night and drove the programmers out. It was vowed that noone would ever place Go among hot coals and sleep upon it ever again
21:28:39 <platypus> LoganCapaldo: What?
21:30:55 <LoganCapaldo> platypus: ?
21:37:18 <agnokapathetic> hello all
21:37:41 <abz> ?users
21:37:42 <lambdabot> Maximum users seen in #haskell: 420, currently: 353 (84.0%), active: 10 (2.8%)
21:52:15 <hpaste>  agnokapathetic pasted "Iteration -> functional" at http://hpaste.org/3274
21:52:31 <agnokapathetic> i'm not sure if this is the right place to ask this
21:52:56 <agnokapathetic> but can anyone help me implement a simple iterative algorithm in haskell?
21:53:00 <glguy> sure
21:53:11 <agnokapathetic> im counting divisors of an integer
21:53:13 <agnokapathetic> and using
21:53:18 <agnokapathetic> length (filter (\x -> x) (map (\p -> p `divides` x) [1..x]))
21:53:20 <newsham> this would be the right place for that
21:53:28 <agnokapathetic> where d `divides` n = n `mod` d == 0
21:53:45 <hpaste>  glguy annotated "Iteration -> functional" with "clean-ups" at http://hpaste.org/3274#a1
21:54:08 <Beelsebob> agnokapathetic: there's no need for the map
21:54:11 <newsham> filter (\x -> x)   doesnt do a whole lot
21:54:24 <Beelsebob> length (filter (\p -> p `divides` x) [1..x])
21:54:37 <Beelsebob> or better yet
21:54:44 <agnokapathetic> yeah, i'm one day into haskell thanks for the help :-)
21:54:48 <Beelsebob> length (filter (p `divides`) [1..x])
21:55:15 <Beelsebob> wait no
21:55:17 <Beelsebob> sorry
21:55:31 <Beelsebob> length (filter (`divides` x) [1..x])
21:55:33 <Beelsebob> even
21:55:42 <agnokapathetic> but, thats still O(n) and the algorithm listed above is O(n sqrt n)
21:55:47 <dmwit> Beelsebob: You've been beaten, see the annotation. ;-)
21:55:58 <Beelsebob> ah, k
21:56:00 <dmwit> agnokapathetic: [1..floor (sqrt x)]
21:56:21 <dmwit> Then double it, and do perfect squares as a special case.
21:56:25 <newsham> which algorithm is O(n sqrt n)?
21:56:40 <dmwit> newsham: I think he means O(sqrt n).
21:56:45 <Beelsebob> dmwit: you could always just use ceil instead of floor
21:56:46 <agnokapathetic> thats what the algorithm in the comment does
21:56:58 <agnokapathetic> yeah, the ceil would include the special sqare case?
21:57:00 <Beelsebob> okay, it does 1 too many comparisons sometimes
21:57:02 <dmwit> Beelsebob: yes, but the same special case happens anyway. ;-)
21:57:08 <Beelsebob> it does?
21:57:11 <Beelsebob> example?
21:57:20 <dmwit> agnokapathetic: Yes, it includes squares, but doubling it would count the square twice.  So you need to special-case that anyway.
21:57:51 <agnokapathetic> how would i go about implementing that special case?
21:57:55 <dmwit> ...or maybe I'm wrong; it's happened before. =P
21:58:09 <Beelsebob> dmwit: can you give an example where it breaks, I'm missing something
21:58:37 <dmwit> Beelsebob: What is the code you're using?  I need to know that before I know if I'm talking nonsense or not. =)
21:58:50 <agnokapathetic> dmwit: and yes  i do mean O(sqrt n)
21:59:00 <dmwit> ?let divides = ((== 0).) . flip mod
21:59:02 <lambdabot> Defined.
21:59:05 <dmwit> > 3 `divides` 6
21:59:07 <lambdabot>  True
21:59:14 <dmwit> > 3 `divides` 7
21:59:15 <lambdabot>  False
21:59:28 <ddarius> First, define Riemann's zeta function, then square it and calculate the Dirichlet series that corresponds to the result.
21:59:28 <Beelsebob> > let divides d n = n `mod` d == 0 in let countDivs x = length (filter (`divides` x) [1..x]) in countDivs 16
21:59:30 <lambdabot>  5
21:59:48 <shapr> @seen dons
21:59:48 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 2h 27m 32s ago.
21:59:49 <dmwit> Beelsebob: That doesn't break.
21:59:52 <Beelsebob> oh, hang on
21:59:57 <Beelsebob> I realise what you're on about now
22:00:01 <dmwit> Beelsebob: It is also O(n), not O(sqrt n) like he wants. =)
22:00:04 <Beelsebob> yeh
22:00:12 <Beelsebob> no, I see what you were getting at now
22:00:58 <dmwit> > let countDivs x = let s = floor (sqrt x) in 2 * length (filter (`divides x) [1..s]) + (if s*s == x then 1 else 0) in countDivs 32
22:00:59 <lambdabot>  Parse error
22:01:11 <Beelsebob> countDivs x = length (filter (`divides` x) [1..floor (sqrt x)]) - (if (floor (sqrt x))^2 == x) then 1 else 0)
22:01:29 <dmwit> Yeah.
22:01:32 <dmwit> That's the idea.
22:01:35 <Beelsebob> > let divides d n = n `mod` d == 0 in let countDivs x = length (filter (`divides` x) [1..floor (sqrt x)]) - (if (floor (sqrt x))^2 == x) then 1 else 0) in countDivs 16
22:01:36 <lambdabot>  Unbalanced parenthesis
22:01:45 <dmwit> But now you're doing the special case, so why not use floor? ;-)
22:01:51 <Beelsebob> > let divides d n = n `mod` d == 0 in let countDivs x = length (filter (`divides` x) [1..floor (sqrt x)]) - (if (floor (sqrt x))^2 == x) then 1 else 0 in countDivs 16
22:01:52 <lambdabot>  Parse error
22:02:06 <Beelsebob> > let divides d n = n `mod` d == 0 in let countDivs x = length (filter (`divides` x) [1..floor (sqrt x)]) - (if ((floor (sqrt x))^2 == x) then 1 else 0) in countDivs 16
22:02:07 <lambdabot>  Add a type signature
22:02:14 <Beelsebob> bah
22:02:15 <Beelsebob> where?
22:02:28 <Beelsebob> > let divides d n = n `mod` d == 0 in let countDivs x = length (filter (`divides` x) [1..floor (sqrt x)]) - (if (((floor (sqrt x)) :: Int)^2 == x) then 1 else 0) in countDivs 16
22:02:29 <lambdabot>   add an instance declaration for (Floating Int)
22:02:38 <dmwit> > let countDivs x = let s = floor (sqrt x) in 2 * length (filter (`divides` x) [1..s]) + (if s*s == x then 1 else 0) in countDivs 32
22:02:39 <Beelsebob> > let divides d n = n `mod` d == 0 in let countDivs x = length (filter (`divides` x) [1..floor (sqrt x)]) - (if (((floor (sqrt x)) :: Int)**2 == x) then 1 else 0) in countDivs 16
22:02:39 <lambdabot>   add an instance declaration for (Floating Integer)
22:02:40 <lambdabot>   add an instance declaration for (Floating Int)
22:02:51 <Beelsebob> > let divides d n = n `mod` d == 0 in let countDivs x = length (filter (`divides` x) [1..floor (sqrt x)]) - (if (((floor (sqrt x)) :: Float)^2 == x) then 1 else 0) in countDivs 16
22:02:52 <lambdabot>   add an instance declaration for (Integral Float)
22:02:56 <Beelsebob> wtf
22:03:03 <agnokapathetic> floor returns a float me thinks
22:03:09 <agnokapathetic> the [1..float]
22:03:12 <agnokapathetic> doesnt work?
22:03:14 <dmwit> :t floor
22:03:16 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
22:03:24 <dmwit> Nobe, floor returns an Integral b.
22:03:25 <Beelsebob> :t ^
22:03:27 <lambdabot> parse error on input `^'
22:03:28 <Beelsebob> :t (^)
22:03:30 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
22:03:46 <Beelsebob> so surely it just can't chose what integer type to use
22:03:52 <Beelsebob> > let divides d n = n `mod` d == 0 in let countDivs x = length (filter (`divides` x) [1..floor (sqrt x)]) - (if (((floor (sqrt x)) :: Int)^2 == x) then 1 else 0) in countDivs 16
22:03:53 <lambdabot>   add an instance declaration for (Floating Int)
22:03:58 <Beelsebob> why doesn't that work?
22:05:07 <agnokapathetic> in my GHCi
22:05:07 <agnokapathetic> C:/Users/Joel/Desktop/haskell/12.hs:19:59:
22:05:07 <agnokapathetic>     No instance for (Floating Int)
22:05:07 <agnokapathetic>       arising from use of `sqrt'
22:05:07 <agnokapathetic>       at C:/Users/Joel/Desktop/haskell/12.hs:19:59-64
22:05:08 <agnokapathetic>     Possible fix: add an instance declaration for (Floating Int)
22:05:10 <agnokapathetic>     In the first argument of `floor', namely `(sqrt x)'
22:05:11 <Beelsebob> yeh
22:05:12 <agnokapathetic>     In the expression: floor (sqrt x)
22:05:14 <agnokapathetic>     In the second argument of `filter', namely `[1 .. floor (sqrt x)]'
22:05:16 <agnokapathetic> whoops
22:05:18 <agnokapathetic> sorry
22:05:20 <agnokapathetic> ill paste
22:05:24 <dmwit> oh
22:05:25 <dmwit> heh
22:05:28 <dmwit> I get it.
22:05:47 <dmwit> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) + (if s*s == x then 1 else 0) in countDivs 32
22:05:49 <lambdabot>  6
22:05:53 <Beelsebob> :)
22:05:53 <dmwit> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) + (if s*s == x then 1 else 0) in countDivs 9
22:05:55 <lambdabot>  5
22:06:02 <dmwit> My number's wrong, though.
22:06:07 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) + (if s*s == x then 1 else 0) in countDivs 16
22:06:09 <lambdabot>  7
22:06:18 <dmwit> So's yours.
22:06:21 <Beelsebob> you're counting up to s
22:06:24 <Beelsebob> not sqrt s
22:06:26 <Beelsebob> oh no
22:06:28 <dmwit> WRONG!
22:06:28 <Beelsebob> being a noob
22:06:29 <dmwit> =)
22:06:43 <Beelsebob> you're adding the odd one
22:06:44 <dmwit> oh
22:06:45 <dmwit> yeah
22:06:46 <Beelsebob> not subtracting it
22:06:57 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs 16
22:06:58 <dmwit> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs 9
22:06:59 <lambdabot>  5
22:07:00 <lambdabot>  3
22:07:01 <Beelsebob> hehe
22:07:04 <Beelsebob> better
22:07:13 <dmwit> much
22:07:27 * dmwit rests
22:07:28 <agnokapathetic> yay!
22:07:32 <agnokapathetic> thank you all very much
22:07:39 <Beelsebob> no probs
22:07:45 <Beelsebob> that was a fun exercise in defaulting
22:07:51 <dmwit> agnokapathetic: Depending on the problem, though, I wouldn't worry too much about this particular O(n)/O(sqrt n) business.
22:08:12 <dmwit> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs 9999999999999999 -- fast
22:08:17 <lambdabot> Terminated
22:08:21 <dmwit> -- not fast
22:08:22 <dmwit> heh
22:08:38 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs 10^10 -- fast
22:08:39 <agnokapathetic> premature optimization is the root of all evil
22:08:40 <lambdabot>  1048576
22:08:40 <agnokapathetic> however
22:08:42 <dmwit> Anyway, a faster solution still is to first factor the number.
22:08:50 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs 10^12 -- fast
22:08:51 <lambdabot>  16777216
22:08:56 <agnokapathetic> the problem is "Which is the first triangle number to have over five-hundred divisors?"
22:08:59 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs 10^14 -- fast
22:09:00 <lambdabot>  268435456
22:09:03 <bos> man, System.Directory has one puny-ass API for file metadata
22:09:05 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs 10^16 -- fast
22:09:07 <lambdabot>  0
22:09:10 <Beelsebob> o.O
22:09:12 <Beelsebob> bug?
22:09:29 <dmwit> agnokapathetic: In that problem, you can do much better!
22:09:45 <omnId> (countDivs 10)^14
22:09:46 <dmwit> For example, you know that the nth triangle number is n(n+1)/2 -- nearly factored for you already!
22:10:45 * dmwit peeks at his solution to see how clever he was
22:11:51 <dmwit> Phew, I factorized them.  My intellectual integrity is intact. =P
22:12:06 <Beelsebob> omnId: yes, but why did 4^14 return 268435456, while 4^16 returned 0
22:12:20 <omnId> > 4^16 :: Integer
22:12:22 <lambdabot>  4294967296
22:12:24 <dmwit> > (4::Int)^16
22:12:25 <lambdabot>  0
22:12:31 <Beelsebob> splode
22:12:32 <dmwit> (overflow)
22:12:35 <Beelsebob> ah yeh
22:12:37 <omnId> > maxBound :: Int
22:12:38 <Beelsebob> so it's defaulting
22:12:38 <lambdabot>  2147483647
22:12:49 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs (10::Integer)^16 -- fast
22:12:49 <dmwit> No
22:12:51 <lambdabot>  0
22:12:54 <dmwit> :t length -- chooses the type
22:12:56 <lambdabot> forall a. [a] -> Int
22:12:58 <Tac-Tics> > maxBound :: Integer
22:12:59 <lambdabot>   add an instance declaration for (Bounded Integer)
22:12:59 <lambdabot>     In the expression: ma...
22:13:05 <Beelsebob> > (4 :: Integer) ^ 16
22:13:06 <lambdabot>  4294967296
22:13:07 <ddarius> :t genericLength
22:13:09 <lambdabot> forall b i. (Num i) => [b] -> i
22:13:15 <Beelsebob> okay, yeh
22:13:17 <Beelsebob> I see
22:13:25 <Tac-Tics> > 4 ^ 16 :: Integer
22:13:27 <lambdabot>  4294967296
22:13:48 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs (10^8) -- fast
22:13:49 <lambdabot>  81
22:13:54 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs (10^12) -- fast
22:13:56 <lambdabot>  169
22:14:00 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs (10^14) -- fast
22:14:05 <lambdabot> Terminated
22:14:09 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs (10^13) -- fast
22:14:15 <lambdabot>  196
22:14:26 <Beelsebob> interesting...
22:14:43 <Beelsebob> so countDivs (10^n) == (n+1)^2
22:14:46 <Beelsebob> why?
22:14:55 * Beelsebob wonders off to check why
22:15:29 <ddarius> Beelsebob: 10 = 5*2, 10^n = 5^n*2^N
22:15:39 <Beelsebob> yep, that makes sense
22:17:00 <ddarius> So for each of the n+1 factors of 5 you multiply by the n+1 factors of 2
22:17:08 <Beelsebob> indeed
22:17:30 <Beelsebob> so in theory...
22:17:49 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs (9^2) -- fast
22:17:50 <lambdabot>  5
22:17:55 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs (9^3) -- fast
22:17:55 <dmwit> > numDivisors (10^16)
22:17:58 <lambdabot>  7
22:17:58 <lambdabot>  289
22:18:14 <Beelsebob> > let countDivs x = let s = floor . sqrt . fromIntegral $ x in 2 * length (filter (`divides` x) [1..s]) - (if s*s == x then 1 else 0) in countDivs (9^4) -- fast
22:18:15 <dmwit> > numDivisors (9^3)
22:18:18 <lambdabot>  7
22:18:18 <lambdabot>  9
22:18:36 <Beelsebob> fun
22:18:54 <dmwit> > map (\x -> numDivisors (9^x)) [1..10]
22:18:54 <newsham> > numDivisors 1354343
22:18:54 <ddarius> 3^(2n) so 2n+1
22:18:58 <lambdabot>  [3,5,7,9,11,13,15,17,19,21]
22:18:59 <lambdabot> Terminated
22:19:16 <newsham> > numDivisors 2671
22:19:16 <Beelsebob> many lots of shiny :)
22:19:17 <lambdabot>  2
22:19:22 <dmwit> > prime 1354343
22:19:24 <lambdabot>  True
22:19:29 <dmwit> ddarius: You bastard. =P
22:19:43 <agnokapathetic>  numDivisors is already defined? joyous
22:19:55 <dmwit> Nope.  I ?let it be defined. =P
22:20:00 <agnokapathetic> ahh
22:20:04 <dmwit> sorry
22:20:18 <ddarius> dmwit: I am indeed a bastard.
22:20:22 <Beelsebob> I take it that prime is a eulers sive
22:20:27 <Beelsebob> @src prime
22:20:27 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:20:30 <Beelsebob> hmm
22:20:38 <Beelsebob> src should return whatever someone ?let it as
22:20:41 <ddarius> (Actually, it's kind of iffy, but I'm pretty sure I still fit the definition.)
22:20:44 <Beelsebob> with a note saying it was
22:20:51 <dmwit> Beelsebob: Yes, it's a sieve.
22:21:13 <agnokapathetic> @src numDivisors
22:21:14 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:21:23 <dmwit> Okay, hpaste time.
22:22:06 <Beelsebob> who mantains lambdabot these days?
22:22:16 <hpaste>  dmwit pasted ""When I was in Project Euler..."" at http://hpaste.org/3275
22:22:54 <dmwit> Don't copy my style, only my ideas. ;-)
22:23:38 <Beelsebob> that's a nice definition actually
22:23:43 <Beelsebob> much clearer than the standard one
22:25:35 <dmwit> > head $ dropWhile ((<= 500) . numDivisors) triangles
22:25:37 <lambdabot>  76576500
22:25:51 <dmwit> We even fit within lambdabot's execution time limit. =)
22:26:39 <newsham> ?vixen where are you from?
22:26:40 <lambdabot> Huntington Beach California
22:26:52 <newsham> ?vixen we should go see a movie.
22:26:53 <lambdabot> what's the matter?
22:27:21 <agnokapathetic> that triangles solution looks like magic to me (one day into haskell coming from a strictly imperative background)
22:27:48 <newsham> agno: shoulda took the blue pill
22:27:52 <dmwit> agnokapathetic: You mean the definition for the infinite list "triangles" on the hpaste?
22:28:05 <agnokapathetic> yes
22:28:17 <dmwit> It *is* magic. =)
22:28:29 <dmwit> agnokapathetic: Did you know the (n*(n+1)/2) formula already?
22:28:41 <agnokapathetic> nope, but it makes sense
22:28:46 <dmwit> ok
22:29:12 <dmwit> So, for you, the magic is in the infinite lists?  Or something else?
22:29:16 <newsham> agno: do you know about list comprehensions (ie. also in python)
22:29:32 <agnokapathetic> yes, list comprehensions are familiar... javascript even has them now :-)
22:29:45 <agnokapathetic> the thing that confuses me most about haskell code i see
22:29:47 <agnokapathetic> is x:xs
22:29:49 <agnokapathetic> p:ps
22:29:53 <newsham> triangles is just a list comprehension
22:29:57 <ddarius> > scanl (+) 1 [2..]
22:29:59 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
22:30:12 <dmwit> > scanl1 (+) [1..]
22:30:13 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
22:30:28 <dmwit> agnokapathetic: That's list construction/deconstruction.
22:30:29 <ddarius> > map (\n -> n*(n+1) `div` 2) [1..]
22:30:31 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
22:30:33 <dmwit> > 3 : [4,5,6]
22:30:34 <agnokapathetic> i understand the triangles definition part :-)
22:30:35 <lambdabot>  [3,4,5,6]
22:30:38 <agnokapathetic> ah
22:30:38 <omnId> > (\(x : xs) -> x) [1,2,3]
22:30:39 <lambdabot>  1
22:30:44 <omnId> > (\(x : xs) -> xs) [1,2,3]
22:30:45 <lambdabot>  [2,3]
22:30:59 <Nafai> So is sjf the new linuxer on reddit?
22:31:01 <Tac-Tics> > (\(x:xs)->x) []
22:31:03 <lambdabot>   Non-exhaustive patterns in lambda
22:31:13 <omnId> > head []
22:31:15 <lambdabot>  Exception: Prelude.head: empty list
22:31:26 <Tac-Tics> is it possible in haskell to specify lambda functions with more than one pattern to match against?
22:31:40 <ddarius> Tac-Tics: No, but you can use case.
22:31:52 <Nafai> 17 of the 25 newest articles are submitted by sjf
22:32:04 <ddarius> (Or, of course, just declare a (local) function.)
22:32:11 <omnId> there's a lambda-case proposal or two for Haskell'.
22:32:23 <Tac-Tics> ddarius: well that wouldn't be cool enough, now would it?
22:33:57 <ddarius> Usually, if you have multiple cases a named function is not a bad idea.
23:08:23 <bos> @src filterM
23:08:24 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:15:07 <elliottt> ping glguy
23:25:59 <matt__r> > id 3
23:26:01 <lambdabot>  3
23:27:50 <agnokapathetic> > foldl ((+) . (*10) ) 0 [1..10]
23:27:52 <lambdabot>  1234567900
23:27:58 <agnokapathetic> > foldl ((+) . (*10) ) 0 [1..11]
23:27:59 <lambdabot>  12345679011
23:28:00 <dmwit> > const (id (+)) ((-) . (+)) 3 4
23:28:02 <lambdabot>   add an instance declaration for (Num (a -> a))
23:28:11 <dmwit> > const (id (+)) (((-).) . (+)) 3 4
23:28:13 <lambdabot>  7
23:28:22 <ddarius> > foldl ((+) . (10*)) 0 [1,3,2,6]
23:28:24 <lambdabot>  1326
23:28:32 <omnId> = const (+) (...) = (+)
23:28:48 <dmwit> omnId: = (+) 3 4
23:28:50 <dmwit> ;-)
23:29:06 <Tac-Tics> > do op <- [(+), subtract, (*), div, mod]; x <- [0..10]; y <- [1..10]; return $ op x y
23:29:07 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8...
23:29:20 <dmwit> > foldr ((+) . (*10)) 0 [1,3,2,6]
23:29:22 <lambdabot>  120
23:30:38 <ddarius> > foldr (flip ((+) . (10*))) 0 [1,3,2,6]
23:30:40 <lambdabot>  6231
23:32:40 <agnokapathetic> >  foldr (flip ((+) . (10*))) 0 (reverse [1,3,2,6])
23:32:42 <lambdabot>  1326
23:36:11 <omnId> > product $ zipWith (*) (iterate (*10) 1) (reverse [1,3,2,6])
23:36:13 <lambdabot>  36000000
23:36:31 <omnId> er, s/product/sum/
23:36:36 <omnId> > sum $ zipWith (*) (iterate (*10) 1) (reverse [1,3,2,6])
23:36:37 <lambdabot>  1326
23:37:56 <agnokapathetic> > sum $ zipWith (*) (iterate (*10) 1) (reverse [5,5,3,7,3,7,6,2,3,0])
23:37:57 <lambdabot>  5537376230
23:38:35 <omnId> > iterate (*10) 1
23:38:36 <lambdabot>  [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,1000000000...
23:38:53 <omnId> > zipWith (*) [2,3,5] [6,3,4]
23:38:55 <lambdabot>  [12,9,20]
23:43:40 <agnokapathetic> >let toDigits x = map Char.digitToInt (show x) in toDigits 12345678
23:44:29 <agnokapathetic> > let toDigits x = map Char.digitToInt (show x) in toDigits 12345678
23:44:32 <lambdabot>  [1,2,3,4,5,6,7,8]
23:46:54 <agnokapathetic> >let fromDigits = fromDigits x =  sum $ zipWith (*) (iterate (*10) 1) (reverse x) let toDigits x = map Char.digitToInt (show x) in fromDigits (take 10 (toDigits 5537376230390876637302048746832985971773659831892672))
23:47:08 <agnokapathetic> > let fromDigits = fromDigits x =  sum $ zipWith (*) (iterate (*10) 1) (reverse x) let toDigits x = map Char.digitToInt (show x) in fromDigits (take 10 (toDigits 5537376230390876637302048746832985971773659831892672))
23:47:08 <lambdabot>  Parse error
23:47:34 <agnokapathetic> > let fromDigits x = sum $ zipWith (*) (iterate (*10) 1) (reverse x) let toDigits x = map Char.digitToInt (show x) in fromDigits (take 10 (toDigits 5537376230390876637302048746832985971773659831892672))
23:47:34 <lambdabot>  Parse error
23:47:58 <agnokapathetic> might as well just paste
23:48:20 <hpaste>  agnokapathetic pasted "overflow?" at http://hpaste.org/3276
23:49:18 <hpaste>  (anonymous) annotated "overflow?" with "over 5k, reduced size" at http://hpaste.org/3276#a1
23:49:43 <agnokapathetic> anyone understand why that doesn't yield 55376230?
23:50:24 <dmwit> > sum $ zipWith (*) (iterate (*10) 1) [0,3,2,6,7,3,5,5]
23:50:26 <lambdabot>  55376230
23:50:50 <dmwit> > take 10 . map Char.digitToInt . show $ 553737623039393939393
23:50:52 <lambdabot>  [5,5,3,7,3,7,6,2,3,0]
23:51:17 <dmwit> Because 55376230 is only eight digits?
23:51:37 <agnokapathetic> *5537376230
23:52:11 <agnokapathetic> im trying to get a number which is the first 10 digits of the larger number
23:52:27 <dmwit> > sum . zipWith (*) (iterate (*10) 1) . reverse . take 10 . map Char.digitToInt . show $ 5537376230393939393939
23:52:29 <lambdabot>  1242408934
23:52:33 <dmwit> whoa
23:52:33 <agnokapathetic> theres my problem
23:52:39 <agnokapathetic> is it an overflow?
23:52:41 <dmwit> > sum . zipWith (*) (iterate (*10) 1) . reverse . take 10 . map Char.digitToInt . show $ (5537376230393939393939 :: Integer)
23:52:43 <lambdabot>  1242408934
23:53:09 <dmwit> > take 10 . map Char.digitToInt . show $ (5537376230393939393939 :: Integer)
23:53:10 <lambdabot>  [5,5,3,7,3,7,6,2,3,0]
23:53:26 <dmwit> :t sum
23:53:28 <lambdabot> forall a. (Num a) => [a] -> a
23:53:34 <agnokapathetic> you can see why i was perplexed
23:53:49 <dmwit> > (sum :: [Integer] -> Integer) . zipWith (*) (iterate (*10) 1) . reverse . take 10 . map Char.digitToInt . show $ (5537376230393939393939 :: Integer)
23:53:51 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
23:53:54 <agnokapathetic> > :t Char.digitToInt
23:53:54 <lambdabot>   parse error on input `:'
23:53:58 <dmwit> Okay, it's overflow.
23:54:10 <dmwit> :t Char.digitToInt
23:54:12 <lambdabot> Char -> Int
23:54:15 <dmwit> Aha!
23:54:17 <dmwit> That's why.
23:54:25 <agnokapathetic> i thought that might be it
23:54:53 <agnokapathetic> how would one work around that?
23:55:03 <dmwit> > sum . zipWith (*) (iterate (*10) 1) . reverse . take 10 . map (toInteger . Char.digitToInt) . show $ 5537376230393939393939
23:55:05 <lambdabot>  5537376230
23:55:12 <agnokapathetic> much obliged :)
23:55:27 <dmwit> Yup, just stick a (toInteger .) in your map. =)
23:56:59 <dmwit> ?hoogle Char -> Integer
23:57:00 <lambdabot> No matches, try a more general search
23:57:07 <dmwit> ?hoogle (Num a) => Char -> a
23:57:09 <lambdabot> No matches, try a more general search
23:57:15 <dmwit> ?hoogle Char -> Int
23:57:16 <lambdabot> Char.digitToInt :: Char -> Int
23:57:16 <lambdabot> Char.ord :: Char -> Int
23:57:53 <agnokapathetic> ?hoogle Char -> Integer
23:57:54 <lambdabot> No matches, try a more general search
