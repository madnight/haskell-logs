01:39:42 --- topic: '["The Haskell programming language: homeground of the lambdacats!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ", "http://arcanux.org/lambdacats.html" ]'
01:39:42 --- topic: set by dons on [Wed Oct 10 16:54:09 2007]
01:39:42 --- names: list (clog Arnia_ krishnbhakt ThePub boegel masak yitz xinming abell Arnia BobFunk jao- bringert dankna cbe Mr_Awesome QplQyer Shimei bens KatieHuber borism Jaak iblechbot igel the_dormant doserj filp z` therp roconnor rhz gour amiddelk talmuth sjanssen ChilliX aking takuan jeffz gvdm EvilTerran goalieca ADEpt ttfh StaticVector Plareplane_ tarrybone slava jonafan gwern sclv kalmar alexj_ JBGood tizoc_ carp_ bos thorkilnaur Korollary fnordus)
01:39:42 --- names: list (jbalint mrsolo mordaunt thepointer LoganCapaldo glguy cmeme psykotic ortmage fnord123_ uebayasi falconair atsampso1 psykonau1 araujo nopcode ddarius fridim LunohoD Xgc harlekin dje Tigge mathrick goban_ Torment jjore-w cladhaire eivuokko sad0ur MarcWebe5 MarcWebe3 dblog v0|d vstranger Philippa sioraiocht pgavin-away pBot- div thoughtpolice Olathe jedbrown kpreid pjd c9s zygen worklez Averell JaffaCake mm_freak idnar dcoutts dmwit lokimaf)
01:39:42 --- names: list (lokik_ heanol [LeCamarade] Tac-Tics2 Daveman Kahdloc TomMD TSC kshepard ivan` swix ski dibblego ToxicFrog stevan sarehu dcoutts_ sciolizer yaarg SamB SamB_XP_ GNU\caus21c scook0 wolverian geocalc nornagon ricky_clarkson l_a_m delYsid kolmodin_ arossato pragma_ oklopol kig cognominal whoppix Arnar liyang wli Eelis trurl birkenfeld lambdabot qz Lycurgus seafood betty dino- Saizan drbean fxr zamez Shurique mr_ank kilimanjaro bdash netx tessier)
01:39:42 --- names: list (@ChanServ integral eddyp_away Vulpyne dcwilson hhg gds puusorsa zmike noj jvoorhis tuukkah klugez sieni osfameron Mortez Vq^ Mitar ibid petekaz desp opqdonut MyCatVerbs Lunar^ ramkrsna opqdonut_ jaredj Shoragan mattiast sphynx profmakx robreim acura Liskni_si kenn TwigEther mornfall Metabol yango felipe dufflebunk cizra flux authentic bgeron ttmrichter_ tlp____ ulfdoz Tychom kpk xerox largos_ jql Syzygy- tphyahoo hellige liffey pejo allbery_b)
01:39:42 --- names: list (hpaste Oatschool platypus newsham tessier_ sek iank astrolabe etnt Heffalump Botje lucca Giraph calvins dfranke__ balodja shapr Eidolos rey_ kaol magagr yosemite arguile Cale m4thrick matthew-_ exDM69 CindyLinz Thas audreyt nasloc__ Altair^ quicksilver koeien Excedrin orbitz dvekravy reffie _frederik_ Choko_ hyko ski_ encryptio aleator jcreigh Kattana oscz mlh kalven dionoea kosmikus Poeir kolmodin dons spoopithy shachaf trez eno Modius)
01:39:42 --- names: list (eck wilx Laney huamn_ caust1c ray Auris- dgriffi3 JohnMeacham andun mightybyte smack__ noddyB benny twifkak ozone vincenz noob henrik fdr- mux nnunley_ Mat^ earthy dylan Spark cameron koala_man levitation[A] Mentr3d Caelum Nafai noclouds Lemmih xsdg Japsu fluctus Khisanth Betovsky yahooooo lament mrd arjanoosting blazzy og bran_ lispy jmob chr1s raxas nothingmuch fox86 Boney cjay dfranke_ carmen ksandstr Adamant blackdog_ Igloo Baughn)
01:39:42 --- names: list (ToRA thedward nelhage ichor Zao saccade DRMacIver matthew_- mattam SimonRC jle agemo)
01:40:11 <wli> I'm a big unbeliever in design patterns.
01:40:15 <quicksilver> wli: the fashionable meme in #haskell is something like this: Design Patterns sux0r! C++ sux0r! Design Patterns only exists because C++ can't abstract! j00 sux0r! Haskell doesn't need design patterns.
01:40:27 <quicksilver> wli: frankly, this is horseshit :P
01:40:45 * alexj_ cheers quicksilver
01:41:06 <sclv> there was a pretty famous paper that showed that like 2/3 of the GoF patterns were essentially "natural" to lisp & co. though
01:41:10 <krishnbhakt> or I use thttpd + sqlite
01:41:26 <quicksilver> sclv: right
01:41:33 <quicksilver> sclv: they may be much much easier to express in other languages
01:41:34 <dankna> sclv: I haven't seen that, do you remember the title/author/link?
01:41:44 <quicksilver> sclv: but that doesn't mean that the issues don't exist
01:42:05 <dankna> well, for what it's worth, I personally am of the opinion that Design Patterns, at the very least, are grasping at something important
01:42:10 <quicksilver> sclv: a couple of them, like 'pimpl' really are just angled at peculiarities of C++
01:42:16 <dankna> it's hard to formalize that stuff and it's hard to convey it in any useful way
01:42:27 <dankna> but there is some underlying truth if we can get at it
01:42:33 <quicksilver> sclv: but the general notion that programming is an engineering discipline and common problems deserve common solutions is sound
01:42:57 <quicksilver> even if you don't think the GoF got the right solution to every problem :)
01:43:04 * dankna nods in agreement
01:43:24 <wli> I take design patterns to be demonstrations of inadequacies in the language.
01:43:34 <quicksilver> yes, that's a popular meme
01:43:39 <quicksilver> I strongly disagree, in general
01:43:45 <quicksilver> pimpl might be an example of that
01:43:48 <dankna> even if true, isn't that a reason that they are worth documenting?
01:43:49 <quicksilver> but MVC isn't
01:43:53 <dankna> as lessons for language designers?
01:43:58 <wli> MVC = ?
01:44:00 <ricky_clarkson> Design patterns are a halfway step before you've implemented the pattern in the language.
01:44:00 <sclv> I think this might be the paper I mentioned: http://www.norvig.com/design-patterns/
01:44:01 <lambdabot> Title: Design Patterns in Dynamic Programming
01:44:07 <dankna> sclv: ah, thanks!
01:44:12 <mattam> wli: It doesn't preclude having design patterns in Haskell anyway does it ?
01:44:35 <sclv> haskell has patterns, but they're nothing like the GoF ones as far as I've seen.
01:44:43 <alexj_> http://blip.tv/file/427648  a talk I gave recently on the design motivation for haskell
01:44:45 <lambdabot> Title: Alex Jacobson on HAppS
01:45:11 <wli> If a design pattern should arise it should be taken as a problem for language designers to resolve.
01:45:27 <mattam> So Model-View-
01:45:35 <mattam> Controller should be "built-in" ?
01:45:39 <quicksilver> sclv: yeah, haskell has patterns like 'make the existential an instance of the class"
01:45:41 <wli> You don't want to repetitively do things like design patterns.
01:45:55 <Spark> nah
01:45:59 <quicksilver> sclv: although we like to call them 'idioms'
01:46:03 <quicksilver> sclv: cos then we feel superior :)
01:46:10 <Spark> if you compress every design pattern down to a language feature you end up with a massive language
01:46:13 <dankna> geesh, at least I've gotten far enough with haskell to understand what that pattern is, haha :)
01:46:22 <Spark> design patterns should exist, but should be concise and to-the-point
01:46:28 <wli> Spark: It has to be approached more intelligently than that.
01:46:30 <dankna> you also lose the flexibility to reinvent the pattern in future
01:47:02 <wli> Spark: If they're down to one-liners then you can obviously ignore them.
01:47:10 <sclv> quicksilver: I mean on the other hand, that's like 2/3 of the point of introducing existential types, right? So it's almost just a language feature more than even an idiom. It's like calling "make your collection an functor and then map over it" a pattern.
01:47:18 <ricky_clarkson> wli: A design pattern in Haskell is that of separating pure from side-effecting code.  I don't think that one needs to disappear like Visitor or Singleton do.
01:47:45 <sclv> singleton can be useful. :-(
01:47:51 <osfameron> GoF patterns are boring
01:47:58 <sclv> It's like the unsafeperformIO of the imperative-object world.
01:48:08 <osfameron> whereas A Pattern Language is the most beautiful book on town planning I could imagine
01:48:13 <ricky_clarkson> alexj_: That video appears to be of a wobbling slide with a shadow moving across it. ;)
01:48:18 <osfameron> (not that I generally imagine town planning to be beautiful)
01:48:47 <alexj_> ricky_clarkson:  it gets cleaner over time.  but the production values were really low.  it was recorded from the camera of someone's laptop.
01:49:08 <ricky_clarkson> Right you are.
01:49:19 <alexj_> I will be putting the PDF with the video somewhere tomorrow or so.
01:49:35 <alexj_> the pdf of the presentation.
01:50:48 <sclv> sometimes when enterprisey patternish stuff appears in haskell code (even toy examples) then it gives me the willies. like when someone has a constructor for Foo called mkFoo
01:52:50 <sclv> the other thing tho is that sometimes exposing imperative ppl. to patterns tends to give them a functional mindset, at least a little. like when they realize an object can encapsulate a behavior and not just a data structure.
01:54:09 <quicksilver> sclv: You can make a pedagogical case that having type + constructor with the same name is confusing
01:54:14 <krishnbhakt> any bindings for lighttpd and sqlite in haskell?
01:54:20 <quicksilver> sclv: that's one reason to use the 'mk' style
01:55:08 <dankna> krishnbhakt, definitely for sqlite, let me check for you which one I finally wound up using, although there are two plus some higher-level wrappers...
01:55:12 <dankna> no idea about lighthttpd
01:57:31 <krishnbhakt> ok
01:57:45 <sclv> didn't dons post a link to a very very basic http server here the other day?
01:58:12 <sclv> it was like 50 lines using the network libraries. for toy purposes that might suffice.
01:58:35 <krishnbhakt> can i have the link sclv?
01:59:07 <sclv> grr: can't find it. checking my history now.
01:59:26 <quicksilver> it's generally not the right answer to write your own HTTP server
01:59:31 <quicksilver> except, for fun
01:59:42 <quicksilver> a 'real' HTTP server has a considerable amount of complexity
01:59:49 <ricky_clarkson> And to find out why it's not the right answer.
01:59:52 <dankna> krishnbhakt: I used the one that winds up as Database.HDBC.Sqlite3.  I'm afraid I don't remember what that means in terms of where you download it from :)
01:59:57 <krishnbhakt> yes i need fastcgi support
02:00:01 <quicksilver> I would think that fastcgi is the answer for simple haskell stuff
02:00:09 <quicksilver> there is a network.fastcgi or something, somewhere
02:00:14 <carmen> good luck specifying HTTP in haskell, what with all the conflicting crap in the RFC..
02:00:31 <dankna> I also don't remember why I decided against the others.  But just in case that's a useful starting point for you.
02:00:31 <osfameron> why would that be worse in haskell than any other langugae?
02:00:44 <krishnbhakt> thanks
02:00:53 <dankna> Yeah, I have been using Network.FastCGI and it's quite nice.  It's on the package page with all the other stuff.
02:01:01 * roconnor once imagined making reference implemenations in haskell for all (relevent) RFCs
02:01:03 <raxas> http://software.complete.org/hdbc-sqlite3
02:01:04 <lambdabot> Title: HDBC Sqlite3 Driver
02:01:29 <roconnor> maybe doing it in Coq would make more sense. ... for some definition of sense
02:01:59 <ricky_clarkson> alexj_: "Building high-reliability things on hope just feels unpleasant to me".  Lovely.
02:03:02 <profmakx> hm. seems that my bootstrap of ghc-6.6.1 on x86_64-freebsd7 succeeded \o/
02:03:07 <Spark> even if something was proven correct, i'd still want to see it tested before i put my life in its hands
02:03:24 <Spark> "oops, we proved the wrong property"
02:03:25 <quicksilver> @quote knuth
02:03:25 <lambdabot> knuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
02:03:25 <lambdabot> might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
02:03:33 <quicksilver> @quote prove
02:03:34 <lambdabot> greentea says: it's actually been proved that there a situations in which we can't know whether a person's stupidity will ever terminate.
02:03:36 <quicksilver> @quote prove
02:03:37 <lambdabot> dons says: dons has quit ("improve @check")
02:03:41 <quicksilver> @quote knuth.*prove
02:03:42 <lambdabot> No quotes match. Where did you learn to type?
02:03:43 <quicksilver> bah
02:03:45 <quicksilver> :)
02:03:54 <roconnor> @quote stack-calculator
02:03:55 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
02:03:58 <dankna> @quote knuth.*proof
02:03:58 <lambdabot> No quotes match. You speak an infinite deal of nothing
02:04:20 <dankna> Oh dear, I have been chastised by a bot.
02:04:39 <roconnor> @vixen you're mean
02:04:39 <lambdabot> I am on the net too much. I should do a net anonymoouse group. online of course.
02:04:41 <krishnbhakt> heheheh
02:05:08 * Spark gazes forlornly at #haskell
02:05:25 <roconnor> @dict forlorn
02:05:25 <lambdabot> Supported dictionary-lookup commands:
02:05:25 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
02:05:25 <lambdabot> Use "dict-help [cmd...]" for more.
02:05:43 <roconnor> @wn forlorn
02:05:44 <lambdabot> *** "forlorn" wn "WordNet (r) 2.0"
02:05:45 <lambdabot> forlorn
02:05:45 <lambdabot>      adj 1: pitiable in circumstances especially through abandonment;
02:05:45 <lambdabot>             "desolate and despairing"; "left forlorn" [syn: {desolate},
02:05:45 <lambdabot>              {godforsaken}, {lorn}]
02:05:46 <lambdabot>      2: marked by or showing hopelessness; "the last forlorn
02:05:49 <lambdabot>         attempt"; "a forlorn cause"
02:07:23 <sclv> krish: you might also want to look at http://www.cs.chalmers.se/~d00nibro/hsp/
02:07:24 <lambdabot> Title: HSP - Haskell Server Pages
02:07:26 <quicksilver> @remember Spark "oops, we proved the wrong property"
02:07:26 <lambdabot> Done.
02:07:35 <quicksilver> Spark: struck me as amusing given your namesake...
02:07:42 <krishnbhakt> cool, thanks
02:08:06 <roconnor> @quote correct
02:08:07 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
02:08:19 <roconnor> @quote correct
02:08:19 <lambdabot> ghc says: parse error (possibly incorrect indentation)
02:08:24 <roconnor> :(
02:08:34 <roconnor> @quote proved
02:08:35 <lambdabot> Spark says: "oops, we proved the wrong property"
02:08:47 <krishnbhakt> stopped after 2005 ?
02:09:07 <sclv> doesn't handle posts either. :-(
02:09:26 <ricky_clarkson> Spark: Oops, we tested the wrong property.
02:09:42 <Spark> lucky we had the redundancy :)
02:09:49 <dankna> well, that's why unit tests aren't the only type you use...
02:10:07 <lokimaf> what would be a non finite form of Int?
02:10:26 <roconnor> @remember knuth Beware of bugs in the above code; I have only proved it correct, not tried it.
02:10:26 <lambdabot> Done.
02:10:28 <dankna> is this a philosophical question? O_o
02:10:29 <ricky_clarkson> Integer?
02:10:37 <lokimaf> kk
02:10:42 <lokimaf> .a'o
02:10:43 <lokimaf> hope
02:10:54 <roconnor> > maxBound (0::Int)
02:10:55 <lambdabot>   add an instance declaration for (Bounded (Int -> a))
02:10:55 <lambdabot>     In the expression:...
02:11:03 <roconnor> > maxBound::Int
02:11:04 <lambdabot>  2147483647
02:11:07 <roconnor> > maxBound::Integer
02:11:08 <lambdabot>   add an instance declaration for (Bounded Integer)
02:11:08 <lambdabot>     In the expression: ma...
02:11:11 <lokimaf> > 1 > 2^32
02:11:13 <lambdabot>  False
02:11:22 <lokimaf> > 1::Int > 2^32
02:11:22 <lambdabot>  Parse error
02:11:31 <lokimaf> > 1 > 2^32 :: Int
02:11:32 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
02:11:37 <ricky_clarkson> > (1::Int) > 2^32
02:11:38 <lambdabot>  True
02:11:46 <lokimaf> yep that was my problem
02:11:51 <lokimaf> or is
02:12:07 <lokimaf> > (1::Integer) > 2^32
02:12:08 <ricky_clarkson> Yes, that is was your problem, or will be has been.
02:12:08 <lambdabot>  False
02:12:58 <lokimaf> how do i convert Int -> Integer ?
02:13:21 <dankna> > fromIntegral (1::Int) > (2^32 :: Integer)
02:13:21 <quicksilver> fromIntegral
02:13:23 <lambdabot>  False
02:13:33 <ricky_clarkson> @hoogle Int -> Integer
02:13:33 <lambdabot> No matches, try a more general search
02:13:59 <ricky_clarkson> @type fromIntegral
02:14:01 <lambdabot> forall a b. (Num b, Integral a) => a -> b
02:14:20 <ricky_clarkson> Is there a reason hoogle can't do the more general search itself?
02:14:39 <dankna> you know, one area I haven't seen any of the tutorials discuss
02:14:49 <profmakx> should it search for a ->b?
02:14:56 <dankna> is practical tips for using ghci and hoogle to answer questions like that
02:15:01 <quicksilver> ricky_clarkson: no, not really
02:15:11 <quicksilver> ricky_clarkson: but it doesn't search instance possibilities
02:15:20 <quicksilver> ricky_clarkson: it would need a complete table of all the instances each type had
02:15:33 <quicksilver> I agree that would be a nice thing :)
02:15:35 <dankna> not that it's that hard to pick up on your own, but then, neither are the subjects of a lot of other tutorials.  in an alternate universe where I have an infinite amount of time and also know this stuff myself, I have written one.........
02:15:37 <ricky_clarkson> quicksilver: Isn't that the other way around though?
02:15:37 <quicksilver> but currently it doesn't do it
02:15:51 <ricky_clarkson> I mean, given Int, you can see that it's an instance of Num easily, or not?
02:16:04 <quicksilver> not unless you ahve a table of all the instances
02:16:06 <quicksilver> :)
02:16:13 <quicksilver> I mean yes, that is "easy"
02:16:17 <quicksilver> but it still requires all the data
02:16:31 <ricky_clarkson> If you have a Haskell runtime, is there a way of obtaining that data?
02:16:43 <quicksilver> types don't exist at runtime :P
02:16:52 <quicksilver> you can try compiling something and seeing if it works
02:17:01 <quicksilver> but hoogle actually works with a haddock hook
02:17:08 <ricky_clarkson> Heh.  First class types++
02:17:12 <quicksilver> so it's essentially a big database generated from the source
02:30:59 <wli> I missed the tail end of the design pattern discussion.
02:32:24 <quicksilver> wli: very little was said after your last comment
02:32:26 <lokimaf> Integer has a limit :(
02:32:32 <wli> Go figure.
02:32:35 <roconnor> wow, Knuth has an infrequenly asked questions page!
02:32:44 <lokimaf> 340282366920938463463374607431768211456 hex: 100000000000000000000000000000000
02:32:56 <quicksilver> lokimaf: no, it doesn't
02:33:07 <wli> RAM capacity, maybe.
02:33:10 <lokimaf> maybe i'm not doing it right then
02:33:12 <quicksilver> lokimaf: integer is only limited by your available memory
02:33:45 <lokimaf> showHex ((2^(fromIntegral numVariables))::Integer)
02:34:04 <quicksilver> :t showHex
02:34:06 <lambdabot> forall a. (Integral a) => a -> String -> String
02:34:13 <lokimaf> > showHex ((2^(fromIntegral 32))::Integer)
02:34:15 <lambdabot>  <[Char] -> [Char]>
02:34:24 <lokimaf> > showHex ((2^(fromIntegral 32::Int))::Integer)
02:34:26 <lambdabot>  <[Char] -> [Char]>
02:34:30 <Jaak> > showHex ((2^(fromIntegral 32))::Integer) ""
02:34:32 <lambdabot>  "100000000"
02:34:32 <lokimaf> > showHex ((2^(fromIntegral (32::Int)))::Integer)
02:34:33 <lambdabot>  <[Char] -> [Char]>
02:34:47 <lokimaf> hmmm
02:34:54 <Jaak> notice the type
02:35:01 <quicksilver> > showHex ((2^(fromIntegral 256))::Integer) ""
02:35:03 <lambdabot>  "10000000000000000000000000000000000000000000000000000000000000000"
02:35:08 <quicksilver> > showHex ((2^(fromIntegral 400))::Integer) ""
02:35:10 <lambdabot>  "100000000000000000000000000000000000000000000000000000000000000000000000000...
02:35:14 <lokimaf> > showHex ((2^(fromIntegral (32::Integer)))::Integer)
02:35:15 <lambdabot>  <[Char] -> [Char]>
02:35:17 <wli> Anyway, we've got monad transformer stacks for separating effects as an idiom. So the next step is moving to some sort of higher level of abstraction that makes commonly-occurring patterns there get blown away by language features.
02:35:19 <quicksilver> well lambdabot starts to cut chars off at that point
02:35:35 <quicksilver> but it's much bigger than what you claimed, at least
02:35:46 <dankna> certainly ideas on doing that are very much worth pursuing
02:36:05 <lokimaf> showHex ((2^(fromIntegral (read "400")))::Integer) ""
02:36:10 <dankna> I'm at a loss for how you're going to even know what commonly-occurring patterns are without first studying them, though :)
02:36:15 <osfameron> wli: I'm quite interested by the idea of encapsulating the MVC pattern (one of the truly useful patterns in GoF) in the language
02:36:17 <quicksilver> wli: I totally agree that many design patterns boil down to a kind of abstraction, and it can be worth asking the language to provide you with the right abstraction
02:36:18 <roconnor> lokimaf:  forgot the >
02:36:24 <lokimaf> > showHex ((2^(fromIntegral (read "400")))::Integer) ""
02:36:25 <lambdabot>  "100000000000000000000000000000000000000000000000000000000000000000000000000...
02:36:28 <roconnor> :)
02:36:29 <lokimaf> nice :D
02:36:33 <quicksilver> wli: but I don't agree that *all* design patterns boil down to *only* that
02:36:35 <lokimaf> thanks
02:36:42 <wli> dankna: Yes, they need to be studied empirically.
02:36:50 <wli> quicksilver: Which ones don't boil down to only that?
02:36:58 <quicksilver> MVC
02:37:02 <quicksilver> Flyweight
02:37:08 <wli> WHat the Hell is MVC?
02:37:11 <quicksilver> off the top of the head, I don't have the book here
02:37:16 <wli> Besides Microsoft Visual C
02:37:21 <quicksilver> Model View Controller
02:37:45 * osfameron likes http://blog.plover.com/2006/09/11/ "Patterns are signs of weakness in programming languages."
02:37:47 <lambdabot> Title: The Universe of Discourse : Design patterns of 1972
02:37:52 * roconnor wonders what the controller part of MVC is
02:37:58 <roconnor> am I the controller?
02:38:06 <dankna> "the business logic", supposedly
02:38:11 <roconnor> or rather a controller?
02:38:11 <wli> Not sure what flyweight is besides a sort of custom allocator.
02:38:34 <quicksilver> wli: a flyweight is a cache, basically
02:38:46 <quicksilver> like using a texture to store your fonts in openGL
02:38:51 <quicksilver> instead of rendering char by char
02:39:42 <quicksilver> observer, a.k.a. publish/subscribe is a useful one, too
02:39:57 <wli> I can't find anything on Model-View-Controller.
02:40:21 <dankna> http://en.wikipedia.org/wiki/Model-view-controller has, at the least, a nice list of links
02:40:22 <lambdabot> Title: Model-view-controller - Wikipedia, the free encyclopedia
02:41:21 <dankna> observer is often misused, of course... when the two ends of it really are tightly coupled but you try to force them to interact through nothing but that mechanism, it makes a lot of maintenance overhead
02:41:24 <wli> This language is all so foreign to me I can't really decipher much of it.
02:42:11 <dankna> well, I have to say that was my reaction when I read up on it, too, and I'm far from decided as to whether it describes something new or just something we would have been doing anyway
02:42:18 <kig> datastructure-UI-logic
02:42:22 <dankna> MVC, I mean, not design patterns in general
02:42:42 <wli> The observer description baffled me as well.
02:43:02 <dankna> that one at least does describe a real and clearly identifiable pattern
02:43:17 <quicksilver> MVC is a big unholy mess and there are quite different interpretations of it
02:43:31 <quicksilver> that's why I explicitly *didn't* suggest I wanted a web framework to be MVC
02:43:36 <dankna> I don't know if you're familiar with the Cocoa API at all, but it makes pervasive use of the observer pattern and might be a good (if large) example of it
02:43:36 <quicksilver> I just said 'separation of concerns'
02:43:47 <quicksilver> which to my mine is the key point
02:44:17 <dankna> mine as well
02:45:07 <raxas> osfameron: monad is a design pattern too. is it also a sign of weakness in programming language?
02:45:27 <dankna> ultimately, the purpose of *any* innovation in software development has to be to improve programmer productivity, which mostly means making maintenance simpler.  separation of concerns isn't quite synonymous with that but definitely supports it...
02:46:24 <osfameron> raxas: in every haskell program do you start off by rolling up another monad from scratch?
02:47:11 <osfameron> raxas: I think the thesis is that language features which are native and transparent are signs of strength in the language, whereas having to reimplement patterns yourself are the signs of weakness
02:47:39 <wli> raxas: It is a higher-level abstraction than most extant. Even higher levels of abstraction should be sought, though.
02:47:51 <osfameron> (hence the OO as design pattern example.  Once OO is part of the language it's no longer a "pattern" that 1972 C programmers have to roll up every time)
02:48:12 <dankna> (not that that stops them from doing it anyway...)
02:48:35 <quicksilver> although ironically good 1972 C programmers probably did a better job :P
02:48:41 <dankna> hah, agreed
02:49:18 <wli> I write C in such a manner that kernel programmers often despise.
02:49:39 <wli> Rigid ADT affairs. Total structure privacy. etc.
02:49:48 <dankna> well, I don't think that's irony at all, it illustrates the point that no amount of language support will ever obviate the need to understand these patterns before using them
02:50:17 <quicksilver> it's ironic if all the effort which went into building language support for OO
02:50:22 <wli> Well, when they arise, you want to devise abstractions to absorb them.
02:50:28 <quicksilver> has actualy made things harder because what they implemented is too restrictive :)
02:50:30 <dankna> wli: well, congratulations; amusement.
02:51:05 <wli> dankna: For what?
02:51:20 <quicksilver> good example is Java's "every time you want to define a new type, it has to be a class, which has to be a whole new file"
02:51:23 <dankna> doing things the right way despite the disapproval
02:51:32 <quicksilver> that really pushes up the activation energy to defining a new type
02:51:38 <quicksilver> so you only do it for 'really important stuff'
02:51:45 <quicksilver> and end up just using ints and so on for less important stuff
02:51:52 * roconnor feels the same way about GHC's modules
02:52:00 <quicksilver> and so you sacrifice the type safety that your language supposedly had
02:52:07 <dankna> well, I don't think anyone here would proselytize the way Java does things, so that's a bit of a strawman...
02:52:07 <quicksilver> roconnor: so do I, but it doesn't bother me as much
02:52:19 <quicksilver> dankna: it was only an example :)
02:52:22 <ricky_clarkson> quicksilver: Though you don't actually need a new file for a new class in Java.
02:52:24 <dankna> hah, okay then
02:52:38 <quicksilver> ricky_clarkson: right. the more recent stuff helps with anonymous classes and stuff
02:52:51 <quicksilver> ricky_clarkson: and the shortcuts for enum types in java 5, and so on
02:53:03 <ricky_clarkson> Recent, since 1997.
02:53:15 <quicksilver> ricky_clarkson: indeed. I learnt java in 1995.
02:53:16 <ricky_clarkson> quicksilver: You may have more than one top-level class in a file, but only one of those may be public.
02:53:17 <dankna> yeah, you just need to remember what that godforsaken syntax for an inner class is...  arbitrary syntax designed with back-compatibility as its only real goal tends to annoy me... heh.  but it's a step in the right direction anyhow.
02:53:19 <quicksilver> ricky_clarkson: I am slow to forgive.
02:53:35 <ivanm> if I want to declare a subset of Int in such a way that its restricted to only 8 elements, what do I do? declare it an instance of Bounded ?
02:53:44 <quicksilver> ivanm: don't
02:53:48 <quicksilver> ivanm: make it an ADT
02:54:03 <quicksilver> data Foo = One | Two | Three | Four | Five ...
02:54:10 <ivanm> quicksilver: I was originally going to, but I'd want to do things like pred, succ, etc.
02:54:14 <ricky_clarkson> dankna: You mean an anonymous class, most likely, and when there's only one method, I agree with you.
02:54:20 <quicksilver> ivanm: then make your ADT an instance of Enum
02:54:24 <dankna> yes, I'm sure that's what I mean
02:54:30 <quicksilver> ivanm: 'deriving Enum' should be enough
02:55:01 <ivanm> quicksilver: would it loop though? my thinking was if I had it as bounded Int, I could then have wrapper methods that would call mod 8, etc.
02:55:04 <osfameron> why not make it Bounded? That would seem less of a kludge (and less annoying if there are many more than 8 elements...)
02:55:23 <ivanm> it's going to be for compass directions... N, NE, E, etc.
02:55:28 <quicksilver> anyhow, the java point was just an example of how well-intentions but badly implemented language support can really hold the programmer back.
02:55:36 <wli> ivanm: There are ways to do that by limiting constructors.
02:55:44 <quicksilver> osfameron, ivanm: making it Bounded is a good idea, but it doesn't do what you think it does :P
02:55:48 <ivanm> wli: how do you limit a constructor?
02:55:54 <ivanm> quicksilver: why not?
02:55:54 <quicksilver> Bounded isn't an enforcing instance.
02:55:57 <dankna> qs: yeah... well, absolutely true.
02:56:05 <ivanm> quicksilver: what does it do then?
02:56:17 <quicksilver> it just provides 'minBound' and 'maxBound'
02:56:18 <quicksilver> that's all
02:56:18 <wli> ivanm: Only export functions to construct it that honor your invariants.
02:56:25 <quicksilver> doesn't change 'succ' or 'pred'
02:56:28 <quicksilver> or enforce anything much
02:56:30 <Mr_Awesome> is there any indexing function for lists that returns Maybe a instead of returning an error like (!!) ?
02:56:52 <wli> ivanm: If you had, say, 360 compass points you're not going to do data Foo = A | B | C | ...
02:56:52 <quicksilver> inc x | x == maxBound = x
02:56:53 <quicksilver>       | otherwise     = toEnum.(+1).fromEnum $ x
02:56:53 <qassam> dmwit still around?
02:57:03 <quicksilver> ivanm: I have used 'inc' above, and 'dec' similarly
02:57:16 <quicksilver> ivanm: they work on ADTs which derive Bounded and Enum
02:57:18 <ivanm> wli: yes, that was my plan... and it was only going to be N, NE, E, SE, S, SW, W, and NW
02:57:36 <ivanm> quicksilver: *nod* OK, thanks
02:57:38 <quicksilver> ivanm: of course you can define the wrap-around version instead of the clamping version
02:57:45 <quicksilver> ivanm: I wanted clamping because this was a menu system
02:57:58 <ivanm> *nod* ... so would Bounded make sense then?
02:58:25 <ivanm> it's not really necessary, just to make it "look" more proper
02:58:31 <quicksilver> I would argue that Bounded doesn't make 'sense' really
02:58:39 <quicksilver> because a circular data type isn't really bounded :)
02:58:45 <ivanm> heh, true
02:58:48 <quicksilver> however it is useful to help you write "inc"
02:58:53 <ivanm> *nod*
02:59:00 <quicksilver> you could make an argument for a Bounded instance but not exporting the instance
02:59:05 <quicksilver> (is that even possible?)
02:59:18 <ivanm> well, the constructor, etc. was going to be exported anyway
02:59:22 <dankna> (no, I don't believe so)
02:59:23 <raxas> Enum looks just innocent, until it twists poor coder's brain with enumFromThenTo
02:59:37 <quicksilver> yes :)
02:59:43 <quicksilver> would be fun writing that
02:59:56 <quicksilver> I guess you'd use clockwise by default for enumFromTo
03:00:07 <quicksilver> and anti-clockwise if a 'negative' first one was chosen
03:00:17 <ricky_clarkson> I dislike walking without a target because I think recursively.  Each step needs to result in a smaller problem left to solve.
03:00:27 * ricky_clarkson cdrs up the stairs.
03:00:47 <ivanm> well, I was originally going to make it an ADT, then thought rather than converting it to/from ints all the time with toEnum/fromEnum just use Int directly, but bound it
03:01:29 <quicksilver> Mr_Awesome: no, although it is often requested
03:01:38 <quicksilver> Mr_Awesome: sometimes people suggest the name 'safeIndex' for it
03:01:39 <wli> You can get the advantages of Ints without losing invariants.
03:01:50 <quicksilver> Mr_Awesome: I think there is one somewhere in some library ndm wrote :)
03:02:04 <Mr_Awesome> quicksilver: which library?
03:02:30 <quicksilver> @where safe
03:02:31 <lambdabot> I know nothing about safe.
03:02:44 <ivanm> I don't suppose there's a way of making Enums wrap directly, without having to create inc/dec functions?
03:02:45 <quicksilver> @where+ safe http://www.cs.york.ac.uk/fp/haddock/safe/Safe.html
03:02:45 <lambdabot> Done.
03:02:50 <quicksilver> ivanm: I don't think so
03:02:54 <ivanm> :(
03:03:06 <quicksilver> Mr_Awesome: there you do. youre function is called 'atMay'
03:03:28 <quicksilver> I note that if you wanted to write it yourself, the easiest way woudl be with 'drop'
03:03:31 <ivanm> quicksilver: apart from creating custom toEnum, fromEnum methods I suppose, or something like that?
03:03:46 <quicksilver> ivanm: well custom succ and pred
03:03:52 <ivanm> yeah
03:03:58 <Mr_Awesome> quicksilver: thanks
03:04:06 <ivanm> @doc Enum
03:04:06 <lambdabot> Enum not available
03:04:12 <ivanm> @index Enum
03:04:12 <lambdabot> Prelude
03:04:18 <ivanm> duh
03:04:47 <quicksilver> in fact, it's listToMaybe . drop n
03:05:17 <quicksilver> > let safeAt l n = listToMaybe . drop n $ l in safeAt [4,5,6] 1
03:05:19 <lambdabot>  Just 5
03:05:22 <quicksilver> > let safeAt l n = listToMaybe . drop n $ l in safeAt [4,5,6] 3
03:05:23 <lambdabot>  Nothing
03:08:24 <ivanm> looks like it'll be easier to construct custom subtraction, addition functions (since I"d also want to do things like go back two directions, etc.)
03:09:03 <quicksilver> I think you'll need some custom functions, yes
03:09:15 <quicksilver> dealing with circular numbers isn't always obvious
03:09:31 <quicksilver> I remember talking to matthew_- about how to 'sort' three great circles
03:09:54 <ricky_clarkson> Why is someone looking at circular numbers?
03:09:58 <ricky_clarkson> ..for what use?
03:10:07 <quicksilver> maybe that means something else?
03:10:15 <dankna> sort points on them, or sort the circles themselves?  it seems like one of those questions where if you had a reason to actually do it, your problem domain would have to provide the answer...
03:10:18 <quicksilver> he's doing compass points
03:10:29 <quicksilver> dankna: the circles themselves
03:10:29 <ivanm> ricky_clarkson: compass orientations... basically operations mod 8
03:11:10 <ricky_clarkson> ivanm: When I've done stuff like that I've just let it grow greater than 8, but I can see how that's a little error-prone.
03:11:17 <ricky_clarkson> ..greater than 7
03:11:27 <ivanm> heh
03:15:24 <ivanm> is there a zipper library for lists included with ghc 6.6.1?
03:15:31 <ivanm> or is there a zipper library for lists at all?
03:18:33 <raxas> ricky_clarkson: blending a terrain tile by neighbours based on compass directions loop is a good example of some advanced circular operation
03:19:24 <qassam> hey guys Im trying to do a histogram for a list without the use of any library functions
03:19:25 <ricky_clarkson> Sounds fun.
03:19:34 <ivanm> @where zipper
03:19:34 <lambdabot> I know nothing about zipper.
03:20:52 <quicksilver> @go huet-zipper
03:20:54 <lambdabot> http://www.eecs.harvard.edu/~nr/pubs/zipcfg-abstract.html
03:20:54 <lambdabot> Title: An Applicative Control-Flow Graph Based on Huet's Zipper (Abstract)
03:21:01 <quicksilver> no, that's not the one :P
03:21:24 <ivanm> would a zipper be the best possible data structure to use if I wanted to keep a track of the path something travels to be able to reverse it later?
03:21:31 <ivanm> heh
03:21:37 <quicksilver> that sounds like what they're for
03:21:52 <quicksilver> depending what you mean by 'path'
03:22:00 <qassam> no ideas about histograms? :/
03:22:15 <ivanm> quicksilver: an ant is travelling in a 2D array, and recording the (x,y) indexes it travels on
03:22:19 <quicksilver> the reason their isn't a zipper library AIUI is that in general you need to write them for each application
03:22:26 <ivanm> hmmmmm :(
03:22:38 <roconnor> lack of dependent types
03:22:42 <osfameron> quicksilver: is that a pattern and therefore a weakness in haskell? ;-)
03:22:49 <roconnor> osfameron: exactly!
03:22:53 <quicksilver> osfameron: yes :)
03:23:18 <quicksilver> ivanm: is it modifying the array as it goes?
03:23:29 <quicksilver> ivanm: to be honest that doesn't sound much like a zipper to me
03:23:44 <quicksilver> a zipper is about a path through a data structure more than a path in space
03:23:47 <ivanm> quicksilver: through STM, yes... but each ant needs to record where its been to be able to reverse its path later on
03:23:58 <quicksilver> it supports constant-time editing of functional structures
03:24:04 <ivanm> and I figured if I used a zipper, it could go back and forth without having to reverse the lsit
03:24:08 <ivanm> *list
03:24:10 <quicksilver> by always making local changes
03:24:26 <quicksilver> that just sounds like a stack to me?
03:24:40 <quicksilver> just use your list in reverse
03:24:45 <quicksilver> and you won't have to reverse it :P
03:24:47 <ivanm> well, I was hoping to avoid that :s
03:24:55 <quicksilver> why? why is that something to be avoided?
03:25:04 <quicksilver> isn't that the correct data structure for what you're doing?
03:25:15 <ivanm> isn't reverse an O(n^2) op?
03:25:36 <ivanm> and if I have a whole heap of ants running concurrently, I was worried that it'd slow it down at some point :s
03:25:37 <ttfh> do you need to reverse the list?
03:25:43 <quicksilver> you don't need to reverse it though!
03:25:47 <osfameron> can you use a zipper in a balanced binary tree?  So that the balancing operations are suspended but get carried out when the zipper moves back up the tree?
03:25:53 <quicksilver> you're always appending to the top
03:25:59 <quicksilver> osfameron: yes
03:26:01 <ivanm> quicksilver: they have to be able to backtrack
03:26:08 <quicksilver> and then when you go back you unwind
03:26:12 <quicksilver> still O(1)
03:26:14 <dankna> so it's a stack
03:26:21 <quicksilver> lists have O(1) push and O(1) pop, you know?
03:26:41 <quicksilver> l goes to  x:l  is O(1) push
03:26:48 <quicksilver> x:l goes to l is O(1) pop
03:26:59 <quicksilver> just have the 'recent' part of the path at the 'head' of the list
03:27:16 <osfameron> quicksilver: cute, something else to play with in cft
03:27:25 <quicksilver> (btw, reverse is O(n), not O(n^2))
03:27:33 <ivanm> duh, wasn't thinking :s
03:27:36 <ivanm> forget that
03:27:43 <quicksilver> osfameron: I'm not saying it's easy, though :)
03:27:56 <quicksilver> osfameron: but that's a zipper with a more complex that usual 'Up' operator
03:28:10 <quicksilver> osfameron: a "plain" zipper, 'Up' is a kind of O(1) 'unfold'
03:28:28 <quicksilver> osfameron: on a rebalnacing tree zipper, 'Up' would be a "locally O(log n)" rebalance
03:28:33 <quicksilver> osfameron: I imagine
03:28:44 <ivanm> now I remember what I was getting confused with... I was thinking of loop-removal but continously performing a "takeWhile (\ pos -> pos /= currentPos) " from the starting point, which would be at the end of the list
03:29:01 <quicksilver> anyhow, if you do need to access a list from both ends, just use Data.Sequence
03:29:05 <ivanm> but that would be rather expensive if performed at every timestep, especially if no loops arise
03:29:07 <quicksilver> (although it's not clear that you do in this case)
03:29:13 <ivanm> yeah, I don't
03:29:17 <ivanm> just got confused :s
03:29:20 <ivanm> thanks quicksilver++
03:29:23 <quicksilver> :)
03:29:35 <raxas> is there some plan to invent double end queue by haskellers in future? or steal the idea from c++ standard libraries at least...
03:30:45 <quicksilver> raxas: Data.Sequence
03:30:55 <quicksilver> raxas: it's much faster than most double end queues
03:31:12 <osfameron> quicksilver: I already had a play with it (for my red-black tree implementation in Perl.  It didn't work for toffee, but I put it down to my ignorance, so I'm pleased if it's known to be possible...)
03:31:13 <integral> sadly, Data.Sequence doesn't expose all the capabilities of the finger trees it uses
03:31:15 <quicksilver> in the sense that it supports many more fast operations that just the two ends
03:31:57 <raxas> quicksilver: ah, that's what I seek, thanks
03:32:16 <quicksilver> raxas: it does fast indexing and fast append, as well
03:32:28 <quicksilver> raxas: and indeed 'fast subsequence delete/insert'
03:32:40 <quicksilver> it's pretty close to an all-purpose sequence structure
03:34:16 <ivanm> I hope I'm not annoying the lot of you tonight... but if I want a random element from a list, I'd have to find the length of the list first and then generate a random index, wouldn't I?
03:34:26 <osfameron> no!
03:34:32 * ivanm has already made one stupid conceptual mistake in the past 5 minutes, and doesn't want to do so again
03:34:38 <ivanm> see? I obviously just did!
03:34:44 <ivanm> osfameron: so what would I do instead then?
03:34:50 <osfameron> ivanm: http://osfameron.vox.com/library/post/random-pain-in-haskell.html
03:34:56 <quicksilver> integral: odd, I thought that was a factored out Data.FingerTree but it seems I remembered wrong
03:35:09 <osfameron> ivanm: that said, you certainly *can* just get the length and generate a random index too.
03:35:24 <osfameron> I just like that algorithm
03:35:31 * integral should get his perl finger tree to CPAN :)
03:36:00 <ivanm> osfameron: heh... I'd already have seeds (since this function would be called from an STM block!)
03:36:01 <osfameron> integral: yes please!
03:36:21 <yitz> qassam: why do you not want to use library functions?
03:36:44 <qassam> cuz my prof is psycho :)
03:36:55 <ivanm> heh
03:37:04 <qassam> had us use the same shit in c
03:37:14 <yitz> ivanm: I like your method better. Generating a new random number for each element of the list is more expensive than just counting  it
03:37:16 <qassam> no fopen! must use open!
03:37:36 <qassam> so would you guys have any ideas? I just want to make one for a list of 10 elements
03:37:41 <ricky_clarkson> osfameron: I like that algorithm because it took me more than 10 seconds to understand.
03:37:47 <ivanm> osfameron: hmmm... I did a similar thing once when my computation was that expensive I didn't want to generate all list elements just to get a random element... but I generated random probabilities at each step, rather than 1/2, 1/3, etc.
03:37:49 <yitz> how about the prelude? is that ok? this sounds silly.
03:38:14 <yitz> Just look at the source of Data.Map and copy it :)
03:38:18 <ricky_clarkson> ivanm: That biases the first elements.
03:38:18 <qassam> I can use either hugs or ghci but it has to compile
03:38:26 <integral> I liked the idea on haskell-cafe of having two preludes, the student one having the same functions but at stricter types
03:38:40 <ivanm> ricky_clarkson: I know.. as it was, the underlying computation was that expensive I ended up just calling head instead! :p
03:38:44 <ricky_clarkson> Haha.
03:38:48 <raxas> ivanm: you can use _some_ random index and cycle the list, then do not need the length
03:38:51 <ivanm> osfameron: do you have any proof that really generates a random element? just wondering what your motivation was for using 1/2, 1/3, etc
03:38:59 <ivanm> raxas: *nod*
03:39:22 <ricky_clarkson> ivanm: Not knowing the length of the list in advance, you can only assume it has as many elements as you've seen thus far.
03:39:23 <osfameron> ivanm: I walked through a short list in my head and it makes sense.  The post links to some source that contains a proof though.
03:39:36 <ivanm> *nod*
03:39:42 <ricky_clarkson> ivanm: If you've seen 4 elements, then there should be a 1/4 chance that you pick the last one.
03:39:49 <osfameron> yitz: that's a good point, I haven't benchmarked, as this is mainly for interest rather than production optimization.
03:39:51 <ivanm> OK, as long as it wasn't a random (pun intentional) fever-dream you had :p
03:40:13 <quicksilver> yeah, as someone points out that algortihm is likely to be very expensive
03:40:17 <quicksilver> but it's very nive :)
03:40:24 <ivanm> nice, or naive? :p
03:40:26 <qassam> ivanm, is there no other way of doing it? with a recursive function perhaps?
03:40:28 <sjanssen> qassam: which part are you having trouble with?
03:40:31 <ricky_clarkson> osfameron: Blog software is really crap at handling comments.
03:40:36 <ivanm> qassam: wouldn't have a clue :p
03:40:47 <quicksilver> it's only an optimisation if cost of random number generation is much higher than the cost of stepping down the list
03:40:59 <quicksilver> lower, I mean ;)
03:41:04 <quicksilver> which is unusual in practice I think
03:41:16 <qassam> sjanssen, I just got a list of 16 digits and buidling a histogram with it - I have a recursive function to go through the list but I cant implement a counter
03:41:21 <osfameron> ricky_clarkson: yeah, odd that Vox doesn't do it better, it's not as if Movable Type haven't got experience in making blog software...
03:42:03 <ivanm> quicksilver: what about if you don't generate a new seed each time? would that make much of a difference?
03:42:08 <quicksilver> qassam: you need to keep passing the 'totals so far' along your recursion
03:42:13 <integral> Vox's pages are insanely wide and graphics heavy for me :-(
03:42:28 <fasta> getBounds for Data.Array.ST is O(1), right?
03:42:51 <sjanssen> fasta: yes, they're cached in the constructor
03:42:58 <qassam> quicksilver, I got that part - but Im so new to haskell I dont know where to begin
03:43:04 <yitz> qassam: foldl' updateHistogram [] xs
03:43:32 <quicksilver> ivanm: yes, it would. But still stepping down the list is just an indirect load
03:43:45 <yitz> updateHistogram can just be a linear search and replace in your case, I think.
03:44:05 <yitz> oops, foldl' is in Data.List. drat!
03:44:08 <qassam> yitz, foldl is a lib function :P
03:44:10 <ivanm> hmmmmm..... so osfameron's is conceptually nicer, but probably more computationally expensive than the naive implementation?
03:44:18 <quicksilver> yup
03:44:19 <yitz> so just use foldl or foldr, those are in the prelude
03:44:25 <ivanm> yitz: a lot of functions in the libs are also in the prelude...
03:45:12 <qassam> with no use whatsoever---
03:45:12 <qassam> unless explicitly authorized---of any Haskell library functions.  In
03:45:12 <qassam> particular, this assignment must be done with lists and recursion: no arrays
03:45:12 <qassam> and no indexing operators, i.e., no emulated arrays, are allowed.
03:45:35 <yitz> but folds are very idiomatic to haskell, i
03:45:41 <yitz> m sure that's ok
03:45:44 <quicksilver> qassam: many of us here could write the code for you. But in general, we're not going to 'just do your homework for you'
03:45:48 <quicksilver> yitz: I'm sure it isn't
03:46:01 <quicksilver> qassam: the right approach is to 'start' , try something
03:46:11 <quicksilver> qassam: then ask for help with the bits you don't understand
03:46:11 <qassam> already started
03:46:26 <pastorn-rr> Control.Parallel.Strategies <-- what's that?
03:46:26 <qassam> have a function going through the list - just cant get a counter to work
03:46:29 <quicksilver> yitz: I'm sure it's intended as an exercise in explicit recursion :)
03:46:37 <pastorn-rr> multi-core-stuff?
03:46:53 <yitz> so write it in Lisp
03:46:59 <ivanm> osfameron: sorry, but looks like I won't be using your _very_ nice function (especially since I don't like the IO requirement throughout)
03:47:00 <quicksilver> qassam: well what are you doing with the counter at the moment? and in what way is it not wokring?
03:47:09 <ivanm> s/especially since/also
03:49:34 <osfameron> ivanm: heh, fair enough, I was mainly answering the "I'd have to" question with an alternative :-)
03:50:09 <quicksilver> osfameron: do you know how to remove the IO from your code, btw?
03:50:13 <ricky_clarkson> osfameron: Why does yours need IO?
03:50:27 <quicksilver> osfameron: and I certainly don't mean with unsafePerformIO ;)
03:50:30 <osfameron> not a clue
03:50:40 <quicksilver> :t randomR
03:50:40 <qassam> quicksilver, I got a function like f (x:xs) = x + f xs going through the list - but no idea how to add an incrementer
03:50:42 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
03:50:58 <quicksilver> osfameron: use that version, and supply the Gen explicitly
03:51:02 <quicksilver> (as a parameter to 'pick')
03:51:03 <osfameron> I mean, for the duration of a do block, yeah
03:51:15 <quicksilver> then thread it through
03:51:36 <quicksilver> qassam: you will need another parameter to store the incrementer in
03:51:42 <osfameron> but the Gen will be an IO object won't it?
03:51:48 <quicksilver> osfameron: no
03:51:57 <quicksilver> osfameron: haskell has pure random gens
03:52:11 <osfameron> how?
03:52:12 <quicksilver> sure you can *choose* to pass in a random gen that you plucked out of IO, if you want to
03:52:15 <quicksilver> but you don't have to
03:52:31 <quicksilver> > randomR (1,10) (mkStdGen 17)
03:52:31 <osfameron> oh, right, I could hard code a seed if I wanted to
03:52:32 <lambdabot>  (2,720252 40692)
03:52:38 <qassam> quicksilver, yes, but the question is would i need a parameter for each digit since Im making a histogram?
03:52:44 <Cale> osfameron: A StdGen just stores the state of the pseudorandom generator
03:52:51 <quicksilver> osfameron: that's not what I mean, though
03:52:56 <osfameron> which makes the underlying functions simpler as they remain pure ?
03:52:59 <quicksilver> osfameron: the 'pick' should take the gen as a paramter
03:53:05 <wli> If I'm going to do some sort of standalone blog thing I'll have to figure out how to deal with some database lib.
03:53:10 <quicksilver> osfameron: wheteher or not the seed is hard-coded is left up to the calling code
03:53:28 <quicksilver> osfameron: teh calling code can use 'mkStdGen' and hard-code a seed, or it can get a seed from somewhere else, lie IO
03:53:43 <quicksilver> qassam: you could yes, although that would look quite ugly
03:53:45 <osfameron> quicksilver: ok, I did read about gens in the manual page I read, and at the time it seemed more straightforward to use getStdRandom
03:53:50 <sjanssen> qassam: the best solution won't need a value for each digit
03:53:52 <quicksilver> qassam: you could also store all the things in a list
03:53:54 <dankna> wli: Consider sqlite as a back-end.  As far as front-ends I can't really help as I don't know your tastes.
03:54:11 <sjanssen> s/value/parameter
03:54:13 <wli> dankna: Anything I can figure out how to use.
03:54:23 <raxas> some platforms like via itx chipsets implement hw random generator. it is visible through kernel by /dev/random and /dev/urandom
03:54:24 <quicksilver> osfameron: I generally find it's more straightforward to use mkStdGen :)
03:54:37 <wli> dankna: I don't care about the back-end, only being able to figure out how to use the access lib.
03:54:38 <raxas> so I prefer to read that instead
03:54:57 * ivanm uses newStdGen
03:54:59 <osfameron> quicksilver: yeah, looks like it would have been.
03:55:24 <dankna> well, HAppS has some sort of object-relational mapping thing.  I haven't looked into it much because it's several times more complicated than what I need...
03:55:29 <osfameron> :t mkStdGen
03:55:31 <lambdabot> Int -> StdGen
03:55:40 <osfameron> oh... not IO StdGen ?
03:56:10 <dankna> do you want something where you write SQL directly, or do you want to hide it?  that's the biggest decision...
03:56:14 <qassam> quicksilver, sjanssen, I know I could store the stuff in a list - but how would I increment only one digit at a time? I tried using something like addHead (x:xs) = (x+1) : xs
03:56:18 <quicksilver> dankna: hAppS's preferred method is just to persist your haskell data without using SQL isn't it?
03:56:35 <quicksilver> dankna: although it has a kind of SQL emulator too I think
03:56:42 <dankna> qs: something like that, but as I said, I could tell it wasn't what I was looking for so I don't really know :)
03:56:46 <quicksilver> qassam: that's right. That adds something to the head of a list
03:57:11 <quicksilver> qassam: you can write something similar to increment the 'nth' place in a list
03:57:41 <qassam> quicksilver, thats where I would be "stuck"
03:57:59 <quicksilver> ah, well that sounds like a good exercise to do first, then :)
03:58:08 <quicksilver> qassam: can you think how you'd increment the 2nd element of a list?
03:58:59 <wli> dankna: I don't get along well with SQL. Hiding it would help.
04:00:10 <qassam> quicksilver, I tried some recursive functions to do it - but I always change the head instead of 2d or thinrd - unless I make the second one the head and then count it
04:00:13 <ndm> @seen TomMD
04:00:13 <lambdabot> TomMD is in #ghc, #xmonad and #haskell. I last heard TomMD speak 12h 34m 18s ago.
04:00:16 <fasta> castUArray (UA l u vec :: UArray i e)  ::  UArray i e' =
04:00:16 <fasta>     (UA l u' (castUnboxed vec))
04:00:16 <fasta>         where u' = toEnum (fromEnum l - 1 + newSize)
04:00:16 <fasta>               newSize = rangeSize (l,u)   *   sizeOfUnboxed (undefined::e)
04:00:16 <fasta>                                         `div` sizeOfUnboxed (undefined::e')
04:00:24 <fasta> What's the modern way to write this?
04:00:27 <wli> dankna: The less resemblance to SQL the better, actually.
04:00:45 <quicksilver> wli: i"m not really sure you want SQL at all
04:00:46 <ndm> @tell TomMD it's not hidden away, but its not stable enough or reliable enough for general use - once it is, i'll let people play with it
04:00:46 <lambdabot> Consider it noted.
04:01:00 <quicksilver> wli: for something as "simple" as blog posts
04:01:03 <fasta> This is from Bulat's arrayref library, but it's saturated with these annotations.
04:01:13 <fasta> (which are not valid in 6.9 anymore)
04:01:24 <quicksilver> wli: maybe you should look at hAppS's style
04:01:28 <vali> are there any examples of a neural network using the backpropagation algorithm anywhere?
04:01:50 <wli> quicksilver: Mostly the storage driver that knows how to avoid losing data is important.
04:02:02 <dankna> yeah, I was just looking through the hackage list to refresh my memory, and I'm pretty sure HAppS is the only thing that's really suitable
04:02:09 <quicksilver> wli: yeah hAppS knows how to do that
04:02:35 <sjanssen> fasta: give a top level type signature with 'forall' and use the scoped tyvars option
04:02:49 <ivanm> ndm: with your supero optimizor... any idea how much optimization arises from the use of church encoding alone?
04:03:04 <dankna> there are things that can serialize Haskell values to xml or to binary files, but the former is not going to perform adequately and the latter leaves you to solve most of the hard parts yourself.
04:03:07 <ndm> ivanm: i don't do church encoding in my newest optimiser
04:03:13 <wli> But I don't want the baggage that goes with it. I just want a normal CGI app that I don't have to tear the system config to shreds for.
04:03:19 <ivanm> ndm: oh, not worth the effort?
04:03:35 <fasta> sjanssen: is it legal to place the signatures there?
04:03:40 <fasta> sjanssen: that is in arguments?
04:03:41 <quicksilver> dankna: hAppS uses things like that
04:03:43 <ndm> ivanm: its simpler not to do it
04:03:43 <dankna> yes, it would certainly be nice if that existed, wouldn't it.  tell me if you find one.  heh.
04:03:47 <sjanssen> fasta: I can't remember
04:03:54 <quicksilver> dankna: and I don't believe that it finds it terribly hard
04:03:59 <dankna> hm
04:04:04 <quicksilver> dankna: it contains deriving recipes which work for most types
04:04:06 <ivanm> ndm: *nod*... just found your slides on it whilst looking up church encoding, and thought it looked cool
04:04:10 <dankna> well, I can't comment without having really studied it, obviously
04:04:11 <sjanssen> fasta: perhaps you just need to turn an extension on?
04:04:15 <dankna> but if it does that, great, I'm impressed
04:04:20 <ndm> ivanm: just the way the algorithm worked out - the Reduceron uses church encoding, which gives it a benefit
04:04:32 <fasta> sjanssen: fglasgow-exts is already on
04:05:00 <sjanssen> fasta: how does compilation fail?
04:05:01 <fasta> sjanssen: ( UA l u vec :: UArray i e)  ::  UArray i e' this also seem really weird code
04:05:12 <fasta> sjanssen: error in pattern
04:05:35 <fasta> sjanssen: hmm, well maybe it isn't
04:05:48 <fasta> sjanssen: it basically forces that e and e' are the same.
04:05:49 * ivanm just got a bug in ghci :o
04:06:34 <sjanssen> fasta: no, it's saying that the result of castUArray x has that type
04:07:12 <fasta> sjanssen: ok
04:07:15 <sjanssen> fasta: you can refactor all of those into top level type decls
04:07:52 <sjanssen> castUArray :: forall e e'. UArray i e -> UArray i e'
04:08:05 <sjanssen> probably with some class contexts too
04:08:42 <fasta> sjanssen: ok, I got it
04:14:37 <fasta> Ok, ArrayRef-1.0 is no longer broken :)
04:14:59 <fasta> Er 0.1
04:17:49 <fasta> dist/build/tmp/./Control/Concurrent/LockingBZ.hs:"Control/Concurrent/LockingBZ.hs": 111:1: parse error in doc string: [TokIdent [lock],TokString " as operation of class ",TokIdent [Locking,Locking]
04:18:08 <fasta> I never used Haddock before. Does this ring any bells?
04:19:26 <qassam> quicksilver, so can you help me access the nth item?
04:19:38 <quicksilver> qassam: yes
04:19:47 <quicksilver> qassam: you know how to access the first item
04:19:53 <quicksilver> qassam: how would you access the second?
04:21:11 <doserj> fasta: how does the comment look like?
04:21:41 <qassam> I was thinking of going through the head first, once counted i can remove the head and the second item can become the head, so on until the end
04:22:07 <hpaste>  (anonymous) pasted "this is what it looks like" at http://hpaste.org/3321
04:22:15 <fasta> doserj: ^^
04:22:47 <quicksilver> qassam: hmm I think you're trying to do too many things at once
04:22:59 <doserj> and which is line 111?
04:23:04 <quicksilver> qassam: acutlaly maybe I misunderstood you
04:23:09 <quicksilver> qassam: yes, that's the idea
04:23:23 <quicksilver> qassam: so let's call the function "getNth"
04:23:29 <doserj> ah, Hugs/GHC is the error
04:23:35 <quicksilver> qassam: so getNth 0 (x:xs) is x, right?
04:23:44 <qassam> quicksilver, I think I got the idea right and I have an add head function to add to the head when Im done - but I cant put it all together
04:23:45 <doserj> "/" turns on italic, so you have to escape the /
04:23:54 <doserj> Hugs\/GHC
04:23:58 <fasta> doserj: -- | Type constructor that attaches lock to immutable value @h@
04:24:08 <quicksilver> qassam: well you need to be able to add to other elements too
04:24:10 <fasta> doserj: that's almost immediately after it
04:24:11 <quicksilver> qassam: not just the head
04:24:16 <qassam> quicksilver, getNth is a function youre defining now?
04:24:23 <quicksilver> qassam: yeah, I was an example
04:24:29 <fasta> doserj: I pasted the other text because that included the text in the error message.
04:24:30 <quicksilver> qassam: working up towards 'addToNth'
04:24:42 <quicksilver> qassam: getNth is perhaps slightly simpler, but they are very similar
04:24:54 <quicksilver> qassam: you already did 'addHead' which is like addToNth where n is 0
04:25:40 <qassam> would getnth 1 x:xs goto the second item?
04:25:58 <quicksilver> yeah
04:26:04 <quicksilver> can you see how to do that? it uses recursion
04:26:45 <qassam> yes
04:27:03 <quicksilver> addtonth is slightly harder
04:27:11 <qassam> quicksilver, I can go through the list, set the item as x, increase x, then goto the next item, set it as x, increase x
04:27:12 <qassam> etc
04:27:18 <quicksilver> because you're not allowed to 'throw away' the whole of the earlier list
04:27:36 <doserj> fasta: does "Hugs\/GHC" fix it?
04:28:12 <qassam> can I do that quicksilver ?
04:28:15 <fasta> doserj: how can I delete all the haddock files it already created?
04:28:28 <quicksilver> qassam: I'm not quite sure what you meant
04:28:37 <fasta> doserj: Since I deleted the whole piece of text and then did continue.
04:29:28 <doserj> huh?
04:29:36 <qassam> quicksilver, I go through item 0(x), increment the counter in the (x) position, goto item 1 and do the same, etc
04:30:20 <doserj> runghc Setup.hs clean maybe
04:30:22 <quicksilver> but you don't want to increment the counter everywhere :)
04:30:33 <fasta> doserj: I think that cleans the build too.
04:30:39 <quicksilver> you only want to increment them one at a time
04:30:44 <doserj> yes
04:32:31 <qassam> quicksilver, isnt that what I said?
04:32:56 * fasta is wildly unimpressed with Haddock.
04:34:12 <roconnor> @check \a b c d -> (a/b) <= (c/d) ==> a`div`b <= c`div`d
04:34:13 <lambdabot>  Add a type signature
04:34:20 <roconnor> @check \a b c d -> (a/b) <= (c/d::Rational) ==> a`div`b <= c`div`d
04:34:21 <lambdabot>   add an instance declaration for (Integral Rational)
04:34:22 <fasta> dist/build/tmp/./Data/ArrayBZ/Dynamic.hs:"Data/ArrayBZ/Dynamic.hs": 76:1: parse error in doc string: [TokPara]
04:34:46 <fasta> Like I have any idea of what that should mean without reading the source code of Haddock.
04:34:54 <roconnor> @check \a b c d -> ((fromInteger a)/(fromInteger b)) <= ((fromInteger c)/(fromInteger d)::Rational) ==> a`div`b <= c`div`d
04:34:55 <lambdabot>  Exception: Ratio.%: zero denominator
04:35:07 <fasta> If it's "open-source" it doesn't mean you need to read the source before you can use it...
04:38:09 <roconnor> @check \a b c d -> (0 <b) and (0<d) and ((fromInteger a)/(fromInteger b)) <= ((fromInteger c)/(fromInteger d)::Rational) ==> a`div`b <= c`div`d
04:38:10 <lambdabot>  Couldn't match expected type `t -> t1 -> t2 -> t3 -> a'
04:38:20 <roconnor> @check \a b c d -> (0 <b) && (0<d) && ((fromInteger a)/(fromInteger b)) <= ((fromInteger c)/(fromInteger d)::Rational) ==> a`div`b <= c`div`d
04:38:21 <wli> mkRat :: Integer -> Integer -> Maybe Rational ; mkRat n d | d == 0 = Nothing | otherwise = Just $ fromIntegral n / fromIntegral d
04:38:22 <lambdabot>  Arguments exhausted after 111 tests.
04:39:12 <araujo> morning
04:40:10 <ricky_clarkson> What does arguments exhausted mean?  I'd have thought the following would give that:
04:40:14 <ricky_clarkson> @check \a b -> (a::Bool)/=b || a==b
04:40:15 <lambdabot>  OK, passed 500 tests.
04:40:18 <roconnor> wli: now I have to prove it in Coq :(
04:40:32 <roconnor> @scheck \a b -> (a::Bool)/=b || a==b
04:40:33 <lambdabot>   Completed 4 test(s) without failure.
04:40:59 <krishnbhakt> @list
04:41:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
04:41:31 <roconnor> ricky_clarkson: I had so many conditions on my proposition, it got tired of trying to sastisfy it after 111 tests
04:41:41 <scook0> @check \a b -> (a == b && a /= b) ==> (a::Bool)
04:41:43 <lambdabot>  Arguments exhausted after 0 tests.
04:41:46 <scook0> \o/
04:42:09 <roconnor> @scheck \a b -> (a == b && a /= b) ==> (a::Bool)
04:42:10 <lambdabot>   Completed 4 test(s) without failure.  But 4 did not meet ==> condition.
04:43:08 <scook0> actually, I suppose you could just do (a && not a) ==> a
04:43:44 <roconnor> @scheck \a -> (a && not a) ==> (0==1)
04:43:45 <lambdabot>   Completed 2 test(s) without failure.  But 2 did not meet ==> condition.
04:46:45 <fasta> Is Haddock even being maintained?
04:48:39 <doserj> there is ongoing work on porting it to the GHC API, so the current Haddock is sort of frozen
04:50:04 <fasta> So, the "portable" Haddock is going to disappear?
04:50:09 <joelr1> morning
04:50:34 <fasta> (since sometimes multiple implementations are nice to have)
04:50:35 <joelr1> does anyone have this pdf? http://portal.acm.org/citation.cfm?id=512931
04:50:37 <lambdabot> Title: Top down operator precedence
04:51:30 <quicksilver> joelr1: unlikely, PDF hadn't been invented in 1973 I don't think :)
04:51:55 <joelr1> quicksilver: do you have an ACM subscription?
04:52:06 <Igloo> You can get lots of older stuff in PDF format from scans of hardcopy
04:52:47 <quicksilver> Igloo: true, what I said was something of a non-sequitur
04:53:05 <quicksilver> Igloo: however, journals being copyrighted, online PDF versions normally only exist if the other themselves has decided to upload
04:53:17 <quicksilver> s/other/author/
04:53:29 <quicksilver> Igloo: which has mostly only been common in more recent times :)
04:53:43 <Igloo> quicksilver: The ACM make PDFs of everything for digital library subscribers
04:53:59 <quicksilver> I know :)
04:54:11 <quicksilver> but joelr1 can't have one of those since he is apparently not one of those
04:54:16 <quicksilver> or he wouldn't have asked :)
04:54:23 * joelr1 bows
04:54:40 <quicksilver> joelr1: you'll need to find a good library I'm afraid
04:54:45 <quicksilver> joelr1: or a friend with access to one
04:55:50 <fasta> Did I miss a GHC extension? It seems that one can partially apply types in type synonyms.
04:56:03 <quicksilver> that's always been true agaik
04:56:04 <quicksilver> afaik
04:56:11 <quicksilver> type synonyms may be of higher kinds
04:56:11 <joelr1> quicksilver: ok, i got it, thanks
04:56:33 <fasta> quicksilver: I thought one always had to repeat all the type variables.
04:56:39 <quicksilver> you can even define type Flip t a b = t b a
04:56:51 <quicksilver> although it turns out not to be as powerful as you hope
04:57:49 <mux> for writing point-free type-level code? :-)
04:57:49 <quicksilver> come to think of it, I can't remember why not :)
04:58:06 <quicksilver> I think it's because you can't use type synonyms in instance declarations
04:58:18 <fasta> quicksilver: you can in GHC
04:58:19 <Saizan>  you can't partially apply a type synonym but you can use partially applid types in it?
04:58:33 <quicksilver> fasta: yes, true
04:58:53 <quicksilver> Saizan: correct, I think
04:59:10 <fasta> For some reason I believed that it wasn't in H98.
04:59:18 <doserj> it isn't H98
04:59:24 <Saizan> so that's why Flip is not useful
04:59:39 <fasta> doserj: what is not exactly?
04:59:55 <fasta> doserj: partially applied type synonyms?
05:01:14 <doserj> Type constructor symbols T introduced by type synonym declarations cannot be partially applied; it is a static error to use T without the full number of arguments.
05:01:24 <doserj> (quoting the report)
05:02:08 <quicksilver> doserj: yes, but putting using partially applied types, in a type synonym, is legal
05:02:10 <fasta> Right, well, than my belief was correct :)
05:02:16 <quicksilver> doserj: which is what fasta was talking about
05:02:33 <fasta> Hugs does accept it, so probably it is H98.
05:02:57 <kosmikus> sure it's legal
05:03:23 <doserj> ah, sorry then i misread...
05:03:43 <quicksilver> as Saizan points out, it would be much more expressive if both were allowed
05:03:52 <quicksilver> but that would essentially be unrestricted type-level lambda
05:03:58 <quicksilver> which I gather is problematic
05:04:15 <kosmikus> only for type inference
05:05:16 <kosmikus> if you allow recursion in type synonyms, too, you get another set of "problems" ;)
05:06:22 <quicksilver> kosmikus: unrestricted type level Mus :)
05:06:40 <quicksilver> kosmikus: just wait until you see the problems we get at the end of the greek alphabet...
05:07:53 <kosmikus> :)
05:09:08 <quicksilver> I do sometimes wish for newtype-recursion
05:09:19 <quicksilver> I can't remember if that's the same can of worms or a different one
05:11:35 <quicksilver> it's odd the way there are alwyas old GHC manual versions with higher google pagerank than the current one
05:15:49 <LeCamarade> Okay. I give up. How do I hide the constructor? (Yes, I am writing MyIO monad).
05:16:05 <LeCamarade> Tried not exporting it from a file/module. No work.
05:16:18 <doserj> quicksilver: my google number one hist for ghc manual is a manual for a motorcycle battery :)
05:17:12 <scook0> LeCamarade: you do have an explicit export list, right?
05:17:22 <LeCamarade> Yes.
05:17:51 <LeCamarade> And there is no consctuctor therein. But the name of the data type is in there. Or therein, depending. :o)
05:18:04 <fasta> quicksilver: universities often point to the old versions and I think pagerank thinks universities know what they do.
05:18:38 <quicksilver> LeCamarade: ()
05:18:42 <quicksilver> LeCamarade: DataType()
05:18:54 <quicksilver> LeCamarade: DataType on itts own exports all constructors
05:19:00 <quicksilver> LeCamarade: DataType() hides them all
05:19:02 <quicksilver> IIRC
05:19:49 <scook0> LeCamarade: are you checking in ghci?
05:20:17 <LeCamarade> No work.
05:20:20 <LeCamarade> scook0: Yes.
05:20:30 <LeCamarade> With :b
05:20:47 <scook0> I find that if I do $ ghci Blah.hs, I can still see private symbols
05:21:02 <scook0> but if I compile, then load the object file, the symbols are hidden
05:21:12 <scook0> I think ghci is giving you access to the private stuff as a convenience
05:22:07 <LeCamarade> Oh. So ... the compiler is aware of the IO type - as in, it's special? (Because GHCi don't show its constructors. (o:)
05:22:38 <Zao> Doesn't IO mostly optimize away to nothing?
05:23:02 <scook0> I think it's just that ghci gives you access to unexported stuff, if it's loading from source (as a debugging convenience)
05:23:22 <audreyt> LeCamarade: hm, my GHCi shows it :)
05:23:27 <audreyt> Prelude> :i IO
05:23:27 <audreyt> newtype IO a
05:23:27 <audreyt>   = GHC.IOBase.IO (GHC.Prim.State# GHC.Prim.RealWorld
05:23:27 <audreyt>                    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
05:24:56 <scook0> :browse seems to be showing stuff you don't necessarily have access to, as well
05:25:19 <quicksilver> right
05:25:29 <quicksilver> there is a different depending of the '*' is by the module name
05:25:42 <quicksilver> :browse and :info show you stuff you don't have access to, regardless
05:25:59 <quicksilver> but also, with respect to modules you load, the * tells you if you have special access or not
05:26:28 <scook0> http://www.haskell.org/ghc/docs/latest/html/users_guide/ch03s04.html#ghci-scope
05:26:30 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/2c2oeu
05:27:11 <LeCamarade> It does alright. Funny. :o)
05:30:13 <titusg> Is there a handy script around to turn a regular .hs file into bird-style lhs and back again?
05:30:52 <titusg> part of lhs2tex perhaps? I can't se anything in the manual...
05:33:27 <dankna> cat foo.hs | sed -e '{ s/^/> /; }' > foo.lhs  # :)
05:33:31 <dankna> or something like that?
05:33:52 <ivanm> if I'm continually changing interior values of an array stored in STM, should I go for a mutable or an immutable array?
05:33:53 <dankna> I realize there are more features one could wish for than that, but you get the idea
05:34:54 <titusg> dankna, thanks I'll have a play with sed, although it's a closed book to me :-)
05:35:19 * dankna nods
05:35:33 <dankna> it's simpler than it looks :)
05:36:05 <quicksilver> ndm: do you have plans to get Catch working for GADTs?
05:36:36 <ndm> quicksilver: no
05:37:11 <quicksilver> no time to do so? no interest to do so? think it's unwise?
05:37:24 <LeCamarade> unlit?
05:37:28 <LeCamarade> relit
05:37:40 <ivanm> are mutable arrays all monad-based?
05:37:51 <quicksilver> yes
05:37:56 <quicksilver> (what else could they be?)
05:38:30 <quicksilver> monads are the only framework we have for encapsulating side effects...
05:39:05 <ivanm> just checking
05:39:20 <ivanm> so what is the difference between an Array and an IArray ?
05:39:29 <quicksilver> Array is a data type
05:39:36 <quicksilver> IArry is a class
05:39:39 <quicksilver> is it not?
05:39:40 <ivanm> ahhh, k
05:39:42 <scook0> ghci -e 'interact $ unlines . map ("> " ++) . lines'
05:39:50 <ivanm> yeah, I misread the docs
05:40:08 <ivanm> quicksilver: but there's two different versions of Array? one based on IArray and one not?
05:40:21 <quicksilver> no, the'res only one version
05:40:26 <quicksilver> it's just there is a monomoprhic interface
05:40:27 <scook0> titusg: there's one way to do it :)
05:40:31 <quicksilver> and a polymorphic interface
05:40:33 <ivanm> ok
05:40:57 <ivanm> will doing continuous incremental updates on an immutable array eventually become expensive? or is it a fixed complexity?
05:41:13 <titusg> egad but sed is cool :-)
05:41:14 <ivanm> there's mentions in the docs about multiple values with the same index...
05:41:19 <quicksilver> it's fixed compplexity AFAIk
05:41:27 <ivanm> *nod*
05:41:46 <ivanm> the docos for (//) is confusing me :s
05:42:04 <ivanm> oh, wait, I get what it's saying
05:42:17 <dankna> yeah, sed is kinda nice.  its syntax is a bit too arbitrary for my tastes but considering when it was written that's kinda understandable.
05:42:25 <ivanm> so what's the difference then between Array and DiffArray? DiffArray is unboxed, and hence uses things like #Int rather than Int?
05:43:03 <ivanm> well, that last bit is garbage anyway... :s
05:43:08 <ivanm> so what is the difference?
05:43:30 <Lemmih> ivanm: DiffArray uses a mutable array to give O(1) updates.
05:43:30 <quicksilver> DiffArray is a supposedly clever functional implementation
05:43:44 <quicksilver> which minimises copying by hiding a mutable array behind an immutable interface
05:43:55 <quicksilver> however, I gather that in practice it's not actually very fast
05:43:59 <ivanm> so its a pure (i.e. non-monadic) wrapper around a non-pure array?
05:44:06 <ivanm> oh :(
05:44:40 <quicksilver> don't try to be too clever, too soon
05:44:50 <quicksilver> try using arrays naively and see how fast it is or isn't
05:44:51 <ivanm> heh
05:45:01 <ivanm> OK, I'll stick to plain arrays for now
05:49:24 <LeCamarade> Eh, lemme take this here chance to ask why Data.HashTable refuses to use a simple Eq as the key.
05:51:21 <quicksilver> LeCamarade: how could you build a hashtable from just an 'Eq' instance?
05:52:11 <LeCamarade> No, I mean as the keys.
05:52:40 <LeCamarade> It asks, as well, for a function from which it can draw the Ints or something to use as keys.
05:53:16 <LeCamarade> So, when you want to use Strings for keys, you should provide, as well, a (String -> Int). The same module has one handy, but ... why?
05:53:30 <quicksilver> LeCamarade: to do the hashing with?
05:53:42 <quicksilver> I think I completely don't understand what you're getting at? :)
05:53:55 <LeCamarade> Can't it use Strings as keys? After all, they can compare. (Eq instances.)
05:54:06 <LeCamarade> Why does it need to turn 'em to Int?
05:54:11 <quicksilver> LeCamarade: yes, it does use the strings as keys
05:54:19 <quicksilver> LeCamarade: buthe int is the hash function...
05:54:31 <quicksilver> LeCamarade: it's a *hash* table it needs a *hash* function :)
05:55:24 <LeCamarade> Well, a hash function is not mandatory. It could have been called a dictionary. :o)
05:55:32 <quicksilver> it isn't, though
05:55:44 <quicksilver> Data.Map is over that-a-way ===>
05:55:50 <quicksilver> Data.Hashtable is a hashtable
05:55:57 <quicksilver> which means a hash function is mandatory
05:56:10 <LeCamarade> So ... is it merely a pedantic pet peeve that they unsist on hash funs?
05:56:14 <ToRA> LeCamarade: new (==) (fromIntegral . length) :: (Eq [a]) => IO (HashTable [a] val)
05:56:17 <LeCamarade> (==) is  a hash fun.
05:56:29 <LeCamarade> When you are dealing with Eqs, == is a hash fun.
05:56:30 <ToRA> no, (==) is how to discriminate between things with the same hash
05:56:42 <quicksilver> LeCamarade: I think you are failing to grasp what hashing is?
05:56:54 <quicksilver> LeCamarade: hashing is when you have some function which boilds down your type to a single number
05:57:05 <LeCamarade> Oh. Single number?
05:57:06 <quicksilver> LeCamarade: which you can use for fast efficient storage/retrieval
05:57:08 <quicksilver> yes
05:57:12 <quicksilver> that's what hash means
05:57:21 <quicksilver> that's what the (key -> Int32) is
05:57:25 <LeCamarade> Didn't know that. I figured ... even MD5 is a hash function. I know, now.
05:58:00 <quicksilver> incidentally with only Eq you can construct only a really dire dictionary
05:58:03 <LeCamarade> (String -> String) like MD5 should not (at least Math'cally) be called a hash procedure?
05:58:12 <quicksilver> MD5 isn't String -> String
05:58:19 <quicksilver> it's String -> Integer
05:58:27 <LeCamarade> :-o
05:58:32 <quicksilver> it's just that Integer is traditionally represented as a hex or base64 string
05:59:16 <LeCamarade> Oh. I was about to ask why d41d8cd98f00b204e9800998ecf8427e looks like a string. And then I figured.
05:59:34 <LeCamarade> @quote hex
05:59:34 <lambdabot> johnnowak says: Oi I need a break. I just tried to read 'Oxford' as a hexidecimal.
05:59:49 <LeCamarade> @quote hex
05:59:49 <lambdabot> shapr says: I am hexed and vexed ;-)
05:59:58 <quicksilver> to construct a decent dictionary you need either a hash function (as used by perl, Data.hashTable and I strongly suspect python)
05:59:58 <LeCamarade> @quote hex
05:59:59 <lambdabot> shapr says: I am hexed and vexed ;-)
06:00:04 <quicksilver> or an Ordering
06:00:15 <quicksilver> as used by Data.Map
06:00:34 <quicksilver> just Eq leaves you with horrible linear-search algortihms
06:00:54 <LeCamarade> Hmm ... I need to go through this here algo them a use in-a de Data.HashTable.
06:01:19 <quicksilver> or read about a simple hash table in a basic algorithms text
06:01:22 <LeCamarade> It's a Knuth thing, I gather.
06:01:30 <quicksilver> dont' think so
06:01:40 <quicksilver> Knuth did some work on perfect hashing
06:01:47 <quicksilver> but I don't think he invented hashtables...
06:02:01 <LeCamarade> No, this here algo, I mean. I remember seeing that.
06:02:19 <LeCamarade> In the reference, I guess.
06:02:21 <quicksilver> according ot the haddock it's "Per-Ake Larson"
06:02:26 <quicksilver> but I haven't read the paper :)
06:03:24 <LeCamarade> I wouldn't read the paper - I hope to live long and be prosperous. :o)
06:04:26 <LeCamarade> Two mentions of Knuth on http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html ... must have made me think he did this.
06:04:28 <lambdabot> http://tinyurl.com/yum6zr
06:04:35 <Spark> could someone help me with isabelle/proof general
06:05:22 <abell> Can anyone explain why   'a = b . C'  gives me "ambiguous type variable" while   'a par = b $ C par'  does not?
06:05:27 <fasta> There are a whole lot of different ways to implement a hash table(some dominating others theoretically).
06:06:00 <abell> where C is a constructor
06:06:21 <abell> Shouldn't the two forms be equivalent?
06:06:24 <fasta> Interestingly, having random numbers lowers the complexity bound.
06:06:26 <quicksilver> abell: perhaps the monomorphism restriction
06:06:43 <abell> Yes, but why does it turn out in one case and not in the other?
06:06:49 <quicksilver> fasta: subject to certain assumptions on the 'randomness' of the random numbers
06:07:04 <quicksilver> abell: because the monomorphism restriction applies to things which have no parameters
06:09:50 <abell> I'm going to take a deeper look at this "monomorphism restriction" thing. Thanks.
06:12:59 <Cale> abell: Essentially, if you have pattern bound typeclass polymorphic things whose type isn't explicitly stated, the MR gets in your way. It's a somewhat arbitrary restriction, but the justification is that normally one expects pattern bound things to be evaluated only once, and then reused.
06:13:36 <fasta> quicksilver: I don't suppose you know these assumptions by heart?
06:13:42 <Cale> (But due to the translation of typeclasses, those pattern bindings turn into function bindings, so they'll get recomputed at each use)
06:13:46 <quicksilver> fasta: no, certainly not.
06:14:06 <quicksilver> fasta: I imagine it's easy to prove under the assumption 'uniform distribution'
06:14:25 <quicksilver> fasta: and much harder to prove under any weaker asuumption which pseudo-random numbers have in practice :)
06:21:24 <LeCamarade> After implementing a simple lazy evaluation module for Ruby, I appreciate the cost of having thunks scattered all over the runtime. :o)
06:22:28 <mrd> really the MR should just be a warning
06:23:25 <LeCamarade> Don't worry. It'll probably die out of Prime.
06:23:34 <LeCamarade> :o)
06:30:18 <dmead> man wtf
06:30:30 <dmead> haskell wasn't in the #1 spot for ifcp?
06:30:34 <dmead> :/
06:38:00 <titusg> dmead, what were the winners using?
06:38:07 <dmead> c++
06:38:11 <dmead> :o
06:38:15 <titusg> ha!
06:39:11 <osfameron> dmead: and perl came 2nd :-)
06:39:17 <LeCamarade> You guys have the biggest number in top 10. The C++ people can't believe they even finished.
06:39:30 <LeCamarade> Shows how much we expect of Haskell - and rightly so.
06:39:34 <LeCamarade> :o)
06:40:13 <dmead> :P
06:41:01 <titusg> doing so well using c++ or perl is quite an achievement -- like winning the 100m carrying a stove
06:41:50 <LeCamarade> Yeah.
06:42:31 <LeCamarade> @karma java
06:42:31 <lambdabot> java has a karma of -21
06:43:42 <osfameron> titusg: or could it be that those languages have certain advantages (say execution speed for C++, rapid prototyping for perl) that were surprisingly important ?
06:43:58 <sclv> the ifcp was more about coding in the made-up-lang
06:44:16 <osfameron> an alternative is that people using Perl *really* really want to do well because of the chip on the shoulder about being considered a noddy scripting language I suppose
06:44:18 <ricky_clarkson> LeCamarade: Haskell's karma in ##java's bot is 1. ;)
06:44:25 <tolvis> Hello. Just wondering why nub . sort "something" doesn't work?
06:44:40 <LeCamarade> :o) Java knows, naturally.
06:44:59 <Olathe> > (nub . sort) "something"
06:45:01 <lambdabot>  "eghimnost"
06:45:02 <LeCamarade> > (nub . sort) "something'
06:45:02 <lambdabot>  Improperly terminated string
06:45:04 <sclv> and understanding the made-up-machine meant thinking pretty low level, so it was probably biased to people who thought closer to machine code too.
06:45:06 <Olathe> > nub . sort "something"
06:45:06 <LeCamarade> > (nub . sort) "something"
06:45:07 <lambdabot>  Couldn't match expected type `a -> [a1]'
06:45:08 <lambdabot>  "eghimnost"
06:45:23 <Olathe> tolvis: You need (nub . sort) instead of nub . sort
06:45:30 <tolvis> ok. thx
06:45:35 <Olathe> No problem.
06:45:43 <LeCamarade> tolvis: Make sure you _paren_ off the composed funcs. The dot bids very tight.
06:45:47 <LeCamarade> kthbye
06:45:58 <LeCamarade> s/bids/binds/
06:46:02 <tolvis> ok
06:46:09 <tolvis> thx saved my day
06:46:11 <tolvis> bye
06:46:16 <LeCamarade> kthxbye
06:46:18 <LeCamarade> :o)
06:46:40 <Olathe> nub . sort seems a bit inefficient.
06:46:49 <sclv> + the report on the ifcp noted that lots of folks jumped ship from the functionals when performance issues arose.
06:47:05 <sclv> instead of finding the right data structure.
06:48:39 <Olathe> > group [1, 1, 2]
06:48:41 <lambdabot>  [[1,1],[2]]
06:49:10 <Olathe> > (map (head) . sort) "something"
06:49:10 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
06:49:20 <Olathe> > (map (head) . group . sort) "something"
06:49:21 <lambdabot>  "eghimnost"
06:49:23 <LeCamarade> > concat $ group [1, 2, 2]
06:49:24 <lambdabot>  [1,2,2]
06:49:28 <LeCamarade> > concat $ group [1, 21 2]
06:49:29 <lambdabot>   add an instance declaration for (Num (t -> a))
06:49:29 <lambdabot>     In the expression: 21 2
06:49:33 <LeCamarade> > concat $ group [1, 1, 2]
06:49:34 <lambdabot>  [1,1,2]
06:49:35 <Olathe> That should be a bit more efficient.
06:51:49 <nornagon> @scheck \a -> concat . group $ a == a :: [Int]
06:51:50 <lambdabot> Couldn't match expected type `[a]' against inferred type `Bool'
06:52:01 <fasta> A website made by amateurs just did a successful DOS attack. (thanks to Firefox, since Opera has saner memory code)
06:52:15 <nornagon> @scheck \a -> concat . group $ (a :: [Int]) == a
06:52:16 <lambdabot> Couldn't match expected type `[a]' against inferred type `Bool'
06:52:25 <nornagon> oh, d'oh
06:52:35 <nornagon> @scheck \a -> (concat . group $ (a :: [Int])) == a
06:52:36 <lambdabot>   Completed 25059 test(s) without failure.
06:52:53 <nornagon> @scheck \a -> (concat . group $ (a :: [String])) == a
06:52:59 <lambdabot> Done.
06:59:02 <Olathe> @check \x -> (-1::Int)*x == x
06:59:04 <lambdabot>  Falsifiable, after 0 tests: -1
07:01:23 <dmead> neat
07:01:33 <dmead> @check a+b = a
07:01:34 <lambdabot>  Parse error
07:01:58 <dmead> @check \a b = a + b == b
07:01:59 <lambdabot>  Parse error
07:02:01 <Olathe> @check False
07:02:02 <lambdabot>  Falsifiable, after 0 tests:
07:02:08 <Olathe> @check True
07:02:09 <lambdabot>  OK, passed 500 tests.
07:02:12 <dmead> @check \a b = (a + b == b)
07:02:13 <lambdabot>  Parse error
07:02:19 <dmead> @check \a b -> (a + b == b)
07:02:20 <lambdabot>  Add a type signature
07:02:20 <byorgey> dmead: you want -> after the \a b, not =
07:02:23 <dmead> right
07:02:45 <dmead> i've used lambdas in haskell zero times
07:02:46 <dmead> hehe
07:02:53 <dmead> directly that is
07:03:00 <byorgey> and it usually doesn't like polymorphic things, since it needs to know a specific type from which it can generate random values
07:03:08 <Olathe> @check \x -> x == "evil"
07:03:09 <lambdabot>  Falsifiable, after 0 tests: "\185869\273056"
07:03:17 <byorgey> dmead: make that once, now =)
07:03:21 <Olathe> @check \x -> x /= "evil"
07:03:22 <lambdabot>  OK, passed 500 tests.
07:03:27 <dmead> @check \a b -> ((a :: Int) + b == b)
07:03:29 <lambdabot>  Falsifiable, after 0 tests: 2, -3
07:03:32 <dmead> kewl
07:03:36 <byorgey> proof, the string "evil" cannot be represented in Haskell!
07:03:40 <dmead> this is quickcheck?
07:03:44 <byorgey> yup
07:03:53 <dmead> cite your rules!
07:03:53 <Olathe> byorgey: Exactly !
07:04:04 <dmead> 1, CH?
07:04:10 <byorgey> @check \a b c -> ((a :: Int) + b) + c == a + (b + c)
07:04:11 <lambdabot>  OK, passed 500 tests.
07:04:48 <byorgey> dmead: hehe =)
07:05:03 <dmead> @check \a b -> ((a :: Int) + (b:: Readl) == b)
07:05:04 <lambdabot>   Not in scope: type constructor or class `Readl'
07:05:09 <dmead> @check \a b -> ((a :: Int) + (b:: Read) == b)
07:05:09 <lambdabot>      Class `Read' used as a type     In the type `Read',     In an expression...
07:05:11 <dmead> ergaergaer
07:05:14 <dmead> @check \a b -> ((a :: Int) + (b:: Real) == b)
07:05:14 <lambdabot>      Class `Real' used as a type     In the type `Real',     In an expression...
07:05:22 <dmead> @check \a b -> ((a :: Int) + (b :: Real) == b)
07:05:23 <lambdabot>      Class `Real' used as a type     In the type `Real',     In an expression...
07:05:25 <byorgey> dmead: Double, perhaps?
07:05:25 <dmead> picky...
07:05:30 <dmead> @check \a b -> ((a :: Int) + (b :: Double) == b)
07:05:30 <lambdabot>  Couldn't match expected type `Int' against inferred type `Double'
07:05:36 <byorgey> but that doesn't typecheck =)
07:05:39 <dmead> :>
07:05:47 <dmead> @check \a b -> ((a :: Double) + (b :: Double) == b)
07:05:48 <lambdabot>  Falsifiable, after 0 tests: -2.0, 4.0
07:06:06 <byorgey> @check \a -> (a :: Double) + a = 2 * a
07:06:06 <lambdabot>  Parse error
07:06:13 <byorgey> @check \a -> (a :: Double) + a == 2 * a
07:06:14 <lambdabot>  OK, passed 500 tests.
07:06:41 <byorgey> @check \a -> sum (replicate 10000 a) == 10000 * a
07:06:42 <lambdabot>  Add a type signature
07:06:50 <byorgey> @check \a -> sum (replicate 10000 a) == 10000 * (a :: Double)
07:06:52 <lambdabot>  Falsifiable, after 7 tests: 2.3333333333333335
07:06:54 <byorgey> bwahaha
07:07:05 <Olathe> @. run keal
07:07:05 <lambdabot>   parse error on input `,'
07:07:17 <byorgey> what's run?
07:07:22 <Olathe> @run (+1) 6
07:07:24 <byorgey> @help run
07:07:24 <lambdabot>  7
07:07:24 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
07:07:30 <byorgey> oh
07:07:43 <byorgey> same as >
07:07:52 <Olathe> Yep.
07:10:29 <ricky_clarkson> @help >
07:10:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:10:44 <Olathe> @. run help
07:10:44 <lambdabot>  Improperly terminated character constant
07:36:57 <hpaste>  Dybber pasted "Project Euler, problem 92, memory usage problem" at http://hpaste.org/3324
07:37:01 <Dybber> Im trying to solve problem 92 on project euler (http://projecteuler.net/index.php?section=problems&id=92) but i got some memory problems.
07:37:03 <lambdabot> Title: Project Euler
07:38:07 <Dybber> I don't understand it, the array I create only contains 10^10 boolean values. Its got to be something else
07:40:21 <fasta> Dybber: you assume one bit per boolean
07:40:27 <fasta> Dybber: that probably doesn't hold
07:40:42 <Dybber> Its using more than a gigabyte of memory!
07:40:43 <byorgey> Dybber: are you getting an error message, or does it just gobble lots of memory and run slowly?
07:40:58 <fasta> Dybber: what array type do you use?
07:41:06 <fasta> Dybber: never mind
07:41:12 <profmakx> man i am pissed. Why doesnt the 6.8 configure even recognise freebsd amd64?
07:41:12 <fasta> Dybber: didn't see your paste
07:41:32 <fasta> profmakx: because it has no users?
07:42:00 <Dybber> byorgey, it's running slowly, taking all the memory, the CPU is not very active
07:42:14 <quicksilver> Dybber: you need to explicitly use UArrays if you are hoping for 1bit per bool
07:42:19 <profmakx> then, why does 6.6.1?
07:42:23 <quicksilver> Dybber: standard arrays will use about 24 bytes per bool
07:42:27 <profmakx> (not that a bootstrap would work...)
07:42:29 <quicksilver> Dybber: that's not so good :)
07:43:01 <fasta> quicksilver: does sharing happen between subvalues of UArrays?
07:43:08 <fasta> quicksilver: STUArrays*
07:43:48 <quicksilver> no
07:43:54 <Igloo> profmakx: Can you paste what happens please?
07:43:56 <quicksilver> unboxed arrays don't share
07:44:22 <quicksilver> if you need an 'unboxed sharing' style semantics, use ByteString
07:44:31 <profmakx> Igloo: in what case? I tried bootstrapping 6.4.2
07:44:37 <quicksilver> or write your own code in a similar way to the way bytestring is written
07:44:48 <profmakx> Igloo: but the compiler blows up in smoke when building Linker
07:45:09 <Igloo> profmakx: 6.8 not recognising freebsd amd64
07:45:39 <profmakx> Igloo: Unrecognised platform: x86_64-unknown-freebsd7.0
07:45:42 <jedbrown> Dybber: the problem statement says `10 Million' which is only 10^7.
07:45:44 <profmakx> might be a trivial patch though
07:46:43 <Igloo> profmakx: I don't see why that would have worked in 6.6.1
07:46:46 <fasta> quicksilver: if I do something like large_list = [1..10^8] in |Just large_list|Just large_list| where |..| denote cells of an STUArray, they list will be stored twice?
07:46:58 <Dybber> jedbrown, oops, but that doesn't work either, still using to much memory
07:47:05 <fasta> quicksilver: also for STArray?
07:47:18 <profmakx> Igloo: what do you mean?
07:47:23 <hpaste>  n00b pasted "Calculate the product of a list" at http://hpaste.org/3325
07:47:30 <quicksilver> fasta: in the unboxed case the values are stored twice
07:47:39 <quicksilver> fasta: in the boxed case, they are shared
07:47:46 <n00b> my function doesn't seems to be doing what it suppose to
07:47:50 <quicksilver> fasta: since the 'box' contains a pointer to the actual value
07:47:53 <Igloo> profmakx: I've just looked at the 6.6.1 code and I can't see why it would have worked
07:47:54 <fasta> quicksilver: ok, that's what I expected. Thanks
07:48:06 <n00b> it suppose to calculate the product of a list
07:48:18 <krishnbh1kt> @numbers
07:48:18 <lambdabot> Unknown command, try @list
07:48:28 <krishnbh1kt> @fun
07:48:29 <lambdabot>  <stdin>: hGetLine: end of file
07:48:35 <quicksilver> n00b: consider productList [1]
07:48:51 <quicksilver> n00b: productList [1] = productList (1:[]) = 1 * productList []
07:48:54 <quicksilver> n00b: right?
07:49:15 <n00b> cool
07:49:21 <profmakx> appears to me that there are not enough ghc users on freebsd :)
07:49:38 <byorgey> Dybber: if it really uses about 24 bytes per bool as quicksilver says, that would be about 230 MB.
07:50:12 <quicksilver> n00b: do you see where I'm going?
07:50:21 <quicksilver> n00b: 1 * productLict [] = 1 * 0
07:50:23 <quicksilver> n00b: = ?
07:50:44 <quicksilver> byorgey: I think 24 bytes may be an exagerattion :) I think 24 bytes is the cost of a list cell, not an array cell
07:50:45 <n00b> 0
07:50:51 <quicksilver> byorgey: but certainly it's multiple words
07:50:54 <byorgey> right.
07:51:10 <byorgey> Dybber, the point is, you should try using some sort of unboxed array representation.
07:51:14 <quicksilver> n00b: can you see what you've done wrong now?
07:51:54 <n00b> YES
07:51:55 <Dybber> byorgey, thats what i'm trying to do, but - I think I need to read about them first :)
07:52:23 <byorgey> Dybber: to start, you can just import Data.Array.Unboxed instead of Data.Array, and change Array to UArray everywhere in your code.
07:52:44 <byorgey> Dybber: there are more sophisticated options as well but that should give you some improvement right away, I think.
07:53:08 <byorgey> Dybber: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Unboxed.html
07:53:09 <lambdabot> http://tinyurl.com/38qe2d
07:53:58 <Dybber> byorgey, i get a type error when I do that.     No instance for (IArray a Bool)
07:54:13 <fasta> profmakx: that's what I meant
07:54:14 <quicksilver> you'll need explicit type annotations for this
07:54:27 <quicksilver> you'll have to annotate it as UArray Int Bool
07:54:53 <Dybber> it compiles!
07:56:30 <Dybber> And prints: prob92: <<loop>>
07:56:33 <Dybber> ??
07:57:49 <quicksilver> @quote anthropo
07:57:50 <lambdabot> No quotes match. Wrong!  You cheating scum!
07:57:59 <byorgey> hm, that probably has something to do with the fact that UArray is strict in the stored values, whereas a generic Array is not.
07:58:10 <quicksilver> @remember Aaron_Denney "Don't anthropomorphize computers.  They hate it when you do that."
07:58:10 <lambdabot> Done.
07:59:26 <byorgey> Dybber: you'll probably have to declare an empty array, then write a function to update one element of the array, and map it over all the elements.
08:00:02 <byorgey> as opposed to packing all of that implicitly into a list comprehension as an argument to 'array'.
08:00:02 <quicksilver> oh, I see
08:00:09 <quicksilver> yes, you're use the laziness esentially
08:00:13 <quicksilver> when you write the array like that
08:00:17 <quicksilver> so you need a lazy array
08:00:31 <quicksilver> I didn't read your code clearly before
08:00:56 <quicksilver> if you want a naive implementation, try Data.Sequence
08:01:02 <quicksilver> could well be fast enough
08:01:13 <Dybber> ok :(
08:01:26 <krishnbh1kt> @version
08:01:26 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
08:01:26 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:01:55 <byorgey> hm, maybe part of the memory problem before was huge thunks representing the array values getting built up?
08:03:06 <roconnor> @check \a b -> b/=0 ==> a`div`b == (-a)`div`(-b)
08:03:10 <lambdabot>  Add a type signature
08:03:15 <roconnor> @check \a b -> b/=0 ==> a`div`b == (-a)`div`(-b::Integer)
08:03:17 <lambdabot>  OK, passed 500 tests.
08:23:14 <Tac-Work> Why is programming.reddit.com the official place of conspiracy for Haskell and Erlang?
08:24:39 <quicksilver> surely conspiracies are ubiquitous by their very nature
08:24:54 <quicksilver> even your cleaning lady and Kim Jong Il are part of the haskell conspiracy
08:25:34 <Tac-Work> Now that I think about it, I did find one of my Haskell books missing last Tuesday when she came to visit....
08:25:35 <Tac-Work> X-D
08:34:43 <Tac-Work> It seems like most of the articles in one way or another turn into an argument between business-oriented coders and cool-ass-languag-oriented hackers
08:35:30 <quicksilver> trying something new is a real investment of time
08:35:33 <ricky_clarkson> Perhaps we need to promote Excel as the only practical programming environment so they leave us alone.
08:35:41 <quicksilver> equally, the stuff you already know how to do
08:35:47 <Tac-Work> I see a lot of the phrase "there is no business purpose to use language X".... and I just want to bonk the poster in the head and tell them to stop thinking like a sheep
08:35:48 <quicksilver> represents a massive (prior) investment of time
08:36:03 <Tac-Work> yeah
08:36:06 <quicksilver> so the hurdle to jump over - to try something new, and consider discarding someting old
08:36:09 <quicksilver> is rather painful
08:36:16 <Philippa> yeah. OTOH, the cultural factors that stop people doing it wastefully are... not clever
08:36:20 <Tac-Work> Why discard the old?
08:36:27 <Tac-Work> Integrate both into your mind
08:36:38 <quicksilver> if some aspects of the new are better than the old you will presume discard (some of) the old
08:36:45 <Philippa> you have to integrate them into more than just your mind
08:36:50 <Philippa> systems integration can be hard, hard work
08:36:50 <quicksilver> all that hard work expended learning your way around obscure java APIs
08:36:54 <quicksilver> or whatever it might be
08:37:26 <quicksilver> and whatever we claim haskell is, I don't think we can claim it's a "pick up in 5 minutes and see instant benefits" language :)
08:37:48 <quicksilver> for all sorts of different reasons
08:37:54 <Tac-Work> I don't actually use Haskell for much (maybe because I'm not exceptionally talented at it quite yet), but it sure as hell causes me to see red flags whenever I see a function with a frivilous side effect
08:38:08 <quicksilver> yes
08:38:15 <Tac-Work> Haskell is definitely not the "forthemasses" language
08:38:20 <quicksilver> you can take things back from pure programming
08:38:25 <quicksilver> and use them in imperative languages
08:38:34 <quicksilver> to write "more pure, more type-disciplined" code
08:38:44 <Tac-Work> I wonder how feasible it would be to make a "less scary" haskell, with as much purity in tact as possible
08:38:45 <quicksilver> the experience can be very beneficial
08:39:04 <matthew_-> the problem is that catering for the lowest common denominator is very unsatisfactory
08:39:21 <Philippa> Tac-Work: depends what you think "less scary" is. Taking out the layout rule and changing a few tokens around would help a lot of people
08:39:50 <Tac-Work> Not the lowest common denominator.... more like a few steps above that.. Haskell clearly lends itself to the somewhat elite.
08:39:55 <Philippa> extra sugar for the do notation so it reads less like a compiler's IL might help
08:40:23 <Tac-Work> Even if you called monads something like "Legos" or "connections" or something, it would cause less pain and fear
08:40:26 <Philippa> because then you're back to the old statement/expression distinction
08:41:06 <Philippa> keeping instance Monad [] out of the Prelude and perhaps out of your Data.List equivalent might help too
08:41:10 <Tac-Work> even like philippa said, making the syntax easier to use
08:41:12 <quicksilver> Tac-Work: SPJ argues that as his biggest mistake, in his "wearin the hair shirt" retrospective about haskell
08:41:15 <Philippa> it causes weird type errors
08:41:18 <quicksilver> Tac-Work: calling them 'monads'
08:41:46 <shapr> @yow !
08:41:46 <lambdabot> Somewhere in suburban Honolulu, an unemployed bellhop is whipping up a
08:41:46 <lambdabot> batch of illegal psilocybin chop suey!!
08:41:55 * mrd calls them Furries, it goes well with lambdacats
08:42:10 <quicksilver> SPJ's suggesting is 'warm fuzzy thing', I believe
08:42:17 <mrd> that works
08:42:22 <Philippa> you really don't want something in a for-the-mainstream standard called a Furry. Some of them'll have heard of furries before
08:42:24 <Tac-Work> And the language would need to be somewhat more standardized
08:42:42 <Philippa> something like "Aspect" might be a non-stupid name
08:42:52 <Tac-Work> in terms of how to get things done. In Haskell, you can do stuff in so many different ways, it would confuse people ;-)
08:43:38 <quicksilver> http://saxophone.jpberlin.de/MonadTransformer?source=http%3A%2F%2Fwww%2Ehaskell%2Eorg%2Fhaskellwiki%2FMonad&language=English
08:43:42 <lambdabot> Title: Warm, fuzzy thing - HaskellWiki, http://tinyurl.com/26nffk
08:43:46 <mrd> for business people, you need a good three letter acronym, preferably starting with X
08:44:00 <Tac-Work> And monads would be taught my example instead of from theory, because they are so simple when you see them in use
08:44:03 <Philippa> yeah, supplying more standard braindead ways to do things is a definite win
08:44:32 <Tac-Work> XLL = X'sn'ta Lazy Language
08:44:43 <Philippa> yeah. And the IO monad "problem" (IO foo -> foo) can be explained in terms of old mainframe-style programming where you'd open and read everything first, do your computation and then write it out again
08:45:06 <mrd> I'd suggest extensible monadic language, but apparently XML is taken
08:45:12 <quicksilver> actually I'm not at all convinced that programming haskell is harder than Java or >NET
08:45:18 <quicksilver> programming is HARD
08:45:23 <quicksilver> really really hard
08:45:25 <Tac-Work> It is
08:45:29 <quicksilver> I know because I do it :) And I have taught it.
08:45:43 <quicksilver> It's just that people who have already invested 3-5 years learning Java/.NET
08:45:44 <Tac-Work> But Haskell has the greatest learning curve of any language I've ever seen
08:45:56 <quicksilver> again, I'm not sure that's true if you start from scratch
08:46:04 <quicksilver> I think it's simply that it's more different
08:46:06 <Tac-Work> and I seriously doubt there is an actual reason that that *needs* to be the case
08:46:17 <quicksilver> so, e.g., if you already knew Java, you'd find .NET a small jump
08:46:22 <quicksilver> because it's so similar in so many ways
08:46:34 <quicksilver> but if you already know Java, haskell is a massive jump
08:46:38 <DukeDave> Can I suggest "Haskell has the greatest unlearning curve"
08:46:52 <quicksilver> yes, that's exactly it
08:46:53 <Tac-Work> DukeDave: hah, that's why I stick wit hi t
08:47:04 <quicksilver> I think if you took two bright people who had never programmed
08:47:12 <quicksilver> and taught them separately haskell and java
08:47:24 <quicksilver> you'd find the difference in 'difficultly' to be much slower than you'd imagine
08:47:32 <quicksilver> smaller, that is
08:47:34 <mrd> some people had already invested 5 years learning Java when it was still new
08:48:10 <Saul_> @src foldl
08:48:10 <lambdabot> foldl f z xs = lgo z xs
08:48:10 <lambdabot>     where lgo z []     =  z
08:48:10 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
08:48:15 <sieni> mrd: perhaps they are slow learners?
08:48:49 <Saul_> @src foldr
08:48:49 <lambdabot> foldr k z xs = go xs
08:48:49 <lambdabot>     where go []     = z
08:48:49 <lambdabot>           go (y:ys) = y `k` go ys
08:49:04 <shapr> @remember DukeDave Haskell has the greatest unlearning curve
08:49:04 <lambdabot> Done.
08:49:58 <Tac-Work> Well, I guess it would still be a good thing if there was a nicer bridge language between Java and Haskell
08:50:07 <opqdonut> @quote imperative
08:50:07 <lambdabot> SamB says: Haskell is the only language I know with first-class support for imperative programming
08:50:09 <quicksilver> Groovy?
08:50:11 <opqdonut> @quote imperative
08:50:11 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
08:50:12 <Tac-Work> let more people take the leap without breaking their legs
08:50:14 <opqdonut> @quote imperative
08:50:14 <lambdabot> Cale says: Ruby is kind of a nice language, for an imperative object oriented language that isn't smalltalk.
08:50:16 <quicksilver> ruby?
08:50:23 <opqdonut> @quote imperative
08:50:24 <lambdabot> DavidAmos says: the real reason for using Haskell is that the code comes out shorter, and is quicker to write, than in imperative languages .. What that means is, I can get much more done when I use
08:50:24 <lambdabot> Haskell
08:50:30 <mrd> @quote functional
08:50:30 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
08:50:30 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
08:50:30 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
08:50:44 <quicksilver> combinator?
08:50:49 <opqdonut> probably ;)
08:50:56 <opqdonut> @quote best imperative
08:50:56 <lambdabot> No quotes for this person. Do you think like you type?
08:51:00 <opqdonut> @quote best.*imperative
08:51:01 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
08:51:11 <opqdonut> bah
08:51:19 <quicksilver> Actually I think the hardest thing about haskell
08:51:28 <quicksilver> trying to put myself in the shoes of someone who has never programmed before
08:51:31 <quicksilver> no preconceptions
08:51:34 <quicksilver> is the error messages
08:51:40 <Tac-Work> for seriously!
08:51:42 <Tac-Work> they suck!
08:51:49 <quicksilver> and that's a shame, because the GHC team have really, really worked on the error messages
08:51:59 <quicksilver> (yes, they used to be *even* *worse*)
08:52:03 <opqdonut> many claim hugs's are better
08:52:07 <mrd> "suggested fix: write an instance for Num Char"
08:52:14 * mrd thinks the suggestions need to die
08:52:24 <quicksilver> for example, suppose I decided to teach a bit of IO talking about what it was
08:52:26 <Tac-Work> A nice Haskell IDE would probably help learning quite a bit
08:52:32 <quicksilver> just so my students could display some text
08:52:34 <Tac-Work> if you could hilight things and find the types
08:52:41 <mrd> Tac-Work: shim lets you do that
08:52:42 <quicksilver> the error message if they make a 'slight' mistake
08:52:46 <quicksilver> is painful :(
08:52:56 <dylan> :t \n -> (take n &&& drop n)
08:52:59 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:53:04 <osfameron> quicksilver: indeed, the messages are very "helpful" but hard to read
08:53:10 <mrd> :t splitAt
08:53:11 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:53:21 <opqdonut> ?src splitAt
08:53:21 <dylan> aha.
08:53:21 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
08:53:22 <quicksilver> consider somethign like do {putStrLn "hello " ++ name; putStrLn "how are you?"}
08:53:24 <opqdonut> :)
08:53:36 <quicksilver> and the various ways you could get that slightly wrong
08:53:40 <quicksilver> and the message you get :(
08:54:04 <Tac-Work> you fool! You can't append IO Strings to Strings!
08:54:05 <Tac-Work> heh
08:54:08 <mux> hehehe
08:54:18 <quicksilver> Tac-Work: definitely, although in my head I was focussing on the part before you explain what a type is
08:54:23 <mux> how dare you trying to append a String to an IO ()
08:54:25 <mux> =)
08:54:36 <quicksilver> yes, that was one of the mistakes :)
08:54:42 <ricky_clarkson> When you get an error message suggesting to add an instance, can you actually do so?
08:54:43 <quicksilver> in case you lacked the imagination to think of your own
08:54:46 <dylan> haskell is great. Code to parse the output of the "remind" program: second unwords $ splitAt 5 (words line)
08:54:48 <ricky_clarkson> > []+5
08:54:49 <lambdabot>   add an instance declaration for (Num [a])
08:54:49 <lambdabot>     In the expression: [] + 5
08:54:49 <lambdabot>    ...
08:55:00 <mux> ricky_clarkson: it's often a wrong suggestion
08:55:02 <ricky_clarkson> ..could I fix it so that that gave [5]?
08:55:07 <ricky_clarkson> mux: I realise that.
08:55:11 <kaol> > 'a':' ':'s':'t':'r':'i':'n':'g':undefined
08:55:12 <quicksilver> dylan: not unwords . drop 5 . words $ line ?
08:55:12 <lambdabot>  Undefined
08:55:25 <quicksilver> kaol: warning!
08:55:34 <quicksilver> kaol: lambdabot's undefined handler does weird stuff
08:55:56 <quicksilver> kaol: a more expected answer is "a string** Exception: undefined
08:56:20 <dylan> quicksilver: that loses information
08:56:35 <mux> > liftM (+) [2] [3]
08:56:36 <lambdabot>  Couldn't match expected type `[t1] -> t'
08:56:38 <quicksilver> dylan: oh, sorry.
08:56:44 <mux> d'oh
08:56:45 <quicksilver> dylan: I understand what you're doing :)
08:56:58 <dylan> quicksilver: I'm producing a calendar using Text.XHtml. :)
08:56:59 <Tac-Work> Concatenating regular Strings and IO Strings together is like trying to append the words "It's nice to meet you" to the act of asking someone for their name
08:57:37 <quicksilver> good analogy!
08:57:57 <ricky_clarkson> So putStrLn "blah" ++ "blah" is (putStrLn "blah") ++ "blah"?
08:58:02 <quicksilver> yes
08:58:09 <quicksilver> so my example had a bug in it
08:58:18 <quicksilver> function application binds tighter than any operator
08:58:19 <mux> I think the way haskell's parser eats token is the most surprising thing
08:58:28 <mux> but when you get used to it, it's okay
08:58:36 <mux> and it makes for easier partial application
08:58:54 <ricky_clarkson> There's tons of syntax, but from what I know of it, it seems consistent.
08:58:58 <quicksilver> it makes sense given that function application is somehow a 'key feature' of the language
08:59:03 <ricky_clarkson> I keep tripping up over Scala's syntax.
08:59:04 <mux> yeah
08:59:12 <quicksilver> but it is confusing
08:59:28 <quicksilver> most other languages people would have used have explicit parens for function applications
08:59:32 <mux> when you only ever did C, C++, Java, PHP, Perl, Ruby... etc, it's wildly confusing
09:00:03 <Tac-Work> C is pretty damn confusing too though
09:00:07 <Tac-Work> C++ esp. with templates
09:00:10 <ricky_clarkson> Ah, but if BASIC was there, it's like coming home. ;)
09:00:20 * mux started coding with Locomotive Basic 1.0 !
09:00:22 <ricky_clarkson> PRINT "Hello, I'm still here"
09:00:27 <mux> ? "Hi!"
09:00:32 <quicksilver> 20 GOTO 10
09:00:33 <dylan> if you're used to perl or python, it's pretty easy to learn that foo a b c is foo(a)(b)(c)
09:00:33 <Tac-Work> Do you have an extra GOTO 10 line!??
09:00:34 <mux> 10 CLS
09:00:38 <mux> quicksilver: haha =)
09:00:50 * mux goes back to home &
09:00:59 <shapr> Good morning #haskell!
09:01:08 <quicksilver> dylan: although in another sense it is also like foo(a,b,c)
09:01:19 <quicksilver> dylan: since in those languages functions would normally be uncurried
09:01:22 <DRMacIver> Hm. Let's play "hunt the data structure". I have a set of subintervals of [0, 1] and a value x. I want to efficiently determine whether x is contained in one of these intervals.
09:01:40 <DRMacIver> What sort of structure should be looking for? I'm imagining one modelled on a binary search tree.
09:01:42 <Tac-Work> The one thing I think I love about Haskell that I can't say about any other language, is the support group
09:01:46 <Tac-Work> This channel is awesome
09:01:53 <shapr> yay!
09:01:58 <quicksilver> DRMacIver: I'm not sure exactly what that's called
09:01:58 <Tac-Work> map #haskell (++)
09:02:01 <dylan> quicksilver: I don't see it as foo (a, b, c) at all. coming from perl, functions really only have one argument anyway, the @_ array. <g>
09:02:08 <quicksilver> DRMacIver: like a QuadTree
09:02:16 <quicksilver> DRMacIver: only in one dimension
09:02:16 <chessguy> uh
09:02:21 <DRMacIver> (Ideally I'd like to be able to determine which interval includes the point)
09:02:23 <quicksilver> DRMacIver: ought to be a BinTree?
09:02:23 <chessguy> you mean map (++) #haskell ?
09:02:33 <Tac-Work> see how helpful everyone is?
09:02:33 <quicksilver> but that means lots of other things too :)
09:02:34 <Tac-Work> yes
09:02:39 <Tac-Work> (flip map) #haskell (++)
09:02:39 <chessguy> lol
09:02:39 <DRMacIver> quicksilver: Yeah, that's more or less what I had in mind.
09:02:46 <quicksilver> is it called a 1D-BSP, perhaps?
09:03:03 <quicksilver> basically it's a binary tree, but intervals can appear more than once
09:03:04 <chessguy> @type (flip map) ?haskell (++)
09:03:07 <lambdabot> forall a. (?haskell::[[a]]) => [[a] -> [a]]
09:03:14 <quicksilver> so, for example, if you have the interval [0.3,0.7]
09:03:24 <quicksilver> then that interval 'occurs' on both sides of 0.5
09:03:30 <quicksilver> so you put it on boths sides of the tree
09:03:41 <DRMacIver> So at each point in the tree I label all intervals that overlap with that subdivision?
09:03:55 <Tac-Work> @type ?whatdoesthequestionmarkdo?
09:03:57 <lambdabot> parse error (possibly incorrect indentation)
09:04:00 <Tac-Work> err
09:04:01 <Tac-Work> hehe
09:04:01 <DRMacIver> Stopping when I get partitions containing only one interval?
09:04:04 <Tac-Work> @type ?hmm
09:04:05 <lambdabot> forall t. (?hmm::t) => t
09:04:09 <Tac-Work> cool
09:04:16 <quicksilver> DRMacIver: http://en.wikipedia.org/wiki/Binary_space_partitioning
09:04:16 <lambdabot> Title: Binary space partitioning - Wikipedia, the free encyclopedia
09:04:23 <DRMacIver> Yeah. Looking there now.
09:04:30 <quicksilver> DRMacIver: although that page is mostly about the 3D case not the 1D case :)
09:04:37 <DRMacIver> That's ok. I can figure it out.
09:05:06 <DRMacIver> I'd already more or less had the idea. I just wanted to get some feedback and keywords for confirmation. Thanks. :)
09:05:36 <quicksilver> in some versions of the algorithm you "turn" [0.3,0.7] into [0.3,0.5] when it's on the left
09:05:50 <quicksilver> in other versions you just point back to teh original [0.3,0.7] cos you can work it out
09:05:53 <quicksilver> :)
09:07:37 <DRMacIver> quicksilver: Thanks
09:13:24 <catBehemoth> anyone alive?
09:13:37 <Vq^> yes
09:13:38 <Tac-Work> nope
09:13:39 <matthew_-> no
09:13:42 <Tac-Work> heh
09:13:47 <quicksilver> @vixen are you alive?
09:13:48 <lambdabot> yes, i am
09:13:49 <kaol> @users
09:13:50 <lambdabot> Maximum users seen in #haskell: 420, currently: 390 (92.9%), active: 22 (5.6%)
09:13:59 <matthew_-> @vixen are you sure?
09:13:59 <lambdabot> yes, i am
09:14:09 <catBehemoth> sorry thats my first time here
09:15:04 <Tac-Work> no problem, this is the best channel on freenode
09:15:09 <Vq^> in that case, welcome to #Haskell mr catBehemoth :)
09:15:37 <catBehemoth> hmmm.. are you all programmers?
09:17:07 <Vq^> if by programmer you mean a person that have some programming knowledge then yes
09:17:51 <catBehemoth> :)) thanks for the answer
09:18:22 <catBehemoth> i just wonder where i shall start... hm..
09:19:47 <abell> I suggest you start from the result you want to get, and then lazily pull all the other information which might be needed
09:19:57 <Vq^> maybe youre looking for the how to start learning haskell tutorial :)
09:20:06 <Vq^> http://www.haskell.org/haskellwiki/Meta-tutorial
09:20:07 <lambdabot> Title: Meta-tutorial - HaskellWiki
09:20:15 <shapr> I am not alive.
09:20:40 <Vq^> @get-shapr-from-the-dead
09:20:40 <lambdabot> Unknown command, try @list
09:20:42 <kaol> not awake yet?
09:20:56 <catBehemoth> sorry guys i aint a programmer at all, ur irc channel came up first when i googled it
09:21:07 <SyntaxNinja> w00t
09:21:10 <shapr> catBehemoth: It's okay, we all started at the beginning.
09:21:12 <catBehemoth> at least u must proud of that:)
09:21:31 <Vq^> catBehemoth: section 1.2 in that meta-tutorial suggests a couple of tutorials for non-programers
09:21:40 <shapr> catBehemoth: What did you google for?
09:22:09 <SyntaxNinja> shapr: maybe lambda cat?
09:22:52 <SyntaxNinja> maybe we can become the most cat friendly programming language.
09:22:55 <catBehemoth> i use IRC from miranda, and never used irc before so i googled irc channel
09:23:06 <shapr> What's miranda?
09:23:19 <chessguy> the predecessor to haskell
09:23:22 <catBehemoth> miranda is an icq, msn etc client
09:23:27 <shapr> ah
09:23:31 <Vq^> oh
09:23:33 <chessguy> oh, different miranda
09:23:35 <catBehemoth> hey! thats not true:)
09:23:41 <slava> the predecessor to haskell is an icq client?
09:23:46 <slava> no wonder haskell has such funny syntax
09:23:47 <shapr> hey slava
09:23:53 <Vq^> slava: :)
09:23:53 <chessguy> lol
09:23:55 <slava> hey shapr
09:23:55 <catBehemoth> how do i answer to a specific person?
09:23:58 <Tac-Work> Haskell was the precursor to computer science
09:24:02 <SyntaxNinja> catBehemoth: well, looks like you figured out IRC
09:24:06 <Tac-Work> it used lazy evaluation to go back in time
09:24:09 <chessguy> catBehemoth, there is a language called "miranda", which was the predecessor to haskell
09:24:49 <catBehemoth> well, maybe i came in to the right place then...
09:25:16 <SyntaxNinja> catBehemoth: if you type "/list" (without quotes) you'll get a list of channels you can join.
09:25:39 <chessguy> a very loooong list :)
09:26:00 <SyntaxNinja> /info #bed
09:26:02 <SyntaxNinja> er
09:26:14 <SyntaxNinja> anyway, that looks like a funny channel
09:27:07 <SyntaxNinja> wow, we're like the 11th largest channel
09:27:08 <catBehemoth> hmm, can you use unicode in haskell. I'm trying to create a little dictionary in japanese
09:27:16 <Tac-Work> yes
09:27:25 <Tac-Work> Haskell uses Unicode strings
09:27:44 <Tac-Work> > ""
09:27:45 <lambdabot>  "\12371\12435\12395\12385\12399"
09:27:48 <Tac-Work> see?
09:27:55 <catBehemoth> wow!
09:28:00 <Tac-Work> > ""
09:28:02 <lambdabot>  "\26684\22909\12356\12356\12376\12419\12394\12356\12363\65311"
09:28:29 <catBehemoth> ??
09:28:31 <Vq^> > "rksmrgs"
09:28:33 <lambdabot>  "r\228ksm\246rg\229s"
09:28:33 <Liskni_si> since when does this work in ghc?
09:28:45 <Vq^> :-o
09:28:48 <Tac-Work> > head ""
09:28:50 <lambdabot>  '\26085'
09:28:55 <abell> I just tried pasting it into ghci and it crashed my terminal :-(
09:29:10 <Tac-Work> abell: what did?
09:29:17 <catBehemoth> lanbdabol, i can see only digits from you
09:29:34 <catBehemoth>    ,    ...
09:29:49 <Tac-Work> lambdabot is a bot. It's printing out the escaped versions of the unicode characters
09:29:50 <dankna> well, many terminals are utf-8 but ghc's internal string rep is utf-32 (or you might as well think of it that way, at least)
09:30:03 <abell> Tried pasting a few of the funny looking chars in a string and ghci stopped working. I had to Ctrl-Z it
09:30:07 <dankna> so you have to know how your OS handles that sort of thing, heh.
09:30:32 <Tac-Work> danka: is it really utf-32?
09:30:40 <Tac-Work> I didn't think utf-32 was very common
09:30:46 <Tac-Work> but then again, I don't know much about it
09:30:48 <abell> So is a string an array of unicode-characters?
09:30:56 <Tac-Work> abell: yes, it is
09:31:03 <Tac-Work> a Char is a unicode char
09:31:15 <catBehemoth> hey guys thanks for ur help, got to go home! tho i'll drop by again!
09:31:31 <dankna> it's not very common, and I'd be interested in knowing why they did it that way... conceptual purity or something, I guess
09:31:35 <catBehemoth> ki o tsukete!
09:31:36 <byorgey> bye catBehemoth!
09:31:52 <abell> Has it always been this way? I had the impression I had looked into the issue and only seen 8-bit chars
09:32:19 <dankna> not sure how long it has been, sorry.  I only looked into it a few months ago, so it could be pretty recent.
09:33:31 <Liskni_si> abell: it doesn't seem to be this way in 661
09:34:05 <ddarius> abell: Char has always been 32-bits (at least), but the IO routines don't care.
09:34:27 <dankna> oh right... sorry, should have clarified that.  the IO routines only deal with the low 8 bits.
09:34:33 <quicksilver> the underlying storage of char is OS-dependent
09:34:40 <quicksilver> or even compiler-dependent, possibly
09:34:51 <quicksilver> ghc + gcc uses wchar32
09:34:57 <quicksilver> or whatever the correct name for that type is
09:35:03 <quicksilver> but you "shouldn't need to know"
09:35:17 <quicksilver> beyond the fact it faithfully represents unicode code points
09:35:50 <quicksilver> the travesty, however, is that putChar and getChar (and friends) are really putByte and getByte
09:35:51 <dankna> well... the only reason it matters is that you have to convert by hand when you do output
09:35:56 <dankna> right, exactly
09:36:02 <Tac-Work> Unicode may be useful off in Europe and Asia, but thankfully us yanks never have to deal with non-ascii characters
09:36:14 <dankna> Tac - I sincerely hope that was sarcasm :)
09:36:42 <Tac-Work> It was more an excuse for my ignorance of the subject ;-)
09:36:46 <dankna> hah okay
09:36:57 <dankna> anyway, not gonna make that argument here and now :)
09:37:07 <quicksilver> of course it's not remotely trivial to write putUTF8Char
09:37:09 <Tac-Work> Unicode is scary, and I'm just glad there are brave souls who make it so my JME works for 90% of what I try it in
09:37:14 <abell> Being Italian, I would be contented with ISO-8859-1
09:37:26 <quicksilver> since that requires you to have full knowledge of UTF8 to write it
09:37:47 <dankna> it isn't actually that hard, I have my own implementation and you'll find several implementations of it on hackage as well (at least one standalone and one as part of, uh, hdbc I think it was)
09:37:47 <quicksilver> abell: then you're mostly OK, since ISO-8859-1 almost coincides with the least significant 8 bits of unicode code point
09:38:16 <quicksilver> dankna: no it's not that hard. But you do need to go look up the code-point-to-UTF8 rules :)
09:38:21 <dankna> yes, absolutely )
09:38:25 <ddarius> abell: Then you wouldn't be able to write stuff like .. etc.
09:38:34 <dankna> okay, so nontrivial then.  as you said :)
09:38:36 <chessguy> anybody know of a haskell implementation of the levenshtein distance algorithm?
09:38:43 <ddarius> chessguy: lambdabot
09:38:45 <abell> I am not able to read it anyway (I guess missing fonts)  :-)
09:38:53 <quicksilver> @losers
09:38:53 <conal> @go levenshtein distance
09:38:53 <lambdabot> Maximum users seen in #haskell: 420, currently: 389 (92.6%), active: 18 (4.6%)
09:38:55 <lambdabot> http://en.wikipedia.org/wiki/Levenshtein_distance
09:38:55 <lambdabot> Title: Levenshtein distance - Wikipedia, the free encyclopedia
09:38:57 <quicksilver> ^^ proof!
09:39:09 <chessguy> conal, that doesn't have a haskell implementation
09:39:40 <ddarius> chessguy: lambdabot uses the Levenshtein distance to "fix" "mistyped" commands.
09:40:02 <chessguy> ddarius, yeah, but i bet that's going to be a bear to find
09:40:21 <ddarius> lambdabot isn't that big
09:40:23 <twanvl> See: http://www.cse.unsw.edu.au/~dons/lambdabot/Lib/Util.hs
09:40:24 <conal> chessguy: the "@go" was for me.  i didn't know what "Levenshtein distance" is.
09:40:35 <chessguy> aha
09:41:31 <DukeDave> chessguy: Just a sec, I think I do
09:42:27 <chessguy> ah, found it
09:42:27 <liyang> chessguy: I've a C implementation but I doubt you'd be interested. :3
09:42:40 <conal> I wonder why darcs doesn't use Levenshtein distance.
09:42:59 <chessguy> liyang, nah, there are lots of imperative implementations, most of which could easily be directly translated from that wikipedia page
09:43:10 <ivan`> it's N^something?
09:43:15 <dankna> because all it gives you is a distance and not the patch to achieve it
09:43:19 <chessguy> http://www.cse.unsw.edu.au/~dons/lambdabot/Lib/Util.hs has the lambdabot one
09:43:28 <dankna> so for diff-like things you need a longest-common-subsequence thingy
09:44:09 <chessguy> class Diff?
09:44:24 <dankna> not sure what you're referring to; I was answering Conal's question
09:45:05 * liyang wants XDiff bindings but doesn't know enough FFI to write one. (Nor have the time to look into it.)
09:45:42 <liyang> And the ability to compose xdiff patches (it's an RFC apparently) would be cool.
09:46:11 <chessguy> @unpl (fromEnum .) . (/=)
09:46:11 <lambdabot> (\ d g -> fromEnum (d /= g))
09:46:16 <dankna> sorry, what's xdiff, a gui tool?
09:46:30 <chessguy> eh?
09:46:42 <liyang> dankna: binary diff, essentially.
09:46:50 <dankna> oh, then indeed, that would be nice to have!
09:47:14 <hpaste>  DukeDave pasted "Levenshtein limit" at http://hpaste.org/3327
09:47:16 <liyang> It doesn't claim any sort of optimality.
09:47:22 * dankna nods
09:47:23 <chessguy> > ((fromEnum .) . (/=)) 'a' 'a'
09:47:28 <lambdabot>  0
09:47:33 <chessguy> > ((fromEnum .) . (/=)) 'a' 'b'
09:47:34 <dankna> sure.  but I imagine it's still at least decent.
09:47:34 <lambdabot>  1
09:47:42 <chessguy> > ((fromEnum .) . (/=)) 'a' 'w'
09:47:43 <lambdabot>  1
09:47:44 <liyang> But it would be nice if you could take two patches and compose them into a single, potentially smaller patch.
09:47:54 * dankna nods
09:48:03 <liyang> And that as far as I know hasn't been implemented.
09:48:15 <liyang> And I want to. But I don't have the time. Aaargh.
09:48:31 <dankna> yeah, very familiar with that frustration
09:49:04 <liyang> (And then use it to build a flux ca^W^Wbetter Time Machine clone.)
09:49:12 <dankna> mmhm.
09:49:17 <chessguy> lol
09:50:43 <liyang> 1.21 jiggawatts @ 88MPH -- it's not just sensible, it's the LAW!
09:50:52 <roconnor> @seen conal
09:50:52 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 8m 12s ago.
09:51:01 <conal> roconnor: yo!
09:51:37 <roconnor> conal: I got a tiny bit of phooey ported to Gtk-hs
09:51:45 <conal> roconnor: awesome. :)
09:52:08 <roconnor> runUI (stringEntry "Initial String" >>= stringDisplay) works
09:52:08 <conal> roconnor: run into any difficulties?
09:52:15 <conal> :)
09:52:22 <roconnor> actually that program doesn't work under my wxHaskell
09:52:34 <roconnor> the stringDisplay never changes :(
09:52:39 <conal> :p
09:53:08 <roconnor> is that program I give, supposed to only update the display when enter is pressed in the input box, or is it supposed to constantly update?
09:53:17 <roconnor> (I don't have a working wxHaskell reference)
09:53:31 <conal> roconnor: enter
09:53:34 <abell> BTW, what's the state of wxHaskell?
09:54:07 <roconnor> abell: AFAIK unsupported, but can be build with some difficulties.
09:54:22 <roconnor> conal: It's a bit distrubing how easy the port has been going so far.
09:55:05 <conal> abell: Daan Leijen told me at ICFP that he's going to start supporting wxHaskell again.
09:55:28 <roconnor> that name sounds dutch.
09:55:30 <abell> conal: good to know. I'd like to port a wxPython program to haskell, but I can't risk it being unstable
09:55:48 <conal> abell: sure.
09:55:51 <malcolmw> cool - but does he know about the other people who are already maintaining wxHaskell?
09:56:06 <roconnor> malcolmw: other people?
09:56:34 <conal> roconnor: yep.  daan is dutch.  he's the original author of wxHaskell (and parsec & other cool libs)
09:56:46 <malcolmw> roconnor: there are some people, including Eric Kow, who post patches on the wxHaskell mailing list, and maintain a darcs repo
09:56:46 <conal> malcolmw: gee, i hope so.
09:57:42 <Saul_> @seen oerjan
09:57:42 <lambdabot> I saw oerjan leaving #haskell 16h 55m 38s ago, and .
09:57:55 <roconnor> conal: other than your weird original code inside iwidget', everything has been fine so far.
09:58:03 <roconnor> I just got rid of the weirdness.
09:58:16 <roconnor> (for now)
09:59:29 <visof> i couldn t understand this -> or <- or this >>= , can anyone help me?
09:59:47 <hpaste>  conal pasted "iwidget'" at http://hpaste.org/3328
09:59:51 <conal> roconnor: :)  i just hpasted my current version.
10:00:12 <conal> roconnor: how does yours compare?
10:00:49 <ddarius> visof: Read any comprehensive Haskell tutorial/introduction/book.
10:01:30 <hpaste>  roconnor annotated "iwidget'" with "my gtk2hs version" at http://hpaste.org/3328#a1
10:01:39 <conal> roconnor: thanks
10:01:45 <roconnor> So I don't do the setting twice thing
10:01:54 <roconnor> nor do I call the event handler
10:01:57 <visof> what is meaning of polymorphic functions?
10:02:05 <roconnor> ... mostly because I don't know how to do it.
10:02:10 <MyCatVerbs> visof: five pounds of flax!
10:02:17 <MyCatVerbs> (Wait, wrong story, nevermind.)
10:02:27 <roconnor> MyCatVerbs: not helpful :(
10:02:57 <roconnor> visof: polymorphic functions are functions where some parameters can be any type at all
10:03:02 <roconnor> @type head
10:03:04 <kosmikus> conal, malcolmw: I'm pretty sure Daan knows about the current wxHaskell maintainers.
10:03:04 <lambdabot> forall a. [a] -> a
10:03:10 <MyCatVerbs> visof: polymorphic functions are functions with types like map :: (a->b) -> [a] -> [b]
10:03:28 <MyCatVerbs> There are variables in the type signature of that function.
10:03:35 <ddarius> polymorphic functions are also covered in any decent introduction/tutorial/book on Haskell
10:03:48 <conal> roconnor: what's a Gtk.ConnectId ?
10:04:08 <MyCatVerbs> For example, you could be transforming a list of Chars into Integers with a function converting characters to their UTF32 numbers.
10:04:11 <conal> some kind of handle to a control?
10:04:16 <roconnor> conal: it is a handle to let you disconnect the event handler later
10:04:26 <roconnor> conal:  maybe there are other things you can do with it.
10:04:31 <MyCatVerbs> Or you could be transforming a list of lists into exactly the same lists... backwards. :)
10:04:52 <conal> roconnor: oh.  nice.
10:05:08 <MyCatVerbs> visof: make any sense, or should I go find some gin and try to explain that again?
10:05:09 <roconnor> event handlers are cummlative
10:05:21 <roconnor> ... which I sort of get the impression is not the case in wxHaskell.
10:06:00 <visof> Mycatverbs i ll read the tutorial
10:06:04 <conal> roconnor: wxHaskell has := and :~ .  The former overwrites, and the latter lets you accumulate.
10:06:20 <roconnor> ah
10:06:26 <visof> Mycatverbs thanks anyway
10:06:46 <roconnor> this difference would worry me, except I get the impression that structure in Phooey is static.
10:06:50 <chessguy> @remember MyCatVerbs does that make any sense, or should I go find some gin and try to explain that again?
10:06:50 <lambdabot> Done.
10:06:55 <roconnor> ... but maybe it is just static in the examples I've seen
10:07:13 <MyCatVerbs> visof: "head" is a better example. It has type [a] -> a.
10:07:26 <conal> roconnor: listeners can go away.  that's why ephemeral.
10:07:53 <conal> roconnor: happens in Eros.
10:07:56 <roconnor> conal: how do they go away?
10:08:03 <MyCatVerbs> visof: it takes a list of... something, and returns the first element of that list. The variable 'a' in its type tells you that "head" works on lists of anything.
10:08:44 <conal> roconnor: close a TV being influenced by another TV.
10:09:04 <roconnor> what does closing a TV mean?
10:09:18 <conal> roconnor: and all TVs influence each other, in that when you start a fusion in one, the others may highlight
10:09:26 <MyCatVerbs> roconnor: you get a .45 and you let rip. :)
10:09:30 <visof> Mycatverbs so the head function with argument with any type , and this function is called polymorphic ?
10:09:51 <conal> roconnor: hm.  deep question.
10:10:11 <roconnor> :)
10:10:14 <MyCatVerbs> visof: yes. "head" only works on the list structure, and doesn't care what the lists are of.
10:10:18 <roconnor> maybe I should worry about it later
10:10:35 <conal> roconnor: in Eros, each TV is in an MDI child window, along with others.
10:10:48 <roconnor> indeed
10:10:57 <roconnor> oh and windows close!
10:11:06 <conal> roconnor: exactly.
10:11:11 <roconnor> scary
10:11:14 <kosmikus> ;)
10:11:19 <MyCatVerbs> visof: another good example is the "length" function, which has type [a] -> Int.
10:11:23 <conal> roconnor: as long as event handlers are installed cumulatively, not destructively, all should be fine.
10:11:42 <roconnor> conal: but upon close, things should get cleaned up
10:11:49 <roconnor> ... ah hence the ephemeral thing?
10:11:56 <conal> roconnor: exactly.
10:12:18 <roconnor> ... but that means I need to teach DataDriven how to disconnect an event handler?
10:12:25 <MyCatVerbs> visof: length doesn't care what type the things inside the list are, because it's only counting them and not having to actually touch them. So you don't need to rewrite a seperate version of "length" for every single data structure you could package inside a list.
10:12:37 <MyCatVerbs> Just the one works on all of them.
10:12:58 <conal> roconnor: mkEvent uses ephemeral
10:13:12 <conal> mkEvent modifySink = Cont (ephemeral >=> modifySink . flip mappend)
10:13:20 <liyang> MyCatVerbs: but what if I want to count in unary instead of your totalitarian 32-bit integers?!
10:13:41 <roconnor> conal: yeah, I sort of ignored mkEvent for the moment 'cause I didn't understand it
10:13:48 <conal> ephemeral lets the garbage collector deactivate a listener.  the mappend acumulates listeners.
10:13:50 <MyCatVerbs> liyang: then implement your own version of length with type [a]->Integral. That's trivial :P
10:14:38 <conal> roconnor: the current implementation is not ideal.  the deactivated listeners ("tombstoned" weak pointers) still take time to skip over.
10:14:49 <liyang> (I was hinting at genericLength but was more itching to get the unary / totalitarian gag out. Apologies for the bad joke. :3)
10:15:14 <roconnor> what is the type of mkEvent?
10:16:44 <MyCatVerbs> liyang: oh, right.
10:17:01 <hpaste>  conal pasted "mkEvent" at http://hpaste.org/3329
10:17:11 <MyCatVerbs> liyang: genericLength :: Foldable a, Integral b => a -> b
10:17:58 <conal> roconnor: simple answer: "mkEvent :: Sink (Sink a -> Sink a) -> Event a".  longer answer in paste.
10:18:43 <liyang> Wow. genericLength was just Integral b => [a] -> b last I looked! Glad to see it improved.
10:18:46 <roconnor> conal: and where does the ``finalizer'' fit into that type?
10:19:03 <smack__> @src genericLength
10:19:04 <lambdabot> genericLength []    = 0
10:19:04 <lambdabot> genericLength (_:l) = 1 + genericLength l
10:19:19 <liyang> (I know, that's Data.Foldable.genericLength and I was talking about Data.List.genericLength.)
10:19:24 <roconnor> ((a -> IO ()) -> (a -> IO ())) -> IO ()
10:20:24 <MyCatVerbs> liyang: oh.
10:20:46 * roconnor ponders that type
10:21:02 <MyCatVerbs> I was thinking Data.Foldable.foldl' (\_ b -> b + 1) 0
10:22:07 <MyCatVerbs> @pl (\a b->b+1)
10:22:07 <lambdabot> const (1 +)
10:22:19 <MyCatVerbs> Hmm, clever.
10:22:19 <liyang> roconnor: how would you conjure up an a out of nothing? Assuming that function actually does something with its first argument.
10:23:16 <roconnor> liyang: this is parameter, the whole function is  (((a -> IO ()) -> (a -> IO ())) -> IO ()) ->  Event a
10:23:27 <byorgey> crazy.
10:23:35 <dankna> that's quite a type
10:24:01 <roconnor> dankna: probably why conal writes it as: Sink (Sink a -> Sink a) -> Event a
10:24:14 * dankna nods
10:24:15 <liyang> roconnor: crazy indeed. At that point I'd start using type synonyms just so I won't have to spend five seconds thinking about it every time I look at it. :-/
10:24:37 <hpaste>  conal annotated "mkEvent" with "mkEvent example" at http://hpaste.org/3329#a1
10:25:33 <MyCatVerbs> liyang: you can get through that in five seconds? Impressive. :)
10:26:14 <hpaste>  conal annotated "mkEvent" with "modifyAttr def" at http://hpaste.org/3329#a2
10:26:16 * roconnor 's gears start grinding in his head
10:26:38 <liyang> MyCatVerbs: on second reading. ^^; And most of the time is trying to figure out exactly what the brackets group. :3
10:26:41 <roconnor> conal: I saw this before, but it is beginning to make more sense to me now
10:27:01 <roconnor> conal: the trick is that the new event handler may make use of the old event handler?
10:27:35 <roconnor> wait, but what if there is not old event handler? ... that is just const (return ()) I guess.
10:27:41 <conal> roconnor: yes.  "modifySink . flip mappend" is how i make accumulate listeners.  the new listener is a mappend of the old one with the added one.
10:27:46 <MyCatVerbs> liyang: I'll give up vi's % command when you come and pry it from my cold, dead fingers.
10:27:52 * liyang notes the one with the sinks is much easier to read. At least it gives you some idea of what it might do. Let's not worry about enforcing that for now...
10:27:56 <MyCatVerbs> ...possibly sooner than that. My hands happen to be cold anyway.
10:28:01 <conal> roconnor: yep.  also written "mempty"
10:28:12 <conal> i love Monoid
10:28:23 * roconnor tries to think how to do this with connectionIds
10:29:02 <liyang> MyCatVerbs: yeah but I'm in irssi, not vim. (Which highlights the corresponding bracket when you put the cursor on either one. =)
10:29:14 <roconnor> @seen dcoutts
10:29:14 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 3h 24m 55s ago.
10:29:18 <roconnor> @seen dcoutts_
10:29:19 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 5h 37m 16s ago.
10:29:20 <dcoutts> hia roconnor
10:29:55 <MyCatVerbs> liyang: ...bah, humbug. This calls for a highlighting irc client. :)
10:30:06 <liyang> Haskell-aware IRC client.
10:30:07 <roconnor> dcoutts: suppose I have an eventHandler's connectionId.  It is possible to get my fingers on the IO () from that?
10:30:35 <roconnor> dcoutts: ... maybe I need to keep the IO action in my hands myself.
10:30:37 <conal> roconnor: as i mentioned, my implementation is not ideal when listeners can die.  the dead listeners get treated as mempty's, which takes time.
10:30:50 <liyang> MyCatVerbs: and tell me about it. I'm cold, not wet yet but will be as soon as I venture outside, and I've a splitting headache. I love the British Isles.
10:31:16 <MyCatVerbs> liyang: but I wouldn't have a clue what to call it. irCatamorphism?
10:31:20 <roconnor> conal: where does that happen?
10:31:28 <MyCatVerbs> liyang: oh, I have a solution to that.
10:31:34 <MyCatVerbs> liyang: I love miserable weather.
10:31:43 <conal> roconnor: it's all encapsulated in Data.Ephemeral.
10:32:11 <conal> roconnor: four simple functions.  the heart is tryWeakWith.
10:32:13 <roconnor> conal: ooh, so you require () to be a monoid.
10:32:24 <MyCatVerbs> liyang: I just forced myself to learn to like it, because, well, I live in Britain. My choices were either to learn to love cold, wet weather, or be miserable 24/7. :)
10:32:31 <conal> roconnor: yep, and IO a for monoids a.
10:32:33 <dcoutts> roconnor: there's not just one IO () in a signal handler, there can be many
10:32:57 <dcoutts> roconnor: connecting a signal handler is cumulative, it does not destroy existing handlers
10:32:59 <liyang> I was pondering potential cat names actually (I want a cat) and Cata came out as one with lots of potential.
10:33:02 <roconnor> dcoutts_: but there is presumably only one for a connectionID?
10:33:09 <dcoutts> roconnor: yes
10:33:32 <conal> dcoutts: do connectionIDs let one remove a specific handler out of many?
10:33:35 <roconnor> but there presumably is not way to recover the IO() from that.
10:33:37 <dcoutts> roconnor: but if you got the connectionID then presumably you connected it, so you've also got the action you connected
10:33:50 <liyang> MyCatVerbs: what's to say I've not learned to like it? That in no way takes away any of my rights to whinge about it. <grin>
10:33:51 <roconnor> dcoutts: yeah, I sort of just realized that :P
10:34:14 <MyCatVerbs> liyang: kitties! <3!
10:34:16 <reilly> liveness is over-rated
10:34:18 <dcoutts> conal: yes, when you connect a handler you get a connectionId back and you can use that to disconnect the signal
10:34:39 <MyCatVerbs> liyang: yerf, but loving it does take away mine. :)
10:34:43 <conal> dcoutts: nifty.  is that a gtk abstraction or a gtk2hs abstraction?
10:34:45 * liyang is worried about a potential Cata morphing his sofa.
10:34:51 <dcoutts> conal: a gtk abstraction
10:35:10 <MyCatVerbs> liyang: bastard! XD
10:35:30 <conal> dcoutts: cool.
10:36:01 <dcoutts> conal: another reason for 'on' to be a stand alone function rather than an attribute, so one can get the connectionID (though admitidly it's not often that one wants to disconnect so you usually ignore the result)
10:36:33 <roconnor> dcoutts: given a ConnectionID, how do I disconnect?
10:36:54 <conal> dcoutts: makes sense to me.
10:37:10 <dcoutts> roconnor: using disconnect :-)
10:37:26 <dcoutts> roconnor: hint: go to the gtk2hs site and use the api search (it's hoogle)
10:37:26 <liyang> (This came about either after realising I couldn't have a pet alien called Endo, or from the fact that I'm feeling ill. Or both.)
10:37:32 <roconnor> signalDisconnect
10:37:40 <roconnor> oh, there is a search!
10:37:52 <conal> dcoutts: would you please point me to the source or haddock docs about this signal/connectionID stuff?
10:38:14 <dcoutts> roconnor: oh yes, we changed the name from disconnect to signalDisconnect
10:38:31 <conal> dcoutts: (i have a recent-ish version of the gtk2hs sources on my computer)
10:39:10 <dcoutts> conal: glib/System/Glib/Signals.chs.pp
10:39:36 <conal> dcoutts: thanks.  what's a .chs.pp ?
10:39:46 <dcoutts> conal: see also glib/System/Glib/Attributes.hs and glib/System/Glib/Properties.chs
10:39:56 <conal> dcoutts: got it
10:40:09 <dcoutts> conal: .chs is a module that get's pre-processed by c2hs the C -> Haskell FFI tool
10:40:29 <dcoutts> conal: .pp is a file that gets pre-processed with cpp the C pre processor
10:40:46 <conal> dcoutts: thanks
10:42:02 <dcoutts> conal: gtk allows us to get a signal whenever a gtk widget's property changes
10:42:33 <dcoutts> conal: but a problem we have is that we represent our attributes as getter/setter functions, not string named gtk properties
10:43:13 <dcoutts> so we'll have to think how to best take advantage of gtk's ability to connect a signal to the change of a widget property
10:43:43 <dcoutts> because gtk wants the property name as a string
10:44:29 <dcoutts> or we could also add a signal connection function into our representation of an attribute
10:44:51 <dcoutts> but not all attributes can give us change notification, we might have to use a type class or something
10:45:08 <dcoutts> conal: if you've got any good suggestions ... :-)  how does wx do it?
10:45:23 <dcoutts> conal: does wx allow you to be notified whenever a widget attribute changes?
10:45:30 <dcoutts> is there a generic mechanism for that?
10:45:47 * conal thinks
10:45:49 <hpaste>  roconnor annotated "mkEvent" with "attempt at gtk2hs version of wEvent" at http://hpaste.org/3329#a3
10:46:19 <roconnor> except I don't know where to get oldId and oldHandler from, nor where to put newId and newHandler
10:46:32 <roconnor> Perhaps the solution is not to use mkEvent at all
10:46:41 <conal> roconnor: why disconnect?
10:46:56 <roconnor> conal: mkEvent is supposed to destructively update the handler right?
10:47:00 <conal> roconnor: oh.
10:47:45 <conal> roconnor: hm.  an artificial problem, fitting gtk & a wx-friendly phooey.
10:47:54 <hpaste>  roconnor annotated "mkEvent" with "forgot to finish the last line" at http://hpaste.org/3329#a4
10:48:20 <conal> roconnor: since the modifier mappends the old listener & the one being added.
10:48:54 <roconnor> conal: right, so there should be a nice way to tease this together.
10:49:33 <conal> roconnor: yes.  maybe a design tweak on my end.  sacrifice some generality and wire in the mappend semantics.
10:49:34 <roconnor> basically we shouldn't have to run though hoop to get gtk2hs to modify destructive just so we can modify non-destructively
10:49:42 <conal> roconnor: !
10:50:56 <visof> when i do the first Example http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output i has  has.hs:3:8: Not in scope: `getline' Failed, modules loaded: none.
10:50:58 <lambdabot> Title: Haskell/Simple input and output - Wikibooks, collection of open-content textbook ...
10:51:51 <roconnor> conal: if the modifer mappends, how does ephemeral manage to cut out only the listeners that have gone away?
10:52:04 <allbery_b> visof: "getline" is not "getLine", did you typo here or in your program?
10:52:45 <conal> roconnor: it doesn't cut them out.  tombstoned listeners get interpreted as mempty (see tryWeak).
10:53:09 <visof> i typed getLine
10:53:35 <conal> roconnor: hence a potential serious inefficiency.
10:53:55 <allbery_b> @index getLine
10:53:55 <lambdabot> System.IO, Prelude
10:54:09 <roconnor> @hoogle tryWeak
10:54:09 <lambdabot> No matches found
10:54:24 <conal> roconnor: Data.Ephemeral, in DataDriven
10:54:37 <dcoutts> conal: so as I understand it you've had to work around the fact that in wx there is only one handler for a signal at once and setting a new one replaces the old?
10:54:39 <visof> what do i do?
10:54:41 <allbery_b> @paste the entire source file please?
10:54:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:54:49 <visof> is this error?
10:55:24 <roconnor> oh Data.Ephermeral is part of DataDriven, not part of the GHC standard libs
10:55:32 <conal> roconnor: right
10:56:07 <conal> roconnor: it's a simple layer on top of System.Mem.Weak (in base lib).
10:56:10 <newsham> Subject: FW: [Dailydave] Canada's Response to Black Hat - SecTor 2007
10:56:23 <newsham> what is cansec west?  chopped liver?
10:56:26 <visof> it s ok i did it
10:56:39 <byorgey> visof: it works now?
10:56:44 <visof> ya
10:57:17 <roconnor> conal: ah, so you try to run an callback, but if the callback doesn't exists, you run mempty = return mempty = return ()
10:57:53 <conal> roconnor: i'm interested in improving this design, perhaps with something like the signal handler collections that gtk uses.  but without tying to any kind of UI framework, since the Ephemeral stuff is much more general.
10:59:44 <conal> roconnor: i'm also noodling over a radically different approach to all of this reactivity stuff.  got inspired after a conversation with Mike Sperber in Freiburg.  His Lula system used multi-threading with blocking and "select".
11:00:33 <conal> roconnor: i don't think select is general enough, but maybe STM would fit.
11:00:39 <roconnor> oooh
11:03:08 <conal> roconnor: it might work out very elegantly.  not sure.  eliminate the notion of installing & removing event listeners.  instead, stop waiting (blocking) on them when we lose interest.
11:04:59 <roconnor> mkEvent aways forces listeners to be appended because of the mappend in it's definition?
11:05:13 <conal> roconnor: yes
11:05:34 <roconnor> intresting
11:05:38 <conal> roconnor: and the "flip" makes listeners get run in order of subscription.
11:06:06 <roconnor> but because gtk2hs is already managing this for us, we don't need to use mkEvent.
11:06:37 <conal> roconnor: i suppose that's so.  modulo ephemerality.  i guess that's what you've been telling me.  :)
11:07:33 <roconnor> conal: so we can probably lift this management of chains of listeners out of mkEvent, so that we can bypass it when using gtk2hs
11:08:01 <roconnor> somehow break mkEvent into two pieces, the chaining part, and the ephemeral part
11:08:09 <conal> roconnor: i think so.  and there's probably a simpler and more efficient way to handle ephemerality with gtk2hs.
11:08:23 <roconnor> okay, I'll think about this more later.
11:08:53 <conal> roconnor: see the weak pointer paper and memo tables in particular.  i think we'd do the same.
11:09:19 <conal> i.e., have the finalizer invoke signalDisconnect
11:09:34 <roconnor> precisely
11:10:02 <conal> then i can re-design the wxHaskell version to mimic the gtk2hs version.
11:10:22 <conal> fun :)
11:11:28 <conal> roconnor: i was thinking about a very similar design anyway.  some kind of collection whose "add" operation yielded a token for removal.  just like ConnectionID.
11:15:29 <conal> roconnor: btw, i think the new reactivity design (threads & blocking) also gives a very elegant & efficient way to fix the general problem that arose when you figured out your program kept getting market data over the web.
11:17:16 <pejo> conal, care to describe this reactivity design a little more?
11:18:27 <conal> pejo: i'll blog about it.  it'll help clarify my ideas as well as invite comments.
11:28:51 <visof> i couldn t understand what is pattern matches?
11:29:39 <roconnor> conal: why would threads and blocking make the web access thingy more elegant?
11:31:08 <dmwit> visof: Pattern matching is just writing functions based on what constructor is used:
11:31:24 <dmwit> data Tree a = Node a | Branch (Tree a) (Tree a)
11:31:34 <dmwit> f (Node a) = [a]
11:31:43 <dmwit> f (Branch l r) = f l ++ f r
11:31:59 <dmwit> Here, the (Node a) and (Branch l r) are pattern matches against the two possible tree constructors.
11:32:17 <dmwit> Pattern matching can be arbitrarily nested, i.e. you could potentially write a function that looked at two levels of the tree at once:
11:32:47 <dmwit> f (Branch (Branch l r) (Node a)) = -- ... handle a tree with a left-hand tree, but only a node on the right
11:33:09 <dmwit> (Though, of course, the more nesting there is, the more possible cases you have to cover.)
11:33:24 <visof> is fst ans snd pattern matches?
11:33:36 <dmwit> fst and snd are functions, but they are written using pattern matches.
11:33:55 <dmwit> fst (a, _) = a -- (a, _) is a pattern match against two-element tuples
11:34:14 <TomMD> @src snd
11:34:14 <lambdabot> snd (_,y) =  y
11:34:28 <dmwit> visof: See also http://www.haskell.org/tutorial/patterns.html
11:34:29 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
11:34:35 <conal> roconnor: hard to explain succinctly.  and maybe there are two separable ideas here.
11:35:16 <roconnor> fair enough
11:42:00 <roconnor> I think people are missing the main result of the ICFP contests
11:42:27 <roconnor> If there is anything consistent between the contest years, it is who the winners are, rather than what the programming language is.
11:42:27 <Tac-Tics> what is the main result of the ICFP contest?
11:42:44 <roconnor> I bet team smartass would win no matter what language you forced them to use.
11:43:03 <phlpp> hm, i now it sounds stupid, but i have some problems writing a very simple function (because i'm coming from a bunch of imperative languages..).. lets take an more abstract example: i want to write a function, which runs endless (thanks to lazyness), and though produces a list of numbers
11:43:07 <roconnor> (or at least finish in the top 3)
11:43:21 <byorgey> phlpp: ok.
11:43:23 <mauke> proceed.
11:43:25 <Philippa> malbolge?
11:43:41 <phlpp> so a number is added by her palindrome, and the result of this is the new number, which is also added to his palin
11:44:23 <phlpp> but i have some difficulties to define the function, that i can deliver a number as an argument, not an list
11:44:34 <mauke> iterate (\x -> x + palin x)
11:44:39 <kscaldef> phlpp: so, you keep doing that to produce the list?
11:44:46 <phlpp> kscaldef: yeah
11:44:51 <phlpp> lets take an example
11:44:56 <vincenz> iterate (\problem -> #haskell problem)
11:45:29 <mauke> > let palin = read . reverse . show in iterate (\x -> x + palin x) 123
11:45:31 <phlpp> number is 349, so we got this: 349 + 943 = 1292; 1292 + 2921 = 4213; 4213 + 3124 = 7337 -- PALIN!
11:45:31 <lambdabot>  [123,444,888,1776,8547,16005,66066,132132,363363,726726,1354353,4888884,9777...
11:46:05 <mauke> > let palin = read . reverse . show in takeWhile (\x -> x /= palin x) $ iterate (\x -> x + palin x) 349
11:46:06 <lambdabot>  [349,1292,4213]
11:46:48 <dmwit> > let palin = read . reverse . show in head . dropWhile (\x -> x /= palin x) $ iterate (\x -> x + palin x) 349
11:46:50 <lambdabot>  7337
11:46:57 <vincenz> @pl (\x -> x /= foo x)
11:46:57 <lambdabot> ap (/=) foo
11:47:43 <vincenz> > let palin = read . reverse . show in takeWhile (ap (/=) pain) $ iterate (ap (+) palin) 13
11:47:44 <lambdabot>   Not in scope: `pain'
11:47:48 <vincenz> > let palin = read . reverse . show in takeWhile (ap (/=) palin) $ iterate (ap (+) palin) 13
11:47:50 <lambdabot>  [13]
11:48:07 <vincenz> > let palin = read . reverse . show in takeWhile (ap (/=) palin) $ iterate (ap (+) palin) 1243
11:48:09 <lambdabot>  [1243]
11:48:20 <mauke> needs less symmetry
11:48:22 <vincenz> > let palin = read . reverse . show in takeWhile (ap (/=) palin) $ iterate (ap (+) palin) 129
11:48:23 <lambdabot>  [129,1050]
11:48:27 <vincenz> you need to basically get a carry
11:48:38 <vincenz> > let palin = read . reverse . show in takeWhile (ap (/=) palin) $ iterate (ap (+) palin) 199
11:48:40 <lambdabot>  [199,1190,2101]
11:48:43 <vincenz> > let palin = read . reverse . show in takeWhile (ap (/=) palin) $ iterate (ap (+) palin) 999
11:48:44 <lambdabot>  []
11:48:48 * vincenz couhg
11:48:51 <vincenz> > let palin = read . reverse . show in takeWhile (ap (/=) palin) $ iterate (ap (+) palin) 899
11:48:52 <lambdabot>  [899,1897,9878,18667,95348,179707,887678,1764466,8409137,15728185,73910936,1...
11:48:59 <conal> roconnor: still there?
11:49:05 <vincenz> > let palin = read . reverse . show in length $ takeWhile (ap (/=) palin) $ iterate (ap (+) palin) 899
11:49:07 <lambdabot>  17
11:49:07 <phlpp> hm
11:49:36 <byorgey> phlpp: got that?  'iterate' gives you the infinite list resulting from applying a function over and over again.
11:49:42 <mauke> > let palin = read . reverse . show in map fst . takeWhile (ap (/=) tail . snd) . ap zipWith tail . iterate (\x -> x + palin x) $ 349
11:49:43 <lambdabot>  Couldn't match expected type `a -> b -> c'
11:49:46 <roconnor> conal: yep
11:49:58 <byorgey> phlpp: then 'takeWhile' lets you only keep the first part of the list, as long as some condition is fulfilled
11:50:37 <mauke> > let palin = read . reverse . show in map fst . takeWhile (ap (/=) tail . snd) . ap zip tail . iterate (\x -> x + palin x) $ 349
11:50:37 <lambdabot>   add an instance declaration for (Num [a])
11:50:53 <conal> roconnor: the new idea for reactivity is on my journal at http://conal.net/journal/#2007-10-10 (~ 1MB)
11:51:25 <byorgey> phlpp: ignore all the stuff about 'ap' =)
11:51:29 <phlpp> byorgey: yeah ok, i just thought it's possibile to do this without iterate (i didn't knew this before), so first i have to "translate" all this stuff here to "me" ;)
11:51:42 <mauke> @src iterate
11:51:42 <lambdabot> iterate f x =  x : iterate f (f x)
11:51:53 <byorgey> phlpp: well, you could write the recursion explicitly yourself.
11:52:01 <byorgey> phlpp: but that wouldn't be very idiomatic Haskell
11:52:36 <mauke> foo = iterate (\x -> x + palin x);   foo x = x : foo (x + palin x)
11:54:01 <mauke> > let palin = read . reverse . show in map fst . takeWhile (ap (/=) palin . snd) . ap zip tail . iterate (\x -> x + palin x) $ 349
11:54:03 <lambdabot>  [349,1292]
11:54:35 <vincenz> conal: did you have customize your blog to get it like that?
11:55:03 <conal> vincenz: yes.  it's tiddlywiki with some plugins.
11:55:19 <vincenz> I mean did you tweak a lot with tiddlywiky, or just installed some plugins
11:55:47 <conal> vincenz: just plugins.  i wrote a couple myself, including haskell syntax coloring.
11:55:54 * vincenz nods
11:55:57 <vincenz> it looks spiffy
11:56:14 <conal> vincenz: but even that (haskell coloring) was on top of another plugin.
11:56:17 <conal> :)
11:56:24 <mauke> > let palin = read . reverse . show in map fst . takeWhile (ap (/=) palin . snd) . ap zip (12 :) . iterate (ap (+) palin) $ 349
11:56:26 <lambdabot>  [349,1292,4213,7337]
11:56:30 <roconnor> conal: nice example of applicative functors
11:56:42 <conal> roconnor: :)
11:59:05 <byorgey> mauke: 12, eh? =)
11:59:35 <mauke> byorgey: do you like 10 better?
12:00:31 <byorgey> mauke: actually, I'm partial to 2396.
12:01:48 <byorgey> oh, wait, I see, it has to be a number which is its own palindrome =P
12:01:56 <vincenz> > let palin = read . reverse . show in takeWhile (ap (/=) palin) . iterate (ap (-) palin) $ 349
12:01:58 <lambdabot>  Exception: Prelude.read: no parse
12:02:04 <byorgey> I mean, a number which yields a palindrome when added to its reverse...
12:02:06 <byorgey> bah
12:02:24 <byorgey> > 2396 + 6932
12:02:25 <lambdabot>  9328
12:02:30 <mauke> > let palin = read . reverse . show in map fst . takeWhile (ap (/=) palin . snd) . ap zip (2396 :) . iterate (ap (+) palin) $ 349
12:02:31 <lambdabot>  [349,1292,4213,7337]
12:02:38 <mauke> psyche!
12:02:49 <byorgey> ok, now I'm officially confused =)
12:02:55 <vincenz> @let palin = read . reverse . show
12:02:56 <lambdabot> <local>:1:8:     Ambiguous type variable `a' in the constraint:       `Read a...
12:03:09 <phlpp> but, but when i'm 'forced' to ignore this ap stuff
12:03:09 <vincenz> @let palin (l :: [Integer]) = read . reverse . show $ l
12:03:09 <lambdabot>  Parse error in pattern
12:03:17 <vincenz> it seems
12:03:21 <vincenz> ap f g is a common pattern
12:03:34 <dmwit> :t ap f g
12:03:37 <lambdabot> Not in scope: `f'
12:03:37 <lambdabot>  
12:03:37 <lambdabot> <interactive>:1:5: Not in scope: `g'
12:03:43 <vincenz> :t \f g -> ap f g
12:03:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:03:52 <vincenz> it's the reader monad
12:04:10 <dmwit> That was unhelpful. =P  \f g -> ap f g === ap
12:04:17 <byorgey> phlpp: in this context, ap f g is the same as \x -> f x (g x)
12:04:30 <conal> or more generally,
12:04:31 <phlpp> hm, as i stated earlier, i'm sorry for my foolish understanding of haskell
12:04:31 <byorgey> for example, ap (+) palin is the same as \x -> x + palin x.
12:04:34 <conal> :t  (<*>)
12:04:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:04:49 <byorgey> phlpp: don't be!
12:04:59 <phlpp> but i didn't advacned to monads (in YAHT) yet, because i wanted to strenghten my "skills" in writing simple stuff like that
12:05:25 <byorgey> phlpp: don't let the pointless cowboys scare you off =)
12:06:39 <phlpp> hm, maybe i just try to "clear" my head, watching tv for an hour and then try again
12:06:46 <phlpp> i'm really confused at the moment
12:06:48 <vincenz> > ap (flip (!!)) (flip replicate 'a') 4
12:06:50 <lambdabot>  Exception: Prelude.(!!): index too large
12:07:10 <vincenz> > ap (flip (!!)) (flip replicate 'a' . (+1)) 4
12:07:11 <lambdabot>  'a'
12:07:44 <byorgey> phlpp: sure, sometimes taking a break and coming back later can be helpful.
12:07:55 <mauke> phlpp: do you understand (\x -> x + palin x)?
12:08:00 <phlpp> yeah
12:08:50 <vincenz> ap for reader monad :: (a -> b -> c) -> (a -> b) -> a -> c
12:09:26 <byorgey> phlpp: ok, do you understand what the 'iterate' function does?
12:09:27 <vincenz> @djinn (a -> b -> c) -> (a -> b) -> a -> c
12:09:27 <lambdabot> f a b c = a c (b c)
12:09:40 <vincenz> ap = s
12:10:00 <dmwit> bwuh
12:10:20 <byorgey> dmwit: I think vincenz means the S combinator.
12:10:26 <dmwit> Yes, I know.
12:10:42 <dmwit> I've worked through it before, too, so I know it's right.
12:10:42 <Taejo> @type ap
12:10:43 <byorgey> oh, sorry =)
12:10:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:10:48 <dmwit> It just blows me away each time. =P
12:10:51 <vincenz> :)
12:10:53 <byorgey> hehe
12:10:59 <vincenz> ap, const and id :)
12:11:13 <phlpp> what, i have to lookup source again. is there a function for ghci to get the source of a functioon?
12:11:16 <Taejo> @src ap
12:11:16 <lambdabot> ap = liftM2 id
12:11:20 <phlpp> like lambdabot does with @src
12:11:25 <dmwit> phlpp: nope
12:11:31 <phlpp> @src iterate
12:11:31 <lambdabot> iterate f x =  x : iterate f (f x)
12:11:39 <dmwit> phlpp: Though you can run \bot locally, if you like. =)
12:11:51 <phlpp> hehe
12:12:31 <Taejo> @pl \x y z -> x z (yz)
12:12:31 <lambdabot> const . flip flip yz
12:12:37 <Taejo> @pl \x y z -> x z (y z)
12:12:37 <lambdabot> ap
12:14:31 <phlpp> a
12:14:32 <phlpp> h
12:14:46 <phlpp> so iterate takes the previous result of the function application and applies the function to this
12:14:50 <phlpp> alright
12:15:02 <jf> template haskell question, anyone?
12:16:00 <jf> I'm trying to generate some class declarations, and they look OK but I get a parse error for the line after the splice
12:16:26 <byorgey> phlpp: right.  it ends up producing the list [x, f x, f (f x), f (f (f x)), ...] and so on.
12:16:45 <TomMD> :t (iterate iterate)
12:16:45 <lambdabot> TomMD: You have 1 new message. '/msg lambdabot @messages' to read it.
12:16:47 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
12:16:47 <lambdabot>       Expected type: (a -> a) -> a -> a
12:16:56 <roconnor> @source iterate
12:16:56 <lambdabot> iterate not available
12:17:00 <olsner> @type last . iterate
12:17:02 <lambdabot>     Couldn't match expected type `[a]'
12:17:02 <lambdabot>            against inferred type `a1 -> [a1]'
12:17:06 <roconnor> @src iterate
12:17:07 <lambdabot> iterate f x =  x : iterate f (f x)
12:17:09 <vincenz> iterate f x = x : iterate f (f x)
12:17:11 <vincenz> yeah
12:17:25 <omnId> @type (last .) . iterate
12:17:27 <lambdabot> forall a. (a -> a) -> a -> a
12:17:31 <roconnor> funny, I would have written iterate f x = x : map f (iterate x)
12:17:42 <vincenz> roconnor: why's that?
12:17:52 <roconnor> vincenz: no reason
12:17:57 <roconnor> it's probably worse
12:18:20 <vincenz> if f is strict
12:18:26 <vincenz> the first version is pretty decent
12:18:52 <mauke> :t let iterate f x = x : map f (iterate x) in iterate
12:18:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = a1 -> a
12:18:54 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
12:18:58 <vincenz> yo need an f
12:19:09 <vincenz> @type let iterate f x = x : map f (iterate f x) in iterate
12:19:11 <lambdabot> forall a. (a -> a) -> a -> [a]
12:19:56 <byorgey> phlpp: so applying iterate to your 'reverse, then add' function (\x -> x + palin x) will give you the list you want.
12:20:51 <byorgey> phlpp: then, as a separate step, if you want to stop at a certain point, you can use something like take or takeWhile.
12:20:58 <byorgey> laziness takes care of the rest.
12:28:24 <jf> Hmm, no-one here does TH?
12:29:07 <byorgey> jf: maybe paste your code on hpaste?  that way people can look and decide whether they are able to help or not.
12:29:12 <byorgey> @hpaste
12:29:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:29:46 <n00b> @lambdabot
12:29:46 <lambdabot> Unknown command, try @list
12:29:54 <n00b> @list
12:29:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:30:55 <n00b> @babel
12:30:55 <lambdabot>   bzzt.
12:31:09 <omnId> n00b: LB listens to /msgs if you want to poke around.
12:31:26 <Tac-Tics> @bf ++.
12:31:26 <lambdabot>  fd:21: hClose: resource vanished (Broken pipe)
12:31:47 <omnId> @help help
12:31:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:31:54 <Tac-Tics> @help bf
12:31:54 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
12:32:02 <n00b> @version
12:32:03 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
12:32:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:32:05 <Tac-Tics> @help hpaste
12:32:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:32:29 <omnId> command spellchecker.  The actual command is @paste
12:32:31 <omnId> @help paste
12:32:31 <lambdabot> paste. Paste page url
12:32:43 <n00b> @dict haskell
12:32:43 <lambdabot> Supported dictionary-lookup commands:
12:32:43 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
12:32:43 <lambdabot> Use "dict-help [cmd...]" for more.
12:33:12 <omnId> @vera tmtowtdi
12:33:14 <lambdabot> *** "tmtowtdi" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
12:33:14 <lambdabot> TMTOWTDI
12:33:14 <lambdabot>      There's More Than One Way To Do It (slang, PERL)
12:33:14 <lambdabot>  
12:33:51 <dons> ?yow!
12:33:51 <lambdabot> Is it NOUVELLE CUISINE when 3 olives are struggling with a scallop in a
12:33:51 <lambdabot> plate of SAUCE MORNAY?
12:33:52 <dons> ?users
12:33:53 <lambdabot> Maximum users seen in #haskell: 420, currently: 400 (95.2%), active: 19 (4.8%)
12:33:57 <n00b> @vera WYSIWYG
12:33:58 <lambdabot> *** "wysiwyg" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
12:33:58 <lambdabot> WYSIWYG
12:33:58 <lambdabot>      What You See Is What You Get (DTP)
12:33:58 <lambdabot>  
12:33:59 <dons> cool, 400.
12:34:07 <Tac-Tics> @versa haskell
12:34:08 <lambdabot> No match for "haskell".
12:34:15 <Tac-Tics> @versa diy
12:34:16 <lambdabot> No match for "diy".
12:34:32 <Tac-Tics> No do it yourself?
12:34:37 <Tac-Tics> @versa RTFM
12:34:39 <lambdabot> *** "rtfm" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
12:34:39 <lambdabot> RTFM
12:34:39 <lambdabot>      Read The Flaming / Fucking Manual (telecommunication-slang, Usenet,
12:34:39 <lambdabot>      IRC)
12:34:39 <lambdabot>  
12:35:10 <omnId> @wn prestidigitation
12:35:11 <lambdabot> *** "prestidigitation" wn "WordNet (r) 2.0"
12:35:11 <lambdabot> prestidigitation
12:35:11 <lambdabot>      n : manual dexterity in the execution of tricks [syn: {sleight
12:35:11 <lambdabot>          of hand}]
12:36:36 <jf> byorgey: haha, yes, that helped immensely: In copying it to the paste, I saw what the error was!
12:37:12 <byorgey> jf: hehe, awesome. =)   I think it's the same principle as doing math on a blackboard.
12:37:43 <jf> Cheerio
12:37:49 <phobes> I always get more stupider at the blackboard
12:38:13 <byorgey> phobes: really?  when people are watching, or even by yourself?
12:38:27 <phobes> I guess I don't use the blackboard when people aren't watching :)
12:38:35 <byorgey> well, that's your problem then!
12:39:04 <byorgey> doing anything with people watching is difficult unless you're really used to it.
12:39:09 <phobes> ya
12:42:17 <phlpp> byorgey: (sorry, i'm watching tv at the moment) yeah, ok, thats clear to me
12:43:12 <phlpp> but one issue is left: how do i now write a function, that stops if an element in the produced list is the same as its palindrom?
12:43:23 <phlpp> i think that was this confusig ap stuff? ;)
12:43:24 <byorgey> phlpp: that's what takeWhile is for
12:43:33 <byorgey> phlpp: are you familiar with takeWhile?
12:43:38 <byorgey> phlpp: no, ap is not necessary.
12:43:43 <mauke> takeWhile (\x -> x /= palin x) tehList
12:44:30 <byorgey> phlpp: (takeWhile p list) only takes elements from list as long as the function p returns True when applied to them.
12:44:47 <byorgey> > takeWhile odd [1,3,7,9,12,5,9]
12:44:49 <lambdabot>  [1,3,7,9]
12:45:00 <byorgey> in that example, it stopped as soon as it hit 12, which isn't odd.
12:45:17 <phlpp> ah ok
12:45:30 <mauke> > takeWhile (< 10) [1 ..]
12:45:31 <lambdabot>  [1,2,3,4,5,6,7,8,9]
12:45:58 <byorgey> and as my excellent assistant ;) has also demonstrated, it works perfectly well on infinite lists
12:46:35 <mauke> > filter (< 10) [1 ..]
12:46:39 <lambdabot> Terminated
12:46:46 <byorgey> ...whereas filter does not.
12:47:23 <phlpp> ah!
12:47:31 <byorgey> the reason being that 'filter' includes everything that satisfies the predicate, whereas takeWhile stops as soon as it finds something that doesn't.
12:47:48 <phobes> > filter (> 10)  [1 ..]
12:47:50 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
12:48:04 <mauke> > takeWhile (> 10) [1 ..]
12:48:05 <lambdabot>  []
12:48:11 <omnId> > take 9 (filter (< 10) [1..])
12:48:15 <lambdabot> Terminated
12:48:25 <omnId> > take 8 (filter (< 10) [1..])
12:48:26 <lambdabot>  [1,2,3,4,5,6,7,8]
12:48:41 <byorgey> hmm, that's... odd
12:48:55 <phobes> The problem with filter is the 11th element
12:49:01 <omnId> it works until you hit the no-mans land
12:49:04 <mauke> works here
12:49:15 <mauke> hangs on take 10
12:49:24 <byorgey> yeah, for me too
12:49:32 <mauke> > take 9 (filter (< 10) [1..])
12:49:38 <alexj> any reason why Network.URI would be missing from a random install of GHC?
12:49:39 <lambdabot> Terminated
12:49:40 <byorgey> bizarre
12:49:50 <mauke> @slap lambdabot
12:49:50 * lambdabot slaps lambdabot
12:49:59 <phobes> byorgey:  why shouldn't it behave that way?
12:50:00 <byorgey> alexj: I don't think that's included by default, is it?
12:50:10 <alexj> it isn't?
12:50:17 <alexj> well that would explain it.
12:50:30 <dmwit> mauke: Be careful about [1..] vs [0..] ?
12:50:42 <mauke> dmwit: I copy/pasted that from ghci
12:50:53 <byorgey> alexj: on Ubuntu, at least, you have to also install libghc-network-dev
12:50:53 <alexj> byorgey: it looks standard http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network-URI.html
12:50:55 <lambdabot> http://tinyurl.com/2xdcca
12:51:11 <omnId> Prelude> take 2 (filter (<3) [1..])
12:51:12 <omnId> [1,2]
12:51:17 <omnId> > take 2 (filter (<3) [1..])
12:51:21 <lambdabot> Terminated
12:51:27 <dmwit> huh
12:51:44 <alexj> byorgey.  ah thatnks
12:51:50 <byorgey> alexj: it's standard, but it isn't included as part of the base ghc package on all systems.
12:51:56 <kaol> > filter (<3) [1..]
12:51:59 <lambdabot> Terminated
12:52:09 <mauke> > (filter (<3) [1..]) !! 1
12:52:10 <lambdabot>  2
12:52:26 <omnId> kaol: that hits bottom when it tries to print the third element.
12:52:57 <dmwit> > take 2 (filter (<3) [1..10])
12:52:58 <lambdabot>  [1,2]
12:53:19 <dmwit> ?version
12:53:19 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
12:53:20 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:53:27 <phobes> it looks like take is forcing evaluation of one past the last taken...
12:53:39 <omnId> @src take
12:53:39 <lambdabot> take n _      | n <= 0 =  []
12:53:40 <lambdabot> take _ []              =  []
12:53:40 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:53:40 <dmwit> phobes: Yes, that's very odd.
12:54:02 <omnId> > take 0 undefined
12:54:03 <lambdabot>  Undefined
12:54:17 <byorgey> that @src doesn't necessarily have anything to do with reality.
12:54:18 <dmwit> =(
12:54:31 <dmwit> ?where prelude
12:54:31 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
12:54:35 <omnId> @source Prelude
12:54:35 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
12:54:40 <byorgey> yeah, that's unfortunate.  take shouldn't be that strict in its second argument.
12:55:01 <Heffalump> some bug was reported on that subject recently, IIRC
12:55:06 <Heffalump> found by the streaming people
12:55:15 <omnId> @source Data.List
12:55:15 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
12:55:28 <dmwit> byorgey: It may not be the real definition, but it is the specification for the function.
12:55:44 <dmwit> byorgey: So, take is supposed to *behave* as if that were its definition.
12:56:19 <omnId> @actual-implementation-location-of take
12:56:19 <lambdabot> Unknown command, try @list
12:56:43 <omnId> GHC.List maybe?
12:56:48 <dmwit> ?src PreludeList
12:56:49 <lambdabot> Source not found. My mind is going. I can feel it.
12:57:10 <byorgey> dmwit: right.
12:57:33 <byorgey> @source GHC.List
12:57:33 <lambdabot> GHC.List not available
12:57:34 <dmwit> ?src GHC.Base
12:57:35 <lambdabot> Source not found. Are you on drugs?
12:57:46 <dmwit> ?source GHC.Base
12:57:46 <lambdabot> GHC.Base not available
12:58:04 <kolmodin> have anyone seen the ThinkPad laptops available without bundled OS?
12:58:10 * omnId digs around the http directories
12:58:26 <n00b> @source lambdabot
12:58:27 <lambdabot> lambdabot not available
12:58:35 <n00b> @source linux
12:58:35 <lambdabot> linux not available
12:58:49 <omnId> http://darcs.haskell.org/packages/base/GHC/List.lhs
12:59:06 <n00b> > who are you lambdabot ?
12:59:06 <lambdabot>   parse error on input `}'
12:59:30 <n00b> how do you ask lambdabot a ques ??
12:59:41 <omnId> @vixen How are you?
12:59:41 <dmwit> @vixen who are you?
12:59:42 <lambdabot> yes, i am
12:59:42 <lambdabot> i'm just me :)
13:00:03 <dmwit> ?where lamdabot
13:00:03 <lambdabot> I know nothing about lamdabot.
13:00:07 <dmwit> ?where lambdabot
13:00:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:01:20 <dmwit> byorgey: That code still isn't strict in its second argument if its first argument is 0...
13:01:22 <dmwit> ?
13:01:45 <dmwit> For values of "that code" == "GHC.List".
13:03:18 <dmwit> heh
13:03:24 <dmwit> @vixen are you god?
13:03:24 <lambdabot> i truely am
13:04:02 <omnId> truly*
13:05:06 <lament> @vixen what is the meaning of life?
13:05:07 <lambdabot> i'm not sure what i mean
13:05:19 <n00b> @vixen who the hell are you?
13:05:20 <lambdabot> yes, i am
13:05:34 <n00b> @vixen what is your name
13:05:34 <lambdabot> My name is Emily
13:05:49 <n00b> @vixen who created you ?
13:05:49 <lambdabot> i dunno, who?
13:05:53 <lament> @vixen how old are you?
13:05:54 <lambdabot> 19, you?
13:05:58 <dmwit> @vixen WHO IS EMILY
13:05:58 <lambdabot> ok...
13:06:01 <lament> @vixen 22
13:06:01 <lambdabot> oh, you're not to much older than me
13:06:09 <lament> brilliant
13:06:11 <dmwit> @vixen 46
13:06:12 <lambdabot> you could be my father!
13:06:15 <dmwit> haha
13:06:16 <omnId> @vixen 293847
13:06:17 <lambdabot> My sister likes Yahoo better. Her screenname is FoxxyGurl83. If you have yahoo you should message her, she's just as pretty as me :)
13:06:18 <n00b> @vixen are you a virgin
13:06:18 <lambdabot> no, i'm not a virgin. are you?
13:06:30 <n00b> @vixen do you have a girl
13:06:30 <lambdabot> yeah, why? of course i'm a girl
13:06:36 <dmwit> Whoa, \bot gets around.
13:06:49 <omnId> @vixen Are you female?
13:06:50 <lambdabot> first you tell me.
13:06:55 <n00b> @vixen do you have a boyfriend
13:06:55 <omnId> @quote female
13:06:55 <lambdabot> nope, that's why i'm here :)
13:06:55 <lambdabot> lambdabot says: Of course i'm female
13:07:18 <lament> finally we know why lambdabot is here
13:07:19 <n00b> @vixen do you want me?
13:07:19 <lambdabot> sure, i want to plenty
13:07:25 <dmwit> @vixen you flirt!
13:07:26 <lambdabot> hey, who did we fight in WWII besides Germany and Russia?
13:07:34 <n00b> @vixen do you wanna go to the movies ?
13:07:34 <lambdabot> sure, i want to plenty
13:07:35 <dons> Igloo: just sent a small patch to System.Posix.Terminal.
13:07:39 <omnId> @vixen Japan?
13:07:40 <lambdabot> whoa whoa whoa, one question at a time!
13:07:41 <dons> we need to get this into 6.8 please.
13:07:53 <n00b> @vixen what's your number ?
13:07:53 <lambdabot> i dunno...
13:07:56 <dons> (just adds a couple of higher baud rates to a datatype)
13:08:06 <lament> @vixen let's go have hot sex in #haskell-blah
13:08:06 <lambdabot> church is my favourite computer scientist.
13:08:11 <n00b> @vixen have you ever had sex ?
13:08:11 <lambdabot> yes, once or twice :)
13:08:21 <n00b> @vixen with who ?
13:08:21 <lament> 13:08 <lament> @vixen let's go have hot sex in #haskell-blah
13:08:21 <lambdabot> is that really what you want to know?
13:08:22 <lament> 13:08 <lambdabot> church is my favourite computer scientist.
13:08:26 <lament> i am in love
13:08:37 <dmwit> =D
13:10:21 <n00b> @vixen what time is it ?
13:10:21 <lambdabot> i don't know, what?
13:10:34 <n00b> @vixen do you know jamaica
13:10:35 <lambdabot> i think i know
13:10:45 <n00b> @vixen what do you know about jamaica
13:10:45 <lambdabot> i dunno, what about?
13:10:49 <omnId> @localtime n00b
13:10:49 <lambdabot> Local time for n00b is Tue Oct 16 15:10:49 2007
13:11:00 <n00b> @vixen you ain't all that smart
13:11:00 <lambdabot> Fuck me like im a school boy
13:11:08 <omnId> :O
13:11:13 <lament> er
13:11:14 <dmwit> O_o
13:11:22 <reilly> oh my
13:11:28 <omnId> @slap lambdabot
13:11:28 <lambdabot> why on earth would I slap lambdabot
13:11:41 <dmwit> I think the lesson here is that girls like being called stupid.
13:11:44 <newsham> ?quote feeling
13:11:44 <lament> @vixen do you mean schoolgirl?
13:11:45 <lambdabot> syntaxfree says: I love lists of functions. They give me this warm mathematical feeling.
13:11:45 <lambdabot> yup, 2nd year at UCLA
13:11:46 <n00b> @slap your ass
13:11:46 * lambdabot smacks your ass about with a large trout
13:12:01 <n00b> @vixen yes baby
13:12:01 <lambdabot> i guessed that
13:12:14 <byorgey> ok, enough =P
13:12:15 <newsham> ?quote better now
13:12:16 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
13:12:20 <n00b> @localtime omnId
13:12:25 <dmwit> ?quote better.now
13:12:25 <lambdabot> lambdabot says: I know everything hasn't been quite right with me, but I can assure you now, very confidentaly, that it's going to be all right again.  I feel much better now.  I really do.
13:12:26 <lambdabot> Local time for omnId is Tue Oct 16 16:15:36
13:13:05 <Igloo> dons: I don't see a patch
13:13:58 <dons> hmm
13:14:09 <dons> i wonder if my new address gets silently discarded on libraries@
13:15:01 <dons> Igloo: http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/7722
13:15:03 <lambdabot> Title: gmane.comp.lang.haskell.libraries
13:15:03 <dmwit> uh...
13:15:05 <dmwit> ?quote
13:15:05 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
13:15:11 <dons> ?quit your self!
13:15:21 <dons> i had a dream about this bug
13:15:45 <kaol> ?quote
13:15:49 <lambdabot> ChrisKuklewicz says: Are there little known Haskell idioms for doing math? Is there an undocumented -funleash-fortran parameter?
13:15:55 <Igloo> dons: Ah, thanks
13:16:28 <phobes> ok I have a question... why is it that laziness is the right default?  It seems to me that lazy evaluation is more difficult to reason about than strict evaluation
13:17:04 <dons> it encourages you to not to impose a particular mental model of evaluation in your code
13:17:07 <Igloo> dons: Hmm, is it guaranteed that B57600 and B115200 will be defined? Is it important to rush this in at the last minute?
13:17:08 <Heffalump> strict programs aren't referentially transparent
13:17:14 <dons> so your code stays easy to compose, parallelise, or otherwise manipulate
13:17:23 <Heffalump> s/strict programs aren't/strict evaluation isn't/
13:17:26 <dons> Igloo: just let me check..
13:17:30 <phobes> but laziness is a particular model of evaluation
13:17:34 <phobes> a more complicated one
13:17:37 <dons> Igloo: we do need it for some code that will go to clients.
13:17:49 <dons> so avoiding having to patch unix to get those is desirable
13:17:51 <dons> but let me check..
13:17:51 <conal> beta-reduction/expansion isn't valid for strict evaluation
13:18:03 <CosmicRay> I am trying to use runInteractiveProcess to implement pipelines.  I have it working with 2 commands, but not with 3.  My pipelines are presently using a naive implementation where a String is what ties two commands together.  I run forkIO $ hputStr to send the String (representing input) to the right-hand command, and hGetContents to read the data output from the left.  How exactly does hGetContents interact with the threading in this c
13:18:03 <phobes> conal:  that's true
13:18:03 <CosmicRay> ase, where the IO action demanding the content of the string is in another IO thread?  And what happens when there are two threads demanding the content of two different Handles that were both accessed by hGetContents in the same thread?
13:18:11 <CosmicRay> I seem to be seeing deadlock somewhere but can't work out where
13:18:39 <dons> Igloo: well, hmm,  tested in windows, the mac, and openbsd.
13:18:51 <dons> so must be fairly ubiquitous?
13:19:16 <dons> Igloo: remember that B115200 maps to #const 115200
13:19:20 <dons> its not a .h thingy
13:19:22 <conal> phobes: but if you mean reasoning about operational behavior (time & space), then yeah -- eager is easier.
13:19:35 <phobes> conal:  no, I mean reasoning about correctness
13:19:49 <dons> Igloo: so I can't see how that could break any build
13:19:56 <dons> its internal to the Terminal.hsc module
13:20:05 <phobes> Imagine that you add "assertions" to the language that allow you to assert things about a value
13:20:17 * fox86 dies after reading about datatypes in yaht
13:20:31 <Igloo> Oh, does #const not do what I think it does?
13:20:37 <phobes> but the assertions only need to hold in contexts where the value is actually going to be evaluated
13:21:12 <kolmodin> dons: you had a X6x something ThinkPad, right? do you know if it's available without bundled OS?
13:21:29 <dmwit> omnId: Short for omniscientIdiot?
13:21:34 <omnId> yep
13:21:41 <dmwit> aha
13:21:46 <phobes> anyway, I
13:21:49 <Igloo> dons: It's getting this value isn't it? bits/termios.h:#define  B38400        0000017
13:22:03 <kolmodin> dons: or did you get it with an OS?
13:22:46 <dons> Igloo: +baud2Word B57600 = (#const B57600)
13:22:46 <dons> +baud2Word B115200 = (#const B115200)
13:22:47 <phobes> it gets much more complicated with every function being lazy ... when you write "foo x" you never know the circumstances under which x will be evluated
13:22:54 <dons> ah i see.
13:22:55 <araujo> kolmodin!!!!!!!!
13:23:11 <dons> Igloo: let me just double check with Phil.
13:23:14 <phobes> rather you have to dive into foo to figure it out
13:23:24 <byorgey> fox86: that's not recommended.
13:23:30 <kolmodin> araujo!!!!!!!!!!!!!
13:23:35 <dons> Igloo: right, we have
13:23:36 <dons> #define B76800  76800
13:23:36 <dons> #define B115200 115200
13:23:36 <dons> #define B230400 230400
13:23:38 <dons> on openbsd.
13:23:40 <byorgey> fox86: if you're having trouble with something specific, feel free to ask here of course =)
13:23:40 <dons> for example.
13:23:55 <fox86> byorgey: thanks! there's just so much to read and my head is full already
13:24:05 <olsner> omnId: oh! so that's where omniscientIdiot went
13:24:08 <mauke> @djinn (a -> Either b a) -> a -> b
13:24:12 <lambdabot> -- f cannot be realized.
13:24:21 <mauke> what
13:24:30 <dons> Igloo: so I can only suggest that if it works on windows and openbsd, its ubiquitous.
13:24:45 * Igloo doesn't think it's a good idea to rush through changes like this at the last minute, when they could break the build on some platform
13:25:04 <mauke> :t let loop f x = case f x of Left r -> r; Right x' -> loop f x' in loop
13:25:07 <lambdabot> forall t t1. (t -> Either t1 t) -> t -> t1
13:25:12 <Igloo> Sorry  :-(
13:25:18 <mauke> does something like that exist in the libraries?
13:25:28 <dons> I understand that, though this is required for the unix package to be usable for our scenario. It all depends on how likely you think this is to break things
13:25:37 <vincenz> mauke: sounds like unfoldr
13:25:40 <vincenz> @type unfoldr
13:25:42 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:25:47 <mauke> but I don't want a list
13:25:49 <dons> Igloo: so we'd be ok with the head branch
13:25:54 <dons> given the unix package is split off
13:26:02 <vincenz> mauke: you want the fix to this version's iterate :)
13:26:45 <dons> kolmodin: yeah, i use an x61, http://shop.lenovo.com/SEUILibrary/controller/e/web/LenovoPortal/en_US/catalog.workflow:category.details?current-catalog-id=12F0696583E04D86B9B79B0FEC01C087&current-category-id=135A781CA29B4ECB9ADAD8E72CF6FD61
13:26:47 <lambdabot> Title: Lenovo - Notebook computers - ThinkPad X Series, http://tinyurl.com/3b5lg2
13:26:52 <dons> mine came with windows, which i immediately wiped, i must admit
13:27:32 <Jaak> dons: isn't x61-s screen too small for programming?
13:27:38 <kolmodin> dons: and so would I. and that's why I don't want to pay for it :)
13:27:47 <byorgey> mauke: hmm, some sort of ArrowLoop something or other?
13:27:55 <byorgey> ^^ total BS
13:28:42 <dons> Jaak: no?
13:29:02 <dons> do you write large programs?
13:29:04 <dons> :)
13:29:07 <kolmodin> :D
13:29:38 <vincenz> dons: how old is your mozilla?
13:29:47 <Jaak> not yet. I need to buy myself a laptop and was wondering
13:30:02 <Jaak> only thing that bothers me about x61 is small screen and quite high price
13:30:03 <dons> vincenz: new?
13:30:06 <dons> 2.something
13:30:13 <vincenz> dons: it lookedo sold
13:30:15 <vincenz> the grey buttons
13:30:18 <augustss> cool, IBM's new mainframes are gonna have decimal floating point
13:30:21 <vincenz> like netscape from the 90s
13:30:24 <dons> vincenz: hmm?
13:30:34 <dons> you're looking at a screenshot?
13:30:35 <vincenz> when you were showing hpc, your browser looked antique!
13:30:51 <dons> its firefox 2.something running the vimperator extension
13:30:55 <dons> so it behaves and looks like vim
13:31:06 * vincenz tried that but didn't like it
13:31:17 <dmwit> vimperator has improved a lot in the last few versions.
13:31:18 <phobes> augustss:  Why is that cool?  financial applications?
13:31:19 <dons> as in this screenshot, http://xmonad.org/images/xmonad_xcompmgr.png
13:31:38 <augustss> phobes: it's just cool for it's own sake
13:31:54 <augustss> phobes: but IBM's reason is financial apps
13:31:56 <vincenz> dons: bare to the bones :)
13:32:23 <dons> sure
13:32:26 <pejo> augustss, isn't rounding errors a problem?
13:32:30 <augustss> phobes: and PL/I is prepared for it!  you can specify the base when you declare a floating point variable
13:32:36 <dons> decorations are for christmas trees
13:32:44 <eyeris> dons what font is that?
13:32:51 <phobes> augustss:  Start posting PL/I links to reddit
13:32:51 <augustss> pejo: not more of a problem than usual
13:33:00 <dons> looks like vera sans?
13:33:19 <eyeris> darn... I thought so, but your vera sans looks better than mine :)
13:33:43 <dons> maybe its verdana?
13:33:55 <dons> i switch between the two
13:33:57 <eyeris> tahoma?
13:34:06 <n00b> xmonad looks good
13:34:07 <eyeris> Verdana is too wide for that
13:34:16 <eyeris> So what browser is that?
13:34:20 <n00b> how do i install it on ubuntu
13:34:25 <dons> vimperator'd firefox.
13:34:31 <n00b> @google xmonad and ubuntu
13:34:33 <lambdabot> http://www.haskell.org/pipermail/xmonad/2007-September/002081.html
13:34:33 <lambdabot> Title: [Xmonad] How to combine xmonad with Ubuntu?
13:35:07 <dons> n00b: you just build it as a normal haskell app, there's also this guy's page about the topic though, http://kenta.blogspot.com/2007/06/ubuntu-xmonad-script.html
13:35:09 <lambdabot> Title: Ken's blog: Ubuntu xmonad script
13:35:49 <eyeris> Holy moly vimperator looks awesome
13:37:02 <byorgey> n00b: note that guy's script is for version 0.2, though, which is not the latest
13:37:32 <byorgey> n00b: just go to xmonad.org, download the latest release, and follow the directions in the README file.
13:37:42 <byorgey> n00b: there's also the #xmonad channel if you have trouble.
13:38:22 <eyeris> Is there an arbitrary precision round function in the Prelude?
13:38:39 <augustss> eyeris: no
13:39:10 <augustss> eyeris: you mean as in "round to 5 decimal places"?
13:39:38 <eyeris> My guess is that is because I am supposed to just round (10.51 * 10) instead of arbround 10.51 1
13:39:42 <eyeris> yes, exactly
13:40:28 <eyeris> heh, forgot the /10 in my equation :0
13:40:29 <augustss> eyeris: you can make one yourself
13:43:36 <sorear> uh... doesn't using floating point defeat the benifits of decimal?
13:44:11 <augustss> you'll have to ask IBM
13:44:48 <eyeris> let arbRound x n = (fromIntegral (round (x * (10 ^ n)))) / (10 ^ n)
13:44:49 <augustss> they are devoting a large part of the chip to a decimal FP unit, so they must think it's important for something
13:45:04 <eyeris> That seems to work.
13:45:27 <nominolo> seems like a good use for a couple million spare transistors
13:45:49 <eyeris> nominolo they need something to convince people that the processors are getting better :)
13:46:26 <mauke> hmm. this square root computation is totally drunk
13:46:32 <phobes> As the US debt becomes larger, it becomes impractical to store all of its digits in fixed point
13:47:09 <mauke> [15,2,4,3,6,3,10,3,9,3,8,5,7,8,4,6,9,1,1,10,... doesn't look like [1,4,1,4,2,1,3,5,6,...
13:47:45 <nominolo> not very close
13:48:26 <CosmicRay> ah ha.  runInteractiveProcess is broken yet again
13:48:29 <CosmicRay> phobes: see Integer ;-)
13:49:29 <eyeris> phobes "they" would rather have the convenient excuse that the computer isn't able to give a consistent answer
13:50:27 <puusorsa> how to round floats to something closer to integer but not quite? :)
13:50:40 <puusorsa> i mean like 3 digits after decimal point or something
13:50:52 <dmwit> ?hoogle Int -> Double -> Double
13:50:55 <lambdabot> No matches, try a more general search
13:51:08 <dmwit> ?hoogle (RealFloat a) => Int -> a -> a
13:51:08 <lambdabot> Prelude.scaleFloat :: RealFloat a => Int -> a -> a
13:51:09 <lambdabot> Data.Graph.Inductive.Monad.newNodesM :: GraphM m gr => Int -> m (gr a b) -> m [Node]
13:51:31 <puusorsa> thanks
13:51:42 <puusorsa> i\m still bad at using hoogle :(
13:53:14 <dmwit> > scaleFloat 3 3.5555555
13:53:19 <puusorsa> hm.. actually wasnt even close
13:53:19 <lambdabot>  28.444444
13:53:25 <dmwit> Yeah, not really.
13:53:28 <augustss> scaleFloat is only useful when rounding according to the base of the number
13:53:54 <augustss> and even then it's not that useful :)
13:54:06 <puusorsa> is there anything that IS useful for this?
13:54:29 <puusorsa> i'd prefer showing 254.99999999999991 as 255 instead
13:54:37 <augustss> eyeris: let arbRound x n = (fromIntegral (round (x * (10 ^ n)))) / (10 ^ n)
13:54:44 <phobes> > 3.55555555 * 8
13:54:46 <lambdabot>  28.4444444
13:54:54 <dmwit> > let roundTo n = (/ (10**n)) . fromInteger . round . (* (10**n)) in roundTo 3 3.5555555
13:54:55 <lambdabot>  3.556
13:55:06 <puusorsa> thanks! <3
13:55:34 <augustss> dmwit: I'd use ^^, unless you really want fractional decimals
13:55:38 <augustss> :)
13:55:40 <eyeris> ** is exponentiation?
13:55:43 <dmwit> ok
13:55:48 <eyeris> not ^>
13:55:50 <dmwit> eyeris: Yes, as is (^) and (^^).
13:55:51 <eyeris> not ^?
13:55:52 <augustss> eyeris: ^, ^^, and **
13:56:00 <eyeris> all do the exact same thing?
13:56:03 <augustss> no
13:56:04 <puusorsa> no
13:56:06 <augustss> all different
13:56:11 <omnId> @type ((^), (^^), (**))
13:56:13 <lambdabot> forall a b a1 b1 a2. (Integral b, Num a, Integral b1, Fractional a1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
13:56:20 <augustss> > 3^(-1)
13:56:21 <lambdabot>  Exception: Prelude.^: negative exponent
13:56:27 <augustss> > 3^^(-)
13:56:28 <lambdabot>        add an instance declaration for (Integral (a -> a -> a))
13:56:28 <lambdabot>     In the ex...
13:56:34 <augustss> > 3 ^^(-1)
13:56:35 <mauke_> *Main> take 20 $ longsqrt2 1 1
13:56:35 <puusorsa> so, what dmwit said, but ^^ instead of ** ?
13:56:36 <lambdabot>  0.3333333333333333
13:56:36 <mauke_> [4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8,0]
13:56:41 <omnId> (^) integral base, (^^) fractional base, (**) floats
13:56:51 <augustss> > 3^^1.5
13:56:51 <eyeris> I see
13:56:51 <lambdabot>  Add a type signature
13:57:21 <augustss> And for ^ and ^^ the exponent has to be integral
13:57:22 <omnId> erm, (^) is num base with nonnegative exponent, rather
13:57:35 <augustss> :t (^)
13:57:37 <dmwit> (^) ~ iterate (*)
13:57:38 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:57:43 <augustss> :t (^^)
13:57:45 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:57:53 <augustss> :t (**)
13:57:55 <lambdabot> forall a. (Floating a) => a -> a -> a
14:00:18 <augustss> It's a bit annoying to have 3 of them, but with single parameter type classes it's hard to do better
14:00:48 <dmwit> (**) and (^^) really are quite different, though.
14:01:52 <phobes> multiplication is quite different for fractionals and floats then too?
14:02:21 <omnId> @instances Fractional
14:02:22 <lambdabot> Double, Float
14:02:30 <omnId> @instances-importing Data.Ratio Fractional
14:02:31 <lambdabot> Double, Float, Ratio a
14:02:57 <dmwit> phobes: For ratios, (*) is potentially exact.
14:03:20 <dmwit> This means that (^^) is potentially exact, but (**) need not be.
14:03:53 <sjanssen> whoa: "patch applied (ghc): View patterns, record wildcards, and record puns"
14:04:11 <conal> wow
14:04:13 * sjanssen  downloads a copy of GHC head
14:04:37 <Heffalump> sjanssen: ooh.
14:04:46 <Heffalump> augustss (and me) will be happy :-)
14:04:54 <omnId> x ^^ y | y < 0 = recip (x ^ (-y)) -- ?
14:04:56 <sjanssen> what are wildcards and puns?
14:05:20 <Heffalump> punning lets you right Foo { a, b, c } rather than Foo { a = a, b = b, c = c }
14:05:29 <Heffalump> s/right/write/ # argh
14:05:57 <Heffalump> wildcards let you write Foo { .. } instead of Foo { a = a, b = b, c = c } when a, b and c are all the fields of Foo
14:06:03 <Heffalump> both in pattern and expression context
14:06:07 <sjanssen> oh, interesting
14:06:17 <Heffalump> I think they also let you write some fields and then .. for the rest, but I've not tried that part
14:06:47 <mauke> man, I fail at computing sqrt 2 :(
14:07:07 <omnId> is the view patterns patch the (expr -> pat) proposal?
14:07:24 <Heffalump> yes
14:07:54 <omnId> which specifics were chosen?  Does expr :: Maybe a, and pat an a pattern?
14:08:18 <augustss> woo! woo!  finally! :)
14:08:32 <sjanssen> omnId: I'm not sure, the patch message doesn't say much
14:09:35 <byorgey> mauke: paste your code?
14:10:01 <omnId> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns -- says it details the implementation choices
14:10:03 <lambdabot> Title: ViewPatterns - GHC - Trac
14:10:11 <hpaste>  mauke pasted "sqrt2.hs" at http://hpaste.org/3330
14:15:58 <mauke> oh wow. looks like I can make vim crash
14:15:58 <mauke> reliably
14:18:11 <lament> emacs wins again!
14:18:52 <olsner> mauke: wow
14:20:55 <nominolo> probably some bad script
14:21:37 <mauke> hmm. doesn't happen with -u NONE
14:21:52 * dcoutts_ submits a bug report for nominolo's attention
14:22:31 <nominolo> O_O
14:23:29 <nominolo> gah, i should use a TODO list
14:23:50 <dcoutts_> nominolo: that's what the trac is for, well for cabal at least :-)
14:24:03 <dcoutts_> trac would make a terrible personal TODO list
14:24:18 <Heffalump> I've been thinking of using it for that
14:24:28 <nominolo> yep.  we need this for our super-cool Haskell IDE
14:25:17 <nominolo> and of course a "Plumber"
14:25:24 <nominolo> to fix space leaks
14:26:04 <nominolo> whenever you use foldl he should complain
14:26:43 <nominolo> and then the cursor should change to a big warhammer or something, and then you have to kick him to get rid of him
14:30:17 <dons> looks interesting, Lemmih , http://hackage.haskell.org/cgi-bin/hackage-scripts/package/safecopy-0.2
14:30:20 <lambdabot> http://tinyurl.com/ysmocq
14:30:21 <eyeris> Why does Haskell show a Float as 6.0e-2? Wouldn't 0.06 be more concise?
14:30:37 <dons> > 0.06 :: Float
14:30:38 <lambdabot>  6.0e-2
14:31:02 <dons> > showEFloat (Just 2) 0.06
14:31:03 <lambdabot>  <[Char] -> [Char]>
14:31:06 <dons> > showEFloat (Just 2) 0.06 []
14:31:07 <lambdabot>  "6.00e-2"
14:31:11 <dons> > showGFloat (Just 2) 0.06 []
14:31:12 <lambdabot>  "6.00e-2"
14:31:16 <dons> > showFloat (Just 2) 0.06 []
14:31:17 <lambdabot>  Couldn't match expected type `[a] -> t'
14:31:28 <dons> > showFFloat (Just 9) 0.06 []
14:31:30 <lambdabot>  "0.060000000"
14:31:34 <dons> > showFFloat (Just 2) 0.06 []
14:31:35 <lambdabot>  "0.06"
14:31:36 <dons> that's it
14:31:42 <eyeris> :)
14:31:56 <dons> ?docs Numeric
14:31:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
14:32:21 <nominolo> > showFloat (Just 2) 0.06
14:32:23 <lambdabot>   add an instance declaration for (Fractional String)
14:32:25 * bringert uses cabal-install (built with 6.6) to install cabal-install (built with 6.6.1)
14:32:34 <dons> oh, that rocks
14:32:36 <omnId> > showFFloat Nothing 0.06 ""
14:32:37 <lambdabot>  "0.06"
14:32:38 <dons> nice bringert
14:32:52 <nominolo> bringert,  does it work?
14:32:56 <bringert> yep
14:33:09 <nominolo> neat
14:33:11 * dons tests xmonad..
14:33:17 <bringert> I installed 6.6.1 with macports, and cabal-1.2 darcs
14:34:12 <bringert> then I used the cabal-install binary left in /usr/local/bin that I had built with 6.6 to run 'cabal install' in the cabal-install repo
14:34:34 <bringert> I guess we should put cabal-install on hackage at some point
14:34:41 <bringert> so that people can cabal-install it
14:34:57 <dcoutts_> yes
14:35:14 <dcoutts_> and we should get more people to use it and report issues
14:35:18 <eyeris> What is the IO cousin of iterate?
14:35:37 <nominolo> does it work with configurations now?
14:35:43 <bringert> nominolo: yes
14:35:45 <dcoutts_> nominolo: at least a bit, yes
14:36:01 <bringert> dcoutts: what doesn't work?
14:36:18 <quicksilver> eyeris: perhaps sequence . take n . iterate
14:36:22 <bringert> dcoutts: well, it doesn't try all possible trees of dependencies
14:36:28 <bringert> it probably should
14:36:37 <dcoutts_> bringert: nothing I've found so far, I was under the impression there was various levels of support possible
14:37:00 <dcoutts_> dons: you said there was some issue in binary you wanted to fix in a point release
14:37:12 <dcoutts_> dons: is that fixed in the current darcs version?
14:37:17 <bringert> right. I haven't tested setting flags manually for example
14:37:36 <quicksilver> eyeris: you don't want to sequence an infinite list...
14:37:50 <quicksilver> eyeris: foldM is another possibility
14:38:15 <nominolo> dcoutts, can you write down your idea to get rid of "dummy-flags"?
14:39:16 <bringert> dcoutts_: we should have a really-old-base flag in cabal-install.cabal, to work with base < 2.0. I don't have 6.4 around to test with though
14:39:17 <nominolo> was it "if dep(base < 1.1) ..." ?
14:39:29 <dcoutts_> bringert: I'm testing that now
14:39:36 <bringert> dcoutts_: great
14:39:43 <dcoutts_> nominolo: I was also just writing that email to cabal-devel
14:39:46 <nominolo> bran_, those "small_base" flags suck
14:39:57 <nominolo> dcoutts, great
14:40:26 <dcoutts_> bringert: though getting cabal to work on ghc-6.4.2 is not so easy since cabal needs filepath and ...
14:40:38 <bringert> :-)
14:42:43 <dcoutts_> bringert: solution is to set build-type: simple and to use cabal-setup
14:45:50 <bringert> dcoutts_, dons: what do you guys think about removing the explicit imports between cabal-install modules?
14:46:15 <dcoutts_> bringert: I don't care too much in cabal-install
14:46:39 <dcoutts_> bringert: it's useful in Cabal itself to make us think clearly about feature dependencies
14:46:47 <bringert> sure
14:47:26 <paczesiowa> @src toUpper
14:47:26 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
14:48:51 <paczesiowa> where can I find definition of toUpper? it's not in Char.hs and Prelude.hs is it builtin?
14:49:07 <quicksilver> it is essentially builtin, yes
14:49:27 <quicksilver> although you ought to be able to find some definition of it, which just relates it to a primop
14:50:16 <quicksilver> paczesiowa: I think the GHC stub is in GHC.Unicode
14:50:25 <quicksilver> paczesiowa: (which you can see imported by Char.hs)
14:51:54 <paczesiowa> google returns http://haskell.cs.yale.edu/ghc/docs/6.2.2/html/libraries/base/GHC.Unicode.html but there's no source attached:/
14:51:56 <lambdabot> http://tinyurl.com/25f9nr
14:52:08 <paczesiowa> and it looks kinda old
14:52:16 <EvilTerran> you could define it manually, but the builtin would be astronomically more efficient
14:52:35 <EvilTerran> (I'm assuming the builtin does bitwise ops or suchlike)
14:52:53 <quicksilver> EvilTerran: I think the builtin calls libc :P
14:53:10 <quicksilver> EvilTerran: toUpper on the complete unicode set is pretty hairy
14:53:19 <paczesiowa> just wanted to toUpper chars from bytestrings
14:53:20 <EvilTerran> ah, yes. unicode.
14:53:41 <quicksilver> paczesiowa: and, what's the problem with doing so?
14:54:07 <paczesiowa> Couldn't match expected type `GHC.Word.Word8'
14:54:07 <paczesiowa>            against inferred type `Char'
14:54:07 <paczesiowa>       Expected type: GHC.Word.Word8 -> GHC.Word.Word8
14:54:07 <paczesiowa>       Inferred type: Char -> Char
14:54:07 <paczesiowa>     In the first argument of `map', namely `toUpper'
14:54:08 <paczesiowa>     In the expression: map toUpper
14:54:20 <quicksilver> paczesiowa: don't use ByteString.Word8 for characters
14:54:25 <quicksilver> paczesiowa: use ByteString.Char8
14:55:01 <quicksilver> (if you want to use the word8 version you can actually translate with toEnum/fromEnum)
14:55:06 <phlpp> how can i filter all values ni a list
14:55:09 <phlpp> which are True?
14:55:23 <phlpp> so i get a list with [True, True, True, ...]
14:55:29 <quicksilver> > filter (==True) [False,True,False,True,False,False]
14:55:31 <lambdabot>  [True,True]
14:55:33 <phlpp> ajh
14:55:39 <phlpp> sorry, that was too obvious, actually
14:55:47 <paczesiowa> > filter id [False,True,False,True,False,False]
14:55:49 <lambdabot>  [True,True]
14:57:58 <phlpp> hm
14:58:12 <hpaste>  eyeris pasted "(no title)" at http://hpaste.org/3332
14:59:20 <omnId> eyeris: -> [(String, String, [Float])]
14:59:33 <omnId> the list comp results in a list.
14:59:37 <eyeris> doh
15:00:01 <eyeris> Yeah, that used to just return the Float
15:00:13 <eyeris> swapped my () and [] characters when I refactored it
15:00:57 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3333
15:01:02 <phlpp> hi
15:01:07 <phlpp> concerning this http://hpaste.org/3333
15:01:12 <fasta> "As an application grows, it gets harder and harder--and more time consuming--to keep state organized and threaded through the code in a pure way." <- isn't this complete nonsense?
15:01:29 <phlpp> can anyone point me to that a)  better style and b) spot the error in  isLychrel?
15:01:53 <phlpp> normally, this take 50 stuff should say sth. like "a lychrel number is only a number if after 50 iterations no palindrome occured"
15:02:03 <mrd> fasta: context?
15:02:09 <phlpp> so, if we take 10677, it needs 53 iterations
15:02:18 <phlpp> but my isLychrel function says, it's an lychrel
15:02:24 <fasta> mrd: The garden of truth: http://programming.reddit.com/info/5yek3/comments/ ;)
15:02:25 <lambdabot> Title: programming: Questioning Functional Programming
15:02:37 * mrd steers clear
15:02:45 <omnId> null (filter f xs) = all (not . f) xs
15:02:49 <mrd> answer out of context: State monad
15:03:49 <eyeris> fasta "grows" in code size? in complexity? in the number of threads?
15:03:53 <paczesiowa> I have this code "main = interact (map toUpper)" when run from 70mb file to /dev/null it takes 26s and 2mb memory, after hiding Prelude and importing Data.ByteString.Lazy.Char8 it takes half the time (great) but it uses70 mb memory, why is that?
15:03:55 <bos> it's really hard to write a large functional program if you don't know what you're doing. this probably shouldn't be news, but seems to be.
15:04:11 <lament> s/functional// ?
15:04:12 <phlpp> thx omnId
15:04:20 <eyeris> fasta notice that he is just making an observation, not asserting a cause :)
15:04:23 <omnId> filter (==True) (map f xs) = filter f xs
15:04:45 <fasta> eyeris: well, he does bring it like he has some authortity.
15:04:49 <dcoutts_> paczesiowa: you're sure you're using Data.ByteString.Lazy.Char8 and not Data.ByteString.Char8 ?
15:04:51 <phlpp> ah lol
15:04:53 <fasta> authority*
15:04:53 <phlpp> :-)
15:05:14 <eyeris> I believe you mean authoritah
15:05:15 <eyeris> :)
15:05:27 <fasta> eyeris: he has lots of that, I guess. ;)
15:06:02 <paczesiowa> dcoutts_ I'll triple check:>
15:07:05 <omnId> phlpp: so the error in isLychrel is that 10677 is *not* a Lychrel, but since you only take 50 iterations, isLychrel 10677 == True?
15:08:02 <phlpp> oh dear
15:08:17 <phlpp> sorry for confusing you, of course isLychrel 10677 has to be true
15:08:18 <omnId> is that the error you were talking about?
15:08:28 <phlpp> i was just confused, sorry
15:08:55 <phlpp> hm, there must be sth. wrong in my implementation
15:09:03 <paczesiowa> dcoutts_ triple checked and it still looks like "import Prelude () \n import Data.ByteString.Lazy.Char8" I check total memory in use with +RTS -sstderr -RTS, maybe that's wrong?
15:09:11 <phlpp> the number of lychrel numbers (length on that filter f xs) isn't correct
15:09:33 <dcoutts_> paczesiowa: hmm. See if it fails if you limit the heap to 2mb.
15:10:16 <omnId> phlpp: remove the length and see what numbers it results in.
15:11:06 <phlpp> hm, numbers from 196-9988
15:11:13 <phlpp> so below 10k
15:11:34 <mauke> bah, this inline template haskell code is really slow
15:12:23 <paczesiowa> dcoutts_ Heap exhausted; :/
15:12:34 <dcoutts_> paczesiowa: hmm, weird
15:12:44 <omnId> phlpp: *shrug* try cranking up the iterations to 500 or something.
15:12:45 <dcoutts_> paczesiowa: what version of ghc and bytestring ?
15:13:15 <phlpp> omnId: i have to use 50 iterations
15:13:28 <hpaste>  Excedrin pasted "C snippet" at http://hpaste.org/3334
15:14:01 <phlpp> omnId: maybe if i use more iterations, i will find more numbers, and that's not good because there's only one awnser ;) 500 iterations would also break the rules
15:14:28 <Excedrin> is there a clean way to abstract that in Haskell? it seems like there should be a way to have unevaluated thunks floating around that resolve to some value based on some probability and all behind the scenes..
15:14:45 <phlpp> because program should succeed in one miute
15:14:46 <hpaste>  Paczesiowa pasted "not so lazy lazybytestrings" at http://hpaste.org/3335
15:14:47 <phlpp> *minute*
15:15:18 <Excedrin> also, I'd like to be able to generalize it for any number of probabilities (not just pairs)
15:16:03 <paczesiowa> dcoutts_ ghc-6.6.1, I don't know what version of bytestrings (there's no info in ghc-pkg list)
15:16:25 <dcoutts_> paczesiowa: it's in base in ghc-6.6.1
15:16:55 <paczesiowa> dcoutts_ base-2.1.1
15:17:05 <omnId> Excedrin: replicateM 20 (randomRIO (0,1)) -- something like that?
15:17:21 <omnId> that'll give you 20 zeroes and ones.
15:17:48 <Excedrin> omnId: no, one half of the pair should be a zero and the other should be a one
15:17:59 <omnId> randomRIO (0,1) >>= \x -> (x, 1 - x) -- this'll give you what evalpair does
15:18:21 <Excedrin> omnId: hrm, it's not quite getting the problem, I'm not sure how to explain it
15:18:32 <paczesiowa> dcoutts_: any ideas?
15:18:41 <dcoutts_> paczesiowa: I'm just testing it myself
15:18:53 <dcoutts_> trying to find a suitable large input file
15:19:12 <tphyahoo> how do I generate a list of lists using quickcheck?
15:19:24 <Excedrin> direct translation of the C is easy obviously, but it's a bad abstraction, I'd like to have a bunch of these values floating around in pure functional land and be able to "force" one half of the pair later which will cause the other part to have the opposite value
15:20:08 <paczesiowa> dcoutts_ I used http://www.gutenberg.org/ebooks/22031, and then (cat that that > this; cat this this > that) to expand it to ~70mb
15:20:10 <lambdabot> Title: The Airplane Boys among the Clouds by John Luther Langworthy - Project Gutenberg
15:22:03 <omnId> Excedrin: erm, so you could have the second part defined in terms of the first?
15:22:50 <Excedrin> it's quantum entanglement, so one when you observe the state of one, the other is the opposite even if you observe it later etc
15:23:32 <omnId> so just have a pair (x, opposite x).  I'm don't understand the problem.
15:24:28 <omnId> let opx = opposite x in (opx `seq` x, opx) -- you want to force evaluation order?
15:26:39 <Excedrin> the value of x isn't known inside the pure functional part, it's just some probability (50% in the example), so inside the pure fp part, I'd like to be able to create a list or whatever with say, [1%3,1%3,1%3] then later say "what's the actual value of the head of the list?" and get "True", then much later if I ask for the rest of the list, it's [False,False]
15:27:40 <dcoutts_> paczesiowa: it seems that map on lazy bytestring is totally borked, it's loosing the laziness
15:27:50 <dcoutts_> dons: I'm quite surprised
15:28:23 <dcoutts_> dons: it must be the functional array fusion we're using on lazy bs. Try it, it's not lazy at all.
15:28:33 <dcoutts_> dons: another reason to switch asap
15:29:05 <dcoutts_> paczesiowa: thanks for finding this, that's pretty bad really.
15:29:48 <paczesiowa> I'm so stupid I can break everything:D
15:29:51 <dcoutts_> paczesiowa: if you defined map locally like this it'd work fast:
15:29:53 <dcoutts_> map f (LPS xs) = LPS (L.map (P.map' f) xs)
15:30:01 <dcoutts_> you'd need to import Data.ByteString.Base
15:33:08 <paczesiowa> dcoutts_ which module shoud be qualified as P and which as L?
15:33:26 <LoganCapaldo> I assume L is ByteString.Lazy
15:33:43 <paczesiowa> yeah, but then there is no P.map'
15:33:46 <LoganCapaldo> but I've been known to make asses of u and me before
15:34:27 <hpaste>  dcoutts annotated "not so lazy lazybytestrings" with "lazier map" at http://hpaste.org/3335#a1
15:36:33 <paczesiowa> dcoutts_: thx! now it even uses 1mb instead of prelude's 2mb of memory
15:37:11 <dcoutts_> paczesiowa: the next version of bytestring will not be using that map code
15:37:54 <dcoutts_> paczesiowa: that program also demonstrates that char.toUpper is very very slow :-)
15:38:29 <LoganCapaldo> why woudl toUp[per be slow? you just gotta add n rgight?
15:38:35 <omnId> unicode
15:38:37 * LoganCapaldo whistles innocently
15:39:30 <paczesiowa> dcoutts_: so next version will work out of the box, right? because when adding different imports (without touching actual code) makes things go twice as fast it's just cool
15:39:47 <paczesiowa> > toUpper 'a'
15:39:59 <lambdabot>  'A'
15:40:01 <paczesiowa> > toUpper 'A'
15:40:02 <lambdabot>  'A'
15:40:27 <mauke> > toUpper '\xdf'
15:40:28 <paczesiowa> LoganCapaldo: even without unicode it's more complicated than adding smth
15:40:28 <lambdabot>  '\223'
15:40:37 <twanvl> > toUpper ''
15:40:37 <lambdabot>  Improperly terminated character constant
15:40:59 <mauke> > toUpper '\x1eaf'
15:41:00 <lambdabot>  '\7854'
15:41:08 <dcoutts_> paczesiowa: right
15:41:50 <mauke> hey, that was right!
15:42:34 <LoganCapaldo> paczesiowa: I can't amke like joke slike that in this channel. I should've learned by now
15:43:46 <paczesiowa> LoganCapaldo: yeah, looks like it has to be smth with cats and lambdas to be funny recently:>
15:44:05 <ddarius> > toUpper ''
15:44:06 <lambdabot>  Improperly terminated character constant
15:44:43 <mauke> > toUpper '\951'
15:44:45 <lambdabot>  '\919'
15:44:46 <LoganCapaldo> always with the improperly terminated character constants
15:45:35 <phlpp> omnId: hm, i do now know where my error has to be
15:45:42 <phlpp> the correct result is 249
15:45:49 <phlpp> so 3 numbers are missing
15:49:15 <phlpp> hm, there's another solution in haskell but i'm not able to spot my error
15:49:37 <omnId> what's the problem description, is there a link?
15:50:09 <phlpp> yeah
15:50:10 <phlpp> sec.
15:50:22 <phlpp> http://projecteuler.net/index.php?section=problems&id=55
15:50:23 <lambdabot> Title: Project Euler
15:50:25 <phlpp> here it is
15:53:11 <TSC> phlpp: I wrote a pretty naive implementation for that problem and it can do up to ten-thousand fairly quickly
15:53:35 <phlpp> TSC: ok
15:54:02 <TSC> By naive, I mean it uses show and read a lot to do the computations
15:54:04 <phlpp> my problem is that for [1..10^4] i get 246 lychrel numbers
15:54:04 <phlpp> not 249
15:54:13 <omnId> TSC: it seems his naive implementation gets three false negatives
15:54:33 <TSC> Ah
15:54:40 <TSC> Do you know which ones?
15:54:56 <omnId> no, nor why
15:55:04 <TSC> I can give a list of the correct ones to compare against
15:55:29 <phlpp> ok
15:57:56 <hpaste>  TSC pasted "Lychrel" at http://hpaste.org/3336
16:00:21 <omnId> *Main> filter (`notElem` lychrelsTo1e4) tscLychrels
16:00:21 <omnId> [4994,8778,9999]
16:00:46 <omnId> palindromes!
16:00:46 <phlpp> yeah
16:01:10 <phlpp> ah
16:01:13 <phlpp> oh my dear
16:01:21 <omnId> so isLychrel x = not (isPalindrome x) && ...
16:01:22 <phlpp> that was in the description of the task, too
16:01:48 <phlpp> yeah, ok, thanks TSC and especially thanks omnId :)
16:04:55 <dons> dcoutts_: yeah, the portability issue to 32 bit machines is fixed in darcs binary
16:04:57 <omnId> er, no
16:05:11 <dcoutts_> dons: ok good good
16:05:16 <omnId> so isLychrel x = all (not . isPalindrome) (drop 1 ...)
16:05:47 <dcoutts_> dons: I'll push the changes for compatibility with older ghc and one of us can tag & upload binary 0.4.1
16:05:58 <dons> ok. cool
16:06:04 <dons> ping me before you do so i can test on a few machines
16:06:30 <hpaste>  omnId annotated "(no title)" with "(no title)" at http://hpaste.org/3333#a1
16:06:31 <Cale> um, 9999 isn't a Lychrel number, since it's a palindrome, no?
16:06:55 <LoganCapaldo> it is the ultimate amount of damage in FF though
16:06:56 <phlpp> 9999 IS a lychrel number
16:06:58 <omnId> Cale: it is according to PE's problem description
16:07:01 <phlpp> it's described in the task
16:07:04 <phlpp> of PE
16:07:29 <Cale> ah, okay
16:07:32 <phlpp> it's because the interesting thing is the result of the _addition_
16:07:39 <Cale> that is "surprising"
16:07:45 <phlpp> yeah ;)
16:07:50 * bos is talking about Haskell at Ignite San Francisco tonight. slides to follow.
16:08:01 <Cale> > let rev = read . reverse . show; revAdd = ap (+) rev; palin = ap (==) rev; lychrel = not . null . drop 50 . takeWhile (not . palin) . drop 1 . iterate revAdd in filter lychrel [1..10000]
16:08:04 <phlpp> cool, good luck bos
16:08:04 <Excedrin> bos: subject of the talk?
16:08:06 <lambdabot>  [196,295,394,493,592,689,691,788,790,879,887,978,986,1495,1497,1585,1587,167...
16:08:14 <Cale> > let rev = read . reverse . show; revAdd = ap (+) rev; palin = ap (==) rev; lychrel = not . null . drop 50 . takeWhile (not . palin) . drop 1 . iterate revAdd in length $ filter lychrel [1..10000]
16:08:17 <lambdabot>  249
16:08:24 <phlpp> yeah, thats right
16:08:42 <bos> Excedrin: why functional programming is enjoyable, and how to take advantage of that
16:08:54 <phlpp> Cale: well done, but it'll take some time to understand that code. i just wanted to practice my `skill` of "thinking functional"
16:08:57 <phlpp> with this task
16:09:03 <dons> and looks like the move is on to get an oregon/north west group going now too
16:09:11 <dons> the bayfp guys can't have all the fun!
16:09:48 <sorear> eventually every population center has a FPUG
16:10:02 <phlpp> @src drop
16:10:02 <lambdabot> drop n xs     | n <= 0 =  xs
16:10:03 <lambdabot> drop _ []              =  []
16:10:03 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
16:11:16 <omnId> > take 0 undefined -- take is too strict in lb's ghc!
16:11:18 <lambdabot>  Undefined
16:11:41 <EvilTerran> @src take
16:11:41 <lambdabot> take n _      | n <= 0 =  []
16:11:41 <lambdabot> take _ []              =  []
16:11:41 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
16:11:47 <dons> more haskell-(ish) jobs, `http://www.google.com/pagead/iclk?sa=l&ai=B7YRpwEQVR5nzH5jmgQOr-di2BNeh6CmrtLWbBMCNtwHQhgMQAxgDIPfbjQIoAzgAUPKsp9f6_____wFgyYb-i8yk1BmqAR5tc2d2aWV3K3B1YmxpYytub25hZHVsdCt1c2VuZXTIAQHaASYvZ3JvdXAvZmEuaGFza2VsbC9tc2cvZDgwODAxZjBlYWEzNzhjMsgCx4OlA6gDAegD2wXoA54B6AO2BegD2gX1AwIBAAA&num=3&adurl=http://www.blurtit.com/listings.php%3Fquery%3DHaskell%2Bprogramming%26uid%3Dadwords-TS10224-AS-200793-130639-91%26search_type%3Dcontent%26ad%3D104
16:11:51 <lambdabot> Title: Haskell Programming - Blurtit, http://tinyurl.com/yrvx6g
16:11:54 <dons> urgh
16:11:56 <dons> "It's Not Haskell...
16:11:59 <dons> ...but it is functional. Hack OCaml
16:12:01 <dons> with SF Bay Area mobile startup."
16:12:19 <dons> evil ocamlers can't find enough of their own, so they corrupt the pure haskell crowd with promises of jobs and starts, eh?
16:12:20 <omnId> quite the url
16:12:35 <Tac-Tics> where are the jobs on that page though?
16:12:50 <dons> http://skydeck.com/jobs/?gclid=CPGY55XFlI8CFRctagodLka-eg
16:12:52 <lambdabot> Title: Skydeck : Jobs @ Skydeck
16:13:08 <dons> yeah, the link was wrong.
16:13:47 <Tac-Tics> greedy californians
16:13:54 <Tac-Tics> they have all the cool haskell jobs
16:13:59 <dons> its not functional if its impure: that's my motto
16:14:09 <dons> well, oregon's also good :)
16:14:17 <Tac-Tics> dons: some people say that something is functional when it works
16:14:25 <dons> that's just silly
16:14:31 <Tac-Tics> it's that darned west coast
16:15:10 <Tac-Tics> although, if I started my own haskell startup, I'd be the only one in all of the midwest
16:15:21 <dons> well, there's sjanssen
16:15:30 <Tac-Tics> where does he  live?
16:15:31 <dons> isn't Aetion in the mid west somewherE?
16:15:47 <dons> he's in nebraska, iirc
16:15:48 <geocalc> it's working when it works
16:15:48 <Tac-Tics> we need a haskell frapper.... written in Haskell
16:17:07 <geocalc> frapper is ?
16:17:26 <LoganCapaldo> what's frapper? Is it like a frappachino?
16:17:26 <sorear> typo for rapper?
16:17:35 <Tac-Tics> frapper is something like google maps where you post where you live and a bio of yourself and a small pic
16:17:49 <Tac-Tics> and then you can see the other people in your area with the same interests
16:17:49 <LoganCapaldo> Don't we have that?
16:17:56 <LoganCapaldo> modulo the pic and and bio
16:18:00 <geocalc> ok
16:18:04 <bos> aetion is in ohio.
16:18:21 <paczesiowa> wouldn't it get sad when you realise that there are 400 of us?
16:18:42 <dons> well, there's 2k on the -cafe@ list
16:18:51 <dons> so if we add those guys, that's a reasonable battalion
16:18:55 <Tac-Tics> paczesiowa: no, I'd get sad when I realized the closest one of you is two states away
16:19:54 <geocalc> poor Tac-Tics
16:20:03 <Tac-Tics> but it would still be need to keep tabs on where haskell is
16:20:48 <LoganCapaldo> @where map
16:21:14 <LoganCapaldo> I know it's in there somewhere
16:21:25 <LoganCapaldo> @where users
16:21:25 <lambdabot> I know nothing about users.
16:21:28 <Tac-Tics> @src map
16:21:28 <lambdabot> map _ []     = []
16:21:28 <lambdabot> map f (x:xs) = f x : map f xs
16:21:31 <EvilTerran> @where is everyone
16:21:32 <lambdabot> I know nothing about is.
16:21:33 <LoganCapaldo> not that map
16:21:40 <LoganCapaldo> the map of haskell users
16:21:45 <EvilTerran> @vixen Where do you live?
16:21:45 <lambdabot> Plugin `vixen' failed with: IRCRaised getRandItem: empty list
16:21:49 <EvilTerran> !
16:21:51 <paczesiowa> my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them. but then I look at some java code and I'm all happy again
16:21:59 <LoganCapaldo> dons: you there?
16:21:59 <shapr> hah
16:22:15 <dons> LoganCapaldo: for a moment..
16:22:17 <shapr> @remember paczesiowa my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them. but then I look at some java code and I'm all happy again
16:22:17 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
16:22:20 <shapr> aww
16:22:29 <LoganCapaldo> dons: you know the map I'm talking about?
16:22:29 <dons> ?quit
16:22:52 <LoganCapaldo> with the location of haskell users?
16:23:08 <Tac-Tics> I guess it's spelled frappr not frapper
16:23:10 <Tac-Tics> but same deal
16:23:18 <iank> not the map that applies a function to elements of a list?
16:23:23 <LoganCapaldo> not that map
16:23:24 <dons> LoganCapaldo: its on the haskell wiki somewhere
16:23:50 <bos> dons: interesting pointer, that. one of the founders of skydeck is irish. i hardly knew any other irish people spoke functional languages :-)
16:23:56 <Mr_Awesome> paczesiowa: happy that you may end up having to code like that?
16:24:07 <shapr> @remember paczesiowa my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them. but then I look at some java code and I'm all happy again
16:24:07 <lambdabot> Done.
16:24:13 * LoganCapaldo really thought it was in lambdabot somewheres
16:24:20 <omnId> LoganCapaldo: I think it's @map, but it was on HaWiki.
16:24:22 <shapr> @quote
16:24:22 <lambdabot> LarryWall says: ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
16:24:33 <dons> bos: hehe
16:24:36 <LoganCapaldo> @map
16:24:37 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
16:24:41 <LoganCapaldo> there it is
16:24:46 <LoganCapaldo> thanks omnId
16:24:53 <Tac-Tics> ah
16:25:01 <EvilTerran> hawiki's gorn...
16:25:09 <shapr> yes it is.
16:25:23 * LoganCapaldo cries
16:25:31 <EvilTerran> @where+ map http://www.haskell.org/haskellwiki/HaskellUserLocations
16:25:31 <lambdabot> I will never forget.
16:25:33 <paczesiowa> Mr_Awesome: nah, more like it's going to be a while when I'll have to get a job, so there are few years of "pure" fun:>
16:25:41 <omnId> gah, I was lagging *seriously* bad.  I just got a flood of a page's worth of stuff.
16:26:08 <Tac-Tics> chmod +x http://www.cse.unsw.edu.au/~dons/haskell-planet
16:26:26 <Tac-Tics> but neat
16:34:03 <phlpp> @src ap
16:34:03 <lambdabot> ap = liftM2 id
16:36:31 <mauke> @src liftM2
16:36:32 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:40:25 <Tac-Tics> @type liftM2
16:40:27 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:40:40 <Tac-Tics> > liftM2 (+) [1..3] [1..3]
16:40:42 <lambdabot>  [2,3,4,3,4,5,4,5,6]
16:41:56 <Tac-Tics> > [(Nothing, Nothing), (Nothing, Just 2), (Just 1, Nothing), (Just 1, Just 2) >>= \(x, y) ->liftM2 mplus x y
16:41:57 <lambdabot>  Parse error
16:41:59 <Tac-Tics> bah
16:42:19 <Tac-Tics> > [(Nothing, Nothing), (Nothing, Just 2), (Just 1, Nothing), (Just 1, Just 2)] >>= \(x, y) -> liftM2 mplus x y
16:42:20 <lambdabot>  Couldn't match expected type `[]' against inferred type `Maybe'
16:43:05 <omnId> return (mplus x y)?
16:43:17 <Tac-Tics> yeah....
16:49:27 <sioraiocht> @src liftM2
16:49:27 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:49:30 <omnId> > concat . transpose . map cycle $ ["BREAKTHETARGETS", "BOARDTHEPLATFORMS"] -- (anyone else ram the A button on the mode selector? :)
16:49:32 <lambdabot>  "BBROEAARKDTTHHEETPALRAGTEFTOSRBMRSEBAOKATRHDETTHAERPGLEATTSFBORREMASKBTOHAE...
16:51:12 <Tac-Tics> I love smash brothers <3
16:51:27 <iank> Took me a sec to get that :)
16:52:55 <omnId> > cycle "....-....|" -- test to see the cutoff point
16:52:57 <lambdabot>  "....-....|....-....|....-....|....-....|....-....|....-....|....-....|....-...
16:53:15 <omnId> 75 characters
16:53:45 <Tac-Tics> > cycle (map show ([1..9] ++ [0]))
16:53:46 <lambdabot>  ["1","2","3","4","5","6","7","8","9","0","1","2","3","4","5","6","7","8","9"...
16:53:49 <Tac-Tics> doh
16:53:52 <iank> fail
16:54:00 <Tac-Tics> I never get it right on my first attempt
16:54:06 <Tac-Tics> I don't have that skill quite yet
16:54:12 <iank> Few do :)
16:54:15 <Tac-Tics> I think that's the true mark of Haskell mastery
16:54:24 <Tac-Tics> Getting your code to compile the first time you try ;-)
16:54:42 <omnId> I think it's the mark of fixing it before trying it publicly :)
16:55:26 <Tac-Tics> why do that?
16:55:31 <iank> ... yeah, I do that in #perl :P
16:55:33 <Tac-Tics> if I screw up in the channel, I might even learn
16:55:50 <iank> So, you gonna do it right?  :)
16:56:21 <Tac-Tics> I tried getting the liftM2 thing right for about 5 minutes then gave up
16:56:56 <omnId> > liftM (uncurry mplus) [(Nothing, Nothing), (Nothing, Just 2), (Just 1, Nothing), (Just 1, Just 2)]
16:56:58 <lambdabot>  [Nothing,Just 2,Just 1,Just 1]
16:57:01 <Tac-Tics> > cycle (map ((!! 0) . show) ([1..9] ++ [0]))
16:57:03 <lambdabot>  "123456789012345678901234567890123456789012345678901234567890123456789012345...
16:57:25 <halex> hey all, does the latest release of GHC have fromString anywhere in its libraries?
16:57:27 <omnId> (!! 0) = head, and anyway ['1'..'9'] ++ "0" is easier
16:58:14 <Tac-Tics> hah
16:58:19 <Tac-Tics> whatever
16:58:30 <sorear> halex: Don't think so, but I know the head does
16:58:58 <halex> thanks sorear, i wonder why they took it out
16:59:00 <Tac-Tics> > head "head" ++ (!! 0) "(!! 0)"
16:59:01 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
16:59:18 <Tac-Tics> bah!
16:59:23 <omnId> hm
16:59:25 <Tac-Tics> I suck at this haskell thing X-D
16:59:48 <Tac-Tics> > (head "head", (!! 0) "(!! 0)")
16:59:50 <lambdabot>  ('h','(')
17:00:10 <Tac-Tics> @pl cycle (map ((!! 0) . show) ([1..9] ++ [0]))
17:00:10 <lambdabot> cycle (map ((!! 0) . show) ([1..9] ++ [0]))
17:00:58 <omnId> Tac-Tics: oh, right (++) concats lists, but 'h' and '(' are Chars
17:01:07 <Tac-Tics> yeah
17:01:15 <omnId> > [head "head", (!! 0) "(!! 0)"]
17:01:17 <lambdabot>  "h("
17:01:29 <iank> > cycle ['1'..'9'] ++ "0"
17:01:31 <lambdabot>  "123456789123456789123456789123456789123456789123456789123456789123456789123...
17:01:53 <iank> the ...._....| is still easier to read, I think
17:02:04 <Tac-Tics> > cycle['1'..'9'] ++ "#"
17:02:05 <lambdabot>  "123456789123456789123456789123456789123456789123456789123456789123456789123...
17:02:10 <Tac-Tics> doh
17:02:25 <Tac-Tics> > cycle $ ['1'..'9'] ++ "#"
17:02:27 <lambdabot>  "123456789#123456789#123456789#123456789#123456789#123456789#123456789#12345...
17:02:33 <sorear> all infinite lists are left annihilators of ++
17:02:34 <Tac-Tics> 75, yep
17:02:40 <Tac-Tics> they really are
17:02:51 <omnId> > concatMap ("........."++) ['1'..]
17:02:52 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
17:02:59 <Tac-Tics> > last $ cycle undefined
17:03:00 <omnId> hehe, I did it too!
17:03:00 <lambdabot>  Undefined
17:03:05 <iank> So, I have an intuitive-ish idea of what $ does, but what's the actual definition?
17:03:06 <omnId> > concatMap ("........."++) ["1"..]
17:03:06 <lambdabot>   add an instance declaration for (Enum [Char])
17:03:29 <omnId> > concatMap (("........."++).(:[])) ['1'..]
17:03:30 <lambdabot>  ".........1.........2.........3.........4.........5.........6.........7........
17:04:17 <omnId> 78 - 3 '...' characters at end + 1 '"' character = 76
17:04:34 <Tac-Tics> why does last $ cycle undefined not work?
17:04:44 <Tac-Tics> Shouldn't it terminate the other way instead of the way it did?
17:04:52 <omnId> last infiniteList would tend not to work
17:04:57 <Tac-Tics> I know
17:05:04 <Tac-Tics> but why didn't it get that far?
17:05:14 <omnId> @src cycle
17:05:14 <lambdabot> cycle [] = undefined
17:05:14 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
17:05:28 <Tac-Tics> oh whoops
17:05:31 <Tac-Tics> I'm thinking of repeat
17:05:36 <omnId> = undefined ++ cycle undefined = undefined
17:05:53 <Tac-Tics> everything is so darned subtle ^^;
17:06:00 <omnId> :)
17:06:51 <Tac-Tics> It's a very grouchy compiler
17:06:55 <Tac-Tics> much like a college professor
17:07:20 <Tac-Tics> marking you down for shit even though you got most of it 100% correct
17:08:42 <conal> Tac-Tics: perhaps the trick is not to take it personally (in either case).  :)
17:08:50 <Tac-Tics> oh I don't
17:09:01 <Tac-Tics> I just think it's funny to call the compiler grouchy
17:09:22 <Tac-Tics> the compiler errors in Haskell help me pace myself
17:09:24 <conal> all scowly-faced.
17:09:41 <Tac-Tics> if I can't compile some code I wrote, I clearly need to spend more time learning about that subject
17:21:16 <Tac-Tics> > liftM mplus Nothing (Just 3)
17:21:17 <lambdabot>  Couldn't match expected type `Maybe t1 -> t'
17:21:26 <Tac-Tics> > liftM2 mplus Nothing (Just 3)
17:21:27 <lambdabot>   add an instance declaration for (Num (m a))
17:22:48 <Tac-Tics> ah, that's why that wasn't working!
17:22:52 <EvilTerran> > mplus Nothing (Just 3)
17:22:54 <lambdabot>  Just 3
17:23:07 <Tac-Tics> > liftM2 (+) (Just 2) (Just 4)
17:23:09 <lambdabot>  Just 6
17:23:50 <Tac-Tics> it applies the function to the things in the next two boxes and puts them into a spacesuit
17:24:43 <Tac-Tics> @src ap
17:24:44 <lambdabot> ap = liftM2 id
17:25:39 <Tac-Tics> someone said a while ago that 'ap' was somehow related to the S in SKI?
17:26:07 <Tac-Tics> some something
17:26:16 <Tac-Tics> I need to learn about SKI calculus
17:26:21 <Tac-Tics> it seems kinda trippy
17:26:23 <EvilTerran> i think it *is* S, if you're working in Reader
17:26:50 <LoganCapaldo>  yep
17:26:53 <EvilTerran> and return in Reader is K
17:27:03 <LoganCapaldo> also yep
17:27:29 <LoganCapaldo> (for the ((->) r) definition of reader)
17:27:41 <Tac-Tics> I will keep that in mind as I try to find time to learn about it
17:27:42 <LoganCapaldo> @src (->) return
17:27:42 <lambdabot> return = const
17:27:47 <EvilTerran> well, yes. reader rather than Reader, i guess
17:27:48 <Tac-Tics> stupid work and all
17:28:18 <LoganCapaldo> @type (->) ap
17:28:20 <lambdabot> parse error on input `->'
17:28:27 <LoganCapaldo> eh  didn't think that worked :)
17:28:40 <conal> for a simpler setting, consider <*> instead of ap
17:29:06 <Tac-Tics> @type <*>
17:29:08 <conal> <*> and pure are S & K on ((->) a)
17:29:08 <lambdabot> parse error on input `<*>'
17:29:08 <EvilTerran> and indeed pure instead of return, i guess
17:29:18 <conal> @type (<*>)
17:29:19 <EvilTerran> ach, too slow :)
17:29:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:29:29 <conal> @type Applicative.pure
17:29:31 <lambdabot> Couldn't find qualified module.
17:29:35 <Tac-Tics> <*> is an arrows thing?
17:29:40 <Tac-Tics> *guesses*
17:29:40 <conal> @type Control.Applicative.pure
17:29:42 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
17:29:46 <phlpp> is it possible to do something like this: if list length is even, then add first two numbers, then the second two numbers (so num 3 and 4), then the next second two num.. (etc) and when length of list is odd then add element 1 and 2, then add element 2 and 3, and so on
17:29:46 <EvilTerran> it's an Applicative thing
17:29:52 <conal> Tac-Tics: it's an Applicative thing
17:29:59 <conal> which is a simplification of Monad
17:30:00 <EvilTerran> snap!
17:30:00 <Tac-Tics> ah
17:30:05 <phlpp> (result is a list containing the different sums of the additions)
17:30:11 <conal> EvilTerran: you won this time!
17:30:18 <EvilTerran> hoorj~!
17:30:43 <phlpp> more precise i want to create the n-th line of pascal's triangle
17:30:55 <Tac-Tics> it's very possible to do it phlpp
17:31:18 <EvilTerran> well, phlpp, there's much easier ways of making pascal's triangle...
17:31:25 <EvilTerran> http://mathworld.wolfram.com/PascalsTriangle.html
17:31:26 <lambdabot> Title: Pascal's Triangle -- from Wolfram MathWorld
17:31:42 <phlpp> oh, i thought this one is easiest
17:31:43 <phlpp> hehe
17:32:11 <Tac-Tics> The naive approach may not be the best way, but it's still a way ;-)
17:32:11 <EvilTerran> there's a direct formula for any given cell at the top of that page
17:32:14 <Tac-Tics> That's my motto at least
17:32:38 <EvilTerran> it's also quite easy to write a definition of one row in terms of the previous
17:32:58 <EvilTerran> > iterate (\r -> zipWith (+) ([1]++r) (r++[1])) []
17:33:03 <lambdabot>  [[],[2],[3,3],[4,6,4],[5,10,10,5],[6,15,20,15,6],[7,21,35,35,21,7],[8,28,56,...
17:33:14 <EvilTerran> hm. not quite right, but you get the idea.
17:33:29 <phlpp> yeah
17:33:33 <phlpp> 1s are missing
17:33:35 <phlpp> ;)
17:33:43 <conal> > iterate (\r -> zipWith (+) ([0]++r) (r++[0])) [1]
17:33:45 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
17:33:50 <phlpp> but they aren't necessary for my task
17:33:51 <EvilTerran> indeed
17:33:57 <byorgey> grr, beat me by one second!
17:33:57 <conal> cute!
17:34:05 <conal> :I
17:34:14 <byorgey> =)
17:34:15 <EvilTerran> well, i like it :)
17:34:16 <conal> that smiley was a typo, but i like it
17:34:29 <byorgey> it looks like "munching"
17:34:37 <byorgey> i.e. munching on some chips, perhaps
17:35:22 <conal> or like i popped a cookie in my mouth just before mom came in the room, and i'm trying not to show it.
17:35:36 <byorgey> perfect!
17:35:43 <byorgey> that's much better than my explanation
17:35:55 <byorgey> :I
17:35:57 <EvilTerran> hamstery cheek-pouches sort of thing going on?
17:36:06 <conal> yeah, that.
17:36:11 <byorgey> :T
17:36:32 <conal> smiley rorschach test.
17:36:49 <EvilTerran> the cookie's bigger at one end...
17:37:41 <iank> There's a bigger cookie in my pants
17:37:47 <Tac-Tics> I want cookies
17:37:56 <Tac-Tics> I will make some later tonight =-D
17:38:18 <conal> my sweetie Holly baked cookies on Sunday.  yumm.
17:39:51 <newsham> ?vixen can you bake cookies?
17:39:51 <lambdabot> i sure can
17:40:41 <Tac-Tics> @vixen delicious ones?
17:40:42 <lambdabot> nevermind about that
17:40:46 <Tac-Tics> hah
17:41:13 <newsham> vixen is the best chat room chick
17:41:51 <newsham> ?vixen meet me here on irc, ell oh ell oh ell.
17:41:52 <lambdabot> understand now?
17:41:54 <Tac-Tics> Only because society has filtered our internets of nerdy woemn
17:41:56 <Tac-Tics> women*
17:44:14 <Philippa> y'know, I'm not sure what I should complain of first: the fact you prefer the bot to me or the sexism
17:44:25 <byorgey> > let prow n = scanl (*) 1 (map (\k -> (n+1-k)/k) [1%1..n%1]) in map (map numerator . prow) [0..]
17:44:32 <newsham> philippa: you're not a chat room chick.
17:44:33 <lambdabot>      Occurs check: cannot construct the infinite type: t = Ratio t
17:44:33 <lambdabot>       Expe...
17:44:34 <newsham> you're a woman.
17:44:45 <newsham> (yes, I had that line ready just in case you complained)
17:45:07 * Philippa shrugs - so on to the second issue, then
17:45:18 <Philippa> balding 40 y/o guys aside
17:45:30 <newsham> vixen is sexism.  you cannot separate vixen from sexism.
17:45:42 <byorgey> > let prow n = scanl (*) 1 (map (\k -> (n+1-k)/k) [1%1..n%1]) in map (map numerator . prow . (%1)) [0..]
17:45:43 <lambdabot>      Occurs check: cannot construct the infinite type: t = Ratio t
17:45:43 <lambdabot>       Expe...
17:46:31 <byorgey> > let prow n = scanl (*) 1 (map (\k -> (n+1-k)/k) [1%1..n]) in map (map numerator . prow) [0..]
17:46:32 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
17:46:50 <byorgey> there we go =)
17:46:59 <Philippa> doesn't have to be. Vixen could, for example, be a parody thereof. Whereas talking about chatroom chicks does actually put people off. It's not quite as bad as "OMG, a woman on IRC!!", but still
17:47:25 <newsham> ?vixen i have blue eyes
17:47:25 <lambdabot> you're my type
17:47:29 <ricky_clarkson> Philippa: I assume you're familiar with the relevant xkcd entry.
17:47:49 <newsham> so vixen can be a parody, but my comments about her cannot be?
17:47:50 <byorgey> Joanna, fire.
17:47:59 <Philippa> ricky_clarkson: yeah. You can assume I don't need hat guy telling me when I can open fire
17:48:07 <ricky_clarkson> Philippa: Heh.
17:48:32 * iank wonders where he has to register to take a turing test
17:48:35 <Philippa> vixen is rather more obviously parody
17:48:46 <iank> They don't give 'em along with the SATs, do they?
17:48:53 <Pseudonym> iank: They have them online.
17:48:57 <newsham> subtlety is next to godlety
17:49:00 <Philippa> @vixen know Eliza?
17:49:00 <lambdabot> isn't it obvious?
17:49:07 <iank> Pseudonym: I want it to be official :(
17:49:07 <Philippa> @vixen in the biblical sense?
17:49:08 <lambdabot> who's to say?
17:49:09 <newsham> (perhaps godelty?)
17:49:13 <ricky_clarkson> There's a statue of Alan Turing a few miles away.  One day I'll blog sat next to it.
17:49:35 <iank> You'll what now?
17:50:13 <Philippa> sometimes subtlety is a bad idea. Thankfully I don't have to tacnuke someone to communicate with them directly :-)
17:50:30 <newsham> ?vixen where are your panties?
17:50:30 <lambdabot> i prefer to go without panties or bras :)
17:50:43 <ricky_clarkson> Me too.
17:50:50 <Pseudonym> iank: You want to prove that you're human?
17:51:11 <Tac-Tics2> oh lord
17:51:19 <Tac-Tics2> Lambdabot is a functional pervert
17:51:41 * Pseudonym wonders, on some occasions, whether or not vixen should be restricted to haskell-blah
17:51:42 <iank> Pseudonym: perhaps
17:51:59 <Pseudonym> Given that Haskell is all serious and stuff now.
17:52:10 <iank> Is not!
17:52:19 <Pseudonym> iank: And your mom!
17:52:20 <newsham> isnt ?vixen-on in #haskell-blah?
17:52:22 <Tac-Tics2> Lambdabot is there only to relieve the stress of the noobie haskellers
17:52:29 <newsham> btw, does ?vixen-on bind only to one channel or all?
17:52:34 <Pseudonym> I use lambdabot every day.
17:52:38 <iank> Pseudonym: your FACE!
17:52:58 <Pseudonym> Saves me firing up GHCi or hoogle.
17:53:24 <Tac-Tics2> and you can spam the channel with error messages and nonsense
17:53:27 <newsham> everyone should have a ghci of their own
17:53:41 <iank> I keep a ghci in the bathroom
17:53:45 <LoganCapaldo> I have a lambdabot of my own, but I haven't gotten @run to work yet
17:53:49 <Pseudonym> I usually use /msg unless I think other people might find it interesting.
17:53:51 <Tac-Tics2> #haskell is more like a GHCi plugin than anything else
17:54:00 <newsham> iank: next to the crapintosh?
17:54:15 <sorear> newsham: all of them.
17:55:00 <iank> In all seriousness, it would be pretty awesome to have a dumbterm in the bathroom -_-
17:55:34 <ricky_clarkson> iank: I use my laptop from the bath.  It sits on a chair.
17:56:27 <newsham> the l0pht had a terminal in the bathroom (I think it might have been the "crapintosh", but that might have been something else.. memory fades)
17:56:37 <Tac-Tics2> ricky_clarkson: I did that once. It was good times
17:57:04 <Tac-Tics2> Baths are good places to think
17:57:46 <newsham> tac: i think the lack of computers in the bathroom contributes to that
17:57:53 <newsham> isolated with your thoughts
17:57:59 <newsham> something we dont do much these days
17:58:15 <Tac-Tics2> Thinking by yourself is boring because computers have made us boring people
17:58:29 <newsham> not vixen, vixen is interesting!
17:58:40 <Philippa> lambdabot's useful for discussions amongst non-newbies too
17:58:41 <newsham> ?vixen i'm not very honest, but I find you very interesting.
17:58:41 <lambdabot> oh, i'm not either
17:58:47 <Tac-Tics2> I got my bound copy of SICP today, so I'm going to be taking a bath for sure tonight to read it ;-)
17:58:51 <Philippa> sometimes it's quicker to evaluate something in public
18:00:04 <Tac-Tics2> I have been wanting to read SICP front to back for many months now, but I can't stand to read it online.... it's the font or something..... so I bought a used library copy for $20 on Half.com
18:00:20 <Tac-Tics2> The public is more willing to shoot down terrible ideas so you don't waste time thinking about them
18:02:20 <newsham> thinking about bad ideas is good practice for thinking about new problems that others havent yet
18:02:39 <Tac-Tics2> that's probably true
18:03:14 <Philippa> yeah. Thinking about why they're bad can be helpful too
18:03:17 <sorear> the public shoots down all ideas
18:03:37 <Philippa> tries to, anyway
18:03:42 <Tac-Tics2> sorear: that is the truest statement ever
18:03:55 <Tac-Tics2> I don't know why I bother reading slashdot any more
18:08:14 <phlpp> cya
18:09:57 <sgillespie> what is the library text-any?
18:10:11 <sgillespie> its required as a build dependancy, can't seem to figure it out
18:10:47 <mrd> got a new pkg?
18:11:04 <mrd> sounds like a ghc 6.8ism
18:11:58 <sgillespie> maybe it has something to do with Text.HTML
18:12:19 <mrd> checked hackage?
18:15:24 <sgillespie> appears to be html
18:16:44 <sgillespie> looks like i got wsp installed finally
18:34:10 <newsham> is it bad to use "hClose" after "hGetContents"?
18:39:32 <Tac-Tics2> why would it be?
18:40:17 <Tac-Tics2> The docs say the handle becomes semi closed after hGetContents is called on it
18:40:30 <Tac-Tics2> and all that means is that the only legal operation on that socket (I think) is hClose
18:46:09 <sorear> newsham, Tac-Tics2: yes, but after you close it, future read operations will fail
18:46:37 <sorear> newsham, Tac-Tics2: and since H98 predates catchable pure exceptions, they decided to make failure in lazy IO silent
18:47:00 <sorear> newsham, Tac-Tics2: "foo <io error or handle closed> bar" is given to your program as "foo "
18:50:45 <Tac-Tics2> silent errors are ew
18:57:16 <Pseudonym> Any potential OzHaskellers here?
18:58:24 <Pseudonym> It's occurred to me that linux.conf.au is being held in Melbourne from 28 Jan to 2 Feb.
18:59:01 <n00b> how can Write a function digits that takes an integer, and returns the pair of the right most, and the second to right most digit
18:59:02 <Pseudonym> Holding it around then, but not over those dates specifically, might not be such a dumb idea if people are planning to go to that.
18:59:27 <n00b> i know how to get the last digit a `mod` 10
18:59:43 <ksandstr> (a `mod` 100) `div` 10 ?
19:00:35 <chadz> alright, i trust my fellow haskellers. I can't figure out what type of beer to brew for my first batch. what say you all?
19:00:47 <Pseudonym> chadz: I wish drtomc was here.
19:00:51 <Pseudonym> He's the real expert.
19:01:25 <ksandstr> hm. rather, (a `div` 10) `mod` 10. `div` 10 is like a right shift for integers
19:03:41 <Pseudonym> John Shepherd is also famed for his homebrew, but he doesn't do Haskell any more.
19:05:36 <chadz> Pseudonym: thanks, i'll keep my eye peeled for drtomc.
19:06:17 <Pseudonym> ?seen drtomc
19:06:18 <lambdabot> I saw drtomc leaving #haskell 13d 5h 29m 4s ago, and .
19:06:22 <Pseudonym> Don't hold your breath.
19:06:41 <chadz> meh, i've been away for a month, anything could happen :)
19:06:43 <chadz> ?seen fuzan
19:06:44 <lambdabot> I saw fuzan leaving #haskell 2m 10d 19h 14m 13s ago, and .
19:06:51 <chadz> err, a bit more than a month.
19:12:17 <n00b> how do I write a function to add two rational numbers (e.g. rtnlAdd (3,4) (1,2) = (10,8))
19:12:35 <omnId> > 3%4 + 1%2
19:12:37 <lambdabot>  5%4
19:13:32 <Pseudonym> You may need to import Data.Ratio if you want cool stuff.
19:15:40 <n00b> I want to write my own ratio function
19:15:53 <Pseudonym> What algorithm would you use?
19:17:42 <hpaste>  n00b pasted "rational" at http://hpaste.org/3338
19:17:51 <n00b> i think it is wrong
19:17:57 <n00b> wrote a while ago
19:18:55 <n00b> ???
19:18:55 <dmwit> n00b: ...do you even know about fractional arithmetic?
19:19:03 <n00b> nope
19:19:06 <Pseudonym> Ah.
19:19:08 <Pseudonym> Well.
19:19:12 <dmwit> Use google.
19:19:15 <Pseudonym> Yeah.
19:19:15 <dmwit> ?go fraction add
19:19:17 <lambdabot> http://themathpage.com/arith/add-fractions-subtract-fractions-1.htm
19:19:17 <lambdabot> Title: Adding and subtracting fractions -- A complete course in arithmetic
19:19:59 <dmwit> n00b: Also, how old are you?
19:21:35 <swix> n00b, well, multiply both numerators by the LCM of both denominators, then add them, and the LCM becomes the new denominator, and you can perhaps reduce using the GCD
19:21:50 <swix> alternatively, you can just multiply by the product of the denominators
19:22:09 <dmwit> swix: If he hasn't got fractional arithmetic down, I doubt he groks GCDs and LCMs yet.
19:22:35 <swix> well, in retrospect, I learned LCM and GCD in elementary school before we did rational operations
19:22:36 <dmwit> (Though I've been wrong before.)
19:22:51 <omnId> > lcm 4 5
19:22:53 <lambdabot>  20
19:22:58 <dmwit> Maybe I would have understood fractions better if we had done it in that order. =)
19:24:00 <n00b> i am 11
19:24:10 <Pseudonym> Right.
19:24:21 <Pseudonym> OK, this information helps. :-)
19:24:24 <TSC> Don't worry, we go all the way to 11 here
19:24:38 <omnId> sorear: I think you've been surpassed.
19:25:03 <dmwit> TSC: Why don't you just make 10 be older?
19:25:15 <Pseudonym> n00b: You're in luck.  I wish I'd had Haskell when I was learning this stuff.
19:25:16 <sorear> well I grokked rational arithmetic at 4
19:25:24 <omnId> @slap sorear
19:25:24 * lambdabot pulls sorear through the Evil Mangler
19:25:28 <omnId> :O
19:25:32 <dmwit> That's new.
19:25:33 <swix> n00b, do you understand how to find the lowest common multiple?
19:25:36 <Pseudonym> My 5-year-old daughter is starting to appreciate negative numbers.
19:25:39 <Olathe> Evil Mangler > *
19:25:46 <Pseudonym> First things first, swix.
19:25:49 <omnId> @be-slightly-less-evil-to sorear
19:25:49 <lambdabot> Unknown command, try @list
19:25:49 <dmwit> Evil Mangler > ??
19:25:58 <swix> Pseudonym, that is first, it's the simplest thing to find!
19:25:59 <Pseudonym> First, you need to understand that a/c + b/c = (a+b)/c
19:26:09 <Pseudonym> Second, you need to understand that a/b = ac/bc
19:26:11 <swix> Pseudonym, don't tell me you charge your daughter usury?
19:26:26 <Pseudonym> swix: No, but thanks for the suggestion.
19:26:40 <Pseudonym> And once you've got that, you can have:
19:26:49 <swix> Pseudonym, she'll be well on her way to understanding the geometric progression if you do
19:26:54 <Arnar> ?index LanguageDef
19:26:55 <lambdabot> Text.ParserCombinators.Parsec.Token, Text.ParserCombinators.Parsec.Language, Text.ParserCombinators.Parsec.Token, Text.ParserCombinators.Parsec.Language
19:27:00 <Pseudonym> a1/a2 + b1/b2 = a1b2/a2b2 + b1a2/a2b2 = (a1b2+b1a2)/a2b2
19:27:10 <Pseudonym> Then introduce gcd.
19:27:11 <Olathe> > let "Evil Mangler" > (*) = True in "yep"
19:27:13 <lambdabot>  "yep"
19:27:14 <Arnar> ?index opStart
19:27:14 <lambdabot> Text.ParserCombinators.Parsec.Token, Text.ParserCombinators.Parsec.Language
19:27:28 <swix> Pseudonym, what about teaching what a sub 1 means first :P
19:27:50 <Pseudonym> swix: She can already use an addiator.
19:28:03 <Pseudonym> And she's currently working out how to handle a soroban.
19:28:43 <swix> ooh
19:28:47 <swix> I <3 my abacus
19:28:56 <Pseudonym> What kind do you have?
19:28:58 <dmwit> I call bullshit; neither addiator nor soroban is in dict.die.net. =P
19:29:03 * ddarius stares at Pseudonym blankly.
19:29:22 <swix> Pseudonym, I'm not sure of the exact names, but does hex and has 13 columns
19:29:25 <Pseudonym> http://en.wikipedia.org/wiki/Addiator -- Mine is much shinier than this.
19:29:29 <Pseudonym> Oh, now THAT'S cool.
19:29:31 <Pseudonym> Hex abacus.
19:29:47 <swix> well, the two beads on top means it can each handle 16 states
19:29:59 <Pseudonym> Ah, right.
19:30:04 <Pseudonym> So it's a Chinese one.
19:30:04 <swix> nothing really changes about the basic operations afaik
19:30:13 <swix> I prefer decimal though
19:30:25 <Pseudonym> Actually, that's a damn clever idea.
19:30:30 <Pseudonym> Using a Chinese abacus for hex.
19:31:28 <n00b> i know i have to find the lcm of the a b
19:32:28 * Pseudonym actually has a professional soroban, probably used by an accountant
19:33:05 <Arnar> ?type reserved
19:33:07 <lambdabot> Not in scope: `reserved'
19:33:18 <Arnar> ?index reserved
19:33:18 <lambdabot> Network.URI, Text.ParserCombinators.Parsec.Token
19:34:35 <omnId> rAdd (n1, d1) (n2, d2) = (..., d) where d = lcm d1 d2 -- is a start
19:35:27 <Arnar> hi folks.. is this outdated --> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
19:35:30 <Arnar> ?
19:35:52 <sorear> Arnar: The page, yes.  The library, no.
19:36:00 <swix> n00b, so do you understand how to add fractions on paper?
19:36:02 <Arnar> sorear: yeah.. meant the page..
19:36:08 <sorear> Arnar: Don't bother downloading it, it's part of the cross-implementation standard library
19:36:09 <Pseudonym> It'd be nice to have a "new" Parsec tutorial.
19:36:22 <Arnar> sorear: yes.. figured that out already,
19:36:26 <allbery_b> the original documentation is outdated, but still describes Parsec *usage* better than the documentation that comes with the standard library version IME
19:36:35 <Arnar> allbery_b: ok..
19:36:41 <Arnar> I'm having some problems with "reserved"
19:36:55 <Arnar> it's type in the docs is [Char] -> ...
19:37:06 <ddarius> > 30000/1001
19:37:09 <lambdabot>  29.97002997002997
19:37:14 * nornagon . o O ( Mr Horrible, Mr Horrible, there's a phone call for Mr Horrible... )
19:37:15 <Arnar> but for me it's expecting TokenParser st
19:37:22 <omnId> @hoogle reserved
19:37:22 <lambdabot> Network.URI.reserved :: Char -> Bool
19:37:22 <lambdabot> Text.ParserCombinators.Parsec.Token.reserved :: TokenParser st -> (String -> CharParser st ())
19:37:22 <lambdabot> Text.ParserCombinators.Parsec.Language.reservedNames :: LanguageDef st -> [String]
19:37:57 <Arnar> omnId: can you point me to some usage examples?
19:38:25 <sorear> Arnar: the type in the docs is the type of the FIELD
19:38:36 <TSC> Arnar: You specialise reserved with a tokeniser first, then give it the string
19:38:39 <sorear> Arnar: which is NOT the same as the selector's type
19:38:46 * omnId checks the docs
19:39:22 * sorear thinks this error is made far too often
19:39:35 <hpaste>  Arnar pasted "Parsec reserved words" at http://hpaste.org/3339
19:40:02 <TSC> You want "reserved lexer "nop"
19:40:13 <Arnar> ah..
19:40:15 <Pseudonym> Speaking of fractions...
19:40:17 <Pseudonym> http://letsplaymath.wordpress.com/2007/10/16/quiz-those-frustrating-fractions/
19:40:20 <lambdabot> Title: Quiz: Those frustrating fractions  Let&#8217;s play math!, http://tinyurl.com/ynw7sm
19:40:40 <TSC> Or you import the Token module with qualified, and then say "reserved = Token.reserved lexer"
19:40:45 <sorear> Arnar: if you want a field, you have to apply a selector to a record.  You can't just name the selector and magically expect the system to find your record.
19:40:57 <TSC> Then you use 'reserved "nop"' everywhere
19:41:41 <Arnar> sorear: oh, ok.. I get it .. that's why the docs have "reserved = P.reserved lexer"
19:41:46 <TSC> That's right
19:42:11 <Arnar> sorear: sorry.. I'm just a noob
19:42:20 <Arnar> TSC++
19:42:59 <TSC> I didn't immediately grasp the design of Parsec either (:
19:43:07 <dmwit> Pseudonym: All of these questions are easy to answer if you replace "fractions" with "division" everywhere.
19:43:19 <sjanssen> sorear: are you sure that's true?
19:43:28 <dmwit> Pseudonym: Then it's a simple application of order-of-operations to understand why, eg, addition and division don't commute.
19:43:40 * sjanssen points out "patch applied (ghc): View patterns, record wildcards, and record puns" :)
19:43:46 <dmwit> (Though if I were explaining it to my child, I'd probably avoid the word commute.)
19:45:39 <NichardRixon> hi
19:45:41 <nburlett> quick question: why do I get Could not find module `Network' in ghc 6.6.1?
19:45:56 <nburlett> it works on my Mac OS X 6.6.1 installation, not on my linux box
19:46:02 <Pseudonym> dmwit: Sure.  _I_ know the answers, and so do you.
19:46:08 <dmwit> Hi, NichardRixon!
19:46:17 <sorear> Hello NichardRixon
19:46:17 <Pseudonym> This is about students, and cutting through the confusion.
19:46:28 <dmwit> Right, okay.  Sorry.
19:46:56 <sjanssen> nburlett: your distribution must not package network with GHC, there's probably another package you can install
19:47:06 <sjanssen> (this is the norm for most packages of GHC today)
19:47:15 <nburlett> sjanssen: ok, I'll try to find it.. do you know what it might be for Gentoo?
19:47:23 <sjanssen> dev-haskell/network, perhaps?
19:47:53 <nburlett> yup
19:48:21 <nburlett> seems to be it
19:48:23 <nburlett> thanks!
19:48:39 * nburlett installs
19:53:01 <nburlett> did you guys see this? http://kovaya.com/miscellany/2007/10/insert-coin.html
19:53:02 <lambdabot> Title: Miscellany: INSERT COIN
19:55:28 <Olathe> nburlett: Heheh
19:55:33 <hpaste>  nburlett pasted "Insert Coin" at http://hpaste.org/3340
19:55:42 <nburlett> ^^^ my haskell implementation
19:58:41 <nburlett> anyway, I need to head home.
19:58:57 <nburlett> cya
19:59:03 <nburlett> thanks for the tip, sjanssen
20:03:05 <hpaste>  n00b annotated "rational" with "rational" at http://hpaste.org/3338#a1
20:03:13 <n00b> this is what i got
20:03:20 <n00b> please help
20:04:46 <omnId> n00b: do the multiplication before the div, doing the div first will give you a rounding error.
20:05:48 <Cale> It's probably best to save the div for after the addition even.
20:06:18 <omnId> I think you've also flipped which things to multiply and divide by, but I can't express why.
20:06:46 <n00b> getting a zero
20:06:56 * omnId hates arithmetic
20:06:58 <Pseudonym> Yeah, that's because of rounding.
20:07:10 <Pseudonym> a2 `div` b is always going to be 1 or 0 (ignoring negative numbers).
20:07:19 <Pseudonym> Same with b2 `div` b.
20:07:27 <Pseudonym> With 0 being the overwhelmingly more likely possibility.
20:07:31 <Arnar> is there something like "take" with type forall a. Int -> [a] -> IO [a]
20:07:41 <Pseudonym> n00b: Here's a suggestion.
20:07:45 <omnId> Arnar: take then return?
20:07:47 <Pseudonym> Try it with a concrete example on paper first.
20:08:01 <omnId> return :: [a] -> IO [a]
20:08:27 <Pseudonym> Then, see what the program does with your example, on paper.
20:08:37 <Pseudonym> You can, of course, use Haskell to compute the LCM.
20:08:57 <ddarius> :t lcm
20:08:59 <lambdabot> forall a. (Integral a) => a -> a -> a
20:09:24 <Arnar> omnId: like.. return . take ?
20:09:27 <omnId> :t \i xs -> return (take i xs)
20:09:29 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> [a] -> m [a]
20:09:35 <TSC> (return .) . take
20:09:41 <omnId> actually (return .) . take since take has two args
20:09:44 <Arnar> ah
20:10:00 <Arnar> but if I want to fix the int guy
20:10:03 <shachaf> \i -> return . take i -- May be clearer
20:10:26 <Arnar> :t return . (take 10)
20:10:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m [a]
20:10:37 <Arnar> think that's what I need
20:10:50 <omnId> > return . (take 3) $ [1..10] :: Maybe [Int]
20:10:51 <lambdabot>  Just [1,2,3]
20:11:05 <Arnar> exactly..
20:11:10 <Arnar> omnId++ thanks
20:11:28 <shachaf> What's the point of this, though?
20:11:37 <shachaf> If it starts with a pure list?
20:12:20 <Arnar> saccade: as the second argument to >>=
20:12:40 <omnId> Arnar: if you're binding out, then returning back in, you could use fmap or liftM
20:12:47 <shachaf> Exactly.
20:12:54 <omnId> m >>= \x -> return (f x) = fmap f m
20:13:03 <shachaf> > fmap (take 3) (Just [1..10])
20:13:05 <lambdabot>  Just [1,2,3]
20:13:05 <Arnar> ok.. I'm sortof flying blind here - not grokking monads yet
20:13:13 <omnId> @src liftM
20:13:13 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:13:14 <shachaf> @src liftM
20:13:15 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:13:24 <omnId> ^^ that source should be illustrative :)
20:13:30 <shachaf> Or, with Control.Applicative:
20:13:33 <Arnar> yes, thanks..
20:13:40 <shachaf> > take 3 <$> Just [1..10]
20:13:41 <omnId> it already does the binding out then returning.
20:13:41 <lambdabot>  Just [1,2,3]
20:14:45 <omnId> fmap, liftM, (<$>), liftA, are all precisely the same function modulo type contexts.
20:14:48 <ddarius> While I prefer the do-notation to a let notation, I wonder how people would react to it.
20:15:00 <geocalc> > [1..3]
20:15:01 <shachaf> omnId: Careful, you might get me started again. :-)
20:15:01 <lambdabot>  [1,2,3]
20:15:19 <omnId> shachaf: I specified the difference :)
20:16:39 <krishnbhakt> > [1..]
20:16:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:16:54 <Arnar> > take 3 `liftM`Just [1..10]
20:16:54 <lambdabot>   lexical error (UTF-8 decoding error)
20:17:05 <Arnar> sorry, backspace messing up
20:17:11 <omnId> map f xs changes the "contents" of a list by applying f.  fmap f m changes the "contents" of m, whichever type it is, by applying f.
20:17:15 <Arnar> > take 3 `liftM` Just [1..10]
20:17:16 <lambdabot>  Just [1,2,3]
20:17:26 <shachaf> @let map = fmap
20:17:27 <lambdabot> <local>:1:6:     Ambiguous type variable `f' in the constraint:       `Functo...
20:17:30 <shachaf> @let (.) = fmap
20:17:31 <lambdabot> <local>:1:6:     Ambiguous type variable `f' in the constraint:       `Functo...
20:18:06 <omnId> > fmap (+1) (*2) 3
20:18:07 <lambdabot>  7
20:18:13 <dons> http://programming.reddit.com/info/5ygt8/comments :)
20:18:14 <lambdabot> Title: programming: Want a Haskell job? Do you grok monad transformers, laziness and ty ...
20:18:18 <omnId> > ((+1) . (*2)) 3
20:18:19 <lambdabot>  7
20:19:39 <omnId> (*2) :: Integer -> Integer, or, given type IntegerReader = (->) Integer, (*2) :: IntegerReader Integer.
20:20:01 <omnId> fmap (+1) changes the "result" Integer by applying (+1) to (*2)'s result.
20:20:04 <shachaf> dons: I suppose "North West USA" isn't ever likely to include WA?
20:20:27 <omnId> i.e. simple function composition.
20:21:14 <nornagon> surely (*2) :: Num a => a -> a
20:21:18 <nornagon> @ty (*2)
20:21:19 <omnId> surely
20:21:20 <lambdabot> forall a. (Num a) => a -> a
20:21:35 <omnId> but I was being monomorphic for simplicity's sake.
20:21:44 <nornagon> ah.
20:21:50 <shachaf> @ghc monomorphi
20:21:51 <lambdabot> ghc says: falls under the monomorphism restriction
20:22:00 <omnId> in the above expression, it does happen to default to Integer anyway :)
20:22:01 <dons> shachaf: well...
20:22:14 <dons> shachaf: i admit, to start with it'll probably be a Portland thing
20:22:21 <dons> since its a big country :)
20:22:54 <shachaf> Oh, well. :-)
20:23:08 <shachaf> There's SeaFunc, I guess, but even that's a bit far from here.
20:23:11 <Arnar> :index liftM
20:23:19 <Arnar> ?index liftM
20:23:20 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:23:26 <omnId> fmap is in Prelude
20:23:50 <Arnar> omnId: ok.. what really is the difference?
20:23:54 <Arnar> why all the different names?
20:23:59 <omnId> none in principle
20:24:09 <shachaf> Arnar: There shouldn't be any.
20:24:10 <omnId> hystorical reasons
20:24:13 <shachaf> @src (<$>)2
20:24:13 <lambdabot> Source not found. My brain just exploded
20:24:14 <shachaf> @src (<$>)
20:24:14 <lambdabot> f <$> a = fmap f a
20:24:18 <thoughtpolice> woot. after a couple days hacking all i can, my bot lives finally. :)
20:24:59 <omnId> (<$>) is *precisely* fmap, liftM and fmap *should* be precisely the same, but the Monad class doesn't inherit Functor like it should.
20:25:00 <ddarius> @src 1
20:25:00 <lambdabot> Source not found. Wrong!  You cheating scum!
20:25:59 <omnId> it is possible to write Functor and Monad instances for your type such that fmap /= liftM, but according to the report, such instances are incorrect.
20:26:47 <dons> shachaf: hmm, do they talk haskell at SeaFunc?
20:26:51 <dons> maybe that should be on the user group list
20:26:59 <Korollary> Sometimes
20:27:01 <Korollary> It's mostly me
20:27:27 <shachaf> dons: I'm not sure.
20:27:39 <shachaf> dons: There are some LISPers, I know.
20:27:44 <Korollary> Most are lispers
20:28:17 <Korollary> We have one ocaml guy
20:28:27 <hpaste>  n00b annotated "rational" with "rational (last)" at http://hpaste.org/3338#a2
20:28:39 <n00b> this is what i did
20:28:47 <n00b> seems to worl
20:28:50 <n00b> work
20:28:55 <n00b> what do u think
20:28:57 <n00b> ???
20:28:58 <shachaf> Korollary: cdiggins used to go, right? He Haskells, I think.
20:29:06 * shachaf has never gone to a meeting.
20:30:52 <omnId> @let rtnlAdd (a1,b1) (a2,b2) = c where a = (((b `div` b1) * a1) + ((b `div` b2) * a2)); b = lcm b1 b2; c = (a,b)
20:30:59 <lambdabot> Defined.
20:31:18 <Korollary> shachaf: He doesn't. He wasn't doing anything but working on his own language.
20:31:24 <sorear> just use a smart constructor
20:31:39 <omnId> @check \a b c d -> (a%b + c%d) == uncurry (%) (rtnlAdd (a,b) (c,d)) :: Int -> Int -> Int -> Int -> Bool
20:31:40 <lambdabot>  Couldn't match expected type `Int -> Int -> Int -> Int -> Bool'
20:31:56 <omnId> @check (\a b c d -> (a%b + c%d) == uncurry (%) (rtnlAdd (a,b) (c,d))) :: Int -> Int -> Int -> Int -> Bool
20:31:57 <lambdabot>  Exception: Ratio.%: zero denominator
20:32:03 <sorear> a :% b + c :% d = (a*d + c*b) % (b*d)
20:32:14 <sorear> nice
20:32:18 <n00b> >let rtnlAdd (a1,b1) (a2,b2) = c where a = (((b `div` b1) * a1) + ((b `div` b2) * a2)); b = lcm b1 b2; c = (a,b) in rtnlAdd (1,2)(2,3)
20:32:32 <n00b> > let rtnlAdd (a1,b1) (a2,b2) = c where a = (((b `div` b1) * a1) + ((b `div` b2) * a2)); b = lcm b1 b2; c = (a,b) in rtnlAdd (1,2)(2,3)
20:32:34 <lambdabot>  (7,6)
20:32:54 <omnId> @check (\a b c d -> all (>0) [a,b,c,d] ==> (a%b + c%d) == uncurry (%) (rtnlAdd (a,b) (c,d))) :: Int -> Int -> Int -> Int -> Property
20:32:56 <lambdabot>  Arguments exhausted after 35 tests.
20:33:00 <omnId> @scheck (\a b c d -> all (>0) [a,b,c,d] ==> (a%b + c%d) == uncurry (%) (rtnlAdd (a,b) (c,d))) :: Int -> Int -> Int -> Int -> Property
20:33:01 <lambdabot>   Completed 28561 test(s) without failure.  But 27265 did not meet ==> condit...
20:33:17 <omnId> looks good :)
20:34:21 <omnId> at least a thousand got through.
20:34:38 <Pseudonym> a and c don't have to be > 0
20:34:50 <omnId> @scheck (\a b c d -> all (>0) [b,d] ==> (a%b + c%d) == uncurry (%) (rtnlAdd (a,b) (c,d))) :: Int -> Int -> Int -> Int -> Property
20:34:51 <lambdabot>   Completed 28561 test(s) without failure.  But 22477 did not meet ==> condit...
20:35:00 <omnId> 5000 more
20:35:14 <Pseudonym> And it's a "corner case" that might come up in real progra,s./
20:35:52 <chadz> :t (%)
20:35:54 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
20:36:10 <chadz> 10%2
20:36:13 <chadz> err
20:36:16 <chadz> > 10%2
20:36:17 <lambdabot>  5%1
20:36:34 <chadz> never seen that library :)
20:36:39 <omnId> @src (%)
20:36:39 <lambdabot> x % y = reduce (x * signum y) (abs y)
20:37:00 <omnId> @src reduce
20:37:00 <lambdabot> reduce _ 0 = undefined
20:37:01 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
20:37:01 <lambdabot>     where d = gcd x y
20:47:02 <dons> reduce eh? that's not often seen
20:50:38 <jcreigh> hmm, yeah. the name "reduce" makes me think of a fold.
20:52:23 <dibblego> same
20:52:32 <dibblego> foldx1 specifically
20:52:50 <iank> reduce is a less general fold, no?
20:53:09 <dibblego> ?type reduce
20:53:11 <hpaste>  FMota pasted "What do you think of this syntax?" at http://hpaste.org/3341
20:53:11 <lambdabot> Not in scope: `reduce'
20:53:28 <FMota> btw, that's non-haskell
20:53:31 <FMota> ;)
20:54:21 <dgriffi3> FMota: what is it then?
20:55:19 <FMota> I call it Sei, but that's what I seem to call every functional language/syntax I make lately.
20:55:51 <shapr> yarr
20:56:22 <dgriffi3> looks like maude
20:56:26 <FMota> maude?
20:56:35 <ddarius> FMota: No problem reusing the name if there is nothing but hpaste posts to show for the last incarnation.
20:56:41 <ddarius> @google Maude OBJ
20:56:44 <dgriffi3> http://maude.cs.uiuc.edu/
20:56:45 <lambdabot> Title: Maude
20:56:46 <lambdabot> http://lists.tunes.org/archives/tunes/2001-November/003213.html
20:56:46 <lambdabot> Title: Maude / OBJ language family
20:56:50 <FMota> :) and blog posts. Indeed :)
20:56:56 <FMota> thank you
20:57:08 <dgriffi3> though maybe that is because I have two class with maude stuff this semester
20:58:04 * shapr updates his lat/long on @where map
20:58:27 <shapr> What beautiful Haskell code can I play with tonight?
20:59:18 <ddarius> Not Haskell, but I started fiddling with my CT article again.  Perhaps I'll pull it through enough to get a readable first cut draft out.
20:59:27 <FMota> shapr:    find a suitable name for:   map read . map (:[]) . show
20:59:59 * FMota thinks he's going to write a post/article about monads. For dummies. :)
21:00:01 <ddarius> :t map read . map return . show
21:00:05 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> [a]
21:00:12 <ddarius> FMota: We don't need another.
21:00:13 <omnId> :t map digitToInt . show
21:00:18 <lambdabot> forall a. (Show a) => a -> [Int]
21:01:01 <FMota> digits n = map digitToInt . show
21:01:14 <FMota> ...although I like using the monkey operator more
21:01:36 <omnId> :t map (map digitToInt . (:[]) . show -- (   :)
21:01:38 <lambdabot> parse error (possibly incorrect indentation)
21:01:41 <shachaf> FMota: Monkeys aren't efficient.
21:01:49 <TSC> ddarius: CT as in category theory?
21:01:52 <omnId> :t map (map digitToInt . (:[])) . show
21:01:52 <chessguy> wow, a monad tutorial. brilliant idea, why hasn't anybody else done that?
21:01:53 <FMota> ddarius: but has anyone written one focused on the xkcd comic?
21:01:55 <ddarius> TSC: Yes.
21:01:56 <lambdabot> forall a. (Show a) => a -> [[Int]]
21:02:04 <ddarius> FMota: Which?  And possibly.
21:02:08 <FMota> :p
21:02:17 <TSC> ddarius: I started reading Lawvere's introductory book in category theory; it seems pretty good so far
21:02:17 <FMota> the one where there are two guys
21:02:28 <chessguy> we need a BobbyTables monad :)
21:02:31 <FMota> and one is thinking a hypothetical situation
21:02:45 <chessguy> oh, the ice cream one
21:02:57 <FMota> and inside the hypothetical situation, the other guy is thinking how to get out
21:03:08 <ddarius> FMota: There was a discussion of that on the mailinglist.
21:03:12 <FMota> ...sarting anoher, nested, hypthetical situation
21:03:25 <ddarius> That could well be viewed as yet another "monads for dummies" style introduction.
21:03:38 <FMota> and he uses a knife to get out of the innermost one
21:04:01 <TSC> unsafeKnife?
21:04:08 <moonlite> :)
21:04:14 <FMota> but in this case it's perfectly safe
21:04:18 <shachaf> FMota: It would be easier to say the URL. :-)
21:04:30 <ddarius> TSC: Maclane is the "bible" for CT and is more readable than I thought.  You may want to try laying your hands on that.
21:04:33 <FMota> because it's contained within the outer hypothetical situation
21:04:43 <FMota> shachaf: if I had it... :p
21:04:52 <FMota> @google xkcd monad
21:04:53 <shachaf> xkcd.com/248
21:04:54 <lambdabot> http://forums.xkcd.com/viewtopic.php?f=12&t=8450
21:04:54 <lambdabot> Title: xkcd &bull; View topic - graph theory in haskell
21:05:03 <FMota> :/ no, I dont think so
21:05:12 <ddarius> TSC: If you are talking about Conceptual Mathematics (I think it's called), then I hear that it is not very deep or comprehensive.
21:05:17 <FMota> ah
21:05:24 <FMota> thank you shachaf !
21:06:11 <TSC> ddarius: Yes, that's the one.  I don't mind if it's shallow to begin with.  My library has MacLane as well, so I'll read that too, thanks!
21:07:30 <puusorsa> @src (>|)
21:07:31 <lambdabot> Source not found. :(
21:07:39 <puusorsa> @src (>>)
21:07:39 <lambdabot> m >> k      = m >>= \_ -> k
21:08:32 <shachaf> @hoogle (>|)
21:08:33 <lambdabot> Did you mean: (>|)
21:08:33 <lambdabot> Prelude.undefined :: a
21:08:33 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
21:09:04 <FMota> as a matter of fact
21:09:13 <FMota> I'm gonna watch xkcd's talk right now!
21:12:09 <chessguy> today's is rather sick
21:13:41 <TSC> I don't think I want to know what Crisco is
21:14:20 <ddarius> Crisco isn't anything bad, but you probably still don't want to know what it is in this context...
21:14:49 <smack__> Crisco brings to mind homemade, down-home, and traditional meals. It is recognized, comfortable, and trusted across generations, yet it is simple and unadorned. It brings about a certain pride in meal creation and attainable excellence in cooking.
21:15:08 <chadz> And anal sex.
21:15:14 <lament> if only i knew earlier about that rule!
21:15:31 <Pseudonym> Erm... haskell-blah please.
21:15:35 <shapr> mmm, beautiful code
21:15:50 <smack__> shapr: the book?
21:15:56 <shapr> Er no, Haskell code
21:16:06 <shapr> Though I've heard the book is good.
21:16:19 <smack__> shapr: i dunno, i angrily flipped through about the past 8 chapters
21:16:27 <smack__> shapr: there are very good chapters in it.
21:16:28 <shapr> You don't like it?
21:16:53 <smack__> well, i find it hard to sit through perl being held up as an example of beautiful code
21:17:40 <smack__> or ruby that looks hideous and is an order of magnitude slower than the equivalent in other languages, but check out that for-each!
21:17:41 <chessguy> what's the book about?
21:18:03 * chessguy prepares to slap anyone who answers "beautiful code"
21:18:04 <smack__> chessguy: it's 40ish chapters, each written by a different programmer, about code they find beautiful.
21:18:07 <shapr> @seen stepcut
21:18:07 <lambdabot> I saw stepcut leaving #haskell 1d 11h 30m 13s ago, and .
21:18:12 <chessguy> oh interesting
21:18:16 <chessguy> famous programmers?
21:18:19 <smack__> chessguy: it is interesting, and i recommend it
21:18:29 <smack__> SPJ's got a chapter
21:18:32 <chessguy> @go beautiful code book
21:18:36 <lambdabot> http://www.amazon.com/Beautiful-Code-Leading-Programmers-Practice/dp/0596510047
21:18:44 <chessguy> did he write about haskell?
21:18:58 <smack__> chessguy: STM, IIRC.  (i'm not there yet, but read it before)
21:20:04 * smack__ wonders why "/nick" isn't working in xchat
21:20:30 <Pseudonym> Yeah, it's Beautiful Concurrency.
21:20:47 <chessguy> smack__, works for me, i use it all the time
21:21:25 <chessguy> whoah, 618 pages
21:21:28 <chessguy> that's a big'un
21:21:58 <shachaf> chessguy: Chapter list: http://naotemmosquito.blogspot.com/2007/10/beautiful-code-chapters-on-line.html
21:22:00 <lambdabot> Title: No Tem Mosquito: Beautiful Code Chapters On Line, http://tinyurl.com/2awyoc
21:22:14 <chessguy> the google result above gives a chapter list too
21:22:30 <chadz> smack__: sometimes a o(n^2) algorithm is good e'nuff :)
21:22:58 <Pseudonym> The best kind of algorithm is one that you can decompose cleanly.
21:23:08 <wli> o(n^2) is not O(n^2).
21:23:09 <swix> chadz, blasphemy!
21:23:32 <Pseudonym> e.g. use an O(n log n) divide-and-conquer algorithm for the upper levels, and O(n^2) with low constant factor for lower levels.
21:23:32 <wli> f(n) is o(n^2) iff lim(n->infty) f(n)/n^2 = 0
21:23:35 <chadz> wli: neither is omega.
21:23:43 <chadz> wli: congrats, i took algorithms too :)
21:23:49 <shachaf> chessguy: Oh.
21:24:09 <shachaf> chessguy: Well, my URL links to online versions of a few of the chapters. :-)
21:24:28 <chessguy> indeed, there are some interesting links, including to a google tech video
21:24:53 <wli> Landau notation is asymptotics, not algorithms.
21:26:01 <shapr> Yay, I'm going to university!
21:26:06 <iank> yay
21:26:08 <iank> Where?
21:26:32 <ddarius> shapr: Good.
21:26:38 <shapr> ua.edu
21:27:01 <Pseudonym> Woo!
21:27:19 <chadz> wli: well, you pwned me :p
21:27:20 <Pseudonym> So they have a good programming languages group?
21:28:00 <chessguy> congrats, shapr
21:28:08 <chessguy> or, really, i should congratulate them :)
21:28:08 <ddarius> Pseudonym: You Aussies make me laugh.
21:28:22 <Pseudonym> ddarius: Must be the accent.
21:28:27 <TSC> Crikey!
21:28:43 * chessguy has the voice on his GPS set to an Aussie
21:28:52 <shapr> Pseudonym: Nah, the CS department sucks. But the head of the CS grad program seems really excited about me attending.
21:29:23 <shapr> It started when I mailed the one FP guy they had and asked if there was a regular luncheon for CS/FP/type theory.
21:30:16 <shapr> I mentioned that I'm a professional Haskell programmer, and he mentioned that he's the head of CS grad studies here.
21:30:56 * ddarius should try that.
21:31:10 <ddarius> Except I'm not a professional Haskell programmer...
21:31:17 <Pseudonym> Sounds like he wants to secretly hire you.
21:31:18 <shapr> You could be if you wanted to be.
21:31:30 <shapr> Pseudonym: I dunno, the guy said he wished he were teaching Haskell instead of Scheme and ML.
21:31:45 <Pseudonym> Like I said, he wants to hire you.
21:31:58 <sorear> What's wrong with ML?
21:31:59 <Pseudonym> He wants to train up a tutor/TA/whatever-it's-called.
21:32:02 <ddarius> shapr: That would be pretty awkward, but you are correct.
21:32:08 <ddarius> sorear: It's ugly.
21:32:10 <shapr> In any case, I know I like meeting people who are enthusiastic about programming languages, so I'll drop by his office next week with my transcript.
21:32:23 <shapr> Pseudonym: Fine by me.
21:32:24 <Pseudonym> sorear: And has some annoying arbitrary restrictions.
21:32:35 <shapr> Pseudonym: I'd point everyone to #haskell
21:32:38 <Pseudonym> shapr: I didn't say it would be a problem.
21:32:42 <Pseudonym> LOL
21:32:45 * shapr grins
21:32:58 * Pseudonym makes a note to come up with some correct but unhelpful answers for shapr's students
21:33:01 <shapr> oh my
21:33:12 <Pseudonym> "Easy: Just call unsafeDoggeh#!"
21:33:25 <ddarius> Pseudonym: Just learn some CT and read some Uustalu.
21:33:28 <shapr> Anyway, I have to get in first. And I have to finish a bachelor's degree, or go for the 5 year program that combines a bachelor's and master's
21:33:47 <dylan> there are such programs?
21:33:47 <Pseudonym> I started tutoring Miranda when I was in second year.
21:33:50 <Pseudonym> Undergrad.
21:33:51 <shapr> dylan: There's one here.
21:33:55 <Pseudonym> Well, lab demonstration.
21:33:58 <Pseudonym> But that's close to tutoring.
21:34:00 <dylan> That would be quite useful.
21:34:11 <shapr> dylan: He says it requires a high GPA though.
21:34:20 <shapr> Meaning #haskell wouldn't see me for months at a time.
21:34:30 <dylan> that'd be bad.
21:34:50 <Pseudonym> We could help you with your homework!
21:34:53 <sorear> but... you're shae errison!  you can't just wave your name? :P
21:34:58 <shapr> On the other hand, when I got back, I might know as much as the REALLY smart people here!
21:35:06 <shapr> sorear: eris - son!
21:35:19 <dons> its a good idea to get some learnings done, i reckon :)
21:35:22 <dons> go shapr!
21:35:24 <shapr> sorear: Actually, I told him that I get mentioned twice in the History of Haskell paper, we'll see :-)
21:35:24 <dgriffi3> @where map
21:35:24 <lambdabot> http://www.haskell.org/haskellwiki/HaskellUserLocations
21:35:33 * sorear gets doubled consonents wrong _often_
21:35:55 <Pseudonym> shapr: That's pretty cool.
21:35:58 <shachaf> sorear: Not vowels?
21:36:11 <Pseudonym> Though I should point out that I'm mentioned three times in Oleg papers.
21:36:18 <sorear> shachaf: There are very few doubled vowels in English
21:36:22 <shapr> Pseudonym: Oh hey, I thought up a name for the wiki-like successor to TMR
21:36:27 <dibblego> what type class has a function a -> a -> a that is commutative?
21:36:28 <Pseudonym> Oh?
21:36:29 <shapr> Pseudonym: Yes, but I know you're cooler than I am ;-)
21:36:34 <Pseudonym> Nah.
21:36:34 <shapr> Pseudonym: The Monad.Writer !
21:36:36 <dons> Pseudonym: lucky bugger.
21:36:37 <Pseudonym> LOL!
21:36:42 <dons> does oleg still write haskell papers?
21:36:43 <sorear> dibblego: AbelianMonoid?
21:37:05 <Pseudonym> I'm not cooler, I just come up with interesting problems that I can't solve but Oleg can.
21:37:12 <shapr> Ya know, that would be a useful facebook app. Say which of your friends you think are cooler than you are.
21:37:13 <dons> heh we should have an annual award with the name `The Monad.Writer' shapr
21:37:21 <dibblego> sorear, thanks
21:37:30 <dons> for the most useful contribution to haskell, or something like that
21:37:31 <Pseudonym> You're actually more likely to end up cited in an Oleg paper if you write LESS code.
21:37:35 <shapr> dons: That would be nifty.
21:37:40 <sorear> dibblego: it doesn't exist, I just generated a name
21:37:48 <dibblego> sorear, I know, just reading about it
21:37:51 <dgriffi3> sorear: isn't abelian only the term used for groups?
21:38:17 <dibblego> dgriffi3, "A monoid whose operation is commutative is called a commutative monoid (or, less commonly, an abelian monoid)" (wikipedia)
21:38:25 <ddarius> As far as I know, I've not been mentioned in any Haskell related publications unsurprisingly.
21:38:25 <sorear> dgriffi3: It's most common with groups, but I've seen it used with most other binary structures
21:38:49 <shachaf> dibblego: For that, you need an identity element and associativity, no?
21:39:07 <dibblego> shachaf, for a Monoid?
21:39:45 <Pseudonym> Another name for the successor to TMR: Composable Transactions
21:40:40 <sorear> you could call it a commutative magma
21:40:58 <ddarius> You wouldn't want a class for such a thing though.
21:41:10 <dibblego> ?src [] mappend
21:41:10 <lambdabot> Source not found. I feel much better now.
21:41:15 <dibblego> ?src [] Monoid
21:41:15 <lambdabot> Source not found. Sorry.
21:41:18 <sorear> ?src [] mconcat
21:41:18 <lambdabot> Source not found. There are some things that I just don't know.
21:41:23 <sorear> ?slap lambdabot
21:41:24 * lambdabot would never hurt lambdabot!
21:41:39 <lambdabot> ?slap sorear
21:43:13 <dons> we should be able to hoogle the src
21:43:26 <omnId> @src [] mplus
21:43:26 <lambdabot> mplus = (++)
21:43:34 <dons> nice idea, Pseudonym . re. tmr thing
21:43:35 <omnId> Monoid: mappend/mempty  MonadPlus: mzero/mplus
21:43:59 <Pseudonym> It's a pun, because in a wiki, development is highly concurrent.
21:45:38 <Randroid> @src my brain
21:45:38 <lambdabot> Source not found.
21:45:42 <Randroid> Dang.
21:46:12 <Pseudonym> ?src of all evil
21:46:12 <lambdabot> Source not found.
21:47:57 <jcreigh> premature optimization, of course.
21:47:58 <dibblego> ?src mconcat
21:47:58 <lambdabot> Source not found. Just try something else.
21:48:10 <dibblego> mconcat = foldl' mappend mempty ?\
21:48:16 <ddarius> jcreigh: That's the -root- of all evil.
21:48:24 <sorear> dibblego: sorta
21:48:42 <sorear> dibblego: but strictness is the root of all evil, I'm pretty sure the real default is foldr
21:48:50 <dibblego> ah right, cheers
21:50:18 <Pseudonym> > evil
21:50:20 <lambdabot>   Not in scope: `evil'
21:50:41 <shachaf> > sqrt (all evil)
21:50:42 <lambdabot>   Not in scope: `evil'
21:50:52 <Randroid> Evil's always in scope, especially when I'm around. :)
21:50:58 <iank> could be the cube root
21:51:05 <shachaf> Why not foldl?
21:51:13 <Randroid> They call me The Cube Root of Evil.
21:51:17 * Randroid will shut up now.
21:51:27 <kaol> > let evil=evil in evil
21:51:31 <lambdabot>  Exception: <<loop>>
21:51:41 <iank> "evil", perhaps?
21:51:42 <shachaf> >  (all evil)
21:51:42 <lambdabot>  Illegal character ''\136''
21:51:44 <Pseudonym> When you look into the Abyss, the Abyss looks into you.
21:51:47 <Pseudonym> @let evil = 666
21:51:51 <lambdabot> Defined.
21:52:07 <Pseudonym> @let money = 25.80697580112788
21:52:09 <lambdabot> Defined.
21:52:12 <iank> > sqrt evil
21:52:12 <Pseudonym> > money == sqrt evil
21:52:13 <lambdabot>   add an instance declaration for (Floating Integer)
21:52:13 <lambdabot>     In the expression: s...
21:52:13 <lambdabot>  Couldn't match expected type `Double'
21:52:20 <Randroid> lol
21:52:21 <shachaf> @undefine
21:52:23 <lambdabot> Undefined.
21:52:35 <shachaf> @let evil :: Num a => a; evil = 666
21:52:37 <lambdabot> Defined.
21:53:01 <iank> what about 'all' ?
21:53:03 <omnId> > take 5 $ iterate (sum . enumFromTo 1) 8
21:53:04 <lambdabot>  [8,36,666,222111,24666759216]
21:53:33 <shachaf> I don't think (sqrt (all evil)) could type-check, no matter what evil was.
21:53:46 <omnId> @type all ?evil
21:53:48 <lambdabot> forall a. (?evil::a -> Bool) => [a] -> Bool
21:53:54 <dons> with enough instances, anything will type check :)
21:53:56 <omnId> define Floating ([a] -> Bool)
21:54:03 <shachaf> Well, OK, with instance Num.
21:54:10 <shachaf> But not in lambdabot.
21:54:24 <ddarius> We should add equi-recursive types so when I forget a map my code will typecheck.
21:54:25 <shachaf> @ty sqrt
21:54:27 <lambdabot> forall a. (Floating a) => a -> a
21:54:32 <shachaf> s/Num/Floating/, right.
21:54:41 <wli> Track a bounding interval (a, b) where signum (f a) == negate (signum (f b))
21:55:07 <wli> Furthermore track (f a, f b) and (f' a, f' b)
21:59:25 <sorear> it seems we have twanvl to thank for the new @slap
22:00:48 <dibblego> > mconcat [[1, 2, 3], [4, 5, 6]]
22:00:53 <lambdabot>  [1,2,3,4,5,6]
22:01:01 <wli> Interpolate the cubic. Solve for its real roots. Form the tightest bounding interval possible using its real roots that fall within the interval and the interval's midpoint. Iterate to convergence.
22:01:55 <ddarius> wli: Who are you talking to?
22:02:19 <wli> I forgot. Someone who was here a few minutes ago.
22:04:10 <iank> talking about the root of evil?
22:07:39 <lokimaf> something about femz
22:10:18 <lokimaf> if i was to make a function that outputed an infinite stream, how would i get a finite amount of them?
22:10:34 <Mr_Awesome> lokimaf: take
22:10:43 <Pseudonym> Or takeWhile.
22:10:47 <Pseudonym> Or anything like that, really.
22:10:51 <Pseudonym> head, (!!)...
22:11:14 <lokimaf> cool
22:11:20 <lokimaf> thanks :)
22:11:56 <Mr_Awesome> lokimaf: become familiar with all the functions in the prelude. theyll all come in handy at some point or another
22:12:32 <ddarius> zipWith (!!)
22:13:03 <omnId> > take 5 [1..]
22:13:14 <lambdabot>  [1,2,3,4,5]
22:13:32 <ddarius> > zipWith (!!) [0..4] [1..]
22:13:33 <lambdabot>   add an instance declaration for (Num [a])
22:13:33 <lambdabot>     In the expression: 4
22:13:58 <omnId> > zipWith (!!) [0..4] (repeat [1..])
22:13:59 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
22:14:01 <ddarius> > sequence (map (!!) [0..4])
22:14:02 <lambdabot>   add an instance declaration for (Num [a])
22:14:02 <lambdabot>     In the expression: 4
22:14:20 <omnId> > zipWith (!!) (repeat [1..]) [0..4]
22:14:21 <ddarius> > sequence (map (flip (!!)) [0..4]) [1..]
22:14:21 <lambdabot>  [1,2,3,4,5]
22:14:22 <lambdabot>  [1,2,3,4,5]
22:15:07 <ddarius> > ap (flip (zipWith (!!))) repeat [0..4] [1..]
22:15:08 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
22:15:24 <Mr_Awesome> i never really understood the ap function
22:15:31 <wli> Me neither.
22:15:36 <Pseudonym> > map ([1..]!!) [0..4]
22:15:38 <lambdabot>  [1,2,3,4,5]
22:15:38 <ddarius> Mr_Awesome: It's just liftM2 ($)
22:16:01 <omnId> m (a -> b) -> m a -> m b -- function in a monad, argument in a monad, put them together in some sensible way
22:16:01 <Mr_Awesome> oh wow. that actually makes complete sense now
22:16:04 <ddarius> @pl \xs is -> map (xs!!) is
22:16:05 <lambdabot> map . (!!)
22:16:17 <ddarius> pl lays the smack down again
22:16:20 <Mr_Awesome> i guess i never bothered to look it up
22:16:35 <conal> ?type <*>
22:16:35 <ddarius> I was actually thinking about that, but thought it was wrong somehow.
22:16:37 <lambdabot> parse error on input `<*>'
22:16:40 <conal> ?type (<*>)
22:16:41 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:16:42 <omnId> [a -> b] -> [a] -> [b] -- apply each a to each (a -> b), since [] is based on concatMap
22:17:00 <wli> I need an Hermite-Lagrange basis for a zeroeth and first derivative on 2 endpoints of an interval.
22:18:12 <omnId> ((->)e) (a -> b) -> ((->)e) a -> ((->)e) b -- get a result function that takes an e, passes it to both first functions, then passes the b result from the second back into the first.
22:18:27 <sorear> ouch, #math maybe?  haskellies don't tend to care much for continuous math
22:18:32 <omnId> the a result, rather
22:19:24 <wli> sorear: Numerical methods aren't #math material.
22:21:01 <lokimaf> how would i apply showHex using map to a sequence of integers?
22:21:17 <lokimaf> a list of integers rather
22:21:26 <omnId> @type showHex
22:21:28 <lambdabot> forall a. (Integral a) => a -> String -> String
22:21:32 <omnId> map (\x -> showHex x "")
22:21:49 <lokimaf> thanks :)
22:21:52 <ddarius> map . flip showHex ""
22:25:19 <omnId> > foldr ($) "" (map showHex [8..15])
22:25:21 <lambdabot>  "89abcdef"
22:31:21 <omnId> @type foldr ($) undefined . repeat
22:31:23 <lambdabot> forall b. (b -> b) -> b
22:32:08 <shachaf> > (foldr id undefined . repeat) (1:)
22:32:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:33:13 <shachaf> That's a nice way of writing it. :-)
22:33:30 <shachaf> @let y = foldr1 id . repeat
22:33:30 <lambdabot> <local>:2:11:     Occurs check: cannot construct the infinite type: a = a -> ...
22:34:12 <shachaf> Oh, hmm.
22:34:22 <shachaf> I guess undefined is necessary. :-(
22:34:36 <omnId> @type foldr id undefined
22:34:38 <lambdabot> forall b. [b -> b] -> b
22:34:40 <omnId> @type foldr1 id
22:34:41 <shachaf> @let y = foldr id undefined . repeat
22:34:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
22:34:42 <lambdabot>     Probable cause: `id' is applied to too many arguments
22:34:43 <lambdabot> Defined.
22:34:50 <omnId> @type foldr1
22:34:52 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
22:36:02 <lokimaf> i want a function that when i add 0x3 to 0x5 i get 0x35
22:36:22 <lokimaf> and when i add 0x5 to 0x3 i get 0x53
22:36:31 <lokimaf> how would i do that?
22:36:40 <omnId> multiply by 16?
22:36:41 <shachaf> lokimaf: "0x5" is a string?
22:36:48 <shachaf> :-)
22:36:53 <lokimaf> hexadecimal
22:37:04 <omnId> so an Int?
22:37:08 <lokimaf> yep
22:37:14 <omnId> x * 16 + y
22:37:21 <lokimaf> kk coold thanks :)
22:37:49 <lokimaf> sweetness
22:37:57 <lokimaf> made a random stream generator :D
22:38:19 <lokimaf> "32953b567ef34c7"
22:38:31 <lokimaf> lol
22:38:33 <lokimaf> here one sec
22:38:36 <lament> that doesn't look very random, it's a bunch of letters with a few numbers thrown in!
22:40:03 <lokimaf> *CUNsam> (map (\x -> showHex x "") (take 111 (cunskArbipa (0x3,0x5::Integer))))!!110
22:40:06 <lokimaf> "28562c9a39801dbdc64a39010462aff22d0fca22ccf8930d22216f8a27"
22:40:32 <lokimaf> generated using .|. .&. 0x3 and 0x5
22:40:32 <OceanSpray> Curry is a weird last name
22:40:47 <Korollary> And Haskell is not all that great, either.
22:41:00 <shachaf> OceanSpray: So is "Spray". :-)
22:41:08 <Korollary> I can be quoted so out of context right now.
22:41:58 <sieni> @remember Korollary And Haskell is not all that great, either.
22:41:58 <lambdabot> Okay.
22:42:19 <omnId> "Okay"?
22:42:22 <shachaf> @quote Korollary
22:42:22 <lambdabot> Korollary says: my brain is fried. I cant read any more STM papers
22:43:55 <hpaste>  loki pasted "infinite random stream generator in 18 lines of haskell code" at http://hpaste.org/3343
22:44:31 <lokimaf> well more like 19
22:44:41 <lokimaf> with the line that your getting a random number
22:45:01 <Korollary> The deal was for 18. I am not paying you a cent.
22:45:17 <lokimaf> well it's less than 18 lines of actual code
22:45:25 <Pseudonym> Hey!  This bloke won't haggle!
22:45:34 <Korollary> Don't give me technicalities.
22:46:02 <lokimaf> there are like 13 lines of actual code, as 2 are blank and 3 are comments
22:46:39 <Korollary> That's discrimination.
22:46:56 <lokimaf> well that's Haskell
22:47:09 <lokimaf> for discriminating hackers
22:47:13 <lokimaf> :)
22:47:14 <lament> badum-ts!
22:47:30 <lament> (not anymore it isn't)
22:47:57 <Korollary> C++ ftw
22:47:57 <goalieca> eww lisp braces
22:48:40 <lament> something lose, something love?
22:48:59 <lokimaf> really whats the #1 language for discriminating hackers this year?
22:49:26 <omnId> Malbolge!
22:49:42 <lament> C++?
22:50:08 <lokimaf> guess it must be Haskell
22:50:25 <lokimaf> no competition
22:50:35 <platypus> Haskell faired poorly in the competition this year.
22:50:50 <lokimaf> really? was there someone else that one?
22:50:56 <lokimaf> won*
22:51:42 <lokimaf> i'm not even sure what the competition is, i only read it here in the topic a few times
22:53:38 <lokimaf> it's okay, i'm on the Haskell team, that's all that really matters
22:53:39 <lokimaf> :D
22:53:40 <platypus> C++ came first, Perl came second.
22:53:53 <wli> That's sick.
22:53:56 <iank> competition?
22:54:04 <Pseudonym> Perl and Haskell don't hate each other any more, FWIW.
22:54:05 <iank> And what the hell did C++ win in?
22:54:05 <lokimaf> in 2006 top team had Haskell as second pick
22:54:06 <platypus> ICFP
22:54:19 <ddarius> Pseudonym: When did Perl and Haskell ever hate each other?
22:54:22 <iank> Dev. suicide rate?
22:54:33 <iank> perl and haskell <3 each other!
22:54:40 <lokimaf> c++ is not even a functional programming language
22:54:42 <lament> i don't hate perl, i just avoid it
22:54:45 <Pseudonym> ddarius: Evil mangler.  Enough said.
22:55:04 <lokimaf> well not like haskell anyways
22:55:20 <roconnor> I think it is better to say team smartass came in first and united coding team came in second
22:55:20 <Korollary> lokimaf: it's not restricted to functional languages.
22:55:22 <ddarius> Pseudonym: At best, that only shows one side.  And it's not necessarily the Perl that makes it Evil.
22:55:29 * ddarius hates Perl though.
22:55:37 <roconnor> programmers are what 5x or 10x more important than languages.
22:55:40 <Korollary> roconnor: exactly. Frankly, I think team smartass can win pretty much in any language.
22:55:51 <platypus> roconnor: True.
22:56:09 <Pseudonym> Team Google can always win because of the 20% private project rule.
22:57:01 * platypus wonders if you could write a book like "Higher order perl" for Java.
22:57:21 <roconnor> Pseudonym: In Europe, it isn't that hard to take one vacation day.
22:57:23 <Pseudonym> It would take someone like MJD to write it.
22:57:33 <ddarius> "Higher Order Masochism in Java"
22:57:34 <Pseudonym> Does Java have anyone like that, apart from Guy himself?
22:57:36 <lokimaf> i think Java would be a better language if they removed for and while loops
22:58:09 <platypus> And replaced them with what?  Primitive recursion?
22:58:10 <lokimaf> and optimized recursion
22:58:35 <lokimaf> haskell only uses recursion really
22:58:38 <Pseudonym> Yeah, I think it'd have to be written by Guy Steele.
22:58:47 <Pseudonym> Can't think of anyone else who could pull it off.
22:58:53 <lokimaf> i do my Java programming without loops or polymorphism
22:59:04 <wli> RMS was Guy Steele's codemonkey, no?
22:59:31 <Pseudonym> I don't think so.
22:59:33 <Pseudonym> Maybe.
22:59:37 <Pseudonym> He was at the MIT AI lab.
22:59:40 <Korollary> it may have been the other way around
23:00:04 <lokimaf> learning for and while loops is like forced retardation
23:00:10 <Pseudonym> Lambda: The Ultimate Java
23:00:29 <Korollary> Well, Dijkstra didn't see it that way.
23:00:44 <Pseudonym> Dijkstra didn't consider recursion.
23:00:55 <Korollary> I wonder what we in Haskell don't see as retardation today
23:00:58 <lokimaf> wasn't he just the anti-goto gu?
23:01:00 <quicksilver> I don't think java 5's sugared for loops are like forced retardation
23:01:12 <quicksilver> they're just a slightly weird syntax for traversal
23:01:18 <quicksilver> which is a handy tool
23:01:24 <sclv> if that's all he's remembered for... sigh.
23:01:42 <Pseudonym> lokimaf: No, but he was pro-structured-programming.  That's a common mistake.
23:01:54 <quicksilver> I mostly remember Dijkstra for being hard to spell and pronounce, but having the grace to get ijk in alphabetical order in his name.
23:01:57 <Pseudonym> Hands up anyone who's actually read the paper...?
23:02:06 * quicksilver raises a virtual hand
23:02:06 <Pseudonym> Thought not.
23:02:10 <Pseudonym> OK, one.
23:02:11 <Pseudonym> And me.
23:02:12 <sclv> i did
23:02:15 <Korollary> I did
23:02:21 <Pseudonym> I'm guessing more people on #haskell have. :-)
23:02:23 <jeffz> me too
23:02:39 <roconnor> I remember Dijkstra for wanting formal proofs of correctness. ... But for imperitive programming that usually means Hoore tripples.
23:02:45 <sclv> anyway, we all know lambda is the ultimate goto...
23:02:49 <platypus> Pseudonym: Which paper?
23:02:56 <lokimaf> he didn't do much actual coding, mainly published papers
23:02:58 <quicksilver> Hoare, roconnor :)
23:03:08 <Pseudonym> platypus: GOTO considered harmful
23:03:09 <lokimaf> IIRC
23:03:11 <Korollary> It's whore triples.
23:03:15 <sclv> he also designed very elegant algorithms
23:03:16 <roconnor> quicksilver: thanks.  I knew it was wrong, but I couldn't get it to seem right.
23:03:42 <Pseudonym> He also invented semaphores.
23:03:49 <Pseudonym> The guy did a lot.
23:04:09 <Korollary> He also pissed off Alan Kay
23:04:12 <Pseudonym> But the point of "GOTO considered harmful" is actually that algorithms should mirror data structures.
23:04:18 <roconnor> I also got the impression that he was about ... let's say algebraic reasoning, rather than deductive reasoning.
23:04:22 <Pseudonym> And GOTO doesn't really model any data structures at all.
23:04:26 <roconnor> which is pretty cool actually.
23:04:38 <Pseudonym> Structured data implies structured programs.
23:04:49 <ddarius> Pseudonym: What?!  Pointers are the gotos of data structures!
23:04:52 <Pseudonym> This comes naturally to people who work in languages with algebraic data types.
23:05:34 <roconnor> Dijkstra invented semaphores!
23:05:38 <sieni> I guess a Japanese computer scientist named "Goto" wrote an article "Dijkstra considered harmful"
23:05:45 <sclv> I mean I'm all for functional and higher-order as lovely. But I'm somewhat tired of knee-jerk anti-imperativeness that runs the risk of functional weenieness.
23:06:21 <Pseudonym> A lot of people pissed off Alan Kay, BTW.
23:06:38 <wli> Assembly code is something I do for a living.
23:07:25 <sclv> yeah i was just referring to the discussion a little while ago. #haskell tends to be pretty good about this stuff actually. after all, ghc does compile via gcc and all.
23:07:28 <ddarius> sclv: There is nothing "anti-imperative" about higher-order [functions]
23:07:33 <wli> Or at least part of it.
23:07:37 <Pseudonym> Lambda: The Ultimate Imperative
23:08:07 <sclv> ddarius: i know. there's just something occasionally anti-imperative about particular folks
23:08:19 <roconnor> I guess laziness is the anti-imperative.
23:09:22 <roconnor> But of course, Haskell loves imperative programming.  We make all sorts of different monads to be imperative within; more than the usual one offered by other languages.
23:10:15 <ddarius> roconnor: Actually, it's often much much less but more tailored.
23:10:34 <newsham> hi
23:10:47 <newsham> ddarius: http://www.thenewsh.com/%7Enewsham/formal/curryhoward/
23:10:48 <lambdabot> Title: The Curry-Howard Correspondence in Haskell
23:11:01 <newsham> with thanks to you.
23:11:05 <sclv> I'd really like to see a response to aspect and layer oriented programming fads, demonstrating that monadic style gives you the advantages like 20x more cleanly than the insane bytecode hashing of something like AspectJ
23:11:36 <raxas> /4/4
23:11:58 <Pseudonym> I don't understand aspects.
23:12:09 <ddarius> sclv: Despite some saying otherwise, monadic style and aspect oriented programming are not very related.
23:12:20 <Pseudonym> I mean, I understand what it's for, but I can't, for the life of me, see how it's even close to a practical idea.
23:12:34 <ddarius> sclv: In other words, there's no reason to think monads can do what aspects do at all.
23:12:55 <Korollary> I am sorta in the same boat.
23:13:19 <sclv> ddarius: aspects essentially are a form of polymorphism over stateful actions, right?
23:13:29 <sclv> (and layers over contexts)
23:13:52 <sclv> so conceptually if you have something in a writer monad, you can throw it in another writer monad and hey! aspects!
23:13:57 <ddarius> sclv: No.
23:14:24 <sclv> what do you think they are then?
23:14:48 <Pseudonym> So you're saying that stacking on more monad transformers where they're needed is kinda like aspects?
23:14:53 <sclv> i mean all the real-world-deployish examples I've seen involve patching in logging or transformation code or such.
23:15:44 <sclv> of course aspects also involve, sometimes, doing this to someone else's already-compiled code. which monads don't quite do (thankfully).
23:16:18 <quicksilver> I think we'd have to be careful making an argument in which monad transformers were the solution
23:16:23 <Korollary> But that's one of the ideas. Allegedly, you should be able to manipulate different aspects of a program.
23:16:25 <quicksilver> monad transformers aren't exactly pretty :P
23:16:38 <Korollary> including performance
23:17:50 <sclv> one big apsect-selling point is totally absurd -- it involves declaring a function with a database aspect such that the database connection is then auto opened and closed with patched "around" code. any sort of "around" function is conceptually either something that can be done with a cps wrapper or a monad transformer, right?
23:18:16 <dmwit> :t bracket
23:18:18 <lambdabot> Not in scope: `bracket'
23:18:39 <quicksilver> what elisp calls 'around-advice' perhaps
23:18:39 <dmwit> ?t Control.Exception.bracket
23:18:40 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:18:49 <dmwit> bah
23:18:52 <dmwit> :t Control.Exception.bracket
23:18:54 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
23:20:24 <sclv> Korollary: what do you mean, including performance?
23:22:25 <Korollary> sclv: One paper read listed performance as something that can be mutated isolated from other aspects
23:23:13 * Pseudonym suspects that a higher-order version of policy-based design might be superior to aspects in most respects
23:23:17 <Pseudonym> But I don't know what it'd look like.
23:23:21 <hpaste>  olsner annotated "infinite random stream generator in 18 lines of haskell code" with "shorter version" at http://hpaste.org/3343#a1
23:24:31 <sclv> Korollary: right, but what does that actually *mean*? an aspect isn't even a real thing per se, its just a fancy way of saying a "concern" which is a fancy way of saying whatever we want it to be. does it just mean it'll swap in a better datastructure when the predefined rules note that you've decided to use a poor one?
23:25:22 <Korollary> sclv: I don't know. My main gripe with aspects is that they're underspecified to me. I don't like it when it comes to "good taste".
23:25:54 <wli> What's policy-based design?
23:26:12 <Pseudonym> It's a Modern C++ thing.
23:26:17 <olsner> and with that I'm off to work... I did find something with iterate, but it's not really shorter, just more convoluted
23:26:30 <Pseudonym> The library provides the mechanism, you plug in policy.
23:26:44 <wli> IDGI
23:30:37 <wli> I don't get OO in general I guess.
23:31:21 <Korollary> Not all that uncommon a sentiment
23:31:34 <Pseudonym> I get Alan Kay's definition.
23:31:38 <Pseudonym> And it makes beautiful sense.
23:31:46 <Pseudonym> OO a la Alan Kay == Erlang threads
23:31:52 <wli> Anyway, I think I have the Lagrange-Hermite basis but am too harried to write it down in code.
23:31:55 <Pseudonym> What's not to understand?
23:32:08 <Korollary> Pseudonym: the actor model?
23:32:27 <Pseudonym> No, objects. :-)
23:32:29 <monochrom> I am perverted.
23:32:58 <sclv> wli: Data.Hashtable is maybe a simple example, right?
23:33:20 <sclv> you create it with a type of key, and also a function to translate that key into an int.
23:34:10 <sclv> so you've specified, so to speak, its "policy" for hashing.
23:34:38 <Pseudonym> No, that's not policy-based design.
23:34:43 <Pseudonym> PBD might be to plug in concurrency.
23:35:00 <Pseudonym> So you can have a concurrent hash table and a non-concurrent hash table, with the same code base.
23:35:19 <sclv> Pseudonym: right, and it happens at the compiler level instead of at runtime, right?
23:35:38 <Pseudonym> Well, in C++ it would.
23:35:51 <Pseudonym> In Haskell, it would probably depend on specialisation, but you can specify that using a pragma.
23:35:57 <sclv> But if it isn't at the compiler level, then its just a classic gang of four pattern.
23:36:28 <mgsloan> hmm, why isn't (,) sectionable?
23:36:54 <Pseudonym> It's not an operator.
23:37:01 <mgsloan> I surpose
23:37:12 <mgsloan> still, it'd be pretty cool
23:37:16 <Pseudonym> > 1 `(,)` 2
23:37:16 <lambdabot>  Parse error
23:37:18 <Pseudonym> Damn.
23:37:26 <roconnor> > (1,) 2
23:37:26 <lambdabot>  Parse error
23:38:02 <roconnor> @pl \x -> (1,x)
23:38:03 <lambdabot> (,) 1
23:38:05 <mgsloan> (3,,2,,,1) :: Num a => a -> a -> a -> (a,a,a,a,a,a)
23:38:10 <roconnor> @pl \x -> (x,1)
23:38:11 <lambdabot> flip (,) 1
23:38:32 <mgsloan> hmm!
23:38:43 <mgsloan> well, it appears to be a function somehow
23:39:00 <Pseudonym> Sure, it's a function.
23:39:02 <Pseudonym> Not an operator.
23:39:37 <mgsloan> yeah.. I suppose we don't really need tuple sugar much anyway
23:39:54 <wli> We do, but never mind that.
23:40:07 <mgsloan> hah
23:40:15 <mgsloan> I guess with the advent of arrows..
23:41:10 <wli> http://holomorphy.com/~wli/Untuple.hs
23:41:41 <mgsloan> ah, nice
23:43:37 <omnId> @src uncurry
23:43:37 <lambdabot> uncurry f p = f (fst p) (snd p)
23:43:55 <omnId> the uncurryNs should be: uncurryN f ~(...) = ...
23:44:10 <newsham> mm curry (just had some)
23:44:49 <omnId> > uncurry ?newsham
23:44:50 <lambdabot>   Not in scope: `newsham'
23:45:02 <olsner> I'd like something like foldl ($1 + $2), or even ($2 + 16 * ($1 .&. $2), $1 * 16 + ($1 .|. $2))
23:45:15 <wli> What the heck?
23:45:28 <mgsloan> hah
23:45:33 <olsner> that would make it possible to write pointfully in something that looks more like pointless style - without lambdas
23:45:44 <wli> Where did the $'s come from?
23:45:56 <newsham> positional arguments?
23:46:01 <omnId> f $2 $1 = \x y -> f y x
23:46:04 <mgsloan> basically he's saying (\$1 $2 -> ...)
23:46:09 <olsner> yeah, positional arguments
23:46:40 <Pseudonym> No, you want De Bruijn indices!
23:46:47 <omnId> what part of the overall expression would it put the lambdas?
23:46:54 <olsner> omnId: the right one :P
23:47:01 <newsham> > let f xs = (xs!!2]*(xs!!0) + (xs!!1) in f [5,2,3]
23:47:02 <lambdabot>  Unbalanced parenthesis
23:47:08 <newsham> > let f xs = (xs!!2)*(xs!!0) + (xs!!1) in f [5,2,3]
23:47:10 <lambdabot>  17
23:47:19 <omnId> oh gawd.  Desugaring based on typechecking?
23:47:34 <sclv> it wouldn't know where to parenthesize
23:47:37 <olsner> well, I guess you'd have to introduce another kind of bracket to indicate how big the lambda is
23:47:55 <omnId> (\-> expr $1 $2)
23:48:21 <newsham> is it really so much pain to (\a b -> expr a b) ?
23:48:42 <olsner> I guess I want functional perl
23:48:57 <Pseudonym> \ -> \ -> expr $1 $2
23:48:58 <omnId> $_[0]
23:49:12 <sclv> @go haskerl
23:49:14 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
23:49:14 <lambdabot> Title: The Haskerl index
23:49:16 <Pseudonym> ?pl \a b -> expr a b
23:49:16 <lambdabot> expr
23:49:22 <Pseudonym> Even more painless!
23:50:27 <mgsloan> yeah, that's probably the worst syntactic idea I've heard in a while, no offense
23:50:29 <omnId> When I was getting up to speed with Haskell I keep a little list of things like that.  I don't think I've looked back on it :)
23:53:19 <omnId> > ($(((.(.($3)))($))($2)))$($(^)))
23:53:19 <lambdabot>  Unbalanced parenthesis
23:54:34 <omnId> > ($(((.(.($3)))($))($2)))$($(^))
23:54:36 <lambdabot>  9
23:57:19 <wli> So now I've got the Lagrange-Hermite basis there.
