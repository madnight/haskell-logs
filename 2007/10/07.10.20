00:13:28 <goalieca> wasn't that on reddit
00:13:56 <sjanssen> goalieca: yes
00:14:08 <goalieca> oh. its qwe1234
00:14:09 <goalieca> that jackass
00:14:10 <goalieca> haha
00:14:22 <sjanssen> http://programming.reddit.com/info/5ynb1/comments
00:14:23 <lambdabot> Title: programming: New C++ concepts smell like Haskell type classes
00:14:35 <wli> Yeah, qwe1234 is basically a troll.
00:17:33 <mgsloan> C++ concepts are basically just ways to make C++ template errors a bit more readable..
00:17:41 <mgsloan> at least, with the boost conceptcheck stuff
00:18:05 <goalieca> a single boost error overflows my terminal buffer
00:18:08 <goalieca> so i had to increase it
00:18:31 <dmwit> ?karma c
00:18:31 <lambdabot> c has a karma of 15
00:18:34 <dmwit> c++
00:18:36 <dmwit> ?karma c
00:18:37 <lambdabot> c has a karma of 15
00:18:46 <goalieca> ?karma c++
00:18:46 <lambdabot> c++ has a karma of -8
00:18:48 <goalieca> haha
00:18:55 <goalieca> ?karma assembly
00:18:55 <lambdabot> assembly has a karma of 0
00:18:59 <goalieca> ?karma asm
00:18:59 <lambdabot> asm has a karma of 0
00:19:02 <goalieca> ?karma python
00:19:03 <lambdabot> python has a karma of -1
00:19:07 <goalieca> ?karma haskell
00:19:07 <lambdabot> haskell has a karma of 21
00:19:13 <goalieca> ?karma lisp
00:19:14 <lambdabot> lisp has a karma of 0
00:19:23 * dmwit thinks . o O ( It must be fun to type c++++ or c++-- )
00:21:41 <wli> It's getting late enough I'm going to have to worry about throwing off my sleeping schedule.
00:22:25 <dmwit> You could worry about it... or you could go to sleep.
00:23:04 <arcatan> or you could become a levitating lemming
00:23:31 <dmwit> I'd consider that a last resort.
00:23:40 <wli> Meant for elsewhere, sorry.
00:23:44 <dmwit> Imagine how disappointing it would be to attempt to run off a cliff and not fall?
00:23:54 <dmwit> jobs
00:25:31 <sjanssen> dmwit: would that mean I could fly?
00:25:42 <sjanssen> that wouldn't be very disappointing
00:26:27 <dmwit> You would be a happy-go-lucky lemming. =)
00:28:12 <c> dotd http://bp3.blogger.com/_6JTfnuPhpFQ/Ro838cO9VtI/AAAAAAAAAAk/ILr3Fsf0sGs/s1600-h/P1010324.JPG (silly MIME hate)
00:28:14 <lambdabot> Title: P1010324.JPG (image), http://tinyurl.com/22bjzt
00:28:18 <c> oops
00:28:20 <c>  wrong chan
00:28:20 <c> heh
00:28:44 <c> only pasted twice cuz blogger kills the MIME type of jpgs when you paste to ffox
00:30:13 <roconnor> @go 1 CAD in USD
00:30:14 <lambdabot> 1 Canadian dollar = 1.026694 U.S. dollars
00:30:31 <c> @fact-delete P1010324.JPG
00:30:31 <lambdabot> Fact deleted.
00:30:50 <geocalc> easy way to tell nothing good : oops wrong chan
00:32:32 <c> @fact-delete unknown-fact
00:32:32 <lambdabot> Fact deleted.
01:03:11 <takamura> hi
01:04:34 <geocalc> hi
01:06:06 <ddvlad> hi
01:12:54 * wli thinks derange' rs >>= return . (c:) probably simplifies to something.
01:13:07 <wli> (in the list monad)
01:13:49 <kaol> @type \rs c -> derange' rs >>= return . (c:)
01:13:51 <lambdabot> Not in scope: `derange''
01:13:55 <oerjan> liftM (c:) (derange' rs)
01:14:06 <wli> derange' :: Ord t => [(t, (Int, [Int]))] -> [[(t, Int)]]
01:14:22 <kaol> @type \foo c -> foo >>= return . (c:)
01:14:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a] -> a -> m [a]
01:14:55 <wli> Thanks.
02:01:46 <ChilliX> Yo!
02:03:33 <Heffalump> morning
02:03:59 <axm_> morning
02:05:04 <ricky_clarkson> Cold at that.
02:05:15 <axm_> is there some sort of unsafeCoerce# -> String -> a -> b where string is the type of b?
02:05:19 <Saul_> Is it just me, or is the class type Num really ugly?
02:06:39 <Saizan_> ?type cast
02:06:41 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
02:06:51 <axm_> mh, that does not make sense without context (my question)
02:06:56 <Saizan_> ?docs Data.Typeable
02:06:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
02:07:27 <axm_> nope, if I could use typeable, it would be simpler for me
02:08:41 <hpaste>  axm pasted "unsafeCoerce# with type given as String?" at http://hpaste.org/3398
02:08:51 <Saizan_> i though there was something like castTo :: a -> TypeRep -> Maybe b
02:09:23 <axm_> hm, do not know TypeRep yet, or was it some part of Typeable?
02:09:58 <Saizan_> it is
02:10:23 <axm_> what I would need (at the paste) would be some dynamically casting hint for unsafeCoerce# (yes, i already explored alternatives)
02:10:44 <axm_> as how i do it now, it segfaults. do not really know why, though.
02:11:10 <axm_> (without explicitely giving the type)
02:12:04 <sjanssen> hmm, how does unsafeEval work?
02:12:20 <axm_> basically eval without the typeable restriction
02:12:58 <axm_> has been some time i had a look at the docs though, it was explained there
02:16:06 <axm_> "Wrapping up polymorphic values can be annoying, so we provide a unsafeEval function for people who like to live on the edge, which dispenses with dynamic typing, relying instead on the application to provide the correct type annotation on the call to eval."
02:16:46 <sjanssen> "Note that if you get the proof wrong, your program will likely segfault." :)
02:16:50 <axm_> usually, you would have to do eval "MyType (a->b)", with unsafeEval you can do it directly
02:16:56 <axm_> exactly
02:17:30 <Heffalump> ricky_clarkson: yeah, and our heating isn't working :-)
02:17:34 <axm_> what i might be willing to write is the function of coercing it to a given String b
02:17:45 <axm_> if that would make sense and would be reusable
02:18:14 <axm_> that lead me to the thought, sth. like that might already exist
02:19:19 <sjanssen> axm_: I don't think you can write the function you're looking for
02:19:42 <axm_> (say typeCoerce string a = if string=="Int->Int" then unsafeCoerce# b::Int->Int else ...)
02:20:13 <axm_> why not? the paste gives a hello world of it
02:20:18 <sjanssen> axm_: the type of a result can't depend on the value of a variable
02:20:37 <axm_> that would make it like that
02:20:47 <axm_> breaking the type security of course
02:22:21 <axm> it would be tedious to write it, but I would be guess it could be reusable then
02:22:47 <sjanssen> axm: think about your 'else' branch
02:23:24 <sjanssen> case string of "Int" -> unsafeCoerce# x :: Int; "String" -> unsafeCoerce# x :: String
02:23:33 <axm> it wouldn't be complete, yes, but it could be extendable in need, or what do you mean?
02:23:55 <sjanssen> this will be rejected by the type checker
02:24:02 <sjanssen> @type unsafeCoerce#
02:24:04 <lambdabot> Not in scope: `unsafeCoerce#'
02:24:12 <sjanssen> @type GHC.Exts.unsafeCoerce#
02:24:14 <lambdabot> forall t b. t -> b
02:24:46 <sjanssen> @type \string x -> case string of "Int" -> GHC.Exts.unsafeCoerce# x :: Int; "String" -> GHC.Exts.unsafeCoerce# x :: String
02:24:48 <lambdabot>     Couldn't match expected type `Int' against inferred type `String'
02:24:48 <lambdabot>     In the expression: GHC.Prim.unsafeCoerce# x :: String
02:26:43 <sjanssen> axm: do you see now why this function is impossible?
02:27:53 <axm> not really, not in my context (generally speaking, i see why, though i could not explain it like that), give me 2 more minutes to prove you wrong
02:32:10 <geocalc> 5 minutes now axm
02:32:12 <hpaste>  axm annotated "unsafeCoerce# with type given as String?" with "extended my little example to include type casting, not only dynamic parameter count " at http://hpaste.org/3398#a1
02:32:47 <axm> generally, you would be right. i am not speaking of using the code for anything, but for predefined stuff. in this case just application
02:33:13 <axm> sry, geocalc, underestimated
02:33:40 <geocalc> np axm :)
02:35:34 <sjanssen> axm: yes, your program works because you take steps to make certain that the result type for all branches is the same
02:35:54 <sjanssen> by saturating the the functions until you've reached Int
02:36:18 <sjanssen> axm: I'm curious what your ultimate goal is
02:36:21 <axm> and i could live with that
02:36:54 <axm> testing functions given at runtime as string
02:37:13 <sjanssen> do you know quickCheck?
02:37:19 <axm> so far i had 3 approaches that are all too ugly
02:37:23 <axm> yes i do
02:38:09 <sjanssen> you could dynamically evaluate ("quickCheck (" ++ mycode ++ ")")
02:38:20 <sjanssen> quickCheck has a monomorphic return type
02:38:37 <axm> as far as i have understood it, type checking there as well happens at runtime, so far nobody has questioned that, do you (would be really nice to know)?
02:39:04 <axm> hm, you do above
02:39:04 <sjanssen> type checking for quickCheck?  It's all static
02:39:43 <axm> as far as i have understood, there are testproperties compiled given to quickcheck, i have never really used it, am i wrong?
02:40:06 <sjanssen> quickcheck is just a Haskell library, it doesn't use any runtime compilation
02:40:39 <axm> we are talking different topics i think
02:41:04 <axm> quickCheck can evaluate a string representing an arbitrary function given at runtime?
02:41:11 <sjanssen> no, it can't
02:41:25 <axm> that is what i want to
02:41:30 <sjanssen> I'm suggesting you use hs-plugins+quickcheck
02:42:22 <geocalc> use lambdabot !
02:42:23 <sjanssen> hs-plugins for compilation at runtime, and the quickcheck library to provide arguments for the functions you'd like to test
02:42:35 <sjanssen> geocalc: yes, good point
02:42:47 <sjanssen> @check \x y -> x && y == y && x
02:42:48 <lambdabot>  Add a type signature
02:43:09 <sjanssen> @check \x y -> (x :: Bool) && y == y && x
02:43:10 <lambdabot>  Add a type signature
02:43:24 <sjanssen> @check \x y -> (x :: Bool) && y == y && x :: Bool
02:43:24 <lambdabot>  Add a type signature
02:43:37 <sjanssen> okay, what am I doing wrong?
02:43:37 <Saizan_> @check \x y -> (x  && y) == (y && x)
02:43:38 <lambdabot>  OK, passed 500 tests.
02:43:39 <sjanssen> @check True
02:43:40 <lambdabot>  OK, passed 500 tests.
02:43:50 <sjanssen> oh, duh
02:43:51 <axm> i doubt that will be a better solution than doing everything within an eval
02:44:17 <sjanssen> axm: doesn't @check do almost exactly what you want to do?
02:44:49 <axm> i could do eval "(+5) 4 == 9", but i want to have the function only "read" one time, and then perform multiple checks on it
02:45:23 <axm> (and i want to specify explicit tests)
02:45:52 <axm> i do not know what is going on inside lambdabot though
02:46:13 <geocalc> what test ?
02:46:33 <Saizan_> axm: do you want to read the function once and then interactively specify test cases?
02:46:46 <axm> i already have 3 workaround that work, i just have the feeling that this is too hard for simple stuff. and i would like to change it.
02:48:01 <geocalc> :t axm
02:48:03 <lambdabot> Not in scope: `axm'
02:48:17 <geocalc> ;)
02:48:19 <axm> Saizan_, not yet, but would be a possibility. as I see it, it boils down to: I would like to have a function I can address as a function from within haskell, dynamically typed.
02:48:56 <Saizan_> if you know the test cases in advance you can just eval a module where the function is applied to those, and the return type will be always the same
02:49:38 <Saizan_> well, use Data.Dynamic/Typeable then
02:50:06 <axm> yes, i could use the metaplug recently released as well
02:50:46 <axm> but that would mean to write a file to disc and compile that as module right?
02:50:58 <axm> if the function is dynamic
02:51:16 <Saizan_> isn't that what hs-plugins does?
02:51:55 <axm> oh, until now, i was just using the eval functionality, that does not (afaik)
02:52:21 <Saizan_> it still feeds your code to ghc
02:52:34 <geocalc> axm you want a programming bot ?
02:53:08 <axm> would be nice, but where are you going geocalc ?
02:53:33 <geocalc> nowhere
02:53:59 <axm> (or is that an idiom that does not translate?)
02:54:52 <geocalc> you said about file so i think of it axm
02:56:07 <axm> Saizan_, hm, as soon as the evaluated code would not be haskell anymore, it would become something externally anyway. i have not explored that possibility yet. intuitively i just think there would be something simpler in a haskell-haskell situation.
02:57:39 <axm> maybe it is because lisp was the language i was learning before, but i really miss the "take that string and use it there as code" in that context and was expecting something similar here (+ "and it is a function of this type" maybe)
02:57:47 <geocalc> axm there's geordi ealbot of c++ made in haskell
02:57:55 <geocalc> v*
02:58:08 <axm> never heard of it
02:59:22 <geocalc> ?go geordi c++ evalbot
02:59:23 <lambdabot> No Result Found.
02:59:30 <geocalc> ?
02:59:33 <axm> http://www.xs4all.nl/~weegen/eelis/geordi/
02:59:34 <lambdabot> Title: geordi - C++ eval bot
03:01:03 <allbery_b> axm: lisp has the advantage that lisp code is very nearly its own AST.  doesn't work so well for haskell
03:04:09 <ricky_clarkson> axm: I think thinking of lisp as string manipulation is misleading.
03:04:24 <ricky_clarkson> ..tree manipulation, more like.
03:04:42 <allbery_b> hence my AST comment
03:05:24 <axm> alright, but the way is a lot easier there, hence my "too used to" comment
03:06:04 <allbery_b> hm.  liskell? :)
03:06:05 <ricky_clarkson> axm: Remember that lots of lisp macros are to enable laziness, which you get for free in Haskell.
03:07:02 <geocalc> axm look at both bots to have a better idea
03:07:42 <axm> actually i am still thinking if that would advance me.
03:07:46 <ricky_clarkson> axm: In lisp when you don't like lambdas you write macros.  In Haskell you write point-free.
03:08:29 <axm> basically in haskell there is no other way to have a typecheck at runtime, so each workaround involves having to run an external compiler
03:08:36 <ricky_clarkson> > map ((*2).(+10)) [1..10]
03:08:37 <lambdabot>  [22,24,26,28,30,32,34,36,38,40]
03:09:27 <geocalc> > [0..h]
03:09:28 <lambdabot>   Not in scope: `h'
03:09:29 <axm> i am not doubting the advances of haskell, i just say that dynamic programming is easier with the first :)
03:09:36 <axm> *advantages
03:10:16 <allbery_b> having a labguage's external representation be very close to its own AST certainly has its advantages
03:10:43 <allbery_b> (lisp macros being a key example:  you're just twiddling the AST on the fly)
03:11:05 <allbery_b> it also has the disadvantage that ASTs are not generally all tha readable by humans :)
03:11:50 <wli> Or writable.
03:12:00 <allbery_b> yeh
03:12:13 <geocalc> \yeah
03:12:15 <allbery_b> and it makes lisp macros a bit of a black art at times
03:12:45 <fox86> where can i find a list of the builtin types and their sizes, Int, Float etc?
03:12:59 <ricky_clarkson> axm: I think macros are orthogonal to dynamic typing.
03:14:02 <allbery_b> yes and no.  I think the external ~= AST hthing is facilitated by dynamic typing, and macros depend on that
03:14:32 <allbery_b> that said, someone sufficintly clever could probably do the same thing with static typing
03:14:56 <axm> ricky_clarkson, i was not talking about macros in particular
03:15:03 <allbery_b> (after all, TH exists)
03:15:30 <ricky_clarkson> axm: Then yes, Lisp's dynamic features are fantastic.  I'm interested in how, if at all, people get the same advantages in Haskell.
03:15:31 <geocalc> fox86=<< ghc doc
03:15:55 <allbery_b> fox86: that depends on the compiler and the platform
03:15:57 <hkBst> allbery_b: C++ has templates too, that doesn't make it anywhere near as powerful as lisp either...
03:16:16 <allbery_b> templates don't manipulate the AST.  lisp macros and TH do
03:16:19 <axm> ricky_clarkson, now we are getting somewhat nearer what i mentioned ;)
03:16:20 <puusorsa> haskell can has cheezburger plz k thx bye
03:16:29 <puusorsa> omg wtf lol
03:16:52 <Saizan_> C++ templates are just perametric polymorphism no? we have that as the base of the type system here
03:16:55 <fox86> allbery_b: ah. ghc 6.6.1 on linux.
03:17:02 <ricky_clarkson> Saizan_: They generate code.
03:17:20 <ricky_clarkson> And curious error messages.
03:17:22 <hkBst> Saizan_: they are Turing complete
03:17:46 <Saizan_> ricky_clarkson: implementation issue :)
03:17:59 <Saizan_> hkBst: that's not good
03:18:04 <Heffalump> they're not parametric, because you can specialise them
03:18:13 <ricky_clarkson> Saizan_: No, code generation is how they're specified afaik, or at least, the only conceivable implementation.
03:18:22 <hkBst> Saizan_: whatever
03:18:39 <Heffalump> yes, you can't do any early error checking because it's not an error unless code generation actually produces it
03:20:39 <Saizan_> so they are more powerful than java generics?
03:21:00 <geocalc> java lol
03:21:00 <axm> so, would an extension to unsafeCoerce  like unsafeTypeCoerce:: String -> a -> b with String giving the type b is casted to be useful to people beyond me?
03:21:25 <geocalc> ?
03:21:32 <axm> this would be probably implemented as ghc hack first though
03:21:34 <allbery_b> doesn't Data.Typeable give you some ability to do that?
03:21:44 <axm> some, but not freely
03:21:59 <hkBst> Saizan_: yes, which is one reason why Java sucks...
03:22:01 <allbery_b> well, this is haskell
03:22:24 <allbery_b> freely is unsafeCoerce.  which gets you core dumps if used freely
03:22:29 <Saizan_> hkBst: that's not relevant
03:22:48 <hkBst> Saizan_: Java is not relevant
03:23:08 * allbery_b will withhold judgement on the strength ofjava generics until the java equivalent of oleg shows up on the scene :)
03:23:24 <ricky_clarkson> oleg=?
03:23:35 <nornagon> measure of type hackery
03:23:37 <axm> allbery_b, i will just take that as a 'no', well in my case, it would have been the missing functionality
03:23:38 <nornagon> @quote oleg
03:23:38 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
03:23:38 <sjanssen> axm: didn't we already discuss that "unsafeTypeCoerce:: String -> a -> b" is impossible?
03:23:40 <wli> Wadler proposed something useful. He was ignored AIUI.
03:23:49 <axm> as a function, yes
03:24:05 <axm> but at some place unsafeCoerce is defined, too
03:24:13 <wli> Also AIUI ignoring Wadler also entailed a type system with holes in it somewhere.
03:24:15 <ricky_clarkson> Saizan_: C++ templates don't make you specify types fully, so they can appear to work until you try to use them with a new type.
03:24:22 <axm> would not be impossible to add functionality at that level, or would it?
03:24:46 <ricky_clarkson> wli: afaict, Java generics was pretty much designed by Wadler.
03:24:53 <sjanssen> axm: it's still impossible, AIUI
03:25:10 <ricky_clarkson> It lacks self types, which might be fixed next year.
03:25:16 <wli> Then my understanding may be wrong.
03:25:17 <puusorsa> ricky_clarkson, still, it's a compile time error
03:25:24 <sjanssen> axm: the *type* of the result can't depend on the *value* of an argument
03:25:31 <puusorsa> .. iirc
03:25:53 <ricky_clarkson> puusorsa: Sure, but it isn't really specified in terms of types.  It's a text substitution system.
03:26:07 <fox86> i've been looking for definitions of Int, Double etc at haskell.org/ghc for a while, but i really can't find anything
03:26:09 <ricky_clarkson> Well, perhaps token, not text.
03:26:22 <Saizan_> axm: unsafeTypeCoerce:: String -> a -> b means that i can use the result as any type, it's not determined by unsafeTypeCoerce in any way
03:26:23 <allbery_b> ricky clarkson: oleg kiselyov has a reputation in the haskell community for doing "impossible" things with haskell types
03:26:25 <sjanssen> fox86: what exactly do you want to know about them?
03:26:40 <allbery_b> so we tend to measure type hackery in olegs
03:26:44 <puusorsa> right, still it's nice that it blows up when compiling and not later
03:26:50 <axm> ah bugger, you are right
03:26:51 <ricky_clarkson> allbery_b: I might be an equivalent in Java then. ;)
03:27:02 <allbery_b> http://okmij.org/ftp/ for many examples
03:27:03 <lambdabot> Title: This FTP site
03:27:13 <wli> ricky_clarkson: I really seriously thought the Java people screwed things up badly.
03:27:18 <geocalc> axm make those functions as case ..
03:27:20 <ricky_clarkson> ..though that's probably like being a lego architect.
03:27:37 <wli> ricky_clarkson: But I'm operating purely on impressions or some such.
03:27:51 <fox86> sjanssen: how big they are and the difference between Float and Double
03:27:53 <ricky_clarkson> wli: The system's workable, but does have some faults.  A lot of peoplewho've never seen generics think it's crap..
03:28:06 <allbery_b> (the scary thing is that I'm slowly starting to understand what he does and how he does it)
03:28:31 <puusorsa> url or it didnt happen
03:28:35 <geocalc> float is double
03:28:44 <Saizan_> fox86: the Storable class in Foreign has a sizeOf method
03:29:08 <fox86> Saizan_: ah, okay
03:29:10 <axm> geocalc, i would have to think about how you can generalize the usage, the work would not be worth it for the one application case. and i have less uglier workarounds right now.
03:29:37 <geocalc> mmh
03:31:50 <fox86> sjanssen: i found it in libraries/prelude/numeric types
03:32:20 <axm> and actually no other cases than application have come to my mind by now ...
03:35:08 <fox86> it says that Float can store single-precision floating point numbers and Double can store double-precision floating point numbers. i suppose it means that Double can be more accurate than Float?
03:35:20 <matthew-_> yes
03:35:30 <fox86> okay, thanks
03:35:34 <matthew-_> twice as accurate
03:35:42 <matthew-_> for some sort of odd value of twice
03:36:11 <fox86> i see. i think Float will do for now then
03:36:53 <matthew-_> be careful - floating point numbers don't obey maths
03:37:01 <matthew-_> I would suggest you use them only if you really need to
03:37:02 <geocalc> > 0.3 * 2.5 :: Double
03:37:04 <lambdabot>  0.75
03:37:17 <allbery_b> also, watch out for hardware FP implementations that impement single precision by masking
03:37:27 <allbery_b> sometimes it's both easier and faster to just use Double
03:37:30 <matthew-_> > 1.1 + 2.2
03:37:31 <lambdabot>  3.3000000000000003
03:37:47 <matthew-_> > 10e18 + 1 == 10e18
03:37:49 <lambdabot>  False
03:37:56 <geocalc> is there quad ?
03:38:12 <fox86> aah. i'll use Double then
03:38:14 <matthew-_> > (10e18 + 1)::Float == (10e18::Float)
03:38:14 <lambdabot>  Parse error
03:38:18 <allbery_b> not presently
03:38:20 <matthew-_> > ((10e18 + 1)::Float) == (10e18::Float)
03:38:21 <lambdabot>  True
03:38:24 <matthew-_> yay
03:38:46 <ricky_clarkson> > (16777215 :: Float)+1
03:38:48 <lambdabot>  1.6777216e7
03:38:56 <ricky_clarkson> > (16777216 :: Float)+1
03:38:57 <lambdabot>  1.6777216e7
03:41:04 <geocalc> > 1 / (((256^3)^10)^400) :: Double
03:41:05 <lambdabot>  0.0
03:41:16 <geocalc> no
03:41:59 <geocalc> > 1 / (((256^3)^10)^400) :: Float
03:42:01 <lambdabot>  0.0
03:42:11 <geocalc> pff
03:45:12 <geocalc> > 1 / ((((256^3)^10)^400)^40) :: Double
03:45:14 <lambdabot>  0.0
03:45:33 <geocalc> toto
03:45:35 <ricky_clarkson> Someone write a version of Float that keeps track of how much possible error there is between calculations.
03:46:17 <Saintmagician> can anyone here help me with a problem regarding types and type classes?
03:46:40 <bartw> like an imaginary number except with error ?
03:47:03 <ricky_clarkson> bartw: I think you mean complex.
03:47:51 <geocalc> yeah float rouding shit
03:47:52 <ricky_clarkson> I don't know how error works properly for floats, but I expect it's not as simple as x plus or minus y
03:48:38 <lokimaf> how do i get length to return an integer?
03:48:45 <Saul_> I'm looking for a symbol for scalar multiplication, vector addition and vector substraction, any suggestions?
03:48:54 <ricky_clarkson> :t length
03:48:56 <lambdabot> forall a. [a] -> Int
03:49:23 <lokimaf> could I convert that into an Integer somehow?
03:49:28 <Saizan_> Saintmagician: which is it?
03:49:33 <lnxz> lokimaf: you could use genericLength
03:49:43 <lokimaf> :t genericLength
03:49:45 <lambdabot> forall b i. (Num i) => [b] -> i
03:49:52 <ricky_clarkson> @hoogle Int -> Integer
03:49:52 <lambdabot> No matches, try a more general search
03:50:08 <Saizan_> > fromIntegral (length [1]) :: Integer
03:50:10 <lambdabot>  1
03:50:31 <lokimaf> cool thanks :)
03:51:29 <Saul_> > (genericLength [1]) :: Integer
03:51:31 <lambdabot>  1
03:51:40 <Saintmagician> I'm dealing with pairs of integers (so "type Coord = (Int, Int)"). When i do == with them (so e.g. "(1, 2) == (3, 4)"), it only returns true if both numbers in the pairs of equal. I want to change it so that it only compares the first number (so "(1, 2)" is equal to "(1, 5)"). But using "instance Eq Coord where ...etc" doesn't work
03:51:49 <ricky_clarkson> @djinn Int -> Integer
03:51:49 <lambdabot> -- f cannot be realized.
03:52:22 <Saintmagician> like, would i *have* to do something like "data Coord a = Coord (a, a)" and then do "instance Eq Coord where ...etc"?
03:52:26 <scook0> Saintmagician: that's because Coord is just a type alias
03:52:30 <Saizan_> Saintmagician: yes
03:52:43 <ricky_clarkson> > (first (==)) (1,2) (1,4)
03:52:44 <lambdabot>  Couldn't match expected type `t1 -> t'
03:52:46 <lokimaf> :t /
03:52:47 <bartw> ricky_clarkson: what about pessimisticly keeping track of significant digits ?
03:52:48 <scook0> or you could use a custom comparison function instead of (==)
03:52:48 <lambdabot> parse error on input `/'
03:53:00 <scook0> like (==) `on` fst or something
03:53:01 <lokimaf> :t (/)
03:53:03 <lambdabot> forall a. (Fractional a) => a -> a -> a
03:53:12 <ricky_clarkson> bartw: That coud work, but it would probably be way too pessimistic.
03:53:20 <Saintmagician> i don't want to use a custom comparition function, cause then i won't be able to use a lot of pre-written functions for my coordinate pairs
03:53:25 <ricky_clarkson> I'm talking about knowing the actual error range all the time.
03:53:41 <scook0> Saintmagician: looks like your best bet is a data/newtype
03:53:46 <scook0> instead of a type alias
03:53:51 <Saintmagician> and i don't really want to use a Constructer, so "data Coord a", cause then i'd have to change type sigs of a lot of functions
03:53:55 <Saintmagician> what's newtype?
03:53:58 <bartw> ricky_clarkson: don't you run into problems with the error on the error then ?
03:54:12 <ricky_clarkson> bartw: Depends how the error is specified.
03:54:19 <scook0> Saintmagician: I don't see how you'd have to change signatures
03:54:34 <scook0> as long as you've been using Coord consistently
03:55:13 <Saintmagician> well, i'd have to change "Coord" to "Coord Int" in all my type signitures
03:55:20 <scook0> no you wouldn't
03:55:27 <bartw> ricky_clarkson: but how would you use the error anyways, compiletime reordering hints would be usefull, but what else ?
03:55:34 <Saizan_> you can write data Coord = C (Int,Int)
03:55:43 <scook0> newtype Coord = C (Int, Int)
03:56:02 <Saintmagician> but then i'd have to change my functions. So instead of passing around (a, b)...i'd have to use (C (a, b)) in my functions
03:56:12 <ricky_clarkson> bartw: Dunno.  Possibly to use Float for speed but to ban any lossy calculations, or any lossy ones with a total loss greater than 0.1% or something.
03:56:18 <Saintmagician> uhh...what's the difference between data and newtype?
03:57:25 <Saizan_> Saintmagician: newtype Name = Contr Type has the same internal representation as Type but it's effectively a distinct type for the type checker
03:58:03 <scook0> you can achieve (almost) the same effect with data
03:58:15 <scook0> so if you're confused, don't worry about it for now and just use data
03:58:34 <scook0> (since you can always change it to newtype later if you really want to)
03:59:18 <geocalc> > 1 :: Int == 1 :: Double
03:59:18 <lambdabot>  Parse error
03:59:34 <Heffalump> > (1 :: Int) == (1 :: Double)
03:59:35 <lambdabot>  Couldn't match expected type `Int' against inferred type `Double'
03:59:38 <Saintmagician> the thing is, when you (==) for a turple, each element in the turple gets checked for ==. So (1, 2) == (3, 4) has the 1 and the 3 compared, and the 2 and the 4 compared. Isn't there a way to change this? Or is how (==) works on turples just something that can't be changed?
03:59:54 <ricky_clarkson> Saintmagician: "tuple" ;)
03:59:55 <Saizan_> it can't be changed.
04:00:02 <Heffalump> Saintmagician: you'd need to avoid importing, directly or indirectly, the module that defined that instance.
04:00:08 <Saintmagician> spelling was never my strong suite =P
04:00:19 <Heffalump> And since it's the Prelude, that'll be hard.
04:00:45 <Saintmagician> yeah..., i guess i'll go and just use the "data Coord = C (Int, Int)" way then
04:00:56 <scook0> redefining (==) for tuples is ... uh ... semantically dubious anyway
04:01:12 <Saintmagician> thanks for the help
04:01:52 <Saizan_> oh, we missed the real answer to his problem, use things like sortBy instead of sort etc..
04:02:09 <geocalc> head==
04:02:50 <scook0> Saizan_: well, we mentioned using a custom comparison function, but ultimately you're right
04:03:49 <roconnor> #haskell--
04:04:56 <scook0> leaving is no fair though -- people are supposed to hang around and give us conversation fodder!
04:05:09 <scook0> :)
04:05:20 <ricky_clarkson> So I can't redefine == that easily then.
04:05:28 <ricky_clarkson> > let (==)=(\x y -> fst x==fst y) in (1,2)==(1,4)
04:05:29 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, b)
04:05:29 <lambdabot>       Expec...
04:05:31 <Heffalump> you can hide it and define your own Eq
04:06:03 <EvilTerran> > let (==)=(\x y -> fst x Prelude.== fst y) in (1,2)==(1,4)
04:06:05 <lambdabot>  True
04:06:08 <Heffalump> > let (==) = (\x y -> (Prelude.==) (fst x) (fst y)) in (1,2) == (14)
04:06:09 <lambdabot>   add an instance declaration for (Num (a, b))
04:06:12 <Heffalump> bah, too slow :-)
04:06:18 <Heffalump> (and wrong)
04:06:20 <desegnis> ricky_clarkson: That's because the (==) in (fstx == fst y) is the same (==) that you're defining
04:06:42 <ricky_clarkson> Ah.  Is there a way of grabbing the original?
04:06:54 <Heffalump> yes, what EvilTerran said
04:07:07 <ricky_clarkson> Oops, thanks.
04:07:07 <Heffalump> you can always refer to symbols by their qualified name
04:07:12 <scook0>  > let (==)=(\(===) (====) -> fst (===) Prelude.== fst (====)) in (1,2)==(1,4)
04:07:18 <scook0> > let (==)=(\(===) (====) -> fst (===) Prelude.== fst (====)) in (1,2)==(1,4)
04:07:19 <lambdabot>  True
04:07:21 <nornagon> O_o
04:07:40 <scook0> alphabetic variable names are for the weak
04:08:32 <lokimaf> >  fromIntegral ((length "lipapa")/2) ::Integer
04:08:33 <lambdabot>   add an instance declaration for (Fractional Int)
04:08:37 <lokimaf> :(
04:08:45 <lokimaf> how to make it work?
04:08:50 <nornagon> > let { (=====)=fst; (==)=(\(===) (====) -> (=====)(===)Prelude.==(=====)(====)) in (1,2) == (1,4)
04:08:50 <lambdabot>  Parse error
04:08:58 <scook0> > (genericLength "lipapa") / 2)
04:08:58 <lambdabot>  Unbalanced parenthesis
04:09:00 <scook0> > (genericLength "lipapa") / 2
04:09:02 <lambdabot>  3.0
04:09:06 <nornagon> > let { (=====)=fst; (==)=(\(===) (====) -> (=====)(===) Prelude.== (=====)(====)) in (1,2) == (1,4)
04:09:06 <lambdabot>  Parse error
04:09:08 <Saizan_> lokimaf: id you want integer division use div
04:09:13 <nornagon> oops
04:09:14 <desegnis> > length "lokimaf" `div` 2
04:09:15 <lambdabot>  3
04:09:21 <nornagon> > let { (=====)=fst; (==)=(\(===) (====) -> (=====)(===) Prelude.== (=====)(====)) } in (1,2) == (1,4)
04:09:22 <lambdabot>  True
04:09:25 <lokimaf> kk
04:09:58 <scook0> nornagon: http://www.haskell.org/haskellwiki/Obfuscation
04:09:59 <lambdabot> Title: Obfuscation - HaskellWiki
04:10:42 <geocalc> ^
04:10:42 <lokimaf> yay :-) it worked
04:11:04 <nornagon> scook0: wacky
04:11:14 <lokimaf> now i can convert logjbang numbers into hexadecimal :-)
04:11:22 <ricky_clarkson> > let (==)=(.fst).(Prelude.==).fst in (1,2)==(1,4)
04:11:23 <lambdabot>  True
04:11:32 <lokimaf> or into Integer actually
04:11:38 <lokimaf> they are hexadecimal
04:11:42 <nornagon> pity about the 404s though
04:12:16 <scook0> yeah, I was more pointing out the (???) thing
04:22:59 <Saizan_> ?type throwTo
04:23:02 <lambdabot> Not in scope: `throwTo'
04:23:15 <Saizan_> ?type Control.Exception.throwTo
04:23:17 <lambdabot> GHC.Conc.ThreadId -> GHC.IOBase.Exception -> IO ()
04:40:53 <fox86> hmm, if i make a new datatype with "data Test = Test Int", then i can make an instance(?) of that datatype using "foo :: Test" and "foo = Test 1",  i think. how do i make e.g. 10 instances of it?
04:42:28 <augustss> @seen heffalump
04:42:28 <lambdabot> heffalump is in #haskell and #darcs. I last heard heffalump speak 35m 21s ago.
04:42:49 <scook0> fox86: what do you mean by "10 instances"?
04:42:57 <scook0> you mean map Test [1..10]?
04:43:37 <fox86> scook0: i want 10 samples of Test, or 10 "objects" if you like. my terminology sucks, sorry
04:44:39 <scook0> I guess the real question is, what are you planning on doing with these 10 values?
04:44:56 <scook0> (most likely, you want to put them in a list)
04:45:10 <scook0> foos :: [Test]
04:45:21 <scook0> foos = [Test 1, Test 2, Test 3]
04:45:56 <scook0> but I'm not really sure what your intention is
04:47:12 <fox86> scook0: yes. i should have said Node instead of Test because i want to put Nodes in a list
04:47:51 <scook0> well, the most straightforward way is just to write them in a list
04:47:59 <scook0> [Node 1, Node 2, Node 3]
04:48:02 <scook0> or whatever
04:48:07 <fox86> scook0: nice. thank you!
04:48:23 <scook0> (which you can factor out to map Node [1..3] in this case)
04:48:45 <scook0> I'm assuming you want the nodes to have different numbers
04:48:50 <fox86> scook0: yes
04:49:23 <fox86> scook0: eventually i want to make a "network" such as this http://en.wikipedia.org/wiki/Image:Neural_network_example.png
04:49:24 <lambdabot> Title: Image:Neural network example.png - Wikipedia, the free encyclopedia
04:49:48 <scook0> ah, neural networks :)
04:51:20 <fox86> scook0: yes. so i must create some data structure that allows me to move in both directions.. and all the nodes in layer n should be connected to those in layer n+1 etc
04:51:38 <fox86> scook0: i have been looking at trees, trying to figure out how to do it based on those
04:52:00 <scook0> I guess you'll want to be able to update the edge weights at some point too
04:52:12 <fox86> yes
04:52:38 <aleator> are you sure you want actual graph? Do you need to make sparesely connected network?
04:52:51 <roconnor> I thought each set of edges just forms a matrix
04:53:32 <scook0> that's a good point, actually
04:53:38 <fox86> hmm. i thought each layer could be a list of Nodes and then the layers could be put in another list of layers
04:53:50 <fox86> not sure though. i am only learning Haskell
04:53:53 <scook0> an actual network might be a bad data structure for implementing an artificial NN
04:54:10 <roconnor> aleator: I think usually each layer in the graph is fully connected
04:55:47 <aleator> roconnor: Yes, that's why I commented. Though I guess there could be some point of making huge sparse structure..
04:55:58 <roconnor> as I recall, the weighted edges form a matrix, and the nodes are some non-linear S-function.
04:55:59 <scook0> a functional NN structure might be something like a (zipper?) list of 2D arrays
04:56:01 <fox86> the easiest way possible would be good for me, considering i am new with haskell
04:56:24 <fox86> by the way, does anyone know if the hidden layers in a NN always have the same amount of nodes?
04:56:35 <scook0> in general, no they don't
04:56:48 <ricky_clarkson> Don't use a language you don't understand to understand a problem.
04:56:51 <fox86> oh, that complicates things a bit
04:57:03 <aleator> What you use NN for?
04:57:10 <ricky_clarkson> Use a problem you understand to understand the language.
04:57:14 <scook0> though it might help to restrict yourself to a NN where they do
04:57:19 <fox86> aleator: it's an assignment at school
04:57:24 <aleator> Ah ok.
04:57:57 <aleator> Well you could have a Node [Double] and Layer [Node] and Network [Layer] to start..
04:57:57 <fox86> ricky_clarkson: yep, but i don't have time to learn haskell if i don't do it while doing homework at the same time. i know it's a bad idea, but i really want to learn haskell
04:58:11 <scook0> I do suspect that learning NNs and Haskell at the same time is a little eager, but good luck if you keep going with it
04:58:18 <roconnor> typically a NN is represented as a list of matrices, one matrix for each layer of edges.
04:58:39 <roconnor> no explicit graphs or nodes are used.
04:58:52 <fox86> ah, hmm
04:59:05 <fox86> this is a NN using backpropagation, so i have to be able to sweep both ways
04:59:34 <roconnor> fox86: I understand. :)  I did this sort of thing for my final project in AI.
04:59:45 <roconnor> I did it in Java.  This was before my Haskell days.
05:00:02 <aleator> fox86: In that case, you should have bunch of formulae given to you. Those translate into haskell rather well.
05:00:02 <scook0> sounds like a zipper might be nice, but that could be too hairy for a beginner ... maybe
05:00:15 <fox86> roconnor: aah. i figured that if i manage to make a very small/simple structure work (like total 10 nodes), i can go from there
05:00:41 <roconnor> fox86: the difficulty of the problem is independent of the number of nodes.
05:00:57 <scook0> a simpler option might be to keep the layers in an array, and move back/forth using array indices
05:01:01 <roconnor> maybe it depends on the number of layers.
05:01:48 <fox86> yesterday someone recommended that i keep a list of Nodes in each layer, and then another list of layers
05:02:05 <roconnor> The math for backpropagtion tells you how to update each layer.
05:02:37 <scook0> just using lists would make forward/backward traversal tricky
05:02:39 <roconnor> I strongly recommend using 2-D arrays for this.
05:03:06 <roconnor> the nerual network isn't walked around in like a typical graph.
05:03:25 <fox86> ah. so i ought to be thinking in terms of matrices?
05:03:36 <roconnor> fox86: very much so.
05:04:44 <roconnor> your input forms a vector
05:05:03 <roconnor> then you do a matrix multiplication to get the values for the first hidden layer
05:05:19 <roconnor> then you apply some non-linear function to each value in this vector
05:05:34 <roconnor> apply another matrix multiplication to the the values for the next layer
05:05:37 <fox86> writing this down
05:05:42 <roconnor> repeat until you go through all the layers.
05:06:01 <aleator> And for doing matrix stuff, GSLHaskell is way to go
05:06:07 <roconnor> fox86: This is how I remember.  It was almost 10 years ago.
05:06:11 <puusorsa> how about writing ffi bindings for http://leenissen.dk/fann/
05:06:13 <lambdabot> Title: Fast Artificial Neural Network Library
05:06:29 <roconnor> so that is evalutation
05:06:33 <puusorsa> or is reinventing the wheel the point?
05:06:42 <phlpp> > map Char.chr [103, 104, 33]
05:06:44 <lambdabot>  "gh!"
05:06:56 <phlpp> > map Char.chr [104, 105, 33]
05:06:57 <lambdabot>  "hi!"
05:06:58 <phlpp> actually.
05:07:03 <roconnor> to do updating you need to compare your output values to the expected output value.
05:07:15 <roconnor> then there was some calculus whose details I forgot.
05:07:19 <aleator> puusorsa: He is doing an assignment, so it is.
05:07:25 <puusorsa> ack
05:07:36 <roconnor> but you use this difference to update the weights in the last layer
05:07:36 <scook0> pedagogical wheel-invention
05:07:41 <roconnor> back propogate
05:07:48 <roconnor> and update the weights in the second last layer
05:08:13 <roconnor> The exact details how the updates for weights escape me.
05:08:16 <fox86> roconnor: the backpropagation doesn't go all the way back to the first layer?
05:08:23 <roconnor> it does
05:08:39 <roconnor> you keep backprogating the updates all the way back to the first layer
05:08:52 <fox86> aah
05:08:52 * scook0 is reminded of somebody's office door at his uni, with a sign saying "no backpropagation allowed within 10 feet of this door"
05:08:55 <roconnor> I just forget how to compute what the new weights are.
05:09:25 <fox86> roconnor: i have a book on NNs that explain the mathy details i think. i can find that out
05:09:26 <roconnor> but it will be some relatively clear function of the inputs, outputs, expected output, and existing weights.
05:09:52 <roconnor> well, it will be somewhat clear
05:10:02 <roconnor> ... okay, maybe the math will be opaque, who knows ;)
05:10:33 <roconnor> my point is you don't need graphs or trees or anything like that.
05:11:25 <roconnor> at least as I recall.
05:12:13 <fox86> roconnor: okay, i'll go back to the drawing board and try to think it through using matrices
05:12:29 <roconnor> fox86: I hope it works out for you.  I think it will.
05:12:53 <geocalc> aleator=<< what is gslhaskell ?
05:12:56 <fox86> roconnor: thanks. i have until next monday
05:13:15 <scook0> http://dis.um.es/~alberto/GSLHaskell/
05:13:19 <lambdabot> Title: GSLHaskell
05:13:22 <aleator> geocalc: http://dis.um.es/~alberto/GSLHaskell/
05:13:22 <scook0> @where gslhaskell
05:13:22 <lambdabot> I know nothing about gslhaskell.
05:13:22 <lambdabot> Title: GSLHaskell
05:13:31 <scook0> @where+ gslhaskell http://dis.um.es/~alberto/GSLHaskell/
05:13:32 <lambdabot> I will never forget.
05:13:39 <aleator> ie. haskell scientific lib. Quite good.
05:13:56 <aleator> Lot better than starting to code by defining dot product.
05:14:07 <pBot-> If I do a <- x
05:14:10 <pBot-> what does that mean?
05:14:31 <pBot-> Do I assign x to a, or is x nearing the value of a? or what?
05:14:59 <geocalc> GoodScientificLibHaskell ok
05:15:06 <roconnor> pBot-: it means you ``assign'' the value calculated from the expression x for whatever calculate means in your current monad.
05:15:11 <scook0> pBot-: it's a little subtle
05:15:49 <ricky_clarkson> :t (<-)
05:16:00 <lambdabot> parse error on input `<-'
05:16:01 * roconnor hopes his answer isn't too misleading
05:16:03 <ricky_clarkson> Bah, syntax.
05:16:03 <fox86> so you recommend i use GSLHaskell for this? i hope i can install that without root privileges then
05:16:11 <scook0> it's syntax, not an operator, so it has no type
05:16:25 <roconnor> ricky_clarkson: <- is syntactic sugar, and isn't really a function.
05:16:29 <scook0> the closest equivalent operator is (=<<)
05:17:45 <aleator> fox86: Well, depends. I would use it, but then again, if you are just learning stuff, it might add mental baggage in form of that librarys conventions
05:17:57 <roconnor> pBot-: a <- getChar means get a character from the console and let the variable a hold the resulting value.
05:18:19 <roconnor> that is for the IO monad.
05:18:26 <fox86> aleator: ah, okay. i will save it for later then. i need to understand basic structures first anyway. i bet i'll learn a lot by doing that
05:18:49 <ricky_clarkson> roconnor: So it's let for monads?
05:18:52 <maskd> t
05:18:56 <scook0> bearing in mind that (this kind of) <- can only occur in a do-block
05:19:27 <roconnor> ricky_clarkson: i wouldn't say that, because there is already a let for do blocks, which is different.
05:19:43 <roconnor> ricky_clarkson: but other than that I might agree with you.
05:19:58 <scook0> in a sense, you could say it's an "impure" let
05:20:14 <scook0> (if you like abusing terminology)
05:20:58 <scook0> the actual meaning of <- depends on the implementation of (>>=) in the monad at hand
05:22:56 <pBot-> ERROR file:.\Profile.hs:21 - Instance of Num [Char] required for definition of makeMatrixColumn
05:22:59 <pBot-> Am I missing some class?
05:23:29 <roconnor> pBot-: you tried to add or multiply strings.
05:23:39 <scook0> pBot-: is Profile.hs your code?
05:23:58 <scook0> if it is, then yeah, you've tried to perform arithmetic on a string
05:24:19 <roconnor> [Char] means Strings
05:24:33 <roconnor> Num is a class of basic arithmetic operations
05:24:38 <roconnor> @i Num
05:24:38 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
05:24:39 <pBot-> scook0, yeah :p
05:24:42 <roconnor> @info Num
05:24:43 <lambdabot> (Num)
05:24:47 <roconnor> *sigh*
05:24:56 <scook0> thanks for the info, \b!
05:26:04 <roconnor> So in princple you could get things to work by teaching Haskell how to add and multiply strings.  But in practice you've made a different error than the one the error message is getting at.
05:30:35 <wli> Are module systems part of type systems?
05:31:13 <scook0> I'd guess that that depends on how fancy the module system is
05:31:47 <wli> Elaborating however possible would be helpful.
05:31:51 <scook0> what's the context?
05:32:19 <wli> Getting the foggiest clue of how module systems are supposed to work.
05:32:41 <scook0> you mean ML-style module systems?
05:32:52 <wli> Yes, by and large.
05:33:04 <wli> I don't consider things like what C has a module system.
05:33:36 <pBot-> What does this mean? I calc something (app m = p?) then I apply it to m?
05:33:36 <pBot-> [app m | m <- p]
05:33:38 <scook0> C's a bad example, since it doesn't really even have a namespacing system
05:33:54 <pBot-> Or is it a row break?
05:34:03 <scook0> pBot-: that's a list comprehension expression
05:34:03 <Spark> wli: module systems can be all sorts of things, and can involve a type system if you want to parameterise and instantiate modules i think
05:34:22 <pBot-> scook0: hrms ok?
05:34:24 <scook0> it basically means "a list like p, but with function app applied to each element"
05:34:33 <wli> Spark: I'd want to stick to the case where one parametrizes and instantiates things.
05:34:37 <scook0> so if p = [1, 2, 3]
05:34:45 <scook0> then you end up with [app 1, app 2, app 3]
05:34:49 <pBot-> oh ok
05:34:56 <pBot-> thx! =)
05:34:57 <Spark> wli: parameterising what exactly?
05:36:05 <Spark> wli: how about a complex numbers module that you can parameterise to choose the implementation of the component numbers
05:36:07 <wli> Spark: There are a number of different constructs to parametrize modules on: imported modules, types, and top-level bindings.
05:36:09 <scook0> pBot-: from a "beginner's" point of view, it's not quite the same as <- in a do-block
05:36:25 <scook0> even though you'll eventually realise that it actually is the same :)
05:36:43 <scook0> wow, that probably sounded really confusing
05:37:06 <puusorsa> very zen
05:37:08 <wli> Spark: For Haskell-like languages, possibly also typeclasses.
05:38:03 <Spark> i have to wonder what is the benefit of adding these features to modules when the language already supports it for other notions of encapsulation
05:38:14 <scook0> pBot-: there's more explanation of list comprehensions at http://haskell.org/haskellwiki/List_comprehension if you're interested
05:38:14 <lambdabot> Title: List comprehension - HaskellWiki
05:38:18 <wli> Spark: Understanding modules.
05:38:27 <Spark> e.g. in java you don't need to give packages type parameters because the classes inside the package can have type parameters
05:39:22 <wli> Spark: That depends on the philosophy of language design. I just want to know how modules work.
05:39:24 <scook0> wli: this is perhaps not the ideal place to ask, since Haskell doesn't have a fancy module system (though YMMV)
05:40:04 <scook0> I think ATTaPL has a chapter on module systems
05:40:22 <wli> Surprise. I don't have that book yet.
05:40:45 <scook0> I must get my own copy one of these days
05:40:45 <wli> And I won't be going book shopping until at least Feb. 2008.
05:41:11 <wli> My budget is blown until then.
05:41:17 <integral> chapter 8 sounds like it's on ML modules
05:41:18 <pBot-> So if I have a list molseqs containing numerous things, a sequence for one (sekvString), can I write:
05:41:18 <pBot-> [sekvString m | m <- molseqs]
05:41:18 <pBot-> To make a list of the sekvString-strings in molseqs?
05:42:07 <wli> I also suspect from that description it will be scant on conceptual detail.
05:42:44 <wli> For instance, Mitchell's text on programming languages also has a chapter on ML modules, by which I've not been enlightened.
05:43:11 <Saizan_> pBot-: if molseqs :: [Type1]. sekvString :: Type1 -> Type2 then [sekvString m | m <- molseqs] :: [Type2]
05:43:12 <integral> "8. Design Considerations for ML-Style Module Systems -- Robert Harper and Benjamin C. Pierce"
05:43:16 <scook0> pBot-: if you're saying what I think you're saying, then yes
05:44:57 <scook0> that particular comprehension could also be written map sekvString molseqs
05:45:32 <fasta> I get a stack overflow when I use the following code: http://hpaste.org/3399
05:46:07 <wli> I'd think the type-theory heavy environment would have people who've got something to pass on about modules, but maybe not, or maybe not at this hour.
05:46:11 <pBot-> scook0, MolSeq has a number of attributes, one of them being sekvString :p
05:46:21 <pBot-> molseqs is a list of MolSeq
05:46:53 <scook0> so sekvString is also a function of type MolSeq -> String
05:47:12 <scook0> and molseqs has type [MolSeq]
05:47:15 <fasta> Anything I can do about it next to raising the amount of stack space available?
05:47:31 <scook0> and your end result has type [String]
05:47:59 <scook0> corresponding to the sekvStrings of your MolSeqs
05:50:49 <fasta> The file I want to parse is only 2.8MB.
05:52:52 <augustss> fasta: what do you do with the result of parsing?
05:53:14 <fasta> augustss: I put it in a graph data structure
05:54:14 <fasta> augustss: I am now raising the stack to 100MB, but imho that shouldn't be necessary.
05:55:00 <augustss> fasta: I agree.  But if the computation of the Ints in the list happens late then there will be a lot of thunks
05:55:35 <fasta> augustss: I should seq something?
05:55:51 <wli> Looking back over Mitchell's treatment it looks kinda sorta like a language that manipulates the ordinary expression language, so you mostly just want the evaluation process at the module level to honor the type system of the expression language. The mechanics of this are far beyond me, though.
05:57:46 <hpaste>  augustss annotated "(no title)" with "A quick hack" at http://hpaste.org/3399#a1
06:00:04 <scook0> I guess that's one way to deep-sequence a data structure
06:01:06 <fasta> augustss: I applied rnf now (that's the not so hacky way)
06:01:37 <wli> This approach to understanding modules has the massive problem of not gibing with the records-as-modules affairs that crop up in various places at all.
06:03:42 <fasta> augustss: ok, it seems to work
06:04:00 <augustss> :)
06:04:23 <fasta> augustss: the profiler did pinpoint this "space leak" quite nicely.
06:04:47 <fasta> Space leaks as a result from monads are a lot more opaque to me.
06:08:00 <phlpp> hm
06:08:17 <fasta> Mostly because writing out the applications of the functions takes so much work.
06:09:11 <augustss> yeah, that can be annoying
06:09:47 <fasta> The canonical forever loop that does nothing in the state monad is a good example.
06:11:09 <fasta> I don't like that the profiler contains all kinds of names that are not documented.
06:11:16 <fasta> E.g. what is a BLACKHOLE
06:11:54 <fasta> I can guess something for ARR_WORDS, though.
06:13:17 <Heffalump> apparently mtl needs some work with INLINE pragmas and stuff.
06:14:31 <TomMD> fasta: They describe a 'BLACKHOLE' in the recent STM based RTS paper... lets see if I can find it.
06:14:44 <TomMD> But yes, I understand the more general complaint.
06:15:24 <TomMD> fasta: http://www.haskell.org/~simonmar/papers/conc-substrate.pdf
06:16:54 <fasta> TomMD: I don't do anything with STM myself. That's also confusing.
06:18:31 <TomMD> fasta: What is confusing about STM?  Again, lots of papers on the subject - really well written ones by Peyton-Jones.
06:19:08 <Saizan_> confusing that something related to STM appears when he's not using it
06:19:15 <fasta> Saizan_: thanks
06:21:21 <Zao> A black hole is an infinite loop the implementation detects, and thus just stops evaluating.
06:21:31 <Zao> See http://groups.google.com/group/fa.haskell/msg/ca961c90e25118a1
06:21:32 <lambdabot> Title: GHC 6.7 on Windows / containers-0.1 package? - fa.haskell | Google Groups
06:22:35 <Heffalump> so it only shows up on profiles during an infinite loop?
06:22:41 <fasta> Zao: odd; I don't use threads, so the existence of an infinite loop should make my program diverge.
06:22:48 <fasta> Zao: but it doesn't diverge.
06:23:12 <fasta> Heffalump: I think the answer is no.
06:23:34 <Heffalump> I can't really think what else it could mean, though.
06:23:45 <Zao> > let f = f
06:23:45 <lambdabot>  Parse error
06:24:11 <Zao> Meh. My lambda-fu is weak... in ghci, try   let f = f  <newline>  f
06:24:16 <Zao> That'll go into a blackhole.
06:24:20 <koffein> hi
06:24:35 <koffein> I'm trying to use a textView in gtk2hs
06:24:39 <Heffalump> > let f = f in f
06:24:43 <lambdabot>  Exception: <<loop>>
06:24:46 <koffein> but I can't insert stuff
06:24:53 <koffein> http://pastebin.com/d73084f40
06:25:05 <Heffalump> zao: indeed, like that. But that seems to be only a partial explanation for what's going on with the BLACKHOLE entry in fasta's profile.
06:25:08 <augustss> Heffalump: http://cgiirc.org/
06:25:09 <lambdabot> Title: CGI:IRC - Web based IRC Client
06:25:24 <Heffalump> augustss: what about it?
06:25:27 <koffein> probably because I just did not get it, but it should be easy...
06:25:42 <Zao> Heffalump: Oh, I didn't read the backlog, I just saw the word "blackhole" :)
06:25:45 <augustss> Heffalump: perhaps we should start using it
06:26:43 <pejo> augustss, no irc from work?
06:26:50 <koffein> the paste is with error message
06:27:12 * bringert wakes up and finds 2500 empty lines in his source file.
06:27:17 <bringert>  apparatenly I fell asleep with my finger on the enter key.
06:28:12 <augustss> bringert: it would have been better if you had woken up with 2500 lines of beautiful Haskell code
06:28:12 <fasta> What a production 2500 lines of code!
06:28:21 <koffein> does anyone at least know a good tutorial for gtk2hs? I read the glade introduction and the memory example
06:28:22 <fasta> In his dreams ;)
06:28:33 <koffein> they both don't tell much
06:29:26 <bringert> augustss: I've never gotten that to work, unfortunately.
06:29:31 <fasta> Can I profile the stack usage too in some way?
06:29:50 <paczesiowa> koffein: there is original gtk tutorial translated to haskell
06:30:14 <paczesiowa> koffein: http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/
06:30:23 <koffein> paczesiowa, cool, thanks
06:30:27 <olsner> it'd be neat with a programming language where code writes itself
06:30:34 <paczesiowa> koffein: it's not finished though...
06:31:11 <paczesiowa> if code wuold write itself, we would (should?) die:>
06:31:37 <koffein> paczesiowa, is there a downloadable version?
06:31:48 <dmg_> @seen ndm
06:31:48 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 2d 13h 26m 45s ago, and .
06:32:01 <paczesiowa> koffein: wget, httrack?
06:33:14 <koffein> paczesiowa, I always forget the right wget option for that
06:33:26 <koffein> if there are multiple pages
06:33:38 <Saizan_> -m for mirror?
06:33:48 <paczesiowa> koffein: there are like 10 pages, so just save them using browser:>
06:34:01 <koffein> Saizan_, thanks
06:34:10 <koffein> well
06:34:24 <koffein> maybe I'll remember it next time
06:34:27 <koffein> :P
06:35:01 * wli decides that since useful high-level information is not forthcoming he'll just have to try writing module systems to get a feel for them.
06:37:58 <wli> I wonder if module systems are one of those not-very-thoroughly studied corners of programming languages.
06:39:35 <olsner> I guess most people just see it as plumbing
06:41:56 <wli> The last time people forgot how plumbing worked was called the Dark Ages. ;)
06:42:36 <koffein> the tutorial still does not tell my why this should not work... http://pastebin.com/d73084f40
06:42:55 <phlpp> hi omnId
06:43:03 <omnId> hello
06:43:11 <koffein> hi
06:43:47 <koffein> paczesiowa, any idea?
06:44:02 <Saizan_> koffein: textViewGetBuffer textview :: IO TextBuffer it seems, so you've to run it with <- to get a TextBuffer
06:44:17 <EvilTerran> koffein, well, you're trying to use an IO Something as a Something, so you'll need to bind it to get at the Something
06:44:41 <Saizan_> koffein: or in other words: use b <- textViewGetBuffer textview instead of let b = textViewGetBuffer textview
06:44:59 <EvilTerran> (the "use" is not part of the syntax)
06:45:17 <koffein> Saizan_, thanks... I thought I already tried that..
06:46:03 <koffein> now I get what ghc was trying to tell me
06:46:21 <Saizan_> have you familiarity with the IO monad?
06:49:36 <pejo> wli, the ML people have done heaps of work on module systems.
06:50:34 <wli> pejo: cool, though also weird because I've not heard of as much of it as I should in that case
06:52:22 <fasta> augustss: it appears that I cheered too soon. It still does 95% alloc.
06:52:25 <koffein> Saizan_, I'm trying to understand IO.. but I don't
06:52:29 <Heffalump> Derek Dreyer's paper at ICFP this year relates them to type classes.
06:52:34 <wli> I've really lost touch since the SEL-HPC functional programming archive.
06:53:00 <wli> Heffalump: Very interesting. Maybe progress is being made on Haskell's module system expressiveness issues.
06:53:08 <pejo> wli, Derek Dreyer had a paper on ICFP this year about recursive modules. His thesis might be a good start if you want to read up on stuff.
06:53:18 <pejo> Bah, Heffalump beat me to it.
06:53:22 <Heffalump> I don't think anyone is proposing to make significant changes to Haskell's system.
06:53:39 <wli> pejo: The recursive module discussion from some hours ago is actually what inspired my interest right now.
06:53:48 <wli> Heffalump: That's a shame. Oh well.
06:53:50 <koffein> well
06:53:54 <koffein> thanks a lot, guys
06:54:01 <Heffalump> it's a bit of a problem, because type classes are really useful, but they don't subsume a proper module system, but they are close enough that it's not really worth adding one
06:54:02 <koffein> I'm off again
06:54:26 <wli> They don't need to be un-redundant.
06:54:35 <wli> Heck, case and if are redundant. Why do we have if?
06:54:38 <Heffalump> no, but there's a cost to having too much stuff in the language
06:54:52 <Heffalump> it's all a trade-off
06:54:52 <faxathisia> What is that cost?
06:55:14 <Heffalump> potential loss of orthogonality, more work for people to learn the language, more work for implementors and tool writers
06:55:31 <wli> Well, the killer is really control over the scope of instances.
06:55:50 <fasta> Does -0 vs -02 make a difference?
06:56:01 <wli> Things don't need to be very fancy to get some sort of grip on that.
06:56:38 <wli> But my interest is purely for understanding how the things work, not diving into the guts of ghc.
06:58:15 <wli> (In fact, issues "advanced" enough to cope with the Haskell vs. modules issues that make it hard/unique/new/whatever are even optional from my POV.)
07:01:12 <wli> SML or even a monomorphic base language will do.
07:02:21 <ogex> is there some generic function that zips a ByteString and a list?
07:02:43 <Heffalump> into what?
07:03:00 <ogex> into a list of pairs
07:03:12 <fasta> Hmm, it looks as if 02 makes a difference.
07:03:21 <ogex> of a Word8 and elemenst of the list
07:03:37 <Heffalump> @pl \a b -> zip (unpack a) b
07:03:37 <lambdabot> zip . unpack
07:04:10 <ogex> Heffalump, yes I know that but I wonder if this can be done mor egeneric.
07:04:28 <Heffalump> what would be more generic? Some kind of "list-like" type class?
07:04:48 <ogex> you see we have B.zip and List.zip
07:04:48 <ogex> I need something in between
07:05:04 <ogex> yes, or some zippable type class
07:06:13 <Heffalump> John Goerzen did something in that area, I think.
07:06:30 <Heffalump> Do you actually have a need for overloading?
07:06:31 <mrd> ML modules are cool, but type-classes are so damn convenient... sigh
07:07:54 <EvilTerran> SYB has generic zipping... i don't know enough about it to know if it would work for that, though
07:08:06 <ogex> Heffalump ,ideally yes.
07:09:27 <ogex> Is that the John Goerzen of gopher (just seen the wikipedia page)
07:09:53 <Heffalump> EvilTerran: I doubt it, since you need higher level semantic knowledge to know that a ByteString is (in some way) equivalent to a [Word8]
07:10:21 <Heffalump> ogex: seems likeit
07:11:02 <Heffalump> his webpage doesn't seem to have the package on it, though
07:11:26 <EvilTerran> righto. i wasn't sure if it could zip different-typed-but-the-same-shape structures, or only structures that turn out to be the right types
07:12:13 <fasta> ogex: what has he got to do with gopher? I know he has a as gopher page, though.
07:13:41 <Heffalump> EvilTerran: no idea, but I can't see how it could apply either of those possibilities to ByteString and []
07:14:15 <EvilTerran> well, as you mentioned, with enough semantic knowledge, ByteString is kinda like [Word8]
07:14:20 <Heffalump> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ListLike-1.0.0
07:14:23 <lambdabot> http://tinyurl.com/yqtzzl
07:14:30 <ogex> fasta: the two-line wikipedia article about him mentions "gopher" five time: http://en.wikipedia.org/wiki/John_Goerzen
07:14:31 <Heffalump> yes, but SYB doesn't have semantic knowledge
07:14:43 <Heffalump> ogex: that's the package I was thinking of
07:14:53 <EvilTerran> quite
07:15:05 <EvilTerran> so it can only do the latter, not the former
07:16:18 <phlpp> http://projecteuler.net/index.php?section=problems&id=54
07:16:19 <lambdabot> Title: Project Euler
07:16:25 <phlpp> seems to be an interesting task
07:16:52 <phlpp> actually by solving this task you could go one writing your own poke game.. i think it's just a small step then
07:17:20 <ogex> Heffalump, thanx. seems to be similar to what I was looking for
07:31:00 <wli> Okay, found a paper on higher-order modules for SML that clears up a lot of things.
07:32:40 <mux> @users
07:32:40 <lambdabot> Maximum users seen in #haskell: 420, currently: 383 (91.2%), active: 8 (2.1%)
07:35:26 <baboa> hi, just trying out happs...
07:35:54 <baboa> anybody here with some advice what to do first?
07:37:33 <Lemmih> baboa: A blog or a wiki, perhaps.
07:38:14 <baboa> Lemmih: to get it up and running  :)
07:38:30 <fasta> This is rather bad, right? %GC time      61.9%  (60.4% elapsed)
07:38:42 <baboa> their front page changed and got some cool colors, but there is not much info yet...
07:38:48 <Lemmih> baboa: Download, build, install?
07:39:38 <baboa> I'm somewhere inside build right now
07:39:46 <baboa> fighting with HaXml
07:41:50 <bauchus> i have a question about gtk2hs... I do drawings on a cairo canvas. showText works fine. but if I select a special font (chess font) all text disapears. Does anyone know such problems?
07:42:56 <SamB_XP_> bauchus: did you select the font correctly?
07:43:09 <bauchus> i did: selectFontFace "Chess Merida" FontSlantNormal FontWeightNormal
07:43:29 <bauchus> with an invalid font name, the text is there...
07:43:38 <SamB_XP_> oh, funny
07:44:10 <SamB_XP_> what kind of font is Chess Merida?
07:44:35 <bauchus> TrueType
07:44:38 <SamB_XP_> and what happens if you select it with the GTK font selector dialog box?
07:45:47 <bauchus> hm, I'll try it. with xfontsel i can see the chess pieces. demo/fonts (from gtk2hs) lists my font.
07:47:04 <wli> Dreyer's recursive module paper is clearing up a whole heck of a lot.
07:48:28 <TomMD> > do Just
07:48:36 <lambdabot>  Add a type signature
07:48:52 <TomMD> > do Just :: Maybe [a]
07:48:53 <lambdabot>  Couldn't match expected type `Maybe [a]'
07:49:14 <omnId> @type Just
07:49:16 <lambdabot> forall a. a -> Maybe a
07:49:19 <omnId> @type Just []
07:49:21 <lambdabot> forall a. Maybe [a]
07:49:41 <TomMD> I like the fact that 'do Nothing' is valid Haskell.
07:49:57 <omnId> which evaluates to 'Nothing' :)
07:50:12 <bauchus> my font works in the GTK font selector dialog.
07:50:47 <SamB_XP_> huh.
07:52:03 <araujo> dons, ping
07:56:27 <baboa> where do I get generic-xml-any from?
07:58:02 <Lemmih> http://happs.org/HAppS/generic-xml
08:01:04 <fasta> I have a function from [(Int,Int)] -> Foo, but this function never gets to see any of the arguments, because the stack has already been blown before that. I already added rnf in this function to make sure it gets forced there, but it doesn't appear to help.
08:02:01 <fasta> The idea would be that the list gets read from a file and the building of the data structure happens as the file is being read.
08:02:39 <SamB_XP_> does -xc work on blown stacks?
08:02:48 <fasta> SamB_XP_: yes
08:03:17 <fasta> I can also get a profile, but it only tells me that something allocates a lot.
08:03:29 <fasta> That something is the thing that is generating the list.
08:14:37 <LoganCapaldo> @type sum . scanl (*) 1 . map (fromEnum . (' '==))
08:14:39 <lambdabot> [Char] -> Int
08:15:18 <LoganCapaldo> > sum . scanl (*) 1 . map (fromEnum . (' '==)) $ "   a"
08:15:25 <lambdabot>  4
08:15:39 <LoganCapaldo> > sum . scanl1 (*) . map (fromEnum . (' '==)) $ "   a"
08:15:40 <lambdabot>  3
08:16:06 <LoganCapaldo> > sum . scanl1 (*) . map (fromEnum . (' '==)) $ " a"
08:16:08 <lambdabot>  1
08:16:12 <LoganCapaldo> > sum . scanl1 (*) . map (fromEnum . (' '==)) $ ""
08:16:13 <lambdabot>  0
08:16:47 <LoganCapaldo> > scanl1 (*) []
08:16:48 <lambdabot>  []
08:16:53 <LoganCapaldo> oh
08:16:58 <gwern> anyone compiled yi lately? I'm getting odd errors along the line of Setup.hs:34:12: Not in scope: `compilerPath'
08:17:04 <LoganCapaldo> for some reason I expected that would be safe
08:17:11 <gwern> but configure isn't complaining aboiut libraries being missing...
08:17:15 <LoganCapaldo> > foldl (*) []
08:17:16 <lambdabot>   add an instance declaration for (Num [a])
08:17:23 <LoganCapaldo> > foldl1 (*) []
08:17:24 <lambdabot>  Exception: Prelude.foldl1: empty list
08:17:39 <LoganCapaldo> Oh I guess it's ok for scan to not apply the function at all
08:17:41 <LoganCapaldo> duh
08:18:54 <LoganCapaldo> > sum . scanl1 (*) . map (fromEnum . (' '==)) $ "   a" ++ ['a'..] -- lazy?
08:18:56 <lambdabot>  3
08:19:25 <LoganCapaldo> > sum . scanl1 (*) . map (fromEnum . (' '==)) $ "   a" ++ [toEnum 0..]
08:19:27 <lambdabot>  3
08:20:07 <LoganCapaldo> it can't be lazy
08:20:11 <LoganCapaldo> right?
08:20:33 <LoganCapaldo> since (+) is ultimately strict...
08:20:37 <LoganCapaldo> right?
08:21:45 <omnId> > length ['a'..]
08:21:47 <lambdabot>  1114015
08:21:59 <omnId> Bounded enums have an upper bound limit
08:22:08 <LoganCapaldo> yeah I know
08:22:17 <Saizan> > fix $ (1:) . scanl (+) 1
08:22:19 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:22:35 <LoganCapaldo> Saizan: I was talking about the + in sum
08:22:36 <fasta> @src Data.List.minimum
08:22:36 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:22:42 <fasta> @src minimum
08:22:43 <lambdabot> minimum [] = undefined
08:22:43 <lambdabot> minimum xs = foldl1 min xs
08:22:57 <Saizan> LoganCapaldo: ah, right, unless you've a lazy Num instance
08:22:57 <omnId> LoganCapaldo: (+) is strict for Int
08:24:06 <wli> > take 10 $ map numerator $ zipWith (*) (scanl1 (+) $ map recip $ map negate $ scanl1 (*) $ map negate $ [(1 :: Rational) ..]) (scanl1 (*) [1..])
08:24:08 <lambdabot>  [1,1,4,15,76,455,3186,25487,229384,2293839]
08:26:37 <omnId> LoganCapaldo: (length . takeWhile (' '==)) seems to do the same
08:26:52 <LoganCapaldo> sure
08:27:23 <LoganCapaldo> but it's not +/*\" "="  a" :)
08:30:08 <LoganCapaldo> I tried to use takeWhile but they wouldn't let me
08:30:17 <omnId> "they"?
08:30:31 <LoganCapaldo> it was an interview question a while back
08:30:52 <LoganCapaldo> "count the number of leading spaces in a string"
08:30:56 <LoganCapaldo> in K
08:31:07 <fasta> What's the strictness annotations flag name again?
08:31:10 <omnId> ah
08:31:16 <faxathisia> > length (first (group "       abc"))
08:31:24 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
08:31:28 <faxathisia> hm
08:31:30 <omnId> faxathisia: s/first/head/
08:31:37 <faxathisia> oops!
08:31:42 <_achilles_> is K really all that popular?
08:31:58 <LoganCapaldo> I didn't really know K so it was like we were playing this weird game where I coudl ask what operators there were but they didn't want to give away the answer
08:32:29 <LoganCapaldo> The only reason i figured it out was due to Haskell
08:32:35 <omnId> LoganCapaldo:  :D
08:33:17 <LoganCapaldo> anyway it just came to mind
08:33:50 <omnId> what does that 'sum . scanl1 ...' thingy look like in K?
08:34:06 <LoganCapaldo> right so +/ would be sum
08:34:16 <LoganCapaldo> (foldr1 (+) really)
08:34:20 <omnId> oh, +/*\" "="  a"
08:34:25 <fasta> Never mind
08:34:30 <omnId> like you said before
08:34:33 <LoganCapaldo> yeah
08:34:35 * allbery_b is having apl flashbacks
08:34:39 <omnId> I had no idea what that was. :)
08:35:03 <faxathisia> :t scanl1
08:35:05 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
08:35:33 <allbery_b> oh wait.  K would be a successor to J, right?  that would figure it has reduce (/)
08:35:35 <omnId> > scanl1 (+) [3,5,2,7,4] -- like foldl1 but keeps the intermediates
08:35:40 <lambdabot>  [3,8,10,17,21]
08:36:05 <LoganCapaldo> allbery_b: yeah I think so
08:37:33 <omnId> so *\" "= is scanl1 (*) . map (fromEnum . (' '==))
08:38:03 <faxathisia> ahh
08:38:10 <faxathisia> K the [APL like] language
08:38:50 <LoganCapaldo> omnId: yeah except without the fromEnum :)
08:39:02 <LoganCapaldo> no bools
08:39:02 <omnId> bools are straight 0 and 1?
08:39:05 <LoganCapaldo> yeah
08:39:13 <wli> > take 10 $ map numerator $ zipWith (*) (scanl1 (+) $ map recip $ (1:) $ scanl1 (*) $ map negate $ [(1 :: Rational) ..]) (1 : scanl1 (*) [1..])
08:39:15 <lambdabot>  [1,0,1,2,9,44,265,1854,14833,133496]
08:39:20 <wli> Much better.
08:39:27 <omnId> \ modifies to scanlike behavior?
08:39:29 <LoganCapaldo> +/&\" "="   a" would be the same I think
08:39:33 <LoganCapaldo> yeah
08:39:46 <omnId> " "= automatically maps over the string?
08:40:05 <faxathisia> almost everything is an implicit map in K isn't it?
08:40:07 <omnId> how does that work?
08:40:21 <MyCatVerbs> Magic.
08:40:33 <omnId> :)
08:41:27 <LoganCapaldo> strings are vectors of chars
08:41:40 <omnId> is " " a string or a char?
08:41:50 <LoganCapaldo> it's both sort of
08:42:22 <LoganCapaldo> I don't really know that much, I stopped looking into K after I didn't take that job
08:42:54 <LoganCapaldo> but in " "="abc" " " gets promoted(?) to "   " and = is an element wise comparision
08:43:11 <LoganCapaldo> and the result is a vector of 1s or 0s
08:43:27 <omnId> map (==) (repeat ' ') "   a"
08:43:32 <omnId> zipWith, rather
08:43:35 <LoganCapaldo> yeah
08:53:14 <wli> > let facs :: [Ratio Integer] = 1 : scanl1 (*) [1..] in take 10 . map numerator . zipWith (*) facs . scanl1 (+) . map recip . zipWith (*) facs $ cycle [1, -1] -- better still
08:53:14 <lambdabot>  Parse error
08:53:56 <omnId> lhs type annotations are an extension.  Move the :: [Ratio Integer] to the rhs.
08:54:31 <omnId> @src Rational
08:54:32 <lambdabot> type Rational = Ratio Integer
08:54:42 <wli> > let facs = 1 : scanl1 (*) [1..] in take 10 . map numerator . zipWith (*) facs . scanl1 (+) . map recip . zipWith (*) facs $ cycle [1, -1]) :: [Integer]
08:54:42 <lambdabot>  Unbalanced parenthesis
08:55:12 <wli> > let facs = 1 : scanl1 (*) [1..] in take 10 . map numerator . zipWith (*) facs . scanl1 (+) . map recip . zipWith (*) facs $ cycle [1, -1]
08:55:13 <lambdabot>  [1,0,1,2,9,44,265,1854,14833,133496]
08:55:48 <wli> Stupidity of mine for killing all warnings and turning on defaulting warnings.
09:06:19 <Heffalump> njbartlett: you there?
09:06:43 <njbartlett> Heffalump: I am, got to go in a minute though...
09:07:03 <Heffalump> we're due an AngloHaskell pubmeet. Shall I pick a date and announce it?
09:07:43 <njbartlett> Yeah sounds good
09:08:58 <njbartlett> Sorry, have been a bit distracted with other stuff recently. Need to sort out the November meeting at City Uni...
09:09:05 <Heffalump> no problem
09:09:23 <Heffalump> I know you weren't too keen on monthly meetings anyway :-)
09:10:23 <njbartlett> Oh I'd love to do monthly meetings... if I didn't have to organise them, and we could find enough people willing to give talks :-)
09:11:27 <njbartlett> Got to go, TTYL
09:25:09 <fasta> -fvia-c should be named -fultraslow
09:25:59 <LoganCapaldo> Is there a good reason to use -fvia-c?
09:26:16 <LoganCapaldo> Is it more portable or something?
09:26:33 <LoganCapaldo> Oh I guess to bootstrap ghc.
09:26:36 <fasta> LoganCapaldo: the performance guide claims it helps.
09:26:50 <LoganCapaldo> ah
09:27:01 <Lemmih> fasta: Wiki or doc book?
09:27:12 <fasta> Lemmih: doc book
09:27:18 <olsner> I imagine gcc has better code generation, scheduling and all the fiddly cpu-specific stuff
09:27:54 <fasta> Hmm, it seems I crushed the space leak.
09:28:03 <fasta> minimum/maximum are bad
09:28:25 <fasta> Too bad I need to write just about everything from scratch to get a decent program.
09:28:53 <omnId> can anyone think of a simpler: (\xs -> all (==1) $ zipWith (-) (tail rs) rs)?
09:29:36 <LoganCapaldo> heh
09:29:54 <fasta> Does @src show the GHC implementation?
09:29:56 <omnId> s/rs/xs/
09:30:09 <LoganCapaldo> tests for [m,1..n]-ness?
09:30:16 <omnId> yes
09:30:18 <LoganCapaldo> err
09:30:25 <LoganCapaldo> tests for [m,m+1..n]-ness?
09:30:25 <omnId> [m,m+1..n]-ness
09:31:31 <fasta> Much better: the profile now looks like a nice triangle.
09:31:39 <olsner> > scanl (-) [1,2,3,4]
09:31:40 <lambdabot>   add an instance declaration for (Num [t])
09:31:48 <Lemmih> ap (==) (enumFrom . head), perhaps.
09:32:03 <olsner> > scanl (flip subtract) 0 [1,2,3,4]
09:32:05 <lambdabot>  [0,-1,-3,-6,-10]
09:32:11 <olsner> > scanl (subtract) 0 [1,2,3,4]
09:32:12 <lambdabot>  [0,1,1,2,2]
09:32:28 <LoganCapaldo> map (subtract m) == [0..length xs - 1]?
09:34:01 <LoganCapaldo> @type \xs -> map (subtract (head xs)) xs == [0..length xs - 1]
09:34:01 <omnId> and $ zipWith (==) [0..] $ map (subtract (head xs) xs
09:34:03 <lambdabot> [Int] -> Bool
09:34:42 <omnId> no length if you zipWith + and.
09:37:04 <augustss> fasta: maximum/minimum are bad?
09:37:18 <augustss> @src maximum
09:37:18 <lambdabot> maximum [] = undefined
09:37:19 <lambdabot> maximum xs = foldl1 max xs
09:37:26 <fasta> augustss: maybe it was because I used the foldable version
09:38:24 <fasta> This rule should fire: "maximumInt"     maximum = (strictMaximum :: [Int]     -> Int);
09:38:46 <fasta> So, I guess using the non-foldable version _is_ fast
09:43:33 <LoganCapaldo> > foldr ((+) . const 1) 0 "abc"
09:43:45 <lambdabot>  3
09:44:27 <thetallguy> Anyone have a link for exactly what -fglasgow-exts implies?
09:44:59 <augustss> > maximum [1..1000000]
09:45:01 <lambdabot>  1000000
09:45:11 <augustss> > maximum [1..10000000]
09:45:14 <lambdabot>  10000000
09:45:27 <augustss> >maximum [1..100000000]
09:45:40 <augustss> > maximum [1..100000000]
09:45:44 <lambdabot> Terminated
09:46:20 <faxathisia> @src maximum
09:46:21 <lambdabot> maximum [] = undefined
09:46:21 <lambdabot> maximum xs = foldl1 max xs
09:46:36 <faxathisia> > foldr1 max [1.. 100000000]
09:46:38 <lambdabot>  Exception: stack overflow
09:47:51 <fasta> By fast, I meant that it didn't overflow the stack.
09:48:09 <faxathisia> I suppose we verge into Big Num territory when you go past 10000000?
09:48:17 <faxathisia> which is why it suddenly becomes a lot harder to calculate
09:48:27 <augustss> fasta: But I can't get the library maximum to overflow the stack
09:49:01 <thetallguy>     Couldn't match expected type `. (forall a) a'
09:49:02 <thetallguy> 	   against inferred type `()'
09:49:30 <thetallguy> I'm getting this message without -fglasgow-exts, but not with, and I would like to narrow it down
09:50:24 <fasta> augustss: neither can I probably. I used Data.Foldable.maximum
09:51:16 <augustss> fasta: oh, ok.  that's probably far too general.  Gotta watch out for those over-generalized functions ;)
09:51:25 <fasta> augustss: yes, unfortunately.
09:51:52 <conal> thetallguy: it's not recognizing the forall syntax.
09:51:52 <fasta> augustss: This utopy of "reuse" isn't reality yet.
09:52:02 <augustss> thetallguy: does your program contain a 'forall'?
09:52:33 <thetallguy> conal: oh, I had assumed it was recognizing but not allowing some aspect of it to typecheck
09:52:35 <conal> thetallguy: the "." got treated as an infix op and is being rendered prefix.
09:52:37 <augustss> fasta: No, that only works in C++
09:52:37 <fasta> augustss: It seems "reuse" in this fashion depends on how fast a $1000 machine is.
09:52:39 <thetallguy> Ah
09:53:02 <fasta> augustss: general code compiles slow in C++, though.
09:53:02 <conal> thetallguy: i only recognized the problem because i've gotten this kind of message a few times.
09:53:12 <fasta> augustss: and why cannot do GHC do the same a C++?
09:53:12 <thetallguy> Okay, thanks, I had gotten stuck on it being a higher level problem.
09:53:19 <fasta> augustss: nobody cared about it, I guess?
09:53:30 <fasta> as*
09:53:54 <thetallguy> I guess I'll remove the forall
09:53:57 <augustss> fasta: Well, with the RULES stuff you get closer to what you can do with templates in C++
09:54:09 <thetallguy> publish the lib and let y'all comment.
09:54:09 <conal> thetallguy: sure.  or use {-# LANGUAGE Rank2Types -#} or -fglasgow-exts
09:54:35 <thetallguy> That would exclude yhc, wouldn't it?
09:54:51 <augustss> fasta: And yes, when something is slow it's often because no one has cared enough yet.
09:54:53 <conal> thetallguy: i guess it would.
09:55:00 <thetallguy> Since this is a function to time expression evaluation, I'd like to ensure that it is more standard.
09:55:16 <thetallguy> If there's a really good reason to include the forall, I'll do it.
09:55:18 <conal> does anyone know if yhc supports "forall" type exprs?
09:55:21 <augustss> thetallguy: If you don't need the forall, leave it out
09:55:21 <fasta> I wonder whether the gcc developers ever use their own compiler ;)
09:55:30 <LoganCapaldo> @pl \xs n -> asTypeOf (len xs) n
09:55:30 <lambdabot> asTypeOf . len
09:55:39 <thetallguy> It's only there because GHC gave it to me.
09:55:40 <fasta> thetallguy: forall is not in Haskell98
09:55:40 <augustss> conal: no
09:55:48 <fasta> thetallguy: you can disable that
09:56:08 <augustss> conal: that wasn't the answer to your question, but to the implied question :)
09:56:22 <conal> augustss: :)
09:56:56 <fasta> I guess something the size of Openoffice written in GHC compiled via -fvia-c would take a month to compile here.
09:57:38 <thetallguy> Removing the forall does the trick, at least type check wise
09:57:42 <augustss> fasta: are you stuck with a 386?
09:57:58 <fasta> augustss: no, 2800+
09:58:16 <conal> is there a standard type for binary trees?
09:58:19 <fasta> augustss: it's not a quadcore like everybody else has here ;)
09:58:28 <augustss> compiler developers should be forced to use their own compiler and have very slow machines
09:59:03 <thetallguy> well, I think they should get to use fast machines
09:59:11 <thetallguy> but have to finish on the slow one before release
09:59:18 <fasta> augustss: what machinepark do you have? ;)
09:59:24 <Korollary> that would hurt their productivity, though. They just should have benchmarks.
09:59:46 <thetallguy> Yeah, the slow machine should be part of the test suite
09:59:46 <augustss> fasta: Nothing super fast.  Typically I use my MacBook
09:59:49 <Korollary> run on slower machines I mean
10:00:07 <Heffalump> does anyone understand changes in the behaviour of scoped type variables between GHC 6.6 and 6.8?
10:00:23 <fasta> Heffalump: I do know how to port
10:00:30 <fasta> Heffalump: otherwise, I have no idea.
10:01:18 <augustss> Heffalump: it's sane in 6.8, I think :)
10:01:35 <augustss> I could never figure out how they worked before
10:02:05 <Heffalump> I had to add some signatures to a program that compiled with 6.6, to make it work with 6.8. And then 6.6 started complaining I'd used two names for the same scoped type variable (correctly, I think). But when I try making the names the same, 6.8 complains.
10:02:38 <Heffalump> I suspect there's been a change in whether some of them are in a binding position or not.
10:02:40 <fasta> Heffalump: you want code that works with both versions?
10:02:53 <Heffalump> fasta: ideally, yes
10:03:18 <fasta> Heffalump: I think you essentially need to copy the code then.
10:03:31 <Heffalump> i.e. use CPP?
10:03:35 <fasta> Heffalump: yes
10:03:48 <Heffalump> lovely.
10:04:00 <Heffalump> I'll try to persuade droundy to switch to 6.8 :-)
10:04:11 <fasta> Heffalump: but if you want a more informed answer you should ask someone who implemented it :)
10:07:24 <fasta> Anything I can do to recude  %GC time      67.3% ?
10:07:29 <fasta> reduce*
10:08:02 <pejo> fasta, produce fewer intermediate lists?
10:08:31 <fasta> pejo: what happened to deforestation?
10:10:15 <pejo> fasta, it doesn't fuse everything. If it does I guess you have to do something else though.
10:10:43 <fasta> I also need tools to read this profile.
10:10:47 <fasta> 1500 lines...
10:27:28 <kolmodin> any code.h.o admins around?
10:27:38 <kolmodin> Igloo: ?
10:28:01 <kolmodin> I'd like to be part of the binary-p group
10:48:34 <conal> is there a shift happening from d.h.o to c.h.o?
10:48:44 <Heffalump> yes
10:49:29 <conal> what's the shift about?
10:50:18 <allbery_b> I think d.h.o was haphazardly granted access whereas c.h.o is intended to be a community resouce linked with hackage
10:51:15 <conal> is there value in moving existing packages to c.h.o?
10:51:28 <Heffalump> yes, it'll be easier for new people to get access to change them
10:51:43 <conal> oh.  thanks.
10:52:54 <allbery_b> (d.h.o was more for folks directly affiliated with haskell.org, c.h.o is a sort of haskell sourceforge)
10:54:11 <magnusth> I'm feeling silly asking this... how do I catch an error like "*** Exception: Map.find: element not in the map"?
10:54:33 <allbery_b> Control..Exception.catch, o use Map.lookup which returns a Maybe
10:54:45 <allbery_b> Control.Exception.catch, or use Map.lookup which returns a Maybe
10:54:52 * allbery_b looks suspiciously at his finfers
10:55:27 <allbery_b> the latter is generally preferable, exceptions are a poor way to d business in general
10:56:00 <magnusth> allbery_b, how could I use Control.Exception.catch?  the type involves IO
10:56:11 <allbery_b> right, exceptions can only be caught in IO
10:56:20 <allbery_b> that's one reason why you should use Map.lookup instead
10:56:36 <magnusth> allbery_b, ah, got you
10:56:40 <allbery_b> if you insist on using exceptions, look at Control.Exception.evaluate
10:56:53 <allbery_b> but laziness means you need to make sure you force he value or the exception will escape the catch
10:57:13 <allbery_b> lookup is safer because it'll DTRT with laziness
10:57:19 <newsham> exceptions dont want to die either
10:58:26 <magnusth> allbery_b, since I'm not in IO where I need to catch I'll probably just use lookup... seems like the easier way
11:05:36 <sclv> is the general pattern for exceptions in haskell then: avoid them whenever possible
11:05:37 <sclv> ?
11:06:26 <Saizan> yes
11:07:15 <Saizan> because they can only be catched in IO, also they can hide in an unevaluated thunk
11:09:27 <sclv> so when is it a useful pattern to ever generate or catch an exception? i can see generating them for debugging purposes -- i.e. failfast on invalid states. but catching them?
11:10:44 <Saizan> well in networking or I/O code
11:11:06 <Heffalump> making programs more robust
11:11:12 <mrd> generally, haskell programmers prefer to use MonadError
11:11:41 <mrd> :type lookup
11:11:51 <Saizan> :t lookup
11:11:51 <shachaf> :t lookup
11:11:53 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:11:55 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:12:02 <mrd> :t Data.Map.lookup
11:12:04 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
11:12:29 <mrd> @hoogle ErrorT
11:12:30 <lambdabot> Control.Monad.Error.ErrorT :: m (Either e a) -> ErrorT e m a
11:12:30 <lambdabot> Control.Monad.Error.ErrorT :: newtype ErrorT e m a
11:12:30 <lambdabot> Control.Monad.Error.mapErrorT :: (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
11:12:48 <shachaf> And this uses fail when the lookup fails?
11:13:03 <shachaf> It should be MonadZero. :-)
11:14:16 <newsham> ?type maybe
11:14:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:15:33 <shachaf> @ty fromMaybe mzero
11:15:35 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe (m a) -> m a
11:16:13 <mrd> the difference is that "failure" in this case provides an error message
11:16:52 <shachaf> Well, fail should still be in MonadZero.
11:32:53 <visof> ?karma c
11:32:54 <lambdabot> c has a karma of 15
11:33:02 <visof> what is the meaning of karma?
11:33:15 <visof> i can t understand this
11:33:23 <byorgey> visof: in general, or specifically in #haskell?
11:33:41 <bartw> wikipedia has the answers ;)
11:33:45 <visof> in #haskell
11:34:08 <byorgey> in #haskell, it's a way of rewarding others for being helpful or doing something praiseworthy, etc.
11:34:56 <byorgey> so if a user named foo was helpful to you, you could say @karma+ foo (or just put ++ after their nick) to award them a karma point.
11:35:14 <newsham> ?karma- visof
11:35:14 <lambdabot> visof's karma lowered to -1.
11:35:22 <jaj> lambdabot++
11:35:38 <jaj> @karma+ lambdabot
11:35:38 <lambdabot> lambdabot's karma raised to 48.
11:36:00 <opqdonut> ?karma opqdonut
11:36:01 <lambdabot> You have a karma of 1
11:36:09 <lament> ?karma
11:36:09 <lambdabot> You have a karma of 0
11:36:10 <visof> is karma English word?
11:36:13 <lament> yes.
11:36:14 <byorgey> ?karma+ visof
11:36:15 <lambdabot> visof's karma raised to 0.
11:36:32 <byorgey> well, yes, but originally it was borrowed from... some other language.
11:36:41 <lament> like most words.
11:36:42 <byorgey> hindi, perhaps?  I'm not sure
11:36:47 <byorgey> lament: good point. =)
11:37:19 <newsham> ?all-dict karma
11:37:19 <visof> ?karma+ visof
11:37:22 <lambdabot> *** "Karma" gcide "The Collaborative International Dictionary of English v.0.48"
11:37:22 <lambdabot> Karma \Kar"ma\, n. [Skr.]
11:37:22 <lambdabot>    1. (Buddhism, Hinduism) One's acts considered as fixing one's
11:37:22 <lambdabot>       lot in the future existence.
11:37:22 <lambdabot>       [1913 Webster]
11:37:23 <lambdabot> [20 @more lines]
11:37:25 <lambdabot> You can't change your own karma, silly.
11:37:40 <visof> haha
11:37:45 <byorgey> Skr. = Sanskrit?
11:37:51 <opqdonut> yep
11:37:53 <newsham> karma is a conservation law.  sum of what you give == sum of what you get
11:38:15 <newsham> "what goes around comes around"
11:38:23 <jaj> visof, well I guess you should raise lambdabot's karma for giving you this definition ;)
11:38:48 <jaj> @more
11:38:52 <olsner> perhaps karma should be measured in percent of the total given karma, rather than absolute values
11:39:17 <visof> ?karma+ lambdabot
11:39:18 <lambdabot> lambdabot's karma raised to 49.
11:39:30 <visof> ?karma+ haskell
11:39:31 <lambdabot> haskell's karma raised to 22.
11:40:52 <byorgey> olsner: that would be rather discouraging.  "Your karma is 0.003%."
11:41:28 <olsner> s'pose so
11:41:36 <allbery_b> it also trips over the perl svnbot that ++s ayone who commits.  once per line of commit message
11:41:48 <allbery_b> (mmm, karma spam)
11:42:54 <pgavin> @seen dcoutts
11:42:55 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 1h 2m 38s ago.
11:44:24 <jaj> @seen lambdabot
11:44:24 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #
11:44:25 <lambdabot> ghc and #darcs
11:46:25 <newsham> I think the karma conservation might actually be an integral and not a summation
11:47:37 <kolmodin> ?karma
11:47:38 <lambdabot> You have a karma of 2
11:47:42 <kolmodin> hmm..
11:47:59 <LoganCapaldo>  ?karma chameleon
11:48:28 <Korollary> eww
12:02:42 <ricky_clarkson> If something you run quickcheck on takes two args, does qc grab a new value for each arg for each test, or do something like nested loops?
12:03:17 <oerjan> new value for each i think
12:03:53 <ricky_clarkson> So if the first arg's generator is exhausted, does testing stop?
12:04:09 <oerjan> i think you are confusing qc with smallcheck
12:04:28 <ricky_clarkson> Is smallcheck what lambdabot does with @scheck?
12:04:40 <LoganCapaldo> yeeeees
12:04:41 <oerjan> @check \a b -> a || b || True
12:04:43 <lambdabot>  OK, passed 500 tests.
12:04:50 <ricky_clarkson> If the first arg's generator is exhausted *in qc* what happens?
12:05:05 <oerjan> as you can see quickcheck does lots of tests despite there being only 4 possible combinations
12:06:04 <oerjan> it essentially chooses each test case randomly i think
12:06:12 <oerjan> with no regard for the previous ones
12:06:54 <oerjan> but smallcheck generates all (below a size bound) in some order
12:07:52 <ricky_clarkson> I see.
12:08:16 <ricky_clarkson> What does this mean then?  "Arguments exhausted after 97 tests."
12:08:30 <ricky_clarkson> (mentioned in http://www.cs.chalmers.se/~rjmh/QuickCheck/manual_body.html#3 )
12:08:31 <oerjan> from quickcheck?
12:08:44 <ricky_clarkson> Yes.
12:08:49 <LoganCapaldo> they got really tired and had to take a nap before doing anymore tests
12:08:58 <ricky_clarkson> I feel the same.
12:09:06 <dmwit> ricky_clarkson: You can specify preconditions for a test.
12:09:24 <dmwit> It then picks lots of random examples, but only tests the ones that meet the precondition.
12:09:43 <dmwit> Of course, you want to know how many actual tests it ran, not how many random things it tried.
12:09:47 <byorgey> ricky_clarkson: by default, it only produces a maximum number of possible test cases.  If a lot of them get thrown out due to preconditions (specified by ==>), you might get that 'exhausted' message.
12:10:00 <ricky_clarkson> Grr, the doc I pointed to does explain that.
12:10:15 <oerjan> @scheck \a b -> a || b || True
12:10:17 <lambdabot>   Completed 4 test(s) without failure.
12:11:18 <jatqceer> hi, what is the best way to catch an floating point exception, like NAN or divide by zero?
12:11:18 <ricky_clarkson> Is a test data generator equivalent to a List?
12:11:53 <dmwit> :t isNAN
12:11:55 <lambdabot> Not in scope: `isNAN'
12:12:01 <dmwit> ?hoogle isnan
12:12:02 <lambdabot> Prelude.isNaN :: RealFloat a => a -> Bool
12:12:21 <dmwit> :t catch
12:12:23 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
12:12:50 <dmwit> > 1 / 0 -- but not always an exception
12:12:51 <lambdabot>  Infinity
12:12:59 <LoganCapaldo> @type (/)
12:13:01 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:13:35 <dmwit> > isNaN (1 / 0) -- hmm
12:13:36 <lambdabot>  False
12:13:55 <bartw> eh ?
12:14:08 <bartw> thats a new one
12:14:49 <LoganCapaldo> newtype SafeFrac a = SF a ; instance (Fractional a) => Fractional (SafeFrac a) where (/) (SF _) (SF 0) = error "Divide by zero" ; (/) (SF a ) (SF b)  = SF (a/b) ...
12:15:18 <jatqceer> actually, it seems to me that NAN or Infinity will not raise any exception.  and I need to explicitly test with isNAN or isInfinity and raise a exception myself, which make the code much more unreadable
12:15:50 <LoganCapaldo> throw in a deriving Num and the code practically writes itself
12:15:52 <jatqceer> isNaN (0 / 0)
12:15:53 <LoganCapaldo> ;)
12:16:00 <jatqceer> > isNaN (0 / 0)
12:16:02 <lambdabot>  True
12:16:31 <dmwit> > 1 `div` 0
12:16:33 <lambdabot>  Exception: divide by zero
12:16:50 <jatqceer> > isInfinity (1 / 0)
12:16:51 <lambdabot>   Not in scope: `isInfinity'
12:17:11 <jatqceer> @hoogle isinfinity
12:17:11 <lambdabot> No matches found
12:17:12 <dmwit> > isInfinite (1 / 0)
12:17:14 <lambdabot>  True
12:17:50 <oerjan> > nub . filter isInfinite $ [-1/0, 1/0]
12:17:52 <lambdabot>  [-Infinity,Infinity]
12:18:01 <monadonous> hey, is there a way to import modules in ghci?
12:18:08 <allbery_b> :m +...
12:18:11 <newsham> :module +Data.List
12:18:30 <dmwit> or :m *... if you want to import the closure (useful when you're importing a module you wrote).
12:18:45 <LoganCapaldo> import the closure?
12:18:58 <allbery_b> transitive closure, I assume
12:19:03 <allbery_b> i.e. all modules needed
12:19:10 <allbery_b> along with the one you named
12:19:22 <monadonous> doesn't that just change the module context? what if I want to import several modules?
12:19:22 <LoganCapaldo> How will it know?
12:19:28 <jatqceer> is there any paper or reference on writing numerically stable program in haskell?
12:19:37 <allbery_b> :m without the + changes the context
12:19:41 <allbery_b> :m + adds modules
12:19:59 <allbery_b> :m - removes a module added with :m +
12:20:25 <monadonous> cool, thanks
12:20:41 <newsham> there's also :help ;-)
12:21:04 <monadonous> yeah mine says nothing about this. Is it a GHC 6 feature? I could only get 5 to install
12:22:26 <oerjan> @version
12:22:26 <lambdabot> lambdabot 4p555, GHC 6.6 (Linux i686 2.66GHz)
12:22:26 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:22:58 * oerjan hopes you at least mean 6.5
12:23:16 <oerjan> 5 is - ancient
12:23:27 <monadonous> yeah, the freebsd port for 6 didn't work
12:23:48 <monadonous> and source install looked scary, though I guess GHC 5 could compile 6 for me
12:25:51 <dmwit> monadonous: You should try downloading one of the binaries from the GHC site. 6.6 is really quite a lot different from 5.
12:26:06 <dmwit> (If you really are using GHC 5... and not 6.5.)
12:27:26 <dmwit> It'll be worth the effort. =)
12:27:53 <monadonous> there was a freebsd binary, but only for x64
12:28:00 <monadonous> is source install hard?
12:28:12 <mrd> whats the earliest ver you can compile 6.6 with
12:28:46 <dmwit> I'm surprised there was no package in FreeBSD's package manager for it.
12:28:47 <monadonous> it says 5.04 on the website
12:28:58 <monadonous> there was a package, but the package was broken
12:29:00 <dmwit> I know there are at least a few other people using GHC 6.6 on FreeBSD.
12:29:01 <allbery_b> sounds like he's on freebsd 4 still
12:29:10 <dmwit> mmm
12:29:13 <monadonous> nope, 6.1-RELEASE
12:29:29 <allbery_b> huh
12:29:32 <monadonous> the package failed during linking with "Error 1"
12:29:34 <allbery_b> update your ports
12:29:38 <monadonous> yeah
12:29:41 <allbery_b> 6.6.1 should be current
12:30:14 <mrd> how do ports handle ghc
12:31:05 <olsner> probably by first downloading the binary
12:33:18 <allbery_b> yes, ports include a minimal bootstrap binary tarball
12:33:29 <allbery_b> which is used to build the full port
12:34:55 <allbery_b> oh, which website are you looking at?
12:35:09 <monadonous> http://haskell.org/ghc/download_ghc_661.html
12:35:10 <lambdabot> Title: GHC: Download version 6.6.1
12:35:24 <allbery_b> I think the only packages built for freebsd4 were ghc 5.04, btw
12:39:59 <newsham> thats why not to run freebsd4.
12:40:15 <vvv> > help
12:40:16 <lambdabot>   Not in scope: `help'
12:40:40 <oerjan> @help
12:40:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:40:50 <newsham> cant you build ghc6 with ghc5 somehow?
12:40:59 <vvv> oerjan: thnx! :)
12:40:59 <sorear> yes you can
12:41:05 <sorear> or rather 'should'
12:41:08 <vvv> @list
12:41:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:41:32 <vvv> @help seen
12:41:33 <lambdabot> seen <user>. Report if a user has been seen by the bot
12:41:55 <vvv> @seen arossato
12:41:55 <lambdabot> arossato is in #xmonad and #haskell. I don't know when arossato last spoke.
12:42:22 <vvv> @botsnack
12:42:22 <lambdabot> :)
13:09:40 <roconnor> I read through the Geometric Algebra textbook.
13:09:49 * roconnor tries to remember who wanted to know about that.
13:10:11 <roconnor> ugh, 396 possible people.
13:11:57 <roconnor> oh right, the archives
13:12:36 <oerjan> @users
13:12:36 <lambdabot> Maximum users seen in #haskell: 420, currently: 400 (95.2%), active: 11 (2.8%)
13:14:29 <bartw> 12
13:16:12 <ricky_clarkson> The rest are fbi bots trying to decrypt our code.
13:17:53 <lament> little do they know that the secret password is "12345"!
13:18:23 <LoganCapaldo> I have the same combination on my luggage
13:20:11 <bartw> ah, not fair, you skipped a line in that joke
13:20:48 <bartw> ah, spaceballs
13:23:11 <_dml> how can i convert an Integer to an Int?
13:23:22 <_dml> (I realize this is dangerous)
13:23:25 <Liskni_si> fromIntegral
13:23:39 <LoganCapaldo> @quote monochrom
13:23:39 <lambdabot> monochrom says: Well I was writing Windows apps in C since the days of Windows 3.0 and I tell you it's very OO.
13:23:48 <LoganCapaldo> @quote fromIntegral
13:23:48 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
13:23:57 <_dml> Liskni_si: thanks
13:52:45 <LurkerJoe> can someone point me to some doc on how to "register and identify myself with the network's nickname registration services (e.g. NickServ)"? "/motd" was suggested, but is not displaying anything for me (in chatzilla).
13:52:59 <Heffalump> did you try /msg nickserv help?
13:53:17 <Heffalump> and did you check any status window for the responses?
13:53:26 <kpreid> LurkerJoe: http://freenode.net/faq.shtml#nicksetup
13:53:27 <lambdabot> Title: freenode: frequently-asked questions
13:54:48 <LurkerJoe> haeffalump: no on the "/msg nickserv", I'm both a #haskell newbie and an IRC newbie. Don't have a status window message that I see. I'll try each of these suggestions. Thanks.
13:54:58 <vvv> what is a common extension for files that should be pre-processed by cpphs to get .hs?
13:55:10 <LurkerJoe> oops... and thanks kpreid
13:55:31 <Igloo> vvv: .hs
13:55:35 <vvv> <foo>.cpphs?
13:56:56 <dibblego> what would we call the type-class for a type that has mplus, >>=, unit/return, but not mzero?
13:57:13 <allbery_b> broken?
13:57:13 <vvv> Igloo: And then I should feed cabal with my cpphs definitions, right?
13:57:17 <Heffalump> MonadFucked
13:58:06 <dibblego> how about this type: newtype X a = X (a, [a])
13:58:39 <olsner> MonadMisc
13:58:57 <dibblego> Misc because it has miscellaneous Monad operations?
14:01:01 <pjd> dibblego: a monoid without an identity is a semigroup
14:01:04 <wli> MonadRecursiveHigherOrderModulesWithScopedInstances?
14:01:20 <olsner> yes, in lieu of Heffalump's proposal, but less offensive
14:02:13 <dibblego> pjd, then should there be a semigroup type class?
14:02:38 <pjd> i'm sure there is, in one of the alternative Preludes
14:02:58 <dibblego> pjd, with just the one function: a -> a -> a?
14:03:29 <pjd> you would have something like (Monad m, Semigroup (m a)) =>...
14:04:12 <dibblego> Semigroup is not a Monad though right?
14:04:41 <pjd> dibblego: that one function would be mappend / mplus, yeah
14:04:54 <dibblego> ok thanks
14:05:28 <pjd> well, Semigroup and Monad are somewhat independent, in that context
14:05:34 <dibblego> class (Semigroup a) => Monoid a where ... would be ideal then according to what I am reading
14:05:36 <pjd> it's the monad instance that's a semigroup
14:05:45 <dibblego> yep, gotchya
14:05:50 <pjd> yeah, that sounds right
14:06:36 <dibblego> excellent, thanks for the help
14:07:26 <pjd> dibblego: have you read John Meacham's class alias proposal?
14:07:33 <dibblego> no
14:07:41 <pjd> http://repetae.net/john/recent/out/classalias.html
14:07:42 <lambdabot> Title: Class Alias Proposal for Haskell
14:08:02 <dibblego> cheers
14:08:25 <pjd> that, or something like that, is sorely needed to make the above-mentioned kind of fine-grained class hierarchy practical
14:09:02 <dibblego> practical; not so much typing it all out all the time?
14:11:30 <ryani> @pl \a b -> Constr $ f (unConstr a) (unConstr b)
14:11:30 <lambdabot> (Constr .) . (. unConstr) . f . unConstr
14:12:02 <birkenfeld> ryani: sounds like a job for a Functor
14:12:12 <ryani> @pl \f a b -> Constr $ f (unConstr a) (unConstr b)
14:12:13 <lambdabot> ((Constr .) .) . flip flip unConstr . ((.) .) . (. unConstr)
14:12:23 <ryani> Perhaps
14:14:28 <ryani> Not exactly, though
14:14:39 <ryani> newtype Vector a = Vector [a]
14:14:54 <ryani> unVector (Vector v) = v
14:14:56 <oerjan> :t curry (?constr . uncurry ?f . (?unConstr *** ?unConstr)
14:14:58 <lambdabot> parse error (possibly incorrect indentation)
14:15:00 <oerjan> :t curry (?constr . uncurry ?f . (?unConstr *** ?unConstr))
14:15:02 <lambdabot> forall c c1 a c2. (?unConstr::a -> c2, ?f::c2 -> c2 -> c1, ?constr::c1 -> c) => a -> a -> c
14:15:08 <phlpp> hm, are there some haskell books (haven't to be like an introduction to haskell) that anyone could recommend?
14:15:12 <ryani> liftVec f = Vector . f . unVector
14:15:19 <dibblego> phlpp, Graham Hutton's
14:15:24 <phlpp> or is the situation like there are no good/necessary books about haskell out there
14:15:38 <ryani> which is pretty, but liftVec2 is less pretty.
14:16:02 <Cale> phlpp: There's Graham Hutton's book, as well as some older ones.
14:16:02 <wli> I need to get Graham Hutton's book but have blown my budget for months to come.
14:16:24 <wli> Cale: Which older ones?
14:16:55 <Cale> http://haskell.org/haskellwiki/Books_and_tutorials has a list
14:16:57 <lambdabot> Title: Books and tutorials - HaskellWiki
14:17:13 <oerjan> :t curry (?constr . (uncurry ?f `on` ?unConstr))
14:17:15 <lambdabot> Not in scope: `on'
14:17:18 <Cale> School of Expression, Craft of Functional Programming
14:17:46 <wli> I've got those two. They were a bit too introductory for me.
14:18:08 <Cale> Apparantly Hutton's book is more introductory.
14:18:17 <wli> Ouch.
14:18:33 <Cale> (But perhaps better written)
14:18:53 <KatieHuber> pjd: that Meacham proposal looks really good... but what are the chances it actually gets implemented (presumably as a GHC extension first)?
14:19:14 <Cale> wli: You'd probably be better off just reading papers.
14:19:18 <pjd> KatieHuber: if you find out, let me know!
14:19:24 <KatieHuber> heh
14:19:44 <Cale> Don has a book coming out soon called "Real world haskell"
14:19:45 <wli> Yeah. Or writing.
14:19:49 <pjd> it looks exciting to me too, but i'm just a recreational Haskeller yet
14:19:58 <wli> Don & Bos' book sounds pretty exciting to me.
14:20:04 <phlpp> what will this book be about
14:20:04 <phlpp> ?
14:20:04 <pjd> not up to speed with developments
14:20:08 <Cale> Er, yeah, and Brian :)
14:20:13 <Cale> Bryan, sorry :)
14:20:24 <mauke> @unpl join (liftM evalPermu (mapM (return draw)))
14:20:24 <lambdabot> ((liftM evalPermu (mapM (return draw))) >>= \ a -> a)
14:20:52 <oerjan> actually, (Constr .) . (f `on` unConstr)
14:21:07 <KatieHuber> hmm, it seems to be progressing well :p http://hackage.haskell.org/trac/ghc/ticket/788
14:21:09 <lambdabot> Title: #788 (Class aliases (as proposaed by John Meacham)) - GHC - Trac
14:21:43 <oerjan> :t let on (+) f x y = f x + f y in (?constr .) . (?f `on` ?unConstr)
14:21:45 <lambdabot> forall b c t a. (?constr::b -> c, ?f::t -> t -> b, ?unConstr::a -> t) => a -> a -> c
14:22:23 <pjd> "Milestone: _|_" ?
14:36:06 <fasta> pjd: isn't it obvious?
14:38:30 <lokimaf> how do i add a module to my local ghc?
14:39:22 <byorgey> lokimaf: it depends what you mean.  What exactly are you trying to do?
14:39:25 <lokimaf> like i have module VALsi and I want to access it for another package
14:39:35 <lokimaf> from another module in a different program
14:39:57 <lokimaf> also have a module NAMcu
14:40:46 <lokimaf> which converts Integer ->  LOGJbang  String numbers,  so want to use that for random number generator output
14:41:31 <byorgey> well, the easiest way is if you have them in the same directory, you can just type 'import VALsi' (or whatever) at the top of the module in which you want to use it.
14:41:51 <lokimaf> but it's a different directory
14:42:25 <lokimaf> i have my lOgjbang in the lOgjbang section, and my random intelligence stuff in ri folder
14:42:41 <byorgey> you can also package them up using cabal, and use that to help you install it.
14:43:00 <lokimaf> kk
14:43:05 <lokimaf> thanks
14:43:15 <byorgey> here's a good place to start: http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
14:43:16 <lambdabot> Title: How to write a Haskell program - HaskellWiki
14:43:29 <byorgey> that has info & links on how to set everything up.
14:47:07 <lokimaf> i've decided that maybe lOgjbang will need a random number generator so I might as well integrate it
14:48:03 <lokimaf> am in the process
15:04:39 <fatt> Hi! A question. We are making compiler with Haskell and syntax has possibility to import files. We are using Alex and Happy as tools for this dragon. Do you have any suggestions or pointers to give how the importing could/should be done? Thanks from any advices given :)
15:05:11 <lokimaf> hey how come complement creates negative numbers instead of just flipping the bits?
15:05:19 <araujo> fatt, a compiler about what?
15:05:34 <wli> The sign bit is one of the bits.
15:05:35 <fatt> for c like language
15:05:37 <Heffalump> lokimaf: if you flip the top bit of a signed number you will change its sign..
15:05:49 <lokimaf> is there an ordinary negation function?
15:05:55 <lokimaf> well negative numbers are bogus
15:05:57 <Heffalump> yes, negate
15:06:02 <Heffalump> well, use unsigned types then
15:06:13 <lament> > let x = 42 in -x
15:06:13 <lokimaf> like 0x1 complement is 0xe
15:06:14 <lambdabot>  -42
15:06:28 <lokimaf> 0001 complement = 1110
15:06:31 <Heffalump> no, 0x1 complement is 0xfffffffe
15:06:36 <Heffalump> on 32 bit values
15:06:50 <lokimaf> well not on hex values
15:06:52 <lokimaf> hmmm
15:07:00 <Heffalump> if you want 4 bit values, you'll need to do something to make sure they are truncated
15:07:00 <lokimaf> but okay, i'll just write my own
15:07:22 <pmatos> Hello all, why can't I input nested list of integers into the repl? (like [1,[2,3],3])
15:07:38 <LoganCapaldo> that does not type check
15:07:48 <herrmann> Wrong type
15:07:50 <ricky_clarkson> pmatos: What type of list is that?
15:08:02 <herrmann> Do you want [Int] or [[Int]] ?
15:08:02 <LoganCapaldo> you can do [[1],[2,3],[3]]
15:08:08 <pmatos> oh... lists are homogenous in haskell... of course...
15:08:10 <pmatos> :-\
15:08:13 <ricky_clarkson> > (1,(2,3),3)
15:08:14 <lambdabot>  (1,(2,3),3)
15:08:22 <LoganCapaldo> or [Left 1, Right [2,3], Left 3]
15:08:42 <pmatos> LoganCapaldo: What is that?
15:08:55 <Olathe> > ('b', 'a', 'n', 'a', 'n', 'a', 's')
15:08:55 <ricky_clarkson> The Either monad.
15:08:56 <lambdabot>  ('b','a','n','a','n','a','s')
15:09:13 <LoganCapaldo> I think the monad part is a little irrevelant for this scenario :)
15:09:21 <LoganCapaldo> @type [Left 1, Right [2,3], Left 3]
15:09:23 <lambdabot> forall t t1. (Num t1, Num t) => [Either t [t1]]
15:09:27 <ricky_clarkson> The Either warm and fuzzy thing.
15:09:35 <LoganCapaldo> the Either data type :)
15:09:40 <pmatos> humm, oki, thanks!
15:09:42 <LoganCapaldo> @src Either
15:09:43 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:09:57 <LoganCapaldo> data Either a b = Left a | Right b
15:10:01 <Olathe> You call yourself a rocket scientist !
15:10:06 <LoganCapaldo> Do not!
15:10:07 <Olathe> You should be ashamed of yourself !
15:10:15 <LoganCapaldo> Na ah!
15:10:21 <ricky_clarkson> Rocket science is trivial compared to type theory.
15:10:55 <LoganCapaldo> Is it really?
15:11:00 <LoganCapaldo> "trivial"?
15:11:01 <ricky_clarkson> Burn something, something moves.  The rest is engineering.
15:11:09 <SamB> it truly is
15:11:09 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
15:11:19 <Olathe> @messages
15:11:20 <lambdabot> You don't have any new messages.
15:11:28 <SamB> @messages
15:11:28 <ricky_clarkson> @massages
15:11:28 <lambdabot> locomalo said 2d 14h 57m 55s ago: "Hello, Once I asked for discribing hardware with functional languages and you pointed me to funhdl project, thak you for that. Are you using Atom or Lava? Thank
15:11:28 <lambdabot> you"
15:11:28 <lambdabot> You don't have any new messages.
15:11:52 <ricky_clarkson> @massagas
15:11:53 <lambdabot> You don't have any new messages.
15:11:59 <ricky_clarkson> @mas aguas
15:11:59 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
15:12:25 <LoganCapaldo> heh
15:12:27 <SamB> @msg locomalo I'd like to be using atom or lava
15:12:27 <lambdabot> Not enough privileges
15:12:38 <Olathe> @msg Olathe hi
15:12:39 <lambdabot> Not enough privileges
15:12:41 <Olathe> :(
15:12:42 <LoganCapaldo> @tell SamB it's @tell
15:12:42 <lambdabot> Consider it noted.
15:12:46 <Olathe> I can't even tell myself something.
15:12:51 <SamB> oopa
15:12:51 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
15:12:54 <SamB> oops
15:12:54 <Olathe> @tell Olathe hi
15:12:54 <lambdabot> You can tell yourself!
15:12:58 <Olathe> :(
15:12:58 <SamB> @tell locomalo I'd like to be using atom or lava
15:12:58 <lambdabot> Consider it noted.
15:13:25 <Olathe> lambdabot: What if I'm not here right now ?
15:13:28 <SamB> anyway, back to rocket science being trivial compared to type theory
15:13:33 <Olathe> lambdabot: Then, it's not so hard to tell me something.
15:13:40 <Olathe> not so easy.
15:14:01 <LoganCapaldo> @tell LoganCapaldo_todos Buy milk
15:14:01 <lambdabot> Consider it noted.
15:14:03 <SamB> Olathe: but you can't ask lambdabot if you aren't here
15:14:07 <wli> Rocket science's difficulties are largely related to its empirical nature.
15:14:11 <mauke> @vixen tell Olathe hi
15:14:12 <lambdabot> hello there
15:14:16 <NotOlathe> @tell Olathe hi
15:14:17 <lambdabot> Consider it noted.
15:14:19 <LoganCapaldo_tod> o drat
15:14:29 <SamB> wli: and the expense of the rockets
15:14:30 <Olathe> @messages
15:14:30 <lambdabot> NotOlathe said 13s ago: hi
15:14:33 <Olathe> Yay !
15:14:35 <LoganCapaldo_tod> my chocie of nick was too long
15:14:54 <Olathe> Now lambdabot will have to remember that message forever.
15:15:10 <wli> SamB: I lumped that in with the rest of the empirical stuff.
15:15:17 <LoganCapaldo> Until someone rips it bleeding from her metaphorical skull
15:15:19 <jcreigh> hmm, for being a "simple graphics library", it sure is hard to figure out from the docs how to draw a pixel in Graphics.HGL
15:15:40 <SamB> wli: it's not such a big deal if you use balsa
15:15:46 <LoganCapaldo> Doesn't HGL call out to OpenGL?
15:15:49 <SamB> and cardboard
15:15:50 <SamB> and plastic
15:16:03 <LoganCapaldo> I didn't think OpenGL was terribly pixel oriented
15:16:07 <lokimaf> lol my negation function makes no use of numbers
15:16:08 <Olathe> What's a good 2D pixel-based library ?
15:16:10 <jcreigh> LoganCapaldo: no, I don't think so.
15:16:21 <SamB> LoganCapaldo: that's hOpenGL
15:16:26 <jcreigh> LoganCapaldo: I mean, I don't think Graphics.HGL is OpenGL based
15:16:27 <LoganCapaldo> oh nvm then
15:16:53 <SamB> HGL is that one that you just don't use
15:17:11 <jcreigh> SamB: oh? What's the one that I use?
15:17:12 <fatt> Exp from Alex&Happy? Some direction how to implement file importing (changing the stdin source etc) during parsing needed here.
15:17:27 <LoganCapaldo> "he Haskell Graphics Library is designed to give the programmer access to most interesting parts of the Win32 Graphics Device Interface and X11 library without exposing the programmer to the pain and anguish usually associated with using these interfaces."
15:17:33 <LoganCapaldo> I was clearly mistaken
15:18:02 <SamB> LoganCapaldo: yeah, see, they obviously disagree about the most interesting parts
15:18:10 <wli> I'm going to have to look at one of the graphics libraries these days.
15:18:22 <LoganCapaldo> Yeah
15:18:39 <SamB> clearly you want the glut bindings ;-)
15:18:44 <LoganCapaldo> methinks trying to wrap both X and win32 in some kind of lowest common denominator is bound to fail
15:18:48 <SamB> or do I mean glu>?
15:19:39 <SamB> ... whichever library will set you up so you can do OpenGL stuff without having to use WGL/GLX interfaces
15:22:10 <LoganCapaldo> besides I'd much rather have haskell bindings to GDI+ than win32
15:33:50 <fasta> What does threadDelay do exactly? Does it wait "real actual time" or CPU time that's used by GHC?
15:34:34 <mauke> I think it's real time
15:35:09 <fasta> Hmm, so the only way it's accurate if GHC is the only process running on the machine.
15:35:24 <fasta> Is there anything else that's independent of that?
15:35:35 <wli> If Linux there's oprofile.
15:36:07 <SamB> what are you trying to achieve?
15:36:55 <fasta> SamB: I intend to let my machine run for about 10 days running lots of experiments, but I'd also still like to use it to do some text editing.
15:37:46 <SamB> I meant, what had you been hoping to use threadDelay for ?
15:38:08 <fasta> SamB: I currently use it to stop the computation when it takes longer than 5 minutes.
15:38:35 <fasta> SamB: I let two computations compete: the actual computation and threaddelay
15:38:58 <fasta> SamB: when it completes the answer is Just <something> otherwise it's Nothing
15:38:58 <SamB> oh. you want to let the computation run for that much CPU time?
15:39:04 <fasta> SamB: right
15:39:42 <fasta> There's getCPUTime which I use to count CPU time
15:42:19 <LoganCapaldo> does it really matter if it's exactly 5 minutes or jsut about five minutes?
15:42:41 <fasta> LoganCapaldo: well, 5 minutes or within 10% of that, I guess.
15:43:53 <LoganCapaldo> > 5 * 60 * 0.10 / 60
15:43:54 <lambdabot>  0.5
15:44:15 <LoganCapaldo> i shoulda been able to do that in my head
15:45:11 <SamB> between five and five and a half minutes?
15:45:46 <fasta> "There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run earlier than specified."
15:45:54 <fasta> That's also not really good
15:46:07 <SamB> fasta: well, it sounds like you don't have any actual realtime requirements
15:46:12 <wli> That is standard.
15:46:30 <fasta> SamB: indeed I haven't.
15:46:36 <Liskni_si> There's also setitimer in posix.
15:46:44 <wli> The wakeup won't be early but there may be scheduling delays, e.g. a busy system.
15:46:44 <fasta> SamB: it's not a SNES ;)
15:47:03 <wli> That's almost a quote from manpages on timer primitives, if not a verbatim one.
15:47:38 <SamB> so you could just wait 5 minutes, see what the cpu time used by the other thread was, and then continue waiting 15 seconds at a time or something...
15:47:40 <mauke> fasta: you could always check cpu time when the timer expires, then reschedule yourself if needed
15:48:22 <mauke> sleep (total - cputime) >> recheck
15:48:44 <fasta> mauke: I guess I will do that. Thanks
15:48:49 <SamB> I'm not sure what happens if the worker thread gets into a tight loop though
15:49:14 <SamB> (a tight loop being one with no allocation or thread-related calls)
15:49:27 <fasta> SamB: my code is not that tight
15:49:33 <LoganCapaldo> it can still get preempted though can't it?
15:50:06 <SamB> LoganCapaldo: yes but can you kill it?
15:50:10 <fasta> SamB: in fact I have no idea how one can write like that in Haskell (unless you allocate an STArray once and do a kind of assembly programming on that)
15:50:45 <SamB> let f n = f $! (n+1)
15:51:05 <fasta> SamB: (and actually doing something too)
15:51:34 <LoganCapaldo> SamB: I don't follow. the killing thread, gets scheduled, sets the kill flag on tight loop thread, and tight loop thread doesn't get scheduled again, no?
15:51:52 <SamB> fasta: well I guess you'll be okay then
15:52:03 <sjanssen> fasta: it doesn't guarantee that the thread will sleep for the exact time, but it is pretty close in practice
15:52:10 <SamB> LoganCapaldo: the thing about those tight loops is that they never reenter the schedular
15:52:29 <LoganCapaldo> So the answer to my "it can still get preempted question" was no :)
15:52:30 <fasta> sjanssen: are you suggesting it is pointless to implement the extra logic suggested by mauke?
15:52:38 <LoganCapaldo> ok
15:52:43 <SamB> unless you can force the OS thread into the schedular?
15:53:20 <sjanssen> fasta: I don't think mauke's hack is needed, threadDelay always sleeps for at least the duration
15:53:32 <sjanssen> unless the thread receives an async exception
15:53:32 <SamB> LoganCapaldo: well, I guess the problem is that there are two schedulars involved, and preemption could refer to either one...
15:53:58 <mauke> sjanssen: huh?
15:54:04 <LoganCapaldo> Yeah sorry, I spefically meant the thread scheduler for GHC could premept the thread with the tight loop :)
15:54:15 <SamB> sjanssen: but threadDelay sleeps in clock time, not CPU time
15:54:25 <sjanssen> oh, fasta wants CPU time
15:54:29 <lokimaf> :t genericTake
15:54:32 <sjanssen> nevermind
15:54:35 <SamB> LoganCapaldo: the answer to that is "I don't see how"
15:54:38 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
15:54:42 <lokimaf> is there a take that accepts an Integer?
15:54:51 <wli> genericTake
15:55:03 <lokimaf> @hoogle genericTake
15:55:04 <lambdabot> List.genericTake :: Integral a => a -> [b] -> [b]
15:55:04 <lambdabot> Data.List.genericTake :: Integral i => i -> [a] -> [a]
15:55:05 <Olathe> brandedTake
15:55:14 <SamB> lokimaf: it's generic
15:55:21 <SamB> it doesn't HAVE to take an Integer
15:55:29 <Olathe> @hoogle Integral
15:55:29 <lambdabot> Prelude.Integral :: class (Real a, Enum a) => Integral a
15:55:30 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
15:55:30 <jcreigh> (although you really have to ask yourself, are your lists going to contain more than 2**31 elements?)
15:55:39 <Olathe> What are the Integral types ?
15:55:45 <SamB> @instances Integral
15:55:46 <lambdabot> Int, Integer
15:55:47 <mauke> @instances Integral
15:55:48 <lambdabot> Int, Integer
15:55:55 <Olathe> My lists are infunute !
15:56:04 <SamB> @instances-importing Data.Word,Data.Int,Foreign.C.Types Integral
15:56:05 <lambdabot> Int, Integer
15:56:09 <mauke> @instances-exporting Data.Word Integral
15:56:10 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
15:56:31 <SamB> @instances-importing Data.Word Data.Int Foreign.C.Types Integral
15:56:32 <lambdabot> CChar, CInt, CIntMax, CIntPtr, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort, CWchar, Int, Int16, Int32, Int64, Int8,
15:56:32 <lambdabot> Integer, Word, Word16, Word32, Word64, Word8
15:56:38 <Olathe> > genericTake (5::Word64) [1..25]
15:56:40 <lambdabot>  [1,2,3,4,5]
15:56:51 <Olathe> > genericTake (278::Int8) [1..25]
15:56:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]
15:57:24 <Olathe> > genericTake (254::Int8) [1..25]
15:57:25 <LoganCapaldo> SamB: yeah that's unfortunate. Maybe GHC's thread scheduler could run in a seperate OS thread from the rest of the code. Of course then you're at the mercy of your OS's scheduler to run your scheduler. meh. Sucks.
15:57:25 <lambdabot>  Exception: List.genericTake: negative argument
15:57:26 <lokimaf> cool
15:57:52 <Olathe> > length (genericTake (254::Word8) [1..25])
15:57:53 <lambdabot>  25
15:57:58 <Olathe> > length (genericTake (254::Word8) [1..2500])
15:58:00 <lambdabot>  254
15:58:06 <SamB> LoganCapaldo: no, all you need is a way for the schedular to be invoked periodically...
15:58:13 <SamB> safely
15:59:11 <LoganCapaldo> you could pepper the generated code with the occasional schedule() in the midle of tight loops. heh
15:59:19 <lokimaf> how about a version of !! that accepts an Integer?
15:59:55 <mauke> @hoogle generic
15:59:55 <lambdabot> Data.Generics.Aliases.Generic :: type Generic c
15:59:56 <lambdabot> List.genericDrop :: Integral a => a -> [b] -> [b]
15:59:56 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
16:00:13 <Olathe> > let (!!!) = (flip . genericTake) in [1, 2, 3, 4, 5] !!! (2::Integer)
16:00:14 <lokimaf> genericIndex
16:00:14 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[a]'
16:00:23 <Olathe> > let (!!!) = genericTake in [1, 2, 3, 4, 5] !!! (2::Integer)
16:00:24 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Integer'
16:00:27 <Olathe> :(
16:00:51 <lokimaf> > generic Index [1,2,3] (1::Integer)
16:00:51 <lambdabot>   Not in scope: data constructor `Index'
16:00:54 <lokimaf> > genericIndex [1,2,3] (1::Integer)
16:00:56 <lambdabot>  2
16:00:59 <lokimaf> yay :-)
16:01:04 <Olathe> Oh :(
16:01:41 <Olathe> > let (!!!) = genericIndex in [1, 2, 3, 4, 5] !!! (1::Integer)
16:01:43 <lambdabot>  2
16:01:50 <Olathe> !!! !
16:02:15 <LoganCapaldo> @type (!)
16:02:17 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
16:02:34 <Olathe> @type (!!!)
16:02:36 <lambdabot> Not in scope: `!!!'
16:02:49 <Olathe> OMG: '!!!'
16:03:49 <LoganCapaldo> @instances Ix
16:03:50 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
16:04:06 <LoganCapaldo> @instances-importing Ix
16:04:07 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
16:04:11 <SamB> hmm, oh, that's right
16:04:23 <SamB> the schedular uses timer signals...
16:04:51 <dmwit> ?instances-importing Data.Ix Ix
16:04:52 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
16:04:55 <nornagon> @scheck \k' v' -> let { (<<) = shiftL; (>>) = shiftR; k = abs k'; v = abs v' } in (((k::Int)<<12) * v) >> 24 == k * (v>>12)
16:04:56 <lambdabot>   Completed 169 test(s) without failure.
16:05:27 <LoganCapaldo> Ordering is an instance of Ix?
16:05:28 <nornagon> ^- is there a better way to check only positive integers? also, why is there no instance for (Serial Word32)?
16:05:30 <dmwit> instance Ix Ordering?
16:05:31 <LoganCapaldo> fascinating
16:05:51 <LoganCapaldo> oooo
16:06:10 <LoganCapaldo> instance (Enum a) => Ix a where ... would be cool
16:06:15 <dmwit> nornagon: Maybe use (==>)?
16:06:21 <SamB> LoganCapaldo: did you get that?
16:06:27 <nornagon> @ty (==>)
16:06:29 <dmwit> ?src Ix
16:06:29 <lambdabot> Not in scope: `==>'
16:06:29 <lambdabot> class (Ord a) => Ix a where
16:06:29 <lambdabot>     range           :: (a,a) -> [a]
16:06:29 <lambdabot>     index           :: (a,a) -> a -> Int
16:06:29 <lambdabot>     inRange         :: (a,a) -> a -> Bool
16:06:31 <lambdabot>     rangeSize       :: (a,a) -> Int
16:06:39 <nornagon> dmwit: ... ?
16:06:41 <SamB> LoganCapaldo: GHC's RTS does, in fact, call the schedular at intervals
16:06:52 <SamB> using timer signals of some kind
16:06:57 <LoganCapaldo> SamB: huzzah
16:07:03 <dmwit> nornagon: Sorry, that's a QuickCheck thing.  My bad.
16:07:12 <nornagon> ah, does lb have quickcheck?
16:07:14 <SamB> so says http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Signals
16:07:16 <lambdabot> Title: Commentary/Rts/Signals - GHC - Trac
16:07:17 <dmwit> It's ?check
16:07:27 <nornagon> (this is for testing some fixed point arith accuracy)
16:07:33 <nornagon> @check \k' v' -> let { (<<) = shiftL; (>>) = shiftR; k = abs k'; v = abs v' } in (((k::Int)<<12) * v) >> 24 == k * (v>>12)
16:07:34 <lambdabot>  Falsifiable, after 185 tests: -92, 85
16:07:46 <nornagon> rats.
16:08:34 <SamB> @scheck \k' v' -> let { (<<) = shiftL; (>>) = shiftR; k = abs k'; v = abs v' } in (((k::Int)<<12) * v) >> 24 == k * (v>>12)
16:08:35 <lambdabot>   Completed 169 test(s) without failure.
16:08:50 <SamB> puny scheck
16:11:16 <nornagon> oh well, i guess that answers that question anyway.
16:16:18 <fasta> SamB: You are right: it doesn't work with this: pointless_loop xs = pointless_loop (reverse xs)
16:17:10 <SamB> fasta: funny
16:17:17 <SamB> that looks like it does allocation to me
16:17:37 <fasta> SamB: I choose xs to be []
16:17:43 <SamB> even so
16:17:44 <fasta> SamB: chose*
16:17:55 <fasta> SamB: I only tested in ghci.
16:17:55 <SamB> I'd expect it to allocate a bunch of THUNK nodes
16:18:00 <EvilTerran> if reverse were defined with reverse xs@[] = xs...
16:18:16 <EvilTerran> or is there only ever one [] node anyway?
16:18:34 <SamB> EvilTerran: well, maybe two or three
16:18:44 <EvilTerran> that makes sense. heck, even i thought of it ;)
16:19:04 <dmwit> What if GHC knows that reverse . reverse == id?
16:19:06 <SamB> depending on how many versions of GHC.Base are loaded
16:19:10 <Olathe> @src reverse
16:19:10 <lambdabot> reverse = foldl (flip (:)) []
16:19:25 <Olathe> > (reverse . reverse) [1..]
16:19:36 <SamB> s/versions/copies
16:19:37 <Olathe> Faster !
16:19:39 <lambdabot> Terminated
16:20:15 <fasta> leaky abstractions
16:20:58 <Liskni_si> dmwit: Is it?
16:21:31 <dmwit> Liskni_si: Semantically, yes, but as Olathe showed, GHC doesn't know that.
16:21:49 <jcreigh> @hoogle Region -> Graphic
16:21:50 <lambdabot> No matches, try a more general search
16:21:53 <jcreigh> grr.
16:22:00 <mrd> it is when strict
16:22:14 <Liskni_si> dmwit: What's the semantics of reverse of an infinite list?
16:22:27 <fasta> Ok, I see the problem.
16:23:17 <fasta> No, I won't see the problem, merely an observation.
16:23:44 <fasta> If I try return [1..] it also never returns Nothing
16:23:54 <dmwit> Liskni_si: One way you could think of infinite list semantics is to consider them to be the "limit" of the (finite) inits of the list, in some appropriate metric space.
16:23:59 <EvilTerran> if a haskell interpreter worked by algebraic manipulation of expressions, it'd be possible for reverse.reverse to work...
16:24:22 <EvilTerran> like those maths programs that do algebraic calculus and whatnot
16:24:25 <dmwit> Liskni_si: Then it shouldn't be too hard to show that reverse . reverse would be id for each list in the limit, and hence id overall as well.
16:25:09 <dmwit> I guess I haven't really worked through the details, so there might be some hidden snag in defining the metric space or so, but (reverse . reverse == id) seems intuitively reasonable.
16:25:30 <EvilTerran> think of reverse on infinite lists like sqrt on floats or whatever; it loses information, but you can get around that (at least in part) by eliminating as many applications of the functions algebraically as possible before evaluating 'em
16:25:59 <EvilTerran> that's my thinking, anyway. i imagine the performance characteristics would be horrible and probably involve exponentiation, though.
16:25:59 <Liskni_si> dmwit: Ok, good point :)
16:26:55 <dmwit> proof by intimidation
16:28:16 <LoganCapaldo> I don't think I like the sqrt on floats analogy
16:28:31 <fasta> You can replace reverse [1..] by error "out of memory"
16:29:12 <LoganCapaldo> and reverse (error "out of memory") does result in error "out of memory", no? :)
16:29:42 <Liskni_si> Yeah.
16:29:47 <LoganCapaldo> wait is that an argument for or against. I'm confused
16:30:00 <fasta> And (reverse.reverse) [1..] by error "very funny"
16:30:09 <LoganCapaldo> hehhe
16:30:14 <Liskni_si> If f x returns bottom, g $ f x should as well, provided it's strict.
16:30:22 <EvilTerran> LoganCapaldo, sqrt (error "out of memory") results in  in error "out of memory", too :)
16:30:48 <EvilTerran> unless you have a very funny number representation, anyway. but i'm also confused.
16:32:05 <EvilTerran> Liskni_si, i consider elimination of bottoms to be an optimisation ;)
16:32:19 <jcreigh> okay, my idea of drawing a pixel by making a line that starts and ends on the same point doesn't work. there's a rectangleRegion :: Point -> Point -> Region, but I only see functions that can draw a Graphic. How do I convert a Region to a Graphic?
16:32:22 <dmwit> > let g = const 3; bottom = bottom; f x = return bottom; x = error "foobar" in g $ f x
16:32:26 <lambdabot>  Add a type signature
16:32:30 <EvilTerran> as long as an implementation doesn't introduce bottoms the standard says must be absent, i don't mind
16:33:17 <dmwit> jcreigh: What library?
16:33:20 <jcreigh> HGL
16:33:32 <EvilTerran> @docs Graphics.HGL
16:33:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL.html
16:33:35 <jcreigh> alternatively, what library other than that should I be using?
16:33:41 <LoganCapaldo> jcreigh: http://www.haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL-Draw-Region.html
16:33:44 <lambdabot> http://tinyurl.com/246hkx
16:33:50 <LoganCapaldo> last function on the page
16:33:56 <jcreigh> oh God.
16:33:58 <LoganCapaldo> regionToGraphic
16:33:59 <jcreigh> sorry, I'm so stupid.
16:33:59 <EvilTerran> Graphics.HGL.Draw.Region.regionToGraphic :: Region -> Graphic
16:34:05 <EvilTerran> ah, beaten to the punch
16:34:09 <dmwit> What a great name.
16:34:13 <jcreigh> I've looked at that page like 20 times.
16:34:21 <Liskni_si> dmwit: "provided it's strict"
16:34:26 <EvilTerran> jcreigh: ah, don't worry about it. we all have stupid days. :)
16:34:28 <jcreigh> thanks guys. :)
16:40:00 <fasta> Are there any -fvia-c benchmarks vs default?
16:47:02 <sorear> fasta: used to be, but dons took them down
16:47:14 <fasta> sorear: it seems the shootout uses via-c
16:48:07 <fasta> sorear: is that still the suggested flag when you want the fastest code disregarding compile time?
16:48:12 <sorear> yes
16:48:21 <sorear> by 2% or so
16:48:58 <mauke> my new favorite function: permute = join (liftM evalPermu (mapM (return draw)))
16:49:03 <fasta> Ok, I can imagine why it's the default.
16:49:13 <fasta> (not via-c)
16:49:24 <ricky_clarkson> :t permute
16:49:27 <lambdabot> Not in scope: `permute'
16:49:44 <dmwit> :t evalPermu
16:49:46 <lambdabot> Not in scope: `evalPermu'
16:49:58 <mauke> it's not in any library
16:50:01 <dmwit> mauke: Too many parens! =)
16:50:12 <dmwit> join . liftM . evalPermu . mapM . return $ draw
16:50:23 <EvilTerran> evilEmu?
16:50:26 <mauke> nice. now replace every . by `liftM`
16:50:46 <LoganCapaldo> and replace the existing liftM with fmap
16:50:53 <EvilTerran> and liftM liftM with join ($) fmap
16:51:10 <EvilTerran> need to get some reader binds in there, too
16:51:27 <mauke> permute xs = evalPermu (mapM (const draw) xs) xs  -- real version
16:51:53 <LoganCapaldo> is Permu some kind of permutation monad?
16:51:59 <EvilTerran> this gives you all permuations of a list, i take it?
16:52:03 <mauke> EvilTerran: yes
16:52:18 <mauke> LoganCapaldo: yes, that's what I had in mind when I wrote it
16:53:08 <mauke> "draw" takes a random element from the remaining values
16:53:20 <mauke> well, it takes every one of them and combines the results
16:53:51 <mauke> (Permu is actually a StateT [] under the hood)
16:54:30 <EvilTerran> isn't there something hairy in the [] monad to do permutations?
16:54:54 <dmwit> There's a clever, hairy solution for the power set.
16:55:09 <EvilTerran> > filterM (const [True, False]) [1..3]
16:55:11 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
16:55:35 <EvilTerran> cartesian product's easy, too (liftM (,))
16:56:16 <mauke> anyway, the mapM generates (draw; draw; draw; ...) with one draw for each list elements
16:56:21 <EvilTerran> nCr's fairly easy, given the power set, i guess; you could filter by length (although i imagine there's a nicer way to do it that doesn't involve power set)
16:56:36 <mauke> then runPermu computes all possibilities and returns a list of them
16:58:04 <Tela> I'm having trouble understanding how to layer transformers, at least concerning MaybeT
16:58:56 <Tela> I want to carry a state computation around that might produce an invalid answer at any point and then have it short circuit the remaining calculations with Nothing.
16:59:43 <mauke> do you want to get a state with Nothing?
17:00:00 <dmwit> I think you want StateT Maybe
17:00:04 <dmwit> .
17:00:04 <Tela> I'd like to, yeah
17:00:09 <mauke> @unmtl StateT Maybe
17:00:09 <lambdabot> StateT Maybe
17:00:26 <dmwit> Well, StateT s Maybe.
17:01:04 <mauke> I don't think so
17:01:11 <Tela> If I return Nothing at some point in there will it stop all the rest of the state computations?
17:01:14 <mauke> that'd give you Maybe (a, s)
17:01:30 <fasta> Tela: mauke means whether you want to have a state value when the result is Nothing
17:01:43 <Tela> Yeah, I'd like it
17:02:11 <fasta> Ok, I thought there was a miscommunication.
17:02:15 <dmwit> ?unmtl MaybeT (State s)
17:02:15 <lambdabot> MaybeT (State s)
17:02:29 <mauke> @kind ErrorT
17:02:33 <fasta> @help mtl
17:02:37 <lambdabot> * -> (* -> *) -> * -> *
17:02:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:02:39 <fasta> @help unmtl
17:02:39 <lambdabot> unroll mtl monads
17:02:47 <Tela> I was thinking of just making a Maybeish type that carries a value around in Nothing but doesn't do anything with it, but that doesn't seem best
17:02:49 <fasta> unroll?
17:02:59 <mauke> @unmtl ErrorT e (State s) a
17:03:00 <lambdabot> s -> (Either e a, s)
17:03:09 <mauke> bingo!
17:03:28 <Tela> Huh, I suppose that's true. Either isn't a monad in the Prelude, right?
17:03:30 <fasta> thanks
17:03:35 <pchiusano> hi
17:03:57 <mauke> I don't think so
17:04:13 <Tela> So, State (Either Board Board) ()
17:04:14 <pchiusano> I am trying to figure out the most haskell-ish way of doing the following:
17:04:35 <pchiusano> I am doing a scanl f s alist
17:04:36 <Tela> And just have it pass the value through without modification on the Left side
17:05:09 <mauke> how is Board an error value?
17:05:13 <pchiusano> and I basically want to cut off the list once f returns Nothing
17:05:32 <dmwit> :t unfoldr
17:05:34 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:05:35 <mauke> but yeah, that'd work
17:05:46 <mauke> no, wait
17:05:57 <pchiusano> i guess I want like a scanlWhile
17:05:59 <Tela> It's not exactly an error, it's just a board that failed to result correctly
17:06:27 <mauke> State s (Either Board Board)
17:06:41 <dmwit> pchiusano: Try unfoldr or playing with "flip mplus".
17:07:19 <Tela> Well, the Board is the state, I just don't quite have the type together for what () is going to be ;)
17:07:57 <mauke> Tela: then you can just use ErrorT String (State Board) a
17:08:12 <scook0> pchiusano: another option might be takeWhile isJust on the result
17:08:36 <Tela> How would I get a board out on errors, though? ErrorT Board (State Board) a?
17:09:02 <mauke> @unmtl ErrorT String (State Board) a
17:09:02 <lambdabot> Board -> (Either String a, Board)
17:09:05 <scook0> (with appropriate fmapping or whatever in the middle)
17:09:13 <mauke> Tela: see? it always return a Board
17:09:56 <Tela> Ahh... I see
17:09:57 <mauke> the fst value tells you whether it was successful (Right a) or failed (Left String)
17:11:13 <Tela> Transformers are clicking more and more now... :)
17:12:05 <conal> ?type Stream
17:12:07 <lambdabot> Not in scope: data constructor `Stream'
17:12:10 <conal> ?type Data.Stream
17:12:12 <lambdabot> Couldn't find qualified module.
17:12:26 <dmwit> ?type Data.Stream.Stream
17:12:28 <lambdabot> Couldn't find qualified module.
17:12:35 <dmwit> ?index Stream
17:12:35 <lambdabot> Network.Socket
17:12:36 <conal> i'm picking up a Data.Stream data type, and i don't know where it's coming from.
17:13:00 <mauke> @google Data.Stream
17:13:03 <lambdabot> http://www.datastream.net/
17:13:03 <lambdabot> Title:
17:13:08 <conal> i installed Wouter's Data.Stream, but a different Data.Stream is getting found instead
17:13:35 <conal> oh -- from Arrow.
17:13:44 <conal> i mean from the "arrow" package.
17:14:47 <scook0> @djinn a -> (a -> Bool) -> Maybe a
17:14:47 <lambdabot> f a b =
17:14:47 <lambdabot>     case b a of
17:14:47 <lambdabot>     False -> Nothing
17:14:47 <lambdabot>     True -> Just a
17:15:02 <conal> i wonder what the rules are resolving conflicts between packages
17:15:16 <dmwit> rand % 2
17:15:19 <dmwit> ?
17:15:24 <Zao> Either import them qualified, or use  hiding.
17:15:38 <conal> they're both Data.Stream
17:15:41 <dmwit> Zao: I think he has two packages with identically named modules.
17:15:45 <Zao> Ah.
17:15:58 <twanvl> I think you need to use ghc-pkg to hide/uninstall one of them
17:17:23 <twanvl> Or maybe you can pass a flag to ghc to tell it which packages to use
17:17:27 <Saizan> you can pass -hide/package flags to ghc directly, or use cabal and depend on only one of them
17:30:49 <timthelion> \connect im.bitlbee.org
17:30:58 <ben> Almost!
17:31:09 <Zao> > flip '\'
17:31:10 <lambdabot>  Improperly terminated character constant
17:31:23 <timthelion> I know, I just typed it wrong.
17:31:49 <timthelion> I'm not perfect, I'll never be a haskeller, whaa
17:31:52 <dmwit> > flip '\''
17:31:57 <lambdabot>  Couldn't match expected type `a -> b -> c'
17:32:09 <dmwit> That's a better error message. =)
17:52:20 <shachaf> sorear: Are you sure what you posted to -cafe was what Andrew Coppin wanted?
17:52:33 <shachaf> sorear: It looks like it just reduces a lambda expression.
17:52:51 <shachaf> sorear: He wanted to transform it to SKI.
17:55:01 <scook0> shachaf: wouldn't that just require a different definition of reduce?
17:55:22 <scook0> (I think that was the idea)
17:56:08 <shachaf> Oh, hmm. I may have misunderstood "Thought it sounded fun, so I did it".
17:57:09 <shachaf> Well, it would need a bit more than that.
17:57:21 <shachaf> Since reduce is :: Term -> Maybe Term.
17:57:43 <monadonous> has anyone ever gotten this error while compiling GHC?:
17:57:56 <shachaf> Oh, never mind, maybe.
17:58:05 <monadonous> /usr/bin/ar: creating libHSbase.a
17:58:09 <monadonous> gmake[2]: *** [libHSbase.a] Error 1
17:58:14 <monadonous> gmake[2]: *** Deleting file `libHSbase.a'
17:58:25 <Zao> monadonous: Paste sites are nice.
17:58:39 <monadonous> paste site?
17:58:43 <scook0> @paste
17:58:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:58:59 <Zao> Or rafb.net/paste for generic text.
18:00:50 <hpaste>  monadonous pasted "GHC compile fails" at http://hpaste.org/3402
18:10:37 <sorear> shachaf: ah, well, that's easily enough fixed
18:13:48 <sclv> has anyone played with business objects' CAL language?
18:14:45 <phlpp> gn8 guys
18:14:53 <phlpp> byorgey: still here? :D
18:16:29 <shachaf> > Data.Generics.everywhere (Data.Generics.mkT (++"!")) ["a", "bc"] -- I can see why this happens, but is there an easy way to do what I'm trying to?
18:16:31 <lambdabot>  ["a!!","bc!!!"]
18:19:19 <sjanssen> shachaf: only match against []'s instead of all lists?
18:20:02 <twanvl> > Data.Generics.everywhere (Data.Generics.mkT $ \x -> if null x then "!" else x) ["a", "bc"]
18:20:04 <lambdabot>  ["a!","bc!"]
18:20:31 <sjanssen> Data.Generics.everywhere (Data.Generics.mkT (\s -> if null s then "!" else s)) ["a", "bc"]
18:20:41 <sjanssen> bah, twanvl wins
18:21:27 <wli> I wonder what you'd have to do to these toy evaluators to tack on a module language.
18:21:34 <wli> module system, rather.
18:22:21 <shachaf> sjanssen, twanvl: OK, thanks.
18:23:34 <sharris> sclv, I've played with Cal, even did a database library of sorts in it
18:23:43 <nornagon> :t Data.Generics.everywhere
18:23:45 <lambdabot> forall a. (Data.Generics.Basics.Data a) => (forall a1. (Data.Generics.Basics.Data a1) => a1 -> a1) -> a -> a
18:24:04 <nornagon> scary
18:25:01 <sclv> sharris: does it implement any measure of ghc type extensions, or is it closer to straight haskell 98?
18:25:44 <sharris> Not even up to h98 in some ways, e.g. no nested pattern matching and some other things
18:25:54 <sharris> No extensions for sure
18:25:56 <sclv> sharris: also, is it generally, in your opinion "ready for prime time" so to speak -- trying to decide if its worth it for me to get my feet wet in it to take advantage of java's libraries.
18:26:27 <sharris> Yeah, the Java libs are a huge thing for me too at work - I think it's worth a good look
18:26:57 <sclv> something usable and to the JVM as F# is to .NET would be huge.
18:27:12 <phlpp> ok guy's
18:27:14 <phlpp> gn8
18:27:16 <phlpp> sleep well
18:27:28 <SamB> Scala?
18:27:32 <kpreid> sclv: I don't really know, but isn't Scala aiming at something like that?
18:27:53 <SamB> I don't know too much about F# or Scala though...
18:28:04 <wli> I've not seen much of Scala.
18:28:18 <wli> Things leaning in the OO direction tend to escape my notice.
18:28:45 <sclv> yeah, i should probably play more with Scala. something about it turns me off a bit -- it looks much more like the functional end of multi-paradigm is downplayed.
18:28:48 <kpreid> most things on the JVM will lean in the OO direction :-)
18:29:16 <sharris> Yeah, I thought Cal was a lot "cleaner" though for some reason than Scala.  Take a look sometime at how Scala makes the a:as notation work out. Hint ":" isn't a constructor there, iirc
18:29:17 <kpreid> (not all. ABCL doesn't, to take an example I happen to be familiar with. generate a class per lambda, whee)
18:29:36 <sclv> When closures hit Java, it seems like it might take the wind out of scala quite a bit, although it has a reasonably solid userbase.
18:31:22 <wli> Sounds more like an if than a when, but anyhow.
18:32:42 <sharris> It's coming back to me about how Scala interpreted conses like "a:as".  It has pattern matching, so you'd think it's a constructor.  But really it's a method call on the "as" object.  All methods starting with ":" have prefix syntax.  Seemed to confusing/surprising to me.
18:33:54 <sjanssen> sharris: do you use the a:as syntax in pattern matching too?
18:34:25 <sharris> Yes you do.
18:34:50 <sharris> I guess that's why it was sortof surprising...
18:35:00 <sjanssen> yeah, how do you pattern match on a method call?
18:35:27 <dmwit> 1. Restrict pattern matching on methods to methods that are constructors.
18:35:30 <dmwit> 2. ???
18:35:36 <dmwit> 3. GHC!
18:35:39 <wli> More useful would be structural subtyping.
18:35:56 <sharris> I think the method call was just building the cons - I need to go look!
18:35:57 <wli> Starting from a functional base language.
18:36:29 <sjanssen> I should look at Scala
18:36:41 <wli> So that if a data type t had a subset of the alternatives available in t' then variables of type t would be usable wherever t' is required or some such.
18:39:20 <wli> With the analogous superset relation for record components.
18:39:28 <dmwit> Now that I'm finally learning what LL(k), LR(k), SLR(k), and LALR(k) mean (and how to implement parsers that accomplish them), I'm beginning to appreciate Parsec a lot more.
18:39:51 <sharris> PS: reason I haven't actually used Cal at work yet - the minimal support jar files are about 12Mb.
18:44:51 <sharris> Welp my memory was bad: apparantly Scala pattern matches like so on lists: case Cons(x, xs) => s.show(x) + ":" + show(xs)
18:44:57 <sharris> so the constructor is explicit...
18:45:43 <sclv> reading its docs again now.
19:33:17 <hpaste>  NicoReed pasted "(no title)" at http://hpaste.org/3403
19:33:45 <Nico_Reed> can someone help me figure out why this isnt compiling?
19:35:05 <Zao> Do something like  ns <- getNumb [] ; printme $ head ns
19:35:23 <LoganCapaldo> Nico_Reed: it would help if we knew what the error was
19:35:37 <Nico_Reed> i dont know how to copy it in from GHCi
19:35:53 <dmg_> @seen ndm
19:35:53 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 3d 2h 30m 50s ago, and .
19:36:06 <LoganCapaldo> but Zao is probbaly right
19:36:44 <Nico_Reed> @zao what is ns suppose to be? and what is the $ suppose to mean?
19:36:44 <lambdabot> Maybe you meant: faq map
19:36:47 <Zao> You have more severe issues though... nico.hs:12:27: Occurs check: cannot construct the infinite type: t = [t]
19:37:06 <dmwit> return (list ++ temp) -- order of operations, lol
19:37:15 <dmwit> Nico_Reed: ^^^^
19:37:54 <LoganCapaldo> dmwit: did you jsu lol @ the ordr of operations? :)
19:37:57 <dmwit> Also, printme probably has a different type than you were hoping for.
19:38:05 <sclv> Nico_Reed the $ operator is just function application but with low precedence. So you can do, for example, return $ list ++ temp
19:38:10 <Zao> $ is function application, but with low priority.
19:38:12 <sclv> and not need the parens
19:38:40 <dmwit> I would doubt very much if getNumb has the semantics you were looking for, either.
19:38:43 <Nico_Reed> ah i see so what exactly should i change other than the order of operations change
19:39:16 <dmwit> printme num = print num >> return num -- maybe?
19:40:13 <dmwit> getNumb list = do { ... else do { putStrLn "NO"; getNumb (num:list) } } -- probably
19:40:42 <dmwit> getNumb is probably nicer as a fold or map, somehow, though I don't see it right away, and I'm going to dinner.
19:40:44 <dmwit> Good luck!
19:40:54 <Nico_Reed> thanks
19:46:31 <Nico_Reed> Can someone explain the difference of : and ++?
19:46:41 <LoganCapaldo> lambdabot can!
19:46:46 <LoganCapaldo> @type (:)
19:46:48 <lambdabot> forall a. a -> [a] -> [a]
19:46:53 <LoganCapaldo> @type (++)
19:46:55 <lambdabot> forall a. [a] -> [a] -> [a]
19:47:14 <LoganCapaldo> [x] ++ list == x:list
19:47:40 <Nico_Reed> so ++ to fuse two lists but : to prepend a list with a single element?
19:47:50 <LoganCapaldo> yes
19:48:10 <LoganCapaldo> (except : is a constructor)
19:48:13 <LoganCapaldo> @src []
19:48:13 <lambdabot> data [] a = [] | a : [a]
19:48:14 <Nico_Reed> so ++ can replace : in all situations?
19:48:23 <LoganCapaldo> more like the other way around
19:48:32 <LoganCapaldo> ++ is written in terms of (:)
19:48:37 <LoganCapaldo> @src (++)
19:48:37 <lambdabot> (++) []     ys = ys
19:48:37 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
19:48:40 <shachaf> Nico_Reed: (++) is implemented in terms of (:).
19:48:53 <Nico_Reed> ah i see
19:49:34 <wli> O, for mplus to be (++) again.
19:49:38 <LoganCapaldo> A list is either the empty list [], or a value :'ed to the front of another list
19:49:54 <shachaf> Nico_Reed: In order to add an element to the end of the list, you have to walk the entire list.
19:50:07 <shachaf> wli: mplus or mappend?
19:50:35 <LoganCapaldo> I'd think you'd want it to be mplus
19:50:39 <wli> shachaf: Now I'm unsure.
19:50:42 <LoganCapaldo> @src [] mplus
19:50:43 <lambdabot> mplus = (++)
19:50:56 <LoganCapaldo> @src [] mappend
19:50:57 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:51:06 <LoganCapaldo> @type mappend
19:51:08 <lambdabot> forall a. (Monoid a) => a -> a -> a
19:51:17 <LoganCapaldo> mappend has the wrong kind
19:51:19 <LoganCapaldo> no?
19:51:29 <LoganCapaldo> err rather Monoid has the wrong kind
19:51:30 <shachaf> LoganCapaldo: mappend doesn't have a kind.
19:51:41 <shachaf> > [1] `mappend` [2]
19:51:42 <lambdabot>  [1,2]
19:51:47 <wli> shachaf: It was a monadic operation, not a monoidal one.
19:51:55 <Nico_Reed> is there an easy way to dump a list?
19:52:04 <shachaf> Nico_Reed: What do you mean by dump?
19:52:08 <shachaf> Nico_Reed: show?
19:52:10 <Nico_Reed> like print it out to the screen
19:52:54 <shachaf> Nico_Reed: print?
19:53:07 <shachaf> Nico_Reed: (Which is (putStrLn . show).)
19:53:18 <shachaf> Nico_Reed: Or just look at it in ghci, depending on what you want to do.
19:53:26 <Nico_Reed> uh.. i guess like each element is printed out to the screen.. so the output is [1,2,3]
19:54:07 <shachaf> Nico_Reed: What are you trying to do? Write a program that prints a list, or just look at the list yourself?
19:54:18 <geocalc> > [0..12] --voila
19:54:19 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12]
19:55:24 <LoganCapaldo> > [1..]
19:55:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
19:55:29 <Nico_Reed> well.. im trying to do the exersice is the Yet Another Haskell Tutorial.. the idea is to ask the users to type numbers until they type 0, and then it does a few operators on the whole list
19:55:37 <Nico_Reed> i dont know how to get the list
19:55:59 <shachaf> Nico_Reed: What do you mean by "get"?
19:56:55 <LoganCapaldo> @type get
19:56:57 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
19:57:17 <geocalc> in yaht they explain all you need Nico_Reed
19:57:29 <Tela> If you're getting them from some stdin, you'll want something like getContents
19:59:47 <LoganCapaldo> > runState $ put 1 >>= get
19:59:48 <lambdabot>        add an instance declaration for (MonadState (State s b) ((->) ()))
20:00:05 <LoganCapaldo> > runState $ put 1 >> get
20:00:06 <lambdabot>  <Integer -> (Integer,Integer)>
20:00:31 <LoganCapaldo> > runState $ put 1 >> get $ undefined
20:00:32 <lambdabot>        add an instance declaration for (MonadState (State s a) ((->) a1))
20:01:15 <geocalc> LoganCapaldo=<< don't confuse Nico_Reed
20:01:27 <Nico_Reed> actually.. i think i got it
20:01:32 <Nico_Reed> well not what he siad
20:01:33 <LoganCapaldo> I'm too busy confusing myself to confuse Nico_Reed
20:01:50 <geocalc> lol
20:02:21 <Nico_Reed> does haskell define a char and a string as different types?
20:03:21 <geocalc> you should re read yaht Nico_Reed
20:03:31 <Zao> String is [Char]
20:04:06 <Tela> > runState (put 1 >> get) undefined -- LoganCapaldo?
20:04:07 <lambdabot>  (1,1)
20:04:25 <shubalub> hi
20:04:36 <geocalc> hi
20:04:49 <LoganCapaldo> yeah what Tela said
20:07:48 <shachaf> How's the Haskell wikibook doing, someone? Is it in a recommendable condition?
20:08:45 <geocalc> what do you mean ?
20:09:07 <Tela> Is it possible to "define" undefined using something like unsafePerformIO?
20:09:16 <shachaf> If someone was learning Haskell, could I recommend the wikibook to them?
20:09:28 <shachaf> Tela: Yes.
20:09:31 <shachaf> @src undefined
20:09:31 <lambdabot> undefined =  error "Prelude.undefined"
20:09:33 <kpreid> Tela: it's easier: undefined = undefined
20:09:33 <shachaf> @src error
20:09:33 <lambdabot> error s = throw (ErrorCall s)
20:09:50 <shachaf> Hmm, that may not lead to it.
20:09:55 <kpreid> @src throw
20:09:56 <lambdabot> throw exception = raise# exception
20:10:01 <kpreid> @src raise#
20:10:01 <lambdabot> Source not found. I am sorry.
20:10:09 <geocalc> in first i think yaht shachaf
20:10:12 <shachaf> kpreid: I assumed Tela meant something as useful as undefined.
20:10:21 * shachaf doesn't like YAHT.
20:10:24 <kpreid> eh?
20:10:34 <Tela> kpreid I'm wondering about how you can mess with the type system more than just the trivial definition
20:10:37 <kpreid> well, I suppose it depends on whether your impl does <<loop>>
20:11:23 <shachaf> kpreid: That's true.
20:11:24 <geocalc> so do shachaf haskell tutorial ;)
20:11:38 <shachaf> Does ghci do <<loop>>, by the way?
20:11:48 <kpreid> Tela: Could you rephrase that question?
20:12:20 <kpreid> > last (cycle []) :: forall a. a
20:12:20 <lambdabot>  Parse error
20:12:25 <kpreid> > last (cycle []) :: a
20:12:28 <shachaf> I saw a definition of f :: a -> IO b some time ago.
20:12:37 <lambdabot>  Exception: Prelude.cycle: empty list
20:12:39 <Tela> kpreid Hmm... How about: how can you implement coerce :: a -> b using unsafePerformIO, since I keep hearing that's possible
20:12:57 <kpreid> Tela: you need IORefs as well as unsafePerformIO
20:13:32 <kpreid> both are, if I understand correctly, sound without the presence of the other
20:13:55 <Tela> Well, not just unsafePIO. I'm just curious to see what it takes to break the type system
20:14:20 <kpreid> well, you *can't* without those ingredients or similar ones
20:14:42 <Tela> Is there some page which says how you would using them?
20:14:44 <SamB> sorear implemented unsafeCoerce using generalized newtype deriving and associated types
20:15:51 <sorear> Tela: read the documentation for unsafeperformio
20:17:06 <Tela> Ohh... Didn't catch that before. You can sneak IORefs entirely outside of IO. Interesting.
20:17:47 <allbery_b> you can sneak IO entirely out of IO.  of course, this is a recipe for disaster
20:18:23 <Olathe> If you're making a Disaster library, it's great !
20:18:24 <allbery_b> there are a few valid uses of it (which many people consder evidence that haskell needs a formalized / better way to deal with it)
20:18:55 <Nico_Reed> Why doesn't "main = foldr (+) 0 [1,2,3,4]" compile? The error I am getting is along the lines of expected type 'IO a' against '[[t]] ->[t]'.
20:19:02 <Tela> I suppose that's kind of what I'm curious about — why would someone use it/why does it exist?
20:19:24 <kpreid> Nico_Reed: You want "main = print (foldr (+) 0 [1,2,3,4])"
20:19:31 <shachaf> Nico_Reed: Look at the type of main.
20:19:44 <allbery_b> Tela:  sometimes you need a shared / global reference.
20:19:49 <shachaf> A cheating way: main = return $ foldr (+) 0 [1,2,3,4]
20:20:04 <Olathe> O-o
20:20:08 <Olathe> srsly
20:20:09 <allbery_b> the only way to get one currently is "foo = unsafePerformIO (newIORef initialValue)"
20:20:12 <shachaf> (Right? main :: (Show a) => IO a, if a isn't (), prints it?)
20:20:32 <allbery_b> I thought main just discarded the result
20:20:37 <kpreid> shachaf: that's a ghc thing
20:20:51 <shachaf> kpreid: OK, I thought it probably would be.
20:20:59 <Nico_Reed> ah thanks you guys
20:21:04 <shachaf> Tela: You should use a REPL for simple experiments like that one, probably.
20:21:04 * kpreid thinks it's a thing that shouldn't be, but *shrug*
20:21:15 * shachaf agrees.
20:21:56 * kpreid idly wonders about the consequences of (>>) :: IO () -> IO a -> IO a
20:22:14 <kpreid> (and the same for do-notation)
20:22:25 <shachaf> kpreid: What consequences do you mean?
20:22:32 <kpreid> @type (>>)
20:22:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
20:22:54 <kpreid> well, people would have to write monadic code to explicitly discard nontrivial values
20:23:02 <kpreid> I wonder how much of a burden it would be
20:23:20 <kpreid> and whether any bugs would be caught by it
20:23:26 <shachaf> Oh, you mean, making (>>) more specific?
20:23:50 <kpreid> yes
20:23:59 * shachaf thought you were still talking about unsafePerformIO. :-)
20:24:52 <shachaf> How would that catch bugs?
20:26:23 <kpreid> hm -- I can't actually think of any examples
20:27:22 <shachaf> @ty (*>) -- (>>) should be this, though.
20:27:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
21:51:09 <hpaste>  ramza3 pasted "opengl callbacks" at http://hpaste.org/3404
23:08:45 <Taral> is (take N . sort) an efficient way of getting top N?
23:10:09 <TSC> It's certainly efficient in programming time (:
23:10:39 <Taral> yes, but is (take N $ sort l) take time O(length l * log N)?
23:10:47 <Taral> er, does, not is.
23:10:53 <TSC> Depends on the sort
23:10:59 <Taral> Prelude.sort
23:11:08 <TSC> I'm not sure how the standard Data.List.sort is implemented
23:11:12 <Taral> bah!
23:11:18 <TSC> (or if it can vary between implementations)
23:11:32 <ddarius> It can definitely vary between implementations
23:11:32 <sjanssen> Taral: it's implemented as merge sort
23:11:44 <sorear> TSC: sure it can vary! after all, the standard uses insertion sort
23:11:50 <sorear> @src sortBy
23:11:50 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
23:12:01 <Taral> ouch.
23:12:16 <Taral> that's mad.
23:12:24 <Taral> @src insertBy
23:12:24 <lambdabot> insertBy _   x [] = [x]
23:12:24 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
23:12:24 <lambdabot>                                  GT -> y : insertBy cmp x ys'
23:12:24 <lambdabot>                                  _  -> x : ys
23:15:16 <dmwit> Taral: take n . sort is O(n+l*log(l)) in GHC, where l is the length of the list.
23:16:16 <Taral> are you sure?
23:16:34 <dmwit> ...no
23:16:37 <Taral> nor am I.
23:16:41 <sclv> if you want stream based -- i.e. lazy or online sorting, then insertion sort or a variant thereof is sort of your only bet though.
23:16:44 <Taral> I suppose I could run some tests.
23:16:48 <Pseudonym> I think it's actually O(l log n)
23:16:52 <Pseudonym> Not 100% certain.
23:17:14 <sclv> insertion sort is also very fast on a list already largely sorted.
23:18:07 <nornagon> but still O(n), yes?
23:18:14 <Taral> O(n^2)
23:18:18 <nornagon> ah
23:18:31 <nornagon> i'm thinking of inserting something into an already-sorted list
23:18:33 <Taral> depends on how you define "already largely sorted"
23:18:42 <nornagon> which is O(n)
23:18:52 <Taral> insertion sort is O(n * k) where k is the number of elements "out of place".
23:19:54 <sclv> the haskell libs are all by datatype -- i'm starting to think there should be algorithm libs too.
23:20:14 <Taral> like STL has?
23:20:18 <Taral> that would be nice.
23:20:24 <Taral> STL has partial_sort, which is exactly what I need.
23:20:33 <sclv> with decent implementations of your standard sort functions, tree functions, diff functions even.
23:20:41 <Taral> and it's guaranteed to be O(l log n) [usually written n log k]
23:21:18 <Pseudonym> Which, incidentally, is suboptimal.
23:24:16 <luqui> it slightly bugs me that take k . sort is O(n) for all k
23:24:34 <Pseudonym> Why?
23:24:40 <Pseudonym> You've got to inspect every element.
23:24:51 <luqui> no, i mean, is as low as O(n) for all k
23:25:01 <luqui> i.e. take 1000000000000000 . sort is still O(n) :-)
23:25:07 <yrlnry_> All fixed k.
23:25:11 <Pseudonym> O(n + k log k)
23:25:22 <luqui> oh really?
23:25:26 <Pseudonym> Or O(n + k log (n-k))
23:25:27 <yrlnry_> Sure.
23:25:33 <Pseudonym> Well, think of it this way.
23:25:40 <Pseudonym> Kolmogorov-Chaitin complexity theory 101.
23:25:40 <yrlnry_> To find the median element of the list is O(n log n).
23:25:55 <yrlnry_> That has k=n/2.
23:26:03 <Pseudonym> To "read" a number n, requires log n bits, right?
23:26:04 <dmwit> ...which is not a fixed k.
23:26:11 <Pseudonym> That's basic information theory.
23:26:12 <yrlnry_> Yes, that's my point.
23:26:28 <dmwit> Oh, right, I'm mixing up you and luqui.
23:26:41 <Pseudonym> Now.  The number of size-k permutations from a set of length n is n! / (n-k)!
23:26:56 <Pseudonym> So to "read" which permutation it is requires log(n! / (n-k)!) bits of information.
23:27:02 <Pseudonym> Each comparison gives you one bit.
23:27:05 <Pseudonym> Therefore:
23:27:17 <Pseudonym> O(log(n! / (n-k)!))
23:27:33 <Pseudonym> = O(log n! - log (n-k)!)
23:27:45 <Pseudonym> ~= O(n log n - (n-k) log (n-k))
23:27:59 <luqui> I think I understand that argument
23:28:02 <wli> Alternatively, note that it's a degree k polynomial in n.
23:28:03 <Pseudonym> = O(n (log n - log (n-k)) + k log (n-k))
23:28:20 <Pseudonym> = O(n log (n/(n-k)) + k log (n-k))
23:28:37 <Pseudonym> Now, because 0 <= k <= n, log (n/(n-k)) is bounded.
23:28:49 <Pseudonym> And hence is O(1).
23:28:51 <Pseudonym> Therefore:
23:28:57 <Pseudonym> = O(n + k log (n-k))
23:29:02 <Pseudonym> QED
23:29:32 <Taral> well, it's hard to tell on the sort because the GC gets in the way of large numbers of elements
23:29:47 <Pseudonym> You can, of course, get more anal about constant factors and crap like that.
23:42:27 <hpaste>  ramza3 pasted "Bad coding?" at http://hpaste.org/3405
23:42:58 <bbrown> is that a bad approach, eg if I call the moveCamera function with; moveCamera 1 0.4  for example
23:43:13 <dmwit> Not bad, but consider something like
23:43:20 <yrlnry_> I think it's a bad approach.
23:43:21 <dmwit> data Motion = Left | Right | Up | Down
23:43:26 <yrlnry_> Yeah.
23:43:28 <Pseudonym> Nope.
23:43:32 <Pseudonym> :t Left
23:43:35 <lambdabot> forall a b. a -> Either a b
23:43:39 <Pseudonym> Perhaps L | R | U | D
23:43:40 <dmwit> ouch
23:43:49 <bbrown> you guys are on top of it, thanks
23:44:47 <bbrown> yrlnry_, what about the function itself
23:45:08 <dmwit> It seems okay, but I find two things mildly surprising:
23:45:21 <dmwit> 1. There's no "forward" and "backward" -- but maybe you don't need them.
23:45:59 <dmwit> 2. It seems like you could factor the actual motion calculation into something like move :: (Double, Double, Double) -> Camera -> Camera
23:46:36 <dmwit> Then you could have something like
23:46:46 <bbrown> thought this approach would be easier for some reason
23:46:55 <dmwit> moveCamera U dpos = move (0, 0, dpos) -- pretty readable
23:47:24 <bbrown> that doesn't modify the position, only sets it
23:47:38 <dmwit> hmm?
23:47:43 <bbrown> hold on, nevermind
23:47:48 <hpaste>  Pseudonym annotated "Bad coding?" with "(no title)" at http://hpaste.org/3405#a1
23:48:00 <Pseudonym> Erm.
23:48:07 <Pseudonym> s/Y/Z/
23:48:10 <Pseudonym> But apart from that...
23:48:13 <shubalub> is getHostByName "www.google.com" supposed to fart and die?
23:48:13 <Taral> @src index
23:48:14 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
23:48:45 <bbrown> Pseudonym, I got the approach, thanks; and I think dmwit is on to a cleaner approach as well
23:48:45 <Pseudonym> dmwit: I can understand why you might want to not add 0 if you don't need to.
23:48:49 <shubalub> HostEntry {hostName = "www.l.google.com", hostAliases = ["www.google.com"], host
23:48:49 <shubalub> Family = *** Exception: Network\Socket.hsc:(1535,17)-(1624,13): Non-exhaustive p
23:48:49 <shubalub> atterns in case
23:49:04 <dmwit> shubalub: No, I get a real answer.
23:49:14 <shubalub> huh
23:49:18 <shubalub> guess I'm doing something wrong
23:49:26 <dmwit> Pseudonym: Ah, good point.
23:50:07 <dmwit> shubalub: I haven't done anything special, just "ghci, :m + Network.BSD, getHost...".  So maybe you have something broken on your system, or there is a bug in the version you're using?
23:51:55 <shubalub> everything else works fine...so either my install is broken or I have a buggy version
23:52:14 <shubalub> now that I think about it, how much testing does GHC get on windows?
23:52:26 <dmwit> shubalub: Have you tried calling the equivalent function from C?
23:52:36 <dmwit> Maybe the problem is lower-level than GHC. (?)
23:52:47 <hpaste>  Pseudonym annotated "Bad coding?" with "Avoiding the addition" at http://hpaste.org/3405#a2
23:53:05 <shubalub> Pinging www.l.google.com [64.233.169.104] with 32 bytes of data:
23:53:18 <Pseudonym> Erm/
23:53:31 <Pseudonym> Again, s/adjCameraY/move/
23:53:43 <shubalub> so I don't have a networking problem (well I do, but not atm)
23:53:44 * dmwit wonders whether (id $) is really less expensive than (+ 0).
23:53:57 <Pseudonym> dmwit: At high optimisation levels, yes.
23:53:59 <Pseudonym> Well...
23:54:07 <Pseudonym> OK, it's not necessarily less expensive.
23:54:10 <dmwit> You still have to make an entire thunk for it, right?
23:54:11 <Pseudonym> But it can be optimised away.
23:54:21 <Pseudonym> Note the INLINE directive!
23:54:30 <dmwit> hahaha
23:54:31 <dmwit> ok
23:54:46 <Pseudonym> In general, you can't optimise floating-point operations away.
23:54:53 <Pseudonym> Only constant arithmetic and redundant casts.
23:55:14 <Pseudonym> Even (x+0) is meaningful.
23:55:31 <dmwit> Oh, really?  When is x+0 /== x?
23:55:49 <Pseudonym> I believe that (-0) + 0 /= (-0)
23:55:54 <Pseudonym> Or something like that.
23:55:57 <ddarius> > (-0) + 0
23:56:02 <lambdabot>  0
23:56:05 <Pseudonym> > -0
23:56:06 <ddarius> > (-0) + 0 :: Double
23:56:06 <lambdabot>  0
23:56:08 <lambdabot>  -0.0
23:56:14 <Pseudonym> Hmmm.
23:56:17 <dmwit> > (-0::Double) + 0 == (-0)
23:56:18 <lambdabot>  True
23:56:28 <ddarius> > 1/0 + 0 :: Double
23:56:30 <lambdabot>  Infinity
23:56:36 <Pseudonym> > (0 :: Double) + (-0)
23:56:38 <lambdabot>  -0.0
23:56:38 <dmwit> ?check \x -> x::Double+0 == x
23:56:38 <lambdabot>  Parse error
23:56:44 <ddarius> > 0/0 + 0 :: Double
23:56:45 <Pseudonym> > (-0) + (-0)
23:56:46 <lambdabot>  NaN
23:56:47 <lambdabot>  0
23:56:51 <Pseudonym> > (-0) - (-0)
23:56:53 <lambdabot>  0
23:56:55 <Pseudonym> > (-0) - (+0)
23:56:56 <lambdabot>   add an instance declaration for (Num (a -> a))
23:56:56 <lambdabot>     In the expression: (- 0)...
23:57:03 <Pseudonym> > (-0) - (+0 :: Double)
23:57:03 <lambdabot>  Parse error
23:57:04 <ddarius> You need type annotations.
23:57:09 <Pseudonym> > (-0) - (0 :: Double)
23:57:11 <lambdabot>  -0.0
23:57:14 <Pseudonym> Hmmm.
23:57:23 <Pseudonym> Maybe it requires affine mode turned on or something.
23:57:27 <ddarius> Pseudonym: Just have the whole expression be double, it's easier to type.
23:57:42 * Pseudonym can't remember, but there's a corner case here with affine zeroes
23:58:16 <Pseudonym> > -0.0 + -0.0
23:58:16 <lambdabot>      precedence parsing error
23:58:17 <lambdabot>         cannot mix `(+)' [infixl 6] and prefix ...
23:58:25 <Pseudonym> > (-0.0) + (-0.0)
23:58:25 <dmwit> ?check \x -> x + 0 == x :: Double
23:58:27 <lambdabot>  Couldn't match expected type `Double' against inferred type `Bool'
23:58:27 <lambdabot>  -0.0
23:58:33 <dmwit> ?check \x -> x + 0 == (x :: Double)
23:58:35 <lambdabot>  OK, passed 500 tests.
23:58:39 <Pseudonym> :-)
23:58:53 <ddarius> dmwit: @check isn't too useful for this question
23:58:54 <Pseudonym> Unforutnately, QuickCheck isn't an IEEE-754 conformance checker.
23:58:55 <dmwit> yeah
23:59:02 <dmwit> =(
23:59:14 <Pseudonym> I forget the details, but I do remember reading a paper on optimisation and IEEE-754.
23:59:29 <Pseudonym> And essentially, there are only two optimisations that you can do safely.
23:59:40 <Pseudonym> > (0/0 - 0.0/0)
23:59:41 <lambdabot>  NaN
23:59:45 <Pseudonym> > (0/0 - 0.0/0) + 0
23:59:46 <lambdabot>  NaN
23:59:50 <Pseudonym> Aha!
