00:02:27 <dataangel> Is there a way to iterate through a list with a list comprehension, but also get an index for the current item? Like enumerate in python
00:03:18 <misterbeebee_> @check  \x -> length x  /=  length (transpose x)  ||  length (nub (map length x)) /= 1 || (transpose . transpose) x == (x::[[Int]])
00:03:20 <lambdabot>  OK, passed 500 tests.
00:04:09 <mauke> dataangel: zip [0 ..]
00:04:13 <misterbeebee_> >   let myList =  "blah" in zip [0...]   myList
00:04:13 <lambdabot>  Parse error
00:04:15 <dataangel> nm I got it
00:13:09 <DJ-DrIP[AR]> hai all, i need libreadline.so.4
00:13:20 <dataangel> I have a unary function that takes a list and returns list, and I want it to be applied to a list n times. It sounds like a fold except the function is unary...
00:13:43 <misterbeebee_> dataangle: example?
00:13:48 <DJ-DrIP[AR]> meh
00:13:48 <DJ-DrIP[AR]> nvm
00:14:01 <misterbeebee_> > take 5 $ iterate (map  (1+)) [2,3,4,5]
00:14:02 <mauke> :t (foldr (.) id .) . replicate
00:14:08 <lambdabot> forall a. Int -> (a -> a) -> a -> a
00:14:10 <lambdabot>  [[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9]]
00:14:38 <mauke> > ((foldr (.) id .) . replicate) 5 (map succ) [2 .. 5]
00:14:39 <lambdabot>  [7,8,9,10]
00:14:55 <dataangel> mauke: That looks incredibly obfuscated compared to misterbee's version :P
00:15:35 <mauke> > iterate (map succ [2 .. 5]) !! 5
00:15:35 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[a1]'
00:15:46 <mauke> > iterate (map succ) [2 .. 5] !! 5
00:15:48 <lambdabot>  [7,8,9,10]
00:15:50 <mauke> better?
00:18:08 <mauke> sub { my ($n, $f) = @_; sub { (reduce { my ($g, $h) = ($a, $b); sub { $g->($h->(shift)) } } id, ($f) x $n)->shift } }
00:21:07 <hpaste>  dataangel pasted "another newb compile problem. help? :)" at http://hpaste.org/3110
00:22:28 <mauke> reversed arguments?
00:25:29 <misterbeebee_> shiftLeftN x n = ((iterate shiftLeft) x)  !! n  -- is this what you mean?
00:26:40 <dataangel> misterbeebee_: Yes
00:27:39 <dataangel> misterbeebee_: oh... OH.... iterate is an interesting function @_@
00:27:44 <dataangel> I was misunderstanding what it did
00:28:00 <mauke> :t iterate
00:28:02 <lambdabot> forall a. (a -> a) -> a -> [a]
00:28:03 <dataangel> take higher elements from the produced list to apply the function more times
00:28:20 <misterbeebee_> iterate f n = f^n (in math notation
00:28:32 <mauke> iterate f x = x : iterate f (f x)
00:28:56 <dataangel> I just looked up the def in the prelude :)
00:28:59 <dataangel> sweetness
00:29:01 <misterbeebee_> I retract my previous statement
00:29:12 <mauke> @src (!!)
00:29:12 <lambdabot> xs     !! n | n < 0 = undefined
00:29:12 <lambdabot> []     !! _         = undefined
00:29:12 <lambdabot> (x:_)  !! 0         = x
00:29:12 <lambdabot> (_:xs) !! n         = xs !! (n-1)
00:29:15 <misterbeebee_> don't need prelude.
00:29:18 <dataangel> but why doesn't my def work? ;p
00:29:23 <misterbeebee_> @src iterate
00:29:23 <lambdabot> iterate f x =  x : iterate f (f x)
00:29:49 <misterbeebee_> :t foldr
00:29:51 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
00:30:01 <mauke> dataangel: because an Int is not a list
00:30:43 <mauke> wait, now I'm confusing myself
00:30:58 <misterbeebee_> your "spacefiller" list [0..n] is [Int] ...   replicate n [0]   should work in place of [0..n]
00:31:22 <misterbeebee_> @let shiftLeft = (tail x) ++ [head x]
00:31:23 <lambdabot> <local>:13:18: Not in scope: `x'  <local>:13:30: Not in scope: `x'
00:31:51 <misterbeebee_> @let shiftLeft = \x -> (tail x) ++ [head x]
00:31:57 <lambdabot> Defined.
00:32:09 <mauke> dataangel: a is the current list element
00:32:19 <misterbeebee_> @let shiftLeftN = foldr (\a b -> shiftLeft a) x (replicate n [])
00:32:20 <lambdabot> <local>:14:41: Not in scope: `x'  <local>:14:54: Not in scope: `n'
00:32:38 <misterbeebee_> @let shiftLeftN x n = foldr (\a b -> shiftLeft a) x (replicate n [])
00:32:41 <mauke> why []?
00:32:44 <lambdabot> Defined.
00:32:51 <mauke> just use () or undefined
00:32:59 <misterbeebee_> > shiftLeftN [1,2,3,4] 2
00:33:00 <lambdabot>  Exception: Prelude.tail: empty list
00:33:04 <misterbeebee_> d'oh
00:33:34 <misterbeebee_> I'm wrong.
00:33:46 <misterbeebee_> @src foldr
00:33:46 <lambdabot> foldr k z xs = go xs
00:33:46 <lambdabot>     where go []     = z
00:33:46 <lambdabot>           go (y:ys) = y `k` go ys
00:34:29 <misterbeebee_> @let shiftLeftN' x n = foldr (\b a -> shiftLeft a) x (replicate n ())
00:34:35 <lambdabot> Defined.
00:34:38 <misterbeebee_> shiftLeftN' [1,2,3,4] 2
00:34:48 <misterbeebee_> > shiftLeftN' [1,2,3,4] 2
00:34:49 <lambdabot>  [3,4,1,2]
00:35:01 <misterbeebee_> mauke was right... the "\a b" was backwards
00:35:21 <misterbeebee_> I mistakenly though that the [0...n] had to be changed to [ List ], but that was irrelevant
00:35:23 <dataangel> misterbeebee_: I follow :)
00:36:04 <misterbeebee_> but the takehome point is : when you are making up dummy data to fill places, there's a better way to solve your problem
00:38:39 <dataangel> why is it ((iterate shiftLeft) x) rather than (iterate (shiftLeft x))?
00:39:06 <misterbeebee_> :t iterate
00:39:09 <lambdabot> forall a. (a -> a) -> a -> [a]
00:39:11 <misterbeebee_> :t shiftLeft
00:39:13 <lambdabot> Not in scope: `shiftLeft'
00:39:30 <misterbeebee_> iterate takes (a -> a) as its first argument
00:39:36 <misterbeebee_> shiftLeft is a->a
00:39:53 <dataangel> @src iterate
00:39:54 <lambdabot> iterate f x =  x : iterate f (f x)
00:40:09 <misterbeebee_> or to put it another way, (shiftLeft x) is a list, not a function, but iterate wants a list
00:40:20 <misterbeebee_> er, iterate wants a *function*, of course
00:41:16 <misterbeebee_> if you apply the (unary) function to an input, then in the result there's no compuation left to iterate.
00:42:24 <dataangel> wouldn't (iterate (shiftLeft) x) work?
00:42:35 <mauke> sure
00:42:36 <dataangel> because it wants both args
00:42:44 <mauke> or simply: iterate shiftLeft x
00:44:05 <misterbeebee_> yep yep, all the same, function application associates to the left.  f a b === (f a) b == f (a) b == (f (a) b)
00:44:27 <mauke> == (((f) (a)) (b))
00:44:29 <misterbeebee_> !== f (a b)
00:44:37 <dataangel> if I want to iterate over a list but keep an index, do I do [ stuff | elem <- mylist, i <- length mylist] ?
00:44:50 <mauke> no
00:44:54 <misterbeebee_> never use length, it won't work on infinite lists
00:45:04 <mauke> [ stuff | (i, x) <- zip [0 ..] mylist ]
00:45:16 <mauke> a.k.a. zipWith stuff [0 ..] mylist
00:45:28 <dataangel> Will [ stuff | elem <- mylist, i <- [0..]] work the same?
00:45:45 <mauke> no
00:46:03 <misterbeebee_> list comprehensions do "cross product", not "dot product"
00:46:13 <mauke> [ (i, x) | x <- "foobar", i <- [0 ..] ]
00:46:15 <mauke> > [ (i, x) | x <- "foobar", i <- [0 ..] ]
00:46:23 <lambdabot>  [(0,'f'),(1,'f'),(2,'f'),(3,'f'),(4,'f'),(5,'f'),(6,'f'),(7,'f'),(8,'f'),(9,...
00:46:45 <dataangel> > [(x,y) | x <- [1,3,5], y <- [2,4,6]]
00:46:46 <lambdabot>  [(1,2),(1,4),(1,6),(3,2),(3,4),(3,6),(5,2),(5,4),(5,6)]
00:47:07 <dataangel> whoa it does combinations @_@
00:47:09 <mauke> > sequence [[1,3,5],[2,4,6]]
00:47:10 <lambdabot>  [[1,2],[1,4],[1,6],[3,2],[3,4],[3,6],[5,2],[5,4],[5,6]]
00:47:14 <dataangel> that is not what I would have expected
00:47:25 <mauke> dataangel: think of it as a nested foreach loop
00:47:27 <dataangel> or well I guess that makes sense -- nested loops
00:47:30 <dataangel> beat me to it :
00:47:31 <dataangel> :)
00:47:47 <misterbeebee_> > let f = "abcdefgh" in [ (i, x !! i)  | x,  i <- [0..] ]
00:47:48 <lambdabot>   Not in scope: `x'
00:47:59 <misterbeebee_> > let x =  "abcdefgh" in [ (i, x !! i)  | x,  i <- [0..] ]
00:48:00 <lambdabot>  Couldn't match expected type `Bool' against inferred type `[Char]'
00:48:24 <misterbeebee_> > let x =  "abcdefgh" in [ (i, x !! i)  |  i <- [0..]]
00:48:26 <lambdabot>  Exception: Prelude.(!!): index too large
00:48:34 <misterbeebee_> annoying.
00:48:44 <mauke> > zip [0 ..] ['a' .. 'h']
00:48:45 <lambdabot>  [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h')]
00:48:58 <misterbeebee_> yeah, but I was trying to do it in comprehension syntax
00:49:32 <mauke> > [ (i, x) | x <- "foobar" | i <- [0 ..] ]
00:49:32 <lambdabot>  Parse error
00:49:40 <mauke> needs ghc extensions
00:50:39 <misterbeebee_> zip is better, anyway
00:51:04 <misterbeebee_> mkIndexed = zip [0..] -- should be in Prelude or Data.List
00:51:26 <mauke> nah
00:51:41 <mauke> zip [0..] is obviouser
00:52:34 <mauke> > filterM (const [True,False]) [0 .. 3]
00:52:36 <lambdabot>  [[0,1,2,3],[0,1,2],[0,1,3],[0,1],[0,2,3],[0,2],[0,3],[0],[1,2,3],[1,2],[1,3]...
00:53:27 <ac> is there a "map" of type :: (a -> b -> c) -> [a] -> [b] -> [c]?
00:53:38 <mauke> :t zipWith
00:53:40 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
00:53:49 <ac> guess I should have hoogled that
00:53:58 <mauke> see also: hoogle
00:55:00 <dataangel> Is there a painless way to generate random numbers, or is that going to go into monad territory?
00:55:12 <dataangel> I just want to fill up my 5x5 grid with some random numbers
00:55:28 <mauke> :t randomIO
00:55:30 <lambdabot> forall a. (Random a) => IO a
00:55:42 <mauke> that'll give you a random number (in IO)
00:55:47 <dataangel> right
00:55:59 <dataangel> can I use that to make a list from the REPL?
00:57:32 <mauke> x <- replicateM 5 (replicateM 5 randomIO)
00:57:32 <ac> > let strm = randoms (mkStdGen 10) :: [Int]
00:57:33 <lambdabot>  Parse error
00:57:46 <ac> @let strm = randoms (mkStdGen 10) :: [Int]
00:57:51 <lambdabot> Defined.
00:57:56 <ac> > take 10 strm
00:57:57 <lambdabot>  [-1258130923,-870666468,433432625,-1228884604,793723731,1488653119,609706456...
00:58:09 <mauke> :t replicateM 5 (replicateM 5 randomIO)
00:58:09 <ac> dataangel: and that's pure
00:58:11 <lambdabot> forall a. (Random a) => IO [[a]]
00:58:21 <mauke> ac: it's also constant
00:58:32 <mauke> you could just paste that list into your program
00:58:58 <ac> yep. And you could also mkStdGen foo
01:00:03 <nornagon> > take 10 strm
01:00:04 <lambdabot>  [-1258130923,-870666468,433432625,-1228884604,793723731,1488653119,609706456...
01:00:24 <nornagon> i wrote a random number monad a while ago
01:00:34 <nornagon> i think it was very similar to State
01:00:45 <nornagon> but you could pull random numbers out whenever you needed
01:02:08 <takamura> hello
01:02:15 <quicksilver> nornagon: Cale wrote one too :)
01:02:20 <quicksilver> @go MonadRandom
01:02:22 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
01:02:22 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
01:02:41 <quicksilver> nornagon: In the past I've just use 'State StdGen' or 'RandomGen g => State g'
01:02:48 <quicksilver> (or StateT)
01:03:24 <nornagon> ah, heh :)
01:06:43 <misterbeebee_> g'night all. microsoft puzzlehunt tomorrow morning
01:07:11 <dataangel> ac: How do I get mkStdGen?
01:07:30 <quicksilver> import System.Random
01:07:35 <ac> dataangel: System.Random
01:07:42 <quicksilver> or :m +System.Random (in ghci)
01:07:53 <ac> @hoogle mkStdGen
01:07:57 <lambdabot> Random.mkStdGen :: Int -> StdGen
01:08:08 <quicksilver> @index mkStdGen
01:08:08 <lambdabot> System.Random
01:08:19 <ac> quicksilver: ahah. new command
01:08:29 <quicksilver> not new :)
01:08:36 <ac> (for me of course)
01:08:42 <quicksilver> ah :)
01:09:05 <Tac-Tics> > gen <- mkStdGen
01:09:05 <lambdabot>  Parse error
01:09:13 <dataangel> To constrain the range should I just modulo?
01:09:26 <quicksilver> dataangel: randomR
01:09:31 <quicksilver> :t randomR
01:09:36 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
01:09:41 <Tac-Tics> > mkStdGen >>= \gen -> putStrLn $ (randomR gen (1, 3) :: IO Int)
01:09:42 <lambdabot>  Couldn't match expected type `(a, a)'
01:09:54 <quicksilver> > randomR (1,5) (mkStdGen 15)
01:09:59 <lambdabot>  (4,640224 40692)
01:10:05 <Tac-Tics> bah
01:10:06 <dataangel> hrm
01:10:08 <quicksilver> Tac-Tics: no IO in lambdabot :P
01:10:12 <Tac-Tics> but but
01:10:15 <Tac-Tics> I wants it
01:10:19 <quicksilver> or 'randomRs' for a list of them
01:10:21 <quicksilver> :t randomRs
01:10:23 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
01:10:29 <quicksilver> > randomRs (1,5) (mkStdGen 15)
01:10:30 <lambdabot>  [4,1,1,2,3,5,2,4,5,3,1,3,1,3,5,3,2,5,1,3,4,1,3,5,1,1,2,5,4,3,5,2,2,4,1,3,3,5...
01:10:32 <quicksilver> (infinite list)
01:13:22 <dataangel> How is strm = randoms (mkStdGen 10) :: [Int] pure? Why doesn't that need any monad magic?
01:13:37 <vincenz> moin
01:13:41 <ac> dataangel: it's a pseudorandom generator
01:13:46 <ac> dataangel: they're not random at all
01:13:49 <nornagon> dataangel: mkStdGen 10 seeds the generator
01:13:54 <nornagon> when you use the same seed
01:13:54 <dataangel> oh good point :P
01:13:57 <nornagon> you get the same numbers
01:14:07 <dataangel> but that's OK as long as you don't take the same index twice
01:14:21 <nornagon> well
01:14:32 <ac> dataangel: unless you're doing cryptography
01:14:32 <nornagon> you'd want to generate a new seed for each run of your program, probably
01:14:39 <nornagon> otherwise things work the same way every time
01:14:43 <serishema> so strm x = randoms (skStdGen x) :: [Int] would be impure?
01:14:46 <dataangel> for just getting some random test data for the moment it will work fine ;p
01:14:51 <dataangel> but to use the time as the seed you'd need a monad, yes?
01:14:51 * serishema lurks here sometimes because she thinks she might learn something as a result.
01:15:05 <nornagon> serishema: nope
01:15:16 <nornagon> serishema: that'd just let you give it the seed when you call it
01:15:32 <serishema> oh, but it's pure because x can't change as soon as it's called?
01:15:39 <nornagon> it's not really possible to represent impure code without IO
01:15:47 <nornagon> disregarding unsafePerformIO
01:16:09 <dataangel> is unsafePerformIO standard or GHC specific?
01:16:16 <serishema> i see.
01:16:40 <nornagon> er, good question
01:16:45 <nornagon> @index unsafePerformIO
01:16:45 <lambdabot> System.IO.Unsafe, Foreign
01:17:09 <nornagon> @docs unsafePerformIO
01:17:09 <lambdabot> unsafePerformIO not available
01:17:26 <nornagon> @docs System.IO.unsafePerformIO
01:17:26 <lambdabot> System.IO.unsafePerformIO not available
01:17:33 <nornagon> @docs System.IO
01:17:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
01:18:10 <nornagon> oops, i'm silly
01:18:14 <nornagon> @docs System.IO.Unsafe
01:18:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html
01:22:28 <dataangel> If I have a square grid (list of lists), how can I print it prettily?
01:25:48 <mauke> print grid
01:26:03 <aleator_> mapM print?
01:26:26 <dataangel> mapM print did the trick
01:26:38 <dataangel> but for some reason it sticks [(),(),(),(),(),(),(),(),()] on the bottom
01:26:40 <dataangel> why is that?
01:26:43 <aleator_> or rather mapM_ print.
01:27:01 <aleator_> those are return values of print function.
01:28:54 <Cale> dataangel: ghci tends to print the result of IO actions after carrying out their side effects
01:29:28 <dataangel> ah
01:30:07 <Cale> mapM (\x -> print x >> getLine) [1..3]
01:32:44 * dons waves from hackathon day 2
01:32:47 <dons> we got lambdas!
01:35:21 <vincenz> dons: you're wearing a monad, not a lambda, it's less pure!
01:37:47 <dons> not all monads are impure
02:19:40 <suppaman> hello
02:20:10 <dons> hey suppaman
02:25:47 <Mr_Awesome> when using the State monad, is it customary to give your monadic functions type b -> State s a or type b -> s -> (s, a) ?
02:26:25 <mauke> the former
02:26:56 <dons> and to name your State monad also
02:27:55 <Mr_Awesome> but then how can i get access to the state within my function? do i have to do f x = State \s -> ... ?
02:28:45 <EvilTerran> is there a function hiding somewhere that does IO () -> FunPtr (IO ())?
02:34:14 <Mr_Awesome> oh right. get and put
02:35:03 <mudge> hello
02:35:10 <mudge> I'm trying to use the Network library
02:35:38 <mudge> I did:  import Network,  but GHCi is saying " Could not find module `Network'"
02:35:46 <mudge> anyone know why?
02:36:25 <mudge> how do I import Network?
02:36:43 <kolmodin> mudge: do you have the network package installed?
02:36:50 <kolmodin> ghc-pkg list network
02:39:21 <mudge> doesn't look like it
02:40:09 <mudge> how do you install a package?
02:43:29 <mudge> how would I go about installing the Network library?
02:48:48 <LeCamarade> Comrades, how do I leverage the Control.Parallel.Strategies strategies in impure calls (which are the most-likely to need par, anyway), without going all unsafePerformIO?
02:51:54 <mnislaih> go to http://flickr.com/photos/pepeiborra for some live Hackathon coverage
02:51:55 <lambdabot> Title: Flickr: Photos from pepeiborra
02:55:37 <LeCamarade> Oh. Looks like Control.Concurrent.mergeIO does just fine. :o)
03:01:13 <LeCamarade> conal:  You're at Hac?
03:01:21 <LeCamarade> Saw your pics on dons' blog. :o)
03:02:28 <conal> LeCamarade: yes.  having a great time
03:02:41 <LeCamarade> Nice laptop thing, there. ;o)
03:02:55 <conal> thanks.
03:03:12 <LeCamarade> Comrades, if I want to thread actions, could I possibly do it sans unsafePerformIO?
03:04:32 <EvilTerran> forkIO?
03:05:24 <EvilTerran> sounds like a job for Control.Concurrent to me, anyway
03:06:32 <LeCamarade> Yeah, I am using C.Conc. But ...
03:06:45 <LeCamarade> Does, for example, nmerge eval IO actions in the lists.
03:06:46 <LeCamarade> ?
03:07:11 <LeCamarade> My func, which is supposed to abstract that, looketh like:
03:07:53 <LeCamarade> spawnList them = unsafePerformIO $ nmerge [them]
03:08:05 <LeCamarade> Even if I remove the unsafe ...
03:08:34 <LeCamarade> Will nmerge actually perform the actions in +them+ in parallel?
03:08:54 <EvilTerran> nmerge doesn't do IO in the list elements, AFAIK
03:09:01 <LeCamarade> :o(
03:09:07 <EvilTerran> just sparks 'em to WHNF
03:09:15 <LeCamarade> I may have to write my nmergeIO?
03:09:27 <LeCamarade> WHNF, WTF?
03:09:32 <LeCamarade> @dict whnf
03:09:32 <lambdabot> Supported dictionary-lookup commands:
03:09:32 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
03:09:32 <lambdabot> Use "dict-help [cmd...]" for more.
03:09:46 <LeCamarade> :o(
03:10:02 <xerox> ?foldoc whnf
03:10:03 <EvilTerran> what do you want, :: [IO a] -> IO [a] that runs every element concurrently and assembles the output list in the order the actions finish?
03:10:04 <lambdabot> *** "whnf" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
03:10:04 <lambdabot> WHNF
03:10:04 <lambdabot>  
03:10:04 <lambdabot>         {weak head normal form}
03:10:04 <lambdabot>  
03:10:43 <LeCamarade> EvilTerran: Yes. I want to perform in parallel.
03:11:02 <LeCamarade> Use par and seq?
03:11:35 <EvilTerran> par and seq don't do IO either
03:12:49 <LeCamarade> So that leaves me with The Dragons, no? forkIO?
03:12:58 <EvilTerran> (print "foo" `seq` print "bar") won't print foo, only bar
03:14:31 <EvilTerran> forcing something of type IO <whatever> doesn't run it; only linking it into main (or the top-level in ghci) does that.
03:14:35 <EvilTerran> dragons?
03:14:56 <nomeata> Hi. Is there a function of type: Maybe (m ()) -> m ()
03:15:12 <sioraiocht> @hoogle Maybe a -> a
03:15:13 <lambdabot> Maybe.fromJust :: Maybe a -> a
03:15:13 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
03:15:13 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
03:15:33 <sioraiocht> nomeata: what do you need it do to?
03:16:02 <sioraiocht> @src fromJust
03:16:02 <lambdabot> fromJust Nothing  = undefined
03:16:02 <nomeata> sioraiocht: if Nothing, it should do “nothing” (return ()), otherwise do the action
03:16:02 <lambdabot> fromJust (Just x) = x
03:16:19 <nomeata> @type fromJust (return ())
03:16:21 <lambdabot> ()
03:16:31 <nomeata> @type fromMaybe (return ())
03:16:33 <lambdabot> forall (m :: * -> *). (Monad m) => Maybe (m ()) -> m ()
03:16:43 <nomeata> but there is no well known name for that?
03:16:53 <mauke> @pl fromMaybe (return ())
03:16:54 <lambdabot> fromMaybe return
03:17:06 <mauke> what
03:17:17 <mauke> :t fromMaybe return
03:17:19 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe (a -> m a) -> a -> m a
03:18:14 <nomeata> what is pl doing there? Is it right there?
03:18:44 <mauke> @pl f ()
03:18:44 <lambdabot> f
03:18:59 <nomeata> > fromMaybe (return ()) (Just 2)
03:19:00 <lambdabot>   add an instance declaration for (Num (m ()))
03:19:10 <nomeata> > fromMaybe (return ()) (Just (Identitiy 2)
03:19:10 <lambdabot>  Unbalanced parenthesis
03:19:13 <nomeata> > fromMaybe (return ()) (Just (Identitiy 2))
03:19:13 <lambdabot>   Not in scope: data constructor `Identitiy'
03:19:20 <xerox> ?pl ()
03:19:21 <lambdabot> ()
03:19:43 <EvilTerran> ?type liftM2 when isJust fromJust
03:19:45 <lambdabot> forall (m :: * -> *). (Monad m) => Maybe (m ()) -> m ()
03:19:46 <sioraiocht> @pl f n = case n of {Nothing -> return (); Maybe x -> x}
03:19:46 <lambdabot> (line 1, column 17):
03:19:46 <lambdabot> unexpected "{"
03:19:46 <lambdabot> expecting variable, "(", operator or end of input
03:34:45 <LeCamarade> Woah. Still can't believe I should write a parallel sequence from scratch - isn't there a copy lying about, somewhere?
03:36:29 <Matt2309> I hope you'll excuse the newbie question, but I was wondering what the $ operator means (as used in http://leiffrenzel.de/papers/getting-started-with-hunit.html )
03:36:30 <lambdabot> Title: Getting started with HUnit
03:37:46 <nomeata> What do I have to do to make Cabal haddock watch out for #ifdef __HADDOCK__? I have {-# LANGUAGE CPP #-}, and haddock build works.
03:39:10 <EvilTerran> parallel ms = do c <- newChan; mapM (\m -> forkIO $ writeChan c =<< m); replicateM (length ms) (readChan c) -- something like this, LeCamarade?
03:40:35 <EvilTerran> @docs Control.Concurrent.Chan
03:40:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
03:40:51 <ndm> @seen kosmikus
03:40:51 <lambdabot> kosmikus is in #gentoo-haskell, #darcs and #haskell. I last heard kosmikus speak 1d 7m 19s ago.
03:41:02 <ndm> kosmikus?
03:41:13 <kosmikus> yes
03:41:19 <ndm> am having lhs2tex issues, and have a paper due in monday morning
03:41:27 <kosmikus> :)
03:41:59 <ndm> it keeps saying undefined command SkipToFmtEnd
03:42:03 <kosmikus> which conference has a monday morning deadlnie?
03:42:09 <ndm> this is using the Jan 07 release
03:42:35 <ndm> York Doctoral Symposium - i haev been accepted, just making the revisions at my g/f's house, on her computer, and realised I can't even build the paper...
03:42:59 <ndm> previously i was using the svn build
03:43:09 <kosmikus> the error message sounds to me as if you might be mixing internal files from different lhs2TeX versions
03:43:09 <Boney> ndm: can't you ssh into a machine you control on campus?
03:44:20 <ndm> Boney, no - i don't seem to be able to do ssh from this machine - its on a Uni network :(
03:44:40 <kosmikus> ndm: do you have a stray lhs2TeX.sty lying around somewhere it shouldn't be? call lhs2TeX -v and look what files it actually reads?
03:46:56 <ndm> (\Program Files\Haskell/lhs2tex-1.12/polycode.fmt(\Program Files\Haskell/lhs2tex  -1.12/lhs2TeX.fmt(\Program Files\Haskell/lhs2tex-1.12/lhs2TeX.sty(\Program Files  \Haskell/lhs2tex-1.12/lhs2TeX.fmt)
03:47:12 <ndm> looks like its getting them all from the same place, and that's a brand new installation today
03:48:11 <ndm> ah!
03:48:21 <ndm> i just searched my emails, and remembered the reason
03:48:24 <hpaste>  Mr_Awesome pasted "(no title)" at http://hpaste.org/3112
03:48:34 <ndm> its all to do with the line endings of all the .fmt files on windows
03:48:41 <ndm> which we fixed in the darcs version
03:48:44 <Mr_Awesome> could someone tell me if that is a decent way to do what im doing?
03:48:46 <ndm> arcs/svn
03:48:58 <Mr_Awesome> or is there a more elegant way?
03:49:18 <kosmikus> ndm: yes, I remember vaguely. can you remind me what was wrong?
03:49:49 <ndm> kosmikus, the .fmt files have really weird line endings - i am pretty sure its fixed in SVN
03:50:16 <kosmikus> it just confuses me that no one else ever reported this problem on Windows
03:50:21 <ac> I've heard that Haskell automatically memoizes things... what kind of data structure does it use?
03:50:44 <ndm> does anyone else use lhs2tex on windows?
03:50:49 <kosmikus> yes
03:50:52 <ndm> it may just be the polycode mode
03:51:19 <EvilTerran> gaaaah
03:51:50 <kosmikus> well, anyway, I will make a new release soon, and I'll try to fix the Windows experience
03:52:02 <EvilTerran> the library i'm trying to c2hs in *does* have this enumerated type as an enum, but it's not given a name, so i can't {# enum #} it >.<
03:52:04 <ndm> its in the lhs2tex.fmt and .sty - so should effect everyone...
03:52:11 <kosmikus> I have a Windows-based lhs2TeX user in an office next to me now, that makes testing a lot easier
03:52:32 <ndm> good, its a really good tool, and having a nicer windows experience would be good
03:52:46 <ndm> if you had a windows installer then you could not require GHC to be installed
03:52:57 <ndm> i only installed GHC on this machine to build lhs2tex
03:53:22 <kosmikus> I once had a Windows installer, even, as you might remember
03:53:37 <ndm> yes, vaguely
03:53:42 <kosmikus> and I'll probably make one again
03:54:17 <kosmikus> but in the past, I didn't have a 100% Linux environment on all machines I was working on -- now I do, which makes me a much happier person, but is worse for the lhs2TeX users ...
03:55:19 <ndm> @karma+ kosmikus
03:55:19 <lambdabot> kosmikus's karma raised to 7.
03:55:28 <LeCamarade> EvilTerran: Yes, only it should return the results of the call.
03:55:33 <ndm> i've now built my paper, so can now go and change it
03:55:46 <LeCamarade> Wait, lemme see if yours does ...
03:56:00 <ndm> i have to remember what changes to make, since my notes got lost with all my luggage on the way back from Germany...
03:56:08 <ndm> but at least now its feasible
03:56:44 <LeCamarade> EvilTerran: Well, yeah. Close to that, I guess.
03:56:48 <kosmikus> hmm, I can't find any changes in svn to lhs2TeX.sty file
03:57:13 <EvilTerran> i missed a bit off; it should be ...mapM (\m -> forkIO $ writeChan c =<< m) ms; ...
03:57:32 <Saizan_> Mr_Awesome: StateT YourEnv IO would be a much more nice monad to work in
03:58:30 <LeCamarade> Okay, lemme go call Ma, eat, fetch the DVD, read the some pages out of this Spanish guy's novel, and feed the kitten.
03:58:45 <Saizan_> ac: haskell doesn't memoize anything automatically, it just shares values
03:59:18 <ac> Saizan_: oh. I suppose I heard wrong. So it makes sense to make a function that creates arrays and then returns functions that accesses those arrays
03:59:26 <Mr_Awesome> Saizan_: hmm... would i then have to change all of my "State" to "StateT" ?
04:00:02 <Mr_Awesome> this is the only place that the State interacts with IO
04:01:34 <Mr_Awesome> i dont even understand StateT completely. i dont think i would know how to rewrite it if i were using StateT...
04:02:14 <Saizan_> well you could lift your State action in StateT
04:02:30 <Saizan_> but if this is the only place you need IO then it's fine
04:03:35 <Mr_Awesome> ok. thanks
04:17:10 <Saizan_> Mr_Awesome: btw, if you keep your state actions polymorphic, i.e. with type MonadState s m => ... -> m a, you can use them both as State and StateT
04:23:21 <Mr_Awesome> what do you mean "state actions"?
04:23:40 <Mr_Awesome> you mean values of type State s a?
04:38:34 <Saizan_> Mr_Awesome: yes
04:51:14 <Beelsebob> odd instance of the monomorphism restriction being a git
04:51:21 <Beelsebob> how would one get round it with this code...
04:51:33 <Beelsebob> (a,b) = ((+),show)
04:52:19 <Beelsebob> because you can't simply write (a,b) :: (Num a, Show b) => (a -> a -> a, b -> String)
04:58:49 <LoganCapaldo> can't you?
04:59:00 <Beelsebob> nvm, I found out why
04:59:20 <Beelsebob> the specific numeric type needs to be defined to defeat monomorphism
04:59:48 <LoganCapaldo> > let ( (a,b) :: (Num a, Show b) => (a -> a -> a, b -> String) ) = ((+), show)
04:59:48 <lambdabot>  Parse error in pattern
04:59:57 <LoganCapaldo> > let ( (a,b) :: (Num a, Show b) => (a -> a -> a, b -> String) ) = ((+), show) in (a, b)
04:59:57 <lambdabot>  Parse error in pattern
05:00:13 <LoganCapaldo> meh
05:01:54 <LoganCapaldo> >  let { t :: (Num a, Show b) => (a -> a -> a, b -> String) ; t = undefined } in let (a, b) = ((+), show) `asTypeOf` t in (a, b)
05:01:56 <lambdabot>  (<Integer -> Integer -> Integer>,<Integer -> [Char]>)
05:02:29 <ac> I want to map a function that has side effects to a list, but I don't want anything returned. What should I use?
05:02:44 <LoganCapaldo> @type  let { t :: (Num a, Show b) => (a -> a -> a, b -> String) ; t = undefined } in let (a, b) = ((+), show) `asTypeOf` t in (a, b)
05:02:45 <lambdabot> (Num a, Show b) => (a -> a -> a, b -> String) ; t = undefined } in let (a, b) = ((+), show) `asTypeOf` t in (a, b) :: forall a a1. (Num a, Show a1) => (a -> a -> a, a1 -> String)
05:02:51 <LoganCapaldo> ac: mapM_ or forM_ ?
05:02:56 <LoganCapaldo> @type mapM_
05:02:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
05:02:58 <ac> LoganCapaldo: thanks
05:03:13 <therp> ac: you don't want anything returned? sequence?
05:03:15 <idnar> @type forM_
05:03:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
05:03:25 <therp> @type sequence
05:03:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:03:29 <idnar> is that just flip mapM_ ?
05:03:37 <LoganCapaldo> idnar: yes
05:03:44 <idnar> ah
05:03:54 <idnar> @src forM_
05:03:55 <lambdabot> forM_ = flip mapM_
05:03:57 <idnar> heh.
05:04:01 <LoganCapaldo> forM_ [1..10] putStrLn --- looks kinda imperativey is the idea I think
05:04:20 <ac> forM_ or mapM_ is what I want
05:04:29 <ac> what does the '_' mean?
05:04:39 <LoganCapaldo> I read it as "drop"
05:04:39 <ac> the M is obviously Monad...
05:04:46 <idnar> @type mapM
05:04:47 <LoganCapaldo> but I dunno what it actually means
05:04:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:05:04 <idnar> I think it just indicates that the result is discarded
05:05:18 <ac> makes sense, as _ is used in pattern matches
05:05:22 <LoganCapaldo> well yeah that's what it indicates
05:08:03 <LoganCapaldo> Beelsebob: I just tried my eleborate expression in ghci, it works w/o any fancy extensions turned on fwiw
05:08:24 * LoganCapaldo is never quite sure what lambdabot does differently
05:08:24 <Beelsebob> LoganCapaldo: what was that one?
05:08:34 <LoganCapaldo> @type  let { t :: (Num a, Show b) => (a -> a -> a, b -> String) ; t = undefined } in let (a, b) = ((+), show) `asTypeOf` t in (a, b)
05:08:36 <lambdabot> (Num a, Show b) => (a -> a -> a, b -> String) ; t = undefined } in let (a, b) = ((+), show) `asTypeOf` t in (a, b) :: forall a a1. (Num a, Show a1) => (a -> a -> a, a1 -> String)
05:09:21 <Beelsebob> ouch
05:09:40 <LoganCapaldo> or you could just go -fno-monomorphism-restriction I suppose ;)
05:11:31 <LoganCapaldo> @type  let { t :: (Num a, Show b) => (a -> a -> a, b -> Show) ; t = ((+), show) ; (a, b) = t } in (a, b)
05:11:34 <lambdabot>     Class `Show' used as a type
05:11:34 <lambdabot>     In the type `Show'
05:11:49 <LoganCapaldo> @type  let { t :: (Num a, Show b) => (a -> a -> a, b -> String) ; t = ((+), show) ; (a, b) = t } in (a, b)
05:11:50 <lambdabot> (Num a, Show b) => (a -> a -> a, b -> String) ; t = ((+), show) ; (a, b) = t } in (a, b) :: forall a b. (Num a, Show b) => (a -> a -> a, b -> String)
05:13:40 <LoganCapaldo> @type let ( (a :: Num a => a -> a -> a), (b :: Show b => b -> String) ) = ((+) , show ) in (a, b) -- this requires an extension I think
05:13:43 <lambdabot>     Couldn't match expected type `forall a. (Num a) => a -> a -> a'
05:13:43 <lambdabot>            against inferred type `a -> a -> a'
05:29:45 <LoganCapaldo> Beelsebob: wait how were you running into the MI?
05:29:50 <LoganCapaldo> err MR
05:30:05 <LoganCapaldo> @type let (a, b) = ((+), show) in (a, b)
05:30:07 <lambdabot> forall a a1. (Num a, Show a1) => (a -> a -> a, a1 -> String)
05:30:16 <LoganCapaldo> I don't think I had enough context :)
05:40:52 <mudge> hello
05:41:26 <mudge> listenOn creates a socket with a port number,  but what is the hostname for the socket?
05:41:38 <mudge> please someone be alive right now
05:42:09 * SamB wonders why, when he reports debian bugs from emacs, it thinks his name and email address is Samuel Bronson <Samuel Bronson <naesten@gmail.com>>
05:43:28 <LoganCapaldo> sockets don't have hostnames
05:43:33 <LoganCapaldo> hosts do
05:43:38 <LoganCapaldo> @hoogle hostname
05:43:38 <lambdabot> Network.HostName :: type HostName
05:43:38 <lambdabot> Network.BSD.hostName :: HostEntry -> HostName
05:43:38 <lambdabot> Network.BSD.getHostName :: IO HostName
05:44:08 <LoganCapaldo> @docs Network.BSD
05:44:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-BSD.html
05:44:24 <SamB> sockets do have hostnames... see, english works like cobol except you can even use ambiguous specifications
05:44:55 <LoganCapaldo> gah
05:45:23 <LoganCapaldo> ok let me rephrase
05:45:36 <LoganCapaldo> there is likely not a function from sockets to hostnames
05:45:43 <LoganCapaldo> better?
05:45:44 <SamB> true ;-)
05:46:50 <SamB> obviously you first would need to grab whichever endpoint address you were interested in, and then you'd need to find it's hostname
05:48:50 * SamB wonders how to install pst-pdf
05:49:17 <sendark> afternoon everyone
05:49:59 <mudge> if I did: main = withSocketsDo $ do sock <- listenOn (PortNumber 1250)      how would I connect to that socket?
05:50:20 <mudge> and then did:   (handle, host, port) <- accept sock
05:50:36 <_achilles_> moring
05:50:36 <mudge> now the socket is listening,   how do I connect to it and communicate with it?
05:50:44 <sendark> what is the difference between Int and Integer?
05:50:44 <_achilles_> morning*
05:51:06 <mudge> an Integer can be an integer that can be as long as you want
05:51:19 <mudge> an Int is limited in how big it can be
05:51:35 <mudge> and Int is like 2^32
05:51:35 <sendark> ok so they are not interchangeable?
05:51:51 <mudge> no, they are different
05:51:53 <_achilles_> no pun intended
05:51:58 <sendark> because ghci complains that it cant match Int against Integer, but in all my type definitions i've used Int
05:52:03 <sendark> so i'm a bit lost.
05:52:04 <LoganCapaldo> depends what toy mean by interchangeable
05:52:13 <LoganCapaldo> s/toy/you/
05:52:44 <LoganCapaldo> > fromInteger 234 :: Int
05:52:49 <lambdabot>  234
05:52:49 <mudge> LoganCapaldo: if I did: main = withSocketsDo $ do sock <- listenOn (PortNumber 1250)      and then:
05:52:58 <mudge> (handle, host, port) <- accept sock
05:53:04 <mudge> how would I connect to that socket?
05:53:06 <sendark> i could use that
05:53:31 <liyang> (Integer is (just as long or) longer than an Int. ->Int<- is that long. ->Integer<- is longer. See?)
05:53:43 <LoganCapaldo> mudge: you'd connect on port 1250 to whatever host / ip you were running that code on
05:54:12 <mudge> ah, I see,  if I'm running the code on my local machine,  would my hostname be localhost?
05:54:14 <hpaste>  sendark pasted "Scene perception with ac3" at http://hpaste.org/3113
05:54:31 <LoganCapaldo> sure or you could use 127.0.0.1
05:54:48 <mudge> LoganCapaldo: thanks very much
05:56:23 <LoganCapaldo> sendark: add type annotatiosn to your top level values
05:56:30 <LoganCapaldo> ghc defaults to Integer I think
05:56:51 <LoganCapaldo> so queueCheese :: Queue
05:56:54 <sendark> nice
05:57:16 <LoganCapaldo> and it shoudl be ok
05:57:25 <LoganCapaldo> (assuming you do want to use Int s)
05:57:25 <sendark> cheers LoganCapaldo
05:57:33 <sendark> yea i wanna use ints
06:00:14 <noteventime> Is this the main Haskell IRC channel? :-)
06:00:59 <LoganCapaldo> yes
06:01:36 <noteventime> Good :-), just making sure
06:03:39 <sendark> lol
06:18:54 <sendark> is there any way of seeing the trace of ghci on a recursive function?
06:19:04 <EvilTerran> hat?
06:19:22 <EvilTerran> (it's not ghci, but i imagine it runs similarly)
06:20:01 <byorgey> @where hat
06:20:01 <lambdabot> http://www.haskell.org/hat/
06:20:24 <byorgey> sendark: hat is your best bet for now, although there's going to be a debugger in ghc 6.8.1
06:20:45 <sendark> cheerio
06:20:55 <byorgey> unfortunately there's no nice, really simple way =(
06:23:50 <sendark> aargh. cant build hat on my mac.
06:23:53 <sendark> bloody macs.
06:24:27 <sendark> make[1]: hmake: Command not found
06:24:46 <LoganCapaldo> someone I don't think that's because you have a mac
06:25:05 <byorgey> sendark: you need to get hmake.
06:25:08 <LoganCapaldo> http://www.haskell.org/hmake/
06:25:09 <lambdabot> Title: hmake - a make tool for Haskell programs
06:25:18 <sendark> oki
06:25:28 <LoganCapaldo> is hmake better than --make?
06:25:35 <byorgey> sendark: it may be possible to get it through your package manager.
06:26:03 <sioraiocht> package managers for os x suck
06:26:11 <byorgey> hehe =P
06:26:29 * byorgey doesn't even know what the difference is between hmake and --make
06:26:31 <sioraiocht> i just end up compiling everythign from source, and it turns out to be less of a headache, usually
06:26:57 * LoganCapaldo doesn't know either which is why he was asking
06:27:27 <sendark> cant compile hmake either
06:27:28 <sendark> ghc-6.4.1: file `lang' does not exist
06:27:38 <sendark> make[1]: *** [/Users/sendo/Desktop/hmake-3.13/targets/powerpc-Darwin8/obj/hmake/QSort.o] Error 1
06:27:43 <sioraiocht> sendark: maybe you should yoru version of ghc
06:27:50 <sioraiocht> *should upgrade
06:27:53 <sendark> oki
06:28:27 <sendark> upgrading.
06:28:31 <sendark> 13 mb!
06:28:51 <byorgey> hopefully you don't have to compile THAT from source!
06:28:55 <sendark> lol
06:28:57 <sendark> nope
06:29:03 <sendark> fink is on it
06:29:16 <byorgey> compiling ghc is a notoriously ridiculous process
06:30:53 <SamB> it is mostly notoriously LONG
06:32:03 <sendark> u can allways stop for a quickie with your girl while it compiles :)
06:32:18 <sendark> or are we talking night of pasion long?
06:32:58 <byorgey> sendark: more like the latter.
06:33:07 <sendark> nice.
06:33:40 <sendark> nah, not working.
06:34:18 <hpaste>  sendark pasted "compiling hmake" at http://hpaste.org/3114
06:35:32 <LoganCapaldo> Are you sure you upgraded ghc?
06:35:51 <sendark> yep
06:35:54 <LoganCapaldo> ghc-6.4.1: file `lang' does not exist
06:35:54 <sendark> to 6.4.1
06:36:05 <LoganCapaldo> _to 6.4.1/
06:36:07 <LoganCapaldo> oh
06:36:08 <sioraiocht> err
06:36:13 <sioraiocht> 6.6.1 is the version you want, sendark
06:36:19 <sendark> ah i see.
06:36:29 <LoganCapaldo> I think we were all thinking something 6.6ish
06:36:37 <birkenfeld> btw, the CSS preprocessor library I mentioned earlier is now on hackage
06:36:48 <byorgey> birkenfeld: nice =)
06:37:02 <byorgey> sendark: hm, I thought you already had 6.4.1 before?
06:37:23 <LoganCapaldo> yeah me too
06:37:25 <birkenfeld> byorgey: it's nice for me to contribute :)
06:37:59 <byorgey> <sendark> cant compile hmake either
06:37:59 <byorgey> <sendark> ghc-6.4.1: file `lang' does not exist
06:38:05 <byorgey> that was from before
06:38:35 <sendark> god. yea, fink only has 6.4.1
06:38:49 <sendark> i'm gonna have to go for a night of passion with my girl while 6.6 compiles :)
06:39:54 <byorgey> sendark: nah, there's a binary distribution for OS X on the ghc download page
06:41:54 <sendark> saw that
06:42:02 <sendark> installing.
06:46:22 <Japsu> @index runGraphics
06:46:22 <lambdabot> Graphics.HGL.Run, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE
06:46:31 <Japsu> :O
06:46:41 <Japsu> Graphics.SOE == School of Expression?
06:46:58 <Japsu> (I've the book here)
06:47:07 <EvilTerran> heah. it's a wrapper around Graphics.HGL to match up more accurately with the API in the book, i think
06:47:10 <byorgey> Japsu: that's right =)
06:47:11 <EvilTerran> *yeah
06:51:25 <Arnar> byorgey: hey there..
06:51:36 <byorgey> hey Arnar
06:51:55 <Arnar> care for another nub helpout? :)
06:52:12 <byorgey> sure =)
06:52:32 <hpaste>  Arnar pasted "redundancy?" at http://hpaste.org/3115
06:53:06 <Arnar> the fvBExp and fvAExp functions.. they're correct as they are - but I feel there is a more concise way of defining them..
06:53:14 <Arnar> since I'm repeating myself alot
06:53:31 <Arnar> just curious how you'd write them
06:53:46 <byorgey> Arnar: yes, repeating yourself is a good sign that there's more abstraction to be had
06:54:36 <byorgey> Arnar: ah, I see
06:55:04 <byorgey> if you want to cut down on the repetition there, you should look at something like Uniplate
06:55:06 <byorgey> or SYB
06:55:16 * Arnar googles
06:55:17 <byorgey> some sort of generic traversal library
06:55:21 <byorgey> @where Uniplate
06:55:21 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/uniplate/
06:55:40 <Arnar> ooh.. nice
06:55:43 <byorgey> @where SYB
06:55:43 <lambdabot> http://www.cs.vu.nl/boilerplate
06:55:57 <mudge> what's neil mitchel's nick?
06:55:58 <byorgey> I've never used either one, actually, but they look quite useful
06:56:06 <byorgey> mudge: ndm
06:56:11 <Arnar> looks helpful..
06:56:19 <mudge> byorgey: thanks
06:56:24 <Arnar> bu they're not std. haskell libs?
06:56:24 <mudge> @ndm
06:56:24 <lambdabot> Maybe you meant: id undo
06:56:35 <mudge> @where ndm
06:56:35 <lambdabot> http://www.cs.york.ac.uk/~ndm/
06:56:38 <Arnar> I mean.. I'd have to install?
06:56:38 <byorgey> Arnar: what do you mean by "standard"
06:56:40 <byorgey> ?
06:56:46 <mudge> @seen ndm
06:56:46 <lambdabot> I saw ndm leaving #haskell 3h 7s ago, and .
06:56:49 <mudge> damn
06:56:58 <byorgey> they don't come distributed with ghc, if that's what you mean
06:57:04 <Arnar> ok..
06:57:30 <mudge> ndm,  404 error: http://haskell.org/hoogle/?q=forall
06:57:32 <lambdabot> Title: forall - Hoogle
06:57:47 <byorgey> but they're fairly "standard" in that lots of people use them
06:57:48 <Arnar> well.. the example on the uniplate page is exactly what I'm doing, finding free variables in an expression
06:57:57 <byorgey> Arnar: well, there you go =)
06:58:18 <Arnar> byorgey: cool, thanks :)
06:58:27 <mudge> what's forall mean?
06:58:36 <byorgey> mudge: maybe you want @tell?
06:59:02 <mudge> byorgey:  yea, thanks
06:59:09 <byorgey> mudge: it explicitly quantifies a type
06:59:25 <byorgey> mudge: are you looking at a specific example?
06:59:25 <mudge> quantifies a type?   what does that mean?
06:59:41 <byorgey> @type show
06:59:46 <lambdabot> forall a. (Show a) => a -> String
07:00:09 <byorgey> ^^ that means that the type is valid "for all" types a
07:00:41 <mudge> byorgey: yea,  I'm looking at this: (>>) :: forall a b . m a -> m b -> m b
07:01:04 <byorgey> although you don't actually need the forall in the above type, since it's implied by just having a lowercase letter a in the type
07:01:12 <byorgey> mudge: yeah, that's the same thing
07:01:34 <byorgey> "for all types a and b, (>>) has the type m a -> m b -> m b"
07:01:53 <byorgey> or put another way, "a and b can be any types"
07:01:54 <mudge> byorgey:  i see thanks
07:02:07 <mudge> and this is "quantifiying" a type?
07:02:31 <byorgey> universally quantifying, yes
07:02:52 <byorgey> "forall" and "exists" are the universal and existential quantifiers =)
07:02:57 <EvilTerran> from predicate logic, forall and exists are called quantifiers (the universal and existential one, respectively). we don't have exists, but we still call forall a quantifier.
07:03:44 <birkenfeld> what I don't quite get is rank-N types
07:04:10 <byorgey> birkenfeld: a rank-N type is just one where a quantifier is buried N levels deep
07:04:46 <birkenfeld> yep, but what the different effect of a "buried" and a normal quantifier is...
07:04:53 <byorgey> so "forall a. a -> [a]" is a rank-1 type
07:05:05 <byorgey> "String -> forall b. [b]" is a rank-2 type
07:05:22 <byorgey> since the forall is "buried" under the (->)
07:05:47 <birkenfeld> hm... could the latter be a real useful type?
07:06:11 <EvilTerran> not really
07:06:12 <byorgey> mm... that particular one I wrote, I'm not sure
07:06:18 <byorgey> but in general they can be =)
07:06:27 <birkenfeld> I guess the only return value is [bottom]?
07:06:32 <byorgey> yeah
07:06:44 <EvilTerran> (forall b. (b -> Int, b)) -> Int, for instance, could be useful
07:07:06 <mudge> oh i see,  this happy logic stuff,  parade
07:08:13 <birkenfeld> @djinn (forall b. (b -> Int, b)) -> Int
07:08:13 <lambdabot> -- f cannot be realized.
07:08:15 <dmwit> birkenfeld: Or maybe [].
07:08:23 <birkenfeld> right
07:09:01 <mudge> what is does the . mean in (forall b. (b -> Int, b)) -> Int
07:09:05 <mudge> what is the dot for?
07:09:08 <EvilTerran> mine could be a valid type for uncurry ($), i think
07:09:15 <EvilTerran> to indicate the end of the quantifier, mudge
07:09:18 <Olathe> It means that the part after is what the forall applies to.
07:09:32 <mudge> EvilTerran: thanks
07:09:32 <EvilTerran> forall a b c. (...) is also valid
07:10:28 <birkenfeld> hm. where's the difference between (forall b. String -> [b]) and (String -> forall b. [b])?
07:11:58 <birkenfeld> @type \(x :: String) -> []
07:11:59 <lambdabot> forall a. String -> [a]
07:15:16 <byorgey> birkenfeld: the first one is a function which can return a list of whatever type it is asked for; but each time you call the function it will return a list of a particular type.  The second one is a function which returns a list which in and of itself can be of any type.
07:15:54 <birkenfeld> byorgey: I'm not sure... http://www.haskell.org/haskellwiki/Rank-N_types says that "forall can be floated out of the right-hand side of (->) if it appears there"
07:15:56 <lambdabot> Title: Rank-N types - HaskellWiki
07:16:03 <byorgey> oh, ok
07:16:14 <byorgey> I guess those are really the same thing.
07:16:21 <birkenfeld> I'm still looking for a nice simple example, but perhaps there are no nice simple examples :(
07:16:52 <byorgey> birkenfeld: yeah, higher-rank types can be confusing.  I'd say, don't worry about them if you don't need them yet =)
07:17:11 <birkenfeld> I guess that's the best course of action... :)
07:17:14 <Arnar> is there a "concat" like function that concats stuff with a delimiter in between?
07:17:22 <byorgey> @type intersperse
07:17:24 <lambdabot> forall a. a -> [a] -> [a]
07:17:32 <Arnar> byorgey: thanks
07:17:49 <byorgey> > intersperse ' ' ["hi", "there", "Arnar"]
07:17:49 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
07:18:06 <byorgey> > intersperse " " ["hi", "there", "Arnar"]
07:18:07 <lambdabot>  ["hi"," ","there"," ","Arnar"]
07:18:17 <fasta>  > concat $ intersperse " " ["hi", "there", "Arnar"]
07:18:20 <birkenfeld> yeah, normally you want join = concat . intersperse
07:18:26 <birkenfeld> erm
07:18:29 <Arnar> yeah.. figured
07:18:30 <birkenfeld> join x = concat . intersperse x
07:18:34 <fasta> > concat $ intersperse " " ["hi", "there", "Arnar"]
07:18:35 <lambdabot>  "hi there Arnar"
07:18:37 <Olathe> @src join
07:18:37 <lambdabot> join x =  x >>= id
07:18:42 <byorgey> well, I wouldn't call it join, but yeah =)
07:18:49 <byorgey> join already means something else
07:19:01 <birkenfeld> right, I called it joinStr
07:19:09 <Arnar> concat $ intersperse  is good enough for me :)
07:19:13 <fasta> concat $ intersperse " " ["hi", "there", "Arnar"] should be in the standard libs
07:19:27 <fasta> I have seen it in multiple "Util" libraries already
07:19:39 <birkenfeld> there are quite a few string functions missing IMO
07:19:47 <birkenfeld> e.g. split, trim
07:19:54 <fasta> Someone needs to fix cabal-install
07:19:55 <birkenfeld> the MissingH library provides some of them
07:20:04 <LoganCapaldo> > unwords ["hi", "there", "Arnar"]
07:20:04 <Arnar> where's intersperse defined?
07:20:05 <fasta> Then all those problems go away
07:20:05 <lambdabot>  "hi there Arnar"
07:20:10 <EvilTerran> isn't concat . intersperse " " = unwords?
07:20:24 <fasta> EvilTerran: I didn't know that. Nice
07:20:32 <fasta> :t unwords
07:20:33 <EvilTerran> @src unwords
07:20:33 <lambdabot> unwords [] = ""
07:20:33 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
07:20:34 <lambdabot> [String] -> String
07:20:37 <LoganCapaldo> \x -> concat . intersperse x is what should be in the lib
07:20:38 <Arnar> LoganCapaldo: thanks.. but I need to delimit with "," :)
07:21:01 <birkenfeld> perhaps we need chunks and unchunks ;)
07:21:47 <LoganCapaldo> i thought someone mentioned that some bleeding edge ghc had inter---something else-- that was this function basically
07:21:51 <LoganCapaldo> intercalate?
07:22:50 <LoganCapaldo> http://www.haskell.org/pipermail/glasgow-haskell-bugs/2006-October/006476.html
07:22:52 <lambdabot> Title: [GHC] #971: Add intercalate and split to Data.List, http://tinyurl.com/2z5vbu
07:23:29 <byorgey> @index intersperse
07:23:29 <lambdabot> Data.List
07:23:33 <byorgey> Arnar: ^^
07:23:57 <Arnar> byorgey: ah, thanks.. my next question was going to be "how do I ask lambdabot" :)
07:24:52 <Arnar> ah, works like a charm:  showState s fv = "[" ++ (concat $ intersperse "," [v ++ "=" ++ (show $ s v) | v <- fv]) ++ "]"
07:25:41 <LoganCapaldo> @hoogle intercalate
07:25:41 <lambdabot> No matches found
07:26:16 <macron> LoganCapaldo: looking for 'intersperse'?
07:26:24 <LoganCapaldo> no
07:27:08 <LoganCapaldo> trying to figure out what version of ghc, if any this http://hackage.haskell.org/trac/ghc/ticket/971 is actually in
07:27:09 <lambdabot> Title: #971 (Add intercalate to Data.List) - GHC - Trac
07:28:08 <macron> ah, such a function would be useful. I  use concat . intersperse x all the time.
07:28:17 <olsner> intercalate?
07:28:19 <mudge> wow I just learned how to have heterogeneous lists
07:28:33 <olsner> is that misspelled or just very obscure?
07:29:07 <mudge> do you guys know how to have a list with different types in it?
07:29:46 <_achilles_> ? make your own list type?
07:30:15 <mudge> no, using the lists defined by prelude
07:30:36 <LoganCapaldo> olsner: the ticket seems to imply the later
07:30:43 <EvilTerran> quantified types!
07:30:44 <mudge> putting different types in a regular list
07:30:52 <mudge> EvilTerran: that's right!
07:31:01 <LoganCapaldo> "Some people expressed their concerns against such an uncommon word being used and suggested that there should be some explanation for it. It was agreed that there should be an explanation somewhere on the Wiki."
07:31:06 <_achilles_> nope, but i know little -> nothing about haskell
07:31:12 <EvilTerran> [forall a. a] ;)
07:31:19 <mudge> here's how to do it: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
07:31:22 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ..., http://tinyurl.com/f9umb
07:32:17 <olsner> oh, it's even in the dictionary, so it's just obscure ;-) http://dictionary.reference.com/browse/intercalate
07:32:18 <lambdabot> Title: intercalate - Definitions from Dictionary.com
07:37:26 <mudge> is quantifier logic related to category theory?
07:38:46 <byorgey> mudge: everything is related to category theory
07:39:13 <byorgey> seriously though, only tangentially
07:39:39 <olsner> hmm... apparently, I've read the wikibook page on existentially quantified types two times before, but I still don't know what it's about
07:39:54 <byorgey> you don't need to know any category theory to study predicate logic.
07:42:01 <MADnificent> omg, my code looks way to complicated
07:42:09 * MADnificent must fix in brain
07:42:30 <Olathe> > fix code
07:42:31 <Arnar> hmm.. now I'm looking for \x -> putStr (x ++ "\n")
07:42:31 <lambdabot>   Not in scope: `code'
07:42:51 <MADnificent> Olathe: fix brain to write nice code ^_^
07:43:07 * allbery_b 's brain still doesn't generate nice Haskell code
07:43:33 <EvilTerran> @src unlines
07:43:33 <lambdabot> unlines = concatMap (++ "\n")
07:43:41 <desegnis> @type putStrLn
07:43:43 <lambdabot> String -> IO ()
07:43:48 <MADnificent>  /o\ oh noes, it's contagious
07:43:53 <EvilTerran> oh, wait, yes. sorry. still thinking in terms of intersperse.
07:43:57 <Arnar> @index putStrLn
07:43:58 <lambdabot> System.IO, Prelude
07:44:10 <Arnar> desegnis: thanks.. just what I was after
07:44:17 <Olathe> @hoogle String -> String
07:44:18 <lambdabot> Network.URI.normalizeCase :: String -> String
07:44:18 <lambdabot> Network.URI.normalizeEscape :: String -> String
07:44:18 <lambdabot> Network.URI.normalizePathSegments :: String -> String
07:44:28 <Arnar> although.. I probably should have been able to gess "putStrLn" :P
07:45:56 <_achilles_> anyone here read through "yaht"
07:46:56 <mudge> is predicate logic the same thing as quantifier logic?
07:47:13 <byorgey> _achilles_: probably, why?
07:47:42 <Olathe> mudge: I think that's first-order logic.
07:47:48 <LoganCapaldo> > (\xs -> do { x <- xs ; return $ x ++ "\n" }) ["hello", "world"]
07:47:49 <lambdabot>  ["hello\n","world\n"]
07:48:12 <_achilles_> i'm having trouble wrapping my head around a CPS example
07:48:32 <LoganCapaldo> > [ x ++ "\n" | x <- ["hello", "world"] ]
07:48:33 <lambdabot>  ["hello\n","world\n"]
07:48:44 <xerox> > unlines ["hello","world"]
07:48:46 <lambdabot>  "hello\nworld\n"
07:48:55 <LoganCapaldo> zoop
07:49:02 <desegnis> mudge, I guess quantification belongs to predicate logic
07:49:19 <LoganCapaldo> > ["hello", "world"] >>= (++ "\n")
07:49:21 <lambdabot>  "hello\nworld\n"
07:49:27 <LoganCapaldo> I overreturned I did
07:49:37 <_achilles_> byorgey: think you might be able to walk me through his example?
07:49:37 <LoganCapaldo> > (\xs -> do { x <- xs ; x ++ "\n" }) ["hello", "world"]
07:49:38 <lambdabot>  "hello\nworld\n"
07:49:48 <byorgey> _achilles_: I can try!
07:49:55 <byorgey> @where yaht
07:49:55 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
07:50:16 <byorgey> _achilles_: what page?
07:50:37 <Saizan_> where is a list of LANGUAGE options?
07:50:49 <xerox> ?docs
07:50:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
07:51:18 <xerox> ?docs Distribution.Extension
07:51:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html
07:51:22 <xerox> There, Saizan_.
07:51:29 <Saizan_> thanks
07:51:32 <fasta> Is there a way to implement a without repeating all the arguments? a b c d = f a b c d d
07:51:33 <xerox> yw
07:51:48 <fasta> er a b c d = f b c d d
07:52:06 <Olathe> @pl let a b c d = f a b c d d in a
07:52:07 <lambdabot> fix (flip flip id . ((flip . (ap .)) .) . f)
07:52:15 <Olathe> Eww !
07:52:16 <scook0> easy!
07:52:38 <xerox> wow.
07:52:41 <mudge> desegnis: thanks
07:52:42 <fasta> In factor you could use dup.
07:52:43 <Saizan_> ?type ((join .) .) .) . ?f
07:52:44 <Olathe> @pl let a b c d = f b c d d in a
07:52:45 <lambdabot> parse error on input `)'
07:52:45 <lambdabot> flip flip id . (ap .) . f
07:52:50 <mudge> what is the conn@ in this code: conn@(h,host,port) <- accept sock
07:52:51 <Olathe> There.
07:52:52 <Saizan_> ?type (((join .) .) .) . ?f
07:52:54 <lambdabot> forall (m :: * -> *) a a1 a2 a3 a4. (Monad m, ?f::a4 -> a3 -> a2 -> a1 -> m (m a)) => a4 -> a3 -> a2 -> a1 -> m a
07:53:06 <Olathe> mudge: wholeThing@(parts)
07:53:13 <Olathe> I think.
07:53:16 <allbery_b> yes
07:53:16 <scook0> mudge: conn gets bound to the tuple (h,host,port)
07:53:20 <Saizan_> ?type ((join .) . ?f
07:53:22 <lambdabot> parse error (possibly incorrect indentation)
07:53:24 <mudge> Olathe:  wow interesting
07:53:37 <scook0> to avoid you having to put the compound term back together, if you need to do something with it
07:53:40 <mudge> is @ an operator or just part of the name conn@?
07:53:49 <ski> a b c = join (f b c)
07:54:00 <scook0> mudge: it's special pattern-matching syntax
07:54:05 <allbery_b> not exactly an operator, but definitely syntax
07:54:06 <cognominal_> @src sequence
07:54:06 <lambdabot> sequence ms = foldr k (return []) ms
07:54:07 <lambdabot>     where
07:54:07 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
07:54:35 <mudge> allbery_c thanks,  is @ part of haskell98?
07:54:37 <Olathe> > ((++ "!!") . (>> "AA")) "Wrong !"
07:54:39 <lambdabot>  "AAAAAAAAAAAAAA!!"
07:54:44 <ski> mudge : yes
07:55:00 <desegnis> mudge, it's the same as (h,host,port) <- accept sock; let conn = (h,host,port)
07:55:22 <Saizan_> ?type let f = (,,,); a = (join .) . f in a -- you can, fasta
07:55:24 <lambdabot> forall a a1 c. a -> a1 -> c -> (a, a1, c, c)
07:56:04 <mudge> interesting
07:57:58 <scook0> they're generally called "as-patterns"
07:58:09 <cognominal_> @src (>>)
07:58:09 <lambdabot> m >> k      = m >>= \_ -> k
07:59:31 <fasta> Saizan_: it makes little sense to me, however.
07:59:41 <cognominal_> @src (>>=)
07:59:41 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
07:59:57 <fasta> It would be nice to see what instance of join is being used in a programming environment
08:00:14 <xerox> ?src [] (>>=)
08:00:14 <lambdabot> m >>= k     = foldr ((++) . k) [] m
08:00:15 <Saizan_> (-> r) there
08:00:18 <sendark> cant instal ghc
08:00:19 <xerox> ?src concatMap
08:00:20 <lambdabot> concatMap f = foldr ((++) . f) []
08:00:27 <sendark> it says i dont have a suitable compiler
08:00:28 <Saizan_> err, well you know what i mean
08:00:30 <sendark> but i have gcc installed
08:00:45 <fasta> sendark: you need a Haskell compiler
08:01:00 <xerox> cognominal_: so it's m >> k = concatMap (const k) m
08:01:05 <fasta> sendark: and since gcc cannot compile Haskell, it's not a Haskell compiler.
08:01:12 <xerox> substituting backwards
08:01:22 <sendark> fasta: im trying to compile the ghc binaries
08:01:31 <sendark> is ghc written in haskell?
08:01:38 <scook0> sendark: yup
08:01:41 <fasta> sendark: why are you compiling it?
08:01:52 <scook0> I hear that compiling GHC yourself is a bad idea, if you can avoid it
08:01:58 <sendark> not compiling, but installing
08:02:04 <sendark> i run ./configure
08:02:08 <fasta> sendark: ...
08:02:30 <fasta> sendark: you downloaded the binary distribution?
08:02:34 <sendark> configure: error: no acceptable C compiler found in $PATH
08:02:36 <sendark> yep
08:02:37 <fasta> sendark: well, what did you do?
08:02:38 <xerox> cognominal_: makes sense?
08:02:47 <fasta> sendark: platform?
08:02:54 <sendark> darwin-ppc
08:03:03 <sendark> with fink installed
08:03:05 <sendark> and gcc4 installed
08:03:08 <sendark> downloaded the binaries
08:03:21 <sendark> and it says on the install file "to install, run ./configure and then make install
08:03:44 <fasta> sendark: if you do gcc in the directory where configure is, what do you see?
08:04:30 <fasta> sendark: gcc: "no input files"? or "not found"
08:04:45 <sendark> gcc-4: no input files
08:05:02 <fasta> sendark: you typed "gcc" literally?
08:06:31 <sendark> nope
08:06:35 <sendark> had to type gcc-4
08:08:14 <fasta> sendark: well, then isn't it obvious?
08:08:22 <scook0> well, that would presumably be why ./configure can't find it
08:09:19 <cognominal_> thx xerox
08:09:26 <xerox> cognominal_: you're welcome
08:09:43 <fasta> Most sane operating systems have gcc symlinked to gcc-foo.
08:09:57 <cognominal_> @src zipWith
08:09:58 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
08:09:58 <lambdabot> zipWith _ _      _      = []
08:10:14 <sendark> fasta: i made a symlink from gcc-4 to gcc
08:10:17 <sendark> but still
08:10:21 <sendark> does not work
08:10:22 <fasta> sendark: well, then it should work
08:10:32 <fasta> sendark: does not work is not something the machine says
08:10:34 <scook0> sendark: is the symlink in your $PATH?
08:10:42 <fasta> scook0: probably not
08:10:45 <fasta> :)
08:10:51 <desegnis> sendark: more probably, from gcc to gcc-4?
08:11:04 <fasta> desegnis: right
08:11:08 <sendark> fasta: give me a minute please
08:11:21 <fasta> (I assumed that he made a mistake when typing it on IRC)
08:12:03 <MADnificent> does anyone want to look at some code to see how to beautify it? I know it's ugly, but I don't have the experience yet to see how to beautify it (it is just learning-code, so you'd really do it just for fun)
08:12:05 <fasta> You can open a bug report to ask for the search to be include gcc-4, but I doubt it will be accepted.
08:12:06 <desegnis> btw, don't configure scripts usually listen to some $CC environment variable?
08:12:17 <fasta> desegnis: they do.
08:12:27 <fasta> desegnis: but most users don't set them, I think
08:12:39 <sendark> checking for gcc... gcc
08:12:40 <sendark> checking for C compiler default output file name... configure: error: C compiler cannot create executables
08:13:10 <allbery_b> check config.log
08:13:15 <sendark> this is after making a symlink from gcc to gcc-4
08:13:18 <sendark> so gcc works
08:13:36 <MADnificent> sendark: did you ask this a day ago too? or are you another user (and if you're another user, are you on mac too?)
08:13:50 <fasta> sendark: you can try to see whether gcc really works by compiling something simple first.
08:13:54 <desegnis> fasta, thanks. but sendark doesn't need it anymore, as it seems
08:14:35 <fasta> I think the error: C compiler cannot create executables is a FAQ
08:14:43 <fasta> Google surely knows the answer
08:14:50 <sendark> cool
08:14:51 <sendark> cheerio
08:15:26 <allbery_b> osx: gcc_select
08:17:33 <therp> why isn't there CVoid in Foreign.C.Types?
08:18:05 <therp> not that it'd be of any use, but I'd like to use opaque structures for wrapping foreign libs
08:18:50 <mux> we use () to mean that
08:19:09 <therp> good idea, thanks
08:19:13 <mux> or more exactly, IO ()
08:19:28 <mux> because a void C function cannot possibly be pure
08:19:57 <ski> void foo() {return;}
08:20:17 <mux> you wouldn't write bindings to such a function though :)
08:21:10 <ski> what if you had some mutable binding to a function pointer .. sometimes you could want to set it to a "noop" function, no ?
08:21:51 <Arnar> hey guys.. one more stupid question:
08:21:51 <mux> if the function is a noop, what use is there to have bindings for it?
08:21:53 <hpaste>  Arnar pasted "do construct" at http://hpaste.org/3116
08:22:06 <mux> we can use similar haskell constructs
08:22:09 <scook0> mux: to temporarily disable that functionality
08:22:14 <ski> mux : no, a mutable function pointer variable
08:22:24 <therp> mux: I'm using it ATM like this "type XftFont = ()"
08:22:29 <therp> mux: maybe doing proper types later..
08:23:34 <desegnis> Arnar: you cannot have a where clause in the middle of a do expression
08:23:56 <vincenz> use monadic let
08:23:56 <Arnar> desegnis: ok.. thanks.
08:24:09 <hpaste>  ski annotated "do construct" with "do-let" at http://hpaste.org/3116#a1
08:24:17 <desegnis> so you have to use let instead
08:24:20 <mux> ski: well? you'd set it to some FunPtr (... -> IO ()) anyways since other values would cause IO actions
08:24:36 <Arnar> ski, desegnis: ah, thanks
08:24:48 <mux> so having bindings for a ... -> () type is useless still
08:24:49 <Arnar> tried let .. in -- but I guess that's not monadic?
08:25:11 <allbery_b> leave off the "in"
08:25:31 <allbery_b> in a do expression, it's just let foo = bar
08:25:43 <allbery_b> (the "in" is added byt he do expansion machinery
08:25:43 <Arnar> allbery_b: cool, got it.. thanks
08:25:57 <ski> mux : you're right .. (but i still would say "nontrivial")
08:26:18 <allbery_b> @undo do a <- foo; let b = bar a; return b
08:26:18 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
08:26:27 <allbery_b> @undo do { a <- foo; let b = bar a; return b }
08:26:27 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 68}) "Parse error"
08:26:30 <desegnis> @hoogle a -> ()
08:26:34 <lambdabot> No matches, try a more general search
08:26:37 <allbery_b> hm, @undo doesn't do let, does it
08:26:42 <mux> :t rnf
08:26:47 <lambdabot> forall a. (NFData a) => a -> Done
08:26:53 <mux> :i Done
08:27:04 <mux> @info Done
08:27:04 <lambdabot> (Done)
08:27:09 <mux> damn
08:27:25 <allbery_b> anyway:  foo >>= \a -> let b = bar a in return b
08:27:51 <allbery_b> or more pedantically,  foo >>= \a -> let b = bar a in do return b
08:28:05 <ski> do {let {<decl> ...}; <stmt> ...; <expr>}  =  let {<decl> ...} in do {<stmt> ...; <expr>}
08:28:30 <Arnar> ski: ah.. thanks,
08:29:23 <therp> to use the type constructor Ptr, do I have to define it myself? data Ptr a?
08:29:33 <allbery_b> @index Ptr
08:29:34 <lambdabot> Foreign.Ptr, Foreign, GHC.Exts, GHC.Exts
08:29:45 <therp> thnx
08:31:13 <desegnis> what - Control.Parallel.Strategies defines a version of seq which is specific to (), really? wow
08:33:17 <vonBergmann> ChanServ: i'm having some trouble with pattern matching, would anybody be able to tell me what's wrong with the last line of the following: http://hpaste.org/3117#a0
08:33:39 <vonBergmann> i'm having some trouble with pattern matching, would anybody be able to tell me what's wrong with the last line of the following: http://hpaste.org/3117#a0
08:33:50 <ski> :)
08:34:22 <ski> the guard is an expression (of type `Bool')
08:34:24 <ski>   x == (0,(_,_,_))
08:34:30 <ski> `_' is not an expression
08:34:50 <ski>   expand ((0,(_,_,_)):xs) = xs
08:34:53 <ski> should work
08:35:31 <ski> (though i suspect you want to add more cases to `expand')
08:35:53 <vonBergmann> i see
08:36:25 <vonBergmann> l
08:36:37 <vonBergmann> i will later
08:36:46 <ski> (in Prolog or Erlang, i think your idea would work, though)
08:37:15 <vonBergmann> there's a large delay between the time and type enter and the message appearing in irc
08:37:30 <vonBergmann> ~30 seconds or so, anybody else having similar problems?
08:37:50 <fasta> vonBergmann: you use a proxy
08:38:07 <fasta> vonBergmann: if you go through 30 machines, of course it's going to be slow
08:38:38 <fasta> In the year 2200 that problem will probably be resolved, though
08:39:33 <vonBergmann> so would getting an actual irc client rather than connecting through http://ircatwork.com/cgi-bin/irc/irc.cgi help?
08:40:07 <fasta> vonBergmann: hehe, of course
08:40:59 <Arnar> dunno if it makes any sense, but is there something like  a -> [IO a]  available?
08:41:07 <fasta> vonBergmann: but since you use ircatwork, you probably want to dodge the filtering on your boss network.
08:41:18 <fasta> vonBergmann: so, a normal client might not work.
08:41:29 * fasta having no idea of what ircatwork actually does
08:41:46 <ski> Arnar : doing what ?
08:41:48 <nomeata> Hi. Do we have a instance Monoid (a -> a) somewhere?
08:42:14 <ski> @type (const [] :: a -> [IO a])
08:42:16 <lambdabot> forall a. a -> [IO a]
08:42:38 <Arnar> ski, I have a function of type Config -> IO Config, and I want to construct a list where it's applied recursively on some initial Config
08:42:50 <IAW8967> How
08:42:52 <IAW8967> fast
08:42:54 <IAW8967> is
08:42:56 <IAW8967> this
08:43:06 <fasta> I don't have this delay
08:43:15 <Arnar> [cfg0, sosC cfg0, sosC $ sosC cfg0, ...]
08:43:35 <Arnar> sosC being that function
08:43:57 <ski> Arnar : how many times should 'sosC' be iteratively applied ?
08:44:10 <desegnis> @type iterate join
08:44:12 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
08:44:12 <lambdabot>       Expected type: m (m a) -> m (m a)
08:44:19 <vonBergmann> i'm at home and am looking into getting a client right now
08:44:24 <desegnis> would have been to easy :)
08:44:30 <vonBergmann> because i lied when i said 30 seconds, it's more like 1 minute!
08:44:31 <Arnar> ski: possibly infinately.. but a certain type constructor of the return value signals a "final configuration", where it stops
08:45:17 <Arnar> infinitely*
08:46:20 <fasta> Arnar: just iterate and filter
08:46:35 <ski> fasta : s/he has `IO' mixed into it
08:46:51 <Arnar> he ;)
08:47:11 <ski> something like `iterateUntilM :: Monad m => (a -> Bool) -> (a -> m a) -> a -> m [a]' ?
08:47:26 <fasta> Arnar: just unsafeInterleaveIO and some manual filter function, I guess then.
08:47:28 <ski> i don't know about any fitting library function
08:47:48 <fasta> I hate that filterM etc, don'
08:47:51 <fasta> t compose
08:47:51 <Arnar> I have some miranda code that I'm following, but in that case sosC is deterministic (which mine isn't) so there's no messing with monads there
08:47:59 <fasta> (in a lazy way)
08:48:19 <fasta> Since everytime you do something with IO you are basically programming on a C level of abstraction
08:48:44 <ski> that's because monads generally can be strict
08:49:22 <mzq> Hello.
08:52:03 <nomeata> uh. Data.Monoid defines instance Monoid b => Monoid (a -> b), which overlaps with what I need (instance Monoid (a -> a))
08:52:30 <ski> hm `instance Monoid (a -> a)' is not H98, i think
08:53:04 <nomeata> ski: but I think it’s a pretty obvious and useful Monoid
08:53:07 <Arnar> ski: that iterateUntilM seems like what I'm trying.. would you look at a small paste?
08:53:11 <ski> (arguably, `instance Monoid b => Monoid (a -> b)' could maybe belong in `Control.Monad.Reader' or something)
08:53:19 <ski> Arnar : sure
08:53:24 <ski> hm
08:53:47 <hpaste>  Arnar pasted "iterate monads" at http://hpaste.org/3118
08:54:09 <Arnar> the problem there is of course with the >>= - which returns IO Config
08:54:23 <ski> nomeata : possibly you want `Data.Monoid.Endo' ?
08:54:42 <nomeata> ski: hmm. guess you are right
08:54:54 <hpaste>  (anonymous) annotated "iterate monads" with "(no title)" at http://hpaste.org/3118#a1
08:55:43 <ski> Arnar : do you just want this specific function ?, or the more general `iterateUntilM' ?
08:55:56 <Arnar> ski: just this specific one
08:56:27 <byorgey> nomeata: you want Endo.
08:56:37 <byorgey> @src Endo
08:56:37 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
08:56:47 <nomeata> got it, but it’s quite ugly now :-)(
08:57:00 <Arnar> ski: I'm also happy with just somehow iterating inside a do block and printing the Configurations on stdout.. I can get away with not having a list
08:57:13 <ski> Arnar : @type derivSeq
08:57:14 <Arnar> but I don't know if that's even possible :)
08:57:44 <ski> Arnar : it is
08:57:57 <Arnar> ski: hmm? I put Config -> IO [Config] in the paste.. but if Config -> [IO Config] makes more sense I don't care
08:58:14 <Arnar> ski: ok, what should I google? :)
08:58:16 <sorear> nomeata: ddowngrade to 6.4
08:58:24 <ski> Arnar : sorry .. i didn't notice `derivSeq' was the name of the function you were trying to define ;)
08:58:37 <Arnar> ski: ah, sorry.. should have mentioned :)
08:58:40 <sorear> nomeata: 6.4 had (id, (.)) as a monad... the behavior silently changed in 6.6
08:59:42 <sorear> stefan@stefans:~$ ghc-6.6.1 -e '("foo"++) `Data.Monoid.mappend` ("foo"++) $ "bar"'
08:59:43 <dons> haskells up 5 or so points on the tiobe index
08:59:45 <sorear> "foobarfoobar"
08:59:47 <dons>  34      |Haskell              |0.167%
08:59:47 <sorear> stefan@stefans:~$ ghc-6.4.2 -e '("foo"++) `Data.Monoid.mappend` ("foo"++) $ "bar"'
08:59:50 <sorear> "foofoobar"
09:00:02 <dons> that's a 0.04% of the market jump (i.e. of google's hit count)
09:00:03 <sorear> you actually pay attention to tiobe?
09:00:18 <dons> sorear: i pay attention to haskell rising from 50th a year ago..
09:00:26 <dons> and erlang chasing us
09:00:31 <dons> 39      |Erlang               |0.115%
09:00:43 <hpaste>  ski annotated "iterate monads" with "e.g." at http://hpaste.org/3118#a2
09:00:44 <dons> ocaml's gone down, 48      |OCaml                |0.075%
09:01:26 <Arnar> @index liftM
09:01:26 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:01:39 <ski> "tiobe" ?
09:01:49 <ski> @type liftM
09:01:51 <phlpp> is there some good tutorial for understanding CPS(-style functions)? i just reached this part in "yet another haskell tutorial", but it's hard to understand
09:01:52 <ski> @type fmap
09:01:59 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:02:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:02:38 <sorear> phlpp: Do you know how functions are implemented in C-like languages?
09:02:43 <sorear> stacks and whatnot/
09:03:01 <phlpp> 'implemented'?
09:03:11 <phlpp> u mean type function(type, ...)
09:03:12 <phlpp> ? :>
09:03:47 <sorear> nah, I mean what kind of code is generated for them, stack discipline, asctivation records, etc
09:03:56 <Arnar> ski: thanks.. the program compiles and executes.. have to figure out how to output the stuff to see if it's correct :)
09:04:07 <sorear> if not, don't worry, there are dozens of ways to understand the CPS transform
09:04:55 <byorgey> dons: how goes the hackathon?
09:05:06 <hpaste>  ski annotated "iterate monads" with "printing along the way" at http://hpaste.org/3118#a3
09:05:31 <phlpp> sorear: hm ok
09:05:44 <phlpp> sorear: so do you think it's not _necessary_ at the moment to understand the few pages
09:05:48 <phlpp> about cps in my tutorial?
09:06:16 <sorear> phlpp: I don't know.  I was just offering *one* way to understand CPS
09:06:29 <ski> Arnar : ^
09:07:04 <byorgey> phlpp: I don't think it's necessary.  It's definitely ok to skip some things on a first time through a tutorial and come back to them later =)
09:07:43 <phlpp> byorgey: ok, thanks
09:07:48 <phlpp> and thank you sorear
09:10:44 <dons> byorgey: kicking along
09:11:42 <vonBergmann> test
09:12:05 <byorgey> dons: any idea where ICFP will be next year?
09:12:55 <byorgey> probably somewhere in north america I guess
09:18:37 <dons> byorgey: in victoria, british columbia
09:18:58 <byorgey> dons: ok, cool
09:19:12 * byorgey plots
09:19:36 <oerjan> to take over the world?
09:20:09 <byorgey> no, to attend ICFP =)
09:20:22 <oerjan> ah
09:20:42 <byorgey> taking over the world will have to wait for 2009
09:20:47 <sorear> That's just his cover story.
09:20:48 <ski> to attend ICFP and there cabal to take over the world ?!
09:21:23 <byorgey> sorear: shhh!
09:21:39 <Cheery> since haskellers are mathematically oriented, I shall ask this question here: I'm going to make a programmer writing interface to a touch display in a handheld device, and I'd need some mathematics that I could apply to glyphs
09:21:57 <sorear> You write programmers?
09:22:14 <Cheery> urgh, my english sucks if I said that :D
09:22:21 <byorgey> no, the interface writes programmers =)
09:23:00 <sorear> Cheery: so what kind of math-for-glyphs do you need?
09:23:02 <Cheery> not, tried to express something like: "text-interface for programmers via a touch display"
09:25:07 <Cheery> well, when you turn letters in a word to their bit forms, buffer them to the screen from up to down, they automatically form glyphs
09:25:23 <sorear> ...?
09:26:18 <Cheery> but I'd want to achieve the same effect with pencil
09:26:49 <sorear> huh?
09:27:01 <sorear> you want to use a pencil to draw a bitmap?
09:27:06 <Cheery> the pixel lines form glyphs in sense that you can learn to recognise words by it's glyph
09:27:13 <EvilTerran> OCR?
09:27:17 <hpaste>  Saizan pasted "can i write empty without the class?" at http://hpaste.org/3119
09:28:09 <Cheery> sorear: nah, I'd know how to do that
09:28:51 <Cheery> I'd like to achieve same effect with vectors what I achieve with pixels the way I described
09:29:01 <sorear> ooh, 3k pastes!
09:29:12 <sorear> how do you draw stuff with vectors?
09:29:33 <Cheery> vector graphics*
09:30:28 <sorear> Saizan_: No.
09:30:55 <byorgey> Cheery: so, given a set of vectors/strokes, you want to recognize which character they most closely resemble??
09:31:33 <sorear> Cheery: look at http://keithp.com/~keithp/talks/twin-ols2005/twin-ols2005www/#SECTION00080000000000000000
09:31:35 <lambdabot> Title: TWIN: A Window System for `Sub-PDA' Devices, http://tinyurl.com/yvxlvd
09:31:42 <sorear> Cheery: actually, the whole page
09:37:51 <Cheery> sorear: that seems useful but it's not what I'm looking for. taking a deep breath, then reattempting to explain what I need more precisely
09:40:30 <_achilles_> ha
09:41:03 <byorgey> _achilles_: ?
09:41:22 <_achilles_> I saw your conversation about CPS stuff a while ago
09:41:38 <_achilles_> with phlpp
09:41:52 <byorgey> oh, hehe =)
09:42:10 <_achilles_> goofy tricky stuff
09:42:16 <_achilles_> :)
09:43:44 <_achilles_> well I'm back for action, here goes a CPS map and filter
09:44:19 <Cheery> I need some algorithms and math for constructing glyphs from words so that one can recognise the word's letters' bit strings from the glyph's structure
09:45:42 <Cheery> the glyphs won't resemble letters but words
09:45:59 <byorgey> _achilles_: have fun =)
09:48:00 <Cheery> and for and they should be hand-writable
09:48:25 <Cheery> -and for
09:52:14 <byorgey> Cheery: that sounds interesting, but I doubt anyone here will be able to help you all that much
09:54:27 <_achilles_> sounds mind-boggling
09:56:07 <byorgey> @pl \f g h x -> f (g x) (h x)
09:56:07 <lambdabot> liftM2
09:56:15 <byorgey> oh, duh
09:58:28 <Cheery> byorgey: yep, but this would be the place if anywhere anyone would be able to help me with this thing
10:00:05 <earthy> hm.
10:00:18 <earthy> cheery, look into arabic and sanskrit letterforming
10:02:08 <byorgey> Cheery: just out of curiosity, I want to make sure I understand you right: given a word (such as 'haskell') you want to come up with a single glyph which somehow encodes the letters in the word?
10:02:57 <earthy> oh, and ofcourse, chinese and japanese ideography should prove inspirational
10:03:08 <earthy> some of that is quite compositional
10:03:41 <Cheery> byorgey: you understood me right
10:04:14 <byorgey> Cheery: but it should be sufficiently distinguishable that someone can input it with a stylus?
10:04:27 <Cheery> yes
10:04:44 <fasta> What's an alternative to fail "reason" and runMaybeT?
10:04:56 <Cheery> the pixel-form would suffice otherwise
10:05:04 <MyCatVerbs> You want a lojban equivalent for written glyphs.
10:05:08 <byorgey> hm... I'm not sure how you could do much better than just inputting each letter one after the other?
10:05:09 <MyCatVerbs> ?
10:05:30 <oerjan> fasta: why do you need an alternative?
10:05:33 <allbery_b> EitherT?  ErrorT?
10:05:49 <fasta> oerjan: I don't, but people often claim that fail "" is somehow "wrong".
10:06:00 <Cheery> MyCatVerbs: lojban has nothing to do with this one right now, I want to generate glyphs from english and even finnish words as well
10:06:03 <mauke> fasta: mzero
10:06:14 <oerjan> fasta: that's a fault of the Monad class, not any specific monad
10:06:17 <fasta> Oh, right
10:06:27 <oerjan> they want it to be in MonadZero instead
10:06:28 <fasta> That's what I needed
10:06:40 <MyCatVerbs> Cheery: but you want something artificially constructed, rather than naturally evolved.
10:06:48 <Cheery> sure
10:06:51 <fasta> So, it would be best to define my_fail str = mzero
10:07:09 <oerjan> except then your reason gets lost, completely
10:07:31 <oerjan> if you want the reason preserved, use ErrorT
10:07:52 <fasta> ok
10:07:57 <Cheery> hmm. thought where do we draw a line here? If I evolve them with a simulation, is it naturally evolved or artificially constructed?
10:08:07 <oerjan> fasta: using fail is the best under the current system.
10:08:23 <oerjan> improving it requires changing the whole system
10:08:53 <fasta> Haskell is legacy already? ;)
10:08:59 <chessguy> @djinn (Integer -> Bool) -> Bool
10:08:59 <lambdabot> f _ = False
10:09:16 <oerjan> fasta: reactionary, actually
10:09:20 <MyCatVerbs> Cheery: ...how would you judge fitness for a genetic algorithm involving glyph design?
10:09:26 <oerjan> it was done "right" in 1.4
10:09:40 <MyCatVerbs> Cheery: (seminatural, I'd say, BTW. ^_^)
10:11:35 <birkenfeld> chessguy: reading sigfpe?
10:11:45 <chessguy> attempting
10:11:59 <birkenfeld> I gave up, dinner awaits :)
10:12:00 <Cheery> hmm.. that'd may be the question I'd need to answer... first things that come to my mind is mathematical, geometrical and human
10:12:20 <Cheery> mathematical fitness in a way that the algorithm would be simple
10:12:51 <Cheery> geometrical fitness in a way that the glyphs would stay in some geometric bounds
10:13:29 <Cheery> human fitness in a way that the glyphs would have minimal amount of strokes, uniqueness and writability
10:14:21 <chessguy> Cheery, are you writing a GA in haskell?
10:15:31 <Cheery> depends whether I'll need to
10:17:05 <DJ-DrIP[AR]> hai all
10:18:39 <DJ-DrIP[AR]> i need a bit of help
10:20:52 <MyCatVerbs> Cheery: mathematical fitness isn't neccessarily such a problem, though, provided the user never has to see or apply the algorithm themself. It's not like you couldn't write a *second* GA to find an algorithm requiring the minimal number of steps which closely resembles the one you select from the first GA. ;)
10:21:21 <DJ-DrIP[AR]> humm
10:21:23 <DJ-DrIP[AR]> odd
10:21:27 * arcatan humms
10:21:37 <DJ-DrIP[AR]> /usr/local/lib/ghc-6.6.1/ghc-6.6.1: error while loading shared libraries: libreadline.so.4: cannot open shared object file: No such file or directory
10:22:14 <Cheery> MyCatVerbs: that's true
10:22:21 <DJ-DrIP[AR]> btw: 16arctan(1/5)-32atctan(1/237) == pi
10:22:28 <DJ-DrIP[AR]> i believe :p
10:22:42 <fasta> DJ-DrIP[AR]: you are on a broken platform.
10:22:52 <DJ-DrIP[AR]> eh?
10:22:55 <fasta> DJ-DrIP[AR]: you need readline version 5
10:23:07 <DJ-DrIP[AR]> i see
10:23:19 <fasta> DJ-DrIP[AR]: what platform is broken?
10:23:27 <DJ-DrIP[AR]> however, i'm trying to install utfstring9
10:23:29 <DJ-DrIP[AR]> *8
10:23:49 <fasta> DJ-DrIP[AR]: on what platform are you?
10:23:56 <DJ-DrIP[AR]> Gentoo
10:24:11 <DJ-DrIP[AR]> i686
10:24:36 <Cheery> MyCatVerbs: earthy's comments about letter forming are giving interesting search results
10:25:50 <DJ-DrIP[AR]> fasta, any ideas?
10:26:04 <fasta> DJ-DrIP[AR]: yes, install Debian :)
10:26:11 <DJ-DrIP[AR]> =(
10:26:15 <fasta> DJ-DrIP[AR]: or just install a newer version of readline
10:26:21 <DJ-DrIP[AR]> how?
10:26:25 <fasta> DJ-DrIP[AR]: I may hope that should be one emerge command
10:26:31 <DJ-DrIP[AR]> mkk
10:26:52 <Cheery> but not finding useful pages about arabic or sanskrit
10:27:28 <DJ-DrIP[AR]> emerge: there are no ebuilds to satisfy "libreadline".
10:27:33 <DJ-DrIP[AR]> =(
10:27:37 <MyCatVerbs> Cheery: if you get anything good out of this, I want to steal your ideas to make an input device. :)
10:29:13 <MyCatVerbs> Cheery: what I wanna do is put a flexible stylus pickup and a display onto a film of transparent material, then wrap it around the back of the user's hand.
10:29:44 <MyCatVerbs> Cheery: so it's just like taking notes on the back of one's hand, except that after you write the note, it fades a few seconds later and gets stored into memory. :)
10:30:00 <Cheery> completely buttonless design
10:30:01 <Cheery> ?
10:30:22 <MyCatVerbs> Dunno. Maybe.
10:31:07 <MyCatVerbs> Have a few specific glyphs that cause the thing to retrieve previous notes, perhaps. Also, abuse bluetooth to pass notes around class. :)
10:31:17 <Cheery> that sounds cool
10:31:28 <monochrom> Haskell data types are topless. Haskell strict data types are topless and bottomless. :)
10:31:39 <_achilles_> yay, CPS map!
10:31:45 <lnxz> DJ-DrIP[AR], I think you want sys-libs/readline
10:31:51 <DJ-DrIP[AR]> ok
10:33:33 <DJ-DrIP[AR]> ha ha ha and i was just about to download debian
10:33:39 <DJ-DrIP[AR]> lol
10:33:46 <DJ-DrIP[AR]> thanks
10:42:59 <sorear> DJ-DrIP[AR]: if it still doesn't work, get hexedit and change 'libreadline.so.4' into 'libreadline.so.5' in /usr/local/lib/ghc-6.6.1/ghc-6.6.1
10:43:07 <sorear> trust me, it works
10:45:38 <Cheery> ooho. http://en.wikipedia.org/wiki/Graphonomics
10:45:40 <lambdabot> Title: Graphonomics - Wikipedia, the free encyclopedia
10:49:10 <vonBergmann> what does the "announce" option in hpaste.org do?
10:49:14 <rjseagraves> Is there a built-in function like read, but has return type "Maybe Read a" (so if the read fails, a runtime exception doesn't get thrown)?
10:49:36 <allbery_b> vonBergmann: sends an annoucement of the paste to this channel
10:50:03 <sjanssen> rjseagraves: you can use reads
10:50:03 <lambdabot> sjanssen: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:50:09 <sjanssen> > reads "1"
10:50:10 <lambdabot>  [(1,"")]
10:50:18 <allbery_b> <hpaste>  ski annotated "iterate monads" with "printing along the way" at http://hpaste.org/3118#a3
10:50:22 <allbery_b> (example from earlier)
10:50:26 <sjanssen> rjseagraves: successful parses have the form [(x, "")]
10:51:51 <Cheery> http://upload.wikimedia.org/wikipedia/commons/6/60/WritingSystemsoftheWorld4.png
10:51:53 <lambdabot> http://tinyurl.com/38xnuy
10:52:04 <Cheery> there are some I did never know about
10:52:38 * Nafai is crazy and is reading the Haskell 98 Report
10:53:15 <allbery_b> @google omniglot
10:53:17 <lambdabot> http://www.omniglot.com/
10:53:17 <lambdabot> Title: Omniglot - a guide to the languages, alphabets, syllabaries and other writing sy ...
10:54:19 <MyCatVerbs> Cheery: maybe, but I have no *clue* whether it'd be feasible or not yet.
10:55:29 <MyCatVerbs> Cheery: we can do flexible transistors on film already, and flexible displays, but I'm not sure if it's even remotely possible to do flexible stylus input, or to put all three together.
10:56:25 <MyCatVerbs> Cheery: the other problem would be that it just would not work at *all* unless it were constantly in tension, and I'm not sure whether that'd be too uncomfortable to use or not. Not to mention how much of the human hand it could be made to cover, nor how easy or difficult it would be to fit to a particular person's hand.
10:57:20 <hpaste>  vonBergmann pasted ""Expanding" out terms in a list" at http://hpaste.org/3120
10:57:42 <vonBergmann> i'm trying to write a function to "expand" out terms of a list
10:57:47 <vonBergmann> ie) The list [(2,(1,1,36.0))] would become a new list [(1,1,36.0),(1,1,36.0)]
10:58:19 <vonBergmann> i think i've got the list to recursively go down to the base case but i can't think of any way to generate the new list
10:58:38 <olsner> > concatMap (uncurry (flip repeat)) [(2,'a'),(3,'b')]
10:58:45 <lambdabot>  Couldn't match expected type `a -> c' against inferred type `[b]'
10:59:02 <olsner> aww, it should've been a good guess though
10:59:14 <vonBergmann> any help/ideas would be appreciated
10:59:17 <olsner> @type concatMap (uncurry (flip repeat))
10:59:19 <lambdabot>     Couldn't match expected type `a -> c' against inferred type `[b]'
10:59:19 <lambdabot>     In the first argument of `flip', namely `repeat'
10:59:29 <olsner> @type concatMap (uncurry (flip replicate))
10:59:31 <lambdabot> forall a. [(a, Int)] -> [a]
10:59:41 <olsner> @type concatMap (uncurry replicate)
10:59:43 <lambdabot> forall a. [(Int, a)] -> [a]
10:59:55 <olsner> > concatMap (uncurry replicate) [(2,'a'),(3,'b')]
10:59:55 <_achilles_> can you load multiple modules from the hugs commandline?
10:59:59 <lambdabot>  "aabbb"
11:00:20 <_achilles_> > putStrLn ("Shhhhhh!")
11:00:21 <lambdabot>  <IO ()>
11:00:32 <fasta> _achilles_: I can.
11:00:41 <_achilles_> how do I muster that?
11:01:18 <xerox> :also
11:01:41 <fasta> _achilles_: the man page contains the answer (I just checked)
11:02:08 <_achilles_> yeah, i just didn't want to "man hugs"
11:02:13 <Cheery> btw. It's sort of funny to know where our writing system evolved from. think about teachers trying to retain the 'correctness' in children's handwriting.
11:02:46 <Cheery> where our writing system would go yet after this?
11:02:48 <fasta> _achilles_: uhm, but we should?
11:03:32 <_achilles_> nevermind, trying to make a homophobic joke
11:03:32 <fasta> _achilles_: this IRC channel is no cure for laziness, AFAIU.
11:03:48 <_achilles_> man hugs....it's funny
11:04:39 <Cheery> lots of hugs
11:05:25 <fasta> how about man evil?
11:06:14 <Cheery> man cat
11:06:15 <_achilles_> my favorite feminist one is: man bash
11:06:42 <Cheery> man slapping
11:07:07 <fasta> man ual
11:07:14 <_achilles_> ha
11:07:27 <Botje> man boobs
11:07:30 <fasta> man iac
11:07:45 <_achilles_> man meet
11:07:54 <Cheery> hah, my next software has cmd boobs
11:07:57 <Botje> man tle
11:08:17 <Cheery> then I can use the man boobs -section
11:08:37 <_achilles_> woohoo
11:09:31 <_achilles_> cool
11:09:44 <_achilles_> I've finished the damn CPS portion of yaht
11:10:06 <MyCatVerbs> CPS blew my brain up.
11:10:23 <_achilles_> agreed
11:11:01 <Botje> yaht should have silly stories in major brain-blowing chapters.
11:11:22 <_achilles_> I told someone earlier, the first part of yaht is a lot of hand holding, "you look nice today"s and chocolate, the CPS part comes out of nowhere and slaps you right in the mouth
11:11:24 <MyCatVerbs> For *all* the exercises in there, rather than writing something from scratch, I came up with a function to be supplied to yaht's continuation-passing fold ('foldc', right?) which achieved the desired result, rather than actually designing something from scratch.
11:11:43 <MyCatVerbs> Mmmhmmm.
11:13:25 <_achilles_> I managed to figure out the cps_map and cps_filter just now. it probably took me an hour or so of good brain racking and 30 minutes of good discussion to understand the fold example
11:13:44 <MyCatVerbs> I've no idea whether my answers for those are even vaguely valid. They're *correct*, but I don't know if they're what I was meant to have written.
11:14:19 <_achilles_> yeah I couldn't check them, for some reason they don't appear in the PDF
11:14:35 <_achilles_> but if you go here: http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics/Solutions
11:14:46 <_achilles_> they've got 'em
11:14:50 * MyCatVerbs manually stepped through the reductions involved in foldc in order to work out how to use it, then came up with lambdas to pass it that'd work.
11:15:10 <_achilles_> oh....
11:15:19 <earnest> anybody knows a channel about lex or yacc?
11:15:38 <MyCatVerbs> _achilles_: those are, I presume, merely *one* set of valid answers? Presumably YAHT's questions could each be answered using any number of fascinating tricks.
11:16:08 <_achilles_> true true: but I presume that's similar to what the author was looking for
11:16:59 <r3m0t> hello, I'm new
11:17:17 <r3m0t> when I enter "double :: Int -> Int" into hugs, I get "Undefined variable "double"
11:17:17 <_achilles_> welcome, I'm new too
11:17:51 <_achilles_> > let double :: Int -> Int
11:17:51 <lambdabot>  Parse error
11:18:32 <axm> :t (*2)
11:18:34 <lambdabot> forall a. (Num a) => a -> a
11:19:05 <_achilles_> r3m0t, the interpreters (in my breif experience) don't allow you to do things like that
11:19:21 <Cheery> it'd be interesting to know how the handwriting recognition software finds out in what angle the input comes to the display
11:19:34 <_achilles_> I know there are ways to do it, but you can't just type verbatim what you would into a module file
11:20:47 <r3m0t> then what do I do?
11:21:05 <fasta> Haskell Quiz: what does \f -> (liftM2 fmap (,) f) do?
11:21:24 <axm> in ghci for example you could force the type by "let double = (*2) :: Int->Int"
11:21:30 <olsner> @type liftM2 fmap (,)
11:21:32 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1 -> f a) -> a1 -> f (a1, a)
11:21:57 <_achilles_> pop open and editor, type in what you want to try, the hugs <filename>.hs
11:22:14 <olsner> fasta: it does magic on a functor :P
11:22:47 <MyCatVerbs> Or open ghci and do :load filename.hs, then :r afterwards. I think those work in hugs too, right?
11:23:00 <_achilles_> to the best of my knowledge
11:23:32 <r3m0t> That's OK, I have both
11:24:19 <_achilles_> the (*2) is a-kin to a lambda function
11:25:01 <r3m0t> then to define double as 2 * x?
11:25:47 <_achilles_> that's what the line axm mentioned does
11:25:57 <DJ-DrIP[AR]>  5.2_p7
11:26:02 <DJ-DrIP[AR]> err oops
11:26:11 <r3m0t> you mean the brackets have the defininition of the function?
11:26:29 <r3m0t> this is too complicated, I'm just going to put it in a file
11:26:40 <_achilles_> I agree
11:27:20 <r3m0t> whoops :) this window manager takes getting used to
11:27:20 <LoganCapaldo> double = join (+)
11:27:35 <axm> r3m0t, no, they turn an infix operator like * into a function
11:27:36 <r3m0t> LoganCapaldo: smartass :P
11:28:51 <DJ-DrIP[AR]> hai all i have readline 5.2_p7 but i need an earlier version of it... I run gentoo, any help?
11:28:59 <_achilles_> emerge
11:29:03 <_achilles_> ;)
11:29:08 <oerjan> r3m0t: everyone turns into a smartass in this channel eventually.  it's infectious.
11:29:09 <axm> (*) 2 would be the same to (2*) here
11:29:57 <LoganCapaldo> hmm
11:30:13 <LoganCapaldo> @type 2 >>= (+)
11:30:18 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a
11:30:28 <LoganCapaldo> @type (+) >>= 2
11:30:30 <_achilles_> DJ-DrIP[AR] $ emerge haskell98 #i thnk
11:30:30 <lambdabot> forall a b. (Num a, Num ((a -> a) -> a -> b)) => a -> b
11:31:05 <oerjan> @type const 2 >>= (+)
11:31:07 <lambdabot> forall b. (Num b) => b -> b
11:31:07 <LoganCapaldo> @type (+) >>= 2 . id
11:31:09 <lambdabot> forall a b. (Num a, Num ((a -> a) -> a -> b)) => a -> b
11:31:29 <LoganCapaldo> oerjan: yeah but that's like so just a normal return 2 >>= (+)
11:31:50 <oerjan> > (+) >>= flip id 2
11:31:51 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
11:31:51 <lambdabot>     Probabl...
11:31:51 <LoganCapaldo> I wanted something bizzare and cool :)
11:32:08 <oerjan> > (+) >>= undefined
11:32:08 <lambdabot>  Add a type signature
11:32:52 <oerjan> > (+) >>= return . flip id 2
11:32:53 <lambdabot>  <Integer -> Integer>
11:33:43 <oerjan> looks good
11:34:08 <oerjan> > ((+) >>= return . flip id 2) 3
11:34:09 <lambdabot>  5
11:35:06 <_achilles_> 6?
11:35:08 <oerjan> @pl (+) >>= return . flip id 2
11:35:08 <lambdabot> ($ 2) `fmap` (+)
11:50:11 <ericlavigne> let cons h t = [h]++t
11:50:25 <mauke> DENIED
11:50:31 <ericlavigne> I assume there is a built-in function for cons, but I haven't been able to find it.
11:50:55 <mauke> :
11:51:04 <mauke> @src (++)
11:51:04 <lambdabot> (++) []     ys = ys
11:51:04 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
11:51:20 <ericlavigne> Checking the source of ++, that makes a lot of sense.
11:51:21 <mauke> @hoogle a -> [a] -> [a]
11:51:25 <lambdabot> List.intersperse :: a -> [a] -> [a]
11:51:25 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
11:51:25 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
11:52:25 <LoganCapaldo> hehe
11:52:27 <monochrom> > (:) 3 [3,4]
11:52:28 <lambdabot>  [3,3,4]
11:52:30 <ericlavigne> @hoogle b -> [b] -> [b]
11:52:31 <lambdabot> List.intersperse :: a -> [a] -> [a]
11:52:31 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
11:52:31 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
11:52:37 <LoganCapaldo> it would mbe funny if ++ was the constructor..
11:52:53 <EvilTerran> there is a type like that, iirc
11:53:08 <fasta> Where's the monad instance (-> r) defined?
11:53:23 <monochrom> Control.Monad.Instances perhaps
11:53:52 <fasta> monochrom: in what file, to be more specific?
11:54:05 <mauke> @source Control.Monad.Instances
11:54:06 <lambdabot> Control.Monad.Instances not available
11:54:13 <monochrom> somethingsomething/Control/Monad/Instances.hs or lhs
11:54:40 <fasta> monochrom: I checked that of course, but it isn't there(in mtl).
11:54:49 <fasta> I will do a full-text search
11:54:50 <EvilTerran> C.M.Instances or C.M.Reader(.Class), i'd've thought
11:55:34 <fasta> Meh, all I find are imports.
11:56:40 <fasta> Found it
11:56:43 <fasta> It's in base
11:56:48 <sorear> grep -r ftw
11:56:57 <mauke> ack > grep -r
11:57:58 <monochrom> Oh I see. "it" sometimes refers to a file.
11:58:24 <monochrom> I hate pronouns. Should be banned.
11:59:08 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html is your friend too
11:59:42 <fasta> Why is this a functor? fmap f (x,y) = (x, f y)
12:00:01 <fasta> (and not fmap f (x,y) = (y, f x)?
12:00:05 <fasta> )
12:00:12 <fasta> It seems arbitrary
12:00:21 <oerjan> huh?
12:00:34 <mauke> types
12:00:35 <oerjan> because the data type is (,) a b
12:00:53 <oerjan> and functors always require removing the _last_ element
12:01:05 <mauke> :t \f (x,y) -> (y, f x)
12:01:13 <lambdabot> forall t t1 t2. (t -> t2) -> (t, t1) -> (t1, t2)
12:01:14 <oerjan> haskell does not support reordering type arguments in instances
12:01:55 <mauke> (a, b) -> (b, c) isn't even close to f a -> f b
12:11:01 <fasta> mauke: I see what you mean.
12:16:35 <ericlavigne> I am confused by these errors: "Not in scope: List.head" and "Not in scope: Data.List.tail". What do I need to do to make these libraries available?
12:17:11 <allbery_b> import?
12:17:26 <allbery_b> ghci auto-imports fully qualified names; ghc does not
12:17:32 <ericlavigne> ah, okay
12:17:35 <mauke> also, head/tail are in the Prelude
12:17:37 <Korollary> head and tail should be exported from Prelude
12:17:49 <ericlavigne> yes, I was confused because ghci accepted but not ghc
12:18:00 <ericlavigne> I will go read about import.
12:18:05 <allbery_b> also, you should probably be consistent about whether using Haskell98-compatible List of hierrchical Data.List :)
12:18:19 <allbery_b> gr
12:18:21 <ericlavigne> I don't understand that last comment.
12:18:27 <allbery_b> "or hierarchical"
12:18:47 <allbery_b> also, you should probably be consistent about whether using Haskell98-compatible List or hierarchical Data.List :)
12:19:10 <ericlavigne> Which is considered preferable today?
12:19:11 <allbery_b> List is the old, haskell98-compatible name for the module which is inmodern haskell called Data.List
12:19:29 <mudge> what's the difference between quantifier logic and predicate logic?
12:19:30 <ericlavigne> Okay, thanks.
12:19:38 <allbery_b> the next standard will bless the latter, meanwhile all existing haskell compilers should accept Data.List
12:19:51 <allbery_b> but if for some reason you need to stick to the standard use List
12:20:08 <ericlavigne> Mostly I just want my code to work in ghc :-)
12:20:31 <mauke> ericlavigne: do you know OCaml?
12:20:41 <ericlavigne> mauke: Yes
12:21:14 <mauke> import Foo is like open Foo;;
12:21:25 <mauke> import qualified Foo is like just using Foo.something in OCaml
12:21:55 <ericlavigne> Okay, I can do that.
12:21:58 <LoganCapaldo> import qualified Foo as F is like...?
12:22:26 <mauke> dunno
12:22:31 <mauke> module F = Foo or something?
12:22:47 <LoganCapaldo> is there an equivalent import Foo (f, g) or hiding (f, g)?
12:28:34 <mudge> anyone know the difference between quantifier logic and predicate logic?
12:28:42 <mudge> or are they the same thing?
12:29:40 <monochrom> same
12:32:53 <mudge> monochrom: thanks, that question has been itching me for hours
12:33:06 <mudge> google wasn't too friendly on that one
12:33:23 <mudge> it actually is hard to find some stuff on google
12:33:41 <mudge> I couldn't find a website anywhere that said quantifier logic is the same thing as predicate logic
12:34:47 <monochrom> Relatively few people say "quantifier logic". It is harder to find.
12:35:58 <ericlavigne> http://ling.kgw.tu-berlin.de/discourse&grammar/Text/d3215.htm
12:36:00 <lambdabot> Title: 3.2.1.5 The logic of there
12:36:37 * narain had never heard of "quantifier logic" before now
12:36:44 <ericlavigne> predicate logic (sometimes known as „quantifier logic")
12:38:12 <fasta> Well, it's equivalent to: \z r -> (\a1 -> \r1 -> (\a2 -> a1 . a2) (z r1) r1) ((,) r) r
12:38:28 <fasta> Not that this makes it any clearer.
12:42:59 <sjanssen> @pl \z r -> (\a1 -> \r1 -> (\a2 -> a1 . a2) (z r1) r1) ((,) r) r
12:42:59 <lambdabot> join . (. (,)) . flip flip id . (ap .) . flip ((.) . (.))
13:10:29 <fasta> Figuring out why the type of liftM (,) id is the way it is, is a nice exercise.
13:10:49 <mauke> should be easy
13:10:56 <mauke> liftM = fmap, fmap = (.)
13:11:01 <mauke> x . id = x
13:11:22 <fasta> mauke: without making use of that route
13:11:36 <sorear> @ty (liftM, (,), id)
13:11:44 <lambdabot> forall a1 r (m :: * -> *) a b a11. (Monad m) => ((a1 -> r) -> m a1 -> m r, a -> b -> (a, b), a11 -> a11)
13:11:44 <fasta> :t liftM (,)
13:11:46 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (b -> (a1, b))
13:12:06 <fasta> I wanted to see how "id" matched m a1.
13:12:24 <fasta> (but that's all clear now)
13:12:24 <mauke> m = ((->) e), a1 = e
13:12:37 <sorear> unify a1 with a, r with (b -> (a, b)), m with (->) a11
13:12:43 <mauke> id is also known as 'ask'
13:15:44 <fasta> sorear: that's a different problem.
13:20:36 <fasta> sorear: never mind, I see your intentions.
13:21:17 <axm> i am trying to find  the definition of an operator in a module i am examining ("-<<" is not standard, is it?), is there a better way than following all includes?
13:23:19 <sjanssen> axm: ghci :info
13:25:42 <axm> compiles, (interpreted), but :info -<< : not in scope
13:26:28 <jaj> :info (-<<)
13:26:55 <HairyDude> foldl is to foldl' as foldr is to ... ?
13:27:14 <mudge> what does "bottom" mean in this sentence: The value of seq a b is bottom if a is bottom, and otherwise equal to b. seq is usually introduced to improve performance by avoiding unneeded laziness.
13:27:34 <fasta> mudge: bottom = bottom
13:27:47 <mauke> literally :-)
13:27:47 <HairyDude> fasta: very helpful, like saying eggs is eggs ;)
13:27:55 <axm> jaj, yes tried that as well
13:28:00 <mauke> mudge: bottom is the unvalue
13:28:20 <mudge> an unvalue?   so does every type have a bottom?
13:28:24 <HairyDude> correct
13:28:25 <fasta> mudge: yes
13:28:36 <mudge> it is the one value that every type has?
13:28:38 <mauke> mudge: it can stand for an infinite loop, an error, etc
13:28:44 <HairyDude> :t undefined
13:28:47 <fasta> There are some movements to eredicate it, though ;)
13:28:48 <lambdabot> forall a. a
13:29:02 <mudge> :t bottom
13:29:04 <lambdabot> Not in scope: `bottom'
13:29:16 <mudge> fasta: why eradicate it?
13:29:23 <HairyDude> there must be a joke there somewhere, but I can't think of one :)
13:29:43 <HairyDude> fasta: surely that would require solving the halting problem ;)
13:29:43 <mauke> HairyDude: it involves "bottom" and (_|_)
13:29:52 <HairyDude> mauke: :)
13:30:18 <Zevv> @index popen
13:30:18 <lambdabot> bzzt
13:30:25 <Zevv> @index openPipe
13:30:25 <lambdabot> bzzt
13:30:26 <mudge> so does this sentance mean:The value of seq a b is bottom if a is bottom, and otherwise equal to b.
13:30:33 <mudge> what does that sentance mean?
13:30:51 <mauke> @hoogle Interactive
13:30:52 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
13:30:52 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
13:30:54 <sjanssen> it means "The value of seq a b is bottom if a is bottom, and otherwise equal to b." :)
13:30:59 <fasta> HairyDude: no, it doesn't. If you encode that your program terminates (which all those languages require)
13:31:03 <sjanssen> mudge: do you know what bottom is?
13:31:08 <Zevv> thanks
13:31:14 <mudge> sjanssen:  my understanding is that it is any value
13:31:19 <fasta> HairyDude: or rather that they are productive
13:31:29 <fasta> (coinductive recursion)
13:31:38 <mauke> mudge: no, any value is not bottom
13:31:39 <sjanssen> mudge: not quite.  Bottom is a value that is a member of every type
13:31:51 <mauke> if you have a specific value, it can't be bottom :-)
13:32:05 <sjanssen> mudge: some examples of bottom are: undefined, error "foo", pattern match failure, non-termination
13:32:19 <sjanssen> mudge: basically, crashing/non-terminating values
13:32:20 <mudge> okay,  so how could  a = bottom   in seq a b  ?
13:32:33 <fasta> mudge: seq undefined b
13:32:33 <sjanssen> mudge: a = undefined, is one
13:32:43 <HairyDude> anyway, can anyone answer my question?
13:32:58 <olsner> @where alex
13:32:58 <lambdabot> http://www.haskell.org/alex/
13:33:14 <sjanssen> HairyDude: I don't think foldr has a strict version -- it'd be pretty useless
13:33:22 <mudge> ah thanks buys
13:33:24 <mudge> guys
13:33:26 <HairyDude> ah
13:33:28 <HairyDude> how come?
13:33:43 <sjanssen> HairyDude: it'd use O(n) stack
13:33:49 <HairyDude> oh right
13:34:05 <sjanssen> foldr' might be useful with a structure you can traverse right to left, like an array
13:34:17 <HairyDude> but not on lists
13:34:20 <sjanssen> right
13:35:03 <HairyDude> well anyway, I squashed the space leak by using foldl' and flip.
13:41:55 <Zevv> can anybody point me to some example code using System.Process.runProcess ?
13:43:39 <Zevv> hm nevermind, its runInteractiveCommand
13:51:36 <mauke> what's a good name for an infix tuple constructor?
13:52:08 <basti_> :::?
13:52:25 <mauke> eww
13:52:38 <mauke> actually, I want a normal operator, not a constructor
13:53:01 <basti_> huh?
13:53:23 <mauke> something that doesn't start with :
13:53:50 <basti_> .::?
13:53:54 * basti_ isnt at all creative
13:54:03 <mux> mauke: (,) ? :)
13:54:09 <mauke> mux: I said infix
13:54:29 <mauke> I'm thinking of something like -->
13:54:37 <mux> isn't that infix? x,y
13:54:39 <mauke> unfortunately -> and => are already taken
13:54:42 <mux> if you omit the special syntax
13:54:44 <mauke> > 2,3
13:54:45 <lambdabot>   parse error on input `,'
13:55:04 <mux> by special syntax I mean (2,3)
13:56:15 <mauke> I want to reduce the punctuation in calls to M.fromList
13:56:17 <mux> anyways, you could maybe use <,> ?
13:56:28 <araujo> hello
13:56:44 <mauke> M.fromList ["foo" => bar] would be ideal
13:56:56 <mux> oooh
13:57:10 <mux> I see what you're looking after
13:57:15 <mux> perl-guy :)
13:57:42 <mauke> yes!
13:58:35 <mux> ~> ?
13:59:25 <Saizan_> ->:
13:59:33 <mauke> good enough
13:59:59 <mauke> it would look better with ~ in the middle of the line, though :-)
14:00:48 <davidL> depends on the font, I suppose
14:04:13 <monochrom> |-> may work
14:05:19 <mauke> YES! xmonad compiled!
14:09:55 <Saizan_> is there a smart way to check if a number in binary representation is a multiple of 3?
14:10:23 <sorear> Saizan_: yes
14:11:11 <sorear> > foldl (\n1 dg -> (n1 * 2 + dg) `mod` 3) 0 [1,1,1,0,0,0,1]
14:11:12 <lambdabot>  2
14:11:20 <HairyDude> is there a function ordinal :: Int -> String that behaves like ordinal 1 = "1st", ordinal 5 = "5th" etc?
14:11:32 <mauke> no
14:11:37 <sorear> n1 only takes the values 0, 1, 2 - this is a finite state automaton!
14:11:41 <HairyDude> hrm
14:11:51 <idnar> heh
14:12:37 <Saizan_> sorear: ooh right!
14:13:52 <sorear> > let { zer [] = 0; zer (0:x) = zer x ; zer (1:x) = one x ; one [] = 1; one (0:x) = two x; one (1:x) = zer x; two [] = 2; two (0:x) = one x; two (1:x) = two x} in zer [1,1,1,0,0,0,1] -- constant space on lazy lists!
14:13:54 <lambdabot>  2
14:14:09 <Saizan_> i wonder if i can somohow combine the automatons for 3 and 7
14:14:25 <sorear> Saizan_: sure, use the automaton for 21
14:14:39 <sorear> a number is divisible by 7 iff it is 0, 7, or 14 mod 21
14:14:54 <sorear> a number is divisible by 3 iff it is 0, 3, 6, 9, 12, 15, or 18 mod 21
14:15:04 <monochrom> Chinese Remainder Theorem.
14:15:41 <sorear> what monochrom said
14:15:43 <Saizan_> but i need 20 states then
14:15:55 <sorear> no, you need 21
14:16:05 <monochrom> Yes, state space multiplies up.
14:16:18 <sorear> remember, with careful coding you only need lg|#states| memory
14:16:39 <Saizan_> however i need to accept numbers divisible by 3 "or" 7
14:16:55 <sorear> ... use 21 states?
14:17:52 <Saizan_> yeah, i see
14:19:23 <Cheery> how human sees pixels?
14:20:02 <Cheery> this thought came up to my mind when I started to wonder with very small pixel sequences that represent strokes
14:20:40 <Cheery> I can't stop seeing one stroke as two that I thought would be one single stroke when I drew it from close
14:23:51 <Cheery> only 4x4 sawline horizontal stroke starts to seem like 4x4 sawline horizontal stroke
14:26:42 <sorear> Cheery: the human brain doesn't see pixels; a 1e-6 steradian vertical line looks more different from a 1e-6 steradian horizontal line than a 1e-6 steradian horizonal line offset by 1e-1 radians, even though a L^2 norm gives the opposite result
14:26:50 <dons> ?yow
14:26:50 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
14:26:57 * sorear loves steradians and uses them every chance he gets
14:26:59 <dons> ?quit bizarro
14:27:25 <Saizan_> sorear: can you point me to a page that shows how to derive those divisibility rules from the chinese remainder theorem?
14:29:16 <sorear> Saizan_: Not sure...  a number is divisible by 2 iff it is 0, 2, 4, 6, or 8 mod 10 (I'm sure you were taught this quite early), this is a logical extension of that
14:29:57 <monochrom> You need an introduction to number theory.
14:30:00 <Cheery> good night
14:30:07 <Saizan_> i've never been taught any of this
14:30:44 <monochrom> Teachers used to teach that 30 years ago.
14:32:49 <Saizan_> maybe i could use trial division, but it seems a bit tedious on a turing machine
14:33:05 <monochrom> Anyway, http://www.aw-bc.com/rosen/ is one, and it seems programmer-friendly.
14:33:07 <lambdabot> Title: rosenWebsite
14:33:53 <sorear> you were never taught that even numbers have even final digits?!
14:34:29 <monochrom> It is the Calculator Age, sorear. No one teaches that. Actually even the teachers don't know that, probably.
14:34:52 <Saizan_> ah, 8 mod 10 means even final digit?
14:35:17 * sorear sighs deeply
14:35:39 <sorear> (0, 2, 4, 6, or 8) mod 10
14:35:40 <sorear> NOT
14:35:45 <sorear> 0, 2, 4, 6, or (8 mod 10)
14:35:58 <monochrom> By the year 2030, only PhDs in Math know why how to add.
14:36:09 <monochrom> s/why//
14:36:25 * Saizan_ feels dumb
14:36:44 * mrd is dumb
14:36:53 <Saizan_> ok, that makes sense
14:37:10 <Saizan_> now i'd try to generalize to 3 and 7
14:37:23 <jcreigh> monochrom: I don't think so. Lots of people now know how to add, and odds are at least some of them will be alive in 2030.
14:37:34 <monochrom> 10 = 2*5, 2 and 5 coprime.  21 = 3*7, 3 and 7 coprime.
14:37:54 <mrd> yea but i'll be ~50.  how is that 'alive'?
14:38:30 <sorear> jcreigh: you're forgetting the part where communist extremests stage a coup and use the military to kill everyone with an IQ over 70
14:38:43 <sorear> ideological threats, y'know
14:39:06 <monochrom> I guess the extremists themselves have IQ below 70, too. :)
14:40:26 <Zevv> Can I use takeWhile to take everything from a list up to a certain pattern ? for example, when the list is [1,2,3,4,5,0,0,0,0,6,5,4,,], I want to takeWhile until the last elements are [0,0,0,0], thus returning [1,2,3,4,5]
14:40:27 <Cale> sorear: The joke will be on them, since IQ of 100 is normalised to the average score of the population. :)
14:40:27 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:40:57 <Cale> Zevv: you can if you use tails first
14:41:17 <Zevv> @index tails
14:41:17 <lambdabot> Data.List
14:41:31 <Zevv> Ok, I'll look into that. Thanks
14:41:47 <omnIdiot> > map head . takeWhile ((/= [0,0,0,0] . take 4) . tails $ [1,2,3,4,5,0,0,0,0,6,7]
14:41:48 <lambdabot>  Unbalanced parenthesis
14:41:48 <Cale> > map head . takeWhile ((/=[0,0,0]) . take 3) . tails $ [1,2,3,4,5,0,0,0,0,6,5,4]
14:41:50 <lambdabot>  [1,2,3,4,5]
14:41:58 <monochrom> That will be a very sad joke, since there will be no end to the killings.
14:42:33 <monochrom> 1. Normalize. 2. Cleanse. 3. Repeat.
14:43:01 <Cale> Of course, you should be careful about the way I just did that...
14:43:05 <Cale> > map head . takeWhile ((/=[0,0,0]) . take 3) . tails $ [1,2,3,4,5,0,1,0,0,6,5,4]
14:43:05 <mrd> monochrom: it'll end in log(population) time!
14:43:06 <lambdabot>  Exception: Prelude.head: empty list
14:43:09 <monochrom> Instructions printed on the Anti-Intellectual Shampoo!
14:43:13 <sphynx> hi all!
14:43:17 <olsner> perhaps, just *perhaps* that was sorear's original point... but I doubt he thought that far ;-)
14:43:46 <Zevv> Cale: that's not going to work for an infity input list, is it ?
14:43:47 <Cale> > map head . takeWhile (\x -> take 3 x /= [0,0,0] && not (null x)) . tails $ [1,2,3,4,5,0,1,0,0,6,5,4]
14:43:48 <lambdabot>  [1,2,3,4,5,0,1,0,0,6,5,4]
14:43:56 <Cale> Zevv: sure it will
14:44:01 <Cale> > map head . takeWhile (\x -> take 3 x /= [0,0,0] && not (null x)) . tails $ [1..]
14:44:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:44:03 <sorear> Cale: iirc, the normalization is only done every 10 years, and only if the IQ committee is still alive
14:44:22 <Cale> sorear: haha
14:44:32 <Zevv> Amazing, still
14:44:38 <omnIdiot> > take 3 []
14:44:40 <lambdabot>  []
14:44:50 <omnIdiot> Cale: s/map head/concat . map (take 1)/ ?
14:44:53 <monochrom> Oh, so our IQ-100 people are already dumber than those IQ-100 people 200 years ago?
14:44:59 <Cale> omnIdiot: that'd also work
14:44:59 <mrd> the brain monsters will invade and suppress the brain waves of everyone on earth, making them stupider
14:46:06 <monochrom> Anyway, this future doesn't bode well for Haskell. We need people good enough to learn monads!
14:46:27 <mrd> name your kid "Monad"
14:46:32 <sphynx> I wonder why mu do synatx doesn't work without 'in': do_doesnt_work = do {g <- newStdGen; let s = generate 1000 g genExpr ; putStrLn s; }
14:46:38 <olsner> perhaps they'll have to invent simpler programming languages instead :P
14:46:47 <sphynx> but this works: do_doesnt_work = do {g <- newStdGen; let s = generate 1000 g genExpr in putStrLn s; }
14:47:11 <sphynx> and it works without 'in' when is placed on multiple lines without {}
14:47:14 <mrd> sphynx: ha ran into that today too
14:47:19 <sorear> monochrom: actually, for all of recent history the IQ scores have had to be normalized *down*. I doubt this will last much longer...
14:47:20 <mrd> it's ambiguous that's why
14:47:23 <omnIdiot> sphynx: the first should work, what's the error?
14:47:49 <mrd> is it let { ... ; ... } or: do { let ... ; ... }
14:47:53 <sphynx> *Main> do {g <- newStdGen; let s = generate 1000 g genExpr; putStrLn s; }
14:47:53 <sphynx> <interactive>:1:63: parse error on input `;'
14:48:00 <monochrom> I am not sure which direction "normalize down" goes.
14:48:19 <omnIdiot> do { let ... ; ... } is shorthand for let { ... } in do { ... }
14:48:34 <monochrom> IQ-120 in the past becomes IQ-100 now, like that?
14:48:52 <olsner> hmm... if haskell people were dumber, would haskell be easier?
14:48:53 <mrd> doing the exact same thing with generate too
14:49:02 <mrd> i ended up doing: newStGen >>= \g -> generate ...
14:49:08 <sphynx> I thought that let in do {} works in all following expressions
14:49:14 <omnIdiot> sphynx: odd...
14:49:34 <sphynx> yeah, I can fix it too, but I just want to know why it works in such a strange manner
14:50:03 <omnIdiot> sphynx: try deleting the last ; before the }
14:50:15 <sphynx> omnIdiot: tried already )
14:50:22 <allbery_b> <olsner> hmm... if haskell people were dumber, would haskell be easier?
14:50:31 <allbery_b> no, just means the haskell people would be the simons and oleg :)
14:50:44 <omnIdiot> @type do {g <- newStdGen; let s = ?generate 1000 g ?genExpr; putStrLn s}
14:50:46 <lambdabot> parse error on input `}'
14:51:07 <allbery_b> and the rest of you would be like me, scratching my fleabitten fur from themouth of my cave
14:51:11 <omnIdiot> (no ?name in @type?)
14:51:17 <omnIdiot> @type ?x
14:51:19 <lambdabot> forall t. (?x::t) => t
14:51:33 <sphynx> *Main> do {g <- newStdGen; let s = generate 1000 g genExpr; putStrLn s}
14:51:33 <sphynx> <interactive>:1:63: parse error on input `}'
14:51:41 <allbery_b> try a semicolon before the }
14:51:46 <allbery_b> just for grins
14:51:54 <allbery_b> I seem to recall the parser used for this stuff is kinda dumb
14:51:56 <omnIdiot> allbery_b: he had it that way first :)
14:51:58 <sphynx> mm, that was a first variant :)
14:52:00 <allbery_b> oh
14:52:02 <mrd> do {g <- newStdGen; let s = { generate 1000 g genExpr }; putStrLn s }
14:52:23 <omnIdiot> @type do {g <- newStdGen; let { s = ?generate 1000 g ?genExpr }; putStrLn s }
14:52:25 <lambdabot> (?genExpr::t_a2ul, ?generate::Integer -> StdGen -> t_a2ul -> String) => IO ()
14:52:31 <omnIdiot> there we are.
14:52:34 <allbery_b> oh right, nested let
14:52:42 <mrd> do you see why it is ambiguous without the nested brackets?
14:52:51 <omnIdiot> *shrug*
14:52:56 <sphynx> *Main> do {g <- newStdGen; let s = { generate 1000 g genExpr }; putStrLn s}
14:52:56 <sphynx> <interactive>:1:28: parse error on input `{'
14:53:00 <allbery_b> well, that particular parser rule is just a bit insane
14:53:07 <sorear> monochrom: yes
14:53:12 <omnIdiot> sphynx: move the { before "s ="
14:53:13 * mrd agrees
14:53:21 <dons> ooh, http://web.mac.com/malcolm.wallace/HaskellWorkshop.html
14:53:22 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
14:53:29 * mrd wouldn't construct a ghci stmt this way, but anyway
14:53:32 <mrd> how is Hac going
14:53:41 <dons> list of accepted videos!
14:53:54 <dons> mrd: rocking it. we're going to blow up ruby tomorrow
14:54:14 <omnIdiot> sphynx: The parser must think that the semi after "let s = ..." introduces another name in the let's decl list.
14:54:34 <mrd> dons: blow up ruby again?
14:54:37 <omnIdiot> let's can define multiple names
14:55:42 <omnIdiot> sphynx: if this were multiple lines, layout would tell it to end the let's decl list and start a new do statement.
14:56:29 <sphynx> omnIdiot: so it's unclear if last third statement is belong to second or not?
14:56:34 <omnIdiot> do { s1 ; let s = x ; s2 } parses as do { s1 ; let { s = x ; s2 } }
14:56:57 <sphynx> omnIdiot: yean, I mean the same
14:57:42 <sphynx> omnIdiot: ok, it's clear now. Thanks!
14:58:08 <dons> http://programming.reddit.com/info/2xbrh/comments/c2xbrm?context=5
14:58:10 <lambdabot> Title: Programming old school modular synthesizers in Haskell :: Video (reddit.com), http://tinyurl.com/2p4c9d
15:12:03 <SamB> hmm, I think knuth got fix 420 for TeX wrong...
15:12:19 <SamB> I think it should say "after the last user's death"
15:14:05 <dons> i'm really fired up about the hackathon, and haskell. hw + icfp + cufp + hackathon is great motivation
15:14:31 <dons> let's build better software, now! we've got all the tools. keep away from those side effects, don't be tempted!
15:17:39 <sieni> did anyone meet timo lilja there? dons?
15:24:01 <dons> oh , yes , i saw his talk
15:25:46 <sieni> I work at the same company
15:26:17 <sieni> our boss was supposed to go there originally I think, but then Timo went there
15:50:38 <FMota> > ap(++)show"ap(++)show"
15:50:43 <lambdabot>  "ap(++)show\"ap(++)show\""
15:50:46 <FMota> :)
15:52:22 <idnar> heh
15:53:32 <FMota> > ap(++)id"ap(++)show"
15:53:34 <lambdabot>  "ap(++)showap(++)show"
15:53:39 <FMota> oops
15:53:53 <FMota> ap(++)id"ap(++)show\""
15:54:03 <oerjan> putStr$ap(++)show"putStr$ap(++)show" works if you have IO
15:54:12 <FMota> > ap(++)id"ap(++)show\""
15:54:13 <lambdabot>  "ap(++)show\"ap(++)show\""
15:54:17 <FMota> :)
15:54:20 <FMota> a quine-generator XD
15:54:56 <omnIdiot> ap(++)id = join(++)
15:55:16 <FMota> > join(++)"ap(++)show\""
15:55:17 <lambdabot>  "ap(++)show\"ap(++)show\""
15:55:22 <FMota> good point.
15:55:54 <mauke> import Control.Monad.Reader;main=putStrLn$ap(++)show"import Control.Monad.Reader;main=putStrLn$ap(++)show"
15:56:03 <FMota> :)
15:56:50 <oerjan> @list id
15:56:50 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
15:56:58 <oerjan> @help read
15:56:58 <lambdabot> read "<foo>". Print <foo>
15:57:09 <omnIdiot> @read "blah"
15:57:09 <lambdabot>  blah
15:57:35 <oerjan> with that you can almost make a quine
15:58:13 <omnIdiot> @read "ap(++)show\"@read ap(++)show\""
15:58:13 <lambdabot>  ap(++)show"@read ap(++)show"
15:58:16 <kpreid> @pl (\x -> "> " ++ x ++ show x)
15:58:16 <lambdabot> ("> " ++) . ap (++) show
15:58:20 <oerjan> @. read run ap (++) join "@. read run ap (++) join "
15:58:21 <lambdabot> Plugin `compose' failed with: IRCRaised Prelude.read: no parse
15:58:23 <kpreid> @pl (\x -> "> " ++ x ++ show x) "foo"
15:58:23 <lambdabot> "> foo" ++ show "foo"
15:59:00 <kpreid> @pl (\x -> "> " ++ x ++ "y" show x ++ "z") "foo"
15:59:00 <lambdabot> "> foo" ++ show "foo" ++ "z"
15:59:01 <oerjan> @run ap (++) join "@. read run ap (++) join "
15:59:02 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
15:59:02 <lambdabot>       Expected...
15:59:10 <kpreid> @pl (\x -> "> " ++ x ++ "y" show x ++ "z")
15:59:10 <lambdabot> ("> " ++) . ap (++) ((++ "z") . show)
15:59:18 <omnIdiot> oerjan: s/join/show/
15:59:23 <oerjan> er, yeah
15:59:32 <oerjan> @. read run ap (++) show "@. read run ap (++) show "
15:59:33 <lambdabot>  @. read run ap (++) show "@. read run ap (++) show "
15:59:39 <omnIdiot> awesome :)
15:59:49 <FMota> XD
15:59:55 <kpreid> @pl (\x -> "> " ++ x ++ "y" ++ show x ++ "z")
15:59:55 <lambdabot> ("> " ++) . ap (++) (('y' :) . (++ "z") . show)
16:00:04 <FMota> ap is very useful. :)
16:00:19 <omnIdiot> Monad ((->) r) is very useful
16:00:20 <FMota> ...for useless things
16:00:41 <kpreid> > ("> " ++) . ap (++) ((" $ " ++) . show) $ "(\"> \" ++) . ap (++) ((" $ " ++) . show)"
16:00:42 <lambdabot>  Couldn't match expected type `a -> b'
16:00:54 <kpreid> > ("> " ++) . ap (++) ((" $ " ++) . show) $ "(\"> \" ++) . ap (++) ((\" $ \" ++) . show)"
16:00:55 <lambdabot>  "> (\"> \" ++) . ap (++) ((\" $ \" ++) . show) $ \"(\\\"> \\\" ++) . ap (++)...
16:01:32 <kpreid> @. run read ("@. run read " ++) . ap (++) ((" $ " ++) . show) $ "(\"> \" ++) . ap (++) ((\" $ \" ++) . show)"
16:01:32 <lambdabot> Plugin `compose' failed with: IRCRaised Prelude.read: no parse
16:01:50 <kpreid> @. read run ("@. read run " ++) . ap (++) ((" $ " ++) . show) $ "(\"> \" ++) . ap (++) ((\" $ \" ++) . show)"
16:01:52 <lambdabot> Plugin `compose' failed with: IRCRaised Prelude.read: no parse
16:01:59 <kpreid> eh, never mind :)
16:02:02 <oerjan> i recall last time i tried to make a palindromic quine but couldn't fit it within the limit
16:02:13 <omnIdiot> > [id, (+3), (/2)] `ap` [4, 8] -- ap is good for non-useless things, too
16:02:14 <lambdabot>  [4.0,8.0,7.0,11.0,2.0,4.0]
16:03:52 <kpreid> > (\x -> x ++ show x ++ "--" ++ reverse (show x) ++ reverse x) "(\x -> x ++ show x ++ "--" ++ reverse (show x) ++ reverse x)"
16:03:52 <lambdabot>  Illegal escape sequence
16:04:01 <mudge> I'm writing a simple web server and when the browser connects to my server the browser gives this error: The connection to the server was reset while the page was loading.
16:04:09 <kpreid> > (\x -> x ++ show x ++ "--" ++ reverse (show x) ++ reverse x) "(\\x -> x ++ show x ++ \"--\" ++ reverse (show x) ++ reverse x)"
16:04:10 <lambdabot>  "(\\x -> x ++ show x ++ \"--\" ++ reverse (show x) ++ reverse x)\"(\\\\x -> ...
16:04:18 <oerjan> @where+ quine @. where id quine
16:04:19 <lambdabot> Done.
16:04:20 <mudge> anyone know why it is doing that?
16:04:25 <mudge> just asking
16:04:26 <oerjan> @. where id quine
16:04:27 <lambdabot>  @. where id quine
16:04:31 <oerjan> bah
16:04:43 <kpreid> @. read run (\x -> x ++ show x ++ "--" ++ reverse (show x) ++ reverse x) "(\\x -> x ++ show x ++ \"--\" ++ reverse (show x) ++ reverse x)"
16:04:43 <oerjan> @where quine
16:04:44 <lambdabot> Plugin `compose' failed with: IRCRaised Prelude.read: no parse
16:04:44 <lambdabot>  @. where id quine
16:04:47 <omnIdiot> > getZipList $ ZipList [id, (+3), (/2)] <*> ZipList [4, 8, 12] -- generic zipping
16:04:48 <lambdabot>  [4.0,11.0,6.0]
16:04:55 <mudge> oerjan,  you familiar with writing any web server stuff?
16:04:59 <oerjan> i thought where didn't add a space, they must have changed it
16:05:07 <oerjan> mudge: absolutely not
16:05:11 <chessguy> mudge, sounds to me like the socket is getting closed before the request is fully served
16:05:19 <oerjan> i only do impractical things
16:05:36 <oerjan> at best
16:05:51 <mudge> chessguy: yikes,  I wonder if there is a way to keep the socket open for a period of time
16:05:56 <chessguy> @remember oerjan i only do impractical things
16:05:57 <lambdabot> Done.
16:05:59 <EvilTerran> main = putStr s >> print s where s = "main = putStr s >> print s where s = "
16:06:23 <oerjan> @where+ quine @where quine
16:06:23 <lambdabot> Done.
16:06:29 <chessguy> mudge, dumb question, are you writing it in haskell?
16:06:30 <oerjan> @where quine
16:06:30 <lambdabot>  @where quine
16:06:39 <mudge> chessguy: yea
16:06:44 <mudge> chessguy: of course
16:07:05 <kpreid> @type  mapM_ ($ s) [putStr, print]
16:07:07 <lambdabot> Not in scope: `s'
16:07:16 <kpreid> @type \s -> mapM_ ($ s) [putStr, print]
16:07:16 <chessguy> mudge, ok, just making sure. i just got here, so i don't know what the conversation has been, if anything. you might try looking at some other web servers written in haskell
16:07:17 <lambdabot> String -> IO ()
16:07:26 <chessguy> @where hope
16:07:27 <lambdabot> http://hope.bringert.net/
16:07:32 <kpreid> @pl \s -> mapM_ ($ s) [putStr, print]
16:07:32 <lambdabot> flip mapM_ [putStr, print] . flip id
16:07:36 <chessguy> i believe that has a web server built in
16:07:36 <omnIdiot> main = liftM2 (>>) putStr print "main = liftM2 (>>) putStr print" -- if only instance Monad ((->) r) were standard
16:07:59 <mudge> chessguy: thanks     i did a forkIO to handle the request,     maybe the thread dies before it can finish
16:08:01 <chessguy> @where wash
16:08:01 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
16:08:16 <chessguy> that also has a web server component
16:08:57 <chessguy> @where happs
16:08:57 <lambdabot> http://happs.org
16:09:10 <chessguy> there's also that one, of course
16:10:03 <oerjan> @type  mapM_ ($ ?s) [putStr, print] -- kpreid, this is a common lambdabot @type trick
16:10:05 <lambdabot> (?s::String) => IO ()
16:10:12 <kpreid> I know
16:12:15 <oerjan> > runReader$ap(++)(Reader show)$Reader"runReader$ap(++)(Reader show)$Reader"
16:12:16 <lambdabot>  Couldn't match expected type `[a] -> [a]'
16:12:47 <oerjan> hm...
16:13:02 <oerjan> oh
16:13:22 <oerjan> > runReader$ap(Reader(++))(Reader show)$Reader"runReader$ap(Reader(++))(Reader show)$Reader"
16:13:23 <lambdabot>  Couldn't match expected type `a -> a1 -> b'
16:13:56 <oerjan> > runReader$ap(Reader(++))(Reader show)"runReader$ap(Reader(++))(Reader show)"
16:13:56 <lambdabot>  Couldn't match expected type `t -> a1 -> Reader r a'
16:14:57 <mudge> hey can someone go here and tell me what they see: http://24.7.167.34:1250/
16:15:07 <mudge> that's test my webserver
16:15:13 <mudge> that'll*
16:15:16 <LoganCapaldo>  omg mudge hacked me
16:15:22 <LoganCapaldo> computer crashing
16:15:26 <LoganCapaldo> arrrrrg
16:15:28 <mudge> really?
16:15:38 <LoganCapaldo> naw :)
16:15:48 <mudge> did you get an error,  or did it actually work?
16:15:52 <LoganCapaldo> although it is taking a really long time to load...
16:15:54 <jeffz> mudge: half worked.
16:15:59 <LoganCapaldo> so I don't really have anything yet
16:16:43 <mudge> jeffz: what did you see?
16:16:49 <omnIdiot> "This is my first attempt at a web server!"
16:16:54 <mudge> did anyone get a connection reset error?
16:17:00 <mudge> omnIdiot:  great!
16:17:02 <Nafai> I'm reading the Haskell 98 Report, in Section 1.3 it says "Values and types are not mixed in Haskell." What does it mean for values and types to be mixed?
16:17:11 <LoganCapaldo> I still can't get it to load :(
16:17:16 <mudge> damn
16:17:19 <LoganCapaldo> I'm surprised it's not timing out
16:17:21 <jeffz> mudge: http://jeffz.name/mudge.png
16:17:43 <chessguy> mudge, works for me in firefox
16:17:50 <omnIdiot> mudge: it took a few reloads
16:17:56 <LoganCapaldo> oh maybe safari is dealing less gracefully than links / firefox
16:18:01 <mudge> thanks
16:18:05 * LoganCapaldo tries in FF
16:18:09 <oerjan> > (runReader$ap(Reader(++))(Reader show))"(runReader$ap(Reader(++))(Reader show))"
16:18:11 <lambdabot>  "(runReader$ap(Reader(++))(Reader show))\"(runReader$ap(Reader(++))(Reader s...
16:18:26 <mudge> jeffz:  got a the reset by peer error,
16:18:29 <mudge> thanks jeffz
16:18:30 <oerjan> bah
16:18:45 <chessguy> mudge, looks like IE is going to time out
16:18:55 <mudge> this server is not used to this much traffic
16:19:03 <mudge> lol
16:19:10 <mudge> chessguy: okay
16:19:29 <LoganCapaldo> reader quine
16:19:41 <mudge> I might be getting that reset error because I'm not reading in any data from the browser
16:19:46 <mudge> maybe
16:19:49 <oerjan> Nafai: for example if you can define a type of arrays that have a given length, where that length is the value of a variable
16:19:49 <LoganCapaldo> > "string quine"
16:19:50 <lambdabot>  "string quine"
16:19:59 <oerjan> it's called dependent types
16:20:10 <LoganCapaldo> I can't get it to work with ff looks like :(
16:20:14 <LoganCapaldo> sorry
16:20:34 <Nafai> oerjan: Okay, thanks
16:20:46 <mudge> LoganCapaldo:  I restarted the server
16:20:49 <oerjan> in haskell, a type cannot include information about a variable beyond its type
16:21:06 <LoganCapaldo> yay firefox likes it
16:21:08 <mudge> make sure you use port 1250 :  http://24.7.167.34:1250/
16:21:26 <mudge> LoganCapaldo:  cool, thanks
16:21:33 <LoganCapaldo> safari continues not to
16:22:58 <allbery_b> safari doesn't like it much here either
16:24:11 <allbery_b> hrm
16:24:35 <allbery_b> tcpdump shows a bunch of SYN packets going out with no response
16:25:09 <mudge> allbery_b  i turned the server off for a second
16:25:11 <allbery_b> that seems a bit lower level than safari, somehow
16:25:39 <mudge> allbery_b:  just turned it back on
16:25:47 <idnar> @src on
16:25:48 <lambdabot> (*) `on` f = \x y -> f x * f y
16:26:03 <idnar> @src comparing
16:26:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:26:20 <oerjan> wow, it's in?
16:26:25 <oerjan> > on
16:26:26 <lambdabot>   Not in scope: `on'
16:26:34 <oerjan> well not there...
16:26:44 <oerjan> :t on
16:26:45 <lambdabot> Not in scope: `on'
16:26:57 <oerjan> :t Data.Function.on
16:26:59 <lambdabot> Couldn't find qualified module.
16:27:08 <dmwit> ?index on
16:27:08 <lambdabot> bzzt
16:27:15 <omnIdiot> > sortBy (compare `on` snd) [('a',3), ('b',1), ('c',2)]
16:27:16 <allbery_b> ok. getting a response but safari says the werver reset the conenction
16:27:16 <lambdabot>   Not in scope: `on'
16:27:18 <allbery_b> server
16:27:31 <omnIdiot> @let on f g x y = f (g x) (g y)
16:27:34 <omnIdiot> > sortBy (compare `on` snd) [('a',3), ('b',1), ('c',2)]
16:27:36 <lambdabot>   Not in scope: `on'
16:27:41 <lambdabot> Defined.
16:27:46 <mauke> haha
16:27:47 <omnIdiot> >.>
16:27:48 <dmwit> heh
16:27:52 <omnIdiot> > sortBy (compare `on` snd) [('a',3), ('b',1), ('c',2)]
16:27:53 <lambdabot>  [('b',1),('c',2),('a',3)]
16:27:53 <oerjan> race condition
16:28:04 <idnar> hmm
16:28:26 <allbery_b> hm
16:28:33 * allbery_b wonders how pedantic safari is
16:28:33 <idnar> is it inefficient to do something like this: maximumBy (compare `on` expensiveFunction) listOfStuff
16:28:55 <oerjan> idnar: i brought that up here earlier
16:29:01 <allbery_b> you're sending newlines.  pedantically, you're supposed to send CRLFs
16:29:07 <oerjan> afaik, yes
16:29:12 <omnIdiot> idnar: as efficient as: maximumBy (\x y -> compare (expensiveFunction x) (expensiveFunction y))
16:29:14 <dmwit> idnar: Python has this "decorate/sort/undecorate" idiom that seems to apply well to that case.
16:29:28 <idnar> so I guess I'll do
16:29:37 <sorear> idnar: O(n) calls to expensiveFunction
16:29:55 <idnar> maximumBy (compare `on` snd) $ map (\x -> (x. expensiveFunction x)) listOfStuff
16:29:57 <dmwit> idnar: Never mind me, that's apparently unnecessary.
16:30:00 * allbery_b also suspects other noncompliances with http-1.1
16:30:03 <oerjan> sorear: O(n log n)
16:30:06 <mudge> allbery_b: thanks for the info
16:30:18 <omnIdiot> (\x -> (x, expensiveFunction x)) = (id *** expensiveFunction)
16:30:23 <sorear> oerjan: false; are you thinking of sort?
16:30:23 <oerjan> it doesn't memo it
16:30:29 <oerjan> oh wait
16:30:30 <omnIdiot> s/***/&&&/
16:30:32 <sorear> @src maximumBy
16:30:32 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:30:33 <oerjan> er, yeah
16:30:34 <allbery_b> there are several required headers in http-1.1
16:30:46 <mudge> allbery_b:  I wonder if the reset error comes up because the server does not read any of the data given to the web server and instead just gives the browser the page
16:30:56 <allbery_b> no
16:31:12 <allbery_b> I'm guessing it's looking for a header you're not sending
16:31:19 <mudge> ah,  that could be
16:31:33 <oerjan> still, you could save some reevaluation even with maximumBy
16:31:34 <allbery_b> firefox tends to be more laissez-faire aout such things (behavior inherited from netscape)
16:31:46 <oerjan> if the maximum is first, say
16:31:48 <idnar> expensiveFunction is a recursively defined function, but I couldn't find an easy way to memoize it
16:32:10 <idnar> (it's actually collatzSequence)
16:32:19 <allbery_b> just for grins you could try identifying as http-1.0 instead
16:32:26 <oerjan> idnar: anyway, your `on` snd trick is what i thought of as well
16:33:29 <mudge> allbery_b,  good idea,   i'll do that right now
16:33:48 <oerjan> yeah, you would need arrays (for a finite set of values) or tries
16:33:49 <allbery_b> (some of the newer browsers do't support 1.0 any more, though)
16:33:53 <idnar> I tried doing something like: collatz = ((map collatz' [0..]) !!) where collatz' = ...
16:34:01 <mudge> allbery_b:  now identifies with 1.0
16:34:25 <allbery_b> hm, nope, still doesn't like it
16:34:39 * allbery_b doesn't recall what http-1.1 requires
16:34:44 <idnar> but the problem is, if you want collatz n, that'll force evaluation of collatz n - 1, n - 2, etc. even if those results aren't otherwise needed
16:34:53 <allbery_b> and, oh duh, 1.0 would not have been enough to escape required headers
16:34:59 <allbery_b> 0.9 would but support for that is long dead
16:35:04 <idnar> which was producing a massive memory explosion
16:35:41 <oerjan> idnar: actually it won't force the values themselves only the list cons cells
16:35:53 <oerjan> but that's still bad
16:36:10 <idnar> oh yeah, true
16:36:49 <idnar> anyhow, calculating, say, collatz 999999 was causing memory consumption over 1.2GB
16:36:58 <oerjan> besides, looking up with !! is expensive, you want arrays at least
16:37:23 <oerjan> in fact it may be even worse since those values are then left as thunks
16:37:37 <sorear> digit tries FTW
16:37:46 <sorear> ?oldwiki MemoizingCafs
16:37:46 <lambdabot> http://www.haskell.org/hawiki/MemoizingCafs
16:37:52 <sorear> uhm..
16:37:53 <sorear> :(
16:37:57 <oerjan> idnar: an option is to memoize only _part_ of the range
16:38:51 <idnar> sorear: hmm, that page doesn't even seem to be archived anywhere
16:39:07 <sorear> idnar: try british ising, and CAFs
16:39:15 <davidL> If unsort :: RandomGen g => g -> [a] -> [a] why doesn't this work: foo m = unsafePerformIO $ newStdGen >>= (\g -> return . unsort g [1..m^2])
16:39:32 <Cale> idnar: really?
16:39:40 <Cale> idnar: how was your collatz function implemented?
16:39:42 <sorear> because you used unsafePerformIO without satisfying the proof obligation?
16:40:01 <Cale> idnar: oh, sorry, I hadn't read :)
16:40:26 <hpaste>  idnar pasted "collatz" at http://hpaste.org/3122
16:40:28 <sorear> davidL: looks like it should
16:40:33 <idnar> just so we're clear ;)
16:40:42 <sorear> davidL: oh wait, bad use of .
16:40:51 <sorear> davidL: you need $ there
16:41:01 <davidL> ugh. thanks sorear
16:41:02 <idnar> oerjan: yeah, I thought of that, but I was wondering if there wasn't a better way to go about it
16:41:30 <mudge> allbery_b: I wonder what http 1.1 headers are required
16:41:35 <sorear> davidL: but note that thanks to full-laziness that may or may not use the same seed each time
16:41:41 <idnar> (er, that doesn't actually generate the sequences, just the length)
16:41:41 <allbery_b> I don't recall, for servers
16:41:51 <allbery_b> I know clients are required to send Host:
16:41:53 <oerjan> idnar: you could use an infinite trie, it's tree-based so only log n overhead to how many items you look at, i think
16:41:57 <sorear> davidL: best to avoid storing your guns loaded and pointed down
16:42:20 <oerjan> though i couldn't find any infinite trie implementation on hackage when i looked
16:42:28 <allbery_b> but I tend to use other people's servers rather than reinventing the wheel, because with stuff like web servers it invariably comes out some shape that is almost but not quite unlike round
16:42:46 <davidL> sorear: I want to have a different seed every time
16:43:36 <sorear> davidL: then don't use unsafePerformIO :P
16:44:43 <davidL> but isn't all of System.Random bound to the IO monad?
16:44:49 <oerjan> davidL: no.
16:44:57 <oerjan> :t random
16:44:59 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
16:45:24 <oerjan> that function takes a generator in and passes it out.  can be used with any state monad
16:45:39 <oerjan> or explicitly
16:45:52 <oerjan> *it = the new one
16:46:13 <oerjan> only the initial generator usually needs to be got from IO
16:46:51 <mudge> allbery_b: maybe it because i'm using "/n" instead of "/r/n"  in the headers
16:46:53 <davidL> ah, ok I see now
16:47:04 <oerjan> @src Random
16:47:04 <lambdabot> class Random a where
16:47:04 <lambdabot>   random    :: RandomGen g => g -> (a, g)
16:47:04 <lambdabot>   randoms   :: RandomGen g => g -> [a]
16:47:04 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
16:47:04 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
16:47:06 <lambdabot>   randomRIO :: (a,a) -> IO a
16:47:08 <lambdabot>   randomIO  :: IO a
16:47:35 <oerjan> the first four methods are for pure use
16:47:52 <allbery_b> mudge: that was actually the first one I mentioned
16:47:54 <idnar> oerjan: strangely enough, partial memoization seems to make it slower than no memoization at all (and I'm not running out of memory)
16:48:09 <allbery_b> although I've also been thinking that's also onme of the first things browsers usually adjust for automatically
16:48:32 <idnar> oerjan: but I guess I shouldn't be using a list
16:48:34 <allbery_b> [19:28] <allbery_b> you're sending newlines.  pedantically, you're supposed to send CRLFs
16:48:43 <oerjan> idnar: definitely not
16:48:48 <oerjan> use an array
16:49:10 <idnar> oerjan: I'm not quite sure how the code for that should look, though
16:49:15 <mudge> allbery_b:  I just restarted it using CRLFs
16:49:37 <allbery_b> huh.  works now
16:49:41 <allbery_b> sad.
16:49:48 <mudge> allbery_b:  in safari?
16:49:48 <allbery_b> wonder if it's worth a bug report to apple
16:49:50 <allbery_b> yep
16:49:56 <mudge> wow!,   rad
16:50:00 <mudge> that was it
16:50:02 <mudge> geeps
16:50:19 <mudge> allbery_b: yea it is kind of sad that safari won't adjust for /n
16:51:40 <idnar> oh here we go
16:51:46 <idnar> ok, that's a massive improvement
16:53:12 <Cale> Prelude Data.List> map (\x -> (head x, length x)) . group . sort . map (log2 . head . filter powerOfTwo . collatz) $ [1..100000]
16:53:12 <Cale> [(0,1),(1,1),(2,1),(3,93744),(4,1),(5,14),(6,1),(7,2473),(8,1),(9,3692),(10,1),(11,8),(12,1),(13,16),(14,1),(15,42),(16,1),(17,1)]
16:53:27 <oerjan> yeah, array lookups are O(1) while list lookup is O(n)
16:53:36 <mudge> jeffz,  you there?
16:53:48 * allbery_b i almost tempted to go fire up vmware on the laptop and see if safari3 (well, the new webkit at least) also does that
16:54:13 <mudge> allbery_b: that would be cool
16:54:32 * idnar tweaks the upper bound downwards
16:54:40 <Cale> Kind of interesting how 2^3 is so much more common a power of two than anything else there.
16:54:48 <jeffz> mudge: aye.
16:55:02 <mudge> would you check http://24.7.167.34:1250/  in that browser of yours?
16:55:13 <mudge> i think it might be fixed now
16:55:15 <jeffz> mudge: same.
16:55:23 <mudge> damn,   same error?
16:55:28 <jeffz> mudge: yes
16:55:39 <jeffz> mudge: are you implementing http?
16:55:42 <Cale> Half the time I get connection reset
16:55:55 <Cale> The other half, I get through.
16:56:00 <mudge> well just a bit,  yea it is doing http
16:56:09 <mudge> Thanks Cale,  what browser are you using?
16:56:13 <jeffz> mudge: have you followed the http rfc?
16:56:25 <Cale> Firefox 2.0.0.7 on Ubuntu
16:57:18 <mudge> Cale, okay, thanks,   are you getting that reset error now?
16:57:20 <chessguy> mudge, looks like i'm getting the same results as cale with firefox on windows
16:57:46 <Cale> mudge: yep
16:57:49 <mudge> thanks
16:57:55 <mudge> is it still going through sometimes?
16:58:00 <Cale> yeah
16:58:30 <olsner> mudge: it's not waiting for a query at all (when tested with telnet)
16:58:33 <mudge> okay, cool thanks
16:58:46 <mudge> jeffz: I need to start digging into the http rfc
16:59:05 <jeffz> mudge: always a good place to start :p
16:59:25 <mudge> olsner:  yea,  it completely ignores the client,   as soon as there is a connection the server spits out the web page
17:00:10 <mudge> maybe that's exactly the problem,   maybe it needs to wait for the client to make a request for the webpage before serving it,   once a connection is made
17:00:55 <mudge> thanks all
17:01:10 <allbery_b> one other possible ssue is that it claims text/html but provides text/plain
17:03:19 <mudge> allbery_b: ah good point
17:03:20 <allbery_b> fwiw I'm seeing the same sometimes-reset behavior on firefox 2.0.0.7 osx
17:04:20 <olsner> IIRC, the contents should be terminated by a double-CRLF unless otherwise indicated by a content-length field
17:04:56 <mudge> allbery_b: it says it is serving plain text now
17:05:02 <olsner> but reading the RFC thoroughly would tell you what's correct
17:05:13 <allbery_b> I think that's untrue, double-crlf only matters for the header
17:05:25 <allbery_b> and content length is only required when using keep-open
17:06:02 <allbery_b> (which is not the default)
17:07:57 <olsner> on second thought, I think allbery_b is right ;-)
17:07:58 <olsner> the connection reset is most probably caused by the server not reading all of the query properly (and any part of the query that arrives after the server has closed down the connection will make the server send a RST packet to the client)
17:09:16 <allbery_b> and fwiw it works under safari3 beta
17:10:44 <allbery_b> double newline content behavior would be problematic for non-text/* content
17:10:52 <mudge> olsner: I think that is probablly it
17:11:18 * HairyDude grins at the ghc library docs: "RealWorld is deeply magical"
17:11:28 <mudge> right now it is a server that likes to force content down a browser's throat
17:11:53 <oerjan> it's a magical world!
17:12:18 <allbery_b> easy fix for the request issue is to read until a double crlf on input, then send the output
17:12:48 <mudge> allbery_b: you got some quick code for that?
17:13:19 <allbery_b> nope
17:13:38 <mudge> ok,  just checking,   great idea,   that's the next thing I'm going to do
17:13:58 <allbery_b> it's just pattern matching, ought to be trivial in haskell (modulo monds)
17:14:01 <allbery_b> monads
17:14:24 <oerjan> but - what if the browser is _not_ requesting the page, only information about it?
17:14:45 <mudge> oerjan: http requests are requests for pages
17:15:21 <oerjan> mudge: well i don't know but how does my browser know not to refetch pages that haven't changed?
17:15:53 <geocalc> time
17:15:57 <oerjan> perhaps it actually cuts off the connection after seeing a modified-date?
17:16:01 <allbery_b> it doesn't
17:16:22 <allbery_b> it sends an if-modified-since header, the server sends back a "reuse from cache" code if it implements that
17:16:34 <allbery_b> the server can avoid it entirely with a cache-control: none header
17:17:00 <allbery_b> or TRT happens if the servewr doesn't support if-modified-since and resends the content always
17:17:01 <oerjan> ic, so the server is permitted to always send the whole page
17:17:03 <mudge> the browser doesn't know ----  the server doesn't resend the page if it thinks the browser already has it
17:17:57 <allbery_b> if you want to be really pedantic you can distinguish vbetween GET ad HEAD requests
17:18:31 <allbery_b> but HEAD isn't often used
17:18:48 <hpaste>  newsham pasted "if-modified-since" at http://hpaste.org/3123
17:20:01 <chessguy> @quote magic
17:20:01 <lambdabot> qwe1234 says: real programmers write their own garbage collectors instead of using a magic black box from godforsaken academic website.
17:20:36 <monochrom> haha
17:20:39 <newsham> real programmers recycle their trash
17:21:10 <allbery_b> anyway this kind of stuff is why I made the commet about reinventing wheels earlier
17:21:20 <mudge> ah,  i found the http standard: ftp://ftp.isi.edu/in-notes/rfc2616.txt
17:21:39 <monochrom> Real programmers connect wires.
17:21:54 <newsham> real programmers dont take the square root of -1
17:22:26 <monochrom> Do you know what the job title "programmer" first referred to?
17:22:31 <allbery_b> no, real programmers throw SIGFPE when you do that :)
17:22:40 <allbery_b> s/you/they/
17:23:35 <newsham> heh , programmers cant throw!
17:23:39 <mauke> real programmers don't expect SIGFPE for floating point ops
17:23:45 <mudge> newsham: thanks for the hpast on if-modified
17:23:58 <newsham> np
17:24:07 <oerjan> what has poor sigfpe done to them?
17:24:26 <mrd> nobody expects the SIGFPE
17:24:31 <monochrom> poor sigfpe taught them how to reinvent monads.
17:24:51 <mudge> what's sigfpe?
17:24:59 <chessguy> @where sigfpe
17:24:59 <lambdabot> I know nothing about sigfpe.
17:25:15 <allbery_b> as I used it, a unix signal (floating point error, but also used for other numeric errors)
17:25:16 <monochrom> sig = signal (as in unix signals), fpe = floating point exception.
17:25:28 <allbery_b> around here, these days he goes by dpiponi
17:25:34 <oerjan> @go neighborhood infinity
17:25:36 <chessguy> @where+ sigfpe http://sigfpe.blogspot.com/
17:25:37 <lambdabot> http://sigfpe.blogspot.com/
17:25:37 <lambdabot> Title: A Neighborhood of Infinity
17:25:37 <lambdabot> Done.
17:25:44 <mudge> oh, him,  Dan,  he is really cool
17:26:01 <mauke> and you get SIGFPE for integer division by zero
17:26:27 <mudge> mauke:  why because he corrects you?
17:26:36 <mudge> he corrected me on my blog
17:26:49 <newsham> C programmers know the cost of everything and the value of nothing.
17:26:58 <newsham> fnctional programmers know the value of everything and the cost of nothing
17:27:21 <mudge> @quote newsham C programmers know the cost of everything and the value of nothing.
17:27:22 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
17:27:26 <monochrom> logic programmers know nothing :)
17:27:34 <mudge> @remember newsham C programmers know the cost of everything and the value of nothing.
17:27:34 <lambdabot> Done.
17:27:39 <mauke> @quote
17:27:39 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
17:27:53 <mudge> @remember newsham fnctional programmers know the value of everything and the cost of nothing
17:27:54 <lambdabot> Done.
17:28:02 <mauke> mudge: why? :(
17:28:09 * mrd would reverse Lisp and Ruby in that quote
17:28:22 <mudge> mauke:  what?
17:28:31 <mudge> mauke: why what?
17:28:32 <oerjan> mrd: ruby has macros?
17:28:35 <mauke> why did you put that in the quote db?
17:28:44 <mrd> no it has some pitiful excuses instead
17:28:56 <mudge> newsham said it and I thought it was pretty interesting
17:28:58 <mrd> that doesn't stop ruby programmers from chippering on about "metaprogramming"
17:29:04 <sorear> mudge: dude, that's a Perlisism
17:29:32 <mudge> sorear: what is?
17:29:43 <newsham> i just find it amusing that people dont know their unix signals
17:29:44 <monochrom> pronouns should be banned
17:29:46 <mauke> mudge: http://www.google.de/search?hl=en&q=%22value+of+everything%22+%22cost+of+nothing%22
17:29:47 <lambdabot> Title: "value of everything" "cost of nothing" - Google Search, http://tinyurl.com/2fomyy
17:29:50 <newsham> perhaps i am getting old
17:29:58 <mrd> what is "metaprogramming" anyway?  name suggests that it "comes after" programming.
17:30:15 <mrd> debugging? crashing?
17:30:20 <monochrom> people don't know unix pipes either. when I say "f . g is like g | f" they ask what is g | f.
17:30:38 <newsham> the two phases of programming are bugging and debugging
17:30:51 <mrd> more like rebugging
17:31:03 <newsham> mono: even most unix people dont know how to use unix tools compositionally anymore :(
17:31:08 <sorear> mudge: http://www.cs.yale.edu/quotes.html, #55
17:31:10 <lambdabot> Title: Perlisisms - "Epigrams in Programming" by Alan J. Perlis
17:31:11 <mrd> newsham: it's GUI mind-rot
17:31:26 <newsham> its more than that.
17:31:36 <newsham> gui mind rot didnt add -R to gnu grep
17:31:39 <newsham> or -n to gnu cat
17:31:45 <allbery_b> gnu mind rot?
17:31:57 <allbery_b> although, cat -n came from 4.xBSD
17:32:04 <newsham> could be
17:32:16 * sorear did not know about cat -n
17:32:21 <newsham> berkeley definitely didnt believe in the unix philosophy
17:32:32 <mrd> grep -R is a lot more convenient than using find, though
17:32:40 <mudge> sorear:  whoa, thanks ,   sorear, what do you think of this Perlis guy?
17:32:41 <mrd> so i'm ok with that
17:32:49 <sorear> mudge: I feel old.
17:32:50 <newsham> fgr() { find . -type f -print0 |xargs -0 grep "$@"; }
17:33:03 <mudge> sorear: why?   you're such a young gun
17:33:07 <newsham> (or in ~/bin/fgr if you dont believe in shells with functions)
17:33:33 <allbery_b> hard to do philosophy when you're stoned :)
17:33:33 * allbery_b thinks more people need to read K&P
17:33:50 <mudge> K&P?
17:33:54 * oerjan thought perlisism was sayings about perl
17:34:02 <allbery_b> Kernighan and Pike, "The UNIX Programming Environment"
17:34:09 <sorear> The UNIX Programming Environment, Kernighan and Pike
17:34:16 * sorear holds up his copy
17:34:20 <mudge> yea,  I thought so too,   but apparently perlis  is a guy
17:34:25 * mrd chuckles
17:34:34 <mudge> http://scw.tw/works/OSDCtw2007/slides.ppt
17:34:37 <newsham> http://plan9.bell-labs.com/cm/cs/doc/84/kp.ps.gz
17:34:38 <Lycurgus> perlisms I should think
17:35:55 <newsham> anyone have a copy of lady ada's program for computing bernouli numbers?
17:35:56 <mudge> allbery_b: is that a pretty good book?
17:36:34 <allbery_b> yes
17:36:34 <allbery_b> it starts with shell-level programming (pipes and such) and proceeds to programming techniques (in C, alas, but it kinda predates haskell)
17:36:47 <newsham> nothing wrong with a little C
17:36:57 <mrd> that's how it starts
17:37:12 <newsham> thats how i started too :)
17:37:24 <mudge> allbery_b: cool thanks
17:37:27 <mudge> C is important
17:37:31 <newsham> (I dont know if you can count BASIC and 6502)
17:37:43 <mrd> then before you know it, you're crouched in the corner of the Wean cluster on a linux machine, Saturday night, stinking up the room
17:37:58 <mrd> madly typing away
17:38:07 <newsham> why would you put linux on your machine? :)
17:38:14 <allbery_b> the original Unix philosophy is very functional:  you build programs by composing
17:38:18 <mrd> they don't have Suns anymore in there
17:38:23 * allbery_b notes that his dsl is bouncing up and down so much now that he will have to withdraw from the discussion :(
17:38:30 <newsham> allbery: yah, the link I just pasted spells it all out
17:40:04 <allbery_b> linux?  I think the wean clusters are all imacs now
17:40:20 <mrd> they still have linux in the back room
17:40:32 <mrd> yea i was surprised too by the imacs
17:40:42 <mauke> there's a subtle difference between imacs and emacs
17:41:00 <mrd> weird, someone at my door
17:41:00 <newsham> neither one is eight megs and constantly swapping anymore?
17:41:17 <olsner> imacs have an OS, emacs *is* an OS ;-)
17:41:52 <oerjan> can you use emacs as the OS on imacs?
17:42:13 <newsham> my other operating system is emacs?
17:42:50 <olsner> build an elisp interpreter into EFI (if that's enough to actually run emacs - presumably there's a bit of other glue needed)
17:42:53 <newsham> my lisp machine crashed and all I got was this lousy editor?
17:42:56 <mrd> my favorite was emacs on an eMac
17:43:17 <Spark> emacs and imacs have a lot in common
17:43:20 <Spark> bloat and pointless gimmicks
17:43:37 <mrd> emacs is about the least bloated thing on my computer now, sadly
17:43:46 <Spark> i think you may have lost your way
17:43:57 <olsner> I'd say most of the mac gimmicks are actually useful
17:44:01 <Spark> i recommend a course of software genoide
17:44:22 * mrd reminds Spark about Firefox
17:44:32 <Spark> i tried switching away from firefox recently
17:44:44 <Spark> to konqueror
17:44:48 <Spark> full of optimism for a better world
17:44:59 <Spark> but it just got slower and slower the longer i left it on for
17:45:04 <newsham> mrd: who woulda thunk you would be saying that some day?
17:45:05 <Spark> until it was less responsive than firefox
17:45:19 <mrd> newsham: i said it years ago, since it's been a long time since I only had 8 MB of RAM
17:45:24 <monochrom> I recommend e-links to you.
17:45:24 <allbery_b> after rms recovers from the brain hemorrhage, sure
17:45:26 <mrd> over 10 years
17:46:24 <Spark> e-links you say
17:46:42 <monochrom> Yes.
17:46:58 <Spark> that's just an ncurses thing
17:47:24 <monochrom> It doesn't have gimmicks.
17:47:34 <Spark> it's not really useful for much more than reading html mail
17:47:54 <Spark> i don't disapprove of firefox's feature set too much
17:47:59 <Spark> it could be slimmed down, sure
17:48:06 <Spark> but my main problem is the performance and stability
17:48:32 <mrd> it gets pretty wonky on my old P4 when i leave it running
17:49:04 <sorear> what, elinks?
17:49:16 <mrd> firefox
17:49:40 * mrd awaits the haskell replacement for firefox
17:50:27 <sorear> I've already got a name for it (but not much code, sadly)
17:50:33 <monochrom> Will it be functional? XD
17:50:48 <mrd> it will be as lazy as I
17:51:09 <newsham> maybe when firefox is out of beta
17:51:12 <newsham> do people do that anymore?
17:51:33 <monochrom> I think firefox is no longer in beta.
17:52:09 <mauke> haskell software should move from alpha to beta to eta, then lambda
17:52:19 <mrd> gamma, delta?
17:52:22 <monochrom> hehehehe
17:52:30 <olsner> hasn't firefox been out of beta for a number of years already?
17:52:44 <newsham> as eta approaches zero?
17:53:17 <mrd> greek alphabet versioning would surely drive package systems insane =)
17:53:22 <olsner> haskell software should start at 1, then gradually approach zero as it gets closer to what it should be
17:53:33 <monochrom> @remember mauke haskell software should move from alpha to beta to eta, then lambda
17:53:34 <lambdabot> Done.
17:53:56 <olsner> (much as tex approaches version pi)
17:54:19 <monochrom> "we are zeroing in on bugs"
17:54:42 <newsham> |f(x)-f(c)| < eta
17:54:58 <mauke> you english and your number verbing
17:55:41 <newsham> lifting nouns to verbs
17:55:42 <monochrom> eta = η  epsilon = ϵ
17:55:55 <newsham> oh yah
17:56:06 <newsham> i should know that
17:56:12 <monochrom> The eta rule is (\x -> f x) = f.
17:57:54 <davidL> I'm having trouble making an infinite list of lists which are [1..n] in random order. I have an unsort method which randomly unsorts one list but I'm stuck on how to repeat that indefinitely
17:58:27 <mauke> unsort = shuffle?
17:58:33 <davidL> yeah
17:58:56 <monochrom> IIUC your problem is unsolvable.
17:59:12 <newsham> like concat (iterate unsort xs) ?
17:59:26 <newsham> (i imagine your unsort is a monad action though)
18:00:36 <pgavin> sequence $ repeat $ unsort xs
18:00:36 <newsham> > concat (iterate (map succ) [1,1,1])
18:00:37 <lambdabot>  [1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,11,11,11,12,...
18:00:38 <LoganCapaldo> @type iterateM
18:00:40 <lambdabot> Not in scope: `iterateM'
18:00:44 <LoganCapaldo> drat
18:01:08 <oerjan> mapM unsort
18:01:15 <oerjan> if unsort were monadic
18:01:44 <davidL> I get a stack overflow using sequence
18:01:58 <oerjan> davidL: what is the type of unsort?
18:02:11 <davidL> unsort :: (RandomGen g) => g -> [a] -> [a]
18:02:41 <oerjan> it would have been easier if it was g -> [a] -> ([a], g)
18:03:16 <LoganCapaldo> State!!!!
18:03:31 <newsham> how about foldl unsort xs (repeat xs)    ?
18:03:32 <davidL> yeah then I could have used getStdRandom
18:03:43 <idnar> RandomMonad
18:03:58 <newsham> oh wait you dont output the next g
18:04:28 <sorear> just use split!
18:04:29 <newsham> you could randomIO
18:04:47 <oerjan> newsham: that would _really_ ruin the ability to make an infinite list
18:04:53 <newsham> doesnt docs warn that split doesnt give as good quality numbers?
18:05:02 <oerjan> newsham: probably
18:05:06 <sorear> @ty map (\g -> ?unshuffle g [1..100]) $ unfoldr (Just . split) (mkStdGen 42)
18:05:08 <lambdabot> forall b t. (?unshuffle::StdGen -> [t] -> b, Num t, Enum t) => [b]
18:05:11 <sorear> davidL: ^^^
18:05:27 <glguy> newsham: what was the if-modified-since stuff for?
18:05:44 <LoganCapaldo> implicit variables are so implicitly variable
18:05:47 <newsham> glguy: some people were talking about it.  *shrug*
18:06:02 <HairyDude> iterateM can only work for lazy monads
18:06:02 <davidL> sorear: and then I give a different seed value for each list?
18:06:15 <glguy> newsham: happs related
18:06:19 <oerjan> glguy: i was wondering how my browser avoided downloading pages that haven't changed
18:06:20 <LoganCapaldo> What'sa non-lazy monad?
18:06:21 <HairyDude> which incidentally IO isn't
18:06:26 <glguy> ahh
18:06:28 <LoganCapaldo> well theres that
18:06:29 <sorear> davidL: YES, that uses a different seed value for each list.
18:06:40 <sorear> > unfoldr (Just . split) (mkStdGen 42)
18:06:42 <lambdabot>  [44 40692,1720603 2147442707,128694413 2147402015,2060101258 2147361323,1735...
18:06:45 <sorear> see?
18:06:48 <HairyDude> LoganCapaldo: one for which _|_ >>= f == _|_ doesn't necessarily hold
18:07:14 <newsham> you should modify your unsort to return the final g
18:07:19 <newsham> and then keep folding that g back in
18:07:28 <sorear> HairyDude: no, that's a lazy monad; non-lazy monads are the ones where _|_ >>= _ = _|_
18:07:33 <newsham> better than keep making new generators
18:07:38 <LoganCapaldo> HairyDude: so in IO _|_ >>= f /= _|_ potentionally?
18:07:44 <HairyDude> sorear: woops, yes
18:07:52 <LoganCapaldo> gah
18:08:04 <LoganCapaldo> stop confusing me
18:08:18 <davidL> I think I understand, thanks all
18:08:39 <olsner> newsham: but wouldn't that force the 1..n'th shuffled lists completely when you take the first element of the n+1-th shuffling? that's probably not what you want
18:08:40 <HairyDude> LoganCapaldo: well... unsafeInterleaveIO _|_ >>= f /= _|_ can hold :)
18:09:10 <HairyDude> actually that might not be right.
18:09:17 <newsham> is that not what you want?
18:09:22 <sorear> _|_ >>= f    -->   \ st# -> case (unIO _|_ st#) of (# x, st# #) -> unIO (f x) st#    -->   \ st# -> case (_|_ st#) of (# x, st# #) -> unIO (f x) st#    -->   \ st# -> case _|_ of (# x, st# #) -> unIO (f x) st#    -->   \ st# -> _|_
18:09:35 <sorear> which isn't *really* _|_, but it's close enough for us
18:09:44 <olsner> I guess it does depend on what you want to use the shuffles for
18:09:57 <LoganCapaldo> sorear, stop it! I didn't wnt to see that. Now I'm corrupted :)
18:10:18 <newsham> mere mortals should never see "#"
18:10:25 <olsner> @remember sorear _|_ >>= f    -->   \ st# -> case (unIO _|_ st#) of (# x, st# #) -> unIO (f x) st#    -->   \ st# -> case (_|_ st#) of (# x, st# #) -> unIO (f x) st#    -->   \ st# -> case _|_ of (# x, st# #) -> unIO (f x) st#    -->   \ st# -> _|_
18:10:25 <lambdabot> Done.
18:10:47 <LoganCapaldo> olsner: You have strange criteria for quotability
18:10:52 <olsner> LoganCapaldo: yes
18:11:03 <sorear> newsham: I'm not mortal?
18:11:10 <HairyDude> you can use unsafeInterleaveIO to implement iterateM and repeatM for IO... e.g. we have something like hGetContents = repeatM (hGetChar h) (except for details about semi-closed handles)
18:11:14 <LoganCapaldo> sorear: no just not mere
18:11:42 <sorear> HairyDude: Also breaks miserably at EOF
18:11:48 <HairyDude> yes.
18:12:22 <olsner> LoganCapaldo: this specific line scored in complete unreadability... also, it will boggle the mind of the one who brings it out with @quote when they wonder what it means and why it was quoted ;-)
18:12:53 <HairyDude> sorear: wow, where does that come from?
18:12:57 <LoganCapaldo> olsner: you're evil you know that right?
18:13:22 <newsham> sorear: no, you're like in the bowels of ghc
18:13:29 <newsham> where no mortal dare to trod
18:13:33 <HairyDude> oh, doh
18:14:02 <goalieca> sorear: well done. that looks worse than perl
18:14:17 <HairyDude> newsham: btw, what's wrong with defining a function called (#) ? :)
18:14:35 <newsham> i dare not
18:14:35 <sorear> goalieca: at least it's definable in BNF :P
18:15:09 <oerjan> HairyDude: not legal H98 identifier
18:15:31 <HairyDude> really? never had problems using it myself
18:15:48 <oerjan> ghc adds it to use it internally
18:16:02 <oerjan> hm...
18:16:09 <HairyDude> Prelude> let (#) = (+) in 1 # 2
18:16:09 <HairyDude> 3
18:16:14 <oerjan> > let (#) = map in (#)
18:16:16 <HairyDude> that's ghci with no extensions on
18:16:21 <lambdabot>  Add a type signature
18:16:27 <oerjan> oh wait
18:16:34 <HairyDude> oerjan: lambdabot's dialect isn't H'98 though
18:16:42 <oerjan> it's at the end of alphanumerics it's not allowed
18:16:53 <oerjan> HairyDude: it's pretty close
18:17:03 <oerjan> very few extensions enabled
18:17:16 <oerjan> > let test# = 1 in test#
18:17:17 <lambdabot>  Parse error
18:17:39 <HairyDude> what does it have? existentials and implicit arguments, what else?
18:17:39 <oerjan> and also, > passes everything through Language.Haskell which is H98 (even a subset)
18:17:59 <oerjan> HairyDude: only in :t, which has several
18:18:21 <oerjan> but > is quite restricted
18:18:43 <HairyDude> ah
18:19:14 <oerjan> also, how can it have existentials when it doesn't allow data type definitions?
18:19:49 <oerjan> but it has universal quantification
18:20:02 <LoganCapaldo> anonymous newtypes? :)
18:20:04 * HairyDude fails to grok the difference. :)
18:20:29 <oerjan> existential = there exists a type, universal = for all types
18:20:36 <oerjan> :t map
18:20:38 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:20:48 <oerjan> here it means for all types a and b
18:20:56 <HairyDude> they use the same 'forall' keyword which confuses things somewhat.
18:21:20 <oerjan> that's using deMorgan's laws in a sense
18:21:41 <oerjan> not for all = for some, not
18:22:22 <oerjan> well, possibly
18:27:10 <oerjan> data D = forall a. Cl a => D a <=> data D = D (exists a. Cl a and a)
18:28:01 <oerjan> more or less
19:03:34 <SamB_XP> man this is a low traffic list! http://gmane.org/info.php?group=gmane.comp.lang.haskell.jhc
19:03:36 <lambdabot> Title: Gmane -- Lists Information
19:14:03 <blazzy> is there something like cscope for haskell?
19:17:16 <allbery_b> hat, sort of, but it doesn't work very well ime
19:17:21 <allbery_b> @where hat
19:17:21 <lambdabot> http://www.haskell.org/hat/
19:32:53 <twifkak> potentially stupid ghc question:
19:33:51 <twifkak> i add `import Text.Regex` and get "it is a member of regex-posix-0.71, which is hidden"
19:34:11 <twifkak> and yet, i have no problem in ghci, and ghc-pkg field regex-posix exposed says True
19:34:14 <twifkak> whatup?
19:34:18 <newsham> ghc --make foo.hs
19:34:24 <newsham> should pull in the packages you need
19:34:47 <twifkak> oh, yar, thanks. in this case, it's xmonad, so i need to add the pkg to the .cabal, yes?
19:34:55 <newsham> yah
19:35:16 <newsham> add to the Build-Depends:
19:35:26 <twifkak> thanks :)
19:44:12 <oerjan> > map ((((1:+0)+sqrt(-3))/2)^) [1..]
19:44:14 <lambdabot>  [0.5 :+ 0.8660254037844386,(-0.4999999999999999) :+ 0.8660254037844386,(-0.9...
19:58:13 <tehgeekmeister> ?src filterM
19:58:13 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:58:21 <tehgeekmeister> bah.
19:58:42 <oerjan> @index filterM
19:58:42 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:58:54 <oerjan> @source Control.Monad
19:58:55 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
19:59:53 <tehgeekmeister> thanks.
20:05:25 <hpaste>  nicodaemos pasted "I love strong typing except when it sucks.  What did I do wrong with the types?" at http://hpaste.org/3124
20:06:45 <oerjan> nicodaemos: i guess a missing liftIO somewhere
20:08:18 <allbery_b> your runStateT is expected to produce IO a because it's in a do bock whose type is declared as IO
20:08:33 <oerjan> or maybe that -> IO () in runLoop should be -> CGIT IO ()
20:08:34 <mrd> is there a runCGIT
20:09:09 <nicodaemos> the type for runOneFastCGI :: CGI CGIResult -> IO ()
20:09:23 <nicodaemos> so I'm assuming it will do the runCGIT
20:09:24 <allbery_b> doesn't matter, all the "statements" havbe to be in IO
20:09:25 <mrd> @hoogle evalStateT
20:09:27 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
20:09:42 <mrd> runOneFastCGI (evalStateT ... )
20:10:32 <allbery_b> basically the >>= that is generated is in IO, not in CGIT IO
20:10:45 <allbery_b> because that's the type of the entire expression
20:10:54 <allbery_b> and a chain of binds have to all be in the same monad
20:11:35 <allbery_b> (because it's really a single long expression, not a series of independent statement like the do syntax makes it look like)
20:11:36 <nicodaemos> allbery_b: can I assume <- means the same >>= for your statement?
20:11:51 <mrd> that's waht it is
20:12:03 <allbery_b> a <- b internally becomes b >>= \a ->
20:12:06 <mrd> might be time to take a look at do-notation de-sugaring
20:12:24 <allbery_b> note the incompleteness of that expression, which is why the whole thing has to be in the same monad
20:12:33 <oerjan> nicodaemos: use a liftIO on runOneFastCGI, and change the type to CGIT IO ()
20:12:37 <cognominal_> @src (<+>)
20:12:37 <lambdabot> Source not found. That's something I cannot allow to happen.
20:12:48 <oerjan> that's my guess
20:13:36 <oerjan> er wait, that may not make sense
20:14:02 <oerjan> CGI is a non-transformer variant of CGIT?
20:14:27 <nicodaemos> type CGI a = CGIT IO a
20:14:40 <oerjan> oh
20:15:54 <nicodaemos> mrd: I had a solution similar to what you recommended.  But I changed it because of a different problem.
20:16:23 <oerjan> i am not sure you can do what you want then
20:17:45 <oerjan> the only way to run something in StateT AppState (CGIT IO) is to run it inside the CGIT IO monad
20:18:18 <oerjan> and if runOneFastCGI is the only way to run CGIT, then you cannot get out a result...
20:19:05 <nicodaemos> I thought monad transformers would help to do something like this
20:19:29 <nicodaemos> How do people really stack monads when using libraries?
20:19:32 <oerjan> would it be enough to use runOneFastCGI outside the whole loop? you can do that
20:19:53 <nicodaemos> sure, I can write this however
20:34:17 <oerjan> nicodaemos: if you want to run separate CGI actions, i think CGIT (StateT AppState IO) might work better, then you can preserve state between them
20:35:25 <nicodaemos> ok, so you're saying I can stack the monads in a different way ... push my state monad (lower?) in the stack?
20:35:31 <oerjan> yep
20:36:18 <oerjan> it would allow something closer to the non-working one you pasted
20:36:32 <nicodaemos> I'm really fuzzy with how an existing library would handle this case where I insert a monad lower into the stack ... you wouldn't happen to know of any good examples anywhere?
20:36:35 <oerjan> although the r would still not be available
20:37:01 <rubyruy> I have a question that is not terribly specific to haskell, but pertains to a fairly key part of haskell - namely, the whole namespaced functions + (relatively speaking) dumb data structure approach (vis-a-vis OOP)
20:37:21 <oerjan> no, but the Network.CGI page does say you can use your choice of monad within CGIT
20:37:53 <nicodaemos> I know ... that's what I've really be trying to do ... get fastcgi to use my state monad over and over again as it loops
20:38:21 <nicodaemos> I had gotten it to use it ... once ... but it lost state (recreated it) as it looped.
20:38:37 <oerjan> indeed, then you want the State inside CGIT
20:39:31 <nicodaemos> now since CGIT is already defined in Network.CGI.Monad.hs, would I import that module while hiding CGIT and then define my own newtype for it?
20:40:07 <oerjan> er, i meant to use that CGIT
20:40:57 <rubyruy> I managed to "get over" the idea that data structures and functions should always live together as in OOP, but one thing is kinda nagging me: don't you run into situations where you'd like to control how the internals of a data structure get manipulated? I'm specifically talking about data structures that necessarily hold state (think GUI kits and say, the data structure for a text box).
20:41:24 <rubyruy> I can give a concrete example of what i'm talking about ...
20:41:31 <nicodaemos> I'm not quite sure I understand how, but let me try some code
20:42:01 <oerjan> newtype AppT m a = AppC (CGIT (StateT AppState m) a)
20:42:39 <oerjan> this should allow you to derive MonadCGI too, i think
20:43:20 <allbery_b> rubyruy: define in a separate module, don't export the labels
20:43:53 <allbery_b> make sure exported constructors initialize the records properly
20:44:39 <oerjan> you might also want to pull AppC a / r into the state, since runCGI provides no direct way of returning results
20:44:42 <rubyruy> You have your textbox and it maintains some sort of state (position on screen, visual style stuff, and of course the value). I'm assuming here that this really IS a place where you can't avoid mutable state, but please tell me if i'm wrong. When this state is manipulated, say, the value is altered, in OOP, it is the normal state of affairs to have some sort of value-setting method. This is useful, because now you have a very convenient hook fr
20:44:48 <allbery_b> this is im[erfect because you can use the flat syntax to get at them, but fo large records that's sufficiently painful to be a "don't do that"
20:45:44 <allbery_b> alternatively there may be some trick one can pull with existentials but I'm too tired tonight...
20:45:47 <rubyruy> Oh i see - so effectively you can still have a form of 'private data' ?
20:45:52 <rubyruy> with acessors
20:46:38 <allbery_b> hm, actually, if ylou don't export the value constructor then you can't pattern match to get at the fields either
20:46:46 <allbery_b> so you do in fact have private data
20:47:12 <nicodaemos> oerjan: I think I'm going to have to keep playing with this, but I thanks for the ideas!  Monad transformers seem interesting ... I really need to get more of a feel for how to use them.
20:47:36 <oerjan> nicodaemos: you're welcome, and good luck :)
20:53:54 <oerjan> nicodaemos: whoops, i am seeing one major snag - Network.FastCGI seems to only support IO as monad
20:54:13 <oerjan> i only looked at Network.CGI previously :(
20:54:45 <nicodaemos> oerjan: is that because of type CGI a = CGIT IO a and everything is CGI CGIResult?
20:55:22 <oerjan> that and all the run functions end in -> IO () rather than -> m ()
20:56:54 <oerjan> sorry for misleading you :(
20:57:16 <nicodaemos> oh no worries, I'm learning stuff
20:58:25 <nicodaemos> Do you see a way I could use runFastCGIConcurrent' with my State Transformer without having to rewrite it?
20:59:06 <oerjan> i don't see that function, looking at http://hackage.haskell.org/packages/archive/fastcgi/3000.0.0/doc/html/Network-FastCGI.html
20:59:09 <lambdabot> http://tinyurl.com/ys56be
20:59:21 <nicodaemos> I mean is it an extensible function and I just don't know how to take advantage of it or was it not designed for it?
20:59:43 <nicodaemos> oops, it's in 3001 or so, I got the latest from darcs
20:59:50 <oerjan> oh
21:02:41 <nicodaemos> forget the 3001, just from darcs http://darcs.haskell.org/fastcgi/
21:02:42 <lambdabot> Title: Index of /fastcgi
21:02:46 <tehgeekmeister> is there a general way to take a function name in string form and execute it?
21:02:53 <tehgeekmeister> (err, call it on some value)
21:04:19 <sjanssen> tehgeekmeister: hs-plugins?
21:04:35 <sjanssen> tehgeekmeister: Haskell doesn't come with an eval function
21:05:17 <oerjan> nicodaemos: perhaps it would be simpler to use an IORef to preserve the state
21:05:41 <sorear> tehgeekmeister: In what environment?
21:06:02 <sorear> tehgeekmeister: Haskell is a full-blooded batch compiler language
21:06:32 <tehgeekmeister> sorear: it's just a simple programming exercise, i can use a case on different values, i just wanted to know if there was something more general to use instead
21:07:49 <sjanssen> tehgeekmeister: use Data.List.lookup or a Map if there are more than a few names you want to match
21:08:02 <nicodaemos> oerjan: that's a good idea, I'll go try that
21:22:33 <nicodaemos> oerjan: Yup, the IORef works fine with the state, Thanks !
21:41:35 <twifkak> okay, new contrib
21:41:43 <twifkak> interested in thoughts before i darcs send
21:41:47 <twifkak> http://hpaste.org/3125
21:41:53 <sorear> sh--
21:42:00 <sorear> stefan@stefans:~/irclogs/freenode$ grep twifkak #haskell.log
21:42:08 <sorear> why doesn't this work!?!?
21:42:10 <sorear> oh...
21:42:21 <twifkak> blah! mischan
21:44:06 <twifkak> sorear: gathering evidence for the inquisition?
21:44:40 <sorear> twifkak: since you asked in #haskell, it seems pretty nice, although I'd indent where decoratedNames 1 less and inline result (just me)
21:44:44 <sorear> twifkak: heh
21:45:01 <sorear> twifkak: nah, just thinking "don's scheme actually worked!?"
21:45:13 <twifkak> lol
21:45:39 <ramza3> @hoogle pushMatrix
21:45:40 <lambdabot> No matches found
21:45:47 <twifkak> i wonder if he and SPJ have a bet going for "most newbs recruited in '07"
21:46:21 <sorear> @remember twifkak [on dons] i wonder if he and SPJ have a bet going for "most newbs recruited in '07"
21:46:22 <lambdabot> Done.
21:46:54 <twifkak> oh dear...
21:47:31 <oerjan> this rampant @remember'ing is probably all my fault
21:47:38 <twifkak> okay, another question -- for the Build-Depends on the regex packagen -- what version numbers should i put there?
21:48:09 <ramza3> anybody work with opengl and haskell and know if pushMatrix is defined.  Seems to have been moved from where it has been in the past (eg, the examples from several years ago)
21:48:44 <twifkak> is it worth trying to go back in time to find out when the functions i'm using were first added?
21:48:53 <twifkak> (and if so, how might i do that?)
21:50:42 <ramza3> matrixExcursion , hehe
21:51:13 <hpaste>  tehgeekmeister pasted "(no title)" at http://hpaste.org/3126
21:52:10 <hpaste>  tehgeekmeister annotated "(no title)" with "same post as a moment ago but including the error message" at http://hpaste.org/3126#a1
21:53:55 <oerjan> tehgeekmeister: map read
21:54:16 <scook0> nums is still just a list of strings
21:54:51 <scook0> you need to convert them to something that sqrt will accept (e.g. using map read above)
21:55:06 <tehgeekmeister> oh, right.
21:55:51 <scook0> if you want you can just do (print . sqrt . read)
21:55:54 <tehgeekmeister> should've known it'd be something that simple.
21:56:04 <tehgeekmeister> i just changed the let nums
21:56:18 <oerjan> scook0: that won't be any good as he needs it on all the other functions too
21:56:32 <scook0> ah, I didn't look that closely
21:56:44 <oerjan> btw, sequence_ . map = mapM_
21:57:30 <tehgeekmeister> oerjan: thanks
21:58:18 <oerjan> if everything prints a list of one or more Doubles, you might also be able to factor out the printing
21:59:44 <tehgeekmeister> explain?
21:59:47 <oerjan> and the nums, if you want to go pointfree
22:00:11 <tehgeekmeister> pointfree would be good, i just didn't know how to do it in this case.
22:00:13 <oerjan> if you change print $ sum nums to [sum nums]
22:00:26 <oerjan> (actually that doesn't fit with pointfree
22:00:44 <oerjan> alternatively, print . sum
22:00:59 <scook0> mapM_ print $ case head args of ...
22:01:09 <oerjan> scook0: right
22:01:19 <tehgeekmeister> oh!  i wasn't aware a case could be used like that.
22:01:29 <scook0> yeah, it's just an expression
22:01:59 <scook0> you can do the same tricks with if and do expressions
22:02:24 <oerjan> unfortunately getting both that and pointfree seems to introduce some stray (:[]) or return's
22:03:15 <scook0> in this case it might be cleaner to just leave in the redundant prints
22:03:32 <scook0> it's a stylistic judgement call, really
22:04:47 <oerjan> although you could do both if you changed the case to a List.lookup
22:05:32 <oerjan> @pl (return .)
22:05:32 <lambdabot> (return .)
22:09:07 <SamB_XP> hmm. http://en.wikipedia.org/wiki/Literate_programming should mention that Haskell already lets you write definitions in many orders and use them polymorphically...
22:09:08 <lambdabot> Title: Literate programming - Wikipedia, the free encyclopedia
22:10:48 <chessguy> @unpl (return .)
22:10:48 <lambdabot> (\ a d -> return (a d))
22:14:05 <oerjan> SamB_XP: i am not sure how relevant that is, my hunch is that the article refers to having multiple ways of looking at code
22:14:52 <SamB_XP> I mean, in C and PASCAL it's absolutely essential to be able to reorder code in order to write a literate program
22:15:20 <SamB_XP> since declarations need to be at the top and so on
22:16:05 <oerjan> hm, maybe
22:25:39 <geocalc> @hoogle list
22:25:40 <lambdabot> Control.Monad.List :: module
22:25:40 <lambdabot> Data.List :: module
22:25:40 <lambdabot> List :: module
23:01:31 <divip_> @type map
23:01:33 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:02:23 <divip_> > map (+1) [1..10]
23:02:25 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
23:03:43 <divip_> @type babel
23:03:45 <lambdabot> Not in scope: `babel'
23:03:58 <oerjan> @help babel
23:03:58 <lambdabot> babel <lang1> <lang2> <phrase>.
23:03:58 <lambdabot> Translate a phrase in lang1 to lang2.
23:03:58 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
23:04:24 <davidL> ?babel en spanish hello
23:04:25 <lambdabot>   hola
23:08:50 <divip_> oerjan: thanks
23:16:09 <divip_> Hi, I'm trying to compile Lambdabot 4.0.1 from .tar.gz. The compilation terminates with the error: Could not find module `Data.ByteString.Char8':it was found in multiple packages: fps-0.7 base
23:18:06 <divip_> I'm using GHC 6.6
23:18:46 <oerjan> @seen dons
23:18:46 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 7h 54m 44s ago.
23:19:25 <oerjan> not the best timing it seems
23:19:40 <davidL> I think the tarball is really out of date if I remember correctly and using the darcs lambdabot is recommended
23:19:53 * oerjan vaguely recalls that too
23:20:22 <divip_> OK, I will try the darcs version.
23:28:10 <divip_> Other: I wrote a UnicodePrelude.hs module with 19 unicode symbols defined like not_elem, /\, ... Has anybody such module? It is worth to put it on Hackage DB?
23:46:42 <divip_> I'm now trying to compile lambdabot from darcs (today). It needs zlib-any. I downloaded zlib-0.3 from HackageDB, but it fails to compile, because the file zlib.h is missing. Does it need greencard or something like that?
23:48:18 <sorear> no, it needs you to run autoconf
23:48:30 <sorear> ...or maybe to install zlib
23:48:44 <sorear> yeah, I think that's it
23:50:48 <divip_> OK, it works! The development version of the zlib library was needed.
23:57:21 <divip_> what  about the containers package? binary-0.4 needs it (lambabot needs binary).
23:57:28 <ramza3> I am looking at some code that has "let abc =<blah>" and then "in SomeDataType { ... }" where do I find information on the in keyword
23:57:53 <oerjan> @where report
23:57:54 <lambdabot> http://www.haskell.org/onlinereport/
23:58:01 <oerjan> see the expression chapter
23:58:34 <oerjan> > let x = 2; y = 3 in x+y
23:58:36 <lambdabot>  5
