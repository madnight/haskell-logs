00:01:03 <sjw> boxes also need to know, IIRC, how they should be examined by the GC
00:01:36 <sjanssen> yeah, there's a bunch of flags in addition to 'evaluated'
00:02:12 <sjw> from the STG paper, isn't there a function pointer to the GC part for that type?
00:02:27 * sjw read it about 6 years ago
00:02:34 <sjanssen> modern day GHC uses a bitmask
00:03:06 <nornagon> :t ($)
00:03:12 <sjw> what happens if your datatype has > 32 elements?
00:03:14 <lambdabot> forall a b. (a -> b) -> a -> b
00:03:15 <nornagon> :t id :: (a -> b) -> a -> b
00:03:17 <lambdabot> (a -> b) -> a -> b :: forall a b. (a -> b) -> a -> b
00:03:28 <nornagon> ^- what is the difference? :)
00:03:35 <nornagon> @src ($)
00:03:35 <lambdabot> f $ x = f x
00:03:49 <nornagon> @src id
00:03:49 <lambdabot> id x = x
00:03:53 <nornagon> nothing, i guess
00:03:59 <omnId> nornagon: correct
00:04:00 <sjanssen> nornagon: no difference
00:04:23 <nornagon> > (1+) `id` 3
00:04:24 <sjw> apart from precedence?
00:04:25 <lambdabot>  4
00:04:39 <sjanssen> sjw: not sure, perhaps a 1 in the highest bit means there is an additional bitmask
00:04:47 <omnId> sjw: also correct
00:05:33 <sjw> I wonder if it makes sense to stick objects of the same type in a ragion of memory, then you don't require the bitmask
00:05:44 <sjw> although the tradeoffs aren't trivial, I suspect
00:06:10 <sjanssen> sjw: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
00:06:13 <lambdabot> Title: Commentary/Rts/Storage/HeapObjects - GHC - Trac, http://tinyurl.com/2y6qst
00:06:16 <nornagon> foldl (flip id) sure is neat
00:06:23 * sjw is RTFW'd
00:06:34 <sjw> :)
00:06:50 <dmwit> I know STFW and RTFM, but RTFW is new to me...
00:07:00 <nornagon> wiki?
00:07:02 <sjanssen> sjw: I had to check the wiki to see if I was talking out my ass :)
00:07:16 <sarehu> W = Web
00:07:29 <sjw> dmwit: yeah, I just made it up, but it seems pertinent
00:07:33 <sjw> W = wiki
00:07:39 <dmwit> ah
00:07:41 <dmwit> =)
00:07:46 <sarehu> W = wiki?  stfu...w.. gah!
00:08:57 <sjw> but we/you were talking about boxed values ... did someone mention unboxed types and #?
00:10:41 <geocalc> do you want to make an assembler ?
00:11:40 <mgsloan> we were more just talking about terminology and what Thunk/Box/Unboxed really mean
00:12:04 <geocalc> ok
00:13:59 <sjanssen> mgsloan: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects gives some definitions for boxed/unboxed
00:14:02 <lambdabot> Title: Commentary/Rts/Storage/HeapObjects - GHC - Trac, http://tinyurl.com/2y6qst
00:15:39 <Pseudonym> Search The Fine Up
00:15:48 <Pseudonym> That sounds like a bad hip hop song.
00:19:25 <mgsloan> interesting stuff...
00:21:31 <geocalc> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CodeGen#Storagemanagerrepresentations
00:21:34 <lambdabot> Title: Commentary/Compiler/CodeGen - GHC - Trac, http://tinyurl.com/uavbu
00:21:50 <mudge> hey you know,  I don't think other channels have the pleasure of having such a cool bot like lambdabot
00:22:57 <omnId> @quote lambdabot
00:22:57 <lambdabot> lambdabot says: I CAN HAS CHEEZBURGER?
00:23:26 <ac> mudge: no, they don't
00:23:30 <dmwit> ?quote ..?..?.
00:23:30 <lambdabot> monochrom says: If you're having trouble learning monads, try to learn something harder, like algebraic geometry.
00:24:44 <dmwit> I wonder if every English word has some quote associated with it.
00:25:07 <harlekin> ?quote thee
00:25:08 <lambdabot> No quotes match. My mind is going. I can feel it.
00:25:17 <harlekin> Heh.
00:25:20 <dmwit> THAT'S NOT ENGLISH
00:25:24 <dmwit> =P
00:25:29 <harlekin> ^-^
00:25:50 <omnId> @quote prestidigitation
00:25:50 <lambdabot> No quotes match. It can only be attributed to human error.
00:28:02 <EvilTerran> ?quote intercalate
00:28:02 <lambdabot> No quotes match. stty: unknown mode: doofus
00:28:19 <EvilTerran> ?quote reticulating spline
00:28:20 <lambdabot> No quotes for this person. I can't hear you -- I'm using the scrambler.
00:28:34 <dmwit> SimCity 2000!
00:28:39 <EvilTerran> yaay! :D
00:28:40 <nornagon> :D
00:29:15 <omnId> dmwit: not played.  What are you reffering to?
00:29:46 <dmwit> There was this very odd thing when you started up SimCity 2000; a female voice would say "reticulating splines" right before everything started.
00:30:06 <dmwit> It always through me for a bit of a loop as a kid, because I didn't understand that the game actually had a sense of humor.
00:30:26 <dmwit> I just recently realized that "number of pigeons" is not really a metric anybody cares about for statues. =D
00:31:37 <EvilTerran> you can't cut back on funding! YOU WILL REGRET THIS!
00:31:57 <omnId> I wrote an expansion for sequence [(+2), (*3)] 4.  Well, part of one, anyway :)   Posting...
00:31:59 <EvilTerran> *ahem*
00:32:04 * EvilTerran goes to have breakfast
00:32:15 <nornagon> omnId: say, foldl (flip id)? :D
00:32:24 <nornagon> oh er
00:32:26 <nornagon> sequence
00:32:28 <nornagon> nm :/
00:32:37 <encryptio> :t flip id
00:32:39 <lambdabot> forall b c. b -> (b -> c) -> c
00:32:49 <nornagon> > foldl (flip id) 4 [(+2), (*3)]
00:32:50 <lambdabot>  18
00:33:05 <hpaste>  omnIdiot pasted "sequence in ((->) r) is not all that evil, but trying not to miss a paren is tiresome." at http://hpaste.org/3146
00:36:19 <dmwit> http://patcoston.com/co/common/529.wav "Reticulating Shplines"
00:37:23 <omnId> Shpl is not a consonant cluster you see in English that often.
00:39:45 * omnId does the second k expansion for fun
00:45:15 * omnId regrets it immediately
00:46:40 * omnId drowns in parens
00:46:49 <omnId> *glug*
00:48:30 * dmwit hands omnId a better editor
00:51:45 <geocalc> what's k expansion ?
00:52:25 <omnId> geocalc: re: my last paste, an expansion of the 'k' function.
00:52:32 <ac> @src ($)
00:52:32 <lambdabot> f $ x = f x
00:56:37 <omnId> success!
01:01:12 <hpaste>  omnId annotated "sequence in ((->) r) is not all that evil, but trying not to miss a paren is tiresome." with "phew..." at http://hpaste.org/3146#a2
01:01:39 <omnId> oops, dropped the 4 between steps two and three, oh well
01:01:49 <geocalc> omnId-> k mean ?
01:02:06 <omnId> geocalc: it's a local definition within sequence
01:02:09 <omnId> @src sequence
01:02:09 <lambdabot> sequence ms = foldr k (return []) ms
01:02:09 <lambdabot>     where
01:02:09 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
01:02:14 <omnId> k = liftM2 (:)
01:02:35 <omnId> "monadic cons"
01:03:32 <malcolmw> The Haskell Workshop videos are offline again - viewers exceeded my semi-monthly transfer limit of 100Gb in 24hrs!
01:03:32 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
01:03:56 <omnId> in sequence, in the reader monad, it conses the result of one function with the results of the rest of the list's functions.
01:04:54 <omnId> this is just the long way to say (sequence [(+2), (*3)]) == (\r -> [r + 2, r * 3])
01:05:23 <geocalc> mmh
01:09:54 <matthew-_> malcolmw: you could try bittorrenting it
01:10:29 <malcolmw> matthew-_: I'll attempt Google Video again first I think
01:11:01 <malcolmw> matthew-_: from a connection with better than 20kb/s upload speed :-)
01:12:18 <pejo> malcolmw, how big are they in total?
01:12:34 <malcolmw> pejo: 1.68Gb
01:13:04 <malcolmw> there are 14 videos (from HW) in total
01:14:02 <pejo> malcolmw, I could probably host them somewhere if you want?
01:14:29 <ac> if you're dealing with functions with one argument, " " and "$" have the same meaning, right?
01:14:44 <malcolmw> pejo: what kind of bandwidth do you have available?
01:15:13 <ac> nevermind
01:15:21 <pejo> malcolmw, right now? 100 Mbit. I might be able to arrange something faster given some time.
01:15:52 <malcolmw> pejo: I meant, do you have limits on how much data is transferred?
01:16:18 <geocalc> is ghc internal exposed in haskell via modules ?
01:16:23 <pejo> malcolmw, nah
01:16:31 <ndm> is this for video hosting?
01:16:43 <malcolmw> hi ndm: yes
01:17:01 <ndm> yay :-)
01:17:16 <geocalc> lol
01:17:27 <pejo> malcolmw, did you get slashdotted?
01:17:40 <malcolmw> ndm: sorry, you missed the 24 hour window in which the videos were available before my site closed down
01:17:51 <malcolmw> pejo: yep, reddited I think
01:17:57 <ndm> wow
01:19:02 <malcolmw> roughly 1000 video views in 24hrs - exceeded my hosting limits
01:19:04 <pejo> malcolmw, can I ftp/wget them from you somehow?
01:20:12 <geocalc> is haskell 200x is planed ?
01:20:21 <matthew-_> pejo: it sounds like you're going to host in academia?
01:20:35 <malcolmw> pejo: I'll have to think about that - I'm not sure I have anywhere with enough space to host it for FTP now
01:21:23 <matthew-_> pejo: if that is the case, someone somewhere has to pay for the bandwidth...
01:21:28 <pejo> matthew, we host ftp.se.freebsd.org too, so shouldn't be a problem.
01:21:45 <matthew-_> ahh, fair enough
01:21:52 <geocalc> 2008 ?
01:22:09 <ndm> malcolmw, www.cs.york.ac.uk/fp ?
01:22:09 <matthew-_> we should probably have some sort of round robin dns to spread the load.
01:22:17 <malcolmw> geocalc: it is called Haskell' (haskell prime)
01:22:29 <ndm> malcolmw, as long as you don't actually give anyone the link, pejo should be able to download them
01:22:30 <matthew-_> I have 4TB transfer a month available...
01:23:53 <malcolmw> pejo: is there any way I can upload by FTP to you?
01:25:36 * ndm can't even connect to SSH from here :-(
01:27:47 <quicksilver> has anyone written up a HAC report?
01:27:51 <quicksilver> I'm curious of how it went
01:28:45 <ndm> malcolmw, have you tried to upload to other video hosting networks? megavideo.com springs to mind, since they have a very lax copyright policy at least, so might not mind the quality thing
01:29:42 <malcolmw> ndm: it looks like pejo will be hosting the videos soon :-)
01:42:12 <geocalc> thanks pejo !
01:43:05 <ndm> @karma+ pejo
01:43:06 <lambdabot> pejo's karma raised to 1.
01:45:48 <pejo> Quite amazing that >50 people who weren't at HW are interested in watching the videos imho.
01:47:15 <ndm> i'm interested and i was there :)
01:47:19 <ndm> or rather i want to see my one
01:48:02 <pejo> There could be at most 10 speakers who are interested though!
01:48:30 <pejo> But it's probably a good idea to watch your own talk, now that you mention it.
01:49:43 <ndm> i think colin will want to see at least 3 :)
02:08:55 <yitz> names
02:09:41 <hpaste>  omnId annotated "sequence in ((->) r) is not all that evil, but trying not to miss a paren is tiresome." with "doing reader's liftM2 first makes it simpler." at http://hpaste.org/3146#a3
02:12:29 <yitz> mmm... haven't been here for a while... how do you talk to lambdabat again?
02:12:48 <masak> @tell yitz like this
02:12:48 <lambdabot> Consider it noted.
02:12:58 <omnId> yitz: /msg lambdabot @help
02:13:06 <yitz> thanks!
02:13:06 <lambdabot> yitz: You have 1 new message. '/msg lambdabot @messages' to read it.
02:13:11 <masak> :)
02:19:08 <ac> @vixen tell me about yourself
02:19:08 <lambdabot> what about me?
02:19:59 <omnId> @vixen what do you do for fun?
02:19:59 <lambdabot> i hang out with friends and surf
02:20:07 <omnId> @vixen that's cool
02:20:07 <lambdabot> it is pretty cool, isn't it?
02:20:59 <ac> @vixen how many lines of code are you?
02:20:59 <lambdabot> let's just say a few
02:21:02 <ac> ;)
02:21:25 <omnId> ac: such a rude question!  Never ask a lady her weight!
02:23:49 <omnId> yitz: '> code' is short for '@run code'
02:24:22 <omnId> > 1 + 1
02:24:24 <lambdabot>  2
02:25:31 <yitz> > let status="works" in unwords ["This", status]
02:25:33 <lambdabot>  "This works"
02:27:35 <omnId> @pl (let x = me x in x) dinner
02:27:35 <lambdabot> fix me dinner
02:27:58 <phf`> does anybody know how yi implements the buffer? my guess is a linked list with a zipper
02:30:04 <ac> omnId: does lambdabot have a command in scope that sends a /me message?
02:32:02 <pejo> ac, actions are just messages with a special prefix on the protocol level
02:32:37 <pejo> (Hence your client interprets them and shows stuff in a different colour etc).
02:32:55 <ac> > me "/me says hi"
02:32:56 <lambdabot>   Not in scope: `me'
02:33:06 <ac> bleh, not what I meant
02:33:11 <ac> > "/me says hi"
02:33:13 <lambdabot>  "/me says hi"
02:33:27 <ac> ... see what I mean?
02:34:03 <opqdonut> pejo: so how do you explain the difference between
02:34:07 * opqdonut this
02:34:08 <opqdonut> /me this
02:34:24 <omnId> a few people have the priviledges to make her say things
02:34:49 <gh__> hello
02:35:08 <pejo> opqdonut, your client translates the first /me to something different, and the second one it didn't translate, perhaps because you pressed some magic key-combo to make it ignore the leading /.
02:35:09 <gh__> has anyone successfully used checkinstall and cabal together ?
02:35:31 <opqdonut> pejo: yeah but what is the magic prefix on the protocol level?
02:35:38 <opqdonut> the thing a /me get's translated to?
02:36:39 <quicksilver> opqdonut: ^A
02:37:18 <quicksilver> phf`: 'linked' is a strange adjective for haskell data structures, since they all tend to be linked in some sense
02:37:28 <quicksilver> phf`: but yes, I'm sure Yi is based around zippers of one kind or another
02:38:41 <pejo> opqdonut, http://www.irchelp.org/irchelp/rfc/ctcpspec.html, look for "ACTION".
02:38:42 <lambdabot> Title: The Client-To-Client Protocol (CTCP)
02:38:55 <pejo> opqdonut, but quicksilver answered the question basically.
02:44:20 <geocalc> pejo-> this link is dead
02:44:34 <phf`> quicksilver: i don't know why i said linked. the sentiment i meant, is it something informal (add a zipper to list, hack until works) or it's some special datastructure described in some paper i could read
02:44:53 <quicksilver> phf`: There is a Yi paper; worth checking out
02:45:05 <quicksilver> phf`: I think it's just a variation on zipper, but I'm not sure
02:47:30 <SamB_XP> I would very much like to see an unlinked list ;-)
02:47:44 * KatieHuber points at java.lang.ArrayList, and shudders :p
02:47:55 <KatieHuber> er, java.util probably :/
02:48:10 <SamB_XP> a disconnected list, even
02:48:30 <KatieHuber> I have a problem where my IO actions aren't happening
02:48:37 <pejo> geocalc, hm? Lambdabot obviously got the title for the page?
02:48:46 <KatieHuber> I think this is because nothing depends on the result, so they're being lazily ignored
02:48:58 <KatieHuber> but I have no idea how to fix it
02:49:14 <SamB_XP> KatieHuber: eh?
02:49:19 <pjd> KatieHuber: the "main" action is what gets executed
02:49:27 <pjd> so you need to bind it in there, somehow
02:49:29 <SamB_XP> IO isn't usually lazy...
02:49:36 <pjd> directly or indirectly
02:49:57 <KatieHuber> so, main calls out to some C, which calls back to a function of type foo->bar->baz->IO ()
02:50:10 <haraldk> The ICFP arrangers are annoyingly slow to publish results on their website!
02:50:30 <KatieHuber> and that function calls out to a C function imported as type nup->quux->IO()
02:50:37 <pjd> KatieHuber: main itself is (or should be) just one big IO () value
02:50:41 <KatieHuber> the call in is working fine, the call out not so much
02:50:45 <KatieHuber> main is fine
02:51:04 <KatieHuber> so if i put a putStrLn in the function C calls, I see it
02:51:20 <KatieHuber> if I put a printf in the C function the haskell calls, I don't see it
02:51:32 <SamB_XP> haraldk: if you think they are slow at that, think how slow they will be to publish the genome sources!
02:51:39 <KatieHuber> I don't even have a clue where to begin looking for this :/
02:51:46 <KatieHuber> it worked, once...
02:51:50 <quicksilver> KatieHuber: FWIW, laziness can *never* prevent IO actions being evaluated
02:52:00 <quicksilver> KatieHuber: unless you use unsafeperformIO
02:52:11 <yitz> Or unsafeInterleaveIO
02:52:15 <quicksilver> KatieHuber: perhaps your FFI imports are wrong?
02:52:18 <haraldk> Can anyone confirm that the winning languages were C++, Perl and no further languages?
02:52:22 <KatieHuber> well, I had a problem once where a file wasn't getting read unless I printed its contents, because it was too lazy
02:52:30 <phf`> quicksilver: the paper doesn't go into the details of buffers, so i'll read the code, but later
02:52:32 <quicksilver> are you importing something as pure which s not pure
02:52:41 <SamB_XP> KatieHuber: yeah, that used unsafeInterleaveIO
02:52:48 <haraldk> (I wonder because of a kind of bet)
02:52:49 <KatieHuber> hmm
02:52:53 <quicksilver> KatieHuber: yes, sadly getContents is stupid, broken and unsafe, and so is readFiel
02:53:07 <quicksilver> KatieHuber: I complain about this about once a week but my complains fall on deaf ears :P
02:53:11 <KatieHuber> heh
02:53:30 <quicksilver> if you FFI import something as pure when it isn't, though
02:53:38 <geocalc> http://pejo.com/test.lambdabot.html
02:53:39 <quicksilver> that could cause a similar effect
02:53:47 <quicksilver> (that's effectively wrapping unsafePerformIO around it)
02:53:59 <KatieHuber> OK, is there something somewhere which explains how to do the foreign import/export safely ?
02:54:18 <KatieHuber> the link on the FFI page about "how to do this" is broke :/
02:54:22 <quicksilver> there is http://www.haskell.org/haskellwiki/FFI_Introduction
02:54:23 <lambdabot> Title: FFI Introduction - HaskellWiki
02:54:28 <yitz> > readFile "quicksilver_complaints.txt"
02:54:29 <lambdabot>  <IO [Char]>
02:54:30 <quicksilver> and also 'FFICookBook' linked form that page
02:54:36 <quicksilver> yitz: ;)
02:54:37 <yitz> Indeed, deaf ears.
02:55:00 <ac> quicksilver: hey, I finished a reasonable implementation. For the most part I could easily generalize it to n-dimensions (I had this in mind) except for one tricky function
02:55:11 <quicksilver> ac: nice!
02:55:14 <quicksilver> ac: what kind of speed is it?
02:55:26 <ac> quicksilver: uhm... let me test it
02:55:46 <ac> quicksilver: couple seconds for 256^2
02:55:54 * quicksilver nods
02:55:56 <quicksilver> yeah, that's what I take
02:56:07 <quicksilver> on a 2Ghz Core processor
02:56:13 <quicksilver> not great, but not a disaster
02:56:20 <quicksilver> I think it can probably be faster, haven't tried to optimize
02:56:43 <ac> quicksilver: yeah, I've got a 1.5ghz. It takes about 6 seconds for 512^2
02:56:56 <hpaste>  ac pasted "fast(er) perlin noise" at http://hpaste.org/3147
02:57:22 <ac> quicksilver: the only function I'll have trouble generalizing to n-dimensions is "stream2boxes2d"
02:57:37 <quicksilver> ac: I tried generalising all my types from GLdouble to 'Fractional d, RealFrac d' etc
02:57:44 <quicksilver> ac: so it would work for 'any sensible type'
02:57:52 <quicksilver> ac: that made it more than 2x slower :(
02:58:00 <ac> quicksilver: what's GLdouble?
02:58:30 <SamB_XP> ac: presumably OpenGL's Double-like type...
02:58:39 <quicksilver> yeah, it's Double really
02:58:42 <quicksilver> on my system at least
02:59:06 <ac> quicksilver: I'm using Ints for almost everything, and a little bit of floats I guess
02:59:31 <quicksilver> ac: you should try Double instead of Float
02:59:41 <quicksilver> Float is a stupid slow type which no one should use :P
03:00:06 <ac> well, I was just presuming I'm using floats. I never say "Float" anywhere, just "fromIntegral"
03:00:14 <quicksilver> you do say Float in at least one place :)
03:00:22 <quicksilver> cosInterp :: Int -> Int -> Float -> Int
03:00:27 <ac> oh yeah you're right
03:00:31 <quicksilver> and I daresay that fixes your types elsewhere
03:00:34 <ac> let me change that to Double and see if it goes faster
03:00:37 <quicksilver> by the magic of type inference
03:00:41 <ac> :)
03:01:10 <ac> quicksilver: no noticeable difference with Double there
03:01:14 <quicksilver> I'm using cubic interpolation not cosine
03:01:19 <quicksilver> I wonder if cosine is faster
03:01:24 <ac> quicksilver: I think it's much faster
03:01:27 <quicksilver> it might be, if the FPU has cosine built in
03:01:41 <quicksilver> I will do some systematic speed tests later
03:01:51 <quicksilver> got real work to do first though :)
03:02:17 <ac> quicksilver: lame. Let me know if you have any ideas on how to generalize stream2boxes2d to nd. It's a real mind bender for me
03:03:29 <quicksilver> yes, a bit fiddly
03:06:28 <KatieHuber> ac, quicksilver: there's another kind of noise (forget the name temporarily sorry) which is generally considered better for fragment shaders than perlin
03:06:38 <KatieHuber> would probably also be better suited to functional programming
03:06:52 <quicksilver> perhaps Simplex Noise?
03:06:56 <KatieHuber> that's the one :)
03:06:58 <geocalc> ac wwhere is the rest of files to be able to run your perlinoise ?
03:07:08 <quicksilver> Simplex Noise was written by Perlin too :)
03:07:09 <ac> geocalc: it's all in one file
03:07:14 * MyCatSchemes hugs xmonad.
03:07:22 <quicksilver> it's the same thing but N-tetrahedrons instead of N-cubes
03:07:33 <quicksilver> however it's somewhat more fiddly to code and I was being lazy
03:07:35 <quicksilver> ;)
03:07:53 <quicksilver> it's also more fiddly to make it cube-periodic
03:07:57 <quicksilver> and I wanted tileable textures!
03:08:11 <KatieHuber> I just figured since it's what gets implemented in the fragment shader (where fragments are independent) it'd be easier in the FP case too
03:08:25 <KatieHuber> I'm completely failing to find the GLSL implementation though
03:08:42 <ac> geocalc: does it work for you?
03:09:14 <geocalc> no gtk here ???
03:09:26 <ac> geocalc: oh nevermind, hpaste cut off the end
03:09:31 <ac> I'll break it in to two files
03:09:47 <quicksilver> KatieHuber: *nod* makes sense
03:09:51 <KatieHuber> ah, linked from here: http://www.davidcornette.com/glsl/links.html
03:09:53 <lambdabot> Title: GLSL Shaders - GLSL Links
03:10:13 <quicksilver> yup, read that PDF :)
03:10:21 <quicksilver> I'll bookmark that page anymoose
03:12:29 <KatieHuber> hmm, I don't see what I'm doing wrong with my IO stuff
03:12:52 <geocalc> KatieHuber-> what do you mean by glsl implementation ?
03:12:53 <KatieHuber> I think I'll make a teeny tiny example and see if that's similarly broken
03:13:19 <KatieHuber> geocalc: that link has a zip file with a GLSL shader which generates the noise fragment-by-fragment on the GPU
03:14:05 <geocalc> ahh glsl simplex noise
03:14:33 <ac> hmm. now that I've split it into two files, I'm seeing an error about the data constructor (which I'm importing) from the other file is not in scope
03:15:02 <geocalc> :(
03:15:27 <ac> shouldn't I be able to import a data constructor like any other name?
03:15:49 <TSC> I think you import the constructor as part of the data type
03:16:09 <TSC> E.g. import Data.Maybe (Maybe (Just))
03:16:10 <mux> you have export lines like, Foo(Constr1, Constr2) or Foo(..)
03:16:11 <quicksilver> there may be a difference between exporting it as a function (to construct) and exporting it as a constructor (to pattern match)
03:16:15 <TSC> Or something like that
03:16:21 <mux> or only Foo if you're not exporting the constructors
03:16:42 <ac> TSC: thanks, that is the syntax
03:17:46 <ac> geocalc: here, I'll post both now...
03:17:48 <hpaste>  ac pasted "perlin noise main" at http://hpaste.org/3148
03:17:58 <hpaste>  ac pasted "gtk support" at http://hpaste.org/3149
03:18:29 <ac> the code may be ugly, but give me a break, because it's my first Haskell program :-/
03:18:57 <ac> I'd appreciate tips though :)
03:19:07 <KatieHuber> hmr, my simple example works great :/
03:19:24 <geocalc> nice 0 app here :)
03:23:19 <ac> 0 app?
03:24:47 <KatieHuber> OK, I have narrowed my problem down
03:25:06 <KatieHuber> I need to call a foreign import ccall function once for each item in a haskell list
03:25:18 <KatieHuber> if I call it on (head list) it's fine
03:25:37 <KatieHuber> if I try to use mapM to call it on (take 3 list) it's not fine (appears not to terminate)
03:25:48 <KatieHuber> same for sequence_ $ map instead of mapM
03:26:07 <KatieHuber> in case it matters, it's declared
03:26:10 <KatieHuber> foreign import ccall "PatienceHS.h PlaceCard" placeCard ::
03:26:10 <KatieHuber>     Ptr () -> CInt -> CInt -> CInt -> CDouble -> CDouble -> IO ()
03:26:21 <quicksilver> and what's the C type?
03:26:23 <KatieHuber> (the Ptr() is given)
03:26:56 <KatieHuber> void PlaceCard(HsPtr userData, HsBool faceUp, HsInt suit, HsInt rank, HsDouble x, HsDouble y)
03:27:01 <KatieHuber> hmm, that bool shouldn't be there
03:27:23 <KatieHuber> fixing it to HsInt doesn't help though
03:27:25 <quicksilver> that looks odd to me
03:27:33 <quicksilver> if it's "CInt" on the haskell-side
03:27:38 <quicksilver> it should just be 'int' on the C-side, no?
03:27:44 <KatieHuber> should it?
03:27:52 <quicksilver> yes
03:28:00 <geocalc> ac still no gtk ui here i'm sure i downloaded a complete ghc but module not found !
03:28:08 <quicksilver> the 'CInt' type is defined to be "C's int"
03:28:13 <quicksilver> geocalc: gtk is a separate package
03:28:52 <KatieHuber> that does indeed appear to fix it, thanks
03:29:00 <quicksilver> yay :)
03:29:14 <KatieHuber> so what are the HsThingy types?
03:29:17 <quicksilver> the 'HS' type are only if you're trying to do inspection of haskell values from the C side
03:29:32 <quicksilver> the default FFI mode of usage is to keep the C side using plain ordinary C types
03:29:42 <quicksilver> and use CInt, CDouble, etc on the haskell side
03:29:53 <geocalc> when i downloaded it was bundled with it !!! the bad bundle
03:30:18 <KatieHuber> hmm, maybe I spoke too soon
03:30:37 <KatieHuber> yeah, it was a fluke :/
03:30:40 <KatieHuber> every so often it works
03:30:45 <ac> geocalc: you have to install gtk2hs in order to compile it. I think you only need libgtk if I give you the binary
03:30:55 <quicksilver> KatieHuber: HsPtr should be void *
03:31:01 <KatieHuber> yeah changed that too
03:31:05 <quicksilver> hmm
03:31:23 <KatieHuber> I'll paste some code
03:31:28 <quicksilver> cool
03:32:00 <hpaste>  Katie pasted "Haskell code" at http://hpaste.org/3150
03:32:48 <hpaste>  Katie annotated "Haskell code" with "Foreign import things" at http://hpaste.org/3150#a1
03:32:55 <geocalc> anyway i'll will build ghc head soon so i'll build all this time
03:33:31 <hpaste>  Katie annotated "Haskell code" with "Stuff calling foreign export stuff" at http://hpaste.org/3150#a2
03:33:48 <quicksilver> KatieHuber: does objective-C manage to compile that to C calling conventions?
03:34:07 <KatieHuber> anything that looks like a C function call is exactly a C function call
03:34:14 <KatieHuber> there's nothing like C++ magic going on
03:35:24 <SamB_XP> indeed
03:35:40 <quicksilver> KatieHuber: I would suspect that the problems are caused somehow by the stableptr stuff
03:35:49 <SamB_XP> all the magic is in square brackets or RTL function calls or something
03:36:00 <quicksilver> KatieHuber: I'm afraid I don't know how you're supposed to do that though
03:36:19 <quicksilver> there seems to be more casting going on than I'd expect :)
03:36:24 <KatieHuber> heh
03:36:32 <quicksilver> why use stableptr's at all?
03:36:37 <quicksilver> why not just alloca a plain Ptr
03:36:39 <quicksilver> in your main?
03:36:41 <KatieHuber> AFAICT from the docs I need a StablePtr to avoid things getting GC'd
03:37:02 <KatieHuber> but I have no idea how this is supposed to be done ;)
03:37:06 <SamB_XP> @type alloca
03:37:08 <lambdabot> Not in scope: `alloca'
03:37:12 <SamB_XP> @hoogle alloca
03:37:13 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
03:37:13 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
03:37:13 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
03:37:35 <SamB_XP> KatieHuber: I'm pretty sure alloca keeps whatever it allocates alive for the duration of the call
03:37:56 <quicksilver> hmm
03:38:12 <quicksilver> actually I think StablePtr is the right thing
03:38:15 <SamB_XP> otherwise it would just return it, not pass it to a given continuation ;-)
03:38:27 <quicksilver> StablePtr is for references to haskell values
03:38:37 <quicksilver> alloca is for 'Storable' stuff, i.e. exposed representation
03:38:44 <quicksilver> StablePtr for opaque representation
03:39:08 <SamB_XP> true
03:39:27 <KatieHuber> for what little it's worth, I've done something like this before and it seemed to work
03:39:33 <KatieHuber> but there were no infinite lists then
03:39:34 <SamB_XP> StablePtr is for Haskell things, alloca* for C things
03:39:56 <KatieHuber> I'm pretty sure it's when "states" (in makeAppState) is tiny that things work
03:40:22 <KatieHuber> when it's huge (so huge it might as well be infinite), which is the usual case, stuff hangs
03:40:37 <KatieHuber> so I guess something is forcing evaluation of more of that list than it should, somehow
03:40:58 <KatieHuber> could that be caused by (AppState (p:_)) <- deRefStablePtr oldPointer ?
03:41:07 <quicksilver> interesting
03:41:10 <quicksilver> I wouldn't have thought so
03:41:34 <quicksilver> I wouldn't expect stableptrs to do any forcing
03:42:00 <SamB_XP> how do you compute the list?
03:42:23 <KatieHuber> it's a depth-first search of a graph, with a history list to avoid cycling
03:42:39 <KatieHuber> the graph is absolutely massive, couldn't possibly ever get through it all
03:42:47 <KatieHuber> but hopefully the first bits are the most useful ;)
03:43:19 <SamB_XP> and you're sure even the first elements are generated okay/
03:43:21 <SamB_XP> ?
03:43:32 <KatieHuber> yeah, I've printed 'em out on the command-line and it works fine
03:43:58 <KatieHuber> I can get through a few thousands of nodes in a few seconds
03:44:04 <SamB_XP> huh
03:44:30 <SamB_XP> so what error do you get?
03:44:36 <KatieHuber> it just hangs
03:44:51 <KatieHuber> that foreign import call (placeCard) never makes it to ObjC land
03:45:49 <KatieHuber> in fact, if I stick a putStrLn immediately after the deref it doesn't get called either...
03:46:30 <quicksilver> you're definitely calling 'placeCards' with the right void*?
03:46:49 <quicksilver> I don't think I understand why placeCards has two different Ptr ()...
03:47:02 <KatieHuber> the first is the haskell state object (AppState)
03:47:11 <quicksilver> right
03:47:17 <quicksilver> as generated by the newStablePtr in main
03:47:19 <KatieHuber> the second is user data for the C callback (in this case, the thing that's drawing the card images)
03:47:28 <quicksilver> ah
03:47:33 <quicksilver> gotcha
03:48:10 <quicksilver> why not print out the value of the Ptr () ?
03:48:16 <quicksilver> at allocation and at call time
03:48:21 <quicksilver> make sure it's the same pointer
03:49:57 <KatieHuber> worryingly, both print 0x00000003
03:50:05 <quicksilver> well that's consistent at least
03:50:12 <quicksilver> stableptrs aren't really pointers :)
03:50:12 <KatieHuber> but definitely not a pointer :p
03:50:16 <quicksilver> it's a misnomer
03:50:19 <KatieHuber> that's the Ptr value, not the stableptr
03:50:23 <quicksilver> they're more like reference ids
03:50:28 <KatieHuber> guess it's the same though
03:50:37 <quicksilver> well they're pointers in a generic sense
03:50:41 <quicksilver> but not in the sense of addresses
03:52:43 <KatieHuber> it's definitely (AppState (p:_)) <- deRefStablePtr oldPointer that's taking the time
03:52:44 <SamB_XP> KatieHuber: you must have mixed them up somewhere
03:53:00 <KatieHuber> (in the sense that putStrLn on either side of it, before shows, after doesn't)
03:53:23 <KatieHuber> I tried (AppState ps) <- ............ and using "head" later to get p, to no avail
03:53:38 <SamB_XP> unless you mean that both the StablePtr and the Ptr that you had cast it from/to are the same
03:53:55 <KatieHuber> I can't print StablePtr, it says there's no show for it
03:54:07 <KatieHuber> the 0x0000003s are the Ptrs, going out to C and coming in from C
03:54:25 <SamB_XP> maybe you should seperate the pattern match from the deref?
03:54:34 <ac> KatieHuber: just out of curiosity, what are you working on?
03:54:42 <KatieHuber> solitaire game
03:55:41 <KatieHuber> hmm, when I separate it, the pattern match still causes a hang, even when it's not attached to the deref
03:55:58 <SamB_XP> I thought so
03:56:17 <KatieHuber> er, no it doesn't
03:56:21 <SamB_XP> eh?
03:56:26 <KatieHuber> well, a putStrLn after the let shows up
03:56:32 <KatieHuber> I'll paste code
03:56:35 <SamB_XP> oh, lets are lazy
03:56:51 <KatieHuber> so that proves nothing then
03:56:52 <SamB_XP> try pat <- return x
03:57:05 <SamB_XP> instead of let pat = x
03:57:33 <ac> KatieHuber: are some of the graphics in C?
03:57:39 <KatieHuber> yeah
03:57:48 <SamB_XP> objective C actually
03:57:57 <cpoucet> lo
03:58:06 <SamB_XP> but that's not much different
03:58:08 <ac> graphics programming is lots of fun
03:58:08 <hpaste>  Katie annotated "Haskell code" with "what it looks like now" at http://hpaste.org/3150#a3
03:58:18 <KatieHuber> so, "deref'd" is printed, "going to place cards" isn't
03:58:53 <cpoucet> eww
03:59:40 <SamB_XP> KatieHuber: so... somehow that pattern match is either diverging or just taking a long time
04:00:33 <KatieHuber> if you scroll up to makeAppState you can see most of the definition of the list, if there's something there to indicate badness
04:00:42 <SamB_XP> which probably means your troubles are completely unrelated to StablePtr
04:01:04 <KatieHuber> at least it's now a Haskell question instead of an FFI question :)
04:01:17 <SamB_XP> quite ;-)
04:01:53 <quicksilver> you can try the same pattern match on the output of makeAppState
04:02:00 <quicksilver> before you even pass it to newStablePtr
04:02:04 <vincenz> KatieHuber: why not de-c it a bit
04:02:11 <quicksilver> is it literally the 'first time' that it hangs?
04:02:19 <quicksilver> so the state shoulsd still be the initial state?
04:02:31 <KatieHuber> in fact, the state never gets changed (step isn't called)
04:02:40 <SamB_XP> vincenz: well the FFI doesn't support ObjC calls does it?
04:02:40 <KatieHuber> if I put that pattern match into main it works fine
04:02:55 <vincenz> SamB_XP: hmm?
04:02:58 <vincenz> that's not what I mean
04:03:02 <KatieHuber> I'm assuming vincenz wants some wrapper functions around the FFI imports & exports
04:03:29 <vincenz> nope
04:03:38 <KatieHuber> er, I lied again, it doesn't work in main
04:03:45 <quicksilver> ah, good
04:03:47 <KatieHuber> stupid sometimes-works thing :)
04:03:55 <quicksilver> we're definitely back into haskell-land then
04:04:02 <quicksilver> that's before stableptrs happen
04:04:04 <hpaste>  vincenz annotated "Haskell code" with "somewhat cleaner" at http://hpaste.org/3150#a4
04:04:16 <vincenz> whoops, forgot a "
04:04:32 <quicksilver> I checked with the GHC guys: castStablePtr is essential a NOP, and deRefStablePtr is a one-line lookup
04:04:40 <quicksilver> they certainly shuoldn't be able to force anythign
04:05:13 <KatieHuber> vincenz: I just want it to work, refactoring after correctness :p
04:05:25 <KatieHuber> anyway, that function is now solidly ruled out of the equation
04:05:35 <KatieHuber> I should make a new paste with the broken haskell code alone
04:05:55 <vincenz> KatieHuber: fair 'nunff
04:06:27 * SamB_XP goes to school... late again...
04:06:39 <malcolmw> new location for Haskell Workshop videos: http://www.ludd.ltu.se/~pj/hw2007/HaskellWorkshop.html
04:06:41 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
04:06:50 * vincenz is wearing his hackathon t-shirt at work and spreading the word :)
04:07:21 <malcolmw> I wonder how long it will take before this server gets slashdotted too :-)
04:07:39 <pejo> Lets hope this works, I have to do other stuff offline for a couple of hours. :-)
04:07:43 <merus> good luck, malcolmw :)
04:10:25 <tolik> KatieHuber: stepState definition feels somewhat bizarre
04:10:27 <hpaste>  (anonymous) annotated "Haskell code" with "(no title)" at http://hpaste.org/3150#a5
04:11:12 <KatieHuber> it is, fortunately it's not currently being called :)
04:14:39 <malcolmw> hmm, Google Video has truncated the ICFP programming contest video from 1hr 23mins to 1min 6sec
04:14:40 <hpaste>  Katie pasted "the problematic code..." at http://hpaste.org/3151
04:15:37 <KatieHuber> I can't possibly make AnyUIPatience go through dfs instead of BeleagueredCastle because I can't define Eq or Ord for it
04:15:56 <KatieHuber> don't see why that'd make a difference though
04:22:47 <KatieHuber> taking out the existentials doesn't help any :/
04:24:31 <KatieHuber> heh, it's breakAfter's fault
04:24:44 <KatieHuber> ... obviously :/
04:25:43 <quicksilver> break forces l up until the first place that p suceeds
04:25:51 <quicksilver> or.. hmm
04:25:53 <quicksilver> does it?
04:25:58 <KatieHuber> break doesn't, it's fine
04:26:05 <KatieHuber> breakAfter does due to the pattern match on the second list being []
04:26:22 <KatieHuber> I can rewrite breakAfter to not force stuff easily
04:26:48 <quicksilver> oh yes, good point :)
04:27:21 <quicksilver> appendHead xs ys = xs ++ (take 1 ys)
04:27:22 <quicksilver> ?
04:29:24 <hpaste>  Katie annotated "the problematic code..." with "fixed breakAfter" at http://hpaste.org/3151#a1
04:29:27 <mux> when you write FFI bindings, and that you use ForeignPtr's, is it usual to still export a function calling finalizeForeignPtr for the sake of applications that may need to have maximum control over memory usage?
04:30:12 <_achilles_> bye
04:30:17 <KatieHuber> thanks for all the help all :)
04:31:17 <Zao> Now I feel somewhat silly. I just discovered the x{val=newval} syntax for changing one or more elements of an data.
04:31:28 <quicksilver> yes it's handy that
04:31:29 <KatieHuber> :o
04:31:37 <KatieHuber> why has nobody mentioned this before!
04:31:44 <quicksilver> Zao: it's not technically changing, of course, but I'm sure you know that
04:31:51 <Zao> quicksilver: I knew that one was coming :)
04:34:06 * quicksilver disagrees violently with ndm
04:40:11 <titusg> how come I can use `let' but not `where' in a lambda?
04:40:40 <quicksilver> titusg: cos of syntax
04:40:56 <titusg> quicksilver: simple as that eh?
04:41:11 <quicksilver> titusg: 'where' is syntactically permitted after declarations, which means  top-level definitions and let clasues
04:41:20 <scook0> you can't use guards either, I believe (on lambdas)
04:41:26 <vincenz> or where clauses :)
04:41:32 <vincenz> you can have where's on where's
04:41:48 <quicksilver> vincenz: you can use guards on where clause definitions
04:41:52 <quicksilver> maybe that's not what you wer saying
04:42:05 <vincenz> you can have nested wheres
04:42:06 <mauke> > (\x | x -> 42) True
04:42:06 <lambdabot>  Parse error
04:42:24 <scook0> vincenz: arguably a (declaration with a where) is just a declaration, though I haven't checked the syntax spec ;)
04:42:34 <scook0> @where report
04:42:34 <lambdabot> http://www.haskell.org/onlinereport/
04:42:40 <titusg> it seems a bit disappointing that \ is a special case
04:42:49 <vincenz> scook0: indeed
04:42:50 <quicksilver> titusg: \ is like let
04:42:53 <quicksilver> sort of
04:42:56 <quicksilver> it's like a single let
04:43:09 <quicksilver> I'm not sure it's fair to say it's a "special" case
04:43:13 <quicksilver> they're all special cases :)
04:43:19 <quicksilver> there are only 3 or 4 binding forms
04:43:24 <quicksilver> top-level, let, where and \
04:43:30 <quicksilver> also <- inside do blocks
04:43:38 <mux> and in list comprehensions?
04:43:40 <vincenz> > foo x y z = bar y z  where {bar n m = x + dum m where {dum m = n + m}}
04:43:40 <lambdabot>  Parse error
04:43:46 <vincenz> > foo x y z = bar y z  where {bar n m = x + dum m; where {dum m = n + m}}
04:43:46 <lambdabot>  Parse error
04:43:47 <titusg> quicksilver: thinking of it as a let makes more sense
04:43:48 <vincenz> meh
04:43:54 <vincenz> it works on plurilines
04:43:54 <quicksilver> vincenz: lambdabot can't do definitions
04:44:11 <quicksilver> vincenz: you'd need to wrap that whole thing in a let
04:44:18 <mux> there's @let :)
04:44:41 <vincenz> ah rght :)
04:44:47 <vincenz> > let foo x y z = bar y z  where {bar n m = x + dum m; where {dum m = n + m}} in foo 1 2 3
04:44:47 <lambdabot>  Parse error
04:44:52 <vincenz> > let foo x y z = bar y z  where {bar n m = x + dum m where {dum m = n + m}} in foo 1 2 3
04:44:54 <lambdabot>  6
04:44:58 <vincenz> nested wheres
04:45:03 <vincenz> notice how dum refers to 'n'
04:45:06 <mux> @let fac n = product [1..n]
04:45:07 <lambdabot> Defined.
04:45:14 <mux> > fac 5
04:45:15 <lambdabot>  120
05:01:38 <vincenz> @seen roconnor
05:01:38 <lambdabot> I saw roconnor leaving #haskell-hac07 and #haskell 19h 15m 36s ago, and .
05:30:37 <nornagon> so, i hear there are 'write a scheme interpreter in scheme' tutorials
05:30:37 <nornagon> are there any 'write a haskell interpreter in haskell' tutorials?
05:30:37 <quicksilver> no
05:30:37 <quicksilver> haskell is belived to be 10^23 times harder to interpret than scheme :)
05:30:37 <nornagon> is it significantly more difficult?
05:30:47 <nornagon> just because of syntax?
05:31:17 <Zao> Look at the ghci source?
05:31:17 <quicksilver> nornagon: not just because of syntax, no
05:31:17 <quicksilver> because of:
05:31:17 <quicksilver> 1) syntax
05:31:17 <quicksilver> 2) type inference
05:31:17 <quicksilver> 3) class resolution
05:31:26 <quicksilver> 4) class implementation (dictionary passing?)
05:31:27 <matthew_-> 'write a haskell type checker in prolog' tutorials?
05:31:37 <nornagon> you could presumably come up with a limited sort of haskell, with no typeclasses?
05:31:41 <cpoucet> there's a paper for "typing haskell in haskell"
05:31:42 <quicksilver> sure
05:31:43 <cpoucet> @where thigh
05:31:43 <lambdabot> I know nothing about thigh.
05:31:45 <cpoucet> @where thih
05:31:45 <lambdabot> I know nothing about thih.
05:31:49 <cpoucet> @google thih
05:31:51 <lambdabot> http://howithappened.com/
05:31:51 <lambdabot> Title: that's how it happened
05:31:55 <cpoucet> @google thih type:pdf
05:31:58 <lambdabot> http://portal.acm.org/ft_gateway.cfm?id=871907&type=pdf&coll=GUIDE&dl=ACM
05:31:59 <quicksilver> nornagon: you probably just mean typed lambda calculus
05:32:08 <nornagon> i guess so :)
05:32:30 <quicksilver> nornagon: it's certainly not that hard to write a typed lambda calculus interpreter; the type checker/inferrer being the hardest part
05:32:46 <quicksilver> there must be a few textbooks with that as an example, I would have thought
05:33:36 <malcolmw> Bernie Pope's "baskell" project is a mini-interpreter for a haskell-like language - it's pretty small and neat
05:33:49 <nornagon> @go baskell
05:33:49 <njbartlett> There's an example type-checker for an ML-like language in the Scala tutorial docs
05:33:53 <lambdabot> http://www.mp3.com/artist/baskell-rose/summary/
05:33:53 <lambdabot> Title: Baskell Rose MP3 Downloads - Baskell Rose Music Downloads - Baskell Rose Music V ...
05:33:57 <nornagon> haha
05:34:02 <nornagon> @go baskell haskell
05:34:05 <lambdabot> http://www.haskell.edu/athletics/gallery/CategoryUserList.asp?CatID=7
05:34:25 <malcolmw> @google bernie pope baskell
05:34:26 <lambdabot> http://www.cs.mu.oz.au/~bjpop/code.html
05:34:26 <lambdabot> Title: Bernie Pope's fun Haskell code
05:44:55 <pastorn> @where haskell prime
05:44:56 <lambdabot> http://haskell.org/
05:45:00 <pastorn> @where haskell'
05:45:01 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
06:09:23 <cpoucet> Anyone have familiar with haskell-mode, when I trry to load inferior-haskell, it tells me "process haskell not running"
06:10:08 <quicksilver> run-haskell
06:13:12 <cpoucet> quicksilver: and to use C-c C-t?
06:14:55 <Saizan_> cpoucet: you've to C-c C-l
06:14:57 <Saizan_> first
06:15:52 <Saizan_> and the interpreter has to load it successfully
06:16:18 <cpoucet> still not working
06:16:57 <cpoucet> C-c C-t ... asks me what function I want (by default the function I selected).  I press enter and get  (in the little miniline at the bottom, not the window of the interpreter) <interactive>:1:0 Not in scope: `foo'
06:18:56 <cpoucet> Saizan_: ?
06:30:22 <mrd> cpoucet: did you load your file yet?
06:30:31 <cpoucet> yes
06:30:38 <cpoucet> It seems I had -2- haskell interpreters running
06:30:50 <mrd> fun
06:30:56 <mrd> more the merrier
06:31:44 <cpoucet> ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)
06:31:49 <cpoucet> that line uncommented would bork everything
06:33:15 <mrd> oh yea
06:33:19 <cpoucet> how come?
06:33:32 <mrd> that's the old deprecated mode
06:33:37 <cpoucet> oh
06:33:52 <mrd> it's been superseded by inf-haskell
06:33:59 * cpoucet nods
06:34:25 <mrd> basically i just go to the directory i want haskell to run from and type M-x run-haskell.  prefix C-u to pick the precise command it runs.
06:34:59 <cpoucet> "go to the directory" ?
06:35:19 <matthew_-> mrd: which package is that?
06:35:27 <matthew_-> s/package/mode/
06:35:56 <mrd> matthew_-: the old one? ghci.el or something
06:36:07 <matthew_-> oh ok
06:36:27 <mrd> cpoucet: 'cd' or open file, etc
06:36:39 <cpoucet> hwo do you cd in emacs?
06:36:59 <mrd> open a  buffer in that directory
06:37:08 <cpoucet> oh with the emacsclient?
06:37:21 <mrd> its not important
06:37:33 <mrd> C-x C-f or wtever
06:37:36 <allbery_b> doesn't matter how you do it
06:37:42 * cpoucet shrugs
06:37:46 <fasta> I have an implicit mapping from a list element x to a number. I want that the sum of these numbers is always even when it is given to another function. Are such things expressible in Haskell in some sane way? And more specifically: how?
06:37:54 <cpoucet> What directory does run-haskell run from?
06:38:03 <allbery_b> you M-x run-haskell from a buffer containing a file in that directory
06:38:09 <quicksilver> the directory of the buffer you're in when you run it
06:38:13 <cpoucet> hmm, which is annoying if you have no files in your root-dir
06:38:14 <quicksilver> if you get it wrong there is always :cd
06:38:16 <cpoucet> (of your projecT)
06:38:16 <mrd> allbery_b: or dired the dir
06:38:30 <mrd> cpoucet: emacs opens 'directories' into dired mode
06:39:03 <fasta> Smart constructors only move the problem elsewhere, AFAIK.
06:39:27 <fasta> I would need a way to start with a proof that it is even initially and add a proof for every function that it doesn't break the invariant.
06:39:49 <mrd> fasta: you could express that thinking, somewhat, with GADTs
06:39:50 <allbery_b> you could also M-: (setq default-directory "/path...") RET but that is probably not what you usually want
06:40:04 <fasta> mrd: do you know of a non-trivial example?
06:40:10 <allbery_b> (it's also buffer-local)
06:40:12 <chessguy> is there a standard way to convert a Data.Array to a list?
06:40:27 <mrd> fasta: the examples of Empty vs NonEmpty lists and "typesafe" head/tail
06:40:36 <mrd> chessguy: a list of what
06:40:52 <mrd> assocs, elems, or keys
06:41:02 <mrd> well i guess keys is pointless.
06:41:08 <edwardk> @type assocs
06:41:09 <mrd> but assocs and elems are the two functions you'll want
06:41:14 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
06:41:34 <edwardk> @type elems
06:41:35 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
06:41:38 <_ry> i am trying to write a function that will split a string into a list of strings given some character - but i don't know how? is there an easy solution
06:41:39 <quicksilver> chessguy: normally elems, assocs if you need the indices
06:41:42 <chessguy> ah, elems was what i was looking for
06:41:46 <chessguy> thanks
06:42:08 <mrd> _ry: there's a fairly simple recursive function you can write using span and break.  or you can use Text.Regex.splitRegex
06:42:11 <idnar> @type keys
06:42:13 <lambdabot> Not in scope: `keys'
06:42:33 <Japsu> http://gimbo.org.uk/blog/2007/04/20/splitting-a-string-in-haskell/
06:42:36 <lambdabot> Title: gimboland » Python-style string split (and strip / trim) in Haskell, http://tinyurl.com/344k4u
06:42:53 <oerjan> @hoogle Array i e -> [i]
06:42:54 <lambdabot> No matches, try a more general search
06:42:56 <mrd> @type Data.Map.keys
06:42:56 <fasta> mrd: can one encode arbitrary properties in that system?
06:42:58 <lambdabot> forall k a. Data.Map.Map k a -> [k]
06:43:17 <mrd> fasta: no .. it's not dependent typing
06:43:34 <mrd> fasta: but simple stuff like "EvenSum" "OddSum" should be doable
06:43:38 <idnar> @type range
06:43:40 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
06:43:48 <fasta> mrd: I doubt it's simple in my case.
06:43:50 <idnar> range . bounds or something
06:44:01 <oerjan> @type indices
06:44:03 <lambdabot> forall i e. (Ix i) => Array i e -> [i]
06:44:14 <fasta> mrd: I.e. I don't think anyone on this planet can encode what I want within a week.
06:44:25 <mrd> fasta: even Oleg?
06:44:28 <fasta> mrd: right
06:44:37 <mrd> ok, I guess you're screwed
06:44:59 <mrd> you need 1 Oleg week of type hackery
06:45:03 <quicksilver> well the "simple" but heavyweight answer is to explicitly include the proofs in the data
06:45:12 <quicksilver> a tuple of functions along with your actual data
06:45:14 <fasta> mrd: I don't think I will try to encode it, since Haskell is not suitable for it.
06:45:23 <quicksilver> but that's not necessarily a pleasant job
06:45:45 <mrd> then don't.  write separate proofs. /shrug
06:47:13 <allbery_b> ...epigram?
06:48:08 <mrd> agda2?
06:48:31 <Philippa> fasta: you can't do arbitrary in haskell, but modulo termination you can encode most things that don't require you to reason about how many times a value's used
06:49:13 <nornagon> oh dear, is there no libpng binding for haskell? :(
06:51:29 <quicksilver> nornagon: there is a real shortness of image loaders
06:54:23 <nornagon> quicksilver: i'm noticing that :/
06:54:32 <Eelis> the status table in the README of hs-plugins doesn't list x86_64-linux. does anybody know if hs-plugins works on x86_64-linux?
06:54:37 <Saizan_> interpreting a haskell type as a logic formula, type constructors are predicates?
06:54:44 <nornagon> it would be great if libpng didn't suck so much
06:55:20 <Eelis> Saizan_: pretty much
06:55:55 <fasta> Another thing is that I haven't seen anyone writing proofs for code in the ST monad.
06:56:05 <allbery_b> @version
06:56:06 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
06:56:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:56:27 <allbery_b> hm, for some reason I thought dons's uebermachine was amd64
07:00:31 <quicksilver> allbery_b: I believe dons has access to an ubermachine, but it's not the one lambdabot runs on
07:00:59 <quicksilver> allbery_b: he has run speed tests of some stuff on a 16-core machines IIRC
07:04:15 <chessguy> grr, why does drawTree not actually look like a tree on anything i run it from
07:04:18 <chessguy> it'
07:04:29 <chessguy> it's just one long string with a bunch of \n's in it
07:05:00 <oerjan> :t drawTree
07:05:06 <lambdabot> Tree String -> String
07:05:11 <fasta> chessguy: it does
07:05:15 <fasta> chessguy: it's rotated
07:05:25 <fasta> chessguy: :)
07:05:33 <fasta> chessguy: still, I don't like it
07:05:36 <chessguy> ah, putStr to the rescue
07:05:42 <oerjan> chessguy: are you print'ing the String instead of putStr'ing it?
07:05:44 <fasta> Heh
07:05:53 <chessguy> fasta, no, it doesn't. i'll thank you not to tell me what my computer's doing
07:06:21 <chessguy> oerjan, i was just evaluating the string, instead of putStr'ing or printing it
07:06:41 <oerjan> @index drawTree
07:06:42 <lambdabot> Data.Tree
07:08:42 <quicksilver> Oh, by the way, I have a new hatred targer
07:08:50 <quicksilver> today, I hate the Show instance for StdGen
07:09:10 <oerjan> why?
07:09:18 <oerjan> > mkStdGen 1
07:09:21 <lambdabot>  2 1
07:09:32 <quicksilver> because it doesn't generate something I can copy-paste into haskell code
07:09:34 <quicksilver> (or the repl)
07:09:55 <oerjan> > read (mkStdGen 1) :: StdGen
07:09:56 <lambdabot>  Couldn't match expected type `String'
07:09:57 <quicksilver> if I write "data Foo = Foo StdGen Int Int deriving (Show)"
07:10:07 <oerjan> > (read . show) (mkStdGen 1) :: StdGen
07:10:09 <lambdabot>  2 1
07:10:17 <quicksilver> then if I "show $ Foo (mkStdGen 0) 5 7"
07:10:25 <quicksilver> I et the string "Foo 1 1 5 7"
07:10:29 <quicksilver> which is no use to anyone :P
07:10:33 <quicksilver> it's got the wrong number of parameters
07:10:55 <oerjan> it can be used with read though
07:11:03 <quicksilver> yup
07:11:06 <quicksilver> but not pasted into haskell code
07:11:08 <quicksilver> or the repl
07:14:28 <ac> quicksilver: I figured out how to generalize stream2boxes. In a day or two I'll piece together a truely n-dimensional implementation :)
07:15:01 <quicksilver> ;)
07:15:02 <quicksilver> ysy
07:15:19 <quicksilver> ac: I did some tests over my lunch break and my code is inexplicable a factor of thre slower
07:15:25 <quicksilver> ac: I wonder what I did to it :P
07:15:34 <ac> quicksilver: slower than what?
07:15:42 <quicksilver> than it used to be
07:15:51 <ac> quicksilver: hah. that's odd.
07:15:58 <quicksilver> Oh
07:16:07 <quicksilver> I forgot to run with the right RTS options
07:16:09 <quicksilver> that explains it :)
07:16:37 <ac> quicksilver: currently I'm puzzling over the problem of how to generate all possible lists of ints from [0..n] of length n+1 and containing at least one n
07:16:47 <fasta> quicksilver: are you sure it weren't the gremlins?
07:16:59 <quicksilver> fasta: it may be the gremlins who removed the RTS options
07:17:06 <quicksilver> but once I returns them it worked again :)
07:17:11 <ac> quicksilver: what's RTS?
07:17:18 <fasta> Run Time System
07:17:41 <quicksilver> ac: I'm running GLUT in my main thread and the texture rendering in anotehr thread
07:17:48 <quicksilver> ac: therefore I need threading to run properly
07:18:01 <quicksilver> ac: otherwise my texture thread only gets occasional timeslices and takes 3x longer than it should :)
07:18:15 <fasta> All this multi-core business is pretty pointless if you see the Reduceron.
07:18:18 <ac> quicksilver: huh. I wonder if I'd benefit from using GL whan I start making animations
07:18:57 <ac> quicksilver: that is my current goal
07:19:12 <quicksilver> ac: I daresay gtk is as good at animations as openGL
07:19:21 <quicksilver> ac: I just didn't fancy fighting with a widget toolkit :P
07:19:38 <quicksilver> ac: widget toolkit are great for writing word processors but they always get in my way when I'm just hacking around
07:19:40 <nornagon> ugh, this ffi stuff is breaking my head
07:19:55 <nornagon> i can't even work out how to bind png_sig_cmp
07:20:02 <ac> quicksilver: it's not bad at all, and if I want to add widgets later for user selectable options it will be really easy
07:20:15 <nornagon> because i think i'll want to do some sort of bytestring stuff
07:20:53 <quicksilver> ac: you're probably right.
07:21:03 <oerjan> > let nL n = [bef++[n]++aft | m <- [0..n-1], bef <- replicateM m [0..n-1], aft <- replicateM (n-1-m) [0..n]] in nL 3
07:21:07 <quicksilver> ac: I'm mainly using openGL for this because its intended use was another openGL project
07:21:15 <lambdabot>  [[3,0,0],[3,0,1],[3,0,2],[3,0,3],[3,1,0],[3,1,1],[3,1,2],[3,1,3],[3,2,0],[3,...
07:21:21 <quicksilver> ac: and having already just learnt openGL I didn't want to try something didfferent :)
07:21:38 <ac> quicksilver: yeah I remember you mentioning you wanted to take slices and render them on 3D objects
07:21:54 <mrd> gtkGLext works with haskell and supplants GLUT
07:22:03 <nornagon> so, speaking of openGL
07:22:09 <nornagon> who wants to bind libpng for me
07:22:10 <mrd> so it's a good alternative if you don't want to use GLUT with OpenGL
07:22:10 <nornagon> <.<
07:22:35 <oerjan> ac: ^^
07:22:46 * quicksilver nods
07:22:52 <ac> :type (^^)
07:22:56 <oerjan> oh wait
07:22:57 <nornagon>  .z 24
07:22:59 <nornagon> gah
07:23:06 <oerjan> ^^ means look above
07:23:11 <idnar> there should be a (^_^) operator
07:23:17 <nornagon> :D
07:23:17 <fox86> does anyone here use emacs with haskell? any configurations/modes you would recommend?
07:23:29 <oerjan> although i messed up the total length
07:23:49 <birkenfeld> fox86: the "official" haskell-mode works well for me
07:24:01 <oerjan> > let nL n = [bef++[n]++aft | m <- [0..n], bef <- replicateM m [0..n-1], aft <- replicateM (n-m) [0..n]] in nL 2
07:24:01 <nornagon> > let =^.^= = ++ "teh kitty!" ++ in "look at " =^.^= " pretty!"
07:24:02 <lambdabot>  Parse error
07:24:03 <dolio> I used haskell-mode when I used emacs. It was nice.
07:24:03 <lambdabot>  [[2,0,0],[2,0,1],[2,0,2],[2,1,0],[2,1,1],[2,1,2],[2,2,0],[2,2,1],[2,2,2],[0,...
07:24:06 <nornagon> aw.
07:24:09 <birkenfeld> fox86: see http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
07:24:10 <lambdabot> Title: Emacs Lisp packages
07:24:17 <fox86> birkenfeld: does it come with emacs by default?
07:24:25 <birkenfeld> I don't think so
07:24:28 <ac> @src (^^)
07:24:29 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
07:24:30 <birkenfeld> at least I had to emerge it separately
07:24:54 <fox86> okay. thank you
07:24:55 <oerjan> nornagon: parentheses around operators when not infix (as in before that =)
07:25:09 <idnar> > let a =^.^= b = a ++ "teh kitty!" ++ b in "look at " =^.^= " pretty!"
07:25:10 <lambdabot>  "look at teh kitty! pretty!"
07:25:46 <pastorn> if i have a list and need to work with it in "chunks" of varying length, will splitAt be O(n) then?
07:25:56 <birkenfeld> @pl \a b -> a ++ "x" ++ b
07:25:56 <lambdabot> (. ('x' :)) . (++)
07:26:04 <sjanssen> pastorn: yes, splitAt n is O(n)
07:26:18 <sjanssen> pastorn: you might try Data.Sequence instead of a list
07:26:31 <ac> @hoogle replicateM
07:26:32 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
07:26:32 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
07:26:39 <nornagon> http://linuz.sns.it/~monge/wiki/index.php/Milfoh <-- oho
07:26:42 <lambdabot> Title: Milfoh - MaurizioHomepage
07:26:43 <nornagon> oerjan: ah
07:26:51 <birkenfeld> @src replicateM
07:26:51 <lambdabot> replicateM n x = sequence (replicate n x)
07:26:57 <ac> oerjan: what inspired you to write that? :)
07:27:11 <pastorn> so for (this,rest) = splitAt n xs i will not need to do extra calculations when i call for rest (in f xs = dostuff this : f rest)
07:27:19 <nornagon> @pl \a b -> a ++ "foo" ++ b
07:27:19 <lambdabot> (. ("foo" ++)) . (++)
07:27:22 <oerjan> ac: you said you were pondering it
07:27:29 <ac> oerjan: you make it too easy :P
07:27:34 <birkenfeld> nornagon: (++ "foo" ++) would be nicer...
07:27:50 <pastorn> @hoogle Sequence
07:27:50 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
07:27:50 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
07:27:50 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
07:27:53 <ac> oerjan: that's what I get for voicing my preliminary ponderings
07:27:53 <sjanssen> and syntactically invalid
07:27:56 <nornagon> :t (++ "foo" ++)
07:27:58 <birkenfeld> yep
07:27:58 <lambdabot> parse error on input `)'
07:28:03 <sjanssen> @docs Data.Sequence
07:28:03 <lambdabot> Data.Sequence not available
07:28:05 <sjanssen> grr
07:28:06 <birkenfeld> thus the "would"
07:28:13 <sjanssen> @docs
07:28:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
07:28:14 <pastorn> @where Sequence
07:28:14 <lambdabot> http://sequence.complete.org
07:28:18 <birkenfeld> hoogle seems to be a bit out of date, generally
07:28:19 <sjanssen> pastorn: ^^^ search that page
07:28:27 <quicksilver> ac: hmm This texture takes 6 seconds :(
07:28:33 <ac> oerjan: I was just going to generate all possibilities and filter them for n
07:28:35 <ac> quicksilver: at what size?
07:28:36 <quicksilver> ac: but then that's about right, because it has three layers of noise
07:28:40 <quicksilver> ac: 256x256
07:28:44 <birkenfeld> it often finds only the haskell98 api docs which have no explanation
07:28:45 <ac> quicksilver: mine's faster!!
07:28:49 <quicksilver> ac: nod :(
07:29:09 <oerjan> ac: you can use replicateM for that too
07:29:26 <ac> quicksilver: though I took a fair amount of time in doing it in such a way as to never duplicate an interpolation call, and also I'm using faster cosine interpolation
07:29:29 <oerjan> has the advantage you get the list ordered
07:29:35 <hpaste>  Tac-Work pasted "Case Madness!" at http://hpaste.org/3153
07:30:08 <quicksilver> Tac-Tics: yes. You can't use variables on the left
07:30:15 <quicksilver> Tac-Tics: or rather, if you do, it's a binding form
07:30:27 <quicksilver> Tac-Tics: z -> 'c' means "match anything and bind what we do match to z"
07:32:19 <ac> oerjan: I don't care if they're ordered
07:32:51 <Tac-Tics> ack! dur
07:32:53 <Tac-Tics> that makes sense
07:33:00 <pastorn> @src Data.Sequence.empty
07:33:00 <lambdabot> Source not found. I feel much better now.
07:33:06 <Tac-Tics> haskell really needs a "cond" statement =-(
07:33:16 <fasta> Tac-Tics: ?
07:33:17 <pastorn> @src Data.Sequence.singleton
07:33:17 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:33:21 <pastorn> @src singleton
07:33:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:33:24 <pastorn> awww
07:33:28 <oerjan> Tac-Tics: you can do that with guards
07:33:28 <mauke> case () of _ | cond ->
07:33:47 <fasta> Tac-Tics: What should it do?
07:33:53 <mattrepl> this must be in the GHC docs, but: is there a way to make a Haskell module available to C code?  reverse-FFI, if you will
07:34:18 <fasta> Tac-Tics: I already wrote one with fundeps.
07:34:46 <mauke> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-140003.4
07:34:47 <lambdabot> Title: 3 Foreign Declarations, http://tinyurl.com/yezf7t
07:34:49 <chessguy> @pl \x -> (x, f x)
07:34:49 <lambdabot> ap (,) f
07:34:49 <puusorsa> mauke, yes.
07:35:06 <idnar> :t ap
07:35:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:35:21 <birkenfeld> @pl \(x, y) -> (x, f y)
07:35:21 <lambdabot> second f
07:35:30 <birkenfeld> @pl \x y -> (x, f y)
07:35:30 <lambdabot> (. f) . (,)
07:35:36 <chessguy> @type second ?f
07:35:38 <lambdabot> forall (a :: * -> * -> *) b c d. (?f::a b c, Arrow a) => a (d, b) (d, c)
07:35:54 <birkenfeld> arrows ftw...
07:36:07 <idnar> :t uncurry . second f
07:36:09 <lambdabot> Not in scope: `f'
07:36:15 <idnar> :t uncurry . second ?f
07:36:17 <lambdabot>     Couldn't match expected type `a -> b -> c'
07:36:17 <lambdabot>            against inferred type `(d, c1)'
07:36:29 <oerjan> :t uncurry (second ?f)
07:36:31 <lambdabot>     Couldn't match expected type `b -> c'
07:36:31 <lambdabot>            against inferred type `(d, c1)'
07:36:38 <oerjan> :t curry (second ?f)
07:36:40 <lambdabot> forall b c a. (?f::b -> c) => a -> b -> (a, c)
07:37:05 <idnar> oh duh
07:37:40 <chessguy> @pl \m -> e d (f b m)
07:37:40 <lambdabot> e d . f b
07:39:25 <ac> when you create an empty Data.Map, how does Haskell know its type when you do inserts later?
07:39:32 <quicksilver> type inference
07:39:42 <quicksilver> remember compiling happens all-at-once, and before running
07:39:57 <chessguy> @pl \b m -> (e d . f b) m
07:39:58 <lambdabot> (e d .) . f
07:39:58 <quicksilver> presumably some later reference to that variable will make it clear what type you're expecting
07:40:05 <ac> remarkable
07:40:18 <quicksilver> yes, I must admit I always like that bit
07:40:18 <axm> yeah, and i am still trying to get around that :/
07:40:21 <quicksilver> just using 'empty'
07:40:23 <quicksilver> and it works
07:40:48 <axm> quicksilver, i had another look on printf and can now phrase better why i think it cannot help me
07:41:31 <axm> i could _define and implement_ a function with that technique, but i cannot use that as type for an unknown function
07:41:35 <chessguy> @quote printf
07:41:35 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
07:41:37 <axm> at least i am too stupid
07:42:30 <quicksilver> axm: "unknown function" ?
07:42:33 <axm> at this point i think > eval ("MyFunctionType("++fn++")" ... would not work
07:42:49 <axm> cause type and implementation are mixed up
07:45:20 <sjanssen> axm: what problem are you trying to solve?
07:45:54 <axm> eval a string to a function that i do not know the parameter count of
07:46:05 <axm> i could do everything that i want to do within the eval
07:46:22 <sjanssen> using hs-plugins, yeah?
07:46:40 <axm> but that does not satisfy me, so i am looking for a way to evaluate once
07:46:41 <axm> yes
07:47:01 <sjanssen> IIRC, hs-plugins has a function String -> Dynamic
07:47:06 <axm> ..and then be able to do sth. with it more than one time without having to re-eval
07:47:24 <axm> Data.Dynamic?
07:47:28 <sjanssen> yeah
07:47:35 <sjanssen> I might be misremembering
07:47:54 <axm> the doc says it takes only monomorphic, so i did not try
07:48:02 <axm> should i?
07:48:30 <axm> either Typeable or monomorphics, if i remember correctly
07:48:51 <quicksilver> yeah, polymorphism itself isn't safe with Dynamic
07:48:58 <quicksilver> but you can wrap things in existentials
07:49:04 <quicksilver> and existentials work fine in Dynamic
07:49:04 <axm> so the idea was to make my own data type (MyFunctionType) and make it a Typeable
07:49:04 <chessguy> > sortBy (comparing snd) [(7,0),(8,1)]
07:49:11 <quicksilver> it does depend what you're trying to do
07:49:13 <lambdabot>  [(7,0),(8,1)]
07:49:25 <chessguy> how do i sort those in the opposite direction
07:49:29 <axm> existentials are foralls, for dummies, right?
07:49:37 <axm> or is there more to it?
07:49:48 <quicksilver> no, they're the opposite of forall
07:49:49 <quicksilver> in a sense
07:49:51 <quicksilver> the dual of it
07:49:57 <chessguy> :t comparing
07:49:59 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
07:50:01 <axm> i meant the keyword
07:50:10 <sjanssen> axm: you can wrap polymorphic functions in a Dynamic
07:50:17 <axm> oh
07:50:21 <sjanssen> axm: see the example http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-4.html#node_sec_7
07:50:22 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules, http://tinyurl.com/2xwycf
07:50:26 <quicksilver> > sortBy (comparing ((*-1).snd)) [(7,0),(8,1)]
07:50:26 <lambdabot>   Not in scope: `*-'
07:50:34 <quicksilver> > sortBy (comparing ((*(-1)).snd)) [(7,0),(8,1)]
07:50:35 <lambdabot>  [(8,1),(7,0)]
07:50:39 <quicksilver> chessguy: like that?
07:50:45 <chessguy> heh
07:50:54 <chessguy> that's...cute
07:51:56 <oerjan> newtype Rev a = Rev a; instance Ord a => Ord (Rev a) where compare (Rev x) (Rev y) = compare y x
07:52:08 <quicksilver> I'm sort of suprised there isn't an 'opposite :: Ordering -> Ordering'
07:52:31 <oerjan> don't remember if there's anything like that somewhere
07:52:54 <oerjan> hm, add a deriving (Eq)
07:53:47 <oerjan> oh wait...
07:54:11 <chessguy> :hoogle Ordering -> Ordering
07:54:16 <oerjan> > map (compare EQ) [LT,EQ,GT]
07:54:18 <lambdabot>  [GT,EQ,LT]
07:54:18 <sjanssen> oerjan: the type is similar to Data.Monoid.Dual
07:54:31 <axm> sjanssen, yes, in that example there is a function with 2 parameters, but i want to be able to have a function with a paramter count not known at runtime
07:54:33 <oerjan> voila
07:55:10 <chessguy> :t compare EQ
07:55:11 <lambdabot> Ordering -> Ordering
07:55:17 <sjanssen> axm: perhaps data Wrap = forall a. FunctionType a => Wrap a
07:55:32 <sjanssen> where FunctionType is your typeclass similar to PrintfType
07:55:37 <axm> yip, this is where the printf example comes in
07:55:40 <oerjan> > sortBy ((compare EQ.).comparing snd) [(7,0),(8,1)]
07:55:41 <lambdabot>  [(8,1),(7,0)]
07:55:53 <quicksilver> oerjan: clever
07:55:59 <sjanssen> axm: I have no idea if this will work in practice, I'm just tossing out ideas
07:56:24 <sjanssen> umm, how about 'flip compare'? :P
07:56:38 <axm> thanks for that :), i tried to follow that path, but i realized, i cannot wrap unknown functions (eval) that way
07:56:43 <axm> at least _i_ cannot
07:56:51 <quicksilver> flip compare `on` snd ?
07:57:00 <quicksilver> but without 'on' that's clumsy to write
07:57:28 <oerjan> :t flip (comparing snd)
07:57:29 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
07:57:39 <axm> cause printf for example takes an arbitrary number of arguments but processes one at a time without ever actually representing a function like that
07:57:56 <quicksilver> axm: It might be easier to suggest solutions with a better idea of what you're *actually* trying to do
07:58:02 <oerjan> > sortBy (flip (comparing snd)) [(7,0),(8,1)]
07:58:03 <lambdabot>  [(8,1),(7,0)]
07:58:08 <ac> It's fairly easy to create a map from a list of (key,value) tupples using foldr, but is there a function from Data.Map to do the same?
07:58:12 <quicksilver> axm: unless, of course, the answer is just that you're playing with the boundaries of the possible for the fun of it
07:58:24 <quicksilver> ac: fromList
07:58:48 <quicksilver> axm: for example, although hs-plugins is uber-cool, most of the time eval is a sledgehammer to crack a nut...
07:58:50 <axm> both actually. (i could use what i have, but as this point i would have to say, haskell is a poor language for doing the job)
07:59:32 <axm> i am working on a dynamic code evaluator, that takes code and performs tests on it
07:59:33 <sjanssen> axm: what is the job?
08:00:01 <sjanssen> axm: tests ala QuickCheck?
08:00:10 <axm> that would usually be the job of an interpreter, but
08:00:28 <axm> quickcheck uses ghci or hugs in the background,
08:00:39 <axm> but i am constrained to use compiled code
08:01:13 <axm> so that would mean implementing "my own" interpreter for it or plugging an existing one into it
08:01:29 <axm> and i am evaluating the first possibility at the moment
08:03:06 <axm> so, an example what i really want would be: let fn = eval "(+5)" ... in fn 4 == 9 'and' fn 5 == 10
08:05:40 <oerjan> :t (+5) -- this is going to be _very_ hard to get all type information through
08:05:48 <lambdabot> forall a. (Num a) => a -> a
08:07:07 <sjanssen> axm: no, quickcheck doesn't use ghci or hugs
08:07:26 <axm> oh, i thought so
08:07:38 <fasta> sjanssen: maybe he means the script?
08:07:38 <sjanssen> all the type introspection is done statically with type classes
08:07:53 <quicksilver> axm: conversely, by using hs-plugins you are, essentially, using ghci :)
08:08:09 <sjanssen> fasta: perhaps
08:09:36 <axm> quicksilver, so a possible solution would be to write another plugins for my use?
08:10:02 <quicksilver> erm, no, I wasn't suggesting that
08:10:08 <quicksilver> I was trying to challenge your assumptions
08:10:21 <quicksilver> as in what the 'difference' is between using ghci and using hs-plugins
08:10:58 <quicksilver> "dynamic code evaluator, that takes code and performs tests on it"
08:11:07 <quicksilver> ^^ takes what sort of code? compiled or source?
08:11:41 <quicksilver> sounds to me like you're confusing the meta-level with the target-level
08:11:58 <quicksilver> perhaps un-necessarily
08:12:05 <hpaste>  kosmikus pasted "type families experiment" at http://hpaste.org/3154
08:12:21 <axm> maybe. sounds to me as it would actually be easy to use ghci from within compiled code
08:12:29 <kosmikus> ^^ gives an error in my ghc; can anybody confirm with a very recent snapshot?
08:13:23 <Beelsebob_> anyone got any idea how to make latex display two items side by side?
08:13:23 <axm> compiled code is what my final goal is, nothing against using an interpreter within, but i think i was blind to that possibility
08:13:33 <fasta> kosmikus: wrong indentation, here
08:13:54 <kosmikus> fasta: huh? there's no indentation at all
08:14:04 <fasta> kosmikus: I can't help that
08:14:18 <axm> Beelsebob_, multienum perhaps?
08:14:19 <fasta> Abcde.hs:3:0: parse error (possibly incorrect indentation)
08:14:59 <fasta> kosmikus: and a compiler bug with fglasgox-exts
08:15:01 <quicksilver> axm: all sorts of ways depending what kind of "item" they are
08:15:21 <fasta> kosmikus: mine is about a 1.5 weeks old.
08:15:25 <quicksilver> axm: such as tabulars, minipages, hfills, and so on
08:15:31 <fasta> kosmikus: maybe that's too old according to your standards?
08:15:32 <kosmikus> fasta: ah yes, I didn't even try without -fglasgow-exts
08:15:32 <quicksilver> axm: erm, sorry
08:15:37 <quicksilver> Beelsebob_: all that was for you :P
08:15:45 <quicksilver> axm: that was for Beelsebob_ . Damn this buggy brain.
08:15:51 <kosmikus> fasta: I have 20070921
08:16:04 <fasta> kosmikus: it should say (like with all the other features): you are using that and that feature, but that's not H98.
08:16:13 <fasta> kosmikus: Mine is 6 days newer
08:16:29 <kosmikus> ok
08:16:29 <fasta> kosmikus: imho, type families are not ready for experimentation.
08:16:43 <fasta> kosmikus: other than on paper :)
08:16:58 <kosmikus> fasta: possibly
08:16:59 * oerjan wonders what they can be ready for if not experimentation...
08:17:26 <Beelsebob_> quicksilver: thanks, minipages was the answer :)
08:17:57 <fasta> oerjan: initially everything is ready for experimentation. Then when you did a trivial experiment and it didn't work it loses that property.
08:18:19 <fasta> oerjan: they are ready to waste time with, maybe.
08:19:41 <axm> quicksilver, and even if i can user an interpreter, it would boil down to the same problem, that i cannot use some dynamic code multiple times without having to "eval" it more than once
08:20:18 <quicksilver> axm: I'm sorry, I still don't understand
08:20:20 <kosmikus> fasta: well, I still want to understand them; if the implementation doesn't match my intuitions, that's an observation I can learn from ;)
08:20:21 <axm> and under these constraints, i think at the moment this is not possible with haskells strict type system
08:20:35 <quicksilver> axm: is it haskell you're trying to evaluate?
08:20:38 <quicksilver> axm: or some other language?
08:20:50 <axm> haskell
08:20:52 <quicksilver> (why must the meta-level be the same as the target level)
08:21:01 <fasta> kosmikus: you can only learn from the implementation when it's correct in the cases that you mispredict.
08:21:12 <quicksilver> ok, well if you're trying to evaluate haskell, why are you trying to evaluate variable argument functions?
08:21:16 <quicksilver> since haskell doesn't have those?
08:21:22 <fasta> kosmikus: which is in this case about the empty set with -fglasgow-exts.
08:21:24 <quicksilver> why not stick to just evaluating haskell which actually exists?
08:21:25 <axm> difference between meta- and target being?
08:21:33 * mux realizes he's more and more using ghc -e in command lines
08:21:37 <quicksilver> meta : the language you are writing your evaluator in
08:21:46 <quicksilver> target : the language you are evaluating / testing
08:22:51 <axm> hm, i am not sure if this is a communication problem. i will paste sth
08:23:09 <quicksilver> I think it is a communication problem, yes
08:23:17 <quicksilver> I still don't really understand what you're trying to do :)
08:23:24 <kosmikus> fasta: I disagree. The implementation gives hints on what might be hard to get right, or even parts of the theory that are problematic.
08:23:27 <quicksilver> it's entirely possible that I'm too stupid :P
08:24:06 <axm> i have rather the feeling i am ;)
08:24:37 <fasta> kosmikus: I think that unless you implement the whole machinery for yourself that's a waste of time.
08:25:30 <kosmikus> fasta: you're so negative ;)
08:25:35 <fasta> (and theory is always "problematic", since not all the cases are listed in articles(because there is only limited space)
08:25:50 <fasta> kosmikus: I speak from experience in other areas.
08:26:25 <kosmikus> exactly my point. but it should be possible to reconstruct the important bits from the papers. that's what I'm trying to do. if this isn't possible, we need more papers ;)
08:26:43 <kosmikus> well, or I need a chat with ChilliX or one of the others ...
08:27:15 <fasta> kosmikus: right "reconstruct", everyone keeps busy with reconstructing. It would be more efficient for everyone if everyone would only publish something worth publishing.
08:27:47 <fasta> Instead one has to wade through all kinds of crap.
08:28:23 <fasta> Then there's also the availability of articles problem.
08:28:50 <fasta> (which isn't a major point if you are into type theory, though)
08:29:05 <kosmikus> no. articles are available.
08:29:38 <kosmikus> I partially agree with the other point. but it's made somewhat difficult by the historically grown conference publishing system in CS which doesn't give you a lot of space.
08:29:45 <kosmikus> I have some hopes for mechanical proofs in the future though.
08:29:46 <fasta> kosmikus: for my problems articles aren't always available
08:30:43 <fasta> Anyway, back to work
08:31:01 <kosmikus> fasta: any you're working on?
08:31:30 <pizza_> i'm just learning haskell; does haskell have a numerical infinity?
08:31:41 <fasta> kosmikus: I can come up with a title in 5 minutes or so, but you don't have access to it neither.
08:31:50 <fasta> kosmikus: unless you can access more than I.
08:32:00 <fasta> either*
08:32:38 <kosmikus> fasta: I just wanted to know what area you're working in.
08:33:40 <axm> quicksilver, http://hpaste.org/3155
08:39:10 <quicksilver> pizza_: yes
08:39:16 <quicksilver> > 1/0 :: Double
08:39:19 <lambdabot>  Infinity
08:39:20 <quicksilver> pizza_: in some cases
08:39:42 <quicksilver> pizza_: it represents the IEEE 'Infinity' value, if you compile it on a system with an IEEE-based C 'double' type.
08:40:15 <quicksilver> pizza_: there is no terminating representative 'Infinity' in the standard integer types though
08:41:25 <Beelsebob_> > 1 `div` 0 :: Int
08:41:27 <lambdabot>  Exception: divide by zero
08:41:31 <Beelsebob_> fair enough
08:41:41 <Beelsebob_> makes a limited amount of sense
08:41:59 <quicksilver> it's a question of maintaining a fairly efficient mapping to hardware capabilities, I believe
08:42:13 <Beelsebob_> indeed
08:42:15 <quicksilver> IEEE FPU hardware has a standard infinite rep, so there is no harm giving access to that
08:42:28 <quicksilver> faking out an integer one would slow everything down
08:42:57 <Beelsebob_> damn it, all integers should be represented as church numerals :P
08:43:02 <quicksilver> axm: you could try tupling up all the parameters
08:43:12 <quicksilver> axm: then it would work to some extent
08:43:52 <axm> i figured it would not make much difference if i take lists of wraps or tuples
08:44:36 <axm> at some point i would have to map the function that i get (that i cannot assume is not  curried) to it
08:45:44 <axm> or do you mean to transform the "evaled" function within the eval to a tupled one?
08:46:02 <oerjan> > do [1]::[Int]++[2]
08:46:03 <lambdabot>   Only unit numeric type pattern is valid
08:46:10 <quicksilver> why can't you assume the function you get is curried
08:46:22 <quicksilver> or, perhaps to ask a better question
08:46:30 <quicksilver> WHERE do you "get" this function from?
08:46:35 <quicksilver> what control do you have over its form?
08:46:47 <axm> a web interface for example?
08:47:27 <axm> no control whatsoever. i can make the restriction that its correct type is given with it
08:47:42 <axm> but i won't get that at compile time
08:47:52 <quicksilver> so you are "given" an arbitrary haskell function?
08:47:54 <quicksilver> in source form?
08:47:58 <axm> yes
08:47:59 <quicksilver> and a list of parameters to try it on?
08:48:13 <quicksilver> and a list of expected results?
08:48:19 <axm> all true
08:48:22 <quicksilver> right
08:48:24 <quicksilver> that sounds OK
08:48:33 <quicksilver> shuld work with tuples
08:48:45 <quicksilver> because the size of the tuple tells you how much you need to 'uncurry' the function :)
08:49:02 <quicksilver> the list of parameters must be a list of tuples
08:49:06 <quicksilver> for what else could it be, I wonder?
08:49:23 <quicksilver> well it could be a tuple of lists, but that's much of a muchness
08:58:06 <Mr_Awesome> @pl \f x y -> f x $ g y
08:58:06 <lambdabot> flip flip g . ((.) .)
08:58:52 <oerjan> @pl \f x -> f x . g
08:58:52 <lambdabot> flip flip g . ((.) .)
08:58:53 <axm> yes, as far as i can see, this will work. thanks quicksilver
08:59:37 <oerjan> @pl \f -> (. g) . f
08:59:37 <lambdabot> ((. g) .)
08:59:44 <quicksilver> axm: pleased to be of assistance
09:01:03 <moondraken> hi
09:01:13 <moondraken> is coding an OS easy or something?
09:01:22 <moondraken> HaskellOS
09:01:31 <moondraken> a lone guy who has 500 lines of code
09:01:33 <oerjan> @check \f x y -> ((.g).) f (x::Bool) (y::Bool) == (f x $ g y :: Bool)
09:01:34 <lambdabot>   Not in scope: `g'
09:01:49 <oerjan> @check \g f x y -> ((.g).) f (x::Bool) (y::Bool) == (f x $ g y :: Bool)
09:01:50 <lambdabot>  Add a type signature
09:02:00 <puusorsa> depends what you want the os to do
09:02:03 <oerjan> @check \g f x y -> ((.g).) f (x::Bool) (y::Bool) == (f x $ (g y :: Bool) :: Bool)
09:02:04 <lambdabot>  OK, passed 500 tests.
09:02:43 <puusorsa> doing an os that supports text io on console and nothing else probably isn't too hard
09:06:35 <dmwit> Be careful to separate the OS from the programs that run on the OS.
09:06:41 <Mr_Awesome> oerjan: nice
09:06:57 <Mr_Awesome> i wish i could come up with that
09:07:03 <dmwit> We had to make an operating system for class, and it wasn't too bad; we built the entire thing in 10 weeks, basically.
09:07:18 <moondraken> oh really??!!
09:07:23 <moondraken> that's it??!!
09:07:26 <moondraken> wow awsome
09:07:43 <moondraken> so I can code my own HURD kernel just fine?
09:07:45 <Mr_Awesome> @pl \f g h -> h . g . f
09:07:45 <lambdabot> (flip (.) .) . flip (.)
09:07:52 <oerjan> Mr_Awesome: the basic trick is to start by removing the innermost variable
09:08:03 <dmwit> Uh... you don't have to make a HURD kernel, just download it.
09:08:10 <oerjan> @pl \h -> h . g . f
09:08:10 <lambdabot> (. (g . f))
09:08:31 <edwardk> dmwit: though you'd probably get farther than they have by starting from scratch ;)
09:08:37 <puusorsa> there are some tutorials for doing an os. if you use lilo/grub for loading, it really isn't that hard
09:09:00 <mrd> unix is easy to write.  that's the point .. it's easy to implement because it doesn't do anything for the user.
09:09:19 <oerjan> hm, that one doesn't seem much more promising
09:09:28 <Mr_Awesome> maybe if i reverse it
09:09:38 <Mr_Awesome> @pl \f g h -> f . g . h
09:09:38 <lambdabot> (. (.)) . (.) . (.)
09:09:55 <oerjan> @pl \h -> f.g.h
09:09:55 <lambdabot> ((f . g) .)
09:10:17 <Mr_Awesome> @pl \f g -> f . (g .)
09:10:17 <lambdabot> (. (.)) . (.)
09:10:21 <oerjan> @pl \g -> (.) (f.g)
09:10:21 <lambdabot> (.) . (f .)
09:11:11 <oerjan> @pl \f -> (.) . (f .)
09:11:12 <lambdabot> ((.) .) . (.)
09:11:28 <sioraiocht> okay
09:11:33 <sioraiocht> screw complexity theory
09:11:34 <sioraiocht> like forever
09:11:37 <sioraiocht> err
09:11:41 <sioraiocht> category theory, even
09:11:49 <Mr_Awesome> wait, is ((f . g) .) the same as f . (g .)
09:11:54 * sioraiocht just had the WORST category theory lecturer EVER
09:12:09 <Mr_Awesome> (.) is associative, right?
09:12:53 <oerjan> not as a section
09:13:12 <pastorn> sioraiocht: why?
09:13:21 <MyCatSchemes> Hrmn. How long did xmonad take to write, anyhoo?
09:13:28 <sioraiocht> pastorn: there was a powerpoint presentation of the formal definitions of everything
09:13:36 <mrd> MyCatSchemes: it's still under active development, so what do you mean?
09:13:37 <sioraiocht> the lecturer proceeded to read the definitions from the slide
09:13:41 <sioraiocht> and then write them on teh board
09:13:53 <mrd> powerpoint is a plague
09:13:54 <oerjan> but ((f . g) .) = (.) (f . g)
09:13:57 <edwardk> sioraiocht: ouch
09:14:00 <MyCatSchemes> mrd: from nothing to 0.1-stable, then from 0.1-stable to 0.3-stable, really.
09:14:05 <pastorn> sioraiocht: where? when?
09:14:10 <mrd> MyCatSchemes: darcs changes =)
09:14:13 <sioraiocht> pastorn: Oxford, about an hour ago
09:14:16 * pastorn needs more categories in his life
09:14:29 <mrd> powerpoint is in the category of things which are horrible
09:14:34 <MyCatSchemes> pastorn: natural numbers under (<=)
09:14:43 <sioraiocht> mrd: what are arrows in that category?
09:14:47 <edwardk> powerpoint doesn't fit well with mathematics education. it works reasonably well for computer science and other disciplines but i've seen very few good mathematics presentations in powerpoint.
09:15:02 <MyCatSchemes> paolino: powerpoint slides under (\x y -> x `morehorriblethan` y)
09:15:03 <mrd> sioraiocht: painful
09:15:03 <sioraiocht> edwardk: i would argue it doesn't work well for anything
09:15:04 <pastorn> MyCatSchemes: (<=) ???
09:15:19 <MyCatSchemes> pastorn: "less than or equals"
09:15:30 <pastorn> oh, my bad
09:15:39 <mrd> it doesn't work for computer science, except maybe at a basic level.  but powerpoint lecturers will always bore people to death.
09:15:58 <pastorn> @paste
09:15:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:15:59 <mrd> at the basic level, you're already bored to death, so ppt doesn't make it worse
09:15:59 <edwardk> sioraiocht: depends on what you are p;resenting. if you are talking to statistics or charts its a good medium to present information to talk to, but its bad if you use it in classic 'talking point' style.
09:16:02 <moondraken> dmwit: I meant if I wanna port HURD into another code other than C
09:16:19 <sjanssen> MyCatSchemes: the first commit was Mar  6, 2007.  I worked on it for a week or two before that
09:16:25 <sioraiocht> edwardk: right, if you're presenting information using visualisation that's one thing
09:16:57 <MyCatSchemes> sjanssen: kewl, thanks. Roughly how much of your time were you spending on it during that period, please?
09:17:06 <MyCatSchemes> sjanssen: (also, it's fucking awesome. Thanks for writing it. <3 xmonad)
09:17:06 <edwardk> sioraiocht: thats what i've always used powerpoint for. if i just have to stand up and talk and it adds no value i see no point in booting up the projector.
09:17:20 <sioraiocht> edwardk: that's rare in powerpoint use, though, hehe
09:17:32 <sjanssen> MyCatSchemes: hard to say, it really fluctuates.  There've been several other developers too
09:18:00 <mrd> writing on a board w/o ppt is much better if you involve the students in the process
09:18:09 <mrd> keeps people awake too
09:18:32 <MyCatSchemes> Powerpoint is still handy for showing graphs.
09:18:47 <MyCatSchemes> Though, if it comes to that, then, uh, get a life and learn to use GNUplot instead, fools?
09:19:20 <MyCatSchemes> sjanssen: certainly not a full-time thing though, right? Like, evenings and weekends?
09:19:51 <sjanssen> MyCatSchemes: not full time
09:24:22 <moondraken> is this doable to port HURD into haskell?
09:24:50 <moondraken> I mean the guy doing HaskellOS has a microkernel or something
09:25:30 <edwardk> mrd: the problem with a lot of people is when they write on the board to involve the students they spend half of their time talking INTO the board and blocking the view of what they wrote, so i'd say it takes skill to be able to present information in either form.
09:26:10 <quicksilver> it takes skill to present information in *any* form
09:26:16 <edwardk> yeah
09:26:27 <quicksilver> certainly powerpoint leads some would-be presenters down a bad path
09:26:35 <quicksilver> but, unless I misremember, SPJ uses powerpoint
09:26:41 <quicksilver> and he's an accomplished presenter
09:26:50 <quicksilver> I do regard him as something of an exception, in that regard :)
09:27:08 <quicksilver> emperically, most of the good presenters I have experienced have not been using powerpoint
09:27:18 <allbery_b> proves little, imo
09:27:28 <sjanssen> quicksilver: yes, SPJ uses cheesy powerpoints with MS Comic Sans ;)
09:27:33 <moondraken> if powerpoint sux why don't you use latex for presentations?
09:27:37 <pejo> I think Wadler uses powerpoint too.
09:27:48 <quicksilver> moondraken: I do :)
09:27:50 <byorgey> also, SPJ works for Microsoft =)
09:27:52 <quicksilver> or, at least, I have
09:28:08 <allbery_b> 90%+ of presentations are in powerpoint.  of *course* most crappy presentations are in powerpoint
09:28:12 * cpoucet uses open office impress and ALWAYS exports to pdf
09:28:19 <quicksilver> allbery_b: that's not what I said, is it?
09:28:31 <quicksilver> allbery_b: I said, most the good ones I have experience have not been using powerpoint
09:28:59 <allbery_b> yeh
09:29:05 <quicksilver> sjanssen: actually I rather like blackboard-fonts for mathsy presentation
09:29:13 <quicksilver> sjanssen: and comic sans is something like a blackboard font
09:29:14 * allbery_b did have something in there but is being fuzzyheaded again
09:30:11 <allbery_b> something about most presenters using non-PPT have actually thought about how they're presenting, and are therefore more likely to be good presenters anyway
09:30:59 <osfameron> exporting to pdf is really really useful for when your laptop doesn't work or doesn't connec to the projector
09:31:07 <osfameron> (which is a common theme when you're on Linux...)
09:31:44 <quicksilver> allbery_b: yes, that's true
09:31:56 <quicksilver> I've given presentations using hand-written transparencies more than once
09:32:02 <quicksilver> even multi-layered ones for 'animation'
09:32:13 <quicksilver> whatever gets the content across most comfortably
09:32:46 <pejo> quicksilver, it's quite hard to get them to 'align' though.
09:32:49 <moondraken> for chris sake stop whining about powerpoint if you know haskell you are supposed to know better alreayd
09:32:55 <moondraken> use quicktime then
09:33:21 <quicksilver> pejo: it's all in the wrist
09:33:44 <pejo> moondraken, the reason we use Haskell is because it's a good tool for the job. Wouldn't it be nice if presentation software was the right tool for the job too?
09:34:20 <quicksilver> use Keynote
09:34:23 <osfameron> allegedly keynote is less hateful than PP/Impress
09:34:24 <quicksilver> it's the wrong tool, too
09:34:30 <quicksilver> but at least it's GORGEOUS and wrong
09:34:33 <quicksilver> instead of ugly and wrong ;)
09:34:50 <mrd> presentations at a conference are different than lectures in a class
09:34:57 <quicksilver> with luck the eyecandy will distract you from your own failings
09:34:58 <mrd> they're much shorter, for one
09:35:13 <pejo> Yeah, whatever I do in Keynote it looks great. Odd thing considering my lack of artistic talent.
09:35:23 <quicksilver> I certainly never used powerpoint to teach
09:35:37 <quicksilver> but then I tended to teach practical classes
09:35:45 <quicksilver> often I did worked examples in emacs on a projector
09:36:55 <moondraken> use OpenOffice?
09:37:06 <mornfall> openoffice... ick.
09:38:01 <quicksilver> still I admit to having an affection for chalk
09:38:03 <birkenfeld> anyone mentioned beamer?
09:38:15 * mrd uses beamer sometimes
09:38:31 * mornfall uses beamer, too
09:38:36 <mornfall> haven't seen/heard about keynote
09:38:44 <mornfall> and openoffice, i avoid like a plague
09:38:52 <mrd> when i'm forced to make some kind of slides
09:38:59 <Neopoznanij> =)
09:39:08 <birkenfeld> mornfall: ms office would be pandemia, then?
09:39:20 <mornfall> birkenfeld: dunno
09:39:33 <mornfall> i haven't seen it for years
09:39:38 <Neopoznanij> which irc server you can talk?
09:39:39 <Neopoznanij> =)
09:39:44 <moondraken> Koffice?
09:39:47 <edwardk> i have been known to take the prebaked slides for whatever textbook i'm teaching out of and skim through them in class with the students and go from there in another direction, simply to provide a straw man to argue with if i disagree with the textbook or to have another source of information in intro courses.
09:39:52 <Neopoznanij> =)
09:40:38 <mornfall> mm, baked slides.
09:41:14 <quicksilver> nice with jam
09:41:24 <birkenfeld> and peanut butter?
09:41:41 <edwardk> the filmy aftertaste always gets me though
09:41:53 <mornfall> chilli and garlic, you barbarians
09:41:56 <mornfall> and tomato sauce
09:42:27 * osfameron tried to love latex-beamer but failed because of it's useless error reporting.  Debugging a presentation is just too much hate.
09:43:01 <pastorn> @src Data.Char.isControl
09:43:01 <lambdabot> Source not found. Do you think like you type?
09:43:05 <edwardk> note to self avoid standing too close to mornfall after he gives a presentation.
09:43:08 <pastorn> @src isControl
09:43:08 <lambdabot> Source not found. You type like i drive.
09:43:23 <Heffalump> @seen mnislaih
09:43:23 <lambdabot> I saw mnislaih leaving #haskell and #ghc 1d 5h 20m 22s ago, and .
09:43:42 <oerjan> @source Data.Char
09:43:42 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
10:08:13 <cpoucet> ivant: hello
10:08:17 <cpoucet> ivant: how's the ropes going
10:09:02 <ivant> cpoucet, just got home this afternoon, still unpacking my luggage
10:09:02 <lambdabot> ivant: You have 1 new message. '/msg lambdabot @messages' to read it.
10:09:50 <ivant> cpoucet, we finished the binary-tree version of ropes (i.e., skeleton impl: concat and balancing)
10:09:50 <cpoucet> ivant: Ah :)
10:09:57 <cpoucet> Splendid
10:09:59 <cpoucet> what's missing?
10:10:11 <cpoucet> I presume accessor methods?
10:10:16 <ivant> cpoucet, lots of simple stuff, like, accessors
10:10:21 * cpoucet nods
10:10:26 <cpoucet> How do you handle substring?
10:10:36 <ivant> cpoucet, we don't yet :-)
10:10:38 <cpoucet> Do you keep a set of indices into buffers?
10:10:42 <cpoucet> I can take a look :)
10:10:46 <ivant> cpoucet, we were concentrated on writing the balancing
10:10:54 <cpoucet> I'll ask Igloo for access
10:10:58 <ivant> it is in darcs @ community.haskell.org
10:11:03 <ivant> sure
10:11:19 <ivant> and we even tried running hpc on it with quickcheck
10:11:26 <ivant> balancing seems to work just fine
10:11:59 <ivant> cpoucet, now we'd want to implement ropes on finger-trees and start comparing the performance and trade-offs
10:12:09 * cpoucet nods
10:12:13 <ivant> of course, after finishing the basic stuff
10:12:16 <cpoucet> Right
10:13:20 <twanvl> looking at the rope code: do you need Empty at all? Why not use Leaf B.empty?
10:13:33 * kolmodin is back from ICFP/hackathon
10:13:34 <lambdabot> kolmodin: You have 1 new message. '/msg lambdabot @messages' to read it.
10:13:47 <cpoucet> ivant: I disagree with your choice of Leaf
10:13:52 <cpoucet> ivant: It does not allow partial use of a bytestring
10:14:05 <sjanssen> ivant: "partial use"?
10:14:14 <sjanssen> s/ivant/cpoucet
10:14:25 <cpoucet> substring 2 length aRope
10:14:31 <cpoucet> you want to share the first bytestring
10:14:49 <sjanssen> cpoucet: ByteString handles the sharing itself
10:14:49 <cpoucet> or I guess maybe you do that one level up in the nodes..
10:14:55 <cpoucet> oh, that I was not aware of
10:14:57 <sjanssen> @src ByteString
10:14:57 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:14:59 <ivant> privet, kolmodin
10:14:59 <sjanssen> bah
10:15:20 <cpoucet> sjanssen: should've been @ HAC, it was interesting meeting all the IRC people
10:15:31 <sjanssen> data ByteString = PS (ForeignPtr Word8) Int Int {- ptr, offset, length -}
10:15:55 <sjanssen> cpoucet: I would've liked to come.  Freiburg is very far for me though
10:16:39 <cpoucet> sjanssen: where are you at?
10:16:43 <ivant> cpoucet, again, we just tried to do the reasonable things because we were short on time. Deciphering the Ocaml code for balancing was a bit tough (the code is, like, obfuscated :-) )
10:16:54 <cpoucet> ivant: yeah, welcome to o'caml :)
10:17:02 <mrd> the O is for obfuscated
10:17:06 <cpoucet> ivant: it wasn't really obfuscated, O'Caml code is just ugly
10:17:32 <ivant> cpoucet, yep, they did some things which are unnecessary. Our balancing is much much simpler
10:17:42 * cpoucet nods
10:18:32 <sjanssen> cpoucet: I'm in the middle of the USA
10:19:03 <ivant> sjanssen, better luck next year :-)
10:19:20 <ivant> canada is much closer
10:21:11 <sjanssen> ivant: who is hosting it?
10:21:40 <ivant> Victoria (university of Victoria?), Canada. I have no idea, where it is, though
10:22:21 <edwardk> ah nice, i should be able to make it next year then
10:24:16 <edwardk> er. so did they reveal endo's fate? i have been completely out of the loop with regards to icfp happenings this year.
10:24:20 <byorgey> ivant: it's SW Canada, just north of Seattle, Washington, USA
10:25:00 <nominolo> endo had a 97 or something survival rate
10:25:06 <edwardk> nice
10:25:17 <nominolo> team smartass (of course{
10:25:21 <edwardk> hahaha
10:25:23 <edwardk> of course
10:25:43 <ivant> byorgey, thanks
10:26:03 <ivant> well, we saw endo, he is cute :-)
10:26:08 <edwardk> so did they consult a random number generator to see if he lived? =)
10:26:15 <ivant> s/saw endo/saw endo alive
10:27:37 <ivant> edwardk, it just happened that in our universe he was saved :-)
10:27:42 <edwardk> =)
10:29:47 <kosmikus> edwardk: why would we consult a random number generator to see if he lives? it just turned out he lived after the transformation ...
10:30:35 <edwardk> well, it seemed like more of an issue when all the survival rates i was seeing were in the 1-2% range ;)
10:30:53 <kosmikus> :)
10:36:48 <MyCatSchemes> Hrmn. Is there any way to get ghc to produce more compact binaries? I'm in a situation where disk space is at something of a premium.
10:37:25 <dmhouse> My guess would be import fewer modules.
10:37:44 <Heffalump> the new shared library stuff may help, if you have multiple binaries to save space over
10:37:50 <Heffalump> I've not tried it, though.
10:37:53 <dmhouse> Although it's probably worth looking through the GHC flag list.
10:37:56 <dmhouse> ?quote flags
10:37:56 <lambdabot> sorear says: -f flags are so 2006
10:37:59 <dmhouse> ?quote UN
10:38:00 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly responsible for hastening the adoption of functional programming languages
10:38:04 <Heffalump> I think split-objs is another option.
10:38:42 <Philippa> yeah, was about to mention that
10:40:04 <MyCatSchemes> dmhouse: not code that I wrote myself, but jah. ;)
10:40:11 <MyCatSchemes> Philippa, Heffalump: thanks.
10:40:47 <MyCatSchemes> ghc -e is teh sex
10:41:04 <MyCatSchemes> ghc -e "interact (unlines . Data.List.nub . lines)" ^_^
10:41:47 <dmwit> Or, you could just use "uniq"
10:41:57 <dmwit> You know, whichever is shorter and more feature-rich. ;-)
10:42:29 <MyCatSchemes> dmwit: ghc -e was quicker than running man -k to have *found* uniq in the first place.
10:42:32 <MyCatSchemes> >_>
10:42:37 <dmwit> heh
10:42:45 <MyCatSchemes> Plus, the apropos line for it.
10:42:53 <MyCatSchemes> "report or omit repeated lines"
10:43:14 <MyCatSchemes> Like I was going to find *that*. I'd've looked for words like "duplicate" or "unique", even. :/
10:43:59 <dmwit> If you were vgrepping for "unique", the program name "uniq" probably would have caught your eye.
10:44:16 <dmwit> But yes, finding the appropriate program in Unix usually takes a few years... =P
10:44:49 <MyCatSchemes> It's not particularly quicker than finding the algorithm I'm after in Knuth and running it with ghc -e :)
10:45:02 <edwardk> all you have to do is have been using it for years, then the right tool is always near to hand ;)
10:45:24 <monochrom> What is "fastest" depends on what you know.
10:46:02 <monochrom> This is a corollary of: Only the nipple is intuitive, all else is learned.
10:46:06 <MyCatSchemes> Damn. GHC's linker's -dynamic flag is only available on OS X? :(
10:46:31 <MyCatSchemes> monochrom: there's also the (universal) human gesture for "no".
10:46:49 <mauke> there's a universal "no"?
10:46:58 <MyCatSchemes> monochrom: and I'm fairly certain that more than one pair of virgins has, er, puzzled things out for themselves, over the course of human history.
10:47:19 <MyCatSchemes> mauke: yeah, shaking one's head is surprisingly common across cultures.
10:47:37 <edwardk> monochrom: that says something rather disturbing about user interface design. microsoft boob? er.. bob.
10:47:57 <puusorsa> "you seem to have forgotten your password, would you like to change it?"
10:47:58 <Taejo> MyCatSchemes, perhaps they don't find it intuitive... hence the, er, puzzle
10:48:08 <puusorsa> ms knows security
10:48:24 <monochrom> hahahaha
10:49:10 <Philippa> MyCatSchemes: yeah, except sometimes it means "yes"
10:49:16 <MyCatSchemes> puusorsa: heh, that particular qdb quote was from #openbsd, here.
10:49:25 <MyCatSchemes> puusorsa: "Key-in-lock security." :)
10:49:38 <MyCatSchemes> Philippa: where? Damn, I thought it was universal.
10:49:50 <Philippa> MyCatSchemes: I forget that bit, unfortunately. Trivia's like that
10:49:59 <Philippa> where that's the case then nodding is no, IIRC
10:50:09 <MyCatSchemes> Philippa: I trust you well enough to take your word for it anyway. ;)
10:50:33 <mrd> i've heard of this trivia too
10:50:44 <byorgey> supposedly nodding/shaking the head is "reversed" in Albania
10:50:55 <byorgey> although I've never been there =)
10:50:57 <MyCatSchemes> Ah
10:50:59 <MyCatSchemes> Well
10:51:02 <MyCatSchemes> That's Albania.
10:51:07 <MyCatSchemes> And they used to drive Trabants.
10:51:13 <byorgey> hehe
10:51:13 <edwardk> i'll ask my albanian coworker. maybe thats why he is always so negative ;)
10:51:13 <MyCatSchemes> Which just about explains it, really.
10:51:13 <mrd> they also like Bush over there.  they've got everything backwards.
10:51:33 <edwardk> little did i know he was vigorously agreeing
10:52:26 <monochrom> hahahaha
10:58:27 <cpoucet> roconnor: ping
10:58:36 <roconnor> cpoucet: ack
11:10:32 <glen_quagmire> > length (fst ( floatToDigits 2 (0.1 :: Float)))
11:10:34 <lambdabot>  24
11:10:39 <glen_quagmire> why is it 24? not 23?
11:11:08 <cpoucet> > fst . floatToDigits 2 (0.1::Float)
11:11:08 <dmhouse> > fst ( floatToDigits 2 (0.1 :: Float))
11:11:09 <lambdabot>  [1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,1]
11:11:09 <lambdabot>  Couldn't match expected type `a -> (a1, b)'
11:11:15 <cpoucet> doh
11:11:34 <glen_quagmire> single precision has 23 bits for fraction
11:11:37 <axm> i wish there was a possibility to break the type system in certain spots
11:11:57 <sjanssen> axm: unsafeCoerce#
11:11:58 <dmhouse> axm: how long have you been using Haskell?
11:12:04 <axm> 6 weeks?
11:12:05 <sjanssen> experts only though
11:12:12 <zappa> @index sleep
11:12:12 <lambdabot> System.Posix.Unistd, System.Posix
11:12:18 <allbery_b> why are you trying to break the sype system?
11:12:22 <dmhouse> Then it's likely there's a way to do what you want without bypassing the best feature of Haskell.
11:12:22 <allbery_b> type system even
11:12:39 <axm> i was desperate enough to dig through printf, i could use a new challenge ;)
11:12:42 <allbery_b> there are usually better ways, unless you're up to something that requires measurable olegs of type experience
11:13:43 <axm> cause it is not what i want in a spot short answer, slightly longer: http://hpaste.org/3155
11:14:14 <doserj> glen_quagmire: in base 2, you can save one digit, but floatToDigits works in the general case, so it outputs "all" digits
11:15:40 <cpoucet> axm: hard to read code, get some whitespace
11:16:01 <axm> pardon me?
11:16:16 <axm> did you mean the paste?
11:16:25 <cpoucet> yes
11:16:45 <axm> hm, i tend to make compact code, are there style guidelines somewhere?
11:16:48 <cpoucet> What is it you're trying to do
11:17:37 <axm> probably stuff i should not try at this point ;)
11:18:15 <axm> in short, getting haskell code inserted and evaluated at runtime
11:18:37 <dmhouse> My guess is that you want to have a list of 3-tuples, ([args_i], func, [outputs_i]), and test that func args_i = output_i for all i (to use slightly mathsy notation).
11:18:39 <glen_quagmire> > isIEEE (2 ** (-150) :: Float)
11:18:41 <lambdabot>  True
11:18:44 <dmhouse> If so, look at QuickCheck.
11:18:51 <axm> yes
11:19:10 <axm> yes, i forgot that loose end
11:19:10 <glen_quagmire> in single precision, smallest positive number is 2^-149. how come is that number still IEEE?
11:19:26 <dmhouse> axm: so for binary functions the args_i would be pairs?
11:19:49 <axm> it would, but i do not know they are binary
11:20:38 <doserj> > 2 ** (-150) :: Float -- obviously IEEE
11:20:39 <lambdabot>  0.0
11:22:56 <dmhouse> axm: I expect it can be done, but by far the easiest way would be to create testUnary, testBinary, etc. functions. But do post to haskell-cafe if you're interested in how in might be done in a general way.
11:23:13 <axm> i know, but that is ugly
11:24:47 <glen_quagmire> doserj: oh it's 0.0 hah
11:28:25 <monochrom> > isIEEE (undefined :: Float)
11:28:27 <lambdabot>  True
11:28:30 <monochrom> hehehe
11:29:48 <MyCatSchemes> monochrom: when does that ever not come out true?
11:29:55 <MyCatSchemes> When you're using a VAX? :)
11:30:28 <monochrom> @type isIEEE
11:30:30 <lambdabot> forall a. (RealFloat a) => a -> Bool
11:30:42 <monochrom> When you implement your own RealFloat, for example.
11:31:12 <MyCatSchemes> Can you use GMP's arbitrary-length floats in Haskell?
11:31:14 <roconnor> > isIEEE (undefined :: Fixed)
11:31:15 <lambdabot>      `Fixed' is not applied to enough type arguments
11:31:15 <lambdabot>     Expected kind `?', b...
11:31:24 <roconnor> > isIEEE (undefined :: Fixed 32)
11:31:24 <lambdabot>  Parse error
11:31:36 <roconnor> how does Fixed work again?
11:31:38 <monochrom> @info Fixed
11:31:38 <lambdabot> (Fixed)
11:32:22 <MyCatSchemes> > isIEEE (undefined :: Fixed E12)
11:32:22 <lambdabot>        add an instance declaration for (RealFloat (Fixed E12))
11:32:23 <lambdabot>     In the exp...
11:32:41 <roconnor> oh, not a realfloat
11:32:51 <MyCatSchemes> > solution (undefined :: Fixed E12)
11:32:51 <lambdabot>   Not in scope: `solution'
11:32:56 <MyCatSchemes> > resolution (undefined :: Fixed E12)
11:32:56 <lambdabot>        add an instance declaration for (HasResolution (Fixed E12))
11:32:56 <lambdabot>     In the...
11:33:07 <MyCatSchemes> ...huh.
11:33:07 <roconnor> @hoogle resolution
11:33:07 <lambdabot> No matches found
11:33:14 <roconnor> what is that?
11:33:28 <MyCatSchemes> roconnor: Data.Fixed.resolution, according to the haddock docs.
11:34:07 <cpoucet> Igloo: when doing darcs stuff, apparently it doesn't make stuff group-writeable, which is annoying for projects with multi developer
11:34:26 <roconnor> How come lambdabot has Fixed but no exact real arithmetic?
11:35:51 <psnively> cpoucet: Sounds like you need to use the umask option to get/pull.
11:36:20 <cpoucet> psnively: how do you do that?
11:36:25 <cpoucet> and it's not get but push
11:36:43 <doserj> roconnor: because Data.Fixed is in base?
11:37:30 <psnively> cpoucet: At least pull and apply have a --umask option.
11:37:57 <psnively> So if you're pushing to a remote repo, over SSH for example, then you'll want to use the --umask option to apply on the server.
11:38:48 <psnively> That is, consider a repo-level defaults file that says, e.g. apply umask=017 or whatever is appropriate.
11:39:16 <roconnor> doserj: Data.Fixed is in base?!?
11:39:33 <psnively> Also make sure that the remote repo is set up correctly to be shared, i.e. directories are group sticky.
11:40:02 <psnively> chmod -R g+s <directory> is your friend.
11:40:37 <roconnor> why is it in base?!
11:40:51 <doserj> good question :)
11:41:17 <roconnor> I don't really object, but it seems contrary to the policy that I understood.
11:42:14 <roconnor> wow
11:42:18 <roconnor> Data.Foldable is in base
11:42:31 <psnively> All your Data.Foldable are belong to base.
11:43:01 <monochrom> haha
11:43:20 <monochrom> @remember psnively All your Data.Foldable are belong to base.
11:43:20 <lambdabot> Done.
11:43:22 <roconnor> Data.Fixed should totally be called Numeric.Fixed
11:43:30 <roconnor> Numeric is all lonely
11:43:40 <psnively> :-D
11:44:52 <doserj> well, Numeric is also in base, so besides renaming this wouldn't change much
11:46:08 <sjanssen> roconnor: yeah, it seems weird that Data.Fixed is in base
11:46:10 <MyCatSchemes> doserj: yes, but it would make Numeric not so damn lonely any more. Also, it would reduce overcrowding in Data
11:46:25 <doserj> I agree totally :)
11:46:39 <doserj> (and the Enum instance for Data.Fixed should be fixed...)
11:47:15 <EvilTerran> some would say Fixed is fine, and that it's the other fractional types that're broken
11:48:07 <roconnor> we had this discussion before
11:48:29 <Notrix> Hey, I am trying to do some challenges, (for beginners). I wrote this function (5lines) for resolving the first one : http://nopaste.com/p/ajIytJ8zm . But I have the feeling that's it's bad and there is a better solution, has someone any idea ?
11:48:33 <roconnor> I came to the conclusion taht Enum needs to be split into two classes with each of the two possible semantics
11:50:29 <EvilTerran> one of them's related to Integral, i guess
11:52:01 <doserj> one should be adding epsilon, one should be adding 1
11:52:08 <Zao> I've been skimming hackage but haven't been able to find any useful package for this... are there any image loading solutions, or do I have to get my hands dirty with FFI?
11:52:37 <EvilTerran> there's an (incomplete, iirc) GD binding
11:52:45 <EvilTerran> i hear there's an SDL binding, i think that can load images
11:53:39 <byorgey> Notrix: yeah, your solution is basically brute-force, right?
11:53:52 <byorgey> Notrix: I know there's a better way but let me think about it for a minute =)
11:53:54 <EvilTerran> i'm currently working on an Allegro binding, but that'll be several weeks at least before it even sees a "hey guys, look what i made" release
11:55:09 <Notrix> byorgey, I don't know, I'm studying recursion with haskell, so It was the first solution I've found :(
11:55:29 <EvilTerran> at the moment, i'd suggest using an existing program to convert your image to PPM or something; something trivial to read manually
11:55:52 <Zao> EvilTerran: Good idea.
11:56:04 <EvilTerran> oh, i also heard that someone might be working on an imagemagick binding, but it's not released if it even exists
11:56:35 <EvilTerran> they might've just said they wanted one, in an "i want a pony" sort of way
11:56:55 <byorgey> Notrix: don't get me wrong, from a Haskell point of view it looks great =)
11:57:10 <byorgey> Notrix: I just meant that from a mathematical point of view it can be done more efficiently.
11:57:25 <Zao> EvilTerran: import Pony
11:57:45 <sjanssen> cabal-install pony
11:57:45 <EvilTerran> heh
11:58:06 <EvilTerran> import Pony hiding (pony) -- ssh, it's a surprise
11:58:18 <EvilTerran> import qualified Pony -- my pony's got a PhD!
11:58:20 <byorgey> hehe
11:58:25 <Notrix> byorgey: ah cool :) I'm really curious to see your solution in a mathematical point of view :)
12:08:48 <Jaak> hi, I'm trying to get lambdabot (darcs) working, it builds but when given an expression it just says "fd:8: hClose: resource vanished (Broken pipe)"
12:08:58 <Jaak> (ghc 6.6, amd64)
12:10:31 <byorgey> Notrix: I'm still working on it, I'll paste something soon =)
12:16:07 <Notrix> byorgey, okay thank you :)
12:18:33 <Notrix> stupid question, is there a maxList function like in haskell or do I have to define it myself ?
12:18:56 <EvilTerran> @hoogle Ord a => [a] -> a
12:18:57 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
12:18:57 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
12:18:57 <lambdabot> Prelude.head :: [a] -> a
12:19:39 <Notrix> cool thank you :]
12:19:47 <EvilTerran> > maximum "foo bar baz eek ack ook"
12:19:49 <lambdabot>  'z'
12:20:35 <Notrix> > maximum [True, False, False, True]
12:20:37 <lambdabot>  True
12:20:43 <Notrix> how is it possible :o ?
12:20:57 <mikael> Bool and Char both implement Ord
12:21:46 <xerox> > liftM2 (<) [False,True] [False,True]
12:21:48 <lambdabot>  [False,True,False,False]
12:21:51 <twifkak> @src Ord
12:21:51 <lambdabot> class  (Eq a) => Ord a  where
12:21:51 <lambdabot>     compare      :: a -> a -> Ordering
12:21:51 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:21:52 <lambdabot>     max, min         :: a -> a -> a
12:22:47 <Notrix> I've got still a lot to learn :(
12:22:53 <EvilTerran> iirc, `max` on bools is the same as ||, and likewise for `min` and &&
12:23:15 <EvilTerran> and so and = minumum, and or = maximum
12:23:28 <hpaste>  byorgey pasted "finding repunit multiples" at http://hpaste.org/3158
12:24:02 <byorgey> Notrix: unfortunately, that's not a complete solution, but maybe it will give you some interesting ideas. =)
12:24:38 <Notrix> byorgey, thank you very much :) I'll disect this
12:25:15 <Randroid> You know, I always forget that you can say things like liftM2 (<) [True, False] [False, True]. I know that [] is a monad, but it always escapes my mind when it might be useful.
12:25:42 <xerox> ?check \xs -> not (null xs) ==> and xs == minimum xs
12:25:43 <lambdabot>  OK, passed 500 tests.
12:25:56 <xerox> ?check \xs -> not (null xs) ==> or xs == maximum xs
12:25:56 <EvilTerran> the [] monad is very similar to list comprehensions
12:25:57 <lambdabot>  OK, passed 500 tests.
12:26:16 <EvilTerran> xerox, ah, good point, maximum and minimum aren't defined on [].
12:27:21 <Heffalump> I guess liftM2 is one way of doing a cross-product
12:29:35 <EvilTerran> sequence makes a nice n-ary equivalent, too
12:29:56 <Randroid> > liftM2 (+) [1,2,3] [4,5,6]
12:29:58 <lambdabot>  [5,6,7,6,7,8,7,8,9]
12:30:05 <Randroid> That's cool.
12:30:48 * Randroid needs to go change his underwear. It seems that Haskell can blow other things besides your mind.
12:30:59 <Heffalump> thanks for that image. Not.
12:31:01 <byorgey> > liftM2 (,) [1,2,3] [4,5,6]
12:31:03 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
12:31:28 <Randroid> Very cool as well.
12:31:32 <byorgey> > sequence [[1..3], [4..6], [7..9]]
12:31:33 <lambdabot>  [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2,...
12:31:35 <monochrom> haha
12:31:42 <byorgey> yeah, the list monad is useful like that =)
12:32:33 <Notrix> Is it possible to pass to map a 2 arguments function ?
12:32:43 <hpaste>  Yitz annotated "finding repunit multiples" with "`mod` (9 * a)" at http://hpaste.org/3158#a1
12:32:48 <EvilTerran> > zipWith (,) "abc" "def"
12:32:49 <lambdabot>  [('a','d'),('b','e'),('c','f')]
12:33:05 <EvilTerran> > map (uncurry (+)) [(1,2),(3,4),(5,6)]
12:33:06 <lambdabot>  [3,7,11]
12:33:20 <EvilTerran> > map (+) [1..10]
12:33:21 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
12:33:26 <EvilTerran> what do you need? ;)
12:33:41 <doserj> There are no 2 argument functions in haskell...
12:33:57 <lament> what a stupid and arbitrary limitation!
12:33:59 <EvilTerran> ...only functions which return functions and functions that expect tuples
12:34:09 * lament runs away
12:34:10 <yitz> Notrix, byorgey: The solution on hpaste doesn't work for numbers divisible by 3. I fixed it - you need to use `mod` (9*a) instead of `mod` a (think about it...)
12:34:43 <mikael> lament: 1 is one of the least arbitrary numbers
12:34:53 <Notrix> well, I may expressed it badly, I've defined a function cycle :: Int -> Int -> Int and I want to pass "to do" map (cycle x 1) [a..b] where x loop trought [a..b]
12:34:57 <lament> mikael: the other one is 69105
12:35:15 <byorgey> yitz: ah, yes, of course. thanks! I knew there was a simple way to fix it but I wasn't coming up with it, so I figured if I pasted it someone else would figure it out =)
12:35:22 * lament quickly creates a programming languages where all functions take exactly 69105 arguments
12:35:32 <EvilTerran> ah. map (`cycle` 1), map (flip cycle 1), map (\x -> cycle x 1)...
12:35:33 <lament> *language
12:36:07 <ddarius> lament: Base it on linear logic, and I'll be impressed.
12:36:18 <EvilTerran> Notrix, do you see?
12:36:20 <Notrix> yitz, I have to read all this, thank you for the interest :)
12:36:30 <mauke> map ($ 1) . map cycle $ [a .. b]
12:36:38 <Notrix> EvilTerran, I've never heard a bout flip and \x stuff but the infix form that's great idea :)
12:36:44 <EvilTerran> @src flip
12:36:44 <lambdabot> flip f x y = f y x
12:36:46 <EvilTerran> easy!
12:37:28 <Notrix> map (`cycle` 1) <- that's the easier one, isn't it ?
12:37:30 <EvilTerran> > map (x -> if even x then x `div` 2 else 3 * x + 1) [1..]
12:37:31 <lambdabot>  Parse error
12:37:37 <EvilTerran> > map (\x -> if even x then x `div` 2 else 3 * x + 1) [1..]
12:37:39 <lambdabot>  [4,1,10,2,16,3,22,4,28,5,34,6,40,7,46,8,52,9,58,10,64,11,70,12,76,13,82,14,8...
12:37:57 <EvilTerran> (\x y z -> ...) is just the same as (let f x y z = ... in f)
12:38:05 <Notrix> heyyyy
12:38:08 <EvilTerran> \ is pronounced "lambda"
12:38:11 <Notrix> that's exactly what I'm doing
12:38:14 <Notrix> the 3n +1 problem
12:38:40 <EvilTerran> hehe. i figured it was a nice example of a single-parameter function over the naturals :D
12:38:57 <Notrix> yeah it's nice :o
12:39:27 <Notrix> are you a teacher / phd / student at oxford ?
12:40:10 <doserj> > take 100 $ iterate (\x -> if even x then x `div` 2 else 3 * x + 1) 19
12:40:11 <lambdabot>  [19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,4,2,1,4,2,1,4,2,1...
12:40:21 <EvilTerran> student. second year CS undergrad
12:40:36 <Notrix> oh cool
12:40:41 <Notrix> I'm a fresher at imperial
12:40:44 <Arnar> @type iterate
12:40:46 <lambdabot> forall a. (a -> a) -> a -> [a]
12:45:38 <Olathe> @pl \a -> takeWhile (> a) (iterate f)
12:45:38 <lambdabot> flip takeWhile (iterate f) . flip (>)
12:45:47 <Notrix> EvilTerran, do you have any pdf course for haskell, I mean your oxford slides ?
12:45:50 <Olathe> @pl \a -> takeWhile (> a) (iterate f a)
12:45:50 <lambdabot> ap (takeWhile . flip (>)) (iterate f)
12:46:33 <Olathe> > ap (takeWhile . flip (>)) (iterate (\x -> if even x then x `div` 2 else 3 * x + 1)) 19
12:46:35 <lambdabot>  []
12:46:38 <Olathe> :(
12:47:06 <Olathe> > (ap (takeWhile . flip (>)) (iterate (\x -> if even x then x `div` 2 else 3 * x + 1))) 19
12:47:08 <lambdabot>  []
12:47:31 <Olathe> @pl \a -> takeWhile (> a) (iterate (\x -> if even x then x `div` 2 else 3 * x + 1) a)
12:47:31 <lambdabot> ap (takeWhile . flip (>)) (iterate (ap (liftM2 if' even (`div` 2)) ((1 +) . (3 *))))
12:47:44 <Olathe> > ap (takeWhile . flip (>)) (iterate (ap (liftM2 if' even (`div` 2)) ((1 +) . (3 *)))) 19
12:47:53 <lambdabot>   Not in scope: `if''
12:47:57 <doserj> Olathe: 19 < 19 is false
12:48:06 <Olathe> Oh :)
12:48:19 <Olathe> > (ap (takeWhile . flip (>=)) (iterate (\x -> if even x then x `div` 2 else 3 * x + 1))) 19
12:48:20 <lambdabot>  [19,58,29,88,44,22]
12:48:51 <doserj> but don't you want just takeWhile (>1) ?
12:49:15 <Olathe> If all of them go to less than themselves, inductively, it works.
12:49:27 <doserj> true
12:50:37 <Arnar> hey guys..
12:50:43 <Olathe> Hello.
12:50:49 <Arnar> do we have sth. like \x -> [x] ?
12:50:53 <sjanssen> return
12:50:57 <sjanssen> > return 1 :: [Int]
12:50:58 <mrd> :t (:[])
12:50:59 <lambdabot>  [1]
12:51:01 <lambdabot> forall a. a -> [a]
12:51:11 <mrd> it's the chomping function
12:51:15 <EvilTerran> Notrix, i'm afraid i don't think we're meant to distribute them. i could, but it'd be a bit naughty
12:51:17 <byorgey> the monkey operator!
12:51:22 <Arnar> sjanssen: ah, thanks.. I keep forgetting list is a monad
12:51:22 <byorgey> (:[])
12:51:32 <mrd> :t singleton
12:51:34 <lambdabot> Not in scope: `singleton'
12:51:38 <EvilTerran> Notrix, also, some teacher-y people from the comlab come on here, so i'd better not ;)
12:52:01 <Heffalump> dcoutts may well be still on a train :-)
12:52:04 <allbery_b> @quote eat.a.
12:52:04 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
12:52:22 <Olathe> Heheh
12:52:26 <allbery_b> hm, I thought all that state was gone...
12:53:36 <bringert> dcoutts_: cabal-install now requires zlib>=0.4, but that is not on hackage
12:58:24 <kolmodin> ?tell dons the binary homepage is a tad out of date..
12:58:25 <lambdabot> Consider it noted.
13:03:59 <Notrix> EvilTerran, pfff I don't see where is the problem. If a lecturer gives a lecture it's because he wants to share his knowledgde. Imperial's courses and slides are accessible to everybody
13:04:30 <BSP_> hi, i'm trying to build GHC stage1 using version from darcs following the guide on trac.. but when i do "make stage1" GHC complains "unknown package: unix".. does anyone know how to fix this?
13:04:38 <BSP_> the environment is cygwin on windows vista
13:04:51 <EvilTerran> you can't get at the oxford notes from outside the intranet, though, which makes me think they're kinda protective of 'em
13:04:59 <EvilTerran> they're not that interesting, anyway.
13:05:02 <Heffalump> Notrix: errm, there's also the fact that they are paid to do so.
13:05:04 <hpaste>  Arnar pasted "mapM, filterM" at http://hpaste.org/3159
13:05:14 <Arnar> would anyone be so kind as to look at the above ^^
13:05:46 <Notrix> Heffalump, well I'm sure all my lecturer could get a lot more money if they worked in a company
13:06:01 <Notrix> Anyway there slides and courses are still available for everybody :p
13:06:42 <byorgey> Arnar: what's the problem?
13:06:54 <Notrix> EvilTerran, haha :p Ok. In fact it was just to compare what the oxford students see in the first year with the imperial's ones
13:06:59 <Arnar> byorgey: it's not doing what I want it to :)
13:07:20 <byorgey> Arnar: ah.  well, did you ask it nicely?
13:07:31 <Arnar> backstory: I've parsed a construct like " g->C # g->C # g->C "
13:07:33 <Arnar> byorgey: hehe..
13:07:34 <djfroofy> why is that if I want to understand any function defined in haskell, I have to read someone's doctoral thesis?
13:07:44 <Arnar> where g are guards and C are commands (programs if you will)
13:07:56 <byorgey> Arnar: ok
13:08:05 <Arnar> I wan't to select non-deterministically one of the commands, but only if the corresponding guard does not fail..
13:08:09 <EvilTerran> we don't see much. we re-invent a significant chunk of the library defined in the report, gloss over the concept of monads, do a bit of graphics in a custom framework that's idiot-proof but very specific
13:08:18 <Arnar> failed guard is indicated by sosGC returning FailedGC
13:08:43 <byorgey> Arnar: ok, so in other words you want to non-deterministically pick from among those for which the guard is successful?
13:08:54 <Arnar> to give everyone the same probability, I'm flatting the tree - and I want to filter out those that have failed guards
13:08:57 <Arnar> byorgey: exactly
13:09:04 <EvilTerran> i *think* you can look at what lecture streams we do without being inside the oxford bubblew
13:09:04 <Arnar> s/flatting/flattening/
13:09:33 <byorgey> djfroofy: because Haskell is sufficiently powerful/abstract that you can actually define/use PhD-level concepts in under five lines of code.
13:09:47 <Heffalump> Notrix: but they wouldn't get time to do research
13:10:03 <cpoucet> @remember byorgey because Haskell is sufficiently powerful/abstract that you can actually define/use PhD-level concepts in under five lines of code.
13:10:03 <lambdabot> Done.
13:10:32 <Arnar> byorgey: before, I was just looking at the root of the tree and selecting either the left or right hand side of #, but that didn't give all of them an even change (first one got 1/2, second one 1/4 etc.)
13:11:26 <arjanoosting> @seen Igloo
13:11:26 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I don't know when Igloo last spoke.
13:11:32 <Notrix> Heffalump, true :p, but I think most teachers enjoy giving lectures (well I hope so)
13:11:35 <byorgey> Arnar: the flattenGC looks fine.
13:11:41 <yitz> Arnar: you want to pick one that fails?
13:11:57 <Arnar> yitz: no.. I wan't to pick one that doesn't fail
13:11:59 <yitz> Or did you want (not . fails) ?
13:12:06 <Arnar> ah.
13:12:15 <Arnar> yes, (not . fails)
13:13:13 <djfroofy> byorgey: certainly, but wouldn't it be nice if someone could explain that (if only as a verisimilitude) in a few lines of English, rather than saying: "Oh, read the research paper"
13:13:39 <Arnar> looks like that was my problem :)
13:13:46 <Arnar> changed it to "succeeds" and reversed
13:14:07 <byorgey> djfroofy: well, you're right.  and in some cases, that's been done.  in some cases, no one has done it yet. and in some cases, it really isn't possible.
13:15:09 <byorgey> djfroofy: also, there are some really excellent, readable papers out there.  Just because something is in a paper doesn't mean it's not accessible.
13:16:00 <ddarius> Usually research papers do a very good job of explaining and therefore it's best and easiest to just refer to it.
13:16:09 <hpaste>  Arnar annotated "mapM, filterM" with "(no title)" at http://hpaste.org/3159#a1
13:16:24 <Arnar> byorgey, yitz: ^^ that one does what I want.. :)
13:16:26 <Arnar> thanks
13:16:43 <djfroofy> byorgey: agreed, i don't mind reading papers.  but when i'm in hacking mode, it can be a distraction.
13:18:25 <EvilTerran> ?type \f -> filterM (return . f)
13:18:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> Bool) -> [a] -> m [a]
13:18:42 <cpoucet> lo heffa
13:18:46 <EvilTerran> ?type \f -> return . filter f
13:18:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> Bool) -> [a] -> m [a]
13:19:23 <Arnar> EvilTerran: do they have the same semantics?
13:19:36 <EvilTerran> i think so, yes
13:19:43 <twifkak> @pl \f -> filterM (return . f)
13:19:43 <lambdabot> filterM . (return .)
13:19:43 <user317> how come this doesn't work:  _ <- (liftM IO.hClose) Nothing
13:19:50 <twifkak> @pl \f -> return . filter f
13:19:50 <lambdabot> (return .) . filter
13:20:17 <kpreid> user317: becuase liftM just lifts a function
13:20:18 <twifkak> well, that was uninformative.
13:20:18 <ddarius> user317: Because it makes no sense.
13:20:19 <user317> i have a (Maybe Handle) and i want to close it without actually pulling it out
13:21:10 <user317> this works fine: (liftM ((+) 2)) Nothing
13:21:24 <kpreid> user317: here's a somewhat roundabout way: mapM_ IO.hClose (listToMaybe Nothing)
13:21:42 <hpaste>  EvilTerran annotated "mapM, filterM" with "I think this is equivalent" at http://hpaste.org/3159#a2
13:21:54 <kpreid> user317: to make it less roundabout, you need the function for Maybe which mapM_ is for [] -- I think you'll have to write it
13:22:22 <mrd> mapM_ = sequence_ . map
13:22:38 <Arnar> EvilTerran: thanks.. what is =<< ?
13:22:45 <EvilTerran> @src (=<<)
13:22:46 <lambdabot> f =<< x = x >>= f
13:22:51 <Arnar> oh..
13:22:53 <Arnar> naturally :)
13:22:54 <EvilTerran> :D
13:23:03 <bringert> how do I install ghc-6.8 from darcs and keep it from creating symlinks like ghc -> ghc-6.8? I want 'ghc' to still be 6.6
13:23:13 <mrd> er mapM_ f = sequence_ . map f
13:23:28 <EvilTerran> a lot of haskell seems to end up being right-to-left, so it's more natural in some cases
13:23:48 <user317> > :t (liftM IO.hClose) Nothingrn(liftM IO.hClose) Nothing :: Maybe (IO ())
13:23:48 <lambdabot>  Illegal character ''\DLE''
13:24:21 <Arnar> EvilTerran: yes.. right-to-left is more natural for "composite" like stuff
13:24:44 <Arnar> well.. for mathematicians at least
13:25:13 <mrd> @type maybe (return ()) IO.hClose
13:25:15 <lambdabot> Maybe GHC.IOBase.Handle -> IO ()
13:25:44 <Arnar> are $ and . only different in preceedence?
13:26:02 <ddarius> Arnar: They don't even have the same type.
13:26:05 <mrd> $ is application
13:26:08 <mrd> . is composition
13:26:48 <byorgey> although they are sometimes interchangeable in a situation like (a $ b $ c $ d) <==> (a . b . c $ d)
13:26:54 <byorgey> but that isn't because they're the same.
13:27:00 <Arnar> ah..
13:27:06 <EvilTerran> which is for the best, seeing as they aren't
13:27:44 <byorgey> right.
13:28:01 <byorgey> I mean, it would be confusing if they were interchangeable because they're the same, when they aren't.
13:29:04 <EvilTerran> ohh, my head O.o
13:29:45 <byorgey> ...you mean O$o?  because those aren't the same =)
13:30:01 <mrd> especially if your nose is broken
13:30:01 <EvilTerran> wait, "head O" would be a type error...
13:30:30 <mrd> or, perhaps:   "Before surgery: O$o"  "After surgery: O.o"
13:30:41 <EvilTerran> @remember byorgey I mean, it would be confusing if they were interchangeable because they're the same, when they aren't.
13:30:41 <lambdabot> Done.
13:30:42 <Arnar> so "f $ x" is "f x"..
13:30:49 <EvilTerran> @src ($)
13:30:49 <lambdabot> f $ x = f x
13:30:51 <mrd> @src ($)
13:30:52 <lambdabot> f $ x = f x
13:30:55 <EvilTerran> exactly :D
13:30:55 <mrd> damn you
13:31:05 <user317> mrd, thanks, what about: Maybe.fromJust . (liftM IO.hClose)
13:31:05 <EvilTerran> you're welcome ;)
13:31:11 <EvilTerran> @quote stereo
13:31:12 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
13:31:20 <mrd> user317: wouldn't that break on Nothing
13:31:43 <mrd> and i don't mean "break on nothing"
13:31:50 <Arnar> but they have different preceedence (f $ x y is not f x y)
13:31:53 <user317> mrd, yea you are right
13:31:57 <mrd> Arnar: indeed
13:32:24 <byorgey> in fact, it's f (x y)
13:32:54 <EvilTerran> @pl ($)
13:32:54 <lambdabot> id
13:33:22 <mrd> f $ x = f `id` x
13:33:22 <user317> mrd, i guess this does the same thing, (Maybe.fromMaybe (return ())) . (liftM IO.hClose) $ Nothing
13:33:44 <mrd> probably
13:33:49 <mrd> fromMaybe is total, like maybe
13:33:53 <ddarius> :t fromMaybe (return ()) . liftM hClose $ Nothing
13:34:01 <lambdabot> Not in scope: `hClose'
13:34:04 <mrd> IO.hClose
13:34:18 <EvilTerran> ?type hClose
13:34:20 <lambdabot> Not in scope: `hClose'
13:34:25 <EvilTerran> ?type IO.hClose
13:34:26 <lambdabot> GHC.IOBase.Handle -> IO ()
13:34:58 <EvilTerran> ?type fromMaybe (return ()) . liftM IO.hClose $ Nothing
13:35:00 <lambdabot> IO ()
13:37:11 <user317> i guess that makes sense
13:38:45 <EvilTerran> ?type (>> IO.hClose) . guard . isJust
13:38:48 <lambdabot>     No instance for (MonadPlus ((->) GHC.IOBase.Handle))
13:38:48 <lambdabot>       arising from use of `guard' at <interactive>:1:17-21
13:39:11 <EvilTerran> oh, i see. never mind me.
13:40:54 <EvilTerran> ?type maybe (return ()) IO.hClose $ Nothing
13:40:56 <lambdabot> IO ()
13:50:04 <Tela> Anyone want to golf on a Haskell Quiz response with State and Random? Monads are just now clicking for me, so I feel like I wrote it pretty pathologically.
13:50:32 <hpaste>  Tela pasted "Haskell Quiz 76: Word Munger" at http://hpaste.org/3161
13:51:46 <Tela> I feel like there must be an easier way to thread the StdGen around
13:52:01 <cpoucet> Regarding haskell-mode in emacs, it seems to be borking on data-declaractions
13:52:23 <mrd> in what way
13:52:50 <cpoucet> it seems to take the | as a guard
13:52:56 <cpoucet> so I get
13:52:58 <cpoucet> Foo
13:53:00 <mrd> the indent?
13:53:00 <cpoucet>     | Bar
13:53:02 <cpoucet> yah
13:53:06 <mrd> data Foo
13:53:16 <mrd> did you cycle through the indentations?
13:53:23 <mrd> (keep hitting tab)
13:53:27 <cpoucet> yep
13:53:52 <mrd> data Foo = ?
13:54:06 <cpoucet> data Foo =
13:54:08 <cpoucet>    Bar
13:54:11 <cpoucet>   | Bum
13:54:14 <cpoucet> I get the | after Bar
13:54:27 <mrd> even after hitting  Tab again?
13:54:30 <cpoucet> yep
13:54:37 <mrd> weird
13:54:38 <cpoucet> it flips back and forth by 1 ltter
13:54:42 <TSC> Tela: you could change the "loop" and mungeLine to use the State monad too, so they don't have to thread the gen manually
13:54:53 <shapr> Where's the array cabal package?
13:54:54 <shapr> @where array
13:54:55 <lambdabot> I know nothing about array.
13:54:56 <shapr> hmm
13:58:22 <bringert> why is base called 2.1 in ghc 6.8?
13:58:52 <bringert> it seems to be 2.1.1 in ghc 6.6.1
13:59:33 <bringert> shapr: array is a new ghc 6.8 package, from the base split
14:01:34 <user317> has the work on glasgow parallel haskell stopped?
14:06:01 <shapr> user317: Ask Phil Trinder?
14:06:38 <glen_quagmire> in a normal function without IO, can I still print something?
14:07:07 <glen_quagmire> like, for debug purpose, during function evaluation, i want to print some numbers
14:07:15 <ddarius> @hoogle trace
14:07:15 <lambdabot> Debug.Trace.trace :: String -> a -> a
14:07:15 <lambdabot> Debug.Trace :: module
14:07:15 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
14:07:52 <shapr> bringert: network-bytestring doesn't build with 6.6.1, should I just wait till 6.8?
14:08:12 <EvilTerran> bear in mind that they might arrive at unexpected times, not at all, or even multiple times
14:08:15 <bringert> shapr: probably just need to hack the .cabal file
14:12:02 <turulu> hi
14:12:05 <glen_quagmire> nice trace works. thanks ddarius
14:12:06 <turulu> could someone real brief what's the difference between having an OS coded in ASM, Haskell or C?
14:12:10 <turulu> thanks
14:12:16 <turulu> I know there is haskellOS
14:12:26 <glen_quagmire> but if I have if then else block, I need to put trace for every thing
14:12:32 * glen_quagmire tries trace in let block
14:12:36 <ddarius> turulu: There need be no external difference.
14:12:57 <turulu> I am recently aware of other languages and I was wondering why ALL OSes are coded in C
14:12:59 <Tela> TSC, I saw how you could bring State up through mungeLine, but I'm having trouble figuring out how to combine the State and IO monads in loop.
14:13:05 <turulu> ddarius: in terms of performance?
14:13:28 <Tela> Is it possible to have loop :: State StdGen (IO ())?
14:13:33 <hpaste>  Tela annotated "Haskell Quiz 76: Word Munger" with "Brought State to mungeLine..." at http://hpaste.org/3161#a1
14:13:39 <TSC> Tela: Oh, because you call getLine in loop... let me see
14:14:05 <TSC> One option is to separate the IO
14:14:19 <ddarius> turulu: Policy is more important for performance.
14:14:29 <Tela> But then you need to manually thread the StdGen, right?
14:14:35 <TSC> Another is to use a monad transformer
14:14:46 <turulu> err... and Policy is achieved by means of...?
14:14:55 <cpoucet> Is it possible, in some way, to define submodules in 1 file?
14:15:45 <Tela> Can I bring the monad transformer in right here at loop, or would I need to thread it back through the rest of the program? :S
14:16:02 <glen_quagmire> > let dis = trace (show (b*b - 4.0*a*c)) (b*b - 4.0*a*c); det = trace (show sqrt(dis)) (sqrt dis) in det + dis
14:16:03 <lambdabot>   Not in scope: `trace'
14:16:05 <TSC> You could have "loop :: StateT StdGen IO ()"
14:16:30 <Tela> Let me fiddle with that for a bit then, thanks :)
14:17:08 <TSC> I think you can introduce it at loop, but you might need to convert from StateT to State and back, via get, put and runState
14:17:33 <ddarius> turulu: By means of code, but the language used is completely irrelevant.
14:17:51 <turulu> ddarius: policy of what?
14:18:17 <ddarius> turulu: Everything.
14:18:47 <turulu> ddarius: so C haskell and ASM can do policies? Then why compete creating OSes with different languages?
14:19:31 <dmwit> cpoucet: Have you tried putting "module Blah where ..." several times in one file?
14:19:53 <ddarius> turulu: "policies" aren't something concrete.  But obviously you can use whatever language you want and create an OS with exactly the same interface.
14:20:26 <cpoucet> dmwit: nope
14:20:32 <ddarius> turulu: However, how easy it would be will vary with language and rarely does one try to make an OS with exactly the same interface so what other interfaces a language suggests is another aspect.
14:20:55 <bringert> @tell dcoutts_ cabal-install needs zlib-0.4, since 0.3 doesn't build on ghc 6.8. any chance you could put it on hackage?
14:20:55 <lambdabot> Consider it noted.
14:21:07 <turulu> ddarius: so... in what respects is Haskell better than C?
14:21:08 <ddarius> turulu: There isn't One Right Operating System.
14:21:36 <ddarius> turulu: In the same respects Haskell is better than C in any domain.
14:22:09 <cpoucet> dmwit: seems not to work :|
14:22:12 <dmwit> laziness, memory management, composability...
14:22:28 <cpoucet> crud
14:22:31 * cpoucet wants multiple modules
14:22:57 <turulu> recently I've reading how C is buggy as hell
14:22:57 <turulu> I saw a military study comparing ADA and C
14:23:01 <glen_quagmire> is there a way to not call trace when I compile the program with some parameters?
14:23:13 <TSC> glen_quagmire: Redefine trace
14:23:14 <Botje> turulu: C does not have bugs.
14:23:22 <TSC> trace _ x = x
14:23:31 <TSC> (and maybe hide the import)
14:23:33 <dmwit> trace = flip const
14:23:46 <dmwit> trace _ = id -- I like this one
14:23:48 <turulu> Botje: according that study it has tons
14:23:54 <rey_> gets() is a pretty big bug :)
14:23:59 <dmwit> cpoucet: Hmm, no it doesn't.
14:24:00 <ddarius> turulu: Languages don't have bugs.
14:24:58 * cpoucet tsks
14:25:06 <Botje> turulu: considering C is just portable assembly, it does that job pretty well
14:25:14 * ddarius disagrees.
14:25:46 <turulu> o_O
14:25:47 <glen_quagmire> should I concern for efficiency ?   when I define trace _ = id, would it actually call id function  or compiler will figure out and not call id but just evaluate the argument?
14:26:14 <ddarius> glen_quagmire: No you shouldn't worry about it because either way the difference will be negligible.
14:26:14 <sjanssen> glen_quagmire: 'trace _ = id' will disappear with ghc -O
14:26:26 <Taejo> C has what Linus would call "brain damages" if he wasn't so blind to the joys of anything-but-c
14:26:45 * shapr agrees
14:27:16 <glen_quagmire> nice
14:27:24 <EvilTerran> glen_quagmire, i think trace uses unsafePerformIO, so it's completely undefined in behaviour anyway ;)
14:28:14 <turulu> ok... any apps for linux written in Haskell?
14:28:15 <turulu> just curious how it would run
14:28:22 <sjanssen> darcs, xmonad
14:28:41 <dmwit> ghc, pugs
14:28:46 <ddarius> Most Haskell programs will run on Linux.
14:29:20 <dmwit> I'm assuming hpaste/hoogle are run on some *nix.
14:30:21 <Botje> turulu: linspire's package management system is haskell too
14:30:32 <turulu> w00t
14:31:05 <bos> brilliant, google blog search finds this: "Generic Picture Valium. Valium Ativan, Generic Haskell A Language For Generic Programming!"
14:31:11 <glen_quagmire> let dis = trace ("dis: " ++ show (b*b - 4.0*a*c)) (b*b - 4.0*a*c) -- I don't like (b*b - 4.0*a*c) appearing twice. If I do let dis_ = (b*b - 4.0*a*c); dis = trace (show dis_) dis, is this better?
14:31:35 <turulu> I wish Linux or some widely used OS would be ported into different OSes in order to see real benchmarks
14:31:55 <ddarius> turulu: That makes no sense.
14:31:59 <dmwit> glen_quagmire: Sure, that's a great way to do it.
14:32:18 <glen_quagmire> awesome!
14:32:24 <turulu> ddarius: then why that guy is coding HaskellOS?
14:33:02 <dmwit> turulu: I think you are confused about how operating systems and programming languages interact.
14:35:53 <goalieca> turulu, start out with binutils
14:36:13 <goalieca> like write less, cat, wc
14:36:26 <glen_quagmire> hrm I can't import multiple modules on one line? import IO, Numeric, Debug.Trace
14:36:37 <turulu> goalieca: yes
14:37:10 <dmwit> glen_quagmire: nope
14:37:15 <Mr_Awesome> what does MonadState s m | m -> s mean?
14:37:20 <goalieca> turulu: http://haskell.org/haskellwiki/Wc
14:37:21 <glen_quagmire> impdecl  ->  import [qualified] modid [as modid] [impspec]
14:37:21 <lambdabot> Title: Wc - HaskellWiki
14:37:34 <turulu> goalieca: what about the kernel?
14:37:45 <goalieca> would be foolish to write in anything but c
14:37:53 <dmwit> Mr_Awesome: I think it's a functional dependency; it means that the type "m" completely determines the type "s".
14:37:57 <goalieca> i wouldn't put c++ in a kernel even
14:38:09 <goalieca> c++ makes perfect sense for user-space stuff though
14:38:27 <turulu> goalieca: mm.. someone here told me for a class excercise he had to create an OS
14:38:33 <turulu> do you know by any chance what's the name of that excercise
14:38:35 <Mr_Awesome> dmwit: oh... that still doesnt really make sense. is it important for me to understand it?
14:38:42 <turulu> and if there are any tutorials online?
14:39:03 <dmwit> Mr_Awesome: It's just a cue to the type-checker, I think.  Don't worry about it too much.
14:39:20 <dmwit> Mr_Awesome: They're introducing something new which overshadows fundeps soon.  (Hopefully!)
14:39:22 <goalieca> turulu, grab a book by the minix guy.. its called "modern operating systems"
14:39:35 <goalieca> writing an OS is a huge deal
14:39:51 <dmwit> ?google pintos
14:39:53 <lambdabot> http://www.stanford.edu/class/cs140/projects/pintos/pintos.html
14:40:20 <turulu> goalieca: mm... that HaskellOS says he only has 500 lines
14:40:24 <dmwit> turulu, goalieca: Writing an OS is no big deal; have a go at implementing PintOS and see just how easy it can be! =)
14:40:45 <goalieca> dmwit, i can write a 20 line os for some stupid microcontroller.
14:40:53 <goalieca> but a usefull desktop os is different
14:40:55 <turulu> I ok I don't mean big or small deal... some type of instruction to follow and all
14:41:08 <turulu> lol@20 lines
14:41:09 <gwern> I thought it was xmonad that was supposed to be 500 lines?
14:41:20 <dmwit> goalieca: Now you're talking about the programs to run on the OS; I agree that such a thing is much more tedious.
14:41:23 <goalieca> turulu, this is the standard book everyone has. I think it's well written: http://www.amazon.com/Modern-Operating-Systems-Andrew-Tanenbaum/dp/0130313580
14:41:27 <lambdabot> http://tinyurl.com/2ayw4g
14:41:35 <yitz> "What's that site running?" (http://uptime.netcraft.com/up/graph) www.hpaste.org: OS: Linux Server: HAppS/0.8.4
14:41:35 <turulu> Page not found!
14:41:40 <gwern> a new tagline, I suppose. 'XMonad! Longer and more complex than an OS!"
14:41:50 <dmwit> goalieca: But that task is totally unnecessary; all you need to get working on your operating system is a C compiler. ;-)
14:42:31 <turulu> lambdabot: you links is working!!
14:42:38 <glen_quagmire> Ambiguous occurrence `trace' It could refer to either `trace', defined at Quadratic.hs:44:0 or `trace', imported from Debug.Trace at Quadratic.hs:6:0-17
14:42:41 <dmwit> http://www.scs.stanford.edu/07au-cs140/
14:42:42 <lambdabot> Title: CS140: Operating Systems
14:42:45 <goalieca> dmwit, ignoring boot but making a multi-tasking OS with memory management and base drivers.
14:43:04 <dmwit> goalieca: Yes, that is what we did.  Except we didn't ignore boot.
14:43:19 <goalieca> term project?
14:43:26 <dmwit> yeah
14:43:31 <goalieca> okay. of course.
14:43:37 <goalieca> different from an "assignment"
14:43:45 <dmwit> ok
14:44:02 <goalieca> implementing a shell is an "assignment". making a schedular is an "assignment". but the whole thing is a project
14:44:07 <goalieca> that's all i'm getting at
14:44:12 <dmwit> ok
14:44:13 <yitz> Hoogle runs on haskell.org, which is Apache 2.0.46 on Red Hat Linux at Yale U.
14:44:16 <dmwit> We agree, then. =)
14:44:31 <dmwit> yitz: Sweet, my assumptions are warranted!
14:45:31 <turulu> dmwit: thanks for the Stanford link
14:45:58 <turulu> by the way I used to work at WholeFoods over there as a dirty immigrant bagger
14:46:03 <turulu> :-)
14:46:31 <hpaste>  etnt' pasted "How to use the State Monad" at http://hpaste.org/3162
14:46:54 <etnt`> anyone care to take a look at my pasted code ?
14:47:00 <ac> turulu: you mean in the bay area?
14:47:07 <etnt`> need som help with those Monads...
14:47:27 <dmwit> etnt`: You don't need any monads.
14:47:29 <dmwit> Check this out:
14:47:30 <turulu> near the rails and below University Avenue
14:47:35 <turulu> not sure if still there
14:47:39 <ac> turulu: did you move?
14:47:44 <dmwit> > (sum &&& length) . filter odd $ [1..9]
14:47:49 <pgavin> etnt`: yeah, that's generally the type of thing you'd use monads for
14:47:52 <lambdabot>  (25,5)
14:48:05 <turulu> righ next to Frog design or watever is called that design company
14:48:21 <etnt`> dmwit: yes but the whole point is that I want to learn how to use Monads
14:48:28 <pgavin> but you'd use doSumCount :: [Int] -> State (Int, Int,) Int
14:48:35 <etnt`> they drives me mad ... :-)
14:48:48 <etnt`> hm...
14:48:56 <pastorn> @type (&&&)
14:48:58 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:49:04 <pgavin> data State s a = State $ s -> (s, a)
14:49:10 <pgavin> oops
14:49:12 <pgavin> I mean
14:49:22 <pgavin> data State s a = State (s -> (s, a))
14:49:44 <dmwit> Surely it would be doSumCount :: [Int] -> State (Int, Int) ()
14:49:56 <pastorn> @src (&&&)
14:49:56 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
14:50:06 <pastorn> @src arr
14:50:06 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:50:11 <pgavin> dmwit: err, yeah
14:50:12 <pastorn> great success!!
14:50:14 <dmwit> etnt`: In any case, yes, you can use the state monad to keep track of the sum and the length.
14:50:30 <dmwit> pastorn: They're arrows, so the implementation depends on which arrow you're in.
14:50:31 <pgavin> then you'd pull the sum out of the resulting state
14:50:41 <dmwit> I was using the (->) arrow, in which case I think arr = id
14:50:46 <etnt`> dmwit: I suspect so, just can't see how
14:50:56 <pastorn> dmwit: is this category theory arrows?
14:51:01 <dmwit> pastorn: yes
14:51:07 <pastorn> whoa, cool
14:51:27 <ac> turulu: what's your programming background?
14:51:45 <dmwit> etnt`: Use (sum, length) as your state.  Then sumCount should sequence the actions: set the initial state, update the state based on the list.
14:51:52 <turulu> ac: 0
14:52:03 <dmwit> etnt`: Similarly, doSumCount simply sequences an update action for each element of the list.
14:52:31 <ac> turulu: but have you written small programs in any language?
14:52:41 <dmwit> pastorn: (&&&) just runs two functions in parallel:
14:52:46 <turulu> ac: negative I said 0
14:53:04 <dmwit> > ((*32) &&& show) $ 3
14:53:06 <lambdabot>  (96,"3")
14:53:18 <ac> turulu: oh. It would be interesting to start out with Haskell :)
14:53:20 <pastorn> ok
14:53:28 <turulu> ac: I am beginning now to build my background
14:53:38 <ac> turulu: though I'm not sure I'd recommend it
14:53:39 <turulu> turulu: I am debating Lisp or Haskell
14:53:39 <dmwit> So, in effect, f &&& g x = (f x, g x); it's just a handy way of writing it.
14:54:06 <pastorn> it is?
14:54:14 <ac> turulu: with either one, you'll be starting way ahead of me. I started with Microsoft QBasic
14:54:32 <mikael> it also works for any arrow type of f and g
14:54:32 <pastorn> dmwit: it's one character shorter :)
14:54:52 <dmwit> etnt`: Can you come up with the type annotations for the State-monad version, anyway?
14:54:52 <mikael> oh, you've been over that
14:55:14 <turulu> ac: mm.. well I gotta start from scratch. Not sure if that qulifies as "ahead" ;-)
14:55:30 <ac> turulu: if you start with lisp/scheme, I'd recommend a book that I'm working on now: "Structure and Interpretation of Computer Programs". It's supposedly an introductory text on programming, but it's pretty dense for that in my opinion, and I'd recommend reading it after a little experience
14:56:09 <mikael> try it, can't hurt!
14:56:11 <hpaste>  etnt' pasted "use of a Monad" at http://hpaste.org/3163
14:56:12 <ac> turulu: I think it's an excellent book though, and you can get the full text here: http://mitpress.mit.edu/sicp/
14:56:14 <lambdabot> Title: Welcome to the SICP Web Site
14:56:20 <dmwit> > sum &&& length [1,2,3] -- /me wonders about precedence
14:56:21 <lambdabot>  Couldn't match expected type `[a] -> c''
14:56:42 <turulu> ac: wow awsome
14:56:44 <Mr_Awesome> how can i do what im trying to do with this declaration?  type E = MonadState s m => m V
14:56:46 <sarehu> > (sum &&& length) [1..3] -- what were you thinking
14:56:47 <lambdabot>  (6,3)
14:56:49 <etnt`> dmwit:. bah...I'm stupid...
14:56:53 <dmwit> etnt`: You can also annotate pastes to keep things together.
14:57:07 <ac> turulu: it's widely regaurded as one of the best "introductory" books on programming in general
14:57:23 <etnt`> I'll remember that
14:57:26 <goalieca> and you won't get imperative taint?
14:57:30 <Mr_Awesome> do i have to use newtype or something?
14:57:37 <goalieca> most n00bs start out with java. stupid cs schools
14:57:54 <turulu> ac: what math level do you reccomend?
14:58:09 <dmwit> etnt`: There's a couple of weird things going on with the code you pasted, hold on a second.
14:58:24 <ddarius> Starting using Scheme, How to Design Programs is probably the best online resource.
14:58:32 <ddarius> http://www.htdp.org
14:58:34 <lambdabot> Title: How to Design Programs
14:58:40 <turulu> goalieca: on an article someone called teaching java a "vocational training" o_O
14:59:07 <ac> turulu: well, basically none is necessary, but any helps. That book I just mentioned assumes vary basic calculus (some of the examples in the first chapter deal with newton's method and symbolig differentiation), but it's not necessary
14:59:09 <hpaste>  yitz annotated "How to use the State Monad" with "sumCount in the State monad" at http://hpaste.org/3162#a1
14:59:17 <goalieca> turulu, computer science is pretty much software engineering at most places :(
14:59:43 <yitz> etnt' - I pasted a State monad version. Enjoy.
14:59:52 <ddarius> SICP is overly mathematical.
15:00:11 <ddarius> If you don't know better, it can give the wrong impression of programming.
15:00:15 <yitz> @type odd
15:00:17 <lambdabot> forall a. (Integral a) => a -> Bool
15:00:19 <etnt`> yitz: thx, will give me something to ponder
15:00:27 <ac> turulu: ddarius is right
15:00:28 <EvilTerran> @src odd
15:00:28 <lambdabot> odd = not . even
15:00:32 <EvilTerran> ...
15:00:34 <EvilTerran> @src even
15:00:34 <lambdabot> even n = n `rem` 2 == 0
15:00:37 <turulu> thanks guys!! this is awsome...
15:00:54 <EvilTerran> okay. good thing that isn't not.odd, eh...
15:01:02 <sarehu> it would've been great if it printed "even = not . odd"
15:01:09 <sarehu> er, what he said
15:01:12 <EvilTerran> :D
15:01:16 <ac> turulu: I just wish I had all this information available when I started out about 10 years ago ;)
15:01:22 <goalieca> EvilTerran, for integer types it would be easier to check bits wouldn't it?
15:01:30 * ddarius also started with QBASIC
15:01:38 <hpaste>  dmwit annotated "use of a Monad" with "A tip and a place to start" at http://hpaste.org/3163#a1
15:01:46 <ac> QBASIC + DOS is awesome!
15:01:54 * goalieca started with hypercard.. then qbasic
15:02:01 * goalieca is really tainted
15:02:08 <adaptable> BASIC for Atari ST. :)
15:02:09 * goalieca took years to unlearn
15:02:13 <ac> heh
15:02:23 <EvilTerran> goalieca, i guess so, but it's not a method of a class, AFAIK, so it can't be specialised for specific types
15:02:34 <etnt`> dmwit: thx!
15:02:40 <dmwit> Good luck!
15:02:41 <dmwit> =)
15:03:08 <goalieca> EvilTerran, lack of overloading makes me sad.
15:03:44 <EvilTerran> goalieca, but i imagine the definition of rem for Int (say) uses the processor's integer modulo, and so an optimising compiler could well reduce that to bitops
15:04:03 <dmwit> EvilTerran: You would wish so; but in fact it does not.
15:04:06 <dons> yo yo haskell hacker
15:04:06 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:04:07 <dmwit> =/
15:04:09 <EvilTerran> but hey, this is haskell! since when do we worry about any aspect of running time but asymptotic complexity? ;)
15:04:11 <dons> s
15:04:19 <dmwit> Hi dons!
15:04:22 <dons> EvilTerran: that's such 1990s talk :P
15:04:46 <goalieca> O( log n ) < 50 forall n :-)
15:04:53 <dons> that's *so* true
15:05:04 <cpoucet> no it's not!
15:05:06 <EvilTerran> it's "true enough"
15:05:06 <cpoucet> constant factors!
15:05:20 <cpoucet> 1000000000000log n !< 50
15:05:23 <dmwit> O(log n) is actually a set of functions, for which (<) isn't really all that well defined.
15:05:27 <goalieca> okay O( log n ) = O (c)
15:05:49 <EvilTerran> i really don't like O() notation. it feels so imprecise.
15:05:58 <goalieca> > log (2^64)
15:06:03 <lambdabot>  44.3614195558365
15:06:08 <dmwit> EvilTerran: Just replace (=) with (\elem) everywhere and it will feel better. =)
15:06:18 * EvilTerran prefers the curly inequality operators
15:06:22 <dmwit> 3x^2 \elem O(x^2)
15:06:29 <ac> turulu: Another language I always recommend for people to start with is JavaScript. It's already installed on your computer, and in some ways it's really fun to program with.
15:06:53 <goalieca> ac you're nuts :P
15:07:02 <goalieca> allegro and c are a good start
15:07:09 <turulu> ac: it's ok to practice like for webpages?
15:07:17 <dmwit> etnt`: By the way, feel free to hpaste if you think you've made some progress, or if you come up against another wall! =)
15:07:18 <sarehu> what's wrong with javascript?  it's a nice language
15:07:50 <etnt`> dmwit: thx, I'm thinking at the moment... :-)
15:07:52 <ac> basically, it really doesn't matter at all what you start with, as long as you don't get boxed in
15:08:33 <ddarius> sarehu: There are definitely things wrong with javascript, but, relatively speaking, it is a nicer language than most.
15:08:50 <sarehu> starting with javascript is waaaay better than starting with, say, MS Works spreadsheet (where some moron decided it was ok to limit people to 255 character expressions in each cell :-))
15:09:01 <ac> goalieca: note that I said "in some ways" (which happens to exclude building interactive cross-browser-compliant web pages)
15:09:07 <EvilTerran> f `curlyle` g meaning f = O(g), f `curlylt` g meaning f = o(g)
15:09:15 <EvilTerran> and then ~ for bigtheta
15:10:11 <EvilTerran> can't for the life of me remember what it's called or who thought it up, but i like it
15:10:21 <EvilTerran> doesn't abuse notation quite so vigorously
15:11:10 <dmwit> What is o(g)?
15:11:14 <sarehu> personally I prefer O_{n -> \infty}(f(n))
15:11:53 <ac> how do I assert things outside of a do block?
15:12:02 <sarehu> ac: assert?
15:12:24 <ac> sarehu: specify an equality that when fails raises an exception
15:12:29 <sarehu> ok
15:12:43 <dmwit> ac: With guards?
15:12:52 <dmwit> > error "AAAGH"
15:12:54 <lambdabot>  Exception: AAAGH
15:12:56 <yitz> @type error
15:12:58 <lambdabot> forall a. [Char] -> a
15:13:15 <dmwit> :t flip (error "AAGH") -- teehee!
15:13:17 <lambdabot> forall a b c. b -> a -> c
15:13:39 <sarehu> ac: like    f x | x < 0 = error "Fooie.f: index out of range"
15:15:07 <ac> sarehu: ok
15:15:28 <glen_quagmire> how can I [Int] -> String?
15:15:40 <yitz> @type read
15:15:42 <lambdabot> forall a. (Read a) => String -> a
15:15:42 <glen_quagmire> [2,3,46,0] -> "23460"
15:15:57 <glen_quagmire> > read [1,0,1]
15:15:58 <lambdabot>   add an instance declaration for (Num Char)
15:15:58 <lambdabot>     In the expression: 1
15:16:21 <glen_quagmire> > show [1,0,1]
15:16:22 <lambdabot>  "[1,0,1]"
15:16:28 <yitz> > read $ map show [2,3,46,0]
15:16:29 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
15:16:44 <ac> turulu: I don't understand your question
15:16:44 <yitz> > read $ concatMap show [2,3,46,0]
15:16:45 <lambdabot>  23460
15:17:08 <glen_quagmire> > concatMap show [2,3,46,-1]
15:17:09 <lambdabot>  "2346-1"
15:17:10 <yitz> > concatMap show [2,3,46,0]
15:17:11 <lambdabot>  "23460"
15:17:33 <turulu> ac: what question?
15:18:39 <ac> turulu: about practicing on web pages
15:19:29 <EvilTerran> dmwit, effectively, f = o(g) <=> f = O(g) && f /= \Theta(g), as i understand it
15:20:07 <dmwit> Okay, so x^2 \in o(x^3), for example.
15:20:14 <EvilTerran> g has explicitly "worse" asymptotic complexity, rather than "no better"
15:20:50 <EvilTerran> yeah. but x^2 \not\in o(x^2)
15:20:55 <sarehu> EvilTerran: not quite.  f \in o(g) means lim x -> infinity f(x)/g(x) = 0
15:21:18 <EvilTerran> i was about to say that. i was under the impression that the two statements were equivalent
15:21:46 <turulu> ac: oh you mention java is nice to practice, and I said if it's ok to practice on websites
15:21:46 <EvilTerran> if f(x)/g(x) tends to any non-zero value, then they're bigtheta with each other
15:22:04 <sarehu> for example, sin^2(x) \in O(1), sin^2(x) \notin \Theta(1), sin^2(x) \notin o(1)
15:22:04 <ac> turulu: Java and JavaScript are fairly different computer languages
15:22:17 <EvilTerran> unless it tends to infinity, of course
15:22:38 <EvilTerran> sarehu, well, okay. i was thinking of monotonic increasing functions only.
15:22:55 <EvilTerran> this is in the context of computational complexity, after all
15:22:56 <turulu> oh
15:23:45 <ac> turulu: but they can both run within a web browser environment, though JavaScript is more at home there ;)
15:23:46 <sarehu> EvilTerran: not even that restriction is good enough.  You can be monotonic increasing and teeter between n and n^2, making you O(n^2), not Theta(n^2), and not o(n^2).
15:24:57 * EvilTerran thinks about this
15:25:48 <dmwit> sarehu: malevolent
15:25:50 <dmwit> I like it.
15:26:13 <sarehu> just imagine a function starting at (n,n), making a line to (n+1,(n+1)^2), then making a near-flatline to ((n+1)^2 + 1, (n+1)^2 + 1), and repeating from there.
15:26:22 <EvilTerran> don't the defs of the Big*s involve liminf and/or limsup? i'd've expected it to work with the right arrangement of those
15:27:29 <EvilTerran> although i suspect that may well depend on who you ask
15:27:33 <ac> turulu: In a web browser you see Java in side an applet frame, but JavaScript can control any part of a web page and react to any user input
15:28:15 <sarehu> EvilTerran: depends on what you're comparing -- if you're comparing how some function over a set S grows with respect to some input size measurement, n : S -> RealNumbers, then yeah.
15:28:46 <turulu> ac: oh.. Java like flash
15:28:49 <sarehu> dmwit: thanks
15:29:01 <sarehu> I aim to displease.
15:29:28 <EvilTerran> that is a pretty pathalogical example
15:30:09 <EvilTerran> i'll look into this further at some point
15:30:22 <ac> turulu: exactly, except that flash is specifically for rich media programs, and Java can be used for everything, including web servers, desktop applications, and supposedly software for embedded devices
15:31:20 <EvilTerran> given that i only got into this discussion 'cos i said i didn't like how non-rigorous O() feels to me, i shouldn't grumble when someone points out problems with my reasoning and edge-cases ;)
15:31:21 <ac> turulu: however, flash is aggressively catching up on both desktop applications and things like cell phones. Also, ActionScript (the flash programming language) is very similar to JavaScript, in fact, based on the same specification
15:32:46 <turulu> ac: ok
15:35:39 <hpaste>  etnt' annotated "use of a Monad" with "(no title)" at http://hpaste.org/3163#a2
15:36:03 <etnt`> dmwit: I give up...
15:36:14 <ac> pattern matching only works with types, and guards work with values, right?
15:36:15 <dmwit> etnt`: Don't give up!  That's exactly right!
15:36:21 <dmwit> etnt`: oh
15:36:25 <dmwit> etnt`: Not quite right. =P
15:36:32 <dmwit> etnt`: But still don't give up!
15:36:42 <FMota> I have something a little interesting to share :)
15:36:57 <etnt`> dmwit: don't know what to do
15:36:58 <dmwit> etnt`: In the state monad, there are two interesting things: the "state", which has a fixed type, and the "value" of the monad, which can vary depending on what action happened last.
15:37:01 <FMota> let's say we have a type Nat, which is actualyl codata.
15:37:05 <FMota> *actually
15:37:12 <dmwit> etnt`: "return" changes the "value" of the monad without changing the state.
15:37:18 <FMota> Nat is defined as     Nat = 0 | Succ Nat
15:37:28 <dmwit> etnt`: "put" is the action that changes the state, and makes the monad have a useless value.
15:37:29 <dmwit> :t put
15:37:31 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
15:37:40 <FMota> We can define infinity:     inf = Succ inf
15:37:46 <yitz> etnt': In a state monad, there are two things to talk to: the state, and the result. "return" specifies the result. To specify a value for the state, use "put" (or "modify" to change it using a function).
15:37:49 <etnt`> dmwit: ok, I'll try some more
15:38:35 <etnt`> dmwit: initialize = do {put (0,0) }
15:38:38 <FMota> We can define (+) and (*) such that they'll give us infinity when used with infinity.
15:38:42 <dmwit> etnt`: Perfect!
15:38:52 <etnt`> horay... :-)
15:39:10 <dmwit> etnt`: Okay, the next step is to create a function
15:39:20 <FMota> a + 0 = a;  a + Succ b = Succ (a + b)
15:39:35 <FMota> a * 0 = 0; a * Succ b = (a * b) + a
15:39:37 <dmwit> updateStep :: Int -> State S () -- this function should change the state by increasing the sum/length if the input value is odd
15:39:55 <etnt`> dmwit: ok, I'll give it a try
15:40:09 <dmwit> etnt`: Here, you'll probably want to use "get", which sets the "value" of the monad to be the same as the "state" of the monad.
15:40:12 <FMota> My question is whether or not we can define exponentiation for infinity.
15:41:31 <dmwit> FMota: I guess the obvious thing doesn't work for some reason?
15:41:35 <yitz> "get" pulls out the state, so that you can do stuff with it. Then you can "put" it back. Or, just use "modify" to change the state in place.
15:42:20 <FMota> either it doesnt work, or I'm just being dumb today
15:42:28 <sioraiocht> in category theory, can arrows map from one category to another?
15:42:43 <sioraiocht> or just from one object to anothe rin teh same category
15:42:44 <FMota> the obvious thing is:   a ^ 0 = 1;  a ^ suc b = (a ^ b) * a
15:43:27 <FMota> for infinity on the left-side of ^, it's fine
15:43:36 <yitz> No, an arrow is part of the definition of the category itself. But a functor specifies maps from objects of one category to another.
15:43:40 <dmwit> FMota: What's 1 ^ \infty? ;-)
15:43:44 <sioraiocht> yitz: thanks
15:43:48 <FMota> but it doesn't work for right-side infinity
15:44:02 <sioraiocht> what are arrows in Rng?
15:44:25 <sioraiocht> nevermind
15:44:27 <FMota> dmwit: that's a point :)
15:44:32 <sioraiocht> i woudl guss ring homomorphisms
15:44:41 <yitz> Yup
15:44:56 <FMota> although, you'd think that logically 2 ^ inf = inf
15:45:08 <FMota> while that's not ... exactly true in some cases
15:45:14 <FMota> like this one.
15:45:21 <hpaste>  etnt' annotated "use of a Monad" with "updateStep" at http://hpaste.org/3163#a3
15:45:35 <ddarius> A functor is an arrow in the category of categories.
15:45:41 <etnt`> dmwit: what do you think?
15:46:05 <dmwit> Great, the idea is right!
15:46:06 <yitz> Great!
15:46:12 <ac> FMota: and how about .5 ^ infinity? Perhaps there is a logical reason why it's not easy to define
15:46:22 <dmwit> If you want to be consistent with the previous thing, make sure the "i" is odd first, but other than that, very nice.
15:46:24 <etnt`> he he, I'm getting the hang on it..perhaps..
15:46:27 <FMota> ac: working only with naturals here
15:46:35 <ac> FMota: oh duh
15:46:38 <FMota> although yeah, I guess that's part of it.
15:46:41 <yitz> FMota: what is 0 ^ infinity?
15:46:46 <dmwit> 1
15:46:55 <FMota> 0 ^ infinity = 0
15:47:00 <FMota> ... I'd say.
15:47:05 <FMota> :)(
15:47:08 <FMota> *:)
15:47:11 <yitz> It's undefined, really.
15:47:21 <yitz> Like 0/0
15:47:28 <sarehu> well x ^ infinity for |x| < 1 converges to zero
15:47:32 <dmwit> http://cale.yi.org/index.php/Open_letter_to_James_Anderson
15:47:34 <sarehu> it's not like 0/0
15:47:34 <EvilTerran> i'd go for zero
15:47:36 <lambdabot> Title: Open letter to James Anderson - CaleWiki
15:47:40 <FMota> I can see why 0 * infinity would be undefined, but 0 ^ infinity is 0
15:47:54 <dmwit> Oh, whoops, that's 0^0, not 0^infinity.
15:48:02 <ac> what's a pretty version of "not $ (==) x y"?
15:48:03 <dmwit> Never mind, I'm happy with 0^infinity = 0.
15:48:07 <FMota> 0^0 is undefined.
15:48:10 <sarehu> ac: x /= y
15:48:13 <dmwit> ac: (/=) ?
15:48:23 <FMota> although it'd obviously be 1 with my definition.
15:48:30 <ac> ah. I was searching for !== and !=
15:48:44 <sarehu> 0^0 is undefined unless the zero in the exponent is integer-esque :)
15:48:45 <yitz> lim x->0 of x^infinity is infinity, not zero.
15:48:52 <dmwit> ac: If you squint, it looks like there's a slash through the equals sign, just like in math. =P
15:49:05 <dmwit> yitz: What??
15:49:24 <yitz> Uh - oh, right.
15:49:30 <ac> yitz: that _must_ be 0
15:49:40 <dmwit> yitz: I think that limit is undefined.
15:49:46 <ac> (or undefined)
15:49:55 <dmwit> (Remember it must approach the given value from both the positive and negative sides...)
15:50:23 <FMota> yitz: huh? lim x -> k of x ^ infinity = 0 for |k| < 1
15:50:25 <sarehu> x^infinity = 0 forall |x| < 1.  So lim x->0 of x^infinity = 0.
15:50:49 <dmwit> Oh, right, infinity is just a shorthand for a limit.  Okay.
15:50:50 <yitz> 0^inf = exp (inf * log 0) = exp (inf * -inf) = exp(-inf) = 0
15:50:58 <_achilles_> anoyne here done the euler project?
15:51:02 <yitz> So how about 1 ^ infinity?
15:51:09 <FMota> the whole thing? I doubt it.
15:51:11 <ddarius> If you guys are going to start using analysis with non-standard arithmetics you're going to have to be more careful and more explicit.
15:51:15 <dmwit> _achilles_: I think several people have worked on it; which one are you up to?
15:51:20 <_achilles_> 11
15:51:25 <_achilles_> the 20x20 box
15:51:32 <EvilTerran> ah, this one goes up to eleven!
15:51:40 <dmwit> ha
15:51:40 <EvilTerran> (sorry)
15:51:41 <_achilles_> I'm trying to learn Haskell along the way
15:52:02 <FMota> yitz: I'd think it would be 1, but idk how the math goes. Although, the horizontal assymptote is 1, so that works.
15:52:08 <yitz> _achilles: I think I posted some comments about that one on haskellwiki.
15:52:09 <sarehu> 1^infinity is semistable, it's "equal" to 1, but some expressions are more equal than others...
15:52:17 <_achilles_> ah.
15:52:19 <_achilles_> mk
15:52:19 <FMota> (horizontal assymptote of  f(x) = 1^x)
15:52:52 <yitz> I think Euler is a great set of examples to learn Haskell with.
15:53:02 * FMota should not be allowed around infinities and zeros.
15:53:02 <dmwit> etnt`: Have you figured out how to use updateStep to accumulate over an entire list?
15:53:11 <_achilles_> so far I've found the previous one's pretty informative
15:53:32 <_achilles_> I've just reached a point where I'm sure monads would come in handy and I'm just not terribly comfortable with them yet
15:53:47 <yitz> lim (x->1+) x^infinity = infinity.  But lim(x->1-) x^infinity = 0.
15:54:02 <_achilles_> which I suppose should force me to learn monads
15:54:15 <etnt`> dmwit: thinking...
15:54:17 <_achilles_> but I'm just antsy to see everyone elses solution ;)
15:54:45 <dmwit> _achilles_: I don't think I used monads in any of the first 20.
15:54:48 <EvilTerran> huh. i didn't use monads for 11.
15:54:48 <dmwit> (I got bored after that.)
15:54:48 <FMota> yitz: yes, and lim (y -> inf) 1 ^ y = 1
15:54:53 <_achilles_> really....
15:54:59 <_achilles_> hmmm
15:55:09 <EvilTerran> which monad are you thinking of?
15:55:23 <_achilles_> shrug
15:55:38 <_achilles_> seems like just using list to chug out all the possible maxs
15:55:46 <EvilTerran> i figure, it's easy to find the best answer only looking at horizontal lines, vertical's pretty easy too
15:55:50 <_achilles_> s/maxes/products
15:55:55 <nornagon> genObjectNames :: Int -> IO [a] -- [a]?
15:55:55 <EvilTerran> (see "transpose")
15:55:56 <dmwit> Yes, I didn't even import Control.Monad, and almost nothing with monads is easy without that.
15:55:56 <_achilles_> right
15:56:28 <nornagon> also, how come there's no genTextures function in HOpenGL?
15:56:41 <anr> ya haskell newbie w/ an indentation question
15:56:46 <EvilTerran> the only horrible bit i can't decipher offhand is how i converted my list-of-rows into a list-of-diagonals going each way
15:56:56 <_achilles_> hah
15:56:57 <_achilles_> yeah
15:57:02 * Beelsebob_ wonders why darcs asked for his password 15 times to get a repository from an ssh server
15:57:02 <dmwit> anr: hpaste?
15:57:14 <LoganCapaldo> Beelsebob_: poor memory?
15:57:15 <_achilles_> that's where I thought maybe a "State" monad could be helpful
15:57:20 <EvilTerran> because, once you've got that, it's pretty easy!
15:57:23 <_achilles_> or I support I could brute force it
15:57:23 <anr> I'm using emacs, how do I keep the "where" keyword on the RHS?
15:57:41 <Beelsebob_> LoganCapaldo: somewhat odd though :/
15:57:44 <_achilles_> suppose*
15:57:44 <Beelsebob_> and very disconcerting
15:57:47 <_achilles_> sheesh, can't type
15:57:57 <yitz> _achilles_: you don't _need_ monads to solve problems like these, in my opinion. I use them _all_ the time - but I use them to make code more maintainable, not to make problem solving easier.
15:58:02 <EvilTerran> state? sounds like you're trying to write imperatively...
15:58:09 <LoganCapaldo> less disconcerting than it not asking for your password at all
15:58:23 <EvilTerran> or absent-midedly tab-completing your password
15:58:25 <sioraiocht> [23:56] pete83: MuHAHAHA
15:58:25 <sioraiocht> [23:56] pete83: I knew trolling would get me the best help!
15:58:25 <sioraiocht> [23:56] pete83: Latex is awesome!
15:58:25 <sioraiocht> [23:56] sioraiocht: *rolls eyes* did that work?
15:58:25 <sioraiocht> [23:56] pete83: thanks sioraiocht!
15:58:25 <sioraiocht> [23:56] sioraiocht: np...
15:58:26 <dmwit> _achilles_: If you know concatMap, then you know the list monad.
15:58:27 <sioraiocht> [23:56] pete83: You're brilliant!
15:58:29 <sioraiocht> what's wrongt with that picture?
15:58:32 <ddarius> LoganCapaldo: That would be kind of cool.
15:58:37 <Beelsebob_> LoganCapaldo: true, but 15 times makes me think "omg, isn't the server gonna revoke my password if I've got it wrong this many times?"
15:58:45 <Beelsebob_> it seemed to ask once per patch
15:58:58 <LoganCapaldo> ddarius: presumably it could with .ssh_keys or whatever that directory is called
15:59:02 <dmwit> sioraiocht: Looks like you helped a troooooll.
15:59:19 <sioraiocht> dmwit: I did, regrettably.
15:59:21 <EvilTerran> "<project> is rubbish, it doesn't let me to <blah>!"
15:59:42 <EvilTerran> <cue all the experts in #project telling you how to do <blah>
15:59:51 <anr> googling for hpaste, haskell-mode just indents where normally
15:59:57 <EvilTerran> @hpaste
15:59:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:00:06 <sioraiocht> well, to be fair, #latex is woefully quite, most of the time
16:00:16 * LoganCapaldo tries EvilTerran's method
16:00:16 <ddarius> Haskell is rubbish, it doesn't Julienne cut my carrots.
16:00:25 <LoganCapaldo> Dammit!
16:00:29 <LoganCapaldo> ddarius beat me too it
16:00:38 <dmwit> You'll need to attach a robot arm to your serial port as step one...
16:00:46 <sioraiocht> ddarius: have you compiled ghc for your blender yet?
16:01:25 <sioraiocht> you'll need to do that, then use Control.Blender.Julienne
16:01:56 <sioraiocht> you can also use Control.FoodProc.Julienne if you have a cuisinart or something else
16:02:14 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3164
16:02:33 <sioraiocht> but you should import them as qualified, they will undoubtedly conflict with the Prelude
16:02:36 <anr> thanks
16:02:36 <yitz> Referential transparancy will make your Julienne cut  carrots come out identically each time.
16:02:49 <sioraiocht> yitz: or perhas as the SAME carrot?
16:02:51 <_achilles_> hmmm
16:02:52 <raxas> dmwit: serial port are lame, my robot is going to have /dev/motivator/leg5/servo3 and so on crafted usb controller
16:03:05 <anr> I'd like "where" to be under the "("
16:03:09 <_achilles_> monads just seem.....powerful, and worth trying to use
16:03:20 <anr> http://hpaste.org/3164
16:03:21 <dmwit> anr: So... put it there?
16:03:25 <EvilTerran> @go you could have invented monads
16:03:29 <anr> by hitting tab
16:03:30 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
16:03:30 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
16:03:31 <_achilles_> perhaps I'm just not familiar enough with them to say
16:03:32 <yitz> Hmm... that makes the carrots less satisfying, but it sure keeps the calorie count down.
16:03:36 <sioraiocht> _achilles_: they arn't the the be all end all, they're just a way you do certain things in functional programming
16:03:50 <_achilles_> fair enough
16:03:52 <dmwit> anr: You'll probably have to hack on the indentation code yourself, then.
16:04:00 <Mr_Awesome> im sort of stuck making a repl. i tried using getContents and parsing an infinite list of print/eval actions, but it never actually prints. is this even a good way to go about it?
16:04:01 <anr> ah, ok
16:04:09 <ddarius> _achilles_: It's preferable to not use monads if the don't clearly offer a benefit.
16:04:29 <dmwit> Mr_Awesome: Have you set the buffering to LineBuffering or NoBuffering or whatever?
16:04:48 <sioraiocht> _achilles_: I've implemented very few monads of my own, the most common uses already exist and if you are useing them for something else you might want to ask yourself why
16:05:01 <EvilTerran> Mr_Awesome, i'd suggest using line-by-line IO instead for that sort of thing. getContents (and suchlike lazy reading)'s a bit dodgey
16:05:20 <sioraiocht> lazy I/O totally messes things ups
16:05:24 <sioraiocht> *up
16:05:36 <Mr_Awesome> EvilTerran: i cant use getLine. i dont want to force the user to type an entire expression on a single line
16:06:10 <EvilTerran> well, how do you know when an expression ends, then?
16:06:40 <Mr_Awesome> only the parsing function knows that
16:06:50 <LoganCapaldo> I don;t think using getLine forces your user to type there expression ona  single line
16:07:06 <EvilTerran> Mr_Awesome, you could try to parse it, and, if it fails, go round again for another line
16:07:26 <EvilTerran> reparse, concat on another line, keep going round and round 'til it parses or the user gives up
16:07:36 <EvilTerran> or whatever. i can't be more helpful without more information.
16:07:52 <Mr_Awesome> but what if the parser fails due to bad syntax
16:08:02 <Mr_Awesome> rather than simply an incomplete expression
16:08:30 <EvilTerran> then you need to rethink your program, i'm afraid.
16:08:41 <EvilTerran> or you could allow people to indicate at the end of a line "i'm not done yet"
16:09:07 <EvilTerran> and then the input-processing functions could strip off that and the newline, and concat on the next line
16:09:08 <ac> what exactly is the difference between "foo :: a -> b -> c" and "foo :: a -> (b -> c)"?
16:09:18 <EvilTerran> i'd suggest \ for such a purpose, like what C does.
16:09:19 <user317> @src foldM
16:09:19 <lambdabot> foldM _ a []     = return a
16:09:19 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
16:09:32 <EvilTerran> ac, absolutely nothing. -> is right-associative.
16:09:33 <liyang> ac: a pair of parentheses.
16:09:34 <yitz> Usually its best to use getLine anyway, and if it failed in the middle of the line, point out where. That way, the user can use readline, etc. More intuitive for the user.
16:09:45 <ac> ah. I thought so
16:10:13 * ac feels silly for having a couple "-> (a -> b)" in his code
16:10:13 <glen_quagmire> given a list and x, how do I get sum of each elements * x ?
16:10:22 <EvilTerran> yitz, that too. i don't really like getContents, hence my "[it]'s a bit dodgey" comment ;)
16:10:27 <glen_quagmire> foldl (+ (* x)) 0 l
16:10:35 <ddarius> sum (map (x*))
16:10:42 <Mr_Awesome> if only getContents worked like i want it to... it would be so perfect and elegant
16:10:46 <ddarius> sorry, sum . map (x*)
16:10:53 <ac> I'm still unlearning scheme and its lack of currying
16:11:05 <EvilTerran> getContents uses unsafePerformIO; its behaviour is undefined ;)
16:11:14 <glen_quagmire> > foldl ((+) . (*2)) 0 [1,2,3]
16:11:19 <lambdabot>  11
16:11:20 <LoganCapaldo> I thought getContents used unsafeInterleaveIO?
16:11:37 <LoganCapaldo> Have I been lied too????
16:11:40 <ddarius> EvilTerran: It's "primitive" and it's behaviour is defined by the Report.
16:11:41 * LoganCapaldo weeps
16:11:50 <ddarius> LoganCapaldo: It does use unsafeInterleaveIO.
16:11:53 <Mr_Awesome> well it isnt interleaving anything. in fact its not letting anything get computed
16:11:55 <dmwit> > foldl (\x y -> x + 2*y) 0 [1,2,3]
16:11:57 <lambdabot>  12
16:12:07 <ddarius> LoganCapaldo: Though you could implement unsafeInterleaveIO with unsafePerformIO.
16:12:10 <ac> if you drop off trailing arguments and add them to an inner lambda expression, it does change the way its compiled, right?
16:12:15 <dmwit> glen_quagmire: But it really is a map first, then a fold, so use ddarius' solution.
16:12:17 <hpaste>  etnt' annotated "use of a Monad" with "sumCount2" at http://hpaste.org/3163#a4
16:12:26 <EvilTerran> i stand corrected, on both counts
16:12:38 <etnt`> dmwit: still some way to go...
16:12:40 <EvilTerran> doesn't mean i have to like it ;)
16:12:43 <dmwit> etnt`: Aha!  Now you've come up to the sequencing bit.
16:12:48 <glen_quagmire> oh i missed ddarius'
16:12:59 <dmwit> (>>) sequences two actions for which you don't care about the "value" part of the first action.
16:13:41 <yitz> ac: not necessarily, it's up to the compiler. Probably shouldn't matter.
16:13:43 <dmwit> etnt`: Also, foldl isn't quite right, because it works on pure functions, not monads.
16:13:56 <ddarius> :t foldM
16:13:56 <dmwit> etnt`: foldM (or its cousin, foldM_) is better here.
16:13:57 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:14:09 <dmwit> etnt`: But "sequence" is even better, I think, in this case:
16:14:11 <dmwit> :t sequence
16:14:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:14:23 <etnt`> dmwit: ok, I'll try it
16:15:07 <yitz> I personally like mapM better here.
16:15:08 <ac> yitz: I guess it would be a simple optimization, because all the compiler would have to do is notice that certain variables do not depend on trailing arguments
16:15:09 <dmwit> etnt`: Actually, I retract that.  You want foldM. =P
16:15:14 <yitz> @type mapM
16:15:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:15:31 <etnt`> dmwit: ok
16:15:41 <pastorn> @src repeat
16:15:41 <lambdabot> repeat x = xs where xs = x : xs
16:15:55 <dmwit> repeat x = x : repeat x
16:16:18 <ac> dmwit: someone a couple days ago said it was defined like that for optimization purposes
16:16:28 <dmwit> Yes, I'm sure it is.
16:16:59 <glen_quagmire> I'm trying to recalculate Float.  toDigits x = let (l,e) = floatToDigits 2 x in sum . map (* (2**e)) l
16:17:19 <ddarius> The Report doesn't specify sharing behaviour, but in practice compilers are unlikely to break any explicit sharing and unlikely to share (important) things that aren't.
16:17:25 <ac> wouldn't it be nice if there was a super verbose mode when compiling that told you about the more interesting optimizations?
16:17:29 <pastorn> what's an easy way to build circular data types?
16:17:31 <glen_quagmire> floatToDigits 2 returns list of 0's and 1's and an exponent
16:17:52 <ddarius> pastorn: You mean circular values?
16:17:56 <pastorn> in C i would've said "pointers"
16:18:07 <glen_quagmire> for each element in the list, I need to do el * 2 ** exponent  .. no i lose
16:18:43 <ddarius> pastorn: There are a variety of ways depending on what you want.
16:19:10 <yitz> @hoogle tying the knot
16:19:11 <lambdabot> Did you mean: Tying The Knot
16:19:11 <lambdabot> Prelude.undefined :: a
16:19:11 <lambdabot> Test.QuickCheck.Batch.bottom :: a
16:19:32 <yitz> @hoogle Tying The Knot
16:19:33 <lambdabot> No matches, try a more general search
16:19:37 <yitz> ha!
16:19:45 <omnId> @GOOgle tying the knot
16:19:45 <lambdabot> Unknown command, try @list
16:19:51 <omnId> bah
16:19:52 <yitz> @go haskell tying the knot
16:19:54 <ddarius> @google "Tying the Knot"
16:19:54 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
16:19:54 <lambdabot> Title: Tying the Knot - HaskellWiki
16:19:57 <lambdabot> http://www.tyingtheknot.net/
16:19:57 <lambdabot> Title: BEBB | Studios
16:20:10 <ddarius> That one is probably wedding related.
16:20:22 <omnId> @go tying the knot dan piponi
16:20:24 <lambdabot> http://www.mail-archive.com/haskell-cafe@haskell.org/msg29006.html
16:20:24 <lambdabot> Title: Re: [Haskell-cafe] "Tying the knot" with unknown keys
16:20:25 <pastorn> ddarius: i have a lot of (Id,[Id]) where the second one points at a lot of possible next elements
16:20:28 <yitz> So is the other one, in some sense.
16:20:52 <sarehu> pastorn: so you have a graph?
16:20:56 <ddarius> pastorn: If the HaWiki TyingTheKnot page was still up that would be a good intro
16:21:06 <ddarius> pastorn: What kinds of things do you want to do?
16:21:20 <omnId> glen_quagmire: maybe you should also zipWith (*) powersOfTwo your list of bits?
16:21:22 <glen_quagmire> How do I do this? [1,0,1,1] ===> 1*2**x + 0*2**(x-1) + 1*2**(x-2) + 1*2**(x-3) ...
16:21:56 <omnId> > zipWith (*) (iterate (*2) 1) [1,0,1,1]
16:22:01 <lambdabot>  [1,0,4,8]
16:22:07 <ddarius> pastorn: Tying the knot is very clean, but it's useless in some cases because you can't tell circular values from infinite ones, i.e. sharing is not observable in Haskell.
16:22:20 <glen_quagmire> > sum . zipWith (*) (iterate (*2) 1) [1,0,1,1]
16:22:21 <lambdabot>  Couldn't match expected type `a -> [a1]'
16:22:21 <sarehu> foldl (((+) .) (*2)) 0 [1,0,1,1]
16:22:21 <yitz> > sum $ zipWith (*) (iterate (*2) 1) [1,0,1,1]
16:22:22 <lambdabot>  13
16:22:43 <sarehu> > foldl (((+) .) (*2)) 0 [1,0,1,1]
16:22:44 <lambdabot>  11
16:22:48 <glen_quagmire> :t iterate
16:22:50 <lambdabot> forall a. (a -> a) -> a -> [a]
16:22:54 <Shimei> Is there a name for a data structure where you have a cell, a reverse list, and a forward list? Seems like a zipper except not for a tree.
16:22:56 <pastorn> ddarius: infinite is not a problem... this is "electric sheep", short mpg-films that are screensavers that are linkable
16:22:57 <omnId> > iterate (*2) 1
16:22:58 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:23:14 <dmwit> Shimei: It's a zipper for a list.
16:23:16 <sarehu> > foldl ((+) . (*2)) 0 [1,0,1,1]
16:23:17 <lambdabot>  11
16:23:42 <dmwit> pastorn: Maybe you want a Data.Map telling where each sheep can go/come from.
16:23:46 <glen_quagmire> > iterate (+1) 0
16:23:47 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:23:51 <Shimei> dmwit: Ah, makes sense. Seems like a common FP tool.
16:23:53 <dmwit> Map Int [Int] or whatever.
16:24:26 <pastorn> hmm... i haven't used Data.Map
16:24:28 <pastorn> yet
16:24:44 <pastorn> you think this seems like a good use of it?
16:24:52 <sarehu> the (iterate (*2) 1) has the values reversed of what the question specified
16:24:54 <dmwit> pastorn: (Actually, unless the format has changed, the electric-sheep file names are rather ill-specified.  They have both a comes-from and a goes-to portion, but only the goes-to portion is meaningful.)
16:25:28 <pastorn> dmwit: or only the comes-from
16:25:28 <omnId> > zipWith (*) (iterate (*2) 1) $ reverse [1,0,1,1]
16:25:30 <lambdabot>  [1,2,0,8]
16:25:30 <dmwit> s/only the goes-to portion/only on of the two portions/
16:25:56 <omnId> sum $ ...
16:26:11 <pastorn> dmwit: since one sheep can be linked to many
16:26:30 <yitz> @let glen ys x = sum $ zipWith (*) (map (2^) ys) $ zipWith subtract [0..] x
16:26:32 <lambdabot> Defined.
16:26:38 <dmwit> pastorn: Right, see my correction.
16:26:56 <yitz> > glen [1,0,1,1] 10
16:26:57 <lambdabot>   add an instance declaration for (Num [a1])
16:28:17 <yitz> @let glen ys x = sum $ zipWith (*) (map (2^) ys) $ zipWith subtract [0..] $ repeat x
16:28:18 <lambdabot> <local>:4:12:     Occurs check: cannot construct the infinite type: a = [a]  ...
16:28:38 <omnId> @undefine
16:28:40 <lambdabot> Undefined.
16:28:41 <omnId> try again
16:28:46 <yitz> @let glen ys x = sum $ zipWith (*) (map (2^) ys) $ zipWith subtract [0..] $ repeat x
16:28:48 <lambdabot> Defined.
16:28:52 <yitz> > glen [1,0,1,1] 10
16:28:54 <lambdabot>  59
16:29:54 <omnId> er, you're just generating [10,9..0] and zipWith (2^)ing that?
16:30:26 <mdmkolbe3> Is there a lazy, infinite set implementation?  Sort of like a lazy list (I only need it for Int), but with lazy list the cost of set difference is in the "size" of the "larger" list, but a good implementation of set difference could do better than that.
16:30:54 <bos> dcoutts_: ping
16:30:56 <dmwit> Dunno, but there's a Data.Set; does it fit your bill?
16:31:00 <bos> @seen dcoutts_
16:31:00 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts_ last spoke.
16:31:02 <bos> hmph
16:31:14 <hpaste>  etnt' annotated "use of a Monad" with "sumCount2 still not there" at http://hpaste.org/3163#a5
16:31:15 <omnId> > zipWith (*) [2^1, 2^0, 2^1, 2^1] [10,9,8,7]
16:31:16 <lambdabot>  [20,9,16,14]
16:31:22 <omnId> > sum $ zipWith (*) [2^1, 2^0, 2^1, 2^1] [10,9,8,7]
16:31:23 <lambdabot>  59
16:31:35 <yitz> @undefine
16:31:36 <lambdabot> Undefined.
16:31:36 <etnt`> dmwit: struggling with that foldM
16:31:58 <glen_quagmire> > > zipWith (\a b -> a * 2**(0-b)) (fst (floatToDigits 2 1e-16)) (iterate (+1) 0)
16:31:58 <lambdabot>   parse error on input `>'
16:32:05 <sarehu> mdmkolbe3: how would you be able to tell if something is an element of the set in finite time?
16:32:07 <glen_quagmire> > zipWith (\a b -> a * 2**(0-b)) (fst (floatToDigits 2 1e-16)) (iterate (+1) 0)
16:32:08 <lambdabot>   add an instance declaration for (Floating Int)
16:32:24 <dmwit> etnt`: One second.
16:32:38 <omnId> @ty floatToDigits
16:32:40 <lambdabot> forall a. (RealFloat a) => Integer -> a -> ([Int], Int)
16:32:49 <omnId> r/**/^/
16:33:03 <glen_quagmire> >2 ^ 2
16:33:08 <omnId> (space)
16:33:13 <omnId> > 2 ^ 2
16:33:14 <lambdabot>  4
16:33:26 <omnId> @ty (^)
16:33:27 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
16:33:34 <mdmkolbe> > findMin (fromList [1..]) -- does not terminate, but I need it too (technically I'm after a heap now that I think of it)
16:33:35 <lambdabot>   Not in scope: `fromList'
16:34:01 <omnId> or map fromIntegral on your list of Ints
16:34:06 <yitz> @let glen ys x = sum $ zipWith (*) ys $ map (\z -> 2^(x-z)) [0..]
16:34:07 <sarehu> mdmkolbe3: so what you really need is some manually specified binary search tree, whose structure you know beforehand
16:34:08 <lambdabot> Defined.
16:34:13 <yitz> > glen [1,0,1,1] 10
16:34:14 <lambdabot>  1408
16:34:15 <glen_quagmire> omnId: I need to do negative exponents
16:34:34 <yitz> @undefine
16:34:35 <lambdabot> Undefined.
16:34:45 <yitz> @let glen ys x = sum $ zipWith (*) ys $ map (\z -> 2**(x-z)) [0..]
16:34:46 <lambdabot> Defined.
16:34:50 <yitz> > glen [1,0,1,1] 10
16:34:52 <lambdabot>  1408.0
16:35:20 <mdmkolbe> sarehu: the sets are on positive ints, so checking for membership is easy if for example the sets are implemented as an ordered list, but the set difference operator for that costs too much
16:35:20 <yitz> > glen [1,0,1,1] 1
16:35:21 <lambdabot>  2.75
16:35:42 <glen_quagmire> yitz: thanks
16:36:11 <omnId> s/map  (\z -> 2**(x-z)) [0..]/iterate (/ 2) (2**x)/
16:36:49 <chessguy> @type iterate (/ 2) (2**?x)
16:36:51 <lambdabot> Not in scope: `**?'
16:36:51 <lambdabot>  
16:36:51 <lambdabot> <interactive>:1:19: Not in scope: `x'
16:37:00 <chessguy> @type iterate (/ 2) (2**(?x))
16:37:02 <lambdabot> forall a. (?x::a, Floating a) => [a]
16:37:13 <glen_quagmire> haskell makes my head go crazy. in a good way
16:37:13 <omnId> > iterate (/2) (2**10)
16:37:14 <lambdabot>  [1024.0,512.0,256.0,128.0,64.0,32.0,16.0,8.0,4.0,2.0,1.0,0.5,0.25,0.125,6.25...
16:37:19 <sarehu> mdmkolbe: findMin still won't terminate unless the infinite stream you're using to feed the set contains the minimum possible element
16:37:31 <chessguy> oh, duh
16:37:44 * chessguy smacks himself
16:38:11 <mdmkolbe> sarehu: ah, yes, I see.  Ok, then how do I make an infinite set without using fromList?
16:38:21 <omnId> it seems simpler to reverse the digits and multiply by the ascending powers of two.
16:38:23 <sarehu> mdmkolbe: if you know your input is coming presorted, you could do something
16:39:00 <glen_quagmire> I think I need a list of [1/2^1, 1/2^2, 1/2^3, ...]
16:39:21 <mdmkolbe> sarehu: if the set implementation knew that yes.  Does the set implementation have any other ways to generate the infinite set with a working findMin
16:39:24 <mdmkolbe> ?
16:39:27 <sarehu> mdmkolbe: a list of sets that cover the intervals [1,2), [2,4), [4,8), [8,16), ...
16:39:34 <omnId> glen_quagmire: map recip?
16:39:47 <yitz> Check  whether repeated (2**) or repeated (/ 2) has better precision behavior for your app.
16:39:52 <dmwit> etnt`: Okay, I'm with you now; what's up?
16:40:00 <omnId> wait, is that 1/(2^x)?
16:40:04 <glen_quagmire> 1/2^1  is this better than 2**(-1) ?
16:40:13 <omnId> or (1/2)^x?
16:40:21 <glen_quagmire> 1/(2^x) omnId
16:40:38 <omnId> dunno which is better
16:40:48 <dmwit> It depends what you want.
16:40:49 <yitz> > 2^(-3)
16:40:51 <dmwit> :t (^)
16:40:51 <lambdabot>  Exception: Prelude.^: negative exponent
16:40:52 <dmwit> :t (**)
16:40:52 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
16:40:54 <lambdabot> forall a. (Floating a) => a -> a -> a
16:40:55 <dmwit> :t (^^)
16:40:57 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
16:41:01 <yitz> > 2**(-3)
16:41:02 <lambdabot>  0.125
16:41:13 <glen_quagmire> > 1/2^(-3)
16:41:14 <dmwit> > 2^^(-3)
16:41:14 <lambdabot>  Exception: Prelude.^: negative exponent
16:41:14 <etnt`> dmwit: I can't get that foldM right
16:41:15 <lambdabot>  0.125
16:41:23 <glen_quagmire> > 1/2^(3)
16:41:24 <sarehu> mdmkolbe: this would give you linear time cost the first time you evaluate the thunk (with respect to the input parameter n), with logarithmic time for future lookups
16:41:24 <lambdabot>  0.125
16:41:24 <dmwit> > 2^^(-3)::Ratio
16:41:25 <lambdabot>      `Ratio' is not applied to enough type arguments
16:41:25 <lambdabot>     Expected kind `?', b...
16:41:28 <omnId> dmwit: glen's taking a list of digits and reconstructing a Floating.  He'll need (**)
16:41:29 <dmwit> > 2^^(-3)::Rational
16:41:31 <lambdabot>  1%8
16:42:01 <dmwit> etnt`: aha
16:42:13 <dmwit> etnt`: What have you tried?
16:42:58 <etnt`> dmwit: all sort of thing, feels like the type is wrong to foldl's first argument
16:43:05 <glen_quagmire> > iterate (\x -> 2**(0-x)) 0
16:43:06 <lambdabot>  [0.0,1.0,0.5,0.7071067811865476,0.6125473265360659,0.6540408600420695,0.6354...
16:43:10 <dmwit> :t foldM
16:43:12 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:43:19 <dmwit> etnt`: You may be right.
16:43:23 <etnt`> dmwit: sorry foldM
16:43:31 <dmwit> etnt`: What type would you wish for instead?
16:44:26 <omnId> glen_quagmire: that's 2**(0-previousResult).  I don't think you want that :)
16:44:26 <gwern> so I have here a darcs repo which includes a hsc file but not the hs file it generates, and the cabal file doesn't handle .hsc since the ghc-options: field sets ghc options. what should one do in this situaiton
16:44:27 <etnt`> dmwit: (a -> b -> m a)
16:44:44 <etnt`> dmwit: as the first argument
16:44:49 <glen_quagmire> omnId: yup just checked it from zvon.org
16:45:13 <glen_quagmire> i'm not sure where I can check semantics of built in functions
16:45:23 <glen_quagmire> like, python docstring thingy
16:45:33 <omnId> @docs Prelude
16:45:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
16:45:38 <glen_quagmire> so I just google
16:45:43 <mdmkolbe> sarehu: I like it.  It sounds like the same trick that length doubling vectors use
16:45:44 <dmwit> :t mapM
16:45:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:45:56 <glen_quagmire> @docs iterate
16:45:57 <lambdabot> iterate not available
16:46:01 <chessguy> i wonder if it would be possible to write a generalized REPL
16:46:06 <omnId>  @docs takes a module
16:46:07 <dmwit> etnt`: Is mapM closer to what you want?
16:46:11 <omnId> @index iterate
16:46:11 <lambdabot> Data.List, Prelude
16:46:33 <dmwit> :t mapM_
16:46:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:47:07 <omnId> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Aiterate
16:47:08 <lambdabot> http://tinyurl.com/ovjef
16:47:11 <etnt`> dmwit: hm...but I would like to reduce the list I guess, to (sum,len) i.e the state
16:47:43 <dmwit> etnt`: Yes, but the state changes are all encapsulated in the final monad that's returned.
16:48:05 <glen_quagmire> > map (\x y -> y * 1/(2^(-x)) [0..] (fst (floatToDigits 2 1e-16))
16:48:06 <lambdabot>  Unbalanced parenthesis
16:48:09 <dmwit> etnt`: Remember, there's a "state" and a monad "value"... we are trying to get the "state" to be (sum, len), and we don't care about the "value".
16:48:16 <glen_quagmire> > map (\x y -> y * 1/(2^(-x))) [0..] (fst (floatToDigits 2 1e-16))
16:48:17 <etnt`> dmwit: ok, I see
16:48:17 <lambdabot>  Couldn't match expected type `[Int] -> t'
16:48:26 * etnt` thinking again...
16:48:55 <omnId> glen_quagmire: you want zipWith to apply a function to two lists
16:49:35 <glen_quagmire> > zipWith (*) (map (\x -> 1/(2^(-x))) [0..]) (fst (floatToDigits 2 1e-16))
16:49:35 <lambdabot>   add an instance declaration for (Fractional Int)
16:49:36 <lambdabot>     In the expression: 1 /...
16:50:32 <omnId> > zipWith (*) (map (\x -> 1/(2^(-x))) [0..]) (map fromIntegral . fst $ floatToDigits 2 1e-16) -- floatToDigits produces Int digits
16:50:35 <lambdabot>  Exception: Prelude.^: negative exponent
16:50:54 <omnId> > zipWith (*) (map (\x -> 1/(2**(-x))) [0..]) (map fromIntegral . fst $ floatToDigits 2 1e-16) -- and (**) is for floats
16:50:55 <etnt`> dmwit: but how do I get in the init-state if using mapM ?
16:50:55 <lambdabot>  [1.0,2.0,4.0,0.0,0.0,32.0,64.0,0.0,256.0,0.0,0.0,2048.0,0.0,8192.0,0.0,32768...
16:51:24 <dmwit> etnt`: You don't!  The resulting computation will affect whatever state happens to be in the monad at the time.
16:51:49 <glen_quagmire> > zipWith (*) (map (\x ->(2**(-x))) [0..]) (map fromIntegral . fst $ floatToDigits 2 1e-16)
16:51:50 <lambdabot>  [1.0,0.5,0.25,0.0,0.0,3.125e-2,1.5625e-2,0.0,3.90625e-3,0.0,0.0,4.8828125e-4...
16:51:50 <dmwit> etnt`: Later, you'll have to do something like (initialize >> mapM_ ...) to get that initial state to make sense.
16:52:02 <glen_quagmire> > sum $ zipWith (*) (map (\x ->(2**(-x))) [0..]) (map fromIntegral . fst $ floatToDigits 2 1e-16)
16:52:03 <lambdabot>  1.8014398509481984
16:52:09 <etnt`> dmwit: aha
16:52:21 <chessguy> @hoogle Monad m => (a -> Bool) -> m a -> (a -> m ()) -> m ()
16:52:21 <lambdabot> No matches, try a more general search
16:53:19 <glen_quagmire> what does fromIntegral do?
16:53:29 <chessguy> @type fromIntegral
16:53:31 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:53:38 <glen_quagmire> general coercion from integral types  ??
16:53:42 <chessguy> bingo
16:53:50 <glen_quagmire> but what does that mean?
16:54:02 <chessguy> @type fromIntegral 2
16:54:04 <lambdabot> forall b. (Num b) => b
16:54:18 <chessguy> @type fromIntegral (2::Int)
16:54:20 <lambdabot> forall b. (Num b) => b
16:54:32 <glen_quagmire> > sum $ zipWith (*) (map (\x ->(2**(-x))) [0..]) ( fst ( floatToDigits 2 1e-16))
16:54:33 <lambdabot>   add an instance declaration for (Floating Int)
16:54:33 <lambdabot>     In the expression: (2 **...
16:56:05 <EvilTerran> ugh... i can never understand how anyone using ruby could possibly be happy with writing { |x| x.foo ... }
16:56:25 <omnId> > let fr = fromIntegral; f (ds, e) = sum $ zipWith (*) (iterate (/2) (2**fr e)) $ reverse $ map fr ds in f (floatToDigits 2 11)
16:56:27 <lambdabot>  26.0
16:57:48 <omnId> > let fr = fromIntegral; f (ds, e) = sum $ zipWith (*) (iterate (/2) (2**(fr e - 1))) $ map fr ds in f (floatToDigits 2 2983)
16:57:50 <lambdabot>  2983.0
16:57:50 <EvilTerran> what's the deal with ruby's |...| syntax, anyway? as far as i can tell, it's got no etymology in maths or programming
16:57:59 <sarehu> Smalltalk?
16:58:05 <ddarius> What sarehu said.
16:58:47 <omnId> @let digitsToFloat (ds, e) = sum $ zipWith (*) (iterate (/2) (2**(fromIntegral e - 1))) $ map fromIntegral ds
16:58:51 <lambdabot> Defined.
16:58:58 <gwern> so, does anyone know how to get .hsc files working with cabal?
16:59:11 <omnId> > digitsToFloat (floatToDigits 2 9280)
16:59:12 <lambdabot>  9280.0
16:59:23 <sjanssen> gwern: they should just work
16:59:33 <sjanssen> gwern: what goes wrong?
16:59:44 <gwern> sjanssen: it's strange, but with Andrea's xmonad-util repo, it's not
16:59:51 <gwern> the hs file is never generated from the hs
16:59:54 <EvilTerran> oh, okay
16:59:57 <omnId> @index floatToDigits
16:59:57 <lambdabot> Numeric
17:00:03 <omnId> @docs Numeric
17:00:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
17:00:14 <gwern> hsc is detected by cabal, i can manually convert it - the file just isn't being run through hsc2hs
17:00:46 <gwern> I'm jiggling cabal options, but nothing has clicked yet
17:00:48 <glen_quagmire> > digitsToFloat 0.1
17:00:48 <lambdabot>   add an instance declaration for (Fractional ([a], t))
17:00:49 <EvilTerran> although it seems to have a rather different meaning in smalltalk
17:01:07 <glen_quagmire> > digitsToFloat (0.1, 2)
17:01:08 <lambdabot>   add an instance declaration for (Fractional [a])
17:01:08 <lambdabot>     In the expression: 0.1
17:01:08 <sjanssen> gwern: the repository builds cleanly for me
17:01:10 <gwern> 'Setup: Hslock.hs doesn't exist
17:01:14 <SamB_XP> "[|x y z| x foo: y andBar: z]" looks better, doesn't it?
17:01:23 <omnId> @ty L.digitsToFloat
17:01:24 <lambdabot> Couldn't find qualified module.
17:01:38 <omnId> Floating a => ([Int], Int) -> a
17:01:42 <sjanssen> gwern: this is with a clean repository?
17:02:10 <gwern> sjanssen: I've darcs sent all the patches I made, if that's what you mean
17:02:21 <omnId> > show (typeOf digitsToFloat)
17:02:22 <lambdabot>  "([Integer],Integer) -> Double"
17:02:41 <glen_quagmire> > iterate (-1) -1
17:02:42 <lambdabot>   add an instance declaration for (Num (a -> a))
17:02:44 <sjanssen> gwern: so there's a chance that you've got patches in your repo that I don't
17:02:45 <glen_quagmire> > iterate (-1) (-1)
17:02:46 <lambdabot>   add an instance declaration for (Num (a -> a))
17:02:47 <dmwit> :t typeOf
17:02:49 <lambdabot> forall a. (Typeable a) => a -> TypeRep
17:02:51 <SamB_XP> > digitsToFloat
17:02:52 <lambdabot>  <([Integer],Integer) -> Double>
17:02:58 <glen_quagmire> > iterate (\x -> x - 1) (-1)
17:02:59 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
17:03:14 <dmwit> > [-1,-2..]
17:03:15 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
17:03:26 <chessguy> @pl \x -> x - 1
17:03:26 <lambdabot> subtract 1
17:03:29 <glen_quagmire> map (\x -> 2**x) iterate (\x -> x - 1) (-1)
17:03:31 <omnId> > enumFromThen (-1) (-2)
17:03:32 <gwern> well, it can't be the patches. I just deleted it and got a new one, and I still see ' Linking dist/build/hxput/hxput ...
17:03:33 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
17:03:35 <gwern> Setup : Hslock.hs doesn't exist
17:03:35 <sarehu> > iterate pred (-1)
17:03:36 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
17:03:37 <hpaste>  etnt' annotated "use of a Monad" with "almost there..." at http://hpaste.org/3163#a6
17:03:43 <chessguy> @pl \x -> 2**x
17:03:43 <lambdabot> (2 **)
17:04:05 <glen_quagmire> map (2**) $ iterate (\x -> x - 1) (-1)
17:04:13 <etnt`> dmwit: how do I get out the values from the State ?
17:04:14 <dmwit> :t get -- for etnt`
17:04:15 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
17:04:28 <omnId> do val <- get ; ...
17:04:32 <glen_quagmire> did I crash lambdabot ?
17:04:33 <dmwit> etnt`: That makes the "value" of the monad equal to the "state" of the monad.
17:04:37 <glen_quagmire> oh forgot >
17:04:38 <dmwit> :t runState
17:04:40 <lambdabot> forall s a. State s a -> s -> (a, s)
17:04:49 <glen_quagmire> > map (2**) iterate (\x -> x - 1) (-1)
17:04:50 <lambdabot>  Couldn't match expected type `[t]'
17:04:53 <yitz> @type execState
17:04:54 <lambdabot> forall s a. State s a -> s -> s
17:04:58 <glen_quagmire> > map (2**) (iterate (\x -> x - 1) (-1))
17:05:00 <lambdabot>  [0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.953125e-3,...
17:05:14 <dmwit> etnt`: See also yitz' suggestion of execState. =)
17:05:18 <omnId> glen_quagmire: [-1, -2 ..] is simpler
17:05:28 <yitz> execState runs the monad, throws away the "result", and returns the final value of the state.
17:05:29 <omnId> than iterate ...
17:05:57 <glen_quagmire> > zipWith (*) (map (2**) [-1, -2 ..]) (fst (floatToDigits 2 1e-16))
17:05:58 <lambdabot>   add an instance declaration for (Floating Int)
17:06:01 <ac> how do I make a counter in a function that increments with each call?
17:06:03 <etnt`> dmwit,yitz: ok
17:06:29 <bos> ac: you don't.
17:06:44 <glen_quagmire> > zipWith (*) (map (2**) [-1, -2 ..]) (map (fromIntegral . fst) (floatToDigits 2 1e-16))
17:06:44 <lambdabot>  Couldn't match expected type `[(a, b)]'
17:06:55 <glen_quagmire> > zipWith (*) (map (2**) [-1, -2 ..]) (map (fromIntegral . fst) $ floatToDigits 2 1e-16)
17:06:56 <lambdabot>  Couldn't match expected type `[(a, b)]'
17:07:20 <omnId> glen_quagmire: the fst goes on the pair, the map goes on the digits extracted via fst
17:07:22 <ac> bos: why not? It is the easiest solution in this case. I'm sure it's possible, I just don't know how
17:07:45 <omnId> map fromIntegral (fst (...))
17:07:50 <pjd> ac: explain the problem, perhaps
17:08:08 <sjanssen> gwern: what's the output of build --verbose?
17:08:29 <glen_quagmire> > zipWith (*) (map (2**) [-1, -2 ..]) (map fromIntegral (fst floatToDigits 2 1e-16))
17:08:30 <lambdabot>  Couldn't match expected type `(a, b)'
17:08:38 <ac> ok, there's this function called "idleAdd" in gtk2hs that takes a function that's called whenever the gtk main loop is idle. I want this function to update a pixel buffer with the current frame of an animation
17:08:58 <glen_quagmire> I can't understand whatn fromIntegral does
17:09:07 <omnId> > zipWith (*) (map (2**) [-1, -2 ..]) (map fromIntegral (fst (floatToDigits 2 1e-16))) -- fst's argument needs parens
17:09:07 <pjd> ac: look at the time instead
17:09:09 <lambdabot>  [0.5,0.25,0.125,0.0,0.0,1.5625e-2,7.8125e-3,0.0,1.953125e-3,0.0,0.0,2.441406...
17:09:12 <pjd> at a guess
17:09:36 <pjd> a counter is not a good way to keep track of frames
17:09:36 <bos> ac: idleAdd runs in the IO monad, so you can do what you want, but it's probably the wrong approach
17:09:37 <glen_quagmire> hoa thanks omnId
17:09:45 <ac> pjd: I'm retrieving the current frame from an arry with an integer index
17:09:48 <omnId> > zipWith (*) (map (2**) [-1, -2 ..]) $ map fromIntegral $ fst $ floatToDigits 2 1e-16 -- ($) is good for reducing them
17:09:50 <lambdabot>  [0.5,0.25,0.125,0.0,0.0,1.5625e-2,7.8125e-3,0.0,1.953125e-3,0.0,0.0,2.441406...
17:10:18 <pjd> ac: you can work out the index from the time
17:10:26 <ac> pjd: that's a pointless hack
17:10:26 <chessguy> so i'm thinking about going through the "write yourself a scheme in 48 hours", separating the lisp-specific stuff from the lisp-specific, and packaging the rest into a generalized module. anybody think this would be useful?
17:10:36 <pjd> ac: no, it's the right way to do it
17:10:50 <bos> ac: there's no guarantee that an animation will run on a meaningful schedule if you just get called whenever gtk thinks it's idle.
17:11:02 <pjd> otherwise your animation speed will be completely framerate-dependent
17:11:09 <bos> ac: you want gtk to call you at a regular interval, not just whenever it feels like it.
17:11:17 <omnId> anyway, this function should do what you want: digitsToFloat (ds, e) = sum $ zipWith (*) (iterate (/2) (2**(fromIntegral e - 1))) $ map fromIntegral ds
17:11:24 <ac> bos: that's true, but in this case I don't care if the animation is jerky. I want to see each frame
17:11:58 <bos> ac: there's no guarantee you'll see every frame, either.
17:12:00 <pjd> ac: take it from the time anyway; it will be less code than maintaining a counter of your own
17:12:01 <yitz> ac: if the frame number really is gui state, then save it in a gui variable, or an IORef.
17:12:52 <ac> hmm. if it's simpler to base it off time, I'll do that in the long run, because that is the correct solution if you're doing an animation. But I'm also curious how a counter would be implemented
17:13:16 <bos> ac: using an IORef
17:13:36 <omnId> I'd personally extract the powers part into a local name
17:14:06 <omnId> digitsToFloat ... = sum $ zipWith (*) powers $ map fromIntegral ds where powers = ...
17:14:07 <chessguy> ok, i guess i'm going to just get lost in the flood tonight
17:14:42 <omnId> that's a clear definition
17:14:43 <byorgey> chessguy: what exactly would the non-scheme-specific stuff be for?
17:14:53 <byorgey> chessguy: general combinators for writing an interpreter?
17:15:08 <etnt`> dmwit: and yitz thanks a lot for your help, I'm not quite finished but need to get some sleep... :-)
17:15:16 <chessguy> byorgey, yes, a generalized REPL, with state, error-handling, etc.
17:15:20 <dmwit> etnt`: Okay, sleep well!  And good luck. =)
17:15:32 <chessguy> you would just apply your grammar and semantics
17:15:39 <chessguy> more or less
17:15:40 <yitz> etnt': bye.
17:15:42 <byorgey> chessguy: I think that could be pretty neat.
17:16:03 <chessguy> i'm not sure if it would be combinators or just a library
17:16:32 <byorgey> oh, I see what you're saying
17:16:52 <byorgey> yeah, that would be cool. =)
17:17:18 <chessguy> good, as long as someone thinks i'm not nuts :)
17:17:20 <ac> chessguy: a friend of mine is also doing this in Haskell, but it's still in its fetal stages
17:17:52 <Philippa_> I'm slowly doing something related
17:18:08 <Philippa_> though it's not aiming to be fully generic
17:18:09 <chessguy> i'd say my ideas aren't even fetal yet. it was conceived like an hour ago
17:18:35 <bos> iow, your ideas are still lying in bed with rumpled sheets, smoking a cigarette
17:18:45 <hpaste>  ramza3 pasted "Is this wrong?" at http://hpaste.org/3165
17:18:56 <SamB_XP> no, no, you aren't allowed to smoke until 18 in the states
17:18:58 <chessguy> wow, i wasn't going to take the metaphor quite that far
17:19:04 <ramza3> I am getting parse input error with that code, anybody see what I am doing
17:19:12 <chessguy> bos, what do you think of the idea?
17:19:13 <SamB_XP> certainly not before conception
17:19:21 <hpaste>  ra pasted "(no title)" at http://hpaste.org/3166
17:19:32 <ramza3> oops, that last one is the right/wrong one
17:19:59 <mauke> where's the =?
17:20:26 <ramza3> no-where
17:21:06 <dmwit> ramza3: Give that action a name, and you'll be fine.
17:21:17 <dmwit> i.e. actionName = preservingMatrix $ do ...
17:21:45 <dmwit> ramza3: Although you'll have to get the "mech" variable from somewhere.
17:21:54 <dmwit> So maybe "actionName mech = ...".
17:23:40 <ramza3> dmwit actionName mech = preservingMatrix $ do  .... where  ... I am still getting a parse input error at "="
17:25:43 <dmwit> ramza3: Which =?
17:26:12 <ramza3> actionRotMech mech = preservingMatrix $ do ...  that one
17:26:36 <dmwit> ramza3: Then you have an error earlier in the file.
17:26:49 <dmwit> Look for unbalanced parens or so.
17:27:46 <ramza3> dmwit, it is within a function "do"?  would that matter? eg,  func abc = do ... actionRotMech mech = preservingMatrix $ do ...
17:28:01 <dmwit> ...
17:28:23 <dmwit> Okay, then my first advice (naming the function) was totally off base.
17:28:35 <dmwit> Can we have a bit more context?
17:28:54 <hpaste>  ramza3 pasted "(no title)" at http://hpaste.org/3167
17:29:38 <dmwit> And before you added the (actionRotMech mech =) bit, what was the error?
17:30:08 <ramza3> cant remember, this is the error I have now;  parse error on input `=
17:30:38 <dmwit> Yeah, take away the (actionRotMech mech =) bit; I didn't realize it was in the middle of a do block when I suggested that.
17:31:43 <ramza3> dmwit, hmm, parse error on input preservingMatrix
17:32:03 <ramza3> I think need a anonymous function
17:32:58 <dmwit> Well, I don't know much about the OpenGL libraries, but most of the *syntax* looks okay.
17:33:14 <dmwit> Do you mean readIORef rather than get when finding "mech" and "angleRot" at the top?
17:33:47 <ramza3> the code works, I tried it both ways
17:34:01 <omnId> which "get" are they?
17:34:39 <ramza3> dmwit, I did this,  let (xrot,yrot,zrot) = mechRot mech  ... and the preservingMatrix. I didnt want to do that, but I did
17:38:41 <dmwit> You do not actually use xrot, yrot, zrot; do you need to do that at all?
17:39:33 <ramza3> I did
17:47:49 <Zao> Ooh, someone else using OpenGL in Haskell.
17:47:51 <Zao> Great fun :)
17:51:28 <pastorn> @type flip
17:51:30 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
17:51:43 <pastorn> @type flip map
17:51:45 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
17:52:01 <pastorn> @type flip (:)
17:52:02 <lambdabot> forall a. [a] -> a -> [a]
17:57:55 <Tela> I'm wondering how idiomatic this code I wrote is... What I could do to improve it (besides using MonadRandom which I just discovered :)
17:57:59 <hpaste>  Tela annotated "Haskell Quiz 76: Word Munger" with "Haskell Quiz #76" at http://hpaste.org/3161#a2
18:02:06 <allbery_b> aieee, I've created a monster!
18:04:52 <dmwit> Tela: All your stateful code is mixed up with all your IO code.
18:05:00 <dmwit> That's not really necessary for this problem, is it?
18:05:27 <kpreid> dmwit: er, is it? I see only the getLine loop
18:05:34 <kpreid> note the inner runState
18:05:43 <Tela> I tried to bring the StdGen state up into loop so that each line would be mangled uniquely
18:06:08 <Tela> But that's as close as it gets
18:06:56 <Tela> Although, I feel like there should be a cleaner way to change the State monad to the StateT transformer. Perhaps not, though.
18:07:38 <kpreid> Tela: in mungeWord and loop, instead of get and put, you should use a function like randomST which splits the gen and returns half
18:08:20 <Tela> @type randomST
18:08:22 <lambdabot> Not in scope: `randomST'
18:08:30 <dmwit> I just mean that it's odd that the line-getting logic is mixed up with the munging-logic.
18:08:48 <Tela> Where's randomST at?
18:09:00 <dmwit> It seems much more common to have something like loop :: [String] -> State StdGen [String] or something.
18:09:13 <hpaste>  yitz annotated "Haskell Quiz 76: Word Munger" with "simplified loop" at http://hpaste.org/3161#a3
18:09:37 <kpreid> Tela: in your code
18:10:04 <Tela> Er... Of course :D
18:10:10 <yitz> As an example, I simplified the function loop. I also made the type polymorphic, so that later you can change the monad you are using without changing every function.
18:10:34 <kpreid> Tela: by splitting you don't have to thread the randomgen in *and* out, just in
18:12:25 <Tela> Hmm.. I'm only just now starting to understand how these Monads all work. Could you explain splitting more?
18:13:00 <dmwit> I think splitting is unrelated to monads.
18:13:07 <kpreid> It's a Random thing, not a monad thing
18:13:29 <kpreid> Tela: write exactly the same thing as randomST, but "split" instead of "random"
18:14:04 <kpreid> then, in loop, you do this:
18:14:15 <kpreid> gen <- splitST
18:14:16 <kpreid> let munge = evalState (mungeLine l) gen
18:14:27 <kpreid> @type split
18:14:29 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
18:14:48 <kpreid> split returns two gens which will produce different random sequences.
18:15:50 <Tela> I see, I see.. It just pulls a new generator out for me instead of having to thread a single line of StdGens through. Cool
18:17:45 <kpreid> Tela: why does splitEnds return the last in a list?
18:18:30 <Tela> It was a bit of a hack so that things like splitEnds "It" work without needing to throw Maybe in there, too
18:18:40 <kpreid> ahh.
18:19:00 <kpreid> perhaps you should treat the head the same for "" :)
18:19:40 <Tela> Done and done :)
18:20:16 <kpreid> also, in mungeWord, I'd drop the $ in favor of moving the parens around the sortBy call (and add some whitespace around ++)
18:20:36 <kpreid> return $ [first] ++ map snd (sortBy (comparing fst) randPairs ++ last
18:20:40 <kpreid> er
18:20:44 <kpreid> return $ [first] ++ map snd (sortBy (comparing fst) randPairs) ++ last
18:21:04 <kpreid> also, [x] ++ y is x : y
18:21:18 <kpreid> (but the symmetry may be better)
18:21:45 <Tela> Well, with the head fix on splitEnds, x :: [Char] anyway
18:22:04 <kpreid> ah, right
18:22:53 <kpreid> (my other suggestions regarding that line are independent of the use of : or not, of course)
18:23:40 <Tela> Yeah... It looks much cleaner like that. I still get tripped up by some of the ways you can abuse precedence for clean code.
18:28:40 <kpreid> well, the general rule there is that in `x` (y) `z` where y contains no infix operators itself, you can eliminate the parens. so I tried removing the $
18:30:54 <Tela> kpreid, the splitST idea worked exactly right in mungeWord, but in loop (not Yitz's version, which I'm still working through) it's failing because it's expected to be a StateT. Is there a way around that?
18:30:58 <chessguy> i know i've seen stuff like this before, but i don't remember the purpose: type Foo a = Bar | Baz
18:31:06 <chessguy> where the type parameter is not used on the right
18:31:15 <chessguy> i think the term is phantom type?
18:32:03 <mauke> http://www.haskell.org/haskellwiki/Phantom_type
18:32:04 <lambdabot> Title: Phantom type - HaskellWiki
18:32:25 <Tela> chessguy, It's a phantom type, yeah. I think they're basically used for documentation though
18:33:21 <kpreid> Tela: take the type signature off.
18:33:51 <kpreid> Tela: or change it to reference MonadState instead of State
18:33:56 <kpreid> (the type class)
18:34:35 <Tela> It's spitting kind errors at me now. I suppose it's because I've got strict types in the rest of the program?
18:35:04 <kpreid> no
18:35:06 <kpreid> paste your program again
18:35:36 <hpaste>  Tela annotated "Haskell Quiz 76: Word Munger" with "Using splitST" at http://hpaste.org/3161#a4
18:36:32 <chessguy> hm, for documentation?
18:36:35 <chessguy> i don't get it
18:37:04 <ac> @hoogle Monad a => a b -> (b -> c) -> a c
18:37:04 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
18:37:05 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
18:37:05 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
18:37:12 <Tela> chessguy, the mauke's link explains it better than I understood it. It lets you enforce types just a little more strictly
18:37:34 <mauke> chessguy: think about Ptr a
18:37:44 <mauke> internally, all pointers have the same representation
18:37:45 <chessguy> i'm not familiar with it
18:37:50 <ac> Is there a way to apply a function to something in a monad?
18:37:58 <mauke> ok, do you know IORef? :-)
18:37:58 <dmwit> liftM
18:38:08 <chessguy> vaguely
18:38:45 <ac> :type liftM
18:38:53 <ac> sorry
18:39:00 <chessguy> how about parsec's Parser, would that be a good example?
18:39:03 <mauke> I'm pretty sure all IORefs also have the same internal format
18:39:04 <ac> (that's the problem with sloppy focus)
18:39:24 <mauke> IIRC Parser isn't a phantom type
18:39:32 <mauke> :t liftM
18:39:34 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:39:34 <ac> huh. liftM is basically the exact type signature I hoogled for
18:39:44 <chessguy> all parsers are similar, but "Parser a" must return something of type a
18:39:59 <chessguy> (return in a loose sense)
18:40:03 <mauke> yeah, but the a appears on the RHS of the data declaration
18:40:17 <chessguy> hm
18:40:29 <chessguy> @src IORef
18:40:29 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
18:40:53 <mauke> @src STRef
18:40:54 <lambdabot> data STRef s a = STRef (MutVar# s a)
18:41:02 <mauke> heh
18:41:07 <kpreid> Tela: show the error too
18:41:16 <mauke> @src MutVar#
18:41:17 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:41:17 <ac> @src liftM
18:41:18 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:41:43 <ac> @src (<-)
18:41:43 <lambdabot> Source not found. My pet ferret can type better than you!
18:41:55 <mauke> <- is syntactic sugar for >>= \
18:42:01 <ac> ah right. I knew that
18:42:11 <ac> @src (>>=)
18:42:12 <lambdabot> Source not found. You speak an infinite deal of nothing
18:42:12 <hpaste>  Tela annotated "Haskell Quiz 76: Word Munger" with "The error" at http://hpaste.org/3161#a5
18:42:23 <mauke> @. undo src liftM
18:42:23 <lambdabot> ()
18:42:25 <chessguy> @src Read
18:42:26 <lambdabot> class Read a where
18:42:26 <lambdabot>   readsPrec    :: Int -> ReadS a
18:42:26 <lambdabot>   readList     :: ReadS [a]
18:42:26 <lambdabot>   readPrec     :: ReadPrec a
18:42:26 <lambdabot>   readListPrec :: ReadPrec [a]
18:42:28 <LoganCapaldo> @src Maybe (>>=)
18:42:28 <lambdabot> (Just x) >>= k      = k x
18:42:30 <lambdabot> Nothing  >>= _      = Nothing
18:42:38 <LoganCapaldo> (The source of >>= depends on the Monad)
18:42:40 <mauke> @undo do { x1 <- m1; return (f x1) }
18:42:40 <lambdabot> (m1 >>= \ x1 -> return (f x1))
18:43:13 <chessguy> is there a class like Readable a where fromString :: String -> a
18:43:27 <LoganCapaldo> Isn't that Read?
18:43:33 <mauke> @src Read
18:43:33 <lambdabot> class Read a where
18:43:33 <lambdabot>   readsPrec    :: Int -> ReadS a
18:43:33 <lambdabot>   readList     :: ReadS [a]
18:43:33 <lambdabot>   readPrec     :: ReadPrec a
18:43:33 <lambdabot>   readListPrec :: ReadPrec [a]
18:43:39 <Tela> read :: Read a => String -> a
18:44:14 <LoganCapaldo> @type read
18:44:16 <lambdabot> forall a. (Read a) => String -> a
18:44:22 <mauke> @src read
18:44:22 <lambdabot> read s = either error id (readEither s)
18:44:37 <chessguy> @src readEither
18:44:38 <lambdabot> Source not found. Wrong!  You cheating scum!
18:44:55 * chessguy hangs his head in shame
18:45:17 <mauke> readEither :: (Read a) => String -> Either String a
18:45:21 <LoganCapaldo> chessguy: you're not the first to fail to find the src of readEither :)
18:47:18 <kpreid> Tela: Not sure what's wrong. Put the sigs back. :) I actually meant to take the sig off only splitST.
18:48:53 <Tela> kpreid, ah, here's a more telling error, I think
18:49:13 <hpaste>  Tela annotated "Haskell Quiz 76: Word Munger" with "The better error" at http://hpaste.org/3161#a6
18:50:40 <kpreid> Tela: Ah, you have hit the monomorphism restriction.
18:50:56 <kpreid> Tela: You must include the general type signature for splitST.
18:50:57 <Tela> Ooh, this sounds fun.
18:51:33 <Tela> something like splitST :: MonadState m => m ()?
18:52:29 <Tela> Oh ho. Goody: "The monomorphism restriction is probably the most annoying and controversial feature of Haskell's type system."
18:52:58 <kpreid> MonadState StdGen m => m StdGen StdGen
18:53:11 <kpreid> er, wait, that's wrong
18:53:14 <kpreid> => m StdGen
18:53:28 * allbery_b keeps wondering if there's a less intrusive way to handle the problem the MR is intended to solve
18:53:40 <mauke> {-# OPTIONS_GHC -fno-monomorphism-restriction #-}
18:54:15 <Tela> Is there a quick way to explain MR? Or should I just start reading that hawiki page? :)
18:54:39 <allbery_b> hm?  isn't there a better way to handle the "things become way too polymorphic" issue?
18:57:02 <allbery_b> Tela: in brief (and probably oversimplifying too much):  if yoy have a function of no arguments which produces a polymorphic result (e.g.. foo :: Num a -> a), it's hard for the compiler to restrict the type sanely at compile time
18:57:20 <allbery_b> so all uses end up indirecting through a clas sdictionary when they shouldn't need to
18:57:41 <allbery_b> the MR forces a monomorphic interpretation of the type to avoid this
18:58:43 <allbery_b> (in the example of foo I used, if you don't type it it will end up being an Integer even if it would otherwise be Num a => a)
18:58:44 <Tela> I think I'm beginning to see... I've run into this a few times before and just added a type signature to beat it off. I didn't need a polymorphic result, usually, though.
18:59:14 <allbery_b> given "foo = 3" the type *should* be Num a => a because "3" is a olymorphic constant, but the MR forces it to Integer
18:59:28 <allbery_b> polymorphic constant.  don';t mind my inability to type :)
18:59:52 <allbery_b> because otherwise your "constant" is always a doubly indirect function call
19:00:12 <dmwit> foo = 3 === foo = fromIntegral 3, right?
19:00:17 <dmwit> :t 3
19:00:18 <allbery_b> yes
19:00:19 <lambdabot> forall t. (Num t) => t
19:00:56 <SamB_XP> olymorphism would be good for Tony Hawk
19:01:41 <chessguy> you mean ony Hawk?
19:01:54 <SamB_XP> no, I really meant Tony Hawk
19:02:09 <chessguy> never mind, dumb joke
19:02:27 * allbery_b rolls his eyes
19:02:39 <SamB_XP> yes! because the whole point of it being tony hawk is that it has to do with the word "ollie"
19:02:46 <chessguy> thanks, at least someone detests bad humor :)
19:03:08 <andy_> hi
19:03:15 <chessguy> hi andy_
19:03:17 <dmwit> Hi, andy_!
19:03:30 <chessguy> @losers
19:03:31 <lambdabot> Maximum users seen in #haskell: 420, currently: 359 (85.5%), active: 12 (3.3%)
19:03:31 * dmwit starts a dangerous enthusiasm battle
19:03:39 <andy_> ive got soem trouble installing gtk2hs on ubuntu 7.10
19:03:41 <SamB_XP> I like bad humour, but it should at least make a little sense
19:03:44 <andy_> seems packages are broken
19:04:08 * allbery_b has no clue about Tony Hawk except there's some sports-ish console games using his name
19:04:10 <chessguy> SamB_XP, sorry, it's too late at night for sense
19:04:26 <SamB_XP> chessguy: it's only 10:10...
19:04:45 <SamB_XP> in retrospect, this attitude is probably why I have so much trouble in the mornings...
19:04:47 <chessguy> thanks, all the clocks in my house are broken, i never would have known...
19:05:35 <SamB_XP> actually this one is fast since I had to disable NTP because Windows was messing up on the DST conversion
19:05:40 <monochrom> including the clock on your computer?
19:05:59 <chessguy> i was wondering who was going to point that out :)
19:06:11 <SamB_XP> well, you see, his battery died
19:06:21 <SamB_XP> so he now has to type in the time and date on every boot
19:08:01 <SamB_XP> he also has to say what kind of hard drive he has on every boot
19:08:34 <Korollary> Are there any ICFP videos yet?
19:09:13 <glen_quagmire> hrm I can't still understand why floatToDigits 2 (1e-10 :: Float) returns length 24 list, not 23.
19:09:21 <glen_quagmire> > length (fst (floatToDigits 2 (1e-10 :: Float)))
19:09:23 <lambdabot>  24
19:09:33 <glen_quagmire> Float type should have 23 fractions
19:10:09 <SamB_XP> > isDenormalized (1e-10 :: Float)
19:10:10 <lambdabot>  False
19:10:34 <glen_quagmire> SamB_XP: yah that was my guess. but I can't see exactly why
19:10:49 <SamB_XP> > floatToDigits 2 (1e-10 :: Float)
19:10:50 <lambdabot>  ([1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,1,1,1,1,1,1],-33)
19:10:52 <goalieca> of course 1e-10 is normalized
19:10:57 <glen_quagmire> > isDenormalized (0.5 :: Float)
19:10:58 <lambdabot>  False
19:11:05 <SamB_XP> goalieca: I'm not very good at remembering float range okay?
19:11:16 <glen_quagmire> > isDenormalized (1e-16 :: Float)
19:11:17 <lambdabot>  False
19:11:42 <LoganCapaldo> What is normal really? Who is truly "normal"? We're all different in our own ways
19:11:44 <glen_quagmire> > isDenormalized (1e-45 :: Float)
19:11:45 <lambdabot>  True
19:11:58 <goalieca> here http://steve.hollasch.net/cgindex/coding/ieeefloat.html
19:11:59 <lambdabot> Title: IEEE Standard 754 Floating-Point
19:12:03 <SamB_XP> LoganCapaldo: in terms of types where isIEEE returns true...
19:12:03 <glen_quagmire> > length (fst (floatToDigits 2 (1e-45 :: Float)))
19:12:04 <lambdabot>  1
19:12:09 <SamB_XP> it has a very well-defined meaning
19:12:16 <SamB_XP> otherwise I'm not sure what it means
19:12:40 <chessguy> @undo do { e <- p >>= f b x; return () }
19:12:40 <lambdabot> (p >>= f b x >>= \ e -> return ())
19:12:56 <LoganCapaldo> I think we should rename the function to isASpecialSnowflake
19:13:06 <SamB_XP> glen_quagmire: oh, I got it
19:13:15 <SamB_XP> that first digit was the implicit "1" probably
19:13:56 <SamB_XP> > floatToDigits 2 (1 :: Float)
19:13:58 <lambdabot>  ([1],1)
19:14:22 <glen_quagmire> that means 2^1 * 1 * 2^-1
19:14:24 <monochrom> Take 1011.01 for example. Writing it as 1.01101 * 2^3 is normalized. Writing it as 0.0101101 * 2^5 is denormalized.
19:14:34 <SamB_XP> yeah.
19:14:58 <glen_quagmire> but I can't see why sometimes it returns 24 length lists SamB_XP
19:15:09 <SamB_XP> glen_quagmire: read the wikipedia article or something
19:15:14 <glen_quagmire> maybe it's always denormalized
19:15:21 <glen_quagmire> for floatToDigits.
19:15:24 <monochrom> Given bounded bits for the exponent and mantissa, if you allow some numbers written denormalized, you can write more numbers.
19:15:30 <SamB_XP> glen_quagmire: that "1." isn't stored in the representation
19:15:51 <glen_quagmire> SamB_XP: yup that's the meaning of normalized representation
19:16:19 <SamB_XP> so you get 23 explicit digits and a leading 1 digit thrown in for free
19:16:44 <glen_quagmire> oh
19:16:57 <glen_quagmire> when you put it that way, i can kind of understand
19:16:58 <monochrom> But really, I am not sure why anyone has to explain this to anyone - I mean outside school. Supposedly all of you have taken reputable CS courses and one of them taught you this.
19:17:05 <glen_quagmire> thanks SamB_XP
19:17:20 <SamB_XP> monochrom: um, I'm only a sophomore!
19:17:39 <SamB_XP> monochrom: also it's easy to forget and/or get confused
19:17:59 <monochrom> The course "computer organization" is in the sophomore year.
19:18:17 <SamB_XP> did I mention that I'm an EE?
19:18:22 <LoganCapaldo> You need to have taken reputable CS course to be in this channel?
19:18:23 <SamB_XP> at the beginning of sophomore year?
19:18:30 <LoganCapaldo> damn.
19:18:41 <SamB_XP> taking two/three freshman classes?
19:19:38 <Tela> Seriously, I'm a BME major. My teachers don't even begin to assume we know what computers are.
19:19:59 <sn> body modification engineer?
19:20:05 <SamB_XP> BioMechanical Engineering?
19:20:10 <monochrom> I'm really commenting on the "I think we should rename the function to isASpecialSnowflake" comment.
19:20:13 <Tela> Close enough :) Biomedical
19:20:24 <LoganCapaldo> Ah well in that case
19:20:32 <LoganCapaldo> carry on :)
19:20:35 <SamB_XP> Tela: how about non-bio medical?
19:20:54 <SamB_XP> that would be more interesting
19:21:00 <SamB_XP> mainly because I'm not sure it's possible
19:21:19 <Tela> I agree with you there on the B being pretty darn redundant
19:21:36 <Tela> I suppose you could engineer surgical lights
19:22:12 <SamB_XP> anyway, I don't think engineers usually get to pick a submajor until sophomore year
19:24:43 * goalieca is a grad in biomedical.. but from the ECE side of things
19:24:52 <Tela> Woah. Since when was the HAppS website... colorful?
19:25:16 <pizza_> since it became self-aware
19:26:04 <Tela> goalica, I'm leaning toward the ECE side of things. I want to get involved in signal processing on neuron electrodes sometime in the next year or so.
19:26:26 <Korollary> Dr Frankenstein is such a popular idol.
19:26:44 <SamB_XP> his methods were so crude
19:27:03 <Korollary> We call such people pioneers
19:27:31 <Tela> The electrode controlled prosthetics that have been developed are really exciting
19:27:37 <SamB_XP> I mean didn't his apparatus like require it to be a dark and stormy night or something?
19:28:27 <SamB_XP> Tela: They've had that sort of thing for a while now, haven't they?
19:29:05 <Tela> Several years, yeah. They're pretty, well, "crude", though.
19:29:35 <SamB_XP> I think I was served by one at the McDonalds in Children's Hospital some years ago...
19:29:51 <SamB_XP> er, I mean a person with one
19:30:08 <SamB_XP> I'm not positive though; I was kinda little at the time...
19:30:40 <goalieca> Tela: my grad supervisor was involved in a project to locate the optical nerve placement for leg implants
19:31:28 <goalieca> i was involved.. but in the "sit in an mri machine for an hour while we scan your leg". turns out my lack of leg fat screwed up their method :)
19:31:32 <goalieca> so they went to plan b
19:31:32 <goalieca> hehe
19:31:48 <Tela> heheh
19:31:48 <SamB_XP> ... optical?
19:31:52 <glen_quagmire> > 1e-8 - 1e-16
19:31:54 <lambdabot>  9.9999999e-9
19:32:00 <glen_quagmire> > 1e-8 - 1e-16 :: Float
19:32:01 <lambdabot>  1.0e-8
19:32:04 <sorear> glen_quagmire:
19:32:09 <allbery_b> s/p/m/ I think
19:32:10 <glen_quagmire> > 1e-9 - 1e-16 :: Float
19:32:12 <lambdabot>  9.999999e-10
19:32:41 <glen_quagmire> I'm trying to explain that fraction rounded off.
19:33:01 <Tela> I'm basically performing as a cell tech for my Grad supervisor. We're working to see what the effects of chronic damage by those electrodes really are. There's some concern that current techniques could lead to a lot of damage over time.
19:33:54 <glen_quagmire> > let (l,e) = floatToDigits 2 1e-8 in (length (fst l), e)
19:33:54 <lambdabot>  Couldn't match expected type `(a, b)' against inferred type `[Int]'
19:34:15 <glen_quagmire> > let (l,e) = floatToDigits 2 1e-8 ::Float in (length l, e)
19:34:16 <lambdabot>  Couldn't match expected type `Float'
19:34:16 <monochrom> We now use nuclear power and solar power. No need to wait for lightning nights any more. In fact sunny days are now preferred.
19:35:18 <glen_quagmire> > let (l,e) = floatToDigits 2 (1e-8 :: Float) in (length l, e)
19:35:19 <lambdabot>  (24,-26)
19:35:27 <glen_quagmire> > let (l,e) = floatToDigits 2 (1e-9 :: Float) in (length l, e)
19:35:28 <lambdabot>  (24,-29)
19:35:43 <glen_quagmire> now, exponent of 1e-16 is -53.
19:36:37 <glen_quagmire> To calculate 1e-9 - 1e-16, exponents have to be same. so, 1e-16 will be 0.000...1...*2^-29   with 24 leading 0's
19:36:59 <glen_quagmire> 1e-16 = 0.1...*2^-53  in binary
19:37:29 <glen_quagmire> so, to raise that exponent to -29, there will be 24 leading 0's
19:37:43 <glen_quagmire> 24 = -29 - (-53)
19:38:17 <glen_quagmire> But, still 1e-9 - 1e-16 does not return 1e-9. I think 24 leading 0's will evaluate 1e-16 to be 0.0
19:39:49 <sorear> > 1e-9 :: Float
19:39:51 <lambdabot>  1.0e-9
19:40:21 <glen_quagmire> > 1e-9 - 1e-16
19:40:22 <lambdabot>  9.999999e-10
19:40:44 <glen_quagmire> > 1e-9 - 1e-16 :: Float
19:40:45 <lambdabot>  9.999999e-10
19:47:27 <chessguy> @pl e x y = e' x y >>= p
19:47:27 <lambdabot> e = flip flip p . ((>>=) .) . e'
19:47:40 <omnId> @ty \f x y -> x >>= (y >>=) . (return .) . f
19:47:42 <lambdabot> forall a b (m :: * -> *) a1. (Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
19:49:03 <oerjan> @pl e xy = e' xy >>= p
19:49:03 <lambdabot> e = (p =<<) . e'
19:49:30 <oerjan> e = curry ((p =<<) . uncurry e')
19:50:26 <chessguy> not worth it, oerjan :)
19:50:30 <chessguy> though cute :)
19:51:30 <oerjan> well the technique is nice to know, since @pl often is lousy about this case
19:53:17 <omnId> @type \ f g -> curry (f (uncurry g)) -- useful in general?
19:53:19 <lambdabot> forall a b c a1 b1 c1. (((a, b) -> c) -> (a1, b1) -> c1) -> (a -> b -> c) -> a1 -> b1 -> c1
19:53:41 <chessguy> oh yeah, i use that type all the time
19:53:52 <omnId> :P
19:54:39 * chessguy sighs and wonders if he'd be better off scrapping the scheme stuff and starting from scratch
19:58:19 <omnId> @type \ f g -> curry (f . uncurry g) -- simpler
19:58:21 <lambdabot> forall c a b c1. (c1 -> c) -> (a -> b -> c1) -> a -> b -> c
19:59:56 <chessguy> oh well, time to call it a night
20:00:02 <omnId> @. djinn type \ f g -> curry (f . uncurry g)
20:00:04 <lambdabot> f a b c d = a (b c d)
20:00:20 <omnId> :)
20:01:14 <oerjan> @pl  f a b c d = a (b c d)
20:01:15 <lambdabot> f = (.) . (.)
20:01:30 <oerjan> :t (.) . (.)
20:01:32 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:01:55 <omnId> right.  Boobies combinator.  I guess I didn't make anything new.
20:01:57 <sieni> the legendary boobs and bellybutton combinator
20:02:57 <oerjan> @unpl ((.).(.)) (p =<<) e'
20:02:57 <lambdabot> (\ c f -> (e' c f) >>= p)
20:03:09 <sorear> @quote smilies
20:03:10 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
20:03:35 <oerjan> omnId: actually that improved it a lot
20:03:47 <oerjan> in shortness, at least
20:06:37 <oerjan> @pl e x y = p' (e' x y)
20:06:37 <lambdabot> e = (p' .) . e'
20:06:42 * omnId can understand (f .) . g more readily than ((.).(.)) f g
20:06:56 <oerjan> yeah, they're the same
20:07:07 <oerjan> i just realized that
20:07:43 <oerjan> @unpl (((f.).).).g
20:07:43 <lambdabot> (\ h k n q -> f (g h k n q))
20:07:44 <omnId> ((.).(.)) f g = ((.) ((.) f)) g = ((.) f) . g
20:09:27 <omnId> @unpl (.)(.)(.)(.)(.)
20:09:27 <lambdabot> (\ f i k l -> f (i (k l)))
20:09:53 * omnId coins the fickle operator
20:11:02 <omnId> (get it?  fikl?  I'm so terribly droll.)
20:11:48 <oerjan> @unpl (.)(.)(.)(.)(.)(.)
20:11:48 <lambdabot> (\ i k l q r -> i (k l) (q r))
20:11:55 <oerjan> @unpl (.)(.)(.)(.)(.)(.)(.)
20:11:56 <lambdabot> (\ k l q r u -> k l (q r u))
20:12:19 <omnId> @unpl (.)(.)(.)(.)
20:12:19 <lambdabot> (\ e f i k l -> e f i (k l))
20:13:02 <glen_quagmire> in C++, float a=0.5, b=1e-7; cout<<a-b; outputs 0.5. in haskell, 4.99999
20:13:08 <oerjan> oh wait that's something i looked at the other day
20:13:13 <glen_quagmire> > 0.5 - 1e-7 :: Float
20:13:14 <lambdabot>  0.4999999
20:13:37 <omnId> (\ e f i k l -> e f i (k l)) (.) = (.) f i (k l) = f (i (k l))
20:13:43 <allbery_b> glen_quagmire: if you;re using printf in C with the %g format, it'll handle the rounding for you
20:13:51 <allbery_b> if you use Text.Printf the same should happen
20:13:53 <Pseudonym> glen_quagmire: The default number of digits printed by operator<< is somewhat low.
20:13:58 <allbery_b> if you just use show, well...
20:13:59 <oerjan> @unpl (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
20:14:00 <lambdabot> (\ aj al am at aw -> aj (al am at aw))
20:14:07 <oerjan> @unpl (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
20:14:07 <lambdabot> (\ r u x z aa -> r (u x) (z aa))
20:14:20 <allbery_b> (and c++ is similar)
20:14:26 <oerjan> @unpl (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
20:14:26 <lambdabot> (\ x z aa ag aj -> x (z aa ag aj))
20:14:36 <glen_quagmire> :t Printf
20:14:38 <lambdabot> Not in scope: data constructor `Printf'
20:14:39 <omnId> how interesting
20:14:39 <sieni> Perhaps I'll just wake up
20:14:48 <oerjan> hint, look at the last and third to last there...
20:16:04 <Pseudonym> glen_quagmire: There's a C++ ostream manipulator to increase it, but I can't remember exactly what it is right now.
20:16:14 <Pseudonym> Probably width.
20:16:32 <glen_quagmire> Pseudonym: cout<<setprecision(17)<<a-b; outputs 0.49999...
20:16:37 <Pseudonym> Right./
20:16:39 <Pseudonym> There you go.
20:16:41 <Pseudonym> setprecision
20:16:54 <oerjan> omnId: see it?
20:17:03 <omnId> oerjan: see what?
20:17:12 <glen_quagmire> but i'm having difficulty explaining why 0.5 - 1e-7 is 0.4999.. while 0.5 - 1e-8 is 0.5
20:17:24 <oerjan> @unpl (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
20:17:24 <lambdabot> (\ x z aa ag aj -> x (z aa ag aj))
20:17:33 <oerjan> @unpl (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
20:17:33 <lambdabot> (\ aj al am at aw -> aj (al am at aw))
20:17:37 <glen_quagmire> for Floats, there are 23 fraction bits.  I can't get that number 23
20:18:04 <glen_quagmire> > floatToDigits 0.5
20:18:05 <lambdabot>   add an instance declaration for (Fractional Integer)
20:18:09 <omnId> neat
20:18:12 <Pseudonym> glen_quagmire: You can't represent 0.1 exactly in IEEE-754 floating point.
20:18:28 <Pseudonym> The closest floating point number is something very close to it.
20:18:30 <omnId> @unpl (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.) -- repeat every four?
20:18:30 <lambdabot> (\ aw ay az bf bi -> aw (ay az bf bi))
20:18:34 <glen_quagmire> > (floatToDigits 2 0.5, floatToDigits 2 1e-8)
20:18:35 <lambdabot>  (([1],0),([1,0,1,0,1,0,1,1,1,1,0,0,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,1,0,0,0,1,1...
20:18:37 <oerjan> yep
20:18:55 <Pseudonym> That's the reason why, when printing, we usually don't show all 23 digits.
20:19:13 <glen_quagmire> > (snd (floatToDigits 2 0.5), (snd (floatToDigits 2 1e-8))
20:19:13 <lambdabot>  Unbalanced parenthesis
20:19:17 <Pseudonym> There's no point.  And because this is output for humans, humans often don't appreciate the difference between precision and accuracy.
20:19:25 <glen_quagmire> > (snd (floatToDigits 2 0.5), (snd (floatToDigits 2 1e-8)))
20:19:27 <lambdabot>  (0,-26)
20:19:30 <Pseudonym> At any rate, 23 is a ridiculous default.
20:20:03 <Pseudonym> Haskell and C++ make the defaults different, but allow you to change it if appropriate.
20:20:05 <sieni> Pseudonym: not least because 2/3 is approximately 0.666, so the whole number is cursed
20:20:11 <glen_quagmire> so, 0.1 is  0.blah * 2^0.   and 1e-8 is 0.blah * 2^-26
20:20:22 <glen_quagmire> where blah is just binary bit string
20:21:18 <glen_quagmire> 0.b * 2^0 - 0.b * 2^-26   will be calculated as 0.b*2^0 - 0.000..00b*2^0  with 26 leading 0's.
20:21:48 <Pseudonym> > decodeFloat 0.1
20:21:50 <lambdabot>  (7205759403792794,-56)
20:22:00 <Pseudonym> > 7205759403792794 * 2^(-56)
20:22:01 <lambdabot>  Exception: Prelude.^: negative exponent
20:22:07 <Pseudonym> > 7205759403792794 / 2^56
20:22:08 <lambdabot>  0.1
20:22:40 <Pseudonym> > decodeFloat 1e-8
20:22:42 <lambdabot>  (6044629098073146,-79)
20:22:59 <omnId> foldl1' AppE $ replicate 4000 $ VarE (mkName ".")
20:23:08 <Pseudonym> > 7205759403792794 * 2^(79-56)
20:23:09 <lambdabot>  60446290980731462090752
20:24:16 <glen_quagmire> > let (f,e) = decodeFloat (1e-8 :: Float) in f * 2 ** e
20:24:17 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
20:24:33 <glen_quagmire> > let (f,e) = decodeFloat (1e-8 :: Float) in f / 2^e
20:24:34 <lambdabot>   add an instance declaration for (Fractional Integer)
20:24:34 <lambdabot>     In the expression:...
20:24:35 <oerjan> omnId: also, you get the same repetition with fmap, since they are equal when the third argument is a function (that's what i looked at initially)
20:24:44 <oerjan> er, second
20:25:07 <omnId> fmap in ((->) r) is (.), yes
20:25:34 <pizza_> why use floats instead of rationals? speed?
20:26:06 <Pseudonym> Speed, memory usage.
20:26:08 <oerjan> @unpl (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
20:26:09 <lambdabot> (\ r u x z aa -> r (u x) (z aa))
20:26:12 <oerjan> @unpl (.)(.)(.)(.)(.)(.)
20:26:12 <lambdabot> (\ i k l q r -> i (k l) (q r))
20:26:18 <glen_quagmire> and for homework
20:26:24 <oerjan> right - (.) settles down faster
20:26:39 <pizza_> hehe, ok
20:28:41 <hpaste>  omnId pasted "oerjan, try a larger multiple of 4 for "replicate 12" :)" at http://hpaste.org/3168
20:29:37 <omnId> I tried 4000 first.  Bad idea.
20:29:46 <omnId> LAG!
20:29:59 <omnId> THRASH!
20:30:50 <oerjan> :t (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
20:30:52 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
20:31:11 <oerjan> hm that works, i recall fmap got it all to hang
20:31:26 <oerjan> too many instances to decide
20:31:31 <omnId> :D
20:32:58 <glen_quagmire> > (0.5 - (1/2^26)::Float, 0.5 - (1/2^25)::Float)
20:33:02 <lambdabot>  (0.5,0.49999997)
20:33:04 * omnId briefly wonders if it'd be a good idea to manually step through the expansion of (.)x12; he quickly discards the horrible idea
20:33:16 <glen_quagmire> so, 26 is the magic number?
20:33:32 <oerjan> omnId: i did
20:33:53 <omnId> you did?
20:33:54 <oerjan> i was sitting at a cafe, writing on a napkin
20:34:12 <omnId> how many steps?
20:34:28 <oerjan> well i did it iteratively
20:35:40 <oerjan> expanding (.)x n for higher and higher n
20:35:53 <oerjan> until suddenly two were equal
20:36:32 <omnId> maybe I should try a right-associative version
20:36:49 <omnId> (.)((.)(.)), (.)((.)((.)(.))), etc
20:36:55 <oerjan> i don't think that repeats
20:37:53 <goalieca> omnId, nice boobies. ^^
20:38:07 <oerjan> another thing i found out: if you have a lambda expression \a b ... v -> a b (c (d e f)) ... where each variable occurs exactly once, and in sequence, then you can @pl it down to just applications of (.)
20:38:45 <omnId> "found out" I'm guessing doesn't mean "proved" :)
20:38:54 <oerjan> sure it does
20:38:58 <omnId> oh?
20:39:10 <_achilles_> hey
20:39:34 <_achilles_> anybody bored wanna critique some haskell code?
20:39:38 * omnId does
20:40:41 <oerjan> hm... unless i made a mistake
20:42:03 <Pseudonym> :t (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
20:42:06 <oerjan> the trick is, if you have something like a(b(c(...v))...) you turn it into (a.b.c...u) v
20:42:12 <lambdabot> forall a b c a1 b1. (b1 -> b -> c) -> (a -> b1) -> a -> (a1 -> b) -> a1 -> c
20:42:22 <Pseudonym> ?free f :: forall a b c a1 b1. (b1 -> b -> c) -> (a -> b1) -> a -> (a1 -> b) -> a1 -> c
20:42:22 <lambdabot> (forall x. k . f1 x = f2 (q x) . h) => q . f3 = f4 . g => h . f5 = f6 . p => k . f f1 f3 y f5 = f f2 f4 (g y) f6 . p
20:42:23 <oerjan> then you have the final variable loose, and can remove it
20:42:35 <oerjan> erm...
20:43:30 <oerjan> (.)((.)((.)ab)c)d etc., so all the (.)'s are added first
20:44:17 <oerjan> i guess there is one exceptional case, id
20:44:33 <oerjan> for \a b ... v -> a b ... v
20:45:34 <oerjan> anyway, so as you rearrange and remove the last variable, eventually you are left with just the (.)'s
20:47:37 <oerjan> QED
20:47:54 <omnId> cool
20:48:15 <hpaste>  _achilles_ pasted "omnld review" at http://hpaste.org/3169
20:48:59 <omnId> oops, he tried to paste it to privmsg
20:50:45 <oerjan> that's gotta hurt :)
20:51:54 <oerjan> @src maximum
20:51:54 <lambdabot> maximum [] = undefined
20:51:54 <lambdabot> maximum xs = foldl1 max xs
20:53:51 <omnId> > tails [1..20]
20:53:56 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[2,3,4,5,6,7,8,9,10,11...
20:54:08 <omnId> > tails [1..5]
20:54:09 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
20:54:59 <oerjan> second critique: 20 is hard-coded
20:55:44 <_achilles_> what was the first:
20:55:45 <_achilles_> ?
20:56:01 <oerjan> replace fold max 0 by maximum
20:56:04 <_achilles_> ah
20:56:04 <oerjan> *foldl
20:56:08 <_achilles_> ok
20:56:25 <thoughtpolice> whoa, harpy is lots of fun. :)
20:56:42 <Tela> Stylistically, it's a lot more popular to use where so as not to expose helper functions to the top level
20:56:44 <thoughtpolice> maybe an excuse to dive into compiler adventures.
20:56:44 <oerjan> i suppose 4 shouldn't be hard-coded either :)
20:56:47 <omnId> what's (length matrix) and (length (head matrix))?  24?
20:57:18 * omnId is too lazy to count
20:57:25 <oerjan> just 20
20:57:46 <_achilles_> 20x20\
20:58:13 <omnId> I was going to say then that rowToMax' should stop at 17, but I guess a product of fewer numbers can't be max anyway :)
20:58:19 <Tela> (On a side note, is there an idiomatic definition for groupByLength :: Int -> [a] -> [[a]]?)
20:58:30 <omnId> several
20:58:34 <_achilles_> right, I took advantage of that omnld
20:58:41 <oerjan> groupBy ((==) `on` length)
20:58:42 <omnId> many write it since it should be in the libs :)
20:58:52 <_achilles_> in which module is tails defined?
20:58:58 <TSC> @index tails
20:58:58 <lambdabot> Data.List
20:58:59 <oerjan> oh wait
20:59:06 <omnId> (and that's an I in omnId, btw :)
20:59:07 <Tela> Yeah, I always miss it there
20:59:45 <_achilles_> tk
21:00:01 <omnId> _achilles_: :t diag?
21:00:09 <oerjan> another critique is it won't work for negative numbers :)
21:00:25 <omnId> nvm, I'll just load into ghci and see myself :)
21:00:40 <_achilles_> diag? or diag'?
21:00:59 <_achilles_> diag::[[Integer]]
21:01:04 <omnId> *Main> diag [[1,2,3],[4,5,6],[7,8,9]]
21:01:05 <omnId> Loading package haskell98 ... linking ... done.
21:01:05 <omnId> [[1,2,3],[4,5,6],[7,8,9]]
21:01:08 <omnId> ?
21:01:30 <oerjan> but to achieve that you would need to actually ensure that the extracted sublists have exactly length 4...
21:01:31 <_achilles_> hmmm
21:01:41 <Tela> I really like the Arrows version of this program...
21:02:20 <_achilles_> one sec
21:03:07 <_achilles_> blast, I broke it
21:03:15 <Tela> @index on
21:03:15 <lambdabot> bzzt
21:03:35 <omnId> _achilles_: what should that eval to?
21:03:41 <Tela> oerjan: What's that `on` you used up there?
21:03:54 <omnId> on f g x y = f (g x) (g y)
21:04:16 <_achilles_> flip flop n r
21:04:21 <_achilles_> in the definition
21:04:23 <oerjan> Tela: that was wrong btw i misunderstood the question
21:04:32 <omnId> (on is going in in some future version)
21:04:39 <Tela> oerjan, I'd just never seen on before :)
21:05:11 <omnId> > transpose [[1,2,3],[4,5,6],[7,8,9]]
21:05:16 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
21:05:21 <omnId> that?
21:05:29 <_achilles_> diag [[1,2,3],[4,5,6],[7,8,9]] => [[1,2,3],[5,6,7],[9,7,8]]
21:05:38 <_achilles_> damnnit
21:06:45 <_achilles_> SHOULD do....
21:07:06 <omnId> I think rowValues = map rowToMax
21:07:17 <oerjan> why is diagValues etc. using colValues instead of the simpler rowValues?
21:07:56 <Tela> diag [[1..3],[4..6],[7..9]] => [[3], [2,6], [1,5,9], [4,8], [7]]?
21:07:57 <_achilles_> diag [[1,2,3],[4,5,6],[7,8,9]] => [[1,2,3],[5,6,4],[9,7,8]
21:07:57 <omnId> I don't understand that diag transform.
21:08:25 <_achilles_> the intent is to move the diagonal into the columns
21:08:46 <_achilles_> but it appears to be failing
21:09:14 <oerjan> _achilles_: you are getting diagonals wrapping around, i think
21:09:22 <omnId> so basically to extract [1,5,9]?
21:09:46 <_achilles_> I want wrapping.
21:10:03 <_achilles_> I'd like the whole matrix, not just the first column
21:10:10 <omnId> the problem statement doesn't seem to mention wrapping.
21:10:19 <omnId> http://projecteuler.net/index.php?section=problems&id=11
21:10:20 <lambdabot> Title: Project Euler
21:10:22 <_achilles_> I know...
21:10:27 <_achilles_> I cheataed
21:10:29 <_achilles_> :)
21:10:35 <omnId> @slap _achilles_
21:10:35 * lambdabot slaps _achilles_
21:10:38 <_achilles_> haha
21:10:42 <oerjan> _achilles_: i mean, you get diagonals like [2,6,7]
21:10:58 <omnId> oerjan: I think he understands
21:11:21 <Pseudonym> O HAI  I MADE U A SOLUSHUN, BUT I CHEETED IT
21:11:45 <_achilles_> ?
21:12:02 <omnId> Internet.
21:12:16 <omnId> It makes you crazy.
21:12:20 <Pseudonym> It does.
21:12:23 <_achilles_> if you can recommend a way to avoid the wraping that gets me all the "valid" diagonals, I'd be happy to hear about it
21:12:31 <Pseudonym> I have so far resisted the urge with my cats.
21:12:55 <oerjan> _achilles_: actually the wrapping might not be so bad if you split them afterwords...
21:13:02 <oerjan> *wards
21:13:25 <oerjan> since each of them consists of two proper diagonals concatenated
21:14:18 <omnId> res = maximum $ concatMap ($ matrix) [rowValues, colValues, diagValues, rDiagValues] -- maybe less clear, but cool looking :D
21:14:21 <oerjan> after transposing, splitting should be fairly simple
21:14:38 <_achilles_> haha
21:14:48 <_achilles_> thanks omnld, I assumed there was a way to do that
21:15:08 <_achilles_> :) I just wished I thought of it
21:15:38 <Tela> Haskell golf is such a twisted thing.
21:16:13 <omnId> Style point: personally I'd put single-use-only names within a where clause of the function they're used in.
21:16:24 <_achilles_> mk
21:16:46 <omnId> so the various *Values functions could be within res.
21:17:47 <Tela> Speaking of that, in this example, is there some way to define diag and rdiag without exposing diag' but such that diag' calls would be memoized from both functions?
21:18:08 <omnId> so diag basically rotates each row by a successively larger number of elements?
21:18:18 <_achilles_> that's the goal
21:18:56 <n00b> does anyone where I cn find any good tutorial on SOE Graphics Library
21:19:14 <n00b> @google School of Expressions
21:19:16 <lambdabot> http://www.expression.edu/
21:19:18 <_achilles_> originally, I had an rdiag too....but I tried to combine them, apparently the combine didn't work as well as  I thought
21:19:42 <n00b> @google haskell SOE
21:19:43 <TSC> Is the book itself useful as a tutorial for the library?
21:19:43 <lambdabot> http://haskell.org/soe/
21:19:43 <lambdabot> Title: Home Page
21:19:44 <omnId> > let f n xs = take n xs ++ drop n xs in zipWith f [0..] [[1,2,3],[4,5,6],[7,8,9]]
21:19:46 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
21:20:01 <omnId> > let f n xs = drop n xs ++ take n xs in zipWith f [0..] [[1,2,3],[4,5,6],[7,8,9]] -- oops
21:20:03 <lambdabot>  [[1,2,3],[5,6,4],[9,7,8]]
21:20:09 <n00b> can't afford the book
21:20:17 <ac> how do I get seconds since the epoch from a ClockTime?
21:20:22 <omnId> rdiag goes the other way?
21:20:22 <n00b> barely even feeding myeslf
21:20:28 <n00b> and making ends meet
21:20:36 <_achilles_> right
21:20:40 <TSC> n00b: I borrowed it from a library
21:20:56 <n00b> i am on a scholarship
21:21:04 <omnId> @let rot n xs = drop n xs ++ take n xs
21:21:07 <lambdabot> Defined.
21:21:11 <n00b> school library is lame
21:21:40 <omnId> > zipWith rot [0, -1..] [[1,2,3],[4,5,6],[7,8,9]]
21:21:41 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
21:21:56 <n00b> can the SOE library create buttons
21:22:10 <n00b> I have a project to create a calculator
21:22:21 <TSC> I'd try with gtk
21:22:26 <_achilles_> hmmm
21:22:28 <omnId> > zipWith rot [20, 19..] [[1,2,3],[4,5,6],[7,8,9]]
21:22:29 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
21:22:34 <omnId> > zipWith rot [3, 2..] [[1,2,3],[4,5,6],[7,8,9]]
21:22:35 <lambdabot>  [[1,2,3],[6,4,5],[8,9,7]]
21:22:38 <n00b> I was thinking of wxhaskell, but my teach SOE
21:22:40 <omnId> ther we are
21:22:55 <oerjan> perhaps for diag' the simplest is to reverse the matrix, then use diag?
21:22:57 <n00b> he say GTk is too easy
21:23:06 <omnId> diag = zipWith rot [0..]
21:23:13 <oerjan> i mean, rdiag
21:23:14 <omnId> rdiag = zipWith rot [20, 19..]
21:23:22 <n00b> I used the gtk and glade and created a calc in 15 mins, fully functional
21:23:33 <oerjan> omnId: but that requires an explicit 20
21:23:39 <n00b> so can SOE create it ???
21:23:39 <Tela> That hardcodes the 20 in again..
21:23:45 <omnId> oerjan: it's not worse than what he has :)
21:24:01 <_achilles_> hey!
21:24:02 <_achilles_> ;)
21:24:06 <omnId> oerjan: I'm going meaning-preserving before improving the algorithm
21:24:17 <omnId> :P
21:24:19 <oerjan> rdiag = diag . reverse
21:24:53 <Tela> rdiag = diag . map reverse, no?
21:25:03 <oerjan> Tela: both work for this case
21:25:15 <Tela> ah, got it
21:25:16 <oerjan> i guess map reverse gives a more intuitive order
21:25:17 <omnId> oh of course!
21:25:47 <Tela> the rotation is still reflected over either flip
21:26:49 <oerjan> diag = splitWraps . transpose . diag'
21:27:20 <omnId> diag = zipWith rot [0..]
21:27:37 <oerjan> no, diag' = zipWith rot [0..]
21:28:07 <oerjan> and then some massaging
21:28:13 <n00b> did some googling, it seems SOE can't create it. It's just a graphics libraries, not a GUI creator
21:29:13 <ac> there must be a more elegant way to do this:
21:29:17 <ac> > liftM tdSec (liftM (flip diffClockTimes (TOD 0 0)) getClockTime)
21:29:18 <lambdabot>   Not in scope: `getClockTime'
21:29:41 <_achilles_> so which is it?
21:29:42 <oerjan> well, listM (tdSec . flip diffClockTimes (TOD 0 0)) for a start
21:29:56 <oerjan> *liftM
21:30:55 <hpaste>  omnId annotated "omnld review" with "this seems to work" at http://hpaste.org/3169#a1
21:30:58 <Tela> splitWraps xs = map (`splitAt` xs) [20, 19..]
21:31:01 <Tela> ?
21:31:12 <oerjan> Tela: more or less
21:32:23 <omnId> "rotate a left by list by n elements"???  /me double-takes
21:32:55 <_achilles_> ?
21:32:57 <omnId> rotate a list left by n elements
21:33:02 <_achilles_> oh...
21:33:10 <_achilles_> in the comment
21:33:42 <Tela> so you mean... rotate a (rot 2 [left, by, list]) n elements?
21:34:08 <Tela> :)
21:34:09 <omnId> a [left, by] list
21:34:12 <omnId> :P
21:35:01 <omnId> Tela: this is precisely what I meant.  I of course expected the reader to pick up on it.
21:35:13 <_achilles_> wow....so that's about halved my code
21:35:21 <Tela> :D
21:35:33 <omnId> moral of the day: the recursion has already been done.
21:35:44 <_achilles_> mm?
21:35:56 <omnId> explicit recursing over the list conses
21:36:08 <omnId> map, zipWith, maximum
21:36:16 <_achilles_> ah
21:37:12 <omnId> do you understand what's there?
21:38:40 <_achilles_> hmmm
21:38:44 <_achilles_> hang on a minute
21:39:15 <oerjan> splitWraps = filter (not . null) . (concatMap . uncurry ((++) `on` (:[])) . zipWith splitAt [0..] . reverse -- okay, so i got carried away
21:39:36 <oerjan> er, [1..] maybe
21:39:36 <ac> pjd: still around?
21:40:11 <ac> pjd: I'm realizing I need an IORef anyway, in order to tell if enough time has passed to draw another frame
21:41:22 <glen_quagmire> > ((1/2^128) :: Float)
21:41:27 <oerjan> :t filter (not . null) . (concatMap . uncurry (liftM2 (++) `on` (:[])) . zipWith splitAt [1..] . reverse
21:41:27 <lambdabot>  0.0
21:41:28 <lambdabot> parse error (possibly incorrect indentation)
21:41:30 <glen_quagmire> is this a bug?
21:41:41 <glen_quagmire> Float should handle up until 1/2^149
21:42:02 <glen_quagmire> in C++, float type can store 1/pow(2.0, 149)
21:42:17 <oerjan> :t filter (not . null) . concatMap (uncurry (liftM2 (++) `on` (:[]))) . zipWith splitAt [1..] . reverse
21:42:18 <lambdabot> Not in scope: `on'
21:42:46 <oerjan> :t let on f e x y = f(e x)(e y) in filter (not . null) . concatMap (uncurry (liftM2 (++) `on` (:[]))) . zipWith splitAt [1..] . reverse
21:42:48 <lambdabot> forall a. [[a]] -> [[a]]
21:43:23 <omnId> @src tails
21:43:23 <lambdabot> tails []         = [[]]
21:43:23 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
21:44:16 <glen_quagmire> > (2**(-128)::Float)
21:44:18 <lambdabot>  2.938736e-39
21:44:29 <glen_quagmire> I think it's difference between / and **
21:45:05 <oerjan> > 2^128 :: Float
21:45:06 <lambdabot>  Infinity
21:45:20 <oerjan> > 2**128 :: Float
21:45:22 <lambdabot>  Infinity
21:45:32 <oerjan> > 2^127 :: Float
21:45:33 <lambdabot>  1.7014119e38
21:46:15 <oerjan> yeah
21:46:42 <oerjan> > isIEEE (2^127 :: Float)
21:46:43 <lambdabot>  True
21:47:19 <oerjan> > 2^^(-149)
21:47:20 <lambdabot>  1.401298464324817e-45
21:47:34 <omnId> @src zipWith
21:47:35 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
21:47:35 <lambdabot> zipWith _ _      _      = []
21:54:17 <_achilles_> thanks for the help oerjan, appreciated
21:57:23 <hpaste>  sutats pasted "Refactoring logHook to avoid io $ putStr" at http://hpaste.org/3170
21:58:35 <Tela> I want to write a monad... A project to learn more about them. Any moderately difficult suggestions?
21:59:39 <omnId> Tela: implement False in StateT s IO ()
21:59:40 <omnId> @go False programming language
21:59:43 <lambdabot> http://wouter.fov120.com/false/
21:59:43 <lambdabot> Title: Wouter's False page
22:00:39 <omnId> parsec has some sexy parsing monads, too.
22:01:17 <Tela> Parsec sounds more fun... "obfusciated syntax" sounds like frustration abounds to me :)
22:01:30 <ac> how do I branch on an IO Bool? "if" doesn't seem to do the trick
22:01:43 <omnId> Tela: It's just dumb Forth with one-letter symbol names.
22:02:19 <oerjan> ac: do b <- ioBool; if b ...
22:02:40 <omnId> or liftM (\b -> if b ...) ioBool
22:02:58 <oerjan> omnId: only if the if is pure
22:03:04 <omnId> right
22:03:08 <ac> thanks
22:04:05 <Tela> Okay, so it's not impossible. I still have looming thoughts of Intercal when I see syntax like that, though :)
22:04:13 <omnId> oerjan: though if it isn't, you could join.  But join (liftM f x) is just x >>= f
22:05:03 <omnId> It's a cute little language, I've written three interpreters.  It's my try-out-a-language exercise of choice.
22:06:20 <omnId> you know much about Forth?
22:06:26 <Tela> Eh, why not? Playing with stacks sounds fun
22:19:44 <TSC> Is there an easy way to measure how much stack space a program uses?  I have a program that exhausts stack space, but only on large input.  I'd like to be able to test it with small input and see how the stack space behaves.
22:20:35 <bos> TSC: read up on profiling
22:21:02 <bos> summary: compile -prof -auto-all, run +RTS -P -RTS, read the generated .prof file
22:22:43 <TSC> Thanks
22:22:50 <TSC> I might need -xt too, to show stack use
22:27:44 <Tela> omnId I've never used Forth, but I know a bit about stack languages. I worked through an example once in Lisp involving one.
22:33:42 <ac> Is it possible to call a function on a timer?
22:36:05 <omnId> forever (do { f ; threadDelay (10^6) })?
22:36:10 <sieni> ac: yes, with forkIO and threadDelay
22:36:39 <sieni> ac: and if you google for "timer haskell", then this is explained on the first page you get from google
22:37:18 <ac> sieni: cool.
22:38:22 <ac> I'm giving up with using gtk's idle function. It's not behaving properly
22:39:02 <bos> ac: how not?
22:39:18 <ac> it burns CPU even with G.priorityLow
22:39:29 <bos> ac: also, gtk has functions for calling you on a timer
22:41:47 <ac> @hoogle idleAdd
22:41:48 <lambdabot> No matches found
22:44:38 <sieni> ac: isn't that the point of idle functions? i.e. that they are run whenever the is nothing else to do?
22:45:39 <ac> I guess they aren't typically used
22:46:27 <mgsloan> gtk2hs has periodic function calling
22:46:28 <sieni> depends
22:49:46 <newsham> "function"
22:50:44 <mgsloan> it's as simple as
22:50:44 <mgsloan> timeoutAdd (widgetQueueDraw window >> return True) 30
22:50:55 <mgsloan> stuff in the () is my 'function' :P
22:51:18 <ac> Why does this produce a type mismatch between "a1 -> Char" and "a1 -> String": putStrLn ("foo" ++ (liftM show bar))
22:51:24 <newsham> truely a = a >> return True
22:51:30 <ac> bar is an IO Int
22:52:04 <ddarius> :t liftM show bar
22:52:10 <ddarius> :t liftM show (return 3)
22:52:13 <lambdabot> Not in scope: `bar'
22:52:14 <lambdabot> forall (m :: * -> *). (Monad m) => m String
22:52:34 <ddarius> :t ("foo" ++)
22:52:36 <lambdabot> [Char] -> [Char]
22:52:36 <omnId> ac: if you're putStrLning it, you might as well extract the string from bar with 'val <- bar'
22:53:31 <omnId> @ty putStrLn . ("foo" ++) . show =<< (undefined :: IO Int)
22:53:33 <lambdabot> IO ()
22:54:23 <newsham> do { b <- bar; putStrLn ("foo" ++ b) }
22:54:27 <newsham> is that so horrid?
22:54:32 <omnId> nah :)
22:54:33 <oerjan> :t ("foo" ++) . liftM show
22:54:35 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
22:54:35 <lambdabot>       Expected type: [a1] -> [Char]
22:55:01 <newsham> too bad you cant just tick all of the functions to liftM them
22:55:04 <omnId> liftM show gets you an IO String, but you can't concatenate Strings and IO Strings
22:55:25 <newsham> putStrLn' (("foo"++)' bar)
22:55:49 <omnId> ("foo"++)' ?
22:55:59 <newsham> "too bad you cant just tick all of the functions to liftM them"
22:56:17 * omnId slaps forehead
22:56:26 <newsham> liftM putStrLn (liftM ("foo"++) bar)
22:56:36 <omnId> though liftM putStrLn gets you an IO (IO ())
22:56:51 <olsner> rather m (IO ())
22:56:52 <newsham> putStrLn `fmap` (("foo"++) `fmap` bar)    ?
22:57:09 <omnId> fmap = liftM, so that's no different
22:57:17 <newsham> oops, yah, my bad
22:57:36 <oerjan> :t putStrLn =<< ("foo"++) . show <$> ?bar
22:57:38 <newsham> somehow slipped my mind that putStrLn was an io thingy
22:57:38 <lambdabot> (?bar::IO Integer) => IO ()
22:57:43 <omnId> (=<<) hooks an action to a kleisli
22:58:03 <newsham> :t putStrLn =<< ("foo"++) `fmap` (return 3)
22:58:04 <lambdabot>     No instance for (Num [Char])
22:58:04 <lambdabot>       arising from the literal `3' at <interactive>:1:38
22:58:13 <newsham> err.. blah, not 3.
22:58:17 <newsham> :t putStrLn =<< ("foo"++) `fmap` (return "x")
22:58:19 <lambdabot> IO ()
22:58:25 <newsham> where (return "x") stands in for bar
22:58:43 <omnId> liftM show bar, rather
22:58:50 <newsham> ah, yes, show
22:59:00 <omnId> so you could even do liftM (("foo"++) . show)
22:59:09 <newsham> :t putStrLn =<< ("foo"++) `fmap` (show `fmap` return 3)
22:59:11 <lambdabot> IO ()
22:59:40 <newsham> or compose, yah.
23:00:21 <omnId> fmap f . fmap g = fmap (f . g) -- this is a Functor law, iirc.
23:01:05 <newsham> :t putStrLn =<< ("foo"++).show `fmap` return 3
23:01:07 <lambdabot>     precedence parsing error
23:01:07 <lambdabot>         cannot mix `(.)' [infixr 9] and `fmap' [infixl 9] in the same infix expression
23:01:20 <omnId> pretty clear error :)
23:01:25 <newsham> :t putStrLn =<< (("foo"++).show) `fmap` return 3
23:01:27 <lambdabot> IO ()
23:01:44 <oerjan> :t putStrLn =<< ("foo"++) . show <$> ?bar -- again
23:01:46 <lambdabot> (?bar::IO Integer) => IO ()
23:02:07 <newsham> ?src <$>
23:02:07 <lambdabot> f <$> a = fmap f a
23:02:08 <oerjan> (don't know why it defaults to Integer)
23:02:13 <newsham> huh, neat.
23:02:15 <omnId> @ty putStrLn . ("foo" ++) . show =<< (undefined :: IO Int) -- and since we're binding anyway, no need for the fmap
23:02:17 <lambdabot> IO ()
23:02:18 <oerjan> :t show ?t
23:02:20 <lambdabot> (?t::Integer) => String
23:02:27 <newsham> ?hoogle <$>
23:02:27 <lambdabot> No matches found
23:02:33 <newsham> ?hoogle (<$>)
23:02:33 <lambdabot> Did you mean: (<$>)
23:02:34 <lambdabot> Prelude.undefined :: a
23:02:34 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
23:02:39 <omnId> @index (<$>)
23:02:39 <lambdabot> bzzt
23:02:45 <omnId> Control.Applicative
23:02:50 <newsham> danke
23:03:11 <oerjan> newsham: hoogle is broken on * and $
23:03:19 <omnId> (<*>) = ap; (*>) = (>>); pure = return; etc.
23:03:47 <omnId> (modulo lack of proper typeclass relationship) :/
23:04:13 <shachaf> omnId: If anything, you should flip all those =s.
23:05:23 <omnId> shachaf: equivalence is commutative :)
23:06:04 <newsham> hmm.. this applicative lib looks useful, but the docs are kinda terse
23:06:20 <dibblego> how can you explain to the layperson that 0.999... is equivalent to 1, given that they do not accept that 1/9 is equivalent to 0.111... ?
23:06:29 <omnId> an Applicative Functor is not quite a Monad, but more than a Functor
23:06:33 <omnId> it has return and ap
23:06:37 <omnId> no bind
23:06:45 <newsham> dibblego: i saw this explained on the "math does not suck" web page.
23:06:58 <dibblego> @google math does not suck
23:07:00 <shachaf> omnId: Yes, but I meant that return should be an alternate name for pure.
23:07:01 <lambdabot> http://answers.yahoo.com/question/index?qid=20070826213220AAwlm0u
23:07:01 <lambdabot> Title: I suck at math , does that meen i'm dumb .? - Yahoo! Answers
23:07:01 <newsham> x = 0.9999...;  10x = 9.9999x;  10x-x = x = 1
23:07:45 <newsham> http://www.mathdoesntsuck.com/
23:07:51 <lambdabot> Title: Math Doesn't Suck
23:08:05 <shachaf> newsham: 10x-x = x?
23:08:30 <newsham> err..   10x-x = 9x = 9
23:08:37 <newsham> 9.999999.. - 0.999999
23:09:04 <newsham> danica mckellar rules
23:09:54 <Pseudonym> dibblego: Express 0.299999... in binary, and distinguish it from 0.3.
23:10:05 <newsham> x = 0.9999'; 10x = 9.9999';  10x-x = 9.9999' - 0.9999' = 9;  10x-x = 9x; 9x = 9; x = 1
23:10:10 <Pseudonym> That's not a good lay explanation, of course.
23:10:12 <newsham> does that do it for you?
23:10:18 <dibblego> I'll give those a burl, thanks
23:10:26 <dibblego> I'm trying to convince a stubborn colleague
23:10:43 <newsham> perhaps you should stop and ask yourself "why?"
23:10:51 <Pseudonym> But that binary thing is a good one for people who understand it.  There's basically no way to represent 0.2999... in binary in a way that's distinct from 0.3.
23:10:51 <newsham> sometimes its best to let stuborn colleagues lie
23:10:52 <omnId> 0.999... is a representation in base 10.  The question of "does 0.999... = 1" is a question of what 0.999... represents.  I don't know enough about the rules of repeating decimals to prove anything, and in any case, the question isn't very interesting :)
23:11:02 <dibblego> I know why; I'm having trouble explaining why; I'm just looking for alternative explanations
23:11:37 <Pseudonym> Alternatively, express 0.1111... (that's in base 3, for the record) in decimal.
23:11:38 <Tela> omnId, you can represent repeating decimals as an infinite sum and then prove that the sum .999... converges to 1
23:12:14 <olsner> I think of it as 1 being the limit as the number of nines approaches infinity (and since there is an infinite number of nines, it really does get there too ;-)
23:12:35 <Pseudonym> Tela: Some people find that explanation more confusing than helpful.  I can come up with a series of rationals that converges to sqrt(2), but sqrt(2) isn't rational.
23:12:39 <newsham> http://www.bostongeek.com/2006/08/23/math-fact-of-the-week-0/
23:12:40 <lambdabot> Title: Math Fact of the Week #0 at BostonGeek
23:12:59 <Pseudonym> So in what sense is sqrt(2) the limit of the series?
23:13:18 <Pseudonym> You and I know the answer, but you can see how it might confuse some people.
23:13:36 <newsham> http://en.wikipedia.org/wiki/Proof_that_0.999..._equals_1
23:13:37 <lambdabot> Title: 0.999... - Wikipedia, the free encyclopedia
23:13:52 <Tela> It can be confusing, yes, but it's also the best answer once you start trying to define what a repeating decimal is, I'd believe.
23:14:06 <newsham> here's how to convince stuborn collegues: proof by wikipedia.
23:14:10 <Pseudonym> I agree, given that it works for 0.333...
23:14:21 <omnId> In any case, the question isn't very interesting. :)
23:14:28 <ac> hum. now that I finally have the types right, nothing is getting printed. In fact, the whole do block doesn't seem to be running
23:14:32 <Pseudonym> Actually, I think it's really interesting.
23:14:44 <Pseudonym> Because it gets to the heart of what it means for two real numbers to be "equal".
23:14:53 <Pseudonym> Which isn't as obvious a question as it may at first appear.
23:14:55 <sieni> Tela: I would rather say that the decimal expansion is a notation for an (possibly) infinite sum.
23:15:08 <dibblego> my colleague's objection was "0.1111... is an approximation of 1/9"; which I think is very poor
23:15:11 <dibblego> so maybe I should give up
23:15:22 <ac> could printing a value from an IORef cause odd behavior lik ethat?
23:15:24 <Tela> sieni That's what I said as well :)
23:15:25 <omnId> Pseudonym: that's an interesting question, I think "what does 0.999... represent?" isn't as interesting.
23:15:53 <Pseudonym> Only in the sense that 0.1111... is a lexical approximation to a decimal representation of a certain real.
23:16:02 <newsham> how about SUM_1^{\inf} 9 / 10^i    ?
23:16:02 <sieni> By definition 0.1111... = \sum_{n=1}1^\infty 10^{-n}, which obviously is 1/9
23:16:14 <Pseudonym> onmId: And, in fact, there's lots of interesting "stuff" in the border between numbers and numerals.
23:16:15 <dibblego> yes I tried explaining "the concept of 0.111... is exactly equivalent to 1/9"
23:16:28 <dibblego> emphasising *the concept*
23:16:32 <oerjan> ac: doubtful, could you hpaste?
23:16:33 <Tela> dribblego If your colleague has a more engineering based mindset, it can be really difficult to demonstrate. I could never explain it to my dad because he always thought of an infinite decimal as meaning "as many more numbers as I need" instead of... infinite
23:16:59 <omnId> sieni: unfortunately I was never taught that repeating decimals are defined by infinite sums, and I didn't take enough maths to reason about infinite sums anyway.
23:17:02 <newsham> again I question the utility of explaining things to stuborn people
23:17:37 <Korollary> employment?
23:17:45 <newsham> omni: how about limits?  lim x -> inf of  1 - 1/10^x  ?
23:17:49 <hpaste>  ac pasted "gtk2hs timeout issues" at http://hpaste.org/3171
23:17:52 <Pseudonym> newsham: At that point, Huìnéng was enlightened.
23:17:54 <ac> oerjan: there it is
23:18:32 <omnId> repeating decimals to me were just "imagine it goes on forever".  Nothing quite so rigorous. :)
23:19:04 <Tela> Rigor is where all the "fun" is :D
23:19:12 <newsham> there's always a way to add rigormortis to your statements, omni
23:19:12 <omnId> I agree.
23:19:57 <Pseudonym> A monk asked Zhaozhou, "How is 0.999... equal to 1?"  Zhaozhou answered, "the ellipsis is three pounds of flax".  At that moment, the monk was enlightened.
23:20:16 <ac> oerjan: want me to add the rest of the gtk code?
23:20:21 <oerjan> ac: that's weird
23:20:38 <ac> oerjan: yeah, the "foo"s disappear when I uncomment that
23:20:45 <newsham> before he could put into practice some algorithm which he had learned, the only thing pseudonym feared was that he should learn some new algorithm first
23:21:52 <newsham> how dare I compare myself with pseudonym.  when he is told one thing he understands ten.  when I am told one thing I understand only two.
23:22:00 <Pseudonym> newsham: Mu.
23:22:27 <ac> this is irritating. Coding this was a breeze until I get to the simplest part... the event loop, and then all hell breaks loose
23:23:05 <oerjan> i don't think i know enough about gtk2hs to help much
23:23:12 <oerjan> (er, almost nothing? :D)
23:23:16 <Pseudonym> The trouble is, when I am told one thing, I understand ten things which are not what I am told.
23:24:25 <newsham> if you see the buddha on the road, kill the buddha
23:24:25 <Pseudonym> The thing which can be described is not the true thing.
23:24:57 <Tela> You know it's late at night on #haskell when discussion is mingled with Zen
23:25:01 <oerjan> only thing i can think of is if the IORef somehow gets mangled...
23:25:05 <Pseudonym> It's only 4:30pm here.
23:25:15 <dibblego> I can hear my colleagues arguing numbers in the distance
23:25:25 <Pseudonym> dibblego: Numbers or numerals?
23:25:26 <newsham> the buddha you meet is not the true buddha
23:25:37 <dibblego> Pseudonym, "point-nines"
23:25:43 <Pseudonym> Numerals, then.
23:25:48 <oerjan> ac: maybe you could paste the rest of main, just in case
23:25:50 <dibblego> yes that
23:26:04 <Pseudonym> Does the point-nine have Buddha nature?
23:26:10 <newsham> dibblego: wikipedia didnt shut em up?
23:26:13 <dibblego> I shall rub and see
23:26:21 <dibblego> newsham, no, I've given up anyway
23:26:31 <omnId> name a number between 0.999.. and 1
23:26:41 <Pseudonym> omnId: Mu.
23:26:46 <ac> oerjan: sure, just a minute
23:27:07 <newsham> there are an infinite number of numbers between 0.999 and 1.
23:27:14 <omnId> Pseudonym: you're alloted only one Mu per night, you've exhausted your supply.
23:27:19 <Pseudonym> Damn.
23:27:27 <Pseudonym> OK...
23:27:30 <Pseudonym> Mount Sumeru.
23:27:33 <Pseudonym> Better?
23:27:38 <oerjan> newsham: now you're being surreal.
23:27:41 <omnId> much
23:27:44 <Tela> You could go Chinese and pull a "wu". That might be cheating though
23:27:51 <newsham> there are an infinite number of numbers between any two reals
23:28:05 <newsham> wu-tang to that
23:28:15 <hpaste>  ac annotated "gtk2hs timeout issues" with "timeout issues with complete main" at http://hpaste.org/3171#a1
23:29:38 <ddarius> dibblego: What do they have to argue about?
23:29:47 <dibblego> ddarius, stubbornness I guess
23:29:58 <newsham> what is "it breaks" ?
23:30:12 <Pseudonym> ddarius: Geeks like arguing.
23:30:17 <ac> oerjan: I wonder if it's a bug. Do you have gtk2hs installed?
23:30:18 <omnId> Pseudonym: now that I think about it, the correct response that question is "Type mismatch: cannot unify Number and Numeral" :)
23:30:20 <Pseudonym> The less important the argument, the better.
23:30:29 <Pseudonym> omnId: Oh, good answer!
23:30:30 <dibblego> Pseudonym, so very true
23:30:38 <oerjan> nope, sorry
23:30:39 <ddarius> Pseudonym: About things that they are knowingly underqualified to discuss?
23:30:44 <Pseudonym> Of course!
23:30:48 <Pseudonym> Look at us discussing zen!
23:30:49 <dibblego> ddarius, knowingly is the important adverb there
23:31:08 <Pseudonym> Mind you, we're not arguing about Zen.
23:31:30 <dibblego> yes we are (no we're not)
23:31:36 <scodil> does anyone know a data structure that will let you store, say, tuples of ints, and let you query with sub-tuples? like if I put (4,6,7,8) in there i can query with (6,8) and it will find it
23:31:38 <Tela> Of course not. As geeks, we relegate all such "conversations" firmly to the category of discussion
23:31:45 <ddarius> Pseudonym: Exactly!  No one is saying "I don't know anything about Zen, but clearly this is the way Zen is."
23:31:54 <opqdonut> i have a nice one for you: 0.99999... = 1 <=> 9.999999... = 10  subtract these and we get 9=9!
23:32:03 <omnId> scodil: a list?
23:32:12 <Pseudonym> ddarius: Except that's probably correct.
23:32:18 <opqdonut> (not a proper proof of course)
23:32:29 <scodil> omnId: sorry, i meant to say, query in sub-linear time
23:33:01 <oerjan> scodil: Data.Set?
23:33:14 <oerjan> or Map
23:33:27 <Pseudonym> scodil: Did you mean lists, not tuples?
23:33:40 <ddarius> opqdonut: ?
23:33:41 <scodil> the keys are tuples
23:33:46 <scodil> or lists, whatever
23:33:57 <newsham> how about function?  f 4 6 = (7,8) ?
23:34:03 <Pseudonym> I don't think I understand the problem.  Haskell doesn't have "sub-tuples".
23:34:10 * Pseudonym is too brainwashed
23:34:16 <scodil> sets and subsets
23:34:16 <newsham> or maps of maps of maps?
23:34:44 <newsham> m `lookup` 4 `lookup 6 == (7,8) ?
23:34:58 <scodil> however they are represented, if 5/7/8/10 is a key, I want to be able to query for it with 8/5
23:36:06 <scodil> or 5/8
23:36:24 <scodil> its fine if there has to be a cannonical ordering
23:36:28 <oerjan> ac: maybe you could ask on haskell-cafe
23:36:51 <ac> oerjan: I think I might be getting somewhere... this might be embarrassing
23:37:50 <oerjan> anyway, afk
23:38:01 <StaticVec> don't leave me
23:38:36 * omnId leaves StaticVec
23:40:24 <ac> oerjan: ok, I deleted the binary, .o, and .hi files, recompiled it, and it worked
23:40:35 <ac> blarg!
23:41:14 <olsner> when in doubt, rebuild all ;-)
23:41:19 <newsham> ac: awesome.
23:42:53 <ac> however, in the process, I managed to tab complete the -o foo to -o foo.hs because that was the only file left, and I wiped out my code with the binary. Yay for backups
23:43:41 <newsham> this is where darcs/cvs/svn/etc would be good
23:44:24 <olsner> or a Makefile instead of manual compilation, if that was what took the -o option
23:53:47 <newsham> one thing I dont like about learning haskell is there are all these hidden gems out there that you have to stumble on by yourself
23:53:59 <newsham> like nobody says "go read 'applicative programming with effects'"
23:54:34 <omnId> what an awful curse
23:54:37 <newsham> or "a tutorial on the universality and expressiveness of fold"
23:55:02 <newsham> perhaps there should be a page on the wiki with a list of these intermediate papers that everyone shoudl read
23:55:08 <newsham> (maybe there is?)
