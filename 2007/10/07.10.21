00:00:05 <Pseudonym> > let nan = (0/0 - 0.0/0) in nan + 0 == nan
00:00:07 <lambdabot>  False
00:00:07 <Pseudonym> :-)
00:00:26 <dmwit> > let nan = 0.0/0 in nan == nan
00:00:27 <lambdabot>  False
00:00:31 <dmwit> So that hardly counts.
00:00:39 <Pseudonym> Yeah.
00:00:46 <dmwit> It might not fit (==), but it fits (===), which is what matters for optimization.
00:00:55 <Pseudonym> OK, I can think of one case.
00:01:13 <Pseudonym> If you evaluate a NaN, then turn on signalling NaNs, then add zero, then it traps.
00:01:19 <Pseudonym> If you don't, you get no trap.
00:01:22 <Pseudonym> Perhaps that's it.
00:01:26 <dmwit> o ho!
00:01:46 <dmwit> ?hoogle trap
00:01:47 <lambdabot> No matches found
00:01:51 <dmwit> =/
00:02:03 <dmwit> Anyway, I'm sure you can set traps in Haskell, so I believe that argument.
00:02:21 <Pseudonym> My memory on this is very vague.,
00:02:35 <Pseudonym> But that's certainly one case where it makes a difference.
00:03:14 <ablo> hello
00:03:31 <ablo> im very new to haskell...just wanted to ask u guys something
00:03:51 <dmwit> Hi ablo!  Ask away.
00:03:54 <bbrown> just a thought, it is amazing that haskell code can get compiled to object code; is there any future for a VM
00:04:15 <dmwit> That's a curious question.  What VM would you want it to run on?
00:04:17 <Pseudonym> bbrown: Hugs.
00:04:44 <bbrown> I should have said I am working with ghc
00:05:13 <bbrown> dmwit: someone would have to write one
00:05:17 <ablo> i have to display output as tabular form....
00:06:16 <ablo> PutStrLn in a specific location
00:06:32 <ablo> is it possible ...actually not using \t or space
00:06:55 <dmwit> ablo: Yes, but you'll need to use an appropriate library.
00:07:16 <ablo> i have private message u
00:07:42 <dmwit> I'm not sure about which library attacks this, though.
00:08:04 <Pseudonym> I should point out that lambdabot just uses GHCi.
00:08:12 <Pseudonym> To execute arbitrary code safely.
00:09:15 <dmwit> ablo: If you want something quick and dirty, you could keep track of the width of each column you need to output.
00:09:19 <dmwit> Then pad the rest with spaces.
00:15:26 <sorear> Pseudonym: uh.... no, lambdabot compiles to native codee
00:15:28 <hpaste>  shaf pasted "displayTabular" at http://hpaste.org/3406
00:15:44 <Pseudonym> > 1+2
00:15:47 <lambdabot>  3
00:15:51 <sorear> bbrown: WHY would you want to use a VM when you can use the real one?
00:15:51 <Pseudonym> sorear: You mean that?
00:15:55 <sorear> Pseudonym: yes.
00:16:03 <Pseudonym> OK, I did not know that.
00:45:37 <Flynsarmy> How to return the length of a String?
00:45:49 <dmwit> :t length -- ;-)
00:45:52 <lokimaf> > (pi'i) = (*)
00:45:56 <lambdabot>  Parse error
00:45:58 <lambdabot> forall a. [a] -> Int
00:46:09 <dmwit> > let (pi'i) = (*) in pi'i 3 4
00:46:14 <lambdabot>  12
00:46:30 <dmwit> ?check \xss -> xss == transpose (transpose xss)
00:46:30 <lambdabot>  Add a type signature
00:46:40 <lokimaf> > let (pi'i) = * in 2 pi'i 4
00:46:40 <lambdabot>  Parse error
00:46:50 <dmwit> ?check \xss -> (xss :: [[String]]) == transpose (transpose xss)
00:46:51 <lambdabot>  Falsifiable, after 3 tests: [[""],[]]
00:46:53 <lokimaf> > let pi'i = * in 2 pi'i 4
00:46:53 <lambdabot>  Parse error
00:47:16 <lokimaf> oh well
00:47:18 <dmwit> > let pi'i = (*) in 2 `pi'i` 4 -- parens around the (*) are required for partial application
00:47:20 <lambdabot>  8
00:47:51 <lokimaf> hmmm
00:47:52 <lokimaf> kk
00:49:03 <dmwit> Flynsarmy: Got it working?
00:49:24 <Flynsarmy> dmwit: yep, thanks :)
00:59:24 <Heffalump> ?check \xss -> and (zipWith (==) xss (tail xss)) ==> (xss :: [[String]]) == transpose (transpose xss)
00:59:26 <lambdabot>  Falsifiable, after 2 tests: [[]]
00:59:47 <Heffalump> ?check \xss -> and (zipWith ((==) `on` length) xss (tail xss)) ==> (xss :: [[String]]) == transpose (transpose xss)
00:59:48 <lambdabot>   Not in scope: `on'
01:00:27 <oerjan> @let on (+) f x y = f x + f y
01:00:31 <lambdabot> Defined.
01:00:59 <oerjan> try again
01:01:05 * dmwit waits for somebody else to retry Heffalump's ?check
01:01:44 <dmwit> ?check \xss -> and (zipWith ((==) `on` length) xss (tail xss)) ==> (xss :: [[String]]) == transpose (transpose xss)
01:01:45 <lambdabot>  Falsifiable, after 1 tests: [[]]
01:01:47 <dmwit> I lied.
01:03:55 <Heffalump> > transpose [[]]
01:03:57 <lambdabot>  []
01:04:04 <Heffalump> > transpose []
01:04:04 <dmwit> =(
01:04:05 <lambdabot>  []
01:04:26 <Heffalump> ?check \xss -> all (not . null) xs && and (zipWith ((==) `on` length) xss (tail xss)) ==> (xss :: [[String]]) == transpose (transpose xss)
01:04:27 <lambdabot>   Not in scope: `xs'
01:04:31 <Heffalump> ?check \xss -> all (not . null) xss && and (zipWith ((==) `on` length) xss (tail xss)) ==> (xss :: [[String]]) == transpose (transpose xss)
01:04:33 <lambdabot>  Arguments exhausted after 177 tests.
01:04:45 <Heffalump> well, that's some kind of evidence :-)
01:04:55 <dmwit> Yeah, that makes me happier. =)
01:07:51 <oerjan> > transpose . transpose $ [[1,2,3,4],[5,6],[7,8,9,10],[11]]
01:07:53 <lambdabot>  [[1,2,3,4],[5,6,9,10],[7,8],[11]]
01:08:22 <oerjan> > transpose . transpose $ [[1,2,3,4],[5,6],[7,8,9,10],[11,12,13,14,15]]
01:08:23 <lambdabot>  [[1,2,3,4,15],[5,6,9,10],[7,8,13,14],[11,12]]
01:08:38 <dmwit> um
01:09:08 <dmwit> > transpose . transpose $ [[1,2],[3]]
01:09:10 <lambdabot>  [[1,2],[3]]
01:09:19 <oerjan> almost like tetris blocks :)
01:09:22 <Syzygy-> > transpose . transpose .
01:09:22 <lambdabot>   parse error on input `}'
01:09:24 <Syzygy-> > transpose . transpose .
01:09:24 <lambdabot>   parse error on input `}'
01:09:25 <dmwit> > transpose [[1,2,3,4],[5,6],[7,8,9,10],[11]]
01:09:26 <lambdabot>  [[1,5,7,11],[2,6,8],[3,9],[4,10]]
01:09:36 <Syzygy-> > transpose . transpose $ [[1,2],[3],[4,5]]
01:09:37 <lambdabot>  [[1,2],[3,5],[4]]
01:09:37 <oerjan> they trickle up if there is room for them
01:10:07 <dmwit> Oh, I see.
01:10:16 <Syzygy-> Sorry for the double dud inputs. I just returned to a civilized keyboard, and have to unlearn the aussie/uk/us-sun-keyboard position of backspace.
01:10:18 <dmwit> There really is no reasonable value to put "in between" there.
01:10:52 <Heffalump> > transpose . transpose $ [[1,2,3],[4,5],[6]]
01:10:53 <lambdabot>  [[1,2,3],[4,5],[6]]
01:11:04 <Heffalump> ?check \xss -> all (not . null) xss && and (zipWith ((>=) `on` length) xss (tail xss)) ==> (xss :: [[String]]) == transpose (transpose xss)
01:11:05 <lambdabot>  Arguments exhausted after 213 tests.
01:11:13 <dmwit> Luckily, all my lists will have (map length xs == replicate (length xs) (length . head $ xs)), so... =)
01:11:40 <oerjan> Heffalump: argh, i was just going to do that!
01:12:28 <dmwit> > transpose [[],[],[]]
01:12:29 <lambdabot>  []
01:12:40 <dmwit> That really is unfortunate, though.
01:17:59 <Tela> Is it possible to use STM to have a recursive forked process which keeps popping off new recursed processes? I'm having trouble getting the types to work.
01:19:14 <hpaste>  Tela pasted "Recursing STM" at http://hpaste.org/3407
01:19:20 <Heffalump> Tela: you do the forking in IO, not STM (IIRC)
01:19:57 <Heffalump> yeah. It doesn't make sense to fork off stuff inside an atomically block, because you can't roll that back.
01:20:08 <Heffalump> Well, in principle you can, I guess, but I doubt STM handles that.
01:20:35 <dmwit> Only in #haskell would somebody consider rolling back a process fork.
01:20:52 <Heffalump> forkIO is just a thread fork
01:21:00 <dmwit> Oh, okay.
01:21:08 <oerjan> @remember dmwit Only in #haskell would somebody consider rolling back a process fork.
01:21:09 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
01:21:14 <Heffalump> but in either case, if you know the thing was pure, or had a restricted set of side-effects you can control, why not?
01:21:16 <oerjan> sheesh
01:21:34 <dmwit> Surely getRandItem isn't required to @remember things. =P
01:22:10 <Tela> Hm, oh well then.
01:24:11 <lokimaf> > 0x199
01:24:22 <lambdabot>  409
01:24:29 <lokimaf> > 0x200
01:24:30 <lambdabot>  512
01:24:32 <lokimaf> ?
01:24:37 <lokimaf> wtf?
01:24:40 <dmwit> > 0x1ff
01:24:42 <lambdabot>  511
01:24:43 <lokimaf> o
01:24:45 <lokimaf> oops
01:24:47 <dmwit> =)
01:24:48 <lokimaf> *blush*
01:44:09 <Cale> dmwit: what's unfortunate about it?
01:44:29 <dmwit> Cale: It's not wrong, just unfortunate.
01:44:31 <dmwit> It loses information.
01:44:49 <dmwit> I have no proposed better solution, though.
01:45:02 <Cale> transpose also loses information in other ways:
01:45:17 <Cale> > (transpose . transpose) [[1,2,3],[4,5],[6,7,8]]
01:45:18 <lambdabot>  [[1,2,3],[4,5,8],[6,7]]
01:45:29 <dmwit> Yes, we discovered this too.
01:45:37 <dmwit> It is a related problem, I think.
01:45:53 <Cale> I think that behaviour is actually kind of handy sometimes.
01:46:11 <oerjan> > transpose . transpose $ [[1,2,3],[],[]]
01:46:12 <lambdabot>  [[1,2,3]]
01:48:51 <dmwit> Cale: Do you have an example off-hand?
01:49:45 <Cale> Not really. However, the fact that it preserves the cases where the lengths of the lists are weakly decreasing is handy for working with Young tableaux.
02:08:59 <LeCamarade> Um ... how do I end the /query in BitchX? (This not being #bitchx or anythin).
02:10:15 <wilx> /close win number?
02:10:45 <LeCamarade>  /close is an unknown command in BitchX. :o(
02:11:38 <oerjan> in irssi it's /window close, if that helps
02:12:16 <LeCamarade> Oh. Nope.
02:12:19 * LeCamarade giveth up.
02:38:26 <Radek> Hello all. I have a question (newbie question). I have infinite list, my function accesses this list and reads some data. This function is called several times with different parameters, but it always reads almost same data from infinite list. Will entries in this list be always recomputed? Or is it chached? (ghc)
02:38:49 <Radek> chached = cached
02:39:03 <oerjan> usually not cached
02:39:13 <sjanssen> Radek: it depends on the circumstance
02:39:38 <sjanssen> Radek: a top level value is (almost) always shared
02:40:48 <Radek> Ok, maybe more specific question. I have list of 'primes' and the function that calculates factorials. Will primes be always recomputed?
02:40:57 <oerjan> um, wait, reading more carefully it sounds like your case may be cached.
02:41:26 <oerjan> i thought you were talking about function results :)
02:41:42 <sjanssen> Radek: if primes is a top level declaration, yes
02:42:13 <oerjan> if you give something a name and it is not polymorphic, then it will usually be shared
02:43:38 <Radek> sjanssen: I don't quite understand what's "a top level declaration"
02:44:01 <sjanssen> Radek: not in a let or where
02:44:17 <Radek> sjanssen: Ok, thanks
02:44:56 <Radek> oerjan: It is not polimorphic but computed using sieve. Like this: primes = sieve [2..]; sieve (p:rest) = p : sieve [n | n <- rest, n `mod` p /= 0]
02:45:23 <oerjan> should be fine then
02:45:35 <Radek> ok, thanks.. So it is not where the application is slow. ;)
02:45:50 <sjanssen> it's fine, thanks to the Dreaded Monomorphism Restriction! :)
02:47:01 <Radek> sjanssen: If I only knew what you are talking about.. ;) I'm just starting to learn haskell and it doesn't stop to amaze me. :)
02:47:45 <sjanssen> Radek: the monomorphism restriction is the rule that makes Haskell give primes a monomorphic type rather than a polymorphic one
02:47:58 <fatt> A question from here too. Any exp from Alex & happy available? Can you give any pointers how to implement stdin (my compiler syntax has possibility to import source files) change during parsing?
02:48:31 <Radek> sjannsen: Now, it rings a bell.. a bit.
02:48:53 <oerjan> it's the bell of DOOM *cackle*
02:49:00 <sjanssen> Radek: you don't need to know it yet, it's a warty and controversial part of the language
02:49:21 <sjanssen> Radek: hence the 'Dreaded' part :)
02:50:13 <Radek> I think that I read it somewhere.. but did not understand much. BTW. Are there any general hints on optimization of haskell code?
02:50:17 <KatieHuber> just when you think everything's OK, *bamf*, it makes you type a type signature :/
02:50:50 * wli recommends -fno-monomorphism-restriction and/or the equivalent pragma.
02:53:29 <oerjan> wli: how would that affect the sharing of primes, above?
02:53:57 <wli> I don't believe it would. It's just less surprising in general.
02:54:12 <oerjan> maybe you would then suddenly find yourself having to add a monomorphic type declaration to it...
02:54:43 <sjanssen> it would adversely affect sharing
02:55:12 <sjanssen> the primes example above is the poster child for the DMR
02:58:07 * wli can't say he's looked into it much.
03:34:14 <phlpp> hi
03:35:22 <raxas> 4
03:35:34 <raxas> sry, wrong window
03:36:06 <EvilTerran> i hope that's not your root password
03:36:17 <oerjan> for so many reasons
03:48:25 <magnusth> @hoogle [Maybe a] -> Maybe [a]
03:48:25 <lambdabot> No matches, try a more general search
03:48:54 <nornagon> @hoogle Monad m => [m a] -> m [a]
03:48:54 <lambdabot> Prelude.head :: [a] -> a
03:48:55 <lambdabot> Prelude.last :: [a] -> a
03:49:00 <nornagon> heh :)
03:49:21 <nornagon> :t sequence
03:49:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:51:02 <magnusth> thanks, nornagon
03:52:19 <nornagon> sequence and mapM are so cool
03:52:40 <nornagon> i love composing computations with list comprehensions and then executing them, it makes so much sense
03:58:51 <raxas> EvilTerran: fortunately, I use no root passwords, only ssh keys for remote logins and secured console for local ones
03:59:45 <puusorsa> hooray!
04:00:01 <puusorsa> nonsense makes sense
04:02:41 <opqdonut> hooray!
04:02:48 <opqdonut> puusorsa makes no sense!
04:04:15 <magnusth> @hoogle lookup
04:04:16 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
04:04:16 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
04:04:16 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
04:05:16 <fasta> I specified -M700m, but the program still allocates > 80% of my 1GB memory. Why?
04:06:07 <geocalc> try -M200m
04:06:27 <fasta> The actual problem I try to solve is that it starts to swap and in that case I already know it will never complete within the time I find acceptable.
04:06:43 <fasta> geocalc: is that based on experience?
04:06:51 <geocalc> no
04:07:08 <geocalc> just to know
04:07:19 <geocalc> :)
04:08:30 <geocalc> what is your problem fasta ?
04:10:39 <fasta> geocalc: the problem is that I want to get an exception when it goes above 700m, s.t. I can let the machine work on a different problem.
04:11:03 <fasta> geocalc: I tried 200m now, and it still doesn't work.
04:12:07 <vincenz> fasta: does your laptop come with an altitude meter?
04:12:11 <fasta> Can anyone explain why this doesn't work? ./Main  +RTS -H199m -M200m -A1m -RTS
04:12:30 <fasta> vincenz: very funny
04:12:40 <vincenz> fasta: I know :)
04:16:31 <geocalc> i have a solution à la vincenz fasta it is buy more memory hahaha, seriously i can't help
04:18:12 <magnusth> @hoogle isJust
04:18:13 <lambdabot> Maybe.isJust :: Maybe a -> Bool
04:18:28 <magnusth> @hoogle just
04:18:28 <lambdabot> Prelude.Just :: a -> Maybe a
04:18:28 <lambdabot> Maybe.fromJust :: Maybe a -> a
04:18:28 <lambdabot> Maybe.isJust :: Maybe a -> Bool
04:18:51 <geocalc> is there no systeme function to read the used mem in ghc fasta ?
04:21:31 <geocalc> btw fasta you want your app answer in some time so control on it et voila
04:23:47 <geocalc> no ?
04:27:04 <dcoutts> @seen bringert
04:27:05 <lambdabot> bringert is in #ghc and #haskell. I don't know when bringert last spoke.
04:27:08 <dcoutts> bringert: ping
04:27:32 <bringert> dcoutts: hi
04:27:49 <dcoutts> bringert: hia, I'd like to release tar today, along with a load of other things
04:27:56 <dcoutts> bringert: do you want to do the tar release?
04:28:51 <dcoutts> bringert: and if possible we should release cabal-install too
04:29:19 <bringert> dcoutts: unfortunately I won't have any time at all in the next few days
04:29:39 <bringert> dcoutts: you are welcome to make new releases of whatever you want though
04:29:42 <dcoutts> bringert: ok
04:30:56 <phlpp> > filter (\x -> x != ' ') "8C TS KC 9H 4S 7D 2S 5D 3S AC"
04:30:58 <lambdabot>   Not in scope: `!='
04:31:02 <phlpp> > filter (\x -> x /= ' ') "8C TS KC 9H 4S 7D 2S 5D 3S AC"
04:31:04 <lambdabot>  "8CTSKC9H4S7D2S5D3SAC"
04:31:15 <phlpp> > drop 10 $ filter (\x -> x /= ' ') "8C TS KC 9H 4S 7D 2S 5D 3S AC"
04:31:17 <lambdabot>  "7D2S5D3SAC"
04:32:11 <EvilTerran> > concat.words $ "8C TS KC 9H 4S 7D 2S 5D 3S AC"
04:32:12 <TSC> You could replace the call to filter with "concat . words"
04:32:13 <lambdabot>  "8CTSKC9H4S7D2S5D3SAC"
04:32:16 <TSC> See? (:
04:32:16 <EvilTerran> :D
04:32:26 <phlpp> :D
04:32:29 <phlpp> thans
04:32:30 <EvilTerran> although that'd strip tabs, too.
04:32:34 <phlpp> *thanks*
04:32:39 <phlpp> there are no tabs
04:32:44 <phlpp> just whitespace seperation
04:32:51 <phlpp> separation.. eh
04:33:01 <TSC> Probably clearest is (filter (not . isSpace))
04:33:35 <EvilTerran> @index isSpace
04:33:35 <lambdabot> Data.Char
04:33:45 <phlpp> filter (not.isSpace) "8C TS KC 9H 4S 7D 2S 5D 3S AC"
04:33:56 <phlpp> > filter (not.isSpace) "8C TS KC 9H 4S 7D 2S 5D 3S AC"
04:33:56 <phlpp> :>
04:33:57 <lambdabot>  "8CTSKC9H4S7D2S5D3SAC"
04:48:05 <krishnbhakt> any new lecture videos from simon
04:51:33 <magnusth> @hoogle filter
04:51:33 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
04:51:34 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
04:51:34 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
04:55:47 <fasta> geocalc: it appears that it gets killed my the OS because it takes too much resources.
04:56:15 <fasta> geocalc: i.e. it allocates a gigantic amount of memory (and no amount of memory that one can buy will help with that)
04:56:56 <fasta> Well, a petabyte of memory would help, I guess.
04:58:42 <Heffalump> not really, where would you put it?
04:59:20 <fasta> Heffalump: have you followed the discussion?
04:59:46 <fasta> This was the question: "Can anyone explain why this doesn't work? ./Main  +RTS -H199m -M200m -A1m -RTS"
04:59:59 <Heffalump> no. I was just responding to your comment about a petabyte helping.
05:00:02 <fasta> The manual states that -M was designed for what I want.
05:00:14 * wli thinks it would be cool to hammer out a toy evaluator with a module system based on some type system or other.
05:00:23 <fasta> Only problem being that it doesn't work :(
05:00:24 <Heffalump> I did read your question but I have no more idea about the RTS than you do (and probably much less)
05:00:30 <Beelsebob> Hmmm
05:00:48 <Beelsebob> I need a good example of a program where lazy evaluation order results in a somewhat surprising or confusing evaluation order
05:00:57 <wli> (One of those type systems for modules, that is.)
05:01:03 <Beelsebob> any suggestions
05:02:12 <hpaste>  fasta pasted "for Beelsebob" at http://hpaste.org/3408
05:03:13 <Beelsebob> fasta: interesting... let me run that through hat-anim to find out what it does, because I certainly expect a straightforward evaluation order there
05:03:17 <fasta> Beelsebob: if you can predict what it does without running it, it's not confusing for you otherwise, it is.
05:03:25 <fasta> Beelsebob: hat-anim doesn't work, I think
05:03:31 <Beelsebob> oh?
05:03:36 <Beelsebob> if it doesn't, it's my fault
05:03:36 <fasta> Beelsebob: if it does... I want to see it too :)
05:03:38 <Beelsebob> so I'll fix it
05:03:59 <fasta> Beelsebob: Last time I wanted to understand that program I wrote it out by hand.
05:04:11 <fasta> But there's little fun in that, I can tell you that.
05:04:34 <fasta> Beelsebob: you develop hat?
05:04:45 <fasta> Since when is hat under development again?
05:04:54 <Beelsebob> fasta: I do, but only because it's part of my research
05:05:19 <Beelsebob> @index forever
05:05:20 <lambdabot> bzzt
05:05:24 <fasta> Beelsebob: what do you expect before running it?
05:05:24 <Beelsebob> @hoogle forever
05:05:25 <lambdabot> No matches found
05:05:35 <fasta> forever is in Control.Monad
05:05:44 <Beelsebob> ah, okay
05:06:16 <Beelsebob> I expect that it prints "Foo 1 " and stops, while it infinitely adds 1 to b
05:06:23 <Beelsebob> but I may well be being naïve
05:07:19 <fasta> Beelsebob: well, then it's a good example, I guess.
05:07:28 <Beelsebob> hehe
05:07:41 <Beelsebob> hmm, forever doesn't appear to be in Control.Monad
05:07:44 <Beelsebob> or at least, not hat's
05:07:53 <Beelsebob> @src forever
05:07:53 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
05:08:14 <fasta> Beelsebob: forever a = a >> forever a
05:09:53 <fasta> Hmm, maybe this is the wrong program.
05:10:06 <Beelsebob> gyah
05:10:11 <Beelsebob> I seem to have broken something
05:10:17 * Beelsebob wonders why Hat is not installing properly
05:10:23 <fasta> I intended this to create a space leak (which it did in 6.7)
05:10:34 <Beelsebob> okay
05:10:43 <Beelsebob> what would you exect happens?
05:10:45 <Beelsebob> on paper?
05:11:33 <fasta> Beelsebob: oh, right.
05:11:42 <fasta> Beelsebob: you need to remove the strictness annotations.
05:11:53 <Beelsebob> okay
05:11:55 <Beelsebob> done
05:12:08 * Beelsebob gets out pen and paper and does the evaluation
05:12:18 <fasta> Beelsebob: then if you compile it (but I think ghci does too), it will create a huge space leak.
05:13:05 <fasta> Beelsebob: if you just look at it and ask someone what it does, then most people will say naively that it will just run like a C while(true) loop.
05:13:17 <Beelsebob> indeed
05:13:23 <Beelsebob> increment b and do nothing
05:13:25 <Beelsebob> never stop
05:13:44 <fasta> Beelsebob: do not run this program to long, since it can bring down a machine.
05:13:50 <fasta> too*
05:13:57 <Beelsebob> at the moment, ghc is having some trouble compiling it
05:14:03 <fasta> ?
05:15:01 <Beelsebob> ambiguous type variable b in the constraint: `show b' arising from use of show (obvious place)
05:15:17 <Beelsebob> it seems to think that foo :: (b, Foo)
05:15:18 <fasta> Beelsebob: enable extensions
05:15:39 <Beelsebob> same error
05:16:22 <fasta> Beelsebob: PEBKAC or try different compiler version
05:16:35 <Beelsebob> not got a different compiler version
05:16:44 <fasta> What version do you have?
05:16:48 <Beelsebob> 6.6.1
05:16:53 <dcoutts> bringert: oh and we need a new HTTP release too
05:16:55 <fasta> I have that too, I will try that too.
05:17:02 <dcoutts> bringert: for cabal-install
05:17:20 <fasta> dcoutts: is it possible that STArray's are not counted as space on the heap?
05:17:21 <hpaste>  beelsebob pasted "is there pebkac here" at http://hpaste.org/3409
05:17:33 <bringert> dcoutts: sure. there are some new patches in darcs that ought to be release anyway
05:17:37 <dcoutts> bringert: though that can wait a day or two, since we also need zlib and that requires cabal-1.2.1 to be installed on hackage, and I only just uploaded cabal-1.2.1
05:17:55 <dcoutts> bringert: so we need to ask ross to update hackage to use cabal-1.2.1
05:18:04 <dcoutts> before I can upload zlib
05:18:08 <bringert> dcoutts: sounds good
05:18:24 <dcoutts> bringert: should I leave the http release to you then?
05:18:32 <dcoutts> bringert: we don't need it for a couple days
05:18:41 <bringert> dcoutts: you
05:18:44 <bringert> eh
05:19:00 <Beelsebob> :t runState
05:19:02 <bringert> dcoutts: you're welcome to do it
05:19:06 <dcoutts> bringert: ok
05:19:07 <lambdabot> forall s a. State s a -> s -> (a, s)
05:19:07 <Beelsebob> @type runState
05:19:09 <lambdabot> forall s a. State s a -> s -> (a, s)
05:19:11 <Beelsebob> oh, being slow
05:19:12 <fasta> Beelsebob: I think my forever type is incorrect.
05:19:28 <fasta> Beelsebob: that's the only thing that's different
05:19:38 <Beelsebob> okay, well, what module is it in?
05:19:45 <Beelsebob> ghc agrees it's not in Control.Monad
05:19:59 <Beelsebob> the other definition I've seen is fix (>>)
05:19:59 <dcoutts> bringert: would it be version 3001.0.0 or what? what was the last released one? do we have to bump the version at all?
05:20:17 <bringert> dcoutts: I think all releases should have different version numbers
05:20:27 <bringert> dcoutts: otherwise all sorts of things break
05:20:40 <dcoutts> bringert: absolutely they should, I'm wondering what the right next version number is
05:21:14 <dcoutts> bringert: do you only do releases on hackage now? is that the only place I have to look to check for numbers of past releases?
05:21:18 <roconnor> @seen ddarius
05:21:18 <lambdabot> I saw ddarius leaving #haskell, #haskell-overflow and #haskell-blah 5h 30s ago, and .
05:21:21 <Beelsebob> fasta: runState returns a tuple... what is the first element meant to be?
05:21:28 <fasta> Beelsebob: forever is in the new mtl
05:21:29 <bringert> dcoutts: yes
05:21:41 <bringert> dcoutts: I think 3001.0.0 is fine
05:21:43 <fasta> Beelsebob: read the manual
05:21:43 <dcoutts> bringert: in which case it's only 3000.0.0 which was the last release, so we can make this one 3001.0.0 ?
05:21:46 <dcoutts> bringert: ok
05:22:05 <Beelsebob> @doc runState
05:22:06 <lambdabot> runState not available
05:23:47 <roconnor> @tell ddarius Were you the one who wanted to have a review of that Geometric Algebra textbook?
05:23:48 <lambdabot> Consider it noted.
05:24:12 <fasta> Beelsebob: ./base/Control/Monad.hs
05:24:21 <fasta> Beelsebob: it's in base.
05:24:28 <olsner> roconnor: have you reviewed a textbook but don't remember who asked you to?
05:24:38 <Beelsebob> why is ghc complaining about it's non-existance then?
05:24:50 <fasta> Beelsebob: I already told you
05:25:15 <fasta> Beelsebob: it only exists in >=6.7
05:25:17 <Beelsebob> thomas-davies-computer:~/Desktop tatd2$ ghc -fglasgow-exts -package base test.hs
05:25:18 <Beelsebob> test.hs:7:12: Not in scope: `forever'
05:25:21 <Beelsebob> oh, okay
05:25:26 <Beelsebob> didn't see you say that
05:25:43 <Beelsebob> so hang on
05:25:46 <fasta> forever     :: (Monad m) => m a -> m ()
05:25:46 <fasta> forever a   = a >> forever a
05:25:53 <fasta> Beelsebob: it needs a type signature
05:26:01 <fasta> Beelsebob: my definition was correct, though
05:26:15 <Beelsebob> cool
05:26:18 <Beelsebob> oh arse
05:26:26 <Beelsebob> my ghc install appears to be screwed
05:26:47 <fasta> Beelsebob: probably not
05:26:48 <roconnor> olsner: something like that
05:26:53 <Beelsebob> ld just exploded complaining that all the Control.Monad.State functions are missing
05:27:11 <roconnor> olsner: I've read through the text, and hence can now comment about it.
05:27:15 <fasta> Beelsebob: ok, that looks like a broken system, yes.
05:27:18 <hpaste>  beelsebob pasted "splode" at http://hpaste.org/3410
05:27:20 <Saizan> --make?
05:27:22 <geocalc> -v
05:27:34 <fasta> Oh, right
05:27:46 <Beelsebob> oh, okay, why do I need --make for that?
05:27:47 <fasta> Probably you just need to do --make, indeed.
05:27:50 <Saizan> or -package mtl
05:27:56 <fasta> Beelsebob: because it otherwise doesn't link
05:28:12 <Saizan> you need both base and mtl
05:28:17 <Beelsebob> oh, okay
05:28:19 <Beelsebob> oddness
05:28:29 <fasta> Saizan: in >=6.7 you don't need those packages at the command line
05:28:32 <Beelsebob> in the mean time... yes, I see that causes RAM explosion
05:28:43 <Saizan> fasta: even without --make?
05:28:56 <fasta> Saizan: then you probably do need it, I don't know
05:29:01 <roconnor> @unmtl ContT StateT ErrorT IO
05:29:01 <lambdabot> (IO -> ErrorT StateT) -> ErrorT StateT
05:29:05 <Beelsebob> so fasta in the absence of hat-anim, what is actually happening there?
05:29:19 <roconnor> @unmtl ContT r StateT s ErrorT e IO
05:29:19 <lambdabot> err: Unknown MTL(4)
05:29:35 <Beelsebob> is it not doing the C style while(true)?
05:29:36 <Saizan> that the b field of Foo becomes an huge unevaluated thunk, right?
05:29:51 <roconnor> @unmtl ContT StateT s ErrorT e IO
05:29:51 <lambdabot> err: Unknown MTL(4)
05:30:21 <fasta> Saizan: AFAICR, yes.
05:30:41 <bringert> dcoutts: sorry about the xmonad== thing
05:30:56 <bringert> dcoutts: I must have forgotten to test after that change
05:31:20 <fasta> Where are STArrays allocated?
05:31:23 <dcoutts> bringert: no probs, was easy to fix
05:31:29 <kolmodin> bringert: hey!
05:31:48 <fasta> Well, they should go to the heap, but I don't think they get counted.
05:32:28 <bringert> kolmodin: hi
05:33:04 <EvilTerran> @unmtl ContT (StateT s (ErrorT e (IO a)))
05:33:04 <lambdabot> ContT (StateT s (ErrorT e (IO a)))
05:33:35 <kolmodin> bringert: how's the little one doing? :)
05:33:37 * fasta should get a reprogrammable IRC client and filter all the unmtl commands from it
05:33:57 * EvilTerran has no idea why that one didn't work
05:34:29 <EvilTerran> **ctcp version's** ... i'd expect irssi to be programmable enough to do that
05:34:37 <bringert> kolmodin: on my shoulder atm
05:34:42 <roconnor> EvilTerran: (ErrorT e (IO a))) can't be right.
05:34:50 <roconnor> (ErrorT e IO)?
05:34:54 <EvilTerran> ah
05:34:56 <kolmodin> bringert: ah, XP programming. you need to teach them early
05:35:23 <EvilTerran> @unmtl (ContT r (StateT s (ErrorT e IO))) a
05:35:24 <lambdabot> (a -> s -> IO (Either e (r, s))) -> s -> IO (Either e (r, s))
05:35:32 <bringert> kolmodin: not coding, trying to feed him. but my laptop keeps going 'blip'
05:35:36 <bringert> bbl
05:35:40 <EvilTerran> roconnor, there you go
05:35:43 <kolmodin> aye
05:35:59 <roconnor> \o/
05:36:09 <Beelsebob> @src runState
05:36:09 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
05:36:13 <Beelsebob> gyah
05:37:07 <EvilTerran> isn't runState = flip ($) or something?
05:37:29 <EvilTerran> ?type runState
05:37:38 <lambdabot> forall s a. State s a -> s -> (a, s)
05:38:32 <roconnor> I'd rather have the reverse of unmtl ... ununmtl
05:38:42 <roconnor> @mtl (a -> s -> IO (Either e (r, s))) -> s -> IO (Either e (r, s))
05:38:43 <lambdabot> Maybe you meant: ft map msg pl unmtl url
05:39:15 <EvilTerran> i think that might be undecidable
05:39:24 <roconnor> :(
05:43:55 <Beelsebob> fasta: I'm completely missing what's happening here
05:44:13 <Beelsebob> mostly I suspect because I don't know the state monad
05:44:33 <fasta> Beelsebob: well, fantastic. That means the example is good.
05:44:51 <Beelsebob> fasta: not really, becasue I need to be able to explain why the evaluation order is not what's expected
05:44:54 <Beelsebob> and why it's confusing
05:45:42 <fasta> Beelsebob: then find a less confusing example or do some work. You should do some work for your thesis, right?
05:45:50 <Beelsebob> plausable
05:46:44 <Beelsebob> but now I'm interested in this example
05:46:48 <shachaf> Beelsebob: runState is defined in the newtype, I think.
05:46:48 <fasta> I am completely confused however why my program doesn't throw a heap overflow exception why the simple approximation of that program does.
05:47:09 <shachaf> newtype State s a = State { runState :: s -> (a,s) }
05:47:20 <fasta> Beelsebob: you can see the source for everything if you either do a GHC checkout or browse it on the web.
05:47:20 <shachaf> Something like that.
05:47:24 <Beelsebob> shachaf: that defines it's type... not what it is
05:47:42 <Beelsebob> fasta: I can't find the source for runState anywhere
05:48:00 <shachaf> Beelsebob: It's just a record accessor.
05:48:30 <fasta> while*
05:48:31 <shachaf> data Point = Point { x :: Int, y :: Int }
05:48:40 <shachaf> That defines the functions x and y.
05:48:49 <shachaf> @source Control.Monad.State
05:48:49 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
05:49:14 <shachaf> @source Control.Monad.State.Lazy
05:49:14 <lambdabot> Control.Monad.State.Lazy not available
05:49:27 <Beelsebob> shachaf: sure, but runState should then have the type (State s a) -> s -> (a,s)
05:49:34 <Beelsebob> which extracts the first element from the record
05:49:39 <Beelsebob> but what *is* that first element
05:49:43 <shachaf> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
05:49:53 <shachaf> Beelsebob: It's a function :: s -> (a,s).
05:49:57 <Beelsebob> indeed
05:50:02 <Beelsebob> but how is it defined
05:50:14 <fasta> Ok, I set a maximum stack size and a maximum heap size. Why does it still use more memory than the sum of those two?
05:50:20 <Beelsebob> it takes a State, and magically produces a function, of that type?
05:50:24 <Beelsebob> where is this function defined?
05:50:26 <fasta> dcoutts: do you have any idea on that?
05:50:32 <shachaf> > (State (\s -> (s,s))) `runState 5
05:50:32 <lambdabot>  Parse error
05:50:33 <EvilTerran> a State *is* a function of that type
05:50:34 <shachaf> > (State (\s -> (s,s))) `runState` 5
05:50:36 <lambdabot>  (5,5)
05:50:38 <Heffalump> Beelsebob: that depends on how the State was constructed
05:50:40 <shachaf> Beelsebob: You define that function.
05:50:50 <shachaf> Beelsebob: There are some primitives, such as get, put, return, (>>=).
05:50:54 <EvilTerran> the state is threaded by function composition
05:51:04 <EvilTerran> it's really rather cunning/elegant
05:51:21 <EvilTerran> not quite as nice as Reader, but still quite cool
05:51:23 <Heffalump> and completely standard for a state monad
05:51:38 <Beelsebob> shachaf: can you give me a simple example?
05:51:55 <Saizan> Beelsebob: it's like data State s a = State (s -> (a,s)); runState (State f) = f, so the "function" is the one built by forever using Monad methods
05:51:58 <Heffalump> Beelsebob: would you be asking how the function returned by id applied to something of type s -> (a, s) is defined?
05:52:24 <shachaf> Beelsebob: I gave one: get.
05:52:25 <shachaf> @src get
05:52:25 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
05:52:28 <shachaf> @src State get
05:52:28 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
05:52:31 <fasta> Beelsebob: also: what's the point of including an example that everyone who already programs in Haskell and reads mailing lists has already seen in your master thesis?
05:52:39 <Saizan> e.g. modify f = State (\s -> ((),f s))
05:52:49 <Beelsebob> Saizan: oh, hang on, I see where I'm confused
05:53:08 <shachaf> get = State (\s -> (s,s))
05:53:21 <EvilTerran> the state isn't what's stored in a State, it's the stateful computation
05:53:58 <shachaf> It's a function that gets some state and returns a tuple of that state (as a return value) and that state (as a state).
05:54:25 <shachaf> So it doesn't change the state at all, but returns (as the first element of the tuple) what it contains.
05:54:48 <shachaf> Then you have put: put x = State (\s -> ((),x))
05:56:05 <shachaf> It gets some value, and then returns a function (wrapped in a State constructor) that gets some state, ignores it, and returns () (as a return value) and the original argument to put (as a state).
05:57:19 <Beelsebob> okay, so (forever $ modify (\(Foo a b) -> Foo a (b+1))) constructs an infinite computation
05:57:24 <Beelsebob> but never actually applies it
05:57:34 <Beelsebob> (beacuse it's busy constructing it)
05:58:05 <Beelsebob> that is somewhat surprising
05:59:35 <Saizan> well no,
05:59:38 <bringert> dcoutts: it's weird that parsePackageId allows "xmonad". I didn't think it did
06:02:25 <Heffalump> well, it'll be lazy until you inspect the Foo.
06:02:38 <Saizan> uuhm, i'm not sure, but State should be lazy enough to permit the computation to start executing, but you get a space leak since you construct values like (Foo 1 (1+1+1+1+1.....))
06:03:05 <Beelsebob> Saizan: that's what I'd expect
06:03:18 <Beelsebob> but fasta is saying something is going on that you wouldn't expect
06:03:34 <Beelsebob> but I don't know the state monad well enough to actually see what it is
06:04:00 <Saizan> well, you said you expected Foo 1 printed, that never happens
06:04:04 <Beelsebob> indeed
06:04:19 <Beelsebob> but I see why that doesn't happen
06:04:22 <Heffalump> Saizan: you won't get a space leak until you try to inspect the state, at which point your program will diverge anyway
06:04:27 <Beelsebob> in that it can't figure out the whole state
06:04:38 <Beelsebob> the Foo 1 part is a different Foo 1 in ever state
06:04:44 <Heffalump> it doesn't happen for the same reason that fix id never terminates
06:04:55 <Saizan> Heffalump: yes, but with a seq it would diverge without wasting memory
06:05:21 <Heffalump> Saizan: only if the fields of Foo are strict, I think
06:05:36 <Heffalump> cos Foo <suspension> <suspension> is in WHNF otherwise.
06:05:55 <Heffalump> or do you mean with a seq on the y+1 ?
06:06:00 <Heffalump> s/y+1/b+1/
06:06:00 <Saizan> exactly
06:06:23 <fasta> Both work I think
06:06:32 <Saizan> modify (\(Foo a b) -> let b' = b+1 in b' `seq` Foo a b')
06:07:25 <Beelsebob> but that essentially makes the second argument of Foo strict anyway
06:07:45 <Beelsebob> it's just a somewhat less obvious way of writing it
06:08:06 <Saizan> yes, "locally" strict
06:08:42 <Beelsebob> yeh, but as it's the only locality where it's ever updated, it's essentially globaly strict
06:08:52 <Beelsebob> but I see your point
06:09:02 <Beelsebob> we could in theory write another function that didn't need the second argument to be strict now
06:12:33 <roderyk> types 101: why does this fail?
06:12:33 <roderyk> fn :: FilePath -> String; fn f = do;   contents <- readFile f; contents
06:13:13 <MyCatVerbs> That wants to be fn :: FilePath -> IO String.
06:13:21 <Beelsebob> and you want to return the contents
06:13:53 <Saizan> essentially: fn = readFile
06:14:19 <Beelsebob> you could however write unsafeFn :: FilePath -> String; unsafeFn f = unsafePerformIO (readfile f)
06:14:24 <roderyk> but if I change it to FilePath -> IO String, it complains that it inferred String while I'm asking it to be IO String?
06:14:32 <Beelsebob> but that would have the normal tags about unsafeness associated with it
06:14:48 <Beelsebob> roderyk: yeh, you need to return contents
06:14:52 <Beelsebob> to wrap it in the monad
06:15:10 <Beelsebob> fn :: FilePath -> IO String; fn f = do contents <- readFile f; return contents
06:15:16 <Beelsebob> but that's just readFile
06:15:17 <Saizan> roderyk: you can't take a value out of the IO monad, you can only bind it to a name with <- in do-notation, but you've to rewrap it in the IO monad
06:15:20 <Beelsebob> so a pretty boring function
06:15:50 <roderyk> Saizan: ah, ok. I think I understand.
06:15:54 <Beelsebob> roderyk: if this happens to be in a particular place where you know this is a "safe" operation
06:16:06 <roderyk> the key is the unsafePerformIO.... time for more reading. thanks :)
06:16:09 <Beelsebob> then you could always just wrap unsafePerformIO
06:16:17 <Beelsebob> but you *must* be sure it's safe
06:16:26 <Beelsebob> or all bets are off about your program's behaviour
06:17:02 <roderyk> Beelsebob: thanks a bunch, I will stick to readFile for now; was just curious about the behavior
06:17:09 <Saizan> http://www.haskell.org/haskellwiki/Introduction_to_IO
06:17:11 <lambdabot> Title: Introduction to IO - HaskellWiki
06:17:36 <Beelsebob> I have to admit, I wrap raedFile in unsafePerformIO a lot actually
06:18:02 <Beelsebob> in that it's usually the end of a non-IO computation, that I've figured out where things are going wrong, and want to grab the relevant bit out of the file
06:18:03 <Saizan> heh, readFile itself uses unsafeInterleaveIO
06:20:54 <roderyk> I think I'm beginning to understand vaguely. since main itself is IO (), it essentially rewraps the monad for you
06:21:03 <Beelsebob> yep
06:21:36 <Beelsebob> when I learned about IO, I found that the easiest way to think about it is the conceptual idea that things in the IO monad have an invisible "world" parameter
06:21:48 <Beelsebob> so putStrLn takes a world, and a string
06:21:52 <Beelsebob> and modifies the world
06:22:02 <Beelsebob> (gives you back a new world in which the line is printed)
06:22:53 <Beelsebob> readFile takes a world, and a path, fishes about in the world, giving you back the contents of that file, and then gives back an essentially unchanged world, and the contents
06:23:42 <smack__> Beelsebob: the world is always changed
06:23:54 <Beelsebob> smack__: yes, but with readFile it isn't changed in a discernable way
06:24:27 <Saizan> well, your kernel has opened a file descriptor for you
06:24:55 <Beelsebob> true enough
06:25:20 <smack__> it's changed enough that the next call to readFile isn't guaranteed to return the same value
06:25:21 <roderyk> as well as trimming a little of your HD's total life
06:25:35 <Beelsebob> smack__: indeed
06:27:33 <ToxicFrog> And the file access timestamp might be updated, etc
06:28:19 <sioraiocht> lambdacats, eh?
06:28:52 <Saizan> another way is to think that IO Foo is a small imperative program that gives you a Foo when executed, and in haskell we use do-notation to compose this small programs into our main that we feed to the runtime system
06:28:56 <fasta> Hmm, finally I found the bug in the RTS.
06:29:38 <fasta> Well, I found a test case, since the RTS seems rather complex ;)
06:30:30 <roderyk> how does one import a module in ghci?
06:30:45 <fasta> Hmm, this is not good; Gnome crashed I think
06:30:45 <Beelsebob> roderyk: :module + <module>
06:31:19 <Beelsebob> Saizan: I find that rather an unhealthy way of describing it -- in that you do not necessarily have to use the do notation, and evaluation will not necessarily occur in the order you "imperatively" specify
06:32:04 <jedbrown> Anyone know how to get Auctex to work with literate haskell (probably using mmm-mode)?
06:33:07 <Saizan> Beelsebob: well do-notation was an alias for Monad methods, and the imperative parts will occur in that order
06:34:01 <Beelsebob> Saizan: will they? do let a = [1..]; b <- readFile "Jam.txt"; return b
06:34:20 <Beelsebob> surely that non-terminates if they're evaluated in the order you would expect
06:34:22 <Saizan> a is not of type IO
06:34:41 <Saizan> it's not a computation connected with main
06:34:42 <Beelsebob> but it is in the do block... ie the bit you'd expect to act "imperatively"
06:34:51 <Beelsebob> but it does not act in any way imperatively
06:35:49 <Saizan> well, i've not been very clear, but i've not said that do-blocks are imperative, but that we use them to compose imperative programs
06:36:04 <Beelsebob> yeh, sure
06:36:14 <Beelsebob> but I don't think it's the healthiest thing to tell someone learning the IO monad
06:36:24 <mrd> :t evaluate
06:36:26 <lambdabot> Not in scope: `evaluate'
06:36:38 <Beelsebob> in that certainly if I were told that when I were learning it I would assume that lazy evaluation went out the window
06:37:38 <Saizan> in fact IO should be strict
06:37:48 <Beelsebob> why?
06:38:14 <Beelsebob> you can use strictness annotations if you want strict IO
06:38:36 <fasta> The RTS should be modified to cope with lazy I/O for real applications.
06:38:43 <roderyk> Beelsebob: are you recommending people just getting the hang of Monads stick to >> / >>= notation and avoid the 'do' construct?
06:39:23 <fasta> Currently, reading 1000 files lazily will use up all the file descriptors.
06:40:04 <fasta> roderyk: there's nothing wrong with do notation
06:40:22 <fasta> roderyk: at least nothing important.
06:40:38 <fasta> roderyk: it's nice to know what it desugars to, but that's about it
06:40:45 <Beelsebob> roderyk: net necessarily, but I don't think it does any harm
06:41:02 <fasta> There have been blog posts about how horrible it is, but well you know blog posts...
06:41:17 <shachaf> roderyk: I'd say the reverse: It's nice to know what >>/>>= can be sugared to, but that's about it.
06:41:25 <Beelsebob> for example it would have been clear that readFle x >>= \y -> return y was the same as simply readFile
06:41:27 <shachaf> s/roderyk/fasta/
06:42:02 <fasta> shachaf: it doesn't really matter which side you know.
06:42:18 <fasta> Both can be used to solve wonderful problems.
06:42:52 <Beelsebob> my suggestion is to know both sides
06:42:57 <shachaf> Understanding just do-notation isn't very useful, compared to understanding the desugared version.
06:42:59 <Beelsebob> and be able to decide not to use either of them well
06:43:06 <shachaf> Once you do, do-notation is trivial.
06:43:20 <fasta> I wonder whether there's any RTS that does lazy IO in a more sane way.
06:43:51 <fasta> shachaf: you can write the same programs with them.
06:45:23 <shachaf> fasta: You can't have a real understanding of do-notation without understanding what it desugars to.
06:49:48 <pejo> shachaf, why can't an operational/denotational semantics be given to the do-notation, excluding the desugared stuff?
06:52:00 <roderyk> here's an idiom I'm missing:
06:52:02 <shachaf> pejo: Well, it could work, maybe, but I doubt it'd work in Haskell.
06:52:03 <roderyk> let lst = [1,2,3,0,4,5,6]; a = takeWhile (/= 0) lst; b = drop (length a) lst in a ++ [0,0,0] ++ b
06:52:11 <roderyk> [1,2,3,0,0,0,0,4,5,6]
06:52:25 <pejo> shachaf, why?
06:52:48 <roderyk> the idea is I want to arbitrarily split the list at some point, but I don't want to go through it twice (drop $ length a ..) to get the second part
06:52:54 <roderyk> is there a better idiom for this?
06:53:03 <olsner> splitAt
06:53:25 <olsner> > splitAt 7 [1..12]
06:53:27 <lambdabot>  ([1,2,3,4,5,6,7],[8,9,10,11,12])
06:53:37 <fasta> Is there anyone with 6.8 installed?
06:53:41 <roderyk> olsner: thanks :)
06:53:50 <ari> @src splitAt
06:53:50 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
06:54:04 <roderyk> @break
06:54:04 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
06:54:06 <Beelsebob> that's rather disapointing
06:54:07 * ari shrugs - the actual implementation in ghc and the like is probably better
06:54:09 <roderyk> @src break
06:54:10 <lambdabot> break p =  span (not . p)
06:54:11 <byorgey> yes, but you have to give splitAt an index.  roderyk wants to split at a point determined by a predicate.
06:54:19 <Beelsebob> I would hope that splitAt were defined so as to only traverse the list once
06:54:30 <fasta> @source splitAt Data.List
06:54:31 <lambdabot> splitAt Data.List not available
06:54:33 <fasta> @source splitAt
06:54:33 <lambdabot> splitAt not available
06:54:37 <fasta> @source Data.List.splitAt
06:54:37 <lambdabot> Data.List.splitAt not available
06:54:47 <byorgey> roderyk: yes, break/span is probably what you want.
06:54:50 <shachaf> pejo: Hmm.
06:54:56 <fasta> Here lambdabot! _|_
06:55:00 <Beelsebob> splitOn p xs = (takeWhile p xs, dropWhile p xs)
06:55:26 <shachaf> pejo: It seems like a clumsy way of doing things, but I suppose you could do it that way.
06:55:42 <shachaf> fasta: @source is for files.
06:55:43 <LeCamarade> ?where lambdacats
06:55:43 <lambdabot> http://arcanux.org/lambdacats.html
06:55:47 <shachaf> @src splitAt
06:55:47 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
06:56:16 <LeCamarade> ?where+ \cats http://arcanux.org/lambdacats.html
06:56:16 <lambdabot> Plugin `where' failed with: IRCRaised getRandItem: empty list
06:56:22 <roderyk> is this how these splits are actually defined? (ie... they go over the list twice?)
06:57:39 <Beelsebob> roderyk: it would appear so
06:57:53 <Saizan> roderyk: no.
06:58:12 <Saizan> @source Data.List
06:58:12 <hpaste>  ari pasted "splitAt in ghc-6.6/libraries/base/GHC/List.lhs" at http://hpaste.org/3411
06:58:12 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
08:14:21 * roconnor tries to figure out how to turn milk and cream into half and half.
08:15:41 <roconnor> okay, my cream is 40%
08:15:49 <roconnor> half and half is 12.5%
08:16:35 <roconnor> not sure how much my whole milk is
08:17:46 <jedbrown> 3.75 or so
08:19:11 <Notrix> hi, is there a function that can replace a String in a [String] ? or an easy way to create one ? I can write one by recursion bu i wonder if there's another way ?
08:19:18 <roconnor> I'm surpised it isn't labeled clearly on my carton
08:19:26 <roconnor> 3.75% is what I'd expect
08:20:01 <Saizan> Notrix: how do you find the String to "replace"?
08:20:35 <Notrix> Saizan, I mean a function like the s// in Perl
08:20:50 <Notrix> I know we can use regexes in haskell
08:21:07 <jedbrown> roconnor: Just mix 3:1 and you'll be close enough.
08:21:19 <Olathe> Notrix: You can use map.
08:22:01 <Olathe> > map (\str -> if (str == "hello") then "goodbye" else x) ["hello", "hi", "how are you"]
08:22:02 <lambdabot>   Not in scope: `x'
08:22:08 <Olathe> > map (\str -> if (str == "hello") then "goodbye" else str) ["hello", "hi", "how are you"]
08:22:10 <lambdabot>  ["goodbye","hi","how are you"]
08:22:19 <Saizan> Olathe: that's quite wasteful, and it's more like s//g
08:22:36 <Saizan> ?type span
08:22:37 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:22:39 <Notrix> yeah I haven't thought about the map
08:23:01 <Notrix> span :o ?
08:23:21 <roconnor> jedbrown: perfect
08:23:32 <Saizan> > span (/="hello") ["foo","bar","hello", "hi", "how are you"]
08:23:34 <lambdabot>  (["foo","bar"],["hello","hi","how are you"])
08:24:16 <Saizan> > let (before,_:after) = span (/="hello") ["foo","bar","hello", "hi", "how are you"] in before ++ ("quux":after)
08:24:17 <lambdabot>  ["foo","bar","quux","hi","how are you"]
08:24:38 <Notrix> nice :)
08:24:48 <Saizan> Notrix: that's a start ^^^, there are some corner cases to check however
08:25:21 <Saizan> > let (before,_:after) = span (/="hello") ["foo","bar","hi", "how are you"] in before ++ ("quux":after)
08:25:23 <lambdabot>   Irrefutable pattern failed for pattern (before, _ : after)
08:25:24 <Notrix> okay, thank you for the help I'll have a look at span in prelude.hs :)
08:28:04 <Olathe> > let mapFirst _ _ [] = []; mapFirst find replace (x:xs) = if (find x) then (replace x):xs else x:(mapFirst find replace xs) in mapFirst (== "hello") (const "goodbye") ["foo","bar","hello","hi","how are you"]
08:28:05 <lambdabot>  ["foo","bar","goodbye","hi","how are you"]
08:31:08 <roconnor> jedbrown: you'd think half and half would have been 1:1 :)
08:32:33 <ivant> @seen Heffalump
08:32:33 <lambdabot> Heffalump is in #haskell and #darcs. I last heard Heffalump speak 2h 26m 33s ago.
08:51:44 <_ry> how do i do the integer modulo operation?
08:52:42 <sorear> > 123 `mod` 3
08:52:44 <lambdabot>  0
08:52:49 <_ry> thanks
08:53:00 <sorear> also `rem`, which has different sign behavior
08:53:18 <sorear> > (123 `mod` -3, 123 `rem` -3)
08:53:19 <lambdabot>      precedence parsing error
08:53:19 <lambdabot>         cannot mix `rem' [infixl 7] and prefix ...
08:53:30 <sorear> > ((123 `mod` -3), (123 `rem` -3))
08:53:30 <lambdabot>      precedence parsing error
08:53:30 <lambdabot>         cannot mix `rem' [infixl 7] and prefix ...
08:53:38 <sorear> > ((123 `mod` (-3)), (123 `rem` (-3)))
08:53:39 <lambdabot>  (0,0)
08:53:43 <sorear> uh...
08:53:57 <sieni> > ((-123) `mod` 3, (-124) `rem` 3)
08:53:58 <lambdabot>  (0,-1)
08:54:03 <xerox> ?check \x y -> mod (x :: Int) y == rem x y
08:54:05 <lambdabot>  Exception: divide by zero
08:54:05 <sieni> oosp
08:54:16 <xerox> ?check \x y -> y /= 0 ==> mod (x :: Int) y == rem x y
08:54:17 <sieni> > ((-124) `mod` 3, (-124) `rem` 3)
08:54:17 <lambdabot>  Falsifiable, after 5 tests: -1, 2
08:54:18 <lambdabot>  (2,-1)
08:54:57 <sieni> sorear: 123 is a bit bad example here, since it
08:55:05 <sieni> 's divisible by 3 :-)
08:55:05 <sorear> sieni: yeah :)
09:02:34 <magnusth> does anyone know about the community.haskell.org server and services?
09:03:51 <shapr> What do you want to know about it?
09:05:48 <magnusth> shapr, is there anything automatically done to stuff on code.haskell.org? (e.g. generation of code, checking that building works, etc)
09:06:43 <magnusth> oups, should have been generation of docs, rather than "code"
09:07:03 <thoughtpolice> magnusth: i've noticed nothing of that sort, it's mainly just a shell with a repo publically available (with darcs and whatnot)
09:07:18 <thoughtpolice> although i saw hints of trac being installed so that might be an available service if you want.
09:07:56 <magnusth> thoughtpolice, ok, good to know... mostly I wanted to know if there was automation that put requirements on how I lay out my darcs repo
09:08:04 <kolmodin> any hackage.h.o admins around?
09:08:56 <magnusth> thoughtpolice, if I'd like to put my haddock docs somewhere, does the haskell community provide a place?
09:09:02 <thoughtpolice> magnusth: no, mine is somewhat oddly organized.
09:09:17 <thoughtpolice> magnusth: hackage does automatic haddock runs over certain packages whenever it feels it should, iirc.
09:09:34 <thoughtpolice> but there's work to make it automatically generate haddock stuff for all packages in the future.
09:09:54 <thoughtpolice> magnusth: no on code.haskell.org you can lay it out however you want.
09:10:13 <thoughtpolice> i have a snapshot dir for my bot, the darcs repo and an older version of it.
09:10:24 <thoughtpolice> you could probably put a small website up there if you wanted.
09:10:47 <magnusth> thoughtpolice, cool... are my community.haskell.org credentials in any way related to HackageDB?
09:10:54 <kolmodin> heh, never mind
09:17:59 <magnusth> anyone know a good example of how to get cabal's "./Setup test" to work?
09:22:15 <paolino> :t mplus
09:22:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
09:22:46 <LoganCapaldo> Bwahahah
09:23:06 * LoganCapaldo is a mad scientist
09:23:34 <thoughtpolice> magnusth: no
09:24:02 <hpaste>  LoganCapaldo pasted "Madness!" at http://hpaste.org/3412
09:25:04 <thoughtpolice> magnusth: you can just install a hook for runTest in your Setup.hs
09:25:08 <thoughtpolice> http://haskell.org/cabal/release/rc/doc/API/Cabal/Distribution-Simple.html#v%3ArunTests
09:25:10 <lambdabot> http://tinyurl.com/yr2xqp
09:25:30 <_ry> which can be used on infinite lists: foldl or foldr ?
09:26:01 <Heffalump> foldr
09:29:19 <magnusth> thoughtpolice, yeah, I found that one too... but it's usually easier to see /how/ to use it based on an example
09:30:02 <magnusth> I have two external test files, one with QuickCheck tests and one with unit tests
09:30:18 <magnusth> it's not exactly obvioius how to tie them in with that API
09:31:50 <thoughtpolice> magnusth: hm just a sec,
09:41:20 <Beelsebob> Has anyone got a version of ghc with ghci debugger that works on Mac OS?
09:41:38 <gwern> is anyone running ghc 6.8 or out of darcs? can you check to see whether using the -ddump-minimal-imports option on a file breaks import statements which are renamed? (the import...as stuff)
09:42:01 <gwern> I'm also curious whether it still runs stuff together, like import Foo(bar,baz...)
09:58:05 <thoughtpolice> magnusth: you still there? i've got a small example of calling quickcheck tests if you want it
09:58:18 <magnusth> thoughtpolice, ah, that'd be cool
09:59:02 <asl> gwern: in my simple test the -ddump-minimal-imports dosn't seem to mess with the qualified imports ... maybe I'll try something simpler
10:00:22 <magnusth> thoughtpolice, are you pasting it somewhere?
10:00:58 <thoughtpolice> magnusth: http://hpaste.org/3413
10:01:51 <thoughtpolice> i think that should be sufficient
10:02:09 <glguy> hpaste, url
10:02:10 <hpaste> Haskell paste bin: http://hpaste.org/
10:02:39 <thoughtpolice> magnusth: if you need extra info about the environment you can get it from cabal in the parameters it provides to the functions you hook,
10:02:46 <thoughtpolice> see http://haskell.org/cabal/release/latest/doc/API/Distribution-Simple.html for more on those data structures
10:02:47 <fasta> hpaste, foobar
10:02:48 <lambdabot> http://tinyurl.com/yssh6y
10:03:06 <asl> gwern: ah, nevermind, I lied.  It will do things like: import Data.ByteString(B.putStr, B.readFile)
10:03:16 <asl> I'm not sure if that answers your question
10:04:19 <magnusth> thoughtpolice, thanks
10:08:30 <bbrown> anybody really bored, I have a difficult task I have no idea how to approach
10:08:49 <The_Wuhb> perl 6 has been impleented in haskell?
10:08:54 <The_Wuhb> ??
10:08:55 <bbrown> basically trying to convert some C code to haskell
10:09:13 <TomMD> Pugs, but I thought development has slowed on that recently.
10:09:24 <bbrown> The_Wuhb, I dont know the specifics, but why is that hard to believe
10:09:46 <fasta> The_Wuhb: ???????
10:10:11 <fasta> The_Wuhb: try using just one, it works better.
10:10:59 * glguy picks the 2nd from right one
10:11:16 <TomMD> ?where pugs
10:11:16 <lambdabot> http://www.pugscode.org/
10:12:33 <TomMD> bbrown: Is FFI an option?  Or does that defeat the purpose?
10:12:46 <allbery_b> pugs is actually a number of projects in roughly parallel development.  a haskell-based compiler/interpreter was one of the projects, but it's been on hold since audreyt went silent
10:13:18 <allbery_b> (most current activity is on a perl5-based translator which generates lisp...)
10:13:31 <bbrown> bbrown: no, it is only one C source file. Basically, I have an issue with a large area.  It is bad C code, that is half the problem.  One sec, let me post
10:13:55 <bbrown> TomMD: sorry, that was for you
10:14:01 <TomMD> Roger, I saw
10:14:53 <bbrown> TomMD, I was trying to convert this; I guess I didnt even know where to start, except for storing that array somehow; http://glants.cvs.sourceforge.net/glants/src/src/text.c?revision=1.1.1.1&view=markup
10:14:55 <lambdabot> Title: SourceForge.net Repository - [glants] View of /src/src/text.c, http://tinyurl.com/yrbfyq
10:15:50 <allbery_b> .oO { there is not-bad C code? }
10:15:51 <bbrown> my code from 6 years ago, sure does suck
10:16:12 <glguy> allbery_b: of course!
10:17:43 <TomMD> bbrown: Scary.  I would start by making an informal specification, learn the Haskell GL bindings, then rewrite.  But thats just me, not knowing the Haskell GL (or any GL).
10:18:48 <bbrown> TomMD, informal spec, for whom?  How would you store a large array like that though full of byte data
10:19:03 <bbrown> TomMD: I guess I could read it from file, but I was trying avoid that
10:19:20 <TomMD> Well, the array could just be a Haskell UArray, right?
10:19:47 <bbrown> TomMD, I guess so
10:20:25 <spx2> if beta in (TUN)* this means beta is any non-terminal or termianl production
10:20:34 <TomMD> I've got a big, fat, ugly UArray in one of my Haskell modules too - but mine looks small because I can compute each element.
10:23:19 <spx2> I'm trying to eliminate left recurrence
10:23:21 <spx2> for this production
10:23:28 <spx2> and I'm not sure if I'm doing it right
10:45:25 <mudge> anyone know how to generate object code from a tree containing a program?
10:45:52 <mrd> programs grow on trees?
10:46:25 <allbery_b> mudge: compiler writers :>
10:46:39 <mudge> mrd: do they?
10:46:46 <allbery_b> (well, sometimes I'm tempted to exclude the gcc developers...)
10:47:18 <roderyk> mrd: I always had a feeling I was barking up the wrong tree...
10:48:51 <locomalo> @msg
10:48:52 <lambdabot> Not enough privileges
10:49:01 <locomalo> @msg locomalo
10:49:01 <lambdabot> Not enough privileges
10:49:09 <allbery_b> you want @messages, I think
10:49:17 <locomalo> yes, thankyou
10:49:17 <lambdabot> locomalo: You have 1 new message. '/msg lambdabot @messages' to read it.
10:49:38 <allbery_b> (@msg is for the bot to e.g. identify itself to nickserv on startup)
10:49:50 <locomalo> ok ic
10:50:10 <locomalo> @messages
10:50:10 <lambdabot> SamB said 19h 37m 12s ago: I'd like to be using atom or lava
10:50:59 <locomalo> @seen SamB
10:50:59 <lambdabot> SamB is in #perl6 and #haskell. I last heard SamB speak 14h 36m 15s ago.
10:56:05 <locomalo> @tell SamB Do you describe circuits using functional language? If yes, what are you using? Thank you in advance!
10:56:06 <lambdabot> Consider it noted.
10:58:21 <Olathe> @tell lambdabot Noted.
10:58:21 <lambdabot> Nice try ;)
10:59:11 <shachaf> People should use @ask for questions.
10:59:49 <Saizan> locomalo: seen lava? http://raintown.org/lava/
10:59:50 <lambdabot> Title: The Lava Hardware Description Language
11:00:05 <LoganCapaldo> @help ask
11:00:05 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
11:00:17 <LoganCapaldo> @help tell
11:00:17 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
11:00:27 <LoganCapaldo> you're right they should
11:00:57 <lament> @quote
11:00:57 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
11:02:55 <locomalo> Saizan, yes i did, but by the time I did the first question I had to decide what to use, atom or lava. But now I decided that I'm going to do the same circuit in lava, atom and acl2
11:03:27 <Saizan> k
11:04:16 <gwern> asl: it does sort of answer my question, but was this a recent ghc?
11:04:37 <gwern> I'm thinking of filing a bug report, since that output should vbe copy-and-pastable, but breaking qualified imports obviously breaks programs...
11:05:05 <asl> gwern:  GHCi, version 6.8.0.20071019
11:05:44 <ivant> is there some easy criteria which tells when it is possible to rewrite recursive function into the one (or several) which has tail recursion?
11:07:26 <gwern> alright then. seems unliekly it would've been fixed since then...
11:07:46 <sclv> it should be possible whenever you have at most one recursive call per branch, no? (which isn't the same as pretty for all such cases)
11:07:48 <LoganCapaldo> well anythign you can write recursively you can write iteratively, and tail recursion gets transformed to iteration, so I think the criteria is const True ;)
11:08:12 <dmwit> LoganCapaldo: Not the same.
11:08:20 <dmwit> The iterative solution may need to keep a stack.
11:08:24 <LoganCapaldo> look at my smiley!
11:08:28 <dmwit> But a tail-recursive function can do away with the stack...
11:08:29 <LoganCapaldo> it's a smiley!
11:08:32 <dmwit> oh
11:08:38 <LoganCapaldo> heh
11:10:08 <sclv> ivant: just inspect your recursive calls, and ask if the work being done on the returned value can't be pushed down into the body of the called function, maybe with a helper function added.
11:10:10 <sorear> ivant: it's ALWAYS possible.  google CPS.  but trading stack for heap is essentially never a win
11:12:00 <ivant> sorear, oh, I should also say that I don't want to pass the stack (e.g. a list) manually
11:12:52 <sorear> ivant: what's the difference between a stack and an accumulator?  I don't think there is one.
11:12:58 <ivant> okay, a more specialized problem for starters: suppose Ackermann function. Is it possible to rewrite it into tail-recursive version without passing the "stack" as an extra argument
11:13:15 <ivant> sorear, that's a good question :-)
11:13:38 <sorear> Your problem is interesting, but too ill-specified to be solved.
11:13:44 <ivant> oh
11:13:59 <ivant> can you suggest how can I improve it?
11:15:05 <kolmodin> ivant: privet! kak dela? :D
11:15:23 <ivant> kolmodin, privet! :-)
11:15:30 <pgavin> @seen dcoutts_
11:15:31 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts_ speak 2d 52m 19s ago.
11:15:38 <pgavin> @seen dcoutts
11:15:39 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 19m 42s ago.
11:17:13 <fasta> What's the point of dupTChan?
11:17:49 <asl> gwern: wait, why is the bahvior I posted not copy/pastable?  Is it invalid syntax?
11:17:52 <asl> I suppose I could try it
11:17:59 <sclv> ivant: ackermann is not primitive-recursive -- i suspect that this means it can't be written as you suggest -- conceptually it seems pretty impossible.
11:18:02 <fasta> E.g. suppose t is a TChan, why wouldn't replicate 2 t do about the same?
11:18:16 <gwern> asl: pardon? what do you mean?
11:18:55 <asl> gwern:  nevermind
11:19:12 <asl> gwern: the output is not copy/pastable, as you said.  I had to try it out
11:20:11 <ivant> sclv, so, is primitive-recursive a necessary condition then? and is there any proof of this? :-)
11:20:26 <Lemmih> fasta: You can take data from the duplicated chan without modifying the original.
11:20:38 <sclv> ivant: my intuition. it would be a fun thing to prove though.
11:21:06 <ivant> okay, thanks
11:21:18 <fasta> Lemmih: ok, so a channel basically is a queue?
11:21:27 <fasta> Lemmih: mutable queue*
11:21:52 <Lemmih> fasta: "TChan is an abstract type representing an unbounded FIFO channel.", yes.
11:22:18 <fasta> Lemmih: yes, i did read that. Thanks
11:23:33 <gwern> asl: http://hackage.haskell.org/trac/ghc/ticket/1792 if you want to comment
11:23:35 <lambdabot> Title: #1792 (-ddump-minimal-imports breaks qualified imports (import...as)) - GHC - Tr ...
11:25:56 <sclv> ivant: conceptually, there is a case where ackermann calls itself with the result of itself -- so you either have to let the stack build up for the result of itself calls, or you have to pass them as thunks (which creates the stack upside down, so to speak) or roll your own stacklike construct which does essentially the same thing, right?
11:28:04 <ivant> sclv, I'm trying to figure out, whether it is possible to get away without using anything stacklike by using one or two extra variables which get passed to the next call
11:29:27 <sclv> fasta: look at the tchan source code -- dupTChan keeps the same writer channel but creates a new reader channel (i.e. tvar wrapping the writer channel)
11:30:14 <augustss> ivant: it's possible to rewrite ackermann without a stack, but I'm not sure how nasty it will get
11:30:47 <asl> do any standard libraries (like Control.Arrow or something) define a function :: (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b ?
11:31:13 <lament> @hoogle (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
11:31:14 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
11:31:14 <lambdabot> Control.Parallel.Strategies.(-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
11:31:14 <lambdabot> Control.Parallel.Strategies.(-||) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
11:31:38 <lament> doesn't seem like it...
11:32:04 <asl> lament:  so I don't feel bad for defining it ad-hoc, then.  It seems like something useful.
11:32:14 <lament> i don't see how you can possibly define that
11:32:20 <ivant> augustss, what approach should I take?
11:32:28 <asl> lament: f .>> g = \x -> f x >>= g
11:32:41 <augustss> ivant: I have no idea, I just know it's possible in theory :)
11:32:58 <integral> isn' that >>> in the kleisli arrow?
11:33:11 <asl> integral: I think so.  where is the instance?
11:33:12 <ivant> augustss, do you know where I can read about it?
11:33:12 <shachaf> integral: Yes.
11:33:15 <augustss> ivant: since tail recursion can emulate a while loop, and then you can encode everything as Integer
11:33:31 <integral> asl: good question!
11:33:35 <shachaf> I think somebody mentioned that one Haskell book uses (<>).
11:33:41 <augustss> @pl \x -> f x >>= g
11:33:42 <lambdabot> (g =<<) . f
11:33:56 <lament> :t \x -> f x >>= g
11:33:58 <lambdabot> Not in scope: `f'
11:33:58 <lambdabot>  
11:33:58 <lambdabot> <interactive>:1:14: Not in scope: `g'
11:33:59 <ivant> augustss, do you suggest encoding a "stack" as Integer? :-)
11:34:01 <integral> @kind Control.Arrow.Kleisli
11:34:02 <lament> erk
11:34:02 <lambdabot> (* -> *) -> * -> * -> *
11:34:13 <shachaf> @ty \x -> ?f x >>= ?g -- This?
11:34:15 <lambdabot> forall t (m :: * -> *) a b. (?f::t -> m a, ?g::a -> m b, Monad m) => t -> m b
11:34:27 <shachaf> Oh, never mind.
11:34:29 <augustss> ivant: it's possible that you'd have to do that, I don't know
11:34:32 <shachaf> @ty \f g x -> f x >>= g
11:34:33 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
11:34:50 <lament> oh, i was confused
11:35:05 <asl> integral:  it looks like I'd need to use the Kleisli newtype wrapper
11:35:10 <shachaf> asl: Yes.
11:35:10 <integral> @ty \f g -> runKleisli $ (Kleisli f) >>> (Kleisli g)
11:35:12 <lambdabot> forall a a1 (m :: * -> *) b. (Arrow (Kleisli m)) => (a -> m a1) -> (a1 -> m b) -> a -> m b
11:35:19 <sclv> augustss: b.bbut, how would you write ackermann as a while loop!
11:35:22 <integral> yeah.  Sadly the libraries inside on wrapping newtypes round everything
11:36:06 <sclv> (without a stack, that is)
11:36:12 <augustss> sclv: A while loop is OK, it's just with a for loop (with a fixed number of iterations) you can't do it
11:36:33 <augustss> sclv: you can encode anything with Integer
11:37:01 <sclv> right, but encoding a stack with an integer is still a stack.
11:37:01 <Heffalump> augustss: so you'd keep a stack of things left to calculate, encoded in the Integer?
11:37:24 <augustss> Heffalump: that would work.  I never said it was a good idea, just that it's possible
11:38:07 <sclv> you haven't actually made it cleanly tail recursive then -- like was argued above, you just recreated your stack on the heap.
11:38:19 <dcoutts> pgavin: hia
11:38:54 <augustss> sclv: ah, so you want to compute it in a some fixed size storage?
11:39:10 <ivant> augustss, yes :-)
11:39:17 <Heffalump> which would presumably have to depend on the inputs
11:39:28 <augustss> sclv: then you at least need as much as the result will take.  and it might be possible to do it in that amount
11:40:05 <Heffalump> but you'll need to store some intermediates, unless there's some clever accumulating parameter transformation
11:40:18 <sclv> augustss: its ivant's question -- i'm just interpreting it as best i can. what i understand it to mean is, for a reasonable definition of "good idea
11:40:37 <sclv> " -- are there recursive functions where transforming them to tail recursive is not a good idea.
11:40:50 <augustss> ivant: it's an interesting exercise to write ackermann with foldr as your only means of recursion
11:41:26 <Heffalump> augustss: are you allowed nested foldr calls?
11:41:41 <ferron> >let power a = a ^ a in power 2
11:41:52 <ferron> > let power a = a ^ a in power 3
11:41:54 <lambdabot>  27
11:42:01 <augustss> Heffalump: I'm trying to remember if you need them, I don't think you do.
11:42:03 <Heffalump> actually, how would you ever make a list to feed to foldr without any other form of recursion? foldr doesn't really introduce recursion in itself.
11:42:31 <ivant> only fix does :-)
11:42:33 <augustss> It doesn't have to be foldr.  Primitive recursion over the natural numbers works fine too
11:42:53 <Heffalump> sure, but primitive recursion is more powerful than just foldr
11:43:03 <ferron> > let power n |n == 0 = 1 |otherwise = n ^ power (n - 1) in power 3
11:43:03 <Heffalump> if you're allowed [1..n] as well, foldr would do
11:43:04 <lambdabot>  9
11:43:12 <ferron> > let power n |n == 0 = 1 |otherwise = n ^ power (n - 1) in power 3
11:43:13 <lambdabot>  9
11:43:14 <Heffalump> but the definition of [1..n] is recursive
11:43:29 <Philippa> yeah, but it's primitive recursive over n
11:43:52 <augustss> OK, I'll allow you any primitive recursive function. :)
11:44:10 <Heffalump> Philippa: right, but I'm arguing that just foldr isn't enough, not that primitive recursion isn't
11:44:16 <Philippa> but presumably not HOFs, which is the important part - if you get HOFs as well it's very different
11:44:24 <Philippa> Heffalump: I can encode n as a list...
11:44:24 <augustss> Exactly
11:44:33 <ferron> > let power n |n == 0 = 1 |otherwise = n ^ power (n - 1) in power 3
11:44:35 <lambdabot>  9
11:44:35 <Heffalump> Philippa: how, without recursion?
11:44:42 <pgavin> dcoutts: back
11:45:01 <pgavin> dcoutts: I've got a patch to fix that compile error
11:45:03 <Philippa> Heffalump: not the point, n would be input in that case
11:45:17 <dcoutts> pgavin: great
11:45:20 <Heffalump> that's cheating :-) If you're offering foldn rather than foldr, that's a different matter...
11:45:21 <augustss> Heffalump: I think you're right, you'd need [1..n] as well.
11:45:46 <Philippa> I've missed a little context, where's n coming from?
11:45:48 <pgavin> should I email it straight to you?
11:46:03 <Heffalump> that's ambiguous so far
11:46:49 <Philippa> if n's input then asking for it encoded appropriately is fair play
11:46:57 <Philippa> if it's not, then the question is what input it's derived from
11:47:11 <ivant> Philippa, we are trying to figure out, is it possible to write ackermann function in tail-recursive style without accumulating stack (i.e. by using fixed amount of memory)
11:47:22 <Heffalump> ok, I demand my inputs encoded in the form of the result of applying the ackermann function to them
11:48:13 <augustss> ivant: do you agree that the fixed amount will depend on the arguments to ackermann?  Since we need to store the result.
11:48:28 <Philippa> Heffalump: no inverse function, so not a valid encoding
11:48:31 <Heffalump> augustss: in principle we could stream it out
11:48:40 <Heffalump> Philippa: ok, a tuple of the numbers and the ackermann result.
11:49:06 <Philippa> sure, but you're not allowed to access the ackermann result
11:49:19 <Heffalump> ok, then you're not allowed to access the list :-p
11:49:45 <Philippa> the fair equivalent would be to just prevent me accessing the items in the list. Which is fine by me
11:49:59 <ivant> augustss, constant number of extra arguments of Int type are okay (suppose we restrict our-selfs only to the arguments which give the result which fits in Int)
11:50:06 <Heffalump> I don't see why I should be prevented from accessing it.
11:50:11 <magnusth> dataenc has now found its way onto c.h.o: http://code.haskell.org/dataenc/
11:50:12 <lambdabot> Title: Index of /dataenc
11:50:18 <Heffalump> If you'd like to complain about redudancy, then just one input and the ackermann result will do me fine.
11:50:27 <Heffalump> s/redudancy/redundancy/
11:50:32 <Philippa> because then there is in a fundamental sense data in it that wasn't in the numbers alone
11:50:49 <pgavin> dcoutts: ^^^
11:51:02 <Philippa> which there isn't in encoding a natural as a list of some type with no values
11:51:04 <Heffalump> not at all, there's a two-way mapping
11:51:24 <Heffalump> (I suggest you employ some argument based on the time complexity of the mapping now :-)
11:51:58 <Philippa> like 'expressible as a fold using only constructors as arguments'?
11:52:27 <dcoutts> pgavin: you're subscribed to gtk2hs-devel right? if the patch is not huge then email it there
11:52:43 <pgavin> hmm
11:53:02 <pgavin> I'm not sure if I can only send you that one patch or not
11:53:39 <Philippa> which is a bit more precise than just time complexity :-)
11:54:07 <Heffalump> and also arbitrarily chosen to get the answer you want :-p
11:54:43 <Philippa> it's not totally arbitrary: it's fairly hard to claim there's non-trivial computational content if all you're doing is swapping constructors
11:54:54 <dcoutts> pgavin: if the patch(es) are big email them to me direct, though you could cc gtk2hs-devel to keep people in the loop
11:54:56 <Philippa> ("non-trivial" - there's trivial content in id)
11:55:48 <Heffalump> in any case, I can't see how this could work with just primitive recursion on the input values, given that the function is known not to be primitive recursive..
11:55:53 <pgavin> dcoutts: do you mind if I just send the whole bundle to you (and the list) again?
11:56:03 <dcoutts> pgavin: go ahead
11:56:11 <Philippa> likewise
11:56:50 <pgavin> dcoutts: ok, will do :)
12:00:48 <pgavin> dcoutts: ok, sent
12:00:53 <dcoutts> ta
12:10:26 <SamB> @tell locomalo I do not. Currently I am taking Electric Circuits 1 or something like that, where we deal only in analog circuits... linear ones, as I understand it...
12:10:26 <lambdabot> Consider it noted.
12:11:17 <locomalo> SamB, ok thank you anyway!
12:11:17 <lambdabot> locomalo: You have 1 new message. '/msg lambdabot @messages' to read it.
12:11:27 <locomalo> @messages
12:11:28 <lambdabot> SamB said 1m 2s ago: I do not. Currently I am taking Electric Circuits 1 or something like that, where we deal only in analog circuits... linear ones, as I understand it...
12:12:05 <bastix> % help
12:12:27 <oerjan> @help
12:12:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:12:49 <locomalo> SamB, so it wasn't you the one who told me that where doing something with more than one clock domain :(
12:12:58 <Kazuya> I was wondering if somebody could help me out, I have a function of type String -> [(String, a)] -> [a], and its output is in the format JUST [a], This is terribly annoying when im trying to call it within another function
12:13:01 <Kazuya> Any way around this?
12:13:12 <SamB> locomalo: I was thinking about it
12:13:12 <lambdabot> SamB: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:13:21 <SamB> @messages
12:13:22 <lambdabot> LoganCapaldo said 21h 39s ago: it's @tell
12:13:22 <lambdabot> locomalo said 1h 17m 15s ago: Do you describe circuits using functional language? If yes, what are you using? Thank you in advance!
12:13:36 <bastix> @help list
12:13:36 <lambdabot> list [module|command]
12:13:36 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:13:47 <SamB> how the heck are both of those new
12:15:57 <locomalo> SamB, I supouse you studied CS and now you're taking some EE courses?
12:17:03 <SamB> uh, define studied
12:17:39 <chessguy> @all-dict study
12:17:42 <lambdabot> *** "Study" gcide "The Collaborative International Dictionary of English v.0.48"
12:17:42 <lambdabot> Study \Stud"y\, v. t.
12:17:42 <lambdabot>    1. To apply the mind to; to read and examine for the purpose
12:17:42 <lambdabot>       of learning and understanding; as, to study law or
12:17:42 <lambdabot>       theology; to study languages.
12:17:44 <lambdabot> [244 @more lines]
12:17:55 <SamB> by that definition I suppose the answer is "yes"
12:18:30 <chessguy> you only read the first of 5 of 249 lines
12:18:42 <SamB> well, that part
12:19:51 <oerjan> reading the first 5 of 249 lines is not considered a good way of studying, is it? :D
12:20:19 <SamB> I have much to learn of CS, but I really didn't think majoring in it was a good way to do that
12:21:56 <locomalo> SamB, my case is the oposite, I'm studied EE and now I'm taking some CS courses to do my final project to finish with EE grade studies
12:22:19 <SamB> I don't know as I've taken any CS *courses*
12:22:39 <SamB> some programming courses I guess
12:23:14 <locomalo> here only in CS you can get the oportunity to study functional language
12:23:41 <SamB> I don't think they know what functional languages are at my current school
12:24:37 <locomalo> all the rest of the programmers, let's say 90 %, don't know it either
12:25:11 <SamB> considering the size of the school I guess I can't blame 'em
12:25:26 <TomMD> What school?
12:25:37 <SamB> widener.edu
12:25:44 <locomalo> here in Argentina, of course
12:25:50 <locomalo> ok, I see you later, bbl
12:33:38 <desegnis> heh. I just had one of these moments going “If you think about a problem first, writing the Haskell solution is a matter of one minute.”
12:41:59 <shapr> desegnis: yah!
12:43:22 <desegnis> ;)
12:43:23 <spx2> I'd like to ask a LFA question
12:45:34 <oerjan> Lupus Foundation of America?
12:47:38 <dmwit> spx2: You should probably just ask the question, it's easier on all of us that way.
12:48:19 <oerjan> especially us acronym-blind ones :)
12:50:21 <fasta> spx2: nice you found an acronym I don't know!
12:50:48 <fasta> Local Feature Analysis?
12:51:05 <oerjan> logical frameworks? linear functionals?
12:51:14 <ari> Linear friendly automaton?
12:54:07 <sieni> Lolland Falster Alliancen?
12:54:17 <sieni> Loving Female Authority
12:54:17 <sieni> ?
12:56:13 <fasta> It seems spx2 forgot what it stands for.
12:56:20 <dmwit> Little Ferret Abdomen
12:57:26 <spx2> Formal Languages and Finite Automata
12:57:42 <spx2> my question is regarding eliminating left recursion
12:58:02 <dmwit> Ooo, I just learned about this.
12:58:11 <spx2> I would like to read something about it to clarify
12:58:31 <spx2> because I just read something and it wasn't enough to make me understand
12:59:20 <dmwit> http://www.stanford.edu/class/cs143/handouts/06-Formal-Grammars.pdf
12:59:23 <lambdabot> http://tinyurl.com/23rz6p
12:59:59 <spx2> dmwit: I got the same document from a google search
13:00:10 <dmwit> Oh, wow.
13:00:11 <spx2> dmwit: unfortunately my kpdf/xpdf do not show all symbols
13:00:21 <spx2> dmwit: hence,I cannot use it
13:00:29 <Zao> spx2: pdftops?
13:00:38 <phlpp> > 2^63
13:00:39 <lambdabot>  9223372036854775808
13:00:48 <phlpp> > 2^31
13:00:49 <lambdabot>  2147483648
13:00:59 <phlpp> > 2^31 / 10^6
13:01:00 <lambdabot>  2147.483648
13:01:03 <spx2> Zao: same problem
13:01:19 <dmwit> spx2: Your system is broken. =P
13:01:33 <dmwit> xpdf shows it just fine here (and I don't see any symbols anywhere, either; are you sure it's the same document?)
13:01:38 <spx2> dmwit: anyway this is not about pdf or ps
13:01:48 <spx2> dmwit: I need to read this eliminating left recursion from somewhere
13:03:48 <hpaste>  dmwit pasted "copy/pasta from cs143 lecture notes" at http://hpaste.org/3414
13:05:19 <spx2> dmwit: ok so its not really eliminating recursion,its transforming left recursion to right recursion.
13:05:28 <dmwit> spx2: Exactly.
13:06:34 <spx2> dmwit: I thought the algorithm knew how to really ELIMINATE RECURSION wich would have been an interesting thing ...
13:07:09 <dmwit> spx2: Tell me, how would you create a CFG for, say, the regular expression a* without recursion?
13:07:39 <dmwit> I don't think eliminating recursion is possible even in this simplest case.
13:08:25 <spx2> dmwit: I'm not aware of what CFG might be
13:08:34 <dmwit> context-free grammar
13:09:22 <spx2> dmwit: well , by directly describing the language with the general form its elements take
13:09:29 <dmwit> i.e. probably the same as what you call a "formal language".
13:09:52 <spx2> dmwit: wich would take much more space on paper than writing a simple recursion equation
13:10:39 <spx2> dmwit: also sometimes I think it would be impossible to Enumerate all the possible general forms of the elements of the language
13:10:59 <spx2> dmwit: or too time-consuming
13:11:28 <spx2> dmwit: for example "[abcde]{4}"
13:12:14 <spx2> dmwit: this could be described as {xyzrt|x,y,z,r,t in {a,b,c,d,e}}
13:12:28 <hpaste>  n00b pasted "recursive power function" at http://hpaste.org/3415
13:12:29 <spx2> sorry
13:12:39 <spx2> dmwit: this could be described as {xyzr|x,y,z,r in {a,b,c,d,e}}
13:13:14 <ferron> just wrote a recursive power function, but I was thinking about doing it using only one input
13:13:54 <spx2> ferron: I thought it requires 2
13:14:15 <spx2> dmwit: yes I was talking about a CFG
13:16:00 <spx2> dmwit: how far in the formal languages are you ?
13:16:11 <dmwit> About one week ahead of you. =)
13:16:34 <dmwit> We covered LL(1) grammars at the beginning of last week.
13:17:49 <spx2> dmwit: So are you using some book or course material or... ?
13:17:58 <spx2> dmwit: are you solving problems for homework ?
13:18:10 <dmwit> I am in school right now.
13:18:25 <dmwit> So, I guess it's fair to say I'm using some course material. =)
13:19:08 <dmwit> (I'm actually in a compiler class, so our homework is to slowly build a compiler from scratch.  I think what you call "Formal Languages" was covered in a different class.)
13:20:05 <spx2> dmwit: well I'm not in school any more,I've dropped out
13:20:08 <dmwit> (So, I have covered regular expressions, finite automata, context-free grammars, Turing machines, computability, etc. in another class.)
13:20:12 <spx2> dmwit: could we share course notes etc ?
13:20:16 <dmwit> spx2: Oh, cool!  I'm impressed.
13:20:30 <ddarius> dmwit: You're impressed that he dropped out?
13:20:30 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
13:20:32 <spx2> dmwit: don't mock me :P
13:20:47 <dmwit> ddarius: I'm impressed that he has the willpower to study these things without being in school.
13:20:53 <dmwit> If I had that willpower, I'd drop out, too.
13:21:01 <ddarius> dmwit: Many people here do.
13:21:27 <olsner> I'm a temporary drop-out too
13:22:27 <dmwit> spx2: Well, all my "notes" are linked to from the front page of cs143.stanford.edu, so I guess we could share notes... =)
13:24:23 <spx2> olsner: thats kind of what I feel like also ... I'm not sure if I'll take this exam , if I don't take it I'll be drop out for sure
13:27:54 <Philippa> dmwit: if you have time, study is comparatively easy. It just means sitting yourself in front of books and making sure some of your timewasting online is on the relevant subjects
13:28:26 <spx2> Philippa: I have a job
13:29:29 <Heffalump> it's too tempting to timewaste in a non-productive way
13:29:31 <spx2> dmwit: so you're in stanford , is knuth your daddy or what ? :D
13:29:57 <dmwit> Yeah, I needed the family connection. =)
13:30:06 <LoganCapaldo> whose your daddy?
13:30:16 <dmwit> Nobody owns my daddy!
13:30:18 <LoganCapaldo> Knuth!
13:30:28 <dmwit> Or did you mean, "Who's your daddy?" ;-)
13:30:32 <LoganCapaldo> Something I've always wondered
13:30:47 <spx2> dmwit: yes that's what I meant,english is not my native tongue ..
13:30:58 <LoganCapaldo> Is the K silent? I had a professor who always said Ka-Nuth, but that just seemed wrong
13:31:06 <dmwit> I actually went to a lecture by Knuth once, but I couldn't understand it. =(
13:31:23 <sioraiocht> dmwit: he's giving one here this week, i fear it.  i hear he's a horrible lecturer
13:31:29 <dmwit> Everyone I know (including Knuth himself) pronounces the 'K'.
13:31:52 <LoganCapaldo> ah wel
13:32:04 <LoganCapaldo> I guess he jsut has a non-poetic last name
13:32:10 <Heffalump> sioraiocht: I thought he was ok the last time I went to one he gave at Oxford
13:32:27 <sioraiocht> and he's a visiting prof here, I have no idea what else he does here
13:32:45 <sioraiocht> Heffalump: if I knew what "combinatorial objects" were I might be more interested
13:32:58 <Heffalump> well, go, and you might find out..
13:33:41 <spx2> LoganCapaldo: maybe just german provenience
13:33:51 <spx2> LoganCapaldo: or german origins ...
13:34:14 <sioraiocht> Heffalump: are you in liechtenstein?
13:34:28 <Heffalump> no, I just have friends who registered a domain in it
13:34:31 <LoganCapaldo> The two are orthogonal aren't they? :)
13:34:33 <sioraiocht> ah
13:34:34 <spx2> sioraiocht: he's probably drinking beer and having fun with some fellow female students of yours :)
13:34:37 <Heffalump> while we were at Oxford, in fact :-)
13:34:55 <sioraiocht> Heffalump: neat.  did you do your undergrad or grad here?
13:35:00 <Heffalump> grad
13:35:03 <sioraiocht> in C?S
13:35:05 <sioraiocht> *CS
13:35:07 <Heffalump> yeah
13:35:11 <sioraiocht> cool :)
13:35:21 <sioraiocht> what college?
13:35:22 <Heffalump> what are you doing there?
13:35:24 <Heffalump> Magdalen
13:35:27 <sioraiocht> wow, nice
13:35:36 <sioraiocht> MSc and (hopefully?) DPhil in CS
13:35:37 <Heffalump> nice deer, certainly :-)
13:35:42 <Heffalump> ah, that's exactly what I did
13:35:57 <sieni> Dr. Phil
13:36:31 <Heffalump> someone with an MA and DPhil from Oxford who was also called Phil liked to arrange the letters as MAD Phil
13:36:50 <sioraiocht> lol
13:37:00 <spx2> Heffalump: magdalen ?
13:37:10 <pejo> Heffalump, stacking titles, like the german system!
13:37:14 <spx2> Heffalump: very interesting female name
13:39:06 <sioraiocht> spx2: it's named after mary magdalen, afaik
13:39:31 <sioraiocht> Heffalump: were you in magd for both your msc and dphil?
13:39:31 <Heffalump> many old Oxford and Cambridge colleges have religious names
13:39:34 <Heffalump> yeah
13:39:45 <sioraiocht> lucky, lol
13:39:56 <sioraiocht> my college is the only negative thing about oxford so far
13:40:29 <Heffalump> St Annes? (from your hostname) I know people who were there and seemed to find it ok.
13:40:37 <Heffalump> and it's near the lab..
13:40:55 <sioraiocht> Heffalump: i'm housed in summertown
13:41:19 <Heffalump> ah
13:41:24 <sioraiocht> and I have had the worst treatment by college and academic offices, and i compared notes with other grads that havehad even worse experiences
13:41:42 <Heffalump> I guess I've only really known undergrads there.
13:41:46 <sioraiocht> oh
13:41:51 <Heffalump> what'd they do to you?
13:41:53 <sioraiocht> from what i've heard the undergrads love it
13:42:24 <sioraiocht> hrm, we can start with trying to keep my student loan money because they insisted taht until I paid my tuition in full I wasn't entitled to living expense money =p
13:42:55 <sioraiocht> or the fact taht they took FOREVER to give me a letter of reference for abank, and then got my name and the address wrong and took even longer to get back to me
13:43:23 <Heffalump> couldn't you just go and stand in the admin offices until they fixed it? That's the advantage of being somewhere small...
13:43:49 <sioraiocht> no, i asked if they could do it there and they flat out told me to come back in 3 days as they were "very busy"
13:44:34 <Heffalump> find another college for your DPhil then, they'll be sorry :-) (they make a packet from science grad students for not doing anything much)
13:44:49 <sioraiocht> yeah
13:44:52 <sioraiocht> that's what I plan to do
13:44:56 <roconnor> I saw people being kinda rude.  I thought that was weird for the haskell channel.  Then I noticed I was on #kubuntu.
13:45:17 <sioraiocht> although apparently your current college will try and lash on to you with tentacles of death..for the money ;)
13:45:24 <spx2> roconnor: loool
13:45:45 <Heffalump> I didn't think they can stop you changing between degrees, though perhaps that's only UG -> G
13:46:16 <sioraiocht> they can't technically STOP you, I don't think.  but there's a form (isn't there always) and I believe to you have interview witht he tutor for graduates
13:46:37 <roconnor> Maybe it is hard to be civil when you have 414 people on an IRC channel :P
13:46:49 <Heffalump> doesn't #haskell have that many?
13:46:58 <sioraiocht> @users
13:46:58 <lambdabot> Maximum users seen in #haskell: 420, currently: 406 (96.7%), active: 13 (3.2%)
13:47:04 <roconnor> Heffalump: I only see 406 :)
13:47:15 <Heffalump> ah, but we've had 420.
13:47:18 <sioraiocht> #haskell is unusually well behaved
13:47:31 <spx2> sioraiocht: does that work on any channel ?
13:47:37 <Heffalump> no, it's our bot
13:47:49 <spx2> :(
13:48:44 <ddarius> #haskell is unusual
13:49:04 <ddarius> Anyway roconnor.  Yes, I was the one interested in the review of the Geometric Algebra book.
13:49:44 <roconnor> ddarius: as far as I can tell, they use the phase ``object-oriented'' in their subtitle to sell the book. ;)
13:50:04 <roconnor> ddarius: by object-oriented they mean "oriented objects"
13:50:09 <ddarius> roconnor: They roughly say that in the preface or book description or whatever is online.
13:50:19 <roconnor> objects being lines, plane, circles, spheres, etc.
13:50:32 <roconnor> ddarius: oh, right, that part is online.
13:51:21 <roconnor> ddarius: I haven't found such an accessable description of the conformal model in any of their papers before, so that was good.
13:51:43 <roconnor> ddarius: it is pretty involved.
13:52:20 <roconnor> ddarius: there are points, and flat points, free vectors, tangent vectors, etc.
13:52:30 <roconnor> plus all the dual ways of representing objects.
13:52:52 <roconnor> I suppose it is pretty clear what to use in which situations
13:53:12 <roconnor> but still, I can imagine it taking a bit to sort things out.
13:53:28 <swiert> roconnor: Which book is that?
13:53:32 <roconnor> for example, you need to take three points to make a circle
13:53:41 <roconnor> but they can't be flat points
13:54:04 <roconnor> swiert: Geometric Alegbra: An object oriented approach.
13:54:25 <LoganCapaldo> lol
13:54:29 * olsner pulls out an infinitely large circle
13:55:00 <roconnor> It was a little sad in their raytracer examples when they had to separate tangent vectors into a point and a vector for effeciency reasons.
13:55:00 <ddarius> olsner: Indeed, a line is a circle through the point at infinity.
13:56:38 <roconnor> ddarius: I just read the book front to back, and didn't work on the exercises.
13:57:03 <roconnor> so I didn't gain an intuation on how the different operations distribute over each other.
13:57:04 <spx2> roconnor: so what does that book teach you ? how to build a 3d engine for a game or. ... ?
13:57:13 <swiert> roconnor: ah. ok.
13:57:28 <roconnor> I hope to go over it again, and work on some of the exercises.
13:57:45 <roconnor> I'd love to make a template haskell implementation, or even a slow non-template reference implemenation.
13:57:50 <spx2> roconnor: I've tried that with some math books,reading without doing exercices,and it does not work ....
13:58:08 <ddarius> roconnor: You partially answered this, but just to direct it a bit more: How good a job did it do explaining the material?  How good a job motivating it?
13:58:41 <roconnor> ddarius: well, I was pretty motivated before.  The presentation seem very clear.
13:59:23 <roconnor> I met a Grassman algebra in differential geometry before, so I was aware of that
13:59:54 <roconnor> geometric product is new, other than the papers I've read before by the authors
14:00:03 <roconnor> ddarius: I haven't played with their software yet
14:00:13 <spx2> roconnor: who wrote it ?
14:00:25 <swiert> Speaking of books, has anyone here read: http://www.amazon.com/Elements-Computing-Systems-Building-Principles/dp/026214087X/ref=pd_bbs_sr_1/105-0411079-5911639?ie=UTF8&s=books&qid=1193000284&sr=8-1
14:00:27 <roconnor> they strongly recommend playing with it to get an intuition on how geometric algebra operations work.
14:00:28 <lambdabot> http://tinyurl.com/2cyayn
14:00:32 <ddarius> spx2: The Dorst group.
14:00:59 <ddarius> roconnor: GAViewer is somewhat fun.
14:01:15 <roconnor> ddarius: I really think the GAViewer would help me alot.
14:02:03 <spx2> ddarius roconnor what applications does it have ?
14:02:19 <ddarius> spx2: Geometric algebra?
14:02:46 <roconnor> spx2: it is a method for doing euclidean transformations to points, lines, and planes.
14:03:16 <roconnor> ... and conformal transformations of circles and spheres also happens for free.
14:03:42 <roconnor> spx2: the transformations of these different objects are done uniformly.
14:03:58 <spx2> roconnor: I've learned in differential geometry of difeomorphisms
14:04:13 <spx2> roconnor: aare these transformations you talk of in any connection with difeomorphisms ?
14:04:44 <roconnor> spx2: these are rigid motion transformations ... isometries IIRC
14:05:02 <roconnor> so they are much more restricted than difeomorphism.
14:05:07 <spx2> roconnor: also in measure theory I've seen a nice algorithm for transforming a function into another progresivelyh so that the graph of one function progressively converges to the other graph
14:05:20 <spx2> roconnor: oh I understand
14:06:16 <ddarius> spx2: Geometric algebra in general, not just the Conformal Geometric Algebra, can be used as the mathematical language for practically all topics in physics.  In general, most places you use vectors (or particularly inner product spaces), using geometric algebra will provide you some benefit.
14:06:27 <roconnor> GA also handles arbitrariy linear transforms which are extended to work on other objects by extending it to an outermorphism.
14:06:50 <eneas> \join physics
14:06:56 <roconnor> but those transformations are done differently.
14:08:18 <roconnor> spx2: The first product is the wedge product, which is an antisymetric operation that forms bi-vectors from two vectors.
14:08:47 <roconnor> spx2: you may have encountered these bi-vectors in electormagatism, etc.
14:09:25 <roconnor> but they were called vectors traditionally, but bi-vectors remove the arbitray choice of a left or right hand rule.
14:16:20 <ddarius> roconnor: Not exactly.
14:36:23 <TomMD> What do you guys think about a 'Data.Binary.GetSafe' module?  The idea is that it would mirror most 'get' functions from Data.Binary.Get except with a type like: "getsWord32le :: Get (Maybe Word32)" and would first check if there is enough space?
14:36:33 <TomMD> *Enough bytes remaining.
14:38:16 <LoganCapaldo> @docs Data.Binary
14:38:17 <lambdabot> Data.Binary not available
14:38:18 <lekro> ?minimum
14:38:18 <lambdabot> Unknown command, try @list
14:38:21 <LoganCapaldo> boo
14:38:21 <lekro> ?src minimum
14:38:21 <lambdabot> minimum [] = undefined
14:38:22 <lambdabot> minimum xs = foldl1 min xs
14:38:28 <LoganCapaldo> @go haskell data.binary
14:38:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
14:38:30 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
14:38:35 <lekro> I probably asked that already but why is minimum not implemented in terms of foldl1' ?
14:38:53 * LoganCapaldo feels feeling of deja vu
14:38:54 <TomMD> LoganCapaldo: Yes, I am talking about a wrapper to Data.Binary.
14:39:01 <lekro> what's the reason that it's using foldl1?
14:39:05 <LoganCapaldo> I have no doubt you are
14:39:14 <LoganCapaldo> But I dunno what Data.Binary is :)
14:39:25 <TomMD> Oh, sorry.  Misunderstood.
14:40:10 <LoganCapaldo> hmm
14:40:16 <LoganCapaldo> interesting
14:40:36 <byorgey_> lekro: no one knows. =P
14:41:13 <lekro> byorgey_: but doesn't this render minimum quite useless?
14:41:28 <TomMD> You see, I don't like that Data.Binary.X will throw an exception in these cases - thus making my functions incomplete.  I want to break any sort of dependence on the IO monad performing 'catch' when I decode network packets.  Therefore I must decode the network packets as type Maybe (or some variant)
14:42:42 <byorgey_> lekro: theoretically, the laziness could be useful (e.g. if using a lazy natural type), but in most cases, yes, it would be more useful to have a strict version.
14:43:44 <byorgey_> lekro: sometimes minimum gets optimized to the strict version anyway, but you can't count on it.  I usually just make my own strict version, minimum'.  (and maximum', and sum', and product'...)
14:44:41 <ndm> is Jerzy Karczmarczuk here?
14:45:55 <LoganCapaldo> @get-jerzy-karczmarczuk
14:45:56 <lambdabot> Unknown command, try @list
14:45:58 <ndm> he seems to have "half started" about 4 flamefests, by my reckoning
14:46:00 <ddarius> lekro: That's the H98 definition.  foldl' and co. aren't part of the H98 standard libraries.
14:46:03 <ndm> in the last 2 weeks
14:46:06 <byorgey> ndm: indeed.
14:46:21 <shachaf> Is seq in Haskell 98?
14:46:23 <ndm> plans? is this where dons steps in with a lambda of enlitenment?
14:46:25 <ndm> shachaf: yes
14:46:27 <ddarius> shachaf: Yes
14:46:28 <TomMD> Is he the reason my mailbox has been filling up latly?
14:46:48 <ndm> not really, he's just the reason that there have been a few "raised voices"
14:47:07 <shachaf> Maybe @get should get an argument.
14:47:11 <LoganCapaldo> > seq and find
14:47:12 <lambdabot>  Add a type signature
14:47:38 <byorgey> "then dons did hold on high the lambda of enlightenment, saying, 'oh Lord, bless this Thy holy Lambda of Enlightenment...'"
14:47:45 <shachaf> andefined?
14:48:43 <TomMD> ndm: Is YHC broken or is it just my two computers?  (Debian 32bit, Ubuntu 64 bit)
14:48:59 <ndm> TomMD: scons fullclean, scons update ?
14:49:05 <TomMD> I'll try again
14:49:06 <allbery_b> oh good, I'mnot the only one who thought his tone was a bit off
14:49:20 <ndm> TomMD: recently cpphs changed in an incompatible way, we patched it on friday to update
14:49:20 <LoganCapaldo> And Succ (Succ (Succ Zero)) shall be the number of the counting, Not Succ Zero nor Succ (Succ (Succ (Succ Zero))). Succ (Succ (Succ (Succ (Succ Zero)))) is right out
14:49:30 <ndm> TomMD: meaning you need a brand new Yhc repo and a brand new cpphs
14:49:41 <TomMD> ndm:  I did pull 6.8 on both... forgot about that - is that my issue?
14:50:20 <ndm> TomMD: perhaps, perhaps not - i've never tried with 6.8 but clearly it should work on 6.8 - so hpaste a failure log
14:51:00 <byorgey> LoganCapaldo: =D
14:52:31 <byorgey> and the Lord did grin, and the people did feast on lambdas, and foldrs, and monads, and arrow combinators, and category theory, and...
14:53:00 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3416
14:53:18 <TomMD> ndm: oops.... ^^^ that is mine
14:54:08 <TomMD> it is a stupid configure bug on my ubuntu.  I'll fire up the Debian box, which is more interesting (if you have time, and are interested in this).
14:54:34 <ndm> TomMD: that suggests it can't find GCC, which is unlikely on a linux box
14:54:45 <ndm> TomMD: i'm around all night, and would like to know what's gone wrong
14:55:23 <ndm> TomMD: actually, that looks like it failed before, and has cached the failure - try scons fullclean, then scons configure - it should force it to trty again
14:58:29 <hpaste>  thammers pasted "nix X11-1.2.2" at http://hpaste.org/3417
15:02:15 <hpaste>  tommd annotated "(no title)" with "YHC Build Error" at http://hpaste.org/3416#a1
15:02:26 <TomMD> ndm: new error ^
15:02:31 <LoganCapaldo> > [fromEnum 65] :: String
15:02:32 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
15:02:44 <LoganCapaldo> > [toEnum 65] :: String
15:02:45 <lambdabot>  "A"
15:02:50 <TomMD> working on the debian box, which now (not previously) is having the same configure issue, but not going away.
15:03:03 <LoganCapaldo> > [chr 65]
15:03:05 <lambdabot>  "A"
15:03:44 <ndm> TomMD: hmm, well that error i can diagnose, and will be a pain to fix
15:04:11 <ndm> TomMD: is that the RC of GHC 6.8?
15:04:52 <TomMD> It is the darcs (http://darcs.haskell.org/ghc-6.8/ghc)
15:04:54 <lambdabot> Title: Index of /ghc-6.8/ghc
15:04:58 <TomMD> as of... oh... 5 days ago/
15:05:29 <TomMD> The Glorious Glasgow Haskell Compilation System, version 6.8.0.20070914
15:05:31 <omnId>  > map chr [104,101,108,108,111]
15:05:37 <omnId> > map chr [104,101,108,108,111]
15:05:38 <lambdabot>  "hello"
15:05:40 <ndm> TomMD: more importantly, is that the filepath and directory libraries that go with them?
15:06:01 <TomMD> absolutely.  It is just the libraries (and extras) that go with GHC 6.8
15:06:11 <ndm> crap, that means GHC 6.8 has a bug in it...
15:06:27 <TomMD> ... I'm waiting to hear something new ...
15:07:06 <ndm> it appears both directory and filepath export makeRelativeToCurrentDirectory
15:07:16 <ndm> what should happen is that one should import and reexport the other
15:07:21 <ndm> or only one should export
15:07:39 <LoganCapaldo> damn import/export laws
15:07:50 <LoganCapaldo> those tarrifs are killing the free trade between haskell libraries
15:09:44 <TomMD> *light bulb comes on*  I was running into a similar error when playing with halfs recently.
15:10:54 <dcoutts> ndm: send in the patch quick
15:11:07 <ndm> hmm, maybe its fixed in GHC 6.8 and is Yhc using an older version of the library
15:12:40 <ndm> TomMD: if you just :m System.FilePath then do :b, does makeRelativeToCurrentDirectory come up in the list?
15:15:00 <TomMD> ndm: 'makeRelative' appears, but it is exactly that, no 'ToCurrentDirectory'.  Also, :b is now break by default.
15:15:16 <ndm> TomMD: many things change...
15:15:35 <ndm> TomMD: in that case it appears Yhc is using an old copy - if you do scons update, then scons depends, do you have any luck?
15:17:02 <TomMD> ndm: 'scons update ; scons depends ; scons configure ; scons build' fails on the last step with the same error.
15:17:22 <ndm> TomMD: hmm, will just check with filepath Yhc is using...
15:23:11 <ndm> TomMD: scons depends; scons build
15:23:23 <ndm> TomMD: have just updated the filepath repo that Yhc pulls off
15:25:53 <TomMD> ndm:  Somewhat silly/annoying.  First run errored with this "scons: *** [Errno 2] No such file or directory: 'depends/filepath/System/FilePath/Version_0_11.hs".  I subsequently fullcleaned, but now it won't configure again.
15:26:19 <ndm> TomMD: ah, crap - now i remember why we didn't update...
15:26:27 <ndm> TomMD: give me half an hour and i'll fix it up again
15:31:27 <mux> mm, a wordsBy function in Data.List would be welcome
15:31:42 <shachaf> mux: Not a linesBy? :-)
15:31:46 <shachaf> @src words
15:31:46 <lambdabot> words s = case dropWhile isSpace s of
15:31:46 <lambdabot>     "" -> []
15:31:46 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
15:31:48 <shachaf> @src lines
15:31:48 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
15:33:20 <omnId> methinks getRandItem was used to select a "source not found you idiot" insult.
15:34:06 <TomMD> @quote
15:34:06 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
15:34:24 <TomMD> @quote tommd
15:34:24 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
15:34:54 <dibblego> what's a simple function that uses as-patterns?
15:35:35 <omnId> @type \xxs@(_:xs) -> zip xxs xs
15:35:37 <lambdabot> forall t. [t] -> [(t, t)]
15:35:51 <shachaf> @src tails
15:35:51 <lambdabot> tails []         = [[]]
15:35:51 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
15:35:59 <dibblego> ah nice thanks
15:36:12 <shachaf> @src scanr1
15:36:12 <lambdabot> scanr1 f []     = []
15:36:12 <lambdabot> scanr1 f [x]    = [x]
15:36:12 <lambdabot> scanr1 f (x:xs) = f x q : qs where qs@(q:_) = scanr1 f xs
15:36:31 <shachaf> @src insertBy
15:36:31 <lambdabot> insertBy _   x [] = [x]
15:36:31 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
15:36:31 <lambdabot>                                  GT -> y : insertBy cmp x ys'
15:36:31 <lambdabot>                                  _  -> x : ys
15:37:11 <dibblego> I'll use tails thanks; just for the Scala wiki; there's no documentation on as-patterns
15:44:14 * omnId discovers the Pizza language while googling for the Scala wiki.
15:44:27 <omnId> If nothing else its a great name :)
15:45:08 <byorgey> omnId: heh, is it serious, or an esolang?
15:45:14 <hpaste>  mux pasted "wordsBy function" at http://hpaste.org/3418
15:45:21 <omnId> Java + generics, lambdas, and ADTs
15:45:22 <olsner> Java dialect if I recall correctly
15:45:37 <mux> without the extra character check of the standard "words" function
15:46:03 <omnId> http://en.wikipedia.org/wiki/Pizza_programming_language
15:46:06 <olsner> been around for ages - remember reading about Pizza about the same time I was learning Java
15:46:56 <omnId> methinks programmers consume more pizza than java.
15:48:34 <olsner> (this was before I had learned to drink coffee)
15:49:52 * omnId doesn't know many programmers that eat scala.
15:56:30 <omnId> mux: why do you make the break skip the first nondropped element?
15:57:57 <mux> because we already know it doesn't satisfy the predicate
15:58:09 <mux> since it is where the dropWhile stopped
15:58:47 <mux> it was initially neil mitchell (ndm on irc) who realizes there was this extra check, he talked about it in his blog
15:59:07 <ndm> two extra checks per word
15:59:15 <mux> hey there :)
15:59:18 <ndm> hi :)
16:00:44 <byorgey> @src break
16:00:44 <lambdabot> break p =  span (not . p)
16:04:08 <omnId> span _ xs@[]            =  (xs, xs)
16:04:09 <omnId> span p xs@(x:xs')
16:04:09 <omnId>          | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
16:04:09 <omnId>          | otherwise    =  ([],xs)
16:04:38 <LoganCapaldo> span!
16:04:58 <dibblego> http://scala.sygneca.com//code/as-patterns for anyone interested (since you all seem to be :))
16:05:00 <lambdabot> Title: code:as-patterns [Scala Wiki]
16:07:51 <asl> in the implementation of tails, why the ([] : []) as the result of the base case?  for looks?
16:08:15 <dcoutts> asl: rather than what? [[]] ?
16:08:19 <dibblego> for looks? what do you mean? what else do you think it might be?
16:08:32 <dibblego> you mean the syntax?
16:08:47 <asl> ah, I mean, isn't [] polymorphic enough to mean the same thing?
16:08:48 <LoganCapaldo> damn [[]], you look good, not like that ugly [] : []
16:09:11 <LoganCapaldo> [] /= [[]]
16:09:17 <dibblego> [] and [[]] are very different
16:09:21 <dibblego> > length [[]]
16:09:23 <lambdabot>  1
16:09:23 <shachaf> asl: Where do you see that?
16:09:32 <shachaf> > ([] : [])
16:09:33 <lambdabot>  [[]]
16:09:42 <asl> @src tails
16:09:42 <shachaf> @src tails
16:09:42 <lambdabot> tails []         = [[]]
16:09:42 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
16:09:43 <lambdabot> tails []         = [[]]
16:09:43 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
16:09:46 <dibblego> tails returns a list of at least length 1
16:10:04 <asl> dibblego: ah, because the empty list is the tail of everything
16:10:07 <asl> got it
16:10:18 <dibblego> asl, great :)
16:10:29 <shachaf> Oh, I see.
16:10:32 <centrinia> asl, the empty list is the tail of the singleton.
16:10:34 * shachaf missed one message.
16:11:28 <Beelsebob> gyah
16:11:36 <Beelsebob> why am I incapable of coming up with real world examples
16:11:47 <mauke_> because there is only one real world
16:11:53 <Beelsebob> I'm particularly special at coming up with the world's most contrived examples ever
16:11:55 <LoganCapaldo> bwahahah
16:11:56 <centrinia> What is this "real world" you speak of?
16:12:24 <Beelsebob> centrinia: the thing that gets threaded about in the IO monad ;)
16:12:25 <Beelsebob> :P
16:12:41 <centrinia> Ah. ;)
16:13:03 * shachaf feels like he's nothing but an IO action.
16:13:17 <Beelsebob> shachaf: no, merely a side effect
16:13:29 <shachaf> Beelsebob: There are no side effects!
16:13:44 <Beelsebob> depends how you define side effects
16:13:47 <shachaf> That's the point of threading the real world.
16:13:51 <Beelsebob> I'd define them as "changes to the real world"
16:14:07 <Beelsebob> seeing as the other definition is useless in a functional sense
16:14:30 <conal> from another viewpoint, the real world doesn't change -- it's a pure function of time.
16:14:30 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:14:35 <shachaf> Beelsebob: Well, what about State?
16:15:06 <shachaf> Beelsebob: That's just as threaded; do you not treat that as having side effects?
16:15:21 <Beelsebob> shachaf: that's arguable... because it's not the same conceptual model as IO... but on the other hand you do have "side effects" of modifying state
16:15:35 <ddarius> from another viewpoint, the real world doesn't change and time is part of it
16:15:43 <ddarius> (expanding "world" to "universe"
16:15:44 <ddarius> )
16:16:03 <Beelsebob> in the mean time... anyone got any nice producer/consumer examples?
16:16:31 <Beelsebob> I'm trying to come up with a good example of when lazy evaluation order is confusing to the programmer
16:16:39 <Beelsebob> because the computation jumps about all over the place
16:17:04 <centrinia> Beelsebob, print (take 4 (map (1+) [1..]))
16:17:18 <Beelsebob> centrinia: hmmm
16:17:25 <Beelsebob> that may just work
16:17:27 <centrinia> Then show what print (map (1+) [1..]) does >:)
16:17:34 <Beelsebob> if I make (1+) rather more complex
16:18:23 <pBot-> Beelsebob!
16:18:25 <pBot-> omg its the devil
16:18:27 <pBot-> run for your lives!
16:18:28 <centrinia> print $ reverse [1..]
16:18:29 <Beelsebob> pBot-:
16:18:31 <Beelsebob> o.O
16:18:36 <omnId> that's Beelsebub
16:18:41 <omnId> bob's fine
16:18:46 <Beelsebob> I'm just his cousin
16:18:49 <pBot-> ohh
16:19:01 <pBot-> so you were his homie before he went down to hell?
16:19:06 <pBot-> you are actually an angel maybe?
16:19:11 <hpaste>  mauke pasted "id-31.hs" at http://hpaste.org/3419
16:19:13 <Beelsebob> hmm... yeh, centrinia that's a surprisingly nice example actually
16:19:14 <centrinia> Just tell the programmer that you should never lazily reverse an infinite list.
16:19:30 <Beelsebob> (take (map (1+) [1..]))
16:19:33 <mauke> Beelsebob: ^ also uses lazy evaluation
16:19:47 <omnId> Beelsebob: explaining how a list defined recursively in terms of itself evaluates can be instructive.
16:19:49 <shachaf> centrinia: What do you mean by "lazily reverse"?
16:20:02 <ben> omnId: How does it?
16:20:02 <centrinia> That's the opposite of strictly reverse.
16:20:17 <Beelsebob> omnId: I'm not trying to explain lazy evaluation
16:20:25 <Beelsebob> I'm trying to explain why debuggers that show it are bad
16:20:35 <shachaf> How do you do that?
16:20:35 <mauke> what?!
16:20:40 <mauke> and I was trying to help you :(
16:20:47 <omnId> ben: hm?
16:20:49 <Beelsebob> so in that example, if I were to try to debug "take" I would find myself confused by the fact that I couldn' focus on it
16:20:53 <ndm> Beelsebob: or rather one particular debugger is bad?
16:20:57 <centrinia> Strictness is defined by: f is strict iff f () == ()
16:21:08 <Beelsebob> ndm: no, not at all
16:21:13 <ndm> f _|_ == _|_, you mean
16:21:16 <omnId> centrinia: s/()/_|_/g?
16:21:17 <shachaf> centrinia: f _|_ = _|_, no?
16:21:18 <centrinia> Probably.
16:21:21 <ben> omnId: How does a list defined recursively in terms of itself evaluate?
16:21:24 <Beelsebob> ndm: I'm covering hat-anim, hood, ghci, Debug.Trace in this
16:21:26 <LoganCapaldo> lol, id is the only strict function?
16:21:33 <shachaf> LoganCapaldo: No.
16:21:34 <ndm> Beelsebob: but there is exactly one working debugger for haskell, ghci
16:21:38 <omnId> > let xs = 1 : xs in xs
16:21:39 <mauke> LoganCapaldo: const ()
16:21:40 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:21:42 <shachaf> > (+1) undefined
16:21:43 <lambdabot>  Undefined
16:21:47 <Beelsebob> ndm: what's Debug.Trace then?
16:21:53 <Beelsebob> ndm: and what's Hood?
16:22:00 <shachaf> mauke: Do you mean _|_ too? :-)
16:22:16 <ndm> Beelsebob: debug.trace is rudimentary tracking, not debugging
16:22:19 <centrinia> > reverse [1..]
16:22:19 <mauke> shachaf: no, I'm just using centrinia's definition
16:22:23 <lambdabot> Terminated
16:22:26 <LoganCapaldo> there are 2 strict functions :)
16:22:27 <Beelsebob> ndm: debug.trace is rudimentary debugging
16:22:29 <centrinia> Okay, that was bad.
16:22:36 <Beelsebob> it's certainly rudimentary though
16:22:41 <mauke> Beelsebob: showing evaluation order is essential for debugging
16:22:45 <omnId> ben: printing the list like that causes evaluation to start.  Evaluation is outermost-first, so the first thing the printer sees is a cons cell (:) 1 (...) where the (...) is an unevaluated thunk.
16:22:47 <Beelsebob> mauke: not at all
16:22:56 <ndm> Beelsebob: semantics changing and unpredictable is not the phrases i like to hear when debugging
16:23:04 <Beelsebob> mauke: you're just assuming we are gonna use a step-by-step debugger
16:23:14 <omnId> ben: it sees the (:) 1 so it prints "[1," then forces the thunk.
16:23:20 <Beelsebob> ndm: indeed -- so ghci debugger is bad then?
16:23:22 <mauke> Beelsebob: yes, because that's what I'd like to use :/
16:23:35 <ben> Thunk is a cool word.
16:23:38 <Beelsebob> mauke: fair enough -- but that doesn't mean it's the only way to do it, or the way everyone wants to do it
16:23:56 <Beelsebob> ndm: Hood is arguably better than ghci debugger in a lot of cases
16:23:57 <omnId> ben: (...) in this case is xs, which is defined as a cons cell: (:) 1 (...), so the printer put another "1," and forces the thunk.
16:24:02 <Beelsebob> and arguable worse in a lot of others
16:24:16 <ndm> Beelsebob: under my definition of a debugger, Haskell has exactly one, the ghci one
16:24:26 <Beelsebob> ndm: that's nice... your definition is wrong
16:24:28 <Beelsebob> :P
16:24:36 <ndm> a debugger must work in at least 90% of cases and be of basic use for debugging
16:24:50 <Beelsebob> ndm: interestingly, Hat works for 90% of cases of Haskell
16:24:58 <omnId> ben: actually in this particular case the (...) refers to exactly the same thunk, like you had a linked list in C whose tail pointer pointed to itself.
16:25:03 <Beelsebob> it just doesn't work for 90% of cases of an odd language that ghc works on
16:25:05 <ndm> Beelsebob: thats not even remotely true, even with the H98 restriction
16:25:22 <Beelsebob> ndm: the only thing I can think of that Hat doesn't work on for H98 is a few odd cases of defaulting
16:25:31 <Beelsebob> and in those cases, there's a systematic fix to make it work
16:25:33 <ben> omnId: Okay. That does seem instructive to me.
16:26:00 <ndm> Beelsebob: it never works for me, even on linux, and "apart from a commonly used feature" is not 90% of cases
16:26:24 <Beelsebob> ndm: of note, it doesn't break on all defaulting, only some... and there is a systematic fix for it
16:26:36 <centrinia> let { x=(y,z); z = (y,x); y=1; } in x
16:26:44 <Beelsebob> and well, if you can't get it to work, then you're doing something special
16:26:48 <ndm> Beelsebob: if you change the code, you are't debugging it
16:26:48 <omnId> > let fibs = 1 : 1 : (zipWith (+) fibs (tail fibs)) in fibs -- this is the same.  It starts out as two cons cells: (:) 1 ((:) 1 (...)), when the thunk is forced, it looks at the thunks already evaluated so there's no problem.
16:26:50 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:27:21 <Beelsebob> ndm: a lot of debugging papers for imperative programming languages actually argue that if you're not changing the code you aren't debugging it ;)
16:27:34 <ndm> TomMD: if you are still around, please try "scons fullclean; scons depends; scons build" - i think i got it
16:27:43 <ndm> Beelsebob: and they are also wrong
16:27:58 <TomMD> ndm: I'll start it, but eating dinner soon so I'll have to catch you up later tonight.
16:28:18 <ndm> TomMD: i'm off to bed now, so email the yhc mailing list if it doesn't work
16:28:41 <Beelsebob> ndm: anyway, back to my original point that lazy evaluation is not something you want in a debugger... Simon Marlow even says in his paper "Lazy evaluation is confusing, and crap for debugging... but something is better than nothing, so we implemented it"
16:29:06 <mauke> he's also wrong
16:29:45 <ndm> Beelsebob: i agree - but i also think that its the best thing out there, even though it leaks that horrible detail
16:30:00 <Beelsebob> ndm: certainly it's the best practical implementation just now
16:30:17 <Beelsebob> although there are other ideas that are better -- if not practically implemented
16:30:33 <Beelsebob> Hood for example has the massive advantage of being able to print a function
16:30:50 <Beelsebob> mauke: next time ghci debug disapears into 100000 steps of a function you're not interested in, you may not be saying that... but for now, if you like it, use it
16:31:28 <ndm> anyway, i should sleep - bye!
16:31:40 <ndm> (and congratulations to Beelsebob)
16:31:44 <mauke> I haven't used it yet, actually
16:31:50 <Beelsebob> nn ndm
16:32:01 <Beelsebob> ndm: ? congratulations?
16:32:08 <Beelsebob> greg been poking you or something?
16:32:20 <ndm> Beelsebob: greg mentioned
16:32:25 <Beelsebob> thx :)
16:32:31 <monochrom> lazy evaluation is hard. but I won't say it's confusing or crap. (some feeble minds confuse themselves over it, that's all. XD)
16:32:34 <shachaf> Beelsebob: Oh, have I been confusing you with Beelzebuddy?
16:32:50 <Beelsebob> shachaf: dunno?
16:33:09 <shachaf> Beelsebob: I guess I have. You aren't in #nethack much, are you?
16:33:30 <Beelsebob> monochrom: if you're debbuging your program, you're probably already confused and struggling to understand all the logical implications of what's going on, so you probably don't need lazy evaluation ordering on top of that
16:33:39 <Beelsebob> shachaf: nope, not at all
16:33:43 <centrinia> Lazy evaluation allows more programs to execute.
16:34:03 <bbrown> TomMD, you there
16:34:12 <TomMD> bbrown: check
16:34:13 <mauke> Beelsebob: then how do I debug a strictness problem?
16:34:18 <Beelsebob> centrinia: certainly -- I'm not arguing that it's bad for running programs
16:34:20 <fnord123> has anyone reproduced a termite-like lib in haskell?
16:34:31 <Beelsebob> I'm arguing it's bad for debugging logical errors
16:34:35 <Beelsebob> mauke: strict check
16:34:51 <mauke> what's that?
16:34:58 <centrinia> Well, lazy evaluation is like lazy people. You can't really predict when they will show up. :p
16:35:03 <Beelsebob> mauke: perhaps you're doing a different kind of debugging from me... it sounds like you want to do profiling more than debugging
16:35:16 <Beelsebob> mauke: it tells you if you functions are as lazy as they can be or not
16:35:38 <Beelsebob> Olaf argues that the problem with strictness 90% of the time is not not being strict enough, but instead, not being lazy enough
16:36:02 <mauke> no, I had the case of a (pseudo-)infinite loop that was caused by one line of code being too strict
16:36:14 <mauke> or maybe it was a real infinite loop
16:36:22 <Beelsebob> well, strict check would probably have found it for you
16:36:40 <Beelsebob> basically what it does, is it tries your functions with lots of inputs (alla quickcheck), and looks for patterns in the output
16:36:51 <Beelsebob> i.e. is part of the output fixed
16:36:59 <centrinia> We should have uncountable sets in Haskell.
16:37:03 <Beelsebob> but not being produced lazily
16:37:39 <centrinia> data Cantor = Cantor Bool Cantor Cantor
16:38:25 <centrinia> Maybe I don't need the Bool.
16:39:24 <centrinia> Can [Bool] be uncountably infinite?
16:39:53 <TomMD> @let trues = True : trues
16:39:56 <lambdabot> Defined.
16:40:06 <TomMD> centrinia: You mean that?
16:40:22 <centrinia> No, I mean the set of all lists of Bool.
16:40:31 <centrinia> It should be uncountable.
16:42:38 <Beelsebob> should it?
16:42:48 <Beelsebob> why?
16:42:54 <LoganCapaldo> Cantor, Gallop, Trot?
16:43:17 <ddarius> @wn canter
16:43:18 <lambdabot> *** "canter" wn "WordNet (r) 2.0"
16:43:18 <lambdabot> canter
16:43:18 <lambdabot>      n : a smooth 3-beat gait; between a trot and a gallop [syn: {lope}]
16:43:18 <lambdabot>      v 1: ride at a canter; "The men cantered away"
16:43:18 <lambdabot>      2: go at a canter, of horses
16:43:20 <lambdabot>      3: ride at a cantering pace; "He cantered the horse across the
16:43:22 <lambdabot>         meadow"
16:43:24 <centrinia> Beelsebob, you can encode every subset of the set of natural numbers with it.
16:43:39 <Beelsebob> centrinia: yeh, fair enough
16:49:23 <sorear> it's... weird
16:49:49 <sorear> in the canonical model [Bool] is uncountable
16:50:01 <sorear> but not every such value can be constructed
16:50:44 <sorear> One can construct a minimal model closed under all expressable programs (I'm going to call this the 'weak model' by analogy with weak sums, does it have a better name?)
16:51:18 <sorear> which *is* countable, since it is covered by an image of the strings Unicode*
16:51:47 <centrinia> Yeah, Unicode strings are finite...
16:51:55 <sorear> moral: uncountable cardinals are a very slippery subject
16:52:28 <centrinia> There's too many of them!
16:53:10 <sorear> And it only gets worse... the Burali-Forti paradox hurts my head
16:53:55 <omnId> > iterate (concatMap (\c -> if c=='#' then "# #" else "   ")) "#"
16:53:57 <lambdabot>  ["#","# #","# #   # #","# #   # #         # #   # #","# #   # #         # # ...
16:54:22 <sorear> ah, but the cantor set isn't in that list!
16:54:31 <Beelsebob_> omnId: hehe, I find that so much clearer than the monadic example
16:54:36 <omnId> it's the last element :)
16:56:13 <centrinia> It takes longer to evaluate (let f x = (f x,f (x+1)) in f 1) than (let g x = g (x+1) in g 1) :(
16:56:41 <dmwit> > iterate (concatMap (\c -> [c, ' ', c])) "#"
16:56:43 <lambdabot>  ["#","# #","# #   # #","# #   # #         # #   # #","# #   # #         # # ...
16:56:46 <centrinia> But I guess graph reduction makes the first countable. Hmm.
16:56:59 <omnId> dmwit: smart!
16:57:25 <omnId> @pl \c -> [c,' ',c]
16:57:25 <lambdabot> ap (:) ((' ' :) . return)
17:08:03 <shachaf> Hmm, is (:"") (:[])'s relative?
17:08:08 <shachaf> @ty (:"")
17:08:13 <lambdabot> Char -> [Char]
17:08:18 <dmwit> Yes, [] == "".
17:08:18 <wli> I wish there were some way to tell it not to use ap. It's incomprehensible.
17:08:29 <shachaf> dmwit: I meant visually. :-)
17:08:32 <ddarius> wli: Hack the source.
17:08:41 <shachaf> wli: Why?
17:08:48 <shachaf> wli: ap is just S.
17:08:55 <dmwit> shachaf: Oh. =)
17:09:21 <wli> That's all well and good if you're translating to unlambda.
17:09:37 <olsner> :t ap
17:09:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:11:20 <sorear> wli: right, that's exactly what @pl is supposed to do.  it's abstraction elimination as described in section 3.3 of the unlambda manual
17:11:25 <wli> The @pl bits don't preserve types properly anyway.
17:12:50 <wli> sorear: One would hope the thing could work with a different set of combinators and use a higher-flown reference for its algorithm.
17:13:48 <sorear> wli: you'd prefer Curry's BCIW over Schönfinkel's SKI?
17:14:12 <augustss> it's all the same :)
17:14:24 <wli> sorear: Worse, a custom set of combinators reflecting more common programming practices.
17:15:11 <augustss> wli: and why not make a custom set of combinators for each program?
17:15:13 <shachaf> Hmm, what are BCIW?
17:15:20 * shachaf has come across them before, but doesn't remember them.
17:15:24 <shachaf> Isn't C flip?
17:15:30 <omnId> b = (.) iirc
17:15:33 <mauke> augustss: I call those combinators "functions"
17:15:35 <wli> It is until you throw in squishy issues like readability.
17:15:38 <shachaf> Yes, I thought so.
17:15:45 <shachaf> What's W?
17:15:58 <augustss> mauke: I was just feeling transported back to 1981 again :)
17:16:05 <wli> augustss: I think you get that when referencing functions not defined in what's passed to @pl
17:17:27 <omnId> http://en.wikipedia.org/wiki/B,C,K,W_system
17:17:28 <lambdabot> Title: B,C,K,W system - Wikipedia, the free encyclopedia
17:17:36 <omnId> W x y = x y y
17:17:50 <wli> Fixing up whatever issue it has with losing and/or introducing type qualifiers is already serious enough.
17:18:15 <augustss> W = join
17:18:34 <omnId> (in ((->) e), of course)
17:18:35 <augustss> in the reader monad
17:18:41 <LoganCapaldo> W?
17:18:57 * LoganCapaldo looks upscreen
17:18:59 <LoganCapaldo> nvm
17:20:28 <idnar> :t ap
17:20:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:20:40 <wli> K = const, W = join in ((->) e), C = flip, B = (.)
17:21:24 <omnId> S = ap in ((->) e), I = id
17:22:13 <augustss> @pl \ k f g x -> k (f x) (g x)
17:22:13 <lambdabot> liftM2
17:22:25 <augustss> That's Turner's S'
17:22:29 <wli> BCKW actually are more intuitive.
17:22:30 <conal> :t (<*>) -- simpler & more general
17:22:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:22:50 <augustss> @pl \ k f g x -> k (f x) g
17:22:50 <lambdabot> (flip .) . (.)
17:23:09 <augustss> @pl \ k f g x -> k f (g x)
17:23:09 <lambdabot> ((.) .)
17:23:14 <shachaf>  @pl does use join, const, (.), flip
17:23:17 <shachaf> As well as ap.
17:23:56 <omnId> Oh my god.  Point-free programming is combinator calculus!
17:23:57 <augustss> SKIBCW
17:24:21 <augustss> omnId: of course :)
17:24:23 <ddarius> omnId: Yes.
17:25:02 <augustss> it all fits together
17:25:03 <wli> Has anyone else noticed the @pl bits introducing spurious type constraints?
17:25:06 <LoganCapaldo> omnId: like d'uh :-p
17:25:19 <mauke> wli: for example?
17:25:36 <wli> It happened too long ago. I've forgotten it.
17:26:27 <wli> Otherwise I'd probably belt out the example first.
17:32:06 <chessguy> @bot
17:32:06 <lambdabot> :)
17:37:13 <chessguy> wow
17:37:17 <chessguy> i saw 6 minutes of lag in there :)
17:38:18 <chessguy> apparently my router sent the packet by way of jupiter
17:38:53 <dmwit> hah
17:38:59 <dmwit> chessguy++
17:38:59 <sorear> wow, tachyon IP!
17:40:22 <ddarius> Crap!  I need to buy expensive high capacity harddrives now to hold all the stuff I'll download in the "future"?!
17:41:31 <LoganCapaldo> Noooo
17:48:19 <hpaste>  ramza3 pasted "(no title)" at http://hpaste.org/3420
17:48:56 <bbrown> In that code, I need unsigned bytes, when I compiled the code; it was about 5 times what it should had been.  Are there approaches for storing bye data in haskell
17:49:41 <dmwit> ByteString, maybe?
17:49:53 <LoganCapaldo> Word8?
17:50:00 <LoganCapaldo> Data.Binary?
17:50:17 <dmwit> bbrown: I guess it depends on what you want to do with it. =)
17:50:56 <LoganCapaldo> Heck maybe even just using Array would help
17:51:03 <LoganCapaldo> I dunno
17:51:15 <LoganCapaldo> actuallyu
17:51:35 <LoganCapaldo> you're probably have an [Integer] right there
17:52:07 <LoganCapaldo> just doing fontData :: [Int] or fondtData :: [Word8] might help
17:52:16 <LoganCapaldo> size wise
17:52:18 <LoganCapaldo> I dunno
17:52:23 <LoganCapaldo> IANAHE
17:52:58 <dmwit> "I am not a huge expert"?
17:53:28 <LoganCapaldo> Haskell Expert
17:53:35 <LoganCapaldo> but I guess Huge works
17:54:05 <bbrown> is word8 a misnomer, hehe
17:54:32 <LoganCapaldo> I think so :)
17:55:11 <LoganCapaldo> I've complained about it many a time <g>
17:55:14 <monochrom> why is word8 a misnomer?
17:55:52 <LoganCapaldo> cause when I see word I think machine word and then I see 8 so I think 8 machine words :)
17:55:54 <bbrown> because normally a word is thought of as 16 bits, 2 bytes; where a Byte is just 8 bits
17:56:08 <LoganCapaldo> It's a personal problem I know
17:56:50 <bbrown> or at least when I worked with that low-level stuff back in the day, maybe my recollection is off
17:56:58 <dmwit> Yeah, word can refer to any size, really.
17:58:23 <bbrown> dmwit, wikipedia is setting me right;  I stand corrected.  http://en.wikipedia.org/wiki/Word_(computing)
18:00:24 <monochrom> <troll>You can edit wikipedia to add what you believe, then launch a "dispute" war or "neutral POV" war to basically neutralize everyone else's knowledge</troll> :)
18:01:06 <LoganCapaldo> that wikipedia article doesn't solve my problem of reading Word8 as 8 words :)
18:01:19 <LoganCapaldo> I demand another wikipedia article!
18:01:21 <ddarius> LoganCapaldo: Perhaps a full frontal lobotomy would.
18:01:32 <monochrom> In the x86 assembly circle, they use "word" for 16 bits, then "double word" for 32 bits, "quad word" for 64 bits. It sticks. But that is just the x86 asm circle.
18:01:59 <LoganCapaldo> ddarius: that would solve way too many problems
18:02:56 <wli> It's also used by x86-influenced standards orgs/committees, like for PCI.
18:03:08 <monochrom> In other asm circles, and in academia, "word" is whatever the machine word is. I know a machine with a 36-bit word.
18:03:46 <mauke> "word" is this office program
18:03:57 <mauke> import Data.Word97
18:04:00 <SamB> mauke: eeek, that's the worst definition yet
18:04:43 <monochrom> Should it be Data.Word97 or Office.Word97 or Vulnerability.Word97?
18:06:02 <LoganCapaldo> why choose?
18:06:54 <monochrom> Because you have to type in one of them.
18:07:08 <LoganCapaldo> no mean why not support all 3? :)
18:07:11 <mauke> word 97: advanced type system
18:07:19 <monochrom> Yes, you can also type in all of them.
18:07:47 <monochrom> "all of them" is still a choice.
18:07:59 <LoganCapaldo> @remember mauke word 97: advanced type system
18:07:59 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
18:08:21 <monochrom> INTERESTING!
18:08:31 <shachaf> The quote plugin is broken.
18:08:54 <LoganCapaldo> I guess lambdabot didn't like that one
18:09:07 <monochrom> "Capt'in, the random number generator is failing!"
18:10:33 <wli> Well, at least Linux renamed memcpy_from_fs_to_gs(), though set_fs() and get_fs() are still there.
18:10:53 <sorear> @seen twanvl
18:10:53 <lambdabot> I saw twanvl leaving #haskell 15m 9s ago, and .
18:10:56 <wli> Frankly I'm surprised they didn't call it rep_stosl_from_fs_to_gs() and leave it that way.
18:14:26 <bran_> is there an Eq ish class for structures that need IO to compare?
18:14:37 <LoganCapaldo> bran_: wah?
18:14:55 <LoganCapaldo> you doing crazy things!
18:15:08 <LoganCapaldo> I need to take a vacation from this channel
18:15:25 <LoganCapaldo> things are too real in here
18:16:39 <monochrom> If you need a break from reality, just avoid IO. :)
18:18:12 <wli> Do you count derangement(s)? ;)
18:18:15 <wli> > let facs = 1 : scanl1 (*) [1..] in take 10 . map numerator . zipWith (*) facs . scanl1 (+) . map recip . zipWith (*) facs $ cycle [1, -1]
18:18:16 <lambdabot>  [1,0,1,2,9,44,265,1854,14833,133496]
18:20:36 <bran_> like if you want to compare two hashtables?
18:20:53 <SamB> bran_: why the heck would you have hashtables?
18:21:02 <LoganCapaldo> Also why would hask tables need IO?
18:21:07 <LoganCapaldo> heh
18:21:09 <LoganCapaldo> hask
18:21:11 <bran_> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-HashTable.html
18:21:13 <lambdabot> http://tinyurl.com/2lcw77
18:21:15 <LoganCapaldo> I meant hash
18:21:26 <SamB> we so need to get that out of base
18:21:39 <SamB> these poor people keep trying to USE it
18:23:14 <LoganCapaldo> do x <- toList hash1 ; y <- toList hash2 ; return (x == y) ?
18:23:32 <LoganCapaldo> oops
18:27:09 <LoganCapaldo> why is that in IO anyway?
18:28:25 <wli> It's too late for that. We have arrays.
18:28:37 <LoganCapaldo> ?
18:29:12 <wli> If you've got arrays, people will try to use them for hashtables.
18:29:18 <LoganCapaldo> oh
18:29:30 <LoganCapaldo> yes, yes we will
18:29:40 <LoganCapaldo> actually I don't think I've ever used an Array in Haskell
18:29:44 <LoganCapaldo> damn
18:29:47 <LoganCapaldo> that's weird
18:36:48 <dmg_> @seen ndm
18:36:48 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 2h 4m 10s ago, and .
18:52:45 <LoganCapaldo> is there a pure hashtable floating around out there?
18:53:00 <sorear> no
18:53:06 <vBergmann> @doc !!@help
18:53:06 <lambdabot> !!@help not available
18:53:10 <vBergmann> @help
18:53:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:53:14 <vBergmann> @list
18:53:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:53:27 <sorear> indeed, it is provably impossible to implement a O(1) associative array without mutation or laziness
18:53:47 <LoganCapaldo> or laziness?
18:53:57 <EvilTerran> O(log n) (ie O(1) in practice), surely?
18:54:03 <sorear> @go Pure versus impure LISP
18:54:07 <lambdabot> http://portal.acm.org/citation.cfm?id=237741&coll=portal&dl=ACM
18:54:07 <lambdabot> Title: Pure versus impure Lisp
18:54:09 <LoganCapaldo> So it's possible to have one in Haskell?
18:54:26 <sorear> Maybe.  Probably not.
18:54:34 <LoganCapaldo> k
18:54:35 <sorear> The proof was done in a strict language.
18:54:45 <LoganCapaldo> interesting
18:54:55 <vBergmann> @help hoogle
18:54:55 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
18:55:06 <LoganCapaldo> You could have one in ST instead of IO I suppose
18:55:07 <sjanssen> we can use DiffArray tricks
18:55:18 <vBergmann> hoogle !!
18:55:23 <vBergmann> @hoogle !!
18:55:24 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
18:56:18 <sorear> Anyways, 1. there exists an algorithm which can be implemented in O(k) with mutation, but at least O(k log k) without 2. with O(1) associative arrays, reference cells can be implemented in O(1)   therefore, O(1) associative arrays cannot exist in a strict pure language.
18:56:48 <LoganCapaldo> hehhe
18:56:53 <LoganCapaldo> I like the 2nd one
18:57:32 <LoganCapaldo> that's a devlish one
18:58:00 <wli> I'm all ears to hear how one can escape Omega(lg(n)) circuit depth...
18:59:30 <EvilTerran> "assume n never exceeds 2^64..."
18:59:34 <monochrom> Indeed, "O(1) memory access" is a lie.
18:59:36 <LoganCapaldo> memory is magically fast, obviously :)
18:59:52 <LoganCapaldo> and you never ever have to page from disk either :)
19:00:18 <wli> Enter NUMA... and paging, yes. TLB and cache misses make things interesting, too
19:00:21 <monochrom> <troll>It is a conspiracy of the imperative people to tout their O(1) memory access to FUD functional programming.</troll>
19:01:45 <johnnowak> joy is purely functional, strict, and can have O(1) associative arrays
19:01:56 <wli> mrads, srads, and irads (Resource Affinity Domains for Memory, Scheduling, and Interrupts or IO) make things more interesting still when they don't line up perfectly.
19:03:04 <wli> The n <= 2^64 fallacy is really blatant.
19:03:24 <wli> Memory is sped up by hacks where not all the address lines are wired.
19:03:54 <wli> Also, real architectures have physical addressing limits well below 2^64; IA64 has the largest at 2^52.
19:05:00 <EvilTerran> still, pragmatism..
19:05:24 <EvilTerran> ...dictates that we ignore asymptotic complexities entirely, and chose our algorithms exclusively by profiling
19:05:57 <EvilTerran> :P
19:06:17 <SamB> it does not!
19:06:19 <wli> You will never get a chance to compile, much less run or profile, any significant program on a significantly broad spectrum of systems.
19:07:13 <wli> And that really applies to insignificant ones even more so.
19:07:45 <wli> If you can't get a lot of it right on the basis of a priori considerations you are out of the game.
19:09:04 <johnnowak> EvilTerran: stop overstating your point for effect this instant!
19:09:20 <EvilTerran> i refer you to <EvilTerran> :P
19:09:44 <monochrom> recursive reference.
19:10:08 <EvilTerran> fix refer!
19:10:19 <EvilTerran> fix reefer :: Madness?
19:10:41 <monochrom> newtype Madness = Madness Madness
19:11:34 <LoganCapaldo> how does joy have O(1) associative arrays?
19:11:58 <wli> I'm not sure there are adequate theoretical tools for counting cacheline and TLB misses.
19:13:32 <johnnowak> LoganCapaldo: i'm not sure it does, but it could. in a concatenative language, it's pretty easy to do it because all data is singularly referenced (if dup actually duplicates)
19:14:00 <johnnowak> so really it has to be concatenative and linear, but concatenative languages are linear automatically with the right primitives... you don't need types to enforce it
19:15:10 <johnnowak> a linear lisp could do the same
19:15:19 <wli> The usual algorithmic analysis methods lack data structure layout and tracking which pages and cache lines are touched vs. cache and TLB entry replacement policies.
19:15:27 <mrd> > fix (\ x -> succ x)
19:15:29 <lambdabot>  Exception: <<loop>>
19:15:52 <ricky_clarkson> > fix succ
19:15:53 <lambdabot>  Exception: <<loop>>
19:16:10 <ricky_clarkson> Why does \x -> succ x look so bad to me now, when it looked so great only a year ago?
19:16:24 <shachaf> ricky_clarkson: It's amazing, isn't it? :-)
19:16:27 <wli> eta reduction?
19:16:30 <LoganCapaldo> cause it's redundant?
19:16:48 <vagif> Hello. Trying to install HAppS and having problems. It requires HTTP library. BUt when installing HTTP it requires Cabal 1.2
19:16:52 <shachaf> .map {|x| x.f } in Ruby also looks bad.
19:17:06 <ricky_clarkson> .map(_.f) in Scala looks good.
19:17:10 <idnar> I don't think .map { .f } is valid syntax, though :P
19:17:11 <sorear> vagif: Install Cabal 1.2
19:17:11 <shachaf> I understand they're adding .map(&:f) in 2.0?
19:17:14 <idnar> er
19:17:15 <vagif> How to install cabal 1,2 ? It looks like it requires... itself !!
19:17:25 <idnar> I don't think that's what I mean anyway, I shouldn't try and write code in a language I don't know
19:17:27 <stepcut> vagif: you can install cabal 1.2 using cabal 1.1
19:17:35 <stepcut> vagif: Atleast, I just did a few hours ago
19:17:44 <stepcut> vagif: so I could install http
19:17:49 <alexj> vagif: I use searchpath with happs and not deal with cabal issues.
19:17:58 <vagif> when running ./setup build on cabal 1.2 i got following error:
19:17:59 <alexj> s/not/don't.
19:17:59 <thoughtpolice> vagif: yeah, i installed 1.2 a few hours ago as well with no problems.
19:18:04 <stepcut> vagif: you might also be able to use the slightly older version of http, which works with the older cabal
19:18:22 <idnar> every time I see that syntax, though, I struggle to avoid laughing hysterically and drooling, because it's the basically same syntax that dBASE / Clipper had for code blocks
19:19:01 <vagif> Cabal.cabal:23: 'Executable' stanza starting with field 'extra-source-files'
19:19:16 * wli ignores ruby and scala and looks at Cayenne.
19:19:38 * EvilTerran can't understand how people can possibly be happy with .map {|x| x.f }
19:19:50 <vagif> i'll try older HTTP
19:19:51 <monochrom> dBase was my third programming language. First was some programmable calculator. Second was BASIC.
19:20:00 <EvilTerran> sections are fantastic!
19:20:15 <shachaf> EvilTerran: That's not even a section.
19:20:28 <EvilTerran> well, {.f} would kinda be a (.) section
19:20:30 <shachaf> Well... OK, it's a method call.
19:20:33 <shachaf> Right.
19:21:16 <wli> C was first for me, unless you count a one-off Runge-Kutta diffeq solver in BASIC as having learned BASIC.
19:21:30 <shachaf> In Ruby, since "f" means "f()", you can't even refer to f easily.
19:21:42 <shachaf> You have to say method(:f) or something like that.
19:22:05 <wli> At that point I'd suggest using another language.
19:22:35 <idnar> I think I had C first, then later BASIC; but I kinda left C alone for a while before coming back to it
19:23:14 <newsham> BASIC -> BASIC -> BASIC -> 6502 -> C -> 68000
19:23:26 <wli> I was never a BASIC programmer. I just hammered out the solver in one day.
19:23:34 <ricky_clarkson> shachaf: I hate to harp on, but Scala: f _ refers to f.
19:23:55 <LoganCapaldo> I went basic -> qbasic -> visual basic -> C++ -> ... gets hazy here ...
19:24:12 <idnar> ricky_clarkson: does it have currying, or does that only work on a function with one arg?
19:24:27 <dmwit> > 1000/60
19:24:33 <johnnowak> shachaf: if you think about it, you'll realize that referring directly the methods isn't something you want to do much anyway
19:24:38 <lambdabot>  16.666666666666668
19:24:38 <allbery_b> * EvilTerran can't understand how people can possibly be happy with .map {|x| x.f }
19:24:46 <LoganCapaldo> There are a lot of things in my past I'm not proud of :)
19:24:47 <allbery_b> everything is relative.  compare to perl, php, or C :)
19:24:51 <johnnowak> you need blocks because just passing a method and using it will use it in a different scope than which it was intended
19:24:58 <shachaf> johnnowak: Probably not.
19:25:04 <idnar> C -> BASIC -> Pascal / C -> C++ -> Python + others (like Haskell more recently)
19:25:05 <EvilTerran> perl's got the advantage of loads of stuff using $_ implicitly, though
19:25:07 <newsham> allbery: bad syntax is a lot easier to deal with than missing concepts
19:25:15 <shachaf> johnnowak: Yes, I remember Io had a clear distinction, right?
19:25:31 <ricky_clarkson> idnar: def f(x: Int,y: Int)=x+y
19:25:32 <johnnowak> shachaf: Yes, so does Ruby, Smalltalk, etc.
19:25:55 <shachaf> johnnowak: Well, what if you want to talk about a function, in Ruby?
19:25:56 <ricky_clarkson> idnar: f _ gives an (Int, Int) => Int
19:26:03 <idnar> ricky_clarkson: ah
19:26:04 <shachaf> johnnowak: Do you just store it in a Proc?
19:26:23 <johnnowak> shachaf: I don't know Ruby very well. However, I'm not sure what you'd mean by "just a function". How would it be different than a method?
19:26:24 <ricky_clarkson> idnar: f((_: Int),5) gives an Int -> Int.  I don't know why I have to specify the type there.
19:26:25 <wli> I didn't take programming seriously for a long time. I thought it was just some way to write down formulas.
19:26:36 <allbery_b> functions are methods :)
19:26:53 * LoganCapaldo kind of wishes he had wli's old attitude
19:26:58 <johnnowak> Exactly, and hence you need to be careful regarding their namespaces.
19:27:04 <idnar> I learned programming before maths
19:27:05 <monochrom> Programming should be some way to write down formulas. :)
19:27:07 <thoughtpolice> php :( -> c -> perl -> ... -> haskell?!
19:27:08 <allbery_b> unfortunately I don't recall how ruby does it either
19:27:19 <allbery_b> (not gaving a good night.  again)
19:27:41 <idnar> I seem to recall finding algebra easy to understand because I was already used to working with "unknowns" in my programs
19:27:42 <wli> Actually if you're going to claim I was a BASIC programmer you'll have to claim I was an Algol programmer first.
19:27:53 <idnar> I think it has left me with a rather distorted view of everything, though
19:28:13 <ricky_clarkson> I started off with crying and wetting myself.  Life went down from there really.
19:28:34 <allbery_b> BASIC, 6502 asm, Z80 asm, FORTRAN, COBOL, C, (...25+ years of learning...), Ruby, Haskell.  roughly
19:28:59 <monochrom> idnar: That's actually nice. Only caveat is imperative programming's "unknown" is mutable. Remove that, and you actually understand the point of algebra!
19:29:04 <wli> Some friend of the family was an Algol programmer and I got to try out something small with that first, though I don't recall offhand what it was. I think it was some power series method for computing some function.
19:29:14 <ricky_clarkson> I don't know how you can do 25+ years of learning, without either including lisp or writing your own programming language.
19:29:28 <allbery_b> oddly enough, I've done both
19:29:36 <newsham> you z80 programmers and your luxurious 16-bit stack pointer!
19:29:44 <wli> ricky_clarkson: Writing your own OS kernel?
19:29:54 <idnar> monochrom: heh
19:30:13 <idnar> monochrom: I also remember being confused by the mathematical concept of a "function", because it wasn't really anything much like the functions I was used to
19:30:19 <newsham> I had to swap the 8-bit stack pointers and share two 128-bit stacks to multitask on my 6502 :(
19:30:51 <idnar> monochrom: once I figured out how the two overlapped, I suddenly understood functional programming languages a whole lot better
19:30:54 <newsham> ricky: there are a lot of things to do with computers outside of functional programming.
19:30:57 <bparkis> does anyone know of a paste site that doesn't require a captcha or that has a capcha that doesn't u se javascript?
19:31:01 <newsham> a point that is often overlooked by functional programmers
19:31:04 <idnar> (of course, this was many years later)
19:31:06 <mrd> ?paste
19:31:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:31:49 * allbery_b actually dug out the implementation details of the BASIC interpreter on his 6502 SBC and made the BASIC multitask, including a split-screen setup for both instances
19:31:54 <allbery_b> that was fun
19:32:00 <idnar> ricky_clarkson: well, I can't quite claim 25+ years, but I can't really claim to have learned lisp, and I've never even given a thought to writing my own programming language
19:32:04 <ricky_clarkson> newsham: I didn't mention functional programming.
19:32:05 <newsham> SBC?
19:32:13 <allbery_b> "single board computer"
19:32:21 <johnnowak> i think i learned to program just for the sake of being able to write my own programming language
19:32:23 <allbery_b> literally a bare circuit board
19:32:37 <johnnowak> i don't seem to do anything else with the knowledge
19:32:40 <idnar> ricky_clarkson: I suspect it'll be another 10 years before I would even consider allowing myself to write my own language
19:32:44 <wli> My interest was in math. I thought of computers as a sort of ridiculous hybrid between typewriters and calculators.
19:32:51 <ricky_clarkson> johnnowak: I'd guess you'd like one of those bare bones FORTHs.
19:33:01 <johnnowak> idnar: you learn a lot in the process of repeatedly screwing it up
19:33:02 <bparkis> thanks tat works
19:33:21 <idnar> johnnowak: yeah, maybe
19:33:29 <ricky_clarkson> idnar: I wrote my own before I knew what the word 'parse' meant.
19:33:30 <johnnowak> ricky_clarkson: that was my first, yes
19:33:35 <wli> I had zero respect for them. I thought of the numbers that came out as jokes of sorts, like the silliness with memorizing pi to numerous digits.
19:33:49 <vBergmann> wli: so how do you think about computers now?
19:33:54 <idnar> johnnowak: but I prefer a slightly less brute-force approach to learning
19:34:24 <mrd> math isn't 'real'.  computers produce 'real' results.
19:34:29 <johnnowak> idnar: i'm not sure i'd call it "brute force". i'm not saying write things and have them fail. it's the research aspect and challenging your earlier ideas where you learn.
19:34:52 <idnar> johnnowak: ok, fair enough
19:34:56 <wli> vBergmann: War machines. They're weapons for cryptanalysis, guiding missiles to their targets, ferreting out dissidents, and enriching the wealthy at the expense of the poor.
19:34:58 <allbery_b> ==johnnowak
19:35:06 <allbery_b> that's the essence of learning, really
19:35:12 <johnnowak> i reject that equality
19:35:23 <idnar> johnnowak: I guess it's just not a problem I want to tackle head on right at the moment, I'd rather absorb some of the necessary knowledge in a more indirect fashion for a while
19:35:34 <monochrom> Weapons of Mass Decryption.
19:35:38 <newsham> wli: computers dont enrich the poor?
19:35:42 <allbery_b> don't want me agreeing with you?
19:35:46 <idnar> but I haven't ever really felt any interest in designing my own language
19:35:46 <wli> newsham: No.
19:35:59 <johnnowak> allbery_b: Heh, I learned C first. I thought that was a typo for ++johnnowak. :)
19:36:03 <idnar> I think it's really just because I'm still discovering all the wonderful languages out there
19:36:18 <Philippa> newsham: if you think western economics tends to enrich the rich more so than the poor then computers let that happen faster
19:36:29 <Philippa> me, I'd be in a much harsher world without them
19:36:49 <newsham> philippa: absolute wealth has increased for all members of society.
19:37:04 <newsham> income disparity is another issue.
19:37:19 <lokimaf> all to gods order ;-)
19:37:22 <EvilTerran> blah?
19:37:28 <ricky_clarkson> idnar: I think being able to easily steal things from other languages is fun.
19:37:30 <newsham> yes, this is a very bla discussion.
19:37:30 <johnnowak> income disparity was much lower when we were all hitting each other with clubs
19:37:38 <newsham> john: yes it was.
19:37:45 <ricky_clarkson> That's why I like lisp, though I can't figure out how to easily steal Haskell's type system for it.
19:37:55 <EvilTerran> ah, for the days when leaves were currency...
19:38:08 <allbery_b> anyway, re languages:  never a *compiler* per se; a toy forth interpreter to teach myself 68000 assembler, some other interpreters to learn hopw to use lex and yacc, and later on again to teach myself not to need them (i.e. to learn how to do my own lexers and parsers)
19:38:13 <wli> Well, I'll take on the economics on #haskell-blah if need be; the point is I see computers as weapons anymore.
19:38:36 * EvilTerran wanders off to clean phones
19:39:04 <ricky_clarkson> EvilTerran: Is that a Douglas Adams reference?
19:39:05 <allbery_b> and various practical tools which generated C code from "higher level" specifications (query languages, really; I could stretch things and say I reinvented QUEL before I knew anything of Prof. Stonebraker's work)
19:39:31 <EvilTerran> indeed. it started at the leaves/currency comment, even
19:39:33 <allbery_b> or Codd &  Date
19:41:13 <allbery_b> and I suspect I have literally forgotten more languages than most people know, mainly because early on I went on a whirlwind tour of computer languages, mostly not retaining the syntax but remembering the ideas behind them
19:42:25 <geocalc> ^good
19:42:46 <newsham> snobol4life
19:48:03 <newsham> how does one define addition of natural numbers using gadts?
19:49:08 <chessguy> allbery_b, do you suggest such a 'tour'?
19:49:27 <chessguy> s/suggest/recommend/
19:49:29 <Philippa> newsham: you mean at the type level, presumably?
19:49:34 <allbery_b> depends.  it worked for me, but I think I'm a bit odd
19:49:35 <newsham> yes
19:49:53 <allbery_b> (how many people pick up basic haskell in a couple months in their mid-40s?)
19:50:11 <allbery_b> with very little prior  FP exposure
19:50:35 <allbery_b> I've always been somethhing of a knowledge sponge.
19:50:44 <newsham> ie. (Succ n) is supposed to be a type that can only take a (Succ n) or a Z as a type arg
19:54:41 <TSC> Bugs?  Impossible
19:56:17 * mrd hands lambdabot a bottle of Raid
19:56:40 <newsham> ?bot has bugs?  hopefully nothing contagious
19:56:40 <lambdabot> :)
19:57:00 <shachaf> @botsnake
19:57:00 <lambdabot> :)
19:57:37 <shachaf> @seen dcoutts
19:57:37 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell, #ghc and #darcs. I don't know when dcoutts last spoke.
20:02:06 <newsham> is it possible to do natural arithmetic in gadts?
20:02:38 <sorear> no
20:02:57 <sorear> well you CAN, but ghc isn't smart enough to see associativity &c
20:04:02 <newsham> data N x where {Z :: N x; S :: x -> N x}   what for Add?   Add :: x -> S y -> S (Add x y)
20:04:06 <newsham> but what of the base case?
20:17:01 <dons> ?yow
20:17:02 <lambdabot> My Aunt MAUREEN was a military advisor to IKE & TINA TURNER!!
20:20:33 <chessguy> @arr
20:20:34 <lambdabot> Yeh scurvy dog...
20:21:18 <shachaf> @brain
20:21:18 <lambdabot> What can I do for fun, Pinky? That's it! I'll send several
20:21:18 <lambdabot> bills to Senate for ratification, then veto them all!
20:21:41 <monochrom> hahahaha
20:22:16 <idnar> *giggle*
20:23:38 <vBergmann> @help yow
20:23:38 <lambdabot> yow. The zippy man.
20:23:49 <vBergmann> @help brain
20:23:49 <lambdabot> brain. Pinky and the Brain
20:26:06 <lekro> I'm trying to install HOpenGL. I did autoreconf and "runghc Setup.hs configure". When starting the build step it immediately returns with the error: Setup.hs: OpenGL.cabal:114: Unknown field 'install-includes'. What is the system telling me here?
20:26:37 <lekro> or better, why doesn't it know the field install-includes?
20:28:53 <newsham> i guess gadts dont see much action here?
20:32:46 <lekro> oh, I guess I found the problem.
20:33:03 <lekro> ghc-6.4 is not enough, it needs 6.6
20:41:41 <SamB> @brain
20:41:41 <lambdabot> Wuh, I think so, Brain, but isn't Regis Philbin already married?
20:41:51 <SamB> @brain
20:41:52 <lambdabot> It is here that my cheap workforce of trained iguanas will work
20:41:52 <lambdabot> night and day to make our shoes to my exacting specifications!
20:42:10 <SamB> @brain
20:42:10 <lambdabot> Uh, I think so, Brain, but I get all clammy inside the tent.
20:42:17 <SamB> @brain
20:42:18 <lambdabot> Be quiet Pinky, or I shall have to hurt you.
20:42:20 <SamB> @brain
20:42:20 <lambdabot> I think so, Brain, but I don't think Kaye Ballard's in the union.
20:42:24 <SamB> @brain
20:42:24 <lambdabot> The game does not conclude until the woman with the eating disorder ululates.
20:42:37 <SamB> @brain
20:42:37 <lambdabot> Be quiet Pinky, or I shall have to hurt you.
20:43:05 <newsham> ?. brain vixen
20:43:05 <lambdabot> I think so, Brain, but we're already naked.
20:43:12 <newsham> ?. vixen brain
20:43:12 <lambdabot> yes
20:44:01 <SamB> ?. brain vixen
20:44:01 <lambdabot> But where will we find an open tattoo parlor at this time of night?
20:44:17 <SamB> @brain tattoo
20:44:17 <lambdabot> It is here that my cheap workforce of trained iguanas will work
20:44:17 <lambdabot> night and day to make our shoes to my exacting specifications!
20:44:24 <SamB> hmm. no influence.
20:47:09 <stoic_> is length . group . quicksort faster than length . nub ?
20:47:21 <newsham> ?. fixen brain
20:47:21 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "fixen"
20:47:24 <chessguy> ululates, lol
20:47:29 <newsham> ?. vixen brain
20:47:29 <lambdabot> you sir are no gentleman
20:48:08 <newsham> stoic: I believe so.  nub should be quadratic.
20:48:23 <newsham> group.quicksort is just aprox nlogn right?
20:49:54 <sclv> we need a faster default nub algorithm.
20:50:22 <mrd> how would you get one without more constraints?
20:51:32 <vBergmann> @help vixen
20:51:32 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
20:51:43 <newsham> ?vixen a/s/l?
20:51:43 <lambdabot> 19/f/California
20:54:21 <sclv> mrd: you'd need to require ord maybe, but still -- how often do we need a nub of things that don't implement ord?
20:54:39 <mrd> well there is a short piece of code that works then
20:54:52 <mrd> map head . group . sort
20:55:32 <mrd> > take 2 . nub $ [1,1] ++ [2..]
20:55:34 <lambdabot>  [1,2]
20:55:47 <mrd> the way nub is defined also interacts nicely with laziness
20:56:13 <sclv> @src nub
20:56:13 <lambdabot> nub = nubBy (==)
20:56:20 <sclv> @src nubBy
20:56:21 <lambdabot> nubBy eq []             =  []
20:56:21 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:56:31 <mrd> > nubBy (\ x y -> y `mod` x == 0) [2..]
20:56:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:56:42 <TSC> Yes, if you do "take m . nub", it's O(m^2)
20:57:35 <xelxeba1> @src quot
20:57:35 <lambdabot> Source not found. :(
20:58:08 <xelxeba1> 20 `quot 10
20:58:21 <xelxeba1> > 20 `quot` 10
20:58:23 <lambdabot>  2
20:58:29 <stoic_> #~.0-.~,,2 3 4 (](]*>) [:> <"0@[([:+/&.>/ ^~&.>) [:prs&.> >.@%:)50e6 ... J is great
20:59:36 <sclv> what about ordNub = Data.Set.toList . Data.Set.fromList
20:59:55 <mrd> that could work too i suppose
21:00:59 <sclv> you could also do a nubBy with maps, I suppose.
21:02:56 <sclv> the only problem is that set's default toList uses foldl'
21:03:26 <lekro> can you rely on the behaviour of nubBy used with non-commutative equality function?
21:03:29 <mrd> > take 10 $ sort [1..]
21:03:34 <lambdabot> Terminated
21:03:54 <TSC> I think the == in Eq is supposed to be symmetric
21:03:59 <xelxeba1> sort [3,7,1]
21:04:04 <xelxeba1> > sort [3,7,1]
21:04:05 <lambdabot>  [1,3,7]
21:04:41 <lekro> TSC: but maybe it's in the standard that nubBy always calls eq x y and not eq y x
21:04:50 <sclv> if it used a foldr instead, by fusion we could probably get the standard nub behavior
21:07:06 <xelxeba1> @src sort
21:07:06 <sclv> hey -- you can create a singleton set out of things that aren't instances of Ord! except then you can't insert.
21:07:06 <lambdabot> sort = sortBy compare
21:07:16 <xelxeba1> @src compare
21:07:16 <lambdabot> compare x y | x == y    = EQ
21:07:16 <lambdabot>             | x <= y    = LT
21:07:16 <lambdabot>             | otherwise = GT
21:07:24 <sclv> @src sortBy
21:07:24 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
21:07:35 <xelxeba1> thanks
21:07:58 <sclv> insertion sort -- again, works great with laziness and hideous with efficiency. we were talking about this this morning. i'm noticing a pattern here...
21:08:01 <mrd> that's not really what's used
21:09:07 <xelxeba1> what's really used?
21:09:44 <mrd> mergesort
21:09:50 <lekro> does it have a reason why compare uses <= where < would be sufficient?
21:10:21 <mrd> maybe to deal with bad ord instances /shrug
21:10:33 <stoic_> > fromDistinctAscList [1,2,3,3,4]
21:10:34 <lambdabot>   Not in scope: `fromDistinctAscList'
21:11:10 <stoic_> > Data.IntSet.fromDistinctAscList [1,2,3,3,4]
21:11:15 <lambdabot>  fromList [1,2,3,4]
21:11:36 <xelxeba1> @src mergesort
21:11:36 <lambdabot> Source not found. You type like i drive.
21:12:03 <xelxeba1> :P
21:12:10 <stoic_> > Data.IntSet.fromDistinctAscList [2,3,5,3,1,6,6]
21:12:11 <lambdabot>  fromList [1,2,3,5,6]
21:14:02 <xelxeba1> b
21:14:13 <xelxeba1> whoops, sorry
21:14:34 <sclv> http://darcs.haskell.org/ghc-6.6/packages/base/Data/List.hs
21:14:56 <sclv> I'm feeling sort of dumb parsing how this particular mergesort works.
21:15:05 <mrd> http://hpaste.org/3422
21:17:53 <sclv> what am I missing in the mergesort?
21:18:28 <sclv> I don't see where it's breaking down the list into sublists via recursive calls
21:18:58 <mrd> map wrap
21:19:20 <mrd> then it successively merges consecutive sublists
21:19:38 <dibblego> let f [] ys = ys; f xs [] = xs; f (x:xs) (y:ys) = x : y : f xs ys in f [1..5] [8,9,10] -- what is the name of this function?
21:19:43 <dibblego> > let f [] ys = ys; f xs [] = xs; f (x:xs) (y:ys) = x : y : f xs ys in f [1..5] [8,9,10] -- what is the name of this function?
21:19:52 <mrd> unzip?
21:19:54 <lambdabot>  [1,8,2,9,3,10,4,5]
21:20:08 <mrd> er
21:20:19 * mrd bonks self
21:20:24 <dibblego> f :: [t] -> [t] -> [t]
21:21:21 <mrd> > concat $ zipWith (++) [[1],[2],[3]] [[4],[5],[6]]
21:21:22 <lambdabot>  [1,4,2,5,3,6]
21:21:37 <sclv> mrd: o.k., I sort of see it now.
21:25:06 <sclv> > concat $ zipWith (\x y-> [x,y]) [1..5] [8..10] -- still doesn't have the same semantics, because it stops interleaving once either list runs out
21:25:08 <lambdabot>  [1,8,2,9,3,10]
21:25:18 <shachaf> dibblego: I would call it "interleave", maybe?
21:25:24 <shachaf> @go haskell interleave
21:25:26 <lambdabot> http://blog.moertel.com/articles/2006/03/23/the-perfect-shuffles-puzzle-solved-in-haskell
21:25:26 <lambdabot> Title: The "perfect shuffles" puzzle (solved in Haskell)
21:25:40 <dibblego> shachaf, yeah, I would too
21:25:41 <shachaf> That page would, too.
21:27:04 <mrd> :t interleave
21:27:06 <lambdabot> Not in scope: `interleave'
21:27:06 <sclv> a zipWith with cases for how to handle the remainder of a list after the other runs out would be handy.
21:27:10 <mrd> @hoogle interleave
21:27:11 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
21:27:11 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
21:27:15 <mrd> @hoogle intersperse
21:27:15 <lambdabot> List.intersperse :: a -> [a] -> [a]
21:27:57 <sclv> > intersperse '!' "haskell"
21:27:58 <lambdabot>  "h!a!s!k!e!l!l"
21:35:39 <sclv> > "give me a " ++ (concat . List.intersperse "! give me a " $ (List.map (:[]) "HASKELL")) ++ "! and what does that spell?"
21:35:41 <lambdabot>  "give me a H! give me a A! give me a S! give me a K! give me a E! give me a ...
21:35:51 <idnar> hahaha
21:38:29 <mrd> HASKE?
21:38:53 <sclv> haske not what your language can do for you...
21:40:50 <newsham> ?let cheer x = concatMap (" give me a " ++) (words x)
21:40:52 <lambdabot> Defined.
21:41:20 <newsham> ?eval cheer "test one two"
21:41:38 <Cale> > cheer "test one two"
21:41:40 <lambdabot>  " give me a test give me a one give me a two"
21:41:48 <newsham> cant use eval with defineds?
21:42:25 <thoughtpolice> you can use the @. plugin iirc
21:43:41 <newsham> yah was gonna see if I could ?. with "cheer" and "brain"
21:46:14 <thoughtpolice> @. cheer eval "one two three"
21:46:14 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "cheer"
21:46:20 <thoughtpolice> @. @cheer @eval "one two three"
21:46:21 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "@cheer"
21:46:31 <thoughtpolice> hm
21:49:04 <thoughtpolice> @compose @do @undo do { n <- return 3; print n }
21:49:05 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "@do"
21:58:11 <omnId> > concat $ transpose ["foo", "barbaz"]
21:58:12 <lambdabot>  "fboaorbaz"
22:11:48 <prb> What's the preferred way to get the name of the current module, e.g., for use as a logger handle?
22:12:35 <prb> I assume that there's a straightforward way via -fth, but it's not obvious from the docs...
22:13:23 <omnId> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html#v%3AcurrentModule
22:13:26 <lambdabot> http://tinyurl.com/2rec3w
22:15:47 <omnId> here = $(currentModule >>= return . LitE . StringL)
22:15:52 <omnId> try that.
22:23:57 <prb> omnId: That works.
22:24:32 <prb> Does TH need to be imported in every module that uses it?
22:24:55 <omnId> Language.Haskell.TH(currentModule) anyway
22:25:20 <prb> omnId: Cool beans; thanks!
22:25:23 <omnId> LitE and StringL and their types, too
22:25:50 <prb> omnId: Without some IDE to autocomplete too much for me, I don't mind a few extra imports... ;)
22:25:51 <omnId> Language.Haskell.TH(currentModule, Exp(LitE), Lit(StringL))
22:38:53 <sclv> @fact
22:38:54 <lambdabot> I can not handle empty facts.
22:38:57 <sclv> @help fact
22:38:57 <lambdabot> fact <fact>, Retrieve a fact from the database
22:39:01 <sclv> @help free
22:39:02 <lambdabot> free <ident>. Generate theorems for free
22:39:06 <sclv> @fact dude
22:39:06 <lambdabot> I know nothing about dude
22:39:16 <sclv> @fact-snoc
22:39:16 <lambdabot> I can not handle empty facts.
22:39:19 <sclv> @help fact-snoc
22:39:20 <lambdabot> snoc information to fact
22:39:29 <sclv> @help fact-cons
22:39:29 <lambdabot> cons information to fact
22:39:35 <sclv> @fact hoogle
22:39:35 <lambdabot> I know nothing about hoogle
22:39:39 <sclv> @fact faq
22:39:39 <lambdabot> I know nothing about faq
22:39:43 <sclv> Wpretty
22:39:46 <sclv> @pretty
22:39:56 <sclv> @pretty \x -> x+1
22:39:57 <lambdabot> "Parse error" at column 1
22:40:04 <sclv> @help pretty
22:40:04 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
22:40:11 <sclv> @pretty x+1
22:40:12 <lambdabot> "Parse error" at column 4
22:40:17 <sclv> @pretty let x = 5
22:40:17 <lambdabot> "Parse error" at column 10
22:40:30 <sclv> @pretty "let x = 5;"
22:40:31 <lambdabot> "Parse error" at column 13
22:41:05 <sclv> oh, sorry -- thought I was private msging lambdabot.
22:41:15 <omnId> @slap sclv
22:41:15 * lambdabot smashes a lamp on sclv's head
22:42:06 <newsham> LAMP?
22:42:32 <sclv> that would hurt even more.
22:42:45 <scook0_> suddenly, a genie appears!
22:42:52 <scook0_> "You disturbed me, fool!"
22:43:43 <newsham> ?djinn (p->q)->r -> (p->s, q)
22:43:44 <lambdabot> -- f cannot be realized.
22:44:01 <omnId> Uh-oh!  I was privmsging @slap someone to see the new slaps and came upon this blasphemy: "
22:44:01 <omnId>  * lambdabot activates his slap-o-matic..."
22:44:06 <omnId> "his"
22:44:29 <newsham> omniId: you have something against transexual bots?
22:45:08 <omnId> not especially, just... uh... damn, there's no correct way to answer that.
22:45:13 <sclv> @vixen are you transsexual
22:45:13 <lambdabot> yes, i am
22:46:01 <newsham> on the internet nobody knows your she bot is a he
22:47:25 <sorear> @vixen are you parametrically adjectival?
22:47:25 <lambdabot> yes, i am
22:47:42 <omnId> @vixen are you a bot?
22:47:42 <lambdabot> no, how dare you ask if i'm a bot!
22:47:57 <sorear> @tell twanvl 22:43 < omnId> Uh-oh!  I was privmsging @slap someone to see the new slaps and came upon this blasphemy: "* lambdabot activates his slap-o-matic..."
22:47:57 <lambdabot> Consider it noted.
22:48:06 <newsham> you can call her a monad transformer, but dont dare call her a bot
22:48:20 <nornagon> @vixen you dirty monad transformer you!
22:48:20 <lambdabot> you're turning me on :)
22:48:25 <nornagon> uh.
22:48:39 <nornagon> that was .... odd.
22:48:54 <sorear> vixen has worse oddities
22:49:00 <sorear> FAR worse
22:49:17 <nornagon> <.<
22:49:31 <newsham> ?vixen tease
22:49:31 <lambdabot> tell me a joke.. I like men that makes me laugh
22:50:06 <omnId> @vixen I told my friend about lambdas, but he didn't get the point.
22:50:07 <lambdabot> you sir are no gentleman
22:50:59 <sorear> nornagon: go run strings on http://www.cse.unsw.edu.au/~dons/lambdabot/State/vixen
22:51:15 <newsham> ?vixen-on
22:51:16 <lambdabot> Not enough privileges
22:51:18 <newsham> ;-)
22:52:33 <newsham> ?vixen how many phds does it take to perform a beta-reduction?
22:52:33 <lambdabot> lots
23:14:54 <omnId> I want to put something in my .ghci, where is it in Windows?  C:\Documents and Settings\Me\.ghci didn't work.
23:17:14 <dmwit> @vixen What do you think of Hitler?
23:17:14 <lambdabot> i do occassionally, i guess
23:17:43 <omnId> C:\.ghci seems to work
23:17:49 <dmwit> =(
23:21:15 <newsham> ?vixen you're a smart one.
23:21:15 <lambdabot> Thank God for AOL that I could meet people like you!
23:21:41 <sjanssen> heh
23:21:45 <newsham> ?vixen are you blonde?
23:21:45 <lambdabot> yes, i am
23:22:02 <Olathe> @vixen Are you a computer or a human ?
23:22:03 <lambdabot> no, i'm really a girl
23:22:06 <nornagon> ?vixen what color is ur hair?
23:22:06 <lambdabot> my hair is brown
23:22:07 <newsham> ?vixen a/s/l
23:22:07 <lambdabot> 19/f/California
23:22:12 <Olathe> Well, that wins the Turing test.
23:22:25 <omnId> actually it doesn't seem to work :/
23:22:44 <newsham> ?vixen do you want to visit hawaii?
23:22:44 <lambdabot> sure, i want to plenty
23:23:08 <Olathe> @vixen Where would you like to go today ?
23:23:08 <lambdabot> the question isn't would i, but should i
23:23:20 <davidL> ?vixen are you a student
23:23:20 <lambdabot> yup, 2nd year at UCLA
23:23:27 <newsham> ?vixen what are you studying?
23:23:27 <lambdabot> i'm a psychology major
23:23:42 <newsham> ?vixen do you like girls?
23:23:43 <lambdabot> sure, i definitely don't hate
23:23:45 <nornagon> ?vixen ur gay
23:23:45 <lambdabot> and now that I have finished with you, you may go!
23:24:03 <Mr_Awesome> ?vixen i ate a monkey!
23:24:04 <lambdabot> i'm a huge baseball fan
23:24:19 <Olathe> @vixen Write some Haskell.
23:24:19 <lambdabot> church is my favourite computer scientist.
23:24:21 <dmwit> ?vixen bgalelrgh eahg
23:24:22 <lambdabot> Hmmm
23:24:51 <Olathe> @vixen version
23:24:51 <lambdabot> there are a lot of weirdos on here
23:24:57 <Olathe> Heh
23:25:15 <sjanssen> @vixen are you purely functional?
23:25:16 <lambdabot> i am just a fun girl!
23:25:24 <newsham> ?vixen Dont you think Turing was cuter?
23:25:24 <lambdabot> am i? i'm glad you think so at least
23:25:30 <Olathe> @vixen Do you see dead people ?
23:25:30 <lambdabot> i'll hafta plead the fifth on that one.
23:26:20 <newsham> ?vixen have you ever killed a man?
23:26:20 <lambdabot> no, i'm a woman
23:26:32 <Olathe> @vixen Why are you a woman ?
23:26:33 <lambdabot> do i seem  un-feminine to you?
23:26:38 <sclv> omnId -- have you tried \Local Settings\ directory?
23:26:53 <Olathe> @vixen Do I seem unfeminine to you ?
23:26:53 <lambdabot> is that really what you want to know?
23:27:09 <sclv> omnId: also, maybe, the executable's directory?
23:27:32 <sclv> @vixen what do you study?
23:27:33 <lambdabot> i'm a psychology major
23:27:39 <sclv> @vixen do you like psychology?
23:27:40 <lambdabot> sure, i definitely don't hate
23:28:12 <Olathe> @vixen What is your quest ?
23:28:13 <lambdabot> is that really what you want to know?
23:28:23 <Olathe> @vixen Is that really what you want to know ?
23:28:24 <lambdabot> i dunno, what do you got?
23:28:51 <davidL> @vixen sup
23:28:51 <lambdabot> I'm stroking my hard cock as we speak...
23:29:15 <dmwit> She must have a boyfriend.
23:29:45 <Olathe> Or a rooster.
23:30:07 <dmwit> @vixen do you have a rooster
23:30:07 <lambdabot> i do occassionally, i guess
23:30:11 <dmwit> @vixen do you hate
23:30:11 <lambdabot> no, i never hate
23:31:45 <Olathe> @vixen You say yes.
23:31:45 <lambdabot> yup
23:31:50 <Olathe> @vixen I say no.
23:31:51 <lambdabot> no?
23:31:59 <Olathe> @vixen You say goodbye.
23:32:00 <lambdabot> wait, don't leave! i enjoy talking to you
23:32:04 <Olathe> @vixen I say hello.
23:32:05 <lambdabot> hiya
23:33:07 <omnId> sclv: neither worked.
23:34:13 <Olathe> @vixen grglplasty goodbye antlerville
23:34:13 <lambdabot> wait, don't leave! i enjoy talking to you
23:34:31 <sclv> @. vixen brain
23:34:31 <lambdabot> isn't it obvious?
23:34:36 <sclv> @. vixen brain
23:34:36 <lambdabot> hey, we have simular taste in music
23:34:40 <omnId> @vixen masturbate
23:34:40 <lambdabot> nothing wrong some occasional self abuse :)
23:34:56 <sclv> :[]
23:35:02 <Olathe> I wish @. would show the intermediate output.
23:35:33 <dmwit> @vixen sticky
23:35:33 <lambdabot> *giggles*
23:35:54 <dmwit> @vixen slow night
23:35:54 <lambdabot> are you being sincere?
23:36:34 <Olathe> @vixen Is that a rooster in your pocket or are you just happy to see me ?
23:36:34 <lambdabot> i truely am
23:37:19 <omnId> @vixen It's spelled truly.
23:37:20 <lambdabot> Thank God for AOL that I could meet people like you!
23:37:28 <Olathe> Heh
23:37:51 <Olathe> @vixen repeat
23:37:51 <lambdabot> my memory isn't so good so sometimes I forget that I asked something
23:37:52 <Olathe> @vixen repeat
23:37:53 <lambdabot> I'm sorry, I forgot we already talked about that...
23:37:56 <Olathe> @vixen repeat
23:37:56 <lambdabot> sorry, I don't mean to repeat myself... I just have a poor memory...
23:38:05 <Olathe> Ahh.
23:38:12 <Olathe> @vixen Is that a rooster in your pocket or are you just happy to see me ?
23:38:12 <lambdabot> i truely am
23:38:14 <Olathe> @vixen Is that a rooster in your pocket or are you just happy to see me ?
23:38:14 <lambdabot> yes, i am
23:40:11 <codeshepherd> Given that functions are building blocks of Haskell .. as opposed to objects..  Is it difficult for people from OOP background to learn Haskell ?
23:40:20 <Olathe> It can be.
23:40:57 <dmwit> This one confuses me:
23:41:01 <dmwit> ?vixen language
23:41:01 <lambdabot> i just turned 19
23:41:13 <dmwit> codeshepherd: (That was unrelated to your question, by the way.)
23:41:44 <Olathe> @vixen xxxaxxxgxxxexxxx
23:41:44 <lambdabot> you sound like an awesome guy... are you single?
23:41:52 <Olathe> @vixen xxxxxxxxage
23:41:52 <lambdabot> i just turned 19
23:42:18 <dmwit> hehehe
23:42:18 <omnId> why don't you guys just look at the source?  >.>
23:42:19 <dmwit> oh
23:42:24 <aleator> Hmm. I'm worried. My code gives totally different results with -O2 than withour..
23:42:38 <olsner> floating-point?
23:42:53 <aleator> yeah, one option..
23:55:47 <newsham> omnId: who says we didnt?
23:56:17 <omnId> nobody! :)
