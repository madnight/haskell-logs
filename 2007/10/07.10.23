00:01:26 <takamura> hi
00:02:09 <omnId> ASSERTION, MODELS, TRUE, FORCES, TRIPLE VERICAL BAR WITH RIGHT TURNSTILE
00:02:13 <omnId> WAIT, WHAT?
00:02:34 <dmwit> turnstile?
00:02:39 <dmwit> Hi, takamura!
00:02:53 <newsham> i've heard turnstile before
00:03:05 <newsham> they gotta call stuff something
00:26:58 <krishnbh2kt> any tutorial on haskell which demonstrates how typical algorithms can be implemented?
00:27:55 <jql> typical in haskell, or typical in language-X?
00:35:50 <dmwit> krishnbh1kt: Which algorithms are you interested in?
00:37:45 <krishnbhakt> like the ones knuth's book
00:38:07 <krishnbhakt> typical sort/dynamic/b&b
00:38:13 <dmwit> Hmmm.
00:38:24 <dmwit> Well, have you seen Chris Okasaki's thesis/book?
00:38:28 <krishnbhakt> no
00:38:32 <dmwit> It talks about data structures in the purely functional regime.
00:38:41 <krishnbhakt> i have heard about it
00:38:52 <krishnbhakt> but that is data structure
00:39:01 <dmwit> I'm sure almost every tutorial has at least one sort in it.
00:39:28 <dmwit> (The canonical example is a rather poorly-performing quicksort.)
00:39:33 <krishnbhakt> just a tutorial dedicated to it
00:40:21 <dmwit> I can't really think of any.
00:40:25 <krishnbhakt> ok
00:41:13 <sjanssen> krishnbhakt: I don't think there is a single document.  There are lots of mailing list posts, blogs, etc. that you can find
00:43:09 <sjanssen> krishnbhakt: here's a neat message by Okasaki showing a dynamic programming technique http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo
00:43:13 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/u45vz
00:50:26 <krishnbh1kt> Chris Okasaki's thesis, has it been updated post h98
00:50:44 <dmwit> The book is much newer than the thesis, I gather.
00:51:04 <dmwit> Where newer implies better and more comprehensive.
00:53:10 <Caelum> which book?
00:53:27 <krishnbh1kt> is it for free?
00:54:36 <dmwit> The book has the same name as the thesis, "Purely Functional Data Structures".
00:54:39 <dmwit> It is not free.
00:54:51 <krishnbh1kt> ok
00:57:28 <krishnbh1kt> where is wli?
00:57:44 <wli> What?
00:58:15 <krishnbh1kt> hi wli, any idea on tutorial related to algorithms using haskell
00:58:43 <wli> Sure. It might be a good idea to write one.
00:59:03 <krishnbh1kt> i am not at all good in haskell
00:59:32 <wli> Learn by teaching. Document what you learn as you learn it.
00:59:36 <krishnbh1kt> are one of the haskell gurus planning?
01:00:15 <krishnbh1kt> hmm, sounds good
01:00:19 <wli> I have no idea, but I'm entirely serious about what I'm saying.
01:00:40 <krishnbh1kt> i will give it a try with some statistical algos
01:00:56 <krishnbh1kt> may be t.test to begin with
01:01:22 <omnId> okay, this is TREMENDOUSLY off-topic, but eh, what the hell: http://www.youtube.com/watch?v=2I9xMVbtTdY
01:01:23 <wli> Numerics are sorely neglected in the algorithmic arena for Haskell.
01:01:23 <lambdabot> Title: YouTube - hamster stuck in a videogame
01:02:19 <krishnbh1kt> there should be something like R in haskell
01:02:33 <krishnbh1kt> R seems like crying to be written in haskell
01:03:28 <wli> Sounds good. You should do something like that, then.
01:03:40 <kilimanjaro> just write an interface to the existing R infrastructure
01:03:49 <kilimanjaro> what's the point in duplicating the work of such a tremendous project
01:04:03 <krishnbh1kt> for fun
01:04:07 <krishnbh1kt> learn
01:04:13 <Mr_Awesome> omnId: totally worth it :)
01:04:26 <kilimanjaro> krishnbh1kt, ok, that's a good enough reason
01:04:27 <wli> Loop fusion, deforestation, etc.
01:04:50 <wli> Plus NDP-based parallelization.
01:05:26 <takamura> i'm very interested in a statistical library for haskell. Now i'm beginning a statistical research project and will do it in R, but if I can do it in haskell it will be nicer :)
01:05:55 <dmwit> omnId: Bizarre.
01:06:03 <kilimanjaro> why don't you start with some low level FFI bindings for whatever procedures you need, then experiment implementing your project in Haskell, and take it from there?
01:06:16 <kilimanjaro> see how effective you can be, what works, what doesn't work, etc
01:06:48 <krishnbh1kt> sounds good
01:07:03 <omnId> dmwit: and awesometastic!
01:07:12 <kilimanjaro> I think more important than being implemented in Haskell is the actual API presented to the Haskell programmer
01:07:24 <wli> Not sure how well NDP copes with FFI calls floating around inside its loops.
01:10:00 <krishnbh1kt> any pointers on what to read before taking the plunge?
01:10:23 <wli> Golub & van Loan?
01:10:27 <opqdonut> well you probably don't want to read NULL
01:10:36 <dmwit> The Gentle Introduction to Haskell
01:10:43 <dmwit> ?where gentle
01:10:43 <lambdabot> I know nothing about gentle.
01:10:51 <dmwit> ?go gentle introduction to haskell
01:10:53 <lambdabot> http://www.haskell.org/tutorial/
01:10:53 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
01:11:31 <wli> When you look at the world, do you see the matrix? Or its eigenvalues?
01:11:49 <opqdonut> do you see the LU-factorisation?
01:11:58 <dmwit> ?where+ gentle http://www.haskell.org/tutorial/
01:11:58 <lambdabot> Okay.
01:12:04 <dmwit> ?botsnack
01:12:04 <lambdabot> :)
01:12:25 <krishnbh1kt> got it
01:13:39 <krishnbh1kt> the book looks tough!
01:14:17 <krishnbh1kt> any of you having a pdf of Golub & van Loan or a simpler alternative?
01:16:04 <wli> Golub & van Loan is about numerical linear algebra.
01:17:11 <krishnbh1kt> yes i have it in print
01:17:16 <krishnbh1kt> never had the courage to read
01:18:03 <krishnbh1kt> the very first chapter starts with saxpy's algo!
01:18:24 <wli> There's nothing to be afraid of. It's only a book
01:19:17 <krishnbh1kt> yes you are right :)
01:19:24 <krishnbh1kt> but not at all gentle
01:20:07 * wli ponders a "Rough Guide to Haskell."
01:31:43 <krishnbh1kt> thanks wli, i will start with t.test in haskell :)
01:31:54 <wli> Very cool.
01:32:14 <wli> Use continued fractions. The power series suck.
01:41:06 <quicksilver> wli: its eigenvalues, definitely
01:41:40 <roconnor> power series are great!
01:41:53 <roconnor> well, they are at least adequate
01:42:04 <roconnor> what are we talking about?
01:42:17 <wli> Continued fractions rule, though.
01:42:36 <wli> Incomplete gamma function evaluation for the t-test.
01:42:42 <roconnor> continued fractions have bizare convergence properties.
01:42:51 <roconnor> wli: wow
01:42:57 <wli> Only if you're not used to them.
01:43:09 <wli> roconnor: Wow what?
01:43:40 <roconnor> I more or less don't undertand ``Incomplete gamma function evaluation for the t-test.'' other than ``something to do with statistics''
01:44:08 <wli> roconnor: The CDF of the t statistic ends up being an incomplete gamma function.
01:44:17 <roconnor> I will grant you that the convergence properties of continued fractions, however bizzare, are often better than that of power series.
01:44:22 <sclv> So if I want to create and write simple graphics files, what library should I be looking at?
01:44:56 <wli> roconnor: Except, of course, very close to 0, where power series are absolutely fabulous.
01:45:01 <roconnor> Tim was working on bindings for image magik at the hackathon I think.
01:45:09 <oerjan> better than a disk in the complex plane?
01:45:30 <TSC> sclv: How simple do you want to go?  If very simple, try http://www.haskell.org/haskellwiki/Library_for_PPM_images
01:45:31 <lambdabot> Title: Library for PPM images - HaskellWiki
01:45:38 <roconnor> wli: yep; that why we use range rediction to try to get our points as close to 0 as possible ;)
01:45:46 <wli> oerjan: Typically it's swift convergence over a very large and irregular region of the plane.
01:46:04 <roconnor> wli: thankfully analytic functions are completely characterised by their behaviour near 0.
01:46:19 <wli> oerjan: Or, if not swift, then convergence that's about the same over the whole plane.
01:46:32 <quicksilver> completely characterised by their behaviour at 0, aren't they?
01:46:33 <wli> roconnor: Well, range reduction has its own issues.
01:46:48 <oerjan> hm
01:47:00 <roconnor> quicksilver: several different analytic functions functions are 0 at 0.
01:47:08 <roconnor> wli: true :)
01:47:10 <quicksilver> roconnor: behaviour is more than just value, though
01:47:19 <quicksilver> roconnor: by 'behaviour at 0' I meant all derivatives
01:47:34 <roconnor> ah
01:47:46 <roconnor> pfft derivatives
01:47:47 * wli points to his vanity domain.
01:47:55 <sclv> TSC: just looking to do basic scripting for producing charts and data visualizations. thanks.
01:48:11 <roconnor> the derivative at 0 would be meaningless without all the points around 0.
01:48:14 <sclv> haskellcharts looks good too.
01:48:33 <roconnor> sclv: I liked haskell charts so much, I sumbitted a patch!
01:48:59 <TSC> For more complex formats, you can bind to Imagemagick (or just use the PPM library + convert to and from PPM)
01:50:51 * wli repeatedly points to his vanity domain.
01:51:36 <wli> (/whois wli)
01:54:32 <oerjan> this cannot be right, holomorphy belongs to all mankind
01:55:43 <wli> That's what they say about everything right before it's get privatized. BTW prepare to have to pay for every bit of the air you breathe and suffocate if you can't pay up. ;)
01:56:46 <oerjan> prepare to be no. 10573 against the wall when the revolution comes ;)
01:57:19 <wli> The revolution came and went and the bad guys won.
01:59:29 <oerjan> pardon me, the *next* revolution
02:00:38 <oerjan> which will of course also be won by the bad guys, just different bad guys
02:08:03 <dcoutts> @seen ndm
02:08:04 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 9h 35m 25s ago, and .
02:16:36 <arcatan> hugs says module blah not previously loaded, what that means?
02:17:36 <Mr_Awesome> youre probably trying to use something from a module thats not in scope
02:21:16 <arcatan> oh, my parsec installation just wasn't correct
02:30:45 <joelr1> good morning
02:31:08 <cognominal_> how do you read in english haskell' ?
02:31:17 <dcoutts> haskell-prime
02:31:21 <cognominal_> thx
02:31:22 <wli> Haskell Prime
02:31:40 <dcoutts> read x' as x prime
02:31:49 <mux> does someone have a link to some efficient function for listing factors of a number?
02:31:50 <cognominal_> and say you have haskell''  like a second derivative, ho do you say it?
02:31:53 <mux> factors n = [ d | d <- [1..n], n `mod` d == 0 ]
02:31:57 <mux> falls short :)
02:31:59 <dcoutts> cognominal_: it's a convention from mathematics
02:32:23 <dcoutts> cognominal_: it usually means the "next value of" in some sense
02:32:29 <cognominal_> I knew that but I did not know how it was pronounced
02:32:32 <dcoutts> cognominal_: like let x' = x + 1 in ...
02:32:37 <dcoutts> cognominal_: ok ok:-)
02:32:47 <cognominal_> :)
02:33:32 <dcoutts> mux: sssh, that's the first FP practical we set at Oxford, so no solutions please ;-)
02:33:55 <dcoutts> mux: actually, that's prime factors
02:34:03 <mux> I want all factors :-)
02:34:19 <oerjan> mux: if you find the prime factors first, the rest is easy
02:34:23 <mux> yep
02:34:36 <mux> I found some code for finding factors with the elliptic curve method
02:34:40 <mux> but it's not working so well
02:34:56 <mux> strangely, the functions are very partial
02:37:05 <oerjan> on a hunch, perhaps they require you do remove some small factors like 2,3,5 first
02:37:15 <mux> yes, it looked like it
02:37:34 <oerjan> *to
02:40:57 <Jiten> mux, you only need to test numbers less than square root of n
02:42:40 <Jiten> haskell compilers aren't smart enough to figure that out, are they?
02:42:49 <mux> they sure aren't :)
02:44:17 <mux> heh, ghc has a lot of prolems compiling some small haskell code containing a 150-digit numbers
02:44:33 <masak> @ask dons if there's any chance you could re-invite lambdabot to #bioclipse. also, if there's a way to automate this, so we don't have to bother you every time it drops off the channel
02:44:33 <lambdabot> Consider it noted.
02:45:27 <sjanssen> lambdabot: @join #bioclipse
02:45:46 <masak> sjanssen: oh!
02:45:48 <masak> thx
02:46:04 <sjanssen> no problem
02:46:13 <masak> @tell dons never mind, sjansen showed me how :)
02:46:13 <lambdabot> Consider it noted.
02:46:17 <sjanssen> you'll need dons' help to have lambdabot automatically join
02:46:29 <sjanssen> masak: you probably don't have the permissions necessary
02:48:23 <masak> sjanssen: the @join thing is quite sufficient, since lambdabot hangs around here most of the time
02:49:15 <phlpp> hi
02:49:34 <oerjan> @join #doubtfully
02:49:34 <lambdabot> Not enough privileges
02:51:37 <mux> Jiten: no, I need to test until after sqrt n, if I want to get all the factors
02:52:40 <mux> actually, even if I want prime factors
02:52:49 <Jiten> why?
02:53:00 <mux> > sqrt 28
02:53:02 <lambdabot>  5.291502622129181
02:53:19 <mux> yet, 7 is a prime factor of 28
02:53:42 <Jiten> however, 28/4 makes 7
02:54:02 <Jiten> you're already diving by 4 at one point
02:54:22 <Jiten> you could also get 14 at the same time as dividing by 2
02:55:27 <Jiten> actually, you don't need to do sqrt. just keep both the result and the divider and stop once result is smaller than divider
02:58:45 <njbartlett> http://www.trollied.org/onefortrav.jpg
02:59:07 <njbartlett> (work safe... slightly off topic but most people here should appreciate)
02:59:09 <Jiten> unless my thinking is all wrong, that should get you all the factors.
03:14:10 <roderyk> I've seen one-liners (eg. a lambda function for a filter), where one uses 'flip'. I'm assuming it's to use less parens. eg. "flip drop s $ (length s) - 3". is this a fairly common idiom?
03:14:36 <KatieHuber> @unpl flip drop s $ (length s) - 3
03:14:37 <lambdabot> (drop ((length s) - 3) s)
03:15:27 <KatieHuber> @pl (drop ((length s) - 3) s)
03:15:27 <lambdabot> drop (length s - 3) s
03:15:39 <sjanssen> roderyk: generally flip is used to pointfree code
03:16:04 <nornagon> @pl \s -> drop (length s - 3) s
03:16:04 <lambdabot> drop =<< subtract 3 . length
03:16:08 <sjanssen> eg. (\x -> foo x 1) becomes (flip foo 1)
03:16:59 <roderyk> i see, thanks
03:19:23 <Jiten> mux: you became quite silent.
03:19:53 <phlpp> @type (=<<)
03:19:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
03:25:00 <frederik> hi. Is there anybody in here who could help me with a haskelldb problem?
03:31:10 <vincenz> augustss: ping
03:45:52 <frederik> my problem regarding haskelldb basicly amounts to the question, where I can find DBDirect mentioned in the docs or what is supposed to replace it in the latest releases?!
03:48:04 <phlpp> Cale: hehe, i recently found out that playing clapton is better than just listening to him. although my guitar doesn't sound as good as his ;)
03:49:15 <Jiten> frederik: http://haskelldb.sourceforge.net/getting-started.html
03:49:16 <lambdabot> Title: HaskellDB - Getting Started
03:49:45 <Jiten> that page answers your question I think. found it pretty easily with google.
03:51:51 <frederik> Jiten: thanks, but I think, this doesn't help, I know this page
03:52:10 <frederik> Jiten: at least the mentioned dbspec.hs doesn't exist in the package from hackage
03:52:17 <Jiten> Note: Currently, DBDirect is not installed when make install is run, but it is compiled and should be available in the build/ghc subdirectory after running make. So when DBDirect is used below, just replace that by <path to HaskellDB dir>/build/ghc/DBDirect.
03:52:38 <frederik> Jiten: this COULD help *g
03:52:46 <Jiten> it was on the page
03:53:27 <Jiten> also, I saw a hit to debian's pages with a note that DBDirect isn't included in the package
03:53:41 <Jiten> for haskelldb
03:54:02 <frederik> I'm using the official package linked from the haskelldb page
03:54:12 <frederik> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskelldb-0.10
03:54:14 <lambdabot> http://tinyurl.com/ywflok
03:57:07 <frederik> no, the information on that page doesn't seem to be up to date
03:57:57 <frederik> Jiten: do you use haskelldb or did just do a quick google search?
04:00:53 <frederik> dbspec, DBDirect should generate a database description for use with haskelldb. I wrote a few lines of code that do this for me using the functions from Database.HaskellDB.DBSpec.DatabaseToDBSpec
04:01:42 <frederik> and I can insert data into the database using the generate datatypes and I can do query but I can't figure out how to do select fields from the query results
04:02:59 <frederik> I always get type errors about missing Select instances (which indeed aren't generated explicitly in the database description modules)
04:28:51 <dcoutts> malcolmw: oh first new released version of HaXml for a long time I notice :-)
04:28:57 <dcoutts> first on hackage since 0.13.2
04:30:09 <malcolmw> oh, there have been plenty of development versions, I just didn't put them on hackage
04:30:53 <dcoutts> malcolmw: ok, well glad there's one on hackage now :-)
04:31:16 <malcolmw> the prompting of the masses, and all that.  well, at least a couple of people on haskell-cafe
04:31:23 <dcoutts> malcolmw: btw, there's a new cpp-options so you don't have to use hacks like cc-options: -DFoo; ghc-options: -DFoo
04:31:32 <dcoutts> malcolmw: but it's new in Cabal-1.2.1
04:31:58 <malcolmw> yeah, so maybe once that has been released, I'll update...
04:32:04 <dcoutts> it has been released
04:32:07 <dcoutts> it's on hackage
04:32:10 <malcolmw> ah
04:32:28 <malcolmw> well, maybe once it is widespread due to the release of 6.8.1...
04:32:35 <dcoutts> and it's in the recent ghc-6.8.0 snapshots
04:32:38 <malcolmw> or something
04:32:52 <malcolmw> I don't want to increase the barriers to adoption too much
04:33:10 <dcoutts> malcolmw: I'm on a one man campaign to get everyone to upgrade to Cabal-1.2.x, whatever version of ghc they're using :-)
04:33:17 <dcoutts> malcolmw: sure
04:33:19 <nominolo> @src mconcat
04:33:19 <lambdabot> Source not found. stty: unknown mode: doofus
04:33:36 <oerjan> @src Monoid
04:33:36 <lambdabot> class Monoid a where
04:33:36 <lambdabot>     mempty  :: a
04:33:36 <lambdabot>     mappend :: a -> a -> a
04:33:36 <lambdabot>     mconcat :: [a] -> a
04:35:02 <dcoutts> malcolmw: an alternatively, if you don't really need the version number as a CPP symbol, cabal generates a module that provides the package version number
04:36:23 <nominolo> @src [] mconcat
04:36:23 <lambdabot> Source not found. My pet ferret can type better than you!
04:37:16 * quicksilver 's Cabal version is 0.0
04:37:38 <nominolo> how's that?
04:38:08 <oerjan> 	mconcat = foldr mappend mempty
04:38:23 <oerjan> is the default
04:40:21 <nominolo> @pl \exp (es, o) -> let (e', o') = f exp in (e' : es, o' `mappend` o)
04:40:22 <lambdabot> (line 1, column 21):
04:40:22 <lambdabot> unexpected "("
04:40:22 <lambdabot> expecting natural, identifier or "in"
04:41:23 <nominolo> @pl \exp (es, o) -> let  r = f exp in (fst r : es, snd r `mappend` o)
04:41:24 <lambdabot> (`ap` snd) . (. fst) . flip (flip . (. flip (mappend . snd)) . ap . ((,) .) . flip ((:) . fst)) . fix . const . f
04:42:56 <mux> yay, the maths library at http://www.polyomino.f2s.com/david/haskell/main.html is rather impressive
04:42:57 <lambdabot> Title: Haskell for Maths
04:43:19 <mux> my code for problem 12 was taking ages, and it's immediate if I use their lib and the "numDivisors" function =)
04:43:29 <mux> trinums = scanl (+) 1 [2..]
04:43:31 <mux> main = print . head . dropWhile ((<= 500) . numDivisors) $ trinums
04:43:34 <mux> and it's sexy
04:45:16 <nominolo> too bad it's not on hackage
04:47:00 <quicksilver> mux: tis sexy, although arguably the point of the problem is to come up with the good algorithm yourself :)
04:47:13 <quicksilver> mux: so using someone else's efficient algorithm is, in some sense, 'cheating'
04:47:28 <roconnor> or is it good research?
04:47:55 <roconnor> @src mconcat
04:47:56 <lambdabot> Source not found. My brain just exploded
04:48:14 <roconnor> oh for monoids
04:48:23 * roconnor was thinking MonadPlus
04:48:26 <roconnor> :(
04:48:40 <roconnor> too many ms
04:56:45 <mux> quicksilver: yeah, I admit; but I don't find it fun to come up with complicated mathematical algorithms myself :)
04:57:24 <mux> besides, being able to reuse good code is a quality for a programmer :-)
04:58:41 <mux> those problems that don't require heavy algorithms I did them myself entirely
04:59:30 <roconnor> @go Newton-Cotes
04:59:32 <lambdabot> http://en.wikipedia.org/wiki/Newton-Cotes_formulas
04:59:32 <lambdabot> Title: Newton-Cotes formulas - Wikipedia, the free encyclopedia
05:00:29 * wli notes the anagram/derangement problem has something of a closed form expressible as an integral of a product of Laguerre polynomials.
05:01:14 <roconnor> ``Boole's rule is called Bode's rule in Abramowitz and Stegun due to propagation of an early typo''
05:01:26 <roconnor> poor Boole
05:01:39 <mux> quicksilver: also, many problems in project euler are very easily solvable using Integer, that is in fact, using libgmp behind the scenes, while it would be much more difficult to solve them in, say, bare C
05:02:25 <hpaste>  (anonymous) pasted "Typeclass paremeterised lists" at http://hpaste.org/3435
05:03:15 <EvilTerran> anonymous, you can write {-# OPTIONS_GHC -XFoo -XBar ... #-} more portably as {-# LANGUAGE Foo, Bar, ... #-}
05:03:30 <dblhelix> roconnor: is that because someone erroneously read "ol" in a handwritten text as "d"?
05:03:34 <vincenz> roconnor: that's what I call 'error-propagation'
05:03:43 <wli> Oh, yeah, the bigger number == harder to program assumption implicit in many of those things.
05:03:59 <eToRA|hom> EvilTerran: can't write GADTs tho in LANGUAGE can you?
05:04:29 <EvilTerran> as far as i know, "LANGUAGE Foo" and "OPTIONS_GHC -XFoo" are exactly equivalent
05:04:30 <mux> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html#t%3AExtension
05:05:00 <lambdabot> http://tinyurl.com/2b93uq
05:05:47 <wli> It's still true to some degree; the bigger numbers often run slow enough to preclude brute force.
05:06:33 <eToRA|hom> EvilTerran: I stand corrected.  give or take commas interspersing options
05:06:55 <mux> wli: I observed something funny btw, trying to compile a haskell program containing a huge 150-digits number took *long*
05:07:07 <mux> GHC ran for several minutes before giving me an executable
05:07:24 <wli> Did it run fast?
05:07:38 <mux> yes, only the build was very slow
05:08:11 <EvilTerran> maybe it ran the algorithm in full at compiletime(?)
05:10:14 <wli> I guess it still ran within project euler's suggested time limit.
05:10:39 <frederik> at the risk of getting annoying ...: is there anybody who could help me with my haskelldb problem?
05:11:23 <TSC> I've had source files with long literal lists take a long time to compile too
05:13:06 --- mode: irc.freenode.net set +o ChanServ
05:22:13 <ddvlad> quit
05:22:16 <ddvlad> exit
05:22:46 <LeCamarade> Heh. He may have even tried ^D
05:23:08 <LeCamarade> Or ^Z
05:24:31 <EvilTerran> i was thinking he thought we were a terminal
05:30:45 <iank> hehe
05:45:10 <fasta> Does it matter whether I strip a binary for the time it takes to execute?
05:45:39 <fasta> By matter I mean >1%.
05:46:14 <EvilTerran> only if it makes a difference between it fitting in memory and not, i imagine
05:47:16 <roconnor> wikipedia thinks arctanh should be called artanh
05:47:18 <titusg> how do I specify ghci options in an lhs script? %options ghci -fblah doesn't seem to work...
05:47:29 <roconnor> should the Prelude be changed?
05:47:47 <EvilTerran> roconnor, i've never seen that
05:47:49 <ivanm> roconnor: and of course we _all_ trust wikipedia, don't we? :p
05:48:04 <ivanm> btw, is it possible to pattern match with a record-style type?
05:48:41 <roconnor> > arctanh 1
05:48:42 <EvilTerran> http://mathworld.wolfram.com/InverseHyperbolicTangent.html says either is okay
05:48:43 <lambdabot> Title: Inverse Hyperbolic Tangent -- from Wolfram MathWorld
05:48:44 <lambdabot>   Not in scope: `arctanh'
05:49:04 <roconnor> ?
05:49:09 <roconnor> am I totally mistaken?
05:49:20 <ivanm> @hoogle tanh
05:49:20 <lambdabot> Prelude.tanh :: Floating a => a -> a
05:49:21 <lambdabot> Prelude.atanh :: Floating a => a -> a
05:49:25 <ivanm> ^^
05:49:25 <EvilTerran> not explicitly, actually, but it mentions "artanh" as a possibility
05:49:32 <ivanm> atanh is also good, AFAIK
05:49:49 <EvilTerran> roconnor, wikipedia may well be referring to some weird notation that only one person uses
05:49:50 <roconnor> Haskell uses atanh
05:50:05 <roconnor> what a nice compromise :)
05:50:13 <EvilTerran> i'd trust mathworld over it any day, and that seems to prefer arctanh to artanh
05:50:36 <ivanm> roconnor: it's not a compromise...
05:50:39 <roconnor> mathworld is definitely one person's opinion :P
05:50:48 <ivanm> I've seen a lot of people/textbooks using acos, atanh, etc.
05:50:56 <ivanm> a lot of calculators and computer programs as well
05:51:11 <ivanm> after all, mathematicians are lazy, and the shorter the better! :p
05:51:24 <EvilTerran> roconnor, most mathworld pages have a bewildering selection of references at the bottom, though
05:51:42 <roconnor> EvilTerran: indeed, the references look quite good.
05:52:05 <roconnor> one one solution ... Google
05:52:06 <EvilTerran> while wikipedia tends to suffer from chronic [citation needed] :P
05:52:12 <roconnor> 73,500 votes for arctanh
05:52:23 <roconnor> 20,100 votes for artanh
05:52:32 <roconnor> 199,000 votes for atanh
05:52:46 <ivanm> as I said.... it's shorter!
05:52:50 <EvilTerran> all the C code will use atanh
05:52:53 <Japsu> !vote hyperbolicAreaTangent
05:53:04 <roconnor> ``while wikipedia tends to suffer from chronic [citation needed] :P'' [citation needed]
05:53:05 <hkBst> Yeah, Mathworld is perfect: "is the hyperbolic tangent and the superscript -1 denotes an inverse function, not the multiplicative inverse." </sarcasm>
05:53:35 <EvilTerran> and anything with a math library inspired by <math.h>
05:53:39 <EvilTerran> hkBst, what?
05:53:44 <ivanm> hkBst: where's the opening <sarcasm> tag?
05:54:00 <quicksilver> I think ^{-1} is the standard notation when you have typesetting available, isn't it?
05:54:14 <quicksilver> and generally I've seen 'arc' when you don't
05:54:16 <ivanm> quicksilver: though the "a" or "arc" prefix is also used for trig functions
05:54:29 <quicksilver> and 'a' in cmoputer libraries
05:54:29 <ivanm> even when you don't have typesetting
05:54:39 <ivanm> mainly because people are used to them
05:54:47 <ivanm> but "a" is also in maths, not just "arc"
05:54:52 <quicksilver> well the -1 is pretty illogical :)
05:54:58 <ivanm> why?
05:55:01 <ivanm> inverse
05:55:02 <quicksilver> but still the most common convention when I was taught
05:55:09 <ivanm> it is in general
05:55:11 <quicksilver> it's inconsistent with sin^{2}
05:55:14 <roconnor> ... I used wikipedia to choose the name hemi-metric rather than semi-metric for a non-symetric metric
05:55:15 <quicksilver> which
05:55:15 <ivanm> true
05:55:43 <ivanm> quicksilver: but then, sin^2 is sin(sin(x))
05:55:49 <ivanm> so it's function squaring
05:55:51 <quicksilver> no, it's not
05:55:55 <ivanm> and sin^-1 is function inverse
05:56:01 <ivanm> quicksilver: ummm... whoops, my mistake
05:56:02 <quicksilver> sin^2 (x) is (sin x)^2
05:56:04 <ivanm> you're right :s
05:56:10 <quicksilver> although it's odd :)
05:56:13 <ivanm> yes
05:56:18 <ivanm> mental blank there :s
05:56:21 * ivanm hates trig
05:56:27 <hkBst> and sin^-2 ? :D
05:56:39 <ivanm> @slap hkBst
05:56:40 * lambdabot slaps hkBst
05:56:48 <ivanm> don't be rediculous!
05:56:54 * ddarius would prefer sin^2 to be sin . sin
05:56:55 <roconnor> inverse of sin^2 ?
05:57:00 <ivanm> ridiculous*
05:57:28 <quicksilver> hkBst: sin^-2 x is (arcsin x)^2
05:57:29 <ivanm> ddarius: reason it isn't, is for when writing functions....
05:57:39 <ivanm> quicksilver: is it though?
05:57:42 <quicksilver> yup
05:57:53 <quicksilver> these conventions are mainly used in differentiation formulae
05:57:59 <quicksilver> (and integration)
05:58:03 <quicksilver> when such things pop up quite often
05:58:16 <ivanm> don't recall ever seeing something like sin^-2 :s
05:58:27 <ddarius> Of course the solution is clear.
05:58:51 <ivanm> ddarius: what? obviously its not that clear if I can't see it...
05:59:00 <ddarius> complex exponentials
05:59:47 <hkBst> ddarius: that doesn't work for non-trig functions.
05:59:47 <ivanm> hmmmm??? as in sin(x) = complex(exp(ix)) ?
06:00:09 <ivanm> s/complex/imaginary
06:00:50 <quicksilver> arguably, sin's domain and codomain are different
06:00:58 <quicksilver> so sin ( sin x ) is ill-typed
06:01:09 <opqdonut> mhmm
06:01:12 <ivanm> quicksilver: depends if you want reals or not
06:01:15 <ddarius> I usually write it out (e^(ix) - e^(-ix))/(2i) if I really want sin which I rarely do.
06:01:23 <ivanm> since sin(2) could be used in some circumstances
06:01:32 <ddarius> Er +
06:01:43 <ivanm> no, it's minus
06:01:52 <ivanm> cos has +
06:01:54 <ivanm> sin has -
06:02:03 <ddarius> Ah good, so I was right at the beginning.
06:02:06 <ricky_clarkson> quicksilver: Did you never sit there hitting the sin button on a calculator to see what it converged to? ;)
06:02:16 <opqdonut> how about sin^e(x)?
06:02:21 <ddarius> > iterate sin 1
06:02:28 <lambdabot>  [1.0,0.8414709848078965,0.7456241416655579,0.6784304773607402,0.627571832049...
06:02:40 <ivanm> > fix sin 1
06:02:40 <lambdabot>   add an instance declaration for (Floating (t -> a))
06:02:41 <ketil> @seen ndm
06:02:41 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 13h 30m 3s ago, and .
06:02:48 <ivanm> @type fix
06:02:51 <lambdabot> forall a. (a -> a) -> a
06:02:55 <opqdonut> > fix sin
06:02:56 <lambdabot>  Exception: <<loop>>
06:02:58 <opqdonut> won't work
06:02:58 <ivanm> duh
06:03:02 <ivanm> :(
06:03:03 <quicksilver> fix doesn't calculate that kind of fixed point :)
06:03:06 <ivanm> heh
06:03:07 <opqdonut> yep
06:03:37 <quicksilver> fix sin is sin ( sin ( sin ( sin ( ....... sin ( _|_ ) ) ) .... )
06:03:44 <ivanm> *nod*
06:03:45 <ddarius> sin is not continuous...
06:03:55 <ddarius> Well...
06:04:16 <ddarius> It's not monotonic.
06:04:34 <opqdonut> well sin : [1,0] -> [1,0] is :)
06:04:43 <ddarius> Not in the definability order.
06:04:45 <opqdonut> bahmm, make that [-1,1]
06:04:57 <opqdonut> ah, you're talking domain theory or something
06:05:02 <roconnor> > sin (-1)
06:05:04 <lambdabot>  -0.8414709848078965
06:05:09 <quicksilver> it's infinitely continuous on R and C
06:05:18 <quicksilver> but it's not continuous on the CPO
06:05:21 <roconnor> sin [-1 .. 1] = [-0.842 .. 0.842]
06:05:24 <smashor> Hello. Could someone explain to me the const function? Why has it the type const :: a -> b -> a?
06:05:38 <quicksilver> smashor: it ignores its second parameter and returns its first
06:05:42 <smashor> or in other words: what's the purpose of that function ?
06:05:45 <ddarius> @djinn a -> b -> a
06:05:45 <lambdabot> f a _ = a
06:05:50 <smashor> quicksilver: that's all?
06:05:51 <quicksilver> smashor: so its return type is alwys the type of the first parameter
06:05:55 <quicksilver> smashor: yes, that's all :)
06:05:57 <roconnor> (const 7) is a function at always returns 7
06:06:00 <smashor> hmpf
06:06:11 <ddarius> const and id are very handy
06:06:15 <roconnor> so it is like a parameterized constant function.
06:06:19 <smashor> ok, next one: const (id (5)) 6 results in 5
06:06:32 <smashor> const id 5 6 results in 6
06:06:44 <roconnor> (id (5)) is 5
06:06:45 <smashor> why (i assumed both result in 5)
06:06:56 <smashor> roconnor: that's clear :D
06:07:17 <roconnor> (const id) is the a function that always returns the identity function.
06:07:32 <ddarius> smashor: Just apply the definitions.  That's all you have to do.
06:07:43 <ddarius> There's no thinking involved at all.
06:08:09 <roconnor> so that (const id) x is always id
06:08:42 <roconnor> > const id undefined 6
06:08:44 <lambdabot>  6
06:08:50 <ricky_clarkson> @type id
06:08:50 <roconnor> > id 6
06:08:53 <lambdabot> forall a. a -> a
06:08:53 <lambdabot>  6
06:09:12 <ddarius> const id 5 6 ~> (\x _ -> x) id 5 6 ~> (\_ -> id) 5 6 ~> id 6 ~> (\x -> x) 6 ~> 6
06:09:16 <ricky_clarkson> > let another=id in id (5::Integer)*id 6.5
06:09:17 <lambdabot>   add an instance declaration for (Fractional Integer)
06:09:29 <quicksilver> smashor: well the thinking to do is to understand how haskell groups things
06:09:36 <ricky_clarkson> > (5::Integer)*6.5
06:09:37 <lambdabot>   add an instance declaration for (Fractional Integer)
06:09:39 <smashor> quicksilver: that's the point
06:09:41 <quicksilver> smashor: const id 5 6 is (((const id) 5) 6)
06:09:57 <quicksilver> smashor: so 'const id' always returns id, it ignore the 5
06:10:05 <quicksilver> smashor: and the 'id' that got returned is appleid to the 6
06:10:07 <smashor> quicksilver: now I got it, thanks
06:10:09 <quicksilver> and id 6 == 6
06:10:10 <quicksilver> :)
06:11:57 <smashor> still so many things to learn... :D
06:12:23 <roconnor> it's like learning a new algebra.
06:13:32 <smashor> what's the correct notation for that (leave the parameter on both sides) ?
06:13:33 <ddarius> A new easier algebra.  There's only one rule.
06:13:46 <roconnor> ddarius: there are many derived rules.
06:14:17 <smashor> so myLast = foldr1 (const id) is the same as myLast x = foldr1 (const id) x
06:14:19 <roconnor> correct notation for what?
06:14:21 <ddarius> real algebra has many axioms
06:14:31 <osfameron> oh, the const id 5 6 example is surprising and informative
06:14:50 <roconnor> ddarius: I think you will find that there is more rules than just beta equivalence.
06:14:59 <osfameron> I think I would write that with the parens to disambiguate though :-)
06:15:05 <roconnor> ddarius: you may argue there is  alpha equivalence, and there is certainly iota-equivalence.
06:15:24 <ddarius> roconnor: I could reduce it all to beta equivalence if I like and there is still quite a bit less than algebra.
06:16:11 <roconnor> ddarius: you can reduce away alpha equivalence?
06:16:15 <ddarius> Yes.
06:16:21 <roconnor> really?
06:16:23 <roconnor> how?
06:17:07 <quicksilver> roconnor: google doesn't seem to know what iota-equivalance is. What is it?
06:17:24 <smashor> ah.. I meant eta reduction
06:17:30 <ddarius> I could switch to deBruijn indices if I like or use an explicit substitution calculus (though that would probably add rules...)  I could assert all names be distinct though that's not quite enough.
06:17:35 <roconnor> quicksilver: I don't know how standard the iota term is.  It is case anaysis.
06:18:04 <roconnor> ddarius: oh.  I thought you were going to reduce it to beta-reduction.
06:18:10 <ddarius> roconnor: I knew what you meant, though I wasn't sure.
06:18:38 <roconnor> I only got iota-reduction from the Coq documenation.
06:18:51 <roconnor> I wonder if it is Thompson's book.
06:18:53 <ddarius> Anyway, alpha conversion applies to the algebra too.
06:18:59 <ddarius> But I have to go.
06:20:45 <ivanm> Does anyone here know of an implementation of Boehm's exact real arithmetic in Haskell?
06:21:32 <roconnor> ivanm: maybe I wrote one.
06:21:50 <ivanm> "maybe"?
06:22:02 <roconnor> Depends on what you mean by Boehm's implemenation.
06:22:45 <quicksilver> ivanm: maybe http://www.rbjones.com/rbjpub/cs/cs011.htm has some clues?
06:22:49 <lambdabot> Title: Implementation of Computation with Reals
06:23:30 <ivanm> roconnor: where numbers are represented by a generating function which take in a precision parameter
06:23:43 <roconnor> http://www.haskell.org/haskellwiki/Exact_real_arithmetic#Implementations
06:23:45 <lambdabot> Title: Exact real arithmetic - HaskellWiki, http://tinyurl.com/uafsh
06:23:58 <ivanm> quicksilver: that's what I want... but the symalg link doesn't work
06:24:00 <roconnor> ivanm: yes, I did one of those sorts.
06:24:02 <ivanm> forgot I found that page :s
06:24:36 <quicksilver> http://journals.cambridge.org/production/action/cjoGetFulltext?fulltextid=851624
06:24:40 <lambdabot> http://tinyurl.com/33xm7e
06:24:44 <quicksilver> ^^ that appears to be roconnor's paper :)
06:24:55 <quicksilver> at least, it has his name at the top, and lots of haskell code at the end
06:25:20 <roconnor> :)
06:25:25 <ivanm> heh
06:25:29 <ivanm> thanks quicksilver, roconnor
06:25:59 <quicksilver> Unless there are two distinct R. O'connor's writing haskell programs for real arithmetic, perhaps
06:26:00 <ivanm> I've been reading through Boehm's paper in Topics in Functional Programming, but he never mentions how he implemented it
06:26:14 <roconnor> ivanm: David Lester's implemenation is better.
06:26:19 <ivanm> just "yeah, we wrote something, and its efficiency is better than continued fractions"
06:26:45 <ivanm> @google "david lester" "exact real arithmetic"
06:26:48 <Dybber> How do I measure how much time it takes to execute a function? Is there something like time :: (a->b) -> a -> IO (..some-type..)
06:26:48 <lambdabot> http://eliaus.univ-perp.fr/spip.php?article121
06:26:48 <lambdabot> Title: ..: Laboratoire ELIAUS [Erreur] :..
06:27:12 <quicksilver> Dybber: depends what you think 'execute' means
06:27:25 <ivanm> heh, don't think that's it... since that page doesn't exist! :p
06:27:43 <quicksilver> Dybber: generally, you call 'getCurrentTime', you force as much of the function as you're interested in, and then you call getCurrentTime again
06:27:45 <Dybber> quicksilver, get the value of the function when applied to a given value
06:27:46 <roconnor> ivanm: http://darcs.augustsson.net/Darcs/CReal/
06:27:48 <lambdabot> Title: Index of /Darcs/CReal
06:27:59 <roconnor> was linked to by the wiki
06:28:11 <quicksilver> Dybber: haskell functions may return their values bit by bit depending how much you inspect, though :)
06:28:39 <roconnor> Dybber: you may be interested in "evaluate" to help force evaluation
06:28:43 <roconnor> @type evaluate
06:28:45 <lambdabot> Not in scope: `evaluate'
06:28:51 <roconnor> @hoogle evaluate
06:28:52 <lambdabot> Control.Exception.evaluate :: a -> IO a
06:28:52 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
06:29:04 <roconnor> Control.Exception.evaluate
06:29:27 <roconnor> but beware, it only forces head normal form IIRC.
06:29:49 <Dybber> thanks quicksilver and roconnor, i think I can work something out now :)
06:30:54 <ivanm> roconnor: looking through it... can't see anywhere you have a precision parameter being used to define how precise your computable real number is
06:31:33 <roconnor> ivanm: showCReal's first parameter is the precision
06:31:44 <ivanm> ahhh
06:31:48 * ivanm looks again
06:33:03 <roconnor> but for approximation as number pull out the Int -> Integer function from the CR_ constructor
06:33:13 <roconnor> the Int is again the precision.
06:34:09 <roconnor> (this time in bits)
06:38:31 <ti8jge> hello, is there a system function that checks if every element of a list is the same?
06:39:02 <ti8jge> because i have a list of lists, and i want to know if the size of all of the sub-lists are the same
06:39:31 <ivanm> ti8jge: you could code it, I suppose.....
06:39:31 <ti8jge> i can create a function of my own, but if we already have one implemented, it would be better
06:39:38 <ivanm> but I don't think so
06:39:39 <dcoutts> ti8jge: think about using zip or zipWith
06:39:41 <ivanm> @hoogle [[a]]
06:39:42 <lambdabot> List.inits :: [a] -> [[a]]
06:39:42 <lambdabot> List.tails :: [a] -> [[a]]
06:39:42 <lambdabot> Data.Tree.levels :: Tree a -> [[a]]
06:39:55 <roconnor> @hoogle Eq a => [a] -> Bool
06:39:55 <lambdabot> Prelude.null :: [a] -> Bool
06:39:55 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
06:39:55 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
06:40:17 <ToRA|home> @type \xs -> and . map ((head xs) ==) $ xs
06:40:19 <lambdabot> forall a. (Eq a) => [a] -> Bool
06:40:25 <roconnor> the best I can think of is (null x || all (==(head x)) x)
06:40:57 <dcoutts> > let allSame [] = True; allSame xs = zipWith (==) xs (tail xs) in allSame "aaaa"
06:40:58 <lambdabot>  Couldn't match expected type `Bool' against inferred type `[Bool]'
06:41:03 <dcoutts> bah
06:41:09 <dcoutts> > let allSame [] = True; allSame xs = and (zipWith (==) xs (tail xs)) in allSame "aaaa"
06:41:11 <lambdabot>  True
06:41:53 <quicksilver> yes, zipWith(==)`ap`tail is about the best you can do, I believe
06:41:56 <roconnor> > (\x -> all (==(head x)) x) []
06:41:57 <lambdabot>  True
06:42:03 <roconnor> yay laziness
06:42:05 <dcoutts> my solution and roconnor's differ if your == test is not transitive
06:42:17 <roconnor> fuck the call to null
06:42:41 <quicksilver> if your == is not transitive your quarks will separate and you will vanish into a quantum superstate
06:42:52 <opqdonut> :D
06:43:07 <roconnor> I wonder if catch is happy with (\x -> all (==(head x)) x)
06:43:17 <dcoutts> quicksilver: it's important for things like groupBy where you supply an arbitrary ==-like function
06:43:30 <roconnor> @pl (\x -> all (==(head x)) x)
06:43:30 <lambdabot> all =<< (==) . head
06:43:41 <dcoutts> roconnor: that's an interesting question
06:43:53 <roconnor> anyone have catch installed?
06:43:58 <quicksilver> it should be OK if it can see the definition of 'all'
06:43:58 <roconnor> @seen ndm
06:43:58 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 14h 11m 20s ago, and .
06:44:01 <quicksilver> which presumably it can
06:44:34 <roconnor> @src head
06:44:35 <lambdabot> head (x:_) = x
06:44:35 <lambdabot> head []    = undefined
06:44:45 <roconnor> presumably catch is not happy with head?
06:44:46 <ivanm> roconnor: any idea if David Lester bothered to update that to use H98?
06:44:54 <quicksilver> catch is not happy with head, per se
06:44:56 <roconnor> even though the pattern match is ``complete''
06:45:01 <quicksilver> but catch can detect when you use head safely
06:45:16 <roconnor> ivanm: I patched it to make it Haskell '98
06:45:18 <quicksilver> you give catch a set of 'root nodes'
06:45:24 <quicksilver> i.e. functions you plan to call
06:45:26 <quicksilver> e.g. 'main'
06:45:30 <quicksilver> and it checks those are safe
06:45:43 <ivanm> roconnor: ahhh, OK... that's the one in lennart's darcs repo?
06:45:52 <roconnor> ivanm: is the darcs version not haskell 98?
06:46:13 <roconnor> ivanm: I put a patch on the old wiki.  I assume lennart applied the patch but I don't know.
06:46:37 <roconnor> I don't have the rights to David's work, so I never produced a patched version.
06:46:40 <ivanm> it mentions Haskell 1.2, so I don't know (haven't actually tried building and running it yet, more interested in how it was done)
06:46:45 <ivanm> roconnor: *nod*
06:46:47 <roconnor> I argue that  a patch isn't a violation of copyright.
06:46:57 <roconnor> but some people disagree ... so I may still end up in jail.
06:47:57 <quicksilver> roconnor: we'll send you lambdas, if you do
06:48:38 <ivanm> quicksilver: real lambdas, or "\" ascii representation of lambdas?
06:49:24 <quicksilver> real ones, hidden in cakes
06:50:13 * roconnor will evaluate myself out of jail.
06:50:14 <ivanm> heh
06:51:48 * roconnor callCCs
06:51:57 <roconnor> free man at alst
06:51:59 <roconnor> last
06:52:10 <downs> purely out of interest, could you give me an estimate as to how long it would take to generate the first 65k fibonacchi numbers in Haskell, presuming a compiler of your choice?
06:52:28 * downs is trying to draw a comparison to some D code he whipped up
06:52:55 <downs> I'm downloading the GHC to try it out myself, but my battery might not last that long.
06:52:58 <ricky_clarkson> Heh, sending a lambda in cakes is kinda a good description of how Java's planning to get closures (lambdas).
06:53:26 <opqdonut> downs: that should be pretty quick to test
06:53:48 <downs> yeah but I'm down to 30% battery charge, and this is gentoo
06:53:54 <downs> so it might run out trying to build it
06:54:15 <opqdonut> :D
06:54:26 <ricky_clarkson> Laptops preinstalled with Gentoo should come with a free generator.
06:54:30 <downs> totally
06:54:53 <downs> like, with a hand crank
06:54:55 * downs 'd <3 that
06:55:19 <ricky_clarkson> I wouldn't mind a hand-crank for laptops in general.
06:55:24 <downs> ack
06:55:34 <quicksilver> downs: takes about 65 seconds to generate the 65001st, for me
06:55:35 <roconnor> > log 2
06:55:35 <ricky_clarkson> Or maybe a foot-pedal, then I can power it by tapping my foot to music.
06:55:36 <Lemmih> downs: 1.8 seconds in ghci, 1.2s when compiled.
06:55:36 <lambdabot>  0.6931471805599453
06:55:41 <quicksilver> downs: erm, about 5-6 seconds
06:55:48 <downs> okay, haskell wins that one :D
06:55:51 <ToRA|home> > last . take 65000 $ fix ((1:) . scanl (+) 1)
06:55:54 <lambdabot>  7032848247492065712932639019933964353964340005290905667371705187605468522703...
06:56:07 * downs is looking at 19s in D, although with a self-written, unoptimized bignum
06:56:36 <vegai> D should be a bit faster
06:56:41 <quicksilver> that was interpreted, and I fear a lot of the time was formatting the number :)
06:56:54 <vegai> it has to more to do with the algorithm than the language
06:57:01 <downs> true
06:57:19 <downs> the D code used was   bignum[] array=[bignum("0"), bignum("1")]; bignum fibs(int where) { while (array.length!>where) array~=array[$-1]+array[$-2]; return array[where]; }
06:57:19 <downs>   writefln(Integers[0..10000] ~ map(&fibs) ~ toArray);
06:57:40 <downs> fast as it gets, afaik
06:58:14 <downs> waitasec .. there's a bignum class here :D :goes adapt:
07:02:51 <downs> damnit. this module is incomplete.
07:02:58 * downs gives up. Battery is down anyways.
07:03:29 <int-e> downs: if you want to print them all you're probably best off with a naive base 10^9 (10^18 for 64 bit systems) implementation of bignums, and addition, otherwise output time, converting from binary to decimal, will dominate the running time.
07:04:06 <downs> mmh
07:04:21 <downs> I'll probably end up using uints .. the problem is conversion to decimal
07:04:31 <opqdonut> print in hexadecimal
07:04:41 <paczesiowa> don't print at all
07:04:41 <downs> heh .. interesting idea
07:05:35 <paczesiowa> isn't computing enough?
07:06:44 <downs> also true. Down to 16%. I'll hibernate now to prevent crashing.
07:06:45 <downs> Laters :)
07:08:50 <nominolo> :t fmap id Set.empty
07:08:53 <lambdabot> Couldn't find qualified module.
07:08:56 <nominolo> :t fmap id S.empty
07:08:58 <lambdabot> Couldn't find qualified module.
07:09:16 <byorgey> try Data.Set.empty
07:09:25 <nominolo> @instances Functor
07:09:26 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:09:42 <nominolo> ah, right.  Ord constraint ...
07:09:54 <byorgey> yeah =(
07:10:17 <nominolo> no.  does that really hinder making it an instance of Functor?
07:11:16 <nominolo> > Data.Set.map (\x -> x*x) Data.Set.fromList [4, -4]
07:11:17 <lambdabot>  Couldn't match expected type `Data.Set.Set a'
07:12:16 <visq> downs: for comparison, C&gmp takes ~ 30% (0.4s) of ghc fibs; not too bad, as ghc does not destructivly update integers afaik
07:12:18 <quicksilver> nominolo: yes, it does
07:12:29 <quicksilver> nominolo: because you can't give fmap an unbounded type
07:12:40 <quicksilver> nominolo: there is a blog post explaining the work-around though
07:13:13 <nominolo> does x == fmap f y  ==>  length x == length y ?
07:13:30 <quicksilver> for lists? yes
07:13:35 <opqdonut> you probably want map instead of fmap
07:13:38 <opqdonut> then yes :)
07:13:43 <nominolo> no, i mean, is it a requirement of fmap ?
07:13:45 <quicksilver> no
07:13:56 <quicksilver> well... length is only defined on lists
07:13:57 <quicksilver> :)
07:14:12 <nominolo> good point
07:14:14 <quicksilver> but in principle, no it's not a requirement as far as I know
07:14:42 <quicksilver> I think a functor which maps everythign to a single point is still a functor
07:15:11 <quicksilver> data Unit a = (); instance Functor Unit where fmap f () = ()
07:15:12 <nominolo> i think there's a workaround using ATs, now
07:15:42 <byorgey> quicksilver: but in that example, fmap somehow still perserves "size"
07:15:51 <byorgey> *preserves
07:16:11 <quicksilver> byorgey: hmm that's true
07:16:36 <int-e> nominolo: you could have  class Functor' f a b where fmap :: (a -> b) -> f a -> f b, and, say, instance (Ord a, Ord b) => Functor' Set a b where fmap f = fromList . map f . toList
07:17:46 <nominolo> i can live with using Data.Set.map
07:18:03 <nominolo> would just have been nicer to just use fmap
07:18:19 <nominolo> of course, there's also Data.Foldable
07:18:35 <nominolo> er, Traversable or so
07:20:07 <Taejo> @pl map fst $ iterate (\(a, b) -> (b, a+b)) (0, 1)
07:20:07 <lambdabot> map fst (iterate (uncurry (ap (,) . (+))) (0, 1))
07:20:57 <opqdonut> :D
07:21:38 <shapr> Mmm, readable code.
07:23:15 <ramza3> Setup.o(.text+0x46):fake: undefined reference to `Cabalzm1zi1zi6zi2_Distribution
07:23:15 <ramza3> ziSimple_defaultMainWithHooks_closure'
07:23:23 <ramza3> I got the darcs OpenGL repo, and am trying to build it.  I did autoreconf and then ./configure ...now what do I do.  I tried ghc Setup.hs  ...but got those errors
07:25:24 <ivanm> what does this error message mean? "(`Time' has non-nullary constructors)"
07:25:49 <quicksilver> trying to derive Enum, perhaps?
07:25:52 <ivanm> I'm trying to have a newtype datatype over Int, which derives Eq, Ord, Enum and Show, but it doesn't like it :(
07:25:54 <int-e> ramza3: add --make to the ghc command line
07:25:55 <quicksilver> something along those lines
07:25:56 <ivanm> quicksilver: yes
07:26:12 <ramza3> int-e: oops, duh
07:26:16 <ivanm> but why doesn't it like it?
07:26:23 <quicksilver> you can't derive Enum for non-Enum types
07:26:33 <ivanm> isn't Int an enum type?
07:26:41 <quicksilver> the built-ing 'deriving Enum' must take priority over the magic newtype stuff
07:26:47 <quicksilver> or maybe you just don't have -fglasgow-exts on?
07:26:55 <ivanm> oh, do you need that?
07:27:02 <quicksilver> newtype deriving is an extension, yes
07:27:14 <int-e> ivanm: you need the GeneralizedNewtypeDeriving extension for that.
07:27:19 <ivanm> :(
07:27:21 <nominolo> ramza3, or use runhaskell Setup.hs configure
07:27:30 <ivanm> why does newtype need deriving when Data doesn't?
07:27:53 <Botje> data is just an alias
07:27:57 <Botje> compiler expands it for you
07:28:04 <int-e> no, data defines a new type
07:28:06 <ivanm> I thought newtype was the alias...
07:28:06 <ivanm> heh
07:28:07 <int-e> do you mean type?
07:28:12 <Botje> err
07:28:12 <Botje> that
07:28:20 <Botje> come to think of it, what DOES data do? :)
07:28:23 <quicksilver> ivanm: your comment makes no sense?
07:28:36 <quicksilver> ivanm: with a 'data' you wouldn't get an Enum instance, would you?
07:28:37 <ivanm> quicksilver: which one? a lot of what I say doesn't make sense? :p
07:28:54 <quicksilver> there are two ways to derive an Enum instance
07:29:02 <quicksilver> (1) haskelly 98, all constructors must be nullary
07:29:16 <quicksilver> (2) generalised newtype deriving, must be a newtype, is a GHC extension
07:29:27 <int-e> oh, yes the builting deriving will probably take precedence. that's unfortunate.
07:29:30 <ivanm> why is that?
07:29:54 <ivanm> so how come inbuilt types, like Int, have Enum, but manually created ones don't?
07:30:05 <ivanm> cos Int is magically defined as 1 | 2 | 3 | 4 | ... ?
07:30:17 <quicksilver> I don't think it's magic
07:30:24 <int-e> ivanm: haskell98 treats  newtype Foo = Foo X like data Foo = Foo X for purposes of deriving instances.
07:30:30 <quicksilver> the source of the Enum instance is part of the standard library
07:30:37 <quicksilver> you could easily write it yourself
07:30:40 <ivanm> quicksilver: so tell me then, how would you manually code such a thing if you were trying to re-define Int?
07:30:48 <ricky_clarkson> Would data be more appropriate?
07:30:49 <quicksilver> instance Enum (MyType) where...
07:30:53 <quicksilver> I'd write the instance!
07:31:00 <ivanm> *nod*
07:31:03 <quicksilver> instances don't have to be derived... you can just write them
07:31:18 <int-e> instance Enum Int where { toEnum = id; fromEnum = id }
07:31:35 <ivanm> well, in this case, the only reason I was using newtype instead of type was to hide the constructor... but since I'm the only one using this module, stuff it
07:32:22 <int-e> > fromEnum 1.5
07:32:24 <lambdabot>  1
07:32:27 <int-e> eek.
07:32:31 <ivanm> heh
07:32:38 <ivanm> > fromEnum 1.6
07:32:39 <roconnor> int-e: cover that up
07:32:40 <lambdabot>  1
07:32:47 <ivanm> :t fromEnum
07:32:49 <lambdabot> forall a. (Enum a) => a -> Int
07:32:51 <define-macro>  /msg nickserv set hide email on
07:33:10 <downs> kay, found a power outlet
07:33:28 <int-e> roconnor: I wasn't aware of that instance. I wonder why it exists.
07:33:39 <quicksilver> int-e: [1,1.1...2]
07:33:48 <roconnor> int-e: it's horrible
07:33:51 <quicksilver> int-e: annoying, isn't it? :)
07:33:53 <int-e> quicksilver: hmm. right.
07:33:58 <int-e> yes :)
07:34:04 <quicksilver> should be a 'Range' or 'Sequence' class, or something
07:34:18 <roconnor> int-e: don't get me started on the Enum instance for Fixed
07:34:39 <ricky_clarkson> Can you progammatically remove instances?
07:34:51 <shapr> Sort of
07:35:04 <int-e> ricky_clarkson: no. you can only avoid importing them.
07:35:04 <roconnor> ricky_clarkson: intances are like virues that infect all your haskell modules.
07:35:12 <osfameron> > 1.1 + 0.1
07:35:14 <lambdabot>  1.2000000000000002
07:35:23 <roconnor> wear a newtype for protection
07:35:31 <osfameron> odd, perl -debug reports that as 1.2
07:35:35 <shapr> Or just keep your instances in their own module.
07:35:37 <ivanm> oh well, thanks for your help everyone...
07:35:43 <osfameron> I thought everyone used the same floating point libraries at the backend
07:35:43 <ivanm> g'night all
07:36:01 <roconnor> shapr: ?
07:36:05 <int-e> osfameron: well, not everyone prints floating point numbers the same way
07:36:20 <roconnor> excel for example ...
07:36:23 <osfameron> int-e: oh, so the problem is when it comes to output?
07:36:26 <shapr> roconnor: Avoid importing by separating instances from class/code.
07:36:38 <roconnor> shapr: what if I want to use the instance?
07:36:51 <osfameron> oh, no it's that it imposes :: Double by default
07:36:55 <shapr> Then you can use it. But it should be the user's choice.
07:36:57 <osfameron> > 1.1 + 0.1 :: Float
07:36:59 <lambdabot>  1.2
07:37:12 <roconnor> shapr: what if I want to use an instance in a module that others want to use?
07:37:25 <shapr> ?
07:37:44 <roconnor> I import an instance so I can write a beautiful module
07:38:03 <roconnor> then someone imports my module because it works well because it is written with beautiful code
07:38:14 <roconnor> then they get that instance that I imported, right?
07:38:28 <shapr> Yes, but your beautiful module isn't part of the original library.
07:38:30 <fasta> The H98 language report doesn't specifiy the complexity of operations, right?
07:38:30 <quicksilver> osfameron: I weould have thought perl was double by default too
07:38:38 <fasta> specify*
07:38:58 <quicksilver> osfameron: there is a long tradition, anyhow, of displaying FP numbers to 1, 2 or 3 fewer digits than maximum accuracy, to conceal rounding errors to some degree
07:39:00 <roconnor> shapr: but my module is part of my library.
07:39:12 <quicksilver> osfameron: pocket calculators, for example, do this
07:39:13 <osfameron> quicksilver: dunno... I thought it automatically promoted numeric types as required.  But in either case 1.1+0.1 in perl -debug gives a "nicer" answer
07:39:29 <osfameron> quicksilver: I thought pocket calculators used fixed point anyway?
07:39:58 <shapr> roconnor: I think you'd have to structure your library in some way other than keeping all instances separate then.
07:40:21 <roconnor> shapr: I don't see how that is possible; but I haven't studied the issue too much.
07:40:28 <frederik> I asked some hours ago, I thought I should try again, does anybody in here have experience with haskelldb?
07:40:43 <quicksilver> osfameron: some of them display binary-style rounding errors, at least
07:40:48 <quicksilver> osfameron: if you know how to find them :)
07:40:53 <ToRA|home> frederik: i have some, what's up?
07:40:56 <roconnor> I don't see how you can use instances effective if you need to relegate them to an untouchable region.
07:40:57 <int-e> osfameron: try perl -le 'printf "%20.18f\n", (1.1+0.1)'
07:41:01 <roconnor> effectively
07:41:07 <frederik> ToRA|home: great, finally someone who used it ;)
07:41:14 <osfameron> quicksilver: sadly I haven't had a pocket calculator for a couple of years (use phone if I need to)
07:41:32 <zipMe> hello, can somebody point out what's wrong here : m = array ((1,2),(1,2)) [((1,1),0),((1,2),0),((2,1),0),
07:41:32 <zipMe> ((2,2),4)]
07:41:39 <frederik> ToRA|home: well ... first: do you know how one is supposed to generate the database description modules in the latest version?
07:41:41 <ricky_clarkson> I want a pocket lambdabot.
07:42:04 <downs> looking at 1s without output
07:42:23 <int-e> > printf "%20.18f\n" (1.1+0.1) -- it cheats :/
07:42:25 <lambdabot>  Add a type signature
07:42:30 <quicksilver> zipMe: they're out of bounds?
07:42:31 <ToRA|home> frederik: mm, so I don't know about latest version
07:42:35 <int-e> > (printf "%20.18f\n" (1.1+0.1)) :: String -- it cheats :/
07:42:37 <lambdabot>  "1.200000000000000200\n"
07:42:38 <ToRA|home> frederik: I'm running a debian system here
07:42:47 <frederik> ToRA|home: the old documentation first talks about DBDirect, which isn't available in the package, then it mentions dbspec which isn't in there too
07:42:53 <zipMe> quicksilver : yep i get *** Exception: Error in array index
07:42:57 <ToRA|home> frederik: right, so I was using DBDirect
07:42:58 <frederik> ToRA|home: well, how do you generate the modules?
07:43:01 <frederik> oh
07:43:07 <zipMe> quicksilver : i don't understand why :/
07:43:10 <quicksilver> zipMe: you've said the array only goes from (1,2) minimum to (1,2) maximum
07:43:17 <quicksilver> zipMe: so it should only be one element :)
07:43:23 <ToRA|home> frederik: DBDirect PostgreSQL host username password etc...
07:43:26 <downs> anyway, laters :)
07:43:26 <quicksilver> zipMe: I think you meant ((1,1),(2,2)) as the range
07:43:33 <zipMe> quicksilver, ok got it, thans :)
07:44:05 <int-e> > ((1.1+0.1)-1.2) * 2^52
07:44:06 <lambdabot>  0.625
07:44:39 <frederik> ToRA|home: I wrote a few lines of code which generate the modules using the functions from Database.HaskellDB.DBSpec
07:44:55 <frederik> .DBSpecToDatabase
07:45:25 <frederik> ToRA|home: do you know which version is in debian?
07:45:47 <frederik> (um, DatabaseToDBSpec, of course)
07:46:08 <ToRA|home> apt-cache show haskelldb-bin gives Version: 0.9.cvs.601-18
07:46:28 <frederik> ToRA|home: oh, ok, the current version available at hackage.haskell.org is 0.10
07:46:58 <osfameron> int-e: ah, ok
07:47:12 <frederik> ToRA|home: I'm able to insert data into the database and even query data, but using ! to access record fields doesn't work for me
07:47:56 <frederik> ToRA|home: it complains about there being no Select instance for the Record datatype
07:49:37 <ToRA|home> frederik: mmm, can you (have you already) pasted some code context for ur use of ! ?
07:49:53 <frederik> ToRA|home: I didn't, but I can
07:50:19 <frederik> ToRA|home:  do insert db veranstaltungen vRec
07:50:19 <frederik>            idRec <- (query db) $ (project (iD << lastInsertId))
07:50:19 <frederik>            verId <- idRec ! iD
07:50:26 <fasta> Is anyone using FGL for a practical application?
07:50:45 <dons> I used it for the 05 ICFP contest
07:50:45 <fasta> (I cannot imagine someone is doing so, unless for the most trivial of problems)
07:50:46 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
07:51:02 <fasta> dons: but you didn't go further than 2000 nodes, right?
07:51:14 <dons> roughly, yes.
07:51:49 <frederik> ToRA|home: so I first insert some record and then I try to get the last insert it (I don't know any better way to do this with haskelldb then with a small snippet of code I found on the net: lastInsertId = Expr (ConstExpr (OtherLit "LAST_INSERT_ID()"))
07:52:02 <frederik> , which works)
07:53:36 <ToRA|home> frederik: query returns a list tho doesn't it?
07:53:48 <ToRA|home> frederik: (or am i bracketing that wrong?)
07:56:00 <frederik> ToRA|home: yes, it does
07:56:07 <frederik> wait ...
07:56:17 <frederik> query :: (Database.HaskellDB.Database.GetRec er vr) =>
07:56:17 <frederik> Database -> Query (Rel er) -> IO [Record vr]
07:57:26 <ToRA|home> so don't you mean (last idRec) ! iD in that example if you want the last thing?
07:57:40 <ToRA|home> (tho there must be a more databasey way of doing this..)
07:58:02 <bilboquet> I'm trying to install NewBinary and I get an error that lang-any cannot be satisfied. What does that mean?
07:59:00 <desegnis> bilboquet: Is lang a library?
07:59:24 <bilboquet> desegnis:  how do I check?
08:00:21 <frederik> ToRA|home: brb
08:00:27 <desegnis> bilboquet, no idea. It's not in hackage anyway
08:00:35 <Beelsebob> is there any sensible way to recover a lost haskell.org password?
08:01:18 <desegnis> bilboquet, what's the full error message?
08:01:20 <desegnis> @hpaste
08:01:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:02:38 <bilboquet> desegnis:  Setup: cannot satisfy dependency lang-any
08:03:32 <bilboquet> http://hpaste.org/3436
08:08:05 <frederik> ToRA|home: hm, now I'm totally confused *g
08:08:11 <desegnis> bilboquet: Funny. Do you get the same error if compiling by hand? Because, NewBinary.cabal on hackage does not mention lang
08:08:32 <ToRA|home> frederik: ok...
08:08:58 <bilboquet> desegnis: I haven't tried compiling by hand. It looks like lang is an old package.. I'm update my haskell install
08:09:07 <bilboquet> s/update/updating
08:09:36 <frederik> ToRA|home: I'll try something
08:09:43 <desegnis> bilboquet: Well, newBinary is an old package, too
08:10:27 <ToRA|home> frederik: if you're getting type errors, try putting a (ideally cut down) example of the code and error on hpaste.org/new and i'll have a look see if i can see anything
08:10:49 <bilboquet> desegnis: Ultimatelty, I'm trying to install suppercollider
08:12:40 <frederik> ToRA|home: thanks
08:20:19 <frederik> ToRA|home: Ok, I guess I found my mistake :)
08:20:48 <ToRA|home> frederik: hehe, glad to be of help :)
08:20:51 <frederik> ToRA|home: but there's still the problem how to get the last insert id
08:21:18 <dons> ?users
08:21:18 <lambdabot> Maximum users seen in #haskell: 420, currently: 381 (90.7%), active: 10 (2.6%)
08:21:26 <ToRA|home> frederik: hmm
08:22:11 <roconnor> I can compute logorithms in Coq \o/
08:22:22 <ToRA|home> frederik: well if you have your code snippet, and it's sane, i guess you cna put that in a query
08:22:46 <ToRA|home> frederik: and then do [res] <- query $ expr
08:22:57 <ToRA|home> the question is then what can you do with res
08:26:26 <frederik> ToRA|home: I'll just see what I can do. Now I'd ohly like to know what is the "official" way to generate the database descriptions in the latest version ...
08:27:05 <frederik> ToRA|home: but the way I do it works, but the way it is described in the docs definitly does not work in the version available on hackage
08:27:23 <ToRA|home> from the look of the hackage docs, i assume it's by using dbToDBSpec in Database.HaskellDB.DBSpec and then dbInfoToModuleFiles in Database.HaskellDB.DBSpec.DBSpecToDBDirect
08:27:27 <frederik> ToRA|home: haskelldb could really use a better documentation ;)
08:27:34 <ToRA|home> assuming you want to grab the schema from a live db
08:27:43 <quicksilver> who needs documentation when you have types?
08:27:44 <frederik> ToRA|home: that's what I did, yes
08:27:55 <frederik> ...
08:28:06 <frederik> quicksilver: did you ever see haskelldb's types *g
08:28:37 <quicksilver> hmm
08:28:40 <quicksilver> maybe the types need types
08:28:43 <quicksilver> to help document them
08:28:43 <quicksilver> :P
08:28:46 <mrd> kinsd
08:28:52 <ToRA|home> they do, but it's mostly *
08:29:14 <kosmikus> maybe the types need to be more precise, and you have to be able to use more syntax on the type level
08:29:14 <lambdabot> kosmikus: You have 1 new message. '/msg lambdabot @messages' to read it.
08:29:25 <kosmikus> thanks, lambdabot
08:34:13 <frederik> btw the lack of documentation reminds me of wxhaskell, does anybody know what happened to it? Somebody took over the development, is there any progress?
08:34:42 <quicksilver> I beleive there is
08:34:47 <quicksilver> it looks recently updated to me
08:35:09 <quicksilver> well, recently = 2007 at least
08:35:51 <quicksilver> but the darcs repo has changes in august
08:36:10 <frederik> quicksilver: oh, I didn't notice that, I'll have to take a look at it when I find some time
08:43:49 <Xymic> http://www.xymic.eu.tt
08:43:51 <Xymic> http://www.xymic.eu.tt
08:43:51 <lambdabot> Title: ..:: Xymic ::..
08:43:52 <lambdabot> Title: ..:: Xymic ::..
08:43:53 <Xymic> http://www.xymic.eu.tt
08:43:53 <lambdabot> Title: ..:: Xymic ::..
08:44:48 <opqdonut> .....
08:45:01 <kowey> frederik: wxhaskell is still somewhat alive.... last activity in Sep, though.
08:45:24 <kowey> Jeremy O'Donoghue said he was working on some build stuff, particularly getting it to compile with wxWidgets 2.8
08:45:58 <kowey> (that was in August)
08:46:17 <shapr> @yow !
08:46:18 <lambdabot> This PORCUPINE knows his ZIPCODE ... And he has "VISA"!!
08:47:28 <shapr> mm spam
08:47:40 <opqdonut> mm
08:47:48 <opqdonut> @yow ?
08:47:48 <lambdabot> Does someone from PEORIA have a SHORTER ATTENTION span than me?
08:47:52 <shapr> @yow !
08:47:53 <lambdabot> hubub, hubub, HUBUB, hubub, hubub, hubub, HUBUB, hubub, hubub, hubub.
08:47:56 <quicksilver> if you liked the PORCUPINE with VISA you're going to love this CAPYBARA with AMEX.
08:48:08 <opqdonut> :D
08:48:27 <shapr> Yow!  Legally-imposed CULTURE-reduction is CABBAGE-BRAINED!
08:48:55 <MyCatSchemes> Odd. How come the bracket function in IO isn't anywhere in HHL?
08:49:14 <dons> shapr: :D
08:49:15 <quicksilver> what's HHL?
08:49:16 <shapr> Yow! This TYPE THEORIST knows CATEGORY THEORY but forgot his LUNCH!
08:49:51 <dons> Yow! The C# programmer tried to COMPOSE his FUNCTIONS but ended up NAUSEOUS!
08:49:57 <shapr> hah!
08:50:18 <raxas> that one about type theorist is worth for lambdacat
08:50:26 <dons> http://diditwith.net/2007/10/23/BuildingFunctionsFromFunctionsPart2FunctionComposition.aspx
08:50:29 <lambdabot> Title: Did it with .NET - Building Functions from Functions, part 2: Function Compositi ..., http://tinyurl.com/yp9lur
08:50:43 <shapr> Somewhere in the UK, SIMON PEYTON-JONES is dreaming of REDEXES!
08:50:47 <dons> heh
08:50:57 <frederik> kowey: last time I tried to use it about a year ago I couldn't build it with the then latest ghc
08:51:11 <kowey> 6.6?
08:51:16 <shapr> dons: C# requires a whole article on how to do function composition?
08:51:21 <kowey> we now have a two stage process that fixes that
08:51:23 <dons> yeah, I know!
08:51:26 <frederik> kowey: don't remember it, sorry
08:52:00 <kowey> frederik: ok, well, it should build now, with wxWidgets 2.6 (not 2.8 yet) and GHC 6.6
08:52:20 <quicksilver> dons: that article filed under "read it and weep"
08:52:24 <kowey> you'll want the darcs version, though
08:54:54 <earthy> ooh, function composition in C#! usefule!
08:56:32 <earthy> (given that I'll be doing some C# in the near future)
08:57:57 <quicksilver> it has been demonstrated that there is only one program you should ever write in C#
08:58:05 <quicksilver> a haskell compiler or interpreter!
08:58:32 <user317> is there a poll or select function in haskell?
08:58:56 <quicksilver> user317: the idiomatic thing to do is just use threads
08:59:16 <quicksilver> user317: if you want POSIX select() it's there in one of the posix modules, I think
09:00:06 <MyCatSchemes> @hoogle (a->Bool) -> [a] -> ([a],[a])
09:00:07 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
09:00:07 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
09:00:07 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
09:18:32 <shapr> mmm code
09:20:15 <arcatan> i love the smell of fresh code in the morning
09:21:46 <shapr> me too!
09:21:52 <shapr> Too bad it's shell script.
09:22:59 <allbery_b> could be java...
09:23:41 <ricky_clarkson> Hey!  I resemble that remark.
09:30:33 <shapr> Has anyone heard of a bluetooth binding for Haskell?
09:32:51 <shapr> @where lambdacats
09:32:51 <lambdabot> http://arcanux.org/lambdacats.html
09:32:55 <shapr> Yay lambdacats!
09:33:06 <shapr> Has anyone announced lambdacats on haskell-cafe?
09:34:13 <gwern> shapr: I think that's where I first learned of them
09:34:36 <shapr> oh
09:40:17 <byorgey> shapr: lambdacats actually sort of started on haskell-cafe, IIRC.
09:40:27 <shapr> I discovered that.
09:40:46 <shapr> I should read more -cafe!
09:41:01 <byorgey> well, it's something of a superhuman task these days. =)
09:43:09 <Adamant> I love lambdacats
09:44:52 <shapr> Me too
09:45:11 <shapr> lambdacats keep me laughing when the rest of the world pushes me to violence.
09:48:31 * allbery_b kinda caused lambdacats, inadvertently.
09:48:52 <Botje> oh noes! a side effect! get him!
09:49:00 * allbery_b still isn't sure if that was a mistake or not...
09:50:50 <EvilTerran> it's wittier than most of the "lolcats" meme, anyway
09:51:10 <osfameron> I quite like lolthulu
09:55:43 * pjd is sad that lolscientist.com didn't take off
10:05:12 <shapr> Does Windows have anything like inotify?
10:05:18 <shapr> I know mac has something like that.
10:07:57 <allbery_b> it does but I couldn't tell you how it works
10:11:54 <byorgey> mmm, quiet today.
10:12:00 <shapr> allbery_b: Any idea what it's called?
10:13:27 <shapr> byorgey: Make some productive noise!
10:13:30 <shapr> byorgey: Written any code today?
10:14:05 <byorgey> shapr: well, some Java, but that doesn't count =(
10:17:52 <allbery_b> shapr: "Directory Change Notification", loosk like
10:19:45 <shapr> I'll check it out, thanks.
10:34:26 <Beelsebob> woot
10:34:39 <Beelsebob> got hat-anim simulating doing strict evaluation
10:38:42 * byorgey high-fives Beelsebob
10:45:14 <Beelsebob> don't tell olaf
10:45:22 <Beelsebob> he'll be annoyed I spent a day not writing up :P
10:50:22 <byorgey> hehe, don't worry =)
11:18:04 <eumenides> erm, I just installed hscurses, but I'm being told by ghc that it's a hidden package?
11:20:08 <Lemmih> eumenides: Add it to your cabal file?
11:21:42 <cschneid> excuse me for being a newbie :) but can anybody show me a tutorial which explains the (.) function and the ($) function?  I just need them drawn out with a few examples :)
11:22:22 <mauke> > 2 : [1, 10, 13]
11:22:24 <lambdabot>  [2,1,10,13]
11:22:33 <mrd> (f . g) x = f (g x)
11:22:40 <mauke> cschneid: ($) does nothing
11:22:40 <mrd> f $ x = f x
11:22:46 <mauke> it's just a syntactic separator
11:22:50 <Lemmih> cschneid: (.) is compose, ($) is apply.
11:23:32 <ketil> @seen ndm
11:23:33 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 18h 50m 54s ago, and .
11:23:34 <byorgey> > (+1) 4  -- add one
11:23:35 <lambdabot>  5
11:23:43 <byorgey> > (*2) 4 -- multiply by two
11:23:44 <lambdabot>  8
11:23:59 <byorgey> > ((+1) . (*2)) 4  -- multiply by two, then add one
11:24:00 <lambdabot>  9
11:24:02 <mrd> > (:[]) 1 -- monkey eats a number
11:24:03 <lambdabot>  [1]
11:24:19 <cschneid> mrd... I like that.
11:25:32 <eumenides> Lemmih: ach. got it
11:25:34 <cschneid> and thank you byorgey, I'll have to play around a bit more with the dot.  Do most lines of code move from right to left then when determining the order things get evaluated?
11:27:18 <eumenides> only when there are a lot of dots and a $ at the end
11:27:27 <Cale> cschneid: Well, things actually get evaluated left to right ;)
11:27:28 <Mr_Awesome> not if you use arrows
11:27:49 <Cale> If you have  f (g (h x)), then it's f which gets used first
11:28:08 <Cale> with  (g (h x))  as its argument
11:28:27 <cschneid> Cale, yeah, but if you do f . g . h x , it's f(g(h x)).  It would "run" h on x, use that result to do g, then f right?  I know it goes depth first, but it doesn't evaluate until coming back up
11:28:44 <ketil> It's too late for me - what is the memory requirements of 'span'?
11:28:47 <mauke> haskell evaluation goes outside in
11:29:14 <Cale> If f has something to return immediately, it will be able to do that without touching the g (h x)
11:29:26 <cschneid> Cale, I'm thinking to boring like... if f takes a function, and does something with it, g(h x)) doesn't need to be touched at all
11:29:54 <Cale> Well, yeah, that's a boring case, if it just ignores the parameter.
11:30:19 <mrd> ketil: it may cons a new list and the snd result should be shared with the original input
11:30:34 <Cale> It could also return a data structure which would have the g (h x) embedded somewhere within it -- then that wouldn't get evaluated until something else looked inside the data structure later.
11:31:13 <Cale> > let ones = 1 : ones in take 5 ones
11:31:22 <lambdabot>  [1,1,1,1,1]
11:31:36 <ketil> mrd: I'm trying to split a potentially huge list into partitions (using the old groupBy (const (not . p)) trick)
11:31:39 <Cale> take is evaluated first
11:31:50 <Cale> @src take
11:31:51 <lambdabot> take n _      | n <= 0 =  []
11:31:51 <lambdabot> take _ []              =  []
11:31:51 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
11:32:03 <ketil> mrd: memory seems to be proportional to the largest partition size... I was hoping to avoid that.
11:32:18 <mrd> yea i'd imagine so
11:32:32 <Cale> 5 is not less than or equal to 0 and the list ones doesn't match []
11:32:51 <mrd> you'd need a different data structure
11:32:51 <Cale> So  take 5 (1 : ones) = 1 : take 4 ones
11:32:58 <ketil> I even tried to variations of takeWhile .. `par` dropWhile, but no go.
11:33:20 <Cale> (and that's returned immediately)
11:33:37 <mrd> maybe make an array and index into it
11:33:46 <Cale> the take 4 ones will only be evaluated if there's a pattern match which needs to find out if that list is [] or (:)
11:34:03 <Cale> cschneid: kind of make sense?
11:34:28 <oerjan> ketil: hm... if you make sure not to look at one element of a partition until discarding the previous one...
11:34:41 <cschneid> Cale, sorta :) I'm at work where all I have is java and .net :)  I need to go home and play around some more.  Haskell is going to take some mental rearranging to really "get"
11:35:11 <Cale> Let me give an example which I give to everyone :)
11:35:19 <Cale> double x = x + x
11:35:32 <Cale> Under strict evaluation, if we evaluate double (double 5)
11:35:35 <nomeata> Hi. Given a lazy bytestring x, shoudnt (head x `cons` tail x) === x (with (LPS l1) === (LPS l2) = l1 == l2)?
11:35:37 <ketil> oerjan, I think I'm doing that.  e.g. return . map length . partitions =<< readFile "largeFile"  -- blows the heap
11:35:39 <oerjan> or at least discarding any pointers to its beginning
11:35:39 <Cale> It goes like this:
11:35:43 <Cale> double (double 5)
11:35:48 <Cale> = double (5 + 5)
11:35:52 <Cale> = double 10
11:35:55 <nomeata> That is, if I chop of a char and put it back one, cant it recognize that and save memory?
11:35:55 <Cale> = 10 + 10
11:35:56 <Cale> = 20
11:36:11 <Cale> That is, the evaluation is innermost first
11:36:19 <ketil> nomeata, probably not.
11:36:25 <nomeata> ketil: why not?
11:36:40 <ketil> nomeata, you could compare on the pointer, but I don't think it does.
11:36:42 <Cale> Under outermost-first evaluation, it goes like this:
11:36:44 <dcoutts> nomeata: it's not clear that it'd be a benefit as it involves doing extra work.
11:36:45 <Cale> double (double 5)
11:36:52 <Cale> = (double 5) + (double 5)
11:36:53 <cschneid> (double 5) + (double 5)
11:37:04 <Cale> = (5 + 5) + (double 5)
11:37:07 <Cale> = 10 + (double 5)
11:37:11 <Cale> = 10 + (5 + 5)
11:37:13 <Cale> = 10 + 10
11:37:14 <Cale> = 20
11:37:25 <nomeata> dcoutts: Im recursing over a bytestring, and putting it back to gether if I dont want changes (removing comments from a line), so in this case it helps very much
11:37:43 <Cale> Note that we duplicated the work of computing double 5 there, so lazy evaluation optimises this
11:37:43 <cschneid> but it doesn't actually figure the (double 5) part until it needs to in order to continue.  Thanks for the example Cale
11:37:49 <Cale> right
11:37:52 <hpaste>  nomeata pasted "LPS chopper" at http://hpaste.org/3438
11:38:06 <dcoutts> nomeata: and you can't just use the original in that case?
11:38:10 <cschneid> although, I should probably be back to work cranking out java code.  Rots the mind it does....
11:38:28 <nomeata> dcoutts: hmm. now that you say so  its from before I know about @ patterns, so maybe I can :-)
11:38:28 <Cale> Lazy evaluation is outermost first, but it adds sharing: if a function parameter occurs multiple times in the body, the results of evaluating it are shared between the copies.
11:38:38 <Cale> So that becomes:
11:38:42 <Cale> double (double 5)
11:38:49 <Cale> = let x = double 5 in x + x
11:38:53 <Cale> = let x = 5 + 5 in x + x
11:38:56 <Cale> = let x = 10 in x + x
11:38:58 <Cale> = 20
11:38:59 <nomeata> dcoutts: hmm. not trivially at least
11:39:09 <Cale> Which is the same number of steps as strict evaluation takes
11:39:15 <dcoutts> nomeata: well it's not trivial to do inside bytestring either :-)
11:39:27 <Cale> (really, it uses pointers)
11:39:38 <Cale> cschneid: all right, see you around
11:39:46 <cschneid> Cale, you were very helpful, thank you
11:39:49 <cschneid> I'm sure I'll be back
11:39:51 <Cale> no problem :)
11:39:54 <ketil> OhMyGodItWorks!
11:39:55 <oerjan> ketil: hm... your example is not enough - whatever _uses_ the return value needs to have the same policy
11:39:56 <nomeata> dcoutts: its not? if pointers are equal and offset1 + length1 = offset2...
11:40:03 * ketil whees!
11:40:08 * cschneid begins lurking
11:40:15 <dcoutts> nomeata: but it's extra work which only occasionally pays off
11:40:21 <kaol> @users
11:40:21 <lambdabot> Maximum users seen in #haskell: 420, currently: 393 (93.6%), active: 15 (3.8%)
11:40:55 <ketil> (I used `par` to evaluate the rest (dropWhile) in parallel with returning the first partition, compiled with -smp and ran with -N3.  To completion)
11:41:14 <mrd> -smp?
11:41:19 <mrd> is that new or old
11:41:24 <dcoutts> nomeata: I guess it doesn't strike me as an optimisation that'd pay off that often, perhaps you've got a really good example though that cannot easily be written differently.
11:41:24 <nomeata> dcoutts: hmm. I guess thats true, although I woundt be surprised if it happens in other places as well, that you split a string to make some descision and then put it back together
11:41:42 <mrd> > undefined `par` 1
11:41:44 <lambdabot>  1
11:41:55 <dcoutts> nomeata: but you shouldn't be putting the string back together using cons anyway, that'll never be fast
11:41:58 <ketil> I hereby nominate myself for this week's Hopeless Hack award.
11:42:09 <oerjan> ketil: aha, right takeWhile and dropWhile keep a common pointer until both are forced
11:42:11 <ketil> mrd: for threading.  I think perhaps it is the default now.
11:42:26 <nomeata> dcoutts: for example, when someone uses unlines . takeWhile (something) . unlines
11:42:35 <ketil> oerjan, exactly.  I *though* groupBy using span would avoid that, but it sure doesn't seem so.
11:42:59 <nomeata> dcoutts: that code was a more or less direct translation of non-bytestring code. I guess I should do index searching and the like.
11:43:08 <mrd> > map (1 `par`) [2,3,4]
11:43:09 <lambdabot>  [2,3,4]
11:43:32 <oerjan> ketil: i guess to avoid it without par you need to somehow do things in parallel yourself.  unfoldr might work.
11:43:39 * mrd wonders if par breaks parametricity like seq does
11:43:48 <dcoutts> nomeata: I'm not sure where you mean in that example, in the reconstruction of the lines
11:44:02 <oerjan> mrd: supposedly not, iirc from the other day
11:44:05 <hpaste>  ketil pasted "partitioning in parallel" at http://hpaste.org/3439
11:44:23 <sorear> mrd: par has no semantic effect at all
11:44:26 <oerjan> @src span
11:44:26 <lambdabot> Source not found. I am sorry.
11:44:36 <Tac-Tics> :t span
11:44:38 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:44:56 <ketil> http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html#span
11:44:58 <lambdabot> Title: A Tour of the Haskell Prelude, http://tinyurl.com/ywhnjx
11:45:10 <nomeata> dcoutts: considering unlines . lines, when concating the various bytestring lines, it could be detected that they are already aligned in memory, so ByteString could just return the original part of the string
11:45:20 <sorear> @go Fixing some space leaks with a garbage collector
11:45:23 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/garbage-collection.html
11:45:23 <lambdabot> Title: Wadler: Garbage collection
11:45:50 <sorear> your problem is endemic to lazy evaluators.  wadler found a hackish solution long ago, and it is implemented in GHC
11:46:01 <nomeata> dcoutts: a small example: (unlines . lines) (LPS "abc\ndef\n") woudd return LPS ("abc\n","def\n"), right?
11:46:16 <dcoutts> nomeata: right
11:46:17 <sorear> ...incorrectly: http://hackage.haskell.org/trac/ghc/ticket/1038
11:46:19 <lambdabot> Title: #1038 (selector thunks not working? space leak in standard example) - GHC - Trac
11:46:19 <nomeata> but both abc\n and def\n are part of the same ByteString
11:46:30 <sorear> ketil: what GHC version?
11:46:31 <nomeata> sharing the pointer, just differing by offset and length
11:46:42 <dcoutts> nomeata: yep
11:46:49 <nomeata> dcoutts: so if that is true, then why not return one big chunk of the original bytestring
11:47:30 <dcoutts> nomeata: because even in this case it's not that bad, it's only really bad if you're consing single chars
11:47:59 <dcoutts> nomeata: because here we have lines of non-trivial length
11:48:05 <nomeata> dcoutts: and for a large file, this would mean that (unlines  . take 1000 . lines ) is still an LPS of just one bytestring chunk, instead of 1000
11:48:10 <ketil> sorear, 6.8.0.x
11:48:27 <sorear> does it work with the HEAD?
11:48:28 <nomeata> dcoutts: sorry, what do you mean by non-trivial length?
11:48:59 <dcoutts> nomeata: I admit we've not really investigated a block coalescing strategy for lazy bytestrings yet, but that's partly because we think it's rather hard to do generally in a way that's always a benefit and not a net cost.
11:49:28 <dcoutts> nomeata: well ok you used very short lines, but if your lines are not that short then the rechunking isn't too bad.
11:49:30 <ketil> sorear, thank for the Wadler link, I'll print it and read it later.
11:49:57 <ketil> sorear, I haven't tested it with anything else, but I suspect the technique to be unreliable.
11:50:38 <dcoutts> nomeata: we've been thinking of adding a defrag or similar function for lazy bytestring that you could call explicitly to join together chunks under a certain size
11:50:39 <nomeata> dcoutts: I cant assess that, although I think one pointer comparison one int addition and one int comparison is going to be very fast, while I imagine (but this is an uneducated guess) that having a large list costs some memory and lots of time in later users of the string.
11:50:53 <dcoutts> nomeata: and that'd be the right place to stick the optimisation you're talking about
11:50:59 <nomeata> dcoutts: I agree with that
11:52:17 <nomeata> and Im going to rewrite uncomment using elemIndex :-)
12:00:14 <bakert> @pl  (\x -> x - 1)
12:00:14 <lambdabot> subtract 1
12:00:21 <bakert> @t subtract
12:00:21 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:00:32 <bakert> :t subtract
12:00:34 <lambdabot> forall a. (Num a) => a -> a -> a
12:00:44 <bakert> @src subtract
12:00:44 <lambdabot> subtract x y = y - x
12:00:54 <bakert> cunning
12:01:13 <bakert> @pl (\x -> x + 1)
12:01:13 <lambdabot> (1 +)
12:01:24 <bakert> :t (1 -)
12:01:25 <lambdabot> forall t. (Num t) => t -> t
12:01:27 <oerjan> it's there only because (- x) is not a legal section
12:01:47 <bakert> oerjan: yes (- 1) was messing up my code.  as was ((-) 1)
12:01:50 <bakert> but (+ 1) was fine
12:01:51 <bakert> i see
12:02:00 <quicksilver> hates it, we do!
12:02:11 <quicksilver> join the campaign for using ~ for unary minus
12:02:12 <bakert> it's not pretty
12:02:16 <quicksilver> or anythign else, frankly
12:02:20 <bakert> ooh that is a radical solution
12:02:30 <quicksilver> !@$%^&&* for unary minus would be fine by me
12:02:43 <quicksilver> or, perhaps, more practically, negate
12:02:46 <mauke> unary minus should be "neg". negative literals (using ~ or whatever) would be a nice bonus
12:02:47 <quicksilver> > negate 5
12:02:49 <lambdabot>  -5
12:03:00 <bakert> @src negate
12:03:00 <lambdabot> negate x = 0 - x
12:03:12 <JBGood> > (0-) 5
12:03:13 <lambdabot>  -5
12:04:05 <bakert> :t (1 -)
12:04:07 <lambdabot> forall t. (Num t) => t -> t
12:04:14 <bakert> :t (subtract 1)
12:04:16 <lambdabot> forall t. (Num t) => t -> t
12:04:27 <bakert> :)
12:04:33 <bakert> i am confusing myself now
12:04:40 <quicksilver> as mauke correctly notes, there are two issues: unary minus and negative literals
12:04:46 <bakert> 1 - x is NOT the same thing as x - 1 :)
12:05:02 <mauke> it is in {0, 1}
12:05:28 <quicksilver> what's really sad is that haskell went for this nice simple rule of all symbolic operators being infix
12:05:32 <quicksilver> and then '-' breaks it
12:05:34 <MyCatSchemes> Hrmn. Is there any way of checking whether or not a particular file happens to exist that doesn't involve attempting to open it and then catching an exception if you can't, please?
12:05:49 <mauke> MyCatSchemes: why do you need that?
12:06:11 <bos> MyCatSchemes: doesFileExist
12:06:19 <mauke> oh hello
12:06:43 <MyCatSchemes> bos: sweet, what module, please?
12:06:48 <bos> @hoogle doesFileExist
12:06:49 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
12:06:55 <sorear> MyCatSchemes: I don't know what you are trying to do but it sounds like a very very bad idea
12:06:57 <bos> (that's System.Directory)
12:07:17 <sorear> Hoogle is right - just Directory will do.
12:07:27 <MyCatSchemes> mauke: uh... what? So that I can check whether a config file exists or not in a particular standard directory, load it if it does or do nothing if it doesn't. Duh?
12:07:35 <MyCatSchemes> Seems a pretty obvious usage to me. >>
12:07:37 <bos> hoogle is half-right. Directory works, but System.Directory is preferred.
12:07:41 <mauke> MyCatSchemes: er. why do you need to check for existence then?
12:07:44 <sorear> MyCatSchemes: it's a bad idea
12:07:48 <mauke> MyCatSchemes: just open it
12:08:14 <MyCatSchemes> mauke: because playing with exceptions is a bit of pointless overkill, perhaps?
12:08:18 <sorear> MyCatSchemes: don't ask for race conditionsa
12:08:35 <mauke> MyCatSchemes: you have to catch exceptions anyway
12:08:59 <mauke> you could get EPERM or ENFILE or whatever
12:08:59 <MyCatSchemes> sorear: uhuh. I don't really care about that possibility in the case of a userspace non-priviledged daemon.
12:09:03 <sorear> MyCatSchemes: What if the user deletes the file after the doesFileExists but before the open?  That's right, your daemon crashes.
12:09:12 <mauke> and even ENOENT because someone can remove the file between doesFileExist and openFile
12:09:15 <sorear> denial of service!
12:09:36 <quicksilver> MyCatSchemes: the point is, it isn't even simpler :) It's just as simple to go ahead and open the file...
12:09:43 <mauke> in conclusion, doesFileExist doesn't buy you anything and makes your code more complex
12:10:06 <MyCatSchemes> sorear: I can't really envisage somebody a) having access to that file (it's a config file, for chrissake, I don't set those a+rw!) and b) being dumb or malicious enough to delete the config file *just* after starting the daemon.
12:10:27 <oerjan> :t catch
12:10:28 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
12:10:43 <mauke> no one will ever enter more than 200 characters in a single line so gets() is perfectly safe
12:11:01 <mrd> sometimes you just want to check if a file exists without reading it, too
12:11:04 <oerjan> except that using catch is not really more difficult than using doesFileExist + open
12:11:44 <MyCatSchemes> sorear: do I even care? That's not a denial of service, I'm not going to let somebody else have write permission on my config files - and if I do, I've got much bigger problems than whether the daemon crashes or not. :P
12:12:42 <oerjan> catch (fmap Just $ readFile f) (const Nothing)
12:12:43 <sorear> MyCatSchemes: I find it alarming that you mention write permission on config files.  That has nothing to do with deletability on UNIX
12:12:44 <MyCatSchemes> Hrmn. You can safely hClose() a handle that might not have been successfully opened, right?
12:13:02 <MyCatSchemes> sorear: if the file isn't deletable, how else is it going to be deleted?
12:13:12 <MyCatSchemes> sorear: magic filesystem pixies are going to invade my machine?
12:13:12 <mrd> () /:: Handle
12:13:17 <sorear> MyCatSchemes: When is a file deletable?
12:13:48 <mauke> how can you get a handle that wasn't opened?
12:13:56 <MyCatSchemes> sorear: when somebody who wants to delete it has write access to it.
12:14:01 <mauke> MyCatSchemes: wrong
12:14:10 <MyCatSchemes> When else, then?
12:14:24 <mauke> when the directory it is in is writable
12:14:28 <sorear> MyCatSchemes: not 'else', just plain wrong.  you can delete a 000 file
12:14:42 <ben> More like when all directories it is in are writable. <:)
12:14:44 <mauke> unlink() is an operation on the filename, which is part of a directory
12:14:52 <MyCatSchemes> sorear: sure thing, if your UID is the owner's or if you're root.
12:15:09 <mauke> MyCatSchemes: no, if you have write access to the directory
12:15:15 <MyCatSchemes> And if /etc is world-writable, or if an attacker has cracked my account, or rooted my box, then I'm already screwed.
12:15:34 <MyCatSchemes> mauke: duh, but if an attacker has write access to /etc, I'm already boned.
12:15:42 <MyCatSchemes> s/duh/yes/
12:15:51 <mauke> stop defending yourself and just write the right code
12:16:00 <MyCatSchemes> Who cares? Daemons crashing is the least of my problems at that point. :P
12:16:18 <mauke> I care, because the code will suck
12:16:26 <MyCatSchemes> mauke: I'm writing it anyway, but I still think worrying about a race condition on a config file is stupid.
12:16:44 <MyCatSchemes> Or, at the very minimum, blazingly overparanoid.
12:16:46 <mauke> then you shouldn't be allowed to write daemons
12:17:01 <bakert> alright children!  enough!
12:18:07 <bakert> what about: "hmmm, you could use doesFileExist but i think you might be better off handling possible exceptions if you want maximally robust code - ... etc."
12:18:11 <bakert> ?
12:18:51 <MyCatSchemes> mauke: would you like me to check for symlinks too while I'm at it? And perhaps I should make sure my executable isn't suid-anything? And perhaps I should check the permissions on /tmp while I'm at it?
12:19:04 <mauke> MyCatSchemes: no, just open the file and check for errors
12:19:05 <ben> No, you just catch exceptions >:[
12:20:16 <bakert> @seen omnid
12:20:16 <lambdabot> I saw omnid leaving #haskell 10h 59m 44s ago, and .
12:20:19 <MyCatSchemes> But there are dozens of race-condition attacks that work by hoodwinking the target via a symlink. That's no more less likely to happen than someone trying to DOS my program by unlinking its config files.
12:20:42 <quicksilver> the point is more that 'check-then-do' is a broken idiom
12:20:47 <ben> MyCatSchemes: Such as?
12:20:48 <quicksilver> so it's best simply to be out of the habit of doing it
12:21:19 <quicksilver> because although check-then-do may not cause you a problem in this particular case, it's important to understand why it's a poor idiom
12:21:26 <quicksilver> especially when the better approach is no harder to write
12:22:08 <quicksilver> check-then-do is only appropriate when you have something like 'atomically' or 'block the whole world' up your sleeve
12:22:09 <oerjan> catch (readFile f) (const "") -- anything wrong with just this?
12:22:10 <MyCatSchemes> ben: can't be arsed to look the lot up. They're well documented.
12:22:11 <mauke> MyCatSchemes: if your program isn't setuid, symlink "attacks" don't gain you anything
12:22:14 <quicksilver> like transactional dbs or stuff
12:23:06 <mauke> MyCatSchemes: my point is simply that open + check result is the obvious Right Thing to do, and anything else will make the code suck
12:23:13 <mauke> and I don't care about people, only code
12:24:11 * MyCatSchemes writes it with catch.
12:24:16 <oerjan> :t catch (readFile f) (const $ return "") -- apart from the type
12:24:22 <lambdabot> Not in scope: `f'
12:24:28 <oerjan> :t catch (readFile ?f) (const $ return "") -- apart from the type
12:24:30 <lambdabot> (?f::FilePath) => IO String
12:24:41 <MyCatSchemes> Only one thing. I'm going to write it backwards with =<< instead of >>=, just to register frustration. ;)
12:25:08 <mauke> ben: let's say you have a suid program that reads data from a file. if you can replace the filename by a symlink to e.g. /etc/shadow you can get data from files you normally aren't allowed to read
12:25:38 <mauke> it gets worse if the suid program writes to a location that can be controlled by the user
12:26:03 <ben> Should the suid program not drop down to user privileges to do that?
12:26:29 <mauke> yes, probably
12:26:48 <mauke> it doesn't even have to be suid
12:26:54 <sieni> or no? :-)
12:27:06 <mauke> it could be a daemon running under a different uid
12:27:14 <MyCatSchemes> Just has to be priviledged - root or wheel or someone with a uid that has a lot of access.
12:28:15 <mauke> if that daemon supports user config files, a user could ln -s /etc/shadow ~/.config.rc
12:29:17 <sieni> what are you discussing?
12:29:39 <sieni> too long backlog to get a good overview
12:30:35 <mauke> symlink attacks on unsuspecting programs (discussion triggered by an attempt to use doesFileExist before openFile to check for success)
12:33:45 <quicksilver> another good symlink attack is to trick a program into writing something into .ssh
12:33:50 <quicksilver> you can do pretty evil things that way
12:35:02 <newsham> hmm.. did a bunch of languages get faster than haskell?  http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
12:35:04 <lambdabot> Title: Create your own Ranking | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/lepfo
12:35:17 <newsham> ghc is still listed as 1.9x, but now there are lots in between gcc and haskell
12:37:06 <sieni> mauke: could you give an example?
12:37:32 <mauke> again? :/
12:37:35 <Igloo> That's an interesting graph. I wonder if the 3 sections relate to whether optimisation effort has been spent, or features of the languages (e.g. interpreters vs compilers)
12:38:04 <sorear> the GCLS is harmful to your health
12:39:42 <sieni> mauke: or do you mean the problems that can occur if you don't follow the standard practice in a suid root program to fork() and setuid() appropriately before accessing user files?
12:40:48 <mauke> http://www.infosecwriters.com/texts.php?op=display&id=159
12:40:50 <lambdabot> Title: Infosecwriters.com
13:00:19 <KatieHuber> Igloo: well, the first section are all compiled or JIT-compiled AFAIK, the second section are all interpreted or byte-code compiled then interpreted AFAIK, and the third section are just lazy ;)
13:00:29 <alexj> looking at the benchmarks.  it seems like haskell benchmarks as twice as more verbose as ruby/python.  but subjectively, I feel like it is more expressive.
13:01:28 <Igloo> alexj: I don't know what it's like now, but it certainly used to be the case that there was some ugly Haskell to hack around performance bugs
13:02:54 <kscaldef> I wonder why certain benchmarks aren't included in the default ranking
13:04:50 <alexj> igloo: ah ok.  premature optimization and all that.    also reading the code, it has type annotations that are unnecessary (should be exluded as comments).  and the tree code could be reduced to 1/5th using modern SYB techniques.
13:05:20 <sjanssen> alexj: won't SYB absolutely kill performance?
13:05:49 <alexj> sjanssen: don't k know.  I care less about performance than expressivity.  optmize only where necessary.
13:06:08 <kscaldef> alexj: I think the point is that they weren't premature optimizations in this case.  Older, simpler implementations were considerably slower
13:06:11 <sjanssen> alexj: the shootout entries are optimized for speed over beauty
13:06:26 <alexj> sjanssen: yeah, i got that.
13:06:32 <kscaldef> what's SYB?
13:06:38 <bakert> Scrap Your Boilerplate
13:07:03 <bakert> @google scrap your boilerplate peyton jones
13:07:05 <lambdabot> http://www.cs.vu.nl/boilerplate/
13:07:05 <lambdabot> Title: Scrap your boilerplate ... in Haskell
13:07:09 <kscaldef> so, same as DRY, or something else?
13:07:25 <alexj> sjanssen: I assume that SYB will eventually get optimizations put in. .  also better typechecking.
13:07:42 <bakert> it's a way of getting rid of code to traverse data structures and just write the operations.  i think.  i read the paper a while ago.
13:08:15 <alexj> SYB is what HAppS uses to infer XML representations for haskell data types.
13:09:21 <bakert> kscaldef: it does sound like a "call to arms" rather than an implementation of a specific idea i grant you.
13:09:35 <bakert> does anyone understand functional references?
13:12:54 <oerjan> bakert: a particular implementation or the general idea? (the latter is just bundling a getter and a setter somehow, isn't it?)
13:13:09 <bakert> i have an implementation by omnid
13:13:15 <bakert> but i'm trying to do something clever with it
13:13:20 <bakert> and it isn't working :(
13:13:24 <omnId> hello bakert :)
13:13:31 <bakert> ooh!  cool!
13:13:43 <bakert> so, this functional references thing.  very nice.
13:13:56 <bakert> do you remember when we were implementing invert?
13:14:02 <bakert> invert x = apply (20 -) x
13:14:04 <omnId> It's twan's thing.  I just copy/pasted :)
13:14:08 <bakert> apply f r = ref (f . get r) (set r . f)
13:14:09 <omnId> yeah
13:14:25 <bakert> that is meant to work with "update" as well as to read values, right?
13:14:38 <omnId> It should
13:14:41 <bakert> up r = invert down r
13:14:50 <bakert> update up (+ 1) r
13:15:19 <bakert> Couldn't match expected type `FRef s a'
13:15:19 <bakert>            against inferred type `Traits -> Int'
13:15:24 <bakert> (Traits is the record type)
13:15:33 <bakert> any idea why that might be?
13:15:49 <bakert> i think the definition of invert/apply must be slightly wrong
13:15:53 <omnId> do you ever use just 'up' where you could have used 'get up'?
13:16:04 <omnId> elsewhere?
13:16:11 <bakert> yes
13:16:18 <bakert> is that bad?
13:16:26 <Saizan> why does the definition of up take an argument?
13:16:27 <omnId> how is up defined?
13:16:36 <omnId> er, wait, nevermind :)
13:16:39 <sieni> mauke: ok, so this is pretty basic stuff (that you shouldn't do user file io without fork() and setuid() and setgid()ing)
13:16:45 <omnId> bakert: do :t up
13:16:58 <bakert> :: (Ref r[a3Fa]) => r[a3Fa] Traits Int
13:17:10 <bakert> but down
13:17:11 <bakert> :: Traits -> Int
13:17:22 <bakert> sorry, reverse that
13:17:27 <bakert> from the example above
13:17:44 <omnId> oh, try adding an annotation 'up :: Ref r => r Traits Int'
13:17:44 <bakert> the one that is defined by the functional references codes is
13:17:50 <bakert> :: (Ref r[a3Fa]) => r[a3Fa] Traits Int
13:18:02 <bakert> the one that is defined with invert and apply is
13:18:09 <bakert> :: Traits -> Int
13:18:49 <omnId> bakert: update requires an FRef Traits Int
13:19:16 <omnId> Ref r => r Traits Int includes both FRef and (->) in the Ref class.
13:19:31 <omnId> try adding a 'up :: Ref r => r Traits Int' annotation.
13:20:06 <Saizan> bakert: the problem is that you've eta-expanded up = invert down, forcing the -> instance for Ref
13:20:29 <omnId> oh, duh, I told him to do that and it was wrong :)
13:20:40 <bakert> up r = invert down r
13:20:57 <bakert> is not eta-expanded
13:20:58 <bakert> ?
13:21:07 <omnId> it is
13:21:10 <bakert> oh.
13:21:17 <omnId> the r on boths sides shows that.
13:21:34 <bakert> oh i see.  i was thinking "eta expanded" meant "eta reduced" :)
13:21:43 <bakert> i just saw the magic word "eta"!
13:21:45 <bakert> :)
13:21:52 <omnId> (:
13:22:30 <omnId> bakert: perhaps it'd be simpler to get rid of the polymorphic bits and use FRefs directly.
13:22:41 <bakert> wicked.  with the type annotation and eta reduction it works great.
13:22:45 <bakert> thanks folks :) :) :)
13:23:40 <bakert> now if someone can just change how (- 1) is interpreted everything will be perfect :)
13:23:56 <omnId> > (subtract 1) 5
13:23:58 <lambdabot>  4
13:24:21 <bakert> yeah ... someone helped me out with that one earlier.  but i've been officially inducted into the cult of people who don't like it :)
13:24:46 <omnId> you'd rather use negate for your negative numbers?  :P
13:25:38 <oerjan> as for the ~ mentioned, that already means lazy pattern matching
13:25:40 <bakert> no i'd rather the magic haskell fairy god worked out what i meant each time :)
13:26:01 * oerjan blinks
13:26:20 <omnId> Sacrifice for the Glory of the Holy GHC!
13:26:26 <roconnor> > (- 1) 2
13:26:27 <lambdabot>   add an instance declaration for (Num (t -> a))
13:26:27 <lambdabot>     In the expression: (- 1)...
13:27:14 <oerjan> you _might_ be able to define that instance (that's why i blinked)
13:27:19 <omnId> instance Num a => Num (a -> a) where fromInteger x = subtract (negate x)
13:27:40 <ToXedVirus> how do i convert a double to a integer?
13:27:50 <roconnor> @type floor
13:27:52 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:28:01 <oerjan> @src RealFrac
13:28:02 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
13:28:02 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
13:28:03 <omnId> @src RealFrac
13:28:03 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
13:28:05 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
13:28:07 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
13:28:09 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
13:28:10 <roconnor> @type (const 0)
13:28:12 <lambdabot> forall t b. (Num t) => b -> t
13:28:13 <omnId> oopsies
13:28:38 <oerjan> ToXedVirus: with those :)
13:29:03 <oerjan> @quote stereo
13:29:03 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
13:29:23 <omnId> @quote metastereo
13:29:24 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
13:30:05 <ToXedVirus> mmkey, thanks
13:30:59 <Taejo> @src sequence
13:30:59 <lambdabot> sequence ms = foldr k (return []) ms
13:31:00 <lambdabot>     where
13:31:00 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
13:31:25 <mauke> sequence = foldr (liftM2 (:)) (liftM0 [])
13:31:40 <omnId> liftM0? :)
13:31:45 <oerjan> that one really should be in Applicative :)
13:31:48 <mauke> it's called "return" for some reason
13:31:51 <ToXedVirus> im too stupid to make it work
13:31:59 <Taejo> > sequence [1, 2, 3]
13:32:00 <lambdabot>   add an instance declaration for (Show (m [a]))
13:32:02 <oerjan> > truncate 1.2
13:32:04 <omnId> > floor (3.8)
13:32:08 <lambdabot>  3
13:32:08 <lambdabot>  1
13:32:25 <Taejo> @type sequence
13:32:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:32:40 <omnId> > sequence [Just 1, Just 2]
13:32:42 <lambdabot>  Just [1,2]
13:32:44 <ToXedVirus> 2.5 - (round 2.5)
13:32:50 <Taejo> @src pure
13:32:50 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:32:55 <mauke> > 2.5 - round 2.5
13:32:56 <lambdabot>  Add a type signature
13:32:56 <omnId> > sequence [[1], [2,3], [4,5]]
13:32:57 <lambdabot>  [[1,2,4],[1,2,5],[1,3,4],[1,3,5]]
13:33:06 <ToXedVirus> print (2.5 - (round 2.5))
13:33:12 <mauke> ToXedVirus: that doesn't work because 2.5 isn't an integer
13:33:22 <ToXedVirus> so i have to convert it back to a double
13:33:23 <oerjan> ToXedVirus: the result before and after round doesn't have the same type
13:33:39 <omnId> fromIntegral
13:33:40 <Taejo> ahh omnId, so sequence == product for lists?
13:33:45 <oerjan> @quote fromIntegral
13:33:45 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
13:33:57 <ToXedVirus> great success
13:34:11 <ToXedVirus> thanks dudes
13:34:17 <omnId> > sequence [id, (+3), (/2)] 4
13:34:19 <lambdabot>  [4.0,7.0,2.0]
13:34:47 <oerjan> :t foldr (liftA2 (:)) (liftA0 [])
13:34:48 <lambdabot> Not in scope: `liftA0'
13:34:54 <mauke> > properFraction 2.5
13:34:55 <lambdabot>  (2,0.5)
13:35:01 <oerjan> :t foldr (liftA2 (:)) (pure [])
13:35:03 <lambdabot>     Ambiguous occurrence `pure'
13:35:03 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
13:35:41 <omnId> :t foldr (liftA2 (:)) (Control.Applicative.pure [])
13:35:43 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [f a] -> f [a]
13:36:43 <oerjan> lots of things in Control.Monad that could be generalized. sequence_, mapM, mapM_
13:37:46 <omnId> but since Monad doesn't inherit Applicative they can't be put in just the one place :/
13:37:57 <oerjan> not yet
13:38:23 <oerjan> for now, some aren't in both either
13:38:26 <omnId> you have plans?  :)
13:38:43 <oerjan> it seems like an obvious thing to do ones class aliases arrive
13:38:47 <oerjan> *once
13:39:46 <oerjan> and >> too
13:40:13 <oerjan> :t ((>>),(*>))
13:40:15 <lambdabot> forall (m :: * -> *) a b (f :: * -> *) a1 b1. (Monad m, Applicative f) => (m a -> m b -> m b, f a1 -> f b1 -> f b1)
13:40:49 <ToXedVirus> can you give me a site with all the default functions of haskell?
13:40:54 <omnId> @docs
13:40:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:40:59 <omnId> check the Prelude
13:41:05 <oerjan> @where prelude
13:41:05 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
13:41:29 <omnId> ^ that's the spec, ghc's Prelude docs are:
13:41:30 <omnId> @docs Prelude
13:41:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
13:44:14 * oerjan thinks the _majority_ of Control.Monad's functions generalize to Applicative
13:44:44 <omnId> how many actually require the joining behavior of bind?
13:46:16 <omnId> many of the fooM functions just add a sequence on their non-M counterparts.
13:46:17 <oerjan> lessee, >>=, =<<, join, foldM, foldM_
13:47:35 <twanvl> Also, guard and fail, but for a different reason
13:47:56 <oerjan> those could work with Alternative
13:47:57 <omnId> guard needs MonadPlus anyway
13:48:33 <omnId> does Alternative have a zero? /me checks
13:48:40 <twanvl> yes
13:49:07 <omnId> I see.
13:50:29 <oerjan> also msum
13:50:39 <oerjan> (could work with Alternative)
13:51:07 <omnId> is (<|>) left-catch or left-distributive?  Does it specify?
13:51:46 <twanvl> "An associative binary operation"
13:52:03 <newsham> alexj: the benchmark used to count lines of code excluding comments but shifted towards some compressed size metric
13:52:20 <newsham> so ghc used to get much better source code size metrics
13:52:44 <twanvl> It doesn't specify, and recently I started having doubts whether it should be specified at all
13:52:45 <alexj> newsham: they measure gzip of the code after eliminating continuous whitespace.
13:52:49 <newsham> but i think the compressed size metric is more fair.  also like you mentioned, lots of (premature) optimizations
13:53:16 <newsham> i guess everyone wanted to win on speed
13:53:24 <kilimanjaro> speed is the only meaningful metric
13:53:30 <kilimanjaro> well, memory use too
13:53:34 <kilimanjaro> but the size is meaningless
13:54:21 <kilimanjaro> it's too dependent on the particular language. really the most important real-world characteristic is development time, and I don't think this is really adequately expressed using even the compressed size metric
13:54:47 <newsham> speed is the most important metric.
13:54:50 <newsham> programmer speed, of course.
13:55:16 <omnId> > unwrapMonad $ WrapMonad [1,2,3] <|> WrapMonad [4,5]
13:55:17 <lambdabot>  [1,2,3,4,5]
13:56:38 <kilimanjaro> newsham, well the bottom line is that money is the most important metric, you want net revenue, that means reducing development cost and increasing value, if you are working on software where maximizing application speed generates value then it might be more important than trying to reduce programmer speed
13:56:43 <twanvl> omnId: <|> is most often used by parser libraries, and different libraries use it for different things
13:57:17 <newsham> money sometimes refered to as "the bottom line"
13:57:20 <newsham> go figure
13:58:28 <bakert> So now I have 13 functions like this:
13:58:52 <bakert> up :: :: Ref r => r Traits Int
13:59:00 <bakert> up = invert down
13:59:02 <Taejo> I'm thinking that (foldr (:)) == (++), but quickcheck says I'm mistaken. Can anyone explain?
13:59:27 <bakert> can i use template haskell or something similar to generate them from a list of pairs or similar?
13:59:44 <twanvl> > foldr (:) "123" "456"
13:59:47 <lambdabot>  "456123"
13:59:48 <ari> :t foldr (:) []
13:59:51 <lambdabot> forall a. [a] -> [a]
13:59:54 <sjanssen> Taejo: flip (foldr (:) [])
14:00:00 <omnId> @check (\xs ys -> flip foldr (:) xs ys == xs ++ ys) :: [Int] -> [Int] -> Bool
14:00:01 <lambdabot>  Couldn't match expected type `a
14:00:03 <Heffalump> no, flip (foldr (:)
14:00:08 <Heffalump> with a closing paren
14:00:13 <omnId> @check (\xs ys -> flip (foldr (:)) xs ys == xs ++ ys) :: [Int] -> [Int] -> Bool
14:00:14 <twanvl> ?check \a b -> foldr (:) a b == (b ++ a :: [Int])
14:00:14 <lambdabot>  OK, passed 500 tests.
14:00:15 <sjanssen> oh, right
14:00:15 <lambdabot>  OK, passed 500 tests.
14:00:16 <omnId> silly me
14:00:35 <sieni> Taejo: it's (flip (++)) no (++)
14:00:49 <idnar> :t foldr (:)
14:00:50 <Taejo> yeah, I see that, but I don't understand
14:00:51 <lambdabot> forall a. [a] -> [a] -> [a]
14:00:53 <idnar> :t (++)
14:00:55 <lambdabot> forall a. [a] -> [a] -> [a]
14:01:10 <omnId> foldr (:) xs ys -- puts xs at the nil at the end of ys
14:01:52 <Heffalump> Taejo: foldr f e xs replaces all the (:) in xs with f, and the [] in xs with e
14:02:13 <Heffalump> So foldr (:) ys xs will replace the [] in xs with ys.
14:02:20 <Taejo> aah... I had the order of arguments wrong
14:02:24 <bakert> it just seems very wasteful to give over 39 lines of code to something that is effectively 13 (maybe 26) pieces of information.
14:02:32 <Taejo> I thought it was foldr f xs e
14:03:38 <bakert> opposites [('up, down), ('left, right), ('good, evil), ('hot, cold)]
14:03:41 <bakert> that would be nice
14:03:46 <bakert> hmm
14:04:25 <omnId> [up, left, good, hot] = map invert [down, right, evil, cold]
14:04:57 <Taejo> so mapa f xs ys = foldr ((:) . f) ys xs
14:05:19 <Taejo> where mapa f xs ys == (map f xs) ++ ys
14:10:42 <notyouravgjoel> haskell error messages are awfullly confusing
14:12:12 <omnId> notyouravgjoel: any one in particular you have a question about?
14:14:20 <notyouravgjoel> I figured the one out. I was going to ask about it; it was complaining about the wrong place, I believe. I have a new one -- ill pastebin
14:14:35 <bakert> is template haskell part of haskell prime?  going to be a core language feature i mean?
14:15:24 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3440
14:15:26 <dons> > ' -- is ok, I think
14:15:26 <lambdabot>  Improperly terminated character constant
14:15:35 <notyouravgjoel> (that one is me)
14:15:39 <dons> > {- seems reasonable
14:15:40 <lambdabot>  Unterminated nested comment
14:15:57 <dons> ah, hugs
14:16:20 <dons> so you're applying a number to some arguments, I think
14:16:32 <dons> the giveaway is that it thinks you want a Num(ber)
14:16:39 <omnId> notyouravgjoel: mod takes two arguments, not a pair.
14:16:43 <dons> of function type
14:16:46 <omnId> mod num prime
14:16:54 <dons> yep. that's the one
14:16:56 <dons> :t mod
14:16:59 <lambdabot> forall a. (Integral a) => a -> a -> a
14:17:10 <dons> arguments to functions in haskell aren't wrapped in parens and commas
14:17:16 <dons> > mod 5 2
14:17:18 <lambdabot>  1
14:17:29 <dons> > mod(5,2) -- wrong language
14:17:30 <lambdabot>   add an instance declaration for (Integral (t, t1))
14:17:30 <lambdabot>     In the expression: m...
14:17:46 <dons> > (1,2) -- a pair
14:17:47 <lambdabot>  (1,2)
14:17:59 <dons> > fst (1,2) -- messing with a pair
14:18:00 <lambdabot>  1
14:19:24 <sorear> bakert: I hope not.  Template Haskell is huge, ugly, and essentially forces any compiler to adopt most of GHC's design decisions.  It would have a terrible chilling effect on Haskell compilation technology.
14:19:35 <notyouravgjoel> so how does one define a function that accepts multiple parameters?
14:20:01 <omnId> checkprime num primes = all (\x p -> mod x p /= 0) primes
14:20:26 <omnId> checkprime num primes = all (\p -> mod num p /= 0) primes -- oops :)
14:20:34 <iank> :)
14:21:11 <omnId> notyouravgjoel: like that, just seperate parameters by a space.
14:21:37 <quicksilver> sorear: do you have a vision of how a meta-haskell might look which would be beautiful?
14:22:01 <sorear> quicksilver: No.
14:22:08 <quicksilver> no, me neither
14:22:09 <quicksilver> shame :)
14:22:17 <bakert> sorear: so you don't use TH?
14:22:22 <quicksilver> haskell's just got a bit too much syntax, methinks :(
14:22:27 <sorear> bakert: I try not to
14:22:34 <notyouravgjoel> wow
14:22:49 <quicksilver> of course there are less encompassing metaprogramming techniques for particular problems
14:22:53 <omnId> notyouravgjoel: hm?
14:22:59 <quicksilver> deriving Typeable is pretty powerful on its own
14:23:05 <sorear> Ideally we don't have a metasystem at all.  Syntactic abstraction is to semantic abstraction what chicken wire is to rivets.
14:23:11 <notyouravgjoel> this is just very different
14:23:13 <notyouravgjoel> =)
14:23:20 <quicksilver> Uniplate is very nice looking and solves one class of problems well
14:23:32 <omnId> notyouravgjoel: indeed :)  Are you going through a tutorial?
14:23:45 <notyouravgjoel> yes, but this isnt exactly part of the tutorial
14:24:27 <quicksilver> sorear: that's a rather nice quote
14:24:37 <sorear> We already have very powerful semantic abstraction.  Expression-level hygenic macros with dynamic arguments are fully covered by laziness and HOAS.
14:25:01 <sorear> ... thank you?
14:25:19 <quicksilver> @remember sorear Ideally we don't have a metasystem at all.  Syntactic abstraction is to semantic abstraction what chicken wire is to rivets.
14:25:19 <lambdabot> I will never forget.
14:25:28 <sorear> lies
14:26:57 <quicksilver> even without fully syntactic abstraction, compile-time processing is nice
14:27:06 <quicksilver> e.g. to define a data type based on a DB schema
14:27:07 <quicksilver> etc
14:27:28 <bakert> omnId: woah, [up, left, good, hot] = map invert [down, right, evil, cold]
14:27:31 <bakert> i can do that?
14:27:47 <omnId> bakert: the type signature might be hairy, but yes :)
14:27:56 <bakert> oh lord
14:28:04 <omnId> it's just an ordinary pattern binding
14:28:21 <oerjan> might get in trouble with the Dreaded MR
14:28:46 <omnId> in other words, you'll need a signature.
14:28:47 <oerjan> since that is one case where you _cannot_ use a type signature to circumvent it
14:28:49 <bakert> omnId: for some reason i have never taken in that i can do that with function definition
14:29:20 <bakert> oerjan, omnId: i currently have 13 type signatures.  so as long as i can work it out that seems fine!
14:29:21 <bakert> :)
14:29:29 <omnId> > let Just x = lookup 2 [(1,'a'),(2,'b'),(3,'c')] in x
14:29:40 <lambdabot>  'b'
14:30:00 <bakert> oh god where do i start? :)
14:30:19 <bakert> the type of one of the functions is
14:30:19 <bakert> Ref r => r Traits Int
14:30:33 <quicksilver> bakert: I quite often do stuff like [foo,bar,baz] <- mapM mkSomething ["foo","bar","baz"]
14:30:51 <oerjan> > let Just x = lookup 'a' [('a',1),('b',2),('c',3)]; x :: Num a => a in x
14:30:52 <lambdabot>      Cannot match a monotype with `forall a. (Num a) => a'
14:30:52 <quicksilver> bakert: where 'mkSomething' is, perhaps, an IO action allocating an OS resource like a graphics card texture
14:30:52 <lambdabot>       Expected typ...
14:30:52 <bakert> gah.  i don't even understand how to go about it.  i think i will make a simple non-functional-references example of multiple functions first
14:30:59 * fasta hands a cycle escape to quicksilver 
14:31:34 <oerjan> see, no type signature allowed
14:32:07 <omnId> bakert: the signatures would all be unneccessary if I got rid of the polymorphic part of the funref thing, i.e. just use ordinary FRefs instead of being polymorphic in Ref r.  Would you like me to give you a simplified version of FRef.hs?
14:32:36 <bakert> What does that actually mean?  That FRef.hs would be fixed to work only on my Traits and not a general lib any more?
14:32:45 <bakert> Or something less horrible than that?
14:32:49 <bakert> :)
14:32:53 <omnId> bakert: much less horrible :)
14:32:57 <bakert> oh good.
14:33:14 <bakert> So forgive me if this is a bit rude but how come you didn't do it like that in the first place?
14:33:15 <bakert> :)
14:33:22 <omnId> bakert: it means that up, down, allaround :: FRef Traits Int instead of :: Ref r => r Traits Int
14:33:30 <bakert> Is there some advantage to having it the way it is now?
14:33:55 <omnId> bakert: you can use, for example, up as an ordinary function and it'll behave like 'get up'.
14:34:08 <omnId> seems a small win for such headaches :)
14:34:11 <bakert> ooh i need that :)
14:34:22 <bakert> no let's do it the hard way!
14:34:27 <bakert> and have perfection!
14:34:32 <omnId> oh, okay then :D
14:34:51 <bakert> ok so starting from the basics
14:34:54 <bakert> :t [a, b, c] = map putStrLn ["hello", "there", "dude"]
14:34:56 <lambdabot> parse error on input `='
14:34:59 <bakert> oop
14:35:03 <bakert> > let x = [a, b, c] = map putStrLn ["hello", "there", "dude"]
14:35:03 <lambdabot>  Parse error
14:35:06 <bakert> erm
14:35:13 <bakert> ok ... the basics have confounded me!
14:35:22 <omnId> let [...] = map f [...] in (...)
14:35:47 <bakert> i can see the type of a or b or c really easily
14:35:51 <bakert> but what do i write above
14:35:52 <bakert> [a, b, c] = map putStrLn ["hello", "there", "dude"]
14:35:56 <bakert> for a type signature?
14:36:10 <omnId> it seems, though, that adding a signature might not be possible, as oerjan said :(
14:36:16 <bakert> ah
14:36:18 <bakert> so i'm in
14:36:26 <bakert> -fno-monomorphism-restriction land?
14:37:40 <omnId> try it and cross your fingers
14:38:20 <bakert> is it bad to enter that realm?
14:38:31 <xelxeba1> x11-extras is complaining about "Could not find module `Graphics.X11.Xlib.Misc'", was a relevant notice sent out on the mailing list?
14:38:39 <dmwit> bakert: No, you can do it without that realm!
14:38:48 <hpaste>  notyouravgjoel pasted "(no title)" at http://hpaste.org/3441
14:38:48 <dmwit> a, b, c :: IO ()
14:39:06 <oerjan> dmwit: he is not speaking about that example, really
14:39:06 <bakert> aha!  .. I tried [a, b, c] :: [IO ()] :(
14:39:14 <notyouravgjoel> I'd appreciate any help if possible =)
14:39:27 <sjanssen> xelxeba1: have you installed X11?
14:39:40 <dmwit> > let a, b, c :: IO (); [a, b, c] = map putStrLn ["hey", "there", "joe"] in 3 -- typechecks?
14:39:45 <lambdabot>  3
14:39:46 <omnId> twanvl: are you watching?  The polymorphic bit of the funrefs seems to be quite a hassle with the MMR.  :(
14:39:58 <bakert> oerjan: can't i copy dmwit's ideas over to the more complicated function(s)?
14:40:11 <shachaf> sjanssen: Probably, otherwise it'd complain at the configure stage.
14:40:15 <xelxeba1> sjanssen: yes
14:40:19 <oerjan> bakert: dmwit's case works because that type has no type class restriction
14:40:26 <shachaf> xelxeba1: What version?
14:40:39 <dmwit> bakert: What is the more complicated function?
14:40:48 <oerjan> so the MR does not apply
14:41:27 <Taejo> My brief experiments show that `foldr (++) [] xss` does not take quadratic time. Is this because of fusion rules?
14:41:47 <twanvl> omnId: bah, the DMR must die!
14:41:49 <omnId> > let [x,y,z] = [1,2,3] ; x,y,z :: Num a => a in [x,y,z] -- trying to add a typeclass polymorphic type to already-bound definitions doesn't work so well.
14:41:50 <lambdabot>      Cannot match a monotype with `forall a. (Num a) => a'
14:41:50 <lambdabot>       Expected typ...
14:42:06 <bakert> dmwit: [up, left] = map invert [down, right] -- where down :: (Ref r) => r Traits In
14:42:16 <bakert> s/In/Int/g
14:42:27 <xelxeba1> shachaf: not sure, 1.0.3?
14:42:28 <sjanssen> Taejo: "foldr (++) [] xss" is linear wrt. the total number of elements in the result list
14:42:52 <Beelsebob> how bizare
14:42:53 <Taejo> sjanssen, so I see, and I'm impressed. To what do I owe this feat?
14:43:03 <Beelsebob> I have a function that causes a stack overflow when compiled
14:43:05 <twanvl> I think pattern bindings are always monomorphic, at least in recent GHCs
14:43:06 <omnId> bakert: the (Ref r) => context is what causes to Dreaded Monomorphism Restriction.  As you can see in the [x,y,z] thing I did.  It just doesn't work.
14:43:06 <sorear> Taejo: fold *right*
14:43:09 <vincenz> @seen augustss
14:43:09 <lambdabot> augustss is in #haskell. I last heard augustss speak 21h 21m 53s ago.
14:43:11 <sjanssen> Taejo: laziness
14:43:14 <Beelsebob> but when run in ghci runs instantly
14:43:16 <sorear> Taejo: a ++ b takes time length a
14:43:18 <shachaf> xelxeba1: You ned >=1.2.1, no?
14:43:38 <sorear> sjanssen: no, it would exhibit time O(n) in SML too
14:43:48 <sjanssen> xelxeba1: we're talking about the Haskell package called X11, not X.org
14:43:52 <bakert> omnId: i see.  so Ref r means anything that implements Ref.  but monomorphism restriction says "nope you must tell me what types you are really using"
14:44:03 <bakert> not just a class of types.
14:44:04 <bakert> ??
14:44:05 <shachaf> Oh, sorry.
14:44:10 <dmwit> bakert: Oh, yeah, that's a bit different.
14:44:16 <bakert> :)
14:44:24 <omnId> bakert: the monomorphism restriction says that if you have a typeclass-polymorphic pattern binding, it must default to one type.
14:44:30 <xelxeba1> sqanssen: ah, okay, 1.2.3
14:45:02 <bakert> omnId: so could i just tell it to use a particular type in my client code but leave your library general.  or is that a nonsensical idea?
14:45:08 <sjanssen> xelxeba1: try cleaning and rebuilding X11-extras
14:45:36 <omnId> > let [x,y,z] = [1,2,3] ; x,y,z :: Complex Integer in [x,y,z]
14:45:37 <lambdabot>   add an instance declaration for (RealFloat Integer)
14:45:37 <lambdabot>     In the expression: ...
14:45:45 <omnId> > let [x,y,z] = [1,2,3] ; x,y,z :: Integer in [x,y,z]
14:45:48 <lambdabot>  [1,2,3]
14:46:13 <omnId> bakert: try using 'up, left, etc :: FRef Traits Int'
14:47:04 <omnId> then you'll need 'get up traits'.  'up traits' will be invalid since up can't be a function without Ref r => r
14:47:47 <bakert> oh :(
14:48:05 <bakert> yes that causes errors elsewhere where i am using the record accessors
14:48:09 <xelxeba1> sjanssen: that did the trick :) thanks.
14:48:33 <bakert>     Couldn't match expected type `FRef' against inferred type `(->)'
14:48:33 <omnId> bakert: the other option is to not use a list binding and bind 'em all seperate.
14:48:34 <dmwit> omnId: Huh, I was under the impression that you could always get around MR by giving good type signatures.
14:48:44 <panagos> hello, i'm a prolog user, i have this question: does haskell support logical constructs like prolog? pattern matching, unification, etc
14:48:53 <dmwit> omnId: Do you know off-hand why it doesn't work here?
14:49:09 <dmwit> panagos: Pattern matching yes; what's unification?
14:49:35 <omnId> dmwit: It would seem that annotating a pattern binding only works if the pattern is top level, not, as in this example, within a cons pattern.
14:49:35 <panagos> dmwit: it's a prolog core mechanism
14:50:02 <omnId> (x : y : z : []), (:) is the top pattern.
14:50:30 <omnId> x is one of the (:)'s sub-patterns
14:50:33 <dmwit> panagos: Cool, what does it do?
14:50:45 <dmwit> omnId: huh
14:51:07 <panagos> dmwit: for instance, [a|X] will unify with [Y, b] as {X = [b], Y = a}
14:51:16 <twanvl> http://hackage.haskell.org/trac/haskell-prime/wiki/MonomorphicPatternBindings#Experiment
14:51:19 <lambdabot> Title: MonomorphicPatternBindings - Haskell Prime - Trac, http://tinyurl.com/2nly6h
14:51:31 <panagos> dmwit: X and Y are variables, a and b literals
14:51:36 <sorear> fun rep 0 a = nil | rep i a = a :: rep (i-1) a ; foldr (op @) nil (rep 1000000 [1]);   takes about ~6 seconds for me
14:52:17 <Taejo> panagos, what does | in [a|X] mean?
14:52:21 <panagos> dmwit: and [A|B] means a list with head A and tail B
14:52:22 <dmwit> panagos: Sounds just like pattern matching to me.
14:52:30 <shachaf> Taejo: (:).
14:52:42 <Taejo> ok
14:52:53 <omnId> twanvl: "to make pattern bindings monomorphic by default."  Does that mean even if the inferred type isn't typeclass-bounded?
14:52:57 <dmwit> twanvl: heh
14:53:00 <Taejo> dmwit, it isn't really pattern matching
14:53:20 <twanvl> I don't know, you have to ask SPJ
14:53:22 <Taejo> since you have variable and values on both sides
14:53:32 <dmwit> Taejo: You can do that in pattern matching, too:
14:53:43 <dmwit> > let foo [3, x] = x in foo [3, 4]
14:53:49 <sorear> omnId: Yes.
14:53:55 <lambdabot>  4
14:54:05 <omnId> dmwit: in pattern matching there's values on the left and patterns on the right.  You try to hook up what matches.  In unification there's patterns and partially specified things on both sides, and you match what fits.
14:54:08 <Taejo> dmwit, yes, but you can't do this:
14:54:12 <Taejo> > let [1, 2] = [a, b] in a
14:54:12 <lambdabot>   Not in scope: `a'
14:54:21 <omnId> dmwit: type inference uses unification.
14:54:44 <panagos> in prolog, you can define so-called compounds, where you can leave parameters as variables, and the unifier can match variables with literals/subcompounds/other variables
14:54:44 <Taejo> omnId, so that's where I've heard it in the haskell world
14:54:47 <Beelsebob> can anyone think what would cause the same code to cause a stack overflow when compiled, but not when run in ghci?
14:54:57 <panagos> can that be done in haskell?
14:55:22 <Beelsebob> panagos: the closest Haskell comes to unification is pattern matching... which isn't very close
14:55:27 <shachaf> Beelsebob: Which code?
14:55:35 <panagos> hmmmm
14:56:04 <Beelsebob> shachaf: there's quite a large chunk that's being run (as in, 4-5 files), so not really suitable for pastebin even :/
14:56:08 <Beelsebob> it's pure Haskell 98
14:56:11 <Beelsebob> no extensions
14:56:20 <Beelsebob> no monads
14:56:30 <sorear> no monads?  what does that mean?
14:56:40 <shachaf> Beelsebob: No monads? How does it compile?
14:56:45 <Taejo> lol
14:56:59 <Beelsebob> shachaf: okay, sorry, the IO monad, in a single line.. that begins with main =
14:57:01 <panagos> but the cool thing with prolog is that you can sometimes switch the roles of input and output
14:57:05 <sorear> shachaf: you can compile an empty file with ghc -c
14:57:10 <panagos> omnId: do you know prolog?
14:57:17 <omnId> panagos: sorry, no.
14:57:37 * sorear is familiar with unification
14:57:39 <omnId> panagos: if you *really* want unification, there's a slightly insane way to program in the type level and use the inferencer's unification.
14:57:55 <sorear> panagos: no, all values in Haskell are ground
14:58:03 <Beelsebob> panagos: if you want to combine functional programming and logic programming, you may want to stare at curry
14:58:41 <panagos> Beelsebob: i'll check that out :D
15:08:23 <augustss> @seen vincenz
15:08:23 <lambdabot> vincenz is in #haskell. I last heard vincenz speak 25m 14s ago.
15:08:49 <panagos> with prolog, i can e.g. give as a fact "foo([a|X], X)". then if i do the question "?- foo([a, b, c], X)", i get X = [b, c]. likewise, if i ask "?- foo(X, [b, c])", i get X = [a, b, c]
15:09:16 <panagos> does haskell support such pattern matching?
15:09:44 <monochrom> Perhaps f ('a':xs) = xs
15:10:29 <dmwit> f (x:xs) ys | xs == ys = ...
15:10:36 <panagos> monochrom: but can it then work the other way around?
15:10:41 <dmwit> no
15:10:45 <dmwit> Haskell is not prolog.
15:10:49 <monochrom> that does the first but not the second. there is no automatic way of doing the second, unless you write your own search and backtracking.
15:11:02 <panagos> hmmm
15:17:52 <omnId> ?brain Are you pondering what I'm pondering?
15:17:52 <lambdabot> Oooh, I think so Brain, but I think I'd rather eat the Macarena.
15:18:05 <dmwit> ?quote
15:18:05 <lambdabot> eyeris says: grr... I hate the way every haskell tutorial brags about how easy strings are to use. They are only easy once you drink the koolaid.
15:18:14 <dmwit> ?quote perpendicular
15:18:14 <lambdabot> No quotes match. The more you drive -- the dumber you get.
15:18:31 <monochrom> monads are easy to use
15:18:42 <hpaste>  xelxebar annotated "(no title)" with "added missing check to checkprime" at http://hpaste.org/3441#a1
15:19:37 <dmwit> ?quote drive
15:19:37 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
15:19:37 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
15:19:59 <dmwit> what?
15:20:46 <dmwit> ?quote dumber
15:20:46 <lambdabot> roconnor says: <roconnor> xerox: I'm dumber than a turning machine.
15:20:56 * dmwit spins
15:21:47 <Olathe> No spinning !
15:22:13 <panagos> ghc compiles in native elf format on linux?
15:22:28 <ben> panagos: yes
15:23:04 <panagos> and it can interface with .o files from C?
15:23:26 <dmwit> right
15:24:44 <panagos> that's really good!
15:27:32 <astrolabe> If I type 'runhaskell Setup.lhs configure' and get the response 'Setup.lhs: HTTP.cabal:19: 'Executable' stanza starting with field 'flag old-base description' ' , does that mean something has gone wrong?
15:28:22 <dons> wrong cabal version?
15:28:28 <dons> you using cabal 1.2.x?
15:28:38 <astrolabe> dons: How do I tell?
15:28:40 <Laney> Is there a roadmap/feature list/similar for GHC 6.8 anywhere?
15:29:18 <dons> ghc-pkg list
15:29:29 <dons> Laney: yeah, chheck the haskell.org/ghc wiki
15:29:42 <astrolabe> Cabal-1.1.6
15:30:29 <TomMD> dons: do you ever work, or is this a 'Haskell Tech Support'?  J/k - its really neat how you always know the answer and are willing to help.
15:34:24 <astrolabe> hmmm I'll try getting the latest ghc then.
15:43:21 <panagos> a:b:c is (a:b):c or a:(b:c) ?
15:43:46 <sorear> panagos: :info (:) in a ghci session
15:43:51 <Zao> panagos: Since only one of them works, it should be somewhat obvious.
15:44:28 <panagos> .....
15:44:46 <Laney> Check the types and all will become clear
15:45:57 <astrolabe> Hmmm.  Well, I've downloaded ghc 6.6.1, and I now how Cabal-1.1.6.2, but I still get the same error :(
15:46:26 <dons> you need cabal 1.2 :|
15:46:26 <Laney> astrolabe: Try Cabal 1.2.0 from the website
15:46:38 <astrolabe> Thanks
15:47:29 <Laney> Hey, if I'm using the darcs version of some library and regularly updating it using cabal, will I end up with redundant files?
15:48:40 <Laney> Alternatively: Should I uninstall before upgrading, or will this be taken care of?
15:48:47 <omnId> panagos: :info (:) says 'infixr 5 :' which means that the (:) operator is right-associative
15:59:36 <astrolabe> I've got the new cabal now.  How do I get rid of the old one?
16:08:04 <newsham> anyone know where to find spj's motivational article on using haskell/STM's?
16:08:16 <newsham> aimed at non-haskell programmers, not technical journal stuff.
16:08:31 <Pseudonym> ?google "beautiful concurrency"
16:08:34 <lambdabot> http://research.microsoft.com/~simonpj/papers/stm/beautiful.pdf
16:09:32 <newsham> thanks
16:09:34 <augustss> Too bad the example he used isn't the most beautiful
16:09:56 <dons> he likes the {;;} syntax too, oddly
16:11:45 <newsham> s'ok, it'll do fine for the purpose.
16:12:33 <Zao> dons: It makes for less lines in books?
16:12:53 <dons> or safer code when transcribing?
16:13:10 <Cale> I think it's mainly to look familiar to outsiders :)
16:13:27 <dons> don't want to scare them with this crazy whitespace thing
16:13:32 <dons> ?quote hang
16:13:32 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
16:13:41 <Cale> In case they start hyperventilating, they can just stick their head in a curly brace.
16:13:49 <dons> right
16:14:03 <dons> ?quit achtung
16:14:15 <newsham> curly embraces
16:14:38 <allbery_b> python has given laoyt a bad reputation
16:14:54 <dons> hmm. yes.
16:14:54 <dons> and
16:15:00 <dons> lisp gave FP a bad rep.
16:15:22 <dons> but GNU make hasn't hurt python's layout?
16:15:43 <astrolabe> @karma+ dons
16:15:43 <lambdabot> dons's karma raised to 135.
16:15:46 <newsham> hmm.. how would gnumake hurt python layout?
16:16:27 <dons> ok, so python didn't learn from GNU make, instead, it emulated it.
16:16:28 <allbery_b> make (gnu or otherwise) is gnerally looked upon as an unavoidable evil
16:16:39 <dons> in terms of significant tabs, I mean
16:16:43 <allbery_b> no, python behaves sanely if you indent with spaces.  maek throws an error
16:16:44 <newsham> are you talking about tab-actions in make?
16:16:45 <dons> don't you guys write makefiles anymore?
16:16:47 <newsham> thats not specific to gnumake
16:17:11 <dons> ah, right you are. i just implicitly attribute all goodness to bsd make :)
16:19:28 <newsham> how can use format latex docs without make?!@#? ;-)
16:24:41 <panagos> how do i write 1-tuples?
16:24:58 <sjanssen> panagos: there isn't such a thing
16:25:10 <panagos> you are kidding me!
16:25:15 <sjanssen> no
16:25:27 <sjanssen> why do you want a 1-tuple?
16:25:39 <shapr> y0 y0
16:25:44 <shapr> What's the good code today?
16:25:59 <dons> panagos: its a cute question :)
16:26:02 <centrinia> :: (a)
16:26:12 <centrinia> That defines an one-tuple. :)
16:26:14 <dons> what would the inhabitants of such a type be?
16:26:27 <shapr> It assumes that tuples are a container type as they are in Python.
16:26:30 <dons> assuming this syntax:   (Bool)
16:26:38 <dons> what would the elements of the type (Bool) be?
16:26:40 <mgsloan> haskell seems to have a zero-tuple
16:26:42 <mgsloan> ()
16:26:46 <panagos> at least python supports it! also for completeness (why would you need a 0-tuple? yet there it is!)
16:26:50 <Zao> data () = ()
16:26:58 <centrinia> How would I define a tuple type with the data keyword?
16:26:59 <sjanssen> panagos: () is very useful
16:27:02 <dons> panagos: yes, but what does a one-tuple actually mean?
16:27:11 <dons> what are the elements of the type?
16:27:13 <sjanssen> panagos: in monadic code, for example
16:27:24 <omnId> there is a one tuple!  It's just called Identity :)
16:27:28 <dons> data T a = T a ?
16:27:30 <dons> yes, Identity
16:27:37 <mgsloan> yeah, it confused me in monadic code
16:27:42 <centrinia> The elements of the tuple are arbitrary like in ordinary tuples.
16:27:44 <panagos> a 1-tuple would be a 1-tuple :D
16:27:47 <Pseudonym> ?hoogle Control.Monad.Identity
16:27:47 <lambdabot> No matches, try a more general search
16:27:54 <Pseudonym> :t Id
16:27:56 <lambdabot> Not in scope: data constructor `Id'
16:28:02 <centrinia> oneTupleTuple :: ((a)) :O
16:28:03 <omnId> @index Identity
16:28:03 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
16:28:03 <dons> panagos: ok, so what are the elements of the 1-tuple of Bools?
16:28:07 <Pseudonym> Hmm.
16:28:17 <Pseudonym> :t Control.Monad.Identity.Id
16:28:17 <omnId> @type Control.Monad.Identity.Identity
16:28:18 <lambdabot> forall a. a -> Identity a
16:28:19 <lambdabot>     Not in scope: data constructor `Control.Monad.Identity.Id'
16:28:21 <Pseudonym> Right.
16:28:22 <Pseudonym> OK
16:28:24 <panagos> dons: i don't get you
16:28:25 <Pseudonym> There it is, anyway.
16:28:28 <omnId> the constructor is Identity
16:28:29 <Pseudonym> And it's a monad, too!
16:28:53 <sjanssen> is Identity a newtype?
16:28:57 <dons> panagos: it goes back to why you would want such a value
16:28:57 <Pseudonym> Probably.
16:28:59 <sjanssen> if so, it isn't an acceptable 1-tuple
16:29:01 <dons> yes
16:29:17 <omnId> panagos: the Bool type has two values: False and True, how many values does the OneTuple Bool type have?
16:29:24 <dons> the python guys don't know why they would want it, I suspect :)
16:29:36 <centrinia> Is it even possible to declare arbitrary arity tuples with the data keyword.
16:29:42 <dons> ah, thanks omnId, I'm a bit tired.
16:29:45 <panagos> omnId: 2 !
16:29:54 <sjanssen> do Python tuples support concatenation and slicing?
16:29:56 <dons> panagos: so its identical to the type Bool then?
16:30:22 <panagos> sjanssen: yes
16:30:23 <mgsloan> data Single a = Single a
16:30:27 <Pseudonym> sjanssen's complaint, BTW, is that Bool actually has three values (including bottom), and the 1-tuple of Bool has four.
16:30:32 <mgsloan> is (Single a) the same type as a?
16:30:32 <dons> yes.
16:30:49 <sjanssen> panagos: Haskell tuples don't have concatenation, and that is why we don't have a 1-tuple
16:30:50 <panagos> dons: at first glance, yes
16:30:51 <dons> which makes it interesting for experts, but not so interesting for beginners
16:30:54 <panagos> nevermind
16:31:01 <omnId> mgsloan: in the presence of _|_, actually no :)
16:31:03 <dons> panagos: and this is why there is no separate one tuple type :)
16:31:04 <Igloo> Bool only has one _|_, though, whereas the 1-tuple of a Bool would have 2 _|_s
16:31:26 <dons> panagos: esp. in a strict language, the one-tuple doesn't make sense
16:31:31 <mgsloan> omnld - oh, well, I figured it was a distinct type just in its nature, in the same way (a) is
16:31:35 <omnId> _|_, Single _|_, Single False, Single True
16:31:37 <dons> while in Haskell, it is actually a useful type
16:31:54 <dons> Pseudonym: we should get Id into base.
16:31:59 <twanvl> I think yhc has a one-tuple
16:32:02 <dons> the one tuple is underappreciated :)
16:32:06 <sjanssen> how are tuples different from arrays in Python?
16:32:30 <dons> presumably python arrays are mutable?
16:32:38 <panagos> sjanssen: they are immutable (and in python arrays are called lists too ;)
16:32:41 <Pseudonym> dons: Yeah, maybe.
16:32:43 <dons> panagos: is the one tuple in python really the 1-element mutable array?
16:33:12 <panagos> in python tuples are immutable, and 1-tuples too
16:33:26 <sjanssen> GHC doesn't have a boxed 1-tuple, but it has an unboxed 1-tuple :P
16:33:48 <panagos> (note that i am a haskell newbie...)
16:34:08 <dons> oh, that's interesting. so how is the python 1-tuple from the value stored in the 1-tuple?
16:34:10 <panagos> (you have probably figured that out already :D)
16:34:33 <sorear> dons: python tuples and arrays are not the same
16:34:35 <dons> can it be null, or store null?
16:34:36 <panagos> dons: you just say "x = (y,)"
16:35:19 <panagos> in python
16:35:22 <dons> say i had a python 1-tuple storing True and False, are there any other values that could be stored in that 1-tuple of Bools?
16:35:40 <Philippa> ..."1-tuple storing True and False"?
16:35:51 <panagos> dons: once you have a tuple, it's immutable, you can't change its items
16:35:55 <dmwit> No types in Python...
16:36:18 <dons> ok, i'll try again, how is x = y different to x = (y,) ?
16:36:21 <panagos> dons: but you can concatenate tuples if you like...
16:36:40 <dmwit> dons: x + x have different semantics there.
16:36:44 <dmwit> (for example)
16:36:45 <panagos> dons: x is a tuple! :D y need not be one
16:36:53 <omnId> dons: how is let x = y different from let x = Identity y  :P?
16:37:15 <dons> omnId: that's what I'm trying to establish: in python, are there bottoms in the one-tuple?
16:37:41 <sorear> dons: python is strict, there are no bottoms period
16:38:13 <Cale> There are bottoms, of course
16:38:14 <dons> right, so how is the 1-tuple of a different to a? does it introduce purity?
16:38:20 <panagos> what are bottoms? you mean something like a:b:c:[], [] being the bottom?
16:38:21 <Cale> But they spread quickly ;)
16:38:35 <dons> panagos: null or undefined values
16:38:37 <sorear> dons: it's a different value
16:38:41 <Cale> panagos: Essentially values which cause nontermination
16:38:44 <sorear> dons: just like 1 and 2 are different values
16:39:10 <dons> sorear: but the type is isomorphic to the type it is parametrised by?
16:39:21 <blackdog_>  /me thought this was a classy channel - quickly spreading bottoms? seriously?
16:39:21 <sorear> what are types?
16:39:29 <sorear> this is python we're talking about
16:39:30 <Cale> heh
16:39:36 <omnId> @slap blackdog_
16:39:36 * lambdabot slaps blackdog_
16:39:41 <panagos> !
16:39:43 <blackdog_> ... deserved
16:39:49 <dons> sorear: of course it has types
16:39:51 <Olathe> @slap slappers
16:39:51 * lambdabot hits slappers with a hammer, so he breaks into a thousand pieces
16:39:59 <sorear> dons: it has type.
16:40:04 <dons> right :)
16:40:12 <sorear> everything is an object
16:40:21 <sorear> (1,) is an inhabitant of the same type as 1
16:40:24 <panagos> something else: hugs doesn't accept let x = 1. how do i write that in hugs?
16:40:27 <sorear> as different from 1 as 2 is
16:40:37 <dons> so its purpose is what then?
16:40:44 <sorear> infact more so, since most partial functions that work on 1 also work on 2
16:40:44 <Cale> Functions are strict in Python, so values which are defined by nonterminating computations are unusable.
16:40:49 <sorear> dons: regularity
16:40:50 <dons> as a tag for values that can be concatenated?
16:41:10 <sorear> dons: haskell has 0, 2, 3, 4, 5, .. tuples.
16:41:24 <dons> so that's what i was trying to understand
16:41:29 <sorear> dons: so what if 1-tuples are unneccesary, N is a much nicer set to deal with than N-1
16:41:38 <sorear> N \ {1}  rather
16:41:44 <omnId> panagos: unfortunately hugs doesn't allow adding new names in the repl, you'll have to load definitions from a file.
16:41:45 <dons> sure. but it needed special syntax, it seems
16:41:48 <Olathe> panagos: Switch to ghci.
16:41:51 <dons> (x,)
16:42:06 <dons> panagos: yeah, ghc is where it is at.
16:42:15 <Cale> panagos: Yeah, either switch to ghci, or put your definitions in a file.
16:42:16 <panagos> Olathe: i would, but it's too big to download now... ;)
16:42:32 <Cale> panagos: you can write  x = 1  into a file and load it
16:42:41 <Cale> :r will reload the file if you change it
16:43:13 <panagos> ok
16:43:14 <Cale> I recommend keeping an editor window open alongside the terminal in which you're running hugs/ghci
16:43:40 <panagos> Cale: thought so
16:44:04 <newsham> whoa, dons is doing python?
16:44:32 <dons> newsham: nope. :)
16:45:14 <sorear> newsham: he's struggling to learn it after all this time with typed FP :)
16:45:51 <newsham> python is spoken with a slight lisp
16:46:01 <dons> everything is typed, just accept that sorear :)
16:46:16 <dons> even things that say they aren't, usually have a type structure
16:46:21 <newsham> there are speech-to-text processor now, dons.
16:46:27 <Nafai> dons: Heh, I'm having a hard time learning Haskell after being used to Python
16:46:33 <dons> Nafai: oh, how so?
16:46:42 <dons> too much type structure?
16:47:00 <newsham> Haskell is very much different than python.  where to start ;-)
16:47:12 <Nafai> That's a big part of it, I think
16:47:22 <dons> sorear: you should look at booleans in php sometime
16:47:27 <Nafai> The Haskell syntax is weird :)
16:47:33 <dons> and try to work out what values are treated as true and false
16:47:34 <yrlnry> Heck, I have trouble with Haskell coming from SML.
16:47:47 <augustss> Nafai: it's natural!
16:47:58 <dons> Nafai: oh, syntax. yes, I always forget that syntax can be a hurdle
16:48:04 <newsham> so is mandarin if you're from beijing
16:48:16 <dons> python seems so arbitrary and confused in its syntax
16:48:37 <Nafai> dons: I don't disagree, I guess I'm just used to it
16:48:47 <dons> who in CS do we blame for the f(1,2,3) syntax?
16:48:50 <newsham> seems rather similar to most other C-like languages to me
16:49:00 <dons> some guys at Bell Labs? or is it earlier?
16:49:08 <Nafai> I was able to hack something useful together in my first afternoon of learning Python
16:49:14 <newsham> I think it predates C
16:49:20 <wli> I couldn't stand Python much. I stopped using it ASAP the one time I committed to using it.
16:49:21 <Cale> dons: Newton perhaps?
16:49:22 <Nafai> I ended up using a form of that code for like 3 or 4 years after that
16:49:23 <wli> Earlier.
16:49:24 <newsham> btw, we used f(x,y) in calculus too :)
16:49:26 <augustss> f(1,2,3) was in FORTRAN
16:49:44 <wli> i.e. 1954 at latest
16:49:48 <dons> due to parser technology of the time? :)
16:49:59 <Nafai> I've spent several afternoons trying to write Haskell and I have yet to write anything beyond Hello World that works in Haskell
16:50:07 <Pseudonym> The () notation for arrays dates at least back to FLOW-MATIC.
16:50:09 <dons> Nafai: why not do the irc bot tutorial?
16:50:11 <augustss> dons: no, probably because it's a notation used in maths
16:50:19 <sorear> doesn't it date back to Leibniz?
16:50:28 <Pseudonym> But FLOW-MATIC didn't have function calls AFAIK.
16:50:47 <Pseudonym> Yeah, I think it's the standard function syntax from ages ago.
16:50:49 <dons> augustss: right, so we take the expression syntax, but then a different syntax for saturated function application, it seems
16:50:50 <Cale> sorear: yeah, I think it was Newton who invented that notation
16:51:09 <yrlnry> I wish Newton had invented a postfix notation.
16:51:32 <fnord123> Where can I read up on ghci's limitations? I've got an MVar () and would like to use putMVar on it in ghci but I'm told I need to make an instance decl for Num().
16:51:43 <Nafai> dons: Probably a good place to start, should find the time
16:51:57 <dons> fnord123: sounds like a type error :) not a ghci limitation
16:52:00 <Cale> Er, oh, it was Euler, apparently.
16:52:07 <newsham> too bad newton never got laid.
16:52:09 <Cale> "Euler was the first to use the notation that is probably used more than anything else, f(x), to represent the function of x."
16:52:10 <sorear> fnord123: that sounds like user error.  you can't put numbers into a MVar ()
16:52:11 <newsham> things would be so different
16:52:28 <yrlnry> newsham: why do you think they would have been better?
16:52:32 <dons> fnord123: you want a newEmptyMVar :: MVar Int
16:52:33 <dons> perhaps?
16:52:36 <fnord123> very similar code compiles, though.   a <- newEmptyMVar;  putMVar a 0
16:52:52 <sorear> dons: eek!  newEmptyMVar :: IO (MVar Int)
16:52:54 <augustss> Mathematicians are usually pretty confused about functions :)
16:52:55 <dons> right, remember that () is not of type Int
16:52:57 <sjanssen> fnord123: extended defaulting
16:53:01 <dons> sorear: yes, oops.
16:53:05 <dons> sorear: pesky types
16:53:05 <augustss> Like calling f(x) a function
16:53:22 <fnord123> so it's inferring based on the full program when im using the compiler; but in interactive mode it obviously cannot (?)
16:53:25 <tech> did anyone see airy today
16:53:25 <wli> Usually  f : X -> Y
16:53:26 <sjanssen> fnord123: ghci doesn't know ahead of time what you'll put into the MVar, so it gives it the default type of MVar ()
16:53:34 <fnord123> aye aye. :)
16:53:48 <dons> augustss: they're weirdos, because they don't have to execute their programs :)
16:54:04 <yrlnry> dons: and they're only interested in O(1) algorithms.
16:54:07 <dons> ?seen airy
16:54:07 <augustss> fnord123: ghci is not made for program development.  put your definitions in a file
16:54:07 <lambdabot> Last time I saw airy was when I left ##logic, #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #parrot, #perl6, #scala, #scannedinavian, #unicycling
16:54:07 <lambdabot> and #xmonad 4d 7h 40m 18s ago, and .
16:54:09 <sorear> fnord123: right, it has to commit after each line.  same principle as the value restriction
16:54:16 <Philippa> remember we only get to currying via higher-order function
16:54:20 <Philippa> functions, even
16:54:38 <Cale> Mathematicians are not confused about types
16:54:45 <Cale> (or functions for that matter)
16:54:51 <dmwit> dons: He's looking for ari.  Why he continues to call him airy is beyond me. =/
16:55:02 <dons> ah.
16:55:05 <Philippa> you have to have a pretty coherent notion of function to even find the possibility, which means that there's going to be a pre-existing syntax from when we didn't have it
16:55:42 <Cale> In mathematics, essentially every proposition with a free variable acts as a type.
16:55:49 <yrlnry> Philippa: I seem to remember that the idea of currying was invented by Schonfinkel after consideration of the identity A^(BxC) = (A^B)^C.
16:55:55 <dons> thankfully we got lambda calculus to clean up the broken math syntax :)
16:56:17 <Cale> dons: Also, mathematicians have taken to using a very LC-like syntax.
16:56:33 <Cale> (x |--> x^2) for \x -> x^2
16:56:36 <Philippa> yrlnry: right. We'd been playing with functions for how long by then?
16:56:41 <dons> Cale: nice.
16:56:55 <dons> we should hand out free ghci's on cd for maths departments
16:57:15 <dons> i bet that would help improve the regularity of the hand written notation :)
16:57:20 <newsham> dons: there are even mathematicians who are reworking their written syntax formally based on it
16:57:23 <Cale> I think lots of CS people get the wrong idea about mathematics from the early courses they take which seem mostly designed by physicists or something :)
16:57:34 <newsham> http://www.funmath.be/
16:57:35 <Philippa> by the time Schoenfinkel got to it, we already knew that exponential meant function as well
16:57:36 <lambdabot> Title: Funmath Home Page
16:57:45 <Philippa> Cale: definitely
16:58:12 <Philippa> especially from the amount of it that's not constructive and the fact we don't talk about things like tactics
16:58:44 <dons> Cale: yes, its a bad light for math when you do say, undergrad math, then do theorem proving over on the CS side later.
16:58:44 <Philippa> the early courses tend to take about as anti-computational an approach as you can get, really
16:59:01 <dons> mm
16:59:36 <Cale> Yeah, undergrad math is very different when you're in the mathematics program I find.
16:59:44 <newsham> D.Gries, "The Need for Education in Useful Formal Logic"
16:59:48 <Cale> It's like the mathematicians save the good courses for their own students.
16:59:49 <newsham> http://csdl2.computer.org/persagen/DLAbsToc.jsp?resourcePath=/dl/mags/co/&toc=comp/mags/co/1996/04/r4toc.xml&DOI=10.1109/MC.1996.10041
16:59:52 <centrinia> One can say that the number 2 in the naturals is not the same thing as the number 2 in the integers.
16:59:59 <Cale> centrinia: yep
17:00:18 <Cale> centrinia: But one can also identify them via the obvious isomorphism whenever that's convenient.
17:00:27 <dons> centrinia: right, ad hoc polymorphic numeric literals :)
17:00:31 <Cale> s/isomorphism/embedding/
17:00:55 <wli> I've got to start using the existential type formulation of ADT's dons told me about.
17:01:02 <Cale> One can also say that 2 is the category with two objects and a single nonidentity arrow between them.
17:01:07 * dons infers types as the first step in understanding any abstraction, idea or thought
17:01:17 <Cale> Or the set {0,1}
17:01:24 <tech> dmwit: his real name is airy, and someone took it
17:01:41 <Cale> As long as it's made clear *which* 2 you're talking about, it's okay.
17:01:58 <centrinia> The number 2 in the integers is the equivalence class of all pairs (a,b) such that a=b+2
17:02:01 * sorear doubts tech
17:02:15 * Eelis remembers trying to get his probabilistics teacher to specify the type for the '|' in P(X|Y)  :)
17:02:21 <Cale> right
17:02:41 <Cale> and in the reals (via Dedekind cuts), it's the set of all rational numbers strictly less than 2
17:02:44 <sorear> it's a single symbol
17:02:54 <sorear> P(.|.)
17:03:02 <newsham> I usually skipped equivalence class
17:03:11 <Eelis> sorear: that's what i found out after 15 minutes of discussion and mutual misunderstanding, yes
17:03:14 <Cale> newsham: heh
17:03:31 <centrinia> Or the set of all Cauchy sequences that differ from the constant sequence {2,2,...} by a null sequence.
17:03:48 <tech> sorear: don't you know anything about finland, ari is not a real finn name, but airy is
17:04:06 <dons> sorear is from helsinki though!
17:04:13 <dons> why are we looking for ari again?
17:04:26 <sorear> tech: I don't know anything about finland, but ari has always been his nick.  you can't
17:04:26 <dons> is he a haskell hacker?
17:04:41 <sorear> tech: I don't know anything about finland, but ari has always been his nick.  you can't "take" someone's nick on IRC that easily...
17:05:15 <dons> sorear: hackers, dude. taking nicks all the time
17:05:21 <dons> and assigning types to them
17:05:30 <Olathe> Just last week, someone took my nick.
17:05:37 <Olathe> Which means I am currently an impostor !
17:05:40 <Olathe> Muahahaha !
17:05:41 <newsham> airy :: Fin?
17:05:42 <dons> did he clean it before he gave it back?
17:06:13 <dons> someone is trying to hack ben's nick, see!
17:06:23 <Cale> P(-|A) can be thought of as another probability distribution on the same sample space/events.
17:06:32 <ben> :(
17:06:48 <gotchernose> HAXX0RZ
17:07:15 <tech> what fun!
17:07:19 <tech> oh man
17:07:25 <dons> Who's who now??
17:07:27 <dmwit> hah
17:08:02 <gotchernose> hehe
17:08:21 <dons> :)
17:08:27 <jaredj> uhr
17:08:30 <tech> switching identities is fun
17:08:37 <dmwit_> Wait, how do I do that?
17:08:42 <dmwit_> =P
17:08:47 <dons> who are you again?
17:08:52 <dons> ?seen dmwit
17:08:52 <lambdabot> dmwit is in #haskell, #haskell-blah and #xmonad. I last heard dmwit speak 10s ago.
17:09:05 <dmwit> Okay, I'm me again.
17:09:19 <dmwit> But for future reference, how do I do that?
17:09:23 <sorear> I AM ME!
17:09:27 * dmwit googles
17:09:40 <sorear> dmwit: /msg nickserv help
17:09:52 <dons> i'm suspicious about sorear
17:10:02 <dons> you say you're like 9 years old?
17:10:05 <dons> seems unlikely
17:10:16 <tech> he's a paedo
17:10:19 <dmwit> aha, got it
17:10:28 <dons> tech: a child?
17:10:29 <sieni> dons: children are people too!
17:10:47 <dons> ?web1913 person
17:10:49 <lambdabot> *** "Person" web1913 "Webster's Revised Unabridged Dictionary (1913)"
17:10:49 <lambdabot> Person \Per"son\, v. t.
17:10:49 <lambdabot>    To represent as a person; to personify; to impersonate.
17:10:49 <lambdabot>    [Obs.] --Milton.
17:10:49 <lambdabot>  
17:10:51 <lambdabot> [73 @more lines]
17:10:52 <sorear> I'm 16 and I'm sticking to it.
17:10:58 <dons> ?more
17:10:58 <lambdabot> *** "Person" web1913 "Webster's Revised Unabridged Dictionary (1913)"
17:10:59 <lambdabot> Person \Per"son\, n. [OE. persone, persoun, person, parson, OF.
17:10:59 <lambdabot>    persone, F. personne, L. persona a mask (used by actors), a
17:10:59 <lambdabot>    personage, part, a person, fr. personare to sound through;
17:11:01 <lambdabot>    per + sonare to sound. See {Per-}, and cf. {Parson}.]
17:11:03 <dons> a mask!
17:11:03 <lambdabot> [68 @more lines]
17:11:14 <sjanssen> sorear: oh yeah?  We'll see what your story is in a year
17:11:16 <dons> or nick if you will.
17:11:26 <dons> i bet he says the same thing.
17:11:34 <tech> @more
17:11:34 <lambdabot>    1. A character or part, as in a play; a specific kind or
17:11:35 <lambdabot>       manifestation of individual character, whether in real
17:11:35 <lambdabot>       life, or in literary or dramatic representation; an
17:11:35 <lambdabot>       assumed character. [Archaic]
17:11:35 <lambdabot>  
17:11:36 <lambdabot> [63 @more lines]
17:11:37 <sieni> dons: http://www.youtube.com/watch?v=7gIj86NjNi4
17:11:38 <lambdabot> Title: YouTube - Anthony Gatto, Kids Are People Too.
17:11:47 <dons> ah
17:15:49 <monadonous> can someone help me with a problem with type classes?
17:16:06 <monadonous> I'm trying to write a function that lets me (||) together predicates
17:16:13 <hpaste>  monadonous pasted "Type class problem" at http://hpaste.org/3442
17:16:52 <dmwit> instance (Orable b) => Orable (a -> b) where ... maybe?
17:16:57 <omnId> monadonous: instance Orable b => Orable (a->b)
17:17:24 <omnId> the result has to be Orable if you use `a_or` on it.
17:18:39 <monadonous> that makes sense, but even when I add that I get the same errors
17:18:53 <monadonous> even the first instance isn't working though, oddly
17:19:44 <omnId> class Orable a where a_or :: Orable b => a -> a -> b -- this means that the result of a_or x y can have *any* type, so long as it's in Orable.
17:20:16 <monadonous> yes, that's what I intend
17:21:06 <dmwit> You must be able to construct any orable type out of two instances of any other orable type.
17:21:10 <dmwit> Is this *really* what you want?
17:21:18 <omnId> so what would (True `a_or` False :: a -> Bool) be?
17:21:22 <dmwit> i.e. You would need to create a function (a -> b) out of two Bools.
17:21:55 <omnId> I think you want a_or :: a -> a -> a
17:22:49 <omnId> @type (||)
17:22:51 <lambdabot> Bool -> Bool -> Bool
17:22:52 <omnId> @type liftM2 (||)
17:22:54 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
17:22:56 <monadonous> oh that does make sense, and when I make that change it compiles
17:23:24 <omnId> @type \f g x -> liftM2 (||) f g x
17:23:26 <lambdabot> forall t. (Monad ((->) t)) => (t -> Bool) -> (t -> Bool) -> t -> Bool
17:24:58 <monadonous> liftM2 can already do what my a_or does?
17:26:27 <omnId> the monad ((->) r) instance is such that liftM2 op does op on the results of two functions.
17:27:04 <omnId> > liftM2 (&&) even (>5) 6
17:27:06 <lambdabot>  True
17:27:10 <hpaste>  mdmkolbe pasted "GADTs and exhaustive pattern matches" at http://hpaste.org/3443
17:27:27 <monadonous> so a_or = liftM2 (||)
17:27:38 <mdmkolbe> Anyone know how to convince GHC that that pattern is exhaustive? http://hpaste.org/3443
17:27:52 <omnId> you'll need to import Control.Monad.Instances for the ((->) r) instnace.
17:28:05 <mdmkolbe> (other than just adding a dummy match or just turning off the warning)
17:28:21 <TSC> But it's not exhaustive
17:28:41 <TSC> Is it?
17:28:54 <omnId> yep
17:29:12 <omnId> baz FooInt FooChar doesn't even typecheck.
17:29:18 <TSC> Oh, GADTs
17:29:23 <mdmkolbe> TSC: GADTs make it exhaustive by the fact that baz takes two 'Foo t'.  the only way for that to happen is if they use the same constructor.
17:29:44 <TSC> The ts have to be the same, I see
17:33:16 <Philippa> mdmkolbe: file a bug report for now and add a comment to the line?
17:36:31 <monadonous> liftM2 works for simple one parameter predicates, but fails for others
17:36:49 <mrd> @src liftM2
17:36:49 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:38:06 <omnId> liftM2 f g h x = f (g x) (h x)
17:39:06 <monadonous> but what about ? f g h x x2 x3... = f (g x x2..) (h x x2...)
17:39:23 <monadonous> that is what a_or does
17:40:08 <monadonous> the type system lets it know when to finally apply (||)
17:40:50 <omnId> it calls the a_or that belongs to the result type, so it could be another liftM2 a_or or a plain (||)
17:41:07 <omnId> (iiuc)
17:41:39 <seliopou> mdmkolbe: maybe it's a bug?
17:42:38 <mdmkolbe> seliopou: I'm guessing that GADTs throw the coverage checker out of whack (who knows, it might be an NP-Hard problem once GADTs are in there)
17:42:43 <monadonous> ah, so the second instance's a_or can become a_or = liftM2 (a_or)
17:42:50 <dataangel> @src head
17:42:50 <lambdabot> head (x:_) = x
17:42:50 <lambdabot> head []    = undefined
17:44:51 <dataangel> The haskell wikibook says it only makes sense to use lazy patterns when you're dealing with a single constructor. But that's just giving a time _not_ to use it (when you have multiple constructors). What benefit is there to doing so at all ever?
17:46:38 <mrd> > (\ (a,(b,c)) -> a) (1,undefined)
17:46:39 <lambdabot>  Undefined
17:46:40 <mrd> > (\ (a,~(b,c)) -> a) (1,undefined)
17:46:42 <lambdabot>  1
17:47:24 <mrd> deconstructing a value forces evaluation at that point, which may be too soon
17:47:52 <mrd> however, any uses of ~ can be transformed into an equivalent let-in expression. i think.
17:48:12 <mrd> since let-bindings are lazy by default
17:48:13 <omnId> let's insert an implicit ~, so I believe that's correct.
17:48:26 <centrinia> > product (map (-1 +) [1..])
17:48:30 <lambdabot> Terminated
17:48:33 <centrinia> Damn. :|
17:48:39 <mrd> > (subtract 3) 5
17:48:40 <lambdabot>  2
17:48:59 <centrinia> My expression should equal zero. :|
17:49:18 <omnId> > product [0..]
17:49:22 <lambdabot> Terminated
17:49:33 <TSC> * is strict in both arguments, isn't it?
17:49:34 <omnId> > 0 * (0/0)
17:49:36 <lambdabot>  0.0
17:49:40 <iank> o_O
17:49:47 <centrinia>  O_O
17:49:54 <iank> ()_()
17:49:56 <omnId> > 0/0
17:49:58 <lambdabot>  NaN
17:50:04 <iank> > NaN * 0
17:50:05 <lambdabot>   Not in scope: data constructor `NaN'
17:50:08 <iank> bah
17:50:13 <omnId> > (0/0) * 0
17:50:14 <lambdabot>  0.0
17:50:23 <omnId> hrm.
17:50:26 <centrinia> > sum [1/x^2 | x<-[1..]]
17:50:30 <lambdabot> Terminated
17:50:32 <iank> > 0/0 + 0
17:50:33 <lambdabot>  NaN
17:50:36 <iank> > (0/0) + 0
17:50:37 <lambdabot>  NaN
17:50:48 <iank> > (0/0) * 0 + 0
17:50:49 <lambdabot>  0.0
17:50:52 <centrinia> > (1/0)*0
17:50:54 <lambdabot>  0.0
17:51:08 <centrinia> Hmm, weird.
17:51:15 <iank> (0/0 + 0)*0
17:51:18 <centrinia> > (1*0/0)
17:51:19 <lambdabot>  NaN
17:51:21 <iank> er
17:51:24 <iank> > (0/0 + 0)*0
17:51:25 <lambdabot>  0.0
17:51:31 <iank> > (0/0 + 0)*1
17:51:32 <lambdabot>  NaN
17:51:36 <centrinia> Okay, that's not commutative.
17:51:46 <centrinia> > 0*1/0
17:51:48 <lambdabot>  NaN
17:51:52 <centrinia> > 1*0/0
17:51:53 <lambdabot>  NaN
17:51:59 <centrinia> Or maybe it is commutative.
17:52:18 <centrinia> It is just not associative.
17:52:35 <centrinia> > sum [1/x^2 | x<-[1..100]]
17:52:37 <lambdabot>  1.6349839001848923
17:52:50 <centrinia> That should have 3 digits of accuracy.
17:52:52 <omnId> > (0*(1/0), (0*1)/0)
17:52:53 <lambdabot>  (0.0,NaN)
17:53:44 <centrinia> > uncurry (*) (0*(1/0),(0*1)/0)
17:53:45 <lambdabot>  0.0
17:54:33 <centrinia> I guess lambdabot is being seriously abused here. :)
17:55:04 <omnId> I was hoping 0 * NaN = NaN, so I could disprove product (0 : xs) = 0
17:56:58 <centrinia> That's weird, ghci-6.9.20071018 says that 0*(1/0)  = NaN
17:57:17 <linxu> lamdabot!
17:57:30 <linxu> its been seized by aliens intelligence!
17:58:00 <seliopou> :t 1
17:58:02 <lambdabot> forall t. (Num t) => t
17:58:08 <centrinia> So does ghci-6.6.1
17:58:09 <seliopou> ...
17:58:11 <seliopou> Type?
17:58:24 <SamB_XP_> some kinda overzealous optimization?
17:58:39 <centrinia> :t (let x = f x in x)
17:58:41 <lambdabot> Not in scope: `f'
17:58:45 <centrinia>  :(
17:59:11 <omnId> :t (let x = ?f x in x)
17:59:12 <lambdabot> forall t. (?f::t -> t) => t
17:59:25 <omnId> :t \f -> let x = f x in x
17:59:27 <lambdabot> forall t. (t -> t) -> t
17:59:35 <SamB_XP_> ... 6.9 already???
17:59:53 <centrinia> I'm using the developmental version.
18:00:01 <SamB_XP_> well I realize it's a development version
18:00:14 <centrinia> But 0*(1/0) is also NaN in 6.6.1
18:00:14 <sieni> centrinia: I guess there were other situations, where lambadabot gave wrong answers in floating point arithmetic
18:00:16 <SamB_XP_> but has 6.8 been released yet?
18:00:30 <centrinia> Not that I know of.
18:00:35 <omnId> @version
18:00:35 <lambdabot> lambdabot 4p555, GHC 6.6 (Linux i686 2.66GHz)
18:00:35 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:00:37 <sieni> centrinia: certainly 0*(1/0) should be NaN
18:00:49 <centrinia> > 0*(1/0)
18:00:51 <lambdabot>  0.0
18:00:56 <centrinia> That's wrong.
18:01:00 <sieni> what was the other one, hmm...
18:01:45 * omnId tried 6.6, 0*NaN = NaN
18:02:09 <SamB_XP_> lambabot doesn't use GHCi though
18:02:14 <SamB_XP_> lambdabot uses GHC
18:02:22 <SamB_XP_> arg spelling
18:02:22 <sjanssen> ghc -O, to be more specific
18:02:49 <SamB_XP_> so is this an invalid optimization?
18:03:46 * omnId tried compiling 'main = print (0*(1/0))' in 6.6 -O2, got 0.0
18:04:07 <centrinia> 0_0
18:04:26 <Nafai> Is coercion (like fromIntegral) conceptually different from type casts?
18:04:40 <sieni> we noticed something strange before in lambdabot's floating point behavior
18:05:15 <omnId> Nafai: it changes the bytes around to fit the new format.  Casting just keeps them as is which could cause Bad Things(tm)
18:05:50 <centrinia> So don't coerce a tuple into a list?
18:05:57 <centrinia> Cast instead. :)
18:06:17 <omnId> centrinia: hm?
18:06:47 <centrinia> (1,True) :: [a] is different from ([a]) (1,True) :)
18:07:14 <sjanssen> (1, True) :: [a] is impossible
18:07:18 <omnId> doesn't C 'casting' often do conversion in cases like those?
18:07:19 <sieni> Nafai: well, fromIntegral is always safe
18:07:38 <centrinia> Yeah, that's why you want to cast it directly into a list [a].
18:08:03 <centrinia> omnId: For double to integers, almost always.
18:08:15 <omnId> unsafeCoerce (1,True) :: [a] I'd imagine would segfault.
18:08:40 <centrinia> > unsafeCoerce (1,True) :: [Bool]
18:08:47 <lambdabot>   Not in scope: `unsafeCoerce'
18:08:48 <centrinia> Okay, bad idea.
18:08:53 <omnId> no unsafe* in LB
18:09:03 <omnId> that would not be safe :)
18:09:43 <_achilles_> any good Monad exercises?
18:09:49 <_achilles_> or "challenges"
18:10:22 <centrinia> Find an arrow that does not correspond to a monad.
18:11:09 <_achilles_> I'm reading through "All about Monads" and "YAHT" and am starting to grasp it
18:11:32 <SamB_XP> _achilles_: make a monad?
18:11:34 <_achilles_> .....centrinia, it's that's for me, that's a little beyond me
18:11:43 <_achilles_> if that's*
18:11:58 <SamB_XP> then notice that you could replace it with a stack from the MTL
18:13:02 <omnId> Prelude> GHC.Prim.unsafeCoerce# (1,True) :: [a]
18:13:04 <omnId> []
18:13:05 <omnId> :)
18:13:23 <omnId> the (,) constructor is at the same place as the [] constructor for lists.
18:16:39 <dmwit> _achilles_: Try to work out what the Control.Monad functions do for each of the usual monads: [], ((->) r), IO, etc.
18:17:13 <dmwit> For example, what does "join" do for lists? for functions? for IO?
18:18:00 <_achilles_> that's an interesting challege
18:18:06 <_achilles_> not exactly what I had in mind
18:18:21 <omnId> dmwit: for example, type out the definition of liftM, then substitute the definitions of (>>=) and return for some monad you're interested in (((->) r) for example).  Do some beta substitution for the lambdas and simplify.
18:18:34 <omnId> @src liftM
18:18:35 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:18:48 <omnId> @undo  do { x1 <- m1; return (f x1) }
18:18:48 <lambdabot> (m1 >>= \ x1 -> return (f x1))
18:18:54 <omnId> @src (->) (>>=)
18:18:55 <lambdabot> f >>= k = \ r -> k (f r) r
18:18:59 <omnId> @src (->) return
18:18:59 <lambdabot> return = const
18:19:08 <omnId> put those parts together and simplify.
18:19:20 <_achilles_> fair enough
18:20:36 <dmwit> Another possible one: suppose you wanted each of your functions to return their return value and a string giving some "status" information.
18:20:49 <dmwit> So, functions would be :: a -> (b, String).
18:21:05 <dmwit> That's neat, but now functions like (a -> (b, String)) and (b -> (c, String)) aren't composable.
18:21:07 <seliopou> :t join (***)
18:21:12 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
18:21:15 <seliopou> meh
18:21:23 <dmwit> See if you can come up with a monad that would solve this problem by allowing you to "sequence" or "compose" these functions.
18:21:32 <_achilles_> sounds like State
18:21:37 <dmwit> Yep. =)
18:21:40 <_achilles_> ;)
18:21:46 <omnId> Writer, actually.
18:21:59 <dmwit> Stolen shamelessly from "You Could Have Invented Monads... and Maybe You Already Have".
18:22:05 <_achilles_> haha
18:22:20 <seliopou> :t join (&&&)
18:22:21 <omnId> @unmtl a -> Writer String b
18:22:22 <lambdabot> err: No applications
18:22:22 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
18:22:24 <_achilles_> I've been beating my head on monads a lot lately so I've "read it all"
18:22:37 <_achilles_> feels like anyway
18:22:59 <_achilles_> I know they say "nothing too special about monads"
18:23:04 <_achilles_> just a buzz word...blah blah blah
18:23:10 <dmwit> I found that implementing a few monads myself (as in YCHIMAMYAH) was what made it really click.
18:23:26 <omnId> gesundheit.
18:23:34 <_achilles_> I feel like I'm getting it and want to prove it by implementing something ..... useful
18:23:44 <_achilles_> omnld - heh
18:24:02 <dmwit> _achilles_: How about a parser monad?  You could call it, I don't know, Parsec or something. ;-)
18:24:06 <_achilles_> haha
18:24:20 <_achilles_> I started the "Write Yourself a Scheme" tutorial too.
18:24:36 <_achilles_> that uses a fair amount of Parsec....it did solidify a lot
18:24:48 <dmwit> (Actually, it's probably easier to do some kind of regular expression/lexer monad.)
18:25:48 <dmwit> I think the real problem with implementing useful monads is that they're already done, and better than what you could come up with on your own anyway. =P
18:28:20 * dmwit reads about zsh and thinks, "We need a Haskell shell."
18:28:40 <dmwit> We could do so much better than the current syntax, I think.
18:29:28 <dataangel> So you should use lazy pattern matches when pattern matching would cause evaluation which is "too soon." When is too soon? :P All the examples I've seen before are trivial unrealistic uses of stuff like let x = undefined ... :P
18:29:48 <mrd> typically when working with cyclic data
18:30:03 <mrd> it doesn't arise too often, let me see if i can think of something
18:30:03 <dmwit> > take 3 [1,2,3,undefined]
18:30:08 <lambdabot>  [1,2,3]
18:30:26 <omnId> If you have a useful parameterized type T with some functions return :: a -> T a, map :: (a -> b) -> T a -> T b, and join :: T (T a) -> T a, then T is likely a monad, (if these 3 functions act together in the correct way)
18:30:28 <mrd> by not arising too often, i mean, it's usually let-bound anyway
18:30:48 <dataangel> hrm...
18:34:32 <jaredj> dmwit: someone made hsh a while ago
18:35:18 <jaredj> i used to use zsh but it got annoying setting it everywhere, and now, everywhere besides home it's not really a choice
18:35:36 <jaredj> i'm afraid the same would be frequently true of an hsh
18:36:07 * dmwit has had no problem setting zsh as his shell anywhere he went
18:36:20 <jaredj> coo'.
18:36:34 <_achilles_> can't imagine hsh is part of any standard install
18:36:39 <jaredj> i admin for a bunch of users and end up typing things as them - including for loops, etc
18:36:41 <koala_man> how many new boxes do you connect to per day?
18:36:45 <jaredj> some of them use tcsh. :P
18:36:50 <dataangel> I understand the concept of circular references but I'm having trouble thinking of how you could run into trouble with a cyclical evaluation
18:37:06 <dmwit> jaredj: ouch =/
18:37:16 <jaredj> yeh. no for loops for me.
18:37:18 <dmwit> koala_man: Being on a University campus means I log on to several machines per day.
18:37:21 <jaredj> % bash
18:37:25 <mrd> @where tutorial
18:37:25 <lambdabot> http://www.haskell.org/tutorial/
18:37:29 <mrd> i think that has an example
18:38:06 <dmwit> koala_man: Though admittedly they are all pretty much identical, so either it works on all or none of them.
18:38:25 <koala_man> well, I wask asking jaredj
18:39:44 <jaredj> koala_man: i admin machines on our site, but there are others we connect to that i don't admin. some of those didn't even get around to switching me to bash
18:40:20 <dmwit> Can't you change yourself?
18:40:21 <jaredj> koala_man: the big problem is i type as other users, so i tend to use defaults (or worse)
18:41:07 <jaredj> besides if i get used to cool zsh commands and tab completions, i'll be as annoyed with bash as i am now with tcsh
18:41:15 <koala_man> I guess I can see the problem if you spend most of the day in and out of other people's accounts with two minute intervals
18:42:14 <jaredj> aand the linux contingent at my work needs as much unification as possible :/
18:43:05 <jaredj> but i shouldn't rain on people's shell parties
18:43:29 <_achilles_> ha
18:43:48 <_achilles_> were it the year 1200, many wars would be fought over shells
18:44:11 <_achilles_> bash, csh, zsk, ksh! RRRRRRRRAHHHHHHHHHHHHHHHHHHHH!!!!!!!!!!!!!
18:44:37 <jaredj> gesundheit. gesundheit. gesundheit. gesundheit. argh!
18:44:48 <jaredj> :)
18:44:56 <_achilles_> please excuse my allergies
18:45:56 <_achilles_> anyone here know anything about erlang?
18:46:39 <omnId> I know the "Erlang the Movie" clip on Youtube was awesome!  :)
18:46:59 <jaredj> lol
18:47:12 <_achilles_> sounds like I need to check it out
18:47:26 <Spark> erlang is an unconvincing new fashion in programming languages
18:47:37 <jaredj> NO WAY ITS THE GRATEST
18:47:54 <Spark> i remain unconvinced
18:47:58 <jaredj> I READ ABOUT IT ON REDDIT
18:48:12 <jaredj> yeah that's all really
18:48:44 <jaredj> shared-nothing, small messages and light threads are a good way to go, i think
18:49:00 <jaredj> inferno had that going on with limbo
18:49:03 <Spark> you can do that without erlang though
18:49:06 <jaredj> limbo is awesome.
18:49:15 <Spark> and then you get it without throwing away type safety
18:51:02 <SamB_XP> wait a minute, erlang has types?
18:51:03 <jaredj> limbo is much lighter than java, and less annoyingly concrete than c. and yes, typesafe channels.
18:51:14 <SamB_XP> oh.
18:51:15 <SamB_XP> right.
18:51:27 * SamB_XP is forgetful and misparsing
19:05:57 <_achilles_> erlang the movie....stunning
19:07:05 <_achilles_> hello robert
19:07:07 <_achilles_> hello mike
19:07:26 <_achilles_> hello joe
19:09:11 <omnId> hello robert
19:09:39 <_achilles_> great...
19:10:31 <_achilles_> as we'll see..........as we'll see, the call is left undisturbed
19:10:44 * Nafai tries to understand the IRC bot tutorial
19:11:38 <SamB_XP> mwahahaha
19:11:39 <_achilles_> so in all seriousness....erlang is a declarative language (like haskell) with multithreading/message passing?
19:12:11 <_achilles_> but no types
19:12:11 <chessguy> Nafai, you mean the roll your own irc bot tutorial?
19:12:24 * saz waves at seafoodX
19:12:28 <Nafai> chessguy: Yeah
19:13:03 * SamB_XP wrote @google instead. well, okay, so roll-your-own irc bot wasn't around yet at the time, and he actually did it because people kept telling him to whenever he complained that there wasn't one yet...
19:13:21 <chessguy> Nafai, what's up?
19:13:56 <Nafai> Trying to understand this part specifically: "do s <- init `fmap` io (hGetLine h)
19:14:26 <chessguy> ok
19:14:36 <mgsloan> last time I looked at erlang, it looked a bit crazy, at least with regards to how data is passed.  iirc it's pretty much just passing numbers
19:14:45 <chessguy> hGetLine h gets the line from the handle, h
19:14:48 <dons> Nafai: its lifting init to become a monadic function, and applying that to the getline
19:15:07 <omnId> that's 'do x <- io (hGetLine h) ; let s = init x ; ... '
19:15:08 <dons> so its basically chomping the input line, ala perl
19:15:26 <dons> the use of fmap there is an idiom
19:15:39 <_achilles_> yumyumyum
19:15:39 <shachaf> dons: Maybe you can replace it with (<$>)?
19:15:42 <_achilles_> chompchompchomp
19:15:59 <shachaf> dons: Also, it's closer to Perl's chop, I think.
19:16:12 <omnId> do s <- io (hGetLine h >>= return . init) -- does the same.
19:16:15 <SamB_XP> shachaf: what difference can an m make?
19:16:18 <Nafai> Yeah, I'm trying to understand how fmap works
19:16:36 <omnId> @src IO fmap
19:16:36 <lambdabot> fmap f x = x >>= (return . f)
19:17:03 <_achilles_> @src [] mapM
19:17:03 <lambdabot> Source not found.
19:17:08 <omnId> 'fmap f action' applies 'f' to 'action's result.
19:17:08 <shachaf> SamB_XP: I think (not a Perler) that chomp only chops if the last character is '\n'.
19:17:16 <omnId> @src mapM
19:17:16 <lambdabot> mapM f as = sequence (map f as)
19:17:32 <_achilles_> oh yeah
19:17:35 <jaredj> IT"S JOIN!!
19:17:43 <jaredj> er, right?
19:17:46 <omnId> jaredj: what is?
19:17:56 <dons> :t join
19:17:57 <_achilles_> shachaf....correct chomp is a specialized chop
19:17:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:17:59 <jaredj> oh some people argued for two hours over two functions
19:18:04 <jaredj> :t mapM
19:18:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:18:13 <jaredj> :t fmap
19:18:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:18:49 <jaredj> meh something about monads being functors, nm.
19:18:59 <omnId> fmap = liftM = liftA = (<$>) -- (modulo contexts)
19:18:59 <Nafai> Okay, another part I'm not understanding
19:19:00 <shachaf> jaredj: Are you thinking of liftM?
19:19:00 <jaredj> you had to be there
19:19:09 <Nafai> What does (const $ return ()) do?
19:19:11 <jaredj> IT"S FMAP!!
19:19:14 <jaredj> yeah that :)
19:19:18 <_achilles_> hello joe
19:19:21 <ivanm> @seen roconner
19:19:22 <lambdabot> I haven't seen roconner.
19:19:23 <jaredj> @fish liftM
19:19:24 <lambdabot> Maybe you meant: flush list
19:19:24 <shachaf> Nafai: It's equivalent to (\_ -> return ())
19:19:25 * omnId pokes jaredj hard in the ribs
19:19:34 <jaredj> @trout fmap
19:19:34 <lambdabot> Unknown command, try @list
19:19:37 <jaredj> what?
19:19:42 * jaredj shuts up
19:19:55 * _achilles_ cheers
19:20:20 <dons> :t init <$> getLine
19:20:22 <lambdabot> IO [Char]
19:20:28 <dons> much nicer, isn't it.
19:20:33 <ivanm> @seen roconnor
19:20:33 <lambdabot> I saw roconnor leaving #haskell and #haskell-blah 4h 39m 47s ago, and .
19:20:40 <dons> we should give the applicative functor crew an award
19:21:06 <ivanm> Looking through some code I found on the net, what does "default" do with an imported module?
19:21:27 <dons> sjanssen: i wonder if we could clean up some of the liftMs and fmaps with <$>
19:21:30 <dons> in xmonad.
19:21:36 <dons> ivanm: it sets the type defaulting
19:21:49 <ivanm> hmmm... well, it doesn't seem to work in this case...
19:21:51 <sjanssen> I don't really call <$> "cleaning"
19:21:57 <dons> :t <$
19:21:59 <lambdabot> parse error on input `<$'
19:22:00 <shachaf> Maybe (.) . fmap shoud have a nice name?
19:22:03 <dons> :t (<$)
19:22:05 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
19:22:19 <dons> :t <**>
19:22:21 <lambdabot> parse error on input `<**>'
19:22:25 <dons> :t (<**>)
19:22:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
19:22:37 <ivanm> I'm looking at David Lester's exact real arithmetic implementation... I don't know if it's because it was written for Haskell 1.2, but it seems to be using Floating rather than his CReal :s
19:22:52 <omnId> @type (.) . fmap
19:22:54 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a1 -> b) -> (a -> f a1) -> a -> f b
19:22:57 <dons> so it would be defaulting to somethings
19:23:05 <ivanm> and he's using the function (:+), which I can't seem to find with hoogle :s
19:23:10 <omnId> @type liftM2 liftM
19:23:11 <shachaf> sjanssen: Do you think `fmap` is nicer than <$>?
19:23:12 <lambdabot> forall a1 r (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 (a1 -> r) -> m1 (m a1) -> m1 (m r)
19:23:17 <shachaf> ivanm: Complex, maybe?
19:23:24 <omnId> @type \f g x -> liftM2 liftM f g x
19:23:26 <lambdabot> forall t a1 r (m :: * -> *). (Monad m, Monad ((->) t)) => (t -> a1 -> r) -> (t -> m a1) -> t -> m r
19:23:26 <sjanssen> shachaf: I prefer prefix
19:23:43 <ivanm> shachaf: in what respect? for (:+) ?
19:23:54 <shachaf> ivanm: Yes.
19:23:58 <omnId> @index (:+)
19:23:59 <lambdabot> Data.Complex
19:24:10 <ivanm> so why doesn't hoogle find it?
19:24:11 <dons> fmap's not an intuitive name though
19:24:21 <ivanm> @doc Data.Complex
19:24:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Complex.html
19:24:28 <dons> :t many
19:24:29 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
19:24:32 <shachaf> ivanm: It has a problem with some characters.
19:24:45 <dons> mm. lots of good stuff in Control.Applicative I should learn more thoroughly
19:24:48 <sjanssen> dons: I think it's very intuitive, especially the "map" part
19:24:50 <shachaf> sjanssen: In some cases, prefix is nicer.
19:25:09 <dons> only if you think of monadic containers :)
19:25:13 <shachaf> sjanssen: But what's wrong with infix?
19:25:20 <shachaf> > (+1) $ 5
19:25:22 <lambdabot>  6
19:25:28 <shachaf> > (+1) <$> Just 5
19:25:29 <lambdabot>  Just 6
19:25:32 <dons> fmap init getLine  / init <$> getLine
19:25:36 <dons> the latter is easier on the outsider
19:25:47 <sjanssen> dons: why is it easier on the outsider?
19:25:56 <dons> it looks like a pipe?
19:26:00 <omnId> dons: once they're familiar with (<$>) anyway.
19:26:00 <sjanssen> dons: both "fmap" and "<$>" are magical names to then
19:26:04 <sjanssen> s/then/them
19:26:12 <dons> prefix is even more confusing though
19:26:18 <sjanssen> why?
19:26:34 <dons> its not clear things compose with fmap
19:26:50 <omnId> > pure (+1) <*> Just 5
19:26:51 <lambdabot> Terminated
19:27:04 <omnId> o.O
19:27:29 <omnId> > return (+1) `ap` Just 5
19:27:30 <lambdabot>  Just 6
19:27:35 * SamB_XP thinks he prefers prefix for fmap
19:27:42 <Nafai> Where is 'asks' defined?
19:27:44 <sjanssen> I really hate `fmap`
19:27:50 <omnId> @index asks
19:27:51 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
19:27:56 <SamB_XP> I just don't undesrtand `fmap`
19:28:00 <shachaf> Is this using the Arrow pure?
19:28:00 <dons> sjanssen: i saw you reverting my commits!
19:28:05 <SamB_XP> I mean sure I understand it when you go and explain it
19:28:06 <dons> i want to start  the pro `fmap` faction
19:28:08 <shachaf> > return (+1) <*> Just 5
19:28:08 <sjanssen> dons: which?
19:28:10 <lambdabot>  Just 6
19:28:11 <SamB_XP> but it sure isn't easy to READ
19:28:30 <_achilles_> <*> ? liftM
19:28:30 <dons> then again, I'm from the school of (`mapM` [1..10]) $ \n -> do
19:28:35 <shachaf> dons: Pro-`fmap`? Why?
19:28:38 <omnId> > pure (+1) <*> Just 5
19:28:39 <lambdabot> Terminated
19:28:39 <SamB_XP> dons: I will take the con `fmap` faction
19:28:42 <_achilles_> I'm new, I don't know all this crazy <!(@#*&@(#*!&> syntaxes
19:28:48 <dons> it takes the syntactic position of a pipe |
19:28:59 <dons> so thus breaks up the sentence more clearly for the reader
19:29:00 <shachaf> > Control.Applicative.pure <*> Just 5
19:29:01 <lambdabot>  Couldn't match expected type `(->) a' against inferred type `Maybe'
19:29:02 <_achilles_> syntax***
19:29:06 <shachaf> > Control.Applicative.pure (+1) <*> Just 5
19:29:07 <lambdabot>  Just 6
19:29:08 <dons> I assume people want to read my code :)
19:29:13 <dons> whereas prefix is no better than lisp.
19:29:15 <ivanm> @ask roconnor Do you still have the patches you made for David Lester's CReal code lying around? It doesn't seem to work for me :s
19:29:15 <lambdabot> Consider it noted.
19:29:16 <dons> and we all know lisp is bad
19:29:22 <ivanm> why is lisp bad?
19:29:30 <sjanssen> dons: if you really want infix, you should use an operator
19:29:34 <omnId> > typeOf (let x = pure (+1) in x)
19:29:34 <lambdabot> Terminated
19:29:37 <sjanssen> I think most uses of `foo` functions are bad
19:29:39 <SamB_XP> dons: prefix form may be non-ideal, but `fmap` is worse
19:29:41 <shachaf> dons: Can I @quote you on that? :-)
19:29:53 <shachaf> SamB_XP: Sure, but is <$>?
19:30:01 <SamB_XP> functions that are made to be `infix` are okay...
19:30:04 <SamB_XP> like `on`
19:30:09 <shachaf> SamB_XP: Actually, why is `fmap` worse?
19:30:10 <LoganCapaldo> `mod`
19:30:22 * shachaf has gotten used to reading functions either way.
19:30:45 <shachaf> I don't think of most functions as being intended to work one way or the other.
19:30:48 <LoganCapaldo> mod x y incurs a cache miss for me ;)
19:30:53 <SamB_XP> shachaf: well, what would you do if I said f `map` xs
19:31:04 <shachaf> SamB_XP: I wouldn't object.
19:31:10 <SamB_XP> crazies!
19:31:10 <shachaf> > (+1) <$> [1,2,3,4,5]
19:31:12 <lambdabot>  [2,3,4,5,6]
19:31:19 <SamB_XP> that looks reasonable to me
19:31:32 <shachaf> SamB_XP: My example?
19:31:36 <SamB_XP> the <$>
19:31:40 <shachaf> SamB_XP: So your problem is with the ``?
19:32:05 <SamB_XP> my problem is with the use of `` on names that weren't intended for such use, I guess
19:32:14 <omnId> > (<$>) (+1) [1,2,3,4,5] -- /me is evil for its own sake :D
19:32:16 <lambdabot>  [2,3,4,5,6]
19:32:20 <_achilles_> > map (+1) [1,2,3,4,5]
19:32:21 <lambdabot>  [2,3,4,5,6]
19:32:30 <_achilles_> one's monadic the other's not?
19:32:51 <omnId> _achilles_: (<$>) and fmap are more general, they can be used with different types.
19:32:55 <dons> sjanssen: well I just suggested <$> :)
19:32:58 <omnId> @src [] fmap
19:32:58 <lambdabot> fmap = map
19:33:01 <LoganCapaldo> no the monadic one would be liftM (+1) [1,2,3,4,5]
19:33:07 <omnId> but []'s fmap is just map, yes :)
19:33:08 <shachaf> _achilles_: Not monadic, just functoric. :-)
19:33:16 <sjanssen> dons: I hate <$> slightly less than `fmap`
19:33:26 <omnId> > liftM (+1) [1,2,3,4,5]
19:33:27 <lambdabot>  [2,3,4,5,6]
19:33:34 <_achilles_> ha
19:33:36 <sjanssen> I also hate liftM
19:33:42 <omnId> sjanssen: that's progress :D
19:33:46 <_achilles_> thanks for the distinction shachaf
19:33:53 <SamB_XP> sjanssen: why do you hate liftM?
19:34:02 <LoganCapaldo> cause it smells of cabbage
19:34:02 <SamB_XP> do you hate newtype?
19:34:08 <SamB_XP> do you hate data?
19:34:10 <SamB_XP> how about type?
19:34:15 <_achilles_> i hate data
19:34:17 <sjanssen> newtype, type and data are fine :)
19:34:18 <_achilles_> ;)
19:34:29 <SamB_XP> how about Either
19:34:31 <dons> he loves prefix fmap above all else, but no one knows why
19:34:32 <SamB_XP> do you hate Either?
19:34:32 <mgsloan> liftM / fmap aren't keywords
19:34:33 <shachaf> > (\f m -> do { x <- m; return (f x) }) (+1) [1,2,3,4,5]
19:34:35 <lambdabot>  [2,3,4,5,6]
19:34:38 <_achilles_> not the key word, just the stuff we waste all our time "processing"
19:34:38 <dons> must be a secret lisp programmer :)
19:34:44 * dons `ap` dinner
19:34:49 * dons <* dinner
19:34:50 <sjanssen> SamB_XP: I think "mapping" a function over a structure is more intuitive than "lifting" a function into some Monad
19:35:01 <omnId> dons: ap = (<*>)
19:35:04 <SamB_XP> sjanssen: what do you do with liftM2?
19:35:07 <shachaf> dons: Do you mean (<*>)?
19:35:11 <sjanssen> liftM2 is fine
19:35:12 <LoganCapaldo> funny, I think the second one is more intuitive
19:35:18 <shachaf> SamB_XP: Surely you mean liftA2? :-)
19:35:20 <ivanm> @tell roconnor Never mind, I worked it out... I misunderstood what it was doing (though had to change Complex to Data.Complex)
19:35:20 <lambdabot> Consider it noted.
19:35:30 <_achilles_> well, playing devil's advocate, I'll agree with Logan
19:35:32 <LoganCapaldo> my brain doesn't work like sjanssen's. sad face :(
19:35:32 <SamB_XP> I like liftM because it goes nice with liftM2, if for no other reason
19:35:36 <sjanssen> also, liftM only exists because of poor decisions with the Monad/Functor hierarchy
19:35:41 <SamB_XP> sjanssen: what do you say to that?
19:35:44 <omnId> dons ::Applicative f =>  f (Food -> Full)
19:35:54 <Olathe> Mmmm...fooood.
19:35:56 <omnId> dinner :: Applicative f => f Food
19:35:57 <sjanssen> SamB_XP: I think it's a reasonable argument
19:35:58 <LoganCapaldo> (I also think of fmap as lifting the function into the functor)
19:36:02 <shachaf> Maybe if it was called map, map2 would be a valid name?
19:36:10 <shachaf> Even if it was only for Applicatives.
19:36:11 <sjanssen> SamB_XP: though I argue that liftM and liftM2 are very different beasts
19:36:23 <sjanssen> SamB_XP: liftM is functorial, liftM2 is applicative
19:36:30 <SamB_XP> sjanssen: perhaps
19:36:48 <sjanssen> shachaf: hmm, that's an interesting idea
19:36:56 <SamB_XP> but still
19:37:02 <SamB_XP> I do like shachaf's suggestion
19:37:10 <omnId> you need some kind of joining or apping to go from f (a->b) and f a to f b.
19:37:10 <jaredj> fmap is fricative
19:37:11 <Olathe> functorial f = f . (functorial (f - 1))
19:37:37 <omnId> Olathe: needs instance Num (a -> b)
19:37:44 <SamB_XP> @type let functorial f = f . (functorial (f - 1)) in functorial
19:37:46 <lambdabot> forall c a. (Num (c -> c)) => (c -> c) -> a -> c
19:38:04 <ivanm> With the "default" keyword, is there a way of saying that - for example - all values of type (Integral a) should be Int ?
19:38:18 <ivanm> just having "default (Int)" doesn't seem to work
19:38:31 <SamB_XP> ivanm: what's happening?
19:39:22 <shachaf> Is there a reason haskell.org doesn't link to the report?
19:39:45 <Olathe> functorial id = id
19:39:50 <LoganCapaldo> why should it? It's not haskell.org's job to provide you with links
19:39:50 <omnId> http://www.haskell.org/onlinereport/decls.html#sect4.3.4
19:39:51 <lambdabot> Title: The Haskell 98 Report: Declarations
19:40:31 <ivanm> SamB_XP: well, I'm trying out this exact real arithmetic module, which for its example program has "default (CReal)" (where CReal is an instance of Floating) ... but all floating values are defaulting to float rather than CReal
19:41:16 <omnId> wouldn't that complain that CReal isn't in Integral?
19:41:25 <omnId> (or is it?)
19:41:41 <ivanm> omnId: no, I wanted Floating.... for some reason I just used integral as an example
19:41:50 <ivanm> strange thing is, it works now, but wouldn't before :s
19:43:26 <_achilles_> ivanm, you changed something :)
19:43:43 <ivanm> heh, maybe....
19:44:15 <ivanm> oh, wait, if I do :t pi, it still just labels it as Floating a... must just use it as CReal, whereas I expected it to state that pi was of type CReal
19:44:23 <ivanm> @slap myself
19:44:24 * lambdabot smacks myself about with a large trout
19:45:49 <Olathe> @slap all the people in northern Antarctica
19:45:49 * lambdabot beats up all the people in northern Antarctica
19:46:03 <_achilles_> *ouch*
19:46:25 <Pseudonym> ?slap all humans
19:46:26 * lambdabot pulls all humans through the Evil Mangler
19:47:07 <LoganCapaldo> woah
19:47:15 <_achilles_> rude
19:47:19 <LoganCapaldo> thats messed up lb
19:47:20 <ivanm> lambdabot is getting nasty in her old age :p
19:47:23 <omnId> gah!  The horrible pain!
19:47:48 <omnId> But I'm running quite zippy now!  :D
19:48:09 <omnId> Misplaced a few vital organs, though
19:48:10 <Olathe> @yow
19:48:10 <lambdabot> I smell like a wet reducing clinic on Columbus Day!
19:48:15 <_achilles_> help i'm trapped in IO
19:48:15 <_achilles_> lambdabot: IO _achilles_
19:48:22 <LoganCapaldo> Hi, nice to meet you my nam eis CXX$LOGAN1279CAPALDO_VOID_$@
19:48:44 * LoganCapaldo doesn't actually know what mangled names out of the evil mangler look like
19:48:46 <SamB_XP> what?
19:48:49 <Olathe> _achilles_ >> earth
19:48:59 <_achilles_> hooray!
19:49:04 <omnId> LoganCapaldo: it's an object code mangler, not a name mangler
19:49:08 <SamB_XP> LoganCapaldo: you look like you were trying to exploit shell script!
19:49:21 <LoganCapaldo> oh boo
19:49:29 <SamB_XP> LoganCapaldo: the z-encoding is not performed by the evil mangler, it's true
19:49:37 <SamB_XP> that will remain with us when the evil mangler is no more
19:49:39 <LoganCapaldo> reality has ruined my joke
19:49:48 <omnId> LoganCapaldo: so it'd move your eyeball to the back of your shoulder, for example.
19:50:05 <omnId> swap and arm with a leg.
19:50:07 <SamB_XP> LoganCapaldo: you should pretend that was some kind of an attempt to exploit shell script
19:50:10 <omnId> the usual
19:50:11 <ivanm> LoganCapaldo: that's what you get for playing with reality! :p
19:50:26 <SamB_XP> LoganCapaldo: then you can salvage the humour
19:50:41 <_achilles_> all is lost
19:50:52 <omnId> @quote lambdabot
19:50:52 <lambdabot> lambdabot says: @quote lambdabot
19:51:07 <_achilles_> @yow
19:51:07 <lambdabot> ... ich bin in einem dusenjet ins jahr 53 vor chr ... ich lande im
19:51:07 <lambdabot> antiken Rom ...  einige gladiatoren spielen scrabble ... ich rieche
19:51:07 <lambdabot> PIZZA ...
19:51:19 <_achilles_> yipe
19:52:02 <_achilles_> *I am a jelly doughnut*
19:52:05 <SamB_XP> @babel de en ich bin in einem dusenjet ins jahr 53 vor chr
19:52:06 <lambdabot>   I am in one dusenjet in the year 53 forwards chr
19:52:31 <SamB_XP> @babel de en ich lande im antiken Rom
19:52:31 <lambdabot>   I land in antique Rome
19:52:46 <LoganCapaldo> Something about I was in the year 53 before (after?) christ, I landed in ancient rome, the gladiators were playing scrabble
19:52:49 <SamB_XP> @babel de en einige gladiatoren spielen scrabble
19:52:49 <lambdabot>   some gladiatoren play scrabble
19:52:54 <LoganCapaldo> and then something about pizza
19:53:08 <SamB_XP> @babel de en ich rieche
19:53:08 <SamB_XP>  PIZZA
19:53:09 <_achilles_> @bable rieche
19:53:09 <lambdabot>   I smell
19:53:09 <lambdabot>   bzzt.
19:53:11 <LoganCapaldo> i think i need pzza
19:53:22 <SamB_XP> @babel de en ich rieche PIZZA
19:53:23 <lambdabot>   I smell PIZZA
19:53:29 <_achilles_> yummy
19:53:48 <Olathe> @babel de en der Hummer des Todes
19:53:48 <lambdabot>   the lobster of death
19:53:53 <LoganCapaldo> my german is lousy and rusty :)
19:53:56 <_achilles_> hahah
19:54:01 <monochrom> did they play English scrabble or Latin scrabble?
19:54:01 <SamB_XP> babel is so lame not to know gladiators
19:54:09 <SamB_XP> monadonous: German, clearly!
19:54:13 <ddarius> ich brauche
19:54:17 <shapr> @yow !
19:54:17 <lambdabot> I didn't order any WOO-WOO ... Maybe a YUBBA ... But no WOO-WOO!
19:54:22 <SamB_XP> er.
19:54:25 <SamB_XP> monochrom:
19:54:38 <SamB_XP> I gots to get used to typing four letters now :-(
19:54:44 <_achilles_> wow.
19:55:05 <monochrom> monadonous is a great greek name. :)
19:56:05 <Olathe> Zeus is a nice one, too.
19:56:57 <LoganCapaldo> Man I am  tired
19:57:02 <LoganCapaldo> bed time
19:57:05 <_achilles_> so I hate to break up the great conversation about evil manglers and greek names, but where does one learn about the crazy <$>-like operators (other than hoogle)
19:57:19 <dons> ?docs Control.Applicative
19:57:19 <lambdabot> Control.Applicative not available
19:57:19 * LoganCapaldo schlafens
19:57:23 <dons> read the base library, basically
19:57:25 <TSC> There's some paper on applicative functors
19:57:32 <ddarius> @google Effectful programming with applicative functors
19:57:33 <ddarius> ?
19:57:35 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
19:57:35 <lambdabot> Title: Applicative Programming with Effects
19:57:39 <ddarius> There we go.
19:57:43 <dons> ?source Control.Monad
19:57:44 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
19:57:50 <lasts> @pl (\x -> max x . Just)
19:57:50 <lambdabot> (. Just) . max
19:57:50 <dons> http://darcs.haskell.org/packages/base/Control/Applicative.hs
19:58:27 <shachaf> @ty (\x -> max x . Just) -- Are you sure this is what you want?
19:58:28 <lambdabot> forall a. (Ord (Maybe a)) => Maybe a -> a -> Maybe a
19:58:43 <_achilles_> so <|> == `mplus`?
19:58:54 <ddarius> @src (<|>)
19:58:55 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:58:57 <omnId> _achilles_: for a WrappedMonad, yes
19:59:13 <_achilles_> hmm
19:59:20 <LoganCapaldo> I thought <|> was left biased choice...
19:59:42 <LoganCapaldo> waiy
19:59:50 <LoganCapaldo> Im asleep
19:59:53 <LoganCapaldo> nvm
20:00:04 <omnId> instance MonadPlus m => Alternative (WrappedMonad m) where
20:00:05 <omnId> 	empty = WrapMonad mzero
20:00:05 <omnId> 	WrapMonad u <|> WrapMonad v = WrapMonad (u `mplus` v)
20:00:17 <lasts> shachaf, hm ?
20:00:29 <_achilles_> instance Alternative Maybe where
20:00:29 <_achilles_> 	empty = Nothing
20:00:29 <_achilles_> 	Nothing <|> p = p
20:00:29 <_achilles_> 	Just x <|> _ = Just x
20:00:41 <shachaf> lasts: I just thought that was an odd function.
20:00:48 <shachaf> lasts: (Ord (Maybe a)) => ...
20:00:52 <lasts> oh, sure it is :D
20:01:08 <_achilles_> isn't that the same definition for Maybe's mplus?
20:01:15 <_achilles_> @src Maybe mplus
20:01:15 <lambdabot> Nothing `mplus` ys  = ys
20:01:16 <lambdabot> xs      `mplus` _ys = xs
20:01:26 <omnId> _achilles_: 'twould seem so
20:02:07 <_achilles_> o-bee-kay-bee
20:05:22 <omnId> \x y -> max <$> x <*> Just y
20:05:30 <omnId> @ty \x y -> max <$> x <*> Just y
20:05:32 <lambdabot> forall a. (Ord a) => Maybe a -> a -> Maybe a
20:06:06 <dons> anyone know what the debian ghc package is called?
20:06:15 <dons> e.g. if we want to get it from apt-get ?
20:06:21 <jaredj> dons: ghc6
20:06:41 <dons> thanks
20:07:00 <dons> i.e. apt-get install ghc6 ?
20:07:09 <shachaf> dons: Yes.
20:16:52 <conal> anyone know where url.el (for Emacs) is?  It's used by hpaste.el.
20:18:37 <thoughtpolice> http://www.koders.com/lisp/fidB46CCCA8D57FBD093BAF6E08289CFB4DA7624B2B.aspx?s=TV+Raman
20:18:39 <lambdabot> Title: Koders Code Search - url.el - Lisp - GPL, http://tinyurl.com/269nzn
20:18:48 <thoughtpolice> that's the actual file; i don't know about any other dependencies you might need
20:19:18 <conal> thoughtpolice: thanks.  hm.  that file requires several others (url-vars, url-cookie, etc).
20:19:32 <conal> i see.  they're all listed on that page.
20:19:51 <thoughtpolice> conal: also, according to this page the emacs 'url loading package' (not sure if that's exactly it, though) is included with emacs: http://www.gnu.org/software/url/
20:19:52 <lambdabot> Title: Emacs URL Package
20:20:47 <thoughtpolice> conal: aha!
20:20:49 <thoughtpolice> http://cvs.savannah.gnu.org/viewvc/emacs/lisp/url/?root=emacs
20:20:50 <lambdabot> Title: [emacs] Index of /emacs/lisp/url
20:20:58 <thoughtpolice> it is included in the default distro, it seems. :)
20:21:21 <conal> thoughtpolice: jackpot!  :)
20:22:49 <_achilles_> @src mapMaybe
20:22:49 <lambdabot> Source not found. I feel much better now.
20:25:10 <omnId> _achilles_: do you want fmap?
20:25:26 <omnId> > fmap (+1) (Just 5)
20:25:28 <lambdabot>  Just 6
20:25:35 <shachaf> omnId: That's not mapMaybe.
20:25:45 <omnId> @type mapMaybe
20:25:47 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
20:25:49 <omnId> ah
20:25:57 <ddarius> @index mapMaybe
20:25:57 <lambdabot> Data.Maybe
20:26:02 <shachaf> > mapMaybe (\x -> if even x then Just x + 1 else Nothing) [1,2,3,4,5,6]
20:26:04 <lambdabot>   add an instance declaration for (Num (Maybe a))
20:26:04 <lambdabot>     In the expression: if e...
20:26:08 <ddarius> When'd that get put in there?
20:26:11 <shachaf> > mapMaybe (\x -> if even x then Just (x + 1) else Nothing) [1,2,3,4,5,6]
20:26:12 <lambdabot>  [3,5,7]
20:26:28 <ddarius> Presumably it's catMaybes . map f ?
20:26:50 <omnId> @type (catMaybes .) . map
20:26:52 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
20:26:55 <_achilles_> yup
20:26:56 <omnId> presumably
20:27:19 <omnId> @source Data.Maybe
20:27:19 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
20:28:52 <_achilles_> catMaybes . map f seconded
20:29:50 <_achilles_> possibly a dumb question: what (if any) kind of concurrency is provided in Haskell?
20:30:01 <SamB_XP> threads
20:30:07 <SamB_XP> the nicest threads you ever did see
20:30:15 <shub> I ran two instances of ghci once
20:30:19 <_achilles_> haha
20:30:24 <_achilles_> well played shub
20:30:31 <omnId> SamB_XP: and the green grass grows all around all around?
20:30:34 <dons> _achilles_: much concurrency, being pure and all
20:30:39 <dons> we like to speculate our thunks :)
20:30:52 <dons> ?docs Control.Concurrent
20:30:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
20:31:10 <_achilles_> hmmm
20:31:19 <_achilles_> cool thanks for the info dons
20:31:23 <thoughtpolice> _achilles_: lightweight, preemptive and scalable (across multiple cores) :)
20:31:37 <ddarius> _achilles_: GHC provides many different types of and approaches to concurrency approaches.
20:32:00 <_achilles_> rad
20:32:17 <_achilles_> dare I mention -- vs. erlang
20:32:21 * omnId slowly approaches ddarius's approacheses.
20:32:27 <_achilles_> I'm trying to get a feel for the rift between erlang and haskell
20:33:05 <jaredj> were the erlang people aiming for a functional language?
20:33:15 <ddarius> Chans and forkIO provide something roughly like basic Erlang
20:33:38 <ddarius> jaredj: Not in particular.  It used to be a bit more Prology.
20:33:45 <ddarius> (Though still it was never a logic language.)
20:33:53 <dons> there's a bunch of other things haskell has, that erlang doesn't: speed, nested data parallelism, transactional memory
20:34:08 <_achilles_> monads :)
20:34:09 <dons> haskell's always been a language for parallel programming
20:34:12 <Pseudonym> Purity.
20:34:18 <SamB_XP> dons: seriously?
20:34:21 <dons> well, specifically regarding concurrency and parallel programming
20:34:24 <Pseudonym> It's always been intended as one.
20:34:28 <SamB_XP> dons: even before the monadic revolution?
20:34:29 <ddarius> there's a bunch of other things erlang has, that haskell doesn't...
20:34:34 <dons> SamB_XP: yes, much much before
20:34:43 <dons> the first GHC version ran on a transputer, iirc
20:34:44 <Pseudonym> SamB: SPJ's book from 1987 mentions it.
20:34:49 <wli> GUM and Parallel Haskell were rather early.
20:34:58 <SamB_XP> the book that's written in miranda?
20:35:00 <Pseudonym> And, of course, that's based on earlier papers, not by him.
20:35:03 <Pseudonym> Yeah.
20:35:14 <ddarius> SamB_XP: Haskell didn't exist in 1987
20:35:17 <dons> http://groups.google.com/group/comp.lang.functional/msg/20a80be2e0c567f0?hl=en&
20:35:17 <Pseudonym> I think the idea goes back to Turner at least.
20:35:18 <lambdabot> Title: Haskell availability - comp.lang.functional | Google Groups, http://tinyurl.com/hga4o
20:35:21 <Pseudonym> Probably earlier.
20:35:27 <dons> `Good news: we are; we have a parallel implementation running on the
20:35:27 <dons> GRIP multiprocessor, with absolute wall-clock speedup over the same
20:35:27 <dons> programs running on a comparable uniprocessor'
20:35:42 <SamB_XP> so how did it mention GHC in connection with parallelism if therre was no Haskell yet?
20:35:46 <dons> Jun 12 1990
20:35:46 <Pseudonym> In fact, the original GHC project was called "GRASP".
20:35:57 <Pseudonym> It might even still be mentioned in the source.
20:36:07 <dons> it is
20:36:11 <Pseudonym> There you go.
20:36:15 <wli> Concurrent Clean (yes, there's a "Concurrent" in its name) is a chip off the same block.
20:36:22 <dons> ghc/compiler/deSugar/Match.lhs:% (c) The GRASP/AQUA Project, Glasgow University, 1992-1998
20:36:28 <Pseudonym> There you go.
20:36:54 <SamB_XP> GRASP/AQUA is a very funny name
20:36:57 <SamB_XP> if you think about it
20:36:58 <dons> there aren't any source files with earlier dates
20:37:00 <jaredj> heh
20:37:18 <ddarius> SamB_XP: Perhaps apropos though.
20:37:26 <SamB_XP> perhaps!
20:37:30 <Pseudonym> Yeah, 1992 was one of the last times that GHC could be completely rewritten.
20:37:30 <dons> this early thread is quite nice, http://groups.google.com/group/comp.lang.functional/browse_thread/thread/170572035915bbb6/20a80be2e0c567f0?hl=en%14a80be2e0c567f0
20:37:32 <lambdabot> Title: Haskell availability - comp.lang.functional | Google Groups, http://tinyurl.com/34fn4x
20:37:44 <dons> Pseudonym: yeah, it seems like that was the story.
20:38:47 <Pseudonym> I'm glad that SPJ noted in his OSCON talks that this idea was never really going to work as posed.
20:38:59 <Pseudonym> Even though it made a lot of intuitive sense at the time.
20:39:09 <Pseudonym> STM and data parallelism make MUCH more sense.
20:39:22 <cognominal_> @src fmap
20:39:23 <lambdabot> Source not found. My brain just exploded
20:39:25 <SamB_XP> as does `par`
20:39:32 <Pseudonym> And static scheduling will probably turn up sooner or later.
20:39:35 <dons> the new stuff on speculating thunks and using profiling to feed that back in seems promising
20:39:36 <Cale> @src Functor
20:39:36 <lambdabot> class  Functor f  where
20:39:37 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
20:39:55 <Pseudonym> Someone is going to discover, at some point in the next 10 years, that purity helps hard real-timeness.
20:39:56 <dons> also, it helps that we have widely available, performant multicores now
20:40:05 <SamB_XP> Pseudonym: undoubtedly
20:40:08 <dons> that's an interesting thought, Pseudonym. hmm
20:40:14 <Pseudonym> Laziness might not.
20:40:17 <Pseudonym> But purity will.
20:40:20 <SamB_XP> quite so
20:40:21 <dons> we need to revive Timber
20:40:36 <Pseudonym> dons: And it's not an original thought, either.
20:40:38 <SamB_XP> laziness is unlikely to help hard real-timeness
20:40:39 <Cale> Laziness helps compositionality though.
20:40:50 <dons> Pseudonym: right. e.g. Timber :)
20:40:51 <wli> Purity/laziness for instruction-level parallelism is out there, tooo.
20:40:56 <Pseudonym> Yeah.
20:40:56 <Cale> At least usable nonstrictness does.
20:41:13 <Pseudonym> I remember work on statically guaranteeing real-time performance from before that, though.
20:41:31 <Cale> I'm not sure I'd be willing to give up laziness in daily programming now.
20:41:40 <Pseudonym> Cale: Daily programming, no.
20:41:53 <wli> My daily programming is not in Haskell.
20:41:53 <dons> i'd be happy to drop into a strict subset for low level work
20:41:54 <SamB_XP> Cale: then don't become a programmer exclusively of hard-realtime things
20:41:55 <Pseudonym> But if you had to write a program that must meet its real-time guarantees or lives are lost...
20:42:01 <Cale> SamB_XP: hehe :)
20:42:04 <dons> think of the value semantics!
20:42:08 <dons> i mean, just think of them!
20:42:21 <SamB_XP> dons: what?
20:42:24 * dons channels qwe1234 and feels a little nauseous
20:42:45 <SamB_XP> oh, the call-by-value semantics?
20:42:47 <wli> Isn't there some mode of programming where lazy vs. strict doesn't matter in some sense?
20:43:03 <dons> non terminating programs?
20:43:07 <ddarius> Strongly normalizing programs.
20:43:21 <Pseudonym> Primitive recursion.
20:43:28 <wli> I think it has or had something to do with CPS but there was more to it.
20:43:33 <Pseudonym> However, lazy vs. strict always matters from the point of view of pragmatics.
20:43:43 <Pseudonym> Even in situations where it doesn't matter semantically.
20:43:47 <SamB_XP> programs that are finished executing before you hit enter
20:43:48 <ddarius> Well, if you CPS then the evaluation order of the language is irrelevant.
20:43:48 <wli> I saw it in the context of compilation.
20:44:10 <dons> yes, sometimes having bottoms in your types is annoying.
20:44:24 <dons> a lot of the time, actually
20:44:26 <dons> its strange
20:44:33 <ddarius> dons: I was about to say!
20:44:48 <dons> makes proofs hard, for example...
20:45:07 <ddarius> People are nowhere near ready to grasp the nettle of provably terminating programming.
20:45:17 <wli> Maybe CPS for realtime is a good idea when the language is lazy.
20:45:22 <hpaste>  conal pasted "QuickCheck, functions, and equality" at http://hpaste.org/3444
20:45:57 <conal> I'd like comments on that hpaste.  I'm starting to use QuickCheck.
20:46:08 <conal> inspired by dons's advertisements.
20:47:05 <ddarius> I can't wait for HPC.  It seems like a crucial ingredient to test-driven development.  A much more meaningful green bar.
20:47:18 <dons> why wait, it is here now!
20:47:19 <wli> ddarius: HPC?
20:47:31 <hpaste>  conal annotated "QuickCheck, functions, and equality" with "sample properties" at http://hpaste.org/3444#a1
20:47:44 <Cale> wli: Haskell program coverage.
20:47:55 <dons> conal: looks a lot like the stuff I used for Data.ByteString
20:48:11 <conal> The question is how to test equality between functions and between infinite structures.
20:48:14 <Cale> wli: It's a tool which shows you a highlighted version of your code which indicates which parts were actually exercised.
20:48:18 <conal> dons: oh yeah?  i'll take a look.
20:48:23 <wli> Nice.
20:48:42 <dons> conal: see the bottom of http://darcs.haskell.org/bytestring/tests/QuickCheckUtils.hs
20:48:51 <dons> and the properties, http://darcs.haskell.org/bytestring/tests/Properties.hs
20:48:59 <thoughtpolice> hpc looks awesome, but I could never get hmake to build properly so I'm just waiting until 6.8 :)
20:49:01 <dons> e.g. prop_concatBP       = L.concat      `eq1`  P.concat
20:49:41 <dons> conal: in particular, the Model class
20:49:49 <conal> dons: will do.
20:49:52 <ddarius> I too feel like waiting for 6.8.1 for that.
20:51:24 <xelxeba1> fellow friends of Haskell, are is there a better way to pattern match the argument in this function? foo ('f':'o':'o':c) = c
20:51:29 * thoughtpolice waits with bated breath
20:51:46 <thoughtpolice> xelxeba1: foo ("foo":xs) = xs ?
20:51:57 <shachaf> thoughtpolice: No.
20:52:03 <Cale> Is the HPC output for xmonad/contrib online somewhere? (at least I think that's the example I saw in the talk)
20:52:14 <shachaf> thoughtpolice: That's be :: [String] -> [String]
20:52:17 <dons> f xs | "foo" `isPrefixOf` xs = ...
20:52:58 <dons> Cale: you saw the hpc output for the core StackSet.hs module
20:53:11 <dons> and I speculated we should do it for the fairly untested contrib code
20:54:22 <conal> dons: i like the "Model" idea.
20:54:55 <xelxeba1> thanks dons
20:55:55 <dons> conal: at least that works nicely for types that have other types that model them well
20:56:52 <shubalub_> "We've completely changed the sematics of our monadic addition operator, h, without lifting a finger to edit it." -- I've heard things like that about operator overloading, but not in a positive way.
20:57:09 <conal> hey -- i didn't realize it was legal to import-qualified more than one module with the same qualifier (e.g., "as P").
20:57:31 * omnId didn't realize that either.
20:57:32 <ddarius> Haskell is filled with neat tricks.
20:57:34 <jaredj> It's not. Please step out of the car.
20:57:35 <shubalub_> Is it possible to redefine addition in Haskell?
20:57:44 <conal> jaredj: :)
20:57:51 <ddarius> shubalub_: Yes and no.
20:57:55 <omnId> shubalub_: it's possible to define a (+) operator of your own choosing.
20:58:06 <omnId> (+) is just a name.
20:58:42 <omnId> > let "blargh" + 5 = Left (); _ + _ = Right "what?" in "" + 0
20:58:44 <lambdabot>  Right "what?"
20:59:30 <omnId> not a terribly useful definition, that. :)
20:59:53 <xelxeba1> actually, I quite like it. . . very quirky
21:00:07 <omnId> @type let "blargh" + 5 = Left (); _ + _ = Right "what?" in (+)
21:00:09 <lambdabot> forall t. (Num t) => [Char] -> t -> Either () [Char]
21:01:32 <_achilles_> funky
21:01:39 <omnId> the Prelude provides a (+) in the Num class that several types implement.
21:02:43 <shachaf> @wiki Humor/1984
21:02:43 <lambdabot> http://www.haskell.org/haskellwiki/Humor/1984
21:02:51 <omnId> so you might get a name clash in some cases.
21:03:38 <omnId> @let x + y = x Prelude.* y -- mwahahaha
21:03:38 <lambdabot> <local>:10:194:     Ambiguous occurrence `+'     It could refer to either `+'...
21:03:46 * omnId is thwarted
21:04:09 <_achilles_> :(
21:04:39 <xelxeba1> > let 2 + 5 = 5 in 2 + 2
21:04:40 <lambdabot>   Non-exhaustive patterns in function +
21:04:49 <xelxeba1> whoops
21:04:53 <xelxeba1> > let 2 + 2 = 5 in 2 + 2
21:04:54 <omnId> you didn't define the (+) 2 2 case :)
21:04:54 <lambdabot>  5
21:05:15 <xelxeba1> yay! large values of 2
21:05:23 <_achilles_> > 2 + 2
21:05:24 <lambdabot>  4
21:05:32 <omnId> that's Prelude.+
21:05:56 <omnId> xelxeba1's (+) lived only in the context of the let expression.
21:06:04 <_achilles_> yeah
21:07:05 <omnId> @let x `div` 0 = 42; x `div` y = x `Prelude.div` y
21:07:06 <lambdabot> Defined.
21:07:08 <xelxeba1> obviously this whole 2 + 2 = 4 business is a bug in the Prelude, we should 'fix' it
21:07:21 * omnId redefines division by zero
21:07:32 <xelxeba1> > 4/0
21:07:34 <lambdabot>  Infinity
21:07:34 <shachaf> > 5 `div` 0
21:07:35 <lambdabot> Terminated
21:07:37 <shachaf> > 5 `div` 0
21:07:38 <lambdabot> Terminated
21:07:41 <shachaf> Hmm.
21:07:45 <omnId> awww
21:07:49 <omnId> > 5 `L.div` 0
21:07:51 <lambdabot>  42
21:07:55 <shachaf> omnId: Thwarted again!
21:07:56 <_achilles_> ha
21:07:57 <xelxeba1> yay!
21:08:09 * omnId shakes his fist at no one in particular
21:08:10 <shachaf> Who in their right mind would type `L.div` for division?
21:08:48 <omnId> shachaf: TEH CRAZY PEOPLES!!!
21:08:50 <mgsloan> yes, haskell needs to start using significant figures, so that 2 really means [1.5, 2.5)
21:09:10 <Pseudonym> Hey, I have to L.divide numbers every day!
21:09:23 <mgsloan> so then 2 + 2 = [3, 5)
21:09:51 <xelxeba1> @src L.div
21:09:51 <lambdabot> Source not found. I feel much better now.
21:10:05 <omnId>  @src is not so dynamic
21:10:17 <shubalub_> that would tend to mess up factorial examples, I think
21:10:50 <_achilles_>  scanl1 (*) [1..]
21:10:53 <_achilles_> :)
21:10:58 <xelxeba1> how do we dynamic-ify @src?
21:13:29 <wli> Interval arithmetic is not as useful as one might suppose. Better is to use a probability distribution.
21:13:49 <mgsloan> yeah, I was mostly joking :)
21:13:55 <Pseudonym> wli: Disagree.
21:13:57 <mgsloan> probability distributions would be sweet :)
21:14:13 <Pseudonym> Unlike probability distributions, interval arithmetic gives exact answers.
21:14:36 <wli> Pseudonym: That's fine. Carry around a support interval with your distribution.
21:15:10 <mgsloan> is there a nice representation of standard distributions which allows for stuff like multiplication?
21:15:19 <Pseudonym> What you said is "Interval arithmetic is not as useful as one might suppose."
21:15:21 <mgsloan> that would be rather impressive, I think
21:15:26 <Pseudonym> That's what I take issue with.
21:15:32 <mgsloan> eg, closed under multiplication
21:15:59 <wli> Pseudonym: I presumed the probability distributions to have compact support.
21:17:01 <shubalub_> http://wiki.tcl.tk/3018
21:17:04 <lambdabot> Title: everything is a string
21:17:07 <mgsloan> seems like it'd be very useful to have a probability distribution that's closed under lots of operations
21:17:37 <Pseudonym> That's the thing I found most annoying about Tcl.
21:17:50 <Pseudonym> The most important lesson I ever learned about computer science is "data has structure".
21:18:24 <wli> mgsloan: xy and x + y are well-studied cases.
21:18:35 <shubalub_> my data structures and algorithms professor is in the Tcl camp :/
21:18:36 <inono> what are some infiite list tricks you can only do with foldr
21:19:04 <sjanssen> > foldr (||) False (repeat True)
21:19:05 <lambdabot>  True
21:19:39 <Pseudonym> shubalub: The guy who was my data structures and algorithms lecturer is somewhat famous in that field.  He's no fan of Haskell, but he'd never say "everything is a string".
21:19:44 <inono> what is repeat True?
21:19:52 <jcreigh> > repeat True
21:19:53 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
21:19:57 <inono> ah
21:20:02 <inono> repeat x = x : repeat x ?
21:20:12 <_achilles_> yup
21:20:13 <Pseudonym> iono: More or less.
21:20:22 <Pseudonym> Actually more like: repeat x = let xs = x : xs in xs
21:20:29 <geezusfreeek> @pl \x -> x : repeat x
21:20:30 <lambdabot> ap (:) repeat
21:20:30 <Pseudonym> But the distinction isn't important for you.
21:20:36 <inono> why the distinction
21:20:42 <Pseudonym> Memory use.
21:20:47 <inono> meaning?
21:20:51 <Pseudonym> The linked list is actually stored as a cyclic data structure.
21:20:59 <Pseudonym> Which means it uses finite heap.
21:21:20 <mgsloan> wli - yeah, i suppose xy would be most useful
21:21:21 <inono> why cant you just do x : repeat x ?
21:21:34 <Pseudonym> Because that would leak more memory.
21:21:44 <Pseudonym> Don't worry about this.
21:21:53 <xelxeba1> I'm quite interested
21:21:55 <Pseudonym> It means the same thing, it just works a bit differently under the covers.
21:22:06 <inono> well you brought it up
21:22:10 <inono> curious minds wonder
21:22:13 <Pseudonym> Sure. :-)
21:22:18 <Pseudonym> ?src repeat
21:22:19 <lambdabot> repeat x = xs where xs = x : xs
21:22:23 <mgsloan> might be able to use some of the curve representations used in computational geometry to represent probability distributions
21:22:24 <_achilles_> how does one design code to work petter "under-the-covers"
21:22:24 <Pseudonym> There you go.
21:22:33 <_achilles_> should that be ghc(i)'s job?
21:22:40 <Pseudonym> achilles: Yes and no.
21:22:41 <_achilles_> better***
21:22:56 <Pseudonym> You're never really freed from pragmatic concerns, especially when you're writing a library.
21:22:56 <_achilles_> shouldn't***
21:22:57 <wli> mgsloan: No, you just represent the distribution by its parameters.
21:23:12 <Pseudonym> Because clients can't, in general, modify your library.
21:23:38 <shubalub_> I suppose everything is a string, at least if it's an instance of Show
21:23:57 <Pseudonym> That means functions aren't strings.
21:24:06 <inono> but.. its just a let
21:24:07 <mgsloan> wli - well, assuming those parameters make up a representation which is closed under multiplication..
21:24:26 <Pseudonym> inono: Yes, but the let is recursive.
21:24:28 <wli> mgsloan: Not sure which distribution to use for that right offhand.
21:24:29 <shubalub_> too bad, that would make dynamic @src easier
21:24:40 <Pseudonym> The thing is, the tail of the cons points back to the cons.
21:25:00 <mgsloan> I mean, could you take two normal curves offset and scaled, multiply, and get another normal curve..
21:25:13 <Pseudonym> It introduces a cycle.
21:25:28 <omnId> 'repeat x = x : repeat x' would behave the same if Haskell memoized.
21:25:40 <inono> doesnt it memoize?
21:25:48 <inono> i thought that was the whole point of call-by-need.
21:26:03 <Pseudonym> Nope.
21:26:16 <Pseudonym> The point of call-by-need is that the semantics are cleaner.
21:26:21 <omnId> it's not worth it in general.  Adds tons of memory use for things that might not be used more than once.
21:26:39 <Pseudonym> One example is that you can transparently memoise a function, and nothing changes apart from run-time and memory use.
21:26:49 <omnId> I should say, 'if GHC* memoized'
21:27:09 <inono> so.. it doesnt memoize? wouldnt that introduce eager semantics in places you dont want?
21:27:19 <Pseudonym> It doesn't memoise for you.
21:27:28 <Pseudonym> If that's what you meant.
21:27:32 <omnId> I believe Haskell doesn't have much to say about runtime behaviour
21:27:51 <inono> im puzzled as to how you can have call-by-need without memoization
21:27:53 <omnId> Haskell-the-language vs. GHC-the-implementation
21:27:57 <geezusfreeek> repeat x = x : repeat x is more like let xs = repeat x in x : xs ... which is different from repeat x = let xs = x : xs in xs because let represents a heap allocation
21:28:37 <geezusfreeek> notice how in the former version, that heap allocation is recursed, but it is not in the latter
21:29:28 <omnId> transpose former and latter.
21:29:30 <inono> sounds like relying on implementation details
21:29:52 <geezusfreeek> err, i think i was just too vague there
21:29:58 <omnId> which is perfectly acceptable for GHC's standard library :)
21:30:08 <geezusfreeek> s/recursed/repeated/
21:33:05 <omnId> in any case, 'repeat x = x : repeat xs' and 'repeat x = xs where xs = x : xs' are semantically equivalent.  Learning your semantics comes first before delving too far into runtime behavior.
21:33:07 * wli forgets what distribution you get from x + y where x, y have given distributions. Or x * y. Or whatever.
21:33:45 <geezusfreeek> yeah, the only reason i know this stuff is because of research into writing my own lazy language
21:33:58 <geezusfreeek> compiler, that is
21:34:04 <shachaf> omnId: 'repeat x = x : repeat xs' causes a "Not is scope" error. :-)
21:34:23 <omnId> grar
21:34:45 <geezusfreeek> shachaf, that should be 'repeat x = x : repeat x'
21:34:54 <newsham> shachaf: what is xs?
21:35:08 <shachaf> geezusfreeek: I know. :-)
21:35:16 <geezusfreeek> ah
21:35:28 <shachaf> newsham: Ask oI.
21:35:51 <geezusfreeek> prolly just a typo :)
21:36:05 <newsham> dont believe in xs, success is to give
21:37:27 <dmwit> :t fix . (:)
21:37:30 <lambdabot> forall a. a -> [a]
21:40:44 <bos> new inline operators are default infixl 9, right?
21:41:23 <omnId> I believe so
21:42:28 <omnId> "Any operator lacking a fixity declaration is assumed to be infixl 9"
21:42:34 <omnId> http://www.haskell.org/onlinereport/decls.html#sect4.4.2
21:42:35 <lambdabot> Title: The Haskell 98 Report: Declarations
21:44:49 * omnId defines 'infixr 1 ?; (?) x y z = if x then y else z', gets (cond ? exp1 $ exp2) expressions.
21:45:35 <newsham> wonder how they picked the number 9
21:45:40 <newsham> not exactly round
21:45:41 <shachaf> omnId: Using ($) may not be ideal.
21:46:16 <omnId> shachaf: maybe not, but it was available
21:46:26 <shachaf> You could have "f $ x ? y $ z $ q".
21:46:38 <shachaf> Hmm, that's possibly not a good example.
21:47:02 <bos> omnId: thanks
21:48:20 <bos> newsham: perhaps because it's the lowest precedence level, and wreaks least havoc on nearby uses of operators with defined fixities?
21:51:28 * omnId uses -ddump-parsed: Just (((f $ x) ? y) $ z) $ q
21:52:22 <inono> are there any foldr examples perhaps with division?
21:53:55 <newsham> http://www.cs.nott.ac.uk/~gmh/fold.pdf
21:56:35 <newsham> > foldr (\ch chs -> ch:'+':chs) [] "test"
21:56:38 <lambdabot>  "t+e+s+t+"
21:59:24 <omnId> > concatMap (:"+") "test"
21:59:26 <lambdabot>  "t+e+s+t+"
21:59:30 <omnId> @src concatMap
21:59:31 <lambdabot> concatMap f = foldr ((++) . f) []
21:59:34 <newsham> > let f ch chs = ch:'+':chs in 't' `f` ('e' `f` ('s' `f` ('t' `f` [])))
21:59:35 <lambdabot>  "t+e+s+t+"
22:00:51 <dmwit> > intersperse '+' "test"
22:00:52 <lambdabot>  "t+e+s+t"
22:00:58 <dmwit> almost
22:01:51 <dmwit> wait
22:01:53 <dmwit> ?src concat
22:01:53 <lambdabot> concat = foldr (++) []
22:01:57 <dmwit> Bah.
22:02:31 <dmwit> I've been replacing long (++) chains with concat [...] chains for readability and thinking, "I get readability and better speed at the same time!".
22:03:17 <newsham> ?src (++)
22:03:17 <lambdabot> (++) []     ys = ys
22:03:17 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
22:03:44 <omnId> xs ++ ys = foldr (:) ys xs
22:03:46 <newsham> > let f xs ys = foldr (:) ys xs in "test" `f` "this"
22:03:47 <lambdabot>  "testthis"
22:04:32 <omnId> > foldr (flip (foldr (:))) [] ["test", "that"]
22:04:33 <lambdabot>  "testthat"
22:05:05 <inono> is call-by-need useful anywhere you dont have infinite data structures ?
22:05:06 <omnId> foldr.  The Every Tool(tm).
22:05:38 <newsham> inono: yes.  consider    let if' b t e = case b of True -> t; False -> e
22:05:40 <geezusfreeek> inono, oh yes
22:05:50 <TSC> inono: Yes; e.g. shortcut-evaluation in && (in C and Haskell)
22:05:57 <TSC> Among many other cases
22:06:09 <inono> shortcut evaluation?
22:06:13 <newsham> inono: if boolean is true, the 't' expression is returned without having to evaluate whatever was in the 'e' expression
22:06:14 <inono> its irrelevant unless there's side effects
22:06:23 <newsham> its irrelevant to te result
22:06:28 <newsham> but not the the computation efficiency
22:06:29 <TSC> The side effect is "it's faster" (:
22:06:39 <inono> well i was talking about the result actually.
22:06:58 <newsham> where computations terminate, the results are identical.
22:07:20 <dmwit> There's a theorem that says that any order of reduction of the lambda calculus that terminates must produce the same result.
22:07:24 <dmwit> ...I think.
22:07:30 <dmwit> I may have misunderstood the theorem. =P
22:07:34 <inono> eager evaluation can get stuck in some cases actually.
22:07:35 <newsham> dmwit: or not terminate.
22:07:37 <TSC> Sounds right to me
22:07:48 <dmwit> newsham: Hence the "that terminates" clause.
22:07:55 <newsham> oh yes
22:08:06 <inono> ah, terminatio...
22:08:29 <newsham> and between strict and non-strict, non-strict terminates more often
22:08:32 <geezusfreeek> dmwit, but some reduction sequences might still not terminate while others do
22:09:02 <newsham> if strict evaluation terminates, then so will non-strict.
22:09:17 <newsham> but not vice versa
22:09:20 <omnId> I think it goes that if any order terminates, normal order will.
22:11:22 <geezusfreeek> looking back, there was no confusion, so nevermind
22:11:25 <geezusfreeek> :)
22:29:17 <xelxeba1> is there a version of take that accepts Integers instead of Ints?
22:29:35 <xelxeba1> > :t take
22:29:36 <lambdabot>   parse error on input `:'
22:29:36 <dons> :t genericTake
22:29:38 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
22:29:40 <dons> that's the one :)
22:29:44 <dmwit> ?hoogle Integer -> [a] -> [a]
22:29:44 <lambdabot> No matches, try a more general search
22:29:48 <xelxeba1> :) thanks
22:29:48 <dons> it accepts any Integral type
22:29:54 <dmwit> ?hoogle Integral i => i -> [a] -> [a]
22:29:55 <lambdabot> List.genericDrop :: Integral a => a -> [b] -> [b]
22:29:55 <lambdabot> List.genericTake :: Integral a => a -> [b] -> [b]
22:29:55 <lambdabot> Data.List.genericDrop :: Integral i => i -> [a] -> [a]
22:30:52 <omnId> List.genericTake is bounded on Integral, Data.List.genericTake is more general, bounded on Num
22:30:53 <nornagon> @src List.genericTake
22:30:54 <lambdabot> Source not found. Do you think like you type?
22:31:23 <nornagon> omnId: ... bounded on num?
22:31:31 <omnId> Num a => ...
22:31:38 <nornagon> > Data.List.genericTake (2%17) [1..]
22:31:39 <lambdabot>   add an instance declaration for (Integral (Ratio t))
22:31:39 <lambdabot>     In the expression:...
22:31:41 <omnId> typeclass-bounded
22:31:48 <TSC> @type Data.List.genericTake
22:31:49 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
22:31:51 <nornagon> ^- i don't think so.
22:31:54 <TSC> Looks like integral to me
22:31:55 <dmwit> I don't think so.
22:32:04 <dmwit> That wouldn't really make sense.
22:32:09 <dmwit> How would you take 2.5 elements?
22:32:10 <omnId> erm, I'm thinking of genericLength
22:32:17 <nornagon> right
22:32:25 <omnId> @slap omnId
22:32:25 * lambdabot beats up omnId
22:32:31 <omnId> @thanks
22:32:31 <lambdabot> you are welcome
22:32:42 <dmwit> Whoa, I didn't know about @thanks. =)
22:33:34 <dons> @thanks?
22:33:35 <lambdabot> you are welcome
22:33:37 <dons> huh.
22:33:43 <dons> someone slipped that in
22:33:52 <xelxeba1> what other 'useful' commands does lambdabot support . . .
22:34:00 <dmwit> xelxeba1: Try ?list. ;-)
22:34:07 <xelxeba1> @list
22:34:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:14:02 <paczesiowa> @src (++)
23:14:02 <lambdabot> (++) []     ys = ys
23:14:03 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
23:17:47 <dibblego> is there a >>= for Either, but binds through Left?
23:18:13 <paczesiowa> wouldn't that be different monad?
23:18:26 <dibblego> sure
23:18:32 <dmwit> dibblego: Nope, you'll have to write it yourself.
23:18:35 <sjanssen> dibblego: that isn't possible, due to kind issues
23:18:50 <dibblego> ah of course
23:19:12 <sjanssen> you could newtype Either' a b = Either' (Either b a)
23:19:25 <omnId> you could define a Flip newtype and define Monad (Flip Either)
23:19:34 <omnId> (Flip Either e) rather
23:19:45 <dibblego> yeah
23:19:45 <paczesiowa> how can I find all ghc's fusions for (++)?
23:20:14 <sjanssen> paczesiowa: hunt through the source for GHC.Base and GHC.List
23:21:01 <paczesiowa> lambdabot can't do that for me?
23:21:08 <vincenz> @seen augustss
23:21:08 <lambdabot> augustss is in #haskell. I last heard augustss speak 6h 27m 1s ago.
23:21:09 <sjanssen> no
23:21:31 <vincenz> @msg augustss Any reason why you sent me that email, or was that a wrong address?
23:21:37 <vincenz> @tell augustss Any reason why you sent me that email, or was that a wrong address?
23:21:37 <lambdabot> Consider it noted.
23:22:16 <omnId> augustss is going to be confused.  "What email did I send to lambdabot?"  :o)
23:22:26 <paczesiowa> lazy lambdabot...
23:22:31 <vincenz> it shows off as coming from me
23:22:38 <omnId>  for @msg, too?
23:23:00 <omnId>  @msg makes LB privmsg someone, doesn't it?
23:23:14 <Pseudonym> But only if you're an admin.
23:23:19 <omnId> right.
23:23:22 <Pseudonym> @msg #haskell Sock puppet!
23:23:23 <lambdabot> Sock puppet!
23:23:29 <vincenz> whoops
23:23:55 <Pseudonym> @msg #haskell ACTION fumbles around in the dark
23:23:55 <dmwit> heh
23:23:55 * lambdabot fumbles around in the dark
23:24:08 <vincenz> @msg #haskell /me OHNO
23:24:08 * lambdabot OHNO
23:24:40 <dmwit> ?somecrazycommand
23:24:41 <lambdabot> Unknown command, try @list
23:32:21 <hpaste>  Paczesiowa pasted "string filters" at http://hpaste.org/3445
23:32:25 <paczesiowa> can someone explain that to me?
23:34:08 <sjanssen> paczesiowa: the differences may have more to do with your toUpper' function
23:34:29 <paczesiowa> I was testing with the same toUpper'
23:34:44 <sjanssen> paczesiowa: not in the source code you've pasted
23:35:20 <omnId> filtr2 uses Data.Char.toUpper
23:37:31 <paczesiowa> ok, my blindness answers my first (less important question), how about the second?
23:38:06 <sjanssen> yes, cs'' is copied, but the copy happens lazily
23:38:14 <sjanssen> GHC won't keep the whole thing in memory
23:38:16 <quicksilver> paczesiowa: bigList ++ smallList doesn't copy anything 'at the end'
23:38:27 <quicksilver> paczesiowa: it 'unwinds' bigList char by char as you step through it
23:38:44 <quicksilver> paczesiowa: and it can throw away already processes parts with GC
23:39:33 <quicksilver> paczesiowa: ++ does impose an overhead, which is that it keeps "pushing the thunk". the (++ smallList) part is always there, making each character access a little slower, until bigList is finished
23:39:57 <quicksilver> if you 'add up' all the 'little slowers' then the overall effect is O(length bigList)
23:40:25 <Pseudonym> But it's amortized constant time.
23:40:54 <Pseudonym> Per element.
23:40:55 <sjanssen> I disagree
23:41:13 <sjanssen> I agree with "constant per element"
23:41:21 <quicksilver> constant per element, yes
23:41:33 <quicksilver> and length bigList elements, so overall slowdown O(length bigList)
23:41:42 <quicksilver> or, O(number of elements you actually demand)
23:41:44 <quicksilver> if that's less
23:41:47 <Pseudonym> Right.
23:42:02 <Pseudonym> And since demanding those elements _also_ takes O(number of elements you demand) time...
23:42:25 <sjanssen> the extra constants still count
23:42:45 <sjanssen> remember the difference between ((xs ++ ys) ++ zs) and (xs ++ (ys ++ zs))
23:44:00 <Pseudonym> foldl1 (++) xss and foldr1 (++) xss have different complexity in the size of xss.
23:44:51 <LeCamarade> Haskell Prime should mention Darcs, IRC, #haskell and lambdabot.
23:45:01 <Pseudonym> Why/
23:45:02 <Pseudonym> ?
23:45:08 <LeCamarade> They are standard.
23:45:11 <LeCamarade> :o)
23:45:19 <LeCamarade> Just like -fgalsgor-exts
23:45:20 <Pseudonym> Woo!  We're standard, people!
23:45:30 <paczesiowa> I thought, that when we have (someList x) ++ someOtherList, that someList x has to be computed (and it's last item points to nil) so that particular list is used (and copied) co compute whole expression, but it's later discarded andgced
23:45:51 <quicksilver> paczesiowa: [1,2,3] ++ [4,5,6]
23:45:54 <Pseudonym> I'd hate to think that you couldn't build a conforming Haskell implementation without shapr or dons.
23:45:58 <quicksilver> paczesiowa: if you demand the first element
23:46:11 <quicksilver> paczesiowa: it reduces to 1 : ([2,3] ++ [4,5,6])
23:46:11 <omnId> @src (++)
23:46:12 <lambdabot> (++) []     ys = ys
23:46:12 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
23:46:13 <paczesiowa> so that's why I used that aux trick, to not point that last element to nil, making it garbage
23:46:19 <LeCamarade> Pseudonym: You can find them in Cabal, can't you? :o)
23:46:22 <quicksilver> paczesiowa: that's applying the definition of ++
23:46:35 <quicksilver> paczesiowa: then once you use that 1 (or not) it can be thrown away
23:46:44 <quicksilver> leavng you just with [2,3] ++ [4,5,6]
23:46:49 <Pseudonym> LeCamarade: Yeah, but everything needs the latest version of them from hackage.
23:46:53 <omnId> aux just looks like a fusion of map toUpper' and (++)
23:47:37 <paczesiowa> I tried with hand-crafted append, it was slower but both versions still took the same time
23:49:07 <omnId> I wonder the difference between (map f (xs ++ ys) ++ zs) and (map f xs ++ (map f ys ++ zs))
23:49:08 <paczesiowa> writing haskell programs which don't eat gbs of memory is hard:/
23:49:44 <LeCamarade> paczesiowa: Thank God my PDA has terabytes.
23:50:08 <sjanssen> paczesiowa: I don't think so
23:50:17 <sjanssen> paczesiowa: the program you pasted runs in O(1) memory
23:50:53 <Cale> paczesiowa: I've written Haskell programs which ran in constant space which would have used combinatorially large amounts of memory in any other language ;)
23:51:27 <Cale> Er, perhaps that was actually log space. Whatever. :)
23:51:57 <paczesiowa> yes, but it took me 2 hours, of writing many pointless lines of code before I did that version (filtr2 is my teacher's version). and I first wrote that and then it took some time to undetstand that.
23:52:30 <paczesiowa> but now, thanks to you I know, that I understood it wrong:>
23:53:49 <Cale> So the function takes the first 5 characters of the list, separates them off, then maps the whole list to uppercase, followed by the first 5 characters?
23:54:14 <hpaste>  dfranke pasted "Uh oh" at http://hpaste.org/3446
23:54:21 <dfranke> ^^^ This looks like a bug
23:54:38 <paczesiowa> I know that's stupid, but the point of that excersize was to make it use constant memory
23:54:52 <omnId> filtr cs = map toUpper' cs ++ take 5 cs
23:55:18 <Cale> omnId's version should use constant space.
23:55:34 <paczesiowa> it doesn't because it's lazy
23:55:37 <sjanssen> it won't
23:55:38 <Cale> hm?
23:55:54 <Pseudonym> dfranke: Not a bug, I'm pretty sure.
23:55:58 <Pseudonym> > 100000000000000000000
23:56:00 <lambdabot>  100000000000000000000
23:56:01 <Pseudonym> > 100000000000000000000 :: Int
23:56:02 <lambdabot>  1661992960
23:56:06 <paczesiowa> it will compute (take 5 cs) at the end, so it has to remember cs all the time
23:56:10 <sjanssen> Cale: the 'take 5 cs' thunk will hold on to cs
23:56:13 <Pseudonym> > 10000000000000000000000000
23:56:14 <lambdabot>  10000000000000000000000000
23:56:15 <Pseudonym> > 10000000000000000000000000 :: Int
23:56:16 <Cale> ah, right
23:56:16 <lambdabot>  1241513984
23:56:22 <Pseudonym> It's a shame we don't have trapping arithmetic.
23:56:38 <paczesiowa> the most interesting thing though is that
23:56:39 <Pseudonym> There are two problems here, though.
23:56:52 <Pseudonym> 1. The type of the second argument to encodeFloat is Int, not Integer.
23:56:59 <paczesiowa> lazyFiltr2 cs = lazyMap toUpper' cs `L.append` L.take 5 cs
23:57:01 <dfranke> (I know)
23:57:04 <Pseudonym> 2. encodeFloat doesn't complain if you give it an exponent out of range.
23:57:06 <paczesiowa> this works in constant memory:D
23:57:10 <Cale> yeah
23:57:16 <Pseudonym> > 1000000000000000000000 :: Int
23:57:18 <lambdabot>  -559939584
23:57:18 <Cale> Probably due to some rules :)
23:57:46 <Pseudonym> Problem 2 isn't a problem.  Infinity or underflow is the "right" answer.
23:57:54 <Pseudonym> Problem 1 is a limitation of modern CPUs.
