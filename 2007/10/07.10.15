00:00:00 <FMota> you know what haskell needs? subtyping.
00:00:06 <Pseudonym> However...
00:00:13 <Pseudonym> isqrt :: Integer -> Integer
00:00:22 <Pseudonym> isqrt = truncate . sqrt . fromIntegral
00:00:24 <Pseudonym> Now:
00:00:26 <Pseudonym> [1..isqrt n]
00:00:34 <FMota> > isqrt 4
00:00:35 <lambdabot>   Not in scope: `isqrt'
00:00:47 <Pseudonym> @let isqrt = truncate . sqrt . fromIntegral
00:00:50 <lambdabot> Defined.
00:00:52 <Pseudonym> > isqrt 4
00:00:54 <lambdabot>  2
00:00:54 <FMota> > let isqrt = truncate . sqrt . fromIntegral in 4
00:00:55 <lambdabot>  4
00:00:57 <Pseudonym> > isqrt 9
00:00:58 <FMota> lol
00:00:58 <lambdabot>  3
00:01:02 <Pseudonym> > isqrt 10
00:01:03 <lambdabot>  3
00:01:05 <FMota> I always mess things up
00:01:06 <Pseudonym> However.
00:01:18 <FMota> > isqrt 8
00:01:19 <lambdabot>  2
00:01:24 <Pseudonym> This will fail if your integers can't be represented exactly in Doubles.
00:01:40 <Pseudonym> However, in that case, you probably won't be doing [1..isqrt n].
00:06:41 <heanol> join Reddit
00:06:43 <heanol> oops
00:08:18 <FMota> :index find
00:08:26 <FMota> @index find
00:08:26 <lambdabot> Data.List
00:08:33 <FMota> @index fromJust
00:08:33 <lambdabot> Data.Maybe
00:08:52 <FMota> :t find
00:08:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
00:10:36 <dfranke_> what's the syntax for a unicode escape?
00:11:24 <FMota> sq x = x * x
00:11:41 <FMota> isqrt n = pred . fromJust . find (flip (>) n . sq) $ [1..]
00:12:59 <FMota> that should work for just about any integer.
00:13:47 <lokimaf> Haskell is for uber cool people
00:14:26 <allbery_b> dfranke_: '\n' where n is a decimal (*not* octal!) integer
00:14:28 <FMota> that's pretty much true of everyone in #haskell.  (me excluded, ofc)
00:14:42 <lokimaf> I made a Haskell tutorial: http://lokamaf.blogspot.com/2007/10/lokis-tutorial.html
00:14:43 <lambdabot> Title: la.ma'aselyTCAna. pela.lokimaf.: Loki's हस&#2381;क&#2375;ल&#2381;ल Tut ...
00:14:44 <allbery_b> cool?  me?> as if.
00:15:20 <lokimaf> tell me what you think at a skim
00:15:23 <Pseudonym> When cool people start using Haskell, that's when I jump ship.
00:15:28 <FMota> instance HaskellProgrammer p => Cool a
00:15:31 <FMota> *Cool p
00:15:37 * Pseudonym is hipster hacker
00:15:46 * allbery_b too old to be cool
00:15:55 * lokimaf has girls chase him around begging to have sex with him
00:15:59 <allbery_b> (or awake, given that it's 3am local, but...)
00:17:09 <lokimaf> this one girl got to my room took off her clothes and begged me to fuck her,  i don't bring random girls to my house anymore...
00:17:18 <lokimaf> hmmm maybe should tone down
00:17:21 <lokimaf> oh well
00:17:36 <lokimaf> anyways, i like Haskell :D
00:17:37 <Pseudonym> Yes, you should.
00:17:39 <Pseudonym> haskell-blah
00:17:49 <Pseudonym> That's what it's for.
00:18:13 <lokimaf> yep, i usually just talk functions
00:18:35 <FMota> lokimaf, I understand your plight, and you have my sympathy. Next time wear a rainbow shirt -- you'll still have girls flocking around you, but at least they won't get nekid.
00:18:46 <FMota> [/blah]
00:19:56 <lokimaf> hmm well i have an understanding that it's actually the tarot cards,  but that's just like haskell random number generator with some additions
00:20:05 <FMota> #haskell :: HaskellProgramm p => Channel p
00:20:11 <FMota> *HaskellProgrammer
00:21:02 <FMota> #haskell = filter (not . blah) programmers
00:21:10 <FMota> w/e
00:21:13 <lokimaf> agoode has an ipv6 address that's pretty cool
00:21:21 <FMota> it's late, and I'm rambling.
00:21:48 <lokimaf> tzal gyd
00:21:56 <FMota> but I can't get off because Metric is on. oh well...
00:22:07 <swix> how do you get a list less the first 1000 elements?
00:22:24 <FMota> you mean without the first 1000 elements?
00:22:28 <swix> yes
00:22:29 <FMota> drop 1000 list
00:22:32 <swix> cool
00:22:35 <FMota> np :)
00:22:54 <lokimaf> :D
00:23:44 <lokimaf> kk well i'll go back to working on my speakable haskell derivative LOGJbang
00:24:25 <nornagon> that doesn't look very speakable to me
00:24:28 <FMota> :o
00:24:45 <nornagon> how do you even pronounce that?!
00:25:30 <FMota> Haskell isn't very good for speaking with. Ambiguity is actually quite a nice feature of natural languages.
00:25:54 <FMota> and Haskell has very little ambiguity.
00:26:05 <nornagon> lojban is not a natural language
00:26:21 <nornagon> it's a conlang designed to be unambiguous
00:26:25 <FMota> plus, anything without dependent types is not suited for speaking in
00:26:49 <FMota> nornagon: right. still, my point stands.
00:27:15 * nornagon tips it over
00:27:38 <FMota> how? points are 0-dimensional objects. They can't be tipped!
00:28:59 <nornagon> FMota: they can if you lift them into the 3-dimension monad
00:29:54 <FMota> that's bogus
00:30:07 <FMota> how can you tip something without length, width, or height?
00:30:23 <FMota> Or even duration, for that matter.
00:30:57 <nornagon> well, if you have a point in 2-space, then you sweep it through a curve, you have a curve, which is a 2-object
00:31:08 <nornagon> then sweep the 2-object to obtain a 3-object
00:31:12 <nornagon> then tip it over
00:32:02 <FMota> fair enough
00:32:13 <FMota> but then it's no longer a point! :o
00:32:55 <nornagon> that's because it's been lifted into 3-space :)
00:33:05 <FMota> indeed
00:35:07 <geocalc> nornagon=<< can you paste an exemple
00:35:18 <nornagon> uh, what?
00:35:45 <geocalc> 3-space point
00:36:37 <nornagon> perhaps you missed the irony, i wasn't really being serious :P
00:36:44 <FMota> sweepTo3 trajectory2 . sweepTo2 trajectory1 $ point
00:39:57 <geocalc> > let evil = sum [1..sum[1..8]]
00:39:57 <lambdabot>  Parse error
00:41:23 <geocalc> @let evil = sum [1..sum[1..8]]
00:41:26 <lambdabot> Defined.
00:41:45 <geocalc> > evil
00:41:46 <lambdabot>  666
00:41:50 <LeCamarade> :-o
00:41:54 * LeCamarade runs away
00:42:06 <LeCamarade> +
00:42:09 <LeCamarade> +
00:42:12 <mauke> > sqrt 666
00:42:13 <LeCamarade> +
00:42:14 <LeCamarade> +
00:42:14 <LeCamarade> +
00:42:14 <lambdabot>  25.80697580112788
00:42:19 <LeCamarade> +
00:42:29 <ibid>  /away
00:42:32 <ibid> gah
00:42:41 <Pseudonym> > sqrt evil == money
00:42:42 <lambdabot>   Not in scope: `money'
00:42:44 * ibid is un-away, though :)
00:42:58 <sclv> I'm writing a webapp framework in squiggol, but the IO support is awful.
00:43:04 <Pseudonym> > isqrt evil
00:43:06 <lambdabot>  25
00:43:23 <FMota> lol
00:43:35 <FMota> > 5^2
00:43:36 <lambdabot>  25
00:43:39 <Pseudonym> @let money = 25
00:43:41 <FMota> > 5^2^2
00:43:41 <lambdabot> Defined.
00:43:43 <lambdabot>  625
00:43:44 <Pseudonym> Now it's true.
00:43:50 <Pseudonym> > money == isqrt evil
00:43:51 <lambdabot>  True
00:43:52 <FMota> 5^2^2 + 5^2
00:43:57 <LeCamarade> :o)
00:44:00 <FMota> > 5^2^2 + 5^2
00:44:01 <lambdabot>  650
00:44:09 <FMota> > 5^2^2 + 5^2 + 5 + 11
00:44:11 <lambdabot>  666
00:44:19 <ibid> > money^2 == evil
00:44:21 <lambdabot>  False
00:44:22 <Pseudonym> > 562^2 + 5^2 + 2^4
00:44:23 <lambdabot>  315885
00:44:26 <Pseudonym> > 5^2^2 + 5^2 + 2^4
00:44:28 <lambdabot>  666
00:44:33 <FMota> well... it's not elegant, but it works.
00:44:49 <mauke> > sqrt (2 * 666)
00:44:50 <lambdabot>  36.49657518178932
00:44:52 <LeCamarade> (money == isqrt 666) && (money == isqrt evil)
00:45:18 <LeCamarade> @let rootOfAll = isqrt
00:45:21 <lambdabot> Defined.
00:45:25 <FMota> > sum[1..sum[1..8]]
00:45:27 <lambdabot>  666
00:45:40 <LeCamarade> > money == rootOfAll evil
00:45:42 <lambdabot>  True
00:45:46 <LeCamarade> Be frank lambdabot
00:45:47 <FMota> lol
00:45:50 <LeCamarade> :-o
00:45:51 <LeCamarade> +
00:45:52 <LeCamarade> +
00:45:53 <LeCamarade> +
00:45:54 <LeCamarade> +
00:45:59 <ibid> that's wrong, btw :)
00:46:11 <osfameron> what's with the +s ?
00:46:16 <LeCamarade> Cross.
00:46:22 <ibid> @let premature x = x ^ 2
00:46:25 <lambdabot> Defined.
00:46:30 <ibid> @let optimization = 5
00:46:33 <lambdabot> Defined.
00:46:42 <ibid> > permature optimization == rootOfAll evil
00:46:43 <lambdabot>   Not in scope: `permature'
00:46:50 <ibid> > premature optimization == rootOfAll evil
00:46:51 <Pseudonym> Gotta go.  Night.
00:46:51 <lambdabot>  True
00:47:12 <FMota> :p
00:47:27 <LeCamarade> @let root = (\_ _ _ -> isqrt) -- Monomorphism rest., you there?
00:47:29 <sclv> :t Money
00:47:30 <lambdabot> Defined.
00:47:31 <lambdabot> Not in scope: data constructor `Money'
00:47:43 <sclv> (fromIntegral Money) ** 2.0197391959991466
00:48:00 <sclv> > (fromIntegral Money) ** 2.0197391959991466
00:48:01 <lambdabot>   Not in scope: data constructor `Money'
00:48:03 <FMota> @let local x = sum [1..x]
00:48:06 <LeCamarade> @let root = (\_ _ -> isqrt) -- Monomorphism rest., you there?
00:48:06 <lambdabot> Defined.
00:48:07 <lambdabot> <local>:12:0:     Multiple declarations of `L.root'     Declared at: <local>:...
00:48:14 <sclv> > (fromIntegral money) ** 2.0197391959991466
00:48:16 <lambdabot>  666.0000000000003
00:48:23 <LeCamarade> money == (root "of" "all") evil
00:48:30 <FMota> @let variables = local 8
00:48:30 <lambdabot> <local>:12:12:     Ambiguous occurrence `local'     It could refer to either ...
00:48:37 <FMota> :/
00:48:40 <LeCamarade> > money == (root "of" "all") evil
00:48:40 <FMota> darn
00:48:41 <lambdabot>  Couldn't match expected type `Integer'
00:48:58 <LeCamarade> :o(
00:49:03 <LeCamarade> Get back to work, you!
00:49:04 <FMota> @let local_ x = sum [1..x]
00:49:07 <lambdabot> Defined.
00:49:13 <FMota> @let variables = local_ 8
00:49:17 <lambdabot> Defined.
00:49:19 * ibid is compiling a kernel module
00:49:24 <FMota> > local_ variables == evil
00:49:25 <lambdabot>  True
00:50:41 <LeCamarade> Reddit won't get out or RO mode!
00:53:37 <mauke> > iterate (sum . enumFromTo 1) 8
00:53:42 <lambdabot> Terminated
00:55:55 <mauke> > join (.) (sum . enumFromTo 1) 8
00:55:57 <lambdabot>  666
00:56:12 <geocalc> fear haskell
00:56:15 <osfameron> the return value of the beast!
00:59:47 <nornagon> join is like concat in that case, yes?
01:00:12 <geocalc> @loosers
01:00:13 <lambdabot> Unknown command, try @list
01:00:18 <nornagon> @losers
01:00:18 <lambdabot> Maximum users seen in #haskell: 420, currently: 362 (86.2%), active: 14 (3.9%)
01:00:30 <nornagon> (learn to spell!)
01:01:04 <TSC> @src join
01:01:04 <lambdabot> join x =  x >>= id
01:01:16 <nornagon> ah.
01:01:45 <nornagon> :t join (.)
01:01:47 <mauke> in the list monad, >>= id is concatMap id, so concat == join
01:01:48 <lambdabot> forall b. (b -> b) -> b -> b
01:02:52 <pastorn-rr> @src join
01:02:52 <lambdabot> join x =  x >>= id
01:03:01 <mauke> > join (.) sqrt 2
01:03:06 <lambdabot>  1.189207115002721
01:03:20 <nornagon> > sqrt 2
01:03:22 <lambdabot>  1.4142135623730951
01:03:25 <osfameron> huh?
01:03:27 <nornagon> ??
01:03:44 <mauke> > (.) sqrt sqrt 2
01:03:46 <lambdabot>  1.189207115002721
01:04:03 <nornagon> oh ah
01:04:21 <mauke> > join (^) 3
01:04:22 <osfameron> but why twice?
01:04:23 <lambdabot>  27
01:04:27 <nornagon> so join (.) a is like a . a
01:04:40 <mauke> join f x = f x x
01:05:04 <nornagon> i still don't understand that :)
01:05:12 <nornagon> how does that come from (>>= id) ?
01:05:38 <mauke> @src (->) >>=
01:05:39 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:05:42 <byorgey> @src (->) (>>=)
01:05:43 <lambdabot> f >>= k = \ r -> k (f r) r
01:06:07 <mauke> see the duplicated r?
01:06:12 <nornagon> zany
01:07:35 <byorgey> it's the environment, aka "reader" monad, (r ->)
01:08:11 <byorgey> @type join
01:08:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:08:35 <mauke> (r -> (r -> a)) -> (r -> a)
01:08:43 <mauke> @djinn (r -> (r -> a)) -> (r -> a)
01:08:44 <lambdabot> f a b = a b b
01:09:34 <byorgey> that is, the "environment" b gets passed in to both arguments of a two-arguement function, thus making a one-argument function.
01:10:11 <greentea> Hi all. i can't seem to work out how to create a new type at the GHCi prompt, e.g. i'd like to be able to create MyBool = False | True. Can someone point me in the right direction, please?
01:10:21 <byorgey> greentea: you can't, unfortunately.
01:10:36 <byorgey> greentea: you'll need to write the type in a file and load the file into ghci.
01:10:38 <greentea> Ah. Well, that explains that - thanks. :-)
01:10:44 <greentea> Yeah, that's what i've been doing.
01:11:14 <Cale> greentea: If that's the case, then you perhaps forgot the data keyword?
01:11:42 <osfameron> hmmm, where is the "join" above coming from?  In ghci I did :m +Control.Monad, and it complains No instance for (Monad ((->) a))
01:11:54 <mauke> :m +Control.Monad.Reader
01:11:55 <Cale> osfameron: Control.Monad.Instances
01:12:00 <Cale> (or Reader)
01:12:04 <greentea> Oh,no, i mean, it works when i load the file into GHCi, just wanted to know if there was some way of doing it without having to load up a file.
01:12:09 <mauke> Reader is shorter and works in 6.4 :-)
01:12:10 <osfameron> oh, so there are different definitions of it all over the shop?
01:12:22 <Cale> osfameron: no, they're the same instance
01:12:27 <mauke> osfameron: no, there's only one join. you're missing a Monad instance
01:12:55 <osfameron> but the:  join (^) 3  works fine with .Reader, and doesn't with C.M on its own
01:13:08 <mauke> yes
01:13:25 <byorgey> hm, does anyone know if the inability to define data types at the ghci prompt is due to a theoretical limitation, or is it simply an unimplemented feature?
01:14:07 <goalieca> :type &&&
01:14:13 <goalieca> :t &&&
01:14:15 <lambdabot> parse error on input `&&&'
01:14:54 <goalieca> tabarnac
01:15:00 <byorgey> goalieca: need parens
01:15:04 <byorgey> @type (&&&)
01:15:05 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:15:07 <Cale> osfameron: Control.Monad doesn't export the instance of Monad for ((->) e)
01:15:20 <mauke> s/export/contain/
01:15:27 <mauke> instances are always exported
01:15:31 <Cale> Well, that too :)
01:15:39 <byorgey> goalieca: for the function instance of Arrows, f &&& g = \x -> (f x, g x)
01:16:00 <Cale> osfameron: Personally, I think it ought to go into the Prelude :)
01:16:21 <goalieca> byorgey, thank you.
01:17:02 <osfameron> Cale, mauke: ok, ta.  Actually, I can't see where the monads come into it at all, I'll come back to it at some point when I'm not at work...
01:17:21 <Cale> :t join
01:17:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:17:26 <Cale> That's where
01:18:24 <osfameron> oh, because functions are monads
01:19:59 <wli> What's the join for function monads?
01:20:09 <Cale> join f x = f x x
01:21:10 <Cale> join :: Monad m => m (m a) -> m a, so if m = ((->) e), then join :: (e -> e -> a) -> e -> a
01:21:43 <Cale> which could really be only one thing :)
01:23:40 <byorgey> Cale: how much do you know about the Waterloo CS department?
01:23:50 <Cale> not a whole lot
01:23:57 <byorgey> ok, just wondering
01:24:05 <byorgey> I'm applying to PhD programs
01:24:13 <Cale> cool
01:25:31 <Cale> Shallit is there, I think, if you're into formal language stuff.
01:26:26 <byorgey> hm, ok, thanks, I'll take a look.  Formal language stuff sounds good (I think).
01:28:22 <Itkovian> Can one say that Java is strongly typed?
01:30:22 <Cale> Itkovian: Yes, in some sense of the term
01:30:47 <Itkovian> ok
01:31:29 <Cale> Though I think its type system is a rather poor example if you want to show off strong static typing.
01:32:11 <mauke> @docs Numeric
01:32:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
01:32:46 <Itkovian> Cale: no, I'm just reading a draft of a friend's PhD and it was menioned, and I wanted to make certain before commenting on it
01:39:15 <dmwit> 1% of my lines of code start with -- TODO:
01:39:18 <dmwit> =(
01:40:57 <Cale> Better than 100%
01:44:22 <mux> bah, it's insanely hard to run a simple command, get output and the return status of the executable in haskell
01:44:43 <dmwit> mux: Yeah. =(
01:45:08 <mux> I fought against laziness so that I could use pOpen or hPipeFrom (from MissingH package), and now it works but I have other problems
01:45:38 <mux> I get error messages from the command I'm running printed on the screen, and no easy/portable way to shut those off
01:46:33 <dmwit> mux: I have a function runWithInput that I copied from jcreigh that is pretty nice, are you interested?
01:46:34 <mux> I guess I could hack the pipe stuff from MissingH so that I also get stderr in the pipe and thus no screen pollution
01:46:45 <mux> dmwit: very much, yes! thanks
01:47:04 <quicksilver> is the missingH stuff lazy?
01:47:35 <mux> the pipe* is described as such, but the hPipe* one isn't, the problem is that since I have a Handle, I have nothing but hGetContents to call
01:47:39 <mux> and hGetContents is lazy
01:48:07 <quicksilver> in that circumstance, I write my own strict hGetContents
01:48:09 <mux> I just quicly wrote a strict hGetContents'
01:48:12 <mux> yes
01:48:14 <mux> I did that
01:48:18 <quicksilver> normally I just iterate hGetLine
01:48:19 <hpaste>  dmwit pasted "for running programs in Haskell" at http://hpaste.org/3297
01:48:27 <mux> I want the full output to parse it with Parsec
01:48:31 <quicksilver> (and I curse the haskell gods for only giving us lazy hGetContents)
01:48:32 <mux> I don't want to split it by lines
01:48:41 <mauke> http://hpaste.org/3296
01:48:58 <quicksilver> mux: well I join it up again afterwards :)
01:49:06 <quicksilver> mux: it's just hGetLine is convenient and strict :P
01:49:07 <mux>     output <- pOpen ReadFromPipe "ldd" [f] hGetContents'
01:49:22 <mux> once you have a strict hGetContents, this is very convenient =)
01:49:29 <mauke> output <- getPipe "ldd" [f]
01:49:37 <mux> if only it could pipe stderr as well so my screen doesn't get polluted
01:49:56 <mux> mauke: thanks, will try this out
01:49:58 <roconnor> hGetContents has broken semantics ... that can be useful /sometimes/, but not always.
01:49:58 <Itkovian> dmwit: only 1%?
01:50:10 <mux> mauke: oh, it's using forkProcess
01:50:22 <dmwit> Itkovian: I also have a separate TODO file which has big, unfinished tasks (new features).
01:50:24 <dmwit> =/
01:50:28 <mux> mauke: I was trying to stay portable =) though of course ldd(1) isn't supposed to exist or be useful under Windows
01:50:29 <Itkovian> lol
01:50:31 <roconnor> really hGetContents should be called hUnsoundGetContents.
01:50:48 <Itkovian> dmwit: you should see my Phd draft ;-)
01:50:50 * osfameron briefly pimps the London Perl Workshop: http://www.mccarroll.org.uk/~gem/pages/lpw2007-announce.txt
01:50:50 <mauke> mux: fork is portable enough :-)
01:50:58 <dmwit> hehehe
01:50:59 <mux> for my concern, it sure is
01:51:06 <mux> and that will drop the dependency on MissingH I guess
01:51:09 <osfameron> looking for good, short talks, accessible to a general audience.  If anyon'e interested.
01:51:15 <mux> mauke: thanks =)
01:52:00 <roconnor> MissingH seems like a broken idea.  Independent functions out to be independently packaged.
01:52:08 <roconnor> s/out/ought/
01:52:16 <mux> I agree, but I found some stuff there that I didn't find elsewhere
01:52:37 <mux> now that I know about FileManip though for instance, I won't use their glob function anymore =)
01:52:44 <mux> FileManip is nice
01:52:50 <mux> the find and glob APIs are good
02:00:35 <quicksilver> roconnor: I believe that, when cosmicray started writing that, he wasn't sure how much of it he was reinventing and what should go where
02:00:49 <quicksilver> roconnor: and it is his intention to slowly separate + repackage those parts which seem important
02:00:58 <roconnor> :)
02:01:15 <roconnor> MissingH is certainly better than nothing ... I think
02:01:49 <roconnor> and presumably MissingH was made before we had such a nice Cabal/Hackage system?
02:02:56 <quicksilver> yes
02:03:38 <roconnor> presumably getting at a bunch of little packages should be easier.
02:03:44 <roconnor> or maybe we need cabal install first.
02:03:58 <roconnor> probably no need to wait.
02:06:33 <quicksilver> CosmicRay is a bit too keen on lazy IO for my liking, too :)
02:07:07 <roconnor> I don't pay him enought not to be lazy.
02:07:11 <quicksilver> hdbc is lazy by default and I believe that is a bad decision in a DB library.
02:07:58 <roconnor> oh, that sort of lazy
02:08:09 <roconnor> I thought you were claiming he was lazy about dividing up MissingH ;)
02:10:37 <mauke> @hoogle genericSplit
02:10:38 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
02:10:38 <lambdabot> Data.List.genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
02:14:48 <takamura> hello
02:15:14 <lokimaf_> what would be your name written in Kanji?
02:15:21 <Vq^> hello takamura
02:15:36 <dcoutts> @seen pgavin
02:15:36 <lambdabot> I saw pgavin leaving #haskell 13h 22m 56s ago, and .
02:15:59 <dcoutts> @tell pgavin gstreamer/Media/Streaming/GStreamer/Core/Types.chs:244:11: Not in scope: `cObjectUnfloat'
02:15:59 <lambdabot> Consider it noted.
02:16:08 <takamura> lokimaf_, I cant write kanji in this computer
02:16:23 <lokimaf_> kk was just wondering
02:16:40 <takamura> taka is high and mura is town
02:17:14 <lokimaf_> cool, so would that be high in terms of elevation?
02:17:37 <takamura> yes, many Japanese names are names of natural places
02:17:55 <lokimaf_> makes sense
02:18:22 <takamura> its the same for other languages
02:18:32 <takamura> names of places, jobs, etc.
02:18:59 <takamura> or town names
02:19:35 <takamura> anyway, i'm not japanese :p
02:19:41 <lokimaf_> i just noticed that your name was in abugida form and figured it was Japanese
02:19:59 <lokimaf_> oh so is it an anime fascination?
02:20:17 <lokimaf_> tzal gyd
02:20:20 <takamura> what's abugida?
02:20:38 <lokimaf_> where constonants are inherantly associated with a vowel
02:20:46 <takamura> no, it's a japanese poet, Takamura Koutarou
02:20:57 <takamura> ah
02:21:45 <lokimaf_> so there arent any crunchy constonants in many asian languages
02:21:51 <takamura> a friend of mine show me some works of Takamura and i liked it
02:21:55 <takamura> and choose the nick
02:22:49 <takamura> mm i dont know, japanese is not much related to other asian languages, except korean
02:23:02 <takamura> it is also related to finnish
02:23:06 <takamura> iirc
02:23:39 <osfameron> don't think so
02:23:43 <lokimaf_> hindi is abugida style language as well
02:23:52 <takamura> some scholars say it is an uralo-altaic language
02:23:53 <osfameron> finnish is related to estonian, and allegedly to Hungarian, but not really
02:23:54 <quicksilver> finnish is related to hungarian
02:24:03 <takamura> spanish is abugida also
02:24:10 <quicksilver> the finno-ugrian (sp.?) languages are a small group
02:24:29 <lokimaf_> naw spanish uses latin letters
02:25:01 <lokimaf_> they can have constonant combinations like tcokolat
02:25:12 <takamura> mm, then i didnt understood well what abugida means
02:25:21 <roconnor> mmm tcokolat
02:25:23 <lokimaf_> http://en.wikipedia.org/wiki/Abugida
02:25:24 <lambdabot> Title: Abugida - Wikipedia, the free encyclopedia
02:25:25 <roconnor> :P
02:25:35 <osfameron> lokimaf_: I've seen txokolat, in Catalan and Basque writing
02:25:50 <osfameron> quicksilver: I've read it as "finno-ugric"
02:26:03 <takamura> tcokolat is not spanish
02:26:06 <takamura> chocolate
02:26:42 <lokimaf_> tcokolat iz inglic
02:27:02 <lokimaf_> fonetik englic
02:27:19 <lokimaf_> c = sh
02:27:28 <takamura> now i checked some japanese grammar, and it says japanese can be a uralic or altaic language
02:27:35 <takamura> ah
02:28:39 <takamura> i allways wondered why english spelling is so difficult, why so many consonants? >_<
02:28:45 <lokimaf_> xaskel = haskell
02:29:38 <lokimaf_> konsonants ar a strengt
02:30:03 <lokimaf_> do tzal gyd
02:30:40 <takamura> now i read wikipedia, japanese is not abugida
02:30:48 <lokimaf_> oh well
02:30:52 <takamura> demotic egiptian is, i think
02:31:19 <raxas> takamura: did you considered learning czech? "Plch zdrhl skrz drn, prv zhltl hrst zrn." is a correct and meaningfull czech sentence
02:31:43 <lokimaf_> what does it mean
02:31:43 <takamura> raxas, oh my god!!
02:32:07 <lokimaf_> ?
02:32:36 <raxas> plch is kind of mouse. so it is about he ate some grain and run away through the grass
02:33:10 <takamura> wow
02:33:49 <takamura> what languages are related to czech?
02:34:22 <lokimaf_> k uel aim of tu pretend tu bi produktiv, meibi sliip iven, iz 5:30am
02:34:25 <raxas> takamura: slovak and polish
02:34:42 <lokimaf_> leitrz
02:34:52 <ivanm> I finally managed to fix the looping problems in my (first-ever) STM-based app... except that even after it finishes ghci is still using large amounts of CPU... is there a way of killing off the threads?
02:35:40 <sjanssen> ivanm: killThread?
02:35:55 <takamura> lokimaf_, inglic is easier than english :D
02:36:08 <ivanm> @where killthread
02:36:09 <lambdabot> I know nothing about killthread.
02:36:12 <ivanm> @where killThread
02:36:13 <lambdabot> I know nothing about killthread.
02:36:17 <takamura> i will try to learn it
02:36:19 <ivanm> dammit, wrong command
02:39:11 <mux> @src error
02:39:11 <lambdabot> error s = throw (ErrorCall s)
02:39:54 <ivanm> sjanssen: is there an easier way for a thread to kill itself or for the controlling thread to kill all sub-threads?
02:40:05 <ivanm> or can I just go: killThread myThreadId ?
02:40:27 <sjanssen> hmm, I'm not sure what will happen with killThread myThreadId
02:41:01 * ivanm goes off to try
02:41:17 <sjanssen> yeah, that's safe
02:41:36 <sjanssen> or you could just throw an exception
02:41:45 <ivanm> doesn't work...
02:41:49 <ivanm> @type killThread
02:41:51 <lambdabot> Not in scope: `killThread'
02:41:52 <ivanm> @type myThreadId
02:41:53 <lambdabot> Not in scope: `myThreadId'
02:41:59 <ivanm> grr...
02:42:10 <ivanm> @type Control.Concurrent.myThreadId
02:42:12 <lambdabot> IO GHC.Conc.ThreadId
02:42:18 <ivanm> @type Control.Concurrent.killThread
02:42:19 <lambdabot> GHC.Conc.ThreadId -> IO ()
02:42:21 <sjanssen> killThread =<< myThreadId
02:42:26 <ivanm> yeah
02:42:36 <ivanm> but my point was, just doing "killThread myThreadId" won't work :p
02:43:25 <ivanm> stack overflow :(
02:44:05 <ivanm> I don't know if its my code, or how busy my comp is, forkIO or STM, but the results it should be printing out every "timestep" come out in a rather jerky fashion :s
02:44:38 <scook0_> buffering, maybe?
02:44:53 <hpaste>  ivanm pasted "Stack overflow with STM" at http://hpaste.org/3298
02:48:08 <Lemmih> ivanm: 'return ()' instead of 'killThread =<< myThreadId' still gives a stack overflow.
02:48:25 <ivanm> Lemmih: well, it didn't for me... maybe I had more RAM without it :s
02:48:37 <ivanm> s/without it/before when I didn't have it
02:49:06 <quicksilver> I would personally always collect threadIds when I fork
02:49:12 <ivanm> OK
02:49:24 <ivanm> so, how could I do that?
02:49:35 <quicksilver> thread <- forkIO ...
02:49:38 <ivanm> shift the forkIO from the newAnt to where I do the mapM_ ?
02:49:57 <quicksilver> change newAnt's type to IO ThreadID?
02:50:00 <quicksilver> and remove the return ()
02:50:40 <scook0> (I'm personally not seeing a stack overflow, compiled or not)
02:50:42 <ivanm> quicksilver: then turn mapM_ to mapM ?
02:50:45 <quicksilver> yes
02:50:49 <ivanm> *nod*
02:50:57 <quicksilver> and  presumably keep the list of threadIds around somewhere
02:51:01 <quicksilver> to kill them all off at the end
02:51:07 <ivanm> *nod*
02:51:39 <quicksilver> this is, by the way, an annoyance of thread based programming in ghci
02:51:43 <quicksilver> I submitted a bug about it
02:52:06 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/1399
02:52:08 <lambdabot> Title: #1399 (better support for developing threaded applications in ghci) - GHC - Trac
02:52:23 <quicksilver> still it's probably good practice to collect thread IDs
02:52:28 <quicksilver> and kill em all off when that job is done
02:52:34 <quicksilver> (unless they are coded to die automatically)
02:52:49 <ivanm> yay! it worked!
02:53:12 <LeCamarade> Me, what I wanted was to do ...
02:53:17 <quicksilver> I love how easy it is to change a couple of types in a program :)
02:53:27 <quicksilver> changing somethign from IO () to IO ThreadId is so logical
02:53:29 <quicksilver> ...
02:53:44 <ivanm> I changed "mapM_ ..." to "ants <- mapM ...", and then at the end of runSystem added "mapM_ killThread ants"
02:53:46 <LeCamarade> A list of IO actions in parallel and have 'em return something.
02:54:01 <LeCamarade> And I failed.
02:55:09 <ivanm> LeCamarade: :(
02:57:31 <hpaste>  sjanssen pasted "parsequence" at http://hpaste.org/3299
02:57:36 <sjanssen> LeCamarade: ^^^
02:58:41 <LeCamarade> See, thread stuff take IO (). Which doesn't return sane values. So ... I can't fetch say web pages in parallel. Short of IORef, which me no like.
02:58:52 <EvilRanter> sjanssen, wouldn't a channel be perfect for that sort of thing?
02:59:01 <LeCamarade> Oh. Wait. Nice paste.
02:59:10 <sjanssen> EvilRanter: perhaps, depends on whether the result order matters
02:59:30 <EvilRanter> ah, yes, i see. yours preserves order.
02:59:43 <LeCamarade> Well, I am re-writing my spider from Ruby. In Ruby it did:
03:01:14 <LeCamarade> [url1, url2, url3].map {|x| open(x) {|f| f.read} } # Result is ... [data1, data2 ...]
03:01:17 <Lemmih> Beware of exceptions.
03:01:26 <LeCamarade> Sorry it is Miranda. ;o)
03:01:40 <LeCamarade> Miranda is a Trademark of Research Software.
03:02:34 <LeCamarade> And the Haskell version didn't quite fit. That's clean. Lemme stab again soon.
03:02:43 <ivanm> looks like my problem still isn't fully solved... since if I run it a few times I still keep getting stack overflow errors :s
03:03:17 <sjanssen> Lemmih: yes, I should catch the exception and stick it into the MVar
03:03:31 <ivanm> and for some reason, if I take away the "killThread =<< myThreadID" bit, it crashes even earlier :s
03:03:35 <Lemmih> ivanm: writeTVar state $! val
03:03:56 <sjanssen> of course, the program will crash with "blocked indefinitely", which is almost equivalent :)
03:04:07 <ivanm> yeah
03:04:13 <ivanm> which it looks like what it's doing :s
03:05:44 <ivanm> OK, for some reason when "threadKill =<< myThreadId" is removed, then ghci doesn't reduce in CPU/Mem usage :s
03:06:12 <Lemmih> Works for me.
03:07:34 <sjanssen> LeCamarade: the Haskell equivalent is mapM (\x -> open x >>= read) [url1, url2, url3] -- assuming valid definitions of open and read
03:08:05 <ivanm> OK, looks like there's a bug with my code :s
03:08:07 <quicksilver> or forM [url1,url2,url3] (\x -> open x >>= read) if you prefer that order
03:08:37 <quicksilver> but it's not parallel which is what LeCamarade is after
03:08:47 <sjanssen> is the Ruby version parallel?
03:09:01 <sjanssen> also, it is trivial to write parMapM
03:09:14 <quicksilver> you just did :)
03:09:17 <quicksilver> more or less
03:09:20 <sjanssen> right
03:10:24 <hpaste>  sjanssen annotated "parsequence" with "factor into a futures library" at http://hpaste.org/3299#a1
03:14:02 <quicksilver> sjanssen: nice, except you forget to catch the exceptions
03:14:11 <sjanssen> quicksilver: yeah, that was a half edited copy
03:14:25 <sjanssen> I forgot I was in the middle of adding exception support :)
03:16:13 <quicksilver> nice idea of a Future type though
03:17:10 <hpaste>  sjanssen annotated "parsequence" with "with exceptions" at http://hpaste.org/3299#a2
03:17:14 <sjanssen> Haskell rocks.
03:17:29 <SamB_XP_> parsequence?
03:19:17 <sjanssen> SamB_XP_: yep, a version of sequence that runs each action concurrently
03:19:51 * osfameron worked through the "Tying the Knot" with lazy lets at weekend
03:20:05 <SamB_XP_> shouldn't it take some kind of ... strategy for ensuring the evaluation of the return value?
03:20:15 <SamB_XP_> (if desired)
03:20:26 * sjanssen thinks readMVar m >>= either throw return is beautiful
03:20:29 <osfameron> to generate a doubly linked list.  Actually the hardest thing was traversing the list (because of all the Maybe's getting in the way)
03:20:41 <sjanssen> SamB_XP_: the client is responsible for that
03:21:10 <SamB_XP_> sjanssen: hmm.
03:21:45 <SamB_XP_> so, like, each IO action has to apply said strategy before returning?
03:21:54 <sjanssen> sure
03:22:00 <quicksilver> well this was designed for cases where the IO is what you actually 'want' to do
03:22:05 <SamB_XP_> fair enough, I guess
03:22:10 <quicksilver> if your code was doing 'pure work' then yes
03:22:14 <quicksilver> a strategy might make sense
03:22:39 <quicksilver> in very many cases the IO is enoguh though
03:22:45 <SamB_XP_> I guess so
03:22:47 <quicksilver> (as long as you're not using brokenlazyIO :P)
03:23:00 <SamB_XP_> hehe
04:21:19 <ivanm> I don't suppose there is an easy way in ghci to find all threads in that session?
04:21:27 <ivanm> just to see if I forgot to close any, etc.
04:21:44 <quicksilver> no
04:21:49 <quicksilver> see my bug report :)
04:32:43 <ivanm> quicksilver: heh, true
04:35:17 <ivan`> is there a normal way to do distributed computing in haskell?
04:35:21 <ivan`> ie, objects over network
04:35:37 <Lemmih> Nope.
04:36:36 <quicksilver> no
04:36:41 <quicksilver> that's a hard problem (TM)
04:36:58 <quicksilver> actually immutability makes some parts of it much easier, theoretically
04:36:59 <ivan`> there's nothing like python's twisted?
04:37:07 <quicksilver> not that I've heard of
04:37:19 <matthew_-> well, there're json bindings
04:37:24 <matthew_-> and there's Data.Binary
04:37:31 <quicksilver> that's not the same thing :P
04:37:36 <quicksilver> that's just APIs which might help you build one
04:37:39 <matthew_-> indeed
04:37:44 <matthew_-> also, it has a different name
04:37:49 <quicksilver> ;P
04:37:53 <matthew_-> ;)
04:39:15 * ivan` wanders back to his simple little python world
04:39:31 <ivan`> with lack of lazy and messy stream code
04:41:02 <quicksilver> ivanm: a "transparent" distribution architecture for haskell would be a beautiful thing, though
04:41:15 <quicksilver> ivanm: although you'd have to make some decisions about how 'transparent' you really wanted it to be
04:41:19 <ivanm> how do you mean "transparent" ?
04:41:30 <ivan`> is erlang the only thing that does both SMP and network distribution properly?
04:41:36 <ivan`> it seems like i can't have both worlds
04:41:38 <Botje> see-through lingerie for cabal packages!
04:42:36 <matthew_-> ivan`: yeah, that wouldn't surprise me
04:42:45 <quicksilver> ivanm: well, so that code didn't need to be aware it was running on multiple machines
04:42:50 <matthew_-> the only issue is that erlang's SMP support is currently rubbish
04:42:52 <quicksilver> ivanm: to some extent, at least
04:43:11 <ivanm> quicksilver: *nod*
04:43:15 <ivan`> if there's any confusion i'm not ivanm
04:43:18 <ivan`> nor ivan
04:43:22 <matthew_-> so running the erlang VM with SMP support turned on often results in things running more slowly across multiple cores than on a single core
04:43:29 <ivanm> ivan`: nor ivant? :p
04:43:38 <ivan`> heh
04:43:54 <matthew_-> I reckon you are the same person and just like talking to yourself ;)
04:44:14 <Botje> ivanBACKQUOTE
04:44:17 <ivan`> backtick
04:44:44 <pejo> ivan, did you check GdH?
04:44:48 <hkBst> nasty insects, them backticks
04:44:48 <quicksilver> I was aware that you were different people
04:44:58 <quicksilver> but tab-complete did get the wrong one at one point :)
04:45:06 <quicksilver> thus drawing ivanm into the conversaton by mistake :)
04:45:19 <ivan`> i'm looking at GdH
04:45:27 <quicksilver> tab-complete always seems to prefer pure alpha names to partly punctuation names...
04:45:43 <pejo> But as you mention, Erlang has a pretty good track record in the kind of thing you seem to want to do.
04:45:44 <ivan`> last-used order works for me
04:49:08 <mux> System.FilePath.Find is really sexy
04:51:14 <yitz> @seen bos
04:51:15 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 1d 5h 42m 51s ago.
04:51:26 <yitz> Well, let him know that next time you see him.
04:51:40 <mux> yeah, I intend to :-)
04:52:28 <quicksilver> although 'find' should be called unsafeDontUseThisFind
04:52:32 <quicksilver> 'fold' is nice though :)
04:52:50 <mux> what's so unsafe about find ? *gulps*
04:52:54 <mux> I just switched to using it
04:52:59 <quicksilver> it's unsafe interleaving IO
04:53:06 <mux> files <- find always (anyPerms 0111) path
04:53:15 <mux> recursing over all executable files in a directory
04:53:20 <mux> so, ugh, you're saying the above code is unsafe?
04:53:21 <yitz> It's not _so_ unsafe - just a little.
04:53:23 <quicksilver> you could do really strange stuff if you do anythign which changes the predicate
04:53:29 <mux> ah
04:53:32 <quicksilver> before you'd consumed the whole list
04:53:37 <mux> I guess my usage is ok though
04:53:53 <mux> it's not doing anything funky with the predicates
04:54:06 <quicksilver> as long as you know that none of the code that operates on files would affect the output of files
04:54:09 <quicksilver> as it were
04:54:15 <quicksilver> e.g. as long as none of it is changing permissions
04:54:21 <yitz> I think the only issue is that if something changes in the fs while you are iterating you may get weird results.
04:54:22 <quicksilver> creating new dirs
04:54:22 <quicksilver> etc
04:54:25 <mux> okay, I'm not doing this
04:54:38 <quicksilver> yitz: or if *you* change something in the fs, while you are iterating
04:54:45 <yitz> right.
04:54:52 <quicksilver> yitz: you could easily set up an infinite loop if you create a directory, e.g.
04:54:56 <mux> both sound unpleasant
04:55:04 <yitz> unless you are careful
04:55:08 <quicksilver> right
04:55:30 <quicksilver> I just hate it when people add new referentially opaque features to the language
04:55:47 <quicksilver> when I'm busy trying to tell people that referential transparency is one of the reasons I use haskell :)
04:56:07 <quicksilver> have to keep adding "as long as you don't use... hdbc, FilePath.Find .... "
04:56:12 <mux> I think people are conspiring to get you to stop using haskell :-)
04:56:14 <ico> where can I find the haskell's select() implementation, for asynchronously waiting on multiple file descriptors ?
04:56:27 <quicksilver> ico: the canonical answer is 'just use threads'
04:56:32 <mux> ico: you tipically don't use select() / poll() / whatever in haskell, we have threads
04:56:36 <quicksilver> ico: threads do the right thing (they use select() internally)
04:56:40 <ico> ok, I see
04:56:53 <ico> My imperative brain is hurting more and more ...
04:56:59 <quicksilver> if you really want it, it's somehwere in System.POSIX or therabouts
04:57:00 <mux> that's expected
04:57:09 <quicksilver> ico: threads in haskell are really really cheap. Almost free.
04:57:16 <mux> and soooooooooooooo damn easy
04:57:20 <mux> forkIO, that's it.
04:57:20 <ico> I'll take your advice and do the thread thing then
04:57:22 <quicksilver> ico: so it's quite safe to fork two new threads for every file descriptor
04:57:27 <quicksilver> (one for reading, one for writing)
04:57:38 <ico> new to haskell threading though, more to learn today
04:58:37 * mux garbage collects the countless 'do' that end up being useless after code refactoring
04:58:47 <mux> I always, always forget about those
04:59:32 <mux> it's not as if they were harmful, but I find it quite unaesthetic to have many of those scaterred around the code
05:00:24 <quicksilver> makes your code read like frank sinatra
05:00:27 <quicksilver> do be do be do
05:00:35 <mux> heheh
05:04:17 <TSC> I "do" it my way?
05:15:39 <ndm> @seen dcoutts
05:15:39 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 34m 22s ago.
05:16:06 <ndm> @slap dcoutts
05:16:06 * lambdabot smacks dcoutts about with a large trout
05:21:36 <dcoutts> hia ndm
05:21:53 <LeCamarade> Phew. Reddit is back.
05:24:15 <yitz> Besides threads, you can also use hGetBufNonBlocking
05:25:46 <yitz> Underneath  the hood, I don't think GHC uses select/poll/epoll at all.
05:26:17 <dcoutts> yitz: yes it does
05:26:32 <mux> it has no choice but using those functions
05:26:33 <yitz> I heard that Einar K. experimented with these in his network-alt library.
05:26:48 <mux> otherwise you just cannot implement forkIO
05:26:49 <yitz> oh yeah? interesting.
05:26:53 <dcoutts> that's exactly how ghc does all blocking and non-blocking IO
05:27:06 <mux> that's exactly how any 100% userland threading library does it
05:27:08 <yitz> OK
05:27:13 <mux> ie, libc_r under FreeBSD is doing the same
05:27:28 <mux> you have no choice about it, you _need_ to prevent blocking
05:28:31 <dcoutts> yitz: it could be improved to use system-specific improvements over poll/select
05:28:35 <dcoutts> ie kpoll, epoll etc
05:30:56 <mux> kqueue, kevent
05:31:05 <dcoutts> oh, right
05:31:15 <mux> it sure would help for cases where we have many threads
05:31:20 <profmakx> anyone tried bootstrapping ghc on FreeBSD-Current/amd64? I am getting stuck when compiling the rts
05:31:42 <dcoutts> mux: that should be easier to do now in the threaded rts
05:31:42 <mux> profmakx: what's the error message?
05:31:53 <mux> dcoutts: I need to take a look at this code
05:31:53 <dcoutts> mux: since the IO manager thread is implemented in Haskell
05:31:58 <mux> hmm, nice
05:32:12 <dcoutts> mux: so it should be easier to do system-specific impls of it
05:32:17 * mux nods
05:32:35 <profmakx> mux Linker.c:3556:0: error: `R_X86_64_32S' undeclared (first use in this function)
05:32:46 <mux> hmm, unfriendly message :-)
05:33:23 <yitz> There are Simon posts that report problems with poll/select. He says readNonBlockingFD is implemented using read with O_NONBLOCK. http://www.haskell.org/pipermail/haskell-cafe/2006-February/014619.html
05:33:25 <lambdabot> Title: [Haskell-cafe] Re: standard poll/select interface, http://tinyurl.com/2xxajz
05:33:26 <profmakx> it has something todo with "MAP_32BIT"
05:33:34 <dcoutts> mux, profmakx: it'll be some #ifdef problem I expect
05:33:39 <mux> yeah
05:33:46 <mux> it's hard to tell without more context though
05:33:52 <mux> and context may be totally lost at this point
05:33:56 <dcoutts> "MAP_32BIT" is a linux thing I think
05:34:06 <profmakx> yes it is
05:34:07 <dcoutts> it's to mmap into the first 32bit of the address space
05:34:15 <mux> profmakx: I have yet to test building GHC on RELENG_7, but I'll do soon
05:34:16 <dcoutts> eg for loading code
05:34:34 <mux> since 7.0-R is for soon now, we'd better make it possible for people that install it to use ghc
05:34:43 <mux> dcoutts: oh, evil
05:34:57 <profmakx> unfortunately i am in no way a ghc expert i don't know where to start :)
05:35:00 <mux> it's the kind of things wine uses
05:35:09 <mux> to map DLLs at their expected address
05:35:18 <dcoutts> mux: no, that's MAP_FIXED
05:35:34 <mux> MAP_FIXED is portable
05:35:38 <mux> I'm definitely talking about something else
05:36:05 <dcoutts> mux: I thought it was to do with the 'small' code model, where function pointers are 32bit and get sign-extended to 64bit
05:36:06 <mux> (and MAP_FIXED can fail)
05:36:33 <mux> dcoutts: I know there's something else: we are lacking some feature that wine needs, and wine is thus failing for us
05:36:38 <mux> maybe that has been fixed though
05:36:39 <profmakx> thats what it says in linker.c
05:36:59 <mux> anyways, undefined MAP_32BIT sounds like worth trying, at least
05:37:14 <profmakx> well i defined MAP_32BIT to be 0
05:37:25 <profmakx> then the error i pasted earlier turned up
05:37:50 <mux> beware, they may check for it using #fdef
05:38:01 <mux> in which case, it would still succeed if you defined MAP_32BIT to 0
05:38:05 <mux> try #undef MAP_32BIT
05:39:26 <profmakx> i might also have gotten something wrong with the bootstrap setup, because they #ifdef x86_64_HOST_ARCH
05:39:30 <profmakx> but the host is 32bit
05:39:36 <profmakx> the target is 64
05:39:53 <profmakx> i think i will try a clean start first :)
05:42:23 <ekidd> Good morning.
05:44:30 <LeCamarade> ekidd: Good afternoon.
05:45:20 <TomMD> @time LeCamarade
05:45:22 <lambdabot> Local time for LeCamarade is Mon Oct 15 15:45:17 2007
05:47:57 <profmakx> LeCamarade is ahead of my timezone!
05:51:11 <LeCamarade> :o)
06:03:23 <mux> damn, and I thought haskell-cafe@ would be low volume
06:06:33 <roconnor> *l*
06:06:48 <roconnor> apparently haskell-cafe is a flamewar fest
06:07:38 <ndm> yeah
06:07:52 <ndm> but jerzy seems to have started 2 in 2 days
06:09:39 <quicksilver> jerzy appears to be failing to communicate effectively in some cases
06:09:44 <quicksilver> a lot of cross-purposes going on
06:09:59 <quicksilver> I recommend a good user agent for reading the cafe :)
06:10:44 <quicksilver> does anyone know if isaac dupree is an IRCer?
06:13:47 <pierre-> hi all
06:14:13 <ndm> hi pierre-
06:24:52 <igel> is there a Vector type in haskell?
06:25:08 <igel> one that allows indiced access to elements in O(1)?
06:25:17 <kpreid> igel: Data.Array
06:25:39 <igel> yeah sure, but i mean one that has insert and delete already implemented
06:25:53 <igel> so that the array is replaced if it is to small
06:26:22 <ADEpt> igel: you need growable one? Data.Sequence. Not O(1), but O (nlogn) (IIRC)
06:27:01 <ADEpt> igel: besides, you might be better off with Data.Map or Data.IntMap, depending on your task
06:27:35 <igel> there is no task, i was just wondering
06:27:51 <ADEpt> igel: then, DataIntMap it is :)
06:30:25 <igel> how come IntMap a is faster than Map Int a?
06:30:41 <quicksilver> cleverer algorithm
06:30:51 <quicksilver> using the internal structure of ints
06:31:31 <quicksilver> Data.Sequence does things in O(log (distance from nearest end))
06:31:41 <quicksilver> which is as good as O(1) in practice, in many cases
06:31:46 <ADEpt> +1
06:32:05 <igel> hmm, i have some time today
06:32:10 <quicksilver> of course it does some things faster
06:32:32 <igel> i'll just check out data.seq and write a Vector
06:32:48 <quicksilver> append is O(log(smaller sequence))
06:33:03 <quicksilver> whereas append in a naive vector is O(sum of sizes of two sequences)
06:33:23 <igel> sure, a vector is quite static
06:33:30 <igel> but reading is fast
06:33:45 <igel> i normally use vectors for, say, guis
06:33:54 <igel> if you represent a list
06:34:11 <igel> and everytime it is displayed, you need index-based access to the elements
06:34:19 <quicksilver> but you don't, of course :)
06:34:23 <igel> much more often that changing the original strucutre
06:34:30 <quicksilver> typically displaying a list involves iterating through it
06:34:35 <quicksilver> or iterating through a sublist
06:34:39 <quicksilver> not indexed access...
06:34:49 <etnt> I just noticed the binary stuff, now I wonder if there exist anything similar to Erlang's bitsyntax ?
06:35:10 <igel> hmm that sounds reasonable^^ :)
06:35:34 <quicksilver> igel: in practice I would be very surprised if a sequence fails to provide good enoguh performance
06:36:02 <quicksilver> the main disadvantage of a sequence over traditional imperative structures is not O(1) access, but memory locality
06:36:23 <igel> well it might prove ineffective for index-based replacing then
06:36:24 <quicksilver> so if you used a sequence for 1 million elements in a very random access fashion
06:36:43 <MyCatSchemes> quicksilver: my cache hurts at the very prospect.
06:36:47 <quicksilver> then your main problem would be that the imperative C++ array-based vector has locality
06:36:52 <quicksilver> exactly, MyCatSchemes
06:37:16 <quicksilver> igel: update on sequence is O(log (distance to nearest end))
06:37:42 <quicksilver> cache locality and memory access patterns are much more important than notional O(1) access
06:37:53 <quicksilver> This is, in fact, because O(1) access isn't really O(1) :)
06:38:04 <quicksilver> O(1) access is only O(1) if you also have a cache hit
06:38:12 <igel> do you mean paging issues?
06:38:12 <EvilRanter> or, depending on how you look at it, O(log n) is really O(1)
06:38:14 <quicksilver> and C++-arrays are much more likely to get cache hits most of the time
06:38:24 <EvilRanter> ;)
06:38:26 <quicksilver> igel: well not paging in the OS sense, no
06:38:41 <quicksilver> igel: but caching at the CPU cache level
06:38:49 <quicksilver> similar ideas of course
06:39:08 <igel> ok.. that's new to me
06:39:45 <quicksilver> for "normal" applications, such as your GUI example, you will not find the data structure to be the bottleneck
06:39:57 <quicksilver> and you would be please with Data.Sequence's performance
06:40:12 <quicksilver> you might even win somethign over the C++ equivalent due to fast growing and appending
06:40:15 <quicksilver> in some cases
06:40:19 <quicksilver> and you get cheap undo support for free!
06:40:20 <igel> well i'm not really into gui programming with haskell
06:40:21 <quicksilver> which is really nice
06:40:42 <quicksilver> the main kind of example where data locality would bite you would be writing a graphics package
06:40:44 <igel> the last gui framework i really learned was awt/swing
06:40:52 <quicksilver> you wouldn't want to Data.Seq an entire image of pixels
06:40:57 <quicksilver> that would be painful
06:41:09 <quicksilver> say, 80 million pixels, 4 bytes each :)
06:41:25 <igel> and implementing a swing model means implementing interfaces with methods like "elementAt(int)"
06:41:57 <igel> and if such a method is invoked once for each displayed index, it is better to have random access :)
06:45:19 <quicksilver> typically it's enough that the complexity is not O(n)
06:45:31 <quicksilver> O(log n) is much much better than O(n)
06:46:01 <quicksilver> it's unusual to find examples where O(1) vs O(log n) matters; it's also fiendishly hard to demonstrate and analyse
06:46:16 <quicksilver> because various hardware issues confuse the difference between the two anyway
06:46:34 * roconnor prefers O(inverse ackermann(n))
06:46:46 <iank> roconnor: :'D
06:47:05 * MyCatSchemes prefers O(inverse ackermann(n,graham's number))
06:47:25 <igel> :D
06:47:26 <LeCamarade> O(0)
06:47:28 * iank prefers O(3)
06:47:38 <roconnor> O(3)=O(1)
06:47:54 <iank> .. I know.
06:47:55 <LeCamarade> o(-1) -- Predicts.
06:48:06 <iank> But I rather like to bullshit that O(3) takes three times as long :)
06:48:07 <osfameron> at YAPC::Vienna Damian Conway showed us how to write code in O(-1) time
06:48:15 <MyCatSchemes> O(busybeaver-inverse(n))
06:48:36 <osfameron> using positronic variables that travel back in time
06:48:36 <roconnor> MyCatSchemes: know any non-constant algorithms known to be of that order?
06:48:46 <LeCamarade> :o)
06:49:13 <LeCamarade> Bottom algorithms?
06:49:21 <MyCatSchemes> roconnor: depends what you're measuring. Certainly none of that order in time. ^_^
06:49:59 <profmakx> mux, i seem to have got the rts to compile by undefining x86_64_HOST_ARCH
06:50:03 <roconnor> There is some unification algorithm that is O(n*inverse achermann(n))?
06:57:37 <kosmikus> ndm: ping
06:58:57 <fasta> Can I catch stack overflows?
06:59:37 <roconnor> interesting question
06:59:45 <roconnor> should be easy to test
07:00:12 <fasta> It doesn't say ***Exception Foobar
07:00:24 <fasta> So, it seems that it works on a different level.
07:00:33 <fasta> Which would imply the answer was no.
07:01:28 <LeCamarade> > let die () = 0 + die () in die ()
07:01:33 <lambdabot>  Exception: <<loop>>
07:01:34 <roconnor> :(
07:01:51 <LeCamarade> It says Exception for me.
07:02:27 <roconnor> LeCamarade: that isn't a stack overflow
07:02:28 <vincenz> it's not that simple in general tho
07:02:33 <vincenz> with lazy data structures
07:02:39 <vincenz> you coudl have the overflow during consumption and not construction
07:02:40 <roconnor> > foldl (+) 0 [1..]
07:02:49 <lambdabot> Terminated
07:02:52 <roconnor> > foldr (+) 0 [1..]
07:02:55 <lambdabot>  Exception: stack overflow
07:03:01 <vincenz>  ^^^^^^^^
07:03:04 <LeCamarade> From GHCi: *** Exception: stack overflow
07:03:16 <vincenz> @hoogle catch
07:03:17 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
07:03:17 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
07:03:17 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
07:03:47 <ToRA> Prelude Control.Monad.Fix Data.List Control.Exception> Control.Exception.catch (print $ foldr1 (+) [0..]) (const $ putStrLn "caught")
07:03:48 <ToRA> caught
07:03:52 <LeCamarade> catch is for IO actions only, no?
07:04:01 <vincenz> add a return :)
07:04:13 <vincenz> ToRA: try "return" iso "print"?
07:04:18 * Olathe returns.
07:04:34 <fasta> Maybe it is because I use xc that the Exception *** isn't printed in compiled programs.
07:05:04 <roconnor> LeCamarade: correct.  You have to catch an IO action that demands a stack overflow
07:05:12 <ToRA> vincenz: if you s/return/print then it fails
07:05:15 <roconnor> otherwise there would never be a stack overflow
07:05:16 <ToRA> but i'd expect it to
07:05:33 <ToRA> since it's the print call in ghc that is forcing the foldr1
07:05:38 <ToRA> *ghci
07:05:59 <LeCamarade> Oh. :o)
07:06:01 <vincenz> i guess you'd need to seq it
07:06:39 <quicksilver> even imprecise exceptions can only be caught in IO
07:06:40 <Saizan> ?type evaluate
07:06:40 <ToRA> ah nice, with ghci 6.8
07:06:42 <ToRA> Prelude> foldr1 (+) [0..]
07:06:42 <ToRA> Stopped at <exception thrown>
07:06:42 <ToRA> _exception :: e = stack overflow
07:06:42 <lambdabot> Not in scope: `evaluate'
07:06:43 <ToRA> [<exception thrown>] Prelude>
07:06:45 <quicksilver> see the awkward squad paper
07:07:12 <quicksilver> unless I'm mistaken
07:07:58 <LeCamarade> :t par
07:08:00 <lambdabot> forall a b. a -> b -> b
07:09:42 <quicksilver> catching imprecise exceptions in pure code would violate referential transparency, I think
07:10:20 <vincenz> yep
07:10:33 <LeCamarade> But I don't know if I'll ever grow to like exceptions. Even before I knew about Maybe a, I didn't like them.
07:11:55 <quicksilver> I think they have their place
07:12:20 <quicksilver> but in many (most?) situations there are preferrable alternatives
07:12:21 <roconnor> whare are imprecise exceptions?  Violations of the abstract machine?
07:12:38 <ndm> kosmikus: pong
07:12:38 <quicksilver> they're a kind of _|_
07:12:53 <quicksilver> as such, I think they're denotationally ok
07:13:07 <roconnor> stack overflow isn't _|_
07:13:18 <quicksilver> the strange part is that you can catch them..
07:13:24 <quicksilver> but IO is allowed to be strange
07:13:30 <dcoutts> roconnor: that's an asynchronous exception
07:13:35 <roconnor> oh
07:13:40 <dcoutts> as is heap overflow
07:13:48 <dcoutts> or an exception thrown from another thread
07:13:56 <roconnor> quicksilver: I keep encountering things which are both outside and inside.
07:14:02 <fasta> So, can I happily continue the complete program despite the stack overflow?
07:14:25 <dcoutts> fasta: you can catch it in some outside exception handler in IO
07:14:31 <quicksilver> fasta: in general it's hard to tell "how far things got" before the overflow
07:14:38 <roconnor> fasta: doesn't seem so unreasonable.  The entire IO action is aborted, stack is cleaned up, everyone is happy.
07:14:41 <quicksilver> fasta: but if you don't care, then you can continue
07:14:55 <quicksilver> if you do care, then you hace to implement some kind of 'checkpointing' into IORef/Mvar
07:14:59 <quicksilver> or similar
07:15:12 <dcoutts> fasta: ghci catches does exactly that for example.
07:15:30 <dcoutts> it catches all exceptions, prints them and goes back to the read/eval loop
07:15:31 <roconnor> well, the IO action is aborted baddly.  Side-effects stay.
07:15:36 <fasta> quicksilver: The application is that I do a thousand "tasks" and I either want to know how long the took or whether they failed.
07:15:46 <quicksilver> roconnor: "aborted" rather than "rolled back"
07:15:51 <quicksilver> fasta: yes, that should be fine
07:15:53 <fasta> quicksilver: but I don't want to babysit the machine, so it seems like it should work
07:16:05 <fasta> they*
07:16:10 <quicksilver> fasta: but if some of the tasks have IO side-effects, it is possible that the failed ones caused partial side-effects
07:16:17 <dcoutts> quicksilver: though if you use bracket carefully you could arrange to roll things back explicitly
07:16:25 <quicksilver> dcoutts: absolutely
07:16:26 <dcoutts> eg deleting temp files etc etc
07:16:35 <fasta> quicksilver: the tasks only have side-effects at the beginning
07:16:37 <quicksilver> dcoutts: but the dfault behaviour alone doesn't do that :)
07:16:41 <dcoutts> yes
07:16:42 <quicksilver> fasta: then it should be quite fin
07:16:51 <quicksilver> fasta: see sjanssen's earlier post about futures
07:16:54 <fasta> quicksilver: which are guaranteed to be completed before a stack overflow can occur.
07:17:17 <fasta> quicksilver: I am not subscribed anymore, since there was too much noise.
07:17:41 <fasta> I do check the archives occasionally, but I used to read everything
07:17:44 <wsdo_okadr> I would like to ask regarding Context-Dependent grammars
07:17:54 <wsdo_okadr> for example I read in some textbook I have(wich I find pretty good that)
07:18:08 <wsdo_okadr> LR1={wcw | w in (0,1)*}
07:18:11 <wsdo_okadr> wich is quite ok
07:18:14 <wsdo_okadr> but c is not quite defined
07:18:33 <fasta> And Google isn't what it used to be either.
07:18:35 <wsdo_okadr> I have a hunch it's some context
07:18:57 <wsdo_okadr> but What is it more exactly ?
07:19:21 <fasta> wsdo_okadr: it seems some constant expression
07:19:21 <wsdo_okadr> (0,1)* I know that is the freegroup generated by 2 elements(0 and 1 in this case)
07:19:50 <wsdo_okadr> all sequences of 0 and 1 that have at some point a constant
07:20:06 <fasta> wsdo_okadr: you should complain to whoever gave you that book :)
07:20:39 <mrd> not quite. it has to be the same sequence of 0s and 1s on either side of c
07:20:50 <mrd> what you described is regular
07:21:53 <glen_quagmire> hai my name is lolcatz i here to conquore
07:23:00 <wsdo_okadr> mrd: yes you're right,I wasn't paying enough attention
07:23:29 <wsdo_okadr> What is usually understood by |w| where w is some word generated by {0,1} ?
07:23:35 <wsdo_okadr> in the context of formal languages
07:23:50 <wsdo_okadr> I forgot it was written at the start of the book.
07:25:21 <quicksilver> fasta: I actually meant h paste post :)
07:25:26 <quicksilver> fasta: he said something here about it
07:25:31 <quicksilver> fasta: I'll find it for you
07:25:39 <fasta> quicksilver: oh, so Google is still fine ;)
07:26:00 <quicksilver> fasta: http://hpaste.org/3299
07:26:03 <kosmikus> ndm: well, I was a bit irritated about System.FilePath docs mentioning isDrive etc., but not exporting the functions
07:26:08 <quicksilver> fasta: the thid annotation
07:26:14 <kosmikus> ndm: but I found out that they're only exported by the Windows version
07:26:19 <quicksilver> fasta: note that it has the exceptions in the type
07:26:28 <kosmikus> ndm: do you happen to know what System.Info.os reports for a Windows system?
07:28:03 <fasta> quicksilver: I don't see the significance of that, but I do something very similar already.
07:28:25 <fasta> quicksilver: I adapted the "compete" function from the wiki.
07:29:07 <quicksilver> the significance was that it caught all exceptions
07:29:13 <quicksilver> including, presumably, stack overflows
07:29:19 <quicksilver> and turned them into exception values
07:30:18 <fasta> @type try
07:30:21 <lambdabot> Not in scope: `try'
07:33:52 <fasta> quicksilver: I suppose the significance is that other languages have builtin "futures" and in Haskell you can build them yourself, since otherwise this is isomorphic to what I did.
07:34:51 <quicksilver> fasta: fair enough
07:36:48 <fasta> quicksilver: but after a stack overflow, have I lost the rest of the control stack?
07:37:10 <quicksilver> I don't know how threads and stack overflows inter-relate
07:37:13 <fasta> Can I protect a part somehow?
07:37:16 <quicksilver> I'd hope it was thread local but I'm not sure
07:37:23 <dcoutts> fasta: it's really just like any other exception
07:37:38 <dcoutts> fasta: you can use catch, bracket etc etc
07:37:49 <fasta> dcoutts: ok, so it only destroys everything up to the point of the IO action that started the mess?
07:38:17 <dcoutts> fasta: catch is a wrapper round a computation, so you don't get the result of the computation, you get the exception instead
07:38:51 <fasta> dcoutts: ok, nice.
07:39:16 <ndm> kosmikus: "mingw32"
07:39:18 <fasta> "stack overflow" seemed to indicate that it overwrote the start of the stack somehow.
07:39:38 <fasta> But I guess the implementors are not that stupid ;)
07:39:41 <quicksilver> no, just that the stack ran out of the space it decided to allocate for it
07:39:54 <roconnor> I think the stack allocator knows how much space is available.
07:39:54 <quicksilver> haskell has a checked stack, in other words
07:40:01 <ndm> kosmikus: which is pure evil, of course
07:40:17 <roconnor> ndm: so that is why haskell is slow ;)
07:40:37 <ndm> roconnor: ?
07:40:41 <ndm> evil /= slow
07:41:01 <roconnor> ndm: oh, why is a checked stack evil if not because it is slow?
07:41:11 <roconnor> ndm: woops
07:41:16 <roconnor> you are responding to kosmikus
07:41:19 <fasta> When I use the xc feature, I still get a "stack trace", although I catched the exception.
07:41:19 <roconnor> my bad
07:41:25 <ndm> roconnor: oh, yeah, stack overflow is evil because of slowness
07:41:37 <ndm> roconnor: but heap checks are much more easy to remove, and just as slow
07:41:50 <roconnor> AFAIK, only prim-ops use the stack.
07:42:00 <roconnor> but I sort of think I might be wrong.
07:42:12 <fasta> I find it odd that I get stack overflow, though. I was expecting to run out of heap space, but I guess the two compete for the same memory at some point.
07:42:26 <ndm> roconnor: its the Haskell stack, not the C stack
07:42:51 <ndm> fasta: stack overflow really does mean stack overflow, not because of heap pressure
07:42:54 <roconnor> ndm: yeah, but I thought GHC used the heap for everything other than + and *.
07:43:03 <wsdo_okadr> hi ndm
07:43:06 <wsdo_okadr> ndm: nice to see you :)
07:43:20 <ndm> roconnor: it has a separate stack (which is on the C heap)
07:43:26 <ndm> hi wsdo_okadr - have we met?
07:43:33 <roconnor> ndm: really?
07:43:38 <roconnor> ndm: what gets pushed?
07:43:44 <kosmikus> ndm: I see, thanks
07:43:47 <ndm> roconnor: yes, parameters to functions
07:44:11 <roconnor> ndm: really?
07:44:15 <ndm> roconnor: really :)
07:44:27 <ndm> (with about 85% confidence)
07:44:37 <roconnor> I figured it would just change focus on a graph when ``entering'' a function
07:44:52 <ndm> its not really a graph reduction machine at its heart
07:44:55 <roconnor> I should go reread how a G-machine works.
07:45:00 <ndm> by the time its been converted to CMM etc
07:45:06 <roconnor> ndm: oh
07:45:24 <ndm> its kinda graph reduction, but the actually gritty details don't look much like it by the end
07:45:27 <roconnor> does CMM have a stack?
07:45:42 <quicksilver> In general I don't think it will push a new parameter reference on the stack if there is still one reachable
07:45:43 <ndm> yes, but GHC creates its own "stack" in the CMM heap
07:45:49 <quicksilver> will means it has to do it 'sometimes'
07:45:56 <quicksilver> but not always. I think.
07:46:02 <roconnor> ndm: interesting
07:46:17 <roconnor> ndm: can you make an example of a stack overflow without using primops?
07:46:34 <quicksilver> foldl' (+) 0 [1..]
07:46:44 <roconnor> isn't (+) a primop?
07:46:44 <quicksilver> the fact that might use primops is not relevant
07:46:49 <quicksilver> use Integer if you like
07:46:52 <quicksilver> or a custom Num instance
07:47:09 <quicksilver> it's a stack overflow however (+) is written
07:47:19 <quicksilver> as long as (+) is strict in both parameters
07:47:23 <roconnor> quicksilver: you are claiming that will give a stack overflow even on Data Nat = Zero | Succ Nat ?
07:47:38 <roconnor> quicksilver: ah right, no primops and no seq.
07:47:47 <quicksilver> "as long as (+) is strict in both parameters"
07:47:48 <roconnor> even still, I'll try your example.
07:47:52 <quicksilver> you don't need to use seq to be strict
07:47:58 <quicksilver> some things just are strict...
07:48:18 <quicksilver> actually (+) only needs to be strict on one side but I was too lazy to work out which
07:48:24 <quicksilver> the point is, you build up an infinite thunk
07:48:29 <quicksilver> and infinite thunks are a stack overflow
07:48:43 <wsdo_okadr> ndm: yesterday
07:49:07 <wsdo_okadr> wsdo_okadr: I read hughes article on FP and came here to talk about it
07:50:17 <ndm> ah, i remember
07:50:22 <ndm> under a different username?
07:50:26 <roconnor> quicksilver: stack overflows, not heap overflows?
07:51:31 <quicksilver> roconnor: yes
07:51:40 <quicksilver> roconnor: infinite thunks are stack overflows
07:59:40 <Tac-Tics> I imagine *thunk* is the sound a thunk actually makes when it gets evaluated in Haskell
08:00:06 <roconnor> quicksilver: I get heap exhausted
08:00:12 <roconnor> @paste
08:00:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:00:45 <hpaste>  roconnor pasted "attempt to stack overflow" at http://hpaste.org/3300
08:00:55 <ndm> LeCamarade: just finished reading your "C sucks" article
08:01:10 <hpaste>  roconnor annotated "attempt to stack overflow" with "Result: Heap exhausted" at http://hpaste.org/3300#a1
08:01:17 <Saizan> roconnor: i think you need foldr to stack overflow
08:01:17 <ndm> i love the qwe123 quote :)
08:01:26 <Saizan> > foldr (+) 0 [1..]
08:01:29 <lambdabot>  Exception: stack overflow
08:02:09 <roconnor> Saizan: I get a screen full of Succs, and then the same heap exhausted error.
08:02:21 <fasta> Can this cause a stack overflow? f x  = maybe (return x) (\k -> f k) (foo x)
08:02:22 <roconnor> Saizan: the goal is to generate a stack overflow without using a prim-op
08:02:52 <Saizan> roconnor: ah well, define (+) to pattern match on the right
08:03:06 <quicksilver> roconnor: but you have a lazy (+)
08:03:08 <fasta> I am currently assuming that that runs in constant space.
08:03:14 <quicksilver> I'm talking about a strict (+)
08:03:15 <roconnor> Saizan: will foldr (flip (+)) work fo you?
08:03:23 <fasta> (as an iterative recursive process)
08:03:30 <roconnor> quicksilver: how would you like me to make it strict?
08:03:42 <quicksilver> not use the peano numbers?
08:03:56 <quicksilver> you seem to be drawing a fallacious link between strict and primops?
08:04:05 <Saizan> roconnor: it should, still heap overflow?
08:04:06 <quicksilver> ok, Int is strict, and Int has primops
08:04:09 <roconnor> quicksilver: if I don't use peano numbers, I have to use a primop ... which is my point: only prim-ops cause stack overflows.
08:04:09 <quicksilver> but that's not the point :)
08:04:16 <quicksilver> no, that's not true
08:04:25 <quicksilver> a type can be strict and not primop
08:04:37 <roconnor> quicksilver: fine, how do I make it strict?
08:05:11 <roconnor> and not use primops
08:06:27 <roconnor> Saizan: foldr (flip (+)) still gives me a heap exhausted error.
08:07:29 <roconnor> I don't see how to make any operatation strict without using either a primop or perhaps using DeepSeq.
08:09:04 <roconnor> ah, got it!
08:09:12 <roconnor> foldr (++) [] (repeat ([]::[()]))
08:09:19 <roconnor> stack overflow!
08:09:22 <roconnor> w00t
08:09:25 <roconnor> > foldr (++) [] (repeat ([]::[()]))
08:09:33 <tibbe> if B.pack "my constant string" appears somewhere in the middle of an expression will GHC hoist it to the top level as a true constant or will it recompute it every time?
08:09:37 <lambdabot>  Exception: <<loop>>
08:09:45 <tibbe> or will laziness do the trick?
08:09:47 <roconnor> WTF!
08:10:08 <roconnor> :(
08:10:19 <quicksilver> 'loop' is essentially a way that ghc can detect certain stack overflow conditions
08:10:22 <quicksilver> among other things
08:10:23 <roconnor> It gave me a stack overflow on GHC 6.6
08:10:27 <quicksilver> obviously it's not guaranteed
08:10:41 <roconnor> (to be honest, I was excepting loop)
08:10:46 <Saizan> lambdabot: uses -O2
08:11:13 <Saizan> ?src (++)
08:11:13 <quicksilver> tibbe: in principle it will recompute it every time, but I have a feelig there is a rewrite rule for it
08:11:13 <lambdabot> (++) []     ys = ys
08:11:14 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
08:11:38 <quicksilver> tibbe: and because of the rewrite rule, it will only be computed once. Not sure though.
08:11:39 <tibbe> quicksilver: ok, I guess I should just check the -dump-simpl
08:11:56 <roconnor> -O2 on ghc 6.6 still gives me a stack overflow
08:12:01 <quicksilver> roconnor: to answer your question "How do I make a (+) strict without primops" the answer is generally "use case"
08:12:16 <quicksilver> roconnor: case is the primitive haskell concept which implements strictness
08:12:22 <roconnor> quicksilver: I understand that, but that only puts it in head normal form.
08:12:26 <quicksilver> right
08:12:35 <roconnor> quicksilver: is that strict enough for you?
08:12:39 <quicksilver> but if your type is shallow that is strict enough :)
08:12:46 <quicksilver> and in this case, it was enough for []
08:12:53 <quicksilver> because of the the way you were using []
08:13:02 <quicksilver> which "wasn't very deep"
08:13:28 <roconnor> anyhow, I'm moderately happy I got a stack overflow
08:13:36 <roconnor> although I'm surprised I don't get loop
08:13:43 <roconnor> and I'm suprised lambdabot does get loop
08:13:50 <Saizan> ?version
08:13:51 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
08:13:51 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:15:38 <quicksilver> I have previously observed odd behaviour with LB
08:15:47 <quicksilver> suggesting it might have some non-standard falgs
08:16:28 <roconnor> indeed
08:20:17 <kosmikus> bringert: thanks a lot for the mail :) looks great!
08:20:59 <bringert> kosmikus: you're welcome! Thanks for the typesetting help.
08:21:27 <kosmikus> bringert: no problem. good luck for the defense.
08:22:34 <bringert> kosmikus: btw, don't you think the font looks a bit weird? I think the glyphs have uneven line width, but noone I've asked seems to be as picky as me. Also, some of the figures are a bit crappy, dot2tex doesn't work that great.
08:23:34 <swiert> bringert: are you defending your thesis soon?
08:23:45 <bringert> swiert: just my lic thesis
08:23:53 <kosmikus> bringert: they look a bit weird, but I assumed that this was beyond your influence
08:23:54 <Igloo> lic?
08:24:01 <swiert> bringert: ah - ok.
08:24:09 <swiert> best of luck though.
08:24:29 <SimonRC> hmm
08:24:39 <SimonRC> after reading some Haskell' stuff...
08:24:41 <swiert> Igloo: licentiate thesis, I think.
08:24:51 <kosmikus> bringert: looks a bit like the file has been generated with PS3 fonts at a specific resolution and then been scaled.
08:25:12 <SimonRC> has a solution to the problem with MonadWriter and associated types been fixed?
08:25:20 <SimonRC> *found
08:25:53 <SimonRC> (there is nowhere to put the Monoid restriction in the associated types syntax)
08:25:56 <swiert> Igloo: It's a milestone in a Swedish PhD after 2/3 years.
08:26:35 <Igloo> Ah, OK, thanks
08:27:51 <bringert> kosmikus: could it have anything to do with how I generted the PDF? I use T1 and lmodern, and pdflatex without any options. Or is it the printer who messed up?
08:28:08 <bringert> Igloo: yeah, what swiert said
08:28:37 <kosmikus> bringert: lmodern should be safe
08:29:03 <kosmikus> are you printing A4 and scaling later?
08:33:12 <roconnor> > foldr const () (repeat ())
08:33:14 <lambdabot>  ()
08:33:31 <roconnor> > foldr (flip const) () (repeat ())
08:33:33 <lambdabot>  Exception: <<loop>>
08:34:27 <roconnor> :/
08:34:43 <Tac-Tics> > repeat ()
08:34:44 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
08:35:15 <puusorsa> this seems interesting, http://hpaste.org/3299 , could someone help me a bit in figuring out how to use it? :)
08:35:17 <wsdo_okadr> > repeat ( repeat () )
08:35:19 <lambdabot>  [[(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
08:35:34 <wsdo_okadr> > let a ()
08:35:34 <lambdabot>  Parse error
08:35:36 <wsdo_okadr> > let a = ()
08:35:36 <lambdabot>  Parse error
08:35:51 <roconnor> > let a = () in a
08:35:53 <lambdabot>  ()
08:35:57 <wsdo_okadr> roconnor: why in a ?
08:35:59 <puusorsa> i thought mkFuture readLine would return something that could be fed to askFuture
08:36:13 <wsdo_okadr> > let a = () in a; repeat ();
08:36:13 <lambdabot>  Parse error
08:36:24 <wsdo_okadr> how can I write multiple lines ?
08:36:29 <wsdo_okadr> for the lambdabot
08:36:33 <roconnor> wsdo_okadr: let in declares local variables for some expression
08:36:54 <wsdo_okadr> I want to write MULTIPLE LINES :)
08:37:08 <roconnor> wsdo_okadr: lambdabot only accepts one expession.
08:37:16 <chessguy> wsdo_okadr, the multiple lines you wrote don't make sense
08:37:32 <roconnor> same way the top level print-eval-loop does.
08:37:38 <roconnor> er
08:37:40 <roconnor> bad example
08:37:54 * roconnor forgot about the other let expression
08:38:05 <roconnor> wsdo_okadr:  there are two let expressions in Haskell
08:38:07 <chessguy> > let a = () in {a; repeat () }
08:38:07 <lambdabot>  Parse error
08:38:14 <quicksilver> puusorsa: it does for some values of 'fed'
08:38:19 <chessguy> > let a = () { a; repeat () }
08:38:20 <lambdabot>  Parse error
08:38:28 <roconnor> wsdo_okadr: one let expression works on expression, the other let works inside do blocks.
08:38:31 <quicksilver> puusorsa: you have to 'feed' it via >>= since they are monadic actions
08:39:00 <puusorsa> oh of course silly me. thanks.
08:39:10 <roconnor> GHCi's top level print-eval-loop is much like being inside a do expression
08:39:27 <roconnor> so GHCi's lets at the prompt are the let's that go inside do
08:39:41 <roconnor> however lambdabot does't work inside the IO monad
08:39:59 <roconnor> so the let expression you give are the other kind.
08:40:18 <roconnor> (except when you give lambdabot a let statement inside a do expression)
08:40:26 <bringert> kosmikus: the pdf is A4 (http://www.cs.chalmers.se/~bringert/publ/lic/lic.pdf), and it think it's just cut to G5 (swedish paper size, 169 x 239 mm, often used for dissertations)
08:40:35 <bringert> s/it/I/
08:41:02 <roconnor> but in that case lambda bot is given something like do { let a = (); return a} , with an explicit do.
08:42:38 <kosmikus> bringert: so it's cut, but not scaled? then I have no idea what went wrong. so if you print the file on your own printer, it also looks like that?
08:42:59 <bringert> kosmikus: no, as far as I remember
08:44:36 <shapr> @quote
08:44:36 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
08:44:38 <shapr> w00!
08:44:39 <bringert> kosmikus: even if it was scaled down, why would it look like that, unless they use some very crappy scaling or scale by a large factor?
08:44:41 <shapr> @quote bringert
08:44:42 <lambdabot> bringert says: psicho: so you are saying that your teacher gave you two days to do an assignment in a language you didn't know?
08:45:24 <kosmikus> bringert: crappy scaling would be enough, even by a small factor
08:45:35 <shapr> Sounds quotable
08:46:24 <kosmikus> shapr: what are you doing these days?
08:46:50 <shapr> kosmikus: Hacking on HAppS, trying to get back into the Haskell community, considering getting a CS degree. What about you?
08:46:53 <bringert> kosmikus: ok, thanks. I'll have someone else print my phd thesis.
08:47:04 <dons> ?yow!
08:47:04 <lambdabot> Can you MAIL a BEAN CAKE?
08:47:14 <bringert> shapr: when are you moving back to sweden?
08:47:38 <bringert> hey dons, did you say that you have a small http implemenation we could embed in cabal-install?
08:47:40 <shapr> bringert: I'm not. Min flickvänn har slutat vår relation.
08:47:50 <bringert> shapr: crap
08:47:53 <dons> bringert: ah yes. i do.
08:48:04 <exDM69> I was reading YAHT last night, and I almost figured out how the IO monad works.
08:48:12 <shapr> bringert: Yeah, that happened a month ago, and I'm still recovering.
08:48:12 <dons> its in the link checker i uploaded to hackage a few months ago
08:48:20 <dons> exDM69: sweet :)
08:48:27 <exDM69> I still didn't quite get what do's and sequencing was about, but I guess I'll figure it out if I try it
08:48:27 <dons> welcome!
08:48:30 <bringert> shapr: how is it doing?
08:48:36 * shapr shrugs
08:48:41 <dons> ?undo do x <- getChar ; y <- getChar ; print (x,y)
08:48:41 <lambdabot> (getChar >>= \ x -> getChar >>= \ y -> print (x, y))
08:48:52 <kosmikus> bringert: so you don't have the university print it for you?
08:48:55 <dons> >>= sequences things by gluing them in a lovely dependency order
08:49:10 <exDM69> I just don't have an intresting idea for a Haskell project. (or in fact, any project)
08:49:17 <kosmikus> shapr: sounds good. I'm back in Utrecht, have you heard?
08:49:21 <shapr> No, I didn't know that!
08:49:27 <dons> exDM69: you could contribute to an existing project, perhaps?
08:49:32 <dons> seen xmonad, for example?
08:49:34 <shapr> Are you there for the long term?
08:49:37 <dons> lots of space there to add code
08:49:40 <exDM69> dons: I don't think I have the skills yet
08:49:56 <kosmikus> shapr: I have a position for 5 years. Let's see what happens.
08:49:56 <dons> you never know till you try :)
08:50:01 <exDM69> dons: and Xmonad is not exactly my brand of vodka
08:50:09 <dons> if you're looking for small tasks, you could try the 99 haskell questions quiz on the wiki
08:50:09 <shapr> dons: Looking at the people locations for AmeroHaskell, the most central location appears to be Portland, think we could find a venue?
08:50:12 <exDM69> dons: I was thinking of writing a card game
08:50:18 <dons> shapr: definitely
08:50:21 <dons> shapr: PSU could do it
08:50:26 <exDM69> dons: there is this one card game that has particularly intresting algorithms
08:50:27 <kosmikus> dons, exDM69: then let's write Xapplicativefunctor ;)
08:50:33 <dons> kosmikus: :)
08:50:37 <dons> conal would love that
08:50:45 <dons> kosmikus: actually, i'm looking to move more code out of the X monad
08:50:58 <dons> user code, for example, should run in a very constrained Reader environment
08:51:29 <kosmikus> dons: sounds good; so that users cannot easily mess up everything?
08:51:34 <dons> right
08:51:41 <dons> we don't really want them calling into the X server
08:51:45 <shapr> dons: Ok, sounds like a plan.
08:51:46 <dons> or messing up the core's internal state
08:51:53 <kosmikus> dons: oh, you've released 0.4, right?
08:51:53 <exDM69> dons: hey, nice. I'll try to check out the wiki.
08:51:55 <dons> shapr: ok, let's set up a mailing list to sort this out
08:51:58 <dons> kosmikus: later today
08:52:00 * kosmikus should probably upgrade again
08:52:01 <dons> the release candidate is out
08:52:08 <kosmikus> what's new?
08:52:30 <dons> rules, so that you can set behaviour for particular clients: e.g. gimp always floats, or mplayer goes on workspace 2
08:52:32 <quicksilver> shapr: that's got to be a weird distribution to make portland central?
08:52:40 <dons> hmm, a gazillion new extensions. gnome support
08:52:44 <quicksilver> shapr: lots of developers in alaska shifting the centre of gravity that way?
08:52:50 <kosmikus> dons: great.
08:53:01 <kosmikus> but actually, I don't really find much I'd want from xmonad.
08:53:07 <kosmikus> it just works.
08:53:13 <dons> yeah, that's good to know
08:53:18 <shapr> quicksilver: Mostly that Oregon and California have the most Haskellers. There's roughly ten Haskellers outside of OR & CA.
08:54:11 <dons> shapr: if you can set up a list, i can start looking for local interest
08:54:15 <kosmikus> oh, it's HCAR time again.
08:54:21 <shapr> dons: Awright
08:54:21 <dons> also, portland's close enough to .ca we might attract Cale down :)
08:54:26 <shapr> Yeah, that would be cool :-)
08:54:28 * kosmikus makes a note to send out a call for contributions.
08:54:42 <dons> kosmikus: scary. i can't imagine how we can keep track of everything new any more
08:54:49 <kosmikus> dons: hehe
08:55:01 <kosmikus> all the more important to have a report on it ;)
08:55:01 <dons> i can send you the weekly news announcements since the last hcar, if you like
08:55:10 <kosmikus> maybe
08:55:19 <kosmikus> I'll first look through my own archives
08:55:22 <dons> yep
08:55:38 <kosmikus> oh, btw, I'm looking for a new editor :)
08:55:42 <kosmikus> this will be the last HCAR I do
08:55:56 <ndm> kosmikus: again? seems very recently the last one went round...
08:56:06 <kosmikus> ndm: 6 months
08:56:12 <kosmikus> it's always been like that
08:56:13 <ndm> yeah, doesn't feel like it!
08:56:19 <dons> been a busy 6 months
08:56:25 <kosmikus> May and November
08:56:28 <ndm> indeed
08:56:37 <ndm> haven't been home for the last month, pretty much
08:56:46 * dons off to work to hammer out some more lambdas
08:56:48 <kosmikus> so, if you guys know anyone who might be interested/suitable for becoming HCAR editor, please tell me
08:57:08 <LeCamarade> dons: Wait!
08:57:09 <shapr> dons: I'll mail you about the list
08:57:15 <dons> LeCamarade: quick!
08:57:15 <kosmikus> I'll send out an announcement together with the release of this HCAR that I'm going to step down
08:57:23 <dons> kosmikus: hmm, i'll see if i can think of someone
08:57:26 <LeCamarade> See? Damn Galois! Dem a go take away our channel friends!
08:57:29 <LeCamarade> :o(
08:57:37 <kosmikus> it would be a shame if it wouldn't be continued though, I think
08:57:45 <dons> kosmikus: need to identify some promising phd student with a few years available
08:57:48 <LeCamarade> dons: Just wanted to congratulate you on the talk - it was a concert!
08:57:52 <LeCamarade> :o)
08:57:56 <dons> hah :)
08:57:57 <dons> thanks.
08:58:00 <exDM69> dons: http://www.korttipelit.net/Kasino_in_English.htm  <<-- this is the one I thaught of doing in Haskell
08:58:03 <lambdabot> Title: Kasino
08:58:03 <kosmikus> dons: yes, a PhD student would be good.
08:58:06 <shapr> LeCamarade: They also fund our channel friends. It'd suck if they all had to start writing Java for a living.
08:58:16 <LeCamarade> We should draw up tour dates for the Lambda band. SPJ and the Wailer.
08:58:30 <shapr> SPJ and the Redexes?
08:58:34 <dons> kosmikus: there's a bunch of guys at chalmers. and some new guys at utrecth (alexey perhaps?)
08:58:41 <dons> kosmikus: people who came to the hackathon might be possibles..
08:59:00 <kosmikus> dons: yes, you can be sure that I'll ask around here in Utrecht.
08:59:06 <dons> :)
08:59:07 <LeCamarade> dons: But why do you people say IPI instead of API? :o)
08:59:09 <byorgey> hm, I don't think Cale's particular slice of .ca is very close to Portland =)
08:59:21 <LeCamarade> Okay. You're pardoned. You may rise.
08:59:22 <dons> LeCamarade: :P I don't! your ears are broken, mate.
08:59:32 <LeCamarade> That came out as mite!
08:59:38 <LeCamarade> `mite'
08:59:40 <dons> streuth
08:59:48 <LeCamarade> pweaver. Another Galois guy.
08:59:56 * kosmikus &
09:00:01 <dons> oh, huh. phil's here. cool
09:00:13 <dons> you should all say hi next time -- he's super interesting.
09:00:16 <exDM69> btw, how should I do random shuffling for a list (or array) in Haskell?
09:00:19 <shapr> @seen pweaver
09:00:19 <lambdabot> I saw pweaver leaving #haskell 36s ago, and .
09:00:33 <shapr> hi pweaver! I hear you're interesting.
09:00:39 <dons> exDM69: there's a new wiki article on haskell.org about random shuffling
09:00:47 <dons> exDM69: check the 'Recent changes' page from the front page
09:00:54 <dons> hey pweaver :)
09:00:57 <pweaver> ?
09:01:00 <dons> how's the serial port hacking going?
09:01:11 <pweaver> how do people know about me, has dons been talking
09:01:17 <dons> sssh1
09:01:23 <LeCamarade> pweaver: We've been told everything about you, we are dying to hear your side of the story. Is it true you speak in Haskell, and need an interpreter?
09:01:37 <exDM69> dons: thanks, I'll check it out
09:01:38 <pweaver> it's going well, the new guy Joel found a Haskell module for serial interface for Win32
09:01:49 <dons> sweet.
09:01:52 <pweaver> ...
09:01:53 <dons> we should bundle that up nicely
09:01:56 <shapr> pweaver: Did you do reflective metaprogramming stuff for Rosetta?
09:01:58 <dons> since it keeps coming up on the mailing lists
09:02:01 * LeCamarade &
09:02:04 <pweaver> i think i did :)
09:02:06 <dons> shapr: yeah, i think so.
09:02:21 <dons> pweaver: do you have a link for that composable monadic semantics magic stuff handy
09:02:27 <exDM69> 0.o, haskell.org is down
09:02:29 <dons> some people here would love to poke around in that, i suspect
09:02:45 <shapr> pweaver: That's nifty.
09:02:51 <dons> exDM69: huh, just went down it seems.might be back up soonish
09:03:46 <pweaver> hmm... i'm not sure
09:03:49 <Igloo> It's not down, just very slow
09:03:54 <Igloo> Are we being dotted again?
09:04:02 <dons> hmm, not that i'm aware of
09:04:09 <pweaver> it was only published a week or two ago
09:04:25 <pweaver> there's supposed to be an October release of the code
09:04:43 <shapr> Haskelldotted!
09:05:00 <Igloo> LA is 130
09:05:51 <shapr> ?
09:05:52 <shapr> oh
09:06:44 <pweaver> ... either dons is invisible at his desk or is chatting from home
09:06:53 <pweaver> or i'm not looking at the right desk
09:08:05 <dons> i'm at home :) getting some furniture delivered today to our new apartment
09:08:19 <pweaver> ah, cool
09:08:23 <dons> Igloo: hmm?
09:08:58 <Igloo> "hmm?"?
09:09:16 <dons> ah, 130 or 1.30?
09:09:21 <Igloo> 130
09:09:23 <dons> load avg?
09:09:25 <Igloo> Yup
09:09:28 <dons> crap
09:09:51 <Igloo> It's fallen to 90 now, so whatever it was might be over
09:10:37 <bringert> dons: I had a quick look at that yesterday, I can't see that it gets the body
09:11:04 <bringert> dons: but that should be easy to fix
09:11:40 <bringert> dons: I guess it could get the body straight to a file
09:12:53 <dons> bringert: yeah, it should be easy enough to hack up , to avoid that dependency
09:13:04 <dons> and maybe do it in bytestrings at the same time
09:14:06 <Igloo> There's no obvious guily page, other than the front page
09:14:28 <apfelmus> hi :)
09:14:37 <apfelmus> i'm looking for file system semantics
09:14:59 <apfelmus> but i'm stumbling in the dark currently
09:15:35 <shapr> apfelmus: Did you see Simon Marlow's email about how getContents only works if the file system also has pure FP semantics?
09:15:52 <Mortez> omg, how can I resolve ambiguous (-) when trying to make a type an instance of class Num :S  I need (-) operator for the fields, but ghci will not understand what I want :(
09:16:14 <shapr> apfelmus: It's several months old, but the summary is that lazy file reading only works if the contents of the file do not change between reads.
09:16:21 <hpaste>  BoudewijnE pasted "SIRDS problem" at http://hpaste.org/3302
09:16:31 <boudewijne> can someone help me on an image-generation problem?
09:16:39 <boudewijne> I can create images using the code on hpaste
09:16:52 <apfelmus> shapr: no, i didn't see it. link?
09:16:52 <boudewijne> but they have a 'line' through them
09:17:49 <shapr> apfelmus: http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/4759 & http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/4761
09:17:50 <lambdabot> Title: gmane.comp.lang.haskell.libraries
09:18:01 <Dybber> Why is maximum not tail-recursive? I get stack overflow when finding maximum of a list with 1 mio items
09:18:08 <shapr> apfelmus: It was on my blog, but my blog does not exist anymore.
09:18:18 <apfelmus> :'(
09:18:44 <shapr> I'll make a new blog when HAppS-Begin is usable for that purpose.
09:19:06 <Igloo> :-)
09:19:15 <Dybber> >maximum [1..1000000]
09:19:28 <apfelmus> actually, i was more interested in the usual POSIX semantics
09:19:41 <apfelmus> how to do atomic file write and stuff?
09:19:51 <boudewijne> can someone please help me?
09:19:54 <shapr> apfelmus: Have you seen http://www.haskell.org/halfs/ ?
09:19:55 <lambdabot> Title: Halfs, A Haskell Filesystem
09:20:05 <shapr> @where halfs
09:20:05 <lambdabot> http://www.haskell.org/halfs
09:20:46 <byorgey> Mortez: maybe paste the code you are having trouble with on hpaste?
09:20:47 <pgavin> @src Bounded
09:20:47 <lambdabot> class  Bounded a  where
09:20:47 <lambdabot>     minBound, maxBound :: a
09:21:06 <byorgey> Dybber: the problem isn't that maximum isn't tail recursive, it's that it isn't strict enough.
09:21:48 <byorgey> Dybber: use foldl1' max instead.
09:21:50 <dons> Igloo: i note the page count for the front page has jumped by about 10k since yesterday
09:21:58 <byorgey> > maximum [1..1000000]
09:22:00 <lambdabot>  1000000
09:22:00 <dons> its over the 900k mark now
09:22:10 <byorgey> well, that works anyway since lambdabot uses -O2.
09:22:38 <byorgey> > foldl1' max [1..1000000]
09:22:39 <lambdabot>  1000000
09:22:57 <Igloo> dons: Do you know if that's faster than normal?
09:22:58 <dons> apfelmus: seen Oleg's zipper file system paper?
09:23:00 <Dybber> byorgey, what do you mean that it "isnt strict enough"?
09:23:12 <dons> Igloo: yes, way faster. typically we see 1-2k per day on the front page
09:23:27 * apfelmus saw it all ;)
09:23:30 <dons> i suspect a lot of that 10k came in the past hour, since i don't recall it being over 900k earlier
09:23:37 <shapr> Sounds it'd be interesting to see the referrers for the past 24 hours.
09:23:54 <Igloo> dons: The only easy fix I have is to make it static. It would be great if someone could look properly at making the wiki more resilient to lots of hits
09:24:02 <apfelmus> i mean, i'm not (yet) looking for a new fp-filesystem
09:24:08 <dons> hmm, the front page really could be static
09:24:10 <fasta> I get the stack overflow during unsafeFreeze
09:24:21 <fasta> I thought that was a noop.
09:24:22 <apfelmus> just how exactly the "normal" filesystem on my box handles concurrency
09:24:29 <Dybber> I thought the stack exception was because of to many recursive calls
09:24:40 <Igloo> dons: It has the events and news on
09:24:50 <dons> Igloo: but those are static
09:24:54 <quicksilver> Igloo: there are well-known solutions to that sort of thing
09:24:57 <dons> you have to 'flush' to get the front page regenerated
09:25:01 <Igloo> And it would also look like you weren't logged in
09:25:12 <apfelmus> are files locked when two processes try to read them? to write them?
09:25:13 <quicksilver> Igloo: mostly they involve putting a mostly-transparent proxy in front
09:25:16 <byorgey> Dybber: the important point is that Haskell is lazy, i.e. expressions do not have to be evaluated until their results are needed.
09:25:18 <Igloo> quicksilver: I know, but we need someone to find a good one and apply it to haskell.org's wiki
09:25:29 <quicksilver> apfelmus: on unix-style systems, there is no locking by default
09:25:39 <quicksilver> apfelmus: on win32-style systems, there is crude pessimistic locking by default
09:26:08 <byorgey> Dybber: so, a call like maximum [1..1000000] might end up as the (yet unevaluated) expression, max 1 (max 2 (max 3 (max 4 ...
09:26:27 <apfelmus> quicksilver: so, it's nondeterministic on unix?
09:26:27 <byorgey> Dybber: then, when the result is finally needed, that huge expression will be evaluated, which will cause a stack overflow.
09:26:36 <Dybber> foldr1 max [1..1000000] is also giving stack overflow. My own tail recursive version doesn't
09:26:42 <Igloo> The Haskell98 file operations impose single-writer-or-multiple-reader locks, IIRC
09:26:45 <Dybber> byorgey, ok
09:26:54 <quicksilver> apfelmus: in some sense, yes. The affect of two proceses concurrently modifying the same file is subject to the whims of the kernel scheduler
09:26:59 <Igloo> s/operations/functions/
09:27:17 <quicksilver> apfelmus: in practice however this is a very useful thing to be able to do, and processes choose whatever locking discipline suits them best
09:27:23 <byorgey> Dybber: it's possible that your own version doesn't overflow not because it is tail recursive per se, but because the compiler was able to figure out some optimization that it couldn't with maximum.
09:27:37 <byorgey> Dybber: tail recursion is much less important in a lazy language like Haskell.
09:27:47 <fasta> Can unsafeFreeze handle negative indices?
09:27:50 <Igloo> dons: Where is the hit counter?
09:27:56 <byorgey> Dybber: I'd point you to an excellent page discussing this and related issues on the wiki, but it appears to be very slow at the moment...
09:28:05 <apfelmus> quicksilver: ah. so, there is a separate mechanism for locking files? (i'm a unix n00b)
09:28:24 <dons> Igloo: when you're logged in, there's one at the bottom of each page (in my style, anyway), and on the special pages
09:28:30 <dons> click on 'popularity'
09:29:11 <Tac-Tics> byorgey: why is tail recursion less important?
09:29:20 <Dybber> byorgey, ok thanks, i dont really know how the lazyness is implemented, could be fun to look into.
09:29:43 * Igloo logs in, but finds no counter or popularity
09:30:22 <dons> Igloo: hmm, maybe its only in text mode browsers.. ?
09:30:24 <bringert> dons: would you have time to hack cabal-install to use your http module?
09:30:32 <apfelmus> quicksilver: i mean, i basically ponder the implementation of a wiki with flat files storage and want to get the concurrency right.
09:30:38 <Igloo> Ah, it's just not in the default skin
09:30:43 <dons> bringert: possibly, during this week
09:30:46 <dons> Igloo: ah yes
09:31:01 <dons> Igloo: http://haskell.org/haskellwiki/Special:Popularpages
09:31:02 <lambdabot> Title: Popular pages - HaskellWiki
09:31:28 <hpaste>  Mortez pasted "Help on resolving ambiguity.." at http://hpaste.org/3303
09:31:35 <Igloo> dons: Ah, is there a Popularinthelast24hours?
09:31:53 <bringert> dons: great. I'm using my minial spare time to work on various other parts, like installing local packages, install directories and verbosity
09:31:54 <Igloo> Or 1 hour, or anything?
09:32:09 <dons> bringert: yeah, verbosity is one thing.
09:32:24 <byorgey> Tac-Tics: for several reasons.  First of all, even with a tail-recursive function you can still get stack overflows due to too much laziness.
09:32:26 <dons> so i might look at the http stuff
09:32:39 <dons> Igloo: not that i know of, but maybe someone else is more familiar with mediawiki admin
09:32:50 <dons> Igloo: glguy might know, if he logs in soon
09:33:04 <Igloo> OK, ta
09:33:15 <Igloo> Anyway, I have http://www.haskell.org/static/Haskell.html ready if we have problems again
09:33:15 <lambdabot> Title: Haskell - HaskellWiki
09:33:20 <byorgey> Tac-Tics: and from the other angle, sometimes laziness creates opportunities for efficiency even in non-tail-recursive functions that would be inefficient in a strict language.
09:33:22 <bringert> dons: 'cabal install' can now install the package in the current dir btw, like your cbi
09:33:26 <quicksilver> apfelmus: if everything that accesses the file is using haskell, I believe you may be safe already
09:33:26 <dons> cool
09:33:32 <byorgey> Tac-Tics: although I can't think of an example off the top of my head.
09:33:45 <apfelmus> quicksilver: oh?
09:33:51 <ddarius> byorgey: concat
09:33:52 <bringert> dons: it doesn't install in /usr/local even with --global, but I'm fixing that now
09:33:59 <ddarius> byorgey: In fact any usage of foldr
09:34:14 <dons> bringert: ah right, but --user should use --prefix=$HOME by default?
09:34:22 <dons> (that's an faq on #xmonad)
09:34:54 <byorgey> ddarius: oh right, thanks
09:35:04 <bringert> dons: it uses $HOME/.cabal now
09:35:11 * ddarius wonders how dons got 'an'; 'an' eff ay que ?
09:35:11 <apfelmus> quicksilver: ah, "Implementations should enforce as far as possible, at least locally to the Haskell process, multiple-reader single-writer locking on files"
09:35:17 <byorgey> Dybber: here's the page I was referring to, I think you'll probably find it enlightening: http://www.haskell.org/haskellwiki/Stack_overflow
09:35:18 <lambdabot> Title: Stack overflow - HaskellWiki
09:35:31 <apfelmus> quicksilver: what about several Haskell processes?
09:35:47 <dons> bringert: right, cool.
09:36:09 <Choko_> is there some nice fast way of computing ``n! mod h'' ?
09:36:11 <Dybber> byorgey, thanks I will read that
09:36:29 <dons> ddarius: faq = "eff ae queue" :)
09:37:13 <Mortez> byorgey:  http://hpaste.org/3303  haskell just owns me :/
09:37:32 <quicksilver> apfelmus: then I suspect you should do your own locking
09:38:27 <apfelmus> yeah, i suppose. i don't know how, though, i know next to nothing about posix file operations
09:39:03 <quicksilver> I'd be inclined to have a single long-running haskell server
09:39:18 <quicksilver> and have the "CGI-scripts" access mediated via the single server
09:39:24 <quicksilver> using sockets, I suppose
09:39:35 <quicksilver> maybe that's more heavy-weight than you want :(
09:40:13 <apfelmus> i think so :(
09:40:43 <apfelmus> isn't there a posix function that somehow locks stuff?
09:41:35 <ibid> there's advisory locking and (optional) mandatory locking
09:41:36 <apfelmus> i mean, the ideal thing would be STM for the file system
09:41:52 <apfelmus> ibid: what's that?
09:41:54 * ddarius tends to pronounce it 'fack'
09:42:10 <ibid> in flock(2) and fcntl(2)
09:42:18 <ibid> apfelmus: what's which?
09:42:53 <ibid> fctntl F_GETLK F_SETLK and F_SETLKW are advisory locking
09:43:33 <ibid> ah, could also be mandatory locking if the kernel and the file system support it
09:43:34 <kolmodin> I'm a lambdabot and I'm ok, I hack all night and I surf all day!
09:44:09 <apfelmus> ibid: is there any online text/tutorial about that besides the man pages?
09:44:15 <dons> kolmodin: :)
09:44:22 <hpaste>  fasta pasted "Stack overflow minimal case" at http://hpaste.org/3304
09:44:24 <ibid> apfelmus: probably. use google :)
09:44:25 <quicksilver> a good book on unix systems programming would cover it
09:44:32 <ibid> but flock/fcntl locking isn't reliable if you have to support all read-world scenarios
09:44:44 <kolmodin> :)
09:44:48 <quicksilver> ibid: it's fine if you can assume that only your processses access it
09:44:50 <fasta> I create an array with about one million elements; any modern computer should be able to do that.
09:44:59 <kolmodin> dons: did my patch work for you on 64bits?
09:45:02 <quicksilver> ibid: or, you don't care too badly if some other process screws it up
09:45:09 <dons> kolmodin: getting to it. but seems like the right thing
09:45:15 <ibid> quicksilver: that's assuming the filesystem implements it
09:45:26 <kolmodin> aye. it's what Tim said, but his patch didn't apply any more
09:45:27 <ibid> quicksilver: some NFS filesystems, iirc, disregard it completely
09:45:42 <quicksilver> hmm that rings a bell
09:45:46 <kolmodin> ?localtime dons
09:45:46 <quicksilver> but I'm not sure you're right
09:45:48 <lambdabot> Local time for dons is Mon Oct 15 09:45:46 2007
09:45:51 <kolmodin> oo :)
09:45:56 <quicksilver> I think they disregard it w.r.t. other clients machines
09:46:08 <quicksilver> but for two clients on the same physical machine, it works?
09:46:30 <quicksilver> (that is, worst case. Good NFS servers get it right even in the hard case)
09:46:44 <ibid> quicksilver: possible
09:47:02 <ibid> quicksilver: as i said, if you have to support all real-world scenarios :)
09:48:30 <fasta> Why doesn't this work? http://hpaste.org/3304
09:48:37 <apfelmus> hm, now i'm scanning google results for an online unix systems tutorial ...
09:49:07 <apfelmus> but i just want STM for files. no brain damage, just atomic $ readFile a >>= writeFile b
09:50:21 <ibid> apfelmus: you want a transactional file system. there aren't any for unix, as far as i know
09:50:35 <ibid> apfelmus: unless you count database engines
09:50:41 <apfelmus> that would be fine if i could implement it myself
09:51:02 <apfelmus> i mean, the database engines have to do it in some way, too
09:51:26 <osfameron> would that be hard to implement efficiently?
09:51:54 <osfameron> I mean, would you end up storing a lot of swap files and so on with uncommitted changes?  The design must be quite interesting.
09:52:01 <apfelmus> i.e. i'm fine with a directory that only my Haskell code can read/write to
09:52:27 <astrolabe> fasta: which compiler?
09:52:31 <fasta> astrolabe: GHC
09:53:01 <astrolabe> fasta: My only guess is that you could increase the stacksize of the run time system.
09:53:14 <ibid> osfameron: basically, it's a journaling filesystem done with some care and with a transaction API attached
09:53:19 <apfelmus> osfameron: well, i hope i could get away with making STF an applicative functor instead of a full monad
09:53:32 <fasta> astrolabe: I don't understand why it would use a lot of stack in the first place.
09:54:14 <ibid> osfameron: the basic idea is that all data is written in an append-only journal, and you build (disposable) indexes to speed up access
09:54:21 <astrolabe> fasta: The default memory grabbed by the RTS is pretty small if I recall correctly.
09:54:30 <fasta> astrolabe: 16MB, IIRC
09:55:01 <osfameron> ibid: a bit like a piece table but done at the filesystem basis?
09:55:02 <bos> you can easily push that way down. i've run with an initial heap size of 256KB.
09:55:12 <ibid> osfameron: no idea what a piece table is
09:55:19 <fasta> bos: Why doesn't this work? http://hpaste.org/3304
09:55:31 <fasta> bos: that's the problem we are talking about
09:56:01 <astrolabe> fasta: Isn't that small?  How much room does a Maybe Int take?
09:56:14 <osfameron> ibid: it's a way of storing text for a text-editor or similar structure.  You keep a list of all the "pieces" of text, as indices against a) the original text buffer and b) an appendable buffer of "new" text (insertions/modifications or appends)
09:56:38 <ibid> osfameron: sounds similar
09:56:41 <fasta> astrolabe: I don't know exact numbers but it's less than 20 bytes, I think.
09:57:05 <fasta> astrolabe: but there's no need to have more than a constant number of elements on the stack
09:57:59 <ibid> osfameron: the log basically contains "inode 634 block 4200 was xyz now it is foo, changed by process quux" entries
09:58:33 <fasta> Maybe I can reimplement newArray
09:58:39 <ibid> osfameron: so it's an undo list, only it's authoritative
09:58:51 <osfameron> ibid: sounds interesting, I'll have to read up on it.
09:58:58 <osfameron> "authoritative" in what sense ?
10:00:22 <ibid> osfameron: think a text editor. you have the editor buffer and you have an undo list.  the authoritative version of the data is the edit buffer, and the undo list is just to support the undo feature. in a jornalling design, the editor buffer is just a cache, and the authoritative version of the data is what you can piece together by running through the journal (the undo list)
10:01:07 <osfameron> ah ok.  Very like a piece table/enfilade.
10:01:12 <ibid> osfameron: authoritative in the sense that if it's out of sync with your buffer, it's the buffer that gets thrown out and not the journal
10:01:34 <ibid> osfameron: enfilade, the xanadu concept?
10:01:35 <osfameron> ibid: I'll read up ta.  (Heading off now though... I shouldn't get involved in interesting things at end of day...)
10:01:41 <osfameron> see yas
10:01:44 <ibid> osfameron: i know that one :) and it's similar yes
10:02:06 <osfameron> ibid: yeah, enfilads rock (they're basically like the piece table but with a balanced tree managing the pieces, so more efficient)
10:02:22 <ibid> osfameron: i used to collaborate with ted :)
10:02:24 <osfameron> ibid: I keep on meaning to get time to write a text editor based on one (in Perl or Haskell)
10:02:37 <osfameron> ibid: really!  That must have been interesting
10:02:44 <hpaste>  byorgey annotated "Help on resolving ambiguity.." with "fixed" at http://hpaste.org/3303#a1
10:03:11 <ibid> osfameron: it was until ted lost patience with us geeks :)
10:03:23 <osfameron> ibid: I'm really interested in discussing enfilades some more at some point if you have time.
10:03:24 <byorgey> Mortez: ^^ that should work.
10:03:29 <ibid> osfameron: osfameron have a look at http://antti-juhani.kaijanaho.fi/ie/
10:03:31 <lambdabot> Title: Ibid's Editor
10:03:42 <osfameron> ibid: but right now I'd better go as I promised it's my turn to cook tonight :-)
10:03:56 <ibid> (no history support)
10:04:43 <osfameron> cool!  ((laters))
10:05:11 <Mortez> byorgey++
10:08:07 <dons> http://programming.reddit.com/info/5yc9f/details :)
10:08:08 <lambdabot> Title: programming: Testing your web applications with Haskell
10:09:19 <shapr> I like that binding.
10:12:44 <bos> fasta: i don't know why you're getting a stack overflow, sorry.
10:12:57 <fasta> bos: I think it depends on whether profiling is on or off.
10:13:08 <fasta> bos: I just tried it in ghci and there it works.
10:13:22 <fasta> bos: when I compile the example program without profiling it also works
10:13:28 <bos> fasta: so it works if profiling is off? huh.
10:14:00 <fasta> bos: yes, I verified it now
10:20:59 <MyCatSchemes> > liftM Char.toUpper "foo bar baz"
10:21:01 <lambdabot>  "FOO BAR BAZ"
10:21:08 <MyCatSchemes> :t liftM
10:21:09 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:21:11 <MyCatSchemes> :t map
10:21:13 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:21:24 <dmwit> :t liftM `asTypeOf` map
10:21:25 <lambdabot> forall a1 r. (a1 -> r) -> [a1] -> [r]
10:21:36 * MyCatSchemes brainexplode.
10:21:47 <MyCatSchemes> dmwit: where the Hell did you get asTypeOf from? That was awesome. :)
10:21:57 <dmwit> =)
10:22:09 <dmwit> It's a throwback to before type annotations, I gather. =)
10:22:27 <mrd> it's in haskell for dealing with things that lexical type variables would do
10:22:52 <MyCatSchemes> :t asTypeOf
10:22:52 <dmwit> asTypeOf is just a type-restricted const.
10:22:54 <lambdabot> forall a. a -> a -> a
10:23:20 <MyCatSchemes> @djinn a -> a -> a
10:23:20 <lambdabot> f _ a = a
10:23:54 <oerjan> @src asTypeOf
10:23:55 <lambdabot> asTypeOf = const
10:24:02 <oerjan> @src const
10:24:02 <lambdabot> const x _ = x
10:24:20 <MyCatSchemes> :t liftM `const` map
10:24:22 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:24:41 <MyCatSchemes> :t map `const` liftM
10:24:41 <dmwit> :t (const :: a -> a -> a) liftM map
10:24:43 <lambdabot> forall a1 r. (a1 -> r) -> [a1] -> [r]
10:24:44 <lambdabot>     Ambiguous type variable `m' in the constraint:
10:24:44 <lambdabot>       `Monad m' arising from use of `liftM' at <interactive>:1:12-16
10:25:07 <oerjan> MyCatSchemes: the last argument of const has no effect on the type of the result
10:25:26 <MyCatSchemes> oerjan: ah. Is the effect of asTypeOf a hack in the compiler, then?
10:25:31 <oerjan> asTypeOf has the same _value_ definition as const, but _not_ the same type
10:25:42 <oerjan> no, it simply has a type annotation
10:26:25 <fax> good afternoon
10:27:20 <MyCatSchemes> oerjan: ahhh, I see. Thank you.
10:27:26 <MyCatSchemes> fadec: good evening.
10:27:42 <fax> wow
10:27:50 <fax> very nice cats
10:27:52 <dmwit> fax: Also, good morning.
10:28:38 <dmwit> "boxed cat has a uniform representation"
10:28:40 <fax> oh geez "catmorphism"
10:28:42 <fax> lol
10:30:26 <dmwit> KittyT
10:30:47 <MyCatSchemes> "Tail recursion", heehee.
10:31:15 <dmwit> That one is so cute!
10:33:14 <birkenfeld> http://pocoo.org/~gbrandl/monomorph.png :)
10:33:51 <liyang2> Oh man. Are we still on the \cats? @_@
10:39:54 <liyang2> I'm getting all the jokes apart from `The impossible'. Halp?
10:40:23 <Beelsebob> it's getting out the box
10:40:28 <dmwit> It looks like the cat's leg is way way long.
10:40:35 <dmwit> ...impossibly long.
10:40:42 <oerjan> it's a ghc error message for compiler bugs, i think
10:40:59 <dmwit> liyang2: And one of GHC's famous error messages is "The impossible has happened!  Report it." or something like that.
10:41:06 <Beelsebob> heh
10:41:10 <liyang2> oerjan: I know that much. ^^;
10:41:26 <Beelsebob> my personal favorite has to be lazy bitestring
10:41:30 <oerjan> liyang2: wasn't sure which part you were not getting :)
10:41:33 <liyang2> Beelsebob: guess that makes some sort of sense for me. ^^;
10:42:06 <liyang2> maybe it just failed to tickle me on the right parts. ^^;
10:42:17 <Beelsebob> someone needs to do an amerous cat, with some comment about playing with IO and my monads
10:42:43 * liyang2 likes olegcat
10:42:56 <Beelsebob> it's too much of an in joke
10:43:22 <oerjan> they all are
10:43:25 <liyang2> Don't kid yourself. The whole site is too much of an in-joke. :p
10:43:37 <Beelsebob> yeh... but that one is *too much* of an in joke
10:43:44 <Beelsebob> it requires knowledge of the community
10:43:47 <Beelsebob> not just the languag
10:43:47 * liyang2 loevs KittehT more
10:43:50 <Beelsebob> language*
10:43:59 <Beelsebob> yeh, the kittehT rocks
10:44:02 <liyang2> And my. simoncat's looking cool.
10:44:36 <fax> hehehe
10:44:41 <liyang2> Beelsebob: and the compiler, let's not forget. :)
10:44:48 <Beelsebob> that too
10:45:22 <liyang2> Hang on, did I just say *the* compiler? I didn't mean that. There are other Haskell compilers...
10:45:27 <liyang2> (Right guys?)
10:48:21 <Spark> there are no haskell compilers
10:48:49 <HodriUser-381> selam
10:49:16 <dmwit> Hi asd!
10:49:59 <dolio> There is no spoon.
10:50:25 <dmwit> There is no red pill.
10:50:47 <oerjan> Ceci n'est pas un pipe.
10:51:08 <oerjan> *une
10:52:21 <mrd> someone wrote that on a steam pipe in a building here
10:52:23 <mrd> =)
10:52:46 <dmwit> "There is no pipe"?
10:52:57 <dmwit> ?babel fr en ceci n'est pas un pipe
10:52:59 <lambdabot>   this is not a pipe
10:53:07 <Spark> lol, pipe is feminine
10:53:17 <mrd> ?google magritte ceci n'est pas une pipe
10:53:19 <lambdabot> http://en.wikipedia.org/wiki/The_Treachery_of_Images
10:53:19 <lambdabot> Title: The Treachery Of Images - Wikipedia, the free encyclopedia
10:53:58 <Spark> i saw that referred in some pixel pushing art once
10:54:08 <Spark> ceci n'est pas une pixele
10:54:12 <Spark> or something like that
10:54:36 <liyang2> This is not my fist on your FACE.
10:54:39 <Spark> because it had a pixel under a magnifying glass, and it was a rabbit or something
10:56:10 <liyang2> Spark: how's London? :-/
10:58:42 <Spark> i'm living in the 4th least pleasant place to live in the UK
11:01:22 <ivant> yay, we had our first official Haskell User Group meeting in St.Petersburg on Saturday!
11:01:45 <bos> excellent!
11:01:56 <Spark> did you have a group hug
11:01:58 <ivant> 26 people were there!
11:02:15 <ivant> oh, we forgot about a group hug :-)
11:02:16 <bos> nice.
11:03:31 <ivant> if somebody ever decide to come to St.Petersburg, be sure to prepare a talk for our HUG :-)
11:05:39 <pierre-> ivant: yeah, spbhug was really great
11:07:35 <byorgey> @seen shapr
11:07:36 <lambdabot> shapr is in #scannedinavian, #xmonad, #haskell-blah and #haskell. I last heard shapr speak 58m 16s ago.
11:08:08 <byorgey> shapr: so AmeroHaskell might be in the northwest instead of southeast now?
11:08:18 <shapr> yup
11:08:32 <mrd> catty corner
11:08:48 <shapr> Portland seems like the easiest place to get a venue, and where the most potential attendees are already located.
11:09:06 * mrd is in another corner
11:09:24 <byorgey> shapr: yeah, that makes sense.  it's a bit farther away for me of course, but I'll see if I can still come, depending on when it is and whether I can get cheap plane tickets
11:11:53 <shapr> cool
11:15:32 <bos> portland would be perfect. where's the wiki page again?
11:15:34 <byorgey> I'm actually planning to apply to PSU, so 'twould be a good chance to visit, especially if it happens before December.  dunno how likely that is though.
11:16:01 <byorgey> @wiki AmeroHaskel
11:16:01 <lambdabot> http://www.haskell.org/haskellwiki/AmeroHaskel
11:16:07 <byorgey> erm, but spelled correctly =P
11:20:04 <MyCatSchemes> @seen Zeppelin
11:20:05 <lambdabot> I haven't seen Zeppelin.
11:20:09 <MyCatSchemes> @seen Jesus
11:20:10 <lambdabot> I haven't seen Jesus.
11:20:21 <MyCatSchemes> @seen The_Invisible_Pink_Unicorn
11:20:21 <lambdabot> I haven't seen The_Invisible_Pink_Unicorn.
11:20:23 <Baughn> @seen me
11:20:23 <lambdabot> me has changed nick to olsner.
11:20:23 <lambdabot> I saw olsner leaving #haskell 1d 7h 55m 6s ago, and .
11:20:37 <Baughn> MyCatSchemes: Also, it's an invisible pink dragon. Get it right.
11:21:04 <MyCatSchemes> @seen my_toes_in_fourty_years._So_now_I_go_to_weightwatchers.
11:21:04 <lambdabot> I haven't seen my_toes_in_fourty_years._So_now_I_go_to_weightwatchers..
11:21:21 <Baughn> @seen lambdabot
11:21:22 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #
11:21:22 <lambdabot> ghc and #darcs
11:21:56 <MyCatSchemes> Baughn: wikipedia disagrees.
11:22:35 <MyCatSchemes> Hell, even Google's keyword completion in Firefox immediately comes up with "unicorn" whenever I type "invisible pink"
11:22:53 <Baughn> I was wondering what was up with those search words
11:23:07 <Baughn> Google, you say. Fun.
11:23:19 <fax> lambdabot can unicycle too?
11:23:32 <Baughn> lambdabot, can you unicycle?
11:23:38 <oerjan> @unicycle
11:23:39 <lambdabot> Unknown command, try @list
11:23:50 <Baughn> Guess not. She's too embarrassed to answer.
11:26:05 <roconnor> @vixen can you unicycle?
11:26:06 <lambdabot> i sure can
11:26:28 <Baughn> @seen dons
11:26:28 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 8m 44s ago.
11:44:32 <shapr> Is there a headless X server? Something that can run without display hardware?
11:44:46 <shapr> I want to run automated tests with the recent selenium binding from Galois on a machine without a display.
11:45:14 <dons> shapr: hmm, i think it needs a real browser running javascript
11:45:25 <dons> i'm unaware of a way to run it 'offline' as such
11:45:41 <kaol> like xserver-xorg-video-dummy? (on Debian, at least)
11:46:03 <liyang2> shapr: a VNC server?
11:46:18 <ToxicFrog> shapr: NX? You'll need a remote system with an X terminal to get it started, though.
11:46:37 <dmwit> liyang2: And how would you control the VNC server, without a display?
11:47:00 <ToxicFrog> ...hmm.
11:47:01 <liyang2> dmwit: same question goes to the original request. :)
11:47:07 <liyang2> (XTEST?)
11:47:30 <dmwit> liyang2: You can surely get remote connection that has no X in it to control the server, but that doesn't help control VNC.
11:47:33 <shapr> Selenium starts up the browser by itself.
11:47:43 <ToxicFrog> I have pmap :: Double -> (a -> a) -> [a] -> State b [a]
11:48:20 <liyang2> well, some early VNC servers manifest themselves as X11 servers that don't require display hardware. That's all I know.
11:48:31 <ToxicFrog> I have mutate_one :: Solution -> Solution, where Solution = [Int], and it calls pmap..
11:48:38 <shapr> liyang2: That's an idea, thanks.
11:48:47 <ToxicFrog> It needs to become Solution -> State b Solution, yes?
11:48:50 <shapr> kaol: -dummy sounds good, I can try that locally.
11:49:22 <byorgey> ToxicFrog: not necessarily.  There are functions like runState, execState, and evalState that let you extract things from the State monad.
11:49:33 <byorgey> ToxicFrog: it depends what you want.
11:49:56 <oerjan> ToxicFrog: is the b really polymorphic?  in which case i don't see how pmap could use the state at all?
11:50:01 <ToxicFrog> Hrm
11:51:24 * ToxicFrog tries to figure out how to explain this
11:51:47 <ivant> shapr, AFAIR, there is a thing called x virtual framebuffer server
11:51:54 <ToxicFrog> I have this function, mutate, which takes a Solution and creates a new Solution out of it; data Solution = Solution [Int]
11:52:04 <ToxicFrog> So, ideally, the definition is
11:52:35 <ToxicFrog> mutate (Solution s) = Solution (pmap 0.5 (+1) s)
11:52:50 * roconnor gets a version of iowidget to typecheck
11:52:57 <oerjan> ToxicFrog: what is the _actual_ type of pmap?
11:53:01 <roconnor> Now to attempt to create my first widget!
11:53:02 <ToxicFrog> However, pmap doesn't return an [a], it returns a State [Double] [a], because internally it needs state
11:53:11 <oerjan> ok
11:53:19 <oerjan> so b = [Double]
11:53:37 <ToxicFrog> pmap :: forall a. Double -> (a -> a) -> [a] -> State [Double] [a]
11:54:02 <byorgey> @type execState
11:54:03 <ToxicFrog> Yes, sorry
11:54:04 <lambdabot> forall s a. State s a -> s -> s
11:54:10 <byorgey> @type evalState
11:54:12 <lambdabot> forall s a. State s a -> s -> a
11:54:35 <oerjan> seems like you want evalState
11:55:02 <byorgey> ToxicFrog: I think you want mutate (Solution s) = Solution (evalState (pmap 0.5 (+1) s) ??)
11:55:10 <byorgey> where the ?? is whatever the appropriate initial state is
11:55:40 <roconnor> what is the basic Gtk2hs widget for a simple text entry box?
11:55:53 <ToxicFrog> The initial state comes from the attached State monad via get, I think
11:55:54 <dcoutts_> roconnor: Entry
11:56:26 <ToxicFrog> Basically, mutate needs to be in State, and I'm having trouble with the interaction between State and user-defined types
11:56:40 <roconnor> thx
11:57:02 <oerjan> ToxicFrog: every state monad needs to get its initial state on "startup"
11:57:26 <ToxicFrog> oerjan: the original initial state is created and passed in by main
11:57:43 <oerjan> oh, so there is a global State monad?
11:57:48 <ToxicFrog> From there, it gets carried around until more_randoms way at the bottom of the call graph needs it.
11:58:18 <ToxicFrog> Which I had working back when I was just using [[Int]]
11:58:25 <ToxicFrog> Rather than [Solution]
11:58:36 <ToxicFrog> The problem I'm running into is that I can'
11:58:38 <shapr> ivant: xvfb looks like exactly what I need, thanks!
11:58:46 <oerjan> in that case you probably cannot escape State that easily
11:58:54 <ToxicFrog> I'm not trying to escape it!
11:59:09 <ToxicFrog> The issue is that I want to return a State [Double] Solution
11:59:34 <ToxicFrog>  But I can't see how to turn a State [Double] [Int] into a State [Double] (Solution [Int])
11:59:44 <oerjan> liftM Solution
11:59:56 <ToxicFrog> @type liftM
11:59:58 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:01:27 <roconnor> dcoutts_: Is it possible to invoke the onEditableChanged callback by hand?  I don't see a function for that.
12:01:44 <ToxicFrog> Erm. I don't have a monad going in, only coming out.
12:02:01 <ToxicFrog> And the signature isn't (a->b), it's (a->m a)
12:02:03 <oerjan> but pmap is in the monad
12:02:06 <dcoutts_> roconnor: not sure, lemme look. In general you can't poke all callbacks, since many of them have extra arguments
12:02:18 <ToxicFrog> Yes. That's the problem. I give it a list, I get a monad list out.
12:02:27 <byorgey> i.e. mutate (Solution s) = liftM Solution $ pmap 0.5 (+1) s
12:02:38 <ToxicFrog> ...oh, right
12:02:58 <roconnor> dcoutts_: If I change an attribute by hand, will the callback be called?
12:03:08 <ToxicFrog> ...right, right! Solution has type [Int] -> Solution
12:03:12 <ToxicFrog> Didn't realize that
12:03:12 <roconnor> dcoutts_: change an attribute with set
12:03:13 <ToxicFrog> Thank you
12:03:33 <dcoutts_> roconnor: sure, if you modify the content of the Entry then the changed signal will fire
12:03:57 <dcoutts_> roconnor: you have to go to greater lengths to get the opposite behaviour, to modify without getting the signal
12:04:55 <roconnor> so I should set the callback and then set the inital value to have the callback called on initialization?
12:05:15 <roconnor> I think I can do that
12:06:54 <Saul_> Hey guys
12:07:09 <Saul_> I have a bit of a problem (not really, more of a mental exercise)
12:07:26 <dmwit> Hi Saul_!
12:07:36 <dmwit> We all love mental exercise.
12:07:54 <Saul_> I have a problem that is defined using snoc lists, but I want to rewrite it to a definition using cons lists
12:08:06 <Saul_> the list itself shouldn't be reversed though
12:08:14 <Saul_> and it should be proven correct
12:08:48 <Saul_> the function I have is:
12:08:52 <Saul_> f [] = 0
12:09:13 <Saul_> f (s <| b) = 10 * f s + b
12:09:52 <Saul_> dmwit: Hi
12:10:54 <oerjan> Saul_: sounds like you essentially want to change a foldr (on snocs) to a foldl (on conses)
12:11:48 <oerjan> (well, a foldl on snocs, which has the same structure as a foldr on conses)
12:11:59 <Saul_> oerjan: I guess (aren't foldrs on cons though, and foldls on snoc)?
12:12:56 <oerjan> you can have foldls and foldrs on both, but mirrored
12:13:22 <Saul_> I see
12:13:37 <Saul_> But that is way too generic, I just need it in this specific case
12:13:44 <oerjan> so the way to write each for a snoc is to write the opposite for a cons
12:14:03 <Saul_> the function basically turns [1, 2, 3, 4] into 1234
12:14:08 <oerjan> well you need to use the same structure
12:15:11 <roconnor> dcoutts_: It kinda works!!!!
12:15:23 <oerjan> actually you need to generalize slightly, because a foldl on (cons) lists requires passing the accumulating argument
12:15:23 <dcoutts_> roconnor: only kinda?
12:15:40 <roconnor> dcoutts_: well, it didn't quite initialize properly
12:15:49 <roconnor> but once it got going to worked
12:15:55 <dcoutts_> ok
12:15:58 <roconnor> I build an echo dialog
12:16:07 <roconnor> using two entry boxes
12:16:15 <Saul_> Well I already have a accumulating function that calculates the same as f already, but I need to derive one from the definition of f
12:16:28 <roconnor> using Phooey with a Gtk2hs backend!
12:16:41 <dcoutts_> roconnor: oh, cool!
12:17:16 <dcoutts_> roconnor: so to do all that nicer you want a way to get a signal for a specific attribute
12:17:27 <dcoutts_> roconnor: which is possible in Gtk+, but we've not bound it yet
12:17:33 <dcoutts_> and I should look into doing so
12:17:34 <roconnor> dcoutts_: ah yes
12:17:39 <roconnor> that would be much better
12:17:46 <Saul_> @src foldl
12:17:46 <lambdabot> foldl f z xs = lgo z xs
12:17:46 <lambdabot>     where lgo z []     =  z
12:17:46 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
12:17:51 <Saul_> @src foldr
12:17:52 <lambdabot> foldr k z xs = go xs
12:17:52 <lambdabot>     where go []     = z
12:17:52 <lambdabot>           go (y:ys) = y `k` go ys
12:18:23 <dcoutts_> roconnor: something like: on widget (attrChanged attr) $ do ...
12:18:35 <oerjan> as you see, go is the function you already have essentially
12:19:18 <oerjan> so you probably want the corresponding lgo
12:19:21 <Saul_> I basically also have lgo as well
12:19:58 <roconnor> dcoutts_: that would look more like the existing wxHaskell code
12:20:14 <dcoutts_> roconnor: what api does it use?
12:20:15 <Saul_> I really don't have much of a problem with writing accumulating functions and stuff, but the exercise is to derive one from the other
12:21:22 <Saul_> I have g a [] = a
12:21:40 <Saul_> and g a (x:xs) = g (10 * a + x) xs
12:21:48 <oerjan> yeah
12:21:50 <Saul_> g 1 = f
12:21:58 <dcoutts_> roconnor: or rather, what would you write in wx to get the same effect ?
12:22:40 <Saul_> I even derived a weird accumulating version of f, but it still works with snoc lists
12:22:43 <Beelsebob> Saul_: use fold
12:22:58 <oerjan> i am not sure, but maybe one could view it has a kind of CPS transformation?
12:23:02 <oerjan> *as
12:23:13 <Saul_> g x y [] = y
12:23:37 <roconnor> dcoutts_: I'm not certain.  I don't fully appreciate what the wxHaskell code I'm replacing does.
12:23:41 <Saul_> g x y (s <| b) = g (x * 10) (x * b + y) s
12:23:47 <Saul_> g 1 0 = f
12:23:49 <dcoutts_> roconnor: ok :-)
12:23:51 <Saul_> CPS?
12:23:59 <roconnor> dcoutts_: but there is a fair amount of use of `on`
12:24:08 <roconnor> which I've replaced
12:24:23 <Saul_> Beelsebob: I would first have to derive fold, so that would probably make it more work
12:24:33 <Saul_> oerjan: CPS?
12:24:35 <dcoutts_> robreim: I think their 'on' means turn a signal into a function valued attribute
12:24:38 <dcoutts_> oops
12:24:43 <dcoutts_> roconnor: ^^
12:24:49 <oerjan> continuation passing style
12:24:57 <roconnor> dcoutts_: right, I have no idea at this point
12:25:01 <Saul_> ah ok
12:26:20 <Saul_> I don't really have a lot of experience with that, and I would also have to prove it correct first
12:27:50 <oerjan> do you have a proven function for converting between snoc and cons lists?  perhaps you could compose it with that, and somehow unravel the result
12:28:32 <Saul_> Nope, that's the problem
12:28:47 <fox86> anyone know how to completely turn off indentation when using haskell-mode in emacs? (remove-hook 'haskell-mode-hook 'turn-on-haskell-indent) does disable some of the fancier stuff, but not everything. i would like "return" to just make a newline without indenting at all and then rather tab my way to where i want to be. maybe this is a question for #emacs, but they don't seem to use haskell-mode
12:29:06 <Saul_> I do have some calculation rules, but they aren't much help
12:29:32 <oerjan> maybe make that first, as otherwise it would seem hard to even define what it means for your original exercise to be correct...
12:30:23 <Saul_> Yeah I've tried some things, but no luck so far :(
12:30:37 <oerjan> although when i think about it, such a conversion function would essentially also be a foldl...
12:31:34 <dons> http://programming.reddit.com/info/5yciu/details
12:31:35 <lambdabot> Title: programming: Ask Reddit: How do I get a job hacking Haskell all day?
12:31:39 <dons> anyone else have suggestions?
12:32:16 <oerjan> calculation rules?  like a : (b <| c) = (a : b) <| c ?
12:32:34 <Lemmih> @seen dcoutts_
12:32:34 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 7m 50s ago.
12:32:41 <dcoutts_> hia Lemmih
12:32:45 <Saul_> Yeah like those (although that particular one is missing)
12:33:06 <araujo> dons, starting your own startup
12:33:09 <oerjan> actually i guess <| could be defined as a haskell function (not to be pattern matched on, though)
12:33:21 <roconnor> dcoutts_: Hmm, I guess when the text attribue on an entry is set, the onEntryActivate callback isn't fired?
12:33:22 <beschmi> fox86: what function gets called by "return"? C-h k RET
12:33:51 <dcoutts_> roconnor: the activate is what happens when you press enter in the Entry box
12:34:16 <Saul_> well the calculation rule you suggested in reverse would be a proper definition
12:34:18 <ivant> oh, I wish one day I could get a job hacking Haskell
12:34:30 <roconnor> dcoutts_: I think I will have to fire that initally by hand
12:34:37 <eyeris> How can I make ghc infer Float from `Int / (Int + Int)`? (the Int is being returned by `length :: [a] -> Int`)
12:34:40 <fox86> beschmi:" RET runs the command newline-and-indent-relative"
12:34:42 <oerjan> right
12:34:42 <Saul_> combined with [] <| b = b : []
12:35:34 <oerjan> eyeris: use fromIntegral or genericLength
12:35:51 <dcoutts_> roconnor: I don't think I understand, that signal does not correspond to any property of the widget, it's more like the signal you get when someone presses a button widget
12:35:54 <Lemmih> dcoutts_: I've been told that SOE/Gtk once had problems on Windows. HsSDL is now in the same situation. Do you have any wise words or hints?
12:36:11 <dcoutts_> Lemmih: what kind of problems?
12:36:13 <Saul_> I've tried using those, but then I got stuck
12:36:21 <eyeris> oerjan thanks
12:36:29 <dcoutts_> Lemmih: most of our problems were to do with making it easy for windows users to install
12:37:04 <dcoutts_> Lemmih: so you could make an installer, the hint there is InnoSetup, it's what gtk2hs and ghc-6.8 use
12:37:25 <roconnor> dcoutts_: yeah, I want to initalize the edit box with a string, and then notify the event handler, as if the enter key was pressed.  Seems like a reasonable initalization routine to me.
12:37:38 <beschmi> fox86, runs command newline here in haskell-mode
12:38:53 <dcoutts_> roconnor: hmm, so is the behaviour that you want, that the values calculated based on the entry's text should only update when the user presses enter in the box ?
12:39:43 <roconnor> dcoutts_: I think so.  I think updating as they type would be really annoying in most cases.
12:40:23 <roconnor> ... I should test to see what the wxHaskell version did
12:40:28 <dcoutts_> roconnor: you should ask conal how he manages that kind of update policy
12:40:58 <roconnor> I should, but I think he was able to always fire any event handler.
12:43:19 <dcoutts_> roconnor: of course you can always run the event handler directly if you were the one who connected it
12:45:50 <dons> augustss with his hackathon tshirt :) http://catenova.org/~lemmih/ICFP07/images/pa040054.jpg
12:49:17 <earthy> nice shirt, btw. I like the axe in the lambda.
12:49:31 <earthy> (mrchebas had his on today)
12:51:42 <Saul_> Argh, I give up
12:51:53 <Saul_> oerjan: Thanks for your help
12:53:07 <dons> earthy: cool :)
13:09:34 <eyeris> I'm trying to use the Text.CSV package. I import Text.CSV and Text.ParserCombinators.Parsec but ghci still tells me that both CSV and ParseError are not in scope.
13:09:49 <dons> how do you import them?
13:09:59 <dons> and did you touch your .hs file, so ghci can see non-exported symbols?
13:10:49 <eyeris> I import them at the top of my .hs with "import Text.CSV"
13:11:45 <eyeris> I'm not sure what you mean by touching the .hs file. I can touch it with the unix command touch, but that doesn't change anything
13:12:13 <sjanssen> eyeris: how did you install Text.CSV?
13:14:00 <eyeris> runghc Setup.hs build/install or something like that -- from the instructions
13:14:25 <eyeris> I might just be using it wrong. Here is my code (on hpaste)
13:14:41 <hpaste>  eyeris pasted "csverror" at http://hpaste.org/3310
13:15:27 <sjanssen> eyeris: yes, you're doing it wrong :P
13:15:31 <eyeris> figures
13:16:24 <hpaste>  sjanssen annotated "csverror" with "parseCSVFromFile returns Either ParseError CSV" at http://hpaste.org/3310#a1
13:17:11 <eyeris> Ok, so I misunderstood now Either works... trying to use it more like Maybe?
13:17:31 <oerjan> Maybe doesn't work like that either :D
13:18:23 <oerjan> you need Just and Nothing like you need Left and Right
13:18:29 <eyeris> ok yeah
13:19:22 <eyeris> yay! it works!
13:25:41 <n00b> how do i write a recursicve function to sum all the elements in  list
13:25:55 <dons> > sum [1..10]
13:25:57 <lambdabot>  55
13:25:58 <dons> ?src sum
13:25:58 <lambdabot> sum = foldl (+) 0
13:26:01 <dons> ?src foldl
13:26:04 <lambdabot> foldl f z xs = lgo z xs
13:26:04 <lambdabot>     where lgo z []     =  z
13:26:04 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:26:06 <dons> :)
13:26:15 <oerjan> ?src foldl'
13:26:16 <lambdabot> foldl' f a []     = a
13:26:16 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:26:21 <byorgey> a bit over-general for that specific problem, perhaps, but...
13:26:23 <dons> well, that's over the top.
13:26:34 <wli> mySum [] = 0 ; mySum (x:xs) = x + mySum xs
13:26:36 <dons> n00b: what have you got so far?
13:28:24 <n00b> i am gonna hpaste it
13:30:49 <hpaste>  n00b pasted "sumAll" at http://hpaste.org/3311
13:31:19 <dmwit> n00b: That looks fine.
13:31:25 <dmwit> Are you having a problem with it?
13:31:41 <n00b> kinda learning list
13:31:52 <n00b> I wrote based on you guys replies
13:31:59 <dmwit> aha
13:33:41 <n00b> <dmwit> ???
13:35:46 <n00b> how do I write a rursive definition for div in haskell ?
13:36:14 <Heffalump> how efficient do you want?
13:36:28 <Heffalump> ls
13:36:31 <Heffalump> sorry
13:36:42 <wli> I think he can take dogslow.
13:36:44 * mrd lists Heffalump's directories
13:36:48 <dmwit> n00b: Do you mean, how do you divide each element of a list by a certain number, or do you really want to define div?
13:36:54 <n00b> Implement the following operators (over the natural numbers i.e. positive integers) using recursive definitions: (a) * (multiplication) (b) div (division) (c) mod (modulus)
13:37:10 <Heffalump> well, I suggest you consider two possible cases.
13:37:21 <Heffalump> Either (a) the answer is 0 or (b) the answer is not 0.
13:51:07 <hpaste>  (anonymous) pasted "numDigits" at http://hpaste.org/3312
13:51:47 <n00b> i am writing a recursive function to count the number of digits in a numbers
13:52:00 <n00b> help pleas !!!!
13:52:34 <oerjan> n00b: you might try div'ing by 10
13:53:24 <byorgey> n00b: the first case looks good.  In the other case, you know it has at least one digit, plus some more.  How will you use numDigits to count the rest?
13:55:21 <n00b> could i break down the number each time by using
13:55:24 <n00b> mod
13:55:25 <n00b> ??
13:55:32 <oerjan> n00b: div, i said :)
13:55:41 <n00b> ok
13:55:48 <byorgey> if you mod by 10 you'll get the last digit of the number.
13:55:56 <byorgey> if you div by 10 you'll get everything BUT the last digit.
13:56:41 <abell> Does it have to be recursive?
13:56:47 <n00b> let a = 14 `div` 10 in if a <= 9 = 1 else a+1
13:56:55 <n00b> >let a = 14 `div` 10 in if a <= 9 = 1 else a+1
13:56:58 <n00b> yes
13:57:03 <n00b> > let a = 14 `div` 10 in if a <= 9 = 1 else a+1
13:57:03 <lambdabot>  Parse error
13:57:07 <TomMD> > do Nothing
13:57:09 <lambdabot>  Nothing
13:58:01 <oerjan> n00b: then not =
13:59:16 <byorgey> n00b: that's closer, but it's still not recursive.  and also, you need 'if a <= 9 then 1' instead of '... = 1', as oerjan mentioned.
13:59:33 <n00b> i tried it and I keep getting a stack overflow
14:00:01 <n00b> otherwise = numDigits a `div` 10
14:00:22 <oerjan> n00b: you need parentheses
14:01:05 <oerjan> function application binds tighter than operators
14:01:25 <n00b> answer always 1
14:01:42 <hpaste>  n00b pasted "numDigits" at http://hpaste.org/3313
14:02:10 <byorgey> think about what that says.  "otherwise = numDigits (a `div` 10)" means that if a >= 10, a has the same number of digits as a/10.  is that true?
14:03:11 <n00b> don't understand
14:03:38 <byorgey> ok, let's try an example.
14:03:41 <byorgey> suppose a = 587.
14:03:42 <oerjan> n00b: what is numDigits (14 `div` 10)?
14:04:11 <byorgey> how would evaluation of numDigits 587 proceed?
14:04:14 <oerjan> (that is, what should it be?)
14:07:51 <n00b> don't understand
14:08:07 <n00b> i get the last digit, but what should it do ??
14:08:31 <Botje> n00b: numDigits "15" = 1 + numDigits "5" = 2
14:08:41 <n00b> ok
14:08:49 <Botje> n00b: your code does numDigits "15" = numDigits "5" = 1
14:08:56 <Botje> do you spot what's missing?
14:08:57 <n00b> so one is added to the previous
14:09:58 <shapr> I'm trying to start a Haskell program in a subshell with ( program ) & but I always get "Main: <stdin>: hGetChar: end of file" any idea why?
14:10:12 <shapr> I tried piping some random text to the program, but I still get the same error.
14:10:29 <shachaf> shapr: Does it work otherwise?
14:10:47 <wli> botched SIGTTIN handling?
14:10:55 <bos> shapr: probably because it's doing non-blocking IO on stdin
14:11:28 <shapr> shachaf: Yes, the program works if stdin is available.
14:11:49 <bringert> dcoutts: thanks for pushing those patches to cabal-1.2
14:12:37 <n00b> getting a stack overflow
14:13:17 <hpaste>  n00b pasted "(no title)" at http://hpaste.org/3314
14:13:27 <n00b> check that
14:14:58 <omnId> numDigits 12 = (1 + numDigits 12) `div` 10 = (1 + numDigits ((1 + numDigits 12) `div` 10))) `div` 10
14:15:18 <byorgey> n00b: your parentheses aren't in the right place.  see if you can figure out why.
14:15:37 <omnId> when you call numDigits recursively, it needs to take a smaller case or it'll just keep calling it forever.
14:16:03 <n00b> ???
14:16:04 <byorgey> n00b: a very good exercise in this sort of situation is to see if you can "simulate" the code on a particular example by hand, to see if you understand what is happening.
14:16:49 <omnId> n00b: in the example I showed, you need to `div` the 12 by 10 before passing it to numDigits
14:18:42 <eyeris> !! is linear time, right?
14:18:48 <byorgey> eyeris: yup.
14:18:50 <mauke> what's a good algorithm for computing all digits of sqrt 2?
14:19:10 <eyeris> So is there a more efficient way of writing something like this:
14:19:16 <eyeris> let as = "abcdefg"; [ as !! x | x <- [1,4,6] ]
14:19:24 <byorgey> mauke: by "good" do you mean "simple", "efficient", or what?
14:19:51 <mauke> byorgey: fast
14:20:07 <mauke> I need to generate more than 100000 digits in less than 20 seconds :-)
14:20:22 <oerjan> eyeris: we discussed that the other day
14:20:44 <eyeris> oerjan you and I did? Is there a #haskell log somewhere?
14:21:01 <mauke> @where logs
14:21:01 <oerjan> i don't remember if you were involved :)
14:21:01 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
14:21:42 <Olathe> @pl \x f -> f x
14:21:42 <lambdabot> flip id
14:21:59 <byorgey> mauke: maybe something on here will help? http://numbers.computation.free.fr/Constants/constants.html
14:22:00 <lambdabot> Title: Mathematical Constants and computation
14:22:10 <Olathe> > (flip id) 3 (+1)
14:22:12 <lambdabot>  4
14:22:13 <mauke> ah, thanks
14:22:18 <hpaste>  omnId annotated "(no title)" with "n00b:" at http://hpaste.org/3314#a1
14:22:45 <oerjan> i think i did something with scanl drop...
14:23:09 <byorgey> mauke: I know simple ways to compute sqrt 2 to arbitrary precision, but not fast =)
14:23:12 <omnId> Olathe: s/id/($)/ is you want it to be a little clearer
14:23:15 <Olathe> > flip id 3 (+1)
14:23:16 <lambdabot>  4
14:23:18 <omnId> if*
14:23:38 <Olathe> > 3 id (+1)
14:23:38 <lambdabot>        add an instance declaration for
14:23:39 <lambdabot>       (Num ((a -> a) -> (a1 -> a1) -> ...
14:23:51 <omnId> > 3 `id` (+1)
14:23:51 <lambdabot>        add an instance declaration for (Num ((a -> a) -> a1))
14:23:58 <omnId> erm, oops
14:24:02 <Olathe> > (+1) (id 3)
14:24:03 <lambdabot>  4
14:24:06 <omnId> > (+1) `id` 3
14:24:07 <lambdabot>  4
14:24:09 <mauke> byorgey: my current approach is iterate (\x -> x / 2 + recip x)
14:24:20 <mauke> byorgey: with unfoldr (\a -> let (d, r) = a `divMod` b in Just (toEnum (fromInteger d + 48), r * 10)) to generate the digits
14:24:34 <omnId> ($) f x vs. flip ($) x f
14:25:43 <byorgey> mauke: right, I'd guess that's probably not very fast =)
14:26:18 <oerjan> > map head . tail . scanl (flip drop) "abcdefg" . ap (zipWith (-)) (0:) $ [1,4,6]
14:26:20 <lambdabot>  "beg"
14:26:20 <mauke> fast enough to get 100343 digits in 16 iterations
14:26:46 <byorgey> > 2^16
14:26:47 <lambdabot>  65536
14:26:52 <byorgey> > 2^17
14:26:53 <lambdabot>  131072
14:26:56 <byorgey> yup =)
14:27:29 <Olathe> @pl \fs -> (\x -> map (\f -> f x) fs)
14:27:30 <lambdabot> flip (map . flip id)
14:27:35 <byorgey> it's the memory management and printing that take a long time.
14:28:58 <byorgey> I wonder if there's a way to generate it stream-style.  with your method it has to calculate the entire rational value in memory before printing anything out.
14:29:37 <wli> The long division analogue for square roots.
14:29:40 <mauke> the first iterations seem to take almost no time
14:29:51 <mauke> but the last few rounds are really expensive
14:30:31 <mauke> crap. lifting the first 14 iterations to compile time doesn't help.
14:31:01 <Olathe> Usually, you have map f xs. What's a good name for q in q fs x ?
14:31:07 <byorgey> wli: ah, right.  I wonder if that would be faster?
14:31:15 <mauke> Olathe: sequence?
14:31:29 <quicksilver> KatieHuber: around? or any other openGL experts?
14:31:54 <omnId> map ($ x) fs works too
14:32:09 <Olathe> Right, but this is for Mathematica naming.
14:32:40 <byorgey> how about Pam?
14:32:54 <omnId> mapApply?
14:33:01 * byorgey only half joking
14:33:29 <byorgey> ApplyEachInAListOfFunctionsToAValue?
14:33:45 <ddarius> sequence
14:33:48 <KatieHuber> quicksilver: here
14:34:02 <quicksilver> KatieHuber: I'm trying to optimise my particle engine
14:34:25 <quicksilver> KatieHuber: currently it's moving + drawing about 12,000 particles (triangles) per second
14:34:42 <quicksilver> KatieHuber: which is better than the 3000 it was doing at the beginning of the evening
14:34:50 <KatieHuber> you mean, 12000 particles @ 60fps?
14:34:52 <quicksilver> KatieHuber: does that sounds like a reasonable speed?
14:35:02 <quicksilver> no, 3000 particles at 40fps
14:35:09 <quicksilver> erm
14:35:19 <quicksilver> which is 120,000 particles per second in fact :)
14:35:29 <quicksilver> clearly my maths is a bit limited...
14:35:53 <KatieHuber> well, particle systems are almost always limited by fill rate, since they tend to be blended
14:36:17 <KatieHuber> so the number of particles shouldn't matter nearly as much as the number that are on the screen
14:36:25 <quicksilver> they're all onscreen
14:36:39 <KatieHuber> so try taking them all offscreen, and see what your framerate does
14:36:46 <quicksilver> ;)
14:36:50 <KatieHuber> if it improves massively, there's little point optimizing further
14:36:52 * quicksilver tries that
14:36:53 <n00b> how do you implement operators recusively
14:37:01 <KatieHuber> if it stays the same, then you can probably still optimize
14:37:06 <n00b> ???
14:37:19 <omnId> n00b: the same as any other function?
14:37:20 <n00b> for example the mod or div operator
14:37:21 <byorgey> n00b: a function is recursive if it is defined in terms of itself.
14:37:31 <n00b> ok
14:37:36 <byorgey> n00b: usually, this means there will be a simple case called the 'base case' with no recursion.
14:37:38 <quicksilver> KatieHuber: went up from 40fps to 44fps
14:37:45 <byorgey> i.e. it's so simple you know the answer right away.
14:38:00 <quicksilver> KatieHuber: I guess that means I'm still CPU-bound
14:38:01 <byorgey> for example, numDigits a, when a <= 9.
14:38:03 <quicksilver> KatieHuber: right?
14:38:05 <KatieHuber> sounds that way
14:38:08 * quicksilver nods
14:38:09 <n00b> so can a div operator call itself
14:38:11 <n00b> ??
14:38:21 <quicksilver> well the haskell is doing quite a lot of work
14:38:30 <byorgey> n00b: and the other case is the recursive case, where the function calls itself on a *simpler* version of the problem, and somehow uses that to build the complete answer.
14:38:32 <quicksilver> perlin-noise generated wind turbulence
14:38:37 <byorgey> n00b: sure, any Haskell function can call itself.
14:38:55 <KatieHuber> time for profiling to see where the CPU time is going, then
14:38:58 * quicksilver nods
14:39:13 <byorgey> n00b: for example, the recurisve case for numDigits was to recognize that if you divide the number by 10, there's one less digit, so you can count the digits of that and then add one.
14:39:18 <quicksilver> I might try some simpler particle systems which don't use the perlin noise for comparison :)
14:39:26 <byorgey> i.e. numDigits a = 1 + numDigits (a `div` 10)
14:39:27 <n00b> base case would be like if n < 0 = error "Positive number only" else n = n + (div n)
14:39:55 <byorgey> hold on, you're putting too much in there =)
14:39:58 <byorgey> one thing at a time
14:40:02 <omnId> n00b: probably div x y | y > x = 0
14:40:20 <KatieHuber> I mean, a double-buffered STREAM_DRAW VBO, and writing directly to the MapBuffer'd pointer (can you even do that in Haskell?) would be the fastest way to get the vertices to the card
14:40:22 <n00b> just a algorithm
14:40:42 <KatieHuber> but there's a good chance that your problem isn't in the GL at all
14:40:47 <quicksilver> KatieHuber: I've not tried using vertex buffer stuff
14:41:02 <quicksilver> KatieHuber: this is all a great begin glBegin(GL_TRIANGLES)
14:41:07 <KatieHuber> OMG :/
14:41:11 <KatieHuber> well, start there then :p
14:41:30 <quicksilver> can you change colour in the middle of a vertex buffer?
14:41:38 <n00b> remember it must be recursive
14:41:49 <KatieHuber> you can submit a color array
14:42:32 <omnId> n00b: what's div 2 3?
14:42:57 <n00b> 0
14:43:07 <quicksilver> KatieHuber: yeah, I'm fairly sure it's my physics engine not my GL code which is the limiting factor
14:43:08 <omnId> n00b: what made you figure that out?
14:43:21 <quicksilver> KatieHuber: I wasn't sure though, until you pointed that out :) so, thanks.
14:43:34 <omnId> n00b: 3 > 2
14:43:46 <omnId> n00b: and div 4 3?
14:43:59 <n00b> 1
14:44:04 <quicksilver> KatieHuber: perlin noise is slow, probably I should cache some values to avoid recomputation.
14:44:23 <n00b> so it is possible to recursively div two numbers
14:44:41 <n00b> or more
14:44:41 <omnId> n00b: div 4 3 = 1 + div (4 - 3) 3
14:45:38 <omnId> you can think of division as iterated subtraction
14:48:16 <hpaste>  n00b pasted "(no title)" at http://hpaste.org/3315
14:48:27 <n00b> getting a stack overflow
14:48:37 <omnId> n00b: y > x
14:48:46 <omnId> div 2 3 | 3 > 2 = 0
14:48:52 <omnId> or x < y
14:51:24 <quicksilver> KatieHuber: Ah. If i try a larger number of simpler particles (10,000 particles with just simple ballistic movement), then I get 20fps onscreen but 40fps offscreen
14:51:39 <quicksilver> KatieHuber: so there is in fact definite room for improvement :)
14:52:27 <KatieHuber> yup
14:52:45 <dibblego> ?check \f -> (Nothing >>= (f :: Int -> Maybe Int)) == Nothing -- why is there no instance of Arbitrary for Maybe?
14:52:46 <lambdabot>        add an instance declaration for (Arbitrary (Maybe Int))     In the exp...
14:53:11 <quicksilver> KatieHuber: is there a rough order of magnitude I ought to be aiming for? 100,000 simply textured particles at 60fps, perhaps?
14:53:18 <quicksilver> KatieHuber: this is a fairly modern laptop
14:53:54 <KatieHuber> again, depends far more on blending and particle size than on the number of particles
14:54:26 <quicksilver> I'm definitely using alpha and modulate
14:54:34 <quicksilver> some particles I use additive blending on
14:56:20 <KatieHuber> if all the particles are offscreen, 100000@60fps doesn't sound unreasonable
14:56:26 * quicksilver nods
14:56:29 <shapr> Would "installHandler keyboardSignal" try to read from stdin?
14:57:05 <KatieHuber> if they're all onscreen and blended and say, 30ish pixels square, you'll get many fewer, maybe 5-10k@60fps
14:57:14 <KatieHuber> depends massively on your graphics card
14:57:32 <KatieHuber> really not possible to give a sensible answer :/
14:57:37 * quicksilver nods
14:57:39 <quicksilver> understood
14:57:51 <quicksilver> it's possible to point me in the direction of the right order of magnitude though :)
14:57:54 <quicksilver> which you have...
14:58:09 <quicksilver> OK, now to learn about vertex arrays and VBOs
14:59:43 <vincenz> @seen psykotic
14:59:44 <lambdabot> I saw psykotic leaving #haskell 2h 34m 16s ago, and .
15:01:00 <TomMD> Does anyone know if ndm made supero available anywhere?  I really would like to play with it.
15:01:24 <ddarius> ndm knows.
15:01:45 <TomMD> Yes, but lambdabot hasn't seen him for 5 hours and I keep missing him.
15:01:54 <omnId>  @ask him
15:01:55 <nopcode> hey :)
15:02:04 <abell> dibblego, I think defining an arbitrary for Maybe would choose frequencies which wouldn't be appropriate in most cases
15:02:18 <abell> Like returning Nothing half of the times
15:02:24 <dibblego> abell, I guess
15:02:28 <nopcode> how do i get, for each item in a list, the item and the rest of the list?
15:02:32 <nopcode> (with the item removed)
15:02:50 <dibblego> > tails [1..10]
15:02:52 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
15:02:57 <dibblego> like that?
15:03:16 <Olathe> @pl xs -> zip (heads xs) (tails xs)
15:03:16 <lambdabot> (line 1, column 4):
15:03:16 <lambdabot> unexpected ">" or "-"
15:03:16 <lambdabot> expecting variable, "(", operator or end of input
15:03:17 <nopcode> no, i want to pick an item in the middle of the list too, resulting in the item and the list without that item
15:03:25 <Olathe> O...K
15:03:26 <dmwit> see
15:03:28 <omnId> f [1,2,3] = [(1,[2,3]), (2,[1,3]), (3,[1,2])]?
15:03:31 <dmwit> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
15:03:38 <dibblego> @pl \xs -> zip (heads xs) (tails xs)
15:03:39 <lambdabot> liftM2 zip heads tails
15:03:47 <dmwit> There's a function there called "extract" which does what you're describing.
15:03:49 <Olathe> @pl \xs -> zip (heads xs) (tails xs)
15:03:49 <lambdabot> liftM2 zip heads tails
15:03:54 <Olathe> Take that !
15:03:59 <oerjan> @let extract l = [(x,bef++aft) | (bef,x:aft) <- zip (inits l) (tails l)]
15:04:04 <lambdabot> Defined.
15:04:08 <omnId> > liftM2 zip heads tails [1,2,3]
15:04:08 <lambdabot>   Not in scope: `heads'
15:04:12 <oerjan> > extract [1..10]
15:04:14 <lambdabot>  [(1,[2,3,4,5,6,7,8,9,10]),(2,[1,3,4,5,6,7,8,9,10]),(3,[1,2,4,5,6,7,8,9,10]),...
15:04:20 <Olathe> Ahh, inits.
15:04:27 <omnId> > liftM2 zip inits tails [1,2,3]
15:04:29 <lambdabot>  [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
15:04:34 <TomMD> @ask ndm Is superO available to the public?  I've got a MD5 implementation (2-5x slower than C when using GHC -O2) I thought might be fun to test with superO... provided I can get it setup with Data.ByteString
15:04:35 <lambdabot> Consider it noted.
15:04:41 <Olathe> Bah.
15:04:46 <Olathe> @pl \xs -> zip xs (tails xs)
15:04:46 <lambdabot> ap zip tails
15:04:58 <omnId> > map (\(xs,y:ys) -> (y, xs++ys)) $ liftM2 zip inits tails [1,2,3]
15:05:00 <lambdabot>   Non-exhaustive patterns in lambda
15:05:03 <Olathe> > (ap zip tails) [1, 2, 3, 4]
15:05:04 <lambdabot>  [(1,[1,2,3,4]),(2,[2,3,4]),(3,[3,4]),(4,[4])]
15:05:16 <nopcode> hm :)
15:05:17 <ddarius> > fix ((0:) . (1:) . ap (zipWith (+)) tail)
15:05:18 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:05:27 <Olathe> @pl \xs -> zip xs (tail (tails xs))
15:05:27 <lambdabot> ap zip (tail . tails)
15:05:38 <Olathe> > (ap zip (tail . tails)) [1, 2, 3, 4]
15:05:39 <lambdabot>  [(1,[2,3,4]),(2,[3,4]),(3,[4]),(4,[])]
15:05:42 <shapr> Aha! it was installHandler keyboardSignal!
15:05:52 <omnId> > take 3 $ map (\(xs,y:ys) -> (y, xs++ys)) $ tail $ liftM2 zip inits tails [1,2,3]
15:05:54 <lambdabot>   Non-exhaustive patterns in lambda
15:06:18 <ddarius> > let f !a = a in f 3
15:06:19 <lambdabot>   Not in scope: `f'
15:06:22 <Olathe> @pl \xs -> map (\t -> (head t, tail t)) (tails xs)
15:06:23 <lambdabot> map (liftM2 (,) head tail) . tails
15:06:31 <Olathe> > (map (liftM2 (,) head tail) . tails) [1, 2, 3, 4]
15:06:32 <lambdabot>  Exception: Prelude.head: empty list
15:06:49 <omnId> > init $ map (\(xs,y:ys) -> (y, xs++ys)) $ liftM2 zip inits tails [1,2,3]
15:06:50 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
15:06:56 <omnId> :D
15:07:15 <Olathe> @src mapWhile
15:07:15 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:07:29 <TomMD> @src infinity
15:07:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:07:36 <dmwit> map f . takeWhile p ?
15:07:44 <dmwit> ?src Infinity
15:07:45 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:08:17 <oerjan> Infinity is only a Read/Show thing, not a real constructor
15:08:20 <Olathe> @pl \xs -> map (\t -> (head t, tail t)) (takeWhile (not . null) (tails xs))
15:08:21 <lambdabot> map (liftM2 (,) head tail) . takeWhile (not . null) . tails
15:08:33 <Olathe> > (map (liftM2 (,) head tail) . takeWhile (not . null) . tails) [1, 2, 3, 4]
15:08:34 <lambdabot>  [(1,[2,3,4]),(2,[3,4]),(3,[4]),(4,[])]
15:08:43 <omnId> > init $ map (\(xs,y:ys) -> (y, xs++ys)) $ liftM2 zip inits tails [1,2,3,4]
15:08:45 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
15:08:45 <ddarius> @let fib n = fib' n 0 1 0 1 where fib' 0 a b c d = a; fib' n a b p q | a `seq` b `seq` p `seq` q `seq` False | even n = fib' (n `div` 2) a b (p*p+q*q) (2*p*q+q*q) | otherwise = fib' (n - 1) ((p+q)*a+q*b) (q*a+p*b) p q
15:08:46 <lambdabot>  Parse error
15:09:04 <Olathe> Oh.
15:09:15 <Olathe> I've been doing it wrong this whole time.
15:09:39 <dmwit> > let extract n xs = let (b, m:e) = splitAt n xs in (m, b++e) in extract 5 [1..10]
15:09:40 <lambdabot>  (6,[1,2,3,4,5,7,8,9,10])
15:10:46 <ddarius> @let fib n = fib' n 0 1 0 1 where fib' n a b p q | n `seq` a `seq` b `seq` p `seq` q `seq` False = undefined;fib' 0 a _ _ _ = a; fib' n a b p q | even n = fib' (n `div` 2) a b (p*p+q*q) (2*p*q+q*q) | otherwise = fib' (n - 1) ((p+q)*a+q*b) (q*a+p*b) p q
15:10:49 <omnId> > zipWith (\i xs -> (xs !! i, take i xs ++ drop (i+1) xs) [0..] $ (\xs -> map (const xs) xs) [1,2,3,4]
15:10:49 <lambdabot>  Unbalanced parenthesis
15:10:51 <lambdabot> Defined.
15:11:00 <ddarius> > fib 20
15:11:01 <omnId> > zipWith (\i xs -> (xs !! i, take i xs ++ drop (i+1) xs)) [0..] $ (\xs -> map (const xs) xs) [1,2,3,4]
15:11:03 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
15:11:03 <lambdabot>  6765
15:11:14 <ddarius> > map fib [1..20]
15:11:15 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
15:11:30 <AndyC> Hi, can anyone help me with a Parsec question please?
15:11:48 <dmwit> shoot!
15:11:53 <Olathe> > map fibs [270,273..280]
15:11:54 <lambdabot>   Not in scope: `fibs'
15:11:58 <Olathe> > map fib [270,273..280]
15:12:00 <lambdabot>  [119447720249892581203851665820676436622934188700177088360,50598866273592314...
15:12:30 <AndyC> Thanks. I am trying to parse some binary data (actually it's a Java class file).
15:12:31 <jonathanv> my goodness, this fib function confuses me
15:13:05 <AndyC> I'm looking at the bytecode that can be a variable number of bytes.
15:13:54 <AndyC> I want to parse the first byte, do a case of on it to work out how many more bytes to read, read them then return something.
15:14:27 <AndyC> I'm fine up until the second bit of parsing e.g. read in two more bytes.
15:14:38 <dmwit> > let phi = (1 + sqrt 5) / 2; fib n = round ((phi ** n - (negate phi) ** (negate n)) / sqrt 5) in fib 1
15:14:40 <lambdabot>  1
15:14:43 <AndyC> Any ideas on a direction please?
15:14:46 <dmwit> > let phi = (1 + sqrt 5) / 2; fib n = round ((phi ** n - (negate phi) ** (negate n)) / sqrt 5) in map fib [1..10]
15:14:47 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
15:15:07 <dmwit> > let phi = (1 + sqrt 5) / 2; fib n = round ((phi ** n - (negate phi) ** (negate n)) / sqrt 5) in map fib [270,273..280]
15:15:08 <lambdabot>  [119447720249893657237202506912376692627920328520374419456,50598866273592779...
15:15:12 <omnId> do n <- anyToken; bytes <- sequence (replicate n anyToken); ... -- something like that maybe
15:15:20 <dmwit> Doesn't seem exact.
15:15:24 <nopcode> hm
15:15:32 <nopcode> i guess this would be easier if i just removed the element from the list
15:15:43 <nopcode> by searching for it
15:15:48 <dmwit> nopcode: What are you trying to do?
15:15:55 <oerjan> :t replicateM
15:15:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:15:58 <dmwit> omnId: Are you familiar with do-notation for monads?
15:16:07 <dmwit> err...
15:16:08 <AndyC> After the first anyToken I need to look at n and decide how many more to read.
15:16:09 <nopcode> dmwit: well it's a logic puzzle
15:16:19 <omnId> dmwit: AndyC*? :)
15:16:22 <dmwit> yes
15:16:24 <dmwit> sorry
15:16:30 <AndyC> yes
15:16:33 <AndyC> ish
15:16:34 <nopcode> dmwit: people walking over the bridge... i need to expand the state
15:16:37 <dmwit> AndyC: Okay, no problem.
15:17:02 <nopcode> i've got a state with lists l and r, representing the list of people on each side
15:17:25 * glguy reminds hpasters to use the annotate functionality when pasting revisions of existing code
15:17:28 <nopcode> now i want to get all states which can be derived from this by moving one person in list 'r' to list 'l'
15:17:36 <dmwit> varLength = do { length <- number; case length of { 0 -> fail "bad file"; n -> replicateM n anyToken } }
15:17:47 <dmwit> AndyC: But more likely, you'd want:
15:17:59 <dmwit> varLength = number >>= replicateM anyToken
15:18:02 <dmwit> :t replicateM
15:18:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:18:06 <nopcode> so, how do i get a list with the first occurence of a given item removed?
15:18:11 <AndyC> Ah, sorry. Hang on.
15:18:23 <dmwit> AndyC: Well, you get the idea, though there might need to be a "flip" in my code somewhere. =P
15:18:30 <omnId> you're parsing [Byte]?
15:18:35 <AndyC> The first byte I read isn't how many more to read. It's an opcode.
15:18:58 <AndyC> Some opcodes want two more bytes, some want one, some don't need any.
15:19:15 <dmwit> AndyC: It doesn't matter what you're reading; the technique I just showed should apply equally well.
15:19:55 <dmwit> nopcode: delete?
15:19:55 <AndyC> So I want to say something like do op <- anyToken; case op of 0 -> arg <- parseIndex; return C op arg;
15:19:57 <dmwit> :t delete
15:19:57 <oerjan> AndyC: btw Parsec defines count which i guess is a restricted synonym for replicateM
15:19:58 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
15:20:01 <TomMD> nopcode: Look at Data.List (delete, deleteBy, deleteFirstBy)
15:20:17 <puusorsa> .. damn
15:20:36 <dmwit> AndyC: right
15:20:36 <AndyC> oerjan: Thanks, I've used that elsewhere already.
15:20:39 <nopcode> ok thanks
15:20:42 <puusorsa> 20sec too slow, almost managed to say something helpful :)
15:21:24 <dmwit> AndyC: Though in the case statement, you'll need to add the "do" keyword again, because at that point you're out of the original do block.
15:21:33 <TomMD> puusorsa: That would have made four.  I already came in third - its no wonder our community is small, I keep forgetting people don't like being smothered.
15:22:26 <AndyC> dmwit: Yeah, I tried that and I can't get it just so. Is the state after the 1st do still getting threaded into the 2nd do?
15:22:49 <dmwit> AndyC: Things in scope in the first do should still be in scope in the case statement.
15:23:02 <dmwit> AndyC: Why don't you paste the code you're trying to use?  It will be a lot easier for us to help you.
15:23:03 <dmwit> ?hpaste
15:23:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:23:32 <AndyC> Cos, it's on a different computer at work :-(
15:24:00 <AndyC> It's my first time daring to enter. I don't know what I was afraid of.
15:24:01 <dmwit> ...
15:24:30 <dmwit> ok
15:24:41 <AndyC> I'll come back another time with something to show you. Thanks very much for your help.
15:24:49 <dmwit> Well, good luck!
15:24:50 <dmwit> =)
15:25:58 <ddarius> He should join some other IRC channels...
15:46:35 * raxas failed miserably to coerce his girlfriend into haskell
15:47:26 * dmwit failed miserably to coerce his girlfriend into programming
15:47:42 <dmwit> You're one step ahead of the game, raxas. =)
15:48:49 <Spark> every so often, when we're on enough drugs, i try to teach my girlfriend about programming
15:48:57 <Spark> usually she gets bored and i get frustrated and then the drugs wear off
15:49:06 <dolio> That's the best time to learn stuff.
15:49:29 <jonathanv> what drugs
15:49:43 <Spark> amphetamine usually
15:49:51 <jonathanv> gross
15:50:10 <nopcode> how do i apply a function to a tuple of arguments?
15:50:23 <dmwit> Same as usual, put them next to each other.
15:50:25 <raxas> dmwit: Of course. We keep dating for more than 12 years now. But she said "No, I am too old for such a crazy coding."
15:50:29 <dmwit> f (a, b, c)
15:50:42 <jonathanv> why can't people just stick to weed
15:50:44 <nopcode> nah i mean i want each element of the tuple to become one argument
15:50:46 <dmwit> raxas: Hahaha, that's a pretty awesome quote.
15:50:50 <Japsu> nopcode: use uncurry
15:51:02 <omnId> (\(x,y,z) -> f x y z)
15:51:14 <Japsu> > uncurry (\x y -> x + y) $ (1,2)
15:51:16 <lambdabot>  3
15:51:24 <omnId> @src uncurry
15:51:24 <lambdabot> uncurry f p = f (fst p) (snd p)
15:51:29 <Spark> jonathanv: maybe because it makes you fall asleep or go insane
15:51:30 <omnId> already does it for (x, y)
15:51:40 <Japsu> hmm
15:51:49 <dmwit> > (+1) &&& concat $ (3, [[4,5],[6,7,8]])
15:51:49 <lambdabot>  Couldn't match expected type `[[a]]'
15:51:54 <Japsu> @pl \f (x,y,z) -> f x y z
15:51:55 <lambdabot> (line 1, column 8):
15:51:55 <lambdabot> unexpected ","
15:51:55 <lambdabot> expecting letter or digit, operator or ")"
15:51:55 <lambdabot> ambiguous use of a non associative operator
15:51:56 <jonathanv> if weed makes you fall asleep, maybe you need that sleep
15:52:02 <dmwit> > ((+1) &&& concat) (3, [[4,5],[6,7,8]])
15:52:02 <lambdabot>  Couldn't match expected type `[[a]]'
15:52:04 <omnId> dmwit: (***)
15:52:10 <dmwit> oh, right
15:52:20 <dmwit> > (+1) *** concat $ (3, [[4,5],[6,7,8]])
15:52:22 <lambdabot>  (4,[4,5,6,7,8])
15:53:49 <Japsu> why can't I suddenly pattern match with a triplet
15:53:56 <Japsu> in a lambda
15:53:57 <Japsu> @pl let uc3 f (x,y,z) = f x y z in uc3
15:53:58 <lambdabot> (line 1, column 15):
15:53:58 <lambdabot> unexpected ","
15:53:58 <lambdabot> expecting letter or digit, operator or ")"
15:53:58 <lambdabot> ambiguous use of a non associative operator
15:54:06 <dmwit> Japsu: You can, it's just ?pl that doesn't know about that.
15:54:09 <Japsu> right
15:54:13 <oerjan> Japsu: since there are no functions to unpack a triplet, @pl cannot do anything about them
15:54:21 <Japsu> k
15:54:35 <dmwit> > (\(x, y, z) -> x + y + z) (3,4,7)
15:54:36 <lambdabot>  14
15:55:01 <omnId> @type let uc3 f (x,y,z) = f x y z in uc3
15:55:02 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2 -> t3) -> (t, t1, t2) -> t3
15:57:15 <omnId> @pl (\f ((x,y),z) -> f x y z) -- it works if you use nested pairs, not pretty though :)
15:57:15 <lambdabot> (`ap` snd) . (. fst) . (`ap` snd) . (. fst)
15:59:42 <Olathe> @shorten (`ap` snd) . (. fst) . (`ap` snd) . (. fst)
15:59:43 <lambdabot> Unknown command, try @list
15:59:44 <Olathe> :(
16:00:02 <omnId> (\f ((x,y),z) -> f x y z) -- :)
16:00:24 <omnId> @type (`ap` snd) . fst
16:00:26 <lambdabot> forall b a b1 b2. ((a, b1) -> b1 -> b, b2) -> (a, b1) -> b
16:00:38 <oerjan> :t uncurry.uncurry
16:00:41 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
16:02:01 <oerjan> short enough? :)
16:02:08 <nopcode> %)
16:06:22 <ivanm> what's the difference between record-style types and "standard" types?
16:06:33 <ivanm> record-style types are just named versions of the latter?
16:06:44 <sjanssen> ivanm: not very much
16:06:59 <ivanm> *nod*
16:07:03 <Vulpyne> It's usually easier to deal with stuff by name than position.
16:07:18 <Vulpyne> Especially if you reorder things or add/remove fields.
16:07:21 <sjanssen> record style just introduces accessor functions and allows the {} pattern matching and update syntax
16:07:27 <ivanm> so can you use record-style with pattern matching like with normal types?
16:08:07 <ivanm> e.g. data FooBar = FB {foo :: String, bar :: String} ... f :: FooBar -> String, f FB f b = f ++ b
16:08:10 <ivanm> would that work?
16:08:18 <omnId> data T = C { x :: U } is like data T = C U; x (C a) = a
16:08:20 <ivanm> make that f (FB f b)
16:08:45 <ivanm> so does pattern matching work?
16:09:03 <omnId> yes
16:09:28 <omnId> also f (FB {foo = f, bar = b}) = f ++ b
16:09:34 <ivanm> *nod*
16:09:57 <ivanm> though presumably record-style makes it easier to extract one particular variable than in non-record style or by using a tuple?
16:09:58 <oerjan> > case Just 1 of Just {} -> True; _ -> False
16:10:03 <lambdabot>  True
16:10:26 <ivanm> how did that work? the {} matches everything?
16:10:57 <EvilRanter> it's a curiosity of the grammar
16:11:06 <ivanm> *nod*
16:11:16 <EvilRanter> it's record syntax for "record with no fixed fields"
16:11:22 <ivanm> ahhh
16:11:33 <ivanm> so {} is equivalent to _ ?
16:11:33 <EvilRanter> but it happens to work for constructors that weren't defined as records, too
16:11:45 <ddarius> ivanm: No.
16:11:52 <omnId> ivanm: a record pattern needs a Constructor
16:11:54 <EvilRanter> it's independent of number of parameters on the constructor
16:11:55 <ivanm> so is that a curiosity as defined in H98, or just implementation-specific
16:12:00 <ivanm> ddarius, omnId: *nod*
16:12:10 <ivanm> EvilRanter: ahhhhh
16:12:13 <oerjan> H98
16:12:17 <EvilRanter> > case (1,2) of (,) {} -> True; _ -> False
16:12:18 <lambdabot>      Warning: Pattern match(es) are overlapped
16:12:18 <lambdabot>              In a case alterna...
16:12:36 <EvilRanter> hm. well, it parsed, so it made my point :)
16:12:39 <ivanm> so its a way of pattern matching constructors rather than just the parameters?
16:12:47 <ivanm> i.e. working out which constructor was used
16:12:56 <omnId> Just {} is equivalent to Just _
16:13:20 <oerjan> would have been nice if you could do the opposite - pattern match on a field regardless of constructor
16:13:24 <omnId> say Constr has 3 fields, Constr {} is Constr _ _ _
16:13:34 <ivanm> *nod*
16:13:35 <oerjan> but alas
16:13:36 <ddarius> oerjan: That would rarely make sense.
16:14:06 <ivanm> oerjan: wouldn't that only work with constructors with the same number of parameters, and possibly the same types of parameters?
16:14:09 <oerjan> ddarius: say if you have a type with two constructors that share a field
16:14:45 <ddarius> I didn't say it never made sense.
16:14:58 <omnId> ivanm: different constructors can share a field name, but it must have the same type.
16:15:17 <ivanm> *nod*
16:15:17 <omnId> data Foo = Bar { x :: String, y :: Int } | Baz { x :: String }
16:15:25 <omnId> x :: Foo -> String
16:15:55 <ivanm> so to access the x field, if fb :: Foo, then its just fb.x ?
16:16:06 <ddarius> This isn't Java.
16:16:06 <omnId> x fb
16:16:13 <omnId> x is a selector function
16:16:21 <ddarius> x is just a function
16:16:24 <omnId> hence x :: Foo -> String
16:17:36 <ivanm> oh.... I was going off this: http://research.microsoft.com/~simonpj/Haskell/records.html
16:17:43 <ivanm> or is this just a proposal?
16:18:00 <omnId> just a proposal
16:18:37 <omnId> modifyX f foo@(Foo {x = oldx}) = foo {x = f oldx} -- a sensible modifyX definition
16:20:11 <ivanm> ahhh
16:23:40 <Betovsky> hi
16:23:43 <Betovsky> one question
16:24:06 <shapr> ?
16:24:20 <Betovsky>  let fun = (scanl1 (*)) . enumFromTo 1
16:24:23 <Betovsky> this works
16:24:32 <Betovsky> let fun = (scanl1 (*)) . enumFromTo
16:24:36 <Betovsky> this doesnt work
16:24:51 <Betovsky> shouldnt be able to work?
16:24:59 <Betovsky> being fun to receive 2 args
16:25:02 <EvilRanter> ?type (scanl1 (*)) . enumFromTo
16:25:03 <chessguy> @type (scanl1 (*)) . enumFromTo
16:25:07 <lambdabot>     Couldn't match expected type `[a]'
16:25:08 <lambdabot>            against inferred type `a1 -> [a1]'
16:25:09 <lambdabot>     Couldn't match expected type `[a]'
16:25:09 <lambdabot>            against inferred type `a1 -> [a1]'
16:25:13 <EvilRanter> ?type (.)
16:25:16 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:25:16 <oerjan> . always threads exactly one argument
16:25:19 <EvilRanter> ?type scanl1 (*)
16:25:21 <lambdabot> forall a. (Num a) => [a] -> [a]
16:25:26 <EvilRanter> ?type enumFromTo
16:25:28 <lambdabot> forall a. (Enum a) => a -> a -> [a]
16:25:29 <omnId> fun1 x = scanl1 (*) [1..x] ; fun2 x = scanl1 (*) [x .. ???]
16:25:57 <EvilRanter> ?src (.)
16:25:57 <lambdabot> (.) f g x = f (g x)
16:25:59 <Betovsky> hmm i think i see
16:26:07 <EvilRanter> (f . g) x = f (g x)
16:26:13 <EvilRanter> so (f . g) x y = f (g x) y
16:26:34 <Betovsky> isn't there something like (.) but the second function receives 2 args?
16:26:41 <omnId> @type let (f .: g) x y = f (g x y) in scanl1 (*) .: enumFromTo
16:26:43 <lambdabot> forall a. (Num a, Enum a) => a -> a -> [a]
16:27:09 <oerjan> @pl \f g x y -> f (g x y)
16:27:10 <lambdabot> (.) . (.)
16:27:25 <omnId> ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
16:27:28 <chessguy> ah, the old hooter
16:27:44 <omnId> @type (scanl1 (*) .) . enumFromTo
16:27:45 <lambdabot> forall a. (Num a, Enum a) => a -> a -> [a]
16:28:29 <Betovsky> hehe
16:28:33 <Betovsky> thx
16:28:35 <oerjan> more generally, you pack the first function inside as many (_ .) as you need
16:28:59 <omnId> @pl \x y z -> f (g x y z)
16:28:59 <lambdabot> ((f .) .) . g
16:29:21 <oerjan> @pl \f g x y z -> f (g x y z)
16:29:21 <lambdabot> (.) . (.) . (.)
16:29:59 <Betovsky> hmm
16:30:12 <chessguy> by the way everyone, it's now been proven that any 2 numbers are equal to each other. all of mathematics is screwed. time to go home. http://www.mathbin.net/15013
16:30:16 <lambdabot> Title: MathBin.net - Proof that any 2 numbers are equal to each other
16:31:28 <oerjan> @slap chessguy
16:31:29 * lambdabot smacks chessguy about with a large trout
16:31:38 * chessguy grins
16:34:36 <roconnor> conal: I made my first phooey application with a gtk2hs backend.
16:34:55 <roconnor> conal: runUI (stringEntry "Initial String" >>= stringDisplay)
16:40:14 * roconnor doesn't believe that the limit of integrals is the same as the integral of a limit.
16:40:39 <oerjan> indeed not without further restrictions
16:43:25 <gwern> hey everyone. I remember someone once telling me that a way to improve on 'nub' performance was instead a (toList . fromList) using Data.Set or whatever, but that the latter did not produce the exact same output as the former somehow - that the better performance came at a cost
16:43:33 <gwern> does anyone remember what the difference was?
16:43:43 <gwern> (I'd test for myself, but my ghc is currently broken)
16:43:45 <oerjan> order
16:43:59 <bos> you'll get your list sorted if you pipe it through a Map or Set.
16:44:33 <gwern> a Map too? but I thought it was Set's feature that it didn't admit duplicates
16:45:03 <bos> it does, but if you put in [4,3,3,2,5,1], you'll get out [1,2,3,4,5]
16:45:12 <bos> doesn't, that is
16:45:26 <oerjan> map doesn't admit duplicates either
16:45:51 <Olathe> @src nub\
16:45:52 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:45:53 <Olathe> @src nub
16:45:53 <lambdabot> nub = nubBy (==)
16:45:56 <Olathe> @src nubBy
16:45:56 <lambdabot> nubBy eq []             =  []
16:45:57 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:46:14 <gwern> huh. so what exactly is a Map then? (I know I should look this up but I'm feeling lazy)
16:46:40 <EvilRanter> a map is a "function" from its key type to its value type
16:46:48 <omnId> > M.fromList [(1,'a'), (2,'b')] M.! 2
16:46:50 <lambdabot>  'b'
16:47:06 <EvilRanter> so you can have several keys pointing to the same value, but not several instances of the same key
16:47:11 <gwern> hmm. so... a little like an array then?
16:47:24 <EvilRanter> a (Set a) is kinda like a (Map a ())
16:47:29 <oerjan> i think you can do something hairy with zip [0..] to preserve order using map to nub
16:47:30 <omnId> other languages call them hashes or associative arrays.
16:47:53 <gwern> ah, I see then
16:47:57 <EvilRanter> it is kinda like an array, yeah, in some respects
16:48:10 <EvilRanter> but it's got different constraints on the key, and is much less space-efficient
16:48:34 <EvilRanter> but better algorithmically for a lot of things; heck, it can even be more space-efficient, if your keys are very spread out
16:48:34 <oerjan> actually you may not even need a map, just sortBy
16:48:35 <jbauman> tail recursion?
16:48:49 <jbauman> oops, scrolled up
16:49:38 <Olathe> > let uniq = uniqBy (==); uniqBy eq = uniqBy' eq []; uniqBy _ _ [] = []; uniqBy eq ps (x:xs) = if (elem x ps) then x:(uniqBy' eq (x:ps) xs) else uniqBy' eq ps xs in uniq [5, 2, 3, 5, 4, 2]
16:49:39 <lambdabot>  arity mismatch for 'uniqBy'
16:49:48 <Olathe> > let uniq = uniqBy (==); uniqBy eq = uniqBy' eq []; uniqBy _ _ [] = []; uniqBy' eq ps (x:xs) = if (elem x ps) then x:(uniqBy' eq (x:ps) xs) else uniqBy' eq ps xs in uniq [5, 2, 3, 5, 4, 2]
16:49:48 <lambdabot>  arity mismatch for 'uniqBy'
16:49:54 <Olathe> > let uniq = uniqBy (==); uniqBy eq = uniqBy' eq []; uniqBy' _ _ [] = []; uniqBy' eq ps (x:xs) = if (elem x ps) then x:(uniqBy' eq (x:ps) xs) else uniqBy' eq ps xs in uniq [5, 2, 3, 5, 4, 2]
16:49:56 <lambdabot>  []
16:49:59 <Olathe> Bah.
16:50:12 <dcoutts_> @seen dons
16:50:13 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 22m ago.
16:50:53 <Olathe> > let uniq = uniqBy (==); uniqBy eq = uniqBy' eq []; uniqBy' _ _ [] = []; uniqBy' eq ps (x:xs) = if (any (eq x) ps) then x:(uniqBy' eq (x:ps) xs) else uniqBy' eq ps xs in uniq [5, 2, 3, 5, 4, 2]
16:50:54 <oerjan> Olathe: you cannot use elem
16:50:55 <lambdabot>  []
16:51:03 <dcoutts_> dons: I'd like to do a binary 0.4.1 point release with ghc-6.4, 6.6, 6.8 compatibility
16:51:04 <oerjan> too slow :)
16:51:08 <omnId> (map head . group . sort) I think would do quickly enough.  I'm not sure how it compares to (toList . fromList)
16:51:09 <Olathe> I know.
16:51:22 <Olathe> I'm doing it with a list, which can then be converted to using a set or something.
16:51:45 <Olathe> > let uniq = uniqBy (==); uniqBy eq = uniqBy' eq []; uniqBy' _ _ [] = []; uniqBy' eq ps (x:xs) = if (any (x `eq') ps) then x:(uniqBy' eq (x:ps) xs) else uniqBy' eq ps xs in uniq [5, 2, 3, 5, 4, 2]
16:51:46 <lambdabot>  Parse error
16:51:50 <Olathe> > let uniq = uniqBy (==); uniqBy eq = uniqBy' eq []; uniqBy' _ _ [] = []; uniqBy' eq ps (x:xs) = if (any (x `eq`) ps) then x:(uniqBy' eq (x:ps) xs) else uniqBy' eq ps xs in uniq [5, 2, 3, 5, 4, 2]
16:51:52 <lambdabot>  []
16:51:54 <Olathe> Bah.
16:52:23 <Olathe> > let uniq = uniqBy (==); uniqBy eq = uniqBy' eq []; uniqBy' _ _ [] = []; uniqBy' eq ps (x:xs) = if (any (x `eq`) ps) then uniqBy' eq ps xs else x:(uniqBy' eq (x:ps) xs) in uniq [5, 2, 3, 5, 4, 2]
16:52:24 <lambdabot>  [5,2,3,4]
16:52:27 <Olathe> There.
16:52:31 <Olathe> Ordering is preserved.
16:52:46 <oerjan> that's just nubBy
16:52:46 <Olathe> Not sure how to use sets, though.
16:52:59 <Olathe> Right, but you can replace the list with a set to get the speedup.
16:53:06 <Olathe> With nubBy, you can't.
16:53:13 <Olathe> @src nubBy
16:53:13 <lambdabot> nubBy eq []             =  []
16:53:13 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:54:00 <dons> dcoutts_: seems reasonable
16:54:05 <dons> there was a 32 bit import issue anyway
16:54:09 <dons> so we hvae to do a minor release
16:54:18 <dons> but backporting all the constructor changes is just sucky
16:54:30 <dcoutts_> dons: I've done it, it was easy
16:54:36 <dcoutts_> dons: and it's easy to make bytestring-0.9 build with ghc-6.4 and 6.6
16:54:46 <dcoutts_> I've got all the changes locally
16:54:58 <dcoutts_> I'm just building the latest ghc snapshot so I can test with 6.8
16:55:05 <oerjan> @let on e f x y = f x `e` f y
16:55:10 <lambdabot> Defined.
16:55:35 <dcoutts_> dons: and I'll send the changes to unix-compat and tar to bringert
16:55:40 <dons> huh, http://alberrto.googlepages.com/easyvision
16:55:42 <lambdabot> Title: Alberrto - easyVision
16:55:51 <dons> dcoutts_: great work.
16:55:56 <dons> that'll keep people happy then
16:56:04 <dons> `This is an experimental Haskell system for fast prototyping of computer vision and image processing applications'
16:56:25 <dcoutts_> dons: what we need is for cabal-install to support local package repos, so one can test packaging changes locally
16:56:26 <Olathe> Ahh, uniqBy won't work, just uniq.
16:56:51 <dcoutts_> dons: even better would be 'unpacked' local package repos
16:56:55 <dons> mm
16:57:02 <oerjan> > map snd . sortBy (comparing fst) . map head . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ [5,2,3,5,4,2]
16:57:04 <lambdabot>  [5,2,3,4]
16:57:06 <dcoutts_> dons: so that it builds from the source tree, rather than a tarball
16:57:41 <dcoutts_> dons: imaging unpacking all the tarballs in a hackage repo in place, then just editing and building
16:58:11 <dons> yeah
16:59:03 <Olathe> > let uniq = uniq' Data.Set.empty; uniq' _ [] = []; uniq' set (x:xs) = if (Data.Set.member x set) then uniq' set xs else (x:uniq' (Data.Set.insert x set) xs) in uniq [5, 2, 3, 5, 4, 2]
16:59:05 <lambdabot>  [5,2,3,4]
16:59:08 <Olathe> There we are.
17:00:37 <dons> hmm, so that computer vision thing has haskell bindings to:
17:00:38 <dons>     * HSSL (new version of GSLHaskell) for matrix computations.
17:00:38 <dons>     * HopenGL for 2D and 3D graphics and user interface.
17:00:38 <dons>     * MPlayer for real time image grabbing and video decoding.
17:00:38 <dons>     * Intel's IPP for fast image processing.
17:00:40 <dons>     * Other useful software: segment extraction, SVMLight, etc.
17:00:43 <dons> ?
17:00:45 <dons> if so -- wow!
17:00:51 <Olathe> Nice and order-preserving. Also, if Data.Set is fast, this will be faster than nub.
17:07:35 <Pseudonym> Why/
17:07:40 <Pseudonym> Why did you remove the _1?
17:07:48 <shapr> dons: That's nifty
17:08:41 <Pseudonym> Whoops, wrong channel.
17:09:02 <ChilliX> Hi guys!
17:17:26 <shapr> hiya ChilliX
17:18:41 <ivanm> with record types, is there an easier way to create/change variables of that type?
17:19:18 <ivanm> rather than having to explicitly do fb = FB {foo = "foo", bar = 2} each time ?
17:20:07 <EvilRanter> (FB "foo" 2) would work, too
17:20:19 <ivanm> *nod*
17:20:31 <EvilRanter> (assuming you defined it in that order)
17:20:43 <omnId> @go overloading functional references
17:20:46 <lambdabot> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
17:20:46 <lambdabot> Title: Overloading functional references - 21 thoughts
17:20:55 <omnId> ivanm: that's an interesting article
17:21:19 <lokimaf_> would you know if there is an open source Haskell SAT solver?
17:22:36 <ivanm> well, I've never touched template haskell :s
17:22:49 <omnId> ivanm: as given there's no magic.
17:22:54 * ivanm might code without record fields for now and leave that till later
17:23:18 <omnId> basically it defines a fooRef = FRef foo (\x fb -> fb {foo = x}), then you can pass this fooRef into set, get, modify, compose, etc.
17:24:08 <pweaver> Is there a nonblocking read function in System.Win32, or a way to see if there is anything waiting in a HANDLE?  All I can find is win32_ReadFile, which blocks
17:27:06 <dcoutts_> pweaver: or just use the portable functions
17:27:23 <dcoutts_> on an ordinary IO.Handle as opposed to a Win32.HANDLE
17:27:32 <pweaver> yes, I would like to :)
17:27:38 <dcoutts_> @hoogle hgetnonblocking
17:27:38 <lambdabot> No matches found
17:27:42 <pweaver> but i'm using a module that uses System.Win32 :p
17:27:43 <dcoutts_> doh
17:28:05 <dcoutts_> @hoogle nonblocking
17:28:05 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
17:28:05 <lambdabot> System.IO.hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
17:28:11 <pweaver> yes I know about that
17:28:40 <pweaver> but I don't have a IO.Handle, I have a Win32.HANDLE
17:28:53 <dcoutts_> pweaver: try converting it to a Handle
17:29:02 <pweaver> is that possible, how?
17:29:28 <dcoutts_> yes, it is possible, afterall, a Handle just wraps a HANDLE on windows
17:29:34 <dcoutts_> it might not be terribly easy however
17:30:02 <pweaver> yes, what I meant was... is there a function already defined for that :p
17:30:09 <dcoutts_> I know the unix package provides a way to convert a FD to a Handle, I'd expect the win32 package provides an equivalent
17:30:12 <pweaver> and it would seem no
17:31:38 <dcoutts_> pweaver: try fdToHandle
17:32:06 <dcoutts_> GHC.Handle.fdToHandle
17:32:10 <dcoutts_> it works on windows too
17:33:00 <pweaver> HANDLE and fd are not compatible
17:33:04 <dcoutts_> pweaver: you'll have to cast the HANDLE to an FD
17:33:14 <dcoutts_> type   HANDLE      = Ptr ()
17:33:20 <dcoutts_> but it's not really a pointer
17:33:25 <pweaver> all rightee
17:33:28 <dcoutts_> it's an abstract 32bit value
17:33:29 <pweaver> I don't know how to do that :)
17:33:33 <pweaver> right
17:34:21 <pweaver> isn't Fd a Posix type?
17:34:29 <pweaver> how is that gonna work on native Win32?
17:34:50 <visof> > let abs x if x>0 then  x else if x<0  then -1*x  else 0
17:34:51 <lambdabot>  Parse error
17:34:56 <visof> help?
17:35:02 <LoganCapaldo> 2 things
17:35:06 <LoganCapaldo> you forgot the =
17:35:12 <LoganCapaldo> and > only does expressions
17:35:13 <dcoutts_> pweaver: the term comes from posix, but the ms c lib provides them too
17:35:43 <LoganCapaldo> > let f x = x + 1 in f 4
17:35:45 <pweaver> you're starting to lose me... I don't know where that (ms c lib) is
17:35:48 <lambdabot>  5
17:35:55 <LoganCapaldo> visof: clear?
17:36:22 <visof> loganCapaldo ya
17:37:14 <dcoutts_> pweaver: they're all just integers, representing indexes into the OS's table of per-process resources
17:37:25 <visof> > let abs x if x>0 then  x else if x<0  then -1*x  else 0 in abs 3
17:37:25 <lambdabot>  Parse error
17:37:34 <pweaver> yes yes, sure, but how do I coerce them to the right type?
17:37:43 <dcoutts_> pweaver: so on windows the C lib defines an fd as a HANDLE
17:37:49 <visof>  > let abs x = if x>0 then  x else if x<0  then -1*x  else 0 in abs 4
17:37:59 <pweaver> yes, yes
17:38:23 <dcoutts_> pweaver: so since the Win32 package unhelpfully defines it as a Ptr () we need to convert
17:38:33 <pweaver> yes, thank you, I understand that
17:38:37 <pweaver> I just don't know how to cast it :)
17:38:59 <visof> > let abs x = if x>0 then  x else if x<0  then -1*x  else 0 in abs 4
17:39:01 <lambdabot>  4
17:39:21 <omnId> -1*x = -x
17:39:32 <visof> > let abs x = if x>0 then  x else if x<0  then -1*x  else 0 in abs (4-5)
17:39:33 <lambdabot>  1
17:39:34 <dcoutts_> pweaver: (\handle -> minusPtr handle nullPtr) :: Win32.HANDLE -> GHC.IOBase.FD
17:39:43 <pweaver> ok, thanks
17:39:47 <pweaver> i dunno if this will help though
17:39:58 <pweaver> i've still got a module that I am trying to use, which expectes HANDLEs
17:40:08 <dcoutts_> oh, that's a pain
17:40:14 <pweaver> i'd rather just find a way to peek ahead or use a nonblocking read
17:40:17 <dcoutts_> what actually expects win32 handles ?
17:40:25 <omnId> > let abs x | x < 0 = -x | otherwise = x in abs (-4)
17:40:26 <lambdabot>  4
17:40:35 <pweaver> someone's serial module
17:40:46 <pweaver> really i don't have to use it
17:40:56 <Pseudonym> Serial + Win32 == serious pain.
17:41:01 <pweaver> yes, :)
17:41:09 <pweaver> I have the unix version of this working easily
17:41:14 <Pseudonym> I just thought I'd mention that.  I had to do it a while ago.
17:41:38 <pweaver> what I may do is use an Fd, and a C function to initialize the baudrate and other parameters
17:42:40 <pweaver> oh i spoke too fast... i only know how to do that on unix, on Posix systems :p
17:46:18 <ivanm> @pl \ (a,b) (x,y) -> (a+x,b+y)
17:46:19 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
17:46:28 <ivanm> ^^ surely there's a nicer way of doing this...
17:46:42 <ivanm> i.e. adding two tuples together in a piecewise fashin
17:46:45 <ivanm> *fashion
17:47:17 <glguy> :t join (***) (+)
17:47:20 <lambdabot> forall b. (Num b) => (b, b) -> (b -> b, b -> b)
17:47:35 <glguy> :t ((+) *** (+))
17:47:37 <lambdabot> forall a a1. (Num a, Num a1) => (a, a1) -> (a -> a, a1 -> a1)
17:47:41 <ivanm> thanks, glguy
17:47:45 <ivanm> that's in Arrow?
17:47:49 <glguy> ivanm: that's not it
17:47:57 <ivanm> oh :(
17:48:08 <glguy> look , the types are all wrong :)
17:48:13 <ivanm> heh
17:48:18 <ivanm> I just trusted you, that's all :p
17:48:49 <Pseudonym> There's an operator in graph.
17:48:51 <Pseudonym> ><
17:49:12 * glguy originally read that as Pseudonym cringing
17:49:25 <ivanm> heh
17:49:27 <ivanm> @hoogle ><
17:49:28 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
17:49:38 <Pseudonym> It's somewhere ridiculous, hang on.
17:49:43 <Pseudonym> Right.
17:49:46 <ivanm> ^^ there?
17:50:02 <EvilRanter> @docs Data.Graph.Inductive.Query.Monad
17:50:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Query-Monad.html
17:50:06 <ivanm> hmmm... that looks kinda like it...
17:50:25 <Pseudonym> That should really go somewhere nicer.
17:51:05 <ivanm> with an infix operator like >< that takes 3 args... how do you actually use it?
17:51:24 <EvilRanter> (x ?? y) z
17:51:28 <EvilRanter> or (x ?? y $ z)
17:51:29 <ivanm> ahhh, k
17:51:29 <Pseudonym> Right.
17:51:47 <EvilRanter> think of it as a binary function that returns a function ;)
17:52:04 <ivanm> heh
17:52:05 * allbery_b is contemplating the insanity he's been discussing on -cafe
17:54:10 <Pseudonym> (.) technically takes three arguments, too.
17:54:21 <ivanm> true
17:54:38 <lament> :t (.)
17:54:40 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:55:26 <glguy> > uncurry (***) (join (***) (+) (1,2)) (4,7)
17:55:27 <lambdabot>  (5,9)
17:55:30 <EvilRanter> I normally think of it as (b -> c) -> (a -> b) -> (a -> c), though
17:55:32 <lament> come on, that's clearly (b -> c) -> (a -> b) -> (a -> c) :)
17:55:39 <lament> EvilRanter: you type faster!
17:55:50 <glguy> > let f = uncurry (***) . join (***) (+) in f (1,2) (4,7)
17:55:52 <lambdabot>  (5,9)
17:55:59 <EvilRanter> yeah. i spend far too much of my life chatting on IRC
17:56:02 <ivanm> does Data.Graph.Inductive.Query.Monad come as standard?
17:56:12 <byorgey> aha!  uncurry (***), of course!  I was trying to come up with that =)
17:56:29 <glguy> > let f = uncurry (***) . ((+)***(+)) in f (1,2) (4,7) -- is pretty too ;-p
17:56:29 <ivanm> @type uncurry (***)
17:56:31 <lambdabot>  (5,9)
17:56:31 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
17:57:44 <byorgey> hm, what we need is incomprehensible operators for curry and uncurry!
17:57:53 <ivanm> heh
17:58:09 <SamB> `curry` and `uncurry` aren't incomprehensible enough?
17:58:22 <ivanm> randomR won't create randomised tuples :(
17:58:29 <lament> SamB: at least you can tell one reverses the other!
17:58:40 <ivanm> looks like I have to call randomR twice :(
17:59:09 <SamB> where is that "pot" character when you need it?
17:59:12 <Syzygy-> So we can have (/\) (***) . ((+)***(+)) (1,2) (4,7)
17:59:14 <Syzygy-> :)
17:59:30 * Syzygy- would propose /\ and \/
17:59:36 <byorgey> I like it!
17:59:38 <SamB> I though those were taken
17:59:40 <Syzygy-> except that's probably infeasible for parser reasons.
17:59:43 <Syzygy-> Or that.
17:59:48 <SamB> for, like, conjunction and disjunction
18:00:00 <Syzygy-> Well ... there si that...
18:00:13 <EvilRanter> ?let (\/) = (&&) in (True \/ False, True \/ True)
18:00:14 <lambdabot>  Parse error
18:00:15 <Syzygy-> We need free operad semantics and trees for computer code dammit!
18:00:18 <SamB> I suppose they could be qualified or something
18:00:18 <EvilRanter> > let (\/) = (&&) in (True \/ False, True \/ True)
18:00:19 <n00b> I am trying to implement a oprator using a recursive definition (* multiply, mod and div)
18:00:20 <lambdabot>  (False,True)
18:00:22 <SamB> but that would be ick
18:00:24 <n00b> help me please
18:00:28 <byorgey> > let (\/) = uncurry in ((***) /\).((+)***(+)) (1,2) (4,7)
18:00:29 <lambdabot>   Not in scope: `/\'
18:00:35 <SamB> and I also suppose you could just not use whatever libraries together...
18:00:39 <byorgey> > let (\/) = uncurry in ((***) \/).((+)***(+)) (1,2) (4,7)
18:00:40 <lambdabot>  Couldn't match expected type `t -> a -> (a1 b c, a1 b' c')'
18:00:45 <byorgey> never mind =)
18:00:48 <Syzygy-> byorgey: You would want to use the SAME symbol both times. :)
18:00:59 <byorgey> Syzygy-: pff, details.
18:01:19 <Syzygy-> > let (\/) = uncurry in (((***) \/).((+)***(+))) (1,2) (4,7)
18:01:20 <lambdabot>  (5,9)
18:01:23 <Syzygy-> HAh!
18:01:42 <byorgey> drat, I was missing a $!
18:02:04 <Syzygy-> Ayup.
18:02:12 <byorgey> well, not a $!, a $
18:03:21 <hpaste>  n00b pasted "recusive div" at http://hpaste.org/3316
18:03:28 <n00b> look at that
18:03:41 <n00b> trying to create a recursive div
18:03:46 <n00b> help !!!
18:04:00 <Olathe> > div 25 3
18:04:02 <lambdabot>  8
18:04:09 <Olathe> > (div 25 3) == 0
18:04:11 <lambdabot>  False
18:04:12 <byorgey> n00b: look very carefully at that inequality...
18:04:17 <Olathe> > 25 > 3
18:04:19 <lambdabot>  True
18:05:18 <n00b> yes
18:05:56 <Syzygy-> n00b: What happens if I evaluate div (-2) 4
18:06:11 <lokimaf_> how do i get a random string of bits of a specified length?
18:06:17 <Olathe> n00b: div 25 3 should give 8, right ?
18:06:29 <Olathe> n00b: What happens when your function does that ?
18:06:57 <n00b> you get a negative number
18:07:35 <n00b> yes
18:07:56 <n00b> does what ???
18:08:03 <n00b> you mean compute
18:08:15 <n00b> it divides 25 by 3
18:08:33 <Olathe> This isn't very enjoyable, so I'll stop.
18:08:48 <n00b> ???
18:08:53 <n00b> stop what ???
18:10:20 <n00b> <Olathe> are u helping
18:10:21 <lament> n00b: what does _your_ function do when given div 25 3?
18:10:23 <alexj> @seen dons
18:10:24 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 9m 38s ago.
18:10:49 <EvilRanter> n00b, "three or more punctuation marks is a sure sign of an insane mind"
18:11:17 <EvilRanter> also, no-one uses that <name> thing to address people but you. it's pretty confusing, makes it look like you're quoting that person.
18:11:24 <EvilRanter> and "u" isn't a word
18:11:27 <Olathe> Incorrect pedanticness is a sign of trolling.
18:11:41 <n00b> isn't it calculating how many times 25 can be divided by 3 ???
18:11:54 <lament> n00b: look at the function and see what actually happens.
18:12:07 <Philippa> Olathe: it's also a sign of just being wrong and not knowing it though
18:13:23 <n00b> `div` is how many whole times the first number can be divided by the second number
18:13:31 <n00b> div is how many whole times the first number can be divided by the second number
18:13:44 <lament> n00b: i know what div is _supposed_ to be. Now look at your function and see what it _actually_ does.
18:13:52 <lament> n00b: with "div 25 3"
18:14:53 <n00b> i know my function is incorrect
18:15:03 * EvilRanter tries to work out azoic's quit message
18:15:03 <n00b> I am seeking your guidance to improve it
18:15:18 <EvilRanter> ...could you pronounce "irssi" as "arsey", or something?
18:16:00 <hpaste>  Syzygy- annotated "recusive div" with "Reduced semantic overload" at http://hpaste.org/3316#a1
18:16:01 <lament> n00b: why did you paste that function if you don't even want to look at it yourself?
18:16:02 <Pseudonym> Surely it'd be something French-sounding.
18:16:42 <Syzygy-> Now, n00b, PLEASE read my annotation and think about what it means.
18:17:17 <n00b> ok
18:17:37 <Syzygy-> And at some point also please consider whether this really is the amount of work you can safely expect strangers to just hand you for free.
18:18:29 <lament> you're never safe on the internet!
18:18:33 <MyCatVerbs> EvilRanter: that's how I read it.
18:21:40 <lament> I always read weird abbreviations as if they were something like IPA
18:21:43 <n00b> lament: I am getting a zero
18:21:56 <lament> ie [irssi]
18:22:57 <n00b> seems like there is some kinda error in it
18:23:04 <n00b> gonna try tracing it
18:23:16 <lament> which i guess in the retarded "using english to transcribe sound" notation would be... eers-see?
18:23:54 <Syzygy-> n00b: And here I thought that I had given you a good enough trace to spot the error and correct it.
18:25:21 <n00b> i am doing that
18:26:42 <n00b> Syzygy: Thanks just saw it
18:28:36 <dmwit> Didn't somebody give the correct solution like two hours ago, before I went to take a nap?
18:29:02 <dmwit> Nope, must have been three hours ago.  heh
18:33:52 <hpaste>  n00b annotated "recusive div" with "recusive div" at http://hpaste.org/3316#a2
18:34:10 <n00b> what do you think guys ???
18:35:41 <liyang2> n00b: I'd try something along the lines of binary (long) multiplication in reverse.
18:36:33 <n00b> liyang2: What's that? (remember I am a n00b)
18:37:29 <n00b> Syzygy: What do you think ???
18:37:47 <n00b> Syzygy-: What do you think ???
18:40:36 <liyang> n00b: something like mul a b = case a of { 0 -> 0 ; _ -> case a .&. 1 of { 0 -> 2 * mul (a `shiftR` 1) b ; 1 -> b + 2 * mul (a `shiftR` 1) b } }
18:40:40 <liyang> But in reverse.
18:41:20 * liyang has no idea if that works or not. He can't see the entire line in his IRC window.
18:42:24 <byorgey> n00b: that looks good.  now you should try to make it work with negative numbers.  for example, div (-4) 2 should be -2.
18:44:13 <liyang> (Not quite reverse but there's an equivalent algorithm for division. I'm too sleepy to attempt to implement one live, on IRC, however.)
18:45:57 <lament> maybe you should have an irc window that wraps :)
18:46:06 <Syzygy-> n00b: Does it actually work?
18:46:12 <Syzygy-> First sensible test, y'know...
18:46:39 <Syzygy-> And n00b. Just because I actually did all your troubleshooting for you doesn't entitle you to pull at me for all other stages.
18:46:51 <n00b> yes
18:47:15 <n00b> are you ditching me
18:47:34 <Syzygy-> I'm trying to point out what parts of your behaviour are almost insultingly rude.
18:47:40 <Syzygy-> (03:37) ( n00b) Syzygy: What do you think ???
18:47:40 <Syzygy-> (03:37) ( n00b) Syzygy-: What do you think ???
18:47:44 <Syzygy-> Prime example.
18:47:52 <n00b> cool
18:47:59 <hpaste>  n00b pasted "recusive mod" at http://hpaste.org/3317
18:48:09 <n00b> just look at my recursive mod
18:48:18 <n00b> and tell me what you think
18:48:27 <Pseudonym> It's only a prime example in a unique factorisation domain.
18:49:06 <lament> badum-ts.
18:49:17 <shapr> n00b: Hey, be nice
18:49:37 <shapr> or else
18:49:40 <sorear> ooh, @shapr, that's never a good sign
18:49:44 <lament> @shappr
18:49:44 <lambdabot> Unknown command, try @list
18:49:46 <lament> @shapr
18:49:46 * lambdabot slaps
18:49:48 <Syzygy-> n00b: Looks reasonable. Doesn't handle negatives gracefully.
18:49:53 <dmwit> heh
18:49:58 <Syzygy-> shapr: The @shapr got removed from lb?
18:50:03 <shapr> @get-shapr
18:50:03 <lambdabot> shapr!!
18:50:04 <Syzygy-> Or wait ...
18:50:06 <Syzygy-> That's it.
18:50:08 <Syzygy-> :)=
18:50:08 <shapr> I'm here!
18:50:13 <shapr> Dang, I've recursively called myself!
18:50:14 <dmwit> It worked!
18:50:16 --- mode: shapr set -o shapr
18:50:21 <dmwit> whoa
18:50:35 * Syzygy- pats himself down. Nope, world still here. Didn't vanish in a puff of recursion.
18:50:36 <lambdabot> shapr!!!!!1!eleven!
18:50:44 <shapr> sorear: I was opped days ago when protontorpedo showed up again.
18:50:52 * dmwit makes a note not to call himself while he is a channel operator
18:50:54 <shapr> As rhabbit
18:52:00 <joed> oi.
18:52:11 <dmwit> Hiya, joed!
18:52:18 <joed> dmwit: How goes?
18:52:26 <dmwit> Not too shabby, you?
18:52:47 <joed> Heh, trying to promote some things in a Java Shop :)
18:53:14 <dmwit> Hey, no problem, you can promote me any time! ;-)
18:53:45 <liyang> lament: irssi. Wanting accessibility-from-anywhere prohibits me from using a client with a notion of wrapping text. But that's okay because I don't do most of my coding in irssi.
18:54:06 <lament> sorry? irssi wraps text
18:54:20 <liyang> in what sense? When I enter it?
18:54:32 <liyang> !magic-flag
18:54:38 <liyang> (tell me.)
18:55:11 <lament> the only thing my irssi doesn't wrap is the title.
18:55:18 <lament> i can't read titles when they're longer than ~70 chars.
18:55:37 <lament> but stuff people say takes up more than one line when it's too long to fit in one.
18:55:47 <liyang> I mean, when the text I enter exceeds the available columns, how can I get it to show everything?
18:55:58 <liyang> s/enter/am entering/
18:56:21 <lament> oh, the text you're entering!
18:56:22 <Syzygy-> liyang: You want the place you enter and edit text to wrap too??
18:56:44 <monochrom> Is that why people use many short lines?
18:56:47 <monochrom> Like this?
18:56:50 <liyang> I was complaining that I couldn't see the entire line and may not have been as meticulous wrt checking over my own code.
18:56:55 <monochrom> And their reason is
18:56:57 <monochrom> they yse
18:56:57 <dmwit> IRC is multiplayer Notepad.
18:56:59 <monochrom> use
18:57:03 <monochrom> irssi?
18:57:15 <liyang> dmwit: damn right.
18:57:18 <lament> liyang: right, i misunderstood :(
18:57:36 <joed> monochrom: Yeah. most likely the best IRC client you can find today.
18:57:38 <lament> monochrom:
18:57:39 <lament> yes
18:57:56 <liyang> lament: now you're just taking the piss. ;p
18:58:30 <lament> monochrom: are you using irssi? :)
18:59:06 <monochrom> No. That is why I have no problem merging many short lines into one, proofread it, before pressing enter and echoing internationally.
18:59:28 * liyang grins
18:59:39 <liyang> Life is sometimes, alas, too short. :)
18:59:59 <monochrom> Lines too short, too.
19:00:34 <lament> monochrom: i don't remember seeing _any_ irssi clients with multiline input... are you using ERC or something?
19:00:37 * liyang thwaps monochrom with txtspk
19:00:38 <dmwit> monochrom: s/, proofread it,/ and proofreading it/
19:01:00 <lament> oh wow, i just misspelt IRC as irssi.
19:01:01 <dmwit> ...
19:01:05 <dmwit> and s/it/them/
19:01:17 <lament> "it" works
19:01:33 <dmwit> Ah, yes, it does.
19:01:43 <Syzygy-> lament: Almost as bad as the people who wonder where you hang out on mIRC :P
19:01:50 <monochrom> Actually, I am not using one with multiline input either.
19:02:04 <lament> monochrom: oh, so you lied :)
19:02:24 <lament> Syzygy-: at least that's not the worst type of mislabeling
19:02:38 * liyang is only guessing clients like XChat might let you have multi-line (or at least wrapped) inputs.
19:02:51 <lament> Syzygy-: the worst is the "customer support" kind: "Now click on the picture of a blue E..."
19:02:59 <n00b> I am trying to write a recursive function for multiplication, but I am not sure
19:03:20 <Syzygy-> lament: Hehe.
19:03:28 <liyang> n00b: try the one I posted earlier. I'd like to know if it works.
19:03:41 <_achilles_> @ty [] return
19:03:42 <liyang> (Distributed computing at large!)
19:03:43 <lambdabot>     Couldn't match expected type `(a -> m a) -> t'
19:03:43 <lambdabot>            against inferred type `[a1]'
19:03:48 <n00b> where's the link
19:03:59 <liyang> n00b: er, scrollback...
19:04:16 <dmwit> _achilles_: return :: a -> [a]
19:04:23 <liyang> > let mul a b = case a of { 0 -> 0 ; _ ->  case a .&. 1 of { 0 -> 2 * mul (a `shiftR` 1) b ; 1 -> b + 2  * mul (a `shiftR` 1) b } }
19:04:24 <lambdabot>  Parse error
19:04:37 <liyang> > let mul a b = case a of { 0 -> 0 ; _ ->  case a .&. 1 of { 0 -> 2 * mul (a `shiftR` 1) b ; 1 -> b + 2  * mul (a `shiftR` 1) b } } in mul 3 5
19:04:38 <lambdabot>  Add a type signature
19:04:56 <liyang> > let mul a b = case a of { 0 -> 0 ; _ ->  case a .&. 1 of { 0 -> 2 * mul (a `shiftR` 1) b ; 1 -> b + 2  * mul (a `shiftR` 1) b } } in mul 3 5 :: Int
19:04:58 <lambdabot>  Add a type signature
19:05:17 <monochrom> You'll have to ask ghci for the type error.
19:05:29 <Syzygy-> liyang: Bit-twiddling multiplication eh?
19:05:29 <n00b> looks complicated
19:05:33 <liyang> Grr. Can't be arsed.
19:05:46 <liyang> Syzygy-: it's how I always write multiply. :)
19:05:59 <dmwit> > let mul 0 a = 0; mul b a = a + (b-1) * a in mul 3 5
19:06:00 <lambdabot>  15
19:06:15 <dons> ?seen ndm
19:06:15 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 9h 31m 29s ago, and .
19:06:22 <Syzygy-> dmwit: Recursing to * is cheating.
19:06:25 <dmwit> > let mul x y = length (replicate x () >> replicate y ()) in mul 3 5
19:06:26 <lambdabot>  15
19:06:34 <dmwit> Syzygy-: oops =P
19:06:42 <Syzygy-> > let mul 0 a = 0; mul b a = a + mul (b-1) a in mul 3 5
19:06:43 <lambdabot>  15
19:08:26 <dmwit> > let mul 0 a = 0; mul b a = a + mul a (b-1) in mul 3 5 -- more egalitarian towards argument order =)
19:08:26 <lambdabot>  Unbalanced parenthesis
19:08:28 <liyang> Okay, it worked in principle on addition of a type signature.
19:08:38 <dmwit> > let mul 0 a = 0; mul b a = a + mul a (b-1) in mul 3 5 -- (more egalitarian towards argument order =)
19:08:40 <lambdabot>  15
19:08:50 <liyang> But here's a more readable version without (*):
19:08:54 <liyang> > let mul :: Int -> Int -> Int ; mul a b = case a of { 0 -> 0 ; _ -> let c = mul (a `shiftR` 1) b `shiftL` 1 in case a .&. 1 of { 0 -> c ; 1 -> b + c } } in mul 3 5
19:08:56 <lambdabot>  15
19:10:05 <liyang> log(a) time. Beat *that* you unarists! ;p
19:10:18 <Syzygy-> liyang: Neat.
19:10:19 * smack__ must not understand GNU make
19:10:28 <Syzygy-> Not necessarily the most readable. But neat efficiencywise.
19:10:29 <LoganCapaldo> I demand sub-constant time!
19:10:32 <dmwit> ?slap lambdabot for checking parenthesis matching in quotes and comments
19:10:32 * lambdabot slaps lambdabot for checking parenthesis matching in quotes and comments
19:10:34 <Pseudonym> smack: Nobody does.
19:10:34 <smack__> @paste
19:10:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:10:42 <Syzygy-> LoganCapaldo: Do you want memory restrictions for that?
19:10:58 <LoganCapaldo> heh
19:10:59 <dmwit> Syzygy-: ...sub-constant.
19:10:59 <ddarius> Restrict to 0 bits
19:11:10 <monochrom> "O(1) random access" is a lie.
19:11:18 <Syzygy-> dmwit: Well .... Ok. Use of an oracle?
19:11:23 <LoganCapaldo> there are very many wrong things :)
19:11:31 <dmwit> =)
19:12:16 <liyang> Syzygy-: it's how I teach multiplication. :)
19:12:22 <Syzygy-> What? You mean there are limits to what memory/speed tradeoffs can do? And here I had a grand master plan to stop WW2 using a negative complexity multiplication algorithm for information transfer!!
19:12:33 <Syzygy-> liyang: What level do you teach? And what subject?
19:12:39 <liyang> (to first year students doing processor architecture. Sadly.)
19:12:46 <Syzygy-> Hehe
19:12:55 <liyang> Syzygy-: I'm still (forever :() a student.
19:13:00 <jcreigh> monochrom: you mean in the sense that doing memory access outside the CPU cache will take longer?
19:13:04 <Pseudonym> For extra credit, invert the FFT algorithm for multiplication.
19:13:20 <monochrom> jcreigh: that's one factor. there are others.
19:13:22 <solrize> is haxml the right lib to use if i want to crunch some xml files around?
19:13:41 <Syzygy-> Pseudonym: That would be an awesome coprocessor. That uses acoustical FFT and FFT inversion for basic arithmetic.
19:13:42 <jcreigh> monochrom: oh? other factors? what are they?
19:14:12 <ddarius> Syzygy-: WW2 seems pretty stopped.
19:14:31 <Syzygy-> ddarius: Pre-war stopping.
19:14:35 <Syzygy-> Sorry.
19:14:36 <Syzygy-> Prevent.
19:14:51 <Pseudonym> Syzygy: Well, op-amps are named because they form operations in analog computers.
19:15:02 <Syzygy-> :)
19:15:16 * ddarius hugs op-amps.
19:15:21 <liyang> And functional programming languages are so named becuase they're not dysfunctional.
19:16:11 * ddarius hugs feedback loops.
19:16:24 <nornagon> i need to learn more electronics
19:16:35 <nornagon> hopefully in the course i'll be doing it'll be impossible not to
19:16:53 <ddarius> Analog electronics is fun.  Digital is mostly just very tedious programming.
19:16:55 * liyang is getting back to some electronics at the cost of his PhD completion. ;_;
19:17:23 <dmwit> :t liftM2
19:17:25 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:17:37 <lament> analog electronics is so amazingly counterintuitive
19:17:46 <lament> i just can't get it at all
19:17:48 <liyang> ddarius: snap! I stopped being interested in electronics after every project published in EPE seemed to consist of a damn PIC.
19:18:15 <ddarius> lament: The secret is to learn signal processing.
19:18:15 <lament> if somebody knows a way to make it intuitive, please share :)
19:18:25 <dmwit> :t liftM2 :: (a -> b -> r) -> (r -> a) -> (r -> b) -> (r -> r) -- did I get this right?
19:18:27 <lambdabot> (a -> b -> r) -> (r -> a) -> (r -> b) -> (r -> r) :: forall a b r. (a -> b -> r) -> (r -> a) -> (r -> b) -> r -> r
19:18:46 <lament> ddarius: is that fourier and friends?
19:19:02 <ddarius> lament: Yes, though there's quite a bit more to it.
19:19:09 <Olathe> > let divMod :: (Bits a, Ord a) => a -> a -> (a, a); divMod a b = if (a < b) then (0, a) else (let (q, r) = join (***) (`shiftL` 1) (divMod (shiftR a 1) b); r' = r .|. (a .&. 1) in if (r' < b) then (q, r') else ((q .|. 1), r' - b)) in divMod 252834 11
19:19:10 <lambdabot>  (22984,10)
19:19:20 <lament> ddarius: how's that relevant, to, say, a basic radio receiver?
19:19:22 <Olathe> Doesn't quite work for negative numbers, though.
19:19:28 <liyang> Olathe: bloody hell.
19:19:45 <Olathe> liyang: ;)
19:19:56 * liyang scratches his eyes out 
19:20:00 <Olathe> Heheh
19:20:00 <lament> Olathe: maybe you should @pl that.
19:20:10 <Olathe> @pl dies on if
19:20:10 <lambdabot> (line 1, column 9):
19:20:10 <lambdabot> unexpected reserved word "if" or "i"
19:20:10 <lambdabot> expecting variable, "(", operator or end of input
19:20:17 <Olathe> It gives if'
19:20:19 <LoganCapaldo> see
19:20:23 <ddarius> lament: You need to understand, e.g. heterodyning which is clear if you understand the frequency domain and the convolution theorem.
19:20:27 <Pseudonym> A basic radio receiver is, like, a coil and a diode.
19:20:35 <LoganCapaldo> this si why we need bool
19:21:19 <LoganCapaldo> got maybe and either why not bool?
19:21:20 <liyang> (SDR FTW!)
19:21:26 <ddarius> lament: Analog electronics is mostly signal processing-esque.  Another example, it's easiest to just think of a capacitor as a high-pass filter.
19:21:57 * liyang ponders the signature of join (***)
19:21:57 <lament> ddarius: that certainly makes more sense than the way it's normally presented
19:22:13 <Pseudonym> capacitor == spring, inductor == mass, resistor == damping
19:22:38 <lament> Pseudonym: right, exactly, that's NOT the way i want to look at it :)
19:22:41 <Pseudonym> :-)
19:22:42 <Olathe> @pl \(q, r) -> (q, r .|. (a .&. 1))
19:22:42 <lambdabot> second (.|. (a .&. 1))
19:22:46 <ddarius> Pseudonym: Indeed, but to understand the mechanical systems is probably easiest via the Laplace transform so...
19:22:46 <reffie> so dons works at galois?
19:22:48 <sorear> Everything describable with first-order linear ODEs is basically the same.
19:22:55 <monochrom> Suppose you have n bytes of RAM. The circuitry to pick out one byte you want by the address you give is at least Theta(log n) deep, meaning turn around time is also Theta(log n). They cheat by saying n=4TB, therefore Theta(log 4TB) = Theta(1).
19:22:57 <LoganCapaldo> arg stop wth the physics. you guys are gonna me nightmares
19:23:08 <Olathe> @pl (second (.|. (a .&. 1)) join (***) (`shiftL` 1) (divMod (shiftR a 1) b)
19:23:08 <lambdabot> (line 1, column 72):
19:23:08 <lambdabot> unexpected end of input
19:23:08 <lambdabot> expecting variable, "(", operator or ")"
19:23:15 <Olathe> @pl (second (.|. (a .&. 1))) join (***) (`shiftL` 1) (divMod (shiftR a 1) b)
19:23:15 <lambdabot> second (.|. (a .&. 1)) join (***) (`shiftL` 1) (divMod (shiftR a 1) b)
19:23:17 <omnId> liyang: join (f :: a -> a -> b) :: a -> b
19:23:31 <lament> ddarius: i've just never seen anything on (basic) electronics that explains stuff in that manner.
19:23:34 <ddarius> sorear: There is some cleverness in e.g. seeing how a diode leads to heterodyning (as a diode is a non-linear element)
19:23:45 <Olathe> > let divMod :: (Bits a, Ord a) => a -> a -> (a, a); divMod a b = if (a < b) then (0, a) else (let (q, r) = second (.|. (a .&. 1)) join (***) (`shiftL` 1) (divMod (shiftR a 1) b) in if (r < b) then (q, r) else ((q .|. 1), r - b)) in divMod 252834 11
19:23:46 <lambdabot>  Couldn't match expected type `m (m a) -> m a'
19:23:49 <Olathe> Bah.
19:23:59 <ddarius> sorear: But yes, you are more or less right.
19:24:00 <liyang> omnId: it's actually more general than that, but yeah. I'll have to figure out a way to work that into my programs.
19:24:17 <omnId> liyang: that's join for m = (->) a
19:24:23 <solrize> lament, you don't like horowitz & hill?
19:24:35 <Olathe> @pl ((second (.|. (a .&. 1))) . (join (***) (`shiftL` 1))) (divMod (shiftR a 1) b)
19:24:35 <lambdabot> second (.|. (a .&. 1)) (join (***) (`shiftL` 1) (divMod (shiftR a 1) b))
19:24:47 <lament> haven't seen it
19:24:52 <Olathe> > let divMod :: (Bits a, Ord a) => a -> a -> (a, a); divMod a b = if (a < b) then (0, a) else (let (q, r) = second (.|. (a .&. 1)) (join (***) (`shiftL` 1) (divMod (shiftR a 1) b)) in if (r < b) then (q, r) else ((q .|. 1), r - b)) in divMod 252834 11
19:24:54 <lambdabot>  (22984,10)
19:24:57 <nornagon> O_o
19:25:00 <omnId> @src join
19:25:00 <lambdabot> join x =  x >>= id
19:25:02 <solrize> oh wait i didn't see the context.  it's a really good electronics text but not the way ddarius described it
19:25:06 <omnId> @src (->) (>>=)
19:25:07 <lambdabot> f >>= k = \ r -> k (f r) r
19:25:25 <omnId> f >>= id = \r -> id (f r) r = \r -> f r r
19:25:40 <Olathe> There we go, nicely pled without if'
19:25:41 <nornagon> @djinn (r -> (r -> a)) -> r -> a
19:25:41 <lambdabot> f a b = a b b
19:26:02 <lament> ddarius: so basically you suggest thinking about everything in the frequency domain?
19:26:10 <ddarius> lament: No.
19:26:21 <ddarius> lament: Signal processing doesn't just use the frequency domain.
19:26:22 * monochrom <3 Laplace transform, time-frequency duality, complex numbers... who needs trig identities? :)
19:26:23 <Olathe> @pl \a b -> if (a < b) then (0, a) else (let (q, r) = second (.|. (a .&. 1)) (join (***) (`shiftL` 1) (divMod (shiftR a 1) b)) in if (r < b) then (q, r) else ((q .|. 1), r - b))
19:26:24 <lambdabot> (line 1, column 42):
19:26:24 <lambdabot> unexpected "("
19:26:24 <lambdabot> expecting natural, identifier or "in"
19:27:19 * liyang thinks the important concept is, as monochrom mentioned, duality.
19:27:20 <monochrom> think about everything in both the time domain and the frequency domain. more complete picture.
19:27:21 <omnId> join (***) f = (\r -> (***) r r) f = (***) f f = f *** f
19:27:23 <ddarius> lament: However, you do want to readily be able to work with transfer functions which also leads to control theory (parts of) which is(/are) extremely important for understanding feedback.
19:27:59 <ddarius> liyang, monochrom: The convolution theorem.
19:28:28 <liyang> ddarius: ignore me. I'm just commenting from the sidelines.
19:28:40 <monochrom> convolution in one domain is multiplication in the other. <3 <3 <3
19:28:49 <ddarius> Yep.  That's the linchpin.
19:29:05 <lament> ddarius: i want stuff to be intuitive. That means no math. :)
19:29:17 <liyang> (and was intending to read some papers but you pesky kids are putting a stop to that!)
19:29:19 <LoganCapaldo> lynchpin?
19:29:25 <LoganCapaldo> @spell linchpin
19:29:30 <Pseudonym> ?wn lynchpin
19:29:32 <lambdabot> *** "lynchpin" wn "WordNet (r) 2.0"
19:29:32 <lambdabot> lynchpin
19:29:32 <lambdabot>      n 1: a central cohesive source of support and stability; "faith
19:29:32 <lambdabot>           is his anchor"; "the keystone of campaign reform was the
19:29:32 <lambdabot>           ban on soft money"; "he is the linchpin of this firm"
19:29:34 <lambdabot>           [syn: {anchor}, {mainstay}, {keystone}, {backbone}, {linchpin}]
19:29:36 <lambdabot>      2: pin inserted through an axletree to hold a wheel on [syn: {linchpin}]
19:29:43 <Pseudonym> ?wn linchpin
19:29:43 <monochrom> Are you the master of your intuition?
19:29:43 <lament> "capacitors are like high-pass filters" is intuitive
19:29:44 <lambdabot> *** "linchpin" wn "WordNet (r) 2.0"
19:29:44 <lambdabot> linchpin
19:29:44 <lambdabot>      n 1: a central cohesive source of support and stability; "faith
19:29:44 <lambdabot>           is his anchor"; "the keystone of campaign reform was the
19:29:46 <lambdabot>           ban on soft money"; "he is the linchpin of this firm"
19:29:48 <lambdabot>           [syn: {anchor}, {mainstay}, {keystone}, {backbone}, {lynchpin}]
19:29:50 <lambdabot>      2: pin inserted through an axletree to hold a wheel on [syn: {lynchpin}]
19:29:52 <LoganCapaldo> heh
19:29:55 <iank> ?wn holy channel flood, batman
19:30:00 <LoganCapaldo> that answers that question :)
19:30:00 <lambdabot> *** "holy" wn "WordNet (r) 2.0"
19:30:00 <lambdabot> holy
19:30:00 <lambdabot>      adj : belonging to or derived from or associated with a divine
19:30:00 <lambdabot>            power [ant: {unholy}]
19:30:00 <lambdabot>      n : a sacred place of pilgrimage [syn: {holy place}, {sanctum}]
19:30:01 <shapr> yarr
19:30:02 <lambdabot> [76 @more lines]
19:30:03 <Pseudonym> Yeah, they're _like_ high-pass filters.
19:30:13 <SamB_XP_> I thought a linchpin was something you removed to dump your enemies into the drink or canyon
19:30:14 <Pseudonym> Except that in general, you need somewhere for the extra voltage to go.
19:30:19 <monochrom> http://www.vex.net/~trebla/weblog/intuitive.html
19:30:21 <lambdabot> Title: What Is Intuitive?
19:30:27 <Pseudonym> This is something that gets me about electronics that doesn't happen in software.
19:30:31 <SamB_XP_> or at least prevent them from reaching your fortress easily
19:30:40 <Pseudonym> You need places to dump the stuff you don't want.
19:30:46 <Pseudonym> And you have to deal with fanout and stuff.
19:30:50 <lament> Pseudonym: you're the guy who was just talking about masses and springs. I'm not listening to you. :)
19:31:01 <Pseudonym> Hey, it helped me.
19:31:15 <lament> it didn't help me at all :( It's what I had in phys 101 or whatever that was
19:31:35 <monochrom> I think everything is intuitive. :)
19:31:39 <lament> turning a very simple scheme into a system of strange-looking differential equations is totally not the way to make people understand it
19:31:49 <SamB_XP_> lament: didn't you have capacitors in physics II?
19:31:55 <lament> s/scheme/circuit
19:32:05 <lament> SamB_XP_: yes
19:32:09 <Pseudonym> Strange-looking differential equations _is_ analog electronics.
19:32:24 <ddarius> lament: It would be very difficult to -understand- things like feedback or what a diode is doing in a heterodyne without understanding the math.
19:32:31 <monochrom> OK, not absolutely everything. But everything reproducible again and again in the lab or in reality is intuitive. Look, it happens right in front of you, it is real experience, how can it not be intuitive?
19:32:32 <liyang> Olathe: I need to become more familiar with Arrows; i.e. more than just *** and &&&.
19:32:48 <ddarius> lament: Also this is part of a beautiful hub of math that touches every field of pure and applied math.
19:32:55 <Olathe> I just used @pl to get it.
19:33:05 <liyang> Olathe: :p
19:33:07 <Olathe> @pl \(a, b) -> (f a, f b)
19:33:07 <lambdabot> f *** f
19:33:22 <Olathe> @pl \f -> f *** f
19:33:23 <lambdabot> join (***)
19:33:34 <Olathe> Hmm...
19:33:39 <Olathe> @pl \f (a, b) -> (f a, f b)
19:33:39 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
19:33:42 <ddarius> The good news is the math looks scarier than it actually is.
19:33:44 <dmwit> ?src Arrow
19:33:44 <lambdabot> class Arrow a where
19:33:44 <Olathe> O-o
19:33:44 <lambdabot>     arr, pure   :: (b -> c) -> a b c
19:33:44 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
19:33:44 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
19:33:44 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
19:33:45 * liyang becomes less impressed. But still impressed to an extent. :p
19:33:46 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
19:33:47 <lament> ddarius: i suppose i agree with monochrom. I think most things are intuitive. Circuits are simple beasts and clearly should be understandable without the math.
19:33:48 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
19:33:51 <Olathe> That's horrid.
19:34:10 <monochrom> differential equations are continuous-time recursion.
19:34:17 <nornagon> @pl \f -> \(a,b) -> (f a, f b))
19:34:17 <lambdabot> (line 1, column 27):
19:34:17 <lambdabot> unexpected ")"
19:34:17 <lambdabot> expecting variable, "(", operator or end of input
19:34:18 <SamB_XP_> lament: hmm. differential equations don't help you understand stuff?
19:34:21 <nornagon> er.
19:34:21 <Olathe> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .)) -vs- join (***) f
19:34:26 <nornagon> @pl \f -> \(a,b) -> (f a, f b)
19:34:26 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
19:34:31 <nornagon> rats.
19:34:38 <lament> SamB_XP_: i keep saying "intuitive" and people keep not noticing it. I'm pretty sure I'm using the word correctly.
19:34:39 <dmwit> :t join (&&&)
19:34:41 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
19:34:59 <nornagon> @djinn (b -> c) -> (b -> (c,c))
19:34:59 <lambdabot> f a b = (a b, a b)
19:35:10 <monochrom> What is intuitive? And I again cite my url http://www.vex.net/~trebla/weblog/intuitive.html
19:35:11 <lambdabot> Title: What Is Intuitive?
19:35:20 <solrize> lament is there something unintuitive about strange-looking differential equation systems?  :)
19:35:53 <lament> solrize: this is irrelevant. I want electronics to be intuitive, not differential equation systems.
19:36:14 <SamB_XP_> lament: maybe I think differential equations are intuitive ;-)
19:36:19 <ddarius> lament: Why are most things intuitive but math not?
19:36:23 <SamB_XP_> maybe that's why I'm majoring in EE
19:36:25 <lament> SamB_XP_: this is irrelevant. I want electronics to be intuitive, not differential equation systems.
19:36:39 <liyang> once you get past the psychological barrier of ODEs, everything becomes intuitive.
19:36:47 <monochrom> A small circuit can be understood with or without math.
19:36:48 <liyang> (Mostly.)
19:36:52 <solrize> i guess i don't understand, once ODE's are intuitive then explaining electronics in terms of them is natural
19:36:53 <lament> SamB_XP_: i don't need to think about advanced linguistics to speak English.
19:37:08 <solrize> hirsch & smale is the best book i know for making ODE's intuitive
19:37:09 <raxas> lament: circuits are only an abstraction. not a real thing. real universe is quite different, it does electricity in fractalous, recursive functional way
19:37:23 <liyang> lament: but it helps with advanced usage. Or wordplay.
19:37:25 <monochrom> Actually, from small circuits, you understand what's going on, and you summarize that with math.
19:37:28 <SamB_XP_> lament: might explain why we haven't covered anything like that in circuits yet
19:37:45 <SamB_XP_> we haven't gotten to capacitators yet anyway
19:37:52 <lament> raxas: the real universe is pretty fucked up, but when people throw stuff at me, i can usually catch it, without solving equations of motion
19:37:57 <monochrom> Then the math may tell you alot about larger circuits. "Let the symbols do the work" and all that.
19:37:58 <solrize> i don't know how to explain even something like an RC time constant except with a DE
19:38:08 <dmwit> 21 JIGAWATTS!  WHAT WAS I THINKING
19:38:13 <Philippa> lament: your body has hardwired approximations, so?
19:38:13 <SamB_XP_> lament: can you now?
19:38:18 <dmwit> Overload the flux capacitors!
19:38:23 <liyang> I mean, knowing *basic* linguistics certainly changed the way I write / analyse my and others' writings.
19:38:24 <chessguy> @yow
19:38:25 <lambdabot> Finally, Zippy drives his 1958 RAMBLER METROPOLITAN into the faculty
19:38:25 <lambdabot> dining room.
19:39:04 <dmwit> So, is ?yow just a computerized version of mad libs, or what?
19:39:11 <Olathe> @yow
19:39:11 <lambdabot> Th' MIND is the Pizza Palace of th' SOUL
19:39:16 <omnId> @google zippy the pinhead
19:39:16 <ddarius> @help yow
19:39:20 <lambdabot> http://www.zippythepinhead.com/
19:39:20 <lambdabot> Title: Zippy the Pinhead
19:39:20 <lambdabot> yow. The zippy man.
19:39:34 <ddarius> Possibly the worst comic ever.
19:39:35 <Tac-Tics> Haskell is the measurement of coolness in computer science
19:39:36 <Olathe> I think it's not, since I've never seen the same pattern with different words filled in.
19:39:41 * ddarius has certainly seen no contenders.
19:39:42 <SamB_XP_> my circuits teacher says "trust the math. there isn't anything to see in electrical engineering except the math." or something like that
19:40:09 <ddarius> SamB_XP_: You certainly don't want to trust the math too far.
19:40:10 <ddarius> ..
19:40:19 <SamB_XP_> ddarius: true
19:40:20 <monochrom> If the circuit is large enough, you will see nothing anyway.
19:40:26 * liyang wouldn't trust linguistics to pick up on subtle emotional cues, however. Or at least what he knows of linguistics.
19:40:27 <omnId> @brain Are you pondering what I'm pondering?
19:40:27 <lambdabot> Well, I think so, Brain, but do I really need two tongues?
19:40:39 <omnId> ^ superior to @yow
19:40:42 <SamB_XP_> monochrom: what is this I see on my CRT
19:40:46 <monochrom> My intuition goes blank when the circuit has more than 5 components. I will need math.
19:41:14 <monochrom> Your intuition may work well up to 1000 components. Good for you. You will have your breakdown point higher up.
19:41:17 <Philippa> liyang: I don't know how much study of connotation's been done
19:41:27 <monochrom> "Let the symbol do the work."
19:41:50 * SamB_XP_ was making a joke about his CPU or something
19:41:51 <dmwit> Wow, this *is* kind of like reading ?yow all day.
19:41:58 <liyang> Human emotions are beyond analysis!
19:42:05 <monochrom> Your ego is the only justification for insisting on your personal intuition. You want to prove you exceed math. You want to prove you never fail.
19:42:07 <Philippa> it's probably possible to put together a model, it'll have to be parameterised somewhat on what connotations people have for each word though
19:42:19 <Philippa> liyang: that's a strong statement, philosophically speaking
19:42:21 <dmwit> Griffy!  I think I just spotted JOHN UPDIKE in an art museum in BOSTON -- he wore PENNY LOAFERS!
19:42:49 <SamB_XP_> Philippa: and what connotations people believe others to have for each word ;-)
19:43:03 <Philippa> a lot of people find you can do surprisingly well if you're careful about your assumptions, too - you get unknowns, sure
19:43:04 <ddarius> monochrom: Clearly he need prove nothing.  He's beyond math.
19:43:12 <monochrom> Oh hehehe.
19:43:28 <dmwit> ?keal beyond math
19:43:29 <lambdabot> i try make program called Glyph to do it but my script lang called T too slow. i invent T
19:43:36 <lament> I have no idea what you guys are talking about
19:43:49 <lament> (re intuition, not re zippy)
19:43:57 <ddarius> I'm just playing on monochrom's statement.
19:44:08 <Philippa> SamB_XP_: that's not necessarily relevant for the purpose
19:44:11 <SamB_XP_> lament: we are secretly communicating circuit diagrams based on the distance between the whitespace in our texts
19:44:17 <monochrom> And I'm poking at the true, dark nature of intuition.
19:44:20 <ddarius> My personal beliefs are that having both intuition -and- formal manipulations down is -crucial-.
19:44:31 <lament> ddarius: yes, that's what i think too.
19:44:48 <SamB_XP_> hmm. probably it will be...
19:44:53 <ddarius> lament: It sounds very much like you don't want any math.
19:45:24 <liyang> Philippa: I'm intentionally being outspoken in my assertions. ;p
19:45:48 <ddarius> liyang is beyond analysis!
19:45:50 <lament> ddarius: for very simple circuits, yes.
19:46:25 <lament> ddarius: DEs seem an inappropriate tool for analyzing, well, a very simple picture with a few numbers on it.
19:46:26 <SamB_XP_> liyang: who is outspeaking you?
19:46:35 <ddarius> lament: It's important to build a bridge between your intuitions and the math.
19:46:48 <liyang> ddarius: analysis is beyond me!
19:46:56 <liyang> (at least when I took the course.)
19:46:56 <lament> ddarius: but i have no intuition :(
19:47:09 <SamB_XP_> liyang: how was calculus?
19:47:26 <monochrom> How do you gain intuition? Practice. Or brainwashing.
19:47:28 <ddarius> lament: Using math you can import them.
19:47:38 <liyang> SamB_XP_: just fine. I had somewhat of a head start back at school.
19:47:57 <SamB_XP_> I wonder if I'll ever get to take analysis
19:48:05 <Tac-Tics> Analysis is neat
19:48:11 <liyang> SamB_XP_: (by which I'm presuming you mean the differential. If we're going to be pedantic. :)
19:48:18 <Philippa> monochrom: (good) analogy helps, too
19:48:38 <ddarius> lament: E.g. the equation for a tank circuit is exactly the same as the one for rotational motion.
19:48:51 * liyang can cope with, and in fact, rather liked some of the other calculi he's come across.
19:49:19 * ddarius is not a big fan of calculus, but he's going to the dentist Wednesday.
19:49:31 <SamB_XP_> liyang: differential/integral
19:49:37 <monochrom> hahahaha
19:50:06 <SamB_XP_> ddarius: ... what does that have to do with the dentist?
19:50:10 <solrize> does anyone here use haxml?
19:50:12 <ddarius> @wn calculus
19:50:14 <lambdabot> *** "calculus" wn "WordNet (r) 2.0"
19:50:14 <lambdabot> calculus
19:50:14 <lambdabot>      n 1: a hard lump produced by the concretion of mineral salts;
19:50:14 <lambdabot>           found in hollow organs or ducts of the body; "renal
19:50:14 <lambdabot>           calculi can be very painful" [syn: {concretion}]
19:50:16 <lambdabot> [6 @more lines]
19:50:31 <SamB_XP_> I don't think the dentist removes calculi
19:50:47 <monochrom> The dentist uses your mouth for computing. That is why dentists ask people to visit periodically. Their true agenda is to use your mouths for computing.
19:50:57 <SamB_XP_> monochrom: yeah right
19:51:45 <liyang> SamB_XP_: touche.
19:51:53 <monochrom> Here is how your mouth is a computer. Well at least it is a register. Each tooth gap contains a calculus and serves as one bit of memory. Move the calculus up, and you get 1; move it down, and you get 0.
19:52:25 <monochrom> It is the way our ancestor did it anyway! Well on sand not in your mouth.
19:54:40 <monochrom> I should hack into WordNet and modify stuff. Imagine....
19:54:53 <monochrom> "lambda calculi can be very painful"  XD
19:58:11 <monochrom> Is Haskell intuitive? Discuss.
19:58:51 <SamB_XP_> my mom doesn't think teeth count as calculi...
19:59:04 <ddarius> Teeth aren't calculi.
19:59:19 <monochrom> The stones between teeth.
19:59:24 <SamB_XP_> the what?
19:59:44 <monochrom> calcium compounds
20:00:05 <reilly> any type family and GADT wizards around?
20:00:14 <monochrom> stuff that irritates your gum and causes gum to bleed and slowly retreat
20:00:44 <SamB_XP_> hmm, braces irritate gums and make them advance!
20:06:59 <monochrom> Cogito ergo foldl (+) 0.
20:07:21 <dons> things you only see in #haskell
20:07:27 <jcreigh> "I think, therefore I sum"?
20:07:37 <swix> almost
20:07:41 <ChilliX> reilly: What do you want to know?
20:07:43 <swix> Cogito ergo sum...
20:07:49 <dons> "I think, therefore I use higher order functions" :)
20:08:04 <Pseudonym> I think, therefore I don't use Java.
20:08:22 <dons> reilly: yeah, ChilliX knows a little about type families. Ask away!
20:08:39 <reilly> so, i'm trying to use type families to create a function over types that I will use in defining the type signature of a function
20:08:56 <monochrom> hahahaha
20:09:41 <reilly> the function takes two arguments, the type of the second function is the "opposite" of the first
20:09:59 <dons> reilly: perhaps use hpaste.org to illustrate the code?
20:10:00 <reilly> let me hpaste my code ... gimme a second
20:10:07 <ChilliX> reilly: opposite?
20:10:19 <reilly> Buy and Sell
20:10:32 <reilly> or Odd and Even if you want to be more abstract
20:10:38 <ChilliX> yeah, concrete code would be best
20:11:21 <ChilliX> reilly: one function is the inverse of the other?
20:11:39 <reilly> no, one argument is the opposite of the other
20:11:41 <reilly> give me a sec
20:11:44 <ChilliX> ok
20:13:43 <hpaste>  (anonymous) pasted "Type Funs" at http://hpaste.org/3318
20:13:52 <reilly> that was me
20:14:18 <dons> we need syntax highlighting for the keyword `family' :)
20:14:26 <ChilliX> dons: yes!
20:14:39 <ChilliX> reilly: the problem is that your family declaration is non-terminating
20:14:49 <reilly> there's only one pattern for "cross", the other pattern reverses
20:14:55 <ChilliX> type-level functions like their value-level counterparts need to be terminating
20:15:01 <alexj> dons: any insight on how fast a code reload should be if you have a lot of stuff in memory state?
20:15:06 <reilly> how is it not terminating?
20:15:16 <ChilliX> oops, sorry
20:15:17 <dons> alexj: depends on how you serialise the state
20:15:20 <ChilliX> I mis-read
20:15:30 <dons> alexj: we just held on to a Ptr in yi, so it was 0.01s, iirc
20:15:42 <dons> but if you have to walk the state at all, that adds cost
20:15:58 <dons> actually reloading the code is pretty quick, just a mmap and some symbol relocations
20:16:07 <reilly> you can cross a buy with a Sell or a Sell with a Buy, but crossing a Sell with a Sell or a Buy with a Buy is broken
20:16:13 <alexj> if you have to walk any state then do you have to walk all of it?
20:16:33 <reilly> the pattern for crossing a Sell with a Buy is not in that snippet, but it fails with it there
20:16:36 <alexj> suppose you add a field to the state type that starts out empty.  but the rest is a large IxSet?
20:17:04 <reilly> I've tried it with both GADTs and without
20:18:05 <reilly> interestingly, if I define cross trivially (cross x y = 3), then it compiles
20:18:12 <ChilliX> reilly: you mean, you get an error if you have equations for both cases of cross?
20:18:44 <reilly> no, i get an error if I have any pattern matching case for cross
20:19:21 <reilly> but i assume that's because i'm doing something wrong elsewhere
20:19:35 <dons> alexj: are you writing state to disk, or just passing it in as an argument to your program unmodified?
20:20:11 <reilly> i know not to expect a directly understandable error message from ghc with this
20:20:11 <alexj> not sure.
20:20:28 <alexj> dons: would love to be able to have code reloads be really fast.
20:20:31 <ChilliX> reilly: I think you *should* expect an understandable error messafge
20:20:41 <ChilliX> then, it is on us to provide one ;)
20:21:07 <reilly> well, i would like one, but i know that type families and GADTs are bleeding edge
20:21:34 <reilly> my expectation for type families is that I get a usable function over types
20:21:35 <dons> alexj: it can certainly be done. there's no serious issues i know of, as long as you're not, say, uncompressing and recompressing on each reload, or writing to disk
20:21:48 <dons> if you're just throwing the state into the newly reloaded code, should be cost free
20:22:08 <alexj> cool!
20:22:14 <ChilliX> reilly: so, one problem with the pasted code is that the data constructors Buy and Sell are nullary, but you use them with on argument
20:22:29 <ChilliX> in the non-GADT version
20:22:46 <ChilliX> should it be   data Buy = Buy Int   ?
20:22:55 <reilly> oh, that's an artifact of me going back and forth between two approaches
20:23:14 <ChilliX> that's ok, I just want to figure out what your intention is
20:23:25 <reilly> letme make it clearer
20:26:40 <hpaste>  ChilliX annotated "Type Funs" with "Is this what you meant to write?" at http://hpaste.org/3318#a1
20:27:59 <dons> ChilliX: you should blog some paragraphs illustrating how to state nice little properties in types with the new type family stuff
20:28:19 <dons> if you've got material lying around left over from lectures, or some such :)
20:28:24 <ChilliX> reilly: have a look at my corrected version - I guess this is what you had in mind
20:28:29 <reilly> ok
20:29:00 <ChilliX> dons: rl is currently writing up his "GHC's type checker as a substitute for Twelf" paper...
20:29:18 <ChilliX> reilly: it gives an error like this, mind you
20:29:29 <ChilliX> but I think, it is what you had in mind
20:29:35 <dons> yeah, he mentioned. that sounds lots of fun
20:29:59 <dons> papers capture a different audience to blogs though :)
20:30:06 <dons> we just need to get rl a blog!
20:30:28 <ChilliX> yeah :)
20:31:00 <dons> i'd love to read rl's thoughts on software and hacking in the morning with my coffee.
20:31:11 <dons> he's very amusing
20:31:15 <reilly> i did try that ... doesn't compile
20:31:24 <reilly>     Couldn't match expected type `x' against inferred type `Buy'
20:31:24 <reilly>       `x' is a rigid type variable bound by
20:31:24 <reilly> 	  the type signature for `cross' at g2.hs:30:15
20:31:25 <reilly>       Expected type: Order x
20:31:25 <reilly>       Inferred type: Order Buy
20:31:25 <reilly>     In the pattern: (Order Buy x) :: Order Buy
20:31:27 <reilly>     In the definition of `cross':
20:31:29 <reilly> 	cross ((Order Buy x) :: Order Buy) ((Order Sell y) :: Order Sell)
20:31:31 <reilly> 		= min x y
20:31:35 <reilly> oops, sorry
20:32:14 <ChilliX> reilly: yeah, that's what I said, it doesn't compile.  And it shouldn't.  The equation is too specific for the signature.
20:32:29 <ChilliX> That's were you wanted to use the GADT, I guess.
20:32:35 <reilly> yeah
20:32:40 <reilly> and that fails too
20:33:22 <ChilliX> yeah, but in contrast to the version with vanilla data types, I think the GADT version shouldn't fail ;)
20:33:44 <reilly> the error you noticed was an artifact of switching back and forth between the two approaches ... i actually tested what you suggested
20:33:51 <reilly> before
20:34:43 <ChilliX> ok, fair enough
20:35:16 <reilly> I see cross as having two patterns, which exhaust the pattern space ..  cross Buy Sell and cross Sell Buy
20:35:42 <reilly> and the type signature as excluding cross Sell Sell and Cross Buy Buy
20:36:01 <hpaste>  ChilliX annotated "Type Funs" with "This works!" at http://hpaste.org/3318#a2
20:36:33 <ChilliX> Basically, you tripped over a problem in the ineteraction between GADTs and type families.
20:36:40 <reilly> cool.  Why does it work?
20:36:43 <dons> cool
20:36:56 <ChilliX> The short story is that there is an old way of type checking GADTS, which I will rip out of GHC very soon.
20:37:00 <reilly> did I exercise a bug?
20:37:21 <kilimanjaro> On the Haskell Wiki I see "When using a type declaration, the type synonym and its base type are interchangeble almost everywhere (There are some restrictions when dealing with instance declarations).". Can somebody please elaborate on this? I'm just an amateur :)
20:37:32 <kilimanjaro> In particular, what sort of restrictions
20:37:52 <ChilliX> But to rip it out, I have to fix some type family bugs first.  After that's done, the interaction will work fine and the code with your original GADT def will work (you don't have to use the explicit equality context with the ~)
20:38:34 <ChilliX> reilly: as a workaround for the moment, use the GADT definition with the ~ context
20:38:49 <ChilliX> sorry about that
20:38:52 <reilly> ok, what does that do, exactly?
20:39:06 <ChilliX> It is the exact same thing, just with a different syntax
20:39:10 <reilly> since the code we'e pasted back and forth is actually a simplification
20:39:30 <reilly> and I'll be retrofiting what you did into more complex circumstances
20:39:44 <ChilliX> What the new impl of GADTs will do is just desugar a standard GADT def into the orrespomnding one with equalities
20:40:14 <ChilliX> basically, given
20:40:33 <ChilliX> data T a where C :: T MyType
20:40:38 <ChilliX> rewrite to
20:40:55 <ChilliX> data T a where C :: a ~ MyType => T a
20:41:09 <ChilliX> once I fixed GHC, it will do that rewriting automatically
20:41:58 <kilimanjaro> Is that just saying that if I have "type Foo = Bar" and then an instance declaration for Bar it doesn't carry over for Foo? Or is there something else?
20:42:06 <ChilliX> There is one caveat though.  Currently, when you use explicit equality contexts (ie, the ~ constraints), you may run into some other bugs, namely the ones that I want to remove before making the change to GADT type checking.
20:42:39 <reilly> where's the doc on ~ in type signatures?
20:42:53 <reilly> equality constraints
20:42:54 <ChilliX> kilimanjaro: In basic H98, you cannot use a type synonym in an instance decl, but GHC allows this as an extension.
20:43:13 <kilimanjaro> ahh
20:43:28 <kilimanjaro> is there something similar for classes? like a class synonym?
20:43:28 <ChilliX> well, there is some docs here: http://haskell.org/haskellwiki/GHC/Type_families#Equality_constraints
20:43:30 <reilly> ChilliX, thank you so much, BTW.
20:43:30 <lambdabot> Title: GHC/Type families - HaskellWiki, http://tinyurl.com/33fhy7
20:44:16 <ChilliX> You may also want to have a look at http://www.cse.unsw.edu.au/~chak/papers/tyfuns.pdf
20:44:22 <kilimanjaro> The reason I ask is I have a pretty general class but a lot of the instances are going to have a particular run time property that isn't really enforcable by the type system, but I'd still like to syntactically denote that they are special in this way
20:44:35 <kilimanjaro> because not all of them will have that
20:45:03 <kilimanjaro> err, not all of them will have this property, but it certainly is a distinguishing factor
20:45:19 <reilly> The type function paper was my primary source for understanding type families
20:45:27 <ChilliX> reilly: np - sorry, that this is all still somewhat flakey, it just takes a while to iron out all the various type family bugs and interaction with other features, such as GADTs
20:45:41 <conal> kilimanjaro: just don't try to give different instances for different synonyms of the same type.
20:46:09 <ChilliX> reilly: ah, ok - there is not much else in the way of docs right now
20:46:26 <ChilliX> but feel free to ask here or on the mailing lists if you have other problems
20:46:34 <reilly> i know this probably sounds like bashing one's head against the wall, but I've been thinking about taking Oleg's HList stuff and restating it using type families
20:46:43 <reilly> GHC Users, right?
20:46:48 <kilimanjaro> conal, what do you mean?
20:47:07 <ChilliX> reilly: re HList, that'll surely be fun ;)
20:47:12 <ChilliX> yeah, GHC users
20:47:13 <alexj> reilly: I created a simplified version of HList in HAppS.
20:47:13 <kilimanjaro> conal, i'm wondering if there is a way to have some sort of "class synonym"
20:47:29 <alexj> if you need an easier to use version.
20:47:42 <reilly> the type families approach is *so* much less obfuscatory for tpye functions than functional dependencies
20:47:48 <alexj> anyone know if there is any haskell or templatehaskell syntax to support multiline strings?
20:48:17 <reilly> alexj: Hi alex!  I was thinking of doing it for the exercise, not because i need it
20:48:27 <ChilliX> kilimanjaro: see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#undecidable-instances
20:48:28 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
20:48:29 <conal> kilimanjaro: if you define a type X and then define synonyms A = X and B = X, then I don't think you'd get away with declaring instances for A and B of the same class.  Is that what you wanted to do?
20:48:38 <dons> alexj: you know about string gaps?
20:48:47 <alexj> dons: no what are they?
20:48:48 <dons> > "foo\                  \ is a gap"
20:48:50 <lambdabot>  "foo is a gap"
20:48:55 <ChilliX> reilly: I am glad to hear that you think type families improve the situation
20:48:59 <dons> which can have other stuff in the gap
20:49:12 <dons> good for multiline literals (and unboxed literals)
20:49:19 <alexj> yeah, but that is ugly.  would be nice to have the equivalent of pythons """ multiline """
20:49:45 <dons> ah well, we has what we has
20:49:57 <alexj> oh, I think I just figured out a hacky way to do it.
20:50:02 <kilimanjaro> conal, no, I was a bit confused earlier, but what I would really like is to define class Foo .... and then have a synonym for this class, Bar, so that I can give instance declarations for Bar, purely as a way to distinguish instances of Foo that happen to have a particular property
20:50:16 <alexj> you can read files in templatehaskell....
20:50:40 <conal> kilimanjaro: and you won't declare instances for Foo as well?
20:50:46 <reilly> ChilliX:  I think it's a huge step forward for metaprogramming.   I've long felt that Haskell and ML have each had half the answer for computing over types.  I think type families is a big step in the right direction
20:51:41 <ChilliX> :)
20:51:42 <reilly> every time I write an ML program, I miss type classes.  Every time I write a haskell program I miss ML functors
20:52:17 <Pseudonym> The solution is obvious.
20:52:21 <Pseudonym> Implement one for the other.
20:52:23 <kilimanjaro> conal, right, the actual operations are the same for both, but I'd like a way to distinguish between the two on a syntactic level, for the sake of documentation. it's not really a big deal, I can always comment if it becomes an issue
20:52:25 <thermoplyae> i've spent a lot of time in OCaml lately, and i pine for classes every time i open the interpreter
20:52:26 <reilly> can we get type level integers some day (as opposed to peano arithmetic)?
20:52:40 <dons> that's an faq :)
20:52:43 <conal> kilimanjaro: got it.
20:53:01 <Pseudonym>  ?kind LengthList
20:53:01 <reilly> dons: was that to my question?
20:53:09 <Pseudonym> <lambdabot> Int -> * -> *
20:53:09 <ChilliX> reilly: yes, we should have them soon (as far as I am concerned)
20:53:27 <dons> type level integers are the most requested single type system extension in this channel
20:53:41 <ChilliX> reilly: it's just that we have to sort out the bugs first, then we can make things more convenient to use
20:54:04 <dons> now, if this was ruby, we'd make it convenient, then sort out the bugs :)
20:54:13 <kilimanjaro> conal, in particular, I'm implementing some basic algebra stuff, and from a type signature perspective the basic item I am working with is a ring, but there are quite a few different ones in practice, you have commutative rings, where a*b = b*a, and that's not really a property that can be enforced by the type system, but it is distinguished as far as algebra is concerned
20:54:35 <ChilliX> dons: GHC's frontend actually already has them, so it would be pretty easy
20:54:44 <reilly> dons: I like some idea of correctness, so I'm willing to wait
20:54:49 <sorear> there is an obvious correct solotion... it's just ugly
20:54:54 <ChilliX> I guess it's then also a matter of providing some standard library for type-level programming
20:55:44 <dons> ChilliX: yeah, i've noticed the lexer support
20:55:48 <sorear> reilly: look up  presburger arithmetic, the omega test, and dependant ml... it's been done, and works well, but it's a huge ad-hoc extension to the compiler, adding a decision procedure for first order addition to the context reducer
20:55:51 <dons> :k 1
20:55:53 <lambdabot> *
20:55:54 <dons> e.g.
20:55:57 <sorear> :k 2
20:55:58 <kilimanjaro> conal, and there are a few other situations as well, an integral domain is a special kind of ring but still a ring, with a distinguishing property, and it would be nice to embrace this in the type system, even if it is in a way that doesn't add any safety
20:55:59 <lambdabot> Only unit numeric type pattern is valid
20:56:07 <dons> simple extension :)
20:56:08 <reilly> sorear: thanks, I will
20:56:58 <sorear> ChilliX: not so sure it's for that... 1 is (), the unit in the semiring of types, a Generic Haskell feature not the seeds of natkinds
20:57:28 <reilly> BTW, is there a definitive document on kinds in haskell and/or GHC?
20:58:04 <ChilliX> reilly: for GHC, I fear not...
20:58:14 <ChilliX> sorear: yeah, but we can reuse the code
20:58:57 <reilly> the haskell 98 report is, well, terse on the subject
20:59:42 <reilly> will I find a more illuminating discussion in Pierce?
20:59:50 <sorear> reilly: yeah, and for ghc it isn't even documented!
20:59:57 <reilly> ouch
21:00:04 <sorear> reilly: good luck finding any information on the '!' kind
21:00:05 <ChilliX> h98 kinds are simple: * and k -> k
21:00:15 <ChilliX> for ghc, it's a bit of a mess
21:00:25 <ChilliX> and I believe it is only documented in the compiler source
21:00:28 <sorear> reilly: I have a hunch it's for unpointed boxed types
21:00:42 <sorear> @ki GHC.Prim.ByteArray#
21:00:44 <lambdabot> !
21:01:48 <ChilliX> http://darcs.haskell.org/ghc/compiler/types/Type.lhs
21:02:09 <ChilliX> search for "Kind Stuff"
21:10:47 <kilimanjaro> conal, ohh, I'm stupid, I found an easy way to do exactly what I wanted
21:11:10 <kilimanjaro> conal, class (Foo a) => Bar a
21:11:46 <kilimanjaro> for some reason I just assumed you had to have content in a class declaration
21:15:18 <conal> kilimanjaro: that's not quite a class synonym.  if you have a definition requiring a Bar type, then a Foo type won't suffice.
21:15:43 <conal> kilimanjaro: but it may do fine for your purposes.
21:16:27 <kilimanjaro> yea now that I think about it, it's pretty much exactly what I need, but maybe not what I was asking for :)
21:16:45 <conal> kilimanjaro: good enough then!
21:16:57 <kilimanjaro> I have one more question
21:18:12 <kilimanjaro> part of my class definition is that any instance must have some distinguished element. but I'm not sure how to get the types right on this one, if I just have class Foo a where special :: a
21:18:28 <kilimanjaro> then there's no way it can figure out which instance I am referring to
21:18:39 <kilimanjaro> when I actually try to get the value associated with special
21:18:48 <omnId> special :: SomeType
21:18:57 <omnId> instance Foo SomeType
21:19:10 <omnId> > maxBound :: Int
21:19:12 <lambdabot>  2147483647
21:19:14 <omnId> @src Bounded
21:19:15 <lambdabot> class  Bounded a  where
21:19:15 <lambdabot>     minBound, maxBound :: a
21:19:54 <omnId> usually you don't need the type annotation if there's enough context around it to infer the correct type.
21:20:21 <omnId> > [minBound .. ' ']
21:20:22 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
21:20:33 <geocalc> how can o auto generate call for all libs on my linux ?
21:20:53 <geocalc> s/o/i*
21:21:02 <kilimanjaro> omnId, but how could it ever infer which instance to get the value from
21:21:02 <conal> because Haskell type-inference (like ML and unlike C & Java) uses constraint solving (specifically unification), rather than bottom-up.
21:21:46 <conal> > maxBound - (1 :: Int)
21:21:48 <lambdabot>  2147483646
21:21:52 <kilimanjaro> ahh
21:22:01 <omnId> kilimanjaro: in [minBound .. 'a'], this desugars to enumFromTo minBound 'a', and enumFromTo :: Enum a => a -> a -> [a], i.e. the type of 'a' is unified with the type of minBound
21:22:11 <kilimanjaro> gotcha
21:22:40 <omnId> > mzero :: [Int]
21:22:41 <lambdabot>  []
21:22:57 <omnId> > mempty :: Int
21:22:58 <lambdabot>   add an instance declaration for (Monoid Int)
21:22:58 <lambdabot>     In the expression: mempty
21:22:58 <lambdabot> ...
21:23:14 <conal> > mempty :: Sum Int
21:23:16 <lambdabot>  Sum {getSum = 0}
21:23:23 <omnId> :)
21:23:29 <conal> > mempty :: Product Int
21:23:30 <lambdabot>  Product {getProduct = 1}
21:25:45 <geocalc> no client for my question ?
21:27:16 <conal> geocalc: i don't understand the question.  do you want random procedure calls?
21:28:18 <geocalc> no i want haskell able to call everything conal
21:28:53 <Cale> geocalc: You can FFI import things, but bindings generally take at least a little bit of work.
21:28:56 <conal> geocalc: oh -- you want Haskell interfaces to all of your programming libraries, right?
21:29:02 <lokimaf_> hey where is that haskell-gentoo portage uplink?
21:29:25 <Cale> geocalc: There's the problem of marshalling C values and structures into Haskell values.
21:29:58 <geocalc> and for c++ ?
21:30:03 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
21:30:03 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0 An Addendum to the Haskell 98 Repo ...
21:30:16 <Cale> C++ can be done, but it's more awkward.
21:30:43 <Cale> IIRC, you have to know the mangled names for things.
21:30:51 <lokimaf> say does anyone need a SAT solver? I just wrote a generic one that can solve any solveable SAT problem
21:31:02 <lokimaf> in haskell
21:31:06 * kalmar wonders why he was always scared of Control.Applicative
21:31:32 <lokimaf> in a non-deterministic amount of time
21:32:09 <Cale> lokimaf: cool.
21:32:18 <Cale> lokimaf: Perhaps something to add to Hackage?
21:32:34 <Sgeo> G'night
21:33:06 <omnId> kalmar: there's nothing new there if you have Control.Monad reasonably well understood.
21:33:13 <lokimaf> what's hackage?
21:33:24 <lokimaf> or where?
21:33:31 <lokimaf> @uri hackage
21:33:31 <omnId> @where hackage
21:33:31 <lambdabot> http://hackage.haskell.org/
21:33:32 <lambdabot> http://hackage.haskell.org/
21:33:40 <omnId> haskell packages
21:33:53 <lokimaf> cool i'll look into it :-)
21:34:03 <lokimaf> thanks
21:34:05 <kalmar> omnId: well I was also scared of Control.Monad.ap
21:34:07 <kalmar> :/
21:34:11 <omnId> :)
21:34:16 <kalmar> <*> looks less scary than ap
21:34:23 <kalmar> ?
21:34:42 <kalmar> I dunno, but I read enough to make things a bit nicer in the parser I am currently writing
21:34:59 <kalmar> is there a reason why there is no instance Monad m => Applicative m?
21:35:17 <conal> kalmar: just historical i think.  (monads came first.)
21:35:19 <omnId> should be class Applicative m => Monad m
21:35:51 <omnId> hysterical raisons
21:35:52 <kalmar> yeah but in the backwards way you might as well make every monad applicative?
21:35:57 <Cale> kalmar: It would need overlapping instances.
21:36:01 <kalmar> ahh
21:36:04 <kalmar> stupid overlapping instances
21:36:15 <kalmar> are they h'?
21:36:32 <conal> a bigger problem is that instance selection just does head matching.  doesn't backtrack.
21:36:55 <conal> so -fallow-overlapping-instances doesn't help.
21:46:14 <Pseudonym> let-polymorphism is also NP-hard.  It doesn't sound like more backtracking would hurt THAT much.
21:47:15 <conal> Pseudonym: I doubt that argument would fly, but I'd still love to have a real logic programming language in the type class/instance system.
21:47:41 <Pseudonym> Yeah, I know. :-)
21:47:57 <Pseudonym> let-polymorphism is only a problem if there's an insane amount of polymorphism.
21:48:05 <Pseudonym> Fact is, most types are monotypes.
21:48:16 <Pseudonym> And of those that aren't, most functions have signatuers.
21:58:24 <dmwit> So, is this accurate: "class" is used to create parametric polymorphism, and type variables without class restrictions signify ad-hoc polymorphism.
21:58:39 <kalmar> I don't think so
21:58:42 <Pseudonym> No.
21:58:44 <kalmar> class: bounded polymorphism
21:58:47 <omnId> other way 'round
21:58:53 <Pseudonym> Kind of.
21:58:55 <kalmar> without restrictions: parametric polymorphism
21:58:57 <kalmar> ?
21:59:03 <Pseudonym> Haskell doesn't have ad-hoc polymorphism.
21:59:16 <Pseudonym> Yes.  "forall" is parametric polymorphism.
21:59:33 <conal> it has "less ad hoc" ad hoc polymorphism
21:59:45 <kalmar> yay wadler
22:00:38 <Pseudonym> http://andrew.bromage.org/phillip.jpeg
22:11:15 <geocalc> Cale=<<  and for asm ???
22:15:01 <lokimaf> hmmm I made a SAT solver and a SAT generator as 2 seperate .hs files,  could i have two executables? or should I have 2 packages?
22:15:54 <geocalc> or one
22:17:17 <lokimaf> well i'd prefer just the one package with 2 executables
22:18:20 <lokimaf> as the SATGenerator creates problems for the SATSolver to solve, though they are standard CNF so are appropriate for any SAT solvers as input
22:19:05 <lokimaf> the SATGenerator.hs is 31 lines of code
22:19:44 <Pseudonym> Sounds like a module, then.
22:19:58 <lokimaf> SATSolver.hs is 130 lines
22:20:05 <Pseudonym> Hey, maybe you could turn it into a QuickCheck generator.
22:20:30 <lokimaf> what's QuickCheck ?
22:21:03 <Pseudonym> QuickCheck is how Haskellers get away with not writing unit tests.
22:21:17 <lokimaf> @uri QuickCheck
22:21:18 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
22:22:23 <dmwit> I wonder what uri spell-corrects to.
22:22:31 <lokimaf> well there seems to already in existance wheras there is no Haskell SAT solver, and SAT problems are considered most essential in the field of AI
22:22:38 <Pseudonym> ?urine QuickCheck
22:22:49 <dmwit> ah, ?url
22:23:23 <lokimaf> indeed my prof claims they are the last frontier of AI
22:23:34 <lokimaf> or some such
22:23:50 <dmwit> lokimaf: I think what Pseudonym means is that you could use quickcheck to make a more idiomatic SAT generator.
22:24:00 <Pseudonym> I kinda doubt it.
22:24:25 <lokimaf> well the SATGenerator works fine
22:24:30 <Pseudonym> SAT is, in a formal sense, equivalent to any other NP-hard problem.
22:24:36 <lokimaf> as does the solver..
22:24:41 <Pseudonym> And there are plenty of other AI problems that are harder.
22:25:13 <lokimaf> like?
22:25:37 <Pseudonym> Playing go. :-)
22:25:47 <sorear> so if we had efficient sat solvers, computers would be able to program?
